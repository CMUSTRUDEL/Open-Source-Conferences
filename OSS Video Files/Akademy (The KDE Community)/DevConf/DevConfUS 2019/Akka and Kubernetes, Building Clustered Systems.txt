Title: Akka and Kubernetes, Building Clustered Systems
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Hugh McKee

One of the best features of Akka is Akka Cluster. Akka cluster allows for building distributed applications, where one application or service spans multiple nodes. From its initial release in 2013, Akka Cluster needed a node management system to manage the Akka nodes and to provide a resilient and elastic platform. With Kubernetes Akka finally has the node management system that is has been waiting for. Akka Cluster has been designed to gracefully handle nodes leaving and joining a running cluster while continuing to run. Kubernetes adds and removes nodes as needed to increase capacity or to recover from failures. In this talk, we will look at and demonstrate how Akka Java Cluster and Kubernetes work together and how together they form a beautiful relationship.
Captions: 
	00:00:06,270 --> 00:00:15,300
hello everyone so we'll have humic e

00:00:11,610 --> 00:00:19,350
presenting you akka and kubernetes blue

00:00:15,300 --> 00:00:22,190
building clustered systems today yeah I

00:00:19,350 --> 00:00:25,980
can go ahead all right thank you

00:00:22,190 --> 00:00:29,400
everyone like she said my name is Jim

00:00:25,980 --> 00:00:31,920
Mackey I'm a developer advocate I work

00:00:29,400 --> 00:00:36,960
for company called lifeand a better life

00:00:31,920 --> 00:00:38,760
end so some hub at Scala and you've

00:00:36,960 --> 00:00:40,380
heard of Scala so with a company buying

00:00:38,760 --> 00:00:43,110
Scala one of the cofounders of our

00:00:40,380 --> 00:00:46,440
company martin order ski is the creator

00:00:43,110 --> 00:00:49,040
of Scala the other co-founder company is

00:00:46,440 --> 00:00:51,899
jonas pannier who's the creator of akka

00:00:49,040 --> 00:00:56,070
scala is a functional object functional

00:00:51,899 --> 00:00:59,760
language on the JVM akka is the actor

00:00:56,070 --> 00:01:04,680
model implemented on the JVM with Scala

00:00:59,760 --> 00:01:07,610
and Java API s and today I'm going to be

00:01:04,680 --> 00:01:10,770
talking about running akka and

00:01:07,610 --> 00:01:13,170
kubernetes just real briefly though as I

00:01:10,770 --> 00:01:16,619
mentioned my company is a company buying

00:01:13,170 --> 00:01:18,240
Scala Anaka which are all open source

00:01:16,619 --> 00:01:19,920
but there's two other frameworks called

00:01:18,240 --> 00:01:22,650
play which is a web services framework

00:01:19,920 --> 00:01:25,680
all asynchronous has been asynchronous

00:01:22,650 --> 00:01:28,110
since before asynchronous became cool

00:01:25,680 --> 00:01:30,409
reactive programming became cool and

00:01:28,110 --> 00:01:34,500
then logon which is a relatively new

00:01:30,409 --> 00:01:36,960
micro services framework again all open

00:01:34,500 --> 00:01:40,229
source but really here here today to

00:01:36,960 --> 00:01:43,920
talk about running akka the actor model

00:01:40,229 --> 00:01:47,009
on kubernetes because akka has been a

00:01:43,920 --> 00:01:48,619
platform that can run in a cluster for a

00:01:47,009 --> 00:01:50,750
long time

00:01:48,619 --> 00:01:53,600
so you have an actor/model that runs in

00:01:50,750 --> 00:01:55,820
a JVM but it can run as a like a single

00:01:53,600 --> 00:01:59,509
system running in a cluster of GM's and

00:01:55,820 --> 00:02:01,939
a very kind of tightly coupled cluster

00:01:59,509 --> 00:02:04,579
of services where actors are talking to

00:02:01,939 --> 00:02:06,890
each other across this cluster and we

00:02:04,579 --> 00:02:08,720
needed an orchestration platform for

00:02:06,890 --> 00:02:12,700
long time Macca's ten years old ah

00:02:08,720 --> 00:02:16,010
co-clustering is around came out around

00:02:12,700 --> 00:02:17,390
2013 and since that we've been really

00:02:16,010 --> 00:02:19,459
kind of waiting for something like

00:02:17,390 --> 00:02:21,349
career days go along to manage running

00:02:19,459 --> 00:02:26,120
all the JVM s force and that's pretty

00:02:21,349 --> 00:02:28,519
what I want to show you here but so part

00:02:26,120 --> 00:02:32,780
of it is so is the kind of showing you

00:02:28,519 --> 00:02:35,900
actors running in kubernetes so you guys

00:02:32,780 --> 00:02:37,819
heard of the actor model before anybody

00:02:35,900 --> 00:02:42,049
use any kind of actor model like an ER

00:02:37,819 --> 00:02:45,260
laying or vertex kind of does the actor

00:02:42,049 --> 00:02:47,150
model a little bit but the extra metal

00:02:45,260 --> 00:02:51,470
has actually been around for a long time

00:02:47,150 --> 00:02:54,910
that was originally proposed back in the

00:02:51,470 --> 00:02:58,639
early 70s by a guy named Carl Hewitt and

00:02:54,910 --> 00:03:00,889
it's been in use you know earlier was

00:02:58,639 --> 00:03:03,819
one of its first usages for it it was

00:03:00,889 --> 00:03:06,920
used often in things like phone systems

00:03:03,819 --> 00:03:09,230
systems that had to run all the time had

00:03:06,920 --> 00:03:10,790
to be able to go through hardware

00:03:09,230 --> 00:03:12,109
failures and keep running had to go

00:03:10,790 --> 00:03:14,090
through software upgrades and keep

00:03:12,109 --> 00:03:15,859
running things like that and the actor

00:03:14,090 --> 00:03:18,079
model really worked out to be a nice way

00:03:15,859 --> 00:03:21,150
for doing that

00:03:18,079 --> 00:03:22,859
but I in order to kind of describe a

00:03:21,150 --> 00:03:25,379
little bit by the actor model if you're

00:03:22,859 --> 00:03:28,200
not familiar with it is I stole this

00:03:25,379 --> 00:03:30,180
these first few sentences from the

00:03:28,200 --> 00:03:32,640
Wikipedia definition of the actor model

00:03:30,180 --> 00:03:35,760
which I thought was really very concise

00:03:32,640 --> 00:03:37,319
and very well-written so I just I stole

00:03:35,760 --> 00:03:40,430
this I'm gonna walk walk through this a

00:03:37,319 --> 00:03:42,180
little bit so the actor model is a

00:03:40,430 --> 00:03:45,030
mathematical model which is a little

00:03:42,180 --> 00:03:46,799
scary but don't let it for you find

00:03:45,030 --> 00:03:49,200
concurrent computing so one of his big

00:03:46,799 --> 00:03:50,700
things with the actor model is this very

00:03:49,200 --> 00:03:53,700
very good at concurrent computing which

00:03:50,700 --> 00:03:55,290
means is very good at threading so if

00:03:53,700 --> 00:03:57,599
you ever done any kind of threading

00:03:55,290 --> 00:03:59,629
thread based programming you know

00:03:57,599 --> 00:04:02,939
especially like in a language like Java

00:03:59,629 --> 00:04:07,769
it can become pretty pretty wild pretty

00:04:02,939 --> 00:04:09,569
fun and difficult to do right but the

00:04:07,769 --> 00:04:11,159
objective is to do thing a lot of things

00:04:09,569 --> 00:04:14,189
can currently run multiple threads at

00:04:11,159 --> 00:04:16,560
the same time with the actor model the

00:04:14,189 --> 00:04:18,539
doing things concurrently becomes a lot

00:04:16,560 --> 00:04:19,919
easier it's a lot more intuitive and

00:04:18,539 --> 00:04:26,490
hopefully you'll see a little bit of

00:04:19,919 --> 00:04:27,900
that so but the with actors there I've

00:04:26,490 --> 00:04:29,820
heard people cite you know saying well

00:04:27,900 --> 00:04:33,479
the actor model or a new coding in

00:04:29,820 --> 00:04:37,560
actors is hard but to me you know I

00:04:33,479 --> 00:04:42,720
started I picked up using naka back

00:04:37,560 --> 00:04:44,699
around 2000 14 or so and I've been

00:04:42,720 --> 00:04:46,500
programming for a long time working with

00:04:44,699 --> 00:04:48,539
Java since it came out in the 90s all

00:04:46,500 --> 00:04:51,120
that kind of stuff and I came across the

00:04:48,539 --> 00:04:51,630
actor model and I thought I'd died and

00:04:51,120 --> 00:04:54,419
gone to heaven

00:04:51,630 --> 00:04:55,949
I mean it was like the coolest stuff I'd

00:04:54,419 --> 00:04:58,169
ever worked on as far as building a

00:04:55,949 --> 00:05:00,539
system it took a little bit for me to

00:04:58,169 --> 00:05:03,840
kind of wrap my head around doing

00:05:00,539 --> 00:05:05,940
building systems with with actors but

00:05:03,840 --> 00:05:08,130
the more I got into it it just got more

00:05:05,940 --> 00:05:09,570
and more fun and it was awesome where I

00:05:08,130 --> 00:05:12,570
could solve problems that I just

00:05:09,570 --> 00:05:15,450
couldn't dream of solving before

00:05:12,570 --> 00:05:18,060
and one way I'd like to kind of maybe

00:05:15,450 --> 00:05:20,520
try to explain fundamentally what actors

00:05:18,060 --> 00:05:22,290
are I mean you write them in software in

00:05:20,520 --> 00:05:24,540
Java you just write them as a Java class

00:05:22,290 --> 00:05:27,120
and I'll show you some code and so on

00:05:24,540 --> 00:05:28,500
and now it's done but it's one way to

00:05:27,120 --> 00:05:31,500
think of it is is a fundamental building

00:05:28,500 --> 00:05:33,930
block with very simple characteristics

00:05:31,500 --> 00:05:36,150
kind of like a Lego block Lego blocks

00:05:33,930 --> 00:05:38,250
are very fundamental with very simple

00:05:36,150 --> 00:05:41,760
characteristics so you can build things

00:05:38,250 --> 00:05:43,350
with them but just like with Lego blocks

00:05:41,760 --> 00:05:45,450
where you can build systems that are

00:05:43,350 --> 00:05:46,710
things that are really cool like you

00:05:45,450 --> 00:05:49,350
know I got just grabbed this picture

00:05:46,710 --> 00:05:52,080
somebody built this castle out of Lego

00:05:49,350 --> 00:05:56,660
blocks you can use actors to build

00:05:52,080 --> 00:05:56,660
really powerful sophisticated systems

00:05:56,889 --> 00:06:02,500
so with an actor though the only way you

00:05:59,560 --> 00:06:05,379
talk to an actor is by sending it a

00:06:02,500 --> 00:06:08,439
message an asynchronous message so it's

00:06:05,379 --> 00:06:10,780
kind of like you and I texting you send

00:06:08,439 --> 00:06:12,789
me a text message it's a pretty an

00:06:10,780 --> 00:06:14,889
asynchronous message I get that message

00:06:12,789 --> 00:06:17,979
you're free to go on and send other

00:06:14,889 --> 00:06:19,539
messages to other people or do other

00:06:17,979 --> 00:06:21,759
things those types of things that's

00:06:19,539 --> 00:06:24,219
exactly the way say one after talking

00:06:21,759 --> 00:06:26,560
another actor works and that one actor

00:06:24,219 --> 00:06:27,909
sends a message to another actor it's an

00:06:26,560 --> 00:06:32,550
asynchronous message

00:06:27,909 --> 00:06:34,810
now when a actor gets that message it

00:06:32,550 --> 00:06:37,029
does things like it can make local

00:06:34,810 --> 00:06:38,860
decisions so it's you know it's just a

00:06:37,029 --> 00:06:41,590
class there's a method where the method

00:06:38,860 --> 00:06:44,139
thing of the message comes in the

00:06:41,590 --> 00:06:45,430
methods invoked and that triggers the

00:06:44,139 --> 00:06:48,819
code and the clot you know and in the

00:06:45,430 --> 00:06:49,900
actor class to start doing stuff so it's

00:06:48,819 --> 00:06:51,639
you know it's like what do I do with

00:06:49,900 --> 00:06:53,020
this message how do I handle it so you

00:06:51,639 --> 00:06:55,120
know it's just now you're in regular

00:06:53,020 --> 00:06:56,950
code handling it so I can make local

00:06:55,120 --> 00:06:59,380
decisions

00:06:56,950 --> 00:07:01,570
Rick it's fun to is you can do things

00:06:59,380 --> 00:07:03,940
like one actor can create other actors

00:07:01,570 --> 00:07:06,460
so you can create a hierarchy of actors

00:07:03,940 --> 00:07:08,710
and it's also a form of delegation and

00:07:06,460 --> 00:07:10,780
concurrency so say one actor gets the

00:07:08,710 --> 00:07:14,920
message to do some you know asking it to

00:07:10,780 --> 00:07:17,080
do something that actor intern delegates

00:07:14,920 --> 00:07:19,720
that work out to other X's maybe there's

00:07:17,080 --> 00:07:22,450
you know part 1 part 2 part 3 part 4 of

00:07:19,720 --> 00:07:24,670
the task to be done those tasks can be

00:07:22,450 --> 00:07:26,500
run concurrently so the actor can say

00:07:24,670 --> 00:07:30,280
you send me a message I'm an actor

00:07:26,500 --> 00:07:32,260
well I send a message to four other

00:07:30,280 --> 00:07:34,690
actors bang bang bang bang and they're

00:07:32,260 --> 00:07:37,180
all running concurrently so I'm working

00:07:34,690 --> 00:07:39,190
on their part of the solution and then

00:07:37,180 --> 00:07:41,440
we're done they send me a message back

00:07:39,190 --> 00:07:43,150
so it's not a request response this

00:07:41,440 --> 00:07:45,280
actor is deliberately receiving a

00:07:43,150 --> 00:07:47,410
message reacting to it

00:07:45,280 --> 00:07:49,840
performing some kind of a thing like

00:07:47,410 --> 00:07:54,130
delegating out to other actors and maybe

00:07:49,840 --> 00:07:56,320
sending other messages so an actor in

00:07:54,130 --> 00:07:58,030
response to getting a message can send

00:07:56,320 --> 00:08:02,020
more messages which is kind of what I

00:07:58,030 --> 00:08:05,350
just explained this one's really kind of

00:08:02,020 --> 00:08:09,010
fun and powerful in that when an actor

00:08:05,350 --> 00:08:11,260
gets a message it can decide how it's

00:08:09,010 --> 00:08:14,830
going to react to the next message that

00:08:11,260 --> 00:08:16,780
it gets so in a quick example is say and

00:08:14,830 --> 00:08:18,970
this is just by design we're developers

00:08:16,780 --> 00:08:22,360
we're implementing our actors and say an

00:08:18,970 --> 00:08:24,880
actor gets the message and the by design

00:08:22,360 --> 00:08:26,710
this actor is in an idle state so it's

00:08:24,880 --> 00:08:27,910
meaning meaning that it's ready it's

00:08:26,710 --> 00:08:30,250
just sitting there waiting for something

00:08:27,910 --> 00:08:32,650
to do so gets the message and as soon as

00:08:30,250 --> 00:08:33,970
it gets that message it decides that

00:08:32,650 --> 00:08:36,310
it's no longer an and I don't say this

00:08:33,970 --> 00:08:38,740
in an active state so if it gets another

00:08:36,310 --> 00:08:41,080
message asking it to do something the

00:08:38,740 --> 00:08:43,420
way it reacts to that second message is

00:08:41,080 --> 00:08:46,330
different than the way we react to that

00:08:43,420 --> 00:08:47,800
same message type a message when it was

00:08:46,330 --> 00:08:49,720
an idle state when it's an idle

00:08:47,800 --> 00:08:52,150
statement and he gets the message hey

00:08:49,720 --> 00:08:54,310
can you do this it goes okay yeah I can

00:08:52,150 --> 00:08:56,350
do it if it's an inactive state when it

00:08:54,310 --> 00:08:59,170
gets the message hey can you do this the

00:08:56,350 --> 00:09:00,559
response is no I can so say the scenario

00:08:59,170 --> 00:09:01,939
is

00:09:00,559 --> 00:09:04,549
I get a message asking me to do

00:09:01,939 --> 00:09:06,529
something I still a gated work out to a

00:09:04,549 --> 00:09:08,799
bunch of other actors they're doing

00:09:06,529 --> 00:09:11,929
their thing and I'm just sitting there

00:09:08,799 --> 00:09:13,969
my this actors not doing anything I get

00:09:11,929 --> 00:09:14,569
another man messages asking me if I can

00:09:13,969 --> 00:09:16,719
do something

00:09:14,569 --> 00:09:19,479
my response is nope I can't I'm busy

00:09:16,719 --> 00:09:21,799
right even though I'm not really busy is

00:09:19,479 --> 00:09:24,589
these delegate actors that aren't

00:09:21,799 --> 00:09:28,009
currently busy okay so it's just it's

00:09:24,589 --> 00:09:30,049
kind of a unique characteristic of how

00:09:28,009 --> 00:09:31,969
you program an actor's but this is this

00:09:30,049 --> 00:09:35,389
how do you react to the next message

00:09:31,969 --> 00:09:36,739
type of thing the other thing that's

00:09:35,389 --> 00:09:38,719
really interesting though and this is

00:09:36,739 --> 00:09:41,449
where the concurrency part comes in is

00:09:38,719 --> 00:09:44,359
that the only way the state of an actor

00:09:41,449 --> 00:09:46,669
is can be changed as we're in response

00:09:44,359 --> 00:09:49,699
to a message so it's very different from

00:09:46,669 --> 00:09:51,649
say the object model where you know one

00:09:49,699 --> 00:09:54,019
object has referenced to another object

00:09:51,649 --> 00:09:56,419
it can invoke methods on that object and

00:09:54,019 --> 00:09:58,489
how the state of that object is being

00:09:56,419 --> 00:10:01,369
changed could be you know being changed

00:09:58,489 --> 00:10:03,559
by multiple other objects this deal is

00:10:01,369 --> 00:10:06,349
you've got to use locks and things like

00:10:03,559 --> 00:10:08,299
to have to handle concurrency with an

00:10:06,349 --> 00:10:09,709
actor there's a real clean break it's

00:10:08,299 --> 00:10:13,520
the only way you talk to an actor is to

00:10:09,709 --> 00:10:17,100
send an exec a synchronous message

00:10:13,520 --> 00:10:21,600
so that's really in in the case of doing

00:10:17,100 --> 00:10:24,780
things concurrently it it avoids the

00:10:21,600 --> 00:10:27,090
needs for using locks which you know

00:10:24,780 --> 00:10:29,310
like were they in thread based

00:10:27,090 --> 00:10:32,190
programming you would have some maybe a

00:10:29,310 --> 00:10:33,360
synchronous block right which is a which

00:10:32,190 --> 00:10:37,470
is a form of locking

00:10:33,360 --> 00:10:39,540
where thread one has invoked this this

00:10:37,470 --> 00:10:41,220
block of code is running synchronously

00:10:39,540 --> 00:10:43,590
if thread two tries to access it it

00:10:41,220 --> 00:10:45,480
can't it wastes because it's locked out

00:10:43,590 --> 00:10:47,340
it's that kind of an approach with

00:10:45,480 --> 00:10:49,970
actors there's a fundamental different

00:10:47,340 --> 00:10:49,970
approach to it

00:10:50,660 --> 00:10:58,100
so that was a real real quick overview

00:10:54,750 --> 00:11:02,790
of actors it's very very cool I love it

00:10:58,100 --> 00:11:05,430
the kubernetes is the shiny new kid on

00:11:02,790 --> 00:11:08,700
the block I do I go to a lot of

00:11:05,430 --> 00:11:10,260
conferences and it's the one of the big

00:11:08,700 --> 00:11:13,170
topics right now I've already talking

00:11:10,260 --> 00:11:14,700
about it last year I spent a good part

00:11:13,170 --> 00:11:16,650
of the year working with a customer you

00:11:14,700 --> 00:11:19,230
know big enterprise customer customer

00:11:16,650 --> 00:11:21,060
and insurance company who has an

00:11:19,230 --> 00:11:23,840
on-premise kubernetes environment and

00:11:21,060 --> 00:11:25,380
they want to move a lot of their legacy

00:11:23,840 --> 00:11:27,030
applications to it

00:11:25,380 --> 00:11:29,760
and we were working with them helping

00:11:27,030 --> 00:11:34,530
them do that very very cool environment

00:11:29,760 --> 00:11:37,860
but for running clustered actor models

00:11:34,530 --> 00:11:41,100
on an environment kubernetes is like the

00:11:37,860 --> 00:11:42,270
perfect platform for for things like a

00:11:41,100 --> 00:11:45,320
cover

00:11:42,270 --> 00:11:48,320
and as I hope I'll be able to show you

00:11:45,320 --> 00:11:51,330
there there's some real power in

00:11:48,320 --> 00:11:53,670
kubernetes because with kubernetes the

00:11:51,330 --> 00:11:56,100
nice thing is is like I always say you

00:11:53,670 --> 00:11:57,810
know I'm a Java developer I want to

00:11:56,100 --> 00:11:59,459
build my code I want to run it with the

00:11:57,810 --> 00:12:03,510
least amount of friction as possible

00:11:59,459 --> 00:12:05,339
yeah and in the past we did all this all

00:12:03,510 --> 00:12:06,810
this friction all this details that we

00:12:05,339 --> 00:12:08,899
had to deal with we're getting something

00:12:06,810 --> 00:12:11,339
running on a machine somewhere

00:12:08,899 --> 00:12:13,560
kubernetes is like the lowest friction

00:12:11,339 --> 00:12:16,230
environment that I've I personally have

00:12:13,560 --> 00:12:19,580
run into where we kubernetes you

00:12:16,230 --> 00:12:23,070
basically say here's my application you

00:12:19,580 --> 00:12:24,779
define a kind of a file and there's

00:12:23,070 --> 00:12:28,410
other approaches for doing it but one of

00:12:24,779 --> 00:12:30,390
the the original ways was you describe

00:12:28,410 --> 00:12:32,370
what your application looks like the

00:12:30,390 --> 00:12:34,440
kubernetes and it's a declarative

00:12:32,370 --> 00:12:36,420
description it's not an imperative thing

00:12:34,440 --> 00:12:38,190
it's not like run this run that run this

00:12:36,420 --> 00:12:41,220
other thing and so on it's basically

00:12:38,190 --> 00:12:43,380
saying here's my JVM this in the stocker

00:12:41,220 --> 00:12:45,720
image I want you to run this docker

00:12:43,380 --> 00:12:47,930
image for me and I want you to run one

00:12:45,720 --> 00:12:51,209
instance or n number of instances and

00:12:47,930 --> 00:12:53,730
you take a kubernetes and you take care

00:12:51,209 --> 00:12:58,079
of the rest so things like when you just

00:12:53,730 --> 00:13:01,170
just declare this to kubernetes what

00:12:58,079 --> 00:13:03,839
kubernetes is doing is that it starts

00:13:01,170 --> 00:13:08,040
running our jar right our jars running

00:13:03,839 --> 00:13:10,890
say say it's it gets a hit in traffic

00:13:08,040 --> 00:13:12,860
and you've defined the you declared the

00:13:10,890 --> 00:13:15,209
Cooper days I want this to auto scale

00:13:12,860 --> 00:13:18,240
Cabernets will scale it up for you scale

00:13:15,209 --> 00:13:21,959
up scale it down even better on the on

00:13:18,240 --> 00:13:24,510
the resilience side if you say the

00:13:21,959 --> 00:13:27,480
underlying infrastructure where your jar

00:13:24,510 --> 00:13:30,620
is running in a docker image dies or has

00:13:27,480 --> 00:13:34,040
a problem kubernetes detects ad

00:13:30,620 --> 00:13:35,600
restart your jar somewhere else in its

00:13:34,040 --> 00:13:38,000
cluster and it you know in its

00:13:35,600 --> 00:13:39,890
environment without us having to write

00:13:38,000 --> 00:13:41,810
any kind of code to do that which is you

00:13:39,890 --> 00:13:45,140
know very very nice so it's this very

00:13:41,810 --> 00:13:48,080
declarative way of describing here's my

00:13:45,140 --> 00:13:49,430
stuff please run it and kubernetes

00:13:48,080 --> 00:13:53,720
really takes over with all the heavy

00:13:49,430 --> 00:13:56,120
lifting part of it so let me show you

00:13:53,720 --> 00:13:58,460
what I've got is I'm running on my

00:13:56,120 --> 00:14:00,230
laptop I'm running a kubernetes

00:13:58,460 --> 00:14:04,960
environment I'm using mini shift which

00:14:00,230 --> 00:14:07,730
is the local version of OpenShift

00:14:04,960 --> 00:14:10,760
people you know a lot of people use mini

00:14:07,730 --> 00:14:13,820
cube I just typically run this

00:14:10,760 --> 00:14:16,070
environment on my on my laptop and I

00:14:13,820 --> 00:14:18,410
like mini shift because it's it's a

00:14:16,070 --> 00:14:24,670
little bit easier to install to many

00:14:18,410 --> 00:14:27,370
cases so just to show you that guts

00:14:24,670 --> 00:14:30,430
this environment running so hopefully

00:14:27,370 --> 00:14:32,680
everything is going there's a

00:14:30,430 --> 00:14:34,240
command-line interface a couple actually

00:14:32,680 --> 00:14:37,600
command-line interfaces that they can

00:14:34,240 --> 00:14:41,160
use and what I said was I said oh so you

00:14:37,600 --> 00:14:44,829
get pods this is the open shift command

00:14:41,160 --> 00:14:47,110
CLI command line interface pods are

00:14:44,829 --> 00:14:49,420
kubernetes definition of running

00:14:47,110 --> 00:14:52,390
something in a pod can run one-time work

00:14:49,420 --> 00:14:54,310
containers so in the case of my

00:14:52,390 --> 00:14:57,279
application I've got three containers

00:14:54,310 --> 00:15:00,190
running in three pods inside those

00:14:57,279 --> 00:15:04,140
containers I'm running as three a single

00:15:00,190 --> 00:15:04,140
JVM so there's three JVM is running her

00:15:05,520 --> 00:15:11,880
now the nice thing is said I can bring

00:15:08,399 --> 00:15:13,980
up a console which looks a lot like the

00:15:11,880 --> 00:15:16,800
real kubernetes console running in a

00:15:13,980 --> 00:15:19,320
real environment not on my laptop and

00:15:16,800 --> 00:15:21,330
I've got some projects to find and the

00:15:19,320 --> 00:15:26,660
project I want to show you is this one I

00:15:21,330 --> 00:15:26,660
just called haka cluster demo and

00:15:27,860 --> 00:15:33,570
so quick

00:15:30,610 --> 00:15:36,640
so you can see in this user interface

00:15:33,570 --> 00:15:40,170
you know again it's showing kind of some

00:15:36,640 --> 00:15:42,430
details about my my application running

00:15:40,170 --> 00:15:45,880
running three paws with a nice big

00:15:42,430 --> 00:15:47,890
circular view of it down below it's got

00:15:45,880 --> 00:15:55,870
more detail information that I can click

00:15:47,890 --> 00:15:58,890
into but when I want to show you is the

00:15:55,870 --> 00:15:58,890
application itself

00:16:02,280 --> 00:16:09,570
so this is a visualization of this this

00:16:07,530 --> 00:16:12,570
app the sample application that got

00:16:09,570 --> 00:16:14,010
running as a NACA application at the end

00:16:12,570 --> 00:16:16,290
of the talk I'll give you the link to

00:16:14,010 --> 00:16:18,570
the github project that has all the

00:16:16,290 --> 00:16:20,330
source code for this project but

00:16:18,570 --> 00:16:25,170
basically what I'm trying to do is show

00:16:20,330 --> 00:16:28,530
a lot of stuff in one single picture so

00:16:25,170 --> 00:16:31,610
this diagram is done using it's a really

00:16:28,530 --> 00:16:35,670
awesome JavaScript library called d3.js

00:16:31,610 --> 00:16:37,470
just you know just something I love it I

00:16:35,670 --> 00:16:39,060
mean it's great for visualizations like

00:16:37,470 --> 00:16:41,460
this visualization is all done with

00:16:39,060 --> 00:16:44,100
d3.js with a little bit of JavaScript

00:16:41,460 --> 00:16:45,390
programming my part very cool if you've

00:16:44,100 --> 00:16:48,810
never used it you want to do some kind

00:16:45,390 --> 00:16:51,960
of awesome visualization of stuff it's

00:16:48,810 --> 00:16:54,840
very powerful go look at the it's got

00:16:51,960 --> 00:16:58,020
samples examples a ton of examples that

00:16:54,840 --> 00:17:01,170
are just awesome any case I'm just

00:16:58,020 --> 00:17:02,130
showing this this running environment so

00:17:01,170 --> 00:17:04,800
you can see there's things happening

00:17:02,130 --> 00:17:06,720
it's kind of moving around and what I'm

00:17:04,800 --> 00:17:10,290
gonna do is kind of just I'll be showing

00:17:06,720 --> 00:17:12,120
you what all this is and we'll be using

00:17:10,290 --> 00:17:14,250
this to kind of see how things happen

00:17:12,120 --> 00:17:18,050
what happens as things changed in the

00:17:14,250 --> 00:17:18,050
kubernetes and NOC environment

00:17:19,690 --> 00:17:27,250
so the visualization somebody in my

00:17:25,120 --> 00:17:29,020
company called it a crop circle so I

00:17:27,250 --> 00:17:32,530
kind of liked that name kind of looks

00:17:29,020 --> 00:17:34,600
like a crop circle but it's as I say

00:17:32,530 --> 00:17:39,580
it's an attempt to show what's running

00:17:34,600 --> 00:17:41,440
here so first off off the center circle

00:17:39,580 --> 00:17:43,840
which is just kind of the root of this

00:17:41,440 --> 00:17:46,840
tree and an off of those three big

00:17:43,840 --> 00:17:48,520
circles there's a whole tree of things

00:17:46,840 --> 00:17:50,950
and every one of those circles the green

00:17:48,520 --> 00:17:54,820
and blue circles are representing

00:17:50,950 --> 00:17:57,540
instances of actors real actors are

00:17:54,820 --> 00:17:57,540
running in this system

00:17:58,350 --> 00:18:05,100
the circles see the real and interesting

00:18:02,279 --> 00:18:06,720
ones here are the blue circles on the

00:18:05,100 --> 00:18:09,090
perimeter the blue circles are where the

00:18:06,720 --> 00:18:10,919
business logic swinging so I'm calling

00:18:09,090 --> 00:18:14,700
an entity and really that's what is used

00:18:10,919 --> 00:18:17,279
for it it is an instance of an actor

00:18:14,700 --> 00:18:19,320
that's handling something like maybe the

00:18:17,279 --> 00:18:20,669
telemetry data coming in from a specific

00:18:19,320 --> 00:18:22,860
IOT device

00:18:20,669 --> 00:18:25,019
it's a device one device to device three

00:18:22,860 --> 00:18:27,059
there would be three blue circles for

00:18:25,019 --> 00:18:30,210
each one of those devices it could be

00:18:27,059 --> 00:18:32,549
say it's a shopping cart application so

00:18:30,210 --> 00:18:34,909
you have n number of customers each

00:18:32,549 --> 00:18:38,100
building their own shopping cart so each

00:18:34,909 --> 00:18:40,740
entity actor is handling the incoming

00:18:38,100 --> 00:18:42,000
requests for a specific shopping cart my

00:18:40,740 --> 00:18:44,460
shopping cart is one of those blue

00:18:42,000 --> 00:18:47,370
circles your shopping cart is another

00:18:44,460 --> 00:18:49,169
one is blue service the green

00:18:47,370 --> 00:18:50,730
interactors there are instances of

00:18:49,169 --> 00:18:53,129
actors and I'll show you the Java code

00:18:50,730 --> 00:18:56,250
behind this in a minute the green

00:18:53,129 --> 00:18:58,019
circles are another type of actor and

00:18:56,250 --> 00:19:01,350
they're called shard actors and the job

00:18:58,019 --> 00:19:03,509
of these actors is to distribute the

00:19:01,350 --> 00:19:05,789
load over the cluster because again

00:19:03,509 --> 00:19:09,240
we're running three jams across the

00:19:05,789 --> 00:19:10,679
network is one running is a single think

00:19:09,240 --> 00:19:13,529
of this as a single micro service

00:19:10,679 --> 00:19:15,899
running you know it can scale up from

00:19:13,529 --> 00:19:17,580
one JVM to n number of JVMs

00:19:15,899 --> 00:19:20,190
right now in this example I'm showing

00:19:17,580 --> 00:19:23,100
you ring three it's a single micro

00:19:20,190 --> 00:19:24,840
service and we need to distribute the

00:19:23,100 --> 00:19:27,000
work across the cluster so there's these

00:19:24,840 --> 00:19:29,940
D sharding actors to do that this green

00:19:27,000 --> 00:19:32,789
one snow in this example application I'm

00:19:29,940 --> 00:19:35,519
running here there's only 15 shards

00:19:32,789 --> 00:19:37,350
there always be 15 shard actors no

00:19:35,519 --> 00:19:39,450
matter how many noes are there are in

00:19:37,350 --> 00:19:40,840
the cluster and we'll see how that works

00:19:39,450 --> 00:19:44,360
in a minute

00:19:40,840 --> 00:19:46,430
and the bigger circles represent

00:19:44,360 --> 00:19:48,920
multiple things they represents that

00:19:46,430 --> 00:19:53,410
this is a pod it represents that this is

00:19:48,920 --> 00:19:56,810
a JVM it represents some instances of

00:19:53,410 --> 00:19:58,940
actors one actor per JVM that type of

00:19:56,810 --> 00:20:02,840
thing

00:19:58,940 --> 00:20:04,820
the little pink circles that you see

00:20:02,840 --> 00:20:07,040
kind of poof out of existence what's

00:20:04,820 --> 00:20:11,840
happening there is these end of the

00:20:07,040 --> 00:20:13,670
actors are written to only stay active

00:20:11,840 --> 00:20:16,040
if they're receiving messages if they

00:20:13,670 --> 00:20:17,960
stop receiving messages they shut

00:20:16,040 --> 00:20:20,000
themselves down so that's what you're

00:20:17,960 --> 00:20:21,680
seeing when they when an actor shuts

00:20:20,000 --> 00:20:24,530
itself down because it hasn't received

00:20:21,680 --> 00:20:26,570
any messages for a while it shuts itself

00:20:24,530 --> 00:20:29,880
down and in visualization here kind of

00:20:26,570 --> 00:20:32,220
poof out of existence

00:20:29,880 --> 00:20:34,320
so again think of this is this one

00:20:32,220 --> 00:20:36,570
circle is representing a single

00:20:34,320 --> 00:20:38,880
microservice in a system of

00:20:36,570 --> 00:20:40,559
microservices now I'm not saying every

00:20:38,880 --> 00:20:42,600
micro-service in the system has to be

00:20:40,559 --> 00:20:44,010
written in archive was just you know

00:20:42,600 --> 00:20:47,940
easier for me to do this real quick

00:20:44,010 --> 00:20:50,190
slide just by copy pasting you know the

00:20:47,940 --> 00:20:53,340
single circle

00:20:50,190 --> 00:20:56,910
so let's go back to the running

00:20:53,340 --> 00:21:01,050
environment so we didn't think I could

00:20:56,910 --> 00:21:02,940
do it to simulate say losing a note yeah

00:21:01,050 --> 00:21:04,950
we're running along here we're running

00:21:02,940 --> 00:21:07,470
on three JVM this micro service is

00:21:04,950 --> 00:21:09,360
handling all these requests and say

00:21:07,470 --> 00:21:11,550
something goes wrong and to simulate

00:21:09,360 --> 00:21:13,200
this I'm just second under the guy who

00:21:11,550 --> 00:21:15,450
set this stuff so that I can click one

00:21:13,200 --> 00:21:19,050
of these big circles and it's going to

00:21:15,450 --> 00:21:21,780
cause the that JVM to shut down so the

00:21:19,050 --> 00:21:24,860
JVM shuts down and then what you'll see

00:21:21,780 --> 00:21:28,650
is pretty quickly we'll be back to

00:21:24,860 --> 00:21:30,240
having the those 15 green circles there

00:21:28,650 --> 00:21:32,190
were five of them on that note that went

00:21:30,240 --> 00:21:34,590
down now there they were redistributed

00:21:32,190 --> 00:21:36,840
in Tom the other nodes now in the

00:21:34,590 --> 00:21:40,080
background that was akka actors reacting

00:21:36,840 --> 00:21:44,160
to the loss of the JVM now kubernetes

00:21:40,080 --> 00:21:46,050
also saw that we lost a JVM and as you

00:21:44,160 --> 00:21:48,540
can see it's already started one backup

00:21:46,050 --> 00:21:51,390
so it started a new JVM backup really

00:21:48,540 --> 00:21:53,040
pretty quickly but in the meantime the

00:21:51,390 --> 00:21:55,500
service had to keep running a kid had to

00:21:53,040 --> 00:22:00,150
keep handling all these these requests

00:21:55,500 --> 00:22:02,640
so what you see here is said the new JVM

00:22:00,150 --> 00:22:03,270
started up that joined the cluster and

00:22:02,640 --> 00:22:05,490
Anaka

00:22:03,270 --> 00:22:06,870
the akka actors saw this and go ah we

00:22:05,490 --> 00:22:08,370
got more capacity we lost some

00:22:06,870 --> 00:22:10,770
capacities a moment ago but now we've

00:22:08,370 --> 00:22:12,360
got more capacity back so start shifting

00:22:10,770 --> 00:22:14,100
work back over to it just so you can

00:22:12,360 --> 00:22:14,640
kind of see visually as this is

00:22:14,100 --> 00:22:17,880
happening

00:22:14,640 --> 00:22:19,830
we lost the JVM for a bit

00:22:17,880 --> 00:22:23,850
the akka actors reacted pretty quickly

00:22:19,830 --> 00:22:25,860
to it and then kubernetes also reacted

00:22:23,850 --> 00:22:28,019
pretty quickly to it a new JVM started

00:22:25,860 --> 00:22:29,279
up joined the cluster and then the you

00:22:28,019 --> 00:22:31,350
know things started them kind of

00:22:29,279 --> 00:22:32,730
migrated back over to it so reboot this

00:22:31,350 --> 00:22:36,539
is what the sharding actors do they

00:22:32,730 --> 00:22:39,090
rebalance we went down to two nodes we

00:22:36,539 --> 00:22:41,779
all 15 shards around the suno's when we

00:22:39,090 --> 00:22:44,100
go back up to three nodes now the

00:22:41,779 --> 00:22:46,710
discharge redistribute themselves across

00:22:44,100 --> 00:22:52,639
to the cluster so another thing I can do

00:22:46,710 --> 00:22:52,639
is say this micro-service is

00:22:54,500 --> 00:23:02,150
is getting a hit in traffic and it you

00:22:59,330 --> 00:23:03,830
know a spike in traffic so I mentioned

00:23:02,150 --> 00:23:05,750
earlier that you can set up your

00:23:03,830 --> 00:23:09,710
kubernetes environment so you can see

00:23:05,750 --> 00:23:11,540
say the CPUs of the three GM JVMs are

00:23:09,710 --> 00:23:13,730
reaching a higher threshold that you've

00:23:11,540 --> 00:23:17,300
configured to save say if the CPU

00:23:13,730 --> 00:23:19,190
utilization goes over 60% that's a

00:23:17,300 --> 00:23:21,860
trigger to kubernetes to start up some

00:23:19,190 --> 00:23:24,370
more pods which starts up for some more

00:23:21,860 --> 00:23:29,180
JVM s4 so I'm gonna simulate that here

00:23:24,370 --> 00:23:32,000
I'm gonna use the user interface to

00:23:29,180 --> 00:23:35,480
scale it up so you can see it kind of

00:23:32,000 --> 00:23:38,330
goes great and then it goes it starts up

00:23:35,480 --> 00:23:41,420
so what's happening behind the scenes is

00:23:38,330 --> 00:23:44,420
now we've got five pods running and then

00:23:41,420 --> 00:23:48,080
in the visualization what we should see

00:23:44,420 --> 00:23:51,400
in a little bit hopefully is we'll see

00:23:48,080 --> 00:23:53,240
two more of these big circles join in

00:23:51,400 --> 00:23:54,470
now it takes a little bit of time

00:23:53,240 --> 00:23:57,590
because what's happening behind the

00:23:54,470 --> 00:23:59,180
scenes here is the JVM you know the pod

00:23:57,590 --> 00:24:00,920
starts up it has to load the docker

00:23:59,180 --> 00:24:02,990
image the docker image starts up it has

00:24:00,920 --> 00:24:06,140
to load the JVM the JVM starts running

00:24:02,990 --> 00:24:09,530
my code my code start saying running

00:24:06,140 --> 00:24:11,210
code to join the Aqua cluster but that's

00:24:09,530 --> 00:24:13,160
happened so you can see now we're at

00:24:11,210 --> 00:24:17,180
five of the big circles right so there's

00:24:13,160 --> 00:24:20,990
five JVM is running and then that's what

00:24:17,180 --> 00:24:23,510
I kubernetes did and then now the Aqua

00:24:20,990 --> 00:24:25,970
environment II sees that oh we got extra

00:24:23,510 --> 00:24:28,210
capacity this is what the shard actors

00:24:25,970 --> 00:24:30,950
are for so you can see kind of slowly

00:24:28,210 --> 00:24:32,690
the green shard actors are migrating

00:24:30,950 --> 00:24:35,450
over and they're bringing over the

00:24:32,690 --> 00:24:38,360
entities that they're responsible for so

00:24:35,450 --> 00:24:41,950
they're being the shard actor activities

00:24:38,360 --> 00:24:43,820
being stopped and the old holder knows

00:24:41,950 --> 00:24:46,700
where they're at and there's been

00:24:43,820 --> 00:24:50,030
rebalanced okay so this is just a way

00:24:46,700 --> 00:24:51,830
for kind of gracefully handle it or

00:24:50,030 --> 00:24:56,090
taking advantage of the increased

00:24:51,830 --> 00:24:59,720
increased capacity now the green actors

00:24:56,090 --> 00:25:00,290
are actors that are out of the box with

00:24:59,720 --> 00:25:02,929
akka

00:25:00,290 --> 00:25:05,780
it's called cluster sharding the blue

00:25:02,929 --> 00:25:09,770
actors are access code I wrote as a

00:25:05,780 --> 00:25:11,300
developer the mechanics of these green

00:25:09,770 --> 00:25:12,890
actors and some other actors are

00:25:11,300 --> 00:25:15,220
involved in this whole cluster sharding

00:25:12,890 --> 00:25:18,380
isn't rocket science this is stuff that

00:25:15,220 --> 00:25:19,940
once you get comfortable with akka and

00:25:18,380 --> 00:25:22,250
I'll show you a little bit of some of

00:25:19,940 --> 00:25:23,929
that mechanics up in a bit the stuff

00:25:22,250 --> 00:25:25,550
that you can write yourself to do these

00:25:23,929 --> 00:25:28,700
kinds of things like distributing work

00:25:25,550 --> 00:25:30,710
across the cluster and the other part is

00:25:28,700 --> 00:25:32,060
all these actors that are you know

00:25:30,710 --> 00:25:35,380
they're able to message each other

00:25:32,060 --> 00:25:35,380
across the cluster as well

00:25:35,510 --> 00:25:40,650
so I'm saying you know we had to spike

00:25:38,400 --> 00:25:43,620
in traffic now the spike in traffic so

00:25:40,650 --> 00:25:47,360
verso kubernetes goes all right I'm

00:25:43,620 --> 00:25:47,360
gonna scale back down

00:25:47,900 --> 00:25:52,330
and I want to go to visualization

00:25:49,760 --> 00:25:56,780
quickly boom yes so kubernetes killed

00:25:52,330 --> 00:25:59,750
those two pods those two JVMs really

00:25:56,780 --> 00:26:01,670
quickly and then Hakka saw that this

00:25:59,750 --> 00:26:03,830
happened and it reacts very quickly were

00:26:01,670 --> 00:26:08,620
those 15 shard actors are rebalanced on

00:26:03,830 --> 00:26:08,620
the remaining three JVMs

00:26:13,290 --> 00:26:20,310
so this is a pretty good example the

00:26:17,760 --> 00:26:22,320
combination of kubernetes and the socket

00:26:20,310 --> 00:26:23,850
cluster of what's called a reactive

00:26:22,320 --> 00:26:25,830
system you know the term reactive has

00:26:23,850 --> 00:26:28,050
gotten very popular in last few years

00:26:25,830 --> 00:26:29,880
and primarily it's because of reactive

00:26:28,050 --> 00:26:31,830
programming which is great because

00:26:29,880 --> 00:26:34,380
reactive program is a very good style of

00:26:31,830 --> 00:26:35,820
programming a lot of you know tool sets

00:26:34,380 --> 00:26:37,620
and frameworks have adopted over the

00:26:35,820 --> 00:26:39,270
last few years but there's also the

00:26:37,620 --> 00:26:41,040
concept of reactive systems which is

00:26:39,270 --> 00:26:43,320
pretty intuitive but also kind of

00:26:41,040 --> 00:26:45,780
important and historically hasn't been

00:26:43,320 --> 00:26:48,120
that easy to do which is you want to

00:26:45,780 --> 00:26:51,690
have a system that's always responsive

00:26:48,120 --> 00:26:53,220
to users and the only way that the

00:26:51,690 --> 00:26:55,830
system can always be responds to the

00:26:53,220 --> 00:26:58,140
users is that the systems built

00:26:55,830 --> 00:27:00,150
architecture only from the very you know

00:26:58,140 --> 00:27:03,120
kind of from the ground up to be able to

00:27:00,150 --> 00:27:06,120
handle failures and and also to be able

00:27:03,120 --> 00:27:08,670
to scale and that's kind of what I was

00:27:06,120 --> 00:27:10,110
just showing you here and it's ready

00:27:08,670 --> 00:27:14,050
with this combination of kubernetes

00:27:10,110 --> 00:27:17,830
Anaka one approach for doing it

00:27:14,050 --> 00:27:22,090
so the the project today that we're

00:27:17,830 --> 00:27:26,830
seeing here running it's just a Java

00:27:22,090 --> 00:27:28,710
maven project okay how many of your

00:27:26,830 --> 00:27:37,090
devout Java developers here

00:27:28,710 --> 00:27:38,890
maven farewell okay so in a Java maven

00:27:37,090 --> 00:27:42,580
project may even is used for building

00:27:38,890 --> 00:27:45,850
the code alright and there's this file

00:27:42,580 --> 00:27:48,160
called a pom that is used to define your

00:27:45,850 --> 00:27:50,800
application so if you're familiar with

00:27:48,160 --> 00:27:52,450
maven and all one of the things you do

00:27:50,800 --> 00:27:53,890
is you declare all your dependencies all

00:27:52,450 --> 00:27:56,890
the libraries that your code uses but

00:27:53,890 --> 00:27:59,680
then the other thing you can do is you

00:27:56,890 --> 00:28:01,510
can define plugins so this is one

00:27:59,680 --> 00:28:04,900
there's two plugins that were added to

00:28:01,510 --> 00:28:07,410
this project so that it was kind of set

00:28:04,900 --> 00:28:11,110
up and able to be deployed to kubernetes

00:28:07,410 --> 00:28:15,100
one is a plugin that's used to build a

00:28:11,110 --> 00:28:17,920
jar jar or a big jar of self-contained

00:28:15,100 --> 00:28:19,960
jar so what this plug-in does is when

00:28:17,920 --> 00:28:22,000
you build the project it creates a

00:28:19,960 --> 00:28:23,920
single jar that contains not only your

00:28:22,000 --> 00:28:25,060
code all your dependencies so it's a

00:28:23,920 --> 00:28:27,480
single file that can be run

00:28:25,060 --> 00:28:30,970
independently

00:28:27,480 --> 00:28:35,530
the other thing that is part of this is

00:28:30,970 --> 00:28:38,410
a plugin that builds a docker image for

00:28:35,530 --> 00:28:41,620
this project so basically when you build

00:28:38,410 --> 00:28:43,990
this project it builds a big jar and

00:28:41,620 --> 00:28:47,950
then it plugs that jar into a docker

00:28:43,990 --> 00:28:51,010
image and creates that docker image and

00:28:47,950 --> 00:28:52,630
one of probably one of the most

00:28:51,010 --> 00:28:54,160
interesting things here is even though

00:28:52,630 --> 00:28:55,750
this is kind of if you've done docker or

00:28:54,160 --> 00:28:56,380
something like that with you know docker

00:28:55,750 --> 00:28:58,960
file

00:28:56,380 --> 00:29:00,460
it's just describing what's how to run

00:28:58,960 --> 00:29:03,390
this thing so basically we're just

00:29:00,460 --> 00:29:07,410
giving it to Java command to run our jar

00:29:03,390 --> 00:29:07,410
okay and that's it

00:29:07,720 --> 00:29:15,610
also witness projects are some Yambol

00:29:12,159 --> 00:29:18,490
files that are used to define or this is

00:29:15,610 --> 00:29:22,120
how you declare how to run the

00:29:18,490 --> 00:29:26,490
application so it's it's a type of

00:29:22,120 --> 00:29:32,799
deployment you gave it a name name space

00:29:26,490 --> 00:29:36,399
and the lot of other stuff here but the

00:29:32,799 --> 00:29:39,039
this is the name of the image the docker

00:29:36,399 --> 00:29:41,139
image that's going to be deployed and

00:29:39,039 --> 00:29:43,299
then a few things about some of the

00:29:41,139 --> 00:29:45,279
ports the network ports that this

00:29:43,299 --> 00:29:48,190
application needs so it's just talking

00:29:45,279 --> 00:29:50,620
about port 8080 which is of course the

00:29:48,190 --> 00:29:52,269
web for the web client and then two five

00:29:50,620 --> 00:29:55,120
five two which is what ocker uses to

00:29:52,269 --> 00:29:57,340
talk to other nodes in the cluster and

00:29:55,120 --> 00:29:58,629
then eight five five eight which is a

00:29:57,340 --> 00:30:00,700
knockout management of course those

00:29:58,629 --> 00:30:01,179
three ports here that are defined that's

00:30:00,700 --> 00:30:04,929
it

00:30:01,179 --> 00:30:07,779
so you give this file to kubernetes it's

00:30:04,929 --> 00:30:10,570
just a simple command you know like a

00:30:07,779 --> 00:30:12,879
cube control apply minus F give it this

00:30:10,570 --> 00:30:14,919
file and this is the declaration to

00:30:12,879 --> 00:30:19,360
kubernetes say take this image and run

00:30:14,919 --> 00:30:21,820
it and also by the way hmm I said start

00:30:19,360 --> 00:30:24,210
up with three instances of this so run

00:30:21,820 --> 00:30:24,210
three pods

00:30:25,480 --> 00:30:31,539
and then there's another one other than

00:30:28,840 --> 00:30:35,980
that there's just regular Java code so

00:30:31,539 --> 00:30:38,799
this is the class with the main method

00:30:35,980 --> 00:30:41,049
in it and it does things like you know

00:30:38,799 --> 00:30:43,029
here's some Java code where we start up

00:30:41,049 --> 00:30:45,100
akka just like one line of code you

00:30:43,029 --> 00:30:47,669
could just this actor system you can

00:30:45,100 --> 00:30:50,799
kind of think of it as a glorified

00:30:47,669 --> 00:30:53,190
thread pool it's way more than that but

00:30:50,799 --> 00:30:55,889
it you know this is a thing that you

00:30:53,190 --> 00:30:58,029
spawn actors from this is the thing that

00:30:55,889 --> 00:30:59,500
handles all the networking this is the

00:30:58,029 --> 00:31:02,530
thing that handles the communication

00:30:59,500 --> 00:31:06,120
between actors

00:31:02,530 --> 00:31:09,430
and then just some examples here where

00:31:06,120 --> 00:31:11,830
some at some actors are started so when

00:31:09,430 --> 00:31:13,720
this JVM starts up there's a set of

00:31:11,830 --> 00:31:16,930
actors that are started up to get things

00:31:13,720 --> 00:31:20,950
rolling and we'll see more about about

00:31:16,930 --> 00:31:22,390
what these guys do in a minute the one

00:31:20,950 --> 00:31:26,500
thing I did want to show you this this

00:31:22,390 --> 00:31:30,130
aqua cluster bootstrap which is a method

00:31:26,500 --> 00:31:32,050
that I define down here which has these

00:31:30,130 --> 00:31:34,420
two lines of code so what happens is

00:31:32,050 --> 00:31:38,290
when this JVM has started up in the

00:31:34,420 --> 00:31:41,620
docker container and it runs this jar

00:31:38,290 --> 00:31:44,320
this main method is invoked it calls

00:31:41,620 --> 00:31:47,440
this code which calls this aqua cluster

00:31:44,320 --> 00:31:52,300
bootstrap this is where the magic sauce

00:31:47,440 --> 00:31:54,550
happens where the JVM starts up and it

00:31:52,300 --> 00:31:56,950
announces itself to the cluster because

00:31:54,550 --> 00:31:58,690
you know say we're running when I we

00:31:56,950 --> 00:32:00,220
were running three nodes there are three

00:31:58,690 --> 00:32:01,480
JVM is running in cluster they were all

00:32:00,220 --> 00:32:04,300
talking to each other over the network

00:32:01,480 --> 00:32:05,890
and then two more started up when I when

00:32:04,300 --> 00:32:08,560
I scale it up to five when those things

00:32:05,890 --> 00:32:12,070
started up they ran this code does the

00:32:08,560 --> 00:32:15,670
cluster bootstrap what this does is it

00:32:12,070 --> 00:32:18,640
uses the kubernetes api kubernetes api

00:32:15,670 --> 00:32:20,830
to ask kubernetes hey are there any

00:32:18,640 --> 00:32:22,360
other pods like me running and in

00:32:20,830 --> 00:32:23,800
kubernetes answers oh yeah there are

00:32:22,360 --> 00:32:25,900
here's three and it gives the basic

00:32:23,800 --> 00:32:28,270
users back the network addresses so

00:32:25,900 --> 00:32:32,530
those other three three pods so then

00:32:28,270 --> 00:32:34,360
this new pod this new JVM can then use

00:32:32,530 --> 00:32:36,430
that information to announce itself you

00:32:34,360 --> 00:32:39,510
think to the other nodes in the cluster

00:32:36,430 --> 00:32:41,760
and say hey I want to join the party

00:32:39,510 --> 00:32:45,030
so they start talking to each other and

00:32:41,760 --> 00:32:48,180
that's where they these these multiple

00:32:45,030 --> 00:32:50,850
JVMs form themselves in the cluster so

00:32:48,180 --> 00:32:53,430
not a lot of code for us to do but as

00:32:50,850 --> 00:32:55,470
you can imagine there's some fun stuff

00:32:53,430 --> 00:32:57,830
that happens under the covers to make

00:32:55,470 --> 00:32:57,830
this all happen

00:33:03,140 --> 00:33:09,770
so the those end of the actors the blue

00:33:06,770 --> 00:33:13,520
circles as I mentioned they represent

00:33:09,770 --> 00:33:14,960
instances of like your shopping cart on

00:33:13,520 --> 00:33:18,200
my shopping cart in somebody else's

00:33:14,960 --> 00:33:20,299
shopping cart or IOT device whatever it

00:33:18,200 --> 00:33:22,850
is whatever this application happens to

00:33:20,299 --> 00:33:24,620
be handling so in this little diagram

00:33:22,850 --> 00:33:26,540
here that I'm what I'm trying to show is

00:33:24,620 --> 00:33:29,570
this say you're on a stay on a phone

00:33:26,540 --> 00:33:32,240
client the setting this microservice I'm

00:33:29,570 --> 00:33:33,410
on another phone client and somebody

00:33:32,240 --> 00:33:36,770
else is on another one so it's just

00:33:33,410 --> 00:33:39,770
three different examples of users so

00:33:36,770 --> 00:33:42,650
your entity 64 I'm entity 17 and the

00:33:39,770 --> 00:33:44,630
others and a 76 so what I'm saying is

00:33:42,650 --> 00:33:47,780
that these are IDs it's like shopping

00:33:44,630 --> 00:33:49,760
cart ID or device ID or whatever you

00:33:47,780 --> 00:33:52,730
know this is a design decision that we

00:33:49,760 --> 00:33:56,929
make as developers but what happens is

00:33:52,730 --> 00:33:59,780
that say our device comes in over the

00:33:56,929 --> 00:34:03,440
wire and talks to an HTTP endpoint in

00:33:59,780 --> 00:34:06,290
this micro service and then that HTTP

00:34:03,440 --> 00:34:08,690
request is then used to build a message

00:34:06,290 --> 00:34:11,780
that's sent that we want to send to our

00:34:08,690 --> 00:34:15,260
entity actor well in your in your case

00:34:11,780 --> 00:34:18,109
following the blue line the HTTP request

00:34:15,260 --> 00:34:22,580
lands on the JVM running at the top left

00:34:18,109 --> 00:34:25,300
however your entity actor is running in

00:34:22,580 --> 00:34:28,940
a JVM that's running in the bottom left

00:34:25,300 --> 00:34:31,429
okay so the the messaging that occurs

00:34:28,940 --> 00:34:35,090
here is all handled through actor

00:34:31,429 --> 00:34:38,510
messages so the HTTP request is sending

00:34:35,090 --> 00:34:40,820
a message to an actor a local actor on

00:34:38,510 --> 00:34:42,379
its JVM that local actor looks and sees

00:34:40,820 --> 00:34:45,440
oh this is for not for one of my

00:34:42,379 --> 00:34:47,419
entities is for anybody on a different

00:34:45,440 --> 00:34:49,129
note in the cluster so that's what that

00:34:47,419 --> 00:34:52,609
actors are responsible for doing that

00:34:49,129 --> 00:34:56,399
actor then force a message over to an

00:34:52,609 --> 00:34:58,890
actor on the other JVM

00:34:56,399 --> 00:35:01,440
and it Ford's it to the Chardon actor

00:34:58,890 --> 00:35:05,849
and then finally gets forwarded to your

00:35:01,440 --> 00:35:08,250
entity action okay so the coding to do

00:35:05,849 --> 00:35:11,010
this is dead simple it's like one line

00:35:08,250 --> 00:35:12,900
of code I'll show you some examples but

00:35:11,010 --> 00:35:14,910
the mechanics that's happening here is

00:35:12,900 --> 00:35:16,349
this is what akka does and so you might

00:35:14,910 --> 00:35:19,049
look at this and go oh my gosh this is

00:35:16,349 --> 00:35:21,619
like wave overhead message missus

00:35:19,049 --> 00:35:24,930
message well there was one never copped

00:35:21,619 --> 00:35:26,490
okay but then messaging between actors

00:35:24,930 --> 00:35:29,910
in the same jail they're just basically

00:35:26,490 --> 00:35:32,910
method calls alright so not a lot

00:35:29,910 --> 00:35:34,380
overhead there's serialization the DC

00:35:32,910 --> 00:35:36,180
release that does deserialization

00:35:34,380 --> 00:35:38,309
happening when the message goes over the

00:35:36,180 --> 00:35:41,849
wire but once the message is internal to

00:35:38,309 --> 00:35:44,220
it the JVM it's not and occas actually

00:35:41,849 --> 00:35:46,549
built for very high performance systems

00:35:44,220 --> 00:35:49,410
is built for his systems that handle

00:35:46,549 --> 00:35:52,650
millions of actors and handled millions

00:35:49,410 --> 00:35:54,240
of messages per second so this is a this

00:35:52,650 --> 00:35:57,690
is what this thing's been built to do

00:35:54,240 --> 00:36:01,200
for naka ten years old has been beat up

00:35:57,690 --> 00:36:04,400
hard and and toughened a lot to do these

00:36:01,200 --> 00:36:04,400
things very very optimally

00:36:06,110 --> 00:36:10,510
and in the case of say you know right

00:36:08,450 --> 00:36:14,540
now in this example we're running with

00:36:10,510 --> 00:36:16,700
four JVMs and four terminators pods and

00:36:14,540 --> 00:36:20,090
say for some reason we lose one of those

00:36:16,700 --> 00:36:22,160
JVMs because that pod stopped either

00:36:20,090 --> 00:36:23,270
because it was shut down deliberately or

00:36:22,160 --> 00:36:26,540
something broke

00:36:23,270 --> 00:36:29,540
well kubernetes is able to handle that

00:36:26,540 --> 00:36:31,280
and on its level but the akka actors are

00:36:29,540 --> 00:36:34,070
able to handle it on its level as well

00:36:31,280 --> 00:36:37,010
the idea here is that the clients you

00:36:34,070 --> 00:36:38,840
know the web clients they just keep

00:36:37,010 --> 00:36:40,640
going away and they don't they're not

00:36:38,840 --> 00:36:42,950
missing a beat if something you know we

00:36:40,640 --> 00:36:46,130
scale up or scale down we have some kind

00:36:42,950 --> 00:36:47,750
of failure behind the scenes from the

00:36:46,130 --> 00:36:49,730
perspective of the clients the system is

00:36:47,750 --> 00:36:52,330
so responsive that's what a reactive

00:36:49,730 --> 00:36:52,330
system is all about

00:36:52,579 --> 00:37:00,640
so let's take a look at the entity actor

00:36:57,069 --> 00:37:08,229
so this is the code behind those blue

00:37:00,640 --> 00:37:11,410
circles so this is just Java you got I

00:37:08,229 --> 00:37:14,799
created a class is extending a NACA base

00:37:11,410 --> 00:37:16,329
class called abstract logging actor got

00:37:14,799 --> 00:37:18,569
some instance variables those are the

00:37:16,329 --> 00:37:20,709
local state of the actor in the sense

00:37:18,569 --> 00:37:22,269
there's one method that I have to

00:37:20,709 --> 00:37:24,849
implement is called this great receive

00:37:22,269 --> 00:37:26,949
and this is the method that you write to

00:37:24,849 --> 00:37:31,209
handle incoming messages sent him to

00:37:26,949 --> 00:37:34,869
this actor so we're not the writing the

00:37:31,209 --> 00:37:36,309
code for serialization D civilizational

00:37:34,869 --> 00:37:38,169
that's kind of stuff sending you all the

00:37:36,309 --> 00:37:40,179
mechanics to send me messages we just

00:37:38,169 --> 00:37:41,890
write the code for handling incoming

00:37:40,179 --> 00:37:43,419
messages and then there's I'll show you

00:37:41,890 --> 00:37:43,959
an example of sending a message in a

00:37:43,419 --> 00:37:48,189
minute

00:37:43,959 --> 00:37:51,429
so this actor is set up so that it can

00:37:48,189 --> 00:37:53,619
handle a specific set of messages so I

00:37:51,429 --> 00:37:55,509
got one message called command another

00:37:53,619 --> 00:37:59,519
one called query and this other one

00:37:55,509 --> 00:38:03,279
called timeout an instance of this

00:37:59,519 --> 00:38:05,219
something called a timeout so the

00:38:03,279 --> 00:38:08,799
command you have these these met

00:38:05,219 --> 00:38:11,169
messages for command or query they're

00:38:08,799 --> 00:38:13,689
just you want to run that object that

00:38:11,169 --> 00:38:15,849
comes into the actor invokes a method

00:38:13,689 --> 00:38:17,679
this method looks it looks at that

00:38:15,849 --> 00:38:19,869
object and goes up okay I'm gonna call

00:38:17,679 --> 00:38:23,140
the command method serious the command

00:38:19,869 --> 00:38:24,800
medicine is now I this is just my code

00:38:23,140 --> 00:38:27,920
right

00:38:24,800 --> 00:38:31,340
and this is you know kind of a

00:38:27,920 --> 00:38:33,260
bare-bones simple implementation I

00:38:31,340 --> 00:38:35,480
didn't want to have a lot of stuff

00:38:33,260 --> 00:38:36,860
around other than just trying to show

00:38:35,480 --> 00:38:37,640
you some of the mechanics of handling a

00:38:36,860 --> 00:38:42,290
message

00:38:37,640 --> 00:38:45,440
so the message comes in I performed some

00:38:42,290 --> 00:38:48,470
way on logic the way I wrote this actor

00:38:45,440 --> 00:38:50,750
is if the this end of the variable is

00:38:48,470 --> 00:38:52,850
null that means it's the first time we

00:38:50,750 --> 00:38:54,410
received a message it's the first time

00:38:52,850 --> 00:38:56,180
they received the message since the

00:38:54,410 --> 00:38:58,520
actor was started because the action

00:38:56,180 --> 00:39:00,410
could be started to be in state and it

00:38:58,520 --> 00:39:02,060
could receive more messages after that

00:39:00,410 --> 00:39:06,500
which means it's going to go down to the

00:39:02,060 --> 00:39:08,780
else but I get this message and the

00:39:06,500 --> 00:39:11,840
thing I want to show you here is in this

00:39:08,780 --> 00:39:14,180
line this is where this actor is sending

00:39:11,840 --> 00:39:16,490
a message to another actor now in this

00:39:14,180 --> 00:39:18,680
case there's a convenience method that I

00:39:16,490 --> 00:39:21,170
inherent called sender which gives me

00:39:18,680 --> 00:39:23,390
the what's called an actor reference

00:39:21,170 --> 00:39:26,180
this is like an actor actor gyro

00:39:23,390 --> 00:39:28,190
this is how you set one how you send

00:39:26,180 --> 00:39:29,510
messages to an actor you use this actor

00:39:28,190 --> 00:39:32,840
you're all which the sender methods

00:39:29,510 --> 00:39:35,090
returning and you do a tell and then I

00:39:32,840 --> 00:39:37,850
build an object which is my just above

00:39:35,090 --> 00:39:39,170
my design as a developer and say alright

00:39:37,850 --> 00:39:41,870
I got this minute

00:39:39,170 --> 00:39:43,470
this command act objects that I wanted

00:39:41,870 --> 00:39:45,690
to send back

00:39:43,470 --> 00:39:48,300
and then this last parameter self just

00:39:45,690 --> 00:39:51,839
says who's the message from so whoever

00:39:48,300 --> 00:39:53,970
sent me this message I did my work they

00:39:51,839 --> 00:39:55,770
send me an asynchronous message I've

00:39:53,970 --> 00:39:57,599
received that message I did some stuff

00:39:55,770 --> 00:39:59,460
and then I send a message back to them

00:39:57,599 --> 00:40:01,470
another asynchronous message so it's not

00:39:59,460 --> 00:40:05,180
a synchronous request responses that

00:40:01,470 --> 00:40:09,540
this is always see cause asynchronous

00:40:05,180 --> 00:40:10,950
okay so that's really the flow so I

00:40:09,540 --> 00:40:16,140
gotta zoom ahead because we're running

00:40:10,950 --> 00:40:19,970
out of time so yeah the idea is that all

00:40:16,140 --> 00:40:22,560
this stuff keeps running and working

00:40:19,970 --> 00:40:25,109
regardless of the the pod so if we got

00:40:22,560 --> 00:40:27,210
one pod we have one JVM running if you

00:40:25,109 --> 00:40:28,819
scale up the three pods we've got three

00:40:27,210 --> 00:40:31,950
javion who's with me if you lose a pod

00:40:28,819 --> 00:40:34,079
that's okay you know the kubernetes is

00:40:31,950 --> 00:40:36,839
handling it on its end and akka is

00:40:34,079 --> 00:40:40,050
handling another and the the movement of

00:40:36,839 --> 00:40:43,589
the shards is all handled by the shard

00:40:40,050 --> 00:40:46,400
actors themselves the last thing I want

00:40:43,589 --> 00:40:51,390
to show you real quick let me skip ahead

00:40:46,400 --> 00:40:53,250
the mystery the the street thing that I

00:40:51,390 --> 00:40:54,990
showed you is just something I

00:40:53,250 --> 00:40:58,290
implemented as developers not part of

00:40:54,990 --> 00:41:00,930
ocarina thing and the fun part of this

00:40:58,290 --> 00:41:06,290
problem was so is that I've got a web

00:41:00,930 --> 00:41:08,940
page the sending a request to my cluster

00:41:06,290 --> 00:41:12,569
asking for the tree which is just sent

00:41:08,940 --> 00:41:15,810
update as a JSON object okay well the

00:41:12,569 --> 00:41:17,369
JSON object has to be composed of the

00:41:15,810 --> 00:41:20,099
end of the actors that are being created

00:41:17,369 --> 00:41:21,960
all across the cluster so if the HTTP

00:41:20,099 --> 00:41:23,430
request comes in to one JVM how does

00:41:21,960 --> 00:41:25,079
that one JVM know about all the other

00:41:23,430 --> 00:41:28,710
entities in these other jaebeum's

00:41:25,079 --> 00:41:30,660
right that's the fun trick here so what

00:41:28,710 --> 00:41:33,720
happens is that when an entity actor

00:41:30,660 --> 00:41:36,790
starts out it sends a message to another

00:41:33,720 --> 00:41:39,340
actor to say hey add me to the tree

00:41:36,790 --> 00:41:42,400
that actor gets the message and then it

00:41:39,340 --> 00:41:44,980
forwards it to its counterpart actors on

00:41:42,400 --> 00:41:47,440
the other nodes in the cluster so let me

00:41:44,980 --> 00:41:49,470
very quickly show you the code that does

00:41:47,440 --> 00:41:49,470
this

00:41:49,820 --> 00:41:54,490
so I'm back in the entity actor and

00:41:51,740 --> 00:41:58,390
there's this method called notify start

00:41:54,490 --> 00:41:58,390
so notify start

00:41:59,950 --> 00:42:06,400
I just build a message in a night to a

00:42:02,920 --> 00:42:08,770
tell so the HTTP server variable is an

00:42:06,400 --> 00:42:11,280
actor reference it's the actor URL and

00:42:08,770 --> 00:42:14,170
I'm saying hey here's the start object

00:42:11,280 --> 00:42:15,550
you know deal with it now in my end of

00:42:14,170 --> 00:42:17,020
the actors done it doesn't expect an

00:42:15,550 --> 00:42:18,910
acknowledgement back from this other

00:42:17,020 --> 00:42:21,520
actor it's just sending a message off to

00:42:18,910 --> 00:42:26,040
this other actor this other actor is

00:42:21,520 --> 00:42:26,040
called this HTTP server actor

00:42:26,420 --> 00:42:33,890
and this guy gets that message just the

00:42:31,970 --> 00:42:39,830
same thing it's got a crate receive gets

00:42:33,890 --> 00:42:42,380
that message and action anity it looks

00:42:39,830 --> 00:42:45,380
at the message goes if it says start add

00:42:42,380 --> 00:42:48,680
it to the tree this is just again code I

00:42:45,380 --> 00:42:51,470
wrote but then it checks a flag and this

00:42:48,680 --> 00:42:54,200
message is saved if the message has a

00:42:51,470 --> 00:42:55,280
forward and field in it that's true then

00:42:54,200 --> 00:42:57,020
I want to Ford the sign to my

00:42:55,280 --> 00:42:58,400
counterparts but if you know when you

00:42:57,020 --> 00:42:59,570
forward it you don't want it to be true

00:42:58,400 --> 00:43:01,340
because you want it to forward and

00:42:59,570 --> 00:43:03,950
infinitely you only want to forward it

00:43:01,340 --> 00:43:08,660
once right so I go to this forward

00:43:03,950 --> 00:43:10,340
action method and here is a loop I'm

00:43:08,660 --> 00:43:14,990
looping through the members in the

00:43:10,340 --> 00:43:17,240
cluster and I'm checking because I and I

00:43:14,990 --> 00:43:18,680
can ask akka for this I'm saying right

00:43:17,240 --> 00:43:20,780
what's the cluster look like right now

00:43:18,680 --> 00:43:22,970
there's three nodes running in a cluster

00:43:20,780 --> 00:43:27,500
let me loop through all three of those

00:43:22,970 --> 00:43:30,410
nodes if the note that I'm looping to

00:43:27,500 --> 00:43:32,000
right now isn't my node and if that node

00:43:30,410 --> 00:43:34,730
is up then I'm going to forward the

00:43:32,000 --> 00:43:38,270
action and then down here I'm just

00:43:34,730 --> 00:43:40,100
building a URL and then forwarding that

00:43:38,270 --> 00:43:43,120
message off to my counterpart so that's

00:43:40,100 --> 00:43:43,120
where that

00:43:44,099 --> 00:43:49,739
the yellow guy the actor received that

00:43:47,249 --> 00:43:51,719
message the floor flag was true

00:43:49,739 --> 00:43:54,509
and it forwarded the message to his

00:43:51,719 --> 00:43:57,509
counterparts across the cluster this is

00:43:54,509 --> 00:44:01,369
kind of an example of cluster where the

00:43:57,509 --> 00:44:04,690
the code to do this is pretty simple

00:44:01,369 --> 00:44:07,920
pretty powerful

00:44:04,690 --> 00:44:07,920
Samir a crock

00:44:08,100 --> 00:44:11,100
there's some other things here we'll

00:44:09,869 --> 00:44:13,140
have time to go into them this

00:44:11,100 --> 00:44:14,490
there's cluster Singleton's cluster

00:44:13,140 --> 00:44:19,800
sharding which we should looked at a

00:44:14,490 --> 00:44:21,480
little bit there's if you've ever heard

00:44:19,800 --> 00:44:22,560
about or interested in doing like events

00:44:21,480 --> 00:44:25,160
or seeing a command career

00:44:22,560 --> 00:44:27,540
responsibility segregation seeker s

00:44:25,160 --> 00:44:32,490
isn't it this is kind of foundational

00:44:27,540 --> 00:44:34,590
implementation of that you know the

00:44:32,490 --> 00:44:36,540
whole idea is having this cluster being

00:44:34,590 --> 00:44:40,260
distributed but the thing I already want

00:44:36,540 --> 00:44:42,780
to get to is that these are the github

00:44:40,260 --> 00:44:44,820
projects and I'll post these slides but

00:44:42,780 --> 00:44:47,280
the project that was going to was the

00:44:44,820 --> 00:44:49,740
top one the kubernetes one it's just

00:44:47,280 --> 00:44:52,140
then the intent of these projects is you

00:44:49,740 --> 00:44:53,670
can just clone these projects build them

00:44:52,140 --> 00:44:57,060
there's a readme I've been trying to get

00:44:53,670 --> 00:44:59,100
to read me the self contained with some

00:44:57,060 --> 00:45:01,200
you know where you can take it and use

00:44:59,100 --> 00:45:04,460
it I've been using this in some

00:45:01,200 --> 00:45:07,920
workshops the other six projects are

00:45:04,460 --> 00:45:09,570
akka maven projects not kubernetes

00:45:07,920 --> 00:45:11,160
doesn't have a visualization but the

00:45:09,570 --> 00:45:13,560
intent is something that if you're

00:45:11,160 --> 00:45:15,420
curious about akka and you want to see

00:45:13,560 --> 00:45:17,820
about running stuff in clusters which is

00:45:15,420 --> 00:45:19,619
really very cool you can take these

00:45:17,820 --> 00:45:22,230
projects and kind of incrementally start

00:45:19,619 --> 00:45:24,600
from a very basic project up to a couple

00:45:22,230 --> 00:45:27,240
projects to do event sourcing and seeker

00:45:24,600 --> 00:45:28,950
s the last two projects to event

00:45:27,240 --> 00:45:32,260
sourcing and Seacrest's the the

00:45:28,950 --> 00:45:34,660
persistence persistence query

00:45:32,260 --> 00:45:36,250
also written a little Riley book this

00:45:34,660 --> 00:45:38,410
free to download if you're interested in

00:45:36,250 --> 00:45:40,450
its no code lots of pictures it kind of

00:45:38,410 --> 00:45:44,710
explains about actors if you're

00:45:40,450 --> 00:45:45,130
interested and that's it thanks very

00:45:44,710 --> 00:45:48,579
much

00:45:45,130 --> 00:45:50,910
and I'm got time for quite good time for

00:45:48,579 --> 00:45:50,910
questions

00:45:54,440 --> 00:45:59,270
thanks for your talk you mentioned that

00:45:56,750 --> 00:46:02,540
during the bootstrap phase

00:45:59,270 --> 00:46:05,870
it was asking the kubernetes about the

00:46:02,540 --> 00:46:09,740
state how lose the fabricate client or

00:46:05,870 --> 00:46:13,850
just the HTTP rest endpoint or the

00:46:09,740 --> 00:46:16,820
method for asking the kubernetes during

00:46:13,850 --> 00:46:18,860
the strip yeah you mentioned that asking

00:46:16,820 --> 00:46:21,410
the kubernetes about the state like how

00:46:18,860 --> 00:46:23,510
many ports are there so that it can be

00:46:21,410 --> 00:46:27,440
able to connect to those ports it's

00:46:23,510 --> 00:46:30,770
talking to kubernetes api Cooper's own

00:46:27,440 --> 00:46:32,750
API and the API makes restful requesters

00:46:30,770 --> 00:46:35,090
back to the jacobian kubernetes

00:46:32,750 --> 00:46:40,760
environment but it's really just a

00:46:35,090 --> 00:46:43,430
kubernetes api that we're using there is

00:46:40,760 --> 00:46:46,220
fabricate the client and it's used for

00:46:43,430 --> 00:46:49,100
talking to kubernetes my question was in

00:46:46,220 --> 00:46:50,690
its line specifically I know that I and

00:46:49,100 --> 00:46:52,490
the backend the actual implementation

00:46:50,690 --> 00:46:56,190
the bootstrap code is written in Scala

00:46:52,490 --> 00:47:00,049
but if the Scala it's Java as well

00:46:56,190 --> 00:47:00,049
so it's a Java API

00:47:01,130 --> 00:47:04,219
for me

00:47:06,400 --> 00:47:12,150
yeah so it's a REST API with a job

00:47:09,040 --> 00:47:12,150
wrapper on top of it

00:47:14,470 --> 00:47:21,220
so my question is does aqua cluster

00:47:18,460 --> 00:47:24,010
provide any benefits to like like

00:47:21,220 --> 00:47:26,440
replicating actors so so say like if a

00:47:24,010 --> 00:47:30,400
pod died and all the actors in that pod

00:47:26,440 --> 00:47:33,670
died would aqua cluster have replication

00:47:30,400 --> 00:47:36,609
in four or any resiliency and yes with

00:47:33,670 --> 00:47:38,650
the replication so yeah you have an

00:47:36,609 --> 00:47:42,099
instance of like your shopping cart

00:47:38,650 --> 00:47:46,510
actor was on a pod to die so what

00:47:42,099 --> 00:47:48,640
actually happens is that the actor if

00:47:46,510 --> 00:47:50,800
another message gets sent to that actor

00:47:48,640 --> 00:47:54,220
there's a mechanism mechanisms built

00:47:50,800 --> 00:47:56,410
into it where it says oh well where it

00:47:54,220 --> 00:47:59,170
was is gone so now we had to figure out

00:47:56,410 --> 00:48:01,599
where we want to put it now which means

00:47:59,170 --> 00:48:04,560
where's its shard going to be relocated

00:48:01,599 --> 00:48:08,410
to so that's all being handled by the

00:48:04,560 --> 00:48:11,380
out-of-the-box akka actors that but then

00:48:08,410 --> 00:48:13,329
your your actor is restarted okay a new

00:48:11,380 --> 00:48:15,730
instance of the actions brought up now

00:48:13,329 --> 00:48:17,740
in order for it to cover in state the

00:48:15,730 --> 00:48:18,490
state had to be persistent to some kind

00:48:17,740 --> 00:48:20,470
of a database

00:48:18,490 --> 00:48:22,960
so this is where event sourcing really

00:48:20,470 --> 00:48:25,150
comes in where you know commands are

00:48:22,960 --> 00:48:27,900
coming in to the actor and you can do a

00:48:25,150 --> 00:48:30,310
crud crud based approach as well but

00:48:27,900 --> 00:48:32,710
where every time a message is coming

00:48:30,310 --> 00:48:35,290
into that actor and it's performing some

00:48:32,710 --> 00:48:37,720
business logic it's also it's not done

00:48:35,290 --> 00:48:41,250
until it's actually persisted somewhere

00:48:37,720 --> 00:48:44,530
and then so when you lose that actor

00:48:41,250 --> 00:48:46,990
then when as the actors restarted it can

00:48:44,530 --> 00:48:51,120
recover it stay from some persistent

00:48:46,990 --> 00:48:51,120
store okay thank you

00:48:52,370 --> 00:48:56,600
I had the same question is in but I'll

00:48:53,930 --> 00:48:58,490
ask you does the ID stay the same or is

00:48:56,600 --> 00:49:00,530
that about yeah the idea is the same

00:48:58,490 --> 00:49:04,580
yeah because it's like your shopping

00:49:00,530 --> 00:49:06,200
card entity 64 and that ID is not going

00:49:04,580 --> 00:49:09,080
to change effect it's important that it

00:49:06,200 --> 00:49:12,560
doesn't change because the ID is used to

00:49:09,080 --> 00:49:14,810
recover the state and again it works

00:49:12,560 --> 00:49:17,780
really well with event sourcing where

00:49:14,810 --> 00:49:19,640
you're not using crud you're just

00:49:17,780 --> 00:49:21,530
throwing events like you know a DA might

00:49:19,640 --> 00:49:23,990
add an item to a car test an event it's

00:49:21,530 --> 00:49:25,820
stored in some kind of a database and I

00:49:23,990 --> 00:49:27,290
had another one remove an item add the

00:49:25,820 --> 00:49:29,900
shipping guide to building you know each

00:49:27,290 --> 00:49:31,850
one is just an event and the aggregate

00:49:29,900 --> 00:49:35,420
of all those events is the current state

00:49:31,850 --> 00:49:37,670
of your Kennedy so when that entity has

00:49:35,420 --> 00:49:41,330
to be resurrected somewhere else in a

00:49:37,670 --> 00:49:44,410
cluster it replaced those those events

00:49:41,330 --> 00:49:44,410
to recover its State

00:49:44,490 --> 00:49:49,800
if you're using events or some course to

00:49:46,530 --> 00:49:52,640
this cred you just you know do your

00:49:49,800 --> 00:49:52,640
query to recover it

00:49:58,900 --> 00:50:02,430

YouTube URL: https://www.youtube.com/watch?v=da_xPRvB0FE


