Title: Why you shouldn't write crypto functions yourself
Publication date: 2019-03-04
Playlist: DevConfCZ 2019
Description: 
	Presentation name: Why you shouldn't write crypto functions yourself
Speaker: Simo Sorce
Description:  Writing cryptographic functions is not hard, you do not even need to understand the math behind the cryptographic primitive you want to implement to be able to construct a set of cunctions that correctly encrypts and decrypts ciphertext.
So why cryptographers keep saying you should not implement your own crypto ?
In this talk we'll show practical examples that explain why implementing a mathematical function correctly is only the easy part of the job, and where the devil in the detail lies. We'll also show how even thought through implementations sometimes can be attacked, and how they evolve over time.

Genral understanding of how modern CPUs work is useful to better understand the more technical parts. Knowledge of a programming language is highly recommended.
[ https://sched.co/Jceq]
Captions: 
	00:00:05,090 --> 00:00:11,940
so my name is no socks I work for their

00:00:07,710 --> 00:00:13,440
outfits a team and dog is why you

00:00:11,940 --> 00:00:16,800
shouldn't write cryptographic algorithms

00:00:13,440 --> 00:00:19,230
yourself let's get to it

00:00:16,800 --> 00:00:21,140
so everyone tells you that right you

00:00:19,230 --> 00:00:23,159
shouldn't write your own crypto I

00:00:21,140 --> 00:00:29,999
usually don't tell you why

00:00:23,159 --> 00:00:33,630
and I could tell you so instead this

00:00:29,999 --> 00:00:37,020
morning we're going to a little exercise

00:00:33,630 --> 00:00:40,680
how we could write your essay function

00:00:37,020 --> 00:00:45,600
or so that use RSA because I recently

00:00:40,680 --> 00:00:53,160
had to refresh my memory like a nice

00:00:45,600 --> 00:00:59,070
little CV the Kami is that this is

00:00:53,160 --> 00:01:01,440
fundamentally RSA so pretty straight for

00:00:59,070 --> 00:01:05,189
function this is the encryption function

00:01:01,440 --> 00:01:08,000
so see is there your cyclic tags and all

00:01:05,189 --> 00:01:11,040
you need to do is take your message

00:01:08,000 --> 00:01:12,750
exponent shady with the e exponent it's

00:01:11,040 --> 00:01:15,780
called the public exponent and then do

00:01:12,750 --> 00:01:18,990
modules this is also by the way the way

00:01:15,780 --> 00:01:21,590
you do signatures by the same time and

00:01:18,990 --> 00:01:25,229
this is how you decrypt a message

00:01:21,590 --> 00:01:26,640
you take this ciphertext is generated an

00:01:25,229 --> 00:01:29,790
exponent shady with their private

00:01:26,640 --> 00:01:37,159
exponent just okay and you get back your

00:01:29,790 --> 00:01:39,630
message right and I sure now no tricks

00:01:37,159 --> 00:01:43,229
that's really what is the base of error

00:01:39,630 --> 00:01:44,720
say it's just that simple function where

00:01:43,229 --> 00:01:47,670
is it

00:01:44,720 --> 00:01:50,400
so we need to look a little bit that

00:01:47,670 --> 00:01:52,110
does usually tails people talk about a

00:01:50,400 --> 00:01:56,850
little bit you know when trying to

00:01:52,110 --> 00:02:00,090
implement crypto stuff so first of all

00:01:56,850 --> 00:02:03,479
we need to figure out if the function we

00:02:00,090 --> 00:02:05,430
saw is enough and it isn't like there

00:02:03,479 --> 00:02:07,410
are mathematical attacks on that

00:02:05,430 --> 00:02:09,240
that kind of functions are going to be

00:02:07,410 --> 00:02:12,480
aware of them to be able to actually

00:02:09,240 --> 00:02:15,480
build something that is secure and very

00:02:12,480 --> 00:02:17,730
basic things are attacked like comma

00:02:15,480 --> 00:02:20,700
modules so when you want to create a

00:02:17,730 --> 00:02:23,340
private theater say your create two big

00:02:20,700 --> 00:02:25,140
numbers called B and Q the multiply

00:02:23,340 --> 00:02:28,500
together you get modulus and then you

00:02:25,140 --> 00:02:30,240
derive your public and private exponent

00:02:28,500 --> 00:02:32,520
and stuff like that in the end what you

00:02:30,240 --> 00:02:35,250
do you create two keys a public and a

00:02:32,520 --> 00:02:38,070
private key I want it because at least

00:02:35,250 --> 00:02:40,650
back in a time is kinda I'm consuming to

00:02:38,070 --> 00:02:43,800
build a private key some people thought

00:02:40,650 --> 00:02:46,890
well maybe we share some of the you know

00:02:43,800 --> 00:02:49,200
parameters we can speed up key creation

00:02:46,890 --> 00:02:51,270
will have someone to distribute the

00:02:49,200 --> 00:02:53,520
private keys to people and you know that

00:02:51,270 --> 00:02:56,280
would be faster but that was broken so

00:02:53,520 --> 00:03:00,530
never we use parameters always generate

00:02:56,280 --> 00:03:04,820
new fresh keys another thing is that

00:03:00,530 --> 00:03:07,410
people want to be able to decrypt fast

00:03:04,820 --> 00:03:10,290
because oftentimes specially if you

00:03:07,410 --> 00:03:11,910
store stuff on this you write once so

00:03:10,290 --> 00:03:13,980
encryption is not that big a deal but

00:03:11,910 --> 00:03:16,500
you want to be free many times so the

00:03:13,980 --> 00:03:18,840
decryption is fast in price and you can

00:03:16,500 --> 00:03:20,790
get by having a small private exponent

00:03:18,840 --> 00:03:24,230
because then you don't need to exponent

00:03:20,790 --> 00:03:27,299
shake it off tonight to get your message

00:03:24,230 --> 00:03:29,760
except that if uses more exponent you

00:03:27,299 --> 00:03:31,680
break the crypto system so you have to

00:03:29,760 --> 00:03:33,660
have a larger private exponent to do

00:03:31,680 --> 00:03:35,100
that and so again when you create your

00:03:33,660 --> 00:03:39,630
private keys you have to be able to

00:03:35,100 --> 00:03:41,730
careful conversely a small public

00:03:39,630 --> 00:03:43,580
authority if you want to have a fast

00:03:41,730 --> 00:03:46,230
encryption there may be a have a small

00:03:43,580 --> 00:03:48,390
phone there so that it would be faster

00:03:46,230 --> 00:03:51,180
crypt stuck to it again if it's too

00:03:48,390 --> 00:03:52,769
small like three which was used for

00:03:51,180 --> 00:03:56,220
quite a while I do get over the number

00:03:52,769 --> 00:04:00,930
three then it's kind of broken but if

00:03:56,220 --> 00:04:02,760
you use at least 2 to the 16 it's fine

00:04:00,930 --> 00:04:05,970
and that's what is commonly actually

00:04:02,760 --> 00:04:10,260
used however that's not enough because

00:04:05,970 --> 00:04:11,310
RSA has a fixed size of the message if

00:04:10,260 --> 00:04:12,900
you can encrypt

00:04:11,310 --> 00:04:15,120
and that correspond to the lack of the

00:04:12,900 --> 00:04:17,900
key you also have to do some padding and

00:04:15,120 --> 00:04:21,000
that if we randomized because we don't

00:04:17,900 --> 00:04:23,310
break I say it so there are a bunch of

00:04:21,000 --> 00:04:25,169
details and you can search for this

00:04:23,310 --> 00:04:28,590
paper for 20 years of attacks on their

00:04:25,169 --> 00:04:31,050
ass a cryptosystem and we'll give you

00:04:28,590 --> 00:04:33,030
all the details you want to know and all

00:04:31,050 --> 00:04:34,940
the pointers to other papers to go in

00:04:33,030 --> 00:04:38,910
deep in the mathematics if you want to

00:04:34,940 --> 00:04:41,389
so if you follow all of these things we

00:04:38,910 --> 00:04:43,139
can do it right you're gonna write it

00:04:41,389 --> 00:04:46,669
wait a second

00:04:43,139 --> 00:04:50,250
first of all the equation is very simple

00:04:46,669 --> 00:04:54,600
but I didn't say that he uses really

00:04:50,250 --> 00:04:57,120
really really big numbers so you cannot

00:04:54,600 --> 00:04:59,280
really use your floating-point units and

00:04:57,120 --> 00:05:01,320
it's in a cpu for example to delete it

00:04:59,280 --> 00:05:04,520
because you need perfect precision and

00:05:01,320 --> 00:05:09,060
floating-point units are imprecise and

00:05:04,520 --> 00:05:12,419
so you have to write or find an

00:05:09,060 --> 00:05:15,210
arbitrary procedure library to deal with

00:05:12,419 --> 00:05:17,970
these huge numbers of your total now is

00:05:15,210 --> 00:05:21,270
allowed 1000 beats do doesn't means

00:05:17,970 --> 00:05:23,660
4,000 is or 8000 interval so they're

00:05:21,270 --> 00:05:26,789
really really big several of several

00:05:23,660 --> 00:05:30,560
hundred bytes for each single number

00:05:26,789 --> 00:05:32,970
you also need five numbers generator

00:05:30,560 --> 00:05:35,760
because you need to generate keys if you

00:05:32,970 --> 00:05:37,979
want to do anything anymore so and that

00:05:35,760 --> 00:05:40,169
has to be a good one has to have new

00:05:37,979 --> 00:05:42,600
tests for formality to make sure there's

00:05:40,169 --> 00:05:44,039
actually a prime number because if you

00:05:42,600 --> 00:05:48,690
don't use prime numbers in the same

00:05:44,039 --> 00:05:51,330
expert and you also need also good

00:05:48,690 --> 00:05:53,280
cheese yeah cryptographic secure cell

00:05:51,330 --> 00:05:56,300
run generator normally because if we use

00:05:53,280 --> 00:05:56,300
more random doing

00:05:56,600 --> 00:06:02,540
encryption/decryption so assuming we

00:06:00,440 --> 00:06:05,480
will do all that and we cheat a little

00:06:02,540 --> 00:06:07,550
bit because we choose GMP no multi

00:06:05,480 --> 00:06:10,160
precision automatic library I choose

00:06:07,550 --> 00:06:12,770
this one because that's the libraries

00:06:10,160 --> 00:06:17,060
using level which is project was working

00:06:12,770 --> 00:06:20,200
for to fix this then we cheat of the

00:06:17,060 --> 00:06:23,000
width because the math handle there and

00:06:20,200 --> 00:06:25,460
this is how you decrypt they are say

00:06:23,000 --> 00:06:31,580
frenzy all right it's just a single

00:06:25,460 --> 00:06:34,910
function call done right but this is a

00:06:31,580 --> 00:06:39,560
bit slow and your users may gather your

00:06:34,910 --> 00:06:41,000
patience if you just this one so you go

00:06:39,560 --> 00:06:43,430
ahead and say okay let's try to make a

00:06:41,000 --> 00:06:46,580
little bit faster so at least people can

00:06:43,430 --> 00:06:48,590
actually use it use a little bit of math

00:06:46,580 --> 00:06:50,750
I'm not going to explain what it is but

00:06:48,590 --> 00:06:54,380
it has to do is China's reminder theorem

00:06:50,750 --> 00:06:57,410
another thing to make the public's :

00:06:54,380 --> 00:06:59,930
small again but even not provably secure

00:06:57,410 --> 00:07:02,330
way probably in the sense that nobody

00:06:59,930 --> 00:07:04,580
has proven this broken but there's also

00:07:02,330 --> 00:07:06,740
no proof that it's not broken but in 30

00:07:04,580 --> 00:07:10,610
years nobody found a problem with this

00:07:06,740 --> 00:07:13,280
project so we are fine and so now our

00:07:10,610 --> 00:07:17,210
simple functions just a little bit

00:07:13,280 --> 00:07:19,040
longer 10 times less long all right okay

00:07:17,210 --> 00:07:23,080
right it's not it's still not a big deal

00:07:19,040 --> 00:07:28,570
but this was to decrypt or sign a

00:07:23,080 --> 00:07:31,310
message so I think is fun right okay

00:07:28,570 --> 00:07:32,900
maybe you're fine baby not I think we

00:07:31,310 --> 00:07:35,150
should go back to the paper I mentioned

00:07:32,900 --> 00:07:37,520
and breathe a little bit more because we

00:07:35,150 --> 00:07:39,260
read about the math but we didn't read

00:07:37,520 --> 00:07:42,980
what happens when you actually

00:07:39,260 --> 00:07:45,670
implements that's the way I should so

00:07:42,980 --> 00:07:48,140
there are a few things we need to

00:07:45,670 --> 00:07:51,380
consider when writing something like

00:07:48,140 --> 00:07:53,570
this math can be used not only to break

00:07:51,380 --> 00:07:55,639
the message system but also to analyze

00:07:53,570 --> 00:07:58,249
the implementation and find it in

00:07:55,639 --> 00:08:02,599
additional sports and then use those

00:07:58,249 --> 00:08:05,029
faults to recover keys so there are at

00:08:02,599 --> 00:08:07,279
least three famous attacks that I'm just

00:08:05,029 --> 00:08:10,699
going to mention very briefly one is

00:08:07,279 --> 00:08:14,419
timing attacks meaning that if you just

00:08:10,699 --> 00:08:16,400
you know run the function or depending

00:08:14,419 --> 00:08:19,550
on what the keys you will have different

00:08:16,400 --> 00:08:21,860
things happening inside the CPU and an

00:08:19,550 --> 00:08:26,900
attacker can actually time how you do

00:08:21,860 --> 00:08:30,020
things and recovery upkeep and so Rivest

00:08:26,900 --> 00:08:32,870
which is one of the guys behind there I

00:08:30,020 --> 00:08:35,180
can never say immediately found a way to

00:08:32,870 --> 00:08:36,440
defeat with attack and using blinding

00:08:35,180 --> 00:08:39,550
and will see the negative of lightning

00:08:36,440 --> 00:08:42,409
miss so that can be taken care of

00:08:39,550 --> 00:08:44,839
not a problem is around the false so

00:08:42,409 --> 00:08:48,620
believe it or not computer sometimes and

00:08:44,839 --> 00:08:50,959
but in their CPUs mathematic live reason

00:08:48,620 --> 00:08:53,480
of bugs and people make you know

00:08:50,959 --> 00:08:57,290
mistakes in general the problem is with

00:08:53,480 --> 00:09:02,390
our say if you have a Miss thing in the

00:08:57,290 --> 00:09:03,589
map and you get it wrong like the wrong

00:09:02,390 --> 00:09:04,760
signature first time in case you're

00:09:03,589 --> 00:09:07,880
making a senior so rather than

00:09:04,760 --> 00:09:11,269
decrypting then and you then sent out

00:09:07,880 --> 00:09:13,880
this signature broken then you broke the

00:09:11,269 --> 00:09:17,420
letter say we've enough that signature

00:09:13,880 --> 00:09:18,920
you can recover the privacy okay so you

00:09:17,420 --> 00:09:20,779
have to be careful but that's easy you

00:09:18,920 --> 00:09:24,500
will check that the signature it's right

00:09:20,779 --> 00:09:27,199
and you're done and finally one of the

00:09:24,500 --> 00:09:31,390
most famous braking marker I hope I say

00:09:27,199 --> 00:09:35,360
right attack some pkcs1 the kcs one is

00:09:31,390 --> 00:09:37,940
basically one of the standard ways of

00:09:35,360 --> 00:09:42,709
doing padding as I said before or say

00:09:37,940 --> 00:09:44,810
can only sign or encrypt messages of

00:09:42,709 --> 00:09:46,730
fixed size but you usually want to say

00:09:44,810 --> 00:09:49,490
you know random stuff so what you do you

00:09:46,730 --> 00:09:51,709
just have some padding to your message

00:09:49,490 --> 00:09:54,260
so you can reach the size of the key so

00:09:51,709 --> 00:09:56,959
even if it magic message is more or if

00:09:54,260 --> 00:09:58,760
your message is large and pieces but at

00:09:56,959 --> 00:10:00,110
some point you will have to put some

00:09:58,760 --> 00:10:03,320
padding

00:10:00,110 --> 00:10:05,120
the size of the key depending on how you

00:10:03,320 --> 00:10:07,550
do that and how you handle errors in

00:10:05,120 --> 00:10:10,130
case of the Christian you may get into

00:10:07,550 --> 00:10:13,279
trouble and come back a fine place the

00:10:10,130 --> 00:10:15,260
best in recover enough information state

00:10:13,279 --> 00:10:17,570
or machine to recover the keys again so

00:10:15,260 --> 00:10:21,829
you really have to be careful about

00:10:17,570 --> 00:10:27,470
these things and our function which now

00:10:21,829 --> 00:10:29,269
is in here basically the premise of code

00:10:27,470 --> 00:10:32,060
is not enough so you have to do a little

00:10:29,269 --> 00:10:33,440
bit more stuff so we cheat a little bit

00:10:32,060 --> 00:10:34,910
again we say that we have just one

00:10:33,440 --> 00:10:39,649
function that will generate a very good

00:10:34,910 --> 00:10:43,220
random - to do the blind and blinding is

00:10:39,649 --> 00:10:45,470
a way to avoid tiny attacks how time

00:10:43,220 --> 00:10:47,269
attacks work if you have a server like

00:10:45,470 --> 00:10:49,250
the other it means it can keep sending

00:10:47,269 --> 00:10:51,620
stuff to the server to the server is

00:10:49,250 --> 00:10:53,600
there to serve requests my clients and

00:10:51,620 --> 00:10:55,220
that means you have an Oracle it means

00:10:53,600 --> 00:10:55,730
that the sermon would keep trying to

00:10:55,220 --> 00:10:58,510
decrypt

00:10:55,730 --> 00:11:00,829
you know clients send the stuff to them

00:10:58,510 --> 00:11:03,199
and if you can repeat the operation over

00:11:00,829 --> 00:11:04,940
and over you can pass with time what

00:11:03,199 --> 00:11:08,329
happens into the machine

00:11:04,940 --> 00:11:10,040
statistically now the single bridge and

00:11:08,329 --> 00:11:11,899
because you can send always the same

00:11:10,040 --> 00:11:14,360
message you can time precisely always

00:11:11,899 --> 00:11:16,160
the same decryption if you don't do

00:11:14,360 --> 00:11:19,430
anything or the same signature

00:11:16,160 --> 00:11:21,560
verification depending on the product so

00:11:19,430 --> 00:11:23,720
in order to have always a different

00:11:21,560 --> 00:11:26,300
computation such that the state cannot

00:11:23,720 --> 00:11:29,269
record your statistical methods you

00:11:26,300 --> 00:11:31,069
basically multiply stuff random number

00:11:29,269 --> 00:11:33,680
and then you do your computation then

00:11:31,069 --> 00:11:37,100
you multiply by the inverse that's a

00:11:33,680 --> 00:11:40,490
bunch of math bachelors yes

00:11:37,100 --> 00:11:44,540
and our code is twice as big but still

00:11:40,490 --> 00:11:46,519
yeah okay then we have close to check

00:11:44,540 --> 00:11:49,399
our signatures for random Falls and

00:11:46,519 --> 00:11:51,740
stuff like that so more or less as

00:11:49,399 --> 00:11:54,110
before we just do some checking and

00:11:51,740 --> 00:11:56,510
luckily for us because the public public

00:11:54,110 --> 00:11:58,430
exponent is small we can just do an

00:11:56,510 --> 00:11:59,600
exponentiation without her needing any

00:11:58,430 --> 00:12:01,690
tricks to make it fast

00:11:59,600 --> 00:12:04,210
let me just check it out

00:12:01,690 --> 00:12:06,460
okay and so we've done that as well I'll

00:12:04,210 --> 00:12:08,970
get to extractions more which is

00:12:06,460 --> 00:12:11,170
achieved because underneath there is a

00:12:08,970 --> 00:12:12,430
the mathematical library there's a bunch

00:12:11,170 --> 00:12:15,430
of stuff but let's say it's just

00:12:12,430 --> 00:12:17,860
posterior and they're from lekin Barker

00:12:15,430 --> 00:12:20,470
one of the defense that is using TLS is

00:12:17,860 --> 00:12:22,990
pretty simple if you get an error in the

00:12:20,470 --> 00:12:25,540
decryption because TLS uses this there

00:12:22,990 --> 00:12:29,530
are say mostly just to share session

00:12:25,540 --> 00:12:31,450
keys we just pretend that this equation

00:12:29,530 --> 00:12:33,340
was actually successful we generate

00:12:31,450 --> 00:12:35,050
random session key and we keep using it

00:12:33,340 --> 00:12:38,620
and the attacker doesn't know whether

00:12:35,050 --> 00:12:41,590
this is like here or not and so it

00:12:38,620 --> 00:12:50,020
cannot gain a lot of information about

00:12:41,590 --> 00:12:51,940
the state we don't yet know that comes

00:12:50,020 --> 00:12:55,960
around there the fun stuff that you have

00:12:51,940 --> 00:12:57,880
to deal with something that others also

00:12:55,960 --> 00:13:00,420
mentioned side-channel attacks this is

00:12:57,880 --> 00:13:05,200
all the rage if you've seen you know

00:13:00,420 --> 00:13:07,720
recent CPU issues with you know

00:13:05,200 --> 00:13:09,460
speculation you don't have to go all the

00:13:07,720 --> 00:13:12,490
way the speculation to the side channel

00:13:09,460 --> 00:13:16,170
attacks with modern CPUs cache is that

00:13:12,490 --> 00:13:19,170
actually shared you know within a core

00:13:16,170 --> 00:13:22,300
and you can do run nice tricks like

00:13:19,170 --> 00:13:24,610
forcing the CPUs dumb caches and then

00:13:22,300 --> 00:13:26,740
inspect whether the cache line was

00:13:24,610 --> 00:13:28,870
actually loaded by trying to no didn't

00:13:26,740 --> 00:13:30,850
see how much time it takes basically you

00:13:28,870 --> 00:13:32,710
can measure what another process is

00:13:30,850 --> 00:13:35,620
doing if you really know what to look

00:13:32,710 --> 00:13:39,190
for and that measuring when it comes to

00:13:35,620 --> 00:13:41,650
her say he's bad because basically just

00:13:39,190 --> 00:13:44,410
like timing attack and I'll attack like

00:13:41,650 --> 00:13:46,510
that so we kind of go back to the

00:13:44,410 --> 00:13:49,690
drawing board a little bit and a few

00:13:46,510 --> 00:13:52,270
researchers late last year came out with

00:13:49,690 --> 00:13:56,070
this paper the ten the nine lives of

00:13:52,270 --> 00:14:00,450
like in market path which showed that

00:13:56,070 --> 00:14:04,540
basically must TLS implementations we're

00:14:00,450 --> 00:14:06,130
back where it could be broken local on

00:14:04,540 --> 00:14:06,940
the local machine you cannot do that

00:14:06,130 --> 00:14:11,300
over

00:14:06,940 --> 00:14:14,149
however if you use maybe even

00:14:11,300 --> 00:14:15,890
vaporization but if use containers or if

00:14:14,149 --> 00:14:17,270
you have brewed processes running a DNS

00:14:15,890 --> 00:14:20,060
server but you also have users on the

00:14:17,270 --> 00:14:24,070
same system you are in the local case

00:14:20,060 --> 00:14:32,270
and so you can attack other processes

00:14:24,070 --> 00:14:36,740
with these methods so how do we go try

00:14:32,270 --> 00:14:39,920
to defeat catch and title track the

00:14:36,740 --> 00:14:42,200
problem with these attacks is that your

00:14:39,920 --> 00:14:44,750
CPU is will work that can be measured by

00:14:42,200 --> 00:14:47,420
someone else so we need to make the CPU

00:14:44,750 --> 00:14:50,330
to work so that every time you measure

00:14:47,420 --> 00:14:52,070
it it's always exactly the same

00:14:50,330 --> 00:14:54,170
regardless of what you're doing

00:14:52,070 --> 00:14:56,029
meaning regardless of the inputs that

00:14:54,170 --> 00:14:59,510
the attacker is sending here so the

00:14:56,029 --> 00:15:01,310
attack is trying to send you no messages

00:14:59,510 --> 00:15:02,839
to a TLS server another process and

00:15:01,310 --> 00:15:08,029
trying to measure what happens on the

00:15:02,839 --> 00:15:10,220
CPU at the same time so well we need to

00:15:08,029 --> 00:15:11,990
go all the way down to the mathematical

00:15:10,220 --> 00:15:13,610
library first of all does all these

00:15:11,990 --> 00:15:17,000
issues because if the mathematical

00:15:13,610 --> 00:15:19,550
library takes one millisecond to do one

00:15:17,000 --> 00:15:21,350
exponentiation and ten millisecond to do

00:15:19,550 --> 00:15:23,360
another depending what are the inputs

00:15:21,350 --> 00:15:26,120
that's wrong because as I said they have

00:15:23,360 --> 00:15:29,839
to take the same time luckily for us in

00:15:26,120 --> 00:15:32,600
the sense me when I was writing a fixes

00:15:29,839 --> 00:15:37,490
the GMP library already has a bunch of

00:15:32,600 --> 00:15:40,190
fog to the lower level and not abstract

00:15:37,490 --> 00:15:43,390
interface they're called underbar second

00:15:40,190 --> 00:15:47,870
bar which hopefully means that they are

00:15:43,390 --> 00:15:51,320
safe from the point of view of always

00:15:47,870 --> 00:15:52,080
taking the same time with the condition

00:15:51,320 --> 00:15:54,480
that

00:15:52,080 --> 00:15:57,840
is the same size but for our size is not

00:15:54,480 --> 00:16:00,270
a problem because we use just always the

00:15:57,840 --> 00:16:01,890
same key energy on a server so always

00:16:00,270 --> 00:16:03,330
the same key to the decryption so the

00:16:01,890 --> 00:16:05,460
size of the key or the size of the

00:16:03,330 --> 00:16:07,140
exponents over the same so every time

00:16:05,460 --> 00:16:10,830
the packet for the cell is something we

00:16:07,140 --> 00:16:12,480
use always the same size so with that we

00:16:10,830 --> 00:16:18,060
should be kind of fun

00:16:12,480 --> 00:16:21,870
so I'm not going that but what happened

00:16:18,060 --> 00:16:25,620
is that we went from one function to

00:16:21,870 --> 00:16:30,090
compute you know a signature or

00:16:25,620 --> 00:16:33,060
scripture decryption to function about

00:16:30,090 --> 00:16:36,300
analyze as we saw in example two eight

00:16:33,060 --> 00:16:40,710
function 400 sir so that's kind of

00:16:36,300 --> 00:16:42,600
unfold again and to change the padding

00:16:40,710 --> 00:16:45,710
function which was also one of the

00:16:42,600 --> 00:16:45,710
easiest to break

00:16:48,770 --> 00:16:56,370
side-channel resistant functions so but

00:16:52,410 --> 00:16:58,770
20 lines to to functionalize so by the

00:16:56,370 --> 00:17:01,320
end of their work which is lasted that

00:16:58,770 --> 00:17:03,930
be more than a month where there were

00:17:01,320 --> 00:17:08,490
almost 40 commits we've kept same

00:17:03,930 --> 00:17:11,010
container as part of this CD and I just

00:17:08,490 --> 00:17:13,740
want to show you is more an example of

00:17:11,010 --> 00:17:15,510
what we have to do because these was

00:17:13,740 --> 00:17:20,040
actually really hard I have to say

00:17:15,510 --> 00:17:21,930
really hard not because the code is

00:17:20,040 --> 00:17:24,030
necessarily any harder than any other

00:17:21,930 --> 00:17:26,010
code but because you have to really put

00:17:24,030 --> 00:17:28,920
yourself in a mental state where you

00:17:26,010 --> 00:17:34,020
consider every possibility like when I

00:17:28,920 --> 00:17:35,400
say that you cannot run stuff that have

00:17:34,020 --> 00:17:38,460
two different types of means you cannot

00:17:35,400 --> 00:17:40,320
use conditionals you cannot say if the

00:17:38,460 --> 00:17:43,770
key is larger than these or if you know

00:17:40,320 --> 00:17:45,510
the key has a 1 and then do something or

00:17:43,770 --> 00:17:47,790
do something else because you have taken

00:17:45,510 --> 00:17:49,800
two branches in the code and that is

00:17:47,790 --> 00:17:52,800
measurable the attacker could force the

00:17:49,800 --> 00:17:54,960
code out of the memory just one of the

00:17:52,800 --> 00:17:58,800
two gravities and the measure which Brad

00:17:54,960 --> 00:17:59,900
she took in the CPU so you will know if

00:17:58,800 --> 00:18:02,090
the first bit was one

00:17:59,900 --> 00:18:03,590
zero if ii was what i was your third

00:18:02,090 --> 00:18:05,990
block my back and then you can recover

00:18:03,590 --> 00:18:08,270
the key this is simplified doesn't work

00:18:05,990 --> 00:18:10,250
like that but that's what happens so you

00:18:08,270 --> 00:18:13,160
have to bezel breaking mind and find

00:18:10,250 --> 00:18:15,650
ways to do conditionals without doing

00:18:13,160 --> 00:18:17,840
commissions and this is kind of

00:18:15,650 --> 00:18:20,240
deceiving and i'm gonna show you why men

00:18:17,840 --> 00:18:21,500
copy is conditional here you have to

00:18:20,240 --> 00:18:24,050
realize this commission that tried to

00:18:21,500 --> 00:18:27,980
fix so this is just what happens at the

00:18:24,050 --> 00:18:29,540
end of the pkcs1 padding or d-pad in

00:18:27,980 --> 00:18:31,130
front in this case when you want to

00:18:29,540 --> 00:18:33,170
remove the matter that kind of message

00:18:31,130 --> 00:18:36,200
as I said because ever say uses fixed on

00:18:33,170 --> 00:18:37,610
skis you have to some patio and then you

00:18:36,200 --> 00:18:39,950
go right and the rest is the message

00:18:37,610 --> 00:18:42,860
okay and the why did because just what

00:18:39,950 --> 00:18:44,330
Dida is really really bad don't use

00:18:42,860 --> 00:18:47,330
because what anymore

00:18:44,330 --> 00:18:48,980
other stuff but it basically has a

00:18:47,330 --> 00:18:50,450
little header then there's a bunch of

00:18:48,980 --> 00:18:52,760
padding they didn't know how much how

00:18:50,450 --> 00:18:56,450
long it is and there is a terminator

00:18:52,760 --> 00:18:59,240
let's say it says you're right and then

00:18:56,450 --> 00:19:02,000
you have your message now if you just go

00:18:59,240 --> 00:19:04,040
normal like we did before and you say

00:19:02,000 --> 00:19:06,380
bunch of functions to find will

00:19:04,040 --> 00:19:09,410
intermediaries all the sponsor our

00:19:06,380 --> 00:19:11,360
diamond attacks is all that but assume

00:19:09,410 --> 00:19:13,100
years old that then your left me oh I

00:19:11,360 --> 00:19:15,620
need to copy the message in the buffer

00:19:13,100 --> 00:19:18,800
to return to the application right but

00:19:15,620 --> 00:19:20,700
if you do that measurable because if

00:19:18,800 --> 00:19:23,549
you're becaus

00:19:20,700 --> 00:19:25,710
they decrypted message before the dapat

00:19:23,549 --> 00:19:29,940
account to be for some memory out of the

00:19:25,710 --> 00:19:32,369
cache then this mem copy will just load

00:19:29,940 --> 00:19:34,350
the last part of the buffer in memory

00:19:32,369 --> 00:19:37,139
and again the attacker can find out the

00:19:34,350 --> 00:19:40,619
land and from the land can find bunch of

00:19:37,139 --> 00:19:44,489
information so we have to copy that

00:19:40,619 --> 00:19:48,139
bathroom into the destination always

00:19:44,489 --> 00:19:50,249
this with the same amount of operation

00:19:48,139 --> 00:19:51,989
regardless of the length of the message

00:19:50,249 --> 00:19:53,960
the message could be long you know the

00:19:51,989 --> 00:19:57,749
whole thing or just be one bite

00:19:53,960 --> 00:19:59,279
and so we end up with this thing which I

00:19:57,749 --> 00:20:03,779
don't know how to describe but it's

00:19:59,279 --> 00:20:06,210
really nice notice that I'm cheating I'm

00:20:03,779 --> 00:20:08,879
using also this called tournament copy

00:20:06,210 --> 00:20:11,970
which are special man copy functions

00:20:08,879 --> 00:20:16,429
that we are depending on the first

00:20:11,970 --> 00:20:18,779
parameter copy to the destination buffer

00:20:16,429 --> 00:20:21,950
what's in the distance your buffer Oh

00:20:18,779 --> 00:20:25,200
wasn't this horse power again in a way

00:20:21,950 --> 00:20:26,970
that an attacker cannot check from where

00:20:25,200 --> 00:20:29,399
you're happy with sir that's already

00:20:26,970 --> 00:20:33,210
cheated here but again in the end what

00:20:29,399 --> 00:20:36,720
happens you have a logarithmic time

00:20:33,210 --> 00:20:40,769
function where you end up copy the whole

00:20:36,720 --> 00:20:42,600
buffer one by two bars for by assisting

00:20:40,769 --> 00:20:46,730
by their column and so on until you copy

00:20:42,600 --> 00:20:49,289
know and hopefully if you got it right

00:20:46,730 --> 00:20:51,470
it always take the same time regardless

00:20:49,289 --> 00:20:57,179
of the length of the rest of the buffer

00:20:51,470 --> 00:20:59,940
and so yeah like just look at this for

00:20:57,179 --> 00:21:03,659
this one it was an if-then-else

00:20:59,940 --> 00:21:06,960
statement now it's hopefully not

00:21:03,659 --> 00:21:10,970
traditional and it still provides the

00:21:06,960 --> 00:21:10,970
leg out as a condition so yeah

00:21:12,520 --> 00:21:20,410
so from a naive to reasonably secure

00:21:16,809 --> 00:21:23,679
implementation we increased you know

00:21:20,410 --> 00:21:25,900
from just a basic recite venture all the

00:21:23,679 --> 00:21:29,770
way to the latest handle it that's

00:21:25,900 --> 00:21:34,690
thwarted magnet is more current which is

00:21:29,770 --> 00:21:36,900
quite a bit and takeaway for me is you

00:21:34,690 --> 00:21:42,820
know the you know the saying you know

00:21:36,900 --> 00:21:45,610
good cheap fast used to the security

00:21:42,820 --> 00:21:48,040
case almost like choose one

00:21:45,610 --> 00:21:53,320
it's either fast fast fast very very

00:21:48,040 --> 00:21:56,260
very secure or very very simple but you

00:21:53,320 --> 00:21:58,000
can't have even two or rather you have

00:21:56,260 --> 00:22:01,809
to have a compromise usually between

00:21:58,000 --> 00:22:03,730
speed and security but every time you

00:22:01,809 --> 00:22:08,470
know Security's broken you just have to

00:22:03,730 --> 00:22:11,220
give up speed and so this is it for me

00:22:08,470 --> 00:22:11,220
questions

00:22:31,210 --> 00:22:34,319
[Music]

00:22:36,520 --> 00:22:42,679
so the question the remark was a low but

00:22:40,730 --> 00:22:46,669
it's all these laptop which is CV they

00:22:42,679 --> 00:22:47,870
actually fix the disable so we were in

00:22:46,669 --> 00:22:50,690
content as well with the same

00:22:47,870 --> 00:22:53,299
researchers and your statement is true I

00:22:50,690 --> 00:22:55,700
will have to say that it open ourselves

00:22:53,299 --> 00:22:57,890
this I did not raise a CV by changing

00:22:55,700 --> 00:23:01,809
the definition of the track model thanks

00:22:57,890 --> 00:23:04,850
no look what that model for OpenSSL I

00:23:01,809 --> 00:23:07,130
reviewed their their changes they were

00:23:04,850 --> 00:23:10,309
lucky that they already had done a bunch

00:23:07,130 --> 00:23:13,700
of aside channel resistance changes in

00:23:10,309 --> 00:23:18,110
their math library before also never say

00:23:13,700 --> 00:23:19,880
so they had less code to write however

00:23:18,110 --> 00:23:21,679
I'm not conversant confident that he

00:23:19,880 --> 00:23:24,020
also did get right of the patches they

00:23:21,679 --> 00:23:27,020
did I didn't look at the assembly I

00:23:24,020 --> 00:23:29,690
looked at the patches and they basically

00:23:27,020 --> 00:23:31,460
ended up doing what I could have done to

00:23:29,690 --> 00:23:33,620
some degree in my first vision that I

00:23:31,460 --> 00:23:37,520
need for metal but we did a second

00:23:33,620 --> 00:23:39,500
revision a little bit forward so it's

00:23:37,520 --> 00:23:42,140
really hard to get this thing right I

00:23:39,500 --> 00:23:44,630
don't think we got it right in there

00:23:42,140 --> 00:23:46,520
either the probably some compiler

00:23:44,630 --> 00:23:48,980
optimization that we're not we were not

00:23:46,520 --> 00:23:52,010
able we be able to defeat maybe there

00:23:48,980 --> 00:23:54,830
are we defeated them on exactly 664 but

00:23:52,010 --> 00:23:56,570
not not secure sir it's really really

00:23:54,830 --> 00:23:59,030
hard and one of the issues that we don't

00:23:56,570 --> 00:24:00,650
have any test to figure out whether I

00:23:59,030 --> 00:24:02,570
mean attachment these are really

00:24:00,650 --> 00:24:04,880
different about because it's very hard

00:24:02,570 --> 00:24:10,030
also right at accident

00:24:04,880 --> 00:24:10,030
so yeah that's right but they changed

00:24:10,110 --> 00:24:14,610
okay I think we're out of time

00:24:12,880 --> 00:24:22,930
thank you

00:24:14,610 --> 00:24:22,930

YouTube URL: https://www.youtube.com/watch?v=TdZ6QEPi3mc


