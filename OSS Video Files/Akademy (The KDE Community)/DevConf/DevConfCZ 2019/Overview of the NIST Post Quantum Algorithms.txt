Title: Overview of the NIST Post Quantum Algorithms
Publication date: 2019-03-04
Playlist: DevConfCZ 2019
Description: 
	Presentation name: Overview of the NIST Post Quantum Algorithms
Speaker: Robert Relyea
Description:  This session will have a high level overview of the various NIST post-Quantum algorithms: 1) why they are needed, 2) how the families of the various algorithms work. 3) what are the broad characteristics of those families, 4) what algorithms are in those families, 5) how some of the one offs work. 6) Where to go to play with the algorithms. 5) What are the next steps in the competition.
[ https://sched.co/Jcdj]
Captions: 
	00:00:06,080 --> 00:00:12,150
I'm just gonna dive right in

00:00:08,370 --> 00:00:14,100
since I've been in a boost about three

00:00:12,150 --> 00:00:17,609
years you three years ago I gave a talk

00:00:14,100 --> 00:00:20,249
on the issues of a host quantum crypto

00:00:17,609 --> 00:00:25,820
so today I'm talking you're going to be

00:00:20,249 --> 00:00:29,519
talking about the mist contests or for

00:00:25,820 --> 00:00:31,289
determining standardizing post quantum

00:00:29,519 --> 00:00:36,450
crypto algorithms to be able to be used

00:00:31,289 --> 00:00:37,620
in our systems so what I'm going to talk

00:00:36,450 --> 00:00:39,810
about today I'm going to do a quick

00:00:37,620 --> 00:00:41,880
review over some of the stuff I talked

00:00:39,810 --> 00:00:43,800
about three years ago just put us in on

00:00:41,880 --> 00:00:47,460
the level set then we're going to talk

00:00:43,800 --> 00:00:53,700
about the specifics of the mist contest

00:00:47,460 --> 00:00:55,640
what NIST is looking for what you know

00:00:53,700 --> 00:00:58,230
what kind of algorithms they got etc

00:00:55,640 --> 00:01:01,710
I'll do a quick review of some of the

00:00:58,230 --> 00:01:04,379
major four major post quantum systems

00:01:01,710 --> 00:01:07,860
that we then I discussed three years ago

00:01:04,379 --> 00:01:09,150
it'll be very quick overview and then

00:01:07,860 --> 00:01:10,680
we'll look at some of the unique

00:01:09,150 --> 00:01:13,760
algorithm some of the algorithms that

00:01:10,680 --> 00:01:17,280
don't fall into those categories and

00:01:13,760 --> 00:01:18,900
then we'll talk about some conclusions

00:01:17,280 --> 00:01:21,150
what I'm not going to do is I'm not

00:01:18,900 --> 00:01:24,360
going to go into the math behind any of

00:01:21,150 --> 00:01:28,110
these systems and we're not gonna do any

00:01:24,360 --> 00:01:30,500
deep dives other than some of the unique

00:01:28,110 --> 00:01:35,370
algorithms on how these algorithms work

00:01:30,500 --> 00:01:38,490
so the first thing post quantum

00:01:35,370 --> 00:01:40,950
computers are coming IBM last month and

00:01:38,490 --> 00:01:44,310
announced the commercial availability of

00:01:40,950 --> 00:01:46,950
their quantum computer they've actually

00:01:44,310 --> 00:01:51,240
had it available for over a year for

00:01:46,950 --> 00:01:53,010
researchers it's a 20-bit so we're not

00:01:51,240 --> 00:01:55,979
like worried about breaking anything

00:01:53,010 --> 00:01:58,530
with it but the fact that I'm talking

00:01:55,979 --> 00:02:04,650
about a real machine that does 20 bits

00:01:58,530 --> 00:02:05,939
of quantum is something that I couldn't

00:02:04,650 --> 00:02:08,770
say three years ago when I gave this

00:02:05,939 --> 00:02:13,090
talk so they're coming there

00:02:08,770 --> 00:02:17,500
it's moving faster it's not now looking

00:02:13,090 --> 00:02:19,870
like not when not if but when we're

00:02:17,500 --> 00:02:22,300
going to have quantum computers quantum

00:02:19,870 --> 00:02:23,940
computers allow us to be able to solve

00:02:22,300 --> 00:02:27,280
some problems that we can't solve

00:02:23,940 --> 00:02:30,520
quickly in classical computers do this

00:02:27,280 --> 00:02:33,400
certain kinds of parallelization not

00:02:30,520 --> 00:02:36,280
every hard problem can be solved with

00:02:33,400 --> 00:02:38,260
quantum computers unfortunately some of

00:02:36,280 --> 00:02:41,710
the ones that can are all of our

00:02:38,260 --> 00:02:45,010
existing public key systems so RS ADHD

00:02:41,710 --> 00:02:48,730
sa easy.all Altos once you have product

00:02:45,010 --> 00:02:51,640
computers there are some algorithms for

00:02:48,730 --> 00:02:56,260
finding for doing general solutions you

00:02:51,640 --> 00:02:58,240
have a a single answer to a problem and

00:02:56,260 --> 00:02:59,890
you can check that single answer if you

00:02:58,240 --> 00:03:01,600
can do that you can find that answer

00:02:59,890 --> 00:03:05,920
with a quantum computer in square root

00:03:01,600 --> 00:03:09,730
two time rather than slow time in the in

00:03:05,920 --> 00:03:11,680
our existing systems but that doesn't

00:03:09,730 --> 00:03:13,150
really break our symmetric algorithms it

00:03:11,680 --> 00:03:14,620
means that our key sizes have to be

00:03:13,150 --> 00:03:18,760
twice as big in order to have the same

00:03:14,620 --> 00:03:20,650
security hashes would be the same thing

00:03:18,760 --> 00:03:23,260
that our hash functions are already

00:03:20,650 --> 00:03:25,690
twice as big because of collisions

00:03:23,260 --> 00:03:29,890
because in collision cases we have a

00:03:25,690 --> 00:03:32,590
root in time anyway so not really a

00:03:29,890 --> 00:03:35,770
whole lot of hurt to our symmetric and

00:03:32,590 --> 00:03:37,780
hash algorithms there are sets of

00:03:35,770 --> 00:03:40,540
algorithms that are quantum safe that we

00:03:37,780 --> 00:03:45,400
can do public key operations with or

00:03:40,540 --> 00:03:47,230
thought to be quantum safe and we'll

00:03:45,400 --> 00:03:49,870
talk about the some of the issues with

00:03:47,230 --> 00:03:52,270
them and when we need those algorithms

00:03:49,870 --> 00:03:54,970
depends on how long you want to secure

00:03:52,270 --> 00:03:57,820
your data so if you want to secure data

00:03:54,970 --> 00:03:59,980
for ten years make sure it's a symmetric

00:03:57,820 --> 00:04:01,960
key encrypted don't use a public key

00:03:59,980 --> 00:04:06,760
system because it will probably be

00:04:01,960 --> 00:04:10,360
broken by then okay well because we're

00:04:06,760 --> 00:04:13,780
in this case where we're actually

00:04:10,360 --> 00:04:16,840
running up where we really needed these

00:04:13,780 --> 00:04:20,840
post quantum algorithms yesterday NIST

00:04:16,840 --> 00:04:24,520
has started a new contest just like the

00:04:20,840 --> 00:04:28,550
and sha-3 contests looking for

00:04:24,520 --> 00:04:30,950
replacement so looking for proposals for

00:04:28,550 --> 00:04:33,710
replacements for our public key

00:04:30,950 --> 00:04:39,710
algorithms nist announced this contest

00:04:33,710 --> 00:04:44,270
in 2016 the submission deadline was in

00:04:39,710 --> 00:04:48,680
November 2017 so all last year they've

00:04:44,270 --> 00:04:51,560
been evaluating the submissions NIST got

00:04:48,680 --> 00:04:55,370
87 submissions of which they they

00:04:51,560 --> 00:04:59,200
continued considered 69 were properly

00:04:55,370 --> 00:05:02,810
formatted that is had all the right

00:04:59,200 --> 00:05:05,960
criteria met physical correct criteria

00:05:02,810 --> 00:05:09,200
of you had your alpha an algorithm you

00:05:05,960 --> 00:05:11,120
had a implementation for the algorithm

00:05:09,200 --> 00:05:13,580
you had all the right descriptions and

00:05:11,120 --> 00:05:18,050
documentation in place in order to be

00:05:13,580 --> 00:05:21,380
accepted of those 69 five of them were

00:05:18,050 --> 00:05:23,389
broken and later withdrawn and other

00:05:21,380 --> 00:05:25,669
four or five are broken but the

00:05:23,389 --> 00:05:29,600
presenters have not the team's have not

00:05:25,669 --> 00:05:32,360
withdrawn them yet there was a

00:05:29,600 --> 00:05:33,770
conference in April 2000 18 where

00:05:32,360 --> 00:05:37,190
everybody presented what their

00:05:33,770 --> 00:05:41,500
algorithms were there'll be a second

00:05:37,190 --> 00:05:43,789
workshop in in August of this year

00:05:41,500 --> 00:05:49,070
assuming the government shutdown didn't

00:05:43,789 --> 00:05:52,100
push that out and this plans to call

00:05:49,070 --> 00:05:56,450
that list down to 20 or so algorithm so

00:05:52,100 --> 00:05:58,340
we have 64 officially 64 algorithms

00:05:56,450 --> 00:06:03,169
still in the contest that should drop

00:05:58,340 --> 00:06:05,180
down to about 27 of those 64 don't fall

00:06:03,169 --> 00:06:10,460
into our traditional post quantum

00:06:05,180 --> 00:06:14,840
algorithm systems that we talked about

00:06:10,460 --> 00:06:17,200
before and this is going to select more

00:06:14,840 --> 00:06:19,310
than one algorithm for Standardization

00:06:17,200 --> 00:06:21,200
they're looking at maybe three or four

00:06:19,310 --> 00:06:23,090
of the algorithms and they're also

00:06:21,200 --> 00:06:25,970
saying when an algorithm drops out of

00:06:23,090 --> 00:06:30,110
their contest it may come back in some

00:06:25,970 --> 00:06:31,250
future standardization they're just

00:06:30,110 --> 00:06:33,260
trying to get

00:06:31,250 --> 00:06:34,790
get it down so that we can really focus

00:06:33,260 --> 00:06:39,410
on just a couple of them and make sure

00:06:34,790 --> 00:06:41,300
that they're really secure okay so most

00:06:39,410 --> 00:06:44,110
of the submissions were from teams of

00:06:41,300 --> 00:06:47,870
people only six had a single person

00:06:44,110 --> 00:06:50,090
submitting it and two-thirds of the

00:06:47,870 --> 00:06:52,910
submissions had teams that submitted

00:06:50,090 --> 00:06:54,800
more than had people members on their

00:06:52,910 --> 00:06:57,730
teams had submitted more than one

00:06:54,800 --> 00:07:01,430
application so there's people who some

00:06:57,730 --> 00:07:04,850
who were on several different teams and

00:07:01,430 --> 00:07:08,240
that was the more common case not the

00:07:04,850 --> 00:07:10,040
least common case of those that only had

00:07:08,240 --> 00:07:13,760
people who were on their team on one

00:07:10,040 --> 00:07:17,780
algorithm there were 26 submissions ten

00:07:13,760 --> 00:07:20,270
of those 26 were were broken so over

00:07:17,780 --> 00:07:24,080
almost half of the ones where you're

00:07:20,270 --> 00:07:27,980
only on one team are broken the other 43

00:07:24,080 --> 00:07:29,900
had about four broken and in three of

00:07:27,980 --> 00:07:33,700
the unique completely invented out of

00:07:29,900 --> 00:07:40,820
blue algorithms were broken immediately

00:07:33,700 --> 00:07:43,430
so when this presented this they what

00:07:40,820 --> 00:07:46,100
they're asking for is replacements for

00:07:43,430 --> 00:07:48,620
our signing encryption key encryption

00:07:46,100 --> 00:07:51,050
and just regular data encryption

00:07:48,620 --> 00:07:52,810
algorithms and they're looking for them

00:07:51,050 --> 00:07:57,490
in five different levels which

00:07:52,810 --> 00:08:03,290
correspond to the current security of

00:07:57,490 --> 00:08:07,640
AES 128 through AES 256 and their ass

00:08:03,290 --> 00:08:13,580
they ask the presenters to concentrate

00:08:07,640 --> 00:08:16,190
on the first three levels the they're

00:08:13,580 --> 00:08:18,680
going to evaluate them on how well they

00:08:16,190 --> 00:08:21,950
meet that security level they're also

00:08:18,680 --> 00:08:25,790
going to evaluate them on how well they

00:08:21,950 --> 00:08:31,010
perform are they can you do a operation

00:08:25,790 --> 00:08:33,469
in less than a day and in some they have

00:08:31,010 --> 00:08:35,479
some other nebulous criteria like

00:08:33,469 --> 00:08:38,409
drop-in replacement

00:08:35,479 --> 00:08:41,589
can we take an existing algorithm

00:08:38,409 --> 00:08:44,769
to call and drop in this algorithm

00:08:41,589 --> 00:08:47,079
without having to change it protocol

00:08:44,769 --> 00:08:51,399
how strong are they against side-channel

00:08:47,079 --> 00:08:53,589
attacks as you see mo in his talk at RSA

00:08:51,399 --> 00:08:54,879
has some difficulty that quantum the

00:08:53,589 --> 00:08:57,189
post quantum stuffs are even more

00:08:54,879 --> 00:09:00,759
complicated and have more issues than

00:08:57,189 --> 00:09:08,069
that that area perfect forward security

00:09:00,759 --> 00:09:11,139
simplicity etc so here's the the base

00:09:08,069 --> 00:09:15,339
crypto systems that I talked about three

00:09:11,139 --> 00:09:17,170
years ago most of the presentation there

00:09:15,339 --> 00:09:22,149
most of the algorithms fall in one of

00:09:17,170 --> 00:09:28,089
these in hash-based I talked about last

00:09:22,149 --> 00:09:29,439
time I talked about how box just the

00:09:28,089 --> 00:09:31,420
hash mate system and one of the issues

00:09:29,439 --> 00:09:35,410
with hash based systems was you couldn't

00:09:31,420 --> 00:09:37,000
use the same key twice well all the ones

00:09:35,410 --> 00:09:38,949
in this standard are what's called

00:09:37,000 --> 00:09:42,759
stateless what they've done is they

00:09:38,949 --> 00:09:44,290
extended the space of the the hash is

00:09:42,759 --> 00:09:47,139
the number of the number of times you

00:09:44,290 --> 00:09:49,120
can sign up to the point where they've

00:09:47,139 --> 00:09:51,250
covered every possible signature for

00:09:49,120 --> 00:09:56,050
that size and so they don't need to keep

00:09:51,250 --> 00:09:58,149
track of how many times you sign your

00:09:56,050 --> 00:09:59,529
your signature determines which of the

00:09:58,149 --> 00:10:04,389
keys you're going to use and then it

00:09:59,529 --> 00:10:06,579
gets used that that one time one of the

00:10:04,389 --> 00:10:08,980
important parts of hash base is the

00:10:06,579 --> 00:10:12,670
Merkel tree I only bring this up because

00:10:08,980 --> 00:10:16,600
it turns out other crypto systems use

00:10:12,670 --> 00:10:18,939
the same thing it's a way of taking a

00:10:16,600 --> 00:10:21,189
very large key compressing it down to a

00:10:18,939 --> 00:10:26,380
hash and the cost is you make your

00:10:21,189 --> 00:10:30,130
signatures very large here are the

00:10:26,380 --> 00:10:33,189
systems that are proposed for crypto

00:10:30,130 --> 00:10:35,110
patch there's only two proposals most

00:10:33,189 --> 00:10:36,610
proposals have multiple flavors and

00:10:35,110 --> 00:10:39,269
because there was only two I was able to

00:10:36,610 --> 00:10:41,860
list all the flavors that were available

00:10:39,269 --> 00:10:45,730
as you can see the public key sizes are

00:10:41,860 --> 00:10:47,780
pretty reasonable 32 bytes 64 bytes

00:10:45,730 --> 00:10:50,900
that's smaller than the

00:10:47,780 --> 00:10:54,610
our essay but the signature sizes are in

00:10:50,900 --> 00:10:59,570
the order of ten thousand bytes and and

00:10:54,610 --> 00:11:01,370
the times can be fairly long up to half

00:10:59,570 --> 00:11:07,280
a second some of them are even over a

00:11:01,370 --> 00:11:11,230
second to to sign so it's a kind of

00:11:07,280 --> 00:11:13,930
heavyweight in in size of signature and

00:11:11,230 --> 00:11:18,710
signing time but there may be some

00:11:13,930 --> 00:11:20,950
operations that that can deal with that

00:11:18,710 --> 00:11:20,950
okay

00:11:24,080 --> 00:11:30,890
code base code base is use it uses the

00:11:28,190 --> 00:11:32,600
notion of err correcting systems so you

00:11:30,890 --> 00:11:34,910
have a noisy line you want to be able to

00:11:32,600 --> 00:11:36,380
send your data through and not have to

00:11:34,910 --> 00:11:39,260
send it three times you send your data

00:11:36,380 --> 00:11:42,110
through once with some extra stuff the

00:11:39,260 --> 00:11:44,000
data gets corrupted you're able to use

00:11:42,110 --> 00:11:45,890
the extra stuff to recover the data

00:11:44,000 --> 00:11:49,460
turns out you can turn this into a

00:11:45,890 --> 00:11:51,380
crypto system you take a matrix that

00:11:49,460 --> 00:11:56,150
that puts that extra stuff into your

00:11:51,380 --> 00:11:59,000
data and if you obscure that may make

00:11:56,150 --> 00:12:03,290
tricks so that with with some additional

00:11:59,000 --> 00:12:06,440
matrix matrices people can't tell what

00:12:03,290 --> 00:12:08,120
the the stuff that you put in in order

00:12:06,440 --> 00:12:10,010
to do the error correction is only you

00:12:08,120 --> 00:12:15,680
know what it is and that's your private

00:12:10,010 --> 00:12:18,950
key and so you simply encode some data

00:12:15,680 --> 00:12:22,550
with that and run it to make it noisy

00:12:18,950 --> 00:12:25,100
you you XOR some random data to it to

00:12:22,550 --> 00:12:28,810
simulate a noisy line and that's your

00:12:25,100 --> 00:12:32,930
cipher text and you decrypt it by

00:12:28,810 --> 00:12:36,950
undoing the the air correction and you

00:12:32,930 --> 00:12:40,460
get your data back this is a actually a

00:12:36,950 --> 00:12:43,250
very old system first proposed in the

00:12:40,460 --> 00:12:45,020
70s we have lots of confidence in it

00:12:43,250 --> 00:12:47,660
because we've been trying to analyze it

00:12:45,020 --> 00:12:52,640
a lot unfortunately the key sizes are

00:12:47,660 --> 00:12:55,040
fairly large megabytes a megabyte and

00:12:52,640 --> 00:12:56,630
when they've tried to reduce it most of

00:12:55,040 --> 00:13:00,150
those have been bro

00:12:56,630 --> 00:13:01,980
so the proposals are some ways of

00:13:00,150 --> 00:13:03,900
reducing the key size one of the

00:13:01,980 --> 00:13:07,680
proposals is the original standard the

00:13:03,900 --> 00:13:12,000
classic Micmac eelis you can see it's

00:13:07,680 --> 00:13:14,280
got a one megabyte public key and it can

00:13:12,000 --> 00:13:17,850
be a bit expensive to do a keygen almost

00:13:14,280 --> 00:13:22,260
a second but you can see others of them

00:13:17,850 --> 00:13:25,140
are in the order of under ten thousand

00:13:22,260 --> 00:13:26,940
bytes there's still thousands of

00:13:25,140 --> 00:13:28,800
thousands of I spy thousands of bikes

00:13:26,940 --> 00:13:30,920
for your your your key sizes and

00:13:28,800 --> 00:13:32,760
thousands of bytes for your encoded key

00:13:30,920 --> 00:13:34,950
there are some of the gets in the

00:13:32,760 --> 00:13:36,330
hundreds who knows if they're actually

00:13:34,950 --> 00:13:41,910
going to be secure and make it to the

00:13:36,330 --> 00:13:44,280
end but oh and code base is only for

00:13:41,910 --> 00:13:46,200
encryption and key encryption there were

00:13:44,280 --> 00:13:47,580
some proposals for doing code signing of

00:13:46,200 --> 00:13:49,860
code base all of them turned out to be

00:13:47,580 --> 00:13:51,780
insecure all of them were broken so

00:13:49,860 --> 00:13:56,610
there are no code base signature

00:13:51,780 --> 00:13:57,600
algorithm is that survive ok lattice I'm

00:13:56,610 --> 00:14:02,010
going to completely hand away that

00:13:57,600 --> 00:14:05,310
lattice because it's complicated

00:14:02,010 --> 00:14:10,380
there are two main categories of lattice

00:14:05,310 --> 00:14:16,440
there's the LW e and then r LW e in true

00:14:10,380 --> 00:14:18,950
systems the LW e is provably secure we

00:14:16,440 --> 00:14:21,570
have pretty good confidence in it and

00:14:18,950 --> 00:14:23,990
that at least it's it it's it's a we

00:14:21,570 --> 00:14:28,350
have confidence that secure as the

00:14:23,990 --> 00:14:31,380
underlying hard problem that that that

00:14:28,350 --> 00:14:32,700
it tries to solve the other systems they

00:14:31,380 --> 00:14:37,590
haven't really patched out the proofs

00:14:32,700 --> 00:14:39,720
that much but they get smaller key sizes

00:14:37,590 --> 00:14:43,020
lattice is the one that that gets us

00:14:39,720 --> 00:14:45,450
closest to our current system so if you

00:14:43,020 --> 00:14:47,880
look at him they were this is by far the

00:14:45,450 --> 00:14:49,920
most common proposal I did not include

00:14:47,880 --> 00:14:52,260
all the different variants of all the

00:14:49,920 --> 00:14:55,950
different algorithms I've only included

00:14:52,260 --> 00:14:58,740
their their smallest ones on the list so

00:14:55,950 --> 00:15:00,780
I could fit them all here you can see

00:14:58,740 --> 00:15:05,070
that our key sizes are getting into

00:15:00,780 --> 00:15:07,170
under a thousand bytes and oh by the way

00:15:05,070 --> 00:15:08,110
that whenever you see the these lines

00:15:07,170 --> 00:15:10,300
here where it's

00:15:08,110 --> 00:15:17,800
in orange or yellowish here those are

00:15:10,300 --> 00:15:19,600
others that already broken okay that's

00:15:17,800 --> 00:15:22,300
theirs encryption and there's code

00:15:19,600 --> 00:15:24,480
signing right in there signing that can

00:15:22,300 --> 00:15:29,230
be done with lattice so it's a pretty

00:15:24,480 --> 00:15:30,519
flexible system multi-variant since I'm

00:15:29,230 --> 00:15:34,120
running short on time we're not going to

00:15:30,519 --> 00:15:35,620
talk about how it works but we'll jump

00:15:34,120 --> 00:15:39,750
right to the key sizes one of the

00:15:35,620 --> 00:15:39,750
interesting things on multi variants is

00:15:39,779 --> 00:15:46,269
this is another one of those algorithms

00:15:42,100 --> 00:15:48,220
that can use Merkle trees to compress

00:15:46,269 --> 00:15:50,560
the public key so you can see we got

00:15:48,220 --> 00:15:54,160
fairly large public keys orders of

00:15:50,560 --> 00:15:56,200
hundreds of thousands of bytes but some

00:15:54,160 --> 00:15:58,690
of these have really really small public

00:15:56,200 --> 00:16:00,339
keys but you'll see the key sizes are on

00:15:58,690 --> 00:16:03,579
the order of tens of thousands of bytes

00:16:00,339 --> 00:16:04,959
so you can if you have systems where

00:16:03,579 --> 00:16:07,540
you're gonna generate the key and then

00:16:04,959 --> 00:16:10,360
sign it's good to have you use the

00:16:07,540 --> 00:16:12,490
smaller key size because the the some of

00:16:10,360 --> 00:16:15,550
the to keep the some of the public key

00:16:12,490 --> 00:16:20,829
and the key size is smaller than it is

00:16:15,550 --> 00:16:22,810
for the other variants okay I'm gonna

00:16:20,829 --> 00:16:25,990
turn this into a homework problem for

00:16:22,810 --> 00:16:29,860
you mercy we're saying is one of those

00:16:25,990 --> 00:16:31,240
systems that are not based on the

00:16:29,860 --> 00:16:34,360
system's we have it lacks it looks

00:16:31,240 --> 00:16:36,279
pretty secure it's it's cool what's

00:16:34,360 --> 00:16:37,899
interesting is it simple enough that you

00:16:36,279 --> 00:16:39,310
can go read the paper without a whole

00:16:37,899 --> 00:16:41,320
lot of math and understand how it's

00:16:39,310 --> 00:16:44,440
working and the other important thing

00:16:41,320 --> 00:16:46,570
about it is the scheme that it's using

00:16:44,440 --> 00:16:49,570
is related to the scheme some of those

00:16:46,570 --> 00:16:51,370
smaller lattice systems are using and so

00:16:49,570 --> 00:16:53,199
you can get an idea of how that scheme

00:16:51,370 --> 00:16:57,279
works without having to dive into all

00:16:53,199 --> 00:16:58,990
the details of lattice and underneath

00:16:57,279 --> 00:17:02,250
the covers it's using air correction

00:16:58,990 --> 00:17:06,250
systems it can have a decryption air

00:17:02,250 --> 00:17:08,919
because the the air has got got too high

00:17:06,250 --> 00:17:10,689
same thing with lattice so if you see

00:17:08,919 --> 00:17:11,250
something with air correcting systems in

00:17:10,689 --> 00:17:13,919
it

00:17:11,250 --> 00:17:15,360
pash system with air correcting systems

00:17:13,919 --> 00:17:16,919
it doesn't mean it's codebase it could

00:17:15,360 --> 00:17:21,689
be a lattice based system or like this

00:17:16,919 --> 00:17:23,640
system so error correcting systems are

00:17:21,689 --> 00:17:26,400
becoming a new cryptographic primitive

00:17:23,640 --> 00:17:33,030
that we just have to deal with guess

00:17:26,400 --> 00:17:35,400
again guess again is interesting

00:17:33,030 --> 00:17:39,740
algorithm I only bring it up because it

00:17:35,400 --> 00:17:42,419
was just completely off the wall bizarre

00:17:39,740 --> 00:17:45,960
basically it uses probabilities and the

00:17:42,419 --> 00:17:50,700
idea is you have a better than half

00:17:45,960 --> 00:17:52,830
probability of guessing something but

00:17:50,700 --> 00:17:54,780
you're the attacker only has a half

00:17:52,830 --> 00:17:58,980
probability of guessing this this the

00:17:54,780 --> 00:18:02,820
same thing the issue with this is it

00:17:58,980 --> 00:18:05,669
encrypts one bit in 2,000 times the size

00:18:02,820 --> 00:18:08,100
of whatever your your numbers are which

00:18:05,669 --> 00:18:10,559
are fairly large the other problem with

00:18:08,100 --> 00:18:17,549
this is a simple script broke this

00:18:10,559 --> 00:18:22,200
algorithm completely psych ECC has new

00:18:17,549 --> 00:18:25,610
life cycles ECC but instead of using

00:18:22,200 --> 00:18:30,240
point multiplication it uses mapping to

00:18:25,610 --> 00:18:33,330
different I job but I sahjhan discours

00:18:30,240 --> 00:18:35,549
now Assad's terms are Assad unis if

00:18:33,330 --> 00:18:37,559
they'd have a one-to-one mapping for the

00:18:35,549 --> 00:18:38,970
numbers you have a set of numbers and

00:18:37,559 --> 00:18:40,200
we're in curve set of numbers on the

00:18:38,970 --> 00:18:42,659
other curve in this I have a one-to-one

00:18:40,200 --> 00:18:50,039
mapping between those numbers there

00:18:42,659 --> 00:18:53,520
Assad Yunus the and so instead of curves

00:18:50,039 --> 00:18:55,770
or set of points the public keys are

00:18:53,520 --> 00:19:01,140
actually occurs and we send these curves

00:18:55,770 --> 00:19:04,070
around the psyche is more compute

00:19:01,140 --> 00:19:09,150
intensive than ECC and slightly more

00:19:04,070 --> 00:19:11,280
slightly longer keys but actually still

00:19:09,150 --> 00:19:15,740
pretty good we're still under a thousand

00:19:11,280 --> 00:19:19,110
bytes for our keys but you can see the

00:19:15,740 --> 00:19:20,230
encryption decryption times are much

00:19:19,110 --> 00:19:23,490
higher than

00:19:20,230 --> 00:19:27,280
these other algorithms we're looking at

00:19:23,490 --> 00:19:32,919
so ECC is back again ECC is still part

00:19:27,280 --> 00:19:40,870
of crypto RSA RSA is back again not

00:19:32,919 --> 00:19:42,520
really this is mostly a joke but it made

00:19:40,870 --> 00:19:44,200
it into this it made it into the first

00:19:42,520 --> 00:19:45,820
round of submission and it's good to

00:19:44,200 --> 00:19:48,730
think about these types of things the

00:19:45,820 --> 00:19:50,559
question is can we make RSA big enough

00:19:48,730 --> 00:19:54,610
to make it safe from post quantum and

00:19:50,559 --> 00:19:58,600
the answer is yes but it takes a

00:19:54,610 --> 00:19:59,760
gigabyte key more big for gigabyte

00:19:58,600 --> 00:20:02,140
private key

00:19:59,760 --> 00:20:06,640
it takes three and a half days to

00:20:02,140 --> 00:20:08,559
generate a key twenty minutes to verify

00:20:06,640 --> 00:20:16,120
a signature and two and a half hours to

00:20:08,559 --> 00:20:18,490
make a signature so anyway so crypt is

00:20:16,120 --> 00:20:22,169
the quantum computers coming we have

00:20:18,490 --> 00:20:25,150
alternatives we now have a good list of

00:20:22,169 --> 00:20:27,280
possible possible replacements that

00:20:25,150 --> 00:20:30,790
number is going to get smaller in the

00:20:27,280 --> 00:20:32,669
next year and there's where you can go

00:20:30,790 --> 00:20:37,530
find more information about everything

00:20:32,669 --> 00:20:37,530
so any questions

00:20:39,510 --> 00:20:56,340
yes the lattice space proposals are

00:20:54,420 --> 00:21:00,060
fairly close to drop-in replacements

00:20:56,340 --> 00:21:02,820
their sizes actually the I just Assad

00:21:00,060 --> 00:21:05,700
Janis ECC is pretty close to drop in the

00:21:02,820 --> 00:21:08,850
only issue is the performance the key

00:21:05,700 --> 00:21:19,920
sizes are bigger than ECC but smaller

00:21:08,850 --> 00:21:20,280
than RSA so yes the the ECC ones are are

00:21:19,920 --> 00:21:22,620
very

00:21:20,280 --> 00:21:24,000
I'm sorry are there any the question was

00:21:22,620 --> 00:21:27,930
are there any systems that are difficult

00:21:24,000 --> 00:21:31,980
and like and the sahjhan this ECC is

00:21:27,930 --> 00:21:34,860
very very fifteen like it the whole math

00:21:31,980 --> 00:21:38,510
is exactly diffie-hellman the way the

00:21:34,860 --> 00:21:38,510
product the way the protocols structured

00:21:38,660 --> 00:21:41,660
yes

00:21:52,630 --> 00:22:02,409
okay I'm sorry I should have mentioned

00:21:56,960 --> 00:22:04,700
it I did not label those those slides

00:22:02,409 --> 00:22:09,039
those numbers are not bits

00:22:04,700 --> 00:22:12,909
those numbers are bytes so when you see

00:22:09,039 --> 00:22:16,669
328 bytes that's bigger than an RSA key

00:22:12,909 --> 00:22:20,179
you multiply the bits by 30 so the 32

00:22:16,669 --> 00:22:25,850
ones are actually has to fit 256 bit

00:22:20,179 --> 00:22:30,200
hashes is what they are the times are in

00:22:25,850 --> 00:22:32,179
milliseconds so so these are all still

00:22:30,200 --> 00:22:37,309
sub-second but if you see something like

00:22:32,179 --> 00:22:43,390
a thousand that's over a second any

00:22:37,309 --> 00:22:52,109
other questions okay thank you

00:22:43,390 --> 00:22:52,109

YouTube URL: https://www.youtube.com/watch?v=iPijIw-ZDpY


