Title: From Jenkins-under-your-desk to resilient service - DevConf.CZ 2021
Publication date: 2021-03-17
Playlist: DevConfCZ 2021
Description: 
	Speakers: Michael Hofmann, Inaki Malerba


Red Hat's CKI ("cookie") project started out as a Jenkins proof-of-concept to show that kernel testing can be integrated into the kernel workflow.

Today, CKI provides all the infrastructure that stands between a merge request for a Fedora/CentOS/RHEL kernel repository on gitlab.com and the green check mark that signals that it can be merged.

Join us in our journey of how a bunch of engineers (that couldn't spell DevOps correctly) learned to operate a fast-moving resilient service used by kernel developers in their daily work.

We will talk about:

How we keep the CKI service up and running by
- using a state-of-the art logging, monitoring and alerting setup
- being persistent in the case of transient failures
- reducing single-point-of-failure

How we make it easy to modify the testing pipeline by
- running canary pipelines for unmerged code

How we make it safe to hack on the underlying infrastructure by
- dividing the backend infrastructure into microservices
- automatically deploying testing versions for merge requests
- automating production deployments



Schedule: https://sched.co/gmIL
Captions: 
	00:00:01,680 --> 00:00:06,879
as she said my name is

00:00:03,600 --> 00:00:10,639
i'm here with michael we are from the

00:00:06,879 --> 00:00:13,280
cki team um what do we do

00:00:10,639 --> 00:00:16,800
the ck team also known as known as

00:00:13,280 --> 00:00:20,000
continuous kernel integration

00:00:16,800 --> 00:00:23,359
we basically try to avoid grumpy kernels

00:00:20,000 --> 00:00:26,800
developers for living we run ci

00:00:23,359 --> 00:00:30,400
for the linux kernel which means that

00:00:26,800 --> 00:00:32,079
we grab a commit we trigger a pipeline

00:00:30,400 --> 00:00:34,719
we build the com the

00:00:32,079 --> 00:00:36,079
kernel we test it and we try to report

00:00:34,719 --> 00:00:38,800
the results of

00:00:36,079 --> 00:00:40,000
what we just tested that can't be too

00:00:38,800 --> 00:00:42,879
hard right

00:00:40,000 --> 00:00:44,000
uh well some time ago we started like

00:00:42,879 --> 00:00:46,399
this

00:00:44,000 --> 00:00:47,280
it was basically a proof of concept we

00:00:46,399 --> 00:00:49,520
needed to show

00:00:47,280 --> 00:00:51,199
that uh testing the kernel on a

00:00:49,520 --> 00:00:54,559
continuous integration

00:00:51,199 --> 00:00:58,239
workflow was possible so we sat down

00:00:54,559 --> 00:01:00,879
uh besides a big pega mod of of course

00:00:58,239 --> 00:01:02,399
jenkins because you can never go wrong

00:01:00,879 --> 00:01:06,159
by using chinese

00:01:02,399 --> 00:01:08,880
but that was really useful to to show

00:01:06,159 --> 00:01:10,640
us and people that testing the kernel

00:01:08,880 --> 00:01:14,240
was possible

00:01:10,640 --> 00:01:16,560
but it involved a lot of python and

00:01:14,240 --> 00:01:17,280
openshift projects and clicking and

00:01:16,560 --> 00:01:20,720
stuff that

00:01:17,280 --> 00:01:23,520
really didn't scale that well so after

00:01:20,720 --> 00:01:24,880
showing that this was uh something that

00:01:23,520 --> 00:01:28,960
was possible that

00:01:24,880 --> 00:01:31,200
we could maintain and scale up

00:01:28,960 --> 00:01:32,320
testing of the kernel of the linux

00:01:31,200 --> 00:01:35,759
kernel

00:01:32,320 --> 00:01:37,759
we needed to revisit our problems

00:01:35,759 --> 00:01:39,520
we started gaining more and more

00:01:37,759 --> 00:01:40,720
responsibilities for example with

00:01:39,520 --> 00:01:43,840
current developers

00:01:40,720 --> 00:01:47,040
we needed to onboard new kernel trees

00:01:43,840 --> 00:01:50,560
we started testing kernels from blue

00:01:47,040 --> 00:01:53,439
and koji which are some builders

00:01:50,560 --> 00:01:54,880
that red hat and fedora uses we also

00:01:53,439 --> 00:01:57,200
test kit repos

00:01:54,880 --> 00:01:59,040
we are now testing gitlab merch requests

00:01:57,200 --> 00:02:00,079
we have a patchwork which is an

00:01:59,040 --> 00:02:03,040
interface for

00:02:00,079 --> 00:02:05,119
mailing lists and patches sent to the

00:02:03,040 --> 00:02:09,280
mailing lists

00:02:05,119 --> 00:02:11,440
we also provide gating for rpm packaging

00:02:09,280 --> 00:02:14,239
and we are working on the kernel

00:02:11,440 --> 00:02:16,800
workflow infrastructure i don't know

00:02:14,239 --> 00:02:17,760
using any of those stocks it's really

00:02:16,800 --> 00:02:20,160
interesting change

00:02:17,760 --> 00:02:20,959
on how red hat works on the kernel but

00:02:20,160 --> 00:02:23,440
we also

00:02:20,959 --> 00:02:25,360
uh work with test maintainers we help

00:02:23,440 --> 00:02:28,800
them onboard new kernel trees

00:02:25,360 --> 00:02:32,080
we have them on board uh new tests

00:02:28,800 --> 00:02:34,160
uh i also configure target testings and

00:02:32,080 --> 00:02:37,280
well give them some feedback about how

00:02:34,160 --> 00:02:39,840
those tests are going

00:02:37,280 --> 00:02:41,360
so we need it to be somewhere like this

00:02:39,840 --> 00:02:43,120
where everything is automatic

00:02:41,360 --> 00:02:45,519
everything is on track we don't have to

00:02:43,120 --> 00:02:49,200
go clicking buttons and putting cars

00:02:45,519 --> 00:02:52,959
back on the tracks um but yeah it's

00:02:49,200 --> 00:02:56,239
really not that easy um

00:02:52,959 --> 00:02:59,200
so we decided i mean we found out

00:02:56,239 --> 00:03:00,400
that we were gonna need some uh fasting

00:02:59,200 --> 00:03:02,840
keywords like

00:03:00,400 --> 00:03:05,360
software site related reliability

00:03:02,840 --> 00:03:08,879
engineering and things that help us

00:03:05,360 --> 00:03:11,599
keep our machinery working

00:03:08,879 --> 00:03:12,720
we started building our services under

00:03:11,599 --> 00:03:15,360
this

00:03:12,720 --> 00:03:17,200
main dilemma that is that any component

00:03:15,360 --> 00:03:19,760
or dependency that can fail

00:03:17,200 --> 00:03:21,840
will fail and some of them will fail

00:03:19,760 --> 00:03:23,680
even more than others

00:03:21,840 --> 00:03:26,400
but we needed to make sure that all the

00:03:23,680 --> 00:03:29,599
failures can be retrieved successfully

00:03:26,400 --> 00:03:30,239
um and if there are some that cannot be

00:03:29,599 --> 00:03:32,159
retried

00:03:30,239 --> 00:03:34,080
we need to know which ones are and try

00:03:32,159 --> 00:03:36,319
to keep them as minimum

00:03:34,080 --> 00:03:37,519
so all the failures at first need to be

00:03:36,319 --> 00:03:39,840
prevented

00:03:37,519 --> 00:03:41,519
having fewer components or simpler

00:03:39,840 --> 00:03:45,200
dependencies

00:03:41,519 --> 00:03:47,840
helps us prevent important issues

00:03:45,200 --> 00:03:49,599
but also once the failures happened

00:03:47,840 --> 00:03:52,720
those need to be detected

00:03:49,599 --> 00:03:55,760
and we need to recover from that

00:03:52,720 --> 00:03:56,720
um what some background about what we

00:03:55,760 --> 00:03:59,519
have

00:03:56,720 --> 00:04:00,000
uh basically we run on a lot of

00:03:59,519 --> 00:04:02,159
different

00:04:00,000 --> 00:04:04,879
infrastructures outside of our control

00:04:02,159 --> 00:04:07,120
like different openshift clusters

00:04:04,879 --> 00:04:07,920
a bigger cluster speaker is a hardware

00:04:07,120 --> 00:04:09,840
provisioning

00:04:07,920 --> 00:04:11,280
so that's how what we use to get

00:04:09,840 --> 00:04:14,319
machines for the testing

00:04:11,280 --> 00:04:16,959
but we also run on aws on gitlab.com

00:04:14,319 --> 00:04:17,519
and many other platforms to communicate

00:04:16,959 --> 00:04:20,160
all these

00:04:17,519 --> 00:04:20,720
services running on different platforms

00:04:20,160 --> 00:04:23,840
we use

00:04:20,720 --> 00:04:26,880
amqp cluster

00:04:23,840 --> 00:04:28,960
which is well rapidmq and

00:04:26,880 --> 00:04:30,240
a lot of cues to connect all the

00:04:28,960 --> 00:04:32,320
services

00:04:30,240 --> 00:04:34,800
we also have internal microservices

00:04:32,320 --> 00:04:36,960
running on all these different clouds

00:04:34,800 --> 00:04:38,160
like uh services to trigger the

00:04:36,960 --> 00:04:40,880
pipelines

00:04:38,160 --> 00:04:43,040
uh to send the reports to to babysit the

00:04:40,880 --> 00:04:46,080
pipelines until they finish

00:04:43,040 --> 00:04:47,919
but we also have like a really important

00:04:46,080 --> 00:04:50,240
pipeline components like the gitlab

00:04:47,919 --> 00:04:52,160
runner which we use to run the tests

00:04:50,240 --> 00:04:54,240
a test database where we store all the

00:04:52,160 --> 00:04:55,520
all the results and information that we

00:04:54,240 --> 00:04:59,040
generate

00:04:55,520 --> 00:05:01,919
the bigger provisioning etc

00:04:59,040 --> 00:05:03,759
so the first thing is how to prevent uh

00:05:01,919 --> 00:05:06,880
these problems from happening at

00:05:03,759 --> 00:05:09,360
the beginning well basically

00:05:06,880 --> 00:05:10,080
minimize the essential pieces if you

00:05:09,360 --> 00:05:12,320
have less

00:05:10,080 --> 00:05:14,240
critical pieces that means that less

00:05:12,320 --> 00:05:17,840
things can go wrong

00:05:14,240 --> 00:05:19,039
we divided our all our stack into three

00:05:17,840 --> 00:05:21,360
main categories

00:05:19,039 --> 00:05:23,199
essential components are the pieces that

00:05:21,360 --> 00:05:25,840
are needed for the service to run

00:05:23,199 --> 00:05:27,360
our single points of failure and now the

00:05:25,840 --> 00:05:30,800
things that we need to keep

00:05:27,360 --> 00:05:32,240
at minimum on the next layer we have the

00:05:30,800 --> 00:05:34,000
necessary components

00:05:32,240 --> 00:05:35,520
are those things that need to run at

00:05:34,000 --> 00:05:37,680
least some time

00:05:35,520 --> 00:05:39,600
for the operations to work like for

00:05:37,680 --> 00:05:41,759
example the reporter component

00:05:39,600 --> 00:05:43,440
you don't need to have it running all

00:05:41,759 --> 00:05:46,160
the time with uh

00:05:43,440 --> 00:05:47,759
four nines or nine nines we just uh as

00:05:46,160 --> 00:05:48,479
long as it's running sometimes and it

00:05:47,759 --> 00:05:52,320
can pick up

00:05:48,479 --> 00:05:55,199
the work uh that it was generated before

00:05:52,320 --> 00:05:56,720
that's not a problem for the operation

00:05:55,199 --> 00:05:57,600
but we also have like optional

00:05:56,720 --> 00:05:59,120
components

00:05:57,600 --> 00:06:00,800
which are those that provide

00:05:59,120 --> 00:06:03,520
observability and increase the

00:06:00,800 --> 00:06:05,440
reliability of the system we cannot fail

00:06:03,520 --> 00:06:07,680
our testing if for example the

00:06:05,440 --> 00:06:10,960
logs aggregation system is down on all

00:06:07,680 --> 00:06:13,280
the metrics and stuff like that

00:06:10,960 --> 00:06:14,479
the first minimization we made are the

00:06:13,280 --> 00:06:16,720
message queues

00:06:14,479 --> 00:06:18,080
we tried to decouple all the pieces of

00:06:16,720 --> 00:06:20,960
code

00:06:18,080 --> 00:06:23,199
for that we translated all the rest apis

00:06:20,960 --> 00:06:25,680
into message queuing

00:06:23,199 --> 00:06:27,120
uh and that allows us to run all this

00:06:25,680 --> 00:06:28,960
like to

00:06:27,120 --> 00:06:30,160
be abstracted from the place that the

00:06:28,960 --> 00:06:32,240
code is running

00:06:30,160 --> 00:06:33,680
as long as it can connect to the

00:06:32,240 --> 00:06:36,560
ravenomq server

00:06:33,680 --> 00:06:39,360
that turns everything into a way more

00:06:36,560 --> 00:06:40,880
reliable and distributed system

00:06:39,360 --> 00:06:42,880
increase as i said the service

00:06:40,880 --> 00:06:44,960
portability because

00:06:42,880 --> 00:06:46,160
you are not tied to the place that the

00:06:44,960 --> 00:06:48,160
the code is running

00:06:46,160 --> 00:06:49,520
as long as it can connect to the message

00:06:48,160 --> 00:06:51,199
queue uh

00:06:49,520 --> 00:06:53,120
and it allows us to automatically

00:06:51,199 --> 00:06:56,160
reprocess the failed messages

00:06:53,120 --> 00:06:56,639
after some time we build the system on

00:06:56,160 --> 00:07:00,880
driving

00:06:56,639 --> 00:07:02,960
queue vanilla ravidmq that allows us to

00:07:00,880 --> 00:07:04,880
retry the message the messages that

00:07:02,960 --> 00:07:08,000
failed after some time

00:07:04,880 --> 00:07:08,639
by default if you if a worker returns

00:07:08,000 --> 00:07:11,919
the message

00:07:08,639 --> 00:07:12,800
to the server that message would get on

00:07:11,919 --> 00:07:14,319
the beginning of the

00:07:12,800 --> 00:07:16,639
of the queue so it would get

00:07:14,319 --> 00:07:19,759
automatically reprocessed the next time

00:07:16,639 --> 00:07:20,479
like right after it was returned and

00:07:19,759 --> 00:07:22,560
that could

00:07:20,479 --> 00:07:24,479
unblock your services if something is

00:07:22,560 --> 00:07:26,000
going on with that particular message

00:07:24,479 --> 00:07:27,919
in this case the message goes to the

00:07:26,000 --> 00:07:31,120
back of the queue and gets reprocessed

00:07:27,919 --> 00:07:32,639
after some time for example uh as i said

00:07:31,120 --> 00:07:35,840
well we have a

00:07:32,639 --> 00:07:37,280
this uh rabbitmq cluster it's hosted on

00:07:35,840 --> 00:07:40,479
aws as it's one of

00:07:37,280 --> 00:07:43,720
our key components we need to

00:07:40,479 --> 00:07:47,199
make sure that it runs with as much as

00:07:43,720 --> 00:07:48,400
availability as possible uh we have a

00:07:47,199 --> 00:07:50,319
webhook bridge

00:07:48,400 --> 00:07:51,680
for those applications where we cannot

00:07:50,319 --> 00:07:53,840
decide if they are

00:07:51,680 --> 00:07:56,319
they have rest apis or use message

00:07:53,840 --> 00:08:00,479
queues we built a very

00:07:56,319 --> 00:08:02,960
reliable bridge to turn web hooks into

00:08:00,479 --> 00:08:04,479
message queues into messages in the

00:08:02,960 --> 00:08:07,840
queues

00:08:04,479 --> 00:08:10,800
uh and for the retries we also have uh

00:08:07,840 --> 00:08:11,280
we are converting external message

00:08:10,800 --> 00:08:15,280
queues

00:08:11,280 --> 00:08:18,560
like umb which is a internal red hat

00:08:15,280 --> 00:08:22,639
message pass or fedora message pass into

00:08:18,560 --> 00:08:25,840
our own message where we can retry the

00:08:22,639 --> 00:08:29,120
messages successfully

00:08:25,840 --> 00:08:30,960
another example are the s3 buckets uh

00:08:29,120 --> 00:08:32,240
this provides a very generic way to

00:08:30,960 --> 00:08:35,360
store artifacts

00:08:32,240 --> 00:08:35,919
we don't need to rely on on nfs volumes

00:08:35,360 --> 00:08:38,880
or git

00:08:35,919 --> 00:08:40,560
hosting or other platforms that we were

00:08:38,880 --> 00:08:43,200
using before

00:08:40,560 --> 00:08:44,080
f3 it's universal it's fast and it's

00:08:43,200 --> 00:08:47,360
really reliable

00:08:44,080 --> 00:08:50,800
so we use aws f3 for external

00:08:47,360 --> 00:08:54,560
files we use openshift and mini i o for

00:08:50,800 --> 00:08:56,560
internal files it can also be used as a

00:08:54,560 --> 00:08:58,399
permanent database we also use it to

00:08:56,560 --> 00:09:02,240
store some files and to

00:08:58,399 --> 00:09:04,480
distribute the status across some pieces

00:09:02,240 --> 00:09:06,320
and again it increases a lot of the

00:09:04,480 --> 00:09:06,880
service portability because you don't

00:09:06,320 --> 00:09:08,320
need to

00:09:06,880 --> 00:09:10,000
you don't care whether it's it when it's

00:09:08,320 --> 00:09:12,240
running you know like

00:09:10,000 --> 00:09:13,839
for example with an nfs volume you need

00:09:12,240 --> 00:09:14,480
you would need to mount that volume on

00:09:13,839 --> 00:09:17,360
all the

00:09:14,480 --> 00:09:20,160
places you want to use it with s3 as

00:09:17,360 --> 00:09:23,200
long as you have access to the server

00:09:20,160 --> 00:09:26,240
it's all fine for example we use this

00:09:23,200 --> 00:09:28,720
as uh c cache uh

00:09:26,240 --> 00:09:31,120
for caching git repositories so we don't

00:09:28,720 --> 00:09:34,160
clone all the kernel trees every time

00:09:31,120 --> 00:09:35,600
for pipeline artifacts and as the

00:09:34,160 --> 00:09:39,600
database as i said

00:09:35,600 --> 00:09:42,399
for configurations on some static files

00:09:39,600 --> 00:09:44,720
the third thing is containers we try to

00:09:42,399 --> 00:09:46,640
turn everything into container

00:09:44,720 --> 00:09:48,000
this allows us to forget about

00:09:46,640 --> 00:09:48,880
infrastructure don't worry where the

00:09:48,000 --> 00:09:51,839
things are running

00:09:48,880 --> 00:09:53,839
just we distribute the packages like

00:09:51,839 --> 00:09:55,839
this we don't install packages just

00:09:53,839 --> 00:09:57,519
put them into an image and use the image

00:09:55,839 --> 00:10:00,320
everywhere we need to use it

00:09:57,519 --> 00:10:01,600
like for example we use aws lambda for

00:10:00,320 --> 00:10:03,680
the webhook bridge

00:10:01,600 --> 00:10:05,760
but we also use gitlab runners and we

00:10:03,680 --> 00:10:09,839
don't care whether it's running we can

00:10:05,760 --> 00:10:11,760
run runners on gitlab or sorry on docker

00:10:09,839 --> 00:10:14,320
or kubernetes or some disposable

00:10:11,760 --> 00:10:17,839
machines we don't care about that

00:10:14,320 --> 00:10:18,560
the next thing is detection we have as

00:10:17,839 --> 00:10:22,000
we said

00:10:18,560 --> 00:10:25,519
we have a lot of moving pieces

00:10:22,000 --> 00:10:26,800
uh we build and test the pipelines we

00:10:25,519 --> 00:10:28,959
have microservices we have

00:10:26,800 --> 00:10:29,839
current jobs everything running on aws

00:10:28,959 --> 00:10:32,320
openstack

00:10:29,839 --> 00:10:33,440
different carbonated clusters so we need

00:10:32,320 --> 00:10:36,160
to log

00:10:33,440 --> 00:10:36,959
and monitor all these these things

00:10:36,160 --> 00:10:39,120
running

00:10:36,959 --> 00:10:40,640
for the logs we tried to pipe everything

00:10:39,120 --> 00:10:41,519
to that now but that didn't solve our

00:10:40,640 --> 00:10:44,000
problems

00:10:41,519 --> 00:10:46,079
so we had to improve this we found out

00:10:44,000 --> 00:10:48,399
that loki was a really good solution

00:10:46,079 --> 00:10:49,440
for it it's basically like a prominent

00:10:48,399 --> 00:10:52,800
use but for logs

00:10:49,440 --> 00:10:55,040
it helps us index the logs and

00:10:52,800 --> 00:10:57,440
have easy retention policies for the

00:10:55,040 --> 00:11:00,320
logs to be rotated easily

00:10:57,440 --> 00:11:01,120
for the metrics uh prometheus is an

00:11:00,320 --> 00:11:03,440
excellent

00:11:01,120 --> 00:11:05,200
it's so good that we realize that every

00:11:03,440 --> 00:11:06,079
application deserves a slash magic

00:11:05,200 --> 00:11:07,760
endpoint

00:11:06,079 --> 00:11:09,279
it allows you to monitor the internal

00:11:07,760 --> 00:11:12,160
styles of the services

00:11:09,279 --> 00:11:14,320
and you can know what is how a service

00:11:12,160 --> 00:11:17,040
is doing how long is it taking

00:11:14,320 --> 00:11:17,680
and for our python applications most of

00:11:17,040 --> 00:11:19,760
our code is

00:11:17,680 --> 00:11:20,880
python so using python client a

00:11:19,760 --> 00:11:23,200
prometheus client

00:11:20,880 --> 00:11:24,880
it's really important for good solution

00:11:23,200 --> 00:11:25,519
it handles everything you just need to

00:11:24,880 --> 00:11:28,640
define

00:11:25,519 --> 00:11:30,880
the data you wanna expose

00:11:28,640 --> 00:11:32,399
everything it's visualizing grafana we

00:11:30,880 --> 00:11:33,519
have dashboards like this which allows

00:11:32,399 --> 00:11:36,160
us to

00:11:33,519 --> 00:11:38,800
see what's going on and have some alerts

00:11:36,160 --> 00:11:41,519
if something goes wrong

00:11:38,800 --> 00:11:43,440
and at higher level we use monit when

00:11:41,519 --> 00:11:44,240
it's a simple solution for monitoring

00:11:43,440 --> 00:11:47,920
you

00:11:44,240 --> 00:11:50,639
can write your own shell scripts

00:11:47,920 --> 00:11:51,600
and make them fail and monitor we will

00:11:50,639 --> 00:11:53,760
uh

00:11:51,600 --> 00:11:56,160
alert you about that but it also has

00:11:53,760 --> 00:11:56,720
some basic really useful checks like uh

00:11:56,160 --> 00:12:00,000
hosts

00:11:56,720 --> 00:12:02,959
uptime uh file systems size

00:12:00,000 --> 00:12:03,600
and capacity but we also like as i said

00:12:02,959 --> 00:12:06,160
with our

00:12:03,600 --> 00:12:07,040
custom scripts we check for bigger host

00:12:06,160 --> 00:12:10,880
skills

00:12:07,040 --> 00:12:15,519
s3 packet sizes and ravity mq

00:12:10,880 --> 00:12:17,600
cues size and not acknowledged messages

00:12:15,519 --> 00:12:19,360
this is really important to also recall

00:12:17,600 --> 00:12:21,200
all these problems because you as you

00:12:19,360 --> 00:12:23,200
can see here

00:12:21,200 --> 00:12:25,920
we can have a good track of what

00:12:23,200 --> 00:12:29,120
happened and when

00:12:25,920 --> 00:12:29,839
and uh like at last if everything

00:12:29,120 --> 00:12:31,920
explodes

00:12:29,839 --> 00:12:33,279
you want to be the first one to to know

00:12:31,920 --> 00:12:36,320
when something goes wrong

00:12:33,279 --> 00:12:38,560
so we use sentry which capture which uh

00:12:36,320 --> 00:12:40,720
yeah catches all the problems in our

00:12:38,560 --> 00:12:43,600
code and we can have some nice

00:12:40,720 --> 00:12:45,279
tracebacks and be aware of what's going

00:12:43,600 --> 00:12:47,440
on with our applications

00:12:45,279 --> 00:12:48,800
we use sentry io for that and an

00:12:47,440 --> 00:12:52,320
internal instance for

00:12:48,800 --> 00:12:54,000
the internal code uh all these

00:12:52,320 --> 00:12:56,560
it's not really useful if you don't have

00:12:54,000 --> 00:13:00,320
alerting so we have uh

00:12:56,560 --> 00:13:03,120
all these low-key properties and the

00:13:00,320 --> 00:13:04,959
money things go into irc which is our

00:13:03,120 --> 00:13:08,560
main channel of communication

00:13:04,959 --> 00:13:11,120
but also are sent to the mailing list uh

00:13:08,560 --> 00:13:12,880
if anyone reads that but it's the most

00:13:11,120 --> 00:13:13,440
important thing it's the irc because

00:13:12,880 --> 00:13:17,200
it's

00:13:13,440 --> 00:13:19,839
where we spend all our time

00:13:17,200 --> 00:13:21,519
but the thing is uh even after you

00:13:19,839 --> 00:13:23,360
realize that something went wrong

00:13:21,519 --> 00:13:25,040
growing wrong you need to recover from

00:13:23,360 --> 00:13:28,480
that so

00:13:25,040 --> 00:13:29,360
we have uh on the bay and the most basic

00:13:28,480 --> 00:13:32,320
level

00:13:29,360 --> 00:13:34,160
the the worst problem it's the network

00:13:32,320 --> 00:13:37,440
always as that

00:13:34,160 --> 00:13:39,920
cat was afraid of we

00:13:37,440 --> 00:13:41,040
have a lot of network issues so we

00:13:39,920 --> 00:13:43,680
income we added

00:13:41,040 --> 00:13:44,560
retry loops to every network access in

00:13:43,680 --> 00:13:47,120
the pipeline and

00:13:44,560 --> 00:13:47,760
on all the services so we know that any

00:13:47,120 --> 00:13:52,160
transient

00:13:47,760 --> 00:13:55,519
network failure is retried several times

00:13:52,160 --> 00:13:59,760
but we also uh used as i said

00:13:55,519 --> 00:14:01,839
the reviewing of messages in rapidmq

00:13:59,760 --> 00:14:04,079
there's some information on our blog

00:14:01,839 --> 00:14:06,880
about this system but basically

00:14:04,079 --> 00:14:08,079
we just uh re-cue all the messages

00:14:06,880 --> 00:14:10,800
indefinitely

00:14:08,079 --> 00:14:12,880
because uh as it says nothing is as

00:14:10,800 --> 00:14:13,839
motivating to fix a bug as a message

00:14:12,880 --> 00:14:17,279
full as a

00:14:13,839 --> 00:14:18,320
queue full of messages um with all the

00:14:17,279 --> 00:14:21,519
alerting we get

00:14:18,320 --> 00:14:22,000
alerts every time message fails so it's

00:14:21,519 --> 00:14:24,160
really

00:14:22,000 --> 00:14:25,839
easy to i mean it's great so you don't

00:14:24,160 --> 00:14:27,120
lose the failures you can retry the

00:14:25,839 --> 00:14:30,320
failures

00:14:27,120 --> 00:14:32,079
you can go you go and test locally with

00:14:30,320 --> 00:14:35,360
that message that it's

00:14:32,079 --> 00:14:38,800
making stuff fail so it's

00:14:35,360 --> 00:14:42,079
really helpful and the third

00:14:38,800 --> 00:14:45,120
when all these things went wrong and

00:14:42,079 --> 00:14:46,959
didn't catch the problems on time we

00:14:45,120 --> 00:14:50,079
have the pipeline herder which is

00:14:46,959 --> 00:14:51,519
uh a bot that babysits the pipelines and

00:14:50,079 --> 00:14:53,920
if something failed

00:14:51,519 --> 00:14:56,160
it had it knows about many failures that

00:14:53,920 --> 00:14:58,800
we know we can safely retry

00:14:56,160 --> 00:14:59,839
so it goes and checks the logs of the of

00:14:58,800 --> 00:15:02,320
the jobs

00:14:59,839 --> 00:15:02,959
and it retries them for us so we don't

00:15:02,320 --> 00:15:06,720
have to click

00:15:02,959 --> 00:15:08,720
anything if that's not enough

00:15:06,720 --> 00:15:10,079
we have failed fallbacks as i said we

00:15:08,720 --> 00:15:11,839
have different uh

00:15:10,079 --> 00:15:13,760
clusters we have different openshift

00:15:11,839 --> 00:15:15,839
clusters uh

00:15:13,760 --> 00:15:17,279
so we can change the runners if

00:15:15,839 --> 00:15:18,320
something goes wrong on one of the

00:15:17,279 --> 00:15:21,360
clusters we are running

00:15:18,320 --> 00:15:26,079
we can fall back to the others

00:15:21,360 --> 00:15:29,120
really easily with just pushing a button

00:15:26,079 --> 00:15:31,360
so michael

00:15:29,120 --> 00:15:32,720
it's going to tell us how we tried to do

00:15:31,360 --> 00:15:36,240
devops

00:15:32,720 --> 00:15:36,240
that was that was a good introduction

00:15:36,320 --> 00:15:40,880
so uh yaki talked about the the aspect

00:15:39,279 --> 00:15:43,040
of um

00:15:40,880 --> 00:15:44,720
how we keep it running but now uh the

00:15:43,040 --> 00:15:46,320
system would be the most stable if we

00:15:44,720 --> 00:15:49,519
don't change it

00:15:46,320 --> 00:15:54,399
so um i

00:15:49,519 --> 00:15:56,560
i need to say next slide in yakidura

00:15:54,399 --> 00:15:58,160
so we we thought about how how to

00:15:56,560 --> 00:16:01,920
approach actually um

00:15:58,160 --> 00:16:03,519
our devops uh culture and so

00:16:01,920 --> 00:16:05,279
uh and steph waters also talked about

00:16:03,519 --> 00:16:05,759
this a lot now in the last last couple

00:16:05,279 --> 00:16:08,800
of years

00:16:05,759 --> 00:16:10,720
um it

00:16:08,800 --> 00:16:11,920
i really made those things up here but

00:16:10,720 --> 00:16:13,519
um

00:16:11,920 --> 00:16:16,079
one aspect we consider pretty important

00:16:13,519 --> 00:16:18,399
is that it is as open as possible so

00:16:16,079 --> 00:16:20,240
uh this is about code about

00:16:18,399 --> 00:16:23,600
documentation about how we work

00:16:20,240 --> 00:16:25,040
uh about communication but it also needs

00:16:23,600 --> 00:16:27,040
to be safe so

00:16:25,040 --> 00:16:30,079
everybody is scared of certain pieces of

00:16:27,040 --> 00:16:31,839
code and we try to minimize them um

00:16:30,079 --> 00:16:33,360
so that if you change something or if

00:16:31,839 --> 00:16:34,639
you have to change something you feel

00:16:33,360 --> 00:16:36,720
safe

00:16:34,639 --> 00:16:38,480
and are more or less also eager to clean

00:16:36,720 --> 00:16:41,199
up pieces um

00:16:38,480 --> 00:16:42,880
as it as it becomes apparent and the

00:16:41,199 --> 00:16:43,920
third piece is that that deployments

00:16:42,880 --> 00:16:47,040
need to be

00:16:43,920 --> 00:16:47,440
painless uh production deployments but

00:16:47,040 --> 00:16:49,600
also

00:16:47,440 --> 00:16:50,480
deployments locally even if it's not

00:16:49,600 --> 00:16:53,680
really deploying but

00:16:50,480 --> 00:16:55,440
just running the code yourself just just

00:16:53,680 --> 00:16:58,560
for figuring out whether it

00:16:55,440 --> 00:17:00,000
should work um what also going into like

00:16:58,560 --> 00:17:03,040
staging and camera or

00:17:00,000 --> 00:17:03,440
deployments that uh might be hard to do

00:17:03,040 --> 00:17:05,679
if you

00:17:03,440 --> 00:17:07,760
don't have a lot of experience in a

00:17:05,679 --> 00:17:09,839
certain area of the code

00:17:07,760 --> 00:17:11,839
so i think the next slide starts with

00:17:09,839 --> 00:17:15,760
the openness aspect

00:17:11,839 --> 00:17:18,720
so uh openness in our case uh

00:17:15,760 --> 00:17:20,319
means of course open code we have a lot

00:17:18,720 --> 00:17:23,600
of report stories

00:17:20,319 --> 00:17:25,199
um for all these pieces we try to

00:17:23,600 --> 00:17:25,839
consolidate them where it makes sense

00:17:25,199 --> 00:17:28,720
but still

00:17:25,839 --> 00:17:30,799
still it's a lot uh and the open by

00:17:28,720 --> 00:17:31,760
default is actually something we try to

00:17:30,799 --> 00:17:34,160
live by

00:17:31,760 --> 00:17:35,520
now there are certain pieces that we are

00:17:34,160 --> 00:17:37,760
not really comfortable putting them for

00:17:35,520 --> 00:17:40,400
example on gitlab.com uh mostly

00:17:37,760 --> 00:17:42,080
secrets uh internal documentation

00:17:40,400 --> 00:17:43,600
configuration

00:17:42,080 --> 00:17:45,679
our deployment jammers are still

00:17:43,600 --> 00:17:47,520
internal that

00:17:45,679 --> 00:17:49,280
is something that we want to to change

00:17:47,520 --> 00:17:51,440
um also the ansible code we've

00:17:49,280 --> 00:17:53,440
we've learned a lot from what the fedora

00:17:51,440 --> 00:17:55,600
infrastructure people put online

00:17:53,440 --> 00:17:57,600
and we want to do this but um at the

00:17:55,600 --> 00:17:59,760
moment there's still this encrypted

00:17:57,600 --> 00:18:01,360
secrets file on there

00:17:59,760 --> 00:18:03,120
where we don't want to just have a

00:18:01,360 --> 00:18:04,160
password between our internal

00:18:03,120 --> 00:18:07,840
infrastructure and

00:18:04,160 --> 00:18:10,880
um and the world

00:18:07,840 --> 00:18:12,559
so this this piece is in progress

00:18:10,880 --> 00:18:14,240
we've worked a lot on documentation and

00:18:12,559 --> 00:18:17,039
there's there's far more to do

00:18:14,240 --> 00:18:17,440
um trying to find out what our audiences

00:18:17,039 --> 00:18:19,440
are

00:18:17,440 --> 00:18:20,559
um we are a service so we actually have

00:18:19,440 --> 00:18:21,919
users

00:18:20,559 --> 00:18:23,760
kernel developers that are more or less

00:18:21,919 --> 00:18:26,000
forced to work with us we want to make

00:18:23,760 --> 00:18:27,520
that as painless as possible

00:18:26,000 --> 00:18:29,919
but we also want to document uh the

00:18:27,520 --> 00:18:31,360
individual pieces of their readme files

00:18:29,919 --> 00:18:33,120
or there should be rhythmifies on all of

00:18:31,360 --> 00:18:35,360
those repositories

00:18:33,120 --> 00:18:36,880
uh and something we've worked on is

00:18:35,360 --> 00:18:39,840
trying to inventorize

00:18:36,880 --> 00:18:41,280
how all these pieces fit together we've

00:18:39,840 --> 00:18:42,320
sewn that from ce and i will show an

00:18:41,280 --> 00:18:44,799
example in a minute

00:18:42,320 --> 00:18:45,760
um and again we still have internal

00:18:44,799 --> 00:18:49,440
documentation

00:18:45,760 --> 00:18:52,640
um so um we are not there yet

00:18:49,440 --> 00:18:55,200
so this is this is uh oh yeah ha

00:18:52,640 --> 00:18:56,559
there's another thing um and yeah one of

00:18:55,200 --> 00:18:58,320
the things that that worked well is

00:18:56,559 --> 00:18:59,840
having documentation fridays

00:18:58,320 --> 00:19:01,840
so that there's actually an excuse to

00:18:59,840 --> 00:19:03,200
work on documentation so this is an

00:19:01,840 --> 00:19:05,039
example of um

00:19:03,200 --> 00:19:06,880
of what the inventory looks like it

00:19:05,039 --> 00:19:08,880
tries to describe a service

00:19:06,880 --> 00:19:10,720
uh or a cron job in this case what it's

00:19:08,880 --> 00:19:12,400
good for where you can find

00:19:10,720 --> 00:19:14,640
the code or where you can find the

00:19:12,400 --> 00:19:18,080
deployment what it depends on

00:19:14,640 --> 00:19:20,799
um what other pieces might depend on it

00:19:18,080 --> 00:19:21,360
and this gets rendered on in our website

00:19:20,799 --> 00:19:23,039
um

00:19:21,360 --> 00:19:25,520
so in the next slide you see an example

00:19:23,039 --> 00:19:27,840
this looks like on our homepage

00:19:25,520 --> 00:19:29,840
um so that you can actually start to

00:19:27,840 --> 00:19:31,679
explore stuff you can click through

00:19:29,840 --> 00:19:33,360
the idea is also to to use that for

00:19:31,679 --> 00:19:34,400
example for monitoring so that you can

00:19:33,360 --> 00:19:36,160
define in this

00:19:34,400 --> 00:19:39,120
structured yaml format uh your

00:19:36,160 --> 00:19:42,320
monitoring or even alerting um

00:19:39,120 --> 00:19:44,799
a connection between deployment and code

00:19:42,320 --> 00:19:46,000
uh and put more metadata about how it

00:19:44,799 --> 00:19:49,280
all fits together

00:19:46,000 --> 00:19:52,240
in an abstract uh way let's say but uh

00:19:49,280 --> 00:19:55,039
still um should make it easier to to get

00:19:52,240 --> 00:19:57,200
a feeling how it all fits together

00:19:55,039 --> 00:19:58,480
we try to be open in our uh daily

00:19:57,200 --> 00:20:01,360
operations um

00:19:58,480 --> 00:20:02,799
that means uh moving issues from jira to

00:20:01,360 --> 00:20:06,400
gitlab.com

00:20:02,799 --> 00:20:08,960
um which is also quite a bit nicer for

00:20:06,400 --> 00:20:10,640
the features we only used from jr which

00:20:08,960 --> 00:20:13,039
are really nicely covered by

00:20:10,640 --> 00:20:14,400
gitlab.com we have an open channel

00:20:13,039 --> 00:20:16,720
that's mostly populated

00:20:14,400 --> 00:20:17,840
by the bot that is reloading about

00:20:16,720 --> 00:20:19,440
everything

00:20:17,840 --> 00:20:21,280
but also all the discussions happen

00:20:19,440 --> 00:20:23,520
there

00:20:21,280 --> 00:20:24,720
everything is mutually best most request

00:20:23,520 --> 00:20:27,520
based so there are no

00:20:24,720 --> 00:20:28,799
direct pushes um and everybody can

00:20:27,520 --> 00:20:31,280
basically subscribe to

00:20:28,799 --> 00:20:32,640
to the merge request or the project and

00:20:31,280 --> 00:20:35,760
chime in

00:20:32,640 --> 00:20:37,280
we try to formalize our feedback process

00:20:35,760 --> 00:20:38,960
a bit because sometimes uh

00:20:37,280 --> 00:20:41,360
discussions happen on ioc and you might

00:20:38,960 --> 00:20:44,880
not be online so you might miss them

00:20:41,360 --> 00:20:47,840
so for for more general stuff uh

00:20:44,880 --> 00:20:48,480
that might be a good idea or where you

00:20:47,840 --> 00:20:50,640
just feel

00:20:48,480 --> 00:20:52,880
you won't have feedback um you have an

00:20:50,640 --> 00:20:54,080
rfc process which basically means you

00:20:52,880 --> 00:20:56,000
put up a merge request to the

00:20:54,080 --> 00:20:57,440
documentation repository from the next

00:20:56,000 --> 00:20:59,840
slide as an example

00:20:57,440 --> 00:21:00,480
uh and you can ask for feedback it's

00:20:59,840 --> 00:21:02,559
still

00:21:00,480 --> 00:21:04,240
uh it's a feedback process explicitly

00:21:02,559 --> 00:21:06,960
it's it's not i mean you have

00:21:04,240 --> 00:21:08,080
processes like adr uh architectural

00:21:06,960 --> 00:21:11,600
decision records

00:21:08,080 --> 00:21:13,280
um where you actually ask for decisions

00:21:11,600 --> 00:21:15,120
uh in this case we are an agile team we

00:21:13,280 --> 00:21:17,679
trust each other uh well enough

00:21:15,120 --> 00:21:19,840
so that you can actually just um ask for

00:21:17,679 --> 00:21:21,840
feedback and we trust that uh whoever

00:21:19,840 --> 00:21:22,960
uh put this up they do the right thing

00:21:21,840 --> 00:21:25,039
afterwards so

00:21:22,960 --> 00:21:26,400
they are the domain expert they they get

00:21:25,039 --> 00:21:31,520
feedback and then they

00:21:26,400 --> 00:21:34,240
can carry on whatever they want to do um

00:21:31,520 --> 00:21:34,640
the next big chunk is safety and in this

00:21:34,240 --> 00:21:36,960
case

00:21:34,640 --> 00:21:38,080
uh safety to change so we want to make

00:21:36,960 --> 00:21:39,919
that as

00:21:38,080 --> 00:21:41,760
safe as possible we want to make reviews

00:21:39,919 --> 00:21:44,640
as painless as possible so that means

00:21:41,760 --> 00:21:45,360
linting and testing as much as you can

00:21:44,640 --> 00:21:47,919
we try to

00:21:45,360 --> 00:21:50,080
lynch hellcoach hell in yammer code uh

00:21:47,919 --> 00:21:52,720
all kinds of python lintels that we can

00:21:50,080 --> 00:21:55,120
get our hands on unit tests um

00:21:52,720 --> 00:21:56,400
markdown linting link checking

00:21:55,120 --> 00:21:59,600
everything we can think of

00:21:56,400 --> 00:22:01,520
to automate um and also to have less to

00:21:59,600 --> 00:22:04,799
review because if it's automatically

00:22:01,520 --> 00:22:08,080
uh limited uh there's already

00:22:04,799 --> 00:22:09,600
automated feedback coming um

00:22:08,080 --> 00:22:11,200
means also we have a linting script that

00:22:09,600 --> 00:22:13,840
you can just run locally and just

00:22:11,200 --> 00:22:15,919
work hopefully independent of your

00:22:13,840 --> 00:22:17,919
explicit python setup

00:22:15,919 --> 00:22:19,039
um we're still working on using

00:22:17,919 --> 00:22:22,000
formatters uh the

00:22:19,039 --> 00:22:23,120
packet theme is quite a bit better or

00:22:22,000 --> 00:22:26,159
like

00:22:23,120 --> 00:22:28,000
further along with this trajectory uh so

00:22:26,159 --> 00:22:29,280
using something as black for python code

00:22:28,000 --> 00:22:32,960
might actually take the

00:22:29,280 --> 00:22:33,600
pain out of the uh formatting expect

00:22:32,960 --> 00:22:35,520
let's say

00:22:33,600 --> 00:22:37,679
instead of just using flaggate but

00:22:35,520 --> 00:22:40,320
that's the work in progress

00:22:37,679 --> 00:22:41,679
um and one another aspect for the

00:22:40,320 --> 00:22:44,080
testing is that we

00:22:41,679 --> 00:22:44,720
these dependencies that we have shared

00:22:44,080 --> 00:22:46,799
libraries

00:22:44,720 --> 00:22:48,000
um that are reused in other places and

00:22:46,799 --> 00:22:50,960
so if somebody changes

00:22:48,000 --> 00:22:51,440
the library we don't yet run dependent

00:22:50,960 --> 00:22:54,159
uh

00:22:51,440 --> 00:22:55,679
testing pipelines so this is the list to

00:22:54,159 --> 00:22:58,080
do but should also happen the next

00:22:55,679 --> 00:23:00,159
couple of weeks

00:22:58,080 --> 00:23:02,000
um as in yaki already said we split it

00:23:00,159 --> 00:23:05,280
up into into microservices

00:23:02,000 --> 00:23:08,400
also because um i'm pretty old i need to

00:23:05,280 --> 00:23:09,919
fit pieces into my head um so i have the

00:23:08,400 --> 00:23:12,799
tendency to simplify things

00:23:09,919 --> 00:23:13,919
um and that also makes it less scary

00:23:12,799 --> 00:23:15,520
because if you have

00:23:13,919 --> 00:23:17,200
the feeling or if you have a good

00:23:15,520 --> 00:23:18,640
understanding or at least you think you

00:23:17,200 --> 00:23:20,960
have a good understanding

00:23:18,640 --> 00:23:23,280
it's much more fun to to change code and

00:23:20,960 --> 00:23:25,120
to clean it up and also

00:23:23,280 --> 00:23:26,720
in our experience microservices are

00:23:25,120 --> 00:23:28,000
structured better so there are some

00:23:26,720 --> 00:23:30,480
interfaces that you

00:23:28,000 --> 00:23:32,159
more or less need to either explicitly

00:23:30,480 --> 00:23:33,039
or implicitly define between those

00:23:32,159 --> 00:23:35,600
pieces

00:23:33,039 --> 00:23:37,840
and that actually makes structures more

00:23:35,600 --> 00:23:37,840
clear

00:23:38,400 --> 00:23:41,440
what's on the next slide i have no idea

00:23:40,080 --> 00:23:43,679
actually

00:23:41,440 --> 00:23:45,760
oh yeah so and the last last aspect is

00:23:43,679 --> 00:23:48,960
uh how you can actually deploy code

00:23:45,760 --> 00:23:50,480
so we are basically uh

00:23:48,960 --> 00:23:52,159
it's always nice so we say we are an

00:23:50,480 --> 00:23:53,360
agile team and that means for us living

00:23:52,159 --> 00:23:56,480
on the edge

00:23:53,360 --> 00:23:57,760
um so if you merge something to maine it

00:23:56,480 --> 00:24:00,159
gets deployed one way

00:23:57,760 --> 00:24:01,200
one way or the other and the way that

00:24:00,159 --> 00:24:03,279
works for us is that

00:24:01,200 --> 00:24:05,120
you get a review but you are responsible

00:24:03,279 --> 00:24:07,279
for for merging it and for

00:24:05,120 --> 00:24:09,039
uh actually making sure that any fallout

00:24:07,279 --> 00:24:10,000
is handled or to revert whatever you

00:24:09,039 --> 00:24:11,760
changed

00:24:10,000 --> 00:24:13,120
so it's your code the reviewers can give

00:24:11,760 --> 00:24:16,880
feedback but they are not

00:24:13,120 --> 00:24:20,159
responsible for whatever you want um so

00:24:16,880 --> 00:24:23,360
it's a process that's working quite well

00:24:20,159 --> 00:24:26,480
um it's very important to have some

00:24:23,360 --> 00:24:29,120
some uh restraint at the end of the day

00:24:26,480 --> 00:24:29,840
uh or just before the weekend and it's a

00:24:29,120 --> 00:24:33,440
good idea to

00:24:29,840 --> 00:24:34,159
to shift the deployment to the next day

00:24:33,440 --> 00:24:38,320
or to

00:24:34,159 --> 00:24:41,120
next week and jackie already discussed

00:24:38,320 --> 00:24:42,080
the structure of what we have and now

00:24:41,120 --> 00:24:45,760
for deployment

00:24:42,080 --> 00:24:47,279
there are the last two types of

00:24:45,760 --> 00:24:49,039
of stuff we are in so internal

00:24:47,279 --> 00:24:50,880
microservices and uh and pipeline

00:24:49,039 --> 00:24:53,760
components and they are slightly

00:24:50,880 --> 00:24:54,159
different in how you can deploy them so

00:24:53,760 --> 00:24:56,799
um

00:24:54,159 --> 00:24:58,799
for microservices those are containers

00:24:56,799 --> 00:25:01,919
um

00:24:58,799 --> 00:25:05,039
we package them up they should be

00:25:01,919 --> 00:25:06,159
uh policy free um and code should be

00:25:05,039 --> 00:25:07,520
structured in a way that there is a

00:25:06,159 --> 00:25:10,960
non-production mode

00:25:07,520 --> 00:25:13,279
uh that makes running the code um

00:25:10,960 --> 00:25:14,480
safe like for example if you normally

00:25:13,279 --> 00:25:16,400
send emails

00:25:14,480 --> 00:25:18,240
if you set this to false its production

00:25:16,400 --> 00:25:19,600
is false it shouldn't send emails

00:25:18,240 --> 00:25:22,000
otherwise you get kernel developers

00:25:19,600 --> 00:25:24,640
yelling at you um

00:25:22,000 --> 00:25:25,120
we centralized all our deployment

00:25:24,640 --> 00:25:27,440
jammers

00:25:25,120 --> 00:25:29,120
for openshift all the ansible scripts

00:25:27,440 --> 00:25:30,720
into one piece

00:25:29,120 --> 00:25:32,559
that allowed us to actually clean that

00:25:30,720 --> 00:25:33,200
up and get some structure in there also

00:25:32,559 --> 00:25:37,679
to get an

00:25:33,200 --> 00:25:39,360
overview what do you run and

00:25:37,679 --> 00:25:41,279
as everything is deployed automatically

00:25:39,360 --> 00:25:44,159
from there if you change something

00:25:41,279 --> 00:25:45,039
everything is is redeployed uh it's

00:25:44,159 --> 00:25:46,799
either potent

00:25:45,039 --> 00:25:48,400
ansible and then an open shift or

00:25:46,799 --> 00:25:49,919
kubernetes jammers so they shouldn't

00:25:48,400 --> 00:25:52,880
should mess things up

00:25:49,919 --> 00:25:53,279
but it also means that uh it should work

00:25:52,880 --> 00:25:56,640
so

00:25:53,279 --> 00:25:58,400
um if

00:25:56,640 --> 00:26:00,559
the deployment code is brittle you will

00:25:58,400 --> 00:26:02,159
notice because it runs quite often

00:26:00,559 --> 00:26:03,600
um and also keeps people from messing

00:26:02,159 --> 00:26:04,080
with the infrastructure in a manual way

00:26:03,600 --> 00:26:05,760
because

00:26:04,080 --> 00:26:09,120
basically their changes get overwritten

00:26:05,760 --> 00:26:12,720
the next time such a pipeline runs

00:26:09,120 --> 00:26:13,200
um now normally you for microservice you

00:26:12,720 --> 00:26:15,520
want to

00:26:13,200 --> 00:26:16,960
try it locally we have a helper to build

00:26:15,520 --> 00:26:18,559
this container image you can also just

00:26:16,960 --> 00:26:21,120
pull it down from the merch request

00:26:18,559 --> 00:26:22,320
all our mess requests build all of those

00:26:21,120 --> 00:26:24,159
container images

00:26:22,320 --> 00:26:25,840
continuously you get to get them tagged

00:26:24,159 --> 00:26:26,720
per meter request you get them tech per

00:26:25,840 --> 00:26:28,400
pipeline

00:26:26,720 --> 00:26:30,400
so whatever you are interested in you

00:26:28,400 --> 00:26:32,400
can get from from gitlab

00:26:30,400 --> 00:26:35,279
from the registry electricity there

00:26:32,400 --> 00:26:36,960
might be faster than building it locally

00:26:35,279 --> 00:26:39,120
now if you want to run those container

00:26:36,960 --> 00:26:40,480
images that is always painful because

00:26:39,120 --> 00:26:42,240
you need to have some

00:26:40,480 --> 00:26:43,600
configuration on them to make them do

00:26:42,240 --> 00:26:45,200
what you want

00:26:43,600 --> 00:26:47,360
most of the pieces have a command line

00:26:45,200 --> 00:26:50,159
interface that actually allow you to

00:26:47,360 --> 00:26:51,760
check the microservice how it processes

00:26:50,159 --> 00:26:53,039
some

00:26:51,760 --> 00:26:55,679
certain aspect for example for the

00:26:53,039 --> 00:26:57,520
kernel web hooks um they

00:26:55,679 --> 00:26:58,720
they check merge requests whether they

00:26:57,520 --> 00:27:01,440
have uh

00:26:58,720 --> 00:27:02,480
certain labels set stuff like that um

00:27:01,440 --> 00:27:04,080
and so they have a command line

00:27:02,480 --> 00:27:05,520
interface to basically

00:27:04,080 --> 00:27:07,120
uh check your certain virtual requests

00:27:05,520 --> 00:27:09,600
for example you can see what they do

00:27:07,120 --> 00:27:10,799
um so if you would think of a function

00:27:09,600 --> 00:27:13,039
as a service

00:27:10,799 --> 00:27:15,039
um most of our microservices are mostly

00:27:13,039 --> 00:27:16,720
event processing so you can basically do

00:27:15,039 --> 00:27:19,760
one shot

00:27:16,720 --> 00:27:20,880
run on on some event cloudy with

00:27:19,760 --> 00:27:23,919
something

00:27:20,880 --> 00:27:26,159
um but so yeah it works

00:27:23,919 --> 00:27:28,480
reasonably well but uh getting them up

00:27:26,159 --> 00:27:29,679
locally is a bit of a pain because you

00:27:28,480 --> 00:27:31,279
need to have this configuration and it's

00:27:29,679 --> 00:27:32,640
not something that you can easily share

00:27:31,279 --> 00:27:36,320
because there might be some

00:27:32,640 --> 00:27:38,320
production credentials in there um

00:27:36,320 --> 00:27:40,080
for the next aspect is actually how do

00:27:38,320 --> 00:27:42,640
you can can you actually

00:27:40,080 --> 00:27:44,320
do a testing deployment of them now you

00:27:42,640 --> 00:27:45,440
have this non-production mode so either

00:27:44,320 --> 00:27:47,440
you run it locally in this

00:27:45,440 --> 00:27:49,520
non-production mode or remotely on the

00:27:47,440 --> 00:27:52,480
kubernetes cluster doesn't matter

00:27:49,520 --> 00:27:54,559
so you can just uh move it there um

00:27:52,480 --> 00:27:56,960
there's a shell script that nobody wants

00:27:54,559 --> 00:27:58,880
because it's painful to understand

00:27:56,960 --> 00:28:00,880
script um

00:27:58,880 --> 00:28:02,399
and so the last thing we've worked on is

00:28:00,880 --> 00:28:04,159
basically making that uh

00:28:02,399 --> 00:28:06,159
automated by the press of a button in

00:28:04,159 --> 00:28:08,080
gitlab so you have a merge request you

00:28:06,159 --> 00:28:10,000
have this beautiful button that says uh

00:28:08,080 --> 00:28:11,360
deploy it into a merch request

00:28:10,000 --> 00:28:14,720
environment and just spin up

00:28:11,360 --> 00:28:18,080
a comparable deployment config

00:28:14,720 --> 00:28:20,320
in openshift or kubernetes to try it out

00:28:18,080 --> 00:28:22,320
and okay the idea is that you can find a

00:28:20,320 --> 00:28:24,080
link in and then inspect the logs for

00:28:22,320 --> 00:28:27,440
example

00:28:24,080 --> 00:28:28,880
um same goes for production deployments

00:28:27,440 --> 00:28:30,159
normally it's it's deployed

00:28:28,880 --> 00:28:30,720
automatically when the merchandise is

00:28:30,159 --> 00:28:33,919
merged but

00:28:30,720 --> 00:28:34,640
if you want so sometimes to find out

00:28:33,919 --> 00:28:37,279
whether something

00:28:34,640 --> 00:28:39,039
is really fixed on on your code uh you

00:28:37,279 --> 00:28:39,679
can also deploy a merge request into

00:28:39,039 --> 00:28:41,760
production

00:28:39,679 --> 00:28:43,360
and that will survive a redeployment of

00:28:41,760 --> 00:28:44,880
this deployment repository basically

00:28:43,360 --> 00:28:47,360
attacks the container image as

00:28:44,880 --> 00:28:47,919
being production and within two minutes

00:28:47,360 --> 00:28:49,440
it should just

00:28:47,919 --> 00:28:51,279
uh appear on openshift and you can

00:28:49,440 --> 00:28:52,640
actually figure out whether you solved

00:28:51,279 --> 00:28:54,960
the problem or you can press another

00:28:52,640 --> 00:28:57,360
button and another job to a while back

00:28:54,960 --> 00:29:00,399
which would also be a quite painless and

00:28:57,360 --> 00:29:00,399
within a couple of minutes

00:29:00,480 --> 00:29:04,720
now for the other big piece which is the

00:29:03,279 --> 00:29:06,080
pipeline so this is uh

00:29:04,720 --> 00:29:08,240
the pipeline is always a nice world but

00:29:06,080 --> 00:29:10,799
it's it's basically um

00:29:08,240 --> 00:29:11,520
a lot of python tools duct taped

00:29:10,799 --> 00:29:14,000
together

00:29:11,520 --> 00:29:15,520
by a lot of bash you know 2 000 lines of

00:29:14,000 --> 00:29:18,080
bash i think at the moment

00:29:15,520 --> 00:29:18,880
which is really hard to test but you can

00:29:18,080 --> 00:29:20,720
test

00:29:18,880 --> 00:29:22,080
the components it's actually the way you

00:29:20,720 --> 00:29:23,440
should test them

00:29:22,080 --> 00:29:27,360
they all have a command line interface

00:29:23,440 --> 00:29:29,440
you pip install them uh and there you go

00:29:27,360 --> 00:29:32,159
and that is actually the way these tools

00:29:29,440 --> 00:29:32,159
also developed

00:29:32,320 --> 00:29:39,120
for actually running the pipeline itself

00:29:35,679 --> 00:29:42,720
we we support canary deployments so

00:29:39,120 --> 00:29:45,200
for all the that's on the next slide um

00:29:42,720 --> 00:29:45,200
you can

00:29:45,760 --> 00:29:51,679
um run your non-merged code

00:29:49,520 --> 00:29:52,640
um in a pipeline so basically normally

00:29:51,679 --> 00:29:54,640
these pipelines

00:29:52,640 --> 00:29:57,039
are these are just container images they

00:29:54,640 --> 00:29:58,960
they do a pip installed in the beginning

00:29:57,039 --> 00:30:00,799
of the main branch and you can override

00:29:58,960 --> 00:30:04,159
it to say like i want to have

00:30:00,799 --> 00:30:05,760
my branch instead of the main branch um

00:30:04,159 --> 00:30:07,919
and we have the bot that will help you

00:30:05,760 --> 00:30:09,440
and if you're nice you can ask it a lot

00:30:07,919 --> 00:30:11,360
of complicated questions uh

00:30:09,440 --> 00:30:13,120
basically saying like test this old

00:30:11,360 --> 00:30:16,399
pipeline that passed

00:30:13,120 --> 00:30:19,279
a while ago use the same kernel revision

00:30:16,399 --> 00:30:20,320
it should still pass but and you can

00:30:19,279 --> 00:30:22,399
modify

00:30:20,320 --> 00:30:23,360
also parameters if it's necessary for

00:30:22,399 --> 00:30:25,039
testing your changes

00:30:23,360 --> 00:30:27,200
if you for example mess with the pipe

00:30:25,039 --> 00:30:27,840
the pipeline yaml but also for example

00:30:27,200 --> 00:30:30,080
if you

00:30:27,840 --> 00:30:31,360
for example uh change how the beacon

00:30:30,080 --> 00:30:32,799
provisioning works

00:30:31,360 --> 00:30:34,640
you can actually figure out whether you

00:30:32,799 --> 00:30:36,640
you broke the production setup before

00:30:34,640 --> 00:30:37,919
before it gets merged

00:30:36,640 --> 00:30:39,840
yeah okay and then production

00:30:37,919 --> 00:30:42,159
deployments is for the pipeline

00:30:39,840 --> 00:30:44,399
basically you merge it you get it uh as

00:30:42,159 --> 00:30:46,240
soon as it hits the git repository

00:30:44,399 --> 00:30:47,600
it will be used for the next pipeline

00:30:46,240 --> 00:30:50,159
that comes along and if you need to

00:30:47,600 --> 00:30:52,640
revert code it's a git report and

00:30:50,159 --> 00:30:54,640
a button press array so that's that's

00:30:52,640 --> 00:31:00,000
also quite easy

00:30:54,640 --> 00:31:00,000

YouTube URL: https://www.youtube.com/watch?v=C7FLD0FUnsY


