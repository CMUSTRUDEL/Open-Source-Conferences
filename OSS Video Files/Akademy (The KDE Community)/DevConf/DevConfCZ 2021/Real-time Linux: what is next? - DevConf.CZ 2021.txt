Title: Real-time Linux: what is next? - DevConf.CZ 2021
Publication date: 2021-03-14
Playlist: DevConfCZ 2021
Description: 
	Speaker: Daniel Bristot de Oliveira

With the PREEMPT_RT mainlining, is the real-time Linux development ended? - No! It is the beginning of a new era. The low latency provided by the nowadays communication channels and the need for a software stack for AI/ML present on Linux is enabling a new class of cyber-physical systems that depends on real-time kernel. But, is the real-time kernel ready to be used in such scenarios? This presentation is a discussion about the current state of Real-time Linux. It will talk about the kind of determinism that is possible to obtain with Linux and the type of determinism that is still not possible to achieve. The main goal is to point to the next opportunities in the development that can enable Linux for a class of systems that requires more robust evidence of correctness, including the formal verification of the kernel and the mathematical analysis of the timing properties of the kernel.



Schedule: https://sched.co/gmMw
Captions: 
	00:00:01,120 --> 00:00:04,560
i'm daniel i'm part of the real-time

00:00:03,040 --> 00:00:06,240
kernel team at red hat

00:00:04,560 --> 00:00:08,080
and i'm also a postdoctoral researcher

00:00:06,240 --> 00:00:10,639
at school of spirit santana

00:00:08,080 --> 00:00:12,559
in pisa where i try to live in between

00:00:10,639 --> 00:00:14,719
these two words of the development and

00:00:12,559 --> 00:00:18,000
research right

00:00:14,719 --> 00:00:20,640
so relax this is not a heavy uh

00:00:18,000 --> 00:00:22,640
talk i'm not going too much details but

00:00:20,640 --> 00:00:24,160
it's more an open-ended talk presenting

00:00:22,640 --> 00:00:25,279
some talks and pointing to the

00:00:24,160 --> 00:00:27,599
interactions

00:00:25,279 --> 00:00:30,240
and people will see links on qr codes

00:00:27,599 --> 00:00:32,960
during the presentation right

00:00:30,240 --> 00:00:35,440
so what is real time right real-time

00:00:32,960 --> 00:00:37,200
systems are computing systems that

00:00:35,440 --> 00:00:39,120
the correct behavior does not depend

00:00:37,200 --> 00:00:40,640
only on the functional behavior but also

00:00:39,120 --> 00:00:42,879
in the timing behavior

00:00:40,640 --> 00:00:44,000
that is the logical result is only

00:00:42,879 --> 00:00:47,520
correct it is

00:00:44,000 --> 00:00:48,480
produced before a given deadline so the

00:00:47,520 --> 00:00:51,600
response time

00:00:48,480 --> 00:00:54,559
is also important uh

00:00:51,600 --> 00:00:56,320
in the real-time theory the things works

00:00:54,559 --> 00:00:58,079
somehow like this so we start to create

00:00:56,320 --> 00:01:00,640
a precise definition of the system

00:00:58,079 --> 00:01:01,199
try to capture all the behaviors and we

00:01:00,640 --> 00:01:03,520
try to

00:01:01,199 --> 00:01:05,119
imagine some algorithm try to define the

00:01:03,520 --> 00:01:06,159
worst case scenarios and come up with

00:01:05,119 --> 00:01:08,240
some formulas

00:01:06,159 --> 00:01:09,920
to show that results are delivered

00:01:08,240 --> 00:01:12,400
before the

00:01:09,920 --> 00:01:12,400
deadline

00:01:12,960 --> 00:01:17,040
there are some uh theories that are

00:01:15,200 --> 00:01:20,000
straightforward to understand

00:01:17,040 --> 00:01:21,280
like the ddf or single core but there

00:01:20,000 --> 00:01:23,520
are others that are more

00:01:21,280 --> 00:01:25,280
complex right and when i say complex

00:01:23,520 --> 00:01:27,360
it's in that complex

00:01:25,280 --> 00:01:29,520
that it generally requires some years of

00:01:27,360 --> 00:01:32,560
understanding of this mathematics behind

00:01:29,520 --> 00:01:36,159
real time so the real-time

00:01:32,560 --> 00:01:39,680
system theory is generally considered a

00:01:36,159 --> 00:01:41,360
complex subject because the mathematical

00:01:39,680 --> 00:01:44,399
reasoning is complex

00:01:41,360 --> 00:01:45,680
and in order to facilitate the

00:01:44,399 --> 00:01:48,560
development of new

00:01:45,680 --> 00:01:50,240
theories some assumptions are made to to

00:01:48,560 --> 00:01:52,799
facilitate the reasoning right

00:01:50,240 --> 00:01:54,320
like assuming that the system is fully

00:01:52,799 --> 00:01:57,600
preemptive because

00:01:54,320 --> 00:01:59,520
it's easy to to think in this way

00:01:57,600 --> 00:02:01,600
assuming that the other process of a

00:01:59,520 --> 00:02:04,640
system are independent that

00:02:01,600 --> 00:02:06,880
overheads are tolerable and uh and yes

00:02:04,640 --> 00:02:07,680
think things are this way because it

00:02:06,880 --> 00:02:09,679
would be

00:02:07,680 --> 00:02:12,239
too complex to be reviewed and

00:02:09,679 --> 00:02:15,280
established otherwise

00:02:12,239 --> 00:02:17,599
and on the other corner we have

00:02:15,280 --> 00:02:19,360
linux which has a more practical

00:02:17,599 --> 00:02:21,520
approach right

00:02:19,360 --> 00:02:23,920
the real-time linux is not a single

00:02:21,520 --> 00:02:25,440
thing but instead a set of features

00:02:23,920 --> 00:02:27,760
that tries to provide a more

00:02:25,440 --> 00:02:31,920
deterministic behavior for them

00:02:27,760 --> 00:02:34,400
and uh and the approach works more like

00:02:31,920 --> 00:02:35,680
okay we have a metric to be maximized

00:02:34,400 --> 00:02:38,480
for example we have the

00:02:35,680 --> 00:02:40,640
the scheduling latency and some

00:02:38,480 --> 00:02:43,920
background is generally considered like

00:02:40,640 --> 00:02:46,160
okay in the theory the primitive model

00:02:43,920 --> 00:02:48,160
is a good thing for for this so we try

00:02:46,160 --> 00:02:50,239
to mimic that

00:02:48,160 --> 00:02:51,200
and then some testing tools generally

00:02:50,239 --> 00:02:53,120
developed right

00:02:51,200 --> 00:02:55,280
and user space testing tool like cycling

00:02:53,120 --> 00:02:58,560
test and these go again

00:02:55,280 --> 00:03:00,080
for for other metrics so nowadays the

00:02:58,560 --> 00:03:00,720
main features for the real-time linux

00:03:00,080 --> 00:03:02,720
you can say

00:03:00,720 --> 00:03:05,440
which is the the full primitive mode

00:03:02,720 --> 00:03:08,720
with primarity we have scattered line

00:03:05,440 --> 00:03:11,120
and log with pi and so on but

00:03:08,720 --> 00:03:13,200
in the same same way that mathematics

00:03:11,120 --> 00:03:14,879
lyrics is complex and many times some

00:03:13,200 --> 00:03:16,159
assumptions are made to facilitate the

00:03:14,879 --> 00:03:18,080
development

00:03:16,159 --> 00:03:20,000
for example the primitive mode of linux

00:03:18,080 --> 00:03:20,640
is not the primitive mode on the theory

00:03:20,000 --> 00:03:24,480
because

00:03:20,640 --> 00:03:26,640
we can uh disable disable the impression

00:03:24,480 --> 00:03:28,879
temporarily in same way the scan

00:03:26,640 --> 00:03:32,080
deadlines uh accept some things that

00:03:28,879 --> 00:03:34,640
are not yet formalized for example

00:03:32,080 --> 00:03:36,239
uh persecute threats mixed with global

00:03:34,640 --> 00:03:38,959
schedule

00:03:36,239 --> 00:03:40,239
but some these things are are accepted

00:03:38,959 --> 00:03:43,680
because otherwise it would be too

00:03:40,239 --> 00:03:46,720
complex and we'll go nowhere else right

00:03:43,680 --> 00:03:48,720
so in one hand these things are good

00:03:46,720 --> 00:03:50,080
these uh these simplifications are good

00:03:48,720 --> 00:03:52,159
because they enable the progress and

00:03:50,080 --> 00:03:54,159
they are enabling use on a set of

00:03:52,159 --> 00:03:56,000
environments but they create this gap

00:03:54,159 --> 00:03:59,360
between the two and practicing

00:03:56,000 --> 00:03:59,920
so but well who cares about real-time

00:03:59,360 --> 00:04:01,840
linux

00:03:59,920 --> 00:04:04,080
and why is it important to try to put

00:04:01,840 --> 00:04:06,000
these two things together

00:04:04,080 --> 00:04:08,000
in in our current use case we are seeing

00:04:06,000 --> 00:04:09,120
high frequency trading some embedded

00:04:08,000 --> 00:04:11,680
electronics

00:04:09,120 --> 00:04:12,480
some low latency virtualization case

00:04:11,680 --> 00:04:14,959
that

00:04:12,480 --> 00:04:16,400
enables linux and that push the

00:04:14,959 --> 00:04:18,959
real-time linux forward

00:04:16,400 --> 00:04:20,239
but in the future we are starting more

00:04:18,959 --> 00:04:23,120
complex scenarios

00:04:20,239 --> 00:04:23,520
right you're starting seeing a system

00:04:23,120 --> 00:04:25,280
with

00:04:23,520 --> 00:04:28,560
lots of real-time tests instead of

00:04:25,280 --> 00:04:31,040
having one real-time task or one per cpu

00:04:28,560 --> 00:04:33,199
and we are seeing the usage of

00:04:31,040 --> 00:04:36,560
livingston safe critical systems

00:04:33,199 --> 00:04:38,400
and here is where uh the things start to

00:04:36,560 --> 00:04:40,960
get more complex right

00:04:38,400 --> 00:04:42,240
because safe critical systems they

00:04:40,960 --> 00:04:44,160
require a more

00:04:42,240 --> 00:04:46,479
higher level of insurance of the system

00:04:44,160 --> 00:04:48,160
behavior with some evidence that it

00:04:46,479 --> 00:04:52,000
works correctly

00:04:48,160 --> 00:04:53,199
and to the point that tests are good but

00:04:52,000 --> 00:04:55,680
sometimes

00:04:53,199 --> 00:04:56,400
that other things like for momentos

00:04:55,680 --> 00:04:58,720
could

00:04:56,400 --> 00:04:59,520
uh make these effects more strong and

00:04:58,720 --> 00:05:02,160
enable

00:04:59,520 --> 00:05:03,360
linux for more complex vertical

00:05:02,160 --> 00:05:05,199
environments

00:05:03,360 --> 00:05:07,199
so and here are back again there's this

00:05:05,199 --> 00:05:08,240
theory and procs and trying to make them

00:05:07,199 --> 00:05:10,639
together

00:05:08,240 --> 00:05:12,400
luckily some things have changed in the

00:05:10,639 --> 00:05:14,880
in your past right

00:05:12,400 --> 00:05:15,840
so and and here's an example with the

00:05:14,880 --> 00:05:18,960
preemption

00:05:15,840 --> 00:05:20,639
theory versus practice so

00:05:18,960 --> 00:05:22,560
with the parameter t the kernel becomes

00:05:20,639 --> 00:05:24,960
more preemptive which is

00:05:22,560 --> 00:05:26,479
as preemptive as possible everything

00:05:24,960 --> 00:05:29,120
becomes a tasks

00:05:26,479 --> 00:05:30,800
uh depression is enabled by default and

00:05:29,120 --> 00:05:32,320
we have some good results measured by

00:05:30,800 --> 00:05:34,880
cyclic tests on user space

00:05:32,320 --> 00:05:36,080
saying that okay my scheduling latency

00:05:34,880 --> 00:05:41,120
is

00:05:36,080 --> 00:05:41,120
in this amount of microseconds uh

00:05:41,360 --> 00:05:44,560
this is good because okay it enabled

00:05:43,759 --> 00:05:47,919
linux

00:05:44,560 --> 00:05:49,680
uh to to to be used on real-time system

00:05:47,919 --> 00:05:50,160
and enable the developments of series

00:05:49,680 --> 00:05:53,919
that

00:05:50,160 --> 00:05:56,560
that relies on it like sca deadline but

00:05:53,919 --> 00:05:58,479
yet there's no clear description of the

00:05:56,560 --> 00:06:01,039
factors that cause the latency there is

00:05:58,479 --> 00:06:04,160
no evidence that worst case scenario was

00:06:01,039 --> 00:06:08,160
ever hit by cyclic test so it's hard

00:06:04,160 --> 00:06:10,400
to convince a skeptical person right so

00:06:08,160 --> 00:06:12,800
how how how can we try to make linux

00:06:10,400 --> 00:06:14,960
more scientific compliant let's say

00:06:12,800 --> 00:06:16,720
right well we can try to follow that

00:06:14,960 --> 00:06:17,600
algorithm that people in the academia

00:06:16,720 --> 00:06:19,680
work which is

00:06:17,600 --> 00:06:21,280
trying to create a precise definition of

00:06:19,680 --> 00:06:23,280
the system create an algorithm

00:06:21,280 --> 00:06:24,960
trying to find worst case and define

00:06:23,280 --> 00:06:26,960
some set of equations

00:06:24,960 --> 00:06:28,240
uh luckily and that's so that's

00:06:26,960 --> 00:06:30,000
something that we also see

00:06:28,240 --> 00:06:31,600
on the application of other things for

00:06:30,000 --> 00:06:34,479
for safety critical

00:06:31,600 --> 00:06:36,560
um most of the kernel already works and

00:06:34,479 --> 00:06:38,080
there is the code there and many times

00:06:36,560 --> 00:06:39,520
we don't actually need to create a

00:06:38,080 --> 00:06:41,360
number of them but just to add a nice

00:06:39,520 --> 00:06:44,319
little twist on your perspective

00:06:41,360 --> 00:06:45,360
right so yes it's possible to try such

00:06:44,319 --> 00:06:46,960
approach

00:06:45,360 --> 00:06:49,680
for example the scheduling latest

00:06:46,960 --> 00:06:51,199
definition we said that schedule later

00:06:49,680 --> 00:06:53,919
definition

00:06:51,199 --> 00:06:56,000
is the longest time between the arrival

00:06:53,919 --> 00:06:58,160
of a highest priority job

00:06:56,000 --> 00:06:59,360
and when it starts to execute in its own

00:06:58,160 --> 00:07:02,080
code

00:06:59,360 --> 00:07:02,880
then we created a formal model that

00:07:02,080 --> 00:07:06,560
represents

00:07:02,880 --> 00:07:08,080
all the kernel events that could cause

00:07:06,560 --> 00:07:09,440
this delay or that influence in this

00:07:08,080 --> 00:07:12,800
matter

00:07:09,440 --> 00:07:15,840
from that from all these events we

00:07:12,800 --> 00:07:19,280
draw using a formal method

00:07:15,840 --> 00:07:22,880
what could be the worst case uh

00:07:19,280 --> 00:07:24,400
scenario for this latest they find a set

00:07:22,880 --> 00:07:27,840
of variables

00:07:24,400 --> 00:07:28,880
and came up with a bounce for the

00:07:27,840 --> 00:07:31,599
schedule latency

00:07:28,880 --> 00:07:33,360
and this was accepted by by uh by the

00:07:31,599 --> 00:07:36,639
real-time kernel community in

00:07:33,360 --> 00:07:39,759
theory right so

00:07:36,639 --> 00:07:40,880
this was a good advance as a real-time

00:07:39,759 --> 00:07:43,520
community because

00:07:40,880 --> 00:07:45,199
for a long time linux was precise by

00:07:43,520 --> 00:07:49,120
being

00:07:45,199 --> 00:07:51,120
not uh explored academically right or

00:07:49,120 --> 00:07:53,120
not exploring in the same rigor that

00:07:51,120 --> 00:07:55,599
they use there

00:07:53,120 --> 00:07:58,400
things have changed now linux we create

00:07:55,599 --> 00:08:01,360
some sort of theory that max links up

00:07:58,400 --> 00:08:02,160
but still right theory without proxy is

00:08:01,360 --> 00:08:04,400
not that

00:08:02,160 --> 00:08:05,599
that useful for for me as a developer

00:08:04,400 --> 00:08:09,120
right

00:08:05,599 --> 00:08:10,560
so we created also a

00:08:09,120 --> 00:08:12,879
practical schedule latency in

00:08:10,560 --> 00:08:16,479
measurement 2 that

00:08:12,879 --> 00:08:17,680
uses that formula capture the events of

00:08:16,479 --> 00:08:19,440
the kernel that

00:08:17,680 --> 00:08:20,720
influence on the variables of that

00:08:19,440 --> 00:08:22,720
formula

00:08:20,720 --> 00:08:24,800
but still trying to minimize the

00:08:22,720 --> 00:08:26,879
overhead that it causes

00:08:24,800 --> 00:08:28,800
right because we need to deal with too

00:08:26,879 --> 00:08:31,039
much events

00:08:28,800 --> 00:08:32,959
okay i i i don't have time here to

00:08:31,039 --> 00:08:35,360
explain this right but you can check the

00:08:32,959 --> 00:08:37,120
presentation of the linux plumbers last

00:08:35,360 --> 00:08:39,440
year that i presented in the

00:08:37,120 --> 00:08:42,000
details how these two works and it's

00:08:39,440 --> 00:08:45,839
available on my github and you can check

00:08:42,000 --> 00:08:48,560
more about it on my my web page

00:08:45,839 --> 00:08:49,600
and it has an output that tells me how

00:08:48,560 --> 00:08:52,480
much

00:08:49,600 --> 00:08:54,160
latency the system has considering some

00:08:52,480 --> 00:08:57,120
kinds of interrupts

00:08:54,160 --> 00:08:58,959
and where is the from where the the

00:08:57,120 --> 00:09:00,880
latest came from which is

00:08:58,959 --> 00:09:03,200
is it this variable or is it this

00:09:00,880 --> 00:09:06,320
interruption

00:09:03,200 --> 00:09:08,320
and with that we could bound together

00:09:06,320 --> 00:09:12,320
the theory in perhaps right

00:09:08,320 --> 00:09:15,120
and at the end one thing that we feared

00:09:12,320 --> 00:09:17,040
when trying to to make this more

00:09:15,120 --> 00:09:17,760
pessimistic and worst case things from

00:09:17,040 --> 00:09:21,120
theory

00:09:17,760 --> 00:09:23,600
only if we fear that the values would be

00:09:21,120 --> 00:09:25,920
too much pessimistic like not enabling

00:09:23,600 --> 00:09:26,640
limbs anymore for for the workloads that

00:09:25,920 --> 00:09:29,519
we were

00:09:26,640 --> 00:09:29,920
looking for but instead the results that

00:09:29,519 --> 00:09:33,040
we

00:09:29,920 --> 00:09:34,800
got were in that confirming

00:09:33,040 --> 00:09:36,160
what we thought what what they think

00:09:34,800 --> 00:09:38,000
about linux obviously

00:09:36,160 --> 00:09:40,000
the latest reported by this more

00:09:38,000 --> 00:09:40,880
pessimistic that cover all the cases

00:09:40,000 --> 00:09:43,519
that shows

00:09:40,880 --> 00:09:44,560
the root case the root cause they they

00:09:43,519 --> 00:09:46,160
are larger

00:09:44,560 --> 00:09:49,200
than cyclic tests because cyclic tests

00:09:46,160 --> 00:09:50,080
cannot get out the possible case or it

00:09:49,200 --> 00:09:52,560
would take too

00:09:50,080 --> 00:09:53,600
too long to hit one of these this

00:09:52,560 --> 00:09:56,000
miscase

00:09:53,600 --> 00:09:56,800
is still even with all the pessimism we

00:09:56,000 --> 00:09:59,120
are

00:09:56,800 --> 00:10:00,480
we are below one millisecond like we

00:09:59,120 --> 00:10:02,800
show on some

00:10:00,480 --> 00:10:04,079
uh architectures and also on a more

00:10:02,800 --> 00:10:05,839
complex architecture which

00:10:04,079 --> 00:10:07,680
we showed that it's still like even

00:10:05,839 --> 00:10:10,800
being super pessimistic

00:10:07,680 --> 00:10:11,120
almost unrealistic pessimist the latest

00:10:10,800 --> 00:10:15,200
is

00:10:11,120 --> 00:10:18,480
it's only two or four milliseconds right

00:10:15,200 --> 00:10:19,839
which might be too large for some use

00:10:18,480 --> 00:10:22,959
case that we are seeing but

00:10:19,839 --> 00:10:24,000
it's not for the automotive uh case for

00:10:22,959 --> 00:10:27,680
example

00:10:24,000 --> 00:10:29,680
and we have a strong evidence so

00:10:27,680 --> 00:10:31,200
with that work can we say that limit was

00:10:29,680 --> 00:10:32,560
theoretically proof as real-time

00:10:31,200 --> 00:10:35,839
operating system

00:10:32,560 --> 00:10:39,120
no there's still a long way to go right

00:10:35,839 --> 00:10:41,760
uh and the main point is that uh

00:10:39,120 --> 00:10:42,480
the focus of the parent rt for example

00:10:41,760 --> 00:10:45,040
of the

00:10:42,480 --> 00:10:46,800
of the major focus of the real-time link

00:10:45,040 --> 00:10:49,680
kernel community

00:10:46,800 --> 00:10:51,600
was in the scheduling latency but

00:10:49,680 --> 00:10:54,480
scheduling the latency even though it's

00:10:51,600 --> 00:10:55,120
a big part of the problem it's not the

00:10:54,480 --> 00:10:57,200
main goal

00:10:55,120 --> 00:10:59,279
the main goal is the response time of a

00:10:57,200 --> 00:11:00,000
task it's not when a test starts to run

00:10:59,279 --> 00:11:03,200
but when

00:11:00,000 --> 00:11:05,279
the test ends the computation and this

00:11:03,200 --> 00:11:07,519
involves other parts of the system

00:11:05,279 --> 00:11:08,640
like like scheduling and locking and

00:11:07,519 --> 00:11:12,959
then things get

00:11:08,640 --> 00:11:15,040
more complex but well

00:11:12,959 --> 00:11:17,120
we have an example of this integration

00:11:15,040 --> 00:11:19,279
and what else can we do right

00:11:17,120 --> 00:11:20,560
what what what is the the lesson learned

00:11:19,279 --> 00:11:23,200
with these this

00:11:20,560 --> 00:11:24,800
theory jointly in the prediction she

00:11:23,200 --> 00:11:26,079
should start from black should start

00:11:24,800 --> 00:11:28,000
from theory

00:11:26,079 --> 00:11:29,279
the points that you may find that it's

00:11:28,000 --> 00:11:32,800
not a chicken egg problem

00:11:29,279 --> 00:11:34,880
it's an evolution problem right

00:11:32,800 --> 00:11:36,320
we need we need to balance and bring new

00:11:34,880 --> 00:11:39,600
things from theory and mix

00:11:36,320 --> 00:11:42,959
it up with new new code and make things

00:11:39,600 --> 00:11:44,959
working together right

00:11:42,959 --> 00:11:46,959
is there a way is there any evidence

00:11:44,959 --> 00:11:49,600
that this is possible

00:11:46,959 --> 00:11:50,320
giving that the linux kernel moves fast

00:11:49,600 --> 00:11:53,519
and that

00:11:50,320 --> 00:11:55,600
you're there or or that does does little

00:11:53,519 --> 00:11:59,120
external developers care that much

00:11:55,600 --> 00:12:02,320
about it right and here we have another

00:11:59,120 --> 00:12:04,320
example with migrate disable so my great

00:12:02,320 --> 00:12:05,839
disable is a synchronization mechanism

00:12:04,320 --> 00:12:08,639
from the brain30

00:12:05,839 --> 00:12:11,279
that temporarily avoids a task to be

00:12:08,639 --> 00:12:14,240
migrated from one processor to another

00:12:11,279 --> 00:12:16,320
right it is good because it's a it

00:12:14,240 --> 00:12:19,200
avoids disabling the preemption

00:12:16,320 --> 00:12:19,600
that that causes the scheduling latency

00:12:19,200 --> 00:12:22,639
right

00:12:19,600 --> 00:12:23,519
that's why it's good in one hand on the

00:12:22,639 --> 00:12:25,760
flip side

00:12:23,519 --> 00:12:27,600
it breaks one assumption that we use on

00:12:25,760 --> 00:12:30,240
the schedulers which is being

00:12:27,600 --> 00:12:31,920
the working conserving like that line

00:12:30,240 --> 00:12:35,120
assumes it's working conservative

00:12:31,920 --> 00:12:37,200
or that is that the the m high guest uh

00:12:35,120 --> 00:12:39,600
trends will be able to run on the am

00:12:37,200 --> 00:12:41,600
processors of a system

00:12:39,600 --> 00:12:42,959
and and this created a discussion on

00:12:41,600 --> 00:12:46,079
lkml because

00:12:42,959 --> 00:12:47,519
uh some people were trying to to use

00:12:46,079 --> 00:12:49,760
migrate to disable all the

00:12:47,519 --> 00:12:51,120
no private rt kernel because it would

00:12:49,760 --> 00:12:52,959
facilitate their

00:12:51,120 --> 00:12:54,720
their lives on the other hand would

00:12:52,959 --> 00:12:55,519
create for us a problem on the

00:12:54,720 --> 00:12:59,680
scheduling

00:12:55,519 --> 00:13:02,720
uh subsystem and during this discussion

00:12:59,680 --> 00:13:03,279
one nice way was when peter came up with

00:13:02,720 --> 00:13:05,040
some

00:13:03,279 --> 00:13:07,600
some algorithm okay this is the

00:13:05,040 --> 00:13:09,120
algorithm i suggest to to allow us to to

00:13:07,600 --> 00:13:12,000
mitigate this problem

00:13:09,120 --> 00:13:12,720
we will create a tools to to find worst

00:13:12,000 --> 00:13:15,760
case

00:13:12,720 --> 00:13:17,920
and we will also try to update this with

00:13:15,760 --> 00:13:21,200
the theory that we are creating

00:13:17,920 --> 00:13:23,360
so that's a good example that we can uh

00:13:21,200 --> 00:13:24,240
go forward and continue trying to mix

00:13:23,360 --> 00:13:26,720
these uh

00:13:24,240 --> 00:13:27,920
these two words with the acceptance of

00:13:26,720 --> 00:13:29,600
the community as well

00:13:27,920 --> 00:13:31,920
right because the results are good at

00:13:29,600 --> 00:13:34,959
the end so

00:13:31,920 --> 00:13:39,680
where else do we need to put

00:13:34,959 --> 00:13:41,600
effort on this right uh

00:13:39,680 --> 00:13:43,199
one point is this cat deadline and you

00:13:41,600 --> 00:13:46,020
can check my presentation

00:13:43,199 --> 00:13:47,199
and with yuri last year at dev golf

00:13:46,020 --> 00:13:50,000
[Music]

00:13:47,199 --> 00:13:50,639
for example currently the the design of

00:13:50,000 --> 00:13:52,800
deadline

00:13:50,639 --> 00:13:55,279
uh doesn't allows tasks with different

00:13:52,800 --> 00:13:57,920
cpu masks to share a cpu

00:13:55,279 --> 00:14:00,320
right because a global scheduler but

00:13:57,920 --> 00:14:03,440
some perceptual trends need to run

00:14:00,320 --> 00:14:05,440
as cadet live for example uh

00:14:03,440 --> 00:14:07,279
we might need to boost some persecute

00:14:05,440 --> 00:14:10,399
threats like rcu

00:14:07,279 --> 00:14:13,839
for for a given time right so

00:14:10,399 --> 00:14:16,000
uh we we have this need

00:14:13,839 --> 00:14:17,600
of having arbitrary priority affinity on

00:14:16,000 --> 00:14:19,440
the linux curve

00:14:17,600 --> 00:14:20,720
we have some theories like the same

00:14:19,440 --> 00:14:23,360
partition or some

00:14:20,720 --> 00:14:23,920
level of dynamic partitioning that that

00:14:23,360 --> 00:14:27,440
could be

00:14:23,920 --> 00:14:32,079
useful for that but more resources

00:14:27,440 --> 00:14:34,320
is required another thing is that

00:14:32,079 --> 00:14:35,279
currently we ignore the overheads inside

00:14:34,320 --> 00:14:37,839
the systems

00:14:35,279 --> 00:14:40,079
right and also the methodology that we

00:14:37,839 --> 00:14:42,800
use to test scan deadline is basically

00:14:40,079 --> 00:14:43,600
informal we put some user space test to

00:14:42,800 --> 00:14:45,680
run

00:14:43,600 --> 00:14:46,880
and and see if they reply before the

00:14:45,680 --> 00:14:49,040
deadline

00:14:46,880 --> 00:14:51,040
but we don't try to understand what is

00:14:49,040 --> 00:14:53,839
going inside the operating system

00:14:51,040 --> 00:14:57,120
and this had led us to have problems in

00:14:53,839 --> 00:15:00,000
the past like with uh

00:14:57,120 --> 00:15:01,040
we've uh tasked with deadlines shorter

00:15:00,000 --> 00:15:04,480
than the period

00:15:01,040 --> 00:15:07,680
for example another point is that

00:15:04,480 --> 00:15:11,040
we've locked with proxy execution that

00:15:07,680 --> 00:15:11,440
is currently on the premier team we have

00:15:11,040 --> 00:15:14,000
the

00:15:11,440 --> 00:15:15,519
priority inversion protocol that that

00:15:14,000 --> 00:15:17,279
works like this if i have a highest

00:15:15,519 --> 00:15:18,240
priority thread waiting on a lower

00:15:17,279 --> 00:15:20,160
priority

00:15:18,240 --> 00:15:21,760
this lower priority will inherit the

00:15:20,160 --> 00:15:24,839
priority of the high guest

00:15:21,760 --> 00:15:26,000
to avoid a task with a mid priority to

00:15:24,839 --> 00:15:28,240
postponing

00:15:26,000 --> 00:15:30,480
all this batch of multi-seconds of

00:15:28,240 --> 00:15:34,399
people depending on the lock

00:15:30,480 --> 00:15:37,040
so this this algorithm it works

00:15:34,399 --> 00:15:38,160
for single processors for fixed priority

00:15:37,040 --> 00:15:39,839
schedulers

00:15:38,160 --> 00:15:41,920
like the firefighter scheduler but not

00:15:39,839 --> 00:15:44,000
for it was not designed like

00:15:41,920 --> 00:15:45,759
for multiple cores and neither designed

00:15:44,000 --> 00:15:48,000
for uh

00:15:45,759 --> 00:15:49,839
deadline based schedulers right this

00:15:48,000 --> 00:15:51,120
protocol was later extended with a

00:15:49,839 --> 00:15:52,959
deadline inheritance

00:15:51,120 --> 00:15:54,320
but it has some new issues and you can

00:15:52,959 --> 00:15:55,279
check it out on the presentation last

00:15:54,320 --> 00:15:57,360
year

00:15:55,279 --> 00:15:59,440
there is this initiative that is

00:15:57,360 --> 00:16:02,560
implementing proxy execution

00:15:59,440 --> 00:16:04,639
uh that is promising

00:16:02,560 --> 00:16:05,600
it's a good mechanism but you still need

00:16:04,639 --> 00:16:10,320
some kind of

00:16:05,600 --> 00:16:14,079
background to to get some corner cases

00:16:10,320 --> 00:16:14,079
and so on

00:16:14,240 --> 00:16:18,399
no this presentation was faster than i

00:16:16,240 --> 00:16:21,519
thought so my final remarks

00:16:18,399 --> 00:16:25,759
are okay

00:16:21,519 --> 00:16:28,959
well we had a lot of progress

00:16:25,759 --> 00:16:32,399
in the real-time linux as a community

00:16:28,959 --> 00:16:34,720
and last year's right or last decade

00:16:32,399 --> 00:16:37,440
even we were getting old

00:16:34,720 --> 00:16:40,959
so we have the bread party we have scat

00:16:37,440 --> 00:16:44,480
deadline we have lots of tools

00:16:40,959 --> 00:16:47,759
and uh most importantly

00:16:44,480 --> 00:16:50,000
in the last years we've been seeing this

00:16:47,759 --> 00:16:50,800
need of of livingston safe critical

00:16:50,000 --> 00:16:54,160
systems and

00:16:50,800 --> 00:16:56,240
now the automotive is not known or door

00:16:54,160 --> 00:16:57,680
uh but but there is even more there is

00:16:56,240 --> 00:16:59,600
industry 4.0

00:16:57,680 --> 00:17:01,519
there is the edge computing there is

00:16:59,600 --> 00:17:02,959
also the low latency user case that we

00:17:01,519 --> 00:17:05,839
are at support

00:17:02,959 --> 00:17:07,919
right so these are demanding more

00:17:05,839 --> 00:17:10,799
sophisticated analysis

00:17:07,919 --> 00:17:12,000
right but for us to be able to give

00:17:10,799 --> 00:17:14,319
better response

00:17:12,000 --> 00:17:15,760
for for the requests for example from

00:17:14,319 --> 00:17:19,199
our customers

00:17:15,760 --> 00:17:20,160
but also to to create this evidence that

00:17:19,199 --> 00:17:22,160
will enable

00:17:20,160 --> 00:17:23,360
real-time learners to go further to to

00:17:22,160 --> 00:17:25,039
get new markets

00:17:23,360 --> 00:17:27,199
that require these this more

00:17:25,039 --> 00:17:29,919
sophisticated kind of evidences

00:17:27,199 --> 00:17:30,840
and documentation that show that works

00:17:29,919 --> 00:17:34,000
fine

00:17:30,840 --> 00:17:36,880
right and uh

00:17:34,000 --> 00:17:38,799
the difference between us and the these

00:17:36,880 --> 00:17:39,840
older real-time operating system that

00:17:38,799 --> 00:17:42,160
sometimes

00:17:39,840 --> 00:17:44,840
were designed to be real-time operating

00:17:42,160 --> 00:17:49,120
systems since the beginning that where

00:17:44,840 --> 00:17:51,760
the design with uh certification

00:17:49,120 --> 00:17:52,640
on the mind to target in the and to get

00:17:51,760 --> 00:17:55,360
certification

00:17:52,640 --> 00:17:56,720
for this kind of applications right

00:17:55,360 --> 00:18:00,160
linux linux was not

00:17:56,720 --> 00:18:03,520
signed that way and uh but still

00:18:00,160 --> 00:18:05,120
we can we can find a way to make to give

00:18:03,520 --> 00:18:07,120
these evidences

00:18:05,120 --> 00:18:08,320
uh based on the things that we already

00:18:07,120 --> 00:18:09,919
have

00:18:08,320 --> 00:18:12,799
and the scheduling and real-time

00:18:09,919 --> 00:18:15,280
community it's well receptive

00:18:12,799 --> 00:18:17,280
for this more theoretical like work

00:18:15,280 --> 00:18:20,320
because if they actually make our lives

00:18:17,280 --> 00:18:22,559
easier at the end right and it avoids us

00:18:20,320 --> 00:18:25,720
to facing problems in the future because

00:18:22,559 --> 00:18:28,559
we didn't take in consideration this

00:18:25,720 --> 00:18:31,039
disgrace that the academics are doing

00:18:28,559 --> 00:18:31,760
right and and we have learned how to

00:18:31,039 --> 00:18:35,919
deal with

00:18:31,760 --> 00:18:38,559
it now so yeah that's it thank you all

00:18:35,919 --> 00:18:39,520
uh i have a lot of support from research

00:18:38,559 --> 00:18:42,400
people so please

00:18:39,520 --> 00:18:43,919
check the the research book there are

00:18:42,400 --> 00:18:47,039
nice people and feel free to

00:18:43,919 --> 00:18:49,360
to talk to me about research as well and

00:18:47,039 --> 00:18:52,400
that's it

00:18:49,360 --> 00:18:53,120
we have a actually we have uh two

00:18:52,400 --> 00:18:56,480
questions

00:18:53,120 --> 00:18:59,520
the first is from caroline

00:18:56,480 --> 00:19:02,880
what about real time on

00:18:59,520 --> 00:19:06,160
arma okay

00:19:02,880 --> 00:19:08,400
each arm board has its own

00:19:06,160 --> 00:19:09,600
set of problems that are derivated from

00:19:08,400 --> 00:19:12,640
the board support

00:19:09,600 --> 00:19:16,160
package right some have a

00:19:12,640 --> 00:19:18,640
drivers upstream some doesn't so

00:19:16,160 --> 00:19:20,160
assuming that the hardware is upstream

00:19:18,640 --> 00:19:23,200
support is upstream

00:19:20,160 --> 00:19:26,240
there's no problem right

00:19:23,200 --> 00:19:30,080
the the primitives of the preempt rt

00:19:26,240 --> 00:19:31,600
they are all architecture independent

00:19:30,080 --> 00:19:33,440
there might be now some glue on

00:19:31,600 --> 00:19:35,039
architectural dependent code to make it

00:19:33,440 --> 00:19:38,240
work but

00:19:35,039 --> 00:19:40,080
uh it's not necessarily part of the

00:19:38,240 --> 00:19:41,440
the core of the real-time features

00:19:40,080 --> 00:19:42,559
they're they're mostly all hardware

00:19:41,440 --> 00:19:46,080
independent

00:19:42,559 --> 00:19:49,360
so yes limit primarity on arm

00:19:46,080 --> 00:19:52,080
it works arma people

00:19:49,360 --> 00:19:52,640
are the people that work on arm they

00:19:52,080 --> 00:19:55,360
they

00:19:52,640 --> 00:19:57,039
support the development of prematurity

00:19:55,360 --> 00:20:00,799
and these kernel features

00:19:57,039 --> 00:20:02,640
so yeah it works and and we are

00:20:00,799 --> 00:20:04,559
ready assuming that the virtual

00:20:02,640 --> 00:20:08,640
participants upstream or that

00:20:04,559 --> 00:20:11,520
it works for you okay

00:20:08,640 --> 00:20:12,640
thank you for the reply we have a more

00:20:11,520 --> 00:20:16,320
question for you

00:20:12,640 --> 00:20:20,080
so get ready alexander

00:20:16,320 --> 00:20:24,000
is making more deeply more technically

00:20:20,080 --> 00:20:26,320
i don't know if you are able to uh

00:20:24,000 --> 00:20:27,840
okay he's pointing out that some part of

00:20:26,320 --> 00:20:31,440
the camera for instance

00:20:27,840 --> 00:20:36,880
transparent huge stables are currently

00:20:31,440 --> 00:20:36,880
not compatible with real time

00:20:36,960 --> 00:20:41,600
and is asking if this blocker for

00:20:40,080 --> 00:20:45,440
upscaling

00:20:41,600 --> 00:20:48,320
preempt rt yeah so

00:20:45,440 --> 00:20:50,559
the last question first no it's not a

00:20:48,320 --> 00:20:53,760
blocker for the prime parity upstream

00:20:50,559 --> 00:20:56,640
it's now it's not the disabled for

00:20:53,760 --> 00:20:57,440
all the case it's disabled on or kernel

00:20:56,640 --> 00:21:00,559
because

00:20:57,440 --> 00:21:00,960
it might hold the the virtual memory

00:21:00,559 --> 00:21:03,520
lock

00:21:00,960 --> 00:21:05,600
same for for too long and there are some

00:21:03,520 --> 00:21:06,559
use cases of people that

00:21:05,600 --> 00:21:09,360
because of the way that their

00:21:06,559 --> 00:21:12,159
applications were designed this caused

00:21:09,360 --> 00:21:15,520
a non-determinism because it's not

00:21:12,159 --> 00:21:18,559
because of the brand rt it's because the

00:21:15,520 --> 00:21:19,679
the virtual memory semaphore it's a huge

00:21:18,559 --> 00:21:22,880
kernel lock

00:21:19,679 --> 00:21:25,440
and can cause this kind of of uh

00:21:22,880 --> 00:21:27,440
issues again it's not prime trees just

00:21:25,440 --> 00:21:29,120
because it's a big kernel block

00:21:27,440 --> 00:21:31,679
it's been quite a while that people are

00:21:29,120 --> 00:21:33,919
trying to find a way to improve it

00:21:31,679 --> 00:21:34,720
it's not easy so yes the transparent

00:21:33,919 --> 00:21:37,760
huge page

00:21:34,720 --> 00:21:40,080
is is disabled also

00:21:37,760 --> 00:21:41,600
this kind of uh heuristic work is

00:21:40,080 --> 00:21:43,600
generally not required

00:21:41,600 --> 00:21:44,960
that much for many users on the printer

00:21:43,600 --> 00:21:46,799
t because they actually

00:21:44,960 --> 00:21:48,400
like to reserve their research by

00:21:46,799 --> 00:21:49,919
themselves manually instead of trying to

00:21:48,400 --> 00:21:53,039
use some risks like the

00:21:49,919 --> 00:21:53,039
transparent huge base

00:21:54,480 --> 00:21:58,320
thank you actually there are a lot of

00:21:56,799 --> 00:22:01,760
questions i'm trying to go

00:21:58,320 --> 00:22:02,080
one by one the most voted one it will be

00:22:01,760 --> 00:22:05,919
the

00:22:02,080 --> 00:22:08,559
next one and that is from willian uh

00:22:05,919 --> 00:22:10,400
has there been interest from the new

00:22:08,559 --> 00:22:13,760
automotive engineering

00:22:10,400 --> 00:22:17,440
effort to using the real-time camera

00:22:13,760 --> 00:22:21,120
yes yes mainly for the

00:22:17,440 --> 00:22:21,120
requirements of six criticals

00:22:22,880 --> 00:22:29,039
looking forward and next is

00:22:26,000 --> 00:22:32,559
from daniel i see a need

00:22:29,039 --> 00:22:35,840
for real-time workload inside the kvm

00:22:32,559 --> 00:22:39,200
virtual machine what's your take

00:22:35,840 --> 00:22:42,559
on that it works

00:22:39,200 --> 00:22:45,600
we have we there is

00:22:42,559 --> 00:22:48,880
even a team on red hat luis capitolino

00:22:45,600 --> 00:22:50,720
is the head of the team that we have

00:22:48,880 --> 00:22:54,240
been working as a team

00:22:50,720 --> 00:22:57,679
for three or four years already

00:22:54,240 --> 00:22:58,640
making the kvmrt and the carnarity

00:22:57,679 --> 00:23:01,360
working together

00:22:58,640 --> 00:23:02,559
well we have good results but still it's

00:23:01,360 --> 00:23:06,159
just being applied for

00:23:02,559 --> 00:23:09,440
a single use case which is telco

00:23:06,159 --> 00:23:12,240
and the results are quite impressive uh

00:23:09,440 --> 00:23:13,679
but i advise talk to louise about uh it

00:23:12,240 --> 00:23:16,000
is more okay

00:23:13,679 --> 00:23:16,880
uh these other needs other than than

00:23:16,000 --> 00:23:20,320
telco with

00:23:16,880 --> 00:23:22,559
the cave mrt so luis can can

00:23:20,320 --> 00:23:24,960
can give you more business-like answer

00:23:22,559 --> 00:23:24,960
for this

00:23:25,200 --> 00:23:28,720
good thank you it's going to hear about

00:23:27,840 --> 00:23:32,640
this

00:23:28,720 --> 00:23:36,520
we have uh also one question from

00:23:32,640 --> 00:23:40,000
varan what about smi's

00:23:36,520 --> 00:23:42,799
x86 or honey under hypervisor

00:23:40,000 --> 00:23:45,120
does a preempter of the determinist

00:23:42,799 --> 00:23:47,520
still hold

00:23:45,120 --> 00:23:48,720
yes and also it's a good point because

00:23:47,520 --> 00:23:51,360
the smi

00:23:48,720 --> 00:23:52,799
looks like a hyper like if the bare

00:23:51,360 --> 00:23:56,480
metal becomes a

00:23:52,799 --> 00:23:59,760
hypervisor right we have a

00:23:56,480 --> 00:24:01,679
something on a lower level that stalls

00:23:59,760 --> 00:24:04,559
the operating system that runs on top

00:24:01,679 --> 00:24:05,840
of it right it does not change the way

00:24:04,559 --> 00:24:07,440
that the preemptivity

00:24:05,840 --> 00:24:09,679
works the preparation is still

00:24:07,440 --> 00:24:11,200
deterministic it's just that you need to

00:24:09,679 --> 00:24:14,480
account this interference

00:24:11,200 --> 00:24:18,400
from the lower level uh layer

00:24:14,480 --> 00:24:21,760
right so if your smis run for like uh

00:24:18,400 --> 00:24:23,600
10 microseconds and still these 10

00:24:21,760 --> 00:24:25,279
microseconds on top of the latency of

00:24:23,600 --> 00:24:27,600
the prem 30

00:24:25,279 --> 00:24:30,000
doesn't cause you a failure or if it's

00:24:27,600 --> 00:24:33,120
still good for you

00:24:30,000 --> 00:24:33,919
it's okay right it's just yet another

00:24:33,120 --> 00:24:37,360
workload

00:24:33,919 --> 00:24:38,960
so it does not affect the param30 model

00:24:37,360 --> 00:24:40,400
it just affects the results that you

00:24:38,960 --> 00:24:42,240
achieve on that architecture

00:24:40,400 --> 00:24:47,679
but if it's if it's a hardware or if

00:24:42,240 --> 00:24:50,720
it's a virtual machine

00:24:47,679 --> 00:24:54,880
okay i i caroline what is missing to

00:24:50,720 --> 00:24:54,880
make linux save critical for automotive

00:24:55,360 --> 00:24:58,880
lots of things lots of things

00:24:57,679 --> 00:25:02,480
standardization

00:24:58,880 --> 00:25:04,159
uh creating more evidences trying to

00:25:02,480 --> 00:25:05,600
understand what are the evidence that we

00:25:04,159 --> 00:25:07,520
need to create

00:25:05,600 --> 00:25:09,919
and there is an effort now i try to have

00:25:07,520 --> 00:25:13,440
to try to to figure this out

00:25:09,919 --> 00:25:17,760
uh we will that happen yes

00:25:13,440 --> 00:25:18,640
for sure for sure as to the 40s on

00:25:17,760 --> 00:25:21,919
issues okay

00:25:18,640 --> 00:25:24,880
the 40s is another thing right

00:25:21,919 --> 00:25:25,760
uh linux will probably be used on safe

00:25:24,880 --> 00:25:28,240
critical

00:25:25,760 --> 00:25:29,120
right but some a low level of

00:25:28,240 --> 00:25:32,400
criticality

00:25:29,120 --> 00:25:34,799
now right it will not control brakes it

00:25:32,400 --> 00:25:37,279
will not control the steering wheel

00:25:34,799 --> 00:25:38,640
but it can control like dashboards or

00:25:37,279 --> 00:25:41,679
other things that require

00:25:38,640 --> 00:25:45,360
uh timing and safety but

00:25:41,679 --> 00:25:47,840
but it's still the the asu

00:25:45,360 --> 00:25:49,760
b level which is the suv is something

00:25:47,840 --> 00:25:52,799
that is more complex

00:25:49,760 --> 00:25:54,799
but anyways there's no need for linux to

00:25:52,799 --> 00:25:56,159
be the default os

00:25:54,799 --> 00:25:58,159
there is a lot of problems to be

00:25:56,159 --> 00:26:00,720
resolved i hope in the future we can

00:25:58,159 --> 00:26:02,159
achieve such a level of of confidence

00:26:00,720 --> 00:26:06,880
and results right

00:26:02,159 --> 00:26:06,880
it will take some time i think personal

00:26:07,159 --> 00:26:10,159

YouTube URL: https://www.youtube.com/watch?v=0_AlWX8EFAk


