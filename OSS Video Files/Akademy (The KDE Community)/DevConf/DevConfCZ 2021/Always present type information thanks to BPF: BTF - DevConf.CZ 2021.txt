Title: Always present type information thanks to BPF: BTF - DevConf.CZ 2021
Publication date: 2021-03-14
Playlist: DevConfCZ 2021
Description: 
	Speaker: Arnaldo Melo


The presence of compact type information brought initially by the needs of BPF allows for more and more tools to use it seamlessly.

This talk will show what has been accomplished so far in the BTF (BPF Type
Information) camp, from improvements in its generation from DWARF, overcoming compiler bugs and speeding up the tool used to encode the kernel BTF information, pahole.

The kernel now has all its types always available at /sys/kernel/btf/vmlinux
and at devconf.cz 2021 time all its modules will be in that sysfs hierarchy
with the advent of split BTF.

The new raw pretty printing features of pahole will be demonstrated, where
things like raw arrays of structs can be fed to it plus the type name to use in
decoding stdin, all sorts of heuristics and back references are used to grok
complex data files.

The kernel also now have snprintf routines that use BTF for use in debugging
and tracing, bpftrace and bpftool use it and examples of such usage will be
shown. 


Schedule: https://sched.co/gmLF
Captions: 
	00:00:01,199 --> 00:00:07,200
my name is ronaldo cavale de mello i

00:00:04,160 --> 00:00:11,599
work for red hat for

00:00:07,200 --> 00:00:14,160
the last uh 14 years from brazil

00:00:11,599 --> 00:00:14,880
and i presented several times at devkov

00:00:14,160 --> 00:00:17,840
but

00:00:14,880 --> 00:00:19,119
always in brno not not like this now

00:00:17,840 --> 00:00:22,240
without seeing anybody

00:00:19,119 --> 00:00:26,400
which is really strange but let's try it

00:00:22,240 --> 00:00:30,000
uh this is about uh a

00:00:26,400 --> 00:00:34,320
so this is about the bpf type format

00:00:30,000 --> 00:00:37,920
which is a a format for encoding

00:00:34,320 --> 00:00:40,320
types like c types the kernel types like

00:00:37,920 --> 00:00:42,239
uh kernel data structures user space

00:00:40,320 --> 00:00:43,200
data structures kernel api data

00:00:42,239 --> 00:00:46,879
structures

00:00:43,200 --> 00:00:49,520
et cetera it came from the bpf subsystem

00:00:46,879 --> 00:00:50,960
which is not really the main topic for

00:00:49,520 --> 00:00:54,640
this presentation but

00:00:50,960 --> 00:00:58,160
it gave us uh btf which is a

00:00:54,640 --> 00:01:01,199
very compact form of representing types

00:00:58,160 --> 00:01:04,239
which uh ends up as a fraction of the

00:01:01,199 --> 00:01:07,520
dwarf which is another type information

00:01:04,239 --> 00:01:10,880
but it as well has a a fraction of

00:01:07,520 --> 00:01:12,159
what is contained in dwarf all the tools

00:01:10,880 --> 00:01:15,520
besides the

00:01:12,159 --> 00:01:18,400
bpf ecosystem use it as well

00:01:15,520 --> 00:01:19,040
for instance uh you can use in the

00:01:18,400 --> 00:01:22,720
kernel

00:01:19,040 --> 00:01:26,560
uh to have a print k

00:01:22,720 --> 00:01:28,560
let's say or some ascent printf that

00:01:26,560 --> 00:01:30,400
you pass a pointer and you specify

00:01:28,560 --> 00:01:33,520
what's the type for this pointer

00:01:30,400 --> 00:01:36,560
and it will instead of printing just a

00:01:33,520 --> 00:01:37,520
integer or a string it will print the

00:01:36,560 --> 00:01:40,560
whole type like

00:01:37,520 --> 00:01:45,439
you do on tools like gdb

00:01:40,560 --> 00:01:49,520
or crash and things like that so and um

00:01:45,439 --> 00:01:52,079
and i will show a a something i did

00:01:49,520 --> 00:01:54,960
uh where she uses this information to do

00:01:52,079 --> 00:01:57,680
the predict printing of raw data

00:01:54,960 --> 00:01:59,840
arbitrary data uh using the btf type

00:01:57,680 --> 00:02:03,040
information that is available

00:01:59,840 --> 00:02:06,000
now in the kernel so where is it

00:02:03,040 --> 00:02:06,960
in the kernel in the kernel you have a

00:02:06,000 --> 00:02:10,479
new

00:02:06,960 --> 00:02:11,200
cfs file called the c scanner btf vm

00:02:10,479 --> 00:02:14,400
linux

00:02:11,200 --> 00:02:17,040
and uh all the ties for the camera all

00:02:14,400 --> 00:02:18,160
i don't know how many i i i said

00:02:17,040 --> 00:02:20,560
thousands of times

00:02:18,160 --> 00:02:21,599
uh they are all there you can get full

00:02:20,560 --> 00:02:23,840
information about it

00:02:21,599 --> 00:02:24,800
all the the the name of the data

00:02:23,840 --> 00:02:27,920
structures

00:02:24,800 --> 00:02:30,560
enumerations everything and uh

00:02:27,920 --> 00:02:31,760
more recently we have it available as

00:02:30,560 --> 00:02:34,319
well for

00:02:31,760 --> 00:02:35,519
kernel modules with a feature called

00:02:34,319 --> 00:02:39,200
split btf

00:02:35,519 --> 00:02:42,160
which will come true so what is in there

00:02:39,200 --> 00:02:43,519
all current types both the kernel api

00:02:42,160 --> 00:02:45,360
which is set in stone

00:02:43,519 --> 00:02:47,120
so it's something that was defined at

00:02:45,360 --> 00:02:49,599
some at

00:02:47,120 --> 00:02:50,400
some time in the past and then we can

00:02:49,599 --> 00:02:53,760
change it

00:02:50,400 --> 00:02:57,280
or we can perhaps add some

00:02:53,760 --> 00:02:59,440
new field but while keeping the existing

00:02:57,280 --> 00:03:02,640
ones with the same semantics

00:02:59,440 --> 00:03:04,800
and that the same at the same offsets

00:03:02,640 --> 00:03:07,360
from the start of the data structure

00:03:04,800 --> 00:03:08,159
and we have as well kernel internals

00:03:07,360 --> 00:03:11,440
which are

00:03:08,159 --> 00:03:13,519
always in flux like the internal

00:03:11,440 --> 00:03:14,800
kernel data structure that represents a

00:03:13,519 --> 00:03:18,319
task or a

00:03:14,800 --> 00:03:21,280
socket buffer or the what

00:03:18,319 --> 00:03:23,040
represents a block device or things like

00:03:21,280 --> 00:03:25,680
that inside the kernel that

00:03:23,040 --> 00:03:26,480
uh they are not uh covered by the kernel

00:03:25,680 --> 00:03:29,599
api

00:03:26,480 --> 00:03:30,720
uh sometimes for companies like ours for

00:03:29,599 --> 00:03:34,799
red hat we

00:03:30,720 --> 00:03:38,080
have some extended kernel api

00:03:34,799 --> 00:03:40,490
where we guarantee that even internal

00:03:38,080 --> 00:03:42,080
data structures don't change

00:03:40,490 --> 00:03:46,159
[Music]

00:03:42,080 --> 00:03:49,440
like things that are in the upstream or

00:03:46,159 --> 00:03:52,720
community uh kernel api so let's see

00:03:49,440 --> 00:03:54,959
uh with the these

00:03:52,720 --> 00:03:56,080
there is a tool which i wrote long ago

00:03:54,959 --> 00:03:59,519
uh which

00:03:56,080 --> 00:04:02,560
can consume uh both vtf and

00:03:59,519 --> 00:04:05,760
dwarf so you have this

00:04:02,560 --> 00:04:08,080
uh the name is paho which i i will

00:04:05,760 --> 00:04:11,280
explain a little bit about it

00:04:08,080 --> 00:04:14,560
later and uh but

00:04:11,280 --> 00:04:15,040
if you just say piho rw lock underscore

00:04:14,560 --> 00:04:17,120
t

00:04:15,040 --> 00:04:18,720
what you are asking for this data

00:04:17,120 --> 00:04:22,000
structure

00:04:18,720 --> 00:04:24,479
be it a enumeration be it a

00:04:22,000 --> 00:04:25,680
union or a struct or a type therefore

00:04:24,479 --> 00:04:28,800
whatever

00:04:25,680 --> 00:04:29,440
and cco don't specify where to get this

00:04:28,800 --> 00:04:31,840
information

00:04:29,440 --> 00:04:33,280
it will look first at the btf

00:04:31,840 --> 00:04:36,320
information which

00:04:33,280 --> 00:04:37,919
nowadays uh is present on most

00:04:36,320 --> 00:04:39,120
distributions if you look at your system

00:04:37,919 --> 00:04:42,240
right now and it's

00:04:39,120 --> 00:04:46,000
up to date then you're gonna see

00:04:42,240 --> 00:04:48,160
it on that location that i specified so

00:04:46,000 --> 00:04:49,280
it will get this information and will

00:04:48,160 --> 00:04:51,600
reconstruct

00:04:49,280 --> 00:04:53,520
the data structure on the screen in a

00:04:51,600 --> 00:04:55,199
way that is even compilable

00:04:53,520 --> 00:04:56,800
and it will provide several for extra

00:04:55,199 --> 00:04:58,720
information like its size

00:04:56,800 --> 00:05:00,240
how many cache lines it uses how many

00:04:58,720 --> 00:05:03,199
members

00:05:00,240 --> 00:05:05,039
what's the number of bytes in the last

00:05:03,199 --> 00:05:08,000
cache line this is interesting

00:05:05,039 --> 00:05:08,000
for developers

00:05:08,320 --> 00:05:12,080
so it started for looking at strict

00:05:11,520 --> 00:05:14,320
holes

00:05:12,080 --> 00:05:15,520
so you you get the kernel get the gun

00:05:14,320 --> 00:05:17,039
has thousands of

00:05:15,520 --> 00:05:18,560
uh data structures and these data

00:05:17,039 --> 00:05:21,520
structures have

00:05:18,560 --> 00:05:22,639
lots of members if you are not careful

00:05:21,520 --> 00:05:26,320
you can end up

00:05:22,639 --> 00:05:30,080
with alignment spaces between

00:05:26,320 --> 00:05:33,680
uh data members in the data structure

00:05:30,080 --> 00:05:36,240
that if you are careful enough

00:05:33,680 --> 00:05:38,080
and reorganize the digital structure you

00:05:36,240 --> 00:05:41,350
can make it smaller

00:05:38,080 --> 00:05:43,280
it can consume less

00:05:41,350 --> 00:05:46,160
[Music]

00:05:43,280 --> 00:05:47,680
less memory less cache lines and you can

00:05:46,160 --> 00:05:50,800
make the kernel faster

00:05:47,680 --> 00:05:54,400
for things like uh

00:05:50,800 --> 00:05:58,160
network packet socket buffers

00:05:54,400 --> 00:06:01,280
or for the what represents a

00:05:58,160 --> 00:06:04,639
a data uh coming

00:06:01,280 --> 00:06:07,759
to and from a file on a disk

00:06:04,639 --> 00:06:11,440
so but this name is strange so

00:06:07,759 --> 00:06:14,800
let's call it another name so we can use

00:06:11,440 --> 00:06:17,440
a li eliases in the uh shell

00:06:14,800 --> 00:06:18,080
and the you know command interpreter and

00:06:17,440 --> 00:06:21,199
you say

00:06:18,080 --> 00:06:22,560
no when you call type death it's the

00:06:21,199 --> 00:06:24,319
same thing as poho

00:06:22,560 --> 00:06:26,240
and they say struct is the same thing as

00:06:24,319 --> 00:06:29,600
p whole i'm going to say union

00:06:26,240 --> 00:06:31,600
or num and then you can do

00:06:29,600 --> 00:06:34,080
instead of here hold er double lock t

00:06:31,600 --> 00:06:36,080
you do it very naturally like type def

00:06:34,080 --> 00:06:37,840
air double lock t and then you get the

00:06:36,080 --> 00:06:38,800
type that this type that that you're

00:06:37,840 --> 00:06:40,720
asking for

00:06:38,800 --> 00:06:43,440
from the kernel that is running on your

00:06:40,720 --> 00:06:45,600
machine right now

00:06:43,440 --> 00:06:46,560
if you do a strapless head that

00:06:45,600 --> 00:06:49,599
represents

00:06:46,560 --> 00:06:52,639
uh one entry or the

00:06:49,599 --> 00:06:55,680
head of a linked list in the kernel then

00:06:52,639 --> 00:06:56,720
you get this other data structure let's

00:06:55,680 --> 00:06:59,440
see if you do

00:06:56,720 --> 00:07:02,080
enumerations if you do enum and then

00:06:59,440 --> 00:07:02,479
this this name perform type you're going

00:07:02,080 --> 00:07:05,199
to get

00:07:02,479 --> 00:07:05,599
the enumeration again in a way that you

00:07:05,199 --> 00:07:08,960
can

00:07:05,599 --> 00:07:11,120
even recompile or and build it on your

00:07:08,960 --> 00:07:12,240
on your source code and this is used in

00:07:11,120 --> 00:07:16,080
btf programs

00:07:12,240 --> 00:07:19,599
to when they are building uh

00:07:16,080 --> 00:07:21,919
uh bad code from the restricted c

00:07:19,599 --> 00:07:23,039
so and this enumeration will keep it in

00:07:21,919 --> 00:07:26,720
mind we're gonna use it

00:07:23,039 --> 00:07:29,039
later and when i meant

00:07:26,720 --> 00:07:30,160
all kernel types uh it's all kind of

00:07:29,039 --> 00:07:33,280
types and then

00:07:30,160 --> 00:07:36,560
uh you can then use this uh

00:07:33,280 --> 00:07:40,319
expand types uh option of

00:07:36,560 --> 00:07:41,520
p hold oh type def and then it will get

00:07:40,319 --> 00:07:44,560
that air double lock

00:07:41,520 --> 00:07:47,919
t which was like this

00:07:44,560 --> 00:07:50,479
like this and

00:07:47,919 --> 00:07:51,840
expand it all the way down and then you

00:07:50,479 --> 00:07:55,120
see that uh

00:07:51,840 --> 00:07:58,479
a arc rwt is in fact

00:07:55,120 --> 00:08:01,759
a strict keyword w lock which

00:07:58,479 --> 00:08:05,599
is in turn an union which has

00:08:01,759 --> 00:08:08,000
a atomic t an atomic d is

00:08:05,599 --> 00:08:08,720
in turn just an inter integer that is

00:08:08,000 --> 00:08:12,479
accessed

00:08:08,720 --> 00:08:14,479
using some special uh operations

00:08:12,479 --> 00:08:17,039
and then you go all the way down and you

00:08:14,479 --> 00:08:18,879
get the offsets from the start

00:08:17,039 --> 00:08:21,440
this can be used for when you are

00:08:18,879 --> 00:08:25,280
decoding uh

00:08:21,440 --> 00:08:27,599
kernel ops or that you want to know what

00:08:25,280 --> 00:08:28,720
is that some offset on a complex data

00:08:27,599 --> 00:08:32,080
structure full of

00:08:28,720 --> 00:08:35,120
substructures but okay let's continue

00:08:32,080 --> 00:08:38,240
split btf uh split ptf

00:08:35,120 --> 00:08:41,519
uh is for kernel models uh so

00:08:38,240 --> 00:08:43,440
the the kernel module btf which has the

00:08:41,519 --> 00:08:44,880
types that are exclusive to this

00:08:43,440 --> 00:08:47,920
specific kernel model

00:08:44,880 --> 00:08:49,600
refers to the kernel btf information so

00:08:47,920 --> 00:08:52,560
that it doesn't duplicate it

00:08:49,600 --> 00:08:54,480
it's available since behold version 1.19

00:08:52,560 --> 00:08:57,040
and the kernel 5.11

00:08:54,480 --> 00:08:57,680
the last one so it's not yet enabling

00:08:57,040 --> 00:09:01,120
things like

00:08:57,680 --> 00:09:02,000
fedora you have k-config variables for

00:09:01,120 --> 00:09:04,080
that

00:09:02,000 --> 00:09:05,120
uh this kernel specifically was built

00:09:04,080 --> 00:09:08,399
with clang

00:09:05,120 --> 00:09:11,200
and it works as well so

00:09:08,399 --> 00:09:13,760
when you look go to that directory the c

00:09:11,200 --> 00:09:15,600
scanner btf instead of just the vm linux

00:09:13,760 --> 00:09:18,880
you have one per module

00:09:15,600 --> 00:09:22,240
okay and then what's in there

00:09:18,880 --> 00:09:26,160
you have uh you call

00:09:22,240 --> 00:09:28,560
piero acp acp ipad specifying this

00:09:26,160 --> 00:09:30,160
acpi underscore pad as the name of the

00:09:28,560 --> 00:09:33,200
file that you want to bring

00:09:30,160 --> 00:09:34,320
all the types it didn't work because you

00:09:33,200 --> 00:09:36,720
didn't specify

00:09:34,320 --> 00:09:39,120
what is the base btf so you have to do

00:09:36,720 --> 00:09:42,240
this btf base

00:09:39,120 --> 00:09:45,279
uh acpi pad and then it

00:09:42,240 --> 00:09:47,040
gets the the the first the first data

00:09:45,279 --> 00:09:50,640
structure that is specific to this

00:09:47,040 --> 00:09:52,640
uh canon model okay if you do it like

00:09:50,640 --> 00:09:55,440
this be a hole in this specified

00:09:52,640 --> 00:09:57,680
this prefix here then it does everything

00:09:55,440 --> 00:09:57,920
for you it specifies the bases dm linux

00:09:57,680 --> 00:10:00,959
and

00:09:57,920 --> 00:10:04,000
goes on okay can i do more okay

00:10:00,959 --> 00:10:06,880
we can do more uh using playing

00:10:04,000 --> 00:10:08,399
structure is powerful you you now you

00:10:06,880 --> 00:10:09,680
want to see a current data structure

00:10:08,399 --> 00:10:11,440
just say structure and you get

00:10:09,680 --> 00:10:13,120
the current data search for developers

00:10:11,440 --> 00:10:14,240
for reconstructing type no need for

00:10:13,120 --> 00:10:16,320
kernel headers

00:10:14,240 --> 00:10:19,120
you can uh instead of using kernel

00:10:16,320 --> 00:10:21,760
headers to build some thing that will

00:10:19,120 --> 00:10:22,959
ultimately be turned into a binary and

00:10:21,760 --> 00:10:24,640
get into the kernel

00:10:22,959 --> 00:10:26,000
you just use the this type of

00:10:24,640 --> 00:10:29,839
information that's

00:10:26,000 --> 00:10:32,880
available on every machine

00:10:29,839 --> 00:10:35,760
it matches the running carno some more

00:10:32,880 --> 00:10:37,920
then that's the the part that i i uh

00:10:35,760 --> 00:10:40,079
some extra utilizations there is a

00:10:37,920 --> 00:10:41,120
a co-worker red hatcher called joe

00:10:40,079 --> 00:10:43,040
lawrence his he

00:10:41,120 --> 00:10:44,640
he came to me and said behold knows

00:10:43,040 --> 00:10:46,800
about types

00:10:44,640 --> 00:10:47,920
he we need to extract modern versioning

00:10:46,800 --> 00:10:50,560
info

00:10:47,920 --> 00:10:52,399
in shell scripts it's related to work

00:10:50,560 --> 00:10:55,760
that we do in kernel live patching

00:10:52,399 --> 00:10:58,320
can you help i said sure uh

00:10:55,760 --> 00:11:00,320
let's try to do some pretty printing of

00:10:58,320 --> 00:11:04,079
raw data using type information

00:11:00,320 --> 00:11:07,279
to format std in the the standard

00:11:04,079 --> 00:11:09,920
input of of pi hold and let's support

00:11:07,279 --> 00:11:11,040
arrays and it's available in this

00:11:09,920 --> 00:11:13,440
version of vehicles

00:11:11,040 --> 00:11:14,079
okay so mod version info you get this

00:11:13,440 --> 00:11:16,560
information

00:11:14,079 --> 00:11:18,320
from a kernel driver which is compiled

00:11:16,560 --> 00:11:21,360
with this specific feature

00:11:18,320 --> 00:11:22,959
and then that's this is the data

00:11:21,360 --> 00:11:24,880
structure okay

00:11:22,959 --> 00:11:26,880
and then let's pretty print it we have

00:11:24,880 --> 00:11:31,120
to ex extract this

00:11:26,880 --> 00:11:34,560
using uh being you to use object copy

00:11:31,120 --> 00:11:35,680
get this versions section and output it

00:11:34,560 --> 00:11:38,640
to this version

00:11:35,680 --> 00:11:39,360
file the version file has this size and

00:11:38,640 --> 00:11:42,480
then

00:11:39,360 --> 00:11:46,079
you say print the first three

00:11:42,480 --> 00:11:49,120
entries on an array that starts at the

00:11:46,079 --> 00:11:53,279
at the offset zero of this

00:11:49,120 --> 00:11:56,800
versions file and get the information

00:11:53,279 --> 00:12:00,000
from the kernel module the type is this

00:11:56,800 --> 00:12:03,600
and we get this so yeah

00:12:00,000 --> 00:12:05,760
uh he seems satisfied uh what

00:12:03,600 --> 00:12:07,680
joe lawrence asked me so let's go to

00:12:05,760 --> 00:12:12,079
something else uh

00:12:07,680 --> 00:12:15,279
you you now get adi stuff like elf

00:12:12,079 --> 00:12:18,320
64 header from the kernel

00:12:15,279 --> 00:12:21,600
that's the definition of the type and so

00:12:18,320 --> 00:12:23,519
if we get some uh

00:12:21,600 --> 00:12:25,839
any binary like bing bash and then you

00:12:23,519 --> 00:12:27,680
say give me the first one

00:12:25,839 --> 00:12:29,040
and then it's the first one that's the

00:12:27,680 --> 00:12:31,680
header and then

00:12:29,040 --> 00:12:33,519
if you look at the at those numbers it

00:12:31,680 --> 00:12:36,560
will make sense

00:12:33,519 --> 00:12:40,000
and then for bcp as well

00:12:36,560 --> 00:12:42,720
and then case closet okay no

00:12:40,000 --> 00:12:43,279
let's add some more features dash dash

00:12:42,720 --> 00:12:45,279
header

00:12:43,279 --> 00:12:47,600
instead of saying that's the one counter

00:12:45,279 --> 00:12:51,519
you say that the header for this thing

00:12:47,600 --> 00:12:54,639
is elf 64 hdr and then it will stop

00:12:51,519 --> 00:12:56,560
there's just one hander okay so we can

00:12:54,639 --> 00:12:59,680
have as well head of variables

00:12:56,560 --> 00:13:00,800
so that field is in the header type that

00:12:59,680 --> 00:13:03,040
can be later

00:13:00,800 --> 00:13:04,480
referenced to the code ranges in the

00:13:03,040 --> 00:13:07,680
file for instance

00:13:04,480 --> 00:13:09,440
so the perf data header i i i

00:13:07,680 --> 00:13:10,959
maintain the pair of header the pep

00:13:09,440 --> 00:13:13,680
tools uh in the

00:13:10,959 --> 00:13:14,240
linux kernel so i was thinking yeah i

00:13:13,680 --> 00:13:17,680
may

00:13:14,240 --> 00:13:20,959
use this to to decode the apex

00:13:17,680 --> 00:13:23,360
data file so you have

00:13:20,959 --> 00:13:24,079
the the the magic number the size of the

00:13:23,360 --> 00:13:26,959
whole

00:13:24,079 --> 00:13:29,360
file so the information we need to see

00:13:26,959 --> 00:13:32,560
to get where to start decoding

00:13:29,360 --> 00:13:35,279
types like the attributes or the

00:13:32,560 --> 00:13:36,800
events are here or the offset the size

00:13:35,279 --> 00:13:40,800
etc okay

00:13:36,800 --> 00:13:44,079
so we go to uh to see the perfect header

00:13:40,800 --> 00:13:46,639
the event header it's a variable sized

00:13:44,079 --> 00:13:47,600
record you have a type which will

00:13:46,639 --> 00:13:49,760
specify

00:13:47,600 --> 00:13:52,000
how to decode this thing you have a misc

00:13:49,760 --> 00:13:54,399
which are flags and you have the size

00:13:52,000 --> 00:13:55,040
the variable size of record is specified

00:13:54,399 --> 00:13:57,760
here

00:13:55,040 --> 00:13:59,440
the kernel produces this and perf in the

00:13:57,760 --> 00:14:01,440
user space or any other

00:13:59,440 --> 00:14:02,560
program that uses the perf evan

00:14:01,440 --> 00:14:03,839
interface will

00:14:02,560 --> 00:14:05,760
use this information to know how to

00:14:03,839 --> 00:14:07,519
decode the information produced by the

00:14:05,760 --> 00:14:10,240
kernel

00:14:07,519 --> 00:14:10,800
so in in the perth tool when you specify

00:14:10,240 --> 00:14:12,800
here

00:14:10,800 --> 00:14:14,000
uh dash c performance header is the same

00:14:12,800 --> 00:14:18,560
thing as an avi

00:14:14,000 --> 00:14:20,959
uh perf can have this in a btf

00:14:18,560 --> 00:14:23,519
format or in uh dwarf form it doesn't

00:14:20,959 --> 00:14:26,240
matter but people can use both

00:14:23,519 --> 00:14:26,959
then where it uses variable sized

00:14:26,240 --> 00:14:29,519
records

00:14:26,959 --> 00:14:30,240
well and has well known member names

00:14:29,519 --> 00:14:33,360
like type

00:14:30,240 --> 00:14:36,160
and size which is good so

00:14:33,360 --> 00:14:36,160
if i say

00:14:36,959 --> 00:14:41,440
sig bytes which is an option to that

00:14:39,360 --> 00:14:44,480
offset

00:14:41,440 --> 00:14:47,600
and size bytes which is after this

00:14:44,480 --> 00:14:50,160
offset how many enter how many bytes

00:14:47,600 --> 00:14:52,079
are related to this specific per event

00:14:50,160 --> 00:14:54,399
header type

00:14:52,079 --> 00:14:55,440
and then i say give me the first four

00:14:54,399 --> 00:14:57,920
count four

00:14:55,440 --> 00:14:58,800
and then i say that the size of operator

00:14:57,920 --> 00:15:00,639
that will

00:14:58,800 --> 00:15:01,920
specify what is the size of this

00:15:00,639 --> 00:15:05,279
variable sized record

00:15:01,920 --> 00:15:05,920
is the size member inside the perth evan

00:15:05,279 --> 00:15:08,959
header

00:15:05,920 --> 00:15:11,600
type so it shows me the first four

00:15:08,959 --> 00:15:12,720
but then since there is no information

00:15:11,600 --> 00:15:14,800
here

00:15:12,720 --> 00:15:15,920
it's just an integer the best thing you

00:15:14,800 --> 00:15:19,120
can do

00:15:15,920 --> 00:15:23,760
is to show just numbers then

00:15:19,120 --> 00:15:23,760
if you go and tell something else

00:15:24,320 --> 00:15:28,160
to use header variables you can just

00:15:26,720 --> 00:15:30,720
reference like this header

00:15:28,160 --> 00:15:32,240
data offset and instead of hardcoding

00:15:30,720 --> 00:15:34,639
the number so it will

00:15:32,240 --> 00:15:35,600
use the header perform header get the

00:15:34,639 --> 00:15:38,160
information there

00:15:35,600 --> 00:15:39,040
from the perf data file and you get the

00:15:38,160 --> 00:15:41,360
same thing

00:15:39,040 --> 00:15:43,759
but then do you remember that

00:15:41,360 --> 00:15:46,639
enumeration perfect evan type

00:15:43,759 --> 00:15:47,040
oh take a look at this specific one the

00:15:46,639 --> 00:15:50,240
perf

00:15:47,040 --> 00:15:52,320
record con it's number three

00:15:50,240 --> 00:15:53,360
if you come back here we know that this

00:15:52,320 --> 00:15:57,440
one

00:15:53,360 --> 00:16:00,720
straight okay if i say that the

00:15:57,440 --> 00:16:04,320
the there is a field

00:16:00,720 --> 00:16:07,680
in this event header uh that is

00:16:04,320 --> 00:16:10,000
the type for this thing and then i say

00:16:07,680 --> 00:16:11,839
and if i don't specify type equals

00:16:10,000 --> 00:16:14,160
something it assumes that

00:16:11,839 --> 00:16:15,759
it's type equals type it's just like

00:16:14,160 --> 00:16:18,240
it's a well-known

00:16:15,759 --> 00:16:20,240
member name for this specific semantic

00:16:18,240 --> 00:16:22,959
then you you specify that

00:16:20,240 --> 00:16:23,839
the enumeration for the type that's

00:16:22,959 --> 00:16:26,880
specified here

00:16:23,839 --> 00:16:30,240
is that perfect type okay

00:16:26,880 --> 00:16:31,680
so it will get that number for a and try

00:16:30,240 --> 00:16:34,639
to do a loop cup in this

00:16:31,680 --> 00:16:36,000
enumeration and if it finds it like it

00:16:34,639 --> 00:16:39,199
did with the number three

00:16:36,000 --> 00:16:42,880
here thing starts to get better uh

00:16:39,199 --> 00:16:44,959
you get the then the path record com

00:16:42,880 --> 00:16:48,000
instead of just three

00:16:44,959 --> 00:16:50,880
and then e

00:16:48,000 --> 00:16:52,399
this enumeration has something something

00:16:50,880 --> 00:16:54,320
interesting

00:16:52,399 --> 00:16:56,079
it it map it number three to

00:16:54,320 --> 00:16:58,560
perfrack.com

00:16:56,079 --> 00:16:58,560
and then

00:17:01,360 --> 00:17:07,520
the types here

00:17:04,480 --> 00:17:11,839
shows that uh it's an union so

00:17:07,520 --> 00:17:14,880
com has the same start as a header

00:17:11,839 --> 00:17:19,839
and i can go from these

00:17:14,880 --> 00:17:24,559
enumeration if i do lowercase on it

00:17:19,839 --> 00:17:28,160
to this type okay and then

00:17:24,559 --> 00:17:31,520
i know what to cast that specific

00:17:28,160 --> 00:17:32,240
chunk of data coming from the standard

00:17:31,520 --> 00:17:36,160
input

00:17:32,240 --> 00:17:39,360
which is to this type of record con

00:17:36,160 --> 00:17:42,000
and then i can get to this

00:17:39,360 --> 00:17:43,039
i know that there is a pid and i'm

00:17:42,000 --> 00:17:46,640
formatting it as

00:17:43,039 --> 00:17:50,559
an excellent html because i ask it here

00:17:46,640 --> 00:17:50,559
and then that i know that the

00:17:50,799 --> 00:17:56,559
um is a string and then i can do better

00:17:54,559 --> 00:17:58,880
and i can do this for all the other

00:17:56,559 --> 00:17:58,880
types

00:17:59,039 --> 00:18:03,360
all these types and get everything

00:18:01,200 --> 00:18:05,440
decoded

00:18:03,360 --> 00:18:06,880
okay there are lots more but we end up

00:18:05,440 --> 00:18:10,000
with something like this

00:18:06,880 --> 00:18:13,200
which let me explain uh the time is

00:18:10,000 --> 00:18:16,000
going up uh so you have p ho you say

00:18:13,200 --> 00:18:16,799
bing perf where to get the the data

00:18:16,000 --> 00:18:20,240
types

00:18:16,799 --> 00:18:21,120
you say that the header is this so this

00:18:20,240 --> 00:18:24,880
type

00:18:21,120 --> 00:18:25,440
that it gets from here and you say that

00:18:24,880 --> 00:18:28,480
the

00:18:25,440 --> 00:18:32,160
the records are of the type perf file

00:18:28,480 --> 00:18:35,760
80 tier and then you say in the header

00:18:32,160 --> 00:18:38,480
get the range from these member that has

00:18:35,760 --> 00:18:39,840
offset and size same thing for preferred

00:18:38,480 --> 00:18:42,400
event header

00:18:39,840 --> 00:18:44,160
i say that there is a size type a size

00:18:42,400 --> 00:18:47,520
member there is a type member

00:18:44,160 --> 00:18:50,880
and i said that to decode those types

00:18:47,520 --> 00:18:54,480
you have to use this uh

00:18:50,880 --> 00:18:56,720
enumeration plus this other enumeration

00:18:54,480 --> 00:18:58,320
combine the two and then decode

00:18:56,720 --> 00:19:01,120
everything

00:18:58,320 --> 00:19:03,520
okay so the goal here is to use it to

00:19:01,120 --> 00:19:05,280
document the file format while providing

00:19:03,520 --> 00:19:08,240
a full pretty printer

00:19:05,280 --> 00:19:10,000
replace the dumper of raw evidence in

00:19:08,240 --> 00:19:12,000
perf report

00:19:10,000 --> 00:19:14,480
new records that we add in the future

00:19:12,000 --> 00:19:16,400
will get automatically supported

00:19:14,480 --> 00:19:18,320
the future is to experiment more with

00:19:16,400 --> 00:19:20,960
this finish the perfect

00:19:18,320 --> 00:19:20,960
nice sector

00:19:21,679 --> 00:19:25,440
with features that are not specific to

00:19:23,600 --> 00:19:29,440
it so you can use this to decode a

00:19:25,440 --> 00:19:29,919
gif file or a whatever any any other

00:19:29,440 --> 00:19:33,679
type

00:19:29,919 --> 00:19:36,960
any other file type integrated with the

00:19:33,679 --> 00:19:39,200
decoding that is present in perf for

00:19:36,960 --> 00:19:40,000
that maps integers in kernel apis to

00:19:39,200 --> 00:19:41,679
strings where

00:19:40,000 --> 00:19:43,360
they are not documented as an

00:19:41,679 --> 00:19:47,360
enumeration

00:19:43,360 --> 00:19:48,640
and try maybe add some other features

00:19:47,360 --> 00:19:50,799
that this feature to other tools like

00:19:48,640 --> 00:19:53,679
gtb or crash uh

00:19:50,799 --> 00:19:55,840
and fixed box found in this presentation

00:19:53,679 --> 00:19:59,440
this presentation is available

00:19:55,840 --> 00:20:01,679
here and together with other

00:19:59,440 --> 00:20:05,360
presentations about bpf

00:20:01,679 --> 00:20:06,400
uh and uh there are other features that

00:20:05,360 --> 00:20:10,080
are already present like

00:20:06,400 --> 00:20:12,960
filtering by the enumeration number

00:20:10,080 --> 00:20:13,520
that maps back to the number it's it's

00:20:12,960 --> 00:20:18,240
already

00:20:13,520 --> 00:20:18,240
quite capable so that's it for the

00:20:18,840 --> 00:20:21,840
presentation

00:20:22,000 --> 00:20:26,240
now it's time for questions i i thank

00:20:24,080 --> 00:20:29,280
you

00:20:26,240 --> 00:20:30,720
thank you arnold it seems like video any

00:20:29,280 --> 00:20:34,320
questions in the q a

00:20:30,720 --> 00:20:34,960
section but if anyone wants to ask

00:20:34,320 --> 00:20:37,520
anything

00:20:34,960 --> 00:20:39,919
please follow up on the discord server

00:20:37,520 --> 00:20:44,159
on the

00:20:39,919 --> 00:20:47,280
on the discord track in there

00:20:44,159 --> 00:20:49,760
and i think that will be everything

00:20:47,280 --> 00:20:51,440
or if you want to add anything we have

00:20:49,760 --> 00:20:53,760
still four minutes left

00:20:51,440 --> 00:20:54,799
so it's really up to you yeah i mean i i

00:20:53,760 --> 00:20:58,559
i

00:20:54,799 --> 00:21:03,039
this this uh btf thing is

00:20:58,559 --> 00:21:06,559
uh is really enabling uh

00:21:03,039 --> 00:21:08,080
lots of new features uh all this type

00:21:06,559 --> 00:21:08,720
information was already available in

00:21:08,080 --> 00:21:11,360
dwarf

00:21:08,720 --> 00:21:12,080
but dwarf was too big dwarf version five

00:21:11,360 --> 00:21:16,240
and four

00:21:12,080 --> 00:21:18,159
improved a lot uh improved a lot uh

00:21:16,240 --> 00:21:19,360
in this regard there are new features

00:21:18,159 --> 00:21:22,480
where uh

00:21:19,360 --> 00:21:25,520
compaction is possible

00:21:22,480 --> 00:21:28,080
but by now btf is

00:21:25,520 --> 00:21:29,360
supported inside the kernel by the bpf

00:21:28,080 --> 00:21:34,320
verifier

00:21:29,360 --> 00:21:38,080
so a really vibrant community around it

00:21:34,320 --> 00:21:41,360
popped up into existence uh

00:21:38,080 --> 00:21:42,799
it's used i mean lots of places in bpf

00:21:41,360 --> 00:21:45,840
trades

00:21:42,799 --> 00:21:46,960
i saw a talk yesterday by uh aj osha

00:21:45,840 --> 00:21:50,240
that worked with me

00:21:46,960 --> 00:21:53,360
even mpa hall uh

00:21:50,240 --> 00:21:57,200
that uh where he showed examples where

00:21:53,360 --> 00:22:00,480
you can specify uh accessing

00:21:57,200 --> 00:22:04,799
task struct

00:22:00,480 --> 00:22:07,440
fields and in the past is required that

00:22:04,799 --> 00:22:08,000
you used kernel headers that should

00:22:07,440 --> 00:22:11,600
match

00:22:08,000 --> 00:22:13,760
exactly that scanner that you are using

00:22:11,600 --> 00:22:14,799
this was a source of confusion sometimes

00:22:13,760 --> 00:22:18,159
and problems

00:22:14,799 --> 00:22:19,440
but now since the type information for

00:22:18,159 --> 00:22:22,960
the kernel is shipped

00:22:19,440 --> 00:22:25,360
together in the kernel image

00:22:22,960 --> 00:22:27,840
and when you boot it it is available

00:22:25,360 --> 00:22:31,039
there and the camera can use it from

00:22:27,840 --> 00:22:32,400
inside the kernel to validate uh

00:22:31,039 --> 00:22:34,640
lots of new features that are being

00:22:32,400 --> 00:22:38,840
implemented in uh bpf

00:22:34,640 --> 00:22:41,440
like bpf compiled once run everywhere

00:22:38,840 --> 00:22:44,480
uh um it's

00:22:41,440 --> 00:22:48,080
it's really i mean it's really exciting

00:22:44,480 --> 00:22:48,480
what you can do with this you can use it

00:22:48,080 --> 00:22:51,039
i mean

00:22:48,480 --> 00:22:52,720
it's fast to use it you don't have to

00:22:51,039 --> 00:22:55,360
process lots of data

00:22:52,720 --> 00:22:56,240
so i i really think that people should

00:22:55,360 --> 00:22:59,840
look at it

00:22:56,240 --> 00:23:00,559
more and find ways to use it since it's

00:22:59,840 --> 00:23:02,960
available

00:23:00,559 --> 00:23:02,960
everywhere

00:23:05,440 --> 00:23:08,720
thank you very much for your talk and

00:23:07,280 --> 00:23:12,559
for the new tool

00:23:08,720 --> 00:23:18,080
to to

00:23:12,559 --> 00:23:23,840
try and i think that's it for this talk

00:23:18,080 --> 00:23:23,840

YouTube URL: https://www.youtube.com/watch?v=fX6_xHldTjU


