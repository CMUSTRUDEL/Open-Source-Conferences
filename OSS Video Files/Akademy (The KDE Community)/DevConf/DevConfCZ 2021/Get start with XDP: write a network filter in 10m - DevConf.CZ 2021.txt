Title: Get start with XDP: write a network filter in 10m - DevConf.CZ 2021
Publication date: 2021-03-19
Playlist: DevConfCZ 2021
Description: 
	Speaker: Hangbin Liu

XDP and eBPF are getting popular, it's performance has giant improvement compared with iptables. In this session, we will show how to write a small XDP network filter. This session is for audiences who are not familiar with XDP, but want to know how to write a XDP program. The listener should familiar with C and network packet format.



Schedule: https://sched.co/gmNo
Captions: 
	00:00:02,560 --> 00:00:07,200
i'm hamil from red hat

00:00:04,480 --> 00:00:09,200
i'm working in the network service team

00:00:07,200 --> 00:00:13,679
and today we will talk about um

00:00:09,200 --> 00:00:13,679
how to start the programming with fdp

00:00:13,840 --> 00:00:21,199
okay so here's the agenda

00:00:18,000 --> 00:00:24,720
first we will talk about what and why

00:00:21,199 --> 00:00:28,080
why use ftp and then we will write a

00:00:24,720 --> 00:00:31,679
small program we will extend the program

00:00:28,080 --> 00:00:34,719
and use the ppf maps

00:00:31,679 --> 00:00:37,120
at the last we will load the bpf program

00:00:34,719 --> 00:00:41,760
with dppkf

00:00:37,120 --> 00:00:44,640
okay first what and why we use fdp

00:00:41,760 --> 00:00:46,000
and as the time is delete we will go to

00:00:44,640 --> 00:00:49,200
go through this part of

00:00:46,000 --> 00:00:52,559
quickly so what's fdp

00:00:49,200 --> 00:00:55,920
fcpa the express data test

00:00:52,559 --> 00:00:58,160
is a network feature based on ebpf

00:00:55,920 --> 00:00:59,280
it's very to you very easy to use

00:00:58,160 --> 00:01:02,480
because we can

00:00:59,280 --> 00:01:03,359
comply it once and load it on multi

00:01:02,480 --> 00:01:06,880
kernels without

00:01:03,359 --> 00:01:10,960
recoupling and it's also very fast

00:01:06,880 --> 00:01:14,080
and we can operate on package before

00:01:10,960 --> 00:01:17,200
is being converted to skb and

00:01:14,080 --> 00:01:21,600
go through the whole network stack

00:01:17,200 --> 00:01:25,520
okay now let's see how to write a

00:01:21,600 --> 00:01:29,040
hello world program the first two lines

00:01:25,520 --> 00:01:31,680
is the hipper functions

00:01:29,040 --> 00:01:32,400
it provides the helper functions and

00:01:31,680 --> 00:01:36,400
then next

00:01:32,400 --> 00:01:39,439
is the section helper is this is used to

00:01:36,400 --> 00:01:41,040
place a section in elf file after

00:01:39,439 --> 00:01:44,240
complying

00:01:41,040 --> 00:01:47,680
here we define the second name as

00:01:44,240 --> 00:01:50,159
fcp job the next line is the main

00:01:47,680 --> 00:01:53,920
function in this section

00:01:50,159 --> 00:01:56,240
the name is xp ftp drop program

00:01:53,920 --> 00:01:58,799
it has only one parameter but we don't

00:01:56,240 --> 00:02:02,719
use it right now we will talk about it

00:01:58,799 --> 00:02:05,840
later it's on how one line it returns

00:02:02,719 --> 00:02:09,520
xdp drop which means we will drop every

00:02:05,840 --> 00:02:11,280
package we received on the interface

00:02:09,520 --> 00:02:13,200
there's there's there are also some

00:02:11,280 --> 00:02:16,319
other kind of

00:02:13,200 --> 00:02:20,640
actions like ftp pass or fcp

00:02:16,319 --> 00:02:24,800
tx fcp redraft and the last line is the

00:02:20,640 --> 00:02:28,160
license license section this section is

00:02:24,800 --> 00:02:31,200
needed as as some helper

00:02:28,160 --> 00:02:33,760
accessible only by gpr license license

00:02:31,200 --> 00:02:36,959
the program

00:02:33,760 --> 00:02:40,400
okay now let's see how to

00:02:36,959 --> 00:02:42,160
build the object um first we need to

00:02:40,400 --> 00:02:45,200
install some dependents

00:02:42,160 --> 00:02:49,120
like uh clan llm

00:02:45,200 --> 00:02:53,200
or leave ppf with sdp and then we will

00:02:49,120 --> 00:02:56,560
build the object by welcome

00:02:53,200 --> 00:02:57,760
with dash g this will generate a debug

00:02:56,560 --> 00:03:02,080
information

00:02:57,760 --> 00:03:05,760
and we need to make the target bpf

00:03:02,080 --> 00:03:08,800
source file fcp drop.c output is

00:03:05,760 --> 00:03:12,720
ftp drop.o this is a

00:03:08,800 --> 00:03:16,000
elf file and we can also some

00:03:12,720 --> 00:03:19,680
thumbs the object by lrm object

00:03:16,000 --> 00:03:23,680
obg terms as we how comply

00:03:19,680 --> 00:03:26,480
the object with dash g it will

00:03:23,680 --> 00:03:28,000
uh we can see the this assembled source

00:03:26,480 --> 00:03:31,040
code

00:03:28,000 --> 00:03:35,040
it will return activity drop

00:03:31,040 --> 00:03:37,519
so built with the dash g

00:03:35,040 --> 00:03:40,000
is very useful for debugging when we

00:03:37,519 --> 00:03:42,959
only hold the object file but we don't

00:03:40,000 --> 00:03:42,959
have the source code

00:03:43,760 --> 00:03:50,640
also with lm of obd

00:03:47,120 --> 00:03:52,000
opt terms we can uh with dash edge we

00:03:50,640 --> 00:03:55,120
can see the

00:03:52,000 --> 00:03:55,920
section lines like the fbx dp drop

00:03:55,120 --> 00:03:58,480
section

00:03:55,920 --> 00:04:01,840
the license section we just defined in

00:03:58,480 --> 00:04:01,840
the example

00:04:03,599 --> 00:04:10,560
okay now how to load the

00:04:06,640 --> 00:04:11,120
object the easiest way to load the ftp

00:04:10,560 --> 00:04:14,159
object

00:04:11,120 --> 00:04:16,479
kernel is about the ip link

00:04:14,159 --> 00:04:18,560
before the test there's one that don't

00:04:16,479 --> 00:04:20,720
load it on the default interface

00:04:18,560 --> 00:04:22,000
because our example will drop every

00:04:20,720 --> 00:04:25,360
package

00:04:22,000 --> 00:04:26,639
come come in the interface so if you

00:04:25,360 --> 00:04:31,680
load it on default

00:04:26,639 --> 00:04:31,680
interface you may get internet uh

00:04:31,759 --> 00:04:39,600
your disconnect with the internet okay

00:04:35,520 --> 00:04:42,639
first we load it with app link set

00:04:39,600 --> 00:04:45,040
vth with module sdp

00:04:42,639 --> 00:04:46,000
with model xcp generic there are also

00:04:45,040 --> 00:04:49,280
some other

00:04:46,000 --> 00:04:50,240
modules models like ftp driver or lcd

00:04:49,280 --> 00:04:54,000
offload

00:04:50,240 --> 00:04:57,360
but it's only supported by a few drivers

00:04:54,000 --> 00:04:58,080
if you want to testing you can use ftp

00:04:57,360 --> 00:05:01,039
generic

00:04:58,080 --> 00:05:03,120
which is supported by all the drivers

00:05:01,039 --> 00:05:06,160
and the supply the object

00:05:03,120 --> 00:05:09,440
under the section name after load

00:05:06,160 --> 00:05:10,720
it into with ip link show we will show

00:05:09,440 --> 00:05:13,120
the

00:05:10,720 --> 00:05:14,240
lines you can see the lines program ftp

00:05:13,120 --> 00:05:17,440
with id1

00:05:14,240 --> 00:05:19,440
we can also use ppf tools program show

00:05:17,440 --> 00:05:22,880
to show the

00:05:19,440 --> 00:05:23,520
program we just load another tool is xdp

00:05:22,880 --> 00:05:27,360
loader

00:05:23,520 --> 00:05:30,240
as the loader settings also show the

00:05:27,360 --> 00:05:30,800
show the program reload if you want to

00:05:30,240 --> 00:05:35,440
unload

00:05:30,800 --> 00:05:39,840
the object just to ip link set interface

00:05:35,440 --> 00:05:39,840
with sdp generic off

00:05:40,000 --> 00:05:47,039
but we have one we recommended to

00:05:43,680 --> 00:05:50,080
use ftp loader to load the xdb

00:05:47,039 --> 00:05:53,120
object because it's the only way

00:05:50,080 --> 00:05:54,240
red hat support and it's only the is the

00:05:53,120 --> 00:05:56,479
only way

00:05:54,240 --> 00:05:58,000
uh we load the multi programs on one

00:05:56,479 --> 00:06:01,039
interface

00:05:58,000 --> 00:06:04,840
so let's see with activity loader

00:06:01,039 --> 00:06:08,000
load with module stb skb

00:06:04,840 --> 00:06:11,120
means is the same with with the

00:06:08,000 --> 00:06:15,600
private in with the example

00:06:11,120 --> 00:06:18,560
ip link that we use xcp generic

00:06:15,600 --> 00:06:20,319
and we also supply the section name the

00:06:18,560 --> 00:06:24,800
interface name and the

00:06:20,319 --> 00:06:26,960
object file so with ftp loader status

00:06:24,800 --> 00:06:28,000
you can see we load the two http

00:06:26,960 --> 00:06:31,840
programs the first

00:06:28,000 --> 00:06:32,560
is fcd dispatcher is provided by the xcp

00:06:31,840 --> 00:06:35,919
loader

00:06:32,560 --> 00:06:39,039
the next one fb job program is that

00:06:35,919 --> 00:06:41,440
is what we write before

00:06:39,039 --> 00:06:42,479
now with every link show you can see it

00:06:41,440 --> 00:06:45,520
only shows the first

00:06:42,479 --> 00:06:49,039
program but the ppf bpf2

00:06:45,520 --> 00:06:51,919
program will show the two programs

00:06:49,039 --> 00:06:54,080
first is http dispatcher the second is

00:06:51,919 --> 00:06:57,440
ftp drop program

00:06:54,080 --> 00:07:01,360
to load to unload the program just type

00:06:57,440 --> 00:07:04,400
xcp loader unload a means or

00:07:01,360 --> 00:07:04,400
with the interface name

00:07:05,440 --> 00:07:07,680
okay

00:07:09,280 --> 00:07:14,400
okay now we have learned how to write a

00:07:13,280 --> 00:07:18,000
fcb program

00:07:14,400 --> 00:07:20,160
and load it to kernel but this is just a

00:07:18,000 --> 00:07:22,960
hello world program and the meaningless

00:07:20,160 --> 00:07:23,440
so let's try a meaningful program how

00:07:22,960 --> 00:07:26,720
about

00:07:23,440 --> 00:07:28,000
we drop some specific packets like a net

00:07:26,720 --> 00:07:31,120
filter or add tables

00:07:28,000 --> 00:07:32,319
we write a program to drop a ipv6

00:07:31,120 --> 00:07:36,080
package

00:07:32,319 --> 00:07:36,800
um first we need to see the parameter we

00:07:36,080 --> 00:07:42,400
just said

00:07:36,800 --> 00:07:42,400
we just saw the struct.xcpmd

00:07:42,800 --> 00:07:49,120
there are two fields we will use today

00:07:45,919 --> 00:07:51,759
the data and the data end as we know

00:07:49,120 --> 00:07:54,400
when the driver receive a packet the

00:07:51,759 --> 00:07:58,160
data starts from the internet header

00:07:54,400 --> 00:08:00,639
so the xcpmd data

00:07:58,160 --> 00:08:01,520
point to the internet header and the

00:08:00,639 --> 00:08:05,039
data end

00:08:01,520 --> 00:08:05,039
point to the end of the data

00:08:05,759 --> 00:08:10,080
now now here is the full code

00:08:10,160 --> 00:08:17,199
we now we need two more headlines uh

00:08:13,440 --> 00:08:19,120
if either to define the either header

00:08:17,199 --> 00:08:22,720
and the id header

00:08:19,120 --> 00:08:24,960
um compared to the previous program

00:08:22,720 --> 00:08:26,400
we added some we first we defined the

00:08:24,960 --> 00:08:29,360
data end

00:08:26,400 --> 00:08:30,800
point to the ctx data end and the data

00:08:29,360 --> 00:08:32,959
point to serial data

00:08:30,800 --> 00:08:34,560
then we define the either header

00:08:32,959 --> 00:08:37,760
variable eth

00:08:34,560 --> 00:08:41,680
point to the data which is which is the

00:08:37,760 --> 00:08:45,600
beginning of the data and then

00:08:41,680 --> 00:08:49,839
we we access the data

00:08:45,600 --> 00:08:52,080
in the internet header

00:08:49,839 --> 00:08:52,959
we must make sure we don't access

00:08:52,080 --> 00:08:57,040
invalid

00:08:52,959 --> 00:09:00,880
error we need to check the data plus the

00:08:57,040 --> 00:09:02,160
size of eth header is greater than the

00:09:00,880 --> 00:09:04,959
data end

00:09:02,160 --> 00:09:05,920
this check is compulsory by the bpf

00:09:04,959 --> 00:09:08,959
wafer

00:09:05,920 --> 00:09:12,320
because we we can't okay we can't

00:09:08,959 --> 00:09:15,760
access and authorize the kernel memories

00:09:12,320 --> 00:09:19,440
um after that we compare the

00:09:15,760 --> 00:09:22,640
protocol if is ipv6

00:09:19,440 --> 00:09:26,000
we will drop it if it's not we will

00:09:22,640 --> 00:09:28,800
pass or pass the package

00:09:26,000 --> 00:09:29,120
okay it's very easy right if you want to

00:09:28,800 --> 00:09:32,240
drop

00:09:29,120 --> 00:09:35,680
some other kind of package like ipv6

00:09:32,240 --> 00:09:38,320
ipv4 or even tcp udp

00:09:35,680 --> 00:09:38,880
or or based on the sources the port

00:09:38,320 --> 00:09:40,880
number

00:09:38,880 --> 00:09:42,240
you can just do the same like this

00:09:40,880 --> 00:09:45,920
example and

00:09:42,240 --> 00:09:48,959
operate the package data based on the

00:09:45,920 --> 00:09:52,160
network format so you need to know the

00:09:48,959 --> 00:09:52,160
network format first

00:09:53,120 --> 00:10:00,320
okay and now

00:09:57,040 --> 00:10:03,440
now is that all no

00:10:00,320 --> 00:10:04,640
what if we want to communicate with the

00:10:03,440 --> 00:10:07,519
kernel

00:10:04,640 --> 00:10:09,040
what if we want to count the number we

00:10:07,519 --> 00:10:11,760
just dropped

00:10:09,040 --> 00:10:12,640
here we will introduce a very important

00:10:11,760 --> 00:10:15,920
feature

00:10:12,640 --> 00:10:19,519
ebpm feature the maps

00:10:15,920 --> 00:10:21,440
bpf maps is are used to share data

00:10:19,519 --> 00:10:24,720
between the kernel and the user space

00:10:21,440 --> 00:10:29,120
we can update the map data in kernel and

00:10:24,720 --> 00:10:33,600
read it from user space or vice versa

00:10:29,120 --> 00:10:36,720
here is an example we of the new

00:10:33,600 --> 00:10:40,079
bpf type format defined map

00:10:36,720 --> 00:10:42,000
here we defined a structure extract the

00:10:40,079 --> 00:10:47,120
rs count

00:10:42,000 --> 00:10:50,640
with the section maps

00:10:47,120 --> 00:10:51,920
the the struct type is a bpf map type or

00:10:50,640 --> 00:10:56,480
perspirate

00:10:51,920 --> 00:11:00,000
it means we defined an array on each cpu

00:10:56,480 --> 00:11:04,079
on the system and the k is the unsigned

00:11:00,000 --> 00:11:07,600
62 the value is alone there is only one

00:11:04,079 --> 00:11:10,720
entries in this in this struct

00:11:07,600 --> 00:11:14,720
there are also some other kind of

00:11:10,720 --> 00:11:18,800
dpf maps like the hash or array

00:11:14,720 --> 00:11:18,800
these are defined in the linux kernel

00:11:19,200 --> 00:11:27,200
okay now let's see the full code

00:11:23,600 --> 00:11:31,200
so first we defined the map

00:11:27,200 --> 00:11:34,640
and then we define a key

00:11:31,200 --> 00:11:35,600
as we only have one one entry so the k

00:11:34,640 --> 00:11:38,720
is zero

00:11:35,600 --> 00:11:43,040
and um when we when we get the

00:11:38,720 --> 00:11:47,120
ipv6 package we get the value from them

00:11:43,040 --> 00:11:49,519
from the map by vpf map lookup element

00:11:47,120 --> 00:11:50,399
with the means the map name and the key

00:11:49,519 --> 00:11:53,279
value

00:11:50,399 --> 00:11:54,240
we get we get the value and if there's a

00:11:53,279 --> 00:11:57,839
value we

00:11:54,240 --> 00:11:58,720
plus one now we count the number in the

00:11:57,839 --> 00:12:01,839
kernel

00:11:58,720 --> 00:12:06,800
but how do we get the

00:12:01,839 --> 00:12:10,480
value from user space

00:12:06,800 --> 00:12:14,079
okay let's see first we build it

00:12:10,480 --> 00:12:18,240
we build it with silang and then we

00:12:14,079 --> 00:12:21,440
then load it with ftp loader

00:12:18,240 --> 00:12:22,639
and then we receive some ipv6 package um

00:12:21,440 --> 00:12:25,519
[Music]

00:12:22,639 --> 00:12:26,639
with pbf2 map show we will show all the

00:12:25,519 --> 00:12:31,040
maps on

00:12:26,639 --> 00:12:34,000
reload you can see the first map is

00:12:31,040 --> 00:12:34,560
a particular array with name rx count

00:12:34,000 --> 00:12:37,760
this is

00:12:34,560 --> 00:12:41,519
just what we we defined

00:12:37,760 --> 00:12:45,440
in the program so with bpf map dump

00:12:41,519 --> 00:12:45,440
with id16 and

00:12:47,040 --> 00:12:57,200
um yes and with the k0 we can see

00:12:53,040 --> 00:13:00,160
the on cpu 0 the value is 13

00:12:57,200 --> 00:13:00,959
and with cpu 1 the value is 7 and after

00:13:00,160 --> 00:13:03,040
you

00:13:00,959 --> 00:13:04,000
sum the value you will get the total

00:13:03,040 --> 00:13:07,839
values we have

00:13:04,000 --> 00:13:07,839
we just dropped

00:13:08,160 --> 00:13:15,680
okay so until now

00:13:11,360 --> 00:13:19,519
uh after build the bpf object

00:13:15,680 --> 00:13:22,480
we load it to kernel while xcp loader

00:13:19,519 --> 00:13:23,839
we saw the maps we saw the maps about

00:13:22,480 --> 00:13:26,480
bpo tools

00:13:23,839 --> 00:13:27,360
and but what if we want to load the

00:13:26,480 --> 00:13:30,639
object

00:13:27,360 --> 00:13:33,839
and show the maps in in sim2 and

00:13:30,639 --> 00:13:35,920
what if we want to define another output

00:13:33,839 --> 00:13:39,440
format we don't use this json

00:13:35,920 --> 00:13:41,680
output so we need to write our own user

00:13:39,440 --> 00:13:44,320
space program to load the object

00:13:41,680 --> 00:13:44,880
and communicate communicate with kernel

00:13:44,320 --> 00:13:48,079
to get

00:13:44,880 --> 00:13:51,360
the map data then we

00:13:48,079 --> 00:13:55,040
then we need to use leave bpf and leave

00:13:51,360 --> 00:13:57,839
sdp uh for the detail

00:13:55,040 --> 00:13:59,120
in this example is a is a very very easy

00:13:57,839 --> 00:14:02,160
example

00:13:59,120 --> 00:14:06,240
if you want to know the detailed usage

00:14:02,160 --> 00:14:09,839
you can read it from the github repo

00:14:06,240 --> 00:14:13,040
okay so here is the

00:14:09,839 --> 00:14:16,880
the example we use with

00:14:13,040 --> 00:14:21,199
as deep xdp and leak ppf

00:14:16,880 --> 00:14:25,120
first first is header header files

00:14:21,199 --> 00:14:26,959
in the example we use lib table and the

00:14:25,120 --> 00:14:30,399
libx dp table

00:14:26,959 --> 00:14:32,639
and develop

00:14:30,399 --> 00:14:33,600
first we define the following variables

00:14:32,639 --> 00:14:36,800
global the

00:14:33,600 --> 00:14:38,240
interface index and the fcp struct scp

00:14:36,800 --> 00:14:44,800
program

00:14:38,240 --> 00:14:48,399
and now let's see the main program

00:14:44,800 --> 00:14:51,360
um as the usage is a

00:14:48,399 --> 00:14:55,279
program name plus the interface name so

00:14:51,360 --> 00:14:58,560
first we get the interface theme and

00:14:55,279 --> 00:15:01,519
get the index of the interface

00:14:58,560 --> 00:15:02,399
and then we'll load the ftp object by

00:15:01,519 --> 00:15:06,240
the little bit

00:15:02,399 --> 00:15:09,920
deep lcp by xcd program open file

00:15:06,240 --> 00:15:14,320
with the file name and the section name

00:15:09,920 --> 00:15:14,320
we load the fcp program

00:15:14,639 --> 00:15:18,560
then we attach the ftp program to the

00:15:17,760 --> 00:15:22,320
interface

00:15:18,560 --> 00:15:25,199
with sdp module skb

00:15:22,320 --> 00:15:26,079
and now we have loaded the program but

00:15:25,199 --> 00:15:28,639
we want to

00:15:26,079 --> 00:15:29,839
get the map data so we need to find the

00:15:28,639 --> 00:15:32,800
map id from

00:15:29,839 --> 00:15:34,560
the vpf object so first we need to find

00:15:32,800 --> 00:15:38,480
the bpf object

00:15:34,560 --> 00:15:41,839
from xtp project object

00:15:38,480 --> 00:15:45,839
then we find the map map fd

00:15:41,839 --> 00:15:47,839
from the bpf object with the map name rx

00:15:45,839 --> 00:15:50,880
count

00:15:47,839 --> 00:15:55,279
after after we get the map id we

00:15:50,880 --> 00:15:59,120
call a function named the prostate to

00:15:55,279 --> 00:16:00,959
every two seconds to get the status

00:15:59,120 --> 00:16:03,199
now let's see what the pro state looks

00:16:00,959 --> 00:16:03,199
like

00:16:03,680 --> 00:16:10,160
in the first days we will count the

00:16:08,320 --> 00:16:12,079
perceptual number and print out the

00:16:10,160 --> 00:16:15,600
total dropped package

00:16:12,079 --> 00:16:18,639
so first we need to get the cpu numbers

00:16:15,600 --> 00:16:19,519
uh by uh from dbpf number of possible

00:16:18,639 --> 00:16:23,199
cpus

00:16:19,519 --> 00:16:26,480
and then we define a array

00:16:23,199 --> 00:16:30,079
called the values array with the

00:16:26,480 --> 00:16:34,000
max entry cpu number then we get

00:16:30,079 --> 00:16:37,600
the we get the values from the map

00:16:34,000 --> 00:16:40,800
from the map fd with k0

00:16:37,600 --> 00:16:45,040
by bpfmap lookup element

00:16:40,800 --> 00:16:51,839
after that we summary the

00:16:45,040 --> 00:16:51,839
values every two seconds

00:16:52,160 --> 00:16:56,320
i will also count the sum in total to

00:16:54,800 --> 00:16:59,360
get the total number

00:16:56,320 --> 00:17:00,000
so at last we will print out the total

00:16:59,360 --> 00:17:05,839
package

00:17:00,000 --> 00:17:05,839
and the package per second

00:17:06,880 --> 00:17:13,120
okay so

00:17:10,000 --> 00:17:16,319
um before the testing we need to

00:17:13,120 --> 00:17:19,120
set the set unlimited to unlimited

00:17:16,319 --> 00:17:19,679
so we can get enough source resource

00:17:19,120 --> 00:17:23,520
then

00:17:19,679 --> 00:17:27,600
we build the xcp program

00:17:23,520 --> 00:17:30,720
we build the program with gcp

00:17:27,600 --> 00:17:33,200
please note that the xdp program and

00:17:30,720 --> 00:17:35,039
objects we showed at the beginning is

00:17:33,200 --> 00:17:38,160
not user space program

00:17:35,039 --> 00:17:41,679
the xdp object is built as an

00:17:38,160 --> 00:17:44,880
erf file and will be loaded to kernel

00:17:41,679 --> 00:17:48,480
while this program is run in user space

00:17:44,880 --> 00:17:51,200
and is used to load the

00:17:48,480 --> 00:17:51,600
ftp object and print out the map values

00:17:51,200 --> 00:17:54,720
just

00:17:51,600 --> 00:17:57,440
like we should ensure the

00:17:54,720 --> 00:17:59,360
just like the lcd loader or the bpf

00:17:57,440 --> 00:18:02,960
tools

00:17:59,360 --> 00:18:07,520
and that's why we built it with gcc um

00:18:02,960 --> 00:18:11,200
but the xcp object is built about cloud

00:18:07,520 --> 00:18:14,640
so now we built it with gcc

00:18:11,200 --> 00:18:18,080
and with flags arrow ppf and

00:18:14,640 --> 00:18:20,400
our xdp and then load the

00:18:18,080 --> 00:18:22,000
we run the program with the interface

00:18:20,400 --> 00:18:24,880
name which one

00:18:22,000 --> 00:18:25,600
and then after we receive some ipv6

00:18:24,880 --> 00:18:27,520
packets

00:18:25,600 --> 00:18:31,840
it will print out the total dropped

00:18:27,520 --> 00:18:31,840
number and the package per second

00:18:32,400 --> 00:18:36,160
okay so all the example code could be

00:18:35,760 --> 00:18:43,840
found

00:18:36,160 --> 00:18:45,919
in this link including this slide

00:18:43,840 --> 00:18:45,919

YouTube URL: https://www.youtube.com/watch?v=ZfpAAyfeiwA


