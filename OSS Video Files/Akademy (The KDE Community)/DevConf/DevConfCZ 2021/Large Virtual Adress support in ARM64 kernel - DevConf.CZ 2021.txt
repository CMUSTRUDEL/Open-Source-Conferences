Title: Large Virtual Adress support in ARM64 kernel - DevConf.CZ 2021
Publication date: 2021-03-14
Playlist: DevConfCZ 2021
Description: 
	Speaker: Bhupesh Sharma


With ARMv8.2 architecture extensions becoming available in new / upcoming ARM64 CPUs, two new hardware extensions, namely - LVA (Large Virtual Addressing)
and LPA (Large Physical Addressing) are also being supported in open-source software now.

Starting from Linux kernel version 5.4, the 52-bit (Large) Virtual Address (VA) and Physical Address (PA) support was introduced for the ARM64 kernel. Although the kernel documentation describes these features (see [1] for more details) and how they impact the new kernels running on older CPUs (which don't support 52-bit VA extension in hardware) and the newer CPUs (which support 52-bit VA extension in hardware), it is still at-times complex for a normal user to understand the same and understand how one can "opt-in" for receiving VAs from a 52-bit space.

In this talk, I explain how:
A. the kernel memory layout gets "flipped" for ARM64 after the support for these features were added,
B. user-space applications, especially the ones which provide debugging support (e.g. kexec-tools, makedumpfile and crash-utility) get impacted because of the same, and
C. how user-space applications can "opt-in" to receiving VAs from a 52-bit space by specifying an mmap hint parameter that is larger than 48-bit.
ARMv8.2 architecture extensions - LVA and LPA:
....

Schedule: https://sched.co/gmN2
Captions: 
	00:00:01,199 --> 00:00:05,920
i welcome you to this session

00:00:03,040 --> 00:00:06,640
on uh large virtual address support uh

00:00:05,920 --> 00:00:09,280
52-bit

00:00:06,640 --> 00:00:10,880
in arm64 kernel so we are going to talk

00:00:09,280 --> 00:00:12,400
about the relevant implementation

00:00:10,880 --> 00:00:15,679
details and discuss some

00:00:12,400 --> 00:00:18,720
main points uh so um hi i am

00:00:15,679 --> 00:00:20,400
shawna i currently work with leonardo uh

00:00:18,720 --> 00:00:22,800
i hope you are taking good care of

00:00:20,400 --> 00:00:25,840
yourself during the pandemic

00:00:22,800 --> 00:00:27,680
you know usually large address support

00:00:25,840 --> 00:00:29,519
is a very frequently talked about topic

00:00:27,680 --> 00:00:32,559
but you know it can become

00:00:29,519 --> 00:00:35,360
moving quite quickly so um i i've

00:00:32,559 --> 00:00:35,840
tried to you know make this talk a bit

00:00:35,360 --> 00:00:38,719
uh

00:00:35,840 --> 00:00:39,680
you know in a sense condensed but not so

00:00:38,719 --> 00:00:42,239
condensed that

00:00:39,680 --> 00:00:44,800
uh you know it becomes boring for you so

00:00:42,239 --> 00:00:45,360
i did a similar talk uh on the same

00:00:44,800 --> 00:00:48,160
topic

00:00:45,360 --> 00:00:48,879
in lyrics con australia a month back

00:00:48,160 --> 00:00:51,760
also

00:00:48,879 --> 00:00:52,480
virtually and this is actually an update

00:00:51,760 --> 00:00:55,440
on that

00:00:52,480 --> 00:00:57,039
uh on the same talk basically i tried to

00:00:55,440 --> 00:00:58,320
gather all the feedback that the people

00:00:57,039 --> 00:01:02,160
had to share there

00:00:58,320 --> 00:01:04,879
and then i just incorporated a few

00:01:02,160 --> 00:01:05,519
changes in the talk accordingly yeah you

00:01:04,879 --> 00:01:08,320
can find

00:01:05,519 --> 00:01:10,159
a open source article i have written for

00:01:08,320 --> 00:01:12,960
the open source magazine

00:01:10,159 --> 00:01:15,040
on this topic also so probably that will

00:01:12,960 --> 00:01:17,520
also provide you some more details

00:01:15,040 --> 00:01:20,000
so in this talk i'll try to talk uh

00:01:17,520 --> 00:01:23,040
mainly you know in terms of the large

00:01:20,000 --> 00:01:25,600
address support or 964. i'll try to you

00:01:23,040 --> 00:01:27,520
know demystify a few details

00:01:25,600 --> 00:01:28,640
so let's open up the mystery box a

00:01:27,520 --> 00:01:32,159
little just uh

00:01:28,640 --> 00:01:34,720
bit by bit uh so first

00:01:32,159 --> 00:01:35,200
uh you know a bit about myself so i

00:01:34,720 --> 00:01:36,799
worked

00:01:35,200 --> 00:01:38,960
currently with the naru as part of the

00:01:36,799 --> 00:01:41,200
landing team uh so this is my

00:01:38,960 --> 00:01:42,240
snap from the last in person conference

00:01:41,200 --> 00:01:44,960
i attended

00:01:42,240 --> 00:01:45,840
in 2019 you know when you could travel

00:01:44,960 --> 00:01:48,960
freely

00:01:45,840 --> 00:01:50,799
so missing those days right so uh

00:01:48,960 --> 00:01:52,079
really good leaders in linux kernel

00:01:50,799 --> 00:01:54,079
interest me i

00:01:52,079 --> 00:01:56,159
contribute to uh you know same with live

00:01:54,079 --> 00:01:58,240
stream open source projects like linux

00:01:56,159 --> 00:02:00,000
cfi and input boot loaders

00:01:58,240 --> 00:02:02,320
i recently have i also started

00:02:00,000 --> 00:02:05,520
contributing to user space utilities

00:02:02,320 --> 00:02:07,520
like exec tools make them file i also

00:02:05,520 --> 00:02:11,759
could maintain the crash utility to

00:02:07,520 --> 00:02:11,759
upstream that's the user's face too

00:02:12,239 --> 00:02:17,360
so uh all right so let's uh see what we

00:02:15,360 --> 00:02:18,959
are going to talk about today right

00:02:17,360 --> 00:02:21,440
first we are going to talk about the

00:02:18,959 --> 00:02:24,480
large virtual address support for

00:02:21,440 --> 00:02:26,319
the what in the house so the basics then

00:02:24,480 --> 00:02:29,360
we are going to discuss a bit about the

00:02:26,319 --> 00:02:31,360
existing kernel memory layout on arm64

00:02:29,360 --> 00:02:34,160
thereafter we will discuss about

00:02:31,360 --> 00:02:36,400
flipping the arm64 kernel memory map

00:02:34,160 --> 00:02:38,400
so for accommodating the increased

00:02:36,400 --> 00:02:40,400
memory range so i'm going to talk about

00:02:38,400 --> 00:02:43,040
what happens with this flipping

00:02:40,400 --> 00:02:44,640
uh in detail then we will talk about

00:02:43,040 --> 00:02:46,000
something very important you know what

00:02:44,640 --> 00:02:47,760
happens to user space

00:02:46,000 --> 00:02:50,319
so what happens mainly to the existing

00:02:47,760 --> 00:02:52,640
user space applications which expect

00:02:50,319 --> 00:02:54,000
pointers let's say from the existing

00:02:52,640 --> 00:02:57,120
48-bit address

00:02:54,000 --> 00:02:58,400
arrange from the kernel how do they keep

00:02:57,120 --> 00:03:00,560
on working

00:02:58,400 --> 00:03:02,640
uh also we will discuss about some of

00:03:00,560 --> 00:03:04,640
the user space applications that were

00:03:02,640 --> 00:03:05,760
broken after these you know curly map

00:03:04,640 --> 00:03:07,760
changes

00:03:05,760 --> 00:03:10,000
uh thereafter we will discuss how a user

00:03:07,760 --> 00:03:12,720
space application can explicitly request

00:03:10,000 --> 00:03:15,599
addresses from the 52-bit kernel range

00:03:12,720 --> 00:03:16,720
uh later on uh i'll talk a bit about how

00:03:15,599 --> 00:03:18,800
to test the

00:03:16,720 --> 00:03:21,920
va support especially if you don't have

00:03:18,800 --> 00:03:25,519
a real arm 64 hardware how do you test

00:03:21,920 --> 00:03:27,360
you know these changes this support

00:03:25,519 --> 00:03:29,280
and at the very end i'll try to share

00:03:27,360 --> 00:03:32,799
some suggestions and

00:03:29,280 --> 00:03:36,640
suggest some next steps right so

00:03:32,799 --> 00:03:39,519
let's begin okay so i hope all of you

00:03:36,640 --> 00:03:40,480
uh here have heard about 64 hardware and

00:03:39,519 --> 00:03:43,440
you know how

00:03:40,480 --> 00:03:44,159
it is uh moved very quickly from good to

00:03:43,440 --> 00:03:46,319
have to

00:03:44,159 --> 00:03:48,400
at the minimum required feature for

00:03:46,319 --> 00:03:50,000
various computing use cases so you can

00:03:48,400 --> 00:03:52,959
think of edge routers

00:03:50,000 --> 00:03:53,439
all the way up to servers right so all

00:03:52,959 --> 00:03:55,519
you can

00:03:53,439 --> 00:03:56,959
think about super computers you know

00:03:55,519 --> 00:03:59,920
just at the

00:03:56,959 --> 00:04:02,400
top most end of the spectrum so you can

00:03:59,920 --> 00:04:05,360
think of several such existing use cases

00:04:02,400 --> 00:04:06,480
right so 64-bit hardware allows you to

00:04:05,360 --> 00:04:09,760
well in theory it

00:04:06,480 --> 00:04:13,200
allows you to connect to up to 16

00:04:09,760 --> 00:04:16,959
xd bytes of memory it's quite huge right

00:04:13,200 --> 00:04:17,519
so we recently saw silver with 64 tv

00:04:16,959 --> 00:04:20,560
byte

00:04:17,519 --> 00:04:23,199
uh memory connected to it uh and this

00:04:20,560 --> 00:04:26,240
was the x86 machine but you know uh

00:04:23,199 --> 00:04:27,840
we are going to see more and more

00:04:26,240 --> 00:04:29,360
such servers coming up on other

00:04:27,840 --> 00:04:32,240
architectures

00:04:29,360 --> 00:04:34,400
similarly for arm so we have more and

00:04:32,240 --> 00:04:36,400
more use cases coming up that require

00:04:34,400 --> 00:04:38,800
addressing the ranges larger than what

00:04:36,400 --> 00:04:40,400
is normally allowed by 48-bit virtual

00:04:38,800 --> 00:04:43,759
addressing cpu right

00:04:40,400 --> 00:04:45,440
so do note that uh there are still some

00:04:43,759 --> 00:04:47,520
limitations still right

00:04:45,440 --> 00:04:48,800
not all the processors support the full

00:04:47,520 --> 00:04:50,800
64-bit uh

00:04:48,800 --> 00:04:52,320
virtual or physical address space so

00:04:50,800 --> 00:04:53,759
we'll talk about that more in the

00:04:52,320 --> 00:04:56,000
upcoming slides

00:04:53,759 --> 00:04:58,720
also i don't know that i'll focus this

00:04:56,000 --> 00:05:00,800
talk mainly on arm 64 architecture

00:04:58,720 --> 00:05:02,000
and mainly talk only about the virtual

00:05:00,800 --> 00:05:04,479
address support uh

00:05:02,000 --> 00:05:05,039
requirements uh you know just to save on

00:05:04,479 --> 00:05:07,039
time

00:05:05,039 --> 00:05:08,800
so similar discussion applies to the

00:05:07,039 --> 00:05:12,080
physical address space requirements for

00:05:08,800 --> 00:05:14,000
arm 64. the increased uh virtuality

00:05:12,080 --> 00:05:15,120
space when we talk about a physical

00:05:14,000 --> 00:05:17,360
address space

00:05:15,120 --> 00:05:18,479
but i'll mainly concentrate this talk on

00:05:17,360 --> 00:05:20,960
arm 64

00:05:18,479 --> 00:05:21,680
and the virtual interest rates so let's

00:05:20,960 --> 00:05:24,240
see uh

00:05:21,680 --> 00:05:25,280
what happens further right so in the

00:05:24,240 --> 00:05:27,440
previous slides

00:05:25,280 --> 00:05:29,039
uh we mainly talked about the

00:05:27,440 --> 00:05:31,199
architectural limitation

00:05:29,039 --> 00:05:33,520
in the cpu design for addressing the

00:05:31,199 --> 00:05:36,160
complete 64-bit memory map

00:05:33,520 --> 00:05:37,759
so let's see how uh you know two will

00:05:36,160 --> 00:05:40,400
used architectures

00:05:37,759 --> 00:05:42,000
champions in their own right right uh

00:05:40,400 --> 00:05:43,199
fair in terms of the virtual addressing

00:05:42,000 --> 00:05:46,800
capabilities

00:05:43,199 --> 00:05:48,960
so intel uh x86 64-bit

00:05:46,800 --> 00:05:50,000
basically introduced the five-level page

00:05:48,960 --> 00:05:52,400
table support

00:05:50,000 --> 00:05:55,039
in both hardware and software in its

00:05:52,400 --> 00:05:58,240
10th uh generation isolate course so

00:05:55,039 --> 00:06:00,639
codes like i3 i5 i7

00:05:58,240 --> 00:06:01,600
these are support file level uh page

00:06:00,639 --> 00:06:04,000
tables which

00:06:01,600 --> 00:06:05,680
allow them to address up to 57 bit

00:06:04,000 --> 00:06:07,840
virtual

00:06:05,680 --> 00:06:09,600
uh note that this bumps the possible

00:06:07,840 --> 00:06:09,919
virtual addressing space all the way up

00:06:09,600 --> 00:06:12,880
to

00:06:09,919 --> 00:06:14,720
128 baby bytes and the physical

00:06:12,880 --> 00:06:17,759
addressing space also gets a bump

00:06:14,720 --> 00:06:19,440
and it it is bumped to four baby bytes

00:06:17,759 --> 00:06:22,800
quite a leap right

00:06:19,440 --> 00:06:23,680
so uh on the similar lines um 64

00:06:22,800 --> 00:06:25,680
introduced to

00:06:23,680 --> 00:06:26,880
new architecture extensions so these are

00:06:25,680 --> 00:06:31,039
called the 15-bit

00:06:26,880 --> 00:06:34,639
addressing extensions maybe the um v8.2

00:06:31,039 --> 00:06:37,280
lva and lpa

00:06:34,639 --> 00:06:38,000
where lba stands for large virtual

00:06:37,280 --> 00:06:40,400
addressing

00:06:38,000 --> 00:06:41,600
and lpa stands for large physical

00:06:40,400 --> 00:06:44,319
literacy

00:06:41,600 --> 00:06:46,000
so uh these are actually uh part of the

00:06:44,319 --> 00:06:46,960
arm made application profile

00:06:46,000 --> 00:06:50,560
architecture

00:06:46,960 --> 00:06:52,479
version 8.2 so it is expected that the

00:06:50,560 --> 00:06:53,280
arm system for course with these

00:06:52,479 --> 00:06:55,919
extensions

00:06:53,280 --> 00:06:56,479
will allow you uh to address all the way

00:06:55,919 --> 00:06:59,360
up to

00:06:56,479 --> 00:07:01,039
uh you know four baby byte of virtual

00:06:59,360 --> 00:07:03,280
and physical address space

00:07:01,039 --> 00:07:05,280
again quite a big jump as compared to

00:07:03,280 --> 00:07:08,400
the earlier maximum support of

00:07:05,280 --> 00:07:10,800
256 terabytes that was achievable with

00:07:08,400 --> 00:07:11,520
the maximum 48 bit address support that

00:07:10,800 --> 00:07:13,919
was

00:07:11,520 --> 00:07:15,680
available earlier so we saw that both

00:07:13,919 --> 00:07:19,039
x86 and arm

00:07:15,680 --> 00:07:21,680
they have you know increased the uh the

00:07:19,039 --> 00:07:22,960
the virtual and physical address support

00:07:21,680 --> 00:07:26,160
that is available

00:07:22,960 --> 00:07:28,240
and you can basically try to use these

00:07:26,160 --> 00:07:31,360
new features to develop applications

00:07:28,240 --> 00:07:35,199
that require addressing larger

00:07:31,360 --> 00:07:37,520
ram range okay so just a

00:07:35,199 --> 00:07:39,360
quick recap of the previous slide from

00:07:37,520 --> 00:07:42,000
arm 64 perspective

00:07:39,360 --> 00:07:43,440
and so we got to know that the army 8.2

00:07:42,000 --> 00:07:45,919
application processors

00:07:43,440 --> 00:07:47,400
made from the cortex a family such as

00:07:45,919 --> 00:07:51,599
the a55

00:07:47,400 --> 00:07:53,039
a75 and a76 these provide two extensions

00:07:51,599 --> 00:07:55,360
these are called the lva

00:07:53,039 --> 00:07:56,319
and the lp extensions respectively and

00:07:55,360 --> 00:07:58,560
the cpus

00:07:56,319 --> 00:08:00,960
with these extensions provide you to

00:07:58,560 --> 00:08:01,840
addre a capability with t2 address

00:08:00,960 --> 00:08:04,960
52-bit

00:08:01,840 --> 00:08:05,520
uh address ranges which is quite a big

00:08:04,960 --> 00:08:07,440
jump

00:08:05,520 --> 00:08:10,160
from the earlier support that was

00:08:07,440 --> 00:08:12,319
available with the 48-bit address space

00:08:10,160 --> 00:08:13,759
so this makes these armpors you know

00:08:12,319 --> 00:08:16,879
possible candidates for

00:08:13,759 --> 00:08:19,120
high-end applications like servers or

00:08:16,879 --> 00:08:20,080
even supercomputers you know use cases

00:08:19,120 --> 00:08:22,879
like that

00:08:20,080 --> 00:08:23,280
which also require a low power profile

00:08:22,879 --> 00:08:25,919
so

00:08:23,280 --> 00:08:26,319
a low power profile is basically a usb

00:08:25,919 --> 00:08:29,440
for

00:08:26,319 --> 00:08:31,360
usb for arm 64 cores so

00:08:29,440 --> 00:08:33,200
if you want to address larger address

00:08:31,360 --> 00:08:34,719
ranges as well as you know consume less

00:08:33,200 --> 00:08:37,120
power doing that

00:08:34,719 --> 00:08:37,760
probably you know using these arm cores

00:08:37,120 --> 00:08:41,039
make

00:08:37,760 --> 00:08:44,080
more sense for you then

00:08:41,039 --> 00:08:46,480
let's uh you know uh uh

00:08:44,080 --> 00:08:48,880
talk a bit about address spaces you know

00:08:46,480 --> 00:08:50,160
uh in the previous slide we basically

00:08:48,880 --> 00:08:53,600
tried to talk about

00:08:50,160 --> 00:08:55,519
uh 48-bit and 52-bit address spaces but

00:08:53,600 --> 00:08:58,000
basically what happens in the background

00:08:55,519 --> 00:09:00,240
when a cpu tries to read from

00:08:58,000 --> 00:09:01,519
or write to an address so let's see what

00:09:00,240 --> 00:09:04,080
happens there

00:09:01,519 --> 00:09:05,360
uh i'm sure folks here know a lot about

00:09:04,080 --> 00:09:08,080
mmu hardware

00:09:05,360 --> 00:09:08,720
already so i'm not going to take a deep

00:09:08,080 --> 00:09:12,320
dive

00:09:08,720 --> 00:09:13,760
you know explaining the role of mmu and

00:09:12,320 --> 00:09:15,279
how it separates the virtual and

00:09:13,760 --> 00:09:18,080
physical address space

00:09:15,279 --> 00:09:18,880
but uh let's see a simple example you

00:09:18,080 --> 00:09:21,200
know how to

00:09:18,880 --> 00:09:22,000
uh to understand how a hardware model

00:09:21,200 --> 00:09:24,240
works

00:09:22,000 --> 00:09:26,160
when a cpu issues a virtual address and

00:09:24,240 --> 00:09:28,560
it needs to find an equivalent

00:09:26,160 --> 00:09:29,360
physical address for that scene so here

00:09:28,560 --> 00:09:31,600
i am taking

00:09:29,360 --> 00:09:32,720
an example that is specifically suited

00:09:31,600 --> 00:09:34,800
for arm 64

00:09:32,720 --> 00:09:36,000
architecture but the basic underlying

00:09:34,800 --> 00:09:39,200
principle is valid for

00:09:36,000 --> 00:09:41,279
other architectures also so when an r64

00:09:39,200 --> 00:09:43,920
processor issues a virtual address

00:09:41,279 --> 00:09:44,720
for an instruction fetch or a data

00:09:43,920 --> 00:09:46,640
access

00:09:44,720 --> 00:09:47,839
the mmu hardware basically translates

00:09:46,640 --> 00:09:49,760
this virtual address to the

00:09:47,839 --> 00:09:52,160
corresponding physical letters

00:09:49,760 --> 00:09:53,040
and this happens uh using a phenomena

00:09:52,160 --> 00:09:56,320
which is called the

00:09:53,040 --> 00:09:58,399
translation table walk so usually

00:09:56,320 --> 00:10:01,040
a translation table walk comprises of

00:09:58,399 --> 00:10:02,959
one or more translation table lookups

00:10:01,040 --> 00:10:05,279
so in this example i am going to show

00:10:02,959 --> 00:10:06,560
three translation table levels level one

00:10:05,279 --> 00:10:09,760
is the top most level

00:10:06,560 --> 00:10:12,880
and level three is the lower most so

00:10:09,760 --> 00:10:14,480
in each translation table lookup uh you

00:10:12,880 --> 00:10:16,959
basically get a descriptor

00:10:14,480 --> 00:10:18,000
as a return which indicates one of the

00:10:16,959 --> 00:10:20,320
following either the

00:10:18,000 --> 00:10:22,399
entry is the final entry of the book in

00:10:20,320 --> 00:10:25,040
this case the entry contains the

00:10:22,399 --> 00:10:25,920
physical address and the associated

00:10:25,040 --> 00:10:28,880
permissions

00:10:25,920 --> 00:10:31,440
and attributes for this access or an

00:10:28,880 --> 00:10:33,920
additional level of lookup is required

00:10:31,440 --> 00:10:36,079
in this case the entry contains the

00:10:33,920 --> 00:10:37,360
translation table base address for the

00:10:36,079 --> 00:10:39,760
next lookup

00:10:37,360 --> 00:10:42,160
so you can see this uh from the figure

00:10:39,760 --> 00:10:43,760
uh that i have just shared in the slide

00:10:42,160 --> 00:10:45,519
that there are three level uh page

00:10:43,760 --> 00:10:47,839
tables level one is the

00:10:45,519 --> 00:10:49,519
you know the the highest one and level

00:10:47,839 --> 00:10:52,399
three is the lower most one

00:10:49,519 --> 00:10:54,720
so each descriptor is either pointing to

00:10:52,399 --> 00:10:56,560
a physical address or is pointing to the

00:10:54,720 --> 00:10:59,519
base address of the next level

00:10:56,560 --> 00:10:59,920
lookup table so now in the next slide

00:10:59,519 --> 00:11:02,000
let's

00:10:59,920 --> 00:11:03,519
look uh you know what happens from a

00:11:02,000 --> 00:11:05,920
software perspective

00:11:03,519 --> 00:11:09,519
particularly how the lens curve supports

00:11:05,920 --> 00:11:09,519
these translation tables

00:11:10,160 --> 00:11:17,120
okay so uh on this slide we will try

00:11:13,920 --> 00:11:20,480
and see how things mainly happen from uh

00:11:17,120 --> 00:11:22,720
linux point of view so the arm64

00:11:20,480 --> 00:11:24,000
architecture currently supports the base

00:11:22,720 --> 00:11:27,600
sizes of

00:11:24,000 --> 00:11:30,880
4k 16k and 64k

00:11:27,600 --> 00:11:32,720
so of these uh uh mainly

00:11:30,880 --> 00:11:33,920
uh you know the normally used space

00:11:32,720 --> 00:11:36,240
sizes are 4k and

00:11:33,920 --> 00:11:38,320
64k so 4k is mainly used for the

00:11:36,240 --> 00:11:39,200
embedded profiles whereas the 64k is

00:11:38,320 --> 00:11:41,920
used for the

00:11:39,200 --> 00:11:42,880
solar profiles uh let's look at the

00:11:41,920 --> 00:11:46,000
virtual addressing

00:11:42,880 --> 00:11:49,440
ranges uh supported when a 4k page size

00:11:46,000 --> 00:11:50,720
is used so first is a 39 bit addressing

00:11:49,440 --> 00:11:53,360
range

00:11:50,720 --> 00:11:54,720
which allows you after three translation

00:11:53,360 --> 00:11:57,279
table levels

00:11:54,720 --> 00:11:59,120
the second is the 48 bit addressing

00:11:57,279 --> 00:12:00,720
range which allows you up to four

00:11:59,120 --> 00:12:03,279
translation table levels

00:12:00,720 --> 00:12:04,639
so you will refer to the arm64 memory

00:12:03,279 --> 00:12:06,720
documentation page

00:12:04,639 --> 00:12:08,160
that resides inside the kernel uh

00:12:06,720 --> 00:12:11,839
documentation

00:12:08,160 --> 00:12:11,839
for more details

00:12:12,480 --> 00:12:18,880
further continuing on the linux details

00:12:15,839 --> 00:12:21,680
uh so for the 64k

00:12:18,880 --> 00:12:22,800
page size which is normally used for the

00:12:21,680 --> 00:12:24,880
server profile

00:12:22,800 --> 00:12:26,399
let's look at the virtual addressing

00:12:24,880 --> 00:12:28,959
range is supported so

00:12:26,399 --> 00:12:30,720
first is a 42-bit uh addressing range

00:12:28,959 --> 00:12:32,320
which allows you transfer two

00:12:30,720 --> 00:12:34,240
translation table limits

00:12:32,320 --> 00:12:36,000
the second is the 15-bit addressing

00:12:34,240 --> 00:12:39,360
range uh which

00:12:36,000 --> 00:12:41,120
allows three translation table levels

00:12:39,360 --> 00:12:43,760
note that the translation table levels

00:12:41,120 --> 00:12:46,639
for 64k and 52-bit

00:12:43,760 --> 00:12:48,880
uh addressing uh you know uh versus the

00:12:46,639 --> 00:12:50,720
4k page size and the 14-bit

00:12:48,880 --> 00:12:52,800
addressing are intentionally kept the

00:12:50,720 --> 00:12:55,200
same to minimize the effort that is

00:12:52,800 --> 00:12:57,760
required for moving from 48 bits

00:12:55,200 --> 00:12:59,680
all the way up to 52-bit address space

00:12:57,760 --> 00:13:00,560
just uh the number of the descriptors in

00:12:59,680 --> 00:13:03,680
the first

00:13:00,560 --> 00:13:05,120
translation level are expanded for the

00:13:03,680 --> 00:13:07,040
52-bit addressing

00:13:05,120 --> 00:13:08,399
again you can refer to the ancestry from

00:13:07,040 --> 00:13:10,639
memory documentation

00:13:08,399 --> 00:13:14,240
uh page that resides in the

00:13:10,639 --> 00:13:14,240
documentation for more details

00:13:16,000 --> 00:13:21,279
okay so uh in my view the best way to

00:13:19,120 --> 00:13:23,920
understand the 52-bit address space on

00:13:21,279 --> 00:13:24,639
r64 is to have a look at an example

00:13:23,920 --> 00:13:27,920
right

00:13:24,639 --> 00:13:29,760
so uh we saw in the previous slide that

00:13:27,920 --> 00:13:32,240
the 52-bit support is only available

00:13:29,760 --> 00:13:34,880
with a page size of 64k

00:13:32,240 --> 00:13:35,920
and it requires three levels of page

00:13:34,880 --> 00:13:38,560
tables

00:13:35,920 --> 00:13:39,040
so let's see how the three level uh

00:13:38,560 --> 00:13:41,600
kernel

00:13:39,040 --> 00:13:42,720
page tables yeah the for the top most

00:13:41,600 --> 00:13:46,240
one is the page

00:13:42,720 --> 00:13:48,399
global directory pgd ah then the

00:13:46,240 --> 00:13:49,440
next one is called page middle directory

00:13:48,399 --> 00:13:52,480
pnd

00:13:49,440 --> 00:13:54,560
and the last one pde which is

00:13:52,480 --> 00:13:56,079
called the page table entries fit into

00:13:54,560 --> 00:13:58,480
the picture here

00:13:56,079 --> 00:14:00,560
uh let's start from our earlier premise

00:13:58,480 --> 00:14:01,519
the core issue the 64-bit virtual

00:14:00,560 --> 00:14:03,760
address

00:14:01,519 --> 00:14:05,120
and we want to find out an equivalent

00:14:03,760 --> 00:14:08,320
physical address for the same

00:14:05,120 --> 00:14:10,639
on arm 64. so on the extreme left

00:14:08,320 --> 00:14:13,360
of the picture you can see the tpbr

00:14:10,639 --> 00:14:15,360
select bit which is pick number 63

00:14:13,360 --> 00:14:17,920
so it selects basically this between the

00:14:15,360 --> 00:14:21,040
kernel space and user space addresses

00:14:17,920 --> 00:14:21,839
so ttbrx holds basically the base

00:14:21,040 --> 00:14:26,560
address of the

00:14:21,839 --> 00:14:29,199
level 1 page tip now bits 51 down to 42

00:14:26,560 --> 00:14:30,079
in the incoming virtual address tell us

00:14:29,199 --> 00:14:33,360
about the

00:14:30,079 --> 00:14:36,399
pgd index in the level 1 table

00:14:33,360 --> 00:14:38,560
similarly bits 41 down to 29

00:14:36,399 --> 00:14:40,320
in the incoming virtual address tell us

00:14:38,560 --> 00:14:43,440
about the pmd index

00:14:40,320 --> 00:14:46,240
in the level 2 table and lastly it's

00:14:43,440 --> 00:14:46,959
28 down to 16 in the incoming virtual

00:14:46,240 --> 00:14:50,160
address

00:14:46,959 --> 00:14:54,800
tell us about the pt index in the level

00:14:50,160 --> 00:14:57,680
3 tape so finally the derived pte value

00:14:54,800 --> 00:14:58,560
is and the lowermost 16 bits of the

00:14:57,680 --> 00:15:01,519
virtual address

00:14:58,560 --> 00:15:02,959
are combined to determine the final

00:15:01,519 --> 00:15:05,839
physical address value

00:15:02,959 --> 00:15:06,560
so i hope this example makes things more

00:15:05,839 --> 00:15:09,199
clear

00:15:06,560 --> 00:15:10,560
so as you can see in the figure we have

00:15:09,199 --> 00:15:13,680
three page tables

00:15:10,560 --> 00:15:15,680
level one level two level three and

00:15:13,680 --> 00:15:16,720
then bands of the bits of the incoming

00:15:15,680 --> 00:15:19,839
virtual addresses

00:15:16,720 --> 00:15:22,720
are used to index into these uh

00:15:19,839 --> 00:15:23,600
tables i hope uh you know this makes

00:15:22,720 --> 00:15:26,079
things

00:15:23,600 --> 00:15:27,360
uh more clear again feel uh free to

00:15:26,079 --> 00:15:30,079
refer to the arm v8

00:15:27,360 --> 00:15:30,399
documentation from arm mainly regarding

00:15:30,079 --> 00:15:33,680
the

00:15:30,399 --> 00:15:36,560
address translation for more details

00:15:33,680 --> 00:15:38,800
right so we come to uh you know uh

00:15:36,560 --> 00:15:41,839
interesting uh

00:15:38,800 --> 00:15:43,600
aspect here so how do we decide the

00:15:41,839 --> 00:15:44,240
kernel design approach to support both

00:15:43,600 --> 00:15:46,399
the older

00:15:44,240 --> 00:15:48,639
arm 64 cpus which don't support the

00:15:46,399 --> 00:15:51,199
15-bit extensions and also support the

00:15:48,639 --> 00:15:52,800
newer ones which do so in the kernel we

00:15:51,199 --> 00:15:53,759
have selected an approach to keep a

00:15:52,800 --> 00:15:55,759
single binary

00:15:53,759 --> 00:15:57,920
and make a decision at the early boot

00:15:55,759 --> 00:16:00,560
time to check if the underlying hardware

00:15:57,920 --> 00:16:02,959
is supposed to 52-bit extensions or not

00:16:00,560 --> 00:16:04,399
so if it does the kernel uses a 15-bit

00:16:02,959 --> 00:16:06,399
virtual addressing mode

00:16:04,399 --> 00:16:09,120
otherwise it falls back to the default

00:16:06,399 --> 00:16:10,720
48-bit or low virtual addressing mode

00:16:09,120 --> 00:16:13,279
so let's take an example of two

00:16:10,720 --> 00:16:15,839
platforms the ampere emac

00:16:13,279 --> 00:16:17,680
arm64 world station which doesn't have

00:16:15,839 --> 00:16:20,399
the support for the new extensions

00:16:17,680 --> 00:16:23,920
and the newer fujitsu fx 700 which

00:16:20,399 --> 00:16:28,160
claims support for the v8.2 extensions

00:16:23,920 --> 00:16:31,279
so uh uh i'm sorry so uh

00:16:28,160 --> 00:16:32,399
you can as you can see uh in the figure

00:16:31,279 --> 00:16:35,759
here

00:16:32,399 --> 00:16:37,360
uh that you know the figure demonstrate

00:16:35,759 --> 00:16:38,160
that the decision about the addressing

00:16:37,360 --> 00:16:40,720
range

00:16:38,160 --> 00:16:41,440
uh to support is made at the early boot

00:16:40,720 --> 00:16:44,000
time

00:16:41,440 --> 00:16:46,240
and accordingly either the 48 bit or the

00:16:44,000 --> 00:16:48,480
52-bit addressing range is used

00:16:46,240 --> 00:16:50,000
uh again you can refer to the arm 64

00:16:48,480 --> 00:16:52,320
memory documentation

00:16:50,000 --> 00:16:54,399
page inside the kernel documentation for

00:16:52,320 --> 00:16:56,800
more details

00:16:54,399 --> 00:16:57,759
uh fair enough so on this slide we'll

00:16:56,800 --> 00:17:00,000
just quickly

00:16:57,759 --> 00:17:01,120
look at the kernel variables which the

00:17:00,000 --> 00:17:03,040
kernel code uses

00:17:01,120 --> 00:17:04,880
mainly to make sure that it handles both

00:17:03,040 --> 00:17:05,839
the 48-bit virtual address as well as

00:17:04,880 --> 00:17:08,959
the 58 put

00:17:05,839 --> 00:17:11,760
52-bit virtual address with

00:17:08,959 --> 00:17:12,640
and also it is able to make an early

00:17:11,760 --> 00:17:15,439
time deletion

00:17:12,640 --> 00:17:17,600
to switch from 48-bit to the 52-bit

00:17:15,439 --> 00:17:20,160
virtual address space if required

00:17:17,600 --> 00:17:21,760
so it uses uh mainly three variables uh

00:17:20,160 --> 00:17:22,240
there are others as well but you know

00:17:21,760 --> 00:17:24,480
just

00:17:22,240 --> 00:17:25,600
uh not very useful for this discussion

00:17:24,480 --> 00:17:27,600
so let's uh

00:17:25,600 --> 00:17:29,280
discuss about these three variables

00:17:27,600 --> 00:17:31,600
first these are the near bits

00:17:29,280 --> 00:17:32,559
uh we have its minimum and we have its

00:17:31,600 --> 00:17:35,440
actual

00:17:32,559 --> 00:17:37,120
so the wheelbase uh is actually denoting

00:17:35,440 --> 00:17:37,919
the maximum size of the virtual address

00:17:37,120 --> 00:17:40,480
space

00:17:37,919 --> 00:17:41,919
the v8's minimum is denoting the minimum

00:17:40,480 --> 00:17:42,480
size of the virtual address space

00:17:41,919 --> 00:17:45,919
whereas

00:17:42,480 --> 00:17:46,640
vmware's actual denotes the actual size

00:17:45,919 --> 00:17:48,799
of the va

00:17:46,640 --> 00:17:50,240
space so if you really want to check the

00:17:48,799 --> 00:17:53,039
vapor space

00:17:50,240 --> 00:17:53,679
range supported by your running arm 64

00:17:53,039 --> 00:17:55,600
curl

00:17:53,679 --> 00:17:58,080
you should look at the value reported by

00:17:55,600 --> 00:18:01,120
the variable behave its action

00:17:58,080 --> 00:18:04,160
so let's uh move further uh

00:18:01,120 --> 00:18:06,080
so uh do we need to keep something uh

00:18:04,160 --> 00:18:07,760
additional in mind when we talk about

00:18:06,080 --> 00:18:09,360
the increased memory map support in

00:18:07,760 --> 00:18:12,480
arm64

00:18:09,360 --> 00:18:12,880
surely uh we do need to keep in mind

00:18:12,480 --> 00:18:14,720
that

00:18:12,880 --> 00:18:17,440
you know the kernel memory layout was

00:18:14,720 --> 00:18:18,720
flipped uh starting from kernel version

00:18:17,440 --> 00:18:21,679
5.4

00:18:18,720 --> 00:18:22,640
to allow a larger virtual it is space

00:18:21,679 --> 00:18:24,480
support

00:18:22,640 --> 00:18:26,080
let's look at the figures on the slide

00:18:24,480 --> 00:18:28,960
to understand this better

00:18:26,080 --> 00:18:31,360
by default with up to 48-bit virtual it

00:18:28,960 --> 00:18:33,840
is support the arm64 kernel map

00:18:31,360 --> 00:18:36,000
looks something shown on the left side

00:18:33,840 --> 00:18:38,000
uh the direct linear range was

00:18:36,000 --> 00:18:40,160
you know mapped at the farthest end of

00:18:38,000 --> 00:18:43,360
the of the memory range

00:18:40,160 --> 00:18:46,799
whereas the kernel text range was uh

00:18:43,360 --> 00:18:49,520
kept near the lower uh address ranges

00:18:46,799 --> 00:18:51,679
for the 52-bit support we flipped

00:18:49,520 --> 00:18:54,400
basically the

00:18:51,679 --> 00:18:56,080
kernel memory map but we decided to keep

00:18:54,400 --> 00:18:59,280
the current text addresses same

00:18:56,080 --> 00:19:00,240
as earlier so the direct linear map

00:18:59,280 --> 00:19:04,240
range goes

00:19:00,240 --> 00:19:07,520
from ffffffff all zeros

00:19:04,240 --> 00:19:09,200
address and whereas after a gap of the

00:19:07,520 --> 00:19:12,080
kernel address

00:19:09,200 --> 00:19:13,600
sanitizer the casan uh the kernel text

00:19:12,080 --> 00:19:16,640
and other addressing ranges

00:19:13,600 --> 00:19:18,240
uh they are kept so this flipped kernel

00:19:16,640 --> 00:19:20,240
kernel map actually causes some

00:19:18,240 --> 00:19:20,960
interesting problems in the user space

00:19:20,240 --> 00:19:24,720
so

00:19:20,960 --> 00:19:26,559
let's uh look at them in the next line

00:19:24,720 --> 00:19:29,039
right then so what happens in the user

00:19:26,559 --> 00:19:30,320
space then unfortunately due to the flip

00:19:29,039 --> 00:19:32,960
in the kernel memory map

00:19:30,320 --> 00:19:34,640
a few use base applications especially

00:19:32,960 --> 00:19:35,280
the ones that are used to debug live

00:19:34,640 --> 00:19:37,120
kernel

00:19:35,280 --> 00:19:39,039
or which are used to analyze the vm

00:19:37,120 --> 00:19:41,360
cooldowns they get broken

00:19:39,039 --> 00:19:42,160
up just interrupt just wanted to let you

00:19:41,360 --> 00:19:44,640
know that there are

00:19:42,160 --> 00:19:45,360
five minutes left so far we don't have

00:19:44,640 --> 00:19:48,480
questions

00:19:45,360 --> 00:19:51,840
so go ahead

00:19:48,480 --> 00:19:54,640
sure no problem okay so uh

00:19:51,840 --> 00:19:55,200
unfortunately because of this flip uh we

00:19:54,640 --> 00:19:57,919
actually

00:19:55,200 --> 00:19:59,520
have some use case applications broken

00:19:57,919 --> 00:20:01,360
uh the main reason for that is that

00:19:59,520 --> 00:20:03,039
these applications also need to perform

00:20:01,360 --> 00:20:04,080
a virtual address to physical address

00:20:03,039 --> 00:20:06,080
conversion

00:20:04,080 --> 00:20:07,360
so you can see that some applications

00:20:06,080 --> 00:20:09,679
like exit 2

00:20:07,360 --> 00:20:10,799
scratch utility and make them files

00:20:09,679 --> 00:20:12,880
these were broken

00:20:10,799 --> 00:20:14,320
after the changes starting from kernel

00:20:12,880 --> 00:20:16,320
versions 5.4

00:20:14,320 --> 00:20:18,640
so i have proposed some fixes for these

00:20:16,320 --> 00:20:20,880
utilities while some have been accepted

00:20:18,640 --> 00:20:23,840
others are still pending some discussion

00:20:20,880 --> 00:20:24,799
so you can uh you know look at these uh

00:20:23,840 --> 00:20:27,120
details uh

00:20:24,799 --> 00:20:28,240
using the hyperlinks on the slides uh

00:20:27,120 --> 00:20:30,400
and just have a look

00:20:28,240 --> 00:20:32,400
you know just to understand what happens

00:20:30,400 --> 00:20:34,000
so i know the million dollar question

00:20:32,400 --> 00:20:36,320
coming up right now in your mind

00:20:34,000 --> 00:20:38,080
is what would be you know what happens

00:20:36,320 --> 00:20:40,000
when uh

00:20:38,080 --> 00:20:42,240
you know we use other applications which

00:20:40,000 --> 00:20:43,039
are not used for debugging kernels per

00:20:42,240 --> 00:20:44,400
se

00:20:43,039 --> 00:20:46,159
what happens to these existing

00:20:44,400 --> 00:20:48,080
applications do they break because

00:20:46,159 --> 00:20:50,240
they are expecting a address from the

00:20:48,080 --> 00:20:53,039
kernel which is 50 48 bit

00:20:50,240 --> 00:20:53,840
so the answer is no because we decided

00:20:53,039 --> 00:20:55,760
to keep

00:20:53,840 --> 00:20:57,440
an opt-in model for the use space

00:20:55,760 --> 00:20:59,200
applications that is the kernel by

00:20:57,440 --> 00:21:00,640
default will return address from the

00:20:59,200 --> 00:21:03,440
48-bit range

00:21:00,640 --> 00:21:05,200
right and if the user space applications

00:21:03,440 --> 00:21:07,280
really want a

00:21:05,200 --> 00:21:08,799
pointer from the 50 bit range they can

00:21:07,280 --> 00:21:11,760
explicitly pass a hint

00:21:08,799 --> 00:21:13,840
let's say the map call to request a

00:21:11,760 --> 00:21:15,919
address in that range

00:21:13,840 --> 00:21:18,240
uh so the obvious question that would

00:21:15,919 --> 00:21:19,520
pop in your mind now is how can i test

00:21:18,240 --> 00:21:21,919
the 52-bit uh

00:21:19,520 --> 00:21:23,200
virtuality support especially if you

00:21:21,919 --> 00:21:26,400
don't have any real

00:21:23,200 --> 00:21:28,640
arm 64 hardware you need not worry

00:21:26,400 --> 00:21:30,960
simulation is actually your friend here

00:21:28,640 --> 00:21:34,400
so first option is using quimu

00:21:30,960 --> 00:21:36,640
so you can basically use uh

00:21:34,400 --> 00:21:40,240
i have used an example of running the

00:21:36,640 --> 00:21:42,320
query m64 guest on my fedora x86 host

00:21:40,240 --> 00:21:43,360
here for the same you can use the word

00:21:42,320 --> 00:21:45,840
builder tool

00:21:43,360 --> 00:21:46,480
here i'm creating a figure of 30 arm64

00:21:45,840 --> 00:21:48,640
guest

00:21:46,480 --> 00:21:50,480
then you can launch the same using pemu

00:21:48,640 --> 00:21:53,200
the second option is to use the

00:21:50,480 --> 00:21:55,120
v8 fast simulator model which can be

00:21:53,200 --> 00:21:56,960
downloaded freely from the arm website

00:21:55,120 --> 00:21:59,280
you can get more information about these

00:21:56,960 --> 00:22:01,520
models from the arm website i have

00:21:59,280 --> 00:22:04,080
added a link for that in my slides you

00:22:01,520 --> 00:22:05,679
can exercise linux debian or fedora

00:22:04,080 --> 00:22:07,760
emojis on that same

00:22:05,679 --> 00:22:10,320
so you can see the screenshot of the

00:22:07,760 --> 00:22:13,840
simulator model running a fedora 30 arm

00:22:10,320 --> 00:22:16,000
64 image in the slide below

00:22:13,840 --> 00:22:17,760
right then so what are some of the pain

00:22:16,000 --> 00:22:18,159
points in the next step the first step

00:22:17,760 --> 00:22:20,640
is

00:22:18,159 --> 00:22:22,159
to fix the broken debugging uh related

00:22:20,640 --> 00:22:24,080
use space applications

00:22:22,159 --> 00:22:26,480
which is a work in progress i hope these

00:22:24,080 --> 00:22:26,880
will be fixed very soon the next would

00:22:26,480 --> 00:22:29,200
be

00:22:26,880 --> 00:22:30,799
you know just to make yourself and

00:22:29,200 --> 00:22:33,760
others aware of the flipped corner of

00:22:30,799 --> 00:22:36,240
this map after the colonel version 5.4

00:22:33,760 --> 00:22:38,320
so this might uh you know cause some

00:22:36,240 --> 00:22:40,720
issues so just be aware of that

00:22:38,320 --> 00:22:43,120
also newer or willing uh application

00:22:40,720 --> 00:22:44,080
owners can give the 52-bit addressing a

00:22:43,120 --> 00:22:46,880
try they can

00:22:44,080 --> 00:22:48,880
uh pass for example a hit specific into

00:22:46,880 --> 00:22:51,120
their map call just to see that

00:22:48,880 --> 00:22:53,360
they can address get an address that is

00:22:51,120 --> 00:22:55,760
in the 52-bit range from the kernel

00:22:53,360 --> 00:22:57,520
the next is expect more changes around

00:22:55,760 --> 00:23:00,640
this feature in the near future

00:22:57,520 --> 00:23:02,720
because it's still getting stabilized so

00:23:00,640 --> 00:23:04,880
for example earth has already you know

00:23:02,720 --> 00:23:06,960
merged a path set to extend the

00:23:04,880 --> 00:23:08,320
very clean map range for the 52-bit

00:23:06,960 --> 00:23:10,480
configurations

00:23:08,320 --> 00:23:12,480
so towards then i would just say test

00:23:10,480 --> 00:23:14,480
the upstream kernel if possible

00:23:12,480 --> 00:23:17,039
and you know report issues if there are

00:23:14,480 --> 00:23:20,080
any upstream so

00:23:17,039 --> 00:23:22,080
we have a question from david um other

00:23:20,080 --> 00:23:25,520
pending discussion requirement

00:23:22,080 --> 00:23:27,600
tools like tech sex it's uh related

00:23:25,520 --> 00:23:30,720
directly to the memory mapping or other

00:23:27,600 --> 00:23:30,720
related issues

00:23:31,039 --> 00:23:35,200
oh sorry could you repeat that sure

00:23:33,280 --> 00:23:38,080
other pending discussion

00:23:35,200 --> 00:23:40,000
requirements like access related

00:23:38,080 --> 00:23:43,120
directly to the memory mapping

00:23:40,000 --> 00:23:45,120
for other related issues yes

00:23:43,120 --> 00:23:47,679
so mainly it's memory mapping so there

00:23:45,120 --> 00:23:49,039
were some uh user space applications

00:23:47,679 --> 00:23:50,720
that were broken so

00:23:49,039 --> 00:23:53,200
i think these should be fixed pretty

00:23:50,720 --> 00:23:55,520
soon also the 52-bit

00:23:53,200 --> 00:23:56,480
hardware is just you know coming up we

00:23:55,520 --> 00:23:58,080
started just

00:23:56,480 --> 00:24:00,080
testing that mainly the vehicle

00:23:58,080 --> 00:24:02,720
available was a simulator model

00:24:00,080 --> 00:24:04,240
now we are seeing a few uh hardware

00:24:02,720 --> 00:24:06,559
coming up

00:24:04,240 --> 00:24:07,679
that that support these extensions so

00:24:06,559 --> 00:24:10,000
the discussions are

00:24:07,679 --> 00:24:12,400
mainly you know uh centered around

00:24:10,000 --> 00:24:15,120
what's broken and what can be addressed

00:24:12,400 --> 00:24:16,320
through the new uh flipped kernel memory

00:24:15,120 --> 00:24:19,440
map reach

00:24:16,320 --> 00:24:21,440
uh but yeah i expect that there

00:24:19,440 --> 00:24:22,480
would be more you know more uh

00:24:21,440 --> 00:24:25,120
descriptions and more

00:24:22,480 --> 00:24:27,200
changes uh so just keep an eye on the on

00:24:25,120 --> 00:24:30,559
64 memory.txt

00:24:27,200 --> 00:24:38,080
i think it would be changed

00:24:30,559 --> 00:24:38,080

YouTube URL: https://www.youtube.com/watch?v=j1kQbQ7EUGA


