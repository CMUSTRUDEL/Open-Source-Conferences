Title: The history of a linux kernel design flaw - DevConf.CZ 2020
Publication date: 2020-03-26
Playlist: DevConfCZ 2020
Description: 
	Speakers: Dmitry Levin

This talk about fixing long-standing bugs in the Linux kernel is based on a real story of a design flaw in the Linux kernel on x86-64 architecture. That design flaw existed since the beginning of Linux x86-64 support in 2001 and was finally fixed in 2019.

18 years ago, when the first Linux kernel with x86-64 architecture support was released, it was capable of running processes that execute native x86-64 CPU instructions, and processes that execute legacy x86 CPU instructions. This feature was very popular in the early years of x86-64 architecture when the amount of already existing legacy 32-bit binary code exceeded the amount of native 64-bit binary code.
The feature was implemented in a way that allowed native 64-bit processes to invoke both native 64-bit system calls and compat 32-bit system calls - a fact that was not widely known and caused quite a few surprises for many years to come.
At the same time Linux kernel provided no API that would allow user processes to determine in a reliable way whether the system call being invoked is a native 64-bit system call or a compat 32-bit one. For this reason debuggers and system call tracers traditionally decided on the bitness of syscalls by looking at the value of CS register that describes the bitness of processes.
While this approach works in most cases, it fails miserably when the assumption that system call bitness matches the process bitness is not valid.
This problem was reported many years ago. The first report I'm aware of is the bug #459820 reported in 2008 to the Debian bug tracker. That bug report contains an example program which invokes a 32-bit 'fork' system call, deceiving strace to think it's a 64-bit 'open' system call with weird arguments and return code.
The alternative method of obtaining system call bitness that is also known since the early years of x86-64 architecture is to fetch from the process memory and analyze the opcode of the CPU instruction that caused the system call invocation. This approach is also not reliable because reading process memory after the system call invocation is inherently racy, and in 2012 Linus Torvalds even produced a short example code that reliably deceives the tracer.
The fact that Linux kernel provided no API to obtain this crucial piece of system call information in a reliable way was recognized by Linux kernel developers as a problem many years ago. For example, in the beginning of 2012 there was a lively discussion on that matter. Many kernel hackers took part, many interesting ideas were discussed, but, unfortunately, there were no follow-up because none of these people were interested enough to implement a solution for the problem.
It took many years to find people who really care and were capable of delivering a fix. It was November 2018 when the first RFC patch to fix the problem by extending ptrace API was proposed by Elvira Khabirova. Shortly after the discussion that followed there was a second edition consisting of 16 patches, 15 of them were extending and fixing internal Linux kernel API on various architectures. As result of subsequent iterations the patchset grew further, it affected all architectures supported by the kernel and extended audit and ptrace subsystems. To get it accepted into the kernel, we had no other choice but to split it into parts and upstream them via appropriate maintainer trees. It was an amusing process full of pings.
To cut story short, it took almost 9 months to get all 29 patches implementing PTRACE_GET_SYSCALL_INFO API merged into the kernel, the last patch of the series was accepted in July 2019, the first Linux kernel release with this feature is 5.3.
PTRACE_GET_SYSCALL_INFO API is supported in strace starting with version 4.26 released in December 2018. strace performs a runtime check for PTRACE_GET_SYSCALL_INFO support in the kernel and automatically switches to use this API when it's available. Other userspace debuggers and tracers will follow.

[ https://sched.co/YOrK ]

--
Recordings of talks at DevConf are a community effort. Unfortunately not everything works perfectly every time. If you're interested in helping us improve, let us know.
Captions: 
	00:00:01,590 --> 00:00:07,660
hello everybody thank you for coming my

00:00:05,259 --> 00:00:10,719
name is Mitch living and they chief

00:00:07,660 --> 00:00:13,659
Software Architect of my site and also I

00:00:10,719 --> 00:00:18,420
am them maintain over stress for more

00:00:13,659 --> 00:00:23,620
than 10 years now I usually talk about

00:00:18,420 --> 00:00:28,630
modern features of a stress and today is

00:00:23,620 --> 00:00:33,100
not an exception of the it's also a

00:00:28,630 --> 00:00:38,339
history the history of a Linux kernel

00:00:33,100 --> 00:00:47,350
design flaw this history starts back in

00:00:38,339 --> 00:00:48,870
2001 when x86 64 architecture was first

00:00:47,350 --> 00:00:54,670
implemented

00:00:48,870 --> 00:01:00,280
actually it was Linux kernel where if

00:00:54,670 --> 00:01:02,139
the first universal care know where the

00:01:00,280 --> 00:01:06,700
support of this new architecture was

00:01:02,139 --> 00:01:11,100
added other followed later but yeah so

00:01:06,700 --> 00:01:16,570
the main feature of this obviously

00:01:11,100 --> 00:01:20,890
64-bit architecture was that it could

00:01:16,570 --> 00:01:23,560
execute both native 64-bit instructions

00:01:20,890 --> 00:01:28,990
but also legacy little bit instructions

00:01:23,560 --> 00:01:34,180
this is probably the reason why it

00:01:28,990 --> 00:01:37,480
defeated other competitor but the way it

00:01:34,180 --> 00:01:40,660
was implemented in the kernel it allowed

00:01:37,480 --> 00:01:45,000
to not just to mix the instructions but

00:01:40,660 --> 00:01:48,760
also to mix system calls so you could

00:01:45,000 --> 00:01:54,220
invoke in the same process in the same

00:01:48,760 --> 00:01:57,610
64-bit process both native 64-bit system

00:01:54,220 --> 00:02:01,510
calls and legacy fetch 2 bit system

00:01:57,610 --> 00:02:08,009
calls this feature was not very widely

00:02:01,510 --> 00:02:12,490
known not very well documented and it I

00:02:08,009 --> 00:02:14,680
was a witness of many cases where people

00:02:12,490 --> 00:02:21,280
were genuinely surprised

00:02:14,680 --> 00:02:25,530
to find this out so what does the Linux

00:02:21,280 --> 00:02:31,330
kernel API provide to find out

00:02:25,530 --> 00:02:34,780
information about system call for a user

00:02:31,330 --> 00:02:38,500
space tracer or the burger you can

00:02:34,780 --> 00:02:41,170
obtain the system call number the value

00:02:38,500 --> 00:02:45,640
of cs register that describes the

00:02:41,170 --> 00:02:51,360
business of the process their address of

00:02:45,640 --> 00:02:58,540
the CPU instruction that was invoked but

00:02:51,360 --> 00:03:02,709
there was no API to tell exactly what

00:02:58,540 --> 00:03:09,760
was the system call what was it a 64-bit

00:03:02,709 --> 00:03:11,860
or 32-bit so what could user-space

00:03:09,760 --> 00:03:14,290
dressen's debuggers do then they needed

00:03:11,860 --> 00:03:16,209
to obtain the system call information so

00:03:14,290 --> 00:03:19,900
they fitted this system call number from

00:03:16,209 --> 00:03:23,079
one register fetched the value of cs

00:03:19,900 --> 00:03:26,650
register to find out the business of

00:03:23,079 --> 00:03:31,780
process and they they did a wild guess

00:03:26,650 --> 00:03:36,280
so if the process is 64-bit then the

00:03:31,780 --> 00:03:39,400
Cisco also has to be 64-bit and if it's

00:03:36,280 --> 00:03:41,230
32-bit the process then the system call

00:03:39,400 --> 00:03:45,690
should be why not

00:03:41,230 --> 00:03:48,910
it's quite nature right and then they

00:03:45,690 --> 00:03:51,280
like suppose they know the business of

00:03:48,910 --> 00:03:54,730
system call they phage system called

00:03:51,280 --> 00:03:56,799
agreements according to this or using

00:03:54,730 --> 00:04:01,859
the method appropriate to this business

00:03:56,799 --> 00:04:06,329
and they were working this way later

00:04:01,859 --> 00:04:10,209
slightly more fast methods of obtaining

00:04:06,329 --> 00:04:12,220
registers was introduced in the Linux

00:04:10,209 --> 00:04:18,039
kernels so traces started

00:04:12,220 --> 00:04:22,000
fetching the whole register set but the

00:04:18,039 --> 00:04:26,530
register set sent by the kernel depends

00:04:22,000 --> 00:04:28,330
on the business of process so from a

00:04:26,530 --> 00:04:32,620
system called business specs respect

00:04:28,330 --> 00:04:34,900
if nothing changed and there is no

00:04:32,620 --> 00:04:38,349
surprise that it depends on the person's

00:04:34,900 --> 00:04:40,930
business because the burgers may need to

00:04:38,349 --> 00:04:42,840
fetch registers for all kinds of

00:04:40,930 --> 00:04:46,960
purposes not just for system calls and

00:04:42,840 --> 00:04:49,780
strictly speaking there is no direct

00:04:46,960 --> 00:04:52,240
link between process business and system

00:04:49,780 --> 00:04:57,479
called business except that usually they

00:04:52,240 --> 00:04:59,229
they match very often very much but

00:04:57,479 --> 00:05:01,719
sometimes they don't

00:04:59,229 --> 00:05:05,710
so what happens when they don't match

00:05:01,719 --> 00:05:08,349
first time first time known to me when

00:05:05,710 --> 00:05:11,919
this buck was reported it was reported

00:05:08,349 --> 00:05:17,169
against against this trace to Devon but

00:05:11,919 --> 00:05:22,330
Jerry back in 2008 so there was a very

00:05:17,169 --> 00:05:23,740
simple reproducer so here you can see

00:05:22,330 --> 00:05:26,020
are very similar reproduced is

00:05:23,740 --> 00:05:28,900
essentially the same as one you can find

00:05:26,020 --> 00:05:30,879
and then bug report so what it

00:05:28,900 --> 00:05:37,659
essentially does it just prints the

00:05:30,879 --> 00:05:42,490
string then invokes this 32 bit system

00:05:37,659 --> 00:05:46,469
call using in succeed hexadecimal 80 and

00:05:42,490 --> 00:05:48,969
then prints another another string this

00:05:46,469 --> 00:05:53,190
funny-looking system call is actually

00:05:48,969 --> 00:06:00,069
fork as you can see if you if you

00:05:53,190 --> 00:06:02,550
remember this X this 86 ABI the number

00:06:00,069 --> 00:06:06,879
of system call is stored in EAX register

00:06:02,550 --> 00:06:13,000
it's number 2 number 2 in in the system

00:06:06,879 --> 00:06:15,370
call table of x x86 a is fork so if you

00:06:13,000 --> 00:06:18,099
you can compile this program run this

00:06:15,370 --> 00:06:21,069
program and will see something like this

00:06:18,099 --> 00:06:24,460
so there will be a line printed and then

00:06:21,069 --> 00:06:28,060
two lines printed by by both purchases

00:06:24,460 --> 00:06:30,099
it will look yeah I think purchased IDs

00:06:28,060 --> 00:06:34,110
will be different but all the rest will

00:06:30,099 --> 00:06:38,529
look like this but if you run this

00:06:34,110 --> 00:06:42,420
program under stress it will probably be

00:06:38,529 --> 00:06:45,370
surprised because you will see something

00:06:42,420 --> 00:06:49,780
something really odd

00:06:45,370 --> 00:06:53,340
like you see the line is printed all

00:06:49,780 --> 00:07:02,170
right then some processes attach it and

00:06:53,340 --> 00:07:04,540
then you like see that you see the very

00:07:02,170 --> 00:07:08,170
odd-looking open system call with

00:07:04,540 --> 00:07:30,010
ridiculous arguments and impossible or

00:07:08,170 --> 00:07:33,970
return return code what all subsequent

00:07:30,010 --> 00:07:39,400
system calls look as usual making the

00:07:33,970 --> 00:07:41,920
whole picture very good yeah you

00:07:39,400 --> 00:07:45,190
actually can run this program several

00:07:41,920 --> 00:07:48,820
times and every time we will likely see

00:07:45,190 --> 00:07:53,040
different set of impossible combinations

00:07:48,820 --> 00:07:58,540
of open Flags

00:07:53,040 --> 00:08:00,850
so for me it resembles a toy I had my

00:07:58,540 --> 00:08:04,210
childhood a kaleidoscope

00:08:00,850 --> 00:08:10,840
you turn it slightly and you get every

00:08:04,210 --> 00:08:13,120
time nu nu nu nice looking picture the

00:08:10,840 --> 00:08:19,320
reason for this is Colonel adjacent

00:08:13,120 --> 00:08:22,950
amuse ation so all this strange flakes

00:08:19,320 --> 00:08:26,920
they are actually a cabbage in registers

00:08:22,950 --> 00:08:30,880
and this cabbage depends on what's left

00:08:26,920 --> 00:08:33,669
from previous system calls and they

00:08:30,880 --> 00:08:37,990
depend on our randomized addresses

00:08:33,669 --> 00:08:40,060
research so it was not the case at the

00:08:37,990 --> 00:08:47,380
time of bark report but nowadays you can

00:08:40,060 --> 00:08:51,160
use this as a nice greater scope so what

00:08:47,380 --> 00:08:53,980
are the alternatives what could use the

00:08:51,160 --> 00:08:56,080
space traces do there is an alternative

00:08:53,980 --> 00:09:01,720
method of obtaining

00:08:56,080 --> 00:09:05,140
system conformation uh so you can you

00:09:01,720 --> 00:09:09,760
know the the address of instruction

00:09:05,140 --> 00:09:13,930
pointer you can step to bytes back and

00:09:09,760 --> 00:09:15,550
fetch from that address supposedly the

00:09:13,930 --> 00:09:20,500
instruction that was used to invoke that

00:09:15,550 --> 00:09:22,630
system call yeah and then decide on the

00:09:20,500 --> 00:09:26,380
of court what was the business of system

00:09:22,630 --> 00:09:28,600
call and and so on what's the problem

00:09:26,380 --> 00:09:30,399
when you are teaching something from

00:09:28,600 --> 00:09:41,279
memory there is entering the race

00:09:30,399 --> 00:09:41,279
condition I think so

00:09:48,049 --> 00:10:04,739
may continue sorry you're like you're

00:09:56,909 --> 00:10:07,979
too loud sorry you don't have to

00:10:04,739 --> 00:10:11,129
they are downloaded on this scene okay

00:10:07,979 --> 00:10:18,149
then you when you have to to watch

00:10:11,129 --> 00:10:21,059
carefully the integer called it sorry so

00:10:18,149 --> 00:10:28,979
there is condition it's not just it's in

00:10:21,059 --> 00:10:31,039
current a later in 2012 little storage

00:10:28,979 --> 00:10:35,189
showed a very short several lines

00:10:31,039 --> 00:10:37,199
example how to deceive the tracer in a

00:10:35,189 --> 00:10:41,669
reliable way so it's actually not a race

00:10:37,199 --> 00:10:44,479
if you can deceive it in a 100% and we

00:10:41,669 --> 00:10:47,069
have a 100% chance to decide the tracer

00:10:44,479 --> 00:10:48,869
yeah it's also extra asset of

00:10:47,069 --> 00:10:51,089
coalification but compared to the

00:10:48,869 --> 00:10:58,679
unreliable result it's not really a big

00:10:51,089 --> 00:11:00,779
deal so what what could we do actually

00:10:58,679 --> 00:11:04,319
this problem was known to kernel

00:11:00,779 --> 00:11:07,589
developers for quite a while and in

00:11:04,319 --> 00:11:11,279
generator 2012 there was a lively

00:11:07,589 --> 00:11:12,209
discussion in the kennel man list it

00:11:11,279 --> 00:11:17,220
started with her

00:11:12,209 --> 00:11:22,829
RFC patch to propose a feature that

00:11:17,220 --> 00:11:25,169
later became known as sitcom BBF and

00:11:22,829 --> 00:11:28,369
during that discussion they found out

00:11:25,169 --> 00:11:32,609
that they proposed implementation didn't

00:11:28,369 --> 00:11:36,059
didn't take these compat processes and

00:11:32,609 --> 00:11:41,419
the whole issue into account so yeah and

00:11:36,059 --> 00:11:45,929
this nice person he was a maintainer of

00:11:41,419 --> 00:11:47,999
PJ's jailor or Petraeus and box

00:11:45,929 --> 00:11:52,949
they were quite popular those days

00:11:47,999 --> 00:11:55,949
because the liberal no second so he was

00:11:52,949 --> 00:11:58,630
a maintainer this thing and he was like

00:11:55,949 --> 00:12:05,680
very surprised

00:11:58,630 --> 00:12:09,610
almost as surprised as this he couldn't

00:12:05,680 --> 00:12:13,830
believe that this fish exists and and

00:12:09,610 --> 00:12:17,980
wasn't almost almost undocumented and

00:12:13,830 --> 00:12:21,160
several well-known people suggested

00:12:17,980 --> 00:12:24,340
various solutions for the problem first

00:12:21,160 --> 00:12:28,500
was Linda's who suggested to abuse a

00:12:24,340 --> 00:12:31,900
flux because probably nobody uses them

00:12:28,500 --> 00:12:35,260
so just use two high bids from a flux

00:12:31,900 --> 00:12:39,160
and encode the information whether it's

00:12:35,260 --> 00:12:43,180
compat syscall or not but then Hans

00:12:39,160 --> 00:12:45,610
Peter said he doesn't like this hack and

00:12:43,180 --> 00:12:50,710
he suggested to use another hug and

00:12:45,610 --> 00:12:54,490
abuse her CS register because this race

00:12:50,710 --> 00:12:58,830
is less likely to be used I mean those

00:12:54,490 --> 00:13:05,140
high bids so his he thought his was

00:12:58,830 --> 00:13:07,780
nicer then Roland say that he doesn't

00:13:05,140 --> 00:13:11,080
like that kind of hugs and suggest to

00:13:07,780 --> 00:13:13,600
use reset mechanism or maybe just

00:13:11,080 --> 00:13:16,630
introduced in New York State flavor this

00:13:13,600 --> 00:13:23,680
would be like nice to already existent

00:13:16,630 --> 00:13:26,680
programs and so on but then then you say

00:13:23,680 --> 00:13:30,490
that why not to extend one of already

00:13:26,680 --> 00:13:33,030
existing rig sets when Roland responded

00:13:30,490 --> 00:13:37,720
that this would break a compatibility

00:13:33,030 --> 00:13:42,550
with already existing software like core

00:13:37,720 --> 00:13:47,080
files would change and so on elect

00:13:42,550 --> 00:13:49,750
suggested to ya to use a new flag and

00:13:47,080 --> 00:13:53,650
deliver new Petraeus events we have

00:13:49,750 --> 00:13:56,920
Petraeus or Tracy's good he suggested of

00:13:53,650 --> 00:14:01,300
course to use Petraeus Tracy is very

00:13:56,920 --> 00:14:06,010
good it's nice of him to suggest this

00:14:01,300 --> 00:14:08,520
good name so ya introduced like four new

00:14:06,010 --> 00:14:08,520
events

00:14:09,160 --> 00:14:13,960
that just suggested not to introduce new

00:14:11,560 --> 00:14:16,900
events but instead provide this

00:14:13,960 --> 00:14:20,830
information using the trace get event

00:14:16,900 --> 00:14:22,510
message instead so you can like make an

00:14:20,830 --> 00:14:28,230
extra system call and obtain this

00:14:22,510 --> 00:14:32,890
information yeah

00:14:28,230 --> 00:14:36,100
but as you can imagine the end result of

00:14:32,890 --> 00:14:40,360
this was that sick comp was finally

00:14:36,100 --> 00:14:42,010
implemented because clever Googlers who

00:14:40,360 --> 00:14:45,450
were behind this feature they wanted it

00:14:42,010 --> 00:14:51,310
and they finally made it into the kernel

00:14:45,450 --> 00:14:55,870
but nobody really wanted this feature in

00:14:51,310 --> 00:14:58,210
peaches there yeah the evolution of this

00:14:55,870 --> 00:15:00,700
problem went through all these classic

00:14:58,210 --> 00:15:05,460
steps first people said the problem

00:15:00,700 --> 00:15:09,790
doesn't exist but you clearly so it does

00:15:05,460 --> 00:15:12,670
then they argued that there are no

00:15:09,790 --> 00:15:14,980
consequences no problem that if she's

00:15:12,670 --> 00:15:20,250
called is printed wrongly but then came

00:15:14,980 --> 00:15:23,190
people who were relying on the correct

00:15:20,250 --> 00:15:27,580
correct information about system calls

00:15:23,190 --> 00:15:31,420
like if you if you are maintaining the

00:15:27,580 --> 00:15:33,570
trace some books and it makes the wrong

00:15:31,420 --> 00:15:36,820
decision you are out of the game

00:15:33,570 --> 00:15:39,040
then people say that the race was not

00:15:36,820 --> 00:15:41,140
practical but they looked old

00:15:39,040 --> 00:15:45,550
showed them that it's more than

00:15:41,140 --> 00:15:47,230
practical then people quite known people

00:15:45,550 --> 00:15:51,880
I would say so just with a lot of

00:15:47,230 --> 00:15:54,550
interesting ideas and one every idea was

00:15:51,880 --> 00:15:57,210
objected by one or more kernel

00:15:54,550 --> 00:16:00,400
developers so it was like a nice

00:15:57,210 --> 00:16:03,750
discussion very lovely you can actually

00:16:00,400 --> 00:16:07,750
find it and read it's a it's a industry

00:16:03,750 --> 00:16:10,960
yeah but nobody came out with a real

00:16:07,750 --> 00:16:15,100
patch so like nobody was really

00:16:10,960 --> 00:16:18,420
interested no big clients came to big

00:16:15,100 --> 00:16:20,860
vendors to request the future

00:16:18,420 --> 00:16:22,460
researchers were busy researching other

00:16:20,860 --> 00:16:25,640
kinds of stuff

00:16:22,460 --> 00:16:32,240
so yeah nothing changed full up for this

00:16:25,640 --> 00:16:38,210
and in free software if you if you want

00:16:32,240 --> 00:16:41,210
to do have a have a result yeah

00:16:38,210 --> 00:16:42,320
obviously need to find a person who who

00:16:41,210 --> 00:16:47,120
is interested

00:16:42,320 --> 00:16:52,100
who cares about and who is able to and

00:16:47,120 --> 00:16:56,720
yeah I found about to find out about

00:16:52,100 --> 00:17:00,440
this this discussion only in 2017

00:16:56,720 --> 00:17:03,680
because these people didn't care to like

00:17:00,440 --> 00:17:06,740
like cc maintainer of his race

00:17:03,680 --> 00:17:12,230
why bother him right right no need to so

00:17:06,740 --> 00:17:14,000
I found out about it in 2017 and I asked

00:17:12,230 --> 00:17:18,080
what was the conclusion of this

00:17:14,000 --> 00:17:20,180
discussion what they decided to do to be

00:17:18,080 --> 00:17:24,200
honest I didn't expect any response at

00:17:20,180 --> 00:17:30,200
all but nga responded he said that he

00:17:24,200 --> 00:17:32,900
opposed to all those proposals made five

00:17:30,200 --> 00:17:37,150
years ago for various reasons they were

00:17:32,900 --> 00:17:42,680
more less shaky so and he said well

00:17:37,150 --> 00:17:46,010
let's use the positive result of Sikkim

00:17:42,680 --> 00:17:50,980
PDF and just introducing you Patrice

00:17:46,010 --> 00:17:55,280
request that will contain all the

00:17:50,980 --> 00:18:01,300
information necessary to to find out all

00:17:55,280 --> 00:18:01,300
Cisco details and yes and let's use this

00:18:01,660 --> 00:18:09,670
arch filled with in Sikkim succumbed

00:18:06,290 --> 00:18:13,910
data structure that describes the

00:18:09,670 --> 00:18:15,560
architecture of the system call so if it

00:18:13,910 --> 00:18:19,490
works for second but should work for

00:18:15,560 --> 00:18:22,790
betrays it was a suggestion so I asked

00:18:19,490 --> 00:18:25,940
him how does she said proposed to

00:18:22,790 --> 00:18:30,170
implement this because the internal

00:18:25,940 --> 00:18:33,350
channel API didn't have anything to it

00:18:30,170 --> 00:18:35,570
didn't have the the most crucial part to

00:18:33,350 --> 00:18:38,499
implement this suggestion there

00:18:35,570 --> 00:18:41,419
there was no way to find out the

00:18:38,499 --> 00:18:43,399
architecture of another process you

00:18:41,419 --> 00:18:45,799
could find the architecture of the

00:18:43,399 --> 00:18:49,759
current process but not another process

00:18:45,799 --> 00:18:52,450
so I asked him this and what do you

00:18:49,759 --> 00:18:55,070
think was the answer

00:18:52,450 --> 00:19:02,690
yeah this was Vance that was total

00:18:55,070 --> 00:19:05,799
silence so I thought I really don't want

00:19:02,690 --> 00:19:10,720
to implement this internal channel API

00:19:05,799 --> 00:19:19,609
so I there was no follow-up of this and

00:19:10,720 --> 00:19:24,950
only in 2010 the person was found who

00:19:19,609 --> 00:19:30,289
submitted a refugee patch it was 7th of

00:19:24,950 --> 00:19:33,109
November 2018 we used to work together

00:19:30,289 --> 00:19:37,029
at the time so a little submitter the

00:19:33,109 --> 00:19:41,029
first day of scene and there was a

00:19:37,029 --> 00:19:44,659
follow-up very very very shortly Alec

00:19:41,029 --> 00:19:47,210
responded Alec is a Padres mountain in

00:19:44,659 --> 00:19:50,749
the colonel elect respondent and then

00:19:47,210 --> 00:19:54,229
aunty responded I wonder why Alaric

00:19:50,749 --> 00:19:58,159
responded so promptly maybe the reason

00:19:54,229 --> 00:20:01,729
is that they live in the same city and

00:19:58,159 --> 00:20:05,539
actually could meet face to face and

00:20:01,729 --> 00:20:07,779
discuss things it's actually I would say

00:20:05,539 --> 00:20:11,950
it's very useful to have a kernel

00:20:07,779 --> 00:20:16,759
developer living nearby yeah it helps

00:20:11,950 --> 00:20:17,919
and in general it helps if you can talk

00:20:16,759 --> 00:20:23,200
face to face

00:20:17,919 --> 00:20:28,159
sometimes it helps to resolve questions

00:20:23,200 --> 00:20:32,119
so yeah it was a the first the very

00:20:28,159 --> 00:20:34,369
first approach in this approach I really

00:20:32,119 --> 00:20:37,999
decided to say I said the main problem

00:20:34,369 --> 00:20:41,359
which is how to report the architecture

00:20:37,999 --> 00:20:43,730
when there is no Cannella pie nobody

00:20:41,359 --> 00:20:48,120
wanted to implement this kernel API so

00:20:43,730 --> 00:20:51,000
she decided let's let's hope Andy

00:20:48,120 --> 00:20:53,370
let's hope and you didn't notice

00:20:51,000 --> 00:20:58,110
and we'll just report the comm partners

00:20:53,370 --> 00:21:02,730
of process but as you can as you can

00:20:58,110 --> 00:21:06,510
imagine there that that hope was in vain

00:21:02,730 --> 00:21:09,540
in the notes and he insisted to

00:21:06,510 --> 00:21:13,140
implement least the right way that is to

00:21:09,540 --> 00:21:17,040
implement this miss field so in the end

00:21:13,140 --> 00:21:19,890
we were we had to go head-on

00:21:17,040 --> 00:21:23,640
they had no other options either to drop

00:21:19,890 --> 00:21:30,470
like the ball or to implement the thing

00:21:23,640 --> 00:21:34,020
we wanted to avoid so we agreed what we

00:21:30,470 --> 00:21:38,130
that was an agreement between me and

00:21:34,020 --> 00:21:49,620
Alvaro that I will be implementing the

00:21:38,130 --> 00:21:52,050
boring part and she will implement the

00:21:49,620 --> 00:21:56,070
petraeus part so in the second edition

00:21:52,050 --> 00:21:59,870
of all of the patch set you can see it

00:21:56,070 --> 00:22:03,480
move looks like succumbed data that this

00:21:59,870 --> 00:22:06,660
compact were replaced with a proper arch

00:22:03,480 --> 00:22:09,510
field also instruction pointer was added

00:22:06,660 --> 00:22:12,930
like in Sikkim data it proved to be

00:22:09,510 --> 00:22:19,080
useful later but as you can imagine to

00:22:12,930 --> 00:22:22,980
implement this but I had to like caught

00:22:19,080 --> 00:22:26,250
a lot of boring stuff so it was about 16

00:22:22,980 --> 00:22:30,420
it was 16 in the first iteration 16

00:22:26,250 --> 00:22:33,510
patches to extend the the IP I that

00:22:30,420 --> 00:22:35,880
belongs to audit subsystem at the same

00:22:33,510 --> 00:22:40,460
time when they started doing this we

00:22:35,880 --> 00:22:43,950
started finding various bugs and when

00:22:40,460 --> 00:22:47,160
you find bugs and the fixes are quite

00:22:43,950 --> 00:22:53,420
small and when architectures are well

00:22:47,160 --> 00:22:57,630
maintained they from the fixed so yeah

00:22:53,420 --> 00:23:01,710
some of these fixes were very shortly

00:22:57,630 --> 00:23:04,590
merged like documentation fixes and

00:23:01,710 --> 00:23:11,490
very very well they don't usually break

00:23:04,590 --> 00:23:17,220
things but when you do something bigger

00:23:11,490 --> 00:23:22,260
it takes a lot of time in the third

00:23:17,220 --> 00:23:25,530
edition of this so there was some some

00:23:22,260 --> 00:23:28,800
changes under the hood in the Petraeus

00:23:25,530 --> 00:23:31,200
implementation there was a quite a

00:23:28,800 --> 00:23:35,430
lively discussion all the time on the

00:23:31,200 --> 00:23:37,380
API level we decided to make this field

00:23:35,430 --> 00:23:40,050
available not just for engineering

00:23:37,380 --> 00:23:43,590
system calls but also for Allah Petri

00:23:40,050 --> 00:23:47,700
States and for some reason we decided to

00:23:43,590 --> 00:23:50,730
add a stack pointer and frame pointer

00:23:47,700 --> 00:23:54,030
what is it was that industry's stack

00:23:50,730 --> 00:23:58,320
pointer is actually useful and we

00:23:54,030 --> 00:23:59,910
thought it's available so why not this

00:23:58,320 --> 00:24:03,440
decision

00:23:59,910 --> 00:24:07,770
it was later proven to be not very good

00:24:03,440 --> 00:24:11,310
so yeah that was the first edition of

00:24:07,770 --> 00:24:13,500
this you see it's like getting getting

00:24:11,310 --> 00:24:15,180
slightly bigger but you don't see you

00:24:13,500 --> 00:24:19,200
don't see the outed part of this because

00:24:15,180 --> 00:24:22,380
there was no need to risk in it I was

00:24:19,200 --> 00:24:24,990
waiting for response from architecture

00:24:22,380 --> 00:24:28,010
maintenance and for some well-maintained

00:24:24,990 --> 00:24:30,990
architectures I got apps but you know

00:24:28,010 --> 00:24:33,840
were quite a few architectures in Linux

00:24:30,990 --> 00:24:37,050
kernel as some of them very poorly

00:24:33,840 --> 00:24:42,600
maintained like some didn't get any

00:24:37,050 --> 00:24:46,590
commits for half a year unfortunately at

00:24:42,600 --> 00:24:49,320
this time there was no longer able to

00:24:46,590 --> 00:24:53,730
take part into in this project so all

00:24:49,320 --> 00:24:55,710
there is I had to do myself yeah in the

00:24:53,730 --> 00:24:59,250
fourth edition of this API

00:24:55,710 --> 00:25:03,360
after a quest of kiss cook we decided to

00:24:59,250 --> 00:25:05,970
report also a second stop so yeah it's

00:25:03,360 --> 00:25:10,710
very similar to she's called just call

00:25:05,970 --> 00:25:13,590
enter stop with the addition of a field

00:25:10,710 --> 00:25:15,299
describing Sikkim its own data so this

00:25:13,590 --> 00:25:19,980
helps

00:25:15,299 --> 00:25:22,200
this helps tracer it it doesn't have to

00:25:19,980 --> 00:25:27,059
invoke ecstasy scold obtain this

00:25:22,200 --> 00:25:31,169
information and in the fifth edition so

00:25:27,059 --> 00:25:34,230
it's about month from the beginning we

00:25:31,169 --> 00:25:36,989
well it was me yeah

00:25:34,230 --> 00:25:41,489
some fields were move to the common part

00:25:36,989 --> 00:25:44,369
and also I had to to unite these two

00:25:41,489 --> 00:25:47,850
parts into a single batch said what was

00:25:44,369 --> 00:25:48,299
the reason for this well because if you

00:25:47,850 --> 00:25:53,669
want

00:25:48,299 --> 00:25:56,909
Colonel CI to be involved they don't

00:25:53,669 --> 00:26:00,389
really play well they don't really do

00:25:56,909 --> 00:26:02,460
well when one patch set has to be apply

00:26:00,389 --> 00:26:03,179
it on top of another patch said that is

00:26:02,460 --> 00:26:08,609
submitted

00:26:03,179 --> 00:26:11,639
so to get some kernel testing first I

00:26:08,609 --> 00:26:13,859
wrote a soft test which is actually

00:26:11,639 --> 00:26:18,090
about one third of the whole patch said

00:26:13,859 --> 00:26:20,279
is that is the softest by the way I

00:26:18,090 --> 00:26:24,809
really recommend everybody who extends

00:26:20,279 --> 00:26:28,080
API though either a soft test for it it

00:26:24,809 --> 00:26:33,090
not just helps to taste their the the

00:26:28,080 --> 00:26:36,450
new feature it also helps to discover

00:26:33,090 --> 00:26:38,970
how to use it for me it was quite simple

00:26:36,450 --> 00:26:41,730
because it was almost the same the same

00:26:38,970 --> 00:26:44,639
code that that's used in a stress to

00:26:41,730 --> 00:26:51,090
test whether kernel implements the

00:26:44,639 --> 00:26:54,059
feature in the right way so yes in the

00:26:51,090 --> 00:26:57,629
sixth edition of this which was in the

00:26:54,059 --> 00:26:59,999
middle of December there was a small

00:26:57,629 --> 00:27:04,109
change in the APA and it was the last

00:26:59,999 --> 00:27:09,359
one so about a month after the first RFC

00:27:04,109 --> 00:27:13,590
patch the API was ready and soon after

00:27:09,359 --> 00:27:17,720
that I related this trace in the end of

00:27:13,590 --> 00:27:22,769
December that support of this API but

00:27:17,720 --> 00:27:26,700
there was no cure no well some render

00:27:22,769 --> 00:27:31,769
candles were but fortune this certainly

00:27:26,700 --> 00:27:36,559
cannot be redistributed in basic but

00:27:31,769 --> 00:27:36,559
other others couldn't use this feature

00:27:37,519 --> 00:27:44,570
this was the largest part the sixth

00:27:42,269 --> 00:27:47,370
edition was the largest part set of all

00:27:44,570 --> 00:27:51,529
while was the largest because well oh

00:27:47,370 --> 00:27:55,380
this all this architecture stuff and

00:27:51,529 --> 00:28:00,230
because some of this patches went

00:27:55,380 --> 00:28:03,330
through architecture trees later so yeah

00:28:00,230 --> 00:28:05,870
in this the seventh edition was exactly

00:28:03,330 --> 00:28:12,740
the same it was just your based to the

00:28:05,870 --> 00:28:15,659
tourists to the to the first irsie / 5.0

00:28:12,740 --> 00:28:17,750
colonel it's actually smaller because

00:28:15,659 --> 00:28:23,519
some patches weren't through

00:28:17,750 --> 00:28:25,679
architecture trees you can see it's

00:28:23,519 --> 00:28:31,909
quite quite big a lot of architectures

00:28:25,679 --> 00:28:31,909
but well about fertilities is the test

00:28:32,240 --> 00:28:42,690
so at this moment it was clear that from

00:28:39,120 --> 00:28:45,269
one point our idea to implement this it

00:28:42,690 --> 00:28:47,399
race gets his call for API on all

00:28:45,269 --> 00:28:49,740
architectures

00:28:47,399 --> 00:28:52,490
it felt miserably because we found out

00:28:49,740 --> 00:28:56,130
there is an architecture called alpha

00:28:52,490 --> 00:28:59,190
it's not really that we didn't knew

00:28:56,130 --> 00:29:02,220
about this we knew that Alpha

00:28:59,190 --> 00:29:07,730
architecture exists I even had a shell

00:29:02,220 --> 00:29:10,230
access to books on alpha but apparently

00:29:07,730 --> 00:29:14,659
alpha is a strange architecture

00:29:10,230 --> 00:29:17,279
it doesn't implement a way to obtain

00:29:14,659 --> 00:29:23,039
stick user stack pointer of another

00:29:17,279 --> 00:29:25,350
process so in the end we decided to to

00:29:23,039 --> 00:29:29,130
drop support for alpha and and a few

00:29:25,350 --> 00:29:33,299
other architectures and limit it just to

00:29:29,130 --> 00:29:37,710
only those that implement trace hooks

00:29:33,299 --> 00:29:40,230
now it was about 19 architectures like

00:29:37,710 --> 00:29:43,440
and a few

00:29:40,230 --> 00:29:47,899
from this and then it was clear that the

00:29:43,440 --> 00:29:47,899
the the budge set is like too big

00:29:47,970 --> 00:29:55,470
it affects two different subsystems and

00:29:51,679 --> 00:30:00,559
in one subsystem like there is a

00:29:55,470 --> 00:30:04,080
maintainer who use a regular way of

00:30:00,559 --> 00:30:08,070
accepting patches it has a tree another

00:30:04,080 --> 00:30:11,610
subsystem is pjs maintainer of Padres he

00:30:08,070 --> 00:30:15,389
doesn't have a tree so you have to like

00:30:11,610 --> 00:30:21,539
submit patches to the maintain of last

00:30:15,389 --> 00:30:27,090
resort and he use patch kills and the

00:30:21,539 --> 00:30:30,870
idea that you probably can put the whole

00:30:27,090 --> 00:30:34,110
thing into one of the subsystems I don't

00:30:30,870 --> 00:30:36,419
think it was practical so so we decided

00:30:34,110 --> 00:30:41,250
yes it was too big in the verse and

00:30:36,419 --> 00:30:44,039
let's divide it yeah so it was divided

00:30:41,250 --> 00:30:49,649
back into two parts the first part is

00:30:44,039 --> 00:30:58,590
pure pure out it stuff it when it had to

00:30:49,649 --> 00:31:03,240
be pushed by Audi tree using Palmer's G

00:30:58,590 --> 00:31:07,559
and all the rest would have to wait when

00:31:03,240 --> 00:31:11,700
this is merged and then pushed to Andrew

00:31:07,559 --> 00:31:15,360
Morton who and remoten is a universal

00:31:11,700 --> 00:31:18,720
maintainer who who cares of everything

00:31:15,360 --> 00:31:23,309
that doesn't have a maintainer for

00:31:18,720 --> 00:31:27,169
except patches so it's a he's a kind of

00:31:23,309 --> 00:31:31,760
mention of last resort okay so first

00:31:27,169 --> 00:31:34,470
first it was a push throughout the tree

00:31:31,760 --> 00:31:38,639
well we were not very lucky with timing

00:31:34,470 --> 00:31:43,919
because when we decided to do the split

00:31:38,639 --> 00:31:49,010
the notch window closed and you know how

00:31:43,919 --> 00:31:53,159
the Linux kernel development cycle is

00:31:49,010 --> 00:31:56,159
there is a release then about two weeks

00:31:53,159 --> 00:31:59,580
of notch window and then about six

00:31:56,159 --> 00:32:02,159
window of testing and but fixing and at

00:31:59,580 --> 00:32:06,870
this time after the merge we know you

00:32:02,159 --> 00:32:10,850
can't unless you a very very prominent

00:32:06,870 --> 00:32:13,500
person you can't submit a new new API I

00:32:10,850 --> 00:32:18,529
was not very prominent person so I had

00:32:13,500 --> 00:32:25,220
to wait so we waited one recycle and

00:32:18,529 --> 00:32:30,690
also also Palmer was not really very

00:32:25,220 --> 00:32:33,659
eager to review outed part he was outed

00:32:30,690 --> 00:32:36,389
parts but he was not really ready to

00:32:33,659 --> 00:32:39,269
review architecture dependent parts so

00:32:36,389 --> 00:32:41,629
he waited for architecture maintenance

00:32:39,269 --> 00:32:45,720
to to respond somehow

00:32:41,629 --> 00:32:48,419
so I was thinking these people actually

00:32:45,720 --> 00:32:54,929
I managed to collect a few more arcs for

00:32:48,419 --> 00:33:01,190
this and finally when another kennel

00:32:54,929 --> 00:33:04,679
mesh window opened and closed then

00:33:01,190 --> 00:33:06,960
Palmer was ready to commercial this into

00:33:04,679 --> 00:33:10,889
audit next and then to Linux next and

00:33:06,960 --> 00:33:14,970
then when the next

00:33:10,889 --> 00:33:22,440
Linux kernel mesh window opened it was

00:33:14,970 --> 00:33:24,860
merged finally truly no string it was it

00:33:22,440 --> 00:33:24,860
was me

00:33:28,299 --> 00:33:38,269
well the audit part was merged to to

00:33:35,330 --> 00:33:42,980
Linux next I started pinging Andrew

00:33:38,269 --> 00:33:46,490
Morton I had a hope that maybe he can

00:33:42,980 --> 00:33:50,179
merge it into a one of his cues that

00:33:46,490 --> 00:33:53,570
gets some testing on top of on top of

00:33:50,179 --> 00:33:57,740
Linux next so I was pinging him

00:33:53,570 --> 00:34:02,919
yeah but wasn't changed maybe I got

00:33:57,740 --> 00:34:09,649
some some ups at this point actually

00:34:02,919 --> 00:34:13,369
yeah maybe maybe a one patch was merged

00:34:09,649 --> 00:34:17,359
their arch tree or something like this

00:34:13,369 --> 00:34:19,760
but until until the the audit patch set

00:34:17,359 --> 00:34:22,520
was accepted into Linux tree there was

00:34:19,760 --> 00:34:26,450
absolutely no reaction from Andrew

00:34:22,520 --> 00:34:29,359
Morton and only when he it was in the

00:34:26,450 --> 00:34:32,210
industry only at this moment when

00:34:29,359 --> 00:34:37,940
another mochi window opened and closed

00:34:32,210 --> 00:34:40,520
only at at this moment only at this

00:34:37,940 --> 00:34:44,270
moment and repeated in trophies mmm

00:34:40,520 --> 00:34:48,349
patch queue so yeah and we had to wait

00:34:44,270 --> 00:34:52,250
another this kernel recycle and yeah

00:34:48,349 --> 00:35:01,369
it's only it was on the July then it was

00:34:52,250 --> 00:35:10,010
finally in the industry so in short it

00:35:01,369 --> 00:35:13,540
was 29 commits 47 files changed like

00:35:10,010 --> 00:35:19,780
about 700 insertions first of them is a

00:35:13,540 --> 00:35:25,150
softest to offers also 20 people who

00:35:19,780 --> 00:35:30,290
headed the axe reviews or cyanide buys

00:35:25,150 --> 00:35:34,040
the whole process took almost nine

00:35:30,290 --> 00:35:39,050
months from the 7th of November till 75

00:35:34,040 --> 00:35:40,970
July some people manage to do more

00:35:39,050 --> 00:35:47,869
important things in their lives

00:35:40,970 --> 00:35:50,750
in nine months this yeah but well it

00:35:47,869 --> 00:35:55,329
implements this new feature on those 19

00:35:50,750 --> 00:35:59,420
architectures that enable Jewish hooks

00:35:55,329 --> 00:36:02,060
the API looks this way it's a like it's

00:35:59,420 --> 00:36:05,329
a structure as you can see it contains

00:36:02,060 --> 00:36:09,650
this arch field without a touch value

00:36:05,329 --> 00:36:13,040
that costed us so much time you can

00:36:09,650 --> 00:36:15,800
obtain information about the type of

00:36:13,040 --> 00:36:19,369
system call stop which is important

00:36:15,800 --> 00:36:23,990
because there are no other days for user

00:36:19,369 --> 00:36:26,569
space to find this information and to

00:36:23,990 --> 00:36:30,440
obtain the information common to all

00:36:26,569 --> 00:36:32,420
system call stops and specific to this

00:36:30,440 --> 00:36:35,150
particular system called stop like this

00:36:32,420 --> 00:36:40,130
system called entry stop exit stop and

00:36:35,150 --> 00:36:42,410
Sikkim stop yeah you can find this a in

00:36:40,130 --> 00:36:45,740
Linux kernel headers they don't have

00:36:42,410 --> 00:36:48,770
this nice comments probably we should at

00:36:45,740 --> 00:36:52,609
them how maybe not because there is also

00:36:48,770 --> 00:36:55,250
a description in in one page so you can

00:36:52,609 --> 00:37:00,470
find this nice comments there maybe it

00:36:55,250 --> 00:37:06,200
doesn't worth trouble yeah so back to

00:37:00,470 --> 00:37:11,500
this first example there is no longer

00:37:06,200 --> 00:37:11,500
problem no problem

00:37:14,510 --> 00:37:17,780
it works

00:37:18,730 --> 00:37:27,379

YouTube URL: https://www.youtube.com/watch?v=298Ua94rKdk


