Title: Calling Serverless Functions from an Android App
Publication date: 2019-02-22
Playlist: DevConfUS 2018
Description: 
	This session will look at provisioning OpenWhisk to a Kubernetes environment from the Service Catalog, and how to consume OpenWhisk actions/functions from an Android App.
The Service Catalog leverages Service Brokers.
The Automation Broker lets you write a Ansible Playbook Bundle (APB) to provision a service to a Kubernetes environment.
An OpenWhisk APB makes it simple to provision a serverless environment to you Kubernetes environment.
Building on this, creating & executing your serverless functions from a mobile app can be made easy by using the AeroGear Mobile SDK and Mobile CLI for OpenShift.

https://openwhisk.apache.org/
https://kubernetes.io/docs/concepts/service-catalog/
http://automationbroker.io/
https://github.com/aerogear
https://github.com/aerogear/mobile-cli
Captions: 
	00:00:03,420 --> 00:00:09,240
you're sort of first movers we have

00:00:05,450 --> 00:00:11,760
David Martin and Peter round

00:00:09,240 --> 00:00:15,510
you're both everybody after everybod

00:00:11,760 --> 00:00:17,640
happened earlier or yeah okay yeah so

00:00:15,510 --> 00:00:20,640
they're going to present calling service

00:00:17,640 --> 00:00:22,380
functions from an Android app now if you

00:00:20,640 --> 00:00:25,259
have any questions they're going to take

00:00:22,380 --> 00:00:28,159
questions during the presentation if we

00:00:25,259 --> 00:00:28,159
built that into the

00:00:32,710 --> 00:00:37,250
I'll come by with the mic to make sure

00:00:35,450 --> 00:00:39,710
that you your question can be heard and

00:00:37,250 --> 00:00:41,450
recorded there's no need to get up or

00:00:39,710 --> 00:00:44,390
walk up to me I'll just go to where you

00:00:41,450 --> 00:00:47,720
are the mic near you so with no further

00:00:44,390 --> 00:00:51,710
ado please okay

00:00:47,720 --> 00:00:53,600
thanks everyone for coming stirlitz

00:00:51,710 --> 00:00:56,690
functions calling serverless functions

00:00:53,600 --> 00:00:58,720
from an android app our presentation

00:00:56,690 --> 00:01:04,460
will be structured into two parts so

00:00:58,720 --> 00:01:06,500
that's very that mean the first one will

00:01:04,460 --> 00:01:07,790
be about running and managing a service

00:01:06,500 --> 00:01:10,040
platform on OpenShift

00:01:07,790 --> 00:01:13,729
and then the second part will be about

00:01:10,040 --> 00:01:18,020
invoking that that platform from an

00:01:13,729 --> 00:01:20,750
android app so first let's do a quick

00:01:18,020 --> 00:01:24,020
introduction into service architecture

00:01:20,750 --> 00:01:26,360
and it kind of sounds like there is no

00:01:24,020 --> 00:01:29,030
survey involved so how would it work so

00:01:26,360 --> 00:01:32,990
where does my request go and where does

00:01:29,030 --> 00:01:37,280
the answer come from so that's what

00:01:32,990 --> 00:01:40,159
server les sounds like but it turns out

00:01:37,280 --> 00:01:42,020
that's not really how it works the idea

00:01:40,159 --> 00:01:45,109
here is not that you don't have a server

00:01:42,020 --> 00:01:46,579
but the idea is that you don't care

00:01:45,109 --> 00:01:49,850
about the server you don't have to know

00:01:46,579 --> 00:01:53,689
how what technology stack your server is

00:01:49,850 --> 00:01:57,499
using or how much CPUs it has all you

00:01:53,689 --> 00:01:59,679
care about is I asked my request my

00:01:57,499 --> 00:02:03,409
request goes to a service provider and

00:01:59,679 --> 00:02:05,810
at that moment the service provider will

00:02:03,409 --> 00:02:09,050
spin up the resources it will process my

00:02:05,810 --> 00:02:14,380
request and afterwards it will spin down

00:02:09,050 --> 00:02:14,380
my resources so

00:02:17,950 --> 00:02:23,640
that's sorry I have to move

00:02:26,480 --> 00:02:32,209
the most common type of Cerberus

00:02:30,349 --> 00:02:35,480
architecture is called function as a

00:02:32,209 --> 00:02:38,060
service in in that scenario you map your

00:02:35,480 --> 00:02:40,310
requests to single functions the

00:02:38,060 --> 00:02:42,560
advantage here is that you pay for usage

00:02:40,310 --> 00:02:44,659
and not for having a back-end that is

00:02:42,560 --> 00:02:48,079
available at all times so only when a

00:02:44,659 --> 00:02:49,939
request gets in your function will be

00:02:48,079 --> 00:02:51,829
invoked the resources will be available

00:02:49,939 --> 00:02:54,019
at this time and they will be deep

00:02:51,829 --> 00:02:57,379
provision afterwards examples of this

00:02:54,019 --> 00:03:03,500
type include AWS lambda Google cloud

00:02:57,379 --> 00:03:05,750
functions and other functions so let's

00:03:03,500 --> 00:03:09,349
go on to Apache open wisk

00:03:05,750 --> 00:03:11,599
Apache open risk is what started by IBM

00:03:09,349 --> 00:03:14,239
it implements the function as a service

00:03:11,599 --> 00:03:17,060
infrastructure it's now an Apache

00:03:14,239 --> 00:03:20,150
project an open-source project you can

00:03:17,060 --> 00:03:21,919
write functions in a large number of

00:03:20,150 --> 00:03:23,689
languages and for example you can use

00:03:21,919 --> 00:03:26,180
JavaScript but note chess

00:03:23,689 --> 00:03:30,819
it supports golang it supports Ruby and

00:03:26,180 --> 00:03:30,819
it scales using container technologies

00:03:31,930 --> 00:03:38,659
so to interact with open wisk well first

00:03:35,870 --> 00:03:41,030
of all functions in open wisk or called

00:03:38,659 --> 00:03:42,680
actions and there are many ways you can

00:03:41,030 --> 00:03:45,290
invoke an action you don't have to make

00:03:42,680 --> 00:03:46,940
a direct HTTP request you can for

00:03:45,290 --> 00:03:49,220
example define triggers where you say

00:03:46,940 --> 00:03:51,530
whenever an email goes in I want to

00:03:49,220 --> 00:03:53,810
invoke an action on my service cluster

00:03:51,530 --> 00:03:55,340
or you can define feeds where you say

00:03:53,810 --> 00:03:56,659
that I have a github repository and

00:03:55,340 --> 00:03:58,729
whenever someone pushes to that

00:03:56,659 --> 00:04:01,639
repository I want to run an action on my

00:03:58,729 --> 00:04:03,229
on my cluster or you can use AMQP when a

00:04:01,639 --> 00:04:08,000
message is received I want to run an

00:04:03,229 --> 00:04:10,430
action as mention all those scales with

00:04:08,000 --> 00:04:13,099
docker containers so if more requests go

00:04:10,430 --> 00:04:15,260
in it will spin up multiple instances of

00:04:13,099 --> 00:04:17,530
your function to compare manage to the

00:04:15,260 --> 00:04:17,530
moment

00:04:18,530 --> 00:04:24,050
okay usually you interact with open

00:04:21,500 --> 00:04:26,810
whisk through its CLI this is how the

00:04:24,050 --> 00:04:29,120
manner of it looks like and it gives you

00:04:26,810 --> 00:04:31,510
gives you examples of what you can do

00:04:29,120 --> 00:04:34,430
with it so you can manage your actions

00:04:31,510 --> 00:04:36,230
you comments your triggers namespaces

00:04:34,430 --> 00:04:41,960
namespaces are ways to group functions

00:04:36,230 --> 00:04:43,730
and here are some examples or some

00:04:41,960 --> 00:04:46,070
useful commands that you can use that

00:04:43,730 --> 00:04:47,450
you can use the first one is just list

00:04:46,070 --> 00:04:50,060
everything that's in the cluster this

00:04:47,450 --> 00:04:51,710
will return you all the actions all the

00:04:50,060 --> 00:04:53,120
namespaces all the triggers and feats

00:04:51,710 --> 00:04:55,580
that you have you can also just

00:04:53,120 --> 00:04:59,060
specifically list actions with wsk

00:04:55,580 --> 00:05:00,890
action list more interesting is creating

00:04:59,060 --> 00:05:04,220
an action so the simplest way to do it

00:05:00,890 --> 00:05:06,680
is just to use wsk action crate you give

00:05:04,220 --> 00:05:08,780
the action a name and you provide a file

00:05:06,680 --> 00:05:11,240
by default it assumes that it's a

00:05:08,780 --> 00:05:14,300
javascript file and it will be run in a

00:05:11,240 --> 00:05:16,220
node.js container you can create more

00:05:14,300 --> 00:05:18,500
complex actions where you provide a sip

00:05:16,220 --> 00:05:22,580
file in that case you have to provide a

00:05:18,500 --> 00:05:24,320
kind to tell open wisk is this nodejs is

00:05:22,580 --> 00:05:27,320
this going because it can't infer the

00:05:24,320 --> 00:05:30,110
type from the file extension this has

00:05:27,320 --> 00:05:31,910
several advantages yet so you can bundle

00:05:30,110 --> 00:05:34,669
your dependencies with your action you

00:05:31,910 --> 00:05:37,310
could say I have have one function but

00:05:34,669 --> 00:05:39,440
it calls out to a database maybe and I

00:05:37,310 --> 00:05:41,870
bundle the dependencies for this in my

00:05:39,440 --> 00:05:44,000
zip file you could just bundle your node

00:05:41,870 --> 00:05:46,780
modules if it's a node a no chase

00:05:44,000 --> 00:05:46,780
application

00:05:48,919 --> 00:05:54,979
on two OpenShift so what do we want to

00:05:51,289 --> 00:05:58,310
achieve we want to run open whisk on

00:05:54,979 --> 00:06:00,560
open shift that that already works well

00:05:58,310 --> 00:06:02,029
there is project odd which provide

00:06:00,560 --> 00:06:04,129
templates for this and it makes

00:06:02,029 --> 00:06:06,289
deploying open whisk and open shift or

00:06:04,129 --> 00:06:08,479
also kubernetes pretty straightforward

00:06:06,289 --> 00:06:13,669
there's also an answerable playbook

00:06:08,479 --> 00:06:15,139
window you can use that to deploy open

00:06:13,669 --> 00:06:17,270
risk to the service catalog content

00:06:15,139 --> 00:06:18,229
provision it via one click from the

00:06:17,270 --> 00:06:21,039
Service Catalog

00:06:18,229 --> 00:06:23,539
this one is experimental but it works

00:06:21,039 --> 00:06:26,240
that's okay but we want to go one step

00:06:23,539 --> 00:06:28,520
further now we want to manage or we want

00:06:26,240 --> 00:06:29,960
to represent open with resources in open

00:06:28,520 --> 00:06:33,949
shifts or you want to represent our

00:06:29,960 --> 00:06:36,259
actions in open shift and we want to

00:06:33,949 --> 00:06:37,699
manage them using templates using the

00:06:36,259 --> 00:06:41,990
llamó template set open shifting

00:06:37,699 --> 00:06:44,360
kubernetes use and we want to give you a

00:06:41,990 --> 00:06:47,210
sensible way to retrieve all the

00:06:44,360 --> 00:06:51,639
necessary data you need to invoke those

00:06:47,210 --> 00:06:51,639
actions like credentials and endpoints

00:06:52,330 --> 00:06:57,129
the question is why why would you want

00:06:54,620 --> 00:07:00,889
to do this there are several reasons

00:06:57,129 --> 00:07:02,479
first one operational reason so it's

00:07:00,889 --> 00:07:04,669
possible that you have cluster admins

00:07:02,479 --> 00:07:06,319
that know how to deal with open shift I

00:07:04,669 --> 00:07:08,120
know how to work with templates but they

00:07:06,319 --> 00:07:10,490
should not have to know about how to

00:07:08,120 --> 00:07:13,370
deal with open risk and the CLI so by

00:07:10,490 --> 00:07:15,199
giving them open shift templates or

00:07:13,370 --> 00:07:17,149
kubernetes templates they can just use

00:07:15,199 --> 00:07:20,300
their existing knowledge and apply that

00:07:17,149 --> 00:07:22,550
to work with open wisk resources it's

00:07:20,300 --> 00:07:24,649
also possible that some applications in

00:07:22,550 --> 00:07:27,050
your cluster depend on actions that are

00:07:24,649 --> 00:07:28,669
available exploit i'm so when you have

00:07:27,050 --> 00:07:31,219
templates you can just bundle all your

00:07:28,669 --> 00:07:32,810
templates and deploy them at once and it

00:07:31,219 --> 00:07:34,550
guarantees you that okay when my

00:07:32,810 --> 00:07:37,310
application runs those actions will be

00:07:34,550 --> 00:07:40,009
available then there are security

00:07:37,310 --> 00:07:42,740
reasons you might want to restrict the

00:07:40,009 --> 00:07:44,449
CLI access to your cluster because to do

00:07:42,740 --> 00:07:47,419
that you would have to give out

00:07:44,449 --> 00:07:49,759
credentials and it might be more

00:07:47,419 --> 00:07:52,909
sensible to rely on open shift OAuth for

00:07:49,759 --> 00:07:55,069
all authentication and then there are

00:07:52,909 --> 00:07:56,479
some user experience reasons so you

00:07:55,069 --> 00:07:58,339
might want to take advantage of things

00:07:56,479 --> 00:08:00,319
like the service catalog or service

00:07:58,339 --> 00:08:02,680
bindings to provide more advanced

00:08:00,319 --> 00:08:02,680
features

00:08:03,280 --> 00:08:09,610
okay how do we do this we are going to

00:08:06,620 --> 00:08:12,800
use operators so what's an operator I

00:08:09,610 --> 00:08:14,720
taken this from the core OS website and

00:08:12,800 --> 00:08:16,820
it says an operator is a man method of

00:08:14,720 --> 00:08:18,800
packaging deploying and managing the

00:08:16,820 --> 00:08:20,360
kubernetes application kubernetes

00:08:18,800 --> 00:08:22,639
application is an application that is

00:08:20,360 --> 00:08:25,250
both deploys to deploy to kubernetes and

00:08:22,639 --> 00:08:27,590
managed using the kubernetes api sin

00:08:25,250 --> 00:08:30,010
cube CTL tooling we are particularly

00:08:27,590 --> 00:08:34,219
interested in the managing aspect here

00:08:30,010 --> 00:08:36,169
so let's go bit into details operators

00:08:34,219 --> 00:08:38,089
are applications embedded into your

00:08:36,169 --> 00:08:40,039
namespace they are typically written

00:08:38,089 --> 00:08:41,930
using golang because that's what

00:08:40,039 --> 00:08:45,110
kubernetes and open shift are also

00:08:41,930 --> 00:08:46,700
written in they watch your resources so

00:08:45,110 --> 00:08:49,250
everything that's deployed to your name

00:08:46,700 --> 00:08:53,210
space like ports deployments routes and

00:08:49,250 --> 00:08:55,550
services and they react to changes you

00:08:53,210 --> 00:08:58,279
can use custom types and we are going to

00:08:55,550 --> 00:09:01,100
use custom types to represent open wisk

00:08:58,279 --> 00:09:04,790
types like actions so governance gives

00:09:01,100 --> 00:09:06,890
you this ability to defy so to define

00:09:04,790 --> 00:09:08,839
types that are not known to cover

00:09:06,890 --> 00:09:11,779
Nettie's but or custom resource

00:09:08,839 --> 00:09:13,150
definitions and we I will show you an

00:09:11,779 --> 00:09:16,670
example of that later

00:09:13,150 --> 00:09:19,640
and there's also the coral as operator

00:09:16,670 --> 00:09:21,620
SDK and this was announced reason or

00:09:19,640 --> 00:09:24,020
pretty recently and it provides a pretty

00:09:21,620 --> 00:09:26,779
good way to start developing operators

00:09:24,020 --> 00:09:28,100
it's nice esta cated abstracts away a

00:09:26,779 --> 00:09:30,700
lot of the nasty things of the

00:09:28,100 --> 00:09:30,700
kubernetes api

00:09:31,639 --> 00:09:36,690
okay we're going to work on the service

00:09:34,589 --> 00:09:39,000
operator and I mentioned the customer

00:09:36,690 --> 00:09:41,220
resource definition we want we want to

00:09:39,000 --> 00:09:43,230
have a customer resource that represents

00:09:41,220 --> 00:09:46,889
an openness action this is how this

00:09:43,230 --> 00:09:48,870
template would look like so you we say

00:09:46,889 --> 00:09:53,579
that our customer resource definition is

00:09:48,870 --> 00:09:55,259
called service action and that's more or

00:09:53,579 --> 00:09:57,600
less all we have to provide the rest is

00:09:55,259 --> 00:09:59,189
pretty standard so you don't define here

00:09:57,600 --> 00:10:02,040
what the content of this customer

00:09:59,189 --> 00:10:04,230
resource will be that's handled later

00:10:02,040 --> 00:10:06,240
you just with this you just tell your

00:10:04,230 --> 00:10:08,939
your openshift where your kubernetes hey

00:10:06,240 --> 00:10:11,250
I want to have a resource called service

00:10:08,939 --> 00:10:16,649
action and I want to make the cluster

00:10:11,250 --> 00:10:18,060
aware of this we also have in the

00:10:16,649 --> 00:10:21,899
operation where we have to represent

00:10:18,060 --> 00:10:28,439
this customer resource as type in going

00:10:21,899 --> 00:10:30,569
so what we have is we define the type

00:10:28,439 --> 00:10:33,959
service action which represents our

00:10:30,569 --> 00:10:37,019
resource it has a spec part and a status

00:10:33,959 --> 00:10:40,290
part the spec is basically what do I

00:10:37,019 --> 00:10:42,029
need to create an open risk Act so I

00:10:40,290 --> 00:10:43,860
need a name I need to tell what the name

00:10:42,029 --> 00:10:46,079
of the action is I need a kind is it no

00:10:43,860 --> 00:10:48,540
chairs is going I need to provide the

00:10:46,079 --> 00:10:51,810
code that I want to run of course then I

00:10:48,540 --> 00:10:54,329
have a username and the password here so

00:10:51,810 --> 00:10:56,279
open risk is protected by its own

00:10:54,329 --> 00:11:00,569
authentication that I need to provide

00:10:56,279 --> 00:11:03,540
and then we have a namespace and then we

00:11:00,569 --> 00:11:05,519
have this data structure this basically

00:11:03,540 --> 00:11:07,589
stores what is the status of this

00:11:05,519 --> 00:11:11,040
resource in this case we only have it

00:11:07,589 --> 00:11:13,829
created or not and the next slide we'll

00:11:11,040 --> 00:11:18,360
go into a bit more detail to make sense

00:11:13,829 --> 00:11:20,430
of why we need the status here so the

00:11:18,360 --> 00:11:21,389
reconciliation loop so how do operators

00:11:20,430 --> 00:11:24,029
actually work

00:11:21,389 --> 00:11:25,199
they don't really react to events to

00:11:24,029 --> 00:11:27,809
implement something called a

00:11:25,199 --> 00:11:29,519
reconciliation loop and in every

00:11:27,809 --> 00:11:32,730
iteration of this loop they are

00:11:29,519 --> 00:11:35,220
presented with all your with all the

00:11:32,730 --> 00:11:37,680
watched resources and it's send the job

00:11:35,220 --> 00:11:40,740
of the operator to sync the status of a

00:11:37,680 --> 00:11:42,809
resource with the managed service so in

00:11:40,740 --> 00:11:43,459
that case we have only a status created

00:11:42,809 --> 00:11:45,619
on North Korea

00:11:43,459 --> 00:11:48,949
if the operator would see a resource

00:11:45,619 --> 00:11:50,959
that is there but has the status not

00:11:48,949 --> 00:11:52,429
created false it knows hey I have to do

00:11:50,959 --> 00:11:55,790
something I have to create this an open

00:11:52,429 --> 00:11:58,519
whisk now and then update the status one

00:11:55,790 --> 00:12:01,939
could say that operator an operator is

00:11:58,519 --> 00:12:08,209
basically a state machine for openshift

00:12:01,939 --> 00:12:10,910
kubernetes resources okay this should

00:12:08,209 --> 00:12:12,709
help us understand a bit of the code

00:12:10,910 --> 00:12:15,920
here this is taken from the service

00:12:12,709 --> 00:12:18,860
operator it's a bit simplified but the

00:12:15,920 --> 00:12:20,540
first part of this is watched what we

00:12:18,860 --> 00:12:22,790
have to tell the operator what kind of

00:12:20,540 --> 00:12:24,980
resources it should watch in this case

00:12:22,790 --> 00:12:27,230
we only care about the service action so

00:12:24,980 --> 00:12:30,050
we tell the operator hey watch this

00:12:27,230 --> 00:12:32,179
resource and then we hand over to the

00:12:30,050 --> 00:12:34,129
handler and in a second part we have to

00:12:32,179 --> 00:12:35,959
implement the handle function so this

00:12:34,129 --> 00:12:39,439
will be called in every iteration of a

00:12:35,959 --> 00:12:41,509
reconciliation loop and here we get the

00:12:39,439 --> 00:12:44,480
resource that is currently being watched

00:12:41,509 --> 00:12:46,459
so first thing we do is we make a copy

00:12:44,480 --> 00:12:47,959
of this resource it's called the event

00:12:46,459 --> 00:12:50,389
which is a bit misleading because this

00:12:47,959 --> 00:12:52,790
actually contains the the resource

00:12:50,389 --> 00:12:54,350
itself first we make a copy of it

00:12:52,790 --> 00:12:56,360
because it's a pointer and it's a

00:12:54,350 --> 00:12:58,369
pointer to a life cover Nettie's object

00:12:56,360 --> 00:13:01,490
that is possibly watched by other

00:12:58,369 --> 00:13:03,709
operators of services as well then we

00:13:01,490 --> 00:13:05,929
check the deletion timestamp and if it's

00:13:03,709 --> 00:13:08,689
set we delete the action the way this

00:13:05,929 --> 00:13:09,410
works is in kubernetes when you delete a

00:13:08,689 --> 00:13:12,019
resource

00:13:09,410 --> 00:13:13,639
it's either deleted immediately or if

00:13:12,019 --> 00:13:16,579
there is a finalizer

00:13:13,639 --> 00:13:18,589
attached to the resource kubernetes will

00:13:16,579 --> 00:13:22,309
set the deletion timestamp and we will

00:13:18,589 --> 00:13:26,329
not attempt to delete the resource until

00:13:22,309 --> 00:13:28,970
the finalize is removed otherwise if no

00:13:26,329 --> 00:13:31,189
deletion timestamp is set which we check

00:13:28,970 --> 00:13:32,990
the status if state is created is true

00:13:31,189 --> 00:13:34,459
we do nothing because okay this action

00:13:32,990 --> 00:13:36,049
is there it's not deleted and it's

00:13:34,459 --> 00:13:38,389
already created you can ignore it if

00:13:36,049 --> 00:13:40,579
created is false and we just create the

00:13:38,389 --> 00:13:44,980
action this is calling out to open Wisc

00:13:40,579 --> 00:13:44,980
using its REST API to create the action

00:13:46,060 --> 00:13:50,079
okay

00:13:47,209 --> 00:13:58,209
it's downtime so let's create an action

00:13:50,079 --> 00:13:58,209
we have the okay you show you that

00:14:00,550 --> 00:14:04,510
we've deployed open whisk here in

00:14:02,680 --> 00:14:08,080
namespace and you can see there's also

00:14:04,510 --> 00:14:13,450
the service of praetor deployed when we

00:14:08,080 --> 00:14:16,210
go to resources other resources we now

00:14:13,450 --> 00:14:19,870
get the type service action that's what

00:14:16,210 --> 00:14:22,150
our custom resource definition added we

00:14:19,870 --> 00:14:26,640
can see there is already one action test

00:14:22,150 --> 00:14:26,640
action now let's create another one

00:14:37,339 --> 00:14:43,990
just for the others let's have a look at

00:14:40,459 --> 00:14:43,990
the action that we're going to create

00:14:47,370 --> 00:14:53,820
so this is a template of kind service

00:14:51,750 --> 00:14:56,430
action that means that it belongs to the

00:14:53,820 --> 00:14:59,010
type of the customer resource definition

00:14:56,430 --> 00:15:01,380
that we added earlier to the cluster we

00:14:59,010 --> 00:15:03,450
have to give it a name the resource

00:15:01,380 --> 00:15:06,030
itself and we also have to give the the

00:15:03,450 --> 00:15:08,070
action on open whisker name we just say

00:15:06,030 --> 00:15:10,860
that this is a note chess application or

00:15:08,070 --> 00:15:13,260
function this is the code that it should

00:15:10,860 --> 00:15:17,190
run and here we provide the user or the

00:15:13,260 --> 00:15:18,930
credentials to add this to open wisk

00:15:17,190 --> 00:15:20,610
if you're concerned about this and you

00:15:18,930 --> 00:15:23,400
don't want to give out those credentials

00:15:20,610 --> 00:15:25,440
you could also make it known only to the

00:15:23,400 --> 00:15:28,440
operator by storing it in a secret for

00:15:25,440 --> 00:15:29,850
example so then the operator would just

00:15:28,440 --> 00:15:32,130
take those poems and apply the

00:15:29,850 --> 00:15:34,920
credentials only when it's making a

00:15:32,130 --> 00:15:37,680
request to open wisk and finally we have

00:15:34,920 --> 00:15:40,110
to name space underscore means in the

00:15:37,680 --> 00:15:43,580
open risk move it of just put it into

00:15:40,110 --> 00:15:43,580
the default name space whatever that is

00:15:44,270 --> 00:15:49,820
okay let's create this thing now I just

00:15:47,310 --> 00:15:53,040
used to go see COI so you open shifts UI

00:15:49,820 --> 00:15:59,270
to create this action by providing the

00:15:53,040 --> 00:15:59,270
template since created let's check

00:16:05,980 --> 00:16:10,570
okay there is test action - now so now

00:16:08,710 --> 00:16:15,300
we've created an action of one open

00:16:10,570 --> 00:16:15,300
whisk and it's represented in open shift

00:16:20,450 --> 00:16:23,920
give me back to the slides

00:16:28,050 --> 00:16:35,429
okay and yeah with this I would hand

00:16:31,649 --> 00:16:37,819
over to David for the Android part just

00:16:35,429 --> 00:16:37,819
let me

00:16:46,820 --> 00:16:54,170
thanks Peter let's get the mouse over

00:16:51,420 --> 00:16:54,170
there okay

00:16:55,029 --> 00:17:01,020
we're good okay

00:16:58,230 --> 00:17:03,540
so if you want to if you want to call

00:17:01,020 --> 00:17:04,650
the service from a mobile app and the

00:17:03,540 --> 00:17:06,660
first thing you might be thinking is

00:17:04,650 --> 00:17:09,480
okay I need I need some sort of SDK

00:17:06,660 --> 00:17:11,760
perhaps to call it or can I just make a

00:17:09,480 --> 00:17:14,579
simple HTTP request but you also need

00:17:11,760 --> 00:17:16,230
some details of the thing that you are

00:17:14,579 --> 00:17:18,930
actually calling so it means some sort

00:17:16,230 --> 00:17:23,400
of configuration that's the first the

00:17:18,930 --> 00:17:25,079
first area I looked at the the service

00:17:23,400 --> 00:17:27,209
action how is that represented in

00:17:25,079 --> 00:17:29,880
OpenShift what can I get from OpenShift

00:17:27,209 --> 00:17:31,710
and how can I make that available to the

00:17:29,880 --> 00:17:33,450
mobile app in this case it's a simple

00:17:31,710 --> 00:17:35,190
Android app how can I make it available

00:17:33,450 --> 00:17:38,040
to the Android app in a way that it can

00:17:35,190 --> 00:17:42,210
it can actually make a call to the

00:17:38,040 --> 00:17:43,980
action so what I'm trying to show on

00:17:42,210 --> 00:17:45,890
this slide is if we just get that

00:17:43,980 --> 00:17:49,500
service action the customer resource

00:17:45,890 --> 00:17:51,870
there's a lot of stuff in there and we

00:17:49,500 --> 00:17:55,470
don't want all that so we can slim this

00:17:51,870 --> 00:17:57,330
down so on the right hand side just just

00:17:55,470 --> 00:17:59,280
to get a bird's eye view of the amount

00:17:57,330 --> 00:18:00,390
of stuff in there so as a mobile

00:17:59,280 --> 00:18:03,000
developer I don't care about all that

00:18:00,390 --> 00:18:05,400
yeah I just want the very important bits

00:18:03,000 --> 00:18:10,010
well what URL do I need to call do I

00:18:05,400 --> 00:18:13,110
need any credentials for that so a

00:18:10,010 --> 00:18:15,290
little bit messy but we're getting there

00:18:13,110 --> 00:18:18,150
we can we can do an old secret command

00:18:15,290 --> 00:18:19,530
passing the template string the

00:18:18,150 --> 00:18:23,070
important bit is what we actually get it

00:18:19,530 --> 00:18:25,770
so we get to host here's where open

00:18:23,070 --> 00:18:28,860
whisk server is there's the action name

00:18:25,770 --> 00:18:31,650
the namespace and credentials that's

00:18:28,860 --> 00:18:33,600
that's more usable in our app so we can

00:18:31,650 --> 00:18:39,210
we can use that put it down put it into

00:18:33,600 --> 00:18:41,610
into a JSON file the mobile app itself

00:18:39,210 --> 00:18:43,170
I'll show some of this in Android studio

00:18:41,610 --> 00:18:47,670
but just to give an idea Before we jump

00:18:43,170 --> 00:18:49,650
in it's a simple example app it just has

00:18:47,670 --> 00:18:51,450
one action for calling to service action

00:18:49,650 --> 00:18:55,590
don't expect anything magnificent

00:18:51,450 --> 00:18:57,000
looking so repos up there if anyone does

00:18:55,590 --> 00:18:59,790
like to make things look nice but all

00:18:57,000 --> 00:19:01,650
means go ahead create a pure so we have

00:18:59,790 --> 00:19:03,370
a module in there for the open waste

00:19:01,650 --> 00:19:05,690
client

00:19:03,370 --> 00:19:08,810
that attracts away the bit that actually

00:19:05,690 --> 00:19:12,020
talks to open whisk we read in the open

00:19:08,810 --> 00:19:13,580
msconfig from adjacent flow so using the

00:19:12,020 --> 00:19:15,440
command in the previous slide we can

00:19:13,580 --> 00:19:18,920
just dump that out to a JSON file make

00:19:15,440 --> 00:19:20,900
sure it's in that location there in in

00:19:18,920 --> 00:19:22,160
our apt and in our in our activity we

00:19:20,900 --> 00:19:24,140
can create a new open miss client from

00:19:22,160 --> 00:19:26,600
this config and then using that client

00:19:24,140 --> 00:19:31,250
we can invoke actions so nothing too

00:19:26,600 --> 00:19:36,470
fancy there okay juice to do let's have

00:19:31,250 --> 00:19:39,320
a look at this code okay I'll walk

00:19:36,470 --> 00:19:41,300
through right from the config to calling

00:19:39,320 --> 00:19:43,730
the action if anyone has any questions

00:19:41,300 --> 00:19:48,320
or wants me to explain a bit of code

00:19:43,730 --> 00:19:50,740
somewhere I just share so first of all

00:19:48,320 --> 00:19:53,090
this is an asset so mr jasen

00:19:50,740 --> 00:19:56,120
that's what we saw the output of the OC

00:19:53,090 --> 00:20:01,060
command before was location of sarov

00:19:56,120 --> 00:20:01,060
open whisk action name and credentials

00:20:01,150 --> 00:20:07,310
where is this used in our main activity

00:20:03,950 --> 00:20:09,550
if we look up the top here we are just

00:20:07,310 --> 00:20:12,730
going to Paris in that config here

00:20:09,550 --> 00:20:15,050
create a new open waste client from that

00:20:12,730 --> 00:20:17,330
please ignore the line that talks to an

00:20:15,050 --> 00:20:20,690
SSL certs of New Kingdom that's only

00:20:17,330 --> 00:20:24,230
temporary so we have our open with

00:20:20,690 --> 00:20:26,900
client at this stage what can we do with

00:20:24,230 --> 00:20:28,460
that well down here in our unclick

00:20:26,900 --> 00:20:31,340
Kandra so this app is very simple has

00:20:28,460 --> 00:20:34,130
one button and our onclick and refer

00:20:31,340 --> 00:20:37,310
that we will construct some Prime's that

00:20:34,130 --> 00:20:39,770
we want to send to this action and pass

00:20:37,310 --> 00:20:42,140
it along so did this particular action

00:20:39,770 --> 00:20:44,090
that we created it takes in a name and a

00:20:42,140 --> 00:20:46,760
place so name would say world places

00:20:44,090 --> 00:20:49,190
Boston and it'll respond with a string

00:20:46,760 --> 00:20:54,150
that includes those words in some place

00:20:49,190 --> 00:20:56,310
and just down a bit further then

00:20:54,150 --> 00:20:58,890
plying that invoke so what defines ready

00:20:56,310 --> 00:21:00,270
set up in order to talk to currently you

00:20:58,890 --> 00:21:01,860
have to pass in the action name I have

00:21:00,270 --> 00:21:04,460
some ideas of making that much nicer

00:21:01,860 --> 00:21:07,200
talk about that in a couple of minutes

00:21:04,460 --> 00:21:10,140
anyway it's trying to invoke that's the

00:21:07,200 --> 00:21:12,270
action name passing those params I will

00:21:10,140 --> 00:21:14,430
get a response back and all we'll do

00:21:12,270 --> 00:21:16,800
here is just update our text view to set

00:21:14,430 --> 00:21:18,180
the text just above the button to say

00:21:16,800 --> 00:21:24,090
whatever we're got back from that

00:21:18,180 --> 00:21:26,490
service action I'll jump into the invoke

00:21:24,090 --> 00:21:30,420
function as well just to show there's

00:21:26,490 --> 00:21:35,840
nothing special in here either so this

00:21:30,420 --> 00:21:39,780
is using the volley HTTP request library

00:21:35,840 --> 00:21:42,510
setting up a new cue format to URL based

00:21:39,780 --> 00:21:45,330
on the various configuration so the host

00:21:42,510 --> 00:21:46,860
the namespace the action name then we

00:21:45,330 --> 00:21:51,480
set up this new JSON object request

00:21:46,860 --> 00:21:54,840
passing the prams make sure we set the

00:21:51,480 --> 00:21:56,280
headers here for basical and that just

00:21:54,840 --> 00:21:59,310
adds it to the queue for volley down

00:21:56,280 --> 00:22:03,510
here at the bottom so nothing special

00:21:59,310 --> 00:22:05,310
purchased HTTP request lots of potential

00:22:03,510 --> 00:22:09,470
for me making this nicer for the mobile

00:22:05,310 --> 00:22:09,470
developer but simpler for now

00:22:11,250 --> 00:22:14,880
so eventually I would come back in here

00:22:13,020 --> 00:22:18,150
to detect we update our text view with

00:22:14,880 --> 00:22:20,280
the with the text so let's let's give

00:22:18,150 --> 00:22:22,100
this a spain i just show that it does

00:22:20,280 --> 00:22:24,870
actually work

00:22:22,100 --> 00:22:28,700
so we should have should up the M&A for

00:22:24,870 --> 00:22:28,700
running here perfect

00:22:35,650 --> 00:22:43,600
okay button text goes up here super

00:22:39,880 --> 00:22:48,370
exciting collection hello world from

00:22:43,600 --> 00:22:50,110
Boston Peter did all the hard work I

00:22:48,370 --> 00:22:55,360
just did a small bit that looks

00:22:50,110 --> 00:22:59,410
impressive again so yeah that's pretty

00:22:55,360 --> 00:23:00,940
much the end to end I'll say a few

00:22:59,410 --> 00:23:03,550
things of how I think we can improve

00:23:00,940 --> 00:23:05,820
this though cuz there is mightier scope

00:23:03,550 --> 00:23:05,820
there

00:23:10,660 --> 00:23:16,930
so simpler configuration so one thing we

00:23:15,670 --> 00:23:18,940
didn't cover is what if you create more

00:23:16,930 --> 00:23:21,670
actions I want to call all these actions

00:23:18,940 --> 00:23:23,890
from my mobile app currently that being

00:23:21,670 --> 00:23:25,900
a custom resource for each one how can

00:23:23,890 --> 00:23:26,830
we bring that all together in one Jason

00:23:25,900 --> 00:23:31,650
config flat

00:23:26,830 --> 00:23:33,670
I think Peter you mentioned about

00:23:31,650 --> 00:23:36,310
abstracting away the credentials to is

00:23:33,670 --> 00:23:38,010
secrecy yes so for security reasons you

00:23:36,310 --> 00:23:40,120
might want to do that also for

00:23:38,010 --> 00:23:42,130
simplification of the configuration just

00:23:40,120 --> 00:23:46,990
keep it in one place and in the app

00:23:42,130 --> 00:23:49,360
knows we can get that speaking from

00:23:46,990 --> 00:23:50,710
strictly Android point of view Gradle or

00:23:49,360 --> 00:23:54,160
build time plugins could really help

00:23:50,710 --> 00:23:56,680
here so one idea is to get a plug-in

00:23:54,160 --> 00:23:58,720
that at Build time close down delete is

00:23:56,680 --> 00:24:00,400
config from open shift for you writing

00:23:58,720 --> 00:24:05,260
you haven't you remember or script that

00:24:00,400 --> 00:24:08,040
horrible or C command also a nice

00:24:05,260 --> 00:24:10,750
plug-in this is one that I've been

00:24:08,040 --> 00:24:12,100
inspired from the Apollo client the

00:24:10,750 --> 00:24:14,800
graph QL client if anyone's familiar

00:24:12,100 --> 00:24:16,960
with with the Apollo libraries but

00:24:14,800 --> 00:24:20,170
generating types are classes at build

00:24:16,960 --> 00:24:22,570
time that map to the service actions so

00:24:20,170 --> 00:24:24,310
you could do something like that my

00:24:22,570 --> 00:24:26,860
custom action does invoke under stipe

00:24:24,310 --> 00:24:28,240
checking on that and if your if that

00:24:26,860 --> 00:24:30,430
action doesn't actually exist or won't

00:24:28,240 --> 00:24:35,350
be a type they're so much safer for

00:24:30,430 --> 00:24:37,060
programming any integrations I think

00:24:35,350 --> 00:24:40,690
this is where the most interesting bit

00:24:37,060 --> 00:24:43,840
is how can how can we get the mobile bit

00:24:40,690 --> 00:24:45,370
integrator with more true open wisk how

00:24:43,840 --> 00:24:48,850
can we get open wisk integrating with

00:24:45,370 --> 00:24:51,520
more things in general so mobile

00:24:48,850 --> 00:24:54,550
security that's a big that's a big

00:24:51,520 --> 00:24:57,550
feature of say the arrow gear community

00:24:54,550 --> 00:24:59,380
their gear sdk integrating with keith

00:24:57,550 --> 00:25:01,060
look so what can we bring in there so

00:24:59,380 --> 00:25:02,950
only the right people are authorized to

00:25:01,060 --> 00:25:04,570
call call particular actions

00:25:02,950 --> 00:25:06,220
I know welcome risk has its own

00:25:04,570 --> 00:25:08,770
credentials but can we bring Keith lock

00:25:06,220 --> 00:25:12,450
into plate to keep them keep it more

00:25:08,770 --> 00:25:12,450
centralized as part of a larger project

00:25:12,790 --> 00:25:17,500
server-side are serving a site whatever

00:25:14,740 --> 00:25:19,810
you wanna call it integrations using so

00:25:17,500 --> 00:25:22,450
something like if people refuse or some

00:25:19,810 --> 00:25:24,100
deesis and it's word the idea is you

00:25:22,450 --> 00:25:25,840
have these connections that can connect

00:25:24,100 --> 00:25:27,310
to different services many many

00:25:25,840 --> 00:25:29,440
different types of services and you

00:25:27,310 --> 00:25:32,010
integrate them or tie them together in

00:25:29,440 --> 00:25:35,350
some sort of filtering or data mapping

00:25:32,010 --> 00:25:38,020
true-true DUI so server the server lists

00:25:35,350 --> 00:25:39,100
actions could feed into that and

00:25:38,020 --> 00:25:41,860
possibly a tutor and you could have

00:25:39,100 --> 00:25:44,610
something like a messaging queue and

00:25:41,860 --> 00:25:48,130
yeah hook them up together

00:25:44,610 --> 00:25:50,910
third point OpenShift UI extensions this

00:25:48,130 --> 00:25:53,590
is something as part of the erica work

00:25:50,910 --> 00:25:54,640
would have experimented a good bit with

00:25:53,590 --> 00:26:00,250
openshift

00:25:54,640 --> 00:26:01,930
tree tree 10 and and and we're looking

00:26:00,250 --> 00:26:04,540
to the future would open chef for as

00:26:01,930 --> 00:26:09,070
well because it's changing somewhat but

00:26:04,540 --> 00:26:11,050
how can the OpenShift UI how can it be

00:26:09,070 --> 00:26:13,300
made aware that open whisk is running

00:26:11,050 --> 00:26:15,400
here and there are actions created well

00:26:13,300 --> 00:26:17,980
the customer resource they can tell you

00:26:15,400 --> 00:26:21,190
that and then showing that in the UI in

00:26:17,980 --> 00:26:23,290
some really nice way so you can have a

00:26:21,190 --> 00:26:24,850
unified view of your project with an

00:26:23,290 --> 00:26:26,680
open shift so if you can see your

00:26:24,850 --> 00:26:28,120
service actions and you have other

00:26:26,680 --> 00:26:30,010
things running you can see all those

00:26:28,120 --> 00:26:33,100
things as well and possibly even

00:26:30,010 --> 00:26:37,900
visualize all these things working

00:26:33,100 --> 00:26:40,000
together as part of a larger project so

00:26:37,900 --> 00:26:41,440
that's it on the future potential I'll

00:26:40,000 --> 00:26:44,550
hand it back to you Peter if you want to

00:26:41,440 --> 00:26:44,550
do a wrapper

00:26:51,049 --> 00:26:56,790
um

00:26:52,990 --> 00:26:56,790
maybe to show you one more thing

00:27:00,530 --> 00:27:05,210
so we've seen that the resources have

00:27:03,650 --> 00:27:07,130
been created here with what does the

00:27:05,210 --> 00:27:13,090
resource actually look like we can just

00:27:07,130 --> 00:27:17,450
inspect the yellow source of this yeah

00:27:13,090 --> 00:27:20,510
yeah it's hard to read from here I said

00:27:17,450 --> 00:27:23,000
okay to read I try to yeah so this is

00:27:20,510 --> 00:27:25,220
what what the yellow representation of

00:27:23,000 --> 00:27:26,930
our open was actually now looks like we

00:27:25,220 --> 00:27:29,660
can see that it's of type service

00:27:26,930 --> 00:27:32,780
actions that and that it has a number of

00:27:29,660 --> 00:27:36,080
annotations those are put here by the

00:27:32,780 --> 00:27:38,480
service operator one thing it does is it

00:27:36,080 --> 00:27:41,140
annotates the resource with the endpoint

00:27:38,480 --> 00:27:44,300
of the actual action in open whisk and

00:27:41,140 --> 00:27:46,460
it provides those properties also

00:27:44,300 --> 00:27:50,420
standalone so you have the hostname the

00:27:46,460 --> 00:27:53,300
namespace and this is used in in David's

00:27:50,420 --> 00:27:56,450
app so it this is parsed out and put

00:27:53,300 --> 00:27:58,400
into a JSON file then we can also see

00:27:56,450 --> 00:28:01,760
the finalizer here so when we create an

00:27:58,400 --> 00:28:03,980
action we add this finalize it yeah we

00:28:01,760 --> 00:28:05,690
add this finalizer to the resource so

00:28:03,980 --> 00:28:06,380
that when you delete the resource and

00:28:05,690 --> 00:28:08,780
OpenShift

00:28:06,380 --> 00:28:11,420
it's not to eat it straight away but the

00:28:08,780 --> 00:28:13,910
the operator gets notified and it can do

00:28:11,420 --> 00:28:16,610
its cleanup where cleanup means remove

00:28:13,910 --> 00:28:18,800
to action from open whisk then remove to

00:28:16,610 --> 00:28:22,700
finalizer and then open chef can finally

00:28:18,800 --> 00:28:26,330
delete the resource and then we see the

00:28:22,700 --> 00:28:28,840
spec part this is what we talked about

00:28:26,330 --> 00:28:28,840
in

00:28:29,110 --> 00:28:35,700
let me fight my loss cars it will dare

00:28:37,520 --> 00:28:45,559
a few slides back so if we look at that

00:28:42,080 --> 00:28:47,870
code this is exactly what we read out so

00:28:45,559 --> 00:28:55,760
name kind code and so on this is what we

00:28:47,870 --> 00:28:58,220
read from the CML definition yeah

00:28:55,760 --> 00:28:59,690
stored here and the status in that case

00:28:58,220 --> 00:29:02,929
the action is already created so the

00:28:59,690 --> 00:29:04,550
operator will just skipped that was just

00:29:02,929 --> 00:29:06,970
to show you how it actually looks like

00:29:04,550 --> 00:29:16,100
on open shift when we created an action

00:29:06,970 --> 00:29:19,070
and then back to the presentation just a

00:29:16,100 --> 00:29:20,840
quick recap a recap of what we did so we

00:29:19,070 --> 00:29:22,580
have open Wisc running on open shift we

00:29:20,840 --> 00:29:25,970
didn't do heat much here because that

00:29:22,580 --> 00:29:28,309
already worked thanks to project god we

00:29:25,970 --> 00:29:31,400
have now an operator that manages our

00:29:28,309 --> 00:29:33,830
actions we can interact with this

00:29:31,400 --> 00:29:35,929
operator by creating instances of custom

00:29:33,830 --> 00:29:38,059
resources we can retrieve this

00:29:35,929 --> 00:29:40,520
configuration using the openshift CLI

00:29:38,059 --> 00:29:42,590
tools and this configuration

00:29:40,520 --> 00:29:44,450
configuration is then consumed in an

00:29:42,590 --> 00:29:46,130
android app and this Android app can use

00:29:44,450 --> 00:29:48,710
this configuration to also invoke the

00:29:46,130 --> 00:29:51,410
action the code to all of this is

00:29:48,710 --> 00:29:53,210
available here so you can have a look at

00:29:51,410 --> 00:29:57,410
the operator itself it's using the

00:29:53,210 --> 00:29:59,150
operator SDK your suppository and we

00:29:57,410 --> 00:30:03,470
also have the repository of David's

00:29:59,150 --> 00:30:05,679
Android app here yep that's it thank you

00:30:03,470 --> 00:30:05,679
very much

00:30:09,700 --> 00:30:12,819
[Music]

00:30:26,320 --> 00:30:31,970
so the first one are great fun yeah the

00:30:29,990 --> 00:30:33,650
first one is you mentioned like a lambda

00:30:31,970 --> 00:30:35,330
for example in support for the same type

00:30:33,650 --> 00:30:38,240
of languages for example let's say no GS

00:30:35,330 --> 00:30:43,730
which is commonly used how easy is it to

00:30:38,240 --> 00:30:47,720
port the code over to to open Wisconsin

00:30:43,730 --> 00:30:49,400
on OpenShift you mean how easy would it

00:30:47,720 --> 00:30:51,260
be so if I can just think can I just

00:30:49,400 --> 00:30:52,790
take the code from lambda and plug it in

00:30:51,260 --> 00:30:54,800
and would it just work out of the box

00:30:52,790 --> 00:30:58,610
I'm not I have to say I'm not familiar

00:30:54,800 --> 00:31:00,610
with lambda but Open whisk takes in in

00:30:58,610 --> 00:31:03,230
most simple case it just takes a

00:31:00,610 --> 00:31:04,970
function without any dependencies so you

00:31:03,230 --> 00:31:06,500
if you have something like that running

00:31:04,970 --> 00:31:08,900
on lambda I would imagine that you can

00:31:06,500 --> 00:31:10,850
just take it and deploy it open was that

00:31:08,900 --> 00:31:13,280
would work I'm not sure how long that

00:31:10,850 --> 00:31:15,290
deals with bundles so where you have an

00:31:13,280 --> 00:31:16,970
action with dependencies attitude well

00:31:15,290 --> 00:31:18,890
so you just upload the zip file the same

00:31:16,970 --> 00:31:21,470
as here yes how can you tell it what

00:31:18,890 --> 00:31:24,380
language what what runtime version and

00:31:21,470 --> 00:31:29,090
yeah can I just ask one more question so

00:31:24,380 --> 00:31:32,150
on so related questions on the zip file

00:31:29,090 --> 00:31:34,070
that you upload and so there is for

00:31:32,150 --> 00:31:35,960
example using your same thing let's say

00:31:34,070 --> 00:31:38,330
you have my sequel database that you're

00:31:35,960 --> 00:31:40,610
uploading as a dependency but you don't

00:31:38,330 --> 00:31:43,340
want to create the connection pool every

00:31:40,610 --> 00:31:45,830
time for your service request what are

00:31:43,340 --> 00:31:47,930
best practices for making sure they

00:31:45,830 --> 00:31:51,080
persist over multiple and multiple

00:31:47,930 --> 00:31:53,000
server list requests I'm not sure if in

00:31:51,080 --> 00:31:56,600
that scenario service is the best

00:31:53,000 --> 00:32:00,020
approach it's it's best suited to best

00:31:56,600 --> 00:32:01,940
to stateless and then to maybe actions

00:32:00,020 --> 00:32:05,350
to do simple transactions where the

00:32:01,940 --> 00:32:07,460
database but if you have a if you have a

00:32:05,350 --> 00:32:09,710
connection pool and you're doing

00:32:07,460 --> 00:32:12,679
frequent database transactions maybe a

00:32:09,710 --> 00:32:15,559
standalone service is a better solution

00:32:12,679 --> 00:32:21,500
but that's just my take on it what what

00:32:15,559 --> 00:32:23,870
I tried was to add the yeah I edit I had

00:32:21,500 --> 00:32:26,030
an action that I and I used dependencies

00:32:23,870 --> 00:32:28,190
to talk with their Google home and I

00:32:26,030 --> 00:32:29,900
just my idea which just download to note

00:32:28,190 --> 00:32:32,540
dependencies buns everything into a sip

00:32:29,900 --> 00:32:33,640
and that worked fine but I sorry I can't

00:32:32,540 --> 00:32:37,570
really tell you how to deal with

00:32:33,640 --> 00:32:37,570
database connection pool thank you

00:32:38,080 --> 00:32:44,450
we have a short time okay so yeah I

00:32:41,900 --> 00:32:48,140
realized open source sone is from work

00:32:44,450 --> 00:32:53,450
to support functioning at a service such

00:32:48,140 --> 00:32:56,929
as home with and as a frog so it's a

00:32:53,450 --> 00:33:01,040
special meeting in why we used zombies

00:32:56,929 --> 00:33:04,520
you know miss you it don't consider as a

00:33:01,040 --> 00:33:06,410
myself in a walk do you mean why do we

00:33:04,520 --> 00:33:08,090
want to run open wisp and open shiftin

00:33:06,410 --> 00:33:10,130
yeah yes the latter name are the kind of

00:33:08,090 --> 00:33:11,840
oh yeah this I can't go back to the

00:33:10,130 --> 00:33:16,790
solid nerds

00:33:11,840 --> 00:33:18,740
I mean yeah the idea is that we usually

00:33:16,790 --> 00:33:21,280
you interact with open risk through your

00:33:18,740 --> 00:33:24,320
CLI and you need credentials to do that

00:33:21,280 --> 00:33:26,240
and the idea is imagine you have a large

00:33:24,320 --> 00:33:27,740
kubernetes cluster and you have an admin

00:33:26,240 --> 00:33:30,049
that knows how to work with this club

00:33:27,740 --> 00:33:32,330
work with templates but he shouldn't

00:33:30,049 --> 00:33:34,970
have to know about open whisk and that's

00:33:32,330 --> 00:33:36,500
the idea you this administrator can

00:33:34,970 --> 00:33:38,570
apply his existing knowledge about

00:33:36,500 --> 00:33:40,520
templates and just apply to trove newest

00:33:38,570 --> 00:33:42,080
you can use those templates to interact

00:33:40,520 --> 00:33:44,929
with open risk that's kind of the idea

00:33:42,080 --> 00:33:47,890
giving a more general way of interacting

00:33:44,929 --> 00:33:47,890
with your services

00:33:49,070 --> 00:33:57,950
first rising in the new fiscal to be

00:33:53,659 --> 00:34:02,159
incorporated some of this chronology

00:33:57,950 --> 00:34:04,470
include beyond of a Miss quite is in the

00:34:02,159 --> 00:34:08,280
future or which that emotional have

00:34:04,470 --> 00:34:11,159
planned to and all sign us so this is

00:34:08,280 --> 00:34:24,659
purely experimental okay this is not a

00:34:11,159 --> 00:34:28,619
product and I don't know if my question

00:34:24,659 --> 00:34:31,320
will be short instinctually if you have

00:34:28,619 --> 00:34:32,940
a you're building an application an

00:34:31,320 --> 00:34:37,679
Android application and you're deciding

00:34:32,940 --> 00:34:39,980
whether or not a service back-end is the

00:34:37,679 --> 00:34:43,919
right option for you just by what

00:34:39,980 --> 00:34:47,520
metrics do you make that decision versus

00:34:43,919 --> 00:34:49,740
a standalone service so I I think that

00:34:47,520 --> 00:34:51,060
if you have stateless transactions where

00:34:49,740 --> 00:34:53,609
you just want to do some kind of

00:34:51,060 --> 00:34:56,099
computation on the back end that's a

00:34:53,609 --> 00:34:58,200
pretty good use case for server less if

00:34:56,099 --> 00:35:02,010
you do have something like do simple

00:34:58,200 --> 00:35:04,800
lookups that involve maybe dependency to

00:35:02,010 --> 00:35:07,349
a database but not much much else this

00:35:04,800 --> 00:35:10,140
also might be a good solution for server

00:35:07,349 --> 00:35:12,530
less everything more complex especially

00:35:10,140 --> 00:35:14,849
everything that needs routing or has

00:35:12,530 --> 00:35:18,089
different in or implements different

00:35:14,849 --> 00:35:20,820
kinds of intents is probably better

00:35:18,089 --> 00:35:22,890
suited as a standalone service or David

00:35:20,820 --> 00:35:25,349
with the video few as well yeah but

00:35:22,890 --> 00:35:27,900
that's pretty much my ideas well I just

00:35:25,349 --> 00:35:29,790
wanted to add that sometimes your choice

00:35:27,900 --> 00:35:33,330
and what might be there as well in that

00:35:29,790 --> 00:35:35,820
I gave you if you're using the fusing

00:35:33,330 --> 00:35:36,960
service on AWS then it's it's all

00:35:35,820 --> 00:35:39,240
managed for you but if you're talking

00:35:36,960 --> 00:35:41,010
about on-premise and do you have that

00:35:39,240 --> 00:35:43,130
team to match an open waste cluster or

00:35:41,010 --> 00:35:46,010
not in which case it's just

00:35:43,130 --> 00:35:47,480
do your own ethical manage that I can

00:35:46,010 --> 00:35:52,490
give you maybe one practical example

00:35:47,480 --> 00:35:54,410
that's okay you talk on there yeah

00:35:52,490 --> 00:35:55,730
that's okay yeah we can we can talk yeah

00:35:54,410 --> 00:35:59,740
sure sorry about that

00:35:55,730 --> 00:35:59,740

YouTube URL: https://www.youtube.com/watch?v=-R76FrEL_6M


