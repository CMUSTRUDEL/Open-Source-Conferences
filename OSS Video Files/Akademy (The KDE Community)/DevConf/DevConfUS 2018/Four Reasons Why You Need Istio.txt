Title: Four Reasons Why You Need Istio
Publication date: 2019-02-22
Playlist: DevConfUS 2018
Description: 
	Some companies that were born for the cloud, such as Netflix, for example, identified early on that in order to provide resilient services on a cloud world the application would have to protect itself from abnormalities in the environment it is part of. 

At the time the Netflix OSS stack was created, virtual machines were essentially the only way you could run applications on the cloud and they had chosen Java as the language platform for the service mesh-like capabilities and apart from the Java-only aspect, companies that wanted to enforce the usage of those technologies could not do it at the platform level. Istio delivers service mesh control at the platform level and you'll see why you need in this session.
Captions: 
	00:00:09,900 --> 00:00:22,600
go ahead yeah awesome thanks very much

00:00:19,170 --> 00:00:24,130
oh yes please side knee let's say five

00:00:22,600 --> 00:00:25,330
minutes before I would appreciate that

00:00:24,130 --> 00:00:27,790
you tell me yeah

00:00:25,330 --> 00:00:29,470
good thank you so thanks all for being

00:00:27,790 --> 00:00:31,120
here my pleasure being here for this

00:00:29,470 --> 00:00:33,730
talk and I have a lot of content so I'm

00:00:31,120 --> 00:00:35,469
going to run it's going to be recorded

00:00:33,730 --> 00:00:37,089
so you can watch it like even faster on

00:00:35,469 --> 00:00:39,339
YouTube later or slower if you'd like

00:00:37,089 --> 00:00:41,409
that's the good thing about things that

00:00:39,339 --> 00:00:44,530
go to YouTube so this talk is on four

00:00:41,409 --> 00:00:46,089
reasons why I need sto or I took a

00:00:44,530 --> 00:00:48,429
different spin about talking about

00:00:46,089 --> 00:00:49,659
basics of distributed systems right I

00:00:48,429 --> 00:00:51,370
think most people when they're

00:00:49,659 --> 00:00:53,079
developing applications today especially

00:00:51,370 --> 00:00:54,819
if they're in the micro service world

00:00:53,079 --> 00:00:56,739
they kind of forget that they entered

00:00:54,819 --> 00:00:57,999
the realm of distributed system say they

00:00:56,739 --> 00:00:59,469
don't realize that and that's the

00:00:57,999 --> 00:01:01,149
problem right so that's my perspective

00:00:59,469 --> 00:01:03,339
things that you would not be seeing

00:01:01,149 --> 00:01:05,170
today you know obviously source code you

00:01:03,339 --> 00:01:07,450
will not be seen cat if you're expecting

00:01:05,170 --> 00:01:08,979
pictures of cats and you would not be

00:01:07,450 --> 00:01:10,450
seeing introduction to a CEO so there's

00:01:08,979 --> 00:01:12,009
a friend of mine here that's actually

00:01:10,450 --> 00:01:14,229
going to talk maybe a little bit more

00:01:12,009 --> 00:01:17,049
introduction to East EO tomorrow is that

00:01:14,229 --> 00:01:20,860
correctly right Saturday Sunday all

00:01:17,049 --> 00:01:22,539
right so go there so I will talk so this

00:01:20,860 --> 00:01:25,149
is not an introduction to Ecco sessions

00:01:22,539 --> 00:01:26,920
got awesome so my name is DRC's Vettori

00:01:25,149 --> 00:01:29,860
I work at P photo this is my twitter

00:01:26,920 --> 00:01:31,090
handle you can feel free to follow me on

00:01:29,860 --> 00:01:32,829
twitter i'm mostly tweet about

00:01:31,090 --> 00:01:34,509
technology every now and then and a few

00:01:32,829 --> 00:01:36,600
personal thanks but it's a good place to

00:01:34,509 --> 00:01:40,479
catch up on things so let's go to

00:01:36,600 --> 00:01:42,340
distributed systems basics right I think

00:01:40,479 --> 00:01:44,259
firstly let's talk about the advantages

00:01:42,340 --> 00:01:46,149
of writing distributed application so

00:01:44,259 --> 00:01:48,179
what was once a big application let's

00:01:46,149 --> 00:01:50,439
let's let's see the advantages of

00:01:48,179 --> 00:01:53,079
distributing they often be distributed

00:01:50,439 --> 00:01:55,119
systems they become more reliable they

00:01:53,079 --> 00:01:57,189
become Morrisville scalable just by the

00:01:55,119 --> 00:01:59,289
nature that was what was once a single

00:01:57,189 --> 00:02:01,450
piece and hard to scale it's now

00:01:59,289 --> 00:02:03,280
distributed in smaller pieces that can

00:02:01,450 --> 00:02:05,259
probably should at least probably scale

00:02:03,280 --> 00:02:07,149
individually right now the problem of

00:02:05,259 --> 00:02:08,830
that is that the engineering skills

00:02:07,149 --> 00:02:12,610
required to write and develop

00:02:08,830 --> 00:02:15,969
distributed systems they are

00:02:12,610 --> 00:02:18,099
more complicated than then you would

00:02:15,969 --> 00:02:19,480
write a single Mon of this app if you're

00:02:18,099 --> 00:02:22,269
writing an application that's composed

00:02:19,480 --> 00:02:23,590
by 1520 different pieces pieces that is

00:02:22,269 --> 00:02:25,209
more complicated than writing an

00:02:23,590 --> 00:02:27,670
application that's going to be packaged

00:02:25,209 --> 00:02:30,280
as one file and run on a Android or

00:02:27,670 --> 00:02:32,470
mobile form for example just the basics

00:02:30,280 --> 00:02:34,180
of that right also when dealing with

00:02:32,470 --> 00:02:36,220
distributed systems there's an

00:02:34,180 --> 00:02:38,709
increasing need for tools and patterns

00:02:36,220 --> 00:02:40,540
that facilitate write so on patterns I

00:02:38,709 --> 00:02:41,980
recommend a very good book by Brendan

00:02:40,540 --> 00:02:43,829
Barnes one of the creators of Q Burnett

00:02:41,980 --> 00:02:46,450
is he created a wrote a book on

00:02:43,829 --> 00:02:48,250
distributed signing distributed systems

00:02:46,450 --> 00:02:49,959
it's like a short read that you can

00:02:48,250 --> 00:02:52,389
probably read in a day it's not even 200

00:02:49,959 --> 00:02:54,220
pages but I strongly recommend and I'm

00:02:52,389 --> 00:02:55,659
going to address some of the patterns

00:02:54,220 --> 00:02:57,280
that he talked about in this book in

00:02:55,659 --> 00:02:59,889
this session so it's going to be good

00:02:57,280 --> 00:03:01,569
for that right let's go to you talking

00:02:59,889 --> 00:03:03,459
about bad news on distributed systems

00:03:01,569 --> 00:03:05,349
right it's it's hard right so one of the

00:03:03,459 --> 00:03:07,659
other bad news and distributed systems

00:03:05,349 --> 00:03:10,450
is that you're often dealing with chains

00:03:07,659 --> 00:03:12,310
of calls so what was once a call or

00:03:10,450 --> 00:03:13,750
let's say many operations called super

00:03:12,310 --> 00:03:17,109
functions that happen inside a single

00:03:13,750 --> 00:03:18,879
application a single package now this

00:03:17,109 --> 00:03:20,379
calls they're happening across this is

00:03:18,879 --> 00:03:22,000
routed networks of applications right

00:03:20,379 --> 00:03:24,400
and the problem with that and when

00:03:22,000 --> 00:03:25,359
there's a problem with let's say one of

00:03:24,400 --> 00:03:26,979
your components

00:03:25,359 --> 00:03:28,720
it becomes certainly much harder to

00:03:26,979 --> 00:03:30,549
debug you can't just open a debugger and

00:03:28,720 --> 00:03:32,650
see what's going on with that specific

00:03:30,549 --> 00:03:34,659
piece of technology because first you

00:03:32,650 --> 00:03:37,540
have to know where things are failing

00:03:34,659 --> 00:03:38,949
right so that is the problem so like how

00:03:37,540 --> 00:03:40,449
do you know exactly where the problem is

00:03:38,949 --> 00:03:42,190
happening so this is one of the problems

00:03:40,449 --> 00:03:45,069
with the good distributed systems just

00:03:42,190 --> 00:03:47,409
identifying where the fault is another

00:03:45,069 --> 00:03:48,909
problem and that makes distributed

00:03:47,409 --> 00:03:50,680
systems hard is that you're dealing with

00:03:48,909 --> 00:03:53,019
different types of protocols again if

00:03:50,680 --> 00:03:55,000
you had one big monolith most of the

00:03:53,019 --> 00:03:56,859
calls they were internal calls libraries

00:03:55,000 --> 00:03:58,870
dependencies or just like calling a

00:03:56,859 --> 00:04:00,040
function from another functions you

00:03:58,870 --> 00:04:01,930
don't necessarily have to deal with

00:04:00,040 --> 00:04:03,699
different types of protocols but again

00:04:01,930 --> 00:04:05,079
when dealing with distributed systems

00:04:03,699 --> 00:04:06,909
some communications they're going to be

00:04:05,079 --> 00:04:09,549
message based some are going to be HTTP

00:04:06,909 --> 00:04:12,310
based some are going to use protobuf G

00:04:09,549 --> 00:04:14,199
RPC some are going to use a file base so

00:04:12,310 --> 00:04:15,939
like the the just the nature that are

00:04:14,199 --> 00:04:18,940
now dealing with also different types of

00:04:15,939 --> 00:04:21,219
protocols makes it hard to develop

00:04:18,940 --> 00:04:22,120
distributed systems right so have that

00:04:21,219 --> 00:04:23,810
in mind when you're writing

00:04:22,120 --> 00:04:26,570
micro-services applications

00:04:23,810 --> 00:04:28,190
that the real me RN it's in there almost

00:04:26,570 --> 00:04:31,480
disability distributed applications

00:04:28,190 --> 00:04:34,310
which brings you to a very important

00:04:31,480 --> 00:04:36,530
piece of this cordis this talk which is

00:04:34,310 --> 00:04:39,500
the fallacies of distributed computing

00:04:36,530 --> 00:04:41,050
right these are mistakes that developers

00:04:39,500 --> 00:04:44,180
make when they're developing

00:04:41,050 --> 00:04:46,160
applications without thinking that they

00:04:44,180 --> 00:04:48,230
are now part of a distributed system

00:04:46,160 --> 00:04:49,669
network of applications so how do you

00:04:48,230 --> 00:04:51,590
mind most of these concepts they were

00:04:49,669 --> 00:04:54,590
from the 80s and one of them was

00:04:51,590 --> 00:04:56,240
incorporated in the early 90s right so

00:04:54,590 --> 00:04:57,860
there are old concepts that exist in

00:04:56,240 --> 00:04:59,810
software development but they are very

00:04:57,860 --> 00:05:02,810
important first of them is that we often

00:04:59,810 --> 00:05:04,880
developed thinking that the network and

00:05:02,810 --> 00:05:06,590
there eight the network that we're

00:05:04,880 --> 00:05:08,510
dealing with it's a reliable network

00:05:06,590 --> 00:05:11,419
they descend somehow trust the network

00:05:08,510 --> 00:05:14,090
I'm going to connect talk a to be and as

00:05:11,419 --> 00:05:15,890
a developer you expect yeah the the call

00:05:14,090 --> 00:05:17,540
is going to get there right so this is a

00:05:15,890 --> 00:05:18,590
problem we developed thinking that

00:05:17,540 --> 00:05:20,990
that's not the case

00:05:18,590 --> 00:05:23,300
another problem is that bandwidth is

00:05:20,990 --> 00:05:25,190
infinite and not only bandwidth as in

00:05:23,300 --> 00:05:26,650
the ability to transmit information but

00:05:25,190 --> 00:05:29,690
the ability to process that information

00:05:26,650 --> 00:05:31,729
because bandwidth stops being a problem

00:05:29,690 --> 00:05:33,860
the moment whoever's receiving a call

00:05:31,729 --> 00:05:35,660
doesn't have the ability to process that

00:05:33,860 --> 00:05:37,550
information so more than bandwidth

00:05:35,660 --> 00:05:40,669
itself just the ability to process

00:05:37,550 --> 00:05:42,770
information funny note on bandwidth is

00:05:40,669 --> 00:05:44,570
that while it's from a technology

00:05:42,770 --> 00:05:46,880
perspective we've been able to increase

00:05:44,570 --> 00:05:49,490
bandwidth in communications by more than

00:05:46,880 --> 00:05:52,100
a thousand times for the last 10 15

00:05:49,490 --> 00:05:54,260
years the latencies to a problem right

00:05:52,100 --> 00:05:56,300
just so you know like the the amount of

00:05:54,260 --> 00:05:59,180
time it takes from one ping one let's

00:05:56,300 --> 00:06:01,220
say if you make a record call to a

00:05:59,180 --> 00:06:04,370
service from New York to London and back

00:06:01,220 --> 00:06:06,950
without zero-zero-zero processing time

00:06:04,370 --> 00:06:09,320
it's 38 milliseconds just in latency

00:06:06,950 --> 00:06:11,140
right so often we don't think about it

00:06:09,320 --> 00:06:13,880
when developing applications especially

00:06:11,140 --> 00:06:16,010
distributed systems so only in physics

00:06:13,880 --> 00:06:19,010
basic speed of light it takes 38

00:06:16,010 --> 00:06:23,000
milliseconds for a pig back think back

00:06:19,010 --> 00:06:24,650
from New York to chew on so that in mind

00:06:23,000 --> 00:06:27,620
the second do is that we often think

00:06:24,650 --> 00:06:29,600
networks are secure networks are not

00:06:27,620 --> 00:06:31,729
secure and I'll give you like three few

00:06:29,600 --> 00:06:32,800
interesting some interesting example

00:06:31,729 --> 00:06:36,160
later on

00:06:32,800 --> 00:06:38,800
topology doesn't change this is this is

00:06:36,160 --> 00:06:40,660
one that's like myself as a developer in

00:06:38,800 --> 00:06:42,610
my early days of development I never

00:06:40,660 --> 00:06:45,430
thought about it and I'll talk about it

00:06:42,610 --> 00:06:47,140
why latency zero as I mentioned it about

00:06:45,430 --> 00:06:48,940
latency as well that like we think that

00:06:47,140 --> 00:06:51,160
communication is going to immediately

00:06:48,940 --> 00:06:52,090
get where we think and again like as

00:06:51,160 --> 00:06:54,310
developers

00:06:52,090 --> 00:06:55,990
I don't remember myself thinking like

00:06:54,310 --> 00:06:57,930
five ten years ago about this when

00:06:55,990 --> 00:07:02,170
developing an application I assumed

00:06:57,930 --> 00:07:04,330
everything here was true in my source

00:07:02,170 --> 00:07:08,110
code and the things that I develop which

00:07:04,330 --> 00:07:09,730
is wrong right continuing there is one

00:07:08,110 --> 00:07:11,050
administrator right so that this

00:07:09,730 --> 00:07:14,400
essentially means like oh there's one

00:07:11,050 --> 00:07:16,570
person I have to talk to there's one

00:07:14,400 --> 00:07:19,480
let's say there's just a single system

00:07:16,570 --> 00:07:22,840
but there's one group of people and then

00:07:19,480 --> 00:07:25,570
this is this has become let's say not so

00:07:22,840 --> 00:07:27,880
so much of a problem lately but when was

00:07:25,570 --> 00:07:30,550
created yes another ones that transport

00:07:27,880 --> 00:07:33,430
cost is zero like how much how many

00:07:30,550 --> 00:07:35,530
times we think about the payload versus

00:07:33,430 --> 00:07:37,420
the overhead of a call of a request let

00:07:35,530 --> 00:07:39,130
me make it right and I think we do it

00:07:37,420 --> 00:07:41,350
that often right unless you're dealing

00:07:39,130 --> 00:07:44,800
with let's say unless that is a problem

00:07:41,350 --> 00:07:46,810
or impacts your business and the often

00:07:44,800 --> 00:07:48,700
we see people doing when that starts to

00:07:46,810 --> 00:07:51,190
impact business so I owe my network bill

00:07:48,700 --> 00:07:53,080
for AWS is starting to become a little

00:07:51,190 --> 00:07:55,660
bit complicated what am i doing how can

00:07:53,080 --> 00:07:58,030
I bring down the number of bits that I

00:07:55,660 --> 00:07:59,800
transmit and the other one is that the

00:07:58,030 --> 00:08:00,880
network is modulus that the network

00:07:59,800 --> 00:08:02,320
doesn't change so these are all

00:08:00,880 --> 00:08:04,420
fallacies these are all things that I

00:08:02,320 --> 00:08:07,390
did bad things that I did when

00:08:04,420 --> 00:08:10,570
developing applications that I forgot to

00:08:07,390 --> 00:08:12,700
think about that this are all lies right

00:08:10,570 --> 00:08:14,560
so have that in mind and of course this

00:08:12,700 --> 00:08:16,270
is a presentation on East you so I'm

00:08:14,560 --> 00:08:18,700
going to talk about first there four

00:08:16,270 --> 00:08:21,460
things in each geo that I believe we

00:08:18,700 --> 00:08:23,110
still help you with now II still can

00:08:21,460 --> 00:08:24,760
certainly help you four of them but I

00:08:23,110 --> 00:08:26,190
want to touch especially given the time

00:08:24,760 --> 00:08:28,540
I want to touch them four of these right

00:08:26,190 --> 00:08:30,700
that the network is reliable please

00:08:28,540 --> 00:08:32,530
forget that this is what's here is not

00:08:30,700 --> 00:08:36,320
true there are all fallacies so every

00:08:32,530 --> 00:08:38,120
single thing that's here is a lie okay

00:08:36,320 --> 00:08:40,280
let's talk about Network reliable just

00:08:38,120 --> 00:08:42,380
introducing the concepts a little bit if

00:08:40,280 --> 00:08:43,850
there are a few ways you can think about

00:08:42,380 --> 00:08:46,670
network if you just consider

00:08:43,850 --> 00:08:48,890
mtbf main time before failure of network

00:08:46,670 --> 00:08:51,130
equipment or service that are is already

00:08:48,890 --> 00:08:53,540
a measure of things that things go fail

00:08:51,130 --> 00:08:56,330
there's the stacking that can be applied

00:08:53,540 --> 00:08:58,760
if you stack this routers or network

00:08:56,330 --> 00:09:02,290
components in parallel then you probably

00:08:58,760 --> 00:09:04,700
get twice the MTBF but if you make them

00:09:02,290 --> 00:09:08,020
serial then you get half right so this

00:09:04,700 --> 00:09:12,200
again there's just a physical nature of

00:09:08,020 --> 00:09:14,990
hardware failing and this is a switch by

00:09:12,200 --> 00:09:16,910
the way and there's also the aspect that

00:09:14,990 --> 00:09:19,010
every single network that we run today

00:09:16,910 --> 00:09:21,110
is some sort of virtual network not

00:09:19,010 --> 00:09:23,330
necessarily a cable directly connected

00:09:21,110 --> 00:09:25,220
to a switch but you have to also factor

00:09:23,330 --> 00:09:27,230
that the machines that are running the

00:09:25,220 --> 00:09:28,220
networks they are processing many many

00:09:27,230 --> 00:09:29,780
other things as well

00:09:28,220 --> 00:09:31,220
which they can either names operating

00:09:29,780 --> 00:09:33,410
environment can have a virtual machine

00:09:31,220 --> 00:09:34,610
and that's amazing so we don't think

00:09:33,410 --> 00:09:36,680
about that when developing the

00:09:34,610 --> 00:09:38,240
applications that the actual networks

00:09:36,680 --> 00:09:40,160
they are not necessarily reliable and

00:09:38,240 --> 00:09:44,000
these are servers they look very bad but

00:09:40,160 --> 00:09:46,160
their service and now the second point

00:09:44,000 --> 00:09:48,770
which I'm going to address is that the

00:09:46,160 --> 00:09:51,200
network is reliable and I made let's say

00:09:48,770 --> 00:09:53,630
using some like poetic freedom here I

00:09:51,200 --> 00:09:56,900
just changed the word network from the

00:09:53,630 --> 00:09:58,550
end point is that many many times we

00:09:56,900 --> 00:10:00,350
think that we're when they're connecting

00:09:58,550 --> 00:10:03,290
interfacing with an external application

00:10:00,350 --> 00:10:04,940
or endpoint we tend to think that that

00:10:03,290 --> 00:10:07,370
end point is going to be there for you

00:10:04,940 --> 00:10:09,590
it's going to be right and we don't

00:10:07,370 --> 00:10:11,390
offer the often design applications

00:10:09,590 --> 00:10:14,030
thinking that whatever endpoint I'm

00:10:11,390 --> 00:10:15,650
connecting to my not be available may

00:10:14,030 --> 00:10:18,440
not be available to handle my request

00:10:15,650 --> 00:10:20,840
right so just switching a little bit

00:10:18,440 --> 00:10:23,840
this one from the network is reliable to

00:10:20,840 --> 00:10:25,940
the endpoint is reliable and a big

00:10:23,840 --> 00:10:27,800
mistake that I did which is like a very

00:10:25,940 --> 00:10:30,260
strong recommendation that I give it to

00:10:27,800 --> 00:10:32,060
you is that I always designed for

00:10:30,260 --> 00:10:34,400
reliable endpoints assuming that

00:10:32,060 --> 00:10:36,470
whatever I was going to interface with

00:10:34,400 --> 00:10:38,870
was going to be there always all the

00:10:36,470 --> 00:10:41,839
time so I never had to deal with let's

00:10:38,870 --> 00:10:44,029
say let's say alternative

00:10:41,839 --> 00:10:45,949
ereferral off laws for applications when

00:10:44,029 --> 00:10:48,110
integrated with other systems because

00:10:45,949 --> 00:10:50,389
very interesting we assume if this

00:10:48,110 --> 00:10:51,949
applications are not running my

00:10:50,389 --> 00:10:53,750
application is not going to work if this

00:10:51,949 --> 00:10:57,079
do systems that need to work together if

00:10:53,750 --> 00:10:58,639
they're not often running then then my

00:10:57,079 --> 00:11:01,819
application is not going to work but

00:10:58,639 --> 00:11:03,889
many many times I ended up compromising

00:11:01,819 --> 00:11:06,740
the experience of my application I'm the

00:11:03,889 --> 00:11:09,500
honor of BA because the application B

00:11:06,740 --> 00:11:11,779
was not running there so a very

00:11:09,500 --> 00:11:14,269
important recommendation is designed for

00:11:11,779 --> 00:11:16,100
our reliable endpoints right design for

00:11:14,269 --> 00:11:18,189
endpoints it might not be there when

00:11:16,100 --> 00:11:20,029
you're developing and again especially

00:11:18,189 --> 00:11:21,769
micro-services and eigem whenever you

00:11:20,029 --> 00:11:24,230
hear micro services please also hear

00:11:21,769 --> 00:11:25,699
distributed systems and distributed

00:11:24,230 --> 00:11:29,779
computing because that's what's really

00:11:25,699 --> 00:11:31,610
happening the forest policy that I'm

00:11:29,779 --> 00:11:33,709
addressing and hopefully I'll talk about

00:11:31,610 --> 00:11:36,769
what is - has to do with them as well

00:11:33,709 --> 00:11:38,990
I'm ok with time it seems is that the

00:11:36,769 --> 00:11:42,800
network is secure and this is specially

00:11:38,990 --> 00:11:44,449
interesting right not necessarily

00:11:42,800 --> 00:11:47,120
talking about the network itself whether

00:11:44,449 --> 00:11:48,980
or not the communication that's a

00:11:47,120 --> 00:11:51,230
physical channel physical network

00:11:48,980 --> 00:11:53,449
channel is secure not but whether or not

00:11:51,230 --> 00:11:56,449
the communication between applications

00:11:53,449 --> 00:11:59,509
is secure right now how many of you

00:11:56,449 --> 00:12:01,790
remember the Equifax breach about it's

00:11:59,509 --> 00:12:03,920
not even a year ago right I'm sure those

00:12:01,790 --> 00:12:06,139
of you that live in the u.s. think you

00:12:03,920 --> 00:12:08,120
have to at least spend one hour of your

00:12:06,139 --> 00:12:10,250
time thinking like how does this will

00:12:08,120 --> 00:12:12,230
impact me right am I going to sign up

00:12:10,250 --> 00:12:14,360
for the the package that I profess that

00:12:12,230 --> 00:12:16,100
I have to fax this offering so like all

00:12:14,360 --> 00:12:18,559
these things we have to think about and

00:12:16,100 --> 00:12:20,540
when when you think about like what

00:12:18,559 --> 00:12:24,319
created that it was like okay you can

00:12:20,540 --> 00:12:27,050
sort of blainley unpatched struts

00:12:24,319 --> 00:12:29,750
vulnerability it's that's how people got

00:12:27,050 --> 00:12:31,579
access to technology but then there is

00:12:29,750 --> 00:12:33,680
the impact software every day right like

00:12:31,579 --> 00:12:37,399
we need to keep patching our software or

00:12:33,680 --> 00:12:40,009
fixing bugs every day right so is it is

00:12:37,399 --> 00:12:42,319
it enough that I guess the developer can

00:12:40,009 --> 00:12:43,910
just blame unpacked software do

00:12:42,319 --> 00:12:46,699
vulnerability like this I think that's

00:12:43,910 --> 00:12:49,040
so naive to tell right because and we

00:12:46,699 --> 00:12:50,380
all know that security is not a one-time

00:12:49,040 --> 00:12:53,410
exercise and subract

00:12:50,380 --> 00:12:56,350
that you need to have and I spent some

00:12:53,410 --> 00:12:58,630
time that's it's some time reading a

00:12:56,350 --> 00:13:01,060
little bit more about like what and how

00:12:58,630 --> 00:13:02,680
the vulnerability happened and what was

00:13:01,060 --> 00:13:04,000
happening sort of like this so like

00:13:02,680 --> 00:13:06,730
there was an applicator there was like

00:13:04,000 --> 00:13:09,930
users here evil users here I should have

00:13:06,730 --> 00:13:12,490
like put a sad face here talking to a

00:13:09,930 --> 00:13:14,650
external facing app that was using

00:13:12,490 --> 00:13:16,630
struts stress itself was great

00:13:14,650 --> 00:13:18,190
technology back the end the patterns and

00:13:16,630 --> 00:13:19,990
straightest you used it's a moderate

00:13:18,190 --> 00:13:22,000
view controller pattern great for

00:13:19,990 --> 00:13:24,490
separating concerns inside applications

00:13:22,000 --> 00:13:26,590
now this route struts app was run inside

00:13:24,490 --> 00:13:28,450
the DMZ which is often the type of

00:13:26,590 --> 00:13:30,610
network that separates an internal

00:13:28,450 --> 00:13:35,110
network from an externally assessment at

00:13:30,610 --> 00:13:37,600
work right and this route app has access

00:13:35,110 --> 00:13:40,270
to a DMZ TVs la razÃ³n right so the now

00:13:37,600 --> 00:13:42,820
the thing is that and that's when I say

00:13:40,270 --> 00:13:47,980
that the application network is secure

00:13:42,820 --> 00:13:50,620
is that this streets had unrestricted

00:13:47,980 --> 00:13:53,920
access to other applications that it

00:13:50,620 --> 00:13:56,710
should not right so that's how the fader

00:13:53,920 --> 00:13:58,660
happened is that someone got access to

00:13:56,710 --> 00:14:01,300
use the vulnerability to have access to

00:13:58,660 --> 00:14:04,420
this application and then this should

00:14:01,300 --> 00:14:06,730
have even though we had a specified flow

00:14:04,420 --> 00:14:09,820
of information it should go to had

00:14:06,730 --> 00:14:12,070
access to other types of components

00:14:09,820 --> 00:14:14,440
inside the application which were then

00:14:12,070 --> 00:14:16,270
exploited to get our data right so that

00:14:14,440 --> 00:14:18,910
means that tells me that whatever

00:14:16,270 --> 00:14:20,140
application network we had here was not

00:14:18,910 --> 00:14:22,480
secure so when you have that in mind

00:14:20,140 --> 00:14:24,880
that you're not necessary about the

00:14:22,480 --> 00:14:27,670
physical communication networks but also

00:14:24,880 --> 00:14:29,260
like how much information are you

00:14:27,670 --> 00:14:32,530
exposing from your application to

00:14:29,260 --> 00:14:34,060
networks should a database allow 30

00:14:32,530 --> 00:14:35,920
million formation from 30 million

00:14:34,060 --> 00:14:38,860
subscribers to be retrieved should that

00:14:35,920 --> 00:14:41,140
have raised a long-arm probably should I

00:14:38,860 --> 00:14:43,420
receive a call from a user that I don't

00:14:41,140 --> 00:14:45,940
know who that user is from I receive

00:14:43,420 --> 00:14:48,010
tons of calls from a user that should

00:14:45,940 --> 00:14:51,880
not be making those sorts of calls so

00:14:48,010 --> 00:14:54,370
those are all let's say red alerts that

00:14:51,880 --> 00:14:55,870
we should have that something wrong and

00:14:54,370 --> 00:14:58,150
weird is going on so I have that in mind

00:14:55,870 --> 00:15:00,410
application it's not secure now the

00:14:58,150 --> 00:15:01,700
other one its topology doesn't

00:15:00,410 --> 00:15:03,440
so as a developer here you are

00:15:01,700 --> 00:15:05,180
developing your application so this is

00:15:03,440 --> 00:15:06,620
you developing your application and you

00:15:05,180 --> 00:15:08,570
know your Stack Overflow because you

00:15:06,620 --> 00:15:10,490
don't know what you're doing and then

00:15:08,570 --> 00:15:12,560
and then you develop your application

00:15:10,490 --> 00:15:15,860
and then it runs in your machine and

00:15:12,560 --> 00:15:17,810
it's great we always test some aspect of

00:15:15,860 --> 00:15:20,330
the application on our own machines I'm

00:15:17,810 --> 00:15:22,730
just using this example to justify that

00:15:20,330 --> 00:15:24,410
typologies do chain write the topology

00:15:22,730 --> 00:15:26,810
of the network in which your application

00:15:24,410 --> 00:15:28,550
participates in your machine there in

00:15:26,810 --> 00:15:30,800
itself it's different from the how the

00:15:28,550 --> 00:15:32,990
application looks like in queue in

00:15:30,800 --> 00:15:34,400
production right so we often think that

00:15:32,990 --> 00:15:36,020
topology is not going to change people

00:15:34,400 --> 00:15:37,520
like just from the developing

00:15:36,020 --> 00:15:39,290
environment the applications that are

00:15:37,520 --> 00:15:41,840
running over here java application c

00:15:39,290 --> 00:15:43,580
golang just the network of that

00:15:41,840 --> 00:15:45,140
environment it's going to it's different

00:15:43,580 --> 00:15:47,180
than the network of other environments

00:15:45,140 --> 00:15:48,560
so from the moment you are developing an

00:15:47,180 --> 00:15:50,090
application to the moment you're going

00:15:48,560 --> 00:15:51,890
to run that application either in a

00:15:50,090 --> 00:15:53,990
queue environment or in a production

00:15:51,890 --> 00:15:57,380
environment the application topology is

00:15:53,990 --> 00:16:01,340
going to change right yes that's the

00:15:57,380 --> 00:16:03,770
point they are different now there are

00:16:01,340 --> 00:16:05,300
more complications right in terms of

00:16:03,770 --> 00:16:08,360
topology doesn't change if you are

00:16:05,300 --> 00:16:11,060
dealing with sensitive information

00:16:08,360 --> 00:16:14,360
either from let's say pH I which is

00:16:11,060 --> 00:16:17,000
patient health information under a HIPAA

00:16:14,360 --> 00:16:17,660
compliance or PCI DSS payment card

00:16:17,000 --> 00:16:20,780
industry

00:16:17,660 --> 00:16:23,660
I forgot the designation for DSS there

00:16:20,780 --> 00:16:25,370
are rules that tell you that code

00:16:23,660 --> 00:16:26,720
running in production should be

00:16:25,370 --> 00:16:28,550
separated from called

00:16:26,720 --> 00:16:30,440
running in a queue environment which

00:16:28,550 --> 00:16:31,850
often case a you can say something that

00:16:30,440 --> 00:16:34,040
the topology of a production environment

00:16:31,850 --> 00:16:35,630
of the network is likely going to be

00:16:34,040 --> 00:16:37,250
different right so this is a slide from

00:16:35,630 --> 00:16:39,320
a reason for the recent presentation

00:16:37,250 --> 00:16:41,720
given at the Boston kubernetes meetup

00:16:39,320 --> 00:16:43,790
that I run and I love this because it

00:16:41,720 --> 00:16:46,790
was someone talking about how they run

00:16:43,790 --> 00:16:48,320
kubernetes in a PCI DSS environment so

00:16:46,790 --> 00:16:49,760
like how to run key Benares in the

00:16:48,320 --> 00:16:51,440
environment where it's going to be

00:16:49,760 --> 00:16:53,810
handling and dealing with credit card

00:16:51,440 --> 00:16:55,880
information and there's a rule and in

00:16:53,810 --> 00:16:57,230
the PCI DSS that says the separate

00:16:55,880 --> 00:16:58,640
development test environments for

00:16:57,230 --> 00:17:00,950
production environments and for

00:16:58,640 --> 00:17:03,410
separation with access controls this is

00:17:00,950 --> 00:17:05,839
again just find that yes topologies are

00:17:03,410 --> 00:17:08,030
different if you're developing assuming

00:17:05,839 --> 00:17:09,340
that the way things look in your laptop

00:17:08,030 --> 00:17:12,370
right the way they look

00:17:09,340 --> 00:17:15,130
production that's not a probability a

00:17:12,370 --> 00:17:18,070
good assumption now with the fact that

00:17:15,130 --> 00:17:25,960
the policies do change a another problem

00:17:18,070 --> 00:17:28,900
comes to us which is how do we deal with

00:17:25,960 --> 00:17:31,030
changing topology in an effective manner

00:17:28,900 --> 00:17:35,980
and this is where bad news comes right

00:17:31,030 --> 00:17:40,060
this is data from the last DevOps State

00:17:35,980 --> 00:17:44,770
of DevOps report 2017 and this tells

00:17:40,060 --> 00:17:48,210
that only 28% of the high performing

00:17:44,770 --> 00:17:52,120
companies high performing companies have

00:17:48,210 --> 00:17:54,070
automated configuration management for

00:17:52,120 --> 00:17:56,560
their applications right this is very

00:17:54,070 --> 00:17:58,390
bad because the very performant

00:17:56,560 --> 00:18:00,070
companies they have a high performing

00:17:58,390 --> 00:18:01,810
companies what does it mean for that at

00:18:00,070 --> 00:18:04,570
least in that context one of the metrics

00:18:01,810 --> 00:18:06,550
is that you are able to turn in a code

00:18:04,570 --> 00:18:09,310
change in production in less than one

00:18:06,550 --> 00:18:10,990
hour right and this is not how long does

00:18:09,310 --> 00:18:13,180
it take for you to the deployment it's

00:18:10,990 --> 00:18:15,100
like from the moment a code is pushed to

00:18:13,180 --> 00:18:16,750
a repo how long does it take for that

00:18:15,100 --> 00:18:19,060
code to be packaged tested and deployed

00:18:16,750 --> 00:18:21,220
and run in production right so companies

00:18:19,060 --> 00:18:22,690
do that and that the effective companies

00:18:21,220 --> 00:18:24,700
they do that in less one hour this

00:18:22,690 --> 00:18:27,100
metric is called the lead time right so

00:18:24,700 --> 00:18:28,630
the lead time between a fix is fixed or

00:18:27,100 --> 00:18:30,190
a new feature is implemented it's in

00:18:28,630 --> 00:18:32,350
court it's in code it's in a repository

00:18:30,190 --> 00:18:34,210
and from the moment that reaches

00:18:32,350 --> 00:18:36,100
production so the lead time it's one

00:18:34,210 --> 00:18:38,770
hour so companies that are ultra high

00:18:36,100 --> 00:18:40,240
performance they do that in less than

00:18:38,770 --> 00:18:41,710
one hour so it's one hour from the

00:18:40,240 --> 00:18:43,630
moment the code is there to the code is

00:18:41,710 --> 00:18:46,030
running production right passing of

00:18:43,630 --> 00:18:47,680
course many gates many checks sometimes

00:18:46,030 --> 00:18:49,870
there are even manual checks but the

00:18:47,680 --> 00:18:52,750
problem is that dynamic configuration

00:18:49,870 --> 00:18:54,700
management is hard and I tell you it's

00:18:52,750 --> 00:19:00,040
hard because the very high performing

00:18:54,700 --> 00:19:01,810
companies only 28% of them do that so

00:19:00,040 --> 00:19:05,440
it's it's complicated

00:19:01,810 --> 00:19:08,410
it's very complicated so there's again

00:19:05,440 --> 00:19:11,110
manual steps involvement

00:19:08,410 --> 00:19:12,520
and and the fact about the point about

00:19:11,110 --> 00:19:14,110
the polity changing dynamic

00:19:12,520 --> 00:19:16,270
configuration management that he should

00:19:14,110 --> 00:19:18,220
be able to dynamically know where things

00:19:16,270 --> 00:19:20,940
are running right so if you need to

00:19:18,220 --> 00:19:24,040
someone to change the IP of a database

00:19:20,940 --> 00:19:27,160
manually that's not necessarily dynamic

00:19:24,040 --> 00:19:29,140
configuration right happen if the

00:19:27,160 --> 00:19:31,270
endpoint of an application changes from

00:19:29,140 --> 00:19:33,700
one IP to the other and someone has to

00:19:31,270 --> 00:19:35,020
do that manually if the port changes

00:19:33,700 --> 00:19:36,820
that someone has to do that manually

00:19:35,020 --> 00:19:41,560
that's not a dynamic configuration man

00:19:36,820 --> 00:19:43,480
right hopefully you know that there are

00:19:41,560 --> 00:19:45,430
ways to do this and and you talk about

00:19:43,480 --> 00:19:47,290
bandwidth is infinite I'm going to have

00:19:45,430 --> 00:19:49,270
to derail this conversation a bit so

00:19:47,290 --> 00:19:51,390
that's why the tracks and apparently an

00:19:49,270 --> 00:19:54,550
arrow that you're getting off tracks

00:19:51,390 --> 00:19:56,230
good so again their concepts from the

00:19:54,550 --> 00:19:59,830
distributed systems design instability

00:19:56,230 --> 00:20:01,930
systems book there are three ways you

00:19:59,830 --> 00:20:03,400
can sort through patterns for designing

00:20:01,930 --> 00:20:04,930
distributed applications to groups

00:20:03,400 --> 00:20:06,490
actually right so there's a single node

00:20:04,930 --> 00:20:09,070
group which is a techniques that you

00:20:06,490 --> 00:20:10,960
apply to applications running close to

00:20:09,070 --> 00:20:12,640
each other in a single node so even

00:20:10,960 --> 00:20:15,840
though it's distributed systems you

00:20:12,640 --> 00:20:18,190
still can take advantage of running

00:20:15,840 --> 00:20:19,840
patterns such as side kites sidecar

00:20:18,190 --> 00:20:21,880
pattern or Ambassador pattern which is

00:20:19,840 --> 00:20:23,110
you bring some sort of intelligence

00:20:21,880 --> 00:20:25,180
close to the workload that you're

00:20:23,110 --> 00:20:27,160
running there's also serving patterns

00:20:25,180 --> 00:20:29,410
which is the more popular one so you

00:20:27,160 --> 00:20:31,780
have like a web server and you replicate

00:20:29,410 --> 00:20:33,760
that web server you have ten copies of

00:20:31,780 --> 00:20:36,550
that web server that is a distributed

00:20:33,760 --> 00:20:38,890
system pattern and batch which the name

00:20:36,550 --> 00:20:40,810
says it's packed right so again the

00:20:38,890 --> 00:20:42,430
stateless it's very popular you just

00:20:40,810 --> 00:20:43,540
have like a stateless application and

00:20:42,430 --> 00:20:45,430
you need to do something with it you

00:20:43,540 --> 00:20:48,040
replicate as many copies as you'd like

00:20:45,430 --> 00:20:49,630
because they don't handle state or state

00:20:48,040 --> 00:20:51,160
is handled somewhere else right the

00:20:49,630 --> 00:20:52,900
state is always handled somewhere so we

00:20:51,160 --> 00:20:55,030
tickle it it's kind of complicated to

00:20:52,900 --> 00:20:56,710
say there's also there's always state

00:20:55,030 --> 00:20:58,240
being handle somewhere you just make

00:20:56,710 --> 00:21:00,010
many copies of the exact same

00:20:58,240 --> 00:21:02,560
application and you're good with that

00:21:00,010 --> 00:21:04,330
right now Charlotte it's another pattern

00:21:02,560 --> 00:21:07,060
for distributing in and Charlotte is

00:21:04,330 --> 00:21:08,770
especially used when there's a very

00:21:07,060 --> 00:21:10,900
large amount of data involved because

00:21:08,770 --> 00:21:13,090
think about that if the data is small

00:21:10,900 --> 00:21:14,920
enough that you can have copies of data

00:21:13,090 --> 00:21:17,230
keep them consistency like in many nodes

00:21:14,920 --> 00:21:20,110
if it's small enough then there's

00:21:17,230 --> 00:21:21,730
advantages in keeping that but when when

00:21:20,110 --> 00:21:27,130
you have large pieces of data and it's

00:21:21,730 --> 00:21:29,230
expensive to keep copies of all all all

00:21:27,130 --> 00:21:30,610
the data then you start thinking about

00:21:29,230 --> 00:21:32,559
charting which is when you distribute

00:21:30,610 --> 00:21:36,279
the data you gather data and distribute

00:21:32,559 --> 00:21:37,480
it so that you don't have to store all

00:21:36,279 --> 00:21:39,789
the data all the time in all the

00:21:37,480 --> 00:21:41,289
replicas right if you're doing charted

00:21:39,789 --> 00:21:44,980
right you should always think that

00:21:41,289 --> 00:21:46,539
having one replica of the data it's not

00:21:44,980 --> 00:21:47,679
enough if that goes down you're gonna

00:21:46,539 --> 00:21:50,110
have disruption you don't want

00:21:47,679 --> 00:21:52,360
disruption so often right this charted

00:21:50,110 --> 00:21:54,460
data deployments they come together if

00:21:52,360 --> 00:21:55,929
replicated data model so there is some

00:21:54,460 --> 00:21:57,549
part that's charted and you're also

00:21:55,929 --> 00:22:00,850
replicated parking of that data

00:21:57,549 --> 00:22:02,830
somewhere right the skies are gathered

00:22:00,850 --> 00:22:04,510
this is more for processing if you heard

00:22:02,830 --> 00:22:06,909
of MapReduce or if you heard of like

00:22:04,510 --> 00:22:09,460
it's similar patterns where you try to

00:22:06,909 --> 00:22:11,380
distribute the processing the load into

00:22:09,460 --> 00:22:13,090
many leaves it's in a free model you

00:22:11,380 --> 00:22:15,250
distribute to the leaves and there after

00:22:13,090 --> 00:22:17,889
you finish processing at a point in time

00:22:15,250 --> 00:22:20,260
you're going to then reorganize that

00:22:17,889 --> 00:22:21,340
data in a way that makes sense so when

00:22:20,260 --> 00:22:24,039
you're dealing with processing data

00:22:21,340 --> 00:22:26,110
that's also coming so and then there's

00:22:24,039 --> 00:22:28,049
mice my batch batch is another one of

00:22:26,110 --> 00:22:30,309
course that's very popular it just

00:22:28,049 --> 00:22:31,840
normally scheduled jobs you there's a

00:22:30,309 --> 00:22:33,789
list of tasks and operations that you

00:22:31,840 --> 00:22:37,419
want to run and you use batch model for

00:22:33,789 --> 00:22:38,799
that now my favorite and the session

00:22:37,419 --> 00:22:42,820
right before this one was a little bit

00:22:38,799 --> 00:22:45,850
about this it's it's event based right

00:22:42,820 --> 00:22:50,110
so for me in the mapping of the largest

00:22:45,850 --> 00:22:52,059
a great advantage about serverless is

00:22:50,110 --> 00:22:54,250
that it's vent based right it's not

00:22:52,059 --> 00:22:56,529
request response visited event you're

00:22:54,250 --> 00:22:59,230
going to process you're going to consume

00:22:56,529 --> 00:23:01,059
capacity hopefully when you get an event

00:22:59,230 --> 00:23:03,909
that tells you that you should do that

00:23:01,059 --> 00:23:07,299
right often messaging based systems they

00:23:03,909 --> 00:23:10,570
are there they're event based so as I

00:23:07,299 --> 00:23:13,269
said to today very common types of

00:23:10,570 --> 00:23:15,159
distributed computing that are Evette

00:23:13,269 --> 00:23:17,169
days the server less and function of the

00:23:15,159 --> 00:23:19,630
service have you ever seen a server less

00:23:17,169 --> 00:23:21,250
data center

00:23:19,630 --> 00:23:23,650
this is what several essentially say

00:23:21,250 --> 00:23:29,470
it's amazing right how did they do that

00:23:23,650 --> 00:23:31,559
we don't know oh sorry I know I lied

00:23:29,470 --> 00:23:35,910
there was all right good so

00:23:31,559 --> 00:23:38,620
congratulations you are now certified

00:23:35,910 --> 00:23:43,809
distributed system developers right I

00:23:38,620 --> 00:23:46,690
even have my certificates that I printed

00:23:43,809 --> 00:23:48,210
for me so after finishing this part part

00:23:46,690 --> 00:23:50,770
of the presentation I am now a

00:23:48,210 --> 00:23:52,179
officially certified distributed systems

00:23:50,770 --> 00:23:53,890
developer by the distributed system

00:23:52,179 --> 00:23:56,559
Institute's of course I just made this

00:23:53,890 --> 00:23:59,409
up but the point is that like now that

00:23:56,559 --> 00:24:01,840
you know like the some of the hard

00:23:59,409 --> 00:24:03,730
problems that are involved in developing

00:24:01,840 --> 00:24:05,830
distributed systems you should factor

00:24:03,730 --> 00:24:09,700
that in your development in your day to

00:24:05,830 --> 00:24:12,070
day activities okay now finally like I

00:24:09,700 --> 00:24:13,900
only have like I don't know 10 minions a

00:24:12,070 --> 00:24:15,460
little over 10 minutes and I'm finally

00:24:13,900 --> 00:24:16,510
going to talk about like something that

00:24:15,460 --> 00:24:18,730
was in the title of this presentation

00:24:16,510 --> 00:24:21,039
but for me was very important to give

00:24:18,730 --> 00:24:23,140
you the idea that yes micro services

00:24:21,039 --> 00:24:24,940
development is distributed systems there

00:24:23,140 --> 00:24:26,650
are tools and patterns so when I talked

00:24:24,940 --> 00:24:28,630
about tools and patterns that make your

00:24:26,650 --> 00:24:30,970
life easier when developing micro

00:24:28,630 --> 00:24:33,370
service applications this is one of them

00:24:30,970 --> 00:24:34,870
this is a very good one right so the

00:24:33,370 --> 00:24:36,700
first thing that I'm going to address

00:24:34,870 --> 00:24:40,720
using East um when I took the picture of

00:24:36,700 --> 00:24:43,659
the slide apologies for the lack of

00:24:40,720 --> 00:24:45,700
focus there is that the network is

00:24:43,659 --> 00:24:48,100
secure so assuming so this is a live so

00:24:45,700 --> 00:24:50,710
the network is not secure so how what do

00:24:48,100 --> 00:24:52,330
we do then to make sure that we can

00:24:50,710 --> 00:24:53,740
handle the problem of networking

00:24:52,330 --> 00:24:55,720
security so one of the things that II

00:24:53,740 --> 00:24:57,940
still has out of the box its ability to

00:24:55,720 --> 00:25:00,070
support mutual TLS mutual transport

00:24:57,940 --> 00:25:03,580
layer security that means that if you're

00:25:00,070 --> 00:25:05,559
talking from endpoint 88.8 when point B

00:25:03,580 --> 00:25:08,169
they know each other

00:25:05,559 --> 00:25:09,549
they are trusted and you have formally

00:25:08,169 --> 00:25:11,740
established that they can communicate

00:25:09,549 --> 00:25:15,700
with each other and you know why this is

00:25:11,740 --> 00:25:18,220
important because if we assume that

00:25:15,700 --> 00:25:20,289
network is secure it's not it might be

00:25:18,220 --> 00:25:23,770
the case where an application like this

00:25:20,289 --> 00:25:25,870
streets app that acts as another one and

00:25:23,770 --> 00:25:28,419
you know as an architect that that show

00:25:25,870 --> 00:25:30,369
floor not flow should not have half

00:25:28,419 --> 00:25:31,899
right so again there are technologies

00:25:30,369 --> 00:25:32,409
these two with meter Chile's can help

00:25:31,899 --> 00:25:34,809
you with that

00:25:32,409 --> 00:25:36,879
so that it allows you to formalize the

00:25:34,809 --> 00:25:38,289
information flow so if you as the data

00:25:36,879 --> 00:25:41,259
architect for the application or the

00:25:38,289 --> 00:25:44,080
Arkin you know what systems should be

00:25:41,259 --> 00:25:46,359
used for Asus specific music for

00:25:44,080 --> 00:25:48,970
business functions then that should be

00:25:46,359 --> 00:25:52,330
formalized right this application can

00:25:48,970 --> 00:25:54,340
only talk to this one not in no one else

00:25:52,330 --> 00:25:56,679
and under what circumstances so I have

00:25:54,340 --> 00:25:59,109
that in mind the sto with mute HLS

00:25:56,679 --> 00:26:01,600
allows you to specify a secure

00:25:59,109 --> 00:26:03,759
communication channel formalized right

00:26:01,600 --> 00:26:06,429
so it's not only like okay I'm gonna add

00:26:03,759 --> 00:26:08,830
transport layer security and everybody

00:26:06,429 --> 00:26:10,239
has transported security but everybody

00:26:08,830 --> 00:26:13,059
has can talk to me now you are actually

00:26:10,239 --> 00:26:17,499
specifying who are you expecting to be

00:26:13,059 --> 00:26:19,359
interfacing with so that calls so you

00:26:17,499 --> 00:26:21,429
reduce the risk again like security is a

00:26:19,359 --> 00:26:24,220
practice right so you always have to do

00:26:21,429 --> 00:26:26,230
this sorts of exercises right the other

00:26:24,220 --> 00:26:28,299
it's on topology doesn't change that we

00:26:26,230 --> 00:26:30,159
all believe now that the policy does

00:26:28,299 --> 00:26:31,659
change is that is that okay so you

00:26:30,159 --> 00:26:33,970
understand that from just from your

00:26:31,659 --> 00:26:35,679
basic development environment from from

00:26:33,970 --> 00:26:37,299
the particular environment that your

00:26:35,679 --> 00:26:39,220
application topology is going to change

00:26:37,299 --> 00:26:40,929
right and in order to help with that you

00:26:39,220 --> 00:26:43,029
need to have in mind dynamic

00:26:40,929 --> 00:26:44,470
configuration management right which is

00:26:43,029 --> 00:26:46,809
hard but if you have dynamic

00:26:44,470 --> 00:26:48,639
configuration management in mind and you

00:26:46,809 --> 00:26:51,940
do that as part of your activity you're

00:26:48,639 --> 00:26:54,509
gonna be let's say unless trouble so one

00:26:51,940 --> 00:26:56,019
of the things that easier does with the

00:26:54,509 --> 00:26:58,830
addressing dynamic configuration

00:26:56,019 --> 00:27:00,970
management is that there is a piece of

00:26:58,830 --> 00:27:02,859
there's a component in Easter called

00:27:00,970 --> 00:27:05,590
Pilate that knows where the end points

00:27:02,859 --> 00:27:08,409
are and when as UN points common goal

00:27:05,590 --> 00:27:11,289
they get notified of their existence so

00:27:08,409 --> 00:27:13,239
if endpoint foo version 3 comes up it

00:27:11,289 --> 00:27:15,940
will notify Pilate that there is an

00:27:13,239 --> 00:27:17,919
import who version 3 up is available and

00:27:15,940 --> 00:27:21,909
anyone that wants to interface with that

00:27:17,919 --> 00:27:23,759
endpoint para who know exactly where

00:27:21,909 --> 00:27:25,809
that endpoint is and all the the

00:27:23,759 --> 00:27:28,720
versions that are available for that

00:27:25,809 --> 00:27:30,429
endpoint and even more like how many

00:27:28,720 --> 00:27:32,169
times we can call that point and under

00:27:30,429 --> 00:27:34,419
what circumstances so again to address

00:27:32,169 --> 00:27:36,639
the fact that the policy just change a

00:27:34,419 --> 00:27:37,270
dynamic configuration is you can help

00:27:36,639 --> 00:27:38,880
you with that

00:27:37,270 --> 00:27:40,990
that was reason number two for ease to

00:27:38,880 --> 00:27:44,710
dynamic configuration management of

00:27:40,990 --> 00:27:46,420
endpoints very good so this is the

00:27:44,710 --> 00:27:49,000
example though okay let's say my

00:27:46,420 --> 00:27:50,680
application running in node a under a

00:27:49,000 --> 00:27:52,450
certain IP under the standard network

00:27:50,680 --> 00:27:56,530
changes it's now running a different

00:27:52,450 --> 00:27:58,240
network under a different IP still pilot

00:27:56,530 --> 00:28:00,550
is going to be notified of this change

00:27:58,240 --> 00:28:01,870
and you can have access to that

00:28:00,550 --> 00:28:05,770
information if you want to call that

00:28:01,870 --> 00:28:08,110
application right again topology will

00:28:05,770 --> 00:28:11,410
change because because it does change

00:28:08,110 --> 00:28:13,300
now I think the network is reliable on

00:28:11,410 --> 00:28:15,580
is also very interesting right because

00:28:13,300 --> 00:28:17,860
sometimes we would think would think

00:28:15,580 --> 00:28:20,620
about compromising or application

00:28:17,860 --> 00:28:23,170
because we didn't necessarily provide

00:28:20,620 --> 00:28:27,190
the real users of our application with

00:28:23,170 --> 00:28:28,680
the necessary priorities that they need

00:28:27,190 --> 00:28:33,220
right so in case I have an application

00:28:28,680 --> 00:28:35,740
from A to B right and again do I want

00:28:33,220 --> 00:28:37,780
you as owner of application a do I want

00:28:35,740 --> 00:28:39,880
to disrupt my own experience because B

00:28:37,780 --> 00:28:42,910
is not running and what sometimes happen

00:28:39,880 --> 00:28:44,680
is is that we knowing that some things

00:28:42,910 --> 00:28:46,750
are failing we still wait for fail if

00:28:44,680 --> 00:28:48,550
like I'm going to talk to application B

00:28:46,750 --> 00:28:50,200
I know it's dumb I'm still gonna wait

00:28:48,550 --> 00:28:52,360
for a timeout I'm going to talk to

00:28:50,200 --> 00:28:54,280
application B I know it's down I'm still

00:28:52,360 --> 00:28:55,900
gonna write for a timeout so the user

00:28:54,280 --> 00:28:58,270
experience the end user experience gets

00:28:55,900 --> 00:28:59,440
disrupted even when you know that the

00:28:58,270 --> 00:29:01,720
other application that you're

00:28:59,440 --> 00:29:04,450
interfacing with it's not responding so

00:29:01,720 --> 00:29:06,640
why wait for a failure if you could know

00:29:04,450 --> 00:29:08,380
right now that's not working and keep

00:29:06,640 --> 00:29:10,240
the call local right so one of the

00:29:08,380 --> 00:29:12,010
things that Easter does is that through

00:29:10,240 --> 00:29:13,300
the circuit breaking it opens the

00:29:12,010 --> 00:29:16,600
circuit it knows that that application

00:29:13,300 --> 00:29:18,940
is not responsive and every many calls

00:29:16,600 --> 00:29:20,530
or every many minutes you can then call

00:29:18,940 --> 00:29:22,930
that application again to see if has

00:29:20,530 --> 00:29:25,690
come back up right so the fact that

00:29:22,930 --> 00:29:27,310
you're not waiting for failure increases

00:29:25,690 --> 00:29:28,960
the overall response time of your

00:29:27,310 --> 00:29:32,140
application right because they're not

00:29:28,960 --> 00:29:34,270
waiting waiting for things to go down to

00:29:32,140 --> 00:29:38,350
fail and then do something you know that

00:29:34,270 --> 00:29:39,340
they are done right so and then the fact

00:29:38,350 --> 00:29:42,040
that there's a centralized repository

00:29:39,340 --> 00:29:45,070
that knows the applications that are up

00:29:42,040 --> 00:29:46,840
are not any new application that wants

00:29:45,070 --> 00:29:49,180
to access the same application we also

00:29:46,840 --> 00:29:51,550
know that the application is failing

00:29:49,180 --> 00:29:53,320
then keep the the call locally right

00:29:51,550 --> 00:29:56,920
again increasing reliability not having

00:29:53,320 --> 00:29:59,620
to wait for fail and to address the

00:29:56,920 --> 00:30:00,910
bandwidth is infinite is its its rating

00:29:59,620 --> 00:30:02,920
limiting the rating unlimited it's

00:30:00,910 --> 00:30:05,260
mostly an often associated to API

00:30:02,920 --> 00:30:07,860
management but I think API managed to

00:30:05,260 --> 00:30:10,630
exchange in a bit it was only seen as a

00:30:07,860 --> 00:30:13,270
technology for external API but more and

00:30:10,630 --> 00:30:15,040
more we see internal API if you're

00:30:13,270 --> 00:30:16,870
dealing with micro services move to

00:30:15,040 --> 00:30:18,760
applications distributed systems you

00:30:16,870 --> 00:30:20,650
actually have multiple API is internal

00:30:18,760 --> 00:30:22,510
to your applications in the same way

00:30:20,650 --> 00:30:24,580
that you would only let's say if you

00:30:22,510 --> 00:30:26,680
have ever used a Google Maps API

00:30:24,580 --> 00:30:28,870
if you want to make more than five calls

00:30:26,680 --> 00:30:32,860
I think for a second you have to pay you

00:30:28,870 --> 00:30:34,600
should also have that level of the level

00:30:32,860 --> 00:30:35,980
of control inside organization right

00:30:34,600 --> 00:30:37,990
they are more important in your

00:30:35,980 --> 00:30:40,180
application or important applications

00:30:37,990 --> 00:30:42,010
inside your organization and you should

00:30:40,180 --> 00:30:43,270
prioritize those right in this sense

00:30:42,010 --> 00:30:45,610
that let's say if you have a mission

00:30:43,270 --> 00:30:47,110
critical application and others you

00:30:45,610 --> 00:30:49,090
should probably give the mission

00:30:47,110 --> 00:30:51,550
critical application the ability to have

00:30:49,090 --> 00:30:54,010
receive more requests than just all just

00:30:51,550 --> 00:30:55,260
a regular application imagine that

00:30:54,010 --> 00:30:57,070
you might have other applications

00:30:55,260 --> 00:30:59,380
impacting mission-critical applications

00:30:57,070 --> 00:31:01,570
so one of the things that Easter can do

00:30:59,380 --> 00:31:04,690
as well is the ability to add rating and

00:31:01,570 --> 00:31:06,480
limiting to your application so that you

00:31:04,690 --> 00:31:08,920
don't necessarily fall into the fact or

00:31:06,480 --> 00:31:10,870
fall into assuming that your bandwidth

00:31:08,920 --> 00:31:13,090
is going to be infinite right you can

00:31:10,870 --> 00:31:15,160
give each individual user and you can do

00:31:13,090 --> 00:31:17,350
that in a job page like JSON web token

00:31:15,160 --> 00:31:22,390
base individual users you can give them

00:31:17,350 --> 00:31:24,370
different levels of let's say permission

00:31:22,390 --> 00:31:26,530
to your application in terms of number

00:31:24,370 --> 00:31:30,220
of requests and requests per second

00:31:26,530 --> 00:31:31,930
right so given that I have two minutes

00:31:30,220 --> 00:31:35,920
let's go to the summary right so

00:31:31,930 --> 00:31:37,930
addressing the for distributed system

00:31:35,920 --> 00:31:40,870
policies that I talked about network is

00:31:37,930 --> 00:31:42,790
not reliable and for that recommendation

00:31:40,870 --> 00:31:44,380
is that you can use circuit breakers

00:31:42,790 --> 00:31:46,000
the network is not secure

00:31:44,380 --> 00:31:49,090
recommendations that you can use mutual

00:31:46,000 --> 00:31:51,370
TLS topology changes the recommendation

00:31:49,090 --> 00:31:52,810
that the recommendation is that you use

00:31:51,370 --> 00:31:56,040
dynamic configuration management the

00:31:52,810 --> 00:31:58,410
discovery is you can do that and the

00:31:56,040 --> 00:32:00,950
bandwidth is finit so the recommendation

00:31:58,410 --> 00:32:03,030
is that you use rating limiting for that

00:32:00,950 --> 00:32:06,630
so that's it

00:32:03,030 --> 00:32:08,460
tutor handle is rhetoric and that's what

00:32:06,630 --> 00:32:14,400
I wanted to talk to you today thank you

00:32:08,460 --> 00:32:16,380
very much now we do have a couple

00:32:14,400 --> 00:32:17,790
minutes for questions so if you have a

00:32:16,380 --> 00:32:22,440
question I can repeat the question then

00:32:17,790 --> 00:32:23,940
yeah four minutes all right I'll be in

00:32:22,440 --> 00:32:25,830
the back if you want to talk to me

00:32:23,940 --> 00:32:27,270
individually and this is a topic I'm

00:32:25,830 --> 00:32:28,800
very passionate about so feel free to

00:32:27,270 --> 00:32:31,400
reach out thank you very much

00:32:28,800 --> 00:32:31,400

YouTube URL: https://www.youtube.com/watch?v=y_g7R5uY5b8


