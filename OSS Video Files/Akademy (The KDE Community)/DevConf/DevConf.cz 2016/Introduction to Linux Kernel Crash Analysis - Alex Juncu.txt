Title: Introduction to Linux Kernel Crash Analysis - Alex Juncu
Publication date: 2016-02-11
Playlist: DevConf.cz 2016
Description: 
	As a Technical Support Engineer on the Kernel team, one of the top tools I need is kdump and crash, both used to determine the cause of a kernel crash.
In this presentation, I want to give an introduction on how kdump works and how it generates vmcores and how people can use crash to debug vmcores generated by kernel crashes.
I will demo some basic scenarios where kdump is useful and, if time permits, some more advanced debugging techniques.

Presentation: http://bit.ly/241hYDn
Captions: 
	00:02:45,660 --> 00:02:48,840
anyone you are

00:02:51,680 --> 00:02:56,060
this presentation will be introduction

00:02:57,650 --> 00:03:02,090
welcome Alex

00:03:05,990 --> 00:03:11,370
hello and welcome thank you for

00:03:08,730 --> 00:03:14,730
attending this presentation my name is

00:03:11,370 --> 00:03:17,220
Alex I work for record as a technical

00:03:14,730 --> 00:03:19,890
support engineer meaning that I help our

00:03:17,220 --> 00:03:22,320
clients administer their Red Hat

00:03:19,890 --> 00:03:24,350
Enterprise Linux systems and more

00:03:22,320 --> 00:03:28,040
specifically I work in the kernel team

00:03:24,350 --> 00:03:31,410
which means that we do a lot of work on

00:03:28,040 --> 00:03:33,360
helping our customers and I look at

00:03:31,410 --> 00:03:35,670
virtual analysis when their criminal

00:03:33,360 --> 00:03:37,920
crashes when the system crashes because

00:03:35,670 --> 00:03:40,890
there was a problem on the kernel side

00:03:37,920 --> 00:03:42,209
and as you as you might notice from the

00:03:40,890 --> 00:03:44,850
title this is going to be an

00:03:42,209 --> 00:03:48,600
introduction to some of the other

00:03:44,850 --> 00:03:51,930
techniques that we use on the team to do

00:03:48,600 --> 00:03:54,410
an analysis on kernels that they

00:03:51,930 --> 00:03:57,420
encountered programs on life systems

00:03:54,410 --> 00:04:00,209
what I want to go through today is tell

00:03:57,420 --> 00:04:03,720
you what exactly happens when a kernel

00:04:00,209 --> 00:04:06,030
crashes what do you should prepare to do

00:04:03,720 --> 00:04:08,780
and I want to talk to you about a couple

00:04:06,030 --> 00:04:12,230
of tools that might help you do this

00:04:08,780 --> 00:04:14,100
analysis after you encounter the problem

00:04:12,230 --> 00:04:16,410
let's start with something easy

00:04:14,100 --> 00:04:18,359
something which I hope you are more

00:04:16,410 --> 00:04:20,370
familiar with let's assume that we just

00:04:18,359 --> 00:04:22,860
have a normal application a normal user

00:04:20,370 --> 00:04:26,010
space program that's crashed it

00:04:22,860 --> 00:04:28,290
encountered a problem and it crashed you

00:04:26,010 --> 00:04:30,690
need to figure out what happened to that

00:04:28,290 --> 00:04:33,690
application well there are a couple of

00:04:30,690 --> 00:04:35,580
ways you can do this you can start out

00:04:33,690 --> 00:04:37,410
by for example reading the code if

00:04:35,580 --> 00:04:39,479
you're the developer for example or you

00:04:37,410 --> 00:04:42,120
just have access to the code you can

00:04:39,479 --> 00:04:43,919
start and based on what was the

00:04:42,120 --> 00:04:45,600
environment of the application when it

00:04:43,919 --> 00:04:48,600
crashed and your knowledge of the code

00:04:45,600 --> 00:04:50,190
itself you may want to go through the

00:04:48,600 --> 00:04:54,210
code and see if there was a possible

00:04:50,190 --> 00:04:58,110
problem in the code fix that

00:04:54,210 --> 00:04:59,970
that bug recompile it make it work make

00:04:58,110 --> 00:05:02,460
methyl not all the time you have this

00:04:59,970 --> 00:05:05,400
option you might have a big application

00:05:02,460 --> 00:05:08,639
you might not want to spend years and

00:05:05,400 --> 00:05:12,060
years debugging a software problem you

00:05:08,639 --> 00:05:13,740
might want to modify the code to do some

00:05:12,060 --> 00:05:15,870
to provide it with some more information

00:05:13,740 --> 00:05:18,380
about the application while it's running

00:05:15,870 --> 00:05:21,060
you can do some feedback messages and

00:05:18,380 --> 00:05:23,190
even though most developers won't like

00:05:21,060 --> 00:05:25,289
to admit it the best way to do is just

00:05:23,190 --> 00:05:27,810
to put in some print text in the code

00:05:25,289 --> 00:05:30,120
and see what are the conditions of the

00:05:27,810 --> 00:05:32,460
code while it's running this affects the

00:05:30,120 --> 00:05:35,639
code you have to recompile it if

00:05:32,460 --> 00:05:37,289
sometimes the can modify the application

00:05:35,639 --> 00:05:40,320
so much that it doesn't give you the

00:05:37,289 --> 00:05:42,840
right perspective so you might want to

00:05:40,320 --> 00:05:45,509
do something else usually another good

00:05:42,840 --> 00:05:48,570
approach is to use gdb how many of you

00:05:45,509 --> 00:05:51,720
are familiar with what gdb does yes

00:05:48,570 --> 00:05:53,909
thank you did it is awesome you should

00:05:51,720 --> 00:05:57,500
use it developers use it all the time

00:05:53,909 --> 00:06:01,190
why is it awesome because it can debug

00:05:57,500 --> 00:06:04,320
processes either by starting them

00:06:01,190 --> 00:06:07,110
alongside an application so you have gdb

00:06:04,320 --> 00:06:08,759
that starts an application and when the

00:06:07,110 --> 00:06:12,719
process of that application is running

00:06:08,759 --> 00:06:16,080
you can introduce breakpoints see what's

00:06:12,719 --> 00:06:20,610
the environment at some some lifecycle

00:06:16,080 --> 00:06:21,900
of the process you can alter the virtual

00:06:20,610 --> 00:06:27,719
memory of the process you can do several

00:06:21,900 --> 00:06:29,940
things with gdb so oh one approach is to

00:06:27,719 --> 00:06:33,449
have that application running you can

00:06:29,940 --> 00:06:36,690
attach the gdb to a running process or

00:06:33,449 --> 00:06:39,840
you can start the process with gdb my

00:06:36,690 --> 00:06:44,099
application and have the gdb attached

00:06:39,840 --> 00:06:46,080
from the start to that process but

00:06:44,099 --> 00:06:49,080
sometimes you want to find out what

00:06:46,080 --> 00:06:51,210
happened to at the application after it

00:06:49,080 --> 00:06:55,020
crashed so you want to do a post-mortem

00:06:51,210 --> 00:06:57,570
analysis in some situations the crash of

00:06:55,020 --> 00:06:59,909
that application for example usually in

00:06:57,570 --> 00:07:04,420
the case of a seg fault you would get

00:06:59,909 --> 00:07:07,240
something like a core dump a file for

00:07:04,420 --> 00:07:10,240
called Corden which is the dump of the

00:07:07,240 --> 00:07:12,280
virtual memory of that process what does

00:07:10,240 --> 00:07:14,380
that mean if I have access to the

00:07:12,280 --> 00:07:16,540
virtual memory of the process it means I

00:07:14,380 --> 00:07:19,060
have information about the environment

00:07:16,540 --> 00:07:19,570
of that application at the time of the

00:07:19,060 --> 00:07:22,230
crash

00:07:19,570 --> 00:07:25,030
based on that I can gather information

00:07:22,230 --> 00:07:28,450
about what was going on in the process

00:07:25,030 --> 00:07:31,960
when or at the moment when it crashed I

00:07:28,450 --> 00:07:36,220
can also use GD on this I can start GDD

00:07:31,960 --> 00:07:40,150
on on an application and also provided a

00:07:36,220 --> 00:07:43,210
program which will allow me to for that

00:07:40,150 --> 00:07:45,520
application to run in the same way it

00:07:43,210 --> 00:07:48,730
ran when it encountered the proper the

00:07:45,520 --> 00:07:51,550
problem and got the crash this way I

00:07:48,730 --> 00:07:53,970
have a gdb instance of a process which

00:07:51,550 --> 00:07:57,970
was basically a clone of that initial

00:07:53,970 --> 00:08:01,180
tranche process which I can detect life

00:07:57,970 --> 00:08:04,510
and run gdb operations on that

00:08:01,180 --> 00:08:06,790
application so these are some of the

00:08:04,510 --> 00:08:09,910
approaches for debugging application if

00:08:06,790 --> 00:08:11,680
we move into the kernel world some

00:08:09,910 --> 00:08:14,170
people say that things are completely

00:08:11,680 --> 00:08:16,030
different we have no idea what is going

00:08:14,170 --> 00:08:18,910
on in the kernel how to debug it how to

00:08:16,030 --> 00:08:22,630
do anything kernel space is unicorn land

00:08:18,910 --> 00:08:25,690
everything is different not so much most

00:08:22,630 --> 00:08:27,730
of the principles still apply you still

00:08:25,690 --> 00:08:28,720
have most of the same debugging

00:08:27,730 --> 00:08:31,240
mechanisms

00:08:28,720 --> 00:08:33,960
maybe not print that we have print page

00:08:31,240 --> 00:08:37,570
which do these comes with some other

00:08:33,960 --> 00:08:40,540
problems because the way that the kernel

00:08:37,570 --> 00:08:43,420
works for example not having a terminal

00:08:40,540 --> 00:08:45,880
attached we won't see messages on the

00:08:43,420 --> 00:08:48,970
console you would probably see print

00:08:45,880 --> 00:08:53,200
cake generated messages on a serial port

00:08:48,970 --> 00:08:57,060
for example or by default in the DMS the

00:08:53,200 --> 00:09:01,090
kernel log buffer we can look at those

00:08:57,060 --> 00:09:03,160
messages for more information we can do

00:09:01,090 --> 00:09:06,510
um gdb

00:09:03,160 --> 00:09:09,070
we can attach gdb to the live kernel

00:09:06,510 --> 00:09:11,110
slightly more complicated but we can do

00:09:09,070 --> 00:09:14,740
that we can also get some information on

00:09:11,110 --> 00:09:16,250
a live kernel I just want to mention

00:09:14,740 --> 00:09:18,350
system tab which is

00:09:16,250 --> 00:09:20,720
also very interesting a way of debugging

00:09:18,350 --> 00:09:24,590
things in the kernel it deserves its own

00:09:20,720 --> 00:09:27,230
its own presentation but as you can see

00:09:24,590 --> 00:09:30,050
it mostly we mostly have the same way of

00:09:27,230 --> 00:09:32,750
thinking about debugging the kernel as

00:09:30,050 --> 00:09:35,750
we would do most of the application in

00:09:32,750 --> 00:09:38,330
user space however there are some

00:09:35,750 --> 00:09:40,220
restrictions and I want to mention what

00:09:38,330 --> 00:09:44,360
are those restrictions and how we can

00:09:40,220 --> 00:09:47,720
work around there being same let's talk

00:09:44,360 --> 00:09:49,280
about what a kernel crash so a lot of

00:09:47,720 --> 00:09:52,040
people said ok something happen in the

00:09:49,280 --> 00:09:53,660
kernel of the kernel crash let's be more

00:09:52,040 --> 00:09:57,620
specific about what that means

00:09:53,660 --> 00:09:59,660
first of all we should realize what is

00:09:57,620 --> 00:10:02,990
the severity of a problem in the kernel

00:09:59,660 --> 00:10:06,110
for example we can just have wargames in

00:10:02,990 --> 00:10:09,020
the kernel buffer in that VMs which

00:10:06,110 --> 00:10:12,650
tells us that something was happening in

00:10:09,020 --> 00:10:14,950
kernel space either VSL kernel or

00:10:12,650 --> 00:10:18,490
criminal module outputted some

00:10:14,950 --> 00:10:22,070
information in the kernel DMS buffer and

00:10:18,490 --> 00:10:23,660
those messages could mean something they

00:10:22,070 --> 00:10:26,290
can arrange for just informational

00:10:23,660 --> 00:10:29,870
warnings to actual errors in the device

00:10:26,290 --> 00:10:32,720
these won't cause problems in the kernel

00:10:29,870 --> 00:10:35,210
themselves they may be problems on the

00:10:32,720 --> 00:10:36,920
system when the kernel module will tell

00:10:35,210 --> 00:10:40,339
you that there is a problem for example

00:10:36,920 --> 00:10:42,560
with a disc you have IO errors under

00:10:40,339 --> 00:10:43,820
this that's a problem but that's a

00:10:42,560 --> 00:10:45,860
problem for the disk or the hardware

00:10:43,820 --> 00:10:48,710
it's not a problem for the actual kernel

00:10:45,860 --> 00:10:51,589
so from that perspective everything that

00:10:48,710 --> 00:10:56,050
we get in the mass buffer with these

00:10:51,589 --> 00:10:58,460
twin K generated messages are

00:10:56,050 --> 00:11:01,250
informational from the crown's point of

00:10:58,460 --> 00:11:04,190
view then we have curl

00:11:01,250 --> 00:11:07,780
oops the curl oops are something

00:11:04,190 --> 00:11:12,020
specific to kernel space there are a

00:11:07,780 --> 00:11:14,630
type of problems within the kernel that

00:11:12,020 --> 00:11:17,890
we usually don't want to see but one

00:11:14,630 --> 00:11:20,720
thing though these are some an

00:11:17,890 --> 00:11:23,110
anticipated problem some specific set of

00:11:20,720 --> 00:11:27,020
problems that the kernel might encounter

00:11:23,110 --> 00:11:27,600
which might cause future problems if the

00:11:27,020 --> 00:11:30,149
kernel can

00:11:27,600 --> 00:11:34,290
year on so the colonel will warn you

00:11:30,149 --> 00:11:37,440
about these issues and as Adam books but

00:11:34,290 --> 00:11:39,300
that might mean that the colonel will

00:11:37,440 --> 00:11:41,880
continue running so it will continue

00:11:39,300 --> 00:11:45,060
running with the disclaimer from the

00:11:41,880 --> 00:11:47,880
colonel that I am now unstable use me at

00:11:45,060 --> 00:11:49,649
your own risk and you might want to not

00:11:47,880 --> 00:11:51,360
continue doing that you might want to

00:11:49,649 --> 00:11:54,389
reboot the Machine you might want to

00:11:51,360 --> 00:11:56,579
troubleshoot what caused that death

00:11:54,389 --> 00:11:59,220
colonel who's usually a software issue

00:11:56,579 --> 00:12:03,319
in either the colonel or most likely a

00:11:59,220 --> 00:12:06,120
colonel device driver sometimes it might

00:12:03,319 --> 00:12:10,740
have a side effect in the future which

00:12:06,120 --> 00:12:12,920
will lead to a kernel panic or in

00:12:10,740 --> 00:12:15,899
general the system will just be unstable

00:12:12,920 --> 00:12:17,550
they have the colonel bucks ground

00:12:15,899 --> 00:12:19,980
butters are something that the software

00:12:17,550 --> 00:12:23,220
developer anticipated there are

00:12:19,980 --> 00:12:26,220
situations that the kernel developer

00:12:23,220 --> 00:12:29,069
thought that could happen but you never

00:12:26,220 --> 00:12:32,100
happen so if the colonel reaches that

00:12:29,069 --> 00:12:34,949
point where the code is in a function of

00:12:32,100 --> 00:12:37,709
a piece of a function where it shouldn't

00:12:34,949 --> 00:12:39,839
ever reach that would be a problem it's

00:12:37,709 --> 00:12:40,500
anticipated so the kernel developer said

00:12:39,839 --> 00:12:42,870
that okay

00:12:40,500 --> 00:12:48,329
I'm going to track this but you should

00:12:42,870 --> 00:12:50,220
never be there sometimes that bug is it

00:12:48,329 --> 00:12:52,290
just informational so you can say okay

00:12:50,220 --> 00:12:56,579
that happened do something about it you

00:12:52,290 --> 00:12:59,699
might have a side effects later but if

00:12:56,579 --> 00:13:04,500
it can also cause a kernel crash so

00:12:59,699 --> 00:13:06,720
actually crash the system and I kept

00:13:04,500 --> 00:13:10,529
saying kernel crashes and kernel panics

00:13:06,720 --> 00:13:13,319
the actual kernel panic is when the

00:13:10,529 --> 00:13:17,720
system is completely down is inoperable

00:13:13,319 --> 00:13:22,350
it's the point when the kernel reach

00:13:17,720 --> 00:13:24,720
phase where it's no longer work it can't

00:13:22,350 --> 00:13:27,060
do anything honest processes are not

00:13:24,720 --> 00:13:29,040
being scheduled you can't type in

00:13:27,060 --> 00:13:31,800
anything on the keyboard nothing new

00:13:29,040 --> 00:13:33,750
will pop into the monitor nothing is

00:13:31,800 --> 00:13:35,639
going to happen the criminal is in a

00:13:33,750 --> 00:13:38,660
state where it's still running

00:13:35,639 --> 00:13:43,069
technically so it's the only thing under

00:13:38,660 --> 00:13:45,079
Sheen actually existing in RAM in in

00:13:43,069 --> 00:13:46,100
anywhere but it's not actually doing it

00:13:45,079 --> 00:13:49,339
it's frozen

00:13:46,100 --> 00:13:52,220
that's a kernel panic it's the

00:13:49,339 --> 00:13:54,139
equivalent of what we would see in the

00:13:52,220 --> 00:13:56,629
windows world for example as that blue

00:13:54,139 --> 00:13:58,399
screen of death and this is what we want

00:13:56,629 --> 00:13:59,959
you to talk about in this presentation

00:13:58,399 --> 00:14:03,529
what will you do with these kernel

00:13:59,959 --> 00:14:06,199
crashes these kernel paths when with the

00:14:03,529 --> 00:14:08,329
kernel panics the like the Linux kernel

00:14:06,199 --> 00:14:10,579
specifically wants to help the

00:14:08,329 --> 00:14:13,730
administrator of the system out and it

00:14:10,579 --> 00:14:16,730
does that by providing some information

00:14:13,730 --> 00:14:19,670
about the kernel panic so before it

00:14:16,730 --> 00:14:22,670
draws its last breath the kernel will

00:14:19,670 --> 00:14:26,060
print out on the screen on the serial

00:14:22,670 --> 00:14:28,939
console it will print out a series of

00:14:26,060 --> 00:14:30,829
messages those will will be the last

00:14:28,939 --> 00:14:35,300
thing you will see on the screen before

00:14:30,829 --> 00:14:37,790
the kernel crashes the depending on how

00:14:35,300 --> 00:14:39,889
the system is configured the kernel will

00:14:37,790 --> 00:14:41,720
automatically reboot or not usually

00:14:39,889 --> 00:14:44,480
doesn't because you want the system

00:14:41,720 --> 00:14:47,899
administrator to see that last message

00:14:44,480 --> 00:14:50,779
on screen and these messages contains

00:14:47,899 --> 00:14:54,139
things like what was the process that

00:14:50,779 --> 00:14:57,589
caused the panic what was the state of

00:14:54,139 --> 00:15:00,250
the registers in on the CPU at the time

00:14:57,589 --> 00:15:04,519
of the panic the call trace of the

00:15:00,250 --> 00:15:07,759
kernel space functions which would be

00:15:04,519 --> 00:15:10,639
the history before the kernel panic and

00:15:07,759 --> 00:15:12,980
it looks something like this for example

00:15:10,639 --> 00:15:16,639
at the first line you would see

00:15:12,980 --> 00:15:18,920
something like unable to handle the

00:15:16,639 --> 00:15:23,600
kernel a new pointer dereference that's

00:15:18,920 --> 00:15:26,360
the cause of the panic but it would be

00:15:23,600 --> 00:15:28,459
the equivalent of a new pointed

00:15:26,360 --> 00:15:32,449
referenced in user space like a segfault

00:15:28,459 --> 00:15:34,939
but not really a that is something that

00:15:32,449 --> 00:15:39,620
the system cannot recover from it panics

00:15:34,939 --> 00:15:41,089
so you see the the reason why panic on

00:15:39,620 --> 00:15:43,639
top then you have some more

00:15:41,089 --> 00:15:45,980
informational messages for example what

00:15:43,639 --> 00:15:47,940
was the kernel version what modules were

00:15:45,980 --> 00:15:49,920
linked in you also get

00:15:47,940 --> 00:15:52,110
the list of registers what were the

00:15:49,920 --> 00:15:53,670
register hardware register on the system

00:15:52,110 --> 00:15:56,520
what were they state where work they're

00:15:53,670 --> 00:15:58,710
banned you also get a cold trace you get

00:15:56,520 --> 00:16:03,090
a the cold trace of functions that were

00:15:58,710 --> 00:16:07,290
cold before it reached that that state

00:16:03,090 --> 00:16:09,180
to pack now let me give you a bonus tip

00:16:07,290 --> 00:16:11,580
regarding presentations not regarding

00:16:09,180 --> 00:16:13,440
this you know pressure analysis if you

00:16:11,580 --> 00:16:16,800
ever have to do a presentation when you

00:16:13,440 --> 00:16:19,290
put in a piece of code or text that

00:16:16,800 --> 00:16:23,060
spans two slides you're doing it wrong

00:16:19,290 --> 00:16:27,540
don't do that but actually have a point

00:16:23,060 --> 00:16:30,420
here the the kernel tries to give you as

00:16:27,540 --> 00:16:33,240
much information as possible so it turns

00:16:30,420 --> 00:16:36,590
out to monitor screens for example the

00:16:33,240 --> 00:16:39,030
problem is that when the kernel panics

00:16:36,590 --> 00:16:42,120
everything stops working for example you

00:16:39,030 --> 00:16:44,460
cannot go with pay job and see what was

00:16:42,120 --> 00:16:46,290
the previous screen so even though the

00:16:44,460 --> 00:16:48,780
kernel tried to tell you a lot of things

00:16:46,290 --> 00:16:51,180
you can't see you only see this screen

00:16:48,780 --> 00:16:54,150
you would not see the second screen

00:16:51,180 --> 00:16:56,100
unless for example you have a serial

00:16:54,150 --> 00:16:58,020
console and everything outputted by the

00:16:56,100 --> 00:17:01,020
curve of the kernel went through a

00:16:58,020 --> 00:17:03,300
kernel went to a serial console and you

00:17:01,020 --> 00:17:06,240
have that thing long but most of the

00:17:03,300 --> 00:17:08,010
times you don't so you have information

00:17:06,240 --> 00:17:10,020
but you can't access it so we can't

00:17:08,010 --> 00:17:13,290
really do anything with it or Kenya

00:17:10,020 --> 00:17:16,380
let's see what we can do about another

00:17:13,290 --> 00:17:19,950
example with a wood beam if I have a

00:17:16,380 --> 00:17:23,340
panic caused by out of memory issues on

00:17:19,950 --> 00:17:26,160
top I see that there is the kernel panic

00:17:23,340 --> 00:17:27,690
due to out of memory so that means no

00:17:26,160 --> 00:17:30,690
more RAM no more swap nothing on the

00:17:27,690 --> 00:17:32,730
system that that can be allocated I have

00:17:30,690 --> 00:17:35,220
to panic no more memory I I need to

00:17:32,730 --> 00:17:37,800
panic but it doesn't really show me

00:17:35,220 --> 00:17:40,440
anything useful in this cold case it

00:17:37,800 --> 00:17:42,630
doesn't really show me what caused the

00:17:40,440 --> 00:17:45,450
the out of memory what was a worker

00:17:42,630 --> 00:17:48,390
processes that were eating up the

00:17:45,450 --> 00:17:50,520
resources on the system we need more

00:17:48,390 --> 00:17:53,520
information let's see how we can do that

00:17:50,520 --> 00:17:56,059
for example using the tool Kate called

00:17:53,520 --> 00:17:58,549
kada we can gather more information

00:17:56,059 --> 00:18:01,609
we can prepare the system before a

00:17:58,549 --> 00:18:03,440
possible crash prepare the system to be

00:18:01,609 --> 00:18:05,840
ready to provide us with more

00:18:03,440 --> 00:18:09,109
information at the moment of the pan

00:18:05,840 --> 00:18:12,379
what @k them do it has one role in mind

00:18:09,109 --> 00:18:15,919
to generate that VM core a team core

00:18:12,379 --> 00:18:20,210
just like a normal core down is a copy

00:18:15,919 --> 00:18:23,840
of the memory to a fire so Liam core is

00:18:20,210 --> 00:18:27,229
just a file that is a memory of the

00:18:23,840 --> 00:18:28,940
running entity in the in the case of a

00:18:27,229 --> 00:18:32,299
normal process it was the virtual memory

00:18:28,940 --> 00:18:36,019
of the process in the case of the of the

00:18:32,299 --> 00:18:37,789
kernel it's the contents of the RAM the

00:18:36,019 --> 00:18:40,460
swap so everything that the kernel will

00:18:37,789 --> 00:18:43,809
consider memory so that's what we want

00:18:40,460 --> 00:18:47,599
we want to generate them VM court oh

00:18:43,809 --> 00:18:50,149
this this tool called Kaiba will take

00:18:47,599 --> 00:18:53,509
care of that when the kernel panics that

00:18:50,149 --> 00:18:58,460
we go to that panic face keygen we'll

00:18:53,509 --> 00:19:00,830
start up and copy the contents inch of

00:18:58,460 --> 00:19:04,249
the RAM and swap into this vm core file

00:19:00,830 --> 00:19:07,159
and store it on some persistent disk so

00:19:04,249 --> 00:19:07,899
we can access it later but there's a

00:19:07,159 --> 00:19:11,029
problem

00:19:07,899 --> 00:19:13,909
key dump is something that needs to be

00:19:11,029 --> 00:19:16,879
running on the system but I mentioned

00:19:13,909 --> 00:19:19,899
earlier than when a kernel crash happens

00:19:16,879 --> 00:19:23,479
nothing works on the system so the

00:19:19,899 --> 00:19:24,469
kernel that doesn't do anything occurs

00:19:23,479 --> 00:19:27,080
in a coma

00:19:24,469 --> 00:19:29,210
choose cable something like key down to

00:19:27,080 --> 00:19:31,039
do the operations of extracting the

00:19:29,210 --> 00:19:34,009
contents of the memory and dumping it

00:19:31,039 --> 00:19:37,249
somewhere so we have problem we want to

00:19:34,009 --> 00:19:41,440
run something and nothing to run it this

00:19:37,249 --> 00:19:45,909
is where k exec comes in Kasich is

00:19:41,440 --> 00:19:49,330
awesome in a concept in the Linux kernel

00:19:45,909 --> 00:19:54,289
just like the name suggests k exec

00:19:49,330 --> 00:19:58,509
execute something in the colonel came

00:19:54,289 --> 00:20:01,549
SEC it's independent feature from Kadem

00:19:58,509 --> 00:20:03,679
and it can be used for several features

00:20:01,549 --> 00:20:05,869
for example if you heard of K exact

00:20:03,679 --> 00:20:09,220
probably you've heard of the feature of

00:20:05,869 --> 00:20:12,340
fast reboot this means that when you

00:20:09,220 --> 00:20:15,460
have a running colonel you do a Yammer

00:20:12,340 --> 00:20:17,350
up get update of the kernel kernel

00:20:15,460 --> 00:20:22,360
package and you want to boot into a new

00:20:17,350 --> 00:20:25,540
kernel k exec can execute the new kernel

00:20:22,360 --> 00:20:27,970
when you cannot image from from the disk

00:20:25,540 --> 00:20:29,830
without having to go through a full

00:20:27,970 --> 00:20:32,620
reboot without having to power up the

00:20:29,830 --> 00:20:34,570
machine go through pause go to BIOS QF

00:20:32,620 --> 00:20:37,360
I've read from the Master Boot Record

00:20:34,570 --> 00:20:40,960
etc it just has the old colonel

00:20:37,360 --> 00:20:43,930
executing a new kernel so that's what

00:20:40,960 --> 00:20:46,720
case it does it executes a new executive

00:20:43,930 --> 00:20:48,970
all a day in the kernel not to be

00:20:46,720 --> 00:20:51,460
confused with the K graft and keep

00:20:48,970 --> 00:20:54,340
spliced which is a mechanism of life

00:20:51,460 --> 00:20:58,750
passion meaning that you have one kernel

00:20:54,340 --> 00:21:01,830
running and subsequently you replace the

00:20:58,750 --> 00:21:05,200
running image with another images code

00:21:01,830 --> 00:21:07,300
another journalist code like this at

00:21:05,200 --> 00:21:11,110
work okay exact actually executes a new

00:21:07,300 --> 00:21:13,990
image how can I do that well I have to

00:21:11,110 --> 00:21:16,990
have the new image somewhere store I

00:21:13,990 --> 00:21:20,590
need to have the image which are about

00:21:16,990 --> 00:21:22,990
to execute stored somewhere and since I

00:21:20,590 --> 00:21:25,900
can't store it on this to use it later

00:21:22,990 --> 00:21:28,300
because operations on this need of

00:21:25,900 --> 00:21:31,750
processing from the kernel I need the

00:21:28,300 --> 00:21:33,820
code to be there just when I'm about to

00:21:31,750 --> 00:21:35,760
execute that means that it has to be in

00:21:33,820 --> 00:21:38,500
RAM it has to be in the physical memory

00:21:35,760 --> 00:21:42,730
when I want to execute it any time in

00:21:38,500 --> 00:21:46,270
the future so to run a exact on a new

00:21:42,730 --> 00:21:49,390
image I have to reserve a piece of the

00:21:46,270 --> 00:21:52,660
physical memory just to store an image

00:21:49,390 --> 00:21:56,050
which I'm going to later on execute with

00:21:52,660 --> 00:21:58,150
Kay exact so two runs are on this I'm

00:21:56,050 --> 00:22:01,030
going to pre allocate a good time at

00:21:58,150 --> 00:22:03,700
when the kernel load I will tell the

00:22:01,030 --> 00:22:06,250
colonel to always reserve a certain

00:22:03,700 --> 00:22:10,070
portion of the RAM to be used by nothing

00:22:06,250 --> 00:22:13,400
else and something in the future will

00:22:10,070 --> 00:22:15,590
emulate that from that piece of memory

00:22:13,400 --> 00:22:18,260
of physical memory with some a binary

00:22:15,590 --> 00:22:20,270
image which kids that will be able to

00:22:18,260 --> 00:22:24,350
execute when it needs to

00:22:20,270 --> 00:22:27,740
so using kxf kingdom proto your own

00:22:24,350 --> 00:22:32,240
provisions this piece of physical memory

00:22:27,740 --> 00:22:34,430
with a kdump kernel image which will be

00:22:32,240 --> 00:22:37,220
used to do the things we discussed to

00:22:34,430 --> 00:22:42,110
copy the contents of RAM and put them on

00:22:37,220 --> 00:22:44,390
a disk or a network location I need to

00:22:42,110 --> 00:22:46,430
do this I need to reserve that memory

00:22:44,390 --> 00:22:48,950
region bypassing the crash kernel

00:22:46,430 --> 00:22:50,900
parameter to the kernel at boot time

00:22:48,950 --> 00:22:52,760
this would mean that the bootloader

00:22:50,900 --> 00:22:55,490
needs to pass to the kernel this

00:22:52,760 --> 00:22:57,980
parameter and kingdom knows of that

00:22:55,490 --> 00:23:01,550
reserve region and will put in that

00:22:57,980 --> 00:23:04,250
region the needed binary small

00:23:01,550 --> 00:23:07,310
disclaimer is not necessarily a new

00:23:04,250 --> 00:23:10,280
kernel image it will be the old kernel

00:23:07,310 --> 00:23:14,270
image but the new Rama fast but details

00:23:10,280 --> 00:23:16,220
just think of it as a new kernel running

00:23:14,270 --> 00:23:17,810
a special kernel just for k-dub you have

00:23:16,220 --> 00:23:20,120
the running kernel and you have the

00:23:17,810 --> 00:23:22,660
special kingdom kernel which only does

00:23:20,120 --> 00:23:25,100
the two things that we care about

00:23:22,660 --> 00:23:29,600
copying the contents of the memory and

00:23:25,100 --> 00:23:33,260
put a storing it somewhere ok so we have

00:23:29,600 --> 00:23:37,790
the k-dubb configured this will tell the

00:23:33,260 --> 00:23:39,770
colonel when it panics meaning that it

00:23:37,790 --> 00:23:41,750
does anything that the kernel should do

00:23:39,770 --> 00:23:45,380
on panic line for example print out

00:23:41,750 --> 00:23:47,660
those messages on screen just before it

00:23:45,380 --> 00:23:51,250
that's the last thing which is do

00:23:47,660 --> 00:23:55,220
nothing and stay there on the screen

00:23:51,250 --> 00:23:57,290
the kernel will do a que exec on this

00:23:55,220 --> 00:23:57,890
memory region which contains the kdump

00:23:57,290 --> 00:24:00,470
kernel

00:23:57,890 --> 00:24:01,940
thus we're going to have a new running

00:24:00,470 --> 00:24:03,830
kernel on the system we're going to have

00:24:01,940 --> 00:24:06,320
a new image doing something else

00:24:03,830 --> 00:24:08,330
everything that was in the RAM at the

00:24:06,320 --> 00:24:10,670
time of the crash is still there

00:24:08,330 --> 00:24:13,010
nothing cleared it the old colonel did

00:24:10,670 --> 00:24:14,900
not do clearing of the ramp

00:24:13,010 --> 00:24:15,679
I didn't power off anything so I didn't

00:24:14,900 --> 00:24:18,409
look like

00:24:15,679 --> 00:24:22,700
I just ran a new Colonel there and

00:24:18,409 --> 00:24:26,360
everything else remains meaning that I

00:24:22,700 --> 00:24:29,929
can copy the beer I can copy the content

00:24:26,360 --> 00:24:32,179
into this VM port so the Keegan's image

00:24:29,929 --> 00:24:34,580
will take care of this well it will just

00:24:32,179 --> 00:24:37,100
take the contents of the RAM and swap if

00:24:34,580 --> 00:24:41,000
we need if we need to and store them on

00:24:37,100 --> 00:24:43,730
a flat that file can be for example on a

00:24:41,000 --> 00:24:45,350
partition on the disk it can mount it

00:24:43,730 --> 00:24:47,679
you can be on the route FS not

00:24:45,350 --> 00:24:51,380
recommended it can be on a separate

00:24:47,679 --> 00:24:54,380
partition or LV and even a can do

00:24:51,380 --> 00:24:58,250
Network copy so it either a secure copy

00:24:54,380 --> 00:25:01,039
or NFS or actually use ice Kazim to copy

00:24:58,250 --> 00:25:06,080
the VM core over the network into

00:25:01,039 --> 00:25:08,750
another system but a year okay then

00:25:06,080 --> 00:25:11,360
managed to copy everything and store it

00:25:08,750 --> 00:25:16,130
in a place where we can do a post-mortem

00:25:11,360 --> 00:25:18,770
analysis now how much does this VM core

00:25:16,130 --> 00:25:21,380
occupied well in theory it's the size of

00:25:18,770 --> 00:25:23,630
the RAM plus the size of the swamp let's

00:25:21,380 --> 00:25:26,299
just say the size of the the RAM for

00:25:23,630 --> 00:25:28,520
genetic purposes that might be a big

00:25:26,299 --> 00:25:32,059
file so for example if we're on a server

00:25:28,520 --> 00:25:37,480
that has a 128 GB by kilogram it's going

00:25:32,059 --> 00:25:40,299
to have 128 gigabytes of storage file of

00:25:37,480 --> 00:25:42,799
store data on the file that might be big

00:25:40,299 --> 00:25:46,429
but sometimes we don't need to store

00:25:42,799 --> 00:25:50,840
everything for example we don't need to

00:25:46,429 --> 00:25:53,240
store the contents of the user space the

00:25:50,840 --> 00:25:55,280
virtual memory user space virtual memory

00:25:53,240 --> 00:25:58,039
of the process we if we do kernel

00:25:55,280 --> 00:26:01,010
debugging we don't need to know what was

00:25:58,039 --> 00:26:02,990
going on in this application running on

00:26:01,010 --> 00:26:06,470
the system so we can zero those out and

00:26:02,990 --> 00:26:10,220
actually we want to do that because it's

00:26:06,470 --> 00:26:13,309
a matter of privacy for example if Red

00:26:10,220 --> 00:26:15,389
Hat customers send us a VM core of their

00:26:13,309 --> 00:26:18,899
system

00:26:15,389 --> 00:26:21,869
that were not gonna access private data

00:26:18,899 --> 00:26:25,589
for their company so what we do we

00:26:21,869 --> 00:26:27,509
actually zero out or we recommend the

00:26:25,589 --> 00:26:30,539
client to set up k-dubb in such a way

00:26:27,509 --> 00:26:32,190
that they zero out all the information

00:26:30,539 --> 00:26:35,399
that has nothing to do with the actual

00:26:32,190 --> 00:26:38,789
kernel so in the end we're going to have

00:26:35,399 --> 00:26:41,339
an image of mostly zeros which can be

00:26:38,789 --> 00:26:43,889
compressed so we have a big image but if

00:26:41,339 --> 00:26:45,899
we run a compression algorithm on it we

00:26:43,889 --> 00:26:49,979
can reduce the fat the size of that vm

00:26:45,899 --> 00:26:53,099
port to a very small number like a

00:26:49,979 --> 00:26:56,249
couple of gigabytes so we have the VM

00:26:53,099 --> 00:26:59,009
core we can do analysis on the VM core

00:26:56,249 --> 00:27:01,649
and see what was going on on the system

00:26:59,009 --> 00:27:03,599
at the time of the crash what do we used

00:27:01,649 --> 00:27:08,219
to do that there's this utility called

00:27:03,599 --> 00:27:11,429
crash crash is something that we would

00:27:08,219 --> 00:27:14,700
run on our system or on the system that

00:27:11,429 --> 00:27:18,329
crashed after the reboot to analyze that

00:27:14,700 --> 00:27:21,629
VM core that was generated pressure is

00:27:18,329 --> 00:27:25,769
actually based on gdb so it uses in the

00:27:21,629 --> 00:27:28,079
background gdb this means that you or if

00:27:25,769 --> 00:27:31,649
you know gdb you could be quite familiar

00:27:28,079 --> 00:27:35,099
with what the crash looks like if you

00:27:31,649 --> 00:27:36,539
have some of the same workflows you have

00:27:35,099 --> 00:27:39,869
some of the same features you can have

00:27:36,539 --> 00:27:42,779
plugins for example like in Gd deemed so

00:27:39,869 --> 00:27:47,009
you take advantage of what gdb does plus

00:27:42,779 --> 00:27:49,859
kernel specific things on top it

00:27:47,009 --> 00:27:51,719
requires its inputs of course the VM

00:27:49,859 --> 00:27:53,729
core to see what was the state of the

00:27:51,719 --> 00:27:57,179
system at the time but it also requires

00:27:53,729 --> 00:27:59,789
the original kernel image kernel binary

00:27:57,179 --> 00:28:01,859
just like gdb would you on a normal

00:27:59,789 --> 00:28:05,029
application when you start post-mortal

00:28:01,859 --> 00:28:08,789
an application with you want to read you

00:28:05,029 --> 00:28:11,309
to rewind the an application crash if

00:28:08,789 --> 00:28:13,799
you have the core down you did a gdb my

00:28:11,309 --> 00:28:16,289
application and the core down same thing

00:28:13,799 --> 00:28:18,309
with crash to run crash with the kernel

00:28:16,289 --> 00:28:21,129
image it has to be the same

00:28:18,309 --> 00:28:24,340
image as the one onto the VM Court and

00:28:21,129 --> 00:28:28,450
then the actual VM Court what you get is

00:28:24,340 --> 00:28:31,269
an environment where you have the same

00:28:28,450 --> 00:28:34,210
things or in the crash session as you

00:28:31,269 --> 00:28:36,580
would have on the real system at the

00:28:34,210 --> 00:28:39,429
time of the crash so for example you can

00:28:36,580 --> 00:28:42,340
access logs you can access the damask

00:28:39,429 --> 00:28:44,049
buffer because the kernel log buffer was

00:28:42,340 --> 00:28:46,059
in RAM at the time of the crash

00:28:44,049 --> 00:28:47,889
therefore it was going to be in the VM

00:28:46,059 --> 00:28:49,840
core you can access it so you can get

00:28:47,889 --> 00:28:52,210
more more information you can see the

00:28:49,840 --> 00:28:54,789
entire history of the kernel all the

00:28:52,210 --> 00:28:58,450
logs without having to go with page up

00:28:54,789 --> 00:29:00,460
on the screen we also have access to all

00:28:58,450 --> 00:29:02,879
the data structures of the kernel so

00:29:00,460 --> 00:29:05,349
everything from file systems to

00:29:02,879 --> 00:29:07,659
processes to network connections

00:29:05,349 --> 00:29:11,039
everything that was in RAM and used by

00:29:07,659 --> 00:29:15,690
the kernel you have access to it then

00:29:11,039 --> 00:29:19,539
you can have some tools built into a

00:29:15,690 --> 00:29:23,139
into a crash for example PS you crash

00:29:19,539 --> 00:29:27,729
contains PS a command that will give you

00:29:23,139 --> 00:29:29,320
a similar output SPS in userspace it's

00:29:27,729 --> 00:29:31,989
not going to have all the features of a

00:29:29,320 --> 00:29:34,629
normal PS but it will have just enough

00:29:31,989 --> 00:29:37,779
information for you to figure out what

00:29:34,629 --> 00:29:41,320
was running on the system or you can get

00:29:37,779 --> 00:29:43,749
you have some built-in commands to get

00:29:41,320 --> 00:29:46,509
information about memory you can access

00:29:43,749 --> 00:29:49,029
the mount to see the mount points at the

00:29:46,509 --> 00:29:51,460
time of the crash if there isn't

00:29:49,029 --> 00:29:54,369
something specific that there exists as

00:29:51,460 --> 00:29:57,219
a commanding crash you can always try to

00:29:54,369 --> 00:30:01,839
dissect the actual structures you can

00:29:57,219 --> 00:30:04,419
have pointers in memory you can say that

00:30:01,839 --> 00:30:07,389
that point or a memory represents for

00:30:04,419 --> 00:30:11,169
example of a file stock and you can read

00:30:07,389 --> 00:30:13,809
the contents of that structure as it was

00:30:11,169 --> 00:30:21,070
at the moment of the crash by casting it

00:30:13,809 --> 00:30:24,399
to a strong file so you can do the debug

00:30:21,070 --> 00:30:28,179
as detailed debugging as you want in

00:30:24,399 --> 00:30:31,140
this crash session um if you have all

00:30:28,179 --> 00:30:36,340
the contents of the ramp

00:30:31,140 --> 00:30:38,860
for example what you can do very easy

00:30:36,340 --> 00:30:42,490
and something that we we do all the time

00:30:38,860 --> 00:30:45,809
out of memory the body so we saw on the

00:30:42,490 --> 00:30:49,510
on the screen earlier that there was

00:30:45,809 --> 00:30:53,260
that crash that was caused by out of

00:30:49,510 --> 00:30:55,600
memory issues so we know that something

00:30:53,260 --> 00:30:59,620
was occupying the RAM but we don't know

00:30:55,600 --> 00:31:03,070
what in in a normal system you have the

00:30:59,620 --> 00:31:06,220
OEM killer that will try to kill some

00:31:03,070 --> 00:31:09,580
processes that consume Ram to fear for

00:31:06,220 --> 00:31:12,370
RAM but at some point if all one killer

00:31:09,580 --> 00:31:15,460
cannot cope with the haunt of memory

00:31:12,370 --> 00:31:19,210
being used it's going to give up and let

00:31:15,460 --> 00:31:21,010
the kernel panic you're going to see on

00:31:19,210 --> 00:31:23,700
the panic message you're going to see

00:31:21,010 --> 00:31:26,169
that one specific process failed

00:31:23,700 --> 00:31:28,809
allocating memory and that ultimately

00:31:26,169 --> 00:31:31,330
caused the kernel panic but it does not

00:31:28,809 --> 00:31:35,289
mean that that specific process which

00:31:31,330 --> 00:31:37,240
was running the panic function what is

00:31:35,289 --> 00:31:39,159
the one occupying the most memory so if

00:31:37,240 --> 00:31:41,139
you want to see what was occupying the

00:31:39,159 --> 00:31:44,549
memory so what you can use for example

00:31:41,139 --> 00:31:48,070
in there's a built-in commanding crash

00:31:44,549 --> 00:31:51,940
run kmn and see for example what was the

00:31:48,070 --> 00:31:55,000
usage of ram swap just like a similar

00:31:51,940 --> 00:31:58,389
output as the free format another way

00:31:55,000 --> 00:32:00,760
you can end with the output of kmm you

00:31:58,389 --> 00:32:02,559
for example was he if indeed all the

00:32:00,760 --> 00:32:05,200
swap was used and all of the RAM was

00:32:02,559 --> 00:32:11,309
used indeed if it was an out of memory

00:32:05,200 --> 00:32:12,460
issue then you can do on you can run PS

00:32:11,309 --> 00:32:14,880
sorry

00:32:12,460 --> 00:32:14,880
yes

00:32:15,180 --> 00:32:39,900
ah so to figure out what were the

00:32:27,300 --> 00:32:42,810
structures used by yes I honestly don't

00:32:39,900 --> 00:32:46,890
remember I think you can get that

00:32:42,810 --> 00:32:49,890
information but I I really don't know

00:32:46,890 --> 00:32:55,530
the answer we can see we can try to to

00:32:49,890 --> 00:33:00,780
run the output somebody knows but

00:32:55,530 --> 00:33:04,410
usually the amount of memory occupied by

00:33:00,780 --> 00:33:14,730
kernel structures is infamously smaller

00:33:04,410 --> 00:33:18,240
compared to the user paid data well you

00:33:14,730 --> 00:33:20,760
would then have to dig into all the

00:33:18,240 --> 00:33:23,760
information about the slab and you can

00:33:20,760 --> 00:33:26,160
access that information so you can

00:33:23,760 --> 00:33:28,320
probably not with this specific command

00:33:26,160 --> 00:33:30,690
but in the end yes you would be able to

00:33:28,320 --> 00:33:33,110
get all that information there it

00:33:30,690 --> 00:33:37,740
depends how deep you want to dig

00:33:33,110 --> 00:33:41,240
so on the back to a p.m. to fresh you

00:33:37,740 --> 00:33:44,190
have the option of running PS and C

00:33:41,240 --> 00:33:47,640
which process so process ID with

00:33:44,190 --> 00:33:49,380
processing all the information you would

00:33:47,640 --> 00:33:51,840
have with the normal PS C which

00:33:49,380 --> 00:33:54,300
processes or threads were using the

00:33:51,840 --> 00:33:57,630
physical memory also you would have the

00:33:54,300 --> 00:34:01,410
virtual memory of each processor lookups

00:33:57,630 --> 00:34:05,640
you would have a problem where you are

00:34:01,410 --> 00:34:08,870
the were the system feast because there

00:34:05,640 --> 00:34:11,700
was a resource being used by several

00:34:08,870 --> 00:34:15,540
processors you can end up in a deadlock

00:34:11,700 --> 00:34:19,650
situation where all of the CPUs were

00:34:15,540 --> 00:34:22,200
stuck on an instruction and no new tasks

00:34:19,650 --> 00:34:25,860
were able to to be scheduled on those

00:34:22,200 --> 00:34:28,720
CPU the generic a deadlock up situation

00:34:25,860 --> 00:34:30,760
all for example you can

00:34:28,720 --> 00:34:33,970
in a VM core you can run a BT a

00:34:30,760 --> 00:34:37,840
back-trace of all the process of those

00:34:33,970 --> 00:34:41,440
CPUs to see what processes were running

00:34:37,840 --> 00:34:45,220
on the CPU on what kernel function they

00:34:41,440 --> 00:34:48,010
were stuck on and if for example all

00:34:45,220 --> 00:34:50,560
their CPUs or stockist em up you would

00:34:48,010 --> 00:34:52,960
be able to see what was that spin lock

00:34:50,560 --> 00:34:56,830
which was keeping all of the processes

00:34:52,960 --> 00:35:00,010
all of the CPUs occupied you would be

00:34:56,830 --> 00:35:03,420
able to to determine what was the the

00:35:00,010 --> 00:35:07,270
common resource that caused the Locker

00:35:03,420 --> 00:35:12,460
um there are several things you can do

00:35:07,270 --> 00:35:17,790
with with crash I just gave to two

00:35:12,460 --> 00:35:21,160
examples we also have some specific

00:35:17,790 --> 00:35:24,580
plugins to test for issues for example

00:35:21,160 --> 00:35:29,260
with the file system if the file system

00:35:24,580 --> 00:35:32,740
was frozen and somebody tried to access

00:35:29,260 --> 00:35:35,440
that file system you with those plugins

00:35:32,740 --> 00:35:38,800
you can build up some specific tests and

00:35:35,440 --> 00:35:41,109
try to see if at the time of the crash

00:35:38,800 --> 00:35:43,960
some specific things were happening on

00:35:41,109 --> 00:35:47,560
the machine test for them and see if it

00:35:43,960 --> 00:35:50,080
matches some known use case but these

00:35:47,560 --> 00:35:53,710
were just a couple of these examples of

00:35:50,080 --> 00:35:56,710
how or you would ordinary try to use

00:35:53,710 --> 00:36:01,810
crash to debug some very basic things in

00:35:56,710 --> 00:36:04,060
the kernel what I wanted to share with

00:36:01,810 --> 00:36:08,700
you today is that you need to be

00:36:04,060 --> 00:36:12,420
prepared for these kinds of of crashes

00:36:08,700 --> 00:36:15,400
kdump is not enabled by default in

00:36:12,420 --> 00:36:17,320
insomnia distributions it comes as an

00:36:15,400 --> 00:36:19,300
option to be installed by people that

00:36:17,320 --> 00:36:21,640
you still need to activate it you still

00:36:19,300 --> 00:36:23,980
need to reserve that memory space for

00:36:21,640 --> 00:36:27,220
the RAM because it cost you it depends

00:36:23,980 --> 00:36:29,970
on if you find it useful to have a

00:36:27,220 --> 00:36:32,380
specific region of memory allocated

00:36:29,970 --> 00:36:34,720
constantly in RAM so you have to

00:36:32,380 --> 00:36:35,279
configure it yourself but if you have

00:36:34,720 --> 00:36:36,989
come

00:36:35,279 --> 00:36:40,199
k-dubb configure at least you will have

00:36:36,989 --> 00:36:42,539
the option of doing the analysis force

00:36:40,199 --> 00:36:44,759
modem so you will be able to gather more

00:36:42,539 --> 00:36:47,029
information after the system has been

00:36:44,759 --> 00:36:52,409
rebooted and restored into production

00:36:47,029 --> 00:36:55,409
also once you have that that vm for you

00:36:52,409 --> 00:36:56,819
have tools like crash to analyze the vm

00:36:55,409 --> 00:37:00,029
core and get some useful information

00:36:56,819 --> 00:37:03,989
about the system without having to like

00:37:00,029 --> 00:37:05,880
debug the problem install Kadem if

00:37:03,989 --> 00:37:08,880
you're running a production server

00:37:05,880 --> 00:37:13,859
we highly recommend it a hot half of our

00:37:08,880 --> 00:37:17,459
of our cases we basically say please

00:37:13,859 --> 00:37:18,929
install kdump it will be useful for you

00:37:17,459 --> 00:37:24,209
in the future if you're running with

00:37:18,929 --> 00:37:37,799
this rail system in production up if you

00:37:24,209 --> 00:37:38,579
have any questions performance well let

00:37:37,799 --> 00:37:45,029
me ask you this

00:37:38,579 --> 00:37:48,049
is it running while it's in the system

00:37:45,029 --> 00:37:52,199
is in production nothing is running

00:37:48,049 --> 00:37:54,179
before the actual time so except that

00:37:52,199 --> 00:37:55,919
piece of memory is the memory that you

00:37:54,179 --> 00:37:57,869
have to reserve to be there in case you

00:37:55,919 --> 00:38:02,699
want to execute it nothing's actually

00:37:57,869 --> 00:38:05,099
running so it it doesn't impact

00:38:02,699 --> 00:38:13,609
performance because you have something

00:38:05,099 --> 00:38:13,609
else running on the system it depends

00:38:15,589 --> 00:38:21,900
for example if you have I'm not specific

00:38:20,279 --> 00:38:23,939
I don't know if the number specifically

00:38:21,900 --> 00:38:26,849
but rough estimate if you have for

00:38:23,939 --> 00:38:30,390
example a gigabyte of RAM 100 gigabyte

00:38:26,849 --> 00:38:33,599
of RAM maybe you want to reserve 200

00:38:30,390 --> 00:38:37,559
megabytes for for the crash burner

00:38:33,599 --> 00:38:41,159
parameter this is needed because usually

00:38:37,559 --> 00:38:44,069
to do the copying to have all all the

00:38:41,159 --> 00:38:46,450
space to run operations like coffee

00:38:44,069 --> 00:38:49,180
compress copy over the network

00:38:46,450 --> 00:38:52,380
copy over a lot of this does that answer

00:38:49,180 --> 00:38:52,380
your question okay

00:38:53,339 --> 00:39:07,050
laughter anything else

00:38:56,349 --> 00:39:07,050
ah I need to know Prescott right after

00:39:12,390 --> 00:39:19,150
well you will need the Oh Winnie run

00:39:16,780 --> 00:39:24,099
fashion you will need to render the

00:39:19,150 --> 00:39:27,940
image on a debug kernel so another

00:39:24,099 --> 00:39:30,640
kernel compiled with a debug options but

00:39:27,940 --> 00:39:35,609
the kernel combined with for example the

00:39:30,640 --> 00:39:38,790
symbols so not a strip current okay

00:39:35,609 --> 00:39:38,790
there was

00:39:40,410 --> 00:39:50,340
actually crashes again it can have fun

00:39:46,920 --> 00:39:52,740
that you have the kdump while it's

00:39:50,340 --> 00:39:56,400
running having some issues and panic

00:39:52,740 --> 00:40:07,190
itself right yes yeah you won't have a

00:39:56,400 --> 00:40:10,050
kid yes in short yes there are

00:40:07,190 --> 00:40:13,200
situations where for example in cluster

00:40:10,050 --> 00:40:16,440
environments you have the running system

00:40:13,200 --> 00:40:18,900
that is crashed and you have fencing

00:40:16,440 --> 00:40:21,960
mechanisms by other cluster nodes

00:40:18,900 --> 00:40:24,750
meaning that the note that crash needs

00:40:21,960 --> 00:40:29,640
to surely be taken out of the system so

00:40:24,750 --> 00:40:32,880
an entity powers off the machine so if

00:40:29,640 --> 00:40:35,400
that happens while kdump is copying the

00:40:32,880 --> 00:40:37,950
data you won't have the VM quorum please

00:40:35,400 --> 00:40:43,860
not a completely import this is

00:40:37,950 --> 00:40:45,960
recommended to rather novel as to design

00:40:43,860 --> 00:40:49,740
issues well we were driving with the

00:40:45,960 --> 00:40:53,310
same issues so in reality the kdump

00:40:49,740 --> 00:40:56,550
kernel is actually the same kernel it

00:40:53,310 --> 00:41:00,000
just has a limited set of tools there in

00:40:56,550 --> 00:41:01,800
there any trauma so is the same as a

00:41:00,000 --> 00:41:03,720
normal kernel hat would have things in

00:41:01,800 --> 00:41:08,040
the indie drama fest energy so you don't

00:41:03,720 --> 00:41:11,370
use another problem take it no no it you

00:41:08,040 --> 00:41:15,810
could but in practice you don't it's the

00:41:11,370 --> 00:41:20,430
same kernel image for the K dumper

00:41:15,810 --> 00:41:22,800
oh why bother with the maintaining a

00:41:20,430 --> 00:41:32,820
different separate kernel when you can

00:41:22,800 --> 00:41:34,890
use the same one newer kernels are

00:41:32,820 --> 00:41:39,720
always better okay I think we're running

00:41:34,890 --> 00:41:43,770
out of time I elect some some links to

00:41:39,720 --> 00:41:46,560
the in the presentation first is for the

00:41:43,770 --> 00:41:48,570
feature in in the Linux kernel the key

00:41:46,560 --> 00:41:51,630
damn picture the second is the white

00:41:48,570 --> 00:41:56,550
paper regarding crash so it's actually a

00:41:51,630 --> 00:42:01,530
rather old tool but it explains how how

00:41:56,550 --> 00:42:04,380
it's made for our for Red Hat customers

00:42:01,530 --> 00:42:07,800
we have some specific articles on how

00:42:04,380 --> 00:42:11,190
well we we recommend Kate them being set

00:42:07,800 --> 00:42:15,210
up and we actually have a small script

00:42:11,190 --> 00:42:18,090
that prepares the environment for

00:42:15,210 --> 00:42:21,570
Kingdom you just go to the customer

00:42:18,090 --> 00:42:23,940
portal you do a retro wizard in the web

00:42:21,570 --> 00:42:25,620
interface it generates a script you

00:42:23,940 --> 00:42:28,410
download the script you run the script

00:42:25,620 --> 00:42:35,840
you have kdump working so it takes you

00:42:28,410 --> 00:42:38,820
three seconds except for one edge up

00:42:35,840 --> 00:42:41,460
because you don't want all the time to

00:42:38,820 --> 00:42:44,640
reserve that kernel of that memory

00:42:41,460 --> 00:42:47,210
region might be impacting on the system

00:42:44,640 --> 00:42:51,650
I would recommend everybody to have it

00:42:47,210 --> 00:42:51,650
okay thank you very much

00:42:56,780 --> 00:43:01,100
if you want to find the place there

00:42:58,990 --> 00:43:09,760
thank you enjoy the rest of the

00:43:01,100 --> 00:43:09,760
conference yes a thief always scarves

00:43:12,170 --> 00:43:20,290
configuration on your photo actual

00:43:17,330 --> 00:43:20,290
still out there

00:43:20,369 --> 00:43:33,690
I know so it's available for so this

00:43:29,150 --> 00:43:36,029
this link is only for people who have

00:43:33,690 --> 00:43:37,710
Red Hat subscription yeah I got it was a

00:43:36,029 --> 00:43:41,759
Bible in there actually couldn't find

00:43:37,710 --> 00:43:42,390
for at the seven ah give me just a

00:43:41,759 --> 00:43:45,210
second

00:43:42,390 --> 00:43:47,720
our largest we just create a new ticket

00:43:45,210 --> 00:43:50,849
four thousand by the sovereign status

00:43:47,720 --> 00:43:52,829
links for only for the six and five I

00:43:50,849 --> 00:43:58,789
marry with no information about seven

00:43:52,829 --> 00:43:58,789
I'm almost positive that there is four

00:44:02,450 --> 00:44:10,259
I'll check it now actually I do know

00:44:07,019 --> 00:44:12,140
something this is not something is asked

00:44:10,259 --> 00:44:15,140
Unisa

00:44:12,140 --> 00:44:15,140
potentially

00:44:36,859 --> 00:44:44,089
why don't any minute on opening okay

00:44:40,910 --> 00:44:47,809
generate the VM curvy and core on the

00:44:44,089 --> 00:44:50,000
working system without any crash well

00:44:47,809 --> 00:44:56,869
you couldn't think nothing at all

00:44:50,000 --> 00:44:59,180
MOC yeah it is I did let me find that so

00:44:56,869 --> 00:45:01,750
I can unlock and leave the next

00:44:59,180 --> 00:45:01,750
presenter

00:45:08,200 --> 00:45:20,680
actually without crushing system I just

00:45:13,690 --> 00:45:25,050
Epis I just generate across and okay

00:45:20,680 --> 00:45:25,050
I have text work done from people just

00:45:27,660 --> 00:45:32,730
just call me Tom dumping of the memory

00:45:33,090 --> 00:45:46,930
PDF anyway I just generated the crash so

00:45:44,830 --> 00:45:49,080
I will send it to this point for the red

00:45:46,930 --> 00:45:49,080
carpet

00:45:58,260 --> 00:46:01,590
thank you

00:46:08,500 --> 00:46:14,020
I actually like giving our presentation

00:46:11,740 --> 00:46:18,220
I like talking about the things that I

00:46:14,020 --> 00:46:29,349
do and like so thank you so kingdom

00:46:18,220 --> 00:46:33,760
helper back to Kate um helpers with West

00:46:29,349 --> 00:46:44,130
about Kate dampener l7 somebody has

00:46:33,760 --> 00:46:44,130
about them is there it has options okay

00:46:50,840 --> 00:46:53,470
yes

00:47:11,369 --> 00:47:18,450
Toby tell them what was on thermometer

00:47:14,900 --> 00:47:23,180
ec6 Terra I'm sorry - come on Terence

00:47:18,450 --> 00:47:23,180
attack yo don't go to muttering OH

00:47:31,460 --> 00:47:39,480
as it as a scooter present through

00:47:35,940 --> 00:47:42,630
Joanna - Marty setup so whatever

00:47:39,480 --> 00:47:46,040
observers are aware traditional sheepy

00:47:42,630 --> 00:47:46,040

YouTube URL: https://www.youtube.com/watch?v=w8XnnG68rqE


