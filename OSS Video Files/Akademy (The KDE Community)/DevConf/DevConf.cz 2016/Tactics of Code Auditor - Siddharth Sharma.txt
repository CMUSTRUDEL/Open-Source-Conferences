Title: Tactics of Code Auditor - Siddharth Sharma
Publication date: 2016-02-11
Playlist: DevConf.cz 2016
Description: 
	Source Code Auditing is an important part of security. Being proactive in looking for security bugs before the software is shipped is great way to cut down the risks. Though Source Code Auditing can be performed before the code is shipped or after the code is compiled and shipped as binary. In this talk I would share some of tactics and tools that I use to perform code auditing and explain different types of vulnerabilities present in code caused by for e.g Buffer Overflows, Heap Overflows , data type, arithmetic computations and etc. Some parts of this talk would have live demo and also might go into live pentesting according to time frame. 

- Introduction
- Why we need to perform source code audits
- Defining scope of audit

- SoftWare Auditing Tactics [ C/C++ ]
- Attack plan with limited time frame
- Where to attack
- How to attack
- Which tools to use
- Understanding the impact of vulnerability

This talk is only focused on auditing software written in C/C++. But one can take some parts of this talk and would be able to implement into their own working environment.

Presentation: http://bit.ly/1R05fJP
Captions: 
	00:02:04,630 --> 00:02:16,120
hello nope

00:05:16,729 --> 00:05:26,249
hello everyone here's the last free

00:05:23,069 --> 00:05:31,979
poster if we want somebody and his

00:05:26,249 --> 00:05:37,489
stickers also free if somebody want well

00:05:31,979 --> 00:05:37,489
now please welcome Siddharth

00:06:13,519 --> 00:06:19,860
so title of my talk is tactics of code

00:06:16,589 --> 00:06:22,469
or later and it's about the coordinating

00:06:19,860 --> 00:06:25,860
is something which cannot be really

00:06:22,469 --> 00:06:28,469
taught it's by time it's like how much

00:06:25,860 --> 00:06:32,789
time you do it in reading code and doing

00:06:28,469 --> 00:06:35,999
stuff with it so I'm going to share some

00:06:32,789 --> 00:06:39,559
of my experiences that I like I've been

00:06:35,999 --> 00:06:42,990
auditing code for past two years now and

00:06:39,559 --> 00:06:47,089
so that that's what I'm going to say how

00:06:42,990 --> 00:06:51,899
I do it and I don't say it it's like the

00:06:47,089 --> 00:06:55,439
complete thing people can actually

00:06:51,899 --> 00:07:03,899
implement on like their own techniques

00:06:55,439 --> 00:07:10,519
and stuff so here is the agenda for the

00:07:03,899 --> 00:07:10,519
talk and I'm not going to talk about it

00:07:11,449 --> 00:07:18,119
so what does code auditing looked looked

00:07:15,659 --> 00:07:23,519
like it's actually the fourth in India

00:07:18,119 --> 00:07:26,700
it's pretty amazing if you see this Ford

00:07:23,519 --> 00:07:29,650
was built quite quite long time back

00:07:26,700 --> 00:07:32,080
the fun part what this fourth is when

00:07:29,650 --> 00:07:34,840
the tides are high this fourth is like

00:07:32,080 --> 00:07:39,280
the water will be here and you cannot go

00:07:34,840 --> 00:07:41,590
walking you go through boards or any any

00:07:39,280 --> 00:07:43,900
other means that works on that moves on

00:07:41,590 --> 00:07:48,610
the water and when there is a low tide

00:07:43,900 --> 00:07:50,650
you go by horses or the other means of

00:07:48,610 --> 00:07:53,860
the transport so what I want to say here

00:07:50,650 --> 00:07:57,180
it's like the source code or the

00:07:53,860 --> 00:07:59,380
application is same like this if you put

00:07:57,180 --> 00:08:02,380
your application in two different

00:07:59,380 --> 00:08:04,960
environments it won't have different

00:08:02,380 --> 00:08:07,990
type of vulnerabilities it would it can

00:08:04,960 --> 00:08:11,860
be attacked differently at like the

00:08:07,990 --> 00:08:15,040
architectures the way the application is

00:08:11,860 --> 00:08:17,830
running at the moment so yes

00:08:15,040 --> 00:08:19,990
it's pretty much the same thing you have

00:08:17,830 --> 00:08:23,110
a back door in the fort do you have

00:08:19,990 --> 00:08:28,650
known flaws you have unknown flaws there

00:08:23,110 --> 00:08:33,210
are guards which you want to tackle them

00:08:28,650 --> 00:08:36,490
so the scope of the ordered it's like

00:08:33,210 --> 00:08:39,820
many developers or like I work for the

00:08:36,490 --> 00:08:42,729
team where we have customers who are

00:08:39,820 --> 00:08:46,570
internal to the red heart sometimes we

00:08:42,729 --> 00:08:49,030
get like the customers who use Red Hat

00:08:46,570 --> 00:08:52,570
products they say we want to buy this

00:08:49,030 --> 00:08:54,900
product but what what's the proactive

00:08:52,570 --> 00:08:59,400
effort the idea we are putting it into

00:08:54,900 --> 00:09:02,200
the cold audit or of the application

00:08:59,400 --> 00:09:04,120
many developers would ask ok we have

00:09:02,200 --> 00:09:08,310
implemented this feature in the

00:09:04,120 --> 00:09:11,890
application and we want to we want

00:09:08,310 --> 00:09:16,690
someone to look at it like them there

00:09:11,890 --> 00:09:18,730
might be some vulnerability or not in

00:09:16,690 --> 00:09:21,370
terms of the open source or the red

00:09:18,730 --> 00:09:23,050
heart but like people who are the

00:09:21,370 --> 00:09:25,830
freelancers they can go for the bug

00:09:23,050 --> 00:09:33,040
bounties and 0 days we all see that a

00:09:25,830 --> 00:09:35,800
lot of times like the program managers

00:09:33,040 --> 00:09:36,649
of the product or different people

00:09:35,800 --> 00:09:38,660
involving

00:09:36,649 --> 00:09:40,809
product they will say ok even if you

00:09:38,660 --> 00:09:43,610
find the lower the more moderate

00:09:40,809 --> 00:09:47,360
vulnerabilities in the court just Ellis

00:09:43,610 --> 00:09:49,279
will fix it so when you start or dating

00:09:47,360 --> 00:09:51,259
chord it's really important to

00:09:49,279 --> 00:09:53,269
understand like what you are looking for

00:09:51,259 --> 00:09:58,309
there there might be like your customer

00:09:53,269 --> 00:10:00,800
wants only the vulnerabilities though

00:09:58,309 --> 00:10:03,379
those are critical or important to them

00:10:00,800 --> 00:10:05,569
and they just don't care about like the

00:10:03,379 --> 00:10:13,519
lows and moderate so you don't report

00:10:05,569 --> 00:10:20,689
them so this is pretty much the

00:10:13,519 --> 00:10:22,850
methodology that I that I use it's when

00:10:20,689 --> 00:10:24,709
you are looking for the particular

00:10:22,850 --> 00:10:27,079
application you should you should really

00:10:24,709 --> 00:10:29,360
look at the documentation exactly the

00:10:27,079 --> 00:10:32,660
same version of the documentation which

00:10:29,360 --> 00:10:34,759
applies to the source you are auditing

00:10:32,660 --> 00:10:36,230
because that's really important and most

00:10:34,759 --> 00:10:41,660
of the times in the documentation you

00:10:36,230 --> 00:10:43,040
are going to see like comments or even

00:10:41,660 --> 00:10:45,110
in the chord you can see the comments

00:10:43,040 --> 00:10:47,240
from the developer saying that ok we

00:10:45,110 --> 00:10:50,509
have not implemented this feature but

00:10:47,240 --> 00:10:53,629
this is really important and then you

00:10:50,509 --> 00:10:55,459
know where to look at the other thing is

00:10:53,629 --> 00:10:59,480
I haven't tried it because most of the

00:10:55,459 --> 00:11:02,079
developers like live outside or like I

00:10:59,480 --> 00:11:05,379
don't talk to them in the real world

00:11:02,079 --> 00:11:08,209
it's like you talk to developers you

00:11:05,379 --> 00:11:10,189
when developer is really drinking you

00:11:08,209 --> 00:11:12,410
should go and ask them they might spill

00:11:10,189 --> 00:11:14,949
the beans like they have this problem in

00:11:12,410 --> 00:11:17,720
their code and you wouldn't know yeah

00:11:14,949 --> 00:11:24,949
this is something which we need to look

00:11:17,720 --> 00:11:26,839
at the other thing is if the if the in

00:11:24,949 --> 00:11:29,870
the source code that you are if the

00:11:26,839 --> 00:11:31,429
application you are going toward it it

00:11:29,870 --> 00:11:37,100
has been in the community for a long

00:11:31,429 --> 00:11:39,679
time you should see like what the other

00:11:37,100 --> 00:11:42,529
like the people in the community are

00:11:39,679 --> 00:11:46,850
saying about it they might have some

00:11:42,529 --> 00:11:49,519
ideas ok we think this could be the

00:11:46,850 --> 00:11:50,220
security flaw in this application but no

00:11:49,519 --> 00:11:53,520
one

00:11:50,220 --> 00:11:55,890
so you have some some idea like you some

00:11:53,520 --> 00:11:58,260
boundaries where you can start thinking

00:11:55,890 --> 00:12:03,120
of it there is an idea and then you

00:11:58,260 --> 00:12:05,040
start developing the thing that yeah how

00:12:03,120 --> 00:12:07,080
you are going to order that the other

00:12:05,040 --> 00:12:09,120
important part is if there is an

00:12:07,080 --> 00:12:10,290
application you should really know there

00:12:09,120 --> 00:12:15,960
could be like million lines of

00:12:10,290 --> 00:12:17,880
coordinate so you should if you are able

00:12:15,960 --> 00:12:20,280
to get the blueprints of the application

00:12:17,880 --> 00:12:23,390
like how it works like what is the

00:12:20,280 --> 00:12:26,130
architectural design of the application

00:12:23,390 --> 00:12:29,010
you might not want to look at the

00:12:26,130 --> 00:12:31,830
backend like whatever it's getting

00:12:29,010 --> 00:12:33,510
stored in the database but rather the

00:12:31,830 --> 00:12:34,080
modules over the other places in the

00:12:33,510 --> 00:12:36,150
program

00:12:34,080 --> 00:12:38,850
where where the user is getting in

00:12:36,150 --> 00:12:41,520
feeding the input to the application so

00:12:38,850 --> 00:12:44,790
you can literally cut down the areas

00:12:41,520 --> 00:12:47,850
where the places where you are going to

00:12:44,790 --> 00:12:50,930
see or look through the code because in

00:12:47,850 --> 00:12:53,190
no way you are going to like people can

00:12:50,930 --> 00:12:56,070
order the 1 million lines of code or

00:12:53,190 --> 00:13:06,350
like lodging and dart in a week or two

00:12:56,070 --> 00:13:09,360
weeks it's not possible so this is like

00:13:06,350 --> 00:13:11,700
I'm just taking example of this F like

00:13:09,360 --> 00:13:15,020
this is the architecture however it

00:13:11,700 --> 00:13:19,710
works what's there so you get some idea

00:13:15,020 --> 00:13:22,350
like how how you want to order the code

00:13:19,710 --> 00:13:23,850
well there are the places where you want

00:13:22,350 --> 00:13:27,480
to look for example if there is some

00:13:23,850 --> 00:13:29,940
network thing or maybe at the places

00:13:27,480 --> 00:13:33,030
where the cryptography is used or the

00:13:29,940 --> 00:13:36,620
places where where the where there

00:13:33,030 --> 00:13:39,990
should be the like really secure channel

00:13:36,620 --> 00:13:42,720
in the data and the developers have not

00:13:39,990 --> 00:13:46,080
implemented so those are the good places

00:13:42,720 --> 00:13:57,480
to look at in the code to find out the

00:13:46,080 --> 00:13:59,880
vulnerabilities yeah yes so like why the

00:13:57,480 --> 00:14:02,850
application was written who are the who

00:13:59,880 --> 00:14:05,590
are its users it's also

00:14:02,850 --> 00:14:07,830
really important because if there is any

00:14:05,590 --> 00:14:11,710
demon that is going to run as a root and

00:14:07,830 --> 00:14:16,210
there is no like not much users but it's

00:14:11,710 --> 00:14:19,810
a demon then you you see things like if

00:14:16,210 --> 00:14:23,470
Damon escalates privileges like kid UID

00:14:19,810 --> 00:14:25,120
or set UID and there are places places

00:14:23,470 --> 00:14:27,430
in the code where it doesn't drop set

00:14:25,120 --> 00:14:30,220
properly so you might have you might

00:14:27,430 --> 00:14:34,660
want to look at those places in in the

00:14:30,220 --> 00:14:37,210
code as well so basically you should

00:14:34,660 --> 00:14:43,450
have some high-level view of the

00:14:37,210 --> 00:14:46,090
application where you can think in the

00:14:43,450 --> 00:14:51,850
boundaries where an attacker would would

00:14:46,090 --> 00:14:54,160
be looking at yes like authentication

00:14:51,850 --> 00:14:56,110
information disclosures while logging

00:14:54,160 --> 00:14:59,590
data so this is this is also really

00:14:56,110 --> 00:15:03,820
important for example a lot of places in

00:14:59,590 --> 00:15:07,570
the application where developers enable

00:15:03,820 --> 00:15:09,910
the debug debugging logs and the

00:15:07,570 --> 00:15:13,480
debugging logs get shared with the other

00:15:09,910 --> 00:15:17,890
people or they might load it to any

00:15:13,480 --> 00:15:22,360
public places that can have password IPS

00:15:17,890 --> 00:15:24,280
a lot of places so the this is also one

00:15:22,360 --> 00:15:28,030
of the important parts for the

00:15:24,280 --> 00:15:29,310
information disclosure like Howard's how

00:15:28,030 --> 00:15:33,070
the application is logging data

00:15:29,310 --> 00:15:40,270
especially the debugging logs and the

00:15:33,070 --> 00:15:42,280
crypto failures also just just not by

00:15:40,270 --> 00:15:44,890
looking at the source code but it it's

00:15:42,280 --> 00:15:48,940
also important when you compile source

00:15:44,890 --> 00:15:52,690
code compiler will throw up a lot of

00:15:48,940 --> 00:15:54,400
warnings like when we built our team our

00:15:52,690 --> 00:15:58,150
team packages you can see the RPM build

00:15:54,400 --> 00:16:01,360
logs what's gone wrong over there it

00:15:58,150 --> 00:16:05,410
might suggest some places where the code

00:16:01,360 --> 00:16:11,730
was not properly written so you get some

00:16:05,410 --> 00:16:13,840
ideas about the application or the code

00:16:11,730 --> 00:16:16,430
so

00:16:13,840 --> 00:16:19,150
I'm basically going to talk about the C

00:16:16,430 --> 00:16:21,920
and C++ one of innate abilities here

00:16:19,150 --> 00:16:24,620
like the common type of vulnerabilities

00:16:21,920 --> 00:16:31,490
in the code where people can actually

00:16:24,620 --> 00:16:33,350
see them see them so the first one is

00:16:31,490 --> 00:16:35,930
the buffer overflow then the data types

00:16:33,350 --> 00:16:38,290
and the miscalculation or the bad logic

00:16:35,930 --> 00:16:45,050
that happens in the code

00:16:38,290 --> 00:16:49,250
predictable filenames for example in the

00:16:45,050 --> 00:16:51,800
terms of the buffer overflows these are

00:16:49,250 --> 00:16:55,400
these are caused by the bad API is you

00:16:51,800 --> 00:16:59,240
can see mem copy and STR copying and

00:16:55,400 --> 00:17:01,310
things like that you can just in such

00:16:59,240 --> 00:17:05,540
situations where they usually do is I

00:17:01,310 --> 00:17:07,910
just grab these functions just throw

00:17:05,540 --> 00:17:10,700
throw them at the source code and if

00:17:07,910 --> 00:17:12,680
there is something it shows over there I

00:17:10,700 --> 00:17:16,430
don't have to use like lot of tools

00:17:12,680 --> 00:17:18,850
different tools to do that so if you see

00:17:16,430 --> 00:17:21,680
these these things you can just directly

00:17:18,850 --> 00:17:23,690
just lock them into your order to report

00:17:21,680 --> 00:17:27,320
and say okay and just need some change

00:17:23,690 --> 00:17:30,310
but usually these are not really very

00:17:27,320 --> 00:17:35,470
critical vulnerabilities now nowadays

00:17:30,310 --> 00:17:40,280
yes the other thing is a long time bike

00:17:35,470 --> 00:17:42,800
if the code is using any any string

00:17:40,280 --> 00:17:46,790
functions and you don't import the

00:17:42,800 --> 00:17:49,520
string or - they are completely lot of

00:17:46,790 --> 00:17:52,700
security checks the those mess in the

00:17:49,520 --> 00:17:55,600
code so while compiling also for example

00:17:52,700 --> 00:17:59,810
the 45 source will not work

00:17:55,600 --> 00:18:02,180
it it will not have the secure proper

00:17:59,810 --> 00:18:05,200
security text and if you have a overflow

00:18:02,180 --> 00:18:09,770
or any format string attack over there

00:18:05,200 --> 00:18:12,230
it's just maybe the application just

00:18:09,770 --> 00:18:15,040
won't crash and you you will get an

00:18:12,230 --> 00:18:15,040
overflow over there

00:18:17,239 --> 00:18:22,919
also it is important while compiling the

00:18:20,669 --> 00:18:24,840
code you use the d45 source with the

00:18:22,919 --> 00:18:27,539
optimization flag because if you don't

00:18:24,840 --> 00:18:32,159
use the optimization then also just 45

00:18:27,539 --> 00:18:36,389
so it doesn't work but in our rpm builds

00:18:32,159 --> 00:18:45,989
we make sure that that's enabled by

00:18:36,389 --> 00:18:48,019
default so in terms of the like buffer

00:18:45,989 --> 00:18:50,639
overflow

00:18:48,019 --> 00:18:52,830
it's the classic buffer overflow that

00:18:50,639 --> 00:18:56,789
happens all the time in the code if you

00:18:52,830 --> 00:18:59,999
can see there is a argument that goes

00:18:56,789 --> 00:19:02,429
directly into this plaintiff and you can

00:18:59,999 --> 00:19:04,619
you can actually see a lot of places in

00:19:02,429 --> 00:19:08,039
the code where the user data directly

00:19:04,619 --> 00:19:10,289
gets into the these functions so these

00:19:08,039 --> 00:19:12,479
are one of the places where where you

00:19:10,289 --> 00:19:15,839
should look at like from where the

00:19:12,479 --> 00:19:19,609
source is coming and from like what is

00:19:15,839 --> 00:19:19,609
the source and where it is writing to

00:19:23,809 --> 00:19:29,219
these are also some of the examples that

00:19:26,339 --> 00:19:33,889
you will find in it find in the code for

00:19:29,219 --> 00:19:36,389
example sometimes they will present

00:19:33,889 --> 00:19:39,239
things about the null termination of the

00:19:36,389 --> 00:19:43,259
of the string so you get enough off one

00:19:39,239 --> 00:19:47,999
off by one by terror and below is the

00:19:43,259 --> 00:19:50,429
code how you fix it they you calculate

00:19:47,999 --> 00:19:52,519
the string length is not greater than

00:19:50,429 --> 00:19:58,529
the buffer minus one that is for the

00:19:52,519 --> 00:20:02,129
like you you calculate the null string

00:19:58,529 --> 00:20:04,469
at the end and that's how you return it

00:20:02,129 --> 00:20:06,690
but basically those are those are places

00:20:04,469 --> 00:20:09,589
where like you can look in the code for

00:20:06,690 --> 00:20:09,589
the overflows

00:20:14,460 --> 00:20:19,539
so the next I have the data-type floss

00:20:17,740 --> 00:20:21,909
these are different on the different

00:20:19,539 --> 00:20:25,870
architectures you are working on for

00:20:21,909 --> 00:20:27,669
example the x86 or arm or any any other

00:20:25,870 --> 00:20:30,070
architecture it would be different

00:20:27,669 --> 00:20:32,610
because the datatype handling or the

00:20:30,070 --> 00:20:36,070
size of the datatype would be different

00:20:32,610 --> 00:20:38,110
so integer overflows are associated

00:20:36,070 --> 00:20:42,100
whether it's like signed and unsigned

00:20:38,110 --> 00:20:44,159
data types which are like major problems

00:20:42,100 --> 00:20:49,240
in that you will see a lot of places

00:20:44,159 --> 00:20:55,809
developer uses iced tea iced tea so size

00:20:49,240 --> 00:21:02,679
tea is like the unsigned data type and s

00:20:55,809 --> 00:21:04,330
iced tea is the sign data type now how

00:21:02,679 --> 00:21:07,059
many people know here like how the

00:21:04,330 --> 00:21:13,899
signed and unsigned is there anyone who

00:21:07,059 --> 00:21:15,370
doesn't know that okay like how what is

00:21:13,899 --> 00:21:18,309
the difference between the signed and

00:21:15,370 --> 00:21:27,639
unsigned data type like everyone knows

00:21:18,309 --> 00:21:30,519
here right yeah so there are a lot of

00:21:27,639 --> 00:21:35,919
places like the si si signed data type

00:21:30,519 --> 00:21:37,269
is not said to be used but there there

00:21:35,919 --> 00:21:39,429
are actually some of the places where

00:21:37,269 --> 00:21:43,630
where you will find like developers

00:21:39,429 --> 00:21:48,370
through this common mistake and you can

00:21:43,630 --> 00:21:53,139
see in this code to use this iced tea

00:21:48,370 --> 00:21:55,470
and then this is the user data and the

00:21:53,139 --> 00:21:59,590
Len that goes into some shake and that

00:21:55,470 --> 00:22:03,909
returns -1 now that goes into the size

00:21:59,590 --> 00:22:08,470
and what happens is its returning minus

00:22:03,909 --> 00:22:10,899
1 but this is the unsigned type so it's

00:22:08,470 --> 00:22:13,389
going to wrap and this there will be

00:22:10,899 --> 00:22:18,120
very large value that that's going to be

00:22:13,389 --> 00:22:22,529
stored in the size and this statement

00:22:18,120 --> 00:22:24,270
will always be false so it won't hit

00:22:22,529 --> 00:22:27,320
here

00:22:24,270 --> 00:22:31,940
though there was a security check done

00:22:27,320 --> 00:22:36,390
heterodyne - one or neither but here

00:22:31,940 --> 00:22:38,940
it's never going to check because it

00:22:36,390 --> 00:22:42,240
just wrapped and now the size size has

00:22:38,940 --> 00:22:45,590
the positive value and it will escape

00:22:42,240 --> 00:22:57,150
this cord and then you have like boom

00:22:45,590 --> 00:23:00,480
four gigs of memory allocation so that's

00:22:57,150 --> 00:23:05,760
how like it's two's complement how how

00:23:00,480 --> 00:23:09,990
things work that's 32 bit sign it's like

00:23:05,760 --> 00:23:21,000
the first bit is used for to store like

00:23:09,990 --> 00:23:24,270
negative values or world Bart so this is

00:23:21,000 --> 00:23:27,990
this is the common problem like you use

00:23:24,270 --> 00:23:30,690
the unsigned value and the maximum value

00:23:27,990 --> 00:23:34,740
it can store is like 255 and in some

00:23:30,690 --> 00:23:38,370
logic it adds one to it now it will it

00:23:34,740 --> 00:23:41,610
will be like zero now the overflow built

00:23:38,370 --> 00:23:44,850
in the processor is set but it's checked

00:23:41,610 --> 00:23:51,090
nowhere so it's it's pretty much common

00:23:44,850 --> 00:23:57,120
mistake in the code that happens the

00:23:51,090 --> 00:24:02,780
same applies to design variable also if

00:23:57,120 --> 00:24:02,780
you add one to it it becomes minus 128

00:24:12,500 --> 00:24:19,270
this is also bad cord can anyone tell me

00:24:15,590 --> 00:24:19,270
like what's the problem in the school

00:24:39,240 --> 00:24:51,490
yep you get the muffler

00:24:42,760 --> 00:24:54,490
so this where they give it no it's yeah

00:24:51,490 --> 00:24:54,490
so

00:25:01,299 --> 00:25:09,929
there are some more Bart Gordon anyone

00:25:11,009 --> 00:25:18,940
and this one was like to me yeah I can

00:25:15,639 --> 00:25:22,259
actually show you this is from one of

00:25:18,940 --> 00:25:22,259
the series that we have

00:25:51,950 --> 00:25:56,659
Title II here what the problem is

00:26:00,380 --> 00:26:08,810
it's ah I don't know why it's so bad but

00:26:05,910 --> 00:26:08,810
okay

00:26:49,380 --> 00:26:56,800
so basically what it's expecting it's a

00:26:53,230 --> 00:26:59,680
for the function is expecting the four

00:26:56,800 --> 00:27:04,960
digits but what happens is as soon as

00:26:59,680 --> 00:27:10,500
the PID goes up one there is an overflow

00:27:04,960 --> 00:27:10,500
and that becomes this FFF over here

00:27:11,190 --> 00:27:22,990
after this operation it becomes 1 0 0 0

00:27:14,650 --> 00:27:26,100
0 and it overflows so like these these

00:27:22,990 --> 00:27:29,580
are pretty common errors that you can

00:27:26,100 --> 00:27:29,580
look in the code

00:27:38,149 --> 00:27:47,469
now a lot of places this is actually

00:27:43,249 --> 00:27:53,359
from the Python court bird yeah a lot of

00:27:47,469 --> 00:27:56,059
Python a lot of places in C C++ programs

00:27:53,359 --> 00:27:58,849
and maybe it would be relevant to any

00:27:56,059 --> 00:28:03,649
other program also that they are writing

00:27:58,849 --> 00:28:08,419
to the temp directory now if there is a

00:28:03,649 --> 00:28:10,999
demon who daemon which is working and

00:28:08,419 --> 00:28:13,879
using the temp directory and attacker

00:28:10,999 --> 00:28:16,279
has access to it they can actually use

00:28:13,879 --> 00:28:19,279
the they can just swap it with the

00:28:16,279 --> 00:28:22,669
malicious code over there and whenever

00:28:19,279 --> 00:28:26,799
the daemon again reads and it's going to

00:28:22,669 --> 00:28:29,569
execute and you get pretty much a route

00:28:26,799 --> 00:28:31,699
if it's them and it's working it's on

00:28:29,569 --> 00:28:36,559
the road privileges you will get it the

00:28:31,699 --> 00:28:40,429
other thing is sometimes it doesn't

00:28:36,559 --> 00:28:44,259
depend mostly on the source code but how

00:28:40,429 --> 00:28:49,209
a test shipped to the customers because

00:28:44,259 --> 00:28:53,299
for example when you create rpms or just

00:28:49,209 --> 00:28:56,329
the mechanism like to deliver these

00:28:53,299 --> 00:29:02,089
updates the customer it also depends the

00:28:56,329 --> 00:29:03,739
way you have packaged it so for example

00:29:02,089 --> 00:29:07,579
if there is a post install script which

00:29:03,739 --> 00:29:09,529
is using this that's bad it also happens

00:29:07,579 --> 00:29:10,969
in the spec file so you just lead the

00:29:09,529 --> 00:29:13,999
boundaries of the source code as well

00:29:10,969 --> 00:29:18,139
auu the code or later as in like has to

00:29:13,999 --> 00:29:19,959
take care about things how this is going

00:29:18,139 --> 00:29:25,069
to be delivered to the customer as well

00:29:19,959 --> 00:29:29,179
later because suppose if this is an RPM

00:29:25,069 --> 00:29:31,729
and you are like internal user you can

00:29:29,179 --> 00:29:37,599
just wait and you'll know when your

00:29:31,729 --> 00:29:43,219
administer it the RPM you can just

00:29:37,599 --> 00:29:46,669
change this you can add sudo your name

00:29:43,219 --> 00:29:48,919
and RPN uses the root privileges to

00:29:46,669 --> 00:29:51,319
install on the system so whenever RPM is

00:29:48,919 --> 00:29:52,929
going to install and do the post and

00:29:51,319 --> 00:30:05,360
soul scrap

00:29:52,929 --> 00:30:08,240
done about the tools source code browser

00:30:05,360 --> 00:30:10,399
yeah everyone uses it I use see scope

00:30:08,240 --> 00:30:14,080
just to see some of the functions how

00:30:10,399 --> 00:30:14,080
they are getting called to one flow

00:30:15,159 --> 00:30:21,200
because if you are running some of the

00:30:17,450 --> 00:30:22,700
static analyzers they will say this is

00:30:21,200 --> 00:30:25,100
the function that even you need to look

00:30:22,700 --> 00:30:27,409
at but then you go into the function and

00:30:25,100 --> 00:30:29,419
you see like how the values are coming

00:30:27,409 --> 00:30:33,470
from the other function to this function

00:30:29,419 --> 00:30:36,409
or how the input is coming to this

00:30:33,470 --> 00:30:39,980
function so I just you see like C scope

00:30:36,409 --> 00:30:42,049
or some other tools to see how the

00:30:39,980 --> 00:30:43,340
functions are getting cold front from

00:30:42,049 --> 00:30:46,389
the start of the main function

00:30:43,340 --> 00:30:49,190
so you actually backtrack you have a

00:30:46,389 --> 00:30:53,590
place that static analyzer showed you

00:30:49,190 --> 00:30:56,600
then you backtrack to to the place and

00:30:53,590 --> 00:31:02,809
see how things called manipulated in

00:30:56,600 --> 00:31:05,720
between or if they can be so some of the

00:31:02,809 --> 00:31:08,570
first things are like you can use cpp

00:31:05,720 --> 00:31:15,760
lint overflow finder or cpp check CBB

00:31:08,570 --> 00:31:23,269
check is good it it shows quite a lot of

00:31:15,760 --> 00:31:26,960
problems and there is this post memory

00:31:23,269 --> 00:31:30,230
corruption memory analyzer it's on the

00:31:26,960 --> 00:31:35,029
github if anyone wants I will share the

00:31:30,230 --> 00:31:36,679
link he can pretty much run the program

00:31:35,029 --> 00:31:38,240
and attach the PID to this

00:31:36,679 --> 00:31:39,789
so whenever the program is going to

00:31:38,240 --> 00:31:43,460
crash it is going to analyze it

00:31:39,789 --> 00:31:46,429
automatically and will tell you most of

00:31:43,460 --> 00:31:48,289
the areas or the regions where things

00:31:46,429 --> 00:31:51,250
were executable on the stack or the heap

00:31:48,289 --> 00:31:51,250
or wherever

00:31:53,230 --> 00:32:00,559
the the part of like the sanitizer so

00:31:58,520 --> 00:32:03,200
this is also important in terms of the

00:32:00,559 --> 00:32:05,860
chord audit because develop I like the

00:32:03,200 --> 00:32:09,590
co-director can spend a lot of time

00:32:05,860 --> 00:32:12,620
reading the source corn and it's good it

00:32:09,590 --> 00:32:16,070
gets frustrating not to find anything

00:32:12,620 --> 00:32:19,220
over there so what I usually do is I

00:32:16,070 --> 00:32:23,740
just compile the source code with the

00:32:19,220 --> 00:32:26,510
address sanitizers and it does run them

00:32:23,740 --> 00:32:30,530
and whenever there is some corruption or

00:32:26,510 --> 00:32:32,900
anything it it it just tells where

00:32:30,530 --> 00:32:36,320
exactly the corruption happened and you

00:32:32,900 --> 00:32:38,000
can just go back and fire up your source

00:32:36,320 --> 00:32:42,530
browser and then you can look at the

00:32:38,000 --> 00:32:45,320
code where it happened so it's for name

00:32:42,530 --> 00:32:55,400
like code reading is not only like one

00:32:45,320 --> 00:32:57,920
way it's from the other way as well and

00:32:55,400 --> 00:32:59,600
then therefore just but that that is

00:32:57,920 --> 00:33:02,809
like pretty much the pen testing that

00:32:59,600 --> 00:33:06,850
people do but yes as a code or literacy

00:33:02,809 --> 00:33:10,100
you can do that it it's good it helps

00:33:06,850 --> 00:33:13,660
you track down the places which which

00:33:10,100 --> 00:33:13,660
might have been left in the code audit

00:33:14,140 --> 00:33:24,710
so for the sanitizers there is this Lib

00:33:22,400 --> 00:33:26,990
ace on if you are using fedora you can

00:33:24,710 --> 00:33:29,900
just install the basin and it works with

00:33:26,990 --> 00:33:33,170
the GCC you can just compile it with the

00:33:29,900 --> 00:33:36,650
F sanitized equal to address flag and it

00:33:33,170 --> 00:33:39,650
will say that so address sanitizer can

00:33:36,650 --> 00:33:43,100
pretty much find these use after free

00:33:39,650 --> 00:33:47,809
double free buffer overflows and such

00:33:43,100 --> 00:33:49,490
type of flows and there there is another

00:33:47,809 --> 00:33:54,230
library in the fedora called lib tease

00:33:49,490 --> 00:33:59,500
and you can just put flag F sanitized -

00:33:54,230 --> 00:34:02,560
- sanitized equal to thread and then

00:33:59,500 --> 00:34:06,340
and the thread analyzer will go into the

00:34:02,560 --> 00:34:07,830
picture and it it takes for the race

00:34:06,340 --> 00:34:12,760
condition under deadlocks

00:34:07,830 --> 00:34:14,500
so these are good aboard aims and I

00:34:12,760 --> 00:34:18,639
don't think so there is a package

00:34:14,500 --> 00:34:21,159
available in fedora and so the strikes

00:34:18,639 --> 00:34:23,790
were done in any uninitialized memory

00:34:21,159 --> 00:34:23,790
spaces

00:34:28,810 --> 00:34:36,159
it's also as a court order you like via

00:34:33,070 --> 00:34:39,909
CBS s 2 in the product security also at

00:34:36,159 --> 00:34:43,419
the moment for analysis of the flaws but

00:34:39,909 --> 00:34:46,120
as a cord cord order you can you can use

00:34:43,419 --> 00:34:48,460
these things to actually identify the

00:34:46,120 --> 00:34:55,840
impact of the vulnerability or you have

00:34:48,460 --> 00:35:01,090
found like X X X s vector it's how you

00:34:55,840 --> 00:35:04,180
are able to get into the program it's

00:35:01,090 --> 00:35:06,100
based it's a local it's a it's on the

00:35:04,180 --> 00:35:10,150
local machine or the adjacent network

00:35:06,100 --> 00:35:12,670
like on the VPN or the intranet or it's

00:35:10,150 --> 00:35:16,450
some kind of a demon that if you are

00:35:12,670 --> 00:35:20,680
able to access through network so it

00:35:16,450 --> 00:35:25,750
just use these values and there is a CBS

00:35:20,680 --> 00:35:32,730
s 2 calculator which will show you the

00:35:25,750 --> 00:35:36,720
impact of that so this is pretty much

00:35:32,730 --> 00:35:36,720
anyone has any questions

00:35:50,519 --> 00:35:55,499
yeah

00:35:51,819 --> 00:35:55,499
so yes

00:36:14,370 --> 00:36:22,620
I could be like I have not dealt with

00:36:18,240 --> 00:36:25,380
most of the developers like that just we

00:36:22,620 --> 00:36:29,520
say like this is the flaw that's right

00:36:25,380 --> 00:36:32,370
or nothing like that but yes the same

00:36:29,520 --> 00:36:34,980
thing is if you see the bill dogs of any

00:36:32,370 --> 00:36:37,830
project the compiler would be able to

00:36:34,980 --> 00:36:40,350
show that but the most important thing

00:36:37,830 --> 00:36:43,440
is if these are built on a system where

00:36:40,350 --> 00:37:02,600
no one is looking how its building it's

00:36:43,440 --> 00:37:02,600
going to mess it yeah yes

00:37:14,500 --> 00:37:20,990
yeah ah so the late some of the things I

00:37:17,930 --> 00:37:25,970
sort do some of the like the classic

00:37:20,990 --> 00:37:28,420
things or the functions whatever so when

00:37:25,970 --> 00:37:31,910
we say don't use banned API developer

00:37:28,420 --> 00:37:36,050
then developer can actually write his

00:37:31,910 --> 00:37:38,300
own band API at some point like not to

00:37:36,050 --> 00:37:43,790
use those functions and do something

00:37:38,300 --> 00:37:47,540
like that and then compiler won't show

00:37:43,790 --> 00:37:50,360
any warnings like that like for example

00:37:47,540 --> 00:37:51,770
the string copy or any which were

00:37:50,360 --> 00:37:55,280
like-minded peers

00:37:51,770 --> 00:37:57,830
a lot of people might write their own C

00:37:55,280 --> 00:38:02,990
code just to do that which is like more

00:37:57,830 --> 00:38:04,970
bad now the job of the auditor has

00:38:02,990 --> 00:38:07,660
become more difficult because now tools

00:38:04,970 --> 00:38:07,660
are not showing that

00:38:15,940 --> 00:38:48,270
any more questions I usually spend my

00:38:28,059 --> 00:38:50,950
Fridays on it because yeah

00:38:48,270 --> 00:38:56,049
Tiger you should know when to leave when

00:38:50,950 --> 00:39:01,440
to give up on on something and then

00:38:56,049 --> 00:39:04,210
maybe it's not your day in front of the

00:39:01,440 --> 00:39:08,010
the cold that you are auditing maybe the

00:39:04,210 --> 00:39:11,049
next day you might come huh

00:39:08,010 --> 00:39:14,109
yeah because it's really frustrating you

00:39:11,049 --> 00:39:17,890
can it's not something you know

00:39:14,109 --> 00:39:19,809
beforehand like your manager or anyone

00:39:17,890 --> 00:39:21,609
will not come here and say you have to

00:39:19,809 --> 00:39:26,289
find a hundred flaws in this for scored

00:39:21,609 --> 00:39:28,990
now find it maybe there is nothing maybe

00:39:26,289 --> 00:39:33,549
it can also skip the eyes of the auditor

00:39:28,990 --> 00:39:35,650
and that's why there is more uses of

00:39:33,549 --> 00:39:39,430
things like the address sanitizers and

00:39:35,650 --> 00:39:43,510
the things which missed the ordered but

00:39:39,430 --> 00:39:46,299
again then auditor can go back and see

00:39:43,510 --> 00:39:50,250
things like what were the problems and

00:39:46,299 --> 00:39:50,250
then go back and look at the code again

00:40:01,490 --> 00:40:12,380
like a lot of I guess I guess I don't

00:40:07,890 --> 00:40:16,020
know about the lord of RPM packages have

00:40:12,380 --> 00:40:20,750
they used Coverity but I'd I basically

00:40:16,020 --> 00:40:26,550
don't use Dartmouth for me

00:40:20,750 --> 00:40:29,100
yes static analyzers are good but there

00:40:26,550 --> 00:40:31,650
are a lot of false positives in the

00:40:29,100 --> 00:40:33,840
static analyzers and if it is going to

00:40:31,650 --> 00:40:36,180
give you like 4,000 places in a million

00:40:33,840 --> 00:40:41,070
lines of code to check it's completely

00:40:36,180 --> 00:40:45,390
not possible so the only way is like you

00:40:41,070 --> 00:40:47,340
run the application you poke it several

00:40:45,390 --> 00:40:49,530
ways you see where the crash was and

00:40:47,340 --> 00:40:52,830
then you try to match where the static

00:40:49,530 --> 00:40:57,690
analyzer said it was important and then

00:40:52,830 --> 00:41:00,270
you can see some link between those two

00:40:57,690 --> 00:41:06,990
places then you know exactly where to

00:41:00,270 --> 00:41:09,030
look at play in order thing you cannot

00:41:06,990 --> 00:41:11,010
start from the main function right ain't

00:41:09,030 --> 00:41:14,990
mean and then you start from where it is

00:41:11,010 --> 00:41:14,990
coming it's long long way

00:41:23,390 --> 00:41:31,530
hmm fathers I use very rarely very very

00:41:28,110 --> 00:41:35,010
rarely because fuzzing is completely

00:41:31,530 --> 00:41:37,350
different world and like Lords of

00:41:35,010 --> 00:41:42,180
fathers today if you go and see there

00:41:37,350 --> 00:41:45,720
are lots of others and yes it's bit

00:41:42,180 --> 00:41:49,680
difficult but I usually do the classic

00:41:45,720 --> 00:41:52,080
ways of exploiting I usually use my

00:41:49,680 --> 00:41:53,850
classic ways of exploiting that that

00:41:52,080 --> 00:41:57,890
used to be done before the fathers were

00:41:53,850 --> 00:42:01,050
there just send some crap into the

00:41:57,890 --> 00:42:05,340
system and see where it crashes but

00:42:01,050 --> 00:42:07,530
that's what was and does it for you like

00:42:05,340 --> 00:42:10,950
doing the permutation and combination of

00:42:07,530 --> 00:42:14,190
different type of things but yeah

00:42:10,950 --> 00:42:17,540
sometimes I'd it's bit difficult to use

00:42:14,190 --> 00:42:17,540
father and son projects

00:42:33,270 --> 00:42:52,000
yeah so for example I walk particularly

00:42:49,210 --> 00:42:53,770
in storage I look at the storage

00:42:52,000 --> 00:42:59,160
security for this F and the Gloucester

00:42:53,770 --> 00:43:03,040
and for me the important areas are there

00:42:59,160 --> 00:43:06,360
but there's like what's number of people

00:43:03,040 --> 00:43:08,910
working on like different products so

00:43:06,360 --> 00:43:13,660
they will have a different type of

00:43:08,910 --> 00:43:16,710
approaches to their own for me it's for

00:43:13,660 --> 00:43:16,710
further storage only

00:43:33,160 --> 00:43:46,630
but oh I guess no one wants this so

00:43:42,800 --> 00:43:46,630
mufflers are here we can take it

00:44:18,829 --> 00:44:24,290
yes it's because okay

00:45:37,960 --> 00:45:43,880
yeah sure sure sure

00:45:39,950 --> 00:45:44,359
I'm sorry I said you didn't mention by

00:45:43,880 --> 00:45:48,170
Brian

00:45:44,359 --> 00:46:02,320
so the ASN as sunny is like this similar

00:45:48,170 --> 00:46:02,320
maybe better sometimes it affects it

00:46:09,360 --> 00:46:16,440
it's compiling combined time

00:46:17,160 --> 00:46:21,180
you just compile it with the

00:46:39,410 --> 00:46:43,930
I hate them let's go so fight them

00:47:23,590 --> 00:47:27,850
I'm sorry it does give me this

00:48:45,350 --> 00:48:51,080
there was another way yeah thank you

00:48:48,780 --> 00:48:51,080
thank you

00:49:01,400 --> 00:49:14,310
you west you okay

00:49:08,970 --> 00:49:17,430
I will request for literature because I

00:49:14,310 --> 00:49:20,040
started to I was interested I started

00:49:17,430 --> 00:49:29,850
with some kind of very serious book and

00:49:20,040 --> 00:49:32,420
it was rising my name cedar is it okay

00:49:29,850 --> 00:49:32,420
it's funny

00:49:32,540 --> 00:49:43,010
alright okay so I will write it to you

00:49:39,860 --> 00:49:43,010

YouTube URL: https://www.youtube.com/watch?v=Ixfn6Gpgh5A


