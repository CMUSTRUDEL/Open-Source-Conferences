Title: Functional interpreters and you by Dave Gurnell
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6933-functional-interpreters-and-you.html
Captions: 
	00:00:04,610 --> 00:00:11,870
hi everyone hey doing everyone awake

00:00:09,110 --> 00:00:14,900
after the keynote ready to rock day -

00:00:11,870 --> 00:00:19,640
not too much alcohol and barbecue last

00:00:14,900 --> 00:00:21,230
night certainly my case hi everyone my

00:00:19,640 --> 00:00:23,840
name is Dave I work for these guys

00:00:21,230 --> 00:00:26,240
underscore and I'm here to talk about

00:00:23,840 --> 00:00:27,740
functional programming pattern a pattern

00:00:26,240 --> 00:00:31,040
which is really useful and ubiquitous

00:00:27,740 --> 00:00:32,719
and hopefully you will have all used it

00:00:31,040 --> 00:00:33,860
to some degree or you will all know that

00:00:32,719 --> 00:00:36,079
you've used it by the end of the talk

00:00:33,860 --> 00:00:38,540
and that's the interpreter pattern

00:00:36,079 --> 00:00:42,880
so before I start quick show hands who

00:00:38,540 --> 00:00:45,860
has used the free monads in their code

00:00:42,880 --> 00:00:49,910
okay great so some folks that's great

00:00:45,860 --> 00:00:53,060
baby 25% of people who has used tagless

00:00:49,910 --> 00:00:55,399
finally tagless final tagless okay about

00:00:53,060 --> 00:00:56,809
the same number about 25% okay so for

00:00:55,399 --> 00:00:59,510
you people you probably know everything

00:00:56,809 --> 00:01:00,680
that I'm about to talk about so bad luck

00:00:59,510 --> 00:01:03,770
sorry

00:01:00,680 --> 00:01:05,089
this talk is aimed at people who don't

00:01:03,770 --> 00:01:06,619
know anything about interpreters and

00:01:05,089 --> 00:01:10,280
want to go from from sort of zero

00:01:06,619 --> 00:01:11,900
upwards and will get to the point where

00:01:10,280 --> 00:01:13,970
we've justified what the free monad is

00:01:11,900 --> 00:01:15,320
and sort of why it exists so and the

00:01:13,970 --> 00:01:16,850
caveat some of this stuff is stuff that

00:01:15,320 --> 00:01:18,200
I've researched the first time for this

00:01:16,850 --> 00:01:19,940
talk so if I'm making the errors please

00:01:18,200 --> 00:01:22,670
do point them out in the in the

00:01:19,940 --> 00:01:25,040
questions at the end a one last question

00:01:22,670 --> 00:01:27,080
who's who's used an interpreter who's

00:01:25,040 --> 00:01:30,080
written an interpreter in their in their

00:01:27,080 --> 00:01:32,360
code okay so I would hope at least all

00:01:30,080 --> 00:01:34,430
the people who have who have put their

00:01:32,360 --> 00:01:35,570
hands up for free monad and finally tag

00:01:34,430 --> 00:01:38,270
let's also put their hands up there but

00:01:35,570 --> 00:01:40,970
it's about the same number okay so I'm

00:01:38,270 --> 00:01:42,350
sure you know we're all programmers we

00:01:40,970 --> 00:01:44,000
spend most of our time working in

00:01:42,350 --> 00:01:46,400
general-purpose programming languages

00:01:44,000 --> 00:01:47,930
like Scala and the great thing about

00:01:46,400 --> 00:01:50,030
general-purpose programming languages is

00:01:47,930 --> 00:01:51,290
you can do anything in them and the bad

00:01:50,030 --> 00:01:53,750
thing about general-purpose programming

00:01:51,290 --> 00:01:55,310
languages you can do anything in them

00:01:53,750 --> 00:01:57,290
and that makes it difficult to reason

00:01:55,310 --> 00:01:59,659
about your code so we spend our lives

00:01:57,290 --> 00:02:01,250
working building programs and by

00:01:59,659 --> 00:02:07,549
programs I mean things that computer

00:02:01,250 --> 00:02:10,009
result in in Scala and sometimes we get

00:02:07,549 --> 00:02:12,170
mired in in in implementation details

00:02:10,009 --> 00:02:13,819
and complexity and because our language

00:02:12,170 --> 00:02:16,220
is so general so the idea of the

00:02:13,819 --> 00:02:18,560
interpreter pattern is we shift from

00:02:16,220 --> 00:02:20,300
writing code in Scala to writing code

00:02:18,560 --> 00:02:22,220
some DSL we invented the most specific

00:02:20,300 --> 00:02:23,930
language something that's really good at

00:02:22,220 --> 00:02:24,890
solving one type of problem that we have

00:02:23,930 --> 00:02:27,290
to solve again and again in their

00:02:24,890 --> 00:02:28,880
application and then we shift to that

00:02:27,290 --> 00:02:31,880
and because it's higher level and it's

00:02:28,880 --> 00:02:33,950
simpler it's easier to code but the

00:02:31,880 --> 00:02:36,620
problem is you can't just run a DSL

00:02:33,950 --> 00:02:40,400
right doesn't have any it's just a

00:02:36,620 --> 00:02:42,019
high-level thing it doesn't have any any

00:02:40,400 --> 00:02:44,090
runtime environment so we have to

00:02:42,019 --> 00:02:47,239
provide that and we have to split our

00:02:44,090 --> 00:02:49,489
programs into the source split our code

00:02:47,239 --> 00:02:51,410
base into programs written in the DSL

00:02:49,489 --> 00:02:54,920
and interpret and an interpreter to run

00:02:51,410 --> 00:02:57,010
the DSL so if we perform this split then

00:02:54,920 --> 00:02:59,690
the program's we're writing

00:02:57,010 --> 00:03:01,459
describe a computation we want to run

00:02:59,690 --> 00:03:03,319
they don't on their own do anything

00:03:01,459 --> 00:03:05,330
they're just a sort of a structure or a

00:03:03,319 --> 00:03:06,860
set of mythical z' that sit there and

00:03:05,330 --> 00:03:08,959
say these are some steps I wish to

00:03:06,860 --> 00:03:10,489
perform and then the interpreter has all

00:03:08,959 --> 00:03:12,530
the low level implementation details to

00:03:10,489 --> 00:03:15,920
implement those steps so the purpose of

00:03:12,530 --> 00:03:17,870
this talk is to justify why this is a

00:03:15,920 --> 00:03:19,040
useful pattern and show you some

00:03:17,870 --> 00:03:20,900
different ways you can use it in your

00:03:19,040 --> 00:03:24,109
code base and talk about free and we'll

00:03:20,900 --> 00:03:26,989
talk about finally tactless so the big

00:03:24,109 --> 00:03:29,959
thing that we get ah I see it didn't

00:03:26,989 --> 00:03:34,010
advance when I went there okay I've got

00:03:29,959 --> 00:03:36,049
the old failing failing clicker problem

00:03:34,010 --> 00:03:37,819
okay so the big reason why we do this by

00:03:36,049 --> 00:03:40,549
the way is that it gives us reusability

00:03:37,819 --> 00:03:42,140
and modularity so from the interpreters

00:03:40,549 --> 00:03:44,239
point of view we spend all this time

00:03:42,140 --> 00:03:46,220
solving low-level technical issues in

00:03:44,239 --> 00:03:48,019
our interpreter and then that gets us

00:03:46,220 --> 00:03:49,549
gives us the ability to reuse it again

00:03:48,019 --> 00:03:52,040
and again with programs so all these

00:03:49,549 --> 00:03:53,810
programs in our DSL easy to write nice

00:03:52,040 --> 00:03:55,280
and high level and we get to reuse that

00:03:53,810 --> 00:03:56,720
time we've invested in that interpreter

00:03:55,280 --> 00:03:59,090
so that's one really good bit of reuse

00:03:56,720 --> 00:04:01,069
of modularity we get from the

00:03:59,090 --> 00:04:03,139
programmers point of view the other cool

00:04:01,069 --> 00:04:06,350
thing is that we can write multiple

00:04:03,139 --> 00:04:07,639
interpreters to interpret a program why

00:04:06,350 --> 00:04:10,010
would we do that well we can do

00:04:07,639 --> 00:04:11,329
different things with them so we might

00:04:10,010 --> 00:04:13,130
just have a normal interpreter which

00:04:11,329 --> 00:04:15,889
runs the code we might pretty print it

00:04:13,130 --> 00:04:18,350
we might have at the equivalent of an

00:04:15,889 --> 00:04:20,479
SQL explained so under school recently

00:04:18,350 --> 00:04:21,560
in fact that flat map we had two guys

00:04:20,479 --> 00:04:22,669
from under school gave a talk about I

00:04:21,560 --> 00:04:24,889
think we'll droid speak

00:04:22,669 --> 00:04:26,450
I'll lied all the details if I see a

00:04:24,889 --> 00:04:28,580
choice because a thing which can tell

00:04:26,450 --> 00:04:29,990
you why it made a decision as well as

00:04:28,580 --> 00:04:32,400
the decision it made which is really

00:04:29,990 --> 00:04:35,460
good for analyzing sort of use cases

00:04:32,400 --> 00:04:37,440
in business and because we can build

00:04:35,460 --> 00:04:39,150
multiple interpreters we can also do a

00:04:37,440 --> 00:04:42,449
big thing which is abstract across

00:04:39,150 --> 00:04:45,240
effects so we can have an asynchronous

00:04:42,449 --> 00:04:46,770
interpreter or an interpreter that fails

00:04:45,240 --> 00:04:49,650
gracefully in a number of different ways

00:04:46,770 --> 00:04:51,960
and that with that we can reuse the same

00:04:49,650 --> 00:04:54,120
codebase maybe to do streaming data or

00:04:51,960 --> 00:04:56,070
big data analytics have the same

00:04:54,120 --> 00:04:57,960
programs different interpreters or we

00:04:56,070 --> 00:05:02,389
can run code in production and in test

00:04:57,960 --> 00:05:04,650
one final use case we can write

00:05:02,389 --> 00:05:07,740
interpreters but output other programs

00:05:04,650 --> 00:05:10,979
and these are called compilers okay or

00:05:07,740 --> 00:05:12,780
transpilers if you're hipster so yes so

00:05:10,979 --> 00:05:14,940
if we have a program we can maybe

00:05:12,780 --> 00:05:18,060
rearrange things and optimize some steps

00:05:14,940 --> 00:05:20,910
so things like axel is library which

00:05:18,060 --> 00:05:22,110
will optimize calls to micro services to

00:05:20,910 --> 00:05:26,400
reduce the number of requests you're

00:05:22,110 --> 00:05:27,900
making and batch them together so a

00:05:26,400 --> 00:05:29,610
bunch of use cases I'm going to

00:05:27,900 --> 00:05:31,410
concentrate mainly on the first three

00:05:29,610 --> 00:05:33,930
here because this inspects and rewrite

00:05:31,410 --> 00:05:36,500
programs one the compiler one it turns

00:05:33,930 --> 00:05:39,240
out that some we have to be quite

00:05:36,500 --> 00:05:41,160
specific about the way we build a DSL

00:05:39,240 --> 00:05:42,660
to allow us to do that and I'll show you

00:05:41,160 --> 00:05:44,270
some cases where we start to move into

00:05:42,660 --> 00:05:46,710
territory where we can't do that anymore

00:05:44,270 --> 00:05:48,750
but we're sort of looking at these for

00:05:46,710 --> 00:05:50,130
use cases so now what I want to do is I

00:05:48,750 --> 00:05:52,500
want to talk to you about ways you can

00:05:50,130 --> 00:05:54,450
produce all this stuff and there are

00:05:52,500 --> 00:05:56,820
really two big approaches to

00:05:54,450 --> 00:06:00,180
interpreters there are these things

00:05:56,820 --> 00:06:02,070
called rarified Oh approaches to dsls

00:06:00,180 --> 00:06:03,930
there are these things called rarefied

00:06:02,070 --> 00:06:06,690
dear cells which is basically building a

00:06:03,930 --> 00:06:08,400
data structure to represent verification

00:06:06,690 --> 00:06:09,840
is turning code into data so we build a

00:06:08,400 --> 00:06:11,940
data structure representing a program we

00:06:09,840 --> 00:06:13,590
want to run and then we pass that to

00:06:11,940 --> 00:06:16,080
interpreter and then there's a thing

00:06:13,590 --> 00:06:18,120
called church encoding which is more or

00:06:16,080 --> 00:06:20,070
less an equivalent way of doing things

00:06:18,120 --> 00:06:22,110
where we represent programs as sequences

00:06:20,070 --> 00:06:24,240
of method calls abstract method calls

00:06:22,110 --> 00:06:25,550
and I'll run through both of this we

00:06:24,240 --> 00:06:28,289
spend most of our time on verification

00:06:25,550 --> 00:06:30,120
and a little bit of time on church

00:06:28,289 --> 00:06:32,400
encoding and the reason I'm talking

00:06:30,120 --> 00:06:34,800
about those these two things is that the

00:06:32,400 --> 00:06:37,680
natural extent of verification is the

00:06:34,800 --> 00:06:40,550
free monads and all of that stuff other

00:06:37,680 --> 00:06:42,599
people talk about and then the the

00:06:40,550 --> 00:06:44,580
natural extent of Church encoding is

00:06:42,599 --> 00:06:47,900
this tagless final thing so they kind of

00:06:44,580 --> 00:06:47,900
fit very neatly into these two

00:06:48,310 --> 00:06:51,920
there's one other thing that I want you

00:06:50,660 --> 00:06:55,220
to consider as we're going through the

00:06:51,920 --> 00:06:56,420
talk and I won't this won't be a fool in

00:06:55,220 --> 00:06:58,610
the foreground in the talk but it'll be

00:06:56,420 --> 00:07:02,150
there in the background is that there's

00:06:58,610 --> 00:07:04,310
also an like a gradient of design of a

00:07:02,150 --> 00:07:06,710
DSL as to how standalone or how deeply

00:07:04,310 --> 00:07:08,300
embedded it is in the host language so

00:07:06,710 --> 00:07:11,900
we're building a DSL to run in Scala and

00:07:08,300 --> 00:07:13,370
we can use very little of Scala as part

00:07:11,900 --> 00:07:14,930
of our DSL or you can really lean

00:07:13,370 --> 00:07:16,820
heavily on Scala we can use variable

00:07:14,930 --> 00:07:18,740
definitions and types and implicit and

00:07:16,820 --> 00:07:20,990
all these things and so there is

00:07:18,740 --> 00:07:24,530
definitely a gradient here where the

00:07:20,990 --> 00:07:26,870
more deeply we embed our DSL in Scala

00:07:24,530 --> 00:07:29,810
more closely the semantics aligned with

00:07:26,870 --> 00:07:31,310
Scala the the the easier it is to write

00:07:29,810 --> 00:07:33,530
because we reuse things that are given

00:07:31,310 --> 00:07:35,750
to us in the language but then we have

00:07:33,530 --> 00:07:40,040
to make some sacrifices in terms of this

00:07:35,750 --> 00:07:42,440
inspect ability of programs okay so

00:07:40,040 --> 00:07:45,800
let's talk about some rarified in

00:07:42,440 --> 00:07:47,720
codings I want to start with a little

00:07:45,800 --> 00:07:51,860
example the hello world of interpreters

00:07:47,720 --> 00:07:54,680
is a calculator okay so we're going to

00:07:51,860 --> 00:07:56,900
try model that's pretty small okay

00:07:54,680 --> 00:07:59,150
everyone see that that's good because I

00:07:56,900 --> 00:08:00,380
can't change the font size we want to

00:07:59,150 --> 00:08:02,720
get a model addition and multiplication

00:08:00,380 --> 00:08:06,169
of integers really really basic stuff

00:08:02,720 --> 00:08:08,450
okay so if I wanted to model programs

00:08:06,169 --> 00:08:13,210
like this in Scala

00:08:08,450 --> 00:08:15,890
I would simply wrap them in a function

00:08:13,210 --> 00:08:17,510
so this is a program according to my

00:08:15,890 --> 00:08:18,770
definition it's a thing which is inert

00:08:17,510 --> 00:08:21,650
it doesn't actually do anything on its

00:08:18,770 --> 00:08:24,080
own right but it represents some intent

00:08:21,650 --> 00:08:27,110
some computation we want to run and then

00:08:24,080 --> 00:08:30,860
the way we run it is we interpret it or

00:08:27,110 --> 00:08:32,510
we call it okay so when we're talking

00:08:30,860 --> 00:08:33,950
about the interpreter pattern what we're

00:08:32,510 --> 00:08:35,510
actually talking about is building

00:08:33,950 --> 00:08:39,620
things like this program at the top and

00:08:35,510 --> 00:08:41,719
then some interpreters to run them

00:08:39,620 --> 00:08:45,500
so this eval method takes the function

00:08:41,719 --> 00:08:48,410
and somehow produces a result now a

00:08:45,500 --> 00:08:49,340
mental game for you have a quick think

00:08:48,410 --> 00:08:49,880
about how you didn't promote that

00:08:49,340 --> 00:08:53,270
function

00:08:49,880 --> 00:08:55,460
okay everyone got it okay you can

00:08:53,270 --> 00:08:56,630
implement eval now think about that all

00:08:55,460 --> 00:08:58,700
the different ways you can implement

00:08:56,630 --> 00:08:59,690
eval how much how much flexibility have

00:08:58,700 --> 00:09:01,670
you got in here

00:08:59,690 --> 00:09:03,200
put it another way how much can you tell

00:09:01,670 --> 00:09:05,660
about the programs that are being passed

00:09:03,200 --> 00:09:08,960
into eval when you go to implement it

00:09:05,660 --> 00:09:11,090
and you'll soon realize that's you know

00:09:08,960 --> 00:09:13,130
pretty pretty basic functions in scarlet

00:09:11,090 --> 00:09:15,050
are opaque we can't see inside them okay

00:09:13,130 --> 00:09:17,510
so we've really apart from a couple of

00:09:15,050 --> 00:09:19,430
trivial different ways of reimplemented

00:09:17,510 --> 00:09:22,250
eval we really only have one solution

00:09:19,430 --> 00:09:24,350
here we can we can call the function we

00:09:22,250 --> 00:09:26,420
can't see inside it we can't abstract

00:09:24,350 --> 00:09:28,790
over effects we can't provide meaningful

00:09:26,420 --> 00:09:30,050
different interpreters apart from maybe

00:09:28,790 --> 00:09:34,220
some exception handling or something

00:09:30,050 --> 00:09:35,510
like this and so this code is great fine

00:09:34,220 --> 00:09:37,130
for our use case but it doesn't give us

00:09:35,510 --> 00:09:39,470
any flexibility so let's rebuild that

00:09:37,130 --> 00:09:40,310
and give us some flexibility so what

00:09:39,470 --> 00:09:42,800
we're going to do is we're going to

00:09:40,310 --> 00:09:44,300
reify the language you're using to build

00:09:42,800 --> 00:09:46,370
these programs so the additions the

00:09:44,300 --> 00:09:48,440
multiplications and the integers and we

00:09:46,370 --> 00:09:51,290
can do that by building an algebraic

00:09:48,440 --> 00:09:52,730
data type so it's an expression type we

00:09:51,290 --> 00:09:54,890
either have a literal which wraps up an

00:09:52,730 --> 00:09:57,080
integer or we can add two expressions or

00:09:54,890 --> 00:09:59,450
we can multiply them okay it's pretty

00:09:57,080 --> 00:10:01,040
straightforward and then we can

00:09:59,450 --> 00:10:04,090
represent programs by nesting these

00:10:01,040 --> 00:10:06,350
things together so this is the same

00:10:04,090 --> 00:10:07,610
program I showed you earlier right it

00:10:06,350 --> 00:10:09,380
looks a little different because we

00:10:07,610 --> 00:10:11,150
we're not using him fixed operators and

00:10:09,380 --> 00:10:13,970
of course we can build nice syntax to

00:10:11,150 --> 00:10:18,320
make that make that all nice I refer you

00:10:13,970 --> 00:10:20,060
to other talks for that but then we

00:10:18,320 --> 00:10:21,710
can't just run this expression on its

00:10:20,060 --> 00:10:24,440
own right we need to build something to

00:10:21,710 --> 00:10:26,930
run it so we need our eval our

00:10:24,440 --> 00:10:29,000
interpreter eval function and because

00:10:26,930 --> 00:10:30,800
this thing is an algebraic data type at

00:10:29,000 --> 00:10:32,420
steal traits then the natural way to

00:10:30,800 --> 00:10:34,810
implement it is by pattern matching and

00:10:32,420 --> 00:10:37,250
we can just switch on what type of

00:10:34,810 --> 00:10:39,320
expression we've got and we either

00:10:37,250 --> 00:10:41,360
recursively call eval if we have sub

00:10:39,320 --> 00:10:43,330
expressions or we simply return the

00:10:41,360 --> 00:10:45,770
results if we've got a literal

00:10:43,330 --> 00:10:47,570
okay so this is obviously a lot more

00:10:45,770 --> 00:10:49,820
code than we had previously right we've

00:10:47,570 --> 00:10:53,060
gone from like a one-line function to I

00:10:49,820 --> 00:10:55,190
made 1012 lines of code but it's given

00:10:53,060 --> 00:10:57,890
us a bunch of flexibility already okay

00:10:55,190 --> 00:10:59,630
so this is my interpreter but we've

00:10:57,890 --> 00:11:01,790
already written I can also write an

00:10:59,630 --> 00:11:03,470
asynchronous interpreter so this one

00:11:01,790 --> 00:11:05,960
will whenever we have an add or a

00:11:03,470 --> 00:11:09,230
multiply it will spawn them off as new

00:11:05,960 --> 00:11:10,790
futures and then flatmap on the results

00:11:09,230 --> 00:11:13,200
to combine them together so we can run

00:11:10,790 --> 00:11:16,090
expressions in parallel

00:11:13,200 --> 00:11:18,430
here's one which will reconstruct our

00:11:16,090 --> 00:11:19,480
expressions as a string you might notice

00:11:18,430 --> 00:11:21,280
by the way that this thing doesn't

00:11:19,480 --> 00:11:22,480
correctly bracket the pluses and

00:11:21,280 --> 00:11:25,750
multiplies when they're nested together

00:11:22,480 --> 00:11:27,820
I'll leave that as an exercise exercise

00:11:25,750 --> 00:11:29,200
to you but the principle is there we can

00:11:27,820 --> 00:11:32,410
produce different kinds of results out

00:11:29,200 --> 00:11:34,690
of this and we can recompile our

00:11:32,410 --> 00:11:36,310
programs so this is the the analysis and

00:11:34,690 --> 00:11:38,640
recompilation step this is multiplying

00:11:36,310 --> 00:11:41,080
out the brackets so if I have a

00:11:38,640 --> 00:11:43,420
multiplication of two sons it will turn

00:11:41,080 --> 00:11:47,650
into a sum of several multiplications

00:11:43,420 --> 00:11:50,050
and the big take-home point here is that

00:11:47,650 --> 00:11:52,630
we simplified our language we've made it

00:11:50,050 --> 00:11:55,930
much more restrictive okay we can only

00:11:52,630 --> 00:11:57,160
represent pluses and multiplications you

00:11:55,930 --> 00:11:58,840
don't have all of scholar at our

00:11:57,160 --> 00:12:01,480
disposal and because we've done that

00:11:58,840 --> 00:12:03,880
we've enabled all of these operations in

00:12:01,480 --> 00:12:06,400
our interpreter and this is a very runer

00:12:03,880 --> 00:12:08,650
thing so did anyone see so this is it

00:12:06,400 --> 00:12:10,780
RunAs keynotes car exchange constraints

00:12:08,650 --> 00:12:12,160
liberate Liberty constraints it's all

00:12:10,780 --> 00:12:14,050
about this it's really really really

00:12:12,160 --> 00:12:20,350
great talk if you want to go check that

00:12:14,050 --> 00:12:21,910
out online later okay so that's that's a

00:12:20,350 --> 00:12:24,010
basic DSL but then I'm sure you're

00:12:21,910 --> 00:12:26,560
thinking well what about types ok can we

00:12:24,010 --> 00:12:28,480
do this stuff with types and there are a

00:12:26,560 --> 00:12:30,580
few different ways of representing types

00:12:28,480 --> 00:12:33,310
do cells in Scala so we'll go through

00:12:30,580 --> 00:12:35,290
them now the simplest one is what we

00:12:33,310 --> 00:12:37,420
call an untyped DSL so the idea here is

00:12:35,290 --> 00:12:41,170
we're pushing type checking into the

00:12:37,420 --> 00:12:43,210
interpreter so I'm going to switch the

00:12:41,170 --> 00:12:44,650
problem space a little bit I'm going to

00:12:43,210 --> 00:12:46,780
introduce boolean operators and

00:12:44,650 --> 00:12:49,450
comparisons so this means we can have

00:12:46,780 --> 00:12:53,410
type errors now if we write these things

00:12:49,450 --> 00:12:56,560
in the wrong order okay so okay let's

00:12:53,410 --> 00:12:58,930
verify it I've got a new expression type

00:12:56,560 --> 00:13:00,880
I'm using less than now LT and Anne's

00:12:58,930 --> 00:13:02,470
rather than add and multiply you can

00:13:00,880 --> 00:13:05,560
imagine having as many operators as you

00:13:02,470 --> 00:13:08,430
possibly want in this thing and with

00:13:05,560 --> 00:13:12,610
this expression type I can build

00:13:08,430 --> 00:13:15,160
programs just like I could before so 1

00:13:12,610 --> 00:13:19,450
is less than 2 and 3 is less than 4 but

00:13:15,160 --> 00:13:21,720
I can also produce invalid programs 1

00:13:19,450 --> 00:13:25,120
and 2 is less than 3 and 4 this is

00:13:21,720 --> 00:13:25,690
nonsensical and then we this is fine for

00:13:25,120 --> 00:13:28,600
our preps

00:13:25,690 --> 00:13:30,310
of our dsl and for our programs but it

00:13:28,600 --> 00:13:32,230
causes problems when we implement eval

00:13:30,310 --> 00:13:34,150
so now it's up to us as language

00:13:32,230 --> 00:13:36,250
designers to decide what to do right if

00:13:34,150 --> 00:13:38,530
we were JavaScript we would just say

00:13:36,250 --> 00:13:39,850
anything goes like any operator in

00:13:38,530 --> 00:13:42,190
JavaScript will just work on any two

00:13:39,850 --> 00:13:44,110
things and throw caution to the wind and

00:13:42,190 --> 00:13:46,090
you know if you hear many people talking

00:13:44,110 --> 00:13:47,620
about the idiosyncratic qualities of

00:13:46,090 --> 00:13:49,450
JavaScript that stem from this decision

00:13:47,620 --> 00:13:51,520
but it's trying to avoid runtime errors

00:13:49,450 --> 00:13:53,140
but a Scala programmers were probably a

00:13:51,520 --> 00:13:54,190
bit more principled so we have to deal

00:13:53,140 --> 00:13:57,070
with a couple of problems in this

00:13:54,190 --> 00:13:58,870
interpreter so one is we got an

00:13:57,070 --> 00:14:00,640
expression what's it going to evaluate

00:13:58,870 --> 00:14:04,090
to a boolean or an integer we need to

00:14:00,640 --> 00:14:06,370
handle that somehow and another is well

00:14:04,090 --> 00:14:09,010
okay well I might be given an expression

00:14:06,370 --> 00:14:11,320
that has type errors in it how am I

00:14:09,010 --> 00:14:13,230
going to handle those type errors and

00:14:11,320 --> 00:14:16,810
then expanding things out a little bit

00:14:13,230 --> 00:14:18,160
if I'm evaluating an expression and I

00:14:16,810 --> 00:14:19,890
have a sub expression that's not the

00:14:18,160 --> 00:14:22,570
right type how do I deal with that

00:14:19,890 --> 00:14:25,150
okay so I'm sure many of you are

00:14:22,570 --> 00:14:28,300
screaming at me to use something here

00:14:25,150 --> 00:14:29,800
give me call call out what am I gonna

00:14:28,300 --> 00:14:35,170
what's my return type going to look like

00:14:29,800 --> 00:14:35,590
on this did I hear an either hands up

00:14:35,170 --> 00:14:37,600
for either

00:14:35,590 --> 00:14:39,040
ah good excellent Neville is paying

00:14:37,600 --> 00:14:41,110
attention so we can we can deal with

00:14:39,040 --> 00:14:42,610
these errors here by having an either we

00:14:41,110 --> 00:14:46,360
just have some arrow type whatever so we

00:14:42,610 --> 00:14:47,860
can fail or we can succeed if we can

00:14:46,360 --> 00:14:49,810
deal with this problem of like boolean's

00:14:47,860 --> 00:14:51,670
or integers maybe by adding in an

00:14:49,810 --> 00:14:53,050
algebraic data type to represent the

00:14:51,670 --> 00:14:57,340
types we're going to compute either an

00:14:53,050 --> 00:14:59,590
integer err or a boolean and then when

00:14:57,340 --> 00:15:01,240
we're dealing with the sub expressions

00:14:59,590 --> 00:15:02,800
here we're going to have to deal with

00:15:01,240 --> 00:15:04,090
these Ivor's so I've put some helper

00:15:02,800 --> 00:15:06,670
methods in here but I haven't introduced

00:15:04,090 --> 00:15:08,020
in the code they would call eval try to

00:15:06,670 --> 00:15:10,660
pass the thing as an interests or a

00:15:08,020 --> 00:15:14,350
boolean and fail or succeed right okay

00:15:10,660 --> 00:15:17,650
so what we've done here is we have we

00:15:14,350 --> 00:15:19,450
have a fairly high mismatch of semantics

00:15:17,650 --> 00:15:21,400
between our dsl and scarlett dsl as on

00:15:19,450 --> 00:15:23,020
type scara's strongly typed and because

00:15:21,400 --> 00:15:25,330
we've got that mismatch we have to do

00:15:23,020 --> 00:15:28,780
all this work our interpreter becomes

00:15:25,330 --> 00:15:30,250
more complicated okay so and what's more

00:15:28,780 --> 00:15:33,400
we can have programs that are just

00:15:30,250 --> 00:15:35,710
invalid and will never work so there's a

00:15:33,400 --> 00:15:37,300
sensible question is can we can we make

00:15:35,710 --> 00:15:38,830
this simpler can we make it more

00:15:37,300 --> 00:15:39,400
reliable and of course the answer is to

00:15:38,830 --> 00:15:43,240
add types

00:15:39,400 --> 00:15:44,890
to our DSL so let's do that

00:15:43,240 --> 00:15:47,050
we stopped their expression that we had

00:15:44,890 --> 00:15:48,940
before and I'm just going to type every

00:15:47,050 --> 00:15:51,760
every term in this expression language

00:15:48,940 --> 00:15:53,770
so an expression yields a result of type

00:15:51,760 --> 00:15:55,960
a and we have a literal which wraps up

00:15:53,770 --> 00:15:57,520
any value of type a and less then we'll

00:15:55,960 --> 00:16:01,030
wrap up two expressions of an integer

00:15:57,520 --> 00:16:04,480
and yield rebellion and and we'll

00:16:01,030 --> 00:16:07,270
combine two boolean's into a boolean so

00:16:04,480 --> 00:16:10,390
just by doing this we get a whole bunch

00:16:07,270 --> 00:16:12,150
for free we can still write exactly the

00:16:10,390 --> 00:16:15,670
same code to represent our programs the

00:16:12,150 --> 00:16:17,830
Skyler compiler will will check the the

00:16:15,670 --> 00:16:20,080
result types and how they match together

00:16:17,830 --> 00:16:22,780
on less than an and so it will say this

00:16:20,080 --> 00:16:24,400
is a compiler error if I try to put in a

00:16:22,780 --> 00:16:25,600
literal which is an integer expression

00:16:24,400 --> 00:16:27,250
inside the hand which it expects a

00:16:25,600 --> 00:16:31,000
boolean expression so that's for free

00:16:27,250 --> 00:16:33,400
and our interpreter now is back to being

00:16:31,000 --> 00:16:35,980
really trivial right we've got type

00:16:33,400 --> 00:16:37,570
safety in our language and because we're

00:16:35,980 --> 00:16:39,880
using the same type system that Skylar's

00:16:37,570 --> 00:16:41,590
using there's no mismatch here the the

00:16:39,880 --> 00:16:42,820
scarlet compiler can easily make sure

00:16:41,590 --> 00:16:45,460
we're doing all the right things in our

00:16:42,820 --> 00:16:48,580
eval and you know if we can do all the

00:16:45,460 --> 00:16:52,000
same things parallel execution pretty

00:16:48,580 --> 00:16:54,460
printing simplification and so on okay

00:16:52,000 --> 00:16:56,200
so that the idea here is we're making

00:16:54,460 --> 00:16:58,000
our language closer to Scala we're

00:16:56,200 --> 00:17:02,890
aligning it with Scala and we're getting

00:16:58,000 --> 00:17:04,150
a simpler interpreter there but I want

00:17:02,890 --> 00:17:07,180
to take a little bit of a moment here to

00:17:04,150 --> 00:17:09,730
talk about something else a little side

00:17:07,180 --> 00:17:11,410
issue here which actually kind of makes

00:17:09,730 --> 00:17:14,260
things a little bit more interesting and

00:17:11,410 --> 00:17:16,480
that's to do with ordering now we've

00:17:14,260 --> 00:17:19,690
built a really really basic DSL here and

00:17:16,480 --> 00:17:22,180
I have you noticed that it has an

00:17:19,690 --> 00:17:23,800
implicit ordering based on it so when

00:17:22,180 --> 00:17:25,300
I'm evaluating a less-than there I

00:17:23,800 --> 00:17:27,310
evaluate the left hand side and then the

00:17:25,300 --> 00:17:28,570
right hand side for this language that's

00:17:27,310 --> 00:17:29,980
completely fine like it doesn't matter

00:17:28,570 --> 00:17:32,260
this will pure expressions the ordering

00:17:29,980 --> 00:17:33,130
doesn't matter but in a general in

00:17:32,260 --> 00:17:34,690
general we're building these

00:17:33,130 --> 00:17:36,610
interpreters to mask some kind of

00:17:34,690 --> 00:17:39,280
horrible thing like mutable state or or

00:17:36,610 --> 00:17:41,350
um some other kind of effect and

00:17:39,280 --> 00:17:44,140
sometimes our side effects sometimes

00:17:41,350 --> 00:17:46,150
this order is going to matter so in most

00:17:44,140 --> 00:17:48,640
non-trivial dsls we want the programmer

00:17:46,150 --> 00:17:49,840
to choose that ordering for us so

00:17:48,640 --> 00:17:53,020
there's a question here about how can we

00:17:49,840 --> 00:17:56,200
build an explicit ordering

00:17:53,020 --> 00:17:57,460
into our DSL now what functional

00:17:56,200 --> 00:17:59,440
programming construct do we use for

00:17:57,460 --> 00:18:04,270
ordering of things to sequence things

00:17:59,440 --> 00:18:07,179
together monads yes so finally the M

00:18:04,270 --> 00:18:09,670
word arrives and so we can do this by

00:18:07,179 --> 00:18:14,410
building in a monad ok so we're going to

00:18:09,670 --> 00:18:18,280
make our DSL monadic and hopefully this

00:18:14,410 --> 00:18:19,120
is this is relatively straightforward so

00:18:18,280 --> 00:18:20,520
what we're going to do is we're going to

00:18:19,120 --> 00:18:22,600
take the expression language we've got

00:18:20,520 --> 00:18:24,730
and we're going to add a new type of

00:18:22,600 --> 00:18:26,770
expression and this is going to be the

00:18:24,730 --> 00:18:28,540
expression that will do the sequencing

00:18:26,770 --> 00:18:30,130
so this is a flat map expression I've

00:18:28,540 --> 00:18:31,990
just named it after the flat map method

00:18:30,130 --> 00:18:34,870
because it's basically that thing so a

00:18:31,990 --> 00:18:37,390
flat map expression basically pairs two

00:18:34,870 --> 00:18:39,340
other expressions together we have an

00:18:37,390 --> 00:18:41,530
expression a which will yield a value of

00:18:39,340 --> 00:18:42,910
a and then we have a function which will

00:18:41,530 --> 00:18:45,070
take a value of a and yield an

00:18:42,910 --> 00:18:46,630
expression of B so then if we were going

00:18:45,070 --> 00:18:48,190
to interpret this flat map if we're

00:18:46,630 --> 00:18:50,200
going to run it what we do is run it run

00:18:48,190 --> 00:18:51,670
the first expression take the value pass

00:18:50,200 --> 00:18:53,440
it into the function get back an

00:18:51,670 --> 00:18:56,350
expression and run the second expression

00:18:53,440 --> 00:18:58,120
okay and this is just like flat map in

00:18:56,350 --> 00:19:02,770
an option or flat map in a in a list

00:18:58,120 --> 00:19:04,360
okay now one interesting thing is this

00:19:02,770 --> 00:19:06,580
flat map thing is now dealing with our

00:19:04,360 --> 00:19:09,100
ordering so we can actually simplify

00:19:06,580 --> 00:19:10,720
less than an and notice that they're

00:19:09,100 --> 00:19:12,730
wrapping up other expressions we have

00:19:10,720 --> 00:19:15,400
sub expressions here and the only reason

00:19:12,730 --> 00:19:17,110
we've done that is because that allows

00:19:15,400 --> 00:19:18,850
us to to have some kind of implicit

00:19:17,110 --> 00:19:20,620
order in our language you evaluate the

00:19:18,850 --> 00:19:22,210
sub expressions and then you compare

00:19:20,620 --> 00:19:24,010
them or you evaluate sub expressions and

00:19:22,210 --> 00:19:25,630
you add them together and we don't need

00:19:24,010 --> 00:19:27,429
that anymore because flat map is going

00:19:25,630 --> 00:19:29,860
to do all this stuff for us so we can

00:19:27,429 --> 00:19:33,220
just say less than an and are now just

00:19:29,860 --> 00:19:35,230
primitive operations so the first three

00:19:33,220 --> 00:19:38,290
cases in my expression here are steps in

00:19:35,230 --> 00:19:40,480
my program and the last one tells tells

00:19:38,290 --> 00:19:43,480
you how to order the steps together does

00:19:40,480 --> 00:19:45,100
that make sense oh yeah I've got a few

00:19:43,480 --> 00:19:47,679
nods okay all right is any is anyone

00:19:45,100 --> 00:19:49,630
feeling slightly lost okay a couple of

00:19:47,679 --> 00:19:51,640
people okay that's right this is fine I

00:19:49,630 --> 00:19:53,800
will show you how it all hangs together

00:19:51,640 --> 00:19:55,710
oh one more thing

00:19:53,800 --> 00:19:58,929
I'm gonna rename literal there to pure

00:19:55,710 --> 00:20:01,000
because if you use if you use cats then

00:19:58,929 --> 00:20:02,710
your your monad has flat map and pure

00:20:01,000 --> 00:20:05,360
and literal is and a pure is a way of

00:20:02,710 --> 00:20:06,740
taking a value and putting into

00:20:05,360 --> 00:20:08,780
in this case an expression so it's just

00:20:06,740 --> 00:20:10,880
a terminological difference but it's

00:20:08,780 --> 00:20:13,460
still the same thing so we can no longer

00:20:10,880 --> 00:20:14,720
do this right we can't write our

00:20:13,460 --> 00:20:17,030
programs the same way we were writing

00:20:14,720 --> 00:20:18,740
them before because and unless then

00:20:17,030 --> 00:20:21,200
don't have expressions as their

00:20:18,740 --> 00:20:23,150
parameters so we can't directly push

00:20:21,200 --> 00:20:26,440
expressions together but what we can do

00:20:23,150 --> 00:20:27,980
is use flat map to sequence these things

00:20:26,440 --> 00:20:29,929
brace yourselves

00:20:27,980 --> 00:20:34,970
this is what the code looks like now

00:20:29,929 --> 00:20:37,640
okay so follow it through though okay

00:20:34,970 --> 00:20:38,840
these flat maps are all saying they all

00:20:37,640 --> 00:20:40,669
have two parameters the first parameter

00:20:38,840 --> 00:20:41,960
is an expression to run and the second

00:20:40,669 --> 00:20:45,440
parameter is a thing to do with the

00:20:41,960 --> 00:20:47,120
results okay so the first line here's an

00:20:45,440 --> 00:20:49,130
expression just gives me the value one

00:20:47,120 --> 00:20:51,200
and then I have a function that tells me

00:20:49,130 --> 00:20:52,669
what to do next and the next bit is okay

00:20:51,200 --> 00:20:53,960
I'm going to take the value two and I

00:20:52,669 --> 00:20:56,120
have a function to tell me what to do

00:20:53,960 --> 00:20:57,740
next and the next one is okay well now

00:20:56,120 --> 00:20:59,059
I'm inside two nested functions I've got

00:20:57,740 --> 00:21:00,919
a and B these are the two integers

00:20:59,059 --> 00:21:03,290
computer for the first and second steps

00:21:00,919 --> 00:21:04,850
I can less than them and then I have a

00:21:03,290 --> 00:21:06,110
function to deal with the result so we

00:21:04,850 --> 00:21:08,750
go we work all the way through to the

00:21:06,110 --> 00:21:11,000
end so a and B we less than them C and D

00:21:08,750 --> 00:21:13,070
we less than them we end that and then

00:21:11,000 --> 00:21:15,130
we return the result at the end we wrap

00:21:13,070 --> 00:21:17,299
it in a pure just to make the types work

00:21:15,130 --> 00:21:18,980
now with a little bit if we sort of add

00:21:17,299 --> 00:21:21,230
some methods some flatmap methods here

00:21:18,980 --> 00:21:22,640
and there and I'll show you a link to

00:21:21,230 --> 00:21:24,200
the full code later so you can look at

00:21:22,640 --> 00:21:25,940
that we can end up with something like

00:21:24,200 --> 00:21:27,740
this okay and it's just the same

00:21:25,940 --> 00:21:29,870
structure but we've just used a full

00:21:27,740 --> 00:21:31,429
comprehension so we and all you need to

00:21:29,870 --> 00:21:33,380
do to do this is add a flat map and map

00:21:31,429 --> 00:21:37,070
expression and method on to expression

00:21:33,380 --> 00:21:39,290
so so you can really see the sequence

00:21:37,070 --> 00:21:42,169
here and as a developer you can you know

00:21:39,290 --> 00:21:44,480
just flip to flip two lines over to

00:21:42,169 --> 00:21:46,820
change the order of evaluation you're

00:21:44,480 --> 00:21:48,470
obviously not going to be able to move a

00:21:46,820 --> 00:21:51,200
line too high or too low in the program

00:21:48,470 --> 00:21:53,900
if you need to use it's its result later

00:21:51,200 --> 00:21:55,580
on so we've kind of by aligning

00:21:53,900 --> 00:21:57,710
ourselves with Scala and for

00:21:55,580 --> 00:21:59,570
comprehensions now we've got ordering in

00:21:57,710 --> 00:22:03,559
a DSL without really having to do too

00:21:59,570 --> 00:22:04,400
much extra and your interpreter is kind

00:22:03,559 --> 00:22:07,070
of nice as well

00:22:04,400 --> 00:22:08,780
we got a pure we just yield the value if

00:22:07,070 --> 00:22:11,030
you've got a less than well a and B are

00:22:08,780 --> 00:22:12,530
just integers so we just compare them if

00:22:11,030 --> 00:22:15,230
we got our hands we just do the end and

00:22:12,530 --> 00:22:16,490
flatmap there does exactly what we said

00:22:15,230 --> 00:22:17,680
it would do it evaluates the first

00:22:16,490 --> 00:22:19,240
expression

00:22:17,680 --> 00:22:21,010
takes the result cause a function and

00:22:19,240 --> 00:22:22,510
evaluates the second expression you kind

00:22:21,010 --> 00:22:26,380
of can't be more explicit than that it's

00:22:22,510 --> 00:22:29,350
kind of kind of really pretty I think so

00:22:26,380 --> 00:22:32,560
we've got we've got the ability to write

00:22:29,350 --> 00:22:34,780
this we could write you know a sort of a

00:22:32,560 --> 00:22:38,200
parallel version of this I'm this is a

00:22:34,780 --> 00:22:39,100
little bit this is a this is actually

00:22:38,200 --> 00:22:40,630
not in parallel because I haven't

00:22:39,100 --> 00:22:42,840
implemented flatmap properly there but

00:22:40,630 --> 00:22:46,210
you can you can sort that out yourself

00:22:42,840 --> 00:22:47,740
but so we can build different types of

00:22:46,210 --> 00:22:49,180
interpreters do don't rush result but

00:22:47,740 --> 00:22:51,250
we've now kind of lost some abilities

00:22:49,180 --> 00:22:55,270
think about how you didn't permit pretty

00:22:51,250 --> 00:22:56,380
print on this language right we kind of

00:22:55,270 --> 00:22:57,640
have a bit of a problem here we've got

00:22:56,380 --> 00:22:59,770
this flat map and I'm not really sure

00:22:57,640 --> 00:23:05,680
what to do that how would we reconstruct

00:22:59,770 --> 00:23:07,750
some kind of some kind of a string

00:23:05,680 --> 00:23:09,070
representation of this I'm sure there

00:23:07,750 --> 00:23:10,600
are ways of doing it and we could

00:23:09,070 --> 00:23:11,620
probably maybe build a list of strings

00:23:10,600 --> 00:23:13,360
of all the things we've done in order

00:23:11,620 --> 00:23:14,620
but we're making life more difficult for

00:23:13,360 --> 00:23:16,330
ourselves and we're making life more

00:23:14,620 --> 00:23:17,800
difficult because we're starting to

00:23:16,330 --> 00:23:19,840
build in scarlet functions here and we

00:23:17,800 --> 00:23:21,520
probably the easiest way to pretty print

00:23:19,840 --> 00:23:23,470
this thing is to interpret the whole

00:23:21,520 --> 00:23:26,500
thing in to compile it into another data

00:23:23,470 --> 00:23:28,150
structure where we can more easily

00:23:26,500 --> 00:23:31,540
represent the sequence of computations

00:23:28,150 --> 00:23:33,130
directly okay and and when it comes to

00:23:31,540 --> 00:23:34,420
simplifying things or rewriting them all

00:23:33,130 --> 00:23:36,700
bets are off like this is quite

00:23:34,420 --> 00:23:38,230
difficult to deal with now so I'm not

00:23:36,700 --> 00:23:39,580
going to say it's impossible to do these

00:23:38,230 --> 00:23:41,670
kinds of things I'm going to say you're

00:23:39,580 --> 00:23:45,190
making life much harder for yourself and

00:23:41,670 --> 00:23:46,750
that the idea here is we've made our

00:23:45,190 --> 00:23:48,400
language kind of more general here by

00:23:46,750 --> 00:23:50,200
implementing introducing this flatmap

00:23:48,400 --> 00:23:52,240
step we've added a whole bunch of extra

00:23:50,200 --> 00:23:54,190
capabilities we can actually do

00:23:52,240 --> 00:23:56,020
arbitrary Scala code in the middle of

00:23:54,190 --> 00:23:58,360
our DSL right because you've got that

00:23:56,020 --> 00:24:01,540
Scala function and by introducing that

00:23:58,360 --> 00:24:03,220
we've dramatically reduced our ability

00:24:01,540 --> 00:24:05,940
to kind of look at a whole program from

00:24:03,220 --> 00:24:07,630
the top down and just fiddle with it but

00:24:05,940 --> 00:24:08,740
it's much easier to write the

00:24:07,630 --> 00:24:10,570
interpreter and we get all these

00:24:08,740 --> 00:24:13,540
different types of modularity for free

00:24:10,570 --> 00:24:17,890
so for most people for most cases it's

00:24:13,540 --> 00:24:19,420
it's a really good way of proceeding so

00:24:17,890 --> 00:24:21,880
the next step this is going to be a

00:24:19,420 --> 00:24:23,770
little bit sleight of hand here I'm

00:24:21,880 --> 00:24:25,990
gonna raise a question do we need to

00:24:23,770 --> 00:24:27,790
write flat map for ourselves so this

00:24:25,990 --> 00:24:30,550
idea about having a DSL it has a flat

00:24:27,790 --> 00:24:31,539
map step it's probably a very common

00:24:30,550 --> 00:24:33,489
thing that you could apply to

00:24:31,539 --> 00:24:36,340
a lot of different dsls right you just

00:24:33,489 --> 00:24:37,989
have an expression type that has maybe

00:24:36,340 --> 00:24:40,359
not less than an ad maybe add and

00:24:37,989 --> 00:24:42,879
multiply or different steps and then a

00:24:40,359 --> 00:24:44,350
flat map so should we have to write that

00:24:42,879 --> 00:24:46,570
ourselves isn't this something that some

00:24:44,350 --> 00:24:49,690
other clever functional program will

00:24:46,570 --> 00:24:52,119
have written for us and that is the case

00:24:49,690 --> 00:24:53,919
because we kind of generated venturing

00:24:52,119 --> 00:24:56,409
into free monad territory here so this

00:24:53,919 --> 00:24:58,840
is kind of where the free moaner comes

00:24:56,409 --> 00:25:00,399
in and the idea of the free monad is to

00:24:58,840 --> 00:25:02,830
take this pure and flat map step and

00:25:00,399 --> 00:25:04,809
remove them from our code and make them

00:25:02,830 --> 00:25:08,649
library code that we can reuse and that

00:25:04,809 --> 00:25:10,389
has a number of extra cool things cool

00:25:08,649 --> 00:25:13,659
properties things that allows us to do

00:25:10,389 --> 00:25:15,489
so I'll come to them in a minute so what

00:25:13,659 --> 00:25:18,489
we're going to do is we're going to kind

00:25:15,489 --> 00:25:20,919
of get to having written free ourselves

00:25:18,489 --> 00:25:23,379
to show you show you basically kind of

00:25:20,919 --> 00:25:24,789
open the curtain show you the man behind

00:25:23,379 --> 00:25:26,950
the curtain there's no magic this is

00:25:24,789 --> 00:25:28,869
this is what it is and what we have to

00:25:26,950 --> 00:25:30,970
do is you have to split our DSL into two

00:25:28,869 --> 00:25:33,879
so we're going to split it into the bit

00:25:30,970 --> 00:25:35,859
that does all the semantic stuff less

00:25:33,879 --> 00:25:40,799
than and and then the bit that does the

00:25:35,859 --> 00:25:43,960
sequencing so there we go so now we have

00:25:40,799 --> 00:25:47,979
steps at the top and then monad II

00:25:43,960 --> 00:25:50,080
things at the bottom right so I'm now

00:25:47,979 --> 00:25:51,429
going to say we're going to we're going

00:25:50,080 --> 00:25:53,559
to make these different data types so

00:25:51,429 --> 00:25:55,720
I'm going to rename them both so the

00:25:53,559 --> 00:25:58,960
thing at the top I'm going to call an

00:25:55,720 --> 00:26:00,580
algebra expression algebra and that is

00:25:58,960 --> 00:26:02,590
basically because in all the free monad

00:26:00,580 --> 00:26:04,239
literature that they talk about the and

00:26:02,590 --> 00:26:06,279
algebra as being the bit you plug into

00:26:04,239 --> 00:26:08,859
the free monnet to make your DSL and

00:26:06,279 --> 00:26:10,539
that describes basically the different

00:26:08,859 --> 00:26:12,729
sets of operations we can do to combine

00:26:10,539 --> 00:26:15,340
terms in order to combine values rather

00:26:12,729 --> 00:26:16,690
in a in our DSL so these are the things

00:26:15,340 --> 00:26:18,840
we're going to have every step of F for

00:26:16,690 --> 00:26:21,940
comprehension and then at the bottom

00:26:18,840 --> 00:26:24,460
pure and flatmap here become some kind

00:26:21,940 --> 00:26:26,649
of monad so it's a I'm calling it an

00:26:24,460 --> 00:26:28,179
expression monad for now so I can either

00:26:26,649 --> 00:26:29,859
wrap up a value and turn it into an

00:26:28,179 --> 00:26:31,509
instance of the expression monad or I

00:26:29,859 --> 00:26:32,799
can take two other instances of the

00:26:31,509 --> 00:26:34,299
expression monad and sequence them

00:26:32,799 --> 00:26:37,889
together okay

00:26:34,299 --> 00:26:37,889
sequencing the bottom steps at the top

00:26:38,970 --> 00:26:44,200
and I'm going to add one more step at

00:26:41,529 --> 00:26:45,070
the bottom because the way I had this

00:26:44,200 --> 00:26:46,660
here

00:26:45,070 --> 00:26:48,250
there's actually no way of taking an

00:26:46,660 --> 00:26:51,670
instance of the algebra and putting it

00:26:48,250 --> 00:26:53,890
inside this monad so there's no expert

00:26:51,670 --> 00:26:56,980
alq type at the bottom half of the slide

00:26:53,890 --> 00:26:59,770
so just introduce one more type in here

00:26:56,980 --> 00:27:01,840
and that the terminology used certainly

00:26:59,770 --> 00:27:04,090
in cats is suspend and that just says

00:27:01,840 --> 00:27:06,220
okay well here's a step is a step in our

00:27:04,090 --> 00:27:09,040
from our algebra and we're going to wrap

00:27:06,220 --> 00:27:14,950
it up so just a simple instance of the

00:27:09,040 --> 00:27:17,860
Monad so then this part here is our free

00:27:14,950 --> 00:27:19,900
monad this is tailored to expression

00:27:17,860 --> 00:27:22,060
okay so it's not free it's not

00:27:19,900 --> 00:27:23,560
context-free it's not a situation

00:27:22,060 --> 00:27:26,890
independent but what we can do is remove

00:27:23,560 --> 00:27:29,380
expression and produce some fairly

00:27:26,890 --> 00:27:31,300
abstract looking code where we're not

00:27:29,380 --> 00:27:33,490
saying we have expression at anymore but

00:27:31,300 --> 00:27:34,720
we have this type F so it's a type that

00:27:33,490 --> 00:27:37,180
takes one type type constructor that

00:27:34,720 --> 00:27:39,750
takes one type parameter and that's if

00:27:37,180 --> 00:27:41,590
we go back oh if I get four words

00:27:39,750 --> 00:27:43,390
expression algebra takes one type

00:27:41,590 --> 00:27:45,940
parameter so the idea is we can have a

00:27:43,390 --> 00:27:49,240
free of expression algebra and that is

00:27:45,940 --> 00:27:51,430
basically what we had before so we can

00:27:49,240 --> 00:27:53,590
wrap up a period of simple value we can

00:27:51,430 --> 00:27:55,690
take an instance of expression algebra

00:27:53,590 --> 00:27:57,460
and suspend it or put it into the monad

00:27:55,690 --> 00:28:00,280
and we can sequence two instances of the

00:27:57,460 --> 00:28:02,830
mailer together so we combine that with

00:28:00,280 --> 00:28:05,140
our expression we get something that

00:28:02,830 --> 00:28:07,960
looks a bit like this so this is a

00:28:05,140 --> 00:28:10,120
program now written using this way of

00:28:07,960 --> 00:28:12,520
doing things so I wrote this code

00:28:10,120 --> 00:28:15,970
directly on the slide I suspect if you

00:28:12,520 --> 00:28:17,530
do this there'll be some some type

00:28:15,970 --> 00:28:19,300
errors some variance issues you might

00:28:17,530 --> 00:28:21,220
need to have some helper methods in here

00:28:19,300 --> 00:28:22,330
to make this hi there compiler happy but

00:28:21,220 --> 00:28:24,850
this is showing you the structure of a

00:28:22,330 --> 00:28:26,710
program so you see we've got this monads

00:28:24,850 --> 00:28:29,260
flat map flatmap flat map flatmap pure

00:28:26,710 --> 00:28:31,390
and every step in there we've either got

00:28:29,260 --> 00:28:35,020
just a value being introduced or we have

00:28:31,390 --> 00:28:36,670
a step wrapped in suspend and it's still

00:28:35,020 --> 00:28:38,020
exactly the same program we had before

00:28:36,670 --> 00:28:39,370
but this is just the minimum work we

00:28:38,020 --> 00:28:42,010
need to do to separate these two things

00:28:39,370 --> 00:28:43,180
out and then we can take free from a

00:28:42,010 --> 00:28:45,790
library rather than having to implement

00:28:43,180 --> 00:28:47,860
it ourselves and you could kind of see

00:28:45,790 --> 00:28:49,690
it written like this in fact actually

00:28:47,860 --> 00:28:51,400
you don't normally write a free Monette

00:28:49,690 --> 00:28:53,350
program like this that the nor technique

00:28:51,400 --> 00:28:56,680
is you find your favorite fractional

00:28:53,350 --> 00:28:58,260
programming library you pull in the free

00:28:56,680 --> 00:29:00,120
data type from that program

00:28:58,260 --> 00:29:03,360
every and you normally take your algebra

00:29:00,120 --> 00:29:04,980
and you type alias rapping free around

00:29:03,360 --> 00:29:06,450
it so that the kind of the programs I'm

00:29:04,980 --> 00:29:08,640
going to build the expressions which of

00:29:06,450 --> 00:29:10,470
the programs are a combination of free

00:29:08,640 --> 00:29:13,620
and the algebra so this you know this is

00:29:10,470 --> 00:29:16,200
this necessarily Asit and then you use a

00:29:13,620 --> 00:29:18,660
bunch of helper methods to produce every

00:29:16,200 --> 00:29:20,280
step so don't worry too much about the

00:29:18,660 --> 00:29:22,620
details I've got a function here called

00:29:20,280 --> 00:29:23,880
literal a function called lit less than

00:29:22,620 --> 00:29:25,500
a function called an int and a function

00:29:23,880 --> 00:29:26,910
oh whoops

00:29:25,500 --> 00:29:28,020
old version the slides a function called

00:29:26,910 --> 00:29:30,260
fail which we're going to ignore from

00:29:28,020 --> 00:29:32,570
the next slide onwards but we've got

00:29:30,260 --> 00:29:35,070
we've got functions to basically take

00:29:32,570 --> 00:29:37,650
individual steps in our program and wrap

00:29:35,070 --> 00:29:40,470
them up in free so that we can then do

00:29:37,650 --> 00:29:41,820
this with them so all we're doing really

00:29:40,470 --> 00:29:43,620
if you look at the line for X and the

00:29:41,820 --> 00:29:46,110
line for y they're just less than if I

00:29:43,620 --> 00:29:47,280
go back they were suspended less than so

00:29:46,110 --> 00:29:48,900
all we're doing is making our lies a

00:29:47,280 --> 00:29:50,820
little bit simpler so what you typically

00:29:48,900 --> 00:29:52,200
do you build these helper methods you

00:29:50,820 --> 00:29:55,140
have your program which is written very

00:29:52,200 --> 00:29:57,870
simply and then you can run that for an

00:29:55,140 --> 00:30:00,210
interpreter and what the interpreter and

00:29:57,870 --> 00:30:01,830
the interpreter is kind of going to be

00:30:00,210 --> 00:30:03,060
two parts right there's one part of the

00:30:01,830 --> 00:30:04,590
interpreter is going to deal with free

00:30:03,060 --> 00:30:05,580
and there's gonna be one part of the

00:30:04,590 --> 00:30:08,070
interpreter that's going to deal with

00:30:05,580 --> 00:30:10,470
the expression algebra and the one for

00:30:08,070 --> 00:30:11,640
free is given to us and we just have to

00:30:10,470 --> 00:30:13,980
implement the one for the expression

00:30:11,640 --> 00:30:17,010
algebra and it kind of this is the code

00:30:13,980 --> 00:30:19,920
it kind of looks like this it's a a

00:30:17,010 --> 00:30:22,080
natural transformation but it's

00:30:19,920 --> 00:30:23,670
basically see this apply method it's

00:30:22,080 --> 00:30:25,100
taking instance of expression algebra

00:30:23,670 --> 00:30:27,600
and turning it into an instance of

00:30:25,100 --> 00:30:29,730
something else like a future or an

00:30:27,600 --> 00:30:31,890
option or an either another type

00:30:29,730 --> 00:30:34,410
constructor so all we have to do is say

00:30:31,890 --> 00:30:37,290
this is how you do these two steps

00:30:34,410 --> 00:30:41,010
they're less than in the end and then

00:30:37,290 --> 00:30:42,870
you can pass that the free--free in cats

00:30:41,010 --> 00:30:44,640
has got this method called fold map you

00:30:42,870 --> 00:30:46,950
provide your thing that does the lesson

00:30:44,640 --> 00:30:48,840
on the end and it handles pure suspends

00:30:46,950 --> 00:30:50,460
flat map all this other stuff so you

00:30:48,840 --> 00:30:52,040
never need to touch it and then that

00:30:50,460 --> 00:30:54,900
will yield the right result

00:30:52,040 --> 00:30:56,850
you always have to evaluate to something

00:30:54,900 --> 00:30:58,260
which has something like future or list

00:30:56,850 --> 00:31:00,690
a type constructor something that wraps

00:30:58,260 --> 00:31:04,050
up a value though and the way and it's

00:31:00,690 --> 00:31:06,720
because the way the types match up but

00:31:04,050 --> 00:31:08,220
you can evaluate to like just a raw

00:31:06,720 --> 00:31:11,040
value using this thing called the ID

00:31:08,220 --> 00:31:12,030
monad which is a little hack I won't

00:31:11,040 --> 00:31:13,260
talk about it you can

00:31:12,030 --> 00:31:14,790
there's a really good book with Scala

00:31:13,260 --> 00:31:16,740
with cats that I co-wrote you can read

00:31:14,790 --> 00:31:17,850
about it in there there's a little tiny

00:31:16,740 --> 00:31:20,820
chapter on it which will explain

00:31:17,850 --> 00:31:22,410
everything in there okay so the big

00:31:20,820 --> 00:31:25,590
thing here is free is providing a

00:31:22,410 --> 00:31:26,930
sequencing the flat map part gives us a

00:31:25,590 --> 00:31:30,600
sequencing we don't have to write that

00:31:26,930 --> 00:31:31,980
algebra just gives the steps and one of

00:31:30,600 --> 00:31:33,300
the really big things about this and the

00:31:31,980 --> 00:31:35,820
big justifications for doing something

00:31:33,300 --> 00:31:37,920
like free which I will just talk about

00:31:35,820 --> 00:31:39,630
very briefly and not really explain too

00:31:37,920 --> 00:31:42,510
much is it allows us to combine

00:31:39,630 --> 00:31:43,500
different deer cells so we've got this

00:31:42,510 --> 00:31:44,880
thing called free which does the

00:31:43,500 --> 00:31:47,070
sequencing and we have something we plug

00:31:44,880 --> 00:31:50,070
into free which says oh it's less than

00:31:47,070 --> 00:31:51,780
or and and we can easily add more terms

00:31:50,070 --> 00:31:53,730
on to that by combining things so

00:31:51,780 --> 00:31:56,250
there's a free example of type called

00:31:53,730 --> 00:31:57,600
either K in cats which says okay I've

00:31:56,250 --> 00:32:00,240
got two different algebra is out for one

00:31:57,600 --> 00:32:02,310
algebra two maybe Algebra one is add and

00:32:00,240 --> 00:32:04,920
multiply algebra 2 is less than around

00:32:02,310 --> 00:32:07,740
and I can just say well I can have a

00:32:04,920 --> 00:32:09,600
third algebra which is either algebra 1

00:32:07,740 --> 00:32:11,010
or algebra 2 it's really just you know

00:32:09,600 --> 00:32:12,990
that means it's an ad or a multiplier or

00:32:11,010 --> 00:32:15,840
less than or in hand and if I have that

00:32:12,990 --> 00:32:19,200
at every step in my program then my flat

00:32:15,840 --> 00:32:20,940
map my free my red still works if we had

00:32:19,200 --> 00:32:23,340
implemented fret map ourselves as part

00:32:20,940 --> 00:32:24,780
of our DSL then and we try to combine 2d

00:32:23,340 --> 00:32:26,400
s l's then you have this problem about

00:32:24,780 --> 00:32:28,320
which flat map do you use any given

00:32:26,400 --> 00:32:30,000
stage is the one from first geo cell or

00:32:28,320 --> 00:32:32,880
the one from the second one DSL but by

00:32:30,000 --> 00:32:35,070
factoring out the sequencing here free

00:32:32,880 --> 00:32:36,510
gives us the sequencing sequencing for

00:32:35,070 --> 00:32:38,370
everything and we just plug in the steps

00:32:36,510 --> 00:32:41,760
and there's a whole bunch of boilerplate

00:32:38,370 --> 00:32:42,840
around that and I there's a bunch of

00:32:41,760 --> 00:32:44,670
libraries there's a bunch of stuff in

00:32:42,840 --> 00:32:45,750
cats and there's this great libraries

00:32:44,670 --> 00:32:48,240
for it some degrees like people

00:32:45,750 --> 00:32:49,410
freestyle which will sort of remove all

00:32:48,240 --> 00:32:52,200
that boilerplate you never need to look

00:32:49,410 --> 00:32:53,610
at it it's very easy Ematic developing

00:32:52,200 --> 00:32:55,530
that they've got good documentation on

00:32:53,610 --> 00:32:57,960
this library so you can check it out

00:32:55,530 --> 00:33:02,550
ok so that's that's basically everything

00:32:57,960 --> 00:33:04,980
I wanted to say about about the the

00:33:02,550 --> 00:33:07,050
rarefied version of implementing DSL

00:33:04,980 --> 00:33:09,120
so basically we turn code into a data

00:33:07,050 --> 00:33:10,620
structure and we've talked about various

00:33:09,120 --> 00:33:12,690
different ways of handling type errors

00:33:10,620 --> 00:33:14,820
we talked about ways of doing sequencing

00:33:12,690 --> 00:33:15,840
and that relieves us all that sequencing

00:33:14,820 --> 00:33:20,010
stuff needs us to have him

00:33:15,840 --> 00:33:22,170
monads and the free monads so now I want

00:33:20,010 --> 00:33:23,490
to switch gears and the take-home point

00:33:22,170 --> 00:33:25,250
by the way from the free Mona stuff is I

00:33:23,490 --> 00:33:27,770
think it's all very complicated

00:33:25,250 --> 00:33:29,660
I want to switch gears and sort of show

00:33:27,770 --> 00:33:31,940
an alternative encoding an equivalent

00:33:29,660 --> 00:33:34,100
encoding that actually gives us kind of

00:33:31,940 --> 00:33:35,870
the same things but one of the big

00:33:34,100 --> 00:33:37,340
advantages of it is it's a like a lower

00:33:35,870 --> 00:33:39,650
cognitive load there's less boilerplate

00:33:37,340 --> 00:33:42,410
there's less complexity I think so the

00:33:39,650 --> 00:33:43,820
idea of church encoding is there

00:33:42,410 --> 00:33:45,710
anything we can represent as a data

00:33:43,820 --> 00:33:51,470
structure we can represent as a bunch of

00:33:45,710 --> 00:33:54,890
method calls kind of so rather than

00:33:51,470 --> 00:33:56,510
encoding programs as instances of a data

00:33:54,890 --> 00:33:59,000
structure we're going to encode them as

00:33:56,510 --> 00:33:59,840
a bunch of abstract method calls and

00:33:59,000 --> 00:34:02,390
then we're going to implement the

00:33:59,840 --> 00:34:04,460
methods and provide the details so I'll

00:34:02,390 --> 00:34:06,260
give you two examples of this the first

00:34:04,460 --> 00:34:07,880
one is just showing you how church

00:34:06,260 --> 00:34:10,370
encoding relates to what we just talked

00:34:07,880 --> 00:34:12,350
about so if we have something like this

00:34:10,370 --> 00:34:15,020
something like our expression so I've

00:34:12,350 --> 00:34:18,350
just gone back to having a literal less

00:34:15,020 --> 00:34:21,350
than an and okay anything where I have

00:34:18,350 --> 00:34:25,310
this sort of seal trait this some type

00:34:21,350 --> 00:34:27,770
co-product type some type and you've got

00:34:25,310 --> 00:34:30,550
a set of possible subtypes you can Rhian

00:34:27,770 --> 00:34:35,120
code that as a set of method calls so

00:34:30,550 --> 00:34:38,899
watch the board boom okay so I've still

00:34:35,120 --> 00:34:40,760
got an overall expression type I've

00:34:38,899 --> 00:34:42,379
called it expression DSL it's not a type

00:34:40,760 --> 00:34:44,600
anymore really so much as a library of

00:34:42,379 --> 00:34:45,950
methods and therefore every type I had

00:34:44,600 --> 00:34:48,320
in there I now have a method call and

00:34:45,950 --> 00:34:51,530
you see we're kind of got the same

00:34:48,320 --> 00:34:54,800
parameters and we've got the same result

00:34:51,530 --> 00:34:55,909
types in there pretty much so if I could

00:34:54,800 --> 00:35:00,140
release and these methods are all

00:34:55,909 --> 00:35:01,460
abstracts okay so if I have if I want to

00:35:00,140 --> 00:35:03,560
implement a program in terms of these

00:35:01,460 --> 00:35:05,300
methods I can just write a sequence of

00:35:03,560 --> 00:35:07,880
method calls without knowing how they

00:35:05,300 --> 00:35:10,370
implement it and so at a high level I've

00:35:07,880 --> 00:35:11,930
kind of said what I want to do so I can

00:35:10,370 --> 00:35:15,830
write something like this it's the

00:35:11,930 --> 00:35:17,930
typical sort of pattern I'm gonna take

00:35:15,830 --> 00:35:19,550
in an instance of my DSL type which

00:35:17,930 --> 00:35:22,010
provides the methods that I can run and

00:35:19,550 --> 00:35:22,910
then I'm just going to say okay these

00:35:22,010 --> 00:35:27,500
are the method calls I want in this

00:35:22,910 --> 00:35:28,940
order okay slightly weird having the the

00:35:27,500 --> 00:35:31,610
import there and that's just to make

00:35:28,940 --> 00:35:35,150
things you know shorter make the slide

00:35:31,610 --> 00:35:36,560
shorter and then so this this is now a

00:35:35,150 --> 00:35:37,910
program this satisfies all our

00:35:36,560 --> 00:35:38,720
requirements it's in an earth value it

00:35:37,910 --> 00:35:42,740
doesn't do anything

00:35:38,720 --> 00:35:44,780
but it specifies what we want to do then

00:35:42,740 --> 00:35:46,190
we can plug in an interpreter and the

00:35:44,780 --> 00:35:48,619
interpreter is the bit that tells us how

00:35:46,190 --> 00:35:51,500
to implement how to execute the steps so

00:35:48,619 --> 00:35:53,599
the interpreter is just a sub type of

00:35:51,500 --> 00:35:56,000
expression to yourself we implement that

00:35:53,599 --> 00:35:58,520
abstract class that traits we implement

00:35:56,000 --> 00:36:01,780
all the methods okay and that gives some

00:35:58,520 --> 00:36:04,940
meaning to each step and then we can

00:36:01,780 --> 00:36:07,880
call the interpol the program pass the

00:36:04,940 --> 00:36:11,119
interpreter in and that's a battle

00:36:07,880 --> 00:36:12,410
compute result so this is where this is

00:36:11,119 --> 00:36:13,730
kind of a weird thing that took me

00:36:12,410 --> 00:36:15,380
awhile to get my head around with the

00:36:13,730 --> 00:36:16,970
rarefied version it's really sort of

00:36:15,380 --> 00:36:18,260
straightforward seaming you build this

00:36:16,970 --> 00:36:20,000
data structure there's abstract syntax

00:36:18,260 --> 00:36:21,770
tree and you pass it to the interpreter

00:36:20,000 --> 00:36:24,170
as an argument that fiddly it feels

00:36:21,770 --> 00:36:26,390
really natural here you build your

00:36:24,170 --> 00:36:28,130
program is like a set of abstract method

00:36:26,390 --> 00:36:29,780
calls and you pass the interpreter to

00:36:28,130 --> 00:36:31,160
the program or you pass the

00:36:29,780 --> 00:36:33,650
implementation of each step to the

00:36:31,160 --> 00:36:37,790
program so it's kind of flipped but it

00:36:33,650 --> 00:36:40,220
has the same effect and so this gives us

00:36:37,790 --> 00:36:43,310
this kind of separation of intense and

00:36:40,220 --> 00:36:44,930
implementation but the way I've included

00:36:43,310 --> 00:36:46,580
it here is it's really restrictive I

00:36:44,930 --> 00:36:49,330
can't abstract over effects I couldn't

00:36:46,580 --> 00:36:51,980
make an asynchronous version of this

00:36:49,330 --> 00:36:54,650
okay and that's just because the types

00:36:51,980 --> 00:36:57,260
are too specific so but we can do that

00:36:54,650 --> 00:37:00,950
if we just generalize the types a little

00:36:57,260 --> 00:37:03,200
bit and this is where we come to tagless

00:37:00,950 --> 00:37:04,970
finally tactless final encoding I don't

00:37:03,200 --> 00:37:07,400
know which one the actual aren't what is

00:37:04,970 --> 00:37:10,339
it so anyone know is it tactless final

00:37:07,400 --> 00:37:13,670
finally tactless nobody knows it's crazy

00:37:10,339 --> 00:37:17,060
right okay so the idea here is we're

00:37:13,670 --> 00:37:22,580
just going to say okay in my DSL rather

00:37:17,060 --> 00:37:24,109
then rather than just return values in

00:37:22,580 --> 00:37:27,740
every step of the computation I'm going

00:37:24,109 --> 00:37:29,210
to return some F of the value some type

00:37:27,740 --> 00:37:30,290
constructor wrapped around the value it

00:37:29,210 --> 00:37:31,849
doesn't matter what it is you see I've

00:37:30,290 --> 00:37:33,589
got it as a type parameter up there at

00:37:31,849 --> 00:37:34,640
the top it could be anything could be

00:37:33,589 --> 00:37:37,099
option it can be future it could be

00:37:34,640 --> 00:37:40,040
whatever and then when I build my

00:37:37,099 --> 00:37:41,570
interpreter when I extend this trait and

00:37:40,040 --> 00:37:44,390
I provide all the meaning of all the

00:37:41,570 --> 00:37:47,000
steps I can fill in what that F is so I

00:37:44,390 --> 00:37:49,280
can have an interpreter like this that

00:37:47,000 --> 00:37:50,720
interprets the future and okay it's a

00:37:49,280 --> 00:37:52,030
trivial implementation this is not a

00:37:50,720 --> 00:37:54,580
very good example

00:37:52,030 --> 00:37:57,820
but you can see that okay now I have one

00:37:54,580 --> 00:37:59,500
that works for future and maybe now I

00:37:57,820 --> 00:38:02,140
have one works that that works for the

00:37:59,500 --> 00:38:03,400
ID monads this is a bit of a weird one

00:38:02,140 --> 00:38:05,020
but in principle you can implement

00:38:03,400 --> 00:38:07,390
anything you want in there any type of

00:38:05,020 --> 00:38:12,880
structure you want and then in your and

00:38:07,390 --> 00:38:16,360
then the other thing is that a lot of

00:38:12,880 --> 00:38:17,650
these guys I haven't introduced any any

00:38:16,360 --> 00:38:19,450
sequencing in here I've got a wrote

00:38:17,650 --> 00:38:21,460
square bracket there that's a bit weird

00:38:19,450 --> 00:38:22,720
but I haven't I haven't said how these

00:38:21,460 --> 00:38:24,460
things could be sequence together and

00:38:22,720 --> 00:38:26,230
the idea is that when you build one

00:38:24,460 --> 00:38:27,910
these interpreters you fill in a data

00:38:26,230 --> 00:38:30,070
type that has some kind of sequencing in

00:38:27,910 --> 00:38:34,510
it so we can use a monad so we can build

00:38:30,070 --> 00:38:38,230
a program which says okay I can run this

00:38:34,510 --> 00:38:41,740
sequence of steps for any DSL for of an

00:38:38,230 --> 00:38:44,080
F where F is a monad F has an instance

00:38:41,740 --> 00:38:45,670
of monads so you can import that if you

00:38:44,080 --> 00:38:48,160
import monad and you put this cat slot

00:38:45,670 --> 00:38:52,270
syntax dot flatmap then that gives you

00:38:48,160 --> 00:38:54,550
this flat map method on on F whatever F

00:38:52,270 --> 00:38:56,560
is so if I want to run it with future I

00:38:54,550 --> 00:38:58,480
pass in my a secrets interpreter and

00:38:56,560 --> 00:38:59,620
what so when I pass in a single

00:38:58,480 --> 00:39:02,320
temperature that's an interpreter or

00:38:59,620 --> 00:39:03,490
future so F gets bound to future and

00:39:02,320 --> 00:39:05,620
then this whole thing operates as a

00:39:03,490 --> 00:39:08,200
future and if I want to do it with the

00:39:05,620 --> 00:39:11,530
ID monad I pass in the other interpreter

00:39:08,200 --> 00:39:12,880
that says F is ID and then this whole

00:39:11,530 --> 00:39:16,090
thing works in ideaa nitwit

00:39:12,880 --> 00:39:18,670
synchronously and we can still combine

00:39:16,090 --> 00:39:19,960
DSL to this approach right so if you

00:39:18,670 --> 00:39:22,660
want to build a program from two dear

00:39:19,960 --> 00:39:23,950
cells you just have two parameters yeah

00:39:22,660 --> 00:39:27,250
you have to say all right I need them to

00:39:23,950 --> 00:39:28,690
be the same F okay so if i'm dealing

00:39:27,250 --> 00:39:30,250
with future i need to have an implement

00:39:28,690 --> 00:39:32,350
implementation of both dere cells that

00:39:30,250 --> 00:39:34,660
works with future and that gives us the

00:39:32,350 --> 00:39:36,730
common flat map that we had we talked

00:39:34,660 --> 00:39:38,440
about earlier you had the common flat

00:39:36,730 --> 00:39:40,510
map that was provided by free is now

00:39:38,440 --> 00:39:41,980
just says okay well whatever F we've got

00:39:40,510 --> 00:39:44,980
this monad instance here is going to

00:39:41,980 --> 00:39:47,290
give us this flat map so the kind of the

00:39:44,980 --> 00:39:49,240
big thing here is this is a lot lighter

00:39:47,290 --> 00:39:50,980
weight way of doing things than with

00:39:49,240 --> 00:39:54,250
free in my opinion there's a lot less

00:39:50,980 --> 00:39:56,020
boilerplate it's a lot easier to

00:39:54,250 --> 00:39:58,150
understand I think as a scholar

00:39:56,020 --> 00:40:00,750
developer it feels like sort of

00:39:58,150 --> 00:40:04,030
object-oriented programming but kind of

00:40:00,750 --> 00:40:07,480
stamped out in this very neat pattern

00:40:04,030 --> 00:40:09,640
and I gather there are performance

00:40:07,480 --> 00:40:12,700
improvements on that but I'm not the

00:40:09,640 --> 00:40:14,200
right person to answer that so I've got

00:40:12,700 --> 00:40:15,970
just a couple of minutes left I'll wrap

00:40:14,200 --> 00:40:17,470
up and take some questions so the kind

00:40:15,970 --> 00:40:18,790
of the idea of this talk was to just

00:40:17,470 --> 00:40:20,050
talk about different ways of building

00:40:18,790 --> 00:40:21,850
this interpretive pattern and the big

00:40:20,050 --> 00:40:23,770
thing is program interpret results

00:40:21,850 --> 00:40:26,650
that's that that's the thing

00:40:23,770 --> 00:40:28,360
so whatever approach you use here

00:40:26,650 --> 00:40:29,320
whether you do want something right at

00:40:28,360 --> 00:40:31,800
the beginning of the talk or something

00:40:29,320 --> 00:40:35,110
from right at the end of the talk this a

00:40:31,800 --> 00:40:37,770
separation can yield you all these

00:40:35,110 --> 00:40:40,600
really great benefits in terms of reuse

00:40:37,770 --> 00:40:42,310
and it's in fact that the tagless final

00:40:40,600 --> 00:40:44,490
encoding I'm now basically used in every

00:40:42,310 --> 00:40:46,750
project it's really really really handy

00:40:44,490 --> 00:40:49,180
we talked about two major ways of

00:40:46,750 --> 00:40:51,370
implementing these things verification

00:40:49,180 --> 00:40:53,590
Church encoding which you go with your

00:40:51,370 --> 00:40:54,850
free and tactless final I'll give you

00:40:53,590 --> 00:40:58,210
some references to read more about them

00:40:54,850 --> 00:41:00,010
in a minute and as we went along I kind

00:40:58,210 --> 00:41:03,790
of glossed over this towards the end but

00:41:00,010 --> 00:41:06,640
the that we had this sort of axis of

00:41:03,790 --> 00:41:08,080
light from if you've got like

00:41:06,640 --> 00:41:09,550
replication church and coding as one

00:41:08,080 --> 00:41:10,960
access in your design space you have

00:41:09,550 --> 00:41:12,400
this sort of level of embedding is

00:41:10,960 --> 00:41:14,770
another axis you know a design space and

00:41:12,400 --> 00:41:16,170
really it's how many things in your

00:41:14,770 --> 00:41:18,010
language do you want to model yourself

00:41:16,170 --> 00:41:19,390
versus how many do one just pull

00:41:18,010 --> 00:41:21,010
straight from scala the more you pull

00:41:19,390 --> 00:41:23,560
from scholar the easier life is but the

00:41:21,010 --> 00:41:26,970
less sort of inspectable your language

00:41:23,560 --> 00:41:30,340
becomes okay so here are a couple of

00:41:26,970 --> 00:41:33,970
good links this one on tagless final is

00:41:30,340 --> 00:41:36,520
a london scholarly news group taught by

00:41:33,970 --> 00:41:38,920
chris virtual it's on the skills matter

00:41:36,520 --> 00:41:40,720
website this is an awesome talk where he

00:41:38,920 --> 00:41:42,250
describes tackles final and then

00:41:40,720 --> 00:41:44,650
implements a code base like a fairly

00:41:42,250 --> 00:41:47,290
sophisticated code base live in the talk

00:41:44,650 --> 00:41:49,150
it's really really good if you're

00:41:47,290 --> 00:41:51,760
interested in looking at the code I've

00:41:49,150 --> 00:41:54,700
got this all on github there's a bunch

00:41:51,760 --> 00:41:56,440
of code samples that go go through all

00:41:54,700 --> 00:41:58,750
these different implementations in a lot

00:41:56,440 --> 00:42:00,760
of detail there's also some notes some

00:41:58,750 --> 00:42:02,170
kind of like for like long-form text

00:42:00,760 --> 00:42:05,260
which I'm still working on and I'm

00:42:02,170 --> 00:42:07,380
hoping to flesh that out of it so that's

00:42:05,260 --> 00:42:14,010
all I have thank you very much

00:42:07,380 --> 00:42:14,010

YouTube URL: https://www.youtube.com/watch?v=MfpXcaG-Wog


