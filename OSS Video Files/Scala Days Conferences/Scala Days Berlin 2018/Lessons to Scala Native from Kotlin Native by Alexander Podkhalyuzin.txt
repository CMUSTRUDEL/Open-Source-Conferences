Title: Lessons to Scala Native from Kotlin Native by Alexander Podkhalyuzin
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract and further information can be found here:
https://eu.scaladays.org/lect-6944-lessons-to-scala-native-from-kotlin-native.html
Captions: 
	00:00:04,740 --> 00:00:16,410
I'm Alex and I used to work as leader of

00:00:11,450 --> 00:00:20,700
Scala plugin for ontology and now I

00:00:16,410 --> 00:00:23,630
decided to learn a bit Scala native when

00:00:20,700 --> 00:00:28,610
I switched year ago to cotton native I

00:00:23,630 --> 00:00:31,289
started to develop IDE for cotton native

00:00:28,610 --> 00:00:37,710
because I needed something new after

00:00:31,289 --> 00:00:41,190
nine years of Scala plugin and I found

00:00:37,710 --> 00:00:45,120
it pretty interesting stuff but from

00:00:41,190 --> 00:00:49,110
January I moved even for big horizon's'

00:00:45,120 --> 00:00:53,520
to Kotlin tooling team also I'm now

00:00:49,110 --> 00:00:55,680
leading cotton to one team and I wanted

00:00:53,520 --> 00:01:00,960
to learn something around scholar native

00:00:55,680 --> 00:01:03,629
and that's why I decided to give a top

00:01:00,960 --> 00:01:06,560
for Scala days here and I really

00:01:03,629 --> 00:01:12,119
appreciate that program committee

00:01:06,560 --> 00:01:14,909
accepted this talk here because Kotlin

00:01:12,119 --> 00:01:15,990
is definitely competitive for Scala so

00:01:14,909 --> 00:01:19,040
it's no depth

00:01:15,990 --> 00:01:22,170
I mean that if somebody can tell that

00:01:19,040 --> 00:01:24,659
cotton if somebody tells you that cotton

00:01:22,170 --> 00:01:29,189
is not competitive for Scala it will be

00:01:24,659 --> 00:01:32,490
kind of a lie because you know the same

00:01:29,189 --> 00:01:38,189
field the same people trying to do this

00:01:32,490 --> 00:01:40,799
stuff so definitely right now Kotlin and

00:01:38,189 --> 00:01:44,490
Scala has different markets I mean that

00:01:40,799 --> 00:01:47,939
cotton in completely in Android Market

00:01:44,490 --> 00:01:52,829
and slightly in web stuff and different

00:01:47,939 --> 00:01:55,369
things and Scala is widely used in lots

00:01:52,829 --> 00:01:59,070
of fields and it's very major language I

00:01:55,369 --> 00:02:03,750
still really love Scala do some Scala

00:01:59,070 --> 00:02:07,049
and that's my favorite language so I

00:02:03,750 --> 00:02:09,629
decided to do some kind of comparison to

00:02:07,049 --> 00:02:12,420
understand what's going on so let's time

00:02:09,629 --> 00:02:15,870
start from some sad news especially with

00:02:12,420 --> 00:02:18,660
yesterday talked around growl VM this

00:02:15,870 --> 00:02:23,010
sad news is even more said around

00:02:18,660 --> 00:02:25,290
so that's kind of reddit message

00:02:23,010 --> 00:02:30,000
somebody asked about can Scala native

00:02:25,290 --> 00:02:32,459
keep pace with cotton native and answer

00:02:30,000 --> 00:02:35,430
is actually that yeah it's hardly

00:02:32,459 --> 00:02:37,349
possible because cotton native team is

00:02:35,430 --> 00:02:40,769
quite huge it's more than eight people

00:02:37,349 --> 00:02:43,819
working just on the backend stuff and

00:02:40,769 --> 00:02:47,129
interoperability stuff and they're very

00:02:43,819 --> 00:02:51,060
professional native developers came from

00:02:47,129 --> 00:02:53,910
native roll and we're not so many people

00:02:51,060 --> 00:02:56,430
works on Scala native so it's it's it's

00:02:53,910 --> 00:02:59,160
it's really hard to compete especially

00:02:56,430 --> 00:03:00,870
in the technology which is which can be

00:02:59,160 --> 00:03:03,140
widely used and I'll show you some

00:03:00,870 --> 00:03:07,769
examples where it can be used actually

00:03:03,140 --> 00:03:10,739
and together with yesterday in use

00:03:07,769 --> 00:03:13,910
around growl VM when we can see that

00:03:10,739 --> 00:03:18,360
speed of Scala compiler is much faster

00:03:13,910 --> 00:03:22,019
so we can see that purpose of cognitive

00:03:18,360 --> 00:03:26,910
is even lower so let's try to understand

00:03:22,019 --> 00:03:30,420
what's going on next in the talk so why

00:03:26,910 --> 00:03:35,489
native so first thing is startup

00:03:30,420 --> 00:03:37,970
performance everybody knows that we are

00:03:35,489 --> 00:03:41,310
trying to change our architecture of

00:03:37,970 --> 00:03:43,980
programs into smaller parts or micro

00:03:41,310 --> 00:03:46,980
services and it's definitely important

00:03:43,980 --> 00:03:49,980
for micro services to to startup faster

00:03:46,980 --> 00:03:54,690
and that's why one of the biggest

00:03:49,980 --> 00:03:57,530
purpose of native using native so we

00:03:54,690 --> 00:04:00,930
know already that people started using

00:03:57,530 --> 00:04:04,769
for Amazon lambda for example like Scala

00:04:00,930 --> 00:04:08,340
G yes because startup time is so fast so

00:04:04,769 --> 00:04:11,040
we can run our functions there as small

00:04:08,340 --> 00:04:13,739
micro services so native can be also

00:04:11,040 --> 00:04:17,459
possibility for that so another it's

00:04:13,739 --> 00:04:19,919
it's very questionable ballot but it's

00:04:17,459 --> 00:04:24,349
questionable about question you know gdm

00:04:19,919 --> 00:04:24,349
platform future so I

00:04:24,750 --> 00:04:28,560
it's my personal opinion I mean that we

00:04:27,240 --> 00:04:32,340
just don't know what what will we have

00:04:28,560 --> 00:04:35,850
with with this thing kind of thing

00:04:32,340 --> 00:04:39,780
especially again they they already do in

00:04:35,850 --> 00:04:42,960
different VM which is multi-purpose in

00:04:39,780 --> 00:04:44,840
multiple languages and so on another

00:04:42,960 --> 00:04:47,730
also bullet is general performance

00:04:44,840 --> 00:04:50,070
mainly for Scala native and cotton

00:04:47,730 --> 00:04:53,480
native general performance in not the

00:04:50,070 --> 00:04:56,960
main purpose because it requires lots of

00:04:53,480 --> 00:04:59,640
effort working on performance lots of

00:04:56,960 --> 00:05:05,100
hours for performance engineers

00:04:59,640 --> 00:05:08,220
improving final bit code and that's

00:05:05,100 --> 00:05:10,680
that's not the main purpose so that's

00:05:08,220 --> 00:05:14,280
why it's question was still because even

00:05:10,680 --> 00:05:19,800
hot spot with JIT is very very fast

00:05:14,280 --> 00:05:23,880
actually it's highly optimized code so

00:05:19,800 --> 00:05:27,300
it's performance is real so that's the

00:05:23,880 --> 00:05:30,120
next one is possibility to run programs

00:05:27,300 --> 00:05:34,320
on OS so that's that's what we didn't

00:05:30,120 --> 00:05:37,380
have in with Java so that's we actually

00:05:34,320 --> 00:05:39,560
have it but it's kind of tricky thing

00:05:37,380 --> 00:05:43,320
and the same for Scala and confident so

00:05:39,560 --> 00:05:47,280
iOS native support is kind of possible I

00:05:43,320 --> 00:05:51,780
think and the last one is possibility to

00:05:47,280 --> 00:05:54,540
run on embedded devices that's also the

00:05:51,780 --> 00:05:58,130
vault is changing right now so so for

00:05:54,540 --> 00:06:01,020
example on last week on Google i/o we

00:05:58,130 --> 00:06:04,800
saw the presentation about around

00:06:01,020 --> 00:06:10,020
Android things I mean that people

00:06:04,800 --> 00:06:12,720
already do devices with Android things

00:06:10,020 --> 00:06:16,860
so they all can use all this Java

00:06:12,720 --> 00:06:21,360
coupling and a bit Scala stuff I use

00:06:16,860 --> 00:06:26,010
ordinary Android apps on that places so

00:06:21,360 --> 00:06:29,729
this is also very very big competition

00:06:26,010 --> 00:06:32,820
is going to be there and so embedded

00:06:29,729 --> 00:06:35,050
devices we can talk even about more

00:06:32,820 --> 00:06:38,259
small devices were

00:06:35,050 --> 00:06:40,569
latency is not is critical I mean that

00:06:38,259 --> 00:06:42,539
program should be very predictable so

00:06:40,569 --> 00:06:45,970
smooth Marisa's on small micro seams

00:06:42,539 --> 00:06:49,599
with low CPUs and so on

00:06:45,970 --> 00:06:53,409
with no OS so that's that's possibility

00:06:49,599 --> 00:06:57,039
again that's not the that was actually

00:06:53,409 --> 00:07:00,069
works so that's the answer to the

00:06:57,039 --> 00:07:03,550
question why why we we want and need

00:07:00,069 --> 00:07:06,250
these technologies so let's do some

00:07:03,550 --> 00:07:08,860
introduction generally around this talk

00:07:06,250 --> 00:07:10,930
I'm not going to give some deep

00:07:08,860 --> 00:07:14,740
explanation around these technologies so

00:07:10,930 --> 00:07:17,919
I I want to do some introduction or talk

00:07:14,740 --> 00:07:20,620
and do some good bit cumbersome so let's

00:07:17,919 --> 00:07:25,690
take a look for simple hello world

00:07:20,620 --> 00:07:28,270
projects so that's quite simple but we

00:07:25,690 --> 00:07:30,639
need to run in terminal so I mean that

00:07:28,270 --> 00:07:33,940
nothing is supported yet in intelligence

00:07:30,639 --> 00:07:38,710
if I run by this button I are running

00:07:33,940 --> 00:07:43,389
ordinary GBM so and internally we need

00:07:38,710 --> 00:07:47,289
to run like SBT native link then we will

00:07:43,389 --> 00:07:50,289
see how compiler works and then we will

00:07:47,289 --> 00:07:52,690
get actual binary in this example I have

00:07:50,289 --> 00:07:55,509
two main methods and for skull on it if

00:07:52,690 --> 00:07:57,520
it's important to choose the right main

00:07:55,509 --> 00:08:00,580
method so we need to choose the second

00:07:57,520 --> 00:08:02,020
one then it will optimize and do that

00:08:00,580 --> 00:08:09,159
called illumination did the final

00:08:02,020 --> 00:08:11,500
Benner's it's a bit slow but usable so

00:08:09,159 --> 00:08:18,009
now when we can see this binary and go

00:08:11,500 --> 00:08:21,779
to the actual and for example run with

00:08:18,009 --> 00:08:25,330
this and see the printer one which is

00:08:21,779 --> 00:08:29,620
instantly so that's that's original goal

00:08:25,330 --> 00:08:32,919
to have a instant startup time pretty

00:08:29,620 --> 00:08:35,229
similar in cotton but here we have some

00:08:32,919 --> 00:08:38,969
ID support so we can just run it and see

00:08:35,229 --> 00:08:42,640
this hello native world it don't use

00:08:38,969 --> 00:08:46,000
some tricky stuff like Gradle or SBT it

00:08:42,640 --> 00:08:47,530
uses old-fashioned see make it's a bit

00:08:46,000 --> 00:08:50,920
weird but

00:08:47,530 --> 00:08:54,340
everything of course it's going to be on

00:08:50,920 --> 00:08:59,170
Gradle mostly because you will see why

00:08:54,340 --> 00:09:02,950
why okay so right now it's kind of scary

00:08:59,170 --> 00:09:08,110
see make script which builds and runs

00:09:02,950 --> 00:09:11,470
this stuff so initial compression of

00:09:08,110 --> 00:09:14,440
this simple two things it's about binary

00:09:11,470 --> 00:09:17,500
size which is very different we can try

00:09:14,440 --> 00:09:19,630
to pack it with upx and see the

00:09:17,500 --> 00:09:21,910
difference which is still you know I

00:09:19,630 --> 00:09:24,970
want to say that four point two

00:09:21,910 --> 00:09:27,370
megabytes for a Hilo volt it looks like

00:09:24,970 --> 00:09:32,170
main to many but actually it's it's very

00:09:27,370 --> 00:09:35,710
impressive work believe me and Scala is

00:09:32,170 --> 00:09:37,960
very heavy language itself so that's why

00:09:35,710 --> 00:09:42,310
it possibly collects too many things in

00:09:37,960 --> 00:09:43,780
since inside so encoding native for

00:09:42,310 --> 00:09:47,920
example of runtime library is much

00:09:43,780 --> 00:09:51,460
smaller and that's probably also the

00:09:47,920 --> 00:09:54,250
reason and print a long time it's you

00:09:51,460 --> 00:09:58,270
know it's very simple benchmark which

00:09:54,250 --> 00:10:01,180
also can't go wrong so but don't see it

00:09:58,270 --> 00:10:04,690
like cognitive is pretty better no it's

00:10:01,180 --> 00:10:08,170
just just some numbers and compilation

00:10:04,690 --> 00:10:10,900
plus linking time show that we need to

00:10:08,170 --> 00:10:14,050
do it for after ever any change we need

00:10:10,900 --> 00:10:16,810
to do it constantly so development in

00:10:14,050 --> 00:10:21,070
Kotlin or native for Scala native will

00:10:16,810 --> 00:10:24,850
cost some time I mean we know that in

00:10:21,070 --> 00:10:26,860
Scala and cotton world we have such

00:10:24,850 --> 00:10:30,940
thing like incremental compilation so

00:10:26,860 --> 00:10:33,180
for every change we can see the running

00:10:30,940 --> 00:10:36,220
tests in probably one of few seconds

00:10:33,180 --> 00:10:38,500
that's really productive so whether when

00:10:36,220 --> 00:10:42,970
it's more than 10 seconds it's became

00:10:38,500 --> 00:10:47,700
less productive so that's what I told

00:10:42,970 --> 00:10:51,660
just around incremental compilation and

00:10:47,700 --> 00:10:55,990
we see now that both compilers are slow

00:10:51,660 --> 00:10:59,000
so our big competitor which is growl VM

00:10:55,990 --> 00:11:01,820
is already faster

00:10:59,000 --> 00:11:05,650
and but still incremental compilation is

00:11:01,820 --> 00:11:11,480
going to be important thing I mean that

00:11:05,650 --> 00:11:14,960
that that we can do something

00:11:11,480 --> 00:11:17,270
incrementally for example what is good

00:11:14,960 --> 00:11:20,710
around Scala native what is not

00:11:17,270 --> 00:11:23,560
implemented yet in cotton native that

00:11:20,710 --> 00:11:26,620
Scala native has some intermediate

00:11:23,560 --> 00:11:31,190
representation before actual compilation

00:11:26,620 --> 00:11:33,200
that's that good thing because this

00:11:31,190 --> 00:11:37,060
intermediate representation is possible

00:11:33,200 --> 00:11:39,470
to serialize and publish as libraries

00:11:37,060 --> 00:11:42,100
what is much more complicated and

00:11:39,470 --> 00:11:45,080
colonnades with the where intermediate

00:11:42,100 --> 00:11:48,590
representations is only coming so I mean

00:11:45,080 --> 00:11:51,920
that it's under development but not yet

00:11:48,590 --> 00:11:54,500
ready so but of course the idea is

00:11:51,920 --> 00:11:58,550
completely the same we want to have very

00:11:54,500 --> 00:12:01,030
similar thing to tasty and have a

00:11:58,550 --> 00:12:03,710
possibility to distribute libraries in

00:12:01,030 --> 00:12:06,710
serialize back and intermediate

00:12:03,710 --> 00:12:08,120
representation and this parts definitely

00:12:06,710 --> 00:12:11,180
could be incremental it's already

00:12:08,120 --> 00:12:13,820
incremental in GBM world so it's not

00:12:11,180 --> 00:12:18,650
really complicated to do it

00:12:13,820 --> 00:12:24,320
incrementally in native form so the

00:12:18,650 --> 00:12:26,210
second part requires last compiling from

00:12:24,320 --> 00:12:30,170
intermediate representation in the

00:12:26,210 --> 00:12:36,200
binaries and even more complicated thing

00:12:30,170 --> 00:12:40,250
is linking of course something can help

00:12:36,200 --> 00:12:43,150
in this direction because we can do that

00:12:40,250 --> 00:12:45,410
code eliminations on intermediate

00:12:43,150 --> 00:12:48,380
representation and then a linking will

00:12:45,410 --> 00:12:53,240
be much faster but still a linkage is

00:12:48,380 --> 00:12:55,670
very slow I think in native world so how

00:12:53,240 --> 00:13:00,339
it's again how its implemented in Grail

00:12:55,670 --> 00:13:02,750
VM it's quite impressive again so

00:13:00,339 --> 00:13:04,970
speaking about startup performance we

00:13:02,750 --> 00:13:08,450
can understand one of the possible

00:13:04,970 --> 00:13:11,330
purpose which we as developers already

00:13:08,450 --> 00:13:12,710
want to have and do it for example in

00:13:11,330 --> 00:13:16,340
GBM world

00:13:12,710 --> 00:13:19,130
we do some common line tools but in gdm

00:13:16,340 --> 00:13:22,790
if we want to do some common line we

00:13:19,130 --> 00:13:25,940
still need to wait for running starting

00:13:22,790 --> 00:13:29,860
this gvm stuff so this startup

00:13:25,940 --> 00:13:33,050
performance makes a good idea to have a

00:13:29,860 --> 00:13:38,320
corner its color native for common line

00:13:33,050 --> 00:13:38,320
tools and good think around Scala that

00:13:38,380 --> 00:13:46,790
part of GDK not GDK java standard

00:13:43,190 --> 00:13:51,230
library is implemented in Scala and good

00:13:46,790 --> 00:13:54,880
thing is that a lot of libraries already

00:13:51,230 --> 00:13:58,010
possible to compile for Scala native and

00:13:54,880 --> 00:14:04,730
that's not the same for cotton because

00:13:58,010 --> 00:14:09,230
cotton don't have Java library in in

00:14:04,730 --> 00:14:11,630
native world so that's a trade off kind

00:14:09,230 --> 00:14:16,420
of because if you have a implemented

00:14:11,630 --> 00:14:20,480
Java standard library for one particular

00:14:16,420 --> 00:14:22,690
client like Linux then you you already

00:14:20,480 --> 00:14:26,180
have lots of libraries but then

00:14:22,690 --> 00:14:28,850
supporting new platforms means that you

00:14:26,180 --> 00:14:31,990
you need to reemployment these lots of

00:14:28,850 --> 00:14:35,840
this stuff for different machines and

00:14:31,990 --> 00:14:38,840
this also means that you can get some

00:14:35,840 --> 00:14:46,280
differences in implementations of bugs

00:14:38,840 --> 00:14:48,860
and some problems with compatible so

00:14:46,280 --> 00:14:51,740
Kirkland doesn't have it because we

00:14:48,860 --> 00:14:54,950
don't want to deal with this complicated

00:14:51,740 --> 00:14:59,270
stuff and we all want to have lots of

00:14:54,950 --> 00:15:02,300
supported platform solving so what we

00:14:59,270 --> 00:15:06,290
have in Scala we have some library for

00:15:02,300 --> 00:15:09,950
example scallop and that's some simple

00:15:06,290 --> 00:15:13,070
code which is called calculator because

00:15:09,950 --> 00:15:18,340
you can do plus and multiply two numbers

00:15:13,070 --> 00:15:18,340
and now you can do it from terminal

00:15:20,589 --> 00:15:27,370
first we need to compile it again

00:15:22,850 --> 00:15:39,139
because it's another main entry point

00:15:27,370 --> 00:15:41,420
okay so it's broken okay so thank you we

00:15:39,139 --> 00:15:43,220
need to do it again because entry point

00:15:41,420 --> 00:15:45,769
it's important for in native fold

00:15:43,220 --> 00:15:49,100
because we need to do some optimizations

00:15:45,769 --> 00:15:52,279
for the final binary and one of them is

00:15:49,100 --> 00:15:55,630
dead code elimination so if you know an

00:15:52,279 --> 00:16:07,160
entry point we can remove unnecessary

00:15:55,630 --> 00:16:12,079
classes so now we have new binary and we

00:16:07,160 --> 00:16:18,740
can run it so we can do any calculations

00:16:12,079 --> 00:16:22,310
we want like like operator sum and do

00:16:18,740 --> 00:16:28,250
like 12 and 13 so we can see that it's

00:16:22,310 --> 00:16:31,970
25 it's it's right so software works and

00:16:28,250 --> 00:16:38,389
in Kotlin we can see much more scary

00:16:31,970 --> 00:16:41,120
stuff how's this this is kind of CSV

00:16:38,389 --> 00:16:44,329
parser and it's also common line based

00:16:41,120 --> 00:16:47,410
so but we need here to parse arguments

00:16:44,329 --> 00:16:50,060
by ourselves this this is pretty simple

00:16:47,410 --> 00:16:54,139
arguments parsers so which just takes

00:16:50,060 --> 00:16:58,699
all the arguments one by one you of

00:16:54,139 --> 00:17:03,350
course can use native library which is

00:16:58,699 --> 00:17:07,189
get-ups and this is kind of tricky thing

00:17:03,350 --> 00:17:10,250
especially for Jared and I mean not Java

00:17:07,189 --> 00:17:15,709
Scala gvm developer who who don't know

00:17:10,250 --> 00:17:20,289
this scared native world but it's it's

00:17:15,709 --> 00:17:23,240
possible because of very major interrupt

00:17:20,289 --> 00:17:27,199
interoperability feature in supported in

00:17:23,240 --> 00:17:31,010
cotton native I mean that you can

00:17:27,199 --> 00:17:34,160
actually call the native libraries

00:17:31,010 --> 00:17:36,740
of course you will lose this cut in

00:17:34,160 --> 00:17:40,250
runtime which is available inside of

00:17:36,740 --> 00:17:43,400
cotton itself and you need to deal with

00:17:40,250 --> 00:17:46,669
memory as you usually need to do it in C

00:17:43,400 --> 00:17:50,809
and C++ so we need to define this map

00:17:46,669 --> 00:17:56,419
scoped scope where we can unlock memory

00:17:50,809 --> 00:18:00,370
and so that's that's how it works so

00:17:56,419 --> 00:18:05,390
here we we do some I owe I owe stuff

00:18:00,370 --> 00:18:10,190
just to read the file so and we can

00:18:05,390 --> 00:18:13,370
actually run it and here we have some

00:18:10,190 --> 00:18:17,750
predefined parameters and some

00:18:13,370 --> 00:18:22,059
predefined CSV file which which is

00:18:17,750 --> 00:18:29,480
parsed and did some stuff around that

00:18:22,059 --> 00:18:30,169
okay pretty cool for now actually in

00:18:29,480 --> 00:18:33,410
cotton

00:18:30,169 --> 00:18:37,340
during the probably two weeks ago new

00:18:33,410 --> 00:18:40,070
library were implemented around parsing

00:18:37,340 --> 00:18:43,130
arguments so it's already available but

00:18:40,070 --> 00:18:45,140
I mean that in Scala it's much more than

00:18:43,130 --> 00:18:47,240
one library already available so that's

00:18:45,140 --> 00:18:51,260
it's that's what is cool about Aaron's

00:18:47,240 --> 00:18:54,770
counted so what's next I already started

00:18:51,260 --> 00:18:57,140
speaking about memory management so the

00:18:54,770 --> 00:18:59,660
the big difference between Schoen cotton

00:18:57,140 --> 00:19:05,120
that scow is GC based memory manager

00:18:59,660 --> 00:19:08,120
management as well as growl VM so cotton

00:19:05,120 --> 00:19:10,669
has different ideas it has reference

00:19:08,120 --> 00:19:16,100
counter with cycle collection memory

00:19:10,669 --> 00:19:19,010
management and memory is separate for

00:19:16,100 --> 00:19:23,000
every thread and cycle can be collected

00:19:19,010 --> 00:19:25,370
inside of any every thread so world is

00:19:23,000 --> 00:19:28,370
not stopping when some thread is

00:19:25,370 --> 00:19:31,160
deciding to collect cycles and this is

00:19:28,370 --> 00:19:35,419
very lightweight but generally it's just

00:19:31,160 --> 00:19:38,360
reference counting and what the strong

00:19:35,419 --> 00:19:41,110
think around reference counting I I will

00:19:38,360 --> 00:19:41,110
show a bit later

00:19:41,370 --> 00:19:47,580
actually if if we can if we want to

00:19:44,669 --> 00:19:50,970
speak around science that's that is just

00:19:47,580 --> 00:19:55,799
two different possibilities to implement

00:19:50,970 --> 00:19:59,700
this garbage collecting and science tell

00:19:55,799 --> 00:20:02,039
us that actually it's possible to do do

00:19:59,700 --> 00:20:05,610
the same at the same performance from

00:20:02,039 --> 00:20:07,919
both both sides so all these options are

00:20:05,610 --> 00:20:10,590
right actually I mean according to the

00:20:07,919 --> 00:20:14,610
side we can go from the reference kind

00:20:10,590 --> 00:20:19,019
point to the same point as GC based so

00:20:14,610 --> 00:20:22,019
for most will be pretty the same so the

00:20:19,019 --> 00:20:25,830
purpose of reference counting is mainly

00:20:22,019 --> 00:20:28,139
iOS development why it's important

00:20:25,830 --> 00:20:31,049
because we want to have a good

00:20:28,139 --> 00:20:34,019
interoperability with native languages

00:20:31,049 --> 00:20:37,080
and for iOS native is Swift and

00:20:34,019 --> 00:20:40,080
objective-c which actually has no

00:20:37,080 --> 00:20:44,669
garbage collector they have reference

00:20:40,080 --> 00:20:47,460
counting memory model so that and they

00:20:44,669 --> 00:20:49,950
also have API for reference count that

00:20:47,460 --> 00:20:53,909
means that if our runtime we want to

00:20:49,950 --> 00:20:58,230
join with native iOS runtime we need to

00:20:53,909 --> 00:21:00,480
do this interoperability things and if

00:20:58,230 --> 00:21:03,990
both runtimes are reference counting

00:21:00,480 --> 00:21:07,710
then when we pass object we can wrap

00:21:03,990 --> 00:21:10,259
into some iOS wrapper and if we get

00:21:07,710 --> 00:21:12,360
objects from the Swift we can use this

00:21:10,259 --> 00:21:15,269
reference counting through the API so

00:21:12,360 --> 00:21:19,080
that's very simple and straightforward

00:21:15,269 --> 00:21:21,509
what is not and that's not obvious what

00:21:19,080 --> 00:21:25,110
to do with garbage collectors things so

00:21:21,509 --> 00:21:27,570
that means that that problem most

00:21:25,110 --> 00:21:30,119
probably if you want to run some program

00:21:27,570 --> 00:21:34,049
on Ras you will do everything on your

00:21:30,119 --> 00:21:36,600
own without using reusing some native

00:21:34,049 --> 00:21:41,039
libraries so that's that means lots of

00:21:36,600 --> 00:21:46,139
complications and that's why cotton

00:21:41,039 --> 00:21:48,690
native is now on the IRS it's it's going

00:21:46,139 --> 00:21:51,539
to be of course competitor to growl vien

00:21:48,690 --> 00:21:53,789
but again right now we are going to

00:21:51,539 --> 00:21:55,060
finish this technology for cross

00:21:53,789 --> 00:21:58,170
compilation between

00:21:55,060 --> 00:22:01,690
joint and Alice and having

00:21:58,170 --> 00:22:04,510
cross-compiled business logic between

00:22:01,690 --> 00:22:06,910
these two platforms so that the most

00:22:04,510 --> 00:22:10,710
interesting thing around content native

00:22:06,910 --> 00:22:17,170
because we have own purpose and we want

00:22:10,710 --> 00:22:20,440
to reach some point so we know exactly

00:22:17,170 --> 00:22:24,880
what to do what to implement next in for

00:22:20,440 --> 00:22:28,240
this technology and native world is

00:22:24,880 --> 00:22:31,870
quite wide I mean that lots of new

00:22:28,240 --> 00:22:34,900
things exist around that so one of them

00:22:31,870 --> 00:22:37,900
is actually also preview technology

00:22:34,900 --> 00:22:43,330
which is webassembly and coordinates

00:22:37,900 --> 00:22:46,210
already has experimental support but

00:22:43,330 --> 00:22:50,500
it's just verification of possibilities

00:22:46,210 --> 00:22:53,260
of Kotlin native runtime and again a

00:22:50,500 --> 00:22:56,010
reference counting showed that it's it's

00:22:53,260 --> 00:22:58,480
quite nice and cotton right now it's

00:22:56,010 --> 00:23:02,490
probably the third language supported

00:22:58,480 --> 00:23:05,770
for webassembly have to see and rust and

00:23:02,490 --> 00:23:08,620
webassembly is very interesting

00:23:05,770 --> 00:23:12,120
technology I think it it will be widely

00:23:08,620 --> 00:23:18,100
used in the future instead of JavaScript

00:23:12,120 --> 00:23:21,220
and the last possible a promising target

00:23:18,100 --> 00:23:24,520
is embedded devices and what I want to

00:23:21,220 --> 00:23:28,480
say that it's it's very conservative

00:23:24,520 --> 00:23:32,350
market because some problems or bugs

00:23:28,480 --> 00:23:35,620
means loss losses in in millions of

00:23:32,350 --> 00:23:37,720
dollars so that's why managers don't

00:23:35,620 --> 00:23:41,920
want to switch technologists from one to

00:23:37,720 --> 00:23:44,170
one and also for speaking about language

00:23:41,920 --> 00:23:47,650
itself I mean Scala need for cognitive

00:23:44,170 --> 00:23:49,840
it means that you need to put a lot of

00:23:47,650 --> 00:23:52,890
effort to support different devices you

00:23:49,840 --> 00:23:56,950
can choose the single device like stm32

00:23:52,890 --> 00:24:00,430
and try to support everything but market

00:23:56,950 --> 00:24:02,590
it will be you will be so small so it's

00:24:00,430 --> 00:24:05,140
it's it's really hard to understand if

00:24:02,590 --> 00:24:08,200
it's suitable to do that or not

00:24:05,140 --> 00:24:13,529
I mean for example compared to I

00:24:08,200 --> 00:24:17,980
market which is much much bigger so and

00:24:13,529 --> 00:24:20,710
just some play of words for for the fun

00:24:17,980 --> 00:24:23,230
I mean that you know the main difference

00:24:20,710 --> 00:24:26,649
between cotton not actually mean but one

00:24:23,230 --> 00:24:29,980
of the biggest differences is which K

00:24:26,649 --> 00:24:33,100
word to use for function definition so

00:24:29,980 --> 00:24:36,399
this is fun of def with this two

00:24:33,100 --> 00:24:38,380
different key words so I I can show you

00:24:36,399 --> 00:24:41,559
the right choice I mean that's it's

00:24:38,380 --> 00:24:45,100
another play of worth because right is

00:24:41,559 --> 00:24:47,980
deaf I mean that's what we can see when

00:24:45,100 --> 00:24:53,710
we use on flights so left is ABC and

00:24:47,980 --> 00:25:00,360
right is def so pretty tricky player

00:24:53,710 --> 00:25:06,250
first but anyway mmm that's for fun so

00:25:00,360 --> 00:25:12,630
let's do some ID basics what I want to

00:25:06,250 --> 00:25:15,309
show so sure

00:25:12,630 --> 00:25:21,070
actually I wanted to show you some

00:25:15,309 --> 00:25:25,240
highest stuff I mean this is application

00:25:21,070 --> 00:25:28,480
which we did for cotton conf and the

00:25:25,240 --> 00:25:31,240
most interesting is that it's entirely

00:25:28,480 --> 00:25:38,019
implemented in cotton native so all

00:25:31,240 --> 00:25:40,899
things like server client common line

00:25:38,019 --> 00:25:43,809
interface iOS stuff and Android

00:25:40,899 --> 00:25:46,330
everything was were implemented in in

00:25:43,809 --> 00:25:49,929
the same language so that's pretty nice

00:25:46,330 --> 00:25:53,380
actually code looks a bit scary again

00:25:49,929 --> 00:25:55,720
because lots of usage of native

00:25:53,380 --> 00:25:58,809
libraries I mean when you when you use

00:25:55,720 --> 00:26:03,700
any native fibers it means that it will

00:25:58,809 --> 00:26:06,250
be scary in any way of I mean that even

00:26:03,700 --> 00:26:08,710
in cotton or Scala if you want to use

00:26:06,250 --> 00:26:12,909
when we can't use native fibers because

00:26:08,710 --> 00:26:16,450
they they have a lot of lots of years of

00:26:12,909 --> 00:26:19,480
development I mean lots of developers

00:26:16,450 --> 00:26:21,110
did so many things so it's cool to

00:26:19,480 --> 00:26:24,590
actually

00:26:21,110 --> 00:26:29,300
we use this stuff but speaking about

00:26:24,590 --> 00:26:31,640
language itself it definitely have some

00:26:29,300 --> 00:26:35,090
wrapper library over this native thing

00:26:31,640 --> 00:26:37,970
so that's that's what going on here so

00:26:35,090 --> 00:26:42,530
like we can use database like SQL Lite

00:26:37,970 --> 00:26:47,660
which is also very native library so

00:26:42,530 --> 00:26:52,600
what I can show here is like debugging

00:26:47,660 --> 00:26:52,600
stuff we can run for example server here

00:26:52,870 --> 00:26:58,580
and we can put something like okay you

00:26:56,960 --> 00:27:02,350
can see that it's not stable

00:26:58,580 --> 00:27:05,560
I put breakpoint and everything stopped

00:27:02,350 --> 00:27:14,210
so breakpoint you hit it here and we can

00:27:05,560 --> 00:27:18,560
go to the from and we can see here hit

00:27:14,210 --> 00:27:22,070
of the debugger and that's that's so

00:27:18,560 --> 00:27:25,390
tricky thing I mean the debugging stuff

00:27:22,070 --> 00:27:28,970
which is very simply available in GBM

00:27:25,390 --> 00:27:30,770
when we have Java debugger interface so

00:27:28,970 --> 00:27:33,830
we can do lots of stuff with this

00:27:30,770 --> 00:27:38,420
interface and implement that and with in

00:27:33,830 --> 00:27:41,330
native world we have adult DB so some

00:27:38,420 --> 00:27:45,500
some scary words like a dwarf and other

00:27:41,330 --> 00:27:48,920
things and it's very low level so if we

00:27:45,500 --> 00:27:53,600
want to put things into ID stuff we need

00:27:48,920 --> 00:27:57,530
to put a lot of effort and we actually

00:27:53,600 --> 00:28:00,800
do can do these stepping things and even

00:27:57,530 --> 00:28:04,430
see here some data which we you can see

00:28:00,800 --> 00:28:07,360
a renders some a bit slow so we even can

00:28:04,430 --> 00:28:13,550
see objects and something inside of it

00:28:07,360 --> 00:28:17,050
so kicking about IDE we can see what

00:28:13,550 --> 00:28:19,880
what what is already works as for Scala

00:28:17,050 --> 00:28:22,490
front-end and for example IntelliJ IDEA

00:28:19,880 --> 00:28:26,810
is already works because it's pretty the

00:28:22,490 --> 00:28:31,580
same like Scala for GBM it also uses

00:28:26,810 --> 00:28:34,759
Java standards library so we can just

00:28:31,580 --> 00:28:37,129
put GDK jars and

00:28:34,759 --> 00:28:40,820
everything will be fine with this color

00:28:37,129 --> 00:28:43,940
front and inside of IntelliJ IDEA and

00:28:40,820 --> 00:28:46,879
speaking about for example cotton we

00:28:43,940 --> 00:28:50,059
need to remove this old Java stuff

00:28:46,879 --> 00:28:53,419
because general library is lack of that

00:28:50,059 --> 00:28:57,589
but cotton already has this presentation

00:28:53,419 --> 00:29:01,009
compiler stuff which is reused in inside

00:28:57,589 --> 00:29:06,139
of IDE so everything works more or less

00:29:01,009 --> 00:29:09,709
ok so another thing is that actually

00:29:06,139 --> 00:29:13,269
what we can we can see in IntelliJ I

00:29:09,709 --> 00:29:21,049
mean Scala speaking about Scala that

00:29:13,269 --> 00:29:23,989
here we can we have all the Java stuff

00:29:21,049 --> 00:29:28,429
like Java scroll here because it's it's

00:29:23,989 --> 00:29:31,219
hold the GDK added to the project but

00:29:28,429 --> 00:29:33,799
actually for example for first car

00:29:31,219 --> 00:29:38,299
native SQL stuff is not implemented so

00:29:33,799 --> 00:29:43,159
that's that's kind of green code which

00:29:38,299 --> 00:29:46,399
should be read and that's I think it's

00:29:43,159 --> 00:29:49,940
just small thing I mean that in native

00:29:46,399 --> 00:29:53,479
world we can see libraries here you can

00:29:49,940 --> 00:29:56,299
see like Java link and you can see this

00:29:53,479 --> 00:30:00,589
stuff like near native intermediate

00:29:56,299 --> 00:30:05,869
representation here we also can see here

00:30:00,589 --> 00:30:10,249
some code which is available to to

00:30:05,869 --> 00:30:13,190
analyze and reuse here actually this is

00:30:10,249 --> 00:30:15,649
output stuff but I mean that if we want

00:30:13,190 --> 00:30:18,919
to take a look into the native scallop

00:30:15,649 --> 00:30:21,679
for example we can see the library which

00:30:18,919 --> 00:30:24,409
has this native intermediate

00:30:21,679 --> 00:30:26,929
representation first of all and we also

00:30:24,409 --> 00:30:29,869
have sources here that's how it works

00:30:26,929 --> 00:30:33,829
also already so we put into beti

00:30:29,869 --> 00:30:36,799
dependences for these libraries and IDE

00:30:33,829 --> 00:30:40,190
can get them and see them as ordinary

00:30:36,799 --> 00:30:41,989
and dependency in like India and for

00:30:40,190 --> 00:30:44,209
binaries we have this native

00:30:41,989 --> 00:30:46,929
intermediate representation which P will

00:30:44,209 --> 00:30:50,380
be compiled into the

00:30:46,929 --> 00:30:52,510
bit caught afterwards so the problem

00:30:50,380 --> 00:30:54,880
only problem is that in Java standard

00:30:52,510 --> 00:31:01,630
library which is used for Scala native

00:30:54,880 --> 00:31:06,070
we can seek it Java lib here so we can

00:31:01,630 --> 00:31:09,399
see that there is no sources here so the

00:31:06,070 --> 00:31:11,529
problem is quite a small I mean from the

00:31:09,399 --> 00:31:13,980
Scala native perspective we just need to

00:31:11,529 --> 00:31:16,779
rebuild library to have these sources

00:31:13,980 --> 00:31:20,529
but from the ID perspective it means

00:31:16,779 --> 00:31:23,409
that we need to avoid this GDK inside

00:31:20,529 --> 00:31:25,000
the project somehow it's also pretty

00:31:23,409 --> 00:31:29,830
simple but I mean that it's small things

00:31:25,000 --> 00:31:37,059
which requires a lot of version I mean a

00:31:29,830 --> 00:31:42,130
lot of people work in content so that

00:31:37,059 --> 00:31:46,389
that's and one thing is which is good I

00:31:42,130 --> 00:31:49,809
mean that sources are part of binaries

00:31:46,389 --> 00:31:51,850
and it's nice but it's nice when the

00:31:49,809 --> 00:31:53,740
world is completely open source but

00:31:51,850 --> 00:31:56,289
sometimes people want to share the

00:31:53,740 --> 00:31:58,809
library without sharing these sources so

00:31:56,289 --> 00:32:01,779
that's another thing which is required

00:31:58,809 --> 00:32:03,639
to implement I mean that the native

00:32:01,779 --> 00:32:06,250
intermediate representation should be

00:32:03,639 --> 00:32:09,010
decompile somehow into sources so ID

00:32:06,250 --> 00:32:13,120
should understand this stuff from native

00:32:09,010 --> 00:32:16,210
intermediate representation so in Kotlin

00:32:13,120 --> 00:32:19,510
it's already implemented as we again we

00:32:16,210 --> 00:32:24,789
are using a compiler stuff for decompile

00:32:19,510 --> 00:32:27,990
and in in Scala it will require a lot of

00:32:24,789 --> 00:32:34,480
effort the same like we did for

00:32:27,990 --> 00:32:36,039
decompiling java classes and the another

00:32:34,480 --> 00:32:39,070
thing is platform specific

00:32:36,039 --> 00:32:42,519
implementation so we have a Linux

00:32:39,070 --> 00:32:48,059
support Mac OS but no windows and one of

00:32:42,519 --> 00:32:48,059
the problems is that it's around

00:32:48,360 --> 00:32:55,240
requires some implement reimplementation

00:32:51,039 --> 00:32:57,370
of lots of Java libraries and also it

00:32:55,240 --> 00:33:00,160
requires lots of effort

00:32:57,370 --> 00:33:02,380
of bigger team because small team can

00:33:00,160 --> 00:33:06,240
support just one platform target and

00:33:02,380 --> 00:33:09,070
bigger team can do different things so

00:33:06,240 --> 00:33:16,780
and cross target in compilation is

00:33:09,070 --> 00:33:21,300
another point where we can cross compile

00:33:16,780 --> 00:33:23,530
through the build system and to see this

00:33:21,300 --> 00:33:26,290
just to do very complicated

00:33:23,530 --> 00:33:31,450
multi-platform stuff what is cool

00:33:26,290 --> 00:33:33,580
already in cotton I hope that I do the

00:33:31,450 --> 00:33:36,450
boss I mean I said what is cool around

00:33:33,580 --> 00:33:40,240
Scala and bought a school around cotton

00:33:36,450 --> 00:33:44,020
so but I mean that what is cool in

00:33:40,240 --> 00:33:46,120
cotton because language supports multi

00:33:44,020 --> 00:33:52,050
platform projects so you can implement

00:33:46,120 --> 00:33:55,810
the core stuff and put somewhere expect

00:33:52,050 --> 00:33:58,120
declarations and in platform specific

00:33:55,810 --> 00:34:00,820
implementations you can actually add

00:33:58,120 --> 00:34:03,130
actual implementations for this expected

00:34:00,820 --> 00:34:07,210
from declarations and that means you can

00:34:03,130 --> 00:34:10,510
design library which is which has common

00:34:07,210 --> 00:34:13,480
part and this part will be dependency

00:34:10,510 --> 00:34:17,290
for for your project and platform

00:34:13,480 --> 00:34:20,830
specific parts will be added in in the

00:34:17,290 --> 00:34:23,890
platform models so that's that's also

00:34:20,830 --> 00:34:28,210
what what needed to be supported by in

00:34:23,890 --> 00:34:30,550
future so the the problematic place as I

00:34:28,210 --> 00:34:34,030
already showed easy bugger debugger

00:34:30,550 --> 00:34:37,300
requires implementations for these

00:34:34,030 --> 00:34:41,380
low-level things and in ID it's quite a

00:34:37,300 --> 00:34:43,960
huge amount of work even simple things

00:34:41,380 --> 00:34:48,190
like exceptions text traces is is

00:34:43,960 --> 00:34:51,700
already problematic so let's try to do

00:34:48,190 --> 00:34:59,800
something live for example led to

00:34:51,700 --> 00:35:04,300
another object this function foo which

00:34:59,800 --> 00:35:07,750
actually sort false for example so if

00:35:04,300 --> 00:35:09,440
you want to see the exception we can

00:35:07,750 --> 00:35:18,950
call this C dot

00:35:09,440 --> 00:35:22,010
so let's do the link again and see

00:35:18,950 --> 00:35:24,110
what's what what we'll see so we will

00:35:22,010 --> 00:35:29,660
see the actual strict race and it's

00:35:24,110 --> 00:35:32,390
already problematic because it doesn't

00:35:29,660 --> 00:35:33,830
have even information about lines inside

00:35:32,390 --> 00:35:37,160
of this stack trace

00:35:33,830 --> 00:35:47,350
so debugging problems with exceptions is

00:35:37,160 --> 00:35:51,410
already tricky thing so let's run it and

00:35:47,350 --> 00:35:54,050
we can see here this stack trace but

00:35:51,410 --> 00:35:57,410
there is no source information there is

00:35:54,050 --> 00:35:59,330
no line information and it's very

00:35:57,410 --> 00:36:04,250
complicated thing how to put this into

00:35:59,330 --> 00:36:08,480
Bitcoin and we need to also support from

00:36:04,250 --> 00:36:12,050
the binaries for the breakpoints so

00:36:08,480 --> 00:36:15,290
that's one of the reasons why we chose C

00:36:12,050 --> 00:36:20,540
line because it already has some ll DB

00:36:15,290 --> 00:36:24,410
support so we did not so many things to

00:36:20,540 --> 00:36:29,870
already to have this breakpoint and

00:36:24,410 --> 00:36:32,410
stepping stuff but we have this

00:36:29,870 --> 00:36:35,270
breakpoint and basic stepping but now

00:36:32,410 --> 00:36:37,940
proper variables view I mean it as you

00:36:35,270 --> 00:36:41,960
can as you saw it's slow and it shows

00:36:37,940 --> 00:36:44,900
this query addresses instead of actual

00:36:41,960 --> 00:36:47,450
values so it's also requires lots of

00:36:44,900 --> 00:36:50,210
things and full evaluate expression

00:36:47,450 --> 00:36:53,270
stuff not even full even just probably

00:36:50,210 --> 00:36:57,080
call some function so this is already

00:36:53,270 --> 00:37:01,450
quite a tricky thing inside of a runtime

00:36:57,080 --> 00:37:03,170
of native stuff it requires a kind of

00:37:01,450 --> 00:37:05,450
reflective library

00:37:03,170 --> 00:37:08,120
what is also becomes a problematic

00:37:05,450 --> 00:37:11,780
because native world and don't have

00:37:08,120 --> 00:37:14,180
reflection so that's that's why our gvm

00:37:11,780 --> 00:37:17,270
world who looks quite quite a nice

00:37:14,180 --> 00:37:19,640
because we have everything we would like

00:37:17,270 --> 00:37:23,600
to have and in native it's it's very

00:37:19,640 --> 00:37:26,650
very low level develop

00:37:23,600 --> 00:37:32,380
so that's all I wanted to share with you

00:37:26,650 --> 00:37:35,540
so what I want to tell you is that

00:37:32,380 --> 00:37:38,420
cotton native is actually has very

00:37:35,540 --> 00:37:42,610
pretty good reason why this technology

00:37:38,420 --> 00:37:45,800
exists I mean it's it's tries to

00:37:42,610 --> 00:37:48,770
continue our market which is Android

00:37:45,800 --> 00:37:51,740
developers we want to give them

00:37:48,770 --> 00:37:54,770
possibility to share their code on iOS

00:37:51,740 --> 00:37:58,940
so that's the main purpose of cotton

00:37:54,770 --> 00:38:01,310
native technology and for me it looks

00:37:58,940 --> 00:38:05,680
pretty cool even now so it's it's it's

00:38:01,310 --> 00:38:08,150
in preview stage and probably

00:38:05,680 --> 00:38:12,440
nobody uses in production people

00:38:08,150 --> 00:38:15,320
probably starts to try it just to see

00:38:12,440 --> 00:38:19,310
how it works but it's already cool

00:38:15,320 --> 00:38:21,860
already lots of people wants to try so

00:38:19,310 --> 00:38:24,350
that that's that's why we are excited

00:38:21,860 --> 00:38:28,520
around this technology but speaking

00:38:24,350 --> 00:38:31,130
about scale native I I really saw it

00:38:28,520 --> 00:38:34,040
it's it's really cool it looks nice and

00:38:31,130 --> 00:38:38,920
a lot of effort already done for that

00:38:34,040 --> 00:38:42,140
but III didn't find a good reason to

00:38:38,920 --> 00:38:46,490
which point it moves because too many

00:38:42,140 --> 00:38:48,680
points we can reach again I mean I

00:38:46,490 --> 00:38:53,660
showed embedded devices rebus and with

00:38:48,680 --> 00:38:56,000
stuff iOS things and for small team it's

00:38:53,660 --> 00:39:01,370
even more important to choose this

00:38:56,000 --> 00:39:03,860
direction exact direction so and with

00:39:01,370 --> 00:39:06,560
yesterday talked about around growl VM

00:39:03,860 --> 00:39:08,990
the future is even more complicated I

00:39:06,560 --> 00:39:12,220
mean that it's simple thing just not to

00:39:08,990 --> 00:39:15,290
do anything and okay let's take RAL VM

00:39:12,220 --> 00:39:18,770
so that the question is even more tough

00:39:15,290 --> 00:39:21,130
the reason is required so that's that's

00:39:18,770 --> 00:39:21,130
my

00:39:21,339 --> 00:39:27,360
thoughts so thank you any questions okay

00:39:24,849 --> 00:39:30,329
thank you very much Alexandra

00:39:27,360 --> 00:39:38,200
[Applause]

00:39:30,329 --> 00:39:40,930
are there any questions yes are there

00:39:38,200 --> 00:39:43,719
any plans to have a standard library

00:39:40,930 --> 00:39:46,059
that you could use across iOS or other

00:39:43,719 --> 00:39:49,299
Scullin cotton native targets and

00:39:46,059 --> 00:39:53,619
Android and the JVM may be a subset of

00:39:49,299 --> 00:39:55,900
what you offer on the JVM we have we are

00:39:53,619 --> 00:39:59,710
working right now on implementing

00:39:55,900 --> 00:40:03,940
different libraries like for HTTP

00:39:59,710 --> 00:40:07,450
requests for serialization stuff as well

00:40:03,940 --> 00:40:10,210
as Cortines which is library for

00:40:07,450 --> 00:40:14,920
multi-threading so even these three

00:40:10,210 --> 00:40:16,599
things is lots of hello a lot for

00:40:14,920 --> 00:40:21,569
implementing lots of business logic

00:40:16,599 --> 00:40:21,569
around applications mobile applications

00:40:21,989 --> 00:40:26,890
but but it's not going to be standard I

00:40:24,700 --> 00:40:30,839
mean that it is from JetBrains but

00:40:26,890 --> 00:40:30,839

YouTube URL: https://www.youtube.com/watch?v=2ayOpO3QcN0


