Title: Serialization Protocols with Scala by Christian Uhl
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6929-serialization-protocols-with-scala.html
Captions: 
	00:00:04,800 --> 00:00:10,420
so hello everybody thanks for showing up

00:00:08,290 --> 00:00:13,000
so late in the evening I'm I'm stunned

00:00:10,420 --> 00:00:15,100
and I'm it's crazy you're all the way

00:00:13,000 --> 00:00:18,450
he's still can make it need some more

00:00:15,100 --> 00:00:20,679
coffee well thanks for showing up so

00:00:18,450 --> 00:00:24,369
we're gonna talk about serialization

00:00:20,679 --> 00:00:27,009
protocols in Scala today and first of

00:00:24,369 --> 00:00:31,750
all like what I always like to do is and

00:00:27,009 --> 00:00:33,970
present in a talk is is the why and even

00:00:31,750 --> 00:00:36,190
before that is I'd like to talk a bit

00:00:33,970 --> 00:00:38,800
about how I came to this talk because it

00:00:36,190 --> 00:00:40,750
was a once in a lifetime unicorn event

00:00:38,800 --> 00:00:43,420
that I used to work as a consultant for

00:00:40,750 --> 00:00:46,000
concentric working on a customer project

00:00:43,420 --> 00:00:48,280
and we were in a situation to decide

00:00:46,000 --> 00:00:51,489
which serialization protocol to use and

00:00:48,280 --> 00:00:53,859
the once-in-a-lifetime event was we had

00:00:51,489 --> 00:00:56,050
time to research we had time to think

00:00:53,859 --> 00:00:58,090
about that and yeah we wrote something

00:00:56,050 --> 00:01:00,609
together made like nice little wiki

00:00:58,090 --> 00:01:03,640
pages and I thought well the results of

00:01:00,609 --> 00:01:05,140
what we of the research we did was kind

00:01:03,640 --> 00:01:08,080
of useful for everybody else so I made

00:01:05,140 --> 00:01:10,600
this talk out of that and now for the

00:01:08,080 --> 00:01:12,780
reasoning why would you bother why would

00:01:10,600 --> 00:01:15,790
you bother with serious aging protocols

00:01:12,780 --> 00:01:17,310
I would say the the most important

00:01:15,790 --> 00:01:20,229
aspect that we have right now is that

00:01:17,310 --> 00:01:22,150
system designs is changing if you have

00:01:20,229 --> 00:01:25,509
been to meetups kind of like three years

00:01:22,150 --> 00:01:27,159
before to use before microservices was

00:01:25,509 --> 00:01:29,259
all the rage right everybody was talking

00:01:27,159 --> 00:01:34,030
about how to do micro services how to

00:01:29,259 --> 00:01:35,740
build them and yeah suddenly these these

00:01:34,030 --> 00:01:37,479
little things are now mainstream you see

00:01:35,740 --> 00:01:40,149
them everywhere everyone does micro

00:01:37,479 --> 00:01:44,079
services or already monoliths again dn't

00:01:40,149 --> 00:01:46,030
or to step that step and then kept them

00:01:44,079 --> 00:01:50,049
on earth but yeah they show up

00:01:46,030 --> 00:01:52,000
everywhere and even after that accuse

00:01:50,049 --> 00:01:53,890
are showing up in these micro services

00:01:52,000 --> 00:01:57,430
architecture to not everybody is doing

00:01:53,890 --> 00:01:59,200
direct synchronous rest calls but some

00:01:57,430 --> 00:02:01,920
people are using queues to communicate

00:01:59,200 --> 00:02:06,250
some people abuse distributed message

00:02:01,920 --> 00:02:09,850
distributed locks as queues and still

00:02:06,250 --> 00:02:12,160
use that and I think just one year ago I

00:02:09,850 --> 00:02:15,010
was still listening to all these bank

00:02:12,160 --> 00:02:17,530
talks about or giving us the bank

00:02:15,010 --> 00:02:18,550
account example for for secure s and

00:02:17,530 --> 00:02:21,250
event sourcing

00:02:18,550 --> 00:02:25,390
and now even these show up in in system

00:02:21,250 --> 00:02:27,460
designs and finally hopefully finally

00:02:25,390 --> 00:02:28,870
where we're not using databases as

00:02:27,460 --> 00:02:34,180
integration layers anymore

00:02:28,870 --> 00:02:38,020
so you do I'll find you I'll poke you if

00:02:34,180 --> 00:02:41,470
you do so that brings us to some pretty

00:02:38,020 --> 00:02:45,700
fundamental changes in how we are

00:02:41,470 --> 00:02:47,320
designing systems and I like that that

00:02:45,700 --> 00:02:49,360
tweet from Tim parrot very much where he

00:02:47,320 --> 00:02:51,130
said the distributed systems are about

00:02:49,360 --> 00:02:52,870
protocols not about implementations

00:02:51,130 --> 00:02:55,600
because if you look at the distribution

00:02:52,870 --> 00:02:58,090
of complexity or the overall issues that

00:02:55,600 --> 00:02:59,650
you have or just the amount of pain that

00:02:58,090 --> 00:03:03,340
you feel when building these systems

00:02:59,650 --> 00:03:05,200
then it's mostly about the communication

00:03:03,340 --> 00:03:09,400
between the little pieces and not about

00:03:05,200 --> 00:03:11,950
how to implement a restful api service

00:03:09,400 --> 00:03:14,500
in in play with AK h TDP or so it that

00:03:11,950 --> 00:03:16,480
kind of always works the same but to

00:03:14,500 --> 00:03:20,350
wire these parts together suddenly gets

00:03:16,480 --> 00:03:22,959
very crazy and also just recently I read

00:03:20,350 --> 00:03:24,940
a book from Rebecca Parsons and from neo

00:03:22,959 --> 00:03:27,280
Ford and Patrick cooiie about

00:03:24,940 --> 00:03:29,650
evolutionary architectures and they

00:03:27,280 --> 00:03:31,600
don't talk much about serialization but

00:03:29,650 --> 00:03:34,000
they talk a lot about building

00:03:31,600 --> 00:03:37,530
evolutionary architectures architectures

00:03:34,000 --> 00:03:41,110
that adopt themselves to change and

00:03:37,530 --> 00:03:44,650
architectures that have changed as a

00:03:41,110 --> 00:03:46,330
core competence or as a core principle

00:03:44,650 --> 00:03:49,300
in their design

00:03:46,330 --> 00:03:51,720
so yeah other people are picking up on

00:03:49,300 --> 00:03:54,880
that too the writing books about it and

00:03:51,720 --> 00:03:56,410
since I keep using that word I make up

00:03:54,880 --> 00:03:58,900
my own definition because I didn't find

00:03:56,410 --> 00:04:02,560
anyone who had a good one if you find

00:03:58,900 --> 00:04:04,900
one please send it to me I will proclaim

00:04:02,560 --> 00:04:07,200
that evolvability means the ability of a

00:04:04,900 --> 00:04:09,340
system and its data to adopt to change

00:04:07,200 --> 00:04:11,709
and that's gonna be the working

00:04:09,340 --> 00:04:15,700
definition that we have here for for the

00:04:11,709 --> 00:04:18,820
scope of this talk and if you remember

00:04:15,700 --> 00:04:20,859
the very bad old times that we had when

00:04:18,820 --> 00:04:23,650
we were working on very big monolithic

00:04:20,859 --> 00:04:26,160
systems and very big very expensive

00:04:23,650 --> 00:04:30,180
databases from a company with the Big O

00:04:26,160 --> 00:04:32,320
and we were doing our our migrations and

00:04:30,180 --> 00:04:34,540
we were changing something yeah we

00:04:32,320 --> 00:04:36,820
had to do a schema migration of of the

00:04:34,540 --> 00:04:39,970
database which would usually anger the

00:04:36,820 --> 00:04:42,550
DBAs and we would do our code changes

00:04:39,970 --> 00:04:44,530
and in the end we would do one very big

00:04:42,550 --> 00:04:46,210
deployment which was planned for weeks

00:04:44,530 --> 00:04:50,650
and it would fail and foot's

00:04:46,210 --> 00:04:52,660
was all very horrible and but that's not

00:04:50,650 --> 00:04:55,810
the case anymore we cannot afford to be

00:04:52,660 --> 00:04:57,940
that slow and our systems do not do an

00:04:55,810 --> 00:04:59,500
overt their way anymore because we now

00:04:57,940 --> 00:05:02,380
have as I told before we have replicated

00:04:59,500 --> 00:05:04,420
systems are not just distributed but

00:05:02,380 --> 00:05:06,850
replicated systems that's kind of the

00:05:04,420 --> 00:05:08,770
the easiest case of the problem right

00:05:06,850 --> 00:05:09,490
you have not just one instance of your

00:05:08,770 --> 00:05:11,080
monolith

00:05:09,490 --> 00:05:12,520
you want to have maybe three instances

00:05:11,080 --> 00:05:16,390
and maybe they need to communicate

00:05:12,520 --> 00:05:18,880
between each other or you have

00:05:16,390 --> 00:05:21,700
distributed systems in your data center

00:05:18,880 --> 00:05:23,410
or maybe you're even doing server less

00:05:21,700 --> 00:05:28,330
because it's all the rage and you've

00:05:23,410 --> 00:05:30,370
been to an AWS keynote and now some very

00:05:28,330 --> 00:05:32,770
fun thing that I I keep struggling with

00:05:30,370 --> 00:05:34,480
or I keep messing up is even

00:05:32,770 --> 00:05:36,990
distributing some things to the user

00:05:34,480 --> 00:05:40,120
which means a fat client or even

00:05:36,990 --> 00:05:42,640
sessions stored in anything you push out

00:05:40,120 --> 00:05:46,600
to the user or your clients kind of

00:05:42,640 --> 00:05:49,150
makes it distributed a bit and one of my

00:05:46,600 --> 00:05:51,790
famous mistakes that I keep doing is if

00:05:49,150 --> 00:05:54,730
you have any kind of web application and

00:05:51,790 --> 00:05:57,130
you have any sort of authentication

00:05:54,730 --> 00:05:58,900
authorization system what do you do you

00:05:57,130 --> 00:06:01,540
have some sort of you use a class that

00:05:58,900 --> 00:06:03,280
you store in a cookie and what happens

00:06:01,540 --> 00:06:05,980
you change the user so your cookie

00:06:03,280 --> 00:06:07,720
doesn't match and you back-and-forth and

00:06:05,980 --> 00:06:09,430
suddenly users cannot log in anymore

00:06:07,720 --> 00:06:11,860
locked in users cannot access anything

00:06:09,430 --> 00:06:16,210
anymore so that keeps happening to me

00:06:11,860 --> 00:06:18,220
and so therefore I would say there's

00:06:16,210 --> 00:06:22,270
more distribution in your system that

00:06:18,220 --> 00:06:23,620
you might even be aware of and yeah

00:06:22,270 --> 00:06:27,880
these systems they exchange information

00:06:23,620 --> 00:06:29,710
all the time right and that is is

00:06:27,880 --> 00:06:34,000
problematic because these systems are

00:06:29,710 --> 00:06:37,330
also changing all the time and one more

00:06:34,000 --> 00:06:40,360
one more final thing to do to to

00:06:37,330 --> 00:06:42,250
finalize some words that we have is in

00:06:40,360 --> 00:06:45,669
our community we like to invent a lot of

00:06:42,250 --> 00:06:46,480
words and one of them and usually we

00:06:45,669 --> 00:06:47,980
like to invent verse

00:06:46,480 --> 00:06:52,420
for things we already have a concept for

00:06:47,980 --> 00:06:55,260
and here it's encoded Z realized a

00:06:52,420 --> 00:06:58,800
marshalled and it's it's counterpart of

00:06:55,260 --> 00:07:01,390
decoded deserialize and unmarshal

00:06:58,800 --> 00:07:03,130
depending on which which classes you

00:07:01,390 --> 00:07:05,290
have honor which goggles you have on it

00:07:03,130 --> 00:07:06,970
it kind of always looks the same and for

00:07:05,290 --> 00:07:08,500
the sake of this talk I'm gonna go with

00:07:06,970 --> 00:07:11,620
serialized and deserialized

00:07:08,500 --> 00:07:16,930
and I mean all the other things by that

00:07:11,620 --> 00:07:19,840
as well so yeah we we got problems so

00:07:16,930 --> 00:07:21,400
yeah I think we understood that now and

00:07:19,840 --> 00:07:25,540
the question is well how can we deal

00:07:21,400 --> 00:07:27,250
with this the first one which usually

00:07:25,540 --> 00:07:29,080
comes tomorrow comes to mind if you're

00:07:27,250 --> 00:07:33,010
having any kind of programming languages

00:07:29,080 --> 00:07:35,920
be it Scala be a Java B Python they all

00:07:33,010 --> 00:07:38,850
have something programming language

00:07:35,920 --> 00:07:41,740
provided so we have Scala serializable

00:07:38,850 --> 00:07:43,930
Python has its thing Java of course has

00:07:41,740 --> 00:07:47,950
its thing which Scala serializable

00:07:43,930 --> 00:07:53,830
builds up on so we could technically use

00:07:47,950 --> 00:07:56,230
it if you only take one thing home from

00:07:53,830 --> 00:07:58,690
this talk then do not use it and I will

00:07:56,230 --> 00:08:01,540
be talking a great length advising you

00:07:58,690 --> 00:08:03,160
not to use any of the defaults he

00:08:01,540 --> 00:08:05,020
realizes provided in your programming

00:08:03,160 --> 00:08:07,990
language because it makes your car burn

00:08:05,020 --> 00:08:12,160
it makes makes for a horrible source of

00:08:07,990 --> 00:08:13,840
mistakes so well the worst let's start

00:08:12,160 --> 00:08:16,260
with the obvious but not so important

00:08:13,840 --> 00:08:19,270
bad ones the first one is if you use

00:08:16,260 --> 00:08:22,330
Scala serializable you're bound to Scala

00:08:19,270 --> 00:08:26,290
only Scala code can access data that has

00:08:22,330 --> 00:08:28,450
been serialized by by Scala and that's a

00:08:26,290 --> 00:08:29,950
bit boring if you're in a in a more

00:08:28,450 --> 00:08:32,020
distributed environment where maybe

00:08:29,950 --> 00:08:34,630
other people you know these crazy guys

00:08:32,020 --> 00:08:36,250
with beards and they doing nodejs and

00:08:34,630 --> 00:08:37,470
such you probably want to talk to them

00:08:36,250 --> 00:08:44,229
even if you don't want to

00:08:37,470 --> 00:08:45,910
so think about them a second issue is

00:08:44,229 --> 00:08:48,880
that the poorer performance is just

00:08:45,910 --> 00:08:50,590
awful it's it was never meant as

00:08:48,880 --> 00:08:52,270
something really speedy even though

00:08:50,590 --> 00:08:54,280
there were a couple of performance

00:08:52,270 --> 00:08:59,710
enhancements in the JDK along the time

00:08:54,280 --> 00:09:00,410
it still is really annoying and beyond

00:08:59,710 --> 00:09:02,420
that it

00:09:00,410 --> 00:09:04,970
a couple of very very serious drawbacks

00:09:02,420 --> 00:09:06,980
and the first one is against me standing

00:09:04,970 --> 00:09:09,230
on the shoulders of giants quoting

00:09:06,980 --> 00:09:12,259
Joshua Bloch and his book effective Java

00:09:09,230 --> 00:09:14,839
that you really should have read like

00:09:12,259 --> 00:09:17,410
completely and he says you know you

00:09:14,839 --> 00:09:21,050
should be very cautious about or about

00:09:17,410 --> 00:09:22,639
implementing serializable so if you

00:09:21,050 --> 00:09:26,439
don't trust me trust this guy he knows

00:09:22,639 --> 00:09:29,209
what he's talking about and because well

00:09:26,439 --> 00:09:31,399
once you have released something and it

00:09:29,209 --> 00:09:34,730
starts your software is released and it

00:09:31,399 --> 00:09:36,350
starts serializing things it's really

00:09:34,730 --> 00:09:38,870
really hard to change things afterwards

00:09:36,350 --> 00:09:41,750
right because it's what the Java or the

00:09:38,870 --> 00:09:44,240
Scala the Java serializer does is just

00:09:41,750 --> 00:09:46,129
throw the binary right directly at it

00:09:44,240 --> 00:09:49,810
and then the JVM tries to figure out

00:09:46,129 --> 00:09:53,329
tries to make some sense out of it and

00:09:49,810 --> 00:09:54,769
that has the effect well which I really

00:09:53,329 --> 00:09:56,269
like that reasoning is that the

00:09:54,769 --> 00:09:58,490
implementation of your class the the

00:09:56,269 --> 00:10:01,129
inner structure of your class your most

00:09:58,490 --> 00:10:03,500
inner fundamental secrets that you want

00:10:01,129 --> 00:10:06,410
to keep hidden you know from from your

00:10:03,500 --> 00:10:08,689
clove from your separation of concerns

00:10:06,410 --> 00:10:10,880
principle everything becomes the API

00:10:08,689 --> 00:10:13,189
because everything is out there and you

00:10:10,880 --> 00:10:15,529
have to communicate with everybody out

00:10:13,189 --> 00:10:18,110
there and suddenly the laws of how you

00:10:15,529 --> 00:10:20,720
deal with api's which mostly means do

00:10:18,110 --> 00:10:24,160
not change them applies to your inner

00:10:20,720 --> 00:10:28,750
classes which is a really bad thing and

00:10:24,160 --> 00:10:32,449
since the the JDK is pretty naive about

00:10:28,750 --> 00:10:36,800
parsing the the things it gets from from

00:10:32,449 --> 00:10:39,769
serialized values means you can dump all

00:10:36,800 --> 00:10:42,380
sorts of that and it's it's it's crazy

00:10:39,769 --> 00:10:45,079
what you can do to your JVM and how you

00:10:42,380 --> 00:10:48,949
can execute code by just sneaky getting

00:10:45,079 --> 00:10:51,230
in via to serializer so it's really

00:10:48,949 --> 00:10:54,529
really crazy and yeah of course

00:10:51,230 --> 00:10:57,170
if you're serializing data to disk and

00:10:54,529 --> 00:10:59,300
that is now your new API guess what you

00:10:57,170 --> 00:11:00,949
have to test it and so you have to test

00:10:59,300 --> 00:11:02,059
a lot of things suddenly if you want to

00:11:00,949 --> 00:11:07,009
make sure that your software is still

00:11:02,059 --> 00:11:09,829
correct and another giant that I'm that

00:11:07,009 --> 00:11:14,000
I'm standing on my you ago made at

00:11:09,829 --> 00:11:15,589
devoxx and a poll about

00:11:14,000 --> 00:11:18,290
which features are the most hated and

00:11:15,589 --> 00:11:23,120
guess what serializable is our

00:11:18,290 --> 00:11:25,129
serialization is number one because I

00:11:23,120 --> 00:11:29,050
would say after null it's the second

00:11:25,129 --> 00:11:32,120
billion dollar mistake of the JVM and

00:11:29,050 --> 00:11:34,339
yeah of course I'm a very naive persons

00:11:32,120 --> 00:11:36,800
I make a lot of issues and a lot of

00:11:34,339 --> 00:11:39,079
problems all the time so I had issues

00:11:36,800 --> 00:11:41,060
with ICO remoting I had issues with aqua

00:11:39,079 --> 00:11:45,529
cluster because they both also default

00:11:41,060 --> 00:11:48,019
to Java serialization it has not bitten

00:11:45,529 --> 00:11:50,949
me personally but with spark that's also

00:11:48,019 --> 00:11:53,540
using Java serialization to communicate

00:11:50,949 --> 00:11:55,250
if you get a hold of holding Cracow

00:11:53,540 --> 00:11:57,860
who's running around here at the

00:11:55,250 --> 00:12:00,470
conference I guess tomorrow and she has

00:11:57,860 --> 00:12:02,420
a good talk about that and yeah what I

00:12:00,470 --> 00:12:03,860
mentioned previously uses sessions with

00:12:02,420 --> 00:12:06,920
spring boot yeah

00:12:03,860 --> 00:12:10,129
also Java serialization also problems

00:12:06,920 --> 00:12:14,089
also locking out users also causing all

00:12:10,129 --> 00:12:15,410
kinds of horrible bugs so I hope you

00:12:14,089 --> 00:12:19,339
believe me that it's a really bad idea

00:12:15,410 --> 00:12:23,240
and one note about performance because I

00:12:19,339 --> 00:12:26,449
said yeah performance of the zero lies

00:12:23,240 --> 00:12:28,399
is awful it is and if you just roughly

00:12:26,449 --> 00:12:32,209
skim over the numbers it's it's not so

00:12:28,399 --> 00:12:35,480
much important how how they are they're

00:12:32,209 --> 00:12:38,000
mostly on par they're mostly kind of the

00:12:35,480 --> 00:12:43,129
same magnitude except for the zero line

00:12:38,000 --> 00:12:46,129
for the default JT JVM serialization so

00:12:43,129 --> 00:12:50,980
they they're roughly the same except for

00:12:46,129 --> 00:12:53,839
our odds odd one which is called default

00:12:50,980 --> 00:12:57,110
so in for the scope of this talk I mean

00:12:53,839 --> 00:12:59,779
I guess you won't be building the next

00:12:57,110 --> 00:13:02,809
whatsapp tomorrow but just a regular

00:12:59,779 --> 00:13:05,779
market a regular thing with like a

00:13:02,809 --> 00:13:07,759
hundred thousands of users and in scope

00:13:05,779 --> 00:13:10,100
of that you can treat them performance

00:13:07,759 --> 00:13:12,259
wise as equal the the four things I'm

00:13:10,100 --> 00:13:13,730
going to present to you later right if

00:13:12,259 --> 00:13:15,680
you need it really faster if you're

00:13:13,730 --> 00:13:19,309
building the next whatsapp or the next

00:13:15,680 --> 00:13:20,930
like high frequency trading platform you

00:13:19,309 --> 00:13:22,399
have to do a bit of more of research

00:13:20,930 --> 00:13:26,000
because then this talk will not be

00:13:22,399 --> 00:13:27,329
enough for you but so judge for yourself

00:13:26,000 --> 00:13:29,369
about

00:13:27,329 --> 00:13:32,129
much you want to believe me there and

00:13:29,369 --> 00:13:32,819
again just please don't use the built-in

00:13:32,129 --> 00:13:37,980
Siri Liza

00:13:32,819 --> 00:13:40,319
please I beg you and now of course if

00:13:37,980 --> 00:13:42,509
you're smart you you know about the

00:13:40,319 --> 00:13:44,459
these things called Jason or these if

00:13:42,509 --> 00:13:48,869
you want to party like it's 96 you use

00:13:44,459 --> 00:13:51,389
XML these things are widespread and I

00:13:48,869 --> 00:13:53,489
had colleagues in my career who who

00:13:51,389 --> 00:13:57,110
really enjoyed XML because they claimed

00:13:53,489 --> 00:13:59,489
it was a human readable and I I

00:13:57,110 --> 00:14:01,610
questioned their humanity afterwards but

00:13:59,489 --> 00:14:05,040
they they like to they like to read it

00:14:01,610 --> 00:14:07,709
so that would also be after the defaults

00:14:05,040 --> 00:14:11,009
you realize an interesting candidate to

00:14:07,709 --> 00:14:13,049
to serialize things to and the problem

00:14:11,009 --> 00:14:15,239
is they're still kind of slow depending

00:14:13,049 --> 00:14:18,600
on the benchmark you do like some say

00:14:15,239 --> 00:14:21,059
it's fast some say it slow and well they

00:14:18,600 --> 00:14:25,170
are verbose that what probably usually

00:14:21,059 --> 00:14:28,259
people mean by human readable and number

00:14:25,170 --> 00:14:30,449
handling in Jason because it belongs

00:14:28,259 --> 00:14:32,069
from the JavaScript ecosystem like so

00:14:30,449 --> 00:14:35,759
number handling is fundamentally broken

00:14:32,069 --> 00:14:37,949
and will never ever be fixed and a

00:14:35,759 --> 00:14:39,929
character encoding is also kind of

00:14:37,949 --> 00:14:42,569
difficult like say goodbye to YouTube

00:14:39,929 --> 00:14:48,149
fate and full compatibility if you wanna

00:14:42,569 --> 00:14:50,069
if you want to go that path and also you

00:14:48,149 --> 00:14:51,569
don't have any kind of schemas which can

00:14:50,069 --> 00:14:54,559
be a good thing can be a bad thing but

00:14:51,569 --> 00:14:57,389
for for more bigger more complex

00:14:54,559 --> 00:15:00,059
applications and since this is a Scala

00:14:57,389 --> 00:15:03,269
conference where everybody likes types

00:15:00,059 --> 00:15:07,379
I think people also like schemas instead

00:15:03,269 --> 00:15:10,199
of on schemas stuff so I'm not going too

00:15:07,379 --> 00:15:12,720
deep into detail for around

00:15:10,199 --> 00:15:15,439
JSON and XML and not I'm not going to be

00:15:12,720 --> 00:15:18,689
talking about peas and JSON schema and

00:15:15,439 --> 00:15:21,470
xst and all these friends of that

00:15:18,689 --> 00:15:25,279
ecosystem because in the most most

00:15:21,470 --> 00:15:29,069
important thing is schema evolve ability

00:15:25,279 --> 00:15:30,720
which all of them lack and this is gonna

00:15:29,069 --> 00:15:34,589
be one of the main features of the next

00:15:30,720 --> 00:15:36,360
candidates that we will see so what I'm

00:15:34,589 --> 00:15:40,079
what do I mean by that scheme I've

00:15:36,360 --> 00:15:41,070
evolved ability like if you just think

00:15:40,079 --> 00:15:44,730
that

00:15:41,070 --> 00:15:47,100
you have kind of it's one of the the

00:15:44,730 --> 00:15:50,070
apps I'm caring about at the moment it's

00:15:47,100 --> 00:15:51,630
this it's replicated but actually it

00:15:50,070 --> 00:15:53,250
doesn't have any load like most of our

00:15:51,630 --> 00:15:54,840
applications so we only replicate it

00:15:53,250 --> 00:15:58,350
three times because that's like the

00:15:54,840 --> 00:15:59,880
minimum number of replication but yeah

00:15:58,350 --> 00:16:01,830
you want to deploy it all the time right

00:15:59,880 --> 00:16:03,450
you change code you you have your

00:16:01,830 --> 00:16:05,970
continuous delivery pipeline set up

00:16:03,450 --> 00:16:08,490
perfectly so your versions just go out

00:16:05,970 --> 00:16:11,010
and but maybe you have some sort of

00:16:08,490 --> 00:16:13,620
message queue in the middle and then you

00:16:11,010 --> 00:16:15,720
have all kinds of messages from

00:16:13,620 --> 00:16:17,820
different versions up in that message

00:16:15,720 --> 00:16:20,460
queue like see there's still some

00:16:17,820 --> 00:16:23,310
version one running there's the headpin

00:16:20,460 --> 00:16:26,520
the version 90.9 and now you just

00:16:23,310 --> 00:16:28,380
deployed your version 2.0 and they are

00:16:26,520 --> 00:16:30,690
all running and they're all talking and

00:16:28,380 --> 00:16:33,420
they're all dumping their data onto you

00:16:30,690 --> 00:16:36,570
the message queue and well that's kind

00:16:33,420 --> 00:16:40,920
of a mess because they're 0.9 in 2.0 are

00:16:36,570 --> 00:16:42,660
probably very different so we can split

00:16:40,920 --> 00:16:45,630
the problem into halves one of them is

00:16:42,660 --> 00:16:47,040
backwards compatibility we say you

00:16:45,630 --> 00:16:49,320
deploy a new version and that new

00:16:47,040 --> 00:16:53,940
version survives reading all the data

00:16:49,320 --> 00:16:55,740
that if you think about naively it's

00:16:53,940 --> 00:16:57,810
doable because you know what the old

00:16:55,740 --> 00:17:00,660
data was so you can do all sorts of

00:16:57,810 --> 00:17:02,640
hacks and handles and do some

00:17:00,660 --> 00:17:05,400
compatibility layer yourself just to

00:17:02,640 --> 00:17:08,070
deal with if old do this if you do that

00:17:05,400 --> 00:17:12,089
that's doable it's it's annoying it's

00:17:08,070 --> 00:17:15,060
painful but you can survive that but on

00:17:12,089 --> 00:17:17,939
the other hand what's about forwards

00:17:15,060 --> 00:17:20,070
compatibility if you look at that

00:17:17,939 --> 00:17:21,930
extremely important architecture diagram

00:17:20,070 --> 00:17:23,520
here you see the old one is still

00:17:21,930 --> 00:17:27,540
running right it should also still

00:17:23,520 --> 00:17:29,160
survive reading the new messages so but

00:17:27,540 --> 00:17:31,470
how could you because the old

00:17:29,160 --> 00:17:33,990
application did not can never know about

00:17:31,470 --> 00:17:38,310
the new application and I'm usually very

00:17:33,990 --> 00:17:41,390
bad at predicting the future so this is

00:17:38,310 --> 00:17:44,430
kind of a hard hard problem to solve and

00:17:41,390 --> 00:17:46,710
this is exactly where protocols come

00:17:44,430 --> 00:17:50,460
into play because they can solve exactly

00:17:46,710 --> 00:17:52,530
this issue for us and first one of our

00:17:50,460 --> 00:17:53,840
friends that that we're gonna look at is

00:17:52,530 --> 00:17:57,679
protobuf

00:17:53,840 --> 00:17:59,000
protobuf is like great definition it's a

00:17:57,679 --> 00:18:01,730
language neutral platform neutral

00:17:59,000 --> 00:18:05,409
extensible mechanism XML but faster

00:18:01,730 --> 00:18:08,809
smaller and simpler it's from Google

00:18:05,409 --> 00:18:11,690
they build it they do the specification

00:18:08,809 --> 00:18:13,549
and luckily for us because Google likes

00:18:11,690 --> 00:18:15,200
to invent things and dump things and

00:18:13,549 --> 00:18:18,320
abandon things and invent them again

00:18:15,200 --> 00:18:20,120
dump them again this time they cannot

00:18:18,320 --> 00:18:24,429
because they use it as a foundation for

00:18:20,120 --> 00:18:26,659
g-cloud so they're stuck with it and

00:18:24,429 --> 00:18:29,649
which is nice for us because we have a

00:18:26,659 --> 00:18:33,669
very stable thing in our hands here and

00:18:29,649 --> 00:18:36,590
in addition to to just a specification

00:18:33,669 --> 00:18:39,200
they also provide Scala PB which is a

00:18:36,590 --> 00:18:42,559
probable buffer compiler

00:18:39,200 --> 00:18:45,260
it's plug in 4 for our Scala compiler

00:18:42,559 --> 00:18:49,250
and it will generate us very nice case

00:18:45,260 --> 00:18:50,750
classes so we just specify the protocol

00:18:49,250 --> 00:18:54,860
and we get the classes for free and

00:18:50,750 --> 00:18:59,720
parses serializes everything will be we

00:18:54,860 --> 00:19:01,970
will get for free and if we look at just

00:18:59,720 --> 00:19:03,980
take a peek at how that could look if we

00:19:01,970 --> 00:19:07,309
define our data structure that we want

00:19:03,980 --> 00:19:09,710
to exchange I started with a person we

00:19:07,309 --> 00:19:12,380
see that we define a syntax Pro 2 3

00:19:09,710 --> 00:19:14,510
that's we'll get to it a bit lighter we

00:19:12,380 --> 00:19:17,690
can define which package it will end up

00:19:14,510 --> 00:19:20,510
in the code generation and we can define

00:19:17,690 --> 00:19:23,659
the message itself with its fields it's

00:19:20,510 --> 00:19:27,100
data types and what you see what is

00:19:23,659 --> 00:19:30,200
interesting is you see a number because

00:19:27,100 --> 00:19:33,590
protobuf has a concept of ordering their

00:19:30,200 --> 00:19:35,809
data fields and if you wanna not use

00:19:33,590 --> 00:19:37,760
something anymore then that number is

00:19:35,809 --> 00:19:40,370
essentially burnt and you probably wanna

00:19:37,760 --> 00:19:43,580
so if you want don't care about the user

00:19:40,370 --> 00:19:49,520
ID anymore you should not reuse it but

00:19:43,580 --> 00:19:52,669
you should continue with 4 that's and if

00:19:49,520 --> 00:19:54,740
you I'm showing you proto 3 which is

00:19:52,669 --> 00:19:56,899
fundamental or a bit different from

00:19:54,740 --> 00:19:59,210
proto 2 because in proto 2 they still

00:19:56,899 --> 00:20:01,010
had the idea of something's being

00:19:59,210 --> 00:20:04,429
optional and some things being mandatory

00:20:01,010 --> 00:20:06,710
and that led to tons of bugs in in

00:20:04,429 --> 00:20:07,620
google code and at some point they

00:20:06,710 --> 00:20:10,140
discouraged it

00:20:07,620 --> 00:20:11,820
internally and said well just deal with

00:20:10,140 --> 00:20:14,880
the fact that you never know what you're

00:20:11,820 --> 00:20:17,850
gonna get and so they made everything

00:20:14,880 --> 00:20:21,120
optional by default and remove the

00:20:17,850 --> 00:20:22,950
notation of requiring anything so and

00:20:21,120 --> 00:20:26,790
that caused big outrage and hacker news

00:20:22,950 --> 00:20:29,520
was very angry but still they they made

00:20:26,790 --> 00:20:32,370
it they released it and that's that's

00:20:29,520 --> 00:20:34,700
where we are now and I kind of like the

00:20:32,370 --> 00:20:38,250
idea that if you're exchanging messages

00:20:34,700 --> 00:20:41,520
you you cannot really require some

00:20:38,250 --> 00:20:43,440
things to be there because it kind of it

00:20:41,520 --> 00:20:45,059
leads you down to a rabbit hole of then

00:20:43,440 --> 00:20:47,250
in the end requiring everything and

00:20:45,059 --> 00:20:49,830
writing a lot of if this is not present

00:20:47,250 --> 00:20:53,490
then what then and you'll write a lot of

00:20:49,830 --> 00:21:00,929
glue and boilerplate code and now if we

00:20:53,490 --> 00:21:04,950
look at that in encode how a nice little

00:21:00,929 --> 00:21:07,500
test would look like it's I've used the

00:21:04,950 --> 00:21:09,660
same proto file that we have seen on the

00:21:07,500 --> 00:21:12,809
slides and that generates us a nice

00:21:09,660 --> 00:21:14,820
class called person it has beautiful a

00:21:12,809 --> 00:21:18,120
builder pattern where I can add things

00:21:14,820 --> 00:21:19,890
and I added a new field the favorite

00:21:18,120 --> 00:21:24,780
conference which is of course Scala days

00:21:19,890 --> 00:21:27,000
and I have nice methods or I don't even

00:21:24,780 --> 00:21:29,280
need any math that's because I can just

00:21:27,000 --> 00:21:33,360
write and read stream based with our

00:21:29,280 --> 00:21:37,020
default mechanisms and in the end I read

00:21:33,360 --> 00:21:40,830
the file again and whom suddenly my

00:21:37,020 --> 00:21:41,929
stuff still makes sense and we're also

00:21:40,830 --> 00:21:46,700
going to be talking a bit about

00:21:41,929 --> 00:21:50,910
evolution because I have please go away

00:21:46,700 --> 00:21:53,340
IntelliJ is acting up a bit I have this

00:21:50,910 --> 00:21:55,200
is the same thing serialized twice one

00:21:53,340 --> 00:21:57,240
time without the favorite conference

00:21:55,200 --> 00:22:00,150
field that's what you've seen on slide

00:21:57,240 --> 00:22:01,559
and a second time with I added a field

00:22:00,150 --> 00:22:03,660
because that's what you do you add

00:22:01,559 --> 00:22:06,360
fields to your protocol definition and

00:22:03,660 --> 00:22:08,670
then I see realised it again so I can

00:22:06,360 --> 00:22:12,809
read and with my current state of the

00:22:08,670 --> 00:22:15,360
applications I can read both and of

00:22:12,809 --> 00:22:18,750
course for the favorite conference of

00:22:15,360 --> 00:22:21,389
the old file is just empty the the

00:22:18,750 --> 00:22:25,049
default for primitive types or string

00:22:21,389 --> 00:22:28,469
are kind of your the the defaults you

00:22:25,049 --> 00:22:31,019
would expect to be and now if we look at

00:22:28,469 --> 00:22:34,769
what happens on disk that's where it

00:22:31,019 --> 00:22:37,049
gets expecially interesting is that that

00:22:34,769 --> 00:22:39,869
is our that are the bytes that we have

00:22:37,049 --> 00:22:43,049
on disk and if you look at them

00:22:39,869 --> 00:22:45,330
carefully it's actually not too scary I

00:22:43,049 --> 00:22:48,029
cannot make the the lower thing any

00:22:45,330 --> 00:22:50,700
bigger for you which is said but here

00:22:48,029 --> 00:22:53,999
you see two four you see five bytes

00:22:50,700 --> 00:22:55,619
which tell you the IE and the ID that

00:22:53,999 --> 00:22:58,769
we've seen before in the protocol like

00:22:55,619 --> 00:23:03,599
this is field number two and it's of

00:22:58,769 --> 00:23:05,729
type 2 which means string so the first

00:23:03,599 --> 00:23:08,820
byte tells you which idea it is and

00:23:05,729 --> 00:23:11,129
which type it is the second byte tells

00:23:08,820 --> 00:23:15,769
you how many bytes of payload are coming

00:23:11,129 --> 00:23:18,239
in this case nine characters and then

00:23:15,769 --> 00:23:19,799
surprisingly well working my a first

00:23:18,239 --> 00:23:22,649
name has nine characters there they are

00:23:19,799 --> 00:23:25,379
and then it just without any further

00:23:22,649 --> 00:23:27,989
thing in between it just starts because

00:23:25,379 --> 00:23:30,599
the the length has run out it starts

00:23:27,989 --> 00:23:33,599
again with now field number three it's

00:23:30,599 --> 00:23:37,469
also a string so type number two in

00:23:33,599 --> 00:23:41,399
binary encoding and then byte encode it

00:23:37,469 --> 00:23:44,159
it's a length of three and tada last

00:23:41,399 --> 00:23:46,830
three characters of my name so that's

00:23:44,159 --> 00:23:48,869
actually a pretty forward way and so

00:23:46,830 --> 00:23:50,429
don't be scared about the on disk form

00:23:48,869 --> 00:23:54,599
it's a pretty straightforward and and

00:23:50,429 --> 00:23:57,210
reasonable then wanna put it on slides

00:23:54,599 --> 00:23:59,219
one more we have to feel tag to type the

00:23:57,210 --> 00:24:04,799
value the length and then the actual

00:23:59,219 --> 00:24:06,989
payload so just to show just to recap we

00:24:04,799 --> 00:24:09,210
have no presence logic in proto three

00:24:06,989 --> 00:24:10,519
which angers some people and some people

00:24:09,210 --> 00:24:13,469
like it very much

00:24:10,519 --> 00:24:18,960
LP all things are optional and we have

00:24:13,469 --> 00:24:22,139
some fun little additions yeah well what

00:24:18,960 --> 00:24:23,879
I talked before so optional is now

00:24:22,139 --> 00:24:27,719
redundant and everything is to be

00:24:23,879 --> 00:24:30,059
treated as optional so much for protobuf

00:24:27,719 --> 00:24:33,409
and next candidate we have is thrift

00:24:30,059 --> 00:24:35,070
thrift is a bit more than just a

00:24:33,409 --> 00:24:38,190
civilization framework

00:24:35,070 --> 00:24:40,860
it wants to be a whole RPC framework and

00:24:38,190 --> 00:24:43,230
whole ecosystem a definition language a

00:24:40,860 --> 00:24:48,990
communication protocol so much more and

00:24:43,230 --> 00:24:50,370
if you see that well Facebook developed

00:24:48,990 --> 00:24:53,159
it and they wanted to build something

00:24:50,370 --> 00:24:58,409
really really big like a real very much

00:24:53,159 --> 00:25:01,049
opinionated framework and then well they

00:24:58,409 --> 00:25:03,509
developed it they dropped it and then

00:25:01,049 --> 00:25:05,730
Twitter picked up and then after a while

00:25:03,509 --> 00:25:07,169
they reopened sauced it as Facebook's

00:25:05,730 --> 00:25:09,330
roof because they started again

00:25:07,169 --> 00:25:12,149
and I'm just gonna be talking about the

00:25:09,330 --> 00:25:16,019
real original thrift not the Facebook

00:25:12,149 --> 00:25:18,899
thrift and Twitter picked up and they

00:25:16,019 --> 00:25:21,840
supplied us with Scrooge with this SBT

00:25:18,899 --> 00:25:28,279
and Scala integration we have that's

00:25:21,840 --> 00:25:32,159
working fantastically if we check our

00:25:28,279 --> 00:25:33,899
person in thrift now what I just what I

00:25:32,159 --> 00:25:36,240
found out thanks to Mookie who's who's

00:25:33,899 --> 00:25:37,860
using it you can also see a set

00:25:36,240 --> 00:25:42,240
different namespaces for different

00:25:37,860 --> 00:25:44,519
languages here and you see that the the

00:25:42,240 --> 00:25:46,860
definition of the data is kind of the

00:25:44,519 --> 00:25:48,750
same like it used to be in impro to buff

00:25:46,860 --> 00:25:52,799
they're very similar in in their

00:25:48,750 --> 00:25:55,919
behavior but we're with a big big but of

00:25:52,799 --> 00:25:58,500
the they kept the semantics of optional

00:25:55,919 --> 00:26:00,629
and required so pick your poison pick

00:25:58,500 --> 00:26:04,250
where you want to go they that's where

00:26:00,629 --> 00:26:04,250
they differ the most fundamentally here

00:26:04,820 --> 00:26:11,970
and if you look at it generated code

00:26:07,559 --> 00:26:13,470
they have you don't get a build a

00:26:11,970 --> 00:26:15,960
pattern but instead you get a nice

00:26:13,470 --> 00:26:20,159
constructor that's the the difference

00:26:15,960 --> 00:26:23,340
and you see here that it's it's also a

00:26:20,159 --> 00:26:25,139
bit leaking that thrift is not just a

00:26:23,340 --> 00:26:27,029
protocol it's a protocol family it's

00:26:25,139 --> 00:26:29,250
it's a big framework so you have

00:26:27,029 --> 00:26:32,279
different different protocol factories

00:26:29,250 --> 00:26:34,860
and it goes down it goes above above the

00:26:32,279 --> 00:26:36,450
scope of this talk but and here we're

00:26:34,860 --> 00:26:40,889
working with a binary protocol which is

00:26:36,450 --> 00:26:42,990
a bit more noisy and they provide us

00:26:40,889 --> 00:26:48,410
with their own implementations of

00:26:42,990 --> 00:26:50,360
buffers and encodings so how we can

00:26:48,410 --> 00:26:52,220
while you can download the or the code

00:26:50,360 --> 00:26:53,840
is on github afterwards so don't focus

00:26:52,220 --> 00:26:55,970
too much on the details you can check it

00:26:53,840 --> 00:26:59,060
out later or just copy and paste it if

00:26:55,970 --> 00:27:01,850
you need to it's kind of similar how you

00:26:59,060 --> 00:27:06,290
can read and write files to disk or

00:27:01,850 --> 00:27:10,610
wherever you want to and now if we look

00:27:06,290 --> 00:27:12,890
at what happens um finally oh I forgot

00:27:10,610 --> 00:27:14,450
one thing that's just here I'm sorry

00:27:12,890 --> 00:27:17,870
about that that's just a difference of

00:27:14,450 --> 00:27:19,640
the protobuf without the old version and

00:27:17,870 --> 00:27:21,560
on the right you see the protobuf of the

00:27:19,640 --> 00:27:24,110
new version which means if you add a

00:27:21,560 --> 00:27:26,120
field it just puts it up at the end and

00:27:24,110 --> 00:27:29,170
it's it's very easy very straightforward

00:27:26,120 --> 00:27:31,970
how these how these things behave but

00:27:29,170 --> 00:27:33,650
going back to thrift you see it's it's a

00:27:31,970 --> 00:27:40,150
bit longer it's there they're binary

00:27:33,650 --> 00:27:40,150
protocol and if we look at the slides

00:27:41,470 --> 00:27:45,920
they have kind of the same same thing

00:27:44,090 --> 00:27:48,020
what they do they they have types they

00:27:45,920 --> 00:27:51,050
have a field tag so which is the ID of

00:27:48,020 --> 00:27:53,690
when where it is in stream they have a

00:27:51,050 --> 00:27:55,880
length and if you see about how long the

00:27:53,690 --> 00:27:57,620
length field is they're kind of

00:27:55,880 --> 00:28:01,790
estimating a bit longer messages like

00:27:57,620 --> 00:28:03,950
thrift is protobuf is more meant to be

00:28:01,790 --> 00:28:06,620
more rapid small kind of thing

00:28:03,950 --> 00:28:09,080
communication and thrift things a bit

00:28:06,620 --> 00:28:11,510
more about longer messages as you see in

00:28:09,080 --> 00:28:14,240
it kind of leaks from from that length

00:28:11,510 --> 00:28:16,760
field but in the end you still see the

00:28:14,240 --> 00:28:18,890
exact same bytes of of my name and code

00:28:16,760 --> 00:28:20,990
it and you see the type the field tag

00:28:18,890 --> 00:28:23,180
the length it's just organized a bit

00:28:20,990 --> 00:28:28,940
differently but you see very very big

00:28:23,180 --> 00:28:31,370
similarities so wrapping up it's a whole

00:28:28,940 --> 00:28:34,280
RPC framework and you can embrace that

00:28:31,370 --> 00:28:37,010
if you go with with the whole twitter

00:28:34,280 --> 00:28:39,470
stack you then you're not only doing

00:28:37,010 --> 00:28:41,630
thrift but you can do the whole RPC

00:28:39,470 --> 00:28:43,250
framework or you can just use thrift

00:28:41,630 --> 00:28:46,630
alone into whatever you want with it

00:28:43,250 --> 00:28:48,920
it's kind of easy to plug and play and

00:28:46,630 --> 00:28:52,130
well what you need to know is the scala

00:28:48,920 --> 00:28:55,280
ecosystem is only relying on Twitter so

00:28:52,130 --> 00:28:58,280
if they stop doing it then this means

00:28:55,280 --> 00:29:00,410
half way death of the project and of

00:28:58,280 --> 00:29:01,500
course except for the optional and

00:29:00,410 --> 00:29:05,070
required thing

00:29:01,500 --> 00:29:07,190
they are really really similar so and

00:29:05,070 --> 00:29:11,460
then we have a bit a bit the more

00:29:07,190 --> 00:29:13,050
different friend of us here Avro if you

00:29:11,460 --> 00:29:15,180
have heard about this it's also a

00:29:13,050 --> 00:29:16,950
serialization protocol but it's really

00:29:15,180 --> 00:29:19,590
really different it started as a sub

00:29:16,950 --> 00:29:21,360
project of Hadoop because thrift even

00:29:19,590 --> 00:29:25,740
though it was a bit more focused on

00:29:21,360 --> 00:29:27,390
length it's it was still a bad fit for a

00:29:25,740 --> 00:29:30,860
Duke because what's Hadoop doing it's

00:29:27,390 --> 00:29:34,230
not sending messages around its 0 lysing

00:29:30,860 --> 00:29:36,750
gigabytes of files of all kinds of stuff

00:29:34,230 --> 00:29:38,990
on disk and then working on these

00:29:36,750 --> 00:29:41,340
gigabytes terabytes of files and

00:29:38,990 --> 00:29:45,740
processing them right there they started

00:29:41,340 --> 00:29:48,330
the whole big data craze and hype and

00:29:45,740 --> 00:29:51,330
well it became an Apache project and

00:29:48,330 --> 00:29:56,370
confluent the people who also do Kafka

00:29:51,330 --> 00:29:58,100
are now a large influencer and they they

00:29:56,370 --> 00:30:01,320
kind of push the project forward and

00:29:58,100 --> 00:30:03,210
they have two different schema languages

00:30:01,320 --> 00:30:04,740
one for humans one for machines which is

00:30:03,210 --> 00:30:07,170
nice if you remember the colleague I've

00:30:04,740 --> 00:30:09,390
told you at the beginning who was very

00:30:07,170 --> 00:30:11,820
much in love with XML he might also like

00:30:09,390 --> 00:30:14,400
this one and they also get some nice

00:30:11,820 --> 00:30:16,020
compatibility with Jason so if that is

00:30:14,400 --> 00:30:18,780
one of you things then you could also

00:30:16,020 --> 00:30:22,170
use the the Jason protocol family from

00:30:18,780 --> 00:30:25,020
thrift or the direct mapping in Avro if

00:30:22,170 --> 00:30:30,780
you for some unbeknownst reason to me

00:30:25,020 --> 00:30:31,230
have to deal with Jason but the so far

00:30:30,780 --> 00:30:33,870
so good

00:30:31,230 --> 00:30:35,520
they have a very different attitude to

00:30:33,870 --> 00:30:37,800
how they do it because they think so

00:30:35,520 --> 00:30:40,170
much about big files and not so much

00:30:37,800 --> 00:30:43,350
about little and a lot of files or a lot

00:30:40,170 --> 00:30:45,510
of messages they say they came up with a

00:30:43,350 --> 00:30:50,340
concept of a reader and a writer schema

00:30:45,510 --> 00:30:54,420
to do the the evolution and that means

00:30:50,340 --> 00:30:57,570
that every message also carries the

00:30:54,420 --> 00:30:59,880
schema it was written in and with that

00:30:57,570 --> 00:31:01,620
everybody else who knows roughly about

00:30:59,880 --> 00:31:04,680
that kind of thing can decode the

00:31:01,620 --> 00:31:06,540
message and so you need last type of

00:31:04,680 --> 00:31:08,550
information in the definition because

00:31:06,540 --> 00:31:11,160
everything will be just down in the

00:31:08,550 --> 00:31:12,750
payload and you can skip the field IDs

00:31:11,160 --> 00:31:15,210
because you have two schema with you

00:31:12,750 --> 00:31:17,220
again so you don't have to puzzle it

00:31:15,210 --> 00:31:19,500
back like protocol buffed us or thrift

00:31:17,220 --> 00:31:21,960
us but instead you can just read the

00:31:19,500 --> 00:31:23,669
whole files and you will you will see

00:31:21,960 --> 00:31:28,110
then when you see the the serialized

00:31:23,669 --> 00:31:32,490
thing the schema itself it's kind of

00:31:28,110 --> 00:31:35,370
comparable we have also namespaces they

00:31:32,490 --> 00:31:38,100
they call it a record they have types

00:31:35,370 --> 00:31:42,330
like strings or a union between null and

00:31:38,100 --> 00:31:44,520
long which makes it optional so that's

00:31:42,330 --> 00:31:47,039
still comparable but if we look or

00:31:44,520 --> 00:31:51,690
remember our on disk formats

00:31:47,039 --> 00:31:54,240
this is Avro this is what it does and if

00:31:51,690 --> 00:31:57,120
you kind of roughly skip around what it

00:31:54,240 --> 00:31:58,770
is in the end you see the same bytes

00:31:57,120 --> 00:32:01,880
that I've shown you before which is my

00:31:58,770 --> 00:32:04,799
name but before that there's the whole

00:32:01,880 --> 00:32:06,990
protocol already packed into the message

00:32:04,799 --> 00:32:08,789
so whoever comes along can read it

00:32:06,990 --> 00:32:11,220
without ever talking to anybody else

00:32:08,789 --> 00:32:13,110
which is I guess if you're a big data

00:32:11,220 --> 00:32:15,899
file system a very nice thing to do

00:32:13,110 --> 00:32:17,789
because everybody can read it but if you

00:32:15,899 --> 00:32:19,950
have a lot of tiny little messages then

00:32:17,789 --> 00:32:21,809
you probably don't want to do it so

00:32:19,950 --> 00:32:30,899
decide for yourself when it's

00:32:21,809 --> 00:32:34,049
appropriate so and since I told you it's

00:32:30,899 --> 00:32:35,539
writers and readers schemas then they

00:32:34,049 --> 00:32:37,830
are they just need to be compatible

00:32:35,539 --> 00:32:39,630
because if you can also supply your own

00:32:37,830 --> 00:32:42,480
reader schema and there's some

00:32:39,630 --> 00:32:48,659
resolution rules in an hour that allow

00:32:42,480 --> 00:32:49,620
you to do that so now how does data and

00:32:48,659 --> 00:32:51,809
schema find together

00:32:49,620 --> 00:32:54,059
I've showed you the very first and basic

00:32:51,809 --> 00:32:56,159
implementation is you just wrangled the

00:32:54,059 --> 00:32:58,770
whole fire the whole schema always in

00:32:56,159 --> 00:33:01,020
your payload which might be a serious

00:32:58,770 --> 00:33:04,470
overhead for small files or it might not

00:33:01,020 --> 00:33:07,110
matter for big files what I've seen from

00:33:04,470 --> 00:33:09,210
from confluence what they also recommend

00:33:07,110 --> 00:33:11,460
if you're annoyed by that is that you

00:33:09,210 --> 00:33:12,179
can version eyes it store it yourself

00:33:11,460 --> 00:33:14,549
join it later

00:33:12,179 --> 00:33:16,559
which means you have to take the message

00:33:14,549 --> 00:33:19,710
rip out the schema and replace it with

00:33:16,559 --> 00:33:21,600
an identifier and then read time take

00:33:19,710 --> 00:33:24,740
the identifier and put the schema back

00:33:21,600 --> 00:33:27,110
in which you have to do manually and it

00:33:24,740 --> 00:33:29,070
could store it in a database or you

00:33:27,110 --> 00:33:31,889
could use the schema

00:33:29,070 --> 00:33:33,409
registry from from confluence that will

00:33:31,889 --> 00:33:37,409
help you do that

00:33:33,409 --> 00:33:39,029
so and the benefits are definitely we

00:33:37,409 --> 00:33:40,980
have support for dynamically generated

00:33:39,029 --> 00:33:44,100
schemas and if your schemas are varying

00:33:40,980 --> 00:33:45,899
very very widely and just everybody can

00:33:44,100 --> 00:33:49,019
dump data into a file system then it

00:33:45,899 --> 00:33:50,669
might be a good thing and it operates

00:33:49,019 --> 00:33:52,620
very well with dynamically typed

00:33:50,669 --> 00:33:54,120
languages and not statically typed

00:33:52,620 --> 00:33:57,320
languages but we don't care about them

00:33:54,120 --> 00:33:59,789
because it's Gallican for instance okay

00:33:57,320 --> 00:34:02,820
types are all here all we think about

00:33:59,789 --> 00:34:05,490
and yeah the downsides are definitely we

00:34:02,820 --> 00:34:07,889
have the protocol overhead we or the

00:34:05,490 --> 00:34:11,909
runtime dependency to get the schema in

00:34:07,889 --> 00:34:15,510
anyway and we somehow need to verify

00:34:11,909 --> 00:34:16,980
that if we change the schema then we

00:34:15,510 --> 00:34:19,919
have to find out if this is really

00:34:16,980 --> 00:34:22,290
appropriate okay so much for for Avro

00:34:19,919 --> 00:34:22,889
and forth one of the bunch is cryo or

00:34:22,290 --> 00:34:26,399
creo

00:34:22,889 --> 00:34:29,069
and now no idea how to pronounce it it's

00:34:26,399 --> 00:34:31,319
it's a bit odd because it's not a

00:34:29,069 --> 00:34:35,909
serialization framework like the three

00:34:31,319 --> 00:34:38,339
before they were it's more an object

00:34:35,909 --> 00:34:41,129
broth serialization that does not have a

00:34:38,339 --> 00:34:43,290
schema it's very good at serializing

00:34:41,129 --> 00:34:46,139
pick object graphs or really really

00:34:43,290 --> 00:34:48,089
complex objects into a thing and sending

00:34:46,139 --> 00:34:53,089
them to somebody else who speaks cryo

00:34:48,089 --> 00:34:55,710
and can unwrap it so I would say for

00:34:53,089 --> 00:34:58,950
inter JVM communication for something

00:34:55,710 --> 00:35:02,720
really where performance matters and you

00:34:58,950 --> 00:35:05,040
don't have historical data and only very

00:35:02,720 --> 00:35:06,720
things stay the same then it might be a

00:35:05,040 --> 00:35:08,430
good candidate for the just nice

00:35:06,720 --> 00:35:12,060
implementations for our cluster for

00:35:08,430 --> 00:35:15,150
example but we've been at one project

00:35:12,060 --> 00:35:18,210
where we did it for to store these files

00:35:15,150 --> 00:35:20,400
in Kafka which was bad at it is but also

00:35:18,210 --> 00:35:23,220
trying to read that in with new versions

00:35:20,400 --> 00:35:27,450
was a mess like stupid idea don't do

00:35:23,220 --> 00:35:30,900
that really again Twitter is helping us

00:35:27,450 --> 00:35:36,619
with chill that provides SBT integration

00:35:30,900 --> 00:35:36,619
of of creo and if we look at the code

00:35:38,650 --> 00:35:45,120
[Music]

00:35:40,440 --> 00:35:45,120
looks looks kind of the same like before

00:35:45,780 --> 00:35:50,560
it's a bit boilerplate II to to

00:35:48,520 --> 00:35:53,380
serialize it and to a bit less

00:35:50,560 --> 00:35:55,660
boilerplate II to an serialize it to

00:35:53,380 --> 00:35:58,510
deserialize it but still very Hannibal

00:35:55,660 --> 00:36:00,640
and again don't focus too much on the

00:35:58,510 --> 00:36:02,070
code it's all on github and you can

00:36:00,640 --> 00:36:04,510
check it out later

00:36:02,070 --> 00:36:07,090
just giving you a rough rough overview

00:36:04,510 --> 00:36:09,190
about how it could like how it could

00:36:07,090 --> 00:36:12,400
look like and just telling you it's

00:36:09,190 --> 00:36:14,380
neither of them are bad and don't fear

00:36:12,400 --> 00:36:17,820
it if you please don't use Java

00:36:14,380 --> 00:36:26,400
serialization please it's so easy please

00:36:17,820 --> 00:36:30,280
alright I lost my sight no they're here

00:36:26,400 --> 00:36:35,200
so now nice about cryo is it's even more

00:36:30,280 --> 00:36:38,110
compact so it's really maximum dense if

00:36:35,200 --> 00:36:43,540
we look at the whole file that I have on

00:36:38,110 --> 00:36:50,410
disk here this is cryo it's 16 bytes my

00:36:43,540 --> 00:36:53,320
message and that was thrift which is 32

00:36:50,410 --> 00:36:56,830
bytes and protobuf 4 somewhere in the

00:36:53,320 --> 00:36:59,740
middle and Avro is just odd and so if

00:36:56,830 --> 00:37:05,290
you care about the last bit then cryo

00:36:59,740 --> 00:37:07,090
might be four you know but what you

00:37:05,290 --> 00:37:09,130
really have to keep in mind in that case

00:37:07,090 --> 00:37:11,260
there is no schema which is why I didn't

00:37:09,130 --> 00:37:13,450
show you a schema so therefore there's

00:37:11,260 --> 00:37:15,910
also no schema evolution if the messages

00:37:13,450 --> 00:37:22,150
don't fit it will just crash you JVM so

00:37:15,910 --> 00:37:24,580
good luck and then one thing I will just

00:37:22,150 --> 00:37:26,200
skip over that because it doesn't really

00:37:24,580 --> 00:37:27,910
fit in but I want you to mention it

00:37:26,200 --> 00:37:32,020
there's the thing called simple binary

00:37:27,910 --> 00:37:36,490
encoding from it's in high frequency

00:37:32,020 --> 00:37:38,500
optimized serialization from the real

00:37:36,490 --> 00:37:41,650
logic company from London they're doing

00:37:38,500 --> 00:37:43,990
high frequency trading it's incredibly

00:37:41,650 --> 00:37:46,450
fast it doesn't support Scala and it's

00:37:43,990 --> 00:37:48,220
incredibly complicated so if you want to

00:37:46,450 --> 00:37:50,740
squeeze out the last millisecond or

00:37:48,220 --> 00:37:53,430
nanosecond of performance go there but

00:37:50,740 --> 00:37:53,430
don't talk to me

00:37:53,880 --> 00:38:00,309
so yeah they support schema evolution

00:37:56,589 --> 00:38:02,319
and they do support schema evolution but

00:38:00,309 --> 00:38:07,779
no good Scala integration and it's

00:38:02,319 --> 00:38:10,689
definitely not so easy to to use it so

00:38:07,779 --> 00:38:12,549
to wrap it up I try to wrap it up the

00:38:10,689 --> 00:38:14,949
smiley thing make it a bit more

00:38:12,549 --> 00:38:18,819
digestible so protobuf is very good in

00:38:14,949 --> 00:38:21,009
on the integration wise it has concept

00:38:18,819 --> 00:38:23,619
that I personally like very much and it

00:38:21,009 --> 00:38:26,049
fits kind of what what I think when I

00:38:23,619 --> 00:38:28,089
think about distributed systems but the

00:38:26,049 --> 00:38:30,549
version changed between 2 & 3 & the

00:38:28,089 --> 00:38:32,799
incompatibilities have you heard about

00:38:30,549 --> 00:38:34,929
any other thing having kind of crazy

00:38:32,799 --> 00:38:41,079
changes between 2 & 3 and people don't

00:38:34,929 --> 00:38:45,579
like that it's not gonna be this bad I

00:38:41,079 --> 00:38:47,559
promise well the rift

00:38:45,579 --> 00:38:50,679
shares the concepts so that's why I like

00:38:47,559 --> 00:38:53,859
it it's a way bigger framework so maybe

00:38:50,679 --> 00:38:57,069
be sure if you want to handle such a big

00:38:53,859 --> 00:38:59,619
framework and the integration I mean the

00:38:57,069 --> 00:39:02,469
smiley is a bit too angry it's it's not

00:38:59,619 --> 00:39:05,489
as good integrated as protobuf I feel

00:39:02,469 --> 00:39:08,949
but it's still usable way enough and

00:39:05,489 --> 00:39:11,829
well Avro say very good integration it's

00:39:08,949 --> 00:39:13,509
very great for very big files but I'm

00:39:11,829 --> 00:39:19,689
not gonna talk about that embedded

00:39:13,509 --> 00:39:23,679
schema concept no it has its use

00:39:19,689 --> 00:39:25,959
definitely and for cryo I love the speed

00:39:23,679 --> 00:39:28,209
I love the simplicity of it but it's not

00:39:25,959 --> 00:39:30,759
evolvable and it's definitely not for

00:39:28,209 --> 00:39:32,650
persisting so don't put your cryo

00:39:30,759 --> 00:39:35,140
serialized files anywhere on disk

00:39:32,650 --> 00:39:41,199
because you might not be able to read

00:39:35,140 --> 00:39:44,199
them later so and one last word of

00:39:41,199 --> 00:39:48,880
warning which also comes from the from

00:39:44,199 --> 00:39:51,789
the protobuf issue and why they change

00:39:48,880 --> 00:39:53,529
is that the required notion you remember

00:39:51,789 --> 00:39:56,349
usually if if you're not having worked

00:39:53,529 --> 00:39:59,469
with that too much requiring certain

00:39:56,349 --> 00:40:03,729
things feels very natural like a person

00:39:59,469 --> 00:40:05,980
has a name or if if you're living in the

00:40:03,729 --> 00:40:12,970
1970s you would think a person has again

00:40:05,980 --> 00:40:15,099
and if or maybe you if you're living in

00:40:12,970 --> 00:40:17,829
2017 you think a person has an email

00:40:15,099 --> 00:40:19,690
address but then comes the DSP 400 and

00:40:17,829 --> 00:40:22,990
the data protection officer comes to you

00:40:19,690 --> 00:40:25,140
and says now so things might not be as

00:40:22,990 --> 00:40:27,609
required as you think they will be and

00:40:25,140 --> 00:40:30,430
that leads you into all sorts of trouble

00:40:27,609 --> 00:40:34,869
and you lose a lot of the flexibility

00:40:30,430 --> 00:40:36,849
that such a framework will give you so

00:40:34,869 --> 00:40:38,050
and then a couple of relevant links that

00:40:36,849 --> 00:40:40,329
I want to share with you first one

00:40:38,050 --> 00:40:42,369
effective Java because it's just so good

00:40:40,329 --> 00:40:45,790
that you keep recommending it even if it

00:40:42,369 --> 00:40:48,820
doesn't fit at all and then the second

00:40:45,790 --> 00:40:52,359
one which I think is the best book

00:40:48,820 --> 00:40:55,000
released in 2017 it's or maybe the best

00:40:52,359 --> 00:40:57,070
book in the last five years it's design

00:40:55,000 --> 00:41:00,310
designing data intensive applications

00:40:57,070 --> 00:41:03,099
from Martin clapman which everything I

00:41:00,310 --> 00:41:04,900
said in this I said in this talk it's

00:41:03,099 --> 00:41:07,170
just a tiny chapter of the book and

00:41:04,900 --> 00:41:10,420
there's so much more in there for

00:41:07,170 --> 00:41:12,069
distributed systems for data intensive

00:41:10,420 --> 00:41:14,170
application it's it's a wonderful book

00:41:12,069 --> 00:41:16,300
and I can really really recommend it to

00:41:14,170 --> 00:41:18,099
read it even if it's it's not talking

00:41:16,300 --> 00:41:20,859
about programming languages but a more

00:41:18,099 --> 00:41:23,290
high-level concepts and there's a

00:41:20,859 --> 00:41:26,020
smaller more digestible blog post from

00:41:23,290 --> 00:41:28,569
him about schema evolution in aero

00:41:26,020 --> 00:41:30,490
protocol buffers and thrift that helped

00:41:28,569 --> 00:41:33,190
me a lot building this talk so I owe

00:41:30,490 --> 00:41:38,230
this person a lot if I ever see him I

00:41:33,190 --> 00:41:41,650
will thank him so now that we're closing

00:41:38,230 --> 00:41:43,060
down the talk my twitter is example

00:41:41,650 --> 00:41:46,000
slides and everything else you can find

00:41:43,060 --> 00:41:47,589
on on my on my github so you see the

00:41:46,000 --> 00:41:49,450
sample code there and then there's a

00:41:47,589 --> 00:41:51,640
folder called slides whether you see the

00:41:49,450 --> 00:41:53,470
slides and there's a folder called PDF

00:41:51,640 --> 00:41:58,150
where you can find a PDF version of that

00:41:53,470 --> 00:42:00,160
talk so it's all all accessible and if

00:41:58,150 --> 00:42:02,230
you like listen to me ranting about

00:42:00,160 --> 00:42:04,900
things I have a German podcast about my

00:42:02,230 --> 00:42:07,900
new role and now will where I'm even

00:42:04,900 --> 00:42:10,089
more ranting about crazy stuff oh and

00:42:07,900 --> 00:42:14,050
that concludes it thank you very much

00:42:10,089 --> 00:42:19,570
for your right Wow

00:42:14,050 --> 00:42:21,610
so many awake people thank you very much

00:42:19,570 --> 00:42:23,850
I think we have time for one little

00:42:21,610 --> 00:42:23,850
question

00:42:26,100 --> 00:42:31,480
so trying to repeat the question it's

00:42:28,960 --> 00:42:33,700
about how do you nest objects of build

00:42:31,480 --> 00:42:36,040
more complex data structures and how do

00:42:33,700 --> 00:42:39,220
you deal with that well the first thing

00:42:36,040 --> 00:42:41,140
is don't depending on what you're gonna

00:42:39,220 --> 00:42:43,060
do right if you're communicating between

00:42:41,140 --> 00:42:45,670
systems you probably want to be precise

00:42:43,060 --> 00:42:48,190
because the messages you send around are

00:42:45,670 --> 00:42:50,410
somewhat also your API and the more

00:42:48,190 --> 00:42:53,380
complex your structures are the mobile

00:42:50,410 --> 00:42:55,840
you will have dealing with your API if

00:42:53,380 --> 00:42:58,180
you need fast serialization of very

00:42:55,840 --> 00:43:00,970
complex objects and like I told you cryo

00:42:58,180 --> 00:43:03,670
is probably a way to go but also

00:43:00,970 --> 00:43:06,670
protobuf and thrift have support for

00:43:03,670 --> 00:43:09,010
nested data structures and I have no

00:43:06,670 --> 00:43:11,440
practical experience how far you can can

00:43:09,010 --> 00:43:13,420
do that like it's it's there but I

00:43:11,440 --> 00:43:21,790
cannot tell you how far to go and when

00:43:13,420 --> 00:43:24,460
when it will break please okay so the

00:43:21,790 --> 00:43:26,440
question is when does it start or stop

00:43:24,460 --> 00:43:28,930
to make sense to include the schema in

00:43:26,440 --> 00:43:31,660
in the in the avro message versus not

00:43:28,930 --> 00:43:35,860
including it in protobuf and thrift just

00:43:31,660 --> 00:43:38,560
just writing for a record i I did not do

00:43:35,860 --> 00:43:40,570
any scientific approach from the bottom

00:43:38,560 --> 00:43:43,930
I would say if if it's really messages

00:43:40,570 --> 00:43:45,610
like telling somebody something then I

00:43:43,930 --> 00:43:47,620
would rather go for the smaller things

00:43:45,610 --> 00:43:50,020
and having simple data structures that

00:43:47,620 --> 00:43:52,690
are small and easy to digest but if you

00:43:50,020 --> 00:43:55,980
store big blobs of information to work

00:43:52,690 --> 00:44:00,430
on like action not just payload but

00:43:55,980 --> 00:44:02,380
workload kind of like what what these

00:44:00,430 --> 00:44:05,500
big data systems do like workload that

00:44:02,380 --> 00:44:07,900
you will crunch on later or kind of

00:44:05,500 --> 00:44:10,600
roughly if it gets in the megabytes or

00:44:07,900 --> 00:44:13,120
like multi-digit megabytes then I would

00:44:10,600 --> 00:44:15,250
start thinking about it but it's depends

00:44:13,120 --> 00:44:18,660
so much on what you do with these

00:44:15,250 --> 00:44:18,660

YouTube URL: https://www.youtube.com/watch?v=xrKbBmHCsho


