Title: Leveraging Spire for complex time allocation logic by Vladimir Pavkin
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6913-leveraging-spire-for-complex-time-allocation-logic.html
Captions: 
	00:00:04,610 --> 00:00:12,670
hello everyone I'm really glad to see

00:00:07,280 --> 00:00:15,740
y'all coming to my talk and this topic

00:00:12,670 --> 00:00:18,260
about time allocation and time intervals

00:00:15,740 --> 00:00:20,840
maybe not close to everyone's heart

00:00:18,260 --> 00:00:24,099
maybe not all of you will face it in

00:00:20,840 --> 00:00:29,480
your daily programming jobs but still

00:00:24,099 --> 00:00:33,500
this is useful in in a lot of problems

00:00:29,480 --> 00:00:35,530
so I hope a lot of you will grab

00:00:33,500 --> 00:00:40,820
something interesting from my talk today

00:00:35,530 --> 00:00:43,789
so in the beginning I would like to say

00:00:40,820 --> 00:00:46,399
that my company evolution gaming is

00:00:43,789 --> 00:00:50,059
hiring people we are a growing

00:00:46,399 --> 00:00:54,469
international company that has a lot of

00:00:50,059 --> 00:00:56,539
offices in Europe and we will hire

00:00:54,469 --> 00:00:59,089
engineers in three of them which are in

00:00:56,539 --> 00:01:02,300
Amsterdam regained talents so if you're

00:00:59,089 --> 00:01:05,239
interested you can come to our booth in

00:01:02,300 --> 00:01:07,730
the main hall and we can discuss things

00:01:05,239 --> 00:01:10,700
we do in Scala for example event

00:01:07,730 --> 00:01:13,030
sourcing lack of persistence some Scala

00:01:10,700 --> 00:01:15,740
jazz projects and and a lot of other

00:01:13,030 --> 00:01:20,920
interesting things so feel free to come

00:01:15,740 --> 00:01:23,900
and discuss a little bit about me I'm

00:01:20,920 --> 00:01:27,430
working in a motion gaming for more than

00:01:23,900 --> 00:01:31,640
two years maintaining a little bit a

00:01:27,430 --> 00:01:36,260
little set of date time related projects

00:01:31,640 --> 00:01:38,720
on github my overall experience is in

00:01:36,260 --> 00:01:40,040
Scala is around four years and so last

00:01:38,720 --> 00:01:42,740
years in the ocean gaming I've been

00:01:40,040 --> 00:01:44,630
developing a scheduling system which

00:01:42,740 --> 00:01:51,140
basically exposed me to the things I'll

00:01:44,630 --> 00:01:54,290
talk about today excuse me so spire is a

00:01:51,140 --> 00:01:56,660
huge toolkit of mathematical

00:01:54,290 --> 00:01:59,300
abstractions I will be talking today

00:01:56,660 --> 00:02:02,960
only about 1/2 which is intervals and

00:01:59,300 --> 00:02:06,050
interval sets but if you're doing if

00:02:02,960 --> 00:02:08,599
you're doing any kind of math on your

00:02:06,050 --> 00:02:10,819
daily job you should definitely take a

00:02:08,599 --> 00:02:15,670
look at spire it has a lot of really

00:02:10,819 --> 00:02:18,860
neat things these are core maintainer of

00:02:15,670 --> 00:02:21,530
spire library so

00:02:18,860 --> 00:02:24,379
I'm really grateful to these guys for

00:02:21,530 --> 00:02:27,550
creating this project this really made

00:02:24,379 --> 00:02:32,269
my life a lot a lot easier so kudos to

00:02:27,550 --> 00:02:34,340
to these developers so let's start first

00:02:32,269 --> 00:02:36,680
I would like to cover some theory just

00:02:34,340 --> 00:02:40,819
in case some of you may not be familiar

00:02:36,680 --> 00:02:42,410
with that so intervals are pretty simple

00:02:40,819 --> 00:02:43,760
concept we'll take a look at real

00:02:42,410 --> 00:02:49,160
intervals which are the most and a

00:02:43,760 --> 00:02:50,750
commonly known example of intervals so

00:02:49,160 --> 00:02:53,989
interval is just a set of numbers which

00:02:50,750 --> 00:02:56,810
is defined by two boundaries each of

00:02:53,989 --> 00:02:59,510
them is either closed or open where open

00:02:56,810 --> 00:03:01,280
boundary is a boundary that doesn't

00:02:59,510 --> 00:03:03,560
contain the value at the boundary itself

00:03:01,280 --> 00:03:05,420
which is an empty dot on the graphical

00:03:03,560 --> 00:03:07,879
representation and the closed boundary

00:03:05,420 --> 00:03:11,239
is the opposite of that it contains that

00:03:07,879 --> 00:03:13,549
value at the battery itself and there

00:03:11,239 --> 00:03:16,280
are special kinds of boundaries which

00:03:13,549 --> 00:03:18,019
are infinity positive and negative

00:03:16,280 --> 00:03:22,760
infinity which represent unbounded

00:03:18,019 --> 00:03:25,549
intervals so and also there is special

00:03:22,760 --> 00:03:27,680
empty interval which which equivalent to

00:03:25,549 --> 00:03:29,239
empty set and the degraded infinite

00:03:27,680 --> 00:03:32,810
interval that contains only one element

00:03:29,239 --> 00:03:34,730
basically a singleton set there is one

00:03:32,810 --> 00:03:37,639
interesting property about intervals

00:03:34,730 --> 00:03:40,010
which is you can iterate all the NEB all

00:03:37,639 --> 00:03:42,290
the members of an interval so even a

00:03:40,010 --> 00:03:45,940
very small non degraded interval

00:03:42,290 --> 00:03:51,590
contains an infinite number of elements

00:03:45,940 --> 00:03:54,079
so it's it's an infinite set so and to

00:03:51,590 --> 00:03:55,970
kind of overcome this to iterate you can

00:03:54,079 --> 00:04:01,910
introduce some precision for example

00:03:55,970 --> 00:04:04,190
like some 1000s but this will not be an

00:04:01,910 --> 00:04:06,230
interval anymore if you do that so and

00:04:04,190 --> 00:04:08,630
this is kind of similar to what we can

00:04:06,230 --> 00:04:10,400
say about time intervals because given a

00:04:08,630 --> 00:04:12,500
non-empty time interval you can't

00:04:10,400 --> 00:04:14,959
possibly iterate all them all the

00:04:12,500 --> 00:04:18,070
moments because like that's this kind of

00:04:14,959 --> 00:04:18,070
doesn't make any sense

00:04:18,669 --> 00:04:24,349
interval sets is a natural extension of

00:04:21,919 --> 00:04:27,530
the idea of interval all right so it's

00:04:24,349 --> 00:04:30,409
just a set of intervals that are joined

00:04:27,530 --> 00:04:31,460
using Union operation so again it's it's

00:04:30,409 --> 00:04:35,030
again it's a set of

00:04:31,460 --> 00:04:37,220
members and yes so there are some

00:04:35,030 --> 00:04:40,660
examples breed is therefore

00:04:37,220 --> 00:04:45,500
straightforward just the same thing

00:04:40,660 --> 00:04:48,319
getting more general let's go over some

00:04:45,500 --> 00:04:50,449
operations the most commonly known is

00:04:48,319 --> 00:04:52,340
intersection and union so all the

00:04:50,449 --> 00:04:54,470
operations I'm going to look at our not

00:04:52,340 --> 00:04:57,919
specific to intervals or interval sets

00:04:54,470 --> 00:05:01,099
it's it's set algebra just regular set

00:04:57,919 --> 00:05:04,340
algebra so these are examples of

00:05:01,099 --> 00:05:06,020
intersection and union I think most of

00:05:04,340 --> 00:05:08,030
you should be familiar with that so

00:05:06,020 --> 00:05:10,400
intersection is taking a common part of

00:05:08,030 --> 00:05:14,060
two intervals and Union just joining

00:05:10,400 --> 00:05:17,810
them together taking all the elements in

00:05:14,060 --> 00:05:19,789
the resulting set another interesting

00:05:17,810 --> 00:05:23,740
thing is a complement operation or

00:05:19,789 --> 00:05:26,960
inverse and in other words it's just

00:05:23,740 --> 00:05:29,229
creating given some interval set it

00:05:26,960 --> 00:05:32,150
creates a new interval set which

00:05:29,229 --> 00:05:34,580
contains all the elements that were not

00:05:32,150 --> 00:05:38,300
included in the original one so that's

00:05:34,580 --> 00:05:40,400
also very useful and last one we're

00:05:38,300 --> 00:05:42,849
going to look at is subtraction no

00:05:40,400 --> 00:05:46,430
examples here because this can be

00:05:42,849 --> 00:05:48,590
written using already covered operations

00:05:46,430 --> 00:05:51,860
which is basically if you want to

00:05:48,590 --> 00:05:56,419
subtract set be how to set a you just

00:05:51,860 --> 00:05:58,729
intersect a with a complement of B right

00:05:56,419 --> 00:06:00,620
so we covered operations now just let's

00:05:58,729 --> 00:06:06,080
quickly look at what problems are solved

00:06:00,620 --> 00:06:08,630
with intervals the most common

00:06:06,080 --> 00:06:11,780
application of intervals is the model

00:06:08,630 --> 00:06:13,639
uncertainty so we are functional

00:06:11,780 --> 00:06:15,710
programmers and we know one data

00:06:13,639 --> 00:06:19,370
structure that models uncertainty which

00:06:15,710 --> 00:06:22,130
is list so instead of one result you can

00:06:19,370 --> 00:06:24,919
get zero or several results all right so

00:06:22,130 --> 00:06:29,870
this is kind of uncertain result of a

00:06:24,919 --> 00:06:32,469
computation intervals model different

00:06:29,870 --> 00:06:35,090
kind of uncertainty where list is a

00:06:32,469 --> 00:06:37,610
discrete uncertainty you get some finite

00:06:35,090 --> 00:06:39,949
number of discrete values interval

00:06:37,610 --> 00:06:43,010
models a continuous uncertainty where

00:06:39,949 --> 00:06:45,199
your result lies within some range but

00:06:43,010 --> 00:06:47,599
the number of possible

00:06:45,199 --> 00:06:50,629
different results is infinite right so

00:06:47,599 --> 00:06:54,529
that's that's kind of useful in a lot of

00:06:50,629 --> 00:06:56,810
and a lot of problems there are other

00:06:54,529 --> 00:06:59,029
applications of intervals but today

00:06:56,810 --> 00:07:02,960
we're going to look at scheduling which

00:06:59,029 --> 00:07:06,469
is related to time and the reason we can

00:07:02,960 --> 00:07:09,710
do we can do that we can use intervals

00:07:06,469 --> 00:07:12,830
for the work with time is because

00:07:09,710 --> 00:07:14,719
actually intervals don't require

00:07:12,830 --> 00:07:17,479
anything numeric from the underlying

00:07:14,719 --> 00:07:19,789
type the only thing that R is required

00:07:17,479 --> 00:07:25,219
for intervals to work is order total

00:07:19,789 --> 00:07:29,960
order this is kind of cats order or you

00:07:25,219 --> 00:07:31,939
can take standard color ordering so the

00:07:29,960 --> 00:07:34,610
spire intervals words work with cats

00:07:31,939 --> 00:07:39,159
order but you can in general use any

00:07:34,610 --> 00:07:41,839
other order type class you know about so

00:07:39,159 --> 00:07:45,249
so intercourse require order let's bring

00:07:41,839 --> 00:07:48,219
them some there is some caveats with

00:07:45,249 --> 00:07:51,319
implementing order for date/time values

00:07:48,219 --> 00:07:53,419
one of that is the main the main is that

00:07:51,319 --> 00:07:57,169
for zoned date/time values for example

00:07:53,419 --> 00:07:59,500
Java time zone day time from Java 8 you

00:07:57,169 --> 00:08:02,990
can create two semantically different

00:07:59,500 --> 00:08:05,509
order instances there they're completely

00:08:02,990 --> 00:08:07,219
lawful but they are different let's take

00:08:05,509 --> 00:08:11,270
a look at them so first one is strict

00:08:07,219 --> 00:08:13,580
order which is comparing values

00:08:11,270 --> 00:08:17,389
including the timezone so if you have

00:08:13,580 --> 00:08:19,909
two identical instance instance they

00:08:17,389 --> 00:08:22,279
have to be they have to be located in

00:08:19,909 --> 00:08:26,270
the similar the same timezone to be

00:08:22,279 --> 00:08:28,189
equal even if you have identical

00:08:26,270 --> 00:08:32,199
instance but they have different time

00:08:28,189 --> 00:08:34,550
zones they will be considered not equal

00:08:32,199 --> 00:08:36,289
this is kind of district one there is a

00:08:34,550 --> 00:08:38,719
relaxed version of that which is also

00:08:36,289 --> 00:08:41,390
lawful where we compare on the instance

00:08:38,719 --> 00:08:43,219
so for example if you have different

00:08:41,390 --> 00:08:45,350
time zones but the instance are the same

00:08:43,219 --> 00:08:48,279
so these will be considerably cool so

00:08:45,350 --> 00:08:50,959
depending on your task depending on your

00:08:48,279 --> 00:08:54,649
problem you can select either one

00:08:50,959 --> 00:08:56,680
they're they're both they are both

00:08:54,649 --> 00:08:59,379
widget they're both waffle

00:08:56,680 --> 00:09:02,949
so given we select one or one of these

00:08:59,379 --> 00:09:07,949
order instances we can create intervals

00:09:02,949 --> 00:09:14,160
of time intervals right that use

00:09:07,949 --> 00:09:16,269
date/time values for the points now

00:09:14,160 --> 00:09:20,050
let's now we're ready to look at the

00:09:16,269 --> 00:09:23,410
code actually so let's start with

00:09:20,050 --> 00:09:27,129
balance this is a very simple ADT right

00:09:23,410 --> 00:09:29,199
that just just to encode the data so

00:09:27,129 --> 00:09:31,720
there are open and closed boundaries

00:09:29,199 --> 00:09:35,290
which are which contain a value and just

00:09:31,720 --> 00:09:38,649
represent as it says either open or

00:09:35,290 --> 00:09:40,540
closed boundaries and there are two

00:09:38,649 --> 00:09:43,360
special kinds of boundaries which which

00:09:40,540 --> 00:09:45,009
are unbound that depending on the

00:09:43,360 --> 00:09:46,629
position in the interval and called

00:09:45,009 --> 00:09:50,050
either negative infinity or positive

00:09:46,629 --> 00:09:54,459
infinity and empty bound to encode nth

00:09:50,050 --> 00:09:56,740
interval right so the interval itself is

00:09:54,459 --> 00:09:59,379
conceptually just a pair of bounds as we

00:09:56,740 --> 00:10:01,870
discussed but the encoding is a little

00:09:59,379 --> 00:10:05,459
bit different so you don't have any

00:10:01,870 --> 00:10:10,240
public Aditi here this is done for

00:10:05,459 --> 00:10:12,939
performance reason for the safety

00:10:10,240 --> 00:10:16,059
reasons there are there are several

00:10:12,939 --> 00:10:20,620
design considerations mmm in this choice

00:10:16,059 --> 00:10:23,379
but instead of ADT we have several smart

00:10:20,620 --> 00:10:24,819
constructors and they are pretty much

00:10:23,379 --> 00:10:29,769
enough for everything you might want to

00:10:24,819 --> 00:10:33,670
do with intervals right so and as you

00:10:29,769 --> 00:10:39,220
can see they all require order implicit

00:10:33,670 --> 00:10:41,350
to work so let's just cover the interval

00:10:39,220 --> 00:10:43,240
of the interval API so if given you have

00:10:41,350 --> 00:10:44,980
a single interval what can you what you

00:10:43,240 --> 00:10:48,100
can do with that so you can do a lot of

00:10:44,980 --> 00:10:50,589
things you can check if a particular

00:10:48,100 --> 00:10:53,769
point in our case add a time value

00:10:50,589 --> 00:10:56,619
belongs to the interval or not if you

00:10:53,769 --> 00:10:58,660
can check if two intervals one interval

00:10:56,619 --> 00:11:01,629
is a subset or superset of another

00:10:58,660 --> 00:11:07,839
interval you can calculate intersection

00:11:01,629 --> 00:11:09,910
and union of two intervals you can also

00:11:07,839 --> 00:11:13,470
like the Union is

00:11:09,910 --> 00:11:16,090
it's a little bit tricky right because

00:11:13,470 --> 00:11:18,280
if you have two disjoint intervals the

00:11:16,090 --> 00:11:20,040
union will be an interval set so that's

00:11:18,280 --> 00:11:23,310
why I'm not listening it here because we

00:11:20,040 --> 00:11:25,060
didn't get to interval set yet

00:11:23,310 --> 00:11:28,150
complement and subtraction operations

00:11:25,060 --> 00:11:30,070
are also I separated them in a separate

00:11:28,150 --> 00:11:31,570
point because in general when you do the

00:11:30,070 --> 00:11:34,690
separations for example let's take

00:11:31,570 --> 00:11:36,760
subtraction if you have a big interval

00:11:34,690 --> 00:11:39,520
and you subtract a small interval from

00:11:36,760 --> 00:11:42,730
that you get two intervals instead like

00:11:39,520 --> 00:11:45,010
as a result so in general they return

00:11:42,730 --> 00:11:48,100
these operations have to return a list

00:11:45,010 --> 00:11:49,540
of intervals to work for all cases this

00:11:48,100 --> 00:11:52,840
is kind of inconvenient and this is a

00:11:49,540 --> 00:11:58,090
sign that that we were working in with a

00:11:52,840 --> 00:12:00,430
too low level abstraction so we will see

00:11:58,090 --> 00:12:02,880
how this will be solved in interval sets

00:12:00,430 --> 00:12:06,400
and there is no interval arithmetic

00:12:02,880 --> 00:12:09,870
api's which will not look at today but

00:12:06,400 --> 00:12:12,190
these are also very very useful so we

00:12:09,870 --> 00:12:16,210
clearly see some limitations with

00:12:12,190 --> 00:12:18,430
interval and if we need Union compliment

00:12:16,210 --> 00:12:21,070
and subtraction to work more in a more

00:12:18,430 --> 00:12:24,160
general way we need interval sets these

00:12:21,070 --> 00:12:26,410
were developed by Ruettiger clean and

00:12:24,160 --> 00:12:30,640
actually this is a very nice piece of

00:12:26,410 --> 00:12:33,250
software I would say really really had

00:12:30,640 --> 00:12:35,910
no problems working with these things

00:12:33,250 --> 00:12:39,550
from day one so thank you thank you what

00:12:35,910 --> 00:12:42,870
for developing these things big interval

00:12:39,550 --> 00:12:47,320
sets go into two flavors

00:12:42,870 --> 00:12:50,680
first is interval tri which is under the

00:12:47,320 --> 00:12:52,780
hood is represented with a tree it's

00:12:50,680 --> 00:12:56,350
it's really really fast it's the fastest

00:12:52,780 --> 00:12:58,960
of two and like the performance doesn't

00:12:56,350 --> 00:13:01,810
go for free to work with interval try

00:12:58,960 --> 00:13:03,910
you need a really fast isomorphism to

00:13:01,810 --> 00:13:07,360
long so basically your underlying type

00:13:03,910 --> 00:13:10,350
has to fit in 64 bytes and the

00:13:07,360 --> 00:13:13,770
conversion should be fast for you to

00:13:10,350 --> 00:13:16,630
really gain some performance from that

00:13:13,770 --> 00:13:20,080
this constraint is actually not a very

00:13:16,630 --> 00:13:22,040
tight tight constraint because for

00:13:20,080 --> 00:13:24,290
example if you use time you can

00:13:22,040 --> 00:13:25,520
still use milliseconds precision and you

00:13:24,290 --> 00:13:27,530
will fit in too long

00:13:25,520 --> 00:13:30,550
so only if you need nanoseconds

00:13:27,530 --> 00:13:33,560
precision you will have to resort to

00:13:30,550 --> 00:13:36,890
more generic more general representation

00:13:33,560 --> 00:13:39,380
of an interval set so that's that's

00:13:36,890 --> 00:13:42,730
that's not a big requirement in most of

00:13:39,380 --> 00:13:45,260
the cases so the interval sequence is

00:13:42,730 --> 00:13:46,910
more than a general representation which

00:13:45,260 --> 00:13:49,330
is an array it's it's a little bit

00:13:46,910 --> 00:13:52,100
slower but it's still very fast you can

00:13:49,330 --> 00:13:54,830
check check out the rudy gift stock on

00:13:52,100 --> 00:13:57,320
the details so the he goes there really

00:13:54,830 --> 00:13:59,630
deep into implementation details of how

00:13:57,320 --> 00:14:02,860
these things work really interesting top

00:13:59,630 --> 00:14:05,360
really recommend is to watch so and the

00:14:02,860 --> 00:14:08,530
the results show that interval sequence

00:14:05,360 --> 00:14:13,850
is still still very very fast given the

00:14:08,530 --> 00:14:19,550
rich API that it provides so finally we

00:14:13,850 --> 00:14:23,120
are ready to to do some real work with

00:14:19,550 --> 00:14:25,640
intervals let's take a look at a problem

00:14:23,120 --> 00:14:31,220
that I guess most of you face every day

00:14:25,640 --> 00:14:33,830
which is like an older scheduling so

00:14:31,220 --> 00:14:35,630
let's say we have a three employees

00:14:33,830 --> 00:14:37,790
which have some work already scheduled

00:14:35,630 --> 00:14:39,590
and we need to squeeze in a meeting of

00:14:37,790 --> 00:14:42,500
one hour long somewhere in there in

00:14:39,590 --> 00:14:44,660
their daily schedule and the meeting has

00:14:42,500 --> 00:14:49,310
to happen in the working hours from 9

00:14:44,660 --> 00:14:50,930
a.m. till 7 p.m. so here the task is

00:14:49,310 --> 00:14:53,120
quite simple we can actually solve it

00:14:50,930 --> 00:14:56,060
with our eyes right so there is one kind

00:14:53,120 --> 00:14:59,030
of space where meeting can be placed and

00:14:56,060 --> 00:15:00,950
another one or no no I guess at the

00:14:59,030 --> 00:15:04,250
bottom right so yeah we can we can solve

00:15:00,950 --> 00:15:07,100
it by hand here right but as you can

00:15:04,250 --> 00:15:10,130
guess when the amount of people is is

00:15:07,100 --> 00:15:12,080
bigger when the schedule is more complex

00:15:10,130 --> 00:15:16,070
the solution might not be that obvious

00:15:12,080 --> 00:15:18,490
so we will try to solve the test so that

00:15:16,070 --> 00:15:20,990
it can be easily generalized for more

00:15:18,490 --> 00:15:23,560
complex problems so let's start

00:15:20,990 --> 00:15:27,050
well we'll begin with some helper

00:15:23,560 --> 00:15:29,540
helping code some alliances and helper

00:15:27,050 --> 00:15:31,670
methods so entry basically schedule

00:15:29,540 --> 00:15:32,769
entry right it will be a single time

00:15:31,670 --> 00:15:36,339
interval

00:15:32,769 --> 00:15:38,769
entries will represent a interval

00:15:36,339 --> 00:15:42,939
interval sequence basically as interval

00:15:38,769 --> 00:15:46,360
time interval set a set of several non

00:15:42,939 --> 00:15:49,139
intersecting intervals Union all

00:15:46,360 --> 00:15:52,420
operation will convert a list of

00:15:49,139 --> 00:15:54,730
intervals into a interval sequence

00:15:52,420 --> 00:15:57,129
basically interval sequence is

00:15:54,730 --> 00:16:00,100
isomorphic to a list of intervals so we

00:15:57,129 --> 00:16:02,939
can go back and forth but for some

00:16:00,100 --> 00:16:06,249
reason the Aspire doesn't provide this

00:16:02,939 --> 00:16:09,850
this arrow of the isomorphism so I just

00:16:06,249 --> 00:16:12,819
wrote it here backwards

00:16:09,850 --> 00:16:14,350
so from interval sequence to list of

00:16:12,819 --> 00:16:16,509
intervals there is a method that

00:16:14,350 --> 00:16:22,360
provides this API so we don't need that

00:16:16,509 --> 00:16:24,100
here and the duration is a simple helper

00:16:22,360 --> 00:16:27,579
to calculate the duration of an interval

00:16:24,100 --> 00:16:29,350
it's an option because we don't we can't

00:16:27,579 --> 00:16:30,999
handle all kinds of intervals we can

00:16:29,350 --> 00:16:33,549
calculate duration for an empty me

00:16:30,999 --> 00:16:35,470
interval for example or a decorated

00:16:33,549 --> 00:16:37,660
interval so that's why it returns an

00:16:35,470 --> 00:16:42,040
option the implementation is kind of not

00:16:37,660 --> 00:16:46,059
optimal in any way but it it's enough

00:16:42,040 --> 00:16:47,949
for our purposes here and we need

00:16:46,059 --> 00:16:51,160
duration because we need to filter the

00:16:47,949 --> 00:16:53,049
results so that the meeting is so that

00:16:51,160 --> 00:16:56,610
the interval is at least one hour long

00:16:53,049 --> 00:17:00,009
so that we can fit the meeting inside

00:16:56,610 --> 00:17:03,939
the next thing is we need is to load the

00:17:00,009 --> 00:17:05,649
entries like need basically to load the

00:17:03,939 --> 00:17:07,600
existing scheduled entries for the

00:17:05,649 --> 00:17:09,130
employees the the ones that were

00:17:07,600 --> 00:17:10,779
displayed on the picture in the

00:17:09,130 --> 00:17:12,520
beginning so in the real world of course

00:17:10,779 --> 00:17:15,760
we'll get them from some external

00:17:12,520 --> 00:17:19,380
service or from database but here we'll

00:17:15,760 --> 00:17:25,199
just write write them out as lists

00:17:19,380 --> 00:17:27,610
workday is a simple interval that

00:17:25,199 --> 00:17:29,889
represents the work and the working

00:17:27,610 --> 00:17:31,779
hours from 9:00 this daytime is just

00:17:29,889 --> 00:17:34,659
create it just creates a date/time value

00:17:31,779 --> 00:17:38,350
on on some day that I selected under the

00:17:34,659 --> 00:17:40,840
hood for this for this task basically a

00:17:38,350 --> 00:17:43,650
9:00 p.m. 9:00 a.m. until 7:00 p.m. and

00:17:40,840 --> 00:17:46,020
the duration is just a cached

00:17:43,650 --> 00:17:50,280
of one-hour that will need later for

00:17:46,020 --> 00:17:54,680
filtering so now we are ready to solve

00:17:50,280 --> 00:17:58,350
the task so first first of all we will

00:17:54,680 --> 00:18:00,960
join all the entries for for our three

00:17:58,350 --> 00:18:03,330
employees right the we concatenate all

00:18:00,960 --> 00:18:06,210
the lists and we will Union them all

00:18:03,330 --> 00:18:09,180
into single interval sets interval set

00:18:06,210 --> 00:18:11,220
of basically this interval set will

00:18:09,180 --> 00:18:12,930
represent all the intervals where at

00:18:11,220 --> 00:18:17,490
least one person is working right from

00:18:12,930 --> 00:18:19,020
them so and this will be the time where

00:18:17,490 --> 00:18:21,660
we can't have a meeting right because

00:18:19,020 --> 00:18:27,420
somebody is working and on the second

00:18:21,660 --> 00:18:29,670
step first we invert the someone

00:18:27,420 --> 00:18:31,920
occupies interval set right to get the

00:18:29,670 --> 00:18:33,600
interval set of periods where nobody is

00:18:31,920 --> 00:18:37,530
working this is what we need right this

00:18:33,600 --> 00:18:39,750
is this is the all the set of all time

00:18:37,530 --> 00:18:42,000
periods where nobody is working we

00:18:39,750 --> 00:18:47,610
intersect this so intersection is this

00:18:42,000 --> 00:18:50,370
inspire this and boolean and operator we

00:18:47,610 --> 00:18:52,230
intersect this with a workday to get the

00:18:50,370 --> 00:18:55,740
periods that belong only to our workday

00:18:52,230 --> 00:18:58,490
and the last thing we need to do here is

00:18:55,740 --> 00:19:01,320
to filter the duration so that small

00:18:58,490 --> 00:19:04,280
smaller intervals don't get into results

00:19:01,320 --> 00:19:07,800
for the possible meeting places so we

00:19:04,280 --> 00:19:10,170
materialize the interval sequence

00:19:07,800 --> 00:19:14,130
interval set to a list of intervals this

00:19:10,170 --> 00:19:16,890
is the like the part of the isomorphism

00:19:14,130 --> 00:19:19,980
that is provided by spire and we filter

00:19:16,890 --> 00:19:22,260
them by duration so we say that we need

00:19:19,980 --> 00:19:24,720
only the intervals for each the duration

00:19:22,260 --> 00:19:27,030
exists and that duration is more than

00:19:24,720 --> 00:19:29,900
one hour long so and if we run this we

00:19:27,030 --> 00:19:34,470
get the same result that we obtained

00:19:29,900 --> 00:19:36,570
basically manually right I have a an

00:19:34,470 --> 00:19:38,700
example running right so you can

00:19:36,570 --> 00:19:43,020
basically go to by the open this link

00:19:38,700 --> 00:19:45,380
and launch this caste worksheet so this

00:19:43,020 --> 00:19:50,150
all works yeah you can play around and

00:19:45,380 --> 00:19:52,980
just like try it try some other tasks

00:19:50,150 --> 00:19:54,600
second thing we look at is kind of this

00:19:52,980 --> 00:19:57,390
against calendar scheduling but like a

00:19:54,600 --> 00:20:01,530
little bit different this is more of

00:19:57,390 --> 00:20:04,530
like analytics related tasks so we need

00:20:01,530 --> 00:20:08,010
to see for like for some period like

00:20:04,530 --> 00:20:09,570
let's say 2017 we need to find all the

00:20:08,010 --> 00:20:11,669
periods where L is Bob and Charlie were

00:20:09,570 --> 00:20:13,559
working at the same time together so we

00:20:11,669 --> 00:20:16,280
need kind of to find the correlation

00:20:13,559 --> 00:20:19,350
between their kind of calendar entries

00:20:16,280 --> 00:20:24,419
this is again every is very very simple

00:20:19,350 --> 00:20:25,890
to solve first we'll do kind of it's

00:20:24,419 --> 00:20:29,940
it's almost the same thing we did in the

00:20:25,890 --> 00:20:31,710
first task but here we don't merge all

00:20:29,940 --> 00:20:33,620
the entries together in a single

00:20:31,710 --> 00:20:36,299
interval set but instead will create

00:20:33,620 --> 00:20:40,140
interval set for each employee so

00:20:36,299 --> 00:20:42,210
basically we just convert all the lists

00:20:40,140 --> 00:20:46,200
to interval sets so that we can work

00:20:42,210 --> 00:20:55,890
with them using spire and then we just

00:20:46,200 --> 00:20:59,820
take the each occupied is uh so we start

00:20:55,890 --> 00:21:02,070
with a set of all values basically this

00:20:59,820 --> 00:21:05,580
is this interval sequence o is a minus

00:21:02,070 --> 00:21:08,490
infinity to positive infinity and we

00:21:05,580 --> 00:21:13,169
start to intersect this using again end

00:21:08,490 --> 00:21:15,179
operation with with the sets we have so

00:21:13,169 --> 00:21:17,280
basically what what this means is we

00:21:15,179 --> 00:21:20,250
intersect all the interval sets together

00:21:17,280 --> 00:21:23,400
to get the common part of all of them

00:21:20,250 --> 00:21:27,900
all of this three and this will be

00:21:23,400 --> 00:21:31,650
actually our our result what we want so

00:21:27,900 --> 00:21:36,179
that the the set of intervals where all

00:21:31,650 --> 00:21:38,039
three employees work together so let's

00:21:36,179 --> 00:21:41,010
let's kind of step aside and see so we

00:21:38,039 --> 00:21:45,330
had this in our Union all right which is

00:21:41,010 --> 00:21:47,370
fold left using Union operation and in

00:21:45,330 --> 00:21:49,230
the last example we had again a fold

00:21:47,370 --> 00:21:57,059
left using intersection and starting

00:21:49,230 --> 00:21:59,630
with a interval of all values this

00:21:57,059 --> 00:22:02,090
things like looks similar and there

00:21:59,630 --> 00:22:04,130
they look familiar right so we probably

00:22:02,090 --> 00:22:05,930
have some abstraction here that we can

00:22:04,130 --> 00:22:09,620
use and the abstraction turns out to be

00:22:05,930 --> 00:22:13,160
a monoid and not only I'm annoyed

00:22:09,620 --> 00:22:16,430
actually this this thing is it's called

00:22:13,160 --> 00:22:21,080
bounder GLaDOS which is kind of

00:22:16,430 --> 00:22:27,500
mathematical term to explain that in a

00:22:21,080 --> 00:22:29,600
more approachable words bandit lettuce

00:22:27,500 --> 00:22:33,440
providers provides join and meet semi

00:22:29,600 --> 00:22:36,860
lattices each of them is a idempotent

00:22:33,440 --> 00:22:39,380
commutative monoid basically so what it

00:22:36,860 --> 00:22:42,650
gives us as a programmer programmers

00:22:39,380 --> 00:22:45,440
that we have to set mine eyes again this

00:22:42,650 --> 00:22:48,020
is not related to intervals or it an

00:22:45,440 --> 00:22:51,470
interval sets specifically it's it works

00:22:48,020 --> 00:22:54,380
for all sets that come from a common

00:22:51,470 --> 00:22:56,690
superset so we have a negative infinity

00:22:54,380 --> 00:23:00,170
to positive infinity which is the power

00:22:56,690 --> 00:23:02,450
set of all intervals right all the other

00:23:00,170 --> 00:23:05,120
intervals are subsets of that so we only

00:23:02,450 --> 00:23:08,420
have that construction we have two

00:23:05,120 --> 00:23:10,460
monoliths which one of which is starts

00:23:08,420 --> 00:23:13,160
with empty set as an identity element

00:23:10,460 --> 00:23:16,190
and the Union operation is the addition

00:23:13,160 --> 00:23:19,670
and another monoid is this this common

00:23:16,190 --> 00:23:22,430
power set as identity and there section

00:23:19,670 --> 00:23:26,180
as a addition iteration so that these

00:23:22,430 --> 00:23:28,430
abstractions really help to use kind of

00:23:26,180 --> 00:23:30,440
like not not write what we can like

00:23:28,430 --> 00:23:34,240
eliminate a lot of boilerplate and use

00:23:30,440 --> 00:23:39,170
or already work in code from cats and

00:23:34,240 --> 00:23:43,250
aspire that uses these instances so back

00:23:39,170 --> 00:23:47,810
to our problems there is a huge huge

00:23:43,250 --> 00:23:51,550
space of problems about resource

00:23:47,810 --> 00:23:55,460
allocation so one example can be

00:23:51,550 --> 00:23:57,620
allocating people to some work that has

00:23:55,460 --> 00:24:01,370
to be done in specific periods so we can

00:23:57,620 --> 00:24:06,410
take some grocery shop or another public

00:24:01,370 --> 00:24:08,780
publicly working business that needs

00:24:06,410 --> 00:24:10,780
some people to do some work not not by

00:24:08,780 --> 00:24:13,030
the volume the amount of

00:24:10,780 --> 00:24:17,950
word but the like to work for some time

00:24:13,030 --> 00:24:19,930
so that that's a very very tricky

00:24:17,950 --> 00:24:23,230
problem to solve in general and there

00:24:19,930 --> 00:24:27,250
are literally there's lots of various

00:24:23,230 --> 00:24:29,410
kind of the variety of different

00:24:27,250 --> 00:24:31,810
problems different aspects of these

00:24:29,410 --> 00:24:35,440
problems is really huge so there are

00:24:31,810 --> 00:24:40,690
lots of minimization problems you have

00:24:35,440 --> 00:24:43,930
to solve the the general idea is to

00:24:40,690 --> 00:24:45,550
match right the work and there are the

00:24:43,930 --> 00:24:49,420
resources and the requirements right so

00:24:45,550 --> 00:24:52,480
in in some optimal way and the optimal

00:24:49,420 --> 00:24:55,080
is defined in each tasks in each task a

00:24:52,480 --> 00:24:57,400
little bit differently so in some

00:24:55,080 --> 00:25:01,690
problems you need to minimize over time

00:24:57,400 --> 00:25:04,720
in some other problems need to comply to

00:25:01,690 --> 00:25:07,300
some local legislation and so on so that

00:25:04,720 --> 00:25:10,900
there is what the spectrum of these

00:25:07,300 --> 00:25:13,060
problems is really wide so it's hard to

00:25:10,900 --> 00:25:19,270
provide some really simple example that

00:25:13,060 --> 00:25:20,620
shows like that shows these problems in

00:25:19,270 --> 00:25:24,100
general so instead I'll just provide a

00:25:20,620 --> 00:25:28,210
smoke and a piece of solution of this

00:25:24,100 --> 00:25:30,100
kind of problem so this is kind of an

00:25:28,210 --> 00:25:34,030
attempt to solve resource allocation

00:25:30,100 --> 00:25:36,340
problem where requirement is a interval

00:25:34,030 --> 00:25:39,730
set so we again here use our elias's

00:25:36,340 --> 00:25:42,250
from the beginning requirement is an

00:25:39,730 --> 00:25:44,320
interval set of work that needs to be

00:25:42,250 --> 00:25:44,560
done basically this requirement will say

00:25:44,320 --> 00:25:50,020
so

00:25:44,560 --> 00:25:52,450
I need the a 8 to 15 shift every day

00:25:50,020 --> 00:25:54,700
like someone to work here and the work

00:25:52,450 --> 00:25:57,580
is actually the list of people who will

00:25:54,700 --> 00:25:58,480
work like the actual schedule that is

00:25:57,580 --> 00:26:02,890
currently active

00:25:58,480 --> 00:26:06,100
so John works at day one like L is Joe

00:26:02,890 --> 00:26:08,800
work works at day two and and so on and

00:26:06,100 --> 00:26:10,990
given these we can quickly calculate a

00:26:08,800 --> 00:26:14,590
set of important metrics for our

00:26:10,990 --> 00:26:16,990
solution for example which time was

00:26:14,590 --> 00:26:20,100
covered so which part of requirement was

00:26:16,990 --> 00:26:22,320
actually covered by some work

00:26:20,100 --> 00:26:24,090
even more important which time was not

00:26:22,320 --> 00:26:26,190
covered so basically when when our

00:26:24,090 --> 00:26:28,200
cashier desk is empty when nobody will

00:26:26,190 --> 00:26:30,330
stand here so this will show quickly

00:26:28,200 --> 00:26:33,299
show it this is like you can see this is

00:26:30,330 --> 00:26:35,519
a one-liner perspire and we can see

00:26:33,299 --> 00:26:37,950
unused time we're basically and wasted

00:26:35,519 --> 00:26:39,210
resources where some person comes to

00:26:37,950 --> 00:26:41,789
work but doesn't do any useful work

00:26:39,210 --> 00:26:46,489
because there is no requirement and like

00:26:41,789 --> 00:26:49,259
this is just an example of how simple

00:26:46,489 --> 00:26:53,220
solutions can be for really complex

00:26:49,259 --> 00:26:59,720
sounding problems and that so that's by

00:26:53,220 --> 00:27:03,769
using spire yeah so another dimension of

00:26:59,720 --> 00:27:07,529
real-world applications of spire is

00:27:03,769 --> 00:27:09,359
integration with the main because spire

00:27:07,529 --> 00:27:13,710
the spire intervals are purely

00:27:09,359 --> 00:27:16,619
mathematical thing and most of the time

00:27:13,710 --> 00:27:18,239
you don't need that in your domains it's

00:27:16,619 --> 00:27:19,979
it's very it's actually very good that

00:27:18,239 --> 00:27:22,229
people start to pay attention to

00:27:19,979 --> 00:27:24,509
relation between application code and

00:27:22,229 --> 00:27:27,119
business domain and this is really

00:27:24,509 --> 00:27:31,200
really great you can see that by recent

00:27:27,119 --> 00:27:34,259
rise of popularity in DDD the main

00:27:31,200 --> 00:27:38,450
driven development techniques people try

00:27:34,259 --> 00:27:41,970
to maintain their ubiquitous language

00:27:38,450 --> 00:27:44,609
very very well and yeah I tend to agree

00:27:41,970 --> 00:27:46,590
that that's really great and this is why

00:27:44,609 --> 00:27:49,859
I raised this topic here because spire

00:27:46,590 --> 00:27:51,720
is is not a good fit to be placed

00:27:49,859 --> 00:27:53,970
directly into your domain code because

00:27:51,720 --> 00:27:55,470
it's it's math most of the time you

00:27:53,970 --> 00:27:59,009
don't need math and your domain you need

00:27:55,470 --> 00:28:00,690
some real business related terms so the

00:27:59,009 --> 00:28:02,820
problem is that right intervals and it

00:28:00,690 --> 00:28:07,830
all sets are too broad for most domains

00:28:02,820 --> 00:28:10,049
because I would say that 99% of real

00:28:07,830 --> 00:28:12,539
world domains that need time intervals

00:28:10,049 --> 00:28:14,039
they don't require negative infinity for

00:28:12,539 --> 00:28:17,570
example you can't represent anything

00:28:14,039 --> 00:28:21,509
with negative infinity anything useful

00:28:17,570 --> 00:28:23,129
so most of the domains would actually do

00:28:21,509 --> 00:28:27,509
pretty well with just bounded value

00:28:23,129 --> 00:28:28,799
intervals on hand and so when your the

00:28:27,509 --> 00:28:30,539
problem is that when you're able to

00:28:28,799 --> 00:28:32,429
instantiate something that doesn't

00:28:30,539 --> 00:28:33,330
represent anything useful in your domain

00:28:32,429 --> 00:28:35,430
you're creating

00:28:33,330 --> 00:28:38,460
problems for yourself because these

00:28:35,430 --> 00:28:43,800
values now need somehow to be handled

00:28:38,460 --> 00:28:46,110
and so your programs ideal we must be

00:28:43,800 --> 00:28:49,830
able to present only the values that are

00:28:46,110 --> 00:28:51,870
valid in your domain right so that's why

00:28:49,830 --> 00:28:54,950
you should seriously consider separate

00:28:51,870 --> 00:28:58,260
domain suitable data structures

00:28:54,950 --> 00:29:02,220
basically you will have some business

00:28:58,260 --> 00:29:05,400
related data that will under the hood

00:29:02,220 --> 00:29:07,590
use aspire for performing this complex

00:29:05,400 --> 00:29:12,360
complex calculation and this will give

00:29:07,590 --> 00:29:15,720
you like total freedom in controlling

00:29:12,360 --> 00:29:18,300
what kind of values can be created also

00:29:15,720 --> 00:29:22,830
you can simply maintain your abacus

00:29:18,300 --> 00:29:25,170
language and gain other really really

00:29:22,830 --> 00:29:26,520
nice benefits so the only drawback of

00:29:25,170 --> 00:29:29,310
course is that you have to maintain your

00:29:26,520 --> 00:29:31,740
own set of data structures but but

00:29:29,310 --> 00:29:37,110
that's that's I think the benefits

00:29:31,740 --> 00:29:39,060
outweigh the drawbacks here right so

00:29:37,110 --> 00:29:42,450
that's that's kind of what I wanted to

00:29:39,060 --> 00:29:45,120
say about integration with the main this

00:29:42,450 --> 00:29:47,960
is very important so that your math math

00:29:45,120 --> 00:29:55,070
terms don't leak into your domain terms

00:29:47,960 --> 00:29:59,730
another several concerns that we have my

00:29:55,070 --> 00:30:01,530
slides are broken okay so another

00:29:59,730 --> 00:30:05,610
concerns about integration with the main

00:30:01,530 --> 00:30:07,410
that I wanted to go over is that yeah

00:30:05,610 --> 00:30:09,300
this is this already mentioned what kind

00:30:07,410 --> 00:30:11,820
of intervals makes sense in your domain

00:30:09,300 --> 00:30:14,490
this you should think about that really

00:30:11,820 --> 00:30:17,370
carefully because this may require you

00:30:14,490 --> 00:30:23,220
to throw exceptions if you don't handle

00:30:17,370 --> 00:30:25,440
that properly another thing is what kind

00:30:23,220 --> 00:30:27,270
of bounds do you need in your intervals

00:30:25,440 --> 00:30:29,040
this is also very important because if

00:30:27,270 --> 00:30:33,570
you're not careful with bounds you can

00:30:29,040 --> 00:30:36,240
have degraded intervals so when you have

00:30:33,570 --> 00:30:40,380
two intervals that that are adjacent and

00:30:36,240 --> 00:30:43,740
at the edges and edges you have two

00:30:40,380 --> 00:30:45,660
closed boundaries you get a intersection

00:30:43,740 --> 00:30:47,210
returns you degraded interval with one

00:30:45,660 --> 00:30:48,890
value so if if you

00:30:47,210 --> 00:30:51,169
don't need that you need to take some

00:30:48,890 --> 00:30:55,549
consistent approach to boundaries for

00:30:51,169 --> 00:30:59,299
example the one we took in in my project

00:30:55,549 --> 00:31:01,220
is to create always the sololift

00:30:59,299 --> 00:31:03,529
boundaries always closed and the right

00:31:01,220 --> 00:31:06,320
boundary is always open in this case you

00:31:03,529 --> 00:31:08,809
won't get any any degraded intervals

00:31:06,320 --> 00:31:12,500
ever in using using any kind of

00:31:08,809 --> 00:31:15,890
operations available another thing to

00:31:12,500 --> 00:31:19,760
consider is a time precision not only

00:31:15,890 --> 00:31:21,700
because of the the main concerns right

00:31:19,760 --> 00:31:25,510
so we your domain might not need

00:31:21,700 --> 00:31:30,559
nanoseconds or milliseconds but also

00:31:25,510 --> 00:31:32,750
like more coarse precision may allow you

00:31:30,559 --> 00:31:37,850
to use faster interval try data

00:31:32,750 --> 00:31:40,370
structure which is also benefit ordering

00:31:37,850 --> 00:31:41,630
inequality I discussed that in in the

00:31:40,370 --> 00:31:44,870
beginning in the beginning of the talk

00:31:41,630 --> 00:31:48,049
so you might need strict strict ordering

00:31:44,870 --> 00:31:50,990
or more relaxed equality that uses

00:31:48,049 --> 00:31:53,570
instant comparison so this is also thing

00:31:50,990 --> 00:31:57,470
to consider and try to avoid avoid

00:31:53,570 --> 00:32:00,529
leaking aspire terms aspire types into

00:31:57,470 --> 00:32:03,520
your domain so that people business

00:32:00,529 --> 00:32:07,610
people reading your code don't have to

00:32:03,520 --> 00:32:09,770
like ask you what is semi-lattice like

00:32:07,610 --> 00:32:13,490
what am i no it isn't and stuff like

00:32:09,770 --> 00:32:16,039
that so yeah that's that's basically all

00:32:13,490 --> 00:32:20,419
I have thank you Scala days for inviting

00:32:16,039 --> 00:32:23,500
me and thank you all for coming and we

00:32:20,419 --> 00:32:23,500
have time for questions right

00:32:29,980 --> 00:32:43,610
yeah do we have a microphone for thank

00:32:41,299 --> 00:32:47,059
you for presentation could you give a

00:32:43,610 --> 00:32:51,919
couple of other useful examples of

00:32:47,059 --> 00:32:55,389
sorting except the time I mean of using

00:32:51,919 --> 00:32:55,389
intervals yeah okay

00:32:56,289 --> 00:33:03,860
so there there is a slide above let me

00:33:00,049 --> 00:33:07,669
scroll about problems that are solved

00:33:03,860 --> 00:33:11,840
with intervals there is kind of fuzzy

00:33:07,669 --> 00:33:14,720
logic is very useful application so for

00:33:11,840 --> 00:33:17,029
example expert systems they use a lot of

00:33:14,720 --> 00:33:19,789
fuzzy logic so you're basically your

00:33:17,029 --> 00:33:21,710
result of your calculations lies in some

00:33:19,789 --> 00:33:23,120
range so basically you provide as a

00:33:21,710 --> 00:33:24,919
result you don't provide a value you

00:33:23,120 --> 00:33:27,529
provide some range so this this is

00:33:24,919 --> 00:33:30,049
basically the kind of scheduling is a

00:33:27,529 --> 00:33:32,409
side application the main application is

00:33:30,049 --> 00:33:36,259
uncertainty so if you want to provide

00:33:32,409 --> 00:33:39,909
your like users or like whoever calls

00:33:36,259 --> 00:33:42,769
your API if you want to provide some

00:33:39,909 --> 00:33:46,730
some range this this is a way to go

00:33:42,769 --> 00:33:48,559
because yeah you can because the spire

00:33:46,730 --> 00:33:52,070
allows you to operate on this ranges so

00:33:48,559 --> 00:33:53,870
there is interval arithmetic for example

00:33:52,070 --> 00:33:59,000
and you can loop that so I would say

00:33:53,870 --> 00:34:00,710
mostly it's kind of science but also for

00:33:59,000 --> 00:34:03,950
a very very complex system there can be

00:34:00,710 --> 00:34:07,519
multi-dimensional constraints like and

00:34:03,950 --> 00:34:10,190
it's also so for example you have some

00:34:07,519 --> 00:34:12,589
interval set of allows values on some

00:34:10,190 --> 00:34:15,940
for example you have a manufacturing

00:34:12,589 --> 00:34:19,460
facility and you need to check some

00:34:15,940 --> 00:34:22,129
metrics of some devices like so that

00:34:19,460 --> 00:34:28,030
they lie in some ranges so that's also

00:34:22,129 --> 00:34:28,030
useful application for example yeah

00:34:30,560 --> 00:34:36,150
laughs use exactly this thing not this

00:34:33,750 --> 00:34:38,580
one when something in Java that was

00:34:36,150 --> 00:34:40,740
equivalent and there was an SLA

00:34:38,580 --> 00:34:43,290
requirement and we had like systems that

00:34:40,740 --> 00:34:45,750
were down and happened and so the time

00:34:43,290 --> 00:34:48,240
thing happened a couple of times in my

00:34:45,750 --> 00:34:51,090
life and hopefully we'll have a cup of

00:34:48,240 --> 00:34:56,730
comes to others too yeah yeah great

00:34:51,090 --> 00:35:04,410
great example yeah thanks here in the

00:34:56,730 --> 00:35:06,830
middle hi thanks for the talk and do you

00:35:04,410 --> 00:35:09,540
have a way inspire to represent

00:35:06,830 --> 00:35:14,370
something higher dimension so like

00:35:09,540 --> 00:35:16,740
rectangles and to use all you know they

00:35:14,370 --> 00:35:19,640
you mean like multi-dimensional

00:35:16,740 --> 00:35:23,160
intervals like that or so like seeing

00:35:19,640 --> 00:35:26,070
like a rectangle that is a product of

00:35:23,160 --> 00:35:28,770
two intervals I don't think so

00:35:26,070 --> 00:35:30,720
yeah I don't think so but yeah I don't

00:35:28,770 --> 00:35:31,310
think so the there is something like

00:35:30,720 --> 00:35:34,260
that

00:35:31,310 --> 00:35:36,810
actually I would ask you in in return

00:35:34,260 --> 00:35:38,310
like what kind of applications just just

00:35:36,810 --> 00:35:41,070
out of interest what kind of application

00:35:38,310 --> 00:35:46,890
so yeah we had a use case quite recently

00:35:41,070 --> 00:35:49,170
about using time so in two dimensions so

00:35:46,890 --> 00:35:51,930
one was the time when the user was

00:35:49,170 --> 00:35:54,420
trying to access something and the other

00:35:51,930 --> 00:35:57,180
dimension was the time the content was

00:35:54,420 --> 00:35:59,370
published okay and we had to do

00:35:57,180 --> 00:36:02,220
something similar but basically in with

00:35:59,370 --> 00:36:06,030
rectangles instead of intervals so using

00:36:02,220 --> 00:36:08,700
all these algebra combinators and check

00:36:06,030 --> 00:36:10,970
the intersection against the Union task

00:36:08,700 --> 00:36:19,160
oh sorry Rico

00:36:10,970 --> 00:36:21,589
thank you the spire ik profiles

00:36:19,160 --> 00:36:23,480
realization format because the common

00:36:21,589 --> 00:36:26,810
problem is how do I put those in my

00:36:23,480 --> 00:36:28,400
database no of course not because they

00:36:26,810 --> 00:36:30,619
like sterilization is a total like

00:36:28,400 --> 00:36:32,300
orthogonal concern right so there are

00:36:30,619 --> 00:36:34,220
only these data structures the way you

00:36:32,300 --> 00:36:38,780
want to serialize them is like

00:36:34,220 --> 00:36:41,210
completely up to you so we if you wanna

00:36:38,780 --> 00:36:42,530
something out of the box I I think there

00:36:41,210 --> 00:36:44,480
would be a problem with intervals

00:36:42,530 --> 00:36:46,700
because they are not and there is no a

00:36:44,480 --> 00:36:49,010
public IDT so you have you have to

00:36:46,700 --> 00:36:52,579
invent something like by hand because

00:36:49,010 --> 00:36:54,170
it's like the commonly known for example

00:36:52,579 --> 00:36:55,849
Jason libraries they couldn't they would

00:36:54,170 --> 00:36:57,050
not derive your some codecs

00:36:55,849 --> 00:36:59,660
automatically because there's no public

00:36:57,050 --> 00:37:04,310
editing so answering your question no no

00:36:59,660 --> 00:37:09,589
sterilization some other yeah that

00:37:04,310 --> 00:37:14,210
they're they're also me back hi is spire

00:37:09,589 --> 00:37:17,780
able to resolve optimization problems

00:37:14,210 --> 00:37:22,280
like convex optimization linear

00:37:17,780 --> 00:37:26,060
optimization in such a contexts there

00:37:22,280 --> 00:37:29,930
are some actually as I said spire is a

00:37:26,060 --> 00:37:32,510
really huge toolkit so I I didn't like

00:37:29,930 --> 00:37:34,609
dig into all the and a branch so it has

00:37:32,510 --> 00:37:38,119
a lot of different kind of branches of

00:37:34,609 --> 00:37:40,730
problems solved there are some mmm

00:37:38,119 --> 00:37:43,720
there are some algorithms there for sure

00:37:40,730 --> 00:37:46,849
I've seen some like gradient

00:37:43,720 --> 00:37:50,240
optimizations I guess so but I didn't

00:37:46,849 --> 00:37:52,369
haven't explored that side of spire but

00:37:50,240 --> 00:37:53,750
you should check that out there are

00:37:52,369 --> 00:37:56,210
there are lots of things you might find

00:37:53,750 --> 00:37:57,859
something of that like I saw something

00:37:56,210 --> 00:38:01,730
something useful so there are definitely

00:37:57,859 --> 00:38:03,800
some algorithms inside but I I'm not

00:38:01,730 --> 00:38:06,470
like I haven't discovered like a lot of

00:38:03,800 --> 00:38:11,030
like haven't explored that area so

00:38:06,470 --> 00:38:13,550
couldn't can't really say yeah hi thank

00:38:11,030 --> 00:38:18,760
you for presentation so I would like to

00:38:13,550 --> 00:38:19,990
ask about the if you use some real

00:38:18,760 --> 00:38:24,420
application

00:38:19,990 --> 00:38:28,619
how about performance because on

00:38:24,420 --> 00:38:31,740
on unlimited bound for plus or minus I

00:38:28,619 --> 00:38:33,779
think we'll have a couple a lot of

00:38:31,740 --> 00:38:36,180
computation thank you

00:38:33,779 --> 00:38:38,430
yeah performance is really well and they

00:38:36,180 --> 00:38:41,190
actually the encoding of these intervals

00:38:38,430 --> 00:38:44,640
is really a concise so you don't for

00:38:41,190 --> 00:38:46,799
example if you take interval set right

00:38:44,640 --> 00:38:48,420
you don't need to store all the values

00:38:46,799 --> 00:38:52,769
because the amount of values is infinite

00:38:48,420 --> 00:38:55,710
you store only the kind of points the so

00:38:52,769 --> 00:38:59,039
if you draw the interval like the line

00:38:55,710 --> 00:39:00,869
of numbers right so you're in basically

00:38:59,039 --> 00:39:04,440
interval set can be represented just as

00:39:00,869 --> 00:39:06,150
a array of points where there is some

00:39:04,440 --> 00:39:07,799
boundary and you just need to encode

00:39:06,150 --> 00:39:09,930
what happens at this boundary well like

00:39:07,799 --> 00:39:12,450
is does the interval start or does the

00:39:09,930 --> 00:39:15,660
interval end oh and if it's a closed on

00:39:12,450 --> 00:39:18,769
hand or open boundary and that's it so

00:39:15,660 --> 00:39:23,519
and the amount of computation is also

00:39:18,769 --> 00:39:24,779
really really small so you if you you're

00:39:23,519 --> 00:39:27,650
interested in this problem you should

00:39:24,779 --> 00:39:31,200
definitely watch this talk by a rüdiger

00:39:27,650 --> 00:39:33,509
where's that yeah this first middle

00:39:31,200 --> 00:39:35,400
interval sets it's called world last

00:39:33,509 --> 00:39:37,650
year he goes into detail so the

00:39:35,400 --> 00:39:39,180
representation and amount of work that

00:39:37,650 --> 00:39:40,829
needs to be done to do the oldest

00:39:39,180 --> 00:39:44,700
calculations really small so that's

00:39:40,829 --> 00:39:46,740
that's that's the point just to the

00:39:44,700 --> 00:39:50,250
question serialization I think it's

00:39:46,740 --> 00:39:52,559
relatively trivial to come up with a

00:39:50,250 --> 00:39:55,529
serialization with it because we have a

00:39:52,559 --> 00:39:57,299
kind of a sorted list and it can be

00:39:55,529 --> 00:39:59,309
empty or something and then we have

00:39:57,299 --> 00:40:01,140
three types of boundaries we have the

00:39:59,309 --> 00:40:03,089
upper and the lower can you Ashby UN or

00:40:01,140 --> 00:40:06,599
any of the three and in two of the cases

00:40:03,089 --> 00:40:08,150
you need a value and then it's extremely

00:40:06,599 --> 00:40:10,859
trivial to find a data price

00:40:08,150 --> 00:40:14,029
representation or a json or xml whatever

00:40:10,859 --> 00:40:17,369
you like but it's not out of the box yes

00:40:14,029 --> 00:40:18,839
totally correct yeah so the actual read

00:40:17,369 --> 00:40:21,630
the actual data that needs to encode

00:40:18,839 --> 00:40:24,450
that is needed to encode a interval set

00:40:21,630 --> 00:40:27,029
is really small so you just need write

00:40:24,450 --> 00:40:29,390
the points and the type of this points

00:40:27,029 --> 00:40:29,390

YouTube URL: https://www.youtube.com/watch?v=JpEuEFtecIE


