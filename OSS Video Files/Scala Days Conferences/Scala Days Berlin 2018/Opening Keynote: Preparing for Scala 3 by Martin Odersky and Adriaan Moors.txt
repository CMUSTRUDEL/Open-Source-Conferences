Title: Opening Keynote: Preparing for Scala 3 by Martin Odersky and Adriaan Moors
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6900-opening-keynote%3A-preparing-for-scala-3.html
Captions: 
	00:00:04,590 --> 00:00:09,719
hello I guess Martin oh there he is I

00:00:07,200 --> 00:00:12,150
guess I get to do a few slides first and

00:00:09,719 --> 00:00:16,260
distract you and Martin wanted to work

00:00:12,150 --> 00:00:20,609
on his slides a little bit more we taped

00:00:16,260 --> 00:00:24,499
on his computer I think I hope so yeah

00:00:20,609 --> 00:00:28,220
it's uh it's great to be on state here I

00:00:24,499 --> 00:00:31,499
I finally made my way into a keynote

00:00:28,220 --> 00:00:40,290
sorry I haven't spoken before I was busy

00:00:31,499 --> 00:00:42,600
making to compiler slower so you don't

00:00:40,290 --> 00:00:43,510
mind okay keep doing that it's no

00:00:42,600 --> 00:00:44,780
problem

00:00:43,510 --> 00:00:46,800
[Music]

00:00:44,780 --> 00:00:51,390
wow you guys applaud it so hard to

00:00:46,800 --> 00:00:53,670
screen is shaking so I'm really really

00:00:51,390 --> 00:00:56,810
happy to start the presentation with

00:00:53,670 --> 00:01:01,500
this slide and especially the next one

00:00:56,810 --> 00:01:06,330
last time we were here into 2014 I just

00:01:01,500 --> 00:01:08,280
had to look it up we didn't really have

00:01:06,330 --> 00:01:10,439
an inkling that this was going to be on

00:01:08,280 --> 00:01:15,479
a site a few years later and and here we

00:01:10,439 --> 00:01:17,939
are and I guess you know the next slide

00:01:15,479 --> 00:01:19,950
really speaks for the previous one the

00:01:17,939 --> 00:01:21,719
convergence I think is stunning for you

00:01:19,950 --> 00:01:24,899
for those of you who are project

00:01:21,719 --> 00:01:26,249
managers you know it looks it looks a

00:01:24,899 --> 00:01:30,090
lot alike

00:01:26,249 --> 00:01:33,149
you'll see that 2015 dropped off because

00:01:30,090 --> 00:01:35,909
we feel confident that after two 14 we

00:01:33,149 --> 00:01:38,819
can switch over to the 3-0 series of the

00:01:35,909 --> 00:01:41,969
language you know while Martin was busy

00:01:38,819 --> 00:01:44,490
working on dotty we were on the on the

00:01:41,969 --> 00:01:48,299
evil corporate side working on the Scala

00:01:44,490 --> 00:01:50,209
2 series where you know basically the

00:01:48,299 --> 00:01:53,310
crossover of a lot of the dodgy stuff

00:01:50,209 --> 00:01:56,069
happening in 212 where the function

00:01:53,310 --> 00:01:57,810
encoding the trade encoding the internal

00:01:56,069 --> 00:01:59,880
way of representing fields and traits

00:01:57,810 --> 00:02:01,799
and stuff like that were already aligned

00:01:59,880 --> 00:02:05,219
with the way that dotty did it and then

00:02:01,799 --> 00:02:07,170
you know we saw how that fared with

00:02:05,219 --> 00:02:09,869
hotspot and tweaked some stuff in the

00:02:07,170 --> 00:02:11,250
encoding so there's been this great you

00:02:09,869 --> 00:02:15,959
know dynamics already between a team

00:02:11,250 --> 00:02:18,400
since since 2016 in 213 as you know and

00:02:15,959 --> 00:02:22,320
there will be talks about that tomorrow

00:02:18,400 --> 00:02:25,090
we standardize on the new collections

00:02:22,320 --> 00:02:28,300
rumor is it that you know Kendall from

00:02:25,090 --> 00:02:30,840
wasn't your favorite thing we really

00:02:28,300 --> 00:02:35,740
vastly simplified it and it's now called

00:02:30,840 --> 00:02:37,660
built from I think gogosi Stefan's

00:02:35,740 --> 00:02:40,120
talked about you know how often it is

00:02:37,660 --> 00:02:42,130
used the hint is not not very often

00:02:40,120 --> 00:02:44,500
anymore only really where where you need

00:02:42,130 --> 00:02:46,660
it so really really happy with that

00:02:44,500 --> 00:02:48,010
simplification really happy with you

00:02:46,660 --> 00:02:49,840
know the foundation for the standard

00:02:48,010 --> 00:02:52,660
library that is basically going to be

00:02:49,840 --> 00:02:57,220
two scholar three standard library as

00:02:52,660 --> 00:02:59,260
well and yeah go see Stefan's talk for

00:02:57,220 --> 00:03:01,959
more details about that so the next

00:02:59,260 --> 00:03:04,630
phase of alignment we're focusing on on

00:03:01,959 --> 00:03:06,730
the compiler so imagine taking these

00:03:04,630 --> 00:03:08,050
these timelines and kind of you know

00:03:06,730 --> 00:03:10,450
there's there's this zipper at the top

00:03:08,050 --> 00:03:11,770
and you just kind of pull it down that's

00:03:10,450 --> 00:03:13,270
what we've been doing all this time and

00:03:11,770 --> 00:03:14,380
we're gonna take the two back ends are

00:03:13,270 --> 00:03:16,230
already the same so the way that

00:03:14,380 --> 00:03:19,930
bytecode is emitted is the same already

00:03:16,230 --> 00:03:21,700
and we're gonna shift our gaze towards

00:03:19,930 --> 00:03:23,560
the middle and we're you know we have a

00:03:21,700 --> 00:03:26,590
you know to type checkers basically

00:03:23,560 --> 00:03:29,530
emitting tasty typed types abstract

00:03:26,590 --> 00:03:34,450
syntax trees why you'll have to ask

00:03:29,530 --> 00:03:36,760
Martin what the Y stands for and and so

00:03:34,450 --> 00:03:38,709
with with that convergence I think we're

00:03:36,760 --> 00:03:43,900
gonna be in a really really good spot

00:03:38,709 --> 00:03:46,900
for for TF to scale three cycle then

00:03:43,900 --> 00:03:47,980
before we get to the to the main event I

00:03:46,900 --> 00:03:51,190
won't speak for much longer

00:03:47,980 --> 00:03:53,320
I have a compiler to make slower also

00:03:51,190 --> 00:03:56,410
really excited to announce that we're

00:03:53,320 --> 00:03:58,019
standardizing on the apache license you

00:03:56,410 --> 00:04:02,950
can read all about it

00:03:58,019 --> 00:04:05,380
thank you lawyers were wrangled blog

00:04:02,950 --> 00:04:07,150
posts were written and let us know if

00:04:05,380 --> 00:04:09,640
somehow you know those who weren't

00:04:07,150 --> 00:04:11,860
clapping i see you all of you but if

00:04:09,640 --> 00:04:12,700
you're not happy let us know this is not

00:04:11,860 --> 00:04:14,890
a done deal

00:04:12,700 --> 00:04:16,810
most of you have signed the CLA who've

00:04:14,890 --> 00:04:18,220
contributed but maybe there's a few who

00:04:16,810 --> 00:04:20,620
you know don't have or have other

00:04:18,220 --> 00:04:22,750
legitimate objections let us know

00:04:20,620 --> 00:04:26,890
there's our contact details or in the

00:04:22,750 --> 00:04:29,620
blog post the other thing is that we're

00:04:26,890 --> 00:04:31,480
kicking off a hopefully annual tradition

00:04:29,620 --> 00:04:33,160
of developer surveys

00:04:31,480 --> 00:04:36,730
together with the Scala Center and any

00:04:33,160 --> 00:04:38,650
pfl Martin's team we would really really

00:04:36,730 --> 00:04:40,210
like to get your feedback on not just

00:04:38,650 --> 00:04:42,400
you know now in the hallway but also

00:04:40,210 --> 00:04:44,920
let's record it with computers on the

00:04:42,400 --> 00:04:46,690
internet and you know collect results

00:04:44,920 --> 00:04:49,120
and and incorporate those into our

00:04:46,690 --> 00:04:50,620
roadmaps so we will have this running

00:04:49,120 --> 00:04:52,660
for the next two months until after the

00:04:50,620 --> 00:04:53,890
next Scala days it's about 25 questions

00:04:52,660 --> 00:04:55,840
won't take too long

00:04:53,890 --> 00:04:57,310
completely anonymous but you know if you

00:04:55,840 --> 00:04:59,170
have any questions or come find me

00:04:57,310 --> 00:05:01,780
during a conference send us an email

00:04:59,170 --> 00:05:03,670
there's a thread also on discourse a few

00:05:01,780 --> 00:05:05,410
if you have any concerns around it or

00:05:03,670 --> 00:05:07,390
just want to you know have a debate

00:05:05,410 --> 00:05:11,260
around it rather than just a monologue

00:05:07,390 --> 00:05:13,120
on the survey so with that very excited

00:05:11,260 --> 00:05:26,290
to switch over to Martin thank you very

00:05:13,120 --> 00:05:28,180
much okay okay so Adrian has given you

00:05:26,290 --> 00:05:30,010
the road map which was sort of the road

00:05:28,180 --> 00:05:33,520
map all along and it's nice to see how

00:05:30,010 --> 00:05:35,950
well it has kept up and at the end of

00:05:33,520 --> 00:05:38,920
that road map is Scalla 3 which will be

00:05:35,950 --> 00:05:41,920
a major disruption as people like to say

00:05:38,920 --> 00:05:44,100
in the startup scene so if you do that

00:05:41,920 --> 00:05:46,540
and the question of course is why why

00:05:44,100 --> 00:05:49,740
are we essentially changing the language

00:05:46,540 --> 00:05:54,540
to marry it essentially a new major

00:05:49,740 --> 00:05:56,890
super major number from 2 to 3 so I

00:05:54,540 --> 00:05:58,990
probably should explain why for me

00:05:56,890 --> 00:06:01,180
personally also that's that's something

00:05:58,990 --> 00:06:04,780
that I believe is really important so

00:06:01,180 --> 00:06:07,300
because it has to do with the essence of

00:06:04,780 --> 00:06:10,120
Scala so the essence of Scala at least

00:06:07,300 --> 00:06:12,100
as far as I am concerned is the fusion

00:06:10,120 --> 00:06:15,340
of functional and object-oriented

00:06:12,100 --> 00:06:17,920
programming in a typesetting diffusion

00:06:15,340 --> 00:06:19,180
has been done before with languages like

00:06:17,920 --> 00:06:21,070
small talk a little bit more

00:06:19,180 --> 00:06:22,870
object-oriented with functional elements

00:06:21,070 --> 00:06:24,550
and silos it'll be a little bit more

00:06:22,870 --> 00:06:27,160
functional with object-oriented elements

00:06:24,550 --> 00:06:29,530
but it was all dynamically typed and I

00:06:27,160 --> 00:06:32,620
think the first mainstream language that

00:06:29,530 --> 00:06:34,900
actually achieved that fusion was Scala

00:06:32,620 --> 00:06:37,120
which I don't want to essentially ignore

00:06:34,900 --> 00:06:39,310
other languages this came before such as

00:06:37,120 --> 00:06:42,910
oak ammo that that tried that but I

00:06:39,310 --> 00:06:44,249
think a it wasn't as mainstream and B it

00:06:42,910 --> 00:06:45,809
was more and

00:06:44,249 --> 00:06:47,939
Meishan that means two languages

00:06:45,809 --> 00:06:50,159
side-by-side and people use one or the

00:06:47,939 --> 00:06:52,949
other and less effusion which is what I

00:06:50,159 --> 00:06:55,739
think Scala has tried and done so

00:06:52,949 --> 00:06:57,989
diffusion roughly if you say well what

00:06:55,739 --> 00:07:00,659
what part do I use for what I guess

00:06:57,989 --> 00:07:03,239
every program uses both functions and

00:07:00,659 --> 00:07:05,309
objects and generally functions tend to

00:07:03,239 --> 00:07:07,079
be used for essentially the logic of the

00:07:05,309 --> 00:07:10,409
program and objects for the modularity

00:07:07,079 --> 00:07:12,029
objects are there to essentially outline

00:07:10,409 --> 00:07:14,279
the components of your program

00:07:12,029 --> 00:07:16,049
so that's the essence and then the

00:07:14,279 --> 00:07:18,360
question is well where we're successful

00:07:16,049 --> 00:07:21,629
with that and by at least one measure we

00:07:18,360 --> 00:07:23,789
were immensely successful because I

00:07:21,629 --> 00:07:26,389
think that Scala was the first language

00:07:23,789 --> 00:07:28,799
that starting from a statically typed

00:07:26,389 --> 00:07:30,869
object-oriented core language we

00:07:28,799 --> 00:07:32,639
pioneered a lot of essentially new

00:07:30,869 --> 00:07:35,329
things that are now pretty commonplace

00:07:32,639 --> 00:07:37,739
such as closures function types

00:07:35,329 --> 00:07:39,869
expression orientation so know

00:07:37,739 --> 00:07:43,469
essentially everything is every

00:07:39,869 --> 00:07:46,459
statement returns the value tuples local

00:07:43,469 --> 00:07:50,639
type inference pattern matching traits

00:07:46,459 --> 00:07:52,979
lazy values by name parameters then the

00:07:50,639 --> 00:07:55,949
X colon T syntax yes it existed before

00:07:52,979 --> 00:07:58,019
in Pascal and ml but it was all but

00:07:55,949 --> 00:08:00,179
forgotten when Scala came up up on the

00:07:58,019 --> 00:08:01,709
scene and now it sort of has a revival

00:08:00,179 --> 00:08:04,529
and a lot of new languages are doing the

00:08:01,709 --> 00:08:06,569
same dependent types implicit parameters

00:08:04,529 --> 00:08:10,769
and a lot more so it's a lot of features

00:08:06,569 --> 00:08:12,719
and we are by now in 2018 we're not

00:08:10,769 --> 00:08:14,819
alone many other languages have followed

00:08:12,719 --> 00:08:16,789
suite by adopting a subset of these

00:08:14,819 --> 00:08:19,019
features I just mentioned c-sharp

00:08:16,789 --> 00:08:21,989
adopted quite a lot of them Cortland

00:08:19,019 --> 00:08:24,569
Swift Java Java is a late comer but

00:08:21,989 --> 00:08:27,929
every year that opts on one more feature

00:08:24,569 --> 00:08:30,749
that that so so you could say well Scala

00:08:27,929 --> 00:08:34,250
as it was conceived is really where a

00:08:30,749 --> 00:08:37,439
large part of the industry is moving to

00:08:34,250 --> 00:08:39,599
so in that sense it's success but it's

00:08:37,439 --> 00:08:42,659
maybe not an unqualified success because

00:08:39,599 --> 00:08:44,910
I think that Scala also has quite its

00:08:42,659 --> 00:08:47,279
share of challenges and there are still

00:08:44,910 --> 00:08:50,819
a lot of ways to essentially derail the

00:08:47,279 --> 00:08:53,100
project and I think that if I talk about

00:08:50,819 --> 00:08:56,069
possible derailing the project I would

00:08:53,100 --> 00:08:58,140
say that the it typically comes from two

00:08:56,069 --> 00:09:00,240
sides and both sides sort of see Oh

00:08:58,140 --> 00:09:03,120
some part of Scala and ignore the other

00:09:00,240 --> 00:09:05,970
so one part would be to conceive Scala

00:09:03,120 --> 00:09:08,339
is nothing but a worse Haskell on the

00:09:05,970 --> 00:09:10,470
JVM and the other side would be to

00:09:08,339 --> 00:09:13,860
conceive Scala is nothing but a better

00:09:10,470 --> 00:09:16,079
job of and ignore the deep parts so both

00:09:13,860 --> 00:09:18,120
take 1/2 of Scala features and ignore

00:09:16,079 --> 00:09:20,660
the synthesis and I want to talk a

00:09:18,120 --> 00:09:24,959
little bit about either movement either

00:09:20,660 --> 00:09:26,899
tenancy so on the functional side there

00:09:24,959 --> 00:09:29,820
was the name Haskell later which was

00:09:26,899 --> 00:09:32,459
coined by my former students understood

00:09:29,820 --> 00:09:36,510
so Haskell item in Scala is sort of the

00:09:32,459 --> 00:09:38,040
elevator towards towards Haskell and for

00:09:36,510 --> 00:09:40,680
quite a few people that's actually being

00:09:38,040 --> 00:09:42,839
true which I don't think is bad at all

00:09:40,680 --> 00:09:46,260
it's great Haskell is a great

00:09:42,839 --> 00:09:48,540
programming language and I don't want to

00:09:46,260 --> 00:09:52,140
at all to essentially diminish it in any

00:09:48,540 --> 00:09:54,000
way but Scala I believe is not a very

00:09:52,140 --> 00:09:56,040
good basis for emulating all of

00:09:54,000 --> 00:09:58,950
Haskell's patterns it simply isn't it

00:09:56,040 --> 00:10:00,060
lacks and I guess if you move to ask and

00:09:58,950 --> 00:10:01,740
you will feel that there are certain

00:10:00,060 --> 00:10:03,810
things that are just much smoother in

00:10:01,740 --> 00:10:06,750
Haskell then they can ever be in Scala

00:10:03,810 --> 00:10:09,180
so if you choose to ignore scholars

00:10:06,750 --> 00:10:11,430
object-oriented parts there's little

00:10:09,180 --> 00:10:13,170
point in using it at all I mean why why

00:10:11,430 --> 00:10:17,070
not use Haskell or maybe one of the

00:10:13,170 --> 00:10:18,959
Haskell versions on the JVM so that's I

00:10:17,070 --> 00:10:21,329
think one part of it the other part is

00:10:18,959 --> 00:10:23,040
better Java without scholar steep parts

00:10:21,329 --> 00:10:25,410
and that's us we're essentially a lot of

00:10:23,040 --> 00:10:28,410
other languages sort of jumped on the

00:10:25,410 --> 00:10:30,839
scene or slowly move like tankers on the

00:10:28,410 --> 00:10:33,779
scene so new languages such as Scotland

00:10:30,839 --> 00:10:36,240
or Swift and also of course improvements

00:10:33,779 --> 00:10:39,360
of existing languages such as C sharp

00:10:36,240 --> 00:10:42,360
and Java so there generally you see that

00:10:39,360 --> 00:10:44,490
they trade I mean they're moving in the

00:10:42,360 --> 00:10:47,850
same space but trailing abstraction on

00:10:44,490 --> 00:10:50,399
composition for more features and I

00:10:47,850 --> 00:10:52,079
would probably lean out the window a

00:10:50,399 --> 00:10:54,750
little bit and say more ad hoc features

00:10:52,079 --> 00:10:57,000
so one other things that these languages

00:10:54,750 --> 00:10:59,120
do which actually works pretty well is

00:10:57,000 --> 00:11:01,890
that they avoid the more esoteric

00:10:59,120 --> 00:11:04,199
functional programming parts by making

00:11:01,890 --> 00:11:06,240
it less pleasant to express them so that

00:11:04,199 --> 00:11:08,220
means that essentially you have less of

00:11:06,240 --> 00:11:11,010
a culture path all that you say in one

00:11:08,220 --> 00:11:11,730
team well how should we write our

00:11:11,010 --> 00:11:13,860
programs the

00:11:11,730 --> 00:11:15,240
way or that way in these languages that

00:11:13,860 --> 00:11:17,220
clearly state could take a stand and

00:11:15,240 --> 00:11:19,709
they say while it's possible to do some

00:11:17,220 --> 00:11:22,440
functional programming idioms it's just

00:11:19,709 --> 00:11:25,740
not very pleasant so it's it's not super

00:11:22,440 --> 00:11:29,310
recommended another thing that I believe

00:11:25,740 --> 00:11:32,279
that these languages promote is that by

00:11:29,310 --> 00:11:34,800
having a larger language programs tend

00:11:32,279 --> 00:11:36,810
to be simplified because essentially

00:11:34,800 --> 00:11:38,639
there's more essentially a more features

00:11:36,810 --> 00:11:41,310
that are sort of recipes that you can

00:11:38,639 --> 00:11:43,470
just mix and take up Scala is often

00:11:41,310 --> 00:11:46,649
criticized for being an immense language

00:11:43,470 --> 00:11:48,149
and that frustrates me a little bit

00:11:46,649 --> 00:11:50,610
because if you look at the data it's

00:11:48,149 --> 00:11:52,410
absolutely not true and I just show you

00:11:50,610 --> 00:11:55,290
the data it's just one measure but there

00:11:52,410 --> 00:11:58,889
are others as well so here's the size of

00:11:55,290 --> 00:12:00,750
the language in in lines of grammar size

00:11:58,889 --> 00:12:02,850
so essentially number of syntax rules

00:12:00,750 --> 00:12:04,079
could also measure a number of key words

00:12:02,850 --> 00:12:06,779
that would essentially give you

00:12:04,079 --> 00:12:09,089
fundamentally the same grass so you see

00:12:06,779 --> 00:12:12,660
here's here's gotta so it's it's more

00:12:09,089 --> 00:12:14,250
complex in Haskell but that Haskell here

00:12:12,660 --> 00:12:16,620
is actually the base Haskell Haskell 98

00:12:14,250 --> 00:12:19,199
which nobody ever uses and you would

00:12:16,620 --> 00:12:21,029
have to add the 85 actually language

00:12:19,199 --> 00:12:23,910
flags and language extensions that

00:12:21,029 --> 00:12:26,100
essentially - to that but - that graph

00:12:23,910 --> 00:12:28,230
and I think then the bar would be quite

00:12:26,100 --> 00:12:30,449
a bit higher and then over here you have

00:12:28,230 --> 00:12:33,209
sort of the other sort of industrial

00:12:30,449 --> 00:12:35,310
languages courtland's with java 8 which

00:12:33,209 --> 00:12:37,620
are all quite a lot more complicated

00:12:35,310 --> 00:12:40,319
when here you have c++ and here you have

00:12:37,620 --> 00:12:42,660
c-sharp for me it was quite a surprise

00:12:40,319 --> 00:12:45,810
that c-sharp is so big it's even bigger

00:12:42,660 --> 00:12:48,360
than c++ if you do this measure even

00:12:45,810 --> 00:12:50,250
though I believe everybody will say C++

00:12:48,360 --> 00:12:52,829
is a lot easier to you harder to use

00:12:50,250 --> 00:12:56,790
than c-sharp so that means language size

00:12:52,829 --> 00:12:58,620
is not necessarily correlated with ease

00:12:56,790 --> 00:13:00,720
of use it could be could actually be

00:12:58,620 --> 00:13:02,100
inversely correlated and I think for

00:13:00,720 --> 00:13:04,560
Scala we just have to be clear that

00:13:02,100 --> 00:13:07,709
essentially the language is actually not

00:13:04,560 --> 00:13:10,079
outrageously large and furthermore we

00:13:07,709 --> 00:13:13,829
will try to make it even simpler than it

00:13:10,079 --> 00:13:15,660
is now but some of the patterns are hard

00:13:13,829 --> 00:13:17,819
to use they're puzzlers of surprising

00:13:15,660 --> 00:13:20,850
behaviour and again that's something

00:13:17,819 --> 00:13:24,510
that we want to address so the way

00:13:20,850 --> 00:13:26,670
forward so I believe and I think

00:13:24,510 --> 00:13:29,490
I should say we which is not the Royal

00:13:26,670 --> 00:13:32,460
we but I and a lot of other people that

00:13:29,490 --> 00:13:34,290
I work with believe that scholars fusion

00:13:32,460 --> 00:13:36,180
of functional and object and programming

00:13:34,290 --> 00:13:37,920
is still the most promising way forward

00:13:36,180 --> 00:13:42,120
for general-purpose software development

00:13:37,920 --> 00:13:44,430
but there's a bad I think but there are

00:13:42,120 --> 00:13:48,150
lots of things we have learned since the

00:13:44,430 --> 00:13:50,190
inception of Scala including that the

00:13:48,150 --> 00:13:52,440
following how to be pure without

00:13:50,190 --> 00:13:55,680
sacrificing simplicity and performance

00:13:52,440 --> 00:13:57,960
how to do meta programming safely how to

00:13:55,680 --> 00:13:59,730
cut down on boilerplate for new idioms

00:13:57,960 --> 00:14:02,780
and all these things they are sort of

00:13:59,730 --> 00:14:05,460
things that we discovered and developed

00:14:02,780 --> 00:14:07,770
once the first version that the current

00:14:05,460 --> 00:14:09,990
version of Scala already was out so

00:14:07,770 --> 00:14:12,420
because of all these discoveries I think

00:14:09,990 --> 00:14:14,640
it is the right time to actually try to

00:14:12,420 --> 00:14:16,320
consolidate these and put them into a

00:14:14,640 --> 00:14:20,310
new version of the language so that's

00:14:16,320 --> 00:14:25,560
the main reason why we think that Scala

00:14:20,310 --> 00:14:28,470
3 is a logical and and promising next

00:14:25,560 --> 00:14:30,060
step so what we want to do is we want to

00:14:28,470 --> 00:14:32,370
incorporate these techniques in the

00:14:30,060 --> 00:14:35,220
language to make it simpler more focused

00:14:32,370 --> 00:14:37,200
and more pleasant to use and in

00:14:35,220 --> 00:14:41,760
particular what we want to do is we want

00:14:37,200 --> 00:14:45,120
to become more opinionated so one aspect

00:14:41,760 --> 00:14:47,460
of SCARA that was quite attractive for

00:14:45,120 --> 00:14:49,650
many but quite a problem for others is

00:14:47,460 --> 00:14:51,330
that it's really not just a language

00:14:49,650 --> 00:14:53,130
it's a language toolbox you could

00:14:51,330 --> 00:14:55,200
achieve a lot of things with essentially

00:14:53,130 --> 00:14:57,330
macros and macro paradise you could

00:14:55,200 --> 00:14:58,530
really forge your own languages and the

00:14:57,330 --> 00:15:00,570
problem of course with that is

00:14:58,530 --> 00:15:02,520
fragmentation and that essentially you

00:15:00,570 --> 00:15:04,230
have a lot of different dialects and one

00:15:02,520 --> 00:15:05,820
dialect looks completely different to

00:15:04,230 --> 00:15:08,640
the next one and people can't talk to

00:15:05,820 --> 00:15:10,230
each other and they find essentially the

00:15:08,640 --> 00:15:11,850
things stunningly complicated because

00:15:10,230 --> 00:15:13,710
they don't just don't understand the

00:15:11,850 --> 00:15:15,360
particular dialect so we want to

00:15:13,710 --> 00:15:18,090
essentially reduce that and become more

00:15:15,360 --> 00:15:20,520
opinionated we want to simplify we want

00:15:18,090 --> 00:15:22,560
to eliminate inconsistencies and

00:15:20,520 --> 00:15:24,900
puzzlers in fact I have a close look at

00:15:22,560 --> 00:15:26,730
the puzzler book and say well it's entry

00:15:24,900 --> 00:15:28,410
how many of these can be eliminated in

00:15:26,730 --> 00:15:30,690
the next version of Scala would be great

00:15:28,410 --> 00:15:33,390
if we could eliminate a lot not that

00:15:30,690 --> 00:15:36,240
essentially a language can ever be

00:15:33,390 --> 00:15:37,710
puzzler 3 I think that's that's too much

00:15:36,240 --> 00:15:39,990
to wish for that's it

00:15:37,710 --> 00:15:44,070
not realistic but we definitely can

00:15:39,990 --> 00:15:46,880
reduce them we can build on strong

00:15:44,070 --> 00:15:49,620
foundations over the last year's

00:15:46,880 --> 00:15:51,630
essentially the we have many people have

00:15:49,620 --> 00:15:54,030
developed the foundations in particular

00:15:51,630 --> 00:15:55,770
the dot calculus for dependent object

00:15:54,030 --> 00:15:57,750
types which is an excellent guideline

00:15:55,770 --> 00:15:59,850
when it comes to essentially looking at

00:15:57,750 --> 00:16:01,560
the type soundness of the type system

00:15:59,850 --> 00:16:05,100
that essentially will be in scanner 3

00:16:01,560 --> 00:16:07,290
and we want to consolidate language

00:16:05,100 --> 00:16:09,810
constructs to improve the language

00:16:07,290 --> 00:16:12,330
according to four dimensions should be

00:16:09,810 --> 00:16:15,000
more consistent should be safer should

00:16:12,330 --> 00:16:17,790
we have better ergonomics and be more

00:16:15,000 --> 00:16:20,730
performant so I want to just give a

00:16:17,790 --> 00:16:23,040
quick rush through essentially the

00:16:20,730 --> 00:16:24,720
features just by mentioning them we

00:16:23,040 --> 00:16:27,030
won't have time it would be boring to

00:16:24,720 --> 00:16:28,830
actually go in each one in detail but to

00:16:27,030 --> 00:16:32,250
just say well what under these four

00:16:28,830 --> 00:16:35,180
points what kind of things do I mean

00:16:32,250 --> 00:16:38,130
so for consistency to improve the

00:16:35,180 --> 00:16:40,110
orthogonality and eliminate restrictions

00:16:38,130 --> 00:16:42,300
I would say definitely having

00:16:40,110 --> 00:16:46,520
intersection types instead of the width

00:16:42,300 --> 00:16:49,290
types in current Scala is a big

00:16:46,520 --> 00:16:52,020
advantage because these intersection

00:16:49,290 --> 00:16:54,210
types have nice algebraic properties in

00:16:52,020 --> 00:16:55,950
particular they commute so a and B is

00:16:54,210 --> 00:16:57,540
the same as B and I which you would

00:16:55,950 --> 00:16:59,490
expect from an intersection and which

00:16:57,540 --> 00:17:03,050
was actually was not true for the

00:16:59,490 --> 00:17:03,050
previous myth where we essentially

00:17:03,470 --> 00:17:08,880
joined the compound types with the

00:17:07,200 --> 00:17:11,730
linearization of essentially class

00:17:08,880 --> 00:17:12,750
inheritance which in the in retrospect

00:17:11,730 --> 00:17:14,850
was a bad idea

00:17:12,750 --> 00:17:16,920
once you have intersection types is

00:17:14,850 --> 00:17:18,990
logical you want to dual as well and so

00:17:16,920 --> 00:17:23,010
that's union types or Scala will have

00:17:18,990 --> 00:17:24,660
both intersections and unions then I put

00:17:23,010 --> 00:17:27,240
down implicit function types under

00:17:24,660 --> 00:17:30,480
consistency why would that be more

00:17:27,240 --> 00:17:32,550
consistent well a method can have

00:17:30,480 --> 00:17:34,500
implicit parameters right so everybody

00:17:32,550 --> 00:17:36,330
uses methods with implicit parameter so

00:17:34,500 --> 00:17:38,160
it's only logical that you say well once

00:17:36,330 --> 00:17:40,560
you lift a method to a function then

00:17:38,160 --> 00:17:42,270
that you don't lose the implicitness so

00:17:40,560 --> 00:17:44,250
you should have essentially function

00:17:42,270 --> 00:17:45,870
should also have be able to have

00:17:44,250 --> 00:17:48,600
implicit parameters and you should be

00:17:45,870 --> 00:17:50,340
able to talk about that in the type so

00:17:48,600 --> 00:17:51,270
this looks like just a little smoothing

00:17:50,340 --> 00:17:53,160
out but it

00:17:51,270 --> 00:17:56,610
we'll turn out that that's actually the

00:17:53,160 --> 00:17:58,560
key to a lot of the the progress that we

00:17:56,610 --> 00:18:01,620
can make in Scala 3 so this is sort of

00:17:58,560 --> 00:18:05,070
completely innocuous but with enormous

00:18:01,620 --> 00:18:06,900
consequences interestingly the next

00:18:05,070 --> 00:18:09,120
thing is dependent function types so

00:18:06,900 --> 00:18:11,160
it's the same thing methods can have

00:18:09,120 --> 00:18:13,050
results that depend on their parameter

00:18:11,160 --> 00:18:15,210
types we want to lift that into the

00:18:13,050 --> 00:18:17,460
function space and so that's also

00:18:15,210 --> 00:18:19,980
possible in Scala 3 I can have a

00:18:17,460 --> 00:18:23,310
function type like that takes an X of

00:18:19,980 --> 00:18:26,760
type a and that returns an x dot B where

00:18:23,310 --> 00:18:31,290
it B is for instance a type element of

00:18:26,760 --> 00:18:33,690
the type a here so that is essentially

00:18:31,290 --> 00:18:35,370
just this saying that we want to lift

00:18:33,690 --> 00:18:38,310
these things into functions and again

00:18:35,370 --> 00:18:39,600
that turns out that that's incredibly

00:18:38,310 --> 00:18:41,280
powerful because that's just the

00:18:39,600 --> 00:18:45,720
products of dependent types that you

00:18:41,280 --> 00:18:47,580
have that way trade parameters classes

00:18:45,720 --> 00:18:51,660
could have parameters why not try it's

00:18:47,580 --> 00:18:53,790
indeed why not turned out that you had

00:18:51,660 --> 00:18:55,320
to sort of figure out the rules what you

00:18:53,790 --> 00:18:57,900
do with time and inheritance

00:18:55,320 --> 00:18:59,730
so if essentially with the classes you

00:18:57,900 --> 00:19:02,310
have single inheritance so that it's

00:18:59,730 --> 00:19:03,900
easy but if you have two traits let's

00:19:02,310 --> 00:19:06,330
say a and B and they both inherit

00:19:03,900 --> 00:19:08,430
another tried C then the question is who

00:19:06,330 --> 00:19:10,560
passes the parameters to this a purse

00:19:08,430 --> 00:19:13,140
right a puppet right here so that was

00:19:10,560 --> 00:19:17,370
the question but once that figure out

00:19:13,140 --> 00:19:20,460
indeed the the there's no reason not to

00:19:17,370 --> 00:19:22,770
have tried parameters and they actually

00:19:20,460 --> 00:19:25,890
enable us to eliminate something which

00:19:22,770 --> 00:19:28,110
was pretty weird and ugly called early

00:19:25,890 --> 00:19:31,170
definitions which is was just another

00:19:28,110 --> 00:19:32,820
way to essentially achieve some of the

00:19:31,170 --> 00:19:36,540
functionalities that you had with tried

00:19:32,820 --> 00:19:39,090
parameters and finally generic tuples so

00:19:36,540 --> 00:19:41,220
but we have couples both double values

00:19:39,090 --> 00:19:44,580
and couple types of course in Scala but

00:19:41,220 --> 00:19:46,080
they went up to 22 and that was it right

00:19:44,580 --> 00:19:47,940
and there were each different type of

00:19:46,080 --> 00:19:49,770
one couple to couple three type or for

00:19:47,940 --> 00:19:51,480
each completely different types and

00:19:49,770 --> 00:19:53,160
that's of course why a lot of people

00:19:51,480 --> 00:19:55,770
said well tuples are no good we should

00:19:53,160 --> 00:19:57,960
have h lists because I'd lists we can do

00:19:55,770 --> 00:20:00,210
have actually programs that are generic

00:19:57,960 --> 00:20:03,060
in the length of this topple and that

00:20:00,210 --> 00:20:05,100
can essentially it's much much nicer to

00:20:03,060 --> 00:20:07,259
deal with and indeed that's true

00:20:05,100 --> 00:20:09,960
but then the question is once you have

00:20:07,259 --> 00:20:11,970
these ageless well why my keep tuples

00:20:09,960 --> 00:20:13,799
and why essentially have this

00:20:11,970 --> 00:20:16,860
specialized syntax for tuples if it's

00:20:13,799 --> 00:20:19,649
just such a poor concept so in SCADA

00:20:16,860 --> 00:20:22,649
three actually tuples are H lists so the

00:20:19,649 --> 00:20:24,929
tupple age ABC is essentially just a

00:20:22,649 --> 00:20:27,899
shorthand for writing well it's the age

00:20:24,929 --> 00:20:30,299
list that starts with a and has on the

00:20:27,899 --> 00:20:32,970
right-hand side the tupple alias ageless

00:20:30,299 --> 00:20:35,009
after that has a b and in the third

00:20:32,970 --> 00:20:38,220
element it's a C and the age middle

00:20:35,009 --> 00:20:41,129
would be the empty double and so that's

00:20:38,220 --> 00:20:42,809
essentially the type theoretic expansion

00:20:41,129 --> 00:20:44,490
of these things so everything you can do

00:20:42,809 --> 00:20:48,000
with age lists you will be able to do

00:20:44,490 --> 00:20:50,879
with tuples the add the other thing is

00:20:48,000 --> 00:20:52,769
in terms of representation I think we

00:20:50,879 --> 00:20:55,500
can do better we can essentially it's-

00:20:52,769 --> 00:20:57,929
and she have a compact representation of

00:20:55,500 --> 00:21:00,029
these tuples up to a certain size where

00:20:57,929 --> 00:21:04,259
we don't essentially have these pairs of

00:21:00,029 --> 00:21:07,620
pairs things that age lists imply so it

00:21:04,259 --> 00:21:12,360
was consistency what about ergonomics so

00:21:07,620 --> 00:21:16,320
what what's the reason for economics in

00:21:12,360 --> 00:21:18,600
fact one thing is that we want to reduce

00:21:16,320 --> 00:21:20,549
boilerplate well you say well I thought

00:21:18,600 --> 00:21:22,889
that was cool that's what Scala was all

00:21:20,549 --> 00:21:25,470
about right I mean Scala came and

00:21:22,889 --> 00:21:26,370
reduced a lot of boil operations in in

00:21:25,470 --> 00:21:29,580
Java programs

00:21:26,370 --> 00:21:31,590
case classes no getters no setters no

00:21:29,580 --> 00:21:34,950
equality methods everything was provided

00:21:31,590 --> 00:21:37,110
for you great but on the other hand over

00:21:34,950 --> 00:21:39,210
the years we have developed patterns in

00:21:37,110 --> 00:21:41,940
Scala programs that are actually quite

00:21:39,210 --> 00:21:43,860
boilerplate lis themselves so one to

00:21:41,940 --> 00:21:45,750
stay with case classes is we use case

00:21:43,860 --> 00:21:48,179
classes for data types left and right

00:21:45,750 --> 00:21:52,049
everywhere and yeah it's it's a lot more

00:21:48,179 --> 00:21:55,649
clunky than if you had an enum not an

00:21:52,049 --> 00:21:57,600
ADT type and furthermore even for enums

00:21:55,649 --> 00:22:00,090
where we never had something like that

00:21:57,600 --> 00:22:02,279
directly but now we have it so we can

00:22:00,090 --> 00:22:04,409
write enum color case red green blue and

00:22:02,279 --> 00:22:06,690
that actually generalizes to things like

00:22:04,409 --> 00:22:09,419
lists and options and general case

00:22:06,690 --> 00:22:13,139
classes you can use the same syntax for

00:22:09,419 --> 00:22:15,000
case classes with parameters as well the

00:22:13,139 --> 00:22:17,879
next thing was type lambda so we never

00:22:15,000 --> 00:22:18,759
had type lambdas until somebody figured

00:22:17,879 --> 00:22:21,909
out yeah you

00:22:18,759 --> 00:22:23,949
do it with some horrible contraption

00:22:21,909 --> 00:22:26,229
using structural types and type members

00:22:23,949 --> 00:22:29,379
and things like that right so this was

00:22:26,229 --> 00:22:32,320
so terrible that more sensible people

00:22:29,379 --> 00:22:34,419
immediately went and had a fancy macro

00:22:32,320 --> 00:22:35,859
system for kind projectors because it

00:22:34,419 --> 00:22:38,529
said well we can't we just can't write

00:22:35,859 --> 00:22:40,239
that but of course it's for those who

00:22:38,529 --> 00:22:42,369
have to right that it's super

00:22:40,239 --> 00:22:43,599
boilerplate and again it's something

00:22:42,369 --> 00:22:45,639
where we said well that's something that

00:22:43,599 --> 00:22:47,649
he said she came up when we started

00:22:45,639 --> 00:22:49,149
Scala we didn't even have higher kind of

00:22:47,649 --> 00:22:51,159
types when we had higher kind of types

00:22:49,149 --> 00:22:53,199
they weren't used that much people use

00:22:51,159 --> 00:22:56,169
them more and more and that was really

00:22:53,199 --> 00:22:57,639
essentially a soul sump so now it's kind

00:22:56,169 --> 00:22:59,440
of three will have type lambdas so

00:22:57,639 --> 00:23:01,179
that's the syntax so that's a type

00:22:59,440 --> 00:23:02,919
parameter you can have several of them

00:23:01,179 --> 00:23:04,749
they can have variances or bounds and

00:23:02,919 --> 00:23:07,209
that's here is the right hand side which

00:23:04,749 --> 00:23:12,839
can be an arbitrary a type that mentions

00:23:07,209 --> 00:23:17,019
the type variables okay and the next

00:23:12,839 --> 00:23:19,539
aspect would be safety so Scala

00:23:17,019 --> 00:23:22,089
generally is a fairly safe language but

00:23:19,539 --> 00:23:26,979
there are some things where it could do

00:23:22,089 --> 00:23:28,929
better so who among you has done a large

00:23:26,979 --> 00:23:31,679
refactoring of a scholar program where

00:23:28,929 --> 00:23:38,440
maybe you changed one type to another

00:23:31,679 --> 00:23:41,229
okay how easy was that good well for me

00:23:38,440 --> 00:23:44,049
there was one one sure thing

00:23:41,229 --> 00:23:46,119
normally I what I want is I just changed

00:23:44,049 --> 00:23:47,709
the types and the compiler gives me the

00:23:46,119 --> 00:23:51,219
type errors I fix the type errors I'm

00:23:47,709 --> 00:23:52,869
done except for equality so equality is

00:23:51,219 --> 00:23:55,959
really the bad thing there because I

00:23:52,869 --> 00:23:58,119
said well something I compare two types

00:23:55,959 --> 00:24:01,419
that make sense and now I change one to

00:23:58,119 --> 00:24:04,749
another type and it just will always

00:24:01,419 --> 00:24:07,929
give me false but at runtime so that's

00:24:04,749 --> 00:24:10,269
essentially the one thing where which is

00:24:07,929 --> 00:24:13,299
scary with large-scale refactorings and

00:24:10,269 --> 00:24:15,339
actually there was at least once in our

00:24:13,299 --> 00:24:17,169
compiler we didn't do a refactorings

00:24:15,339 --> 00:24:19,359
because we were scared of that we said

00:24:17,169 --> 00:24:21,909
we said we just don't can't track all

00:24:19,359 --> 00:24:24,009
the points where we compare this tightly

00:24:21,909 --> 00:24:26,469
the first type with the second type so

00:24:24,009 --> 00:24:28,450
now we have with multiversal equality

00:24:26,469 --> 00:24:30,470
which is essentially a nifty way to have

00:24:28,450 --> 00:24:32,390
essentially subpar

00:24:30,470 --> 00:24:34,220
of things that can be compared to each

00:24:32,390 --> 00:24:36,320
other but that can't be compared to

00:24:34,220 --> 00:24:38,390
things outside of their group

00:24:36,320 --> 00:24:40,280
so essentially you can define groups of

00:24:38,390 --> 00:24:42,320
types that can be compared to each other

00:24:40,280 --> 00:24:45,169
but not to other types and you do that

00:24:42,320 --> 00:24:48,110
by essentially setting up implicit and

00:24:45,169 --> 00:24:49,880
enums of course with the IDT's every

00:24:48,110 --> 00:24:52,070
enum is its own island so you can

00:24:49,880 --> 00:24:54,260
compare an enum only to itself but not

00:24:52,070 --> 00:24:56,480
to other types so that prevents you from

00:24:54,260 --> 00:24:59,179
essentially accidentally comparing a

00:24:56,480 --> 00:25:01,130
list of strings with a string so that

00:24:59,179 --> 00:25:03,799
wouldn't make sense anymore it would say

00:25:01,130 --> 00:25:07,730
well you can't do that it's not it's not

00:25:03,799 --> 00:25:09,650
a legal comparison the next thing

00:25:07,730 --> 00:25:11,559
restrict implicit conversions I'm going

00:25:09,650 --> 00:25:14,570
to talk about that a little bit more

00:25:11,559 --> 00:25:17,090
what we planned what we don't have in

00:25:14,570 --> 00:25:19,070
current in the current version Goti

00:25:17,090 --> 00:25:21,950
that's the essentially the project name

00:25:19,070 --> 00:25:25,190
for Scala 3 but we will hopefully add it

00:25:21,950 --> 00:25:26,900
is now safety because it seems that's

00:25:25,190 --> 00:25:29,360
where the world is moving and it's true

00:25:26,900 --> 00:25:31,549
that you a scarlet program doesn't use

00:25:29,360 --> 00:25:33,919
know a lot but scalar programs don't

00:25:31,549 --> 00:25:36,470
live in a vacuum they sense you have to

00:25:33,919 --> 00:25:40,130
interoperate with Java programs that can

00:25:36,470 --> 00:25:43,429
still pass a lot of narrow pointers and

00:25:40,130 --> 00:25:45,799
I think that we should be able to attain

00:25:43,429 --> 00:25:47,480
that by putting it in the type and we

00:25:45,799 --> 00:25:50,870
actually have a very good way to do that

00:25:47,480 --> 00:25:53,120
now because a essentially a malleable

00:25:50,870 --> 00:25:56,419
string is just a union type of the

00:25:53,120 --> 00:25:58,490
string type and not so in scalar 3 if

00:25:56,419 --> 00:26:00,650
you have a class type like string or

00:25:58,490 --> 00:26:01,100
list or whatever it never includes

00:26:00,650 --> 00:26:03,080
Nullah

00:26:01,100 --> 00:26:05,419
so it's it's always metal free it's

00:26:03,080 --> 00:26:08,480
always pure so if you want to add now

00:26:05,419 --> 00:26:11,240
you have to write or now and that's

00:26:08,480 --> 00:26:15,020
essentially for for the interface with

00:26:11,240 --> 00:26:16,610
Java what you do is that you say that if

00:26:15,020 --> 00:26:19,190
essentially you have a type and it

00:26:16,610 --> 00:26:22,820
doesn't have a not null annotation then

00:26:19,190 --> 00:26:25,400
the essentially the the the import of

00:26:22,820 --> 00:26:28,340
the type implicitly adds the or now

00:26:25,400 --> 00:26:31,850
in order to stay honest and add that to

00:26:28,340 --> 00:26:34,100
the Java type and finally effect

00:26:31,850 --> 00:26:36,470
capabilities is something that is a

00:26:34,100 --> 00:26:38,870
little bit further out and has to be do

00:26:36,470 --> 00:26:42,800
with essentially again implicit function

00:26:38,870 --> 00:26:48,300
types and the way to handle purity

00:26:42,800 --> 00:26:52,010
performance so there are some parts in

00:26:48,300 --> 00:26:54,240
Scala where we could do better in making

00:26:52,010 --> 00:26:56,070
abstractions cheaper so scholars

00:26:54,240 --> 00:26:59,820
generally language which encourage these

00:26:56,070 --> 00:27:02,400
abstractions and it would be nice if

00:26:59,820 --> 00:27:04,170
abstraction we didn't have a pay to pay

00:27:02,400 --> 00:27:09,210
a price for abstraction but sometimes

00:27:04,170 --> 00:27:11,760
you do so the first thing is you want to

00:27:09,210 --> 00:27:14,850
introduce the century and opaque type so

00:27:11,760 --> 00:27:16,980
essentially a type that is implemented

00:27:14,850 --> 00:27:19,200
as some other type but you don't know

00:27:16,980 --> 00:27:20,760
what it is so previously we had value

00:27:19,200 --> 00:27:23,010
classes for that so you could say you

00:27:20,760 --> 00:27:25,110
could define a new class like meter and

00:27:23,010 --> 00:27:26,840
it takes a double but a meter is not a

00:27:25,110 --> 00:27:29,550
double so there are two different things

00:27:26,840 --> 00:27:33,480
the problem with that is that value

00:27:29,550 --> 00:27:35,850
classes don't guarantee no boxing they

00:27:33,480 --> 00:27:39,000
guarantee that no boxing as long as

00:27:35,850 --> 00:27:40,860
essentially you see them monomorphic lee

00:27:39,000 --> 00:27:42,870
you have the type of the value class but

00:27:40,860 --> 00:27:45,840
that stops once you put them in a

00:27:42,870 --> 00:27:48,179
collection or worse even once you put

00:27:45,840 --> 00:27:49,800
them into an array so arrays over of

00:27:48,179 --> 00:27:51,990
essentially value classes can be very

00:27:49,800 --> 00:27:53,670
inefficient because every time you put

00:27:51,990 --> 00:27:55,170
it in the array you have to box and

00:27:53,670 --> 00:27:57,510
every time you put it out of the array

00:27:55,170 --> 00:27:59,490
you have to unbox so opaque types don't

00:27:57,510 --> 00:28:02,850
have that disadvantage and opaque type

00:27:59,490 --> 00:28:05,280
just says well a equals B so that's my

00:28:02,850 --> 00:28:06,870
implementation but you as a programmer

00:28:05,280 --> 00:28:08,100
are not allowed to know that

00:28:06,870 --> 00:28:10,580
so essentially type checker will

00:28:08,100 --> 00:28:13,080
complain if you use a B as an a and

00:28:10,580 --> 00:28:15,179
essentially that's in the companion

00:28:13,080 --> 00:28:17,730
object of a that's the only space where

00:28:15,179 --> 00:28:20,240
you actually can know that a equals B

00:28:17,730 --> 00:28:23,429
and value then can define the prop

00:28:20,240 --> 00:28:26,850
appropriate conversions and operations

00:28:23,429 --> 00:28:29,040
on these types so that hopefully will is

00:28:26,850 --> 00:28:31,170
essentially the same very close to what

00:28:29,040 --> 00:28:34,830
value classes are but without the boxing

00:28:31,170 --> 00:28:37,559
penalty with guaranteed non boxing the

00:28:34,830 --> 00:28:39,570
other thing that we have is erased

00:28:37,559 --> 00:28:42,660
parameters which is again something

00:28:39,570 --> 00:28:45,120
fairly very simple and obvious so in

00:28:42,660 --> 00:28:46,830
scala you have quite a lot of things

00:28:45,120 --> 00:28:52,650
typically implicit so I should have

00:28:46,830 --> 00:28:54,480
written implicit here that you pass a

00:28:52,650 --> 00:28:55,710
parameter and you really need that

00:28:54,480 --> 00:28:58,350
implicit parameter or

00:28:55,710 --> 00:29:01,020
for the types so for instance sometimes

00:28:58,350 --> 00:29:03,240
you want to call a method only if some

00:29:01,020 --> 00:29:05,370
type expression a is equal to a type

00:29:03,240 --> 00:29:08,429
expression B and we do that with an

00:29:05,370 --> 00:29:10,380
implicit so equals colon equals and you

00:29:08,429 --> 00:29:13,110
can just essentially pass that the

00:29:10,380 --> 00:29:15,870
evidence but afterwards at runtime you

00:29:13,110 --> 00:29:17,460
might not need it anymore so you can

00:29:15,870 --> 00:29:19,350
maybe arrange things that you don't need

00:29:17,460 --> 00:29:21,630
it anymore so if you don't need it

00:29:19,350 --> 00:29:24,029
anymore then you can put arrays on the

00:29:21,630 --> 00:29:26,279
parameter and that just means okay

00:29:24,029 --> 00:29:28,590
don't bother with generating code for

00:29:26,279 --> 00:29:30,570
this so essentially this is just to make

00:29:28,590 --> 00:29:32,190
the type inference are happy and the

00:29:30,570 --> 00:29:34,559
type checker happy afterwards you can

00:29:32,190 --> 00:29:37,919
drop it and we in fact we drop it very

00:29:34,559 --> 00:29:41,250
very quickly so immediately even during

00:29:37,919 --> 00:29:43,710
type tracking so we might have need to

00:29:41,250 --> 00:29:45,630
generate a very very large term as

00:29:43,710 --> 00:29:48,090
evidence sometimes these evidences are

00:29:45,630 --> 00:29:49,860
complicated but essentially once we have

00:29:48,090 --> 00:29:51,029
done that we throw it immediately away

00:29:49,860 --> 00:29:53,130
and essentially just gives you

00:29:51,029 --> 00:29:55,740
essentially the evidence of that so that

00:29:53,130 --> 00:29:58,080
hopefully will not not only save run

00:29:55,740 --> 00:30:00,360
time but also cut down on compile times

00:29:58,080 --> 00:30:03,750
for these sometimes very hairy type

00:30:00,360 --> 00:30:05,669
level parameters okay so that's

00:30:03,750 --> 00:30:10,350
essentially a quick tour of whirlwind

00:30:05,669 --> 00:30:12,120
tour through the features that we add we

00:30:10,350 --> 00:30:16,710
also remove quite a lot so here's all

00:30:12,120 --> 00:30:19,799
the things that we removed oh I shot

00:30:16,710 --> 00:30:21,929
list it's some more there's no more

00:30:19,799 --> 00:30:25,460
existential types so use dependent types

00:30:21,929 --> 00:30:28,649
for that there's no procedure syntax use

00:30:25,460 --> 00:30:32,010
equals for that an hourly initializers

00:30:28,649 --> 00:30:34,500
use thread parameters xml literals in

00:30:32,010 --> 00:30:38,730
the language are gone and now in the

00:30:34,500 --> 00:30:42,179
library there's no limit 22 so that's a

00:30:38,730 --> 00:30:44,880
simplification everything can go up to

00:30:42,179 --> 00:30:48,059
any arbitrary arbitrary era T's for

00:30:44,880 --> 00:30:50,520
tuples you've seen we do that by mapping

00:30:48,059 --> 00:30:51,990
tuples to edge lists and for functions

00:30:50,520 --> 00:30:55,460
we do that by essentially having a

00:30:51,990 --> 00:30:57,929
function X Excel which essentially takes

00:30:55,460 --> 00:31:01,620
arbitrary number of arguments in an

00:30:57,929 --> 00:31:03,600
array there's no automatic unit

00:31:01,620 --> 00:31:05,909
insertion we will be a lot more picky

00:31:03,600 --> 00:31:08,250
about essentially when you insert that

00:31:05,909 --> 00:31:09,650
you cannot simply drop the unit when the

00:31:08,250 --> 00:31:12,530
function takes a unit

00:31:09,650 --> 00:31:14,750
than you're supposed to pass it there's

00:31:12,530 --> 00:31:17,510
no weak conformance which is and was

00:31:14,750 --> 00:31:21,410
something fairly esoteric and but it

00:31:17,510 --> 00:31:23,660
could trip you up we planned on removing

00:31:21,410 --> 00:31:26,240
both Auto toppling and multi-parameter

00:31:23,660 --> 00:31:28,880
in fixed operations which actually are

00:31:26,240 --> 00:31:30,710
related so that isn't you should make a

00:31:28,880 --> 00:31:36,050
lot of the conversion rules less

00:31:30,710 --> 00:31:38,420
surprising good but the biggest I if I

00:31:36,050 --> 00:31:42,230
should say among all this feature list

00:31:38,420 --> 00:31:43,850
if I should take out one of the parts

00:31:42,230 --> 00:31:45,670
that I think is the most important than

00:31:43,850 --> 00:31:49,220
it's really the improvements to implicit

00:31:45,670 --> 00:31:52,550
implicit actually turned out to be where

00:31:49,220 --> 00:31:55,670
Scala innovated most it wasn't so much

00:31:52,550 --> 00:31:58,490
there at its inception but it was during

00:31:55,670 --> 00:31:59,390
the development of Scala in one version

00:31:58,490 --> 00:32:01,809
after the other

00:31:59,390 --> 00:32:05,080
essentially implicit got a lot of

00:32:01,809 --> 00:32:07,880
refinements so first for type inference

00:32:05,080 --> 00:32:10,460
then for things like implicit classes

00:32:07,880 --> 00:32:12,440
things like context bounds all of these

00:32:10,460 --> 00:32:14,840
ways and she added over the years that

00:32:12,440 --> 00:32:17,270
Scala existed and I believe that

00:32:14,840 --> 00:32:19,250
implicit can be both a blessing and a

00:32:17,270 --> 00:32:25,510
curse and the goal for scalar three is

00:32:19,250 --> 00:32:29,540
fewer curses so simplify and avoid traps

00:32:25,510 --> 00:32:32,120
one part where we actually work out

00:32:29,540 --> 00:32:33,890
essentially the theory of these new

00:32:32,120 --> 00:32:37,130
implicit which is actually very

00:32:33,890 --> 00:32:39,590
pleasingly simple is the papers called

00:32:37,130 --> 00:32:43,880
simplicity and it appeared in January at

00:32:39,590 --> 00:32:46,580
popper this year so in a nutshell what

00:32:43,880 --> 00:32:48,740
we want to do with implicit is that

00:32:46,580 --> 00:32:51,770
where the first thing we want to do is

00:32:48,740 --> 00:32:53,929
that previously we had both implicit

00:32:51,770 --> 00:32:56,870
conversions and implicit parameters and

00:32:53,929 --> 00:32:59,600
if you look at code and often it was

00:32:56,870 --> 00:33:01,550
sort of an roughly comparable balance

00:32:59,600 --> 00:33:03,679
you had programs use quite a lot of

00:33:01,550 --> 00:33:05,510
implicit conversions and they use quite

00:33:03,679 --> 00:33:07,100
a lot of implicit parameters in fact

00:33:05,510 --> 00:33:10,100
it's a historical accident implicit

00:33:07,100 --> 00:33:12,350
conversions came actually first because

00:33:10,100 --> 00:33:17,360
they were essentially invented as a way

00:33:12,350 --> 00:33:19,460
that we could implement an interface by

00:33:17,360 --> 00:33:21,170
existing classes without touching these

00:33:19,460 --> 00:33:22,320
classes so there's this problem that you

00:33:21,170 --> 00:33:26,220
say well I have

00:33:22,320 --> 00:33:28,350
class and then somebody else invents a

00:33:26,220 --> 00:33:30,330
new interface like order 10 I said well

00:33:28,350 --> 00:33:34,320
this class is ordered so I want to make

00:33:30,330 --> 00:33:36,419
this class ordered but the of course I

00:33:34,320 --> 00:33:39,000
can't without touching the class and the

00:33:36,419 --> 00:33:40,590
inheriting ordered so that's why we had

00:33:39,000 --> 00:33:42,450
implicit conversions to solve this

00:33:40,590 --> 00:33:44,460
problem so nowadays we would say well

00:33:42,450 --> 00:33:47,190
that's stupid do it to a type class or

00:33:44,460 --> 00:33:49,380
that has you don't you don't do an

00:33:47,190 --> 00:33:51,960
interface but at the time it was less

00:33:49,380 --> 00:33:53,370
well-known in fact type classes came

00:33:51,960 --> 00:33:55,500
afterwards as sort of a natural

00:33:53,370 --> 00:33:57,990
generalization of implicit conversions

00:33:55,500 --> 00:34:00,360
to implicit parameters and then implicit

00:33:57,990 --> 00:34:02,279
parameters were invented to model type

00:34:00,360 --> 00:34:04,350
classes so that's what the history was

00:34:02,279 --> 00:34:06,779
so implicit conversions were in scalar

00:34:04,350 --> 00:34:08,460
since the beginning since about 2004 and

00:34:06,779 --> 00:34:11,429
implicit parameters came maybe 2 years

00:34:08,460 --> 00:34:13,679
later and so even to this day if

00:34:11,429 --> 00:34:16,290
somebody has writes an implicit

00:34:13,679 --> 00:34:18,000
conversion implicit tutorial often they

00:34:16,290 --> 00:34:20,129
will start with implicit conversions and

00:34:18,000 --> 00:34:22,200
say yeah you want to know about implicit

00:34:20,129 --> 00:34:25,079
Z is this conversion from here to there

00:34:22,200 --> 00:34:27,119
and it makes me cringe because now I see

00:34:25,079 --> 00:34:29,339
this is often usually it's a terrible

00:34:27,119 --> 00:34:32,490
idea to propose what these tutorials

00:34:29,339 --> 00:34:34,470
often often propose as a first step so

00:34:32,490 --> 00:34:36,000
what I want to achieve in the future is

00:34:34,470 --> 00:34:39,450
that implicit conversion is a lot

00:34:36,000 --> 00:34:41,730
smaller so there will be probably still

00:34:39,450 --> 00:34:43,349
be some users but we really want to

00:34:41,730 --> 00:34:47,250
discourage that and we really want to

00:34:43,349 --> 00:34:49,770
put ways that enable you to use way less

00:34:47,250 --> 00:34:52,109
implicit conversions than now and that

00:34:49,770 --> 00:34:55,770
by contrast implicit parameters will be

00:34:52,109 --> 00:34:58,859
a lot more important so how do we cut

00:34:55,770 --> 00:35:00,780
down on implicit conversions well the

00:34:58,859 --> 00:35:05,819
first is that a lot of the implicit

00:35:00,780 --> 00:35:07,319
conversion use cases we can come up with

00:35:05,819 --> 00:35:09,660
other abstractions that are actually

00:35:07,319 --> 00:35:12,690
more natural for that so what does does

00:35:09,660 --> 00:35:14,490
this class here at at the bottom do it's

00:35:12,690 --> 00:35:17,579
an implicit class circle ops takes a

00:35:14,490 --> 00:35:21,540
circle extends anywhere and does this

00:35:17,579 --> 00:35:23,520
thing here well that's just to set up an

00:35:21,540 --> 00:35:25,650
extension method right so you want to

00:35:23,520 --> 00:35:27,390
have a method circumference on circles

00:35:25,650 --> 00:35:30,030
you haven't defined it in your circle

00:35:27,390 --> 00:35:32,880
case class here so that's a way to do it

00:35:30,030 --> 00:35:34,589
but it's a very roundabout way this is

00:35:32,880 --> 00:35:35,550
boilerplate II right I mean we were

00:35:34,589 --> 00:35:38,910
against

00:35:35,550 --> 00:35:40,560
boilerplate but now there's a lot of

00:35:38,910 --> 00:35:42,360
point of light introduced here as well

00:35:40,560 --> 00:35:44,610
in particular since it's a pattern that

00:35:42,360 --> 00:35:46,860
I guess it's pretty common so you do

00:35:44,610 --> 00:35:50,280
this over and over and over again and

00:35:46,860 --> 00:35:53,190
it's heavy so what we want in the future

00:35:50,280 --> 00:35:54,720
is something that is much clearer in a

00:35:53,190 --> 00:35:57,510
sense that we say well we have an

00:35:54,720 --> 00:36:00,060
extension we call it circle ops and it's

00:35:57,510 --> 00:36:02,340
an extension for circle and then we just

00:36:00,060 --> 00:36:04,230
write their method as it is so this is

00:36:02,340 --> 00:36:06,600
implied that this is a circle so there

00:36:04,230 --> 00:36:08,370
if you mentioned radius then essentially

00:36:06,600 --> 00:36:10,110
that's the radius for the circle here

00:36:08,370 --> 00:36:12,030
and you can have is essentially all

00:36:10,110 --> 00:36:14,880
these extensions for extension methods

00:36:12,030 --> 00:36:17,430
and also for word rust cause try to

00:36:14,880 --> 00:36:19,110
implementations so this thing for me was

00:36:17,430 --> 00:36:21,420
inspired from rust that's where I saw it

00:36:19,110 --> 00:36:22,890
but I looked it up since and as I saw

00:36:21,420 --> 00:36:25,230
that swift actually is something very

00:36:22,890 --> 00:36:28,020
similar and it even use extension for it

00:36:25,230 --> 00:36:31,590
so it's not something that is unique to

00:36:28,020 --> 00:36:34,080
Scala but I think if the the in SCADA we

00:36:31,590 --> 00:36:36,540
can use that to actually cut down on

00:36:34,080 --> 00:36:38,940
implicit conversion use cases we can say

00:36:36,540 --> 00:36:43,200
in a lot of situations it's actually

00:36:38,940 --> 00:36:45,330
clearer to express it like that okay the

00:36:43,200 --> 00:36:47,250
next thing we want to do is we want to

00:36:45,330 --> 00:36:50,820
actually actively prevent you from

00:36:47,250 --> 00:36:53,160
writing implicit conversions and the way

00:36:50,820 --> 00:36:55,560
we do that is with language imports so

00:36:53,160 --> 00:36:57,330
previously if you wanted to write an

00:36:55,560 --> 00:36:59,420
implicit conversion you had to import

00:36:57,330 --> 00:37:03,570
language implicit conversions right

00:36:59,420 --> 00:37:05,100
unfortunately for me that's all too easy

00:37:03,570 --> 00:37:06,990
to do in particular if you're an

00:37:05,100 --> 00:37:08,910
intelligent user because IntelliJ will

00:37:06,990 --> 00:37:11,370
just do it for you which I think it's a

00:37:08,910 --> 00:37:13,320
terrible idea that's the point of

00:37:11,370 --> 00:37:16,560
requiring this like these language

00:37:13,320 --> 00:37:18,570
imports is to make you think and to it

00:37:16,560 --> 00:37:20,310
you cannot think if the ID he does it

00:37:18,570 --> 00:37:22,380
for you under the cover so you really

00:37:20,310 --> 00:37:25,800
should type this out and either it's an

00:37:22,380 --> 00:37:29,040
appeal to the folks at IntelliJ to

00:37:25,800 --> 00:37:31,680
actually exempt language imports for all

00:37:29,040 --> 00:37:33,810
from all this fancy auto importation

00:37:31,680 --> 00:37:37,770
magic they're not they're not done for

00:37:33,810 --> 00:37:41,060
that but anyway even so it was it was

00:37:37,770 --> 00:37:44,610
still wasn't enough because you had a

00:37:41,060 --> 00:37:46,650
bright library designer who's who comes

00:37:44,610 --> 00:37:48,770
away convinced that it's a great idea to

00:37:46,650 --> 00:37:51,140
have a conversion from strings to

00:37:48,770 --> 00:37:52,760
like this one here string to int and

00:37:51,140 --> 00:37:54,910
then he puts it in Cyprien once you

00:37:52,760 --> 00:37:57,890
import it in one way you have it as well

00:37:54,910 --> 00:38:01,310
without maybe even realizing it and

00:37:57,890 --> 00:38:02,869
that's of course is then the big mess

00:38:01,310 --> 00:38:04,940
starts you have these conversions and

00:38:02,869 --> 00:38:07,010
you don't know what they do

00:38:04,940 --> 00:38:09,050
so it's wrong to appeal to library

00:38:07,010 --> 00:38:10,850
designers to say don't write implicit

00:38:09,050 --> 00:38:13,369
conversions and if yes you have to put

00:38:10,850 --> 00:38:15,590
this Auto import in here or this this

00:38:13,369 --> 00:38:19,570
language import because it's just too

00:38:15,590 --> 00:38:22,040
easy to do so and maybe every I don't

00:38:19,570 --> 00:38:23,780
expect that people here in this audience

00:38:22,040 --> 00:38:26,990
will think that string to int is a good

00:38:23,780 --> 00:38:29,630
idea but there are lots of gray zones

00:38:26,990 --> 00:38:31,430
there lots of things that people think

00:38:29,630 --> 00:38:34,369
it's a good idea and in the end it's not

00:38:31,430 --> 00:38:36,830
and I must say I know that because I

00:38:34,369 --> 00:38:38,630
have gone through this cycle many many

00:38:36,830 --> 00:38:40,610
times I thought an implicit conversion

00:38:38,630 --> 00:38:42,440
was a great idea and in this case we can

00:38:40,610 --> 00:38:46,610
do it and then in the end I've come to

00:38:42,440 --> 00:38:50,840
regret it so we all have to collectively

00:38:46,610 --> 00:38:52,760
be protected but if what's even more not

00:38:50,840 --> 00:38:55,490
just the library designers even more so

00:38:52,760 --> 00:38:57,890
than users because the users of these

00:38:55,490 --> 00:39:01,040
libraries they will have the problem if

00:38:57,890 --> 00:39:02,690
the implicit conversions happen so what

00:39:01,040 --> 00:39:04,730
we will require in the future is not

00:39:02,690 --> 00:39:07,040
just at the point of definition but also

00:39:04,730 --> 00:39:08,810
at the point of use if there's an if you

00:39:07,040 --> 00:39:10,820
essentially if there's an implicit

00:39:08,810 --> 00:39:12,680
conversion that the compiler inserts

00:39:10,820 --> 00:39:15,320
here then you will need a language

00:39:12,680 --> 00:39:16,520
import and the good thing is if you

00:39:15,320 --> 00:39:18,410
don't try the language import the

00:39:16,520 --> 00:39:20,330
compiler will give you essentially an

00:39:18,410 --> 00:39:22,670
error and say no you can't do that so

00:39:20,330 --> 00:39:24,850
it's an excellent way to actually figure

00:39:22,670 --> 00:39:27,260
out where essentially these implicit

00:39:24,850 --> 00:39:29,390
conversions are happening just don't

00:39:27,260 --> 00:39:34,130
import language implicit conversions and

00:39:29,390 --> 00:39:36,859
the compiler will tell you okay so

00:39:34,130 --> 00:39:39,590
there's one exemption which is that it

00:39:36,859 --> 00:39:41,900
turned out that once we ran it that that

00:39:39,590 --> 00:39:44,359
if a conversion is actually defined

00:39:41,900 --> 00:39:47,420
together with its target type then

00:39:44,359 --> 00:39:49,670
that's typically a thing that is is easy

00:39:47,420 --> 00:39:52,550
to control and it's a good thing to do

00:39:49,670 --> 00:39:54,260
so these are exempted but we are for the

00:39:52,550 --> 00:39:58,250
others you have to essentially write the

00:39:54,260 --> 00:40:00,200
import okay so what about the other side

00:39:58,250 --> 00:40:02,720
of the coin making implicit parameters

00:40:00,200 --> 00:40:05,240
more useful so

00:40:02,720 --> 00:40:09,890
the a number of improvements in the

00:40:05,240 --> 00:40:12,020
works so the first one is so far in

00:40:09,890 --> 00:40:15,590
implicit parameters always had to come

00:40:12,020 --> 00:40:17,420
last in an inner function and that we

00:40:15,590 --> 00:40:19,160
will actually drop this restriction so

00:40:17,420 --> 00:40:21,860
they can come in any order and there can

00:40:19,160 --> 00:40:25,730
be several of them why is that important

00:40:21,860 --> 00:40:28,310
well it's important for instance if this

00:40:25,730 --> 00:40:30,320
type B here depends on the first

00:40:28,310 --> 00:40:32,720
variable X if you have a dependent typed

00:40:30,320 --> 00:40:35,300
and currently you're out of luck you

00:40:32,720 --> 00:40:36,680
have to use the infamous aux pattern or

00:40:35,300 --> 00:40:38,720
something like that to actually get

00:40:36,680 --> 00:40:41,540
there and it's again it's one of these

00:40:38,720 --> 00:40:43,970
hoops that I don't think that ideally

00:40:41,540 --> 00:40:45,350
you shouldn't have to jump through so we

00:40:43,970 --> 00:40:48,320
can get there by essentially having

00:40:45,350 --> 00:40:51,050
multiple implicit classes but wait you

00:40:48,320 --> 00:40:53,810
say that there's an issue now because if

00:40:51,050 --> 00:40:56,060
I have this pattern sorry up with the

00:40:53,810 --> 00:40:58,820
implicit first and then the thing here

00:40:56,060 --> 00:41:00,620
and then if I pass F a parameter how do

00:40:58,820 --> 00:41:02,270
I know it's the implicit parameter or

00:41:00,620 --> 00:41:05,570
the other because we said well if a

00:41:02,270 --> 00:41:07,760
parameter is given then it's if it's

00:41:05,570 --> 00:41:11,750
explicitly given and pass it if not and

00:41:07,760 --> 00:41:14,990
infer an implicit argument so again the

00:41:11,750 --> 00:41:17,300
the new requirement is that if you pass

00:41:14,990 --> 00:41:19,060
a parameter to an argument to an

00:41:17,300 --> 00:41:22,910
implicit parameter you have to use

00:41:19,060 --> 00:41:26,330
explicitly so explicitly is essentially

00:41:22,910 --> 00:41:28,040
a magic method that says well here's I

00:41:26,330 --> 00:41:30,560
want to essentially give you something

00:41:28,040 --> 00:41:32,900
explicitly for this implicit parameter

00:41:30,560 --> 00:41:34,250
and that essentially enables the other

00:41:32,900 --> 00:41:36,380
thing and I believe it's also much

00:41:34,250 --> 00:41:39,410
clearer because now you can actually

00:41:36,380 --> 00:41:41,600
actually know whether the argument is

00:41:39,410 --> 00:41:43,940
for your implicit parameter or it isn't

00:41:41,600 --> 00:41:45,770
you could get confused even before even

00:41:43,940 --> 00:41:48,410
with the implicit arguments always

00:41:45,770 --> 00:41:50,150
coming last because of apply so if you

00:41:48,410 --> 00:41:52,580
have a thing with an apply method then

00:41:50,150 --> 00:41:54,680
yeah you don't know whether you you

00:41:52,580 --> 00:41:56,330
first you insert you apply and then call

00:41:54,680 --> 00:41:59,900
it or whether it's the other way around

00:41:56,330 --> 00:42:03,850
and finally there's implicit function

00:41:59,900 --> 00:42:06,760
types which give you essentially the

00:42:03,850 --> 00:42:10,420
purity without sacrificing implicit

00:42:06,760 --> 00:42:13,310
simplicity and performance I'm

00:42:10,420 --> 00:42:15,670
unfortunately I won't have time here to

00:42:13,310 --> 00:42:17,680
actually show you that

00:42:15,670 --> 00:42:19,930
if you had a little bit more time then I

00:42:17,680 --> 00:42:22,599
would run you through a way to do that

00:42:19,930 --> 00:42:25,270
so I just put up the slide and say well

00:42:22,599 --> 00:42:28,000
there's a lot of things you can do in

00:42:25,270 --> 00:42:30,880
particular things like dependency

00:42:28,000 --> 00:42:33,069
injection things like effects where

00:42:30,880 --> 00:42:35,920
implicit function types are a great

00:42:33,069 --> 00:42:39,280
alternative to the in particular the

00:42:35,920 --> 00:42:42,460
existing approaches using monads or mono

00:42:39,280 --> 00:42:44,589
transformers tax because the

00:42:42,460 --> 00:42:46,390
fundamentally they compose so

00:42:44,589 --> 00:42:48,369
essentially if you have an implicit

00:42:46,390 --> 00:42:50,680
function type that takes X and then one

00:42:48,369 --> 00:42:52,690
that takes Y they can come in any order

00:42:50,680 --> 00:42:55,359
and you can take a subset and none of

00:42:52,690 --> 00:42:57,190
that requires any plumbing all of that

00:42:55,359 --> 00:42:59,619
is done completely transparently by the

00:42:57,190 --> 00:43:02,619
compiler so that's basically the that

00:42:59,619 --> 00:43:07,089
the reason why why implicit function

00:43:02,619 --> 00:43:09,309
types is so much nicer to use and monads

00:43:07,089 --> 00:43:12,430
and mono transformers for these kind of

00:43:09,309 --> 00:43:13,890
things again we're not the first to have

00:43:12,430 --> 00:43:18,369
discovered that there's a movement

00:43:13,890 --> 00:43:20,290
gaining steam I think called algebraic

00:43:18,369 --> 00:43:22,180
effects which is basically the same

00:43:20,290 --> 00:43:24,490
observation that if you say if you have

00:43:22,180 --> 00:43:26,200
effects and you want to have a system

00:43:24,490 --> 00:43:29,079
where your effect is composed naturally

00:43:26,200 --> 00:43:32,200
and implicit function types is I believe

00:43:29,079 --> 00:43:35,020
the the simplest way possible to express

00:43:32,200 --> 00:43:36,640
simple algebraic effects for more

00:43:35,020 --> 00:43:38,530
complicated algebraic effects you would

00:43:36,640 --> 00:43:42,970
need continuations which is a another

00:43:38,530 --> 00:43:45,099
another question okay so that was a

00:43:42,970 --> 00:43:47,440
quick run down to the language but the

00:43:45,099 --> 00:43:49,510
language in isolation is of course

00:43:47,440 --> 00:43:52,720
useless so you need tooling so what do

00:43:49,510 --> 00:43:53,589
we have so far with tooling well we have

00:43:52,720 --> 00:43:57,400
a new compiler

00:43:53,589 --> 00:43:59,619
it's called dot dot C so dot e is

00:43:57,400 --> 00:44:02,859
essentially the project name derived

00:43:59,619 --> 00:44:05,740
from dot the calculus and dot C is the

00:44:02,859 --> 00:44:08,530
compiler for it we have actually pretty

00:44:05,740 --> 00:44:11,589
good IDE support already through the

00:44:08,530 --> 00:44:14,380
language server protocol and it's

00:44:11,589 --> 00:44:16,750
supported directly for pi vs code but

00:44:14,380 --> 00:44:19,540
hopefully in the future by other clients

00:44:16,750 --> 00:44:22,829
as well we have a rapper and a doctor

00:44:19,540 --> 00:44:25,780
and most of the tooling is built around

00:44:22,829 --> 00:44:27,910
tasty so today I want to talk a little

00:44:25,780 --> 00:44:29,560
bit about around tasty because it's also

00:44:27,910 --> 00:44:33,760
important for the interrupt

00:44:29,560 --> 00:44:36,040
so tasty stands for typed abstract

00:44:33,760 --> 00:44:38,470
syntax trees on abstract syntax trees

00:44:36,040 --> 00:44:40,510
essentially the internal version that a

00:44:38,470 --> 00:44:43,480
compiler uses to understand the program

00:44:40,510 --> 00:44:45,000
and after the type checker they're all

00:44:43,480 --> 00:44:47,710
typed and essentially that's what

00:44:45,000 --> 00:44:50,860
typically the compiler like wants to see

00:44:47,710 --> 00:44:54,850
and how it conceptualizes what's in a

00:44:50,860 --> 00:44:58,030
program and we use tasty for a lot of

00:44:54,850 --> 00:45:00,760
different things so for us these typed

00:44:58,030 --> 00:45:03,970
abstract syntax trees are these standard

00:45:00,760 --> 00:45:06,700
serialization format for scanner so it's

00:45:03,970 --> 00:45:08,740
how we represent essentially the what's

00:45:06,700 --> 00:45:11,770
in a Scala file so that when we do

00:45:08,740 --> 00:45:13,870
separate compilation one more one the

00:45:11,770 --> 00:45:18,400
compiler understands what's in other

00:45:13,870 --> 00:45:20,680
modules and also in the future how we

00:45:18,400 --> 00:45:22,870
can generate code from Scala complete

00:45:20,680 --> 00:45:24,850
code it has the complete type

00:45:22,870 --> 00:45:28,090
information including all implicit s--

00:45:24,850 --> 00:45:30,700
are made explicit in that format and it

00:45:28,090 --> 00:45:32,560
also has the complete position

00:45:30,700 --> 00:45:35,950
information so that means we can use

00:45:32,560 --> 00:45:38,020
that very nicely also in an IDE and an

00:45:35,950 --> 00:45:39,520
editor because it really literally tells

00:45:38,020 --> 00:45:41,350
you and everything you need to know

00:45:39,520 --> 00:45:43,780
about the program without any

00:45:41,350 --> 00:45:45,940
information loss and at the same time

00:45:43,780 --> 00:45:47,650
it's actually surprisingly compact so we

00:45:45,940 --> 00:45:49,660
worked really hard to make this compact

00:45:47,650 --> 00:45:51,970
so that it basically the the whole

00:45:49,660 --> 00:45:53,680
optimization exercises how compact can

00:45:51,970 --> 00:45:55,870
you make this so in the end it's about

00:45:53,680 --> 00:45:57,940
the same size as source which means it's

00:45:55,870 --> 00:45:59,920
actually cheap enough to generate this

00:45:57,940 --> 00:46:02,230
as essentially the standard pickle

00:45:59,920 --> 00:46:03,880
information that we have for scholar

00:46:02,230 --> 00:46:06,730
programs so in fact that's the only

00:46:03,880 --> 00:46:10,780
thing that we generate when we when we

00:46:06,730 --> 00:46:14,110
will do pickle information between Scala

00:46:10,780 --> 00:46:15,430
modules so the vision of pasty done is

00:46:14,110 --> 00:46:18,760
that you have essentially a single

00:46:15,430 --> 00:46:21,610
format which is used for a lot of

00:46:18,760 --> 00:46:24,220
different ways so the first one is it's

00:46:21,610 --> 00:46:26,650
used as as I said as to support separate

00:46:24,220 --> 00:46:28,960
compilation of Scala three programs and

00:46:26,650 --> 00:46:30,730
now dottie programs so essentially Scala

00:46:28,960 --> 00:46:33,280
3 when you compile the scarlet scarlet

00:46:30,730 --> 00:46:34,780
reprogram it generates tasty and when

00:46:33,280 --> 00:46:36,910
you want to know what's in a different

00:46:34,780 --> 00:46:38,890
library file or something like that and

00:46:36,910 --> 00:46:42,309
you consulted tasty and find out what

00:46:38,890 --> 00:46:45,999
members it has Edward types and so on

00:46:42,309 --> 00:46:48,279
what we have as a proof of concept do

00:46:45,999 --> 00:46:50,140
your mattress turd that is that you can

00:46:48,279 --> 00:46:54,759
actually also do that as quite

00:46:50,140 --> 00:46:57,039
reasonable overhead and work to map

00:46:54,759 --> 00:46:59,859
current scholar into the same format and

00:46:57,039 --> 00:47:01,569
we don't have that yet but we plan to

00:46:59,859 --> 00:47:03,459
essentially be half the round-trip as

00:47:01,569 --> 00:47:06,400
well so that we can essentially take

00:47:03,459 --> 00:47:10,089
tasty and understand tasty from the

00:47:06,400 --> 00:47:11,709
currents got a to compiler so that that

00:47:10,089 --> 00:47:14,019
that's important because once that's

00:47:11,709 --> 00:47:16,509
done these two parts can talk to each

00:47:14,019 --> 00:47:18,880
other so right now essentially SCADA

00:47:16,509 --> 00:47:20,949
three can understand scatter two because

00:47:18,880 --> 00:47:23,349
it has another mode where it understands

00:47:20,949 --> 00:47:24,309
this color to pickling format but it

00:47:23,349 --> 00:47:25,989
doesn't work the other way around

00:47:24,309 --> 00:47:28,869
because color to doesn't understand

00:47:25,989 --> 00:47:31,029
tasty but once it does understand tasty

00:47:28,869 --> 00:47:34,059
it can actually figure out what's in a

00:47:31,029 --> 00:47:36,759
SCADA three file we use it for the IDE

00:47:34,059 --> 00:47:38,410
with LSP so if you want to do find

00:47:36,759 --> 00:47:40,329
references or something in a program

00:47:38,410 --> 00:47:42,939
then essentially you look in the trees

00:47:40,329 --> 00:47:45,459
that or at least you look at in those

00:47:42,939 --> 00:47:47,199
trees that actually mention the name and

00:47:45,459 --> 00:47:49,719
that lets you find all the referee

00:47:47,199 --> 00:47:53,249
references at actually felt very very

00:47:49,719 --> 00:47:57,489
good speed and we use it to generate

00:47:53,249 --> 00:47:59,349
well we we can use it to generate class

00:47:57,489 --> 00:48:02,859
files so that's currently essentially

00:47:59,349 --> 00:48:05,410
and a just for testing purposes we don't

00:48:02,859 --> 00:48:07,539
have the tooling setup to do this but it

00:48:05,410 --> 00:48:09,309
works in the test suite that we say we

00:48:07,539 --> 00:48:11,349
take these tasty trees and we generate

00:48:09,309 --> 00:48:12,249
Java class files and why is that

00:48:11,349 --> 00:48:14,979
important

00:48:12,249 --> 00:48:17,559
well it's important because it we are no

00:48:14,979 --> 00:48:19,839
longer than tied to generate only one

00:48:17,559 --> 00:48:22,359
kind of class files once we have a tasty

00:48:19,839 --> 00:48:24,819
classify generator we can take generate

00:48:22,359 --> 00:48:26,890
Java eight class files or Java eleven

00:48:24,819 --> 00:48:29,140
class files it doesn't matter our 14

00:48:26,890 --> 00:48:31,390
class files or whatever and you can

00:48:29,140 --> 00:48:33,099
generate JavaScript files and we can

00:48:31,390 --> 00:48:35,890
generate native files so this is a great

00:48:33,099 --> 00:48:40,719
way to actually get cross building to

00:48:35,890 --> 00:48:42,880
work caveat of course sometimes you need

00:48:40,719 --> 00:48:44,920
to have essentially sources that are

00:48:42,880 --> 00:48:46,569
platform dependent may be different

00:48:44,920 --> 00:48:48,459
types different implicit and things like

00:48:46,569 --> 00:48:50,109
that and then of course we can't do

00:48:48,459 --> 00:48:52,479
magic and the single tasty thing will

00:48:50,109 --> 00:48:54,610
not do that but in many other cases

00:48:52,479 --> 00:48:56,470
where this is not the case

00:48:54,610 --> 00:48:58,750
we should be able to do that very well

00:48:56,470 --> 00:49:00,610
and finally this tasty thing because

00:48:58,750 --> 00:49:02,380
it's essentially standardized it's

00:49:00,610 --> 00:49:05,770
essentially the new platform it's

00:49:02,380 --> 00:49:08,050
terrorization serialization format it's

00:49:05,770 --> 00:49:10,840
also a great way to essentially put

00:49:08,050 --> 00:49:12,910
additional tooling on that like macros

00:49:10,840 --> 00:49:15,610
macros can essentially take trees as

00:49:12,910 --> 00:49:19,200
defined by tasty produce at the trees or

00:49:15,610 --> 00:49:21,760
analyzes or optimizes or other things

00:49:19,200 --> 00:49:24,190
okay so the lots of use cases for this

00:49:21,760 --> 00:49:28,240
tasty thing separate compilation IDs

00:49:24,190 --> 00:49:31,030
macros cross building and that brings me

00:49:28,240 --> 00:49:35,020
to the final point of this talk which is

00:49:31,030 --> 00:49:37,510
meta programming so when I talked about

00:49:35,020 --> 00:49:39,610
essentially all the new features then

00:49:37,510 --> 00:49:42,280
there's one sticky point to say well

00:49:39,610 --> 00:49:44,920
yeah what happens with macros that's I

00:49:42,280 --> 00:49:51,520
guess on a lot of people's mind because

00:49:44,920 --> 00:49:53,440
macros so far are very much tied to the

00:49:51,520 --> 00:49:57,220
current Scala compiler which will go

00:49:53,440 --> 00:49:59,020
away NSC so def macros it's just a thin

00:49:57,220 --> 00:50:00,730
veneer around and it's C and macro

00:49:59,020 --> 00:50:03,640
paradise it's basically the same thing

00:50:00,730 --> 00:50:06,070
so they're basically they go into NSC

00:50:03,640 --> 00:50:08,440
for into the current Scala compiler for

00:50:06,070 --> 00:50:10,900
everything they do and that wouldn't be

00:50:08,440 --> 00:50:12,820
a problem by itself but they also expose

00:50:10,900 --> 00:50:15,190
a lot of the internals of the current

00:50:12,820 --> 00:50:16,720
Scala compiler owner chains and

00:50:15,190 --> 00:50:20,290
differences between typed and untyped

00:50:16,720 --> 00:50:22,450
trees it gets rather rather tricky and

00:50:20,290 --> 00:50:24,310
hairy and confusing a lot of the times

00:50:22,450 --> 00:50:26,410
and that's because it essentially just

00:50:24,310 --> 00:50:29,460
throws up open the implementation of the

00:50:26,410 --> 00:50:31,990
current color compiler there's a another

00:50:29,460 --> 00:50:33,670
macro system that doesn't Metis this

00:50:31,990 --> 00:50:35,170
meta programming system it doesn't have

00:50:33,670 --> 00:50:37,690
that problem which is called Scala meta

00:50:35,170 --> 00:50:40,240
but that has a slightly different use

00:50:37,690 --> 00:50:42,580
case so that's really external tools

00:50:40,240 --> 00:50:43,960
that analyze and transform programs so

00:50:42,580 --> 00:50:46,060
essentially you did they would have a

00:50:43,960 --> 00:50:48,580
thing which is essentially not inside

00:50:46,060 --> 00:50:50,110
your compiler but the thing that exists

00:50:48,580 --> 00:50:53,560
separately that essentially you can

00:50:50,110 --> 00:50:55,510
essentially query a lot of programs or

00:50:53,560 --> 00:50:57,280
populate the database or things like

00:50:55,510 --> 00:50:59,170
that so that's a different use case and

00:50:57,280 --> 00:51:01,720
one which will not go away so as

00:50:59,170 --> 00:51:03,340
kilometer is completely independent to

00:51:01,720 --> 00:51:07,660
what we want to do with meta programming

00:51:03,340 --> 00:51:08,500
in Scala 3 so what do we want to do so

00:51:07,660 --> 00:51:11,080
what we are

00:51:08,500 --> 00:51:13,630
trying to do is what I call principled

00:51:11,080 --> 00:51:16,570
metaprogramming where we say let's be

00:51:13,630 --> 00:51:19,000
very simple let's just have essentially

00:51:16,570 --> 00:51:23,110
two fundamental operators and then

00:51:19,000 --> 00:51:27,280
another two so the first operator is

00:51:23,110 --> 00:51:29,800
called quote and it essentially takes an

00:51:27,280 --> 00:51:32,770
arbitrary expression and it gives you

00:51:29,800 --> 00:51:36,250
the code for that expression so as a as

00:51:32,770 --> 00:51:38,890
a data structure and the dual of that is

00:51:36,250 --> 00:51:42,010
price it takes the code of the data

00:51:38,890 --> 00:51:44,470
structure and puts it inside another

00:51:42,010 --> 00:51:46,630
quote it splices it inside another quote

00:51:44,470 --> 00:51:49,870
and if you run this price in the top

00:51:46,630 --> 00:51:51,700
level that means that you run a macro so

00:51:49,870 --> 00:51:54,520
because it means well here's some code

00:51:51,700 --> 00:51:57,160
at the top level it means well run that

00:51:54,520 --> 00:52:02,020
code and produce essentially what the

00:51:57,160 --> 00:52:03,760
final result so to do that then that

00:52:02,020 --> 00:52:07,270
essentially the other two operators are

00:52:03,760 --> 00:52:09,130
inline and run so what inline does is as

00:52:07,270 --> 00:52:11,050
the name implies it just moves something

00:52:09,130 --> 00:52:14,410
from the definition side to the use side

00:52:11,050 --> 00:52:17,170
so macro expansion would then be moved

00:52:14,410 --> 00:52:19,240
the macro to where it's used and then

00:52:17,170 --> 00:52:21,670
run it and that will expand it so that's

00:52:19,240 --> 00:52:25,630
essentially two steps price and inline

00:52:21,670 --> 00:52:28,660
is the macro expansion if you combine

00:52:25,630 --> 00:52:30,880
those two with run then you get staging

00:52:28,660 --> 00:52:32,440
that means runtime code generation at

00:52:30,880 --> 00:52:35,500
runtime so that's essentially the two

00:52:32,440 --> 00:52:40,030
different parts of it okay so if we look

00:52:35,500 --> 00:52:42,970
at the the diagram here then we have

00:52:40,030 --> 00:52:45,370
normal code which has type T in string

00:52:42,970 --> 00:52:46,810
whatever and then these trays these

00:52:45,370 --> 00:52:48,790
these code parts they are called

00:52:46,810 --> 00:52:51,010
expression of T so that's essentially

00:52:48,790 --> 00:52:54,100
the code that essentially is the code

00:52:51,010 --> 00:52:57,640
that when you integrated in a program

00:52:54,100 --> 00:52:59,740
will eventually produce a T and as I

00:52:57,640 --> 00:53:01,630
said quote goes from T to expression of

00:52:59,740 --> 00:53:04,870
T and splice goes from expression of T

00:53:01,630 --> 00:53:06,400
to T and that is super principled and

00:53:04,870 --> 00:53:09,820
very nice and you can do lots of things

00:53:06,400 --> 00:53:12,520
but it's also super restrictive compared

00:53:09,820 --> 00:53:13,960
to what we currently have because one of

00:53:12,520 --> 00:53:16,840
the things you can't do is look inside

00:53:13,960 --> 00:53:18,820
one of your trees this expression it's a

00:53:16,840 --> 00:53:20,410
black box it's just a code of type T you

00:53:18,820 --> 00:53:24,760
can't look inside

00:53:20,410 --> 00:53:28,360
and so what we want to do is augment

00:53:24,760 --> 00:53:31,630
that by essentially having another part

00:53:28,360 --> 00:53:34,570
to it to this and say well these code

00:53:31,630 --> 00:53:36,820
expressions in the end what are they

00:53:34,570 --> 00:53:39,220
they're just typed abstract syntax trees

00:53:36,820 --> 00:53:41,050
that's what the compiler sees and then

00:53:39,220 --> 00:53:43,390
the question is well how do we expose

00:53:41,050 --> 00:53:45,280
them and in the end we just says well we

00:53:43,390 --> 00:53:47,200
have a perfectly good format and we have

00:53:45,280 --> 00:53:49,330
standardized that it's called tasty so

00:53:47,200 --> 00:53:51,550
let's expose it as tasty trees because

00:53:49,330 --> 00:53:53,290
that is not a compiler it's a

00:53:51,550 --> 00:53:55,150
serialization format it's something that

00:53:53,290 --> 00:53:57,790
we will actually have to keep stable

00:53:55,150 --> 00:53:59,500
over many many versions because it's the

00:53:57,790 --> 00:54:02,080
way that scarra programs will talk to

00:53:59,500 --> 00:54:05,320
each other so there will be essentially

00:54:02,080 --> 00:54:09,370
two other operations reflect and ratify

00:54:05,320 --> 00:54:11,650
that I call that map and black box code

00:54:09,370 --> 00:54:14,230
of type T to the underlying tasty tree

00:54:11,650 --> 00:54:17,470
and from the tasty tea tree to the

00:54:14,230 --> 00:54:19,420
expression tree okay so that essentially

00:54:17,470 --> 00:54:21,070
completes this tasty vision that we say

00:54:19,420 --> 00:54:23,170
well we have taste is sort of sitting in

00:54:21,070 --> 00:54:26,050
the middle and macros will be become

00:54:23,170 --> 00:54:30,100
very very powerful because they are just

00:54:26,050 --> 00:54:31,780
at the at the center of it all so they

00:54:30,100 --> 00:54:35,110
essentially they can take all this code

00:54:31,780 --> 00:54:37,510
and convert it and furthermore they can

00:54:35,110 --> 00:54:39,610
do so and even look at other compilation

00:54:37,510 --> 00:54:41,740
modules because at the tasty thing

00:54:39,610 --> 00:54:43,420
that's also the point where we see and

00:54:41,740 --> 00:54:46,390
she pull in modules from of different

00:54:43,420 --> 00:54:48,850
files together but there's one

00:54:46,390 --> 00:54:53,080
restriction and that's that in order to

00:54:48,850 --> 00:54:55,690
do that the you you're restricted to

00:54:53,080 --> 00:54:57,280
so-called blackbox macros so here I

00:54:55,690 --> 00:54:59,710
should say well the way this is done is

00:54:57,280 --> 00:55:01,990
so here on the left you have essentially

00:54:59,710 --> 00:55:05,290
the type checker checks your programs

00:55:01,990 --> 00:55:06,940
and then pretty immediately afterwards

00:55:05,290 --> 00:55:09,340
it essentially generates this tasty

00:55:06,940 --> 00:55:10,990
thing and from tasty you go with

00:55:09,340 --> 00:55:12,760
essentially all the transforms the

00:55:10,990 --> 00:55:16,900
middle end and from there you go into

00:55:12,760 --> 00:55:18,820
the back end so if macros work on tasty

00:55:16,900 --> 00:55:20,440
they must they get expanded after type

00:55:18,820 --> 00:55:22,840
checking and that means that programs

00:55:20,440 --> 00:55:25,600
must type check before macros are

00:55:22,840 --> 00:55:27,970
expanded so you can't have an incorrect

00:55:25,600 --> 00:55:32,770
program that sort of gets healed by

00:55:27,970 --> 00:55:34,450
macro expansion macros always work on

00:55:32,770 --> 00:55:37,079
type trees so this in

00:55:34,450 --> 00:55:39,490
possible it doesn't even enter the

00:55:37,079 --> 00:55:41,829
system that you would have an untyped

00:55:39,490 --> 00:55:43,810
tree and run a typer on that or things

00:55:41,829 --> 00:55:44,200
like that it just doesn't exist in this

00:55:43,810 --> 00:55:45,910
world

00:55:44,200 --> 00:55:47,980
it also means they're hygienic by

00:55:45,910 --> 00:55:50,349
definition and I believe it drastically

00:55:47,980 --> 00:55:52,630
reduces the number of things that can go

00:55:50,349 --> 00:55:54,490
wrong on the other hand there certain

00:55:52,630 --> 00:55:57,010
macros where you say well that is

00:55:54,490 --> 00:55:59,710
actually not enough my macros actually

00:55:57,010 --> 00:56:03,070
need more than that today they have to

00:55:59,710 --> 00:56:05,980
essentially expose the types and change

00:56:03,070 --> 00:56:08,230
the types and our answer to that is

00:56:05,980 --> 00:56:10,619
essentially language level solutions so

00:56:08,230 --> 00:56:13,599
if something is really important and

00:56:10,619 --> 00:56:15,280
affects the types then I believe that it

00:56:13,599 --> 00:56:16,570
is a good place to put that in the

00:56:15,280 --> 00:56:19,240
language and we have done that already

00:56:16,570 --> 00:56:22,510
with a number of things one was the lazy

00:56:19,240 --> 00:56:25,210
macros for implicit it's quite ingenious

00:56:22,510 --> 00:56:27,760
but also super fragile so that's

00:56:25,210 --> 00:56:30,940
actually now in the language type

00:56:27,760 --> 00:56:34,630
lambdas I've mentioned they essentially

00:56:30,940 --> 00:56:37,270
replace or make kind project or super to

00:56:34,630 --> 00:56:39,190
a large degree redundant context

00:56:37,270 --> 00:56:41,170
injections so macros that sort of just

00:56:39,190 --> 00:56:42,910
add and implicit two things implicit

00:56:41,170 --> 00:56:45,010
function types are a great alternative

00:56:42,910 --> 00:56:47,530
for that and we have still work to do

00:56:45,010 --> 00:56:50,440
and we count also on your feedback and

00:56:47,530 --> 00:56:52,869
your help with that one one thing I

00:56:50,440 --> 00:56:55,599
believe we absolutely must do is some

00:56:52,869 --> 00:56:57,730
way to do to do type class derivation so

00:56:55,599 --> 00:56:59,950
I think the time is right to actually

00:56:57,730 --> 00:57:03,310
add that and another thing I really also

00:56:59,950 --> 00:57:05,829
would love to do is type level functions

00:57:03,310 --> 00:57:08,290
so essentially computed functions that

00:57:05,829 --> 00:57:09,420
come do some computations to give you a

00:57:08,290 --> 00:57:15,760
type

00:57:09,420 --> 00:57:19,030
okay so migration you have thrown a lot

00:57:15,760 --> 00:57:20,560
of concepts and stuff at you and new new

00:57:19,030 --> 00:57:22,900
language features removed language

00:57:20,560 --> 00:57:26,589
features how are we ever going to

00:57:22,900 --> 00:57:33,069
migrate to this fata morgana the new

00:57:26,589 --> 00:57:35,680
world so just stay calm and because

00:57:33,069 --> 00:57:37,720
despite many differences I think Scala

00:57:35,680 --> 00:57:39,589
two and three are still fundamentally

00:57:37,720 --> 00:57:43,309
the same language

00:57:39,589 --> 00:57:45,079
and more specifically there's a very

00:57:43,309 --> 00:57:47,989
very large common subset which is

00:57:45,079 --> 00:57:49,880
perfectly workable where there are so

00:57:47,989 --> 00:57:52,609
actually source compatible so that means

00:57:49,880 --> 00:57:55,640
if you want to migrate and there's a

00:57:52,609 --> 00:57:57,319
will be a there's a large subset which

00:57:55,640 --> 00:57:59,569
actually we will have a mode in the

00:57:57,319 --> 00:58:02,210
compiler to figure out to tell you that

00:57:59,569 --> 00:58:03,890
you're in that subset where you say well

00:58:02,210 --> 00:58:05,779
this thing will compile on the scanner

00:58:03,890 --> 00:58:07,549
to and it will compile analyst Carra

00:58:05,779 --> 00:58:11,089
three and it will produce the same

00:58:07,549 --> 00:58:13,430
result so that's number one second we

00:58:11,089 --> 00:58:16,309
have actually rewrite tools so that they

00:58:13,430 --> 00:58:19,069
can handle much of the rest so the

00:58:16,309 --> 00:58:21,109
compiler has has a rewrite mode where it

00:58:19,069 --> 00:58:23,059
can essentially figure out what was

00:58:21,109 --> 00:58:25,339
meant in scholar to and give you this

00:58:23,059 --> 00:58:27,650
kind of three equivalent and Scala fixes

00:58:25,339 --> 00:58:31,009
also a tool that nicely shapes up with

00:58:27,650 --> 00:58:33,200
that purpose so I believe that despite

00:58:31,009 --> 00:58:34,789
what many people see fear that the

00:58:33,200 --> 00:58:39,170
situation is actually better than for

00:58:34,789 --> 00:58:41,869
Python two versus three because mostly

00:58:39,170 --> 00:58:44,869
because of static typing which enables

00:58:41,869 --> 00:58:47,749
these we write tools and secondly also

00:58:44,869 --> 00:58:51,559
because unlike Python we actually have

00:58:47,749 --> 00:58:55,339
binary compatibility as well as source

00:58:51,559 --> 00:58:57,079
compatible ability to play with so now

00:58:55,339 --> 00:58:59,180
you say binary compatibility why it

00:58:57,079 --> 00:59:01,880
wasn't that just the Achilles heel of

00:58:59,180 --> 00:59:03,589
Scala wasn't that every every time where

00:59:01,880 --> 00:59:04,279
essentially that's that's much harder

00:59:03,589 --> 00:59:07,160
than source

00:59:04,279 --> 00:59:09,920
so I mentioned binary compatibility as

00:59:07,160 --> 00:59:12,019
an advantage well actually yes

00:59:09,920 --> 00:59:14,239
because what we have today is actually

00:59:12,019 --> 00:59:16,460
the thirty can link with Kara to twelve

00:59:14,239 --> 00:59:18,319
class files so it means it works with

00:59:16,460 --> 00:59:21,079
the Scala to twelve compiled standard

00:59:18,319 --> 00:59:22,849
library or any other library really we

00:59:21,079 --> 00:59:24,829
can just read it and work with it which

00:59:22,849 --> 00:59:26,900
is actually much better than Scala to

00:59:24,829 --> 00:59:28,880
twelve to to eleven sighs you can't do

00:59:26,900 --> 00:59:31,579
that with the to eleven library pulled

00:59:28,880 --> 00:59:34,219
in with a to twelve compiler so we we

00:59:31,579 --> 00:59:36,259
can do we have today a dotty module that

00:59:34,219 --> 00:59:38,660
can sit just on Skaro two modules so

00:59:36,259 --> 00:59:41,239
that means we can interoperate we can

00:59:38,660 --> 00:59:43,400
have systems that gradually migrate to

00:59:41,239 --> 00:59:46,099
Scala three but that's still rest on a

00:59:43,400 --> 00:59:47,930
SCARA - basis but it's still very

00:59:46,099 --> 00:59:50,779
restrictive because it means before you

00:59:47,930 --> 00:59:52,400
can it's got a three if I anything all

00:59:50,779 --> 00:59:53,560
its dependencies have to be scatter

00:59:52,400 --> 00:59:56,890
three under the car

00:59:53,560 --> 00:59:59,190
but we with with tasty actually we

00:59:56,890 --> 01:00:02,080
believe we can change that as well

00:59:59,190 --> 01:00:04,510
because we using tasty as a common

01:00:02,080 --> 01:00:06,640
intermediate format will not only help

01:00:04,510 --> 01:00:08,290
us share the large part of the compiler

01:00:06,640 --> 01:00:10,150
structure the whole middle end and back

01:00:08,290 --> 01:00:12,340
end already between the SCADA 2 and 3

01:00:10,150 --> 01:00:14,230
compilers but it also gives us two-way

01:00:12,340 --> 01:00:16,590
compatibility so in the future you

01:00:14,230 --> 01:00:18,910
should be able to freely mix and match

01:00:16,590 --> 01:00:21,930
anyway your dependencies and I think

01:00:18,910 --> 01:00:26,710
that will be a big help in the migration

01:00:21,930 --> 01:00:29,830
so roadmap when is this going to happen

01:00:26,710 --> 01:00:34,900
so 2020 what's going to happen until

01:00:29,830 --> 01:00:38,440
then so we are in 2018 we currently have

01:00:34,900 --> 01:00:40,180
dot e 0.9 is curate I think is the last

01:00:38,440 --> 01:00:42,310
released ones there's a new one every

01:00:40,180 --> 01:00:45,070
six weeks so essentially we have rolling

01:00:42,310 --> 01:00:47,050
dot e releases and the purpose of those

01:00:45,070 --> 01:00:49,210
is to flesh out the design I've said

01:00:47,050 --> 01:00:51,790
there's something still to be designed

01:00:49,210 --> 01:00:54,700
get feedback one from the community and

01:00:51,790 --> 01:00:57,430
essentially do iterative refinements we

01:00:54,700 --> 01:01:00,190
plan to go into feature freeze about a

01:00:57,430 --> 01:01:02,740
year from now so hopefully by scaredy's

01:01:00,190 --> 01:01:05,370
next year we are in future freeze and

01:01:02,740 --> 01:01:08,230
then we plan to use another year for

01:01:05,370 --> 01:01:10,660
essentially stabilization and get the

01:01:08,230 --> 01:01:13,630
ecosystem across so that means there

01:01:10,660 --> 01:01:16,390
will be scary developer previews which

01:01:13,630 --> 01:01:19,000
will be essentially be bug fixes and

01:01:16,390 --> 01:01:21,580
tooling improvements and hopefully with

01:01:19,000 --> 01:01:23,740
every review there will be a larger part

01:01:21,580 --> 01:01:26,710
of the Scala ecosystem that will be on

01:01:23,740 --> 01:01:29,950
Scala 3 so that's my hope and then maybe

01:01:26,710 --> 01:01:33,600
by scholar days in two years from now we

01:01:29,950 --> 01:01:36,520
will actually be able to announce Cara 3

01:01:33,600 --> 01:01:38,770
the other barrier is of course stability

01:01:36,520 --> 01:01:40,810
it's a new compiler code base that makes

01:01:38,770 --> 01:01:46,390
me nervous it should make you nervous as

01:01:40,810 --> 01:01:48,220
well so we we try to mitigate that by

01:01:46,390 --> 01:01:49,990
essentially running the same test so

01:01:48,220 --> 01:01:53,230
most Cara - regression tests are in the

01:01:49,990 --> 01:01:55,180
scalar 3 test suite we are slowly

01:01:53,230 --> 01:01:57,220
building up a community build four core

01:01:55,180 --> 01:01:59,110
libraries and tools what's holding us

01:01:57,220 --> 01:02:01,150
back here is mostly macros right now

01:01:59,110 --> 01:02:02,470
that essentially since we can't do the

01:02:01,150 --> 01:02:05,310
scalar to macro so it turns out that

01:02:02,470 --> 01:02:06,930
macros are transitive dependencies of

01:02:05,310 --> 01:02:10,440
almost hundred-person

01:02:06,930 --> 01:02:12,450
of the ecosystem in Scala by now so what

01:02:10,440 --> 01:02:14,040
we really need to do is we have we need

01:02:12,450 --> 01:02:16,500
to have an alternative solution and then

01:02:14,040 --> 01:02:18,180
we have to work with the low-level

01:02:16,500 --> 01:02:20,700
libraries that write these macros to

01:02:18,180 --> 01:02:25,020
have essentially versions out for Scala

01:02:20,700 --> 01:02:26,880
3 the good part is that the since they

01:02:25,020 --> 01:02:28,800
are based on tasty the new ones they

01:02:26,880 --> 01:02:30,630
will work for Scala too as well so one

01:02:28,800 --> 01:02:32,309
scanner to is on tasting you will have

01:02:30,630 --> 01:02:36,900
macros that can actually work on post

01:02:32,309 --> 01:02:39,329
two and three and the the other thing

01:02:36,900 --> 01:02:40,950
what we do is we do bootstrap so we use

01:02:39,329 --> 01:02:43,500
our own compiler to compile everything

01:02:40,950 --> 01:02:46,589
we write but we don't bootstrap from

01:02:43,500 --> 01:02:48,119
essentially a scale of three code base

01:02:46,589 --> 01:02:51,270
so everything gets compiled with a

01:02:48,119 --> 01:02:52,710
scarlet uh compiler and then goes gets

01:02:51,270 --> 01:02:55,680
compiled again with the Scala three

01:02:52,710 --> 01:02:59,520
compiler that we know that that works so

01:02:55,680 --> 01:03:03,420
what we plan to do then in the remaining

01:02:59,520 --> 01:03:05,099
time until SCADA 3 is ensure that core

01:03:03,420 --> 01:03:08,250
projects are published for Scala three

01:03:05,099 --> 01:03:09,660
and long before that we probably in the

01:03:08,250 --> 01:03:11,940
next weeks or something like that we

01:03:09,660 --> 01:03:14,099
want to use our own compiler as the

01:03:11,940 --> 01:03:15,720
bootstrap root so essentially start with

01:03:14,099 --> 01:03:17,910
an old version of the old code of our

01:03:15,720 --> 01:03:21,089
own compiler why does that matter

01:03:17,910 --> 01:03:23,549
because then finally we can eat our own

01:03:21,089 --> 01:03:27,569
dog food we're not forced we can which

01:03:23,549 --> 01:03:30,359
is will be a which could be a great joy

01:03:27,569 --> 01:03:32,700
to be able to use all these fancy scary

01:03:30,359 --> 01:03:34,740
features in our own tools and that of

01:03:32,700 --> 01:03:36,900
course we can't do right now because the

01:03:34,740 --> 01:03:39,569
first step is still Scala 2 for the

01:03:36,900 --> 01:03:43,950
compilation so you can try it out today

01:03:39,569 --> 01:03:47,150
dot e EPFL dot CH has rolling releases

01:03:43,950 --> 01:03:50,579
every six weeks if you have questions

01:03:47,150 --> 01:03:53,420
suggestions or concerns then I imagine

01:03:50,579 --> 01:03:56,069
quite a few of you will have one then

01:03:53,420 --> 01:03:58,680
talk to us any time around the

01:03:56,069 --> 01:04:00,690
conference or after there's a panel at

01:03:58,680 --> 01:04:03,359
the last day of the conference where we

01:04:00,690 --> 01:04:05,099
will respond to questions but of course

01:04:03,359 --> 01:04:07,440
catch me before that if you have

01:04:05,099 --> 01:04:09,599
something that you want to discuss and

01:04:07,440 --> 01:04:12,990
also there's a contributors workshop on

01:04:09,599 --> 01:04:15,599
Friday I think it's Alondra premises

01:04:12,990 --> 01:04:18,240
that I believe still has some number of

01:04:15,599 --> 01:04:19,680
places a torso so talk to Heather Miller

01:04:18,240 --> 01:04:21,530
if you want to go there

01:04:19,680 --> 01:04:28,669
thank you

01:04:21,530 --> 01:04:28,669

YouTube URL: https://www.youtube.com/watch?v=1VDOhiFYW3Y


