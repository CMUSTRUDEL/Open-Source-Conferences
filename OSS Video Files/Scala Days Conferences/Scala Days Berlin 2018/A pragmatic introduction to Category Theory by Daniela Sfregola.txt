Title: A pragmatic introduction to Category Theory by Daniela Sfregola
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6917-a-pragmatic-introduction-to-category-theory.html
Captions: 
	00:00:04,640 --> 00:00:11,840
we are gonna have a little bit of fun we

00:00:08,600 --> 00:00:13,759
are also gonna look at some code don't

00:00:11,840 --> 00:00:17,300
worry about it all the code it's

00:00:13,759 --> 00:00:20,890
published so my suggestion for this talk

00:00:17,300 --> 00:00:23,210
is don't worry about the code too much

00:00:20,890 --> 00:00:25,789
enjoyed the reasoning that we are gonna

00:00:23,210 --> 00:00:27,650
do behind the code and then you know if

00:00:25,789 --> 00:00:29,900
you're interested and you want to know

00:00:27,650 --> 00:00:34,100
more come back to the code have a look

00:00:29,900 --> 00:00:36,559
at it play with it okay I'm so relaxed

00:00:34,100 --> 00:00:39,949
not too much don't fall asleep but I

00:00:36,559 --> 00:00:42,350
enjoy the journey um ii discovered that

00:00:39,949 --> 00:00:45,229
i want to do is that if you are a

00:00:42,350 --> 00:00:48,739
mathematician during this talk you will

00:00:45,229 --> 00:00:51,470
have a few itches um a few moments where

00:00:48,739 --> 00:00:56,150
you would like to scream and probably

00:00:51,470 --> 00:00:58,850
throw me something please don't this

00:00:56,150 --> 00:01:02,150
talk is not meant for you and now i'm

00:00:58,850 --> 00:01:04,489
gonna generalize and forget a lot of

00:01:02,150 --> 00:01:06,250
details but don't worry about it it's

00:01:04,489 --> 00:01:09,650
gonna be awesome

00:01:06,250 --> 00:01:13,280
so a programmatic introduction to

00:01:09,650 --> 00:01:17,420
category theory so why am i doing this

00:01:13,280 --> 00:01:19,910
talk well as many of you i guess i used

00:01:17,420 --> 00:01:23,150
to be a Java developer and i used to

00:01:19,910 --> 00:01:25,730
love it believe it or not and you know

00:01:23,150 --> 00:01:28,550
during my career everybody was talking

00:01:25,730 --> 00:01:31,850
about the Gang of Four and then I start

00:01:28,550 --> 00:01:35,540
doing Scala and suddenly people said no

00:01:31,850 --> 00:01:38,120
the buildin Potter is not he's not cool

00:01:35,540 --> 00:01:41,150
anymore no you know you have to use

00:01:38,120 --> 00:01:44,510
filters and mono agent moments and

00:01:41,150 --> 00:01:46,610
applicatives and it was really scary it

00:01:44,510 --> 00:01:50,270
was a lot of words that I could not

00:01:46,610 --> 00:01:55,000
understand I'm not a mathematician so I

00:01:50,270 --> 00:01:58,040
have no idea what all those words meant

00:01:55,000 --> 00:01:59,810
side note I'm also writing a book yes

00:01:58,040 --> 00:02:01,820
crazy ideas going to take me a while if

00:01:59,810 --> 00:02:04,610
you want to talk about that coming from

00:02:01,820 --> 00:02:07,700
me later but the whole idea is that I'm

00:02:04,610 --> 00:02:09,229
not a mathematician so every time I

00:02:07,700 --> 00:02:10,789
attend this color conference or a

00:02:09,229 --> 00:02:12,379
functional programming conference there

00:02:10,789 --> 00:02:16,220
is always something that makes me feel

00:02:12,379 --> 00:02:17,390
like that latest one was the profiler

00:02:16,220 --> 00:02:19,370
optics

00:02:17,390 --> 00:02:21,830
so if you guys know what a profounder

00:02:19,370 --> 00:02:25,960
uptick is please come and find me and

00:02:21,830 --> 00:02:29,330
explain it to me because I have no idea

00:02:25,960 --> 00:02:32,960
sir I'm out of position a while ago I

00:02:29,330 --> 00:02:34,250
went away and you know I took a couple

00:02:32,960 --> 00:02:37,970
of books and I started selling things

00:02:34,250 --> 00:02:40,750
and after a while it clicked hey I can

00:02:37,970 --> 00:02:45,140
explain this in simple terms for

00:02:40,750 --> 00:02:48,050
pelipper so that's the goal of the sock

00:02:45,140 --> 00:02:50,930
is not for mathematicians but it's for

00:02:48,050 --> 00:02:53,630
people like me that don't understand

00:02:50,930 --> 00:02:56,510
math most of the time but we just still

00:02:53,630 --> 00:02:59,590
get what a mano eight what am on it is

00:02:56,510 --> 00:03:02,720
okay we're all on the same page yeah

00:02:59,590 --> 00:03:05,810
okay cool so why do we care

00:03:02,720 --> 00:03:09,470
well we don't really need to know

00:03:05,810 --> 00:03:11,900
category theory to write your code we

00:03:09,470 --> 00:03:15,020
have been doing that for a long time and

00:03:11,900 --> 00:03:19,760
nobody really cared until the Oscar

00:03:15,020 --> 00:03:21,980
people said that it was important and we

00:03:19,760 --> 00:03:24,549
don't really need to know category

00:03:21,980 --> 00:03:26,989
theory to write good functional code

00:03:24,549 --> 00:03:29,810
functional code is relatively simple

00:03:26,989 --> 00:03:32,690
don't use var don't use var don't use

00:03:29,810 --> 00:03:34,940
VARs don't for exceptions and right for

00:03:32,690 --> 00:03:37,910
functions the basics of function

00:03:34,940 --> 00:03:41,150
programming are actually fairly simple

00:03:37,910 --> 00:03:44,450
to understand so why did I went away and

00:03:41,150 --> 00:03:47,660
I did this churning of starting math

00:03:44,450 --> 00:03:48,200
again well that's because he gave me

00:03:47,660 --> 00:03:51,200
happiness

00:03:48,200 --> 00:03:54,440
and disciplines I'm hoping I'm going to

00:03:51,200 --> 00:03:56,360
transfer it to you but it is that I was

00:03:54,440 --> 00:03:59,600
able to understand why certain things

00:03:56,360 --> 00:04:02,630
are done in a certain way in Scala and I

00:03:59,600 --> 00:04:06,380
was happy so are we ready to start this

00:04:02,630 --> 00:04:09,190
amazing journey yes awesome nice energy

00:04:06,380 --> 00:04:11,840
from the room so how do we reason right

00:04:09,190 --> 00:04:14,540
because at the end our job is to

00:04:11,840 --> 00:04:17,540
translate the way we reason into a

00:04:14,540 --> 00:04:20,000
machine so to come to this conference I

00:04:17,540 --> 00:04:23,330
had to take a train I too took a train

00:04:20,000 --> 00:04:25,490
death was identified by a letter s don't

00:04:23,330 --> 00:04:27,260
ask me to pronounce the station name

00:04:25,490 --> 00:04:29,360
because I'm not gonna dare to do that

00:04:27,260 --> 00:04:31,210
and then I change they take a train

00:04:29,360 --> 00:04:35,419
there was a you

00:04:31,210 --> 00:04:38,240
so in my brain I knew that there were a

00:04:35,419 --> 00:04:41,060
couple of steps take the train change at

00:04:38,240 --> 00:04:43,580
the station take another train but while

00:04:41,060 --> 00:04:46,250
I was doing that I wasn't thinking okay

00:04:43,580 --> 00:04:48,380
you have to walk and you have to

00:04:46,250 --> 00:04:48,800
contract the muscles of your legs to do

00:04:48,380 --> 00:04:50,990
that

00:04:48,800 --> 00:04:53,710
because I know how to work right I don't

00:04:50,990 --> 00:04:57,949
need to look into every single detail

00:04:53,710 --> 00:05:00,669
and it turns out that when human reason

00:04:57,949 --> 00:05:04,430
about things all we do is that we

00:05:00,669 --> 00:05:07,210
decompose the tasking to simpler tasks

00:05:04,430 --> 00:05:09,560
and we forget about all the details that

00:05:07,210 --> 00:05:11,080
we really don't care because we already

00:05:09,560 --> 00:05:14,870
know how they work

00:05:11,080 --> 00:05:18,710
so reasoning is basically about

00:05:14,870 --> 00:05:21,080
composition and abstraction we don't

00:05:18,710 --> 00:05:23,570
care about every single detail all we

00:05:21,080 --> 00:05:25,789
need to know is once we identify the

00:05:23,570 --> 00:05:29,780
single tasks are we're gonna compose

00:05:25,789 --> 00:05:32,570
them together and he happens that

00:05:29,780 --> 00:05:34,340
category theory is exactly that category

00:05:32,570 --> 00:05:36,860
theory doesn't care about what you're

00:05:34,340 --> 00:05:39,099
composing the only thing that it cares

00:05:36,860 --> 00:05:42,889
is about how you can post these things

00:05:39,099 --> 00:05:46,580
and category theory is a really scary

00:05:42,889 --> 00:05:50,030
term so I'm gonna rename a horror theory

00:05:46,580 --> 00:05:52,610
and our theory is because at the end of

00:05:50,030 --> 00:05:55,340
the day all we are gonna look at are

00:05:52,610 --> 00:06:00,979
these magic colors that we are gonna

00:05:55,340 --> 00:06:03,470
deal with okay cool so now a little bit

00:06:00,979 --> 00:06:06,110
of math I promise is gonna be short and

00:06:03,470 --> 00:06:10,310
not so painful and then we will go

00:06:06,110 --> 00:06:16,039
through the fun stuff okay what is the

00:06:10,310 --> 00:06:20,150
category or category is objects when I

00:06:16,039 --> 00:06:25,970
say objects I mean literally a chair a

00:06:20,150 --> 00:06:29,599
flower a human a type they are connected

00:06:25,970 --> 00:06:32,990
by a relation a relation is just

00:06:29,599 --> 00:06:37,250
something that given an object returns

00:06:32,990 --> 00:06:38,870
another object because we are not

00:06:37,250 --> 00:06:42,530
mathematicians we are computer

00:06:38,870 --> 00:06:43,350
scientists we actually have a lot easier

00:06:42,530 --> 00:06:46,050
task than

00:06:43,350 --> 00:06:48,030
magicians do mathematicians has to think

00:06:46,050 --> 00:06:50,790
about crazy categories right they have

00:06:48,030 --> 00:06:52,590
to think about chairs people and a lot

00:06:50,790 --> 00:06:54,390
of things that we really don't care

00:06:52,590 --> 00:06:56,610
about so because we are computer

00:06:54,390 --> 00:07:01,470
scientists we are going to simplify a

00:06:56,610 --> 00:07:03,230
lot so when we write programs usually

00:07:01,470 --> 00:07:08,220
it's not always like that but usually

00:07:03,230 --> 00:07:12,030
objects are tight and ours are functions

00:07:08,220 --> 00:07:14,670
there are exceptions but what category

00:07:12,030 --> 00:07:19,230
is is basically objects connected by

00:07:14,670 --> 00:07:21,410
relations okay and there are some rules

00:07:19,230 --> 00:07:24,840
to our game otherwise it wouldn't be fun

00:07:21,410 --> 00:07:30,240
so the first rule is that if you have an

00:07:24,840 --> 00:07:33,990
F this goes from A to B and you have a G

00:07:30,240 --> 00:07:37,760
that goes from B to C you know you can

00:07:33,990 --> 00:07:40,710
create a new RF that is called G after F

00:07:37,760 --> 00:07:43,080
there is the composition of the two

00:07:40,710 --> 00:07:48,900
arrows we know we can do that because

00:07:43,080 --> 00:07:50,790
that's the rule of the game and the

00:07:48,900 --> 00:07:53,400
other rule of our game is that every

00:07:50,790 --> 00:07:57,180
time we have an object we have a special

00:07:53,400 --> 00:08:00,420
arrow the basically does nothing so if

00:07:57,180 --> 00:08:04,080
we are in a and we take the identity of

00:08:00,420 --> 00:08:05,880
a we will still be in a and every time

00:08:04,080 --> 00:08:06,210
we compose this identity with something

00:08:05,880 --> 00:08:10,800
else

00:08:06,210 --> 00:08:14,970
basically nothing changes so these F

00:08:10,800 --> 00:08:19,410
after I ID of a equal F equal it's

00:08:14,970 --> 00:08:23,460
basically saying ID does nothing okay go

00:08:19,410 --> 00:08:27,570
and finally we need to have

00:08:23,460 --> 00:08:30,300
associativity so in really complex term

00:08:27,570 --> 00:08:33,450
if you have enough and you have a G and

00:08:30,300 --> 00:08:36,060
if you have an age if you go first

00:08:33,450 --> 00:08:40,110
through F and then you go through the

00:08:36,060 --> 00:08:40,440
composition of H or G and the other way

00:08:40,110 --> 00:08:43,349
around

00:08:40,440 --> 00:08:46,350
in simple terms basically the green path

00:08:43,349 --> 00:08:49,050
is the same of the black path too

00:08:46,350 --> 00:08:51,890
complex to read it really easy to to see

00:08:49,050 --> 00:08:55,070
it in a visualization okay and

00:08:51,890 --> 00:08:59,149
the way I remember about sushi tivity is

00:08:55,070 --> 00:09:01,089
that basically I can put the parentheses

00:08:59,149 --> 00:09:04,640
wherever I want

00:09:01,089 --> 00:09:06,589
why is that because I have better things

00:09:04,640 --> 00:09:11,779
to do with my life then worry about

00:09:06,589 --> 00:09:14,029
parentheses okay so you simply don't

00:09:11,779 --> 00:09:18,410
worry about it it would be fine

00:09:14,029 --> 00:09:21,110
so summing up a category it's a set of

00:09:18,410 --> 00:09:23,750
objects there are they have some

00:09:21,110 --> 00:09:27,110
relationships and they have these rules

00:09:23,750 --> 00:09:28,670
these are the rules that you need to

00:09:27,110 --> 00:09:31,130
have in order to have a category and

00:09:28,670 --> 00:09:34,519
these are identity and our that does not

00:09:31,130 --> 00:09:38,480
think composition the ability to create

00:09:34,519 --> 00:09:41,089
new errors by composing existing errors

00:09:38,480 --> 00:09:46,670
and associativity that is I don't care

00:09:41,089 --> 00:09:49,760
about parentheses okay oh good yes but

00:09:46,670 --> 00:09:52,820
why do we care right well it turns out

00:09:49,760 --> 00:09:55,550
that we do this all the time this is a

00:09:52,820 --> 00:09:59,089
really practical example right so I know

00:09:55,550 --> 00:10:03,230
that if I have a function that goes from

00:09:59,089 --> 00:10:05,120
a string to an int basically sighs and I

00:10:03,230 --> 00:10:07,940
have a function that from int goes to

00:10:05,120 --> 00:10:09,500
boo let's call it bigger than two I can

00:10:07,940 --> 00:10:12,380
automatically create a new function

00:10:09,500 --> 00:10:15,010
let's call it size bigger than two they

00:10:12,380 --> 00:10:18,410
will transform my string into a ball and

00:10:15,010 --> 00:10:22,399
they know that for every type I have I

00:10:18,410 --> 00:10:23,870
have a special I do nothing arrow that

00:10:22,399 --> 00:10:25,940
is called identity okay

00:10:23,870 --> 00:10:28,100
so we do this all the time we just don't

00:10:25,940 --> 00:10:34,399
realize there is actually category

00:10:28,100 --> 00:10:38,329
theory okay almost there with the boring

00:10:34,399 --> 00:10:40,390
mathematical stuff let's start about the

00:10:38,329 --> 00:10:43,579
start to talk about the simplest

00:10:40,390 --> 00:10:45,140
category that we can think of right and

00:10:43,579 --> 00:10:47,920
the simplest category that we can think

00:10:45,140 --> 00:10:53,750
of is the category with just one object

00:10:47,920 --> 00:10:56,230
so um it must be a category right so it

00:10:53,750 --> 00:10:59,810
needs to have an object and some arrows

00:10:56,230 --> 00:11:02,660
you need to have an identity and this is

00:10:59,810 --> 00:11:05,450
an hour that does nothing it means that

00:11:02,660 --> 00:11:09,290
if I combine if I compose

00:11:05,450 --> 00:11:12,560
sorry the identity with an a I seek

00:11:09,290 --> 00:11:16,600
Garin a and if I compose an A with the

00:11:12,560 --> 00:11:20,960
identity are still get an A Okay and

00:11:16,600 --> 00:11:25,130
also I can compose any two errors and

00:11:20,960 --> 00:11:26,750
create a new arrow okay but

00:11:25,130 --> 00:11:29,090
mathematician don't have don't say

00:11:26,750 --> 00:11:32,380
category with one object they call it

00:11:29,090 --> 00:11:36,320
more annoyed because it's shorter and

00:11:32,380 --> 00:11:40,120
they probably like it more so as a

00:11:36,320 --> 00:11:42,710
developer I still have a set of rules

00:11:40,120 --> 00:11:44,270
the same that we have seen so far right

00:11:42,710 --> 00:11:47,180
I tend to see composition of such

00:11:44,270 --> 00:11:49,580
tivities those are our three amigas that

00:11:47,180 --> 00:11:52,070
we are gonna see over and over again for

00:11:49,580 --> 00:11:56,570
me I don't care about understanding what

00:11:52,070 --> 00:11:59,870
those formulas are for me it's just a

00:11:56,570 --> 00:12:02,000
test that I have to write so you guys

00:11:59,870 --> 00:12:05,660
are not gonna be able to read this but I

00:12:02,000 --> 00:12:07,490
did it using Scala check you can write

00:12:05,660 --> 00:12:10,310
property tests that will make sure that

00:12:07,490 --> 00:12:13,970
the properties work so I didn't have to

00:12:10,310 --> 00:12:15,770
understand what this formulas are I just

00:12:13,970 --> 00:12:20,860
had to translate them into tests and the

00:12:15,770 --> 00:12:20,860
tests pass so it's awesome okay

00:12:20,920 --> 00:12:28,220
but again why do we care as developers

00:12:24,770 --> 00:12:33,680
um well this is a classic example of

00:12:28,220 --> 00:12:37,460
what Manu it is so we said before the

00:12:33,680 --> 00:12:40,220
Monod is characterized by two things an

00:12:37,460 --> 00:12:43,940
operation and an identity for their

00:12:40,220 --> 00:12:50,090
operation so let's take for example an

00:12:43,940 --> 00:12:52,910
object that represents int notice that

00:12:50,090 --> 00:12:56,270
that object doesn't really matter I

00:12:52,910 --> 00:13:00,470
could have called a cat or dog doesn't

00:12:56,270 --> 00:13:04,610
change what we are discussing and we

00:13:00,470 --> 00:13:06,760
have an arrow that is called zero and we

00:13:04,610 --> 00:13:10,750
have another arrow that is called one

00:13:06,760 --> 00:13:14,240
what happens if I compose zero with one

00:13:10,750 --> 00:13:18,760
where compose means apply operation plus

00:13:14,240 --> 00:13:23,950
I get the r1 what if I compose

00:13:18,760 --> 00:13:27,610
the ro1 with the with itself so I do 1+1

00:13:23,950 --> 00:13:30,880
I get a new arrow that is 2 what if I

00:13:27,610 --> 00:13:34,080
want 3 I compose the other one with the

00:13:30,880 --> 00:13:38,080
arrow 2 and so on and so forth

00:13:34,080 --> 00:13:39,790
so there you go we have a visual

00:13:38,080 --> 00:13:42,820
representation of how we can generate

00:13:39,790 --> 00:13:48,130
all the natural numbers so this pretty

00:13:42,820 --> 00:13:50,350
cool and again the two things that

00:13:48,130 --> 00:13:53,380
characterize money is identity in

00:13:50,350 --> 00:13:56,440
composition so what do a functional

00:13:53,380 --> 00:14:02,950
programmer use every time he has to

00:13:56,440 --> 00:14:05,380
solve a problem type class so what we

00:14:02,950 --> 00:14:07,990
just said is that in order to be Amanat

00:14:05,380 --> 00:14:12,190
you need to have a definition of what

00:14:07,990 --> 00:14:14,350
compost means so given two types I need

00:14:12,190 --> 00:14:18,010
to have a function that produce one

00:14:14,350 --> 00:14:21,900
element of that type and I have need to

00:14:18,010 --> 00:14:26,290
have something that is called identity

00:14:21,900 --> 00:14:35,280
that that does basically nothing

00:14:26,290 --> 00:14:39,400
okay so this for example is a mono it

00:14:35,280 --> 00:14:44,230
instance for int so if I say that

00:14:39,400 --> 00:14:49,240
compose is the operation some then the

00:14:44,230 --> 00:14:54,550
identity is 0 because I can sum any

00:14:49,240 --> 00:14:57,100
numbers to 0 and get the same number I

00:14:54,550 --> 00:15:01,320
happy for can you guys think of any

00:14:57,100 --> 00:15:01,320
other example using integers

00:15:02,490 --> 00:15:06,970
multiplication congratulations

00:15:04,570 --> 00:15:10,690
yes multiplication is the other example

00:15:06,970 --> 00:15:13,300
well done you where instead of having a

00:15:10,690 --> 00:15:15,730
plus here we just have a multiplier

00:15:13,300 --> 00:15:16,150
symbol and the end it is not zero

00:15:15,730 --> 00:15:21,010
anymore

00:15:16,150 --> 00:15:24,130
it's 1 ok another classic example is

00:15:21,010 --> 00:15:26,830
with strings where compose is the

00:15:24,130 --> 00:15:31,220
concatenation of two strings and the

00:15:26,830 --> 00:15:35,270
identity is the empty string okay

00:15:31,220 --> 00:15:39,230
now ready for the fun part yes you guys

00:15:35,270 --> 00:15:42,140
are awesome so um we have seen where a

00:15:39,230 --> 00:15:43,670
category with one object is but

00:15:42,140 --> 00:15:46,120
obviously you know what happens if there

00:15:43,670 --> 00:15:48,500
is more than one what can we do with it

00:15:46,120 --> 00:15:52,910
so let's assume we have this beautiful

00:15:48,500 --> 00:15:56,750
category that has a flower and triangle

00:15:52,910 --> 00:15:58,940
and has an identity flower and identity

00:15:56,750 --> 00:16:02,570
for triangle and then we have some kind

00:15:58,940 --> 00:16:07,850
of way of transforming a flower into a

00:16:02,570 --> 00:16:09,920
triangle so what happens if you know we

00:16:07,850 --> 00:16:11,920
decided to play with it and we say okay

00:16:09,920 --> 00:16:14,930
we're gonna put everything into a box

00:16:11,920 --> 00:16:17,660
and when I say we are gonna put

00:16:14,930 --> 00:16:21,460
everything in a box I mean that we're

00:16:17,660 --> 00:16:24,370
gonna take up a flower and we are gonna

00:16:21,460 --> 00:16:26,810
use a transformation to put into a box

00:16:24,370 --> 00:16:31,630
we're gonna take our triangle and do the

00:16:26,810 --> 00:16:34,370
same and then copy the arrows over okay

00:16:31,630 --> 00:16:38,960
we're just playing with things and see

00:16:34,370 --> 00:16:41,450
what's going on so again we take all the

00:16:38,960 --> 00:16:45,290
objects and we put them in a box and

00:16:41,450 --> 00:16:49,190
then all the hours in the original

00:16:45,290 --> 00:16:53,600
category are mapped into the target

00:16:49,190 --> 00:16:59,210
category another way of looking at this

00:16:53,600 --> 00:17:03,670
is to say okay I have some data but I

00:16:59,210 --> 00:17:09,020
have some metadata about my data so I

00:17:03,670 --> 00:17:11,750
know that I have a flower but maybe I

00:17:09,020 --> 00:17:14,390
have more than one flower so I need

00:17:11,750 --> 00:17:15,530
somehow to express this idea that a

00:17:14,390 --> 00:17:18,140
flower

00:17:15,530 --> 00:17:22,030
I could have 0 or more instances of

00:17:18,140 --> 00:17:27,380
flower or maybe my data is not able I

00:17:22,030 --> 00:17:30,650
need to say by the way you know this

00:17:27,380 --> 00:17:33,710
might not be there and we do this in

00:17:30,650 --> 00:17:36,830
Scala all the time right so we have

00:17:33,710 --> 00:17:40,040
option that is just a wrapper that tells

00:17:36,830 --> 00:17:42,770
you dude be careful you might not be

00:17:40,040 --> 00:17:44,780
there future it's something that is

00:17:42,770 --> 00:17:47,420
gonna take some time to compute

00:17:44,780 --> 00:17:49,190
so you can see there's a box that has a

00:17:47,420 --> 00:17:51,980
little frog then when it's completed

00:17:49,190 --> 00:17:54,440
it's gonna the flag is gonna go up and

00:17:51,980 --> 00:17:56,240
say hey I'm done and it's either gonna

00:17:54,440 --> 00:17:59,450
contain something good or something

00:17:56,240 --> 00:18:02,720
really bad you have try try it's a box

00:17:59,450 --> 00:18:07,280
with a ticking pop be a bump that is

00:18:02,720 --> 00:18:11,660
about to explode at any moment and so on

00:18:07,280 --> 00:18:15,550
and so forth okay so this idea of having

00:18:11,660 --> 00:18:18,320
a category wrapped around into a box

00:18:15,550 --> 00:18:20,600
mathematicians call it functor it's the

00:18:18,320 --> 00:18:25,370
idea of you know having some metadata

00:18:20,600 --> 00:18:27,860
around your data and some is before our

00:18:25,370 --> 00:18:32,720
free amigas are back identity

00:18:27,860 --> 00:18:34,880
composition as such TVT and as usual

00:18:32,720 --> 00:18:36,950
formula sorry I didn't really don't

00:18:34,880 --> 00:18:39,410
understand formulas every time you know

00:18:36,950 --> 00:18:42,680
I there is a formula I have to read it

00:18:39,410 --> 00:18:44,300
like once twice three four times the

00:18:42,680 --> 00:18:46,100
stick doesn't make any sense and then I

00:18:44,300 --> 00:18:48,560
start doing some drawings and then I get

00:18:46,100 --> 00:18:50,900
it but it's just me it's just my brain

00:18:48,560 --> 00:18:53,810
I'm not a mathematician so for me

00:18:50,900 --> 00:18:56,180
formulas are just tests and turns out

00:18:53,810 --> 00:18:58,850
that s color check is really good for

00:18:56,180 --> 00:19:01,010
this so I've wrote some tests that will

00:18:58,850 --> 00:19:05,920
make sure that my mathematician friends

00:19:01,010 --> 00:19:05,920
are happy about my implementation good

00:19:07,630 --> 00:19:20,840
so in a way what we are doing here is

00:19:13,070 --> 00:19:23,240
that we need we need this idiot if I

00:19:20,840 --> 00:19:27,440
know how to transform a flower into a

00:19:23,240 --> 00:19:31,190
triangle then if you give me a box with

00:19:27,440 --> 00:19:34,400
a flower I need to automatically know

00:19:31,190 --> 00:19:39,560
how to transform that box into a box

00:19:34,400 --> 00:19:45,580
containing a triangle right and again as

00:19:39,560 --> 00:19:50,810
a lazy developer boom tight class again

00:19:45,580 --> 00:19:53,179
so this is usually called map and this

00:19:50,810 --> 00:19:56,179
is just a function that given a box of a

00:19:53,179 --> 00:19:58,070
and the function that transforms your

00:19:56,179 --> 00:20:00,950
aim to a be

00:19:58,070 --> 00:20:03,890
it gives you a box of B so if you want

00:20:00,950 --> 00:20:08,540
to call yourself factor you need to tell

00:20:03,890 --> 00:20:11,510
me how to do that okay and we are not

00:20:08,540 --> 00:20:12,530
using any fancy feature of the language

00:20:11,510 --> 00:20:15,590
here right

00:20:12,530 --> 00:20:17,750
we're just reasoning about things and to

00:20:15,590 --> 00:20:18,650
prove you that I have created my own

00:20:17,750 --> 00:20:22,610
option

00:20:18,650 --> 00:20:25,910
it's called maybe and instead of being

00:20:22,610 --> 00:20:31,060
sum of a value is called just of a value

00:20:25,910 --> 00:20:33,650
and instead of having none he has empty

00:20:31,060 --> 00:20:37,130
this is just to demonstrate you there

00:20:33,650 --> 00:20:41,120
are all I'm using is algebra data types

00:20:37,130 --> 00:20:41,660
I'm not using any fancy feature of the

00:20:41,120 --> 00:20:44,090
language

00:20:41,660 --> 00:20:46,790
I'm just reasoning okay if you are this

00:20:44,090 --> 00:20:53,480
type these are all your possible options

00:20:46,790 --> 00:20:56,960
okay so how can we implement a functor

00:20:53,480 --> 00:20:59,930
for maybe well we said before that we

00:20:56,960 --> 00:21:06,250
are putting things in a box and see how

00:20:59,930 --> 00:21:10,070
we can transform so I have a box that

00:21:06,250 --> 00:21:13,850
might contain an A and I have a function

00:21:10,070 --> 00:21:15,740
to transform a name to a B so if you

00:21:13,850 --> 00:21:18,560
give me a box that actually contains

00:21:15,740 --> 00:21:21,170
something well then it's fine I'll just

00:21:18,560 --> 00:21:25,700
look inside and take the value and apply

00:21:21,170 --> 00:21:27,370
the function and if the box is empty and

00:21:25,700 --> 00:21:30,020
sorry bro

00:21:27,370 --> 00:21:33,080
nothing I can do I can multiply the

00:21:30,020 --> 00:21:39,470
function so this is the implementation

00:21:33,080 --> 00:21:41,990
of functor for our type maybe okay you

00:21:39,470 --> 00:21:45,590
know and with the reasoning of these

00:21:41,990 --> 00:21:48,490
boxes we can do a lot of things so this

00:21:45,590 --> 00:21:51,200
is another thing that we can do so

00:21:48,490 --> 00:21:54,200
suppose we have this situation where we

00:21:51,200 --> 00:21:56,660
have two boxes one contains a value a

00:21:54,200 --> 00:21:59,780
and another one contains a function

00:21:56,660 --> 00:22:03,560
right these boxes can contain whatever

00:21:59,780 --> 00:22:06,320
we want we kind of have the intuition

00:22:03,560 --> 00:22:11,320
that it would be possible to given these

00:22:06,320 --> 00:22:15,470
two boxes produce a box B

00:22:11,320 --> 00:22:19,850
but all we can do at this moment is

00:22:15,470 --> 00:22:22,580
transform the content of a box without

00:22:19,850 --> 00:22:28,100
actually combining different boxes

00:22:22,580 --> 00:22:30,799
together so we need to add something

00:22:28,100 --> 00:22:34,070
more because map is not enough anymore

00:22:30,799 --> 00:22:35,799
and this idea of having different boxes

00:22:34,070 --> 00:22:40,610
that are completely independent and

00:22:35,799 --> 00:22:46,429
needs to be put together mathematicians

00:22:40,610 --> 00:22:50,330
come call a applicative they have a few

00:22:46,429 --> 00:22:52,220
more rules about it but the key three

00:22:50,330 --> 00:22:56,200
amigas identity composition

00:22:52,220 --> 00:22:58,850
associativity is still there so again

00:22:56,200 --> 00:23:01,429
you can write a test and the test will

00:22:58,850 --> 00:23:06,049
make sure that your implementation makes

00:23:01,429 --> 00:23:07,940
your mathematician friend happy and what

00:23:06,049 --> 00:23:09,289
we are trying to do here is that we have

00:23:07,940 --> 00:23:14,230
two boxes that are completely

00:23:09,289 --> 00:23:16,820
independent and we want to look inside

00:23:14,230 --> 00:23:25,490
combine them together and put them in

00:23:16,820 --> 00:23:29,149
your box okay how do we do that again

00:23:25,490 --> 00:23:30,799
really boring type to us so we need to

00:23:29,149 --> 00:23:33,440
look inside the box

00:23:30,799 --> 00:23:38,389
right so it means there needs to be a

00:23:33,440 --> 00:23:41,419
factor we need them up but we need two

00:23:38,389 --> 00:23:44,330
new operations we need pure that is the

00:23:41,419 --> 00:23:48,230
idea of I have a value let me put it in

00:23:44,330 --> 00:23:53,059
a box and we have this new function then

00:23:48,230 --> 00:23:55,509
we call it ap there is the idea that if

00:23:53,059 --> 00:23:59,480
I have two boxes that are independent I

00:23:55,509 --> 00:24:01,850
need to combine them together if you

00:23:59,480 --> 00:24:04,480
want to call yourself a negative you

00:24:01,850 --> 00:24:08,149
need to tell me how to do that

00:24:04,480 --> 00:24:09,919
so people get confused usually at this

00:24:08,149 --> 00:24:12,470
point because they cannot think of an

00:24:09,919 --> 00:24:16,999
example for applicative let me give you

00:24:12,470 --> 00:24:19,340
one let's suppose you have two

00:24:16,999 --> 00:24:22,119
completely independent processes there

00:24:19,340 --> 00:24:24,920
are futures that are fetching some data

00:24:22,119 --> 00:24:27,470
from two separate databases

00:24:24,920 --> 00:24:29,360
because they are independent they want

00:24:27,470 --> 00:24:32,870
to run in parallel because you want to

00:24:29,360 --> 00:24:35,480
optimize things so after these futures

00:24:32,870 --> 00:24:39,620
have been run in parallel you want to

00:24:35,480 --> 00:24:41,590
put them together in one result okay so

00:24:39,620 --> 00:24:45,170
this is the idea of applicative you have

00:24:41,590 --> 00:24:50,420
independent effects that wants to be put

00:24:45,170 --> 00:24:55,070
together and yeah that's pretty much it

00:24:50,420 --> 00:24:57,260
but life is not that simple

00:24:55,070 --> 00:25:00,590
so usually functions don't really have

00:24:57,260 --> 00:25:02,780
only one parameter so it might happen

00:25:00,590 --> 00:25:06,080
that instead of having just two boxes

00:25:02,780 --> 00:25:07,670
you have free because maybe the function

00:25:06,080 --> 00:25:08,900
that combines everything together it

00:25:07,670 --> 00:25:11,840
needs two parameters

00:25:08,900 --> 00:25:17,630
it could be free it could before it

00:25:11,840 --> 00:25:22,130
could be five so in Scala we do this in

00:25:17,630 --> 00:25:26,390
this way that is we define a p2 maybe

00:25:22,130 --> 00:25:31,750
three maybe four maybe five maybe six up

00:25:26,390 --> 00:25:37,040
to twenty-two this is not ideal yeah

00:25:31,750 --> 00:25:38,780
apparently that's the way it is so we

00:25:37,040 --> 00:25:41,750
are now ready to implement applicative

00:25:38,780 --> 00:25:45,070
for our type maybe so again maybe is

00:25:41,750 --> 00:25:49,910
just a special option where you have

00:25:45,070 --> 00:25:52,400
just a value or you have empty and what

00:25:49,910 --> 00:25:58,000
we said before is that we have two boxes

00:25:52,400 --> 00:26:04,100
and we want to combine them together so

00:25:58,000 --> 00:26:06,260
if both my boxes contain a value then

00:26:04,100 --> 00:26:08,720
it's great I can just you know take the

00:26:06,260 --> 00:26:10,130
values that I found inside combine them

00:26:08,720 --> 00:26:14,450
together and then put them in a

00:26:10,130 --> 00:26:17,930
container if one of these two boxes is

00:26:14,450 --> 00:26:19,640
empty sorry bro

00:26:17,930 --> 00:26:23,150
there's nothing I can do I cannot apply

00:26:19,640 --> 00:26:26,390
the function if both they are empty is

00:26:23,150 --> 00:26:29,450
the same so this is basically a really

00:26:26,390 --> 00:26:34,360
simple implementation of an applicative

00:26:29,450 --> 00:26:38,149
for maybe okay everybody with me so far

00:26:34,360 --> 00:26:41,539
yes awesome and now the funny bit

00:26:38,149 --> 00:26:45,859
okay so what happens is you know we we

00:26:41,539 --> 00:26:50,959
have this box and we map and why we map

00:26:45,859 --> 00:26:55,369
something we produce another box so what

00:26:50,959 --> 00:26:58,459
happens is that we have a box in box so

00:26:55,369 --> 00:27:01,159
so far what we have learned is that we

00:26:58,459 --> 00:27:02,929
have a functor so if we have a functor

00:27:01,159 --> 00:27:06,079
we can look inside and transform the

00:27:02,929 --> 00:27:09,799
content it's not quite what we want to

00:27:06,079 --> 00:27:13,579
do now and if it's an applicative i can

00:27:09,799 --> 00:27:15,259
combine two independent boxes into one

00:27:13,579 --> 00:27:18,469
but these are not independent there are

00:27:15,259 --> 00:27:22,099
one inside the other so now we have a

00:27:18,469 --> 00:27:24,039
new challenge there is I want something

00:27:22,099 --> 00:27:28,309
special they're given a box of a box

00:27:24,039 --> 00:27:34,849
gives me a box okay

00:27:28,309 --> 00:27:37,609
and believe it or not this is the idea

00:27:34,849 --> 00:27:39,559
of Monat so it's just you know funk

00:27:37,609 --> 00:27:43,459
director is able to squeeze boxes

00:27:39,559 --> 00:27:51,679
together and if you are a mathematician

00:27:43,459 --> 00:27:55,639
I'm sorry no burritos just squashing box

00:27:51,679 --> 00:27:58,959
together and again we have lots of rules

00:27:55,639 --> 00:28:02,539
but it is that we are still in the

00:27:58,959 --> 00:28:04,789
category context so we have the three

00:28:02,539 --> 00:28:08,809
amigas identity composition

00:28:04,789 --> 00:28:11,359
associativity and again it's possible to

00:28:08,809 --> 00:28:13,429
write tasks that will make sure that our

00:28:11,359 --> 00:28:20,599
mathematician friend is happy about our

00:28:13,429 --> 00:28:25,219
implementation okay so um how do we do

00:28:20,599 --> 00:28:28,779
this again it's it's type toss so we

00:28:25,219 --> 00:28:31,399
said before that we need to have a map

00:28:28,779 --> 00:28:35,619
because we need to look inside the box

00:28:31,399 --> 00:28:40,099
right so we need to extend the functor

00:28:35,619 --> 00:28:42,559
but then we need this this function

00:28:40,099 --> 00:28:45,319
there is weird because if you give me a

00:28:42,559 --> 00:28:47,689
box of a box of a then I'm gonna return

00:28:45,319 --> 00:28:50,299
you just the box of ice just squeezing

00:28:47,689 --> 00:28:52,720
things together and we call it flatten

00:28:50,299 --> 00:28:56,059
in Scala

00:28:52,720 --> 00:28:58,759
turns out that the operation of mapping

00:28:56,059 --> 00:29:01,879
and then fluttering things it's so

00:28:58,759 --> 00:29:09,679
common that there is an alias that is

00:29:01,879 --> 00:29:13,179
called flat map okay okay but why why do

00:29:09,679 --> 00:29:18,320
we care right this is why we care

00:29:13,179 --> 00:29:23,330
so using map what we are doing is

00:29:18,320 --> 00:29:26,629
that we have a box of a and then we can

00:29:23,330 --> 00:29:30,109
use flat map and by using sub map we can

00:29:26,629 --> 00:29:33,349
produce a box of B and using pop-on

00:29:30,109 --> 00:29:36,309
again we can have a box of C and using

00:29:33,349 --> 00:29:39,259
flat map again we can get a box of D

00:29:36,309 --> 00:29:42,109
what we are saying here is that we don't

00:29:39,259 --> 00:29:45,409
have effects there are independent

00:29:42,109 --> 00:29:48,019
anymore they are all dependent to each

00:29:45,409 --> 00:29:51,440
other so we know that in order to go

00:29:48,019 --> 00:29:55,549
from A to D all we have to do is that we

00:29:51,440 --> 00:30:00,049
have to go start from a then go to B

00:29:55,549 --> 00:30:04,070
then go to C then go to D so our effects

00:30:00,049 --> 00:30:06,229
are not independent they are strictly

00:30:04,070 --> 00:30:09,739
correlated and there is d there is a

00:30:06,229 --> 00:30:12,229
clear chain of actions and hopefully by

00:30:09,739 --> 00:30:15,049
now you have recognized this pattern

00:30:12,229 --> 00:30:18,440
turns out that the full convention that

00:30:15,049 --> 00:30:22,190
we all love is exactly that it's just

00:30:18,440 --> 00:30:25,700
syntactic sugar for exactly sub mapping

00:30:22,190 --> 00:30:28,190
and mapping so we we do this all the

00:30:25,700 --> 00:30:30,470
time they don't tell us that you can do

00:30:28,190 --> 00:30:33,259
that because it's a Monat it's a monadic

00:30:30,470 --> 00:30:34,609
for loop but we do that right it's one

00:30:33,259 --> 00:30:40,249
of the first things that we learn in

00:30:34,609 --> 00:30:45,049
Scala um but turns out that if you are

00:30:40,249 --> 00:30:49,669
willing to adopt your implementation a

00:30:45,049 --> 00:30:52,429
little bit instead of having a monad has

00:30:49,669 --> 00:30:55,519
a functor you could have monent with

00:30:52,429 --> 00:30:57,590
super powers and super powers in this

00:30:55,519 --> 00:31:00,259
case is a moaner there is also an

00:30:57,590 --> 00:31:02,629
applicative what i mean with that is

00:31:00,259 --> 00:31:05,900
there instead of implementing map and

00:31:02,629 --> 00:31:11,030
flatten if you just implement

00:31:05,900 --> 00:31:13,190
it's pure and flatmap your Mon art will

00:31:11,030 --> 00:31:15,500
be an applicative what it means is that

00:31:13,190 --> 00:31:19,610
your implementation or only will be able

00:31:15,500 --> 00:31:22,610
to handle effects there are dependent

00:31:19,610 --> 00:31:26,170
from each other but you will also be

00:31:22,610 --> 00:31:31,700
able to handle event effects there are

00:31:26,170 --> 00:31:35,660
independent from each other this is just

00:31:31,700 --> 00:31:39,020
an implementation detail but it's is

00:31:35,660 --> 00:31:44,390
extremely powerful in practice sir if we

00:31:39,020 --> 00:31:47,930
try to implement the idea of an instance

00:31:44,390 --> 00:31:49,820
of Menard for maybe what we have as we

00:31:47,930 --> 00:31:55,670
said we have two functions to implement

00:31:49,820 --> 00:31:59,690
a flat map in pure pure is just type

00:31:55,670 --> 00:32:03,740
constructors so you just take the value

00:31:59,690 --> 00:32:06,170
and then you just say just away or lazy

00:32:03,740 --> 00:32:07,460
people just reuse the implementation

00:32:06,170 --> 00:32:11,990
that we have done a couple of slides

00:32:07,460 --> 00:32:20,240
before and for what regards sup map

00:32:11,990 --> 00:32:30,010
flatmap takes a box of a and a function

00:32:20,240 --> 00:32:34,490
that from a returns me a box of B so if

00:32:30,010 --> 00:32:36,530
the box that I have contains a value

00:32:34,490 --> 00:32:38,180
well this grade I'm just gonna look

00:32:36,530 --> 00:32:40,940
inside and apply to the function and

00:32:38,180 --> 00:32:44,210
that's it I'm gonna Dana maybe of be

00:32:40,940 --> 00:32:46,970
awesome and if I actually don't have a

00:32:44,210 --> 00:32:50,410
value sorry bro I can't really apply the

00:32:46,970 --> 00:32:53,690
function so it just returned empty okay

00:32:50,410 --> 00:32:56,660
so congratulations you guys just

00:32:53,690 --> 00:33:01,300
implemented an instance of a moment for

00:32:56,660 --> 00:33:07,700
the e type option only it's called maybe

00:33:01,300 --> 00:33:10,040
almost there I'm gonna try to give you

00:33:07,700 --> 00:33:11,690
guys an intuition or the sentence that

00:33:10,040 --> 00:33:17,530
it literally took me two years to

00:33:11,690 --> 00:33:19,910
understand I'm gonna hopefully you know

00:33:17,530 --> 00:33:23,960
we we will succeed

00:33:19,910 --> 00:33:25,730
in explaining it under five minutes so

00:33:23,960 --> 00:33:29,480
this light is just because

00:33:25,730 --> 00:33:31,610
mathematicians are really precise when

00:33:29,480 --> 00:33:36,050
we work with categories has developers

00:33:31,610 --> 00:33:39,050
we only move types two types and

00:33:36,050 --> 00:33:42,010
functions two functions but it turns out

00:33:39,050 --> 00:33:46,130
that there are two types of functors

00:33:42,010 --> 00:33:47,570
functors that can map one category into

00:33:46,130 --> 00:33:49,970
another category and then there are

00:33:47,570 --> 00:33:52,880
functors that are called endo factors

00:33:49,970 --> 00:33:55,700
that map-reading the same category so

00:33:52,880 --> 00:33:58,090
has developers because we never go

00:33:55,700 --> 00:34:00,680
outside the scope of types and functions

00:33:58,090 --> 00:34:04,490
every funk to the we work with is

00:34:00,680 --> 00:34:07,160
actually an endo functor and now the

00:34:04,490 --> 00:34:07,850
queen of all the sentences do you guys

00:34:07,160 --> 00:34:13,790
ready

00:34:07,850 --> 00:34:17,810
a Monat is aman wait in the category of

00:34:13,790 --> 00:34:23,270
endo functors so who has ever heard that

00:34:17,810 --> 00:34:25,940
one okay everybody okay no panic no

00:34:23,270 --> 00:34:31,790
panic we have five minutes we can do

00:34:25,940 --> 00:34:35,780
this okay so I have highlighted two

00:34:31,790 --> 00:34:38,480
words in that sentence one small rate

00:34:35,780 --> 00:34:41,720
and the other one is endo functors if

00:34:38,480 --> 00:34:44,210
you are scared it's fine just read

00:34:41,720 --> 00:34:46,070
functors and it will be fine because we

00:34:44,210 --> 00:34:50,169
have a much simpler life than

00:34:46,070 --> 00:34:54,050
mathematicians day but what we said

00:34:50,169 --> 00:34:56,830
let's focus on those two words so we

00:34:54,050 --> 00:34:59,810
said the mono it is this idea of

00:34:56,830 --> 00:35:02,240
squashing things together so given two

00:34:59,810 --> 00:35:05,420
instances of my type I'm gonna compose

00:35:02,240 --> 00:35:09,470
them together and get a new time and in

00:35:05,420 --> 00:35:14,240
a way mano it is just the pure function

00:35:09,470 --> 00:35:17,150
that is the identity era and the

00:35:14,240 --> 00:35:20,440
composition is the idea of squishing

00:35:17,150 --> 00:35:24,260
wings together and that is just mono it

00:35:20,440 --> 00:35:25,880
so if you look at pure plus fatten you

00:35:24,260 --> 00:35:28,780
basically have the definition of Monnett

00:35:25,880 --> 00:35:30,020
and and the factors we spoke about

00:35:28,780 --> 00:35:32,690
functors

00:35:30,020 --> 00:35:33,560
they are identified just by one function

00:35:32,690 --> 00:35:37,430
and this is the MA

00:35:33,560 --> 00:35:40,420
functions and when we implement a moment

00:35:37,430 --> 00:35:43,970
we do have to define the map function

00:35:40,420 --> 00:35:48,470
okay so if you are a mathematician you

00:35:43,970 --> 00:35:51,860
are probably gonna talk to me later in a

00:35:48,470 --> 00:35:55,310
really angry tone so this is just an

00:35:51,860 --> 00:35:57,530
intuition of why that sentence everybody

00:35:55,310 --> 00:36:01,400
likes to say I even don't nobody

00:35:57,530 --> 00:36:04,970
understand it so wrapping up we have

00:36:01,400 --> 00:36:07,210
seen a lot of things hopefully you know

00:36:04,970 --> 00:36:09,560
things a little bit clearer than before

00:36:07,210 --> 00:36:12,260
this is a summary of all the things that

00:36:09,560 --> 00:36:13,970
we have seen category theory it's a

00:36:12,260 --> 00:36:16,820
field in mathematics that don't care

00:36:13,970 --> 00:36:20,420
about what we are composing but how we

00:36:16,820 --> 00:36:24,470
are composing things mano it is this

00:36:20,420 --> 00:36:27,110
idea of having two types two instances

00:36:24,470 --> 00:36:29,570
of a type that we combine together we

00:36:27,110 --> 00:36:31,850
squish together to get a new type we use

00:36:29,570 --> 00:36:33,950
your old design think for example when

00:36:31,850 --> 00:36:37,460
you have a list of objects and you want

00:36:33,950 --> 00:36:40,370
to sum them all together to get you know

00:36:37,460 --> 00:36:43,820
one representative object of this list

00:36:40,370 --> 00:36:47,750
we have factored that for Scala people

00:36:43,820 --> 00:36:50,210
is basically has a map function where we

00:36:47,750 --> 00:36:53,150
have this concept of we have some

00:36:50,210 --> 00:36:58,820
metadata around my data and they want to

00:36:53,150 --> 00:37:01,220
act on the context of my metadata we

00:36:58,820 --> 00:37:03,410
have applicative there is the idea of

00:37:01,220 --> 00:37:05,930
having values that are completely

00:37:03,410 --> 00:37:09,410
independent there needs to be combined

00:37:05,930 --> 00:37:12,320
together and the idea of Mona that is I

00:37:09,410 --> 00:37:16,220
have to do operations in sequence and

00:37:12,320 --> 00:37:17,330
they need to stay in the same context in

00:37:16,220 --> 00:37:23,990
the same metadata

00:37:17,330 --> 00:37:27,500
okay cool so turns out the world

00:37:23,990 --> 00:37:33,110
scratched the service did the surface

00:37:27,500 --> 00:37:36,980
sorry this has been made from Rob Norris

00:37:33,110 --> 00:37:40,580
link at the end is a mapping of all the

00:37:36,980 --> 00:37:43,760
side classes that we have in cats so we

00:37:40,580 --> 00:37:46,280
barely cover four of them so these are

00:37:43,760 --> 00:37:48,200
all the ones that we still need to

00:37:46,280 --> 00:37:51,430
understand

00:37:48,200 --> 00:37:51,430
it's gonna be fine

00:37:51,670 --> 00:37:57,620
but if you guys fell asleep it's fine um

00:37:55,370 --> 00:38:00,440
the only thing that I would like to

00:37:57,620 --> 00:38:04,670
remember from this talk is that we can

00:38:00,440 --> 00:38:06,890
learn a lot from other fields we can

00:38:04,670 --> 00:38:08,180
there is always something that we can

00:38:06,890 --> 00:38:11,060
learn from each other

00:38:08,180 --> 00:38:13,520
and in this case what we have learned is

00:38:11,060 --> 00:38:16,400
that doesn't matter what we are

00:38:13,520 --> 00:38:19,490
composing it doesn't matter about the

00:38:16,400 --> 00:38:21,650
details just focus on how you are gonna

00:38:19,490 --> 00:38:22,480
put things together and everything is

00:38:21,650 --> 00:38:26,390
gonna be fine

00:38:22,480 --> 00:38:30,110
so this took was the result of myself

00:38:26,390 --> 00:38:32,960
going back and study a little bit so um

00:38:30,110 --> 00:38:34,760
these are my favorite sources on

00:38:32,960 --> 00:38:36,800
category theory so if I manage to get

00:38:34,760 --> 00:38:41,120
you excited about category theory yes

00:38:36,800 --> 00:38:43,430
welcome on board these are a few links

00:38:41,120 --> 00:38:47,090
the first one it's a really nice

00:38:43,430 --> 00:38:49,880
presentation from Phillip where it talks

00:38:47,090 --> 00:38:52,820
about category theory for the working

00:38:49,880 --> 00:38:56,690
hacker it gives an overview on the

00:38:52,820 --> 00:39:00,850
basics of category theory then there are

00:38:56,690 --> 00:39:04,490
a series of video from bartosh online

00:39:00,850 --> 00:39:08,120
around category theory principles it

00:39:04,490 --> 00:39:12,650
goes quite alluring to details but

00:39:08,120 --> 00:39:14,060
they're really worth it the image that I

00:39:12,650 --> 00:39:19,070
show you before we though the type

00:39:14,060 --> 00:39:23,510
classes from cats there's the link is

00:39:19,070 --> 00:39:25,970
from Rob Norris thank you rob and the

00:39:23,510 --> 00:39:33,620
place where I started all of this was

00:39:25,970 --> 00:39:35,300
actually the cast documentation the the

00:39:33,620 --> 00:39:38,800
problem that I had initially is that I

00:39:35,300 --> 00:39:42,410
was struggling to see the practical

00:39:38,800 --> 00:39:44,180
usage of all this crazy theory because

00:39:42,410 --> 00:39:47,330
documentation is a great place for you

00:39:44,180 --> 00:39:49,310
to start because they will start with

00:39:47,330 --> 00:39:53,480
practical example and they will show you

00:39:49,310 --> 00:39:57,740
why it's useful to have to use libraries

00:39:53,480 --> 00:39:59,369
like cats that implement category theory

00:39:57,740 --> 00:40:02,039
principles

00:39:59,369 --> 00:40:05,329
that was me I'm gonna publish this light

00:40:02,039 --> 00:40:08,569
online so don't worry links are not lost

00:40:05,329 --> 00:40:13,039
gonna publish them on my Twitter handle

00:40:08,569 --> 00:40:17,190
if you I want I also write a block and

00:40:13,039 --> 00:40:19,609
make sure to check the code so are there

00:40:17,190 --> 00:40:19,609
any questions

00:40:20,370 --> 00:40:26,050
[Applause]

00:40:27,290 --> 00:40:43,750
I don't bite no mathematicians who want

00:40:36,320 --> 00:40:50,960
to comment on the talk get one yeah

00:40:43,750 --> 00:40:53,660
mathematician or not I think there's one

00:40:50,960 --> 00:40:55,790
aspect of category theory and

00:40:53,660 --> 00:40:57,650
mathematics that's very hard to grep and

00:40:55,790 --> 00:41:00,260
that we unfortunately don't have to deal

00:40:57,650 --> 00:41:01,490
with and that is category theory you

00:41:00,260 --> 00:41:03,710
deal with something that is more

00:41:01,490 --> 00:41:06,500
infinite than you can put into any set

00:41:03,710 --> 00:41:09,470
and you can create really sets of sets

00:41:06,500 --> 00:41:11,900
and whatever really incredibly infinite

00:41:09,470 --> 00:41:14,000
things and categories can still grab all

00:41:11,900 --> 00:41:16,400
of this and here we deal with things

00:41:14,000 --> 00:41:18,710
that are inherently finite because we

00:41:16,400 --> 00:41:20,990
don't have infinite computers and that

00:41:18,710 --> 00:41:23,660
makes it a lot easier yes I absolutely

00:41:20,990 --> 00:41:26,180
agree I mean mathematic mathematicians

00:41:23,660 --> 00:41:29,120
have to think about what if my setting

00:41:26,180 --> 00:41:32,090
is infinite and I have to compute all

00:41:29,120 --> 00:41:33,740
the numbers that I can think of but we

00:41:32,090 --> 00:41:36,560
worked on computers we don't have the

00:41:33,740 --> 00:41:38,450
problem right Stack Overflow forever so

00:41:36,560 --> 00:41:40,790
at some point we will in finished

00:41:38,450 --> 00:41:42,380
numbers so yes you are absolutely right

00:41:40,790 --> 00:41:45,430
things are a lot easier for us and

00:41:42,380 --> 00:41:45,430

YouTube URL: https://www.youtube.com/watch?v=GWDyIV7Oxyc


