Title: Starting from Scratch with Scala Native by Richard Whaling
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6923-starting-from-scratch-with-scala-native.html
Captions: 
	00:00:04,790 --> 00:00:09,629
starting from scratch with Scala native

00:00:07,100 --> 00:00:10,830
so this is a talk about Scala native if

00:00:09,629 --> 00:00:13,260
that's what you came for you're in the

00:00:10,830 --> 00:00:15,330
right room it's also just a sort of an

00:00:13,260 --> 00:00:16,890
introductory talk on systems programming

00:00:15,330 --> 00:00:19,109
in general and how to do systems

00:00:16,890 --> 00:00:21,119
programming in Scala maybe even an

00:00:19,109 --> 00:00:22,769
argument pedagogically for teaching

00:00:21,119 --> 00:00:24,749
people how to do systems programming in

00:00:22,769 --> 00:00:26,730
Scala because if you really want to go

00:00:24,749 --> 00:00:28,829
under the hood you have to have to learn

00:00:26,730 --> 00:00:31,109
what your computer actually does at the

00:00:28,829 --> 00:00:32,910
hardware level right more conceptually

00:00:31,109 --> 00:00:34,860
I'd say it's also just to talk about

00:00:32,910 --> 00:00:36,660
working with emerging technology right

00:00:34,860 --> 00:00:39,690
about improvised solutions to real-world

00:00:36,660 --> 00:00:41,670
problems and about really relying on

00:00:39,690 --> 00:00:43,830
your your operating system itself as a

00:00:41,670 --> 00:00:46,440
platform rather than like frameworks or

00:00:43,830 --> 00:00:49,710
like more elaborate virtual machines and

00:00:46,440 --> 00:00:51,720
runtimes dot dot dot this is talk about

00:00:49,710 --> 00:00:55,350
how to get things done without the JVM

00:00:51,720 --> 00:00:57,630
that we've come to know and or love so

00:00:55,350 --> 00:01:00,120
what's the concrete non hand-wavy

00:00:57,630 --> 00:01:01,920
portion of the talk it's gonna be a

00:01:00,120 --> 00:01:03,660
crash course in Scala native and just

00:01:01,920 --> 00:01:05,640
like systems programming we're gonna

00:01:03,660 --> 00:01:07,320
learn some pointer arithmetic and then

00:01:05,640 --> 00:01:08,969
we're gonna dive deep into some actual

00:01:07,320 --> 00:01:10,890
exercises because the only way you

00:01:08,969 --> 00:01:12,990
really learn to do this is by actually

00:01:10,890 --> 00:01:14,549
writing programs we're gonna use the

00:01:12,990 --> 00:01:17,579
Google engrams data set have people

00:01:14,549 --> 00:01:20,189
heard of that it's a nice big flat file

00:01:17,579 --> 00:01:22,560
like medium data couple couple gigabytes

00:01:20,189 --> 00:01:24,240
we're gonna implement like three sort of

00:01:22,560 --> 00:01:26,939
simple algorithms on it both in like a

00:01:24,240 --> 00:01:29,909
naive JVM Scala way and then also in a

00:01:26,939 --> 00:01:31,140
Scala native way and because I try to be

00:01:29,909 --> 00:01:34,590
empirical we're gonna have like

00:01:31,140 --> 00:01:36,869
performance numbers because I like I

00:01:34,590 --> 00:01:38,759
like data and then after that that

00:01:36,869 --> 00:01:40,380
concludes the empirical portion of the

00:01:38,759 --> 00:01:44,069
talk then I'll wave my hands and make

00:01:40,380 --> 00:01:45,719
some crazy generalizations about me so I

00:01:44,069 --> 00:01:47,340
am a Scala native contributor I

00:01:45,719 --> 00:01:48,990
contributed to the two and three

00:01:47,340 --> 00:01:51,740
releases but I'm not in the core dev

00:01:48,990 --> 00:01:55,380
team I'm speaking only for myself here

00:01:51,740 --> 00:01:57,149
the yeah like like we were saying in the

00:01:55,380 --> 00:01:59,670
introduction I am working on a book on

00:01:57,149 --> 00:02:02,159
Scala native for a pragmatic it's called

00:01:59,670 --> 00:02:03,329
modern systems programming in Scala I'm

00:02:02,159 --> 00:02:06,149
hoping to be able to announce an

00:02:03,329 --> 00:02:08,640
official like release date and like

00:02:06,149 --> 00:02:11,280
start doing early access online releases

00:02:08,640 --> 00:02:12,569
in the near future so definitely look me

00:02:11,280 --> 00:02:14,489
up on Twitter if you want to find out

00:02:12,569 --> 00:02:16,260
more about that I'm a software engineer

00:02:14,489 --> 00:02:18,510
at m1 Finance

00:02:16,260 --> 00:02:21,420
finance financial services startup in

00:02:18,510 --> 00:02:24,870
Chicago we run spark

00:02:21,420 --> 00:02:27,720
acha stuff like that everyday for a sort

00:02:24,870 --> 00:02:31,110
of a high-throughput trading platform

00:02:27,720 --> 00:02:33,269
and on Twitter I'm at Richard Whalen if

00:02:31,110 --> 00:02:35,370
I just tweeted out the slides I tweeted

00:02:33,269 --> 00:02:36,810
out my notebooks with the data and I

00:02:35,370 --> 00:02:39,090
tweeted out the talk I gave Anse

00:02:36,810 --> 00:02:40,500
colonnaded strange loop last year which

00:02:39,090 --> 00:02:42,090
was about network programming and

00:02:40,500 --> 00:02:43,769
building a web server and Scala native

00:02:42,090 --> 00:02:46,049
so that yeah that's all on my Twitter

00:02:43,769 --> 00:02:46,680
stream but with that being said let's

00:02:46,049 --> 00:02:50,519
get started

00:02:46,680 --> 00:02:52,319
so what's Scala native right first of

00:02:50,519 --> 00:02:54,090
all Scala native is Scala it's not a new

00:02:52,319 --> 00:02:56,549
programming language it's the regular

00:02:54,090 --> 00:02:58,950
Scala that we all write in particular

00:02:56,549 --> 00:03:01,980
it's a it's a scala c plugin right and

00:02:58,950 --> 00:03:03,840
an SBT plug-in that drives it and what

00:03:01,980 --> 00:03:06,030
that Scala C plugin gives you is

00:03:03,840 --> 00:03:08,879
efficiently effectively a an alternative

00:03:06,030 --> 00:03:11,370
back end for the Scala compiler such

00:03:08,879 --> 00:03:16,319
that instead of emitting JVM bytecode it

00:03:11,370 --> 00:03:20,970
emits LLVM byte code LLVM right is the

00:03:16,319 --> 00:03:24,239
the system level linker used in Mac OS

00:03:20,970 --> 00:03:26,700
used by Russ to used and clang a really

00:03:24,239 --> 00:03:28,500
great even though it says LLVM in the

00:03:26,700 --> 00:03:30,750
name of it it's really just a machine

00:03:28,500 --> 00:03:34,019
code compiler back-end it allows us to

00:03:30,750 --> 00:03:36,209
get a true native binary ahead of time

00:03:34,019 --> 00:03:37,500
compilation with our Scala code with all

00:03:36,209 --> 00:03:41,220
the benefits that come with that like

00:03:37,500 --> 00:03:43,829
low overhead tiny reproducible portable

00:03:41,220 --> 00:03:45,810
binary packages and quick startup time

00:03:43,829 --> 00:03:47,489
that makes it great for command-line

00:03:45,810 --> 00:03:49,709
tools and that's most of what people

00:03:47,489 --> 00:03:51,329
have been using it for so far like

00:03:49,709 --> 00:03:53,280
people have demoed like Scala see

00:03:51,329 --> 00:03:54,900
running in Scala native for example and

00:03:53,280 --> 00:03:57,090
things like Scala format which is really

00:03:54,900 --> 00:04:00,359
cool and it's progressing rapidly with

00:03:57,090 --> 00:04:01,859
like library support also but that's not

00:04:00,359 --> 00:04:05,609
always easy because you don't actually

00:04:01,859 --> 00:04:09,389
have a JVM right it's not there is no

00:04:05,609 --> 00:04:10,950
JVM the way it gets anything done is

00:04:09,389 --> 00:04:13,560
that Scala native does include

00:04:10,950 --> 00:04:17,070
implementations of many of the most

00:04:13,560 --> 00:04:18,599
commonly used JDK classes but what it's

00:04:17,070 --> 00:04:20,370
actually doing is that those are like

00:04:18,599 --> 00:04:23,400
stub implementations that are just

00:04:20,370 --> 00:04:26,190
invoking C functions provided by the

00:04:23,400 --> 00:04:28,569
ANSI C standard library or the operating

00:04:26,190 --> 00:04:30,699
system under the hood

00:04:28,569 --> 00:04:33,220
and what makes this possible is that

00:04:30,699 --> 00:04:35,879
Scala native provides these incredibly

00:04:33,220 --> 00:04:41,069
robust and expressive types and

00:04:35,879 --> 00:04:44,319
operators for effectively a Scala DSL 4c

00:04:41,069 --> 00:04:45,759
which once once you you get the sense of

00:04:44,319 --> 00:04:48,190
what that can do it's incredibly

00:04:45,759 --> 00:04:49,870
powerful and exciting and that's what

00:04:48,190 --> 00:04:51,639
this talk is about it's not just about

00:04:49,870 --> 00:04:53,560
how to compile your existing programs

00:04:51,639 --> 00:04:55,569
with a different plugin it's about how

00:04:53,560 --> 00:04:58,870
to write programs designed for Scala

00:04:55,569 --> 00:05:02,409
native that perform like a C program and

00:04:58,870 --> 00:05:04,900
how what a sort of mind shift that is so

00:05:02,409 --> 00:05:07,240
like to get started though like this

00:05:04,900 --> 00:05:09,970
this works right like if it's a plain

00:05:07,240 --> 00:05:12,099
vanilla command line regular Scala you

00:05:09,970 --> 00:05:14,560
add an extra line to your build is BT

00:05:12,099 --> 00:05:17,020
you add a plug-in SBT file with one line

00:05:14,560 --> 00:05:19,120
its Scala native compiles it you get a

00:05:17,020 --> 00:05:20,710
native binary like it just works I have

00:05:19,120 --> 00:05:23,319
too many slides to do live demos I

00:05:20,710 --> 00:05:26,740
promise this works but you can also do

00:05:23,319 --> 00:05:28,900
this which is not very different but

00:05:26,740 --> 00:05:30,909
there's two things one the the string

00:05:28,900 --> 00:05:32,680
literal has a C in front of it that's

00:05:30,909 --> 00:05:34,960
because it's a C style string and we'll

00:05:32,680 --> 00:05:37,030
talk a lot more than you want about how

00:05:34,960 --> 00:05:40,389
strings work and see in a second and

00:05:37,030 --> 00:05:43,270
also the function is now printf has

00:05:40,389 --> 00:05:46,330
anyone seen printf before in their

00:05:43,270 --> 00:05:50,080
programming days yeah yeah yeah this is

00:05:46,330 --> 00:05:51,909
a this this is the real G Lib C printf

00:05:50,080 --> 00:05:53,289
we're talking about here this isn't

00:05:51,909 --> 00:05:56,349
another function that happens to be

00:05:53,289 --> 00:05:59,020
named printf this is invoking the printf

00:05:56,349 --> 00:06:01,300
from Lib C it works because Scala

00:05:59,020 --> 00:06:04,060
natives types like this C string type

00:06:01,300 --> 00:06:06,460
are actually binary compatible with the

00:06:04,060 --> 00:06:08,139
the C ABI and LLVM gives you all the

00:06:06,460 --> 00:06:11,199
calling conventions and stuff basically

00:06:08,139 --> 00:06:13,090
for free right so unlike regular Scala

00:06:11,199 --> 00:06:16,360
string substitution for the people who

00:06:13,090 --> 00:06:18,789
haven't seen it the way printf format

00:06:16,360 --> 00:06:21,069
strings work is that % s is a

00:06:18,789 --> 00:06:23,650
placeholder for a string and then it

00:06:21,069 --> 00:06:24,729
takes a variable number of arguments you

00:06:23,650 --> 00:06:26,080
need to line up with a number of

00:06:24,729 --> 00:06:28,060
arguments you give it with the number of

00:06:26,080 --> 00:06:30,219
like wild cards in your format string

00:06:28,060 --> 00:06:33,729
it's kind of gross I'll talk more about

00:06:30,219 --> 00:06:35,649
how it's problematic later but you get

00:06:33,729 --> 00:06:38,199
all the good and the bad of like

00:06:35,649 --> 00:06:40,029
powerful C standard library stuff which

00:06:38,199 --> 00:06:41,320
I find really exciting because I'm a

00:06:40,029 --> 00:06:44,740
dorky you'll see how

00:06:41,320 --> 00:06:47,860
at heart so like but what what are these

00:06:44,740 --> 00:06:52,780
things right so the the idea of a C

00:06:47,860 --> 00:06:55,420
string is that it's really just a bunch

00:06:52,780 --> 00:06:57,580
of bytes one after the other one ASCII

00:06:55,420 --> 00:06:59,440
character per byte and then the the

00:06:57,580 --> 00:07:01,060
trick is that at the end there's a zero

00:06:59,440 --> 00:07:03,150
byte that marks the end of the string

00:07:01,060 --> 00:07:05,920
and it's all in contiguous memory

00:07:03,150 --> 00:07:09,250
because of that you don't actually store

00:07:05,920 --> 00:07:12,640
the length or any metadata literally the

00:07:09,250 --> 00:07:14,740
the value of the C string oddly enough

00:07:12,640 --> 00:07:16,390
is just the address of the very first

00:07:14,740 --> 00:07:17,800
character in the C string and there's a

00:07:16,390 --> 00:07:21,340
lot of weak semantic weirdness that

00:07:17,800 --> 00:07:22,510
comes from this and if you're squinting

00:07:21,340 --> 00:07:24,490
at this and thinking wait that doesn't

00:07:22,510 --> 00:07:26,200
make sense it doesn't entirely make

00:07:24,490 --> 00:07:28,690
sense and it's broken in a lot of ways

00:07:26,200 --> 00:07:30,370
but that's what C gives us and if we

00:07:28,690 --> 00:07:32,800
want to write programs that really go at

00:07:30,370 --> 00:07:36,490
like C speed we sort of have to deal

00:07:32,800 --> 00:07:38,950
with it for now so this is sort of a

00:07:36,490 --> 00:07:41,530
jumping 5 slides ahead under the hood

00:07:38,950 --> 00:07:43,870
and Scala natives like built-ins see

00:07:41,530 --> 00:07:46,090
string is just an alias for a pointer to

00:07:43,870 --> 00:07:47,500
a see car right which is the equivalent

00:07:46,090 --> 00:07:50,110
of car star for people who've seen

00:07:47,500 --> 00:07:52,000
string pointer is just a generic type in

00:07:50,110 --> 00:07:54,550
Scala native which actually makes them

00:07:52,000 --> 00:07:56,980
for me much easier to work with and much

00:07:54,550 --> 00:07:59,740
easier to teach them C's sort of opaque

00:07:56,980 --> 00:08:02,590
syntax around reference reference types

00:07:59,740 --> 00:08:05,100
and stuff like that double spoiler alert

00:08:02,590 --> 00:08:08,140
C car is actually just an alias for byte

00:08:05,100 --> 00:08:10,060
unfortunately that means it's signed I'm

00:08:08,140 --> 00:08:11,950
of the who on earth would ever want a

00:08:10,060 --> 00:08:14,470
signed byte camp but whatever we deal

00:08:11,950 --> 00:08:15,760
with it oh and the other thing is all

00:08:14,470 --> 00:08:19,540
these pointer types are going to be

00:08:15,760 --> 00:08:21,640
mutable I'm a big fan of a mutable style

00:08:19,540 --> 00:08:22,930
and a mutable everything but when you're

00:08:21,640 --> 00:08:25,120
at when you're working with the bare

00:08:22,930 --> 00:08:26,740
metal every everything is mutable all

00:08:25,120 --> 00:08:28,030
you're doing is mutating memory because

00:08:26,740 --> 00:08:31,720
that's that's how you're implementing

00:08:28,030 --> 00:08:34,210
the ability to like do computations at a

00:08:31,720 --> 00:08:36,610
low enough level so I think hard about

00:08:34,210 --> 00:08:39,610
how to how to provide like clean

00:08:36,610 --> 00:08:41,650
functional immutable facades over some

00:08:39,610 --> 00:08:43,419
of this mess I'm definitely not

00:08:41,650 --> 00:08:46,750
stylistically advocating for one thing

00:08:43,419 --> 00:08:48,190
or the other though so like with that we

00:08:46,750 --> 00:08:50,230
can write like a simple program that

00:08:48,190 --> 00:08:52,360
sort of exercises and demonstrates some

00:08:50,230 --> 00:08:52,720
of what we we and maybe learn a little

00:08:52,360 --> 00:08:55,420
more of

00:08:52,720 --> 00:08:57,700
see strings I guess the idea is we can

00:08:55,420 --> 00:09:00,010
just take a hello world string we can

00:08:57,700 --> 00:09:03,370
get its length with the string length

00:09:00,010 --> 00:09:05,380
function again C standard Lib we can ask

00:09:03,370 --> 00:09:07,540
printf to both print out the content of

00:09:05,380 --> 00:09:09,220
it and its address the percent P

00:09:07,540 --> 00:09:12,880
formatter is gonna give us the address

00:09:09,220 --> 00:09:14,800
for a pointer tell us how long it is but

00:09:12,880 --> 00:09:16,840
we're also gonna ask it to distinguish

00:09:14,800 --> 00:09:19,510
the length of the string from the size

00:09:16,840 --> 00:09:20,680
of the string value and when you print

00:09:19,510 --> 00:09:22,390
this out you'll see what I'm talking

00:09:20,680 --> 00:09:24,430
about there's a there's a there's an

00:09:22,390 --> 00:09:28,030
interesting difference here that's not

00:09:24,430 --> 00:09:30,310
always apparent for when you've spent

00:09:28,030 --> 00:09:32,350
you know 20 years working in languages

00:09:30,310 --> 00:09:33,850
like Java and Python where strings have

00:09:32,350 --> 00:09:36,130
something more like value semantics

00:09:33,850 --> 00:09:38,440
instead of reference semantics the idea

00:09:36,130 --> 00:09:40,930
is once we have the string then we can

00:09:38,440 --> 00:09:43,150
just do a for loop over the over the the

00:09:40,930 --> 00:09:45,280
length of it right to get the offset of

00:09:43,150 --> 00:09:47,620
each character and then we can just grab

00:09:45,280 --> 00:09:49,240
them like we would just any other kind

00:09:47,620 --> 00:09:51,580
of array access or because you can treat

00:09:49,240 --> 00:09:55,240
you can treat pointers basically like

00:09:51,580 --> 00:09:57,580
unsafe index sequences and then print

00:09:55,240 --> 00:09:59,440
each of the characters out and just we

00:09:57,580 --> 00:10:01,390
can look at their binary values while

00:09:59,440 --> 00:10:04,870
we're at it because hey we're we're

00:10:01,390 --> 00:10:08,500
working with bytes here right so did I

00:10:04,870 --> 00:10:10,330
get everything yeah I think this what's

00:10:08,500 --> 00:10:12,520
uh so when we run it the output looks

00:10:10,330 --> 00:10:14,350
like this and just to highlight the

00:10:12,520 --> 00:10:18,360
thing that's really interesting right is

00:10:14,350 --> 00:10:22,630
that the string itself has an address

00:10:18,360 --> 00:10:25,150
the string is offset that formatting is

00:10:22,630 --> 00:10:27,010
a little off the string is itself 12

00:10:25,150 --> 00:10:29,560
bytes long which is kind of a lie

00:10:27,010 --> 00:10:31,060
because it takes 13 bytes of storage if

00:10:29,560 --> 00:10:34,510
you count out these lines I'm printing

00:10:31,060 --> 00:10:36,520
out there's 13 1 byte bytes in the the

00:10:34,510 --> 00:10:38,650
string and that's because the string

00:10:36,520 --> 00:10:41,200
length function and C doesn't count the

00:10:38,650 --> 00:10:43,589
null terminating byte that has to be

00:10:41,200 --> 00:10:46,300
there at the end or everything breaks

00:10:43,589 --> 00:10:49,390
but the the other thing I wanted to call

00:10:46,300 --> 00:10:51,250
out is that right the actual string

00:10:49,390 --> 00:10:53,710
value the pointer value that we're

00:10:51,250 --> 00:10:55,960
working with is 8 bytes long right and

00:10:53,710 --> 00:10:58,960
that's because we're working on a 64-bit

00:10:55,960 --> 00:11:01,180
architecture size of a pointer of any

00:10:58,960 --> 00:11:02,890
pointer value to any type is exactly the

00:11:01,180 --> 00:11:05,990
size of the native machine word which is

00:11:02,890 --> 00:11:09,200
also exactly 8 bytes right

00:11:05,990 --> 00:11:10,730
and that's precisely the the address is

00:11:09,200 --> 00:11:15,860
the value that was printed here this Oh

00:11:10,730 --> 00:11:17,840
X 55 thing right so maybe from from this

00:11:15,860 --> 00:11:21,410
we can actually generalize a little more

00:11:17,840 --> 00:11:23,900
about strings and try to like take take

00:11:21,410 --> 00:11:29,090
another step back and get to a sense of

00:11:23,900 --> 00:11:30,860
how pointers work right so what we're

00:11:29,090 --> 00:11:33,110
gonna do here is we're gonna introduce

00:11:30,860 --> 00:11:35,060
the two really powerful things that

00:11:33,110 --> 00:11:37,550
Scala native gives you for working with

00:11:35,060 --> 00:11:39,680
pointers pointer address arithmetic

00:11:37,550 --> 00:11:42,020
which is horribly unsafe and an easy way

00:11:39,680 --> 00:11:45,500
to break everything and pointer address

00:11:42,020 --> 00:11:48,200
dereference which is even worse right

00:11:45,500 --> 00:11:50,180
because a see string is a pointer to a

00:11:48,200 --> 00:11:51,920
byte we can actually re-implement the

00:11:50,180 --> 00:11:53,180
array lookup we were doing before right

00:11:51,920 --> 00:11:55,910
where we were just treating it like a

00:11:53,180 --> 00:11:58,040
index sequence we can implement a

00:11:55,910 --> 00:12:00,200
constant time index sequence look up

00:11:58,040 --> 00:12:02,300
with pointer arithmetic because we have

00:12:00,200 --> 00:12:03,980
addition right we have the base address

00:12:02,300 --> 00:12:05,720
of the string and we're just adding the

00:12:03,980 --> 00:12:08,870
offset to it that gives us the address

00:12:05,720 --> 00:12:11,090
of the the imp or the if-- character of

00:12:08,870 --> 00:12:12,590
the string and then once we have the

00:12:11,090 --> 00:12:15,590
address of any character in the string

00:12:12,590 --> 00:12:17,540
we can dereference it and see the the

00:12:15,590 --> 00:12:19,970
dereference operator is star i think

00:12:17,540 --> 00:12:21,680
it's the same and let go and rest in

00:12:19,970 --> 00:12:23,960
scotland native it's the exclamation

00:12:21,680 --> 00:12:26,810
it's a prefix exclamation mark or bang

00:12:23,960 --> 00:12:28,670
operator but it does the same thing so

00:12:26,810 --> 00:12:30,350
the idea is this should print us roughly

00:12:28,670 --> 00:12:31,820
the same thing as before the only

00:12:30,350 --> 00:12:33,830
difference is because we're computing

00:12:31,820 --> 00:12:37,700
the addresses of each individual byte in

00:12:33,830 --> 00:12:40,400
the string we can print those out too

00:12:37,700 --> 00:12:42,260
which will maybe illustrate or prove

00:12:40,400 --> 00:12:46,490
what I'm claiming about how strings are

00:12:42,260 --> 00:12:49,160
laid out in memory right so we have the

00:12:46,490 --> 00:12:51,680
same string the the things that are

00:12:49,160 --> 00:12:55,030
really interesting here right is that

00:12:51,680 --> 00:12:57,050
literally the address of the string is

00:12:55,030 --> 00:12:59,510
exactly the address of the first

00:12:57,050 --> 00:13:01,580
character in the string every single

00:12:59,510 --> 00:13:05,660
byte in the string does have a unique

00:13:01,580 --> 00:13:08,030
and fixed address but what what also

00:13:05,660 --> 00:13:11,240
follows from that right is that the type

00:13:08,030 --> 00:13:13,610
system of C doesn't distinguish between

00:13:11,240 --> 00:13:16,340
a pointer to one character and a pointer

00:13:13,610 --> 00:13:19,610
to a arbitrary dynamically dynamically

00:13:16,340 --> 00:13:22,430
like sized array of characters

00:13:19,610 --> 00:13:25,339
that pointer is sort of this box of a

00:13:22,430 --> 00:13:28,339
thing or a sequence like thing or an

00:13:25,339 --> 00:13:30,500
integer like thing in a way that has

00:13:28,339 --> 00:13:33,339
historically made it really hard to

00:13:30,500 --> 00:13:36,200
teach like see and pointers right I

00:13:33,339 --> 00:13:38,120
spent like probably six weeks of my

00:13:36,200 --> 00:13:40,070
systems class in college like struggling

00:13:38,120 --> 00:13:43,160
with it and not really getting it until

00:13:40,070 --> 00:13:44,630
I wrote actual programs so if anyone's

00:13:43,160 --> 00:13:48,320
feeling like I'm throwing a lot of stuff

00:13:44,630 --> 00:13:49,880
at you really fast I am but a lot of

00:13:48,320 --> 00:13:51,350
this becomes a lot more clear once

00:13:49,880 --> 00:13:53,060
you've written some programs and get a

00:13:51,350 --> 00:13:55,519
sense of how these ideas all sort of

00:13:53,060 --> 00:13:59,779
depend on each other and form consistent

00:13:55,519 --> 00:14:01,459
like disciplines and practices so from

00:13:59,779 --> 00:14:03,980
what we like have observed about strings

00:14:01,459 --> 00:14:07,519
so far then we can just sort of make

00:14:03,980 --> 00:14:10,700
some just sort of recap some inferences

00:14:07,519 --> 00:14:12,620
about how pointers work right so in

00:14:10,700 --> 00:14:15,110
general a pointer is just the the

00:14:12,620 --> 00:14:18,320
numeric address of a byte somewhere in

00:14:15,110 --> 00:14:19,760
memory in every modern architecture the

00:14:18,320 --> 00:14:21,110
pointers are the same size is the

00:14:19,760 --> 00:14:25,279
machine word it's not like we're gonna

00:14:21,110 --> 00:14:27,230
compile code for a pdp-11 here and in

00:14:25,279 --> 00:14:29,779
general you can just treat the entire

00:14:27,230 --> 00:14:31,970
address space of your memory as just an

00:14:29,779 --> 00:14:33,529
index sequence of bytes right most of

00:14:31,970 --> 00:14:35,690
them are not valid to access because

00:14:33,529 --> 00:14:38,810
they're unmapped but it's you can think

00:14:35,690 --> 00:14:42,050
of the memory as just one giant byte

00:14:38,810 --> 00:14:44,660
array basically and as I was saying

00:14:42,050 --> 00:14:47,779
earlier the sort of the the pain point

00:14:44,660 --> 00:14:49,730
right is that there's all this sort of

00:14:47,779 --> 00:14:52,070
when you're working with like pointers

00:14:49,730 --> 00:14:54,500
to bytes you lose all this contextual

00:14:52,070 --> 00:14:56,930
information that a modern type system

00:14:54,500 --> 00:15:00,920
would capture like is this one thing is

00:14:56,930 --> 00:15:05,180
this many things do we statically know

00:15:00,920 --> 00:15:08,170
the size of these things and I mean

00:15:05,180 --> 00:15:10,220
we're getting so good at type level

00:15:08,170 --> 00:15:12,079
computation and the scala community I

00:15:10,220 --> 00:15:13,399
sort of feel like we might be able to

00:15:12,079 --> 00:15:16,490
solve a lot of these problems by

00:15:13,399 --> 00:15:20,540
building on top of what C has like given

00:15:16,490 --> 00:15:24,410
to us here but that's sort of above my

00:15:20,540 --> 00:15:26,120
level I'm a I'm a C hacker so we're

00:15:24,410 --> 00:15:28,840
gonna stay really down in the the

00:15:26,120 --> 00:15:32,680
nitty-gritty for the rest of this talk

00:15:28,840 --> 00:15:33,010
cool and point also just to like lay it

00:15:32,680 --> 00:15:35,440
out there

00:15:33,010 --> 00:15:37,150
pointer arithmetic is is totally unsafe

00:15:35,440 --> 00:15:38,830
there's no way it's gonna check if

00:15:37,150 --> 00:15:40,210
you're doing arithmetic off the end of a

00:15:38,830 --> 00:15:42,340
pointer in which case you'll either

00:15:40,210 --> 00:15:43,990
corrupt your data see data you're not

00:15:42,340 --> 00:15:47,320
supposed to or like segfault your

00:15:43,990 --> 00:15:48,910
program you do get a few help a few bits

00:15:47,320 --> 00:15:51,040
of help like if you know your pointer is

00:15:48,910 --> 00:15:53,110
typed because you can have like pointers

00:15:51,040 --> 00:15:56,230
to in Sand arrays events it'll increment

00:15:53,110 --> 00:15:58,110
by the size of the thing you're the the

00:15:56,230 --> 00:16:00,310
thing you know your containing at least

00:15:58,110 --> 00:16:04,330
and you'll see what I mean by that and

00:16:00,310 --> 00:16:06,400
like 20 slides 15 minutes from now the

00:16:04,330 --> 00:16:07,660
other cool thing that Scala native does

00:16:06,400 --> 00:16:10,750
with pointers and then we're really

00:16:07,660 --> 00:16:13,840
close to writing actual code is the way

00:16:10,750 --> 00:16:15,430
it handles stack allocation unlike see

00:16:13,840 --> 00:16:19,270
unlike Java

00:16:15,430 --> 00:16:21,130
unlike go and rust Scala native actually

00:16:19,270 --> 00:16:26,770
has an explicit operator for stack

00:16:21,130 --> 00:16:28,570
allocating variables via pointers what's

00:16:26,770 --> 00:16:30,670
really cool about this is that it allows

00:16:28,570 --> 00:16:33,280
Scala native to maintain a bright line

00:16:30,670 --> 00:16:36,250
between these sort of manually managed

00:16:33,280 --> 00:16:38,440
pointers that are unsafe and that

00:16:36,250 --> 00:16:40,960
require all these like scary pointer

00:16:38,440 --> 00:16:42,940
discipline techniques while also

00:16:40,960 --> 00:16:46,270
maintaining a sort of clean room where

00:16:42,940 --> 00:16:49,690
all the normal like garbage collected

00:16:46,270 --> 00:16:51,250
memory safe like sort of vanilla Scala

00:16:49,690 --> 00:16:54,640
stuff lives I know I've been talking

00:16:51,250 --> 00:16:56,920
about all the scary scary pointer stuff

00:16:54,640 --> 00:16:58,570
for like 15 minutes now but I do

00:16:56,920 --> 00:17:00,460
definitely want to reiterate Scala

00:16:58,570 --> 00:17:02,860
native has like a garbage collector and

00:17:00,460 --> 00:17:04,750
safety and regular semantics if you want

00:17:02,860 --> 00:17:08,320
to use it this talk is about how not to

00:17:04,750 --> 00:17:10,330
do that but what's really cool is that

00:17:08,320 --> 00:17:13,089
because we have this the stack

00:17:10,330 --> 00:17:17,110
allocation operator we can very easily

00:17:13,089 --> 00:17:19,839
and explicitly grab these sort of

00:17:17,110 --> 00:17:21,790
short-lived pointers off the stack the

00:17:19,839 --> 00:17:24,190
cool thing about it with stack

00:17:21,790 --> 00:17:27,760
allocation in particular is that there's

00:17:24,190 --> 00:17:30,690
sort of semi-automatic the actual like

00:17:27,760 --> 00:17:33,720
see call stack will maintain the

00:17:30,690 --> 00:17:36,710
the the stack pointers functions are

00:17:33,720 --> 00:17:39,479
called and returned via the C a bi right

00:17:36,710 --> 00:17:41,220
so what that basically gives you is any

00:17:39,479 --> 00:17:44,190
amount of stack allocation you want to

00:17:41,220 --> 00:17:47,190
do is a constant time just increment the

00:17:44,190 --> 00:17:48,690
the stack pointer basically so it's it's

00:17:47,190 --> 00:17:50,340
just about as fast as physically

00:17:48,690 --> 00:17:52,529
possible the only thing that's dangerous

00:17:50,340 --> 00:17:54,869
is if you accidentally return it from a

00:17:52,529 --> 00:17:56,940
function then you're gonna have a

00:17:54,869 --> 00:17:58,529
pointer into some piece of stack that's

00:17:56,940 --> 00:18:01,039
gonna get clobbered or has already been

00:17:58,529 --> 00:18:04,080
clobbered so it won't necessarily

00:18:01,039 --> 00:18:05,580
protect you from some of those errors we

00:18:04,080 --> 00:18:07,679
have a few other ways to get pointers

00:18:05,580 --> 00:18:10,080
there's heap pointers which come from

00:18:07,679 --> 00:18:12,330
malloc the famous C malloc function

00:18:10,080 --> 00:18:14,340
which we'll talk about in the next major

00:18:12,330 --> 00:18:15,840
section we also have this really cool

00:18:14,340 --> 00:18:18,869
zone allocator that I don't have slides

00:18:15,840 --> 00:18:20,759
on and I have way too much content but

00:18:18,869 --> 00:18:22,470
it's really neat and you should look up

00:18:20,759 --> 00:18:26,489
some of the material on it cuz it's

00:18:22,470 --> 00:18:28,200
actually really powerful so like all

00:18:26,489 --> 00:18:31,379
this said right this is all kind of

00:18:28,200 --> 00:18:34,529
scary power to love about as low-level

00:18:31,379 --> 00:18:37,049
as as as programming languages get right

00:18:34,529 --> 00:18:40,019
but the benefit of this is that it makes

00:18:37,049 --> 00:18:43,039
working with with C and C foreign

00:18:40,019 --> 00:18:45,330
functions really clean and really easy

00:18:43,039 --> 00:18:47,369
not only does it make the compatibility

00:18:45,330 --> 00:18:50,759
really good but it makes writing and

00:18:47,369 --> 00:18:52,470
generating the bindings really easy you

00:18:50,759 --> 00:18:54,809
don't need like special headers you can

00:18:52,470 --> 00:18:57,210
just put like an extern object like this

00:18:54,809 --> 00:18:59,009
in your application code and Scala

00:18:57,210 --> 00:19:02,190
native that's enough for Scala native to

00:18:59,009 --> 00:19:04,200
call out to C functions here I've just

00:19:02,190 --> 00:19:07,200
like written out little bindings for

00:19:04,200 --> 00:19:08,369
like part of the C standard IO header

00:19:07,200 --> 00:19:11,099
right

00:19:08,369 --> 00:19:12,599
Scotland ativ actually provides these so

00:19:11,099 --> 00:19:13,919
you wouldn't need to provide them but if

00:19:12,599 --> 00:19:15,899
you wanted to write your own you'd do it

00:19:13,919 --> 00:19:17,519
like this and it's exactly the same if

00:19:15,899 --> 00:19:19,919
you have like dynamic third-party

00:19:17,519 --> 00:19:22,440
libraries in my last talk I showed how

00:19:19,919 --> 00:19:24,690
to do this for libuv the the nodejs

00:19:22,440 --> 00:19:26,729
event loop c library right

00:19:24,690 --> 00:19:28,710
it's generally pretty straightforward to

00:19:26,729 --> 00:19:30,450
just all you have to do is translate the

00:19:28,710 --> 00:19:32,099
signature of the C function to the

00:19:30,450 --> 00:19:35,970
equivalent Scotland native function and

00:19:32,099 --> 00:19:38,909
it really just works so you you lose the

00:19:35,970 --> 00:19:41,849
JVM but what you gain is everything the

00:19:38,909 --> 00:19:42,250
ANSI err POSIX C libraries give you or

00:19:41,849 --> 00:19:44,860
any

00:19:42,250 --> 00:19:47,490
a third party seat library gives you and

00:19:44,860 --> 00:19:49,870
as it turns out their robust see

00:19:47,490 --> 00:19:52,390
libraries out there for quite a few

00:19:49,870 --> 00:19:54,730
useful things we might want to do and it

00:19:52,390 --> 00:19:56,740
makes you reconsider exactly like what

00:19:54,730 --> 00:19:59,800
the limits of what we can and can't do

00:19:56,740 --> 00:20:02,590
at this sort of low level way of

00:19:59,800 --> 00:20:05,290
approaching things the other but I also

00:20:02,590 --> 00:20:08,500
think we have the option of improving

00:20:05,290 --> 00:20:11,740
upon see just because scull is very very

00:20:08,500 --> 00:20:13,990
good at abstraction and safety so I'll

00:20:11,740 --> 00:20:15,400
try to aim at that where I can but I

00:20:13,990 --> 00:20:18,010
have to move pretty fast I'm thinking

00:20:15,400 --> 00:20:21,460
probably a little bit over time for this

00:20:18,010 --> 00:20:23,830
part of the talk the the like five

00:20:21,460 --> 00:20:25,990
standard C functions that we need for

00:20:23,830 --> 00:20:28,240
like the first couple exercises or these

00:20:25,990 --> 00:20:30,760
five we have printf which we've already

00:20:28,240 --> 00:20:33,820
seen right it's just a formatted like

00:20:30,760 --> 00:20:37,720
printing function we have F gets which

00:20:33,820 --> 00:20:39,340
just reads a line of text from a file it

00:20:37,720 --> 00:20:40,660
reads it into a buffer it gets a count

00:20:39,340 --> 00:20:43,260
to make sure it doesn't overflow the

00:20:40,660 --> 00:20:47,410
buffer it's one of the safer better

00:20:43,260 --> 00:20:50,110
standard i/o functions as scanf is a

00:20:47,410 --> 00:20:52,150
formatted input function it's sort of

00:20:50,110 --> 00:20:54,430
the dual of printf it takes a format

00:20:52,150 --> 00:20:57,370
string in the same form you'll see it in

00:20:54,430 --> 00:21:00,130
a second it basically reads data in from

00:20:57,370 --> 00:21:02,800
a buffer from a string or a file based

00:21:00,130 --> 00:21:07,210
on a formatted input string it's kind of

00:21:02,800 --> 00:21:08,800
broken and it's there there are better

00:21:07,210 --> 00:21:10,540
solutions but it's sort of the standard

00:21:08,800 --> 00:21:13,510
one and it's very very fast as you'll

00:21:10,540 --> 00:21:15,190
also see shortly last but not least you

00:21:13,510 --> 00:21:17,440
have the string comparator which will

00:21:15,190 --> 00:21:20,160
tell you whether two strings whether

00:21:17,440 --> 00:21:23,500
one's lesser or greater than the other

00:21:20,160 --> 00:21:25,330
and then string copy which all of the

00:21:23,500 --> 00:21:27,880
string copying functions in the C

00:21:25,330 --> 00:21:31,270
standard library are broken sort of

00:21:27,880 --> 00:21:33,420
embarrassingly so so we have to just fix

00:21:31,270 --> 00:21:35,800
that because it's it's unacceptable

00:21:33,420 --> 00:21:38,200
there's a there's some weird edge cases

00:21:35,800 --> 00:21:40,360
where it will successfully copy data

00:21:38,200 --> 00:21:42,430
from one string to another but if the

00:21:40,360 --> 00:21:45,130
source is larger than the destination

00:21:42,430 --> 00:21:46,660
it won't overflow the destination buffer

00:21:45,130 --> 00:21:48,580
but it'll fill it right up to the end

00:21:46,660 --> 00:21:51,400
without term adding the terminating zero

00:21:48,580 --> 00:21:52,809
at the end which means that operation is

00:21:51,400 --> 00:21:55,299
okay but the next

00:21:52,809 --> 00:21:57,669
time any operation tries to look for a

00:21:55,299 --> 00:22:00,159
terminating zero it will go off the end

00:21:57,669 --> 00:22:03,220
and blow up everything and trying to

00:22:00,159 --> 00:22:06,309
even like test or debug systems like

00:22:03,220 --> 00:22:09,399
that when you're assured that you will

00:22:06,309 --> 00:22:10,929
not see the bug at the the the point in

00:22:09,399 --> 00:22:15,610
your code at which originates is just

00:22:10,929 --> 00:22:17,230
sort of devilish to use a strong word

00:22:15,610 --> 00:22:18,850
but I I don't want to go too deep into

00:22:17,230 --> 00:22:20,379
this but it's just there there's gonna

00:22:18,850 --> 00:22:22,059
be a few other things we really have to

00:22:20,379 --> 00:22:24,159
wrap or fix what C gives us to get

00:22:22,059 --> 00:22:26,169
anything done so you all have been

00:22:24,159 --> 00:22:28,809
really awesome and patient now let's

00:22:26,169 --> 00:22:30,730
write some actual code so we have the

00:22:28,809 --> 00:22:32,860
the Google Ingram's data set it's

00:22:30,730 --> 00:22:34,480
publicly available if you have a lot of

00:22:32,860 --> 00:22:37,330
bandwidth it's pretty easy to download

00:22:34,480 --> 00:22:39,580
it's about um just although one the word

00:22:37,330 --> 00:22:41,499
counts or fifty gigabytes it's it's

00:22:39,580 --> 00:22:44,049
literally counts of all the words from

00:22:41,499 --> 00:22:45,970
all the books google scanned it's in tab

00:22:44,049 --> 00:22:47,559
delimited text files which are great and

00:22:45,970 --> 00:22:50,590
easy to process in every programming

00:22:47,559 --> 00:22:52,929
language Under the Sun each line is in

00:22:50,590 --> 00:22:56,110
the form word year because they're all

00:22:52,929 --> 00:22:58,629
sorted by year the count by that year

00:22:56,110 --> 00:23:00,429
and then the dot count the doc count is

00:22:58,629 --> 00:23:02,019
the number of documents the word occurs

00:23:00,429 --> 00:23:03,820
in which is like important for like

00:23:02,019 --> 00:23:05,769
tf-idf and other information retrieval

00:23:03,820 --> 00:23:06,929
calculations we're gonna participial

00:23:05,769 --> 00:23:09,129
we're not gonna use it for anything

00:23:06,929 --> 00:23:10,929
they're all separated by the letter of

00:23:09,129 --> 00:23:13,139
the word and we're gonna just use the a

00:23:10,929 --> 00:23:15,580
file which is about 2 gigabytes which is

00:23:13,139 --> 00:23:20,619
medium data it's enough to like make a

00:23:15,580 --> 00:23:23,759
program work so and really nice to just

00:23:20,619 --> 00:23:26,649
a good solid like data crunching problem

00:23:23,759 --> 00:23:28,629
so the three algorithms we want to work

00:23:26,649 --> 00:23:30,999
through are what's the most frequent

00:23:28,629 --> 00:23:33,309
word in this file what are the top 20

00:23:30,999 --> 00:23:35,830
most frequent words and we're gonna sort

00:23:33,309 --> 00:23:38,169
the file to do that and then what are

00:23:35,830 --> 00:23:39,820
them top 20 if we add together all the

00:23:38,169 --> 00:23:41,679
words by year right because they're

00:23:39,820 --> 00:23:44,169
they're split out by year they look like

00:23:41,679 --> 00:23:46,360
this also they have a lot of weird words

00:23:44,169 --> 00:23:50,710
or weird proper nouns or like scanning

00:23:46,360 --> 00:23:52,389
errors things aren't words and they also

00:23:50,710 --> 00:23:56,799
a lot of them have part of speech tags

00:23:52,389 --> 00:23:58,240
like this but I'm a failed computational

00:23:56,799 --> 00:23:59,769
linguists so if I start talking about

00:23:58,240 --> 00:24:02,529
part of speech tags we're gonna be here

00:23:59,769 --> 00:24:04,330
all night so let's just assume that the

00:24:02,529 --> 00:24:04,880
thing on the left-hand column is in fact

00:24:04,330 --> 00:24:09,410
the word

00:24:04,880 --> 00:24:10,460
for now and parse it like that so if we

00:24:09,410 --> 00:24:12,980
were gonna implement this in like

00:24:10,460 --> 00:24:15,860
vanilla Scala I'd say this is a naive

00:24:12,980 --> 00:24:18,560
but simple enough implementation right

00:24:15,860 --> 00:24:20,720
to just find the most frequent like just

00:24:18,560 --> 00:24:22,360
have VARs for the maximum word and the

00:24:20,720 --> 00:24:26,330
count of the year that we've seen so far

00:24:22,360 --> 00:24:29,180
iterate over standard in split them pull

00:24:26,330 --> 00:24:31,460
out the things we care about check and

00:24:29,180 --> 00:24:34,040
update our virus right and you could

00:24:31,460 --> 00:24:37,960
certainly optimize over this people can

00:24:34,040 --> 00:24:41,510
do high-speed IO on the JVM pretty well

00:24:37,960 --> 00:24:45,050
but I argue this is at least a good like

00:24:41,510 --> 00:24:46,430
first a first attempt so how do we do

00:24:45,050 --> 00:24:49,610
this if we're gonna take the native

00:24:46,430 --> 00:24:52,070
approach and want to sort of try to

00:24:49,610 --> 00:24:53,780
optimize for all these weird string i/o

00:24:52,070 --> 00:24:55,720
and allocation tricks that I sort of

00:24:53,780 --> 00:24:58,010
threw at you over the last 20 minutes

00:24:55,720 --> 00:25:00,470
the first thing we want to do is we just

00:24:58,010 --> 00:25:02,900
want to stack allocate everything to try

00:25:00,470 --> 00:25:03,980
to keep the cost of allocation down and

00:25:02,900 --> 00:25:07,940
get to the point where this program

00:25:03,980 --> 00:25:09,890
generates no garbage whatsoever taking

00:25:07,940 --> 00:25:12,200
the the garbage basically taking the

00:25:09,890 --> 00:25:13,550
garbage collector out of the loop has

00:25:12,200 --> 00:25:15,710
pretty dramatic effects on the

00:25:13,550 --> 00:25:18,530
performance as we'll see basically what

00:25:15,710 --> 00:25:20,390
we're going to do is we're just gonna

00:25:18,530 --> 00:25:22,580
iterate over reading a line from

00:25:20,390 --> 00:25:23,930
standardin until F gets returns null

00:25:22,580 --> 00:25:26,300
that's when we know we've reached the

00:25:23,930 --> 00:25:28,490
end of the file and once we've got it

00:25:26,300 --> 00:25:30,470
then we're gonna use this scan and

00:25:28,490 --> 00:25:32,450
compare function and what we're gonna do

00:25:30,470 --> 00:25:34,280
is we're gonna pass it as arguments both

00:25:32,450 --> 00:25:36,200
the buffer that holds the current line

00:25:34,280 --> 00:25:38,150
we just read the size of that buffer so

00:25:36,200 --> 00:25:40,760
we don't overflow it and then it's also

00:25:38,150 --> 00:25:42,620
going to take these these pointers to

00:25:40,760 --> 00:25:44,960
the maximum count to the maximum word

00:25:42,620 --> 00:25:46,550
and the year and we're just going to

00:25:44,960 --> 00:25:49,010
pass those pointers in directly so we

00:25:46,550 --> 00:25:51,170
can update them freely without having to

00:25:49,010 --> 00:25:55,100
worry about allocations or anything like

00:25:51,170 --> 00:25:57,260
that you could also do it with bars but

00:25:55,100 --> 00:25:59,660
I wanted to do it like in like C idiom

00:25:57,260 --> 00:26:01,040
right so the the meat of this is

00:25:59,660 --> 00:26:02,960
actually in the scan and compare

00:26:01,040 --> 00:26:06,530
function which is again going to stack

00:26:02,960 --> 00:26:09,350
allocate account a year a dot count in

00:26:06,530 --> 00:26:10,670
space for the word and then what it's

00:26:09,350 --> 00:26:12,800
going to do is it's going to use scanf

00:26:10,670 --> 00:26:16,280
to read from the line buffer we passed

00:26:12,800 --> 00:26:17,700
in into that that temporary space right

00:26:16,280 --> 00:26:19,889
here did I

00:26:17,700 --> 00:26:21,839
checking the results of scanf is like

00:26:19,889 --> 00:26:24,539
evil and I don't I have a I could give a

00:26:21,839 --> 00:26:27,739
talk on writing a good checker for scanf

00:26:24,539 --> 00:26:31,079
it's horrifying but the idea is then we

00:26:27,739 --> 00:26:34,169
use the dereference offer operator right

00:26:31,079 --> 00:26:36,419
to check if the the value stored and the

00:26:34,169 --> 00:26:38,279
pointer to the max count is less than

00:26:36,419 --> 00:26:40,829
the value that's in the temporary count

00:26:38,279 --> 00:26:42,479
right and if we do that means the word

00:26:40,829 --> 00:26:44,190
we just read is greater than the maximum

00:26:42,479 --> 00:26:45,809
and if that's the case then we just

00:26:44,190 --> 00:26:48,479
update all of the pointers that got

00:26:45,809 --> 00:26:50,159
passed in because they're all immutable

00:26:48,479 --> 00:26:53,309
pointers and that's where we'll use that

00:26:50,159 --> 00:26:57,690
safer string copy that we wrote so

00:26:53,309 --> 00:27:00,269
pretty standard cool so so how does this

00:26:57,690 --> 00:27:03,839
perform it starts out pretty small like

00:27:00,269 --> 00:27:05,249
the native runs a little bit faster if

00:27:03,839 --> 00:27:08,099
you give it like a hundred megabytes of

00:27:05,249 --> 00:27:09,959
input data like it handles the file in

00:27:08,099 --> 00:27:12,509
like four point seven three seconds on

00:27:09,959 --> 00:27:15,779
the JVM version it's like five point

00:27:12,509 --> 00:27:17,309
four one seconds but the more data you

00:27:15,779 --> 00:27:20,879
feed it they just sort of rapidly

00:27:17,309 --> 00:27:22,259
diverge so what's interesting right is

00:27:20,879 --> 00:27:25,649
that it's not like this is generating a

00:27:22,259 --> 00:27:27,509
large heap or anything like it's even

00:27:25,649 --> 00:27:29,700
the JVM version right should be

00:27:27,509 --> 00:27:31,109
discarding all this data but it seems

00:27:29,700 --> 00:27:35,399
like the churn of all those allocations

00:27:31,109 --> 00:27:38,159
are just killing it so that like by the

00:27:35,399 --> 00:27:41,099
time you get to like even like 300

00:27:38,159 --> 00:27:43,049
megabytes it's like the JVM is taking 16

00:27:41,099 --> 00:27:45,239
seconds and native is doing it a nine

00:27:43,049 --> 00:27:47,809
and then like all the way at the end at

00:27:45,239 --> 00:27:50,549
the full file which is 1.7 gigabytes

00:27:47,809 --> 00:27:53,190
it's like the JVM takes more than three

00:27:50,549 --> 00:27:55,950
minutes to do it it takes 186 seconds

00:27:53,190 --> 00:27:58,559
and native dozen in about 43 seconds so

00:27:55,950 --> 00:28:00,149
about five to six times faster and right

00:27:58,559 --> 00:28:03,269
these are diverging if I fed it more

00:28:00,149 --> 00:28:06,269
data it would continue to diverge it's

00:28:03,269 --> 00:28:07,979
it's not like oh one is 20% faster than

00:28:06,269 --> 00:28:10,200
the other kind of difference it's like

00:28:07,979 --> 00:28:12,299
big o-notation there's actually a

00:28:10,200 --> 00:28:17,239
difference in the growth trends in

00:28:12,299 --> 00:28:19,829
general kind of difference so yeah so

00:28:17,239 --> 00:28:21,989
how are people feeling so far everyone

00:28:19,829 --> 00:28:23,759
who's a who's feeling super good about

00:28:21,989 --> 00:28:26,940
this awesome

00:28:23,759 --> 00:28:30,130
cool then I'll keep going

00:28:26,940 --> 00:28:33,460
sweet so for the next trick we're gonna

00:28:30,130 --> 00:28:35,470
sort the that whole a file right this is

00:28:33,460 --> 00:28:37,870
trying like like arguably what I just

00:28:35,470 --> 00:28:39,309
did right was verging on like cheating

00:28:37,870 --> 00:28:40,870
right cuz it's just abusing stack

00:28:39,309 --> 00:28:44,409
allocation and anyone could write a

00:28:40,870 --> 00:28:46,450
faster um like JVM implementation so

00:28:44,409 --> 00:28:47,890
let's write something that actually uses

00:28:46,450 --> 00:28:50,710
the heap and isn't just doing a bunch of

00:28:47,890 --> 00:28:52,690
throwaway allocation and that invokes

00:28:50,710 --> 00:28:55,059
java's sorting functions which are

00:28:52,690 --> 00:28:57,940
actually really good right and the JVM

00:28:55,059 --> 00:29:00,309
is brilliant at optimizing like hot

00:28:57,940 --> 00:29:02,530
inner loops like like sorting right so I

00:29:00,309 --> 00:29:05,470
would argue this gives the JVM more of a

00:29:02,530 --> 00:29:08,679
leg up on what native is capable of and

00:29:05,470 --> 00:29:11,049
and see how this does the JVM version I

00:29:08,679 --> 00:29:13,570
can't go super fast but we're just gonna

00:29:11,049 --> 00:29:15,909
read things into an array buffer right

00:29:13,570 --> 00:29:16,900
but it's basically the same code it's

00:29:15,909 --> 00:29:18,760
just we're appending it to an array

00:29:16,900 --> 00:29:20,440
buffer and then so we have it in an

00:29:18,760 --> 00:29:23,620
array buffer we're just gonna sort it

00:29:20,440 --> 00:29:25,330
like this so nothing complicated in

00:29:23,620 --> 00:29:27,730
native this is harder and it's gonna

00:29:25,330 --> 00:29:30,159
require a few new techniques that we

00:29:27,730 --> 00:29:31,659
haven't learned yet so we have to

00:29:30,159 --> 00:29:32,860
actually model this in gram data is

00:29:31,659 --> 00:29:34,510
something we can store in an array

00:29:32,860 --> 00:29:36,909
called a struct which we'll talk about

00:29:34,510 --> 00:29:38,830
in the next slide we're gonna read all

00:29:36,909 --> 00:29:41,740
of the input all two gigabytes into a

00:29:38,830 --> 00:29:42,700
single giant array and that's tricky

00:29:41,740 --> 00:29:44,679
right because we don't know how many

00:29:42,700 --> 00:29:47,169
there are and when we're allocating

00:29:44,679 --> 00:29:49,539
memory with the C functions we have to

00:29:47,169 --> 00:29:51,580
know how big the arrays are right which

00:29:49,539 --> 00:29:54,730
means we have to resize the array as we

00:29:51,580 --> 00:29:57,130
go which is gonna be fun and then we can

00:29:54,730 --> 00:29:58,960
sort it to do this we're gonna need to

00:29:57,130 --> 00:30:01,059
know how to use structs to model our

00:29:58,960 --> 00:30:02,500
data in like a C and array friendly way

00:30:01,059 --> 00:30:04,750
we're gonna need to know how to use

00:30:02,500 --> 00:30:07,960
malloc and realloc to handle these big

00:30:04,750 --> 00:30:09,490
chunky arrays that persists longer than

00:30:07,960 --> 00:30:12,100
the stack does and we're gonna need to

00:30:09,490 --> 00:30:16,450
use Q sort the G Lib C quicksort

00:30:12,100 --> 00:30:19,780
function which is awesome there we go

00:30:16,450 --> 00:30:21,610
so structs basically work like this it's

00:30:19,780 --> 00:30:24,340
sort of the equivalent of a case class

00:30:21,610 --> 00:30:26,830
maybe with a bit of a to polish feeling

00:30:24,340 --> 00:30:30,010
right now the idea is it's a it's a

00:30:26,830 --> 00:30:31,900
composite data type that is always laid

00:30:30,010 --> 00:30:34,720
out in contiguous memory right it only

00:30:31,900 --> 00:30:37,450
contains primitive primitive types whose

00:30:34,720 --> 00:30:39,760
whose sizes are statically known so

00:30:37,450 --> 00:30:41,710
the offset of any field in the struct is

00:30:39,760 --> 00:30:43,450
also statically known that makes them

00:30:41,710 --> 00:30:44,980
work really well with arrays because you

00:30:43,450 --> 00:30:47,500
know the size of everything and every

00:30:44,980 --> 00:30:49,420
item in the array is the same size it

00:30:47,500 --> 00:30:53,350
means you can get to any field of any

00:30:49,420 --> 00:30:54,820
object in constant time right the weird

00:30:53,350 --> 00:30:57,100
thing is that in --see right they're

00:30:54,820 --> 00:30:59,740
treated more like things with named

00:30:57,100 --> 00:31:02,290
fields in this version of scala native

00:30:59,740 --> 00:31:03,940
they're treated with like tuple like dot

00:31:02,290 --> 00:31:07,150
underscore one dot underscore two

00:31:03,940 --> 00:31:08,920
accessors I think Scala native OH dot 4

00:31:07,150 --> 00:31:12,070
is gonna add named fields to them which

00:31:08,920 --> 00:31:13,360
will be a lot nicer so this is just sort

00:31:12,070 --> 00:31:16,060
of a current limit of the implementation

00:31:13,360 --> 00:31:17,920
but this will actually get easier in the

00:31:16,060 --> 00:31:21,910
very near future and I'm really excited

00:31:17,920 --> 00:31:24,130
for it actually so now our if so if we

00:31:21,910 --> 00:31:26,140
were using the the in Graham case class

00:31:24,130 --> 00:31:28,450
and the jvm version which has the word

00:31:26,140 --> 00:31:32,220
the count the year the dot count all the

00:31:28,450 --> 00:31:35,290
things we had before in the jvm version

00:31:32,220 --> 00:31:37,930
the in Graham data struct is just a C

00:31:35,290 --> 00:31:40,630
struct for which takes a C string an int

00:31:37,930 --> 00:31:43,510
and an int and we'll just have to keep

00:31:40,630 --> 00:31:47,230
track of the of the offsets in our heads

00:31:43,510 --> 00:31:49,060
but I think we can manage it so the the

00:31:47,230 --> 00:31:50,650
one thing that maybe should be raising

00:31:49,060 --> 00:31:53,470
some question marks is hey how do you

00:31:50,650 --> 00:31:55,540
have a dynamically sized tree string and

00:31:53,470 --> 00:31:58,210
a struct whose size is known statically

00:31:55,540 --> 00:32:01,090
and the answer is the thing that exists

00:31:58,210 --> 00:32:03,520
in that struct is not the variable size

00:32:01,090 --> 00:32:05,440
content of the string it is the pointer

00:32:03,520 --> 00:32:07,960
to the content of the string which is

00:32:05,440 --> 00:32:10,690
exactly 8 bytes so we can know that

00:32:07,960 --> 00:32:13,990
every instance of a Ngram data takes

00:32:10,690 --> 00:32:17,230
exactly 20 bytes 8 for the string and

00:32:13,990 --> 00:32:19,060
then 12 for the the 3 ends the downside

00:32:17,230 --> 00:32:20,620
of that is that if we want to keep these

00:32:19,060 --> 00:32:22,750
strings around we're gonna need to

00:32:20,620 --> 00:32:26,950
allocate space for the strings as well

00:32:22,750 --> 00:32:28,240
and to make all of this work we can't

00:32:26,950 --> 00:32:30,190
use stack Allah because we want things

00:32:28,240 --> 00:32:33,100
that outlive any given function so

00:32:30,190 --> 00:32:36,670
instead we're going to use the legendary

00:32:33,100 --> 00:32:38,710
malloc for heap allocation because it's

00:32:36,670 --> 00:32:40,660
not like a Scala Native intrinsic it's

00:32:38,710 --> 00:32:42,190
just a sealed function and actually a c

00:32:40,660 --> 00:32:45,070
function that's mostly in user space

00:32:42,190 --> 00:32:47,380
it's not as friendly as as stack a lock

00:32:45,070 --> 00:32:49,660
is unless we wrap it or something it

00:32:47,380 --> 00:32:51,090
just gives you a pointer of bytes of the

00:32:49,660 --> 00:32:53,550
size you you asked it

00:32:51,090 --> 00:32:55,800
or if you want it typed and you want it

00:32:53,550 --> 00:32:58,200
like being even vaguely saying you have

00:32:55,800 --> 00:33:00,180
to do stuff like this and then if you

00:32:58,200 --> 00:33:04,290
want to resize it you have to do two

00:33:00,180 --> 00:33:06,750
castes in this crazy realloc thing the

00:33:04,290 --> 00:33:08,820
other thing is that like pointers aren't

00:33:06,750 --> 00:33:12,270
managed like they are in Java right if

00:33:08,820 --> 00:33:14,520
if you resize a pointer from if you

00:33:12,270 --> 00:33:18,120
resize an array from three ants to six

00:33:14,520 --> 00:33:19,680
cents realloc may or may not move it to

00:33:18,120 --> 00:33:21,810
some completely different space and

00:33:19,680 --> 00:33:25,080
memory depending if there's room for it

00:33:21,810 --> 00:33:26,940
like on up as a extension of where it

00:33:25,080 --> 00:33:29,250
currently lives right

00:33:26,940 --> 00:33:31,260
so what realloc does is it just returns

00:33:29,250 --> 00:33:33,390
the address of wherever the thing is

00:33:31,260 --> 00:33:37,020
whether it was moved or not but that

00:33:33,390 --> 00:33:39,030
means it could totally invalidate any

00:33:37,020 --> 00:33:40,920
wild pointers you have to this data

00:33:39,030 --> 00:33:42,900
outstanding so you have to be really

00:33:40,920 --> 00:33:44,640
really disciplined about pointers if

00:33:42,900 --> 00:33:47,910
you're going to even consider using

00:33:44,640 --> 00:33:50,820
realloc to sort of help with this oh oh

00:33:47,910 --> 00:33:53,970
one really important thing none of this

00:33:50,820 --> 00:33:56,520
is garbage collected heap right these um

00:33:53,970 --> 00:33:58,020
these basically until you call free

00:33:56,520 --> 00:34:00,390
these will just leak or stay around

00:33:58,020 --> 00:34:03,120
forever because I'm writing programs

00:34:00,390 --> 00:34:04,560
that read a bunch of data in allocate a

00:34:03,120 --> 00:34:06,090
bunch of memory and then exit I'm just

00:34:04,560 --> 00:34:08,130
not gonna call free what you're allowed

00:34:06,090 --> 00:34:10,470
to do if your program exits but

00:34:08,130 --> 00:34:12,750
seriously if you do this in the wild

00:34:10,470 --> 00:34:15,690
free all your pointers I didn't tell you

00:34:12,750 --> 00:34:17,640
to leak memory so if we wanted to like

00:34:15,690 --> 00:34:20,730
wrap this and I'm gonna go fast just to

00:34:17,640 --> 00:34:22,920
recover some time like I'd have like a

00:34:20,730 --> 00:34:24,900
wrapped array class which takes both a

00:34:22,920 --> 00:34:27,270
pointer to the data and then it tracks

00:34:24,900 --> 00:34:29,820
both how much data we've used of the

00:34:27,270 --> 00:34:32,310
array and what the capacity is and then

00:34:29,820 --> 00:34:35,490
we can just allow the caller to both

00:34:32,310 --> 00:34:38,100
decide how much space to initialize it

00:34:35,490 --> 00:34:40,350
with and then which decide when and how

00:34:38,100 --> 00:34:44,730
to grow it which is sort of a compromise

00:34:40,350 --> 00:34:47,280
between some of the uglier stuff that C

00:34:44,730 --> 00:34:49,860
makes you do while still having like

00:34:47,280 --> 00:34:52,230
enough power to like manage large slabs

00:34:49,860 --> 00:34:54,240
of memory oh the other thing is umm

00:34:52,230 --> 00:34:56,280
realloc is really slow right if we're

00:34:54,240 --> 00:34:58,620
copying three ants from one place and

00:34:56,280 --> 00:35:00,390
memory to another that's not bad but if

00:34:58,620 --> 00:35:02,280
like we're gonna have gigabytes and

00:35:00,390 --> 00:35:04,540
we're gonna be growing arrays that are

00:35:02,280 --> 00:35:06,550
like gigabytes why

00:35:04,540 --> 00:35:08,260
that's a lot of data and copying it from

00:35:06,550 --> 00:35:11,320
one part of memory to another could

00:35:08,260 --> 00:35:13,210
become non-trivial and like malloc and

00:35:11,320 --> 00:35:15,369
realloc are also occasionally

00:35:13,210 --> 00:35:16,960
non-deterministic and nonlinear so we

00:35:15,369 --> 00:35:19,020
want to figure out how to cut down on

00:35:16,960 --> 00:35:22,300
the number of invocations of either

00:35:19,020 --> 00:35:24,400
malloc or realloc we're going to get to

00:35:22,300 --> 00:35:27,520
in our program and be kind of strategic

00:35:24,400 --> 00:35:29,680
about that which you'll see in like two

00:35:27,520 --> 00:35:31,839
slides last but not least you have Q

00:35:29,680 --> 00:35:34,150
sort which is really interesting because

00:35:31,839 --> 00:35:37,390
it's like early C attempt at generic

00:35:34,150 --> 00:35:39,760
programming right because it just takes

00:35:37,390 --> 00:35:42,339
a pointer byte as its first data

00:35:39,760 --> 00:35:44,320
argument that's not a string that's not

00:35:42,339 --> 00:35:46,599
a buffer of bytes what that really is is

00:35:44,320 --> 00:35:49,150
that's just a no pointer to an array of

00:35:46,599 --> 00:35:50,829
some opaque type C doesn't have type

00:35:49,150 --> 00:35:53,140
parameters so you have no way to tell it

00:35:50,829 --> 00:35:55,119
what that is instead it takes two

00:35:53,140 --> 00:35:57,010
additional arguments the number of items

00:35:55,119 --> 00:35:58,869
in the array and the size of each one

00:35:57,010 --> 00:36:01,300
you just have to compute that and pass

00:35:58,869 --> 00:36:03,130
it in right and then if you do that you

00:36:01,300 --> 00:36:05,560
can also pass in a comparator which is a

00:36:03,130 --> 00:36:07,180
function pointer C has function pointers

00:36:05,560 --> 00:36:09,160
you can do a if you don't care about

00:36:07,180 --> 00:36:11,849
lexical scope or closure so you can do a

00:36:09,160 --> 00:36:14,859
lot of functional programming and C

00:36:11,849 --> 00:36:17,290
right and that that function pointer has

00:36:14,859 --> 00:36:19,089
to take two pointer bytes in and return

00:36:17,290 --> 00:36:21,640
an int like any other comparator in a

00:36:19,089 --> 00:36:25,119
sane programming language the way it

00:36:21,640 --> 00:36:27,520
works right is the inside the

00:36:25,119 --> 00:36:30,849
comparators you can cast whatever data

00:36:27,520 --> 00:36:33,010
you know you're going to be holding in

00:36:30,849 --> 00:36:35,859
your array and you the programmer have

00:36:33,010 --> 00:36:38,050
to like keep track of all that and like

00:36:35,859 --> 00:36:40,180
so like sort alphabetically we cast it

00:36:38,050 --> 00:36:42,430
to strings dereference them and then use

00:36:40,180 --> 00:36:45,609
string comp on them if we want to sort

00:36:42,430 --> 00:36:48,760
by count we just cast them from pointer

00:36:45,609 --> 00:36:51,099
byte pointer to Engram data and then

00:36:48,760 --> 00:36:53,470
pull out the count with the the second

00:36:51,099 --> 00:36:55,270
field and the the struct right and

00:36:53,470 --> 00:36:57,670
dereference it and then return the the

00:36:55,270 --> 00:37:01,230
the Delta between those two for because

00:36:57,670 --> 00:37:03,490
we want to descend and count right so

00:37:01,230 --> 00:37:05,589
once we've done all this I know I've

00:37:03,490 --> 00:37:07,300
continued to throw a lot of technique at

00:37:05,589 --> 00:37:08,920
you but now we have enough to actually

00:37:07,300 --> 00:37:11,020
write the main routine of our function

00:37:08,920 --> 00:37:12,440
of our of our program and this is gonna

00:37:11,020 --> 00:37:14,320
be the fun one

00:37:12,440 --> 00:37:17,060
as you can see I was saying we want to

00:37:14,320 --> 00:37:19,460
avoid allocation as much as possible so

00:37:17,060 --> 00:37:21,350
we're gonna allocate about a million of

00:37:19,460 --> 00:37:24,260
these trucks at a time and to our array

00:37:21,350 --> 00:37:25,820
like seer which is 1 million items there

00:37:24,260 --> 00:37:28,460
20 bytes each so we're gonna basically

00:37:25,820 --> 00:37:30,650
be pulling in about 20 Meg's of heap

00:37:28,460 --> 00:37:33,650
every time we malloc or realloc which I

00:37:30,650 --> 00:37:35,570
was kind of surprised this worked but

00:37:33,650 --> 00:37:37,670
that was fun we're gonna still use stack

00:37:35,570 --> 00:37:40,370
allocation for our line buffer we're

00:37:37,670 --> 00:37:42,890
gonna create an array with the block

00:37:40,370 --> 00:37:45,490
size about a million items and then

00:37:42,890 --> 00:37:48,680
we're gonna just iterate over standard

00:37:45,490 --> 00:37:50,660
standard in like we were before we're

00:37:48,680 --> 00:37:52,910
good and basically every time we read a

00:37:50,660 --> 00:37:55,640
line we're just gonna check to see if

00:37:52,910 --> 00:37:57,920
we're at capacity and if so we'll grow

00:37:55,640 --> 00:38:00,890
by the block size we already set up so

00:37:57,920 --> 00:38:02,720
like really really basic like dumb

00:38:00,890 --> 00:38:05,270
implementation of a dynamically grow

00:38:02,720 --> 00:38:08,270
able array but it works surprisingly

00:38:05,270 --> 00:38:09,920
well as it turns out we're gonna call

00:38:08,270 --> 00:38:11,240
our parse line function which is going

00:38:09,920 --> 00:38:13,280
to be pretty similar to the one we wrote

00:38:11,240 --> 00:38:15,380
before but with some subtle differences

00:38:13,280 --> 00:38:16,580
and we're just gonna give it what's

00:38:15,380 --> 00:38:19,340
interesting as we give it the line

00:38:16,580 --> 00:38:21,740
buffer we just read and we we're doing

00:38:19,340 --> 00:38:25,940
is we're pointing it literally at a rate

00:38:21,740 --> 00:38:27,710
the the pointer to our data plus the

00:38:25,940 --> 00:38:29,450
offset of how many items used in it

00:38:27,710 --> 00:38:31,250
which is going to be actually the

00:38:29,450 --> 00:38:33,350
address of the next free item so we're

00:38:31,250 --> 00:38:37,100
just going to give it the address of the

00:38:33,350 --> 00:38:39,770
next empty uninitialized struct in our

00:38:37,100 --> 00:38:42,890
array ready for it to use and then we

00:38:39,770 --> 00:38:45,140
can increment the array dot used and

00:38:42,890 --> 00:38:47,600
once that's full we have a full array

00:38:45,140 --> 00:38:50,090
and we know exactly how big it is and we

00:38:47,600 --> 00:38:52,610
can call quicksort on it which works

00:38:50,090 --> 00:38:54,530
quite well as you can see we take the

00:38:52,610 --> 00:38:56,690
array data we cast it to a pointer byte

00:38:54,530 --> 00:38:59,450
because that's required see does a lot

00:38:56,690 --> 00:39:01,580
of weird stuff with casting to and from

00:38:59,450 --> 00:39:04,160
void Scala native doesn't which makes

00:39:01,580 --> 00:39:04,880
things explicit and then we pass in how

00:39:04,160 --> 00:39:06,950
big it is

00:39:04,880 --> 00:39:10,190
etc I'm a little low on time so I'm

00:39:06,950 --> 00:39:11,540
gonna speed up here the actually parsing

00:39:10,190 --> 00:39:13,580
is straightforward you don't even have

00:39:11,540 --> 00:39:16,070
to allocate we're using a dumb trick

00:39:13,580 --> 00:39:17,990
with scanf to actually force scanf to

00:39:16,070 --> 00:39:20,240
malloc space for each string but I can't

00:39:17,990 --> 00:39:21,770
go into that do at a time the cool thing

00:39:20,240 --> 00:39:23,570
about the performance is they start out

00:39:21,770 --> 00:39:24,460
even natives faster by like half a

00:39:23,570 --> 00:39:27,010
second

00:39:24,460 --> 00:39:29,920
but again they continue to diverge jvm

00:39:27,010 --> 00:39:31,900
actually beats native on sort for quite

00:39:29,920 --> 00:39:35,619
a while until you're at like seven

00:39:31,900 --> 00:39:37,330
hundred Meg's but the JVM also goes out

00:39:35,619 --> 00:39:39,580
of control as the heap gets larger and

00:39:37,330 --> 00:39:41,859
it actually fails to completely soar the

00:39:39,580 --> 00:39:44,589
file after about a hundred hundred

00:39:41,859 --> 00:39:45,640
eleven hundred megabytes so yeah I

00:39:44,589 --> 00:39:47,560
thought that was an interesting result

00:39:45,640 --> 00:39:49,540
for the final trick I think I have to go

00:39:47,560 --> 00:39:52,240
really fast because of time but we're

00:39:49,540 --> 00:39:54,280
just gonna aggravate the trick is like a

00:39:52,240 --> 00:39:56,410
brute force aggregation algorithm would

00:39:54,280 --> 00:39:59,200
require breeding that whole big thing

00:39:56,410 --> 00:40:02,650
into heap then creating another smaller

00:39:59,200 --> 00:40:03,910
array and to heap to do the algorithm we

00:40:02,650 --> 00:40:06,310
can avoid that because we know the data

00:40:03,910 --> 00:40:08,680
is already sorted so instead we can just

00:40:06,310 --> 00:40:10,060
keep a much smaller running array use a

00:40:08,680 --> 00:40:12,550
lot more of those stack allocation

00:40:10,060 --> 00:40:15,369
tricks basically by just slinging around

00:40:12,550 --> 00:40:18,099
to pointers to like the next item in our

00:40:15,369 --> 00:40:20,440
big array and the previous one I don't

00:40:18,099 --> 00:40:23,200
think I have enough time to totally walk

00:40:20,440 --> 00:40:24,460
through the dance of this but the slides

00:40:23,200 --> 00:40:27,250
are up and I would love to talk about

00:40:24,460 --> 00:40:29,890
them at length basically the idea is the

00:40:27,250 --> 00:40:31,630
parse line now returns a bool to tell

00:40:29,890 --> 00:40:34,720
you whether it actually encountered a

00:40:31,630 --> 00:40:36,460
new word or not which lets you be even

00:40:34,720 --> 00:40:38,830
more conservative about how you allocate

00:40:36,460 --> 00:40:41,680
memory and how big the the the array

00:40:38,830 --> 00:40:43,240
gets and there's again it's it's a bit

00:40:41,680 --> 00:40:44,800
of a dance but it's also nothing we

00:40:43,240 --> 00:40:49,570
haven't used so far I wish I had more

00:40:44,800 --> 00:40:52,119
time to go into it do to do and here the

00:40:49,570 --> 00:40:54,580
performance sort of burns through the

00:40:52,119 --> 00:40:57,880
road again it's about twice as fast as

00:40:54,580 --> 00:40:59,530
as the the JVM even on the smaller files

00:40:57,880 --> 00:41:01,440
what's interesting is it starts beating

00:40:59,530 --> 00:41:04,210
it on the sword again here immediately

00:41:01,440 --> 00:41:05,950
when the heap is this small which I've

00:41:04,210 --> 00:41:07,030
sort of struggled with understanding and

00:41:05,950 --> 00:41:09,280
might just because of the string

00:41:07,030 --> 00:41:12,220
allocations and malloc blowing things up

00:41:09,280 --> 00:41:13,839
on native in the previous example so

00:41:12,220 --> 00:41:15,580
it's not quite as categorical of a

00:41:13,839 --> 00:41:17,470
difference like the JVM completes the

00:41:15,580 --> 00:41:19,599
whole file but you can definitely see

00:41:17,470 --> 00:41:21,940
things remain mostly linear on native

00:41:19,599 --> 00:41:24,190
right and continuing to perform stabili

00:41:21,940 --> 00:41:27,849
through the whole file while the JVM

00:41:24,190 --> 00:41:29,589
sort of again continues to diverge and I

00:41:27,849 --> 00:41:32,140
would love to talk about that more so

00:41:29,589 --> 00:41:33,700
here's the hand way yep that was the the

00:41:32,140 --> 00:41:36,740
empirical part of the talk here's the

00:41:33,700 --> 00:41:39,260
opinions what I do think I've shown

00:41:36,740 --> 00:41:41,750
are that like one this is a thing that

00:41:39,260 --> 00:41:43,040
you can do and that if you're willing to

00:41:41,750 --> 00:41:45,530
use like manual memory management

00:41:43,040 --> 00:41:47,330
techniques you will get not just like

00:41:45,530 --> 00:41:49,520
fractionally better performance but like

00:41:47,330 --> 00:41:50,960
into integral multiples better

00:41:49,520 --> 00:41:52,940
performance for some kind of

00:41:50,960 --> 00:41:54,860
applications and then in particular

00:41:52,940 --> 00:41:56,420
these these domains where this could

00:41:54,860 --> 00:42:00,970
make a difference or places that have

00:41:56,420 --> 00:42:03,740
one heavy i/o and and or two large heaps

00:42:00,970 --> 00:42:05,720
and if you accept those as things I've

00:42:03,740 --> 00:42:08,510
established it raises the question well

00:42:05,720 --> 00:42:10,940
where do you use Scala native and I mean

00:42:08,510 --> 00:42:14,480
I I want to be somewhat balanced here

00:42:10,940 --> 00:42:17,180
but like big heap heavy IO is a lot of

00:42:14,480 --> 00:42:20,210
stuff people use Scala for like things

00:42:17,180 --> 00:42:22,310
like spark big old data pipelines event

00:42:20,210 --> 00:42:24,050
II services like akka and finagle those

00:42:22,310 --> 00:42:25,880
are all things that can use a lot of

00:42:24,050 --> 00:42:27,619
heap and can do a lot of i/o which i

00:42:25,880 --> 00:42:30,170
think is interesting those are also

00:42:27,619 --> 00:42:32,090
projects I use every day and love and

00:42:30,170 --> 00:42:33,950
they're my bread and butter and they're

00:42:32,090 --> 00:42:35,600
great pieces of software Scala native

00:42:33,950 --> 00:42:38,180
isn't going to destroy them but the

00:42:35,600 --> 00:42:39,110
hardware is changing really fast and I

00:42:38,180 --> 00:42:42,200
think there are new things on the

00:42:39,110 --> 00:42:45,890
horizon so also performance isn't

00:42:42,200 --> 00:42:47,359
everything this isn't safe try this at

00:42:45,890 --> 00:42:49,310
home maybe don't try to sit work

00:42:47,359 --> 00:42:50,690
immediately but we're getting much

00:42:49,310 --> 00:42:52,910
better at breaking things down to the

00:42:50,690 --> 00:42:54,380
small pieces and meta programming and

00:42:52,910 --> 00:42:56,930
doing this safely is something we can

00:42:54,380 --> 00:42:58,970
really think about seriously like look

00:42:56,930 --> 00:43:01,820
at some of TR crumbs and not amines work

00:42:58,970 --> 00:43:04,580
on like they're generating see from

00:43:01,820 --> 00:43:07,910
Scala and like 500 lines of code

00:43:04,580 --> 00:43:10,700
this is a non-volatile DRAM module for

00:43:07,910 --> 00:43:11,780
Intel right so once these things come

00:43:10,700 --> 00:43:13,850
online you're gonna have these big

00:43:11,780 --> 00:43:15,650
heterogeneous heaps hundreds of

00:43:13,850 --> 00:43:17,810
gigabytes that outlive your process and

00:43:15,650 --> 00:43:19,490
power cycles oh and your network

00:43:17,810 --> 00:43:22,550
interfaces can read and write to them

00:43:19,490 --> 00:43:24,050
directly and synchronously like every

00:43:22,550 --> 00:43:26,390
assumption about how the memory

00:43:24,050 --> 00:43:28,400
hierarchy works that we've had for 20

00:43:26,390 --> 00:43:30,580
years it's gonna break as this stuff

00:43:28,400 --> 00:43:33,680
becomes mainstream in the next year too

00:43:30,580 --> 00:43:36,050
and really I think it's going to change

00:43:33,680 --> 00:43:37,730
the game to the point of like how much

00:43:36,050 --> 00:43:40,400
data you can fit into a single

00:43:37,730 --> 00:43:42,400
vertically scaled like very well tuned

00:43:40,400 --> 00:43:45,170
program without having to go distributed

00:43:42,400 --> 00:43:47,310
and I wish I had more time to talk about

00:43:45,170 --> 00:43:48,750
these awesome papers but I don't

00:43:47,310 --> 00:43:51,060
but I have to conclude with this

00:43:48,750 --> 00:43:53,910
observation that to the extent that our

00:43:51,060 --> 00:43:56,790
systems make a break with the past

00:43:53,910 --> 00:43:59,040
soon that Scala native isn't a step back

00:43:56,790 --> 00:44:01,700
to where we were 40 years ago with C

00:43:59,040 --> 00:44:10,170
it's a step forward into the future

00:44:01,700 --> 00:44:14,550
thank you that's my talk thank you very

00:44:10,170 --> 00:44:17,220
much and you'll end it on time 5:30 I'd

00:44:14,550 --> 00:44:19,620
say two questions maybe you're here for

00:44:17,220 --> 00:44:25,890
the evening so you more question could

00:44:19,620 --> 00:44:30,270
be then letter actress advantage of

00:44:25,890 --> 00:44:31,320
using Scala night if instead of C that's

00:44:30,270 --> 00:44:36,840
a good question

00:44:31,320 --> 00:44:38,430
I find the there are a few touches to

00:44:36,840 --> 00:44:40,170
the type system like there is not a void

00:44:38,430 --> 00:44:42,480
pointer in Scala native which I find

00:44:40,170 --> 00:44:44,970
makes things better I think working with

00:44:42,480 --> 00:44:47,550
like functions and just the syntax of

00:44:44,970 --> 00:44:50,610
Scala native has advantages over C there

00:44:47,550 --> 00:44:52,530
is not a direct performance improvement

00:44:50,610 --> 00:44:54,840
of using Scala native oversee a best

00:44:52,530 --> 00:44:56,310
Scala native will match see I would use

00:44:54,840 --> 00:44:57,810
Scala native over C because I like

00:44:56,310 --> 00:45:00,360
writing Scala a lot more than I like

00:44:57,810 --> 00:45:04,920
writing C and I've written C for a

00:45:00,360 --> 00:45:05,520
living yeah and I think that's a matter

00:45:04,920 --> 00:45:07,320
of taste

00:45:05,520 --> 00:45:09,690
I would rather write this than write the

00:45:07,320 --> 00:45:11,400
equivalent C program if you if you would

00:45:09,690 --> 00:45:13,740
I didn't sure I didn't say you should

00:45:11,400 --> 00:45:15,480
write it and see for me the end game

00:45:13,740 --> 00:45:17,040
isn't me writing a ton of code like this

00:45:15,480 --> 00:45:20,040
though it's using like meta programming

00:45:17,040 --> 00:45:21,810
macros staged programming some of the

00:45:20,040 --> 00:45:23,640
code generation techniques that our

00:45:21,810 --> 00:45:27,120
community is really really good at and

00:45:23,640 --> 00:45:31,200
that C macros are not good right to

00:45:27,120 --> 00:45:33,360
write some of this for us and try to

00:45:31,200 --> 00:45:34,980
have like the the power of unsafe

00:45:33,360 --> 00:45:37,350
techniques with some level of

00:45:34,980 --> 00:45:39,420
verification the other direction you go

00:45:37,350 --> 00:45:42,180
you could go something like ATS do you

00:45:39,420 --> 00:45:44,010
know ATS it's like an ml variant with a

00:45:42,180 --> 00:45:46,530
proof language for like checking your

00:45:44,010 --> 00:45:49,170
array bounds and verifying all the the

00:45:46,530 --> 00:45:50,490
bounds checking statically that's a

00:45:49,170 --> 00:45:52,290
really interesting approach that you

00:45:50,490 --> 00:45:55,920
could try to model at the type level and

00:45:52,290 --> 00:45:58,170
verify statically I mean there's also

00:45:55,920 --> 00:46:00,240
claims that branch predictors on modern

00:45:58,170 --> 00:46:01,890
hardware are so fast now that you

00:46:00,240 --> 00:46:04,560
actually can check all your array

00:46:01,890 --> 00:46:07,650
accesses for free basically it's like

00:46:04,560 --> 00:46:10,920
less than a 5% overhead so it's like a

00:46:07,650 --> 00:46:13,470
lot of trade-offs certainly but I feel

00:46:10,920 --> 00:46:15,450
like um more than anything it might just

00:46:13,470 --> 00:46:17,310
be that C is calcified right

00:46:15,450 --> 00:46:19,350
it was standardized 40 years ago the

00:46:17,310 --> 00:46:21,270
standard is broken POSIX was

00:46:19,350 --> 00:46:24,390
standardized 20 years ago that standard

00:46:21,270 --> 00:46:26,520
is broken with Scala native we could rip

00:46:24,390 --> 00:46:28,230
out and replace all the broken parts of

00:46:26,520 --> 00:46:30,450
the user space of the standard library

00:46:28,230 --> 00:46:32,160
right all the string stuff that's broken

00:46:30,450 --> 00:46:34,470
that's not in the kernel we could just

00:46:32,160 --> 00:46:36,300
rewrite all of that that's that's where

00:46:34,470 --> 00:46:38,490
where my head starts going what if we

00:46:36,300 --> 00:46:40,730
rewrote light and replaced all the

00:46:38,490 --> 00:46:44,040
string handling things to actually like

00:46:40,730 --> 00:46:46,200
track how big strings are like then you

00:46:44,040 --> 00:46:49,980
might actually have a much easier time

00:46:46,200 --> 00:46:51,870
of writing like systems programs that

00:46:49,980 --> 00:46:53,430
are known to be safe in a static way I

00:46:51,870 --> 00:46:54,630
don't I could I could ramble about this

00:46:53,430 --> 00:46:57,180
for a while because I'm writing a book

00:46:54,630 --> 00:46:59,940
and it's my life sorry does that sort of

00:46:57,180 --> 00:47:02,520
get at your question cool

00:46:59,940 --> 00:47:04,620
any other questions ok thank you babe

00:47:02,520 --> 00:47:07,830
I'm afraid only one more question I

00:47:04,620 --> 00:47:18,330
don't know which hand was there first

00:47:07,830 --> 00:47:22,560
u.s. or yours I was just wondering what

00:47:18,330 --> 00:47:24,480
the garbage collection situation is like

00:47:22,560 --> 00:47:27,120
as far as I know garbage collection is

00:47:24,480 --> 00:47:29,070
optional you're not forced to or not

00:47:27,120 --> 00:47:31,370
forced out of it but the last time I

00:47:29,070 --> 00:47:35,160
heard about it

00:47:31,370 --> 00:47:36,810
it was with a caveat that it's not like

00:47:35,160 --> 00:47:38,880
as production-ready

00:47:36,810 --> 00:47:41,940
has on the JVM or something like that I

00:47:38,880 --> 00:47:43,590
mean the number of human engineering

00:47:41,940 --> 00:47:45,300
hours that have gone into the JVM is

00:47:43,590 --> 00:47:48,300
various garbage collectors is pretty

00:47:45,300 --> 00:47:50,910
enormous the initial release of Scala

00:47:48,300 --> 00:47:52,350
native just had the Boehm garbage

00:47:50,910 --> 00:47:54,090
collector which is a very traditional

00:47:52,350 --> 00:47:57,300
and conservative one which wasn't

00:47:54,090 --> 00:47:59,880
awesome that worked I think oh not to

00:47:57,300 --> 00:48:03,210
added a new MX garbage collector the

00:47:59,880 --> 00:48:05,040
dennis wrote which is pretty good I'm

00:48:03,210 --> 00:48:06,840
not an expert on garbage collector

00:48:05,040 --> 00:48:09,600
internals but Dennis does have a talk

00:48:06,840 --> 00:48:11,550
maybe from Scala days a year to ago in

00:48:09,600 --> 00:48:13,140
which he has like really good

00:48:11,550 --> 00:48:15,869
performance numbers on

00:48:13,140 --> 00:48:18,000
the new GC performs that I found pretty

00:48:15,869 --> 00:48:20,940
compelling and it is like a pretty

00:48:18,000 --> 00:48:22,589
cutting edge like like up-to-date

00:48:20,940 --> 00:48:25,589
research kind of kind of garbage

00:48:22,589 --> 00:48:28,079
collector that being said the ability to

00:48:25,589 --> 00:48:30,029
have a bright line between hey here's my

00:48:28,079 --> 00:48:31,650
code that uses garbage collection here

00:48:30,029 --> 00:48:37,069
here's the code that doesn't is the

00:48:31,650 --> 00:48:37,069
thing that I get excited about yeah cool

00:48:37,079 --> 00:48:41,610
okay thank you very much sorry for being

00:48:39,390 --> 00:48:45,679
the bad guy to cut the questions but

00:48:41,610 --> 00:48:45,679

YouTube URL: https://www.youtube.com/watch?v=cnNDLRgSKOY


