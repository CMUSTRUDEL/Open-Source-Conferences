Title: Six steps from zero to IDE by Olafur Pall Geirsson
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-7426-six-steps-from-zero-to-ide.html
Captions: 
	00:00:04,620 --> 00:00:13,830
hello everybody I'm Olaf and today we're

00:00:09,210 --> 00:00:14,910
gonna be talking about IDs IDs are we

00:00:13,830 --> 00:00:16,170
use them every day and they're

00:00:14,910 --> 00:00:20,550
incredibly important for our

00:00:16,170 --> 00:00:23,179
productivity but also I think the

00:00:20,550 --> 00:00:26,550
general knowledge of how they work is

00:00:23,179 --> 00:00:29,310
quite long usually it just doesn't work

00:00:26,550 --> 00:00:30,869
or it works and when it works it's

00:00:29,310 --> 00:00:32,669
amazing because we were very productive

00:00:30,869 --> 00:00:36,990
we can call a lot but when it doesn't

00:00:32,669 --> 00:00:38,340
work it's it's a ruined day so I'm

00:00:36,990 --> 00:00:39,960
hoping that at the end of this talk that

00:00:38,340 --> 00:00:43,410
you'll have a bit more understanding

00:00:39,960 --> 00:00:46,320
maybe of how an ID works and especially

00:00:43,410 --> 00:00:49,290
how IDs in of the future for the next

00:00:46,320 --> 00:00:51,060
5-10 years will work because I believe

00:00:49,290 --> 00:00:53,550
we're in a really exciting area now

00:00:51,060 --> 00:00:57,900
where the design and architecture of IDs

00:00:53,550 --> 00:01:00,060
is changing quite a lot so briefly about

00:00:57,900 --> 00:01:03,630
me I'm a software developer at the Scala

00:01:00,060 --> 00:01:05,970
center the author and maintain enough

00:01:03,630 --> 00:01:08,670
maintainer of scale of Mt Scala fix

00:01:05,970 --> 00:01:11,729
kalimera which are refactoring

00:01:08,670 --> 00:01:14,909
reformatting meta programming tools for

00:01:11,729 --> 00:01:16,859
Scala and my mission is sort of I want

00:01:14,909 --> 00:01:21,749
to enable people to focus on on building

00:01:16,859 --> 00:01:23,100
apps not tools because when the tools

00:01:21,749 --> 00:01:25,770
are really great we can focus on

00:01:23,100 --> 00:01:27,090
building better you know business

00:01:25,770 --> 00:01:28,859
applications etcetera I think that's

00:01:27,090 --> 00:01:31,319
really important and we don't waste much

00:01:28,859 --> 00:01:35,189
time on on debating whether we should

00:01:31,319 --> 00:01:38,039
have a trailing comma or not so are you

00:01:35,189 --> 00:01:39,740
familiar with the Scala Center some

00:01:38,039 --> 00:01:43,950
people in the audience some haven't so

00:01:39,740 --> 00:01:46,289
we're not we're a non-profit at EPFL the

00:01:43,950 --> 00:01:49,139
same quarter where martin radowski's lab

00:01:46,289 --> 00:01:52,829
is and our mission is to work on open

00:01:49,139 --> 00:01:55,079
source and education and we maintained

00:01:52,829 --> 00:01:57,959
the cursor of course on functional

00:01:55,079 --> 00:01:59,579
programming and we we do quite a lot of

00:01:57,959 --> 00:02:02,429
open source and primarily with the

00:01:59,579 --> 00:02:05,189
tooling at the moment so we just had a

00:02:02,429 --> 00:02:10,380
talk from Martin and Jorge my colleagues

00:02:05,189 --> 00:02:12,599
in the previous session so I sort of got

00:02:10,380 --> 00:02:14,760
involved in the tooling with Scala fmt

00:02:12,599 --> 00:02:16,470
which is a code formatter over two years

00:02:14,760 --> 00:02:18,760
ago and

00:02:16,470 --> 00:02:20,740
then I then I joined the center to work

00:02:18,760 --> 00:02:23,470
on Scala fix which is pretty much almost

00:02:20,740 --> 00:02:28,960
the same thing it just reads cold and

00:02:23,470 --> 00:02:31,090
then spits out new code and that's sort

00:02:28,960 --> 00:02:33,790
of how I got involved into AI DS because

00:02:31,090 --> 00:02:35,340
I've been doing formatting and then I've

00:02:33,790 --> 00:02:38,200
been doing refactoring and I thought

00:02:35,340 --> 00:02:42,100
well I might as well try and get

00:02:38,200 --> 00:02:45,670
involved in doing editor stuff and I was

00:02:42,100 --> 00:02:49,150
sort of excited when I saw this comment

00:02:45,670 --> 00:02:50,710
on reddit Scala ID situation is quite

00:02:49,150 --> 00:02:52,300
possibly the worst out of all the

00:02:50,710 --> 00:02:54,160
industrial languages in existence

00:02:52,300 --> 00:02:56,650
they're all terrible especially via

00:02:54,160 --> 00:02:57,540
Skoda Atem just use IntelliJ and hope

00:02:56,650 --> 00:03:01,210
for the best

00:02:57,540 --> 00:03:03,820
so I think it's a great coat because

00:03:01,210 --> 00:03:06,280
partly it's it's kind of accurate on the

00:03:03,820 --> 00:03:07,990
recommendation I think if someone asked

00:03:06,280 --> 00:03:11,620
me what do I do with IDs and Scala to

00:03:07,990 --> 00:03:12,970
add to say just use IntelliJ but you

00:03:11,620 --> 00:03:14,440
know you may have some issues but that's

00:03:12,970 --> 00:03:16,540
definitely by far the best option that

00:03:14,440 --> 00:03:18,430
you have today and I think it's also

00:03:16,540 --> 00:03:19,720
funny this this thing because it says

00:03:18,430 --> 00:03:22,540
they're all terrible especially via

00:03:19,720 --> 00:03:24,550
Skoda Robin because if you ask me like

00:03:22,540 --> 00:03:26,290
why where do you see it going in the

00:03:24,550 --> 00:03:27,490
next two three years I think they're

00:03:26,290 --> 00:03:31,240
actually going to become really really

00:03:27,490 --> 00:03:34,209
good and contenders so I think it's a

00:03:31,240 --> 00:03:36,580
fun quote so I thought let's build an ID

00:03:34,209 --> 00:03:40,510
I mean come on how hard can it be

00:03:36,580 --> 00:03:42,310
it's you know we don't really need

00:03:40,510 --> 00:03:43,750
IntelliJ that's sort of heavy let's

00:03:42,310 --> 00:03:46,030
let's build something more lightweight

00:03:43,750 --> 00:03:49,150
something that is fast and snappy and

00:03:46,030 --> 00:03:52,080
and we don't really need so many

00:03:49,150 --> 00:03:54,730
features do it I mean we just need some

00:03:52,080 --> 00:03:56,650
basic features I mean we we have our

00:03:54,730 --> 00:04:01,390
editor some people have sublime some

00:03:56,650 --> 00:04:04,959
people have been we have our own build

00:04:01,390 --> 00:04:07,090
tool so it should work with SBT but some

00:04:04,959 --> 00:04:09,670
people have of Gradle some people have

00:04:07,090 --> 00:04:12,459
maven there's a lot of new build tools

00:04:09,670 --> 00:04:15,670
coming around so we wanted to work with

00:04:12,459 --> 00:04:17,290
those two and then we want Diagnostics I

00:04:15,670 --> 00:04:19,060
mean we don't want any red squiggles

00:04:17,290 --> 00:04:20,560
when there the program is totally fine

00:04:19,060 --> 00:04:22,790
I think everyone have sort of gotten

00:04:20,560 --> 00:04:24,440
sick and tired of that and

00:04:22,790 --> 00:04:27,440
and when there are errors we actually

00:04:24,440 --> 00:04:29,240
want them to be on the editor too so so

00:04:27,440 --> 00:04:33,160
I mean it's not a tall order is it

00:04:29,240 --> 00:04:36,500
common and to be honest I think actually

00:04:33,160 --> 00:04:39,800
you can implement an ID today like in

00:04:36,500 --> 00:04:41,660
one day that does just this by writing

00:04:39,800 --> 00:04:44,330
your reg X that scrapes like the console

00:04:41,660 --> 00:04:47,570
logs and and puts the diagnosis into the

00:04:44,330 --> 00:04:49,130
editor so I don't really think when

00:04:47,570 --> 00:04:50,960
people say they mean like I want a

00:04:49,130 --> 00:04:53,240
lightweight editor they mean more than

00:04:50,960 --> 00:04:57,860
this they mean more than just the

00:04:53,240 --> 00:04:59,900
Diagnostics so the pretty basic features

00:04:57,860 --> 00:05:04,340
I think also include in many people's

00:04:59,900 --> 00:05:07,180
opinion go to definition and it turns

00:05:04,340 --> 00:05:09,620
out that go to definition is not that

00:05:07,180 --> 00:05:12,080
small of a feature it's actually a group

00:05:09,620 --> 00:05:13,940
of features you want to browse between

00:05:12,080 --> 00:05:16,730
your sources and you have multiple

00:05:13,940 --> 00:05:19,670
modules you have main and test and then

00:05:16,730 --> 00:05:21,200
you have dependencies you want to go

00:05:19,670 --> 00:05:22,760
into your scholar dependencies but you

00:05:21,200 --> 00:05:25,640
also want to work your java dependencies

00:05:22,760 --> 00:05:27,110
and if you've worked in IntelliJ you'll

00:05:25,640 --> 00:05:29,860
notice that when there are no sources

00:05:27,110 --> 00:05:34,070
you'll just CD compiled code as well

00:05:29,860 --> 00:05:35,480
which is sometimes really helpful so go

00:05:34,070 --> 00:05:37,660
to definition is not just one feature

00:05:35,480 --> 00:05:39,770
it's actually a group of features and

00:05:37,660 --> 00:05:44,470
according to many people it's a pretty

00:05:39,770 --> 00:05:46,880
basic feature so after that I think the

00:05:44,470 --> 00:05:49,940
second sort of important feature that

00:05:46,880 --> 00:05:51,800
you expect is a completions they're a

00:05:49,940 --> 00:05:54,440
great way to sort of navigate a library

00:05:51,800 --> 00:05:58,010
you know what you can write next save a

00:05:54,440 --> 00:06:00,470
couple keystrokes etc and just like with

00:05:58,010 --> 00:06:03,050
the definition completions are not a

00:06:00,470 --> 00:06:05,810
single feature either although they may

00:06:03,050 --> 00:06:07,220
look like that on the surface the thing

00:06:05,810 --> 00:06:08,840
is when you complete you can complete

00:06:07,220 --> 00:06:10,310
something from the scope that is if

00:06:08,840 --> 00:06:13,370
you're just writing an identifier that's

00:06:10,310 --> 00:06:16,460
completely brought out out of the scope

00:06:13,370 --> 00:06:18,230
and but if it's not in scope we'd expect

00:06:16,460 --> 00:06:20,540
it to auto import it from the from the

00:06:18,230 --> 00:06:23,990
class path from our dependencies and

00:06:20,540 --> 00:06:25,550
those are different and then we also

00:06:23,990 --> 00:06:27,560
want type members which is when we do

00:06:25,550 --> 00:06:29,170
like the dot and then it lists out the

00:06:27,560 --> 00:06:33,760
methods that are part of your class

00:06:29,170 --> 00:06:35,750
that's a completely separate feature and

00:06:33,760 --> 00:06:36,440
sometimes they're not even members of

00:06:35,750 --> 00:06:39,110
the class with a

00:06:36,440 --> 00:06:40,700
our extension methods in Scala and those

00:06:39,110 --> 00:06:42,470
are driven by implicit conversions which

00:06:40,700 --> 00:06:44,870
rely on on fairly advanced sort of

00:06:42,470 --> 00:06:48,580
language semantics and are difficult to

00:06:44,870 --> 00:06:55,370
reproduce so so completions are also

00:06:48,580 --> 00:06:57,710
pretty basic feature and finally I mean

00:06:55,370 --> 00:07:00,230
not the advanced refactorings we but

00:06:57,710 --> 00:07:03,350
renamed it's pretty basic I mean I think

00:07:00,230 --> 00:07:06,650
that we can include that in our pretty

00:07:03,350 --> 00:07:07,910
basic feature list and organize import

00:07:06,650 --> 00:07:09,440
is probably one of the most common

00:07:07,910 --> 00:07:12,980
things you do in IntelliJ you want to

00:07:09,440 --> 00:07:15,830
remove the unused imports you want to

00:07:12,980 --> 00:07:19,040
sort them in the in alphabetical order

00:07:15,830 --> 00:07:20,510
etc and then one thing which is sort of

00:07:19,040 --> 00:07:22,400
common in Scala it's really nice that it

00:07:20,510 --> 00:07:26,960
can help you sort of insert the inferred

00:07:22,400 --> 00:07:31,640
types when you when you just have like a

00:07:26,960 --> 00:07:34,700
large expression etc so when we sort of

00:07:31,640 --> 00:07:36,230
drive start writing out the the check

00:07:34,700 --> 00:07:38,630
list for a pretty basic idea it's

00:07:36,230 --> 00:07:43,880
actually maybe not so basic after all as

00:07:38,630 --> 00:07:45,980
you can see so but in this talk I'm

00:07:43,880 --> 00:07:48,260
gonna show how we can implement all six

00:07:45,980 --> 00:07:50,990
of them and that will be the six steps

00:07:48,260 --> 00:07:52,520
from zero to ID so I'm gonna start

00:07:50,990 --> 00:07:55,580
really quickly by just doing actually a

00:07:52,520 --> 00:08:02,300
demo from a project that's called metals

00:07:55,580 --> 00:08:03,830
and that I started last November when a

00:08:02,300 --> 00:08:05,540
friend of mine asked me to say like hey

00:08:03,830 --> 00:08:07,580
I want to get Scala fix into the editor

00:08:05,540 --> 00:08:10,910
just for linting he just wanted

00:08:07,580 --> 00:08:12,860
diagnostics and he sort of sent me a

00:08:10,910 --> 00:08:15,230
repo and he said here's the build press

00:08:12,860 --> 00:08:18,770
f5 it'll open up this code in debug mode

00:08:15,230 --> 00:08:21,050
and do your magic so that's where we

00:08:18,770 --> 00:08:24,110
started and and we got diagnostic sort

00:08:21,050 --> 00:08:25,820
of like these ones here saying stuff

00:08:24,110 --> 00:08:26,780
that these are not compile errors but

00:08:25,820 --> 00:08:29,000
there's something that you could

00:08:26,780 --> 00:08:31,820
configure Scala fix to say report an

00:08:29,000 --> 00:08:34,510
error if you use option gap and then vs

00:08:31,820 --> 00:08:38,419
code would would sort of error on that

00:08:34,510 --> 00:08:40,900
so this is not a published plug-in

00:08:38,419 --> 00:08:44,750
because it still this sort of prototype

00:08:40,900 --> 00:08:47,810
status still but I'm gonna show you sort

00:08:44,750 --> 00:08:49,670
of brief briefly what it can do so here

00:08:47,810 --> 00:08:53,000
I have opened the project spire we

00:08:49,670 --> 00:08:55,630
she's a alphanumerical we actually got

00:08:53,000 --> 00:08:57,950
to talk about spire today today and

00:08:55,630 --> 00:09:01,310
first of all we'll notice that we have

00:08:57,950 --> 00:09:02,870
the type information on hover and not

00:09:01,310 --> 00:09:04,850
only just the type we actually see the

00:09:02,870 --> 00:09:11,360
full signature information including the

00:09:04,850 --> 00:09:14,720
modifiers etc and then we can go to

00:09:11,360 --> 00:09:16,790
definition and this is for a dependency

00:09:14,720 --> 00:09:22,160
this is in Scala check this is not in

00:09:16,790 --> 00:09:24,320
the spire repo and then we can rename

00:09:22,160 --> 00:09:25,340
stuff which is cool and I think we're

00:09:24,320 --> 00:09:27,590
sorry one thing that is sort of

00:09:25,340 --> 00:09:29,150
important this definition it's not only

00:09:27,590 --> 00:09:30,590
what I've shown you now it's also being

00:09:29,150 --> 00:09:33,020
able to tolerate programs that are

00:09:30,590 --> 00:09:34,490
completely broken so now I'm just gonna

00:09:33,020 --> 00:09:38,360
start ruining the code a bit I'm gonna

00:09:34,490 --> 00:09:39,920
do here I did a bad copy paste I can

00:09:38,360 --> 00:09:42,890
still navigate and I think that's sort

00:09:39,920 --> 00:09:44,300
of really important and in fact you can

00:09:42,890 --> 00:09:47,600
do it so badly I think we do it better

00:09:44,300 --> 00:09:52,480
than IntelliJ because it's really really

00:09:47,600 --> 00:09:56,720
really fuzzy yeah that one was read so

00:09:52,480 --> 00:10:00,050
that's cool and then also we can jump

00:09:56,720 --> 00:10:03,830
into Java and what's really cool is that

00:10:00,050 --> 00:10:06,590
we jump into Java and now it looks like

00:10:03,830 --> 00:10:07,820
I've written a job ID as well but this

00:10:06,590 --> 00:10:11,270
is just being handled by the Java

00:10:07,820 --> 00:10:19,390
language server so it plays out really

00:10:11,270 --> 00:10:19,390
nicely so back to here slowed down a bit

00:10:25,100 --> 00:10:31,829
so the agenda of the talk is pretty much

00:10:28,560 --> 00:10:34,560
a language server protocol which is the

00:10:31,829 --> 00:10:36,510
sort of thing that is the spark for a

00:10:34,560 --> 00:10:37,560
lot of exciting development that's

00:10:36,510 --> 00:10:41,010
happening right now

00:10:37,560 --> 00:10:45,060
in an IDs also for Scala and many other

00:10:41,010 --> 00:10:47,310
languages and I'm gonna briefly show you

00:10:45,060 --> 00:10:49,529
the the current zoo of language servers

00:10:47,310 --> 00:10:51,839
for Scala because there's it's become so

00:10:49,529 --> 00:10:54,000
easy to do some of the things that I

00:10:51,839 --> 00:10:54,899
just showed you that everyone are sort

00:10:54,000 --> 00:10:59,220
of experimenting with different

00:10:54,899 --> 00:11:01,170
approaches and then I'm gonna talk to

00:10:59,220 --> 00:11:03,740
about the build server protocol which is

00:11:01,170 --> 00:11:05,970
a protocol that me and my colleagues

00:11:03,740 --> 00:11:07,260
wrote up because we felt that they were

00:11:05,970 --> 00:11:12,839
missing parts in the language of a

00:11:07,260 --> 00:11:14,250
protocol and then I'll wrap up so the

00:11:12,839 --> 00:11:16,769
language server protocol is sort of

00:11:14,250 --> 00:11:18,300
inspired by this challenge here that we

00:11:16,769 --> 00:11:20,130
want to do IDs and we want to make them

00:11:18,300 --> 00:11:21,899
work for every language in every editor

00:11:20,130 --> 00:11:23,370
so if you want to do scala

00:11:21,899 --> 00:11:25,800
you'll have to do a custom integration

00:11:23,370 --> 00:11:28,760
for vim for sublime for vias code and

00:11:25,800 --> 00:11:31,290
then the next language needs to repeat

00:11:28,760 --> 00:11:32,730
and this is of course not great

00:11:31,290 --> 00:11:34,350
especially because typically people

00:11:32,730 --> 00:11:35,819
doing editors they're low on resources

00:11:34,350 --> 00:11:37,589
and the ones different languages are

00:11:35,819 --> 00:11:40,560
also low on resources so we want to say

00:11:37,589 --> 00:11:43,860
it's work and the language sort of

00:11:40,560 --> 00:11:45,990
protocol is the idea is that we just

00:11:43,860 --> 00:11:47,399
specify the communication protocol

00:11:45,990 --> 00:11:49,110
between an editor and the language

00:11:47,399 --> 00:11:52,470
server and then you can just implement

00:11:49,110 --> 00:11:54,060
it once so them implements the language

00:11:52,470 --> 00:11:57,480
server protocol client then Scala

00:11:54,060 --> 00:11:58,889
implements a server and then for sublime

00:11:57,480 --> 00:12:02,160
and then you can reuse the same server

00:11:58,889 --> 00:12:04,050
for the same for different editors and

00:12:02,160 --> 00:12:05,880
and this is completely it started maybe

00:12:04,050 --> 00:12:08,130
two three years ago and and now it's

00:12:05,880 --> 00:12:10,680
totally exploded their language servers

00:12:08,130 --> 00:12:13,250
for over 30 languages and and all of the

00:12:10,680 --> 00:12:15,930
major editors there's even work to do

00:12:13,250 --> 00:12:17,610
both clients for IntelliJ and also

00:12:15,930 --> 00:12:20,279
servers because you can use IntelliJ so

00:12:17,610 --> 00:12:25,319
there's a lot of activity ongoing right

00:12:20,279 --> 00:12:29,069
now and the the architecture is that the

00:12:25,319 --> 00:12:31,589
editor sends requests to servers you can

00:12:29,069 --> 00:12:34,410
have multiple servers running you saw in

00:12:31,589 --> 00:12:36,390
my demo I was jumping to Java

00:12:34,410 --> 00:12:39,690
which then I was able to browse the Java

00:12:36,390 --> 00:12:41,970
code with definition so then essentially

00:12:39,690 --> 00:12:43,830
it was in my Scala file came back in the

00:12:41,970 --> 00:12:46,680
new browse to the Java server and it's

00:12:43,830 --> 00:12:48,600
so seamless it's so natural when you try

00:12:46,680 --> 00:12:49,950
it in the editor it's almost magical

00:12:48,600 --> 00:12:51,150
when you think that like all of the

00:12:49,950 --> 00:12:54,330
infrastructure that's on going behind

00:12:51,150 --> 00:12:58,800
the scenes and underneath sort of on the

00:12:54,330 --> 00:13:00,270
wire it's just sending JSON RPC messages

00:12:58,800 --> 00:13:03,840
back and forth on practically every

00:13:00,270 --> 00:13:05,970
keystroke and then you're thinking now I

00:13:03,840 --> 00:13:08,730
know why vias code is so slow it's just

00:13:05,970 --> 00:13:10,860
sending huge amounts of JSON blobs back

00:13:08,730 --> 00:13:13,440
and forth all the time

00:13:10,860 --> 00:13:16,890
turns out this is just completely false

00:13:13,440 --> 00:13:18,420
it's absolutely natural the overhead of

00:13:16,890 --> 00:13:21,090
sending these messages back and forth on

00:13:18,420 --> 00:13:22,860
every single keystroke there's a guy at

00:13:21,090 --> 00:13:26,010
Google who's who's doing a writing

00:13:22,860 --> 00:13:27,570
fujian operator operating system and in

00:13:26,010 --> 00:13:31,050
the spare time he's working on an editor

00:13:27,570 --> 00:13:32,220
called Shi which is an editor for the

00:13:31,050 --> 00:13:36,810
next 20 years with uncompromising

00:13:32,220 --> 00:13:38,520
performance and the the the architecture

00:13:36,810 --> 00:13:40,530
he says that he believes for the future

00:13:38,520 --> 00:13:42,680
of editors it's totally different than

00:13:40,530 --> 00:13:45,420
the architecture for editors in the past

00:13:42,680 --> 00:13:47,040
and he believes that it should be sort

00:13:45,420 --> 00:13:49,920
of client-server architecture the core

00:13:47,040 --> 00:13:51,680
does not even have a GUI and and the

00:13:49,920 --> 00:13:53,880
client should provide the GUI and

00:13:51,680 --> 00:13:56,820
between the core in the front and you

00:13:53,880 --> 00:14:00,480
communicate via JSON RPC which is just

00:13:56,820 --> 00:14:02,850
as the same architecture as LSP so I

00:14:00,480 --> 00:14:05,160
feel like maybe in 10 years from now

00:14:02,850 --> 00:14:06,810
there will be just 10 layers of servers

00:14:05,160 --> 00:14:08,970
and protocols talking back and forth all

00:14:06,810 --> 00:14:11,190
the way up which is brilliant because

00:14:08,970 --> 00:14:12,720
you can write the core editor in rust

00:14:11,190 --> 00:14:14,760
and a language server in Scala and

00:14:12,720 --> 00:14:18,570
everything just communicates and

00:14:14,760 --> 00:14:21,450
interoperate really nicely and this guy

00:14:18,570 --> 00:14:23,850
he promised uncompromising performance

00:14:21,450 --> 00:14:25,350
so he profiled and traced very

00:14:23,850 --> 00:14:27,960
accurately down what the overhead of

00:14:25,350 --> 00:14:29,370
each step in this pipeline is and it

00:14:27,960 --> 00:14:30,930
turns out that json.parse is

00:14:29,370 --> 00:14:32,910
microseconds here so it's it's

00:14:30,930 --> 00:14:36,540
completely inedible and it turns out

00:14:32,910 --> 00:14:38,310
that like rendering text is lower so so

00:14:36,540 --> 00:14:40,560
he started optimizing how to render text

00:14:38,310 --> 00:14:43,920
with open G and and stuff like that so I

00:14:40,560 --> 00:14:46,200
think it sort of tests our intuition of

00:14:43,920 --> 00:14:47,530
what is fast and what is slow IDs are

00:14:46,200 --> 00:14:50,200
sort of exciting because

00:14:47,530 --> 00:14:53,890
they definitely there's a stress license

00:14:50,200 --> 00:14:55,660
latency and and and it's it's not always

00:14:53,890 --> 00:14:59,650
intuitive what is important or what is

00:14:55,660 --> 00:15:01,690
hard or what is slow etc so this was me

00:14:59,650 --> 00:15:03,400
back in November I I was sort of reading

00:15:01,690 --> 00:15:05,190
up online trying out of their language

00:15:03,400 --> 00:15:07,390
servers and I thought about this is

00:15:05,190 --> 00:15:10,180
we're gonna have such an amazing future

00:15:07,390 --> 00:15:17,910
man and and I was like how do I sign up

00:15:10,180 --> 00:15:21,100
I'm gonna do an LSP language server yeah

00:15:17,910 --> 00:15:22,450
so in in the--in practice I feel that

00:15:21,100 --> 00:15:24,850
this is sort of it

00:15:22,450 --> 00:15:27,190
LSP is amazing like don't get me wrong

00:15:24,850 --> 00:15:29,020
it's it's it's definitely the building

00:15:27,190 --> 00:15:30,790
block that is making it so it's it's

00:15:29,020 --> 00:15:33,460
lowered the barrier of entry so much for

00:15:30,790 --> 00:15:38,140
doing IDs incredibly but there's still a

00:15:33,460 --> 00:15:39,580
huge amount of work to do so the rest of

00:15:38,140 --> 00:15:41,920
the talk I'm practically gonna show you

00:15:39,580 --> 00:15:45,280
a bit more like why the owl is kind of

00:15:41,920 --> 00:15:46,930
difficult to draw by going through each

00:15:45,280 --> 00:15:51,160
of the methods and I will speed sort of

00:15:46,930 --> 00:15:52,870
the core protocol messages explain them

00:15:51,160 --> 00:15:56,050
the architecture how I've implemented

00:15:52,870 --> 00:15:57,400
them in metals and then you'll maybe see

00:15:56,050 --> 00:15:59,020
that all of the different components

00:15:57,400 --> 00:16:01,270
that need to play together to make this

00:15:59,020 --> 00:16:03,100
work so beware there's going to be quite

00:16:01,270 --> 00:16:07,230
a few sequence diagrams but I'll try to

00:16:03,100 --> 00:16:09,940
keep it light so the primary one is

00:16:07,230 --> 00:16:14,320
published Diagnostics we want to set

00:16:09,940 --> 00:16:17,080
read Diagnostics as we type this is like

00:16:14,320 --> 00:16:18,520
a very basic feature it's the simplest

00:16:17,080 --> 00:16:22,360
sort of obvious feature that you'd like

00:16:18,520 --> 00:16:24,700
to have but it's very hard if you want

00:16:22,360 --> 00:16:26,380
so you have this endless bait between a

00:16:24,700 --> 00:16:28,390
challenge between trading off

00:16:26,380 --> 00:16:29,950
correctness and latency you sort of

00:16:28,390 --> 00:16:31,540
wanted to get the Diagnostics right away

00:16:29,950 --> 00:16:34,480
as you type but you don't want them ever

00:16:31,540 --> 00:16:37,450
to be wrong so one common way to do it

00:16:34,480 --> 00:16:40,930
is to use the compiler depend on it as a

00:16:37,450 --> 00:16:43,750
library and then run it on the buffer

00:16:40,930 --> 00:16:46,330
without before you save all the time and

00:16:43,750 --> 00:16:49,570
this is the mode where I will be using

00:16:46,330 --> 00:16:52,000
the word presentation compiler so I'm

00:16:49,570 --> 00:16:53,440
I've tried it and I've integrated with

00:16:52,000 --> 00:16:55,660
it and and I felt that it was sort of

00:16:53,440 --> 00:16:57,910
difficult to get it working for large

00:16:55,660 --> 00:17:00,370
builds multiple modules longer running

00:16:57,910 --> 00:17:01,270
sessions so the the architecture I

00:17:00,370 --> 00:17:04,510
personally believe

00:17:01,270 --> 00:17:06,760
is the way forward to do accurate

00:17:04,510 --> 00:17:09,490
Diagnostics they're always in sync with

00:17:06,760 --> 00:17:13,770
your build that's just to do it in the

00:17:09,490 --> 00:17:17,220
build and that what we have here is then

00:17:13,770 --> 00:17:21,130
to only trigger it as you save the file

00:17:17,220 --> 00:17:22,570
which may feel may be annoying if you're

00:17:21,130 --> 00:17:25,780
used to working in mentality you get it

00:17:22,570 --> 00:17:28,240
as you type if you like that then you

00:17:25,780 --> 00:17:30,130
can use IntelliJ I think that's fine but

00:17:28,240 --> 00:17:32,110
I think for having completely accurate

00:17:30,130 --> 00:17:33,970
and it's sort of nice that you control

00:17:32,110 --> 00:17:37,480
when type checking occurs you do it on

00:17:33,970 --> 00:17:40,120
save and so what happens here is that

00:17:37,480 --> 00:17:43,120
SBT implements its own server that also

00:17:40,120 --> 00:17:45,280
speaks JSON RPC with its own custom

00:17:43,120 --> 00:17:48,040
method called SBT exact so it's pretty

00:17:45,280 --> 00:17:51,340
cool metals can as you save it sends a

00:17:48,040 --> 00:17:55,270
JSON RPC to the build tool asking for a

00:17:51,340 --> 00:17:56,890
request to compile and then SBT

00:17:55,270 --> 00:18:00,730
publishes the diagnostics back and forth

00:17:56,890 --> 00:18:03,310
so I think this is working really well

00:18:00,730 --> 00:18:04,150
I'm really excited about SBT server so

00:18:03,310 --> 00:18:10,270
if you're still on

00:18:04,150 --> 00:18:11,620
0:13 I recommend you upgrade the next

00:18:10,270 --> 00:18:12,940
one that we wanted to solve this

00:18:11,620 --> 00:18:18,610
definition right that's a pretty basic

00:18:12,940 --> 00:18:20,320
feature so in the gif here we see quite

00:18:18,610 --> 00:18:22,510
a few things happening there we go and

00:18:20,320 --> 00:18:25,360
jump to a local symbol inside of the

00:18:22,510 --> 00:18:27,880
block and there were jumping into Java

00:18:25,360 --> 00:18:33,460
dependency and there we going to Scala

00:18:27,880 --> 00:18:39,280
dependency so what is the sort of how do

00:18:33,460 --> 00:18:42,990
we deliver this thing robustly and

00:18:39,280 --> 00:18:46,630
that's a bit more involved than

00:18:42,990 --> 00:18:48,790
Diagnostics and it involves this

00:18:46,630 --> 00:18:52,240
absolutely tedious and horribly slow

00:18:48,790 --> 00:18:54,640
process that we all dread in IntelliJ is

00:18:52,240 --> 00:18:55,990
that we sort of have to index if you

00:18:54,640 --> 00:18:58,300
want to be able to provide definition

00:18:55,990 --> 00:18:59,710
that's fast in milliseconds we sort of

00:18:58,300 --> 00:19:01,900
need to know all of your dependencies

00:18:59,710 --> 00:19:05,260
and other locations of this that local

00:19:01,900 --> 00:19:07,600
global methods and classes etc so when

00:19:05,260 --> 00:19:09,070
you import the project and this happens

00:19:07,600 --> 00:19:11,110
when you open up vias called in a

00:19:09,070 --> 00:19:13,780
project it'll do a initialize handshake

00:19:11,110 --> 00:19:14,470
with the server this triggers the server

00:19:13,780 --> 00:19:17,650
to

00:19:14,470 --> 00:19:20,950
talk to the build query for some

00:19:17,650 --> 00:19:22,900
metadata such as dependencies which will

00:19:20,950 --> 00:19:25,419
it'll return back with like a list of

00:19:22,900 --> 00:19:28,750
sources jars that we can then feed into

00:19:25,419 --> 00:19:30,640
an index and then the index that does

00:19:28,750 --> 00:19:33,870
its work and this is while your CPU is

00:19:30,640 --> 00:19:37,030
choking and and and the fan is spinning

00:19:33,870 --> 00:19:38,860
and then once it's complete you can do

00:19:37,030 --> 00:19:40,240
definition request and then the index

00:19:38,860 --> 00:19:44,710
and pretty much just responded pretty

00:19:40,240 --> 00:19:48,309
fastly I think that we need an index

00:19:44,710 --> 00:19:51,100
there's different this is not completely

00:19:48,309 --> 00:19:54,880
agreed upon but some people want to do

00:19:51,100 --> 00:19:56,650
more on demand but I feel like it's if

00:19:54,880 --> 00:19:58,990
you do definition you don't expect that

00:19:56,650 --> 00:20:01,570
to start type checking a bunch of stuff

00:19:58,990 --> 00:20:04,179
and responding two seconds later and

00:20:01,570 --> 00:20:05,289
even though my second is too slow so if

00:20:04,179 --> 00:20:07,150
you want to do that really fast

00:20:05,289 --> 00:20:08,500
millisecond response times then you sort

00:20:07,150 --> 00:20:14,669
of have to know the answer before the

00:20:08,500 --> 00:20:17,860
user asks for it and in metals I use

00:20:14,669 --> 00:20:20,860
semantic DB which is an interchange it's

00:20:17,860 --> 00:20:22,210
a schema protobuf schema that includes a

00:20:20,860 --> 00:20:24,309
bunch of semantic information about

00:20:22,210 --> 00:20:26,289
source code that is produced when you

00:20:24,309 --> 00:20:30,450
compile an SBT it produces these files

00:20:26,289 --> 00:20:32,380
that are essentially is a list of

00:20:30,450 --> 00:20:34,030
objects that are shaped like this

00:20:32,380 --> 00:20:36,820
they'll say there's a string which is a

00:20:34,030 --> 00:20:39,010
symbol in this line number and and

00:20:36,820 --> 00:20:40,990
column I have a reference to that

00:20:39,010 --> 00:20:42,780
particular symbol so this is something

00:20:40,990 --> 00:20:45,580
that the bill produces as you compile

00:20:42,780 --> 00:20:48,640
and the the server just picks up these

00:20:45,580 --> 00:20:50,470
files and and uses them to respond and

00:20:48,640 --> 00:20:52,480
then what's really neat as you saw when

00:20:50,470 --> 00:20:55,870
I was removing code editing it and

00:20:52,480 --> 00:20:58,240
breaking it we can metals is able to do

00:20:55,870 --> 00:21:02,200
really well is to recover from you know

00:20:58,240 --> 00:21:04,120
make the most of an old snapshot which

00:21:02,200 --> 00:21:05,530
in my experience is turning out to be

00:21:04,120 --> 00:21:12,039
really really good it's almost better

00:21:05,530 --> 00:21:15,909
than what we have in IntelliJ so that

00:21:12,039 --> 00:21:19,570
was diagnostic no go to definition now

00:21:15,909 --> 00:21:22,770
we're on to completions and and there's

00:21:19,570 --> 00:21:25,799
quite a lot of stuff happening here

00:21:22,770 --> 00:21:28,240
first of all we see we do a scope lookup

00:21:25,799 --> 00:21:30,990
and when we completed a refactoring

00:21:28,240 --> 00:21:33,730
happens it inserts an import right there

00:21:30,990 --> 00:21:38,470
and then when we completed we do a dot

00:21:33,730 --> 00:21:39,730
and now we query for a member so it's so

00:21:38,470 --> 00:21:42,210
seamless it's something that you

00:21:39,730 --> 00:21:44,200
wouldn't even think about being hard

00:21:42,210 --> 00:21:47,080
there's quite a lot of moving pieces

00:21:44,200 --> 00:21:48,700
here there's quite a lot of stuff so how

00:21:47,080 --> 00:21:50,409
does this work and as you can imagine

00:21:48,700 --> 00:21:54,760
there's gonna be a sequence diagram and

00:21:50,409 --> 00:21:57,909
it's quite a big so the editor starts by

00:21:54,760 --> 00:22:01,299
doing a completion and that's the first

00:21:57,909 --> 00:22:04,480
one which turns out that because it's

00:22:01,299 --> 00:22:05,830
not inside of the scope we where we have

00:22:04,480 --> 00:22:09,820
to query the index which knows our

00:22:05,830 --> 00:22:11,409
dependencies and the index supports

00:22:09,820 --> 00:22:11,789
fuzzy searches because if we can see you

00:22:11,409 --> 00:22:15,880
it's like

00:22:11,789 --> 00:22:20,549
compro and that works for completion

00:22:15,880 --> 00:22:23,350
provider so the index responds with that

00:22:20,549 --> 00:22:25,419
but it's attached with the meaning that

00:22:23,350 --> 00:22:28,120
we have to refactor as well so it's

00:22:25,419 --> 00:22:30,429
really neat is that LSP supports a

00:22:28,120 --> 00:22:33,159
fairly advanced tree completion API

00:22:30,429 --> 00:22:36,130
which allows you to give a list of

00:22:33,159 --> 00:22:38,710
suggestions first and then before when

00:22:36,130 --> 00:22:39,909
you select one the editor goes back and

00:22:38,710 --> 00:22:42,220
says hey do you want to do more with

00:22:39,909 --> 00:22:44,649
this particular item and that's called

00:22:42,220 --> 00:22:46,690
completion item resolved

00:22:44,649 --> 00:22:48,039
we're in metals we can then say okay

00:22:46,690 --> 00:22:51,220
great well you pit you chose this

00:22:48,039 --> 00:22:53,830
suggestion this one will need an import

00:22:51,220 --> 00:22:56,380
so it can query Scala fix and say hey

00:22:53,830 --> 00:22:58,210
can you produce the text that it's like

00:22:56,380 --> 00:23:00,730
what are the removals in which lines and

00:22:58,210 --> 00:23:03,700
columns to refactor the code to include

00:23:00,730 --> 00:23:05,350
this import and then we go back so that

00:23:03,700 --> 00:23:09,159
is what happens in the first sort of

00:23:05,350 --> 00:23:12,730
second right there a lot of stuff but

00:23:09,159 --> 00:23:14,440
then as soon as we do a dot and it the

00:23:12,730 --> 00:23:17,110
editor does another another completion

00:23:14,440 --> 00:23:19,390
request which will then pass on to the

00:23:17,110 --> 00:23:20,679
the Scala compiler because that's a

00:23:19,390 --> 00:23:25,120
member lookup and that's pretty hard to

00:23:20,679 --> 00:23:27,100
do so that's where the presentation

00:23:25,120 --> 00:23:30,909
compiler is used and it responds and

00:23:27,100 --> 00:23:32,950
there we go so next time when you go

00:23:30,909 --> 00:23:34,870
into IntelliJ and start typing all of

00:23:32,950 --> 00:23:36,520
these things it's sort of mind-blowing

00:23:34,870 --> 00:23:37,360
to think about all of that intelligence

00:23:36,520 --> 00:23:38,920
as a

00:23:37,360 --> 00:23:42,060
little different architecture but

00:23:38,920 --> 00:23:42,060
there's quite a lot of stuff going on

00:23:42,630 --> 00:23:49,450
the final thing we're done soon

00:23:45,880 --> 00:23:51,370
with the diagrams is the code actions we

00:23:49,450 --> 00:23:54,550
wanted to have pretty basic refactoring

00:23:51,370 --> 00:23:58,270
support and here we see a demo of sort

00:23:54,550 --> 00:24:00,310
of remove the unused imports and this is

00:23:58,270 --> 00:24:02,620
the the warnings are published by the

00:24:00,310 --> 00:24:03,970
compiler it says these are unused we

00:24:02,620 --> 00:24:06,520
know that they're completely accurate I

00:24:03,970 --> 00:24:08,680
think in IntelliJ I've found found that

00:24:06,520 --> 00:24:12,100
the organism ports refactoring is kind

00:24:08,680 --> 00:24:13,810
of broken if you happen to have an

00:24:12,100 --> 00:24:17,460
import that is picked up by a macro

00:24:13,810 --> 00:24:20,380
expansion or placed conversion or and

00:24:17,460 --> 00:24:24,450
it's something you pretty much do all

00:24:20,380 --> 00:24:30,550
the time maybe hundreds of times a day

00:24:24,450 --> 00:24:31,960
yeah this should I've run it on a Kaka I

00:24:30,550 --> 00:24:33,550
should send up here by the way because

00:24:31,960 --> 00:24:36,690
I've removed like five hundred lines of

00:24:33,550 --> 00:24:40,510
code and a little compiled afterwards

00:24:36,690 --> 00:24:42,940
and so this is triggered by the warnings

00:24:40,510 --> 00:24:45,760
from the actual compiler so if your SBT

00:24:42,940 --> 00:24:52,570
build complains unused warning this is

00:24:45,760 --> 00:24:54,190
what metals essentially acts on and so

00:24:52,570 --> 00:24:55,870
what we see here is that there's a

00:24:54,190 --> 00:24:57,610
warning and then we go over it and

00:24:55,870 --> 00:24:59,110
there's a light bulb and then we press

00:24:57,610 --> 00:25:02,310
that action and you don't have to click

00:24:59,110 --> 00:25:06,940
with your mouse you can also do it with

00:25:02,310 --> 00:25:08,500
shortcuts so I sort of cut out the big

00:25:06,940 --> 00:25:10,540
piece here because this is the most

00:25:08,500 --> 00:25:12,190
interesting thing is to show the amount

00:25:10,540 --> 00:25:15,190
of back-and-forth going back just to

00:25:12,190 --> 00:25:16,990
deliver this user experience what we

00:25:15,190 --> 00:25:18,640
have is there's a change in the file

00:25:16,990 --> 00:25:21,310
then we publish the diagnostics from the

00:25:18,640 --> 00:25:24,880
compiler but then happens is that as you

00:25:21,310 --> 00:25:27,790
go over diagnostic the editor sends a

00:25:24,880 --> 00:25:29,470
code action request which is to say what

00:25:27,790 --> 00:25:31,540
actions can I do at this location right

00:25:29,470 --> 00:25:34,660
here so then we get also the range of

00:25:31,540 --> 00:25:36,250
where you are we respond saying these

00:25:34,660 --> 00:25:38,170
are the actions you could do so in this

00:25:36,250 --> 00:25:40,240
case is just like oh you're above a rim

00:25:38,170 --> 00:25:42,910
like an unused warning input and use the

00:25:40,240 --> 00:25:44,170
important warning you can remove unused

00:25:42,910 --> 00:25:45,610
imports but you don't have to do any

00:25:44,170 --> 00:25:48,010
refactoring we just say that's what you

00:25:45,610 --> 00:25:49,970
could do and well if you're gonna do it

00:25:48,010 --> 00:25:51,980
send me back this JSON blob

00:25:49,970 --> 00:25:55,070
now we just give it like a JSON payload

00:25:51,980 --> 00:25:58,429
to send us back later then one once we

00:25:55,070 --> 00:26:00,769
click it the the editor uses the

00:25:58,429 --> 00:26:03,799
workspace execute command request which

00:26:00,769 --> 00:26:05,980
is part of LSB and includes the payload

00:26:03,799 --> 00:26:07,210
that we requested previously and and

00:26:05,980 --> 00:26:10,309
[Music]

00:26:07,210 --> 00:26:13,159
then what happens is that this is sort

00:26:10,309 --> 00:26:14,750
of an any two unit function it just

00:26:13,159 --> 00:26:16,070
sends us a JSON payload and then says I

00:26:14,750 --> 00:26:18,080
don't care what you respond with but

00:26:16,070 --> 00:26:22,730
just do something you know write to disk

00:26:18,080 --> 00:26:24,110
or whatever and what we do here is is we

00:26:22,730 --> 00:26:27,110
use an LSP feature which is called

00:26:24,110 --> 00:26:29,269
workspace apply edit the the editor is

00:26:27,110 --> 00:26:31,429
able to know the server is able to

00:26:29,269 --> 00:26:34,009
invoke a refactoring for the whole

00:26:31,429 --> 00:26:37,730
workspace different files that even if

00:26:34,009 --> 00:26:39,610
you don't have them open and then the

00:26:37,730 --> 00:26:41,690
editor responds saying true or false

00:26:39,610 --> 00:26:43,100
managed to complete the refactoring and

00:26:41,690 --> 00:26:47,389
then we respond with the execute

00:26:43,100 --> 00:26:49,240
commands and unit and I think what's

00:26:47,389 --> 00:26:54,169
interesting with this diagram is that

00:26:49,240 --> 00:26:56,210
client server is a total lie because the

00:26:54,169 --> 00:27:00,830
server is initiating request to the

00:26:56,210 --> 00:27:02,600
client here so it's LSP is really not a

00:27:00,830 --> 00:27:04,580
client-server architecture it's just a

00:27:02,600 --> 00:27:06,620
bi direction peer-to-peer protocol to

00:27:04,580 --> 00:27:08,389
send messages back and forth and you can

00:27:06,620 --> 00:27:09,830
initiate notifications from the server

00:27:08,389 --> 00:27:12,440
to the client and you can send from the

00:27:09,830 --> 00:27:13,759
client to the server so that that was

00:27:12,440 --> 00:27:15,440
sort of mind-blowing I didn't realize

00:27:13,759 --> 00:27:18,289
that until I like two months into the

00:27:15,440 --> 00:27:22,970
project like whoa it's fine server it's

00:27:18,289 --> 00:27:24,679
just such a lie so enough with the

00:27:22,970 --> 00:27:30,399
sequence diagrams and let's just relax a

00:27:24,679 --> 00:27:34,509
bit and look at this silicon become dark

00:27:30,399 --> 00:27:34,509
if you want a color silicon

00:27:41,210 --> 00:28:00,330
any questions yeah yeah do we have

00:27:58,770 --> 00:28:08,580
problems with not relating see for these

00:28:00,330 --> 00:28:13,860
requests in my experiences personally

00:28:08,580 --> 00:28:15,720
just like intuitively know and as the

00:28:13,860 --> 00:28:17,490
the guy who was working on she the

00:28:15,720 --> 00:28:18,179
editor was measuring and tracing the

00:28:17,490 --> 00:28:20,010
whole pipeline

00:28:18,179 --> 00:28:22,740
it's totally neglible in terms of the

00:28:20,010 --> 00:28:24,620
architecture wise it's not the latency

00:28:22,740 --> 00:28:26,909
can be high if your language server slow

00:28:24,620 --> 00:28:28,380
so I mean if you're you're trying to do

00:28:26,909 --> 00:28:31,260
the completion and you're type checking

00:28:28,380 --> 00:28:34,080
the code that that can have a lot of

00:28:31,260 --> 00:28:37,380
latency right but fundamentally the the

00:28:34,080 --> 00:28:40,590
pipeline is not the overhead it's it's

00:28:37,380 --> 00:28:42,120
snappy because I mean you have maybe 20

00:28:40,590 --> 00:28:46,380
30 milliseconds which is a very long

00:28:42,120 --> 00:28:48,330
time to do a lot of back and forth all

00:28:46,380 --> 00:28:52,770
right well hope you enjoyed the silicon

00:28:48,330 --> 00:28:54,990
gift I promised that I'd explain now the

00:28:52,770 --> 00:28:57,270
current zoo of efforts in and in Scala

00:28:54,990 --> 00:28:59,010
so as you can imagine we have this

00:28:57,270 --> 00:29:02,580
architecture we have the methods the

00:28:59,010 --> 00:29:05,159
messages and so it's sort of platen not

00:29:02,580 --> 00:29:06,390
plug-and-play but it there's you go in

00:29:05,159 --> 00:29:07,919
and it's like these are the things you

00:29:06,390 --> 00:29:09,510
can do and then you just implement them

00:29:07,919 --> 00:29:12,299
and then you get like an awesome editor

00:29:09,510 --> 00:29:13,770
for free which is really rewarding it's

00:29:12,299 --> 00:29:16,770
honestly one of the most fun projects

00:29:13,770 --> 00:29:18,059
I've done in a while so what has

00:29:16,770 --> 00:29:19,470
happened is a lot of people are doing

00:29:18,059 --> 00:29:21,330
this as well and they're playing with

00:29:19,470 --> 00:29:22,799
different architectures they want to do

00:29:21,330 --> 00:29:26,010
navigation that way or the one of the

00:29:22,799 --> 00:29:28,340
completions that way etc etc so this is

00:29:26,010 --> 00:29:31,350
my I'm going to show you like a table

00:29:28,340 --> 00:29:33,750
and it's my personal sort of biased view

00:29:31,350 --> 00:29:35,640
on the state of the world but you should

00:29:33,750 --> 00:29:38,399
maybe ask and talk to people if you want

00:29:35,640 --> 00:29:41,520
more details and also one thing because

00:29:38,399 --> 00:29:43,169
I got comments on it I've before this is

00:29:41,520 --> 00:29:45,179
not I'd say these are all super

00:29:43,169 --> 00:29:46,350
complementary and and there's a huge

00:29:45,179 --> 00:29:48,169
amount a little there's a lot of

00:29:46,350 --> 00:29:51,179
collaboration between everyone involved

00:29:48,169 --> 00:29:52,799
there's not less competition in my

00:29:51,179 --> 00:29:54,120
experience then it's more that people

00:29:52,799 --> 00:29:55,409
are actually just experimenting with

00:29:54,120 --> 00:30:00,470
different things and there are

00:29:55,409 --> 00:30:00,470
technically different argue proaches so

00:30:00,649 --> 00:30:04,919
primarily I'd say that there are four

00:30:02,640 --> 00:30:05,640
sort of different experiments on going

00:30:04,919 --> 00:30:08,159
out to do

00:30:05,640 --> 00:30:10,049
LSP with Scala so if you go to the

00:30:08,159 --> 00:30:11,280
marketplace I think you'll find V is

00:30:10,049 --> 00:30:13,830
called marketplace you'll find maybe

00:30:11,280 --> 00:30:17,820
five different servers because there are

00:30:13,830 --> 00:30:21,600
two for enzyme and there's none for

00:30:17,820 --> 00:30:26,340
metals because I haven't published it

00:30:21,600 --> 00:30:28,320
but enzyme has its own graph apocalypse

00:30:26,340 --> 00:30:32,820
implementation for a simple index that

00:30:28,320 --> 00:30:38,700
is based on on class files and and some

00:30:32,820 --> 00:30:41,100
other tricks and then in Dori that we

00:30:38,700 --> 00:30:43,049
saw yesterday tasty is this interchange

00:30:41,100 --> 00:30:44,970
format for typed abstract syntax trees

00:30:43,049 --> 00:30:51,049
that are produced by the compiler which

00:30:44,970 --> 00:30:53,490
is working in body and they're able to

00:30:51,049 --> 00:30:54,929
provide navigation within your project

00:30:53,490 --> 00:30:58,530
sources because those are compiled with

00:30:54,929 --> 00:31:01,200
dotty and and actually so that's why I

00:30:58,530 --> 00:31:02,460
sort of say partial support because if

00:31:01,200 --> 00:31:03,990
your dependencies are in Java

00:31:02,460 --> 00:31:06,840
well the Java compiler does not emit

00:31:03,990 --> 00:31:09,179
tasty so you need something there to

00:31:06,840 --> 00:31:12,299
fill in the hole so it's technically

00:31:09,179 --> 00:31:16,620
doable but you got to be able to work

00:31:12,299 --> 00:31:20,639
with whatever exists on maven and then

00:31:16,620 --> 00:31:23,100
SBT has a language server that you can

00:31:20,639 --> 00:31:24,750
use which is built on the zinc analysis

00:31:23,100 --> 00:31:28,590
file so zinc is the incremental compiler

00:31:24,750 --> 00:31:31,799
and while doing incremental compilation

00:31:28,590 --> 00:31:35,039
it does emit tiny amounts of of metadata

00:31:31,799 --> 00:31:36,539
that can be used for navigating between

00:31:35,039 --> 00:31:38,130
source files but it's kind of

00:31:36,539 --> 00:31:40,710
constrained it only works well for your

00:31:38,130 --> 00:31:42,510
project that you're compiling and it

00:31:40,710 --> 00:31:44,580
also does not even work for all of the

00:31:42,510 --> 00:31:47,789
symbols in your project it works for

00:31:44,580 --> 00:31:49,169
some classes etc etc so you might find

00:31:47,789 --> 00:31:52,980
that there's going to be quite a lot of

00:31:49,169 --> 00:31:54,330
hit and misses if you're navigating so

00:31:52,980 --> 00:31:56,909
that's why I also have added partial

00:31:54,330 --> 00:31:57,740
support and then in in in metals we use

00:31:56,909 --> 00:32:00,070
a man-thing to be we

00:31:57,740 --> 00:32:04,040
is the format that I just showed earlier

00:32:00,070 --> 00:32:06,230
which is the the same data that Scala

00:32:04,040 --> 00:32:08,150
fix needs scholar fix does not depend on

00:32:06,230 --> 00:32:10,490
the Scala compiler it only depends on

00:32:08,150 --> 00:32:12,500
Zumanity to be so by using that we can

00:32:10,490 --> 00:32:15,500
both power the navigation index and we

00:32:12,500 --> 00:32:19,790
get sort of refactoring for free which

00:32:15,500 --> 00:32:21,830
is really awesome it sort of started

00:32:19,790 --> 00:32:24,050
that we wanted to do linting only and

00:32:21,830 --> 00:32:25,280
but then we had to set up the semantics

00:32:24,050 --> 00:32:26,420
the V integration I was like well at

00:32:25,280 --> 00:32:29,780
this point I might as well just go to

00:32:26,420 --> 00:32:31,220
definition right and but for the

00:32:29,780 --> 00:32:33,980
Diagnostics as is that we've done some

00:32:31,220 --> 00:32:35,660
experiments to do use both the the SBT

00:32:33,980 --> 00:32:39,800
server to do compile and then Scala see

00:32:35,660 --> 00:32:41,960
the presentation compiler so if I were

00:32:39,800 --> 00:32:43,760
to bet put my money on it I'd say that I

00:32:41,960 --> 00:32:45,950
think the the route of using the

00:32:43,760 --> 00:32:47,570
compiler to come to public no the build

00:32:45,950 --> 00:32:50,360
to publish the diagnostics I think is

00:32:47,570 --> 00:32:52,280
better but it may definitely be slow for

00:32:50,360 --> 00:32:55,580
large projects which is not desirable of

00:32:52,280 --> 00:32:56,780
course then they're using the the Scala

00:32:55,580 --> 00:32:59,480
presentation compiler the third

00:32:56,780 --> 00:33:02,600
presentation compiler and enzyme has the

00:32:59,480 --> 00:33:04,700
Scala refactoring library which is the

00:33:02,600 --> 00:33:11,179
same one that Scala IDE uses in Eclipse

00:33:04,700 --> 00:33:13,400
which is a fairly old project so we sort

00:33:11,179 --> 00:33:15,140
of forgot one thing a pretty basic

00:33:13,400 --> 00:33:18,230
feature that I have not talked about at

00:33:15,140 --> 00:33:19,880
all which is a limitation of the

00:33:18,230 --> 00:33:22,730
language server protocol which is the

00:33:19,880 --> 00:33:24,950
fact that I wanted to work with my built

00:33:22,730 --> 00:33:27,770
tool I've so far shown use only

00:33:24,950 --> 00:33:32,840
something that works with SPT and does

00:33:27,770 --> 00:33:37,910
anyone here work in maven two people no

00:33:32,840 --> 00:33:42,050
more Gradle more people anything else

00:33:37,910 --> 00:33:45,740
than SBT as well some hands so we also

00:33:42,050 --> 00:33:47,300
care about you and there are quite many

00:33:45,740 --> 00:33:48,770
I think I mean I'm very excited about

00:33:47,300 --> 00:33:52,130
some of the new ones that are coming and

00:33:48,770 --> 00:33:54,230
I'm also excited I think about basil if

00:33:52,130 --> 00:33:55,520
you have a heterogeneous code base etc

00:33:54,230 --> 00:33:57,590
so we wanna cater

00:33:55,520 --> 00:34:03,950
you know the IDE should not be tied to

00:33:57,590 --> 00:34:06,140
SP T so well that was not so the

00:34:03,950 --> 00:34:08,210
situation that we have is essentially

00:34:06,140 --> 00:34:10,609
that well for every ID you sort of have

00:34:08,210 --> 00:34:11,480
to implement a build integration it's

00:34:10,609 --> 00:34:12,710
not that hard but

00:34:11,480 --> 00:34:14,570
it's quite a lot of work if you got to

00:34:12,710 --> 00:34:16,869
do it right to export the build metadata

00:34:14,570 --> 00:34:19,480
the dependencies between the modules etc

00:34:16,869 --> 00:34:21,770
so in IntelliJ they've done essentially

00:34:19,480 --> 00:34:24,950
checked all of the boxes for all of the

00:34:21,770 --> 00:34:27,379
languages and and there and then enzyme

00:34:24,950 --> 00:34:29,629
has existed existed for quite a while so

00:34:27,379 --> 00:34:34,810
they have integrations with maven Gradle

00:34:29,629 --> 00:34:37,250
pants but but and then also for new

00:34:34,810 --> 00:34:38,990
built tools they sort of just hard code

00:34:37,250 --> 00:34:40,639
and they implement as an integration for

00:34:38,990 --> 00:34:42,409
IntelliJ because they only care about

00:34:40,639 --> 00:34:45,649
IntelliJ but that sort of makes it hard

00:34:42,409 --> 00:34:48,859
for newcomers to come into and come with

00:34:45,649 --> 00:34:52,340
a new language server so this is sort of

00:34:48,859 --> 00:34:54,710
the state of the art pen and this was

00:34:52,340 --> 00:34:57,560
the situation that we were facing in

00:34:54,710 --> 00:34:59,210
January we were thinking wait a second

00:34:57,560 --> 00:35:01,790
this looks a bit familiar has anyone

00:34:59,210 --> 00:35:07,100
seen this table before why don't we just

00:35:01,790 --> 00:35:09,290
do a build server protocol so we sat

00:35:07,100 --> 00:35:10,820
down and we wrote sort of a document a

00:35:09,290 --> 00:35:12,500
wish list of what what would be awesome

00:35:10,820 --> 00:35:15,020
if we could just communicate with the

00:35:12,500 --> 00:35:16,310
build tool through JSON RPC and it would

00:35:15,020 --> 00:35:18,800
give us all of this information that

00:35:16,310 --> 00:35:21,170
we're you know going through pain to

00:35:18,800 --> 00:35:23,000
write SBT plugins and then get people to

00:35:21,170 --> 00:35:24,800
install it and globally etc is like why

00:35:23,000 --> 00:35:26,119
doesn't just SBT provide it to us

00:35:24,800 --> 00:35:30,020
like that's this is what we need and

00:35:26,119 --> 00:35:33,200
it's actually not a complicated data so

00:35:30,020 --> 00:35:35,119
we sat down we wrote it and then sort of

00:35:33,200 --> 00:35:37,310
fishing hoping that someone would pick

00:35:35,119 --> 00:35:40,250
it up and implement it but it turns out

00:35:37,310 --> 00:35:41,600
that so core care my colleague at the

00:35:40,250 --> 00:35:44,840
center and they just had a presentation

00:35:41,600 --> 00:35:47,060
in the previous session about loop joint

00:35:44,840 --> 00:35:50,510
efforts with the jet pray and IntelliJ

00:35:47,060 --> 00:35:55,940
Scala team to do a build server

00:35:50,510 --> 00:35:57,830
integration so that the and they had a

00:35:55,940 --> 00:36:01,010
really awesome presentation about it a

00:35:57,830 --> 00:36:02,720
month ago what scholarsphere and it's

00:36:01,010 --> 00:36:05,119
really exciting for IntelliJ because it

00:36:02,720 --> 00:36:09,200
allows you to have much faster import

00:36:05,119 --> 00:36:10,460
build imports and as you save you can

00:36:09,200 --> 00:36:13,070
just trigger compilation in the build

00:36:10,460 --> 00:36:14,900
tool natively in the build tool and get

00:36:13,070 --> 00:36:17,720
those Diagnostics directly and it's also

00:36:14,900 --> 00:36:20,450
important for IntelliJ to get those or

00:36:17,720 --> 00:36:22,340
maybe just faster reload getting updated

00:36:20,450 --> 00:36:26,410
dependencies etc

00:36:22,340 --> 00:36:30,290
so I won't go into depth but I do

00:36:26,410 --> 00:36:32,630
recommend checking out this talk bill

00:36:30,290 --> 00:36:35,869
server vertical and fresh ideas with

00:36:32,630 --> 00:36:36,109
from Kaka and and just in over a month

00:36:35,869 --> 00:36:43,190
ago

00:36:36,109 --> 00:36:45,080
or come and talk to them or me so we're

00:36:43,190 --> 00:36:48,430
gonna wrap it up I think we had six

00:36:45,080 --> 00:36:52,390
features from 0 to IDE the pretty basic

00:36:48,430 --> 00:36:54,530
six steps from zero to pretty basic ID

00:36:52,390 --> 00:36:58,820
because there's a whole category

00:36:54,530 --> 00:37:01,400
features that people use debugging way

00:36:58,820 --> 00:37:03,220
more of these I don't know what people

00:37:01,400 --> 00:37:05,780
use an intelligent but it's quite a lot

00:37:03,220 --> 00:37:09,200
but we're just doing the basic stuff so

00:37:05,780 --> 00:37:12,980
I'm wanted to work with my editor and I

00:37:09,200 --> 00:37:16,099
think LSP is amazing it definitely sort

00:37:12,980 --> 00:37:17,750
of checks that box and it's a it seems

00:37:16,099 --> 00:37:19,520
insignificant in this long list but it's

00:37:17,750 --> 00:37:21,140
a huge problem and it's something that

00:37:19,520 --> 00:37:24,619
has existed for decades like as a

00:37:21,140 --> 00:37:28,780
problem and it's only it's only now that

00:37:24,619 --> 00:37:32,150
it's become so easy which is exciting

00:37:28,780 --> 00:37:36,290
and then I wanted to work with my built

00:37:32,150 --> 00:37:39,680
tool well I think BSP is a pretty

00:37:36,290 --> 00:37:41,540
exciting Avenue here and I'm hoping that

00:37:39,680 --> 00:37:44,450
it can be picked up more by more build

00:37:41,540 --> 00:37:46,570
tools I definitely for me the next steps

00:37:44,450 --> 00:37:49,640
for me in metals would be to implement a

00:37:46,570 --> 00:37:52,010
client and then just say this is the

00:37:49,640 --> 00:37:53,599
interface that we require because I've

00:37:52,010 --> 00:37:55,640
found it really hard to be doing only

00:37:53,599 --> 00:37:58,220
SBT plug-in work and then someone says

00:37:55,640 --> 00:38:00,560
does it work in maven and then then you

00:37:58,220 --> 00:38:03,109
have to just repeat the work and I think

00:38:00,560 --> 00:38:04,609
the combination of these two to trigger

00:38:03,109 --> 00:38:08,660
compilation because unless P does not

00:38:04,609 --> 00:38:11,210
have a way to say compile this module it

00:38:08,660 --> 00:38:13,040
has a way to like let the server send

00:38:11,210 --> 00:38:15,470
notifications hey here's a compilation

00:38:13,040 --> 00:38:18,410
error but you're not able to sort of

00:38:15,470 --> 00:38:20,210
like trigger compilation and the

00:38:18,410 --> 00:38:22,250
combination of these two so LSP provides

00:38:20,210 --> 00:38:25,070
the infrastructure to say publish

00:38:22,250 --> 00:38:27,920
Diagnostics give me read Diagnostics and

00:38:25,070 --> 00:38:29,540
it can say hey I just saved the file but

00:38:27,920 --> 00:38:31,880
the combination of them you can get sort

00:38:29,540 --> 00:38:32,670
of unsaved get pretty fast feedback with

00:38:31,880 --> 00:38:37,260
the the

00:38:32,670 --> 00:38:39,150
the red errors my biased opinion I think

00:38:37,260 --> 00:38:42,359
semantics TV is pretty great for

00:38:39,150 --> 00:38:44,369
navigation because as you saw it works

00:38:42,359 --> 00:38:45,839
great if even if you have broken code if

00:38:44,369 --> 00:38:48,299
you copy pasted something it's still

00:38:45,839 --> 00:38:50,069
sort of the old stuff works or if you

00:38:48,299 --> 00:38:51,450
just checked out a branch you know most

00:38:50,069 --> 00:38:53,819
code doesn't change so then it can just

00:38:51,450 --> 00:38:55,740
omit insolently browser if you get

00:38:53,819 --> 00:38:57,869
merges it still sort of handles this

00:38:55,740 --> 00:38:59,160
stuff even if the code is not parse at

00:38:57,869 --> 00:39:00,119
all and I think that's a pretty

00:38:59,160 --> 00:39:02,789
important feature

00:39:00,119 --> 00:39:04,890
but then again also also it's accurate

00:39:02,789 --> 00:39:06,599
is it matches exactly what the compiler

00:39:04,890 --> 00:39:09,059
produces so if even if you're using

00:39:06,599 --> 00:39:14,670
advanced type level machinery it'll give

00:39:09,059 --> 00:39:19,859
you the correct definitions and for the

00:39:14,670 --> 00:39:21,690
completions I have no clue it sort of

00:39:19,859 --> 00:39:26,549
requires custom work in my opinion I'm

00:39:21,690 --> 00:39:30,089
sort of not convinced that it's possible

00:39:26,549 --> 00:39:32,400
to - it would require a lot of work to

00:39:30,089 --> 00:39:34,410
get the presentation compiler using as a

00:39:32,400 --> 00:39:36,450
the compiler as a library to be

00:39:34,410 --> 00:39:37,799
up-to-date with your build so just to

00:39:36,450 --> 00:39:39,720
give you one example that I think is

00:39:37,799 --> 00:39:41,519
important but it's really hard to do

00:39:39,720 --> 00:39:44,400
with the compiler is you have main and

00:39:41,519 --> 00:39:46,440
test you just write a new class in main

00:39:44,400 --> 00:39:48,480
then you want to complete it in tests

00:39:46,440 --> 00:39:49,500
these are two different modules they're

00:39:48,480 --> 00:39:51,569
different class paths there are

00:39:49,500 --> 00:39:52,829
different compiler instances and they

00:39:51,569 --> 00:39:55,529
need to be aware of the symbols and the

00:39:52,829 --> 00:39:58,730
other ones so I found that if you want

00:39:55,529 --> 00:40:02,880
to do this well I think dot e has a

00:39:58,730 --> 00:40:04,859
better architecture for for being a

00:40:02,880 --> 00:40:07,980
presentation compiler so I'm excited

00:40:04,859 --> 00:40:10,890
about that but for working with if

00:40:07,980 --> 00:40:12,390
you're doing SPARC you're in 211 I have

00:40:10,890 --> 00:40:14,220
a feeling that maybe it might be worth

00:40:12,390 --> 00:40:16,410
to try to do just a custom completion

00:40:14,220 --> 00:40:18,509
engine that's what for example the rust

00:40:16,410 --> 00:40:20,279
language server does not use the rest

00:40:18,509 --> 00:40:23,009
compiler to do completions it's actually

00:40:20,279 --> 00:40:25,740
a custom implementation because also

00:40:23,009 --> 00:40:27,119
what you saw from the examples it's way

00:40:25,740 --> 00:40:29,779
more than just what the compiler does

00:40:27,119 --> 00:40:32,819
you want out of import you want you know

00:40:29,779 --> 00:40:34,440
you want to query the index etc which

00:40:32,819 --> 00:40:36,900
are not things that the compiler

00:40:34,440 --> 00:40:39,539
provides out-of-the-box so for me this

00:40:36,900 --> 00:40:41,710
is doing sort of a clue so I guess I

00:40:39,539 --> 00:40:44,920
kind of lied on the title

00:40:41,710 --> 00:40:46,900
and for refactoring well I think the

00:40:44,920 --> 00:40:48,850
Scala fix has a pretty good integration

00:40:46,900 --> 00:40:51,580
to be used as a library it can give you

00:40:48,850 --> 00:40:53,890
very fine-grained text patches to only

00:40:51,580 --> 00:40:56,560
touch the parts of the code that it's

00:40:53,890 --> 00:40:58,360
refactoring which allows the old

00:40:56,560 --> 00:41:00,460
diagnostics and other stuff to live in

00:40:58,360 --> 00:41:03,400
the editor and you can apply and compose

00:41:00,460 --> 00:41:05,830
more multiple different roles together

00:41:03,400 --> 00:41:10,150
in one batch and I think what's really

00:41:05,830 --> 00:41:11,530
important is that you can as a an API

00:41:10,150 --> 00:41:13,840
that I have not talked about it all but

00:41:11,530 --> 00:41:16,810
you can very easily extend scala fix

00:41:13,840 --> 00:41:18,190
with custom rules without being tied to

00:41:16,810 --> 00:41:20,440
the compiler in any way and it has a

00:41:18,190 --> 00:41:24,250
really great testing infrastructure to

00:41:20,440 --> 00:41:25,600
test new rules so this is sort of work

00:41:24,250 --> 00:41:28,210
that I've been doing for two years and

00:41:25,600 --> 00:41:30,970
and I'd like to advertise it as a as a

00:41:28,210 --> 00:41:34,930
pretty compelling building block to do

00:41:30,970 --> 00:41:44,470
refactoring so that'll be it for me

00:41:34,930 --> 00:41:51,040
thank you very much yes thank you very

00:41:44,470 --> 00:41:53,850
much are there any questions now I how

00:41:51,040 --> 00:41:57,490
does this help us with debugging so

00:41:53,850 --> 00:42:00,960
there is a you can guess it debug server

00:41:57,490 --> 00:42:05,920
protocol awesome

00:42:00,960 --> 00:42:08,620
and in fact geometry who's speaking also

00:42:05,920 --> 00:42:12,280
at this conference will be having a demo

00:42:08,620 --> 00:42:15,340
with debugging in vs code with Tory and

00:42:12,280 --> 00:42:17,820
it's pretty awesome so I'll tell you get

00:42:15,340 --> 00:42:17,820
after him

00:42:19,490 --> 00:42:30,350
yeah hi and so how much are you talking

00:42:27,710 --> 00:42:35,090
with the dotted dot guys to sort of plan

00:42:30,350 --> 00:42:38,600
ahead and converge to some common

00:42:35,090 --> 00:42:41,030
implementation and of course things so I

00:42:38,600 --> 00:42:43,540
mean I'm in the same quarter as they are

00:42:41,030 --> 00:42:46,280
in wheat lunch practically every day

00:42:43,540 --> 00:42:47,810
there's a lot of collaboration we do

00:42:46,280 --> 00:42:50,630
have meetings and we'll we have our

00:42:47,810 --> 00:42:52,160
disagreements and agreements I think

00:42:50,630 --> 00:42:54,980
they have as a presentation compiler or

00:42:52,160 --> 00:42:56,690
something pretty exciting and I think

00:42:54,980 --> 00:43:01,369
for navigation we have something better

00:42:56,690 --> 00:43:04,040
in metals so as I see them being

00:43:01,369 --> 00:43:05,510
complementary but it's you can't force

00:43:04,040 --> 00:43:08,270
people to just work in exactly in the

00:43:05,510 --> 00:43:09,770
same repo there's also issues they have

00:43:08,270 --> 00:43:12,710
a bootstrapping requirement so they

00:43:09,770 --> 00:43:14,690
cannot pull in Scala dependencies but in

00:43:12,710 --> 00:43:17,600
metals I use monix because it has a

00:43:14,690 --> 00:43:20,050
cancelable task and when you're doing

00:43:17,600 --> 00:43:22,820
completion you get cancellation requests

00:43:20,050 --> 00:43:27,200
so as you can imagine there's just a

00:43:22,820 --> 00:43:29,380
whole bunch of stuff that but and then

00:43:27,200 --> 00:43:31,640
I'm speaking a lot with some holiday

00:43:29,380 --> 00:43:34,820
back and forth he's very excited about

00:43:31,640 --> 00:43:38,290
semantic DB and then well I also

00:43:34,820 --> 00:43:41,090
frequent to talk with the SPT guys so

00:43:38,290 --> 00:43:44,540
it's very people are on a technical

00:43:41,090 --> 00:43:46,790
debate discussing trade offs the only

00:43:44,540 --> 00:43:49,130
thing I can complain about or wish for

00:43:46,790 --> 00:43:50,990
is just that we'd had maybe a couple of

00:43:49,130 --> 00:43:52,970
million dollars to fund fund this effort

00:43:50,990 --> 00:43:59,450
because currently it's relied on on

00:43:52,970 --> 00:44:01,990
quite a lot of volunteer effort that's

00:43:59,450 --> 00:44:01,990
another question

00:44:02,970 --> 00:44:09,039
and maybe a very obvious question but

00:44:05,259 --> 00:44:14,829
how do I try this out we have a website

00:44:09,039 --> 00:44:17,369
actually actually we have a really

00:44:14,829 --> 00:44:21,220
awesome domain called metal stud rocks

00:44:17,369 --> 00:44:22,660
which opens up the website and you can

00:44:21,220 --> 00:44:25,799
go to the user installation that will

00:44:22,660 --> 00:44:28,180
sell you there's nothing to see here

00:44:25,799 --> 00:44:29,950
it's still under active development so

00:44:28,180 --> 00:44:31,569
if you want to contribute you can head

00:44:29,950 --> 00:44:33,519
over to the contributor documentation

00:44:31,569 --> 00:44:35,529
which shows you how to set up sort of as

00:44:33,519 --> 00:44:38,049
a contributor you can build the plugin

00:44:35,529 --> 00:44:41,980
yourself some of the guys are using it

00:44:38,049 --> 00:44:43,799
for day-to-day work but it's the

00:44:41,980 --> 00:44:47,910
navigation part is working pretty well

00:44:43,799 --> 00:44:50,950
but you can you can go there and try

00:44:47,910 --> 00:44:53,769
this is also coming to vim on Yavin

00:44:50,950 --> 00:44:56,950
so some people have managed we have you

00:44:53,769 --> 00:45:00,700
can go to integrating with the new

00:44:56,950 --> 00:45:02,410
editor and Felix is in the room is using

00:45:00,700 --> 00:45:06,099
it with vim but there were some

00:45:02,410 --> 00:45:08,559
challenges with file watching but he's

00:45:06,099 --> 00:45:10,239
in the room you can ask him but the vim

00:45:08,559 --> 00:45:13,089
client is sort of primitive it doesn't

00:45:10,239 --> 00:45:15,359
so we use some of the more advanced

00:45:13,089 --> 00:45:19,749
features of the LSP like file watching

00:45:15,359 --> 00:45:20,799
notifications and if the editor doesn't

00:45:19,749 --> 00:45:22,869
send us the file go to notifications

00:45:20,799 --> 00:45:27,039
well then we don't know about the index

00:45:22,869 --> 00:45:34,799
updates etc so by far I'd say Adam and V

00:45:27,039 --> 00:45:34,799
is called are the ones or most stable

00:45:35,369 --> 00:45:42,100
any more questions well thank you very

00:45:40,180 --> 00:45:45,030
much thank you very much again

00:45:42,100 --> 00:45:45,030

YouTube URL: https://www.youtube.com/watch?v=zVl9oi3xgzg


