Title: Benefits of addressability -  clean management of mutation by Gjeta Gjyshinca and James Belsey
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6936-benefits-of-addressability---clean-management-of-mutation.html
Captions: 
	00:00:04,710 --> 00:00:08,560
hey everyone my name is Jetta and this

00:00:07,960 --> 00:00:10,990
is James

00:00:08,560 --> 00:00:13,600
when James first asked me to present

00:00:10,990 --> 00:00:15,070
with him in Berlin I was thrilled it was

00:00:13,600 --> 00:00:17,350
a chance for me to talk about the cool

00:00:15,070 --> 00:00:18,460
technology that I'm working on and to

00:00:17,350 --> 00:00:20,530
hear about other people's scholar

00:00:18,460 --> 00:00:22,869
projects and obviously I was excited to

00:00:20,530 --> 00:00:25,210
see Berlin for the first time but I was

00:00:22,869 --> 00:00:27,759
also a bit surprised I mean I joined the

00:00:25,210 --> 00:00:29,320
team only a year and a half ago as an

00:00:27,759 --> 00:00:32,710
engineer on the core technology that

00:00:29,320 --> 00:00:34,180
we're presenting today and in that time

00:00:32,710 --> 00:00:37,090
I have worked on some really exciting

00:00:34,180 --> 00:00:39,039
projects but it is a daunting team to

00:00:37,090 --> 00:00:40,899
join fresh out of uni and so I had also

00:00:39,039 --> 00:00:43,899
spent a lot of time feeling incompetent

00:00:40,899 --> 00:00:45,520
and asking stupid questions but anyway

00:00:43,899 --> 00:00:46,899
since James was asking me to present

00:00:45,520 --> 00:00:49,539
with him I figured I must be doing

00:00:46,899 --> 00:00:52,120
something right at last but then James

00:00:49,539 --> 00:00:54,190
told me the topic of today's talk and

00:00:52,120 --> 00:00:56,859
then I realised that actually maybe I

00:00:54,190 --> 00:01:01,000
was being punished and that's because

00:00:56,859 --> 00:01:02,050
today we're going to talk about change I

00:01:01,000 --> 00:01:04,629
know what you're thinking

00:01:02,050 --> 00:01:07,840
who comes to a Scala presentation to

00:01:04,629 --> 00:01:09,790
give a talk about change conference

00:01:07,840 --> 00:01:12,520
where functional is king and where the

00:01:09,790 --> 00:01:15,759
words mutable var are mildly

00:01:12,520 --> 00:01:18,400
uncomfortable at best and just insulting

00:01:15,759 --> 00:01:20,110
at worst but don't worry we're hoping

00:01:18,400 --> 00:01:21,759
that by the end of this talk we'll have

00:01:20,110 --> 00:01:24,640
convinced you that the technology that

00:01:21,759 --> 00:01:27,540
we've built allows us to combine the

00:01:24,640 --> 00:01:29,829
benefits of immutable state without

00:01:27,540 --> 00:01:34,090
forcing the developer to give up the

00:01:29,829 --> 00:01:35,950
freedom to to deal with change okay it's

00:01:34,090 --> 00:01:38,439
probably about time I introduced our

00:01:35,950 --> 00:01:41,710
project James and I are part of a team

00:01:38,439 --> 00:01:44,680
that's developed a platform on top of

00:01:41,710 --> 00:01:46,420
which developers across multiple

00:01:44,680 --> 00:01:49,060
business lines at the bank can write

00:01:46,420 --> 00:01:52,350
financial applications from CPU

00:01:49,060 --> 00:01:55,270
intensive risk calculation engines to

00:01:52,350 --> 00:01:58,869
reactive UIs and and trade our desktop

00:01:55,270 --> 00:02:00,250
applications so our clients are first

00:01:58,869 --> 00:02:03,670
and foremost the developers themselves

00:02:00,250 --> 00:02:05,770
and our overarching aim is to build our

00:02:03,670 --> 00:02:07,840
platform in such a way that developers

00:02:05,770 --> 00:02:10,899
get to write the code that they want to

00:02:07,840 --> 00:02:13,330
write and to control the runtime so that

00:02:10,899 --> 00:02:16,350
it ensures that this code runs in the

00:02:13,330 --> 00:02:16,350
way that they want it to run

00:02:16,990 --> 00:02:24,410
so in our in our last presentation we

00:02:21,850 --> 00:02:27,470
spoke about this for the first time in

00:02:24,410 --> 00:02:31,280
London a few months ago and we described

00:02:27,470 --> 00:02:34,610
the platform as a platform that could

00:02:31,280 --> 00:02:36,620
automatically parallelize user code and

00:02:34,610 --> 00:02:37,910
by the way that talk is online if you're

00:02:36,620 --> 00:02:40,700
interested about you don't need to have

00:02:37,910 --> 00:02:43,940
watched it to understand the concepts in

00:02:40,700 --> 00:02:46,670
today's talk so our focus last time was

00:02:43,940 --> 00:02:49,100
on parallelization and we talked about

00:02:46,670 --> 00:02:50,150
trade-offs our developers give up the

00:02:49,100 --> 00:02:52,250
freedom to control their own

00:02:50,150 --> 00:02:55,730
multi-threading but they gain back fast

00:02:52,250 --> 00:03:01,040
and efficient parallelization controlled

00:02:55,730 --> 00:03:02,900
by the platform instead and today we're

00:03:01,040 --> 00:03:07,100
going to talk kind of a little bit more

00:03:02,900 --> 00:03:10,750
about about trade-offs because different

00:03:07,100 --> 00:03:13,040
programming paradigms forced developers

00:03:10,750 --> 00:03:16,430
to deal with change in different ways

00:03:13,040 --> 00:03:19,970
and what that means is that we're

00:03:16,430 --> 00:03:24,650
sometimes forced to kind of pay a price

00:03:19,970 --> 00:03:27,710
for for dealing with change so as I

00:03:24,650 --> 00:03:29,000
mentioned I am an engineer on the

00:03:27,710 --> 00:03:32,510
project and I work on the core

00:03:29,000 --> 00:03:34,580
technology and that covers the the

00:03:32,510 --> 00:03:36,680
compiler plug in the scheduler and the

00:03:34,580 --> 00:03:39,500
cache among many other cool things and

00:03:36,680 --> 00:03:41,120
I'll talk about all of those later James

00:03:39,500 --> 00:03:43,210
has been involved in the project since

00:03:41,120 --> 00:03:45,320
it began about six and a half years ago

00:03:43,210 --> 00:03:48,830
and I'm not really sure what he does

00:03:45,320 --> 00:03:50,810
every day but he'd seen the project grow

00:03:48,830 --> 00:03:52,760
into one of the biggest Scala code bases

00:03:50,810 --> 00:03:55,700
in the world with over three million

00:03:52,760 --> 00:03:57,230
lines of code and more than 20,000 pull

00:03:55,700 --> 00:03:59,870
requests into the main branch by

00:03:57,230 --> 00:04:02,360
something like 500 active developers

00:03:59,870 --> 00:04:05,390
worldwide and of those lines of code

00:04:02,360 --> 00:04:07,250
about 60,000 cover the platform itself

00:04:05,390 --> 00:04:08,720
the core technology and the rest is

00:04:07,250 --> 00:04:12,500
application code that's been built on

00:04:08,720 --> 00:04:17,650
top of that and of those 500 developers

00:04:12,500 --> 00:04:20,480
only about 50 work on on the platform so

00:04:17,650 --> 00:04:22,190
as someone wise once there they forget

00:04:20,480 --> 00:04:25,280
who the only thing that's constant is

00:04:22,190 --> 00:04:26,750
change and so as developers we we have

00:04:25,280 --> 00:04:28,130
to deal with change whether we like it

00:04:26,750 --> 00:04:30,980
or not

00:04:28,130 --> 00:04:33,080
and the reality is that in in any

00:04:30,980 --> 00:04:34,700
long-running application in any real

00:04:33,080 --> 00:04:36,920
system that's live for more than like a

00:04:34,700 --> 00:04:40,190
few milliseconds we're going to have to

00:04:36,920 --> 00:04:41,510
deal with state mutable state and that

00:04:40,190 --> 00:04:42,920
might come because of a number of

00:04:41,510 --> 00:04:45,940
different things whether it's something

00:04:42,920 --> 00:04:48,350
as simple as time ticking forwards or

00:04:45,940 --> 00:04:51,770
temperatures and prices fluctuating or

00:04:48,350 --> 00:04:54,440
users updating their preferences so our

00:04:51,770 --> 00:04:56,120
challenge in order to satisfy the

00:04:54,440 --> 00:05:00,620
requirements of our clients of the

00:04:56,120 --> 00:05:02,570
developers is to build our platform so

00:05:00,620 --> 00:05:06,290
that developers can write the code that

00:05:02,570 --> 00:05:10,430
they want to write without losing the

00:05:06,290 --> 00:05:12,260
benefits of immutable state and without

00:05:10,430 --> 00:05:13,670
incurring some of the costs involved and

00:05:12,260 --> 00:05:15,820
that's what James is going to talk about

00:05:13,670 --> 00:05:19,550
next

00:05:15,820 --> 00:05:23,360
thank you hi

00:05:19,550 --> 00:05:26,920
so I'm gonna use some pictures I'm gonna

00:05:23,360 --> 00:05:28,790
talk about the two paradigms of

00:05:26,920 --> 00:05:30,590
essentially not functional programming

00:05:28,790 --> 00:05:32,570
our procedural programming and

00:05:30,590 --> 00:05:35,470
functional programming I'm gonna talk a

00:05:32,570 --> 00:05:38,180
bit about change in those paradigms and

00:05:35,470 --> 00:05:41,180
why in both cases it's not fully

00:05:38,180 --> 00:05:43,130
satisfactory for us before we we talk

00:05:41,180 --> 00:05:45,980
about what we actually did to make

00:05:43,130 --> 00:05:49,100
ourselves happy and so I I come from

00:05:45,980 --> 00:05:51,380
narrow background and you know before

00:05:49,100 --> 00:05:53,240
the advent of threads that life was

00:05:51,380 --> 00:05:55,340
relatively good you know when the foot

00:05:53,240 --> 00:05:56,600
when the program ran you could debug it

00:05:55,340 --> 00:05:57,590
quite easily you could put in

00:05:56,600 --> 00:05:59,570
breakpoints you could see the change

00:05:57,590 --> 00:06:01,640
that you were making it was relatively

00:05:59,570 --> 00:06:03,770
easy to work out how you managed to get

00:06:01,640 --> 00:06:05,030
into a particular state if you ran the

00:06:03,770 --> 00:06:06,860
program again it will probably do the

00:06:05,030 --> 00:06:10,520
same thing because that there's not

00:06:06,860 --> 00:06:12,910
multi-threading then multi-threading

00:06:10,520 --> 00:06:15,620
arrived and stuff got a whole lot harder

00:06:12,910 --> 00:06:18,410
and when you debug multi-threaded code

00:06:15,620 --> 00:06:20,510
you kind of wind up in this situation

00:06:18,410 --> 00:06:22,190
where you're trying to comprehend what's

00:06:20,510 --> 00:06:24,020
happening in all these cool stacks and

00:06:22,190 --> 00:06:26,870
the interaction that those cool stacks

00:06:24,020 --> 00:06:28,430
are having with the heap and to try and

00:06:26,870 --> 00:06:31,250
work out like what it is and how you

00:06:28,430 --> 00:06:33,770
wind up with this end state and anyone

00:06:31,250 --> 00:06:36,140
who's done this will recognize the pain

00:06:33,770 --> 00:06:37,730
it's it's very hard to keep it in track

00:06:36,140 --> 00:06:39,410
then you also have the problem that you

00:06:37,730 --> 00:06:40,930
know if you put a breakpoint in one of

00:06:39,410 --> 00:06:45,009
these threads and stop it

00:06:40,930 --> 00:06:46,270
then it's like the the the once you

00:06:45,009 --> 00:06:48,220
observe the system it changes this

00:06:46,270 --> 00:06:49,419
behavior because now the other thiser

00:06:48,220 --> 00:06:51,190
you stop the other threads at the same

00:06:49,419 --> 00:06:52,630
time or you allow the other threads to

00:06:51,190 --> 00:06:55,150
continue but because your thread isn't

00:06:52,630 --> 00:06:57,490
continuing it's not making changes and

00:06:55,150 --> 00:07:00,100
that it did make in the case where the

00:06:57,490 --> 00:07:01,570
bug was that happened and I'm sure that

00:07:00,100 --> 00:07:04,300
many people are familiar with this kind

00:07:01,570 --> 00:07:05,979
of pain of like chasing some race

00:07:04,300 --> 00:07:07,419
condition bug where you know you run the

00:07:05,979 --> 00:07:09,250
thing a hundred times and it reproduces

00:07:07,419 --> 00:07:10,479
twice and then you stick in some log

00:07:09,250 --> 00:07:11,889
statements and then that doesn't

00:07:10,479 --> 00:07:13,509
reproduce it because a lot of statements

00:07:11,889 --> 00:07:17,530
have changed their timing so you know

00:07:13,509 --> 00:07:19,900
you can't find that the problem so in a

00:07:17,530 --> 00:07:22,060
procedural like oh well like dealing

00:07:19,900 --> 00:07:23,710
with changes and it's almost always the

00:07:22,060 --> 00:07:25,930
changes that are causing these bugs

00:07:23,710 --> 00:07:27,099
because you know you you've decided

00:07:25,930 --> 00:07:28,599
you've checked you increment it's

00:07:27,099 --> 00:07:29,770
something outside of a lock or something

00:07:28,599 --> 00:07:31,300
like this those are the things that

00:07:29,770 --> 00:07:33,639
actually caused you the pain when you're

00:07:31,300 --> 00:07:35,880
when you're trying to deep debug these

00:07:33,639 --> 00:07:39,699
things and it's the change that happens

00:07:35,880 --> 00:07:42,250
on the flip side like syntactically and

00:07:39,699 --> 00:07:44,410
at the point of change what you write

00:07:42,250 --> 00:07:46,000
it's kind of quite nice and it's very

00:07:44,410 --> 00:07:47,169
easy to understand what it is that the

00:07:46,000 --> 00:07:51,070
change that you're trying to introduce

00:07:47,169 --> 00:07:53,020
into the system so so while like the

00:07:51,070 --> 00:07:54,460
procedural model might not be the what

00:07:53,020 --> 00:07:55,990
it might be the code you want to write

00:07:54,460 --> 00:07:59,830
it's certainly not the code you want a

00:07:55,990 --> 00:08:05,110
debug because it's very very painful so

00:07:59,830 --> 00:08:06,789
it's a debug and so this isn't has

00:08:05,110 --> 00:08:09,370
improved satisfactory to us you know we

00:08:06,789 --> 00:08:11,800
I'm sure to some extent we're preaching

00:08:09,370 --> 00:08:14,020
to the converted right but dealing with

00:08:11,800 --> 00:08:18,580
change in a traditional manner has been

00:08:14,020 --> 00:08:20,409
very very hot however then we move into

00:08:18,580 --> 00:08:23,229
the functional programming world and and

00:08:20,409 --> 00:08:25,659
I'm going to show some code this code

00:08:23,229 --> 00:08:27,759
here is consists of three classes is

00:08:25,659 --> 00:08:30,639
very simple piece of code for

00:08:27,759 --> 00:08:32,169
hypothesized flight and some things to

00:08:30,639 --> 00:08:37,329
calculate the fuel cost for which you'll

00:08:32,169 --> 00:08:40,599
you need an FX rate these things contain

00:08:37,329 --> 00:08:44,350
each other in an ABC style chain and we

00:08:40,599 --> 00:08:45,760
have like that we have code that's

00:08:44,350 --> 00:08:48,640
similar to this and more complicated

00:08:45,760 --> 00:08:52,510
which we'll show later in loads of our

00:08:48,640 --> 00:08:53,889
systems but in the functional world you

00:08:52,510 --> 00:08:56,230
you you

00:08:53,889 --> 00:08:58,119
this problem of mutation right now in

00:08:56,230 --> 00:08:59,920
functional programming there's no change

00:08:58,119 --> 00:09:01,989
right you want to change something so

00:08:59,920 --> 00:09:03,489
that if we want to if we if we create

00:09:01,989 --> 00:09:05,980
this thing like this and we want to

00:09:03,489 --> 00:09:07,839
change the fuel cost from eight point

00:09:05,980 --> 00:09:10,869
eight eight to something else then what

00:09:07,839 --> 00:09:14,019
we do is we copy the object change right

00:09:10,869 --> 00:09:16,089
so so we take the we take that FX right

00:09:14,019 --> 00:09:17,499
and we copy it and then we copy the

00:09:16,089 --> 00:09:19,239
things that contain it and then we copy

00:09:17,499 --> 00:09:20,980
the things that contain them and so now

00:09:19,239 --> 00:09:23,470
we've created like a chain of copied

00:09:20,980 --> 00:09:25,480
objects and that's how we get but that's

00:09:23,470 --> 00:09:27,790
how we get a new thing with a new value

00:09:25,480 --> 00:09:31,239
and that's how we deal with change in

00:09:27,790 --> 00:09:34,929
most FP mod models now it's not very

00:09:31,239 --> 00:09:36,910
nice to write and understand there are a

00:09:34,929 --> 00:09:38,799
lot of helpers for this so that there

00:09:36,910 --> 00:09:40,269
are these things like lenses which means

00:09:38,799 --> 00:09:43,959
that you can write that and obviously

00:09:40,269 --> 00:09:46,559
it's about half as much and it shows how

00:09:43,959 --> 00:09:48,699
you can write the same kind of thing

00:09:46,559 --> 00:09:50,949
which does the same thing it still

00:09:48,699 --> 00:09:52,679
creates the new objects but it does it

00:09:50,949 --> 00:09:55,689
in a way which is like easier to read

00:09:52,679 --> 00:10:00,160
but it's still not that easy to read

00:09:55,689 --> 00:10:01,389
it's still not this right and that's the

00:10:00,160 --> 00:10:03,669
change that you're trying to introduce

00:10:01,389 --> 00:10:05,319
is you're trying to say I want to change

00:10:03,669 --> 00:10:06,389
that thing there and I want to change it

00:10:05,319 --> 00:10:09,759
to 8.13

00:10:06,389 --> 00:10:13,689
right and that line at the top is not as

00:10:09,759 --> 00:10:15,209
easy to read to read as that and it

00:10:13,689 --> 00:10:18,579
doesn't change the underlying mechanics

00:10:15,209 --> 00:10:19,779
so the underlying mechanics are still

00:10:18,579 --> 00:10:22,649
the same is still creating all those

00:10:19,779 --> 00:10:24,850
objects which we'll talk about shortly

00:10:22,649 --> 00:10:27,910
but before we do that I want to show a

00:10:24,850 --> 00:10:30,519
kind of an increasingly more real-world

00:10:27,910 --> 00:10:32,290
example now as Jeff said like we've got

00:10:30,519 --> 00:10:35,439
millions of lines of Scala code so we

00:10:32,290 --> 00:10:37,749
can't show you that butBut what we can

00:10:35,439 --> 00:10:40,660
show you is like a typical and more

00:10:37,749 --> 00:10:41,980
complex example and this is a similar

00:10:40,660 --> 00:10:43,899
thing we've got the flight and the

00:10:41,980 --> 00:10:45,549
flight contains the fuel cost and the

00:10:43,899 --> 00:10:47,009
fuel cause that contains the FX rate but

00:10:45,549 --> 00:10:49,660
there are also some other things like

00:10:47,009 --> 00:10:51,879
when when the airlines are pricing their

00:10:49,660 --> 00:10:54,429
flights they want to do stuff to concern

00:10:51,879 --> 00:10:55,779
with occupancy right because anybody

00:10:54,429 --> 00:10:57,160
who's got children if you fly during

00:10:55,779 --> 00:10:58,809
school holidays they charge you more and

00:10:57,160 --> 00:11:00,069
they charge you more because they know

00:10:58,809 --> 00:11:01,119
that the occupancy is going to be higher

00:11:00,069 --> 00:11:02,939
and they can push the price up and

00:11:01,119 --> 00:11:06,459
they're still settled all seats right

00:11:02,939 --> 00:11:07,699
and so what what you need to do in order

00:11:06,459 --> 00:11:09,410
to work your price out

00:11:07,699 --> 00:11:11,749
you need some kind of occupant like

00:11:09,410 --> 00:11:13,459
relationship to occupancy and in this

00:11:11,749 --> 00:11:15,499
model we're hypothesizing that occupancy

00:11:13,459 --> 00:11:17,959
actually depends on FX rate which isn't

00:11:15,499 --> 00:11:20,029
crazy you know when the exchange rate

00:11:17,959 --> 00:11:21,919
between the UK and the u.s. change is

00:11:20,029 --> 00:11:23,569
like whole loads of shoppers get from

00:11:21,919 --> 00:11:25,069
the from the UK get on airplanes and go

00:11:23,569 --> 00:11:27,410
to New York and go shopping like that as

00:11:25,069 --> 00:11:29,569
a real thing that happens so in this

00:11:27,410 --> 00:11:30,859
case you you you wind up with something

00:11:29,569 --> 00:11:32,809
that's a bit more complex but it's still

00:11:30,859 --> 00:11:36,649
not an insane thing for you to want to

00:11:32,809 --> 00:11:39,529
draw right as an object graph and the

00:11:36,649 --> 00:11:41,509
this collection of references is what

00:11:39,529 --> 00:11:42,589
starts to build the complexity but it's

00:11:41,509 --> 00:11:46,129
kind of logical because you're trying to

00:11:42,589 --> 00:11:49,309
model the real world right now I've got

00:11:46,129 --> 00:11:51,319
a picture here we don't have a graphics

00:11:49,309 --> 00:11:54,769
or art department so my children through

00:11:51,319 --> 00:11:56,600
this so for copyright reasons and here

00:11:54,769 --> 00:11:58,429
the the thing on the left there is

00:11:56,600 --> 00:12:00,049
represents the flight and the flight

00:11:58,429 --> 00:12:01,339
contains these two things it contains

00:12:00,049 --> 00:12:03,439
the fuel cost and it contains the

00:12:01,339 --> 00:12:04,819
occupancy score and both the fuel cost

00:12:03,439 --> 00:12:06,619
in the occupancy school they reference

00:12:04,819 --> 00:12:09,439
that FX rate which is the rightmost

00:12:06,619 --> 00:12:13,639
bottom circle and the occupancy score

00:12:09,439 --> 00:12:16,279
also sorry the fuel cost also rep for

00:12:13,639 --> 00:12:17,989
this is this local price thing right so

00:12:16,279 --> 00:12:19,279
now when I want to cut when I want to do

00:12:17,989 --> 00:12:21,199
something like when I want to change the

00:12:19,279 --> 00:12:22,699
FX rate which is the right bottom one of

00:12:21,199 --> 00:12:24,619
those things if I'm going to be

00:12:22,699 --> 00:12:27,169
efficient I only want to change those

00:12:24,619 --> 00:12:28,399
bottom most four objects right I don't

00:12:27,169 --> 00:12:30,619
want to change the other one because

00:12:28,399 --> 00:12:33,619
it's not changing so now I wind up with

00:12:30,619 --> 00:12:35,509
something that looks like this you will

00:12:33,619 --> 00:12:37,879
keep on track oh we're done with that

00:12:35,509 --> 00:12:39,829
you'll to follow that good now it's

00:12:37,879 --> 00:12:41,299
complicated right because it's high it's

00:12:39,829 --> 00:12:42,319
you you have to create this interent

00:12:41,299 --> 00:12:43,609
where you have to do but it's better to

00:12:42,319 --> 00:12:45,589
create this interim variable you have to

00:12:43,609 --> 00:12:46,910
read it now what's happening is as a

00:12:45,589 --> 00:12:49,579
programmer you have to kind of track

00:12:46,910 --> 00:12:52,129
these object graphs now it's true I can

00:12:49,579 --> 00:12:54,230
contort my business model so that I wind

00:12:52,129 --> 00:12:55,939
up with directed graphs so that the

00:12:54,230 --> 00:12:59,149
changes I make are only ever in the line

00:12:55,939 --> 00:13:01,309
so I can use something like a lens to do

00:12:59,149 --> 00:13:02,720
that but it's painful right because now

00:13:01,309 --> 00:13:04,850
I started to model in a way which is

00:13:02,720 --> 00:13:06,859
actually dependent on how I look code

00:13:04,850 --> 00:13:08,869
are later right and also it means I have

00:13:06,859 --> 00:13:11,089
to kind of know a priori the things I'm

00:13:08,869 --> 00:13:13,730
probably going to want to change and and

00:13:11,089 --> 00:13:16,129
that's hard too because you know like

00:13:13,730 --> 00:13:17,239
you just don't tend to know the end

00:13:16,129 --> 00:13:19,119
state of your system when you start

00:13:17,239 --> 00:13:21,110
building it right so so so that's a

00:13:19,119 --> 00:13:23,000
another problem

00:13:21,110 --> 00:13:25,250
and in real world this is more like what

00:13:23,000 --> 00:13:27,320
the object also like they they're much

00:13:25,250 --> 00:13:29,600
more complicated than the five objects

00:13:27,320 --> 00:13:32,360
that I showed on the previous page them

00:13:29,600 --> 00:13:33,830
and there's interrelation and and yes

00:13:32,360 --> 00:13:36,200
people will say well we shouldn't have

00:13:33,830 --> 00:13:38,839
cycles but realistically in the real

00:13:36,200 --> 00:13:40,550
world you wind up with cycles because it

00:13:38,839 --> 00:13:45,440
makes your code easier to write and it

00:13:40,550 --> 00:13:47,060
models the real world more so we whilst

00:13:45,440 --> 00:13:49,100
there are tools to help manage this in

00:13:47,060 --> 00:13:52,580
the FP world that they're not intuitive

00:13:49,100 --> 00:13:54,320
it's not simple a simple thing to do and

00:13:52,580 --> 00:13:56,450
then change it's just very hard to deal

00:13:54,320 --> 00:13:56,870
with and they always still result in

00:13:56,450 --> 00:14:00,470
coffee

00:13:56,870 --> 00:14:03,140
copying so let's talk about coffee so

00:14:00,470 --> 00:14:05,870
coughing stuff is not free and I think

00:14:03,140 --> 00:14:08,300
everyone knows that but but just to

00:14:05,870 --> 00:14:11,690
labor the point this is a snapshot from

00:14:08,300 --> 00:14:14,839
profiler so Rory you made the snapshot

00:14:11,690 --> 00:14:17,480
for us we've been doing some work on an

00:14:14,839 --> 00:14:19,640
Scarlett performance and this this is a

00:14:17,480 --> 00:14:21,529
snapshot of like object creation inside

00:14:19,640 --> 00:14:24,470
of the compiler is it's from complaining

00:14:21,529 --> 00:14:27,260
akka which is about thirty odd thousand

00:14:24,470 --> 00:14:29,240
lines of Scala and when we do that

00:14:27,260 --> 00:14:31,730
compile it creates like 73 million like

00:14:29,240 --> 00:14:35,839
I'm so sorry 73 million objects in the

00:14:31,730 --> 00:14:37,579
JVM now though people who write the

00:14:35,839 --> 00:14:42,529
compiler that they're like very aware of

00:14:37,579 --> 00:14:44,300
how like how much it costs to do object

00:14:42,529 --> 00:14:45,980
creation so actually there's mutation

00:14:44,300 --> 00:14:48,320
inside of the compiler which makes it

00:14:45,980 --> 00:14:49,760
less that there's been less object

00:14:48,320 --> 00:14:50,839
creation so I think you know if you just

00:14:49,760 --> 00:14:52,130
were to write this in a purely

00:14:50,839 --> 00:14:54,680
functional way you would have even more

00:14:52,130 --> 00:14:56,720
object creation and what we know is that

00:14:54,680 --> 00:14:59,660
in on the JVM platform when you have all

00:14:56,720 --> 00:15:01,370
this object creation and you know if you

00:14:59,660 --> 00:15:03,560
don't have people who are expert and

00:15:01,370 --> 00:15:05,270
able to stop that object creation so

00:15:03,560 --> 00:15:06,529
that you get more performance you just

00:15:05,270 --> 00:15:08,990
wind up paying the price in the garbage

00:15:06,529 --> 00:15:10,640
collection cycles so you know the first

00:15:08,990 --> 00:15:13,070
thing we do when we're trying to like

00:15:10,640 --> 00:15:14,899
optimize our JVM platform is we're gonna

00:15:13,070 --> 00:15:16,850
look at how much allocation we've got

00:15:14,899 --> 00:15:18,829
and we'll just we'll just try and cut

00:15:16,850 --> 00:15:21,620
down that allocation and it makes big

00:15:18,829 --> 00:15:23,390
differences because it's true that at

00:15:21,620 --> 00:15:25,130
the point of allocation you don't pay

00:15:23,390 --> 00:15:26,660
but later on the garbage collect ask to

00:15:25,130 --> 00:15:28,910
track all of that and it has to find the

00:15:26,660 --> 00:15:32,209
dead objects and it has to remove them

00:15:28,910 --> 00:15:35,020
and and that does cost so these two

00:15:32,209 --> 00:15:38,120
problems are way we're

00:15:35,020 --> 00:15:40,430
like we've been groping for a round in

00:15:38,120 --> 00:15:46,310
the dark for a better solution than the

00:15:40,430 --> 00:15:47,839
AFP solution okay if there's one thing

00:15:46,310 --> 00:15:49,640
I've learned from the last couple of

00:15:47,839 --> 00:15:50,900
days it's that no Scala days

00:15:49,640 --> 00:15:54,080
presentation is complete without a

00:15:50,900 --> 00:15:56,210
little bit of theory so before I move on

00:15:54,080 --> 00:15:57,920
to talk about our solution I'm gonna

00:15:56,210 --> 00:15:59,750
spend a few minutes to talk about the

00:15:57,920 --> 00:16:01,850
all-powerful building block but it makes

00:15:59,750 --> 00:16:04,160
it possible and that's represented here

00:16:01,850 --> 00:16:05,320
by this software superhero referential

00:16:04,160 --> 00:16:07,730
transparency man

00:16:05,320 --> 00:16:09,980
again thank you to James's children for

00:16:07,730 --> 00:16:11,420
providing us the graphics and if any of

00:16:09,980 --> 00:16:13,370
you did see the previous presentation

00:16:11,420 --> 00:16:17,060
sorry for repeating the same joke it

00:16:13,370 --> 00:16:18,500
just not that funny so I know a lot of

00:16:17,060 --> 00:16:20,330
you are familiar with this idea already

00:16:18,500 --> 00:16:22,760
but it's so crucial that I'll just

00:16:20,330 --> 00:16:24,260
explain again a function is

00:16:22,760 --> 00:16:26,120
referentially transparent if it returns

00:16:24,260 --> 00:16:28,310
the same result every time we call it

00:16:26,120 --> 00:16:30,529
and it sounds simple enough and it is

00:16:28,310 --> 00:16:32,779
its it means that when we call a

00:16:30,529 --> 00:16:35,180
function with the same input it's

00:16:32,779 --> 00:16:38,000
guaranteed to give us the same output or

00:16:35,180 --> 00:16:40,820
to put it yet another way some function

00:16:38,000 --> 00:16:43,459
X is referentially transparent if we can

00:16:40,820 --> 00:16:46,550
replace any calls to X in our code with

00:16:43,459 --> 00:16:49,820
its result and not have any observable

00:16:46,550 --> 00:16:52,430
effect on the behavior of our program I

00:16:49,820 --> 00:16:53,600
will explain why we care about this but

00:16:52,430 --> 00:16:56,570
first let me show you a couple of

00:16:53,600 --> 00:16:59,630
examples so let's suppose that our

00:16:56,570 --> 00:17:01,580
function X takes some input parameter I

00:16:59,630 --> 00:17:03,890
and just computes 3 plus the log of I

00:17:01,580 --> 00:17:06,230
this is referentially transparent like

00:17:03,890 --> 00:17:07,819
that is not going to change given the

00:17:06,230 --> 00:17:10,790
same input that's always guaranteed to

00:17:07,819 --> 00:17:12,800
give the same output so let's suppose

00:17:10,790 --> 00:17:17,209
that I replace X with its result

00:17:12,800 --> 00:17:19,790
wherever I see it and foo I won't have

00:17:17,209 --> 00:17:22,010
any observable impact on the behavior of

00:17:19,790 --> 00:17:23,750
my program because X is referentially

00:17:22,010 --> 00:17:26,689
transparent and and as I mentioned

00:17:23,750 --> 00:17:29,540
substitutability is key to this this

00:17:26,689 --> 00:17:31,780
idea of referential transparency so

00:17:29,540 --> 00:17:34,880
let's take a look at a counter example

00:17:31,780 --> 00:17:39,110
this time X is a call to get the current

00:17:34,880 --> 00:17:41,270
time and foo is some function that takes

00:17:39,110 --> 00:17:43,840
an input parameter Y again another time

00:17:41,270 --> 00:17:47,700
and it checks whether Y is after X

00:17:43,840 --> 00:17:51,070
so let's say I run this function now at

00:17:47,700 --> 00:17:54,159
11:48 with an input parameter of y

00:17:51,070 --> 00:17:57,669
equals twelve O'Clock twelve is after

00:17:54,159 --> 00:17:59,200
eleven 48 so few returns true but now

00:17:57,669 --> 00:18:01,929
let's suppose I try that trick again of

00:17:59,200 --> 00:18:04,630
substituting that X with a direct call

00:18:01,929 --> 00:18:06,970
to get the current time well I can keep

00:18:04,630 --> 00:18:09,070
calling foo with that same input of Y is

00:18:06,970 --> 00:18:11,049
twelve o'clock and for a little while

00:18:09,070 --> 00:18:12,970
it's going to return true but as soon as

00:18:11,049 --> 00:18:15,279
the clock hits twelve food starts

00:18:12,970 --> 00:18:17,070
returning false even though I am calling

00:18:15,279 --> 00:18:19,419
it with the exact same input parameter

00:18:17,070 --> 00:18:21,250
and that's because we're relying on this

00:18:19,419 --> 00:18:22,690
thing that's called to the local to get

00:18:21,250 --> 00:18:26,830
the local time which is not

00:18:22,690 --> 00:18:28,659
referentially transparent like any good

00:18:26,830 --> 00:18:31,570
superhero referential transparency man

00:18:28,659 --> 00:18:32,640
has some super powers some of the things

00:18:31,570 --> 00:18:35,890
that referential transparency

00:18:32,640 --> 00:18:37,570
immediately gives us order independence

00:18:35,890 --> 00:18:39,100
we can run referentially transparent

00:18:37,570 --> 00:18:40,480
functions in any order because they're

00:18:39,100 --> 00:18:44,200
independent and they won't affect each

00:18:40,480 --> 00:18:46,000
other and for a similar reason we can

00:18:44,200 --> 00:18:48,070
run them in parallel we can run them

00:18:46,000 --> 00:18:49,690
asynchronously because we're guaranteed

00:18:48,070 --> 00:18:51,730
to get the same result every time that

00:18:49,690 --> 00:18:53,320
we call them so we kind of schedule them

00:18:51,730 --> 00:18:56,500
when we like and we can reorder them and

00:18:53,320 --> 00:18:57,669
run them in a way that makes sense and

00:18:56,500 --> 00:18:59,890
one of the other things that we get is

00:18:57,669 --> 00:19:03,190
portability so just like I can run these

00:18:59,890 --> 00:19:05,020
functions across any CPU I can also

00:19:03,190 --> 00:19:06,880
distribute them across an entire grid of

00:19:05,020 --> 00:19:08,380
machines and I mean these are dummy

00:19:06,880 --> 00:19:10,720
examples but you can imagine the

00:19:08,380 --> 00:19:13,419
benefits if if it's an expensive

00:19:10,720 --> 00:19:14,740
function and that leads on to the next

00:19:13,419 --> 00:19:17,440
thing that the referential transparency

00:19:14,740 --> 00:19:19,720
gives us which is memorization or

00:19:17,440 --> 00:19:22,570
caching and that's going to be the focus

00:19:19,720 --> 00:19:24,820
of today's talk so because this function

00:19:22,570 --> 00:19:27,730
is guaranteed to give the same result

00:19:24,820 --> 00:19:29,409
every time I call it I can just cache

00:19:27,730 --> 00:19:30,760
that result and then the next time I

00:19:29,409 --> 00:19:32,590
call the same function with the same

00:19:30,760 --> 00:19:34,809
input I can just retrieve that result

00:19:32,590 --> 00:19:36,909
directly from the cache because I know

00:19:34,809 --> 00:19:38,559
it won't have changed and I get that

00:19:36,909 --> 00:19:42,190
guarantee because the function is

00:19:38,559 --> 00:19:44,260
preferentially transparent ok so so far

00:19:42,190 --> 00:19:46,000
maybe you're thinking that this idea of

00:19:44,260 --> 00:19:48,250
referential transparency kind of

00:19:46,000 --> 00:19:50,649
conflicts with the idea of change and I

00:19:48,250 --> 00:19:53,860
will explain how those things get kind

00:19:50,649 --> 00:19:55,840
of tied together but for now this allows

00:19:53,860 --> 00:19:58,900
me to introduce the

00:19:55,840 --> 00:20:02,200
node and this is the core construct that

00:19:58,900 --> 00:20:05,740
underpins our solution it's it's an

00:20:02,200 --> 00:20:08,140
annotation and it's a construct that

00:20:05,740 --> 00:20:10,059
we've developed ourselves using a

00:20:08,140 --> 00:20:13,330
compiler plugin and it extends the Scala

00:20:10,059 --> 00:20:15,640
language so when you the developer

00:20:13,330 --> 00:20:17,260
annotate your function as a node you're

00:20:15,640 --> 00:20:20,350
guaranteeing to the compiler that it is

00:20:17,260 --> 00:20:23,860
referentially transparent and so the

00:20:20,350 --> 00:20:25,330
compiler can begin to make use of well

00:20:23,860 --> 00:20:27,159
it can transform the function in such a

00:20:25,330 --> 00:20:28,750
way that at runtime we can make use of

00:20:27,159 --> 00:20:32,590
some of those benefits that I mentioned

00:20:28,750 --> 00:20:34,480
before so it is up to the developer to

00:20:32,590 --> 00:20:37,360
ensure that function actually is

00:20:34,480 --> 00:20:38,470
referentially transparent and when we

00:20:37,360 --> 00:20:40,390
first started out we were kind of

00:20:38,470 --> 00:20:41,500
paranoid about this as we worried that

00:20:40,390 --> 00:20:43,090
people would do things that were not

00:20:41,500 --> 00:20:45,789
referentially transparent and try to

00:20:43,090 --> 00:20:48,190
annotate them as nodes so we did build a

00:20:45,789 --> 00:20:50,200
tool to help check for that but in

00:20:48,190 --> 00:20:52,270
practice we've never used it because it

00:20:50,200 --> 00:20:53,909
turns out that most referentially

00:20:52,270 --> 00:20:55,659
transparent functions are just kind of

00:20:53,909 --> 00:20:57,490
making calls to lots of other

00:20:55,659 --> 00:21:04,870
referentially transparent functions and

00:20:57,490 --> 00:21:07,809
then gluing together the results so let

00:21:04,870 --> 00:21:10,149
me go back one so what happens when we

00:21:07,809 --> 00:21:12,190
see a function annotated as a node well

00:21:10,149 --> 00:21:14,409
instead of compiling this function with

00:21:12,190 --> 00:21:16,480
the conventional Scala compiler we use

00:21:14,409 --> 00:21:18,610
Scala a sink which is bundled up with

00:21:16,480 --> 00:21:20,890
the Scala compiler and it generates a

00:21:18,610 --> 00:21:23,350
state machine representation of our

00:21:20,890 --> 00:21:25,210
function and we explained in our

00:21:23,350 --> 00:21:28,120
previous talk why that representation

00:21:25,210 --> 00:21:32,770
was crucial for us to be able to run

00:21:28,120 --> 00:21:34,390
things asynchronously but the main thing

00:21:32,770 --> 00:21:37,630
is that these state machines or these

00:21:34,390 --> 00:21:40,539
are nodes feed I feed work items into

00:21:37,630 --> 00:21:42,490
our scheduler so at compile time we're

00:21:40,539 --> 00:21:44,440
transforming the nodes and then at

00:21:42,490 --> 00:21:47,500
runtime we need something that can

00:21:44,440 --> 00:21:50,169
actually execute them so that's where

00:21:47,500 --> 00:21:52,510
the scheduler comes in and the scheduler

00:21:50,169 --> 00:21:54,130
can look ahead in its work queue of

00:21:52,510 --> 00:21:56,370
nodes and it can make intelligent

00:21:54,130 --> 00:21:59,230
decisions about how to run things and

00:21:56,370 --> 00:22:02,320
last last time that we spoke we spoke

00:21:59,230 --> 00:22:05,350
about how it can batch calls to the

00:22:02,320 --> 00:22:07,539
datastore for example or run things in

00:22:05,350 --> 00:22:08,500
parallel or asynchronously or distribute

00:22:07,539 --> 00:22:10,600
them across the grid

00:22:08,500 --> 00:22:13,900
but today we're going to focus on the

00:22:10,600 --> 00:22:17,170
cash our scheduler is cash aware which

00:22:13,900 --> 00:22:20,140
means that before it runs before it does

00:22:17,170 --> 00:22:22,500
any computation it looks up a result in

00:22:20,140 --> 00:22:25,630
the cash a previously computed result

00:22:22,500 --> 00:22:27,400
and I know that possibly some of you are

00:22:25,630 --> 00:22:29,020
thinking that after naming cache

00:22:27,400 --> 00:22:30,610
coherence and their validation are the

00:22:29,020 --> 00:22:32,140
hardest problems in computer science and

00:22:30,610 --> 00:22:34,930
we're definitely not smart enough to

00:22:32,140 --> 00:22:36,250
solve that but it's because we have the

00:22:34,930 --> 00:22:38,200
guarantees of referential transparency

00:22:36,250 --> 00:22:42,400
that our cash actually remains

00:22:38,200 --> 00:22:44,680
relatively simple so just to reiterate

00:22:42,400 --> 00:22:46,120
before we run any piece of code first we

00:22:44,680 --> 00:22:48,370
look up whether we've got a result for

00:22:46,120 --> 00:22:49,840
that piece of code in the cache but to

00:22:48,370 --> 00:22:51,340
do this lookup obviously you need a

00:22:49,840 --> 00:22:53,500
cache key and that's the bit that we've

00:22:51,340 --> 00:22:56,500
kind of glossed over so far but that's

00:22:53,500 --> 00:22:57,880
where addressability comes in and we're

00:22:56,500 --> 00:23:01,630
going to demonstrate this next bit

00:22:57,880 --> 00:23:04,480
through some live demos so address

00:23:01,630 --> 00:23:06,700
ability allows us to address a function

00:23:04,480 --> 00:23:08,770
called with certain parameters and then

00:23:06,700 --> 00:23:11,290
we can use that address in a cache to

00:23:08,770 --> 00:23:12,400
retrieve the result so bear with us

00:23:11,290 --> 00:23:15,250
because we're gonna start with a very

00:23:12,400 --> 00:23:16,840
simple example and we're going to build

00:23:15,250 --> 00:23:19,930
it up and because we can't multitask

00:23:16,840 --> 00:23:22,480
James is going to type loudly and I'm

00:23:19,930 --> 00:23:26,530
gonna keep explaining so let's suppose

00:23:22,480 --> 00:23:28,930
that our function calc 2 numbers this

00:23:26,530 --> 00:23:30,700
might be a height and a width or a price

00:23:28,930 --> 00:23:32,350
and a quantity doesn't really matter it

00:23:30,700 --> 00:23:35,050
multiplies the numbers and returns a

00:23:32,350 --> 00:23:36,370
result and this is referentially

00:23:35,050 --> 00:23:38,920
transparent that's always going to give

00:23:36,370 --> 00:23:41,830
us the same result so we can annotate it

00:23:38,920 --> 00:23:43,150
as a node and when we run it we do what

00:23:41,830 --> 00:23:46,090
we expect we see that print mind

00:23:43,150 --> 00:23:49,810
calculating than the result but now

00:23:46,090 --> 00:23:51,880
let's try running it again the answer is

00:23:49,810 --> 00:23:53,500
the same the difference is that we don't

00:23:51,880 --> 00:23:55,510
have that print line sorry if I'm

00:23:53,500 --> 00:23:58,330
blocking it we're no longer printing

00:23:55,510 --> 00:24:00,730
calculating there and that's because the

00:23:58,330 --> 00:24:03,040
scheduler hasn't actually executed any

00:24:00,730 --> 00:24:04,540
of the code in that body of that

00:24:03,040 --> 00:24:07,450
function

00:24:04,540 --> 00:24:10,540
we've looked up in the cache by our

00:24:07,450 --> 00:24:12,700
function name and we've retrieved the

00:24:10,540 --> 00:24:14,880
result directly and we can keep doing

00:24:12,700 --> 00:24:17,890
that I mean James can type it again a

00:24:14,880 --> 00:24:19,850
few times and each time we're just going

00:24:17,890 --> 00:24:22,190
to retrieve that result from the cache

00:24:19,850 --> 00:24:24,050
and again this is a simple example but

00:24:22,190 --> 00:24:26,180
imagine if this was some cpu-intensive

00:24:24,050 --> 00:24:28,010
thing or if it was making loads of calls

00:24:26,180 --> 00:24:30,760
to datastore you want to be able to

00:24:28,010 --> 00:24:34,760
cache that result if nothing's changed

00:24:30,760 --> 00:24:36,320
so in this in this instance our cache

00:24:34,760 --> 00:24:38,780
key can simply be the function name

00:24:36,320 --> 00:24:41,660
itself we can look up by that name and

00:24:38,780 --> 00:24:44,360
just retrieve from the cache so let's

00:24:41,660 --> 00:24:46,070
take it one step further and this time

00:24:44,360 --> 00:24:48,440
calc is going to take some input

00:24:46,070 --> 00:24:51,290
parameter which is a quantity and it's

00:24:48,440 --> 00:24:55,010
gonna think you need a switch slide so

00:24:51,290 --> 00:24:59,660
that we see the code sorry yeah it's

00:24:55,010 --> 00:25:00,770
like a genetic so calc is going to take

00:24:59,660 --> 00:25:02,420
some input parameter

00:25:00,770 --> 00:25:04,280
it's a quantity and it's going to

00:25:02,420 --> 00:25:06,380
multiply it by this number that we now

00:25:04,280 --> 00:25:08,960
probably can presume as a price and it

00:25:06,380 --> 00:25:10,850
does the same print line calculating so

00:25:08,960 --> 00:25:12,680
now we call calc with some input

00:25:10,850 --> 00:25:15,470
parameter of 20 and we see the print

00:25:12,680 --> 00:25:16,880
line and then we see the result but

00:25:15,470 --> 00:25:22,010
let's try calling calc again with that

00:25:16,880 --> 00:25:25,100
same input parameter and again you'll

00:25:22,010 --> 00:25:28,250
see that we lose that print line we just

00:25:25,100 --> 00:25:29,600
retrieved directly from the cache so our

00:25:28,250 --> 00:25:31,520
function is still referentially

00:25:29,600 --> 00:25:32,960
transparent because given the same input

00:25:31,520 --> 00:25:35,480
it's guaranteed to give us the same

00:25:32,960 --> 00:25:36,770
output and we can do this a number of

00:25:35,480 --> 00:25:38,630
times again and we'll see that each time

00:25:36,770 --> 00:25:40,610
we just retrieve directly from the cache

00:25:38,630 --> 00:25:44,210
and if we call this with a different

00:25:40,610 --> 00:25:46,550
input parameter 40 then we don't have a

00:25:44,210 --> 00:25:48,650
value already in the cache so we get a

00:25:46,550 --> 00:25:51,170
cache miss and that's when the scheduler

00:25:48,650 --> 00:25:53,150
actually executes code and we get a

00:25:51,170 --> 00:25:54,650
different result but now we've got two

00:25:53,150 --> 00:25:56,840
things in the cache the call to calc

00:25:54,650 --> 00:25:58,250
with 20 and the call to calc with 40 and

00:25:56,840 --> 00:25:59,450
so now we can retrieve both of those

00:25:58,250 --> 00:26:03,260
from the cache without doing any

00:25:59,450 --> 00:26:05,240
computation so it's no longer enough for

00:26:03,260 --> 00:26:08,360
our cache key to just be the function

00:26:05,240 --> 00:26:10,250
name if it were then we could call calc

00:26:08,360 --> 00:26:12,320
with an input parameter of 20 cache that

00:26:10,250 --> 00:26:13,520
result and if we try and look up just by

00:26:12,320 --> 00:26:15,410
the function name we're going to get a

00:26:13,520 --> 00:26:17,960
cache hit next time and that would just

00:26:15,410 --> 00:26:21,070
be bad so we now need to include the

00:26:17,960 --> 00:26:24,260
input parameter as part of our cache key

00:26:21,070 --> 00:26:26,780
and that guarantees that when we call a

00:26:24,260 --> 00:26:28,610
function with the same input parameter

00:26:26,780 --> 00:26:29,900
we're able to address it we're able to

00:26:28,610 --> 00:26:33,290
look it up in the cache and just

00:26:29,900 --> 00:26:36,919
retrieve that result directly ok

00:26:33,290 --> 00:26:38,419
so let's build up on this some more now

00:26:36,919 --> 00:26:41,510
let's suppose that this function is

00:26:38,419 --> 00:26:43,400
actually a method on some class fuel

00:26:41,510 --> 00:26:46,669
cost and a fuel cost take some

00:26:43,400 --> 00:26:47,990
constructor parameters an FX rate which

00:26:46,669 --> 00:26:52,190
we showed you before that's just a

00:26:47,990 --> 00:26:55,100
string currency and then a rate and a

00:26:52,190 --> 00:26:57,440
price which is a double and our function

00:26:55,100 --> 00:26:59,360
now depends on one of those constructor

00:26:57,440 --> 00:27:02,090
parameters you can see it there we're

00:26:59,360 --> 00:27:06,830
multiplying price by quantity by the

00:27:02,090 --> 00:27:09,110
rate so let's construct a fuel cost F

00:27:06,830 --> 00:27:10,940
we've got an FX James I showed you up

00:27:09,110 --> 00:27:14,240
there that we've already constructed

00:27:10,940 --> 00:27:15,830
just to save on some typing so we we can

00:27:14,240 --> 00:27:19,070
construct this F with a constructor

00:27:15,830 --> 00:27:21,620
parameter of 30 for the price and we can

00:27:19,070 --> 00:27:25,460
call our function calc on that instance

00:27:21,620 --> 00:27:26,540
F with certain input parameters so here

00:27:25,460 --> 00:27:28,970
we're calling it with an input parameter

00:27:26,540 --> 00:27:31,669
of 20 and this is the first time that

00:27:28,970 --> 00:27:34,970
we've run this this method on this

00:27:31,669 --> 00:27:38,510
instance of fuel cost and so we see the

00:27:34,970 --> 00:27:40,580
print line - calculating and now we we

00:27:38,510 --> 00:27:42,470
have that result in the cash so if we

00:27:40,580 --> 00:27:44,299
call calc again with the same input

00:27:42,470 --> 00:27:45,830
parameter on the same instance we're

00:27:44,299 --> 00:27:47,270
going to get the same thing without

00:27:45,830 --> 00:27:50,120
printing calculating because we're

00:27:47,270 --> 00:27:51,650
retrieving direct from the cash so now

00:27:50,120 --> 00:27:55,640
let's try constructing another instance

00:27:51,650 --> 00:27:59,169
G of fuel cost where we now change the

00:27:55,640 --> 00:28:03,350
price for our constructor parameters and

00:27:59,169 --> 00:28:06,500
our because our calc depends on the

00:28:03,350 --> 00:28:09,020
constructor parameters if we call calc

00:28:06,500 --> 00:28:11,660
with the same input parameter again we

00:28:09,020 --> 00:28:14,390
have to rerun the function so you see

00:28:11,660 --> 00:28:16,250
the print line to calculating again and

00:28:14,390 --> 00:28:19,850
that's because this is a different

00:28:16,250 --> 00:28:21,500
instance of fuel cost and so we we need

00:28:19,850 --> 00:28:23,660
to take that into account because our

00:28:21,500 --> 00:28:25,880
calc although it is referentially

00:28:23,660 --> 00:28:28,040
transparent it's only referentially

00:28:25,880 --> 00:28:31,460
transparent because we are using the

00:28:28,040 --> 00:28:34,220
same constructor parameters so given the

00:28:31,460 --> 00:28:35,750
same input and called on the same

00:28:34,220 --> 00:28:38,360
instance of the class

00:28:35,750 --> 00:28:40,850
this method calc is referentially

00:28:38,360 --> 00:28:44,090
transparent and so we've annotated it as

00:28:40,850 --> 00:28:46,640
a node and once we've run the

00:28:44,090 --> 00:28:50,720
calculation on our new instance G

00:28:46,640 --> 00:28:52,070
we can run it again and we should get we

00:28:50,720 --> 00:28:53,690
should lose that print line because

00:28:52,070 --> 00:28:57,230
we're now retrieving directly from the

00:28:53,690 --> 00:29:00,410
cache so what does this do to our cache

00:28:57,230 --> 00:29:03,200
key well if we switch back to the slides

00:29:00,410 --> 00:29:04,790
now it's no longer enough to just have

00:29:03,200 --> 00:29:08,870
the function name and the input

00:29:04,790 --> 00:29:10,910
parameters we also need some idea of our

00:29:08,870 --> 00:29:14,540
identity and that's where this construct

00:29:10,910 --> 00:29:19,700
the entity comes in an entity allows us

00:29:14,540 --> 00:29:21,320
to identify classes and equality works

00:29:19,700 --> 00:29:23,929
sort of in the same way as Scala case

00:29:21,320 --> 00:29:28,610
classes and hashcode and equals defined

00:29:23,929 --> 00:29:31,700
in a similar way so if we now have the

00:29:28,610 --> 00:29:35,620
entity identity and the function name

00:29:31,700 --> 00:29:38,660
and the parameters then we can address

00:29:35,620 --> 00:29:40,850
calls to this function with a certain

00:29:38,660 --> 00:29:43,190
input on a certain instance of our class

00:29:40,850 --> 00:29:45,650
in the cache and we can retrieve things

00:29:43,190 --> 00:29:47,440
directly from the cache so we can

00:29:45,650 --> 00:29:50,030
construct loads of these fuel cost

00:29:47,440 --> 00:29:51,830
instances and we can call calc with

00:29:50,030 --> 00:29:53,600
different parameters and we'll cache the

00:29:51,830 --> 00:29:55,520
results so we guaranteed not to run the

00:29:53,600 --> 00:29:57,220
same function twice unless we've had to

00:29:55,520 --> 00:30:00,710
clear the cache but that's another story

00:29:57,220 --> 00:30:02,480
right so let's go back now to that first

00:30:00,710 --> 00:30:05,150
example that we introduced that was like

00:30:02,480 --> 00:30:06,830
a little bit complex but really nothing

00:30:05,150 --> 00:30:09,169
on like what you'd get in the real world

00:30:06,830 --> 00:30:15,980
but just to show you that this is like a

00:30:09,169 --> 00:30:19,520
useful thing so this time is is this the

00:30:15,980 --> 00:30:22,040
right one yeah we can do the tweaks okay

00:30:19,520 --> 00:30:24,470
I skipped ahead I'll come back a bit so

00:30:22,040 --> 00:30:26,240
so we've we've kind of explained enough

00:30:24,470 --> 00:30:28,790
I think to finally get back to the

00:30:26,240 --> 00:30:30,650
problem of change how do we apply change

00:30:28,790 --> 00:30:32,330
here like all of these things are vowels

00:30:30,650 --> 00:30:34,640
we're not going to be able to just

00:30:32,330 --> 00:30:37,970
mutate them well

00:30:34,640 --> 00:30:41,090
we've constructed this idea of tweak

00:30:37,970 --> 00:30:43,910
which expresses intent to apply a change

00:30:41,090 --> 00:30:46,100
and tweaks can be collected together and

00:30:43,910 --> 00:30:47,900
wrapped up in a scenario and the whole

00:30:46,100 --> 00:30:50,600
scenario is this thing that we actually

00:30:47,900 --> 00:30:52,790
apply later and once we've applied that

00:30:50,600 --> 00:30:57,289
and we're in that context we see the

00:30:52,790 --> 00:31:00,749
changes as if we'd mutated our fields so

00:30:57,289 --> 00:31:05,639
we've got some scenario here where our

00:31:00,749 --> 00:31:08,610
rate is 8.13 so inside the scenario we

00:31:05,639 --> 00:31:13,309
put these tweaks the tweaks will change

00:31:08,610 --> 00:31:15,749
the rate on our on our instance f2b 8.13

00:31:13,309 --> 00:31:18,090
and now we we've defined that scenario

00:31:15,749 --> 00:31:20,399
that change is kind of neatly

00:31:18,090 --> 00:31:22,379
encapsulated into this new into this new

00:31:20,399 --> 00:31:25,110
object and it's a clean way to manage

00:31:22,379 --> 00:31:27,749
change but we haven't actually applied

00:31:25,110 --> 00:31:31,320
the change right so to do that we have

00:31:27,749 --> 00:31:34,320
this construct yes so you see if we call

00:31:31,320 --> 00:31:35,629
Cal with that input parameter of 20 we

00:31:34,320 --> 00:31:38,100
retrieve the result from the cache

00:31:35,629 --> 00:31:40,379
that's because rate hasn't changed when

00:31:38,100 --> 00:31:41,610
we're not in the scenario but to

00:31:40,379 --> 00:31:43,799
actually apply the change we need

00:31:41,610 --> 00:31:45,690
something called a given block and we

00:31:43,799 --> 00:31:47,999
can pass our scenario into this block

00:31:45,690 --> 00:31:50,580
and then we can run our calculation in

00:31:47,999 --> 00:31:53,399
there so if we now were on F calc with

00:31:50,580 --> 00:31:54,539
that same input parameter do you want to

00:31:53,399 --> 00:31:56,309
just look at the value first oh yeah

00:31:54,539 --> 00:31:58,080
let's look at the value to prove that

00:31:56,309 --> 00:32:03,570
it's changed so if we look at the rate

00:31:58,080 --> 00:32:06,840
in here inside our scenario we should

00:32:03,570 --> 00:32:09,360
see that it's 8.13 but if we are back

00:32:06,840 --> 00:32:11,820
out of our scenario it's very dense if

00:32:09,360 --> 00:32:14,879
we're back out of the scenario where you

00:32:11,820 --> 00:32:17,399
haven't done any mutation so this should

00:32:14,879 --> 00:32:20,610
still be 8.88 which is what it started

00:32:17,399 --> 00:32:22,139
as originally so where we're trying as

00:32:20,610 --> 00:32:25,320
hard as we can not to get away from

00:32:22,139 --> 00:32:26,669
immutable state so now let's put this in

00:32:25,320 --> 00:32:31,830
a given block to actually apply the

00:32:26,669 --> 00:32:33,360
change and let's do our calculation now

00:32:31,830 --> 00:32:35,220
because the rate is different we haven't

00:32:33,360 --> 00:32:36,389
done this one before so there's no cache

00:32:35,220 --> 00:32:38,549
hit here we're gonna have to run the

00:32:36,389 --> 00:32:40,320
function and you'll see the print line

00:32:38,549 --> 00:32:42,330
too calculating and then a different

00:32:40,320 --> 00:32:44,190
result from last time and if we come

00:32:42,330 --> 00:32:46,169
back out of the scenario then we have no

00:32:44,190 --> 00:32:47,279
tweaks applied there are no changes that

00:32:46,169 --> 00:32:53,369
we've applied and so we have our

00:32:47,279 --> 00:32:54,840
original rate again so this is like this

00:32:53,369 --> 00:32:58,049
is this is nice it's kind of neat it's a

00:32:54,840 --> 00:33:00,629
neat way to encapsulate our our intent

00:32:58,049 --> 00:33:02,249
to change things but it's still probably

00:33:00,629 --> 00:33:04,320
not the code that developers want to

00:33:02,249 --> 00:33:06,029
write and so we've added some syntax

00:33:04,320 --> 00:33:08,549
sugar on top of this that allows you to

00:33:06,029 --> 00:33:09,490
specify your tweak directly inside the

00:33:08,549 --> 00:33:14,020
given block

00:33:09,490 --> 00:33:16,870
so a given rate gets 8.13 we can run our

00:33:14,020 --> 00:33:21,279
function f calc with that same input

00:33:16,870 --> 00:33:22,720
parameter of 20 and when we run it what

00:33:21,279 --> 00:33:26,380
we should see is that we get a cache hit

00:33:22,720 --> 00:33:27,909
and that's because our scenario is equal

00:33:26,380 --> 00:33:30,159
well the underlying mechanics are the

00:33:27,909 --> 00:33:31,809
same when we've written the given block

00:33:30,159 --> 00:33:33,820
in this way with the tweak we've

00:33:31,809 --> 00:33:37,240
constructed a scenario to encapsulate

00:33:33,820 --> 00:33:38,890
the tweak and we get a cache hit because

00:33:37,240 --> 00:33:42,059
the calculation is essentially the same

00:33:38,890 --> 00:33:45,100
and we can construct another scenario s2

00:33:42,059 --> 00:33:46,330
that has the same tweak in it and we can

00:33:45,100 --> 00:33:55,809
just check that these scenarios are

00:33:46,330 --> 00:34:00,510
equal you're doing well so far though I

00:33:55,809 --> 00:34:04,240
mean no typos that I've noticed yeah oh

00:34:00,510 --> 00:34:06,929
let's make too soon did you set it Wow

00:34:04,240 --> 00:34:14,040
yeah okay so we can construct our

00:34:06,929 --> 00:34:16,960
scenario s2 with the same tweak yep

00:34:14,040 --> 00:34:21,750
we've practiced this only like 17 times

00:34:16,960 --> 00:34:24,790
so I think I think they're good right

00:34:21,750 --> 00:34:28,330
and now we can check that it's equal to

00:34:24,790 --> 00:34:30,730
RS that we had before it is which is

00:34:28,330 --> 00:34:32,889
cool so that means that under the same

00:34:30,730 --> 00:34:34,929
scenario we're going to get cache hits

00:34:32,889 --> 00:34:37,419
but what this means is that we need to

00:34:34,929 --> 00:34:39,720
update our cache key so let's go back to

00:34:37,419 --> 00:34:42,460
the slides again and see what this does

00:34:39,720 --> 00:34:44,200
so now it's no longer enough just to

00:34:42,460 --> 00:34:46,300
have our instance and our function and

00:34:44,200 --> 00:34:47,980
our input parameters we also need the

00:34:46,300 --> 00:34:49,540
scenario under which we're running the

00:34:47,980 --> 00:34:52,419
calculation in order to be able to

00:34:49,540 --> 00:34:54,790
address our calls to the function and to

00:34:52,419 --> 00:34:58,359
apply change and so we include the

00:34:54,790 --> 00:35:00,310
scenario as part of our cache key so the

00:34:58,359 --> 00:35:02,560
first time we called

00:35:00,310 --> 00:35:05,080
calc with an empty scenario which means

00:35:02,560 --> 00:35:06,280
no tweaks it means that rate is eight

00:35:05,080 --> 00:35:08,470
point eight eight which is how we

00:35:06,280 --> 00:35:11,170
constructed our object in the first

00:35:08,470 --> 00:35:14,530
place but we have another scenario where

00:35:11,170 --> 00:35:16,660
we've set the rate to 8.13 and that's

00:35:14,530 --> 00:35:20,520
what allows us to cache that call to

00:35:16,660 --> 00:35:22,860
calc under any other scenario

00:35:20,520 --> 00:35:24,570
okay so now that we've covered that bit

00:35:22,860 --> 00:35:26,490
and now that we've shown you change we

00:35:24,570 --> 00:35:28,440
can show it we can go back to our

00:35:26,490 --> 00:35:37,220
original example the more complicated

00:35:28,440 --> 00:35:41,910
problem so if we get the shorten that's

00:35:37,220 --> 00:35:47,090
what if I yep okay so this time we have

00:35:41,910 --> 00:35:47,090
a whoa you want to go back to that rest

00:35:50,150 --> 00:36:01,500
you're in a new one use the mouse I mean

00:35:53,190 --> 00:36:04,710
it's okay before right now okay but we

00:36:01,500 --> 00:36:07,830
still need to be in this one okay all

00:36:04,710 --> 00:36:09,330
right sorry about that live demos okay

00:36:07,830 --> 00:36:10,740
so this time we have a flight that we've

00:36:09,330 --> 00:36:13,110
already constructed because it's kind of

00:36:10,740 --> 00:36:14,580
long but the flight has a fuel cost

00:36:13,110 --> 00:36:16,230
which we were using before and it also

00:36:14,580 --> 00:36:18,980
has this occupancy score which is

00:36:16,230 --> 00:36:24,330
another object that contains a rate and

00:36:18,980 --> 00:36:26,850
some like occupancy of the flight so we

00:36:24,330 --> 00:36:28,290
can call these functions we have two

00:36:26,850 --> 00:36:32,760
functions that we've defined on on

00:36:28,290 --> 00:36:36,150
flight and those are fuel cost which

00:36:32,760 --> 00:36:41,220
uses the fuel cost object to calculate

00:36:36,150 --> 00:36:43,530
the rate and we've also got projected

00:36:41,220 --> 00:36:46,380
occupancy which uses that occupancy

00:36:43,530 --> 00:36:50,610
score object to calculate some projected

00:36:46,380 --> 00:36:52,560
occupancy so we can we don't have to

00:36:50,610 --> 00:36:54,840
understand this entire dependency graph

00:36:52,560 --> 00:36:57,900
in order to make a change the platform

00:36:54,840 --> 00:37:00,000
can kind of propagate changes through

00:36:57,900 --> 00:37:02,400
the system and only tweak the things

00:37:00,000 --> 00:37:05,690
that need to be tweaked so let's say

00:37:02,400 --> 00:37:08,550
that we now change the flight dot fuel

00:37:05,690 --> 00:37:11,790
dot local currency whatever it is that

00:37:08,550 --> 00:37:15,660
we need to do to change the rate and we

00:37:11,790 --> 00:37:21,300
can tweak it to be something else and

00:37:15,660 --> 00:37:23,480
then calculate the fuel cost yeah your

00:37:21,300 --> 00:37:23,480
boss

00:37:23,820 --> 00:37:29,040
and our system propagates that change

00:37:26,430 --> 00:37:30,930
through so that we don't have to kind of

00:37:29,040 --> 00:37:33,030
bend the dependency graph into shape or

00:37:30,930 --> 00:37:35,369
understand it at all

00:37:33,030 --> 00:37:38,970
and we can do the same thing again with

00:37:35,369 --> 00:37:41,640
projected occupancy well if we change

00:37:38,970 --> 00:37:47,400
the rate then that should have an impact

00:37:41,640 --> 00:37:49,830
on the occupancy score as well so what

00:37:47,400 --> 00:37:53,099
we've done we think is to come as close

00:37:49,830 --> 00:37:55,800
as possible to that syntactically nice

00:37:53,099 --> 00:37:58,500
way of just mutating VARs in in a

00:37:55,800 --> 00:38:01,080
procedural language but without losing

00:37:58,500 --> 00:38:04,130
the benefits of immutable state and also

00:38:01,080 --> 00:38:07,099
without incurring the costs of firstly

00:38:04,130 --> 00:38:09,270
difficult to read code and secondly

00:38:07,099 --> 00:38:13,290
creating new objects all the time when

00:38:09,270 --> 00:38:15,480
we're trying to apply a change so this

00:38:13,290 --> 00:38:17,670
way our developers get to write the

00:38:15,480 --> 00:38:21,570
codes that they want to write they get

00:38:17,670 --> 00:38:23,790
to just set rates to 8.13 and our

00:38:21,570 --> 00:38:26,849
platform can still maintain the benefits

00:38:23,790 --> 00:38:28,470
of referential transparency because we

00:38:26,849 --> 00:38:31,230
take into account the scenario and the

00:38:28,470 --> 00:38:38,369
instance identity and function and the

00:38:31,230 --> 00:38:40,710
parameters in our cache key yeah so to

00:38:38,369 --> 00:38:42,810
summarize this this whole thing you know

00:38:40,710 --> 00:38:44,910
you saw the the in the end we were able

00:38:42,810 --> 00:38:47,040
to create those five objects and we were

00:38:44,910 --> 00:38:48,960
able to locate that currency rate and

00:38:47,040 --> 00:38:51,450
change it and when we did it was

00:38:48,960 --> 00:38:53,580
effective for everything but there are a

00:38:51,450 --> 00:38:55,230
few things that are different to the

00:38:53,580 --> 00:38:58,320
other models like we've got the syntax

00:38:55,230 --> 00:39:00,960
of the arrow model but we've only we're

00:38:58,320 --> 00:39:03,540
only creating one object for each change

00:39:00,960 --> 00:39:05,520
so like how changes linear like our

00:39:03,540 --> 00:39:07,470
impact of object creation is linear to

00:39:05,520 --> 00:39:09,599
the change that we're that we're trying

00:39:07,470 --> 00:39:11,280
to make rather than having to

00:39:09,599 --> 00:39:12,480
reconstruct the whole object graph which

00:39:11,280 --> 00:39:15,960
is what we would be forced to do in the

00:39:12,480 --> 00:39:17,760
FP model also I think it's easier to

00:39:15,960 --> 00:39:19,800
read the code you know when you read

00:39:17,760 --> 00:39:21,089
these code which has this thing where

00:39:19,800 --> 00:39:22,680
I've said oh I'm gonna change this one

00:39:21,089 --> 00:39:24,270
thing here it's much easier to

00:39:22,680 --> 00:39:26,130
understand that that's what your truck

00:39:24,270 --> 00:39:27,359
you're trying to change and the runtime

00:39:26,130 --> 00:39:30,300
takes care of doing those things

00:39:27,359 --> 00:39:32,940
efficiently and and that all bound

00:39:30,300 --> 00:39:34,800
together that that may means that you

00:39:32,940 --> 00:39:36,360
know we've taken advantage of the fact

00:39:34,800 --> 00:39:38,460
that because you can address the

00:39:36,360 --> 00:39:39,810
and all of that comes from functional

00:39:38,460 --> 00:39:42,000
programming like the addressability is

00:39:39,810 --> 00:39:43,860
only really possible because you need

00:39:42,000 --> 00:39:45,570
that for to gain the benefits of

00:39:43,860 --> 00:39:46,620
referential transparency because once

00:39:45,570 --> 00:39:48,720
you've got the referential transparency

00:39:46,620 --> 00:39:50,580
or obviously the next step is to cache

00:39:48,720 --> 00:39:52,740
things but if you cache things then you

00:39:50,580 --> 00:39:54,480
make them addressable right so now we've

00:39:52,740 --> 00:39:56,880
got the addressability you can also use

00:39:54,480 --> 00:39:59,550
that address to make a change and that's

00:39:56,880 --> 00:40:01,110
really the the solution that we've

00:39:59,550 --> 00:40:04,160
settled on and that's that's what we

00:40:01,110 --> 00:40:07,110
that's what we're here to talk about and

00:40:04,160 --> 00:40:09,000
you know maybe we just mentioned that in

00:40:07,110 --> 00:40:12,630
another talk we talked about concurrency

00:40:09,000 --> 00:40:14,130
we can also use this change mechanism to

00:40:12,630 --> 00:40:16,980
still get the benefits of being able to

00:40:14,130 --> 00:40:19,140
paralyze all of the execution which is

00:40:16,980 --> 00:40:20,430
obviously also beneficial because you

00:40:19,140 --> 00:40:22,200
you don't wind up with all these

00:40:20,430 --> 00:40:23,910
problems of multi-threading that you

00:40:22,200 --> 00:40:25,650
tend to get with change because the

00:40:23,910 --> 00:40:29,700
change is bound up inside of this

00:40:25,650 --> 00:40:32,760
scenario and it's easy to understand so

00:40:29,700 --> 00:40:34,980
just a little bit more we've got a few

00:40:32,760 --> 00:40:36,510
more minutes I hope did we make it yeah

00:40:34,980 --> 00:40:38,520
we've got a few more minutes so so we've

00:40:36,510 --> 00:40:40,470
added this as a kind of additional

00:40:38,520 --> 00:40:42,420
things in our run-through we had time

00:40:40,470 --> 00:40:46,080
and which is about how address ability

00:40:42,420 --> 00:40:48,570
can help you elsewhere so we have this

00:40:46,080 --> 00:40:50,220
address addressable code but also UI is

00:40:48,570 --> 00:40:51,840
stressful right you know if you've got

00:40:50,220 --> 00:40:53,250
your UI you've got the window and in

00:40:51,840 --> 00:40:54,750
this case inside of the window I've got

00:40:53,250 --> 00:40:56,820
a grid and inside of the grid I've got

00:40:54,750 --> 00:40:58,740
various widgets a live label a text box

00:40:56,820 --> 00:41:00,840
now that's all an addressable thing that

00:40:58,740 --> 00:41:03,030
I've got there and as we've spent the

00:41:00,840 --> 00:41:05,130
last sort of half an hour explaining our

00:41:03,030 --> 00:41:07,110
codes addressable - so we've got these

00:41:05,130 --> 00:41:09,150
things and we can reach inside and we

00:41:07,110 --> 00:41:11,550
can address the code now the nice thing

00:41:09,150 --> 00:41:14,370
that we've got is that we can talk to

00:41:11,550 --> 00:41:15,990
this scheduler runtime that we have and

00:41:14,370 --> 00:41:17,400
we can ask the shared a runtime to

00:41:15,990 --> 00:41:19,560
operate in a completely different

00:41:17,400 --> 00:41:23,100
fashion so we can say okay we want you

00:41:19,560 --> 00:41:25,020
to start running and when you run and we

00:41:23,100 --> 00:41:27,510
have a DSL that looks like this we want

00:41:25,020 --> 00:41:29,610
you to connect two sides of addressable

00:41:27,510 --> 00:41:31,590
componentry together so we have these

00:41:29,610 --> 00:41:34,770
operators that we added and now all this

00:41:31,590 --> 00:41:38,490
- this text box here can address the

00:41:34,770 --> 00:41:39,720
rate and then the fuel cost is basically

00:41:38,490 --> 00:41:41,970
another address where we're reaching the

00:41:39,720 --> 00:41:44,480
rate out and we get this UI up the top

00:41:41,970 --> 00:41:47,000
here where the the

00:41:44,480 --> 00:41:49,369
run-time knows that when a change is

00:41:47,000 --> 00:41:51,589
made to the textbox it will like create

00:41:49,369 --> 00:41:53,630
a tweak and then it will push the tweak

00:41:51,589 --> 00:41:55,810
into the runtime and the runtime will

00:41:53,630 --> 00:41:57,770
work out what needs to be recalculated

00:41:55,810 --> 00:41:59,390
now it knows what needs to be

00:41:57,770 --> 00:42:01,070
recalculated because the first time when

00:41:59,390 --> 00:42:02,960
it read that addressable flight dot fuel

00:42:01,070 --> 00:42:04,339
cost it would have worked out well that

00:42:02,960 --> 00:42:08,000
flight don't feel costs that touched

00:42:04,339 --> 00:42:10,099
this rate so I know that if you change

00:42:08,000 --> 00:42:13,070
that rate I need to rerun it so by

00:42:10,099 --> 00:42:15,230
having this hydrated model where I can

00:42:13,070 --> 00:42:16,730
see my dependencies and by having this

00:42:15,230 --> 00:42:18,950
address ability I can write code like

00:42:16,730 --> 00:42:20,420
this which builds you ice and I

00:42:18,950 --> 00:42:25,720
hopefully Jess was about to actually

00:42:20,420 --> 00:42:30,500
show ya so it's it's not fiction tiny

00:42:25,720 --> 00:42:38,380
let me do the better all right guys see

00:42:30,500 --> 00:42:38,380
that yeah hey and the numbers match

00:42:38,890 --> 00:42:44,480
which we always have thought they were

00:42:40,940 --> 00:42:46,670
going those all fun so you can we can

00:42:44,480 --> 00:42:49,670
build you ice in this in this style and

00:42:46,670 --> 00:42:50,960
and but we don't you know this is a demo

00:42:49,670 --> 00:42:52,520
and it hopefully it ties back and it

00:42:50,960 --> 00:42:54,770
makes sense how we we use that address

00:42:52,520 --> 00:42:56,720
ability in order to achieve this black

00:42:54,770 --> 00:43:01,280
very simple and nice way to build

00:42:56,720 --> 00:43:02,720
reactive you eyes but we also got much

00:43:01,280 --> 00:43:05,329
bigger you ice which have got more

00:43:02,720 --> 00:43:08,780
complexity it still worked and it scales

00:43:05,329 --> 00:43:11,329
because you know anytime you're you're

00:43:08,780 --> 00:43:12,920
only holding on to a bunch of objects

00:43:11,329 --> 00:43:16,040
we've represent the changes that you

00:43:12,920 --> 00:43:18,530
wanted to make to the underlying set of

00:43:16,040 --> 00:43:20,000
objects that you created and that means

00:43:18,530 --> 00:43:22,180
that you can just go and do like

00:43:20,000 --> 00:43:24,800
actually quite significantly complicated

00:43:22,180 --> 00:43:26,240
things with with these you eyes this

00:43:24,800 --> 00:43:28,520
just demonstrates like we've got a 3d

00:43:26,240 --> 00:43:30,500
thing here where you can add like noise

00:43:28,520 --> 00:43:32,630
and twist it and stuff and when you

00:43:30,500 --> 00:43:33,920
click on points it it knows that you've

00:43:32,630 --> 00:43:35,780
clicked on the point and it can

00:43:33,920 --> 00:43:38,390
represent the point in the in the

00:43:35,780 --> 00:43:43,400
container and stuff like that

00:43:38,390 --> 00:43:45,290
okay so how do we do this I I think

00:43:43,400 --> 00:43:47,690
there's a kind of a balance we have

00:43:45,290 --> 00:43:49,130
extremely two mounting people who are

00:43:47,690 --> 00:43:51,620
like what I don't want to write code

00:43:49,130 --> 00:43:53,420
that looks like that his heart but at

00:43:51,620 --> 00:43:56,120
the same time the people who sponsor us

00:43:53,420 --> 00:43:59,240
internally or extremely well with

00:43:56,120 --> 00:44:01,490
resources and and and helped us to be

00:43:59,240 --> 00:44:04,730
more effective and I think that that's

00:44:01,490 --> 00:44:06,980
why we got there and also you know we're

00:44:04,730 --> 00:44:08,660
two people of a very large team of 500

00:44:06,980 --> 00:44:10,790
and and they're and they're some

00:44:08,660 --> 00:44:13,370
spectacularly talented developers and

00:44:10,790 --> 00:44:15,740
engineers in that group and we we're

00:44:13,370 --> 00:44:17,330
just here to represent the work that

00:44:15,740 --> 00:44:19,430
they have they've all collectively done

00:44:17,330 --> 00:44:21,530
to achieve this it definitely is no one

00:44:19,430 --> 00:44:23,120
person brainchild it's it's the result

00:44:21,530 --> 00:44:25,940
of many different people working

00:44:23,120 --> 00:44:27,890
together to build these ideas and make

00:44:25,940 --> 00:44:30,620
them a success

00:44:27,890 --> 00:44:33,050
we still have loads of stuff to do we

00:44:30,620 --> 00:44:34,400
want to improve the way that we do this

00:44:33,050 --> 00:44:35,960
reuse you know we've shown you some

00:44:34,400 --> 00:44:37,520
primitive things here but actually there

00:44:35,960 --> 00:44:40,940
are much more complex ways that we can

00:44:37,520 --> 00:44:42,580
do reuse we also have various ways where

00:44:40,940 --> 00:44:45,080
we know we can improve performance by

00:44:42,580 --> 00:44:46,370
taking shortcuts because of information

00:44:45,080 --> 00:44:50,120
that we have available because in the

00:44:46,370 --> 00:44:51,530
model we want to do better with like our

00:44:50,120 --> 00:44:53,480
programmer experience which at the

00:44:51,530 --> 00:44:56,150
moment is slightly open and it needs to

00:44:53,480 --> 00:45:00,410
be more possible for people to control

00:44:56,150 --> 00:45:01,910
like what can be can be changed which we

00:45:00,410 --> 00:45:04,160
use on obviously under Advisory of what

00:45:01,910 --> 00:45:05,690
can appear to change and then we have

00:45:04,160 --> 00:45:07,370
like a whole bunch of other things where

00:45:05,690 --> 00:45:09,860
we have problems like dealing with the

00:45:07,370 --> 00:45:12,590
JVM it gets confused by the fact that we

00:45:09,860 --> 00:45:14,450
just allocate caches which we don't care

00:45:12,590 --> 00:45:15,620
if we lose them because if you lose some

00:45:14,450 --> 00:45:17,660
it's referentially transparents not a

00:45:15,620 --> 00:45:19,160
big deal you can just create it again so

00:45:17,660 --> 00:45:22,190
there are lots of things that we we

00:45:19,160 --> 00:45:23,570
still want to build and we haven't got

00:45:22,190 --> 00:45:26,240
time today but we've got some nice tools

00:45:23,570 --> 00:45:28,280
which enable you to debug but but we

00:45:26,240 --> 00:45:31,310
want to improve those as well so there's

00:45:28,280 --> 00:45:32,810
a lot to do but it's it's been a great

00:45:31,310 --> 00:45:34,550
project and I think that these ideas are

00:45:32,810 --> 00:45:38,000
worth sharing which is why we're here

00:45:34,550 --> 00:45:41,080
today and that's it so no one's got any

00:45:38,000 --> 00:45:44,110
questions for Jess or I

00:45:41,080 --> 00:45:52,360
okay thank you very much your time James

00:45:44,110 --> 00:45:55,120
way of some time for some okay so thanks

00:45:52,360 --> 00:45:57,490
for the great presentation one question

00:45:55,120 --> 00:45:59,350
I had is what you showed why where you

00:45:57,490 --> 00:46:01,210
had an object graph which was fixed and

00:45:59,350 --> 00:46:03,100
then he applied tweaks to the attributes

00:46:01,210 --> 00:46:05,470
of some of the nodes of the graph can

00:46:03,100 --> 00:46:07,540
you also tweak the graph itself that you

00:46:05,470 --> 00:46:12,550
essentially changed and know that the

00:46:07,540 --> 00:46:14,560
edges in the graph yes that's the show

00:46:12,550 --> 00:46:16,000
answer yes I mean the those fields we

00:46:14,560 --> 00:46:17,890
just treat primitives because it's

00:46:16,000 --> 00:46:22,870
quicker to type in the demo right but

00:46:17,890 --> 00:46:24,700
you can tweak in another pointer and

00:46:22,870 --> 00:46:27,130
then my second question was so you

00:46:24,700 --> 00:46:28,300
started with a base model of the initial

00:46:27,130 --> 00:46:30,490
values of everything and then you

00:46:28,300 --> 00:46:33,370
applied tweak scan does it even make

00:46:30,490 --> 00:46:35,350
sense or do you do that that at some

00:46:33,370 --> 00:46:37,030
point you can consolidate a tweak in the

00:46:35,350 --> 00:46:38,830
in the base model and thereby have a new

00:46:37,030 --> 00:46:40,690
model to start with because I imagine a

00:46:38,830 --> 00:46:44,590
lot of changes will accumulate over time

00:46:40,690 --> 00:46:45,940
yeah but also we didn't really go into

00:46:44,590 --> 00:46:47,590
the details like because we've got this

00:46:45,940 --> 00:46:49,030
compiler plug-in and when you're right

00:46:47,590 --> 00:46:49,990
at entity it kind of wakes up the

00:46:49,030 --> 00:46:51,370
compiler and we change

00:46:49,990 --> 00:46:54,100
everything there are lots of other

00:46:51,370 --> 00:46:56,260
things we can do like where where we

00:46:54,100 --> 00:46:58,660
have one of those nodes what we've also

00:46:56,260 --> 00:47:00,280
got is a hidden field so if you change

00:46:58,660 --> 00:47:01,810
it will stuff the new value in the hid

00:47:00,280 --> 00:47:05,290
in the field so we kind of effectively

00:47:01,810 --> 00:47:08,200
doing that anyway so I mean the answer's

00:47:05,290 --> 00:47:09,940
yes kind of but never conceptually lie

00:47:08,200 --> 00:47:11,620
conceptually the developer always lives

00:47:09,940 --> 00:47:13,150
with the model where you know they've

00:47:11,620 --> 00:47:14,410
they've got their change which they've

00:47:13,150 --> 00:47:16,330
applied and they've applied it either

00:47:14,410 --> 00:47:18,460
they've given the given block or they've

00:47:16,330 --> 00:47:21,280
created this runtime which is reactive

00:47:18,460 --> 00:47:23,650
and and they've got that so so so we we

00:47:21,280 --> 00:47:25,270
can do it physically but but never

00:47:23,650 --> 00:47:26,950
logically we would always stick to the

00:47:25,270 --> 00:47:28,300
model because then it's the it's kinda

00:47:26,950 --> 00:47:30,280
like the principle of least surprise for

00:47:28,300 --> 00:47:38,860
the DEM know they just get the model

00:47:30,280 --> 00:47:41,160
they expect okay some more questions for

00:47:38,860 --> 00:47:41,160
you down here

00:47:43,890 --> 00:47:50,440
are you sure that you changed the rate

00:47:47,950 --> 00:47:52,600
and the effects rate and this factor

00:47:50,440 --> 00:47:54,430
caching what happens when you change the

00:47:52,600 --> 00:47:56,680
currency name which is not used in the

00:47:54,430 --> 00:47:58,180
actual computation what is affect the

00:47:56,680 --> 00:47:59,740
cache and does it have anything to do

00:47:58,180 --> 00:48:01,930
with the fact that the rate was marked

00:47:59,740 --> 00:48:05,410
as a note as the only field in the

00:48:01,930 --> 00:48:06,640
entity that I noticed we got that you

00:48:05,410 --> 00:48:09,850
can only change things that are marked

00:48:06,640 --> 00:48:11,370
as such so so because it's only then

00:48:09,850 --> 00:48:13,870
when we have the interception and

00:48:11,370 --> 00:48:17,020
essentially we have different styles of

00:48:13,870 --> 00:48:18,610
cash matching so the most primitive it

00:48:17,020 --> 00:48:21,550
would just be well you changed something

00:48:18,610 --> 00:48:23,500
so therefore everything is invalid but

00:48:21,550 --> 00:48:25,300
we have more sophisticated models where

00:48:23,500 --> 00:48:26,770
we can be like well you change that but

00:48:25,300 --> 00:48:29,740
we know you don't depend on that so

00:48:26,770 --> 00:48:31,810
therefore you know we will not we'll

00:48:29,740 --> 00:48:34,480
just use the cash value so the answer is

00:48:31,810 --> 00:48:36,790
it depends but but we are aware of that

00:48:34,480 --> 00:48:39,220
issue it is configurable so if you know

00:48:36,790 --> 00:48:41,440
that a calculation is expensive and you

00:48:39,220 --> 00:48:43,840
want a cache hit as much as possible you

00:48:41,440 --> 00:48:45,400
can change your configuration so that we

00:48:43,840 --> 00:48:47,290
do that slightly more expensive check

00:48:45,400 --> 00:48:49,330
when we look up to make sure that even

00:48:47,290 --> 00:48:50,710
if some of the tweaks don't match we

00:48:49,330 --> 00:48:55,300
still don't depend on that in our

00:48:50,710 --> 00:48:58,540
calculation so we can get to cache it so

00:48:55,300 --> 00:49:01,420
you have mentioned that your did this to

00:48:58,540 --> 00:49:04,030
gain performance to avoid the drawbacks

00:49:01,420 --> 00:49:10,810
of copying do you have any hard data

00:49:04,030 --> 00:49:14,140
about that it's hard to like rebuild an

00:49:10,810 --> 00:49:17,560
existing system and with like in the FP

00:49:14,140 --> 00:49:19,090
model and in the non FP model and but

00:49:17,560 --> 00:49:21,250
what we have done is where we've

00:49:19,090 --> 00:49:23,320
decommissioned systems which we we have

00:49:21,250 --> 00:49:27,790
is we have done some analysis about how

00:49:23,320 --> 00:49:30,810
much the most that analysis actually

00:49:27,790 --> 00:49:34,750
focused on how much of the code was

00:49:30,810 --> 00:49:36,850
necessary to do the change or like how

00:49:34,750 --> 00:49:39,100
hard it was for the programmer but in

00:49:36,850 --> 00:49:40,870
terms of runtime we have done some

00:49:39,100 --> 00:49:43,090
analysis on that but we've never

00:49:40,870 --> 00:49:45,460
decommissioned an FP system of any like

00:49:43,090 --> 00:49:46,600
significant size so I don't think we

00:49:45,460 --> 00:49:48,790
could I don't think we could

00:49:46,600 --> 00:49:50,890
realistically claim you know it's this

00:49:48,790 --> 00:49:53,440
versus that but I think that you know

00:49:50,890 --> 00:49:55,300
even in the small example

00:49:53,440 --> 00:49:58,240
even if you count the enclosing objects

00:49:55,300 --> 00:50:00,400
because we wear I will wear Big O and

00:49:58,240 --> 00:50:01,840
right but we've we still create two

00:50:00,400 --> 00:50:03,640
enclosing objects we've got the tweak

00:50:01,840 --> 00:50:05,020
sequence on that and the scenario even

00:50:03,640 --> 00:50:07,360
if you count them we still are creating

00:50:05,020 --> 00:50:09,070
less objects to receive the same change

00:50:07,360 --> 00:50:11,320
and the bigger the object graph and the

00:50:09,070 --> 00:50:13,210
more complex it gets the more you're

00:50:11,320 --> 00:50:15,790
gonna gonna save we don't know what the

00:50:13,210 --> 00:50:17,410
number is because reasonably people who

00:50:15,790 --> 00:50:19,120
write in FP as well will change the

00:50:17,410 --> 00:50:20,830
object model so that they get a

00:50:19,120 --> 00:50:22,960
linearization and so that they've

00:50:20,830 --> 00:50:25,800
minimized the amount changes so it's not

00:50:22,960 --> 00:50:28,690
an easy thing to make but I think that

00:50:25,800 --> 00:50:30,400
it would be pretty hard to argue that it

00:50:28,690 --> 00:50:34,480
that we're not saving it's just we just

00:50:30,400 --> 00:50:38,880
don't know by how much precisely any

00:50:34,480 --> 00:50:38,880
more question or one last short question

00:50:39,720 --> 00:50:48,190
can you try disabling the cache and and

00:50:43,420 --> 00:50:50,080
what's your cache hit ratio so I mean

00:50:48,190 --> 00:50:52,840
we've given like a very stylized view

00:50:50,080 --> 00:50:53,800
you can't disable the cache and and then

00:50:52,840 --> 00:50:57,070
stuff runs real slow

00:50:53,800 --> 00:50:58,330
um I mean there is overhead to switching

00:50:57,070 --> 00:51:00,460
on caching so you wouldn't do it to

00:50:58,330 --> 00:51:02,470
multiply together two numbers so there's

00:51:00,460 --> 00:51:04,150
a lot of machinery there but for an

00:51:02,470 --> 00:51:08,200
expensive function yes it would be

00:51:04,150 --> 00:51:10,630
slower but also a cache the cache it

00:51:08,200 --> 00:51:12,190
ratio varies but what we have is we've

00:51:10,630 --> 00:51:14,380
got tools so you can like run the app

00:51:12,190 --> 00:51:16,780
and and see what your cache

00:51:14,380 --> 00:51:18,790
characteristic is and then reconfigure

00:51:16,780 --> 00:51:20,950
the app so that you get the optimal like

00:51:18,790 --> 00:51:24,430
caching behavior for for the app in it

00:51:20,950 --> 00:51:26,050
that you're running okay I think we

00:51:24,430 --> 00:51:29,410
haven't took time to the nice talk then

00:51:26,050 --> 00:51:30,970
maybe you can answer later yeah we'll be

00:51:29,410 --> 00:51:32,860
around if you want to ask us anything

00:51:30,970 --> 00:51:35,110
we're here so just come and fight okay

00:51:32,860 --> 00:51:38,159
thank you again Thanks

00:51:35,110 --> 00:51:38,159

YouTube URL: https://www.youtube.com/watch?v=Svgh3mkHtWA


