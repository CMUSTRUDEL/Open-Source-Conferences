Title: Oh, All the things you'll traverse by Luka Jacobowitz
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6911-oh%2C-all-the-things-you%27ll-traverse.html
Captions: 
	00:00:04,710 --> 00:00:11,139
my talk is called all the things you'll

00:00:07,360 --> 00:00:15,240
traverse and it's not really about

00:00:11,139 --> 00:00:18,130
philosophy maybe a tiny bit but yeah and

00:00:15,240 --> 00:00:21,519
as a quick motivation like a lot of

00:00:18,130 --> 00:00:24,130
people ask me like what is what is the

00:00:21,519 --> 00:00:26,590
cat's library actually do and I want to

00:00:24,130 --> 00:00:29,320
give like a quick overview of what we

00:00:26,590 --> 00:00:32,980
can do and one of my favorite topics for

00:00:29,320 --> 00:00:35,650
for actually like motivating usage of

00:00:32,980 --> 00:00:38,530
something like the cats library is this

00:00:35,650 --> 00:00:40,480
small thing called Traverse and because

00:00:38,530 --> 00:00:43,329
this is like a beginners talk I'll try

00:00:40,480 --> 00:00:47,230
to build it up from the very beginning

00:00:43,329 --> 00:00:50,620
so yeah a very quick about me I work at

00:00:47,230 --> 00:00:52,000
code centric I organize Scala Dusseldorf

00:00:50,620 --> 00:00:55,390
and interest restorff meetups so if

00:00:52,000 --> 00:00:58,090
you're ever in Dusseldorf check it out

00:00:55,390 --> 00:01:01,090
please come by if you want to give a

00:00:58,090 --> 00:01:03,940
talk talk to me and I'm also a

00:01:01,090 --> 00:01:06,430
maintainer of cats cats affect cats MTL

00:01:03,940 --> 00:01:08,680
and out watch and I'm really

00:01:06,430 --> 00:01:10,930
enthusiastic about FP and I want to

00:01:08,680 --> 00:01:14,200
share it with as many people as possible

00:01:10,930 --> 00:01:16,240
and seeing all of you here is it's

00:01:14,200 --> 00:01:19,570
pretty crazy and it's intimidating and

00:01:16,240 --> 00:01:22,840
awesome all at the same time so yes on

00:01:19,570 --> 00:01:25,710
the agenda we have type classes and then

00:01:22,840 --> 00:01:28,689
ma noise and functors and traversals so

00:01:25,710 --> 00:01:31,810
these may sound a bit intimidating but

00:01:28,689 --> 00:01:34,990
I'm gonna try to like explain them from

00:01:31,810 --> 00:01:38,439
the bottom up right so who here has

00:01:34,990 --> 00:01:41,130
heard about type classes that's a lot of

00:01:38,439 --> 00:01:44,049
who has used them like extensively okay

00:01:41,130 --> 00:01:47,770
okay that's that's great so I won't have

00:01:44,049 --> 00:01:50,680
to do that deep and explanation so type

00:01:47,770 --> 00:01:53,560
classes they give us this thing called

00:01:50,680 --> 00:01:56,860
ad hoc polymorphism and it's a different

00:01:53,560 --> 00:01:59,710
kind of fully morphism from what a lot

00:01:56,860 --> 00:02:02,890
of us know as subtype polymorphism using

00:01:59,710 --> 00:02:06,310
inheritance and type classes themselves

00:02:02,890 --> 00:02:08,470
they don't work on on actual values or

00:02:06,310 --> 00:02:10,240
on instances of values of classes for

00:02:08,470 --> 00:02:12,010
example but they work on types

00:02:10,240 --> 00:02:14,670
themselves that's why they're called

00:02:12,010 --> 00:02:17,430
Tech fests right and in

00:02:14,670 --> 00:02:21,240
in theory they're very similar to olp

00:02:17,430 --> 00:02:23,670
interfaces or traits in Scala and as of

00:02:21,240 --> 00:02:26,070
right now there is no language feature

00:02:23,670 --> 00:02:29,460
that allows us to do like type classes

00:02:26,070 --> 00:02:31,890
as a native feature in Scala but that

00:02:29,460 --> 00:02:35,670
actually might change in the future so

00:02:31,890 --> 00:02:37,740
who knows right so I'm gonna just give

00:02:35,670 --> 00:02:39,990
you a very quick example of a type class

00:02:37,740 --> 00:02:42,900
and I'm going to use this library called

00:02:39,990 --> 00:02:46,620
simulacrum which makes it a lot easier

00:02:42,900 --> 00:02:50,190
and it's basically emulating type class

00:02:46,620 --> 00:02:51,810
as a native feature using macro

00:02:50,190 --> 00:02:55,620
annotations right so this little thing

00:02:51,810 --> 00:02:58,140
app type class that basically tells us

00:02:55,620 --> 00:03:00,030
this is like this is this thing is going

00:02:58,140 --> 00:03:03,450
to be a type less and we use type

00:03:00,030 --> 00:03:05,850
classes as traits and you can see the

00:03:03,450 --> 00:03:08,220
similarity again there and this this

00:03:05,850 --> 00:03:10,980
type class is called show and has an

00:03:08,220 --> 00:03:13,530
abstract type T and a single message

00:03:10,980 --> 00:03:15,840
called show and this show just takes the

00:03:13,530 --> 00:03:19,920
value of T and returns a string right so

00:03:15,840 --> 00:03:22,799
basically it's if you have an instance

00:03:19,920 --> 00:03:26,519
of this show type class then it means

00:03:22,799 --> 00:03:29,940
that you can convert a type T to a

00:03:26,519 --> 00:03:32,910
string right so basically this just

00:03:29,940 --> 00:03:36,120
means that we can convert a type T to a

00:03:32,910 --> 00:03:40,290
string and to actually implement this we

00:03:36,120 --> 00:03:42,209
don't we don't like extend a class from

00:03:40,290 --> 00:03:44,820
an interface what we do instead is we

00:03:42,209 --> 00:03:46,920
create a so-called type class instance

00:03:44,820 --> 00:03:50,190
and this looks something like this right

00:03:46,920 --> 00:03:53,790
so in the first example we have here a

00:03:50,190 --> 00:03:57,269
show type class instance for string and

00:03:53,790 --> 00:03:59,940
it's of type show string and we can just

00:03:57,269 --> 00:04:03,239
create it what just in spite just

00:03:59,940 --> 00:04:06,540
instantiating the this show trait for

00:04:03,239 --> 00:04:09,330
the string type and because string

00:04:06,540 --> 00:04:11,700
already is a string the show method just

00:04:09,330 --> 00:04:14,220
gives it right back so it doesn't do a

00:04:11,700 --> 00:04:19,350
lot and then of course we also have show

00:04:14,220 --> 00:04:24,210
integer or show int and because Scala

00:04:19,350 --> 00:04:27,949
212 allows us to to to call single

00:04:24,210 --> 00:04:30,560
abstract method types Sam types

00:04:27,949 --> 00:04:33,660
using a lambda we can just say

00:04:30,560 --> 00:04:35,310
underscore two strings so if we if our

00:04:33,660 --> 00:04:38,250
type class only has a single member we

00:04:35,310 --> 00:04:41,340
can actually implement instances really

00:04:38,250 --> 00:04:42,690
quickly so this this is just how it

00:04:41,340 --> 00:04:45,660
works and then if we actually want to

00:04:42,690 --> 00:04:47,250
use it like so we can create something

00:04:45,660 --> 00:04:51,509
like this

00:04:47,250 --> 00:04:54,419
so this empty of false method takes an

00:04:51,509 --> 00:04:56,250
abstract type T and constraints it using

00:04:54,419 --> 00:04:59,460
something called a context bound right

00:04:56,250 --> 00:05:01,320
so this double : show basically means

00:04:59,460 --> 00:05:04,590
that if you want to call this empty of

00:05:01,320 --> 00:05:08,789
false method make sure that the T you're

00:05:04,590 --> 00:05:11,789
giving it has to have an instance right

00:05:08,789 --> 00:05:13,770
of off show in scope right and that's

00:05:11,789 --> 00:05:17,070
what we do above by creating this

00:05:13,770 --> 00:05:19,620
implicit value we create an a type class

00:05:17,070 --> 00:05:21,449
instance for show so after we define

00:05:19,620 --> 00:05:23,699
this instance for show string and show

00:05:21,449 --> 00:05:29,360
integer we could now call this empty of

00:05:23,699 --> 00:05:33,139
false method with with with integer and

00:05:29,360 --> 00:05:35,639
string as our type T and if we were try

00:05:33,139 --> 00:05:37,800
to try this with any other thing it

00:05:35,639 --> 00:05:40,889
would complain that hey you don't have a

00:05:37,800 --> 00:05:42,810
type last instance for your type T right

00:05:40,889 --> 00:05:46,289
and this function doesn't do anything

00:05:42,810 --> 00:05:50,400
crazy it just checks if if this

00:05:46,289 --> 00:05:53,820
predicate function f is as 2 and then it

00:05:50,400 --> 00:05:55,830
will either return the string it would

00:05:53,820 --> 00:05:58,440
that that's that's called by using this

00:05:55,830 --> 00:06:00,030
show method or else it will just return

00:05:58,440 --> 00:06:02,070
an empty string all right so this is a

00:06:00,030 --> 00:06:04,800
very very basic example that doesn't

00:06:02,070 --> 00:06:07,139
really do anything useful so let's look

00:06:04,800 --> 00:06:09,750
at something a bit more useful and I I

00:06:07,139 --> 00:06:12,479
promised Mon arts and this is the mono

00:06:09,750 --> 00:06:15,330
type class and it is really really cool

00:06:12,479 --> 00:06:17,490
but it looks a bit it doesn't look like

00:06:15,330 --> 00:06:20,460
much right so we have this thing called

00:06:17,490 --> 00:06:23,099
the empty method which will return some

00:06:20,460 --> 00:06:25,560
type T and we also have a combined

00:06:23,099 --> 00:06:30,210
method that takes two T's and returns a

00:06:25,560 --> 00:06:33,060
new T right so for example if we were to

00:06:30,210 --> 00:06:34,199
create an integer instance for model it

00:06:33,060 --> 00:06:37,320
would look something like this

00:06:34,199 --> 00:06:40,050
so actually integer has multiple modern

00:06:37,320 --> 00:06:41,970
instances but this is the addition

00:06:40,050 --> 00:06:46,110
instance right so we have empty

00:06:41,970 --> 00:06:49,320
which is zero right and to combine two

00:06:46,110 --> 00:06:53,190
mono Ed's we can add them and this is

00:06:49,320 --> 00:06:57,450
this is pretty useful for a reason I'm

00:06:53,190 --> 00:07:00,510
about to show you so let's say we want

00:06:57,450 --> 00:07:03,600
to like some a list of integers right so

00:07:00,510 --> 00:07:06,210
what we usually do if like as functional

00:07:03,600 --> 00:07:08,430
programmers we don't use like a while

00:07:06,210 --> 00:07:10,170
loop or something but we use this fold

00:07:08,430 --> 00:07:14,070
function right or reduce in other

00:07:10,170 --> 00:07:16,290
languages and it takes a seed so the

00:07:14,070 --> 00:07:19,470
seed usually when you want to sum a list

00:07:16,290 --> 00:07:22,050
of integers is zero and then we'll just

00:07:19,470 --> 00:07:23,850
add all of the integers right and we

00:07:22,050 --> 00:07:28,170
need the seed because the list might be

00:07:23,850 --> 00:07:31,200
empty and if it's empty then we'll have

00:07:28,170 --> 00:07:32,430
to return something right so otherwise

00:07:31,200 --> 00:07:35,580
it would have to throw an exception

00:07:32,430 --> 00:07:38,190
because what can you return right so

00:07:35,580 --> 00:07:39,840
this is some on a list of integers but

00:07:38,190 --> 00:07:41,940
we can do the same for a list of strings

00:07:39,840 --> 00:07:45,180
with an empty string and string

00:07:41,940 --> 00:07:47,400
concatenation right and we could also do

00:07:45,180 --> 00:07:51,750
the same thing with a list of sets and

00:07:47,400 --> 00:07:54,900
then having an empty set and using set

00:07:51,750 --> 00:07:57,210
Union right so and maybe you've seen a

00:07:54,900 --> 00:07:59,340
pattern here right so we have this in

00:07:57,210 --> 00:08:02,160
the full left we usually use like an

00:07:59,340 --> 00:08:04,140
empty thing as the first parameter and

00:08:02,160 --> 00:08:07,560
then as a second parameter we want to

00:08:04,140 --> 00:08:10,560
combine two things right and if you can

00:08:07,560 --> 00:08:13,380
add one and one together you get this

00:08:10,560 --> 00:08:17,610
which is the sum function that actually

00:08:13,380 --> 00:08:20,550
takes a mono and this works on any mono

00:08:17,610 --> 00:08:23,250
it's actually like strings integers and

00:08:20,550 --> 00:08:26,070
sets are all instances of mono it's they

00:08:23,250 --> 00:08:27,810
all have mono instances and they're all

00:08:26,070 --> 00:08:30,000
defined in the Katz library so if you're

00:08:27,810 --> 00:08:33,030
using that you can totally use this last

00:08:30,000 --> 00:08:36,419
function and just it will just work and

00:08:33,030 --> 00:08:38,250
it uses this mono T dot empty for the

00:08:36,419 --> 00:08:41,729
seed and then it uses the combined

00:08:38,250 --> 00:08:44,250
function we saw before to combine the

00:08:41,729 --> 00:08:46,470
individual elements of the list and this

00:08:44,250 --> 00:08:49,620
might look a bit weird because like what

00:08:46,470 --> 00:08:52,200
is what is this right so what I T that

00:08:49,620 --> 00:08:55,790
empty and this is actually one of the

00:08:52,200 --> 00:09:01,260
features of type classes is that because

00:08:55,790 --> 00:09:03,390
type glasses don't don't don't because

00:09:01,260 --> 00:09:06,030
they they operate on the valve are not

00:09:03,390 --> 00:09:08,310
on the value but on the type itself we

00:09:06,030 --> 00:09:11,580
can actually associate an empty value to

00:09:08,310 --> 00:09:14,610
a type right so for example my night for

00:09:11,580 --> 00:09:17,060
in temp t is zero and monitor for a

00:09:14,610 --> 00:09:19,710
string that empty is the empty string so

00:09:17,060 --> 00:09:22,140
because we don't operate like on a class

00:09:19,710 --> 00:09:26,880
or whatever we operate on the type we

00:09:22,140 --> 00:09:29,040
can call these things for for for for

00:09:26,880 --> 00:09:31,140
this some function and this this works

00:09:29,040 --> 00:09:33,900
this is one of the features of type

00:09:31,140 --> 00:09:37,740
classes that's all pretty cool and yeah

00:09:33,900 --> 00:09:40,020
so another really really cool feature of

00:09:37,740 --> 00:09:43,080
type classes is that we can do something

00:09:40,020 --> 00:09:46,670
called implicit derivation which is not

00:09:43,080 --> 00:09:48,600
the same as type class derivation but

00:09:46,670 --> 00:09:50,700
finding names with these things is

00:09:48,600 --> 00:09:52,620
difficult so what we can do for example

00:09:50,700 --> 00:09:56,700
if we wanted to create a monolid for

00:09:52,620 --> 00:09:58,470
option you would have to like the the

00:09:56,700 --> 00:10:00,750
empty case is easy right so you can just

00:09:58,470 --> 00:10:03,510
use none but if you have an option of

00:10:00,750 --> 00:10:05,220
integers we could use plus but we we

00:10:03,510 --> 00:10:08,430
want to define Mahanoy

00:10:05,220 --> 00:10:11,550
that works for any t right so for an

00:10:08,430 --> 00:10:14,400
option of any t like we see up there and

00:10:11,550 --> 00:10:17,850
what we need to do is actually say that

00:10:14,400 --> 00:10:19,530
how can we combine any t's and we

00:10:17,850 --> 00:10:21,920
already have this mono type class so

00:10:19,530 --> 00:10:25,410
what we can do is we can basically

00:10:21,920 --> 00:10:28,230
induce this implicit right so what we

00:10:25,410 --> 00:10:32,310
can say is that I have a I can give you

00:10:28,230 --> 00:10:35,640
am honored for option of T if I also

00:10:32,310 --> 00:10:38,280
have a mono it for T right so that makes

00:10:35,640 --> 00:10:40,290
absolutely sin that makes really a lot

00:10:38,280 --> 00:10:42,810
of sense and then combined is just like

00:10:40,290 --> 00:10:46,020
if if both are true then combine them

00:10:42,810 --> 00:10:48,630
and then you then you get this combined

00:10:46,020 --> 00:10:51,510
option value right that should make

00:10:48,630 --> 00:10:53,420
sense but this is a feature that you

00:10:51,510 --> 00:10:56,370
really can't do when you use like

00:10:53,420 --> 00:10:57,930
standard Opie interface and this is what

00:10:56,370 --> 00:11:00,600
makes type classes really really

00:10:57,930 --> 00:11:02,120
powerful so I mean you all know type of

00:11:00,600 --> 00:11:06,150
so this shouldn't be news to you but

00:11:02,120 --> 00:11:08,730
yeah okay so very quick type classes

00:11:06,150 --> 00:11:09,250
versus subtyping yeah type classes give

00:11:08,730 --> 00:11:11,379
us a break

00:11:09,250 --> 00:11:13,420
son types instead of on values I said

00:11:11,379 --> 00:11:15,550
that a lot and this comes in handy

00:11:13,420 --> 00:11:17,560
because type classes like Menards need

00:11:15,550 --> 00:11:19,959
to have like this empty method that

00:11:17,560 --> 00:11:21,610
works on a type and we wouldn't want to

00:11:19,959 --> 00:11:25,149
define it for every instance because it

00:11:21,610 --> 00:11:27,399
doesn't make any sense and last part we

00:11:25,149 --> 00:11:29,920
can use these type classes to derive

00:11:27,399 --> 00:11:32,319
instances for data types that might hold

00:11:29,920 --> 00:11:34,930
other data types when they also have

00:11:32,319 --> 00:11:37,300
instances right so option of T is a

00:11:34,930 --> 00:11:39,970
monoid when T is also am all right so we

00:11:37,300 --> 00:11:42,360
can build up these trees and we can and

00:11:39,970 --> 00:11:46,360
cats there's actually like a lot of

00:11:42,360 --> 00:11:49,750
implicit in induction wait we can do so

00:11:46,360 --> 00:11:52,389
yes so and actually monarchs are really

00:11:49,750 --> 00:11:54,459
cool because they're everywhere right so

00:11:52,389 --> 00:11:57,329
this is the function mano right right

00:11:54,459 --> 00:12:01,060
and it gives us a more annoyed whenever

00:11:57,329 --> 00:12:06,879
a function return type is also a Monod

00:12:01,060 --> 00:12:08,709
right so the empty is just a constant

00:12:06,879 --> 00:12:12,040
function that goes from anything to the

00:12:08,709 --> 00:12:14,769
empty value of the Monod and to combine

00:12:12,040 --> 00:12:18,939
two functions we just run run them all

00:12:14,769 --> 00:12:22,000
both and then combine their combined

00:12:18,939 --> 00:12:25,089
their results so that's pretty simple

00:12:22,000 --> 00:12:27,519
but now we have a mano it for a a to be

00:12:25,089 --> 00:12:30,759
and we can use that for any A to B or

00:12:27,519 --> 00:12:32,800
any A to B where B is the monoi and we

00:12:30,759 --> 00:12:34,720
can also do this for tuples right so if

00:12:32,800 --> 00:12:36,910
a and B are tuples it's pretty easy to

00:12:34,720 --> 00:12:40,029
imagine how we can combine two tuples

00:12:36,910 --> 00:12:41,620
when both of them are able to be

00:12:40,029 --> 00:12:44,980
combined and we can of course also

00:12:41,620 --> 00:12:49,540
create this empty because we have empty

00:12:44,980 --> 00:12:52,149
values for both right and what else is a

00:12:49,540 --> 00:12:55,899
mono we have this either monoid we have

00:12:52,149 --> 00:12:57,819
a map mono ed right so if if we have two

00:12:55,899 --> 00:12:59,860
maps we can combine them if they have

00:12:57,819 --> 00:13:03,069
the same key then we can combine the

00:12:59,860 --> 00:13:04,839
values of those keys and future is also

00:13:03,069 --> 00:13:07,269
home alright so if you have two futures

00:13:04,839 --> 00:13:09,339
we can combine them so there they will

00:13:07,269 --> 00:13:12,790
both be run and when they're done we can

00:13:09,339 --> 00:13:15,009
combine the resulting values and there's

00:13:12,790 --> 00:13:18,850
many more that I couldn't possibly list

00:13:15,009 --> 00:13:21,939
because it's too many right and why is

00:13:18,850 --> 00:13:23,140
this useful so I'm gonna give you a very

00:13:21,939 --> 00:13:26,800
small example

00:13:23,140 --> 00:13:29,709
dad that was very inspired from my

00:13:26,800 --> 00:13:35,350
colleague Marcus so basically what we

00:13:29,709 --> 00:13:37,330
have is we want to define like a small

00:13:35,350 --> 00:13:39,430
application that reads a text file and

00:13:37,330 --> 00:13:41,769
gives us back like some statistics right

00:13:39,430 --> 00:13:45,310
so we define the step function and we

00:13:41,769 --> 00:13:49,000
have like a data value that basically

00:13:45,310 --> 00:13:50,890
just reads in our lines like text data's

00:13:49,000 --> 00:13:54,160
lines and then splits them all up into

00:13:50,890 --> 00:13:58,149
words and then maps them to this thing

00:13:54,160 --> 00:14:00,700
which is a tuple of two integers and a

00:13:58,149 --> 00:14:05,230
map of string to integer right and they

00:14:00,700 --> 00:14:07,720
will represent the number of characters

00:14:05,230 --> 00:14:12,130
the number of words and also the

00:14:07,720 --> 00:14:14,589
occurrence of each word right so if we

00:14:12,130 --> 00:14:17,470
if we apply the step function to a word

00:14:14,589 --> 00:14:20,709
we will get a tuple of 1 and then of the

00:14:17,470 --> 00:14:24,130
word length and then a map of word to 1

00:14:20,709 --> 00:14:27,459
and then if we combine tuples of these

00:14:24,130 --> 00:14:31,930
values for example we have like hello

00:14:27,459 --> 00:14:35,140
and world the combining tuple will give

00:14:31,930 --> 00:14:38,110
us the number of words which is 1 plus 1

00:14:35,140 --> 00:14:41,320
is 2 the combined characters which is

00:14:38,110 --> 00:14:43,779
hello length plus world length and then

00:14:41,320 --> 00:14:45,490
a map of hello to 1 and well 2 1 right

00:14:43,779 --> 00:14:49,540
and if we apply this to all of the

00:14:45,490 --> 00:14:52,630
worlds and our text words now text we

00:14:49,540 --> 00:14:55,540
actually get the full words word count

00:14:52,630 --> 00:14:57,880
the char count and occurrence of each

00:14:55,540 --> 00:15:00,670
word right and this is pretty easy we

00:14:57,880 --> 00:15:02,860
need to do like this mono dot empty and

00:15:00,670 --> 00:15:06,520
we need to add this really big type and

00:15:02,860 --> 00:15:09,329
also I kind of cheated and I added a

00:15:06,520 --> 00:15:12,220
symbolic operator for combined so this

00:15:09,329 --> 00:15:14,560
plus thing with tie-fighter looking

00:15:12,220 --> 00:15:17,980
whatever that is actually just an alias

00:15:14,560 --> 00:15:20,350
for the combine for for well just giving

00:15:17,980 --> 00:15:22,720
it a symbolic operator and well this is

00:15:20,350 --> 00:15:25,870
cool but it's also not not that great

00:15:22,720 --> 00:15:28,269
because we need to like define this

00:15:25,870 --> 00:15:29,740
Mahanoy to empty thing manually so I

00:15:28,269 --> 00:15:31,959
don't know maybe you can do better and

00:15:29,740 --> 00:15:35,140
actually we can do a lot better we can

00:15:31,959 --> 00:15:37,390
just shortcut this into this and combine

00:15:35,140 --> 00:15:39,760
all is just an alias for

00:15:37,390 --> 00:15:45,520
doing exactly that so if we know that

00:15:39,760 --> 00:15:47,530
our data is has is a list of a type M

00:15:45,520 --> 00:15:49,480
which has a monolid we can call this

00:15:47,530 --> 00:15:51,640
function called combined all which is

00:15:49,480 --> 00:15:53,950
provided by cats and it will be exactly

00:15:51,640 --> 00:15:56,410
equivalent to folding over it with the

00:15:53,950 --> 00:15:58,780
empty type and then applying this

00:15:56,410 --> 00:16:01,240
combination operator this monoidal

00:15:58,780 --> 00:16:03,550
combination operator yeah and I think

00:16:01,240 --> 00:16:05,170
that is a very succinct pretty cool

00:16:03,550 --> 00:16:09,100
thing you can do with moloids and that's

00:16:05,170 --> 00:16:11,860
just scratching the edge right and of

00:16:09,100 --> 00:16:13,660
course there's no mono I talked without

00:16:11,860 --> 00:16:15,760
talking about laws laws are very

00:16:13,660 --> 00:16:18,850
important one weight is actually a

00:16:15,760 --> 00:16:21,840
mathematical term and if you just define

00:16:18,850 --> 00:16:24,730
anything as a mod I'd it has to actually

00:16:21,840 --> 00:16:26,260
it also has to be a lawful Monod and

00:16:24,730 --> 00:16:29,260
these are the laws we have this

00:16:26,260 --> 00:16:33,760
associativity which I personally learned

00:16:29,260 --> 00:16:35,800
in like sixth grade and there was like

00:16:33,760 --> 00:16:37,960
why why is this ever useful and now it's

00:16:35,800 --> 00:16:39,580
like oh my god associativity is the most

00:16:37,960 --> 00:16:40,210
useful thing ever so this is pretty

00:16:39,580 --> 00:16:44,860
funny actually

00:16:40,210 --> 00:16:47,140
but yeah so it basically means that the

00:16:44,860 --> 00:16:51,250
combining order doesn't really matter so

00:16:47,140 --> 00:16:54,100
X plus y and then plus Z has to be the

00:16:51,250 --> 00:16:56,650
same as X and then first combining y&z

00:16:54,100 --> 00:16:59,140
right so this is just a social utility

00:16:56,650 --> 00:17:02,200
it's fairly simple but it helps us a lot

00:16:59,140 --> 00:17:05,680
which we'll see later then we also have

00:17:02,200 --> 00:17:08,589
right identity right and this just means

00:17:05,680 --> 00:17:10,209
combining something with its empty value

00:17:08,589 --> 00:17:13,600
will still be the same right so

00:17:10,209 --> 00:17:14,949
combining a string with the empty string

00:17:13,600 --> 00:17:17,560
is still gonna be that string or

00:17:14,949 --> 00:17:20,140
combining a number with zero is still

00:17:17,560 --> 00:17:22,000
gonna be that number right and the same

00:17:20,140 --> 00:17:25,240
goes for left identity so it doesn't

00:17:22,000 --> 00:17:29,050
matter um I saw the identity has commute

00:17:25,240 --> 00:17:30,850
there okay so why do we need this it's

00:17:29,050 --> 00:17:32,410
actually really useful because it allows

00:17:30,850 --> 00:17:34,990
us to to give us a lot of

00:17:32,410 --> 00:17:36,970
transformations that are really really

00:17:34,990 --> 00:17:39,700
cool so for example if we have this

00:17:36,970 --> 00:17:43,870
right so this is a list of six types

00:17:39,700 --> 00:17:46,330
which are all combining and on because

00:17:43,870 --> 00:17:48,850
of our modern laws we can do something

00:17:46,330 --> 00:17:50,720
like this right so we can actually group

00:17:48,850 --> 00:17:55,159
them in certain places

00:17:50,720 --> 00:17:59,539
and this is cool because as we'll see

00:17:55,159 --> 00:18:01,429
later we can also group them by by by a

00:17:59,539 --> 00:18:06,380
constant number right so now we have

00:18:01,429 --> 00:18:09,500
four groups that we can all do that we

00:18:06,380 --> 00:18:11,929
can all compute individually and more

00:18:09,500 --> 00:18:13,640
importantly independently right so at

00:18:11,929 --> 00:18:16,130
the top you would say okay I can only do

00:18:13,640 --> 00:18:19,520
this sequentially but if because we have

00:18:16,130 --> 00:18:23,179
a sociate if 'ti these now we have four

00:18:19,520 --> 00:18:25,309
completely independent computations that

00:18:23,179 --> 00:18:28,220
we could potentially run in parallel

00:18:25,309 --> 00:18:30,770
right so we can write a fully parallel

00:18:28,220 --> 00:18:32,179
version of something like fold and that

00:18:30,770 --> 00:18:34,909
actually makes this really really

00:18:32,179 --> 00:18:36,919
powerful and I've got a quick example

00:18:34,909 --> 00:18:39,620
how something like that would look it's

00:18:36,919 --> 00:18:41,539
not like doesn't work fully just like

00:18:39,620 --> 00:18:44,179
this but for example if we have a list

00:18:41,539 --> 00:18:47,080
of some a which has a more annoyed then

00:18:44,179 --> 00:18:50,419
we can basically group it into groups of

00:18:47,080 --> 00:18:53,150
are available processors so if you have

00:18:50,419 --> 00:18:54,799
like eight cores in our computer you

00:18:53,150 --> 00:18:57,320
could have a list with Boop's of eight

00:18:54,799 --> 00:18:59,510
and then what we can do is we can map

00:18:57,320 --> 00:19:01,460
those in parallel and then combine those

00:18:59,510 --> 00:19:04,280
inner groups to get back a list of A's

00:19:01,460 --> 00:19:05,809
which are the combined groups so now we

00:19:04,280 --> 00:19:10,520
should have a list of eight elements

00:19:05,809 --> 00:19:12,140
with the individual values and then we

00:19:10,520 --> 00:19:14,360
can just call combine all to get the

00:19:12,140 --> 00:19:17,030
final result and we will have actually

00:19:14,360 --> 00:19:18,980
completely paralyzed our fold and that

00:19:17,030 --> 00:19:20,750
is what I think is really really cool

00:19:18,980 --> 00:19:23,860
and this is what ma nodes give you

00:19:20,750 --> 00:19:28,190
because of associativity and identity

00:19:23,860 --> 00:19:29,690
right so let's talk about functors who

00:19:28,190 --> 00:19:32,750
here has heard about functors or who

00:19:29,690 --> 00:19:35,720
knows functors that's a lot of people

00:19:32,750 --> 00:19:38,150
you guys are great cool so type class is

00:19:35,720 --> 00:19:41,090
type functor is in another type class

00:19:38,150 --> 00:19:43,940
and instead of taking a normal normal

00:19:41,090 --> 00:19:47,690
value of type T it takes a what we call

00:19:43,940 --> 00:19:51,919
a higher kind of type as a parameter and

00:19:47,690 --> 00:19:54,289
this is represented as this F open

00:19:51,919 --> 00:19:57,650
bracket underscore open bracket close

00:19:54,289 --> 00:20:01,010
bracket right and what this means is

00:19:57,650 --> 00:20:03,320
that in order to become a fully applied

00:20:01,010 --> 00:20:04,429
type we actually need to give it a type

00:20:03,320 --> 00:20:07,249
right so

00:20:04,429 --> 00:20:10,279
F itself is not like a type we can use

00:20:07,249 --> 00:20:11,929
but we can we have to give it a type to

00:20:10,279 --> 00:20:14,539
become a type we also call these type

00:20:11,929 --> 00:20:17,720
constructors right an example of this is

00:20:14,539 --> 00:20:20,179
for something like list right so list

00:20:17,720 --> 00:20:22,240
itself you can give this a value of list

00:20:20,179 --> 00:20:24,590
you have to give us a value of list of

00:20:22,240 --> 00:20:27,499
something like list of integer list of

00:20:24,590 --> 00:20:30,610
string right and so this is the same

00:20:27,499 --> 00:20:35,029
thing just in an abstract form and so

00:20:30,610 --> 00:20:37,999
this functor there's functor type class

00:20:35,029 --> 00:20:39,980
basically abstracts over the map

00:20:37,999 --> 00:20:41,690
function and I think most of you here

00:20:39,980 --> 00:20:45,230
have used map

00:20:41,690 --> 00:20:47,299
I really assume so and it basically

00:20:45,230 --> 00:20:50,240
allows us to give us a value of some

00:20:47,299 --> 00:20:53,690
type F of a and a function of A to B and

00:20:50,240 --> 00:20:55,610
then we will get an F of B and examples

00:20:53,690 --> 00:20:58,789
for this of course our list option

00:20:55,610 --> 00:21:01,249
either vector or future and there's many

00:20:58,789 --> 00:21:03,799
many more almost all very very many

00:21:01,249 --> 00:21:05,869
things or future and yeah this are just

00:21:03,799 --> 00:21:08,179
some example I think most of you this

00:21:05,869 --> 00:21:10,549
makes a lot of sense so let's talk about

00:21:08,179 --> 00:21:12,830
something called monoidal functors so

00:21:10,549 --> 00:21:17,720
monoidal functor is basically combine

00:21:12,830 --> 00:21:20,899
the the the parameters of moloids with

00:21:17,720 --> 00:21:23,240
the parameters of functors and so for

00:21:20,899 --> 00:21:25,309
example right this is a mono right so we

00:21:23,240 --> 00:21:28,220
have an a and an a we combine them to

00:21:25,309 --> 00:21:31,070
get a new way but you might also have

00:21:28,220 --> 00:21:34,669
like an F of a right like we saw with

00:21:31,070 --> 00:21:37,399
the option option of a combined with

00:21:34,669 --> 00:21:39,289
option of a is also an option of a using

00:21:37,399 --> 00:21:41,929
simple Mahanoy but what if we have

00:21:39,289 --> 00:21:45,049
something like this right we have this

00:21:41,929 --> 00:21:46,879
we have this F of a and F of B and now

00:21:45,049 --> 00:21:48,730
we want to combine them for example an

00:21:46,879 --> 00:21:52,210
option of int and an option of string

00:21:48,730 --> 00:21:56,450
but where would that return type B and

00:21:52,210 --> 00:21:58,820
we we can't use normal monoid combined

00:21:56,450 --> 00:22:01,490
because it expects the types to be the

00:21:58,820 --> 00:22:04,070
same so we need something different here

00:22:01,490 --> 00:22:07,249
and I use this weird operator thing so

00:22:04,070 --> 00:22:10,539
does anyone know what what could be the

00:22:07,249 --> 00:22:10,539
type the result of this

00:22:13,809 --> 00:22:19,280
either it could be either but I'm

00:22:16,940 --> 00:22:22,490
actually going to talk about tube all

00:22:19,280 --> 00:22:24,460
right so it might it would probably have

00:22:22,490 --> 00:22:27,080
both right so if you have an option of a

00:22:24,460 --> 00:22:29,000
and an option of B and you combine them

00:22:27,080 --> 00:22:32,419
you could get like an option of both

00:22:29,000 --> 00:22:35,960
right that's the most common operation I

00:22:32,419 --> 00:22:38,679
think and yeah and this is essentially

00:22:35,960 --> 00:22:41,419
what monoidal functors can give you and

00:22:38,679 --> 00:22:44,450
we'll see right here so this is the

00:22:41,419 --> 00:22:47,000
malarial type class it extends functor

00:22:44,450 --> 00:22:50,330
and it adds these two methods and it

00:22:47,000 --> 00:22:52,460
takes one is the product which just

00:22:50,330 --> 00:22:55,010
looks a bit like combined but as I said

00:22:52,460 --> 00:22:57,679
it has this tuple thing going on and it

00:22:55,010 --> 00:23:00,409
allows us to create to combine two type

00:22:57,679 --> 00:23:02,179
constructors into a new type constructor

00:23:00,409 --> 00:23:04,010
that it will take the values inside

00:23:02,179 --> 00:23:06,679
those type constructor and combine them

00:23:04,010 --> 00:23:08,870
inside of a tuple and it also has this

00:23:06,679 --> 00:23:12,440
pure method which is very similar to the

00:23:08,870 --> 00:23:14,900
monoi to empty method in that it just

00:23:12,440 --> 00:23:18,260
lifts a value into this context and it

00:23:14,900 --> 00:23:20,090
doesn't actually take a value of inside

00:23:18,260 --> 00:23:23,110
our F context inside our F type

00:23:20,090 --> 00:23:25,280
constructor and examples for this are

00:23:23,110 --> 00:23:28,610
like it worked we talked about the

00:23:25,280 --> 00:23:32,659
option memorial and of course we also

00:23:28,610 --> 00:23:34,760
have something like future and yeah so

00:23:32,659 --> 00:23:37,870
what we can what can we do with this so

00:23:34,760 --> 00:23:40,490
who here has used future dot sequence

00:23:37,870 --> 00:23:42,679
man you guys raise a lot of hands it's

00:23:40,490 --> 00:23:44,510
great okay cool and future dot sequence

00:23:42,679 --> 00:23:46,429
is a really really useful function

00:23:44,510 --> 00:23:48,380
basically what it does is if you give it

00:23:46,429 --> 00:23:50,720
a list of future it will run all of them

00:23:48,380 --> 00:23:54,110
in parallel and return you a future of

00:23:50,720 --> 00:23:54,650
all the read all the results and that's

00:23:54,110 --> 00:23:57,320
pretty cool

00:23:54,650 --> 00:24:01,640
so what can we do maybe we can

00:23:57,320 --> 00:24:04,429
generalize this so here we have this the

00:24:01,640 --> 00:24:06,080
same function again it takes a list of

00:24:04,429 --> 00:24:10,250
future of a and returns a future of list

00:24:06,080 --> 00:24:12,470
of a but let's try to abstract out this

00:24:10,250 --> 00:24:16,730
future and try to put in something else

00:24:12,470 --> 00:24:18,799
and what I did here is exactly that we

00:24:16,730 --> 00:24:20,780
took instead of returning a instead of

00:24:18,799 --> 00:24:23,630
taking a list of future of a we take a

00:24:20,780 --> 00:24:25,270
list of F of a and instead of returning

00:24:23,630 --> 00:24:28,090
a future of list of a

00:24:25,270 --> 00:24:32,500
we return an F of list of eight and this

00:24:28,090 --> 00:24:38,320
is the most simple implementation we

00:24:32,500 --> 00:24:43,780
basically fold over the list we lift

00:24:38,320 --> 00:24:47,620
lift an empty list into our monoidal F

00:24:43,780 --> 00:24:50,920
right and then that is the seed and then

00:24:47,620 --> 00:24:54,700
to combine these we actually call this

00:24:50,920 --> 00:24:57,640
product method and then what we get back

00:24:54,700 --> 00:25:00,250
is an F of tuple of a and list a and

00:24:57,640 --> 00:25:03,280
then because we also have map we can

00:25:00,250 --> 00:25:06,720
just turn that into an F of list of a by

00:25:03,280 --> 00:25:09,190
calling by calling map and then

00:25:06,720 --> 00:25:12,070
combining the a with the list of a and

00:25:09,190 --> 00:25:13,810
then we get back an F of list of a which

00:25:12,070 --> 00:25:17,080
is also our result type and this

00:25:13,810 --> 00:25:20,500
basically gives us a way to combine all

00:25:17,080 --> 00:25:24,250
of the all of the F of a's which are in

00:25:20,500 --> 00:25:27,250
our original list and give us back in F

00:25:24,250 --> 00:25:30,940
of list of a so basically it's able to

00:25:27,250 --> 00:25:35,380
turn this this list of F of a inside out

00:25:30,940 --> 00:25:37,690
and that is pretty cool and if you if

00:25:35,380 --> 00:25:40,080
you saw the the Monroy sum function a

00:25:37,690 --> 00:25:43,600
bit earlier it actually looks pretty

00:25:40,080 --> 00:25:46,270
similar like this so the smaller

00:25:43,600 --> 00:25:49,810
monoidal effed-up yer is basically like

00:25:46,270 --> 00:25:53,800
I said it's the higher kind it functor

00:25:49,810 --> 00:25:56,530
version of Mahanoy empty and this

00:25:53,800 --> 00:25:59,650
product function is basically like the

00:25:56,530 --> 00:26:01,690
combined function that ma nodes have so

00:25:59,650 --> 00:26:04,690
this is like the the functor version of

00:26:01,690 --> 00:26:08,500
of the monoidal sum function or combine

00:26:04,690 --> 00:26:10,570
all function right and there's actually

00:26:08,500 --> 00:26:13,210
some syntactic sugar so we don't have to

00:26:10,570 --> 00:26:16,000
do this product and map so we can

00:26:13,210 --> 00:26:18,790
actually do it in one step using cats

00:26:16,000 --> 00:26:22,930
and it just takes like we can just have

00:26:18,790 --> 00:26:25,650
a tuple of our two types and then call

00:26:22,930 --> 00:26:28,120
this map n which is equivalent to

00:26:25,650 --> 00:26:29,350
product and then map right so this is

00:26:28,120 --> 00:26:32,410
just syntactic sugar and I think it

00:26:29,350 --> 00:26:34,740
looks a lot nicer that way yeah so this

00:26:32,410 --> 00:26:37,270
is future that sequence but there's also

00:26:34,740 --> 00:26:38,540
future sugar Traverse and we can do the

00:26:37,270 --> 00:26:41,540
same thing here

00:26:38,540 --> 00:26:44,210
so we have Traverse which takes a list

00:26:41,540 --> 00:26:46,520
of a and then a function from A to

00:26:44,210 --> 00:26:49,100
future of B and returns a future of list

00:26:46,520 --> 00:26:50,600
of the and actually the implementation

00:26:49,100 --> 00:26:51,140
to generalize this is really really

00:26:50,600 --> 00:26:53,770
similar

00:26:51,140 --> 00:26:56,690
we just need to apply this F function

00:26:53,770 --> 00:27:00,560
before actually calling this map end

00:26:56,690 --> 00:27:03,260
function so what we do right here is if

00:27:00,560 --> 00:27:05,510
you look at the this and then this I

00:27:03,260 --> 00:27:08,000
can't show it side by side really well

00:27:05,510 --> 00:27:10,670
should have thought about that but yeah

00:27:08,000 --> 00:27:13,640
instead of getting an F of a as our

00:27:10,670 --> 00:27:16,160
first parameter inside the fold we get

00:27:13,640 --> 00:27:18,350
an A and to lift it to an F of a or an F

00:27:16,160 --> 00:27:20,840
of B in this case we just call this F

00:27:18,350 --> 00:27:23,180
function all right so this is really

00:27:20,840 --> 00:27:25,220
similar and actually Traverse is

00:27:23,180 --> 00:27:27,230
basically like a shortcut or a more

00:27:25,220 --> 00:27:29,270
efficient version of calling map and

00:27:27,230 --> 00:27:32,180
then sequence right so if whenever you

00:27:29,270 --> 00:27:33,860
see a map and then sequence in your code

00:27:32,180 --> 00:27:38,780
just inline it to traverse it will be

00:27:33,860 --> 00:27:42,110
faster and cooler okay so and another

00:27:38,780 --> 00:27:44,390
cool thing is that the laws for for

00:27:42,110 --> 00:27:45,740
monoidal are actually the same as the

00:27:44,390 --> 00:27:49,310
laws from one oeid so we have

00:27:45,740 --> 00:27:51,530
associativity so if you first call the

00:27:49,310 --> 00:27:56,030
product function on FA and FB and then

00:27:51,530 --> 00:27:59,960
on FC it should be isomorphic to FA and

00:27:56,030 --> 00:28:02,840
the first first using product and FB NFC

00:27:59,960 --> 00:28:05,840
and then calling product and FA and the

00:28:02,840 --> 00:28:08,030
product of F B and C right and the same

00:28:05,840 --> 00:28:10,430
is true with the right at any and left

00:28:08,030 --> 00:28:15,560
left identity so if we call this pure

00:28:10,430 --> 00:28:18,320
function and and then use product it

00:28:15,560 --> 00:28:22,010
will have to be isomorphic it can't have

00:28:18,320 --> 00:28:25,430
any effects on the on the actual value

00:28:22,010 --> 00:28:28,550
right so this is another similarity to

00:28:25,430 --> 00:28:31,160
ma nodes and yeah I have a very tiny

00:28:28,550 --> 00:28:34,070
secret so I call this thing monoidal so

00:28:31,160 --> 00:28:37,070
far but in all of the libraries out

00:28:34,070 --> 00:28:39,260
there in Haskell and Scala z and cats

00:28:37,070 --> 00:28:41,570
there it's always called applicative and

00:28:39,260 --> 00:28:45,260
that is short for applicative functor

00:28:41,570 --> 00:28:47,720
but in order to show you these this this

00:28:45,260 --> 00:28:49,850
similarity this relationship i I wanted

00:28:47,720 --> 00:28:52,140
to basically introduce it to you as

00:28:49,850 --> 00:28:54,660
manorial so if you already knew about

00:28:52,140 --> 00:28:56,160
if I might have confused you and I'm

00:28:54,660 --> 00:28:58,950
sorry about that but from now on we'll

00:28:56,160 --> 00:29:02,070
use applicative so okay cool

00:28:58,950 --> 00:29:06,030
so next up is this thing called a

00:29:02,070 --> 00:29:09,150
foldable type class so so far we've used

00:29:06,030 --> 00:29:11,310
lists everywhere to to have like our

00:29:09,150 --> 00:29:14,070
basic collection type but what about

00:29:11,310 --> 00:29:15,990
some things like vector stream or

00:29:14,070 --> 00:29:19,680
something like option which is basically

00:29:15,990 --> 00:29:22,770
like a list with a single element or

00:29:19,680 --> 00:29:23,580
none right and that's what this foldable

00:29:22,770 --> 00:29:26,370
type class does

00:29:23,580 --> 00:29:29,700
so this foldable type class has a few

00:29:26,370 --> 00:29:31,770
methods one of them is fold map and the

00:29:29,700 --> 00:29:36,480
combined all function we saw before and

00:29:31,770 --> 00:29:38,190
fold map takes an abstract F of a right

00:29:36,480 --> 00:29:40,680
so this could be list or vector or

00:29:38,190 --> 00:29:43,950
stream and then it takes a function from

00:29:40,680 --> 00:29:45,930
A to M and M has to have an instance of

00:29:43,950 --> 00:29:49,050
mono as you can see there and then

00:29:45,930 --> 00:29:51,600
because we have a mono I'd and list then

00:29:49,050 --> 00:29:56,600
or something that is list like we can

00:29:51,600 --> 00:29:59,220
flat fold it into a single M value and

00:29:56,600 --> 00:30:01,590
combine all is basically like a shortcut

00:29:59,220 --> 00:30:05,520
so if you already have a mono it inside

00:30:01,590 --> 00:30:09,000
this F right so again I didn't include

00:30:05,520 --> 00:30:11,280
here but yes again combine all is just

00:30:09,000 --> 00:30:14,400
fold map with identity and of course

00:30:11,280 --> 00:30:16,110
instances for this is full a list right

00:30:14,400 --> 00:30:18,150
we have a list foldable a vector

00:30:16,110 --> 00:30:21,060
foldable an option foldable things like

00:30:18,150 --> 00:30:23,660
that and now the really cool part and

00:30:21,060 --> 00:30:27,090
the title of our talk is Traverse and

00:30:23,660 --> 00:30:29,700
the Traverse type class basically

00:30:27,090 --> 00:30:34,290
generalizes what we did before with

00:30:29,700 --> 00:30:36,180
future a in an even more abstract way so

00:30:34,290 --> 00:30:38,280
this is Traverse it extends both

00:30:36,180 --> 00:30:39,960
foldable and functor so we call them

00:30:38,280 --> 00:30:42,360
traversable functors or just Traverse

00:30:39,960 --> 00:30:44,430
for sure and it has the sequence

00:30:42,360 --> 00:30:48,870
function that looks a lot like future

00:30:44,430 --> 00:30:52,080
dot sequence but it's instead of having

00:30:48,870 --> 00:30:55,920
like two instead of having future or

00:30:52,080 --> 00:30:58,170
lists we have just this T and F right so

00:30:55,920 --> 00:30:59,910
basically this T represents our

00:30:58,170 --> 00:31:01,560
traversable type and that can be

00:30:59,910 --> 00:31:05,760
something like lists vector and stream

00:31:01,560 --> 00:31:07,650
and F represents our monoidal or

00:31:05,760 --> 00:31:10,380
click ative type which is some kind of

00:31:07,650 --> 00:31:12,720
effect like option or future or

00:31:10,380 --> 00:31:14,910
something like that and basically from

00:31:12,720 --> 00:31:17,250
the types here we can see it takes an T

00:31:14,910 --> 00:31:19,110
of FFA and returns an F of T array and

00:31:17,250 --> 00:31:20,910
that's just and you can really see here

00:31:19,110 --> 00:31:23,130
that it's just basically turning things

00:31:20,910 --> 00:31:24,900
inside out and that's that's the

00:31:23,130 --> 00:31:26,520
intuition that really helped me and of

00:31:24,900 --> 00:31:29,790
course we also have the Traverse

00:31:26,520 --> 00:31:31,770
function which is very similar again it

00:31:29,790 --> 00:31:34,610
takes the T of a and a function from A

00:31:31,770 --> 00:31:38,220
to F of B and returns an f of T of V

00:31:34,610 --> 00:31:40,230
right so that's cool we have instances

00:31:38,220 --> 00:31:43,440
for vector we have instances for option

00:31:40,230 --> 00:31:47,700
we can also do something crazy like have

00:31:43,440 --> 00:31:49,920
instances for either with with a string

00:31:47,700 --> 00:31:52,230
right so either with where the left type

00:31:49,920 --> 00:31:55,050
is a string is either a string or an A

00:31:52,230 --> 00:31:58,320
and basically it's like an option where

00:31:55,050 --> 00:32:00,480
the none type is just some string and of

00:31:58,320 --> 00:32:02,850
course we could then of course if we can

00:32:00,480 --> 00:32:04,320
define a an instance for option we

00:32:02,850 --> 00:32:07,950
should also be able to find one for

00:32:04,320 --> 00:32:11,850
either and so we actually had to use

00:32:07,950 --> 00:32:13,770
this this type alias but we can actually

00:32:11,850 --> 00:32:15,300
do a little bit better because we don't

00:32:13,770 --> 00:32:17,580
want to force like the string on the

00:32:15,300 --> 00:32:19,650
left hand side we want it to be any type

00:32:17,580 --> 00:32:22,140
and to do that we need something called

00:32:19,650 --> 00:32:24,480
kind trajector or something even more

00:32:22,140 --> 00:32:27,960
ugly called type lambdas but basically

00:32:24,480 --> 00:32:29,970
this means that because either takes two

00:32:27,960 --> 00:32:32,910
type parameters we have to use this

00:32:29,970 --> 00:32:34,710
question mark to turn it into a type

00:32:32,910 --> 00:32:36,540
constructor that only takes one type

00:32:34,710 --> 00:32:39,290
argument right and this is how that

00:32:36,540 --> 00:32:42,150
works right ok cool

00:32:39,290 --> 00:32:43,800
so what what can we do with this so for

00:32:42,150 --> 00:32:45,630
example we can turn a list of future

00:32:43,800 --> 00:32:48,900
into your future list of a that is the

00:32:45,630 --> 00:32:50,790
future that sequence use case but we can

00:32:48,900 --> 00:32:53,220
also do something like stream of option

00:32:50,790 --> 00:32:56,310
of a 2 option of stream of a we can turn

00:32:53,220 --> 00:33:00,680
in either E or i/o a into an isle of

00:32:56,310 --> 00:33:03,450
either a and a and we can do this for

00:33:00,680 --> 00:33:05,460
dozens of different combinations right

00:33:03,450 --> 00:33:09,780
so every time you have a traversable

00:33:05,460 --> 00:33:13,410
type which can be stream list vector

00:33:09,780 --> 00:33:16,580
option either or and or the applicative

00:33:13,410 --> 00:33:18,940
type which can be option future io

00:33:16,580 --> 00:33:21,250
but also vector and list

00:33:18,940 --> 00:33:23,560
than whatever so we have dozens of

00:33:21,250 --> 00:33:25,510
dozens of different combinations we can

00:33:23,560 --> 00:33:27,910
do and we've the only thing we need to

00:33:25,510 --> 00:33:29,500
do is define a traversable instance and

00:33:27,910 --> 00:33:32,940
an applicative instance and we can Ollie

00:33:29,500 --> 00:33:36,160
we we can immediately get all of these

00:33:32,940 --> 00:33:38,110
these implementations for free and that

00:33:36,160 --> 00:33:41,560
is a really really cool thing and one of

00:33:38,110 --> 00:33:44,680
my favorite actually traverses is over

00:33:41,560 --> 00:33:46,600
using something like validated NER um

00:33:44,680 --> 00:33:48,910
so we reserved it or validated does

00:33:46,600 --> 00:33:51,910
anyone know what that is okay that's

00:33:48,910 --> 00:33:52,990
cool less people but still a lot um okay

00:33:51,910 --> 00:33:55,180
I'm going to explain it to you but

00:33:52,990 --> 00:33:57,520
basically what this does is it's just

00:33:55,180 --> 00:34:00,070
the same same type the same shape right

00:33:57,520 --> 00:34:02,620
so we have a vector of validated error a

00:34:00,070 --> 00:34:06,100
and we turn it inside out into a

00:34:02,620 --> 00:34:08,470
validated any L of error and vector a it

00:34:06,100 --> 00:34:11,230
just has another type parameter type

00:34:08,470 --> 00:34:14,680
here error but apart from that it's the

00:34:11,230 --> 00:34:17,080
same shape of turning these nested type

00:34:14,680 --> 00:34:19,240
constructors inside out right I hope

00:34:17,080 --> 00:34:21,100
that makes sense right so what the hell

00:34:19,240 --> 00:34:24,010
is validated any all that sounds weird

00:34:21,100 --> 00:34:26,950
so in cats we have this thing called

00:34:24,010 --> 00:34:29,590
validated and basically it represents

00:34:26,950 --> 00:34:33,280
either a valid case which has a value of

00:34:29,590 --> 00:34:35,650
a or an invalid case which has a value

00:34:33,280 --> 00:34:38,710
of e so it's basically like it's

00:34:35,650 --> 00:34:42,760
isomorphic or it's similar in shape to

00:34:38,710 --> 00:34:45,970
either and validated any L is just a

00:34:42,760 --> 00:34:49,480
type alias for validated with a

00:34:45,970 --> 00:34:52,300
non-empty list of some type e as its

00:34:49,480 --> 00:34:54,340
left type right so it this validated any

00:34:52,300 --> 00:34:59,380
L of E and a will either return a

00:34:54,340 --> 00:35:03,730
non-empty list of type E or a value of

00:34:59,380 --> 00:35:05,830
type a and this is actually a fully

00:35:03,730 --> 00:35:08,590
formed applicative or a fully formed

00:35:05,830 --> 00:35:12,280
monoidal and what this allows us to do

00:35:08,590 --> 00:35:14,260
is to create a function that called

00:35:12,280 --> 00:35:16,990
validate so for example if you want to

00:35:14,260 --> 00:35:19,710
have like we still have like some text

00:35:16,990 --> 00:35:23,290
and we want to parse it to like

00:35:19,710 --> 00:35:26,320
something like a user class which may

00:35:23,290 --> 00:35:28,210
might be some data class right and to

00:35:26,320 --> 00:35:30,520
parse it it might return a list of

00:35:28,210 --> 00:35:32,060
errors or it might return a valid user

00:35:30,520 --> 00:35:34,130
because it's a string we can't really

00:35:32,060 --> 00:35:36,830
No so we have this validate function

00:35:34,130 --> 00:35:40,160
where I'm not going to show you the

00:35:36,830 --> 00:35:42,710
implementation and now what we can do is

00:35:40,160 --> 00:35:45,080
if we have a bunch of lines that we want

00:35:42,710 --> 00:35:49,010
to parse these users we can do this

00:35:45,080 --> 00:35:53,780
using Traverse and very simply speaking

00:35:49,010 --> 00:35:56,480
we have this lines variable basically is

00:35:53,780 --> 00:35:58,610
a list of string and now we call

00:35:56,480 --> 00:36:01,490
Traverse using this validate function

00:35:58,610 --> 00:36:04,100
and if we if we would just call a map

00:36:01,490 --> 00:36:07,580
first we would get a list a validated

00:36:04,100 --> 00:36:11,060
any L of error a user and now if we were

00:36:07,580 --> 00:36:13,400
then sequence that turn it inside out we

00:36:11,060 --> 00:36:16,070
get this type validated any L error or

00:36:13,400 --> 00:36:20,660
list user so basically what this gives

00:36:16,070 --> 00:36:23,870
us is either we will get a non-empty

00:36:20,660 --> 00:36:28,490
list of errors or we will get a list of

00:36:23,870 --> 00:36:31,340
users and this is just a single line for

00:36:28,490 --> 00:36:33,080
validation with error accumulation and

00:36:31,340 --> 00:36:34,630
that makes it really really powerful and

00:36:33,080 --> 00:36:37,910
really cool in my opinion

00:36:34,630 --> 00:36:41,600
okay so still not convinced so this is

00:36:37,910 --> 00:36:43,460
kind of a joke but so because this this

00:36:41,600 --> 00:36:45,680
question about how to turn one thing

00:36:43,460 --> 00:36:49,160
into another comes up so often I

00:36:45,680 --> 00:36:50,690
couldn't really let that go so what I

00:36:49,160 --> 00:36:53,150
did was I looked in my Stack Overflow

00:36:50,690 --> 00:36:56,630
history of like the last six month and

00:36:53,150 --> 00:36:58,310
looked at all my answers and I picked

00:36:56,630 --> 00:37:00,680
all the questions that could be answered

00:36:58,310 --> 00:37:02,750
with like oh that's just Traverse so we

00:37:00,680 --> 00:37:05,480
have this so how do I turn list of

00:37:02,750 --> 00:37:08,240
either T future a B to either T future a

00:37:05,480 --> 00:37:10,460
lispy and if you like think away all

00:37:08,240 --> 00:37:12,230
this either ta be thing this is just

00:37:10,460 --> 00:37:16,280
turning it inside out so this is just

00:37:12,230 --> 00:37:18,410
sequence or Traverse and of course here

00:37:16,280 --> 00:37:21,890
how do you turn a list of i/o into an i

00:37:18,410 --> 00:37:26,510
of list sequence how to turn an either

00:37:21,890 --> 00:37:29,000
error option whatever sequence list the

00:37:26,510 --> 00:37:32,120
classy declasse list sequence combined

00:37:29,000 --> 00:37:34,220
valid uses of sec seek validate and yell

00:37:32,120 --> 00:37:37,010
so he has this seek validated non empty

00:37:34,220 --> 00:37:38,570
list string my string into validated

00:37:37,010 --> 00:37:40,790
non-empty list that is exactly what we

00:37:38,570 --> 00:37:42,560
just did that's just sequence come on so

00:37:40,790 --> 00:37:44,580
okay I've got five more minutes for

00:37:42,560 --> 00:37:46,920
something called semigroups

00:37:44,580 --> 00:37:49,350
and semigroups are really cool as well

00:37:46,920 --> 00:37:50,520
that's just because morons are cool so

00:37:49,350 --> 00:37:52,410
this is a semigroup

00:37:50,520 --> 00:37:54,390
and it looks a lot like a model right

00:37:52,410 --> 00:37:56,340
except it doesn't have this empty value

00:37:54,390 --> 00:37:58,830
right so it's just it allows us to

00:37:56,340 --> 00:38:00,540
combine things and yeah actually

00:37:58,830 --> 00:38:02,610
semigroups just described like an

00:38:00,540 --> 00:38:05,430
associative binary operation that means

00:38:02,610 --> 00:38:07,890
semigroup has only one law and that

00:38:05,430 --> 00:38:09,930
means that this combine function has to

00:38:07,890 --> 00:38:11,520
be associative because it doesn't have

00:38:09,930 --> 00:38:13,650
an identity it can have the right and

00:38:11,520 --> 00:38:16,590
left I didn't in laws so this is cool

00:38:13,650 --> 00:38:18,570
and actually if you look at the if you

00:38:16,590 --> 00:38:20,070
look at cats you'll see that something

00:38:18,570 --> 00:38:21,600
like Mahanoy doesn't actually have a

00:38:20,070 --> 00:38:24,870
combined method actually extends

00:38:21,600 --> 00:38:27,360
semigroup and gets sorry the combined

00:38:24,870 --> 00:38:30,270
method from there so we have this sub

00:38:27,360 --> 00:38:33,030
sub class relationship again so motor ID

00:38:30,270 --> 00:38:36,510
mono it extends semigroup and yr

00:38:33,030 --> 00:38:38,660
semigroups cool well who has ever gotten

00:38:36,510 --> 00:38:41,670
this right so not the first thing but

00:38:38,660 --> 00:38:43,590
unsupported operation exception empty

00:38:41,670 --> 00:38:45,660
dot max who's got who's got in this

00:38:43,590 --> 00:38:48,900
error before yeah okay

00:38:45,660 --> 00:38:50,730
I expected more but that's fine so what

00:38:48,900 --> 00:38:53,310
what happens is that in the scholar

00:38:50,730 --> 00:38:55,950
collections that if you call you can

00:38:53,310 --> 00:38:59,340
call this max operation which will give

00:38:55,950 --> 00:39:03,120
you the max maximum of any of any

00:38:59,340 --> 00:39:05,220
collection it will fail if the list is

00:39:03,120 --> 00:39:09,330
empty or the stream or vector is empty

00:39:05,220 --> 00:39:10,980
and basically just say well yeah throw

00:39:09,330 --> 00:39:12,780
it one time and that's never what we

00:39:10,980 --> 00:39:14,880
want but we usually always want is to

00:39:12,780 --> 00:39:17,280
have like guarantees at compile time and

00:39:14,880 --> 00:39:19,410
never fail at runtime it in the same as

00:39:17,280 --> 00:39:21,450
done with reduced write so reduces like

00:39:19,410 --> 00:39:24,960
the version of fold we we don't give it

00:39:21,450 --> 00:39:28,440
a seed and of course that fails if the

00:39:24,960 --> 00:39:30,750
list is empty and yeah what we can

00:39:28,440 --> 00:39:34,680
actually do though is we have this cool

00:39:30,750 --> 00:39:36,750
non empty list in cats and it gives us a

00:39:34,680 --> 00:39:38,400
way to only construct lists that are non

00:39:36,750 --> 00:39:40,260
empty right so if we call this thing non

00:39:38,400 --> 00:39:42,690
empty list with open parents closed

00:39:40,260 --> 00:39:44,700
parents it actually won't compile well

00:39:42,690 --> 00:39:46,380
throw an error at compile time and say

00:39:44,700 --> 00:39:48,870
there hey you need to give me a head and

00:39:46,380 --> 00:39:52,530
then you can do whatever so and because

00:39:48,870 --> 00:39:54,480
this non empty list gives us gives us

00:39:52,530 --> 00:39:56,970
this guarantee that it's not empty as as

00:39:54,480 --> 00:39:58,140
it's called we can actually very safely

00:39:56,970 --> 00:40:01,170
call maximum

00:39:58,140 --> 00:40:04,319
and actually like maximum is implemented

00:40:01,170 --> 00:40:07,380
in terms of what is called a semigroup

00:40:04,319 --> 00:40:09,930
right suppose so if we have there's this

00:40:07,380 --> 00:40:14,099
thing called max semigroup and basically

00:40:09,930 --> 00:40:17,579
that just means that if we combine to

00:40:14,099 --> 00:40:19,529
funk two to two values it will always

00:40:17,579 --> 00:40:21,690
take the maximum of the two values so if

00:40:19,529 --> 00:40:23,970
we traverse a whole list with this

00:40:21,690 --> 00:40:27,059
maximum semi-group it will always give

00:40:23,970 --> 00:40:29,279
us the maximum value and because there

00:40:27,059 --> 00:40:32,369
is no empty value that you can't create

00:40:29,279 --> 00:40:36,480
a monoid for max you have to use the

00:40:32,369 --> 00:40:38,279
semigroup and to to call to use this

00:40:36,480 --> 00:40:42,509
maximum function you have to actually

00:40:38,279 --> 00:40:44,849
make sure that this list is non-empty so

00:40:42,509 --> 00:40:47,309
that you can actually use a semi group

00:40:44,849 --> 00:40:50,130
instead of a monoid right and of course

00:40:47,309 --> 00:40:52,970
we can also call reduce safely on a non

00:40:50,130 --> 00:40:57,440
empty list and as the last bonus slide I

00:40:52,970 --> 00:40:59,880
have semi grupo functors which are

00:40:57,440 --> 00:41:02,910
basically like Monarto or pelcula

00:40:59,880 --> 00:41:05,759
punctures without the pure type right so

00:41:02,910 --> 00:41:07,529
semi Guapo or like semi group to mono it

00:41:05,759 --> 00:41:09,839
they don't have an empty they don't have

00:41:07,529 --> 00:41:11,940
semi goo balls don't have a pure and of

00:41:09,839 --> 00:41:13,559
course illinois doll then extend simon

00:41:11,940 --> 00:41:17,809
group oh and because i already told you

00:41:13,559 --> 00:41:20,730
that's a lie we have apply and

00:41:17,809 --> 00:41:22,920
applicative instead right so apply

00:41:20,730 --> 00:41:26,130
basically means that we only have this

00:41:22,920 --> 00:41:27,989
product function and we don't have this

00:41:26,130 --> 00:41:30,779
pure it's added in the applicative and

00:41:27,989 --> 00:41:34,710
why do we need that well basically you

00:41:30,779 --> 00:41:37,799
can also traverse over things that don't

00:41:34,710 --> 00:41:40,680
have a pure function if you if you use

00:41:37,799 --> 00:41:45,239
this apply if you have a non empty a non

00:41:40,680 --> 00:41:47,400
empty collection and as an example you

00:41:45,239 --> 00:41:50,940
can try to create an applicative for

00:41:47,400 --> 00:41:53,130
something like map and you might run

00:41:50,940 --> 00:41:55,099
into errors immediately because if you

00:41:53,130 --> 00:41:59,519
if you want to write a play it of

00:41:55,099 --> 00:42:02,339
instance for map for how do you how do

00:41:59,519 --> 00:42:06,900
you create a value of map Cavey if you

00:42:02,339 --> 00:42:08,940
only have value of V right you if you

00:42:06,900 --> 00:42:10,859
want to insert something into a map you

00:42:08,940 --> 00:42:12,030
need to give it both a key and a value

00:42:10,859 --> 00:42:14,190
you can't just give it a

00:42:12,030 --> 00:42:18,830
so this is basically unemployment Abel

00:42:14,190 --> 00:42:18,830
and that's why applicative can't have

00:42:18,860 --> 00:42:23,610
that's why map can't have an applicative

00:42:21,330 --> 00:42:26,370
instance but what it can have is an

00:42:23,610 --> 00:42:28,620
apply method and yeah this so this works

00:42:26,370 --> 00:42:33,180
and we can actually use a non-empty list

00:42:28,620 --> 00:42:35,070
to traverse over applies over instances

00:42:33,180 --> 00:42:36,720
that use apply instead of applicatives

00:42:35,070 --> 00:42:38,820
so that's it for me

00:42:36,720 --> 00:42:41,610
conclusions very quick today we learned

00:42:38,820 --> 00:42:44,730
about Menards functors applicatives and

00:42:41,610 --> 00:42:46,440
foldables and of course we also learned

00:42:44,730 --> 00:42:48,900
about non empty lists and validated and

00:42:46,440 --> 00:42:51,090
all of this can be found in cats and

00:42:48,900 --> 00:42:53,430
yeah we learned about the really cool

00:42:51,090 --> 00:42:54,690
power of traverse so your ever if you

00:42:53,430 --> 00:42:56,340
don't know what to do

00:42:54,690 --> 00:42:58,920
just call traverse see if it compiles

00:42:56,340 --> 00:43:00,630
then usually your code is fine okay

00:42:58,920 --> 00:43:02,370
thank you very much I hope this was a

00:43:00,630 --> 00:43:04,710
good gateway drug so you should all

00:43:02,370 --> 00:43:06,780
check out cats yeah thank you for very

00:43:04,710 --> 00:43:10,970
much for listening my name is Luca you

00:43:06,780 --> 00:43:14,670
can find me on Twitter yeah on github

00:43:10,970 --> 00:43:16,050
I'm also active on Gator and the cat's

00:43:14,670 --> 00:43:18,000
channel so if you ever have any

00:43:16,050 --> 00:43:21,360
questions just feel free to ask we are

00:43:18,000 --> 00:43:23,340
very friendly and want to convince you

00:43:21,360 --> 00:43:26,960
to use it more so we try to be as nice

00:43:23,340 --> 00:43:31,290
as possible yeah thanks a lot Luca and

00:43:26,960 --> 00:43:33,270
although we are actually at the end of

00:43:31,290 --> 00:43:34,980
the talk exactly since we're going to

00:43:33,270 --> 00:43:37,530
lunch break now there are urgent

00:43:34,980 --> 00:43:39,810
questions now I think we can take two or

00:43:37,530 --> 00:43:50,220
three questions but if you're hungry you

00:43:39,810 --> 00:43:53,100
can also already but if they are ok just

00:43:50,220 --> 00:44:00,320
a silly question sure why do you

00:43:53,100 --> 00:44:03,510
annotate the type class so right so um

00:44:00,320 --> 00:44:06,840
this this ad type class yeah this is

00:44:03,510 --> 00:44:10,530
this is a simulacrum that basically what

00:44:06,840 --> 00:44:13,620
it gives you is syntax right so for

00:44:10,530 --> 00:44:18,090
example in the very let me just skip to

00:44:13,620 --> 00:44:20,210
the beginning here in this show thing

00:44:18,090 --> 00:44:24,990
right we call this

00:44:20,210 --> 00:44:25,410
sorry we call this way is this there

00:44:24,990 --> 00:44:27,300
okay

00:44:25,410 --> 00:44:30,120
this T dot shows so basically what it

00:44:27,300 --> 00:44:33,120
allows us to give us syntax right so

00:44:30,120 --> 00:44:34,800
because if if you were only to define

00:44:33,120 --> 00:44:37,110
without this app type class annotation

00:44:34,800 --> 00:44:38,640
you couldn't get this nice syntax so

00:44:37,110 --> 00:44:40,940
what we would have to do instead of

00:44:38,640 --> 00:44:42,120
calling T dot show you would have to do

00:44:40,940 --> 00:44:47,130
implicitly

00:44:42,120 --> 00:44:51,240
show of T dot show and then in parents T

00:44:47,130 --> 00:44:54,630
so it's basically just to give us the

00:44:51,240 --> 00:44:57,270
nice syntax we used to when using Scala

00:44:54,630 --> 00:44:59,850
in general yeah so this inline syntax

00:44:57,270 --> 00:45:01,500
most of the time yeah and it's really

00:44:59,850 --> 00:45:03,000
cool you should like if you want to

00:45:01,500 --> 00:45:05,690
write your own type classes simulacrum

00:45:03,000 --> 00:45:05,690

YouTube URL: https://www.youtube.com/watch?v=yEYPf44rS2U


