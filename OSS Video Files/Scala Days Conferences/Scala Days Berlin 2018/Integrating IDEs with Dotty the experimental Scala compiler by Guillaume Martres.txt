Title: Integrating IDEs with Dotty the experimental Scala compiler by Guillaume Martres
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6932-integrating-ides-with-dotty%2C-the-experimental-scala-compiler.html
Captions: 
	00:00:04,850 --> 00:00:10,170
hi everyone so my name is Guillaume and

00:00:08,519 --> 00:00:13,260
today I'm going to talk to you about

00:00:10,170 --> 00:00:17,039
ideas and compilers and how we're trying

00:00:13,260 --> 00:00:18,480
to integrate all of them together so I

00:00:17,039 --> 00:00:20,340
guess I don't really need to introduce

00:00:18,480 --> 00:00:22,980
Dottie much anymore since you've seen

00:00:20,340 --> 00:00:25,560
Martin's keynote but briefly this is

00:00:22,980 --> 00:00:27,869
this new research compiler that should

00:00:25,560 --> 00:00:30,929
be become scary at some point which has

00:00:27,869 --> 00:00:32,669
a redesign type system in Turners but

00:00:30,929 --> 00:00:35,550
that looks really similar in the surface

00:00:32,669 --> 00:00:38,520
and yet check out the website if you

00:00:35,550 --> 00:00:41,460
want more information on all things that

00:00:38,520 --> 00:00:43,560
he related but that is also a chance to

00:00:41,460 --> 00:00:45,900
redesign components of the compiler so

00:00:43,560 --> 00:00:47,970
for example we improved incremental

00:00:45,900 --> 00:00:50,480
compilation by avoiding under

00:00:47,970 --> 00:00:52,920
compilation in some cases and some and

00:00:50,480 --> 00:00:56,280
we also have better pattern matching

00:00:52,920 --> 00:00:57,870
checks and the algorithm we implemented

00:00:56,280 --> 00:01:00,600
actually who is now reused in Swift

00:00:57,870 --> 00:01:02,790
which is pretty cool and some of these

00:01:00,600 --> 00:01:04,920
things are also being parted back to

00:01:02,790 --> 00:01:09,810
scare to like that are improving mental

00:01:04,920 --> 00:01:12,659
calculation and of course if you want

00:01:09,810 --> 00:01:14,789
people to use dotty we need to provide a

00:01:12,659 --> 00:01:17,939
good developer experience which means we

00:01:14,789 --> 00:01:19,649
need to provide good tools so we have

00:01:17,939 --> 00:01:22,819
the wrapper which even has syntax

00:01:19,649 --> 00:01:25,200
highlighting like ammonites we have

00:01:22,819 --> 00:01:28,469
documentation tool that is used to

00:01:25,200 --> 00:01:32,609
generate oil for documentation and we

00:01:28,469 --> 00:01:35,189
have of course IDE supports so how did

00:01:32,609 --> 00:01:37,799
we do that so let's first start by

00:01:35,189 --> 00:01:40,740
looking at the state of year so the kind

00:01:37,799 --> 00:01:43,469
of idea support you can get today in

00:01:40,740 --> 00:01:45,240
Skara so there's two kinds relievers the

00:01:43,469 --> 00:01:49,049
one based on the sky representation

00:01:45,240 --> 00:01:52,799
compiler that is versatile ID based on

00:01:49,049 --> 00:01:55,020
Eclipse and enzyme and on the other side

00:01:52,799 --> 00:01:57,359
you have implemented so the sky type

00:01:55,020 --> 00:01:57,719
checker and there's only one beside

00:01:57,359 --> 00:02:02,819
dotty

00:01:57,719 --> 00:02:06,899
it was Carrigan for in 3G and all of

00:02:02,819 --> 00:02:09,300
this have like done really good things

00:02:06,899 --> 00:02:11,370
for the making it possible for people to

00:02:09,300 --> 00:02:13,500
use and be productive in scale they're

00:02:11,370 --> 00:02:15,810
also kind of hard to reuse

00:02:13,500 --> 00:02:18,150
first because there are a lot of lines

00:02:15,810 --> 00:02:22,319
of code and they're kind of tight either

00:02:18,150 --> 00:02:25,170
specific ID are to a specific version of

00:02:22,319 --> 00:02:27,870
a skeleton Poirot so when we were

00:02:25,170 --> 00:02:29,340
designing the IDE support for dotty we

00:02:27,870 --> 00:02:33,480
tried to come up with some design

00:02:29,340 --> 00:02:34,980
principles to follow to avoid getting

00:02:33,480 --> 00:02:38,879
into the same issues with the current

00:02:34,980 --> 00:02:41,489
ideas have and hopefully improve the

00:02:38,879 --> 00:02:43,409
situations so the first important one is

00:02:41,489 --> 00:02:46,140
code reuse as much as possible we want

00:02:43,409 --> 00:02:49,920
the IDE and the compiler to share code

00:02:46,140 --> 00:02:51,480
so that if you find bugs in the compiler

00:02:49,920 --> 00:02:54,659
and we fix them they're also fixed in

00:02:51,480 --> 00:02:56,879
the ID and because testing the compiler

00:02:54,659 --> 00:02:59,459
is much easier than testing an IDE which

00:02:56,879 --> 00:03:03,450
typically involves a lot of interactive

00:02:59,459 --> 00:03:05,489
things it makes it much easier to get

00:03:03,450 --> 00:03:07,879
something which is robust and not get

00:03:05,489 --> 00:03:11,069
bugs which are impossible to reproduce

00:03:07,879 --> 00:03:12,689
second is editor elasticity as much as

00:03:11,069 --> 00:03:16,109
possible we don't want to be dependent

00:03:12,689 --> 00:03:20,310
on the fate of one specific editor like

00:03:16,109 --> 00:03:22,650
Eclipse because depending on what's 20

00:03:20,310 --> 00:03:25,379
this here some ideas are going to be

00:03:22,650 --> 00:03:27,230
used more or less so we can't expect

00:03:25,379 --> 00:03:29,549
everyone to want to use the same thing

00:03:27,230 --> 00:03:31,290
of course and probably the most

00:03:29,549 --> 00:03:35,669
important one is that it has to be easy

00:03:31,290 --> 00:03:37,379
to use and to install so let's go

00:03:35,669 --> 00:03:42,590
through this principles one by one and

00:03:37,379 --> 00:03:44,970
see how we implemented them so first off

00:03:42,590 --> 00:03:48,269
code reuse what does this mean here it

00:03:44,970 --> 00:03:50,310
means that to do the kind of interactive

00:03:48,269 --> 00:03:54,329
features you expect from your IDE like

00:03:50,310 --> 00:03:56,010
go to definition or renaming as much as

00:03:54,329 --> 00:03:59,040
possible which should be done by asking

00:03:56,010 --> 00:04:00,479
the compiler about its internal

00:03:59,040 --> 00:04:02,909
representation instead of trying to

00:04:00,479 --> 00:04:05,879
reproduce what the compiler does in a

00:04:02,909 --> 00:04:08,040
different way which means we want to

00:04:05,879 --> 00:04:10,829
query the compiler so really what's the

00:04:08,040 --> 00:04:14,879
compiler what what does it do a bunch of

00:04:10,829 --> 00:04:16,979
things basically this is a list an

00:04:14,879 --> 00:04:18,750
incomplete list of all the phases in the

00:04:16,979 --> 00:04:21,209
compiler you start with a parser of the

00:04:18,750 --> 00:04:24,570
text your source code and gives you

00:04:21,209 --> 00:04:27,360
untyped abstract syntax trees when you

00:04:24,570 --> 00:04:28,620
type check them and then everything

00:04:27,360 --> 00:04:32,010
after that is just a series of

00:04:28,620 --> 00:04:33,600
transformation that simplify the trees

00:04:32,010 --> 00:04:37,020
until you get something that you can

00:04:33,600 --> 00:04:42,000
emit as JVM bytecode or as on using some

00:04:37,020 --> 00:04:45,210
of our back-end and if you want to query

00:04:42,000 --> 00:04:47,430
the compiler you mostly care about the

00:04:45,210 --> 00:04:50,970
type of face and I'll explain why

00:04:47,430 --> 00:04:52,710
shortly so imagine you have some source

00:04:50,970 --> 00:04:55,290
code very simple source code we have a

00:04:52,710 --> 00:04:57,810
final value which is called LM it's

00:04:55,290 --> 00:05:01,050
value is 1 and you have some other of

00:04:57,810 --> 00:05:03,690
our foo which refers to Ln and this

00:05:01,050 --> 00:05:06,780
little flag I put here is the cursor

00:05:03,690 --> 00:05:09,240
position in your ID and at this point

00:05:06,780 --> 00:05:12,450
the user wants to jump to a definition

00:05:09,240 --> 00:05:15,120
of Allen so to do that you need to

00:05:12,450 --> 00:05:18,840
figure out the position of the

00:05:15,120 --> 00:05:20,820
definition of LM and if you look at the

00:05:18,840 --> 00:05:23,430
tree you get after type checking it

00:05:20,820 --> 00:05:26,010
looks a bit like this so it's not string

00:05:23,430 --> 00:05:27,690
anymore it's at this point and abstract

00:05:26,010 --> 00:05:30,780
syntax tree but if you pretty print it

00:05:27,690 --> 00:05:33,150
it looks like this kind of codes so at

00:05:30,780 --> 00:05:37,500
every node basically we have the type

00:05:33,150 --> 00:05:41,040
and the position of this not inverse

00:05:37,500 --> 00:05:43,410
host code and based on this we can

00:05:41,040 --> 00:05:46,500
answer the query because the type of LM

00:05:43,410 --> 00:05:48,570
give us enough information to find by

00:05:46,500 --> 00:05:51,390
traversing the trees where LM has been

00:05:48,570 --> 00:05:54,150
defined and once we find we found this

00:05:51,390 --> 00:05:57,240
tree node we can figure out its position

00:05:54,150 --> 00:06:02,190
in the source code and then we can tell

00:05:57,240 --> 00:06:04,440
IDE jump to this position but if we go a

00:06:02,190 --> 00:06:07,440
little bit further in the trees produced

00:06:04,440 --> 00:06:09,330
by the compiler say we do after constant

00:06:07,440 --> 00:06:12,440
folding well at this point we cannot

00:06:09,330 --> 00:06:14,520
answer the user query anymore because

00:06:12,440 --> 00:06:15,740
information has been lost by constant

00:06:14,520 --> 00:06:18,750
folding

00:06:15,740 --> 00:06:23,400
we went from LM plus 1

00:06:18,750 --> 00:06:26,670
to just 2 alpha 3 and at this point you

00:06:23,400 --> 00:06:28,950
don't know that there was what we called

00:06:26,670 --> 00:06:31,260
LM at this point so you can jump to the

00:06:28,950 --> 00:06:35,040
definition of M so it's really important

00:06:31,260 --> 00:06:37,740
for ideas you thought that the output of

00:06:35,040 --> 00:06:40,410
the compiler of type checker preserves

00:06:37,740 --> 00:06:44,400
as much information as possible that can

00:06:40,410 --> 00:06:48,600
then be used by tools like the ID

00:06:44,400 --> 00:06:50,340
and when we can of course simplify and

00:06:48,600 --> 00:06:52,880
remove this information but only in

00:06:50,340 --> 00:06:56,669
later phases

00:06:52,880 --> 00:06:58,860
so to recap to query the compiler you

00:06:56,669 --> 00:07:01,740
want to starve the trees you get right

00:06:58,860 --> 00:07:05,009
after type checking and you can serve ID

00:07:01,740 --> 00:07:06,870
queries by traversing these trees but

00:07:05,009 --> 00:07:08,910
this leaves one questions unanswered is

00:07:06,870 --> 00:07:10,889
what to do about Calvert has already

00:07:08,910 --> 00:07:13,110
been compiled because typically in a

00:07:10,889 --> 00:07:15,870
project you're going to have a few files

00:07:13,110 --> 00:07:18,060
open in your ideas and at every

00:07:15,870 --> 00:07:20,130
keystroke you can ask your compiler to

00:07:18,060 --> 00:07:23,039
retype check them but then every other

00:07:20,130 --> 00:07:24,630
file in your project which has already

00:07:23,039 --> 00:07:26,610
been compiled you don't want to

00:07:24,630 --> 00:07:28,380
recompile them every time you type a

00:07:26,610 --> 00:07:33,000
single keystroke because you really have

00:07:28,380 --> 00:07:34,020
classifiers for them so to explain right

00:07:33,000 --> 00:07:36,000
I need to introduce another concept

00:07:34,020 --> 00:07:37,949
which is peeking

00:07:36,000 --> 00:07:43,110
so pickling is a phase in the compiler

00:07:37,949 --> 00:07:45,900
that happens a little bit later and this

00:07:43,110 --> 00:07:48,349
phase it takes some information from the

00:07:45,900 --> 00:07:51,930
trajectories and store this information

00:07:48,349 --> 00:07:55,080
so that it will end up in the classifier

00:07:51,930 --> 00:07:56,910
at the ends so in scale to this already

00:07:55,080 --> 00:07:59,820
exists and it's used to store method

00:07:56,910 --> 00:08:01,380
signatures basically if you want to

00:07:59,820 --> 00:08:03,960
support separate compilation in Scala

00:08:01,380 --> 00:08:07,229
that means I have a dot color beaders

00:08:03,960 --> 00:08:09,510
kara B depends on a I first compiled a

00:08:07,229 --> 00:08:12,720
and then at some later point I decided

00:08:09,510 --> 00:08:15,090
to compile B I need to know the

00:08:12,720 --> 00:08:17,699
signatures of all the methods in a to be

00:08:15,090 --> 00:08:19,860
able to call them and in the JVM

00:08:17,699 --> 00:08:22,680
bytecode we already lose some

00:08:19,860 --> 00:08:24,599
information because the JVM does not

00:08:22,680 --> 00:08:25,169
represent things like type power metals

00:08:24,599 --> 00:08:27,810
at all

00:08:25,169 --> 00:08:30,630
so this in from we we know the name of

00:08:27,810 --> 00:08:32,580
all the methods in the JVM bytecode but

00:08:30,630 --> 00:08:34,320
we don't know the exact type signatures

00:08:32,580 --> 00:08:37,709
so this needs to be stored separately

00:08:34,320 --> 00:08:40,409
and this is third in the pickled

00:08:37,709 --> 00:08:43,289
information in the class file in square

00:08:40,409 --> 00:08:45,480
two in dot e we do the exact same thing

00:08:43,289 --> 00:08:49,110
but we go further instead of just

00:08:45,480 --> 00:08:51,720
showing C natural the API of your

00:08:49,110 --> 00:08:56,040
classes we saw the complete

00:08:51,720 --> 00:08:57,480
type check trees and she's got tasty so

00:08:56,040 --> 00:09:00,630
tasty if you've seen

00:08:57,480 --> 00:09:02,160
p-nut of Martines is this amazing thing

00:09:00,630 --> 00:09:05,610
that's going to solve our problems in

00:09:02,160 --> 00:09:07,649
Scala like gives you binary compound

00:09:05,610 --> 00:09:11,540
between scale a 2 and 3 and

00:09:07,649 --> 00:09:13,889
automatically give you j s and whatever

00:09:11,540 --> 00:09:17,250
but here we're mostly interested in what

00:09:13,889 --> 00:09:19,800
it has to do with ideas but first to

00:09:17,250 --> 00:09:22,740
basically briefly explain the original

00:09:19,800 --> 00:09:24,209
motivation of TC is another attempt at

00:09:22,740 --> 00:09:26,940
solving of a binary converter with a

00:09:24,209 --> 00:09:30,600
problem problem is what if you always

00:09:26,940 --> 00:09:33,180
use JVM bytecode then whenever the

00:09:30,600 --> 00:09:35,250
compiler changes its encoding say of

00:09:33,180 --> 00:09:38,310
trades Institute world compared to scale

00:09:35,250 --> 00:09:40,709
up to 11 then everything breaks because

00:09:38,310 --> 00:09:42,930
the encoding is different and

00:09:40,709 --> 00:09:44,399
classifiers using one encoding cannot

00:09:42,930 --> 00:09:49,139
refer to class while using and over

00:09:44,399 --> 00:09:51,510
encoding and you can solve this by

00:09:49,139 --> 00:09:53,910
always compiling from sources but then

00:09:51,510 --> 00:09:56,100
you also can break things when the type

00:09:53,910 --> 00:09:59,579
checker changes so type inference in

00:09:56,100 --> 00:10:01,170
saqqara typically evolves say someone

00:09:59,579 --> 00:10:03,000
find some example where you want

00:10:01,170 --> 00:10:05,279
something to type to be inferred

00:10:03,000 --> 00:10:07,709
correctly it isn't so we change them and

00:10:05,279 --> 00:10:09,120
we hope we test things and we hope that

00:10:07,709 --> 00:10:10,889
he doesn't break too much cards but it's

00:10:09,120 --> 00:10:13,019
always possible that some code that used

00:10:10,889 --> 00:10:15,480
to compile now doesn't compile because

00:10:13,019 --> 00:10:17,850
inference changed slightly because

00:10:15,480 --> 00:10:19,800
implicit search is reserving things a

00:10:17,850 --> 00:10:21,209
little bit differently so already

00:10:19,800 --> 00:10:25,079
comparing things from source code is

00:10:21,209 --> 00:10:26,459
also not very practical and tasty is

00:10:25,079 --> 00:10:29,670
kind of a middle ground between these

00:10:26,459 --> 00:10:32,430
two things because we saw the trees as

00:10:29,670 --> 00:10:34,319
they are after type checking and type

00:10:32,430 --> 00:10:35,519
checking already take care of all the

00:10:34,319 --> 00:10:38,100
things that move the most in the

00:10:35,519 --> 00:10:40,079
compiler a lot of them Twiggy has to get

00:10:38,100 --> 00:10:44,040
right which are type inference and

00:10:40,079 --> 00:10:45,690
avoiding reservation implicit search but

00:10:44,040 --> 00:10:47,760
at the same time it's much more high

00:10:45,690 --> 00:10:50,459
level than JVM bytecode

00:10:47,760 --> 00:10:53,100
so when we change things like the

00:10:50,459 --> 00:10:53,699
encoding of trades or when we decide to

00:10:53,100 --> 00:10:56,160
add put

00:10:53,699 --> 00:10:58,949
Java 11 classifiers instead of Java 8

00:10:56,160 --> 00:11:03,690
that doesn't influence what's stored in

00:10:58,949 --> 00:11:06,000
the tastytrade so how does we thread to

00:11:03,690 --> 00:11:08,579
ideas well basically we only care about

00:11:06,000 --> 00:11:10,030
tasty for ideas because they contain the

00:11:08,579 --> 00:11:12,040
type check trees

00:11:10,030 --> 00:11:13,030
and as I explained previously using the

00:11:12,040 --> 00:11:15,390
type check phase you have all the

00:11:13,030 --> 00:11:18,640
information you need to be able to query

00:11:15,390 --> 00:11:20,680
the compiler to do things like go to the

00:11:18,640 --> 00:11:24,790
finish and now find our references are

00:11:20,680 --> 00:11:27,850
renaming so it is very interesting

00:11:24,790 --> 00:11:29,710
because it means that we have one data

00:11:27,850 --> 00:11:32,200
structure we use to query the compiler

00:11:29,710 --> 00:11:35,710
which retrieves and this works at the

00:11:32,200 --> 00:11:38,590
same time for trees in the open files in

00:11:35,710 --> 00:11:41,890
your IDs and for other trees in your

00:11:38,590 --> 00:11:48,010
class path will have been compiled using

00:11:41,890 --> 00:11:51,030
the tea so based on that we made a set

00:11:48,010 --> 00:11:54,910
of very simple interactive API is to

00:11:51,030 --> 00:11:57,610
basically where it is and do a lifecycle

00:11:54,910 --> 00:11:59,590
management of a compiler and we can use

00:11:57,610 --> 00:12:03,580
that both in the IDE and the repple

00:11:59,590 --> 00:12:05,140
again code we use a so when you ask for

00:12:03,580 --> 00:12:07,900
completions in one of the other we're

00:12:05,140 --> 00:12:10,270
going to use the same code and in the

00:12:07,900 --> 00:12:11,950
future we probably enhance that by

00:12:10,270 --> 00:12:14,440
adding a POS for dealing with

00:12:11,950 --> 00:12:16,500
interruption handling or partial type

00:12:14,440 --> 00:12:18,400
checking because when you're in your IDE

00:12:16,500 --> 00:12:21,820
basically every time you press a

00:12:18,400 --> 00:12:23,830
keystroke we concurrently type check the

00:12:21,820 --> 00:12:26,470
whole file but we could do things in a

00:12:23,830 --> 00:12:28,570
better way and only touch like a section

00:12:26,470 --> 00:12:30,160
of the file that changed and we could

00:12:28,570 --> 00:12:34,660
stop the type checking as soon as you

00:12:30,160 --> 00:12:36,130
decide to add another keystroke and the

00:12:34,660 --> 00:12:39,090
interesting thing about this is that

00:12:36,130 --> 00:12:42,460
it's less than a thousand lines of code

00:12:39,090 --> 00:12:45,430
so it's pretty easy to maintain

00:12:42,460 --> 00:12:49,750
compared to burn in front asian of the

00:12:45,430 --> 00:12:55,830
type checker on to the second principal

00:12:49,750 --> 00:12:58,990
editor agnostic so there's this idea

00:12:55,830 --> 00:13:01,090
portability problem which is if you have

00:12:58,990 --> 00:13:04,810
a bunch of ideas and a bunch of

00:13:01,090 --> 00:13:06,460
programming languages you need to

00:13:04,810 --> 00:13:08,200
multiply the number of ideas by the

00:13:06,460 --> 00:13:10,720
number of foreign languages to get the

00:13:08,200 --> 00:13:13,600
number of plugins you need to support

00:13:10,720 --> 00:13:15,490
all these things properly and that's bad

00:13:13,600 --> 00:13:19,720
because it means a lot of duplicated

00:13:15,490 --> 00:13:21,190
work in development efforts since for

00:13:19,720 --> 00:13:23,440
each idea you're going to have to redo a

00:13:21,190 --> 00:13:25,510
plug-in it also means that

00:13:23,440 --> 00:13:28,540
to write the plugin you need to be an

00:13:25,510 --> 00:13:30,490
expert in above how the ide work and how

00:13:28,540 --> 00:13:32,680
your programming language compiler works

00:13:30,490 --> 00:13:36,790
and usually people who are expert in one

00:13:32,680 --> 00:13:40,210
are not expert in the other so how do we

00:13:36,790 --> 00:13:41,800
fix that well you might have heard of

00:13:40,210 --> 00:13:43,630
that in a previous talk but that is in

00:13:41,800 --> 00:13:47,080
called the language server protocol and

00:13:43,630 --> 00:13:52,530
the idea is instead of tightly covering

00:13:47,080 --> 00:13:55,780
an IDE and a compiler you can instead

00:13:52,530 --> 00:13:57,430
make a protocol so that IDs and

00:13:55,780 --> 00:14:00,760
compilers can talk to each other so on

00:13:57,430 --> 00:14:03,640
one side you have a tool which is

00:14:00,760 --> 00:14:05,470
usually your compiler your ID sorry and

00:14:03,640 --> 00:14:07,000
in the other side you have a language

00:14:05,470 --> 00:14:11,020
server which is usually your compiler

00:14:07,000 --> 00:14:13,210
and when a user does something like

00:14:11,020 --> 00:14:15,130
opening a document you're going to tell

00:14:13,210 --> 00:14:17,620
the compiler hey the user open this

00:14:15,130 --> 00:14:19,480
document and every time something

00:14:17,620 --> 00:14:22,090
changes you let the compiler knows and

00:14:19,480 --> 00:14:24,730
then on the other side the compiler can

00:14:22,090 --> 00:14:28,780
send information back to the tool about

00:14:24,730 --> 00:14:33,360
say error messages and more complex

00:14:28,780 --> 00:14:36,540
things so basically the way it works

00:14:33,360 --> 00:14:39,400
this protocol was first implemented in

00:14:36,540 --> 00:14:42,550
vs code but has now been implemented in

00:14:39,400 --> 00:14:46,960
bunch of other ideas too it's placed on

00:14:42,550 --> 00:14:50,020
JSON RPC which is a simple protocol for

00:14:46,960 --> 00:14:55,210
sending messages back and forth using

00:14:50,020 --> 00:14:56,950
JSON and you start with the ID notifying

00:14:55,210 --> 00:14:59,170
the language server anytime that some

00:14:56,950 --> 00:15:02,410
user action like pressing go to

00:14:59,170 --> 00:15:04,540
definition if a language Java has to

00:15:02,410 --> 00:15:06,760
maintain some internal representation of

00:15:04,540 --> 00:15:08,680
all the cult so it knows what it means

00:15:06,760 --> 00:15:11,710
when the users first go to definition

00:15:08,680 --> 00:15:14,040
and it's also responsible for telling

00:15:11,710 --> 00:15:17,440
the ideas about warnings and errors and

00:15:14,040 --> 00:15:19,089
the IDE can send requests usually it's

00:15:17,440 --> 00:15:22,170
what the user which is triggering the

00:15:19,089 --> 00:15:26,320
request like say I want to rename this

00:15:22,170 --> 00:15:28,360
thing to some other thing and it's

00:15:26,320 --> 00:15:30,610
completely asynchronous and consider by

00:15:28,360 --> 00:15:35,350
which means that anything that can

00:15:30,610 --> 00:15:36,019
happen can be stopped and that the UI of

00:15:35,350 --> 00:15:37,910
the ID

00:15:36,019 --> 00:15:39,350
does not have to freeze every time the

00:15:37,910 --> 00:15:41,689
compiler is trying to type check

00:15:39,350 --> 00:15:45,170
something because it doesn't have to

00:15:41,689 --> 00:15:54,799
wait for response from the protocol to

00:15:45,170 --> 00:15:59,360
continue working so how do we implement

00:15:54,799 --> 00:16:01,730
a language server for dotty well it's

00:15:59,360 --> 00:16:03,949
pretty easy because all the low-level

00:16:01,730 --> 00:16:08,019
handling can already be handled using

00:16:03,949 --> 00:16:12,350
the asp forge a library which was

00:16:08,019 --> 00:16:16,339
implemented for eclipse but what we can

00:16:12,350 --> 00:16:17,839
reuse and all the interaction with the

00:16:16,339 --> 00:16:20,209
compiler can be done using the

00:16:17,839 --> 00:16:21,769
interactive API is we discussed in the

00:16:20,209 --> 00:16:25,129
previous sections which means that in

00:16:21,769 --> 00:16:28,549
the end it's only a few hundred lines of

00:16:25,129 --> 00:16:30,199
code to implement VMware server and just

00:16:28,549 --> 00:16:34,420
to show that was basically no trick to

00:16:30,199 --> 00:16:37,160
it I can show you how the definition

00:16:34,420 --> 00:16:40,160
method works so this is responsible for

00:16:37,160 --> 00:16:43,249
doing go to definition every time the

00:16:40,160 --> 00:16:46,160
user press go to definition we're going

00:16:43,249 --> 00:16:48,049
to get have this method called and while

00:16:46,160 --> 00:16:53,480
only job as very own web server is to

00:16:48,049 --> 00:16:55,670
implement it so input we get parameters

00:16:53,480 --> 00:16:58,519
which are just the position of the

00:16:55,670 --> 00:17:04,130
cursor when the user asked to go to

00:16:58,519 --> 00:17:07,240
definition and the way it works in SP 4j

00:17:04,130 --> 00:17:11,809
is that you return computable future

00:17:07,240 --> 00:17:14,270
which takes some token for consideration

00:17:11,809 --> 00:17:17,600
that you can use to check if user

00:17:14,270 --> 00:17:21,380
interrupted the request but that's not

00:17:17,600 --> 00:17:24,139
super important so you get both URI for

00:17:21,380 --> 00:17:28,029
the document which tells you which file

00:17:24,139 --> 00:17:32,270
the user has go to definition in and a

00:17:28,029 --> 00:17:35,270
position and based on these two things

00:17:32,270 --> 00:17:37,130
you can figure out which compiler to use

00:17:35,270 --> 00:17:39,049
for this particular document because

00:17:37,130 --> 00:17:41,240
usually in a big project we're going to

00:17:39,049 --> 00:17:44,000
have multiple sub comparing us because

00:17:41,240 --> 00:17:45,380
you're going to have the source project

00:17:44,000 --> 00:17:47,480
and at this project they're going to

00:17:45,380 --> 00:17:49,730
have different class path so you need to

00:17:47,480 --> 00:17:53,360
know which compared to use to get the

00:17:49,730 --> 00:17:55,730
trespass once you do that we can just

00:17:53,360 --> 00:17:59,150
query trees using the interactive API as

00:17:55,730 --> 00:18:03,230
I talked about order to get the symbol

00:17:59,150 --> 00:18:07,640
that corresponds to the position the

00:18:03,230 --> 00:18:10,910
user is at and then we can based on

00:18:07,640 --> 00:18:13,160
write get the tree where the symbol is

00:18:10,910 --> 00:18:15,890
defined so the creature a low class and

00:18:13,160 --> 00:18:22,520
when 12 is 3 to find where the

00:18:15,890 --> 00:18:25,220
definition of the symbol is and then we

00:18:22,520 --> 00:18:28,480
just have to do some mapping right back

00:18:25,220 --> 00:18:29,720
to something the LSP 4jp I understand

00:18:28,480 --> 00:18:33,200
all right

00:18:29,720 --> 00:18:37,730
so last design principle how do we make

00:18:33,200 --> 00:18:41,390
this easy to use and the way it works

00:18:37,730 --> 00:18:42,919
right now is we have V dot e SBT plug-in

00:18:41,390 --> 00:18:46,160
that you have to use any way to use that

00:18:42,919 --> 00:18:50,780
he also is responsible for IDE

00:18:46,160 --> 00:18:53,600
integration and it's job is just to look

00:18:50,780 --> 00:18:56,900
at ROI SBT build find all your dirty

00:18:53,600 --> 00:18:58,520
projects compare Eva's projects generate

00:18:56,900 --> 00:18:59,080
configuration files based on this

00:18:58,520 --> 00:19:02,900
project

00:18:59,080 --> 00:19:06,169
install the vs curl extension then you

00:19:02,900 --> 00:19:08,059
on V s code so what kind of

00:19:06,169 --> 00:19:11,120
configuration files do we generate so

00:19:08,059 --> 00:19:13,100
there's basically two things first when

00:19:11,120 --> 00:19:15,200
vs code is started it has no idea which

00:19:13,100 --> 00:19:16,490
version of dot e you're using how to

00:19:15,200 --> 00:19:19,970
start the run whatever

00:19:16,490 --> 00:19:22,220
so we just give it a name of the

00:19:19,970 --> 00:19:26,270
artifact on maven and then we use cross

00:19:22,220 --> 00:19:28,280
here to fetch this thing and uncivil and

00:19:26,270 --> 00:19:31,100
which other has started it needs to know

00:19:28,280 --> 00:19:34,400
all your sub projects and all the class

00:19:31,100 --> 00:19:36,770
path so he have JSON file which say for

00:19:34,400 --> 00:19:38,960
all your projects which compare version

00:19:36,770 --> 00:19:43,100
you're using what flux to pass to the

00:19:38,960 --> 00:19:44,240
compiler which directories contain use

00:19:43,100 --> 00:19:45,710
babies project

00:19:44,240 --> 00:19:48,620
what's your class path for for your

00:19:45,710 --> 00:19:54,740
dependencies and where the output of

00:19:48,620 --> 00:19:57,770
this project resides and so this works

00:19:54,740 --> 00:19:59,450
pretty well but the main issue is that

00:19:57,770 --> 00:20:01,250
we have to generate these files and

00:19:59,450 --> 00:20:02,310
every time you change something in your

00:20:01,250 --> 00:20:04,070
build

00:20:02,310 --> 00:20:06,810
you have to regenerate these files so

00:20:04,070 --> 00:20:10,350
that's why we tell people to start

00:20:06,810 --> 00:20:10,980
obvious code using SBT and not the other

00:20:10,350 --> 00:20:12,450
way around

00:20:10,980 --> 00:20:14,130
because that way we can be sure that

00:20:12,450 --> 00:20:17,520
these files are up to date but that's

00:20:14,130 --> 00:20:20,970
not really practical so what we really

00:20:17,520 --> 00:20:23,010
want is some way to query the big tree

00:20:20,970 --> 00:20:25,790
to get all this information at one time

00:20:23,010 --> 00:20:27,930
instead of having to have a compiler

00:20:25,790 --> 00:20:32,190
plug-in for the build tool to get this

00:20:27,930 --> 00:20:34,620
information and yesterday there was a

00:20:32,190 --> 00:20:37,050
token to the build server protocol but

00:20:34,620 --> 00:20:40,140
is trying to solve this problem among

00:20:37,050 --> 00:20:42,150
others and just recap basically the idea

00:20:40,140 --> 00:20:43,530
is instead of having to make plug-ins

00:20:42,150 --> 00:20:45,840
for build tools to extract information

00:20:43,530 --> 00:20:48,120
we can just ask them the same way we

00:20:45,840 --> 00:20:50,010
have a language server protocol to ask

00:20:48,120 --> 00:20:52,770
the compiler hey how do I go to

00:20:50,010 --> 00:20:55,190
definition we should have a build server

00:20:52,770 --> 00:20:57,810
protocol to ask you build whoo hey

00:20:55,190 --> 00:20:59,820
what's the list of projects that compile

00:20:57,810 --> 00:21:01,410
with dotty and what compare flags do

00:20:59,820 --> 00:21:05,550
they have and what class path do they

00:21:01,410 --> 00:21:08,040
have and once we have this thing it's

00:21:05,550 --> 00:21:09,840
even better than using plugins because

00:21:08,040 --> 00:21:11,880
it means that it should work for any

00:21:09,840 --> 00:21:17,190
build tool that implements the protocol

00:21:11,880 --> 00:21:18,930
and not just SVT and there's one other

00:21:17,190 --> 00:21:20,760
missing piece of the puzzle which is

00:21:18,930 --> 00:21:23,610
some kind of discovery protocol because

00:21:20,760 --> 00:21:25,710
basically the end goal is what the user

00:21:23,610 --> 00:21:29,580
experience is just you start your ID

00:21:25,710 --> 00:21:32,910
whatever ID it is and if you install on

00:21:29,580 --> 00:21:35,370
your IDE marketplace we plug in 4 for

00:21:32,910 --> 00:21:37,230
Scala and then it's automatically if he

00:21:35,370 --> 00:21:39,090
goes out everything which means it need

00:21:37,230 --> 00:21:41,160
to figure out how to start the build

00:21:39,090 --> 00:21:42,750
server for this project so there needs

00:21:41,160 --> 00:21:45,120
to be some kind of discovery protocol

00:21:42,750 --> 00:21:47,730
which doesn't exist yet probably some

00:21:45,120 --> 00:21:49,470
kind of file in your project that says

00:21:47,730 --> 00:21:52,100
this is a command line to start the

00:21:49,470 --> 00:21:57,150
bridge server photogra

00:21:52,100 --> 00:22:00,030
all right so to recap as our design

00:21:57,150 --> 00:22:03,300
principles and how we achieve them so we

00:22:00,030 --> 00:22:05,010
achieve code reuse by implementing API

00:22:03,300 --> 00:22:09,300
is for interactive usage which are not

00:22:05,010 --> 00:22:12,330
specific to any IDE or any specific tool

00:22:09,300 --> 00:22:14,820
and can be already used both by the IDE

00:22:12,330 --> 00:22:17,159
and the wrapper

00:22:14,820 --> 00:22:20,789
we achieve a dog necessity by

00:22:17,159 --> 00:22:24,059
implementing the LSP and we achieved

00:22:20,789 --> 00:22:25,830
easy ease of use using an SBT plug-in

00:22:24,059 --> 00:22:27,779
that basically reduces everything to one

00:22:25,830 --> 00:22:32,299
comment but we can do better we can do

00:22:27,779 --> 00:22:35,039
zero comment hopefully to go further

00:22:32,299 --> 00:22:36,990
there's one over a missing piece of the

00:22:35,039 --> 00:22:40,980
puzzle which is well how do you do bugs

00:22:36,990 --> 00:22:42,600
stuff and if you followed the trends so

00:22:40,980 --> 00:22:44,490
far you can probably guess what's going

00:22:42,600 --> 00:22:53,309
to happen there's a debug server

00:22:44,490 --> 00:22:56,429
protocol so the JVM has a very complete

00:22:53,309 --> 00:23:00,029
API for debugging called JDI the Java

00:22:56,429 --> 00:23:02,700
debug interface and that's how all

00:23:00,029 --> 00:23:04,679
debuggers for Java are implemented and

00:23:02,700 --> 00:23:08,130
we are in luck because resolve a Java

00:23:04,679 --> 00:23:12,690
debug server for that implements with

00:23:08,130 --> 00:23:15,330
debug protocol so as ot compares to Java

00:23:12,690 --> 00:23:19,080
bytecode we can just reuse that and most

00:23:15,330 --> 00:23:22,080
thing just work for I haven't actually

00:23:19,080 --> 00:23:24,600
melted is in dot e yet but was one thing

00:23:22,080 --> 00:23:30,950
which is non trivial to implement and

00:23:24,600 --> 00:23:30,950
what's expression evaluation so

00:23:36,630 --> 00:23:41,880
imagine you're in your debugger trying

00:23:39,480 --> 00:23:44,820
to debug some really simple card here we

00:23:41,880 --> 00:23:46,830
have a class with two methods and you

00:23:44,820 --> 00:23:50,880
put a breakpoint here so now the flag

00:23:46,830 --> 00:23:53,340
means breakpoints and now you want to

00:23:50,880 --> 00:23:55,590
execute food because you're in the

00:23:53,340 --> 00:23:57,150
bigger and the bigger you are used to

00:23:55,590 --> 00:24:01,200
being able to evaluate expression but

00:23:57,150 --> 00:24:04,020
how do you do that because foo takes

00:24:01,200 --> 00:24:05,640
some implicit parameter and we are not

00:24:04,020 --> 00:24:07,860
in the compiler here we're just in or

00:24:05,640 --> 00:24:11,820
debugger and somehow we have to tell the

00:24:07,860 --> 00:24:16,230
debugger how to run this poofing so

00:24:11,820 --> 00:24:17,669
that's that's not trivial and the first

00:24:16,230 --> 00:24:20,280
thing we can do is just well okay let's

00:24:17,669 --> 00:24:22,740
try just to run the compiler so if we

00:24:20,280 --> 00:24:24,419
run the compiler at the end of a

00:24:22,740 --> 00:24:27,059
comparable pipeline basically foo has

00:24:24,419 --> 00:24:30,570
been replaced by this dot foo of why

00:24:27,059 --> 00:24:34,140
because implicit has been resolved but

00:24:30,570 --> 00:24:37,799
then what do you do with this it's some

00:24:34,140 --> 00:24:40,740
card in some method somewhere so based

00:24:37,799 --> 00:24:42,450
on the position of this thing we can add

00:24:40,740 --> 00:24:45,150
a face to the compiler which is only

00:24:42,450 --> 00:24:46,860
used for expression evaluation in the

00:24:45,150 --> 00:24:49,890
debugger and what face is going to

00:24:46,860 --> 00:24:52,140
extract the code that you want to

00:24:49,890 --> 00:24:56,010
evaluate in your debugger into a static

00:24:52,140 --> 00:24:58,650
method so why is this useful because

00:24:56,010 --> 00:25:00,660
unsure have static methods if you can

00:24:58,650 --> 00:25:03,720
compile it to some class file and run

00:25:00,660 --> 00:25:08,580
with classifier on the JVM you can just

00:25:03,720 --> 00:25:09,360
say call this method to your debugger so

00:25:08,580 --> 00:25:12,350
of course things are a bit more

00:25:09,360 --> 00:25:15,450
complicated than that because here or

00:25:12,350 --> 00:25:18,600
static method takes parameters which

00:25:15,450 --> 00:25:21,090
correspond to things which were local

00:25:18,600 --> 00:25:25,440
variables on the stack when you called

00:25:21,090 --> 00:25:27,660
foo but you don't have this information

00:25:25,440 --> 00:25:30,540
directly when you're in the debugger so

00:25:27,660 --> 00:25:32,100
you need to mangle things a bit because

00:25:30,540 --> 00:25:36,030
we only information you're going to get

00:25:32,100 --> 00:25:38,520
from the debugger is you have this self

00:25:36,030 --> 00:25:40,679
which is the current class you're in in

00:25:38,520 --> 00:25:43,200
the debugger and you have a list of

00:25:40,679 --> 00:25:45,059
local variables which we can represent

00:25:43,200 --> 00:25:49,320
as a map from the name of a local

00:25:45,059 --> 00:25:54,720
variable at one time and its value

00:25:49,320 --> 00:25:57,910
all right so we are on the debugging VN

00:25:54,720 --> 00:26:00,430
so there's two VMs here in as the

00:25:57,910 --> 00:26:01,930
debugger debunked the VM which is the

00:26:00,430 --> 00:26:04,960
one running your program and the

00:26:01,930 --> 00:26:07,180
debugging VM which is the one where you

00:26:04,960 --> 00:26:10,090
type your a expression that you want to

00:26:07,180 --> 00:26:12,550
evaluate and send to the VM which is

00:26:10,090 --> 00:26:14,980
currently stopped at your breakpoint so

00:26:12,550 --> 00:26:18,370
unreadable in VM we can run the compiler

00:26:14,980 --> 00:26:23,380
we can compile global to some classifier

00:26:18,370 --> 00:26:25,810
then we can load it in the debug VM and

00:26:23,380 --> 00:26:28,450
once we've managed to do that then we

00:26:25,810 --> 00:26:31,870
just need to call global that exact with

00:26:28,450 --> 00:26:34,030
the right arguments so to do that we're

00:26:31,870 --> 00:26:36,580
going to cheat a bit and add a magic

00:26:34,030 --> 00:26:40,300
method in the standard library that we

00:26:36,580 --> 00:26:44,410
can use to execute some random class

00:26:40,300 --> 00:26:46,330
file on some random class path which is

00:26:44,410 --> 00:26:50,230
just going to look for this classifier

00:26:46,330 --> 00:26:52,450
and call the exact method once we do

00:26:50,230 --> 00:26:55,030
that on the debugging VM basically all

00:26:52,450 --> 00:26:58,650
we have to do is find the class before

00:26:55,030 --> 00:27:01,810
the global class we just created find

00:26:58,650 --> 00:27:05,260
ourself and our list of local variables

00:27:01,810 --> 00:27:07,960
and then do a remote call but sends to

00:27:05,260 --> 00:27:11,260
the remote VM and tells it call these

00:27:07,960 --> 00:27:13,240
methods with as parameters and this is

00:27:11,260 --> 00:27:16,180
pretty horrible to do because with JDI

00:27:13,240 --> 00:27:19,870
API is really low-level but it's

00:27:16,180 --> 00:27:22,440
possible to do and just to prove that it

00:27:19,870 --> 00:27:22,440
actually works

00:27:35,320 --> 00:27:44,530
so this is obvious code running under t

00:27:42,070 --> 00:27:47,350
itself so we're using a compiler to

00:27:44,530 --> 00:27:51,420
compile compiler and now we're going to

00:27:47,350 --> 00:27:51,420
use a compiler to debug a compiler

00:27:54,630 --> 00:28:06,370
okay so has some test case we have some

00:28:01,140 --> 00:28:09,940
object with a vial of type any and it's

00:28:06,370 --> 00:28:11,920
right hand side is 42 and what kind of

00:28:09,940 --> 00:28:16,900
curious of how does this get compiled

00:28:11,920 --> 00:28:22,510
because any gets arise to object but 42

00:28:16,900 --> 00:28:25,780
is an int + int is not an object and if

00:28:22,510 --> 00:28:27,070
you look into this you'll probably find

00:28:25,780 --> 00:28:28,510
that there's something called boxing

00:28:27,070 --> 00:28:33,130
value compare does where it's going to

00:28:28,510 --> 00:28:36,970
wrap your int into an a Java long

00:28:33,130 --> 00:28:39,060
integer and 20,000 how this works you

00:28:36,970 --> 00:28:45,610
can put a breakpoint as a breakpoint

00:28:39,060 --> 00:28:50,830
unbox and then run it to run it we use

00:28:45,610 --> 00:28:54,280
the debugger interface of vs code where

00:28:50,830 --> 00:28:56,890
we've set things up using launched the

00:28:54,280 --> 00:28:59,920
JSON file which basically tells you I

00:28:56,890 --> 00:29:01,930
want to run this main class in this

00:28:59,920 --> 00:29:05,760
project the project name give you the

00:29:01,930 --> 00:29:09,940
class path using various arguments

00:29:05,760 --> 00:29:12,360
alright so I press f5 that starts with

00:29:09,940 --> 00:29:12,360
debugger

00:29:15,630 --> 00:29:21,010
all right so the DVR stopped and already

00:29:19,029 --> 00:29:22,750
we get a lot of things for free just

00:29:21,010 --> 00:29:25,990
thanks to the Java debug server

00:29:22,750 --> 00:29:28,570
implementation we get a list of local

00:29:25,990 --> 00:29:31,090
variables and go inside with local

00:29:28,570 --> 00:29:36,370
variables to get the fields inside all

00:29:31,090 --> 00:29:39,100
these things we have a core stack and we

00:29:36,370 --> 00:29:41,049
can even like hover other things and if

00:29:39,100 --> 00:29:48,429
they're on the list of rocker valve as

00:29:41,049 --> 00:29:50,200
you can see inside them I could now

00:29:48,429 --> 00:29:55,840
here's where it gets interesting

00:29:50,200 --> 00:29:58,690
so I can send expression from my

00:29:55,840 --> 00:30:04,179
debugging VM to the debug VM so if I

00:29:58,690 --> 00:30:09,429
just sentry I get back the value of 3

00:30:04,179 --> 00:30:12,250
and here we are going we are doing a

00:30:09,429 --> 00:30:15,250
pattern matching on three dot c p dot

00:30:12,250 --> 00:30:17,070
widen so I can try to find the value of

00:30:15,250 --> 00:30:20,789
that thing

00:30:17,070 --> 00:30:20,789
and print it

00:30:26,210 --> 00:30:32,480
yes so it's value is this fing type

00:30:30,960 --> 00:30:36,090
right for this type of type life

00:30:32,480 --> 00:30:38,309
somewhere in visual arts int so if

00:30:36,090 --> 00:30:40,740
you're not used to have compared works

00:30:38,309 --> 00:30:42,029
that's not very enlightening but

00:30:40,740 --> 00:30:44,580
thankfully was something called show

00:30:42,029 --> 00:30:46,950
which basically pretty print is back to

00:30:44,580 --> 00:30:50,220
what you'd see as a user in error

00:30:46,950 --> 00:30:54,149
messages or in source code but show

00:30:50,220 --> 00:30:56,250
takes an implicit context argument but

00:30:54,149 --> 00:30:57,539
since I'm lazy I don't want to pass by

00:30:56,250 --> 00:31:01,490
implicit context by hand

00:30:57,539 --> 00:31:01,490
so I want to let the compiler do that

00:31:30,850 --> 00:31:37,340
okay so mmm think the output is wrong

00:31:35,360 --> 00:31:42,289
here but basically what's happening

00:31:37,340 --> 00:31:45,710
usually is you things work out and the

00:31:42,289 --> 00:31:48,440
show method ends up being able to figure

00:31:45,710 --> 00:31:50,120
out but it has to take this context here

00:31:48,440 --> 00:31:55,070
because it's in your list of record

00:31:50,120 --> 00:32:00,909
variables and magically you get back the

00:31:55,070 --> 00:32:06,429
tree the properly pretty printed value

00:32:00,909 --> 00:32:06,429
of course we can step over by others and

00:32:07,389 --> 00:32:19,210
see at every point how things work all

00:32:10,460 --> 00:32:19,210
right let's get back to presentation

00:32:20,679 --> 00:32:28,909
okay so this all seems cool but are

00:32:24,980 --> 00:32:32,630
there any catch and yes the magic catch

00:32:28,909 --> 00:32:35,809
is in some cases the things which are in

00:32:32,630 --> 00:32:37,519
scope when you compile your cards do not

00:32:35,809 --> 00:32:40,760
match exactly the things we trying to

00:32:37,519 --> 00:32:43,820
cut when you run your cards and the main

00:32:40,760 --> 00:32:48,860
point where this happens is when you

00:32:43,820 --> 00:32:52,279
have an inner method in some in some

00:32:48,860 --> 00:32:55,909
method and you try to call a parameter

00:32:52,279 --> 00:32:59,330
of the outer methods and the way in our

00:32:55,909 --> 00:33:04,419
methods are compiling in Scala is they

00:32:59,330 --> 00:33:06,950
get promoted to just methods of a class

00:33:04,419 --> 00:33:09,440
but will take extra arguments which

00:33:06,950 --> 00:33:15,350
correspond to the arguments inside the

00:33:09,440 --> 00:33:18,260
class but you you use inside the inner

00:33:15,350 --> 00:33:20,750
method and the issue with this is that

00:33:18,260 --> 00:33:23,090
if you have an inner method but does

00:33:20,750 --> 00:33:25,220
that use parameter from the outer may

00:33:23,090 --> 00:33:27,260
fund because you don't need it and then

00:33:25,220 --> 00:33:29,600
you in the debugger inside the inner

00:33:27,260 --> 00:33:31,490
method and you try to use one of these

00:33:29,600 --> 00:33:34,370
parameters it's just not going to be

00:33:31,490 --> 00:33:35,510
accessible because when what methods was

00:33:34,370 --> 00:33:37,580
promoted to

00:33:35,510 --> 00:33:40,720
and effort of a class we didn't pass it

00:33:37,580 --> 00:33:43,310
the parameters that he did not need and

00:33:40,720 --> 00:33:44,480
we could generate in the compiler but

00:33:43,310 --> 00:33:47,270
that's not something you want to do by

00:33:44,480 --> 00:33:50,660
default because if you capture too much

00:33:47,270 --> 00:33:54,650
things in your inner method then you

00:33:50,660 --> 00:33:57,440
might leak things if you stop this in

00:33:54,650 --> 00:34:00,950
the closure that is when sent to start

00:33:57,440 --> 00:34:06,130
somewhere else but other than that most

00:34:00,950 --> 00:34:10,330
things should work so future work

00:34:06,130 --> 00:34:13,400
basically we want to do some

00:34:10,330 --> 00:34:15,290
optimizations like I said right now

00:34:13,400 --> 00:34:16,910
every time you press it the keystroke in

00:34:15,290 --> 00:34:20,450
your IDE we're going to recompile

00:34:16,910 --> 00:34:23,450
everything in the current file we could

00:34:20,450 --> 00:34:26,180
try to do less of that and just we

00:34:23,450 --> 00:34:29,950
compile things that have changed and we

00:34:26,180 --> 00:34:33,260
want more features of course like

00:34:29,950 --> 00:34:34,670
documentation and hover because the

00:34:33,260 --> 00:34:37,850
communication is important to show to

00:34:34,670 --> 00:34:39,920
users of course and we can't do that yet

00:34:37,850 --> 00:34:42,170
because testy does not store

00:34:39,920 --> 00:34:44,330
documentation information but we're

00:34:42,170 --> 00:34:46,840
working on changing that and once we do

00:34:44,330 --> 00:34:55,190
that we get other things for free like

00:34:46,840 --> 00:34:57,890
possibility to do to do incremental

00:34:55,190 --> 00:35:00,380
generation of the documentation because

00:34:57,890 --> 00:35:02,180
instead of starting from soft sides and

00:35:00,380 --> 00:35:04,160
generating documentation we can start

00:35:02,180 --> 00:35:08,230
from tasty and generate documentation

00:35:04,160 --> 00:35:12,020
and we also get make it very easy to

00:35:08,230 --> 00:35:15,590
display the documentation inside the

00:35:12,020 --> 00:35:17,750
wrapper for example and of course better

00:35:15,590 --> 00:35:22,400
built for integration using hopefully

00:35:17,750 --> 00:35:24,830
the bits of a protocol so to conclude I

00:35:22,400 --> 00:35:26,630
think it's important to have

00:35:24,830 --> 00:35:29,510
interactivity in mind when designing a

00:35:26,630 --> 00:35:32,210
compiler because we have lots of little

00:35:29,510 --> 00:35:35,660
things that matter for example when

00:35:32,210 --> 00:35:37,010
you're in one ID you're going to most

00:35:35,660 --> 00:35:38,750
the time the code you're going to write

00:35:37,010 --> 00:35:40,550
is not going to compile or even type

00:35:38,750 --> 00:35:43,670
check because it was going to be syntax

00:35:40,550 --> 00:35:46,040
errors but you still want things that go

00:35:43,670 --> 00:35:47,900
to definition to work more or less

00:35:46,040 --> 00:35:48,559
reliable which means you need your

00:35:47,900 --> 00:35:50,749
password to

00:35:48,559 --> 00:35:54,969
be tolerant to arrows and recover from

00:35:50,749 --> 00:35:58,640
this arrows and when you stole things

00:35:54,969 --> 00:36:00,549
your trees like in the tasty format you

00:35:58,640 --> 00:36:02,539
also need to think about interactivity

00:36:00,549 --> 00:36:04,999
because if you want features like

00:36:02,539 --> 00:36:07,309
renaming to work you need to start

00:36:04,999 --> 00:36:07,969
positions of all your tree nodes very

00:36:07,309 --> 00:36:10,039
precisely

00:36:07,969 --> 00:36:13,160
otherwise you're renaming is not being

00:36:10,039 --> 00:36:16,489
going to be able to infuse which part of

00:36:13,160 --> 00:36:17,989
Lucca needs to be renamed how we also

00:36:16,489 --> 00:36:20,539
need to design your beetle with

00:36:17,989 --> 00:36:23,449
interactive use cases in mind otherwise

00:36:20,539 --> 00:36:25,039
you end up in situations where like we

00:36:23,449 --> 00:36:27,349
have right now in this collector system

00:36:25,039 --> 00:36:29,509
where it's really hard and everyone has

00:36:27,349 --> 00:36:31,459
to invent basically plugins for other

00:36:29,509 --> 00:36:35,599
Bluetooth they want to support to be

00:36:31,459 --> 00:36:38,390
able to use them in ideas and hopefully

00:36:35,599 --> 00:36:42,160
we can get interactivity to go beyond

00:36:38,390 --> 00:36:46,549
what ideas and reports currently have in

00:36:42,160 --> 00:36:49,039
Scala which is mostly limited by having

00:36:46,549 --> 00:36:51,289
to solve the same basic problems a lot

00:36:49,039 --> 00:36:52,849
over and over again and freely we can

00:36:51,289 --> 00:36:54,380
avoid that now that we have building

00:36:52,849 --> 00:36:57,969
blocks like the language server protocol

00:36:54,380 --> 00:37:00,259
that take care of little details for us

00:36:57,969 --> 00:37:02,779
and I think one good source of

00:37:00,259 --> 00:37:05,390
inspiration is the work done in

00:37:02,779 --> 00:37:06,739
interests so there's this whole book by

00:37:05,390 --> 00:37:10,369
Edwin Brady called time driven

00:37:06,739 --> 00:37:11,900
development with Idris which gives I

00:37:10,369 --> 00:37:14,289
think some good hints on the kind of

00:37:11,900 --> 00:37:17,119
things we could do if we focused more on

00:37:14,289 --> 00:37:22,749
doing improving the user experience of

00:37:17,119 --> 00:37:22,749
ideas thank you very much

00:37:23,010 --> 00:37:30,130
[Applause]

00:37:25,600 --> 00:37:36,960
thank you very much your mum do you have

00:37:30,130 --> 00:37:36,960
any questions yeah

00:37:44,020 --> 00:37:49,730
where the language server will live in

00:37:47,570 --> 00:37:52,580
the end so we'll be a part of compiler

00:37:49,730 --> 00:37:54,470
or a part of SBT or some standalone

00:37:52,580 --> 00:37:59,000
process that will somehow integrate with

00:37:54,470 --> 00:38:02,810
SBT so the language server right now in

00:37:59,000 --> 00:38:05,210
that he is a separate sub project which

00:38:02,810 --> 00:38:07,220
lives in the git repository of a

00:38:05,210 --> 00:38:12,140
compiler and depends on the compiler I

00:38:07,220 --> 00:38:14,330
think is going to stay that way and the

00:38:12,140 --> 00:38:17,920
main question is how do you get this

00:38:14,330 --> 00:38:21,050
thing and the way it should work is

00:38:17,920 --> 00:38:24,500
basically in your favorite IDE you

00:38:21,050 --> 00:38:27,290
install the plugin for Scala and when

00:38:24,500 --> 00:38:29,600
the plug-in itself finds and resolves

00:38:27,290 --> 00:38:33,380
the compiler from maven using for

00:38:29,600 --> 00:38:41,270
example across here to fetch the jar and

00:38:33,380 --> 00:38:43,850
all its dependencies and start it but in

00:38:41,270 --> 00:38:46,850
this situation how will example SBT

00:38:43,850 --> 00:38:50,330
console and idea coexist they need to

00:38:46,850 --> 00:38:53,480
talk to the same servers all right so

00:38:50,330 --> 00:38:55,670
the SBT itself does not really need to

00:38:53,480 --> 00:38:57,560
talk to the language server because well

00:38:55,670 --> 00:38:59,030
as we teased with all your beta is the

00:38:57,560 --> 00:39:03,320
source of truth for how to compile

00:38:59,030 --> 00:39:05,690
things and then both the language server

00:39:03,320 --> 00:39:07,880
and other users like SBT console are

00:39:05,690 --> 00:39:11,060
going to ask the source of traffic like

00:39:07,880 --> 00:39:12,950
what's the Casper for this thing so

00:39:11,060 --> 00:39:16,900
that's what the bits have a protocol is

00:39:12,950 --> 00:39:20,180
about and the language server has to

00:39:16,900 --> 00:39:24,070
query the build tool about well how do I

00:39:20,180 --> 00:39:26,870
compare this thing and the both the

00:39:24,070 --> 00:39:28,460
Advanta bit we is responsible for making

00:39:26,870 --> 00:39:30,110
sure that if you have at the same time

00:39:28,460 --> 00:39:32,960
some console running or some other

00:39:30,110 --> 00:39:36,110
computation running and the ID asked for

00:39:32,960 --> 00:39:37,730
compilation things work out and you

00:39:36,110 --> 00:39:40,630
don't get conflicts or you didn't get

00:39:37,730 --> 00:39:40,630
everything to freeze

00:39:41,990 --> 00:39:49,310
any more questions now No then thank you

00:39:48,650 --> 00:39:50,980
very much again

00:39:49,310 --> 00:39:54,809
oh thanks

00:39:50,980 --> 00:39:54,809

YouTube URL: https://www.youtube.com/watch?v=pG-kWWM_qco


