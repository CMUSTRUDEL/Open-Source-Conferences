Title: Keynote: Functionalist programming language design by Tomas Petricek
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-7037-keynote%3A-functionalist-programming-language-design.html
Captions: 
	00:00:08,590 --> 00:00:13,520
thanks for the introduction thank you

00:00:10,820 --> 00:00:15,709
for the welcome so I was I was thinking

00:00:13,520 --> 00:00:21,169
what what can i what can I talk about

00:00:15,709 --> 00:00:24,380
and the idea behind this talk is to sort

00:00:21,169 --> 00:00:26,570
of say functional programming but

00:00:24,380 --> 00:00:28,910
interpret it in slightly different way

00:00:26,570 --> 00:00:30,829
so it's what what would what would

00:00:28,910 --> 00:00:34,160
functional programming be in an

00:00:30,829 --> 00:00:35,960
alternative universe and if I just

00:00:34,160 --> 00:00:37,790
called the talk functional programming

00:00:35,960 --> 00:00:39,559
well then first of all they would

00:00:37,790 --> 00:00:41,120
probably tell me that I'm silly because

00:00:39,559 --> 00:00:42,800
what's the point of talking about

00:00:41,120 --> 00:00:46,539
functional programming in front of an

00:00:42,800 --> 00:00:48,920
audience where everyone does it so I

00:00:46,539 --> 00:00:51,949
changed the title to functionalist

00:00:48,920 --> 00:00:53,420
following the sort of name that people

00:00:51,949 --> 00:00:57,829
sometimes use when they talk about

00:00:53,420 --> 00:01:01,850
functionalist architecture my name is

00:00:57,829 --> 00:01:04,909
Thomas and I'm sort of double affiliated

00:01:01,850 --> 00:01:08,390
I'm recently started at the University

00:01:04,909 --> 00:01:10,430
of Kent in the UK so my background is

00:01:08,390 --> 00:01:12,230
sort of functional or programming

00:01:10,430 --> 00:01:14,840
language research and I do quite a lot

00:01:12,230 --> 00:01:19,160
of F sharp and I'm part of the F sharp

00:01:14,840 --> 00:01:21,790
Works team so I thought I'd say I'd say

00:01:19,160 --> 00:01:25,010
a few words about about myself because

00:01:21,790 --> 00:01:26,750
somehow I got invited here which is very

00:01:25,010 --> 00:01:28,520
nice and I've been sort of following

00:01:26,750 --> 00:01:30,860
some of the interesting things that been

00:01:28,520 --> 00:01:35,090
happening in the Scala world but I'm not

00:01:30,860 --> 00:01:36,980
really a Scala person myself my

00:01:35,090 --> 00:01:39,320
background is I've done quite a lot of

00:01:36,980 --> 00:01:42,350
work on the F sharp programming language

00:01:39,320 --> 00:01:44,960
which is the sort of cousin of Scala in

00:01:42,350 --> 00:01:47,450
the dotnet world and I think yesterday

00:01:44,960 --> 00:01:51,110
Martin said that the Scala is sort of

00:01:47,450 --> 00:01:54,020
taking the merging the object-oriented

00:01:51,110 --> 00:01:55,790
with functional and f-sharp has always

00:01:54,020 --> 00:01:59,000
been merging the functional with

00:01:55,790 --> 00:02:00,920
object-oriented so f sharp sort of tends

00:01:59,000 --> 00:02:04,040
to be a bit more on the on the

00:02:00,920 --> 00:02:06,200
functional first side but otherwise I

00:02:04,040 --> 00:02:10,519
think we have sort of many many common

00:02:06,200 --> 00:02:12,890
and shared shared themes I've done some

00:02:10,519 --> 00:02:17,480
work on something we call theory of COI

00:02:12,890 --> 00:02:19,489
effects which is effects track what your

00:02:17,480 --> 00:02:21,349
program does to the world Co effects

00:02:19,489 --> 00:02:21,950
track what your program requires to the

00:02:21,349 --> 00:02:24,830
world

00:02:21,950 --> 00:02:27,890
you can find it online online there's a

00:02:24,830 --> 00:02:31,250
PDF paper with lots of crazy equations

00:02:27,890 --> 00:02:33,739
in it and I've also been working on on

00:02:31,250 --> 00:02:36,530
type providers which I'll show later on

00:02:33,739 --> 00:02:39,080
and that's a sort of neat way of working

00:02:36,530 --> 00:02:43,340
with data in statically typed function

00:02:39,080 --> 00:02:45,530
languages and I'm sort of on the side

00:02:43,340 --> 00:02:47,330
I'm also interested in in philosophy and

00:02:45,530 --> 00:02:50,180
history of science philosophy and

00:02:47,330 --> 00:02:53,299
history of computing so this talk will

00:02:50,180 --> 00:02:56,209
sort of pick random things from from all

00:02:53,299 --> 00:02:58,310
of those themes I'll say a few things

00:02:56,209 --> 00:03:00,560
about some of the interesting F sharp

00:02:58,310 --> 00:03:02,540
features I'll say a few things about

00:03:00,560 --> 00:03:05,930
type providers because I think that's

00:03:02,540 --> 00:03:09,200
that's one area where I've serve has

00:03:05,930 --> 00:03:12,040
something really neat and I'll link it

00:03:09,200 --> 00:03:15,950
together with sort of more philosophical

00:03:12,040 --> 00:03:18,680
outline so what does functional mean

00:03:15,950 --> 00:03:21,700
when you when you talk to functional

00:03:18,680 --> 00:03:26,000
programmers they'll say well function

00:03:21,700 --> 00:03:30,139
that comes from mathematics and function

00:03:26,000 --> 00:03:33,650
from A to B is an object F such that for

00:03:30,139 --> 00:03:36,560
every a in the input it's uniquely

00:03:33,650 --> 00:03:38,269
associated with some object F of a in

00:03:36,560 --> 00:03:41,480
the end the output so that's a

00:03:38,269 --> 00:03:45,889
mathematical definition I on I stole

00:03:41,480 --> 00:03:48,109
from Wikipedia I think and that's what a

00:03:45,889 --> 00:03:50,150
function is and and so the functional

00:03:48,109 --> 00:03:54,620
programming is really built on this idea

00:03:50,150 --> 00:03:56,690
that we compose functions and so on now

00:03:54,620 --> 00:04:03,670
there's very different way of thinking

00:03:56,690 --> 00:04:03,670
about functions so in in architecture

00:04:04,510 --> 00:04:11,359
Bauhaus is sort of school of thought

00:04:07,910 --> 00:04:14,660
that that really sort of made me popular

00:04:11,359 --> 00:04:17,599
the functionalist architecture where a

00:04:14,660 --> 00:04:20,120
function is is the purpose for which

00:04:17,599 --> 00:04:23,090
something is designed or something

00:04:20,120 --> 00:04:26,120
exists so when they talk about functions

00:04:23,090 --> 00:04:28,570
this is what they mean and I think this

00:04:26,120 --> 00:04:30,650
is actually really sort of a useful

00:04:28,570 --> 00:04:34,479
interpretation and it's useful to think

00:04:30,650 --> 00:04:35,689
about function in this in this sense so

00:04:34,479 --> 00:04:38,119
what

00:04:35,689 --> 00:04:40,789
try to do in the talk is to rethink some

00:04:38,119 --> 00:04:44,329
of the things we say about functional

00:04:40,789 --> 00:04:47,989
programming but thinking more in this in

00:04:44,329 --> 00:04:50,719
this context now you might say well this

00:04:47,989 --> 00:04:53,179
is this is really a way definition and

00:04:50,719 --> 00:04:57,610
function in mathematics is a formal

00:04:53,179 --> 00:05:00,679
precise thing but that's just because

00:04:57,610 --> 00:05:02,329
there's sort of multiple different kinds

00:05:00,679 --> 00:05:04,999
of knowledge so some things you can

00:05:02,329 --> 00:05:07,909
describe precisely mathematically some

00:05:04,999 --> 00:05:10,069
things you just can't so this is as good

00:05:07,909 --> 00:05:14,269
as you can get with with explaining for

00:05:10,069 --> 00:05:17,239
the function in this context means and

00:05:14,269 --> 00:05:18,829
one of the really influential ideas from

00:05:17,239 --> 00:05:20,419
the functionalist or modernist

00:05:18,829 --> 00:05:23,719
architecture is that form follows

00:05:20,419 --> 00:05:26,509
function so once you sort of understand

00:05:23,719 --> 00:05:28,550
what's the purpose of a building or in

00:05:26,509 --> 00:05:32,479
our case a program or programming

00:05:28,550 --> 00:05:34,279
language feature the the way it actually

00:05:32,479 --> 00:05:38,769
looks the way it's sort of implemented

00:05:34,279 --> 00:05:44,059
has to follow that function that purpose

00:05:38,769 --> 00:05:46,659
and I'll have a few examples of that in

00:05:44,059 --> 00:05:49,610
in sort of both programming and

00:05:46,659 --> 00:05:52,699
illustrated by some architecture so even

00:05:49,610 --> 00:05:55,519
if you don't care about about my program

00:05:52,699 --> 00:05:57,619
and code code examples you'll still see

00:05:55,519 --> 00:06:01,999
some pretty buildings in the slide so I

00:05:57,619 --> 00:06:04,999
still get and the first theme I want to

00:06:01,999 --> 00:06:08,509
talk about is transformations so this

00:06:04,999 --> 00:06:10,759
will be something very very basic and in

00:06:08,509 --> 00:06:13,729
functional programming you're very often

00:06:10,759 --> 00:06:16,069
writing some data transformations where

00:06:13,729 --> 00:06:18,860
really the point is to transform one

00:06:16,069 --> 00:06:22,719
value into some other value using a

00:06:18,860 --> 00:06:26,050
series of operations or transformations

00:06:22,719 --> 00:06:30,589
and I'll just give you sort of brief

00:06:26,050 --> 00:06:32,509
example here using F sharp this is not

00:06:30,589 --> 00:06:35,449
this is not really new for anyone

00:06:32,509 --> 00:06:38,989
because I'm sure you're doing the same

00:06:35,449 --> 00:06:41,149
thing all the time so it's more to sort

00:06:38,989 --> 00:06:44,379
of show you what what my environment

00:06:41,149 --> 00:06:48,860
looks like and how I do things here so

00:06:44,379 --> 00:06:49,550
I've got this is running in in visual

00:06:48,860 --> 00:06:51,800
studio

00:06:49,550 --> 00:06:56,030
which is sort of autumn like lightweight

00:06:51,800 --> 00:06:59,120
editor and I'm using io night which is

00:06:56,030 --> 00:07:01,849
an f-sharp plugin for it which actually

00:06:59,120 --> 00:07:04,659
has been built by the community and has

00:07:01,849 --> 00:07:08,270
been maintained by the community and I

00:07:04,659 --> 00:07:12,349
pre-loaded some data here and just to

00:07:08,270 --> 00:07:15,220
show you how however feels this is a

00:07:12,349 --> 00:07:18,229
date this is a sort of data set with

00:07:15,220 --> 00:07:23,270
British Pound to dollar exchange rates

00:07:18,229 --> 00:07:24,949
and f-sharp very very many things in a

00:07:23,270 --> 00:07:26,780
server are written using this pipe

00:07:24,949 --> 00:07:31,639
operator which lets you do

00:07:26,780 --> 00:07:34,940
transformations so I can say things like

00:07:31,639 --> 00:07:37,819
for every price give me the conversion

00:07:34,940 --> 00:07:40,940
rate and I can run it interactively and

00:07:37,819 --> 00:07:45,199
at the bottom you'll see my conversion

00:07:40,940 --> 00:07:52,099
rates I could say things like seek

00:07:45,199 --> 00:07:59,810
filter and check that the date is ah

00:07:52,099 --> 00:08:03,139
what can I do yeah I could I could sort

00:07:59,810 --> 00:08:07,250
of say maybe give me the cases where

00:08:03,139 --> 00:08:10,250
this was more than one point five if

00:08:07,250 --> 00:08:17,719
there are some cases like this and then

00:08:10,250 --> 00:08:21,650
give me the date in a nice short date

00:08:17,719 --> 00:08:23,870
format and if I run it it was never over

00:08:21,650 --> 00:08:27,860
one point five so let's do one point

00:08:23,870 --> 00:08:30,590
four five and then I get a few days here

00:08:27,860 --> 00:08:32,300
now I think one of the really nice

00:08:30,590 --> 00:08:34,099
things that I like about this this way

00:08:32,300 --> 00:08:37,039
of programming is that you're very often

00:08:34,099 --> 00:08:40,070
doing things interactively so I've been

00:08:37,039 --> 00:08:44,230
sort of running some code testing it see

00:08:40,070 --> 00:08:47,660
what I get and you can do quite a lot of

00:08:44,230 --> 00:08:50,660
programming in this style so I have

00:08:47,660 --> 00:08:54,529
slightly longer example where I take the

00:08:50,660 --> 00:08:56,690
take my exchange rate and I'm using a

00:08:54,529 --> 00:08:59,300
function called pairwise which will sort

00:08:56,690 --> 00:09:02,180
of go over the list and give me pairs

00:08:59,300 --> 00:09:03,379
with the previous and the next one so I

00:09:02,180 --> 00:09:07,309
can compare how

00:09:03,379 --> 00:09:09,979
how the price how the exchange rate sort

00:09:07,309 --> 00:09:14,089
of changed between two days and then I'm

00:09:09,979 --> 00:09:18,559
then I'm looking at cases where the

00:09:14,089 --> 00:09:23,409
exchange rate on the day after dropped

00:09:18,559 --> 00:09:26,119
by 0.02 and I get all the dates and

00:09:23,409 --> 00:09:29,359
there's quite a few of those but if I

00:09:26,119 --> 00:09:34,669
change it to say so is there a case

00:09:29,359 --> 00:09:38,179
where it dropped by 0.1 and there is one

00:09:34,669 --> 00:09:43,699
date so I do this just to show you how

00:09:38,179 --> 00:09:45,559
breaks it is a it's a great idea all

00:09:43,699 --> 00:09:49,159
right so this is this just one example

00:09:45,559 --> 00:09:53,659
of working with data and here I was

00:09:49,159 --> 00:09:56,049
using sort of plain plain lists but the

00:09:53,659 --> 00:09:58,609
really nice thing about about the the

00:09:56,049 --> 00:10:01,699
pipe operator and this way of writing

00:09:58,609 --> 00:10:04,489
code is that it really it really works

00:10:01,699 --> 00:10:13,069
on a lot of different things so I've got

00:10:04,489 --> 00:10:14,899
another example here and I'll just show

00:10:13,069 --> 00:10:18,199
you a preview you don't have to see the

00:10:14,899 --> 00:10:20,539
values but this is this is a data frame

00:10:18,199 --> 00:10:24,919
which has lots of different information

00:10:20,539 --> 00:10:27,889
in columns it's like a CSV file with

00:10:24,919 --> 00:10:31,609
some data about Titanic passengers so

00:10:27,889 --> 00:10:33,619
it's sort of typical typical example

00:10:31,609 --> 00:10:40,609
data source that everyone talking about

00:10:33,619 --> 00:10:44,539
data science uses and I can take this

00:10:40,609 --> 00:10:47,929
and do the same sort of transformations

00:10:44,539 --> 00:10:51,169
over not just a list of numbers list of

00:10:47,929 --> 00:10:55,159
values but over an entire entire data

00:10:51,169 --> 00:10:59,209
frame so this is using one library where

00:10:55,159 --> 00:11:01,939
I can say group rows by sex so sex is a

00:10:59,209 --> 00:11:04,669
column defining whether the passenger is

00:11:01,939 --> 00:11:09,769
male or female and then I can do an

00:11:04,669 --> 00:11:12,889
aggregation and here you'll see sort of

00:11:09,769 --> 00:11:15,649
aggregate aggregates over all the

00:11:12,889 --> 00:11:16,980
numerical columns in the data frame so

00:11:15,649 --> 00:11:20,149
with these just

00:11:16,980 --> 00:11:23,970
lines I can say that for example here

00:11:20,149 --> 00:11:29,220
the average age of males passengers and

00:11:23,970 --> 00:11:31,079
female passengers with 30 and 28 and you

00:11:29,220 --> 00:11:34,070
can sort of see how much they paid as

00:11:31,079 --> 00:11:38,370
well not sort of that sort of stuff

00:11:34,070 --> 00:11:40,980
so really the sort of interesting idea

00:11:38,370 --> 00:11:43,620
here is that transformation is such a

00:11:40,980 --> 00:11:46,709
common theme in in functional

00:11:43,620 --> 00:11:49,290
programming and it takes multiple

00:11:46,709 --> 00:11:51,810
different different forms and I think in

00:11:49,290 --> 00:11:53,970
sort of architecture you can see that

00:11:51,810 --> 00:11:57,149
there's there's quite a lot of cases

00:11:53,970 --> 00:12:00,930
where similar form gets repeated over

00:11:57,149 --> 00:12:03,540
and over again so this is this is one

00:12:00,930 --> 00:12:05,610
building in Prague and another another

00:12:03,540 --> 00:12:09,089
building from Czech Republic and they

00:12:05,610 --> 00:12:14,000
both have sort of very simple simple

00:12:09,089 --> 00:12:16,260
shape with sort of regular structure and

00:12:14,000 --> 00:12:19,019
it's it's just repeating the same

00:12:16,260 --> 00:12:22,769
pattern that's very general and works

00:12:19,019 --> 00:12:25,230
works for many many different things now

00:12:22,769 --> 00:12:29,579
the same thing I think applies in in

00:12:25,230 --> 00:12:31,440
functional programming so quite

00:12:29,579 --> 00:12:35,760
different example of what I was showing

00:12:31,440 --> 00:12:39,839
you right now is this little sort of toy

00:12:35,760 --> 00:12:42,839
toy programming environment which runs

00:12:39,839 --> 00:12:46,170
in the browser and you can type things

00:12:42,839 --> 00:12:48,600
like fun dog poop and when it loads if

00:12:46,170 --> 00:12:52,649
it eventually loads it will it will

00:12:48,600 --> 00:12:56,310
render a cube in the in the screen on

00:12:52,649 --> 00:12:58,319
the right now the other thing it it lets

00:12:56,310 --> 00:13:05,670
you is that you can transform those

00:12:58,319 --> 00:13:07,829
shapes and we'll see no I can transform

00:13:05,670 --> 00:13:10,019
shapes maybe I can transform shapes a

00:13:07,829 --> 00:13:14,040
bit later I'll get to transforming

00:13:10,019 --> 00:13:15,930
shapes later on but the idea is I'll

00:13:14,040 --> 00:13:19,980
show you some code sample first and then

00:13:15,930 --> 00:13:24,750
I'll try to see if it works the idea is

00:13:19,980 --> 00:13:27,300
that you can take a shape and make you

00:13:24,750 --> 00:13:30,450
make a cube you transform it you change

00:13:27,300 --> 00:13:36,630
a color you move it and

00:13:30,450 --> 00:13:39,240
ah there it is so I have a cube I'll

00:13:36,630 --> 00:13:48,380
make it bigger and then I can say things

00:13:39,240 --> 00:13:52,620
like change the color of a cube to

00:13:48,380 --> 00:13:54,960
orange and the idea is that the cube is

00:13:52,620 --> 00:13:57,720
just a value some representation of what

00:13:54,960 --> 00:14:02,910
I'm doing and I'm transforming it by

00:13:57,720 --> 00:14:05,160
changing color now you can do more

00:14:02,910 --> 00:14:08,130
things so this is an example where I

00:14:05,160 --> 00:14:11,030
take a cone change the color of a cone

00:14:08,130 --> 00:14:14,190
make it bigger I'll take a cylinder

00:14:11,030 --> 00:14:17,940
change it color scale it to make it

00:14:14,190 --> 00:14:21,180
taller and move it move it in one

00:14:17,940 --> 00:14:25,680
direction and if I run it then I created

00:14:21,180 --> 00:14:29,880
I created a little power and with few

00:14:25,680 --> 00:14:34,200
more lines of code you can create things

00:14:29,880 --> 00:14:36,390
like castles but really the sort of

00:14:34,200 --> 00:14:38,580
interesting point here is that pretty

00:14:36,390 --> 00:14:41,550
much all I'm using like that the core

00:14:38,580 --> 00:14:44,670
thing is just composing functions using

00:14:41,550 --> 00:14:46,950
the pipe operator which passes the thing

00:14:44,670 --> 00:14:51,960
to the left to the thing on the right

00:14:46,950 --> 00:14:54,720
and I think that sort of relates to this

00:14:51,960 --> 00:14:57,800
to this mission of the modernist design

00:14:54,720 --> 00:15:01,140
where a lot of people try to eliminate

00:14:57,800 --> 00:15:04,050
ornaments from architecture so this is a

00:15:01,140 --> 00:15:08,400
this is a how art art deco buildings

00:15:04,050 --> 00:15:10,290
look in in Brussels and you can compare

00:15:08,400 --> 00:15:12,900
it with something like this which is

00:15:10,290 --> 00:15:16,650
really sort of simple simple structure

00:15:12,900 --> 00:15:18,710
just of regular shapes nothing that

00:15:16,650 --> 00:15:21,930
doesn't have to be there isn't there and

00:15:18,710 --> 00:15:24,300
in in programming languages I think this

00:15:21,930 --> 00:15:26,940
relates to this roof elimination of

00:15:24,300 --> 00:15:29,400
keywords where and Martin was saying

00:15:26,940 --> 00:15:32,310
that yesterday that Scala doesn't really

00:15:29,400 --> 00:15:34,500
have that many keywords and it's

00:15:32,310 --> 00:15:36,960
something that F sharp F sharp shares as

00:15:34,500 --> 00:15:39,660
well and when you look at the code that

00:15:36,960 --> 00:15:43,949
I was using for composing these shapes

00:15:39,660 --> 00:15:46,959
it really is all sort of

00:15:43,949 --> 00:15:49,359
functions that are therefore the meaning

00:15:46,959 --> 00:15:55,089
of the program and none of the sort of

00:15:49,359 --> 00:15:58,239
extra infrastructure to do by loops or

00:15:55,089 --> 00:16:01,599
class definitions or type class

00:15:58,239 --> 00:16:03,189
definitions it's really sort of focusing

00:16:01,599 --> 00:16:06,309
on what's the what's the meaning that

00:16:03,189 --> 00:16:08,559
I'm trying to construct here and the the

00:16:06,309 --> 00:16:11,379
fun thing on the on the side is that the

00:16:08,559 --> 00:16:13,329
pipe operator it's really just sort of

00:16:11,379 --> 00:16:13,749
an operator that takes the thing on the

00:16:13,329 --> 00:16:16,179
Left

00:16:13,749 --> 00:16:18,849
passes it to the thing on the right and

00:16:16,179 --> 00:16:21,249
it's um it's probably going to be one of

00:16:18,849 --> 00:16:22,869
the major major contributions of the F

00:16:21,249 --> 00:16:25,659
sharp language to the programming

00:16:22,869 --> 00:16:27,819
universe because it's now appearing in

00:16:25,659 --> 00:16:30,459
our I think there's a proposal to add it

00:16:27,819 --> 00:16:33,939
to JavaScript and in F sharp you can

00:16:30,459 --> 00:16:36,909
define it like this so this is some sort

00:16:33,939 --> 00:16:38,949
of I think nine characters of F sharp

00:16:36,909 --> 00:16:42,789
that actually people are interested

00:16:38,949 --> 00:16:46,569
outside of the observe community so this

00:16:42,789 --> 00:16:49,419
has define a pipe operator that takes X

00:16:46,569 --> 00:16:51,549
and F X is some input F is some

00:16:49,419 --> 00:16:55,389
functions and it calls the function on

00:16:51,549 --> 00:16:57,939
the input so this is one one interesting

00:16:55,389 --> 00:17:01,209
example one interesting thing coming

00:16:57,939 --> 00:17:08,649
from F sharp the other thing I want to

00:17:01,209 --> 00:17:10,749
talk about these tie providers and tie

00:17:08,649 --> 00:17:13,689
providers and that sharp really appeared

00:17:10,749 --> 00:17:15,909
for this sort of the function here is

00:17:13,689 --> 00:17:19,389
that we want to navigate through some

00:17:15,909 --> 00:17:22,749
data sources and it could be a database

00:17:19,389 --> 00:17:27,339
or some web-based graph tree graph

00:17:22,749 --> 00:17:29,799
structure or a JSON file navigates

00:17:27,339 --> 00:17:32,919
through a data source and extract some

00:17:29,799 --> 00:17:36,009
information from it so I'll show you

00:17:32,919 --> 00:17:38,460
I'll show an example I have two examples

00:17:36,009 --> 00:17:38,460
here actually

00:17:46,770 --> 00:17:55,900
don't think I need this well I do so the

00:17:53,770 --> 00:18:01,390
first example here I'll make this

00:17:55,900 --> 00:18:04,210
smaller the first example which I think

00:18:01,390 --> 00:18:07,900
really illustrates this this idea nicely

00:18:04,210 --> 00:18:10,960
is this World Bank type provider now

00:18:07,900 --> 00:18:14,130
World Bank is a data source sort of

00:18:10,960 --> 00:18:17,710
online or well World Bank is a

00:18:14,130 --> 00:18:19,990
institution that that tries to help poor

00:18:17,710 --> 00:18:22,000
countries but one of the things they do

00:18:19,990 --> 00:18:23,920
is that they collect a lot of data about

00:18:22,000 --> 00:18:28,300
countries and they make this data

00:18:23,920 --> 00:18:31,030
available and if you want to query the

00:18:28,300 --> 00:18:34,510
the World Bank and find say the carbon

00:18:31,030 --> 00:18:36,400
emissions of Germany you can go to their

00:18:34,510 --> 00:18:40,120
website they have an API documentation

00:18:36,400 --> 00:18:42,820
you issue some XML requests you get some

00:18:40,120 --> 00:18:46,990
XML back if you're lucky you will you

00:18:42,820 --> 00:18:49,750
will find the data there what I what I

00:18:46,990 --> 00:18:52,120
want to show you is a sort of a way of

00:18:49,750 --> 00:18:54,160
adapting this and making it really

00:18:52,120 --> 00:18:57,850
easily accessible from a programming

00:18:54,160 --> 00:19:00,250
language so f-sharp makes this the sort

00:18:57,850 --> 00:19:03,070
of functional and object-oriented style

00:19:00,250 --> 00:19:05,830
so it has a dot operator and if you type

00:19:03,070 --> 00:19:08,860
dot you get a list of members that the

00:19:05,830 --> 00:19:11,650
object has and the interesting thing

00:19:08,860 --> 00:19:14,560
here is that the type providers actually

00:19:11,650 --> 00:19:16,990
sort of give us a way of generating

00:19:14,560 --> 00:19:21,120
these objects behind the scene at

00:19:16,990 --> 00:19:25,930
compile time so when I type dot it

00:19:21,120 --> 00:19:27,700
actually had to look it actually had to

00:19:25,930 --> 00:19:30,820
look at the data source

00:19:27,700 --> 00:19:34,030
the World Bank service and it gave me a

00:19:30,820 --> 00:19:37,980
list of countries that are all here so I

00:19:34,030 --> 00:19:41,500
can say Germany and I get Germany if

00:19:37,980 --> 00:19:44,320
Scotland ever decides to leave the UK I

00:19:41,500 --> 00:19:45,970
will type dot Scotland and when when

00:19:44,320 --> 00:19:49,090
they're when they're in the World Bank

00:19:45,970 --> 00:19:51,780
data set I will have it here so its

00:19:49,090 --> 00:19:51,780
future safe

00:19:52,510 --> 00:19:58,850
and the same thing happens with

00:19:55,850 --> 00:20:01,910
indicators this is a bit of a challenge

00:19:58,850 --> 00:20:03,320
because my screen isn't too big but the

00:20:01,910 --> 00:20:06,200
world bank has lots of different

00:20:03,320 --> 00:20:08,840
indicators about countries and we're

00:20:06,200 --> 00:20:11,480
making those stories directly accessible

00:20:08,840 --> 00:20:13,340
through the members of the object

00:20:11,480 --> 00:20:15,670
now nobody expects that you will

00:20:13,340 --> 00:20:18,860
actually type this from scratch because

00:20:15,670 --> 00:20:21,290
tends to be long the double back takes

00:20:18,860 --> 00:20:24,830
mean sort of make it a valid identifier

00:20:21,290 --> 00:20:27,950
no matter what's inside but if you're

00:20:24,830 --> 00:20:30,560
using any decent editor and everyone is

00:20:27,950 --> 00:20:36,620
then you will actually you will actually

00:20:30,560 --> 00:20:39,800
be able to navigate through the data so

00:20:36,620 --> 00:20:42,770
just to show you some fun data this is

00:20:39,800 --> 00:20:44,600
showing the total carbon emissions of

00:20:42,770 --> 00:20:46,940
Germany in kilotons

00:20:44,600 --> 00:20:49,910
so for Germany it's actually it's

00:20:46,940 --> 00:20:52,700
actually doing going going down now the

00:20:49,910 --> 00:20:56,530
scale doesn't start with zero here so my

00:20:52,700 --> 00:20:58,910
charting library is a bit confusing but

00:20:56,530 --> 00:21:02,090
fortunately this is not a data science

00:20:58,910 --> 00:21:08,690
audience I have if we look at the United

00:21:02,090 --> 00:21:14,600
States not making any political

00:21:08,690 --> 00:21:16,760
statements here but the nice thing here

00:21:14,600 --> 00:21:18,710
is that I can really sort of access the

00:21:16,760 --> 00:21:21,890
data source through my programming

00:21:18,710 --> 00:21:25,940
language and through my programming

00:21:21,890 --> 00:21:30,560
language sort of native features so this

00:21:25,940 --> 00:21:33,320
is this is on the World Bank now

00:21:30,560 --> 00:21:35,360
for World Bank this is a type provider

00:21:33,320 --> 00:21:37,700
that's been specifically built for that

00:21:35,360 --> 00:21:39,620
one data source so it makes for a

00:21:37,700 --> 00:21:42,920
wonderful demo but otherwise it's not

00:21:39,620 --> 00:21:44,210
all that useful and I'm going to show

00:21:42,920 --> 00:21:48,320
you another one which is more

00:21:44,210 --> 00:21:52,820
interesting and this is a type provider

00:21:48,320 --> 00:21:56,780
for accessing any JSON XML and CSV data

00:21:52,820 --> 00:22:01,250
structures so I have a sample URL here

00:21:56,780 --> 00:22:03,650
and this is a URL for open weather map

00:22:01,250 --> 00:22:04,880
which is a sort of service where you can

00:22:03,650 --> 00:22:08,300
register and get

00:22:04,880 --> 00:22:10,760
weather forecasts and I entered Berlin

00:22:08,300 --> 00:22:15,640
here as a city that I'm interested in

00:22:10,760 --> 00:22:19,790
and if you wanted to use this in

00:22:15,640 --> 00:22:23,090
statically typed way then very often you

00:22:19,790 --> 00:22:26,120
have to do something like have a look at

00:22:23,090 --> 00:22:29,540
the response see what the structure of

00:22:26,120 --> 00:22:31,790
the json s writes and records or case

00:22:29,540 --> 00:22:35,960
classes or classes to represent that

00:22:31,790 --> 00:22:37,850
structure then you can use some library

00:22:35,960 --> 00:22:41,300
that will load it into your types and

00:22:37,850 --> 00:22:43,160
then you work with the types or you can

00:22:41,300 --> 00:22:45,230
just say screw it I'll write this in

00:22:43,160 --> 00:22:47,900
JavaScript and you'll be done in ten

00:22:45,230 --> 00:22:51,110
seconds because you just type dot on

00:22:47,900 --> 00:22:59,840
temp and if it's there well then you win

00:22:51,110 --> 00:23:02,300
if it's not very loose so what the tie

00:22:59,840 --> 00:23:05,650
providers are trying to do is to give

00:23:02,300 --> 00:23:08,690
you sort of a nice way of having that

00:23:05,650 --> 00:23:11,540
JavaScript like way of working with data

00:23:08,690 --> 00:23:14,660
but in a statically typed world so what

00:23:11,540 --> 00:23:17,900
I did here is that I defined a type

00:23:14,660 --> 00:23:21,550
called weather which is created by

00:23:17,900 --> 00:23:25,900
adjacent I provider from that sample and

00:23:21,550 --> 00:23:31,310
then this this has some members most

00:23:25,900 --> 00:23:34,220
importantly it has a well I'll do this a

00:23:31,310 --> 00:23:38,840
bit differently so most importantly it

00:23:34,220 --> 00:23:42,290
has this load method and on the first

00:23:38,840 --> 00:23:44,990
line I'm using the URL as a sample for

00:23:42,290 --> 00:23:48,140
to guide the sort of pipe provider

00:23:44,990 --> 00:23:51,560
mechanism and on the second line I'm

00:23:48,140 --> 00:23:55,220
saying now actually load this URL

00:23:51,560 --> 00:24:00,230
whatever it returns into an object and

00:23:55,220 --> 00:24:02,810
give me that object and then I can say

00:24:00,230 --> 00:24:06,170
better dot and you actually see members

00:24:02,810 --> 00:24:10,160
that are generated based on whatever is

00:24:06,170 --> 00:24:14,240
in the JSON file so it has information

00:24:10,160 --> 00:24:16,610
about the city so let's see did we get

00:24:14,240 --> 00:24:18,640
Berlin in Germany we did get Berlin in

00:24:16,610 --> 00:24:18,640
Germany

00:24:18,920 --> 00:24:26,309
and it also infers that this list thing

00:24:22,880 --> 00:24:31,440
is some collection of some other nested

00:24:26,309 --> 00:24:37,350
records so I can say for whether in this

00:24:31,440 --> 00:24:41,610
list do and maybe I'll just get the

00:24:37,350 --> 00:24:44,400
temperature during the day so if sir

00:24:41,610 --> 00:24:50,130
does also have list comprehension syntax

00:24:44,400 --> 00:24:55,470
and I can say something like this to get

00:24:50,130 --> 00:24:56,490
a chart and here's the here's the

00:24:55,470 --> 00:24:58,559
weather forecast

00:24:56,490 --> 00:25:02,340
it's the temperatures for the next few

00:24:58,559 --> 00:25:05,760
days so looks like I came just when it's

00:25:02,340 --> 00:25:08,070
when it's on the down down there on the

00:25:05,760 --> 00:25:12,750
sort of lower lower side of the spectrum

00:25:08,070 --> 00:25:14,630
but it's still pretty good the

00:25:12,750 --> 00:25:18,450
interesting thing here is that you can

00:25:14,630 --> 00:25:20,820
so here I give the type provider a URL

00:25:18,450 --> 00:25:24,150
as a sample and then I load the same one

00:25:20,820 --> 00:25:29,490
so this is going to work probably fine

00:25:24,150 --> 00:25:31,710
but typically you actually want to have

00:25:29,490 --> 00:25:36,059
some sort of function that takes the

00:25:31,710 --> 00:25:40,520
city and gives me better in that city so

00:25:36,059 --> 00:25:44,640
in the URL I'll just put in the city and

00:25:40,520 --> 00:25:48,260
then I'll return the data and now I did

00:25:44,640 --> 00:25:55,770
define a function and I can say get temp

00:25:48,260 --> 00:25:58,050
London and draw the chart and did I

00:25:55,770 --> 00:26:00,660
actually do this or did I do something

00:25:58,050 --> 00:26:04,679
wrong let's see oh I probably did

00:26:00,660 --> 00:26:06,809
something wrong now my internet was slow

00:26:04,679 --> 00:26:10,679
so here's the here's the chart for

00:26:06,809 --> 00:26:12,360
London this is for Berlin so we might

00:26:10,679 --> 00:26:17,190
actually have a nice weekend in London

00:26:12,360 --> 00:26:19,140
woohoo now the sort so the interesting

00:26:17,190 --> 00:26:22,350
point here is that I'm using a different

00:26:19,140 --> 00:26:26,750
URL as my as my sleuth sample and

00:26:22,350 --> 00:26:29,010
different URL as my runtime input and

00:26:26,750 --> 00:26:32,820
that's the sort of interesting

00:26:29,010 --> 00:26:35,370
interesting interesting potential issue

00:26:32,820 --> 00:26:36,210
if the service returned very very

00:26:35,370 --> 00:26:39,000
different

00:26:36,210 --> 00:26:41,880
Jason structure for very very different

00:26:39,000 --> 00:26:45,480
cities then this wouldn't work because

00:26:41,880 --> 00:26:48,810
what I do temp today this is generated

00:26:45,480 --> 00:26:50,430
based on the sample but it just happens

00:26:48,810 --> 00:26:54,330
to be the case that whenever you're

00:26:50,430 --> 00:26:57,540
using a reasonable Jason service they

00:26:54,330 --> 00:27:00,450
will have sort of similar structure for

00:26:57,540 --> 00:27:03,060
all different inputs so this idea of

00:27:00,450 --> 00:27:05,340
inferring the sample generating the

00:27:03,060 --> 00:27:09,570
types from a sample actually works

00:27:05,340 --> 00:27:12,540
really nicely in practice it always

00:27:09,570 --> 00:27:19,050
scares the type theory people but that's

00:27:12,540 --> 00:27:24,900
fine so this was this was the Jason type

00:27:19,050 --> 00:27:27,150
provider and I think where it sort of

00:27:24,900 --> 00:27:29,700
where it sort of fits with with the

00:27:27,150 --> 00:27:33,180
functionalist way of thinking about

00:27:29,700 --> 00:27:35,630
design is that in in functionalist

00:27:33,180 --> 00:27:38,700
thinking the idea is that you sort of

00:27:35,630 --> 00:27:41,820
focus on the message of simplicity using

00:27:38,700 --> 00:27:44,190
basic geometric forms and using simple

00:27:41,820 --> 00:27:47,880
materials and if you look at the code I

00:27:44,190 --> 00:27:50,580
was writing it really is just typing dot

00:27:47,880 --> 00:27:52,680
and selecting things so that's where I

00:27:50,580 --> 00:27:57,480
think that the simplicity in the design

00:27:52,680 --> 00:27:59,730
really is working nicely and it is using

00:27:57,480 --> 00:28:03,780
some sort of clever material behind the

00:27:59,730 --> 00:28:06,030
scene because when I type dot there is

00:28:03,780 --> 00:28:09,240
some sort of clever logic going on

00:28:06,030 --> 00:28:11,520
behind where the compiler will sort of

00:28:09,240 --> 00:28:15,780
work with the type provider to figure

00:28:11,520 --> 00:28:18,990
out how exactly how exactly to get the

00:28:15,780 --> 00:28:21,030
data how exactly to build the list of

00:28:18,990 --> 00:28:24,060
members so there's something clever

00:28:21,030 --> 00:28:27,510
going on behind but the form at the end

00:28:24,060 --> 00:28:31,440
is very simple so it's not like you have

00:28:27,510 --> 00:28:34,470
sort of wiggly wiggly sort of things

00:28:31,440 --> 00:28:38,820
everywhere it really is a sort of simple

00:28:34,470 --> 00:28:43,320
straightforward shape and that's sort of

00:28:38,820 --> 00:28:46,029
the dot operator in F sharp so this is

00:28:43,320 --> 00:28:48,820
roughly the sample I was showing

00:28:46,029 --> 00:28:52,059
and it's just navigating through an

00:28:48,820 --> 00:28:54,879
object now one of the sort of

00:28:52,059 --> 00:28:56,889
interesting things that I think can

00:28:54,879 --> 00:28:59,169
happen both in in architecture and

00:28:56,889 --> 00:29:01,059
design and in programming is when you

00:28:59,169 --> 00:29:03,279
have some interesting material you can

00:29:01,059 --> 00:29:06,669
you can sort of test how far you can

00:29:03,279 --> 00:29:10,149
take it and people definitely did that

00:29:06,669 --> 00:29:12,249
with reinforced concrete so this is this

00:29:10,149 --> 00:29:15,099
is not it looks a bit scary but it's not

00:29:12,249 --> 00:29:18,460
too bad but this is a this is a pretty

00:29:15,099 --> 00:29:20,889
amazing building in in Sao Paulo where

00:29:18,460 --> 00:29:23,769
you can see that the entire it's a it's

00:29:20,889 --> 00:29:25,479
a gallery and the entire thing is it's

00:29:23,769 --> 00:29:28,089
really just standing on these four

00:29:25,479 --> 00:29:31,029
columns in the in the corners and it's

00:29:28,089 --> 00:29:33,369
pretty huge and it is really sort of

00:29:31,029 --> 00:29:36,219
exploiting the fact that you can you can

00:29:33,369 --> 00:29:41,649
use reinforced concrete and it will not

00:29:36,219 --> 00:29:43,509
not fall down and I think you can sort

00:29:41,649 --> 00:29:46,119
of do the same thing with the width of

00:29:43,509 --> 00:29:48,039
with the function with programming where

00:29:46,119 --> 00:29:51,489
if you have some sort of nice

00:29:48,039 --> 00:29:56,259
interesting mechanism it's interesting

00:29:51,489 --> 00:29:58,089
to see how far you can take it and so

00:29:56,259 --> 00:30:02,399
I'll show you one more example of a pipe

00:29:58,089 --> 00:30:05,080
provider that I've been working on and

00:30:02,399 --> 00:30:08,190
this is this is actually not in F sharp

00:30:05,080 --> 00:30:12,039
it's a it's a separate project that is

00:30:08,190 --> 00:30:14,859
heavily inspired by F sharp and the idea

00:30:12,039 --> 00:30:19,690
here is can we make basic data

00:30:14,859 --> 00:30:23,019
exploration really really easy but keep

00:30:19,690 --> 00:30:25,899
it as a reproducible program script so

00:30:23,019 --> 00:30:29,469
if you look at sort of media reporting

00:30:25,899 --> 00:30:31,749
on some data they might use Excel and do

00:30:29,469 --> 00:30:34,119
some sort of pivot tables to aggregate

00:30:31,749 --> 00:30:38,200
data and then they give you some

00:30:34,119 --> 00:30:40,539
resulting chart and if they've done it

00:30:38,200 --> 00:30:43,059
right well then it's a it's a nice chart

00:30:40,539 --> 00:30:44,979
if they've done it wrong then you will

00:30:43,059 --> 00:30:48,279
never find out because there's no trace

00:30:44,979 --> 00:30:50,889
so here the idea is what would be the

00:30:48,279 --> 00:30:55,659
sort of simplest possible web-based

00:30:50,889 --> 00:30:58,599
scripting language where people can

00:30:55,659 --> 00:31:01,230
write a little bit of code to do some

00:30:58,599 --> 00:31:04,270
data transformation

00:31:01,230 --> 00:31:08,470
and the way it works is that you just

00:31:04,270 --> 00:31:12,220
use dot so Olympics in this case is a

00:31:08,470 --> 00:31:14,920
sample data source I have with all the

00:31:12,220 --> 00:31:18,220
Olympic medals ever awarded so there's

00:31:14,920 --> 00:31:21,580
what Olympic Games is it what year or

00:31:18,220 --> 00:31:26,530
discipline and what was medal the person

00:31:21,580 --> 00:31:29,110
won and you can say dot and it tells you

00:31:26,530 --> 00:31:31,330
here's a list of available operations

00:31:29,110 --> 00:31:35,230
that you can do with the data so I can

00:31:31,330 --> 00:31:38,260
filter the data and say and again I say

00:31:35,230 --> 00:31:44,430
filter data and it comes up with all

00:31:38,260 --> 00:31:47,920
possible all possible sort of cone

00:31:44,430 --> 00:31:54,370
conditions I can write such as limited

00:31:47,920 --> 00:31:57,610
to specific Olympic Games so if I say I

00:31:54,370 --> 00:32:00,730
only want three or 2016 then it filters

00:31:57,610 --> 00:32:06,940
the filters the data set and I get Rio

00:32:00,730 --> 00:32:10,600
2016 medals and then I can type dot and

00:32:06,940 --> 00:32:16,060
it offers more filters if I want it or

00:32:10,600 --> 00:32:18,790
then if I want to do something else then

00:32:16,060 --> 00:32:21,010
I can say group data so if I wanted to

00:32:18,790 --> 00:32:23,770
know what's the country with the largest

00:32:21,010 --> 00:32:28,990
number of gold medals then I can group

00:32:23,770 --> 00:32:30,550
the data by team and the other neat

00:32:28,990 --> 00:32:33,070
trick that this does is that it actually

00:32:30,550 --> 00:32:36,490
shows you a live preview of what we've

00:32:33,070 --> 00:32:41,020
what we've created so far so I can say

00:32:36,490 --> 00:32:45,070
group this by team and some the number

00:32:41,020 --> 00:32:48,340
of gold medals I could also do things

00:32:45,070 --> 00:32:56,050
like count the number of distinct

00:32:48,340 --> 00:32:59,160
athletes and sort the data by the number

00:32:56,050 --> 00:33:02,170
of gold medals and then you can see

00:32:59,160 --> 00:33:04,660
what's the what's the aggregate so

00:33:02,170 --> 00:33:07,000
United States do you have the largest

00:33:04,660 --> 00:33:09,190
number of gold medals they also happen

00:33:07,000 --> 00:33:12,430
to have the largest number of of

00:33:09,190 --> 00:33:15,850
athletes involved in the Olympics

00:33:12,430 --> 00:33:17,950
and it's sort of pretty simple data

00:33:15,850 --> 00:33:21,910
transformation something you could write

00:33:17,950 --> 00:33:25,060
in an SQL query but the neat thing is

00:33:21,910 --> 00:33:27,010
that the only language construct I

00:33:25,060 --> 00:33:36,010
actually had to use to do this with dot

00:33:27,010 --> 00:33:38,170
and selecting a member so if I if I do a

00:33:36,010 --> 00:33:40,960
few more things than I can say

00:33:38,170 --> 00:33:43,690
now it gets now it gets awfully

00:33:40,960 --> 00:33:48,180
complicated because take takes an

00:33:43,690 --> 00:33:50,650
argument and I do need parentheses but

00:33:48,180 --> 00:33:51,370
yeah I haven't figured out how to do

00:33:50,650 --> 00:33:54,490
that one yet

00:33:51,370 --> 00:33:56,710
so we can get a data series where the

00:33:54,490 --> 00:34:00,190
key is the athlete and the value is the

00:33:56,710 --> 00:34:03,280
number of gold medals and then I have to

00:34:00,190 --> 00:34:09,540
do a bit more of real programming and

00:34:03,280 --> 00:34:09,540
say create a column chart with this data

00:34:12,300 --> 00:34:21,280
maybe not what did I do wrong

00:34:16,090 --> 00:34:23,800
ah no this is this is actually supposed

00:34:21,280 --> 00:34:31,360
to so this is actually supposed to be

00:34:23,800 --> 00:34:33,159
composts but I let's see I got annoyed

00:34:31,360 --> 00:34:35,560
by word which whenever you write

00:34:33,159 --> 00:34:39,700
composable it always says did you mean

00:34:35,560 --> 00:34:41,440
compostable and no I didn't alright so

00:34:39,700 --> 00:34:47,320
this is this is the right way to do the

00:34:41,440 --> 00:34:51,310
chart so you can you can use the simple

00:34:47,320 --> 00:34:54,159
simple simple sort of dot mechanism take

00:34:51,310 --> 00:34:58,180
it take it way further than I think was

00:34:54,159 --> 00:35:03,640
originally intended and embed quite a

00:34:58,180 --> 00:35:09,100
lot you think that using that simple

00:35:03,640 --> 00:35:12,100
form so I sort of I sort of think that

00:35:09,100 --> 00:35:14,020
if dot in our language is is concrete

00:35:12,100 --> 00:35:21,310
then what type providers give us

00:35:14,020 --> 00:35:23,440
reinforced concrete now so this was this

00:35:21,310 --> 00:35:26,320
was two examples one was the function

00:35:23,440 --> 00:35:29,440
composition where we sort of

00:35:26,320 --> 00:35:32,440
eliminate all the older or lament and

00:35:29,440 --> 00:35:35,400
all the keywords ii was type providers

00:35:32,440 --> 00:35:39,100
where we're using the sort of basic o

00:35:35,400 --> 00:35:41,620
dot and member access and and taking it

00:35:39,100 --> 00:35:43,440
taking it a bit further and the last

00:35:41,620 --> 00:35:47,500
thing i want to talk about is

00:35:43,440 --> 00:35:49,240
computations and specifically observe

00:35:47,500 --> 00:35:53,680
has this feature called computation

00:35:49,240 --> 00:35:56,440
expressions which i think is relevant to

00:35:53,680 --> 00:35:58,720
some of the sort of work on asynchronous

00:35:56,440 --> 00:36:00,910
reactive and concurrent programming that

00:35:58,720 --> 00:36:03,430
people have been doing in scala as well

00:36:00,910 --> 00:36:05,530
and it's also one of the areas where I

00:36:03,430 --> 00:36:12,400
think the two language is really sort of

00:36:05,530 --> 00:36:17,140
exchange ideas quite a lot so what's the

00:36:12,400 --> 00:36:20,410
what's the idea was the purpose and I

00:36:17,140 --> 00:36:21,910
think this is also one case where really

00:36:20,410 --> 00:36:24,820
this sort of distinction between

00:36:21,910 --> 00:36:28,210
thinking about function as a purpose and

00:36:24,820 --> 00:36:31,450
function as a mathematical concept is is

00:36:28,210 --> 00:36:35,020
pretty big so if you think about

00:36:31,450 --> 00:36:37,150
function as a mathematical concept then

00:36:35,020 --> 00:36:40,420
this is just going to be twenty minutes

00:36:37,150 --> 00:36:44,200
on monads but if you think about

00:36:40,420 --> 00:36:47,350
function as a purpose then I think you

00:36:44,200 --> 00:36:50,260
can you can get a really interesting

00:36:47,350 --> 00:36:56,140
sort of alternative view on what this

00:36:50,260 --> 00:36:59,800
language feature does so what we're

00:36:56,140 --> 00:37:02,530
trying to do with with asynchronous and

00:36:59,800 --> 00:37:05,260
concurrent computations in observe is to

00:37:02,530 --> 00:37:08,170
give an alternative meaning to an

00:37:05,260 --> 00:37:11,590
ordinary computation and I'll show you

00:37:08,170 --> 00:37:13,630
an example and I think in architecture

00:37:11,590 --> 00:37:16,390
you often sort of have this as well

00:37:13,630 --> 00:37:19,390
where the the context really matters so

00:37:16,390 --> 00:37:21,220
this is a this is a housing complex in

00:37:19,390 --> 00:37:23,830
Prague that doesn't look all that

00:37:21,220 --> 00:37:26,410
impressive if you take the same sort of

00:37:23,830 --> 00:37:27,280
shape take the same structure and put it

00:37:26,410 --> 00:37:29,920
somewhere else

00:37:27,280 --> 00:37:33,220
then it really looks like a very very

00:37:29,920 --> 00:37:36,550
different very very different thing so I

00:37:33,220 --> 00:37:38,410
think in in the sort of next few

00:37:36,550 --> 00:37:40,089
examples it's really a case of taking

00:37:38,410 --> 00:37:42,819
something very ordinary

00:37:40,089 --> 00:37:46,289
and keeping the structure but changing

00:37:42,819 --> 00:37:46,289
the the meaning behind it

00:37:46,569 --> 00:37:54,789
and the example that we're we're they

00:37:52,719 --> 00:37:56,319
sort of first appeared in a serve is

00:37:54,789 --> 00:37:59,380
when you need to do a synchronous

00:37:56,319 --> 00:38:03,039
computing so this is a little F sharp

00:37:59,380 --> 00:38:07,299
code snippet defining a function try get

00:38:03,039 --> 00:38:10,449
page length which takes a URL then it

00:38:07,299 --> 00:38:14,619
creates a some web client object it

00:38:10,449 --> 00:38:18,130
downloads the URL gets the HTML and then

00:38:14,619 --> 00:38:20,439
it returns the length and it rubs this

00:38:18,130 --> 00:38:23,229
into some constructor so that's the

00:38:20,439 --> 00:38:25,599
option or maybe type that we're using to

00:38:23,229 --> 00:38:29,529
represent missing missing or failing

00:38:25,599 --> 00:38:32,829
things so if it works I returned some of

00:38:29,529 --> 00:38:39,029
length if it doesn't work then I return

00:38:32,829 --> 00:38:42,579
none to indicate that I don't know and

00:38:39,029 --> 00:38:45,160
this this is really simple the only

00:38:42,579 --> 00:38:47,319
problem with it is that it blocks the

00:38:45,160 --> 00:38:50,079
current threat when it does the download

00:38:47,319 --> 00:38:52,299
so download Inc will block and it might

00:38:50,079 --> 00:38:54,939
take fairly long time and if you're

00:38:52,299 --> 00:38:57,160
doing these things in in parallel or if

00:38:54,939 --> 00:39:01,719
you're on a server that's a very bad

00:38:57,160 --> 00:39:05,829
thing to do now you could rewrite this

00:39:01,719 --> 00:39:09,039
using sort of callbacks and and explicit

00:39:05,829 --> 00:39:11,949
continuations or in JavaScript people

00:39:09,039 --> 00:39:14,349
use futures but it really changes the

00:39:11,949 --> 00:39:16,359
structure and you can't do normal

00:39:14,349 --> 00:39:20,079
language things like try ways to handle

00:39:16,359 --> 00:39:22,719
exceptions the way f-sharp does it is

00:39:20,079 --> 00:39:25,630
that you wrap the code block in this

00:39:22,719 --> 00:39:28,420
async block so I'll switch between the

00:39:25,630 --> 00:39:32,799
two a few times just so that you can see

00:39:28,420 --> 00:39:34,989
where the differences are so I've

00:39:32,799 --> 00:39:38,529
wrapped the code block inside this async

00:39:34,989 --> 00:39:41,339
curly brackets but otherwise I keep all

00:39:38,529 --> 00:39:44,140
my sort of syntactic structures the same

00:39:41,339 --> 00:39:47,229
the the one more change that I do is

00:39:44,140 --> 00:39:49,869
that I have to add return so that's just

00:39:47,229 --> 00:39:53,950
sort of syntactic requirement inside

00:39:49,869 --> 00:39:58,839
these computation blocks and when I had

00:39:53,950 --> 00:40:03,010
load and let HTML equals that I now have

00:39:58,839 --> 00:40:06,250
let exclamation mark HTML equals async

00:40:03,010 --> 00:40:10,359
download so this this let exclamation

00:40:06,250 --> 00:40:15,430
mark is what the mathematicians would

00:40:10,359 --> 00:40:17,940
call monadic bind and it means sort of

00:40:15,430 --> 00:40:21,940
start this computation when it finishes

00:40:17,940 --> 00:40:24,670
resume this this asynchronous workflow

00:40:21,940 --> 00:40:26,560
and behind the scenes it runs it runs

00:40:24,670 --> 00:40:31,930
the code so that it doesn't actually

00:40:26,560 --> 00:40:34,000
block the threat but I think what I find

00:40:31,930 --> 00:40:36,670
really sort of nice about this this way

00:40:34,000 --> 00:40:39,040
of writing the code is that you still

00:40:36,670 --> 00:40:42,910
keep all your normal syntax in this

00:40:39,040 --> 00:40:45,130
block so try with previously it was just

00:40:42,910 --> 00:40:48,910
sort of normal dotnet exception handling

00:40:45,130 --> 00:40:50,829
now it does some clever man uses some

00:40:48,910 --> 00:40:54,150
clever mechanism to propagate the

00:40:50,829 --> 00:40:56,410
exception handling sort of across the

00:40:54,150 --> 00:41:00,130
multiple possible threads that are

00:40:56,410 --> 00:41:03,040
running the code so it's reinterpreting

00:41:00,130 --> 00:41:07,869
all the basic language constructs in a

00:41:03,040 --> 00:41:17,440
different context and I'll show you one

00:41:07,869 --> 00:41:22,359
more fun example of this so here this is

00:41:17,440 --> 00:41:28,270
a sample previously I was running

00:41:22,359 --> 00:41:30,280
f-sharp on on the.net runtime or it

00:41:28,270 --> 00:41:31,920
works on on mono as well if you're

00:41:30,280 --> 00:41:35,290
running Mac or Linux

00:41:31,920 --> 00:41:38,380
it runs on donate core which is the sort

00:41:35,290 --> 00:41:42,400
of Microsoft next version of the of

00:41:38,380 --> 00:41:46,560
dotnet that's cross-platform now I'm

00:41:42,400 --> 00:41:46,560
going to do something different because

00:41:47,430 --> 00:41:51,240
yes this is typo

00:41:52,940 --> 00:41:58,970
because the only way I can do you is is

00:41:55,910 --> 00:42:01,250
in a web browser so now I'm using f

00:41:58,970 --> 00:42:04,339
sharp through a project called fable

00:42:01,250 --> 00:42:09,500
which compiles have served to JavaScript

00:42:04,339 --> 00:42:11,079
and so here when I type something I have

00:42:09,500 --> 00:42:15,260
a process running in the background

00:42:11,079 --> 00:42:18,440
which will recompile my my coat and it

00:42:15,260 --> 00:42:20,480
reloads in the browser and you can use

00:42:18,440 --> 00:42:27,800
these async computations in the browser

00:42:20,480 --> 00:42:34,099
as well so one example I can do here is

00:42:27,800 --> 00:42:40,880
to say sleep for a 100 1000 milliseconds

00:42:34,099 --> 00:42:44,060
and then change the color and I'll start

00:42:40,880 --> 00:42:46,940
the computation immediately and if I

00:42:44,060 --> 00:42:52,490
save this and we'll stay for one second

00:42:46,940 --> 00:42:54,680
and then the color changes and if I

00:42:52,490 --> 00:42:57,319
wanted to do traffic lights I could say

00:42:54,680 --> 00:43:00,890
something like this so which way does it

00:42:57,319 --> 00:43:04,550
go first we have green then we do orange

00:43:00,890 --> 00:43:06,500
and then we do red and now I have a

00:43:04,550 --> 00:43:09,410
little sort of asynchronous traffic

00:43:06,500 --> 00:43:11,900
light and it really it really works in

00:43:09,410 --> 00:43:13,970
the browser sort of nicely because in

00:43:11,900 --> 00:43:16,040
the browser you can't block a thread

00:43:13,970 --> 00:43:18,200
there's no way of doing that until

00:43:16,040 --> 00:43:21,170
unless you're mining bitcoins for

00:43:18,200 --> 00:43:24,130
something but then your UI will freeze

00:43:21,170 --> 00:43:24,130
so that's not very good

00:43:24,430 --> 00:43:30,079
so I created this sort of asynchronous

00:43:27,369 --> 00:43:33,950
computation that behind-the-scenes

00:43:30,079 --> 00:43:37,640
creates a timer waits for 100 1000

00:43:33,950 --> 00:43:40,819
milliseconds change the color but the

00:43:37,640 --> 00:43:43,310
really nice thing here is that you can

00:43:40,819 --> 00:43:46,849
still use some of the basic sort of

00:43:43,310 --> 00:43:49,730
language constructs such as while loop

00:43:46,849 --> 00:43:56,030
so now I created a traffic light that

00:43:49,730 --> 00:44:00,530
will run in a loop forever and if you

00:43:56,030 --> 00:44:05,290
don't like copy paste you can say things

00:44:00,530 --> 00:44:05,290
like for color in this list of colors

00:44:08,490 --> 00:44:18,700
sleep and then change the color and it's

00:44:15,369 --> 00:44:22,630
still still doing the same thing and I

00:44:18,700 --> 00:44:24,849
really like this this sort of idea that

00:44:22,630 --> 00:44:27,160
you can take normal sort of language

00:44:24,849 --> 00:44:30,520
constructs and just run them

00:44:27,160 --> 00:44:32,890
asynchronously and when I when I sort of

00:44:30,520 --> 00:44:35,050
we're starting with programming in

00:44:32,890 --> 00:44:37,839
Visual Basic I always wanted to write a

00:44:35,050 --> 00:44:39,910
loop like this to run my game and then

00:44:37,839 --> 00:44:42,400
it wouldn't work because you can't block

00:44:39,910 --> 00:44:45,609
threads and programming Chris was so

00:44:42,400 --> 00:44:47,349
hard and it still is hard these days you

00:44:45,609 --> 00:44:49,780
still have the same problems you have in

00:44:47,349 --> 00:44:53,940
Visual Basic for but with async

00:44:49,780 --> 00:44:53,940
computations that it gets a bit nicer

00:44:54,390 --> 00:45:11,230
now this is this is this is using async

00:45:03,190 --> 00:45:13,359
computations and I think the sort of

00:45:11,230 --> 00:45:15,970
interesting design principle here is

00:45:13,359 --> 00:45:18,099
that the the way this feature is

00:45:15,970 --> 00:45:22,960
implemented in F sharp is that it gives

00:45:18,099 --> 00:45:25,270
you fairly flexible material and you can

00:45:22,960 --> 00:45:28,210
use this sort of acing lock that's one

00:45:25,270 --> 00:45:30,760
of the standard library library things

00:45:28,210 --> 00:45:33,040
but there's quite a few other different

00:45:30,760 --> 00:45:37,210
kinds of computations that people are

00:45:33,040 --> 00:45:39,490
using or the people built and if you

00:45:37,210 --> 00:45:42,609
sort of design those with the material

00:45:39,490 --> 00:45:47,410
in mind then you can create quite a lot

00:45:42,609 --> 00:45:50,200
of nice a nice sort of libraries nice

00:45:47,410 --> 00:45:53,980
api's that fit well with with the idea

00:45:50,200 --> 00:45:56,890
so this is this is sort of another

00:45:53,980 --> 00:46:00,760
interesting use of concrete where it

00:45:56,890 --> 00:46:02,650
really sort of was designed because they

00:46:00,760 --> 00:46:05,109
knew how they are going how they are

00:46:02,650 --> 00:46:07,630
going to build it and there's things you

00:46:05,109 --> 00:46:10,119
can do with concrete like this there's

00:46:07,630 --> 00:46:12,250
things you can't do with concrete so

00:46:10,119 --> 00:46:16,089
this is a picture from the Abu Dhabi

00:46:12,250 --> 00:46:18,580
Louvre Museum which has this crazy roof

00:46:16,089 --> 00:46:22,090
pattern and that's some sort of metal

00:46:18,580 --> 00:46:25,180
all metal things bolted together which

00:46:22,090 --> 00:46:28,060
I'm showing you on this only because the

00:46:25,180 --> 00:46:30,130
the the guy designing the roof structure

00:46:28,060 --> 00:46:33,160
actually used f-sharp to do some of the

00:46:30,130 --> 00:46:35,170
modeling but you can't you can't build

00:46:33,160 --> 00:46:39,460
this with concrete so then you need a

00:46:35,170 --> 00:46:42,430
different material and I think in in in

00:46:39,460 --> 00:46:45,670
programming what is sort of a useful

00:46:42,430 --> 00:46:49,060
design principle along similar lines is

00:46:45,670 --> 00:46:51,280
that when you have some when you have

00:46:49,060 --> 00:46:54,010
some right abstractions it should either

00:46:51,280 --> 00:46:59,650
make things easy or it should make

00:46:54,010 --> 00:47:01,990
things in impossible and there's one

00:46:59,650 --> 00:47:04,030
sort of really interesting asynchronous

00:47:01,990 --> 00:47:07,090
programming abstraction that people have

00:47:04,030 --> 00:47:10,420
been using in F sharp which is called

00:47:07,090 --> 00:47:12,880
asynchronous sequence and I think this

00:47:10,420 --> 00:47:16,090
is a really nice example of a design

00:47:12,880 --> 00:47:19,120
that is designed for a sort of clear

00:47:16,090 --> 00:47:22,150
purpose it makes things that fit with

00:47:19,120 --> 00:47:25,300
the purpose really easy but things that

00:47:22,150 --> 00:47:27,820
don't fit with the purpose you will soon

00:47:25,300 --> 00:47:34,450
realize that there's no way this is

00:47:27,820 --> 00:47:38,970
going to work well so what this does is

00:47:34,450 --> 00:47:43,600
that you have async seek which is

00:47:38,970 --> 00:47:46,450
asynchronously produces async result so

00:47:43,600 --> 00:47:49,570
the async async of a Sinkler

00:47:46,450 --> 00:47:52,240
asynchronously produces just means you

00:47:49,570 --> 00:47:55,660
can start it and it will eventually call

00:47:52,240 --> 00:47:59,770
you back with the result after it does

00:47:55,660 --> 00:48:02,350
some IO or whatever stuff and the async

00:47:59,770 --> 00:48:05,650
result is either the sequence has

00:48:02,350 --> 00:48:08,380
finished there's no more data in it or

00:48:05,650 --> 00:48:10,210
it says here's a value and it gives you

00:48:08,380 --> 00:48:12,850
the value together with another

00:48:10,210 --> 00:48:16,810
asynchronous sequence that you can start

00:48:12,850 --> 00:48:20,920
again to get more data so the type

00:48:16,810 --> 00:48:23,110
definition is pretty much sort of the

00:48:20,920 --> 00:48:25,980
the functional programming textbook

00:48:23,110 --> 00:48:29,110
example of a list of a linked list

00:48:25,980 --> 00:48:31,540
except that it does every sort of step

00:48:29,110 --> 00:48:32,940
asynchronously to compete the next the

00:48:31,540 --> 00:48:40,570
next thing

00:48:32,940 --> 00:48:42,820
and this is this is a sort of amazingly

00:48:40,570 --> 00:48:48,700
nice pattern for certain kinds of

00:48:42,820 --> 00:48:52,030
asynchronous programming so I have a

00:48:48,700 --> 00:48:58,000
little example here where what we are

00:48:52,030 --> 00:49:05,860
doing is that we are we have some data

00:48:58,000 --> 00:49:08,650
files with some prices and we we have we

00:49:05,860 --> 00:49:12,820
have data for one year so we iterate

00:49:08,650 --> 00:49:16,300
over the years of the days of the year

00:49:12,820 --> 00:49:19,120
and then we want to read the JSON data

00:49:16,300 --> 00:49:21,910
that we download this is still running

00:49:19,120 --> 00:49:24,160
in the browser so this is asynchronously

00:49:21,910 --> 00:49:27,250
sort of making a request to the server

00:49:24,160 --> 00:49:30,730
to get the data then we find the price

00:49:27,250 --> 00:49:33,250
and we display it and we wait for 100

00:49:30,730 --> 00:49:35,890
milliseconds and I'm running this in an

00:49:33,250 --> 00:49:40,330
async block just like before with the

00:49:35,890 --> 00:49:43,990
traffic lights so if I can find the

00:49:40,330 --> 00:49:47,320
right window well you can see that my

00:49:43,990 --> 00:49:49,620
parsing didn't work as expected what did

00:49:47,320 --> 00:49:49,620
I do wrong

00:49:52,290 --> 00:49:58,530
well I did something wrong so I did

00:49:55,660 --> 00:50:01,300
something wrong and rather than getting

00:49:58,530 --> 00:50:07,300
getting my data I'm actually I think I'm

00:50:01,300 --> 00:50:12,010
printing the wrong thing here yes this

00:50:07,300 --> 00:50:14,530
is what I wanted to print almost value

00:50:12,010 --> 00:50:16,800
all right now I'm now I'm sort of

00:50:14,530 --> 00:50:20,320
iterating over some data source

00:50:16,800 --> 00:50:22,690
downloading downloading the data one by

00:50:20,320 --> 00:50:27,100
one you can see how this is how this is

00:50:22,690 --> 00:50:29,050
happening if you open the debugger now

00:50:27,100 --> 00:50:32,050
one really annoying thing here is that

00:50:29,050 --> 00:50:34,570
there's no nice way to break this if

00:50:32,050 --> 00:50:37,300
you're just using async because async is

00:50:34,570 --> 00:50:39,340
a computation that produces one value

00:50:37,300 --> 00:50:43,210
but here I'm actually producing a

00:50:39,340 --> 00:50:46,900
sequence of values so what I can do here

00:50:43,210 --> 00:50:48,540
is I can define a computer

00:50:46,900 --> 00:50:52,480
[Music]

00:50:48,540 --> 00:50:59,590
read prices that will do pretty much

00:50:52,480 --> 00:51:06,130
what I have here it will find the number

00:50:59,590 --> 00:51:08,020
and it will yield the value and this is

00:51:06,130 --> 00:51:10,990
now a function that returns an

00:51:08,020 --> 00:51:14,290
asynchronous computation that will

00:51:10,990 --> 00:51:18,940
iterate over an input read data one by

00:51:14,290 --> 00:51:24,810
one and return them and then I can

00:51:18,940 --> 00:51:33,070
consume this and I can say for V in read

00:51:24,810 --> 00:51:35,890
prices do this and I need to change home

00:51:33,070 --> 00:51:41,920
starting things but otherwise it does

00:51:35,890 --> 00:51:47,260
the same thing as before and I now have

00:51:41,920 --> 00:51:49,450
the same the same thing but it's do I

00:51:47,260 --> 00:51:51,760
have the same thing well hopefully I do

00:51:49,450 --> 00:51:55,000
have the same thing but now it's sort of

00:51:51,760 --> 00:51:57,850
nicely separated the the reading from

00:51:55,000 --> 00:52:01,300
the iteration and the the one nice

00:51:57,850 --> 00:52:05,230
feature here is that the consumer sort

00:52:01,300 --> 00:52:08,320
of defines how quickly the input is

00:52:05,230 --> 00:52:11,470
being consumed so this is a this is an

00:52:08,320 --> 00:52:17,500
abstraction that fits nicely with the

00:52:11,470 --> 00:52:20,260
idea that it really depends on what the

00:52:17,500 --> 00:52:23,380
what the purpose is and if your purpose

00:52:20,260 --> 00:52:26,830
here is I want to consume some data

00:52:23,380 --> 00:52:29,320
asynchronously as a sequence then this

00:52:26,830 --> 00:52:31,420
works well but you wouldn't use it for

00:52:29,320 --> 00:52:34,810
things where you have sort of pushed

00:52:31,420 --> 00:52:36,790
based reactive systems because there you

00:52:34,810 --> 00:52:42,520
have no control over how you consume

00:52:36,790 --> 00:52:45,370
things so to wrap up if we if you look

00:52:42,520 --> 00:52:48,010
at what what sort of modern listen and

00:52:45,370 --> 00:52:51,610
and functional means in the in the

00:52:48,010 --> 00:52:54,340
design world then it means a couple of

00:52:51,610 --> 00:52:56,500
things it means this analytical approach

00:52:54,340 --> 00:52:58,390
to the function so that's really sort of

00:52:56,500 --> 00:53:00,440
trying to understand what's the purpose

00:52:58,390 --> 00:53:03,790
of the thing I'm building

00:53:00,440 --> 00:53:06,590
interesting use of new materials and

00:53:03,790 --> 00:53:09,980
openness to structural innovation and

00:53:06,590 --> 00:53:11,750
the elimination of ornament and I think

00:53:09,980 --> 00:53:13,700
those are really actually principles

00:53:11,750 --> 00:53:16,550
that we should be thinking about and

00:53:13,700 --> 00:53:19,220
using in programming Abbi it's sort of

00:53:16,550 --> 00:53:23,300
language design or library design or

00:53:19,220 --> 00:53:25,790
actually building systems and I try to

00:53:23,300 --> 00:53:28,369
give you a few examples in the talk so

00:53:25,790 --> 00:53:32,060
the the function composition that really

00:53:28,369 --> 00:53:36,380
sort of replaces this lots of different

00:53:32,060 --> 00:53:39,290
keywords with just simple in my case the

00:53:36,380 --> 00:53:42,710
piping operator eliminates a lot of the

00:53:39,290 --> 00:53:45,920
keywords and the ornament type providers

00:53:42,710 --> 00:53:48,859
are taking a known structure the dot and

00:53:45,920 --> 00:53:50,540
member access and sort of changing what

00:53:48,859 --> 00:53:54,800
this does but keeping the same

00:53:50,540 --> 00:53:57,140
simplicity and computational expressions

00:53:54,800 --> 00:54:02,570
are letting you sort of repurpose an

00:53:57,140 --> 00:54:04,220
existing existing pattern and use it in

00:54:02,570 --> 00:54:06,950
many different ways so it's sort of

00:54:04,220 --> 00:54:09,950
using the new material that the language

00:54:06,950 --> 00:54:13,310
provides in a sort of way that fits well

00:54:09,950 --> 00:54:18,080
with whatever the material is but works

00:54:13,310 --> 00:54:20,090
in in a number of different areas so the

00:54:18,080 --> 00:54:21,800
whole point of the talk really was to

00:54:20,090 --> 00:54:23,840
sort of try to convince you that

00:54:21,800 --> 00:54:26,510
whenever we say functional programming

00:54:23,840 --> 00:54:28,730
it's maybe more useful to think of this

00:54:26,510 --> 00:54:32,060
function as the as the purpose for which

00:54:28,730 --> 00:54:35,420
things are built rather than function as

00:54:32,060 --> 00:54:38,020
much mathematics because functions and

00:54:35,420 --> 00:54:41,300
mathematics are great for proving things

00:54:38,020 --> 00:54:44,300
but I feel that programming is very very

00:54:41,300 --> 00:54:46,760
often more about the sort of design and

00:54:44,300 --> 00:54:49,520
and building things that will be used by

00:54:46,760 --> 00:54:51,170
other people and the one interesting

00:54:49,520 --> 00:54:53,420
principle that we can take from the

00:54:51,170 --> 00:54:56,030
modernist architecture is this form

00:54:53,420 --> 00:54:57,859
follows function where the purpose for

00:54:56,030 --> 00:55:00,710
which something is built really

00:54:57,859 --> 00:55:04,180
determines what is the structure of it

00:55:00,710 --> 00:55:07,560
and how does it look thank you very much

00:55:04,180 --> 00:55:07,560

YouTube URL: https://www.youtube.com/watch?v=CIQRduY82H4


