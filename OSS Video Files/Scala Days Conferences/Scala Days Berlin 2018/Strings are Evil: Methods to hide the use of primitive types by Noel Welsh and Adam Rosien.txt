Title: Strings are Evil: Methods to hide the use of primitive types by Noel Welsh and Adam Rosien
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6941-strings-are-evil%3A-methods-to-hide-the-use-of-primitive-types.html
Captions: 
	00:00:04,650 --> 00:00:08,610
all right everybody thanks for coming

00:00:06,420 --> 00:00:11,610
along to my talk my name is Noah Welsh

00:00:08,610 --> 00:00:13,469
I'm a consultant at underscore I'm

00:00:11,610 --> 00:00:15,690
giving this talk for my colleague Adam

00:00:13,469 --> 00:00:18,509
who unfortunately couldn't make it over

00:00:15,690 --> 00:00:19,470
here so if you spot any errors or faults

00:00:18,509 --> 00:00:21,060
in the talk they're all out in this

00:00:19,470 --> 00:00:25,559
fault if thinks a good talk is obviously

00:00:21,060 --> 00:00:29,279
in my delivery just keep that in mind so

00:00:25,559 --> 00:00:31,890
what I want to talk about today is the

00:00:29,279 --> 00:00:33,620
the outline I want to talk about that

00:00:31,890 --> 00:00:37,500
way problems can get into our code

00:00:33,620 --> 00:00:39,449
through using the primitive types things

00:00:37,500 --> 00:00:41,519
like int string when they're not

00:00:39,449 --> 00:00:43,230
appropriate and then look at some ways

00:00:41,519 --> 00:00:46,469
that we can mitigate against these

00:00:43,230 --> 00:00:48,120
issues so looking at techniques for

00:00:46,469 --> 00:00:51,089
finding types that have more precise

00:00:48,120 --> 00:00:52,649
meaning ways we can define functions so

00:00:51,089 --> 00:00:56,489
they only work over the intended input

00:00:52,649 --> 00:00:58,679
and output and then looking at what a

00:00:56,489 --> 00:01:01,679
called refinement types and opaque types

00:00:58,679 --> 00:01:03,739
so sections 2 & 3 should be things that

00:01:01,679 --> 00:01:06,180
you can easily use in your own code

00:01:03,739 --> 00:01:09,330
section 4 is a library you can add your

00:01:06,180 --> 00:01:11,670
code but you might find some challenges

00:01:09,330 --> 00:01:13,520
adding it in it's a little if departure

00:01:11,670 --> 00:01:16,020
from what most people are used to and

00:01:13,520 --> 00:01:18,120
section 5 is something that's in

00:01:16,020 --> 00:01:20,820
currently a Scala improvement process

00:01:18,120 --> 00:01:22,200
sip so it's not something we can use now

00:01:20,820 --> 00:01:25,980
but hopefully something will be able to

00:01:22,200 --> 00:01:29,220
use in the relatively near future all

00:01:25,980 --> 00:01:31,200
right so first let's look at evil what

00:01:29,220 --> 00:01:33,360
is evil evil is something profoundly

00:01:31,200 --> 00:01:34,950
wicked or malevolent according to the

00:01:33,360 --> 00:01:36,290
dictionary I looked at or maybe the

00:01:34,950 --> 00:01:38,820
dictionary hadn't worked out who knows

00:01:36,290 --> 00:01:42,150
and in the code in our code what this is

00:01:38,820 --> 00:01:43,740
is ways that bugs into our code ways

00:01:42,150 --> 00:01:45,450
that we don't get out against the

00:01:43,740 --> 00:01:49,020
wickedness of bugs getting into our

00:01:45,450 --> 00:01:51,960
courage so let's have an example so say

00:01:49,020 --> 00:01:55,560
I have the number 12 some in my code the

00:01:51,960 --> 00:01:57,900
question comes 12 what what does this 12

00:01:55,560 --> 00:01:59,100
actually mean and they're different

00:01:57,900 --> 00:02:02,070
constraints depending on the meaning

00:01:59,100 --> 00:02:03,630
here so like is it 1280 the year 12 ad

00:02:02,070 --> 00:02:05,670
why all that has some meaning

00:02:03,630 --> 00:02:07,530
it means you can have negative years I

00:02:05,670 --> 00:02:10,830
guess if they are representing times

00:02:07,530 --> 00:02:13,019
before ad BC it also means you probably

00:02:10,830 --> 00:02:14,569
have some funky handling around the bc

00:02:13,019 --> 00:02:17,040
AC divide cause there's kind of like a

00:02:14,569 --> 00:02:17,940
33 35 year gap so it's not already

00:02:17,040 --> 00:02:18,990
covered in

00:02:17,940 --> 00:02:20,430
calendar and there's various

00:02:18,990 --> 00:02:22,290
counter-reformation in that which are

00:02:20,430 --> 00:02:24,960
going to mess up the meanings of this

00:02:22,290 --> 00:02:27,480
number so representing a year as an

00:02:24,960 --> 00:02:29,700
integer is open yourself up to a lot of

00:02:27,480 --> 00:02:31,590
issues a lot of problems what does it

00:02:29,700 --> 00:02:33,450
mean to take away thirteen from this you

00:02:31,590 --> 00:02:35,940
get minus one BC or do you get to some

00:02:33,450 --> 00:02:41,120
kind of thing that we don't really have

00:02:35,940 --> 00:02:44,340
a name for what if you had twelve bits

00:02:41,120 --> 00:02:46,500
right so what bits can only be positive

00:02:44,340 --> 00:02:49,080
zero positive you can't have negative

00:02:46,500 --> 00:02:50,850
bits that doesn't really make sense in

00:02:49,080 --> 00:02:53,340
most applications at least we're talking

00:02:50,850 --> 00:02:56,430
about a computer maybe it makes sense in

00:02:53,340 --> 00:02:58,350
the information theory um you probably

00:02:56,430 --> 00:03:00,860
have some other constraints here like

00:02:58,350 --> 00:03:02,790
for example if you're talking about AI

00:03:00,860 --> 00:03:04,020
computer maybe when you get to eight

00:03:02,790 --> 00:03:06,120
bits you want to turn that into a byte

00:03:04,020 --> 00:03:08,310
type maybe you're talking about the word

00:03:06,120 --> 00:03:10,440
size in your computer 64 bits so

00:03:08,310 --> 00:03:12,840
anything more than 64 bits is not a

00:03:10,440 --> 00:03:17,340
valid number to have here so some more

00:03:12,840 --> 00:03:19,020
constraints in there what it needs

00:03:17,340 --> 00:03:20,880
twelve kittens well kitten is course are

00:03:19,020 --> 00:03:21,980
always positive no evil introduced like

00:03:20,880 --> 00:03:23,910
kittens

00:03:21,980 --> 00:03:27,300
perhaps they introduced capriciousness

00:03:23,910 --> 00:03:29,580
and holes in your curtains as they did

00:03:27,300 --> 00:03:33,200
for me but again they're constraints

00:03:29,580 --> 00:03:35,940
here of course that kittens must be

00:03:33,200 --> 00:03:37,080
greater than zero zero greater and I

00:03:35,940 --> 00:03:38,490
think twelve kittens is probably pushing

00:03:37,080 --> 00:03:43,680
the limit of how many kittens you'd want

00:03:38,490 --> 00:03:45,450
to have in one spot at once so these are

00:03:43,680 --> 00:03:48,330
all issues you will have if you're just

00:03:45,450 --> 00:03:49,739
using the unadorned type int what are

00:03:48,330 --> 00:03:51,750
you actually representing here what are

00:03:49,739 --> 00:03:54,630
the constraints it's very rare that you

00:03:51,750 --> 00:03:57,239
actually want to represent integer 32

00:03:54,630 --> 00:04:02,730
bits two's complement and where you go

00:03:57,239 --> 00:04:04,920
so integer is evil or int is evil it's a

00:04:02,730 --> 00:04:08,820
way that bugs can get into our code and

00:04:04,920 --> 00:04:10,500
we want to guard against that have

00:04:08,820 --> 00:04:12,570
another example let's say representing

00:04:10,500 --> 00:04:14,550
dates this is something you probably do

00:04:12,570 --> 00:04:15,750
like say Jason which is a very

00:04:14,550 --> 00:04:18,060
impoverished format has no

00:04:15,750 --> 00:04:20,310
representation of dates has strings so

00:04:18,060 --> 00:04:22,740
here you are using strings and you've

00:04:20,310 --> 00:04:23,840
got some nice I Triple E format I can't

00:04:22,740 --> 00:04:27,919
remember the number that goes with it

00:04:23,840 --> 00:04:29,930
for representing dates so all seems good

00:04:27,919 --> 00:04:31,800
so you can represent a day like this

00:04:29,930 --> 00:04:32,940
what we can represent at

00:04:31,800 --> 00:04:35,789
like that there lots of different ways

00:04:32,940 --> 00:04:37,349
of representing dates well here we go is

00:04:35,789 --> 00:04:38,970
a perfectly fine representation of a

00:04:37,349 --> 00:04:42,120
date but it's not actually a valid date

00:04:38,970 --> 00:04:44,699
February the 31st doesn't exist now

00:04:42,120 --> 00:04:48,330
Canada okay so that's one sort of source

00:04:44,699 --> 00:04:49,680
of problems you can have another thing

00:04:48,330 --> 00:04:51,690
well this is a nice format you can

00:04:49,680 --> 00:04:58,139
represent time zones so you only need to

00:04:51,690 --> 00:05:02,159
put a time zone on + 2 that's Berlin 0

00:04:58,139 --> 00:05:03,569
back where I live in the UK and you have

00:05:02,159 --> 00:05:06,270
lots of various options here but it

00:05:03,569 --> 00:05:08,069
complexity and you get this kind of

00:05:06,270 --> 00:05:10,289
problem if you don't actually specify I

00:05:08,069 --> 00:05:11,940
love time zone there to be interpreted

00:05:10,289 --> 00:05:13,650
in the users time zone we have different

00:05:11,940 --> 00:05:15,180
time zones if you're living in Germany

00:05:13,650 --> 00:05:18,830
I'm in the UK let me have different time

00:05:15,180 --> 00:05:21,330
zone so again failing to specify this is

00:05:18,830 --> 00:05:24,930
a way of letting bugs into your program

00:05:21,330 --> 00:05:30,000
so I've see that on the dorm strings are

00:05:24,930 --> 00:05:35,940
another way that evil sneaks in to our

00:05:30,000 --> 00:05:38,009
program ok let's look at something else

00:05:35,940 --> 00:05:40,020
I just used a type alias here to give a

00:05:38,009 --> 00:05:42,029
little bit of meaning to what we're

00:05:40,020 --> 00:05:43,949
doing so let's say we're doing something

00:05:42,029 --> 00:05:47,340
with our CSV we're generating CSV data

00:05:43,949 --> 00:05:52,110
and we're going to turn a list of CSV

00:05:47,340 --> 00:05:55,039
columns into a row of CSV so just get

00:05:52,110 --> 00:05:57,690
our list catenate a bunch of commas

00:05:55,039 --> 00:06:01,560
between all the elements and away we go

00:05:57,690 --> 00:06:04,050
that seems nice but again we've got a

00:06:01,560 --> 00:06:06,719
problem here and that problem is we

00:06:04,050 --> 00:06:08,520
haven't worried about quoting or issues

00:06:06,719 --> 00:06:10,229
you get the CSV so if someone passes in

00:06:08,520 --> 00:06:13,620
this string oops

00:06:10,229 --> 00:06:17,639
we now have a four column CSV row we

00:06:13,620 --> 00:06:20,490
expect to have a three column one list

00:06:17,639 --> 00:06:25,650
of string really evil you got two things

00:06:20,490 --> 00:06:28,379
in there you've got list type which

00:06:25,650 --> 00:06:30,539
often represents more than you want you

00:06:28,379 --> 00:06:33,180
really want to have this CSV row of any

00:06:30,539 --> 00:06:37,169
kind of arbitrary size and you got

00:06:33,180 --> 00:06:40,949
string as well so the general problem we

00:06:37,169 --> 00:06:43,830
have here is that working with printer

00:06:40,949 --> 00:06:45,689
types they're generally too broad

00:06:43,830 --> 00:06:47,519
they represent too many possible values

00:06:45,689 --> 00:06:49,769
they don't constrain the value to the

00:06:47,519 --> 00:06:52,229
actual the domain that we're working

00:06:49,769 --> 00:06:55,709
with am I doing that they allow us to

00:06:52,229 --> 00:06:58,229
make mistakes you say bugs will sneak it

00:06:55,709 --> 00:07:03,989
there's a bug right there sneaking in in

00:06:58,229 --> 00:07:05,849
this string play bugs will sneak in so

00:07:03,989 --> 00:07:09,949
what we really want to do is we want to

00:07:05,849 --> 00:07:13,619
make it impossible to represent these

00:07:09,949 --> 00:07:16,769
invalid values independent states are

00:07:13,619 --> 00:07:21,089
sometimes in call making it possible to

00:07:16,769 --> 00:07:24,179
construct them give the set of legal

00:07:21,089 --> 00:07:27,059
values a name which is a type and then

00:07:24,179 --> 00:07:29,099
we only construct values of the type of

00:07:27,059 --> 00:07:30,389
interests so if we're really dealing

00:07:29,099 --> 00:07:32,789
with kittens they're gonna be positive

00:07:30,389 --> 00:07:35,459
that numbers we're really dealing with

00:07:32,789 --> 00:07:38,189
years and we probably have some smart

00:07:35,459 --> 00:07:41,579
handling of them just in between ad and

00:07:38,189 --> 00:07:44,819
BC and so on and what we're gonna see is

00:07:41,579 --> 00:07:47,519
that this is actually fairly hard to do

00:07:44,819 --> 00:07:53,639
correctly so let's look at some

00:07:47,519 --> 00:07:57,599
techniques for doing this so types take

00:07:53,639 --> 00:07:59,879
as an example a UUID whose use UUID is

00:07:57,599 --> 00:08:01,379
in their code okay most times going up

00:07:59,879 --> 00:08:06,509
so you basically know they are there

00:08:01,379 --> 00:08:08,099
128 bits they are generally unique all

00:08:06,509 --> 00:08:10,679
practical purpose is a unique except for

00:08:08,099 --> 00:08:12,209
they're not and you're ever useful for

00:08:10,679 --> 00:08:13,499
representing things like database keys

00:08:12,209 --> 00:08:15,300
in there because they're not necessary

00:08:13,499 --> 00:08:18,209
sequentially allocated they don't leave

00:08:15,300 --> 00:08:21,179
you open to people attacking your

00:08:18,209 --> 00:08:23,610
database by reading through an ordered

00:08:21,179 --> 00:08:24,809
sequence and they're also useful in

00:08:23,610 --> 00:08:27,059
things like distributed systems and so

00:08:24,809 --> 00:08:28,679
on you can add new nodes to your

00:08:27,059 --> 00:08:30,329
eventually consistent cluster if you

00:08:28,679 --> 00:08:31,769
want to do that type of thing and you

00:08:30,329 --> 00:08:33,509
don't need to renumber everything

00:08:31,769 --> 00:08:38,250
because you use some kind of naive

00:08:33,509 --> 00:08:40,680
hashing algorithm so you IDs useful

00:08:38,250 --> 00:08:44,159
thing you've all used them saved so

00:08:40,680 --> 00:08:46,709
that's great now the typical way of

00:08:44,159 --> 00:08:48,600
representing them in our computer is we

00:08:46,709 --> 00:08:50,040
normally have like kind of string have

00:08:48,600 --> 00:08:53,279
you seen up here some kind of string

00:08:50,040 --> 00:08:55,559
representation so what we might think is

00:08:53,279 --> 00:08:58,750
well easiest way to do that it's just to

00:08:55,559 --> 00:09:04,310
clear a type alias type UID equals

00:08:58,750 --> 00:09:06,200
now if you're gonna do virtually nothing

00:09:04,310 --> 00:09:09,350
to improve your codebase from using

00:09:06,200 --> 00:09:11,690
string this is probably the first thing

00:09:09,350 --> 00:09:15,530
you can do now the great thing about

00:09:11,690 --> 00:09:18,290
having like this type alias is that most

00:09:15,530 --> 00:09:19,550
people are okay adopting them you're not

00:09:18,290 --> 00:09:21,410
introducing a new technique your

00:09:19,550 --> 00:09:23,150
co-workers you're probably not going to

00:09:21,410 --> 00:09:25,220
get a lot of pushback you can probably

00:09:23,150 --> 00:09:26,480
get people to do this it does provide a

00:09:25,220 --> 00:09:30,320
benefit provide a bit of documentation

00:09:26,480 --> 00:09:32,150
to the reader saying hey this is not a

00:09:30,320 --> 00:09:34,280
strengths UID so they might think well I

00:09:32,150 --> 00:09:36,770
should only do like UUID things to them

00:09:34,280 --> 00:09:38,770
I shouldn't be concatenating strings you

00:09:36,770 --> 00:09:42,080
know concatenate new ideas for example

00:09:38,770 --> 00:09:43,910
nonsensical the big problem here though

00:09:42,080 --> 00:09:44,510
is that as far as the compiler is

00:09:43,910 --> 00:09:48,110
concerned

00:09:44,510 --> 00:09:50,180
UID UUID and string are the same thing

00:09:48,110 --> 00:09:51,890
so it's not going to prevent you from

00:09:50,180 --> 00:09:53,930
concatenate in you IDs

00:09:51,890 --> 00:09:56,690
it's not going to warn you when you use

00:09:53,930 --> 00:10:00,020
them incorrectly this is really only a

00:09:56,690 --> 00:10:02,780
hint to the programmer not going to get

00:10:00,020 --> 00:10:04,940
the compiler help you avoid bugs but

00:10:02,780 --> 00:10:09,380
nonetheless if you do nothing else this

00:10:04,940 --> 00:10:12,590
is probably a good good first step right

00:10:09,380 --> 00:10:15,650
so the next kind of real step might be

00:10:12,590 --> 00:10:17,180
say creating like a case class ok so

00:10:15,650 --> 00:10:20,720
we're gonna wrap up how strings in you

00:10:17,180 --> 00:10:22,100
IDs and where we go it's a very very

00:10:20,720 --> 00:10:24,410
basic thing to do I think most girl

00:10:22,100 --> 00:10:25,760
programs are happy with place classes

00:10:24,410 --> 00:10:27,080
we've actually got something the

00:10:25,760 --> 00:10:29,000
compiler will check and you have to have

00:10:27,080 --> 00:10:31,700
a little bit more attention to the way

00:10:29,000 --> 00:10:34,250
you're manipulating it still not very

00:10:31,700 --> 00:10:36,130
powerful though when you construct one

00:10:34,250 --> 00:10:38,120
of these you're not checking that the

00:10:36,130 --> 00:10:40,100
string you're putting in there actually

00:10:38,120 --> 00:10:41,240
is a valid UID there's nothing

00:10:40,100 --> 00:10:42,680
preventing people from just pulling out

00:10:41,240 --> 00:10:43,820
string out and doing naughty things to

00:10:42,680 --> 00:10:45,950
it

00:10:43,820 --> 00:10:47,390
and adding some runtime overhead so now

00:10:45,950 --> 00:10:49,900
we have to allocate not just the string

00:10:47,390 --> 00:10:53,090
but this wrapper for this case class

00:10:49,900 --> 00:10:56,090
wrapper so adding a bit of overhead

00:10:53,090 --> 00:10:59,450
there that's 16 bytes for each kind of

00:10:56,090 --> 00:11:03,410
basic object in Java around the JVM

00:10:59,450 --> 00:11:05,000
should say so one thing we might think

00:11:03,410 --> 00:11:08,980
of is well can we remove this runtime

00:11:05,000 --> 00:11:11,120
overhead maybe extend any Val like so

00:11:08,980 --> 00:11:12,140
and it's basically just like the case

00:11:11,120 --> 00:11:15,020
class we saw earlier

00:11:12,140 --> 00:11:16,970
now in theory we don't have any we don't

00:11:15,020 --> 00:11:19,430
have the runtime overhead but in

00:11:16,970 --> 00:11:20,680
practice we're very unlikely to see much

00:11:19,430 --> 00:11:24,650
benefit from this

00:11:20,680 --> 00:11:26,720
so although an eval was introduced to

00:11:24,650 --> 00:11:28,640
avoid runtime overhead and in some cases

00:11:26,720 --> 00:11:31,730
it does my experience is it doesn't

00:11:28,640 --> 00:11:37,370
really give you much benefit in terms of

00:11:31,730 --> 00:11:39,470
random overhead so I've said any valves

00:11:37,370 --> 00:11:42,800
in the toolbox but it's not really

00:11:39,470 --> 00:11:44,630
something I find too too useful so we're

00:11:42,800 --> 00:11:46,130
going to go talk too much about what

00:11:44,630 --> 00:11:49,570
comes next so a lot of techniques I'll

00:11:46,130 --> 00:11:53,690
show you can use extending any valve

00:11:49,570 --> 00:11:56,690
alright so let's move on to something

00:11:53,690 --> 00:11:58,880
that's actually going to give us some

00:11:56,690 --> 00:12:01,310
some real benefit so what we do here to

00:11:58,880 --> 00:12:03,380
make the constructor private and now you

00:12:01,310 --> 00:12:05,690
can only construct you IDs by going

00:12:03,380 --> 00:12:08,390
through this this method you apply

00:12:05,690 --> 00:12:10,820
method here so this returns an option of

00:12:08,390 --> 00:12:12,680
UUID so it's indicating well maybe I can

00:12:10,820 --> 00:12:14,450
construct a UID from string you give me

00:12:12,680 --> 00:12:16,010
or maybe it's an invalid string I'm

00:12:14,450 --> 00:12:19,010
gonna give you none back instead and

00:12:16,010 --> 00:12:21,560
then you have to do something so if we

00:12:19,010 --> 00:12:23,920
try to construct I think that doesn't

00:12:21,560 --> 00:12:26,150
work we try to construct like this

00:12:23,920 --> 00:12:28,280
hopefully we'll get back like none in

00:12:26,150 --> 00:12:30,530
this case so you're making explicit to

00:12:28,280 --> 00:12:33,950
the programmer that if you go from a

00:12:30,530 --> 00:12:35,480
string to UID you could be making a

00:12:33,950 --> 00:12:39,650
mistake and you need to think about what

00:12:35,480 --> 00:12:40,240
you do in the case of an error so that's

00:12:39,650 --> 00:12:42,710
good

00:12:40,240 --> 00:12:45,470
one problem with case classes is that

00:12:42,710 --> 00:12:48,890
you still have the coffee constructor

00:12:45,470 --> 00:12:52,190
available you can still call copy and

00:12:48,890 --> 00:12:58,430
put sneak in some invalid values that

00:12:52,190 --> 00:13:03,860
way that's our evil laugh there I like

00:12:58,430 --> 00:13:05,540
it you'd have to go to a little bit of

00:13:03,860 --> 00:13:07,730
effort to do that but it's still a

00:13:05,540 --> 00:13:11,240
possibility sort of like to count

00:13:07,730 --> 00:13:14,750
against it so just running down the pros

00:13:11,240 --> 00:13:16,430
and cons we've got one place where we're

00:13:14,750 --> 00:13:19,130
validating our input which is great you

00:13:16,430 --> 00:13:21,980
can't create invalid you IDs by by

00:13:19,130 --> 00:13:24,140
construction but you can still copy them

00:13:21,980 --> 00:13:25,490
and mess them up and the other thing is

00:13:24,140 --> 00:13:26,240
you've got these options all those

00:13:25,490 --> 00:13:28,850
you're okay

00:13:26,240 --> 00:13:30,950
and to some extent as possibly

00:13:28,850 --> 00:13:32,720
unavoidable but at least in the case

00:13:30,950 --> 00:13:34,010
where you have like a literal UUID if

00:13:32,720 --> 00:13:35,570
you have such a thing it'd be nice to be

00:13:34,010 --> 00:13:38,510
able to avoid having to validate that

00:13:35,570 --> 00:13:43,660
I've made a validator at compile time so

00:13:38,510 --> 00:13:46,490
that's that's an issue we have here so

00:13:43,660 --> 00:13:48,040
let's move on to our next technique I

00:13:46,490 --> 00:13:50,960
think everything I've shown here is

00:13:48,040 --> 00:13:54,470
probably fairly standard this where it

00:13:50,960 --> 00:13:57,080
becomes a little bit odd sealed abstract

00:13:54,470 --> 00:14:00,340
case class UID who's seen this before

00:13:57,080 --> 00:14:02,240
hey if you keep loud that's cool okay so

00:14:00,340 --> 00:14:04,390
it's a bit of a brain bender when you

00:14:02,240 --> 00:14:08,300
first see it what does it actually do

00:14:04,390 --> 00:14:08,780
but if you apply you kind of reason

00:14:08,300 --> 00:14:10,760
about it

00:14:08,780 --> 00:14:13,820
so sealed means you cannot extend this

00:14:10,760 --> 00:14:16,370
case class except for in this in the

00:14:13,820 --> 00:14:17,990
file it defined abstract means you

00:14:16,370 --> 00:14:20,300
cannot instantiate this case class

00:14:17,990 --> 00:14:22,580
directly the case class means it's the

00:14:20,300 --> 00:14:27,320
case class and it's got the usual kind

00:14:22,580 --> 00:14:29,380
of pattern matching stuff on it and you

00:14:27,320 --> 00:14:34,850
know the equals and hashcode and so on

00:14:29,380 --> 00:14:36,560
so we can only extend it in this file we

00:14:34,850 --> 00:14:38,330
can't instantiate this this case class

00:14:36,560 --> 00:14:40,910
directly because abstract so it has no

00:14:38,330 --> 00:14:45,920
constructor and it's not going to get a

00:14:40,910 --> 00:14:48,380
copy method either so the other thing

00:14:45,920 --> 00:14:51,020
you can you can extend a case class with

00:14:48,380 --> 00:14:53,300
a class or an anonymous class for

00:14:51,020 --> 00:14:56,000
example so in this file we can actually

00:14:53,300 --> 00:14:57,110
construct instances so in an apply

00:14:56,000 --> 00:15:00,050
method which the thing we had before

00:14:57,110 --> 00:15:01,760
where you can construct a subclass know

00:15:00,050 --> 00:15:05,870
when you're doing naanum asleep there

00:15:01,760 --> 00:15:08,630
going a new the new UUID if you

00:15:05,870 --> 00:15:11,420
construct an anonymous subtype and we

00:15:08,630 --> 00:15:14,300
can construct an instance here we don't

00:15:11,420 --> 00:15:14,780
have a copy method anymore so that's

00:15:14,300 --> 00:15:17,570
good

00:15:14,780 --> 00:15:19,130
so this kind of strange construction is

00:15:17,570 --> 00:15:22,580
essentially a way of getting a private

00:15:19,130 --> 00:15:25,370
constructor and removing the copy method

00:15:22,580 --> 00:15:25,970
that's what it gives us a little bit

00:15:25,370 --> 00:15:33,670
goofy

00:15:25,970 --> 00:15:33,670
welcome to Scala that's how we roll so

00:15:34,320 --> 00:15:38,490
what are we doing well it's got all the

00:15:36,420 --> 00:15:40,170
the the benefits of what we did before

00:15:38,490 --> 00:15:42,870
with the case class in the private

00:15:40,170 --> 00:15:45,680
constructor now we don't have a coffee

00:15:42,870 --> 00:15:49,560
method we're not leaking that anymore

00:15:45,680 --> 00:15:50,910
the bad parts one is you may have to

00:15:49,560 --> 00:15:53,100
explain to your co-workers what this

00:15:50,910 --> 00:15:54,240
thing is that could be an issue you

00:15:53,100 --> 00:15:57,270
could get some pushback there about

00:15:54,240 --> 00:15:58,920
people introducing this well I just

00:15:57,270 --> 00:16:01,530
think it's not too crazy when you when

00:15:58,920 --> 00:16:04,770
you understand it and I hope you didn't

00:16:01,530 --> 00:16:06,540
take too long to explain and still we

00:16:04,770 --> 00:16:08,970
have these options everywhere which is

00:16:06,540 --> 00:16:10,590
annoying when we have literals in our

00:16:08,970 --> 00:16:13,040
code would like the compiler to check

00:16:10,590 --> 00:16:13,040
those for us

00:16:13,310 --> 00:16:18,600
this is the end of what I'm going to

00:16:16,950 --> 00:16:23,630
talk about our basic techniques for

00:16:18,600 --> 00:16:27,330
validating for creating safe data in

00:16:23,630 --> 00:16:28,650
Scala so these are stuff you can do with

00:16:27,330 --> 00:16:31,050
the tools you have now without

00:16:28,650 --> 00:16:33,350
introducing anything that's gonna get

00:16:31,050 --> 00:16:38,040
too much pushback from your colleagues

00:16:33,350 --> 00:16:39,660
let's move on now to functions okay so

00:16:38,040 --> 00:16:42,450
the other part this is we looked at

00:16:39,660 --> 00:16:49,380
creating data now we look at making our

00:16:42,450 --> 00:16:53,190
functions as safer so we go to this bit

00:16:49,380 --> 00:16:54,510
of a rendering bug there so the example

00:16:53,190 --> 00:16:57,750
we've seen you can't count all strings

00:16:54,510 --> 00:17:02,550
be converted to uu IDs and the answer of

00:16:57,750 --> 00:17:05,420
course is no they cannot so when you had

00:17:02,550 --> 00:17:08,699
this situation when the input type is

00:17:05,420 --> 00:17:09,959
bigger than the output type so there are

00:17:08,699 --> 00:17:13,079
elements of the input type that don't

00:17:09,959 --> 00:17:15,030
map to the output type somehow one way

00:17:13,079 --> 00:17:17,880
to handle this of course is to widen the

00:17:15,030 --> 00:17:20,850
output type so instead of returning a u

00:17:17,880 --> 00:17:22,290
I do return an option this avoids the

00:17:20,850 --> 00:17:23,640
only other thing you do the situations

00:17:22,290 --> 00:17:25,770
ready to throw an exception and that's

00:17:23,640 --> 00:17:27,180
not it's not visible to the type checker

00:17:25,770 --> 00:17:28,800
it's not visible to the program as a

00:17:27,180 --> 00:17:31,590
result you're relying on the program to

00:17:28,800 --> 00:17:32,400
check in exceptions being thrown so this

00:17:31,590 --> 00:17:34,320
is what we've done in the previous

00:17:32,400 --> 00:17:40,680
example where they construct it

00:17:34,320 --> 00:17:41,880
returning an option okay so this is like

00:17:40,680 --> 00:17:43,260
a good general technique if you have

00:17:41,880 --> 00:17:44,760
what's called a partial function and a

00:17:43,260 --> 00:17:46,590
function is not defined on its entire

00:17:44,760 --> 00:17:48,120
input so that's a partial function in

00:17:46,590 --> 00:17:50,130
the mathematics sense not in the

00:17:48,120 --> 00:17:54,059
Scala scent which is a slightly

00:17:50,130 --> 00:17:56,850
different thing then you can get rid of

00:17:54,059 --> 00:17:58,710
that partiality if you like it by

00:17:56,850 --> 00:18:00,450
widening the output type to include

00:17:58,710 --> 00:18:01,590
these error case so a good general

00:18:00,450 --> 00:18:04,920
technique but maybe we can go a little

00:18:01,590 --> 00:18:07,830
bit further the first thing you want to

00:18:04,920 --> 00:18:10,470
do is to say well string is basically a

00:18:07,830 --> 00:18:11,670
list of characters okay so we just make

00:18:10,470 --> 00:18:13,410
this transformation list of characters

00:18:11,670 --> 00:18:17,010
not adding anything here just helping us

00:18:13,410 --> 00:18:18,240
on the road that we'll be going now

00:18:17,010 --> 00:18:19,920
something we know for sure when you're

00:18:18,240 --> 00:18:22,860
creating a UID is you can't create one

00:18:19,920 --> 00:18:24,890
from the empty string so we can add that

00:18:22,860 --> 00:18:27,390
constraint in into the type system a

00:18:24,890 --> 00:18:29,400
non-empty list of characters and this is

00:18:27,390 --> 00:18:33,750
a type you'll find in cats or a type you

00:18:29,400 --> 00:18:36,720
can find in scarlet z as well I think so

00:18:33,750 --> 00:18:38,340
it's not something which is too esoteric

00:18:36,720 --> 00:18:40,559
nor something that you have to look too

00:18:38,340 --> 00:18:42,570
far to find it's okay so we've got rid

00:18:40,559 --> 00:18:45,630
of least one possible error there the

00:18:42,570 --> 00:18:48,510
empty string and the next thing to say

00:18:45,630 --> 00:18:50,910
is well this is not a list of characters

00:18:48,510 --> 00:18:52,710
any old character it's a list of hex

00:18:50,910 --> 00:18:54,290
digits so we could define a type for

00:18:52,710 --> 00:18:57,510
that it's a simple serving numeration

00:18:54,290 --> 00:18:59,610
you know one two nine zero nine eight or

00:18:57,510 --> 00:19:01,920
F those as only valid types and then

00:18:59,610 --> 00:19:02,429
we've got rid of a whole new whole class

00:19:01,920 --> 00:19:04,380
of errors

00:19:02,429 --> 00:19:06,630
you can't put crazy unicode characters

00:19:04,380 --> 00:19:10,340
in here anymore and expect stuff to work

00:19:06,630 --> 00:19:13,470
so narrowing the input type down further

00:19:10,340 --> 00:19:15,900
and if we could completely narrow down

00:19:13,470 --> 00:19:22,770
the input type well it has to be 32 hex

00:19:15,900 --> 00:19:25,620
digits well then we could remove the

00:19:22,770 --> 00:19:27,059
option because if we can constrain down

00:19:25,620 --> 00:19:29,190
the input type to exactly match the

00:19:27,059 --> 00:19:32,630
things we can actually construct then we

00:19:29,190 --> 00:19:39,000
could we wouldn't have this issue

00:19:32,630 --> 00:19:41,220
anymore so general technique for

00:19:39,000 --> 00:19:45,360
handling for functions to make them

00:19:41,220 --> 00:19:47,040
safer to have less errors is consider do

00:19:45,360 --> 00:19:49,230
you need to widen the output type are

00:19:47,040 --> 00:19:50,790
there more things in the input type

00:19:49,230 --> 00:19:52,320
thing can be representing the output in

00:19:50,790 --> 00:19:55,140
which case maybe widen it by returning

00:19:52,320 --> 00:19:56,550
an either or an option or even better

00:19:55,140 --> 00:19:58,560
can you if that's the case can you

00:19:56,550 --> 00:19:59,910
narrow down the input type so they're

00:19:58,560 --> 00:20:02,070
not as so many

00:19:59,910 --> 00:20:05,340
puts air which are invalid and get rid

00:20:02,070 --> 00:20:06,990
of some of them and if you can do that

00:20:05,340 --> 00:20:09,140
far enough then you can get rid of that

00:20:06,990 --> 00:20:11,430
widening on the output it's no longer

00:20:09,140 --> 00:20:16,650
because errors are no longer possible in

00:20:11,430 --> 00:20:21,810
this way no so that's basic techniques

00:20:16,650 --> 00:20:24,660
for handling these issues now I want to

00:20:21,810 --> 00:20:27,600
switch and look at a library for

00:20:24,660 --> 00:20:29,040
refinement types so this is something a

00:20:27,600 --> 00:20:30,240
little bit further from what I've been

00:20:29,040 --> 00:20:32,010
talking about it's not sort of cool

00:20:30,240 --> 00:20:33,750
scholar anymore but it is something you

00:20:32,010 --> 00:20:37,350
can download and you can use in your

00:20:33,750 --> 00:20:40,770
code today so what is the refinements

00:20:37,350 --> 00:20:45,390
I've a fiber type is a type along with

00:20:40,770 --> 00:20:46,800
some kind of predicate so you take a

00:20:45,390 --> 00:20:48,480
basic type you refine it with a

00:20:46,800 --> 00:20:51,240
predicate and we assume the predicate

00:20:48,480 --> 00:20:54,720
holds any member of this refined type

00:20:51,240 --> 00:20:57,780
and you can grab the library from yeah

00:20:54,720 --> 00:21:00,270
after almost refined okay so that's an

00:20:57,780 --> 00:21:03,000
example what does this look like here's

00:21:00,270 --> 00:21:05,610
a very simple example int refined

00:21:03,000 --> 00:21:07,860
positive you can probably read that and

00:21:05,610 --> 00:21:11,880
let's go through it what it means saying

00:21:07,860 --> 00:21:16,140
the base type is int it's refined by the

00:21:11,880 --> 00:21:19,050
predicate positive and you imagine that

00:21:16,140 --> 00:21:20,250
means any int greater than zero it's a

00:21:19,050 --> 00:21:23,540
great time for representing kittens

00:21:20,250 --> 00:21:23,540
because you said kittens always positive

00:21:23,810 --> 00:21:29,820
okay now one of the thing is really nice

00:21:26,430 --> 00:21:33,030
about this is we could check this a

00:21:29,820 --> 00:21:34,710
compile time so we don't have these

00:21:33,030 --> 00:21:36,000
options or either as everywhere and I

00:21:34,710 --> 00:21:38,460
carried anymore at least not for

00:21:36,000 --> 00:21:39,750
literals you can't just run two values

00:21:38,460 --> 00:21:42,990
with training no runtime but certainly

00:21:39,750 --> 00:21:45,300
felt literals like this got rid of that

00:21:42,990 --> 00:21:48,110
error case so it doesn't compile anymore

00:21:45,300 --> 00:21:50,430
if the code is incorrect which is great

00:21:48,110 --> 00:21:53,790
the other thing that's nice is that we

00:21:50,430 --> 00:21:55,290
have mostly no runtime overhead I say

00:21:53,790 --> 00:21:57,350
mostly because there can be cases I

00:21:55,290 --> 00:22:00,750
think primitive types could get boxed

00:21:57,350 --> 00:22:02,100
I'm not sure of all the details of

00:22:00,750 --> 00:22:03,900
performance I know that primitives will

00:22:02,100 --> 00:22:08,100
be boxed this will probably box but

00:22:03,900 --> 00:22:10,670
other types won't be so when we have

00:22:08,100 --> 00:22:12,360
like an invalid literal like minus five

00:22:10,670 --> 00:22:15,330
yeah

00:22:12,360 --> 00:22:22,940
five grand in zero I have a second part

00:22:15,330 --> 00:22:26,760
I'd now what about runtime so at runtime

00:22:22,940 --> 00:22:30,240
well we don't know what X is we need to

00:22:26,760 --> 00:22:32,549
refine it and this could introduce an

00:22:30,240 --> 00:22:35,250
error case so in this case we're getting

00:22:32,549 --> 00:22:37,860
back and either a string telling us

00:22:35,250 --> 00:22:41,670
about the error or we get the refined in

00:22:37,860 --> 00:22:44,860
back and and for T to work so is it

00:22:41,670 --> 00:22:46,580
going to be right so we still have to

00:22:44,860 --> 00:22:49,169
[Music]

00:22:46,580 --> 00:22:52,169
have this possibility of error in our

00:22:49,169 --> 00:22:55,169
code when we're not dealing literals but

00:22:52,169 --> 00:22:56,940
I don't really see a way around that

00:22:55,169 --> 00:22:59,820
hopefully we can push these out to the

00:22:56,940 --> 00:23:02,400
edges of our system once because once

00:22:59,820 --> 00:23:04,410
you've refined the type because yeah

00:23:02,400 --> 00:23:05,640
that type hold and you know is even or

00:23:04,410 --> 00:23:09,299
something which is positive so you need

00:23:05,640 --> 00:23:11,520
to do is refinement at the boundaries so

00:23:09,299 --> 00:23:15,470
how expressive are these refinement

00:23:11,520 --> 00:23:19,140
types let's have a look at some examples

00:23:15,470 --> 00:23:20,220
okay so some things you get you get like

00:23:19,140 --> 00:23:22,290
out of the box

00:23:20,220 --> 00:23:25,380
trimmed strings if you want to know they

00:23:22,290 --> 00:23:27,780
have no spaces around them you could

00:23:25,380 --> 00:23:31,080
have negations of predicates like we

00:23:27,780 --> 00:23:33,210
have not trimmed string here you have

00:23:31,080 --> 00:23:35,790
hex string so this handle out you could

00:23:33,210 --> 00:23:43,410
use to handle our case for you IDs to

00:23:35,790 --> 00:23:45,929
some extent they changed 256 so very

00:23:43,410 --> 00:23:46,950
close to the UID example and this still

00:23:45,929 --> 00:23:49,410
been checked at compile time

00:23:46,950 --> 00:23:53,179
so these literals regular expressions

00:23:49,410 --> 00:23:55,950
which i think is pretty cool and then an

00:23:53,179 --> 00:23:58,410
interesting example of like defining a

00:23:55,950 --> 00:24:02,160
much more complex predicate specifying a

00:23:58,410 --> 00:24:03,450
number is between 0 and 1 so we're

00:24:02,160 --> 00:24:07,500
saying it's not greater than 1 and it's

00:24:03,450 --> 00:24:10,590
not less than 0 and you've got a little

00:24:07,500 --> 00:24:13,860
bit of a kind of a rendering bug in here

00:24:10,590 --> 00:24:18,900
in these slides because uh yeah it's not

00:24:13,860 --> 00:24:20,790
so evil so that's um so all the ones

00:24:18,900 --> 00:24:22,200
above 0 to 1 are all things you had come

00:24:20,790 --> 00:24:23,610
out of the box so it's refined and then

00:24:22,200 --> 00:24:25,080
0 to 1 is something we construct

00:24:23,610 --> 00:24:26,040
ourselves from the tools it gives us and

00:24:25,080 --> 00:24:29,940
you can see you can suppress for

00:24:26,040 --> 00:24:34,620
it's very expressive things here sounds

00:24:29,940 --> 00:24:35,940
pretty cool so a recap refined is

00:24:34,620 --> 00:24:37,020
checking checking the literals at

00:24:35,940 --> 00:24:38,340
compile time but you're still checking

00:24:37,020 --> 00:24:39,840
the values at run times you still have

00:24:38,340 --> 00:24:41,010
those in this case either is getting in

00:24:39,840 --> 00:24:44,820
there probably better option because it

00:24:41,010 --> 00:24:46,350
tells you why it failed and one of the

00:24:44,820 --> 00:24:48,480
best things about this is you can

00:24:46,350 --> 00:24:50,700
compose a predicate to create more more

00:24:48,480 --> 00:24:52,380
complex predicates so if we wanted to we

00:24:50,700 --> 00:24:55,290
could create a protocol that expresses

00:24:52,380 --> 00:24:57,150
like the UUID type that we had 32 hex

00:24:55,290 --> 00:24:58,830
digits and we could construct out the

00:24:57,150 --> 00:25:01,230
primitive so there's a fake effectively

00:24:58,830 --> 00:25:03,210
no limit to what you can do here it just

00:25:01,230 --> 00:25:07,800
comes down to how big do you like the

00:25:03,210 --> 00:25:09,510
types to be in your code and how much

00:25:07,800 --> 00:25:14,970
compile time you have here to accept as

00:25:09,510 --> 00:25:16,950
well alright so to recap again this is a

00:25:14,970 --> 00:25:18,600
library you can download you can use it

00:25:16,950 --> 00:25:20,970
does provide a lot of extra security

00:25:18,600 --> 00:25:23,400
into your types it's a bit more of a

00:25:20,970 --> 00:25:26,070
stretch to get to for the average

00:25:23,400 --> 00:25:27,930
programmer but I don't think it's I

00:25:26,070 --> 00:25:30,540
don't think it's crazy then look at this

00:25:27,930 --> 00:25:32,820
and wonder what's going on now let's

00:25:30,540 --> 00:25:34,680
move on to something which is not

00:25:32,820 --> 00:25:37,230
available yet but hopefully will be

00:25:34,680 --> 00:25:42,600
available soon and these are opaque

00:25:37,230 --> 00:25:46,110
types so opaque types are defined in 35

00:25:42,600 --> 00:25:49,260
anyone looked at that okay a few hands

00:25:46,110 --> 00:25:52,350
going up cool so you know the basic idea

00:25:49,260 --> 00:25:56,610
here you can think of opaque types as

00:25:52,350 --> 00:25:59,850
basically being any vowel it sends any

00:25:56,610 --> 00:26:03,810
Val value classes done done right for

00:25:59,850 --> 00:26:06,030
some definition of right so neither

00:26:03,810 --> 00:26:08,610
properties I'm I like so the syntax

00:26:06,030 --> 00:26:10,650
looks like this if you define a type

00:26:08,610 --> 00:26:12,150
alias in Scala we saw that before

00:26:10,650 --> 00:26:15,540
type II you idea cuz string but you know

00:26:12,150 --> 00:26:16,770
you stick opaque in front of it and then

00:26:15,540 --> 00:26:19,530
you need to have a companion object

00:26:16,770 --> 00:26:20,820
which to find some some methods so here

00:26:19,530 --> 00:26:25,830
we have a constructor just like we saw

00:26:20,820 --> 00:26:31,050
before apply string and you get back an

00:26:25,830 --> 00:26:34,100
option of UUID so that's nice so what in

00:26:31,050 --> 00:26:36,140
particular do we go from opaque types

00:26:34,100 --> 00:26:39,480
well

00:26:36,140 --> 00:26:41,160
you can get safe construction which is

00:26:39,480 --> 00:26:43,940
great the companion object is any place

00:26:41,160 --> 00:26:47,070
you can construct them I understand it

00:26:43,940 --> 00:26:50,070
and most importantly they have no

00:26:47,070 --> 00:26:52,020
runtime overhead so and all the other

00:26:50,070 --> 00:26:54,750
situations we had possibly some runtime

00:26:52,020 --> 00:26:57,540
overhead with opaque tights when they

00:26:54,750 --> 00:27:01,740
implemented will hopefully get no

00:26:57,540 --> 00:27:04,230
runtime overhead I believe if you want

00:27:01,740 --> 00:27:06,660
to use some type tags there's a very

00:27:04,230 --> 00:27:08,040
similar technique or type tags have no

00:27:06,660 --> 00:27:10,350
runtime overhead I think it's where the

00:27:08,040 --> 00:27:11,930
cake type works comes from but I can

00:27:10,350 --> 00:27:16,080
talk about type tags too much

00:27:11,930 --> 00:27:18,270
so these opaque types really answer a

00:27:16,080 --> 00:27:20,460
lot of the problems we've had you can

00:27:18,270 --> 00:27:22,020
construct them safely no runtime

00:27:20,460 --> 00:27:25,490
overhead and you can see how you can mix

00:27:22,020 --> 00:27:27,450
them with say something like refined to

00:27:25,490 --> 00:27:30,030
construct an a compile-time from

00:27:27,450 --> 00:27:36,810
literals without here is the zero hand

00:27:30,030 --> 00:27:41,190
going up there okay all right the the

00:27:36,810 --> 00:27:45,120
big downside of course is that they're

00:27:41,190 --> 00:27:47,400
not available yet I think you can you

00:27:45,120 --> 00:27:49,620
can fake them yourself to a large extent

00:27:47,400 --> 00:27:52,880
by using and this type tag technique

00:27:49,620 --> 00:27:55,110
which I haven't talked about but I

00:27:52,880 --> 00:27:57,000
picked eyes themselves are not not

00:27:55,110 --> 00:27:59,340
available anywhere that I'm aware of

00:27:57,000 --> 00:28:02,400
I don't know if they are scheduled to be

00:27:59,340 --> 00:28:04,290
included in scarlet yet so the great

00:28:02,400 --> 00:28:08,520
thing in in my opinion solve all of

00:28:04,290 --> 00:28:09,510
these issues but not quite there so

00:28:08,520 --> 00:28:15,300
let's see if summary of what we looked

00:28:09,510 --> 00:28:17,820
at so the main point is that primitive

00:28:15,300 --> 00:28:19,200
types although they're useful because

00:28:17,820 --> 00:28:20,790
they can respond to some sort of basic

00:28:19,200 --> 00:28:24,150
things that the computer works with now

00:28:20,790 --> 00:28:25,920
they're normally much too wide much too

00:28:24,150 --> 00:28:28,140
broad come far too many values for our

00:28:25,920 --> 00:28:30,810
typical uses if you don't have unsigned

00:28:28,140 --> 00:28:32,550
integers in scala a lot of time you

00:28:30,810 --> 00:28:33,930
really do want unsigned it unsigned

00:28:32,550 --> 00:28:36,450
integers and you can't represent that

00:28:33,930 --> 00:28:37,590
safely in an integer strings of course

00:28:36,450 --> 00:28:41,160
the other place that you just throw all

00:28:37,590 --> 00:28:42,930
sorts of random garbage classic Java

00:28:41,160 --> 00:28:45,120
scripts and stuff if you throw in a Java

00:28:42,930 --> 00:28:46,890
Script you pretty seen the problems that

00:28:45,120 --> 00:28:48,000
of course are the same problems in Scala

00:28:46,890 --> 00:28:51,000
we can have them

00:28:48,000 --> 00:28:54,060
and the solution is to wrap them with

00:28:51,000 --> 00:28:56,100
our own types and we've seen various

00:28:54,060 --> 00:28:58,200
ways of doing that so at the case class

00:28:56,100 --> 00:29:02,300
case class the private constructor the

00:28:58,200 --> 00:29:04,140
sealed abstract case class and that's

00:29:02,300 --> 00:29:06,090
probably the technique that's most

00:29:04,140 --> 00:29:07,980
accessible to people and if you want to

00:29:06,090 --> 00:29:10,460
go that step further you can use this

00:29:07,980 --> 00:29:13,560
refined library and then you have

00:29:10,460 --> 00:29:16,440
reduced runtime overhead and you can get

00:29:13,560 --> 00:29:18,090
away with checking your literals at

00:29:16,440 --> 00:29:21,830
compile time it's a very nice thing to

00:29:18,090 --> 00:29:23,730
use the other thing we looked at was

00:29:21,830 --> 00:29:25,050
when you're working with function to

00:29:23,730 --> 00:29:27,180
think about the types that are going in

00:29:25,050 --> 00:29:29,370
and the types that are going out why

00:29:27,180 --> 00:29:32,130
didn't the output type of your your

00:29:29,370 --> 00:29:34,110
function if the input has more values in

00:29:32,130 --> 00:29:36,840
can be represented in the output or

00:29:34,110 --> 00:29:39,270
better yet consider narrowing the input

00:29:36,840 --> 00:29:46,890
type so that you avoid these

00:29:39,270 --> 00:29:48,210
possibilities of errors and finally so

00:29:46,890 --> 00:29:49,710
we have refinement types we looked at

00:29:48,210 --> 00:29:51,270
them they're a technique you can use

00:29:49,710 --> 00:29:53,040
right now to make your code better

00:29:51,270 --> 00:29:55,040
they're very flexible predicates so you

00:29:53,040 --> 00:29:57,480
can express with refinement types and

00:29:55,040 --> 00:30:02,890
hopefully in the future we can use

00:29:57,480 --> 00:30:07,919
opaque types as well all right thanks

00:30:02,890 --> 00:30:07,919

YouTube URL: https://www.youtube.com/watch?v=w7FuQiSi48w


