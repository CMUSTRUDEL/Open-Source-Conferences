Title: Meet bloop and get more productive with Scala by Jorge Vicente Cantero and Martin Duhem
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6925-meet-bloop-and-get-more-productive-with-scala.html
Captions: 
	00:00:04,570 --> 00:00:09,219
so this talk is gonna be about developer

00:00:07,090 --> 00:00:10,210
tools and in particular it's gonna be

00:00:09,219 --> 00:00:12,820
about group

00:00:10,210 --> 00:00:14,500
so bloop is the adven upper tool we've

00:00:12,820 --> 00:00:17,050
been working on for the past three or

00:00:14,500 --> 00:00:18,930
four months at the sky Center this is a

00:00:17,050 --> 00:00:22,239
this is a toggle it's a killer whale and

00:00:18,930 --> 00:00:24,759
I think it'll stretch very well our kind

00:00:22,239 --> 00:00:27,340
of motivation or the reason why we

00:00:24,759 --> 00:00:30,189
created bloop killer whales are one of

00:00:27,340 --> 00:00:32,079
the fastest animals in the sea and they

00:00:30,189 --> 00:00:34,960
even kill sharks which is kind of cool

00:00:32,079 --> 00:00:39,340
so it was an inspiration for for bloop

00:00:34,960 --> 00:00:40,570
and before we go into details we're

00:00:39,340 --> 00:00:43,600
gonna introduce ourselves

00:00:40,570 --> 00:00:45,670
so I'm Jorge and I am a dev tools

00:00:43,600 --> 00:00:47,920
engineer at the sky Center for the past

00:00:45,670 --> 00:00:49,780
two and a half years I comment a nice

00:00:47,920 --> 00:00:52,210
callous incremental compiler whose name

00:00:49,780 --> 00:00:54,579
is Singh I work mainly on build tools

00:00:52,210 --> 00:00:57,180
and build servers and I also do some

00:00:54,579 --> 00:00:59,700
work on skocy the Scylla - compiler

00:00:57,180 --> 00:01:02,860
compiler plugins and infrastructure

00:00:59,700 --> 00:01:05,199
probably like macros and all this kind

00:01:02,860 --> 00:01:08,140
of stuff I have to say one of my

00:01:05,199 --> 00:01:10,180
obsessions is developer productivity so

00:01:08,140 --> 00:01:14,560
that kind of like tells a lot about this

00:01:10,180 --> 00:01:16,120
project hi everyone my name is Martin I

00:01:14,560 --> 00:01:18,310
am also a software engineer at the Scala

00:01:16,120 --> 00:01:20,620
Center I've been there for a bit more

00:01:18,310 --> 00:01:23,860
than a year now I usually work on

00:01:20,620 --> 00:01:25,810
compilers and build tools and one of the

00:01:23,860 --> 00:01:28,000
things that bother me is when my tools

00:01:25,810 --> 00:01:31,150
get in my way and they don't let me work

00:01:28,000 --> 00:01:33,340
the way I would like to Brazil has been

00:01:31,150 --> 00:01:36,100
working on this be teasing also scar

00:01:33,340 --> 00:01:45,070
native and I just recently joined the da

00:01:36,100 --> 00:01:48,610
TT my GP FL yeah this is a quote that we

00:01:45,070 --> 00:01:50,560
got from happy bloop user he came back

00:01:48,610 --> 00:01:54,490
on our data Channel and told us what we

00:01:50,560 --> 00:01:56,470
did with blue they had an application

00:01:54,490 --> 00:01:58,720
that had many layers where they had

00:01:56,470 --> 00:02:01,720
based ivories that they would build upon

00:01:58,720 --> 00:02:03,280
many layers that Indian they had a

00:02:01,720 --> 00:02:07,540
plugin system that they would deliver to

00:02:03,280 --> 00:02:11,409
the clients whenever they were editing

00:02:07,540 --> 00:02:13,689
the base of their tooling they had to

00:02:11,409 --> 00:02:15,969
publish locally all the changes and then

00:02:13,689 --> 00:02:17,510
and so forth many times many layers and

00:02:15,969 --> 00:02:20,080
it would take a lot of time for

00:02:17,510 --> 00:02:23,090
so using bloop they were able to

00:02:20,080 --> 00:02:25,730
simulate source dependencies and with

00:02:23,090 --> 00:02:27,500
that they got turnarounds in the order

00:02:25,730 --> 00:02:30,079
of seconds we set up ten plus minutes

00:02:27,500 --> 00:02:32,689
that they had at the beginning so it

00:02:30,079 --> 00:02:34,459
it's great now that we have been raising

00:02:32,689 --> 00:02:36,230
nice tones for a few months that we get

00:02:34,459 --> 00:02:38,060
more and more feedback about how people

00:02:36,230 --> 00:02:40,310
are using loop to develop new tools and

00:02:38,060 --> 00:02:41,840
how they are able to get new ideas on

00:02:40,310 --> 00:02:47,510
how to get more productive with our

00:02:41,840 --> 00:02:49,400
children in Scala so when we see that we

00:02:47,510 --> 00:02:51,200
think that good tools are tools that

00:02:49,400 --> 00:02:55,159
should be sufficiently flexible so that

00:02:51,200 --> 00:02:57,470
you can take an embrace your workflow

00:02:55,159 --> 00:02:59,389
and then don't get in your way you feel

00:02:57,470 --> 00:03:00,590
empowered by them because they let you

00:02:59,389 --> 00:03:03,650
do exactly what you want and you don't

00:03:00,590 --> 00:03:09,620
get forced into the way of working how

00:03:03,650 --> 00:03:11,720
they would like you to so in this talk

00:03:09,620 --> 00:03:14,569
we're gonna dive into detail about how

00:03:11,720 --> 00:03:16,970
blue makes you more productive and well

00:03:14,569 --> 00:03:19,340
of course in order to claim that I need

00:03:16,970 --> 00:03:22,129
to define what productivity is so the

00:03:19,340 --> 00:03:25,579
main focus of loop here is that we want

00:03:22,129 --> 00:03:28,129
you to wait like what I'm gonna define

00:03:25,579 --> 00:03:31,879
first productivity actually so we define

00:03:28,129 --> 00:03:33,440
productivity as dual being bounded by

00:03:31,879 --> 00:03:35,470
the your thinking process and not the

00:03:33,440 --> 00:03:40,099
tools you use so you are productive if

00:03:35,470 --> 00:03:41,359
you are you know stopped at some point

00:03:40,099 --> 00:03:43,579
and you cannot you need to think about

00:03:41,359 --> 00:03:45,829
the API design and you will need to

00:03:43,579 --> 00:03:49,879
think over wait until the build tool has

00:03:45,829 --> 00:03:51,650
finished compilation so our goal here is

00:03:49,879 --> 00:03:53,690
to minimize minimize the amount of time

00:03:51,650 --> 00:03:56,750
it passes between a code change and its

00:03:53,690 --> 00:04:00,069
result the result may be a text a test

00:03:56,750 --> 00:04:03,340
execution result or end of compilation

00:04:00,069 --> 00:04:06,290
so I imagine that most of the people

00:04:03,340 --> 00:04:09,199
that don't work on build tools see build

00:04:06,290 --> 00:04:11,930
tools like this right like this beast

00:04:09,199 --> 00:04:13,940
that have many different properties they

00:04:11,930 --> 00:04:17,229
are very different from each other and

00:04:13,940 --> 00:04:19,400
they kind of allow you to do things in

00:04:17,229 --> 00:04:22,490
completely different workflows so you

00:04:19,400 --> 00:04:24,110
have pants and basil that are source

00:04:22,490 --> 00:04:26,240
based dependencies build tools and then

00:04:24,110 --> 00:04:28,880
you have gravy or Maybin and SBT which

00:04:26,240 --> 00:04:31,289
are which kind of like predicates more

00:04:28,880 --> 00:04:36,569
on binary dependencies

00:04:31,289 --> 00:04:38,369
and have other ways of working so what's

00:04:36,569 --> 00:04:40,680
common about about all of these bill

00:04:38,369 --> 00:04:43,289
tools is that they will compile your

00:04:40,680 --> 00:04:45,240
code and when we talk about compilation

00:04:43,289 --> 00:04:47,490
well in order to compile you need to use

00:04:45,240 --> 00:04:49,559
the Scala compiler but compilation is

00:04:47,490 --> 00:04:51,809
one of these services that requires or

00:04:49,559 --> 00:04:53,909
has concrete properties that are

00:04:51,809 --> 00:04:56,999
essential to the experience of the

00:04:53,909 --> 00:04:59,999
language so in this case what we wanted

00:04:56,999 --> 00:05:03,029
to do with Blut is to kind of get the

00:04:59,999 --> 00:05:05,669
core of all these spirit tools the core

00:05:03,029 --> 00:05:09,059
that comprise your code and strip it

00:05:05,669 --> 00:05:12,240
away put it in another tool and expose

00:05:09,059 --> 00:05:14,279
it and by definition all these bill

00:05:12,240 --> 00:05:17,490
tools would be able to reuse that core

00:05:14,279 --> 00:05:19,259
and would would be with the spend their

00:05:17,490 --> 00:05:21,059
time or the developers working on these

00:05:19,259 --> 00:05:24,059
tools could spend their time more on the

00:05:21,059 --> 00:05:26,369
front-end part on how people and users

00:05:24,059 --> 00:05:28,289
interact with the pill tools rather than

00:05:26,369 --> 00:05:31,259
the internals of how you get the Scala

00:05:28,289 --> 00:05:33,839
compiler working correctly so we tried

00:05:31,259 --> 00:05:39,300
hard really hard and the best we could

00:05:33,839 --> 00:05:45,120
do is this so this is how I would kind

00:05:39,300 --> 00:05:46,349
of imagine bloop that was the killer

00:05:45,120 --> 00:05:48,029
wave was official logo this is the

00:05:46,349 --> 00:05:50,519
unofficial logo Heather is not around

00:05:48,029 --> 00:05:54,149
here so it's good that I show it to you

00:05:50,519 --> 00:05:56,399
and what we wanted basically is just to

00:05:54,149 --> 00:05:58,349
have a fast tool a very lightweight tool

00:05:56,399 --> 00:05:59,399
as well and happy tool something that

00:05:58,349 --> 00:06:03,839
you can do something you're happy about

00:05:59,399 --> 00:06:06,240
it so I will define bloop as a zinc plus

00:06:03,839 --> 00:06:08,219
plus it's for those that don't know zinc

00:06:06,240 --> 00:06:10,469
as the Scala sink is Carla's incremental

00:06:08,219 --> 00:06:13,740
compiler so what it does is that given a

00:06:10,469 --> 00:06:16,619
code change you change a file in in your

00:06:13,740 --> 00:06:19,919
in your file system it will compile only

00:06:16,619 --> 00:06:22,439
the necessary parts of your project so

00:06:19,919 --> 00:06:24,240
that the compilation is correct and this

00:06:22,439 --> 00:06:26,669
is basically an optimization it's some

00:06:24,240 --> 00:06:28,709
kind of workaround for the fact that

00:06:26,669 --> 00:06:30,539
batch compilation in Scala compiling

00:06:28,709 --> 00:06:36,059
everything all together is a slow

00:06:30,539 --> 00:06:37,919
process so when we think about what the

00:06:36,059 --> 00:06:40,979
tools we have right now to to kind of

00:06:37,919 --> 00:06:42,240
like build upon we have in one one part

00:06:40,979 --> 00:06:43,990
of the spectrum we have a scholarship

00:06:42,240 --> 00:06:46,660
which is the rockin value as

00:06:43,990 --> 00:06:48,760
the AAP ice you interact with them and

00:06:46,660 --> 00:06:51,430
then you crap the compiler to do

00:06:48,760 --> 00:06:53,950
whatever you want you also have a CLI

00:06:51,430 --> 00:06:55,780
but the CLI doesn't give you hot

00:06:53,950 --> 00:06:58,540
compilers which we will explain which

00:06:55,780 --> 00:06:59,770
will spend later what those are and it

00:06:58,540 --> 00:07:04,030
doesn't give you incrementality

00:06:59,770 --> 00:07:06,820
so it's not very useful and I think that

00:07:04,030 --> 00:07:10,060
one of the bad things about using skocy

00:07:06,820 --> 00:07:12,100
directly is also that you cannot reuse

00:07:10,060 --> 00:07:13,690
the context in which the compiler is use

00:07:12,100 --> 00:07:15,880
so usually compilation happens in a

00:07:13,690 --> 00:07:17,620
context and it may be very useful for

00:07:15,880 --> 00:07:19,330
that compiler to know what that context

00:07:17,620 --> 00:07:22,300
is context is so that it can apply

00:07:19,330 --> 00:07:24,340
optimizations so right now there is no

00:07:22,300 --> 00:07:26,770
way to do that and we think that bloop

00:07:24,340 --> 00:07:28,960
can be a good solution for that on the

00:07:26,770 --> 00:07:30,850
other side of the spectrum we have build

00:07:28,960 --> 00:07:33,420
tools the problem with build tools is

00:07:30,850 --> 00:07:35,470
that they are focused on the user and

00:07:33,420 --> 00:07:37,630
they are too heavy weight they are

00:07:35,470 --> 00:07:40,480
difficult to integrate with because the

00:07:37,630 --> 00:07:42,100
users are supposed to use them and they

00:07:40,480 --> 00:07:44,950
are supposed to be used by users and not

00:07:42,100 --> 00:07:48,760
by tools so there is a gap to fill in

00:07:44,950 --> 00:07:50,980
here and this is exactly what blue tasks

00:07:48,760 --> 00:07:53,680
so blue Paquette zinc gets ink which is

00:07:50,980 --> 00:07:56,410
a library and all the build tools that

00:07:53,680 --> 00:07:59,350
we've seen before grabs that library and

00:07:56,410 --> 00:08:01,410
it gets the zinc library puts it in an

00:07:59,350 --> 00:08:03,520
Elkin server and exposes to you and

00:08:01,410 --> 00:08:04,930
we'll see a little bit more about the

00:08:03,520 --> 00:08:09,160
properties of this nail-gun server

00:08:04,930 --> 00:08:10,870
afterwards one important thing here to

00:08:09,160 --> 00:08:16,000
and to understand is that zinc like

00:08:10,870 --> 00:08:17,950
bloop doesn't doesn't try like doesn't

00:08:16,000 --> 00:08:20,650
aim at replacing to repeat it rather

00:08:17,950 --> 00:08:24,010
complements it and when we talk about

00:08:20,650 --> 00:08:25,540
build tools they do lots of stuff but

00:08:24,010 --> 00:08:27,780
they do also some stuff that they are

00:08:25,540 --> 00:08:31,350
not meant to to do or they are not

00:08:27,780 --> 00:08:33,700
optimized to do so developer workflows

00:08:31,350 --> 00:08:36,640
basically the workflows or the kind of

00:08:33,700 --> 00:08:38,350
projects we work on are very defined

00:08:36,640 --> 00:08:40,360
depending on the culture of our company

00:08:38,350 --> 00:08:42,130
and they are orthogonal to build tools

00:08:40,360 --> 00:08:44,440
and sometimes they require special cases

00:08:42,130 --> 00:08:46,750
they require custom solutions so that we

00:08:44,440 --> 00:08:50,530
can make a change and make it as fast as

00:08:46,750 --> 00:08:51,940
possible so this is one of the reasons

00:08:50,530 --> 00:08:53,200
why bloop is important because bloop

00:08:51,940 --> 00:08:56,890
allows you to do this kind of stuff

00:08:53,200 --> 00:08:57,880
without making complicated changes or

00:08:56,890 --> 00:08:59,710
complicate extensions to

00:08:57,880 --> 00:09:03,640
Bell Tolls that you need to learn how to

00:08:59,710 --> 00:09:05,800
integrate with so what can we do what is

00:09:03,640 --> 00:09:09,460
what are the solutions so the only

00:09:05,800 --> 00:09:11,680
solution that we we we saw four months

00:09:09,460 --> 00:09:14,740
ago was centralization so we want to

00:09:11,680 --> 00:09:16,240
expose compilation as a service and we

00:09:14,740 --> 00:09:19,030
want a server to compile them all all

00:09:16,240 --> 00:09:20,710
the programs their changes to this

00:09:19,030 --> 00:09:23,860
codebase will have the most impact

00:09:20,710 --> 00:09:25,750
because if this code base or if this

00:09:23,860 --> 00:09:28,720
service is reused by the all the other

00:09:25,750 --> 00:09:30,400
built tools then it means that if we

00:09:28,720 --> 00:09:33,580
optimize the performance of that

00:09:30,400 --> 00:09:37,320
compilation server or if we fix the bug

00:09:33,580 --> 00:09:37,320
that will be immediately immediately

00:09:38,280 --> 00:09:41,770
that the change will propagate

00:09:40,060 --> 00:09:44,620
immediately to the rest of the builders

00:09:41,770 --> 00:09:46,240
that uses use the server and you could

00:09:44,620 --> 00:09:51,820
upgrade the server independently of the

00:09:46,240 --> 00:09:54,790
pill tool version this is not some kind

00:09:51,820 --> 00:09:57,520
of pipe dream there are lots of cases

00:09:54,790 --> 00:10:00,610
lots of examples in our community in

00:09:57,520 --> 00:10:03,160
which we are not doing it right and one

00:10:00,610 --> 00:10:05,590
example is Gradle Radle is an important

00:10:03,160 --> 00:10:07,720
bill to many companies use a scholar

00:10:05,590 --> 00:10:11,260
with Gradle because they also have Java

00:10:07,720 --> 00:10:13,600
code or coding code right and Gradle the

00:10:11,260 --> 00:10:15,820
latest version still uses zinc or

00:10:13,600 --> 00:10:19,570
thirteen which is a compiler that was

00:10:15,820 --> 00:10:22,390
used that words that was released three

00:10:19,570 --> 00:10:25,930
years ago so of course that compiler is

00:10:22,390 --> 00:10:28,060
less than ideal it's not fast and it

00:10:25,930 --> 00:10:31,180
doesn't have the best incrementality so

00:10:28,060 --> 00:10:33,670
we want to change that and that's how we

00:10:31,180 --> 00:10:35,740
got the new compilation server ID that

00:10:33,670 --> 00:10:39,460
we want to push around which is when we

00:10:35,740 --> 00:10:41,500
call the new kid in the block now and

00:10:39,460 --> 00:10:44,560
this is the old architecture that we had

00:10:41,500 --> 00:10:46,450
you where you had you already using one

00:10:44,560 --> 00:10:49,120
compiler with some glue code to talk to

00:10:46,450 --> 00:10:50,440
it other CLI tools that you would use so

00:10:49,120 --> 00:10:52,360
this is the old architecture that we had

00:10:50,440 --> 00:10:54,880
first you have the ID that has some

00:10:52,360 --> 00:10:56,110
local to talk to one compiler or SLI

00:10:54,880 --> 00:10:57,940
tools that you would use they also

00:10:56,110 --> 00:10:59,920
talked to one compiler and you'll notice

00:10:57,940 --> 00:11:03,730
also using with some build code blue

00:10:59,920 --> 00:11:06,850
code one instance of the compiler these

00:11:03,730 --> 00:11:08,710
are some issues first we have three

00:11:06,850 --> 00:11:10,900
different implementation of how to talk

00:11:08,710 --> 00:11:11,710
to a compiler also we have three

00:11:10,900 --> 00:11:13,120
different instances

00:11:11,710 --> 00:11:15,510
of the compiler running at the same time

00:11:13,120 --> 00:11:17,830
which is not very efficient

00:11:15,510 --> 00:11:19,810
that we can do much better with this New

00:11:17,830 --> 00:11:21,490
York textured little purposing in which

00:11:19,810 --> 00:11:23,410
all the different tools that you use

00:11:21,490 --> 00:11:25,960
that need a compiler are talking to the

00:11:23,410 --> 00:11:27,610
same instance of loop this has several

00:11:25,960 --> 00:11:29,020
advantages first we have only one

00:11:27,610 --> 00:11:31,450
implementation of the glue code that

00:11:29,020 --> 00:11:33,790
lets you use a compiler from the outside

00:11:31,450 --> 00:11:35,950
and also it means that we have just one

00:11:33,790 --> 00:11:39,700
instance of loop running at the same

00:11:35,950 --> 00:11:41,230
time on your machine these compilation

00:11:39,700 --> 00:11:43,630
servers that we want it has to have

00:11:41,230 --> 00:11:45,340
several properties first it's important

00:11:43,630 --> 00:11:49,390
that it works today with Scala too but

00:11:45,340 --> 00:11:52,410
we also have to support the future be

00:11:49,390 --> 00:11:55,300
future proofing support Scala free today

00:11:52,410 --> 00:11:56,050
um also it's very important to be

00:11:55,300 --> 00:11:58,570
platform agnostic

00:11:56,050 --> 00:12:01,030
you can't ignore s kalakeyas nor Scala

00:11:58,570 --> 00:12:03,250
native and of course guide on the JVM is

00:12:01,030 --> 00:12:03,580
still the most important one at the

00:12:03,250 --> 00:12:06,940
moment

00:12:03,580 --> 00:12:08,590
and whatever you have you want to be

00:12:06,940 --> 00:12:11,140
able to use it with all the build tools

00:12:08,590 --> 00:12:13,960
you cannot just focus on one you have to

00:12:11,140 --> 00:12:15,490
for DVD maven cradle whatever and it has

00:12:13,960 --> 00:12:19,960
to be simple to integrate with this

00:12:15,490 --> 00:12:23,830
compilation server having this

00:12:19,960 --> 00:12:27,160
compilation server also it allows us to

00:12:23,830 --> 00:12:29,290
do new and better optimization we have a

00:12:27,160 --> 00:12:31,870
bull graph that is statically known

00:12:29,290 --> 00:12:34,510
which was just to perform optimization

00:12:31,870 --> 00:12:36,820
we know when we can store things in

00:12:34,510 --> 00:12:40,560
memory where and when we have to store

00:12:36,820 --> 00:12:43,150
them on disk we know when to invalidate

00:12:40,560 --> 00:12:44,520
we don't have to perform all the work

00:12:43,150 --> 00:12:48,130
that you would have to do in a different

00:12:44,520 --> 00:12:50,790
context we can skip classes hashing we

00:12:48,130 --> 00:12:52,870
can reuse the hashes of sources and

00:12:50,790 --> 00:12:55,240
given a stack graph that we have we can

00:12:52,870 --> 00:12:56,890
also do a better work at paralyzing all

00:12:55,240 --> 00:13:00,970
the tests that you get to the

00:12:56,890 --> 00:13:04,480
compilation server so I was talking

00:13:00,970 --> 00:13:06,250
before about having only one instance of

00:13:04,480 --> 00:13:08,680
the compiler running on your machine but

00:13:06,250 --> 00:13:13,930
why is it important that's because you

00:13:08,680 --> 00:13:15,280
get hot compilers a hot compiler as you

00:13:13,930 --> 00:13:19,290
probably know is a controller that has

00:13:15,280 --> 00:13:21,910
been heated up by the JVM which while

00:13:19,290 --> 00:13:24,410
executing your code it's optimizing it

00:13:21,910 --> 00:13:27,290
so that it performs much faster

00:13:24,410 --> 00:13:28,759
um having a hot compiler is very useful

00:13:27,290 --> 00:13:30,920
because it's going to be to compare much

00:13:28,759 --> 00:13:32,750
faster and if you discard it it's going

00:13:30,920 --> 00:13:35,899
to be a huge problem for your

00:13:32,750 --> 00:13:38,209
productivity and you may not know it but

00:13:35,899 --> 00:13:40,490
getting hot compilers having really real

00:13:38,209 --> 00:13:42,889
fan for instance with SVT whenever you

00:13:40,490 --> 00:13:45,829
try to reload going to discard all the

00:13:42,889 --> 00:13:47,930
hot compilers that you had if you for

00:13:45,829 --> 00:13:50,180
instance exit or a bill code your build

00:13:47,930 --> 00:13:51,980
tool and panting controlled see is going

00:13:50,180 --> 00:13:54,319
to discard all the hot compares that it

00:13:51,980 --> 00:13:56,540
had or if you have two different

00:13:54,319 --> 00:13:57,259
instances of SBT ring concurrently in

00:13:56,540 --> 00:13:58,910
thread project

00:13:57,259 --> 00:14:01,069
nothing is shared between the two and

00:13:58,910 --> 00:14:02,509
you don't benefit from the hot compilers

00:14:01,069 --> 00:14:08,980
that you had for one project in the

00:14:02,509 --> 00:14:11,149
other there are some benchmark for

00:14:08,980 --> 00:14:14,120
comparing the performance of hot versus

00:14:11,149 --> 00:14:15,790
cold compilers in graphing I'll that's a

00:14:14,120 --> 00:14:18,589
project on the scale compiler team and

00:14:15,790 --> 00:14:20,720
it shows that it can be up to eighty ten

00:14:18,589 --> 00:14:25,040
eighteen times slower to compile with

00:14:20,720 --> 00:14:26,779
cold compare versus a hot compiler also

00:14:25,040 --> 00:14:28,250
another reason why you don't want to is

00:14:26,779 --> 00:14:30,920
called hot compilers because it takes a

00:14:28,250 --> 00:14:34,100
lot of time to get the compare hot

00:14:30,920 --> 00:14:37,250
enough it consumes CPU cycles it takes

00:14:34,100 --> 00:14:38,600
normal your battery consumes Rams so

00:14:37,250 --> 00:14:40,579
it's really too bad to do again and

00:14:38,600 --> 00:14:42,290
again and again the same work where you

00:14:40,579 --> 00:14:46,009
could just keep the hot compiler and be

00:14:42,290 --> 00:14:49,670
fast all the time so now we want to show

00:14:46,009 --> 00:14:53,540
you bit how does look like it's a cool

00:14:49,670 --> 00:14:55,910
online tool first and which is made so

00:14:53,540 --> 00:14:58,009
that you get the snappiest workflow that

00:14:55,910 --> 00:15:00,079
you quit yet we don't want to get in

00:14:58,009 --> 00:15:01,759
your way you can use the shell that

00:15:00,079 --> 00:15:03,290
you're used to the shell that you love

00:15:01,759 --> 00:15:06,380
and you've configure to better switch

00:15:03,290 --> 00:15:07,790
your workflow what is nice also is that

00:15:06,380 --> 00:15:08,630
we work really hard to get nice

00:15:07,790 --> 00:15:10,910
tab-completion

00:15:08,630 --> 00:15:12,709
everything is contextual so that for

00:15:10,910 --> 00:15:14,360
instance you get here the completion for

00:15:12,709 --> 00:15:17,899
the main method that are defining your

00:15:14,360 --> 00:15:22,579
project and yeah without having to

00:15:17,899 --> 00:15:23,990
compile everything in great we have this

00:15:22,579 --> 00:15:25,610
is what the configuration for loop look

00:15:23,990 --> 00:15:27,199
like looks like this is something that

00:15:25,610 --> 00:15:30,439
would be generated by your build tool

00:15:27,199 --> 00:15:31,699
for you and we've made it so that it's

00:15:30,439 --> 00:15:34,850
pretty transparent and very well

00:15:31,699 --> 00:15:36,680
specified you can see for instance it

00:15:34,850 --> 00:15:38,329
knows what is the base directory of the

00:15:36,680 --> 00:15:40,699
project were to find the source

00:15:38,329 --> 00:15:42,679
is you have the full class pass that you

00:15:40,699 --> 00:15:44,389
read that will be passed to the compiler

00:15:42,679 --> 00:15:45,759
yeah basically everything that you would

00:15:44,389 --> 00:15:48,709
need to perform incremental compilation

00:15:45,759 --> 00:15:52,009
run your project finding the tests and

00:15:48,709 --> 00:15:53,149
so on the world the transparency that

00:15:52,009 --> 00:15:55,339
you get with this confer engine

00:15:53,149 --> 00:15:58,999
configuration final is also helpful

00:15:55,339 --> 00:16:00,350
because it's going to let you figure it

00:15:58,999 --> 00:16:02,149
very easily but you can't the

00:16:00,350 --> 00:16:03,829
configuration file why something may

00:16:02,149 --> 00:16:06,350
have gone wrong why you don't find your

00:16:03,829 --> 00:16:09,709
test why you have class not found

00:16:06,350 --> 00:16:12,199
exceptions and so forth you could also

00:16:09,709 --> 00:16:14,029
use this bill tool even that it's this

00:16:12,199 --> 00:16:16,639
configuration file given that so well

00:16:14,029 --> 00:16:18,199
specified to create new tools that's

00:16:16,639 --> 00:16:19,670
exactly what they've done in the example

00:16:18,199 --> 00:16:23,540
that shown at the very beginning when

00:16:19,670 --> 00:16:26,329
they simulated source dependencies using

00:16:23,540 --> 00:16:28,519
loop there are lots of tools in the

00:16:26,329 --> 00:16:31,670
coming line or whatever to parse JSON

00:16:28,519 --> 00:16:33,980
and to be able to interact with it and

00:16:31,670 --> 00:16:38,540
that makes it very easy to write new

00:16:33,980 --> 00:16:39,860
performance tools using loop this is

00:16:38,540 --> 00:16:41,029
linked to the specification of the

00:16:39,860 --> 00:16:46,899
configuration format if you're

00:16:41,029 --> 00:16:49,040
interested so now that configuring loop

00:16:46,899 --> 00:16:50,959
it's important to understand it's a

00:16:49,040 --> 00:16:53,059
two-step process first you'll need your

00:16:50,959 --> 00:16:54,769
you'll use your existing build tool in

00:16:53,059 --> 00:16:57,470
build definition to change all the

00:16:54,769 --> 00:17:03,110
configuration for loop and then you'll

00:16:57,470 --> 00:17:04,850
get ready with using loop this is as

00:17:03,110 --> 00:17:05,510
simple as it gets to install bloopin to

00:17:04,850 --> 00:17:08,179
get ready to work

00:17:05,510 --> 00:17:11,449
first you add the SVT plug-in that is

00:17:08,179 --> 00:17:13,549
going to add some comments to SVT so

00:17:11,449 --> 00:17:16,189
that it can export the configuration of

00:17:13,549 --> 00:17:19,370
your build to the configuration format

00:17:16,189 --> 00:17:21,049
that loop in the sense and then the

00:17:19,370 --> 00:17:22,669
second parts to do is be tip-top install

00:17:21,049 --> 00:17:28,639
which will actually generate all the

00:17:22,669 --> 00:17:31,669
configuration files um bloob defines

00:17:28,639 --> 00:17:33,769
four main comments the the first one is

00:17:31,669 --> 00:17:35,450
blue compile which obviously complies to

00:17:33,769 --> 00:17:36,710
project its dependencies and

00:17:35,450 --> 00:17:37,460
everything's on as much in progress

00:17:36,710 --> 00:17:39,769
possible

00:17:37,460 --> 00:17:42,740
it supports fire watching so that you

00:17:39,769 --> 00:17:44,710
can pass it - - watch and query compile

00:17:42,740 --> 00:17:47,210
whenever you change the source files and

00:17:44,710 --> 00:17:50,539
you can use different completion

00:17:47,210 --> 00:17:52,610
reporter to get error messages that you

00:17:50,539 --> 00:17:54,679
like best

00:17:52,610 --> 00:17:55,970
and and are many more options that you

00:17:54,679 --> 00:17:57,679
can use everything is very well

00:17:55,970 --> 00:18:00,020
documented for all the comments that we

00:17:57,679 --> 00:18:02,000
have you can use the the help flag so

00:18:00,020 --> 00:18:07,940
that it shows you everything next plane

00:18:02,000 --> 00:18:09,740
is to you what how it's going to to to

00:18:07,940 --> 00:18:13,670
affect how the compilation is going to

00:18:09,740 --> 00:18:15,950
be performed the second comment is bloop

00:18:13,670 --> 00:18:18,020
test which run the test for project and

00:18:15,950 --> 00:18:20,960
its dependencies you can if you want

00:18:18,020 --> 00:18:23,929
just pass it is rated so that you test

00:18:20,960 --> 00:18:25,669
only one project and you can use only to

00:18:23,929 --> 00:18:28,309
filter the test so that you've run just

00:18:25,669 --> 00:18:30,260
a given test suit or maybe some tests

00:18:28,309 --> 00:18:31,820
inside suit it also supports file

00:18:30,260 --> 00:18:37,100
watching so that you can rerun your desk

00:18:31,820 --> 00:18:38,929
whenever you save a file and also we

00:18:37,100 --> 00:18:42,049
have blueprint which will run the main

00:18:38,929 --> 00:18:45,080
the main classes of reproaching also it

00:18:42,049 --> 00:18:47,120
supports watch nice example here is that

00:18:45,080 --> 00:18:48,890
you can use your shell and the shell

00:18:47,120 --> 00:18:51,350
expansion to for instance file all the

00:18:48,890 --> 00:18:53,150
images to train an all network on write

00:18:51,350 --> 00:18:56,600
the data to some variable to this

00:18:53,150 --> 00:18:58,220
expanded by yourself for you and you get

00:18:56,600 --> 00:18:59,540
all of that for free whereas for

00:18:58,220 --> 00:19:01,850
instance with a speech you would have to

00:18:59,540 --> 00:19:04,850
write separate tasks to get all the

00:19:01,850 --> 00:19:06,860
files and then you would have to find

00:19:04,850 --> 00:19:09,230
some way of getting the home directory

00:19:06,860 --> 00:19:11,210
expanded and so on here you can simply

00:19:09,230 --> 00:19:14,090
use the shell that you know to get out

00:19:11,210 --> 00:19:16,309
for free and the last common that you

00:19:14,090 --> 00:19:18,770
interact with the most is bloop console

00:19:16,309 --> 00:19:20,809
which is the equivalent of is bît-yakin

00:19:18,770 --> 00:19:22,820
so it opens a ripple winter project and

00:19:20,809 --> 00:19:26,720
it's dependencies on the class pass that

00:19:22,820 --> 00:19:28,070
you can quickly try things out all the

00:19:26,720 --> 00:19:29,690
comments that we have support tab

00:19:28,070 --> 00:19:32,510
completion you can discover things very

00:19:29,690 --> 00:19:34,520
easily it's completely contextual so if

00:19:32,510 --> 00:19:35,990
you have to come to complete test names

00:19:34,520 --> 00:19:37,940
it's going to do it for you if they need

00:19:35,990 --> 00:19:41,630
the name of main class is going to find

00:19:37,940 --> 00:19:43,480
it for you and you have access to all

00:19:41,630 --> 00:19:47,210
those features from the original show I

00:19:43,480 --> 00:19:49,160
want just to very quickly demo how you

00:19:47,210 --> 00:19:52,250
can sort of loop to work for instance

00:19:49,160 --> 00:19:54,400
with you test so it's really as simple

00:19:52,250 --> 00:19:58,809
as going to plugins or SVT

00:19:54,400 --> 00:19:58,809
you had the SBT plug-in for loop

00:20:05,090 --> 00:20:18,300
using m10 that we released just a few

00:20:08,160 --> 00:20:20,340
days ago and you do bloop install so as

00:20:18,300 --> 00:20:23,370
you can see generated all the configured

00:20:20,340 --> 00:20:26,160
for bloop we have in this case and

00:20:23,370 --> 00:20:29,280
digital project that defines JVM Jas and

00:20:26,160 --> 00:20:30,750
native interrupts so there is one

00:20:29,280 --> 00:20:32,130
configuring for each of them and for

00:20:30,750 --> 00:20:33,660
each project we generate two

00:20:32,130 --> 00:20:36,060
configurations the compiled

00:20:33,660 --> 00:20:39,600
configuration and also the test

00:20:36,060 --> 00:20:41,660
configuration so now let's see what

00:20:39,600 --> 00:20:46,200
happens with bloop

00:20:41,660 --> 00:20:47,700
so first I'm running bloop and then

00:20:46,200 --> 00:20:50,070
which is the most recent version that we

00:20:47,700 --> 00:20:56,400
have and let's see what happens if I

00:20:50,070 --> 00:20:58,470
combine sorry I get top competition to

00:20:56,400 --> 00:21:00,920
get the name of the project oh I need to

00:20:58,470 --> 00:21:00,920
clean first

00:21:02,960 --> 00:21:07,250
so it's compiling everything in parallel

00:21:11,960 --> 00:21:22,560
and here we go so now what happens if I

00:21:15,240 --> 00:21:35,090
maybe try five watching let's try to

00:21:22,560 --> 00:21:40,380
modify something now it's finding again

00:21:35,090 --> 00:21:45,180
differences pretty fast so also support

00:21:40,380 --> 00:21:46,560
tests of course that's run JVM because

00:21:45,180 --> 00:21:48,660
you don't have support for running on

00:21:46,560 --> 00:21:50,130
the other platforms at the moment then

00:21:48,660 --> 00:21:54,240
it's pretty fast all the tests are

00:21:50,130 --> 00:21:57,690
running so as you can see it's very

00:21:54,240 --> 00:22:01,970
simple - you get bloop ready it's just

00:21:57,690 --> 00:22:01,970
adding one line to plug in so to speak

00:22:02,480 --> 00:22:07,110
well this task are nothing new Under the

00:22:05,580 --> 00:22:09,100
Sun right I mean every peel tool

00:22:07,110 --> 00:22:12,820
supports them so what

00:22:09,100 --> 00:22:15,370
I mean what's the hyper part so the hype

00:22:12,820 --> 00:22:17,169
is about integrations and I can see

00:22:15,370 --> 00:22:19,269
array your faces like a screaming and

00:22:17,169 --> 00:22:21,630
say oh no a new tool right I don't want

00:22:19,269 --> 00:22:24,519
to new I want to learn a new tool and

00:22:21,630 --> 00:22:26,919
the fact that see like bloop is a CLI

00:22:24,519 --> 00:22:29,259
gives you some advantages over having a

00:22:26,919 --> 00:22:31,809
shell for instance as in SVT but it's

00:22:29,259 --> 00:22:35,759
not worth a new declaration of a new

00:22:31,809 --> 00:22:38,320
tool so our focus has been on making

00:22:35,759 --> 00:22:40,090
integrations better and this is the

00:22:38,320 --> 00:22:42,850
thing we've been working on during the

00:22:40,090 --> 00:22:44,409
past weeks and this is something that we

00:22:42,850 --> 00:22:46,149
are going to show now and we're going to

00:22:44,409 --> 00:22:48,129
splain how we achieve that how we are

00:22:46,149 --> 00:22:54,039
achieving it because it's like a process

00:22:48,129 --> 00:22:55,690
that is still on like under work so the

00:22:54,039 --> 00:22:58,179
first realization the first kind of like

00:22:55,690 --> 00:23:00,639
key thought is that we want to we want

00:22:58,179 --> 00:23:02,620
loop to be used by all the tools in our

00:23:00,639 --> 00:23:04,929
ecosystem we don't want to leave any

00:23:02,620 --> 00:23:07,779
tool outside of it so in the previous

00:23:04,929 --> 00:23:09,129
case and mentioned Gradle so now that we

00:23:07,779 --> 00:23:11,769
have the opportunity to create something

00:23:09,129 --> 00:23:16,149
new we want the cradle users to benefit

00:23:11,769 --> 00:23:17,440
from the very latest compilers while

00:23:16,149 --> 00:23:19,809
compiler technology that we have in

00:23:17,440 --> 00:23:21,820
Scala and the best scholar language

00:23:19,809 --> 00:23:24,190
experience possible and we wanted to

00:23:21,820 --> 00:23:26,350
have same experience as you have in SBT

00:23:24,190 --> 00:23:28,840
which is the kind of official scaleable

00:23:26,350 --> 00:23:34,590
tool or as you have in Maybin or made

00:23:28,840 --> 00:23:38,620
over pants or whatever tool you use so

00:23:34,590 --> 00:23:41,769
then it's clear that improving SBT only

00:23:38,620 --> 00:23:44,379
is not a solution and improving new

00:23:41,769 --> 00:23:47,710
build tools like mail or hurry or

00:23:44,379 --> 00:23:49,059
investing resources and like our next

00:23:47,710 --> 00:23:50,679
favorite bill tool is not going to be

00:23:49,059 --> 00:23:52,809
the solution either there is a lot of

00:23:50,679 --> 00:23:54,519
people out there that want me great

00:23:52,809 --> 00:23:56,740
bills because migrating bills takes out

00:23:54,519 --> 00:24:00,779
of time takes out of us a lot of

00:23:56,740 --> 00:24:00,779
expertise and it's not an easy process

00:24:02,250 --> 00:24:08,500
so one of the most important projects

00:24:06,730 --> 00:24:11,799
we've been working on at the Center for

00:24:08,500 --> 00:24:13,600
the past fun for the past month is the

00:24:11,799 --> 00:24:15,399
build server protocol so the build

00:24:13,600 --> 00:24:19,269
server protocol is our solution to

00:24:15,399 --> 00:24:20,440
integrations and integrations with Bell

00:24:19,269 --> 00:24:22,110
Tolls in particular so you have

00:24:20,440 --> 00:24:24,179
different clients

00:24:22,110 --> 00:24:26,640
and the clients going to servers in this

00:24:24,179 --> 00:24:28,080
case bloop can act as a as a BSP server

00:24:26,640 --> 00:24:29,820
because it has all information about

00:24:28,080 --> 00:24:32,070
your project and can provide all this

00:24:29,820 --> 00:24:34,380
information to a client but then what

00:24:32,070 --> 00:24:36,240
are the clients so the clients our

00:24:34,380 --> 00:24:39,059
language server language servers and

00:24:36,240 --> 00:24:40,710
editors so in this case IntelliJ has its

00:24:39,059 --> 00:24:43,320
own language server for a Scala it gives

00:24:40,710 --> 00:24:45,240
you completions it gives you IDE like an

00:24:43,320 --> 00:24:48,059
IDE experience right so that's what we

00:24:45,240 --> 00:24:50,970
call an alum with server so IntelliJ

00:24:48,059 --> 00:24:54,059
could integrate with bloop via BSP or

00:24:50,970 --> 00:24:56,760
with whatever build tool there is that

00:24:54,059 --> 00:24:59,429
implements the protocol and as you see

00:24:56,760 --> 00:25:01,200
this is a very similar protocol as LSP

00:24:59,429 --> 00:25:03,540
is trying to solve the same problem but

00:25:01,200 --> 00:25:08,160
instead of applying it to two languages

00:25:03,540 --> 00:25:09,240
we are applying it to build tools if you

00:25:08,160 --> 00:25:11,630
want to know more about this because

00:25:09,240 --> 00:25:15,390
this is a very lengthy problem fee a

00:25:11,630 --> 00:25:18,059
kind of topic to discuss about you I

00:25:15,390 --> 00:25:20,190
recommend you to check out this talk I

00:25:18,059 --> 00:25:22,290
gave at this class fear one month ago

00:25:20,190 --> 00:25:25,860
with Justin from the IntelliJ team in

00:25:22,290 --> 00:25:28,100
which we show the latest advancements in

00:25:25,860 --> 00:25:30,450
the BSP in the based implementation and

00:25:28,100 --> 00:25:32,549
we're gonna show a little bit today but

00:25:30,450 --> 00:25:34,710
we are just gonna go briefly through

00:25:32,549 --> 00:25:37,410
through a process well through the use

00:25:34,710 --> 00:25:39,570
cases and show why this is useful for

00:25:37,410 --> 00:25:41,220
bloop it is important to notice as well

00:25:39,570 --> 00:25:44,820
the BSP is completely independent to

00:25:41,220 --> 00:25:46,410
bloop and we happen to be - it happens

00:25:44,820 --> 00:25:49,880
to be implemented in bloop first because

00:25:46,410 --> 00:25:53,429
it makes like a very good testbed for

00:25:49,880 --> 00:25:54,990
testing whether ESP is a solution or not

00:25:53,429 --> 00:25:59,030
we're still at the process of

00:25:54,990 --> 00:26:02,790
experimenting and it also makes it a

00:25:59,030 --> 00:26:05,429
very nice case because we can abstract

00:26:02,790 --> 00:26:11,220
over build tools I'll dive a little bit

00:26:05,429 --> 00:26:13,620
deeper into that afterwards so the best

00:26:11,220 --> 00:26:16,440
the most important use case that PSP

00:26:13,620 --> 00:26:19,140
supports is an efficient import project

00:26:16,440 --> 00:26:20,669
so probably some of you have imported

00:26:19,140 --> 00:26:23,040
with IntelliJ your project and it's

00:26:20,669 --> 00:26:25,380
taken a lot of time maybe in the order

00:26:23,040 --> 00:26:26,910
of seconds 4 minute sorry in the order

00:26:25,380 --> 00:26:31,710
of minutes four minutes to import a

00:26:26,910 --> 00:26:35,070
patch is part 10 like 20 I've seen 20 by

00:26:31,710 --> 00:26:36,120
the way so this is along like these are

00:26:35,070 --> 00:26:38,190
very

00:26:36,120 --> 00:26:39,990
inefficient process and it kills

00:26:38,190 --> 00:26:41,750
productivity every time this happens to

00:26:39,990 --> 00:26:45,030
me and every time I feel like I need to

00:26:41,750 --> 00:26:45,840
update the indices in IntelliJ it really

00:26:45,030 --> 00:26:49,770
breaks my heart

00:26:45,840 --> 00:26:51,680
so BSP tries to fix this problem by

00:26:49,770 --> 00:26:54,060
making it a snappier and making it

00:26:51,680 --> 00:26:55,950
better so the idea is that instead of

00:26:54,060 --> 00:26:59,640
exporting all the information about the

00:26:55,950 --> 00:27:01,620
build to the IDE the ID connects to the

00:26:59,640 --> 00:27:05,310
source of information to the build tools

00:27:01,620 --> 00:27:06,690
and asks the bell tolls what you have in

00:27:05,310 --> 00:27:09,420
the in the workspace what projects you

00:27:06,690 --> 00:27:10,220
have what are the class paths what are

00:27:09,420 --> 00:27:15,060
their names

00:27:10,220 --> 00:27:17,720
and in our case we can use the same

00:27:15,060 --> 00:27:21,270
trick that you know you would use for

00:27:17,720 --> 00:27:23,940
for a BSP server but instead have all

00:27:21,270 --> 00:27:27,990
these build tools that would be also BSP

00:27:23,940 --> 00:27:29,790
servers BSP clients so I know that some

00:27:27,990 --> 00:27:32,700
of you have custom solutions for

00:27:29,790 --> 00:27:35,100
instance those that develop HTTP servers

00:27:32,700 --> 00:27:39,360
need to be in the SBT shell and need to

00:27:35,100 --> 00:27:39,690
have like the plain integration work in

00:27:39,360 --> 00:27:44,370
there

00:27:39,690 --> 00:27:46,530
so of course using a CLI application to

00:27:44,370 --> 00:27:48,390
compat your your code is not a solution

00:27:46,530 --> 00:27:49,560
you need to integrate everything you

00:27:48,390 --> 00:27:51,960
need to make the use of ploop

00:27:49,560 --> 00:27:55,820
transparent to the user and that's what

00:27:51,960 --> 00:27:59,220
this enables us to do so in this case

00:27:55,820 --> 00:28:00,870
group would be the server and SBT would

00:27:59,220 --> 00:28:03,330
be the client so when you type compiling

00:28:00,870 --> 00:28:04,980
your project what a sweetie would do

00:28:03,330 --> 00:28:07,020
under the hood or what maybe M would do

00:28:04,980 --> 00:28:09,510
under the hood is send a compile request

00:28:07,020 --> 00:28:10,830
to the loop server and there we would

00:28:09,510 --> 00:28:14,990
compile your code in the fastest way

00:28:10,830 --> 00:28:14,990
possible and get get it back to you so

00:28:18,530 --> 00:28:26,040
these are pictures of something that

00:28:23,400 --> 00:28:29,340
we've been working on with we've been

00:28:26,040 --> 00:28:31,620
working with the gem scene I mean so

00:28:29,340 --> 00:28:33,450
this is a screenshot of IntelliJ and

00:28:31,620 --> 00:28:35,610
it's a screenshot of IntelliJ a

00:28:33,450 --> 00:28:39,630
compilation error that comes from bloop

00:28:35,610 --> 00:28:42,690
so bloop imports you're like bloop has

00:28:39,630 --> 00:28:45,210
deprived definitions of your of all your

00:28:42,690 --> 00:28:46,920
built right and all IntelliJ does is

00:28:45,210 --> 00:28:49,540
that you import a project but instead of

00:28:46,920 --> 00:28:52,000
selecting SBT you select PSP

00:28:49,540 --> 00:28:55,150
so the bsp implementation right now in

00:28:52,000 --> 00:28:57,460
IntelliJ would get all the data of your

00:28:55,150 --> 00:29:00,070
build imported and then we'd allow you

00:28:57,460 --> 00:29:02,200
to compile from the UI so in this case

00:29:00,070 --> 00:29:03,850
we get Diagnostics in the editor you

00:29:02,200 --> 00:29:05,710
don't get it in a shell you get it

00:29:03,850 --> 00:29:07,210
directly in the editor and that makes a

00:29:05,710 --> 00:29:09,370
very nice experience when you are

00:29:07,210 --> 00:29:15,190
developing code and makes it it snappy

00:29:09,370 --> 00:29:17,169
as well a good a case as well is that

00:29:15,190 --> 00:29:19,960
instead of having a like a file watcher

00:29:17,169 --> 00:29:21,760
that looks for listens for changes in

00:29:19,960 --> 00:29:23,770
your source files Intel you can tell

00:29:21,760 --> 00:29:27,790
directly to the server which files

00:29:23,770 --> 00:29:31,900
change and that makes for also a faster

00:29:27,790 --> 00:29:34,720
compilation something that was not

00:29:31,900 --> 00:29:37,360
really talked about yet is benchmarking

00:29:34,720 --> 00:29:40,960
the composition and how fast can you

00:29:37,360 --> 00:29:42,880
actually combine so we've been improving

00:29:40,960 --> 00:29:44,650
on the compilation scholarship

00:29:42,880 --> 00:29:46,870
benchmarks project from the Scala

00:29:44,650 --> 00:29:48,370
compiler team and light band in where in

00:29:46,870 --> 00:29:51,040
which they compared the performance of

00:29:48,370 --> 00:29:53,890
Scala C versus also the performance of

00:29:51,040 --> 00:29:55,960
scale C with SBT and we've been

00:29:53,890 --> 00:29:59,370
improving on that to also compare with

00:29:55,960 --> 00:30:02,530
loop so first we've been trying with

00:29:59,370 --> 00:30:05,530
smallish to medium project maybe it's

00:30:02,530 --> 00:30:08,350
vgs-vt it's this calico system built

00:30:05,530 --> 00:30:11,740
tool I guess everybody knows it it has

00:30:08,350 --> 00:30:13,960
about 800 source files 550 thousand

00:30:11,740 --> 00:30:15,850
lines of code and we've seen that

00:30:13,960 --> 00:30:19,419
comparing with group we get about 25

00:30:15,850 --> 00:30:21,280
percent faster we've been trying with

00:30:19,419 --> 00:30:27,040
something that's quite a bit larger

00:30:21,280 --> 00:30:29,710
already 1800 source files 108 300

00:30:27,040 --> 00:30:32,290
thousand lines of code and here to get

00:30:29,710 --> 00:30:36,490
28% faster when combined version front

00:30:32,290 --> 00:30:39,250
end next was akka which is dynamic

00:30:36,490 --> 00:30:43,540
bigger story about 30 thousand lines of

00:30:39,250 --> 00:30:48,040
code 1800 sauce wives and we get here to

00:30:43,540 --> 00:30:49,630
19% faster when compiling an apache

00:30:48,040 --> 00:30:51,400
spark is the biggest that we've tried

00:30:49,630 --> 00:30:52,809
it's four hundred thousand lines of code

00:30:51,400 --> 00:30:56,080
in here do we get

00:30:52,809 --> 00:30:58,720
28% faster and I should mention also

00:30:56,080 --> 00:31:01,090
this is the compilation of hot SBT

00:30:58,720 --> 00:31:04,000
versus hot group so we've been running

00:31:01,090 --> 00:31:06,340
for 10 to 15

00:31:04,000 --> 00:31:08,169
so that we get a hot compilation state

00:31:06,340 --> 00:31:09,760
we're making sure it's stable because

00:31:08,169 --> 00:31:11,020
the machine have inside alized we're

00:31:09,760 --> 00:31:12,940
using the image to make sure that

00:31:11,020 --> 00:31:15,789
everything is reproducible as much as we

00:31:12,940 --> 00:31:18,100
can and those are numbers that we get if

00:31:15,789 --> 00:31:21,909
you plot everything normalized so in

00:31:18,100 --> 00:31:25,690
green this is blue versus SBT in blue we

00:31:21,909 --> 00:31:27,669
should switch that so as you can see

00:31:25,690 --> 00:31:29,320
even if you project this small to big

00:31:27,669 --> 00:31:31,570
you can expect to get with bloop at

00:31:29,320 --> 00:31:33,309
least 20% improvement which i think is

00:31:31,570 --> 00:31:34,630
nice when you compare that to all the

00:31:33,309 --> 00:31:36,789
work that has been done the Scholastic

00:31:34,630 --> 00:31:39,580
compiler to get a similar performance

00:31:36,789 --> 00:31:46,450
improvement you can to today using loop

00:31:39,580 --> 00:31:48,909
instead of SBT so of course the most

00:31:46,450 --> 00:31:52,570
interesting thing of loop to me is the

00:31:48,909 --> 00:31:54,370
new use cases that it enables and how we

00:31:52,570 --> 00:31:56,200
can invest our resources at the sky

00:31:54,370 --> 00:31:59,140
Center in an effective way you have the

00:31:56,200 --> 00:32:01,419
biggest impact out there for you guys so

00:31:59,140 --> 00:32:03,640
you can develop a Scala code better so

00:32:01,419 --> 00:32:06,549
one of these use cases is remote

00:32:03,640 --> 00:32:08,200
compilation the idea of okay so I reuse

00:32:06,549 --> 00:32:10,000
hot compilers locally but I want to

00:32:08,200 --> 00:32:11,919
reuse them in the cloud as well

00:32:10,000 --> 00:32:13,240
because I want to compile as much as as

00:32:11,919 --> 00:32:17,279
fast as possible and that's especially

00:32:13,240 --> 00:32:19,360
important for for CI turnarounds that

00:32:17,279 --> 00:32:21,370
it's especially important the Seattle

00:32:19,360 --> 00:32:23,710
neurons are as fast as possible because

00:32:21,370 --> 00:32:25,960
that encourages changes and you want to

00:32:23,710 --> 00:32:32,500
be blocked by your CI to report errors

00:32:25,960 --> 00:32:33,970
back to you so it is a popular use case

00:32:32,500 --> 00:32:35,529
for CI servers there are some builders

00:32:33,970 --> 00:32:37,720
that are tackling this problem it's not

00:32:35,529 --> 00:32:39,549
an easy problem for instance basil is

00:32:37,720 --> 00:32:43,929
trying like has now a remote compilation

00:32:39,549 --> 00:32:45,610
API but it requires as I said

00:32:43,929 --> 00:32:49,120
architectural changes and those are not

00:32:45,610 --> 00:32:50,380
easy to do even for one build tool I'm

00:32:49,120 --> 00:32:53,529
not going to dive into the details now

00:32:50,380 --> 00:32:55,450
but what's required for this feature but

00:32:53,529 --> 00:33:01,929
it's an important feature to consider in

00:32:55,450 --> 00:33:05,830
the future there is something special

00:33:01,929 --> 00:33:08,649
well there is something there is a use

00:33:05,830 --> 00:33:11,080
case and that is it the use case of

00:33:08,649 --> 00:33:14,760
traditional compilation that it could be

00:33:11,080 --> 00:33:17,060
improved even if we don't realize and

00:33:14,760 --> 00:33:20,090
usually when we have

00:33:17,060 --> 00:33:23,270
four modules like let's say a B C and D

00:33:20,090 --> 00:33:26,510
and BC depend on a and D depends on C

00:33:23,270 --> 00:33:30,530
you need to finish until the compilation

00:33:26,510 --> 00:33:32,180
of a is done sorry you need to wait

00:33:30,530 --> 00:33:33,290
until the computation of a is done so

00:33:32,180 --> 00:33:36,770
that you can start computation of a

00:33:33,290 --> 00:33:39,290
piece and C and you do the same for D so

00:33:36,770 --> 00:33:42,260
T needs to wait for c2 to finish so that

00:33:39,290 --> 00:33:43,640
you can start a compilation there but

00:33:42,260 --> 00:33:46,010
this is less than ideal and there are

00:33:43,640 --> 00:33:49,940
some changes in the compiler that we can

00:33:46,010 --> 00:33:51,590
make to prevent this like to change a

00:33:49,940 --> 00:33:53,870
little bit this picture and give you

00:33:51,590 --> 00:33:55,460
better performance in both batch

00:33:53,870 --> 00:33:58,340
compilation and incremental compilation

00:33:55,460 --> 00:34:00,890
and that is called pipeline compilation

00:33:58,340 --> 00:34:03,560
so pipeline compilation is the idea of

00:34:00,890 --> 00:34:06,410
okay it happens that I can start

00:34:03,560 --> 00:34:10,310
compilation of dependent modules way

00:34:06,410 --> 00:34:12,740
before the compiler has finished and the

00:34:10,310 --> 00:34:14,720
reason for that is that the first part

00:34:12,740 --> 00:34:16,100
of the compilation is used for type

00:34:14,720 --> 00:34:18,740
checking your program and the second

00:34:16,100 --> 00:34:21,169
part is used to kind of like change your

00:34:18,740 --> 00:34:26,510
program so that the generation of class

00:34:21,169 --> 00:34:28,040
files can be done and here we are taking

00:34:26,510 --> 00:34:30,860
advantage of the fact that we don't need

00:34:28,040 --> 00:34:36,169
the class files from a to compile B and

00:34:30,860 --> 00:34:38,720
C and on average that actually makes a

00:34:36,169 --> 00:34:40,700
huge difference because typer

00:34:38,720 --> 00:34:44,750
like type checking a program takes

00:34:40,700 --> 00:34:47,840
around 60% of your time of the time it

00:34:44,750 --> 00:34:49,159
takes to compile and 40% is goes to

00:34:47,840 --> 00:34:52,130
other phases that are related to

00:34:49,159 --> 00:34:54,050
classify generation so by asserting

00:34:52,130 --> 00:34:55,940
before the compilation of all the

00:34:54,050 --> 00:34:58,220
dependent modules no matter what the

00:34:55,940 --> 00:35:00,050
shape of your bill graph is we can make

00:34:58,220 --> 00:35:03,140
a huge difference in your compile times

00:35:00,050 --> 00:35:05,630
because the changes accumulate so if you

00:35:03,140 --> 00:35:09,340
have be busy in this case we'll start 40

00:35:05,630 --> 00:35:14,740
percent fat like before but D will start

00:35:09,340 --> 00:35:17,990
40 per 40 percent plus 40 percent before

00:35:14,740 --> 00:35:20,240
so this idea was pitched in by Rory

00:35:17,990 --> 00:35:22,820
graves well last year I think at Scala

00:35:20,240 --> 00:35:25,610
sphere and I fell in love with this with

00:35:22,820 --> 00:35:29,380
this idea I think it was wonderful and I

00:35:25,610 --> 00:35:30,830
decided to implement it in blood so I

00:35:29,380 --> 00:35:33,050
implemented it in blue

00:35:30,830 --> 00:35:35,450
and I have the changes also required in

00:35:33,050 --> 00:35:37,730
saying the nice idea about the nice

00:35:35,450 --> 00:35:40,220
property of this implementation is that

00:35:37,730 --> 00:35:42,380
it's completely agnostic and it means

00:35:40,220 --> 00:35:44,120
that we will be using pipeline

00:35:42,380 --> 00:35:47,690
compilation for both the Scala to annex

00:35:44,120 --> 00:35:49,340
color 3 and it means that we have a high

00:35:47,690 --> 00:35:51,920
impact for any kind of bill graph you

00:35:49,340 --> 00:35:54,320
have so you have a sequential bill graph

00:35:51,920 --> 00:35:55,820
in which you have three modules and one

00:35:54,320 --> 00:35:57,890
depends on the other one and the other

00:35:55,820 --> 00:36:00,020
one depends on the other one then you'll

00:35:57,890 --> 00:36:02,630
get there are 40 percent faster

00:36:00,020 --> 00:36:04,910
compilation but if you have highly

00:36:02,630 --> 00:36:06,440
parallelizable machine sorry bill graph

00:36:04,910 --> 00:36:08,930
and you also have a machine with lots of

00:36:06,440 --> 00:36:13,060
course the impact can be huge we don't

00:36:08,930 --> 00:36:16,250
yet have results for for the kind of

00:36:13,060 --> 00:36:17,840
impact that this feature does but we

00:36:16,250 --> 00:36:21,350
suspect that it will be it would be

00:36:17,840 --> 00:36:23,510
important and we will showcase the batch

00:36:21,350 --> 00:36:27,800
one image the benchmark numbers in in

00:36:23,510 --> 00:36:30,380
new york so thank you for listening to

00:36:27,800 --> 00:36:41,360
us if you have any questions we are here

00:36:30,380 --> 00:36:43,550
and happy tooling so thanks a lot

00:36:41,360 --> 00:36:48,920
are there questions right away Oh a lot

00:36:43,550 --> 00:36:50,540
of questions I start I was wondering to

00:36:48,920 --> 00:36:53,390
what level of detail does the BSB

00:36:50,540 --> 00:36:55,550
protocol go for IDs can be use it to do

00:36:53,390 --> 00:36:57,380
things like find implicit conversions

00:36:55,550 --> 00:36:58,280
and highlight type signatures and stuff

00:36:57,380 --> 00:36:59,720
like that because otherwise they'd have

00:36:58,280 --> 00:37:00,410
to have their own cache for that sort of

00:36:59,720 --> 00:37:02,780
stuff anyway

00:37:00,410 --> 00:37:04,730
so but in this case doesn't do any any

00:37:02,780 --> 00:37:06,440
of that so bsp only provides you thing

00:37:04,730 --> 00:37:08,420
from only provides you as a language

00:37:06,440 --> 00:37:10,190
server the information about a class

00:37:08,420 --> 00:37:12,670
path and the kind of libraries you need

00:37:10,190 --> 00:37:15,920
to index or you need to kind of find a

00:37:12,670 --> 00:37:18,680
find well provide all the IDE from the

00:37:15,920 --> 00:37:20,660
IV information from so BSP is only about

00:37:18,680 --> 00:37:22,520
Bell Tolls it's only about kind of like

00:37:20,660 --> 00:37:24,560
expressing this bill graph and giving it

00:37:22,520 --> 00:37:26,000
to the client and the client can do

00:37:24,560 --> 00:37:28,490
whatever it wants so you could imagine

00:37:26,000 --> 00:37:31,100
if you are a VI user and you don't like

00:37:28,490 --> 00:37:33,770
idea is you could imagine via BSP

00:37:31,100 --> 00:37:35,630
integration in VI that just allows you

00:37:33,770 --> 00:37:38,750
to compile from the I from the user

00:37:35,630 --> 00:37:40,070
interface and directly tells the server

00:37:38,750 --> 00:37:43,010
hey compile this thing and then goes

00:37:40,070 --> 00:37:44,360
back like come back right so in this

00:37:43,010 --> 00:37:47,570
case it's independent

00:37:44,360 --> 00:37:50,960
from ideas and it's independent from LSP

00:37:47,570 --> 00:37:53,420
it better complements LSP and it doesn't

00:37:50,960 --> 00:37:58,490
try to kind of replace the purpose of

00:37:53,420 --> 00:38:00,650
LSP in order to do the courage aroma

00:37:58,490 --> 00:38:02,150
value want to know what the type is in

00:38:00,650 --> 00:38:04,370
order for the IDE to show that to you it

00:38:02,150 --> 00:38:05,480
has to have the whole class path of

00:38:04,370 --> 00:38:07,520
course yeah so you still have a

00:38:05,480 --> 00:38:08,090
duplicate memory usage tender id needing

00:38:07,520 --> 00:38:09,860
to figure that out

00:38:08,090 --> 00:38:11,210
anther will serve in the background kind

00:38:09,860 --> 00:38:13,130
of sort of a form um was hoping that

00:38:11,210 --> 00:38:14,750
like older whatever there was a two

00:38:13,130 --> 00:38:16,370
gigabytes of dependencies out of my

00:38:14,750 --> 00:38:19,430
class path now only need to be a memory

00:38:16,370 --> 00:38:21,410
once and the IDE why do you need to have

00:38:19,430 --> 00:38:23,450
it in memory no to calculate the type

00:38:21,410 --> 00:38:25,420
but the type is like that's an

00:38:23,450 --> 00:38:27,920
implementation detail of the LSP server

00:38:25,420 --> 00:38:29,180
so when we talk about language servers

00:38:27,920 --> 00:38:30,950
let me servers implement the LSP

00:38:29,180 --> 00:38:33,470
protocol right yes what they are servers

00:38:30,950 --> 00:38:35,300
on their own but in this case when we

00:38:33,470 --> 00:38:37,730
like these servers need to connect to

00:38:35,300 --> 00:38:39,050
build tools to kind of know what the

00:38:37,730 --> 00:38:40,610
classpath of you're like what the

00:38:39,050 --> 00:38:42,620
projects in your in your workspace are

00:38:40,610 --> 00:38:44,570
right but it doesn't like that's an

00:38:42,620 --> 00:38:46,400
independent problem from the problem of

00:38:44,570 --> 00:38:49,220
doing type on hover or like go to

00:38:46,400 --> 00:38:51,680
definition its independent so you get

00:38:49,220 --> 00:38:54,080
information you need for providing like

00:38:51,680 --> 00:38:56,650
for for implement for providing the idea

00:38:54,080 --> 00:38:58,520
experience from the people but that's a

00:38:56,650 --> 00:39:00,470
completely different problem

00:38:58,520 --> 00:39:06,590
I agree but that's let's take the plans

00:39:00,470 --> 00:39:09,200
okay okay yeah that you could do this

00:39:06,590 --> 00:39:11,180
for multiple projects and they have one

00:39:09,200 --> 00:39:12,830
instance running but my experience is

00:39:11,180 --> 00:39:14,180
that most projects have different

00:39:12,830 --> 00:39:16,550
versions of the compiler in their

00:39:14,180 --> 00:39:18,200
requirements mm-hmm so then you will

00:39:16,550 --> 00:39:21,800
have like multiple versions of the

00:39:18,200 --> 00:39:23,300
compiler hot running in memory sure you

00:39:21,800 --> 00:39:25,520
have different class orders for every

00:39:23,300 --> 00:39:27,520
compiler version you use so of course

00:39:25,520 --> 00:39:32,240
you use a little bit more of memory but

00:39:27,520 --> 00:39:34,190
yeah there and you have little less gain

00:39:32,240 --> 00:39:35,660
of like hot compilers sure if you use

00:39:34,190 --> 00:39:38,360
different compiler versions for every

00:39:35,660 --> 00:39:40,730
kind of like build you have yeah but the

00:39:38,360 --> 00:39:43,420
idea is that well usually I haven't seen

00:39:40,730 --> 00:39:45,830
that use case much but in my experience

00:39:43,420 --> 00:39:49,130
all the bills use the same compiler

00:39:45,830 --> 00:39:52,070
version and if you don't you are

00:39:49,130 --> 00:39:53,660
probably stuck on 211 and 212 right so

00:39:52,070 --> 00:39:56,090
you'll have one class over heavily

00:39:53,660 --> 00:39:57,680
optimized by the JVM for 211 and the

00:39:56,090 --> 00:40:02,809
other one for 212

00:39:57,680 --> 00:40:04,910
but you'll get a stated speed-up just

00:40:02,809 --> 00:40:08,510
want to clarify a little bit about the

00:40:04,910 --> 00:40:10,609
integration with ideas so don't stand

00:40:08,510 --> 00:40:12,920
corrected that when you change is B key

00:40:10,609 --> 00:40:15,980
file let's say you still need to run the

00:40:12,920 --> 00:40:18,890
import blue house called start bloop

00:40:15,980 --> 00:40:21,170
because bloop needs this Jason still

00:40:18,890 --> 00:40:25,069
generates a JSON file so essentially to

00:40:21,170 --> 00:40:28,520
run SBT again kind of start this BT go

00:40:25,069 --> 00:40:32,119
for all this ordeal of SBT loading etc

00:40:28,520 --> 00:40:33,859
so is it really a gain in kind of

00:40:32,119 --> 00:40:36,740
performance when we need to refresh the

00:40:33,859 --> 00:40:39,500
project right so that has to do with the

00:40:36,740 --> 00:40:41,029
way bloop works right now as a CLI but

00:40:39,500 --> 00:40:43,220
when we were talking about integrations

00:40:41,029 --> 00:40:45,410
that problem goes away completely

00:40:43,220 --> 00:40:48,020
because you don't need to create a

00:40:45,410 --> 00:40:50,650
configuration file in your disk in order

00:40:48,020 --> 00:40:55,460
to communicate with the bloop server or

00:40:50,650 --> 00:40:57,380
blue PSP server yeah you need to

00:40:55,460 --> 00:40:59,119
you do need the bloop configuration file

00:40:57,380 --> 00:41:01,730
sir because use needs to send a request

00:40:59,119 --> 00:41:04,069
of compilation or I want to see what

00:41:01,730 --> 00:41:06,950
projects you define so in that case that

00:41:04,069 --> 00:41:09,859
that was the BSP was the solution of the

00:41:06,950 --> 00:41:11,329
kind of not ideal integration we have

00:41:09,859 --> 00:41:15,619
right now with SPT in which you need to

00:41:11,329 --> 00:41:18,529
do this to a step process okay so like

00:41:15,619 --> 00:41:20,630
SBT will be running already can prepared

00:41:18,529 --> 00:41:23,119
and then blue who'll be also running

00:41:20,630 --> 00:41:26,029
like a server then intelligible can be

00:41:23,119 --> 00:41:29,569
much faster to refresh the project you

00:41:26,029 --> 00:41:31,400
want to change the PSP server with all

00:41:29,569 --> 00:41:33,260
the information then you have like Intel

00:41:31,400 --> 00:41:34,609
Jake when I came to a BSP server and SBT

00:41:33,260 --> 00:41:36,740
connecting to a BSP server

00:41:34,609 --> 00:41:38,569
okay so then intelligible not need SBT

00:41:36,740 --> 00:41:40,609
server running in order to refresh the

00:41:38,569 --> 00:41:43,010
project yeah right what you wouldn't

00:41:40,609 --> 00:41:44,630
need that okay so and the neat thing

00:41:43,010 --> 00:41:46,190
about that is that it was also for other

00:41:44,630 --> 00:41:47,059
build tools like maybe an and cradle and

00:41:46,190 --> 00:41:49,720
and whatnot

00:41:47,059 --> 00:41:52,760
and you all need to maintain one BSP

00:41:49,720 --> 00:41:55,819
integration the one in IntelliJ and the

00:41:52,760 --> 00:41:58,279
one individuals could you maybe show us

00:41:55,819 --> 00:42:01,080
a short video of the IntelliJ

00:41:58,279 --> 00:42:03,780
integration commands and screenshots

00:42:01,080 --> 00:42:17,280
you already know we don't have the time

00:42:03,780 --> 00:42:19,640
for it so this may be time for one or

00:42:17,280 --> 00:42:19,640
two more questions

00:42:22,820 --> 00:42:29,070
you mentioned play a short very short

00:42:26,630 --> 00:42:31,230
how does that integration work today or

00:42:29,070 --> 00:42:33,450
does it not work at all or it doesn't

00:42:31,230 --> 00:42:35,160
work at this moment but we're working on

00:42:33,450 --> 00:42:39,240
a better a split integration based on

00:42:35,160 --> 00:42:42,540
the PSP client like in like architecture

00:42:39,240 --> 00:42:44,160
so that that use case is supported at

00:42:42,540 --> 00:42:46,170
the moment it is not so in the future

00:42:44,160 --> 00:42:47,970
you will be able to run bloop with play

00:42:46,170 --> 00:42:48,960
framework and indeed have the whole

00:42:47,970 --> 00:42:50,340
pipeline

00:42:48,960 --> 00:42:53,850
the idea is to fully integrate with the

00:42:50,340 --> 00:42:56,130
bill to deduce and to complement while

00:42:53,850 --> 00:43:03,780
still giving the best performance when

00:42:56,130 --> 00:43:07,010
compiling so I think there were all the

00:43:03,780 --> 00:43:07,010
question thank you very much

00:43:07,880 --> 00:43:13,380
[Applause]

00:43:10,080 --> 00:43:16,050
you manage to be everyone awake we

00:43:13,380 --> 00:43:18,500
actually have here like ask like video

00:43:16,050 --> 00:43:24,630
that Justin just sent me now of how the

00:43:18,500 --> 00:43:27,000
how the import project works for for

00:43:24,630 --> 00:43:28,890
bloop so in this case we are showing how

00:43:27,000 --> 00:43:30,570
which like bloop is running in the

00:43:28,890 --> 00:43:32,940
background right now and we have

00:43:30,570 --> 00:43:36,570
IntelliJ so we say okay import a project

00:43:32,940 --> 00:43:39,810
with VSP and immediately like in 604 is

00:43:36,570 --> 00:43:42,180
for 14 milliseconds it it kind of

00:43:39,810 --> 00:43:44,250
imports all the project so if you do it

00:43:42,180 --> 00:43:48,330
for a big project like a Patti spark the

00:43:44,250 --> 00:43:51,780
difference is in like in is very big so

00:43:48,330 --> 00:43:56,460
we have apache spark importing the rbsp

00:43:51,780 --> 00:43:57,630
in 9 seconds with loop and BIA SBT it

00:43:56,460 --> 00:43:59,730
takes around 4 minutes

00:43:57,630 --> 00:44:01,500
so every time you reload or to change

00:43:59,730 --> 00:44:03,780
like a dependency you need to go through

00:44:01,500 --> 00:44:05,990
all this process and bsp makes that much

00:44:03,780 --> 00:44:05,990
better

00:44:06,940 --> 00:44:10,139

YouTube URL: https://www.youtube.com/watch?v=SIP1Y-0Bxow


