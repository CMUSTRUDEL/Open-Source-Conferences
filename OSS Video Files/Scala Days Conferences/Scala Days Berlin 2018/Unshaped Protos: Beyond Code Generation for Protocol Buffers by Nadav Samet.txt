Title: Unshaped Protos: Beyond Code Generation for Protocol Buffers by Nadav Samet
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6940-unshaped-protos%3A-beyond-code-generation-for-protocol-buffers.html
Captions: 
	00:00:04,620 --> 00:00:09,400
so hi everyone I'm really excited to be

00:00:07,630 --> 00:00:11,170
here thanks for coming to my talk it's

00:00:09,400 --> 00:00:12,639
really heartwarming to see so many

00:00:11,170 --> 00:00:16,660
people are that are interested in

00:00:12,639 --> 00:00:18,760
protocol buffers so let me introduce

00:00:16,660 --> 00:00:21,070
myself my name is Nadav summit

00:00:18,760 --> 00:00:23,199
I'm an engineering manager in a start-up

00:00:21,070 --> 00:00:26,170
called tubular labs in a Mountain View

00:00:23,199 --> 00:00:28,570
California and I'm also the author of a

00:00:26,170 --> 00:00:31,300
library called scalloped EB which makes

00:00:28,570 --> 00:00:33,490
it fun and easy to use protocol buffers

00:00:31,300 --> 00:00:35,620
in Scala so in case you don't know

00:00:33,490 --> 00:00:39,489
protocol buffers is a technology that

00:00:35,620 --> 00:00:41,680
Google developed that makes a basically

00:00:39,489 --> 00:00:44,020
enables the distributed systems to

00:00:41,680 --> 00:00:48,039
exchange messages in an efficient binary

00:00:44,020 --> 00:00:50,230
format and I created Scala PB because I

00:00:48,039 --> 00:00:52,629
wanted to have an idiomatic way to use

00:00:50,230 --> 00:00:54,430
protocol buffers in Scala taking

00:00:52,629 --> 00:00:56,430
advantage of case classes and other

00:00:54,430 --> 00:00:58,750
things that are available in Scala

00:00:56,430 --> 00:01:04,660
to make it more pleasant to use than the

00:00:58,750 --> 00:01:06,940
Java a fork or buffers so I created this

00:01:04,660 --> 00:01:09,040
project about four years ago it's on

00:01:06,940 --> 00:01:12,850
github and it's been going in popularity

00:01:09,040 --> 00:01:15,820
ever since but then one day six months

00:01:12,850 --> 00:01:18,970
ago a user comes to me and tells me that

00:01:15,820 --> 00:01:21,670
they want to use Scala PB but without

00:01:18,970 --> 00:01:24,310
giving it any protocol buffers and ask

00:01:21,670 --> 00:01:26,200
me if it's possible to do it that

00:01:24,310 --> 00:01:28,990
sounded like a pretty crazy idea to me

00:01:26,200 --> 00:01:31,360
because what Scala PB does is basically

00:01:28,990 --> 00:01:33,430
taking protocol buffers and generating

00:01:31,360 --> 00:01:35,680
case classes for them with serializers

00:01:33,430 --> 00:01:38,020
and D sterilizers so basically telling

00:01:35,680 --> 00:01:40,570
me that they want to use Scala PB but

00:01:38,020 --> 00:01:41,920
without giving it any protocol buffer

00:01:40,570 --> 00:01:43,450
it's like making me that they want to

00:01:41,920 --> 00:01:47,380
make a peanut butter and jelly sandwich

00:01:43,450 --> 00:01:49,299
but without the peanut butter so then I

00:01:47,380 --> 00:01:51,909
come down and revealed a little bit and

00:01:49,299 --> 00:01:53,079
relaxed and I figured out that there

00:01:51,909 --> 00:01:56,590
actually might be a very interesting

00:01:53,079 --> 00:01:58,450
challenge in there maybe instead of

00:01:56,590 --> 00:02:00,850
starting from a protocol buffer and

00:01:58,450 --> 00:02:04,090
generating case classes and serializers

00:02:00,850 --> 00:02:05,829
and this realizes we will start from the

00:02:04,090 --> 00:02:10,509
case class we'll think of about the case

00:02:05,829 --> 00:02:12,250
class as this schema a that this is

00:02:10,509 --> 00:02:13,900
basically a starting point and we will

00:02:12,250 --> 00:02:15,610
infer the protocol buffer from the case

00:02:13,900 --> 00:02:18,640
class and all the other way around

00:02:15,610 --> 00:02:21,370
and basically generates serializers and

00:02:18,640 --> 00:02:23,560
D sterilizers from the case class so as

00:02:21,370 --> 00:02:26,260
I looked into ways to accomplish this

00:02:23,560 --> 00:02:28,330
and researched few ideas I learned a lot

00:02:26,260 --> 00:02:30,400
of techniques that related to what's

00:02:28,330 --> 00:02:32,770
called the generic programming basically

00:02:30,400 --> 00:02:36,090
processing user-provided data types such

00:02:32,770 --> 00:02:38,920
as case classes in add in a generic way

00:02:36,090 --> 00:02:40,720
so the beauty of these techniques is

00:02:38,920 --> 00:02:43,030
that they are not apply they're not

00:02:40,720 --> 00:02:45,940
specific to Scala PD or to protocol

00:02:43,030 --> 00:02:49,450
buffers but they can be applied in in

00:02:45,940 --> 00:02:51,460
anytime where you want to use a when you

00:02:49,450 --> 00:02:53,200
basically want to iterate over some data

00:02:51,460 --> 00:02:55,450
type that the user provides and you want

00:02:53,200 --> 00:02:56,890
to do something for each field in a

00:02:55,450 --> 00:02:59,470
generic way so you don't know the data

00:02:56,890 --> 00:03:02,230
type ahead of time so what I'd like to

00:02:59,470 --> 00:03:03,850
to suggest here is that maybe you try to

00:03:02,230 --> 00:03:05,200
think how what I'm showing you is

00:03:03,850 --> 00:03:07,209
relevant to the project that you're

00:03:05,200 --> 00:03:09,340
working on those techniques are really

00:03:07,209 --> 00:03:10,930
powerful and once you master them you'll

00:03:09,340 --> 00:03:12,790
be able to get the compiler to do a lot

00:03:10,930 --> 00:03:15,760
of work for you and cut down a lot of

00:03:12,790 --> 00:03:17,680
repetitive code and that means fewer

00:03:15,760 --> 00:03:21,420
bugs and generally happier life for

00:03:17,680 --> 00:03:23,769
everyone so let's say let's start I

00:03:21,420 --> 00:03:26,290
briefly told you what protocol buffers

00:03:23,769 --> 00:03:29,980
are but let's cover it now in in more

00:03:26,290 --> 00:03:32,709
detail so protocol buffers is a language

00:03:29,980 --> 00:03:35,650
that lets you define data structures and

00:03:32,709 --> 00:03:38,320
it also defines a particular way to

00:03:35,650 --> 00:03:40,989
serialize them it's it's basically

00:03:38,320 --> 00:03:43,060
defines a specific binary format and it

00:03:40,989 --> 00:03:45,970
generates classes or code for different

00:03:43,060 --> 00:03:47,920
languages like Java Python C++ and also

00:03:45,970 --> 00:03:50,110
with Scala PB and the beauty of this

00:03:47,920 --> 00:03:52,480
system is that it doesn't matter which

00:03:50,110 --> 00:03:54,550
platform or language you use you can now

00:03:52,480 --> 00:03:56,260
have like a silver team writing code in

00:03:54,550 --> 00:03:58,030
one language and a client team writing

00:03:56,260 --> 00:03:59,860
code in another language they both have

00:03:58,030 --> 00:04:01,209
access to the same protocol buffer and

00:03:59,860 --> 00:04:05,380
they basically can adjust exchange

00:04:01,209 --> 00:04:07,290
messages here is an example of what the

00:04:05,380 --> 00:04:11,470
protocol buffer look like we define a

00:04:07,290 --> 00:04:13,810
message called person and it has a first

00:04:11,470 --> 00:04:16,479
name a which is a string a last name

00:04:13,810 --> 00:04:19,510
which is another string and an H which

00:04:16,479 --> 00:04:21,640
is an integer and every field comes with

00:04:19,510 --> 00:04:22,390
a number so when the message gets

00:04:21,640 --> 00:04:25,150
serialized

00:04:22,390 --> 00:04:27,580
instead of a writing the field name like

00:04:25,150 --> 00:04:29,230
we do in JSON we write with code in a

00:04:27,580 --> 00:04:31,210
binary format the tag number

00:04:29,230 --> 00:04:34,410
and this is one of the reasons why this

00:04:31,210 --> 00:04:36,940
this encoding is relatively efficient

00:04:34,410 --> 00:04:41,380
then we use a command line tool called

00:04:36,940 --> 00:04:43,180
protists C which basically a takes the

00:04:41,380 --> 00:04:44,770
protocol buffer and generates code to it

00:04:43,180 --> 00:04:49,420
in in different languages that it

00:04:44,770 --> 00:04:51,610
supports and scallop e be a adzes SBT

00:04:49,420 --> 00:04:55,570
plug-in that lets you basically generate

00:04:51,610 --> 00:04:57,070
code for a for Scala and it's part of it

00:04:55,570 --> 00:05:01,930
becomes part of your development was

00:04:57,070 --> 00:05:05,320
part of your build tool so this is an

00:05:01,930 --> 00:05:07,450
example of a of the generated code so on

00:05:05,320 --> 00:05:09,640
the left side we see the the protocol

00:05:07,450 --> 00:05:11,740
buffer on the right side we see that the

00:05:09,640 --> 00:05:13,780
code that gets generated so basically

00:05:11,740 --> 00:05:15,580
you see that every field in the protocol

00:05:13,780 --> 00:05:18,370
buffer becomes a field in a case class

00:05:15,580 --> 00:05:21,580
and there is a very important method

00:05:18,370 --> 00:05:24,460
over there to byte array that basically

00:05:21,580 --> 00:05:26,710
takes the instance a but it but it's

00:05:24,460 --> 00:05:29,260
running on and returning an array of by

00:05:26,710 --> 00:05:32,830
array of bytes that's representing the

00:05:29,260 --> 00:05:34,510
the protocol buffer in the companion

00:05:32,830 --> 00:05:37,960
object we have a method called parse

00:05:34,510 --> 00:05:40,480
from which does the opposite thing so it

00:05:37,960 --> 00:05:42,190
basically takes the array of bytes and

00:05:40,480 --> 00:05:44,460
give you back the instance that you see

00:05:42,190 --> 00:05:48,220
realized so let's see this in action I

00:05:44,460 --> 00:05:49,720
start with a defining a person and it

00:05:48,220 --> 00:05:52,420
has a first name and last name and an

00:05:49,720 --> 00:05:54,940
age I just put some values and I call

00:05:52,420 --> 00:05:56,620
two byte array and I also make it a

00:05:54,940 --> 00:05:58,480
vector so the presentation is a little

00:05:56,620 --> 00:06:00,900
bit nicer and you see at the bottom we

00:05:58,480 --> 00:06:04,750
get an array of numbers that represent

00:06:00,900 --> 00:06:06,430
the message and we can go in the

00:06:04,750 --> 00:06:08,290
opposite direction you see now in the

00:06:06,430 --> 00:06:12,040
middle window we start from the array of

00:06:08,290 --> 00:06:14,680
bytes and we call person dot pass form

00:06:12,040 --> 00:06:16,570
and we get back the case class we get

00:06:14,680 --> 00:06:20,410
basically the instance of the case first

00:06:16,570 --> 00:06:22,450
that we we see realized before so this

00:06:20,410 --> 00:06:25,390
is all what you need to know on a on

00:06:22,450 --> 00:06:27,340
protocol buffers and now remember the

00:06:25,390 --> 00:06:29,020
guy that wanted to basically not write

00:06:27,340 --> 00:06:32,110
any protocol buffers but start from the

00:06:29,020 --> 00:06:36,310
case class so let's see what this

00:06:32,110 --> 00:06:37,900
approach can look like a so he first

00:06:36,310 --> 00:06:41,380
would just think why would anybody want

00:06:37,900 --> 00:06:43,080
to do that at all so one reason that you

00:06:41,380 --> 00:06:45,289
know somebody would not want to write

00:06:43,080 --> 00:06:47,610
- kielbasa is that they were just one up

00:06:45,289 --> 00:06:49,139
not some people just don't like

00:06:47,610 --> 00:06:50,490
cogeneration just get an allergic

00:06:49,139 --> 00:06:55,139
reaction when they hear about

00:06:50,490 --> 00:06:56,759
cogeneration and a in other in other

00:06:55,139 --> 00:06:58,229
environments like you know protocol

00:06:56,759 --> 00:06:59,900
buffers are useful for different teams

00:06:58,229 --> 00:07:02,280
when they want to share an interface a

00:06:59,900 --> 00:07:04,979
that they can see you know what messages

00:07:02,280 --> 00:07:07,800
are allowed and so on but sometimes you

00:07:04,979 --> 00:07:09,120
have one project that is monolithic and

00:07:07,800 --> 00:07:10,800
you know the messages never get

00:07:09,120 --> 00:07:14,219
serialized it's one code base that's

00:07:10,800 --> 00:07:17,099
just small and that in term of a bill

00:07:14,219 --> 00:07:20,909
operable so that's that interoperability

00:07:17,099 --> 00:07:23,039
is not a concern and finally when you

00:07:20,909 --> 00:07:26,610
don't generate code but actually your

00:07:23,039 --> 00:07:28,169
code is the schema then you get control

00:07:26,610 --> 00:07:29,639
over the case classes you can add your

00:07:28,169 --> 00:07:31,500
own methods to them they don't have to

00:07:29,639 --> 00:07:33,960
extend some sunbaes class that you get

00:07:31,500 --> 00:07:38,699
from the library a you basically in

00:07:33,960 --> 00:07:41,419
control of the code so the approach

00:07:38,699 --> 00:07:44,629
might look like this we start from a

00:07:41,419 --> 00:07:46,379
case class the user just provides some

00:07:44,629 --> 00:07:51,060
simple bare-bones

00:07:46,379 --> 00:07:52,740
case class and they instantiate it and

00:07:51,060 --> 00:07:54,210
now they want to serialize it and of

00:07:52,740 --> 00:07:57,449
course now they don't have the two byte

00:07:54,210 --> 00:07:59,339
array method defined on it so that kind

00:07:57,449 --> 00:08:01,529
of stuck and our goal here in this talk

00:07:59,339 --> 00:08:03,779
is basically to help that user give him

00:08:01,529 --> 00:08:06,539
a way to sterilize this case class no

00:08:03,779 --> 00:08:11,580
matter what it is and they we're gonna

00:08:06,539 --> 00:08:14,400
see a few options to do that so

00:08:11,580 --> 00:08:15,779
typically in those situations when you

00:08:14,400 --> 00:08:17,580
don't have a common base class that you

00:08:15,779 --> 00:08:19,680
can use you use the type class pattern

00:08:17,580 --> 00:08:21,719
and basically what we have is the

00:08:19,680 --> 00:08:24,990
message serialize a type pattern a type

00:08:21,719 --> 00:08:26,819
class that gets a type parameter T which

00:08:24,990 --> 00:08:30,000
represents the message maybe a person

00:08:26,819 --> 00:08:31,830
and it has a two byte array method that

00:08:30,000 --> 00:08:34,320
would take the instance of the person

00:08:31,830 --> 00:08:36,449
and return an array of bytes in the

00:08:34,320 --> 00:08:38,729
companion object I define a method apply

00:08:36,449 --> 00:08:41,640
that behaves sort of like a constructor

00:08:38,729 --> 00:08:43,500
for this but instead it's starting an

00:08:41,640 --> 00:08:45,690
implicit search for message serializer

00:08:43,500 --> 00:08:47,940
and this is enabling the syntax that you

00:08:45,690 --> 00:08:50,399
see on the first line in the second

00:08:47,940 --> 00:08:52,170
window that basically when I write

00:08:50,399 --> 00:08:54,720
message serializer square brackets

00:08:52,170 --> 00:08:56,290
pelson i'm it will start an implicit

00:08:54,720 --> 00:08:58,540
search for the instance

00:08:56,290 --> 00:09:00,160
and then I could just use this person

00:08:58,540 --> 00:09:04,090
civilizer that I'm getting back assuming

00:09:00,160 --> 00:09:05,830
I can find this implicit a and when I

00:09:04,090 --> 00:09:09,160
get it I can use it to serialize an

00:09:05,830 --> 00:09:10,660
instance of a person so turns out when

00:09:09,160 --> 00:09:13,540
you want to implement those mess those

00:09:10,660 --> 00:09:15,700
message serializers you have to add the

00:09:13,540 --> 00:09:17,560
two byte array method and the two byte

00:09:15,700 --> 00:09:20,140
array method tends to be very palliative

00:09:17,560 --> 00:09:22,360
it's always the same so what it

00:09:20,140 --> 00:09:24,280
essentially does is it's calling another

00:09:22,360 --> 00:09:27,010
abstract method called serialized size

00:09:24,280 --> 00:09:29,470
to find the size of the of the of the

00:09:27,010 --> 00:09:31,750
encoded message and then it allocates an

00:09:29,470 --> 00:09:33,340
array of byte in that size and then it

00:09:31,750 --> 00:09:35,650
creates something called coded output

00:09:33,340 --> 00:09:37,930
stream which is a class that's provided

00:09:35,650 --> 00:09:40,750
by Google that is that knows how to

00:09:37,930 --> 00:09:43,690
write primitive fields into the into the

00:09:40,750 --> 00:09:46,480
array of bytes and then you call a

00:09:43,690 --> 00:09:48,400
function called write 2 which basically

00:09:46,480 --> 00:09:49,750
takes the output stream in a message and

00:09:48,400 --> 00:09:51,730
writes the message encodes the message

00:09:49,750 --> 00:09:54,610
into the output stream and finally

00:09:51,730 --> 00:09:56,920
returned the bytes so actually all the

00:09:54,610 --> 00:09:59,350
action is actually happening in the

00:09:56,920 --> 00:10:01,330
right to method this is well the

00:09:59,350 --> 00:10:02,950
interesting stuff is happening so from

00:10:01,330 --> 00:10:04,840
now on we're just going to focus on how

00:10:02,950 --> 00:10:09,490
would we implement the right to method

00:10:04,840 --> 00:10:11,770
in general option one is called manual

00:10:09,490 --> 00:10:14,980
definition which basically this is like

00:10:11,770 --> 00:10:16,420
a Bart Simpson punishment which says if

00:10:14,980 --> 00:10:18,100
you want to have your own message

00:10:16,420 --> 00:10:18,610
serializer you're gonna have to write it

00:10:18,100 --> 00:10:21,310
yourself

00:10:18,610 --> 00:10:22,690
so it might look like this we're

00:10:21,310 --> 00:10:24,400
basically telling the users we're not

00:10:22,690 --> 00:10:26,080
going to do any work for you you're

00:10:24,400 --> 00:10:28,210
gonna have to write this implicit class

00:10:26,080 --> 00:10:29,620
person serializer and then write in the

00:10:28,210 --> 00:10:32,830
right to method you'll go field by field

00:10:29,620 --> 00:10:39,510
and send it to the outputs to him what

00:10:32,830 --> 00:10:43,090
do you think about that one it's tedious

00:10:39,510 --> 00:10:46,630
it cell phone it's not fun I don't like

00:10:43,090 --> 00:10:49,240
it it's fired let's move on so second

00:10:46,630 --> 00:10:51,040
option is a it's called the runtime

00:10:49,240 --> 00:10:53,110
reflection so this is a very literal

00:10:51,040 --> 00:10:55,030
picture of one time reflection that you

00:10:53,110 --> 00:10:59,490
see there

00:10:55,030 --> 00:11:02,320
and basically ranting reflection is a a

00:10:59,490 --> 00:11:04,990
way to use the information that's

00:11:02,320 --> 00:11:07,780
available to us you know in the in the

00:11:04,990 --> 00:11:10,120
JVM it let us inspect every class and

00:11:07,780 --> 00:11:12,400
list the members of it and ask the JVM

00:11:10,120 --> 00:11:14,530
like what the types of the fields in

00:11:12,400 --> 00:11:16,930
this class and get the values of them so

00:11:14,530 --> 00:11:19,270
the the code that actually does runtime

00:11:16,930 --> 00:11:22,150
reflection tends to be a bit verbose so

00:11:19,270 --> 00:11:24,970
i'm i have pseudocode that kind of gives

00:11:22,150 --> 00:11:28,270
the idea of what it looks like so the

00:11:24,970 --> 00:11:33,520
right to method here would basically go

00:11:28,270 --> 00:11:34,750
over the members of the of the type type

00:11:33,520 --> 00:11:39,460
of tea would give me some type

00:11:34,750 --> 00:11:41,980
information and basically if the member

00:11:39,460 --> 00:11:44,620
is a string we call output dot write

00:11:41,980 --> 00:11:48,460
string if the member is an integer we

00:11:44,620 --> 00:11:52,360
call a output dot right in 32 and so on

00:11:48,460 --> 00:11:54,280
but the problem is what happens if it's

00:11:52,360 --> 00:11:56,440
we don't have here the type the tag we

00:11:54,280 --> 00:11:57,720
actually goes from the user we have two

00:11:56,440 --> 00:12:00,670
options right we can throw an exception

00:11:57,720 --> 00:12:03,820
or we can just ignore the type but none

00:12:00,670 --> 00:12:05,230
of these options are good so and this is

00:12:03,820 --> 00:12:08,170
one of the drawbacks of this approach

00:12:05,230 --> 00:12:09,820
that a we only discover problems for

00:12:08,170 --> 00:12:13,089
example you know if the user wants to

00:12:09,820 --> 00:12:14,350
pass a day time and we just didn't plan

00:12:13,089 --> 00:12:17,200
to like we didn't have a way to

00:12:14,350 --> 00:12:23,260
serialize it then it crashes at runtime

00:12:17,200 --> 00:12:25,450
and so let's just review the the pause

00:12:23,260 --> 00:12:27,490
and cons of this one so the good thing

00:12:25,450 --> 00:12:29,140
about it is that it's not manual like

00:12:27,490 --> 00:12:31,930
the Bart Simpson punishment right so we

00:12:29,140 --> 00:12:33,190
get some something that generates say we

00:12:31,930 --> 00:12:36,100
basically get the function that can

00:12:33,190 --> 00:12:37,720
serialize almost anything and the smoke

00:12:36,100 --> 00:12:39,040
we have a small code is just one

00:12:37,720 --> 00:12:41,410
function so just one class it

00:12:39,040 --> 00:12:44,410
compulsively fast

00:12:41,410 --> 00:12:46,240
on the downside they all disk our get

00:12:44,410 --> 00:12:48,280
getting discovered at runtime so we get

00:12:46,240 --> 00:12:50,050
exceptions if we get at runtime when

00:12:48,280 --> 00:12:54,339
something just doesn't work as intended

00:12:50,050 --> 00:12:56,230
and turns out it's slow really slow so

00:12:54,339 --> 00:13:01,450
slow that we're gonna move on to the

00:12:56,230 --> 00:13:03,790
next one a the third option that that I

00:13:01,450 --> 00:13:08,339
investigated is called their generic

00:13:03,790 --> 00:13:09,509
derivation and finally this is

00:13:08,339 --> 00:13:11,819
something that you know I'm really

00:13:09,509 --> 00:13:14,399
excited about I I learned about it you

00:13:11,819 --> 00:13:16,769
know very recently and this is basically

00:13:14,399 --> 00:13:19,730
a way to get the compiler to create type

00:13:16,769 --> 00:13:23,129
classes for you and it's combining a

00:13:19,730 --> 00:13:25,860
three advanced topics beautifully

00:13:23,129 --> 00:13:28,529
together to to get together the effect

00:13:25,860 --> 00:13:31,129
that we want so those are those concepts

00:13:28,529 --> 00:13:33,689
called H list shapeless generic and

00:13:31,129 --> 00:13:35,970
inductive implicit search just I want to

00:13:33,689 --> 00:13:37,410
see a show of hands like who heard of

00:13:35,970 --> 00:13:40,860
like you know at least one of those

00:13:37,410 --> 00:13:44,670
things I see a lot of events like who

00:13:40,860 --> 00:13:45,540
knows all three then cool so I see that

00:13:44,670 --> 00:13:46,949
there are less people that know all

00:13:45,540 --> 00:13:51,480
three so at least I get a chance to

00:13:46,949 --> 00:13:53,129
teach something and a in just about five

00:13:51,480 --> 00:13:57,240
minutes from now you'll be an expert in

00:13:53,129 --> 00:14:00,689
a generic derivation so let's start with

00:13:57,240 --> 00:14:04,949
H lists so Scala lists are basically

00:14:00,689 --> 00:14:06,540
homogeneous in what sense a in the sense

00:14:04,949 --> 00:14:08,490
that if we basically you know we

00:14:06,540 --> 00:14:11,160
expected to pass things of the same type

00:14:08,490 --> 00:14:14,459
when we instantiate them so if we have a

00:14:11,160 --> 00:14:15,839
one two three and nil the the type in

00:14:14,459 --> 00:14:19,319
fear would tell us that we have a list

00:14:15,839 --> 00:14:20,910
of integers however if we try to do

00:14:19,319 --> 00:14:24,110
something like this throat like random

00:14:20,910 --> 00:14:26,959
things of different types 42 false full

00:14:24,110 --> 00:14:30,059
the compiler will tell us what is the

00:14:26,959 --> 00:14:31,819
least common denominator and invest it

00:14:30,059 --> 00:14:33,929
says we have a list of any so

00:14:31,819 --> 00:14:39,839
essentially we lost the type information

00:14:33,929 --> 00:14:42,269
that they that we had so enter a age

00:14:39,839 --> 00:14:45,120
list if that is implemented in the

00:14:42,269 --> 00:14:47,100
shapeless library and it allows it

00:14:45,120 --> 00:14:51,329
basically provides us an implementation

00:14:47,100 --> 00:14:53,279
of the tow genius linked lists and now

00:14:51,329 --> 00:14:55,769
we can define something like this right

00:14:53,279 --> 00:14:58,339
we import j+ which gives us a new

00:14:55,769 --> 00:15:02,629
meaning for the colon colon operator and

00:14:58,339 --> 00:15:05,910
and we get basically we can compose a

00:15:02,629 --> 00:15:08,009
this list like this given different

00:15:05,910 --> 00:15:09,949
types and at the at the end we put h nil

00:15:08,009 --> 00:15:14,670
which represents the empty a

00:15:09,949 --> 00:15:16,920
heterogenous list and when we run this a

00:15:14,670 --> 00:15:19,279
basically the inferred type would be int

00:15:16,920 --> 00:15:22,290
colon colon boolean colon colon string

00:15:19,279 --> 00:15:24,720
colon colon HDL which basically

00:15:22,290 --> 00:15:27,240
every type that we would we had in the

00:15:24,720 --> 00:15:29,550
in the instance actually as is

00:15:27,240 --> 00:15:32,130
represented here so we we didn't lose

00:15:29,550 --> 00:15:33,990
any type information like like we had in

00:15:32,130 --> 00:15:36,779
the list any before every type is

00:15:33,990 --> 00:15:39,389
actually captured here it is a quick

00:15:36,779 --> 00:15:42,589
example on how you can use it I can

00:15:39,389 --> 00:15:46,740
define a type alias HL assign it some

00:15:42,589 --> 00:15:49,170
type a definition a define a function

00:15:46,740 --> 00:15:51,300
that accepts an instance of HL does

00:15:49,170 --> 00:15:54,750
nothing I mean it's also an exception

00:15:51,300 --> 00:15:59,190
actually and then pass an instance a of

00:15:54,750 --> 00:16:01,110
that H list to my funk and the the cool

00:15:59,190 --> 00:16:03,899
thing here is that if I pass an instance

00:16:01,110 --> 00:16:05,399
of an age list which with like that one

00:16:03,899 --> 00:16:10,680
of the type isn't right somewhere this

00:16:05,399 --> 00:16:14,100
would just not compile the second day

00:16:10,680 --> 00:16:15,959
advance topic is a generic and generic

00:16:14,100 --> 00:16:18,720
is a type class that knows how to

00:16:15,959 --> 00:16:22,560
convert between data types like case

00:16:18,720 --> 00:16:25,589
classes to the generic representation so

00:16:22,560 --> 00:16:28,800
it is an example for a of what it does

00:16:25,589 --> 00:16:32,730
so it is a where I instantiate a generic

00:16:28,800 --> 00:16:37,920
of a person and the in third type of it

00:16:32,730 --> 00:16:41,370
is basically a contains a type inside of

00:16:37,920 --> 00:16:44,550
a a that's called repeal shorthand for

00:16:41,370 --> 00:16:46,560
the presentation of string string int H

00:16:44,550 --> 00:16:50,990
new anybody knows wives things doing

00:16:46,560 --> 00:16:54,120
into H nil because the person has a

00:16:50,990 --> 00:16:55,860
first name last name which are strings

00:16:54,120 --> 00:16:58,350
and then age which is an int so

00:16:55,860 --> 00:17:02,940
basically detected the fields that a

00:16:58,350 --> 00:17:06,480
that that caseless has and a and they're

00:17:02,940 --> 00:17:09,839
represented here and now I can use it I

00:17:06,480 --> 00:17:12,959
can take a person gen called a dot two

00:17:09,839 --> 00:17:14,760
on it and I'll get an age list that

00:17:12,959 --> 00:17:18,000
represents that case class the instance

00:17:14,760 --> 00:17:20,610
of that case class and I can now also go

00:17:18,000 --> 00:17:23,370
in the opposite direction I can give

00:17:20,610 --> 00:17:27,569
person a gendered from a an ageless that

00:17:23,370 --> 00:17:29,250
represent Justin Bieber and a turns out

00:17:27,569 --> 00:17:30,630
is actually 24 which is something I

00:17:29,250 --> 00:17:32,040
learned when I prepared for this talk

00:17:30,630 --> 00:17:33,450
this is quite an amazing fact that I

00:17:32,040 --> 00:17:36,240
think everybody in the home should know

00:17:33,450 --> 00:17:39,090
and when I call purse

00:17:36,240 --> 00:17:43,580
not from I actually get Justin Bieber

00:17:39,090 --> 00:17:46,559
back out of the H list I get an instance

00:17:43,580 --> 00:17:48,960
so formally this is the definition of

00:17:46,559 --> 00:17:51,630
generic it takes a type parameter T

00:17:48,960 --> 00:17:56,850
which is my person or the message I want

00:17:51,630 --> 00:17:58,860
to serialize and it takes a and it

00:17:56,850 --> 00:18:01,170
defines a dependent type called the

00:17:58,860 --> 00:18:03,210
rapper which is the representation type

00:18:01,170 --> 00:18:05,880
normally like an H list for case class

00:18:03,210 --> 00:18:07,440
and it has the pair of method to inform

00:18:05,880 --> 00:18:11,070
that would convert back and from the

00:18:07,440 --> 00:18:12,900
type to the generic representation and

00:18:11,070 --> 00:18:16,530
inside the companion object there is a

00:18:12,900 --> 00:18:19,500
type ls' called the ox Forbes Lela which

00:18:16,530 --> 00:18:21,570
takes two type parameters T and R and

00:18:19,500 --> 00:18:23,309
it's basically a generic of type T with

00:18:21,570 --> 00:18:28,050
representation type r and this trick

00:18:23,309 --> 00:18:31,290
allows me to capture a the both the type

00:18:28,050 --> 00:18:34,679
and representation type together in a

00:18:31,290 --> 00:18:36,450
single type definition alright and and

00:18:34,679 --> 00:18:37,740
the last thing that basically olds

00:18:36,450 --> 00:18:39,990
everything together all this approach

00:18:37,740 --> 00:18:42,690
together is called inductive implicit

00:18:39,990 --> 00:18:44,280
search so I don't know if a lot of

00:18:42,690 --> 00:18:47,730
people know that but when you invoke an

00:18:44,280 --> 00:18:50,100
implicit searching in Scala it basically

00:18:47,730 --> 00:18:52,050
it's a recursive search in a graph and

00:18:50,100 --> 00:18:54,690
and just let's see what it really does

00:18:52,050 --> 00:18:57,390
so let's say that you define this

00:18:54,690 --> 00:19:00,870
function f a func that takes an X and an

00:18:57,390 --> 00:19:04,020
implicit a of type A and you invoke it

00:19:00,870 --> 00:19:05,760
like this func of 17 and basically these

00:19:04,020 --> 00:19:08,010
triggers at compile time and implicit

00:19:05,760 --> 00:19:10,500
search and the compiler has this whole

00:19:08,010 --> 00:19:12,630
software to search for implicit and it

00:19:10,500 --> 00:19:15,090
will search in certain places for an

00:19:12,630 --> 00:19:17,760
implicit for something that can give it

00:19:15,090 --> 00:19:20,370
at this a so it might find this function

00:19:17,760 --> 00:19:22,230
make a that returns an a so it's a

00:19:20,370 --> 00:19:26,940
candidate for for this implicit search

00:19:22,230 --> 00:19:30,059
but this function a wants a B so in

00:19:26,940 --> 00:19:31,590
order to for this for this to work the

00:19:30,059 --> 00:19:33,179
compiler has a new problem now now it

00:19:31,590 --> 00:19:35,190
needs to find an instance of B and if it

00:19:33,179 --> 00:19:38,160
can find one it will be able to use this

00:19:35,190 --> 00:19:40,710
function to create an A so now the

00:19:38,160 --> 00:19:42,600
compiler starts a search for B and it

00:19:40,710 --> 00:19:43,990
might find this function make B that

00:19:42,600 --> 00:19:46,930
wants a C

00:19:43,990 --> 00:19:48,640
and then the compiler start to search

00:19:46,930 --> 00:19:50,710
for C and let's assume that it finds

00:19:48,640 --> 00:19:52,720
this make see that doesn't want anything

00:19:50,710 --> 00:19:55,090
so it's basically the search is stopped

00:19:52,720 --> 00:19:58,210
and is actually successful at that point

00:19:55,090 --> 00:20:01,000
we can never see that we can use it to

00:19:58,210 --> 00:20:03,010
build a be to create an a and give it

00:20:01,000 --> 00:20:05,560
and call that function so basically what

00:20:03,010 --> 00:20:08,410
happens at compile time is that this

00:20:05,560 --> 00:20:10,840
function call becomes basically the

00:20:08,410 --> 00:20:13,240
compiler creates code but but creates

00:20:10,840 --> 00:20:15,850
the implicit like that so we basically

00:20:13,240 --> 00:20:17,230
got the compiler to solve a search

00:20:15,850 --> 00:20:19,570
problem and we're going to manipulate

00:20:17,230 --> 00:20:23,980
this behavior to get it to build a type

00:20:19,570 --> 00:20:25,540
class for us so before we do that I want

00:20:23,980 --> 00:20:28,120
to introduce another type class called

00:20:25,540 --> 00:20:29,890
field serializer so filter eliezer is a

00:20:28,120 --> 00:20:33,100
is a type last that knows how to

00:20:29,890 --> 00:20:35,260
serialize a single field so of type H

00:20:33,100 --> 00:20:37,210
which is the type parameter so it

00:20:35,260 --> 00:20:39,820
basically has a method called serialized

00:20:37,210 --> 00:20:42,310
which takes the output stream the tag

00:20:39,820 --> 00:20:46,320
number and the specific value and it

00:20:42,310 --> 00:20:48,820
writes it into the output stream and

00:20:46,320 --> 00:20:50,620
when I have this definition I can I can

00:20:48,820 --> 00:20:52,840
define a few serializers I can define

00:20:50,620 --> 00:20:53,290
the inside eliezer which knows how to

00:20:52,840 --> 00:20:57,010
serialize

00:20:53,290 --> 00:21:01,150
int and a string civilizer that knows

00:20:57,010 --> 00:21:04,090
how to serialize things and it isn't the

00:21:01,150 --> 00:21:05,320
new idea we have a message serialized we

00:21:04,090 --> 00:21:10,600
want to basically create a message

00:21:05,320 --> 00:21:12,790
civilizer of type T and the the idea is

00:21:10,600 --> 00:21:14,800
to basically create one by converting

00:21:12,790 --> 00:21:17,020
this type T to its generic

00:21:14,800 --> 00:21:20,320
representation to some H list our and

00:21:17,020 --> 00:21:24,060
somehow get a message serialize all for

00:21:20,320 --> 00:21:26,920
this R so if we manage to pull this off

00:21:24,060 --> 00:21:28,690
we can easily build a message realize of

00:21:26,920 --> 00:21:30,280
type T will convert every T to an hour

00:21:28,690 --> 00:21:32,470
and just use this message serialize of

00:21:30,280 --> 00:21:34,680
an hour to magically serialize it and we

00:21:32,470 --> 00:21:37,090
are done

00:21:34,680 --> 00:21:40,600
so it was the code that does that and it

00:21:37,090 --> 00:21:42,100
looks a little bit verbose but basically

00:21:40,600 --> 00:21:44,530
what we have here is there it's an

00:21:42,100 --> 00:21:47,500
implicit function that returns a message

00:21:44,530 --> 00:21:49,600
serialize of T and to create this

00:21:47,500 --> 00:21:51,880
message steriliser T it requires two

00:21:49,600 --> 00:21:54,490
implicit it requires a generic that

00:21:51,880 --> 00:21:56,290
would convert my t to an R and it wants

00:21:54,490 --> 00:21:57,370
a message serialize of an hour so if we

00:21:56,290 --> 00:21:59,710
have all of that

00:21:57,370 --> 00:22:01,899
it is easy to create a right to function

00:21:59,710 --> 00:22:04,179
the tech city and serialize it we use

00:22:01,899 --> 00:22:07,029
the generic dot - method to return an R

00:22:04,179 --> 00:22:09,460
and we'll use the repple civilizer the

00:22:07,029 --> 00:22:12,779
message sterilizer of ours to see

00:22:09,460 --> 00:22:15,039
realize that H lists into the stream

00:22:12,779 --> 00:22:16,720
so for person it will just look like

00:22:15,039 --> 00:22:20,379
this we have a message civilizer of a

00:22:16,720 --> 00:22:23,440
person and we'll find a generic a person

00:22:20,379 --> 00:22:25,330
a that would convert it to this edge

00:22:23,440 --> 00:22:28,539
list of strings tuning in remember first

00:22:25,330 --> 00:22:30,369
name last name age and we'll somehow

00:22:28,539 --> 00:22:33,850
need to get a message sterilizer of this

00:22:30,369 --> 00:22:35,919
H list and combine them together we will

00:22:33,850 --> 00:22:38,350
have the message sterilizer of a person

00:22:35,919 --> 00:22:39,909
but the problem is like how do we get

00:22:38,350 --> 00:22:43,090
the message sterilized of one H list how

00:22:39,909 --> 00:22:44,860
can we get basic dose build for us so

00:22:43,090 --> 00:22:45,580
civilizing H list turns out it's not

00:22:44,860 --> 00:22:47,590
very hard

00:22:45,580 --> 00:22:49,240
we just need to walk in took in two

00:22:47,590 --> 00:22:50,799
cases right we have the base case and

00:22:49,240 --> 00:22:53,139
the inductive case in this white called

00:22:50,799 --> 00:22:54,700
inductive implicit search basically we

00:22:53,139 --> 00:22:57,220
need to serialize the empty list the H

00:22:54,700 --> 00:22:59,080
nil thing so it turns out that

00:22:57,220 --> 00:23:00,100
sterilizing an empty list is very easy

00:22:59,080 --> 00:23:02,590
you just do nothing

00:23:00,100 --> 00:23:04,450
so you basically have this HTM

00:23:02,590 --> 00:23:05,049
sterilizer with an empty right to method

00:23:04,450 --> 00:23:08,139
and you're done

00:23:05,049 --> 00:23:10,389
easy now we our new problem is to

00:23:08,139 --> 00:23:12,519
sterilize a non-empty list so what's a

00:23:10,389 --> 00:23:16,779
non-empty list it has a head type and a

00:23:12,519 --> 00:23:18,610
tail and to sterilize a head followed by

00:23:16,779 --> 00:23:20,080
a tail we need a field sterilizer for

00:23:18,610 --> 00:23:22,929
the head so it's some string or an

00:23:20,080 --> 00:23:25,179
integer some some type of day at the at

00:23:22,929 --> 00:23:26,830
the top of the list and we need a

00:23:25,179 --> 00:23:29,289
message civilizer for the rest of the

00:23:26,830 --> 00:23:31,779
list if you can combine if we get these

00:23:29,289 --> 00:23:36,129
two we just combined them and we

00:23:31,779 --> 00:23:37,809
serialize the entire edge list so you've

00:23:36,129 --> 00:23:39,809
seen the second window how you actually

00:23:37,809 --> 00:23:42,639
do that

00:23:39,809 --> 00:23:44,710
so we have an implicit function that

00:23:42,639 --> 00:23:48,429
returns an add a message sterilizer of

00:23:44,710 --> 00:23:50,379
an ad followed by a tail and the input

00:23:48,429 --> 00:23:52,149
that it wants the it wants a field

00:23:50,379 --> 00:23:54,639
sterilizer for the head of cell as the

00:23:52,149 --> 00:23:56,169
first type and a message sterilizer for

00:23:54,639 --> 00:23:57,940
the tail to sterilize the rest of the

00:23:56,169 --> 00:23:59,590
list and once we have all these

00:23:57,940 --> 00:24:02,230
ingredients we can basically called

00:23:59,590 --> 00:24:05,649
filter dot serialize to serialize the

00:24:02,230 --> 00:24:08,080
head and they tell sterilizer to basic -

00:24:05,649 --> 00:24:09,190
to serialize the tail of the list and we

00:24:08,080 --> 00:24:11,779
are done

00:24:09,190 --> 00:24:14,330
so this is what actually happens right

00:24:11,779 --> 00:24:18,409
we want to have a message realize of a

00:24:14,330 --> 00:24:19,580
person using the generic we a we convert

00:24:18,409 --> 00:24:21,140
it to some age list and we have a

00:24:19,580 --> 00:24:23,690
message sterilizer for the age list and

00:24:21,140 --> 00:24:27,980
through the implicit search we basically

00:24:23,690 --> 00:24:29,929
each time a shave the top of the list

00:24:27,980 --> 00:24:32,270
and they get the field sterilizer for

00:24:29,929 --> 00:24:34,399
that and have a message serializer for

00:24:32,270 --> 00:24:36,080
the rest until we have a message

00:24:34,399 --> 00:24:38,419
sterilizer for an empty list which we

00:24:36,080 --> 00:24:40,760
defined and all of this graph

00:24:38,419 --> 00:24:43,820
construction happens at compile time

00:24:40,760 --> 00:24:44,630
through implicit search and I think it's

00:24:43,820 --> 00:24:47,960
very beautiful

00:24:44,630 --> 00:24:50,179
an elegant technique and it actually

00:24:47,960 --> 00:24:54,140
walks and the code that they get

00:24:50,179 --> 00:24:58,220
generated is pretty efficient so let's

00:24:54,140 --> 00:25:00,679
review that and we finally get else at

00:24:58,220 --> 00:25:02,299
compile time so if that case class that

00:25:00,679 --> 00:25:06,200
we're trying to serialize doesn't have a

00:25:02,299 --> 00:25:07,850
a contains something that we don't know

00:25:06,200 --> 00:25:09,950
how to serialize like a UUID or

00:25:07,850 --> 00:25:12,200
something we didn't plan for the

00:25:09,950 --> 00:25:16,940
implicit search will fail so we know at

00:25:12,200 --> 00:25:18,520
compile time that that that we cannot

00:25:16,940 --> 00:25:22,070
get a message serializer

00:25:18,520 --> 00:25:24,409
the quality that gets generated this way

00:25:22,070 --> 00:25:28,789
is a relatively fast much faster than

00:25:24,409 --> 00:25:32,120
reflection and the user can provide

00:25:28,789 --> 00:25:33,649
their own custom sterilizers so if the

00:25:32,120 --> 00:25:35,240
user really wants to serialize something

00:25:33,649 --> 00:25:37,610
they can just define an implicit field

00:25:35,240 --> 00:25:39,080
serializer and the compiler will find it

00:25:37,610 --> 00:25:40,880
at the right time and it will just

00:25:39,080 --> 00:25:43,909
become part of the graph so this is

00:25:40,880 --> 00:25:44,409
customizable and that's that's a good

00:25:43,909 --> 00:25:47,990
thing

00:25:44,409 --> 00:25:50,270
on the downside a unhelpful compiler

00:25:47,990 --> 00:25:52,610
also turns out that if you cannot find

00:25:50,270 --> 00:25:55,399
your field serialize or something wrong

00:25:52,610 --> 00:25:57,110
happens a during the implicit search the

00:25:55,399 --> 00:25:58,669
compiler will complain about the

00:25:57,110 --> 00:26:01,490
top-level thing about the message

00:25:58,669 --> 00:26:03,230
serialize of a person and it wouldn't

00:26:01,490 --> 00:26:05,779
give you a lot of information about a

00:26:03,230 --> 00:26:08,330
what the actual problem is there are

00:26:05,779 --> 00:26:09,950
various ways to do that to get the

00:26:08,330 --> 00:26:12,770
compiler to give you more verbose output

00:26:09,950 --> 00:26:14,630
but it basically tells you like you know

00:26:12,770 --> 00:26:16,970
what it had for breakfast two days ago

00:26:14,630 --> 00:26:20,029
and it's kind of hard to to follow and

00:26:16,970 --> 00:26:22,390
and it takes practice to be able to to

00:26:20,029 --> 00:26:25,100
understand what it tells you

00:26:22,390 --> 00:26:26,929
another thing I observed is that the

00:26:25,100 --> 00:26:28,850
code that they that we this

00:26:26,929 --> 00:26:31,220
implementation that we get is slower

00:26:28,850 --> 00:26:34,309
than the generated code that Scala PB

00:26:31,220 --> 00:26:36,950
already had and for my investigations

00:26:34,309 --> 00:26:39,919
the the the reasons for that is the

00:26:36,950 --> 00:26:42,320
conversion back and forth from the from

00:26:39,919 --> 00:26:44,360
the case class to the age list and also

00:26:42,320 --> 00:26:47,929
there's a lot of boxing and unboxing

00:26:44,360 --> 00:26:50,929
going going on when that happens and

00:26:47,929 --> 00:26:53,840
finally I we showed how to how to do

00:26:50,929 --> 00:26:56,179
encoders but it's unclear how to do

00:26:53,840 --> 00:26:59,990
decoding and the reason is that in

00:26:56,179 --> 00:27:01,640
protocol buffers the the in when you get

00:26:59,990 --> 00:27:03,350
the something from another system the

00:27:01,640 --> 00:27:04,539
fields can come in any order you're not

00:27:03,350 --> 00:27:06,679
guarantee that they are sorted by

00:27:04,539 --> 00:27:09,080
increasing tag numbers or anything like

00:27:06,679 --> 00:27:11,240
that generally they would be but it's

00:27:09,080 --> 00:27:13,280
not a basically the protocol says it can

00:27:11,240 --> 00:27:15,409
come in any order and it's a bit unclear

00:27:13,280 --> 00:27:19,850
how to efficiently create an H list when

00:27:15,409 --> 00:27:21,860
things come in order you don't expect so

00:27:19,850 --> 00:27:24,110
in summary I like this method a lot it's

00:27:21,860 --> 00:27:25,700
a great method but because performance

00:27:24,110 --> 00:27:29,450
is something that is really really

00:27:25,700 --> 00:27:31,280
important for Scala PB users a I

00:27:29,450 --> 00:27:34,250
continued looking into other into other

00:27:31,280 --> 00:27:37,460
things and that basically made me dive

00:27:34,250 --> 00:27:38,870
into the generic a type class and I

00:27:37,460 --> 00:27:41,990
learned that it's implement by a macro

00:27:38,870 --> 00:27:44,059
and as I went through this I basically

00:27:41,990 --> 00:27:45,830
found myself creating macros that would

00:27:44,059 --> 00:27:49,100
be more specific to Scala PB than the

00:27:45,830 --> 00:27:50,600
generic macro and they and that

00:27:49,100 --> 00:27:52,730
basically that took me to the fourth

00:27:50,600 --> 00:27:55,429
approach which is called implicit macros

00:27:52,730 --> 00:27:59,780
and you know Marcos have this reputation

00:27:55,429 --> 00:28:02,750
of being this say a black magic this

00:27:59,780 --> 00:28:04,909
evil supernatural power that is reserved

00:28:02,750 --> 00:28:08,120
for only few Scala ghouls who knows what

00:28:04,909 --> 00:28:10,640
they're doing and I basically spent a

00:28:08,120 --> 00:28:13,419
few weeks and and learn that stuff and I

00:28:10,640 --> 00:28:16,010
can confirm that this is partly true but

00:28:13,419 --> 00:28:17,390
but at the same time you know kidding

00:28:16,010 --> 00:28:19,100
aside there is actually a lot of

00:28:17,390 --> 00:28:22,100
documentation these days and a lot of

00:28:19,100 --> 00:28:24,289
answers in Stack Overflow and shapeless

00:28:22,100 --> 00:28:25,820
itself is a you know there's a lot of

00:28:24,289 --> 00:28:27,710
markers there that you can learn a few

00:28:25,820 --> 00:28:30,620
tricks and if you a few ideas and and

00:28:27,710 --> 00:28:32,540
there are other places so what I want to

00:28:30,620 --> 00:28:35,600
show you here is like what it takes to

00:28:32,540 --> 00:28:36,090
write a macro most of the code you see

00:28:35,600 --> 00:28:37,440
is a

00:28:36,090 --> 00:28:40,680
there's a little bit of shortcuts that I

00:28:37,440 --> 00:28:42,860
took just to make it fit the slides but

00:28:40,680 --> 00:28:46,620
this would give you a good kind of like

00:28:42,860 --> 00:28:48,630
feel for what it what what really it

00:28:46,620 --> 00:28:52,260
takes to write a macro my goal is to

00:28:48,630 --> 00:28:54,300
convince you that it's not that bad so

00:28:52,260 --> 00:28:56,490
turns out that you know every macro

00:28:54,300 --> 00:28:59,340
basically looks like this it's basically

00:28:56,490 --> 00:29:01,110
an implicit function that returns the

00:28:59,340 --> 00:29:03,690
type that we want you know in this case

00:29:01,110 --> 00:29:05,430
messages realize of type T and the body

00:29:03,690 --> 00:29:08,220
of it is just says the keyword Mac Hall

00:29:05,430 --> 00:29:13,130
followed by a function where the macro

00:29:08,220 --> 00:29:15,630
is actually implemented and this is the

00:29:13,130 --> 00:29:19,770
the macro implementation basically it

00:29:15,630 --> 00:29:21,480
gets a this a week type tag that key

00:29:19,770 --> 00:29:24,540
would give us some information at

00:29:21,480 --> 00:29:26,910
compile time on name under the type T

00:29:24,540 --> 00:29:28,770
and it needs to return a tree basically

00:29:26,910 --> 00:29:32,730
an abstract syntax tree of the scala

00:29:28,770 --> 00:29:34,020
language a and the current

00:29:32,730 --> 00:29:35,580
implementation that you see is just

00:29:34,020 --> 00:29:38,160
three question mark so this is throwing

00:29:35,580 --> 00:29:40,920
an exception and if I actually try to

00:29:38,160 --> 00:29:43,080
use this macro it will for exception

00:29:40,920 --> 00:29:45,150
inside the compiler at compile time and

00:29:43,080 --> 00:29:47,400
the compiler would just explode so don't

00:29:45,150 --> 00:29:51,840
do that but you might think that

00:29:47,400 --> 00:29:54,240
basically a returning a tree when absol

00:29:51,840 --> 00:29:56,610
syntax like is a hard thing but turns

00:29:54,240 --> 00:29:59,970
out it's actually very easy there is a

00:29:56,610 --> 00:30:02,850
technique called quasi quote a which

00:29:59,970 --> 00:30:07,110
basically looks like this you write Q

00:30:02,850 --> 00:30:09,090
and then in inside this block in Reggio

00:30:07,110 --> 00:30:10,800
writes color code and what actually

00:30:09,090 --> 00:30:13,980
happens is that this gives you back an

00:30:10,800 --> 00:30:15,420
abstract syntax tree but that the

00:30:13,980 --> 00:30:19,760
compiler creates out of the code that

00:30:15,420 --> 00:30:19,760
that you give so

00:30:20,090 --> 00:30:24,720
what we have here is basically a

00:30:22,080 --> 00:30:28,290
function that that that returns a tree

00:30:24,720 --> 00:30:31,140
and that at that tree a gets injected

00:30:28,290 --> 00:30:34,200
into into the interior code when the

00:30:31,140 --> 00:30:36,330
Marco gets invoked that's it that is it

00:30:34,200 --> 00:30:39,120
right this is basically what the Scala

00:30:36,330 --> 00:30:41,070
Marco does so the code in red that we

00:30:39,120 --> 00:30:42,950
have here is basically creating an

00:30:41,070 --> 00:30:45,240
instance of a message serializer that

00:30:42,950 --> 00:30:47,310
extends the type that basically extends

00:30:45,240 --> 00:30:49,890
message serialize off of the type T and

00:30:47,310 --> 00:30:54,539
the right to method inside

00:30:49,890 --> 00:30:57,299
it's currently empty and then we

00:30:54,539 --> 00:30:59,460
instantiate that message serializer and

00:30:57,299 --> 00:31:03,870
this is what the user gets out of it

00:30:59,460 --> 00:31:08,730
basically so how would you implement the

00:31:03,870 --> 00:31:11,159
a the the Marco to actually see realize

00:31:08,730 --> 00:31:14,100
something so the first the first thing

00:31:11,159 --> 00:31:15,840
we want to do is to get all the fields

00:31:14,100 --> 00:31:17,850
serializers for the types that we have

00:31:15,840 --> 00:31:19,440
in our in our case class so turns out

00:31:17,850 --> 00:31:21,630
there's a very cool method called in

00:31:19,440 --> 00:31:23,340
fare implicit value that I can basically

00:31:21,630 --> 00:31:25,919
tell the compiler start an implicit

00:31:23,340 --> 00:31:28,409
search for me for the field sterilizers

00:31:25,919 --> 00:31:30,149
that I care about and it will get the

00:31:28,409 --> 00:31:31,529
compiler to basically this is the macro

00:31:30,149 --> 00:31:37,080
telling the compiler start an implicit

00:31:31,529 --> 00:31:40,399
search and it will give me back a a some

00:31:37,080 --> 00:31:43,049
some other tree that represents the

00:31:40,399 --> 00:31:44,309
implicit that it finds and then I can

00:31:43,049 --> 00:31:46,380
inject that into the code

00:31:44,309 --> 00:31:48,450
so basically what I'm defining here this

00:31:46,380 --> 00:31:51,720
implicit is a sequence of tree that

00:31:48,450 --> 00:31:54,049
represents instantiation of all the

00:31:51,720 --> 00:31:56,309
implicit fields i realizes that I want

00:31:54,049 --> 00:31:58,380
they I'm a bit cheating in with the

00:31:56,309 --> 00:32:00,470
syntax this cue fields realizes not real

00:31:58,380 --> 00:32:04,019
syntax but you get the idea

00:32:00,470 --> 00:32:07,110
and then when I have the implicit I

00:32:04,019 --> 00:32:09,090
I basically generate a series of

00:32:07,110 --> 00:32:11,600
civilization statements I basically call

00:32:09,090 --> 00:32:15,860
those implicit dot cellulite method and

00:32:11,600 --> 00:32:18,779
extracting values out of the out of my

00:32:15,860 --> 00:32:21,690
of the instance and passing them to the

00:32:18,779 --> 00:32:23,700
civilized method so I basically just

00:32:21,690 --> 00:32:25,110
create this code and then I have this

00:32:23,700 --> 00:32:27,169
syntax I have the implicit sand the

00:32:25,110 --> 00:32:30,179
rights that I we just talked about and

00:32:27,169 --> 00:32:32,789
then I can just with a dot dollar a

00:32:30,179 --> 00:32:36,830
notation I can basically inject them

00:32:32,789 --> 00:32:36,830
into into the code that gets generated

00:32:38,269 --> 00:32:43,169
in practice it looks like this right so

00:32:41,370 --> 00:32:45,210
this is what it would look for the

00:32:43,169 --> 00:32:47,700
person I have a first name

00:32:45,210 --> 00:32:49,559
a which gets assigned a string

00:32:47,700 --> 00:32:51,269
sterilizer I'm basically using the the

00:32:49,559 --> 00:32:54,299
field name to assign a sterilizer to

00:32:51,269 --> 00:32:56,460
just because it's easy and then and then

00:32:54,299 --> 00:32:59,630
inside the right way I just call those

00:32:56,460 --> 00:33:02,070
serializers to get the output a written

00:32:59,630 --> 00:33:03,190
and this is it this is basically a mock

00:33:02,070 --> 00:33:06,640
ordered

00:33:03,190 --> 00:33:09,130
that sterilizes protocol buffers and it

00:33:06,640 --> 00:33:11,290
really doesn't take long to write and it

00:33:09,130 --> 00:33:13,630
works really really well so you kind of

00:33:11,290 --> 00:33:15,670
notice that we basically closed the full

00:33:13,630 --> 00:33:17,710
circle right because we wanted to avoid

00:33:15,670 --> 00:33:20,070
generating code out of compile time and

00:33:17,710 --> 00:33:22,840
now instead we're generating code inside

00:33:20,070 --> 00:33:24,430
doing compile time but turns out to be

00:33:22,840 --> 00:33:27,760
also generating almost the same code

00:33:24,430 --> 00:33:31,390
that we generate before compile time so

00:33:27,760 --> 00:33:33,250
it has similar a you know a performance

00:33:31,390 --> 00:33:35,830
characteristics

00:33:33,250 --> 00:33:39,430
and this approach is very flexible so

00:33:35,830 --> 00:33:41,560
I'd like to review it and it's fast it

00:33:39,430 --> 00:33:43,450
says file I mean it's similarly fast to

00:33:41,560 --> 00:33:45,250
the generated code I didn't get it to be

00:33:43,450 --> 00:33:48,520
exactly as fast we will see that in a

00:33:45,250 --> 00:33:50,410
bit but it's pretty close a users can

00:33:48,520 --> 00:33:52,780
still you a pass their own custom

00:33:50,410 --> 00:33:55,390
sterilizers because we're relying on the

00:33:52,780 --> 00:33:57,280
implicit search of the compiler a and

00:33:55,390 --> 00:33:59,890
turns out there's much better control

00:33:57,280 --> 00:34:01,900
over compiler errors you can basically

00:33:59,890 --> 00:34:03,670
with enough effort not much effort you

00:34:01,900 --> 00:34:05,260
can basically tell the compiler which

00:34:03,670 --> 00:34:08,590
I'll to give to the user you can catch

00:34:05,260 --> 00:34:11,740
exceptions in in it and and deal with

00:34:08,590 --> 00:34:13,300
them and omit compiler errors and so you

00:34:11,740 --> 00:34:16,630
can make it as friendly as you'd like

00:34:13,300 --> 00:34:19,000
on the downside there are limited

00:34:16,630 --> 00:34:21,929
debugging tools so this is something

00:34:19,000 --> 00:34:24,580
might change you know over time but they

00:34:21,929 --> 00:34:26,500
as far as I know you you know you cannot

00:34:24,580 --> 00:34:28,600
take your basic generate code you know

00:34:26,500 --> 00:34:30,070
with the macro and the users cannot see

00:34:28,600 --> 00:34:32,410
the code they cannot put breakpoints in

00:34:30,070 --> 00:34:36,340
it things like that and that can be you

00:34:32,410 --> 00:34:38,440
know pretty annoying for users right so

00:34:36,340 --> 00:34:40,690
what I want to do next is show you the

00:34:38,440 --> 00:34:43,750
relative performance of the approaches

00:34:40,690 --> 00:34:46,630
that I showed you so at the bottom the

00:34:43,750 --> 00:34:48,370
black line is the baseline generated

00:34:46,630 --> 00:34:52,480
code that scallopini already had for

00:34:48,370 --> 00:34:55,060
several years followed by the macro

00:34:52,480 --> 00:34:58,090
approach and the slight difference that

00:34:55,060 --> 00:35:00,130
you see there is a coming from the fact

00:34:58,090 --> 00:35:02,080
that the generated code directly calling

00:35:00,130 --> 00:35:04,030
the output stream there isn't a that

00:35:02,080 --> 00:35:06,220
field serialized the abstraction in the

00:35:04,030 --> 00:35:08,290
middle but I do think that with a little

00:35:06,220 --> 00:35:12,880
bit of effort I can get it to exactly

00:35:08,290 --> 00:35:14,560
match the line and with the generic with

00:35:12,880 --> 00:35:16,490
a genetic derivation

00:35:14,560 --> 00:35:19,430
a we have a

00:35:16,490 --> 00:35:21,490
it's slightly slower so I just want to

00:35:19,430 --> 00:35:23,960
basically show you how to read the graph

00:35:21,490 --> 00:35:25,280
on the y-axis to this time right how

00:35:23,960 --> 00:35:27,650
long it takes to sell as a message the

00:35:25,280 --> 00:35:30,410
unit a message the units are now seconds

00:35:27,650 --> 00:35:32,510
on the right axis we have how big the

00:35:30,410 --> 00:35:36,320
messages right so a bigger message takes

00:35:32,510 --> 00:35:39,650
law to to serialize so basically it's a

00:35:36,320 --> 00:35:40,970
number of fields that it has and you

00:35:39,650 --> 00:35:42,350
know we're still talking nanoseconds

00:35:40,970 --> 00:35:45,320
here so everything here is super fast

00:35:42,350 --> 00:35:47,570
and this was produced with the tool

00:35:45,320 --> 00:35:49,460
called jmh which basically lets you do

00:35:47,570 --> 00:35:50,960
benchmarking on the JVM and it takes

00:35:49,460 --> 00:35:53,869
care of all the annoying facts like

00:35:50,960 --> 00:35:55,820
warming up the JVM and forking it

00:35:53,869 --> 00:35:59,480
multiple times to avoid like you know

00:35:55,820 --> 00:36:05,030
pitfalls with the JIT and where is

00:35:59,480 --> 00:36:09,050
reflection let's zoom out yeah there is

00:36:05,030 --> 00:36:11,119
a so we know it's a we're talking

00:36:09,050 --> 00:36:13,310
microseconds right so it's still you

00:36:11,119 --> 00:36:15,320
know it's there is a couple of orders of

00:36:13,310 --> 00:36:17,119
magnitude difference but but it's still

00:36:15,320 --> 00:36:23,810
you know it's relatively fast but not as

00:36:17,119 --> 00:36:25,730
fast as I want things to be so basically

00:36:23,810 --> 00:36:30,980
this is a you know the four approaches

00:36:25,730 --> 00:36:32,690
that that I looked into and my

00:36:30,980 --> 00:36:35,630
conclusion is that for at least for

00:36:32,690 --> 00:36:40,520
Scala PB it looks like the MCOs is the

00:36:35,630 --> 00:36:41,810
winning one and and but it doesn't mean

00:36:40,520 --> 00:36:43,850
that this is true for every project I

00:36:41,810 --> 00:36:46,160
think you know acids software developers

00:36:43,850 --> 00:36:47,300
we should know what what's out there and

00:36:46,160 --> 00:36:49,400
pick the right tool for the right

00:36:47,300 --> 00:36:53,350
problem and sometimes you just want to

00:36:49,400 --> 00:36:55,820
optimize for different things and so a

00:36:53,350 --> 00:36:57,890
what I'd like to kind of like to again

00:36:55,820 --> 00:36:59,900
remind you those things are pretty

00:36:57,890 --> 00:37:03,290
general so every time you want to write

00:36:59,900 --> 00:37:05,840
some code that that that takes a a user

00:37:03,290 --> 00:37:07,220
type and that's something with it you

00:37:05,840 --> 00:37:09,230
can use that stuff to cut down

00:37:07,220 --> 00:37:12,310
boilerplate and and get the compiler to

00:37:09,230 --> 00:37:15,020
walk for you is so you have basically

00:37:12,310 --> 00:37:17,600
more way you know less operative code

00:37:15,020 --> 00:37:22,490
and you know fewer bugs few arrows and

00:37:17,600 --> 00:37:24,500
they're generally better life so that's

00:37:22,490 --> 00:37:26,480
all I had and you know no matter what

00:37:24,500 --> 00:37:31,060
your peanut butter is just try to find a

00:37:26,480 --> 00:37:31,060
way to cut it yeah thank you

00:37:34,740 --> 00:37:39,580
thank you very much and we still have

00:37:37,450 --> 00:37:42,160
time for questions so let's start right

00:37:39,580 --> 00:37:48,730
away I go there and then come back to

00:37:42,160 --> 00:37:52,060
you thank you for an interesting talk I

00:37:48,730 --> 00:37:53,140
can see it has a great value for example

00:37:52,060 --> 00:37:56,830
for projects where you need to

00:37:53,140 --> 00:37:59,650
temporarily serialize data and get it

00:37:56,830 --> 00:38:01,990
back but how is any way you thought of

00:37:59,650 --> 00:38:03,490
handling comets ability backwards and

00:38:01,990 --> 00:38:04,980
forward like we do with ordinary prod

00:38:03,490 --> 00:38:08,850
offs

00:38:04,980 --> 00:38:12,310
yes so I that this is true right so way

00:38:08,850 --> 00:38:13,840
you when you get an H list and if you

00:38:12,310 --> 00:38:17,140
stow it somewhere and then the you know

00:38:13,840 --> 00:38:18,550
for long-term storage and then the case

00:38:17,140 --> 00:38:20,980
class somehow change you can't really

00:38:18,550 --> 00:38:22,630
get it back in a in a way there's no

00:38:20,980 --> 00:38:26,110
protocol buffers protocol like that will

00:38:22,630 --> 00:38:28,120
give you so basically if you're not if

00:38:26,110 --> 00:38:30,700
you store it in a way that that is not

00:38:28,120 --> 00:38:40,830
designed for scheme evolution all bets

00:38:30,700 --> 00:38:43,480
are off right thank you for a great talk

00:38:40,830 --> 00:38:47,110
actually this is my first question about

00:38:43,480 --> 00:38:49,990
GMO evolution and I don't really get the

00:38:47,110 --> 00:38:53,190
answer so so far there is no support and

00:38:49,990 --> 00:38:56,980
it's a generic and macro stuff right

00:38:53,190 --> 00:38:59,590
okay so maybe I explain what it would

00:38:56,980 --> 00:39:01,870
look like you know if a and once this

00:38:59,590 --> 00:39:04,120
becomes part of Scala PB so you start

00:39:01,870 --> 00:39:06,490
with the case class and if you basically

00:39:04,120 --> 00:39:09,760
you know have some set of fields and you

00:39:06,490 --> 00:39:11,230
civilize them a and then you try to diss

00:39:09,760 --> 00:39:12,790
utilize it but in the meantime you

00:39:11,230 --> 00:39:16,180
introduced more fields things would get

00:39:12,790 --> 00:39:18,310
out of order so one possible solution

00:39:16,180 --> 00:39:20,200
for that if people want to develop it

00:39:18,310 --> 00:39:22,060
with like evolution in mind which came

00:39:20,200 --> 00:39:23,500
evolution in mind they can use for

00:39:22,060 --> 00:39:26,500
example an annotation and basically

00:39:23,500 --> 00:39:29,710
write something like a put like an add a

00:39:26,500 --> 00:39:31,750
field tag one or something like that and

00:39:29,710 --> 00:39:33,490
then the macro can can find that stuff

00:39:31,750 --> 00:39:35,350
and basically always use that tag number

00:39:33,490 --> 00:39:37,450
for the field so then they can kind of

00:39:35,350 --> 00:39:41,130
guarantee over time that the schema the

00:39:37,450 --> 00:39:41,130
schema so there are plans to

00:39:41,630 --> 00:39:45,769
yeah for specifically for protocol

00:39:43,549 --> 00:39:48,950
buffers that's definitely necessary okay

00:39:45,769 --> 00:39:51,109
the second question was about in Scala

00:39:48,950 --> 00:39:54,400
you can have solute rates and abstract

00:39:51,109 --> 00:39:57,200
data types yeah either automatic

00:39:54,400 --> 00:39:59,329
derivation for for those because in

00:39:57,200 --> 00:40:01,970
protobuf you have one off semantics

00:39:59,329 --> 00:40:05,210
right so yeah that would be necessary

00:40:01,970 --> 00:40:07,009
for in arms and one off and of course

00:40:05,210 --> 00:40:08,630
that would be part of it I wanted I

00:40:07,009 --> 00:40:10,640
didn't want to go into core products in

00:40:08,630 --> 00:40:17,619
this talk but but it's definitely gonna

00:40:10,640 --> 00:40:19,039
be part of what we'll have it in so yeah

00:40:17,619 --> 00:40:20,989
not yet

00:40:19,039 --> 00:40:25,099
it's basically walking polish that's

00:40:20,989 --> 00:40:27,890
kind of like private for now that's a

00:40:25,099 --> 00:40:29,749
great question so maybe community can

00:40:27,890 --> 00:40:31,549
help of course yeah so one of the things

00:40:29,749 --> 00:40:34,039
I learned in my career is that when I'm

00:40:31,549 --> 00:40:36,769
asking ask for estimates in public at

00:40:34,039 --> 00:40:40,160
trying to avoid giving them especially

00:40:36,769 --> 00:40:42,680
when the video is recorded so I so it's

00:40:40,160 --> 00:40:49,730
gonna come in the future yeah okay thank

00:40:42,680 --> 00:40:55,339
you we heard about all the problems with

00:40:49,730 --> 00:40:57,710
future promises so thank you for your

00:40:55,339 --> 00:41:00,589
talk is it possible to use this

00:40:57,710 --> 00:41:02,809
technique to also get an ID L beg from

00:41:00,589 --> 00:41:04,519
your case classes so maybe because I

00:41:02,809 --> 00:41:07,700
realized in the future oh now I need to

00:41:04,519 --> 00:41:09,950
share my data structures and instead of

00:41:07,700 --> 00:41:12,259
hand writing them down based on the case

00:41:09,950 --> 00:41:14,329
cuz I would like to have to generate it

00:41:12,259 --> 00:41:15,920
right I don't know the compiler switch

00:41:14,329 --> 00:41:18,049
or something like that and then share

00:41:15,920 --> 00:41:19,880
this with some other people in the

00:41:18,049 --> 00:41:22,130
company or with the outside world

00:41:19,880 --> 00:41:24,799
yes fantastic question I think this is

00:41:22,130 --> 00:41:26,749
actually a an application that you know

00:41:24,799 --> 00:41:29,900
you can easily do right we're writing a

00:41:26,749 --> 00:41:32,749
type class that that would get you a

00:41:29,900 --> 00:41:34,670
protocol buffer schema as a string out

00:41:32,749 --> 00:41:36,319
of it and you'll basically iterate over

00:41:34,670 --> 00:41:38,539
the fields you know the types and

00:41:36,319 --> 00:41:42,640
basically transform that I think that

00:41:38,539 --> 00:41:42,640
that should be very very doable

00:41:54,369 --> 00:42:02,540
you make me on my lunch

00:41:57,760 --> 00:42:06,290
what about simulation when you have

00:42:02,540 --> 00:42:09,400
several moves and you want to evolve

00:42:06,290 --> 00:42:14,930
your particular buffer say Mattoon is a

00:42:09,400 --> 00:42:20,270
reservation what is exactly the question

00:42:14,930 --> 00:42:23,930
then do you plan to to manage shame

00:42:20,270 --> 00:42:27,650
evolution with generated code yeah so

00:42:23,930 --> 00:42:30,710
basically a in this approach when you

00:42:27,650 --> 00:42:32,869
add filter to the case class a you'll

00:42:30,710 --> 00:42:34,280
have to somehow mark the tag numbers if

00:42:32,869 --> 00:42:36,470
you really want the messages to walk

00:42:34,280 --> 00:42:38,240
like you know to be able to to parse

00:42:36,470 --> 00:42:40,190
data that was serialized in a previous

00:42:38,240 --> 00:42:42,349
version of it so if you introduced tag

00:42:40,190 --> 00:42:44,059
numbers what happens is that when the

00:42:42,349 --> 00:42:47,180
message gets utilized the tag number is

00:42:44,059 --> 00:42:50,089
written today to the output so as long

00:42:47,180 --> 00:42:51,470
as the new version of the of the after

00:42:50,089 --> 00:42:53,569
the evolution write it the new version

00:42:51,470 --> 00:42:55,040
of your case class has the same tag

00:42:53,569 --> 00:42:57,380
numbers but you know the Ted in the

00:42:55,040 --> 00:42:58,940
original one the fields that were in the

00:42:57,380 --> 00:43:00,170
right slot that field from the original

00:42:58,940 --> 00:43:02,390
one would just get into the right slot

00:43:00,170 --> 00:43:04,880
into the new one and fill that you were

00:43:02,390 --> 00:43:07,270
moved we just get dropped so that would

00:43:04,880 --> 00:43:07,270

YouTube URL: https://www.youtube.com/watch?v=bm-_WsSDWoI


