Title: Type Parameter Power Up Variance Bounds and Inference by Chris Phelps
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here: 
https://eu.scaladays.org/lect-6927-type-parameter-power-up%21-variance%2C-bounds%2C-and-inference.html
Captions: 
	00:00:04,730 --> 00:00:09,600
so why am I talking about type

00:00:07,920 --> 00:00:12,900
parameters and variants and things like

00:00:09,600 --> 00:00:16,279
that today at tendril one of our

00:00:12,900 --> 00:00:19,080
products is home energy reports and we

00:00:16,279 --> 00:00:20,760
collect information about how people use

00:00:19,080 --> 00:00:24,449
energy in their home and we produce them

00:00:20,760 --> 00:00:27,330
these reports when we built a new system

00:00:24,449 --> 00:00:28,830
to build these reports we use a free

00:00:27,330 --> 00:00:33,390
monad pattern I'm not going to describe

00:00:28,830 --> 00:00:36,470
what that is but we had workflow stages

00:00:33,390 --> 00:00:39,510
that all extended a common base class

00:00:36,470 --> 00:00:42,510
they were all parameterised with some

00:00:39,510 --> 00:00:44,640
report type we had extensions to those

00:00:42,510 --> 00:00:46,890
report types for the different kinds of

00:00:44,640 --> 00:00:48,870
reports that we generated and so there

00:00:46,890 --> 00:00:50,489
was inheritance and container

00:00:48,870 --> 00:00:55,680
relationships at many different places

00:00:50,489 --> 00:00:59,120
and Scala compiler it's pretty good and

00:00:55,680 --> 00:01:02,280
occasionally you see things like this

00:00:59,120 --> 00:01:06,240
covariant type a occurs in contravariant

00:01:02,280 --> 00:01:07,740
position on what and my colleagues came

00:01:06,240 --> 00:01:09,450
to me and said Chris I don't understand

00:01:07,740 --> 00:01:09,780
this error can you please explain it to

00:01:09,450 --> 00:01:11,640
me

00:01:09,780 --> 00:01:15,090
and I tried to explain it to him and I

00:01:11,640 --> 00:01:15,929
did a pretty lousy job so I took another

00:01:15,090 --> 00:01:18,899
shot at it

00:01:15,929 --> 00:01:21,479
did a another explanation that was much

00:01:18,899 --> 00:01:25,229
better and so I proposed this this talk

00:01:21,479 --> 00:01:26,910
so why should users and any API

00:01:25,229 --> 00:01:30,119
designers learn about these kinds of

00:01:26,910 --> 00:01:32,160
topics for users you know you're looking

00:01:30,119 --> 00:01:34,259
at api's you're looking at documentation

00:01:32,160 --> 00:01:36,330
you're trying to understand what you're

00:01:34,259 --> 00:01:38,369
reading and how to make sense of it you

00:01:36,330 --> 00:01:39,810
want to know what's this thing that I'm

00:01:38,369 --> 00:01:41,340
trying to call what does it need to take

00:01:39,810 --> 00:01:44,160
what's it gonna return to me how do I

00:01:41,340 --> 00:01:45,840
make it interact with my hierarchy if I

00:01:44,160 --> 00:01:48,479
have any of these weird error messages

00:01:45,840 --> 00:01:51,030
how do I deal with them and the API

00:01:48,479 --> 00:01:52,770
designer on the other hand wants to

00:01:51,030 --> 00:01:55,709
decide what sorts of flexibility they

00:01:52,770 --> 00:01:58,009
want to allow and they write an API what

00:01:55,709 --> 00:02:01,979
do they want to offer how did they make

00:01:58,009 --> 00:02:03,720
some of those rough edges easier and

00:02:01,979 --> 00:02:06,560
what do they do when they see these

00:02:03,720 --> 00:02:09,720
weird error messages

00:02:06,560 --> 00:02:12,030
so Adrian Mohr's he's well known for

00:02:09,720 --> 00:02:14,010
saying I stopped worrying about variants

00:02:12,030 --> 00:02:18,510
by just adding plus minus until it

00:02:14,010 --> 00:02:22,200
compiles he may have even said

00:02:18,510 --> 00:02:23,790
this afternoon I don't know and his

00:02:22,200 --> 00:02:25,110
point with this is that this college

00:02:23,790 --> 00:02:26,730
compiler does a really good job of

00:02:25,110 --> 00:02:29,970
getting your back usually you can just

00:02:26,730 --> 00:02:31,500
trust this but you know I think it's

00:02:29,970 --> 00:02:34,170
good for us to go a little deeper and

00:02:31,500 --> 00:02:36,540
understand what we're doing and and what

00:02:34,170 --> 00:02:38,819
it means and sometimes we just have to

00:02:36,540 --> 00:02:42,840
add plus or minus until it compiles and

00:02:38,819 --> 00:02:44,609
you know call the day good so a quick

00:02:42,840 --> 00:02:46,079
overview of what I'm going to talk about

00:02:44,609 --> 00:02:47,220
first we'll spend a lot of time on

00:02:46,079 --> 00:02:49,769
variants then we'll talk about

00:02:47,220 --> 00:02:52,470
constraints and how those constraints

00:02:49,769 --> 00:02:53,940
enable a pattern called type classes and

00:02:52,470 --> 00:02:56,129
then at the end I want to mention very

00:02:53,940 --> 00:03:00,989
briefly how these concepts appear in

00:02:56,129 --> 00:03:03,889
dotty that's going to become Scala 3 so

00:03:00,989 --> 00:03:07,230
let's start kind of with the basics

00:03:03,889 --> 00:03:10,409
inheritance and substitution so all

00:03:07,230 --> 00:03:12,389
values in Scala have a type there's an

00:03:10,409 --> 00:03:14,760
inheritance relationship between those

00:03:12,389 --> 00:03:17,430
types so that all types have a

00:03:14,760 --> 00:03:18,840
superclass a parent relationship that

00:03:17,430 --> 00:03:21,420
goes all the way up to a top class

00:03:18,840 --> 00:03:23,310
called any and they potentially have a

00:03:21,420 --> 00:03:27,150
subtype relationship if they have a

00:03:23,310 --> 00:03:29,549
child they always have this child down

00:03:27,150 --> 00:03:32,419
to bottom but they might define their

00:03:29,549 --> 00:03:35,250
other classes might be defined in there

00:03:32,419 --> 00:03:38,669
we can then substitute these in places

00:03:35,250 --> 00:03:41,310
because references can store instances

00:03:38,669 --> 00:03:42,989
of one of the subclasses and when we

00:03:41,310 --> 00:03:44,790
call functions we can pass a subclass

00:03:42,989 --> 00:03:47,069
where we expect that superclass and

00:03:44,790 --> 00:03:48,989
functions can return a subclass when

00:03:47,069 --> 00:03:51,000
they tell us that they're gonna return a

00:03:48,989 --> 00:03:53,129
superclass and this kind of pattern is

00:03:51,000 --> 00:03:55,919
really really common you've probably

00:03:53,129 --> 00:03:58,199
seen it all over the place if you're

00:03:55,919 --> 00:03:59,549
doing cons on lists you're already

00:03:58,199 --> 00:04:02,609
seeing this pattern happened you're

00:03:59,549 --> 00:04:06,870
having two different subtypes for nil or

00:04:02,609 --> 00:04:09,389
for cons so there's this formal thing

00:04:06,870 --> 00:04:14,099
called Liskov substitution principle was

00:04:09,389 --> 00:04:16,769
Liskov and winged 1994 something about

00:04:14,099 --> 00:04:21,329
let Phi of X be a property provable blah

00:04:16,769 --> 00:04:23,909
blah blah the kind of more user human

00:04:21,329 --> 00:04:27,060
readable version of this I pulled from

00:04:23,909 --> 00:04:29,310
Wikipedia if s is a subtype of T then

00:04:27,060 --> 00:04:32,400
objects of type T can be replaced with

00:04:29,310 --> 00:04:34,290
objects of type s without altering

00:04:32,400 --> 00:04:37,770
the desirable properties of that program

00:04:34,290 --> 00:04:40,050
so I can use subclasses the same places

00:04:37,770 --> 00:04:43,280
that I use the super classes and expect

00:04:40,050 --> 00:04:43,280
to everything to behave the same way

00:04:43,400 --> 00:04:48,360
changing topic a tiny bit let's talk

00:04:46,199 --> 00:04:50,910
about higher kinda types so higher kind

00:04:48,360 --> 00:04:52,590
of type a type that contains or is based

00:04:50,910 --> 00:04:55,770
on another type in some sort of way

00:04:52,590 --> 00:04:58,650
these might be generic these we usually

00:04:55,770 --> 00:05:00,660
call these parameterize types they're

00:04:58,650 --> 00:05:02,580
contained or implemented in terms of

00:05:00,660 --> 00:05:04,949
some other types so a specific example

00:05:02,580 --> 00:05:08,070
is list of int that's a completely bound

00:05:04,949 --> 00:05:10,470
example the more general list of T we

00:05:08,070 --> 00:05:12,419
substitute any other sort of T when we

00:05:10,470 --> 00:05:15,139
bind it to and bind it to double

00:05:12,419 --> 00:05:17,280
whatever when we instantiate one of them

00:05:15,139 --> 00:05:19,789
so this gives us kind of two different

00:05:17,280 --> 00:05:23,880
axes where this sub classing can happen

00:05:19,789 --> 00:05:25,889
there's the container super class and

00:05:23,880 --> 00:05:29,010
subclass relationship right we have

00:05:25,889 --> 00:05:31,919
sequences and sequences our subclass tis

00:05:29,010 --> 00:05:34,770
lists but then we also have this axis

00:05:31,919 --> 00:05:38,430
where the contents have super classes

00:05:34,770 --> 00:05:43,380
and subclasses ins go up to any ref and

00:05:38,430 --> 00:05:47,099
so on if we look at the Scala

00:05:43,380 --> 00:05:50,340
documentation I think the first part

00:05:47,099 --> 00:05:52,289
comes from the tour of Scala variants is

00:05:50,340 --> 00:05:55,289
the correlation of subtyping

00:05:52,289 --> 00:05:56,789
relationships of complex types and the

00:05:55,289 --> 00:05:59,750
subtyping relationships are their

00:05:56,789 --> 00:06:02,639
component types so the correlation of

00:05:59,750 --> 00:06:04,970
that one axis and the subtyping

00:06:02,639 --> 00:06:07,650
relationship on that other axis and

00:06:04,970 --> 00:06:11,099
Twitter Scala school puts it a little

00:06:07,650 --> 00:06:12,750
bit more precisely a central question

00:06:11,099 --> 00:06:16,620
that comes up when mixing oo and

00:06:12,750 --> 00:06:19,229
polymorphism if T is a subclass of T is

00:06:16,620 --> 00:06:23,960
container T prime a subclass of

00:06:19,229 --> 00:06:27,000
container T so I've always felt that

00:06:23,960 --> 00:06:28,830
defining and thinking about variants in

00:06:27,000 --> 00:06:31,410
terms of sub super class and subclass

00:06:28,830 --> 00:06:33,570
relationships although it's technically

00:06:31,410 --> 00:06:35,400
accurate I've always found that really

00:06:33,570 --> 00:06:37,289
confusing to think about and make sense

00:06:35,400 --> 00:06:42,090
of what do we mean when we're talking

00:06:37,289 --> 00:06:46,020
about lists of T is a super type of list

00:06:42,090 --> 00:06:47,699
of you so instead

00:06:46,020 --> 00:06:49,319
I suggest that we think about that

00:06:47,699 --> 00:06:52,259
Liskov substitution principle and apply

00:06:49,319 --> 00:06:54,930
that back into these so we're talking

00:06:52,259 --> 00:06:59,909
about when can we subbed when can we

00:06:54,930 --> 00:07:01,860
substitute values when can we substitute

00:06:59,909 --> 00:07:05,250
complex types in wind can we substitute

00:07:01,860 --> 00:07:08,430
the component types if T Prime's a

00:07:05,250 --> 00:07:11,430
subclass of T can contain or T prime be

00:07:08,430 --> 00:07:13,500
substituted for a container T and when

00:07:11,430 --> 00:07:16,979
those things can or can't happen is what

00:07:13,500 --> 00:07:19,229
variance is all about so I think about

00:07:16,979 --> 00:07:22,349
this like substituting compatible

00:07:19,229 --> 00:07:24,599
machines right so Calvin's got his his

00:07:22,349 --> 00:07:26,340
new and improved duplicator and he was

00:07:24,599 --> 00:07:29,159
going to substitute that in where he

00:07:26,340 --> 00:07:31,710
used to use the duplicator before and

00:07:29,159 --> 00:07:34,740
hobbes who's pushing the button that

00:07:31,710 --> 00:07:36,419
goes boink is going to not really care

00:07:34,740 --> 00:07:38,099
or know whether it's the

00:07:36,419 --> 00:07:43,380
new-and-improved duplicator or the old

00:07:38,099 --> 00:07:45,930
duplicator so a lot of the tutorials

00:07:43,380 --> 00:07:47,969
that you see use this domain example

00:07:45,930 --> 00:07:50,130
that's in terms of animals it's not very

00:07:47,969 --> 00:07:52,979
interesting or compelling but its

00:07:50,130 --> 00:07:55,830
intuitive so I'm sticking with that like

00:07:52,979 --> 00:07:57,870
as we go through these slides I think

00:07:55,830 --> 00:08:01,139
it'll be easier to remember that a cat

00:07:57,870 --> 00:08:02,580
is a pet and a pet is an animal than for

00:08:01,139 --> 00:08:03,840
me to introduce some other sort of

00:08:02,580 --> 00:08:08,219
domain thing that you have to keep

00:08:03,840 --> 00:08:10,080
straight so let's jump right into the

00:08:08,219 --> 00:08:12,779
three kinds of variants that we can see

00:08:10,080 --> 00:08:15,990
in Scala in variance covariance and

00:08:12,779 --> 00:08:18,630
contravariance so invariance says

00:08:15,990 --> 00:08:21,210
there's no subclass relationship that

00:08:18,630 --> 00:08:23,580
means we can't substitute a container T

00:08:21,210 --> 00:08:28,169
and a container you and less T and U or

00:08:23,580 --> 00:08:31,889
the same type sorry unless T and u are

00:08:28,169 --> 00:08:35,010
the same type but subclass so that's

00:08:31,889 --> 00:08:37,829
that's this one axis right but sub

00:08:35,010 --> 00:08:41,659
containers can be consulted to differ

00:08:37,829 --> 00:08:44,820
containers of the same type right so I

00:08:41,659 --> 00:08:47,790
guess list sequence is not a good

00:08:44,820 --> 00:08:52,640
example but if we made our own list

00:08:47,790 --> 00:08:56,490
sequence that was invariant we could

00:08:52,640 --> 00:08:59,970
substitute that sub list for the

00:08:56,490 --> 00:09:02,370
sequence and anything that's

00:08:59,970 --> 00:09:03,600
posed as a VAR has to be invariant we'll

00:09:02,370 --> 00:09:06,689
kind of talk about that a little bit

00:09:03,600 --> 00:09:10,470
more later when we see what what

00:09:06,689 --> 00:09:13,769
problems come up and what that that

00:09:10,470 --> 00:09:17,480
error message was a confused Jackie so a

00:09:13,769 --> 00:09:21,019
few examples here so I start with my

00:09:17,480 --> 00:09:24,930
invariant class invariant wrapper

00:09:21,019 --> 00:09:28,920
parameterized in a he's invariant he has

00:09:24,930 --> 00:09:31,889
no plus/minus annotation he has a

00:09:28,920 --> 00:09:33,329
parameter a DH to his constructor and

00:09:31,889 --> 00:09:38,310
he's going to expose a method that

00:09:33,329 --> 00:09:41,870
returns that a so if I have a w and I

00:09:38,310 --> 00:09:45,990
defined W is invariant wrapper of cat

00:09:41,870 --> 00:09:50,970
then I can put an invariant wrapper with

00:09:45,990 --> 00:09:53,310
a cat into that but if I try actually

00:09:50,970 --> 00:09:55,620
let me do this sub first so I have a sub

00:09:53,310 --> 00:09:58,470
wrapper that extent extends invariant

00:09:55,620 --> 00:09:59,939
wrapper I make my invariant wrapper of

00:09:58,470 --> 00:10:02,250
cat I can substitute my invariant

00:09:59,939 --> 00:10:04,860
wrapper for my sub wrapper for cat into

00:10:02,250 --> 00:10:09,480
my invariant wrapper for cat no problem

00:10:04,860 --> 00:10:12,000
that's this one axis but I can't go the

00:10:09,480 --> 00:10:15,889
other axis invariant wrapper of animal

00:10:12,000 --> 00:10:18,990
can't take my invariant wrapper of cat

00:10:15,889 --> 00:10:20,819
now I can take an invariant wrapper of

00:10:18,990 --> 00:10:23,699
animal and put a cat into it because

00:10:20,819 --> 00:10:25,439
that's regular subclass but anywhere I'm

00:10:23,699 --> 00:10:26,790
using that I can't pull it out and know

00:10:25,439 --> 00:10:28,860
it's account I pull it out and know it's

00:10:26,790 --> 00:10:31,740
an animal and if I want to know it's a

00:10:28,860 --> 00:10:34,319
cat I'm gonna have to become untyped

00:10:31,740 --> 00:10:35,819
safe and do some some casting and maybe

00:10:34,319 --> 00:10:42,209
do some reflection and stuff like that

00:10:35,819 --> 00:10:44,100
you know ugly stuff so this this very

00:10:42,209 --> 00:10:46,290
bottom one when I try to do the wrong

00:10:44,100 --> 00:10:47,930
thing I'm gonna get an error message it

00:10:46,290 --> 00:10:50,189
looks something like Titan mismatch

00:10:47,930 --> 00:10:52,139
found an invariant wrapper of cat

00:10:50,189 --> 00:10:54,660
required an invariant wrapper of animal

00:10:52,139 --> 00:10:57,029
in this case compiler is helpful for us

00:10:54,660 --> 00:11:00,870
it says gives us an example of why it

00:10:57,029 --> 00:11:03,990
why it came to this conclusion cat is a

00:11:00,870 --> 00:11:06,839
subtype of animal but invariant wrapper

00:11:03,990 --> 00:11:09,660
is invariant in Taipei okay so it helped

00:11:06,839 --> 00:11:11,429
tell us why invariant wrapper of cat was

00:11:09,660 --> 00:11:13,970
not an invariant wrapper of animal but

00:11:11,429 --> 00:11:15,529
this is the first place that maybe maybe

00:11:13,970 --> 00:11:17,029
as you or your colleagues out and they

00:11:15,529 --> 00:11:21,589
say what does it mean that this is

00:11:17,029 --> 00:11:24,889
invariant so covariance is the second

00:11:21,589 --> 00:11:29,600
type covariance is really good when we

00:11:24,889 --> 00:11:31,519
want to consume values from the thing so

00:11:29,600 --> 00:11:34,550
in this case we have a subclass

00:11:31,519 --> 00:11:37,670
relationship when the contents have a

00:11:34,550 --> 00:11:41,230
subclass relationship so if you is a

00:11:37,670 --> 00:11:43,579
subclass of T then I can store

00:11:41,230 --> 00:11:47,750
substitute a container for you into my

00:11:43,579 --> 00:11:49,220
container for T and that's useful when

00:11:47,750 --> 00:11:52,759
we want to extract the contents out of

00:11:49,220 --> 00:11:54,680
the container so remember I can use

00:11:52,759 --> 00:11:57,079
subtypes anywhere that I use the super

00:11:54,680 --> 00:11:58,910
type so instances of you can be used

00:11:57,079 --> 00:11:59,360
anywhere where T's are expected that's

00:11:58,910 --> 00:12:02,170
good

00:11:59,360 --> 00:12:05,029
a container of yous gonna give me out

00:12:02,170 --> 00:12:06,470
use which are substitutable forties so

00:12:05,029 --> 00:12:08,899
they give me T's so that's good

00:12:06,470 --> 00:12:11,689
therefore the types are sound so that

00:12:08,899 --> 00:12:13,250
works but this is problematic when you

00:12:11,689 --> 00:12:19,279
add or change values and we'll get to

00:12:13,250 --> 00:12:21,860
that in a couple moments so an example

00:12:19,279 --> 00:12:23,809
of this so can contravariant wrapper

00:12:21,860 --> 00:12:25,850
this time we mark it is controvert all

00:12:23,809 --> 00:12:29,870
right covariant wrapper we mark it as

00:12:25,850 --> 00:12:31,970
covariant with the plus plus a the rest

00:12:29,870 --> 00:12:36,290
of the shape is the same I take an A and

00:12:31,970 --> 00:12:39,860
I have a def that returns that a and I

00:12:36,290 --> 00:12:44,089
want to pass this on this wrapper into

00:12:39,860 --> 00:12:47,660
some function do it so I can put I can

00:12:44,089 --> 00:12:48,920
call that do it function with covariant

00:12:47,660 --> 00:12:51,670
wrappers of cats I can call that

00:12:48,920 --> 00:12:55,670
function with covariant wrappers of dogs

00:12:51,670 --> 00:12:59,480
dogs and cats are subtypes of animal in

00:12:55,670 --> 00:13:00,769
this case I did this this example with

00:12:59,480 --> 00:13:04,899
cats and dogs and animals if you

00:13:00,769 --> 00:13:07,490
remember back I had animals abstract so

00:13:04,899 --> 00:13:09,920
that's why I kind of ended up with this

00:13:07,490 --> 00:13:13,309
kind of example but this also shows

00:13:09,920 --> 00:13:15,920
something that's why we might use Cote

00:13:13,309 --> 00:13:19,069
want to use covariance right we can

00:13:15,920 --> 00:13:21,529
write this duet function that knows how

00:13:19,069 --> 00:13:23,179
to do things about animals and we can

00:13:21,529 --> 00:13:24,600
call it with different subtypes of

00:13:23,179 --> 00:13:27,780
animals that are that are

00:13:24,600 --> 00:13:30,270
right we might see this with many of the

00:13:27,780 --> 00:13:32,460
list functions and we can use that same

00:13:30,270 --> 00:13:36,780
one because list is covariance and we

00:13:32,460 --> 00:13:40,620
can pass different kinds of lists but if

00:13:36,780 --> 00:13:44,880
we try to call that with covalent

00:13:40,620 --> 00:13:47,490
wrapper of any any is not a subclass of

00:13:44,880 --> 00:13:51,300
animal so we're gonna get an error and

00:13:47,490 --> 00:13:53,130
that error is a little less helpful than

00:13:51,300 --> 00:13:56,070
the error we got before it tells us

00:13:53,130 --> 00:13:58,140
there's a type mismatch tells us what it

00:13:56,070 --> 00:14:00,240
expected and what it found but it

00:13:58,140 --> 00:14:06,060
doesn't give us the hint about why why

00:14:00,240 --> 00:14:07,860
those things weren't the same let's go

00:14:06,060 --> 00:14:10,820
the other way other way is

00:14:07,860 --> 00:14:14,070
contravariance so contravariance is

00:14:10,820 --> 00:14:18,030
subclass relationships when the contents

00:14:14,070 --> 00:14:23,850
have a super class relationship okay so

00:14:18,030 --> 00:14:26,910
when the contents are super classes then

00:14:23,850 --> 00:14:30,180
we can use it so if T is a superclass of

00:14:26,910 --> 00:14:33,570
u then we can replace containers for T's

00:14:30,180 --> 00:14:36,530
where we need containers for use so this

00:14:33,570 --> 00:14:40,200
is useful for processors or consumers of

00:14:36,530 --> 00:14:45,300
values and so let me walk through that

00:14:40,200 --> 00:14:47,910
same thing so instances of U T is a

00:14:45,300 --> 00:14:56,220
superclass of U so use can be used where

00:14:47,910 --> 00:15:00,300
T's are expected consumers of U is my

00:14:56,220 --> 00:15:04,140
example backwards here so if you use use

00:15:00,300 --> 00:15:08,190
our subtypes of T's a consumer that

00:15:04,140 --> 00:15:12,810
takes a T can consume at you so so the

00:15:08,190 --> 00:15:15,540
types are sound if I pass a container of

00:15:12,810 --> 00:15:16,830
T's someplace that's our container

00:15:15,540 --> 00:15:19,890
review someplace that expects a

00:15:16,830 --> 00:15:21,540
container of T's it's problematic when

00:15:19,890 --> 00:15:24,480
we return or produce values and we'll

00:15:21,540 --> 00:15:26,520
get to that in just a second so see how

00:15:24,480 --> 00:15:29,400
this gets confusing it's not that bad

00:15:26,520 --> 00:15:32,760
really but especially when you think

00:15:29,400 --> 00:15:34,410
about how these relationships work to

00:15:32,760 --> 00:15:37,590
one another and when you can substitute

00:15:34,410 --> 00:15:42,300
in T's and use

00:15:37,590 --> 00:15:44,760
in different places so so maybe let's

00:15:42,300 --> 00:15:46,680
look at that with an example so here

00:15:44,760 --> 00:15:52,740
I've got an abstract class keeper and

00:15:46,680 --> 00:15:54,690
the keeper contend whatever this a is so

00:15:52,740 --> 00:15:58,490
we've defined it as contravariant with

00:15:54,690 --> 00:16:00,900
the minus annotation keeper of minus a

00:15:58,490 --> 00:16:05,370
so we have a dog-sitter which is a

00:16:00,900 --> 00:16:07,050
keeper of dogs and just to show kind of

00:16:05,370 --> 00:16:11,130
the shape of what this tend is going to

00:16:07,050 --> 00:16:15,210
be because dog is now my a10 is going to

00:16:11,130 --> 00:16:16,950
attend dog returned a unit still we're

00:16:15,210 --> 00:16:19,620
gonna have to define the same thing when

00:16:16,950 --> 00:16:21,900
we define zookeeper which is a keeper of

00:16:19,620 --> 00:16:24,570
any animal and a pet sitter that's a

00:16:21,900 --> 00:16:27,330
keeper of any pet so I'd still have that

00:16:24,570 --> 00:16:31,529
tend to find I just omitted it for for

00:16:27,330 --> 00:16:33,690
brevity on the slide so now I'm gonna

00:16:31,529 --> 00:16:36,180
want to think about when I can

00:16:33,690 --> 00:16:38,550
substitute in different kinds of pet

00:16:36,180 --> 00:16:43,110
sitters or zookeepers to keep my

00:16:38,550 --> 00:16:46,980
different animals so if I have a keeper

00:16:43,110 --> 00:16:50,700
of dogs I can use a dog sitter for that

00:16:46,980 --> 00:16:53,839
dog sitter is a keeper of dogs and that

00:16:50,700 --> 00:16:56,970
dog sitter contend tintin no problem a

00:16:53,839 --> 00:16:58,830
zookeeper because a zookeeper is a

00:16:56,970 --> 00:17:01,800
keeper of any sort of animal it can't

00:16:58,830 --> 00:17:04,350
end any sort of animal he can also tend

00:17:01,800 --> 00:17:07,319
Scooby the dog because the dog is the

00:17:04,350 --> 00:17:09,750
animal so we can substitute him in there

00:17:07,319 --> 00:17:11,160
and that's fine so I'd still got keeper

00:17:09,750 --> 00:17:13,319
of dog but I'm putting it in with a

00:17:11,160 --> 00:17:19,920
keeper of animal which is a super type

00:17:13,319 --> 00:17:23,699
of dog and I can do the same can I do

00:17:19,920 --> 00:17:30,120
the same I cannot yes I can still do the

00:17:23,699 --> 00:17:32,940
same for I see what I did here so so if

00:17:30,120 --> 00:17:35,400
I want a keeper of pet and I try to

00:17:32,940 --> 00:17:37,800
replace it with a keeper of dog with a

00:17:35,400 --> 00:17:40,410
dog-sitter dog sitter is a keeper of

00:17:37,800 --> 00:17:42,530
dogs only but it is not a keeper of all

00:17:40,410 --> 00:17:45,929
sorts of pets it's just a keeper of dogs

00:17:42,530 --> 00:17:48,690
so my dog sitter can't sit cats can't

00:17:45,929 --> 00:17:50,940
sit hamsters so I'm going to have a

00:17:48,690 --> 00:17:55,920
problem if I try to

00:17:50,940 --> 00:18:00,870
send my dog sitter son mate my cat to a

00:17:55,920 --> 00:18:05,570
dog sitter so my error message I found a

00:18:00,870 --> 00:18:05,570
dog sitter but I needed a keeper of pets

00:18:06,440 --> 00:18:13,280
dog is a pet but dog is not the keeper

00:18:09,420 --> 00:18:15,990
of all car dog is not all kinds of pets

00:18:13,280 --> 00:18:18,330
so now we have enough to come back to

00:18:15,990 --> 00:18:21,780
the the error message that that was

00:18:18,330 --> 00:18:23,930
making Jackie throw up his hands so that

00:18:21,780 --> 00:18:27,150
error message talked about covariant

00:18:23,930 --> 00:18:31,500
value in contravariant position so what

00:18:27,150 --> 00:18:33,060
are positions so the the spec defines a

00:18:31,500 --> 00:18:35,880
bunch of rules from what makes a

00:18:33,060 --> 00:18:37,590
position and how positions change but in

00:18:35,880 --> 00:18:41,630
practice usually what you carry about is

00:18:37,590 --> 00:18:43,530
covariant position is method returns

00:18:41,630 --> 00:18:46,470
contravariant position is method

00:18:43,530 --> 00:18:51,990
arguments and invariant positions are

00:18:46,470 --> 00:18:55,710
mutable vowels VARs so when we define in

00:18:51,990 --> 00:18:57,960
our type parameters plus a minus a or

00:18:55,710 --> 00:19:01,350
nothing we said whether that was a

00:18:57,960 --> 00:19:04,590
covariant contravariant or not invariant

00:19:01,350 --> 00:19:07,710
type parameter and then we're going to

00:19:04,590 --> 00:19:10,800
look at the positions covariant

00:19:07,710 --> 00:19:13,350
parameters ones that are marked plus a

00:19:10,800 --> 00:19:15,980
cannot appear in contravariant position

00:19:13,350 --> 00:19:19,830
that means in a method argument

00:19:15,980 --> 00:19:22,710
contravariant parameters minus s cannot

00:19:19,830 --> 00:19:26,580
appear in covariant positions method

00:19:22,710 --> 00:19:28,530
returns and neither covariant or

00:19:26,580 --> 00:19:33,690
contravariant parameters can appear in

00:19:28,530 --> 00:19:36,960
an invariant position so the error

00:19:33,690 --> 00:19:39,510
messages that come out of both 2 to 12 6

00:19:36,960 --> 00:19:41,610
and intellij unfortunately are a little

00:19:39,510 --> 00:19:43,970
bit misleading because they still give

00:19:41,610 --> 00:19:46,830
you the same error message that says

00:19:43,970 --> 00:19:48,690
covariant parameter can't apply and

00:19:46,830 --> 00:19:50,700
contravariant position instead of saying

00:19:48,690 --> 00:19:52,320
covariant parameter cannot apply an

00:19:50,700 --> 00:19:55,650
invariant position or something like

00:19:52,320 --> 00:19:58,050
that so what's a problem with these why

00:19:55,650 --> 00:20:01,320
can't we have something appear in the

00:19:58,050 --> 00:20:04,650
wrong position so let's look at

00:20:01,320 --> 00:20:09,000
contravariant first so contrary

00:20:04,650 --> 00:20:13,170
is method parameters so if I try to do

00:20:09,000 --> 00:20:16,710
box of a pet plus pet so covariant pet

00:20:13,170 --> 00:20:20,850
and I try to do a swap that puts a new

00:20:16,710 --> 00:20:23,610
pet into the box I'm gonna get this

00:20:20,850 --> 00:20:28,830
error message on on that swap method

00:20:23,610 --> 00:20:33,990
there's a new P so suppose I have a a

00:20:28,830 --> 00:20:37,620
box of of cats and I want to swap the

00:20:33,990 --> 00:20:39,420
cat okay that would be a fair thing

00:20:37,620 --> 00:20:43,770
right I've got a box of cats and I want

00:20:39,420 --> 00:20:48,060
to replace it with a cat no problem if I

00:20:43,770 --> 00:20:51,810
have a box of pets and I want to put a

00:20:48,060 --> 00:20:55,770
cat still into that that seems kind of

00:20:51,810 --> 00:20:58,800
ok but if I have a box of cats and I try

00:20:55,770 --> 00:21:02,990
to put a dog in now I've got problems

00:20:58,800 --> 00:21:06,950
right so so I have my box of pets I

00:21:02,990 --> 00:21:10,410
instantiate that as a box of cats and

00:21:06,950 --> 00:21:16,500
then I try to put a pet in and that pets

00:21:10,410 --> 00:21:18,830
not a cat retro so that's the problem

00:21:16,500 --> 00:21:21,350
with contravariance and that's why

00:21:18,830 --> 00:21:24,990
covariant parameters cannot appear in

00:21:21,350 --> 00:21:29,580
contravariant position in value a of

00:21:24,990 --> 00:21:33,720
whatever opposite is the case for

00:21:29,580 --> 00:21:37,940
covariant right so so covariant position

00:21:33,720 --> 00:21:42,300
is return types so I have a sitter of

00:21:37,940 --> 00:21:44,880
contravariant pets I'm going to

00:21:42,300 --> 00:21:49,140
instantiate my sitter with a setter of

00:21:44,880 --> 00:21:55,620
any pets and I try to walk that pet that

00:21:49,140 --> 00:21:57,420
so that seems fine in this in this case

00:21:55,620 --> 00:22:01,260
I have this walk method and walks gonna

00:21:57,420 --> 00:22:04,470
return a new pet so so I've got my

00:22:01,260 --> 00:22:07,230
sitter of cat and my pet sitter returns

00:22:04,470 --> 00:22:10,200
me a new pet if that pets still a cat ok

00:22:07,230 --> 00:22:12,450
everything's fine if that cat returns a

00:22:10,200 --> 00:22:15,720
dog we have a problem but that's

00:22:12,450 --> 00:22:17,480
perfectly legit for the sitter of pet to

00:22:15,720 --> 00:22:21,740
return any subtype of pet

00:22:17,480 --> 00:22:25,170
right so that's why this is a problem to

00:22:21,740 --> 00:22:27,840
have contravariant arguments appear in

00:22:25,170 --> 00:22:33,210
covariant position in value whatever or

00:22:27,840 --> 00:22:36,960
whatever let's look at a different sort

00:22:33,210 --> 00:22:40,290
of example and we'll look at a couple of

00:22:36,960 --> 00:22:44,180
things from this so one is I want to

00:22:40,290 --> 00:22:46,500
make I want to make a point about

00:22:44,180 --> 00:22:49,490
multiple parameters and mixing and

00:22:46,500 --> 00:22:54,210
matching covariance and contravariance

00:22:49,490 --> 00:22:56,340
so I have some p1 that's a pet and some

00:22:54,210 --> 00:23:00,840
p2 that's a pet and I'm going to call a

00:22:56,340 --> 00:23:02,970
function f with those two parameters so

00:23:00,840 --> 00:23:07,410
I have a bunch of example F's here

00:23:02,970 --> 00:23:10,530
example definitions for F bunch of

00:23:07,410 --> 00:23:14,790
different signatures for F if I just had

00:23:10,530 --> 00:23:18,600
F a pet pet which of these signatures

00:23:14,790 --> 00:23:20,010
would I be able to call so f that takes

00:23:18,600 --> 00:23:22,050
two pets and returns a pet yeah

00:23:20,010 --> 00:23:25,830
absolutely I could call that with p1

00:23:22,050 --> 00:23:28,440
Putin F that takes an animal in a pet

00:23:25,830 --> 00:23:34,530
and returns a pet and I call it with two

00:23:28,440 --> 00:23:36,390
pets yeah cool F of any and pet and I

00:23:34,530 --> 00:23:42,270
call it with two pets pets are still a

00:23:36,390 --> 00:23:45,240
nice yeah good F of Annie any pet pets

00:23:42,270 --> 00:23:48,810
are still Annie's yeah good good F of

00:23:45,240 --> 00:23:50,880
cat and dog cats and dogs are pets but

00:23:48,810 --> 00:23:52,650
pets are not cats or dogs right I can

00:23:50,880 --> 00:23:56,370
substitute the one direction but not the

00:23:52,650 --> 00:24:00,750
other direction so I so with just F of

00:23:56,370 --> 00:24:04,010
p1 and p2 I couldn't call this last F so

00:24:00,750 --> 00:24:12,480
what does that all say that says when

00:24:04,010 --> 00:24:13,830
the make sure I say this carefully if I

00:24:12,480 --> 00:24:18,300
wanted to substitute a different

00:24:13,830 --> 00:24:23,880
function I could substitute any function

00:24:18,300 --> 00:24:27,380
where the inputs are super types of the

00:24:23,880 --> 00:24:30,740
way I'm trying to call it okay so

00:24:27,380 --> 00:24:34,040
I have F of two pets I can substitute in

00:24:30,740 --> 00:24:39,550
any function where the parameters are

00:24:34,040 --> 00:24:42,260
pets or above pets animals any and

00:24:39,550 --> 00:24:44,810
that's true for any of our arguments so

00:24:42,260 --> 00:24:48,590
in this case function two takes two

00:24:44,810 --> 00:24:51,470
parameters and returns a result so we

00:24:48,590 --> 00:24:55,820
see function two has two inputs and one

00:24:51,470 --> 00:24:58,970
output t1 t2 are this generalizes across

00:24:55,820 --> 00:25:00,980
all 22 different function types so

00:24:58,970 --> 00:25:04,760
function one all the way to function 22

00:25:00,980 --> 00:25:07,850
all these inputs because they can now

00:25:04,760 --> 00:25:10,310
take I can substitute them in when they

00:25:07,850 --> 00:25:16,040
are super types what does that mean that

00:25:10,310 --> 00:25:17,810
means contravariant and i deliberately

00:25:16,040 --> 00:25:21,820
have left my are blank here because

00:25:17,810 --> 00:25:25,220
we'll get to that on the next slide so

00:25:21,820 --> 00:25:28,130
now I'm defining a type that I expect it

00:25:25,220 --> 00:25:30,830
to come back from those functions so our

00:25:28,130 --> 00:25:35,840
that's an animal and I'm going to call F

00:25:30,830 --> 00:25:37,550
with my two pets so if I have an F that

00:25:35,840 --> 00:25:39,830
takes two pets and returns an animal

00:25:37,550 --> 00:25:40,460
yeah I can store that into an animal

00:25:39,830 --> 00:25:43,820
okay cool

00:25:40,460 --> 00:25:46,010
if it takes two pets and returns a pet

00:25:43,820 --> 00:25:47,570
all pets and animals so I can store that

00:25:46,010 --> 00:25:50,900
into an animal okay cool

00:25:47,570 --> 00:25:53,840
f that takes two pets and returns a cat

00:25:50,900 --> 00:25:56,330
cats a pet pets an animal so yeah cats

00:25:53,840 --> 00:25:58,910
an animal f it takes two pets and

00:25:56,330 --> 00:25:59,600
returns in any well no and he's not an

00:25:58,910 --> 00:26:05,150
animal

00:25:59,600 --> 00:26:06,290
Annie may be animal is so maybe but but

00:26:05,150 --> 00:26:07,760
in general it's not so what does this

00:26:06,290 --> 00:26:09,850
mean this means we can substitute in

00:26:07,760 --> 00:26:14,660
these functions when they return

00:26:09,850 --> 00:26:17,570
subtypes so covariant so our function

00:26:14,660 --> 00:26:22,120
two and again by generalization all of

00:26:17,570 --> 00:26:26,630
our all of our function ends are

00:26:22,120 --> 00:26:30,790
contravariant in inputs and covariant in

00:26:26,630 --> 00:26:30,790
responses in returns

00:26:33,010 --> 00:26:39,320
so again when to use these so covariance

00:26:37,610 --> 00:26:42,560
is really good for containers when I

00:26:39,320 --> 00:26:45,020
want to get things out of that wrapper

00:26:42,560 --> 00:26:47,300
out of that container out of that list

00:26:45,020 --> 00:26:49,490
out of that whatever I want to be able

00:26:47,300 --> 00:26:53,450
to substitute in other wrappers that

00:26:49,490 --> 00:26:55,490
have some types of those so anything

00:26:53,450 --> 00:26:59,480
that's a kind of a producer anything

00:26:55,490 --> 00:27:00,980
that represents inputs sorry represents

00:26:59,480 --> 00:27:04,310
that should be the opposite represents

00:27:00,980 --> 00:27:08,120
outputs of the thing that I am calling

00:27:04,310 --> 00:27:10,460
and contravariance I'm going to use when

00:27:08,120 --> 00:27:14,060
it's something to consume right so our

00:27:10,460 --> 00:27:17,000
examples were zoo keepers and pet

00:27:14,060 --> 00:27:19,640
sitters that consumed in some way a pet

00:27:17,000 --> 00:27:22,160
but these could be processors printers

00:27:19,640 --> 00:27:24,170
you know what have you something that's

00:27:22,160 --> 00:27:27,560
going to visit everything and wants to

00:27:24,170 --> 00:27:32,240
be able to to to do those and the idea

00:27:27,560 --> 00:27:36,470
there right is that because that

00:27:32,240 --> 00:27:39,380
processor can process some supertype it

00:27:36,470 --> 00:27:41,330
can process some part of the thing I'm

00:27:39,380 --> 00:27:44,840
passing and I can pass it some more

00:27:41,330 --> 00:27:48,080
refined thing and it can still process

00:27:44,840 --> 00:27:49,670
the parts that it knows and and again

00:27:48,080 --> 00:27:52,480
this is flipped on the slide it'll be

00:27:49,670 --> 00:27:58,730
fixed by the time I I upload these

00:27:52,480 --> 00:28:02,350
representing inputs to the thing so back

00:27:58,730 --> 00:28:07,460
a number of years ago when Java

00:28:02,350 --> 00:28:10,490
introduced wild card parameters Josh

00:28:07,460 --> 00:28:12,380
Bloch came up with this mnemonic this

00:28:10,490 --> 00:28:14,060
mnemonic works a little better in Java

00:28:12,380 --> 00:28:15,620
because of the keywords but I think it's

00:28:14,060 --> 00:28:17,990
still useful and still helps us to

00:28:15,620 --> 00:28:20,090
remember that so think Arnold

00:28:17,990 --> 00:28:22,420
Schwarzenegger and his fantastic pecs

00:28:20,090 --> 00:28:27,290
when when he was a young man

00:28:22,420 --> 00:28:32,090
bodybuilding mr. Olympia and producer

00:28:27,290 --> 00:28:36,080
extends consumer super so when it's an

00:28:32,090 --> 00:28:39,490
extension when it's a subtype we use

00:28:36,080 --> 00:28:41,830
those for producers covariance

00:28:39,490 --> 00:28:43,289
when they're consumers that's when we

00:28:41,830 --> 00:28:50,289
want to do the super types

00:28:43,289 --> 00:28:53,559
contravariance okay so constraints and

00:28:50,289 --> 00:28:56,919
type classes so we'll start with some

00:28:53,559 --> 00:29:00,220
simple ones upper bound and lower bound

00:28:56,919 --> 00:29:04,570
are for Samer subtypes so this is when

00:29:00,220 --> 00:29:09,360
we want to say so so my examples here

00:29:04,570 --> 00:29:14,409
are our functions so this pet function

00:29:09,360 --> 00:29:19,029
this is pet like apply love to apply

00:29:14,409 --> 00:29:23,679
love to a pet this pet is going to take

00:29:19,029 --> 00:29:26,230
any P which is a pet and do something so

00:29:23,679 --> 00:29:29,440
so I'm not going to allow myself to pet

00:29:26,230 --> 00:29:35,620
other animals that are not subtypes of

00:29:29,440 --> 00:29:40,440
pets I guess depending on whether or not

00:29:35,620 --> 00:29:40,440
you define insects as pets you know

00:29:40,590 --> 00:29:45,549
lower bounds go the opposite way the

00:29:43,240 --> 00:29:53,440
parameter is the same type or a super

00:29:45,549 --> 00:29:56,830
type so this pre I think was meant to be

00:29:53,440 --> 00:30:00,149
add a prefix to a list or something like

00:29:56,830 --> 00:30:04,419
that so I want to add bees to a list of

00:30:00,149 --> 00:30:08,710
A's and return a list of bees where bees

00:30:04,419 --> 00:30:10,600
are super types of A's and I have a I

00:30:08,710 --> 00:30:12,070
have an example of this on a couple of

00:30:10,600 --> 00:30:15,789
slides that I'll explain a little better

00:30:12,070 --> 00:30:17,830
why this BN a and what's going on with

00:30:15,789 --> 00:30:22,960
this one but this is saying we can call

00:30:17,830 --> 00:30:31,020
P pre with any X which is a B which is a

00:30:22,960 --> 00:30:34,600
super type of a so bounds and variants

00:30:31,020 --> 00:30:39,809
so this is kind of the same problem that

00:30:34,600 --> 00:30:43,600
we looked at before this is a plus a

00:30:39,809 --> 00:30:48,100
covariant parameter and I'm passing it

00:30:43,600 --> 00:30:51,460
in as a method argument contravariant

00:30:48,100 --> 00:30:53,049
position so this is going to be the same

00:30:51,460 --> 00:30:54,580
error that made jack

00:30:53,049 --> 00:30:57,369
you throw up his hands at the beginning

00:30:54,580 --> 00:30:59,259
right and I explained before why that

00:30:57,369 --> 00:31:03,100
was a problem but we didn't talk about

00:30:59,259 --> 00:31:04,989
how to how to solve it so one of the

00:31:03,100 --> 00:31:06,820
things that we might try is we say okay

00:31:04,989 --> 00:31:10,860
well let me change my types and let me

00:31:06,820 --> 00:31:14,379
just use bees and let me prepend bees

00:31:10,860 --> 00:31:16,179
onto this list of plus A's but then

00:31:14,379 --> 00:31:18,610
there's no relationship at all between

00:31:16,179 --> 00:31:20,549
A's and B's so the compiler doesn't know

00:31:18,610 --> 00:31:23,470
what to do with these things you know I

00:31:20,549 --> 00:31:25,570
had a list of bees and or a list of A's

00:31:23,470 --> 00:31:26,519
and you given me a list of A's and what

00:31:25,570 --> 00:31:29,019
do I do

00:31:26,519 --> 00:31:31,889
so we need some sort of relationship

00:31:29,019 --> 00:31:37,570
between B and a that's going to be sound

00:31:31,889 --> 00:31:41,440
so we're passing any any B which is a

00:31:37,570 --> 00:31:44,739
subtype of a and a new B and we're going

00:31:41,440 --> 00:31:51,609
to yield a new list of bees all right so

00:31:44,739 --> 00:31:57,639
I have a list of say int and I want to

00:31:51,609 --> 00:32:01,210
pass in some new any any is a super type

00:31:57,639 --> 00:32:05,440
of int and I'm going to return a list of

00:32:01,210 --> 00:32:09,239
any right so what this is doing is it's

00:32:05,440 --> 00:32:12,149
changing the type to a wider type and

00:32:09,239 --> 00:32:15,940
this is exactly what happens with lists

00:32:12,149 --> 00:32:19,090
actually this is exactly the the shape

00:32:15,940 --> 00:32:23,139
of what the the real definition of list

00:32:19,090 --> 00:32:27,070
is here covariant prepend can take any b

00:32:23,139 --> 00:32:29,830
which is an a or a super type so we're

00:32:27,070 --> 00:32:32,859
going to start with list 1 2 3 4 5

00:32:29,830 --> 00:32:38,789
we cons a 0 on to the beginning we still

00:32:32,859 --> 00:32:42,549
have a list events 0 is an int is a

00:32:38,789 --> 00:32:46,450
super tight bound is satisfied int or

00:32:42,549 --> 00:32:53,109
super tight if we try to instead cons

00:32:46,450 --> 00:32:55,330
1.5 on well 1.5 is a double so we're

00:32:53,109 --> 00:32:59,259
gonna have to widen to something which

00:32:55,330 --> 00:33:02,490
is the lowest upper bound of double and

00:32:59,259 --> 00:33:06,490
int so we're gonna end up with any vowel

00:33:02,490 --> 00:33:06,909
so now we've turned from a list of in to

00:33:06,490 --> 00:33:09,549
a list

00:33:06,909 --> 00:33:11,830
- Vinnie Valles was a safe yeah

00:33:09,549 --> 00:33:14,139
absolutely it was safe 1.5 is a

00:33:11,830 --> 00:33:16,479
double-double is in any vowel all those

00:33:14,139 --> 00:33:18,399
things I had before were in since or any

00:33:16,479 --> 00:33:20,649
vowels so now I have a list of any

00:33:18,399 --> 00:33:22,629
vowels but when I want to get things out

00:33:20,649 --> 00:33:24,009
of it I get out any vowels and if I want

00:33:22,629 --> 00:33:27,580
to figure out what they are again I'm

00:33:24,009 --> 00:33:30,009
gonna have to go type unsafe and do some

00:33:27,580 --> 00:33:35,259
some introspection or do some type casts

00:33:30,009 --> 00:33:36,700
or stuff like that view bounds I don't

00:33:35,259 --> 00:33:38,710
want to say very much about this these

00:33:36,700 --> 00:33:40,960
were deprecated I just have the slide in

00:33:38,710 --> 00:33:43,090
here in case you still see them in the

00:33:40,960 --> 00:33:45,029
spec or in real code they're still in

00:33:43,090 --> 00:33:47,259
the spec even though they're deprecated

00:33:45,029 --> 00:33:49,179
basically just indicates a is

00:33:47,259 --> 00:33:51,580
convertible to be by some implicit

00:33:49,179 --> 00:33:53,409
conversion which introduces an evidence

00:33:51,580 --> 00:33:57,249
parameter that we can use to do that

00:33:53,409 --> 00:34:03,849
conversion so more interesting though is

00:33:57,249 --> 00:34:07,950
context bounds so a : context means that

00:34:03,849 --> 00:34:10,480
a has some context which means that

00:34:07,950 --> 00:34:12,879
context of a is somewhere in the

00:34:10,480 --> 00:34:14,109
implicit scope and this is going to

00:34:12,879 --> 00:34:16,510
introduce a compiler is going to

00:34:14,109 --> 00:34:19,029
introduce an evidence parameter on this

00:34:16,510 --> 00:34:22,359
evidence parameter is passed as an

00:34:19,029 --> 00:34:26,980
implicit parameter looks like so I have

00:34:22,359 --> 00:34:29,319
context bound of X which is an M and I

00:34:26,980 --> 00:34:31,299
so I get my regular whatever my regular

00:34:29,319 --> 00:34:34,899
argument list is and then I get added to

00:34:31,299 --> 00:34:38,919
my implicit arguments this evreyone

00:34:34,899 --> 00:34:41,799
dollar which is an M of X and then

00:34:38,919 --> 00:34:44,919
inside my my method I can use the

00:34:41,799 --> 00:34:49,000
implicitly keyword to summon that M of X

00:34:44,919 --> 00:34:50,799
and start calling methods on it so that

00:34:49,000 --> 00:34:58,270
lets us use something called psych class

00:34:50,799 --> 00:35:04,510
pattern so type classes led us implement

00:34:58,270 --> 00:35:07,690
interfaces externally to the code so so

00:35:04,510 --> 00:35:10,510
I have some existing class hierarchy and

00:35:07,690 --> 00:35:13,480
I have some new interface that I want to

00:35:10,510 --> 00:35:15,160
implement and I don't have access to the

00:35:13,480 --> 00:35:19,650
original code or maybe I don't want to

00:35:15,160 --> 00:35:23,390
touch the original code I can right

00:35:19,650 --> 00:35:28,109
an extension that we call a type class

00:35:23,390 --> 00:35:32,869
outside of the original code I can use a

00:35:28,109 --> 00:35:37,459
context bound to say this gets passed to

00:35:32,869 --> 00:35:42,959
this can be passed anything which has a

00:35:37,459 --> 00:35:44,939
context of that of that interface what's

00:35:42,959 --> 00:35:46,380
cool about these is that we can then

00:35:44,939 --> 00:35:51,539
implement them in terms of other

00:35:46,380 --> 00:35:54,029
instances so if I have an adder type

00:35:51,539 --> 00:35:55,979
class and I have an add or event I can

00:35:54,029 --> 00:35:58,949
implement adder of pair of intz in terms

00:35:55,979 --> 00:36:01,499
of that and the compiler can wire that

00:35:58,949 --> 00:36:04,709
up for me and that generalizes really

00:36:01,499 --> 00:36:09,779
really powerfully because I don't have

00:36:04,709 --> 00:36:12,479
to know what the the T is as long as I

00:36:09,779 --> 00:36:19,609
the compiler can give me an adder of T I

00:36:12,479 --> 00:36:23,209
can now implement adder of pair of T and

00:36:19,609 --> 00:36:25,890
and that generalizes even further

00:36:23,209 --> 00:36:29,039
shapeless and so on do a lot of fancy

00:36:25,890 --> 00:36:32,599
tricks with this to generate type class

00:36:29,039 --> 00:36:32,599
derivation for you automatically

00:36:32,789 --> 00:36:39,150
miles use the fancy word earlier today

00:36:34,920 --> 00:36:41,660
inductive type class derivation so

00:36:39,150 --> 00:36:44,640
simply put that define an interface

00:36:41,660 --> 00:36:47,219
implement it for your class put it in

00:36:44,640 --> 00:36:49,769
the implicit scope pass it to the

00:36:47,219 --> 00:36:52,769
function is a type constraint call

00:36:49,769 --> 00:36:57,679
methods from the interface sounds easy

00:36:52,769 --> 00:37:00,150
enough so there's my adder adder of A's

00:36:57,679 --> 00:37:01,859
it's gonna have an ADD method that takes

00:37:00,150 --> 00:37:04,859
two A's and returns nay

00:37:01,859 --> 00:37:07,069
so in implicit scope I'm going to define

00:37:04,859 --> 00:37:11,519
an int adder that's an adder for intz

00:37:07,069 --> 00:37:14,779
that ad takes int int and it returns an

00:37:11,519 --> 00:37:20,519
int by delegating to the regular plus

00:37:14,779 --> 00:37:22,109
then I can add things I have some lists

00:37:20,519 --> 00:37:25,109
say that wants to go through and add

00:37:22,109 --> 00:37:29,400
things I want to go through a list and

00:37:25,109 --> 00:37:31,830
add things I call this add things method

00:37:29,400 --> 00:37:35,340
with any T that has

00:37:31,830 --> 00:37:37,680
an ad or an adder context and my ad

00:37:35,340 --> 00:37:40,340
things can then summon the implicit type

00:37:37,680 --> 00:37:42,150
class instance for whatever that T is

00:37:40,340 --> 00:37:49,860
call out on it

00:37:42,150 --> 00:37:51,930
and Roberts my mother's brother quickly

00:37:49,860 --> 00:37:55,220
I want to mention how these concepts

00:37:51,930 --> 00:37:58,290
come come up in dotty and Scala three

00:37:55,220 --> 00:38:00,240
good news Martin told us yesterday Scala

00:37:58,290 --> 00:38:03,030
three is fundamentally the same language

00:38:00,240 --> 00:38:05,730
as Scala - and that is true for these

00:38:03,030 --> 00:38:07,710
concepts that I talked about today so

00:38:05,730 --> 00:38:10,350
variance and tight bounds all still

00:38:07,710 --> 00:38:14,970
exist in essentially the same the same

00:38:10,350 --> 00:38:17,010
way the current compiler the error

00:38:14,970 --> 00:38:20,010
messages that it returns are slightly

00:38:17,010 --> 00:38:25,740
different and right now slightly less

00:38:20,010 --> 00:38:27,780
helpful I still got this same position

00:38:25,740 --> 00:38:31,500
error that made Jackie throw up his

00:38:27,780 --> 00:38:35,670
hands but I got a different error for

00:38:31,500 --> 00:38:37,770
one of the other cases I didn't talk

00:38:35,670 --> 00:38:41,070
about existential types those are going

00:38:37,770 --> 00:38:43,830
away and structural types which I also

00:38:41,070 --> 00:38:46,710
didn't talk about essentially duck

00:38:43,830 --> 00:38:48,870
typing still exists but they're

00:38:46,710 --> 00:38:51,420
implemented differently so it'll be

00:38:48,870 --> 00:38:54,180
interesting to see whether those get

00:38:51,420 --> 00:38:58,590
used more as their their new

00:38:54,180 --> 00:39:00,570
implementation is more more efficient so

00:38:58,590 --> 00:39:02,760
that's all I have you can find me on

00:39:00,570 --> 00:39:06,390
Twitter eventually all these examples

00:39:02,760 --> 00:39:08,520
will be all be up on github they

00:39:06,390 --> 00:39:11,040
probably will not be as up-to-date as

00:39:08,520 --> 00:39:13,830
the slides until after the New York

00:39:11,040 --> 00:39:15,480
version of this conference but you can

00:39:13,830 --> 00:39:17,310
look some of them are already there now

00:39:15,480 --> 00:39:21,740
and these slides will be made available

00:39:17,310 --> 00:39:21,740
as well so that's it

00:39:27,290 --> 00:39:33,600
my timer just said 45 but he told me I

00:39:30,810 --> 00:39:34,980
have five more minutes so if if I have a

00:39:33,600 --> 00:39:40,350
couple more minutes I can take a couple

00:39:34,980 --> 00:39:45,530
questions on one of your slides you

00:39:40,350 --> 00:39:48,930
mentioned that Varis require invariance

00:39:45,530 --> 00:39:52,550
with correct me if I'm wrong but I think

00:39:48,930 --> 00:39:55,980
Bart cannot do that so we can assign a

00:39:52,550 --> 00:40:00,590
covariant list to a bar it's related I

00:39:55,980 --> 00:40:05,670
think you meant the mutable collections

00:40:00,590 --> 00:40:07,620
so okay so the question is actually

00:40:05,670 --> 00:40:15,470
you're on the mic so I do I need to

00:40:07,620 --> 00:40:20,100
repeat I'm not sure so if the VAR is

00:40:15,470 --> 00:40:21,870
exposed so you can see it outside the

00:40:20,100 --> 00:40:24,630
context of your class then it has to be

00:40:21,870 --> 00:40:26,960
invariant if you use it internally if

00:40:24,630 --> 00:40:32,730
it's private to the class then yes

00:40:26,960 --> 00:40:36,440
you're right you don't have to what

00:40:32,730 --> 00:40:40,880
happens then if I assign a list of our

00:40:36,440 --> 00:40:47,330
immutable list which is covariant

00:40:40,880 --> 00:40:50,610
yes if you assign a list to a VAR y a

00:40:47,330 --> 00:40:52,710
covariant list yeah it's just you meant

00:40:50,610 --> 00:40:55,850
mutable collections it's really really

00:40:52,710 --> 00:40:55,850
it's just a typo yes

00:41:03,190 --> 00:41:16,820
so X so right I'm just trying to figure

00:41:10,160 --> 00:41:20,690
out how best to kind of answer this so I

00:41:16,820 --> 00:41:27,460
believe if we if we are going to expose

00:41:20,690 --> 00:41:33,410
the as a public member that that list

00:41:27,460 --> 00:41:34,670
that we are going to get a compiler

00:41:33,410 --> 00:41:37,240
error and I think it's going to be a

00:41:34,670 --> 00:41:41,000
compiler error that looks very much like

00:41:37,240 --> 00:41:43,700
the position error that we saw before if

00:41:41,000 --> 00:41:46,340
we have that as a private member and we

00:41:43,700 --> 00:41:50,780
will store a thing into it then we

00:41:46,340 --> 00:41:55,970
should be fine let me see if I can hop

00:41:50,780 --> 00:41:59,450
out and take a quick look in okay so I

00:41:55,970 --> 00:42:04,550
don't have an IDE up so so I'm not going

00:41:59,450 --> 00:42:09,610
to pull this up now but the problem that

00:42:04,550 --> 00:42:13,460
happens when we try to expose the

00:42:09,610 --> 00:42:15,460
mutable variable is very similar to

00:42:13,460 --> 00:42:19,010
these problems that we see with

00:42:15,460 --> 00:42:23,360
positions we're going to have the

00:42:19,010 --> 00:42:27,040
ability to try to store things into that

00:42:23,360 --> 00:42:31,550
that variable which don't match the

00:42:27,040 --> 00:42:34,990
variance of the variable right so the

00:42:31,550 --> 00:42:38,470
same problem that we have here where

00:42:34,990 --> 00:42:38,470
contravariant positions

00:42:43,950 --> 00:42:50,470
we are going to be able to construct a

00:42:47,290 --> 00:42:56,680
case very similar to this one let me

00:42:50,470 --> 00:42:59,200
pull this back up we're going to be able

00:42:56,680 --> 00:43:08,830
to construct an example very similar to

00:42:59,200 --> 00:43:12,369
this where we try to set a new value so

00:43:08,830 --> 00:43:19,450
if we had a box of cats and we tried to

00:43:12,369 --> 00:43:21,609
change that cat to some other type we

00:43:19,450 --> 00:43:25,420
could end up trying to store an animal

00:43:21,609 --> 00:43:27,339
into that cat which is not a cat okay so

00:43:25,420 --> 00:43:28,740
uh thanks for your question we can talk

00:43:27,339 --> 00:43:31,270
about this a little more afterwards

00:43:28,740 --> 00:43:35,070
thanks everyone for listening

00:43:31,270 --> 00:43:35,070

YouTube URL: https://www.youtube.com/watch?v=Oql5wIC3rmQ


