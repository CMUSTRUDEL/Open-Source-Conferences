Title: Akka Present and Future by Christopher Batey
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here: 
https://eu.scaladays.org/lect-6905-akka%3A-present-and-future.html
Captions: 
	00:00:04,610 --> 00:00:09,950
so thanks everyone for coming along to

00:00:07,250 --> 00:00:12,559
the talk my name is Christopher Beatty I

00:00:09,950 --> 00:00:14,059
work on the Acker team at light band

00:00:12,559 --> 00:00:16,219
I've been doing this for about six

00:00:14,059 --> 00:00:18,619
months which is about the right amount

00:00:16,219 --> 00:00:20,330
of time to give this talk as what I'm

00:00:18,619 --> 00:00:21,410
gonna do is talk about all the features

00:00:20,330 --> 00:00:23,630
and stuff we've been doing for the last

00:00:21,410 --> 00:00:25,670
six months and kind of look forward to

00:00:23,630 --> 00:00:26,840
the stuff that's in progress now but

00:00:25,670 --> 00:00:29,090
won't we won't be ready for the

00:00:26,840 --> 00:00:32,000
foreseeable future

00:00:29,090 --> 00:00:33,350
I'm guessing given rats Carla days and

00:00:32,000 --> 00:00:35,420
you've chosen to come to the Acker talk

00:00:33,350 --> 00:00:37,580
you know what Acker is we're going to be

00:00:35,420 --> 00:00:39,500
touching on most of it today so we've

00:00:37,580 --> 00:00:41,839
also got the core actor model I'm gonna

00:00:39,500 --> 00:00:43,909
be talking about archetypes and the

00:00:41,839 --> 00:00:46,820
changes to the API and the internals for

00:00:43,909 --> 00:00:48,920
that that has a knock-on effect on most

00:00:46,820 --> 00:00:51,229
of the rest of acha so we'll be looking

00:00:48,920 --> 00:00:53,449
at clustering are two parts of

00:00:51,229 --> 00:00:54,799
clustering we're gonna look at multi DC

00:00:53,449 --> 00:00:57,559
and we're gonna looked at some of the

00:00:54,799 --> 00:01:00,229
the typed api's we'll have a look at

00:00:57,559 --> 00:01:02,989
persistence so archetype probably has

00:01:00,229 --> 00:01:04,850
the most effect on persistence because

00:01:02,989 --> 00:01:05,900
you don't just have the the one type you

00:01:04,850 --> 00:01:07,850
don't just have the messages you're

00:01:05,900 --> 00:01:09,380
sending to actors you have the events

00:01:07,850 --> 00:01:13,030
you save and you have the state that you

00:01:09,380 --> 00:01:16,010
you build up and potentially snapshot

00:01:13,030 --> 00:01:17,540
HTTP quite interesting so I'm going to

00:01:16,010 --> 00:01:19,760
talk about something which is very very

00:01:17,540 --> 00:01:21,710
new we just released a like a preview

00:01:19,760 --> 00:01:25,190
release of it last week I believe are

00:01:21,710 --> 00:01:27,020
for running T RPC on top of ARCA HTTP so

00:01:25,190 --> 00:01:28,220
I think that's everything

00:01:27,020 --> 00:01:29,930
the reason we're going to be talking

00:01:28,220 --> 00:01:32,150
about typed it's the prototype has been

00:01:29,930 --> 00:01:33,680
around for quite some time but the over

00:01:32,150 --> 00:01:35,420
the last say three months what we've

00:01:33,680 --> 00:01:37,610
tried to do is get it to the point where

00:01:35,420 --> 00:01:39,050
we'd call it production ready and we'd

00:01:37,610 --> 00:01:40,520
be happy for people to start you know

00:01:39,050 --> 00:01:42,580
building their regular actor stuff with

00:01:40,520 --> 00:01:45,950
it typed rather than rather than untyped

00:01:42,580 --> 00:01:47,659
the multi DC stuff that is probably the

00:01:45,950 --> 00:01:49,400
oldest feature I'm gonna talk about so

00:01:47,659 --> 00:01:50,210
that's ready to use it's in a release

00:01:49,400 --> 00:01:52,970
version of akka

00:01:50,210 --> 00:01:54,800
G RPC as I said is very new so I'll show

00:01:52,970 --> 00:01:57,470
you how that works how you can you can

00:01:54,800 --> 00:02:00,920
program using ARCA streams r4g RPC and

00:01:57,470 --> 00:02:02,780
use rkh TTP is the underlying HTTP 204

00:02:00,920 --> 00:02:04,520
that I one thing I missed out in the

00:02:02,780 --> 00:02:07,250
previous slide was are we are we talking

00:02:04,520 --> 00:02:09,979
about archery artery is the the newer

00:02:07,250 --> 00:02:11,900
version of remoting and it's always been

00:02:09,979 --> 00:02:14,300
it's currently been udp-based but we've

00:02:11,900 --> 00:02:16,130
just released a TCP based version which

00:02:14,300 --> 00:02:18,080
also has TLS which is what a lot of

00:02:16,130 --> 00:02:18,630
people have been asking for and I'll

00:02:18,080 --> 00:02:20,400
briefly

00:02:18,630 --> 00:02:21,840
talk about stream rafts which is taking

00:02:20,400 --> 00:02:23,370
akka streams I'm being able to

00:02:21,840 --> 00:02:25,050
materialize them on it on it on a

00:02:23,370 --> 00:02:26,910
different computer inside a different

00:02:25,050 --> 00:02:28,920
actor system so you can get the benefits

00:02:26,910 --> 00:02:31,320
of flow control and reactive streams but

00:02:28,920 --> 00:02:35,370
between servers rather than just on the

00:02:31,320 --> 00:02:37,080
single server so first topic archetype

00:02:35,370 --> 00:02:39,750
so who has played with the archetype

00:02:37,080 --> 00:02:41,540
TPI's of the last year or two a few who

00:02:39,750 --> 00:02:43,800
has anyone running it in production now

00:02:41,540 --> 00:02:45,570
last time like I only don't know one

00:02:43,800 --> 00:02:47,070
talk previously on archetypes and his

00:02:45,570 --> 00:02:48,780
company had said all were using it in

00:02:47,070 --> 00:02:50,460
production however we'd change most of

00:02:48,780 --> 00:02:52,680
it unfortunately so I could type

00:02:50,460 --> 00:02:55,380
prototype has been around for quite some

00:02:52,680 --> 00:02:58,410
time and it was made up of two things it

00:02:55,380 --> 00:02:59,340
was a the underlying runtime had changed

00:02:58,410 --> 00:03:01,110
so there was there was a new

00:02:59,340 --> 00:03:03,120
implementation of the of the actor

00:03:01,110 --> 00:03:05,040
system and then there's a completely

00:03:03,120 --> 00:03:06,780
different API which is unsurprisingly

00:03:05,040 --> 00:03:09,240
more types than the previous one

00:03:06,780 --> 00:03:10,800
all right so that we can make it

00:03:09,240 --> 00:03:12,390
production ready and recommend that you

00:03:10,800 --> 00:03:14,730
use it rather than that the regular

00:03:12,390 --> 00:03:17,790
untyped actor API what we've actually

00:03:14,730 --> 00:03:19,920
done is remove the new runtime ah which

00:03:17,790 --> 00:03:22,650
means that you only run archetype on

00:03:19,920 --> 00:03:25,050
your regular actor system there is a new

00:03:22,650 --> 00:03:26,760
thin wrapper so you interact with it in

00:03:25,050 --> 00:03:28,830
a different way and I'll show you that

00:03:26,760 --> 00:03:30,390
today ah but the goal is and actually

00:03:28,830 --> 00:03:33,690
releases of our code to say yep this is

00:03:30,390 --> 00:03:35,310
ready to go we'll probably leave API may

00:03:33,690 --> 00:03:36,780
change on it but the actual quality

00:03:35,310 --> 00:03:40,860
acceptor should be there for you to be

00:03:36,780 --> 00:03:42,480
confident to run it in production so I'm

00:03:40,860 --> 00:03:44,040
gonna start off with an untyped actor

00:03:42,480 --> 00:03:46,230
show you it in a couple of different

00:03:44,040 --> 00:03:47,850
ways of doing it on show how that

00:03:46,230 --> 00:03:49,710
relates to the to the new archetypes

00:03:47,850 --> 00:03:51,900
api's and I'm gonna do it by doing

00:03:49,710 --> 00:03:54,630
something quite ridiculous which is to

00:03:51,900 --> 00:03:56,820
build a distributed lock with a key so

00:03:54,630 --> 00:03:59,070
when you're doing on type darker you can

00:03:56,820 --> 00:04:00,690
obviously send any message to it and a

00:03:59,070 --> 00:04:02,970
good practice would be to still

00:04:00,690 --> 00:04:05,040
represent the incoming messages as a

00:04:02,970 --> 00:04:06,960
sealed hierarchy and maybe the same for

00:04:05,040 --> 00:04:09,180
the response messages so maybe very

00:04:06,960 --> 00:04:10,800
simplistic distributed lock or lock

00:04:09,180 --> 00:04:12,360
would be to say I want to be able to

00:04:10,800 --> 00:04:14,370
lock it and I want to be able to unlock

00:04:12,360 --> 00:04:15,690
it and if I ask to lock it I'll get

00:04:14,370 --> 00:04:17,760
something back saying yep you've been

00:04:15,690 --> 00:04:19,890
granted or I'm sorry some other actors

00:04:17,760 --> 00:04:21,960
got this lock and one way of achieving

00:04:19,890 --> 00:04:24,000
that inside untyped locker would be to

00:04:21,960 --> 00:04:26,669
use some good old mutable state which

00:04:24,000 --> 00:04:27,720
some people might not like and what

00:04:26,669 --> 00:04:29,550
we're essentially doing here is

00:04:27,720 --> 00:04:31,200
representing a kind of state machine but

00:04:29,550 --> 00:04:32,580
where the state is inferred from the

00:04:31,200 --> 00:04:33,990
mutable variables

00:04:32,580 --> 00:04:35,820
so some people even in this very

00:04:33,990 --> 00:04:37,590
simplistic example it can become

00:04:35,820 --> 00:04:39,420
confusing you look you kind of try to

00:04:37,590 --> 00:04:41,580
reason about it and you think oh if if

00:04:39,420 --> 00:04:43,980
the owner of it's taken I can kind of

00:04:41,580 --> 00:04:45,720
accept these messages if it's not taken

00:04:43,980 --> 00:04:46,980
maybe I can accept these messages and I

00:04:45,720 --> 00:04:47,700
think this is this is pretty hard to

00:04:46,980 --> 00:04:50,190
reason about

00:04:47,700 --> 00:04:51,720
so my background coming from an Okie

00:04:50,190 --> 00:04:53,610
user rather than someone working on the

00:04:51,720 --> 00:04:55,410
ARCA team I would probably prefer to

00:04:53,610 --> 00:04:58,020
explicitly represent the states as

00:04:55,410 --> 00:05:00,060
different partial functions so one for

00:04:58,020 --> 00:05:01,980
unlocked and one for locked and then I

00:05:00,060 --> 00:05:03,870
can very explicitly see in the top here

00:05:01,980 --> 00:05:05,940
that if I'm in the unlock state then yep

00:05:03,870 --> 00:05:07,890
I accept the lock message if I'm in the

00:05:05,940 --> 00:05:09,870
the unlock state I accept the lock

00:05:07,890 --> 00:05:11,580
message or if I'm in the lock state then

00:05:09,870 --> 00:05:13,200
I can accept both and I tell people no

00:05:11,580 --> 00:05:15,870
you can't have this and then we use

00:05:13,200 --> 00:05:18,570
become to change behavior after

00:05:15,870 --> 00:05:20,160
receiving a message but you notice one

00:05:18,570 --> 00:05:21,720
of the section see we didn't do it

00:05:20,160 --> 00:05:24,600
become which is fine right you can

00:05:21,720 --> 00:05:27,090
remain remain the same behavior so what

00:05:24,600 --> 00:05:30,240
would this look like if we were to do

00:05:27,090 --> 00:05:31,680
this in archetypes well unsurprisingly

00:05:30,240 --> 00:05:33,330
we end up with a type parameter we're

00:05:31,680 --> 00:05:36,510
not going to be extending any classes or

00:05:33,330 --> 00:05:38,640
input or using traits here we this

00:05:36,510 --> 00:05:40,890
implementation here made quite a bit of

00:05:38,640 --> 00:05:42,570
use of the sender right the implicit

00:05:40,890 --> 00:05:44,640
kind of the function that you get this

00:05:42,570 --> 00:05:46,530
magic sender so you can send back to and

00:05:44,640 --> 00:05:48,630
if we were to look at our protocol even

00:05:46,530 --> 00:05:50,010
though we were saying we're gonna lock

00:05:48,630 --> 00:05:53,010
the message we weren't saying who we

00:05:50,010 --> 00:05:55,140
were so in a cur typed you have to be

00:05:53,010 --> 00:05:56,820
far more explicit about this because the

00:05:55,140 --> 00:05:58,920
the sender for instance what type would

00:05:56,820 --> 00:06:00,660
it be there's nothing forcing you and

00:05:58,920 --> 00:06:03,200
archetypes that even though you know

00:06:00,660 --> 00:06:05,790
what type you receive there's nothing -

00:06:03,200 --> 00:06:07,220
there's no way to know what the type of

00:06:05,790 --> 00:06:11,580
the actor is that sent you the message

00:06:07,220 --> 00:06:12,960
so there's a bit more explicitness when

00:06:11,580 --> 00:06:15,450
dealing with with requests for it

00:06:12,960 --> 00:06:16,860
request response protocols the other

00:06:15,450 --> 00:06:19,350
thing that's gone away and I'm going to

00:06:16,860 --> 00:06:21,630
show the the alternative is that you

00:06:19,350 --> 00:06:23,070
can't use actor selection so this was a

00:06:21,630 --> 00:06:24,300
way of taking an actor path and then

00:06:23,070 --> 00:06:26,370
getting an actor reference and then

00:06:24,300 --> 00:06:28,680
sending whatever message you like to it

00:06:26,370 --> 00:06:30,300
but again there's no real way to do that

00:06:28,680 --> 00:06:32,640
if you're going to be typed about

00:06:30,300 --> 00:06:35,550
message interactions are if you're

00:06:32,640 --> 00:06:36,840
without some unsafe custom so if we

00:06:35,550 --> 00:06:39,840
remind ourselves under mentally what an

00:06:36,840 --> 00:06:41,820
actor is when we receive a message we

00:06:39,840 --> 00:06:43,440
can do one of three things we can we can

00:06:41,820 --> 00:06:45,690
send messages to other actors that we

00:06:43,440 --> 00:06:46,449
already have the the references for we

00:06:45,690 --> 00:06:48,550
could send message

00:06:46,449 --> 00:06:50,259
is to actors where the after reference

00:06:48,550 --> 00:06:52,419
is inside the message which is which is

00:06:50,259 --> 00:06:54,430
quite common we can spawn some children

00:06:52,419 --> 00:06:56,770
and create some kind of party or we can

00:06:54,430 --> 00:06:58,629
change our behavior and we implicitly

00:06:56,770 --> 00:07:02,469
change behavior before we've become or

00:06:58,629 --> 00:07:03,849
by mutating some some some variable so

00:07:02,469 --> 00:07:05,800
what would this look like in archetypes

00:07:03,849 --> 00:07:07,210
well the protocol has to change slightly

00:07:05,800 --> 00:07:09,879
because if we're going to communicate

00:07:07,210 --> 00:07:11,199
with some actor and we want a response

00:07:09,879 --> 00:07:12,879
from it what we're going to have to do

00:07:11,199 --> 00:07:13,960
is send in a reference so they can

00:07:12,879 --> 00:07:17,529
respond to me

00:07:13,960 --> 00:07:19,870
so both lock and unlock end up with an

00:07:17,529 --> 00:07:21,550
actor reference inside so the lock actor

00:07:19,870 --> 00:07:24,490
can can say yep you've got the lock or

00:07:21,550 --> 00:07:26,349
you don't have the lock to show some of

00:07:24,490 --> 00:07:28,330
the more complex features of akka typed

00:07:26,349 --> 00:07:30,550
I've extended their response protocol so

00:07:28,330 --> 00:07:31,990
we have granted and we're just going to

00:07:30,550 --> 00:07:34,689
do that we're just gonna say it granted

00:07:31,990 --> 00:07:36,909
the taken that still takes an an actor

00:07:34,689 --> 00:07:38,499
reference because we had that before and

00:07:36,909 --> 00:07:40,479
I've added a couple of message and just

00:07:38,499 --> 00:07:41,860
say that the it's been released or it's

00:07:40,479 --> 00:07:45,879
bit or the unlock has failed for some

00:07:41,860 --> 00:07:48,939
reason when unlocking so let's see how

00:07:45,879 --> 00:07:50,289
that looks like in archetypes so you for

00:07:48,939 --> 00:07:51,789
each of those things which you would

00:07:50,289 --> 00:07:53,379
normally create a separate partial

00:07:51,789 --> 00:07:55,089
function for if you were doing untyped

00:07:53,379 --> 00:07:57,069
actor but you were following the kind of

00:07:55,089 --> 00:07:58,810
paradigm the guideline or using become

00:07:57,069 --> 00:08:00,639
and switching between states if you

00:07:58,810 --> 00:08:02,919
weren't using FSM then you create

00:08:00,639 --> 00:08:04,389
something called a behavior and there's

00:08:02,919 --> 00:08:05,770
a factory for creating these behaviors

00:08:04,389 --> 00:08:09,189
but they're they're essentially

00:08:05,770 --> 00:08:11,379
functions which go from a the actors

00:08:09,189 --> 00:08:13,300
protocol so the message that the actor

00:08:11,379 --> 00:08:16,599
reference is typed to to the next

00:08:13,300 --> 00:08:18,639
behavior so before when we were kind of

00:08:16,599 --> 00:08:20,379
doing that with become but in this

00:08:18,639 --> 00:08:21,789
example we have to explicitly do this

00:08:20,379 --> 00:08:23,560
because we are actually providing a

00:08:21,789 --> 00:08:25,120
function here which needs to return a

00:08:23,560 --> 00:08:27,759
new behavior that needs to be of the

00:08:25,120 --> 00:08:30,459
same type so if we were to look at the

00:08:27,759 --> 00:08:32,110
case of being locked and we were to

00:08:30,459 --> 00:08:34,389
someone else were to try and get the

00:08:32,110 --> 00:08:36,039
lock we'd send back saying that I'm

00:08:34,389 --> 00:08:37,839
sorry it's taken but we'd end up with

00:08:36,039 --> 00:08:39,659
the same behavior so there's a factory

00:08:37,839 --> 00:08:43,120
method for that so that's the top gate

00:08:39,659 --> 00:08:45,579
however if we were to get the unlock

00:08:43,120 --> 00:08:47,529
then we would need to become unlocked

00:08:45,579 --> 00:08:49,269
and we return a new behavior and that

00:08:47,529 --> 00:08:50,649
can be a value or that can be a function

00:08:49,269 --> 00:08:54,060
I can be a method with where you're

00:08:50,649 --> 00:08:57,010
storing statements inside the start so

00:08:54,060 --> 00:08:58,360
the top one is a function it's not a

00:08:57,010 --> 00:08:59,949
partial function so you'll get the

00:08:58,360 --> 00:09:01,569
appropriate compiler warning if you

00:08:59,949 --> 00:09:04,240
decide to miss out some of that some of

00:09:01,569 --> 00:09:06,430
that a type hierarchy whereas the

00:09:04,240 --> 00:09:08,010
unlocked one we want to ignore some

00:09:06,430 --> 00:09:10,269
messages so there's also

00:09:08,010 --> 00:09:11,620
factory methods that will accept path

00:09:10,269 --> 00:09:13,209
partial functions you're essentially

00:09:11,620 --> 00:09:15,699
saying you don't handle handle the other

00:09:13,209 --> 00:09:18,160
messages these are quite simplistic and

00:09:15,699 --> 00:09:19,630
we'll see some more complex one soon but

00:09:18,160 --> 00:09:21,370
there are also a set of factories where

00:09:19,630 --> 00:09:23,260
you get hold of the actor context as

00:09:21,370 --> 00:09:25,089
well so here these are completely

00:09:23,260 --> 00:09:26,800
contained by the messages coming in and

00:09:25,089 --> 00:09:27,819
the message you want to send back but

00:09:26,800 --> 00:09:29,980
often if you want to do things like

00:09:27,819 --> 00:09:31,720
spawn children or or or do other things

00:09:29,980 --> 00:09:35,319
like timers then you're gonna need an

00:09:31,720 --> 00:09:36,760
actor context no the next thing I want

00:09:35,319 --> 00:09:37,779
to see you imagine that we start off

00:09:36,760 --> 00:09:39,519
this actor which is going to be a

00:09:37,779 --> 00:09:41,920
distributed lock and if we have a

00:09:39,519 --> 00:09:43,990
reference to the actor then we can just

00:09:41,920 --> 00:09:45,250
pass it in while creating other ones but

00:09:43,990 --> 00:09:47,380
I'm gonna assume we're running in some

00:09:45,250 --> 00:09:49,480
type of clustered environments where you

00:09:47,380 --> 00:09:51,640
want to look up the a particular lock

00:09:49,480 --> 00:09:52,870
and previously you might use

00:09:51,640 --> 00:09:54,899
actor selection for that and you might

00:09:52,870 --> 00:09:57,279
identify and you might see if it exists

00:09:54,899 --> 00:10:00,040
in archetypes we want to be able to do

00:09:57,279 --> 00:10:01,990
this in a type safe way so locally

00:10:00,040 --> 00:10:03,640
within a single JVM the API is the same

00:10:01,990 --> 00:10:06,189
or whether you're running inside an aqua

00:10:03,640 --> 00:10:07,569
cluster there's a service discovery for

00:10:06,189 --> 00:10:09,490
typed actors it's called the

00:10:07,569 --> 00:10:11,529
receptionist and that's something which

00:10:09,490 --> 00:10:13,029
is on the actor system so if you have an

00:10:11,529 --> 00:10:15,240
active context you can always get hold

00:10:13,029 --> 00:10:18,640
of the receptionist and you can register

00:10:15,240 --> 00:10:21,880
so you can say I'm of type X with name Y

00:10:18,640 --> 00:10:23,410
and other areas of your code which need

00:10:21,880 --> 00:10:25,029
to look this up which where it can't be

00:10:23,410 --> 00:10:27,010
done but by you know just passing it up

00:10:25,029 --> 00:10:29,589
passing in a reference they can either

00:10:27,010 --> 00:10:32,500
find a particular type doctor or they

00:10:29,589 --> 00:10:34,990
can subscribe and get updates when you

00:10:32,500 --> 00:10:37,180
know new instances of the actor are

00:10:34,990 --> 00:10:40,949
created and registered or whether one of

00:10:37,180 --> 00:10:43,839
them dies and it's removed so the

00:10:40,949 --> 00:10:46,360
receptionist itself is a typed actor so

00:10:43,839 --> 00:10:48,459
you interact with it with messages a

00:10:46,360 --> 00:10:50,800
very simplified version of the protocol

00:10:48,459 --> 00:10:52,899
would look like this you can either find

00:10:50,800 --> 00:10:54,910
which gets you a one shot please tell me

00:10:52,899 --> 00:10:56,920
if there's any existing right now or you

00:10:54,910 --> 00:10:59,500
so can subscribe and what you get back

00:10:56,920 --> 00:11:01,870
is a listing of of after references

00:10:59,500 --> 00:11:04,050
which then you can communicate with so

00:11:01,870 --> 00:11:06,490
let's see how we'd use the receptionist

00:11:04,050 --> 00:11:08,529
so in this example

00:11:06,490 --> 00:11:10,630
we're not just creating a behavior we're

00:11:08,529 --> 00:11:12,160
actually creating it's using a factory

00:11:10,630 --> 00:11:15,160
to create behavior and it's called setup

00:11:12,160 --> 00:11:17,020
and the difference here is you first get

00:11:15,160 --> 00:11:19,149
hold of an actor context so the type of

00:11:17,020 --> 00:11:21,610
this the context on on the right there

00:11:19,149 --> 00:11:24,100
is an actor context and we can use it to

00:11:21,610 --> 00:11:26,680
spawn so I'm spawning one of my unlocked

00:11:24,100 --> 00:11:28,240
actors with name lock a and then I can

00:11:26,680 --> 00:11:30,220
register it with the receptionist and

00:11:28,240 --> 00:11:32,560
the receptionist is only going to accept

00:11:30,220 --> 00:11:36,100
messages of its command which in this

00:11:32,560 --> 00:11:38,290
case is is register once I've done my

00:11:36,100 --> 00:11:40,180
setup then what I need to do is return

00:11:38,290 --> 00:11:41,680
the next behavior the behavior that's

00:11:40,180 --> 00:11:43,570
going to process the first message for

00:11:41,680 --> 00:11:47,140
this actor in this example it's in a

00:11:43,570 --> 00:11:48,550
function call needs lock instance Before

00:11:47,140 --> 00:11:50,170
we jump into that I want to talk about

00:11:48,550 --> 00:11:52,600
ask because we're going to use asking

00:11:50,170 --> 00:11:54,880
that in the next one so one of the

00:11:52,600 --> 00:11:56,740
problems with occur typed is when you

00:11:54,880 --> 00:11:58,779
interact with other actors and you're

00:11:56,740 --> 00:12:01,089
expecting a response back and the

00:11:58,779 --> 00:12:03,880
example here is the receptionist now

00:12:01,089 --> 00:12:05,649
it's very unlikely that your type is

00:12:03,880 --> 00:12:07,420
going to be the type of message which

00:12:05,649 --> 00:12:10,570
the receptionist is going to send back

00:12:07,420 --> 00:12:12,610
to you and that makes sense so there's a

00:12:10,570 --> 00:12:14,500
set of helpers and functions which are

00:12:12,610 --> 00:12:16,540
going to enable it easier to interact

00:12:14,500 --> 00:12:19,149
with typed actors and one of them is the

00:12:16,540 --> 00:12:21,760
ask button when you're an actor asking a

00:12:19,149 --> 00:12:24,160
question of another actor and what you

00:12:21,760 --> 00:12:25,540
do here is you pass in the actor

00:12:24,160 --> 00:12:28,390
reference so in this example it's the

00:12:25,540 --> 00:12:30,730
the receptionist you pass in then a

00:12:28,390 --> 00:12:33,820
function to create the message that you

00:12:30,730 --> 00:12:35,950
want to send to that actor and then

00:12:33,820 --> 00:12:39,940
finally you pass in a function which

00:12:35,950 --> 00:12:42,579
deals with the response so the idea here

00:12:39,940 --> 00:12:44,829
is that you want to turn the protocol of

00:12:42,579 --> 00:12:47,380
the art of the other actor in this case

00:12:44,829 --> 00:12:49,060
the receptionist back into your protocol

00:12:47,380 --> 00:12:51,910
so you can actually receive the the

00:12:49,060 --> 00:12:54,130
message in this case we basically say if

00:12:51,910 --> 00:12:56,529
it's successful in this case it will

00:12:54,130 --> 00:12:58,660
deal with things like timeouts and we

00:12:56,529 --> 00:13:00,310
have a listing then we're going to send

00:12:58,660 --> 00:13:02,290
the lock actor is available to ourselves

00:13:00,310 --> 00:13:04,360
and that's of our protocol that want

00:13:02,290 --> 00:13:07,779
that one will type check otherwise we

00:13:04,360 --> 00:13:09,339
send lock not available what do we do in

00:13:07,779 --> 00:13:11,680
this case so well the first thing we

00:13:09,339 --> 00:13:13,300
need to do is ask for a actor reference

00:13:11,680 --> 00:13:14,680
we need to find a lock and in this

00:13:13,300 --> 00:13:16,900
example it's the same code as in the

00:13:14,680 --> 00:13:19,060
previous slide we basically ask the

00:13:16,900 --> 00:13:20,420
receptionist in a setup method can you

00:13:19,060 --> 00:13:24,399
please find me the lock

00:13:20,420 --> 00:13:26,209
and then what we do is because that

00:13:24,399 --> 00:13:27,620
response that's come back from the

00:13:26,209 --> 00:13:29,839
receptionist has been mapped into our

00:13:27,620 --> 00:13:32,060
protocol then we deal with it so we can

00:13:29,839 --> 00:13:33,620
either say the lock actor is available

00:13:32,060 --> 00:13:36,260
in that case we ask it for the lock

00:13:33,620 --> 00:13:37,610
otherwise if the lock was not available

00:13:36,260 --> 00:13:40,100
maybe it's crashed maybe no one's

00:13:37,610 --> 00:13:42,110
registered it then we can do behavior

00:13:40,100 --> 00:13:45,890
stopped and at that point the actor the

00:13:42,110 --> 00:13:47,690
actor will shut down one of the other

00:13:45,890 --> 00:13:49,519
differences with archetype dizzy your

00:13:47,690 --> 00:13:50,870
actual actor system is an actor

00:13:49,519 --> 00:13:53,450
reference so you actually have a top

00:13:50,870 --> 00:13:55,519
level behavior so this I could take this

00:13:53,450 --> 00:13:57,709
to I could type this to actor system or

00:13:55,519 --> 00:13:59,630
of a actor reference and they can start

00:13:57,709 --> 00:14:03,050
interacting with it and it's very common

00:13:59,630 --> 00:14:04,310
for your top level to be a setup where

00:14:03,050 --> 00:14:06,980
you initially kick off your initial

00:14:04,310 --> 00:14:08,300
actors exception so that's kind of like

00:14:06,980 --> 00:14:10,579
the whirlwind tour of what the

00:14:08,300 --> 00:14:12,260
archetypes API looks like you'll you'll

00:14:10,579 --> 00:14:14,570
say goodbye to sender you'll start to

00:14:12,260 --> 00:14:16,010
deal with a bit more complexity when

00:14:14,570 --> 00:14:18,320
you're interacting because you can't

00:14:16,010 --> 00:14:20,120
just sneak Lee except another another

00:14:18,320 --> 00:14:22,610
message type which could be from some

00:14:20,120 --> 00:14:23,870
receptionist thing the other thing I

00:14:22,610 --> 00:14:25,449
want to have a quick run-through is if

00:14:23,870 --> 00:14:27,920
if how this has changed persistence

00:14:25,449 --> 00:14:29,690
because if you've not used persistence

00:14:27,920 --> 00:14:31,490
before in occur it is a way to do event

00:14:29,690 --> 00:14:33,199
sourcing so you take in messages so you

00:14:31,490 --> 00:14:34,490
you're dealing with a regular actor but

00:14:33,199 --> 00:14:36,769
this time we normally refer to those

00:14:34,490 --> 00:14:38,480
messages as commands you do some stuff

00:14:36,769 --> 00:14:40,360
you validate it and you decide what

00:14:38,480 --> 00:14:42,829
events you want to persist based on it

00:14:40,360 --> 00:14:44,120
and once you end up with million event

00:14:42,829 --> 00:14:45,589
millions and millions of events you

00:14:44,120 --> 00:14:47,149
might end up snapshotting so you don't

00:14:45,589 --> 00:14:51,110
need to replay and build up your state

00:14:47,149 --> 00:14:53,390
back each time and it's very explicit in

00:14:51,110 --> 00:14:54,680
archetype for that so this is a very

00:14:53,390 --> 00:14:56,360
simplistic silly version but it

00:14:54,680 --> 00:14:57,829
essentially it's we have three types we

00:14:56,360 --> 00:14:59,720
have commands events and states they can

00:14:57,829 --> 00:15:01,100
be whatever type you like the commands

00:14:59,720 --> 00:15:03,320
and vents were typically some kind of

00:15:01,100 --> 00:15:04,699
hierarchy of types and then what we have

00:15:03,320 --> 00:15:07,010
is another factory for creating

00:15:04,699 --> 00:15:08,720
persistent behaviors so the persistent

00:15:07,010 --> 00:15:11,120
behavior factory that takes in a

00:15:08,720 --> 00:15:12,620
persistence ID it takes in initial

00:15:11,120 --> 00:15:14,690
states and then it takes in two

00:15:12,620 --> 00:15:16,910
functions the first function is the

00:15:14,690 --> 00:15:19,279
equivalent to your receive method on a

00:15:16,910 --> 00:15:21,050
regular typed actor except this time you

00:15:19,279 --> 00:15:25,040
do get the state as well as the message

00:15:21,050 --> 00:15:26,360
and the context and then as part of that

00:15:25,040 --> 00:15:27,709
command handler what you do is you

00:15:26,360 --> 00:15:29,480
decide which events that you want to

00:15:27,709 --> 00:15:32,839
persist and then that's passed into your

00:15:29,480 --> 00:15:34,370
event into your event handler so what

00:15:32,839 --> 00:15:36,410
does a command handler look like well

00:15:34,370 --> 00:15:38,300
it's a function which takes a command an

00:15:36,410 --> 00:15:40,100
estate and a context and you have to

00:15:38,300 --> 00:15:42,410
produce something called an effect now

00:15:40,100 --> 00:15:44,630
an effect can be to stop you could

00:15:42,410 --> 00:15:46,550
ignore the command maybe it's not valid

00:15:44,630 --> 00:15:48,860
maybe in your current state it isn't

00:15:46,550 --> 00:15:51,560
valid or you can persist one or you can

00:15:48,860 --> 00:15:52,730
persist many events and that's all you

00:15:51,560 --> 00:15:55,430
need to provide for that and that's just

00:15:52,730 --> 00:15:57,500
that's just a function the other is the

00:15:55,430 --> 00:15:59,029
event handler so every time you get you

00:15:57,500 --> 00:16:01,670
produced an event from a command handler

00:15:59,029 --> 00:16:03,350
it comes in and then essentially you

00:16:01,670 --> 00:16:05,810
need to produce a new state based based

00:16:03,350 --> 00:16:07,910
on that event so it's a lot more

00:16:05,810 --> 00:16:09,800
explicit than the old version and it

00:16:07,910 --> 00:16:12,110
allows us as a library to do more things

00:16:09,800 --> 00:16:13,940
for you previously we didn't really know

00:16:12,110 --> 00:16:15,110
that if you had a state if you were and

00:16:13,940 --> 00:16:16,550
so if you wanted to snapshot that's

00:16:15,110 --> 00:16:18,110
something you would decide and you would

00:16:16,550 --> 00:16:19,370
call a method called snapshot and that

00:16:18,110 --> 00:16:21,350
could be any type you like as long as

00:16:19,370 --> 00:16:23,420
you had a sterilizer for it now it's

00:16:21,350 --> 00:16:24,890
very easiest easy for us to say okay

00:16:23,420 --> 00:16:26,839
because we know about the state and we

00:16:24,890 --> 00:16:28,250
know say there's a sterilizer for it we

00:16:26,839 --> 00:16:31,190
could you could easily just tell us to

00:16:28,250 --> 00:16:32,630
snapshot at every hundred events we can

00:16:31,190 --> 00:16:33,770
also make things like event adapters

00:16:32,630 --> 00:16:36,200
which we're working on right now they

00:16:33,770 --> 00:16:37,880
could be more typesafe and tagging

00:16:36,200 --> 00:16:39,589
becomes easier it's very common to tug

00:16:37,880 --> 00:16:41,480
events in these styles of systems so you

00:16:39,589 --> 00:16:43,490
can query them different ways on on the

00:16:41,480 --> 00:16:45,529
read side previously that would have

00:16:43,490 --> 00:16:48,170
been done inside your persistent actor

00:16:45,529 --> 00:16:50,420
by wrapping it in a tagged case class or

00:16:48,170 --> 00:16:52,040
with an event adapter whereas another

00:16:50,420 --> 00:16:53,240
thing on the Builder for a persistent

00:16:52,040 --> 00:16:56,140
behavior is just to say here's a

00:16:53,240 --> 00:16:58,370
function from from event to set of

00:16:56,140 --> 00:17:01,190
tagless and then we'll we'll persist

00:16:58,370 --> 00:17:02,930
that persist attacks for you so that's

00:17:01,190 --> 00:17:04,550
about it that's the type section a few

00:17:02,930 --> 00:17:06,050
things which I haven't covered but

00:17:04,550 --> 00:17:07,520
there's a talk later in the day by hiker

00:17:06,050 --> 00:17:09,589
which I imagine will cover more of this

00:17:07,520 --> 00:17:11,510
stuff are the first I think is most

00:17:09,589 --> 00:17:13,579
important is coexistence so how would

00:17:11,510 --> 00:17:17,089
you migrate over to using a typed rather

00:17:13,579 --> 00:17:18,980
than untyped so you can you can you can

00:17:17,089 --> 00:17:20,929
create typed you can adapt between the

00:17:18,980 --> 00:17:23,120
two systems you can create typed actors

00:17:20,929 --> 00:17:26,480
from a none type system and vice-versa

00:17:23,120 --> 00:17:28,280
so they work really well together our

00:17:26,480 --> 00:17:29,990
other life cycle events which you

00:17:28,280 --> 00:17:32,480
typically override a method for in the

00:17:29,990 --> 00:17:35,000
in the actor trait that's that's another

00:17:32,480 --> 00:17:35,900
handler so signals like whether you've

00:17:35,000 --> 00:17:37,370
been weather you get things like

00:17:35,900 --> 00:17:38,960
terminated and you want to be notified

00:17:37,370 --> 00:17:41,690
of starting and stopping and things so

00:17:38,960 --> 00:17:43,340
you can still do that we have some new

00:17:41,690 --> 00:17:45,679
test kits which very much more

00:17:43,340 --> 00:17:47,750
explicitly distinguished between async

00:17:45,679 --> 00:17:48,260
testing and synchronous testing because

00:17:47,750 --> 00:17:50,810
behaviors

00:17:48,260 --> 00:17:52,820
just our functions then all the time you

00:17:50,810 --> 00:17:55,130
can't just test them synchronously more

00:17:52,820 --> 00:17:56,840
easily it gets a bit tricky if you start

00:17:55,130 --> 00:17:59,210
kicking off async events and things but

00:17:56,840 --> 00:18:01,070
it's still a lot of times it works and

00:17:59,210 --> 00:18:02,180
there's a few anytime which you were

00:18:01,070 --> 00:18:03,560
dealing with an actor referencing

00:18:02,180 --> 00:18:06,050
streams there's a there's an equivalent

00:18:03,560 --> 00:18:10,010
module now for 4 type streams but that's

00:18:06,050 --> 00:18:14,510
very minimal alright so the next thing

00:18:10,010 --> 00:18:16,160
is multi DC so simply put multi DC which

00:18:14,510 --> 00:18:18,410
was the oldest features this has been

00:18:16,160 --> 00:18:21,920
around for six months or so is running a

00:18:18,410 --> 00:18:24,590
cluster across data centers now there is

00:18:21,920 --> 00:18:27,080
nothing stopping you from running

00:18:24,590 --> 00:18:29,720
anarchic Laster across two data centers

00:18:27,080 --> 00:18:31,190
if that's what you want to do but the

00:18:29,720 --> 00:18:33,770
all the things which happen internally

00:18:31,190 --> 00:18:36,350
with inside cluster so gossiping and

00:18:33,770 --> 00:18:37,940
membership decisions etc they all

00:18:36,350 --> 00:18:39,800
wouldn't take into account that cert the

00:18:37,940 --> 00:18:43,760
latency between certain nodes would be

00:18:39,800 --> 00:18:45,350
higher and the way that our cluster

00:18:43,760 --> 00:18:47,060
works where things like membership

00:18:45,350 --> 00:18:49,850
decisions and things are not made if

00:18:47,060 --> 00:18:51,560
there are network partitions etc it's

00:18:49,850 --> 00:18:53,510
obviously more likely to have a network

00:18:51,560 --> 00:18:54,920
partition or another data center down

00:18:53,510 --> 00:18:57,700
when you're dealing with you know

00:18:54,920 --> 00:19:00,530
geographically just distinct locations

00:18:57,700 --> 00:19:01,760
so I'll just go through the kind of

00:19:00,530 --> 00:19:02,930
decisions that were made and I think

00:19:01,760 --> 00:19:04,490
most of the decisions that have been

00:19:02,930 --> 00:19:07,280
made I think from my point of view are

00:19:04,490 --> 00:19:09,950
to expect the other data center to be

00:19:07,280 --> 00:19:12,200
down or expect there to be some kind of

00:19:09,950 --> 00:19:13,760
partition because if you're running

00:19:12,200 --> 00:19:15,140
across multiple data centers my

00:19:13,760 --> 00:19:17,330
assumption is you're doing it because

00:19:15,140 --> 00:19:19,190
either for fault tolerance so you

00:19:17,330 --> 00:19:21,290
actually want to be able to handle a a

00:19:19,190 --> 00:19:23,810
catastrophic outage of a particular data

00:19:21,290 --> 00:19:28,160
center or someone tripping on a wire or

00:19:23,810 --> 00:19:29,780
data locality with customers so things

00:19:28,160 --> 00:19:31,550
like membership management that's all

00:19:29,780 --> 00:19:33,170
done local within a data center so you

00:19:31,550 --> 00:19:34,880
have a leader per data center and it

00:19:33,170 --> 00:19:37,130
will make the decisions so if you if you

00:19:34,880 --> 00:19:39,200
have a network split in between two of

00:19:37,130 --> 00:19:41,240
your data centers data center a on one

00:19:39,200 --> 00:19:43,880
side can store add members acceptor and

00:19:41,240 --> 00:19:45,380
make decisions on that single didson

00:19:43,880 --> 00:19:47,090
charting so I'm going to sneak in some

00:19:45,380 --> 00:19:48,620
more type stuff when I show you the API

00:19:47,090 --> 00:19:51,170
for this because every time I show you

00:19:48,620 --> 00:19:54,140
examples I'll use the typed API rather

00:19:51,170 --> 00:19:55,880
than the the untyped one so across the

00:19:54,140 --> 00:19:58,280
singleton unsurprisingly is something

00:19:55,880 --> 00:20:00,200
which runs once and if you have two data

00:19:58,280 --> 00:20:01,940
centers it the choice would be to run

00:20:00,200 --> 00:20:03,710
one across all of them

00:20:01,940 --> 00:20:07,039
or whether you would want to run one per

00:20:03,710 --> 00:20:09,019
data center and we want and we decided

00:20:07,039 --> 00:20:11,360
that it would be a singleton per data

00:20:09,019 --> 00:20:12,379
center by default so view to run the

00:20:11,360 --> 00:20:14,059
same code with the same configuration

00:20:12,379 --> 00:20:15,740
you'd end up with one per data center

00:20:14,059 --> 00:20:17,600
however I'll show you the API is and how

00:20:15,740 --> 00:20:19,700
you would go about just running it in

00:20:17,600 --> 00:20:22,370
one data center if that you want and the

00:20:19,700 --> 00:20:23,929
same is said for sharding so if you have

00:20:22,370 --> 00:20:25,730
if you're using cluster sharding and you

00:20:23,929 --> 00:20:27,679
send messages to a particular entity ID

00:20:25,730 --> 00:20:28,940
and you're gonna and you do it in two

00:20:27,679 --> 00:20:30,950
data centers you'd end up with two

00:20:28,940 --> 00:20:32,509
instances but you can still use things

00:20:30,950 --> 00:20:34,129
like distributed data you can still that

00:20:32,509 --> 00:20:36,259
use things like regular actor messaging

00:20:34,129 --> 00:20:38,240
to communicate between your two your two

00:20:36,259 --> 00:20:39,740
sets you two sets of nodes rather than

00:20:38,240 --> 00:20:44,120
having to break out like a separate

00:20:39,740 --> 00:20:46,009
protocol like G RPC or HTTP so what you

00:20:44,120 --> 00:20:47,779
do is you tell each nodes are which data

00:20:46,009 --> 00:20:49,730
center it in and then everything you

00:20:47,779 --> 00:20:52,159
knew about after cluster before will

00:20:49,730 --> 00:20:54,379
happen within a local data center but

00:20:52,159 --> 00:20:56,149
then they'll be slightly less frequent

00:20:54,379 --> 00:20:58,220
gossiping between the two data centers

00:20:56,149 --> 00:20:59,899
so each of them each of the each of the

00:20:58,220 --> 00:21:01,730
sides know about what's going on on the

00:20:59,899 --> 00:21:03,919
other side and you can register for

00:21:01,730 --> 00:21:05,330
events like unreachable data center etc

00:21:03,919 --> 00:21:07,940
and if you need to do something based on

00:21:05,330 --> 00:21:09,470
that so let's see how we would use

00:21:07,940 --> 00:21:11,570
something like sharding or Singleton's

00:21:09,470 --> 00:21:13,639
the api's are quite similar for them so

00:21:11,570 --> 00:21:15,230
at the moment deciding which data center

00:21:13,639 --> 00:21:16,759
in is just config there's been some

00:21:15,230 --> 00:21:19,429
ideas about you know automatically

00:21:16,759 --> 00:21:20,840
picking this up in environments like AWS

00:21:19,429 --> 00:21:22,519
and Google Cloud and things like

00:21:20,840 --> 00:21:25,009
databases like Cassandra do but it's

00:21:22,519 --> 00:21:27,110
just config at the moment here's the

00:21:25,009 --> 00:21:29,029
typed API for cluster Singleton's and

00:21:27,110 --> 00:21:31,100
the one for shouting is quite quite

00:21:29,029 --> 00:21:32,570
similar so we're we're spawning a typed

00:21:31,100 --> 00:21:35,240
actor the only thing that's really

00:21:32,570 --> 00:21:37,730
changed between this and the old one is

00:21:35,240 --> 00:21:39,679
that the the message you used to shut

00:21:37,730 --> 00:21:41,629
down these actors it has to be of the

00:21:39,679 --> 00:21:42,950
protocol of the actor it can't be

00:21:41,629 --> 00:21:44,480
something like a poison pill because

00:21:42,950 --> 00:21:48,679
that wouldn't that wouldn't type true

00:21:44,480 --> 00:21:50,360
and yet we can send messages to that if

00:21:48,679 --> 00:21:51,980
in data center B you wanted to have

00:21:50,360 --> 00:21:53,419
another singleton managing something or

00:21:51,980 --> 00:21:55,070
another complete set of clusters

00:21:53,419 --> 00:21:57,649
sharding then you would just do the same

00:21:55,070 --> 00:21:59,389
thing but alternatively you can say

00:21:57,649 --> 00:22:00,649
actually I want to talk to a singleton

00:21:59,389 --> 00:22:01,909
but I want to talk to the one data

00:22:00,649 --> 00:22:03,590
center a because I want to make some

00:22:01,909 --> 00:22:05,570
global decision that wouldn't be

00:22:03,590 --> 00:22:07,909
available if I were to have some kind of

00:22:05,570 --> 00:22:11,119
network split so you pick consistency

00:22:07,909 --> 00:22:12,740
over availability then an interesting to

00:22:11,119 --> 00:22:15,830
think note here we saw what looks like

00:22:12,740 --> 00:22:18,020
quite a complicated ask API

00:22:15,830 --> 00:22:19,790
before are we passed in a function to

00:22:18,020 --> 00:22:21,290
map that message the response message

00:22:19,790 --> 00:22:24,050
back into the protocol of your actor

00:22:21,290 --> 00:22:26,300
that was for when you all having one act

00:22:24,050 --> 00:22:28,520
to talk to another if you're talking to

00:22:26,300 --> 00:22:30,980
an actor from outside of the actor

00:22:28,520 --> 00:22:33,650
ecosystem so just from a regular regular

00:22:30,980 --> 00:22:35,660
Scala code then it looks a lot more like

00:22:33,650 --> 00:22:37,610
a regular ask you just sended a message

00:22:35,660 --> 00:22:41,060
but there's no map to their right and

00:22:37,610 --> 00:22:44,030
what ask actually takes is a function

00:22:41,060 --> 00:22:46,700
which which produces the request message

00:22:44,030 --> 00:22:48,530
of the actor and it passes you a and

00:22:46,700 --> 00:22:51,350
after reference for the response so this

00:22:48,530 --> 00:22:52,880
get value is actually a case class which

00:22:51,350 --> 00:22:55,840
takes in one parameter which is a and

00:22:52,880 --> 00:22:58,970
after reference of the appropriate type

00:22:55,840 --> 00:23:00,380
okay so that's multi D see the other

00:22:58,970 --> 00:23:01,730
thing that's changed and this was quite

00:23:00,380 --> 00:23:04,460
recent and is definitely still in

00:23:01,730 --> 00:23:06,260
preview mode but it's it's ready for you

00:23:04,460 --> 00:23:08,750
to try out on your network

00:23:06,260 --> 00:23:11,840
infrastructure it's not a tree just

00:23:08,750 --> 00:23:14,810
artery it's specifically artery TCP so

00:23:11,840 --> 00:23:16,640
some time ago a new version of remoting

00:23:14,810 --> 00:23:18,830
was released which is based on Aaron

00:23:16,640 --> 00:23:20,390
which is the libraries by martin

00:23:18,830 --> 00:23:22,550
thompson richard robertson and it's

00:23:20,390 --> 00:23:24,350
somewhere cut ah but a lot of people

00:23:22,550 --> 00:23:26,420
can't migrate to that because one it

00:23:24,350 --> 00:23:28,760
doesn't have transport security and two

00:23:26,420 --> 00:23:30,710
it's based on tcp and depending on what

00:23:28,760 --> 00:23:32,510
network infrastructure or what your your

00:23:30,710 --> 00:23:34,030
IT department will allow you to do maybe

00:23:32,510 --> 00:23:37,400
maybe this isn't right for you

00:23:34,030 --> 00:23:40,070
so artery unsurprisingly is built on top

00:23:37,400 --> 00:23:41,990
of echo streams internally so what we've

00:23:40,070 --> 00:23:44,870
basically done is is separate out the

00:23:41,990 --> 00:23:47,600
UDP air on specific things undone an

00:23:44,870 --> 00:23:50,210
equivalent implementation for TCP are

00:23:47,600 --> 00:23:52,160
using extremes TCP and it's really nice

00:23:50,210 --> 00:23:53,810
then because you get things like TLS so

00:23:52,160 --> 00:23:56,090
you can you can start to have transport

00:23:53,810 --> 00:23:57,980
level security again you haven't looked

00:23:56,090 --> 00:23:59,600
at our tree X you saw UDP and runaway

00:23:57,980 --> 00:24:01,160
then there's some other cool things

00:23:59,600 --> 00:24:03,470
about it it separates out system

00:24:01,160 --> 00:24:05,750
messages and control messages are Arin

00:24:03,470 --> 00:24:07,640
when using UDP actually has the concept

00:24:05,750 --> 00:24:11,030
of multiple extreme so you it will do

00:24:07,640 --> 00:24:12,890
that for us in this for TCP at the

00:24:11,030 --> 00:24:14,630
moment it's separate TCP connections so

00:24:12,890 --> 00:24:15,950
you have a control TCP connection you

00:24:14,630 --> 00:24:18,170
have a large message stream if you

00:24:15,950 --> 00:24:20,090
enable that and then you've got your

00:24:18,170 --> 00:24:21,470
regular ones just to stop big large

00:24:20,090 --> 00:24:25,210
messages clogging up the pipe between

00:24:21,470 --> 00:24:25,210
your various active systems

00:24:25,360 --> 00:24:30,130
so next thing we've worked on so stream

00:24:28,090 --> 00:24:31,420
rafts quite a simple feature and if

00:24:30,130 --> 00:24:32,950
you've come across the problem you'll

00:24:31,420 --> 00:24:35,350
find it very useful otherwise you might

00:24:32,950 --> 00:24:36,730
think hmmm why do I need that so my

00:24:35,350 --> 00:24:38,950
assumption is a lot of people here have

00:24:36,730 --> 00:24:41,470
used akka streams or some reactive

00:24:38,950 --> 00:24:42,970
streams compliant a library for

00:24:41,470 --> 00:24:45,460
processing things and that they know

00:24:42,970 --> 00:24:48,790
what back pressure is etc and all of

00:24:45,460 --> 00:24:50,260
that is normally built for a single JVM

00:24:48,790 --> 00:24:52,660
all right so it's inside your

00:24:50,260 --> 00:24:54,640
application how do you deal with the

00:24:52,660 --> 00:24:55,900
flow of messages when things are

00:24:54,640 --> 00:24:57,910
asynchronous and you're not getting the

00:24:55,900 --> 00:25:00,610
natural thing by blocking lots of

00:24:57,910 --> 00:25:02,200
operating system threads what stream

00:25:00,610 --> 00:25:05,410
refs is it takes this concept and puts

00:25:02,200 --> 00:25:07,270
it over the network so there's nothing

00:25:05,410 --> 00:25:09,130
stopping you from doing this yourself so

00:25:07,270 --> 00:25:10,450
if you are a ki streams based or

00:25:09,130 --> 00:25:12,820
something else and you want to

00:25:10,450 --> 00:25:14,710
communicate with another reactive

00:25:12,820 --> 00:25:16,750
streams raqqa streams based thing then

00:25:14,710 --> 00:25:19,540
you could hook it down you could go down

00:25:16,750 --> 00:25:21,640
to TCP you could make sure then that the

00:25:19,540 --> 00:25:23,200
your TCP flow control Maps up nicely

00:25:21,640 --> 00:25:25,570
with your flow control within your

00:25:23,200 --> 00:25:27,790
application but you're suddenly dealing

00:25:25,570 --> 00:25:28,990
with serialization issues you're gonna

00:25:27,790 --> 00:25:30,670
have to start dealing with getting down

00:25:28,990 --> 00:25:31,960
to a byte string rather than I could

00:25:30,670 --> 00:25:34,060
just underling it for you very sure

00:25:31,960 --> 00:25:35,290
ization extension you'll start to have

00:25:34,060 --> 00:25:36,730
to worry about connection pooling

00:25:35,290 --> 00:25:39,490
depending on how you do this

00:25:36,730 --> 00:25:40,990
communication and the other side needs

00:25:39,490 --> 00:25:42,850
to be listening so you need to worry

00:25:40,990 --> 00:25:43,870
about port allocation etc which becomes

00:25:42,850 --> 00:25:47,380
even more complex

00:25:43,870 --> 00:25:48,730
so what stream refs is is a way to take

00:25:47,380 --> 00:25:51,040
this where you've got an actor system

00:25:48,730 --> 00:25:52,840
here and actor system there and you you

00:25:51,040 --> 00:25:54,490
realize it it's not just an odd message

00:25:52,840 --> 00:25:56,620
you actually want to send a significant

00:25:54,490 --> 00:25:58,360
flow of messages from from one to the

00:25:56,620 --> 00:26:00,550
other and you want to do it in a flow

00:25:58,360 --> 00:26:02,440
controlled way because if you just do

00:26:00,550 --> 00:26:04,720
this with regular actors you'd end up

00:26:02,440 --> 00:26:06,250
with all the problems that occur streams

00:26:04,720 --> 00:26:07,960
is trying to solve you'd probably end up

00:26:06,250 --> 00:26:09,130
with you know lots of mail and you'd end

00:26:07,960 --> 00:26:10,390
up blowing up the other system

00:26:09,130 --> 00:26:12,850
especially if you didn't hook it up

00:26:10,390 --> 00:26:16,000
correctly with akka TCP akka streams TCP

00:26:12,850 --> 00:26:17,530
and deal with the TCP flow control so

00:26:16,000 --> 00:26:19,930
the quick primer on how it works

00:26:17,530 --> 00:26:22,000
regularly inside a you know what warned

00:26:19,930 --> 00:26:23,500
JVM is any time there's an async

00:26:22,000 --> 00:26:24,760
boundary anytime we're sending messages

00:26:23,500 --> 00:26:27,100
from one part of the string to the other

00:26:24,760 --> 00:26:29,530
then the only way that happens is the

00:26:27,100 --> 00:26:32,410
demand flows back so the consumer of

00:26:29,530 --> 00:26:34,260
messages picks the picks the rate and

00:26:32,410 --> 00:26:37,360
basically does this but over the network

00:26:34,260 --> 00:26:39,250
so the API is is very simple you can

00:26:37,360 --> 00:26:41,020
take any existing source

00:26:39,250 --> 00:26:42,790
and you can run it with a stream ref and

00:26:41,020 --> 00:26:45,880
it will materialize and you'll end up

00:26:42,790 --> 00:26:48,550
with a future for and that may change of

00:26:45,880 --> 00:26:49,720
source ref a source for F is just a

00:26:48,550 --> 00:26:51,760
source it will be implicitly converted

00:26:49,720 --> 00:26:53,800
for you however if you want to

00:26:51,760 --> 00:26:55,990
explicitly call that source and then

00:26:53,800 --> 00:26:57,580
somehow you can jump over it get that to

00:26:55,990 --> 00:27:00,190
another node how you do that is not

00:26:57,580 --> 00:27:01,480
really the concern of on stream ref that

00:27:00,190 --> 00:27:04,390
could be a regular active message it

00:27:01,480 --> 00:27:05,830
could be over anything you like and once

00:27:04,390 --> 00:27:07,480
you've got hold of that and this could

00:27:05,830 --> 00:27:08,920
be a sink or a source then you can

00:27:07,480 --> 00:27:10,210
materialize it the same way that you can

00:27:08,920 --> 00:27:14,260
run it the same way you would normally

00:27:10,210 --> 00:27:16,990
do and the advantage of doing this is

00:27:14,260 --> 00:27:19,510
under the head under the head no under

00:27:16,990 --> 00:27:20,770
the hood what's going to happen there is

00:27:19,510 --> 00:27:22,780
we're going to have message ordering

00:27:20,770 --> 00:27:24,700
we're going to have redelivery we're

00:27:22,780 --> 00:27:26,170
gonna have demand propagating back from

00:27:24,700 --> 00:27:27,610
one actor system to the other

00:27:26,170 --> 00:27:29,560
and you you won't see this this will

00:27:27,610 --> 00:27:31,600
just be happening under the covers the

00:27:29,560 --> 00:27:33,190
demand propagation the kind of protocols

00:27:31,600 --> 00:27:34,960
which you might have built by actor

00:27:33,190 --> 00:27:37,810
messaging that will be resent and

00:27:34,960 --> 00:27:39,460
retried or under the covers and if you

00:27:37,810 --> 00:27:41,740
create lots and lots and lots of these

00:27:39,460 --> 00:27:43,990
but no one never materializes them then

00:27:41,740 --> 00:27:45,370
they'll eventually time out so you don't

00:27:43,990 --> 00:27:48,220
you don't end up with some type of

00:27:45,370 --> 00:27:49,390
resource leak right so that's a stream

00:27:48,220 --> 00:27:53,920
refs if you've end up with that problem

00:27:49,390 --> 00:27:56,050
then this is a good thing so the the

00:27:53,920 --> 00:28:00,880
final section probably the biggest new

00:27:56,050 --> 00:28:04,540
thing is our G RPC is anyone using G RPC

00:28:00,880 --> 00:28:06,580
in the audience a few as any reason

00:28:04,540 --> 00:28:11,410
using a different RPC frame like thrift

00:28:06,580 --> 00:28:13,090
anything no so normally as a team that

00:28:11,410 --> 00:28:15,460
likes messaging we wouldn't normally

00:28:13,090 --> 00:28:17,740
suggest using an RPC framework but it's

00:28:15,460 --> 00:28:20,350
become a de facto standard it's become

00:28:17,740 --> 00:28:22,840
very popular for those who don't know

00:28:20,350 --> 00:28:25,240
it's based on HTTP to our the it's

00:28:22,840 --> 00:28:27,520
language agnostic so you take a

00:28:25,240 --> 00:28:29,710
interface you can you have compilers

00:28:27,520 --> 00:28:34,300
which turn it into a language of choice

00:28:29,710 --> 00:28:35,740
B H G sharp F sharp Scala Java and then

00:28:34,300 --> 00:28:38,470
it allows you to communicate between two

00:28:35,740 --> 00:28:39,910
services it's based it's based on

00:28:38,470 --> 00:28:43,240
protobuf if you've used that for

00:28:39,910 --> 00:28:44,830
sterilization before one of the

00:28:43,240 --> 00:28:47,650
differences between this and other

00:28:44,830 --> 00:28:49,780
attempts at this like Koba is it

00:28:47,650 --> 00:28:52,060
streaming is a first-class citizen so if

00:28:49,780 --> 00:28:52,930
you've not seen this before this is what

00:28:52,060 --> 00:28:55,630
an interface

00:28:52,930 --> 00:28:58,390
definition language looks like inside gr

00:28:55,630 --> 00:29:00,940
PC you've got four types of requests

00:28:58,390 --> 00:29:03,370
response patterns or patterns the first

00:29:00,940 --> 00:29:04,270
is the simple one so this is going to be

00:29:03,370 --> 00:29:05,890
a distributed hello

00:29:04,270 --> 00:29:07,480
so we first end up with one where we

00:29:05,890 --> 00:29:09,280
just send a small amount a small request

00:29:07,480 --> 00:29:11,320
and we get a small response back that's

00:29:09,280 --> 00:29:12,880
the top one I'm assuming these messages

00:29:11,320 --> 00:29:14,290
hello requests and hello reply it

00:29:12,880 --> 00:29:15,580
defined somewhere and you can put

00:29:14,290 --> 00:29:17,140
whatever you like in there think of them

00:29:15,580 --> 00:29:19,420
as a case class that's what they they

00:29:17,140 --> 00:29:20,620
get mapped to but then you also have the

00:29:19,420 --> 00:29:24,250
use case where you're sending lots of

00:29:20,620 --> 00:29:25,990
data so it keeps talking is prefixed

00:29:24,250 --> 00:29:28,120
with its input parameter is prefixed

00:29:25,990 --> 00:29:30,400
with a stream R but it's response is

00:29:28,120 --> 00:29:33,370
just one message and it keeps replying

00:29:30,400 --> 00:29:34,630
is the opposite it returns a stream so

00:29:33,370 --> 00:29:36,280
the idea is there you would kick off

00:29:34,630 --> 00:29:38,470
something and then you get lots and lots

00:29:36,280 --> 00:29:40,060
of responses back and then obviously you

00:29:38,470 --> 00:29:41,590
can go full shebang and you can decide

00:29:40,060 --> 00:29:42,760
hey I'm going to stream both ways I'm

00:29:41,590 --> 00:29:44,050
gonna send you lots of stuff and I'm

00:29:42,760 --> 00:29:46,600
going to send I'm gonna receive lots of

00:29:44,050 --> 00:29:48,010
stuff now this is something which I

00:29:46,600 --> 00:29:50,260
would imagine would work very well with

00:29:48,010 --> 00:29:52,240
echo streams write an API based on this

00:29:50,260 --> 00:29:54,550
the API you dealt with if you use the

00:29:52,240 --> 00:29:56,770
the default kind of Java one is

00:29:54,550 --> 00:29:58,600
something called a stream observer so

00:29:56,770 --> 00:30:00,340
anytime you end up with stream inside

00:29:58,600 --> 00:30:02,350
your API you end up either having to

00:30:00,340 --> 00:30:04,600
interact with this or implement this to

00:30:02,350 --> 00:30:07,060
deal with the messages there's not the

00:30:04,600 --> 00:30:08,920
most compelling poseable thing so we see

00:30:07,060 --> 00:30:11,020
what this looks like with this so the

00:30:08,920 --> 00:30:12,640
rqg IPC support it's an SBT plug-in

00:30:11,020 --> 00:30:14,950
which will do the code generation for

00:30:12,640 --> 00:30:16,270
you it also supports Mayville maven or

00:30:14,950 --> 00:30:18,970
Gradle of that if that's your thing

00:30:16,270 --> 00:30:20,950
and in it'll generate you stuff for the

00:30:18,970 --> 00:30:23,320
client so client-side stub and it will

00:30:20,950 --> 00:30:25,840
generate the machinery which allows you

00:30:23,320 --> 00:30:28,390
to implement it with echo streams and

00:30:25,840 --> 00:30:31,300
then plug it into an existing akka HTTP

00:30:28,390 --> 00:30:33,100
infrastructure so say hello actually

00:30:31,300 --> 00:30:34,630
knows nothing about akka Orica streams

00:30:33,100 --> 00:30:36,880
that's just that just uses a regular

00:30:34,630 --> 00:30:39,370
standard library future and you would

00:30:36,880 --> 00:30:40,750
implement that however you chose the

00:30:39,370 --> 00:30:42,310
streaming ones I think is where it's a

00:30:40,750 --> 00:30:44,710
really good fit so the assumption is if

00:30:42,310 --> 00:30:46,810
you're doing this then you're not going

00:30:44,710 --> 00:30:48,310
to have a four gigabytes hello request

00:30:46,810 --> 00:30:49,540
it's going to be small and you doesn't

00:30:48,310 --> 00:30:51,400
matter if your materialize and pull this

00:30:49,540 --> 00:30:52,990
into memory but if you're going to send

00:30:51,400 --> 00:30:56,290
lots of things the idea is to use one of

00:30:52,990 --> 00:30:59,290
these streams so a stream inside this

00:30:56,290 --> 00:31:00,880
becomes a source so what you basically

00:30:59,290 --> 00:31:02,380
do is if you wanna implement this on the

00:31:00,880 --> 00:31:04,270
server side you'd have to hook up your

00:31:02,380 --> 00:31:05,680
sink and consume from that source to

00:31:04,270 --> 00:31:06,790
deal with it and that would happen in

00:31:05,680 --> 00:31:08,230
your regular flow control

00:31:06,790 --> 00:31:10,540
way that you would expect from occur

00:31:08,230 --> 00:31:12,490
streams and responses are always

00:31:10,540 --> 00:31:16,360
asynchronous so you somehow turn that

00:31:12,490 --> 00:31:18,550
into a future however you like on the

00:31:16,360 --> 00:31:21,370
other side so we want to actually send

00:31:18,550 --> 00:31:23,410
back lots of things that also becomes a

00:31:21,370 --> 00:31:25,420
source but you return a source and the

00:31:23,410 --> 00:31:27,280
idea then is in the Akagi RPC

00:31:25,420 --> 00:31:29,440
infrastructure what it would do then is

00:31:27,280 --> 00:31:31,420
it would sync it up and attach it you

00:31:29,440 --> 00:31:34,210
know G RPC and send it over over the

00:31:31,420 --> 00:31:35,620
network and if you just love streaming

00:31:34,210 --> 00:31:38,020
you can't stream both ways if you want

00:31:35,620 --> 00:31:39,550
and you could base the source that's

00:31:38,020 --> 00:31:43,300
coming in the source out or they could

00:31:39,550 --> 00:31:44,590
be completely independent so there's two

00:31:43,300 --> 00:31:46,150
cool things I think about this one is

00:31:44,590 --> 00:31:48,580
the fact that you don't have to deal

00:31:46,150 --> 00:31:49,570
with the the on stream observer thinking

00:31:48,580 --> 00:31:51,940
you're bobby you get to deal with that

00:31:49,570 --> 00:31:54,010
go streams which I hope is a nice API

00:31:51,940 --> 00:31:55,300
the other is the fact that and I don't

00:31:54,010 --> 00:31:57,430
think there's anything else can do this

00:31:55,300 --> 00:32:00,390
is you can co-locate this with your

00:31:57,430 --> 00:32:02,740
existing a kahin HTTP infrastructure so

00:32:00,390 --> 00:32:04,270
the stuff that's generated what you can

00:32:02,740 --> 00:32:06,040
do is you get one of these greeter

00:32:04,270 --> 00:32:07,240
service thingies mine was called greeter

00:32:06,040 --> 00:32:08,940
service so it's now called a greeter

00:32:07,240 --> 00:32:11,050
service handler you pass in your

00:32:08,940 --> 00:32:12,940
implementation and what you get back is

00:32:11,050 --> 00:32:15,460
something which is an HTTP request to a

00:32:12,940 --> 00:32:17,620
future of HTTP response or an akahoshi

00:32:15,460 --> 00:32:19,900
DP route which means that you can

00:32:17,620 --> 00:32:21,760
combine it and just pass it in and at

00:32:19,900 --> 00:32:23,020
the moment it's only with HTTP two but

00:32:21,760 --> 00:32:25,420
this will this will change and you'll be

00:32:23,020 --> 00:32:27,580
able to upgrade existing HTTP 1

00:32:25,420 --> 00:32:30,070
connections or you can do that with TLS

00:32:27,580 --> 00:32:31,630
but not without TLS right now which

00:32:30,070 --> 00:32:33,220
means that if you're if you have clients

00:32:31,630 --> 00:32:34,840
and some of them wants to do G RPC

00:32:33,220 --> 00:32:36,370
because the internet told them to and

00:32:34,840 --> 00:32:37,960
some of them want to do HTTP because

00:32:36,370 --> 00:32:39,370
that's the thing then you can actually

00:32:37,960 --> 00:32:40,630
serve all of this stuff over the same

00:32:39,370 --> 00:32:42,310
port and you could have all your racket

00:32:40,630 --> 00:32:43,660
DP routes you could combine it with this

00:32:42,310 --> 00:32:46,810
and you could serve it from the same

00:32:43,660 --> 00:32:48,700
thing but I think it's pretty cool on

00:32:46,810 --> 00:32:50,530
the client side it's unsurprising you

00:32:48,700 --> 00:32:51,970
you you end up with the same interface

00:32:50,530 --> 00:32:53,170
so as a client you interact with the

00:32:51,970 --> 00:32:54,490
same interface that I showed you that

00:32:53,170 --> 00:32:57,160
you'd be implementing if you're on the

00:32:54,490 --> 00:32:58,420
server side I so if we end up here you

00:32:57,160 --> 00:33:00,930
end up a client you just tell it where

00:32:58,420 --> 00:33:02,500
to go and it will connect Tim and

00:33:00,930 --> 00:33:04,780
unsurprisingly cuz I've already showed

00:33:02,500 --> 00:33:06,160
you the API if you call one of the unity

00:33:04,780 --> 00:33:08,530
requests which is the one that out

00:33:06,160 --> 00:33:10,390
streaming you get back a future if you

00:33:08,530 --> 00:33:12,780
end up with one where you have to pass a

00:33:10,390 --> 00:33:14,860
stream in your passing the source in or

00:33:12,780 --> 00:33:16,090
the other way around you end up with a

00:33:14,860 --> 00:33:18,430
source back and then it's your

00:33:16,090 --> 00:33:20,230
responsibility to hook that up to some

00:33:18,430 --> 00:33:21,280
sink and consume it otherwise

00:33:20,230 --> 00:33:22,840
have the same problem where you didn't

00:33:21,280 --> 00:33:24,929
consume the response entity say with

00:33:22,840 --> 00:33:27,910
httpclient

00:33:24,929 --> 00:33:29,830
so to summarize on gr PC this is very

00:33:27,910 --> 00:33:31,780
new so I think we released the point one

00:33:29,830 --> 00:33:33,669
release I this coming week or laughs

00:33:31,780 --> 00:33:36,490
last week so don't put it in production

00:33:33,669 --> 00:33:38,140
just yet it's it only works with part of

00:33:36,490 --> 00:33:41,410
the it only works with the bind and

00:33:38,140 --> 00:33:43,450
handle a sink with akka HTTP the the

00:33:41,410 --> 00:33:45,160
server side is fully our KTTV doesn't

00:33:43,450 --> 00:33:46,900
have any dependencies but the client at

00:33:45,160 --> 00:33:49,150
the moment is based on the on the net II

00:33:46,900 --> 00:33:51,250
version but the idea is that this will

00:33:49,150 --> 00:33:54,280
eventually be based on the HTTP client

00:33:51,250 --> 00:33:55,929
wants it supports HTTP two so if you're

00:33:54,280 --> 00:33:56,950
used to using things like cinnamon if

00:33:55,929 --> 00:33:58,720
you're like burn customer and you're

00:33:56,950 --> 00:33:59,950
monitoring on these things and you're

00:33:58,720 --> 00:34:01,780
monitoring your I can HTTP

00:33:59,950 --> 00:34:06,549
infrastructure you'll get the same for

00:34:01,780 --> 00:34:08,950
the things that you do with um G RPC so

00:34:06,549 --> 00:34:10,000
that's everything we've got time for or

00:34:08,950 --> 00:34:11,200
everything that we've actually managed

00:34:10,000 --> 00:34:12,429
to do in the last six months so I've

00:34:11,200 --> 00:34:15,070
looked at typed I hope that people

00:34:12,429 --> 00:34:16,149
really now go and play with typed

00:34:15,070 --> 00:34:17,530
because we're at the point now where we

00:34:16,149 --> 00:34:19,389
wouldn't want to make any fundamental

00:34:17,530 --> 00:34:20,889
changes to the to the API we've we've

00:34:19,389 --> 00:34:21,940
made a few over the last few months we

00:34:20,889 --> 00:34:26,080
don't want to break it anymore

00:34:21,940 --> 00:34:27,429
I think gr pcs quite exciting so on that

00:34:26,080 --> 00:34:28,720
note I just want to thank you for

00:34:27,429 --> 00:34:29,950
listening I think we've got about we've

00:34:28,720 --> 00:34:33,699
got about five or ten minutes for

00:34:29,950 --> 00:34:36,930
questions so thanks very much

00:34:33,699 --> 00:34:40,320
[Applause]

00:34:36,930 --> 00:34:48,020
any questions which I may or may not be

00:34:40,320 --> 00:34:48,020
able to answer no yeah what's the

00:34:51,560 --> 00:34:54,800
cluster thingy

00:35:05,840 --> 00:35:09,390
so yeah light burned off for a split

00:35:07,800 --> 00:35:11,190
brain resolver I think there's nothing

00:35:09,390 --> 00:35:13,260
you can really can't or cannot do once

00:35:11,190 --> 00:35:15,090
it's split so that the idea that you

00:35:13,260 --> 00:35:16,610
don't I do inconsistent things during a

00:35:15,090 --> 00:35:18,450
split brain and that could be

00:35:16,610 --> 00:35:20,430
accidentally end up with to lots of

00:35:18,450 --> 00:35:22,470
cluster sharding or end up with two

00:35:20,430 --> 00:35:24,210
Singleton's but because all decisions

00:35:22,470 --> 00:35:26,400
are local to a data center actually

00:35:24,210 --> 00:35:28,380
wants it once the do TDD seeds are split

00:35:26,400 --> 00:35:30,270
it actually makes no the leaders can

00:35:28,380 --> 00:35:32,220
still do exactly the same thing so

00:35:30,270 --> 00:35:34,380
there's like that split brain is handled

00:35:32,220 --> 00:35:36,060
by the fact that we don't make a cluster

00:35:34,380 --> 00:35:38,160
never makes cross DC decisions for you

00:35:36,060 --> 00:35:43,190
you'd have to build your own logic based

00:35:38,160 --> 00:35:49,170
on something for that any more questions

00:35:43,190 --> 00:35:50,640
yeah I think they'll be around for a

00:35:49,170 --> 00:35:52,910
long long long so the question was what

00:35:50,640 --> 00:35:55,530
will be the future of untyped actors so

00:35:52,910 --> 00:35:57,120
it's subjective I think they'll be

00:35:55,530 --> 00:35:59,520
around for a long long long long time I

00:35:57,120 --> 00:36:00,750
don't think they're going away I guess

00:35:59,520 --> 00:36:02,700
it'll be based on the success of

00:36:00,750 --> 00:36:05,130
archetype Don how long they remain I

00:36:02,700 --> 00:36:06,150
think we've we we're at the point now

00:36:05,130 --> 00:36:07,650
where I guess we'd want to start

00:36:06,150 --> 00:36:09,570
implementing a lot of our internal stuff

00:36:07,650 --> 00:36:13,350
with I could type rather than untyped

00:36:09,570 --> 00:36:15,360
actors but you definitely my experience

00:36:13,350 --> 00:36:17,520
from using it is you pay a cost because

00:36:15,360 --> 00:36:20,400
you're if you want be something quick

00:36:17,520 --> 00:36:21,810
and hacky which it would never do then

00:36:20,400 --> 00:36:22,890
you suddenly can't just accept a new

00:36:21,810 --> 00:36:24,150
message into your actor you have to

00:36:22,890 --> 00:36:26,400
explicitly think about the protocol

00:36:24,150 --> 00:36:27,900
interaction which can seem quite

00:36:26,400 --> 00:36:29,700
boilerplate initially but I think you

00:36:27,900 --> 00:36:31,410
thank yourself later down the line when

00:36:29,700 --> 00:36:35,750
you you come to go back you go back to

00:36:31,410 --> 00:36:43,860
that code any more questions think I saw

00:36:35,750 --> 00:36:46,110
yeah so question was is there anything

00:36:43,860 --> 00:36:48,390
new in persistent query or persistent

00:36:46,110 --> 00:36:49,620
query was already fully typed because

00:36:48,390 --> 00:36:52,290
you were dealing with streams rather

00:36:49,620 --> 00:36:55,590
than any actors so as far as I'm aware

00:36:52,290 --> 00:36:57,210
there's nothing new you still interact

00:36:55,590 --> 00:36:58,530
you could persistent query doesn't

00:36:57,210 --> 00:37:00,480
really know whether things were basicity

00:36:58,530 --> 00:37:03,470
that with archive assistants typed or

00:37:00,480 --> 00:37:03,470

YouTube URL: https://www.youtube.com/watch?v=ncQTM-F_VmA


