Title: Adding kind-polymorphism to the Scala programming language by Miles Sabin
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6903-adding-kind-polymorphism-to-the-scala-programming-language.html
Captions: 
	00:00:04,570 --> 00:00:09,580
hi thanks good morning everybody thanks

00:00:06,910 --> 00:00:11,639
for a very nice to have such a large

00:00:09,580 --> 00:00:14,980
audience for a talk with such a

00:00:11,639 --> 00:00:16,960
forbidding title hopefully I will I will

00:00:14,980 --> 00:00:19,450
disappoint you all by making making it

00:00:16,960 --> 00:00:21,730
seem actually fairly prosaic and

00:00:19,450 --> 00:00:23,320
hopefully kind of a bit of a no-brainer

00:00:21,730 --> 00:00:30,220
this is something we want and we should

00:00:23,320 --> 00:00:31,300
have so my background I guess like as

00:00:30,220 --> 00:00:33,340
most people know who I am I've been

00:00:31,300 --> 00:00:36,670
working on shapeless for for years and

00:00:33,340 --> 00:00:37,840
years and years now and also a little

00:00:36,670 --> 00:00:41,469
bit more recently I've been working on

00:00:37,840 --> 00:00:43,090
the the type level scarlet compiler and

00:00:41,469 --> 00:00:44,820
I've also again in the last year been

00:00:43,090 --> 00:00:47,590
doing some work with like bent on

00:00:44,820 --> 00:00:48,760
bringing them some things over from type

00:00:47,590 --> 00:00:50,289
Bible scholar wall thinks that they've

00:00:48,760 --> 00:00:54,550
at least been prototype tintype devil

00:00:50,289 --> 00:00:58,390
scholar to to the the light bend Scylla

00:00:54,550 --> 00:00:59,649
compiler and I guess also I've been

00:00:58,390 --> 00:01:01,329
thinking about how some of these things

00:00:59,649 --> 00:01:03,640
that actually will help us sort of

00:01:01,329 --> 00:01:06,490
translate things over to dotty and move

00:01:03,640 --> 00:01:12,909
ourselves in the direction of Scala 3

00:01:06,490 --> 00:01:18,970
over over the next few years so one of

00:01:12,909 --> 00:01:22,530
the and well among the many issues that

00:01:18,970 --> 00:01:26,560
I've faced with shapeless over the years

00:01:22,530 --> 00:01:28,869
are a bunch of problems which I until a

00:01:26,560 --> 00:01:30,159
few years ago I I guess I kind of I kind

00:01:28,869 --> 00:01:31,479
of seemed we're going to be intractable

00:01:30,159 --> 00:01:34,509
they were going to be impossible to

00:01:31,479 --> 00:01:36,450
solve in one way or another we had

00:01:34,509 --> 00:01:41,200
issues with compile times being

00:01:36,450 --> 00:01:45,100
unacceptably long for use complex uses

00:01:41,200 --> 00:01:46,990
of uses uses of the complex types that

00:01:45,100 --> 00:01:49,659
that arise when doing generic

00:01:46,990 --> 00:01:51,670
programming in Scala there were some

00:01:49,659 --> 00:01:54,670
really really quite unpleasant issues

00:01:51,670 --> 00:01:58,689
with the the lazy type constructor and

00:01:54,670 --> 00:02:00,040
shapeless which I I kind of don't want

00:01:58,689 --> 00:02:02,219
to go into the details it's an

00:02:00,040 --> 00:02:04,539
absolutely hideous macro under the hood

00:02:02,219 --> 00:02:05,979
there are there are there are all sorts

00:02:04,539 --> 00:02:07,810
of very very unpleasant things lurking

00:02:05,979 --> 00:02:08,890
in the background there which again it

00:02:07,810 --> 00:02:13,120
never seemed like there was going to be

00:02:08,890 --> 00:02:15,490
any any any very clear path to solving

00:02:13,120 --> 00:02:17,020
them at least at least in our library

00:02:15,490 --> 00:02:20,650
there are issues with implicit

00:02:17,020 --> 00:02:21,880
prioritization and and finally there was

00:02:20,650 --> 00:02:24,550
the fact that although although

00:02:21,880 --> 00:02:28,750
shapeless has always been a library

00:02:24,550 --> 00:02:33,970
which which trades on types and likes to

00:02:28,750 --> 00:02:35,890
use the power of scholars type system to

00:02:33,970 --> 00:02:38,140
to do the things that it does rather

00:02:35,890 --> 00:02:40,240
than escape out of the language to do

00:02:38,140 --> 00:02:42,730
sort of meta programming or extra

00:02:40,240 --> 00:02:45,400
linguistic things nevertheless at a few

00:02:42,730 --> 00:02:47,770
key points it depends really essentially

00:02:45,400 --> 00:02:49,240
on on a number of really quite hairy

00:02:47,770 --> 00:02:53,020
macro so obviously lazy thing one

00:02:49,240 --> 00:02:56,890
example but generic as well which will

00:02:53,020 --> 00:02:58,420
come on to shortly these these are these

00:02:56,890 --> 00:03:01,630
are these are really quite hairy macros

00:02:58,420 --> 00:03:05,110
they are very fragile they depend on

00:03:01,630 --> 00:03:06,760
compile internals they are totally non

00:03:05,110 --> 00:03:09,070
portable there's no way that they will

00:03:06,760 --> 00:03:11,620
survive a transition to dotty or indeed

00:03:09,070 --> 00:03:14,020
any other scarlet compiler if if if

00:03:11,620 --> 00:03:15,100
other other dialects or flavors of

00:03:14,020 --> 00:03:17,140
scarlet would to come along which

00:03:15,100 --> 00:03:23,470
differed in any significant way in their

00:03:17,140 --> 00:03:25,600
internals so this kind of prompted me

00:03:23,470 --> 00:03:28,480
once once once I I suppose the

00:03:25,600 --> 00:03:30,580
realization with with the the si two

00:03:28,480 --> 00:03:34,410
seven one to fix was that actually it's

00:03:30,580 --> 00:03:36,400
it is really quite possible to have

00:03:34,410 --> 00:03:39,400
external contributions to the compiler

00:03:36,400 --> 00:03:40,840
and make progress on problems which

00:03:39,400 --> 00:03:42,850
would seem to be impractical at that at

00:03:40,840 --> 00:03:45,250
the language level and so since that

00:03:42,850 --> 00:03:46,840
point I I've been on a sort of journey

00:03:45,250 --> 00:03:48,550
doing various things and sort of trying

00:03:46,840 --> 00:03:50,230
to tick off some of these these items

00:03:48,550 --> 00:03:52,360
and I think I think it's been going

00:03:50,230 --> 00:03:55,420
quite well I mean the compile time issue

00:03:52,360 --> 00:03:57,550
I think this is stuff which is sort of

00:03:55,420 --> 00:04:00,790
prototype tintype level scholar but

00:03:57,550 --> 00:04:03,940
which will hopefully be landing in like

00:04:00,790 --> 00:04:07,390
Ben Scala to thirteen very shortly which

00:04:03,940 --> 00:04:12,250
are some it turns out quite quite

00:04:07,390 --> 00:04:14,350
surprisingly small tweaks to the to the

00:04:12,250 --> 00:04:16,239
way that implicit work or at least some

00:04:14,350 --> 00:04:17,950
aspects of the way that implicit work

00:04:16,239 --> 00:04:22,710
which dramatically speed up compile

00:04:17,950 --> 00:04:30,550
times for induct type level induction

00:04:22,710 --> 00:04:31,690
the the let issues with lazy have kind

00:04:30,550 --> 00:04:39,909
of gone away because they've been

00:04:31,690 --> 00:04:43,509
replaced by they've been replaced by the

00:04:39,909 --> 00:04:46,449
by name implicit which Martin mentioned

00:04:43,509 --> 00:04:49,569
in his talk about dotty yesterday

00:04:46,449 --> 00:04:50,789
evening that's a feature which has

00:04:49,569 --> 00:04:54,789
landed in dotty

00:04:50,789 --> 00:04:57,819
again is pending merging there is a pull

00:04:54,789 --> 00:05:01,690
request against against Carla for this

00:04:57,819 --> 00:05:03,880
as well it's the some work that I've

00:05:01,690 --> 00:05:05,620
done on inputs a prioritization which is

00:05:03,880 --> 00:05:08,819
he's up for discussion and may very well

00:05:05,620 --> 00:05:14,020
need a sip but hopefully can move us on

00:05:08,819 --> 00:05:15,639
the macros the Romanian macros are three

00:05:14,020 --> 00:05:18,280
three three general families of macros

00:05:15,639 --> 00:05:19,360
which which I think were which which

00:05:18,280 --> 00:05:22,719
have been problematic so lazy I

00:05:19,360 --> 00:05:25,330
discussed witness which is used to

00:05:22,719 --> 00:05:29,289
capture singleton types and and generic

00:05:25,330 --> 00:05:30,849
which is used to map Scott a DTS onto

00:05:29,289 --> 00:05:36,490
onto a generic representation in terms

00:05:30,849 --> 00:05:38,529
of sums and products so anyway lazy as I

00:05:36,490 --> 00:05:40,810
as I anticipated myself has been

00:05:38,529 --> 00:05:42,849
replaced by buying impress its witness

00:05:40,810 --> 00:05:45,400
and there and the like have been

00:05:42,849 --> 00:05:48,370
replaced by by literal types and value

00:05:45,400 --> 00:05:49,599
of which they were experimented with in

00:05:48,370 --> 00:05:52,719
the type level Scala compiler for a

00:05:49,599 --> 00:05:56,020
while and have recently landed in Scala

00:05:52,719 --> 00:05:58,419
213 a generic is really the one

00:05:56,020 --> 00:06:02,380
remaining thing in Scala in shapeless

00:05:58,419 --> 00:06:05,289
rather which it's still very open as to

00:06:02,380 --> 00:06:07,120
what form that should take I've been

00:06:05,289 --> 00:06:11,490
thinking about it a long time and for a

00:06:07,120 --> 00:06:13,659
for a long time and and I I'm still

00:06:11,490 --> 00:06:15,009
unclear exactly what the right path

00:06:13,659 --> 00:06:18,630
forward and I'm going to discuss some of

00:06:15,009 --> 00:06:24,370
the some of the that the issues that

00:06:18,630 --> 00:06:26,860
that arise in this talk the two main

00:06:24,370 --> 00:06:29,740
things that I think I think are

00:06:26,860 --> 00:06:33,399
outstanding is what should shape us maps

00:06:29,740 --> 00:06:35,889
a shapes of generic maps an algebraic

00:06:33,399 --> 00:06:36,939
datatype onto a representation types so

00:06:35,889 --> 00:06:38,620
first question you might have is well

00:06:36,939 --> 00:06:40,449
what what is the representation type do

00:06:38,620 --> 00:06:42,159
we need something special like H lists

00:06:40,449 --> 00:06:44,590
and coke products or can we get away

00:06:42,159 --> 00:06:47,949
with pears and either or something like

00:06:44,590 --> 00:06:50,620
that or maybe there is sort of a church

00:06:47,949 --> 00:06:51,550
encoded kind of representation model

00:06:50,620 --> 00:06:53,289
which doesn't need any kind of

00:06:51,550 --> 00:06:56,020
representation type at all and I think I

00:06:53,289 --> 00:06:57,610
think I think and whereas these are

00:06:56,020 --> 00:07:00,430
things that that you can be sort of

00:06:57,610 --> 00:07:02,110
somewhat kind of fast and loose about in

00:07:00,430 --> 00:07:05,139
a library I think if you're going to

00:07:02,110 --> 00:07:06,729
think in terms of baking something into

00:07:05,139 --> 00:07:08,710
the language as a language feature I

00:07:06,729 --> 00:07:10,029
think you need to have a fairly clear

00:07:08,710 --> 00:07:12,159
idea about which way you're going to go

00:07:10,029 --> 00:07:16,060
and the other thing and the thing I'm

00:07:12,159 --> 00:07:17,889
going to talk about today is what kinds

00:07:16,060 --> 00:07:19,270
are representable and well what does

00:07:17,889 --> 00:07:23,349
what does that mean exactly

00:07:19,270 --> 00:07:27,550
and so shapeless shape uses generic

00:07:23,349 --> 00:07:30,580
initially only represented types of kind

00:07:27,550 --> 00:07:32,830
star so type of kind star is a sort of

00:07:30,580 --> 00:07:34,449
fully applied type so it's a type with

00:07:32,830 --> 00:07:36,789
no holes in it so something like int or

00:07:34,449 --> 00:07:37,900
string and int and string aren't

00:07:36,789 --> 00:07:40,000
particularly interesting for the point

00:07:37,900 --> 00:07:41,199
of view of generic they don't they don't

00:07:40,000 --> 00:07:43,839
they don't they they don't have a

00:07:41,199 --> 00:07:45,699
non-trivial representation that they're

00:07:43,839 --> 00:07:47,560
just they just map map to themselves as

00:07:45,699 --> 00:07:51,610
it were but but any kind of

00:07:47,560 --> 00:07:54,449
interestingly structured type has a

00:07:51,610 --> 00:07:59,500
representation in terms of in terms of

00:07:54,449 --> 00:08:01,539
if is of kind star has a representation

00:07:59,500 --> 00:08:04,990
in terms of a representation type which

00:08:01,539 --> 00:08:06,939
is also of kind star and so the first

00:08:04,990 --> 00:08:09,909
kind of generic type class that arrived

00:08:06,939 --> 00:08:13,479
in shapeless it represented only those

00:08:09,909 --> 00:08:15,219
things it kind of looks it looks like

00:08:13,479 --> 00:08:17,349
this more or less I I this is not

00:08:15,219 --> 00:08:19,539
exactly as it is in its APIs at the

00:08:17,349 --> 00:08:23,139
moment but it's captures the essential

00:08:19,539 --> 00:08:26,199
idea so you can see immediately from the

00:08:23,139 --> 00:08:29,050
type parameters and that's the only

00:08:26,199 --> 00:08:30,939
kinds of types that can be filled in as

00:08:29,050 --> 00:08:34,360
hype arguments for those type parameters

00:08:30,939 --> 00:08:35,800
are are fully applied complete types

00:08:34,360 --> 00:08:39,430
without any holes in them and you can

00:08:35,800 --> 00:08:40,959
see them both both in the type that's

00:08:39,430 --> 00:08:44,069
being represented and also in the

00:08:40,959 --> 00:08:46,390
representation at sorry type itself and

00:08:44,069 --> 00:08:47,030
despite the fact that that you know this

00:08:46,390 --> 00:08:48,560
this

00:08:47,030 --> 00:08:50,390
this this is this is quite a restriction

00:08:48,560 --> 00:08:52,370
of what what you might want might hope

00:08:50,390 --> 00:08:53,480
to be able to represent it covers a huge

00:08:52,370 --> 00:08:54,980
amount of ground and most of the

00:08:53,480 --> 00:08:57,920
applications of shapeless in terms of

00:08:54,980 --> 00:09:01,130
working with I don't know codecs of one

00:08:57,920 --> 00:09:03,830
sort or one one form or another and and

00:09:01,130 --> 00:09:08,920
many many uses of generic programming

00:09:03,830 --> 00:09:14,210
and um can actually be covered by this

00:09:08,920 --> 00:09:17,060
nevertheless there are there are some

00:09:14,210 --> 00:09:19,610
notable things which which it can't do

00:09:17,060 --> 00:09:20,990
in which which really came to light as a

00:09:19,610 --> 00:09:23,660
result of trying to go a little bit

00:09:20,990 --> 00:09:25,550
further in terms of the kinds of type

00:09:23,660 --> 00:09:28,160
loss instances that you can derive

00:09:25,550 --> 00:09:29,420
usually using shapeless and they mostly

00:09:28,160 --> 00:09:32,390
came up in the context of trying to

00:09:29,420 --> 00:09:34,160
derive type classes like I don't know

00:09:32,390 --> 00:09:37,070
functor or traversable or foldable

00:09:34,160 --> 00:09:41,020
whatever for for for cats which is work

00:09:37,070 --> 00:09:47,450
that I did in a project called kittens

00:09:41,020 --> 00:09:50,000
okay so and supports for representing

00:09:47,450 --> 00:09:54,230
types of with with a single a single

00:09:50,000 --> 00:09:58,490
simple hole came to shapeless later in

00:09:54,230 --> 00:10:02,090
the form of generic one and that can

00:09:58,490 --> 00:10:04,340
represent type constructors with with a

00:10:02,090 --> 00:10:05,810
single simple simple tie car type

00:10:04,340 --> 00:10:07,730
argument that's things like this option

00:10:05,810 --> 00:10:12,020
and again you can see immediately in the

00:10:07,730 --> 00:10:14,960
type parameters and that that that is

00:10:12,020 --> 00:10:22,160
the the shape of the types that it that

00:10:14,960 --> 00:10:25,460
it will support and also notice that the

00:10:22,160 --> 00:10:28,910
methods the map you to and from the from

00:10:25,460 --> 00:10:30,650
the the ADT to the representation are

00:10:28,910 --> 00:10:31,910
back again they have become polymorphic

00:10:30,650 --> 00:10:36,860
now they're no longer monomorphic

00:10:31,910 --> 00:10:38,300
methods and okay and this actually gives

00:10:36,860 --> 00:10:40,070
us an all flow at very very interesting

00:10:38,300 --> 00:10:43,130
things and I think we're still at the

00:10:40,070 --> 00:10:45,710
beginning of exploring exactly how far

00:10:43,130 --> 00:10:47,090
we can go in terms of deriving these

00:10:45,710 --> 00:10:49,460
these these these more interesting

00:10:47,090 --> 00:10:52,070
higher classes and but I think I think

00:10:49,460 --> 00:10:55,160
there is there is a huge amount of very

00:10:52,070 --> 00:10:58,010
very interesting stuff that's that is

00:10:55,160 --> 00:11:02,870
out there for people to work with

00:10:58,010 --> 00:11:04,370
okay so I can I can give you a very I'm

00:11:02,870 --> 00:11:05,600
not there's not a demo exactly I'm just

00:11:04,370 --> 00:11:08,150
going to show you the sort of the rough

00:11:05,600 --> 00:11:15,880
general outline of what this this kind

00:11:08,150 --> 00:11:24,220
of stuff looks like so we have a trait

00:11:15,880 --> 00:11:24,220
generic we have a trait generic one

00:11:26,050 --> 00:11:30,560
which look more or less as shown and

00:11:28,910 --> 00:11:34,120
then in terms of what we can do with

00:11:30,560 --> 00:11:38,000
these things if we have a couple of

00:11:34,120 --> 00:11:42,080
simple ADT's so we have a simple

00:11:38,000 --> 00:11:43,910
monomorphic adt a cat has a name and it

00:11:42,080 --> 00:11:45,110
has a representation so I'm not actually

00:11:43,910 --> 00:11:47,060
using shapeless here I'm just I'm just

00:11:45,110 --> 00:11:48,680
if you like manually writing out the

00:11:47,060 --> 00:11:53,690
incidences as you as you might do by

00:11:48,680 --> 00:11:55,490
hand just for the purposes of a quick

00:11:53,690 --> 00:11:59,120
demonstration so this is very very

00:11:55,490 --> 00:12:04,580
simple stuff it Maps stuff from the ADT

00:11:59,120 --> 00:12:08,420
- - to a pair and then back again then

00:12:04,580 --> 00:12:14,000
we have a a simple type of kind star

00:12:08,420 --> 00:12:18,020
arrow star and again here you can see

00:12:14,000 --> 00:12:20,360
that because generic one takes type

00:12:18,020 --> 00:12:25,340
parameters with a single type argument

00:12:20,360 --> 00:12:27,380
we're able to chase our polymorphic type

00:12:25,340 --> 00:12:29,740
both the the the the ADT and the

00:12:27,380 --> 00:12:34,760
representation type through to the

00:12:29,740 --> 00:12:37,070
through to the generic instance and

00:12:34,760 --> 00:12:38,600
again we have polymorphic methods here

00:12:37,070 --> 00:12:41,510
once we've got these things we can do

00:12:38,600 --> 00:12:43,750
useful things with them we can create a

00:12:41,510 --> 00:12:48,170
cat we can map its to its representation

00:12:43,750 --> 00:12:50,030
we can also use the typical sort of now

00:12:48,170 --> 00:12:52,490
well at least to some people fairly

00:12:50,030 --> 00:12:54,410
familiar mechanics of doing an inductive

00:12:52,490 --> 00:12:56,840
type class derivation say for a show

00:12:54,410 --> 00:12:59,660
instance which is going to give you show

00:12:56,840 --> 00:13:03,650
products given a generic or for a

00:12:59,660 --> 00:13:06,470
functor given given a generic we can

00:13:03,650 --> 00:13:08,780
produce a functor instance for products

00:13:06,470 --> 00:13:10,070
if you want to look at code which which

00:13:08,780 --> 00:13:11,510
does this inner in a more robust

00:13:10,070 --> 00:13:14,630
incomplete way

00:13:11,510 --> 00:13:16,550
you will find the the generic code

00:13:14,630 --> 00:13:20,120
pretty much everywhere shape this is

00:13:16,550 --> 00:13:23,120
used the generic one stuff the project

00:13:20,120 --> 00:13:25,400
kitten this is the thing to look at

00:13:23,120 --> 00:13:26,780
but anyway having having having done

00:13:25,400 --> 00:13:28,550
this we can we can we can produce

00:13:26,780 --> 00:13:30,620
functors automatically without having to

00:13:28,550 --> 00:13:32,350
manually write instances and then we can

00:13:30,620 --> 00:13:40,370
F map over them and so on and so forth

00:13:32,350 --> 00:13:43,600
okay okay so we've got support now for

00:13:40,370 --> 00:13:47,740
two two kinds Cayenne types of kind star

00:13:43,600 --> 00:13:50,330
and types of kind star arrow star and

00:13:47,740 --> 00:13:53,240
should we sort there is that it is that

00:13:50,330 --> 00:13:57,260
is that all that we would want to be

00:13:53,240 --> 00:13:58,430
able to support and um can we even stop

00:13:57,260 --> 00:14:02,720
there I mean it does it does it make

00:13:58,430 --> 00:14:06,740
sense to to give up at that point and I

00:14:02,720 --> 00:14:09,260
think I think in the first instance I

00:14:06,740 --> 00:14:10,790
think I think the only the only the only

00:14:09,260 --> 00:14:12,320
reason for stopping at this point will

00:14:10,790 --> 00:14:13,430
be a kind of failure of imagination i

00:14:12,320 --> 00:14:15,050
mean i think i think there's lots of

00:14:13,430 --> 00:14:19,310
lots of lots of very very interesting

00:14:15,050 --> 00:14:21,890
things out beyond those two those two

00:14:19,310 --> 00:14:23,960
kinds that we might want to be able to

00:14:21,890 --> 00:14:26,090
do generic programming with in terms of

00:14:23,960 --> 00:14:28,070
can we stop here actually i think it

00:14:26,090 --> 00:14:30,200
almost immediately falls out that we

00:14:28,070 --> 00:14:39,140
can't really and one of the reasons that

00:14:30,200 --> 00:14:40,940
that we can't is that i i've somewhat

00:14:39,140 --> 00:14:43,670
gloss over some of the complications

00:14:40,940 --> 00:14:45,710
around kinds kinds are not just about

00:14:43,670 --> 00:14:48,440
numbers of type parameters they're also

00:14:45,710 --> 00:14:50,210
about every time you introduce a bound

00:14:48,440 --> 00:14:53,480
on the type parameter you generate a new

00:14:50,210 --> 00:14:55,790
kind and the existing sort of generic

00:14:53,480 --> 00:14:59,630
generic one are not going to be able to

00:14:55,790 --> 00:15:01,280
derive instances for you for types which

00:14:59,630 --> 00:15:04,460
have type parameters which have which

00:15:01,280 --> 00:15:06,190
have bounds it's not even a question of

00:15:04,460 --> 00:15:09,170
going to sort of generic two three four

00:15:06,190 --> 00:15:11,780
you could have generic one

00:15:09,170 --> 00:15:13,430
but it's single type parameter might not

00:15:11,780 --> 00:15:15,320
be simple it might instead of being a

00:15:13,430 --> 00:15:17,810
type of a type parameter of kind star

00:15:15,320 --> 00:15:20,390
might itself be a type parameter of

00:15:17,810 --> 00:15:22,160
current star arrow star now this might

00:15:20,390 --> 00:15:23,390
sound like it's a little bit abstruse

00:15:22,160 --> 00:15:25,160
but actually there are some really

00:15:23,390 --> 00:15:27,199
really nice very simple quite

00:15:25,160 --> 00:15:30,440
handling examples of things that you

00:15:27,199 --> 00:15:32,779
might want to do with deriving a type

00:15:30,440 --> 00:15:34,759
class for for a type with a hole in it

00:15:32,779 --> 00:15:36,920
of that shape again this is not

00:15:34,759 --> 00:15:40,069
currently represented with shapeless

00:15:36,920 --> 00:15:41,839
generic one and so kinds is about a

00:15:40,069 --> 00:15:43,610
little bit more than just number of type

00:15:41,839 --> 00:15:45,649
parameters it's about bounds and it's

00:15:43,610 --> 00:15:47,449
about the kinds of the type parameters

00:15:45,649 --> 00:15:50,600
themselves and recursively so on down

00:15:47,449 --> 00:15:52,730
and and then the problem when you

00:15:50,600 --> 00:15:54,410
actually look at this is how can we

00:15:52,730 --> 00:15:56,149
support this using the model that that I

00:15:54,410 --> 00:15:58,189
just demonstrated with with you know

00:15:56,149 --> 00:15:58,670
generic generic one and so on and so

00:15:58,189 --> 00:16:00,500
forth

00:15:58,670 --> 00:16:04,269
you just end up with an endless an

00:16:00,500 --> 00:16:08,269
endless proliferation of different

00:16:04,269 --> 00:16:10,009
shaped generic type classes which differ

00:16:08,269 --> 00:16:14,000
only in the kinds of their arguments and

00:16:10,009 --> 00:16:16,339
and and the and and and and the precise

00:16:14,000 --> 00:16:18,620
polymorphism of the methods mapping to

00:16:16,339 --> 00:16:20,149
and from representations and it's

00:16:18,620 --> 00:16:22,550
something you can kind of just about

00:16:20,149 --> 00:16:24,110
live within a library because you know

00:16:22,550 --> 00:16:25,790
libraries are things which can grow in a

00:16:24,110 --> 00:16:27,889
relatively incremental and ad-hoc kind

00:16:25,790 --> 00:16:29,810
of way and but I think if we're thinking

00:16:27,889 --> 00:16:31,639
about sort of adding adding jarrett and

00:16:29,810 --> 00:16:33,829
generic or something like generic as a

00:16:31,639 --> 00:16:35,870
language feature i don't think that's

00:16:33,829 --> 00:16:37,399
acceptable i think i think a language

00:16:35,870 --> 00:16:39,740
primitive has to be something which is

00:16:37,399 --> 00:16:43,370
which is reasonably sort of complete and

00:16:39,740 --> 00:16:45,649
coherent and orthogonal and and it's not

00:16:43,370 --> 00:16:48,939
the kind of thing we can't for example I

00:16:45,649 --> 00:16:53,660
think introduce you know generic generic

00:16:48,939 --> 00:16:56,660
one in in in in in Scala or in dot e and

00:16:53,660 --> 00:16:58,250
then and then six months later so decide

00:16:56,660 --> 00:17:00,860
we have to introduce another another

00:16:58,250 --> 00:17:01,819
family of shapes for generics I think we

00:17:00,860 --> 00:17:07,010
need to come up with some kind of

00:17:01,819 --> 00:17:09,429
mechanism which which which enables us

00:17:07,010 --> 00:17:12,439
to kind of cover all of these things and

00:17:09,429 --> 00:17:15,860
okay so can we abstract away the

00:17:12,439 --> 00:17:17,720
differences between the kinds so the

00:17:15,860 --> 00:17:19,429
very first hurdle we hit and it's and

00:17:17,720 --> 00:17:20,720
it's it's incredibly frustrating in a

00:17:19,429 --> 00:17:23,510
way is that there is literally nowhere

00:17:20,720 --> 00:17:31,659
in a scarlet program and that you can

00:17:23,510 --> 00:17:31,659
put types of different kinds I if you

00:17:32,530 --> 00:17:40,820
you kind of want to write code which

00:17:34,970 --> 00:17:42,680
which looks like we're simply applying

00:17:40,820 --> 00:17:45,500
some type constructor to some other type

00:17:42,680 --> 00:17:47,690
and want to be able to fill the hole in

00:17:45,500 --> 00:17:50,360
the outer type constructor with types

00:17:47,690 --> 00:17:54,310
with you know in the example there

00:17:50,360 --> 00:17:56,510
either kind star or star arrow star

00:17:54,310 --> 00:17:59,600
there is no where there's no way to know

00:17:56,510 --> 00:18:01,370
whether it can be done and so what do we

00:17:59,600 --> 00:18:03,920
do about this I mean it seems like we

00:18:01,370 --> 00:18:07,730
free you know we fit hits hit an

00:18:03,920 --> 00:18:09,980
impassable barrier well not really I

00:18:07,730 --> 00:18:14,450
mean we can we can we can sort of try to

00:18:09,980 --> 00:18:17,840
encode our way around this problem what

00:18:14,450 --> 00:18:25,250
we can do is given we don't have any way

00:18:17,840 --> 00:18:27,260
of creating a single hole which will

00:18:25,250 --> 00:18:29,120
take all types of all kinds but we can

00:18:27,260 --> 00:18:30,740
create a feel like a family of holes we

00:18:29,120 --> 00:18:35,990
can create a bunch of wrappers each of

00:18:30,740 --> 00:18:39,740
which takes a argument of a different

00:18:35,990 --> 00:18:41,270
kind and then the result of applying

00:18:39,740 --> 00:18:43,250
that is going to give us a type of kind

00:18:41,270 --> 00:18:45,680
star and we can use that uniformly and

00:18:43,250 --> 00:18:48,340
now obviously you know we're trading off

00:18:45,680 --> 00:18:53,540
generic generic one generic to generic

00:18:48,340 --> 00:18:54,770
3.4 K 0 K 1 K 2 K 3 dot dot okay have we

00:18:53,540 --> 00:18:56,030
actually wanted to think well in a way

00:18:54,770 --> 00:18:59,030
we have because because this is

00:18:56,030 --> 00:19:01,460
completely universal we can use this in

00:18:59,030 --> 00:19:04,370
many contexts generic is one very

00:19:01,460 --> 00:19:05,570
specific type class we might want to be

00:19:04,370 --> 00:19:09,410
able to reuse this infrastructure

00:19:05,570 --> 00:19:10,730
somewhere else it's this is certainly

00:19:09,410 --> 00:19:12,650
the kind of thing that we could imagine

00:19:10,730 --> 00:19:14,450
synthesizing very simply it's maybe not

00:19:12,650 --> 00:19:15,890
so straightforward to imagine how we

00:19:14,450 --> 00:19:17,510
would do that sort of baked into a more

00:19:15,890 --> 00:19:19,400
complex more articulated tight class

00:19:17,510 --> 00:19:22,130
like Generic well let's let's let's kind

00:19:19,400 --> 00:19:24,380
of see how where this goes so one thing

00:19:22,130 --> 00:19:25,670
it doesn't give you okay we can we can

00:19:24,380 --> 00:19:27,440
do that but we also need to somehow

00:19:25,670 --> 00:19:29,990
other model type application because if

00:19:27,440 --> 00:19:38,330
you remember back a bit earlier when we

00:19:29,990 --> 00:19:40,220
were looking at the this generic one

00:19:38,330 --> 00:19:41,510
representation we also notice that we

00:19:40,220 --> 00:19:43,670
actually have something that looks a bit

00:19:41,510 --> 00:19:45,980
like well what it is type application

00:19:43,670 --> 00:19:49,990
we're applying the

00:19:45,980 --> 00:19:55,640
presentation type constructs a to to the

00:19:49,990 --> 00:19:56,750
to the to the the inner type so we've

00:19:55,640 --> 00:19:58,970
got we've got to be able to do something

00:19:56,750 --> 00:20:01,580
like type applications so let's see if

00:19:58,970 --> 00:20:07,700
we can model it and we can try and model

00:20:01,580 --> 00:20:11,620
it via via a viral GA DT so we're just

00:20:07,700 --> 00:20:14,330
going to capture the application of a

00:20:11,620 --> 00:20:17,270
type of kind start r2 to know type

00:20:14,330 --> 00:20:19,730
parameters via and apply what apply zero

00:20:17,270 --> 00:20:22,490
we're going to capture the idea of

00:20:19,730 --> 00:20:27,740
applying a type of kind star arrow star

00:20:22,490 --> 00:20:29,360
to a single type of kind star via an

00:20:27,740 --> 00:20:30,740
applied one and so on I think so again

00:20:29,360 --> 00:20:31,880
we've got we've got this we've got this

00:20:30,740 --> 00:20:35,410
this this sort of parallel

00:20:31,880 --> 00:20:38,150
infrastructure of type applications and

00:20:35,410 --> 00:20:39,799
then you know you can you can you can

00:20:38,150 --> 00:20:43,880
you can kind of you can kind of make

00:20:39,799 --> 00:20:45,740
this work in terms of in terms of GHz

00:20:43,880 --> 00:20:46,790
pattern matching sort of lurking away in

00:20:45,740 --> 00:20:48,500
the implementation of the thing

00:20:46,790 --> 00:20:50,990
hopefully we're no end users are

00:20:48,500 --> 00:20:53,390
actually going to have to see it okay so

00:20:50,990 --> 00:20:55,610
this gives us a replic which is going to

00:20:53,390 --> 00:20:56,870
end up looking like that so this is the

00:20:55,610 --> 00:21:00,110
thing to compare with what I showed you

00:20:56,870 --> 00:21:02,380
just earlier for the generic one so this

00:21:00,110 --> 00:21:07,250
is this is something which will apply

00:21:02,380 --> 00:21:09,230
two types of kind star types of client

00:21:07,250 --> 00:21:10,700
star array star and so forth and we

00:21:09,230 --> 00:21:13,520
could imagine generalizing this and

00:21:10,700 --> 00:21:16,549
producing generics off of arbitrary

00:21:13,520 --> 00:21:18,440
coins in this way okay I can I can I can

00:21:16,549 --> 00:21:24,220
show you some code for this as well so

00:21:18,440 --> 00:21:30,230
this this does actually work so this is

00:21:24,220 --> 00:21:32,059
code it was this one so I'm just going

00:21:30,230 --> 00:21:34,010
to show you so we can see how this this

00:21:32,059 --> 00:21:36,290
kind of works here so this is this

00:21:34,010 --> 00:21:38,840
before we just had generic of cat so now

00:21:36,290 --> 00:21:40,520
we have generic of k0 of cat and that

00:21:38,840 --> 00:21:41,840
works out the same the functor stuff as

00:21:40,520 --> 00:21:43,429
far as the end user is concerned looks

00:21:41,840 --> 00:21:48,679
identical because actually all of the

00:21:43,429 --> 00:21:54,200
governs relating to the the kinds of of

00:21:48,679 --> 00:21:55,340
the types being being derived for it's

00:21:54,200 --> 00:21:57,890
actually hidden away the derivation

00:21:55,340 --> 00:21:59,010
itself however the derivation ends up

00:21:57,890 --> 00:22:03,900
looking quite

00:21:59,010 --> 00:22:04,320
a bit uglier we end up with well maybe

00:22:03,900 --> 00:22:05,670
not

00:22:04,320 --> 00:22:11,160
I mean it really only affects the

00:22:05,670 --> 00:22:12,780
generic the generic case of the

00:22:11,160 --> 00:22:14,930
induction where we end up with a whole

00:22:12,780 --> 00:22:19,860
bunch of a whole bunch of rappers

00:22:14,930 --> 00:22:21,410
appearing in the in the context of the

00:22:19,860 --> 00:22:24,620
generic there's some fairly nasty

00:22:21,410 --> 00:22:29,460
implementation in terms of extracting

00:22:24,620 --> 00:22:30,810
extracting the specific operations we

00:22:29,460 --> 00:22:32,580
need we're going to need to be able to

00:22:30,810 --> 00:22:34,980
actually do something with these applies

00:22:32,580 --> 00:22:38,160
so we end up having to use G ADT pad

00:22:34,980 --> 00:22:40,500
matching to to allow us to sort of move

00:22:38,160 --> 00:22:42,360
down the hierarchy of type applications

00:22:40,500 --> 00:22:43,860
to get something i I guess I kind of

00:22:42,360 --> 00:22:46,440
want to skip over the details because

00:22:43,860 --> 00:22:48,630
basically the conclusion I want to come

00:22:46,440 --> 00:22:50,910
to is that it kind of works but it's

00:22:48,630 --> 00:22:54,540
pretty clunky and I'm not sure I would

00:22:50,910 --> 00:23:01,980
particularly want to inflict out on it

00:22:54,540 --> 00:23:03,570
on it on anyone okay so the first hurdle

00:23:01,980 --> 00:23:05,130
that we had is is that there is

00:23:03,570 --> 00:23:09,330
literally nowhere in a scarlet program

00:23:05,130 --> 00:23:11,550
that you can put more several types of

00:23:09,330 --> 00:23:13,290
different kinds so suppose we just

00:23:11,550 --> 00:23:16,380
dropped that restriction suppose we just

00:23:13,290 --> 00:23:19,830
arrange for it to be possible to write a

00:23:16,380 --> 00:23:22,440
whole parameter in a scarlet program

00:23:19,830 --> 00:23:23,880
which can be filled with type arguments

00:23:22,440 --> 00:23:25,140
of different kinds we're not going to

00:23:23,880 --> 00:23:27,360
add any other infrastructure that

00:23:25,140 --> 00:23:29,580
language at all we're going to rely on

00:23:27,360 --> 00:23:31,350
using being able to use type level

00:23:29,580 --> 00:23:33,150
computation of our implicit sin the way

00:23:31,350 --> 00:23:34,620
that that you know is common in

00:23:33,150 --> 00:23:36,060
shapeless and other libraries to do

00:23:34,620 --> 00:23:37,950
anything else that you might want to do

00:23:36,060 --> 00:23:40,320
in particular we're not going to do any

00:23:37,950 --> 00:23:41,880
any any any any any type application

00:23:40,320 --> 00:23:43,950
we're going to stick with the type

00:23:41,880 --> 00:23:44,790
application model that I showed you the

00:23:43,950 --> 00:23:48,930
last time around

00:23:44,790 --> 00:23:51,060
and so Pascal vato who's Manta being on

00:23:48,930 --> 00:23:53,520
Twitter and github and elsewhere and I

00:23:51,060 --> 00:23:55,740
collaborated on on putting together an

00:23:53,520 --> 00:23:58,230
implementation of this in tight level

00:23:55,740 --> 00:24:01,980
Scala I forget how long ago this is kind

00:23:58,230 --> 00:24:03,990
of over a year I think now and it's

00:24:01,980 --> 00:24:05,250
available in tight level Scala we played

00:24:03,990 --> 00:24:06,740
around with it it was it was kind of it

00:24:05,250 --> 00:24:09,889
was a very very interesting experiment

00:24:06,740 --> 00:24:13,979
we end up with this so this is

00:24:09,889 --> 00:24:17,940
excuse me this is this is rather than

00:24:13,979 --> 00:24:21,869
having a bunch of rappers around our

00:24:17,940 --> 00:24:25,169
type arguments now we have these bounds

00:24:21,869 --> 00:24:27,779
of any kind which indicate that the type

00:24:25,169 --> 00:24:30,509
parameters can be filled with with types

00:24:27,779 --> 00:24:31,889
of any kind and you can see in terms of

00:24:30,509 --> 00:24:37,440
the applications further down that we're

00:24:31,889 --> 00:24:39,690
able to construct a generic type

00:24:37,440 --> 00:24:41,849
application with you know types of kind

00:24:39,690 --> 00:24:43,409
star and types of kind star or star so

00:24:41,849 --> 00:24:44,729
it kind of looks like this is a win from

00:24:43,409 --> 00:24:48,229
a sort of syntactic point of view it

00:24:44,729 --> 00:24:51,570
kind of seems it seems reasonably nice

00:24:48,229 --> 00:24:55,440
we're still encoding poly kind of type

00:24:51,570 --> 00:24:57,749
application as you can see up in the as

00:24:55,440 --> 00:25:01,499
the the arguments and the result types

00:24:57,749 --> 00:25:03,149
of the two and Fromme methods but the

00:25:01,499 --> 00:25:04,409
the sort of the mechanics there have

00:25:03,149 --> 00:25:08,149
become a little bit simpler because we

00:25:04,409 --> 00:25:12,119
can now make the the type application

00:25:08,149 --> 00:25:15,839
data type itself poly kind it so we can

00:25:12,119 --> 00:25:17,549
give it a bound of any kind on its type

00:25:15,839 --> 00:25:21,119
argument and this this kind of makes

00:25:17,549 --> 00:25:28,589
things a little bit simpler the demo

00:25:21,119 --> 00:25:30,359
well in terms of end user code it's

00:25:28,589 --> 00:25:31,529
looking it's looking pretty simple as

00:25:30,359 --> 00:25:33,419
pretty is looking pretty similar now

00:25:31,529 --> 00:25:39,690
we're back to more or less where we were

00:25:33,419 --> 00:25:42,080
with the the initial boilerplate see

00:25:39,690 --> 00:25:46,169
generic case we no longer have to wrap

00:25:42,080 --> 00:25:47,820
the wrap the cat in a in a k0 so we can

00:25:46,169 --> 00:25:48,839
just work with that directly in terms of

00:25:47,820 --> 00:25:50,909
the function well again that was all

00:25:48,839 --> 00:25:52,889
what that was always hidden away in the

00:25:50,909 --> 00:25:54,589
derivation but now if you look at the

00:25:52,889 --> 00:25:57,029
derivation where we have the generic

00:25:54,589 --> 00:25:58,559
therefore the functor again this looks

00:25:57,029 --> 00:26:02,070
this looks this looks quite a bit nicer

00:25:58,559 --> 00:26:03,809
and it doesn't it doesn't

00:26:02,070 --> 00:26:06,210
I mean it's safe to some work I mean

00:26:03,809 --> 00:26:09,509
we've we've we've we've traded off some

00:26:06,210 --> 00:26:11,729
wrappers for some bounds of any kind we

00:26:09,509 --> 00:26:13,409
still have we still have this this type

00:26:11,729 --> 00:26:17,099
application problem that we have to deal

00:26:13,409 --> 00:26:18,869
with and there are still some vaguely

00:26:17,099 --> 00:26:22,589
related type inference problems to deal

00:26:18,869 --> 00:26:23,149
with so the conclusion that we came to

00:26:22,589 --> 00:26:26,419
was the

00:26:23,149 --> 00:26:28,789
it was a little bit better it was still

00:26:26,419 --> 00:26:31,129
pretty clunky and we kind of decided

00:26:28,789 --> 00:26:32,809
that's actually we were going to park it

00:26:31,129 --> 00:26:34,570
and think about it's a bit more a bit

00:26:32,809 --> 00:26:36,499
more see if we could come up with

00:26:34,570 --> 00:26:40,369
something maybe a little bit more

00:26:36,499 --> 00:26:41,690
elaborate and see if we could actually

00:26:40,369 --> 00:26:43,190
get something that was a bit more

00:26:41,690 --> 00:26:45,799
compelling than this I mean that that

00:26:43,190 --> 00:26:47,210
offered a bit mortar to end-users than

00:26:45,799 --> 00:26:49,940
just just a little bit of syntactic

00:26:47,210 --> 00:26:51,889
cleanup and and I I think we were also

00:26:49,940 --> 00:26:55,489
sort of fairly convinced that that the

00:26:51,889 --> 00:26:57,379
benefits weren't sufficient to really be

00:26:55,489 --> 00:26:58,969
that compelling in terms of persuading I

00:26:57,379 --> 00:27:02,059
don't know Adrian that he might actually

00:26:58,969 --> 00:27:03,739
want to merge this stuff it just didn't

00:27:02,059 --> 00:27:07,339
feel to us as though it was sufficiently

00:27:03,739 --> 00:27:10,940
sufficiently sufficiently compelling and

00:27:07,339 --> 00:27:15,219
offering enough that that there was too

00:27:10,940 --> 00:27:19,099
much prospect of that happening but then

00:27:15,219 --> 00:27:21,679
very recently I I forget how long ago I

00:27:19,099 --> 00:27:24,200
mean is this Yuri if it wasn't this year

00:27:21,679 --> 00:27:27,669
as the end of last year Martin announced

00:27:24,200 --> 00:27:30,409
that he was adopting it in dotty the

00:27:27,669 --> 00:27:33,229
initial implementation is actually very

00:27:30,409 --> 00:27:35,359
similar to the one that landed in tight

00:27:33,229 --> 00:27:36,440
levels Carla at least superficially I

00:27:35,359 --> 00:27:39,080
mean it's for us to see the surface

00:27:36,440 --> 00:27:40,399
syntax is concerned it's actually there

00:27:39,080 --> 00:27:44,210
are some really really interesting

00:27:40,399 --> 00:27:48,109
reasons why why why Martin has gone down

00:27:44,210 --> 00:27:49,159
this route I I recommend you button

00:27:48,109 --> 00:27:51,289
holding him and ask him about it

00:27:49,159 --> 00:27:53,509
directly but it's it's it actually turns

00:27:51,289 --> 00:27:56,359
out that it serves the particular model

00:27:53,509 --> 00:27:57,529
that we ended up with actually actually

00:27:56,359 --> 00:28:00,109
fills quite a nice little space

00:27:57,529 --> 00:28:02,299
internally in the implementation of the

00:28:00,109 --> 00:28:04,279
dossie compiler and also with respect to

00:28:02,299 --> 00:28:08,839
some of the theory in the doc calculus

00:28:04,279 --> 00:28:11,989
it turns out that you can the way that

00:28:08,839 --> 00:28:14,210
you can model kinds via subtyping means

00:28:11,989 --> 00:28:17,629
that you can recover a sort of a

00:28:14,210 --> 00:28:20,479
universal a universal top type which i

00:28:17,629 --> 00:28:23,779
think is something that that Martin had

00:28:20,479 --> 00:28:25,429
been quite keen to have and and this

00:28:23,779 --> 00:28:27,440
actually provided quite a quite quite a

00:28:25,429 --> 00:28:30,440
nice elegant way of doing it and and

00:28:27,440 --> 00:28:32,479
gets a sort of small at least mildly

00:28:30,440 --> 00:28:34,749
interesting language feature inste

00:28:32,479 --> 00:28:34,749
bargain

00:28:34,800 --> 00:28:41,280
so as far as III don't think as it as it

00:28:39,570 --> 00:28:43,440
has appeared in Dottie it doesn't take

00:28:41,280 --> 00:28:45,920
us any further along than the last

00:28:43,440 --> 00:28:52,220
example I showed you with the version as

00:28:45,920 --> 00:28:56,160
as as developed in tight level Scala but

00:28:52,220 --> 00:28:57,420
it has at least revived are interesting

00:28:56,160 --> 00:29:01,680
in trying to push a little bit further

00:28:57,420 --> 00:29:03,360
and see if we can get get any make any

00:29:01,680 --> 00:29:07,650
more headway with with coming up with

00:29:03,360 --> 00:29:10,170
with something which would actually make

00:29:07,650 --> 00:29:12,060
for a sort of more generally compelling

00:29:10,170 --> 00:29:14,940
language feature that that actually

00:29:12,060 --> 00:29:16,320
offers more significant benefits to to

00:29:14,940 --> 00:29:17,760
end-users as well as the sort of the

00:29:16,320 --> 00:29:20,520
internal and the or ethical ones that

00:29:17,760 --> 00:29:22,200
that clearly it has for Dottie you know

00:29:20,520 --> 00:29:24,540
we've we've been given an inch so let's

00:29:22,200 --> 00:29:28,200
let's and see if we can take at least

00:29:24,540 --> 00:29:31,230
the yard or two anyway so the first

00:29:28,200 --> 00:29:33,030
hurdle was there's no way to put types

00:29:31,230 --> 00:29:35,580
of different kinds the second hurdle was

00:29:33,030 --> 00:29:44,340
type application so can we can we do

00:29:35,580 --> 00:29:46,830
something with that suppose I mean if I

00:29:44,340 --> 00:29:48,330
mean obviously the apply the applied

00:29:46,830 --> 00:29:50,580
type constructor there is is literally

00:29:48,330 --> 00:29:52,440
you know apply of wrapper to I is really

00:29:50,580 --> 00:29:55,170
is really just meant to represent the

00:29:52,440 --> 00:29:57,810
idea of that we are applying the wrapper

00:29:55,170 --> 00:30:00,900
type constructor to the I type arguments

00:29:57,810 --> 00:30:05,310
whatever they turn out to be can we just

00:30:00,900 --> 00:30:07,020
do that directly why not so the

00:30:05,310 --> 00:30:09,540
interesting thing is actually not so

00:30:07,020 --> 00:30:11,550
much what happens in the in the generic

00:30:09,540 --> 00:30:13,980
trace itself but what happens in the

00:30:11,550 --> 00:30:15,060
implementations where these these are

00:30:13,980 --> 00:30:16,230
things which are synthesized by the

00:30:15,060 --> 00:30:20,370
compiler they're not typically written

00:30:16,230 --> 00:30:22,560
by hand and but we have to have some

00:30:20,370 --> 00:30:23,910
mechanism for providing you know given

00:30:22,560 --> 00:30:26,930
that I'm asking for a generic of some

00:30:23,910 --> 00:30:29,790
particular type actually producing an

00:30:26,930 --> 00:30:31,470
implementation of that of that type in a

00:30:29,790 --> 00:30:35,600
way which which satisfies the

00:30:31,470 --> 00:30:38,490
constraints of the of the generic trait

00:30:35,600 --> 00:30:44,450
so we need to come up with some kind of

00:30:38,490 --> 00:30:46,620
model which allows these these

00:30:44,450 --> 00:30:47,920
definitions in the and the in the

00:30:46,620 --> 00:30:49,570
specific sub

00:30:47,920 --> 00:30:53,710
type of generic corresponding to box

00:30:49,570 --> 00:30:55,720
here to actually provide the

00:30:53,710 --> 00:30:57,940
implementation for the the types in the

00:30:55,720 --> 00:31:01,570
in the in the generic suit in the

00:30:57,940 --> 00:31:03,130
generic traits and what would actually

00:31:01,570 --> 00:31:05,110
almost certainly end up happening is

00:31:03,130 --> 00:31:07,090
that we end up with synthesized bridge

00:31:05,110 --> 00:31:09,130
methods somewhere or other which which

00:31:07,090 --> 00:31:10,750
we're kind of familiar with from from

00:31:09,130 --> 00:31:12,910
the implementation of a specialization

00:31:10,750 --> 00:31:15,580
and and the implementation of tracing

00:31:12,910 --> 00:31:18,600
coding in in the Scylla compiler anyway

00:31:15,580 --> 00:31:22,170
so I think something along those lines

00:31:18,600 --> 00:31:24,910
can almost certainly be made to work

00:31:22,170 --> 00:31:26,470
this is this is this is this is barely

00:31:24,910 --> 00:31:27,730
even working progress from my point of

00:31:26,470 --> 00:31:31,720
view yet but I think I think it's

00:31:27,730 --> 00:31:33,610
something that I think we could actually

00:31:31,720 --> 00:31:35,080
there's a typo there that's that should

00:31:33,610 --> 00:31:37,060
actually just say generic rather than

00:31:35,080 --> 00:31:40,380
generic one because it is supposed to be

00:31:37,060 --> 00:31:44,320
extending this but ignore ignore that

00:31:40,380 --> 00:31:45,430
detail so what would just what would

00:31:44,320 --> 00:31:51,760
this work with this what would this do

00:31:45,430 --> 00:31:54,820
for us so we can have a quick peek at so

00:31:51,760 --> 00:31:56,350
this is the extended version so in terms

00:31:54,820 --> 00:31:58,870
of in terms of what end-users see

00:31:56,350 --> 00:32:05,200
actually very little difference in terms

00:31:58,870 --> 00:32:06,640
of what implementers of generic

00:32:05,200 --> 00:32:08,260
programming infrastructure like type

00:32:06,640 --> 00:32:09,340
cross derivation see they basically some

00:32:08,260 --> 00:32:11,410
that see something which is which is

00:32:09,340 --> 00:32:16,050
which is quite significantly simpler all

00:32:11,410 --> 00:32:19,690
of the apply and type apply

00:32:16,050 --> 00:32:21,010
infrastructure just goes away I think

00:32:19,690 --> 00:32:25,210
there are some almost certainly some

00:32:21,010 --> 00:32:26,740
possibilities for simplifications of

00:32:25,210 --> 00:32:30,400
type inference issues as well which I

00:32:26,740 --> 00:32:35,200
think are worthwhile having and so I

00:32:30,400 --> 00:32:36,820
guess I guess I guess there's a still an

00:32:35,200 --> 00:32:40,780
open question lurking in the background

00:32:36,820 --> 00:32:42,130
about given that actually after I think

00:32:40,780 --> 00:32:44,110
the you know one of the earliest

00:32:42,130 --> 00:32:46,150
iterations that I've been through

00:32:44,110 --> 00:32:47,770
there's not actually that much change in

00:32:46,150 --> 00:32:50,350
the code that an end user our typical

00:32:47,770 --> 00:32:51,370
end user has to write I suppose there is

00:32:50,350 --> 00:32:53,440
there isn't there is a question about

00:32:51,370 --> 00:32:59,040
you know is this this is this is at this

00:32:53,440 --> 00:33:00,720
point it's helping library designers

00:32:59,040 --> 00:33:03,059
somewhat

00:33:00,720 --> 00:33:04,169
it's not really helping end-users very

00:33:03,059 --> 00:33:05,429
much because because most of the

00:33:04,169 --> 00:33:07,739
complexity of this stuff is completely

00:33:05,429 --> 00:33:09,509
hidden from them so I think I think

00:33:07,739 --> 00:33:10,590
there's definitely scope for discussion

00:33:09,509 --> 00:33:12,629
about whether or not that sort of power

00:33:10,590 --> 00:33:16,970
to weight rate weight ratio of the

00:33:12,629 --> 00:33:21,119
language feature is is is quite their

00:33:16,970 --> 00:33:24,299
current status is that there is the type

00:33:21,119 --> 00:33:26,849
level Scala prototype that that I showed

00:33:24,299 --> 00:33:28,139
you earlier on there's the initial dusty

00:33:26,849 --> 00:33:29,279
implementation which I think from the

00:33:28,139 --> 00:33:33,090
point of view of actually playing around

00:33:29,279 --> 00:33:35,369
with should be a similar similar I think

00:33:33,090 --> 00:33:38,999
in terms of to the type level scalar

00:33:35,369 --> 00:33:40,139
implementation from the point of view of

00:33:38,999 --> 00:33:41,820
actually aligning the two

00:33:40,139 --> 00:33:43,229
implementations there's there's quite a

00:33:41,820 --> 00:33:46,799
lot of details in terms of the sort of

00:33:43,229 --> 00:33:48,840
the internals which I think it would be

00:33:46,799 --> 00:33:52,409
very useful to back port from dotty to

00:33:48,840 --> 00:33:54,479
Scala and and hopefully as as part of

00:33:52,409 --> 00:33:56,220
her the process of actually bringing the

00:33:54,479 --> 00:33:59,879
light that that language feature to to

00:33:56,220 --> 00:34:01,679
light meant Scala and then I think then

00:33:59,879 --> 00:34:03,179
I think I think there's lots of scope

00:34:01,679 --> 00:34:06,389
for people to experiment with poly kind

00:34:03,179 --> 00:34:08,010
of application as well and this is the

00:34:06,389 --> 00:34:10,079
kind of stuff that needs a sip so so

00:34:08,010 --> 00:34:12,149
there needs to be some kind of fairly

00:34:10,079 --> 00:34:13,980
fairly rigorous description of exactly

00:34:12,149 --> 00:34:15,029
what the language feature is and how it

00:34:13,980 --> 00:34:17,520
works

00:34:15,029 --> 00:34:24,929
I kind of feel as though as though as

00:34:17,520 --> 00:34:27,829
though the the the range of

00:34:24,929 --> 00:34:30,480
possibilities we've got here are as yet

00:34:27,829 --> 00:34:33,029
unclear I mean I think I think I think

00:34:30,480 --> 00:34:35,069
it may turn out that that kind

00:34:33,029 --> 00:34:37,200
polymorphism will have similar kinds of

00:34:35,069 --> 00:34:39,659
effects as the introduction of higher

00:34:37,200 --> 00:34:41,429
kind of types had in as much as I think

00:34:39,659 --> 00:34:45,569
the very first examples we saw of higher

00:34:41,429 --> 00:34:47,159
kind of types were they look nice but

00:34:45,569 --> 00:34:49,470
they seem to be relatively limited in

00:34:47,159 --> 00:34:50,940
scope and I think it took quite a few

00:34:49,470 --> 00:34:52,079
years of experience with how to kind of

00:34:50,940 --> 00:34:54,000
types to realize that they're actually a

00:34:52,079 --> 00:34:55,169
very very large range of applications

00:34:54,000 --> 00:34:58,470
for these things I think the same thing

00:34:55,169 --> 00:35:01,109
is going to drop out of a kind polymer

00:34:58,470 --> 00:35:02,940
component off ilysm as well I think I

00:35:01,109 --> 00:35:06,329
think I think it's not quite clear

00:35:02,940 --> 00:35:07,619
exactly how far this can go but I think

00:35:06,329 --> 00:35:10,319
I think I think there's there's probably

00:35:07,619 --> 00:35:12,210
just about enough immediately useful

00:35:10,319 --> 00:35:14,030
stuff that's that's that is worth

00:35:12,210 --> 00:35:16,170
pursuing

00:35:14,030 --> 00:35:21,480
okay I actually have a couple of extra

00:35:16,170 --> 00:35:23,070
slides so there's this unusually I've

00:35:21,480 --> 00:35:25,350
actually come in slightly under time

00:35:23,070 --> 00:35:29,790
this is almost unheard of which is great

00:35:25,350 --> 00:35:34,320
I'm actually quite pleased so some of

00:35:29,790 --> 00:35:36,660
the other immediate applications of kind

00:35:34,320 --> 00:35:38,370
polymorphism there's a bunch of little

00:35:36,660 --> 00:35:39,840
little niggly things I don't have people

00:35:38,370 --> 00:35:43,370
would work with things like type you

00:35:39,840 --> 00:35:46,470
know type tags in in the macro API or

00:35:43,370 --> 00:35:50,340
compiler plugins if you want to get hold

00:35:46,470 --> 00:35:54,980
of the type for a of a type constructor

00:35:50,340 --> 00:35:58,500
so a like list and the way you do it is

00:35:54,980 --> 00:36:01,290
typically you you you you ask for a list

00:35:58,500 --> 00:36:02,700
of any or a list of something but that

00:36:01,290 --> 00:36:03,930
of course gets you a type of kind star

00:36:02,700 --> 00:36:05,610
it doesn't get you the type constructor

00:36:03,930 --> 00:36:08,250
so so and it's actually a fairly common

00:36:05,610 --> 00:36:10,680
bug I've seen in multiple to I I have

00:36:08,250 --> 00:36:13,050
committed the bug myself but I've seen

00:36:10,680 --> 00:36:14,340
it in in in other macro using libraries

00:36:13,050 --> 00:36:18,360
that people they want they want they

00:36:14,340 --> 00:36:20,280
want the the internal representation of

00:36:18,360 --> 00:36:23,340
the type of list but they end up with

00:36:20,280 --> 00:36:25,410
the type of you know some list apply to

00:36:23,340 --> 00:36:28,290
some type and they forget to sort of

00:36:25,410 --> 00:36:30,240
poke out the the the the the the inner

00:36:28,290 --> 00:36:32,220
type by by calling type constructor on

00:36:30,240 --> 00:36:33,840
the type they get back and the reason

00:36:32,220 --> 00:36:37,020
for that is that the type of operator

00:36:33,840 --> 00:36:38,730
and the type type tag type class and our

00:36:37,020 --> 00:36:40,860
parameterizing with types of kind star

00:36:38,730 --> 00:36:44,120
there's no way that you can say ask for

00:36:40,860 --> 00:36:47,760
the type of list as present at present

00:36:44,120 --> 00:36:49,560
because because because of precisely the

00:36:47,760 --> 00:36:51,450
same problem that I set up at the

00:36:49,560 --> 00:36:57,410
beginning with generic there's no way of

00:36:51,450 --> 00:37:01,320
writing a definition of a type tag type

00:36:57,410 --> 00:37:04,500
which can accept both lists of int and

00:37:01,320 --> 00:37:08,010
list as its type argument and similarly

00:37:04,500 --> 00:37:09,840
for the type of operator so there's a

00:37:08,010 --> 00:37:12,660
bunch of things that fall into that kind

00:37:09,840 --> 00:37:14,190
of category there's also shape missus

00:37:12,660 --> 00:37:17,450
typable which is a similar kind of thing

00:37:14,190 --> 00:37:19,800
we might want to be able to to ask for

00:37:17,450 --> 00:37:22,520
typable instances both for fully apply

00:37:19,800 --> 00:37:27,710
types and also for type constructors

00:37:22,520 --> 00:37:30,500
um okay I think I wanted to very briefly

00:37:27,710 --> 00:37:31,640
mention this because I think it's

00:37:30,500 --> 00:37:34,100
actually quite an interesting example of

00:37:31,640 --> 00:37:37,340
the kinds of things I'm half expecting

00:37:34,100 --> 00:37:44,300
people will want to experiment with once

00:37:37,340 --> 00:37:46,370
the the sort of the once the sort of

00:37:44,300 --> 00:37:48,620
floodgates are open and and we can we

00:37:46,370 --> 00:37:50,630
can we can play with kinds we can pop be

00:37:48,620 --> 00:37:59,860
polymorphic over over over over all

00:37:50,630 --> 00:38:04,490
kinds how many people in the room

00:37:59,860 --> 00:38:07,280
wrestle with the problem of filling out

00:38:04,490 --> 00:38:09,890
incrementally filling out immutable data

00:38:07,280 --> 00:38:11,930
strikes data structures sort of step by

00:38:09,890 --> 00:38:13,550
step so for example as a result of you

00:38:11,930 --> 00:38:16,520
know filling in an interactive form or

00:38:13,550 --> 00:38:17,270
something along those lines or many

00:38:16,520 --> 00:38:20,180
people do that

00:38:17,270 --> 00:38:22,430
I imagine almost everybody does that in

00:38:20,180 --> 00:38:23,390
some way or another and so there's a

00:38:22,430 --> 00:38:26,450
whole bunch of approaches that people

00:38:23,390 --> 00:38:28,370
people tend to tend to tend to take when

00:38:26,450 --> 00:38:30,080
they do it so one of them is you know

00:38:28,370 --> 00:38:31,420
they wrap everything in option so you

00:38:30,080 --> 00:38:33,470
can rather than having a case class

00:38:31,420 --> 00:38:36,980
representing an order which you know has

00:38:33,470 --> 00:38:40,640
you know an item name and a quantity uuu

00:38:36,980 --> 00:38:42,500
it has an option of a item name and an

00:38:40,640 --> 00:38:46,820
option of a quantity and so forth so you

00:38:42,500 --> 00:38:48,530
can wrap everything an option you can if

00:38:46,820 --> 00:38:49,880
you can you there are the various things

00:38:48,530 --> 00:38:52,730
you could do you maybe have a sort of

00:38:49,880 --> 00:38:53,840
pair of twins data types one which has

00:38:52,730 --> 00:38:55,880
everything wrapped an option and one

00:38:53,840 --> 00:38:57,920
which which is there to represent the

00:38:55,880 --> 00:38:59,030
complete the complete data type once

00:38:57,920 --> 00:39:01,040
once you've got all the elements

00:38:59,030 --> 00:39:03,440
together I know some people who use

00:39:01,040 --> 00:39:06,860
shapeless records to model partial data

00:39:03,440 --> 00:39:08,660
types and one quite nice approach is to

00:39:06,860 --> 00:39:11,260
just parameterize your data type with

00:39:08,660 --> 00:39:14,690
the type constructor so the example here

00:39:11,260 --> 00:39:17,030
is say we've got to say an order data

00:39:14,690 --> 00:39:18,140
type it's parametrized with an F and the

00:39:17,030 --> 00:39:20,570
idea here is that we're going to either

00:39:18,140 --> 00:39:23,960
instantiate F with option or we're going

00:39:20,570 --> 00:39:27,140
to instantiate it with ID ID being that

00:39:23,960 --> 00:39:28,970
the the identity type which we'll just

00:39:27,140 --> 00:39:31,130
take the string sort of idea of string

00:39:28,970 --> 00:39:33,690
is just string so basically the idea is

00:39:31,130 --> 00:39:35,850
that we can we can capture both

00:39:33,690 --> 00:39:38,100
pipes both the types with optional bits

00:39:35,850 --> 00:39:40,620
and the type that's fully completed in

00:39:38,100 --> 00:39:42,480
terms of a parameterised type

00:39:40,620 --> 00:39:45,000
parameterize over a type constructor

00:39:42,480 --> 00:39:48,540
then we end up if we want something like

00:39:45,000 --> 00:39:51,600
a functor because this this this order

00:39:48,540 --> 00:39:53,430
type now has a a it has just one type

00:39:51,600 --> 00:39:56,010
parameter but that type parameter itself

00:39:53,430 --> 00:39:58,650
has a type parameter so this is the

00:39:56,010 --> 00:40:00,900
example of something which is not a type

00:39:58,650 --> 00:40:02,370
of kind start iro star even though it

00:40:00,900 --> 00:40:04,050
only has a single type parameter so this

00:40:02,370 --> 00:40:08,040
cannot currently be represented by shape

00:40:04,050 --> 00:40:09,300
this is generic one and so functor K so

00:40:08,040 --> 00:40:12,750
this is something which is which is

00:40:09,300 --> 00:40:16,110
being proposed to as a new type class

00:40:12,750 --> 00:40:19,320
for cars sometimes known as H functor in

00:40:16,110 --> 00:40:20,910
the in the Haskell world basically it's

00:40:19,320 --> 00:40:24,390
like a functor only instead of a map

00:40:20,910 --> 00:40:26,880
which takes a simple function it has a

00:40:24,390 --> 00:40:28,470
map K which takes a natural

00:40:26,880 --> 00:40:31,620
transformation so a natural

00:40:28,470 --> 00:40:33,150
transformation for example excuse me a

00:40:31,620 --> 00:40:34,800
natural transformation is something

00:40:33,150 --> 00:40:40,860
which would which would for example take

00:40:34,800 --> 00:40:44,700
an option of T onto an ID of T okay and

00:40:40,860 --> 00:40:48,600
if we do that and you just quickly show

00:40:44,700 --> 00:40:50,330
you this we can do things like this so

00:40:48,600 --> 00:40:53,730
if we can if we could if we could derive

00:40:50,330 --> 00:40:56,580
automatically a functor K instance for

00:40:53,730 --> 00:40:59,670
our order type we'd be able to for

00:40:56,580 --> 00:41:01,260
example given this this this so this is

00:40:59,670 --> 00:41:02,550
an option type with a default so this is

00:41:01,260 --> 00:41:03,960
this is how I can actually define an

00:41:02,550 --> 00:41:05,760
actual transformation for another from a

00:41:03,960 --> 00:41:10,590
lot foreign or from an option like thing

00:41:05,760 --> 00:41:12,390
to it to ID so option option with the

00:41:10,590 --> 00:41:15,210
default in either has a given value or a

00:41:12,390 --> 00:41:18,690
default value and a fault which is going

00:41:15,210 --> 00:41:20,130
to take basically the either the given

00:41:18,690 --> 00:41:23,550
or the default value and give you that

00:41:20,130 --> 00:41:26,850
back wrapped in ID so if I now have a

00:41:23,550 --> 00:41:29,310
functor K instance for order then I can

00:41:26,850 --> 00:41:32,160
just map over that value to take a

00:41:29,310 --> 00:41:34,320
partial value and turn it into a

00:41:32,160 --> 00:41:35,640
completed value in ID and I think that's

00:41:34,320 --> 00:41:37,470
kind of interesting I think that's kind

00:41:35,640 --> 00:41:40,020
of quite a nice quite a nice little

00:41:37,470 --> 00:41:42,090
thing to drop out of being able to do

00:41:40,020 --> 00:41:43,890
generic programming over-over types of

00:41:42,090 --> 00:41:45,970
different shapes

00:41:43,890 --> 00:41:47,590
okay I'm gonna leave it there I don't

00:41:45,970 --> 00:41:49,540
know how much time there is if any left

00:41:47,590 --> 00:42:03,340
for questions but if there is any I'm

00:41:49,540 --> 00:42:06,490
happy to take questions now we do have

00:42:03,340 --> 00:42:08,140
time left for questions um just give us

00:42:06,490 --> 00:42:14,950
a second to reach your hand over the

00:42:08,140 --> 00:42:18,820
microphone hi so my question is you've

00:42:14,950 --> 00:42:21,010
shown that it works for types of kinds

00:42:18,820 --> 00:42:28,360
to start a star to star but it would

00:42:21,010 --> 00:42:30,460
also work for kinds of well types that

00:42:28,360 --> 00:42:32,680
take multiple type parameters so for

00:42:30,460 --> 00:42:34,180
example map and yeah absolutely works in

00:42:32,680 --> 00:42:35,320
fact we can make it work with the with

00:42:34,180 --> 00:42:37,060
the encoding even without kind

00:42:35,320 --> 00:42:37,980
polymorphism it's it's clunky but you

00:42:37,060 --> 00:42:40,090
can make it work

00:42:37,980 --> 00:42:43,120
there's a whole bunch of so that the

00:42:40,090 --> 00:42:46,690
type of the type apply stuff depends on

00:42:43,120 --> 00:42:49,240
GA DTS and as you know there are bugs

00:42:46,690 --> 00:42:53,200
enjoy duties for the the example I just

00:42:49,240 --> 00:42:54,610
showed you I had to do some slightly

00:42:53,200 --> 00:42:57,730
ugly things to make it actually work

00:42:54,610 --> 00:43:00,730
with so this weird thing with a nested

00:42:57,730 --> 00:43:03,070
type parameter which is not not simple

00:43:00,730 --> 00:43:04,690
not unifying nicely with the jtt power

00:43:03,070 --> 00:43:06,280
mode but that's basically the idea you

00:43:04,690 --> 00:43:08,940
see bug fix so you know that's that's

00:43:06,280 --> 00:43:11,940
kind of it in principle it works okay

00:43:08,940 --> 00:43:11,940
thanks

00:43:23,000 --> 00:43:28,110
Martin mentioned yesterday there will be

00:43:25,200 --> 00:43:31,440
a tie plant the support in dhoti so I

00:43:28,110 --> 00:43:34,290
wonder because you use the type lambdas

00:43:31,440 --> 00:43:36,870
in implement in the apply something

00:43:34,290 --> 00:43:38,940
wouldn't be enough maybe to have better

00:43:36,870 --> 00:43:40,650
type Landers no not really I mean it

00:43:38,940 --> 00:43:41,940
would help a little bit it would get

00:43:40,650 --> 00:43:43,740
I've said there is there was some tight

00:43:41,940 --> 00:43:46,350
line of the syntax in in some of the

00:43:43,740 --> 00:43:47,730
files that was passed you it would it

00:43:46,350 --> 00:43:50,040
would simplify those bits but it doesn't

00:43:47,730 --> 00:43:52,110
solve the essential problem yeah it's

00:43:50,040 --> 00:43:52,680
nice to have I I want that as soon as

00:43:52,110 --> 00:43:53,810
possible

00:43:52,680 --> 00:43:56,250
it doesn't solve the whole problem

00:43:53,810 --> 00:43:58,950
unfortunately it would be nice if you

00:43:56,250 --> 00:44:01,710
did I think I'm actually opaque types

00:43:58,950 --> 00:44:04,020
and do help in fact so in fact some of

00:44:01,710 --> 00:44:08,250
those type lambdas so there's a tuple to

00:44:04,020 --> 00:44:10,680
a tuple to K type that's that's used

00:44:08,250 --> 00:44:14,010
there actually that really ought to be

00:44:10,680 --> 00:44:15,900
just just an opaque type over a pair and

00:44:14,010 --> 00:44:17,040
in fact sews it 35 opaque types will

00:44:15,900 --> 00:44:25,650
actually make a bunch of that stuff go

00:44:17,040 --> 00:44:32,300
away and that would be very nice any

00:44:25,650 --> 00:44:32,300
other questions one last question

00:44:34,099 --> 00:44:42,950
hi is there any other language that

00:44:37,800 --> 00:44:47,609
support Kaipo kind permit polymorphism

00:44:42,950 --> 00:44:49,859
Haskell it's one of the you know one of

00:44:47,609 --> 00:44:53,040
the many language extensions you can

00:44:49,859 --> 00:44:56,970
enable and if they do you think their

00:44:53,040 --> 00:44:58,170
solution user well thinks things are

00:44:56,970 --> 00:45:01,020
actually slightly different for Haskell

00:44:58,170 --> 00:45:04,140
actually and one of the reasons is that

00:45:01,020 --> 00:45:05,730
they don't have what a big problem that

00:45:04,140 --> 00:45:07,440
we've got is that we have many many more

00:45:05,730 --> 00:45:09,900
kinds than Haskell does because we have

00:45:07,440 --> 00:45:12,569
we have bounds every time you introduced

00:45:09,900 --> 00:45:14,310
bound you produce a new kind which means

00:45:12,569 --> 00:45:17,099
that actually even some very very simple

00:45:14,310 --> 00:45:18,630
looking things which you would expect to

00:45:17,099 --> 00:45:20,579
be very very basic polymorphism actually

00:45:18,630 --> 00:45:22,770
turn out to be things that you require

00:45:20,579 --> 00:45:24,990
either you know multi multiple multiple

00:45:22,770 --> 00:45:26,460
methods with different bounds or ideally

00:45:24,990 --> 00:45:28,109
you would you would want to be able to

00:45:26,460 --> 00:45:29,700
abstract over them and this this this

00:45:28,109 --> 00:45:32,310
model would allow you to abstract over

00:45:29,700 --> 00:45:33,450
bounce in the same way so I think I

00:45:32,310 --> 00:45:35,550
think we actually have a slightly worse

00:45:33,450 --> 00:45:36,990
problem the Haskell does and I think

00:45:35,550 --> 00:45:39,500
this this this potentially works quite

00:45:36,990 --> 00:45:39,500

YouTube URL: https://www.youtube.com/watch?v=v6e7rYOXdcM


