Title: Building a reactive multi user document editor in ScalaJS by Jan Ypma
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-7143-building-a-reactive-multi-user-document-editor-in-scalajs.html
Captions: 
	00:00:09,560 --> 00:00:14,720
I think he'll for coming my name is

00:00:12,650 --> 00:00:19,130
young Emma and today I'll be talking

00:00:14,720 --> 00:00:22,970
about applying the reactive paragraph

00:00:19,130 --> 00:00:24,860
for the front end so you may have worked

00:00:22,970 --> 00:00:27,310
heard the word reactive over the past

00:00:24,860 --> 00:00:29,689
few years it's been a growing

00:00:27,310 --> 00:00:33,560
architectural trend and back-end systems

00:00:29,689 --> 00:00:35,990
but for variety of reasons we have tried

00:00:33,560 --> 00:00:37,490
to use similar things on the front end

00:00:35,990 --> 00:00:41,050
side building building user interfaces

00:00:37,490 --> 00:00:43,580
in this case for real-time editing of

00:00:41,050 --> 00:00:45,710
documents and I thought it'd be

00:00:43,580 --> 00:00:47,120
interesting to share how which which

00:00:45,710 --> 00:00:49,970
things sort of come over to the front

00:00:47,120 --> 00:00:53,150
end and and and which things maybe not

00:00:49,970 --> 00:00:55,520
so much so first I'll talk a little bit

00:00:53,150 --> 00:00:57,620
about the use case that that we're

00:00:55,520 --> 00:01:00,020
looking at and where the the performance

00:00:57,620 --> 00:01:03,590
and and and usability requirements of

00:01:00,020 --> 00:01:05,750
what we wanted to build I'll talk a

00:01:03,590 --> 00:01:08,450
little bit about type safety and how

00:01:05,750 --> 00:01:10,100
scarlet is which is the technology that

00:01:08,450 --> 00:01:12,409
we that we built the front end on

00:01:10,100 --> 00:01:14,359
actually was a very nice fit for we're

00:01:12,409 --> 00:01:16,310
doing and I'll demo and show a little

00:01:14,359 --> 00:01:17,929
bit about how the the source code is

00:01:16,310 --> 00:01:22,999
structured and how everything fits

00:01:17,929 --> 00:01:26,119
together in this editor so tricky if the

00:01:22,999 --> 00:01:28,429
company I work for is a an international

00:01:26,119 --> 00:01:30,109
platform for business transactions what

00:01:28,429 --> 00:01:32,569
that means is that we have about 1

00:01:30,109 --> 00:01:35,090
million companies worldwide that use our

00:01:32,569 --> 00:01:39,200
platform to exchange invoices orders

00:01:35,090 --> 00:01:42,560
payment statuses requisitions inside the

00:01:39,200 --> 00:01:46,219
company and we provided an easy-to-use

00:01:42,560 --> 00:01:48,109
user interface on top of that but the

00:01:46,219 --> 00:01:51,139
semantics underneath the documents that

00:01:48,109 --> 00:01:53,209
are being exchanged are legally

00:01:51,139 --> 00:01:54,530
important to those companies invoices

00:01:53,209 --> 00:01:56,359
need to be booked at the end of the year

00:01:54,530 --> 00:01:58,670
and there's all sorts of important

00:01:56,359 --> 00:02:01,700
processes on top of them which is why

00:01:58,670 --> 00:02:03,439
they're the Oasis Committee an

00:02:01,700 --> 00:02:06,289
international standards committee has

00:02:03,439 --> 00:02:08,330
actually come up with a few very useful

00:02:06,289 --> 00:02:10,459
standards on how what these documents

00:02:08,330 --> 00:02:13,040
could look like semantically they're

00:02:10,459 --> 00:02:16,280
based on XML it's a bunch of fairly big

00:02:13,040 --> 00:02:18,200
xsds called Ruby LD Universal business

00:02:16,280 --> 00:02:19,700
language and these are the kind of

00:02:18,200 --> 00:02:22,930
documents that we're talking about when

00:02:19,700 --> 00:02:28,329
we when I say documents in this talk

00:02:22,930 --> 00:02:31,579
I wanted to share one example of what a

00:02:28,329 --> 00:02:36,499
invoice looks like in UBL just so we

00:02:31,579 --> 00:02:37,400
have sort of an idea of what that what

00:02:36,499 --> 00:02:39,170
we're talking about

00:02:37,400 --> 00:02:40,870
maybe there's a lots of text there's

00:02:39,170 --> 00:02:43,250
binary stuff in there because sometimes

00:02:40,870 --> 00:02:46,219
invoices have attachments of the to them

00:02:43,250 --> 00:02:47,719
like proof that a carpenter did a

00:02:46,219 --> 00:02:50,359
particular piece of work like a picture

00:02:47,719 --> 00:02:55,639
or other things but if you scroll past

00:02:50,359 --> 00:02:57,530
that then the actual semantic data of

00:02:55,639 --> 00:02:59,299
what's in the invoice is there in a

00:02:57,530 --> 00:03:01,519
fairly structured way so you have a

00:02:59,299 --> 00:03:04,489
thing called an invoice line that has a

00:03:01,519 --> 00:03:05,810
line number and has the amount for

00:03:04,489 --> 00:03:09,169
deadlines on it

00:03:05,810 --> 00:03:10,459
and includes a nurse of tech rights and

00:03:09,169 --> 00:03:11,719
things like the description of the

00:03:10,459 --> 00:03:13,909
invoice line you can sort of see if

00:03:11,719 --> 00:03:15,109
you've ever seen an invoice of anything

00:03:13,909 --> 00:03:17,780
at all how you could could stretch it

00:03:15,109 --> 00:03:24,340
down into xml and make it easy to parse

00:03:17,780 --> 00:03:27,169
that go and back yeah our current system

00:03:24,340 --> 00:03:28,370
needs to process about ten documents per

00:03:27,169 --> 00:03:30,859
second that's sort of the load that we

00:03:28,370 --> 00:03:34,159
get worldwide on average visual force

00:03:30,859 --> 00:03:36,169
varies varies wildly and unfortunately

00:03:34,159 --> 00:03:38,120
that's actually stretching the boundary

00:03:36,169 --> 00:03:41,090
of what our current architecture can do

00:03:38,120 --> 00:03:42,979
I think ten of these xml for a second

00:03:41,090 --> 00:03:45,620
that's not so complicated but turns out

00:03:42,979 --> 00:03:46,909
that yeah we wanted to build a big

00:03:45,620 --> 00:03:49,090
company on this which means we go after

00:03:46,909 --> 00:03:51,349
it be client and big companies in a

00:03:49,090 --> 00:03:53,269
process lots of documents also lots of

00:03:51,349 --> 00:03:55,220
big documents not sure the biggest

00:03:53,269 --> 00:03:57,739
invoices that you've seen hopefully not

00:03:55,220 --> 00:04:00,319
that big but as it turns out if you take

00:03:57,739 --> 00:04:02,959
a shipping company like like DHL they

00:04:00,319 --> 00:04:04,909
send out a summarized invoice of every

00:04:02,959 --> 00:04:07,189
single thing that they've done for a

00:04:04,909 --> 00:04:09,259
customer which goes out for thousands

00:04:07,189 --> 00:04:11,389
and thousands of pages all in one

00:04:09,259 --> 00:04:13,579
invoice which turns into 50 megabytes of

00:04:11,389 --> 00:04:16,759
XML and that's not including any

00:04:13,579 --> 00:04:18,859
external binary attachments that are

00:04:16,759 --> 00:04:20,690
also in there so there's quite a lot of

00:04:18,859 --> 00:04:23,349
data that can potentially be in these

00:04:20,690 --> 00:04:27,020
documents which generates load for us

00:04:23,349 --> 00:04:29,840
and you know history is one of this

00:04:27,020 --> 00:04:31,159
historic decisions have been made some

00:04:29,840 --> 00:04:33,080
of them played out well so I'm going to

00:04:31,159 --> 00:04:35,389
played out not so well our current

00:04:33,080 --> 00:04:36,350
system has some challenges when it comes

00:04:35,389 --> 00:04:38,810
to too

00:04:36,350 --> 00:04:40,970
handling these documents I won't go

00:04:38,810 --> 00:04:43,460
through all of them here but an

00:04:40,970 --> 00:04:45,110
important one is that all of these

00:04:43,460 --> 00:04:47,660
documents are read into memory they use

00:04:45,110 --> 00:04:50,480
plain Jack's beyond the Java back-end to

00:04:47,660 --> 00:04:52,010
parse that XML and I guess it's a nexus

00:04:50,480 --> 00:04:54,050
D you get cogeneration it's it's all

00:04:52,010 --> 00:04:55,490
very easy to get started with but it

00:04:54,050 --> 00:04:57,020
means that you have to lug all those 20

00:04:55,490 --> 00:04:58,490
megabytes around everywhere you go and

00:04:57,020 --> 00:04:59,750
that's if you stay within one system if

00:04:58,490 --> 00:05:01,850
there are other systems and you have to

00:04:59,750 --> 00:05:03,200
push them into there well maybe all

00:05:01,850 --> 00:05:05,480
you're interested in is religious the

00:05:03,200 --> 00:05:07,100
totals in the invoice and all the twenty

00:05:05,480 --> 00:05:08,900
megabytes of pictures of cats and other

00:05:07,100 --> 00:05:12,890
things that are attached are not that

00:05:08,900 --> 00:05:13,250
interesting so that's that's there's one

00:05:12,890 --> 00:05:16,790
problem

00:05:13,250 --> 00:05:18,980
as a performance issue but it was

00:05:16,790 --> 00:05:20,750
another issue which is that as a company

00:05:18,980 --> 00:05:22,490
grew so that the number of developers

00:05:20,750 --> 00:05:25,190
that try to interact with what

00:05:22,490 --> 00:05:26,510
inevitably started out as a monolith and

00:05:25,190 --> 00:05:28,460
right now it's actually fairly

00:05:26,510 --> 00:05:30,620
complicated to teach the system about

00:05:28,460 --> 00:05:32,450
new types of documents I've mentioned a

00:05:30,620 --> 00:05:34,160
few like invoices orders and but there's

00:05:32,450 --> 00:05:35,420
a lot of other things that companies

00:05:34,160 --> 00:05:36,560
would like to exchange with each other

00:05:35,420 --> 00:05:37,880
maybe we don't even know what they want

00:05:36,560 --> 00:05:39,530
to exchange maybe they want to come up

00:05:37,880 --> 00:05:41,660
with their own types of documents and

00:05:39,530 --> 00:05:44,840
right now that what our system knows

00:05:41,660 --> 00:05:46,610
about is very tightly anchored inside

00:05:44,840 --> 00:05:48,110
there and we we're doing what we can to

00:05:46,610 --> 00:05:50,360
make it easier to do that but it's all

00:05:48,110 --> 00:05:53,180
fairly hard-coded still and it's also

00:05:50,360 --> 00:05:54,860
something that we wanted to to make a

00:05:53,180 --> 00:05:59,090
little smarter and a little more future

00:05:54,860 --> 00:06:02,210
proof so one or two years ago a project

00:05:59,090 --> 00:06:03,860
was was launched to to rethink this and

00:06:02,210 --> 00:06:05,720
we've only recently started to actually

00:06:03,860 --> 00:06:08,320
go into an implementation phase we start

00:06:05,720 --> 00:06:11,060
to recollect of the requirements that we

00:06:08,320 --> 00:06:13,850
wanted to address with a document

00:06:11,060 --> 00:06:15,830
pipeline and trade shift one important

00:06:13,850 --> 00:06:17,900
change that we we're going to make is

00:06:15,830 --> 00:06:20,990
that we're going to remove that that

00:06:17,900 --> 00:06:22,490
hard-coded barrier which is that we know

00:06:20,990 --> 00:06:25,010
what an invoice and what an order and

00:06:22,490 --> 00:06:27,530
all those things are we're just gonna go

00:06:25,010 --> 00:06:28,670
down a level you UBL the the definitions

00:06:27,530 --> 00:06:30,380
all this is based or it's actually

00:06:28,670 --> 00:06:32,000
fairly layered you have invoices on the

00:06:30,380 --> 00:06:33,350
top but there are some common components

00:06:32,000 --> 00:06:36,010
below that some even more common

00:06:33,350 --> 00:06:38,780
components and then there's things like

00:06:36,010 --> 00:06:41,090
translatable strings and currencies and

00:06:38,780 --> 00:06:42,470
postal addresses on the lowest layer and

00:06:41,090 --> 00:06:44,930
we're going to focus much more on that

00:06:42,470 --> 00:06:47,720
and allowing our customers to define

00:06:44,930 --> 00:06:49,790
documents on top of that but what we

00:06:47,720 --> 00:06:52,100
also want to do is

00:06:49,790 --> 00:06:55,520
make go away from a document is a big

00:06:52,100 --> 00:06:57,830
chunk of opaque data and open it up a

00:06:55,520 --> 00:06:59,240
little bit and see okay how do systems

00:06:57,830 --> 00:07:00,950
and people actually interact with that

00:06:59,240 --> 00:07:02,570
because you don't see 20 megabytes on

00:07:00,950 --> 00:07:04,340
your screen you see a samurai in a

00:07:02,570 --> 00:07:07,100
summary of that and things like

00:07:04,340 --> 00:07:08,660
validations that later on act on

00:07:07,100 --> 00:07:11,480
document say okay I only want to see

00:07:08,660 --> 00:07:13,730
invoices up to 100k euro and higher

00:07:11,480 --> 00:07:15,920
stuff I want to handle separately these

00:07:13,730 --> 00:07:18,110
decisions they also all need to see part

00:07:15,920 --> 00:07:20,360
of the document so we want to make it

00:07:18,110 --> 00:07:24,050
easier to to interact with these things

00:07:20,360 --> 00:07:26,710
in a streaming fashion and inevitably

00:07:24,050 --> 00:07:29,180
event sourcing was an architectural

00:07:26,710 --> 00:07:30,560
direction that fit very well with with

00:07:29,180 --> 00:07:33,470
what we wanted to achieve there and

00:07:30,560 --> 00:07:37,970
that's actually how we are building our

00:07:33,470 --> 00:07:40,010
new document pipeline by saying okay

00:07:37,970 --> 00:07:42,140
we're no longer looking at the document

00:07:40,010 --> 00:07:44,300
as one hole maybe you start out with an

00:07:42,140 --> 00:07:45,980
initial invoice that was imported from

00:07:44,300 --> 00:07:47,180
somewhere or something but after it goes

00:07:45,980 --> 00:07:49,130
into our UI and after it goes through

00:07:47,180 --> 00:07:51,620
other systems all we're gone the store

00:07:49,130 --> 00:07:53,180
is what users are actually doing to the

00:07:51,620 --> 00:07:54,440
document exactly what are they editing

00:07:53,180 --> 00:07:56,600
where are they editing how are they

00:07:54,440 --> 00:07:58,550
doing it what user and that's the only

00:07:56,600 --> 00:08:00,910
information restoring so we're no longer

00:07:58,550 --> 00:08:03,310
storing a replacement document as such

00:08:00,910 --> 00:08:05,750
and that turns into an event stream

00:08:03,310 --> 00:08:07,250
where I can say okay I uploaded a

00:08:05,750 --> 00:08:09,170
document and after that you basically

00:08:07,250 --> 00:08:12,980
only see edited events and maybe some

00:08:09,170 --> 00:08:14,120
security changes and other things maybe

00:08:12,980 --> 00:08:18,070
I should ask who if you have never heard

00:08:14,120 --> 00:08:20,990
the word events sourcing before great

00:08:18,070 --> 00:08:23,360
okay all right this is sort of covered

00:08:20,990 --> 00:08:25,910
for basic elusive the word sourcing but

00:08:23,360 --> 00:08:28,160
events then sourcing means that your

00:08:25,910 --> 00:08:29,990
source of truth in the system is no

00:08:28,160 --> 00:08:31,460
longer what you happen to store in your

00:08:29,990 --> 00:08:34,610
relational database the source of truth

00:08:31,460 --> 00:08:36,770
is only that journal earth changes that

00:08:34,610 --> 00:08:38,120
you're constantly appending to so I

00:08:36,770 --> 00:08:39,770
never go back and say oh this wasn't

00:08:38,120 --> 00:08:41,570
edited because it was the user click the

00:08:39,770 --> 00:08:43,460
button and that sort on their screen and

00:08:41,570 --> 00:08:44,750
even though you may later on change that

00:08:43,460 --> 00:08:46,580
value to be something else they did

00:08:44,750 --> 00:08:48,680
still press that button back in time

00:08:46,580 --> 00:08:54,700
that's what sort of the mindset that you

00:08:48,680 --> 00:08:54,700
that you work for so

00:08:57,620 --> 00:09:01,860
in if you go to trade chief right now

00:09:00,390 --> 00:09:04,230
and try to create you know any of the

00:09:01,860 --> 00:09:06,000
document types that we have the editors

00:09:04,230 --> 00:09:08,149
are somewhat build up like what you see

00:09:06,000 --> 00:09:12,950
that actually slightly more complicated

00:09:08,149 --> 00:09:16,380
but there's an you BL XML file below and

00:09:12,950 --> 00:09:19,260
the editor inevitably in JavaScript

00:09:16,380 --> 00:09:20,970
front-end lands somebody told all the

00:09:19,260 --> 00:09:22,410
form tenors you can't read XML the web

00:09:20,970 --> 00:09:24,329
browser so they inevitably tend to

00:09:22,410 --> 00:09:26,370
convert that to JSON on some server

00:09:24,329 --> 00:09:28,350
component before it even goes to the

00:09:26,370 --> 00:09:30,899
front end so that's that's one step that

00:09:28,350 --> 00:09:32,670
we do when you find out that even the

00:09:30,899 --> 00:09:36,089
automatic JSON that you've got isn't

00:09:32,670 --> 00:09:40,079
quite what you want to put into reactor

00:09:36,089 --> 00:09:42,120
jQuery or or anything between what the

00:09:40,079 --> 00:09:43,649
technology of the day so there's there's

00:09:42,120 --> 00:09:45,089
other JS object tree that you build up

00:09:43,649 --> 00:09:46,500
in memory that's closer to what you

00:09:45,089 --> 00:09:48,180
actually want to show on the screen and

00:09:46,500 --> 00:09:50,760
then you end up with a Dom tree actual

00:09:48,180 --> 00:09:52,470
user interface that you show if you have

00:09:50,760 --> 00:09:54,750
an editor but then the user starts

00:09:52,470 --> 00:09:56,970
typing changing stuff change stuff hits

00:09:54,750 --> 00:09:59,490
the Save button they have to go all the

00:09:56,970 --> 00:10:01,680
way back from your user interface but

00:09:59,490 --> 00:10:03,870
typically the hopefully the web browser

00:10:01,680 --> 00:10:05,279
will take care of the part of getting it

00:10:03,870 --> 00:10:06,930
from a user interface into your JS

00:10:05,279 --> 00:10:09,360
object tree but then you have to put

00:10:06,930 --> 00:10:10,950
them back into the PL json variant that

00:10:09,360 --> 00:10:12,630
you dreamt up for yourself that has to

00:10:10,950 --> 00:10:14,550
them be converted back to ub l if you

00:10:12,630 --> 00:10:15,779
got everything right you end up with the

00:10:14,550 --> 00:10:18,660
same you'll be early started out with

00:10:15,779 --> 00:10:24,089
with the changes apply it of course you

00:10:18,660 --> 00:10:25,709
don't get everything right usually so

00:10:24,089 --> 00:10:26,339
it's the source of bugs but there's a

00:10:25,709 --> 00:10:30,570
second problem

00:10:26,339 --> 00:10:32,190
and that is that for invoice model get

00:10:30,570 --> 00:10:34,709
relevant but if you think about an

00:10:32,190 --> 00:10:36,120
ordering process or a process where

00:10:34,709 --> 00:10:38,070
you're about to order something and say

00:10:36,120 --> 00:10:40,110
ok i'm contacting this this supplier of

00:10:38,070 --> 00:10:42,089
paint and i want this particular red

00:10:40,110 --> 00:10:45,089
color maybe a red car isn't available

00:10:42,089 --> 00:10:46,470
and the supplier typically is in the

00:10:45,089 --> 00:10:48,750
same time zone maybe they're actually

00:10:46,470 --> 00:10:50,040
online right now it might be nice if

00:10:48,750 --> 00:10:51,660
they happen to see that you're about to

00:10:50,040 --> 00:10:52,980
order that they can tell you we don't

00:10:51,660 --> 00:10:54,570
have this red color but you could get

00:10:52,980 --> 00:10:57,269
this one instead not if you discount

00:10:54,570 --> 00:10:58,949
because otherwise you'll be said that

00:10:57,269 --> 00:11:00,839
kind of real-time interaction requires

00:10:58,949 --> 00:11:02,519
both people to be able to see what's

00:11:00,839 --> 00:11:04,079
going on with a document or at least a

00:11:02,519 --> 00:11:05,520
lot of require systems to see that and

00:11:04,079 --> 00:11:08,160
then maybe that people see the actual

00:11:05,520 --> 00:11:08,910
document or help them out a bit but it's

00:11:08,160 --> 00:11:10,500
not possible with this

00:11:08,910 --> 00:11:13,410
architecture because we don't send

00:11:10,500 --> 00:11:15,000
anything back until you know the whole

00:11:13,410 --> 00:11:17,460
audit is complete and what we send back

00:11:15,000 --> 00:11:19,410
is just oh here's a document we don't

00:11:17,460 --> 00:11:22,110
really know what the user was looking at

00:11:19,410 --> 00:11:24,870
and when so any kind of real-time

00:11:22,110 --> 00:11:27,360
interaction isn't isn't possible and

00:11:24,870 --> 00:11:28,800
also showing change that other users are

00:11:27,360 --> 00:11:32,190
doing is only possible about reloading

00:11:28,800 --> 00:11:34,740
the whole thing so look at a different

00:11:32,190 --> 00:11:36,030
way to set this up and the architecture

00:11:34,740 --> 00:11:38,460
here might look familiar if you work

00:11:36,030 --> 00:11:43,080
with redux or Elm move here has worked

00:11:38,460 --> 00:11:48,870
with redux I feel good and album not the

00:11:43,080 --> 00:11:56,970
same guys how strange okay so what we

00:11:48,870 --> 00:12:00,300
can do is say well the these these

00:11:56,970 --> 00:12:02,160
changes that a user is is making those

00:12:00,300 --> 00:12:05,070
are actually they're the core for our

00:12:02,160 --> 00:12:08,280
event stream so if we take these changes

00:12:05,070 --> 00:12:10,230
and we build our user interface based on

00:12:08,280 --> 00:12:12,240
them so we we take all the edits that

00:12:10,230 --> 00:12:15,830
could be made to a document we put them

00:12:12,240 --> 00:12:18,690
into a piece of code that looks at each

00:12:15,830 --> 00:12:21,840
edit and then updates the user interface

00:12:18,690 --> 00:12:23,400
to best reflect its States according to

00:12:21,840 --> 00:12:24,360
what happened in that edit so say you

00:12:23,400 --> 00:12:27,210
have an editor change okay the

00:12:24,360 --> 00:12:29,220
description of line 20 is now cats okay

00:12:27,210 --> 00:12:31,110
then I should go to the text box that's

00:12:29,220 --> 00:12:33,060
for line 20 and change its content to

00:12:31,110 --> 00:12:34,440
become cat and comes a change oh it's

00:12:33,060 --> 00:12:36,150
not cats actually dog and you are

00:12:34,440 --> 00:12:37,440
innovating and change it to dog so

00:12:36,150 --> 00:12:39,690
that's the kind of code that you'd be

00:12:37,440 --> 00:12:42,360
writing and then there's a smart stuff

00:12:39,690 --> 00:12:44,640
that makes it all still perform but the

00:12:42,360 --> 00:12:46,410
code cell is fairly straightforward you

00:12:44,640 --> 00:12:49,080
could think of a million ways to make

00:12:46,410 --> 00:12:50,910
nice Diesel's in other ways to to write

00:12:49,080 --> 00:12:53,130
it succinctly which Redux an element

00:12:50,910 --> 00:12:56,460
Scarlett the discover just framework out

00:12:53,130 --> 00:12:57,480
watch which which we use all do but the

00:12:56,460 --> 00:13:00,180
important thing to realize that the code

00:12:57,480 --> 00:13:03,090
is fairly simple it's a it's a stateless

00:13:00,180 --> 00:13:04,890
transformation that takes only events in

00:13:03,090 --> 00:13:07,470
and knows how to turn them into user

00:13:04,890 --> 00:13:08,760
interface elements now we add another

00:13:07,470 --> 00:13:10,710
thing which is that if the user is

00:13:08,760 --> 00:13:13,470
editing it's interacting with the page

00:13:10,710 --> 00:13:15,060
and adding lines or editing elements or

00:13:13,470 --> 00:13:16,800
we emit and send back to the server

00:13:15,060 --> 00:13:19,590
we're going to make that the same data

00:13:16,800 --> 00:13:21,060
structure and this picture it's it says

00:13:19,590 --> 00:13:22,649
event it's it's not actually an event

00:13:21,060 --> 00:13:24,240
because although it did happen it didn't

00:13:22,649 --> 00:13:25,740
quite reach the server yet so the server

00:13:24,240 --> 00:13:26,730
could technically disagree so you can

00:13:25,740 --> 00:13:28,410
talk a little bit about it should be

00:13:26,730 --> 00:13:29,850
called a vender command but this is the

00:13:28,410 --> 00:13:32,579
same data structure it's the edit that

00:13:29,850 --> 00:13:35,519
the user is being make is doing and

00:13:32,579 --> 00:13:38,189
saying okay the this invoice line number

00:13:35,519 --> 00:13:40,800
20 the description I was goldfish and we

00:13:38,189 --> 00:13:42,389
sent that to the server and we're having

00:13:40,800 --> 00:13:44,040
at the same data structure the editor

00:13:42,389 --> 00:13:46,379
really has only this one thing which is

00:13:44,040 --> 00:13:48,389
edits that has to concern itself with

00:13:46,379 --> 00:13:49,550
and the server can sort of take care of

00:13:48,389 --> 00:13:51,809
the rest

00:13:49,550 --> 00:13:54,089
IRA paying attention there's a bootstrap

00:13:51,809 --> 00:13:56,100
problem here because we started out with

00:13:54,089 --> 00:13:59,040
the initial upload of the document which

00:13:56,100 --> 00:14:00,509
is not an edit it's an XML file so we

00:13:59,040 --> 00:14:02,910
need something that can turn that into

00:14:00,509 --> 00:14:04,410
sort of an initial adit that represents

00:14:02,910 --> 00:14:06,569
what was in the document originally if

00:14:04,410 --> 00:14:08,279
you start out from a blank document it's

00:14:06,569 --> 00:14:09,569
not quite blank because our server will

00:14:08,279 --> 00:14:11,339
give you like an invoice number and

00:14:09,569 --> 00:14:13,139
today's date and these sorts of things

00:14:11,339 --> 00:14:16,499
so there's always something to start out

00:14:13,139 --> 00:14:17,850
with and so I still need some code which

00:14:16,499 --> 00:14:21,179
in our case is on the server that's

00:14:17,850 --> 00:14:24,259
turns that thing into an edit or an

00:14:21,179 --> 00:14:26,939
event structure as well but after that

00:14:24,259 --> 00:14:30,179
you're using two-faced code can be

00:14:26,939 --> 00:14:31,350
actually fairly simplistic but at the

00:14:30,179 --> 00:14:35,999
same time you get a lot of stuff for

00:14:31,350 --> 00:14:38,730
free because if any other user changed

00:14:35,999 --> 00:14:40,170
something then all we have to do is make

00:14:38,730 --> 00:14:42,449
sure that it drops into the same event

00:14:40,170 --> 00:14:45,059
stream that this interface is seeing

00:14:42,449 --> 00:14:49,470
you'll see it on your screen and in

00:14:45,059 --> 00:14:50,970
reality it's even more simple the the

00:14:49,470 --> 00:14:54,360
actually first implementation that we

00:14:50,970 --> 00:14:56,160
did the the architecture of the front

00:14:54,360 --> 00:14:58,559
end actually didn't know how to update

00:14:56,160 --> 00:15:00,449
its own screen literally all the editor

00:14:58,559 --> 00:15:02,129
did was it would render these message

00:15:00,449 --> 00:15:04,829
boxes from the incoming event stream

00:15:02,129 --> 00:15:06,959
when you press a single character into

00:15:04,829 --> 00:15:08,279
an edit box all I did was sent and added

00:15:06,959 --> 00:15:10,499
back to the server I didn't actually

00:15:08,279 --> 00:15:11,879
update the screen and the server was

00:15:10,499 --> 00:15:14,129
quick enough to immediately send it back

00:15:11,879 --> 00:15:15,929
in and then you saw the character that

00:15:14,129 --> 00:15:17,699
you typed not particularly friendly for

00:15:15,929 --> 00:15:19,410
the user that's a very simple clean

00:15:17,699 --> 00:15:20,939
architecture and of course if you mesh

00:15:19,410 --> 00:15:23,129
in other events they've also just be

00:15:20,939 --> 00:15:24,420
sure now if it's found out that you want

00:15:23,129 --> 00:15:26,160
to do a couple of optimizations to

00:15:24,420 --> 00:15:30,449
actually make the editor experience

00:15:26,160 --> 00:15:33,569
Pleasant but it to me it sounds it's

00:15:30,449 --> 00:15:36,570
it's great how do you say a great way to

00:15:33,569 --> 00:15:38,190
show the the beauty and

00:15:36,570 --> 00:15:41,100
simplicity of which you can make an

00:15:38,190 --> 00:15:43,290
architecture like this I wanted to go a

00:15:41,100 --> 00:15:48,630
little bit more into detail in how these

00:15:43,290 --> 00:15:50,790
edits actually look so what data

00:15:48,630 --> 00:15:52,920
structure were using to represent things

00:15:50,790 --> 00:15:54,450
that are being edited on the screen and

00:15:52,920 --> 00:15:56,670
I've been saying yeah the description of

00:15:54,450 --> 00:15:57,840
image line 20 becomes goldfish but how

00:15:56,670 --> 00:16:02,460
would you represent that in a data

00:15:57,840 --> 00:16:03,360
structure and we try to put it in

00:16:02,460 --> 00:16:06,360
exactly in the way that you would

00:16:03,360 --> 00:16:08,940
explain it in English and in this

00:16:06,360 --> 00:16:11,550
particular case we have a change that's

00:16:08,940 --> 00:16:15,090
being made where an invoice line is

00:16:11,550 --> 00:16:16,620
being changed but sister many invoice

00:16:15,090 --> 00:16:17,940
line and invoice we want to say what

00:16:16,620 --> 00:16:19,890
invoice line is being changed well

00:16:17,940 --> 00:16:23,400
something's being changed inside invoice

00:16:19,890 --> 00:16:25,140
line that has a nested id Tech which is

00:16:23,400 --> 00:16:27,750
worthy the business identified for the

00:16:25,140 --> 00:16:30,330
denoise lives with value 10 okay

00:16:27,750 --> 00:16:32,580
so this change is about inverse line 10

00:16:30,330 --> 00:16:34,890
what is being changed that's in the

00:16:32,580 --> 00:16:37,740
change section while we're changing

00:16:34,890 --> 00:16:40,200
actually a sub tag called item and in

00:16:37,740 --> 00:16:42,270
the tight item tag we have another

00:16:40,200 --> 00:16:47,970
subject called name that gets the value

00:16:42,270 --> 00:16:49,590
widgets hold on for just a bit I'll show

00:16:47,970 --> 00:16:51,870
the next XML instead which probably

00:16:49,590 --> 00:16:54,960
makes more sense so it basically says if

00:16:51,870 --> 00:16:57,810
we start off with an empty invoice where

00:16:54,960 --> 00:16:59,760
there is no invoice line with ID 10 yet

00:16:57,810 --> 00:17:03,180
we'll have to create a new invoice line

00:16:59,760 --> 00:17:04,560
with an ID of 10 and create the subject

00:17:03,180 --> 00:17:07,980
item as well because that's what we're

00:17:04,560 --> 00:17:12,390
changing with the name widgets I wrong

00:17:07,980 --> 00:17:14,130
with me so far let's continue let's see

00:17:12,390 --> 00:17:16,050
okay what do we do if we already have an

00:17:14,130 --> 00:17:18,360
invoice with in the inverse line 10 and

00:17:16,050 --> 00:17:20,610
say a note tag which is referred to by

00:17:18,360 --> 00:17:22,199
the edit well we just leave it unchanged

00:17:20,610 --> 00:17:24,270
because it doesn't say what we do to it

00:17:22,199 --> 00:17:26,900
so we just applied on top and we keep

00:17:24,270 --> 00:17:30,270
the invoice line 10 we just add an item

00:17:26,900 --> 00:17:31,650
and with name widgets on top of this you

00:17:30,270 --> 00:17:33,270
can see where this is going if we

00:17:31,650 --> 00:17:35,160
already have an item named stuff well

00:17:33,270 --> 00:17:39,390
that's when we actually go in and change

00:17:35,160 --> 00:17:41,490
it this kind of data structure has the

00:17:39,390 --> 00:17:44,010
advantage that you can be fairly

00:17:41,490 --> 00:17:45,510
specific about what your being what

00:17:44,010 --> 00:17:48,750
you're changing without having to repeat

00:17:45,510 --> 00:17:50,520
a lot of things and one thing we wanted

00:17:48,750 --> 00:17:51,870
optimized for is d e Madhavan

00:17:50,520 --> 00:17:55,710
information we need to exchange it

00:17:51,870 --> 00:17:58,260
remember that got really big really fast

00:17:55,710 --> 00:18:00,780
in another pipeline so we we try to

00:17:58,260 --> 00:18:02,940
optimize that a bit so let's change

00:18:00,780 --> 00:18:05,550
gears a little bit and talk about type

00:18:02,940 --> 00:18:08,310
safety which to me is more like typo

00:18:05,550 --> 00:18:10,620
safety since that's the the the biggest

00:18:08,310 --> 00:18:12,990
class of errors that a compiler

00:18:10,620 --> 00:18:16,880
tends to catch for me anyways let me

00:18:12,990 --> 00:18:20,250
tell me what this does javascript does

00:18:16,880 --> 00:18:22,260
notice there's something about XML HTTP

00:18:20,250 --> 00:18:24,000
requests which is an ajax thing right

00:18:22,260 --> 00:18:26,040
and then goes to twitter and got some

00:18:24,000 --> 00:18:29,010
tweets you set a callback here which

00:18:26,040 --> 00:18:31,560
looks at the status of that AGP request

00:18:29,010 --> 00:18:33,390
and then there's this dollar sign does

00:18:31,560 --> 00:18:35,940
you remember that's that's jquery right

00:18:33,390 --> 00:18:40,710
so we look up a tweet section and then

00:18:35,940 --> 00:18:43,610
add some HTML to it however this is no

00:18:40,710 --> 00:18:45,900
javascript this is actually Scala code

00:18:43,610 --> 00:18:50,760
you can see that by there being a type

00:18:45,900 --> 00:18:54,510
here event on the e but this is how

00:18:50,760 --> 00:18:58,260
Scala GS code can look you basically use

00:18:54,510 --> 00:19:00,060
the full style language which looks a

00:18:58,260 --> 00:19:02,220
lot like JavaScript so this is this is a

00:19:00,060 --> 00:19:05,010
great way to get people on board as well

00:19:02,220 --> 00:19:06,420
but it folds into something you can

00:19:05,010 --> 00:19:08,910
directly run in the web browser

00:19:06,420 --> 00:19:11,370
and it might look like a neat trick in

00:19:08,910 --> 00:19:13,620
the beginning but if you think about all

00:19:11,370 --> 00:19:15,060
the problems that the the front-end

00:19:13,620 --> 00:19:17,940
community is trying to solve right now

00:19:15,060 --> 00:19:19,950
with the several type language is trying

00:19:17,940 --> 00:19:24,360
to be developed Scala is actually a

00:19:19,950 --> 00:19:27,270
really really good fit for trying to

00:19:24,360 --> 00:19:30,240
solve this so a little bit of a scarlet

00:19:27,270 --> 00:19:32,100
is so you write Scala

00:19:30,240 --> 00:19:34,350
you can pass to JavaScript and it runs

00:19:32,100 --> 00:19:35,040
typically in a web browser you can use

00:19:34,350 --> 00:19:36,540
all of Scala

00:19:35,040 --> 00:19:38,160
so macros and other stuff just works

00:19:36,540 --> 00:19:42,120
because it tar is fairly deeply into the

00:19:38,160 --> 00:19:43,560
into the compiler and you can call

00:19:42,120 --> 00:19:45,780
JavaScript stuff directly and there's

00:19:43,560 --> 00:19:47,610
even some macro support in there that if

00:19:45,780 --> 00:19:48,600
you need a really dynamic JavaScript

00:19:47,610 --> 00:19:50,580
object so I don't want to create

00:19:48,600 --> 00:19:52,440
bindings for it you can just say food or

00:19:50,580 --> 00:19:55,020
bars or whatever and I will compile into

00:19:52,440 --> 00:19:57,210
dynamic invocations on the on the

00:19:55,020 --> 00:19:59,430
JavaScript object so if you want to you

00:19:57,210 --> 00:20:02,970
can write some nasty code in Scala as

00:19:59,430 --> 00:20:03,960
well the firm is okay and the code size

00:20:02,970 --> 00:20:05,910
is

00:20:03,960 --> 00:20:08,730
it's big but it's it's sort of it's

00:20:05,910 --> 00:20:10,830
manageable I haven't tried it on mobile

00:20:08,730 --> 00:20:14,400
stuff but in the web browser it it kind

00:20:10,830 --> 00:20:17,970
of loads fast enough but one difference

00:20:14,400 --> 00:20:19,950
or what one new thing to me I'm not a

00:20:17,970 --> 00:20:21,510
front-end person per se but the last

00:20:19,950 --> 00:20:22,710
time I tried to do something similar to

00:20:21,510 --> 00:20:25,110
this was back in the days with Google

00:20:22,710 --> 00:20:28,620
web toolkit who you remember Google web

00:20:25,110 --> 00:20:32,330
toolkit yeah quite a few it was kind of

00:20:28,620 --> 00:20:34,890
fun right I mean at a time

00:20:32,330 --> 00:20:37,290
but unlike Google web toolkit which by

00:20:34,890 --> 00:20:40,140
the way transpires Java code to

00:20:37,290 --> 00:20:42,480
JavaScript but it also forces you into

00:20:40,140 --> 00:20:44,910
particular architecture like you you you

00:20:42,480 --> 00:20:46,080
have to set up your HTML your Drive in a

00:20:44,910 --> 00:20:48,210
certain way and if you want to

00:20:46,080 --> 00:20:49,950
communicate to your server usually we

00:20:48,210 --> 00:20:52,710
should be using their G RPC stuff which

00:20:49,950 --> 00:20:55,280
sort of leaves into it and it's not just

00:20:52,710 --> 00:20:57,270
the transpiler it's it also gives you

00:20:55,280 --> 00:20:59,130
yeah well an architecture to go with

00:20:57,270 --> 00:21:01,080
that most colleges release just a

00:20:59,130 --> 00:21:02,850
language so it's only step one after

00:21:01,080 --> 00:21:04,680
that you have to pick you know are am I

00:21:02,850 --> 00:21:06,450
gonna Google go with the Elm redux like

00:21:04,680 --> 00:21:08,010
architecture or more a traditional way

00:21:06,450 --> 00:21:10,080
you're gonna pull jQuery in which has

00:21:08,010 --> 00:21:11,700
Scala GS bindings so you can still make

00:21:10,080 --> 00:21:14,900
up your own mind as you go along while

00:21:11,700 --> 00:21:18,270
still getting all the type safety and

00:21:14,900 --> 00:21:19,520
amazingly as I have been been using this

00:21:18,270 --> 00:21:22,470
for quite a while

00:21:19,520 --> 00:21:24,570
the community is immense they're there I

00:21:22,470 --> 00:21:25,710
don't think there is a single JavaScript

00:21:24,570 --> 00:21:27,510
framework with more than a couple

00:21:25,710 --> 00:21:30,750
hundred users on it that doesn't have

00:21:27,510 --> 00:21:32,670
Scala G as bindings now and beyond that

00:21:30,750 --> 00:21:34,620
people have realized that well a

00:21:32,670 --> 00:21:37,860
JavaScript implementation is ecology as

00:21:34,620 --> 00:21:39,750
bindings isn't isn't a very nice place

00:21:37,860 --> 00:21:41,640
to be they've been reimplemented ease

00:21:39,750 --> 00:21:43,770
kinds of ideas directly and in plain

00:21:41,640 --> 00:21:46,140
Scarl and that's where the real added

00:21:43,770 --> 00:21:48,090
value starts to come in because then you

00:21:46,140 --> 00:21:50,970
no longer bound to a sort of a half

00:21:48,090 --> 00:21:52,710
typed type script like system where some

00:21:50,970 --> 00:21:55,140
of it is type some of it is not and and

00:21:52,710 --> 00:21:57,120
you know you'll get to the accidental

00:21:55,140 --> 00:21:59,130
typo but it you don't really get to

00:21:57,120 --> 00:22:01,740
breathe the the added value of a fully

00:21:59,130 --> 00:22:04,850
type safe system which which you do that

00:22:01,740 --> 00:22:08,960
with Scala yes I'm gonna skip over this

00:22:04,850 --> 00:22:12,500
so looking a little bit closer at the

00:22:08,960 --> 00:22:12,500
editor architecture

00:22:15,820 --> 00:22:20,769
so using the framework that we're using

00:22:17,649 --> 00:22:26,970
which is called out watch it's basically

00:22:20,769 --> 00:22:29,080
a combination of a reactive streaming a

00:22:26,970 --> 00:22:31,450
retro streaming library for JavaScript

00:22:29,080 --> 00:22:33,340
together with a virtual Dom

00:22:31,450 --> 00:22:35,499
implementation where you can write a

00:22:33,340 --> 00:22:40,090
stream that transforms in this case

00:22:35,499 --> 00:22:43,419
events into a virtual Dom tree who've

00:22:40,090 --> 00:22:45,940
you do not know whatever chill Dom trees

00:22:43,419 --> 00:22:50,590
so it basically asks you to do that in

00:22:45,940 --> 00:22:58,659
in Scala and what we found out is that

00:22:50,590 --> 00:23:00,820
the it helps to have an introduced sort

00:22:58,659 --> 00:23:02,769
of an intermediate state in your

00:23:00,820 --> 00:23:05,859
application so don't don't not going

00:23:02,769 --> 00:23:08,169
directly from events to full-on virtual

00:23:05,859 --> 00:23:10,570
Dom but introduce a series of case

00:23:08,169 --> 00:23:12,580
classes that represents sort of what you

00:23:10,570 --> 00:23:14,679
would like to show on the screen but not

00:23:12,580 --> 00:23:16,960
in terms of input elements just in terms

00:23:14,679 --> 00:23:20,139
of data so strings lists and sequences

00:23:16,960 --> 00:23:23,619
and stuff like that and the advantage

00:23:20,139 --> 00:23:25,479
being that it can be expensive to roll

00:23:23,619 --> 00:23:26,889
all these events into a user interface

00:23:25,479 --> 00:23:29,859
like if you've done like five hundred or

00:23:26,889 --> 00:23:31,869
thousand edits there's a bit of a

00:23:29,859 --> 00:23:33,580
computation to be done before you arrive

00:23:31,869 --> 00:23:35,499
at by actually R and if you share all of

00:23:33,580 --> 00:23:37,299
that into your virtual DOM it means you

00:23:35,499 --> 00:23:41,379
have to do it in a web browser and you

00:23:37,299 --> 00:23:44,109
just do a lot more than you need but

00:23:41,379 --> 00:23:45,970
also by separating that from the virtual

00:23:44,109 --> 00:23:48,340
Dom you make testability a lot easier

00:23:45,970 --> 00:23:49,749
because you have just your beta classes

00:23:48,340 --> 00:23:51,190
to deal with the events you've designed

00:23:49,749 --> 00:23:56,080
the intermediate state you've designed

00:23:51,190 --> 00:23:57,999
and you can you can test this stuff but

00:23:56,080 --> 00:24:00,279
I think let's look a little bit at what

00:23:57,999 --> 00:24:07,269
what we've been what we've been talking

00:24:00,279 --> 00:24:10,570
about so let's drop into the editor

00:24:07,269 --> 00:24:15,549
itself now this is an existing invoice

00:24:10,570 --> 00:24:18,009
but yeah let's start with this so what

00:24:15,549 --> 00:24:19,659
we see on the screen here is an editor

00:24:18,009 --> 00:24:21,249
component that's loaded with an invoice

00:24:19,659 --> 00:24:24,099
that I've uploaded into our system

00:24:21,249 --> 00:24:25,779
before where you can have an invoice

00:24:24,099 --> 00:24:27,399
number that you can edit as an order

00:24:25,779 --> 00:24:28,560
reference as a currency you can change

00:24:27,399 --> 00:24:30,450
two

00:24:28,560 --> 00:24:32,610
the the whatever the currency needs to

00:24:30,450 --> 00:24:36,720
be and their invoice line so a can can

00:24:32,610 --> 00:24:38,540
add some text and change the change the

00:24:36,720 --> 00:24:43,260
amount you can add a line and other

00:24:38,540 --> 00:24:46,560
other fun things but what you will see

00:24:43,260 --> 00:24:56,730
is if I open up my back-end system here

00:24:46,560 --> 00:24:59,100
that while I'm taking text there's

00:24:56,730 --> 00:25:01,290
actually stuff being sent to the server

00:24:59,100 --> 00:25:03,630
which are the events and they resemble

00:25:01,290 --> 00:25:05,850
the structure that we've been talking

00:25:03,630 --> 00:25:10,950
about so we're changing something inside

00:25:05,850 --> 00:25:12,810
the attack inside another tag and the

00:25:10,950 --> 00:25:14,400
the tax themselves have turned into

00:25:12,810 --> 00:25:16,590
numbers which you can explain later but

00:25:14,400 --> 00:25:18,300
you can see the values coming in here so

00:25:16,590 --> 00:25:19,830
what you're seeing here by the way is

00:25:18,300 --> 00:25:22,350
that two string representation of the

00:25:19,830 --> 00:25:25,350
protobuf structure that we put each

00:25:22,350 --> 00:25:28,070
event in that's also the reason that you

00:25:25,350 --> 00:25:31,770
see these things as numbers because the

00:25:28,070 --> 00:25:33,000
we've the XML tag names are basically

00:25:31,770 --> 00:25:36,030
the same you already know what they are

00:25:33,000 --> 00:25:37,830
they are a line line invoice which if

00:25:36,030 --> 00:25:39,630
you just take them a string we store in

00:25:37,830 --> 00:25:41,310
the same string and each event every

00:25:39,630 --> 00:25:42,600
time which takes up a lot of space so

00:25:41,310 --> 00:25:44,160
what we did was creating enumeration

00:25:42,600 --> 00:25:45,750
instead for all the tax that we know

00:25:44,160 --> 00:25:47,580
work that are going to occur then only

00:25:45,750 --> 00:25:49,560
storing is a long which turns into a var

00:25:47,580 --> 00:25:51,300
in just a few bytes in in throat above

00:25:49,560 --> 00:25:53,160
so it saves us quite a bit of space so

00:25:51,300 --> 00:25:56,610
it makes diagnosing stuff a little more

00:25:53,160 --> 00:25:59,940
complicated but it's it's doable now

00:25:56,610 --> 00:26:02,280
these events also go back to the editor

00:25:59,940 --> 00:26:06,240
again so let's find out what happens if

00:26:02,280 --> 00:26:08,880
we open a new browser window let's put

00:26:06,240 --> 00:26:13,110
that on the left side will the same

00:26:08,880 --> 00:26:15,180
editor into here and pretend that were a

00:26:13,110 --> 00:26:18,000
different user and see what happens if

00:26:15,180 --> 00:26:19,730
we add a line here of course it doesn't

00:26:18,000 --> 00:26:23,660
work that's really nice

00:26:19,730 --> 00:26:23,660
my WebSocket drop or something

00:26:24,360 --> 00:26:33,690
ah it's a it got back together so in

00:26:29,809 --> 00:26:35,399
mostly a real time you can see from left

00:26:33,690 --> 00:26:36,600
to right from left to right from from

00:26:35,399 --> 00:26:38,309
right to left what is being changed

00:26:36,600 --> 00:26:39,710
because these events remember they all

00:26:38,309 --> 00:26:42,179
they'll make it to the server

00:26:39,710 --> 00:26:49,260
into one big event stream and get sent

00:26:42,179 --> 00:26:51,260
back to each client that exists I want

00:26:49,260 --> 00:26:57,960
to show you a little bit more about the

00:26:51,260 --> 00:26:59,990
the architecture by going into my IDE

00:26:57,960 --> 00:27:04,380
and walking a little bit through the

00:26:59,990 --> 00:27:05,730
different parts of this application but

00:27:04,380 --> 00:27:09,630
for that I want to show you how it's

00:27:05,730 --> 00:27:12,590
build up first of a picture so there are

00:27:09,630 --> 00:27:14,909
two systems at play here one is called

00:27:12,590 --> 00:27:17,639
document core which is the system that

00:27:14,909 --> 00:27:20,549
manages the events that has an API to

00:27:17,639 --> 00:27:23,909
waken post edits to is an APR to stuff

00:27:20,549 --> 00:27:27,539
and it has an API to get events out

00:27:23,909 --> 00:27:31,320
again for for documents and but doesn't

00:27:27,539 --> 00:27:32,580
know anything about UI then the document

00:27:31,320 --> 00:27:35,159
editor system is the one that actually

00:27:32,580 --> 00:27:38,370
implements the user interface and that's

00:27:35,159 --> 00:27:40,049
sort of a two project SBT set up we have

00:27:38,370 --> 00:27:42,600
a back-end system and the Funland system

00:27:40,049 --> 00:27:45,179
from thing is compiled to to JavaScript

00:27:42,600 --> 00:27:48,000
its ecology yes the backend to to play

00:27:45,179 --> 00:27:50,279
in Java on the JVM and they can share

00:27:48,000 --> 00:27:52,919
classes that can run both on the back

00:27:50,279 --> 00:27:54,120
end and on the front end and that's the

00:27:52,919 --> 00:28:01,580
one that we're gonna take a little bit

00:27:54,120 --> 00:28:04,760
of a closer look at so the let's pick

00:28:01,580 --> 00:28:04,760
eclipse today

00:28:05,450 --> 00:28:14,210
no IntelliJ No so in the document editor

00:28:10,470 --> 00:28:16,679
there are a couple of projects here the

00:28:14,210 --> 00:28:18,240
shared project is called data which

00:28:16,679 --> 00:28:20,070
contains our protocol definitions but

00:28:18,240 --> 00:28:26,240
also some utility classes on top of that

00:28:20,070 --> 00:28:26,240
so let's start let's start there so

00:28:26,690 --> 00:28:30,590
where's first a source

00:28:32,360 --> 00:28:37,830
so this its immediate representation

00:28:35,190 --> 00:28:41,040
that I've been talking about so the gray

00:28:37,830 --> 00:28:42,660
box here is the thing that can can eat

00:28:41,040 --> 00:28:44,130
these edit events that come in and then

00:28:42,660 --> 00:28:46,530
generate the stuff that we can see on

00:28:44,130 --> 00:28:50,610
the screen and these classes here are

00:28:46,530 --> 00:28:58,500
called invoice online they look at line

00:28:50,610 --> 00:29:00,000
first so line is just a case class which

00:28:58,500 --> 00:29:02,040
in this case has all the elements that

00:29:00,000 --> 00:29:05,490
you can see on the screen like the IDE

00:29:02,040 --> 00:29:12,860
description and amount the key which

00:29:05,490 --> 00:29:15,000
represents like that suit yep

00:29:12,860 --> 00:29:16,260
okay okay I'll explain about that a

00:29:15,000 --> 00:29:18,540
little bit because it's actually may be

00:29:16,260 --> 00:29:21,360
more fun than staring at code and also a

00:29:18,540 --> 00:29:23,520
reason that that as you can see riding

00:29:21,360 --> 00:29:25,559
this kinda stuff is not so trivial if

00:29:23,520 --> 00:29:27,240
you go back you remember that the the

00:29:25,559 --> 00:29:29,100
Edit structure says okay change in most

00:29:27,240 --> 00:29:30,780
line 10 and make the description this

00:29:29,100 --> 00:29:32,820
you can do that but what happens if you

00:29:30,780 --> 00:29:35,220
actually change the idea of inverse line

00:29:32,820 --> 00:29:37,740
21 to become 45 or something like that

00:29:35,220 --> 00:29:40,410
are you suddenly saying okay I get

00:29:37,740 --> 00:29:42,419
interest with line 21 I want to actually

00:29:40,410 --> 00:29:44,790
make that 45 now so now it's no longer

00:29:42,419 --> 00:29:47,730
at line 21 so other events that may be

00:29:44,790 --> 00:29:49,830
referring to line 21 now refer to

00:29:47,730 --> 00:29:52,350
something else that's where this key

00:29:49,830 --> 00:29:54,210
comes in at least souls for that on the

00:29:52,350 --> 00:29:56,250
front hand side by saying okay once I've

00:29:54,210 --> 00:29:58,710
created a row I'm no longer looking at

00:29:56,250 --> 00:30:00,450
that ID and only give it a key that that

00:29:58,710 --> 00:30:02,580
I'm gonna remember and as this IDs

00:30:00,450 --> 00:30:04,380
changed by subsequent events I know that

00:30:02,580 --> 00:30:06,330
it's still the same input elements

00:30:04,380 --> 00:30:07,559
because then my framework knows that

00:30:06,330 --> 00:30:09,090
they can reuse that same row on the

00:30:07,559 --> 00:30:11,340
screen it seems a bit of performance and

00:30:09,090 --> 00:30:14,580
it also saves energy because then you're

00:30:11,340 --> 00:30:17,480
you're you don't lose track of whether

00:30:14,580 --> 00:30:19,410
you've already created that row or not

00:30:17,480 --> 00:30:21,720
and then that's the currency code which

00:30:19,410 --> 00:30:25,230
is the last column that has the dollar

00:30:21,720 --> 00:30:27,270
or the Euro or whatever the interesting

00:30:25,230 --> 00:30:29,850
part happens here there's a function

00:30:27,270 --> 00:30:32,280
called consume which creates a new line

00:30:29,850 --> 00:30:35,400
based on what's called a path here but

00:30:32,280 --> 00:30:40,020
that's actually just an edit that's so

00:30:35,400 --> 00:30:43,020
that's part of the UBL added structure

00:30:40,020 --> 00:30:44,970
that you that you saw before so there's

00:30:43,020 --> 00:30:45,690
one of these gray boxes the path is just

00:30:44,970 --> 00:30:47,610
a change

00:30:45,690 --> 00:30:50,370
inside here so the first nested box

00:30:47,610 --> 00:30:52,200
where the line can look at okay change

00:30:50,370 --> 00:30:54,210
is coming in what what do I actually

00:30:52,200 --> 00:30:56,909
need to apply well then we look at

00:30:54,210 --> 00:30:58,620
what's being changed so there's this

00:30:56,909 --> 00:31:02,940
extractor here you can almost read it

00:30:58,620 --> 00:31:06,809
like a piece of XML so if it's an ID tag

00:31:02,940 --> 00:31:09,059
which with a particular value that we

00:31:06,809 --> 00:31:10,529
extract a new line ID then well we

00:31:09,059 --> 00:31:12,570
create a new line and we change your ID

00:31:10,529 --> 00:31:14,730
to match that but if it was a line

00:31:12,570 --> 00:31:17,399
extension amount tag where there was a

00:31:14,730 --> 00:31:19,169
value and the currency in the inside

00:31:17,399 --> 00:31:23,669
that tag well we also create a copy we

00:31:19,169 --> 00:31:26,460
update this etc etc etc that way we can

00:31:23,669 --> 00:31:28,889
go through the edits that we recognize

00:31:26,460 --> 00:31:30,720
XML tags that we know to respond to and

00:31:28,889 --> 00:31:33,450
then we update our state in this case

00:31:30,720 --> 00:31:35,639
the case class line and anything else we

00:31:33,450 --> 00:31:37,649
can simply ignore so if there are taxing

00:31:35,639 --> 00:31:40,649
every that we don't need to play with we

00:31:37,649 --> 00:31:41,940
can jump over those fairly quickly the

00:31:40,649 --> 00:31:44,039
other thing that you can also put in

00:31:41,940 --> 00:31:46,649
this class conveniently is the ability

00:31:44,039 --> 00:31:51,809
to emit new edits so say that we want to

00:31:46,649 --> 00:31:53,399
at some point user chooses to edit the

00:31:51,809 --> 00:31:56,700
description to become something else

00:31:53,399 --> 00:31:59,100
well this function can emit a Euboea

00:31:56,700 --> 00:32:00,659
document edit so a new event that

00:31:59,100 --> 00:32:02,309
changed the description of this line to

00:32:00,659 --> 00:32:04,350
something else and we actually store the

00:32:02,309 --> 00:32:06,269
description in two places because you BL

00:32:04,350 --> 00:32:07,980
has two fields for that maybe and

00:32:06,269 --> 00:32:09,600
depending on downstream systems one or

00:32:07,980 --> 00:32:10,919
the other may be used so in this case

00:32:09,600 --> 00:32:13,580
they're actually two changes there's a

00:32:10,919 --> 00:32:16,710
new description tag and a name tag

00:32:13,580 --> 00:32:21,840
inside an event inside an item check

00:32:16,710 --> 00:32:23,460
that are that are being emitted here so

00:32:21,840 --> 00:32:26,190
now we have a intermediate

00:32:23,460 --> 00:32:28,289
representation built from our events now

00:32:26,190 --> 00:32:29,399
what we still need is to bind it to

00:32:28,289 --> 00:32:32,970
something we can actually show on the

00:32:29,399 --> 00:32:34,950
screen and this is where the out watch

00:32:32,970 --> 00:32:36,659
framework comes in and those are it

00:32:34,950 --> 00:32:38,129
comes in first so that means that we

00:32:36,659 --> 00:32:40,320
until now we haven't actually tied

00:32:38,129 --> 00:32:41,850
ourselves to any front-end framework yet

00:32:40,320 --> 00:32:44,700
which means we can reuse all this stuff

00:32:41,850 --> 00:32:47,190
in two years when some other framework

00:32:44,700 --> 00:32:51,230
comes along that we would like to use

00:32:47,190 --> 00:32:55,409
instead so let's go to the front-end and

00:32:51,230 --> 00:32:56,740
let's see what level we start out with

00:32:55,409 --> 00:32:58,480
here

00:32:56,740 --> 00:33:00,789
I think I'll take a line component

00:32:58,480 --> 00:33:01,869
because it aligns very nicely with the

00:33:00,789 --> 00:33:06,119
line we just looked at

00:33:01,869 --> 00:33:08,799
oh yes eclipses broken we know that so

00:33:06,119 --> 00:33:12,190
which by the way I saw Emacs

00:33:08,799 --> 00:33:15,340
they're also broken so I really know

00:33:12,190 --> 00:33:17,379
where to where to switch to so it's

00:33:15,340 --> 00:33:20,889
really awkward stuff content in outward

00:33:17,379 --> 00:33:22,419
input out watch imports and even if

00:33:20,889 --> 00:33:24,190
you've never used out words before you

00:33:22,419 --> 00:33:26,649
can probably make out what what this

00:33:24,190 --> 00:33:28,149
code is trying to do right and since

00:33:26,649 --> 00:33:29,679
it's Carla it must compile it must be

00:33:28,149 --> 00:33:31,869
methods or something where it has an

00:33:29,679 --> 00:33:33,610
apply method at least call TR somewhere

00:33:31,869 --> 00:33:35,860
which everything's gonna render like a

00:33:33,610 --> 00:33:37,299
TR table row so we are we're inside a

00:33:35,860 --> 00:33:39,639
table it makes sense we're trying to

00:33:37,299 --> 00:33:43,269
make an invoice language it needs to sit

00:33:39,639 --> 00:33:46,230
there CLS is the CSS class for the table

00:33:43,269 --> 00:33:48,909
which we can't use class for some reason

00:33:46,230 --> 00:33:49,629
TV the TV and ID in there done first

00:33:48,909 --> 00:33:53,950
year of a button

00:33:49,629 --> 00:33:55,210
what's that button alright so if you if

00:33:53,950 --> 00:33:57,720
you hover over the thing this blue

00:33:55,210 --> 00:34:02,769
button pops up here which allows you to

00:33:57,720 --> 00:34:05,110
split the invoice line into two well in

00:34:02,769 --> 00:34:07,600
some cases anyways that well the reason

00:34:05,110 --> 00:34:09,849
it sometimes drops out is the the

00:34:07,600 --> 00:34:13,059
WebSocket connection between Firefox and

00:34:09,849 --> 00:34:15,760
the backends akka drops that stream

00:34:13,059 --> 00:34:17,200
after one minute Firefox does not figure

00:34:15,760 --> 00:34:19,299
out that the connection is actually gone

00:34:17,200 --> 00:34:22,720
and we have yet to implement a keepalive

00:34:19,299 --> 00:34:24,520
or something else to make those two work

00:34:22,720 --> 00:34:28,419
together a bit more nicely but it's

00:34:24,520 --> 00:34:31,419
definitely solvable so but this is

00:34:28,419 --> 00:34:34,210
basically how you build HTML you just

00:34:31,419 --> 00:34:36,849
have a just a case class that amongst

00:34:34,210 --> 00:34:40,569
other things gets the line case class we

00:34:36,849 --> 00:34:42,069
already had as input and in a method

00:34:40,569 --> 00:34:44,679
just output something called a V note

00:34:42,069 --> 00:34:50,020
which out watch takes care of to turn

00:34:44,679 --> 00:34:52,179
into actual HTML however we also have a

00:34:50,020 --> 00:34:54,129
thing called a sink which if you might

00:34:52,179 --> 00:34:56,889
recognize it's not bad guys in this case

00:34:54,129 --> 00:34:58,809
it's odd watch his own sink concept but

00:34:56,889 --> 00:35:01,750
it pretty much does the same thing it

00:34:58,809 --> 00:35:03,160
allows you to emit events downstream

00:35:01,750 --> 00:35:06,520
again in this case to go into a web

00:35:03,160 --> 00:35:07,780
socket where in this particular case if

00:35:06,520 --> 00:35:10,150
you were to click the line button and

00:35:07,780 --> 00:35:13,450
their web sockets actually connected

00:35:10,150 --> 00:35:16,690
we take the line that we had and we call

00:35:13,450 --> 00:35:18,970
the dot split function which you can

00:35:16,690 --> 00:35:21,070
sort of read it which returns at you BL

00:35:18,970 --> 00:35:22,690
document edit that is supposed to split

00:35:21,070 --> 00:35:25,030
that line into two it's a common use

00:35:22,690 --> 00:35:26,230
case if you have ordered 20 items but

00:35:25,030 --> 00:35:27,880
you want to invoice them separately you

00:35:26,230 --> 00:35:30,220
split that line into two and then you

00:35:27,880 --> 00:35:32,140
sort of you should have go from there

00:35:30,220 --> 00:35:42,960
and let's admit it as a UBL document at

00:35:32,140 --> 00:35:48,490
a downstream back to the server yes I

00:35:42,960 --> 00:35:51,610
will continue to a few words about

00:35:48,490 --> 00:35:53,790
performance so this inverse that you've

00:35:51,610 --> 00:35:57,280
seen and you've been hacking away that

00:35:53,790 --> 00:35:59,050
while setting up for the slides and we

00:35:57,280 --> 00:36:01,810
did a bit of testing if you have about

00:35:59,050 --> 00:36:04,030
500 events if you're on the server and

00:36:01,810 --> 00:36:06,040
we read them from our back-end system we

00:36:04,030 --> 00:36:07,540
can still spool those into this line and

00:36:06,040 --> 00:36:09,850
invoice structures in about 10

00:36:07,540 --> 00:36:12,010
milliseconds so that's still within the

00:36:09,850 --> 00:36:13,320
realm of just doing it pushing it to the

00:36:12,010 --> 00:36:16,000
server and not needing any caching

00:36:13,320 --> 00:36:17,980
however I try to do the same thing on

00:36:16,000 --> 00:36:20,830
the front end there so Betty pushing the

00:36:17,980 --> 00:36:23,950
events directly into Scala GS lands and

00:36:20,830 --> 00:36:25,870
having that deserialized to protobuf and

00:36:23,950 --> 00:36:27,910
doing the same thing was not quite

00:36:25,870 --> 00:36:29,680
another seconds so there's a big

00:36:27,910 --> 00:36:31,930
difference between what the JVM can

00:36:29,680 --> 00:36:33,910
optimize and what Scala libraries

00:36:31,930 --> 00:36:36,160
originally written for the JVM but

00:36:33,910 --> 00:36:40,150
cross-compiled - Janice - scholar - yes

00:36:36,160 --> 00:36:41,800
and then even on sophisticated

00:36:40,150 --> 00:36:44,290
JavaScript engine it's still gonna be

00:36:41,800 --> 00:36:45,580
much slower however we have the

00:36:44,290 --> 00:36:47,560
advantage that with Scala

00:36:45,580 --> 00:36:48,730
you can run the code you want on the

00:36:47,560 --> 00:36:52,630
server and run the other code in the

00:36:48,730 --> 00:36:54,730
editor so what we actually do is the

00:36:52,630 --> 00:36:56,740
intermediate state we actually calculate

00:36:54,730 --> 00:36:59,440
on the server for the last event that we

00:36:56,740 --> 00:37:01,600
have sent that to the client as JSON and

00:36:59,440 --> 00:37:03,610
the client only has to apply individual

00:37:01,600 --> 00:37:04,780
edits on top of that and that's much

00:37:03,610 --> 00:37:06,700
more lenient because then you get sort

00:37:04,780 --> 00:37:08,080
of one at a time at the speed that users

00:37:06,700 --> 00:37:09,340
are able to type and let me sort of

00:37:08,080 --> 00:37:10,930
there it's okay that it's a little

00:37:09,340 --> 00:37:17,500
slower and it will still pretty much be

00:37:10,930 --> 00:37:21,520
immediate so we use Cassandra's the

00:37:17,500 --> 00:37:23,200
underlying database to store this event

00:37:21,520 --> 00:37:25,270
journal which actually is a very nice

00:37:23,200 --> 00:37:26,650
because you can't query much in

00:37:25,270 --> 00:37:28,990
Cassandra but the thing you can query

00:37:26,650 --> 00:37:31,869
the primary key it's actually ordered on

00:37:28,990 --> 00:37:35,250
this according to that so no matter what

00:37:31,869 --> 00:37:36,820
you're storing once cassandra has done

00:37:35,250 --> 00:37:38,650
reordering it stuff

00:37:36,820 --> 00:37:40,359
if you queried by the same key that you

00:37:38,650 --> 00:37:41,800
stored it under you'll get it really

00:37:40,359 --> 00:37:43,510
really fast especially if you have a lot

00:37:41,800 --> 00:37:45,010
of small rows they'll sit together on

00:37:43,510 --> 00:37:46,720
the disk sectors of your spinning this

00:37:45,010 --> 00:37:51,190
corner on your SSD together in one

00:37:46,720 --> 00:37:55,630
sector it will basically be B be fast

00:37:51,190 --> 00:37:58,630
enough to use however one thing that we

00:37:55,630 --> 00:38:00,880
are working with is that in particular

00:37:58,630 --> 00:38:02,950
with akka and the recent change we use a

00:38:00,880 --> 00:38:04,930
cup resistance as the layer on top of

00:38:02,950 --> 00:38:07,180
Cassandra there's some latency between

00:38:04,930 --> 00:38:09,730
you dropping something inside the

00:38:07,180 --> 00:38:12,310
persistence plugin and a running query

00:38:09,730 --> 00:38:14,200
actually seeing that event which in

00:38:12,310 --> 00:38:15,339
early implementations used to be in tens

00:38:14,200 --> 00:38:18,339
of milliseconds but now it's actually

00:38:15,339 --> 00:38:19,450
grown to almost a second just because of

00:38:18,339 --> 00:38:21,730
the way that the polling and stuff is

00:38:19,450 --> 00:38:24,190
implemented which we're not quite sure

00:38:21,730 --> 00:38:27,730
what to do with because on the one hand

00:38:24,190 --> 00:38:29,349
you want your api's to be fun and snappy

00:38:27,730 --> 00:38:31,630
right if you store something here to pop

00:38:29,349 --> 00:38:34,270
out the other and pretty quickly but ten

00:38:31,630 --> 00:38:35,950
milliseconds is kind of we could

00:38:34,270 --> 00:38:37,359
certainly do that but users are not

00:38:35,950 --> 00:38:39,099
gonna be ten to the seconds away from us

00:38:37,359 --> 00:38:41,109
anyways right they're gonna be crossed

00:38:39,099 --> 00:38:43,140
over or maybe on a mobile phone so the

00:38:41,109 --> 00:38:45,099
ping time to those folks it's gonna be

00:38:43,140 --> 00:38:48,400
orders of hundreds of those seconds

00:38:45,099 --> 00:38:50,380
anyway so there's you know we we're kind

00:38:48,400 --> 00:38:52,630
of working on both from the UI UX

00:38:50,380 --> 00:38:53,650
perspective to attack that and then also

00:38:52,630 --> 00:39:00,670
from a technological perspective

00:38:53,650 --> 00:39:02,800
underneath yeah we went through actually

00:39:00,670 --> 00:39:05,200
a couple of iterations trying to build

00:39:02,800 --> 00:39:09,339
this application and we actually didn't

00:39:05,200 --> 00:39:11,109
immediately choose garage s I first

00:39:09,339 --> 00:39:13,569
played around with react Redux and

00:39:11,109 --> 00:39:15,310
typescript but this was about a year or

00:39:13,569 --> 00:39:17,319
two ago so things have obviously moved

00:39:15,310 --> 00:39:19,000
on since but we couldn't really make

00:39:17,319 --> 00:39:20,410
that work nicely the tooling wasn't

00:39:19,000 --> 00:39:23,200
quite there not all the libraries work

00:39:20,410 --> 00:39:25,720
together and sort of the the the half

00:39:23,200 --> 00:39:29,170
typed nature of the typescript

00:39:25,720 --> 00:39:31,720
approached we didn't really feel very I

00:39:29,170 --> 00:39:33,010
say very secure with that and then we

00:39:31,720 --> 00:39:34,210
thought well if typescript doesn't

00:39:33,010 --> 00:39:35,650
really work we have all these front-end

00:39:34,210 --> 00:39:37,090
a second code JavaScript anyway let's

00:39:35,650 --> 00:39:39,220
just try do it in plain Jam

00:39:37,090 --> 00:39:40,840
script which gets you some of the way

00:39:39,220 --> 00:39:42,730
there but especially the kind of stuff

00:39:40,840 --> 00:39:44,200
we're doing here with pattern matching

00:39:42,730 --> 00:39:47,560
trying to fight okay so if we're seeing

00:39:44,200 --> 00:39:49,480
added with an RD tag here inside this

00:39:47,560 --> 00:39:50,890
and then extract that to here if you

00:39:49,480 --> 00:39:53,620
have to write if statements around that

00:39:50,890 --> 00:39:56,710
you completely lose your head and then

00:39:53,620 --> 00:39:57,910
there's L which you know is it would

00:39:56,710 --> 00:40:03,490
have been the really nice fit for this

00:39:57,910 --> 00:40:05,710
but the we didn't we didn't run with it

00:40:03,490 --> 00:40:07,630
because it lacked server sites reuse of

00:40:05,710 --> 00:40:09,160
the code which we thought we were gonna

00:40:07,630 --> 00:40:10,990
and going to need and we actually do

00:40:09,160 --> 00:40:12,700
need it and there's also the you know

00:40:10,990 --> 00:40:14,170
the maturity aspect of it so maybe in a

00:40:12,700 --> 00:40:15,330
few years it will be really good fit for

00:40:14,170 --> 00:40:17,800
this

00:40:15,330 --> 00:40:19,900
who knows but we're really happy with

00:40:17,800 --> 00:40:21,850
Scala yes especially the the size of the

00:40:19,900 --> 00:40:24,010
community at really has really amazed me

00:40:21,850 --> 00:40:26,800
you can find anything that you you think

00:40:24,010 --> 00:40:29,290
ought to be available like the shield ER

00:40:26,800 --> 00:40:31,180
library the the way to format currencies

00:40:29,290 --> 00:40:33,340
and and dates and other things for

00:40:31,180 --> 00:40:34,390
particular countries which is

00:40:33,340 --> 00:40:36,220
traditionally actually a really hard

00:40:34,390 --> 00:40:37,720
thing to write a proper library for and

00:40:36,220 --> 00:40:41,830
a couple of JavaScript attempts and they

00:40:37,720 --> 00:40:43,930
were all sort of yeah big and and clunky

00:40:41,830 --> 00:40:45,040
there are actually two Scala GS

00:40:43,930 --> 00:40:48,910
implementations that both work really

00:40:45,040 --> 00:40:50,290
well and and all these aspects that are

00:40:48,910 --> 00:40:52,630
traditionally hard to solve for some

00:40:50,290 --> 00:40:54,370
reason the people that that know how to

00:40:52,630 --> 00:40:55,930
solve them properly happen to land on

00:40:54,370 --> 00:40:58,410
Scala she hasn't to me that that's also

00:40:55,930 --> 00:40:58,410
a good sign

00:40:58,780 --> 00:41:08,320
yeah so concluding remarks we're quite

00:41:02,830 --> 00:41:10,930
happy where this is going we are we will

00:41:08,320 --> 00:41:15,130
actually be releasing the AP is related

00:41:10,930 --> 00:41:16,840
to this later in in 2018 probably also

00:41:15,130 --> 00:41:21,460
the source code to sort of a more

00:41:16,840 --> 00:41:23,290
working prototype so that you know we

00:41:21,460 --> 00:41:29,080
can also push third-party integrators to

00:41:23,290 --> 00:41:30,790
work more on this approach and yeah like

00:41:29,080 --> 00:41:33,010
I said we're we're extremely happy where

00:41:30,790 --> 00:41:35,500
it takes us another thing about with is

00:41:33,010 --> 00:41:37,090
that this got me working together with

00:41:35,500 --> 00:41:39,310
with other team members who had not seen

00:41:37,090 --> 00:41:41,380
Scala before in it they don't Java in a

00:41:39,310 --> 00:41:43,270
bit of JavaScript but remarkably they

00:41:41,380 --> 00:41:44,830
were able to pick up Scala you know in

00:41:43,270 --> 00:41:47,890
in a few weeks and just start coding

00:41:44,830 --> 00:41:50,020
with it just by you know the wealth of

00:41:47,890 --> 00:41:52,330
documentation and they're the

00:41:50,020 --> 00:41:53,920
and the good to Taurus a Tartar these

00:41:52,330 --> 00:41:57,339
days I've had very different experiences

00:41:53,920 --> 00:41:59,250
only only a few years back so yeah we

00:41:57,339 --> 00:42:01,560
are record happy right has taken us

00:41:59,250 --> 00:42:06,230
thanks

00:42:01,560 --> 00:42:06,230

YouTube URL: https://www.youtube.com/watch?v=WDbXA3iJgkE


