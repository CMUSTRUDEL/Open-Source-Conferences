Title: Migrating to Scala 2.13 by Julien Richard Foy and Stefan Zeiger
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6924-migrating-to-scala-2.13.html
Captions: 
	00:00:04,620 --> 00:00:11,219
thanks for coming I'm Julia from scare

00:00:08,100 --> 00:00:14,400
Center I'm Stefan I work at light band

00:00:11,219 --> 00:00:16,350
on the Scala compiler team and we're

00:00:14,400 --> 00:00:23,730
going to talk about migrating your code

00:00:16,350 --> 00:00:25,109
to Scala 2:13 today so in case you

00:00:23,730 --> 00:00:27,570
missed Adrienne's talked in the previous

00:00:25,109 --> 00:00:32,279
slot I'd like to give you a quick

00:00:27,570 --> 00:00:33,780
overview of Scala 213 some of the of the

00:00:32,279 --> 00:00:35,550
big topics from the road map I'm

00:00:33,780 --> 00:00:37,740
actually linking to the road map here so

00:00:35,550 --> 00:00:39,930
you can look up the details so the

00:00:37,740 --> 00:00:41,970
biggest thing we're doing is simplifying

00:00:39,930 --> 00:00:44,190
the collections library we're by

00:00:41,970 --> 00:00:46,710
simplifying means that we actually

00:00:44,190 --> 00:00:50,820
redesigned it from scratch which happens

00:00:46,710 --> 00:00:54,540
the last time in 2008 or 9 for Scala 2.8

00:00:50,820 --> 00:00:56,220
so this is a big step we also have some

00:00:54,540 --> 00:00:58,230
further compiler performance

00:00:56,220 --> 00:01:02,280
improvements that did not make it into a

00:00:58,230 --> 00:01:03,750
scholar 212 we continued modularizing

00:01:02,280 --> 00:01:06,630
the standard library

00:01:03,750 --> 00:01:08,220
we'll get to that in a bit what that

00:01:06,630 --> 00:01:10,350
means for you when you're migrating and

00:01:08,220 --> 00:01:12,109
we're trying to improve user

00:01:10,350 --> 00:01:14,429
friendliness which means things like

00:01:12,109 --> 00:01:19,049
documentation and a nicer repple and

00:01:14,429 --> 00:01:20,520
nicer error messages so the current

00:01:19,049 --> 00:01:22,950
status is Scala

00:01:20,520 --> 00:01:25,740
213 Oh milestone 4 was released

00:01:22,950 --> 00:01:27,569
yesterday I already gave this talk two

00:01:25,740 --> 00:01:29,700
days ago and it still said shortly on

00:01:27,569 --> 00:01:33,689
there so now it's out you can actually

00:01:29,700 --> 00:01:37,170
try it it's on maven central and this is

00:01:33,689 --> 00:01:38,639
maybe the biggest biggest milestone in

00:01:37,170 --> 00:01:40,679
years because it's the first milestone

00:01:38,639 --> 00:01:43,229
with the new collections library a mess

00:01:40,679 --> 00:01:46,170
we still had the old one there will be

00:01:43,229 --> 00:01:48,389
another milestone release m5 where we're

00:01:46,170 --> 00:01:51,030
doing minor API changes to the

00:01:48,389 --> 00:01:53,639
collections plus bug fixes and

00:01:51,030 --> 00:01:58,799
performance improvements and all the

00:01:53,639 --> 00:02:00,659
small details that are not yet an m4 so

00:01:58,799 --> 00:02:02,729
I assume you're all here because you

00:02:00,659 --> 00:02:06,060
already have a project that works on

00:02:02,729 --> 00:02:08,810
scarlet 212 or maybe even cross builds

00:02:06,060 --> 00:02:11,940
on 212 and earlier versions like 211 and

00:02:08,810 --> 00:02:15,209
you'd want to upgrade that to use Scala

00:02:11,940 --> 00:02:18,030
213 so that means you're going to target

00:02:15,209 --> 00:02:21,000
Scala 230 no milestone for the one we

00:02:18,030 --> 00:02:23,100
just released or higher and we're using

00:02:21,000 --> 00:02:24,510
an SPT built here for the examples that

00:02:23,100 --> 00:02:26,550
we're showing I'm sure you can do the

00:02:24,510 --> 00:02:32,190
same with other build tools but I don't

00:02:26,550 --> 00:02:34,800
know how okay so instead of just jumping

00:02:32,190 --> 00:02:38,400
riding and on typing sets gala version

00:02:34,800 --> 00:02:40,890
equals to 13 om for an SPT it's easier

00:02:38,400 --> 00:02:43,080
if you first prepare for the migration

00:02:40,890 --> 00:02:45,840
by starting on to 12 or whatever you're

00:02:43,080 --> 00:02:47,550
using now because there are some things

00:02:45,840 --> 00:02:50,910
you can already do there to ensure a

00:02:47,550 --> 00:02:52,920
smoother migration path and one of the

00:02:50,910 --> 00:02:56,610
reasons for that is that we remove many

00:02:52,920 --> 00:02:57,930
deprecated API Xin 213 for example in

00:02:56,610 --> 00:03:00,209
the collections there were things like

00:02:57,930 --> 00:03:02,700
Java conversions which were long

00:03:00,209 --> 00:03:06,300
deprecated in favor of Java converters

00:03:02,700 --> 00:03:08,519
but we're still carried on with each new

00:03:06,300 --> 00:03:11,250
version but now that we did the complete

00:03:08,519 --> 00:03:13,830
redesign we didn't want to port all that

00:03:11,250 --> 00:03:17,160
old code over so we just left it out and

00:03:13,830 --> 00:03:18,840
we also removed Mike deprecated stuff

00:03:17,160 --> 00:03:23,519
outside of the collections library

00:03:18,840 --> 00:03:26,160
so in SBT at deprecation to your Scala

00:03:23,519 --> 00:03:27,690
see options and compile and see what

00:03:26,160 --> 00:03:29,549
comes up and if there are any

00:03:27,690 --> 00:03:32,220
deprecations it's best to remove them

00:03:29,549 --> 00:03:34,530
first and when you have a clean build

00:03:32,220 --> 00:03:38,489
without deprecations in 212 this should

00:03:34,530 --> 00:03:40,200
make the migration much easier another

00:03:38,489 --> 00:03:42,810
thing that we removed is a bunch of

00:03:40,200 --> 00:03:45,540
compiler flags namely the ones that

00:03:42,810 --> 00:03:48,420
modify the source language in particular

00:03:45,540 --> 00:03:50,850
those are wino adapted arcs extract

00:03:48,420 --> 00:03:53,489
inference X full apps why overwrite

00:03:50,850 --> 00:03:55,829
objects why override VARs why infer

00:03:53,489 --> 00:03:58,829
argument types and why vert Pat Matt

00:03:55,829 --> 00:04:01,829
many of those were like half-finished

00:03:58,829 --> 00:04:05,010
or never intended to really be used or

00:04:01,829 --> 00:04:07,260
experimental so they're all gone the

00:04:05,010 --> 00:04:09,989
idea is from now from now on you should

00:04:07,260 --> 00:04:11,640
use X source in order to modify the

00:04:09,989 --> 00:04:13,650
source language we want to avoid the

00:04:11,640 --> 00:04:15,359
fragmentation of the language and only

00:04:13,650 --> 00:04:18,570
give you source level so you can say

00:04:15,359 --> 00:04:21,989
compile this as if it were on Scala 212

00:04:18,570 --> 00:04:24,510
as far as possible you can find more

00:04:21,989 --> 00:04:27,270
information on the actual pull requests

00:04:24,510 --> 00:04:28,770
that we moved those flags there's one in

00:04:27,270 --> 00:04:31,560
particular that I'd like to point out

00:04:28,770 --> 00:04:33,360
that is why no adapted arcs because

00:04:31,560 --> 00:04:36,510
probably the most popular one of those

00:04:33,360 --> 00:04:39,480
that you may use routinely in your bills

00:04:36,510 --> 00:04:43,260
and this is used to turn off argument

00:04:39,480 --> 00:04:46,350
adaptation and Auto toppling because

00:04:43,260 --> 00:04:49,260
they have some let's say dangerous

00:04:46,350 --> 00:04:52,200
corner cases where unintended adaptation

00:04:49,260 --> 00:04:54,630
can happen and there is no way to turn

00:04:52,200 --> 00:04:59,780
that off entirely anymore the goal is

00:04:54,630 --> 00:05:02,280
that we remove the dangerous cases and

00:04:59,780 --> 00:05:03,990
always keep the non dangerous ones

00:05:02,280 --> 00:05:06,570
enabled and that's what what daddy

00:05:03,990 --> 00:05:09,479
already does basically so Dada has has

00:05:06,570 --> 00:05:11,910
more restrictive adaptation and Scala

00:05:09,479 --> 00:05:14,790
2:14 will align with study in that

00:05:11,910 --> 00:05:17,010
regard one feature in particular that we

00:05:14,790 --> 00:05:20,100
already have now in 2:13 that you can

00:05:17,010 --> 00:05:23,790
use is that we disable automatic ADA

00:05:20,100 --> 00:05:26,160
expansion of zero arc methods so when

00:05:23,790 --> 00:05:28,500
you when you have a method and which

00:05:26,160 --> 00:05:32,160
does not have an empty parameter list

00:05:28,500 --> 00:05:34,050
and pass that you need to put an

00:05:32,160 --> 00:05:36,750
underscore there if you want to use it

00:05:34,050 --> 00:05:39,750
as a function to get get any expansion

00:05:36,750 --> 00:05:42,180
but this is only under ex or Stu 14 so

00:05:39,750 --> 00:05:48,060
you need to opt into that it's off by

00:05:42,180 --> 00:05:50,190
default in 213 another thing that we

00:05:48,060 --> 00:05:54,590
cleaned up or removed is modules

00:05:50,190 --> 00:05:58,320
does anyone here using Scala library all

00:05:54,590 --> 00:06:00,030
nobody has expected so in case you find

00:05:58,320 --> 00:06:02,190
it somewhere just replace it by

00:06:00,030 --> 00:06:04,080
individual dependencies because really

00:06:02,190 --> 00:06:06,570
nobody was using it so there's there's

00:06:04,080 --> 00:06:08,850
no point in having it the parallel

00:06:06,570 --> 00:06:10,590
collections have also been moved into a

00:06:08,850 --> 00:06:13,560
separate module they're no longer part

00:06:10,590 --> 00:06:17,760
of the standard collection library and

00:06:13,560 --> 00:06:19,380
this is already in EM 3 so if you if

00:06:17,760 --> 00:06:21,330
you're building on m3 you will encounter

00:06:19,380 --> 00:06:23,550
this there's a separate parallel

00:06:21,330 --> 00:06:26,370
collections module that is published for

00:06:23,550 --> 00:06:29,340
M suis we have not yet adapted it to m4

00:06:26,370 --> 00:06:31,889
if you're using it on M suis file follow

00:06:29,340 --> 00:06:33,690
these instructions that I'm linking here

00:06:31,889 --> 00:06:37,200
for how to cross build we're going to

00:06:33,690 --> 00:06:40,440
make it simpler for m4 and finally Scala

00:06:37,200 --> 00:06:42,210
XML is still there but it's no longer a

00:06:40,440 --> 00:06:45,270
transitive dependency of Scala compiler

00:06:42,210 --> 00:06:46,800
which is probably more exciting for me

00:06:45,270 --> 00:06:48,900
and the rest of the compiler team than

00:06:46,800 --> 00:06:50,610
it is for you because it means we no

00:06:48,900 --> 00:06:52,350
longer rely on this for bootstrapping

00:06:50,610 --> 00:06:54,600
we're no longer using it in Scala doc

00:06:52,350 --> 00:06:56,970
but if you relied on this dependency

00:06:54,600 --> 00:07:01,950
just add a direct dependency on Scala

00:06:56,970 --> 00:07:04,140
XML so now that you've cleaned up your

00:07:01,950 --> 00:07:08,270
build Julian will tell you what to do on

00:07:04,140 --> 00:07:08,270
2:13 okay

00:07:09,840 --> 00:07:16,020
so all you have to do is to use 2:13 oh

00:07:13,770 --> 00:07:20,220
and for as your scalloped version in

00:07:16,020 --> 00:07:24,840
your build definition and then if you

00:07:20,220 --> 00:07:26,280
want to use separate options for if you

00:07:24,840 --> 00:07:28,350
if you are cross building for several

00:07:26,280 --> 00:07:30,690
scale versions and you want to use

00:07:28,350 --> 00:07:33,620
separate options for specific scale

00:07:30,690 --> 00:07:37,680
versions you can use this expression and

00:07:33,620 --> 00:07:41,640
here the important part is here where we

00:07:37,680 --> 00:07:46,590
check that the minor version of Scala is

00:07:41,640 --> 00:07:50,490
higher or require than 13 and here this

00:07:46,590 --> 00:07:53,340
is an example where we show the closest

00:07:50,490 --> 00:07:59,700
option we have to the argument

00:07:53,340 --> 00:08:03,110
adaptation options and then you can try

00:07:59,700 --> 00:08:06,510
to compile and you might get some

00:08:03,110 --> 00:08:11,750
computation error probably due to the

00:08:06,510 --> 00:08:15,660
new correction API and also if you use

00:08:11,750 --> 00:08:18,720
single item types there might be changes

00:08:15,660 --> 00:08:21,390
in the way implicit resolution works

00:08:18,720 --> 00:08:25,980
with singleton types and you might hit

00:08:21,390 --> 00:08:27,570
some corner cases where you could used

00:08:25,980 --> 00:08:31,590
to compile but does not compile anymore

00:08:27,570 --> 00:08:34,410
and you might hit some of the source

00:08:31,590 --> 00:08:38,310
language incompatibilities that define

00:08:34,410 --> 00:08:41,880
just talked about so a short-term

00:08:38,310 --> 00:08:45,090
solution to fix - I mean workaround to

00:08:41,880 --> 00:08:50,460
fix this soft language incompatibilities

00:08:45,090 --> 00:08:52,790
is to use X source to 12 as a compiler

00:08:50,460 --> 00:08:52,790
option

00:08:53,570 --> 00:09:01,250
and then if you want to cross beat your

00:08:57,449 --> 00:09:07,050
project with several scatter versions

00:09:01,250 --> 00:09:11,279
you might get into trouble because the

00:09:07,050 --> 00:09:13,680
the new API of the new Corrections is

00:09:11,279 --> 00:09:18,209
sometimes just different from the the

00:09:13,680 --> 00:09:21,269
old API and we couldn't and also yes we

00:09:18,209 --> 00:09:23,970
have deprecated some types and some

00:09:21,269 --> 00:09:26,010
operations in the new Corrections so if

00:09:23,970 --> 00:09:29,910
you want to have a code that was build

00:09:26,010 --> 00:09:37,199
and that was built without warnings in

00:09:29,910 --> 00:09:39,810
both 211 212 and and also 213 you the

00:09:37,199 --> 00:09:43,500
option that you have is to use this

00:09:39,810 --> 00:09:51,480
library scalar correction compat that

00:09:43,500 --> 00:09:54,930
brings the 213 syntax in 211 and 212 so

00:09:51,480 --> 00:09:57,779
in practice you just add a dependency to

00:09:54,930 --> 00:10:01,829
this module scalar collection compat and

00:09:57,779 --> 00:10:03,870
I think this version has been released

00:10:01,829 --> 00:10:04,350
yesterday or is going to be released

00:10:03,870 --> 00:10:05,940
soon

00:10:04,350 --> 00:10:10,139
it has been released it has been

00:10:05,940 --> 00:10:12,000
released and then so this is the old way

00:10:10,139 --> 00:10:14,100
of converting a correction to another

00:10:12,000 --> 00:10:17,430
correction we used to to pass a type

00:10:14,100 --> 00:10:20,550
here and the new syntax consists in

00:10:17,430 --> 00:10:23,490
passing a value so here we pass a value

00:10:20,550 --> 00:10:27,779
list with singleton the companion object

00:10:23,490 --> 00:10:31,350
list and why why did we do that because

00:10:27,779 --> 00:10:34,529
now here you can you can use for

00:10:31,350 --> 00:10:38,569
instance map to convert a correction to

00:10:34,529 --> 00:10:38,569
a map and that was not possible before

00:10:39,019 --> 00:10:44,519
so this is a new syntax and this doesn't

00:10:42,000 --> 00:10:46,980
compile anymore is 211 and 212 but if

00:10:44,519 --> 00:10:50,550
you use the compatibility library and if

00:10:46,980 --> 00:10:52,769
you write this input then this import

00:10:50,550 --> 00:10:55,610
will provide some implicit definition

00:10:52,769 --> 00:11:00,870
that we that will make this code compile

00:10:55,610 --> 00:11:05,130
also on twitter 1 + 2 12 and on - 13

00:11:00,870 --> 00:11:06,190
because this is as you can see a library

00:11:05,130 --> 00:11:10,930
that is Crosby

00:11:06,190 --> 00:11:14,230
for 211 212 and 213 so on 213 we just

00:11:10,930 --> 00:11:19,990
provide a almost empty packet object and

00:11:14,230 --> 00:11:22,780
just for the import to work and there

00:11:19,990 --> 00:11:26,760
are also other changes in the new

00:11:22,780 --> 00:11:30,250
collection that define we'll talk about

00:11:26,760 --> 00:11:32,620
okay so first I'd like to start with a

00:11:30,250 --> 00:11:34,900
quick recap of the goals of the

00:11:32,620 --> 00:11:37,060
collection redesign just to give you an

00:11:34,900 --> 00:11:38,320
idea of what the interesting things

00:11:37,060 --> 00:11:39,850
there are before we get to the

00:11:38,320 --> 00:11:42,520
problematic parts that will break your

00:11:39,850 --> 00:11:45,460
build so the main goal was to have a

00:11:42,520 --> 00:11:47,970
simpler user facing API so when you call

00:11:45,460 --> 00:11:51,040
the collections library in particular

00:11:47,970 --> 00:11:54,160
nobody loved can build from so we're

00:11:51,040 --> 00:11:55,360
almost removing it and we're also making

00:11:54,160 --> 00:11:57,280
things easier for collection

00:11:55,360 --> 00:12:00,400
implementers there's this less

00:11:57,280 --> 00:12:03,250
boilerplate to write and if you are

00:12:00,400 --> 00:12:05,350
implementing lazy collection types it's

00:12:03,250 --> 00:12:07,510
a lot easier now because everything is

00:12:05,350 --> 00:12:10,930
lazy by default so you don't have to

00:12:07,510 --> 00:12:13,330
override everything and the hierarchy is

00:12:10,930 --> 00:12:15,610
much simpler so all these strange Jen

00:12:13,330 --> 00:12:17,530
collection types are gone which not only

00:12:15,610 --> 00:12:20,230
helps collection implementers but it

00:12:17,530 --> 00:12:22,720
also helps everybody because it makes

00:12:20,230 --> 00:12:25,900
the compiler faster there are far fewer

00:12:22,720 --> 00:12:29,470
super classes now so type inference gets

00:12:25,900 --> 00:12:32,620
faster so let's get to the problematic

00:12:29,470 --> 00:12:35,290
part the most the biggest change the one

00:12:32,620 --> 00:12:37,120
that everyone will encounter in their

00:12:35,290 --> 00:12:40,510
build is that Scala

00:12:37,120 --> 00:12:42,670
seek is now immutable by default so this

00:12:40,510 --> 00:12:44,650
used to be in a type alias to Scala

00:12:42,670 --> 00:12:47,470
collection seek and nowadays Scala

00:12:44,650 --> 00:12:50,470
collection immutable seek and the same

00:12:47,470 --> 00:12:52,330
goes for indexed seek this Alliance was

00:12:50,470 --> 00:12:55,030
set on map which were already the

00:12:52,330 --> 00:12:57,190
immutable versions and everybody really

00:12:55,030 --> 00:13:00,360
wanted immutability for everything by

00:12:57,190 --> 00:13:03,210
default so we finally did that

00:13:00,360 --> 00:13:05,740
unfortunately there's no easy way to

00:13:03,210 --> 00:13:07,080
automatically migrate to this because

00:13:05,740 --> 00:13:10,839
you have to decide on a case-by-case

00:13:07,080 --> 00:13:13,300
basis which one you really want in some

00:13:10,839 --> 00:13:15,580
cases like VAR arcs which I'm getting to

00:13:13,300 --> 00:13:18,370
on the next slide you will have to use

00:13:15,580 --> 00:13:19,720
the immutable ones in many cases you

00:13:18,370 --> 00:13:22,209
probably intended

00:13:19,720 --> 00:13:23,829
use the immutable ones but you just

00:13:22,209 --> 00:13:27,129
didn't realize it and use the generic

00:13:23,829 --> 00:13:30,040
one so those are fine too and get other

00:13:27,129 --> 00:13:32,319
cases you actually want to abstract over

00:13:30,040 --> 00:13:34,750
both mutable and immutable collections

00:13:32,319 --> 00:13:37,509
so you have to use Scala collection seek

00:13:34,750 --> 00:13:39,850
explicitly and in any case when you

00:13:37,509 --> 00:13:41,589
cross building you should not use Scala

00:13:39,850 --> 00:13:43,120
to seek just reference scholar

00:13:41,589 --> 00:13:48,310
collection see course color collection

00:13:43,120 --> 00:13:51,250
immutable seek whichever one you want so

00:13:48,310 --> 00:13:53,350
what is the reason why seek was not

00:13:51,250 --> 00:13:56,019
immutable by default in the first place

00:13:53,350 --> 00:13:58,540
because set and map already were well

00:13:56,019 --> 00:14:00,670
the reason was of are arcs marks are

00:13:58,540 --> 00:14:04,300
part of the Scala language specification

00:14:00,670 --> 00:14:06,399
and the spec is only supposed to refer

00:14:04,300 --> 00:14:08,740
to types directly in the Scala package

00:14:06,399 --> 00:14:12,250
so no Scala collection whatever it had

00:14:08,740 --> 00:14:15,160
to be scarlet seek and unfortunately we

00:14:12,250 --> 00:14:18,279
need Java interoperability and Java uses

00:14:15,160 --> 00:14:22,149
erase for VAR arcs which are mutable so

00:14:18,279 --> 00:14:24,579
that's why we had an immutable a generic

00:14:22,149 --> 00:14:28,149
default seek so it could handle a Java

00:14:24,579 --> 00:14:30,850
erase of course var arcs are not really

00:14:28,149 --> 00:14:33,160
supposed to be mutable not even in Java

00:14:30,850 --> 00:14:34,990
what everyone in Java does is pass an

00:14:33,160 --> 00:14:36,750
array and hope for the best that nobody

00:14:34,990 --> 00:14:38,949
does anything strange with it because

00:14:36,750 --> 00:14:40,779
you really expected that they are

00:14:38,949 --> 00:14:44,319
immutable so we assume the same thing

00:14:40,779 --> 00:14:46,360
now and we still have to interoperate

00:14:44,319 --> 00:14:48,850
with Java so there's a new type called

00:14:46,360 --> 00:14:52,629
Scala collection immutable array seek

00:14:48,850 --> 00:14:57,250
which is a pretend immutable wrapper for

00:14:52,629 --> 00:14:59,740
an array and it's useful for performance

00:14:57,250 --> 00:15:01,809
so you can also use it in your own cone

00:14:59,740 --> 00:15:04,300
the code there's a method array seek dot

00:15:01,809 --> 00:15:06,189
unsafe wrap array which will take an

00:15:04,300 --> 00:15:09,850
array and give you this pretend

00:15:06,189 --> 00:15:13,660
immutable seek for it we still have a an

00:15:09,850 --> 00:15:16,629
implicit conversion to Scala datsuk

00:15:13,660 --> 00:15:20,050
which makes a lot of code compiled that

00:15:16,629 --> 00:15:21,879
would otherwise break but it now copies

00:15:20,050 --> 00:15:24,189
the array because we pretend that the

00:15:21,879 --> 00:15:25,360
resulting seek is immutable so that's

00:15:24,189 --> 00:15:27,670
something you don't want to do by

00:15:25,360 --> 00:15:29,920
accident so if you still have the

00:15:27,670 --> 00:15:32,589
deprecation warnings turned off turned

00:15:29,920 --> 00:15:33,130
on from building on 212 and removing all

00:15:32,589 --> 00:15:35,230
the deck

00:15:33,130 --> 00:15:37,990
it calls you will get this error message

00:15:35,230 --> 00:15:39,970
here that tells you either use an

00:15:37,990 --> 00:15:42,820
explicit to index seek call if you

00:15:39,970 --> 00:15:46,950
really want to copy or call an safe rap

00:15:42,820 --> 00:15:46,950
array manually if that's what you want

00:15:47,610 --> 00:15:54,070
so the other really big change is can

00:15:51,010 --> 00:15:56,500
build from so can built from is gone

00:15:54,070 --> 00:16:00,820
well at least three letters of it are

00:15:56,500 --> 00:16:05,380
gone that's now called built from but

00:16:00,820 --> 00:16:08,290
it's rarely used so if you look at the

00:16:05,380 --> 00:16:10,960
definition here where I removed all the

00:16:08,290 --> 00:16:13,720
deprecated forwarders built from almost

00:16:10,960 --> 00:16:15,820
looks like the old hand built from it

00:16:13,720 --> 00:16:17,770
has a from type an element type and a

00:16:15,820 --> 00:16:20,020
target type and there's a method called

00:16:17,770 --> 00:16:22,120
new builder which looks just like the

00:16:20,020 --> 00:16:25,180
old apply method there's one crucial

00:16:22,120 --> 00:16:28,330
difference though this new builder needs

00:16:25,180 --> 00:16:30,160
a from and in the new collections

00:16:28,330 --> 00:16:32,350
library you can not only use builders

00:16:30,160 --> 00:16:34,360
you can also build lazy new so you need

00:16:32,350 --> 00:16:37,000
to use from specific iterable for that

00:16:34,360 --> 00:16:39,970
and it also takes a from so there is no

00:16:37,000 --> 00:16:41,890
way to use it can't build from when you

00:16:39,970 --> 00:16:43,240
do not have an instance of the source

00:16:41,890 --> 00:16:46,680
collection that's the big difference

00:16:43,240 --> 00:16:50,790
there it always built something that is

00:16:46,680 --> 00:16:54,400
derived from the source collection and

00:16:50,790 --> 00:16:56,380
as I said it's rarely used we do not use

00:16:54,400 --> 00:16:59,050
it at all within the collection library

00:16:56,380 --> 00:17:03,160
instead what we do is we overload

00:16:59,050 --> 00:17:05,079
methods so if you have a map which has

00:17:03,160 --> 00:17:07,180
its own map method in addition to the

00:17:05,079 --> 00:17:10,060
iterables map methods there's another

00:17:07,180 --> 00:17:12,189
overload that implements the semantics

00:17:10,060 --> 00:17:14,890
correctly and gives you a map as a

00:17:12,189 --> 00:17:17,829
result and not an iterable why didn't we

00:17:14,890 --> 00:17:19,870
do this earlier in scala 2.8 for example

00:17:17,829 --> 00:17:22,060
well there were some problems with type

00:17:19,870 --> 00:17:25,240
inference for overloaded methods it was

00:17:22,060 --> 00:17:27,819
really bad at the time and it was still

00:17:25,240 --> 00:17:30,220
rather bad in 211 and we improved it

00:17:27,819 --> 00:17:32,860
into 12 and we're making even further

00:17:30,220 --> 00:17:34,510
improvements in 213 so now type

00:17:32,860 --> 00:17:37,510
inference for overloaded methods

00:17:34,510 --> 00:17:39,910
actually works in these cases so you

00:17:37,510 --> 00:17:42,010
should rarely encounter any problems you

00:17:39,910 --> 00:17:44,530
still use can build from in methods like

00:17:42,010 --> 00:17:46,440
future dot sequence which are outside of

00:17:44,530 --> 00:17:48,779
the collections library

00:17:46,440 --> 00:17:50,730
so you could ride it with overloads just

00:17:48,779 --> 00:17:52,590
right four or five different versions of

00:17:50,730 --> 00:17:54,659
sequence but you don't want to do that

00:17:52,590 --> 00:17:56,669
you want to ride only one so that's

00:17:54,659 --> 00:17:59,070
where you use build from and in practice

00:17:56,669 --> 00:18:01,080
as long as you have an instance of the

00:17:59,070 --> 00:18:03,539
source collection you can use build from

00:18:01,080 --> 00:18:05,250
almost exactly like the old can build

00:18:03,539 --> 00:18:10,559
from so this is it's really easy to

00:18:05,250 --> 00:18:12,509
change in your code there's a second

00:18:10,559 --> 00:18:15,509
replacement for can build from though

00:18:12,509 --> 00:18:18,899
and this is called factory again it

00:18:15,509 --> 00:18:21,269
looks almost the same as built from the

00:18:18,899 --> 00:18:24,240
difference being now there is no from

00:18:21,269 --> 00:18:27,480
type and there is no from element that

00:18:24,240 --> 00:18:30,059
you have to pass so target builds purely

00:18:27,480 --> 00:18:31,590
by target type and not by source

00:18:30,059 --> 00:18:33,870
collection we separated the two

00:18:31,590 --> 00:18:36,929
previously with can't build from you had

00:18:33,870 --> 00:18:39,389
this matrix of source and source type

00:18:36,929 --> 00:18:41,580
and element type and target type and

00:18:39,389 --> 00:18:43,590
then you had a huge search space for

00:18:41,580 --> 00:18:45,600
these can built from instances and lots

00:18:43,590 --> 00:18:48,059
of implicit stew provide them now we

00:18:45,600 --> 00:18:50,129
have two clearly separated ways of

00:18:48,059 --> 00:18:52,559
building either with built from from the

00:18:50,129 --> 00:18:56,039
source or with factory driven by the

00:18:52,559 --> 00:18:59,159
target type and the general rule there

00:18:56,039 --> 00:19:01,320
is the simple one that I I would like to

00:18:59,159 --> 00:19:03,210
tell you is use built from if you have a

00:19:01,320 --> 00:19:06,179
source collection instance otherwise use

00:19:03,210 --> 00:19:07,950
Factory of course the one instance where

00:19:06,179 --> 00:19:10,409
we actually use it inside the collection

00:19:07,950 --> 00:19:12,659
library defies this rule because it's a

00:19:10,409 --> 00:19:14,909
durable dot two when you convert to

00:19:12,659 --> 00:19:17,039
another collection you have an instance

00:19:14,909 --> 00:19:18,899
of the source collection obviously but

00:19:17,039 --> 00:19:20,549
you still use factory because you don't

00:19:18,899 --> 00:19:22,230
care what that source collection is you

00:19:20,549 --> 00:19:25,830
only care what you want to build because

00:19:22,230 --> 00:19:27,629
that's the whole point of the method and

00:19:25,830 --> 00:19:30,059
again if you have to change your code

00:19:27,629 --> 00:19:32,159
it's almost the same as using can build

00:19:30,059 --> 00:19:35,039
from before basically just replace the

00:19:32,159 --> 00:19:37,230
type name and that's it but you have to

00:19:35,039 --> 00:19:42,690
decide first if you want to use built

00:19:37,230 --> 00:19:44,909
from or factory so without can build

00:19:42,690 --> 00:19:47,370
from of course there is no break out

00:19:44,909 --> 00:19:50,159
anymore because there's no nowhere you

00:19:47,370 --> 00:19:52,169
could pass it to as I said all the

00:19:50,159 --> 00:19:55,470
methods like map and flatmap they are

00:19:52,169 --> 00:19:58,529
overloaded they do not take a candle

00:19:55,470 --> 00:20:00,360
from so in the usual case where you

00:19:58,529 --> 00:20:03,480
would have done something like

00:20:00,360 --> 00:20:05,400
X's dot map and pass a break out you now

00:20:03,480 --> 00:20:08,340
have to use an iterator and the to

00:20:05,400 --> 00:20:10,740
method iterator is always safe in these

00:20:08,340 --> 00:20:12,960
cases because if you use break out

00:20:10,740 --> 00:20:14,790
you're only consumed you're only

00:20:12,960 --> 00:20:17,040
iterated and consume the iterator

00:20:14,790 --> 00:20:20,130
exactly once so you don't need to bother

00:20:17,040 --> 00:20:23,820
with use just use an iterator and

00:20:20,130 --> 00:20:25,980
convert it explicitly in other cases

00:20:23,820 --> 00:20:28,650
there is a more direct replacement for

00:20:25,980 --> 00:20:30,600
break out I could not actually find an

00:20:28,650 --> 00:20:33,000
example where you have to migrate in

00:20:30,600 --> 00:20:36,179
this way but there's almost one and

00:20:33,000 --> 00:20:38,100
that's a future dot sequence so if you

00:20:36,179 --> 00:20:40,950
look at the old version here I have a

00:20:38,100 --> 00:20:43,740
have a list of future event and I want

00:20:40,950 --> 00:20:46,770
to sequence it to a future of vector of

00:20:43,740 --> 00:20:50,070
n rather than a future of list of end so

00:20:46,770 --> 00:20:52,200
instead of having the compiler find an

00:20:50,070 --> 00:20:55,200
implicit can built from I would pass

00:20:52,200 --> 00:20:57,900
breakout to this method so this doesn't

00:20:55,200 --> 00:21:00,090
actually work in 212 because the types

00:20:57,900 --> 00:21:02,910
of sequence are constrained in a way

00:21:00,090 --> 00:21:04,799
that you can only produce a future of

00:21:02,910 --> 00:21:08,160
list event but we have a ticket to make

00:21:04,799 --> 00:21:11,100
exactly this use case work and we did so

00:21:08,160 --> 00:21:15,450
in 213 with the direct replacement which

00:21:11,100 --> 00:21:18,120
is built from so what you do now instead

00:21:15,450 --> 00:21:20,190
of having to call pass break out and

00:21:18,120 --> 00:21:22,710
writing this long type a notation here

00:21:20,190 --> 00:21:24,419
you just pass the companion object of

00:21:22,710 --> 00:21:25,950
whatever you want to build and there's

00:21:24,419 --> 00:21:28,950
an implicit conversion from this

00:21:25,950 --> 00:21:31,590
companion object to factory and to build

00:21:28,950 --> 00:21:33,750
from so this means you do not have to

00:21:31,590 --> 00:21:35,549
write the complete type only the

00:21:33,750 --> 00:21:37,910
companion object which makes it much

00:21:35,549 --> 00:21:37,910
simpler

00:21:39,080 --> 00:21:45,090
another big incredibility

00:21:41,940 --> 00:21:47,220
are views but most people will probably

00:21:45,090 --> 00:21:51,960
not encounter them how many of you are

00:21:47,220 --> 00:21:59,549
using views currently I see three three

00:21:51,960 --> 00:22:01,799
hands four you are five okay so very few

00:21:59,549 --> 00:22:04,770
people are actually using views and four

00:22:01,799 --> 00:22:06,960
from many use cases they are still

00:22:04,770 --> 00:22:08,100
compatible even though we we started

00:22:06,960 --> 00:22:10,410
with a completely different approach

00:22:08,100 --> 00:22:12,530
using the new collection library are

00:22:10,410 --> 00:22:14,660
essentially reified iterator up

00:22:12,530 --> 00:22:17,240
operations so if you know Java eight

00:22:14,660 --> 00:22:19,490
streams you can think of view versus

00:22:17,240 --> 00:22:22,580
iterator as being similar to stream

00:22:19,490 --> 00:22:24,950
versus splitter Raider view is used to

00:22:22,580 --> 00:22:27,260
compose the iterator operations that you

00:22:24,950 --> 00:22:30,380
want to perform and then when you

00:22:27,260 --> 00:22:32,720
actually execute this you get an

00:22:30,380 --> 00:22:37,370
iterator that implements these

00:22:32,720 --> 00:22:39,590
operations and the difference of the old

00:22:37,370 --> 00:22:41,600
collections library is that these new

00:22:39,590 --> 00:22:43,490
views are no longer tied to the source

00:22:41,600 --> 00:22:46,040
collection type we still have something

00:22:43,490 --> 00:22:49,490
like map view or index view because they

00:22:46,040 --> 00:22:53,120
should provide special operations which

00:22:49,490 --> 00:22:55,640
are not available on every view but if

00:22:53,120 --> 00:22:57,800
you doesn't know from which kind of

00:22:55,640 --> 00:22:59,450
source collection it was built there is

00:22:57,800 --> 00:23:01,160
still a method called force for

00:22:59,450 --> 00:23:02,630
compatibility but you have to be aware

00:23:01,160 --> 00:23:05,390
that it always gives you a default

00:23:02,630 --> 00:23:08,810
collection type so in general you should

00:23:05,390 --> 00:23:11,300
call some explicit to operation in in

00:23:08,810 --> 00:23:14,510
order to convert back from a view to a

00:23:11,300 --> 00:23:16,400
proper collection there are two methods

00:23:14,510 --> 00:23:18,320
where you may have encountered views

00:23:16,400 --> 00:23:20,090
without knowing because I'm sure more

00:23:18,320 --> 00:23:22,760
than five of you have have used these

00:23:20,090 --> 00:23:25,970
views and that's in the methods map

00:23:22,760 --> 00:23:28,880
values and filter keys on a map they

00:23:25,970 --> 00:23:30,860
pretend to return a map but what you

00:23:28,880 --> 00:23:33,440
actually got is a view because it was

00:23:30,860 --> 00:23:35,060
lazy and I ran into this myself when I

00:23:33,440 --> 00:23:38,900
went to try to migrate the slick

00:23:35,060 --> 00:23:41,600
codebase to two thirteen om4 I called

00:23:38,900 --> 00:23:43,400
map values on a map with definitions to

00:23:41,600 --> 00:23:45,230
compute something and then repeatedly

00:23:43,400 --> 00:23:48,710
accessed those elements while traversing

00:23:45,230 --> 00:23:50,360
an ast which means every time I accessed

00:23:48,710 --> 00:23:52,610
the same map key the value was

00:23:50,360 --> 00:23:54,710
recomputed and I didn't know about it

00:23:52,610 --> 00:23:57,650
because it's actually a map view so in

00:23:54,710 --> 00:23:59,810
the new collections library we declare

00:23:57,650 --> 00:24:01,400
it as map view and a map view is no

00:23:59,810 --> 00:24:04,370
longer a map it is something different

00:24:01,400 --> 00:24:06,590
it is a view so if we run into any type

00:24:04,370 --> 00:24:08,630
errors because of this you have to add

00:24:06,590 --> 00:24:11,200
an explicit to map call in order to

00:24:08,630 --> 00:24:11,200
convert back

00:24:12,960 --> 00:24:17,310
of course there's an even bigger source

00:24:15,510 --> 00:24:19,020
of calm incompatibilities and that's

00:24:17,310 --> 00:24:22,460
when you implement custom collection

00:24:19,020 --> 00:24:28,110
types how many of you are doing that

00:24:22,460 --> 00:24:29,760
anyone one yeah but very few people

00:24:28,110 --> 00:24:32,130
actually do that and of course one of

00:24:29,760 --> 00:24:34,170
the reasons why so few people do that is

00:24:32,130 --> 00:24:36,330
that it's really complicated to do at

00:24:34,170 --> 00:24:38,070
the moment just understanding the type

00:24:36,330 --> 00:24:41,270
hierarchies and making sure you get the

00:24:38,070 --> 00:24:44,040
right can build from is really difficult

00:24:41,270 --> 00:24:46,710
so this this has changed quite a bit in

00:24:44,040 --> 00:24:48,870
the new design and usually unless you

00:24:46,710 --> 00:24:50,700
have very simple collection types like

00:24:48,870 --> 00:24:53,130
in a test case we just have to mock

00:24:50,700 --> 00:24:55,620
something there's no point in trying to

00:24:53,130 --> 00:24:57,720
cross both so you you create two

00:24:55,620 --> 00:25:01,860
different source files use one for two

00:24:57,720 --> 00:25:04,620
twelve and one for two thirteen we

00:25:01,860 --> 00:25:06,630
simplify the type hierarchy quite a bit

00:25:04,620 --> 00:25:08,670
so that you have fewer super classes now

00:25:06,630 --> 00:25:10,320
there's less boilerplate to write from

00:25:08,670 --> 00:25:13,770
any collections when you implement them

00:25:10,320 --> 00:25:15,990
and when you override any methods which

00:25:13,770 --> 00:25:17,340
you generally do because you want to

00:25:15,990 --> 00:25:18,720
make them more performant that's the

00:25:17,340 --> 00:25:21,390
whole point of implementing your own

00:25:18,720 --> 00:25:23,160
collection you now have to override a

00:25:21,390 --> 00:25:25,380
method with an alphabetic name

00:25:23,160 --> 00:25:27,780
previously where you'd override the plus

00:25:25,380 --> 00:25:30,690
plus method it's now called concat and

00:25:27,780 --> 00:25:34,320
plus plus is just an alias a final

00:25:30,690 --> 00:25:36,600
method that calls concat because we we

00:25:34,320 --> 00:25:38,160
want you to have a proper name for every

00:25:36,600 --> 00:25:40,020
method so you don't have to say plus

00:25:38,160 --> 00:25:43,680
plus you can you actually know it's

00:25:40,020 --> 00:25:45,600
called concat now and of course if you

00:25:43,680 --> 00:25:47,820
used can build from you have to overload

00:25:45,600 --> 00:25:51,270
instead just like we do in our own

00:25:47,820 --> 00:25:53,970
collection implementations so how would

00:25:51,270 --> 00:25:55,380
you do this in your SBT build well we

00:25:53,970 --> 00:25:57,980
can do it the same way as for the

00:25:55,380 --> 00:26:00,690
compiler flags that we've seen earlier

00:25:57,980 --> 00:26:04,350
spt actually supports this out of the

00:26:00,690 --> 00:26:06,720
box I I wasn't aware on this until of

00:26:04,350 --> 00:26:09,540
this until very recently so it's a bit

00:26:06,720 --> 00:26:11,820
hidden in SBT at least if you like me or

00:26:09,540 --> 00:26:15,830
in the habit of not reading the manuals

00:26:11,820 --> 00:26:18,450
for every new release so you already get

00:26:15,830 --> 00:26:21,060
that you are a cross version sauce

00:26:18,450 --> 00:26:24,030
directories by default so in addition to

00:26:21,060 --> 00:26:26,490
source main Scala if you build for these

00:26:24,030 --> 00:26:28,800
you would also get scar source

00:26:26,490 --> 00:26:31,740
mein Scala 212 which is only used when

00:26:28,800 --> 00:26:34,650
you build on 212 and source main Scala

00:26:31,740 --> 00:26:36,660
2:13 om for if you build on 213 or m4

00:26:34,650 --> 00:26:39,870
and you can already see the problem

00:26:36,660 --> 00:26:42,480
there SBT uses the binary version it's

00:26:39,870 --> 00:26:44,220
really the best thing it can do but of

00:26:42,480 --> 00:26:46,230
course that's not what we want because

00:26:44,220 --> 00:26:50,280
we care about source compatibility and

00:26:46,230 --> 00:26:52,740
not binary compatibility so once to 1300

00:26:50,280 --> 00:26:56,400
is out and you only want to cross build

00:26:52,740 --> 00:26:57,510
on 212 and 213 you can use that but

00:26:56,400 --> 00:27:01,170
otherwise you're better off

00:26:57,510 --> 00:27:05,760
defining your own like this so when you

00:27:01,170 --> 00:27:08,190
build on 213 or higher we add a scholar

00:27:05,760 --> 00:27:10,559
to 13 plus source directory and

00:27:08,190 --> 00:27:14,940
otherwise is Scala - 12 - source

00:27:10,559 --> 00:27:16,410
directory so this is the source

00:27:14,940 --> 00:27:22,470
compatible approach rather than the

00:27:16,410 --> 00:27:24,450
default binary compatible one and there

00:27:22,470 --> 00:27:27,300
are a few other incompatibilities and

00:27:24,450 --> 00:27:29,580
the new collections we haven't published

00:27:27,300 --> 00:27:32,460
the proper documentation on the Scala

00:27:29,580 --> 00:27:34,260
website yet but there is an FAQ on the

00:27:32,460 --> 00:27:36,929
old collection strawman incubator

00:27:34,260 --> 00:27:39,120
project and it's quite comprehensive

00:27:36,929 --> 00:27:43,559
especially when it comes to the changes

00:27:39,120 --> 00:27:47,640
in the new library so I'll add this back

00:27:43,559 --> 00:27:51,350
to jamia for automated migration thanks

00:27:47,640 --> 00:27:55,170
so in this FAQ you will see a list of

00:27:51,350 --> 00:28:00,140
incompatibilities and so Stefan

00:27:55,170 --> 00:28:03,050
presented those who require like

00:28:00,140 --> 00:28:06,330
decision on a case-by-case basis but

00:28:03,050 --> 00:28:09,059
most of them are just methods that have

00:28:06,330 --> 00:28:11,880
been renamed and or duplicated and I

00:28:09,059 --> 00:28:14,910
asked to something else and in those

00:28:11,880 --> 00:28:17,929
cases the the migration is quite

00:28:14,910 --> 00:28:22,470
mechanical and can be automated and

00:28:17,929 --> 00:28:26,220
that's why we are developing a tool to

00:28:22,470 --> 00:28:30,660
automate the migration the idea is that

00:28:26,220 --> 00:28:33,990
an application that works on 212 if you

00:28:30,660 --> 00:28:36,390
apply the migration tool on it it

00:28:33,990 --> 00:28:40,230
produces an application that works on

00:28:36,390 --> 00:28:42,720
that compiles on 213 currently the

00:28:40,230 --> 00:28:46,889
the migration tool is implemented in the

00:28:42,720 --> 00:28:48,299
form of scatter fix rewrite rule so in

00:28:46,889 --> 00:28:50,909
case you don't know scatter fix is a

00:28:48,299 --> 00:28:56,419
scalar code manipulation tool developed

00:28:50,909 --> 00:29:01,169
at the sky Center mainly and well so

00:28:56,419 --> 00:29:05,519
hopefully you will get an application

00:29:01,169 --> 00:29:07,710
that compiles with 213 but maybe some

00:29:05,519 --> 00:29:13,049
case is not handled by the migration

00:29:07,710 --> 00:29:16,130
tool will have to be under manual in

00:29:13,049 --> 00:29:21,299
practice this is how it works you first

00:29:16,130 --> 00:29:24,539
add the SBT plugin for scaler fix to

00:29:21,299 --> 00:29:27,539
your project then you you run SBT you

00:29:24,539 --> 00:29:30,240
enable scaler fix and then you run the

00:29:27,539 --> 00:29:33,240
migration rule which is named new

00:29:30,240 --> 00:29:35,490
Corrections which transforms an

00:29:33,240 --> 00:29:38,450
application that works on 212 into an

00:29:35,490 --> 00:29:46,799
application that compiles on 213 without

00:29:38,450 --> 00:29:49,350
deprecation warnings and it does that in

00:29:46,799 --> 00:29:51,539
place so it modifies the the project in

00:29:49,350 --> 00:29:56,159
place it doesn't copy it doesn't produce

00:29:51,539 --> 00:29:58,049
the sauce on a different path and then

00:29:56,159 --> 00:29:59,850
you can change the scalar version in

00:29:58,049 --> 00:30:06,630
your project and read out the project

00:29:59,850 --> 00:30:11,429
and try to see if it compiled I had a

00:30:06,630 --> 00:30:11,970
nice admission so what kind of rules do

00:30:11,429 --> 00:30:15,870
we have

00:30:11,970 --> 00:30:18,840
like I've said renaming like types and

00:30:15,870 --> 00:30:21,450
operation have been renamed so for

00:30:18,840 --> 00:30:26,190
instance stream has been replaced with

00:30:21,450 --> 00:30:29,159
lazy list and the operation happened has

00:30:26,190 --> 00:30:33,899
been renamed to lazy appended all that's

00:30:29,159 --> 00:30:36,080
the new name in the case of the

00:30:33,899 --> 00:30:39,179
migration from stream too lazy list I

00:30:36,080 --> 00:30:42,260
want to draw attention to the fact that

00:30:39,179 --> 00:30:42,260
lazy list is not

00:30:42,739 --> 00:30:49,769
totally cement a semantically identical

00:30:45,629 --> 00:30:51,360
to stream in a sense that it is lazy in

00:30:49,769 --> 00:30:53,820
its head also

00:30:51,360 --> 00:30:54,570
so stream is only lazy on the tail not

00:30:53,820 --> 00:30:59,100
on the head

00:30:54,570 --> 00:31:02,989
so that could be a semantic change that

00:30:59,100 --> 00:31:07,350
breaks something in your application and

00:31:02,989 --> 00:31:10,649
apart from Rene means we also we are so

00:31:07,350 --> 00:31:12,960
able to just transform any expressions

00:31:10,649 --> 00:31:15,149
like for instance copy to buffer has

00:31:12,960 --> 00:31:17,549
been deprecated and the recommended way

00:31:15,149 --> 00:31:20,749
to do the same thing is just to take the

00:31:17,549 --> 00:31:23,580
buffer and to call plus plus equal on it

00:31:20,749 --> 00:31:27,749
so we have a rewrite rule that does that

00:31:23,580 --> 00:31:31,649
and then obviously we can we we could

00:31:27,749 --> 00:31:33,119
implement more complex rules but the

00:31:31,649 --> 00:31:35,129
more complex the expression to

00:31:33,119 --> 00:31:39,840
manipulate the harder to implement the

00:31:35,129 --> 00:31:42,080
rewrite order now what is not in the

00:31:39,840 --> 00:31:44,840
scope of the migration tool

00:31:42,080 --> 00:31:48,989
implementation of custom Corrections

00:31:44,840 --> 00:31:56,340
because the api's are quite different

00:31:48,989 --> 00:32:00,809
and yeah and it's it's super complex to

00:31:56,340 --> 00:32:04,529
to write such migration route also some

00:32:00,809 --> 00:32:07,039
advanced usage of can build from might

00:32:04,529 --> 00:32:11,220
be a bit too complex to to support

00:32:07,039 --> 00:32:13,799
because usually they require the rewrite

00:32:11,220 --> 00:32:16,080
of complete method definition and

00:32:13,799 --> 00:32:21,090
implementation so this is something hard

00:32:16,080 --> 00:32:24,809
to do also scattered seek usage I think

00:32:21,090 --> 00:32:29,700
we cannot provide an automatic rewrite

00:32:24,809 --> 00:32:32,399
for that because as Stefan mentioned you

00:32:29,700 --> 00:32:34,799
want to decide on a case-by-case basis

00:32:32,399 --> 00:32:37,519
how to migrate to the news current not

00:32:34,799 --> 00:32:37,519
secure usage

00:32:39,130 --> 00:32:44,559
so far I've given you an example of how

00:32:42,160 --> 00:32:46,690
to migrate an application but for

00:32:44,559 --> 00:32:50,650
libraries the story is a little bit

00:32:46,690 --> 00:32:53,080
different because usually an application

00:32:50,650 --> 00:32:55,809
works only for the current scalar

00:32:53,080 --> 00:32:57,190
version or at least just for one scalar

00:32:55,809 --> 00:33:01,380
version and a library usually

00:32:57,190 --> 00:33:03,640
cross-compile for several scalar version

00:33:01,380 --> 00:33:07,240
so let's say you have a library that

00:33:03,640 --> 00:33:11,169
works with 211 and 212 but you want to

00:33:07,240 --> 00:33:14,409
use the migration system the migration

00:33:11,169 --> 00:33:18,820
tool to produce a library that compiles

00:33:14,409 --> 00:33:21,850
with 211 212 and 213 so we we didn't

00:33:18,820 --> 00:33:25,710
implement this migration rule yet but we

00:33:21,850 --> 00:33:29,380
plan to do that and it will be able to

00:33:25,710 --> 00:33:32,409
to produce code that cross-compiled with

00:33:29,380 --> 00:33:37,090
211 212 and 213 by using the

00:33:32,409 --> 00:33:39,100
compatibility library did I miss

00:33:37,090 --> 00:33:42,130
something I don't think so maybe you

00:33:39,100 --> 00:33:46,120
will have will have to also do some

00:33:42,130 --> 00:33:51,309
finishing manually and I think this is

00:33:46,120 --> 00:33:55,150
it so in case you have questions you can

00:33:51,309 --> 00:33:57,850
have a look at these links for more

00:33:55,150 --> 00:34:01,929
detailed information or examples of

00:33:57,850 --> 00:34:05,260
projects and we are happy to take

00:34:01,929 --> 00:34:12,919
questions thanks for your attention

00:34:05,260 --> 00:34:12,919
[Applause]

00:34:14,009 --> 00:34:23,730
yes the question is what is the future

00:34:21,339 --> 00:34:25,990
of para aggression you want to answer

00:34:23,730 --> 00:34:28,779
well there they're not going anywhere

00:34:25,990 --> 00:34:31,059
there is separate module so eventually

00:34:28,779 --> 00:34:33,909
we're hoping to find somebody else to

00:34:31,059 --> 00:34:36,129
maintain them but for now we will

00:34:33,909 --> 00:34:38,919
publish a version once it's been adapted

00:34:36,129 --> 00:34:42,220
to the new design we have a library for

00:34:38,919 --> 00:34:44,589
meit's on three out and we're working on

00:34:42,220 --> 00:34:46,450
the one for milestone for we're not

00:34:44,589 --> 00:34:48,249
completely sure how far we're going to

00:34:46,450 --> 00:34:50,609
integrate it with the new collections

00:34:48,249 --> 00:34:53,919
design or whether it's going to stay

00:34:50,609 --> 00:34:57,309
mostly in the old design but they it's

00:34:53,919 --> 00:34:58,839
quite separate now so the integration is

00:34:57,309 --> 00:35:01,450
not as tight as it used to be they will

00:34:58,839 --> 00:35:03,099
intersect at iterable once and that's

00:35:01,450 --> 00:35:05,880
pretty much it and then you can convert

00:35:03,099 --> 00:35:05,880

YouTube URL: https://www.youtube.com/watch?v=8pl90az8eTY


