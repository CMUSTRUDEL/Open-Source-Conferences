Title: Literal types what they are good for by Tamer Abdulradi
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6907-literal-types%2C-what-they-are-good-for.html
Captions: 
	00:00:05,000 --> 00:00:12,180
so you can call me Tam for short I work

00:00:08,430 --> 00:00:14,100
at cake solutions so cake solutions used

00:00:12,180 --> 00:00:17,100
to be a consultancy but now it got

00:00:14,100 --> 00:00:19,980
acquired by BAM tech media that's why

00:00:17,100 --> 00:00:23,160
I'm wearing a different t-shirt so BAM

00:00:19,980 --> 00:00:26,070
tech media is a video streaming company

00:00:23,160 --> 00:00:31,199
that also got acquired recently by

00:00:26,070 --> 00:00:35,520
Disney so that's explain why we have

00:00:31,199 --> 00:00:38,130
Mickey Mouse on top of our booth right

00:00:35,520 --> 00:00:41,480
so today I'm gonna be talking about new

00:00:38,130 --> 00:00:43,110
features that landed in scarlet 2.13

00:00:41,480 --> 00:00:46,140
specifically I'm going to be talking

00:00:43,110 --> 00:00:49,260
about literal types so my agenda for

00:00:46,140 --> 00:00:51,930
today is first I'm gonna get everybody

00:00:49,260 --> 00:00:54,690
up to speed I'm gonna be accepting what

00:00:51,930 --> 00:00:57,750
singleton types was literal types and

00:00:54,690 --> 00:01:00,930
couple of highlights from the recent

00:00:57,750 --> 00:01:02,430
request then parts of the talk the

00:01:00,930 --> 00:01:04,320
interesting bit I'm gonna be talking

00:01:02,430 --> 00:01:08,009
about three use cases for literal types

00:01:04,320 --> 00:01:09,509
the first one is the practical one I'm

00:01:08,009 --> 00:01:11,729
going to be talking about a library

00:01:09,509 --> 00:01:14,460
called refined and how it can help you

00:01:11,729 --> 00:01:18,270
to write better programs the second two

00:01:14,460 --> 00:01:19,890
use cases those are search projects of

00:01:18,270 --> 00:01:20,689
mine so that's why they are not

00:01:19,890 --> 00:01:26,460
practical

00:01:20,689 --> 00:01:29,039
so the second one is about encoding SQL

00:01:26,460 --> 00:01:32,789
queries as literal pipes to make sure

00:01:29,039 --> 00:01:36,270
that you can prevent SQL injection

00:01:32,789 --> 00:01:38,340
happening last one is a bit more

00:01:36,270 --> 00:01:41,639
involved so it's using literal types as

00:01:38,340 --> 00:01:44,340
well as other type system features so

00:01:41,639 --> 00:01:46,439
that I can understand my SQL query at

00:01:44,340 --> 00:01:48,359
compile time and for example if I'm

00:01:46,439 --> 00:01:50,880
selecting a column that doesn't exist I

00:01:48,359 --> 00:01:52,709
can get compiler error message telling

00:01:50,880 --> 00:01:59,990
me all that this column it's not there

00:01:52,709 --> 00:02:02,929
all right so let's start all right so

00:01:59,990 --> 00:02:06,479
let's first talk about singleton types

00:02:02,929 --> 00:02:09,990
so they exist almost in any Scala code

00:02:06,479 --> 00:02:14,580
base for example consider this object

00:02:09,990 --> 00:02:17,380
definition what would be the type of

00:02:14,580 --> 00:02:19,810
this object like the type doesn't it

00:02:17,380 --> 00:02:22,810
then there's no extent syntax or

00:02:19,810 --> 00:02:27,340
anything here so you can say it's an

00:02:22,810 --> 00:02:31,480
instance of any or any ref but there is

00:02:27,340 --> 00:02:36,000
also one more hidden type that you can

00:02:31,480 --> 00:02:42,190
access via the syntax object or path dot

00:02:36,000 --> 00:02:47,050
type so this is basically a type that

00:02:42,190 --> 00:02:51,130
has one single instance in this case the

00:02:47,050 --> 00:02:54,010
object itself this is just one form of

00:02:51,130 --> 00:02:55,750
singleton type there is other forms of

00:02:54,010 --> 00:03:01,240
singleton types that the compiler is

00:02:55,750 --> 00:03:05,170
capable of representing for example the

00:03:01,240 --> 00:03:07,360
number 42 the type system is also

00:03:05,170 --> 00:03:09,370
capable of having a type present

00:03:07,360 --> 00:03:14,140
representation for this value

00:03:09,370 --> 00:03:16,900
even before 2.13 however before 2.13

00:03:14,140 --> 00:03:19,930
there is no syntax to use it so the

00:03:16,900 --> 00:03:21,790
feature was pretty much like beasts in a

00:03:19,930 --> 00:03:25,150
cage like you can't you can't interact

00:03:21,790 --> 00:03:28,270
with it unless you use something like

00:03:25,150 --> 00:03:31,810
shapeless which kinda invents syntax for

00:03:28,270 --> 00:03:35,020
you to use literal types so this line

00:03:31,810 --> 00:03:38,830
basically means we are having a function

00:03:35,020 --> 00:03:42,540
that can accept only 42 and if you pass

00:03:38,830 --> 00:03:47,770
anything else this is a compile error

00:03:42,540 --> 00:03:53,410
the news in 2.13 is now we have better

00:03:47,770 --> 00:03:57,040
syntax to achieve the theme the same

00:03:53,410 --> 00:04:00,610
without shapeless so you can write this

00:03:57,040 --> 00:04:06,070
now in 2.13 it will be exactly the same

00:04:00,610 --> 00:04:09,459
so 42 in the position of type here means

00:04:06,070 --> 00:04:13,120
the singleton type that has only one

00:04:09,459 --> 00:04:15,010
value 42 and of course if you pass

00:04:13,120 --> 00:04:17,350
something else this is not gonna compile

00:04:15,010 --> 00:04:22,570
if you want to try this out

00:04:17,350 --> 00:04:25,630
you can via SPT just jump to m3 version

00:04:22,570 --> 00:04:29,050
you will have access to this feature and

00:04:25,630 --> 00:04:30,590
also a couple of other features that I'm

00:04:29,050 --> 00:04:41,920
gonna highlight too

00:04:30,590 --> 00:04:46,400
more of them so what else we got in 2.13

00:04:41,920 --> 00:04:51,440
we got away to hack the way type

00:04:46,400 --> 00:04:55,100
inference works so by default if we

00:04:51,440 --> 00:05:00,260
passed here the value 42 the type

00:04:55,100 --> 00:05:03,410
inference will infer T as an int even

00:05:00,260 --> 00:05:05,360
though in 2.13 there is now the type 42

00:05:03,410 --> 00:05:07,130
it's more specific but the type

00:05:05,360 --> 00:05:11,540
inference doesn't like to interfere it

00:05:07,130 --> 00:05:14,510
this didn't change the way you can force

00:05:11,540 --> 00:05:18,170
the type inference to pick the Naaru one

00:05:14,510 --> 00:05:22,730
is by passing here upper bound of

00:05:18,170 --> 00:05:25,580
singleton so this means the value here

00:05:22,730 --> 00:05:29,380
has to be literal value and it will pick

00:05:25,580 --> 00:05:33,140
the most narrow type 42 okay

00:05:29,380 --> 00:05:35,780
one also other cool use case of this

00:05:33,140 --> 00:05:39,020
singleton is if you mix it with like

00:05:35,780 --> 00:05:40,600
string for example you will be able to

00:05:39,020 --> 00:05:44,600
write a function that accepts only

00:05:40,600 --> 00:05:47,870
hard-coded values but not runtime values

00:05:44,600 --> 00:05:55,270
and we will see this specific example in

00:05:47,870 --> 00:05:55,270
one of the use cases the last highlight

00:05:56,650 --> 00:06:03,650
is the ability of jumping from the type

00:06:00,800 --> 00:06:07,580
level to the value level so if you have

00:06:03,650 --> 00:06:11,960
42 here as a type so this value of is

00:06:07,580 --> 00:06:14,150
function that is part of scala now by

00:06:11,960 --> 00:06:15,920
calling it passing the type parameter it

00:06:14,150 --> 00:06:19,550
will give you back the value associated

00:06:15,920 --> 00:06:22,220
with it you can either call it directly

00:06:19,550 --> 00:06:24,080
if you know the type like that or if t

00:06:22,220 --> 00:06:26,180
if you have type T type parameter or

00:06:24,080 --> 00:06:28,880
something you can also call it but you

00:06:26,180 --> 00:06:31,550
have to propagate the evidence so the

00:06:28,880 --> 00:06:34,610
value of value of with a capital V is

00:06:31,550 --> 00:06:37,940
the type class the magic type class that

00:06:34,610 --> 00:06:41,840
the compiler creates the instances for

00:06:37,940 --> 00:06:43,550
you this value off doesn't only work

00:06:41,840 --> 00:06:44,310
with litter types but also work with

00:06:43,550 --> 00:06:46,920
other

00:06:44,310 --> 00:06:55,860
singleton types like objects and even

00:06:46,920 --> 00:07:01,820
unit as well okay this is the end of the

00:06:55,860 --> 00:07:05,580
part one now I'll be talking about the

00:07:01,820 --> 00:07:08,130
interesting part hopefully so first use

00:07:05,580 --> 00:07:10,980
case I'm gonna talk about refinement

00:07:08,130 --> 00:07:14,820
types the practical use case have as

00:07:10,980 --> 00:07:16,910
I've said so let's consider this use

00:07:14,820 --> 00:07:19,440
case we have an application our

00:07:16,910 --> 00:07:22,700
application connects to a database and

00:07:19,440 --> 00:07:26,460
we accept the database in point as

00:07:22,700 --> 00:07:28,770
environment variable we have this data

00:07:26,460 --> 00:07:35,360
structure to represent the hostname and

00:07:28,770 --> 00:07:37,650
port we have a method that looks like it

00:07:35,360 --> 00:07:40,170
it treats the configuration from the

00:07:37,650 --> 00:07:43,200
environment variable and returns an

00:07:40,170 --> 00:07:45,720
instance of endpoint also from the

00:07:43,200 --> 00:07:47,700
signature because it's an either so I

00:07:45,720 --> 00:07:50,640
can guess it does some sort of

00:07:47,700 --> 00:07:52,440
validation for me then the rest of my

00:07:50,640 --> 00:07:56,220
application I'm using an instance for

00:07:52,440 --> 00:08:00,420
importing to do things with it so far so

00:07:56,220 --> 00:08:04,080
good but the problem here is int is a

00:08:00,420 --> 00:08:06,030
very large has a very large a range

00:08:04,080 --> 00:08:08,310
could be negative numbers could be very

00:08:06,030 --> 00:08:13,260
big numbers numbers that are not valid

00:08:08,310 --> 00:08:15,120
ports so even though this function looks

00:08:13,260 --> 00:08:17,160
like it validates first thing I'm not

00:08:15,120 --> 00:08:20,190
sure if it validates correctly or not

00:08:17,160 --> 00:08:21,660
the type signature doesn't tell me if it

00:08:20,190 --> 00:08:25,680
checks for negative numbers or not maybe

00:08:21,660 --> 00:08:29,490
checks if that's a valid in torso so

00:08:25,680 --> 00:08:34,740
there is a solution for that a library

00:08:29,490 --> 00:08:36,960
called refined so by having some imports

00:08:34,740 --> 00:08:43,080
we'll be able to have a more specific

00:08:36,960 --> 00:08:46,560
type like for example we can encode sort

00:08:43,080 --> 00:08:50,880
of validation or restrictions as type

00:08:46,560 --> 00:08:53,730
information so literal types here used

00:08:50,880 --> 00:08:57,140
in a type position to write any regular

00:08:53,730 --> 00:08:57,140
expression you can think of

00:08:57,469 --> 00:09:08,179
port as well is represented as range of

00:09:01,169 --> 00:09:11,039
numbers if you have the information

00:09:08,179 --> 00:09:12,689
hard-coded in your code base there is

00:09:11,039 --> 00:09:16,229
some macros for you so you can write

00:09:12,689 --> 00:09:21,079
write it directly and get compile-time

00:09:16,229 --> 00:09:23,999
error message if you wrote a wrong value

00:09:21,079 --> 00:09:26,729
but if the value is runtime value which

00:09:23,999 --> 00:09:30,239
is in most of the cases you get for free

00:09:26,729 --> 00:09:33,569
and method that validates the input for

00:09:30,239 --> 00:09:37,279
you gives you either right with the

00:09:33,569 --> 00:09:44,519
value or the error message as a string

00:09:37,279 --> 00:09:47,309
so validation code for free basically so

00:09:44,519 --> 00:09:52,589
now by using this into our case classes

00:09:47,309 --> 00:09:55,199
we got three things at least three

00:09:52,589 --> 00:09:57,389
things so first we got more type safety

00:09:55,199 --> 00:09:59,369
we are now sure anywhere we use the

00:09:57,389 --> 00:10:03,059
instance of end point that it has a

00:09:59,369 --> 00:10:05,669
correct port we got validation code for

00:10:03,059 --> 00:10:08,489
free and one more thing I'm gonna show

00:10:05,669 --> 00:10:11,399
you can even get parsers for these types

00:10:08,489 --> 00:10:14,249
for free so I'm gonna talk about a

00:10:11,399 --> 00:10:19,379
parser library called a tow so this is

00:10:14,249 --> 00:10:21,449
how you normally write a parser so here

00:10:19,379 --> 00:10:23,699
we're like accepting like host name

00:10:21,449 --> 00:10:27,689
which is like letters or digits then

00:10:23,699 --> 00:10:29,849
colon separator then a number int so

00:10:27,689 --> 00:10:31,559
this code doesn't have the same

00:10:29,849 --> 00:10:33,959
validations we have wrote in our

00:10:31,559 --> 00:10:36,359
refinement types so instead of repeating

00:10:33,959 --> 00:10:40,949
things and also putting the validations

00:10:36,359 --> 00:10:44,039
here you can just use the same refined

00:10:40,949 --> 00:10:51,089
types so this is a recent integration oh

00:10:44,039 --> 00:10:53,459
I have problem anyway so this recent

00:10:51,089 --> 00:10:55,769
integration allow allow us to just put

00:10:53,459 --> 00:10:58,139
restrictions here as type parameters

00:10:55,769 --> 00:11:02,489
then you will get here your refinement

00:10:58,139 --> 00:11:07,529
types as output of the parser so passing

00:11:02,489 --> 00:11:09,749
correct port give us the instance of end

00:11:07,529 --> 00:11:11,170
point with the refinement types if you

00:11:09,749 --> 00:11:14,230
pass something

00:11:11,170 --> 00:11:17,260
you will get the same error message he

00:11:14,230 --> 00:11:29,550
got from Van V it's part of the big

00:11:17,260 --> 00:11:29,550
parser so this was the first use case

00:11:29,790 --> 00:11:36,730
now this the the next two use cases are

00:11:33,850 --> 00:11:40,060
the experimental or research projects

00:11:36,730 --> 00:11:45,780
that have been working on and the last

00:11:40,060 --> 00:11:48,330
one I'm gonna show a weird hack so

00:11:45,780 --> 00:11:52,240
preventing SQL injection at compile time

00:11:48,330 --> 00:11:54,580
I'm always a fan of encoding or writing

00:11:52,240 --> 00:11:57,580
my queries as raw strings like that so

00:11:54,580 --> 00:12:00,610
that I can copy it to the SQL console or

00:11:57,580 --> 00:12:03,610
whatever but the problem with this is

00:12:00,610 --> 00:12:06,490
that it's so easy for you to forget and

00:12:03,610 --> 00:12:10,500
start concatenating with input instead

00:12:06,490 --> 00:12:14,530
of delegating this to the database so

00:12:10,500 --> 00:12:18,280
very central project idea that I thought

00:12:14,530 --> 00:12:21,610
of so how about just using literal types

00:12:18,280 --> 00:12:25,000
to write something that wraps all my

00:12:21,610 --> 00:12:28,390
queries to make sure it always has to be

00:12:25,000 --> 00:12:32,170
hard-coded like you can't by mistake do

00:12:28,390 --> 00:12:37,030
it unless you have a compiler so this

00:12:32,170 --> 00:12:40,780
works as expected but the limitation we

00:12:37,030 --> 00:12:44,020
got here is we lost also the flexibility

00:12:40,780 --> 00:12:47,920
of concatenating with other literal

00:12:44,020 --> 00:12:50,080
strings so I can't now say Oh query two

00:12:47,920 --> 00:12:51,880
is the same as query one but with one

00:12:50,080 --> 00:12:57,370
more closer one more thing

00:12:51,880 --> 00:12:59,170
so I lost this however I found the

00:12:57,370 --> 00:13:01,390
library I didn't know about it like

00:12:59,170 --> 00:13:07,660
about few months ago I just learned

00:13:01,390 --> 00:13:10,900
about a library called singleton ops it

00:13:07,660 --> 00:13:14,290
should allow us to somehow magically

00:13:10,900 --> 00:13:16,530
concatenate pipes sorry I need more

00:13:14,290 --> 00:13:16,530
order

00:13:20,230 --> 00:13:25,460
so by importing this library we have

00:13:22,730 --> 00:13:28,280
access to a couple of utility type

00:13:25,460 --> 00:13:30,470
classes and utility type aliases the

00:13:28,280 --> 00:13:32,450
first utility I'm gonna use is just

00:13:30,470 --> 00:13:35,270
alias for a string with singleton to

00:13:32,450 --> 00:13:37,250
become a string just just this just type

00:13:35,270 --> 00:13:41,590
Elias to save space on the slides that's

00:13:37,250 --> 00:13:45,410
it so let's see how I'm gonna use

00:13:41,590 --> 00:13:50,390
singleton ops to concatenate literal

00:13:45,410 --> 00:13:58,610
types at compile time so let's define

00:13:50,390 --> 00:14:01,820
this column plus method so the method

00:13:58,610 --> 00:14:04,940
accepts another type parameter Q - that

00:14:01,820 --> 00:14:08,600
has to be as well literal string then

00:14:04,940 --> 00:14:11,870
the output somehow should be the

00:14:08,600 --> 00:14:16,000
concatenation of those two types so

00:14:11,870 --> 00:14:19,640
singleton also allows you to write this

00:14:16,000 --> 00:14:23,720
so while this looks like we are adding

00:14:19,640 --> 00:14:26,440
pipes or something it's not behind the

00:14:23,720 --> 00:14:32,060
scenes this is just the type alias

00:14:26,440 --> 00:14:35,390
called plus just to fake the the plus

00:14:32,060 --> 00:14:39,380
operator or whatever so in fact this is

00:14:35,390 --> 00:14:42,230
what you are creating here just type

00:14:39,380 --> 00:14:44,210
called op macro that just contains the

00:14:42,230 --> 00:14:45,740
fragments of the query and the operator

00:14:44,210 --> 00:14:47,770
of the plus operator you want to do with

00:14:45,740 --> 00:14:49,970
those fragments

00:14:47,770 --> 00:14:52,670
so now since we are accentuated

00:14:49,970 --> 00:14:55,340
something here or sorry the type here is

00:14:52,670 --> 00:14:57,470
not extinct so we'll have to remove the

00:14:55,340 --> 00:15:02,450
pipe bound as well so that the code will

00:14:57,470 --> 00:15:05,180
compile alright so this works so far I'm

00:15:02,450 --> 00:15:08,410
recording fragments of the query each

00:15:05,180 --> 00:15:12,830
part of the fragment is literal

00:15:08,410 --> 00:15:16,340
hard-coded string now at some point I'll

00:15:12,830 --> 00:15:18,710
need to extract the query as one piece

00:15:16,340 --> 00:15:21,820
in order to execute it or do something

00:15:18,710 --> 00:15:24,770
useful with it so we have in the library

00:15:21,820 --> 00:15:27,350
type class called safe string this

00:15:24,770 --> 00:15:29,290
allows us to also jump from the type

00:15:27,350 --> 00:15:32,590
level to the value level

00:15:29,290 --> 00:15:37,330
it supports literal strings or this of

00:15:32,590 --> 00:15:41,470
macro thing so by by calling good value

00:15:37,330 --> 00:15:43,840
here we're gonna be asking for an

00:15:41,470 --> 00:15:46,330
implicit instance of safe string of op

00:15:43,840 --> 00:15:49,390
macro of whatever this will kick in

00:15:46,330 --> 00:15:52,440
bunch of implicit derivations some of

00:15:49,390 --> 00:15:54,310
them are implementing using macros so

00:15:52,440 --> 00:15:55,360
concatenation is going to happen at

00:15:54,310 --> 00:15:58,750
compile time

00:15:55,360 --> 00:16:00,670
using macro so it's still safe we don't

00:15:58,750 --> 00:16:06,370
have problems are not concatenate

00:16:00,670 --> 00:16:15,510
concatenating in runtime and that's

00:16:06,370 --> 00:16:19,990
that's the use case the last use case

00:16:15,510 --> 00:16:23,290
this one is a bit more involved so I'm

00:16:19,990 --> 00:16:28,240
using here so the aim of this use case

00:16:23,290 --> 00:16:31,930
first I want to be able to write an SQL

00:16:28,240 --> 00:16:35,230
driver that understands a bit of my

00:16:31,930 --> 00:16:36,280
schema so if I select a column that

00:16:35,230 --> 00:16:38,380
doesn't exist

00:16:36,280 --> 00:16:41,530
I want to get like all these columns not

00:16:38,380 --> 00:16:47,740
there or the type doesn't match your

00:16:41,530 --> 00:16:52,270
case class so this is how I represent

00:16:47,740 --> 00:16:57,730
the schema so every column in my schema

00:16:52,270 --> 00:17:00,340
is an implicit instance column names

00:16:57,730 --> 00:17:05,140
here are represented as literal types

00:17:00,340 --> 00:17:07,810
and finally the column types themselves

00:17:05,140 --> 00:17:10,120
here are a bunch of sealed traits

00:17:07,810 --> 00:17:14,890
represented forever credit for every

00:17:10,120 --> 00:17:18,910
data type in my database on the other

00:17:14,890 --> 00:17:22,089
hand queries are represented as pipes so

00:17:18,910 --> 00:17:25,390
select here is a type like a trait with

00:17:22,089 --> 00:17:29,230
just type parameters no values the

00:17:25,390 --> 00:17:32,920
selection so here I'm selecting ID

00:17:29,230 --> 00:17:36,640
untitled this is a hitch list of literal

00:17:32,920 --> 00:17:38,650
types and the table name is literal

00:17:36,640 --> 00:17:42,560
string as well and this is how our

00:17:38,650 --> 00:17:46,820
present query the close

00:17:42,560 --> 00:17:49,900
so now I'll show you this working then I

00:17:46,820 --> 00:18:03,530
will go back to the slides and explain

00:17:49,900 --> 00:18:06,110
how this was implemented so I'm just on

00:18:03,530 --> 00:18:08,180
the code here the scheme has a bit more

00:18:06,110 --> 00:18:11,540
involved so the table names are there

00:18:08,180 --> 00:18:14,090
but ignore them it just the column names

00:18:11,540 --> 00:18:17,830
here post title and the types text and

00:18:14,090 --> 00:18:24,830
so on so here's our schema the implicit

00:18:17,830 --> 00:18:26,750
and here is my select statement H list

00:18:24,830 --> 00:18:27,980
of columns and the table name and the

00:18:26,750 --> 00:18:31,390
relation is a bit different from the

00:18:27,980 --> 00:18:34,550
slides but you get the idea so let's

00:18:31,390 --> 00:18:37,240
let's do something here so reviewer name

00:18:34,550 --> 00:18:46,640
is a camel case I want to fix it to be

00:18:37,240 --> 00:18:48,920
lower lower case so now I get from the

00:18:46,640 --> 00:18:51,050
compiler error message that says column

00:18:48,920 --> 00:18:57,980
reviewer name doesn't exist in table

00:18:51,050 --> 00:19:00,800
posts so I'll fix this now by changing

00:18:57,980 --> 00:19:08,870
the scheme as well and by saving the

00:19:00,800 --> 00:19:10,630
code compiles back again right back to

00:19:08,870 --> 00:19:13,930
our slides

00:19:10,630 --> 00:19:20,050
alright so now I'll be explaining just

00:19:13,930 --> 00:19:20,050
small snippets how this was implemented

00:19:21,160 --> 00:19:30,830
so as a first let's build something bit

00:19:24,740 --> 00:19:34,940
smaller I want to implement a sort of

00:19:30,830 --> 00:19:37,510
codec registry so I want my driver to

00:19:34,940 --> 00:19:40,910
know about the database types and

00:19:37,510 --> 00:19:43,940
associated scala types for them so for

00:19:40,910 --> 00:19:46,070
example something like integer the type

00:19:43,940 --> 00:19:48,200
system should be aware that all it has

00:19:46,070 --> 00:19:52,160
to be int without specifying this

00:19:48,200 --> 00:19:56,419
information manually so in order to

00:19:52,160 --> 00:19:59,299
achieve this we define type class we

00:19:56,419 --> 00:20:03,950
to type information the column type is

00:19:59,299 --> 00:20:05,600
represented as a type parameter and the

00:20:03,950 --> 00:20:08,389
Scala type is represented as a type

00:20:05,600 --> 00:20:11,559
Pender and the reason that one of them

00:20:08,389 --> 00:20:14,989
is a member one of them is a parameter

00:20:11,559 --> 00:20:17,419
so this is because of the the way I want

00:20:14,989 --> 00:20:19,809
to use the type class so for example

00:20:17,419 --> 00:20:22,220
here I'm specifying to the type system

00:20:19,809 --> 00:20:25,070
I'm saying to develop type system an

00:20:22,220 --> 00:20:28,330
integer I'm giving it the column type so

00:20:25,070 --> 00:20:32,059
what I give to the type system goes as

00:20:28,330 --> 00:20:34,429
in the parameter list what the type

00:20:32,059 --> 00:20:37,129
system tells me here so type system

00:20:34,429 --> 00:20:41,269
tells me int so this goes to the body of

00:20:37,129 --> 00:20:44,470
the type class and also the logic of the

00:20:41,269 --> 00:20:47,799
code goes to the body of the type class

00:20:44,470 --> 00:20:51,980
then we define instances for this

00:20:47,799 --> 00:20:55,190
decoder so here saying that integer is

00:20:51,980 --> 00:20:59,419
goes to int and every combination I

00:20:55,190 --> 00:21:04,249
should create an instance as well now by

00:20:59,419 --> 00:21:06,230
using this type class so we just define

00:21:04,249 --> 00:21:09,259
a method that accepts an implicit

00:21:06,230 --> 00:21:12,980
instance of this type class then here by

00:21:09,259 --> 00:21:16,159
passing integer I get 42 and passing

00:21:12,980 --> 00:21:19,279
text I got string fubar so I can claim

00:21:16,159 --> 00:21:22,190
here that the type system understands

00:21:19,279 --> 00:21:26,859
the relation between databases database

00:21:22,190 --> 00:21:33,470
types and Scala types all right so let's

00:21:26,859 --> 00:21:36,950
level up let's do the same example but

00:21:33,470 --> 00:21:41,330
instead of specifying the database types

00:21:36,950 --> 00:21:43,039
I want to specify column names so in

00:21:41,330 --> 00:21:46,129
order to do that first I want the type

00:21:43,039 --> 00:21:47,749
system to be able to know the relation

00:21:46,129 --> 00:21:51,559
between column names and the database

00:21:47,749 --> 00:21:54,980
types so for this also the same trick I

00:21:51,559 --> 00:21:56,809
define a type class with type member the

00:21:54,980 --> 00:22:00,440
input here is the column name and the

00:21:56,809 --> 00:22:02,720
output is the column type and this is

00:22:00,440 --> 00:22:05,359
how I define the schema just implicit

00:22:02,720 --> 00:22:07,480
instances for every column I have in the

00:22:05,359 --> 00:22:07,480
database

00:22:08,470 --> 00:22:17,299
now we got to type glasses think of them

00:22:13,730 --> 00:22:20,030
as type level functions so colon has

00:22:17,299 --> 00:22:22,309
type is something that goes from columns

00:22:20,030 --> 00:22:25,730
to column types and the decoder goes

00:22:22,309 --> 00:22:28,970
from column types to Scala type we can

00:22:25,730 --> 00:22:31,370
just compose them together and create

00:22:28,970 --> 00:22:34,340
one bigger type class that goes from

00:22:31,370 --> 00:22:40,370
column names to the Scala types on one

00:22:34,340 --> 00:22:42,280
go and to define how this derivation of

00:22:40,370 --> 00:22:46,100
column decoder works

00:22:42,280 --> 00:22:48,679
so we basically asks the type system for

00:22:46,100 --> 00:22:50,030
two implicit instances one for the

00:22:48,679 --> 00:22:53,540
column type and the other for the

00:22:50,030 --> 00:22:56,510
decoder and whatever Scala type we found

00:22:53,540 --> 00:22:58,790
inside sorry whatever database type we

00:22:56,510 --> 00:23:01,130
found in the column we pass it here to

00:22:58,790 --> 00:23:05,929
the decoder as input then we get back

00:23:01,130 --> 00:23:08,059
the decoder instance just one small fix

00:23:05,929 --> 00:23:12,860
I have to go and to do in this slide

00:23:08,059 --> 00:23:15,620
before I move on it's not correct Scala

00:23:12,860 --> 00:23:19,160
syntax to refer to column type here in

00:23:15,620 --> 00:23:21,020
the same parameter list this should be

00:23:19,160 --> 00:23:26,210
fixed it and dotty because we can have

00:23:21,020 --> 00:23:28,730
multiple implicit parameters but for now

00:23:26,210 --> 00:23:31,640
the workaround is to define another type

00:23:28,730 --> 00:23:34,490
parameter C then here instead of asking

00:23:31,640 --> 00:23:36,080
an instance of just n we also specify

00:23:34,490 --> 00:23:38,900
that the type member should be the same

00:23:36,080 --> 00:23:42,440
as C then here we can refer to their

00:23:38,900 --> 00:23:46,570
type as C just weird hack but hopefully

00:23:42,440 --> 00:23:46,570
you'll not need to do it in Scala 3

00:23:46,750 --> 00:23:55,190
finally we can write our decode function

00:23:49,970 --> 00:23:57,559
to accept X string then give us directly

00:23:55,190 --> 00:24:01,130
the Scala type and it works as expected

00:23:57,559 --> 00:24:04,390
so now the compiler knows about ID

00:24:01,130 --> 00:24:07,390
that's 42 and column title that is

00:24:04,390 --> 00:24:07,390
extinct

00:24:14,160 --> 00:24:22,570
all right so far so good

00:24:17,790 --> 00:24:25,090
one more improvement to this so I want

00:24:22,570 --> 00:24:27,040
instead of decoding or selecting one

00:24:25,090 --> 00:24:30,100
column I want to be able to select

00:24:27,040 --> 00:24:33,790
multiple columns because this is

00:24:30,100 --> 00:24:36,340
normally how we do select statements so

00:24:33,790 --> 00:24:39,400
in order to do this I use H List to

00:24:36,340 --> 00:24:43,660
represent a list of column names on the

00:24:39,400 --> 00:24:46,210
type level and we have a type decoder

00:24:43,660 --> 00:24:49,470
very similar to the ones we have written

00:24:46,210 --> 00:24:53,320
before but the input is now H list of

00:24:49,470 --> 00:24:55,000
column names and the output is H list of

00:24:53,320 --> 00:25:01,360
Scala types and the decode function

00:24:55,000 --> 00:25:03,670
should return this out for you the

00:25:01,360 --> 00:25:06,280
instances for this type class is going

00:25:03,670 --> 00:25:09,370
to be very similar to how you do

00:25:06,280 --> 00:25:12,700
recursion so in recursion you normally

00:25:09,370 --> 00:25:15,130
think first of the base class the base

00:25:12,700 --> 00:25:19,420
class case here is what if the input is

00:25:15,130 --> 00:25:21,730
empty so if the H list is just empty you

00:25:19,420 --> 00:25:24,100
return an empty list and there's no

00:25:21,730 --> 00:25:31,990
decode logic to write just returned in

00:25:24,100 --> 00:25:33,340
th list but if it's not empty you do

00:25:31,990 --> 00:25:36,730
something on the head on something on

00:25:33,340 --> 00:25:39,100
the tail so we defined head to be any

00:25:36,730 --> 00:25:42,850
type and tail to be H list then we

00:25:39,100 --> 00:25:45,340
defined the decoder for head console ask

00:25:42,850 --> 00:25:47,679
the type system for the compiler for two

00:25:45,340 --> 00:25:49,600
implicit instances column decoder for

00:25:47,679 --> 00:25:52,059
the head and row decoder for tail so

00:25:49,600 --> 00:25:54,760
here's the recursive bit and the

00:25:52,059 --> 00:25:56,260
instance is defined as just you composed

00:25:54,760 --> 00:25:58,890
the types we got from the implicit

00:25:56,260 --> 00:25:58,890
instances

00:26:06,510 --> 00:26:16,570
right so I'm almost done

00:26:09,310 --> 00:26:19,150
I guess I'm ahead of time here one last

00:26:16,570 --> 00:26:22,900
thing I want to talk about is I showed

00:26:19,150 --> 00:26:25,240
you in the compiler in the inter demo

00:26:22,900 --> 00:26:28,960
when I selected when I wrote something

00:26:25,240 --> 00:26:30,940
wrong review name or whatever I got the

00:26:28,960 --> 00:26:35,920
error message to show exactly which

00:26:30,940 --> 00:26:39,150
column failed so this was not a very

00:26:35,920 --> 00:26:42,580
straightforward feature to implement and

00:26:39,150 --> 00:26:46,680
first before explaining how this works I

00:26:42,580 --> 00:26:50,860
I want to explain how normal implicit

00:26:46,680 --> 00:26:53,200
implicit errors works so if we ask it

00:26:50,860 --> 00:26:55,650
but compiler for implicit instances

00:26:53,200 --> 00:26:58,630
implicit instance of free decoder of

00:26:55,650 --> 00:27:01,570
something like this the derivation is

00:26:58,630 --> 00:27:03,700
written in like a pyramid shape so the

00:27:01,570 --> 00:27:05,740
we have to find first instance for

00:27:03,700 --> 00:27:08,100
column decoder the in column the color

00:27:05,740 --> 00:27:12,280
has to find an instance for : has type

00:27:08,100 --> 00:27:17,590
we know here that the problematic type

00:27:12,280 --> 00:27:19,750
is this one bla but the type system

00:27:17,590 --> 00:27:24,130
doesn't give you this information that

00:27:19,750 --> 00:27:27,280
easy so all all you get is just the

00:27:24,130 --> 00:27:31,540
whole big thing doesn't exist it you

00:27:27,280 --> 00:27:36,040
lose the context so in order to work

00:27:31,540 --> 00:27:43,450
around this I have made sort of trick

00:27:36,040 --> 00:27:46,600
you might like it or not so I change it

00:27:43,450 --> 00:27:50,830
calm has type instead of the output type

00:27:46,600 --> 00:27:56,160
being just the happy puff the column

00:27:50,830 --> 00:27:58,960
type it's now on either and the error is

00:27:56,160 --> 00:28:01,210
the left we will see now how we write

00:27:58,960 --> 00:28:05,590
earth and on the right the column type

00:28:01,210 --> 00:28:08,410
that you expect and the happy path this

00:28:05,590 --> 00:28:11,880
is how we define the instance so right

00:28:08,410 --> 00:28:15,210
and the integer here is inside the type

00:28:11,880 --> 00:28:15,210
information of right

00:28:15,450 --> 00:28:22,100
in case of failures so if that column

00:28:18,780 --> 00:28:26,370
doesn't exist we have a low-level

00:28:22,100 --> 00:28:31,020
instance defining the companion object

00:28:26,370 --> 00:28:35,460
of the type class that basically says oh

00:28:31,020 --> 00:28:36,630
this : C not found and this plus is a

00:28:35,460 --> 00:28:39,630
short before

00:28:36,630 --> 00:28:44,549
just the fake concatenation from refined

00:28:39,630 --> 00:28:49,950
ops so now this is the lower level of

00:28:44,549 --> 00:28:53,880
the of the type class the revision now

00:28:49,950 --> 00:28:58,230
we have instances for both cases going

00:28:53,880 --> 00:29:00,200
more up in the pyramid so we have to

00:28:58,230 --> 00:29:03,330
also now all the type classes that

00:29:00,200 --> 00:29:06,720
depends on the on that one has to also

00:29:03,330 --> 00:29:08,940
have the output as either and you have

00:29:06,720 --> 00:29:11,760
to define instances for the happy path

00:29:08,940 --> 00:29:16,530
and the unhappy path so for the happy

00:29:11,760 --> 00:29:20,460
path here if the if we found an instance

00:29:16,530 --> 00:29:26,480
that has type right then the output is

00:29:20,460 --> 00:29:29,370
also right if not if there is a failure

00:29:26,480 --> 00:29:30,090
then you have to also define an instance

00:29:29,370 --> 00:29:32,400
for it

00:29:30,090 --> 00:29:34,200
so if she left you just propagate the

00:29:32,400 --> 00:29:39,210
same error message or change it if you

00:29:34,200 --> 00:29:46,620
want or add to it finally towards the

00:29:39,210 --> 00:29:49,290
top of the pyramid we want to extract

00:29:46,620 --> 00:29:51,690
the happy path only we want to know that

00:29:49,290 --> 00:29:56,190
the right side of the either so we have

00:29:51,690 --> 00:30:00,650
this pet class get so if it was the

00:29:56,190 --> 00:30:03,990
right then you get type out as T if not

00:30:00,650 --> 00:30:07,169
then we have an another implicit that is

00:30:03,990 --> 00:30:08,640
backed by a macro that extracts the

00:30:07,169 --> 00:30:11,669
error message out of the type

00:30:08,640 --> 00:30:16,559
information then show it to you as we

00:30:11,669 --> 00:30:19,230
have seen in the demo right so that's

00:30:16,559 --> 00:30:26,419
the end of my slides I'm gonna just show

00:30:19,230 --> 00:30:30,000
you a couple of links so this dog has

00:30:26,419 --> 00:30:35,200
more in details

00:30:30,000 --> 00:30:37,179
explanation of the last use case there's

00:30:35,200 --> 00:30:39,340
also another version of the talk but

00:30:37,179 --> 00:30:43,269
it's more advanced even so more details

00:30:39,340 --> 00:30:46,600
but the video is not released yet hello

00:30:43,269 --> 00:30:49,000
John John I'm talking about you well the

00:30:46,600 --> 00:30:55,389
video is not released yet so ask us

00:30:49,000 --> 00:30:57,220
asking for the video thank you alright

00:30:55,389 --> 00:30:59,289
here's the code for the to use cases

00:30:57,220 --> 00:31:02,409
I've I've shown if you want to have a

00:30:59,289 --> 00:31:05,889
look on github and here's the libraries

00:31:02,409 --> 00:31:08,279
have used in the slides and now any

00:31:05,889 --> 00:31:08,279
questions

00:31:18,000 --> 00:31:23,800
hello how are you going to represent

00:31:21,250 --> 00:31:32,020
more complex SQL queries with such

00:31:23,800 --> 00:31:35,260
approach all right I have in the demo a

00:31:32,020 --> 00:31:38,670
bit more sophisticated representation

00:31:35,260 --> 00:31:42,660
for quays so I can represent also

00:31:38,670 --> 00:31:47,890
operators like for example when you say

00:31:42,660 --> 00:31:51,460
like title equal question mark so I can

00:31:47,890 --> 00:31:53,710
also understand what's the operators if

00:31:51,460 --> 00:31:56,590
that if the call for example was a list

00:31:53,710 --> 00:31:59,500
of integers for example I can know that

00:31:56,590 --> 00:32:01,210
if the operator is contains so I can

00:31:59,500 --> 00:32:03,100
tell you all the question mark type

00:32:01,210 --> 00:32:06,490
should be the type P inside the list

00:32:03,100 --> 00:32:08,590
it's all just writing more type level

00:32:06,490 --> 00:32:13,180
derivations it's it's a bit hairy to

00:32:08,590 --> 00:32:15,790
write yes but yes it's possible to do I

00:32:13,180 --> 00:32:17,530
just think if you represent whole school

00:32:15,790 --> 00:32:21,280
standard like this you'll be all covered

00:32:17,530 --> 00:32:24,370
with hair or something yes okay totally

00:32:21,280 --> 00:32:27,100
hairy so this was supposed to be

00:32:24,370 --> 00:32:29,200
internal the what I showed you in the

00:32:27,100 --> 00:32:33,550
slides supposed to be internal

00:32:29,200 --> 00:32:37,030
representation let me show you what

00:32:33,550 --> 00:32:38,710
actually are supposed to use so this was

00:32:37,030 --> 00:32:41,950
the original idea there is a macro here

00:32:38,710 --> 00:32:46,030
that parses the SQL for you and spits

00:32:41,950 --> 00:32:48,400
out those type ugly ugly syntax but I

00:32:46,030 --> 00:32:51,000
didn't just show it because it's not the

00:32:48,400 --> 00:32:51,000
theme of the talk

00:33:00,260 --> 00:33:07,700
sorry oh thank you oh and the video is

00:33:04,790 --> 00:33:16,070
life now this that's this one that was

00:33:07,700 --> 00:33:17,270
very quick hello and thank you I'm I'm

00:33:16,070 --> 00:33:20,420
here to the left

00:33:17,270 --> 00:33:23,210
oh hi thank you very much for the talk

00:33:20,420 --> 00:33:24,620
and I have a small question can you

00:33:23,210 --> 00:33:27,980
please go to the slide when you actually

00:33:24,620 --> 00:33:30,110
defined your query with the type before

00:33:27,980 --> 00:33:34,640
you explain how it is implemented

00:33:30,110 --> 00:33:39,290
I think it was an in text editor how you

00:33:34,640 --> 00:33:43,100
actually wrote that query I got in an

00:33:39,290 --> 00:33:46,760
example but like the third tab I think

00:33:43,100 --> 00:33:49,310
yes this one and scroll a bit down yeah

00:33:46,760 --> 00:33:51,580
yeah yeah so basically you need to

00:33:49,310 --> 00:33:56,300
duplicate the whole query in the type

00:33:51,580 --> 00:33:59,690
definition and in the actual query which

00:33:56,300 --> 00:34:05,750
is written in the string yeah so there

00:33:59,690 --> 00:34:09,169
is no any way to avoid this I can so

00:34:05,750 --> 00:34:11,720
it's it's fairly simple to also write

00:34:09,169 --> 00:34:15,800
type class derivation that generates

00:34:11,720 --> 00:34:17,149
string representation from the type it's

00:34:15,800 --> 00:34:19,220
it's possible to have all the

00:34:17,149 --> 00:34:20,990
information here but what I'm showing

00:34:19,220 --> 00:34:24,080
you here is supposed to be the output of

00:34:20,990 --> 00:34:27,800
a macro so you are supposed to write

00:34:24,080 --> 00:34:29,960
this there so there is no point of me

00:34:27,800 --> 00:34:32,060
just doing the derivation well I already

00:34:29,960 --> 00:34:34,909
have the string anyway just put it and

00:34:32,060 --> 00:34:38,649
duplicate the information that's that's

00:34:34,909 --> 00:34:38,649

YouTube URL: https://www.youtube.com/watch?v=OedtxbyexaY


