Title: What can Lagom do for you? by Renato Cavalcanti
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6950-what-can-lagom-do-for-you.html
Captions: 
	00:00:04,570 --> 00:00:08,740
so the talk today I will talk about what

00:00:07,479 --> 00:00:11,520
can I gonna do for you

00:00:08,740 --> 00:00:14,950
and I had the idea of giving that talk

00:00:11,520 --> 00:00:17,050
when I was at Scot exchange last year

00:00:14,950 --> 00:00:20,349
and I was talked with many people

00:00:17,050 --> 00:00:23,290
building Microsoft's using arca archa

00:00:20,349 --> 00:00:24,790
persistence and Scala and so on and I

00:00:23,290 --> 00:00:26,829
realized that there are a lot of people

00:00:24,790 --> 00:00:29,529
building my cursors and they don't know

00:00:26,829 --> 00:00:31,360
what logon offered to them so I said

00:00:29,529 --> 00:00:33,790
okay maybe there are some some

00:00:31,360 --> 00:00:38,590
opportunity here to build a talk on that

00:00:33,790 --> 00:00:41,110
and so the agenda will be I will give a

00:00:38,590 --> 00:00:43,150
brief introduction of lagoon and how our

00:00:41,110 --> 00:00:45,430
vision how you go from mono leaf

00:00:43,150 --> 00:00:49,720
applications to a reactive micro service

00:00:45,430 --> 00:00:51,970
I will the the the core of the talk will

00:00:49,720 --> 00:00:54,280
be actually about the lagoon persistence

00:00:51,970 --> 00:00:56,739
API that is built on top of ARCA

00:00:54,280 --> 00:00:59,590
persistence and aqua clustering okay and

00:00:56,739 --> 00:01:02,410
then I also talked about the I will show

00:00:59,590 --> 00:01:05,560
the lagoon search descriptor during the

00:01:02,410 --> 00:01:07,750
demo but I will not concentrate much on

00:01:05,560 --> 00:01:12,190
that that will be probably the topic for

00:01:07,750 --> 00:01:15,550
another top another call so just a small

00:01:12,190 --> 00:01:19,000
question just to have an idea who who is

00:01:15,550 --> 00:01:22,450
familiar with lagoon okay as some people

00:01:19,000 --> 00:01:28,350
yeah and who are familiar here with aqua

00:01:22,450 --> 00:01:31,270
persistence and clustering okay so

00:01:28,350 --> 00:01:33,520
that's good because well most of people

00:01:31,270 --> 00:01:35,170
know how is our persistence I will not

00:01:33,520 --> 00:01:37,960
give an introduction to our persistence

00:01:35,170 --> 00:01:42,360
so I I assume that you guys understand

00:01:37,960 --> 00:01:45,850
that know how it works so I the thing is

00:01:42,360 --> 00:01:47,619
that Lagoon built on top of two main

00:01:45,850 --> 00:01:49,540
technologies that we have a light band

00:01:47,619 --> 00:01:53,740
the first one is the Play Framework and

00:01:49,540 --> 00:01:55,240
second one is NOC persistence so it's a

00:01:53,740 --> 00:01:59,010
framework built on top of an another

00:01:55,240 --> 00:02:03,580
framework and it's I would say

00:01:59,010 --> 00:02:07,390
prescriptive in to some specific things

00:02:03,580 --> 00:02:09,159
it's built for for building is conceived

00:02:07,390 --> 00:02:13,329
to build to be used for building

00:02:09,159 --> 00:02:15,129
microservice and as you see it's built

00:02:13,329 --> 00:02:17,200
on top of Play Framework but you not see

00:02:15,129 --> 00:02:17,750
actions or essential actions like they

00:02:17,200 --> 00:02:19,940
have in

00:02:17,750 --> 00:02:22,460
we have another lay on top of that which

00:02:19,940 --> 00:02:25,820
is the surface descriptor and you

00:02:22,460 --> 00:02:28,250
understand why we have that later on the

00:02:25,820 --> 00:02:30,920
most important thing for me I believe in

00:02:28,250 --> 00:02:33,610
lagoon is the persistence layer because

00:02:30,920 --> 00:02:37,640
there we leverage our persistence and

00:02:33,610 --> 00:02:40,490
closer sharding and I hope you guys we

00:02:37,640 --> 00:02:43,250
got good understand why that's that's

00:02:40,490 --> 00:02:45,920
important and why we're doing that we

00:02:43,250 --> 00:02:47,180
also have some dev tools on development

00:02:45,920 --> 00:02:49,910
environment to help you do in

00:02:47,180 --> 00:02:52,430
development and it's much much like play

00:02:49,910 --> 00:02:54,080
that we start to do a run and it start

00:02:52,430 --> 00:02:56,510
the application it keeps running you

00:02:54,080 --> 00:02:58,220
change your code is recompile and reload

00:02:56,510 --> 00:02:59,570
the application but the lagoon is a

00:02:58,220 --> 00:03:02,740
little bit more than that because

00:02:59,570 --> 00:03:07,490
usually in lagoon you have one to three

00:03:02,740 --> 00:03:10,520
models and they you also have like Kafka

00:03:07,490 --> 00:03:12,380
that will start Kafka server that

00:03:10,520 --> 00:03:14,360
started for you if you're using

00:03:12,380 --> 00:03:16,340
Cassandra you have a Cassandra embedded

00:03:14,360 --> 00:03:21,470
and embedded custom that started for you

00:03:16,340 --> 00:03:25,670
in my demo today I use a JDBC a version

00:03:21,470 --> 00:03:28,550
of the GC version of Lagoon

00:03:25,670 --> 00:03:31,220
I mean the the persistence API for JDBC

00:03:28,550 --> 00:03:33,080
not for Cassandra just because I like it

00:03:31,220 --> 00:03:35,959
very much I like sleek and it's use

00:03:33,080 --> 00:03:42,110
based on the snake as well and I think

00:03:35,959 --> 00:03:47,090
it's easier for demo so who knows what

00:03:42,110 --> 00:03:49,610
is that so obviously that's Simona leaf

00:03:47,090 --> 00:03:52,850
so you see it's a big application taking

00:03:49,610 --> 00:03:56,690
all my slide here and those forms here

00:03:52,850 --> 00:03:58,610
behind asides they represent parts of

00:03:56,690 --> 00:04:02,090
your different domains that you have put

00:03:58,610 --> 00:04:04,820
inside your application and that's how

00:04:02,090 --> 00:04:07,580
people we have built application for

00:04:04,820 --> 00:04:09,320
years now and what they do is that those

00:04:07,580 --> 00:04:11,060
many different parts of applications

00:04:09,320 --> 00:04:15,440
they communicate with each other they

00:04:11,060 --> 00:04:18,410
are tangled and they those calls that we

00:04:15,440 --> 00:04:20,540
see here so the triangle call the it was

00:04:18,410 --> 00:04:24,110
supposed to be a circle but it's now egg

00:04:20,540 --> 00:04:26,210
kind of feigning egg anyway so the trail

00:04:24,110 --> 00:04:28,039
calls the egg and it's all in process

00:04:26,210 --> 00:04:30,710
calls and also just an interface that

00:04:28,039 --> 00:04:31,460
you call it and so on the problem with

00:04:30,710 --> 00:04:34,190
this kind of

00:04:31,460 --> 00:04:37,030
approach is that that those applications

00:04:34,190 --> 00:04:40,639
become too big and hard to manage and

00:04:37,030 --> 00:04:42,919
and on top of that all they all rights

00:04:40,639 --> 00:04:47,240
to one single database so it's very hard

00:04:42,919 --> 00:04:49,099
to scale that out I was working from

00:04:47,240 --> 00:04:51,949
some time ago for the Flemish government

00:04:49,099 --> 00:04:54,919
and we had like a huge application then

00:04:51,949 --> 00:04:56,509
part of that application was they was

00:04:54,919 --> 00:04:58,759
doing many other things but one thing

00:04:56,509 --> 00:05:01,400
that they were doing they had some parts

00:04:58,759 --> 00:05:04,039
that was used to do some calculations

00:05:01,400 --> 00:05:07,009
over the roads in in Belgium in Flanders

00:05:04,039 --> 00:05:09,380
and lots of other applications were

00:05:07,009 --> 00:05:10,940
calling that application just to be able

00:05:09,380 --> 00:05:14,979
to do those calculations so whenever

00:05:10,940 --> 00:05:17,660
need to do a calculation of geographical

00:05:14,979 --> 00:05:18,830
some geographical calculation I had to

00:05:17,660 --> 00:05:21,320
call that application and that

00:05:18,830 --> 00:05:23,060
application was failing because of that

00:05:21,320 --> 00:05:24,979
everybody was just every other

00:05:23,060 --> 00:05:26,539
application was calling that application

00:05:24,979 --> 00:05:27,889
just because of that calculation

00:05:26,539 --> 00:05:29,300
while that application was also

00:05:27,889 --> 00:05:32,180
responsible for doing some other stuff

00:05:29,300 --> 00:05:33,610
so what we did there is taking that part

00:05:32,180 --> 00:05:37,729
of the application make it an apart

00:05:33,610 --> 00:05:39,409
service you know so that's the the idea

00:05:37,729 --> 00:05:41,570
when you have this model if at some

00:05:39,409 --> 00:05:43,490
point you have to spray them but what

00:05:41,570 --> 00:05:45,770
people will do very often when they

00:05:43,490 --> 00:05:49,580
split their monolith is that they create

00:05:45,770 --> 00:05:53,090
small applications that now communicate

00:05:49,580 --> 00:05:57,320
between each other via rest call or RPC

00:05:53,090 --> 00:05:59,240
calls there one there are actually two

00:05:57,320 --> 00:06:02,840
problems here the first one it's

00:05:59,240 --> 00:06:05,180
actually quite kind of obvious I think

00:06:02,840 --> 00:06:06,740
is that when you create those different

00:06:05,180 --> 00:06:10,039
applications they are running different

00:06:06,740 --> 00:06:12,590
process now i have i'm calling over the

00:06:10,039 --> 00:06:14,900
wire one application from one to the

00:06:12,590 --> 00:06:19,130
other and by doing that I'm adding

00:06:14,900 --> 00:06:22,280
latency but that's expected no what is

00:06:19,130 --> 00:06:24,380
less obvious obvious from from this is

00:06:22,280 --> 00:06:27,289
that you you are creating here a

00:06:24,380 --> 00:06:29,960
temporal dependency by temporal depends

00:06:27,289 --> 00:06:33,800
I mean when the triangle application

00:06:29,960 --> 00:06:35,150
needs to call the egg application well

00:06:33,800 --> 00:06:38,570
if the egg application is not running

00:06:35,150 --> 00:06:39,469
the triangle plication is broken so it

00:06:38,570 --> 00:06:41,449
depends

00:06:39,469 --> 00:06:43,610
it not only depends on the on the

00:06:41,449 --> 00:06:44,960
service or the other one is provided but

00:06:43,610 --> 00:06:48,470
it also depends the fact that

00:06:44,960 --> 00:06:51,590
the other one must be Ronnie no and and

00:06:48,470 --> 00:06:57,620
in that case here if the circle or egg

00:06:51,590 --> 00:06:59,570
one gets crashes actually the whole your

00:06:57,620 --> 00:07:01,490
system will be impacted either they will

00:06:59,570 --> 00:07:04,610
be failing or they will be partially

00:07:01,490 --> 00:07:06,440
operational because they trying depend

00:07:04,610 --> 00:07:08,990
on that the despair depend on that the

00:07:06,440 --> 00:07:11,380
Pentagon depending directly to that and

00:07:08,990 --> 00:07:15,500
so on so once the the circle goes

00:07:11,380 --> 00:07:17,750
everything degrades so the idea how you

00:07:15,500 --> 00:07:20,660
solve that is to how do you cut that

00:07:17,750 --> 00:07:22,520
temporal dependency is by not

00:07:20,660 --> 00:07:26,240
necessarily calling each other

00:07:22,520 --> 00:07:28,760
VRS calls or RPC but by publishing data

00:07:26,240 --> 00:07:31,490
to some broker and consume it from there

00:07:28,760 --> 00:07:35,630
so at that point the circle or AG

00:07:31,490 --> 00:07:37,610
application can can be down but the

00:07:35,630 --> 00:07:39,770
events that were published on the broker

00:07:37,610 --> 00:07:41,900
are still they are already there and I

00:07:39,770 --> 00:07:44,090
can consume those events later even if

00:07:41,900 --> 00:07:47,270
the the circle application is being

00:07:44,090 --> 00:07:51,710
redeployed so that's the the whole idea

00:07:47,270 --> 00:07:55,280
of how you go actually from I would say

00:07:51,710 --> 00:07:57,520
mano leaf to a we call it a micro leaf

00:07:55,280 --> 00:08:00,560
so actually micro serves but still very

00:07:57,520 --> 00:08:02,870
dependent on each other to a reactive

00:08:00,560 --> 00:08:06,440
micro service where you cut that

00:08:02,870 --> 00:08:09,650
temporal dependency but what is how we

00:08:06,440 --> 00:08:12,520
do that oh yeah I forgot that and here

00:08:09,650 --> 00:08:16,250
you can also well you can also do that

00:08:12,520 --> 00:08:18,530
here you can because now you have

00:08:16,250 --> 00:08:20,960
separate applications you can scale them

00:08:18,530 --> 00:08:22,940
up according to their needs so you can

00:08:20,960 --> 00:08:25,490
have many instance of a triangle or

00:08:22,940 --> 00:08:29,570
square and so on but how we achieve that

00:08:25,490 --> 00:08:32,959
we achieved that by focus on a third

00:08:29,570 --> 00:08:35,419
event first design make sure that every

00:08:32,959 --> 00:08:37,190
mutation in your system is can be

00:08:35,419 --> 00:08:40,279
represent in terms of events and that's

00:08:37,190 --> 00:08:42,830
why event source is so important so the

00:08:40,279 --> 00:08:46,760
legume persistence API main focus is to

00:08:42,830 --> 00:08:49,459
help you on that and it embraces the

00:08:46,760 --> 00:08:53,390
concept of event source and secure s so

00:08:49,459 --> 00:08:55,400
in command query responsibility

00:08:53,390 --> 00:08:57,980
segregation you have the command side

00:08:55,400 --> 00:08:58,579
and a crash site and we will have a look

00:08:57,980 --> 00:09:01,459
on those

00:08:58,579 --> 00:09:03,199
two things and what are the the the most

00:09:01,459 --> 00:09:05,720
important problems that Lagoon is

00:09:03,199 --> 00:09:08,209
solving for you there so on the common

00:09:05,720 --> 00:09:11,149
side what elegance owed for you so free

00:09:08,209 --> 00:09:13,269
first the single writer principle I will

00:09:11,149 --> 00:09:16,369
come back I'll give more detail on that

00:09:13,269 --> 00:09:18,499
persistent actor passivation that's

00:09:16,369 --> 00:09:20,569
actually there are two features that are

00:09:18,499 --> 00:09:22,639
inclusive sharding occur closer sharding

00:09:20,569 --> 00:09:25,339
and like on leveraged out and that's the

00:09:22,639 --> 00:09:28,420
important aspect then there are two sub

00:09:25,339 --> 00:09:31,160
two bugs that you can write that you can

00:09:28,420 --> 00:09:33,319
write yourself if you are doing if

00:09:31,160 --> 00:09:35,360
you're using I can persist this directly

00:09:33,319 --> 00:09:39,369
yourself and I will explain what that is

00:09:35,360 --> 00:09:43,389
so back to the single write of principle

00:09:39,369 --> 00:09:46,449
if I have one load application so the

00:09:43,389 --> 00:09:48,739
I'll show you know why how does it

00:09:46,449 --> 00:09:51,139
happens in legume but you have your

00:09:48,739 --> 00:09:53,629
model that we call a persistent entity

00:09:51,139 --> 00:09:57,619
and that thing will run inside an actor

00:09:53,629 --> 00:09:59,029
and we know that in akka if I have a if

00:09:57,619 --> 00:10:00,529
I initialize an actor I cannot

00:09:59,029 --> 00:10:02,989
initialize another an actor with the

00:10:00,529 --> 00:10:05,899
same path on the same location so it

00:10:02,989 --> 00:10:08,360
will fail and so if I have one single

00:10:05,899 --> 00:10:10,669
note I'm kind of safe because I can

00:10:08,360 --> 00:10:13,939
guarantee that that instance is only

00:10:10,669 --> 00:10:16,069
running once in my system but if I have

00:10:13,939 --> 00:10:18,850
a closer and I have many nodes I must

00:10:16,069 --> 00:10:22,189
make sure that for a given entity

00:10:18,850 --> 00:10:25,129
identified by ABC let's say that's the

00:10:22,189 --> 00:10:27,019
idea of that entity I only have one over

00:10:25,129 --> 00:10:29,199
my cluster and that's what the cursor

00:10:27,019 --> 00:10:32,360
shard will help you to achieve and

00:10:29,199 --> 00:10:34,819
another thing is that if I have a

00:10:32,360 --> 00:10:38,389
command that I have to send to that

00:10:34,819 --> 00:10:41,480
given entity and I need to first the

00:10:38,389 --> 00:10:44,239
closer shot we all know where that

00:10:41,480 --> 00:10:46,850
entity is leaving or where the entity

00:10:44,239 --> 00:10:48,769
must be initializes and if I need to

00:10:46,850 --> 00:10:51,379
send another common command to it I

00:10:48,769 --> 00:10:53,209
don't know if I don't need to care about

00:10:51,379 --> 00:10:55,429
if it's already memory or not so the

00:10:53,209 --> 00:10:58,009
closer shard we take it take care for

00:10:55,429 --> 00:11:00,649
that for me and what happened with an

00:10:58,009 --> 00:11:02,689
actor that you bring into memory if it

00:11:00,649 --> 00:11:04,999
doesn't crash for some reason and if you

00:11:02,689 --> 00:11:08,059
don't shut it down for yourself it will

00:11:04,999 --> 00:11:10,910
stay in memory so what Lagoon will do is

00:11:08,059 --> 00:11:12,900
that it has that that's part of twister

00:11:10,910 --> 00:11:16,500
sharding but Lagaan has a tie

00:11:12,900 --> 00:11:19,140
if the the entity it's either for some

00:11:16,500 --> 00:11:21,030
time it will passivate itself it's okay

00:11:19,140 --> 00:11:23,850
I'm not receiving any comment for now so

00:11:21,030 --> 00:11:25,770
I will just stop and the closer shot

00:11:23,850 --> 00:11:28,140
will coordinate that it's not just like

00:11:25,770 --> 00:11:29,820
I will shut down because if you have a

00:11:28,140 --> 00:11:31,290
comment coming at that moment that you

00:11:29,820 --> 00:11:34,200
shut down what will happen with that

00:11:31,290 --> 00:11:37,140
comment it will fail because the actor

00:11:34,200 --> 00:11:39,030
is is is being stop it well we don't

00:11:37,140 --> 00:11:41,640
want that so the closer shard will kind

00:11:39,030 --> 00:11:43,680
of the short region knows that that

00:11:41,640 --> 00:11:45,630
entity is being shut down and then we

00:11:43,680 --> 00:11:47,940
will buffer that comment and once the

00:11:45,630 --> 00:11:49,350
entity really finished the shut down it

00:11:47,940 --> 00:11:51,240
will bring that ain't it back to the

00:11:49,350 --> 00:11:53,160
live with the comment so those are

00:11:51,240 --> 00:11:55,680
things that the closer shots are so V

00:11:53,160 --> 00:11:57,870
for you and that's why in lagoon you

00:11:55,680 --> 00:12:00,450
have the persistence entity it runs

00:11:57,870 --> 00:12:03,060
inside the persistent actor that's pure

00:12:00,450 --> 00:12:07,050
ARCA persistence but we bring together

00:12:03,060 --> 00:12:09,750
the processes occur persistence plus our

00:12:07,050 --> 00:12:12,540
cash Rd R Callister Charlie to create

00:12:09,750 --> 00:12:16,320
that complete solution and that's just

00:12:12,540 --> 00:12:19,200
work like it like it is like we don't

00:12:16,320 --> 00:12:23,760
have to do that yourself of course it's

00:12:19,200 --> 00:12:26,490
not hard to do it but since we can just

00:12:23,760 --> 00:12:30,750
build that for you guys we have it

00:12:26,490 --> 00:12:32,070
that's it so now I will give you a an

00:12:30,750 --> 00:12:34,830
explanation what are those two

00:12:32,070 --> 00:12:37,140
protections of these two kind of bugs

00:12:34,830 --> 00:12:40,020
that we have here so what it really

00:12:37,140 --> 00:12:42,510
happens is that persistence entity will

00:12:40,020 --> 00:12:45,420
live inside a persistence actor okay we

00:12:42,510 --> 00:12:48,000
take care of that then there is a common

00:12:45,420 --> 00:12:49,950
that comes in and it goes over a

00:12:48,000 --> 00:12:53,910
validation I have to decide if I can

00:12:49,950 --> 00:12:56,520
apply that or not then an event will be

00:12:53,910 --> 00:12:59,580
emitted eventually if the command is

00:12:56,520 --> 00:13:02,250
valid and then it apply it is applied to

00:12:59,580 --> 00:13:07,590
my states that's a very important thing

00:13:02,250 --> 00:13:14,510
because later after being applied it

00:13:07,590 --> 00:13:16,950
will be persisted why because people

00:13:14,510 --> 00:13:20,580
people I have seen that happened before

00:13:16,950 --> 00:13:22,530
people persist events and they they

00:13:20,580 --> 00:13:24,510
apply the events but when they apply the

00:13:22,530 --> 00:13:26,070
event they realize that they forgot to

00:13:24,510 --> 00:13:28,740
declare

00:13:26,070 --> 00:13:31,530
eventhandler fight and then what happens

00:13:28,740 --> 00:13:34,470
is that that event cannot be applied the

00:13:31,530 --> 00:13:39,240
actor will fail but the event is

00:13:34,470 --> 00:13:41,160
persisted and when you reinitialize that

00:13:39,240 --> 00:13:42,900
persistent entity again it will replay

00:13:41,160 --> 00:13:45,510
the events and you again fail because

00:13:42,900 --> 00:13:48,030
there is no event handler to handle that

00:13:45,510 --> 00:13:50,670
event so you first need to apply the

00:13:48,030 --> 00:13:53,580
event and then persist it seems like

00:13:50,670 --> 00:13:57,800
obvious but people do make that mistake

00:13:53,580 --> 00:14:00,630
and when you're using our persistence

00:13:57,800 --> 00:14:05,340
yourself I have done that before and I

00:14:00,630 --> 00:14:07,380
have seen that happening and any like oh

00:14:05,340 --> 00:14:10,020
you also take snapshots for you and

00:14:07,380 --> 00:14:12,450
different than Anaka persistence you you

00:14:10,020 --> 00:14:14,310
have to yourself decide when you persist

00:14:12,450 --> 00:14:16,260
in it as an app shot and are going you

00:14:14,310 --> 00:14:19,110
just have a configuration where you say

00:14:16,260 --> 00:14:21,900
every hundred events persist in a

00:14:19,110 --> 00:14:24,120
snapshot another soup to bug that

00:14:21,900 --> 00:14:26,790
happens and my friend Nico will was

00:14:24,120 --> 00:14:29,580
tweeting about that another day is when

00:14:26,790 --> 00:14:31,350
you persist in events and then you make

00:14:29,580 --> 00:14:32,880
a snapshot make sure that you have

00:14:31,350 --> 00:14:35,460
already applied to that event

00:14:32,880 --> 00:14:37,320
otherwise your persisting that your

00:14:35,460 --> 00:14:39,540
snapshot is from your previous event

00:14:37,320 --> 00:14:42,390
well he probably made that mistake as

00:14:39,540 --> 00:14:45,750
well as many of us have done and Lagaan

00:14:42,390 --> 00:14:48,570
kind of solve that's a nice thing is

00:14:45,750 --> 00:14:50,460
that in III was not here when

00:14:48,570 --> 00:14:52,680
Christopher was talking about the future

00:14:50,460 --> 00:14:53,670
of akka but he always he was probably

00:14:52,680 --> 00:14:57,330
talking about

00:14:53,670 --> 00:14:59,610
akka typed so the academia are working

00:14:57,330 --> 00:15:02,580
now on the ARCA persistence typed and

00:14:59,610 --> 00:15:04,680
it's those those things are also solved

00:15:02,580 --> 00:15:07,200
that because the ARCA persistence typed

00:15:04,680 --> 00:15:10,710
take more or less the same approach as

00:15:07,200 --> 00:15:12,840
logon it's doing is like it's it it give

00:15:10,710 --> 00:15:14,610
you the means to declare your comment

00:15:12,840 --> 00:15:17,330
hands and your event handlers and it

00:15:14,610 --> 00:15:20,580
take care of the correct ordering of

00:15:17,330 --> 00:15:23,880
when you the event is emitted it's

00:15:20,580 --> 00:15:26,490
applied then persisted and then there's

00:15:23,880 --> 00:15:28,410
an app shouting so this you cannot make

00:15:26,490 --> 00:15:29,820
that mistake anymore in our persistence

00:15:28,410 --> 00:15:31,650
typed will not be able to make that

00:15:29,820 --> 00:15:33,300
mistake and you cannot make that mistake

00:15:31,650 --> 00:15:35,250
in like them so those are two things

00:15:33,300 --> 00:15:35,640
that's the common side of solving for

00:15:35,250 --> 00:15:40,200
you

00:15:35,640 --> 00:15:43,650
plus the sharding the query side so on

00:15:40,200 --> 00:15:46,320
the to generate views from my events on

00:15:43,650 --> 00:15:48,450
I'm talking about one single service

00:15:46,320 --> 00:15:50,160
okay so in my service I have that entity

00:15:48,450 --> 00:15:52,320
that are producing events on my journal

00:15:50,160 --> 00:15:55,200
and from that journal I will generate

00:15:52,320 --> 00:15:56,640
some views on my model so there are a

00:15:55,200 --> 00:15:59,310
couple of things there the first thing

00:15:56,640 --> 00:16:01,950
is the shorter tagging which allows me

00:15:59,310 --> 00:16:04,200
to have distributed rich side processors

00:16:01,950 --> 00:16:06,810
so what is a red side processor it's

00:16:04,200 --> 00:16:08,730
kind of processor that we define that

00:16:06,810 --> 00:16:13,080
will consume your events and generate

00:16:08,730 --> 00:16:15,090
views from that and lagune will by using

00:16:13,080 --> 00:16:18,420
these shorter tags that I will show you

00:16:15,090 --> 00:16:21,810
in a while what is that exactly is it

00:16:18,420 --> 00:16:24,390
allows us to have distributed read side

00:16:21,810 --> 00:16:26,670
processors we have some facilities for

00:16:24,390 --> 00:16:28,950
developers if you want to I want to

00:16:26,670 --> 00:16:31,200
write some stuff in in sleek for

00:16:28,950 --> 00:16:34,530
instance in our JDBC database which is

00:16:31,200 --> 00:16:36,960
that's the the case of my demo today I

00:16:34,530 --> 00:16:40,710
can let's lock on create the table for

00:16:36,960 --> 00:16:43,050
myself and most important and that's the

00:16:40,710 --> 00:16:45,720
main reason why I choose JDBC because I

00:16:43,050 --> 00:16:49,200
like it very much how these things work

00:16:45,720 --> 00:16:51,330
is that Lagoon does the offset manage

00:16:49,200 --> 00:16:54,060
for you what is what that means what

00:16:51,330 --> 00:16:56,460
does that mean is whenever when I have

00:16:54,060 --> 00:17:00,030
an event of streams each event from my

00:16:56,460 --> 00:17:01,950
journal has a sequence number okay and I

00:17:00,030 --> 00:17:03,840
going start to consume that and if for

00:17:01,950 --> 00:17:07,410
each event it knows okay that was offset

00:17:03,840 --> 00:17:10,320
that much and then I give that event to

00:17:07,410 --> 00:17:12,240
you so you do yourself you do your

00:17:10,320 --> 00:17:15,480
database operation and what you give

00:17:12,240 --> 00:17:17,520
back to me is not something it is not

00:17:15,480 --> 00:17:20,730
yet executed you give me but you give

00:17:17,520 --> 00:17:22,740
back to me i slick DB i/o that I would

00:17:20,730 --> 00:17:24,900
take that DBA oh I'll take the offset

00:17:22,740 --> 00:17:27,720
that I know the one that belongs to that

00:17:24,900 --> 00:17:29,220
event I create another DBA oh I composed

00:17:27,720 --> 00:17:31,590
those two and I is acute on the same

00:17:29,220 --> 00:17:33,780
transaction what does that give is a

00:17:31,590 --> 00:17:36,150
exactly one's delivery so on the read

00:17:33,780 --> 00:17:38,190
side processor when when your

00:17:36,150 --> 00:17:41,670
transaction when your operation database

00:17:38,190 --> 00:17:43,710
succeed it succeed together with my

00:17:41,670 --> 00:17:46,380
offset if it crashed

00:17:43,710 --> 00:17:47,910
next time I restart it and I will take

00:17:46,380 --> 00:17:50,250
an offset that you have never seen

00:17:47,910 --> 00:17:52,170
before or we have seen but your

00:17:50,250 --> 00:17:52,590
transaction failures so the offset is

00:17:52,170 --> 00:17:54,210
men

00:17:52,590 --> 00:17:56,970
on the same transaction and that's a

00:17:54,210 --> 00:17:59,250
good thing and you have this back of

00:17:56,970 --> 00:18:01,260
kind of back of supervisor for streaming

00:17:59,250 --> 00:18:03,419
it's called a restart source it's the

00:18:01,260 --> 00:18:06,480
same principle back off supervisor and

00:18:03,419 --> 00:18:10,940
when it fails it restart after some time

00:18:06,480 --> 00:18:13,950
so that's all there for you and then

00:18:10,940 --> 00:18:16,350
just some example what what is the tag

00:18:13,950 --> 00:18:18,179
char the tagging and the kind of problem

00:18:16,350 --> 00:18:21,150
that people have with that so when you

00:18:18,179 --> 00:18:22,890
persist events you can tag your events

00:18:21,150 --> 00:18:25,289
and that's the means that's the way we

00:18:22,890 --> 00:18:28,770
have in our compositions query to later

00:18:25,289 --> 00:18:31,980
say okay I wanted those events I want

00:18:28,770 --> 00:18:33,809
all the events that has this tag so in

00:18:31,980 --> 00:18:36,659
the example you give today I have this

00:18:33,809 --> 00:18:41,070
account I use like a very simplified

00:18:36,659 --> 00:18:42,360
bank account thing and so my persistence

00:18:41,070 --> 00:18:44,490
ideal are going will create a

00:18:42,360 --> 00:18:47,610
persistence ID that is the name of the

00:18:44,490 --> 00:18:50,970
entity pipe and the real ID of that

00:18:47,610 --> 00:18:54,299
entity okay ABC and then it will add tag

00:18:50,970 --> 00:18:57,570
on my journal for that so I'm just

00:18:54,299 --> 00:18:59,760
taking the case here where I'm not shard

00:18:57,570 --> 00:19:02,190
in the tags and then what will happen

00:18:59,760 --> 00:19:05,190
here is that if I want to consume that I

00:19:02,190 --> 00:19:08,520
will use a persistence query and you say

00:19:05,190 --> 00:19:10,649
give me all the events in order for

00:19:08,520 --> 00:19:14,070
account everything that is tagged it

00:19:10,649 --> 00:19:16,529
with a count event what's the problem

00:19:14,070 --> 00:19:18,840
with that it means that I will have a

00:19:16,529 --> 00:19:21,690
consumer that will consume all the

00:19:18,840 --> 00:19:25,529
events from my entity so if I have a

00:19:21,690 --> 00:19:27,929
here journal and I have three three

00:19:25,529 --> 00:19:29,940
kinds of entity three three entities one

00:19:27,929 --> 00:19:31,409
two and three and the events are in

00:19:29,940 --> 00:19:33,960
their journal like that they are

00:19:31,409 --> 00:19:37,799
interleaved now I have one consumer that

00:19:33,960 --> 00:19:40,289
has to consume them all and what what

00:19:37,799 --> 00:19:43,830
will happen if I have them in a cluster

00:19:40,289 --> 00:19:47,789
if I have many nodes I have my rich side

00:19:43,830 --> 00:19:50,039
process being started in three different

00:19:47,789 --> 00:19:51,899
nodes and do exactly the same consuming

00:19:50,039 --> 00:19:54,539
all the events over and over again

00:19:51,899 --> 00:19:57,779
that's not what we want and what people

00:19:54,539 --> 00:20:01,020
do usually when they are doing that at

00:19:57,779 --> 00:20:04,080
themselves they say ok because I I want

00:20:01,020 --> 00:20:05,950
to have only one consumer I will put it

00:20:04,080 --> 00:20:08,740
on a cluster single tone and as

00:20:05,950 --> 00:20:10,960
singleton innaka you make sure that it

00:20:08,740 --> 00:20:13,179
makes sure that there is only one

00:20:10,960 --> 00:20:15,429
instance of that actor over your whole

00:20:13,179 --> 00:20:17,289
cluster and then what people do they

00:20:15,429 --> 00:20:19,120
create a processor themselves and they

00:20:17,289 --> 00:20:22,450
say okay that has to be a twister single

00:20:19,120 --> 00:20:25,409
tone and so you have one nodes in your

00:20:22,450 --> 00:20:29,620
cluster that is consuming all the events

00:20:25,409 --> 00:20:30,820
but what we really want is to separate a

00:20:29,620 --> 00:20:34,360
little bit of those events not

00:20:30,820 --> 00:20:37,570
necessarily having one processor pure ID

00:20:34,360 --> 00:20:39,220
like here but I want to create a logical

00:20:37,570 --> 00:20:41,470
view over my journal

00:20:39,220 --> 00:20:43,110
and I want to be able to identify them

00:20:41,470 --> 00:20:46,480
in a different way

00:20:43,110 --> 00:20:50,740
so what Lagoon will do is they will

00:20:46,480 --> 00:20:51,220
shard the tags so I can say how it's

00:20:50,740 --> 00:20:54,159
done

00:20:51,220 --> 00:20:57,549
it's basically say that's my entity

00:20:54,159 --> 00:20:59,980
that's my event and I want shard and I

00:20:57,549 --> 00:21:02,740
want ten shots so when we're going to

00:20:59,980 --> 00:21:04,899
persist the events it will take the Real

00:21:02,740 --> 00:21:07,389
ID of the event so not the one that is

00:21:04,899 --> 00:21:09,820
persist but sorry the Real ID of the

00:21:07,389 --> 00:21:12,909
entity in that case here is ABC

00:21:09,820 --> 00:21:15,399
it will take the hash code and you do

00:21:12,909 --> 00:21:18,460
let's say model ten if you ask it for

00:21:15,399 --> 00:21:21,159
ten charts and then mozo ten you give

00:21:18,460 --> 00:21:23,500
you from zero to nine numbers that will

00:21:21,159 --> 00:21:26,350
be appended to the events and like

00:21:23,500 --> 00:21:28,840
always manage that for you then lagoon

00:21:26,350 --> 00:21:30,700
will say okay when when you have one

00:21:28,840 --> 00:21:33,399
single node it will create ten

00:21:30,700 --> 00:21:37,120
processors and each of those processors

00:21:33,399 --> 00:21:39,850
will consume one specific tag so I

00:21:37,120 --> 00:21:43,360
achieved that now instead of having only

00:21:39,850 --> 00:21:45,789
one consumer have ten and if I put

00:21:43,360 --> 00:21:48,909
another node if I was talking about one

00:21:45,789 --> 00:21:50,769
single node if I add on a second node it

00:21:48,909 --> 00:21:53,679
will be distribute I have one node

00:21:50,769 --> 00:21:55,720
consume is five short shorter tags and

00:21:53,679 --> 00:21:58,029
another node consume and not the other

00:21:55,720 --> 00:22:02,250
five shards tags I increase my closer

00:21:58,029 --> 00:22:05,200
and they get distributed so that's

00:22:02,250 --> 00:22:08,139
that's there for you you can have a look

00:22:05,200 --> 00:22:10,090
on the the code and do that yourself but

00:22:08,139 --> 00:22:13,570
it's I'm not saying that it's rocket

00:22:10,090 --> 00:22:15,250
side but there are some some nice tricks

00:22:13,570 --> 00:22:19,570
there to make it really happen for

00:22:15,250 --> 00:22:21,850
instance how can I know if I

00:22:19,570 --> 00:22:24,430
note and I start up how can I know which

00:22:21,850 --> 00:22:26,290
charts tags I have to consume which

00:22:24,430 --> 00:22:28,780
processes I need to start solo gonna

00:22:26,290 --> 00:22:30,850
take care of that for you so that's I

00:22:28,780 --> 00:22:34,630
think it's one of the most powerful

00:22:30,850 --> 00:22:37,120
things in logon is that we we take care

00:22:34,630 --> 00:22:39,610
of the persistence but we put it in a

00:22:37,120 --> 00:22:42,820
context of cluster sharding in one side

00:22:39,610 --> 00:22:44,530
and we take care of the read side on the

00:22:42,820 --> 00:22:47,140
other on the other hand we take care of

00:22:44,530 --> 00:22:49,180
the rich side and we make it possible to

00:22:47,140 --> 00:22:54,340
have different processors at the same

00:22:49,180 --> 00:22:57,040
time by shorting the tags that's good

00:22:54,340 --> 00:22:58,800
because I it's time for demo and my time

00:22:57,040 --> 00:23:04,600
seems to be ok

00:22:58,800 --> 00:23:11,620
so how it looks like that's I start with

00:23:04,600 --> 00:23:15,100
my account entity I won't do live code

00:23:11,620 --> 00:23:20,650
because I I soak on that it's really bad

00:23:15,100 --> 00:23:26,770
and and instead I will just go over over

00:23:20,650 --> 00:23:28,900
the code and explain so this is a

00:23:26,770 --> 00:23:31,660
persistence and in telegin so that's

00:23:28,900 --> 00:23:36,520
your in terms of ddd we call it and

00:23:31,660 --> 00:23:39,610
aggregate and you just that's that will

00:23:36,520 --> 00:23:43,060
run inside on a persistent actor okay so

00:23:39,610 --> 00:23:46,480
but we you don't see actor stuff in

00:23:43,060 --> 00:23:49,510
there you see a little bit but it all it

00:23:46,480 --> 00:23:52,990
it helps you focus on your domain and

00:23:49,510 --> 00:23:55,120
it's about define the states in the case

00:23:52,990 --> 00:23:58,540
here it's an account and I have account

00:23:55,120 --> 00:24:00,730
commands and account events and then I

00:23:58,540 --> 00:24:03,160
have an initial state and my account

00:24:00,730 --> 00:24:07,630
starts with zero balance and then I have

00:24:03,160 --> 00:24:13,660
a commands I deposed something then I

00:24:07,630 --> 00:24:17,500
persist that event and I reply and on

00:24:13,660 --> 00:24:20,050
the withdrawal I have to decide if I

00:24:17,500 --> 00:24:23,380
will go below 0 if I go a negative

00:24:20,050 --> 00:24:26,470
balance it's not allowed so I can reject

00:24:23,380 --> 00:24:29,290
the commands and then I have my my

00:24:26,470 --> 00:24:32,530
events handlers the what I do when I

00:24:29,290 --> 00:24:36,520
receive that event the deposit

00:24:32,530 --> 00:24:38,890
event and when I received get back the

00:24:36,520 --> 00:24:40,720
whiff don't event

00:24:38,890 --> 00:24:42,250
what's it important as maybe baby it's

00:24:40,720 --> 00:24:45,039
not so obvious but I was saying that

00:24:42,250 --> 00:24:47,200
before when you say here then persist

00:24:45,039 --> 00:24:49,720
you're not yet persisting you're telling

00:24:47,200 --> 00:24:51,159
me what you want to get per season what

00:24:49,720 --> 00:24:53,320
I will do behind the scene is okay

00:24:51,159 --> 00:24:55,659
that's the event good I will apply it

00:24:53,320 --> 00:25:00,010
using the event handlers you gave to me

00:24:55,659 --> 00:25:03,419
and then I persist it what happens if I

00:25:00,010 --> 00:25:07,120
apply the event and it fails to persist

00:25:03,419 --> 00:25:10,090
so I applied the event on my states but

00:25:07,120 --> 00:25:12,400
I couldn't persist it is that important

00:25:10,090 --> 00:25:14,230
as we do we care about that well

00:25:12,400 --> 00:25:16,809
actually not because if you try to

00:25:14,230 --> 00:25:18,940
persist something and the database is

00:25:16,809 --> 00:25:22,090
not there for instance your actor will

00:25:18,940 --> 00:25:24,190
blow up and then yet that state will be

00:25:22,090 --> 00:25:25,809
gone and because you are inside an actor

00:25:24,190 --> 00:25:27,640
because that thing will run inside an

00:25:25,809 --> 00:25:30,760
actor you are protected nobody can see

00:25:27,640 --> 00:25:32,770
that states in the meantime you apply it

00:25:30,760 --> 00:25:35,320
you have some state that was mutated in

00:25:32,770 --> 00:25:39,640
memory but you fail it persist so that

00:25:35,320 --> 00:25:42,070
goes so at the end it only counts once

00:25:39,640 --> 00:25:45,100
it's persisted then it's it becomes a

00:25:42,070 --> 00:25:47,890
fact but we apply it before per season

00:25:45,100 --> 00:25:52,750
to guarantee that the event handler is

00:25:47,890 --> 00:25:55,179
there so here have everything define it

00:25:52,750 --> 00:25:57,940
I have for each type that for each data

00:25:55,179 --> 00:26:00,159
type I have here the account it also has

00:25:57,940 --> 00:26:01,179
a JSON serializer the command has

00:26:00,159 --> 00:26:03,970
adjacency rÃ©aliser

00:26:01,179 --> 00:26:06,730
and so on the events that's an important

00:26:03,970 --> 00:26:09,370
thing it has to my base event implements

00:26:06,730 --> 00:26:12,010
this aggregate events that's where I

00:26:09,370 --> 00:26:15,130
have to define that that tag that's how

00:26:12,010 --> 00:26:17,500
logon will tag your events and when

00:26:15,130 --> 00:26:20,679
doing that I'm using that shorted tags

00:26:17,500 --> 00:26:23,799
here and I'm using that number of shards

00:26:20,679 --> 00:26:26,710
10 that's how I you get the events shard

00:26:23,799 --> 00:26:29,650
it ok so when you define your events you

00:26:26,710 --> 00:26:33,220
say ok and I want for that entity I want

00:26:29,650 --> 00:26:36,010
10 shots and so on and here are the

00:26:33,220 --> 00:26:38,860
serializers from my events and commands

00:26:36,010 --> 00:26:41,640
and it will be wired together in your

00:26:38,860 --> 00:26:41,640
application so

00:26:42,870 --> 00:26:46,970
you

00:26:43,970 --> 00:26:49,010
so here is where you wire your

00:26:46,970 --> 00:26:52,400
application so this color version of

00:26:49,010 --> 00:26:54,470
lagoon use Mac wire to wire everything

00:26:52,400 --> 00:26:57,370
together so you have this component so

00:26:54,470 --> 00:27:00,560
you build your your cake with that and

00:26:57,370 --> 00:27:02,960
and at some point you have to declare to

00:27:00,560 --> 00:27:06,410
lagoon your persistence in the

00:27:02,960 --> 00:27:08,660
persistent persistent entity resistor II

00:27:06,410 --> 00:27:12,950
you say okay that's an entity that I

00:27:08,660 --> 00:27:17,420
want to be run inside an actor I have

00:27:12,950 --> 00:27:20,030
also here the serializers I have here

00:27:17,420 --> 00:27:22,580
the event processor and the event

00:27:20,030 --> 00:27:26,960
processor is just a small class where I

00:27:22,580 --> 00:27:30,530
take a repository report account report

00:27:26,960 --> 00:27:32,570
thing I teach logon how to create the

00:27:30,530 --> 00:27:34,810
table for me here and I have the event

00:27:32,570 --> 00:27:37,580
handlers whenever gets a deposit or

00:27:34,810 --> 00:27:40,700
withdrawal whatever you do I increase my

00:27:37,580 --> 00:27:42,740
report I'll show you what is that it's

00:27:40,700 --> 00:27:44,330
just a small class that I have here for

00:27:42,740 --> 00:27:46,280
demo purpose where I have the account

00:27:44,330 --> 00:27:48,080
number and I have a transaction count

00:27:46,280 --> 00:27:50,000
doesn't matter if it's the post of

00:27:48,080 --> 00:27:51,590
withdraw I will increase that's that

00:27:50,000 --> 00:27:53,630
counter to say okay I have so many

00:27:51,590 --> 00:27:56,270
transactions on these accounts that's

00:27:53,630 --> 00:28:02,390
kind of reports I created and the rest

00:27:56,270 --> 00:28:07,370
is just a slick code okay so what no

00:28:02,390 --> 00:28:09,650
this one what this method is expecting

00:28:07,370 --> 00:28:14,930
is to you'll return here you must return

00:28:09,650 --> 00:28:17,780
at the bi o the bi o here where you put

00:28:14,930 --> 00:28:19,970
your operation and I will take that the

00:28:17,780 --> 00:28:21,380
Bao to get with the offset one I will

00:28:19,970 --> 00:28:24,200
compose them and is occurred on the same

00:28:21,380 --> 00:28:27,380
transaction which will give us at

00:28:24,200 --> 00:28:32,510
exactly ones delivery unless you remove

00:28:27,380 --> 00:28:34,430
things the offset tracking and then I

00:28:32,510 --> 00:28:36,320
have this service here and now you show

00:28:34,430 --> 00:28:39,320
start to show now the service

00:28:36,320 --> 00:28:41,390
descriptive part become more interesting

00:28:39,320 --> 00:28:44,540
on the next part of the demo but the

00:28:41,390 --> 00:28:48,290
that's the trade where you define your

00:28:44,540 --> 00:28:50,660
external API and for each method I have

00:28:48,290 --> 00:28:52,610
here I can request the balance I have I

00:28:50,660 --> 00:28:54,500
can request their accounts transaction I

00:28:52,610 --> 00:28:57,240
can deposit money I can withdraw money

00:28:54,500 --> 00:28:59,100
and I have this

00:28:57,240 --> 00:29:02,600
service call that I have to implement

00:28:59,100 --> 00:29:07,040
later on and then this is equivalent to

00:29:02,600 --> 00:29:09,390
to a play routing file okay I say API

00:29:07,040 --> 00:29:10,950
accounts here will come the account

00:29:09,390 --> 00:29:13,740
number you see that there is a column

00:29:10,950 --> 00:29:16,530
there and I can ask for the balance now

00:29:13,740 --> 00:29:18,000
go we will try to to infer what you are

00:29:16,530 --> 00:29:20,220
you're trying what do you want to do

00:29:18,000 --> 00:29:24,330
here for instance that method has no

00:29:20,220 --> 00:29:27,570
payloads but it does return something so

00:29:24,330 --> 00:29:30,780
when when I pass when I define as a path

00:29:27,570 --> 00:29:33,810
call using a service call that has no

00:29:30,780 --> 00:29:37,950
payload but returns something that will

00:29:33,810 --> 00:29:42,120
be a get in rest terms if I have a call

00:29:37,950 --> 00:29:45,240
that does pass a payload then it will be

00:29:42,120 --> 00:29:47,940
a post and so on so so that's how it

00:29:45,240 --> 00:29:52,170
works and you see in a later example

00:29:47,940 --> 00:29:55,890
that you can also do WebSockets okay so

00:29:52,170 --> 00:30:00,270
let's go for the demo so you start like

00:29:55,890 --> 00:30:03,800
on just by doing run oh and please just

00:30:00,270 --> 00:30:08,250
work now demo time

00:30:03,800 --> 00:30:11,010
and I have here I like to do I have here

00:30:08,250 --> 00:30:18,960
a file let me see if I'm on the right

00:30:11,010 --> 00:30:22,260
place no account I am by the way

00:30:18,960 --> 00:30:25,280
I have here docker compose I have here

00:30:22,260 --> 00:30:31,710
Postgres running and I will connect that

00:30:25,280 --> 00:30:33,810
I want to connect it before it started

00:30:31,710 --> 00:30:36,360
yeah perfect

00:30:33,810 --> 00:30:37,770
here I'm connected to to Postgres and

00:30:36,360 --> 00:30:40,650
you see there is no table there but

00:30:37,770 --> 00:30:44,040
legume is starting and what we see is

00:30:40,650 --> 00:30:47,610
that it's now I have the tables created

00:30:44,040 --> 00:30:50,490
by logon and for my demos I like to have

00:30:47,610 --> 00:30:53,400
a file like this one that are those

00:30:50,490 --> 00:30:55,770
source here which I can have some

00:30:53,400 --> 00:30:57,870
functions that I predefined for the demo

00:30:55,770 --> 00:31:00,720
and I will show you how it looks like

00:30:57,870 --> 00:31:03,570
that's that will make a post on logon

00:31:00,720 --> 00:31:08,070
passing some payload so if I say here

00:31:03,570 --> 00:31:10,710
account the I would the post thousand

00:31:08,070 --> 00:31:15,210
euros on the accounts it

00:31:10,710 --> 00:31:19,279
filed by ABC okay so it goes inside lag

00:31:15,210 --> 00:31:22,919
on the entity take that and create

00:31:19,279 --> 00:31:26,580
deposit so what we have here behind the

00:31:22,919 --> 00:31:29,190
scenes what logon have done is first my

00:31:26,580 --> 00:31:32,880
account report was created here am i on

00:31:29,190 --> 00:31:36,590
my table now my account report was

00:31:32,880 --> 00:31:36,590
created let's see what we have done

00:31:36,679 --> 00:31:48,960
select from so now I have the that's the

00:31:47,100 --> 00:31:55,320
the report I have I have one transaction

00:31:48,960 --> 00:31:56,010
if I put another one I have two

00:31:55,320 --> 00:31:58,440
transactions

00:31:56,010 --> 00:32:00,270
that's my read side know that I have my

00:31:58,440 --> 00:32:04,649
processor producing that but the most

00:32:00,270 --> 00:32:06,600
important thing is that the most what is

00:32:04,649 --> 00:32:08,730
interesting for us is that Lagoon is

00:32:06,600 --> 00:32:11,850
taking care of that as well he's

00:32:08,730 --> 00:32:14,850
tracking we are going striking that for

00:32:11,850 --> 00:32:19,549
the read model I name it account report

00:32:14,850 --> 00:32:22,640
for the tag that one with the tag that

00:32:19,549 --> 00:32:28,020
tag account event for Charlotte with the

00:32:22,640 --> 00:32:31,440
with the shot number for I'm I'm on the

00:32:28,020 --> 00:32:42,419
sequence offset number two if I create

00:32:31,440 --> 00:32:47,070
here I know that I have tested it before

00:32:42,419 --> 00:32:48,779
the if I use the ID ABCD I will go on

00:32:47,070 --> 00:32:52,260
the same chart I will have the same

00:32:48,779 --> 00:32:53,940
short short attack so this one I create

00:32:52,260 --> 00:33:00,450
a new account I put thousand years on

00:32:53,940 --> 00:33:03,270
account ABCD and on my offset I have

00:33:00,450 --> 00:33:07,260
only one entry why because the tire the

00:33:03,270 --> 00:33:10,230
tag of this account is the same but here

00:33:07,260 --> 00:33:12,090
on that one I have to read side so I

00:33:10,230 --> 00:33:14,730
have now to read sides being processed

00:33:12,090 --> 00:33:16,620
by the same processor because those two

00:33:14,730 --> 00:33:19,559
IDs are being targeted with on the same

00:33:16,620 --> 00:33:23,980
chart okay and of course I can add more

00:33:19,559 --> 00:33:44,019
and so

00:33:23,980 --> 00:33:46,179
I will stop this one and I will I let it

00:33:44,019 --> 00:33:48,789
start here in the background and what I

00:33:46,179 --> 00:33:52,929
have done now is I increase my account

00:33:48,789 --> 00:33:57,639
service and I create a topic so ten

00:33:52,929 --> 00:33:59,500
minutes okay so before I was only on my

00:33:57,639 --> 00:34:01,990
service descript I have only those calls

00:33:59,500 --> 00:34:04,090
service calls like rest kind of thing

00:34:01,990 --> 00:34:06,909
and now I have the topic and the topic

00:34:04,090 --> 00:34:09,520
is actually the broker API in lagoon and

00:34:06,909 --> 00:34:11,409
the implementation of that that's the

00:34:09,520 --> 00:34:16,060
service I have that implementation and

00:34:11,409 --> 00:34:17,829
if I and I have another service here so

00:34:16,060 --> 00:34:21,250
I have now two service running on argon

00:34:17,829 --> 00:34:27,520
and that other service it's a very

00:34:21,250 --> 00:34:29,530
simplified thing I did here but yeah

00:34:27,520 --> 00:34:32,619
I've started by the loader so the loader

00:34:29,530 --> 00:34:35,379
on that other service it declares a

00:34:32,619 --> 00:34:40,419
service here the stream serves and it

00:34:35,379 --> 00:34:42,909
declares that it wants a client on the

00:34:40,419 --> 00:34:44,919
other service that's my original source

00:34:42,909 --> 00:34:49,389
okay there are consoles where are now I

00:34:44,919 --> 00:34:52,139
have a topic and now I ask logon that's

00:34:49,389 --> 00:34:55,179
a macron logon like take that trait and

00:34:52,139 --> 00:34:57,430
generate a client for me and legume will

00:34:55,179 --> 00:34:59,380
know where that other service is running

00:34:57,430 --> 00:35:03,040
because lagoons take care of that okay

00:34:59,380 --> 00:35:05,020
so and I will inject that here on my

00:35:03,040 --> 00:35:08,260
service implementation so that is my

00:35:05,020 --> 00:35:10,859
first service account service where I

00:35:08,260 --> 00:35:14,410
ask the transactions which is a topic

00:35:10,859 --> 00:35:16,390
where I can subscribe and I can say at

00:35:14,410 --> 00:35:18,640
least once and I will just take the

00:35:16,390 --> 00:35:20,369
message come in there and now you print

00:35:18,640 --> 00:35:23,079
it

00:35:20,369 --> 00:35:25,720
what will happen here is that in one

00:35:23,079 --> 00:35:28,690
side on their counsels logon you see

00:35:25,720 --> 00:35:32,910
that you declare a topic let's let's

00:35:28,690 --> 00:35:32,910
have a look on how how you implement it

00:35:33,000 --> 00:35:37,900
that's a top producer where I'm saying

00:35:36,790 --> 00:35:42,600
okay

00:35:37,900 --> 00:35:47,920
I want to teach lagoon where it has to

00:35:42,600 --> 00:35:51,760
how it has to set up this Kafka topic

00:35:47,920 --> 00:35:54,580
and I'm say okay go to my persistence

00:35:51,760 --> 00:35:56,560
and a registry take an event stream of

00:35:54,580 --> 00:35:59,680
all the events that I have they're using

00:35:56,560 --> 00:36:02,440
some tag that will show up here using

00:35:59,680 --> 00:36:05,620
the Charlotte tags I convert each event

00:36:02,440 --> 00:36:07,750
to a string and I put it in Kafka so

00:36:05,620 --> 00:36:09,430
Lagaan does that for you and then the

00:36:07,750 --> 00:36:12,130
other side the other service can

00:36:09,430 --> 00:36:14,410
subscribe to that what happened here is

00:36:12,130 --> 00:36:20,080
that because I was just doing printer

00:36:14,410 --> 00:36:23,380
lane I have that's the accounts account

00:36:20,080 --> 00:36:26,710
stream serves that is printing that okay

00:36:23,380 --> 00:36:28,690
so it's one month service pushing things

00:36:26,710 --> 00:36:30,490
in Kafka for you the other services

00:36:28,690 --> 00:36:34,900
consuming from Kafka and printing on the

00:36:30,490 --> 00:36:37,450
on the standard output but the next

00:36:34,900 --> 00:36:45,100
thing that is happening here is that

00:36:37,450 --> 00:36:48,130
thing now I have to short to offset

00:36:45,100 --> 00:36:51,040
tracking one for my own rich site and

00:36:48,130 --> 00:36:53,380
one for the topic producer that is like

00:36:51,040 --> 00:36:57,250
own thing it's doing that for you but

00:36:53,380 --> 00:37:04,560
it's the same kind of of infrastructure

00:36:57,250 --> 00:37:09,460
I would say if I have I put here another

00:37:04,560 --> 00:37:12,370
entity what will happen is now I have

00:37:09,460 --> 00:37:14,410
one account report to accountant reports

00:37:12,370 --> 00:37:16,870
and to topic producers offset tracking

00:37:14,410 --> 00:37:19,720
what does that mean is that when I have

00:37:16,870 --> 00:37:21,910
because I choose a shortening of ten it

00:37:19,720 --> 00:37:25,900
means that I have in my single note I

00:37:21,910 --> 00:37:29,050
have a single note here ten process for

00:37:25,900 --> 00:37:32,320
my account report and then process for

00:37:29,050 --> 00:37:34,510
the topic producer I increase my my my

00:37:32,320 --> 00:37:37,570
clothes I put another note both are

00:37:34,510 --> 00:37:39,550
distributed part of my processes we go

00:37:37,570 --> 00:37:42,130
to the new note both for the account

00:37:39,550 --> 00:37:46,330
report and for the top to the so P we

00:37:42,130 --> 00:37:49,420
spread the load as as as we go as we

00:37:46,330 --> 00:37:51,320
increase the size of our closer so the

00:37:49,420 --> 00:37:59,050
next part of the demo

00:37:51,320 --> 00:38:01,490
and I think I still have some time is

00:37:59,050 --> 00:38:08,320
how I call it pub/sub

00:38:01,490 --> 00:38:13,840
yeah that should let's see the code

00:38:08,320 --> 00:38:17,090
what I did here now is I increase my I

00:38:13,840 --> 00:38:19,280
add one more method on my service

00:38:17,090 --> 00:38:24,770
descriptor and that method has something

00:38:19,280 --> 00:38:28,160
different here is it is it iris I get an

00:38:24,770 --> 00:38:30,830
account number and myself skull has no

00:38:28,160 --> 00:38:35,570
payload but it returns me a source of

00:38:30,830 --> 00:38:38,060
string when logon sees out service call

00:38:35,570 --> 00:38:48,220
returning a source it will translate

00:38:38,060 --> 00:38:52,760
that to a WebSocket so what I did

00:38:48,220 --> 00:38:54,590
further here is account entity there is

00:38:52,760 --> 00:38:57,440
another thing logon that I'm using now

00:38:54,590 --> 00:39:00,950
it's the perb sub which is based on a

00:38:57,440 --> 00:39:02,420
couple pub/sub as well and it's it's an

00:39:00,950 --> 00:39:04,310
in-memory thing so there is no

00:39:02,420 --> 00:39:06,110
persistence here I put something on the

00:39:04,310 --> 00:39:08,450
pub sub it will be distributed in my

00:39:06,110 --> 00:39:12,430
closer to everybody that subscribe to it

00:39:08,450 --> 00:39:17,030
so what I'm doing is after persisting

00:39:12,430 --> 00:39:20,120
after persist I put some message in the

00:39:17,030 --> 00:39:24,470
pub sub and I say there is a channel

00:39:20,120 --> 00:39:27,350
here for that ID and if you subscribe to

00:39:24,470 --> 00:39:29,810
it you you see that happen but that's a

00:39:27,350 --> 00:39:33,140
new memory thing that's not if you're

00:39:29,810 --> 00:39:35,510
not to subscribe it if you if you didn't

00:39:33,140 --> 00:39:38,690
subscribe to it you'll not see it so you

00:39:35,510 --> 00:39:41,360
must have subscribed when the vet

00:39:38,690 --> 00:39:46,790
happens and then you see it so I'm using

00:39:41,360 --> 00:39:49,670
us to demo the source thing the

00:39:46,790 --> 00:39:51,860
WebSockets so I have a look we have a

00:39:49,670 --> 00:39:56,150
look on the other service the stream

00:39:51,860 --> 00:39:59,030
service to show you that I also add here

00:39:56,150 --> 00:40:00,410
another stream methods that's exactly

00:39:59,030 --> 00:40:02,750
the same as the other one it takes an

00:40:00,410 --> 00:40:05,619
account and it returns the source but

00:40:02,750 --> 00:40:08,719
what I'm doing here is

00:40:05,619 --> 00:40:10,869
when when I called the account stream

00:40:08,719 --> 00:40:13,969
service and I pass an accountant armored

00:40:10,869 --> 00:40:17,659
number it will call the other service

00:40:13,969 --> 00:40:20,779
and what this method will return me is a

00:40:17,659 --> 00:40:27,559
service call well not this month yeah

00:40:20,779 --> 00:40:29,599
it's hard to see here no maybe not it

00:40:27,559 --> 00:40:32,359
returns me a service call that returns a

00:40:29,599 --> 00:40:33,979
source here because I'm in Scala I'm not

00:40:32,359 --> 00:40:36,559
even seen that there is a WebSocket

00:40:33,979 --> 00:40:42,019
going behind the scenes I'm just working

00:40:36,559 --> 00:40:45,559
with with acha acha streams so I have

00:40:42,019 --> 00:40:50,019
this I read I get a back a future with a

00:40:45,559 --> 00:40:50,019
source in it so I map that's my source

00:40:53,109 --> 00:41:00,709
that's the type a here is a source ok so

00:40:58,069 --> 00:41:03,949
it's maybe not too big for people behind

00:41:00,709 --> 00:41:05,630
in the room but that's a source and I'm

00:41:03,949 --> 00:41:09,429
just transformed that sourcing and

00:41:05,630 --> 00:41:12,589
adding prepending the streaming on it so

00:41:09,429 --> 00:41:20,719
what will happen here is let's go back

00:41:12,589 --> 00:41:25,479
here no here now I will connect with a

00:41:20,719 --> 00:41:25,479
website client to data stream thing

00:41:26,140 --> 00:41:38,599
maybe it's better to do it here almost

00:41:33,349 --> 00:41:43,099
finish when I put a deposit it should

00:41:38,599 --> 00:41:46,159
show up there but if the thing is here I

00:41:43,099 --> 00:41:48,609
subscribe to ABC but here I put event on

00:41:46,159 --> 00:41:52,640
DNF so that's why I didn't show up so

00:41:48,609 --> 00:41:55,039
boom ah so now what is happening is I

00:41:52,640 --> 00:41:57,650
send them as a central command to my

00:41:55,039 --> 00:42:00,319
account service it's emitting events

00:41:57,650 --> 00:42:03,409
after persisting it put on the pub/sub

00:42:00,319 --> 00:42:06,380
they occur the account serves expose

00:42:03,409 --> 00:42:09,049
that pub/sub via WebSockets the other

00:42:06,380 --> 00:42:11,749
serves take that same WebSocket and

00:42:09,049 --> 00:42:13,969
expose it again by adding this streaming

00:42:11,749 --> 00:42:17,719
prepared in that but on the code level

00:42:13,969 --> 00:42:18,760
I'm not even seeing whatever web could

00:42:17,719 --> 00:42:20,650
sockets

00:42:18,760 --> 00:42:25,090
infrastructure I'm just working with

00:42:20,650 --> 00:42:27,940
arca archa streams so that's more the

00:42:25,090 --> 00:42:31,210
service descriptor a functionality logon

00:42:27,940 --> 00:42:35,170
and actually that's everything I had for

00:42:31,210 --> 00:42:37,359
to show today I hope I will give another

00:42:35,170 --> 00:42:40,630
talk another day only focus on service

00:42:37,359 --> 00:42:43,960
descriptor but I hope you guys have

00:42:40,630 --> 00:42:46,660
already a good idea of how it works and

00:42:43,960 --> 00:42:49,720
what what you can what are the nice

00:42:46,660 --> 00:42:50,920
goodies that are there for you I think

00:42:49,720 --> 00:42:53,650
we still have some time for questions

00:42:50,920 --> 00:42:56,140
two minutes but we can yeah now it's

00:42:53,650 --> 00:42:59,260
break so we can stay here I think and

00:42:56,140 --> 00:43:11,550
have some some questions thanks very

00:42:59,260 --> 00:43:11,550
much you have a question here yeah I

00:43:12,359 --> 00:43:20,700
don't know I was not there when it

00:43:17,109 --> 00:43:23,460
happened well I think I think that you

00:43:20,700 --> 00:43:28,660
could have done the same

00:43:23,460 --> 00:43:30,880
there are one thing that is for sure it

00:43:28,660 --> 00:43:33,700
takes from play the same kind of

00:43:30,880 --> 00:43:37,020
developer experience that you start and

00:43:33,700 --> 00:43:40,690
you recompile your your-your-your code

00:43:37,020 --> 00:43:43,000
you have that service call API that is

00:43:40,690 --> 00:43:45,369
you see that I can generate a client for

00:43:43,000 --> 00:43:48,609
that and that's why I'm not using action

00:43:45,369 --> 00:43:51,220
directly but you can go one level one

00:43:48,609 --> 00:43:54,220
level down and use play actions and I

00:43:51,220 --> 00:43:58,090
believe that for applications of a bits

00:43:54,220 --> 00:44:04,030
easier to use ARCA play actions than

00:43:58,090 --> 00:44:06,790
going barebone one level deeper maybe I

00:44:04,030 --> 00:44:08,980
have a better one more information that

00:44:06,790 --> 00:44:12,940
is probably the reason why it was like

00:44:08,980 --> 00:44:17,350
that is that originally play had as

00:44:12,940 --> 00:44:20,170
back-end nettie so we need to instead of

00:44:17,350 --> 00:44:22,570
building another layer on top of net we

00:44:20,170 --> 00:44:25,840
built a layer on top of play but now

00:44:22,570 --> 00:44:28,570
please moving to our HTTP and log on as

00:44:25,840 --> 00:44:32,440
well so now we have service call play

00:44:28,570 --> 00:44:35,710
actions our HTTP no so

00:44:32,440 --> 00:44:37,900
eventually and that's things that we are

00:44:35,710 --> 00:44:39,400
working now and whatever I say now it's

00:44:37,900 --> 00:44:41,110
not a promise okay

00:44:39,400 --> 00:44:43,210
but there are a couple of things

00:44:41,110 --> 00:44:45,490
happening in light battle right now

00:44:43,210 --> 00:44:46,690
one is the archetype and our persistence

00:44:45,490 --> 00:44:51,880
typed that I was saying it's very

00:44:46,690 --> 00:44:54,250
similar to logon API and there is also a

00:44:51,880 --> 00:44:56,500
qgr PC that's so there's already we have

00:44:54,250 --> 00:44:58,870
a rel release I think zero one it's very

00:44:56,500 --> 00:45:03,100
experimental and at some point I believe

00:44:58,870 --> 00:45:05,230
you you just take an aqua gr PC server

00:45:03,100 --> 00:45:08,050
and put the lock on persistence API

00:45:05,230 --> 00:45:10,870
behind it or the lagoon or the aqua

00:45:08,050 --> 00:45:13,510
persistence typed API so we'll move

00:45:10,870 --> 00:45:15,970
things as we go and as those other

00:45:13,510 --> 00:45:20,440
technologies become more mature and at

00:45:15,970 --> 00:45:22,330
some point maybe you not choose Lagoon

00:45:20,440 --> 00:45:25,510
but you choose a code your PC proves

00:45:22,330 --> 00:45:28,000
persistence with sharding so we are

00:45:25,510 --> 00:45:30,070
putting in there those things has to get

00:45:28,000 --> 00:45:40,390
more mature and then we see how it will

00:45:30,070 --> 00:45:42,610
evolve yeah another question so the

00:45:40,390 --> 00:45:44,230
question is if your PC is working

00:45:42,610 --> 00:45:47,050
correctly and if it's working correctly

00:45:44,230 --> 00:45:49,510
in lagoon this was well it's not yet

00:45:47,050 --> 00:45:51,340
working in Lagoon so we are we have some

00:45:49,510 --> 00:45:53,530
experiments it's there are some people

00:45:51,340 --> 00:45:55,540
work on that but our Kochi opposites

00:45:53,530 --> 00:46:00,640
it's also very very initial phase none

00:45:55,540 --> 00:46:01,210
so it's not out yet it's out there it's

00:46:00,640 --> 00:46:03,370
open source

00:46:01,210 --> 00:46:05,680
there is version zero one but it's not I

00:46:03,370 --> 00:46:08,920
would say it's not yet production ready

00:46:05,680 --> 00:46:12,610
there are some things in Lagoon that's

00:46:08,920 --> 00:46:14,830
we still need to solve and I didn't show

00:46:12,610 --> 00:46:17,170
that because I I didn't concentrate much

00:46:14,830 --> 00:46:21,070
in service descriptor but first thing is

00:46:17,170 --> 00:46:22,870
that if you see how I generate a client

00:46:21,070 --> 00:46:24,880
and he knows where is the other service

00:46:22,870 --> 00:46:28,240
so there is behind the scene there is a

00:46:24,880 --> 00:46:30,850
service locator and and at that service

00:46:28,240 --> 00:46:35,020
locator we also have circuit breakers so

00:46:30,850 --> 00:46:37,360
if one services is down I can go it will

00:46:35,020 --> 00:46:39,970
it will close the it will open the

00:46:37,360 --> 00:46:43,450
sacred break that that is not yet

00:46:39,970 --> 00:46:45,730
therefore Akagi RPC and and that is when

00:46:43,450 --> 00:46:46,000
we bring our G RPC into log on we have

00:46:45,730 --> 00:46:47,950
to

00:46:46,000 --> 00:46:50,080
of those problems as well because I do

00:46:47,950 --> 00:46:53,200
not generate a client like I did here I

00:46:50,080 --> 00:46:56,560
will generate ERP sicklied from protobuf

00:46:53,200 --> 00:46:58,480
definitions so I have to so that part is

00:46:56,560 --> 00:47:00,510
not yet there so we have your work on

00:46:58,480 --> 00:47:00,510

YouTube URL: https://www.youtube.com/watch?v=26iiT5hOfX4


