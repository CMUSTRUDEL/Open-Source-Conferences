Title: Effective Scala by Bill Venners and Frank Sommers
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6937-effective-scala.html
Captions: 
	00:00:04,540 --> 00:00:11,500
I am bill Venters and this is Frank

00:00:07,510 --> 00:00:13,090
summers and I wanted to clarify Frank is

00:00:11,500 --> 00:00:15,360
actually not the part of the title of

00:00:13,090 --> 00:00:17,439
the typo presenter it's just

00:00:15,360 --> 00:00:19,480
unfortunately bye-bye I think I'm just

00:00:17,439 --> 00:00:21,460
gonna talk about it the reason that

00:00:19,480 --> 00:00:23,230
we're here together is because we are

00:00:21,460 --> 00:00:26,860
working on a book called effective Scala

00:00:23,230 --> 00:00:30,009
and we have not really started but

00:00:26,860 --> 00:00:32,439
that's our plan and we have works we

00:00:30,009 --> 00:00:34,270
have created a workshop and this talk so

00:00:32,439 --> 00:00:37,330
this talk is just we wanted to talk

00:00:34,270 --> 00:00:38,590
about one idea and I think the other

00:00:37,330 --> 00:00:40,060
reason we're here is because we have

00:00:38,590 --> 00:00:41,560
been working with Scala for a really

00:00:40,060 --> 00:00:43,810
long time and probably everyone knows

00:00:41,560 --> 00:00:45,550
bill because bill is the author of the

00:00:43,810 --> 00:00:47,470
Scala test framework which has been

00:00:45,550 --> 00:00:49,180
around for a very long time and we

00:00:47,470 --> 00:00:51,700
started about the same time working with

00:00:49,180 --> 00:00:54,460
Scala I would say about 2008 or so and

00:00:51,700 --> 00:00:56,079
so what I've done since then is to go on

00:00:54,460 --> 00:00:58,150
and start a company that actually uses

00:00:56,079 --> 00:01:00,730
scarlet and enterprise software setting

00:00:58,150 --> 00:01:02,829
so we have little different sort of

00:01:00,730 --> 00:01:04,989
takes on the effectiveness of using

00:01:02,829 --> 00:01:07,240
Scala and I think that that's what we're

00:01:04,989 --> 00:01:09,430
trying to talk about and so as a

00:01:07,240 --> 00:01:11,560
starting point I like to say that those

00:01:09,430 --> 00:01:13,240
who were at Martin skeino two days ago I

00:01:11,560 --> 00:01:14,770
may have me remember that Martin

00:01:13,240 --> 00:01:15,880
mentioned that Scala is really more than

00:01:14,770 --> 00:01:18,430
a language it's really a language

00:01:15,880 --> 00:01:19,720
toolkit so the language even though the

00:01:18,430 --> 00:01:21,850
language knowledge is in certain

00:01:19,720 --> 00:01:23,650
directions of programming style it

00:01:21,850 --> 00:01:26,290
really doesn't enforce a particular way

00:01:23,650 --> 00:01:28,330
and that's a great thing in many ways it

00:01:26,290 --> 00:01:31,270
gives you great flexibility but it also

00:01:28,330 --> 00:01:33,460
gives you a really wide latitude and so

00:01:31,270 --> 00:01:35,020
when you have a code base such as ours

00:01:33,460 --> 00:01:36,340
for example is probably a nine year old

00:01:35,020 --> 00:01:38,860
code base man again it's in production

00:01:36,340 --> 00:01:42,100
it's used by different companies it

00:01:38,860 --> 00:01:46,150
could be a problem if the styles in the

00:01:42,100 --> 00:01:48,040
code base really diverged so in this

00:01:46,150 --> 00:01:50,530
talk we will try to give you a few

00:01:48,040 --> 00:01:53,650
guidelines and a few pointers in terms

00:01:50,530 --> 00:01:55,479
of how to mitigate this really vile

00:01:53,650 --> 00:01:57,790
attitude that's called offers and it's

00:01:55,479 --> 00:01:59,830
based on our experience so on the one

00:01:57,790 --> 00:02:01,630
end of the spectrum you could program in

00:01:59,830 --> 00:02:04,180
Scala as if you were programming in

00:02:01,630 --> 00:02:07,150
Haskell and I think the term Martin used

00:02:04,180 --> 00:02:08,830
is so verse has gone the JVM and I think

00:02:07,150 --> 00:02:10,989
Eva made a point if I correctly remember

00:02:08,830 --> 00:02:13,989
that it's Chris column a not even though

00:02:10,989 --> 00:02:17,139
you can actually do Haskell RFP on the

00:02:13,989 --> 00:02:18,340
JVM with Scala but ska may not ask me

00:02:17,139 --> 00:02:20,650
the best basis

00:02:18,340 --> 00:02:22,330
that sort of pure FP approach on the VM

00:02:20,650 --> 00:02:23,950
however it's possible you can actually

00:02:22,330 --> 00:02:25,690
do that and the other end of the

00:02:23,950 --> 00:02:27,910
spectrum are mostly those who come to

00:02:25,690 --> 00:02:31,000
Scala for the first time typically from

00:02:27,910 --> 00:02:32,709
Java and you can obviously write Scala

00:02:31,000 --> 00:02:34,720
code as if you were writing Java code

00:02:32,709 --> 00:02:39,220
without the semicolons so you have these

00:02:34,720 --> 00:02:41,260
two extremes and what we try to say here

00:02:39,220 --> 00:02:43,660
today and even convince you hopefully is

00:02:41,260 --> 00:02:45,670
that there is a third way which we think

00:02:43,660 --> 00:02:48,459
is really this represents the sweet spot

00:02:45,670 --> 00:02:50,890
for Scala and so that's where our

00:02:48,459 --> 00:02:52,360
effective Scala guidelines will come and

00:02:50,890 --> 00:02:55,180
we'll give you free guidelines in this

00:02:52,360 --> 00:02:56,799
talk and hopefully if you apply to these

00:02:55,180 --> 00:02:58,720
these guidelines especially to new Scala

00:02:56,799 --> 00:03:01,180
projects hopefully they'll prove to be

00:02:58,720 --> 00:03:03,340
beneficial yeah and each of these are

00:03:01,180 --> 00:03:04,599
quoted because I heard Martin odrs Keys

00:03:03,340 --> 00:03:06,160
say each one of these three things he

00:03:04,599 --> 00:03:07,660
said the first two in his keynote

00:03:06,160 --> 00:03:10,150
yesterday and the third one I heard him

00:03:07,660 --> 00:03:11,709
say it in in a advisory board meeting

00:03:10,150 --> 00:03:13,120
and what we're really trying to do is is

00:03:11,709 --> 00:03:14,110
flush out what does that mean what is

00:03:13,120 --> 00:03:16,989
this Third Way

00:03:14,110 --> 00:03:21,519
that is the sort of the idiomatic way to

00:03:16,989 --> 00:03:23,650
use Scala so we do think that this Third

00:03:21,519 --> 00:03:25,090
Way is is probably the best way for most

00:03:23,650 --> 00:03:28,030
projects

00:03:25,090 --> 00:03:29,440
what better Java as Frank mentioned is I

00:03:28,030 --> 00:03:31,900
think really good for is if you're just

00:03:29,440 --> 00:03:34,209
starting out in Scala and you're coming

00:03:31,900 --> 00:03:36,220
from some imperative language like Java

00:03:34,209 --> 00:03:38,019
it's fine to just program in the way you

00:03:36,220 --> 00:03:40,239
know and get things done and over time

00:03:38,019 --> 00:03:42,340
you'll learn more idiomatic ways to do

00:03:40,239 --> 00:03:47,829
things in Scala more functional ways and

00:03:42,340 --> 00:03:50,200
I have seen the Haskell on the JVM way

00:03:47,829 --> 00:03:53,079
work also in practice in actual

00:03:50,200 --> 00:03:56,470
companies doing that but what was always

00:03:53,079 --> 00:03:59,440
in it always was the situation is there

00:03:56,470 --> 00:04:01,690
was a leader on top who knew you know

00:03:59,440 --> 00:04:03,190
what parts of that they think made sense

00:04:01,690 --> 00:04:05,829
and they made sure everybody on the team

00:04:03,190 --> 00:04:07,959
understood you know what these concepts

00:04:05,829 --> 00:04:09,370
are and we're kind of going in the same

00:04:07,959 --> 00:04:12,669
direction and they maintain consistency

00:04:09,370 --> 00:04:14,859
across the project what I have seen many

00:04:12,669 --> 00:04:17,320
times is that most people on a project

00:04:14,859 --> 00:04:20,950
will be doing this sort of idiomatic

00:04:17,320 --> 00:04:23,349
Scala functional but not Haskell way of

00:04:20,950 --> 00:04:25,030
writing code and then there's a few

00:04:23,349 --> 00:04:28,000
people who are passionate about Haskell

00:04:25,030 --> 00:04:29,500
off to the side doing more that

00:04:28,000 --> 00:04:31,419
direction and then the rest of the team

00:04:29,500 --> 00:04:32,120
can't understand the code so one of the

00:04:31,419 --> 00:04:34,250
things we think is

00:04:32,120 --> 00:04:38,720
important is that management like when

00:04:34,250 --> 00:04:41,479
you're managing the project that you you

00:04:38,720 --> 00:04:43,430
kind of make sure that you you watch the

00:04:41,479 --> 00:04:45,410
consistency because Scala is unopp Enya

00:04:43,430 --> 00:04:47,510
nated the code base can be all over the

00:04:45,410 --> 00:04:48,860
place and it's great that the community

00:04:47,510 --> 00:04:50,210
is all over the place that's very

00:04:48,860 --> 00:04:51,290
interesting and that what's that's one

00:04:50,210 --> 00:04:53,630
of the things that makes our community

00:04:51,290 --> 00:04:56,300
great but in us in a specific project

00:04:53,630 --> 00:04:59,330
it's good to have kind of one style that

00:04:56,300 --> 00:05:00,860
the whole team is its following yeah and

00:04:59,330 --> 00:05:03,080
that segues into our first guideline

00:05:00,860 --> 00:05:04,610
which basically is very simple when you

00:05:03,080 --> 00:05:06,979
start a scholar project it's pretty

00:05:04,610 --> 00:05:08,690
important to pick an opinion a form an

00:05:06,979 --> 00:05:10,460
opinion about how you want things to

00:05:08,690 --> 00:05:11,960
look like in your codebase and you

00:05:10,460 --> 00:05:13,880
you're free to pick whatever opinion you

00:05:11,960 --> 00:05:15,830
like if you like to do the FP approach

00:05:13,880 --> 00:05:18,139
that's great if you like to do the more

00:05:15,830 --> 00:05:20,030
Java like imperative approach maybe

00:05:18,139 --> 00:05:22,010
that's okay - I think Scala lets you do

00:05:20,030 --> 00:05:24,020
that but in my experience what is

00:05:22,010 --> 00:05:25,820
important is to pick one opinion or what

00:05:24,020 --> 00:05:27,889
point of view and stick with that

00:05:25,820 --> 00:05:29,479
throughout the project at least as long

00:05:27,889 --> 00:05:32,150
as you can because it will keep your

00:05:29,479 --> 00:05:35,300
codebase consistent relatively across

00:05:32,150 --> 00:05:37,970
time and also cross teams so a new team

00:05:35,300 --> 00:05:39,830
members join your a project they will be

00:05:37,970 --> 00:05:41,389
able to adhere and follow that style

00:05:39,830 --> 00:05:42,800
even though they may not say like it but

00:05:41,389 --> 00:05:45,740
they would follow it and I think that's

00:05:42,800 --> 00:05:48,740
quite a good way to work with a Scala

00:05:45,740 --> 00:05:50,630
code base over years and and teams and

00:05:48,740 --> 00:05:52,700
time right so Scala as a language is

00:05:50,630 --> 00:05:55,190
unopp in United but your project should

00:05:52,700 --> 00:05:57,380
be opinionated essentially so we wanted

00:05:55,190 --> 00:05:59,990
to give you an example of a way where I

00:05:57,380 --> 00:06:01,310
think Scala as a language maybe not so

00:05:59,990 --> 00:06:07,099
much the library but as the language

00:06:01,310 --> 00:06:09,440
itself it's very unemotional so and that

00:06:07,099 --> 00:06:12,410
is that there this is a comes from Jamie

00:06:09,440 --> 00:06:15,680
Allen he called it the mutability matrix

00:06:12,410 --> 00:06:17,599
of pain and I thought that was a little

00:06:15,680 --> 00:06:19,490
negative it's not really good marketing

00:06:17,599 --> 00:06:22,449
for Scala so I read rebranded the

00:06:19,490 --> 00:06:24,470
immutability matrix of pleasure but

00:06:22,449 --> 00:06:26,810
essentially Scala gives you these four

00:06:24,470 --> 00:06:30,169
choices there's two kinds of variables

00:06:26,810 --> 00:06:31,370
vowels and VARs bells are you can

00:06:30,169 --> 00:06:33,260
initialize them but you can't change

00:06:31,370 --> 00:06:34,849
what they prefer to var as you can keep

00:06:33,260 --> 00:06:36,440
reassigning them so they can change it

00:06:34,849 --> 00:06:40,310
refer to a different object over time

00:06:36,440 --> 00:06:41,870
and immutable objects can't be changed

00:06:40,310 --> 00:06:44,000
after they're initialized the the

00:06:41,870 --> 00:06:45,409
contents can't but mutable objects can

00:06:44,000 --> 00:06:45,770
change state over time so they're much

00:06:45,409 --> 00:06:47,990
more

00:06:45,770 --> 00:06:49,430
but you can have a vowel refer to

00:06:47,990 --> 00:06:51,349
immutable you can have a Val refer to an

00:06:49,430 --> 00:06:52,940
immutable you can have a you know

00:06:51,349 --> 00:06:57,770
basically any combination of these two

00:06:52,940 --> 00:06:59,840
four so what do you think would be I'm

00:06:57,770 --> 00:07:01,430
just gonna let you think in your head so

00:06:59,840 --> 00:07:03,979
you you don't embarrass yourself and

00:07:01,430 --> 00:07:07,220
vote for the wrong one which one do you

00:07:03,979 --> 00:07:09,710
think is the happiest quadrant just pick

00:07:07,220 --> 00:07:12,349
one and then Frank what do you think

00:07:09,710 --> 00:07:14,210
well which one is the most boring is

00:07:12,349 --> 00:07:15,770
also the healthiest because I think in

00:07:14,210 --> 00:07:17,229
that that's quadrant there like it's

00:07:15,770 --> 00:07:19,490
it's basically a pure immutability

00:07:17,229 --> 00:07:22,880
nothing happens it's a it's an immutable

00:07:19,490 --> 00:07:25,250
data structure and it of eval points to

00:07:22,880 --> 00:07:26,870
this data structure so but but that that

00:07:25,250 --> 00:07:28,970
does give you though is the ability to

00:07:26,870 --> 00:07:31,370
reason about your code so this is a

00:07:28,970 --> 00:07:33,800
perfect example where FP the FP approach

00:07:31,370 --> 00:07:35,720
truly shines if you can stay in that

00:07:33,800 --> 00:07:41,030
quadrant then I think you'll be happy

00:07:35,720 --> 00:07:42,500
over time so what what is number two so

00:07:41,030 --> 00:07:43,550
that's number one what do you think you

00:07:42,500 --> 00:07:46,370
can just think in your head what do you

00:07:43,550 --> 00:07:48,469
think is number two this is a little

00:07:46,370 --> 00:07:52,099
trickier so we're gonna we're gonna take

00:07:48,469 --> 00:07:54,289
a choose one and it is this one so this

00:07:52,099 --> 00:07:57,979
is not quite as happy and the reason we

00:07:54,289 --> 00:08:00,409
pick that is number two is because it's

00:07:57,979 --> 00:08:01,009
easy to close over objects and send them

00:08:00,409 --> 00:08:03,349
somewhere else

00:08:01,009 --> 00:08:04,279
and if it's an immutable object and you

00:08:03,349 --> 00:08:06,440
send it somewhere else where there's

00:08:04,279 --> 00:08:08,360
multiple threads hitting it then you've

00:08:06,440 --> 00:08:10,219
just got a concurrency bug in your

00:08:08,360 --> 00:08:12,620
program so it's a it's just a little bit

00:08:10,219 --> 00:08:14,210
safer to have immutable objects in

00:08:12,620 --> 00:08:16,490
memory that you're holding to from bars

00:08:14,210 --> 00:08:18,740
and you're replacing them replacing the

00:08:16,490 --> 00:08:20,240
the you know reassigning the VAR at a

00:08:18,740 --> 00:08:22,729
point to a different immune immutable

00:08:20,240 --> 00:08:24,110
object okay I think the next one is a

00:08:22,729 --> 00:08:26,990
pretty easy one I don't think we don't

00:08:24,110 --> 00:08:28,729
have to take a poll but this is the next

00:08:26,990 --> 00:08:30,229
quarter on that so if you cannot stay in

00:08:28,729 --> 00:08:32,959
one or the other then this would be the

00:08:30,229 --> 00:08:35,060
third place to be at possibly so why

00:08:32,959 --> 00:08:35,899
would you want to do this well most of

00:08:35,060 --> 00:08:38,029
the time you would do this for

00:08:35,899 --> 00:08:40,579
performance and the fact is that some

00:08:38,029 --> 00:08:41,839
algorithms are just basically faster to

00:08:40,579 --> 00:08:43,640
implement in with a mutable data

00:08:41,839 --> 00:08:46,100
structure and they show you examinee

00:08:43,640 --> 00:08:48,110
examples of that but this would be the

00:08:46,100 --> 00:08:49,970
third place to stay so it's a vowel it's

00:08:48,110 --> 00:08:51,350
pointing to a mutable data structure and

00:08:49,970 --> 00:08:53,300
again Scala lets you do that there's

00:08:51,350 --> 00:08:56,000
just a very simple thing it's got to be

00:08:53,300 --> 00:08:58,010
and then the last one is is interesting

00:08:56,000 --> 00:08:59,360
because in Scala I don't know that I've

00:08:58,010 --> 00:09:00,680
ever used that and I don't

00:08:59,360 --> 00:09:02,980
I've ever seen that and I just don't

00:09:00,680 --> 00:09:06,769
think that that combo is necessary and

00:09:02,980 --> 00:09:08,630
what is what you know I think two and

00:09:06,769 --> 00:09:10,220
three are pretty close to each other so

00:09:08,630 --> 00:09:15,050
those guys are actually pretty close to

00:09:10,220 --> 00:09:17,750
each other but the fourth one is just

00:09:15,050 --> 00:09:18,709
not really useful in Scala but what's

00:09:17,750 --> 00:09:21,880
interesting about I think it illustrates

00:09:18,709 --> 00:09:25,730
two things one is that that Scala does

00:09:21,880 --> 00:09:27,230
have an opinion not the language per se

00:09:25,730 --> 00:09:30,860
because in the language it's just as

00:09:27,230 --> 00:09:32,570
easy to say Val something equals mutable

00:09:30,860 --> 00:09:34,250
Ovar something equals mutable in mode

00:09:32,570 --> 00:09:38,180
doesn't really guide you in one

00:09:34,250 --> 00:09:40,160
direction or another but Java does Java

00:09:38,180 --> 00:09:41,329
says that the lower right-hand corner is

00:09:40,160 --> 00:09:43,370
the normal way of doing things and

00:09:41,329 --> 00:09:45,350
normal variables are not final right

00:09:43,370 --> 00:09:49,250
there like a VAR normal objects are

00:09:45,350 --> 00:09:51,110
mutable so like Java C++ C sharp Ruby

00:09:49,250 --> 00:09:52,760
Python all these languages that sort of

00:09:51,110 --> 00:09:57,740
were mainstream languages preceding

00:09:52,760 --> 00:10:00,350
Scala have a different attitude and so

00:09:57,740 --> 00:10:02,540
scholar is trying to suggest there's a

00:10:00,350 --> 00:10:04,790
better way to program the other thing it

00:10:02,540 --> 00:10:06,440
illustrates I think is just that the

00:10:04,790 --> 00:10:09,079
language is unopp Enya nated but we

00:10:06,440 --> 00:10:10,670
should be opinionated so something to

00:10:09,079 --> 00:10:12,380
take away from this is that when you

00:10:10,670 --> 00:10:14,240
approach a coterie of code reviews it's

00:10:12,380 --> 00:10:16,310
good to pick one approach that you like

00:10:14,240 --> 00:10:18,290
to take and maybe it could be that left

00:10:16,310 --> 00:10:20,449
top quadrant or whatever quadrant but

00:10:18,290 --> 00:10:22,640
regardless you should think about this

00:10:20,449 --> 00:10:25,339
it's very important and so our second

00:10:22,640 --> 00:10:29,329
guideline is that Scala of course gives

00:10:25,339 --> 00:10:31,640
you a lots of FP and lots of Oh tools in

00:10:29,329 --> 00:10:33,260
their tool set and that will all let you

00:10:31,640 --> 00:10:35,180
have manage complexity especially as

00:10:33,260 --> 00:10:37,370
your code base grows so it's really

00:10:35,180 --> 00:10:39,290
important to know which particular parts

00:10:37,370 --> 00:10:42,380
of FP and which particular parts of Oh

00:10:39,290 --> 00:10:44,269
we'll help you so you realize we didn't

00:10:42,380 --> 00:10:45,529
define that fps functional programming

00:10:44,269 --> 00:10:47,480
probably most everyone knows that but

00:10:45,529 --> 00:10:49,310
just in case Oh Obi is object-oriented

00:10:47,480 --> 00:10:51,589
programming so that bet is like the

00:10:49,310 --> 00:10:53,660
skull is is is a blend of those two

00:10:51,589 --> 00:10:55,310
things that's the point of it so this is

00:10:53,660 --> 00:10:56,959
our second guideline just to think about

00:10:55,310 --> 00:10:59,660
it consciously before you start a

00:10:56,959 --> 00:11:02,600
project and and and then make decisions

00:10:59,660 --> 00:11:04,579
about which parts to use in your project

00:11:02,600 --> 00:11:08,149
right so what we want to do is show you

00:11:04,579 --> 00:11:09,920
some specific ways that FP and opie help

00:11:08,149 --> 00:11:12,920
you manage complexity so and this is as

00:11:09,920 --> 00:11:16,399
code bases grow large not when it's

00:11:12,920 --> 00:11:19,389
all right so the main way that FB helps

00:11:16,399 --> 00:11:21,769
you manage complexity is FP is

00:11:19,389 --> 00:11:23,120
encourages pure functions a pure

00:11:21,769 --> 00:11:25,430
function is something that just takes

00:11:23,120 --> 00:11:27,529
its input and does some number crunching

00:11:25,430 --> 00:11:29,149
or whatever and returns a result without

00:11:27,529 --> 00:11:30,860
having any other effect off to the side

00:11:29,149 --> 00:11:36,649
that isn't sort of embodied in that

00:11:30,860 --> 00:11:38,209
result and reference transparency is

00:11:36,649 --> 00:11:40,250
what you get when you have pure

00:11:38,209 --> 00:11:44,120
functions referential transparency means

00:11:40,250 --> 00:11:45,709
that I can take an invocation of a

00:11:44,120 --> 00:11:47,240
function where you pass in particular

00:11:45,709 --> 00:11:49,130
data and just replace that whole thing

00:11:47,240 --> 00:11:52,100
with the result because every time you

00:11:49,130 --> 00:11:53,329
pass the same same input to a pure

00:11:52,100 --> 00:11:54,560
function it will always give you the

00:11:53,329 --> 00:11:56,420
same result so it doesn't matter where

00:11:54,560 --> 00:11:58,579
you call it again you can just plug in

00:11:56,420 --> 00:12:01,970
the replacement and what that actually

00:11:58,579 --> 00:12:03,079
lets you do is it's composable what that

00:12:01,970 --> 00:12:06,199
gives you is composability

00:12:03,079 --> 00:12:08,510
and and you can compose more pure

00:12:06,199 --> 00:12:10,220
functions out of out of existing peer

00:12:08,510 --> 00:12:11,839
functions and then then create other

00:12:10,220 --> 00:12:14,000
pure functions out of that you can have

00:12:11,839 --> 00:12:15,709
this big tree of function calls but at

00:12:14,000 --> 00:12:17,209
the top it's still pure you pass in

00:12:15,709 --> 00:12:18,649
maybe a big complicated data structure

00:12:17,209 --> 00:12:20,630
and you get back maybe a big complicated

00:12:18,649 --> 00:12:22,250
data structure this is doing a lot of

00:12:20,630 --> 00:12:24,490
stuff but there's nothing else off to

00:12:22,250 --> 00:12:27,110
the side that you have to keep track of

00:12:24,490 --> 00:12:28,850
so we want to give you some examples of

00:12:27,110 --> 00:12:31,190
where that I mean that's always been the

00:12:28,850 --> 00:12:32,839
claim we want to give you some examples

00:12:31,190 --> 00:12:34,730
of where that that sort of support that

00:12:32,839 --> 00:12:37,399
theory that that helps you reason about

00:12:34,730 --> 00:12:39,380
code but we wanted to first say that it

00:12:37,399 --> 00:12:41,630
actually isn't it doesn't mean that you

00:12:39,380 --> 00:12:43,670
can't reason about imperative code or

00:12:41,630 --> 00:12:45,920
impure code because you can in the small

00:12:43,670 --> 00:12:48,589
so in this small it's perfectly easy to

00:12:45,920 --> 00:12:50,360
reason about imperative code or impure

00:12:48,589 --> 00:12:52,459
code and so an example that we have here

00:12:50,360 --> 00:12:55,040
on the screen is this is what how lists

00:12:52,459 --> 00:12:57,620
exists method is implemented it's got a

00:12:55,040 --> 00:12:59,149
VAR it's got a while loop it reassigns

00:12:57,620 --> 00:13:00,500
the bar in the middle of it but it's

00:12:59,149 --> 00:13:02,240
small enough that you can look at that

00:13:00,500 --> 00:13:05,149
and figure it out you can understand it

00:13:02,240 --> 00:13:07,339
and it it also doesn't return a mutable

00:13:05,149 --> 00:13:09,740
object it returns an immutable object

00:13:07,339 --> 00:13:13,459
which in this case is a boolean so from

00:13:09,740 --> 00:13:15,620
the outside it appears it is pure it

00:13:13,459 --> 00:13:18,860
always it's it always returns the same

00:13:15,620 --> 00:13:21,260
result given the same input so you still

00:13:18,860 --> 00:13:23,390
have the benefit of of referential

00:13:21,260 --> 00:13:25,279
transparency on the outside and they on

00:13:23,390 --> 00:13:26,230
the inside it's small enough that you

00:13:25,279 --> 00:13:28,550
can understand

00:13:26,230 --> 00:13:31,040
yeah but that doesn't really hold of

00:13:28,550 --> 00:13:32,570
course when you are programming large so

00:13:31,040 --> 00:13:34,070
this is an interesting example most

00:13:32,570 --> 00:13:35,330
people think that garbage collection of

00:13:34,070 --> 00:13:38,390
course is a wonderful thing which it

00:13:35,330 --> 00:13:40,160
actually is but I think that bill was

00:13:38,390 --> 00:13:42,410
mentioning this to me some a few years

00:13:40,160 --> 00:13:44,570
ago that when you if you guys remember

00:13:42,410 --> 00:13:46,940
programming and see back in the days

00:13:44,570 --> 00:13:53,750
they're probably too young but I think a

00:13:46,940 --> 00:13:55,580
lot of people say see basically what you

00:13:53,750 --> 00:13:57,980
had to variably most about really is

00:13:55,580 --> 00:13:59,930
managing memory imagine the heap so you

00:13:57,980 --> 00:14:02,240
could think about that as a large-scale

00:13:59,930 --> 00:14:04,550
problem of mutable state if you think of

00:14:02,240 --> 00:14:06,800
the heap is a mutable state basically

00:14:04,550 --> 00:14:08,510
then without automatic garbage

00:14:06,800 --> 00:14:11,780
collection it's really the programmers

00:14:08,510 --> 00:14:14,450
job to manage how that heap is used and

00:14:11,780 --> 00:14:16,010
so you know if you make a mistake there

00:14:14,450 --> 00:14:17,660
is gonna be a big issue there a big

00:14:16,010 --> 00:14:20,960
problem the program will probably crash

00:14:17,660 --> 00:14:22,760
eventually or immediately so here I mean

00:14:20,960 --> 00:14:24,410
it's an example here you would allocate

00:14:22,760 --> 00:14:26,120
four bytes of memory for example on the

00:14:24,410 --> 00:14:27,800
heap and then the next step you may

00:14:26,120 --> 00:14:29,690
allocate another two bytes and another

00:14:27,800 --> 00:14:32,390
fee buys and then afterwards you're free

00:14:29,690 --> 00:14:34,670
two bytes and so now we somehow or other

00:14:32,390 --> 00:14:36,890
you have to keep track of the mutation

00:14:34,670 --> 00:14:38,780
of the state and you know there are

00:14:36,890 --> 00:14:41,300
various tools of doing this but this is

00:14:38,780 --> 00:14:42,440
a big problem and so I think this is an

00:14:41,300 --> 00:14:44,800
interesting perhaps an interesting

00:14:42,440 --> 00:14:47,300
illustration of of how it's difficult

00:14:44,800 --> 00:14:50,150
even though mutable state in the small

00:14:47,300 --> 00:14:52,760
is actually kind of ok but in the large

00:14:50,150 --> 00:14:54,370
it is very very error-prone this is one

00:14:52,760 --> 00:14:56,900
reason that the industry actually

00:14:54,370 --> 00:14:58,100
adopted automatic garbage collection if

00:14:56,900 --> 00:14:59,750
in this example I think you could

00:14:58,100 --> 00:15:01,580
remember that we already released P 2

00:14:59,750 --> 00:15:04,190
all right and that you won't release it

00:15:01,580 --> 00:15:06,080
again but what so in small examples you

00:15:04,190 --> 00:15:07,940
can get it right but what the inside I

00:15:06,080 --> 00:15:09,410
had like many years later after have

00:15:07,940 --> 00:15:11,720
spending a lot of time struggling with

00:15:09,410 --> 00:15:13,400
memory errors and see is that the reason

00:15:11,720 --> 00:15:14,930
it was hard to do get this right is

00:15:13,400 --> 00:15:16,670
because that's a mutable data structure

00:15:14,930 --> 00:15:18,230
and the side effects you're mutating

00:15:16,670 --> 00:15:19,880
each time you allocate malloc and free

00:15:18,230 --> 00:15:21,110
and you just have to remember you have

00:15:19,880 --> 00:15:23,900
to keep track of those side effects in

00:15:21,110 --> 00:15:25,850
your head so another example that I

00:15:23,900 --> 00:15:28,040
think illustrates this this problem of

00:15:25,850 --> 00:15:30,650
in the large how it's hard to reason

00:15:28,040 --> 00:15:32,420
about side-effects is synchronized

00:15:30,650 --> 00:15:34,870
access to shared mutable state we all

00:15:32,420 --> 00:15:37,250
kind of probably agree that's hard to do

00:15:34,870 --> 00:15:39,300
and the reason is is another inside I

00:15:37,250 --> 00:15:40,950
had after I had

00:15:39,300 --> 00:15:43,019
realize and had experience that this was

00:15:40,950 --> 00:15:44,550
hard to do is that this thing is a

00:15:43,019 --> 00:15:46,350
mutable data structure so this is a

00:15:44,550 --> 00:15:48,450
javis monitor that's associated

00:15:46,350 --> 00:15:51,029
logically with every object and if you

00:15:48,450 --> 00:15:52,440
hit a synchronized method if a thread

00:15:51,029 --> 00:15:56,160
hits a synchronized method then this

00:15:52,440 --> 00:15:57,720
data structure will come into being and

00:15:56,160 --> 00:16:00,360
what each of these circles is is a

00:15:57,720 --> 00:16:02,010
thread right so if a thread is executing

00:16:00,360 --> 00:16:04,980
along and hits a synchronized method

00:16:02,010 --> 00:16:06,930
what it does is it enters the entry set

00:16:04,980 --> 00:16:09,230
of the monitor which is like an entry

00:16:06,930 --> 00:16:11,670
room it comes in the left side and it

00:16:09,230 --> 00:16:13,500
that is a mutation of this data

00:16:11,670 --> 00:16:15,690
structure of this mutable data structure

00:16:13,500 --> 00:16:16,950
and then if there's nobody in the middle

00:16:15,690 --> 00:16:19,140
room the middle room is special can only

00:16:16,950 --> 00:16:21,300
have one thread in it then it moves in

00:16:19,140 --> 00:16:23,459
and acquires the lock right and so now

00:16:21,300 --> 00:16:26,160
it's it's owns the monitor that was a

00:16:23,459 --> 00:16:28,290
mutation it's a second mutation if it

00:16:26,160 --> 00:16:30,209
returns or exits with an exception

00:16:28,290 --> 00:16:31,800
either way it will go down at the bottom

00:16:30,209 --> 00:16:34,890
and it releases a lock at that point

00:16:31,800 --> 00:16:36,870
that's the mutation and at that point

00:16:34,890 --> 00:16:38,670
you know other threads may compete to

00:16:36,870 --> 00:16:40,709
get in there if somebody calls dot wait

00:16:38,670 --> 00:16:42,990
on the inside that goes over to this

00:16:40,709 --> 00:16:45,450
back room which is the weight set and

00:16:42,990 --> 00:16:48,000
there's two kind of subcategories over

00:16:45,450 --> 00:16:49,680
there there's you can be waiting to be

00:16:48,000 --> 00:16:51,510
notified and once someone comes in here

00:16:49,680 --> 00:16:51,810
and calls notify you go from orange to

00:16:51,510 --> 00:16:55,380
green

00:16:51,810 --> 00:16:56,880
that's a mutation when this blue guy

00:16:55,380 --> 00:16:58,320
exits the greens and the yellows will

00:16:56,880 --> 00:16:59,820
compete to get in when one of them gets

00:16:58,320 --> 00:17:01,589
in that's a mutation right so it's

00:16:59,820 --> 00:17:04,439
mutation mutation mutation mutation and

00:17:01,589 --> 00:17:05,880
it's all over your code and it's just

00:17:04,439 --> 00:17:07,770
really hard and you know in a small

00:17:05,880 --> 00:17:09,870
example you can get it right but in a

00:17:07,770 --> 00:17:10,919
big one it's very difficult because the

00:17:09,870 --> 00:17:13,380
side effects are hard to reason about

00:17:10,919 --> 00:17:14,970
and things can get large pretty fast so

00:17:13,380 --> 00:17:16,319
I think that the gain in a small but

00:17:14,970 --> 00:17:17,790
what works in a small does necessarily

00:17:16,319 --> 00:17:19,140
scale up in the large because that's a

00:17:17,790 --> 00:17:20,970
referential chance except for

00:17:19,140 --> 00:17:22,829
referential transparency so that's so

00:17:20,970 --> 00:17:24,540
that what makes really FB really so

00:17:22,829 --> 00:17:26,850
wonderful in Scala that you can manage

00:17:24,540 --> 00:17:28,950
this type of complexity as your program

00:17:26,850 --> 00:17:30,720
grows so do use those techniques that

00:17:28,950 --> 00:17:32,850
really helped you do that however

00:17:30,720 --> 00:17:35,480
object-oriented programming also for

00:17:32,850 --> 00:17:37,350
many decades was also aiming at solving

00:17:35,480 --> 00:17:39,960
complexity of your code and your

00:17:37,350 --> 00:17:41,460
problems so it would not be very nice to

00:17:39,960 --> 00:17:44,130
just throw out those features of Scala

00:17:41,460 --> 00:17:47,100
rather we should think of what aspects

00:17:44,130 --> 00:17:49,200
of Oh help you manage complexity clearly

00:17:47,100 --> 00:17:51,210
not all aspects of object reprogram will

00:17:49,200 --> 00:17:53,520
be helpful for Scala programs or even

00:17:51,210 --> 00:17:55,500
effective because they just may just

00:17:53,520 --> 00:17:58,500
fit with this FP approach at the same

00:17:55,500 --> 00:18:00,480
time but but many things do so for

00:17:58,500 --> 00:18:02,580
instance object or any programming often

00:18:00,480 --> 00:18:04,470
puts data close that the operations from

00:18:02,580 --> 00:18:06,990
the data close to where the data is

00:18:04,470 --> 00:18:09,000
defined that and when you do

00:18:06,990 --> 00:18:11,430
object-oriented analysis of a large

00:18:09,000 --> 00:18:13,650
problem like a business domain you often

00:18:11,430 --> 00:18:16,340
use class names and method names that

00:18:13,650 --> 00:18:20,130
are naturally expressing that domain and

00:18:16,340 --> 00:18:22,410
whereas FP gives you a lot of understand

00:18:20,130 --> 00:18:24,510
ability or reason about ability of the

00:18:22,410 --> 00:18:26,700
code object oriented programming and

00:18:24,510 --> 00:18:29,190
especially if it's done well gives you

00:18:26,700 --> 00:18:30,870
accessibility of your code base because

00:18:29,190 --> 00:18:32,430
if a developer comes and looks at your

00:18:30,870 --> 00:18:35,220
at your code working on a certain domain

00:18:32,430 --> 00:18:37,770
those classes and those especially if

00:18:35,220 --> 00:18:39,840
it's a game well designed will give that

00:18:37,770 --> 00:18:43,560
developer easy access to what the code

00:18:39,840 --> 00:18:45,780
does it expresses your domain so that is

00:18:43,560 --> 00:18:48,030
one benefit of opie that you could

00:18:45,780 --> 00:18:50,010
definitely use in scala 10 years and

00:18:48,030 --> 00:18:52,260
this is an example of a piece of code

00:18:50,010 --> 00:18:54,810
that if even if you've never seen this

00:18:52,260 --> 00:18:56,700
you instantly can use this code you know

00:18:54,810 --> 00:18:59,220
what it does it's obviously a class of a

00:18:56,700 --> 00:19:00,800
map and you see their de noms

00:18:59,220 --> 00:19:03,270
which are essentially class names

00:19:00,800 --> 00:19:04,800
express the domain so you have a lot

00:19:03,270 --> 00:19:06,660
each you longitude you have a street

00:19:04,800 --> 00:19:08,730
view panorama and so forth you don't

00:19:06,660 --> 00:19:10,290
have to dwell into the code in great

00:19:08,730 --> 00:19:11,880
detail like if you have a team for

00:19:10,290 --> 00:19:14,280
example if somebody were to work with

00:19:11,880 --> 00:19:15,810
this code pretty much instantly this

00:19:14,280 --> 00:19:18,210
person will be able to use it this

00:19:15,810 --> 00:19:22,260
actually happens to be a s ecology as

00:19:18,210 --> 00:19:24,270
facade over the Google Maps API but this

00:19:22,260 --> 00:19:26,310
is just an example of something that's

00:19:24,270 --> 00:19:28,740
extremely natural II know you have

00:19:26,310 --> 00:19:30,420
methods on an object yeah and the data

00:19:28,740 --> 00:19:32,850
now I also have to mention though that

00:19:30,420 --> 00:19:34,140
state inside an object doesn't mean

00:19:32,850 --> 00:19:36,720
mutable state in object-oriented

00:19:34,140 --> 00:19:38,340
programming in fact especially this is

00:19:36,720 --> 00:19:40,710
an interesting example because in user

00:19:38,340 --> 00:19:42,660
interfaces nowadays the trend is to get

00:19:40,710 --> 00:19:45,240
rid of mutable state in the in the user

00:19:42,660 --> 00:19:47,460
interface however if you program in

00:19:45,240 --> 00:19:48,750
react that's an example of what they're

00:19:47,460 --> 00:19:51,210
trying to do there which is a really

00:19:48,750 --> 00:19:53,010
really good approach but so state inside

00:19:51,210 --> 00:19:55,350
an object it's a good thing most likely

00:19:53,010 --> 00:19:59,490
in many cases but mutable state may or

00:19:55,350 --> 00:20:03,570
may not a good thing yeah sorry yeah in

00:19:59,490 --> 00:20:05,700
here ok I'm just going to just to say

00:20:03,570 --> 00:20:08,020
that you

00:20:05,700 --> 00:20:10,150
functional pure functional programs that

00:20:08,020 --> 00:20:12,370
just have data structures and functions

00:20:10,150 --> 00:20:14,049
they have names and they can be nouns

00:20:12,370 --> 00:20:15,340
and verbs what we're trying to say here

00:20:14,049 --> 00:20:16,929
is that when you when you bring these

00:20:15,340 --> 00:20:19,750
two together and you make a class that

00:20:16,929 --> 00:20:21,760
combines nouns like I'm sorry state the

00:20:19,750 --> 00:20:25,419
data structure with the methods that

00:20:21,760 --> 00:20:27,340
that actually helps people because think

00:20:25,419 --> 00:20:29,590
about their code and when it maps to the

00:20:27,340 --> 00:20:31,030
domain like like a street view panorama

00:20:29,590 --> 00:20:33,100
you could already guess what that

00:20:31,030 --> 00:20:38,289
probably means so that that's our that's

00:20:33,100 --> 00:20:40,120
our claim there and then the if you do

00:20:38,289 --> 00:20:42,130
have Jeb mutable state then it turns out

00:20:40,120 --> 00:20:43,360
that that one that is encapsulation is

00:20:42,130 --> 00:20:45,640
really one of the main tenets of

00:20:43,360 --> 00:20:47,500
objective programming right so even if

00:20:45,640 --> 00:20:49,210
you do have to do the mutable state then

00:20:47,500 --> 00:20:51,039
it turns out that objects actually are a

00:20:49,210 --> 00:20:52,960
pretty good way of doing that you can

00:20:51,039 --> 00:20:55,240
encapsulate state inside an object and

00:20:52,960 --> 00:20:57,400
you can define an interface that object

00:20:55,240 --> 00:21:00,520
in such a way that when you mutate the

00:20:57,400 --> 00:21:02,679
state that is quite well-defined and

00:21:00,520 --> 00:21:04,809
it's understandable so again it's it is

00:21:02,679 --> 00:21:06,490
it's a good tool and object to any

00:21:04,809 --> 00:21:08,320
programming team capsulate state and

00:21:06,490 --> 00:21:10,900
objects you shouldn't from that the

00:21:08,320 --> 00:21:13,150
alternative is is global mutable state

00:21:10,900 --> 00:21:14,530
and so global miu say if that gets

00:21:13,150 --> 00:21:16,480
corrupted it could be anywhere in your

00:21:14,530 --> 00:21:18,730
entire code base that caused it whereas

00:21:16,480 --> 00:21:21,250
the capsulation does is if you know if

00:21:18,730 --> 00:21:23,770
the only only methods only behavior they

00:21:21,250 --> 00:21:25,390
can touch that mutable state is the

00:21:23,770 --> 00:21:27,700
functions on that the member functions

00:21:25,390 --> 00:21:30,100
or the methods on that class then that

00:21:27,700 --> 00:21:33,250
really narrows you know the problem so

00:21:30,100 --> 00:21:34,870
it is if you want mutable state yah-hoo

00:21:33,250 --> 00:21:36,760
is a great way to deal with it and

00:21:34,870 --> 00:21:38,110
sometimes mutable state is useful we

00:21:36,760 --> 00:21:39,520
should admit that even though some

00:21:38,110 --> 00:21:41,260
people may like to say that we should

00:21:39,520 --> 00:21:43,630
well have any readable state but I think

00:21:41,260 --> 00:21:46,179
that's what Stella says so we think that

00:21:43,630 --> 00:21:48,039
that's what yeah so here's an example we

00:21:46,179 --> 00:21:50,049
want to like give you an example of

00:21:48,039 --> 00:21:53,289
where we think it is useful to use

00:21:50,049 --> 00:21:56,919
middle state and that is for sometimes a

00:21:53,289 --> 00:21:58,600
mutable algorithm is the fastest so an

00:21:56,919 --> 00:22:01,179
example is string concatenation there's

00:21:58,600 --> 00:22:02,710
a make string method on list and it's

00:22:01,179 --> 00:22:04,120
implemented this way they create a

00:22:02,710 --> 00:22:06,280
string builder they don't but what does

00:22:04,120 --> 00:22:08,409
make string has to do it gets a a start

00:22:06,280 --> 00:22:10,330
string a separator and an end string and

00:22:08,409 --> 00:22:12,700
what it's supposed to do is return a

00:22:10,330 --> 00:22:14,440
string that starts with a start string

00:22:12,700 --> 00:22:16,120
ends with the in string and that has the

00:22:14,440 --> 00:22:18,250
two string of each element in the list

00:22:16,120 --> 00:22:19,309
separated by step right that's what it's

00:22:18,250 --> 00:22:20,749
supposed to do so you can

00:22:19,309 --> 00:22:22,639
do that functionally by just

00:22:20,749 --> 00:22:24,289
concatenating strings and each time you

00:22:22,639 --> 00:22:25,580
do one of those processes you create a

00:22:24,289 --> 00:22:27,590
new string and throw away the old one

00:22:25,580 --> 00:22:28,999
but it's more efficient to use string

00:22:27,590 --> 00:22:31,730
builder and everybody always does that

00:22:28,999 --> 00:22:34,159
because it's faster it's and and so what

00:22:31,730 --> 00:22:36,049
this guy does is it actually use a met

00:22:34,159 --> 00:22:38,299
another method on list called add string

00:22:36,049 --> 00:22:39,889
which takes a string builder that could

00:22:38,299 --> 00:22:41,659
be non empty but in this case we create

00:22:39,889 --> 00:22:43,879
a new one here and pass it down we pass

00:22:41,659 --> 00:22:46,039
in the three parameters to our method

00:22:43,879 --> 00:22:48,590
and then we get the same string builder

00:22:46,039 --> 00:22:51,200
back it's just mutated it and we at that

00:22:48,590 --> 00:22:52,940
point before we return it change it to

00:22:51,200 --> 00:22:55,820
an immutable from the outside make

00:22:52,940 --> 00:22:57,860
string is pure basically you call make

00:22:55,820 --> 00:23:00,590
string on on the same immutable list

00:22:57,860 --> 00:23:02,269
you'll always get the same result you

00:23:00,590 --> 00:23:05,659
know passing in the same start step and

00:23:02,269 --> 00:23:07,820
end right in what I wanted the demo is

00:23:05,659 --> 00:23:10,519
or just point out is that be when we

00:23:07,820 --> 00:23:13,070
pass in the string builder be is a vowel

00:23:10,519 --> 00:23:14,990
that because parameters to methods

00:23:13,070 --> 00:23:16,820
cannot be reassigned so this is an

00:23:14,990 --> 00:23:18,980
example of the third quadrant where a

00:23:16,820 --> 00:23:20,899
vowel is referring to a mutable object

00:23:18,980 --> 00:23:25,279
and the reason is because it's fast

00:23:20,899 --> 00:23:28,610
right so that is a Scala's basically

00:23:25,279 --> 00:23:31,340
enables that that that if you you know

00:23:28,610 --> 00:23:34,340
where it makes sense to use mutation you

00:23:31,340 --> 00:23:36,740
can do it and that brings us to our

00:23:34,340 --> 00:23:38,419
final guideline for this presentation

00:23:36,740 --> 00:23:40,490
today which kind of brings us all

00:23:38,419 --> 00:23:43,340
together I think and that is that you

00:23:40,490 --> 00:23:44,960
should in general try to put

00:23:43,340 --> 00:23:48,080
side-effects on the outside of your

00:23:44,960 --> 00:23:49,789
program and possibly also on the inside

00:23:48,080 --> 00:23:52,100
the core of your program like in this

00:23:49,789 --> 00:23:54,110
for example used or so and everything

00:23:52,100 --> 00:23:59,149
else in general you should try to keep

00:23:54,110 --> 00:24:01,340
pure okay so what does that mean it

00:23:59,149 --> 00:24:03,110
means that the odds are of your program

00:24:01,340 --> 00:24:05,179
about what makes your program often

00:24:03,110 --> 00:24:06,799
useful is it interacts with the outside

00:24:05,179 --> 00:24:09,019
world so what does the outside world

00:24:06,799 --> 00:24:10,460
mean it means for example I over you

00:24:09,019 --> 00:24:12,980
have to do i or if your program doesn't

00:24:10,460 --> 00:24:15,740
take any i/o then well its can heat up

00:24:12,980 --> 00:24:18,649
the CPU but even that one is actually a

00:24:15,740 --> 00:24:21,080
kind of i/o possible I think but also

00:24:18,649 --> 00:24:23,600
you might want to interact with dist on

00:24:21,080 --> 00:24:25,610
and millions of Java API czar there or

00:24:23,600 --> 00:24:27,379
JavaScript or JavaScript API is nowadays

00:24:25,610 --> 00:24:30,500
lucky so in the Google Maps and what

00:24:27,379 --> 00:24:32,090
that means is that those api's will do

00:24:30,500 --> 00:24:32,419
whatever they want they will not follow

00:24:32,090 --> 00:24:34,309
from

00:24:32,419 --> 00:24:36,559
programming principles they probably use

00:24:34,309 --> 00:24:39,109
imperative styles they will have they

00:24:36,559 --> 00:24:40,999
will have nulls all over the place when

00:24:39,109 --> 00:24:43,669
you look at the facade for a JavaScript

00:24:40,999 --> 00:24:45,649
API well that's even types might be

00:24:43,669 --> 00:24:47,989
questionable you could have any pretty

00:24:45,649 --> 00:24:49,789
much anywhere or everywhere we would

00:24:47,989 --> 00:24:51,950
call this so where you interact with

00:24:49,789 --> 00:24:54,200
this outside world we would like you to

00:24:51,950 --> 00:24:56,840
think of that part of your code as the

00:24:54,200 --> 00:24:59,539
wilderness basically anything goes and

00:24:56,840 --> 00:25:02,690
that part of your code and we would like

00:24:59,539 --> 00:25:05,299
you to confine that wilderness to a

00:25:02,690 --> 00:25:07,100
well-defined region of your code now

00:25:05,299 --> 00:25:09,320
inside of your code like you saw in that

00:25:07,100 --> 00:25:11,629
string builder you could also use

00:25:09,320 --> 00:25:13,249
imperative Styles like even the Scala

00:25:11,629 --> 00:25:15,789
api's do that for performance reasons

00:25:13,249 --> 00:25:18,950
the other reason you may want to do that

00:25:15,789 --> 00:25:20,899
is to use an existing again an existing

00:25:18,950 --> 00:25:22,999
Java API there are just a ton of api's

00:25:20,899 --> 00:25:25,129
that you may want to use but well that's

00:25:22,999 --> 00:25:27,710
important is to confine the use of these

00:25:25,129 --> 00:25:30,259
impurity api's in such a way that from

00:25:27,710 --> 00:25:33,529
the outside they appear to very actually

00:25:30,259 --> 00:25:35,419
adhere to a referential transparency so

00:25:33,529 --> 00:25:37,429
again that's the core of these methods

00:25:35,419 --> 00:25:39,830
and also they are confined to one thread

00:25:37,429 --> 00:25:41,389
of execution because that way you learnt

00:25:39,830 --> 00:25:43,639
about concurrency you can do pretty much

00:25:41,389 --> 00:25:45,739
what you want inside a little core of

00:25:43,639 --> 00:25:47,419
your program and again you would do this

00:25:45,739 --> 00:25:49,129
mainly for performance and you might

00:25:47,419 --> 00:25:52,129
also want to do that like I mentioned to

00:25:49,129 --> 00:25:55,369
use imperative api's that do have

00:25:52,129 --> 00:25:57,769
mutable state all over the place but

00:25:55,369 --> 00:25:59,359
outside of those two areas what we think

00:25:57,769 --> 00:26:01,489
has emerged at least in our experience

00:25:59,359 --> 00:26:05,809
is that you should try to keep the rest

00:26:01,489 --> 00:26:08,299
of your code pure and basically use

00:26:05,809 --> 00:26:09,919
referential transparency take advantage

00:26:08,299 --> 00:26:12,169
of it as much as possible to manage the

00:26:09,919 --> 00:26:13,909
complexity of your code so we just like

00:26:12,169 --> 00:26:15,980
you to think of these three regions and

00:26:13,909 --> 00:26:18,379
I think yeah and then one way to

00:26:15,980 --> 00:26:20,720
illustrate this is as a that these are

00:26:18,379 --> 00:26:23,720
regions of the stack frame so when you

00:26:20,720 --> 00:26:25,639
fire a thread into the JVM it starts

00:26:23,720 --> 00:26:26,840
executing methods each time the method

00:26:25,639 --> 00:26:28,369
calls another method it pushes another

00:26:26,840 --> 00:26:29,989
frame onto the stack so this is showing

00:26:28,369 --> 00:26:32,149
the sack starting at the top and growing

00:26:29,989 --> 00:26:33,320
downwards and we've got quite a few

00:26:32,149 --> 00:26:37,730
methods that called quite a few other

00:26:33,320 --> 00:26:39,230
methods IO should happen at the top and

00:26:37,730 --> 00:26:40,940
if anywhere iowa's happening that's

00:26:39,230 --> 00:26:44,599
actually the wild region where anything

00:26:40,940 --> 00:26:46,050
goes and the top region that's shown

00:26:44,599 --> 00:26:48,600
orange here maybe

00:26:46,050 --> 00:26:50,340
um calling in to mutable api's that are

00:26:48,600 --> 00:26:52,950
valuable there's just a ton of value out

00:26:50,340 --> 00:26:54,930
there in existing libraries that it's

00:26:52,950 --> 00:26:58,380
really handy to be able to just link and

00:26:54,930 --> 00:27:00,180
use and maybe you wrap it and make it

00:26:58,380 --> 00:27:01,320
more Scala like but maybe you know at

00:27:00,180 --> 00:27:03,120
least that part is in the wilderness

00:27:01,320 --> 00:27:06,360
because it's calling into these mutable

00:27:03,120 --> 00:27:08,460
things then at some point you hit pure

00:27:06,360 --> 00:27:10,530
and everything in the yellow region on

00:27:08,460 --> 00:27:12,120
down until you get to purple is

00:27:10,530 --> 00:27:14,220
reference ly transparent it's actually

00:27:12,120 --> 00:27:15,480
you could replace the invocation with

00:27:14,220 --> 00:27:17,970
the result and it would not change the

00:27:15,480 --> 00:27:19,770
meaning of your code down at the bottom

00:27:17,970 --> 00:27:21,930
that's the hot spot that's actually the

00:27:19,770 --> 00:27:23,520
part that matters to the performance so

00:27:21,930 --> 00:27:26,160
there are a lot of times we switch back

00:27:23,520 --> 00:27:29,400
to local mutation that's confined to

00:27:26,160 --> 00:27:31,800
just one thread the border between the

00:27:29,400 --> 00:27:34,380
the yellow and the the purple down here

00:27:31,800 --> 00:27:37,260
is you know there's an immutable object

00:27:34,380 --> 00:27:39,360
coming back like make string uses

00:27:37,260 --> 00:27:41,640
mutation on the inside but it returns a

00:27:39,360 --> 00:27:43,200
string which is immutable so that from

00:27:41,640 --> 00:27:44,880
the top but basically as soon as you hit

00:27:43,200 --> 00:27:47,220
this it's all reference ly transparent

00:27:44,880 --> 00:27:50,100
on the way down any mutation is

00:27:47,220 --> 00:27:51,810
localized or confined so Frank has gonna

00:27:50,100 --> 00:27:53,250
give you a specific example how does it

00:27:51,810 --> 00:27:54,840
work in practice and you know we

00:27:53,250 --> 00:27:56,550
refactor some of our code actually tree

00:27:54,840 --> 00:27:58,170
like follow this pattern and we find it

00:27:56,550 --> 00:28:00,030
to be like really quite useful once you

00:27:58,170 --> 00:28:01,800
get it it's sort of like really helpful

00:28:00,030 --> 00:28:03,780
so in this example we're trying to

00:28:01,800 --> 00:28:05,640
generate a PDF document it's probably a

00:28:03,780 --> 00:28:08,310
very common task for a lot of enterprise

00:28:05,640 --> 00:28:09,990
level applications and the request to do

00:28:08,310 --> 00:28:12,240
this comes from the outside so there is

00:28:09,990 --> 00:28:16,470
an i/o and there is a message that you

00:28:12,240 --> 00:28:18,090
somehow get and receive and that message

00:28:16,470 --> 00:28:20,250
handling should be done in the

00:28:18,090 --> 00:28:21,630
wilderness per a program it may also we

00:28:20,250 --> 00:28:23,940
don't know how you receive that message

00:28:21,630 --> 00:28:26,580
but regardless whatever API use there

00:28:23,940 --> 00:28:29,280
would most likely not follow you know

00:28:26,580 --> 00:28:30,750
referential transparency and you know

00:28:29,280 --> 00:28:32,550
what you should confine that part of

00:28:30,750 --> 00:28:35,220
your code very clearly to the wilderness

00:28:32,550 --> 00:28:37,470
region however once you capture this

00:28:35,220 --> 00:28:39,570
input from the outside world as you go

00:28:37,470 --> 00:28:41,250
ahead and transfer that or transform

00:28:39,570 --> 00:28:43,290
that input into exactly the data that

00:28:41,250 --> 00:28:46,350
you need for your beautifully formatted

00:28:43,290 --> 00:28:48,510
PDF document that code which is probably

00:28:46,350 --> 00:28:50,880
the bulk of your application logic code

00:28:48,510 --> 00:28:52,830
should really be done in a purely

00:28:50,880 --> 00:28:54,180
functional way that's what we think is

00:28:52,830 --> 00:28:56,340
effective so again you would take

00:28:54,180 --> 00:28:57,990
advantage of of referential transparency

00:28:56,340 --> 00:28:59,389
which means that you could change

00:28:57,990 --> 00:29:01,849
methods together you can

00:28:59,389 --> 00:29:03,979
your code composable and and you should

00:29:01,849 --> 00:29:05,539
really try to clearly billion eight that

00:29:03,979 --> 00:29:07,219
segment of your code and really adhere

00:29:05,539 --> 00:29:09,799
to that principle inside that code

00:29:07,219 --> 00:29:11,599
however at the end of the day you may

00:29:09,799 --> 00:29:14,349
want to use an existing Java API to

00:29:11,599 --> 00:29:17,209
create your PDF why reinvent the wheel

00:29:14,349 --> 00:29:18,320
such as let's say the I text is a very

00:29:17,209 --> 00:29:20,779
popular Java API

00:29:18,320 --> 00:29:22,070
well guess what the I text vaporize for

00:29:20,779 --> 00:29:24,289
those who've used it you already know

00:29:22,070 --> 00:29:26,149
this it's a super imperative API just

00:29:24,289 --> 00:29:28,429
like it's like making a cake you have to

00:29:26,149 --> 00:29:30,739
do something things in one step at a

00:29:28,429 --> 00:29:32,749
time it does a lot of mutable state on

00:29:30,739 --> 00:29:34,879
those objects however if you confine the

00:29:32,749 --> 00:29:36,950
use of this API to just one thread and

00:29:34,879 --> 00:29:39,769
let's say you return after you've done

00:29:36,950 --> 00:29:41,629
with this PDF you don't do any i/o and

00:29:39,769 --> 00:29:42,950
you don't do any side-effects inside of

00:29:41,629 --> 00:29:44,719
methods so you definitely don't want to

00:29:42,950 --> 00:29:46,609
write that PDF to a file inside of

00:29:44,719 --> 00:29:48,469
methods but you would want to do is

00:29:46,609 --> 00:29:50,269
return an immutable data structure such

00:29:48,469 --> 00:29:53,839
as a vector a bite or something like

00:29:50,269 --> 00:29:56,809
that and therefore this confined region

00:29:53,839 --> 00:29:58,659
appears to be basically fairly

00:29:56,809 --> 00:30:02,509
functional from the outside but inside

00:29:58,659 --> 00:30:04,940
in this in this inside core part it

00:30:02,509 --> 00:30:06,559
could actually use part of its months

00:30:04,940 --> 00:30:08,389
basically because it's confined right

00:30:06,559 --> 00:30:10,700
and that's any of these layers you can

00:30:08,389 --> 00:30:12,469
call into useful libraries in Scala

00:30:10,700 --> 00:30:15,320
that's what's really nice about it is it

00:30:12,469 --> 00:30:17,179
allows you to to get the benefits of FP

00:30:15,320 --> 00:30:19,759
the benefits of oo and the benefits of

00:30:17,179 --> 00:30:21,409
all those wonderful I'm just wrong

00:30:19,759 --> 00:30:23,299
there's just so much value out there in

00:30:21,409 --> 00:30:25,940
the world in existing libraries in Java

00:30:23,299 --> 00:30:27,200
in JavaScript or wherever right but so

00:30:25,940 --> 00:30:29,479
I'm thinking of maybe not if you don't

00:30:27,200 --> 00:30:31,429
mind is that as soon as you call into an

00:30:29,479 --> 00:30:33,229
API that does side-effects you're in the

00:30:31,429 --> 00:30:37,820
wilderness might as well no no like this

00:30:33,229 --> 00:30:39,619
guy right so the ones that like if

00:30:37,820 --> 00:30:41,389
they're doing i/o then definitely your

00:30:39,619 --> 00:30:42,979
other world does any kind of i/o but if

00:30:41,389 --> 00:30:46,029
you can just keep it local to one thread

00:30:42,979 --> 00:30:51,259
and return something immutable you're in

00:30:46,029 --> 00:30:53,659
ok so just by the way we kind of came up

00:30:51,259 --> 00:30:55,399
with to visualize this architecture this

00:30:53,659 --> 00:30:56,959
is kind of like a design pattern is that

00:30:55,399 --> 00:30:58,820
this is your if this is your application

00:30:56,959 --> 00:31:00,529
all the source code work reallocation

00:30:58,820 --> 00:31:02,059
there's there's some orange reason on

00:31:00,529 --> 00:31:03,499
the orange region on the outside which

00:31:02,059 --> 00:31:05,389
is the wilderness that's the where the

00:31:03,499 --> 00:31:07,339
i/o happens that's where mutation

00:31:05,389 --> 00:31:12,050
happens because it's useful to call into

00:31:07,339 --> 00:31:14,600
libraries on the next in is is

00:31:12,050 --> 00:31:16,790
the pure code which is most of hopefully

00:31:14,600 --> 00:31:19,250
most of the code of your application and

00:31:16,790 --> 00:31:21,650
then on the inside there's that confined

00:31:19,250 --> 00:31:25,760
region where you have some mutation just

00:31:21,650 --> 00:31:28,370
for performance usually that is confined

00:31:25,760 --> 00:31:30,580
to one thread and it doesn't have I Oh

00:31:28,370 --> 00:31:33,110
so that it from the outside it appears

00:31:30,580 --> 00:31:36,140
reference ly transparent so you you can

00:31:33,110 --> 00:31:37,940
basically decide how big or small to

00:31:36,140 --> 00:31:41,720
make these regions when you define an

00:31:37,940 --> 00:31:43,520
app for example yeah yes right so you

00:31:41,720 --> 00:31:46,490
basically could exactly I mean you could

00:31:43,520 --> 00:31:47,780
shrink or grow one of these regions but

00:31:46,490 --> 00:31:49,160
I think the message that we're trying to

00:31:47,780 --> 00:31:51,200
convey is it's important to really

00:31:49,160 --> 00:31:53,210
consciously think about this and really

00:31:51,200 --> 00:31:54,620
make this decision so it's not the case

00:31:53,210 --> 00:31:56,270
that in anywhere in your code you could

00:31:54,620 --> 00:31:57,470
just call and do anything pretty much so

00:31:56,270 --> 00:31:59,840
but you should really think of these

00:31:57,470 --> 00:32:01,940
regions as being separate and distinct

00:31:59,840 --> 00:32:03,650
in your code base and we think that this

00:32:01,940 --> 00:32:06,110
is something that would give you the

00:32:03,650 --> 00:32:08,570
most benefit the sweet spot for both Oh

00:32:06,110 --> 00:32:12,080
which you could do in certain regions as

00:32:08,570 --> 00:32:13,640
well as FP in your code so we think that

00:32:12,080 --> 00:32:15,320
this is kind of a general pattern when

00:32:13,640 --> 00:32:16,640
you when you work with the scala project

00:32:15,320 --> 00:32:18,350
it's more like a macro put like a

00:32:16,640 --> 00:32:20,090
large-scale pattern programming the

00:32:18,350 --> 00:32:21,920
large kind of pattern and we try to give

00:32:20,090 --> 00:32:24,440
you the name but first we thought it's

00:32:21,920 --> 00:32:26,600
like a bagel because it's a bagel I'll

00:32:24,440 --> 00:32:28,190
be like Bay goes with exactly but then

00:32:26,600 --> 00:32:30,560
also the problem with the bago is that

00:32:28,190 --> 00:32:32,090
the bagel is empty in the inside whereas

00:32:30,560 --> 00:32:34,250
this pattern there's something in the

00:32:32,090 --> 00:32:36,380
center that's like solid like something

00:32:34,250 --> 00:32:37,700
is mutation going on mutation going

00:32:36,380 --> 00:32:40,250
especially when you eat your bagel you

00:32:37,700 --> 00:32:42,410
mutate it but that didn't really work so

00:32:40,250 --> 00:32:43,610
then we thought of the Saturn pattern

00:32:42,410 --> 00:32:46,610
looks a bit like the Saturn and then

00:32:43,610 --> 00:32:48,350
plus it rhymes but that also the problem

00:32:46,610 --> 00:32:50,630
with the Saturn is that it's even it's

00:32:48,350 --> 00:32:52,400
gases in the inside but they in between

00:32:50,630 --> 00:32:54,890
the ring and it's just basically nothing

00:32:52,400 --> 00:32:56,450
but here most of your code is there so

00:32:54,890 --> 00:32:58,640
that didn't fight yeah so we didn't have

00:32:56,450 --> 00:33:01,130
a satisfying name for this pattern and

00:32:58,640 --> 00:33:03,530
two days ago I was already in Germany

00:33:01,130 --> 00:33:05,600
and and it actually spoke to me and told

00:33:03,530 --> 00:33:08,150
me what its name was and it turns out it

00:33:05,600 --> 00:33:11,450
spoke German it said bagel ich meine

00:33:08,150 --> 00:33:15,200
keine bagel ich bin kind so torn he bin

00:33:11,450 --> 00:33:17,080
ein Berliner because it looks just like

00:33:15,200 --> 00:33:19,580
a Berliner right

00:33:17,080 --> 00:33:25,049
[Applause]

00:33:19,580 --> 00:33:26,339
so and it's the it's the jelly filled

00:33:25,049 --> 00:33:29,669
donut Berlin are not the American

00:33:26,339 --> 00:33:31,049
president Berliner so that that week

00:33:29,669 --> 00:33:33,779
when we think we should call this the

00:33:31,049 --> 00:33:36,619
Berliner pattern it is the it is the

00:33:33,779 --> 00:33:38,969
whoops lurker Blaney O Matic way to

00:33:36,619 --> 00:33:44,009
design Scala applications where you have

00:33:38,969 --> 00:33:47,609
the outside layer is is the wilderness

00:33:44,009 --> 00:33:49,739
it has I oh that's side effects and it

00:33:47,609 --> 00:33:51,239
has calls into stuff that's useful in

00:33:49,739 --> 00:33:55,710
the outside world that may be mutable

00:33:51,239 --> 00:34:00,049
and you can you do it the the cake part

00:33:55,710 --> 00:34:02,159
is your pure code and the jelly is the

00:34:00,049 --> 00:34:05,190
confined region and there's not a

00:34:02,159 --> 00:34:06,809
mutable goop in there takes it stays on

00:34:05,190 --> 00:34:11,159
the inside from the outside it appears

00:34:06,809 --> 00:34:13,980
reference to transparent right so we we

00:34:11,159 --> 00:34:15,240
wanted to like wrap up by kind of giving

00:34:13,980 --> 00:34:17,760
you some insight as to what we're going

00:34:15,240 --> 00:34:20,909
back to Martin's keynote he said there's

00:34:17,760 --> 00:34:22,440
HEPA Haskell on the JVM extreme there's

00:34:20,909 --> 00:34:24,750
the better job extreme and then there's

00:34:22,440 --> 00:34:28,829
this third way which which we're trying

00:34:24,750 --> 00:34:30,690
to like define so what would hassle on

00:34:28,829 --> 00:34:33,059
that VM look like well I think we have a

00:34:30,690 --> 00:34:35,579
some idea unfortunately the jelly part

00:34:33,059 --> 00:34:37,740
is gone which we think is kind of tasty

00:34:35,579 --> 00:34:39,059
sometimes if you too much of it though

00:34:37,740 --> 00:34:40,889
you can kind of go overboard with that

00:34:39,059 --> 00:34:44,159
but this is what it would look like so

00:34:40,889 --> 00:34:46,319
if you really go and apply those haskell

00:34:44,159 --> 00:34:48,210
like principles to the full extent then

00:34:46,319 --> 00:34:52,529
you really don't have any mutable they

00:34:48,210 --> 00:34:55,529
don't have any kind of confinement but

00:34:52,529 --> 00:34:57,839
you do have i oh yes task on the JVM

00:34:55,529 --> 00:34:59,309
this is Haskell basically it's pure but

00:34:57,839 --> 00:35:02,250
they have to have IO and they do it at

00:34:59,309 --> 00:35:04,529
the edge and and so that that's what it

00:35:02,250 --> 00:35:06,660
is and and as I said this I have seen

00:35:04,529 --> 00:35:09,720
this work in practice it works as long

00:35:06,660 --> 00:35:11,369
as there's a leader on top right so what

00:35:09,720 --> 00:35:12,990
do you think better Java would look like

00:35:11,369 --> 00:35:14,220
yeah that's interesting well let's look

00:35:12,990 --> 00:35:17,160
at it and this is what it would look

00:35:14,220 --> 00:35:20,099
like it's old it's it's all the gooey

00:35:17,160 --> 00:35:22,859
stuff this is like you're basically

00:35:20,099 --> 00:35:25,470
programming Java in Scala where does

00:35:22,859 --> 00:35:27,900
this pattern so everything is mutated

00:35:25,470 --> 00:35:30,900
everything is yeah yes I think that's

00:35:27,900 --> 00:35:32,500
what it looks like yeah so so anyways

00:35:30,900 --> 00:35:34,690
Scala we think is is this

00:35:32,500 --> 00:35:36,460
and you know it is different than

00:35:34,690 --> 00:35:38,050
Haskell and that it does let you do

00:35:36,460 --> 00:35:40,300
mutation let you do what you need right

00:35:38,050 --> 00:35:42,580
but what and so it it doesn't really

00:35:40,300 --> 00:35:45,400
this isn't in the language so much it's

00:35:42,580 --> 00:35:48,010
just from experience we think that the

00:35:45,400 --> 00:35:50,080
most effective way to use Scala is you

00:35:48,010 --> 00:35:52,690
put your side effects on the the i/o to

00:35:50,080 --> 00:35:55,630
the edge just like in Haskell but you

00:35:52,690 --> 00:35:57,340
also have confined mutations on the

00:35:55,630 --> 00:35:59,080
inside for speed which you can't do in

00:35:57,340 --> 00:36:01,690
Haskell I mean and and you'll they'll

00:35:59,080 --> 00:36:04,600
have to do all kinds of jump through

00:36:01,690 --> 00:36:06,430
hoops like trampolining to avoid doing a

00:36:04,600 --> 00:36:09,430
while loop right we just do a while loop

00:36:06,430 --> 00:36:11,560
but most of it is reference ly

00:36:09,430 --> 00:36:13,360
transparent so you get the benefit of FP

00:36:11,560 --> 00:36:14,830
yeah and if you look at the Scala

00:36:13,360 --> 00:36:16,630
libraries have a lot of them actually

00:36:14,830 --> 00:36:18,580
use this pattern already we just try to

00:36:16,630 --> 00:36:19,660
sort of like look at it from a bigger

00:36:18,580 --> 00:36:22,930
perspective but I think it's really

00:36:19,660 --> 00:36:24,580
being used in those and that's why so

00:36:22,930 --> 00:36:27,100
that's our talk we just before we go to

00:36:24,580 --> 00:36:28,420
QA I just want to make a couple things

00:36:27,100 --> 00:36:30,160
we did I mentioned that we have an

00:36:28,420 --> 00:36:32,500
effective scholar workshop that does

00:36:30,160 --> 00:36:34,540
exist our book does not yet but this

00:36:32,500 --> 00:36:36,130
does exist and if you're interested we

00:36:34,540 --> 00:36:37,960
could come in and give this there's the

00:36:36,130 --> 00:36:39,040
URL I mean what a convention about that

00:36:37,960 --> 00:36:41,350
is that while we're talking about

00:36:39,040 --> 00:36:43,000
patterns from the large we also go into

00:36:41,350 --> 00:36:45,310
a lot of details in the sprite a lot

00:36:43,000 --> 00:36:49,510
more detail right classes from you so

00:36:45,310 --> 00:36:51,040
effectively yep and then our tema is my

00:36:49,510 --> 00:36:53,320
company and we are always looking for

00:36:51,040 --> 00:36:54,820
developers we do consulting so if anyone

00:36:53,320 --> 00:36:56,890
is interested there's an email address

00:36:54,820 --> 00:36:58,780
we use come talk to me actually also we

00:36:56,890 --> 00:37:01,210
are available to do consulting if you

00:36:58,780 --> 00:37:05,080
need help with Scala and we are

00:37:01,210 --> 00:37:07,840
listening I am I was a honored to be

00:37:05,080 --> 00:37:09,700
selected as a community representative

00:37:07,840 --> 00:37:12,790
on the Scala Center Advisory Board which

00:37:09,700 --> 00:37:14,980
means I represent you so I need to hear

00:37:12,790 --> 00:37:17,050
what you I need here you complain and

00:37:14,980 --> 00:37:18,040
oftentimes people don't complain so if

00:37:17,050 --> 00:37:19,660
you have any concerns about the

00:37:18,040 --> 00:37:22,150
direction where Scala is going please

00:37:19,660 --> 00:37:23,620
come up and talk to me or let you know

00:37:22,150 --> 00:37:26,320
let me know about it and I can I can

00:37:23,620 --> 00:37:28,750
relay that to the Scala Center so with

00:37:26,320 --> 00:37:31,180
that let's I think we have about five

00:37:28,750 --> 00:37:33,940
minutes for Q&A does anybody have a

00:37:31,180 --> 00:37:36,990
question as if several questions is how

00:37:33,940 --> 00:37:36,990
does question thank you

00:37:41,010 --> 00:37:44,580
so build what this step but does that

00:37:42,780 --> 00:37:47,580
remind you I mean yes anybody know what

00:37:44,580 --> 00:37:56,580
this is a diagram whose micro-service

00:37:47,580 --> 00:38:01,830
architecture a heap of Berliners Oh on

00:37:56,580 --> 00:38:04,080
that slide I think this is my con yeah

00:38:01,830 --> 00:38:05,520
okay yeah so it first stretch let me

00:38:04,080 --> 00:38:07,230
talk yeah very interesting

00:38:05,520 --> 00:38:11,970
thank you and I very much agree with

00:38:07,230 --> 00:38:15,090
your Berliner pattern one thing I liked

00:38:11,970 --> 00:38:17,520
in high school is when you are in the

00:38:15,090 --> 00:38:21,570
wilderness you also specify this by the

00:38:17,520 --> 00:38:25,250
type Haskell has a type I Oh which you

00:38:21,570 --> 00:38:28,620
may get in some Scala libraries but

00:38:25,250 --> 00:38:31,410
instance Scala you don't mark that by

00:38:28,620 --> 00:38:33,150
the type and this is a very helpful to

00:38:31,410 --> 00:38:37,130
see this in the type when you're doing

00:38:33,150 --> 00:38:39,750
i/o and then everything else is pure

00:38:37,130 --> 00:38:41,190
yeah what he said just in case you

00:38:39,750 --> 00:38:43,320
didn't hear him was that in one things

00:38:41,190 --> 00:38:45,180
he likes from Haskell is that when

00:38:43,320 --> 00:38:46,890
you're when you're doing i/o or it's if

00:38:45,180 --> 00:38:48,510
there is it is expressed in a type I

00:38:46,890 --> 00:38:51,120
agree with that I think that's very

00:38:48,510 --> 00:38:52,650
useful Martin I did hear him one time

00:38:51,120 --> 00:38:54,270
say that one one thing he likes about

00:38:52,650 --> 00:38:57,270
Haskell the Scala doesn't have is its

00:38:54,270 --> 00:38:58,950
purity so I think he has some like in

00:38:57,270 --> 00:39:03,240
the back of his mind some some ideas

00:38:58,950 --> 00:39:05,610
brewing about how to do get get more

00:39:03,240 --> 00:39:07,440
type checking for that kind of thing but

00:39:05,610 --> 00:39:09,240
as you're right today that we don't have

00:39:07,440 --> 00:39:10,680
that so it really is wild that's why we

00:39:09,240 --> 00:39:13,530
called it the wild remembrance anything

00:39:10,680 --> 00:39:16,560
goes to this yeah today is there another

00:39:13,530 --> 00:39:21,350
question that's who's gonna there's one

00:39:16,560 --> 00:39:26,820
in the back start with this one here

00:39:21,350 --> 00:39:28,080
Joseph oh sorry I'm a typical typical

00:39:26,820 --> 00:39:31,050
thing that you're dealing with and the

00:39:28,080 --> 00:39:32,640
confined sections are exceptions is

00:39:31,050 --> 00:39:35,940
there a standard approach to avoid

00:39:32,640 --> 00:39:37,970
leaking exception to your pure part of

00:39:35,940 --> 00:39:40,050
your program

00:39:37,970 --> 00:39:41,820
when you say exceptions do you mean like

00:39:40,050 --> 00:39:44,460
throwing exceptions or you are well

00:39:41,820 --> 00:39:46,260
you're basically calling Java libraries

00:39:44,460 --> 00:39:48,360
and they all throw checked or unchecked

00:39:46,260 --> 00:39:49,860
exceptions oh let me restate the

00:39:48,360 --> 00:39:51,180
question for those who didn't hear but I

00:39:49,860 --> 00:39:52,740
think if I'm correct what you said was

00:39:51,180 --> 00:39:54,720
that in this greasy section when you

00:39:52,740 --> 00:39:57,359
call into existing Java API snarling you

00:39:54,720 --> 00:39:59,390
nulls and whatever in there but you may

00:39:57,359 --> 00:40:02,640
all those api's may throw exceptions

00:39:59,390 --> 00:40:05,580
after the question was how to what to do

00:40:02,640 --> 00:40:07,920
about it like huh yeah so basically at

00:40:05,580 --> 00:40:11,040
the interface between Scala code and an

00:40:07,920 --> 00:40:13,530
existing library I try to Scala fie it

00:40:11,040 --> 00:40:15,090
so I catch an exception and return an

00:40:13,530 --> 00:40:17,040
option or something like that or catch

00:40:15,090 --> 00:40:19,320
an exception return it a try or an

00:40:17,040 --> 00:40:22,950
either/or or something and try to make

00:40:19,320 --> 00:40:24,270
it more skull alike but that's my code

00:40:22,950 --> 00:40:25,800
so that's part of the wilderness right

00:40:24,270 --> 00:40:27,540
on the inside of that maybe it's maybe

00:40:25,800 --> 00:40:28,950
it's better but it might still be

00:40:27,540 --> 00:40:30,900
mutable so even then it would still be

00:40:28,950 --> 00:40:33,900
part of the wilderness but what I try to

00:40:30,900 --> 00:40:37,080
do is try to have most of my code

00:40:33,900 --> 00:40:38,430
idiomatic Scala and sort of isolate from

00:40:37,080 --> 00:40:39,690
the libraries I'm using but sometimes

00:40:38,430 --> 00:40:41,880
it's just not worth it and you just call

00:40:39,690 --> 00:40:43,710
the library and that's part of what's

00:40:41,880 --> 00:40:44,760
that's actually part of what Scala is

00:40:43,710 --> 00:40:45,900
about is that you can do that if you

00:40:44,760 --> 00:40:47,670
need to do it and you get something done

00:40:45,900 --> 00:40:49,740
you've got a useful library no matter

00:40:47,670 --> 00:40:50,910
what its style is you can just call it

00:40:49,740 --> 00:40:52,590
how about confine it to those two

00:40:50,910 --> 00:40:54,570
regions that's the important thing yeah

00:40:52,590 --> 00:40:55,710
like don't mix the two that's kind of

00:40:54,570 --> 00:40:57,570
what we're trying to convey so there's

00:40:55,710 --> 00:41:02,450
one in the back here that I think she

00:40:57,570 --> 00:41:07,830
she's like yeah so though my question is

00:41:02,450 --> 00:41:13,010
related to the first one so I want um oh

00:41:07,830 --> 00:41:17,609
it's it's irritating but it's twice so

00:41:13,010 --> 00:41:21,690
I'm in your picture yeah the outside

00:41:17,609 --> 00:41:24,390
wide Earnest layer was as big as in the

00:41:21,690 --> 00:41:27,960
Haskell or as small and my question

00:41:24,390 --> 00:41:32,310
would be you as an opinionated approach

00:41:27,960 --> 00:41:37,080
would you recommend using an i/o monitor

00:41:32,310 --> 00:41:40,500
and do you do that or do you just like

00:41:37,080 --> 00:41:44,040
call your database get bacon and give

00:41:40,500 --> 00:41:48,470
bacon either by caching whatever could

00:41:44,040 --> 00:41:51,990
happen yeah do you use an IO and have an

00:41:48,470 --> 00:41:54,780
interpreter at the very end I personally

00:41:51,990 --> 00:41:56,609
don't use IO monad I just do IO in in

00:41:54,780 --> 00:41:59,640
the outer region and it's small enough

00:41:56,609 --> 00:42:01,710
that I can reason about it but it's if

00:41:59,640 --> 00:42:03,540
you want to do i oh like describe it

00:42:01,710 --> 00:42:06,060
basically it's a it's a it's this

00:42:03,540 --> 00:42:07,320
question it's really where yeah this

00:42:06,060 --> 00:42:07,940
this or this

00:42:07,320 --> 00:42:09,530
see how

00:42:07,940 --> 00:42:10,940
there are two different sizes No so if

00:42:09,530 --> 00:42:13,160
you're using i/o Mon and it's gonna be

00:42:10,940 --> 00:42:15,829
thinner if you're right just calling

00:42:13,160 --> 00:42:18,740
this up maybe it's thicker it's ur pins

00:42:15,829 --> 00:42:20,510
on I mean how this is the each project

00:42:18,740 --> 00:42:23,240
should have an opinion and that's sort

00:42:20,510 --> 00:42:24,770
of you know you can decide based on the

00:42:23,240 --> 00:42:27,440
situation what makes sense for your team

00:42:24,770 --> 00:42:28,730
and and you know but I think the

00:42:27,440 --> 00:42:30,650
important thing is goes back to Kyle on

00:42:28,730 --> 00:42:31,880
number one once you decided I think it's

00:42:30,650 --> 00:42:33,410
good to stick with that decision

00:42:31,880 --> 00:42:35,030
throughout the project because I have

00:42:33,410 --> 00:42:37,520
seen projects where things that aren't

00:42:35,030 --> 00:42:40,130
differently over time and that's where a

00:42:37,520 --> 00:42:40,700
lot of problems can happen I think okay

00:42:40,130 --> 00:42:44,150
thanks

00:42:40,700 --> 00:42:48,140
sure anyone else we might have time for

00:42:44,150 --> 00:42:52,569
one more and if you have one there's one

00:42:48,140 --> 00:42:52,569
in the middle and Amit

00:42:56,240 --> 00:43:03,980
all right you yes do you tolerate

00:42:58,400 --> 00:43:07,670
logging in the pure section so III gave

00:43:03,980 --> 00:43:09,950
a talk at Northeast Carla symposium

00:43:07,670 --> 00:43:12,200
about six weeks ago where I talked about

00:43:09,950 --> 00:43:14,300
pragmatic purity about what is actually

00:43:12,200 --> 00:43:18,770
that there are certain things we ignore

00:43:14,300 --> 00:43:20,450
like for example when you say new like

00:43:18,770 --> 00:43:22,040
that new stringbuilder that was actually

00:43:20,450 --> 00:43:23,290
a side of it cuz it mutated the heat but

00:43:22,040 --> 00:43:25,700
we don't have to keep track of it

00:43:23,290 --> 00:43:29,109
because of garbage collection so we just

00:43:25,700 --> 00:43:33,820
ignore that but it's not pure really and

00:43:29,109 --> 00:43:36,440
logging doesn't really change the

00:43:33,820 --> 00:43:37,760
meaning so I usually don't think of

00:43:36,440 --> 00:43:39,770
logging I think the blogging is

00:43:37,760 --> 00:43:41,480
pragmatically pure the one thing I would

00:43:39,770 --> 00:43:44,510
say about it that was said to me after

00:43:41,480 --> 00:43:48,920
my talk was that if you are doing like

00:43:44,510 --> 00:43:51,020
one of one way to to move IO like to

00:43:48,920 --> 00:43:53,359
make this thinner on the outside is to

00:43:51,020 --> 00:43:55,160
to build up descriptions of side effects

00:43:53,359 --> 00:43:59,780
that you're gonna do is ID effects and

00:43:55,160 --> 00:44:02,570
then execute them at the end right so if

00:43:59,780 --> 00:44:05,480
you do that then you usually want the

00:44:02,570 --> 00:44:07,070
logging to happen when it happens not

00:44:05,480 --> 00:44:09,109
when it's described so you have to be

00:44:07,070 --> 00:44:12,050
careful that way but otherwise I think

00:44:09,109 --> 00:44:14,359
pretty much that logging is okay to do

00:44:12,050 --> 00:44:16,160
anywhere because it's actually useful

00:44:14,359 --> 00:44:17,630
it's a side effect and also I don't

00:44:16,160 --> 00:44:19,609
think it actually makes your code easier

00:44:17,630 --> 00:44:22,040
to reason about not more difficult yeah

00:44:19,609 --> 00:44:25,940
so that probably is that's my opinion

00:44:22,040 --> 00:44:28,190
job don't log away logging even caching

00:44:25,940 --> 00:44:29,300
I would say would be the same yeah can

00:44:28,190 --> 00:44:32,000
teach another one it's a side effect

00:44:29,300 --> 00:44:34,010
that usually you don't have to to worry

00:44:32,000 --> 00:44:36,830
about it's it's on the outside it's

00:44:34,010 --> 00:44:38,510
referentially transparent okay so I

00:44:36,830 --> 00:44:40,609
think is lunch next I don't wanna

00:44:38,510 --> 00:44:43,500
promise lunch if it's not lunch but but

00:44:40,609 --> 00:44:49,719
anyway for your attention

00:44:43,500 --> 00:44:49,719

YouTube URL: https://www.youtube.com/watch?v=DhNw60hxCeY


