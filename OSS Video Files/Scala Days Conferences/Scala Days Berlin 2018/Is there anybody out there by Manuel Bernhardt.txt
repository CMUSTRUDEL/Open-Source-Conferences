Title: Is there anybody out there by Manuel Bernhardt
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6916-is-there-anybody-out-there.html
Captions: 
	00:00:04,590 --> 00:00:11,980
thanks everyone for coming I like to

00:00:08,050 --> 00:00:14,440
talk about not aliens I want to talk

00:00:11,980 --> 00:00:17,080
about distributed systems today I want

00:00:14,440 --> 00:00:21,820
to give you a this is sort of a crash

00:00:17,080 --> 00:00:24,689
course in foundations and before I get

00:00:21,820 --> 00:00:27,429
started a little word of this framer a

00:00:24,689 --> 00:00:30,490
career in distributed systems is both

00:00:27,429 --> 00:00:32,710
exhilarating and frustrating when things

00:00:30,490 --> 00:00:34,840
work it's like a symphony when they

00:00:32,710 --> 00:00:36,610
don't it's like an eleventh birthday

00:00:34,840 --> 00:00:40,329
party where half of the kids are in

00:00:36,610 --> 00:00:44,170
speed I think there's a very accurate

00:00:40,329 --> 00:00:49,690
quote by Jeff Darcy from heck ifs or

00:00:44,170 --> 00:00:51,579
cloud FS and and the reason I want to

00:00:49,690 --> 00:00:53,260
give this disclaimer so I took a

00:00:51,579 --> 00:00:55,120
three-month sabbatical at the beginning

00:00:53,260 --> 00:00:56,980
of the year where I ended up reading a

00:00:55,120 --> 00:00:58,930
lot of distributed systems paper and

00:00:56,980 --> 00:01:00,550
really took all the time I wanted to

00:00:58,930 --> 00:01:02,920
always take and just read and read and

00:01:00,550 --> 00:01:04,989
read and I think you know a distributed

00:01:02,920 --> 00:01:07,900
systems research and engineering is a

00:01:04,989 --> 00:01:12,090
very selfless act because what you do is

00:01:07,900 --> 00:01:14,470
that you you sort of trade your sanity

00:01:12,090 --> 00:01:15,970
for the greater good of humanity of

00:01:14,470 --> 00:01:19,450
understanding how distributed systems

00:01:15,970 --> 00:01:21,009
work and you don't notice it it's kind

00:01:19,450 --> 00:01:24,700
of creeps in or sort of leaves you

00:01:21,009 --> 00:01:27,700
slowly the way you see it so just as a

00:01:24,700 --> 00:01:29,829
little disclaimer if don't come there if

00:01:27,700 --> 00:01:31,659
you come to me in five years and and

00:01:29,829 --> 00:01:34,869
tell me you know I know a lot about this

00:01:31,659 --> 00:01:38,020
used systems now but my life is in ruins

00:01:34,869 --> 00:01:44,470
or the rest of it you know I will have

00:01:38,020 --> 00:01:47,020
warned you so just quickly about myself

00:01:44,470 --> 00:01:50,049
my name is mano Bernard I help companies

00:01:47,020 --> 00:01:52,000
to get started with reactive systems or

00:01:50,049 --> 00:01:55,659
to keep them running or make them run

00:01:52,000 --> 00:01:57,250
faster or what so not I'm also a light

00:01:55,659 --> 00:01:59,500
been consulting and training partner and

00:01:57,250 --> 00:02:04,509
my focus these days is most young acha

00:01:59,500 --> 00:02:08,110
acha cluster extremes I'm also a scuba

00:02:04,509 --> 00:02:09,670
diver and that's not the Danube I live

00:02:08,110 --> 00:02:12,880
in Vienna in Austria but that's not a

00:02:09,670 --> 00:02:17,170
Blue Danube that's I wish it was that is

00:02:12,880 --> 00:02:18,410
actually in Egypt we don't have we don't

00:02:17,170 --> 00:02:20,150
actually have a/c in Austria

00:02:18,410 --> 00:02:22,190
we just have lakes and they're really

00:02:20,150 --> 00:02:28,010
cold so it's not really good to go there

00:02:22,190 --> 00:02:29,750
to dive it's sort of and let me start

00:02:28,010 --> 00:02:31,850
with a motivational quote another quote

00:02:29,750 --> 00:02:34,910
you will get more of these life is a

00:02:31,850 --> 00:02:38,210
single-player game you're born alone

00:02:34,910 --> 00:02:41,000
you're going to die alone all of your

00:02:38,210 --> 00:02:44,000
interpretations are alone all of your

00:02:41,000 --> 00:02:46,910
memories are alone you're gone in three

00:02:44,000 --> 00:02:49,070
generations and no one cares before you

00:02:46,910 --> 00:02:51,170
showed up nobody cared it's all

00:02:49,070 --> 00:02:53,440
single-player I think it's a very

00:02:51,170 --> 00:02:56,390
beautiful quote by a novel rebek Hampton

00:02:53,440 --> 00:02:58,670
are you all motivated now is it yeah

00:02:56,390 --> 00:03:04,190
does it work yes yeah yeah we can do

00:02:58,670 --> 00:03:06,080
this right so really this quote is maybe

00:03:04,190 --> 00:03:08,090
more to motivate the talk than to

00:03:06,080 --> 00:03:09,730
motivate you awesome if it does that's

00:03:08,090 --> 00:03:12,650
great

00:03:09,730 --> 00:03:15,710
because if you think of a single node in

00:03:12,650 --> 00:03:19,460
a cluster it's all single-player you

00:03:15,710 --> 00:03:22,400
know we think of a node of a cluster as

00:03:19,460 --> 00:03:24,020
this set of nodes that talk to one

00:03:22,400 --> 00:03:25,880
another but the reality of it is a

00:03:24,020 --> 00:03:28,550
little bit different this is what I

00:03:25,880 --> 00:03:30,080
would call sort of the God view of a

00:03:28,550 --> 00:03:32,180
cluster we see all the nodes we know

00:03:30,080 --> 00:03:34,220
they're there there is s1 s2 s3 we all

00:03:32,180 --> 00:03:37,250
we know all of them but if you actually

00:03:34,220 --> 00:03:39,860
build distributed systems the way you

00:03:37,250 --> 00:03:43,730
have to think about it is from the point

00:03:39,860 --> 00:03:46,180
of view of the single node that gets to

00:03:43,730 --> 00:03:49,490
see other nodes over an asynchronous

00:03:46,180 --> 00:03:51,260
unreliable network and maybe there is a

00:03:49,490 --> 00:03:53,180
network partition and then you don't see

00:03:51,260 --> 00:03:55,220
the other node anymore or maybe the node

00:03:53,180 --> 00:03:56,959
there's a garbage collection going on if

00:03:55,220 --> 00:03:59,120
it's a Java node and it doesn't respond

00:03:56,959 --> 00:04:00,590
to signals anymore and you don't know

00:03:59,120 --> 00:04:03,560
what's going on it's all very uncertain

00:04:00,590 --> 00:04:06,260
it's all very much and deterministic and

00:04:03,560 --> 00:04:09,530
it's one way of to reason about these

00:04:06,260 --> 00:04:12,650
things that this sort of point of view

00:04:09,530 --> 00:04:16,609
which makes it quite difficult to build

00:04:12,650 --> 00:04:18,260
reliable distributed systems so if we

00:04:16,609 --> 00:04:20,299
want to build a cluster what do we need

00:04:18,260 --> 00:04:22,520
we need three things we need to discover

00:04:20,299 --> 00:04:24,050
who else is there with us in the cluster

00:04:22,520 --> 00:04:26,690
edge on the cluster but who is there

00:04:24,050 --> 00:04:31,249
were the members I need to be able to

00:04:26,690 --> 00:04:33,019
figure out that some some node has a

00:04:31,249 --> 00:04:34,429
that there is a failure you know if

00:04:33,019 --> 00:04:36,499
there is a crashing node I don't want to

00:04:34,429 --> 00:04:38,059
continue pretending it's there I want to

00:04:36,499 --> 00:04:40,909
know about this I probably want to know

00:04:38,059 --> 00:04:43,969
about it's a rather faster dance and and

00:04:40,909 --> 00:04:46,459
slower and finally one of the reasons I

00:04:43,969 --> 00:04:48,949
might want to use a cluster is that I I

00:04:46,459 --> 00:04:52,069
don't have enough computing capacity on

00:04:48,949 --> 00:04:54,859
one machine and I want to balance that

00:04:52,069 --> 00:04:56,659
computing sort of out on different nodes

00:04:54,859 --> 00:04:58,819
for different tasks maybe depending on

00:04:56,659 --> 00:05:00,859
where they are located all of this load

00:04:58,819 --> 00:05:02,809
balancing aspect is also one of the very

00:05:00,859 --> 00:05:04,009
important things that you have to think

00:05:02,809 --> 00:05:06,349
about when you're building clustered

00:05:04,009 --> 00:05:08,379
systems now it turns out that there is

00:05:06,349 --> 00:05:10,759
one quite powerful abstraction that

00:05:08,379 --> 00:05:13,819
covers all of these cases and that's the

00:05:10,759 --> 00:05:15,889
abstraction of group membership so if I

00:05:13,819 --> 00:05:18,110
have a service that runs on each and

00:05:15,889 --> 00:05:22,039
every node and that tells me who is

00:05:18,110 --> 00:05:25,069
there who is failing with capacity to

00:05:22,039 --> 00:05:28,459
take up more work etc that is something

00:05:25,069 --> 00:05:31,069
that I can use and to build an

00:05:28,459 --> 00:05:32,689
application on top of the on these

00:05:31,069 --> 00:05:35,119
machines it sort of feels a bit more

00:05:32,689 --> 00:05:37,669
like an application that runs on one

00:05:35,119 --> 00:05:41,509
machine not exactly the same but it gets

00:05:37,669 --> 00:05:43,759
easier and if I want to implement such a

00:05:41,509 --> 00:05:46,669
group membership service I need three

00:05:43,759 --> 00:05:49,489
things I need failure detectors I need

00:05:46,669 --> 00:05:52,249
dissemination I need a way to spread the

00:05:49,489 --> 00:05:55,879
word out in throughout the cluster and I

00:05:52,249 --> 00:05:57,229
need consensus I need to reach consensus

00:05:55,879 --> 00:06:00,199
and so these are the three things we're

00:05:57,229 --> 00:06:03,979
going to explore today and the first one

00:06:00,199 --> 00:06:08,329
is my favorite topic I don't know why I

00:06:03,979 --> 00:06:11,089
have an irrational interest in Indies in

00:06:08,329 --> 00:06:14,479
these things who can tell me who this

00:06:11,089 --> 00:06:14,929
album is what this album is yeah that's

00:06:14,479 --> 00:06:17,089
great

00:06:14,929 --> 00:06:19,669
this is wish you were here from 75 I

00:06:17,089 --> 00:06:25,279
think this actually depicts failure in

00:06:19,669 --> 00:06:26,959
action and so let's talk about failure

00:06:25,279 --> 00:06:28,999
detectors a little bit a bit of theory

00:06:26,959 --> 00:06:31,459
here to get started with so there's two

00:06:28,999 --> 00:06:33,199
key properties in failure detectors the

00:06:31,459 --> 00:06:35,899
first one is completeness which is to

00:06:33,199 --> 00:06:37,249
say that when a node crashes all the

00:06:35,899 --> 00:06:38,749
other nodes in the cluster should know

00:06:37,249 --> 00:06:41,809
about the fact that this node has

00:06:38,749 --> 00:06:43,879
crashed so if if it's not complete and

00:06:41,809 --> 00:06:44,840
someone will still believe that the

00:06:43,879 --> 00:06:46,310
notice there

00:06:44,840 --> 00:06:48,020
and that's not good so that's

00:06:46,310 --> 00:06:50,000
completeness it's the first thing we

00:06:48,020 --> 00:06:51,410
want out of a failure detector the

00:06:50,000 --> 00:06:52,669
second thing we want out of a failure

00:06:51,410 --> 00:06:55,490
detector is accuracy

00:06:52,669 --> 00:06:58,250
we don't want false positives we don't

00:06:55,490 --> 00:07:00,760
want healthy nodes to start suspecting

00:06:58,250 --> 00:07:05,960
other healthy nodes of having failed and

00:07:00,760 --> 00:07:09,860
that are you know that are the two main

00:07:05,960 --> 00:07:12,470
things that we're concerned with now it

00:07:09,860 --> 00:07:15,050
turns out that in practice your real

00:07:12,470 --> 00:07:18,080
life concerns pesky little things like

00:07:15,050 --> 00:07:19,610
you know speed and network message wrote

00:07:18,080 --> 00:07:23,720
that we have to think of when we

00:07:19,610 --> 00:07:30,290
implement failure detectors and that

00:07:23,720 --> 00:07:32,000
play an important role so let's start

00:07:30,290 --> 00:07:34,490
with seeing how we could do that the

00:07:32,000 --> 00:07:36,350
first wall we're hitting is an

00:07:34,490 --> 00:07:39,020
impossibility results so in distributed

00:07:36,350 --> 00:07:40,880
systems research we don't know so much

00:07:39,020 --> 00:07:42,979
what we can do but we know a few things

00:07:40,880 --> 00:07:46,100
we can't do and one of the things we

00:07:42,979 --> 00:07:50,450
can't do is to build an it's a failure

00:07:46,100 --> 00:07:52,580
detector algorithm that can be both have

00:07:50,450 --> 00:07:55,010
that both has completeness and accuracy

00:07:52,580 --> 00:07:58,100
at the same time if we run that over an

00:07:55,010 --> 00:08:01,010
asynchronous and reliable network and we

00:07:58,100 --> 00:08:05,750
only got these asynchronous and reliable

00:08:01,010 --> 00:08:07,669
networks um so we can't do that so what

00:08:05,750 --> 00:08:09,919
do we do we make trade-offs that's one

00:08:07,669 --> 00:08:11,599
of the things we do we have to make

00:08:09,919 --> 00:08:13,880
choices so we talked about strong to

00:08:11,599 --> 00:08:16,250
weak completeness we're all or some non

00:08:13,880 --> 00:08:18,919
faulty members detect a crash and we

00:08:16,250 --> 00:08:22,599
talk about strong to weak accuracy when

00:08:18,919 --> 00:08:27,740
there are no or some false positives and

00:08:22,599 --> 00:08:30,500
in practice applications go for strong

00:08:27,740 --> 00:08:33,709
completeness and choose a weaker form of

00:08:30,500 --> 00:08:36,200
accuracy that's what most applications

00:08:33,709 --> 00:08:37,940
go for because the scenario where you

00:08:36,200 --> 00:08:39,589
have to handle with you have to deal

00:08:37,940 --> 00:08:41,209
with nodes that think that the other

00:08:39,589 --> 00:08:43,940
node is still late that's a lot harder

00:08:41,209 --> 00:08:46,100
to sort of go around so they go and

00:08:43,940 --> 00:08:50,690
prefer tools to sort of have a flakiness

00:08:46,100 --> 00:08:52,910
in the in the failure detection there's

00:08:50,690 --> 00:08:56,180
two strategies for failure detection one

00:08:52,910 --> 00:08:58,640
of them is heartbeats so if you don't

00:08:56,180 --> 00:09:00,830
receive a heartbeat from a node

00:08:58,640 --> 00:09:04,190
you sort of start assuming that it's

00:09:00,830 --> 00:09:06,470
gone there's another one called the ping

00:09:04,190 --> 00:09:08,240
ping pong so you go and do a request

00:09:06,470 --> 00:09:10,610
response kind of thing you send a ping

00:09:08,240 --> 00:09:13,790
and you expect a pong back that's what a

00:09:10,610 --> 00:09:18,410
cluster uses the ping pong going back

00:09:13,790 --> 00:09:21,410
and forth now let me talk a little bit

00:09:18,410 --> 00:09:23,060
about failure detector types the first I

00:09:21,410 --> 00:09:24,620
want to talk about is the fee adaptive

00:09:23,060 --> 00:09:27,470
accrual failure detector which is

00:09:24,620 --> 00:09:29,900
obviously a very cool name and it's an

00:09:27,470 --> 00:09:31,760
adaptive failure detector which means it

00:09:29,900 --> 00:09:35,900
tries to adapt to changing Network

00:09:31,760 --> 00:09:37,430
conditions link quality etc and what fee

00:09:35,900 --> 00:09:39,710
does is it introduces the notion of

00:09:37,430 --> 00:09:42,800
accrual failure detection so rather than

00:09:39,710 --> 00:09:46,640
saying look the this node is is gone or

00:09:42,800 --> 00:09:48,140
it is there this binary view it gives

00:09:46,640 --> 00:09:52,430
the failure detector confused a

00:09:48,140 --> 00:09:54,800
suspicion value and with that value as

00:09:52,430 --> 00:09:56,330
we'll see we'll be able to make more

00:09:54,800 --> 00:09:58,520
informed decisions so this was made

00:09:56,330 --> 00:10:00,830
popular by Cassandra because they tried

00:09:58,520 --> 00:10:02,420
out a few Goss and failure detectors and

00:10:00,830 --> 00:10:04,250
they needed something that scaled for

00:10:02,420 --> 00:10:05,660
hundreds of nodes and that's how you

00:10:04,250 --> 00:10:08,450
know it got more and more in the

00:10:05,660 --> 00:10:10,850
mainstream what you can see on the graph

00:10:08,450 --> 00:10:12,560
here is for small thresholds you have a

00:10:10,850 --> 00:10:15,410
very fast detection time for higher

00:10:12,560 --> 00:10:18,620
thresholds you have a slow detection you

00:10:15,410 --> 00:10:20,140
have a slower detection time right

00:10:18,620 --> 00:10:23,240
[Music]

00:10:20,140 --> 00:10:25,430
conversely if you have a low threshold

00:10:23,240 --> 00:10:27,530
the failure rate mistake rate is much

00:10:25,430 --> 00:10:28,970
higher than if you have a high threshold

00:10:27,530 --> 00:10:31,760
so there again you have to make a

00:10:28,970 --> 00:10:33,920
trade-off so the original paper says

00:10:31,760 --> 00:10:36,260
that there is a sweet spot between 8 and

00:10:33,920 --> 00:10:38,810
12 in my experience if you run on AWS

00:10:36,260 --> 00:10:40,340
you want to go for 12 13 or more because

00:10:38,810 --> 00:10:41,720
that's just I'm not gonna continue

00:10:40,340 --> 00:10:45,140
talking about that but that's just how

00:10:41,720 --> 00:10:46,910
it is and here's an example how this the

00:10:45,140 --> 00:10:50,410
idea of this failure detectors say you

00:10:46,910 --> 00:10:53,690
have a master node and some worker nodes

00:10:50,410 --> 00:10:56,900
so what you would do there is if if the

00:10:53,690 --> 00:10:59,450
if the master sees that one of the

00:10:56,900 --> 00:11:02,600
workers has the suspicion value getting

00:10:59,450 --> 00:11:04,850
hired in 8 you send stop sending it new

00:11:02,600 --> 00:11:06,740
work because maybe there is a problem if

00:11:04,850 --> 00:11:08,390
it gets higher than 10 you could say ok

00:11:06,740 --> 00:11:10,370
there is this guy's in trouble I'm gonna

00:11:08,390 --> 00:11:12,010
stop we're gonna start rebalancing their

00:11:10,370 --> 00:11:14,050
work to some other work and

00:11:12,010 --> 00:11:17,290
above 12 just kicking it out and

00:11:14,050 --> 00:11:20,530
removing it from my from my cluster it's

00:11:17,290 --> 00:11:23,620
it's not there anymore and so these are

00:11:20,530 --> 00:11:27,430
the these are the this is the initial

00:11:23,620 --> 00:11:29,710
idea behind the Disick rule failure

00:11:27,430 --> 00:11:33,610
detection I think in practice especially

00:11:29,710 --> 00:11:35,830
for some applications it's it things

00:11:33,610 --> 00:11:37,960
happen so fast you've got an interval a

00:11:35,830 --> 00:11:39,820
ping interval that's so fast that you

00:11:37,960 --> 00:11:41,560
can't really use this it's not really

00:11:39,820 --> 00:11:43,600
used in practice so you sort of have to

00:11:41,560 --> 00:11:44,380
find which spot you want to use and for

00:11:43,600 --> 00:11:46,540
your network

00:11:44,380 --> 00:11:49,360
turns out again if the link quality

00:11:46,540 --> 00:11:51,060
changes towards the day you you end up

00:11:49,360 --> 00:11:53,740
with a lot of flakiness

00:11:51,060 --> 00:11:59,530
there is another adaptive actual failure

00:11:53,740 --> 00:12:02,890
detector which is the new one and this

00:11:59,530 --> 00:12:05,470
one is so it's it's faster than fee its

00:12:02,890 --> 00:12:07,360
puff so it's slightly better but also

00:12:05,470 --> 00:12:10,150
the most the biggest difference with fee

00:12:07,360 --> 00:12:14,050
is I found it it did well or better than

00:12:10,150 --> 00:12:15,580
than fee in you know cloud environments

00:12:14,050 --> 00:12:17,710
where you don't really have a network

00:12:15,580 --> 00:12:20,860
but you have a virtual network or

00:12:17,710 --> 00:12:22,810
something and then it's also a lot

00:12:20,860 --> 00:12:25,540
easier to implement so the value is a

00:12:22,810 --> 00:12:28,480
lot simpler to compute so I implemented

00:12:25,540 --> 00:12:31,120
this one for our cluster and run a few

00:12:28,480 --> 00:12:33,130
experiments on it and it's nice but it's

00:12:31,120 --> 00:12:35,140
not you know you don't get that much of

00:12:33,130 --> 00:12:39,250
again still as an adaptive accrual

00:12:35,140 --> 00:12:41,650
failure detection nothing has changed so

00:12:39,250 --> 00:12:45,070
here is a new one and that's the swing

00:12:41,650 --> 00:12:47,290
failure detector as you swim lazily

00:12:45,070 --> 00:12:50,530
through the mill you the secrets of the

00:12:47,290 --> 00:12:54,100
world will infect you and swim is rooted

00:12:50,530 --> 00:12:56,380
in biology and infectious diseases it

00:12:54,100 --> 00:12:58,120
actually sites so then the site's quite

00:12:56,380 --> 00:13:00,730
a few papers that come from the biology

00:12:58,120 --> 00:13:03,100
and so idea is to just infect people so

00:13:00,730 --> 00:13:05,200
swim is not only a failure detectors

00:13:03,100 --> 00:13:08,670
it's two components it's got both the

00:13:05,200 --> 00:13:11,740
failure detection and the the gossip

00:13:08,670 --> 00:13:13,330
component the dissemination component in

00:13:11,740 --> 00:13:16,660
it so here I'm talking about the failure

00:13:13,330 --> 00:13:19,810
detector part of it and the idea is they

00:13:16,660 --> 00:13:22,960
wanted to build a protocol that scales

00:13:19,810 --> 00:13:25,120
well and not exponentially so or

00:13:22,960 --> 00:13:25,840
linearly so for many nodes it's not

00:13:25,120 --> 00:13:28,000
because you have

00:13:25,840 --> 00:13:30,610
cluster that you end up with having to

00:13:28,000 --> 00:13:32,650
wait long or things like that and

00:13:30,610 --> 00:13:36,420
there's a few ways in which swim does

00:13:32,650 --> 00:13:40,060
this so what one thing it does is that

00:13:36,420 --> 00:13:41,650
members that have a problem are first

00:13:40,060 --> 00:13:45,010
suspected but they're not immediately

00:13:41,650 --> 00:13:47,350
removed and then the suspicion spreads

00:13:45,010 --> 00:13:49,420
through gossip and if the node gets it

00:13:47,350 --> 00:13:51,340
it can say hey I'm still there don't

00:13:49,420 --> 00:13:53,740
remove me you know it can it can go back

00:13:51,340 --> 00:13:54,820
and and say I'm still there so that's

00:13:53,740 --> 00:14:04,960
one of the techniques the other

00:13:54,820 --> 00:14:11,770
techniques is is the one of of indirect

00:14:04,960 --> 00:14:13,900
probing so we ping we we choose one we

00:14:11,770 --> 00:14:14,560
chose one Road know that random that we

00:14:13,900 --> 00:14:16,690
want to monitor

00:14:14,560 --> 00:14:18,820
then we ping it and then that guy was

00:14:16,690 --> 00:14:21,520
running a garbage collection because

00:14:18,820 --> 00:14:23,290
it's a Java process and so the AK is too

00:14:21,520 --> 00:14:26,470
slow and it doesn't make it back in time

00:14:23,290 --> 00:14:29,230
so instead of right away suspecting it

00:14:26,470 --> 00:14:32,440
what we do is that we send a ping

00:14:29,230 --> 00:14:34,570
request message to other nodes randomly

00:14:32,440 --> 00:14:37,120
chosen as well and they go and they

00:14:34,570 --> 00:14:40,810
probe that node and then maybe one act

00:14:37,120 --> 00:14:45,640
makes it back and then we can act back

00:14:40,810 --> 00:14:47,650
to the original node and we know it's

00:14:45,640 --> 00:14:49,990
there okay and this happens in one

00:14:47,650 --> 00:14:52,210
protocol period and it's it's quite okay

00:14:49,990 --> 00:14:54,490
and it reduces all of this is just to

00:14:52,210 --> 00:14:56,680
reduce the amount of false positives now

00:14:54,490 --> 00:14:59,320
it turns out that in practice so this

00:14:56,680 --> 00:15:03,250
paper is from I think 2002 or something

00:14:59,320 --> 00:15:06,280
it turns out that that in nowadays on

00:15:03,250 --> 00:15:10,870
modern data centers Swim doesn't do well

00:15:06,280 --> 00:15:13,360
enough by itself and then the people at

00:15:10,870 --> 00:15:17,920
Hoshi Corp figured this out Oishi cope

00:15:13,360 --> 00:15:20,650
they're doing terraform console volt all

00:15:17,920 --> 00:15:22,930
of these up dev ops kind of tools they

00:15:20,650 --> 00:15:25,360
also have clusters and they implemented

00:15:22,930 --> 00:15:27,280
swim and they found that swim was not

00:15:25,360 --> 00:15:29,050
doing so well in terms of failure did

00:15:27,280 --> 00:15:30,880
like there were too many failures still

00:15:29,050 --> 00:15:33,940
false failures were what I said what

00:15:30,880 --> 00:15:36,550
fair uses false positives right there

00:15:33,940 --> 00:15:38,230
are too many false positives in swim so

00:15:36,550 --> 00:15:39,640
they have this implementation of a

00:15:38,230 --> 00:15:41,410
membership service called men

00:15:39,640 --> 00:15:44,290
list which is written and go is

00:15:41,410 --> 00:15:46,120
open-source and it's an extension to the

00:15:44,290 --> 00:15:48,070
swim protocol it has three techniques

00:15:46,120 --> 00:15:49,540
that it uses and if you add all of them

00:15:48,070 --> 00:15:53,590
and you'll all of them what you end up

00:15:49,540 --> 00:15:56,170
with is drastically less false positives

00:15:53,590 --> 00:15:59,410
so you are at less than 2% in comparison

00:15:56,170 --> 00:16:01,330
to vanilla swim and I think you know by

00:15:59,410 --> 00:16:03,220
now I haven't found anything that's more

00:16:01,330 --> 00:16:05,080
state-of-the-art than this and has

00:16:03,220 --> 00:16:06,730
better results in real life applications

00:16:05,080 --> 00:16:08,530
than this so for the moment so this is

00:16:06,730 --> 00:16:16,960
pretty much the state of the art that I

00:16:08,530 --> 00:16:18,190
found um and yeah so I think we're

00:16:16,960 --> 00:16:20,440
through with failure detector I mean I

00:16:18,190 --> 00:16:24,280
could go on for more hours but I don't

00:16:20,440 --> 00:16:32,170
think I have that time so let me go for

00:16:24,280 --> 00:16:34,510
next topic anyone knows this album let's

00:16:32,170 --> 00:16:37,060
pulse 95

00:16:34,510 --> 00:16:40,110
I think it's alive it's a live album so

00:16:37,060 --> 00:16:43,060
that's maybe why

00:16:40,110 --> 00:16:44,440
and I think pulse is really you know

00:16:43,060 --> 00:16:48,610
translates well to this idea of

00:16:44,440 --> 00:16:51,070
disseminating spreading information so

00:16:48,610 --> 00:16:53,410
what do we need we need to talk about

00:16:51,070 --> 00:16:54,550
numbers joining members leaving and

00:16:53,410 --> 00:16:56,500
members failing this sort of information

00:16:54,550 --> 00:16:58,720
basic information we want to spread

00:16:56,500 --> 00:17:03,660
across about in a cluster when it comes

00:16:58,720 --> 00:17:06,130
to membership information okay and then

00:17:03,660 --> 00:17:12,370
there is a few strategies the first one

00:17:06,130 --> 00:17:18,280
is multicast and we have a problem with

00:17:12,370 --> 00:17:22,300
multicast support because we just don't

00:17:18,280 --> 00:17:26,260
have it ok our we have it in theory

00:17:22,300 --> 00:17:28,530
there is IP multicast there is even net

00:17:26,260 --> 00:17:32,650
word like a hardware level multicast

00:17:28,530 --> 00:17:35,350
there is UDP multicast but none on this

00:17:32,650 --> 00:17:36,880
is readily accepted if you go to see

00:17:35,350 --> 00:17:39,430
your sister demons in the data center

00:17:36,880 --> 00:17:44,080
say hey can we have UDP multicast they

00:17:39,430 --> 00:17:45,640
go like so multicast is not something

00:17:44,080 --> 00:17:48,100
that's readily available and even if it

00:17:45,640 --> 00:17:51,010
were we would still have this problem of

00:17:48,100 --> 00:17:53,440
how do we get things in in order like if

00:17:51,010 --> 00:17:56,710
we need to keep ordering between

00:17:53,440 --> 00:17:58,680
different multicast messages we we end

00:17:56,710 --> 00:18:01,330
up there is this very nice 50 pages

00:17:58,680 --> 00:18:04,000
survey on total order broadcast and

00:18:01,330 --> 00:18:07,930
multicast algorithms buy exactly Defago

00:18:04,000 --> 00:18:09,850
and yeah so and yet this one is sort of

00:18:07,930 --> 00:18:13,000
shows you a glimpse of what it means to

00:18:09,850 --> 00:18:15,670
reliably work with multicast so it's

00:18:13,000 --> 00:18:16,780
it's hard it's it's still not there so

00:18:15,670 --> 00:18:19,930
we don't have it so what do we do

00:18:16,780 --> 00:18:26,080
instead you ask well we go back to the

00:18:19,930 --> 00:18:29,740
year 2000 anyone remembers Napster you

00:18:26,080 --> 00:18:32,230
can download this these music files in

00:18:29,740 --> 00:18:37,660
this mp3 format it was new and and all

00:18:32,230 --> 00:18:40,210
the ill and free and and so it turns out

00:18:37,660 --> 00:18:42,790
that because of pair two pair there was

00:18:40,210 --> 00:18:43,930
a lot of research done with the same

00:18:42,790 --> 00:18:45,850
thing because what you have in pair two

00:18:43,930 --> 00:18:47,710
pair systems is just a big ring or a set

00:18:45,850 --> 00:18:49,210
of big rings and you still want to

00:18:47,710 --> 00:18:50,560
search for your files everywhere so how

00:18:49,210 --> 00:18:52,480
do we get to where the cross what do you

00:18:50,560 --> 00:18:55,120
search how do we how do you pass things

00:18:52,480 --> 00:18:58,170
on how do you and and that's where all

00:18:55,120 --> 00:19:02,110
these gossip protocols were developed

00:18:58,170 --> 00:19:04,000
and and gossip protocols the basic idea

00:19:02,110 --> 00:19:06,480
here is and you don't see the animation

00:19:04,000 --> 00:19:10,110
because this is a static PDF file but

00:19:06,480 --> 00:19:12,910
what you would see is normally

00:19:10,110 --> 00:19:14,140
inode oh maybe there is something like

00:19:12,910 --> 00:19:16,000
no there isn't

00:19:14,140 --> 00:19:19,750
anyway what you would what you do is

00:19:16,000 --> 00:19:22,030
that each tick of the clock you one node

00:19:19,750 --> 00:19:24,010
sends the gossip to another node at each

00:19:22,030 --> 00:19:26,980
tick of the clock at protocol period one

00:19:24,010 --> 00:19:30,970
you would have one node sends a message

00:19:26,980 --> 00:19:34,000
to the first one then at tick two both

00:19:30,970 --> 00:19:37,270
nodes will send the message messages to

00:19:34,000 --> 00:19:39,370
other random nose at tick three all

00:19:37,270 --> 00:19:42,490
three nodes that got the message send it

00:19:39,370 --> 00:19:44,140
to other random nodes so at the end of

00:19:42,490 --> 00:19:46,390
the day what you have is in a very few

00:19:44,140 --> 00:19:48,280
ticks you you spread the word across

00:19:46,390 --> 00:19:52,650
quite fast okay

00:19:48,280 --> 00:19:56,860
and now that's the oldest form of of

00:19:52,650 --> 00:20:01,780
random gossip for failure detection in

00:19:56,860 --> 00:20:03,100
this case and there is more structured

00:20:01,780 --> 00:20:04,300
ones because random is not very

00:20:03,100 --> 00:20:06,100
deterministic so

00:20:04,300 --> 00:20:08,380
you have is round-robin for example

00:20:06,100 --> 00:20:10,540
where you go and spread things in a

00:20:08,380 --> 00:20:12,810
round robin fashion then this binary

00:20:10,540 --> 00:20:15,970
round robin which is a little bit faster

00:20:12,810 --> 00:20:20,920
and also round robin with sequence check

00:20:15,970 --> 00:20:23,080
which lets you sort of know when gossip

00:20:20,920 --> 00:20:24,910
message should be arriving and if it

00:20:23,080 --> 00:20:26,740
doesn't and you can take some action now

00:20:24,910 --> 00:20:28,690
for some reason this hasn't this idea

00:20:26,740 --> 00:20:30,490
hasn't caught on so this paper was I

00:20:28,690 --> 00:20:32,620
found it quite nice but some reason I

00:20:30,490 --> 00:20:34,780
haven't seen this technique being used

00:20:32,620 --> 00:20:38,020
at all in modern systems they just all

00:20:34,780 --> 00:20:40,270
go for in random gossip maybe that also

00:20:38,020 --> 00:20:42,430
has to do with you know all of our new

00:20:40,270 --> 00:20:44,170
cloud stuff we just add and remove nodes

00:20:42,430 --> 00:20:46,930
and there is a lot of randomness in

00:20:44,170 --> 00:20:48,700
there anyway so these determinist more

00:20:46,930 --> 00:20:52,150
deterministic approaches to doing things

00:20:48,700 --> 00:20:54,130
doesn't quite work and then it is a

00:20:52,150 --> 00:20:56,320
third thing we can do we can piggyback

00:20:54,130 --> 00:20:58,210
on another protocol so that's what swin

00:20:56,320 --> 00:21:00,130
does it's called this infection stag

00:20:58,210 --> 00:21:02,170
gossip so in swim you have a failure

00:21:00,130 --> 00:21:04,120
detection component which has a protocol

00:21:02,170 --> 00:21:06,100
the protocol is paying ACK and ping

00:21:04,120 --> 00:21:08,230
requests so we're these three type of

00:21:06,100 --> 00:21:12,280
types of messages but there's still a

00:21:08,230 --> 00:21:13,900
bit of space left on the messages okay

00:21:12,280 --> 00:21:16,060
so that's just a header that says what

00:21:13,900 --> 00:21:18,430
type it is but you still have some some

00:21:16,060 --> 00:21:20,710
some space in a message so you fill the

00:21:18,430 --> 00:21:22,600
rest with gossip information or with a

00:21:20,710 --> 00:21:25,440
subset of the gossip and that way you

00:21:22,600 --> 00:21:27,970
sort of spread bits and pieces of your

00:21:25,440 --> 00:21:29,800
the data that you want to spread you

00:21:27,970 --> 00:21:32,680
piggyback on top of these things and and

00:21:29,800 --> 00:21:33,700
I think this is very nice way of doing

00:21:32,680 --> 00:21:37,090
things because you don't have to

00:21:33,700 --> 00:21:39,940
introduce special gossip messages okay

00:21:37,090 --> 00:21:43,090
you you don't add more overhead but you

00:21:39,940 --> 00:21:48,870
just end up having an I think I'll sit

00:21:43,090 --> 00:21:48,870
there that that just piggyback somewhere

00:21:49,290 --> 00:21:57,580
but then you ask what do you even gossip

00:21:52,540 --> 00:22:04,150
about and one thing we can do is say

00:21:57,580 --> 00:22:05,050
look this is not a a has seen a zero

00:22:04,150 --> 00:22:08,620
seconds ago

00:22:05,050 --> 00:22:10,510
I am node a so I know that I'm there I

00:22:08,620 --> 00:22:14,380
always know that I'm there because I'm a

00:22:10,510 --> 00:22:18,000
I have seen B one second ago I have seen

00:22:14,380 --> 00:22:22,570
C three seconds ago now node B

00:22:18,000 --> 00:22:26,200
may have another view of the world it

00:22:22,570 --> 00:22:28,360
has seen a 3 seconds ago it has seen B 0

00:22:26,200 --> 00:22:33,310
seconds ago because it's B and it has in

00:22:28,360 --> 00:22:35,890
C one second I go okay and if these two

00:22:33,310 --> 00:22:40,300
were to exchange their gossip what I

00:22:35,890 --> 00:22:42,490
would end up with is a has seen a zero

00:22:40,300 --> 00:22:44,560
seconds ago B zero seconds ago and C one

00:22:42,490 --> 00:22:46,510
second ago we took out we merge this

00:22:44,560 --> 00:22:50,830
information and by merging this

00:22:46,510 --> 00:22:53,080
information we have now an updated

00:22:50,830 --> 00:22:54,490
gossip message and this gossip merging

00:22:53,080 --> 00:22:56,800
is something extremely common that this

00:22:54,490 --> 00:23:00,280
is done in many things in this example

00:22:56,800 --> 00:23:03,460
this is a failure detection gossip and

00:23:00,280 --> 00:23:06,700
what you would do here is if in one of

00:23:03,460 --> 00:23:09,220
these tables you end up with a you know

00:23:06,700 --> 00:23:11,110
a last scene that crosses I don't know

00:23:09,220 --> 00:23:13,270
five seconds or eight seconds or

00:23:11,110 --> 00:23:16,090
something like this you would end up

00:23:13,270 --> 00:23:19,750
just kicking that no doubt because

00:23:16,090 --> 00:23:23,580
nobody has seen it after eight seconds

00:23:19,750 --> 00:23:23,580
so we can assume that it has failed

00:23:23,970 --> 00:23:29,760
there's a few gossip optimizations that

00:23:26,410 --> 00:23:32,620
we can do a cluster does for example

00:23:29,760 --> 00:23:35,410
keep and maintain as part of the gossip

00:23:32,620 --> 00:23:38,080
a list of nodes that have received a

00:23:35,410 --> 00:23:39,850
certain version of a gossip that means

00:23:38,080 --> 00:23:41,770
that when a node is about to gossip but

00:23:39,850 --> 00:23:45,310
it will be able to do is to say hey

00:23:41,770 --> 00:23:47,380
these other nodes don't probably haven't

00:23:45,310 --> 00:23:49,420
seen the gossip the other the gossip

00:23:47,380 --> 00:23:51,880
message yet so let me talk to them

00:23:49,420 --> 00:23:53,590
rather than to do ones that I know have

00:23:51,880 --> 00:23:56,410
already received and seen the latest

00:23:53,590 --> 00:23:59,470
version of the gossip akka cluster also

00:23:56,410 --> 00:24:01,000
speeds up gossip when less than half of

00:23:59,470 --> 00:24:03,550
the members have seen the latest gossip

00:24:01,000 --> 00:24:05,470
so this can happen for example when you

00:24:03,550 --> 00:24:07,360
are about to when you're starting the

00:24:05,470 --> 00:24:09,970
thing up or when there's a network

00:24:07,360 --> 00:24:15,130
partition everything gets is a bit

00:24:09,970 --> 00:24:17,830
shaky so what you have there is just a

00:24:15,130 --> 00:24:19,870
way to spread things faster okay to

00:24:17,830 --> 00:24:21,640
reach convergence again faster

00:24:19,870 --> 00:24:24,280
convergence is when everybody in the

00:24:21,640 --> 00:24:26,410
cluster has seen the same has the same

00:24:24,280 --> 00:24:28,210
idea of what the cluster is or should be

00:24:26,410 --> 00:24:30,970
when everybody has seen the same

00:24:28,210 --> 00:24:31,570
information and then in Lifeguard they

00:24:30,970 --> 00:24:34,600
have an ant

00:24:31,570 --> 00:24:36,550
entropy mechanism in in lifeguard so

00:24:34,600 --> 00:24:39,100
lifeguard is a swim extension and swim

00:24:36,550 --> 00:24:43,000
by default uses UDP to sort of gossip

00:24:39,100 --> 00:24:44,890
things about and that's sort of it's a

00:24:43,000 --> 00:24:46,750
bit you know there is entropy happening

00:24:44,890 --> 00:24:48,040
there because UDP messages can get lost

00:24:46,750 --> 00:24:49,210
especially when the network is

00:24:48,040 --> 00:24:52,540
unreliable or unstable

00:24:49,210 --> 00:24:55,300
so what lifeguard does is it does it

00:24:52,540 --> 00:24:57,430
takes sometimes it picks one node picks

00:24:55,300 --> 00:25:00,850
another node at random and there's a

00:24:57,430 --> 00:25:03,370
full TCP sink of the gossip state over

00:25:00,850 --> 00:25:05,860
the TCP link which is more reliable and

00:25:03,370 --> 00:25:08,200
that way we reduce the entropy and that

00:25:05,860 --> 00:25:12,000
really helps in sort of recovering post

00:25:08,200 --> 00:25:16,540
network partition makes things faster

00:25:12,000 --> 00:25:18,880
and that's about dissemination now that

00:25:16,540 --> 00:25:21,490
brings us to our third and last topic

00:25:18,880 --> 00:25:27,250
here and does anyone know what this

00:25:21,490 --> 00:25:30,760
album is momentary lapse of reason very

00:25:27,250 --> 00:25:36,010
nice and I think that is accurate

00:25:30,760 --> 00:25:37,960
description of consensus so consensus

00:25:36,010 --> 00:25:42,190
reaching consensus in a distributed

00:25:37,960 --> 00:25:46,170
system that's hard and has driven many

00:25:42,190 --> 00:25:48,730
people insane including me at times and

00:25:46,170 --> 00:25:50,290
let's start with an impossibility result

00:25:48,730 --> 00:25:52,120
the one of group membership which is

00:25:50,290 --> 00:25:54,130
unfortunate because we try to have a

00:25:52,120 --> 00:25:57,400
group membership service but it's not

00:25:54,130 --> 00:25:59,050
possible which is to say that group

00:25:57,400 --> 00:26:01,230
membership with a single group or

00:25:59,050 --> 00:26:04,030
primary partitioning it's called is

00:26:01,230 --> 00:26:05,920
impossible when there is at least one

00:26:04,030 --> 00:26:08,410
node that is suspected of having failed

00:26:05,920 --> 00:26:10,840
so from the moment on that your failure

00:26:08,410 --> 00:26:12,670
detector says hey these guys maybe

00:26:10,840 --> 00:26:15,340
they're maybe not

00:26:12,670 --> 00:26:18,730
you can't readily assume that there is

00:26:15,340 --> 00:26:20,470
only one group left and you could for a

00:26:18,730 --> 00:26:24,580
very long time the research community

00:26:20,470 --> 00:26:27,310
was like but you know maybe just maybe

00:26:24,580 --> 00:26:30,520
if we ignore that node and the rest

00:26:27,310 --> 00:26:33,640
happily moves on we were going we're

00:26:30,520 --> 00:26:37,090
good and this this this was disproved in

00:26:33,640 --> 00:26:38,950
96 that on asynchronous networks you

00:26:37,090 --> 00:26:40,510
can't have that you will end up with

00:26:38,950 --> 00:26:42,550
several partitions and that's the

00:26:40,510 --> 00:26:43,990
problem of this split brain where you

00:26:42,550 --> 00:26:45,010
have many partitions or different

00:26:43,990 --> 00:26:46,540
partitions or everyone

00:26:45,010 --> 00:26:54,280
it goes in their own little cluster of

00:26:46,540 --> 00:26:56,260
OneNote especially on AWS so we can't

00:26:54,280 --> 00:26:58,690
have this and what we have to do again

00:26:56,260 --> 00:27:02,560
is is sort of Trados but one first thing

00:26:58,690 --> 00:27:04,720
that we're going to do here is or that

00:27:02,560 --> 00:27:06,400
we shouldn't do is we should not make

00:27:04,720 --> 00:27:10,630
membership related decisions like things

00:27:06,400 --> 00:27:12,490
like adding nodes to the cluster or

00:27:10,630 --> 00:27:14,170
removing nodes from the cluster while

00:27:12,490 --> 00:27:15,970
they're nodes that are suspect evolving

00:27:14,170 --> 00:27:18,010
fade because if I remove or add things

00:27:15,970 --> 00:27:20,860
then suddenly my cluster has a different

00:27:18,010 --> 00:27:23,110
view of the world some nodes will think

00:27:20,860 --> 00:27:24,550
that these are the list of nodes some

00:27:23,110 --> 00:27:26,680
other nose will only think that there's

00:27:24,550 --> 00:27:29,320
another list of nodes so I'll end up

00:27:26,680 --> 00:27:31,660
with a different view of the world and

00:27:29,320 --> 00:27:35,290
then I'm inhaled and it's really hard to

00:27:31,660 --> 00:27:38,200
recover from that so um don't change

00:27:35,290 --> 00:27:39,940
make don't let nodes join or let don't

00:27:38,200 --> 00:27:44,320
let them leave when when you're in

00:27:39,940 --> 00:27:46,440
trouble so how do we reach consensus

00:27:44,320 --> 00:27:50,760
what do we do one first thing we do is

00:27:46,440 --> 00:27:55,750
we need to reach consensus on time and

00:27:50,760 --> 00:27:58,330
time so there is one paper so if there

00:27:55,750 --> 00:27:59,470
is only one paper if I can interest you

00:27:58,330 --> 00:28:02,320
a little bit in this if there is only

00:27:59,470 --> 00:28:03,970
one paper I would invite you to read at

00:28:02,320 --> 00:28:06,250
some point when you have time it's this

00:28:03,970 --> 00:28:07,990
one it's the it's lamp Leslie Lamport

00:28:06,250 --> 00:28:10,510
time clocks and the ordering of events

00:28:07,990 --> 00:28:14,290
in a distributed system this is one of

00:28:10,510 --> 00:28:16,240
the it won an ACM a word it's one of the

00:28:14,290 --> 00:28:20,530
most important papers in computer

00:28:16,240 --> 00:28:22,990
science I would argue and this is about

00:28:20,530 --> 00:28:24,730
how do you order things on different

00:28:22,990 --> 00:28:26,410
machines and processes that run on

00:28:24,730 --> 00:28:30,730
different machines how do you establish

00:28:26,410 --> 00:28:33,010
a partial order between events it also

00:28:30,730 --> 00:28:35,500
introduces the notion of a replicated

00:28:33,010 --> 00:28:38,320
state machine which is used we'll talk

00:28:35,500 --> 00:28:41,530
about it in consensus protocols it does

00:28:38,320 --> 00:28:43,660
a lot of this very foundational thinking

00:28:41,530 --> 00:28:46,150
in in terms of how we can build

00:28:43,660 --> 00:28:48,010
distributed systems and Lamport locks

00:28:46,150 --> 00:28:50,230
are basically a logical clock where

00:28:48,010 --> 00:28:51,700
events gets flagged with a certain

00:28:50,230 --> 00:28:54,970
version and then we can establish a

00:28:51,700 --> 00:28:57,730
partial order between them now Lamport

00:28:54,970 --> 00:28:58,020
locks on their own are not enough we

00:28:57,730 --> 00:29:00,600
need

00:28:58,020 --> 00:29:02,640
or so what do we do well we just make

00:29:00,600 --> 00:29:05,670
vectors of Lamport clocks these are

00:29:02,640 --> 00:29:07,440
called vector clocks and what you can do

00:29:05,670 --> 00:29:12,390
with this you can which orders between

00:29:07,440 --> 00:29:19,110
events and you can also flag events that

00:29:12,390 --> 00:29:22,050
happen at the same time and these two

00:29:19,110 --> 00:29:23,910
things are quite powerful and they're

00:29:22,050 --> 00:29:27,060
not to be confused with two more things

00:29:23,910 --> 00:29:29,280
which are version vectors and the more

00:29:27,060 --> 00:29:31,560
recent dotted version vectors which are

00:29:29,280 --> 00:29:33,120
extremely the same and often people sort

00:29:31,560 --> 00:29:36,480
of say they're the same but not because

00:29:33,120 --> 00:29:39,060
version vectors are concerned with

00:29:36,480 --> 00:29:41,970
conflict like replicas replicating data

00:29:39,060 --> 00:29:43,260
and detecting conflicts in replicas it

00:29:41,970 --> 00:29:45,960
turns out that both of them have

00:29:43,260 --> 00:29:47,370
extremely similar semantics but there

00:29:45,960 --> 00:29:48,690
are different there's a blog post that

00:29:47,370 --> 00:29:51,450
you can read about it that version

00:29:48,690 --> 00:29:52,950
vectors are not vector clocks and there

00:29:51,450 --> 00:29:55,350
is a subtle difference in sort of the

00:29:52,950 --> 00:29:59,970
implementation and it sort of garbage

00:29:55,350 --> 00:30:02,330
that these things produce and just to

00:29:59,970 --> 00:30:05,850
show you at least one line of code

00:30:02,330 --> 00:30:07,500
during this talk and to show you that

00:30:05,850 --> 00:30:11,880
all that I'm talking about here is not

00:30:07,500 --> 00:30:14,550
just theoretical things this is a kkuk

00:30:11,880 --> 00:30:16,800
lustres gossip message and what you can

00:30:14,550 --> 00:30:19,830
see there is that the version is a

00:30:16,800 --> 00:30:21,900
vector clock so when the gossip moves

00:30:19,830 --> 00:30:25,710
around in the and the spread around

00:30:21,900 --> 00:30:27,390
across this dissemination and when to so

00:30:25,710 --> 00:30:31,350
the way it works with ping ping pong

00:30:27,390 --> 00:30:33,530
sort of we sort of exchange a gossip and

00:30:31,350 --> 00:30:35,790
when the gossip gets sort of together

00:30:33,530 --> 00:30:39,390
diversion back very sorry the vector

00:30:35,790 --> 00:30:41,760
vector clock tells us is this a more

00:30:39,390 --> 00:30:45,420
recent version of the gossip than I have

00:30:41,760 --> 00:30:46,830
is it the same one is it an older one if

00:30:45,420 --> 00:30:49,890
it's the older one I sent back the

00:30:46,830 --> 00:30:54,270
newest version of the gossip or is it

00:30:49,890 --> 00:30:58,670
the same version and then I have a I

00:30:54,270 --> 00:31:00,750
have a conflict I need to merge things I

00:30:58,670 --> 00:31:02,730
it's the same version but the

00:31:00,750 --> 00:31:04,890
information in the message is not the

00:31:02,730 --> 00:31:08,550
same so so I can detect a conflict a I

00:31:04,890 --> 00:31:11,420
have to act up on that so it's really

00:31:08,550 --> 00:31:13,620
used in real world and the real world

00:31:11,420 --> 00:31:15,570
okay now another tool that we have at

00:31:13,620 --> 00:31:18,540
our disposal is replicated state

00:31:15,570 --> 00:31:22,980
machines someone working with state

00:31:18,540 --> 00:31:24,660
machines here people I mean any

00:31:22,980 --> 00:31:26,670
sufficiently complicated model class

00:31:24,660 --> 00:31:29,490
contains an ad hoc and formally

00:31:26,670 --> 00:31:32,100
specified bug-ridden slow implementation

00:31:29,490 --> 00:31:34,470
of half a state machine very nice quote

00:31:32,100 --> 00:31:36,600
by Pete for here I think you know state

00:31:34,470 --> 00:31:41,250
machines are really underrated tools

00:31:36,600 --> 00:31:43,500
that I don't understand why why we don't

00:31:41,250 --> 00:31:45,960
use them more I guess great support for

00:31:43,500 --> 00:31:50,250
you know finite state machine accurate

00:31:45,960 --> 00:31:55,830
even as a persistent FSM that's also

00:31:50,250 --> 00:31:57,420
nice and so let me give a few examples

00:31:55,830 --> 00:31:59,730
here again I don't have the gift it's a

00:31:57,420 --> 00:32:03,630
bit this should be an animation here so

00:31:59,730 --> 00:32:07,080
let me just animate it with my arms so

00:32:03,630 --> 00:32:09,240
let's say I have a client here this red

00:32:07,080 --> 00:32:11,820
thing or orange thing and these three

00:32:09,240 --> 00:32:14,700
things are servers and each server has

00:32:11,820 --> 00:32:17,370
these boxes is a state machine so what I

00:32:14,700 --> 00:32:21,180
would do here I want to store a value in

00:32:17,370 --> 00:32:24,180
a fail-safe way so what I do is I sent

00:32:21,180 --> 00:32:25,020
an event up tool into one of the these

00:32:24,180 --> 00:32:27,480
server nodes

00:32:25,020 --> 00:32:31,950
I sent the set of events that I want to

00:32:27,480 --> 00:32:34,890
save and then what the blue things are

00:32:31,950 --> 00:32:36,690
doing they're replicating the events in

00:32:34,890 --> 00:32:39,810
the same order using vector clocks for

00:32:36,690 --> 00:32:43,680
example 2d to other ones and each of the

00:32:39,810 --> 00:32:45,930
three nodes will apply the same events

00:32:43,680 --> 00:32:48,150
in the same order to the state machines

00:32:45,930 --> 00:32:49,590
so these three state machines will end

00:32:48,150 --> 00:32:51,180
up having the same value because they

00:32:49,590 --> 00:32:54,150
applied the exact same effect in the

00:32:51,180 --> 00:32:57,390
same order everywhere and that's way we

00:32:54,150 --> 00:32:59,430
can store things in a safe fashion if I

00:32:57,390 --> 00:33:02,790
have a 5 cluster node and I lose two

00:32:59,430 --> 00:33:04,950
nodes I still sort of have my my my data

00:33:02,790 --> 00:33:07,110
there my value being saved and this is a

00:33:04,950 --> 00:33:08,640
very sort of again this is it was

00:33:07,110 --> 00:33:09,870
introduced in Leslie Lamport

00:33:08,640 --> 00:33:12,780
time clocks and the ordering of events

00:33:09,870 --> 00:33:15,960
in a distributed system and it's it

00:33:12,780 --> 00:33:17,490
sounds really nice and now how do we

00:33:15,960 --> 00:33:20,070
implement it well the way we implement

00:33:17,490 --> 00:33:24,380
it to implement it we need a consensus

00:33:20,070 --> 00:33:24,380
protocol and

00:33:24,630 --> 00:33:30,730
you know in 98 Lamport published his

00:33:28,930 --> 00:33:34,090
paper the part-time Parliament

00:33:30,730 --> 00:33:36,190
introduces taxes and then at a

00:33:34,090 --> 00:33:38,590
conference later on people told him we

00:33:36,190 --> 00:33:40,630
don't understand how this works so he

00:33:38,590 --> 00:33:42,370
sort of rounded up a group of people and

00:33:40,630 --> 00:33:43,720
said hey this is how it works I'm

00:33:42,370 --> 00:33:45,610
expanding it to you and out of this

00:33:43,720 --> 00:33:47,920
explanation that he made he had this

00:33:45,610 --> 00:33:50,830
other paper in 2001 taxes made simple

00:33:47,920 --> 00:33:53,140
which sort of explains taxes in a simple

00:33:50,830 --> 00:33:55,960
way and then 13 years later there was a

00:33:53,140 --> 00:33:58,780
new paper published called in search of

00:33:55,960 --> 00:34:01,180
an understandable consensus algorithm so

00:33:58,780 --> 00:34:04,270
it seems that taxes made simple wasn't

00:34:01,180 --> 00:34:09,940
simple enough and taxes is a really nice

00:34:04,270 --> 00:34:12,130
brainteaser it's it's it's it's hard so

00:34:09,940 --> 00:34:14,950
praxis is one of them raft is one of

00:34:12,130 --> 00:34:17,440
them raft is really like mint was

00:34:14,950 --> 00:34:19,960
designed to be understood and taught and

00:34:17,440 --> 00:34:21,610
yeah it does that it's it's simpler it's

00:34:19,960 --> 00:34:23,320
it's easier to understand and then

00:34:21,610 --> 00:34:27,090
there's a very nice one that just came

00:34:23,320 --> 00:34:27,090
out it's two months old it's brand-new

00:34:27,180 --> 00:34:34,900
its CASP axis and CASP axis gets rid of

00:34:31,750 --> 00:34:37,780
the log so usually in in taxes and raft

00:34:34,900 --> 00:34:40,410
you have a log and it's it's called

00:34:37,780 --> 00:34:44,340
replicated state machines without logs

00:34:40,410 --> 00:34:47,470
it's a very nice approach I there is one

00:34:44,340 --> 00:34:49,450
implementation in Golders and and you

00:34:47,470 --> 00:34:51,370
know it's still very new so I think I

00:34:49,450 --> 00:34:54,310
expect we'll see more of that spreading

00:34:51,370 --> 00:34:57,460
out I think I think this is a quite a

00:34:54,310 --> 00:34:59,770
nice potential here so this is sort of

00:34:57,460 --> 00:35:01,810
consensus protocol this stuff you may

00:34:59,770 --> 00:35:03,130
have heard of before they're they're

00:35:01,810 --> 00:35:05,140
pretty traditional and their way of

00:35:03,130 --> 00:35:07,960
reaching consensus and but there is a

00:35:05,140 --> 00:35:10,570
more modern a different branch of of

00:35:07,960 --> 00:35:12,970
reaching consensus and it has another

00:35:10,570 --> 00:35:16,570
different type of semantics and that is

00:35:12,970 --> 00:35:20,200
the one of having strong event also

00:35:16,570 --> 00:35:22,270
eventual consistent consensus let's say

00:35:20,200 --> 00:35:24,700
it's using strong eventual consistency

00:35:22,270 --> 00:35:27,490
and these are CRD teas conflict-free

00:35:24,700 --> 00:35:29,440
replicated data types there's two

00:35:27,490 --> 00:35:32,020
families they're the ones that use the

00:35:29,440 --> 00:35:36,000
commutativity of operations and the ones

00:35:32,020 --> 00:35:36,000
that use the convergence of state and

00:35:36,460 --> 00:35:41,420
if you want to use the ones that commute

00:35:39,080 --> 00:35:43,250
where operations commute like one plus

00:35:41,420 --> 00:35:45,800
two plus is a commutative operation I

00:35:43,250 --> 00:35:49,700
can say 1 plus 2 is the same as 2 plus 1

00:35:45,800 --> 00:35:52,670
okay if I use these classes of ER duties

00:35:49,700 --> 00:35:54,110
I need a reliable transport because if I

00:35:52,670 --> 00:35:57,350
lose an operation it doesn't matter that

00:35:54,110 --> 00:35:59,450
it's commutative just lost the other one

00:35:57,350 --> 00:36:03,410
is convergence based on convergence

00:35:59,450 --> 00:36:06,470
state this is what you see here so we

00:36:03,410 --> 00:36:09,320
start all the nodes start with the value

00:36:06,470 --> 00:36:11,150
0 and then the first node up there sets

00:36:09,320 --> 00:36:13,730
the value to 1 and the second one sets

00:36:11,150 --> 00:36:15,680
the value to 4 and then we propagate

00:36:13,730 --> 00:36:17,210
that value down and the convergence

00:36:15,680 --> 00:36:20,690
function that we're using here is the

00:36:17,210 --> 00:36:21,470
maximum so the maximum on the third here

00:36:20,690 --> 00:36:25,760
down there

00:36:21,470 --> 00:36:29,240
this one it's the maximum of 0 and 4 is

00:36:25,760 --> 00:36:33,020
4 so we end up with 4 there and then the

00:36:29,240 --> 00:36:34,790
maximum between 1 & 4 is 4 so at the end

00:36:33,020 --> 00:36:37,850
of the day we end up with 4 everywhere

00:36:34,790 --> 00:36:39,980
so we have converged using this max and

00:36:37,850 --> 00:36:41,210
there is no room for conflict we don't

00:36:39,980 --> 00:36:43,010
end up in a situation where we could

00:36:41,210 --> 00:36:44,300
have something else in 4 and it's very

00:36:43,010 --> 00:36:47,420
nice because especially when you have a

00:36:44,300 --> 00:36:50,060
network partition and both sides get

00:36:47,420 --> 00:36:51,710
stuff written in them when you converge

00:36:50,060 --> 00:36:53,090
back you're going to converge back to

00:36:51,710 --> 00:36:54,890
the same value and when the network

00:36:53,090 --> 00:36:56,990
partition is recovered so that's that's

00:36:54,890 --> 00:36:59,780
quite nice a lot of very interesting

00:36:56,990 --> 00:37:03,500
research in that space it's still

00:36:59,780 --> 00:37:07,610
growing strong this one my favorite one

00:37:03,500 --> 00:37:11,960
is reaching consensus by conventions so

00:37:07,610 --> 00:37:14,420
for example a practical example here in

00:37:11,960 --> 00:37:16,520
a cluster there is a leader of the

00:37:14,420 --> 00:37:19,070
cluster the leader of the pack but it's

00:37:16,520 --> 00:37:21,560
not elected it's designed and the way

00:37:19,070 --> 00:37:23,960
it's designed is by ordering so you take

00:37:21,560 --> 00:37:27,160
all the nodes in all the members in the

00:37:23,960 --> 00:37:29,960
cluster you order them by IP address and

00:37:27,160 --> 00:37:31,760
you put the ones that are not fit for

00:37:29,960 --> 00:37:34,910
being a leader like the ones that have

00:37:31,760 --> 00:37:36,650
an inappropriate status at the very

00:37:34,910 --> 00:37:39,530
bottom and then you take the first one

00:37:36,650 --> 00:37:41,300
and all the nodes do that and so they

00:37:39,530 --> 00:37:43,100
end up with having the same idea of who

00:37:41,300 --> 00:37:44,630
the leader is but they haven't talked

00:37:43,100 --> 00:37:45,770
about it at all they haven't exchanged

00:37:44,630 --> 00:37:48,170
information they just use this

00:37:45,770 --> 00:37:50,670
convention the same is used for example

00:37:48,170 --> 00:37:52,560
if you'd in failure detection strategy

00:37:50,670 --> 00:37:56,160
when you use a heartbeat approach where

00:37:52,560 --> 00:37:59,330
the lack of message means that it there

00:37:56,160 --> 00:38:02,760
is a lack of it's gone so that this

00:37:59,330 --> 00:38:05,550
sometimes not sending data is as

00:38:02,760 --> 00:38:08,150
powerful as sending data so this is this

00:38:05,550 --> 00:38:14,490
is very a very nice way of reaching

00:38:08,150 --> 00:38:20,760
consensus that I quite like so let me

00:38:14,490 --> 00:38:24,690
talk a little bit about a cluster so a

00:38:20,760 --> 00:38:28,230
cluster at the bottom you have the

00:38:24,690 --> 00:38:30,240
membership layer that takes care of

00:38:28,230 --> 00:38:32,130
telling who is there who is not as

00:38:30,240 --> 00:38:33,570
felled etc of these things on top of

00:38:32,130 --> 00:38:37,080
that were several modules for example

00:38:33,570 --> 00:38:40,620
have distributed data that is using CR d

00:38:37,080 --> 00:38:42,450
T's for spreading values out replicating

00:38:40,620 --> 00:38:45,770
data in the India in the cluster

00:38:42,450 --> 00:38:48,630
we have cluster C so we run one

00:38:45,770 --> 00:38:51,180
singleton in the whole cluster and it

00:38:48,630 --> 00:38:53,280
takes care of sort of cleansing it over

00:38:51,180 --> 00:38:56,760
if the node on which the singleton lives

00:38:53,280 --> 00:38:59,580
crashes on top of singleton we have

00:38:56,760 --> 00:39:02,010
cluster sharding where we want to share

00:38:59,580 --> 00:39:04,320
data across many nodes because there's

00:39:02,010 --> 00:39:08,130
too much of them data or actually actors

00:39:04,320 --> 00:39:10,140
in this case also very well managed

00:39:08,130 --> 00:39:11,520
there on top of that you build your

00:39:10,140 --> 00:39:13,320
application so you have all these tools

00:39:11,520 --> 00:39:16,050
there is more of them I just mentioned

00:39:13,320 --> 00:39:18,990
these ones which are quite interesting

00:39:16,050 --> 00:39:20,670
and yeah there's routers that I should

00:39:18,990 --> 00:39:23,100
add to this thing like cluster where

00:39:20,670 --> 00:39:25,230
routers that know about the cluster and

00:39:23,100 --> 00:39:27,030
it can do load balancing and adaptive

00:39:25,230 --> 00:39:31,290
load balancing depending on the load of

00:39:27,030 --> 00:39:33,630
each machine so a cake luster uses the

00:39:31,290 --> 00:39:36,780
fie adaptive actual failure detector it

00:39:33,630 --> 00:39:39,870
uses a ping pong strategy for failure

00:39:36,780 --> 00:39:41,970
detection it uses actually a little bit

00:39:39,870 --> 00:39:43,920
modified version of fee which also takes

00:39:41,970 --> 00:39:45,890
into account the fact that the JV and

00:39:43,920 --> 00:39:49,950
has garbage collection pauses and then

00:39:45,890 --> 00:39:53,760
sometimes you know well you have to

00:39:49,950 --> 00:39:55,980
adjust things let's say in terms of

00:39:53,760 --> 00:39:58,560
dissemination we have random gossip but

00:39:55,980 --> 00:40:00,330
it's biased towards the nodes that may

00:39:58,560 --> 00:40:03,360
not have seen the latest version of a

00:40:00,330 --> 00:40:05,970
gossip in terms of consensus the lead

00:40:03,360 --> 00:40:07,530
is leader by convention and the

00:40:05,970 --> 00:40:09,900
membership decisions are driven by the

00:40:07,530 --> 00:40:13,230
leader joining and leaving this quite

00:40:09,900 --> 00:40:15,990
important we'll get back to it or it's

00:40:13,230 --> 00:40:18,960
put it like this the leader in a cluster

00:40:15,990 --> 00:40:21,210
will not let new nodes join in the in

00:40:18,960 --> 00:40:23,190
the traditional sense of things when

00:40:21,210 --> 00:40:25,800
there are nodes that are suspected

00:40:23,190 --> 00:40:27,900
having failed and the same thing for the

00:40:25,800 --> 00:40:29,910
leaving part at least in one definitions

00:40:27,900 --> 00:40:32,340
and one of the semantics so let's look

00:40:29,910 --> 00:40:34,230
at what happens if we're in a happy path

00:40:32,340 --> 00:40:38,670
if everything goes according to plan

00:40:34,230 --> 00:40:40,320
what happens is we join or joining then

00:40:38,670 --> 00:40:43,110
the leader decides that it's okay we can

00:40:40,320 --> 00:40:44,970
join now we're up and then we want to

00:40:43,110 --> 00:40:47,190
leave so we're in leaving state then the

00:40:44,970 --> 00:40:49,020
leader says yes now you can leave so

00:40:47,190 --> 00:40:50,670
we're exiting and then we're removed

00:40:49,020 --> 00:40:53,760
from the cluster and everything works

00:40:50,670 --> 00:40:56,100
according to plan and that's the dream

00:40:53,760 --> 00:40:58,050
and then the reality is is a bit

00:40:56,100 --> 00:40:59,730
different in reality things don't work

00:40:58,050 --> 00:41:03,150
pan out that that well so what we have

00:40:59,730 --> 00:41:04,920
often we join we're up then we become

00:41:03,150 --> 00:41:07,800
unreachable that's the failure detector

00:41:04,920 --> 00:41:11,390
that detects that this little FD thing

00:41:07,800 --> 00:41:17,010
here there then we're going down and

00:41:11,390 --> 00:41:20,970
then we're removed now there is one

00:41:17,010 --> 00:41:24,480
thing here that you may notice and that

00:41:20,970 --> 00:41:27,810
there is no leader here there is no

00:41:24,480 --> 00:41:31,710
failure detector there from unreachable

00:41:27,810 --> 00:41:34,620
to down this is where the magic happens

00:41:31,710 --> 00:41:35,760
this is where the unicorns are and this

00:41:34,620 --> 00:41:37,730
is where we have a very interesting

00:41:35,760 --> 00:41:40,920
class of consensus or a problem

00:41:37,730 --> 00:41:44,130
protocols algorithms that take care of

00:41:40,920 --> 00:41:46,020
this and this is called split brain

00:41:44,130 --> 00:41:49,790
resolvers this is a class of algorithms

00:41:46,020 --> 00:41:53,370
that you use to sort of automatically

00:41:49,790 --> 00:41:55,650
get rid of or take care of shutting down

00:41:53,370 --> 00:41:58,950
the right nodes and right like all of

00:41:55,650 --> 00:42:02,280
these things so so we're out of time

00:41:58,950 --> 00:42:04,350
sorry about that so I won't be able to

00:42:02,280 --> 00:42:08,640
tell you about split brain resolvers

00:42:04,350 --> 00:42:11,730
today but you can go on my site and read

00:42:08,640 --> 00:42:14,130
about them eventually no I think it

00:42:11,730 --> 00:42:16,830
would take just another talk entirely to

00:42:14,130 --> 00:42:19,530
talk to cover that topic that's why

00:42:16,830 --> 00:42:23,550
even try and attempt to start I think

00:42:19,530 --> 00:42:26,100
anyway I'm pretty much out of time 3 4 3

00:42:23,550 --> 00:42:29,430
3 minutes so um what I invite you to do

00:42:26,100 --> 00:42:30,780
is to read papers these are the papers

00:42:29,430 --> 00:42:36,450
that have been harmed during the

00:42:30,780 --> 00:42:38,310
creation of this talk and yeah you can I

00:42:36,450 --> 00:42:40,530
will put the slides online you can you

00:42:38,310 --> 00:42:43,170
can see that and yeah that's pretty much

00:42:40,530 --> 00:42:45,450
it thank you so much and we have time

00:42:43,170 --> 00:42:46,900
for 3 or 2 minutes may be time for

00:42:45,450 --> 00:42:54,090
questions

00:42:46,900 --> 00:42:54,090

YouTube URL: https://www.youtube.com/watch?v=zKf1kxAu2n0


