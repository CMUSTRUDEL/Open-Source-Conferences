Title: Type safety in the world of graph databases by Michael Pollmeier
Publication date: 2018-09-20
Playlist: Scala Days Berlin 2018
Description: 
	This video was recorded at Scala Days Berlin 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://eu.scaladays.org/lect-6908-type-safety-in-the-world-of-graph-databases.html
Captions: 
	00:00:04,600 --> 00:00:11,080
thanks for interests in this talk my

00:00:09,160 --> 00:00:11,849
name is Michael I'm the author of

00:00:11,080 --> 00:00:17,920
Grameen Escala

00:00:11,849 --> 00:00:19,570
I work it shift EFT and we do static

00:00:17,920 --> 00:00:22,349
content allowances and using graph

00:00:19,570 --> 00:00:24,610
databases to do useful things like

00:00:22,349 --> 00:00:27,579
finding security vulnerabilities of

00:00:24,610 --> 00:00:29,590
having data leaks and so on we'll have

00:00:27,579 --> 00:00:33,280
open source including the giving back

00:00:29,590 --> 00:00:35,649
path and we're hiring so if you if

00:00:33,280 --> 00:00:37,930
you're interested in any of any of what

00:00:35,649 --> 00:00:43,870
follows and you like open source please

00:00:37,930 --> 00:00:46,750
get in touch yeah so basically in this

00:00:43,870 --> 00:00:49,300
talk I firstly going to go over what

00:00:46,750 --> 00:00:51,550
what a graph database is and where the

00:00:49,300 --> 00:00:52,900
differences are to relational DVS what

00:00:51,550 --> 00:00:55,240
they are when you when you might want to

00:00:52,900 --> 00:00:58,510
use them then I'm gonna go over a few

00:00:55,240 --> 00:01:00,430
career languages and that you can used

00:00:58,510 --> 00:01:02,230
to check you write your traversals of

00:01:00,430 --> 00:01:05,470
course and to get some data or

00:01:02,230 --> 00:01:07,020
information all of the graph and and

00:01:05,470 --> 00:01:11,200
then the main part is going to be on

00:01:07,020 --> 00:01:12,970
criminal scholar that allows you to to

00:01:11,200 --> 00:01:18,940
write your course in the type safe way

00:01:12,970 --> 00:01:21,100
and how you can do that okay so when I

00:01:18,940 --> 00:01:22,960
when I first learned about databases

00:01:21,100 --> 00:01:25,360
this is probably what you would do you

00:01:22,960 --> 00:01:29,020
would saw so this is an example of an of

00:01:25,360 --> 00:01:32,229
a concrete DB this it's a relational

00:01:29,020 --> 00:01:34,210
database so you have tables and in this

00:01:32,229 --> 00:01:37,869
case the scenario I'm gonna use across

00:01:34,210 --> 00:01:40,750
the across the talk is a person a person

00:01:37,869 --> 00:01:43,299
might like a pizza or two and basically

00:01:40,750 --> 00:01:45,250
basically you in a relational DB you put

00:01:43,299 --> 00:01:47,710
into into three different tables you

00:01:45,250 --> 00:01:50,020
have a person table with where every row

00:01:47,710 --> 00:01:51,280
corresponds to a person then you have to

00:01:50,020 --> 00:01:53,350
like stable because it's a many-to-many

00:01:51,280 --> 00:01:55,390
relationship ship some one person can

00:01:53,350 --> 00:01:56,530
like many pizzas and then you've got

00:01:55,390 --> 00:01:58,270
pizzas and their names and attributes

00:01:56,530 --> 00:02:03,159
and whatnot so you have like rows and

00:01:58,270 --> 00:02:05,229
columns and that it's the by far the

00:02:03,159 --> 00:02:06,310
most popular model and there's a reason

00:02:05,229 --> 00:02:08,950
for it

00:02:06,310 --> 00:02:12,280
lots of lots of funding went into it

00:02:08,950 --> 00:02:14,530
lots of lots of research and

00:02:12,280 --> 00:02:18,580
it's been it's it's just the most

00:02:14,530 --> 00:02:20,710
popular one and see everybody no sequel

00:02:18,580 --> 00:02:23,680
the tools are highly optimized the the

00:02:20,710 --> 00:02:27,730
that was a very mature they're they're

00:02:23,680 --> 00:02:28,720
battle tested great tooling so there's

00:02:27,730 --> 00:02:31,480
there's lots of reasons to use

00:02:28,720 --> 00:02:35,290
relational DVDs I Postgres and my sequel

00:02:31,480 --> 00:02:37,660
and so on the point I would like to make

00:02:35,290 --> 00:02:41,590
though is they also have some downsides

00:02:37,660 --> 00:02:44,470
so interestingly mostly the dancers are

00:02:41,590 --> 00:02:46,320
bought when it comes to relations with

00:02:44,470 --> 00:02:50,680
relation to besides she quite bad at

00:02:46,320 --> 00:02:53,410
handling relations so if you if you have

00:02:50,680 --> 00:02:55,420
a look at that schema here and you you

00:02:53,410 --> 00:02:58,380
wanna you wanna write your sequel to

00:02:55,420 --> 00:03:00,459
finally all the all the pizzas that Alex

00:02:58,380 --> 00:03:01,959
what we need to do is we need to join

00:03:00,459 --> 00:03:07,060
these three tables together and the

00:03:01,959 --> 00:03:08,590
sequel looks like like this so you don't

00:03:07,060 --> 00:03:09,700
need to read every every word here but

00:03:08,590 --> 00:03:11,950
basically what I'm saying is for a

00:03:09,700 --> 00:03:15,400
simple task like me all the pieces

00:03:11,950 --> 00:03:17,830
of the ellas lines in sequel this this

00:03:15,400 --> 00:03:21,880
gets quite long quiet quite ugly very

00:03:17,830 --> 00:03:23,260
very soon in comparison if you read the

00:03:21,880 --> 00:03:25,780
same thing in gremlin which is a

00:03:23,260 --> 00:03:28,330
graphical API that that I'm going to

00:03:25,780 --> 00:03:30,489
talk more about later it's very natural

00:03:28,330 --> 00:03:31,959
it's very easy to read that even though

00:03:30,489 --> 00:03:35,440
you haven't seen you probably haven't

00:03:31,959 --> 00:03:37,989
seen any environment before so it's not

00:03:35,440 --> 00:03:39,220
only so if you think you're one step

00:03:37,989 --> 00:03:40,750
further and you wanna you want to say

00:03:39,220 --> 00:03:43,239
well let's get some some pizza

00:03:40,750 --> 00:03:44,650
recommendations so basically find all

00:03:43,239 --> 00:03:46,300
the pizzas that Ellis likes and then

00:03:44,650 --> 00:03:50,680
find the people who like the same pizzas

00:03:46,300 --> 00:03:56,230
and find the pizza that they like this

00:03:50,680 --> 00:03:57,880
just explodes right so it's it's it's a

00:03:56,230 --> 00:04:01,600
bit ugly when it comes to relations it's

00:03:57,880 --> 00:04:03,550
also it can also get slow so because

00:04:01,600 --> 00:04:05,620
every time you do join you need to look

00:04:03,550 --> 00:04:07,360
up something in a global index so the

00:04:05,620 --> 00:04:10,120
complexity is log and basically so it

00:04:07,360 --> 00:04:12,610
crawls the time that it takes for for

00:04:10,120 --> 00:04:14,110
that join drawers with the size of your

00:04:12,610 --> 00:04:16,239
of your index so basically the size of

00:04:14,110 --> 00:04:19,989
your data set we're simply in a graph to

00:04:16,239 --> 00:04:22,960
be give a give a note century index so

00:04:19,989 --> 00:04:24,360
the index really they note itself the

00:04:22,960 --> 00:04:27,389
various itself

00:04:24,360 --> 00:04:28,650
the point is to be adjacent versus I'm

00:04:27,389 --> 00:04:33,389
going to talk about I'm going to define

00:04:28,650 --> 00:04:35,069
what with vertices it in a second also

00:04:33,389 --> 00:04:36,870
typically in narration in DB you need to

00:04:35,069 --> 00:04:40,650
define your scheme upfront so it's not

00:04:36,870 --> 00:04:44,819
so grateful for doing some prototyping

00:04:40,650 --> 00:04:46,439
and and so on which totally integrate to

00:04:44,819 --> 00:04:51,330
be is optional optional so you don't

00:04:46,439 --> 00:04:52,889
have to with the relational to be with

00:04:51,330 --> 00:04:55,080
the relation we always have the jogger

00:04:52,889 --> 00:04:58,520
between normalization so how clean is my

00:04:55,080 --> 00:05:00,629
schema which leads to many many tables

00:04:58,520 --> 00:05:03,090
versus how much to optimize for

00:05:00,629 --> 00:05:04,949
performance which two leads to wide rows

00:05:03,090 --> 00:05:07,469
which might be sparse and then as well

00:05:04,949 --> 00:05:09,120
so this this constants child that you

00:05:07,469 --> 00:05:14,819
always have to keep in in your in your

00:05:09,120 --> 00:05:17,340
head and my last bashing point is the

00:05:14,819 --> 00:05:19,919
object-relational impedance mismatch so

00:05:17,340 --> 00:05:22,379
that busy just as a fancy term for if

00:05:19,919 --> 00:05:26,009
you have if your mapping your table to a

00:05:22,379 --> 00:05:28,139
class and your your class has a list

00:05:26,009 --> 00:05:29,879
property then you need to then in each

00:05:28,139 --> 00:05:31,620
store it in a separate and separate

00:05:29,879 --> 00:05:34,589
table and then turn that back end when

00:05:31,620 --> 00:05:37,830
you when it when you hold it so most

00:05:34,589 --> 00:05:39,449
most of you might have might have had

00:05:37,830 --> 00:05:43,080
that fight with you object relational

00:05:39,449 --> 00:05:45,719
mapping framework and so on so those are

00:05:43,080 --> 00:05:47,279
those are all reasons for where

00:05:45,719 --> 00:05:49,979
relationally bees have some have some

00:05:47,279 --> 00:05:52,589
transits again you should use them in

00:05:49,979 --> 00:05:53,520
98% of the case because they are just so

00:05:52,589 --> 00:05:55,259
much more mature

00:05:53,520 --> 00:06:00,569
anyway this talk is about graph to bees

00:05:55,259 --> 00:06:02,909
so some some propaganda most prop again

00:06:00,569 --> 00:06:04,469
is freeze and so this one so this from a

00:06:02,909 --> 00:06:06,000
book called graph databases from from

00:06:04,469 --> 00:06:08,189
irani and it's written about the need

00:06:06,000 --> 00:06:10,620
for a guy so they it's like the the

00:06:08,189 --> 00:06:12,990
apparently most popular one one around

00:06:10,620 --> 00:06:14,639
but yeah it's it's it's only propaganda

00:06:12,990 --> 00:06:17,279
but there's some truth to it so they

00:06:14,639 --> 00:06:18,930
comparing finding the finding the

00:06:17,279 --> 00:06:20,789
friends of friends so like in the social

00:06:18,930 --> 00:06:23,250
network friends are friends and they

00:06:20,789 --> 00:06:25,259
have friends and their friends so if you

00:06:23,250 --> 00:06:29,129
go to death to so they're two is just

00:06:25,259 --> 00:06:31,379
friends or friends right then it's it's

00:06:29,129 --> 00:06:33,479
well it's about the same the same size

00:06:31,379 --> 00:06:35,279
if you can't read those numbers so it's

00:06:33,479 --> 00:06:36,800
basically one millisecond in the in the

00:06:35,279 --> 00:06:40,190
in this use case in this

00:06:36,800 --> 00:06:44,030
set up what they did is they set up a DB

00:06:40,190 --> 00:06:46,879
worth a million people and fifty friend

00:06:44,030 --> 00:06:50,270
relationships per person on average and

00:06:46,879 --> 00:06:52,430
they basically just execute that

00:06:50,270 --> 00:06:55,099
Baccarin compared to time and what do

00:06:52,430 --> 00:06:58,569
you the main point to see here is in

00:06:55,099 --> 00:07:02,030
near photo were just whatever the

00:06:58,569 --> 00:07:06,620
advertising here the times the times

00:07:02,030 --> 00:07:08,169
grow with a constant factor whereas an

00:07:06,620 --> 00:07:10,490
irrationally be it grows exponentially

00:07:08,169 --> 00:07:13,639
the times to do this look at lookups

00:07:10,490 --> 00:07:15,409
now again careful propaganda obviously

00:07:13,639 --> 00:07:18,520
there's ways around that if you if you

00:07:15,409 --> 00:07:20,599
do this with the relation will be so

00:07:18,520 --> 00:07:22,340
yeah you can you can set up certain

00:07:20,599 --> 00:07:24,919
things and pre compute certain things

00:07:22,340 --> 00:07:27,280
which to make this more pleasant in

00:07:24,919 --> 00:07:29,930
relation to be but the main point is

00:07:27,280 --> 00:07:31,520
with the graph to be you get this for

00:07:29,930 --> 00:07:33,080
free basically that's the the whole

00:07:31,520 --> 00:07:35,330
point of a graph DB is that you can look

00:07:33,080 --> 00:07:37,789
up these relationships with constant

00:07:35,330 --> 00:07:42,770
time so super fast compared to compared

00:07:37,789 --> 00:07:45,860
to login okay so it talked a little bit

00:07:42,770 --> 00:07:49,090
graph but water Asian mean by graph so

00:07:45,860 --> 00:07:52,279
actually what I mean is it's called an

00:07:49,090 --> 00:07:54,919
directors property graph so it's

00:07:52,279 --> 00:07:57,139
directed um well let's start with a with

00:07:54,919 --> 00:08:00,800
a with a vertices I've used that that's

00:07:57,139 --> 00:08:02,690
a few times now but a few times so

00:08:00,800 --> 00:08:05,659
vertices are notes or you might just say

00:08:02,690 --> 00:08:07,340
things and they and they can have

00:08:05,659 --> 00:08:11,930
connections those connections are called

00:08:07,340 --> 00:08:13,550
edges each of which have an ID exactly

00:08:11,930 --> 00:08:16,759
one ID just like in a relation in DVD

00:08:13,550 --> 00:08:19,460
with two beauty salon ID what the DB

00:08:16,759 --> 00:08:23,539
would sell it for you and they they have

00:08:19,460 --> 00:08:25,849
exactly one label so that basically like

00:08:23,539 --> 00:08:31,159
you know your table name in a relational

00:08:25,849 --> 00:08:32,930
DB and they have zero end properties so

00:08:31,159 --> 00:08:35,360
nodes can have certain properties and

00:08:32,930 --> 00:08:39,079
edges can answer to turn pro please I'm

00:08:35,360 --> 00:08:42,169
just gonna use this this sample for the

00:08:39,079 --> 00:08:43,640
rest of the talk basically so so I'm

00:08:42,169 --> 00:08:45,740
just gonna go over it so we we have a

00:08:43,640 --> 00:08:47,010
person Alice with the with the name

00:08:45,740 --> 00:08:50,070
Alice and the

00:08:47,010 --> 00:08:53,310
and she's got an H and she likes pizza

00:08:50,070 --> 00:08:56,070
tunnel with with went three and pizza

00:08:53,310 --> 00:08:59,370
Romana with weight 5 so she prefers that

00:08:56,070 --> 00:09:01,320
one but she left

00:08:59,370 --> 00:09:03,660
so basically basically rough tip is a

00:09:01,320 --> 00:09:05,310
quick word for defining these ad hoc

00:09:03,660 --> 00:09:06,810
relationships and looking looking it up

00:09:05,310 --> 00:09:09,600
and and so on so for anything that's

00:09:06,810 --> 00:09:11,370
that's highly relational don't look at

00:09:09,600 --> 00:09:13,530
relational databases but but you may

00:09:11,370 --> 00:09:15,050
want to consider a graph to be with

00:09:13,530 --> 00:09:17,880
those covenants that I mentioned before

00:09:15,050 --> 00:09:19,710
so here's one use case we're not going

00:09:17,880 --> 00:09:21,090
to go into into every everything here

00:09:19,710 --> 00:09:22,890
but basically that's the domain that

00:09:21,090 --> 00:09:25,140
were in at a trip left where we

00:09:22,890 --> 00:09:27,060
basically passed source code into its

00:09:25,140 --> 00:09:29,100
atomic elements and we basically have

00:09:27,060 --> 00:09:35,100
things like declarations and functions

00:09:29,100 --> 00:09:39,420
and operators as our elements and then

00:09:35,100 --> 00:09:41,940
we we put some we put edges on top of

00:09:39,420 --> 00:09:45,050
that so to model things like the control

00:09:41,940 --> 00:09:48,810
flow graph and the data flow graph and

00:09:45,050 --> 00:09:50,580
with that if you then if you then try

00:09:48,810 --> 00:09:53,100
and find connected connected things like

00:09:50,580 --> 00:09:55,380
for example you have an HTTP input that

00:09:53,100 --> 00:09:57,600
might you might want to you might get a

00:09:55,380 --> 00:10:01,020
password form from your user any fun

00:09:57,600 --> 00:10:02,580
connection where that password goes into

00:10:01,020 --> 00:10:05,100
into some string and doesn't go into

00:10:02,580 --> 00:10:06,840
through some sanitization methods and go

00:10:05,100 --> 00:10:09,990
straight to a log file like we just

00:10:06,840 --> 00:10:12,630
recently had with Twitter we can detect

00:10:09,990 --> 00:10:15,780
that kind of stuff right so a CID we're

00:10:12,630 --> 00:10:20,990
finding finding things in the graph by

00:10:15,780 --> 00:10:20,990
traversing it right

00:10:23,999 --> 00:10:28,989
okay so there was a quick definition of

00:10:26,439 --> 00:10:32,769
what a photograph is and why you might

00:10:28,989 --> 00:10:34,269
want to consider it if you do want to go

00:10:32,769 --> 00:10:37,929
for it then there's a few options with

00:10:34,269 --> 00:10:39,879
when it comes to Korean languages so I'm

00:10:37,929 --> 00:10:42,009
gonna I'm gonna basically name three and

00:10:39,879 --> 00:10:49,540
then I'm gonna zoom into into the third

00:10:42,009 --> 00:10:50,489
one so cypher cipher was originally

00:10:49,540 --> 00:10:55,029
created by neo4j

00:10:50,489 --> 00:10:57,279
for their for their graph database it's

00:10:55,029 --> 00:10:59,169
one of the longest ones around they're

00:10:57,279 --> 00:11:02,230
very popular like the popular one and

00:10:59,169 --> 00:11:05,230
the most popular one they've open-source

00:11:02,230 --> 00:11:08,519
cipher as an open cypher effort and some

00:11:05,230 --> 00:11:11,709
some other Venice adopted that it's a

00:11:08,519 --> 00:11:14,079
declarative language so the idea is you

00:11:11,709 --> 00:11:17,049
you you write your traversal just like

00:11:14,079 --> 00:11:18,879
you would draw it on a piece of paper so

00:11:17,049 --> 00:11:20,410
that's that's really nice

00:11:18,879 --> 00:11:23,439
I'm not really an expert on it so I

00:11:20,410 --> 00:11:24,819
can't really judge like this destiny use

00:11:23,439 --> 00:11:27,239
case where it's grateful there's great

00:11:24,819 --> 00:11:30,249
fun in some some days not so grateful

00:11:27,239 --> 00:11:32,559
but since the Shockers board type safety

00:11:30,249 --> 00:11:35,230
and so I had a look at libraries out

00:11:32,559 --> 00:11:39,069
there for Scala and in how that little

00:11:35,230 --> 00:11:41,410
arise yorkers nf1 - that was sort of

00:11:39,069 --> 00:11:44,649
popular and one was for spark other one

00:11:41,410 --> 00:11:47,559
was for a norm so the the play framework

00:11:44,649 --> 00:11:50,049
and they both help you with the

00:11:47,559 --> 00:11:53,439
scaffolding for these for these specific

00:11:50,049 --> 00:11:54,819
tools but when it came to writing our

00:11:53,439 --> 00:11:57,549
results you still had to just read in a

00:11:54,819 --> 00:12:00,329
string right so you basically write this

00:11:57,549 --> 00:12:03,639
in a literal string and that's that's

00:12:00,329 --> 00:12:05,110
that's also you don't get in as far as I

00:12:03,639 --> 00:12:08,079
could see you don't get any type safety

00:12:05,110 --> 00:12:13,689
and from that so it's not so interested

00:12:08,079 --> 00:12:15,730
interesting for this talk Sparkle I only

00:12:13,689 --> 00:12:18,519
learned over lunch that it's called

00:12:15,730 --> 00:12:22,739
sparkle and not sparkle so I'm certainly

00:12:18,519 --> 00:12:27,549
no expert on sparkle but it's basically

00:12:22,739 --> 00:12:30,399
it's a w3c language so you see the Bella

00:12:27,549 --> 00:12:32,679
for XML namespaces here and it looks a

00:12:30,399 --> 00:12:35,379
bit like sequel it's also the clarity of

00:12:32,679 --> 00:12:37,239
different language and the

00:12:35,379 --> 00:12:39,639
this select statement that insulates

00:12:37,239 --> 00:12:42,549
tabular data they also have their cipher

00:12:39,639 --> 00:12:45,489
I think it's called create that Bezier

00:12:42,549 --> 00:12:48,910
it's a sub sub graph but the point is

00:12:45,489 --> 00:12:50,859
Sparkle is full our EFS RDF triples

00:12:48,910 --> 00:12:52,929
stores so they're they're the most

00:12:50,859 --> 00:12:54,759
low-level parameter for for storing data

00:12:52,929 --> 00:12:56,889
that you could that you could imagine

00:12:54,759 --> 00:13:00,399
it's always subject pretty good object

00:12:56,889 --> 00:13:03,399
so Ellis likes pizza

00:13:00,399 --> 00:13:05,019
and yeah so that that's a triple you

00:13:03,399 --> 00:13:08,289
can't you come to do more than that or

00:13:05,019 --> 00:13:10,599
Ellis has ID one that's a triple so lots

00:13:08,289 --> 00:13:12,069
of triples and the ideas and those are

00:13:10,599 --> 00:13:14,349
so primitive that you can then build

00:13:12,069 --> 00:13:16,509
your own anthologies on top of that and

00:13:14,349 --> 00:13:20,409
then infinity on languages issues you to

00:13:16,509 --> 00:13:22,449
query on top of that again I looked for

00:13:20,409 --> 00:13:25,509
libraries to express this kind of stuff

00:13:22,449 --> 00:13:28,119
in a typeset way and yeah I found one I

00:13:25,509 --> 00:13:30,309
found one for again specific for spark

00:13:28,119 --> 00:13:33,249
but again it was just the the

00:13:30,309 --> 00:13:35,849
scaffolding not so much writing back

00:13:33,249 --> 00:13:38,970
forests in a subset way so again that

00:13:35,849 --> 00:13:43,119
that didn't really don't really help

00:13:38,970 --> 00:13:48,789
much yeah it seems to be mostly used in

00:13:43,119 --> 00:13:50,379
academic environments but kocha third

00:13:48,789 --> 00:13:51,789
one and then I'm gonna I'm gonna zoom

00:13:50,379 --> 00:13:53,859
into into this one for the worse so

00:13:51,789 --> 00:13:57,309
that's what basically and gremlin so

00:13:53,859 --> 00:14:00,639
it's an the ideas think what tries to be

00:13:57,309 --> 00:14:03,039
the JD we see what JDBC for relational

00:14:00,639 --> 00:14:04,809
DB's think what tries to do that for for

00:14:03,039 --> 00:14:07,479
for graph databases that's the mission

00:14:04,809 --> 00:14:09,850
statement so say this is cramming groovy

00:14:07,479 --> 00:14:11,949
which was the main the main star and

00:14:09,850 --> 00:14:13,809
basically it's it's imperative so you

00:14:11,949 --> 00:14:16,809
have lots of lots of steps that he can

00:14:13,809 --> 00:14:19,809
that he can combine and they take

00:14:16,809 --> 00:14:21,489
compose and there's some declarative

00:14:19,809 --> 00:14:24,179
styles available as well but this is

00:14:21,489 --> 00:14:27,399
certainly in the main the main stuff

00:14:24,179 --> 00:14:29,559
it's a tour complete language affair

00:14:27,399 --> 00:14:32,639
administer to anyone there's a long list

00:14:29,559 --> 00:14:35,199
of the B's that implement this API

00:14:32,639 --> 00:14:36,819
local as well as promote and so

00:14:35,199 --> 00:14:38,769
basically you write your traversal like

00:14:36,819 --> 00:14:41,379
this and then it executes if you have a

00:14:38,769 --> 00:14:44,169
local like in memory or back by a local

00:14:41,379 --> 00:14:48,359
file system database or if you send it

00:14:44,169 --> 00:14:48,359
to remote remote TV it's the same API

00:14:48,510 --> 00:14:55,050
the the majority of those of those DB

00:14:52,290 --> 00:14:57,830
drivers there is a lot so that's that's

00:14:55,050 --> 00:15:00,810
something to keep in mind there's

00:14:57,830 --> 00:15:03,000
there's many libraries for different for

00:15:00,810 --> 00:15:05,940
different host languages so this is

00:15:03,000 --> 00:15:07,860
Grameen groovy this Grameen Java which

00:15:05,940 --> 00:15:09,510
is like the underlying one and there's

00:15:07,860 --> 00:15:12,660
German Scala which which we're gonna

00:15:09,510 --> 00:15:17,130
zoom into and then there's Python and

00:15:12,660 --> 00:15:21,450
Jason just ripped and dotnet and I think

00:15:17,130 --> 00:15:22,520
some oh okay zooming into grammar in

00:15:21,450 --> 00:15:24,860
Scala

00:15:22,520 --> 00:15:28,740
so it's basically a wrapper around

00:15:24,860 --> 00:15:31,620
grammar and Java and the main objective

00:15:28,740 --> 00:15:34,410
is to give you scholar friendly function

00:15:31,620 --> 00:15:36,630
syntax when you define your euro Russell

00:15:34,410 --> 00:15:38,370
and not just row so I'm going to show a

00:15:36,630 --> 00:15:43,430
few other things like if you want and

00:15:38,370 --> 00:15:46,050
add vertices and edges to a graph and

00:15:43,430 --> 00:15:47,880
not just the function syntax but also to

00:15:46,050 --> 00:15:50,910
make it to make it type safe so make use

00:15:47,880 --> 00:15:54,779
of scalice advanced component and type

00:15:50,910 --> 00:15:56,339
system and to help you in your IDE by by

00:15:54,779 --> 00:15:58,470
deriving sometimes for you that

00:15:56,339 --> 00:16:03,740
otherwise you would have to cast or

00:15:58,470 --> 00:16:06,959
orders yeah do some guesswork and also

00:16:03,740 --> 00:16:09,180
prevent prevent some families of illegal

00:16:06,959 --> 00:16:14,120
course for you at compile time rather

00:16:09,180 --> 00:16:14,120
than rather than airing at runtime and

00:16:14,270 --> 00:16:19,920
yeah Skyler's great language for barring

00:16:16,800 --> 00:16:21,839
a DSL as you'll see and the main thing

00:16:19,920 --> 00:16:23,580
is it's it's just a thin wrapper on top

00:16:21,839 --> 00:16:25,980
of Roman Java so if anything is missing

00:16:23,580 --> 00:16:27,750
or there's probably a few things missing

00:16:25,980 --> 00:16:31,230
you can always go back to the next one

00:16:27,750 --> 00:16:33,900
in Java getting some set up out of the

00:16:31,230 --> 00:16:36,600
way so basically the next few starts all

00:16:33,900 --> 00:16:39,480
assume that where it is this there's one

00:16:36,600 --> 00:16:41,310
card employ of chrome in Scala and we

00:16:39,480 --> 00:16:44,010
have some some instance of a graph right

00:16:41,310 --> 00:16:46,380
so that's thing the graph is an in

00:16:44,010 --> 00:16:49,770
memory like the reference implementation

00:16:46,380 --> 00:16:51,240
of a graph and this could be anything

00:16:49,770 --> 00:16:55,079
else this could be a Janus graph the

00:16:51,240 --> 00:16:56,400
reference or a reference to cosmos draw

00:16:55,079 --> 00:17:00,270
for

00:16:56,400 --> 00:17:01,200
there's a project I think I have a link

00:17:00,270 --> 00:17:03,089
on the on the last slide

00:17:01,200 --> 00:17:04,410
Roma Scala examples that helps you with

00:17:03,089 --> 00:17:05,610
a set up of different different

00:17:04,410 --> 00:17:08,610
properties so there's like five or six

00:17:05,610 --> 00:17:12,480
different the beasts and you have a set

00:17:08,610 --> 00:17:16,350
of four go so when it comes to type

00:17:12,480 --> 00:17:19,140
safety what we busy need to do is we

00:17:16,350 --> 00:17:20,579
define our scheme our once and then we

00:17:19,140 --> 00:17:24,300
use it everywhere so that's the slide

00:17:20,579 --> 00:17:25,920
where we define our schema in in

00:17:24,300 --> 00:17:28,980
practice what we do for example is we

00:17:25,920 --> 00:17:31,140
have a we have a JSON file where we

00:17:28,980 --> 00:17:32,820
actually have our domain specific schema

00:17:31,140 --> 00:17:34,710
and we generate lots of stuff out of

00:17:32,820 --> 00:17:38,130
that so this kind of code could be could

00:17:34,710 --> 00:17:39,860
be generators or you read it so for the

00:17:38,130 --> 00:17:42,929
father given schema that we had before

00:17:39,860 --> 00:17:45,120
we define personals as they have a label

00:17:42,929 --> 00:17:47,670
of type person that's that's got nothing

00:17:45,120 --> 00:17:51,150
to do with type safety that's just it's

00:17:47,670 --> 00:17:53,330
just a string the second one the the

00:17:51,150 --> 00:17:57,450
name so we basically say a person has

00:17:53,330 --> 00:18:00,870
has a name property with a type string

00:17:57,450 --> 00:18:02,490
that's that's all that is and and again

00:18:00,870 --> 00:18:05,010
has an H property with the type int and

00:18:02,490 --> 00:18:07,860
those like edges have also have also one

00:18:05,010 --> 00:18:10,710
property with a name how much and it's

00:18:07,860 --> 00:18:12,210
of type double it is you define it here

00:18:10,710 --> 00:18:14,460
you use that everywhere and then the

00:18:12,210 --> 00:18:17,160
compiler can infer those types for you

00:18:14,460 --> 00:18:21,510
and I'm going to show you what that

00:18:17,160 --> 00:18:25,770
means so first before we do any

00:18:21,510 --> 00:18:27,840
traversals we have some this is a syntax

00:18:25,770 --> 00:18:29,880
to actually add vertices or this is one

00:18:27,840 --> 00:18:33,270
way to to add vertices and edges to your

00:18:29,880 --> 00:18:36,240
graph so the first two lines busy add

00:18:33,270 --> 00:18:39,120
two nodes so then they add the the LS

00:18:36,240 --> 00:18:41,130
person node and the pizza tunnel node

00:18:39,120 --> 00:18:46,309
and the set some properties and because

00:18:41,130 --> 00:18:48,809
we will use our name and age keys here

00:18:46,309 --> 00:18:50,850
there there's already some types types

00:18:48,809 --> 00:18:53,190
actually that you get here because for

00:18:50,850 --> 00:18:55,620
example you couldn't you can say H is

00:18:53,190 --> 00:18:57,390
some string use it has to be of type of

00:18:55,620 --> 00:19:01,080
type int so this when you when you add

00:18:57,390 --> 00:19:03,059
your unit and then the the lines the

00:19:01,080 --> 00:19:04,920
lines below they actually create some

00:19:03,059 --> 00:19:07,350
some edges between those between those

00:19:04,920 --> 00:19:10,020
nodes so as soon as those lines execute

00:19:07,350 --> 00:19:12,300
the you will have those those edges

00:19:10,020 --> 00:19:14,120
the first one just with the label so

00:19:12,300 --> 00:19:16,470
Ellis likes tunnel and the second one

00:19:14,120 --> 00:19:21,210
you can also you can provide the tuple

00:19:16,470 --> 00:19:23,190
to also set some some properties this

00:19:21,210 --> 00:19:25,800
was a user contribution and made me

00:19:23,190 --> 00:19:27,150
realize how how cool Scala is to embed

00:19:25,800 --> 00:19:28,530
you on your own this element to it

00:19:27,150 --> 00:19:35,010
because I think it's I think it's quite

00:19:28,530 --> 00:19:40,350
quite nicely readable the other way to

00:19:35,010 --> 00:19:41,820
to add vertices for example is using is

00:19:40,350 --> 00:19:44,430
using case classes so there's a there's

00:19:41,820 --> 00:19:46,770
a black box black box macro in here this

00:19:44,430 --> 00:19:50,640
by the way is the only macro in Roman

00:19:46,770 --> 00:19:54,090
scholar where in this case we have it

00:19:50,640 --> 00:19:55,860
with a case last person with an with an

00:19:54,090 --> 00:19:58,080
ID which is optional because it's being

00:19:55,860 --> 00:19:59,670
set by the by the DB and then whether to

00:19:58,080 --> 00:20:01,290
the two properties that we that we had

00:19:59,670 --> 00:20:04,560
before so a name and in this case I'm at

00:20:01,290 --> 00:20:06,540
the age optional and then we can just

00:20:04,560 --> 00:20:10,380
add it to the graph by saying graph plus

00:20:06,540 --> 00:20:12,060
an instance of that person and when with

00:20:10,380 --> 00:20:14,430
then what we get back is an instance of

00:20:12,060 --> 00:20:16,050
Felix and we can convert that back to to

00:20:14,430 --> 00:20:21,300
an instance of the person and then the

00:20:16,050 --> 00:20:26,100
ID property will be set in this in this

00:20:21,300 --> 00:20:27,890
case so Vermont that macro has has some

00:20:26,100 --> 00:20:32,840
rough edges it works for these these

00:20:27,890 --> 00:20:35,160
simple cases but it's it's certainly not

00:20:32,840 --> 00:20:37,530
not back free based lots of issues

00:20:35,160 --> 00:20:39,600
around and some rough rough edges but if

00:20:37,530 --> 00:20:41,610
you have some simple thing you can you

00:20:39,600 --> 00:20:43,770
can use that kind of stuff I was I was

00:20:41,610 --> 00:20:47,940
about to rewrite that in Scala in Scala

00:20:43,770 --> 00:20:49,440
meta and skele macros but yeah the it

00:20:47,940 --> 00:20:51,000
stalls a little bit because the

00:20:49,440 --> 00:20:56,160
directions are baton key when it comes

00:20:51,000 --> 00:20:58,260
to macros okay so I was talking about

00:20:56,160 --> 00:20:59,460
traverses so this is a basically you

00:20:58,260 --> 00:21:02,370
want to get some information from the

00:20:59,460 --> 00:21:07,590
from the graph so just as a convention

00:21:02,370 --> 00:21:11,280
we use G as as the Travis source so we

00:21:07,590 --> 00:21:13,710
we can start any any a browser with with

00:21:11,280 --> 00:21:14,730
the G I will get that G with just

00:21:13,710 --> 00:21:16,650
graphed out traversal

00:21:14,730 --> 00:21:19,920
just some convention in the think about

00:21:16,650 --> 00:21:23,149
universe and then what we can do is um G

00:21:19,920 --> 00:21:27,139
V V sense for vertices

00:21:23,149 --> 00:21:28,549
right as opposed to Evo edges so the

00:21:27,139 --> 00:21:33,109
first thing to government here is

00:21:28,549 --> 00:21:35,299
services are lazy so did avi the rich on

00:21:33,109 --> 00:21:37,700
Thomas Graham in Scala and sorry growing

00:21:35,299 --> 00:21:40,279
scholar of verdicts because the be the

00:21:37,700 --> 00:21:42,609
entity type is Sir verdicts we honor

00:21:40,279 --> 00:21:45,109
verdicts in this case all the vertices

00:21:42,609 --> 00:21:46,339
but that first the first line here in

00:21:45,109 --> 00:21:47,719
the second block dozen should do

00:21:46,339 --> 00:21:48,830
anything yet it's just defining the

00:21:47,719 --> 00:21:51,200
Jerusalem

00:21:48,830 --> 00:21:54,259
if you then run to list on it you get

00:21:51,200 --> 00:21:58,159
back a list of vertices and that's when

00:21:54,259 --> 00:22:00,529
it actually executes so the first so the

00:21:58,159 --> 00:22:02,269
the middle box will give you all the

00:22:00,529 --> 00:22:03,739
vertices in the in the graph if that's

00:22:02,269 --> 00:22:06,320
really what he want

00:22:03,739 --> 00:22:08,029
often times you just want you just want

00:22:06,320 --> 00:22:09,919
to start it rusev with a single with the

00:22:08,029 --> 00:22:12,679
single verdicts or Senate or whatever

00:22:09,919 --> 00:22:14,539
and then you just just ready for example

00:22:12,679 --> 00:22:17,450
you could specify the ID of things of

00:22:14,539 --> 00:22:21,109
that critics and then again you just the

00:22:17,450 --> 00:22:23,649
first the so in the third block v1 is

00:22:21,109 --> 00:22:25,999
that better straight Instagram Scala of

00:22:23,649 --> 00:22:30,219
verdicts and if you then run hit option

00:22:25,999 --> 00:22:30,219
then you get you get an optional physics

00:22:32,139 --> 00:22:37,669
okay so now if we started to started

00:22:35,029 --> 00:22:41,509
some some simple vertex who say v1 is

00:22:37,669 --> 00:22:45,529
Ellis we if we want to find out and what

00:22:41,509 --> 00:22:47,749
pizza she likes would say out likes so

00:22:45,529 --> 00:22:51,799
out means follow all the outgoing edges

00:22:47,749 --> 00:22:55,070
to the to the adjacent vertices so to

00:22:51,799 --> 00:22:56,599
the next to the next losses and to be

00:22:55,070 --> 00:23:00,529
more precise out is actually a short

00:22:56,599 --> 00:23:03,349
form of out e dot in V so what this

00:23:00,529 --> 00:23:05,960
means is we followed the outgoing edges

00:23:03,349 --> 00:23:08,149
in this case we could we could filter on

00:23:05,960 --> 00:23:11,269
the edges we could say we could say only

00:23:08,149 --> 00:23:13,909
give me the ones that have have how much

00:23:11,269 --> 00:23:21,399
property of at least four and then

00:23:13,909 --> 00:23:24,349
followed the incoming verdicts and then

00:23:21,399 --> 00:23:25,759
prove say only when I talked about when

00:23:24,349 --> 00:23:27,589
I when I searched about joints and how

00:23:25,759 --> 00:23:30,579
complex it would be to get to get some

00:23:27,589 --> 00:23:34,070
recommendations I mentioned this example

00:23:30,579 --> 00:23:35,340
Pizza recommendations so here we just

00:23:34,070 --> 00:23:38,669
say well

00:23:35,340 --> 00:23:41,999
start with Ellis we know her ID finding

00:23:38,669 --> 00:23:44,309
all the pieces that she likes find me

00:23:41,999 --> 00:23:46,679
all the funding all the people who also

00:23:44,309 --> 00:23:48,230
like the same pieces and then finally

00:23:46,679 --> 00:23:51,480
all the pizzas that these people like

00:23:48,230 --> 00:23:52,799
right so in a sequel and if you write

00:23:51,480 --> 00:23:57,629
this in sequel that's busy wouldn't fit

00:23:52,799 --> 00:24:00,960
on a slide and this this is I think

00:23:57,629 --> 00:24:02,820
quite straightforward so that's that

00:24:00,960 --> 00:24:05,669
sort of if you in such a in such a

00:24:02,820 --> 00:24:09,110
domain then then these disparate

00:24:05,669 --> 00:24:09,110
languages might be better than sequel

00:24:11,059 --> 00:24:15,119
exit you can concatenate lots of steps

00:24:13,499 --> 00:24:18,539
so I'm going to show you a few a few of

00:24:15,119 --> 00:24:22,080
the of the most basic steps this was 20

00:24:18,539 --> 00:24:24,539
or 30 or so of them in total so one is

00:24:22,080 --> 00:24:25,980
the half step so we can we can say

00:24:24,539 --> 00:24:27,330
finding all the vertices that have a

00:24:25,980 --> 00:24:29,610
given labels so that's basically like

00:24:27,330 --> 00:24:34,259
you could imagine that like select star

00:24:29,610 --> 00:24:35,789
from some table name find me find me all

00:24:34,259 --> 00:24:37,350
the vertices that have a given property

00:24:35,789 --> 00:24:38,759
set so everything that has the name

00:24:37,350 --> 00:24:41,309
property set so in this case we will get

00:24:38,759 --> 00:24:43,740
all the vertices because person as well

00:24:41,309 --> 00:24:47,429
as pizza has the name property set all

00:24:43,740 --> 00:24:49,169
and now expect to type safety you can

00:24:47,429 --> 00:24:50,639
you can say finding other all the

00:24:49,169 --> 00:24:55,320
vertices that have the edge property set

00:24:50,639 --> 00:24:57,450
to a value between 25 and 35 type safety

00:24:55,320 --> 00:25:00,269
because if you type this in your ID and

00:24:57,450 --> 00:25:02,909
you and you say Peter between and then

00:25:00,269 --> 00:25:04,590
you get you the autocomplete you know

00:25:02,909 --> 00:25:06,570
you know at that points that you have to

00:25:04,590 --> 00:25:11,669
provide two integers because with the

00:25:06,570 --> 00:25:13,619
fund age as a key event so you you can't

00:25:11,669 --> 00:25:17,639
provide anything anything other than

00:25:13,619 --> 00:25:19,440
that integers are there and compiler

00:25:17,639 --> 00:25:21,980
errors otherwise and and you get

00:25:19,440 --> 00:25:21,980
somebody help

00:25:23,660 --> 00:25:30,920
right you can you can regroup bias so

00:25:27,110 --> 00:25:33,290
first first box would be getting all the

00:25:30,920 --> 00:25:35,210
vertices and group them by the label so

00:25:33,290 --> 00:25:37,940
that's basically like saying well let me

00:25:35,210 --> 00:25:41,480
all the tables out there what you get

00:25:37,940 --> 00:25:44,930
back is growing Scala because it's lazy

00:25:41,480 --> 00:25:47,720
and if you execute head on it you get a

00:25:44,930 --> 00:25:49,610
map of string to collection of physics

00:25:47,720 --> 00:25:51,590
so that's basically the key of the map

00:25:49,610 --> 00:25:53,450
is the label name and the collection of

00:25:51,590 --> 00:25:57,200
photos is all the villages that are in

00:25:53,450 --> 00:26:01,220
that half that label but you can you can

00:25:57,200 --> 00:26:03,730
group by arbitrary things so second box

00:26:01,220 --> 00:26:06,230
is grouped by underscore underscore

00:26:03,730 --> 00:26:08,570
healthy count so underscore underscore

00:26:06,230 --> 00:26:11,660
is similar to the to the UH neskowin

00:26:08,570 --> 00:26:13,250
Scala it's in an anonymous traversal and

00:26:11,660 --> 00:26:15,320
basically if you just look at that

00:26:13,250 --> 00:26:18,140
enormous reversal so and say underscore

00:26:15,320 --> 00:26:21,230
out account that's the degree of the

00:26:18,140 --> 00:26:24,560
verdicts so how many outgoing edges does

00:26:21,230 --> 00:26:27,110
this verdicts have so I'm grouping all

00:26:24,560 --> 00:26:29,360
the vertices by their degree so this is

00:26:27,110 --> 00:26:31,760
two font then I would say at the end

00:26:29,360 --> 00:26:33,530
limit ten and give me the ten super

00:26:31,760 --> 00:26:35,540
nodes in my in my graph so if I have

00:26:33,530 --> 00:26:39,170
some some very highly connectors notes

00:26:35,540 --> 00:26:46,580
they have special properties fine levels

00:26:39,170 --> 00:26:49,520
for example third one group I do group

00:26:46,580 --> 00:26:51,110
count by the age so finally all the

00:26:49,520 --> 00:26:54,470
other villages that have the edge

00:26:51,110 --> 00:26:57,800
property set and do a group count by

00:26:54,470 --> 00:27:00,800
that by very specific property and again

00:26:57,800 --> 00:27:04,700
because we defined the the age as a key

00:27:00,800 --> 00:27:08,270
event before now in our schema we get

00:27:04,700 --> 00:27:10,280
back a map of insta long so this the key

00:27:08,270 --> 00:27:18,590
is the end because that's the see the

00:27:10,280 --> 00:27:20,840
edge property repeat step so I think the

00:27:18,590 --> 00:27:23,360
first one is pretty pretty obvious so we

00:27:20,840 --> 00:27:26,360
started we start as specific verdicts

00:27:23,360 --> 00:27:28,430
and we repeat an arbitrary reversal in

00:27:26,360 --> 00:27:29,930
this in this case we follow we follow

00:27:28,430 --> 00:27:33,940
all the outgoing edges to the adjacent

00:27:29,930 --> 00:27:38,930
vertices and we do that three times

00:27:33,940 --> 00:27:42,200
sing one bit more useful we do that

00:27:38,930 --> 00:27:45,470
repeat step of following the outgoing

00:27:42,200 --> 00:27:47,240
edges to the adjacent vertices and we do

00:27:45,470 --> 00:27:50,300
that until some condition is met and

00:27:47,240 --> 00:27:55,670
that condition can be an upper through

00:27:50,300 --> 00:27:57,920
so again in this case if you just see

00:27:55,670 --> 00:28:01,700
the last the last line out account is

00:27:57,920 --> 00:28:04,550
zero so basically this means follow all

00:28:01,700 --> 00:28:07,040
the outgoing edges to the to the

00:28:04,550 --> 00:28:08,480
adjacent vertices vertices until we are

00:28:07,040 --> 00:28:10,970
at the border of the graph

00:28:08,480 --> 00:28:12,560
so we've just discovered a frontier of

00:28:10,970 --> 00:28:15,980
the of the graph so the outer most of

00:28:12,560 --> 00:28:17,330
the most nodes in the graph but yeah

00:28:15,980 --> 00:28:19,810
this could be Earth just an example

00:28:17,330 --> 00:28:19,810
could be anything

00:28:22,630 --> 00:28:30,170
we altered s select so typically if you

00:28:25,970 --> 00:28:32,060
if you if you wrote the traversal you

00:28:30,170 --> 00:28:34,190
get back the the last thing in your in

00:28:32,060 --> 00:28:36,080
your traversal so so in the examples

00:28:34,190 --> 00:28:38,600
before we look at some some some

00:28:36,080 --> 00:28:40,340
property or so but sometimes you

00:28:38,600 --> 00:28:44,090
interested in in more things along the

00:28:40,340 --> 00:28:46,730
way so to do that what you can do is you

00:28:44,090 --> 00:28:51,230
can label your your your steps on the

00:28:46,730 --> 00:28:53,090
way so so in this in this reversal if we

00:28:51,230 --> 00:28:55,760
ignore the the the a steps for four

00:28:53,090 --> 00:28:57,050
months so we started we started on this

00:28:55,760 --> 00:28:58,460
case all vertices but let's say that

00:28:57,050 --> 00:29:00,890
says some specific verdicts

00:28:58,460 --> 00:29:03,380
we followed the outgoing edges and we

00:29:00,890 --> 00:29:06,560
look up the value of how much so the how

00:29:03,380 --> 00:29:08,690
much does a person like a pizza if he if

00:29:06,560 --> 00:29:11,300
you wouldn't have to select then you

00:29:08,690 --> 00:29:14,000
would get back a list of doubles so a

00:29:11,300 --> 00:29:17,360
list of how much how much do people like

00:29:14,000 --> 00:29:23,080
pizza but you have no idea of who who

00:29:17,360 --> 00:29:26,540
likes what how much so if you label them

00:29:23,080 --> 00:29:28,150
so you say with the vertices you name

00:29:26,540 --> 00:29:29,980
them something you give it

00:29:28,150 --> 00:29:32,680
give it some label maybe more meaningful

00:29:29,980 --> 00:29:35,620
than a and then you you at the outgoing

00:29:32,680 --> 00:29:37,320
edges give them a label as well and then

00:29:35,620 --> 00:29:41,910
you look up some value and do whatever

00:29:37,320 --> 00:29:45,280
and at the end you just say select and

00:29:41,910 --> 00:29:47,860
then in this case the return type is

00:29:45,280 --> 00:29:51,700
it's not of type double but it's of type

00:29:47,860 --> 00:29:53,470
tuple so although in this tuple contains

00:29:51,700 --> 00:29:55,120
all the elements that you've labeled all

00:29:53,470 --> 00:30:01,120
the steps that you've labeled with their

00:29:55,120 --> 00:30:02,860
concrete type so in in gremlin Java

00:30:01,120 --> 00:30:05,740
or grammar in Ruby what we would get

00:30:02,860 --> 00:30:08,860
back it's an array of object and you

00:30:05,740 --> 00:30:11,380
would have to cast your way around but

00:30:08,860 --> 00:30:13,090
here we can we can just use we can use

00:30:11,380 --> 00:30:16,810
well this is implement with shapeless

00:30:13,090 --> 00:30:22,180
and it's actually fairly simple by just

00:30:16,810 --> 00:30:26,290
holding by restoring the labeled members

00:30:22,180 --> 00:30:30,190
as a type member which is an H list and

00:30:26,290 --> 00:30:33,130
that's how we can preserve the type so

00:30:30,190 --> 00:30:35,140
if you if you run two lists on this you

00:30:33,130 --> 00:30:42,430
get back a list of the tuple so a list

00:30:35,140 --> 00:30:44,200
of the recessional yeah the other thing

00:30:42,430 --> 00:30:47,560
I mentioned is you can catch some some

00:30:44,200 --> 00:30:49,780
families of compile time errors of

00:30:47,560 --> 00:30:51,400
errors at compile time so in a dynamic

00:30:49,780 --> 00:30:53,830
language is the native language you

00:30:51,400 --> 00:30:56,230
don't have any compile time so you can't

00:30:53,830 --> 00:31:01,900
get that but also in Java you don't get

00:30:56,230 --> 00:31:02,380
most of this so first the first one you

00:31:01,900 --> 00:31:06,940
can't

00:31:02,380 --> 00:31:09,690
so you set it all the way sorry and then

00:31:06,940 --> 00:31:12,280
you you follow the outgoing edges and

00:31:09,690 --> 00:31:13,990
then you your honor verdicts and you

00:31:12,280 --> 00:31:17,530
want to follow the outgoing edges again

00:31:13,990 --> 00:31:20,560
but ah Keung edges only exists on an

00:31:17,530 --> 00:31:21,970
edge very own on a vertex so if you're

00:31:20,560 --> 00:31:24,610
on an edge there's no thing as an

00:31:21,970 --> 00:31:28,240
outgoing edge because you only have two

00:31:24,610 --> 00:31:30,970
verdicts that's adjacent so this is this

00:31:28,240 --> 00:31:34,090
you can catch at compile time and and

00:31:30,970 --> 00:31:36,970
Chris Connor does that second one would

00:31:34,090 --> 00:31:38,860
be setting a property so we define name

00:31:36,970 --> 00:31:41,270
as a key of string

00:31:38,860 --> 00:31:43,670
hence we can't

00:31:41,270 --> 00:31:45,080
to an integer so the compiler the

00:31:43,670 --> 00:31:47,420
compiler tells you well you can't you

00:31:45,080 --> 00:31:49,970
can't do that so a property in name name

00:31:47,420 --> 00:31:54,530
value doesn't compile if it's the wrong

00:31:49,970 --> 00:31:55,640
type and third one we look up from all

00:31:54,530 --> 00:31:57,860
the vertices we look up the name

00:31:55,640 --> 00:32:00,830
property we do and we know it's it's a

00:31:57,860 --> 00:32:04,130
string and now we we want to compute the

00:32:00,830 --> 00:32:06,260
mean of those name properties well mean

00:32:04,130 --> 00:32:08,030
doesn't make any sense for for a list of

00:32:06,260 --> 00:32:10,400
string so this doesn't compile either

00:32:08,030 --> 00:32:12,140
because there is no view available from

00:32:10,400 --> 00:32:21,770
strength to numbers so it has to be some

00:32:12,140 --> 00:32:24,410
number like in to W so some some magic

00:32:21,770 --> 00:32:27,110
on top typically if you if you're in

00:32:24,410 --> 00:32:30,680
some in some domain you don't wanna you

00:32:27,110 --> 00:32:32,000
don't wanna wrestle with or if you want

00:32:30,680 --> 00:32:34,520
to if you want to show what you're doing

00:32:32,000 --> 00:32:37,100
to your domain expert you don't want to

00:32:34,520 --> 00:32:39,140
show them runners running for us so

00:32:37,100 --> 00:32:41,690
instead what you can what you can do is

00:32:39,140 --> 00:32:45,470
you can define quite easily define your

00:32:41,690 --> 00:32:50,360
own queries in in your own abstraction

00:32:45,470 --> 00:32:52,730
and then name them so in this case these

00:32:50,360 --> 00:32:57,080
two lines this these two boxes are

00:32:52,730 --> 00:32:59,720
exactly equivalent so the upper one is

00:32:57,080 --> 00:33:01,540
your own domain in for your domain

00:32:59,720 --> 00:33:03,680
experts and they will understand that so

00:33:01,540 --> 00:33:06,800
finally all the people with the name

00:33:03,680 --> 00:33:09,940
Alice who liked something well and they

00:33:06,800 --> 00:33:12,650
read it at least three so the the

00:33:09,940 --> 00:33:16,130
implementation of that is in the bottom

00:33:12,650 --> 00:33:18,650
box so look at the name property follow

00:33:16,130 --> 00:33:20,870
the outgoing edges with some filter must

00:33:18,650 --> 00:33:24,140
be greater than three and then go to the

00:33:20,870 --> 00:33:26,360
adjacent vertices the result is the same

00:33:24,140 --> 00:33:26,870
but the upper one is much more much more

00:33:26,360 --> 00:33:29,810
readable

00:33:26,870 --> 00:33:31,220
and so if you want to do this this kind

00:33:29,810 --> 00:33:35,200
of stuff you can obviously always do

00:33:31,220 --> 00:33:37,640
that in your own in the wrapper around

00:33:35,200 --> 00:33:40,430
grammar scholar but if you use the one

00:33:37,640 --> 00:33:43,430
that if you some some of the wiring

00:33:40,430 --> 00:33:44,930
that's that's that's there and you get

00:33:43,430 --> 00:33:48,560
certain benefits like you can also do

00:33:44,930 --> 00:33:50,150
the air select type safe selects and a

00:33:48,560 --> 00:33:54,250
few of the other things that I've shown

00:33:50,150 --> 00:33:54,250
before alpha box yes

00:33:55,070 --> 00:34:02,550
right now there's obviously some some

00:34:01,140 --> 00:34:04,860
downsides and I mentioned that in

00:34:02,550 --> 00:34:08,850
beginning so majority of the of the

00:34:04,860 --> 00:34:11,640
databases and Davis Travis far behind

00:34:08,850 --> 00:34:14,040
relational DB's so there's this I think

00:34:11,640 --> 00:34:17,010
there's no comparison in those regards

00:34:14,040 --> 00:34:18,690
so the the the benefits of having a very

00:34:17,010 --> 00:34:21,480
relational dependent having to do these

00:34:18,690 --> 00:34:24,380
discount reversals that are very

00:34:21,480 --> 00:34:28,520
connected must far outweigh the

00:34:24,380 --> 00:34:32,490
downsides thirty thirty of swollen here

00:34:28,520 --> 00:34:34,650
it is very rapidly expanding space of

00:34:32,490 --> 00:34:38,160
this there's a few really good new

00:34:34,650 --> 00:34:42,179
contenders that just join the community

00:34:38,160 --> 00:34:44,040
and there's like one Microsoft and and a

00:34:42,179 --> 00:34:45,690
double yesterday and they've got some

00:34:44,040 --> 00:34:47,820
implementations and now that run on

00:34:45,690 --> 00:34:48,150
their clouds and there's some some open

00:34:47,820 --> 00:34:51,120
source

00:34:48,150 --> 00:34:52,800
janus janus graph and and I've left

00:34:51,120 --> 00:34:55,620
we've also made some modifications to

00:34:52,800 --> 00:34:58,830
the to the reference implementation of

00:34:55,620 --> 00:35:04,020
tinker pop which is just an in-memory DB

00:34:58,830 --> 00:35:06,030
and we've got some 70% memory better

00:35:04,020 --> 00:35:08,670
memory use and all of that and with open

00:35:06,030 --> 00:35:12,140
source net so there's it's it's rapidly

00:35:08,670 --> 00:35:15,870
moving but but it's still far far behind

00:35:12,140 --> 00:35:17,460
same goes for the tooling so yeah at

00:35:15,870 --> 00:35:19,110
some point you you if you use this kind

00:35:17,460 --> 00:35:24,440
of soft prepared be prepared to to

00:35:19,110 --> 00:35:24,440
actually step in and since contribute

00:35:26,600 --> 00:35:31,940
so summary so we talked about we talked

00:35:30,410 --> 00:35:33,680
about graph so I think they they're

00:35:31,940 --> 00:35:36,710
fundamentally a much simpler model than

00:35:33,680 --> 00:35:38,150
then relational databases relational

00:35:36,710 --> 00:35:40,160
databases have the wrong name because

00:35:38,150 --> 00:35:43,940
they actually not bad graceful

00:35:40,160 --> 00:35:46,790
relational domains they're far for graph

00:35:43,940 --> 00:35:48,530
there is of far less mature there's like

00:35:46,790 --> 00:35:51,470
depending on the use case you might use

00:35:48,530 --> 00:35:53,450
our in for our use case graph to be so

00:35:51,470 --> 00:35:56,630
perfect and relation the bees would be

00:35:53,450 --> 00:35:59,900
would be very bad your mileage may vary

00:35:56,630 --> 00:36:02,720
it's a very active field as well as new

00:35:59,900 --> 00:36:04,160
in the open source as in the close

00:36:02,720 --> 00:36:07,190
source there's lots of stuff going on

00:36:04,160 --> 00:36:11,540
and we talked about granny Scala how you

00:36:07,190 --> 00:36:14,150
can embed and how nice Scala is for

00:36:11,540 --> 00:36:17,120
funding a DSL and how chrome in Scala

00:36:14,150 --> 00:36:19,160
lets you let's see define your personal

00:36:17,120 --> 00:36:20,960
in the types of way and help you happy

00:36:19,160 --> 00:36:24,560
of compounds on rather than having to

00:36:20,960 --> 00:36:27,790
cast your way around right and that's

00:36:24,560 --> 00:36:35,719
that's basically all I have thank you

00:36:27,790 --> 00:36:35,719

YouTube URL: https://www.youtube.com/watch?v=XIYBbJhhd9k


