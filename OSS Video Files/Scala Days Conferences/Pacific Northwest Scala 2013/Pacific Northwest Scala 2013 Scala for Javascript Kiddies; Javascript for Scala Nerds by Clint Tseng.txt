Title: Pacific Northwest Scala 2013 Scala for Javascript Kiddies; Javascript for Scala Nerds by Clint Tseng
Publication date: 2020-01-27
Playlist: Pacific Northwest Scala 2013
Description: 
	What do you do if you are a Scala lover who writes complex, interactive web application interfaces for love and for a living? What do you do if your company writes software that aims to bring about radical change in government, but you still have to play by government rules? What do you do if nothing out there satisfies your needs for both a fantastic user experience and beautiful, functional code?

In this talk I describe how a quest to fulfill a government mandate for accessibility led to the development of a new interface framework based largely on Scala-like philosophies, and how one small monadic abstraction can change the entire face of a codebase. We will cover how Functional Reactive Programming can be usefully applied in a imperative-functional hybrid environment, and the upsides and downfalls of attempting to apply a very Scala-based mindset onto a fully dynamic language like Javascript. The work covered in this talk culminated in a framework called Janus (https://github.com/clint-tseng/janus), and while very young, the implications and influences behind it are very strong, and very much derived from my time learning and building Scala code.

Help us caption & translate this video!

http://amara.org/v/FG70/
Captions: 
	                              alright cool so my name is Clint I'm a                               designer from a company called Sakurada                               and at the impossible task of following                               that up this is made more impossible by                               the fact that I just finished a slide                               deck about three hours ago and have not                               run through them at all so we'll see how                               this goes bear with me we're gonna this                               talk is called scholar for java script                                kiddies and JavaScript for scala nerds                                and it's kind of about taking the                                lessons that we can learn from a                                language we love dearly despite its many                                flaws uh-huh and applying them in                                different ways and I'm going to open by                                saying that nothing you see here is                                going to be new we're going to talk                                about a application framework that's                                pretty old and we're going to talk about                                real simple abstraction and i'm pretty                                sure nothing here is new and that's not                                going to be the point of the journey so                                what's the point of journey what are we                                talking about what we're talking about                                this thing called Janus which is an                                application framework that that we built                                at socata we're going to talk about what                                it is we're going to justify his                                existence because we should do that talk                                about where it came from the                                consequences of decisions that were made                                and then closed with some difficulties                                around trying to take a functional thing                                and put it on top of JavaScript uh-huh                                so what exactly is JavaScript well it's                                a web application framework focused on                                organization of interface code into                                reusable pieces it's not an application                                form work that cares about networks or                                databases or any of that stuff it's just                                about organization but there are a lot                                of things that do this in the JavaScript                                world there's backbone and angular all                                these hip things that are out there so                                why does this thing have to exist why                                did we go and build this in order to                                explain that I kind of have to talk a                                little bit about the company I work for                                and I promise not to shill too much but                                we are hiring and we do a lot of Scala                                and we have a lot of really cool                                projects we have a JSON library that is                                completely reflection free and if you                                didn't look closely you would swear that                                was black magic but that's not the point                                the point is that our company uses data                                and technology to improve informed                                it's and that means a lot of things we                                have a really cool data API we have a                                really rich interface application                                interface but the key point for this                                talk right now is that word governance                                because it means we work with city                                government state governments and federal                                governments and that means that we are                                beholden to certain regulations and laws                                                                                                       means on the web is that by the time                                your application hits the users web                                browser over the wire before JavaScript                                has loaded it needs to be consumable and                                the big problem is that most of the                                JavaScript frameworks out there don't                                care about this they don't look at this                                at all in fact the the routing library                                that actively use to power this                                framework says explicitly if you're                                trying to use this on the client and the                                server together you're probably doing it                                wrong well no we're gonna try to make it                                work and it turns out that making things                                work for                                                            work for SEO so this is something that                                we're interested in now right now the                                way we deal with this at the company is                                we write everything twice right at once                                in Ruby right again in JavaScript and                                that makes it very difficult to build a                                coherent codebase that actually provides                                rich interaction without sacrificing                                quality so let's talk about sort of the                                the principles behind the framework                                because if we're going to define                                something new we need to make sure that                                we're doing it in the right way so of                                course the top priority as I just                                mentioned is reusable code the same code                                should run on server and it should run                                on a client with almost no modification                                 there should be no if server if client                                 checks if possible next thing should be                                 componentized different parts of an                                 interface should function together and                                 you should just be able to compose them                                 together and if you're going to do                                 something multiple times you should be                                 able to call it again again and this is                                 something that like you know as                                 JavaScript programmers we didn't figure                                 out in develop until about three years                                 ago so you know that's pretty cool and a                                 cool result of being componentized is                                 that things are more unit testable                                 that's also something that javascript                                 communities just sort of figuring out                                 and last but certainly not least it                                 should be live bound the framework                                 should do                                 work of making sure that the state of                                 your interface is the state of your                                 world you shouldn't have to do that work                                 yourself and that's also something that                                 is kind of near with backbone and                                 backbone gives you the tools to do that                                 that doesn't take it all the way and                                 make the opinions that it needs to order                                 to make it automatic we'll talk about                                 some influences so jQuery is of course                                 the JavaScript framework for                                 manipulating the Dom it solves the DOM                                 and so far as it can no one just in                                 replacing that use it as much as                                 possible backbone is as I've mentioned                                 sort of the preeminent organizational                                 framework it provides an MVC idiom and                                 it has a lot of really well understood                                 principles and practices no interest in                                 trying to supersede what it does there                                 if finally d                                                           hold near and dear because secretly it                                 is a declarative and functional system                                 most people don't realize that when                                 you're using it because their JavaScript                                 programmers and they'll think about                                 those things but secretly when you're                                 using be through you're declaring that                                 this piece of data should be drawn in                                 this way and you have no state in                                 between so that's pretty cool so scala                                 i'm here at the scala conference where                                 scala as an influence hadn't crossed my                                 mind didn't even come up not even a                                 thought in my mind and we'll see how we                                 get there so let's examine some of our                                 goals one of our goals is that you know                                 our framework should be live bound to                                 HTML and you kind of look at this is                                 like in one possible set of HTML you                                 would have you have like a class where a                                 person is new right that person is new                                 and that may change over time that is a                                 state that could change and you look at                                 the way HTML is formed that's kind of a                                 difficult thing to principally change                                 because when you ask the Dom for the                                 class of this dave is going to tell you                                 person space new and that's not a very                                 easy thing to manipulate and you'll also                                 look over here and let's say we have a                                 string colon some other string that's                                 also another thing where you know short                                 of using you know bracketed templating                                 is very difficult to express what that                                 means and when when I looked at this                                 problem and tried to solve the idea of                                 running a piece of code on the server                                 that generates a set of markup generates                                 a sub state and sends it down to                                 I and attempts to use that state                                 seamlessly then you start going well                                 this stuff better be idempotent this                                 stuff better work the way it should no                                 matter what the existing state of the                                 system is and that is sort of                                 restriction number one that leads us                                 down the path let's talk about the model                                 side of things so this is how backbone                                 does stuff there's you have a person you                                 can get stuff out of it you can set                                 stuff into it and then they have sort of                                 an event-driven data model so you can go                                 through and say well if the first name                                 changes I want to do some imperative                                 thing and then so I modeled after that                                 if you get a person the one changes you                                 can nest into objects because they                                 didn't bother to deal with that you get                                 a person's name first you can set the                                 first name and then I kind of did this                                 thing we can watch a person so instead                                 of just being event-driven I give you a                                 thing that encapsulates some state and                                 and so personnel watch gives you a thing                                 that encapsulate state that changes you                                 can do named off first and I just like                                 as an afterthought almost threw in this                                 little thing work well maybe you want to                                 transform it may be like as the thing                                 changes you want to get something else                                 so my friend lil a really likes putting                                 ! after her name so maybe that's                                 something want too often this is                                 something I built in um so now we talk                                 about mapping these two things together                                 so you have a template here's a fragment                                 of HTML there's no like bracketed                                 templating inside of it and then you                                 have a binding so binding is what takes                                 the state of your model and maps it into                                 that DOM and here you can see that we                                 have we take a first name the sorry the                                 first name class which does not actually                                 say first name and I say its name um so                                 we're finding that div that is                                 incorrectly named and we want to set its                                 text from the first name in the last                                 name and given that i have this sinkhole                                 flat map and you take name the first and                                 last and you're thinking to yourself                                 that's not a flat map and that's                                 absolutely true because i was coding us                                 at two a.m. and couldn't think of what                                 to name it so i said well what's the                                 most confusing thing i can think of so i                                 called it flat map and that's a joke but                                 that word is actually what then                                 triggered the things in my brain to                                 start thinking about this                                 because when i was learning scala that                                 was the first time that i had really                                 seen the concept of a map being used on                                 something that wasn't an array right                                 being a javascript a Ruby programmer you                                 see map a lot but it's always just well                                 I want to do these things to this array                                 you think of it in terms of arrays and                                 it turns out that well mapping a single                                 object is a perfectly valid thing to do                                 so knowing that and having made the                                 realization I went back to the object I                                 have encapsulated state called a varying                                 and added map to it now you can see here                                 the existing things you can create a                                 thing with state with a value you can                                 just imperative to the set value on it                                 that's not a big deal that's fine and                                 then on change we can we can handle some                                 things so I demamp to that so you've                                 passed in a function and we'll give you                                 a new varying that will you know take                                 the existing one map this value and                                 every time it changes admit the same                                 events with the new value and then I                                 kind of thought to myself oh this is a                                 monad and bear in mind this is the only                                 time you're gonna hear monad in this                                 talk um and I kind of thought well I can                                 put a thing in a box and you can take                                 that thing in another box and I actually                                 auto collapse varying together which                                 sounds really dangerous and it's only                                 burned me once surprisingly um and I was                                 like well maybe it's a monad and I spent                                 about a week trying to figure out if it                                 was or not because I'm not the best at                                 this stuff and eventually I went oh who                                 cares because the audience for this                                 framework doesn't know anyway so it                                 seems close enough that the safety is it                                 guarantees and the things that                                 represents are probably there and if                                 something bothers to correct me about it                                 i'm happy to take it but that's kind of                                 what happened there and this varying                                 class ended up being sort of a key to                                 the whole thing here's the whole thing                                 um this is an overview of the main                                 components that comprise Janice is                                 actually a very small code base in terms                                 of lines but as you can see there are a                                 lot of things here so first thing we'll                                 talk about is model we kind of already                                 covered it here's an example model you                                 have a person in extends model there's a                                 thing called bind if a value is                                 explicitly based on some other values                                 you can just sort of bind it so if I                                 always want the first the full name to                                 be part of based on first and last then                                 I just take first and last and can cat                                 them together                                 and to Paul's point earlier about                                 restriction javascript does weird things                                 with this when you're in a function you                                 can sort of rebind the keyword this to                                 whatever on earth you want and so when                                 we're inside of this also incorrectly                                 name flat map uh this is just nothing                                 you're not allowed to access anything                                 else you're given the things you                                 declared and that's it and that's sort                                 of a very simple restriction put in                                 place to make sure people are on the                                 right path and the whole time I was                                 writing this I kind of had to choose a                                 line between being overly restrictive                                 and guiding people on the right path and                                 here's one case in which I chose to be                                 restrictive you can also just declare                                 any random methods of course and the                                 right way to do it in the framework                                 philosophically is to make everything be                                 based on the varying so if i want to                                 check if something is of age i don't                                 return true or false i return a varying                                 of a boolean and so i'm watching age and                                 I'm mapping it to see if it's greater                                 very cool                                                               lists lists are pretty cool these are                                 again largely based on backbone ideas so                                 you have people we declare that the                                 thing is that it as a person just so                                 that we know what to do with the things                                 inside of it when we try to serialize or                                 DC realize there's through in this last                                 element just to show that you can watch                                 out in index so for example if you want                                 to watch the very last index that will                                 always be there and then the interesting                                 thing about the list here is that it has                                 these familiar-looking filter and map                                 things and the thing that accepts is                                 also a varying so if over time a person                                 becomes of age we're going to                                 automatically update the list to contain                                 those new things so you declare what you                                 want to have happen and it's the                                 framework takes care of everything else                                 for you it's not obviously correct but                                 it's getting there all right attributes                                 are just little bags of behavior this is                                 wrapping poorly because the projector is                                 small but you can see that we can we can                                 map alive as an attribute and defines                                 and behavior behind it and here you can                                 see I'm using so this anonymous class                                 thing and like in my brain what was                                 screaming to me was traits are pretty                                 cool and so that's how that                                 mug because it was a lot easier to do it                                 this way then to come up with a bunch of                                 random functions to pass in so here we                                 can declare that alive is by default                                 true an issue is an interesting thing so                                 a difficult thing in front-end                                 frameworks usually is trying to come up                                 with how do I validate things in a way                                 that makes sense because this thing                                 might have                                                               thing has three and they're all                                 different and I don't want to have some                                 central repository of validations and it                                 ended up being easiest to actually just                                 concat issues and flag them as whether                                 they're active or not so based on the                                 earlier facilities you solve for                                 filtering and concatenation we can just                                 declare that a person the person's age                                 is comprised has possible issues                                 comprised of this list and here's one                                 possible issue which is it is an issue                                 its active if the age is less than or                                 equal to                                                                but that's okay it is very severe and                                 here's the message to say which is a you                                 know given that age the age is not valid                                 because as less than zero I forgot to                                 actually put the agent a string but you                                 get the point and these are all                                 concatenated together onto the model                                 itself and then you have a list of                                 issues that may or may not be active and                                 they're filtered on that a view so a                                 view manages the interaction between                                 model and presentation and here we see                                 one we use jQuery to do some things and                                 here you see an imperative thing this is                                 extraordinarily imperative and this is                                 why this class exists alone in itself                                 all it does is declare the behavior of                                 interaction and so you can see that here                                 we're trying to find the delete link                                 when you click on it we prevent default                                 which is a silly front end then you                                 don't have to worry about and then we                                 destroy the subject and as a very                                 imperative thing and we try to limit all                                 the imperative things to to this class                                 and that that's sort of how we achieve                                 being able to do the things we want                                 without burdening ourselves with a lot                                 of machinery so a view uses a temp later                                 to actually do the binding against                                 the fragment of markup so here you see                                 we declare that the dom is based on this                                 thing this thing of markup that the                                 implementation detail doesn't matter but                                 more importantly you see that we have a                                 binding and the binding here we're                                 finding the person div you saw a little                                 bit of this earlier and we're declaring                                 that it has the class of age depending                                 on whether the age is greater than equal                                 to                                                                   whether the ages is greater than equal                                 to                                                                   potent thing and it also goes back to                                 the functional and the restrictive thing                                 when you're in that method you are where                                 near net function you have no access to                                 any state of the world except for what                                 you declare you wanted to use and                                 whatever you do maps directly onto an                                 idempotent action upon your from market                                 fragment and then you can see we can                                 also take some texts from the full name                                 and week also render a view another view                                 based on friends so that's sort of the                                 template or a template or just contains                                 a bunch of binders so you just saw that                                 so that's that thing so how then do we                                 manage state that is purely view based                                 well we just create another model so if                                 you have state that's just in the                                 interface for example if you want                                 something to be expand or not just                                 create a model and then you can nest the                                 thing you actually care about inside of                                 that and access them just as easily as                                 you access the attributes themselves and                                 then you can map against that very                                 easily so now we get to the one part of                                 requests are one part of networks that                                 we care about which is often when you're                                 coding you need to refer to something                                 that's elsewhere that happens kind of a                                 lot and so you know I thought about this                                 problem on a very long walk home once                                 and try to figure out how to make it fit                                 in the framework and I went wait this                                 varying thing indicates something that                                 can change over time in the future is                                 just a thing that changes at some point                                 in the future so I kind of already have                                 a future so all a request is here you                                 can see an initial is era and                                 implantation of a specific request all                                 requests is it um extends HTTP requests                                 which in turn extends varying and so it                                 is just itself a varying and it might                                 have one of these possible values                                 as possible classes as a state so it                                 might be in it it might be pending it                                 might be success it might be error or                                 more that aren't listed here and here                                 you can see me thinking to myself case                                 glasses are pretty cool I want to be                                 able to pattern match and so so that's                                 where that came from and being able to                                 do that sort of thing and we'll talk                                 about the consequences of that decision                                 later and then later you can end down                                 here you can see that in order to                                 actually use that request once we've                                 handled it all we have to do is just say                                 well take what we've succeeded to be                                 given on given that varying depending on                                 whether the value inside of it is                                 successful and then we can map into that                                 success if we want to get a value out of                                 it the store is just the thing that                                 imperative Lee handles the request so we                                 have an HTTP store it handles the thing                                 does a bunch of imperative async stuff                                 which is in this case just all Ajax and                                 then at the very end it imperative Lee                                 sets the result in the request this is                                 okay we've again taken all of our                                 imperative stuff and boxed it into one                                 place and that's really the goal here so                                 you can see in a sample usage of a store                                 is just well here's my request and given                                 some store library I'm going to get the                                 appropriate store for that in handle                                 requests so what on earth is a store                                 library here's where the part where                                 we're in javascript is really awesome                                 because and types are just kind of                                 whatever in JavaScript beans Wild West                                 can do whatever you want so what a                                 library is is just a tight based system                                 in a heritance based system that just                                 reflects all over the place and then                                 determines given this object what do you                                 want to do what you want done with it so                                 you can for example in this case make a                                 new library doesn't doesn't care what's                                 inside of it and we're going to register                                 that any model can be rendered using a                                 general model edit view in a context of                                 edit and now if we try to get a person                                 for context of edit we're going to get                                 this spain on the same line we're going                                 to get a general model edit view and                                 this is really cool because this is what                                 ends up solving the divide between the                                 front end or the client and the server                                 this is what enables us to create a set                                 of components that handles the                                 appropriate thing one place handles are                                 appropriate thing in the other place and                                 puts it all together in a way                                 you're not if switching because you just                                 register a different set of components                                 in each environment and here's where                                 javascript has a major advantage because                                 we can just be completely cavalier about                                 this and not really care the compiler is                                 not going to throw a hissy fit at you so                                 that's sort of the the overall stuff so                                 here we kind of put it all together so                                 you know if we write stuff here you can                                 see I've got an edit renderer into an                                 attribute it binds against that fragment                                 of Dom on the right we're gonna give him                                 a name we're gonna say he's negative                                    years old and oh no negative                                           valid age is less than zero so we can go                                 back and fix that or we could introduce                                 another error which is like oh no first                                 name cannot contain a number what kind                                 of name is that and so this is sort of                                 all of the pieces briefly working                                 together so let's talk about some                                 problems with this whole endeavor the                                 first one is NPM NPM is the package                                 manager that powers node it is                                 extraordinarily pedantic if two                                 different modules referenced the same                                 module even if it's the exact same                                 version it instantiates a completely                                 separate instance of it which there are                                 great reasons behind doing that mostly                                 learned from the Ruby community but now                                 you have a problem where I'm doing                                 things like X instance of Y with those                                 pretend case classes earlier and                                 suddenly why is not the same depending                                 on whether I'm in my project or in my                                 application if I have two things at both                                 for the impound Janice suddenly I have                                 two ideas of what success status to                                 ideas of what in init state is and                                 there's really no way around that so                                 right now actually just export Janice to                                 global that's the only way I could                                 figure it out so we're fighting NPM with                                 with tight based comparisons what's                                 what's another problem that we have well                                 lying to the user is something we have                                 to do frequently for example earlier you                                 saw that when I took away the validation                                 error the thing on screen disappeared                                 immediately that's not a very good sense                                 of indication you should be able to see                                 that you succeeded and then it should                                 disappear bit after that it but because                                 of the way that this is all functional                                 tightly bound against the truth there's                                 no way to be like wait hold on lie to                                 them for just a bit so I created a                                 framework called lie you can see um                                 here's here's how we would do for                                 example you know the nifty thing in                                 facebook where you hover over a link and                                 it appears a little box and then if                                 you've however off it disappears but                                 there's a delay on each side and here's                                 how you'd normally do something like                                 that in JavaScript make a timer you'd                                 say well here's my view here's my link                                 when you hover over onto it I'm going to                                 clear that timer because you just hover                                 it on to it i'm going to set a new timer                                 and then when that timer expires my show                                 a pop-up but then when you hover out i'm                                 gonna clear that time out and then also                                 may be destroyed of you there's about                                 six different bits of state that are                                 happening here they're all entangled                                 together into this piece of code and how                                 can we use a simple abstraction clean it                                 up well here's a varying based version                                 they are hovered or not that's just true                                 or not and you can see we declare                                 hovered and then on the third line there                                 we say well when you hover set it to                                 true and when you uncover set it to                                 false that is the truth and then we                                 apply a simple abstraction to lie to the                                 user so we use a sticky liar and I lost                                 that screen but not that okay and if                                 it's true will lie to them for an                                 additional eight hundred milliseconds                                 that is still true and if it's false                                 will lie to them for an additional four                                 hundred milliseconds that is still false                                 and now we get that delay behavior                                 without polluting our own code base with                                 six different kinds of state and so then                                 we just react on that on that varying                                 and then we show show the view if it's                                 true the improvisation doesn't really                                 matter there um what's another problem                                 with doing this sort of thing in                                 JavaScript doing real functional stuff                                 in JavaScript language hates you can                                 anybody tell me why this would fail this                                 is a valid thing to want to do you want                                 to reverse a series and show to the user                                 but why why would this fail do you think                                 seems pretty obvious that it should work                                 so the answer is that reverse both                                 returns a reversed array and mutates the                                 original array and this was a bug that                                 cost me a whole day the language                                 absolutely hates you and does not want                                 you to use it in that way what's another                                 reason the language hazy well there are                                 no compilers there's no compiler and                                 there's no types Janice the four                                 work is pretty small as a small piece of                                 machinery but it runs deep and because                                 of the way it sort of accepts                                 declarations and just does whatever it                                 wants with them means that if you make a                                 small mistake with what method you're                                 calling or what you're passing into                                 something it takes a really long time to                                 dig it all out because you have to dig                                 into this big piece of machinery gee                                 wouldn't be nice if it told me if I was                                 passing in a string instead of a                                 function and I do I was doing the wrong                                 thing another bug that cost me a full                                 day so that's another problem there and                                 then the last thing is that it's real                                 tough to debug because if you have an                                 imperative framework that manages a                                 bunch of state for you and you try to                                 put functional stuff on top of that what                                 it means is that by the time you've                                 cascaded down to your very last map of                                 your very last varying and you're like                                 here is the problem you've lost all of                                 the other functional things that were                                 entangled inside of this imperative                                 framework code and that's that's                                 actually one of the biggest problems is                                 that the last problem compounded with                                 this one means that your end code is                                 real small and compact and it's                                 functional and you can see that it's                                 correct but it's it's impossible to                                 figure out what went wrong if you did do                                 something wrong and that's because maybe                                 we're thinking about debugging wrong and                                 here's like this is early work where by                                 early i mean i started it seven hours                                 ago and by work I mean clearly it                                 doesn't work that well because i can't                                 get d                                                                    but in case it hasn't become obvious yet                                 this deck is actually written in Janus                                 the entire thing is a deck model with a                                 list of slides and there's a current                                 slide that's based off of a watch of the                                 very last slide and each flies is itself                                 a model so here is a rendering of the                                 actual current state of the system you                                 can see that my deck is down here or                                 right there deck and I've got a current                                 based off of that which is my current                                 slide you can see is currently entangled                                 with                                                                 this slide you can see back on slide                                    when we were messing with jebadiah's                                 name we created a person and that                                 person's name was jebadiah and they were                                                                                                         state of the system the next step is to                                 actually be able to go back in time have                                 a slider that shows you this                                 and then this happened and this happened                                 and this happened and that's a much                                 better way to look at a whole bunch of                                 functional code is just what happened I                                 don't care about the lines themselves i                                 just want to see what happened and how                                 those effects cascaded through the                                 system so that's all a big trip through                                 a system and the system itself doesn't                                 matter I tried to emphasize every time I                                 did something with influence where that                                 influence came from and of course a big                                 part of that it was my time with Scala                                 as hopefully you gleaned I'm going to go                                 back to a claim I made the start which                                 is that nothing here is new right these                                 are all very simple things functional                                 reactive programming is not new now                                 usually is based on events dreams rather                                 than the actual n value but I'm very                                 certain that talking about the value is                                 not new either what's new is taking a                                 bunch of different influences and                                 putting them together it feels new and                                 and so here's here's the point of the                                 entire thing don't ever be satisfied                                 don't be satisfied with your own                                 knowledge that's obvious but also don't                                 be satisfied with your own community if                                 you have a lot of different influences                                 is going to teach you ways to different                                 ways to think about problems sometimes                                 something as simple as joke naming a                                 method flat map at                                                  entire series of effects and don't ever                                 be satisfied with accepted practices and                                 this is something right Victor says a                                 lot too you know you should program                                 things and you should build things to                                 work best in the medium that you're                                 talking about if debugging is hard with                                 the line debugger may be lying debugging                                 is wrong maybe you should be doing some                                 other thing in the in the theme of never                                 being satisfied they're actually several                                 things I wanted to put in this slide                                 deck that I just didn't have time to and                                 when this light that goes online on                                 github which it will in the next few                                 days there will be more in there so I                                 encourage you to check it out but for                                 now thank you very much and I'll take                                 whatever questions you                                 hit his open source in the licenses WTF                                 PL so what friendly Oh search engine                                 friendly so um I didn't emphasize it                                 because it wasn't the point of this talk                                 the point was influences in Scala but                                 the same piece of the same pieces of                                 code are capable of running on a server                                 and on a client so the server will                                 generate a piece of markup through this                                 system that you just saw and that piece                                 of markup is dropped into the web                                 browser and the exact same piece of code                                 well then on a client pick it up and go                                 oh hey here's markup and here was my                                 model state on the server I can trust                                 that the state of the mark-up is                                 accurate to what I wanted to be and I                                 don't have to rerender it I can just                                 pick it up and start binding the same                                 kinds of state transformations against                                 that Dom that I would want to directly                                 yeah yeah so I am familiar with element                                 and I spent some time with it but it was                                 it is one of those things were like it                                 was very high concept and I couldn't                                 really get into it so honestly if I were                                 to name a difference that would probably                                 be it was is that this is meant to be                                 you know just very work that's my time                                 or telling me my presentation is done um                                 it's meant to be accessible and familiar                                 to the way JavaScript programmers want                                 to work there are a lot of chaining                                 api's some of which actually want to get                                 rid of because those are mistakes but                                 that's something that's familiar to                                 JavaScript programmers there's a lot of                                 you know anonymous functions being                                 passed around and that's something                                 that's familiar so I would name that is                                 probably the biggest difference cool                                 thank you very much                                 you
YouTube URL: https://www.youtube.com/watch?v=Lu2FNroF7w8


