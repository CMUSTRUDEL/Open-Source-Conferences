Title: Pacific Northwest Scala 2013 We're Doing It All Wrong by Paul Phillips
Publication date: 2020-01-27
Playlist: Pacific Northwest Scala 2013
Description: 
	My conclusion after moving a million lines of code is that everything we do (plus or minus) is wrong. Henry Ford said "If I had asked people what they wanted, they would have said faster horses." Our horses are now a billion times faster: our horses may well be the fastest in the galaxy. Are we too comfortable on our horses? Would we recognize better mounts if they came along, but didn't look like horses? Is the state of our profession one which warrants pride, shame, or despair? I will explore these questions with unwarranted optimism.

Help us caption & translate this video!

http://amara.org/v/FG7Z/
Captions: 
	                              hi I'll have you know in advance that                               I'm as disappointed by this talk as you                               will be this same thing always happens I                               put                                                                   things that I really ought to and it's                               about                                                                you know expectations on zero all right                               I guess everybody doesn't know who I am                               so that's who I am that that is a                                complete statement there is not much                                more to be said because that that                                bonfire there is my life over the last                                five years                                Oh turski keeps a nice even flame over                                ten and I'm more of a burnout and go                                home which two in fact I have in some                                sense which is why I get to give a talk                                called we're doing it all wrong because                                in principle I'm not the one doing it                                all wrong anymore I don't know if that's                                the case or not we'll see so to                                understand the things that I say you                                have to know that it's somewhat                                emotional for me because I have I mean I                                have invested a huge chunk of my life                                certainly like the most productive years                                of my life in a manner of speaking into                                the scholar fomentation and typesafe                                continues on without me and I it's you                                know they're all my friends over there                                and you know since Scala's got a huge                                chunk of me in it I'm rootin for these                                guys completely so please don't infer                                anything from the things I say in this                                talk which could perhaps be interpreted                                as critical and once in a while given                                that they almost have to be because I                                quit over this stuff right so I mean                                there's no way to reconcile that                                criticism that has to come out so anyway                                I love them and I hope they do well but                                I don't know if they will so that's                                what's next and you know I'm going to go                                up and do something else but the of                                course I'm going to be writing it in                                Scala let's just start it's not like I                                have a better idea so at the very least                                I can endorse Scala relative to the set                                of existing alternatives pretty strongly                                some sense but I mean I I judge things                                compared to what could be and not what                                is so it's like it's not good enough to                                be like you know the strongest of the                                little kids brawling when you could be                                you know like the big kid next door and                                I just think we could do the whole                                enterprise way better it's I have felt                                this for a while and the feeling has                                become too strong to combat so I would                                love to be able to say there's here's                                the thing I wanted to give you a silver                                bullet bad news there is no silver                                bullet and there's no one thing that is                                being done wrong oh and I should clarify                                what I mean by we're doing it all wrong                                because my experiences are largely                                informed by working on the Scala                                compiler implementation which is you                                know not necessarily relevant to Jay                                random project using Scala but it is in                                fact relevant there's a bunch of overlap                                between the failures of design and the                                failures of programming practice that                                take place in the compiler and how that                                manifests for you as a user of the                                compiler these things are sort of go                                hand in hand so I think the people that                                use a language end up unconsciously                                modeling the people that make it so if                                you have issues at one level they're                                going to make themselves felt at the                                next level as well there's some good                                nutshell pictures so when I propose this                                talk as usual just trying to make                                something up to get somebody off my back                                so that I could go back to programming                                pretty much the story of my life I'm                                made up the title this talk and I had                                something very different in mind but I                                definitely didn't think that I would                                find out that we're literally doing it                                all wrong but I mean that is kind of how                                it felt when I sat down to write                                everything down                                so this talk like forget this is so                                incomplete like my list of issues with                                the way things are done in programming                                in general and in Scala particular would                                fill this room with paper so the more                                 that it's like that the more likely it                                 is that I'm delusional and not actually                                 like useful to listen to                                 so I I leave it in your hand like I'm                                 just self-aware enough to know that I'm                                 almost certainly crazy too to think                                 anything like that but I do think that                                 in all honesty so you have to you have                                 to assess I can't assess but I guess if                                 there was one little sort of pity a                                 prism I would throw out there something                                 that I've noticed repeatedly people                                 don't consider when they think about                                 like I want thing X Y they don't have it                                 or Y it's hard the Scala compiler is so                                 ridiculously difficult to modify that                                 you have to be a rocket scientist you                                 need a degree in rocket science II like                                 printed or you can't do it the most                                 trivial modification is a tremendous                                 undertaking almost everybody fails it's                                 amazing the things that people do                                 accomplish but what they have to go                                 through to do it is crazy this holds                                 Scala back more than anything and so so                                 I would say the biggest thing that we                                 are doing wrong there and I think a lot                                 of people are doing wrong is not holding                                 modify ability in their heart as with                                 the esteem that it needs to be you                                 cannot let your codebase deteriorate in                                 such a way that you can't modify it if                                 you can't change it you can't fix it if                                 you can't move things around it will                                 ossify and then then you're go off the                                 cliff and there's that you can see it in                                 the Scala compiler as well there's this                                 point when things are you're kind of you                                 know holding stasis and then you go off                                 a cliff because it's gotten too big to                                 ball of mud the ball of mud mark                                 architecture has won and now you're just                                 trying to stave off your inevitable                                 defeat so but I've never heard it put                                 this way like you know about modify                                 ability because well for one thing when                                 one of these interesting tensions that                                 we always had there is that Martin is                                 less keen on some modifications that I                                 make that he is now the way I see it I'm                                 making modifications so I                                 don't have to modify it more right it's                                 like I also appreciate the benefits of                                 not modifying things it's great that's                                 stability but it has to be right right                                 it's like if it's right then we cannot                                 modify it but you can't like not                                 modifying it when it's wrong or                                 difficult to work with is bad so you                                 know these are these are the struggles                                 of our lives so this is my this is                                 another of my little a prisms if it                                 isn't straightforward to modify it will                                 never be any good I will stand by that                                 one so we go around and we use this                                 language that can do a billion different                                 things and we use it for a billion                                 different things most of the time the                                 thing that we're doing doesn't need                                     of the power that's before us if I'm                                 expressing relationships if I'm saying                                 this thing has this quality and this                                 thing I don't need it tied in with a                                 bunch of initialization order stuff and                                 whatnot I mean I'm making some logic                                 based timeless assertions in a very                                 simple limited language and yet I take                                 on every single thing that Scala could                                 possibly do in order to do that and now                                 anybody who deals with me has to                                 consider every single thing that Scala                                 could possibly do and this is just an                                 explosion of unnecessary complexity if                                 you limit what you say then you limit                                 what you have to understand and they go                                 hand in hand and then I have my favorite                                 kind of mean concrete example of this                                 and it's mean because you know it's                                 inherited from Java but so what                                 when we want to compare two things we                                 get a result and it's less than equal to                                 or greater than that's it that's all                                 that there is we allow for no other                                 possibility except throw an exception so                                 we take those three possibilities and we                                 encode them in                                                    and we say alright let's just take this                                                                                                        it will say first                                             means less than zero means equal greater                                 than zero the other two point                                           means greater than it's good it's fine                                 like it's essentially you know it's a                                 mapping on to whatever you call the you                                 know ejection it's in surjection or an                                 injection model whatever it's great it's                                 fine it's not fine but it's worse than                                 that because now we've it's an int it's                                 not even like some nice specific                                     billion State thing that at least we can                                 associate with the concept of a                                 comparison it's just regular int so                                 everything else that we use in for is                                 exactly the same so here we are using a                                 language with types and we've                                 essentially just abandoned it completely                                 and so you know maybe you can keep your                                 comparisons straight maybe you can't but                                 it's it's this kind of thing in the                                 aggregate that is devastating to                                 correctness because you can't trust                                 anything I just got an INT what's that                                 mean well I don't know it might mean you                                 know the number of ducks there is in                                 this bucket or it might be less than you                                 know who knows it might be failure to                                 find an index I don't know what it is                                 it's an int so the reason that examples                                 kind of mean again is that like well you                                 know we had to do that because you know                                 Java so I've spent the last five years                                 not it along with all manner of                                 decisions that I was less than pleased                                 with that were made on the basis of                                 either performance and I usually say it                                 like this performance or compatibility                                 and its compatibility the scare quotes                                 if they're not apparent are there to                                 tell you that the it's more it's used                                 more as sort of like a appeal to                                 amorphous Authority in the air than it                                 is like there's it's not like I've got                                 the numbers it's for performance it's                                 like I don't want to deal with that it's                                 for performance that's how it's going to                                 be and I'm pretty sure that the great                                 majority of interesting compatibility                                 can be achieved without the kinds of                                 compromises that Scala has made                                 certainly not the                                 Mises to the integrity the type system                                 where there were very easy things could                                 have been done such that we wouldn't                                 have Universal equality running around                                 all over the place which is really                                 devastating to like you know type save                                 equality and whatnot I mean there's a                                 lot of examples compatibility is                                 something that you achieve by mediating                                 the conversation between thing and thing                                 B it's not something that you achieve by                                 polluting the model of a so that it                                 looks a little like B that's you get the                                 worst of both worlds that way but this                                 is mostly in my opinion what's been done                                 in Scala I'll just let you read that                                 slide because this is me being funny I                                 wonder if there's enough people any that                                 are old enough to recognize the graphic                                 yes who likes the graphic from LA means                                 so not that we're lemons but it was the                                 first thing that came to mind the                                 essential logic at work here is what it                                 feels to me like and the worst thing is                                 that you know we're following doing it                                 like Java does for java's reasons and                                 then you know we get one-upped by Java                                 that's when we really get burned like in                                 Java                                                                 work so you know now we've been actually                                 been lapped by Java and that's that's                                 not cool it's like there's what we ought                                 to be leading on that sort of thing and                                 we're not so I hold a special place in                                 my in my black heart for universal                                 equality I don't know like I'm not sure                                 what the room is full of like whether we                                 have lots of like I like monads types or                                 I started in Java so I mean because you                                 can get all kinds of receptions on this                                 sort of thing because people basically                                 they feel the pain of this sort of thing                                 in different ways all the way from like                                 what are you talking about it's great                                 and to like it's the devil but anything                                 that is designed into the core base root                                 object and that works on any's is                                 essentially a complete abandonment of                                 type safety and                                 it makes it it does it in a way that's                                 impossible to recover and you you know                                 you could have a type safety in your                                 core things and give it up but you can't                                 not have it and then make it appear out                                 of thin air except by abandoning and                                 avoiding the operator but because of the                                 way equality is privileged in Scala you                                 can't avoid it there's no way around it                                 you you want to use the collections you                                 have to use it you want to use a pattern                                 matcher you have to use it so they're                                 just in my view no good reason for                                 making these kinds of decisions in a way                                 that everybody is faced with them and                                 nobody can improve on it should be the                                 other way around                                 opt out of type safety don't make people                                 try to reconstruct it so yes a                                 capricious mistress so in hindsight and                                 I'm not going to claim that I was like a                                 hundred percent on top of this going in                                 at all like you know because there are a                                 number of things where I've said like                                 don't do it and I feel like all those                                 don't do it have been correct this is                                 not one I didn't like understand what a                                 mistake this was but you if you're going                                 to try to use inheritance to share                                 implementation you better be sure that                                 there's something useful to be derived                                 from doing so it turns out that you with                                 mutable and immutable collections you                                 literally are in like grave danger from                                 the other implementation everywhere you                                 look so you must you like your cook you                                 must override like methods I would say                                 that a good rule of thumb is if you feel                                 you must override methods or your class                                 is going to be wrong the inheritance is                                 probably the wrong tool but that's very                                 much the case in Scala collections and                                 many bugs have been just from letting a                                 method fall through too far such that it                                 gets caught by the mutable guy at the                                 leaf right I mean because it's not                                 optional the mutable class must not                                 share a little bits of itself into other                                 things but the immutable class must or                                 it's way too expensive it's a                                 performance bug just as much as the                                 other is a correctness bug but they're                                 both bugs so if that's going to be the                                 case if one of the others always wrong                                 then it should be abstract it should not                                 be a thing where we define the                                 implementation up here override it to                                 avoid it here and let it                                 through over here there's no gain in                                 that there's just massive like                                 intertwining complexity which is exactly                                 what we have unfortunately so in                                 hindsight there should be no shared code                                 between mutable and immutable there's                                 some things you just can't abstract over                                 and this is one of them                                 but that's that's where it is and it's                                 just you know there's no way to fix this                                 kind of thing now it's not that there's                                 no way like inherently there's no way                                 against the forces of not changing                                 things and so there it is so I like                                 talking about tails and dogs for some                                 reason to me you know it's like it's                                 always been the thing it's like oh we                                 can't do it that way that would be too                                 slow but you know what you know what                                 slow is spending all day trying to                                 figure out why it doesn't work that's                                 slow that's the slowest thing I know                                 what's you know however slow it is when                                 it runs and gives the right answer                                 that's still pretty fast compared to ah                                 which is you know pretty typical day                                 when when the tails wagging the dog                                 so if correctness is like paramount                                 interest performance will come because                                 you can see right if it's like if it's                                 obviously correct as opposed to you you                                 know there's many good quotes out there                                 one way is to make it have no obvious                                 defects and the other way is to make it                                 with obviously no defects this                                 distinction is like completely lost on                                 beginning programmers it's like the most                                 key distinction right it's not enough                                 for it to be correct it has to be                                 clearly correct visibly correct to the                                 next guy right if you program that way                                 and you actually able to maintain that                                 over a decent sized codebase the                                 performance will come you can't write it                                 slow enough that it can't be optimized                                 if you can see what it's doing if you                                 can modify it but conversely it's                                 impossible to make it fast if nobody can                                 modify it and again that's like the                                 Scala compiler will never be fast I'll                                 it's just never going to happen the poor                                 though I don't know how many the poor                                 bunch of lives into it and and there                                 will be in many tears and blood but                                 they'll never make it fast                                 not with that rewriting it                                 never happen it's just the way that it                                 is it can't you can't because you can't                                 make it fast for one thing without like                                 much greater concurrency stuff going on                                 right I mean and you can't bolt that                                 kind of thing on after the fact no                                 matter you know people are always like                                 yeah I can do it I don't know in our                                 company or my ex company I guess it's                                 you know it's hard to speak in the right                                 tense and types a should certainly know                                 better and I hope that they do on some                                 level know that you cannot bolt to                                 something as crazily mutability                                 everywhere ten years of sequential                                 thinking you cannot take a two hundred                                 thousand line piece of software along                                 those lines and say all right we'll just                                 you know make some adjustments and it'll                                 be running apparent it's never going to                                 happen they can't even get reflection to                                 be thread safe I mean that's like after                                 lots and lots of work it's maybe you                                 know who knows maybe they get there but                                 that's just the tip of the iceberg                                 that's my little clever channeling Ben                                 Franklin those who would give up                                 correctness for a little temporary                                 performance deserve neither correctness                                 nor performance yeah so this is a really                                 good example of the problems that come                                 with not having restraint like if you                                 can do whatever you want then we have to                                 assume you're going to do whatever you                                 want which means we can optimize nothing                                 filter on an immutable collection you                                 ought to be able to return the original                                 collection if nothing changed that's                                 like an obvious optimization but because                                 filters defined as like returns a new                                 collection with the stuff that meets the                                 test and you can actually see the                                 difference with reference equality then                                 we don't know if they don't have like a                                 condition on the next line saying well                                 if the return value you know who knows                                 what they're doing with it but one way                                 or another it's easy for things to break                                 in the face of I tested this for                                 reference equality and now it's not                                 reference equality anymore or it was so                                 the upshot is you can't you just got to                                 allocate until the cows come home even                                 on these like obviously true situations                                 and there are many examples of this                                 where it's impossible to optimize                                 because the semantics aren't locked                                 down it's you know we've presented all                                 these mechanisms for inspection after                                 the fact and no way to limit them and so                                 you're you just basically have to say                                 all right so I mean it's an endless list                                 things like fusion you know if I've got                                 a collection and I do map flatmap filter                                 group by to do now I wrote a macro at                                 some point that would just take you know                                 take an expression like that and fuse                                 all the expressions into one and you                                 know you get in just massive speed at                                 brutemen right if it's like filter                                 filter filter I'll just make it one                                 filter and it's three times faster                                 literally and yet can't do it because                                 who knows what side effects might be                                 hidden in the filter functions don't                                 know and so you're out well you can that                                 you can if you get out in front of that                                 sort of thing and just define it that                                 way you can't have side effects in your                                 filter functions then you get this huge                                 opportunity but you've got to do it so                                 Scala hasn't done that and it's very                                 like the hands are tied behind back and                                 they've been thrown over the side with                                 the concrete shoes it's very difficult                                 to optimize so maybe they'll get there                                 with like very painful like massive                                 purity analysis etc etc but that's just                                 making it too hard there's lots of                                 people out there very willing to program                                 in a particular way so that it's easy                                 for you the compiler rider to optimize                                 but you've got to give them a way to do                                 it if you give them no way to do it then                                 everybody loses                                 so in pulpy fictional language which you                                 know might not be fictional forever                                 reference equality is not something you                                 would have by default I don't want you                                 making that inspection and if you're                                 going to do it you're going to have to                                 like declare that you're doing it so                                 that I can see that you're doing it and                                 everybody else you know I will assume is                                 not doing it because they won't have any                                 operator to do it with another in the                                 well if Java jumped off a bridge what                                 would you do is the semantics of of                                 silent coercion between primitives                                 that's in top maxvalue now I                                 think I could come up with a long list                                 of things we're in top max values                                 actually makes a difference to subtract                                 from something right to some billion but                                 not here                                 there's no warnings there's nothing                                 that's just something scholar will                                 happily do same thing long whatever you                                 know shave off                                                       equal we're in a happy floaty world                                 there's no way out of this it's not like                                 it's not enough that it exists at all                                 you can't get out you can't even opt out                                 I just I'll never get used to this sort                                 of thing right like I don't care whether                                 nobody uses floats whatever I just don't                                 want like obviously wrong things at the                                 core of the language I'm using that's                                 just drives me nuts I wouldn't I would                                 hope that anybody that thought                                 correctness was an interesting value                                 worth pursuing would feel similarly I                                 always get this scream guy into my tada                                 cookies but that like that's a perfect                                 depiction of like me in my office                                 so the the picture is supposed to make                                 you think you can go really fast and                                 still lose the greatest performance                                 improvement of all is when a system goes                                 from not working - working a movement I                                 have experienced less frequently than I                                 would like and the third one is very not                                 very veiled sort of description of Scala                                 see because again it's like there remain                                 these periodic like stepwise jumps in                                 performance taking place in the compiler                                 it's not because like you know we got                                 the next Einstein just was born it's                                 because somebody finally stared through                                 the noise long enough to see the obvious                                 thing that we're doing that's blasting                                 away tons of performance I mean I think                                 there's probably a factor at n lying                                 around it's it's that bad even now even                                 having myself sunk hundreds of hours                                 into profiling the compiler but it is so                                 hard to pinpoint what's doing what and                                 why the and it's impossible to modify so                                 again it's the same thing you can't make                                 it fast                                 if you can't change it so it would be                                 easy to quibble with any particular                                 example in here well some more so than                                 others but it's the aggregate effect                                 that I'm after in that have you ever                                 seen anybody who went out to excel at                                 some activity some you know golfer or                                 whatever have you ever seen them like                                 neglect the fundamentals in the pursuit                                 of whatever it is that the high-level                                 guys do you will not see anybody like                                 that they are masters of the                                 fundamentals and they remain masters of                                 the fundamentals and only when they are                                 confident in their ongoing mastery of                                 the fundamentals do they work on the                                 things that you build on the                                 fundamentals that's how you get good at                                 things these things are like                                 fundamentals that you're not good at and                                 yet there we are out there like at the                                 leading edge of type nuttiness and macro                                 land and all kinds of stuff you can't                                 build on that and so you end up with                                 this terrible feedback loop of like your                                 own flaws are grabbing at you from below                                 and they make everything more                                 complicated on the way up is you have to                                 work around those flaws your work around                                 start duplicating across your codebase                                 and competing with each other I mean it                                 is literally like you have to unravel                                 the maze of workarounds to get back to                                 what started out as a small thing but                                 because it was sitting there under                                 everything it's it has had far-reaching                                 effects it's just not the way to do it                                 you have to get the fundamentals correct                                 you you know there's there's a process                                 there's an order and really if anybody                                 here knows anything about like airplanes                                 please don't do it like yeah just like                                 that I mean that it's like I've got to                                 fly from place to place and that's the                                 last thing I need to know that like even                                 like anybody that I self-identified as a                                 professional programmer was involved                                 which terrify me it's like I I want to                                 hear only like civil engineers that have                                 been converted and retrained I mean I I                                 genuinely think we're terrible at it as                                 a profession like it's shameful and I                                 include myself in that so there's no                                 such thing as a general purpose                                 and if I didn't mention it before my                                 slides are not going to win any awards                                 for like this might be end up at the end                                 a little bit like one of those cartoons                                 where you got a reorder like to make it                                 make sense so it's like as I put a ton                                 of time into it and yet it's never                                 enough and so I don't know this this                                 probably was designed to come a little                                 bit earlier but the examples at the                                 bottom are good examples do you really                                 want your this is it really the same                                 language that you're speaking when you                                 make a statement like take this register                                 and increment the value of this register                                 in place which is like basically you                                 know it we're talking load accumulator                                 type like move EAX versus this type is                                 you know going to conform to this type                                 in some abstract universe with no time                                 state or place it's like just a sort of                                 a eternal law that I'm stating for the                                 purposes of these are like the opposite                                 extremes by a million miles if you are                                 putting those things anywhere near each                                 other you're doing it wrong let me tell                                 you and but we whatever you're doing the                                 one you've got the other right there and                                 it doesn't matter if like you use it                                 it's the possibility exists at all times                                 it's not the same language it's not the                                 same task it's not the same set of                                 things that you want to express and so                                 you end up jack of all trades and master                                 of none so this is more to belabor the                                 same idea but I don't mind belaboring                                 because you're captive audience                                 um the everything that like whatever                                 your tools are for talking the other                                 side has got to have the tools for                                 listening whatever it is that you can do                                 the other side's got to be able to make                                 sense of what it is that you can do and                                 there's a really unfortunate thing in                                 that each new way of talking that you                                 get becomes like geometrically a burden                                 on the listener because they've got to                                 consider you so let's say there's a                                 hundred ways for you to express                                 something you go out and he's like pick                                 mom is just going to pick that one and                                 that one and that's how I'm going to                                 talk and it'll be nice and easy but                                 they've got to all you know consider all                                 things at all times                                 and who knows what kinds of interactions                                 so that it's like for them it's this you                                 know this barrage of possibility even                                 though you're only carving out a little                                 space and it seems reasonable to you in                                 your little space from the other side                                 it's this crazy huge universe you have                                 to limit the size of the possibility                                 universe                                 you can't just limit the size of what                                 you use so this is where one looks Scala                                 and says well there's an awful lot going                                 on and especially it's going on at all                                 times there's no you know there's no                                 reasonable subset like I only use maybe                                 half the language I want to be able to                                 only use that half and then reap the                                 benefits of only using that half because                                 they are significant but it's I can only                                 do that in a very limited way myself I                                 want to be able to do that with other                                 people right it's like the the real                                 thing is to be able to reuse other                                 people's code something we're so                                 terrible at it's so hard and you know we                                 make it harder so yes it's another                                 little aphorism which is probably                                 ambitious in this case but unnecessary                                 expressiveness is the enemy it's I I                                 stress it because it is such a natural                                 thing to think more power is better and                                 right and like I'm sure we've all heard                                 on you know sort of like on a rational                                 basis that's not true and probably no on                                 a rational basis that's not true but                                 intuitively it's very likely we don't                                 accept it we're like yeah more power I                                 could do stuff right because you think                                 about doing stuff but you don't think                                 about being on the receiving end of it                                 or especially just being on the                                 receiving end of the possibility of it                                 but that's where all the victims are                                 those are the silent evidence the bodies                                 the battlefields full of bodies it's all                                 the things not done because it was too                                 complicated because of all the stuff you                                 could have done if that makes any sense                                 so the real power and this is all this                                 is all like Zen master you know none of                                 the real power is in not having the                                 power but it's true right it is through                                 restriction that we gain power it is                                 through the less that we can do the more                                 that we can do with what we did the less                                 that we can do the more that we can opt                                 a                                 - which is very important for                                 encouraging like the right kind of                                 programming if half the reason we do all                                 this bad stuff is for performance well                                 if we could you know properly optimize                                 immutable you know nice code there                                 wouldn't be that kind of gap but we                                 can't                                 we're hamstrung on that point so we end                                 up all right well here we go VAR I                                 equals                                   let's do our I mean it's sick it's crazy                                 it's                                                                     have an index I and be going like in a                                 loop I equals I plus                                                  should have been retired                                              it's crazy like the compiler can't do                                 that it's very upsetting as you can see                                 I I mean really it's like that's what I                                 mean when I say that we're terrible is a                                 profession because it's sick it's sick                                 that like new new kids or I'm teaching a                                 class at my daughter's school and you                                 know it's like they don't have an                                 enormous amount of like programming                                 expertise and they go to code Academy                                 whatever and it's like the first thing                                 they're teaching ugh here we go with                                 like a loop and an i counter like why is                                 it the first thing we're teaching them                                 this is like the worst thing to put into                                 their heads teach them just you know                                 something that's completely without                                 values just you know like map anything                                 the limits of my language are the limits                                 of my world so I carry that with me all                                 the time because what you cannot say you                                 cannot depend upon to have a language at                                 the top that was much smaller than Scott                                 see we already use this hodgepodge of                                 languages right well you know you've got                                 like your ant build with your crazy XM                                 like the worst possible language at the                                 top XML and then your series of other                                 languages on the way down God knows but                                 you're almost certainly you have a                                 hodgepodge of like shell XML Java and                                 Scala like even a little project it's                                 easy to walk into having at least those                                 four and maybe a bunch more so and so in                                 some sense you're already doing this but                                 I mean what if there was like a more of                                 a design situation right it's you have a                                 language essentially that contracts at                                 the top two high level concepts doesn't                                 have a means for expressing time or                                 state and only as it means for                                 expressing what you want to express                                 which is the relation                                 between large abstract entities and                                 that's it and then as you go down you                                 gain the power to express more things                                 but now you can your as the listener you                                 get to deal with less it makes a big                                 difference separation of concerns and                                 forced by construction by construction                                 these are like my favorite two words                                 because the compilers full of these                                 places where it's like well here we go                                 let's try to you know like make sort of                                 handle this situation no no you you just                                 created it you don't need to go back and                                 then try to make sure you did it right                                 excuse me you can just you can just                                 create it right in the first place you                                 can do it by construction I have a very                                 recent commit if you're interested in                                 reading code that rewrites the Pickler                                 which is the serialization of trees to                                 disk that takes place to use the regular                                 treat reversers and there's a page of                                 code that is essentially visually you                                 you look at it and you know it's correct                                 you can't help it because of the way                                 that it happens just rolls out an order                                 and it's done there's the trees it's                                 it's a perfect example I really like it                                 I should I should have a slide of the                                 difference between like obviously no                                 defects and no obvious defects which is                                 what it had before so all these layers                                 so reality being what it is let me just                                 see what time it is later than I thought                                 anybody want to give me a hint how long                                 I actually get stock when all day I                                 should I'll time things a little because                                 I okay all right because I don't want to                                 spend the entire time slagging off Scala                                 because I do have a little bit unlike                                 what I think we ought to do so I might                                 have to fast forward I'm going to fast                                 forward a little bit so that I don't not                                 get to that so here we go a lot a lot of                                 these slides will be online if you                                 really are interested now here's a                                 little joke that I can't help because I                                 really liked it when I thought of it so                                 those were those were like three little                                 things that I sort of thought of as you                                 know guiding principles and they're not                                 catchy enough so it's trying to come up                                 with a catchy expression and then that                                 works a lot better yeah because it does                                 work right                                 ignorance is strength is especially good                                 because that is what a non leaky                                 abstraction is you can be ignorant and                                 therefore you are strong because you                                 don't have to worry about what's inside                                 the abstraction it's true and freedom is                                 slavery if there's total freedom of                                 action you are enslaved by all the                                 possibilities of things you have to                                 handle I mean it's completely prophetic                                 so and that's that's why the thing about                                 anyway war is peace is the like the                                 absolutely layer boundaries like if we                                 will fight our wars at the boundaries so                                 that we can have peace internally so                                 there there are two guys from whom I                                 draw inspiration and it's funny because                                 they would like totally have come to                                 blows the two of them one of them is is                                 Dykstra here and I you know like this                                 really captures so much of what the                                 compiler should be in isn't as a series                                 of machines that are genuinely written                                 in terms of abstractions that only exist                                 because you wrote them if more stuff was                                 written like this we would be so much                                 better off if you I mean be and it can                                 be like that right if you have a large                                 ish system then what you have are little                                 blobs of logic that are operating in                                 terms of some internal logic the                                 underlying levers are things that you                                 write but if you you have to isolate it                                 segregated do not allow for to reach                                 through and do a bunch of crazy oh                                 that's oh this you make it its own thing                                 and enforce it and you actually have a                                 separate component something that is                                 like plausibly modular but you you must                                 be ruthless about it                                 you can't fake this stuff it's got to be                                 you know enforced by construction not                                 enforced by like well the rule is                                 generally we don't call from point A to                                 point B that's not going to do it                                 nobody's good enough to do that and                                 nobody will alright so in the very brief                                 time I have remaining I will give you a                                 complete picture of my plan for the next                                                                          so programming language misses the point                                 as far as I'm concerned I don't need a                                 programming language I need a set of I                                 need a set of tools that help me make                                 software a programming language is                                 something I will need sometimes but not                                 even that often oh really I'm generally                                 I want to programmatically generate a                                 STS and feed those and I want to be able                                 to do basically pick and choose exactly                                 how I'm going to do stuff whether it's                                 going to be with text with something                                 some kind of you know tree form or                                 something even later in the pipeline but                                 basically I want really well-defined                                 entry points into a series of things                                 with really well-defined languages                                 something that is very much not offered                                 by our tremendously entangled compiler                                 which doesn't even have a clean parse                                 tree well it's it's comical try to get                                 back to the source code from what you                                 get out of the scala parser and it's                                 crazily far from what you started with                                 that like to me the minimum test of a                                 parser is that it parses but it parses                                 and then does a bunch of D sugaring                                 which is like really difficult to                                 unravel and it makes it impossible to                                 tell the difference between like a for                                 comprehension and a call to map you                                 can't even tell them apart by the time                                 you get the parse tree and that's not a                                 parse tree that's a parse tree and then                                 I add some fun with it you know we                                 played football why and if you think                                 about it like even though this is what                                 everybody does it's kind of nut why is                                 the canonical representation of code a                                 string isn't that like the like strings                                 like the universal data type that we                                 like to throw everything into and buried                                 string is not a good like basis for                                 things for anything right it just                                 happens to be like the thing that we                                 edit the code that you look at that                                 ought to be a reflection of the actual                                 ASC like the canonical thing ought to be                                 the tree right the code is a view of it                                 and when effect you have of that                                 is that the language becomes unimportant                                 you could actually have like if you                                 don't like curly braces whatever great                                 doesn't matter right because you're just                                 looking at a view                                 of an AST but it's the AST that's                                 important this would also allow us to                                 define things far more tightly than they                                 are presently defined it's the ast                                 behavior that matters it's not you know                                 you don't have to worry about like                                 exactly what's expressible and surface                                 syntax and work out all these syntactic                                 collisions that we have people can make                                 their own decisions about that the                                 language of interoperation ought to be a                                 tree it's trees that are fundamental                                 that's what we work with so I've got                                 this whole vision it's pretty cool take                                 a while to implement but so there's got                                 to be a VM that's running much closer to                                 you than the JVM there's just no way                                 that like you can deal with all the crap                                 that is the JVM and have a good                                 experience I want something that is                                 interpreting exactly the language that                                 I'm writing so I'm going to feed an AST                                 whatever the ast is going to be designed                                 alongside the VM so that the VM is                                 designed to interpret the ast it'll be                                 interpreting exactly what you wrote not                                 something a bunch further down the road                                 right exactly what you wrote and from                                 this we can get like instant feedback                                 really fast right we have all the time                                 in the world to compile down to bytecode                                 that's like machine code that's somebody                                 help this problem I need a tight                                 feedback loop on the thing I'm working                                 on right now and so there is a lot of                                 opportunity there this thing in green                                 that was going to be the basis of the                                 whole talk and instead it just became                                 this one line in green but you got to                                 design the language and the VM and                                 everything around change around diff as                                 being the fundamental entry right it is                                  you don't we go back to the beginning                                  you change one letter in one file and we                                  go back to the beginning and parse                                                                                                            Everything Everything Everything                                  Everything Everything Everything to get                                  back to where you were why we had                                  everything that we just did was already                                  valid all we had to do was change one                                  letter we have no means to do it but all                                  day long you edit code you're not                                  changing a thousand things at once                                  you're changing one everything should be                                  designed so that one change can                                  come in and do its work this would also                                  have the benefit that we would know a                                  lot more about what the impact of a                                  change is something that we are you know                                  very ignorant of right now so that's I                                  want that to be like the fundamental                                  design principles it's all like it were                                  it's the first derivative of what we do                                  right now and okay let me get to my guys                                  at the end here I'm going to skip all                                  this you can look it online so if you                                  want to see some of what I'm talking                                  about if you haven't already this guy is                                  fantastic                                  that's his site and he's got to talk on                                  there like the one talk of going to                                  watch one thing called inventing on                                  principle and if you watch that and you                                  know if you haven't seen it before you                                  don't come out of that going like that                                  guys talking about some stuff that's                                  good then you're crazy and then you've                                  surely heard of this gentleman who has                                  much to say about our flailing and this                                  must be rolling over you know all day                                  long and it's grave but you know it sees                                  all of these quotes from the                                           remain exactly is vital if not more so                                  here's one the programmers themselves                                  are responsible and nobody else and yeah                                  that's the case so but we can do better                                  and I hope that we will thank you for                                  your attention                                  so I guess I used up all my time for                                  sure but I'll be around the next two                                  days with no plan so if you want to know                                  anything feel free all right then                                  five minutes for questions yeah I begged                                  them not to not to just export the                                  compiler to I begged them I begged them                                  not to do it                                  will this apart this sort of surprise is                                  that because of the light that was                                  shined on the incredibly terrible code                                  it has gotten way better iPad and so                                  it's hard to say that it was a mistake                                  in that sense now anybody who is like                                  attempted to use macros or whatever has                                  been like the the victims on the altar                                  of that but it had a tremendously                                  beneficial effect on though of compiler                                  now it's amazing like how good that                                  effect was and how bad it still is like                                  you you know it's like you have to keep                                  readjusting your estimate of the                                  distance to goodness but yeah so it's                                  hard to say nothing like nothing's ever                                  going to be stable anywhere near where                                  it is now like I think the whole                                  reflection library should be thrown out                                  etc but just the fact that anything has                                  any chance of working is big progress is                                  I don't know if that's at all blue                                  spinel folks yes yeah the good parts                                  right well I've actually thought of I                                  thought no no my I still have enthusiasm                                  for enough Scala that I could write                                  skull of the good parts I would like to                                  actually because I just know so much                                  about what's a bad idea but yeah that's                                  I don't know I don't I don't get enough                                  time to program as it is it's hard for                                  me to think about writing books but it's                                  a good idea yes                                  thinking that the next sort of era of                                  programming will be with when you're a                                  progressive qualified to write their own                                  language completely well we must have                                  reached that boy to my bigger most                                  perfect to eat in like fiddle with like                                  oh so ready yourself parser well it's it                                  doesn't even reach the level of                                  something to consider right it's it's                                  it's not even on the radar that's like                                  you know they talk about like maybe ten                                  years from now we're teaching                                  programming like reading and writing you                                  do that then nobody gets out of school                                  without having written a compiler now we                                  now we can enter the era where that                                  happens but I think it's a ways off of                                  quite a ways it's not a question or                                  comment for me the advantage of macros                                  is that it puts it it puts it in a very                                  sharp almost total end to the Cascade of                                  attention deficit current students                                  language features art art art are now                                  sauce you don't have ten okay pick Tyler                                  it's only a macro so today they can't                                   it in the unfriendly well I'm not                                  sure that was the optimal way to get                                  there but I agree that the Cascade of                                  attention-deficit grad students was a                                  good thing to put a to staunch yes yeah                                  I mean I've looked at it enough to know                                  what you're talking about and every time                                  I'd like try to basically it's like                                  there's the activation energy is too                                  high even though they even though it                                  seems to be really good it's still too                                  high it's got to be lower like you've                                  liked the one thing I know for in the                                  absolute core of my heart is that it                                  must require absolutely no investment of                                  energy or commitment or anything or                                  nobody will ever look at it and I assume                                  that is what's happened with MPs I don't                                  actually know people I have no patience                                  for IEDs so I'm the wrong guy to ask but                                  I mean I like the idea and I think it's                                  kind of Turing tarpit in its in the way                                  that it plays out in that like that's I                                  don't need like that level of generality                                  what I need is a really opinionated like                                  set of tools designed to work together                                  in the way that I describe which is like                                  different than MPs if you catch my drift                                  yes have you looked at any of these sort                                  of matryoshka doll languages where you                                  have a very small corporate in the                                  language has levels because like Dai                                  raha quitting is strangely but merging                                  this year presented on a language that                                  had like ten or twelve levels it starts                                  with something like purely functional                                  very small and just gets bigger and                                  bigger and bigger heads in concurrency                                  this that the other funding mutations up                                  at the three outwards with it I will                                  want to pick your brain on that point                                  because like I know that in functional                                  programming world like this is good at                                  super tempting and again and the Turing                                  tarpit again beckons right like if you                                  actually implement in this way and                                  you're like whatever you do if you're                                  nine layers away from doing an addition                                  then it's going to be a problem so it's                                  like you have to make very tasteful                                  compromises and maybe that's where the                                  art is going to lie I'm not sure but I                                  would love to see what's been done yes                                  is your question yeah how's that                                  question alright yes successful I'm just                                  playing calmly this problem scanned over                                  ground we walk smart people like if you                                  think of excellent above the obesity                                  rate yeah but well I can't though it so                                  the thing it can't because of the                                  language in the installed base basically                                  there are a thousand points within the                                  implementation that people depend on                                  that nobody knows what they are when you                                  change it and that breaks them that's                                  when you find out what they are if you                                  set out to rewrite it you would break                                  all thousand of them you can't you                                  without knowing what it is that your                                  code does and what it is that like                                  because the the implementation is the                                  specification anybody who's followed                                  like my struggles knows like the                                  specification has been the big deal to                                  me for years and it really is like the                                  the straw on the back is that I cannot                                  get anything like we have no                                  specification essentially it's useless                                  and yeah there's just no way you have to                                  get there incrementally so you really                                  doomed if you could rewrite it that                                  would be something now clearly it like                                  you know they think of like old like                                                                                                        drag life out of that by throwing a lot                                  of smart people at it clearly great                                  things can be done but typesafe has a                                  compiler team of three people it was                                  four and when I quit they didn't replace                                  me so it's three and and Jason is like                                  ten which is not which is not to                                  minimize the other guys but J like if                                  you don't have Jason                                  you're dead because you need a guy like                                  Jason or like me who's so sick that they                                  will chase this ridiculous ridiculous                                  thing for days to finally find out how                                  it is that it could act like that and                                  you and I don't know like you have half                                  as many of those guys as you did and if                                  Jason ever says like I'm giving this up                                  you better find another one and I don't                                  know where you find another one go                                  alright that's cool again I'll be around                                  so feel free to ask me anywhere anytime                                  you
YouTube URL: https://www.youtube.com/watch?v=TS1lpKBMkgg


