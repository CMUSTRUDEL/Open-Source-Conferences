Title: Pacific Northwest Scala 2013 Akka in Production: Our Story by Evan Chan
Publication date: 2020-01-27
Playlist: Pacific Northwest Scala 2013
Description: 
	Everyone in the Scala world is using or looking into using Akka for low-latency, scalable, distributed or concurrent systems. We want to share our story of developing and productionizing multiple Akka apps, including low-latency ingestion and real-time processing systems, and Spark-based applications.

When does one use actors vs futures?
Why did we go with Logback instead of Akka's built-in logging?
Can we use Akka with, or in place of, Storm?
How did we set up instrumentation and monitoring in production?
How does one use VisualVM to debug Akka apps in production?
What happens if the mailbox gets full?
What is our Akka stack like?
We will share best practices that we've discovered when building Akka and Scala apps, pitfalls and things we'd like to avoid, and a vision of where we would like to go for ideal Akka monitoring, instrumentation, and debugging facilities.

Help us caption & translate this video!

http://amara.org/v/FG6p/
Captions: 
	                              everyone how's it going good welcome to                               pnw scholar my name is Evan so we've had                               two talks on let's see a pod an                               excellent talk on Scala what's wrong                               with it and wave a talk on JavaScript                               we're going to change tags a little bit                               i'm going to be talking about acha today                               I'm a staff engineer who yalla namely if                               you've watched any video on espn.com                                victoria secret REI you've probably used                                our software without knowing it we                                process of the video that consumers                                watch from a lot of sites and my Twitter                                credentials and get up account if                                anyone's interested and that'll be it                                for me so you want reactive programming                                how many people have heard of the term                                reactive programming yeah it's trying to                                get around there's a really cool site                                called the reactive manifesto that talks                                about the new way to build applications                                instead about reactions blowing things                                up well no not really but it's about                                building event-driven scalable resilient                                and responsive apps today like it's no                                longer enough to do the standard the old                                Java model with a thread per user you're                                processing stuff we need something more                                and so a lot of you guys might be                                looking at acha how many people here                                have heard of caca okay good and how                                many people of you stalker in and have                                our code systems in production nice nice                                so just this talk will be useful for a                                lot of you maybe some of you are                                thinking of using play players gone a                                lot of press players built almost                                entirely Anaka right so what we'll talk                                about is how we use acha at loyola and                                our experience with using a production                                and some tips and tricks and we'll also                                show show some Scala code examples as                                well who we are so we Allah was founded                                about six years ago by                                Google engineers we since the very                                beginning we have put a pretty big                                emphasis on analytics that realizing                                that it's really important for video                                publishers to understand you know where                                the contents coming from and so we do a                                huge amount of volume like every time                                someone watches a video the events dream                                to our servers constantly we get up but                                we get over two billion I mean this                                slide is actually owed I think we're                                over                                                                   start using Scala so we were actually                                mostly a movie company plus a little bit                                of javascript actionscript it's C++ here                                and there even MapReduce jobs that was                                pretty interesting and our experience                                with what we learned out of that was                                that ruby is not really a good fit for                                big data it is it is slow it is very                                slow actually it has it has no type                                safety now the type safety thing ruby is                                good for a lot of things but the problem                                with using it for big data and                                especially for our dupe is how many                                people have tried to unit test or write                                or functional tests to do a more jobs                                it's yeah I only say fueled hands like                                it's not very easy and especially via                                but it's just a language that is not                                typesafe it becomes really really hard                                we can't have some percent every code in                                Ruby then you're in trouble and it's but                                this is especially true for mr where you                                have long cycles Ruby works well when                                you have really small iterative like                                loops right you can arm you can run                                stuff again and again really really fast                                and correct mistakes and for mr that is                                not true we started exploring Scala for                                real-time analytics and for arm and mr                                jobs and what we found was that using                                Scala gave us an order or two orders of                                magnitude improvement over mu be pretty                                awesome so today we use Scala and akka                                for basically all of our big data                                pipelines what's storm spark Cassandra                                how many people here at heard of spark                                cool I will talk about spark                                but if you're interested in talking                                about spark with me I'm also a                                contributor to spark now the core one of                                our core problems is that when you when                                you first build a when you put a big                                data pipeline the first things that you                                 have to ingest events so let's say user                                 is playing video that goes into                                 something like engine X server and and                                 then we process a little bit push you to                                 Kafka and then we have more processing                                 steps up to words so this slide just to                                 give you some context to the other whole                                 bunch of slides coming up about how we                                 use it so the first scala app that we                                 build we call it live locks t that takes                                 locks from engine X and tails it and                                 right to the kafka so you can imagine                                 that engine X writes out a log file                                 that's a current file then then what are                                 those it rotates at every I don't know                                 minute five minutes you know whatever                                 right and what we did was we have an                                 actor that is tailing each file and it's                                 rotated it keeps tailing it and what                                 that allows us to do is that it you know                                 if we fall behind a little bit you know                                 then we can we can essentially tale like                                 multiple files if we fall behind we can                                 once the new file gets created we can                                 tail it right away and we can feed these                                 events it was very very simple that kind                                 of like test app it was what acha one                                 dot three or something like that it was                                 like early days so that's it next we                                 decided to do a real-time analytics                                 product and at that time storm had just                                 come out so everyone was very excited                                 about it we started to try to use it now                                 you might ask the question what this                                 archive do of storm it turns out not                                 that much I mean you don't have to use                                 akka and storm but in storm you have                                 what are called bolts and bolts are                                 individual processing units and they can                                 be scheduled anywhere you just tell                                 storm what it does and it figures out                                 where to go and how to tie them together                                 here's a problem though is that both can                                 live on different nodes and they might                                 die or we get restarted independently                                 and for some and for part of the                                 pipeline we didn't actually want that we                                 wanted whole bunch of components that                                 were concurrent to start up together so                                 we decided to use                                 several aqua actors within a boat that                                 talk to each other so kind of just an                                 interesting use of vaca now what                                 occurred to me doe that one of the                                 interesting things that occur to me                                 about acha was that storm could have                                 been actually built with Daka but it's                                 it not what do we find about using storm                                 is that in production storm is difficult                                 to troubleshoot there's we had a lot of                                 nights at                                                               the heck is going on at                                               really have patience to figure out you                                 know what what stuff is going wrong you                                 see that on every note storm at                                 supervisor in process then it spins up                                 several worker processes in addition to                                 that it has a a single master code                                 nimbus and in there Sookie / and and                                 you're not really sure what is going                                 wrong so you start restarting services                                 he starts to keep her which you                                 shouldn't do you do we start Nimbus you                                 restart the supervisor you're trying to                                 figure out you know what why is the                                 performance not up to par it there's a                                 lot of moving parts and it becomes and                                 there's a lot of log files also it's not                                 easy to separate out like just figuring                                 out you know did something happen or not                                 looking at several log files it's it's                                 not easy so instead we started to for                                 our new ingestion pipeline we decided to                                 move away from storm and a use acha                                 entirely now this diagram shows we were                                 trying out aqua cluster if you haven't                                 heard of our cluster is really neat it's                                 a amazon DynamoDB style system where                                 it's peer-to-peer so you spin up a                                 couple notes they gossip and you talk to                                 each other if new notes come up they                                 know that they exist so this is really                                 cool we tried it out when it came out in                                 experimental mode into that one and what                                 happens that we thought okay we want to                                 build an HTTP ingestion service because                                 that way multiple users can talk to it                                 the one team can owned a chubi service                                 which is really nice from a separation                                 standpoint for team wise so what we do                                 is we have spray endpoints and HTTP                                 endpoints then                                 I talked to a cluster router now the                                 cluster routers will know which note to                                 spread messages to the reason is because                                 we have processing that happens and                                 there's some state in it so we want to                                 be relative measures to the correct node                                 based on a quest isn't hash and you can                                 do this in a cluster so this was fine we                                 got it up and running on to a production                                 cluster however this was still do                                 complex the question again became do we                                 want to get page for the system there's                                 again you know multiple nodes talking to                                 each other and we found that in                                        least our cluster wasn't ready for                                 production yet there is still like you                                 know no to be going down and we wouldn't                                 be able to bring them up I think that                                 the new version is actually pretty                                 stable now it's no longer experimental                                 it's at two dot-to-dot one now so I                                 don't let this this way you from using                                 it I was saying that at that point it                                 was not ready oops sorry let me go back                                 a bit and the other thing is that doing                                 HTTP in Scala often means dealing with                                 futures futures are really nice because                                 I don't know if you like if you're not                                 aware future basically a future lets you                                 say I want to do some work                                 asynchronously and then get back we sell                                 later and this is perfect for HTTP                                 because HP is request response i want to                                 send some work out and do it later now                                 in order to for this to work with acha                                 you mix you mix it in with actors so in                                 the future you from HTTP you might send                                 it to some actor and for it to do some                                 work and there might be a chain of                                 futures but what we found was that                                 mixing futures and actors is also a bit                                 complex and the other thing is that from                                 a development standpoint we have a lot                                 of employers that are you know you know                                 we're very few people that are seasoned                                 in scholar and explaining futures is                                 actually not easy i I've had multiple                                 times when I've had to explain what                                 futures were you know when things happen                                 and just conceptually it's kind of                                 difficult to grog whereas we never had                                 any problems explaining actors to people                                 people just seem to get act                                 like very easily maybe because they map                                 very well to object-oriented now                                 framework so that's just something                                 something that we found so finally we                                 evolved our pipeline to be a really                                 simple design what we do is we use Kafka                                 to partition messages based on a certain                                 key you can send messages to different                                 cup competitions and one of the first                                 rules that you've heard about distrib                                 systems is don't distribute so in this                                 system there's no distribution other                                 than spreading messages across                                 partitions and Kafka you have                                 independent acha processes data sweet                                 from Kafka and write to Cassandra there                                 is a pipeline of actors there's first                                 act to reach from Kafka second one                                 decimal conversion the third one writes                                 it it's actually little bit more complex                                 than that but it's still a linear system                                 it's all actors and it's very easy to                                 understand so we're finally at a point                                 where we have a very easy system to                                 deploy a very easy to debug if anything                                 goes wrong it's just one process one                                 lock file and it's been running very                                 well so since is the Scala talk I'm                                 going to switch a little bit to talk                                 about stackable traits of traits of one                                 of the great features in Scala you can                                 put a little bit of functionality and                                 mix different traits together but this                                 turns out that you can stack them also                                 and you can do some pretty cool stuff                                 with it now when you production ice-cold                                 you often start to add you know your                                 beautiful little function starts to look                                 more more complex right you add logging                                 your metrics and soon like over fifty                                 percent of your coat it's like kind of                                 production any stuff has anyone seen                                 that that's right everyone's seen that                                 right so traits to the rescue right here                                 at the bottom we see an actor class you                                 have some functionality in your receipt                                 block if you're not familiar with actors                                 the receipt block is where you handle                                 messages so let's say that I have                                 something called wrap receive that's                                 where my real work is and I want to do                                 something before and after but I want to                                 do it in a way that this doesn't clutter                                 my coat right so                                 these are what stackable traits let you                                 do as an example let's okay sorry so                                 let's say that have a base trade what                                 the space treat does is I call it actor                                 stack there's really this two components                                 to it one is called wrap receive which                                 is that I've moved receive block of                                 actor classes to a second I just renamed                                 it essentially to something called wrap                                 receive and what happens is that the                                 traits that modify the behavior of the                                 receipt block it's going to sit in the                                 regular receive and usually how this                                 works in a second we see blocks are what                                 are called partial functions in scholar                                 that means that they can handle some                                 messages that not do others so when you                                 say is defined that that tells you if                                 the rap receive block is going to handle                                 message otherwise it goes to a built-in                                 function in acha actor is called                                 unhandled which processes messages that                                 are not yeah that aren't process now                                 let's say that I have two traits to                                 instrument to instrument my actors just                                 call instrument one instrument to what I                                 do is they override the receive method                                 and you see something called super don't                                 receive and what that does is that that                                 will pass that will call the next train                                 on a on a stack back up to the original                                 actor stack which caused the rap receive                                 of the base actor and so you notice                                 instrument one that's do something                                 before instrument to this antes now if                                 you mix both them together let's say                                 that I do extend actor with instrument                                 one with extra meant to then we notice                                 that the body of my function is very                                 simple and the order that you mix it                                 then determines the order that the                                 behavior modifiers get caught so if I go                                 back a little bit you notice that                                 instrument too it's the last one in the                                 stack that one gets caught first then it                                 costs instrument one which is the next                                 super class then it calls actor stack                                 which is the parents and then that calls                                 dummy actor so so that's that's your                                 happens and we'll show some examples of                                 how we use this so production izing acha                                 the finally we get to the meat of the                                 talk we have a standard stack of                                 technologies we use spray at that time                                 when we start using a spray was it                                 seemed like the best choice for actually                                 integrating with Daka since then other                                 frameworks web frameworks like skeletor                                 have have a cointegration you guys might                                 have just seen the news that types                                 they've acquired spray so it looks like                                 spray will be here this day as part of                                 acha acha HTTP we use lock back which                                 I've explained a second why we used lock                                 back Yammer metrics spray JSON and we                                 packages all in a single jar so that                                 it's very easy for nyaka apps to to be                                 deployed with like this entire sack i'll                                 be talking about visibility a lot it's                                 been said that the only thing that                                 really matters and distributed systems                                 is visibility when it comes to debugging                                 so the first level visibility which                                 everyone has to have is logging so we                                 like to use log back with a custom log                                 and trade there is a built-in actor                                 logging trade in a car but we don't use                                 it the reason is because actor logging                                 is does a long level based on a static                                 configuration but we like the ability to                                 have dynamically adjustable logging                                 levels and lock back gives you that you                                 can actually go into jmx and adjust the                                 logging level which is super useful in                                 production without having to restart                                 your services so instead what we do is                                 that we have defined our own trade that                                 lets you use lockback darkly one thing                                 that lecture logon gives you is that it                                 will print out the path of your actor in                                 in your logging which is pretty useful                                 so we have a way to put that back                                 basically in slf                                                      called MDC and all you need to do is do                                 a put on to some variable like a crow                                 path and                                 oh this would be easier if Isis we just                                 look at a trade so it's a slightly                                 simplified version of our trait again                                 this used actor stackable trade pattern                                 you'll notice that every actor class it                                 mixes in gets a default lager vowel and                                 at the beginning we immediately log that                                 we're starting this actor this is very                                 useful for debugging but the meat of it                                 is that when we receive a message the                                 first thing we do is we do MDC to put                                 which allows me to have my actor path in                                 and logging now if you might be                                 wondering why we need to do this for                                 every invocation the reason is because                                 every time an actor receives a message                                 and does processing it could be on a                                 different thread so the MDC mechanism is                                 as tied to particular threads so that's                                 the reason why every time you get                                 received you need to reset the MDC the                                 next thing after you do logging logging                                 is good for looking at exceptions but                                 when you need to look at performance                                 it's longing is really not good right so                                 what do you really need our application                                 metrics so we have a trait that at two                                 metrics for every actor that basically                                 looks at how frequently are messages                                 coming in to an actor and the time spent                                 in the receipt block and what we do is                                 that we expose these metrics through a                                 common route metric see for all of our                                 apps then we pull it and send it to a                                 collection service and the way that the                                 trait works is a pretty simple again                                 this is a stackable trait we define a                                 neo timer for the actor and if you're                                 not familiar with the metrics library                                 what a meter does it allows you to                                 measure the duration of a block of code                                 as well as it gives you frequency so all                                 we do is we wrapped receive in a tri                                 finally and we start the timer and then                                 when it exits we stop it this gives us                                 think wraps arm this is a dated a graph                                 of a stacked graph of diff of the                                 different actor pipelines sorry                                 different stages in the actor pipeline                                 and you can see the pink is one of the                                 earlier stages and a pink one sorry the                                 late my pink is the earlier stage and                                 then that one on top heavier pink is the                                 later stage and you can see over time                                 that the time that is spent in each                                 actor in each actor class of varies and                                 you can pinpoint that something might be                                 happening with this with this light pink                                 actor and in fact if we correlate to                                 other metrics that is true if we                                 correlate to the latency that's                                 happening through the system we can see                                 that that point in time when there was a                                 spike also happens to be when things are                                 getting delayed and so yeah it's been a                                 pretty useful debugging tool to measure                                 it okay flow control so why default                                 actor mailboxes are unbounded that means                                 it can easily write messages to an actor                                 mailbox and run our memory if if your                                 act if the actually is tending to is                                 very slow you end up piling more and                                 more messages so any serious action                                 system needs to have some flow control                                 mechanism there's two strategies the                                 easiest one to implement is called the                                 bounded mailbox which is exactly what it                                 sounds like when a mailbox is full then                                 what happens is that there is a                                 configurable delay called the mailbox                                 push time out time and that's how long                                 acha will wait to see if the queue frees                                 up the behavior after that timeout                                 expires has changed acha used to allow                                 you to throw an exception or the block                                 indefinitely well or you can set push on                                 with time to to infinity and if we do                                 that then you can get kind of a basic                                 flow control for local acha actors the                                 new behavior starting I don't                                 I think it's acha two dot one is that                                 when your mailbox is full the messages                                 go to a mailbox called dead letters so                                 there's a mailbox in every acha system                                 called that letters where messages that                                 don't get delivered go your mail your                                 messages that go to actors that have                                 died already also go to that letters the                                 problem with this is that it doesn't                                 work for distributed systems so it's                                 better to implement a real flow control                                 mechanism that one way is for example                                 that you can have the last actor in your                                 pipeline pull up stream some work or you                                 can use a system like pushed with axe                                 where I keep pushing messages but I'm                                 going to wait to get some axe back and                                 if I don't get a certain number of acts                                 and I'm going to slow down so there's a                                 lot of I won't go into those but there's                                 a lot of good blog posts out if you look                                 at the Aqua team blog there's several                                 blog post about how to do flow control                                 those are those are really good although                                 it takes a lot more work to get those                                 set up here's a great graph like to show                                 that a good a good working flow control                                 system means that the rate of all your                                 actors are going to even out so with                                 this graph that you see is a great                                 example of that happening that at some                                 point I'm going to turn on the spigot of                                 my actor pipeline and you can see that                                 there's one trace which spikes up right                                 away and start to drop this is reading                                 messages from Kafka and which makes                                 sense it's going to start right away and                                 as the processing happens in the later                                 stages which are the other lines that                                 will start to slow down the kafka actor                                 because you will start to get pushback                                 and eventually they will all agree all                                 right so that's what you want to see                                 when we flow control works properly how                                 many people use visual vm super useful                                 tool if you don't haven't used it i                                 highly encourage you to download it                                 because it's free awesome way to get                                 live production information from your GV                                 m unfortunately visual vm is is really                                 target at a traditional java apps with                                 red                                 but so one useful veal and visual vm is                                 the CPU sampling which gives you a kind                                 of like a cheap very rough way of                                 estimating where time is being spent I                                 find it super useful in when debugging                                 the performance of maracas apps if                                 you're using something like a bounded                                 mailbox you might see something like                                 this where the top item becomes this NQ                                 method and bounded message queue what                                 that means is that you're after spending                                 a lot of time waiting for messages to be                                 pushed which will tell you that the                                 problem is with the last actor in your                                 chain in our case it would be writing of                                 Cassandra so when we see this we know                                 that the problem is that we're spending                                 too much time writing cassandra for                                 whatever reason and so looking at this                                 gives you like a pretty good quick read                                 that what is causing problems my dream                                 is to have a visual vm plugin that can                                 visualize actor utilization across                                 threats so there's any of you out there                                 that is visual vm the developer or                                 anything like that let me know this                                 would be really cool to have ok so your                                 flow control you have metrics Jeff                                 logging that you know that's not a bad                                 start so here's the thing in a                                 traditional java app or scala app stack                                 traces are pretty useful because every                                 line tells you where its last color and                                 you can kind of trace through it and                                 trace through your code and figure out                                 where you know what's been happening if                                 you ever looked at stock traders from                                 acha this is not very useful you see a                                 lot of this kind of thing our code of                                 dispatch or jsr                                                        joining for current pool and the reason                                 is because every time that acha                                 dispatches then it has to use this                                 framework so you don't remember the                                 stack trace the stack no logo remembers                                 where you've been so how you saw would                                 it be to have like an actor and akka                                 actor message trace where you can see                                 where I've been like the last actor to                                 the current actor and look at the                                 message type right I think that would be                                 that would for acha apps this would be a                                 super useful debugging                                 or maybe you want something like this                                 like a Sankey diagram with message flows                                 you can see on the left side little                                 actors which ones they flow to how many                                 messages roughly are sent to each one                                 sews hackathon in our last hackathon                                 project we actually implement it                                 something like this and here's a simple                                 stackable trait basically what this does                                 is that on every receive we will try to                                 extract out message ID from from the                                 message that a sense then we send an                                 edge to a collector this has the last                                 December which is the last actor node                                 the current node and the message ID then                                 you can aggregate across notes and make                                 some pretty cool crafts finally like                                 just a few hoops just a few hints you                                 don't want to put things that can fail                                 into the actor constructor because why                                 default occur with the stop you want to                                 like have an initializer so if I put                                 this all together I now have several                                 traits that it can mix in I can mix in                                 my login metrics the message tracing and                                 I can keep my the body of my actor                                 really neat and clean and get a lot of                                 super useful instrumentation some next                                 steps we can possibly open source this                                 then we know if you're interested or                                 even interested in contributing to this                                 effort thank you very much we are hiring                                 so come talk to me                                 typesafe console it's yes types of                                 console is useful for debugging but it                                 costs a lot of money if we want to use                                 in production it also has a performance                                 impact so yeah that's interesting                                 thought I'm not really familiar with                                 spring so I am afraid I can't really                                 comment on that I don't know what spring                                 has is like has anything specific to                                 occur I would say that                                 looks like this                                 um I mean yeah yeah I think you're                                 probably right yeah yeah it would be a                                 good lunch topic yes yes yeah please                                 yeah that's probably sure me oh please                                 bring background personally hmm great                                 results from it but it doesn't doesn't                                 sell well on this side of the world and                                 also secondly the Jacka team is credibly                                 protective of their internal yes it's a                                 secret is that they didn't want anybody                                 at runtime messing around with with the                                 implication of vodka so it's it's                                 easiest to understand why why they have                                 that perspective because it is that it                                 is the colonel and you don't want too                                 many other people's code and it's                                 flooding in there and interfering                                 potentially with yeah I think for us is                                 this that I don't think any of us have a                                 spring background so it's just that we                                 haven't really looked at it and we like                                 light frameworks so sort of questions                                 I I think we like the fact that it's                                 declarative because we can control which                                 actors have these like some actors don't                                 don't eat that so we don't we won't mix                                 it in I said you know so I don't know if                                 that's just us but there's also you can                                 also inject the traits at at when you                                 declare when you instantiate an actor                                 instead of in the class header we                                 actually like it in the class header                                 because when you do it at the time                                 Qandil it's easy to do it differently at                                 different sites and get it wrong so but                                 this is my personal opinion yeah i think                                 that from Oliver oh sorry okay yeah so                                 the question was what's the future of                                 storm at a gala like a lot of people are                                 interested in storm i would say that we                                 are not really a storm shop anymore like                                 our experience our painful experience                                 with it in production tells us that you                                 know we don't really want to deal with                                 systems that we have trouble trouble                                 shooting at                                                              we think about it we like simple we like                                 then we like transparent I would say the                                 biggest thing is that storm has built-in                                 automatic playback like of events I                                 think that for us we need to implement                                 systems like that but at a larger level                                 anyway for correctness so we haven't I                                 guess we haven't really missed that but                                 you know yeah                                 I i we just heard about that yeah that                                 does look pretty neat yeah it's so                                 there's a pod lington has a new                                 framework Zipkin that is designed to run                                 a real-time processing on top of Kafka                                 yes so get them more questions Oh event                                 sourced yes that yes that's what we have                                 looked at that we probably will                                 implement it eventually I'm actually not                                 quite sure but yes the event sourced for                                 those of you guys don't know event                                 source is a acha library that it's a                                 library on top of vodka that provides at                                 least once or at exactly once processing                                 it's pretty neat yeah that's definitely                                 an interesting project we want to keep                                 our eyes on ya ok cool yeah ok cool okay                                 cool yeah we should talk cool any other                                 questions ok thanks                                 yeah second okay cool cool good to see                                 okay awesome if you want to do something                                 Aoki light like intensely dynamic                                 modifications of behavior you can always                                 just just write one super trade you                                 could write one trade that does all the                                 rule lookups at runtime or whatever you                                 have to do it right but you always have                                 the ability to go to go deeper there                                 it's just a question of whether you're                                 gonna consider exquisite them okay yeah                                 i can see any of us in the community are                                 moving in the direction of making                                 everything as exclusive as possible yeah                                 it doesn't have to be syntactically                                 heavy it can still just just be a parent                                 and small yeah if there's no surprises                                 yeah wait we're not big fans of magic                                 but that's us us so                                 so I'll just repeat the question the                                 question is you know I said futures are                                 hard to understand so when do you use                                 futures or you always use actors                                 dependent on who you listen to I think                                 there's one guy on the type save that                                 has a book coming out that tells me we                                 should always use actors but I think                                 futures are really good fit when you                                 need request-response if you were to do                                 same thing using actors you need to                                 declare like anonymous actors or you                                 need to track the response somehow right                                 because you don't the good thing about                                 futures is that every time you've sent a                                 request you have a handle on the future                                 so that's it's built into a futures work                                 but if you need to track responses using                                 actors you need a map or you need to do                                 something yourself so it's a little bit                                 yeah futures are a great fit for                                 request-response we still use futures is                                 just try to be more judicious and we try                                 to avoid future stacked on futures kind                                 of like composing them too much and                                 things like that                                 Rob receive yes so the question was                                 about rap receive um it was something                                 that we found what's needed for because                                 the receive method is a partial function                                 and also to simplify the flow of the                                 traits that it's very clear that there's                                 one trait that cause rap receive and so                                 that flow is very clear there is a                                 magical way of doing it where you don't                                 have you don't need a rap receive you                                 can just have the base accra be received                                 but in testing i found out that doesn't                                 work with so you saw in some examples I                                 had where I can do this I can declare a                                 class that well maybe not this one but                                 there's some other ones where the class                                 will extend one trade what another trade                                 so you can't do that if you don't have a                                 rap receive this is what I found maybe                                 there's some way to do it but yeah this                                 yes that's a really good question yeah I                                 mean there's not much we can get around                                 the fact that actor is basically our                                 dynamic right didn't take any objects                                 one thing is that well one thing we                                 should do but we don't to is that you                                 should always have something actually I                                 guess you should have a base for like                                 you should always like know when these                                 pass a message that doesn't that isn't                                 identified like I think there's a base                                 exception that comes across when it                                 doesn't when you get the message but                                 like you can overwrite unhandled and                                 make it very obvious that you got a                                 message that isn't handled but the other                                 thing is that I know a COS adding in                                 some new stuff they're adding in type                                 channels so hopefully that will make                                 things easier I could also has a type                                 actor interface where you define methods                                 and a method somehow map over to the                                 existing thing and I haven't looked at                                 those but                                 that's something that would add a lot of                                 type safety you know maybe it's a good                                 idea good question so speaking of                                 messages do we use the standard classes                                 or like protobuf we haven't I guess we                                 haven't done anything so high                                 performance that we've looked into that                                 we needed like protobuf we use case                                 classes just because they pattern match                                 very well and they're great fit for four                                 actors I think if we needed performance                                 we would switch from acha has pluggable                                 sterilizers we would switch to using                                 creo instead of java serialization and                                 that way we can still have the niceness                                 of case classes without having to deal                                 with protobuf and compiling you know                                 files okay cool cool cool okay thank you                                 very much yep                                 you
YouTube URL: https://www.youtube.com/watch?v=c1heorOM2LE


