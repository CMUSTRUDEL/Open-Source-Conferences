Title: Metals rich code editing for Scala in VS Code Vim Emacs - Ólafur Páll Geirsson
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/metals-rich-code-editing-for-scala-in-vs-code-vim-emacs-and-beyond
Captions: 
	00:00:03,560 --> 00:00:12,269
hello everybody so my name is Olaf and

00:00:10,710 --> 00:00:14,880
I'm really excited to be here and

00:00:12,269 --> 00:00:17,010
present medals a project that provides

00:00:14,880 --> 00:00:18,420
rich code editing for Scala and text

00:00:17,010 --> 00:00:23,250
editors such as vias code

00:00:18,420 --> 00:00:25,019
vim Emacs and beyond so briefly about

00:00:23,250 --> 00:00:28,349
myself I'm an engineer at the Scala

00:00:25,019 --> 00:00:30,900
Center our offices on campus here which

00:00:28,349 --> 00:00:33,540
makes this moment even more special to

00:00:30,900 --> 00:00:35,370
welcome everybody here I'm the author of

00:00:33,540 --> 00:00:37,410
a code formatter called call FMT

00:00:35,370 --> 00:00:39,540
refactoring tool called Scala fix and

00:00:37,410 --> 00:00:42,149
medals the project that I'm presenting

00:00:39,540 --> 00:00:47,660
today so you may have seen me as seen me

00:00:42,149 --> 00:00:50,520
as Oliver PG on github and Twitter so

00:00:47,660 --> 00:00:54,629
before I get started does anyone know

00:00:50,520 --> 00:00:56,309
here what the Scala Center does quite

00:00:54,629 --> 00:00:58,530
many hands which is great it's better

00:00:56,309 --> 00:01:00,300
than a few years ago so we're a

00:00:58,530 --> 00:01:03,539
not-for-profit we're established charity

00:01:00,300 --> 00:01:06,830
pfl on campus and our two primary

00:01:03,539 --> 00:01:09,119
focuses are on open source and education

00:01:06,830 --> 00:01:12,930
so what I've been doing a lot at the

00:01:09,119 --> 00:01:15,180
centre is working on tooling and also

00:01:12,930 --> 00:01:20,520
you may see on your badge we're

00:01:15,180 --> 00:01:22,110
organizing Scala days so and also the

00:01:20,520 --> 00:01:23,970
work that I'm presenting here is really

00:01:22,110 --> 00:01:25,920
not just me it's been a big

00:01:23,970 --> 00:01:28,290
collaborative effort effort with a lot

00:01:25,920 --> 00:01:30,590
of contributors so I want to highlight

00:01:28,290 --> 00:01:32,369
jorge who's been working on bloop

00:01:30,590 --> 00:01:35,600
gabriella who's sitting here came from

00:01:32,369 --> 00:01:37,890
Milano and Merrigan Thomas who are

00:01:35,600 --> 00:01:41,430
adversities lab and we've been working

00:01:37,890 --> 00:01:42,720
together full time since April so and

00:01:41,430 --> 00:01:45,570
also when I mention a few other names

00:01:42,720 --> 00:01:51,930
you jimbo Marco Alexei Johan with some

00:01:45,570 --> 00:01:53,579
Shane so before I want to go and talk

00:01:51,930 --> 00:01:55,290
about text editing I want to talk about

00:01:53,579 --> 00:01:57,420
another topic that we talked a lot about

00:01:55,290 --> 00:01:59,610
at the Scala days at the Scala Center

00:01:57,420 --> 00:02:02,189
which is how do we grow the Scala

00:01:59,610 --> 00:02:04,740
community and I think everyone here her

00:02:02,189 --> 00:02:06,450
flown all over the world to come and be

00:02:04,740 --> 00:02:09,149
present in scala days should also be

00:02:06,450 --> 00:02:11,129
thinking about this question is you know

00:02:09,149 --> 00:02:12,240
we have asked our community and now in

00:02:11,129 --> 00:02:15,510
00:02:12,240 --> 00:02:18,750
and let's say we want to double it in

00:02:15,510 --> 00:02:22,370
2021 very ambitious goal how do we get

00:02:18,750 --> 00:02:25,140
there and it's a really difficult

00:02:22,370 --> 00:02:26,670
problem and and and there's no silver

00:02:25,140 --> 00:02:29,310
bullet you're gonna have to have a lot

00:02:26,670 --> 00:02:31,350
of different solutions so my thesis for

00:02:29,310 --> 00:02:34,770
the talk today is that improved editor

00:02:31,350 --> 00:02:39,210
tooling is one component and I'll tell

00:02:34,770 --> 00:02:40,710
you why I think the first question when

00:02:39,210 --> 00:02:43,080
you onboard someone on your team they've

00:02:40,710 --> 00:02:45,420
never written scala the first thing you

00:02:43,080 --> 00:02:49,410
think about is you know what editor do

00:02:45,420 --> 00:02:50,280
you use what ide do i install if you

00:02:49,410 --> 00:02:52,800
google online

00:02:50,280 --> 00:02:55,500
what ID to use with Scala you'll find

00:02:52,800 --> 00:02:58,020
forums on reddit Stack Overflow core

00:02:55,500 --> 00:03:01,710
people asking the same question and it's

00:02:58,020 --> 00:03:04,440
been going on since 2005 and and usually

00:03:01,710 --> 00:03:06,120
there Heatley you know commented people

00:03:04,440 --> 00:03:09,810
like to have an opinion

00:03:06,120 --> 00:03:11,640
III like this one here who says I'm a

00:03:09,810 --> 00:03:13,740
newbie with Scala I'm developing a play

00:03:11,640 --> 00:03:16,860
framework app I've tried to call ID

00:03:13,740 --> 00:03:19,500
based on Eclipse and IntelliJ in my

00:03:16,860 --> 00:03:22,290
opinion the first one looks not mature

00:03:19,500 --> 00:03:24,360
yet and IntelliJ seems better but I find

00:03:22,290 --> 00:03:25,680
it a bit slow I'm looking for the

00:03:24,360 --> 00:03:29,250
sublime option but it's not so

00:03:25,680 --> 00:03:30,780
documented so I really like this comment

00:03:29,250 --> 00:03:33,710
because it highlights some of the points

00:03:30,780 --> 00:03:36,930
I wanted to make it's someone starting

00:03:33,710 --> 00:03:39,420
with Scala but has like a particular

00:03:36,930 --> 00:03:41,940
goal I want to do a plain app and and

00:03:39,420 --> 00:03:43,560
this person has tried to use different

00:03:41,940 --> 00:03:45,780
IDs but is really looking for the

00:03:43,560 --> 00:03:48,050
sublime option because I'm guessing

00:03:45,780 --> 00:03:51,030
that's what the person is familiar with

00:03:48,050 --> 00:03:53,910
but if you've been long enough in in the

00:03:51,030 --> 00:03:55,200
Scala community you'll know that the

00:03:53,910 --> 00:03:59,940
most uploaded answer is definitely

00:03:55,200 --> 00:04:04,050
IntelliJ without any explanation and

00:03:59,940 --> 00:04:06,860
that's also the yeah so the 2018 Scala

00:04:04,050 --> 00:04:09,270
developer survey kind of confirms that

00:04:06,860 --> 00:04:12,240
81% of the respondents said that they

00:04:09,270 --> 00:04:14,040
use IntelliJ and this may not be

00:04:12,240 --> 00:04:15,720
surprising for the people here in the

00:04:14,040 --> 00:04:20,160
audience can I do a small survey here

00:04:15,720 --> 00:04:23,870
who uses IntelliJ for Scala yeah that's

00:04:20,160 --> 00:04:29,280
about 80 it's not 19%

00:04:23,870 --> 00:04:29,849
so I want to take a moment here and look

00:04:29,280 --> 00:04:34,680
at that

00:04:29,849 --> 00:04:37,020
the 81% number because if you take the

00:04:34,680 --> 00:04:40,770
global programming community it's not

00:04:37,020 --> 00:04:42,030
the same so if you take the get a bhakta

00:04:40,770 --> 00:04:44,129
verse they claim that there are thirty 1

00:04:42,030 --> 00:04:46,470
million programmers globally in the

00:04:44,129 --> 00:04:49,550
world and that's a fair estimation I

00:04:46,470 --> 00:04:52,919
guess get abusers number of developers

00:04:49,550 --> 00:04:54,780
and the JetBrains developer survey from

00:04:52,919 --> 00:04:57,180
2018 says that they have 6 million

00:04:54,780 --> 00:04:59,250
people who who used jetbrains products

00:04:57,180 --> 00:05:01,139
including IntelliJ and that's a really

00:04:59,250 --> 00:05:03,990
impressive number and and Japanese

00:05:01,139 --> 00:05:06,240
products are really fantastic but that

00:05:03,990 --> 00:05:08,849
still leaves 25 million programmers out

00:05:06,240 --> 00:05:14,699
there who've never even downloaded or

00:05:08,849 --> 00:05:17,120
installed IntelliJ and so if you the the

00:05:14,699 --> 00:05:20,490
2018 Stack Overflow developer survey

00:05:17,120 --> 00:05:24,090
you'll also see a similar pattern which

00:05:20,490 --> 00:05:26,550
is that IntelliJ goes has 25% of the

00:05:24,090 --> 00:05:28,949
most popular dip like 25% of the

00:05:26,550 --> 00:05:30,270
respondents say that IntelliJ is or you

00:05:28,949 --> 00:05:33,659
know favorite development environment

00:05:30,270 --> 00:05:37,830
and it's at the sixth place there are 5

00:05:33,659 --> 00:05:41,490
other editors including notepad that you

00:05:37,830 --> 00:05:43,409
know are more popular but also notable

00:05:41,490 --> 00:05:47,880
editor such as VAM sublime text and

00:05:43,409 --> 00:05:50,039
Visual Studio code so there is an editor

00:05:47,880 --> 00:05:51,300
gap here like the representation of how

00:05:50,039 --> 00:05:54,270
people use editors in the scala

00:05:51,300 --> 00:05:56,069
community does not reflect how the

00:05:54,270 --> 00:05:59,430
global programming community uses

00:05:56,069 --> 00:06:01,710
editors and I think this should be kind

00:05:59,430 --> 00:06:03,529
of a big concern going back to the

00:06:01,710 --> 00:06:07,409
question how do we grow the community

00:06:03,529 --> 00:06:09,330
and and it's partly because learning a

00:06:07,409 --> 00:06:12,870
new language is really hard you need to

00:06:09,330 --> 00:06:15,210
learn syntax and semantics but learning

00:06:12,870 --> 00:06:16,770
a new language and the new editor with

00:06:15,210 --> 00:06:20,759
all of the shortcuts and key bindings

00:06:16,770 --> 00:06:22,680
and everything is even harder and and

00:06:20,759 --> 00:06:24,629
this pretty much reflects how I started

00:06:22,680 --> 00:06:27,750
in Scala I started writing scholarly in

00:06:24,629 --> 00:06:30,360
2014 and I used it clips for quite a few

00:06:27,750 --> 00:06:31,919
months and and I chose that because I

00:06:30,360 --> 00:06:33,960
was familiar with the clips from Java

00:06:31,919 --> 00:06:35,969
and it clips worked great

00:06:33,960 --> 00:06:36,770
I learned Scala I was able to actually

00:06:35,969 --> 00:06:40,170
do a play

00:06:36,770 --> 00:06:42,420
like the person on reddit and then

00:06:40,170 --> 00:06:43,890
eventually I streets to IntelliJ because

00:06:42,420 --> 00:06:46,500
well it provided a more feature-rich

00:06:43,890 --> 00:06:49,290
experience but what's really interesting

00:06:46,500 --> 00:06:50,550
is I switched to IntelliJ I didn't have

00:06:49,290 --> 00:06:52,740
to learn Scala I was already familiar

00:06:50,550 --> 00:06:54,180
with it so that out-of-the-box

00:06:52,740 --> 00:06:56,640
experience of using something that's

00:06:54,180 --> 00:06:58,380
familiar so you can learn Scala faster I

00:06:56,640 --> 00:07:01,770
think is it's one of the key components

00:06:58,380 --> 00:07:05,190
if you want to grow the community sudden

00:07:01,770 --> 00:07:06,900
so a few years go on and in 2019 I've

00:07:05,190 --> 00:07:09,870
actually started using full-time novias

00:07:06,900 --> 00:07:12,630
code with metals and that's what I'm

00:07:09,870 --> 00:07:14,340
going to be presenting today so now we

00:07:12,630 --> 00:07:16,770
can go back and talk about completions

00:07:14,340 --> 00:07:24,590
and hers and all of the stuff that this

00:07:16,770 --> 00:07:27,240
talk is really about so a quick tour

00:07:24,590 --> 00:07:29,400
metals works with currently officially

00:07:27,240 --> 00:07:31,200
supports five editors which means that

00:07:29,400 --> 00:07:35,670
that's what we document on our website

00:07:31,200 --> 00:07:38,370
it works with these code them Emacs atom

00:07:35,670 --> 00:07:40,230
and sublime text so it works with any

00:07:38,370 --> 00:07:41,400
other language server compatible editor

00:07:40,230 --> 00:07:43,530
but these are the ones that we have

00:07:41,400 --> 00:07:45,570
tested validated even had maybe some

00:07:43,530 --> 00:07:48,960
customizations to really improve the

00:07:45,570 --> 00:07:51,150
user experience in these editors and if

00:07:48,960 --> 00:07:52,920
you're using since last week or actually

00:07:51,150 --> 00:07:54,390
since the official release last night

00:07:52,920 --> 00:07:56,880
from so much

00:07:54,390 --> 00:07:59,250
we are officially support all of these

00:07:56,880 --> 00:08:01,620
four built tools as well meaning that if

00:07:59,250 --> 00:08:03,990
you just open up metals in a workspace

00:08:01,620 --> 00:08:05,430
that has any of these built tools it'll

00:08:03,990 --> 00:08:06,840
do all of the installation automatically

00:08:05,430 --> 00:08:09,180
for you you don't even have to go online

00:08:06,840 --> 00:08:13,020
to the website it just click of a button

00:08:09,180 --> 00:08:15,630
import this build and it works so and

00:08:13,020 --> 00:08:18,600
then once you've installed it it has a

00:08:15,630 --> 00:08:20,460
ton of functionality so I'm not gonna go

00:08:18,600 --> 00:08:22,380
through all of this list here instead

00:08:20,460 --> 00:08:28,970
I'll just do a very brief demo just to

00:08:22,380 --> 00:08:35,070
give you a taste so what I have here is

00:08:28,970 --> 00:08:40,440
the metals and this code open up in the

00:08:35,070 --> 00:08:42,270
akka repository and some of the first

00:08:40,440 --> 00:08:43,950
things you'll see is there's a outline

00:08:42,270 --> 00:08:46,830
view here you can walk through and

00:08:43,950 --> 00:08:48,170
browse the classes you can fold some

00:08:46,830 --> 00:08:54,830
code

00:08:48,170 --> 00:08:56,390
and you have completions and then we

00:08:54,830 --> 00:09:02,750
have some other fancy features like

00:08:56,390 --> 00:09:03,830
exhaustive matches and so that's pretty

00:09:02,750 --> 00:09:08,300
cool

00:09:03,830 --> 00:09:10,490
and then let me show you we also show if

00:09:08,300 --> 00:09:14,120
you hover over you get a really nice

00:09:10,490 --> 00:09:15,890
information about the types and I think

00:09:14,120 --> 00:09:17,660
this one is really helpful we show two

00:09:15,890 --> 00:09:20,150
parts one is the expression type which

00:09:17,660 --> 00:09:21,290
is the type of that expression and and

00:09:20,150 --> 00:09:23,210
it's highlighted but it's a bit

00:09:21,290 --> 00:09:25,400
difficult to see now but we also show

00:09:23,210 --> 00:09:27,290
you the generic signature of the method

00:09:25,400 --> 00:09:28,970
that you're calling so I think both of

00:09:27,290 --> 00:09:31,580
both pieces of information are really

00:09:28,970 --> 00:09:33,440
helpful and and so if you if you hover

00:09:31,580 --> 00:09:37,460
over a method that has some talk strings

00:09:33,440 --> 00:09:39,220
will also give you nicely formatted duck

00:09:37,460 --> 00:09:41,540
strings I have water thank you

00:09:39,220 --> 00:09:44,140
and that works both for Java and for

00:09:41,540 --> 00:09:46,550
Scala and yeah you can go to definition

00:09:44,140 --> 00:09:48,470
you can find references and there I just

00:09:46,550 --> 00:09:50,300
clicked on and I found five hundred and

00:09:48,470 --> 00:09:53,690
thirty references to a new symbol and it

00:09:50,300 --> 00:09:58,130
was not at all cached we try to be very

00:09:53,690 --> 00:10:00,230
fast with friend references so I'm just

00:09:58,130 --> 00:10:01,490
briefly another kind of out-of-the-box

00:10:00,230 --> 00:10:04,040
experience how it works

00:10:01,490 --> 00:10:07,790
I've have another installation of es

00:10:04,040 --> 00:10:09,260
code here that is has no extensions at

00:10:07,790 --> 00:10:12,680
all installed I've opened up with just a

00:10:09,260 --> 00:10:14,500
Scala file in a mail build and what

00:10:12,680 --> 00:10:17,270
happens is that it pops up and says I

00:10:14,500 --> 00:10:20,000
can help you with Scala file extensions

00:10:17,270 --> 00:10:21,290
and there are quite a few we don't have

00:10:20,000 --> 00:10:24,280
someone in the home ones yet so we're

00:10:21,290 --> 00:10:28,840
not at the top yet but if you install it

00:10:24,280 --> 00:10:33,890
then everything should follow from there

00:10:28,840 --> 00:10:35,390
if you go open up the Scala file it

00:10:33,890 --> 00:10:39,020
takes a moment for the server to start

00:10:35,390 --> 00:10:40,550
oh yeah it already maybe imported the

00:10:39,020 --> 00:10:44,570
Builder so everything should just work

00:10:40,550 --> 00:10:45,800
down for food yeah all right but it

00:10:44,570 --> 00:10:48,980
would have prompted me to import the

00:10:45,800 --> 00:10:51,020
build which is a milk build so let me

00:10:48,980 --> 00:10:53,200
see here so let's see that yeah all

00:10:51,020 --> 00:10:55,460
right then

00:10:53,200 --> 00:10:57,820
that gave you a taste of how metals

00:10:55,460 --> 00:10:57,820
looks like

00:11:03,590 --> 00:11:09,450
so as you saw there's a lot of features

00:11:06,900 --> 00:11:11,220
over 15 20 different features and I'm

00:11:09,450 --> 00:11:14,070
not gonna go and enumerate every one of

00:11:11,220 --> 00:11:16,260
them and show you how they work instead

00:11:14,070 --> 00:11:20,070
I think it's more interesting to focus

00:11:16,260 --> 00:11:22,020
and go more in-depth on two topics so

00:11:20,070 --> 00:11:23,760
the first one that we struggle with and

00:11:22,020 --> 00:11:25,700
that was the first feature that you that

00:11:23,760 --> 00:11:28,680
we have to implement was Diagnostics and

00:11:25,700 --> 00:11:31,800
they are the red and the yellow warnings

00:11:28,680 --> 00:11:34,740
Wiggles that telling you that you have

00:11:31,800 --> 00:11:36,780
an error and the challenge here is to

00:11:34,740 --> 00:11:39,480
get them fast and have them relevant

00:11:36,780 --> 00:11:40,830
like they should be helping you and then

00:11:39,480 --> 00:11:45,060
the second case that he will be doing

00:11:40,830 --> 00:11:48,210
completions so also giving them with low

00:11:45,060 --> 00:11:51,300
latency but also support them in you

00:11:48,210 --> 00:11:54,810
know a large number of positions so

00:11:51,300 --> 00:11:58,070
let's start with the errors as you can

00:11:54,810 --> 00:12:01,500
see here we're kind of shuffling between

00:11:58,070 --> 00:12:04,800
filed a dozen parts and a file that has

00:12:01,500 --> 00:12:06,450
a type error the type error says number

00:12:04,800 --> 00:12:09,360
should be a five string but it's

00:12:06,450 --> 00:12:11,460
actually an int and when we insert the

00:12:09,360 --> 00:12:16,410
the string interpreter we're missing a

00:12:11,460 --> 00:12:19,680
closing curly brace and essentially what

00:12:16,410 --> 00:12:22,080
this case study is about is to see to to

00:12:19,680 --> 00:12:24,030
how we tackle this problem of trying to

00:12:22,080 --> 00:12:30,470
provide these errors so that they're

00:12:24,030 --> 00:12:32,820
helpful but but do it fast in a fast way

00:12:30,470 --> 00:12:36,210
so there are two approaches to actually

00:12:32,820 --> 00:12:38,040
do diagnostics and I would say one of

00:12:36,210 --> 00:12:40,380
them is you can just publish them from

00:12:38,040 --> 00:12:41,670
whatever you compile you run compiled in

00:12:40,380 --> 00:12:43,980
your bill tool and then you scrape the

00:12:41,670 --> 00:12:45,720
logs and you put it into the editor and

00:12:43,980 --> 00:12:48,900
that's what I would call publish errors

00:12:45,720 --> 00:12:50,610
from the build tool and an alternative

00:12:48,900 --> 00:12:54,120
approach is that you have a presentation

00:12:50,610 --> 00:12:56,310
compiler like a library API where you do

00:12:54,120 --> 00:12:59,460
that compilation yourself in the Edit in

00:12:56,310 --> 00:13:03,000
the IDE and you publish them directly

00:12:59,460 --> 00:13:04,980
yourself and the presentation compiler

00:13:03,000 --> 00:13:07,980
approach is pretty much the industry

00:13:04,980 --> 00:13:10,620
standard it's used by college a scholar

00:13:07,980 --> 00:13:14,670
de typescript Java language servers

00:13:10,620 --> 00:13:18,840
so metals uses the one from the bill

00:13:14,670 --> 00:13:20,670
tool so I'm gonna explain why we do that

00:13:18,840 --> 00:13:25,320
and why I think it's actually has really

00:13:20,670 --> 00:13:27,240
nice properties so in a nutshell when

00:13:25,320 --> 00:13:28,350
you type compiled an SPT it's gonna run

00:13:27,240 --> 00:13:30,540
compiling hundred and twenty eight

00:13:28,350 --> 00:13:32,670
source files and then give you an error

00:13:30,540 --> 00:13:34,680
because you have some problem and what

00:13:32,670 --> 00:13:38,460
metals does it just take that error I

00:13:34,680 --> 00:13:40,500
shove it into your editor and this has

00:13:38,460 --> 00:13:42,240
some very nice properties it's

00:13:40,500 --> 00:13:45,060
essentially correct by construction

00:13:42,240 --> 00:13:47,400
whatever you have in your build that

00:13:45,060 --> 00:13:49,500
environment is perfectly reflected in

00:13:47,400 --> 00:13:51,330
your editor there's never the case where

00:13:49,500 --> 00:13:54,630
something like a dependency is off

00:13:51,330 --> 00:13:57,080
saying or anything because it's the same

00:13:54,630 --> 00:13:59,310
thing so if you're using you know

00:13:57,080 --> 00:14:01,440
ammonite scripts which which have a

00:13:59,310 --> 00:14:03,410
different build tool well we should get

00:14:01,440 --> 00:14:05,400
the errors directly from that source

00:14:03,410 --> 00:14:09,180
instead of trying to reproduce that

00:14:05,400 --> 00:14:10,770
environment and another one which i

00:14:09,180 --> 00:14:12,180
think is really exciting as well is that

00:14:10,770 --> 00:14:16,350
because we perform that batch

00:14:12,180 --> 00:14:18,770
compilation so frequently we can share

00:14:16,350 --> 00:14:21,720
it with your tests when you're running

00:14:18,770 --> 00:14:24,090
so you as you're editing you're

00:14:21,720 --> 00:14:26,700
performing those CPU cycles that are

00:14:24,090 --> 00:14:29,130
needed for you to run tests anyways so

00:14:26,700 --> 00:14:31,200
whenever you go from your editor into

00:14:29,130 --> 00:14:32,670
your terminal you don't spend any moment

00:14:31,200 --> 00:14:35,490
compiling because it's already compiled

00:14:32,670 --> 00:14:37,860
so I think these two key components make

00:14:35,490 --> 00:14:42,570
the publish Diagnostics from the build

00:14:37,860 --> 00:14:43,740
really appealing and you and the first

00:14:42,570 --> 00:14:45,630
thing that you would respect wise

00:14:43,740 --> 00:14:48,750
doesn't everyone do this it sounds

00:14:45,630 --> 00:14:50,070
fantastic well you get slow feedback as

00:14:48,750 --> 00:14:54,300
you're editing it may not be as

00:14:50,070 --> 00:14:56,400
interactive and another downside as well

00:14:54,300 --> 00:14:58,740
is that you need to save the file

00:14:56,400 --> 00:15:03,960
because the content that you're editing

00:14:58,740 --> 00:15:05,970
it would be visible to the build tool so

00:15:03,960 --> 00:15:08,280
let's tackle one of those two you know

00:15:05,970 --> 00:15:10,350
both of the the downsides slow feedback

00:15:08,280 --> 00:15:13,860
and requires file save and we'll start

00:15:10,350 --> 00:15:15,900
with a slow feedback so having looked at

00:15:13,860 --> 00:15:18,030
this a bit and we were looking at how to

00:15:15,900 --> 00:15:19,650
speed things up the first lesson that we

00:15:18,030 --> 00:15:22,440
learned was publishing errors is pretty

00:15:19,650 --> 00:15:23,420
fast you essentially run that pipeline

00:15:22,440 --> 00:15:25,340
and

00:15:23,420 --> 00:15:26,540
you the errors come streaming from the

00:15:25,340 --> 00:15:29,450
bill tool and we can just put them

00:15:26,540 --> 00:15:33,470
straight into the editor or it's as fast

00:15:29,450 --> 00:15:34,970
as the bill can be but another one of

00:15:33,470 --> 00:15:36,920
the challenges that removing them

00:15:34,970 --> 00:15:41,540
knowing that that that error error is

00:15:36,920 --> 00:15:42,920
gone can be a bit slow so we're gonna

00:15:41,540 --> 00:15:45,170
look specifically into that how do we

00:15:42,920 --> 00:15:47,930
clear it so imagine that we have three

00:15:45,170 --> 00:15:53,450
source files a B and C and an A has an

00:15:47,930 --> 00:15:55,580
error before you run the batch compiler

00:15:53,450 --> 00:15:57,410
and and it runs in phases so it'll run

00:15:55,580 --> 00:15:58,820
the parser phase and all three files and

00:15:57,410 --> 00:16:01,400
then it runs the typeface which is

00:15:58,820 --> 00:16:03,590
usually the expensive one hundred runs

00:16:01,400 --> 00:16:06,560
twenty more phases and then eventually

00:16:03,590 --> 00:16:08,270
it will reach the JVM and let's say

00:16:06,560 --> 00:16:10,010
everything succeeds perfectly we know

00:16:08,270 --> 00:16:14,420
hey there are no more problems in this

00:16:10,010 --> 00:16:15,950
file then we can clear it and and that's

00:16:14,420 --> 00:16:17,960
kind of the naive approach if you say

00:16:15,950 --> 00:16:19,700
okay let's clear the errors you have to

00:16:17,960 --> 00:16:21,410
wade through these all of these phases

00:16:19,700 --> 00:16:26,210
to finish for all of the files and

00:16:21,410 --> 00:16:30,260
that's a bit difficult so what you could

00:16:26,210 --> 00:16:31,670
do instead is to start group the errors

00:16:30,260 --> 00:16:34,400
by the phases that they were published

00:16:31,670 --> 00:16:37,910
in and then just publish it after the

00:16:34,400 --> 00:16:45,200
parser face is finished which gives you

00:16:37,910 --> 00:16:46,730
a bit faster feedback but you it gives

00:16:45,200 --> 00:16:48,530
you faster feedback but again you're

00:16:46,730 --> 00:16:50,180
still waiting for the type of phase to

00:16:48,530 --> 00:16:52,520
finish for all of the source ones before

00:16:50,180 --> 00:16:53,990
you can clear so essentially instead

00:16:52,520 --> 00:16:56,300
what you can do is you can group the

00:16:53,990 --> 00:16:58,940
earth by whatever face and unit they

00:16:56,300 --> 00:17:02,390
finish they appear from and then you

00:16:58,940 --> 00:17:04,520
clear once those are finished and this

00:17:02,390 --> 00:17:07,190
approach is implemented in bloop so this

00:17:04,520 --> 00:17:08,510
is not implemented in metals but it's

00:17:07,190 --> 00:17:10,910
one of the key components that really

00:17:08,510 --> 00:17:13,910
sped up that you fixed an error and it

00:17:10,910 --> 00:17:14,990
gets removed and this was a huge

00:17:13,910 --> 00:17:21,560
improvement I think in the user

00:17:14,990 --> 00:17:23,630
experience it was really great so metals

00:17:21,560 --> 00:17:26,150
communicates with loop through the build

00:17:23,630 --> 00:17:30,830
server protocol IntelliJ also has a

00:17:26,150 --> 00:17:33,930
client implementation and you can plug

00:17:30,830 --> 00:17:35,400
in any other build tool that you want

00:17:33,930 --> 00:17:36,840
which i think is really great because

00:17:35,400 --> 00:17:38,700
it's accessible so if people are using

00:17:36,840 --> 00:17:40,890
basil or pants you could plug in another

00:17:38,700 --> 00:17:42,870
bill tool but also keep in mind that

00:17:40,890 --> 00:17:45,660
some of that custom work in terms of

00:17:42,870 --> 00:17:46,980
providing faster feedback will need to

00:17:45,660 --> 00:17:49,650
be implemented in those bill tools as

00:17:46,980 --> 00:17:54,600
well that maybe gives you a feel of how

00:17:49,650 --> 00:17:57,600
metals works and one thing that we did -

00:17:54,600 --> 00:18:00,480
- was like a very cheap win in terms of

00:17:57,600 --> 00:18:03,570
giving you faster feedback was we've

00:18:00,480 --> 00:18:05,670
only published that we can use like the

00:18:03,570 --> 00:18:08,220
presentation compiler approach for

00:18:05,670 --> 00:18:09,810
syntax errors so you can run a parser

00:18:08,220 --> 00:18:10,980
you don't need to know the class path

00:18:09,810 --> 00:18:13,560
you don't need to know any of the

00:18:10,980 --> 00:18:15,300
dependencies or the bill pipeline and if

00:18:13,560 --> 00:18:17,040
there's a missing you know closing

00:18:15,300 --> 00:18:18,990
parenthesis or an unclothed string

00:18:17,040 --> 00:18:22,080
literal we can just publish those right

00:18:18,990 --> 00:18:23,730
away and as you can see there is a typer

00:18:22,080 --> 00:18:26,400
below which was published from the build

00:18:23,730 --> 00:18:28,680
tool the the trick that metal does metal

00:18:26,400 --> 00:18:30,270
to us is that is able to work really

00:18:28,680 --> 00:18:31,980
well with an old snapshot of a file that

00:18:30,270 --> 00:18:33,240
has a type fair and then we get new

00:18:31,980 --> 00:18:37,430
syntax errors and then we have to

00:18:33,240 --> 00:18:40,020
compute how they align into the new file

00:18:37,430 --> 00:18:41,670
and once we got there working you're

00:18:40,020 --> 00:18:44,070
able to get pretty snappy feedback as

00:18:41,670 --> 00:18:47,970
you're typing while keeping very stable

00:18:44,070 --> 00:18:50,280
type errors so I think this also helps a

00:18:47,970 --> 00:18:51,810
lot with this little feedback so I mean

00:18:50,280 --> 00:18:53,520
I'm not gonna claim it's a solved

00:18:51,810 --> 00:18:55,890
problem it's probably still slower than

00:18:53,520 --> 00:18:57,420
what you'd use to but for me personally

00:18:55,890 --> 00:18:59,250
in the project I'm working on which are

00:18:57,420 --> 00:19:03,570
small to medium sized it's pretty good

00:18:59,250 --> 00:19:05,250
and it has those really nice attributes

00:19:03,570 --> 00:19:07,560
of correct errors by construction and

00:19:05,250 --> 00:19:08,730
shared compilation with random tests so

00:19:07,560 --> 00:19:12,990
let's look at the last piece which is

00:19:08,730 --> 00:19:16,080
requires file save so if you just typed

00:19:12,990 --> 00:19:18,570
in this thing into your buffer which is

00:19:16,080 --> 00:19:20,700
an invalid program it has a specs of

00:19:18,570 --> 00:19:22,110
string but it gets an int it should be

00:19:20,700 --> 00:19:24,900
an error but there is no error in the

00:19:22,110 --> 00:19:27,060
editor because you have to press save

00:19:24,900 --> 00:19:29,250
and then you get an error so if you're

00:19:27,060 --> 00:19:33,690
coming from an editor like eclipse or

00:19:29,250 --> 00:19:36,660
IntelliJ this may be you know a bit

00:19:33,690 --> 00:19:39,540
counterintuitive and and what you can do

00:19:36,660 --> 00:19:40,440
is let's say you fix that error and the

00:19:39,540 --> 00:19:42,300
error is still there

00:19:40,440 --> 00:19:45,090
well it's there because you haven't

00:19:42,300 --> 00:19:46,860
saved yet so I've seen at least people

00:19:45,090 --> 00:19:47,850
like that out-of-the-box experience

00:19:46,860 --> 00:19:50,370
opening

00:19:47,850 --> 00:19:54,030
and like oh it's not what I expected it

00:19:50,370 --> 00:19:58,320
to be having worked with it now myself

00:19:54,030 --> 00:20:00,960
for a few months I'm no longer sure if

00:19:58,320 --> 00:20:03,870
it's really a feature or a bug because

00:20:00,960 --> 00:20:05,970
when you press save it triggers that

00:20:03,870 --> 00:20:09,870
type checking which is expensive

00:20:05,970 --> 00:20:12,030
it travels your CPU and having control

00:20:09,870 --> 00:20:16,799
over exactly when that happens because

00:20:12,030 --> 00:20:18,809
you're editing kind of you're obviously

00:20:16,799 --> 00:20:20,280
editing an invalid program that

00:20:18,809 --> 00:20:22,350
otherwise you wouldn't be adding in in

00:20:20,280 --> 00:20:24,510
the program so most of the time it's

00:20:22,350 --> 00:20:27,900
broken anyways and most of the time you

00:20:24,510 --> 00:20:30,360
know what's broken so I find the

00:20:27,900 --> 00:20:32,580
workflow where you can just type without

00:20:30,360 --> 00:20:34,590
being distracted by moving errors by

00:20:32,580 --> 00:20:37,070
you're finishing something and saying

00:20:34,590 --> 00:20:39,690
hey this is wrong and like identifier

00:20:37,070 --> 00:20:42,510
it's really nice I think in metals that

00:20:39,690 --> 00:20:44,490
you can just type it at your pace maybe

00:20:42,510 --> 00:20:47,250
you took a sip of coffee and and nothing

00:20:44,490 --> 00:20:48,419
is going crazy now and then when you

00:20:47,250 --> 00:20:51,450
press save when you want to get there

00:20:48,419 --> 00:20:54,030
and so I just recommend you give it a

00:20:51,450 --> 00:20:55,650
try but I just took the liberty to flip

00:20:54,030 --> 00:21:04,590
the downside into an upside and say it's

00:20:55,650 --> 00:21:06,270
a feature so that's that's the story

00:21:04,590 --> 00:21:07,500
around diagnostics and and there's more

00:21:06,270 --> 00:21:09,120
to it but I think these were the ones

00:21:07,500 --> 00:21:12,780
that were kind of interesting and worth

00:21:09,120 --> 00:21:14,549
sharing and the second one is a feature

00:21:12,780 --> 00:21:17,820
that I think everyone cared deeply about

00:21:14,549 --> 00:21:20,640
completions so I'd been working on

00:21:17,820 --> 00:21:22,049
medals I think for seven months and I

00:21:20,640 --> 00:21:23,990
wasn't using it for my day-to-day

00:21:22,049 --> 00:21:27,120
development I was still using IntelliJ

00:21:23,990 --> 00:21:29,909
because we were missing completions but

00:21:27,120 --> 00:21:31,590
once we had completions along with

00:21:29,909 --> 00:21:33,030
parameter hits which are the ones that

00:21:31,590 --> 00:21:35,100
show you the parameters that you're

00:21:33,030 --> 00:21:36,900
filling in and also being able to show

00:21:35,100 --> 00:21:40,350
the types these all three came together

00:21:36,900 --> 00:21:42,360
in one release I was able to switch and

00:21:40,350 --> 00:21:45,690
I haven't really even had the urge to go

00:21:42,360 --> 00:21:47,250
back for a lot of reasons but mostly

00:21:45,690 --> 00:21:48,900
because they're just really good and

00:21:47,250 --> 00:21:55,289
relevant and they're really fast like

00:21:48,900 --> 00:21:57,240
fast so I'll explain how we do that so

00:21:55,289 --> 00:21:58,679
we use a presentation compiler approach

00:21:57,240 --> 00:22:01,020
so as I mentioned before we use the

00:21:58,679 --> 00:22:01,980
built tool for the errors but for the

00:22:01,020 --> 00:22:04,169
completions we

00:22:01,980 --> 00:22:05,970
run our own presentation compiler we

00:22:04,169 --> 00:22:08,340
need to know the class path and we need

00:22:05,970 --> 00:22:09,990
to reproduce that compilation but we

00:22:08,340 --> 00:22:11,760
have the liberty of not having to

00:22:09,990 --> 00:22:14,370
publish any errors we can do whatever we

00:22:11,760 --> 00:22:17,490
like because giving you completions like

00:22:14,370 --> 00:22:19,110
false like not giving you completions

00:22:17,490 --> 00:22:21,990
because there's an error is not the end

00:22:19,110 --> 00:22:22,770
of the world so so that approach works

00:22:21,990 --> 00:22:25,830
really great here

00:22:22,770 --> 00:22:27,480
I remember her what before I started

00:22:25,830 --> 00:22:29,490
working on metals I heard everyone talk

00:22:27,480 --> 00:22:31,169
about the presentation compiler I was

00:22:29,490 --> 00:22:33,809
like where do I add where do I depend on

00:22:31,169 --> 00:22:35,490
this library and I didn't I didn't even

00:22:33,809 --> 00:22:36,960
know what class was called or how do I

00:22:35,490 --> 00:22:39,570
use it and there were no documentation

00:22:36,960 --> 00:22:41,790
there was no website about it so if

00:22:39,570 --> 00:22:43,650
you're curious it's a class called Scala

00:22:41,790 --> 00:22:46,700
tool senousy interactive that global

00:22:43,650 --> 00:22:49,320
which extends the Scala batch compiler

00:22:46,700 --> 00:22:53,760
you can depend on it by depending on the

00:22:49,320 --> 00:22:56,010
Scala compiler artifacts and it's used

00:22:53,760 --> 00:22:59,820
by the repple I'm gonna drop all this

00:22:56,010 --> 00:23:03,720
Cal IDE Scala fiddle a lot of other

00:22:59,820 --> 00:23:05,309
tools and it implements essentially two

00:23:03,720 --> 00:23:07,290
kinds of completions one of them is the

00:23:05,309 --> 00:23:08,760
scope completions where you just pull

00:23:07,290 --> 00:23:11,190
out an identifier that's already

00:23:08,760 --> 00:23:12,840
imported in scope and member completions

00:23:11,190 --> 00:23:16,410
where you would do a dot and it will

00:23:12,840 --> 00:23:18,510
list out the members of that type and as

00:23:16,410 --> 00:23:20,490
I said before I've just been really

00:23:18,510 --> 00:23:22,230
pleasantly surprised that it's snappy

00:23:20,490 --> 00:23:23,400
and it provides just really reliable

00:23:22,230 --> 00:23:28,620
member completion since called

00:23:23,400 --> 00:23:31,950
completions but for that rich completion

00:23:28,620 --> 00:23:33,809
experience that I was used to IntelliJ

00:23:31,950 --> 00:23:37,440
scope completion and member completions

00:23:33,809 --> 00:23:39,150
are not enough I need what I was missing

00:23:37,440 --> 00:23:42,210
was quite a few other completions and

00:23:39,150 --> 00:23:44,370
that's what metal implements on top of

00:23:42,210 --> 00:23:45,990
the presentation compiler so I'm gonna

00:23:44,370 --> 00:23:48,630
go through quite a few of the pieces

00:23:45,990 --> 00:23:51,059
that we do to kind of make that

00:23:48,630 --> 00:23:53,220
experience richer and the first one

00:23:51,059 --> 00:23:55,200
highlights also that it's not that the

00:23:53,220 --> 00:23:57,299
presentation compiler should really even

00:23:55,200 --> 00:24:00,059
have these features because these

00:23:57,299 --> 00:24:02,250
features require an editor because you

00:24:00,059 --> 00:24:04,140
perform refactorings we can explicitly

00:24:02,250 --> 00:24:07,290
move the cursor there's all sorts of

00:24:04,140 --> 00:24:08,760
things that wouldn't really that would

00:24:07,290 --> 00:24:10,770
be really difficult to encode in the

00:24:08,760 --> 00:24:12,600
library api of the presentation compiler

00:24:10,770 --> 00:24:14,370
essentially it just gives you a list of

00:24:12,600 --> 00:24:15,070
symbols and it's up to us to figure out

00:24:14,370 --> 00:24:17,050
what to do

00:24:15,070 --> 00:24:21,760
the first one is when you press ENTER

00:24:17,050 --> 00:24:23,410
and you select an item you can say this

00:24:21,760 --> 00:24:25,690
is the refactoring you should perform on

00:24:23,410 --> 00:24:26,980
the document and one of the things that

00:24:25,690 --> 00:24:29,200
you can do is you can have snippets

00:24:26,980 --> 00:24:31,210
which is essentially you say it should

00:24:29,200 --> 00:24:32,950
insert opening parenthesis and move the

00:24:31,210 --> 00:24:34,960
cursor inside of the parenthesis and

00:24:32,950 --> 00:24:37,960
when you finish that you should trigger

00:24:34,960 --> 00:24:40,360
parameter hints that's what you see when

00:24:37,960 --> 00:24:42,370
you select iterator which is an alluring

00:24:40,360 --> 00:24:44,440
method it shouldn't have any parenthesis

00:24:42,370 --> 00:24:47,920
and you select filter it moves the

00:24:44,440 --> 00:24:49,900
cursor into the filter parentheses and

00:24:47,920 --> 00:24:51,220
when you select next it knows that there

00:24:49,900 --> 00:24:53,100
are no arguments so it moves the cursor

00:24:51,220 --> 00:24:57,400
at the end of it

00:24:53,100 --> 00:24:59,800
so it's pretty basic but it's still kind

00:24:57,400 --> 00:25:03,340
of an important piece of that day-to-day

00:24:59,800 --> 00:25:04,750
experience of writing code so one of the

00:25:03,340 --> 00:25:07,660
fanciest features that we have is

00:25:04,750 --> 00:25:08,500
exhaustive match completions if you do a

00:25:07,660 --> 00:25:11,320
match

00:25:08,500 --> 00:25:13,420
completion it'll provide you to say just

00:25:11,320 --> 00:25:19,480
a regular match or an exhaustive match

00:25:13,420 --> 00:25:22,000
and what we do is this works for both

00:25:19,480 --> 00:25:23,410
field types as well as not sealed types

00:25:22,000 --> 00:25:27,250
which is different if you're coming from

00:25:23,410 --> 00:25:29,380
IntelliJ so if you have a seal type

00:25:27,250 --> 00:25:30,940
sealed ADT it works for both whatever

00:25:29,380 --> 00:25:33,940
you have in scope but it'll also work

00:25:30,940 --> 00:25:36,640
even if those none and Sun even if

00:25:33,940 --> 00:25:38,260
they're not in the scope we would auto

00:25:36,640 --> 00:25:40,960
import them for you which is what you

00:25:38,260 --> 00:25:43,570
would expect but if it's not a sealed

00:25:40,960 --> 00:25:46,360
ADT if it's just like an exception we

00:25:43,570 --> 00:25:51,780
will know we don't exhaustively match

00:25:46,360 --> 00:25:55,270
all of that some types of exceptions but

00:25:51,780 --> 00:25:56,590
yeah I'm sorry I forgot that we give you

00:25:55,270 --> 00:25:58,600
all of the exceptions when you do the

00:25:56,590 --> 00:26:02,290
case completions so I'll just jump into

00:25:58,600 --> 00:26:04,120
the next one so one thing that we do

00:26:02,290 --> 00:26:06,610
here which is really nice as well is

00:26:04,120 --> 00:26:08,380
that not only exhaustive matches but

00:26:06,610 --> 00:26:10,120
individual case statements and I think

00:26:08,380 --> 00:26:11,890
this is really a feature that I've never

00:26:10,120 --> 00:26:13,930
had in IntelliJ and I really enjoy

00:26:11,890 --> 00:26:15,520
metals is that you're doing a collect

00:26:13,930 --> 00:26:17,890
and you're just taking one of the cases

00:26:15,520 --> 00:26:20,770
and this is the worm that works with

00:26:17,890 --> 00:26:21,970
both seal types and also for exceptions

00:26:20,770 --> 00:26:23,140
because it would just provide you the

00:26:21,970 --> 00:26:26,040
completions of all of the exceptions

00:26:23,140 --> 00:26:26,040
that you have in scope

00:26:26,710 --> 00:26:31,780
I find this to be really useful and

00:26:29,400 --> 00:26:32,920
another polish it's just a small thing

00:26:31,780 --> 00:26:35,020
but it's one of these things that

00:26:32,920 --> 00:26:37,420
required a bit of thinking was that if

00:26:35,020 --> 00:26:41,290
you have case and you do and we know

00:26:37,420 --> 00:26:43,780
that none matches the type of qualifier

00:26:41,290 --> 00:26:45,220
of that match so we'll sort it at the

00:26:43,780 --> 00:26:46,750
top but we don't fill throughout the

00:26:45,220 --> 00:26:48,970
rest because it might be that you want

00:26:46,750 --> 00:26:50,020
to do nail dot something else or wait

00:26:48,970 --> 00:26:52,240
it's really that it would be an

00:26:50,020 --> 00:26:55,410
expensive analysis but just the sorting

00:26:52,240 --> 00:26:58,300
is customized and tweaked and polished

00:26:55,410 --> 00:27:02,620
so the next one which I was desperately

00:26:58,300 --> 00:27:04,570
missing which was overriding methods

00:27:02,620 --> 00:27:07,540
implementing something from an interface

00:27:04,570 --> 00:27:09,610
and in metals you can do that one method

00:27:07,540 --> 00:27:12,160
at a time you go into the body like the

00:27:09,610 --> 00:27:13,720
template of that class here we're

00:27:12,160 --> 00:27:16,180
extending seek which has like 500

00:27:13,720 --> 00:27:18,100
methods but only three of them are

00:27:16,180 --> 00:27:20,920
abstracts so when you do the iterator

00:27:18,100 --> 00:27:22,270
you can see that the iterator is sorted

00:27:20,920 --> 00:27:24,940
at the top because that's the one that

00:27:22,270 --> 00:27:27,040
we should implement first but then we go

00:27:24,940 --> 00:27:28,750
back and then there is all the concrete

00:27:27,040 --> 00:27:31,330
ones and we automatically know that

00:27:28,750 --> 00:27:34,030
there should be an override keyword and

00:27:31,330 --> 00:27:35,590
we also compute the correct kind of it's

00:27:34,030 --> 00:27:40,500
a seek event so then it should be a

00:27:35,590 --> 00:27:42,670
filter filter with an it to boolean the

00:27:40,500 --> 00:27:44,380
next one which is a very important

00:27:42,670 --> 00:27:45,790
feature as well and it's really saving

00:27:44,380 --> 00:27:47,710
you a lot of keystrokes is you say oh

00:27:45,790 --> 00:27:50,920
I'm gonna I need to access that API if

00:27:47,710 --> 00:27:54,070
paths and as you can observe we insert

00:27:50,920 --> 00:27:55,450
an import at the top so if you've come

00:27:54,070 --> 00:27:59,110
from IntelliJ you take this for granted

00:27:55,450 --> 00:28:02,550
it just works perfectly but this is not

00:27:59,110 --> 00:28:05,890
part of the presentation compiler so we

00:28:02,550 --> 00:28:07,750
had to implement that ourselves and the

00:28:05,890 --> 00:28:09,790
way we insert the imports is nowhere

00:28:07,750 --> 00:28:12,070
near as sophisticated as IntelliJ does

00:28:09,790 --> 00:28:14,050
it we just take that simple and we

00:28:12,070 --> 00:28:16,300
import it at the bottom of the global

00:28:14,050 --> 00:28:19,450
import list so you will have to manually

00:28:16,300 --> 00:28:20,980
go up there and sort them according to

00:28:19,450 --> 00:28:22,300
the Comanches of your project we're

00:28:20,980 --> 00:28:24,550
really nice to solve that down the road

00:28:22,300 --> 00:28:27,630
but we just it's it's already really

00:28:24,550 --> 00:28:29,950
good as it is better than nothing

00:28:27,630 --> 00:28:31,780
so the next step is that you do and I

00:28:29,950 --> 00:28:33,400
think this is a piece that I cared a lot

00:28:31,780 --> 00:28:34,900
about because I hit on it all the time

00:28:33,400 --> 00:28:37,150
they said you have conflicting names you

00:28:34,900 --> 00:28:38,650
have files already imported but you want

00:28:37,150 --> 00:28:39,910
to use another API which also has the

00:28:38,650 --> 00:28:42,549
name files because

00:28:39,910 --> 00:28:43,419
library developers use the same names

00:28:42,549 --> 00:28:46,440
all over the place

00:28:43,419 --> 00:28:49,330
and it's really frustrating if files

00:28:46,440 --> 00:28:52,330
would only show us the file that into

00:28:49,330 --> 00:28:54,940
the scope medals always does a full

00:28:52,330 --> 00:28:56,679
search on the whole thing every

00:28:54,940 --> 00:28:59,230
completion is exactly the same we

00:28:56,679 --> 00:29:00,820
wouldn't filter out something and there

00:28:59,230 --> 00:29:02,559
aren't any smart completions that you

00:29:00,820 --> 00:29:05,049
have to do with another shortcut to get

00:29:02,559 --> 00:29:08,049
these results it's just a single command

00:29:05,049 --> 00:29:11,230
complete we do the full search so if

00:29:08,049 --> 00:29:12,730
you're gonna do com Google i/o files we

00:29:11,230 --> 00:29:14,500
know well hey this is already a conflict

00:29:12,730 --> 00:29:15,909
in assembling scope we'll just fully

00:29:14,500 --> 00:29:21,820
qualify it for you and I find this

00:29:15,909 --> 00:29:25,030
really nice so another completion that

00:29:21,820 --> 00:29:27,429
we do which from the kind of scope and

00:29:25,030 --> 00:29:30,159
member completion perspective makes no

00:29:27,429 --> 00:29:31,990
sense is that you you want to do a scope

00:29:30,159 --> 00:29:35,110
completion on the code as if it's

00:29:31,990 --> 00:29:36,909
written inside of a string literal so

00:29:35,110 --> 00:29:38,590
this was kind of a cute thing it didn't

00:29:36,909 --> 00:29:40,870
take a lot of work to do implement but

00:29:38,590 --> 00:29:42,370
you have to understand that you're

00:29:40,870 --> 00:29:44,020
inside of a string literal you have to

00:29:42,370 --> 00:29:45,640
do your own parsing to figure out that's

00:29:44,020 --> 00:29:48,549
what the identifier you pull out the

00:29:45,640 --> 00:29:50,309
scope of that identifier then you you

00:29:48,549 --> 00:29:52,960
you figure that and then you have to

00:29:50,309 --> 00:29:55,780
perform the refactoring to insert the

00:29:52,960 --> 00:29:57,610
the leading s and also you have to

00:29:55,780 --> 00:29:59,500
escape some iodine of characters in the

00:29:57,610 --> 00:30:02,380
string and and sometimes you have to put

00:29:59,500 --> 00:30:04,270
the curly braces and then once you have

00:30:02,380 --> 00:30:06,850
the args you can also select a member

00:30:04,270 --> 00:30:08,320
which was just done the same way but I

00:30:06,850 --> 00:30:09,640
think this was one of my favorite

00:30:08,320 --> 00:30:17,289
features to implement it was a lot of

00:30:09,640 --> 00:30:20,350
fun and very useful so you've seen all

00:30:17,289 --> 00:30:21,820
of the features now and there are more

00:30:20,350 --> 00:30:24,039
but but I think these were the ones that

00:30:21,820 --> 00:30:27,190
were most interesting so a lot of

00:30:24,039 --> 00:30:28,780
customizations on the feature adding

00:30:27,190 --> 00:30:31,299
more richness but we also added a few

00:30:28,780 --> 00:30:32,830
customizations to try to squeeze out as

00:30:31,299 --> 00:30:34,179
much performance as we could because

00:30:32,830 --> 00:30:35,890
it's latency-sensitive

00:30:34,179 --> 00:30:38,620
as you're typing you want to get the

00:30:35,890 --> 00:30:42,460
feedback as fast as you as possible so

00:30:38,620 --> 00:30:44,260
these are I would claim the biggest

00:30:42,460 --> 00:30:45,610
contributors to having decent

00:30:44,260 --> 00:30:47,049
performance if you're gonna do

00:30:45,610 --> 00:30:48,940
completion with the perform the

00:30:47,049 --> 00:30:50,170
presentation compiler

00:30:48,940 --> 00:30:52,900
and we'll go through each of them

00:30:50,170 --> 00:30:56,799
individually so if you here is a

00:30:52,900 --> 00:31:01,720
benchmark doing it's actually a 6,000

00:30:56,799 --> 00:31:06,790
line file doing completions on a member

00:31:01,720 --> 00:31:08,110
where you do dot and the first line is

00:31:06,790 --> 00:31:10,090
essentially we just did a new

00:31:08,110 --> 00:31:13,809
presentation compiler and we just gave

00:31:10,090 --> 00:31:17,230
it the full class path from 0 and it

00:31:13,809 --> 00:31:20,020
does that completion with a hot JVM so

00:31:17,230 --> 00:31:22,870
that was 90 milliseconds so if you just

00:31:20,020 --> 00:31:26,320
keep around that compiler instance and

00:31:22,870 --> 00:31:31,240
then you do another completion in in a

00:31:26,320 --> 00:31:33,400
different file then it will be 40

00:31:31,240 --> 00:31:34,780
milliseconds so you shave off 50

00:31:33,400 --> 00:31:37,450
milliseconds just by reusing that

00:31:34,780 --> 00:31:41,950
compiler so this seems like you know a

00:31:37,450 --> 00:31:44,230
no-brainer win but you also have to be

00:31:41,950 --> 00:31:45,730
careful that the longer you use it the

00:31:44,230 --> 00:31:47,919
more symbols get added to the symbol

00:31:45,730 --> 00:31:49,960
table and it's likely that you may get

00:31:47,919 --> 00:31:51,190
more and more wrong results so it's a

00:31:49,960 --> 00:31:55,480
kind of a delicate balance between

00:31:51,190 --> 00:31:57,130
trying to reset it and reusing it what

00:31:55,480 --> 00:31:59,770
happens usually is that you get requests

00:31:57,130 --> 00:32:01,750
in bursts like 5 completions in a row

00:31:59,770 --> 00:32:04,540
all in the same source files to

00:32:01,750 --> 00:32:07,090
parameter hands 3 hovers and then we

00:32:04,540 --> 00:32:09,660
reuse but then medals is very aggressive

00:32:07,090 --> 00:32:12,010
resetting it again and again and again

00:32:09,660 --> 00:32:14,200
but it really says that most of the

00:32:12,010 --> 00:32:15,400
requests were able to shave off those 50

00:32:14,200 --> 00:32:19,870
millisecond overhead which is

00:32:15,400 --> 00:32:22,480
significant another I'd say biggest

00:32:19,870 --> 00:32:25,240
contributor to it being also robust and

00:32:22,480 --> 00:32:26,650
performant is that so

00:32:25,240 --> 00:32:29,380
in Scala you can have compiler plugins

00:32:26,650 --> 00:32:32,140
and SBT it's by add compiler plug-in and

00:32:29,380 --> 00:32:34,030
people have lifters wart remover all

00:32:32,140 --> 00:32:37,090
sorts of stuff

00:32:34,030 --> 00:32:40,480
medals essentially has a whitelist with

00:32:37,090 --> 00:32:42,910
two approved compiler plugins if you're

00:32:40,480 --> 00:32:44,980
using kind projector we allow it if

00:32:42,910 --> 00:32:48,700
you're using better magnetic 4 we allow

00:32:44,980 --> 00:32:54,460
it if you're using any other plug-in I'm

00:32:48,700 --> 00:32:56,799
sorry we disable it so if you

00:32:54,460 --> 00:32:58,179
so and it's from the observation that

00:32:56,799 --> 00:33:01,330
most compiler plugins actually don't

00:32:58,179 --> 00:33:04,509
change the semantics of the language so

00:33:01,330 --> 00:33:06,730
these two actually introduce new like if

00:33:04,509 --> 00:33:09,340
you wouldn't have kind projector the

00:33:06,730 --> 00:33:10,899
completions would break if you don't

00:33:09,340 --> 00:33:13,179
have a better magnetic four they would

00:33:10,899 --> 00:33:15,789
also break in weird ways but less

00:33:13,179 --> 00:33:17,919
obvious ways so we disable everything

00:33:15,789 --> 00:33:20,289
else including macro paradise

00:33:17,919 --> 00:33:23,379
so micro paradise also qualifies for the

00:33:20,289 --> 00:33:25,600
changes the language semantics but it

00:33:23,379 --> 00:33:27,279
also transforms the trees that we get so

00:33:25,600 --> 00:33:29,379
much that all of the positions are

00:33:27,279 --> 00:33:34,450
broken so the completions don't work

00:33:29,379 --> 00:33:36,700
anyways if we enable it and you may be

00:33:34,450 --> 00:33:37,990
wondering now how oh i'm using macro

00:33:36,700 --> 00:33:39,970
notations in my project there's I mean

00:33:37,990 --> 00:33:41,740
it's totally broken and that's not at

00:33:39,970 --> 00:33:44,440
all the case and that's a really cool

00:33:41,740 --> 00:33:45,700
observation is that if you have micro

00:33:44,440 --> 00:33:47,320
annotations in your project the

00:33:45,700 --> 00:33:50,139
completions were totally fine with them

00:33:47,320 --> 00:33:52,749
they only don't work if you have an

00:33:50,139 --> 00:33:54,610
annotation in a source panel and you're

00:33:52,749 --> 00:33:57,639
trying to complete in the same source

00:33:54,610 --> 00:33:59,529
file for those members so if you have

00:33:57,639 --> 00:34:01,509
another project or any other another

00:33:59,529 --> 00:34:02,799
separate file where they're expanded

00:34:01,509 --> 00:34:06,129
they will appear in your completions

00:34:02,799 --> 00:34:09,040
it's only if you're in the same file but

00:34:06,129 --> 00:34:10,929
that was a pure trade-off because you

00:34:09,040 --> 00:34:12,549
miss a few completions in that case but

00:34:10,929 --> 00:34:14,049
if we enabled it you'd miss almost all

00:34:12,549 --> 00:34:18,099
of them anyways because the trees are

00:34:14,049 --> 00:34:20,980
broken anyways so that was kind of how

00:34:18,099 --> 00:34:23,589
we ended up another one that we do is is

00:34:20,980 --> 00:34:26,440
we actually disable blackbox macros we

00:34:23,589 --> 00:34:28,119
don't expand them and this saves from

00:34:26,440 --> 00:34:30,490
some benchmarks in like a source file

00:34:28,119 --> 00:34:33,250
with 200 lines very small one doing some

00:34:30,490 --> 00:34:35,379
fast parse parsers was able to shave off

00:34:33,250 --> 00:34:38,260
around 130 milliseconds if I remember

00:34:35,379 --> 00:34:39,909
correctly by just turning them off and

00:34:38,260 --> 00:34:41,829
if you're not familiar with blackbox

00:34:39,909 --> 00:34:44,319
macros they're essentially some code

00:34:41,829 --> 00:34:46,750
where you you write let's say here you

00:34:44,319 --> 00:34:49,149
want to generate the timestamp up the

00:34:46,750 --> 00:34:51,579
compilation time so what happens is that

00:34:49,149 --> 00:34:53,710
the compiler will invoke this code it

00:34:51,579 --> 00:34:56,349
will execute it at compile time and then

00:34:53,710 --> 00:35:00,520
put in a new syntax tree based on what

00:34:56,349 --> 00:35:03,579
you expanded and just observe here that

00:35:00,520 --> 00:35:07,059
the it returns along the tree but it's

00:35:03,579 --> 00:35:08,140
annotated as an Annie I'll explain that

00:35:07,059 --> 00:35:11,589
in just a bit

00:35:08,140 --> 00:35:14,049
but we blackbook macros have this really

00:35:11,589 --> 00:35:15,839
nice kind of attribute that you can

00:35:14,049 --> 00:35:17,680
disable them and they don't affect

00:35:15,839 --> 00:35:19,630
completions in any way so the

00:35:17,680 --> 00:35:22,569
completions are totally accurate even if

00:35:19,630 --> 00:35:24,549
you discard them you're just getting 150

00:35:22,569 --> 00:35:27,460
milliseconds shave after your your type

00:35:24,549 --> 00:35:29,049
checking which is awesome there's

00:35:27,460 --> 00:35:30,940
another flavor of macros that are called

00:35:29,049 --> 00:35:32,349
white box and there's no way we like if

00:35:30,940 --> 00:35:34,660
we disable them we would produce

00:35:32,349 --> 00:35:36,489
incorrect results and I'm just gonna

00:35:34,660 --> 00:35:37,869
briefly explain why so if you right if

00:35:36,489 --> 00:35:39,339
you have the original code which would

00:35:37,869 --> 00:35:41,650
be something like macros dot timestamp

00:35:39,339 --> 00:35:43,930
if it was a black box macro it gets

00:35:41,650 --> 00:35:46,690
expanded into that tree but because the

00:35:43,930 --> 00:35:49,210
method has an any type ascription the

00:35:46,690 --> 00:35:53,619
expansion engine will ascribe that

00:35:49,210 --> 00:35:56,049
expression to any so it doesn't leak

00:35:53,619 --> 00:35:56,829
that it was long but a white box will

00:35:56,049 --> 00:35:59,470
not do that

00:35:56,829 --> 00:36:01,450
typescript type of scripture meaning

00:35:59,470 --> 00:36:03,579
that the X will have the type long

00:36:01,450 --> 00:36:05,079
meaning that the type of X will

00:36:03,579 --> 00:36:07,119
influence the completions in the rest of

00:36:05,079 --> 00:36:08,769
the source file so this means if you're

00:36:07,119 --> 00:36:10,989
using metals with a library like

00:36:08,769 --> 00:36:14,230
shapeless that has a CH list generated

00:36:10,989 --> 00:36:16,539
by macros you will get the correct H

00:36:14,230 --> 00:36:19,839
list from like a person with an H list

00:36:16,539 --> 00:36:22,119
of string and it's an H nil but just

00:36:19,839 --> 00:36:26,799
keep in mind that you're paying also for

00:36:22,119 --> 00:36:29,200
the cost here another big win is just by

00:36:26,799 --> 00:36:31,539
not doing handling requests at all

00:36:29,200 --> 00:36:34,569
and that's an even better you go from 2

00:36:31,539 --> 00:36:38,380
down to 0 so imagine that we have a

00:36:34,569 --> 00:36:39,400
request queue I've probably been moving

00:36:38,380 --> 00:36:41,529
my hands in the wrong direction the

00:36:39,400 --> 00:36:43,119
whole time because they're the screen

00:36:41,529 --> 00:36:47,289
here is wrong but anyway so the request

00:36:43,119 --> 00:36:49,900
queue goes this way and we are

00:36:47,289 --> 00:36:51,670
responding to the the first completion

00:36:49,900 --> 00:36:53,230
here and in the meantime while we were

00:36:51,670 --> 00:36:57,999
responding to it the editor sends us

00:36:53,230 --> 00:37:01,630
three new completions once we're

00:36:57,999 --> 00:37:04,059
finished with the first completion we

00:37:01,630 --> 00:37:06,989
cancelled the two that are older and we

00:37:04,059 --> 00:37:09,309
start working on the latest completion

00:37:06,989 --> 00:37:10,480
and this was only changed now in the

00:37:09,309 --> 00:37:12,730
last release that was coming last night

00:37:10,480 --> 00:37:15,489
in the sense that we previously we would

00:37:12,730 --> 00:37:16,960
respond to them in order and what we

00:37:15,489 --> 00:37:18,759
could have is getting up like a really

00:37:16,960 --> 00:37:20,769
long queue of requests and you wouldn't

00:37:18,759 --> 00:37:22,000
get feedback so now we just prioritize

00:37:20,769 --> 00:37:24,700
whatever you just

00:37:22,000 --> 00:37:26,440
submitted and that makes sense in a

00:37:24,700 --> 00:37:28,000
world where you're editing and you only

00:37:26,440 --> 00:37:29,470
care about the last completion that you

00:37:28,000 --> 00:37:31,990
triggered not the one that was before

00:37:29,470 --> 00:37:33,310
and this is great because we shave off

00:37:31,990 --> 00:37:38,320
like we should we skip a bunch of

00:37:33,310 --> 00:37:43,330
requests and what we can do is well is

00:37:38,320 --> 00:37:47,140
the editor can send us cancel this so

00:37:43,330 --> 00:37:48,910
even in valleys in progress metals if

00:37:47,140 --> 00:37:50,590
the editor tells us cancel this we will

00:37:48,910 --> 00:37:52,420
be able to turn off and even stop the

00:37:50,590 --> 00:37:52,990
type checker during middle of

00:37:52,420 --> 00:37:54,609
type-checking

00:37:52,990 --> 00:37:56,950
and thanks to the cancellation support

00:37:54,609 --> 00:38:01,750
in the compiler that that's really great

00:37:56,950 --> 00:38:03,640
and the last piece is a feature that is

00:38:01,750 --> 00:38:05,560
just implemented in the compiler in the

00:38:03,640 --> 00:38:06,849
presentation compiler where you can

00:38:05,560 --> 00:38:08,980
instead of type checking the whole

00:38:06,849 --> 00:38:10,990
source file you can give it a position

00:38:08,980 --> 00:38:13,420
and it will just type checked down to

00:38:10,990 --> 00:38:15,700
that position and you get the typed tree

00:38:13,420 --> 00:38:17,050
at that position so here just as an

00:38:15,700 --> 00:38:19,840
example we're doing we're completing

00:38:17,050 --> 00:38:21,550
numbers and that means we need to go and

00:38:19,840 --> 00:38:23,200
type check the object metals we get

00:38:21,550 --> 00:38:25,930
numbers but it's as a type description

00:38:23,200 --> 00:38:29,320
list event so we don't have to type

00:38:25,930 --> 00:38:31,960
check the one in the the body of that

00:38:29,320 --> 00:38:33,550
method so this works out of the box if

00:38:31,960 --> 00:38:36,820
you just use the presentation compiler

00:38:33,550 --> 00:38:38,589
for scope and member completions but

00:38:36,820 --> 00:38:40,210
with all of the customizations and

00:38:38,589 --> 00:38:42,010
extensions that we do we essentially we

00:38:40,210 --> 00:38:45,430
need to work a lot with the compiler

00:38:42,010 --> 00:38:47,109
trees and their half pipe checks so if

00:38:45,430 --> 00:38:48,580
you're working on the code base you'll

00:38:47,109 --> 00:38:50,290
come in you need to be aware that it's

00:38:48,580 --> 00:38:52,270
really easy to have no types on some

00:38:50,290 --> 00:38:55,720
trees and you need to be aware that you

00:38:52,270 --> 00:38:56,980
should use just targeted typing and and

00:38:55,720 --> 00:38:58,480
that's pretty much how models does now

00:38:56,980 --> 00:39:00,820
and it means it makes a huge difference

00:38:58,480 --> 00:39:03,520
I don't have any numbers but for the

00:39:00,820 --> 00:39:05,320
parameter hints it went from just like

00:39:03,520 --> 00:39:07,390
oh I I wanted I don't want to do

00:39:05,320 --> 00:39:08,770
parameter in skews it was so slow to the

00:39:07,390 --> 00:39:11,560
point where it was just always there and

00:39:08,770 --> 00:39:12,930
I didn't bother so it makes made a huge

00:39:11,560 --> 00:39:16,060
difference

00:39:12,930 --> 00:39:21,550
so as I've said before metals has a lot

00:39:16,060 --> 00:39:24,250
of features and we've had to cover two

00:39:21,550 --> 00:39:26,830
case studies of Diagnostics and

00:39:24,250 --> 00:39:29,980
completions but there's a lot more to it

00:39:26,830 --> 00:39:32,530
so feel free to come to me and ask any

00:39:29,980 --> 00:39:35,109
questions if you're curious I'm gonna

00:39:32,530 --> 00:39:35,920
just very quickly go over the editors

00:39:35,109 --> 00:39:38,620
that we serve

00:39:35,920 --> 00:39:42,250
but it'll be a bit fast since I don't

00:39:38,620 --> 00:39:44,260
have so much time left if you're

00:39:42,250 --> 00:39:46,300
wondering what's up with the hyper on

00:39:44,260 --> 00:39:47,680
Visual Studio code I'll give it to you

00:39:46,300 --> 00:39:50,470
now in a minute

00:39:47,680 --> 00:39:52,500
so it has really great support for other

00:39:50,470 --> 00:39:54,610
languages that are very widely used

00:39:52,500 --> 00:39:56,710
primarily typescript and Python like

00:39:54,610 --> 00:39:58,360
it's fantastic so if you're using those

00:39:56,710 --> 00:40:00,330
languages coming to Scala you probably

00:39:58,360 --> 00:40:03,190
want to just continue using these code

00:40:00,330 --> 00:40:05,380
it has LSP support out of the box which

00:40:03,190 --> 00:40:06,940
means that it's just built into the

00:40:05,380 --> 00:40:09,780
editor and the villa's code team

00:40:06,940 --> 00:40:12,310
maintains that support which is great

00:40:09,780 --> 00:40:13,870
I'm gonna I don't think I'll have time

00:40:12,310 --> 00:40:15,730
to show you but I wanted to show you

00:40:13,870 --> 00:40:17,470
there are two features called live share

00:40:15,730 --> 00:40:19,300
and remote development which are just

00:40:17,470 --> 00:40:22,150
fantastic it allows you to pair program

00:40:19,300 --> 00:40:23,470
with a remote colleague and you're just

00:40:22,150 --> 00:40:25,060
editing as if you're on the same

00:40:23,470 --> 00:40:29,050
computer in a Google Drive style

00:40:25,060 --> 00:40:31,030
collaboration and it's fantastic

00:40:29,050 --> 00:40:34,330
remote development allows you to SSH

00:40:31,030 --> 00:40:35,650
into a remote machine not as in your

00:40:34,330 --> 00:40:36,970
open vias code and you just say I'm

00:40:35,650 --> 00:40:38,920
going to open up a folder in an

00:40:36,970 --> 00:40:40,900
unnecessary remote and then you're just

00:40:38,920 --> 00:40:43,240
editing on that machine but you have the

00:40:40,900 --> 00:40:45,040
great UI with no fiddling with file

00:40:43,240 --> 00:40:49,600
watchers or anything it just works out

00:40:45,040 --> 00:40:51,460
of the box and it's fantastic it has a

00:40:49,600 --> 00:40:53,170
great extension ecosystem and having

00:40:51,460 --> 00:40:54,700
written worked a bit on the metals

00:40:53,170 --> 00:40:57,160
extension that we've written in

00:40:54,700 --> 00:40:59,320
typescript as well and I just enjoy

00:40:57,160 --> 00:41:01,330
writing the extension it takes me like

00:40:59,320 --> 00:41:04,180
you have good completion support you'd

00:41:01,330 --> 00:41:06,010
press play you get like a new fresh

00:41:04,180 --> 00:41:07,840
instance in two seconds that has that

00:41:06,010 --> 00:41:10,240
version of whatever you changed so it's

00:41:07,840 --> 00:41:12,220
really snappy and great and I've tried

00:41:10,240 --> 00:41:13,390
to do it with the other editors it's

00:41:12,220 --> 00:41:16,210
just the best that I've seen in the

00:41:13,390 --> 00:41:17,920
years code and it's very actively

00:41:16,210 --> 00:41:20,080
developed like every month there are new

00:41:17,920 --> 00:41:21,550
releases and I'm I look forward to

00:41:20,080 --> 00:41:23,950
reading the release notes because it's

00:41:21,550 --> 00:41:25,690
just something exciting so the only

00:41:23,950 --> 00:41:27,280
really bad thing I can say is that the

00:41:25,690 --> 00:41:31,210
syntax highlighting for Scala kind of

00:41:27,280 --> 00:41:33,490
sucks it's gotten way better thanks to a

00:41:31,210 --> 00:41:36,640
contributor called Pinal for the past

00:41:33,490 --> 00:41:39,940
weeks and I'm just so thankful to his

00:41:36,640 --> 00:41:42,250
work because previously was especially

00:41:39,940 --> 00:41:45,540
better off string interpolators and non

00:41:42,250 --> 00:41:46,930
ASCII identifiers and stuff like that so

00:41:45,540 --> 00:41:49,030
I'm

00:41:46,930 --> 00:41:54,220
just gonna skip this because the time is

00:41:49,030 --> 00:41:56,770
out but life share is really cool so

00:41:54,220 --> 00:41:58,390
give it a try and the wrote the remote

00:41:56,770 --> 00:42:00,790
development where you can just as you

00:41:58,390 --> 00:42:03,970
know you can code on a machine with a

00:42:00,790 --> 00:42:05,380
hundred cores and 200 gigs of ram and it

00:42:03,970 --> 00:42:07,630
just works seamlessly there's no waste

00:42:05,380 --> 00:42:08,559
like you just do it from the vs code UI

00:42:07,630 --> 00:42:12,640
it's fantastic

00:42:08,559 --> 00:42:15,550
so give it a try so for vim it's

00:42:12,640 --> 00:42:18,069
legendary model editing I've used them

00:42:15,550 --> 00:42:22,059
myself for Python development for a

00:42:18,069 --> 00:42:24,490
while and I loved it and it has I'm just

00:42:22,059 --> 00:42:26,410
gonna say it wasn't the case a year ago

00:42:24,490 --> 00:42:28,329
but today it has a comprehensive LSB

00:42:26,410 --> 00:42:29,550
support in fact there are two different

00:42:28,329 --> 00:42:32,740
implementations like two different

00:42:29,550 --> 00:42:34,839
plugins that comprehensively implement

00:42:32,740 --> 00:42:42,430
most of the spec which is just fantastic

00:42:34,839 --> 00:42:44,380
and I'd say the biggest complaint I can

00:42:42,430 --> 00:42:46,270
have having tried to use it now with

00:42:44,380 --> 00:42:47,770
metals is that if you want to say hey

00:42:46,270 --> 00:42:50,410
would you like to import the build that

00:42:47,770 --> 00:42:52,030
is a blocking UI widget it would be

00:42:50,410 --> 00:42:54,250
really nice to just have a thing that's

00:42:52,030 --> 00:42:55,720
on like non-blocking on the side and you

00:42:54,250 --> 00:42:57,400
can continue editing and click on the

00:42:55,720 --> 00:43:01,119
button whenever you want and this is

00:42:57,400 --> 00:43:02,980
really really annoying and if you

00:43:01,119 --> 00:43:04,900
haven't seen it there's an in

00:43:02,980 --> 00:43:07,690
development editor called own a bit

00:43:04,900 --> 00:43:09,190
which kind of solves that problem but

00:43:07,690 --> 00:43:10,990
still keeps all of the goodies of them

00:43:09,190 --> 00:43:14,410
so I'm personally very excited about

00:43:10,990 --> 00:43:17,470
that one Emacs I don't know much about

00:43:14,410 --> 00:43:22,450
so don't shoot me but it seems to be

00:43:17,470 --> 00:43:24,369
legendarily customizable and it also not

00:43:22,450 --> 00:43:26,470
the case a year ago but it has today

00:43:24,369 --> 00:43:29,319
comprehensive LSP support which is just

00:43:26,470 --> 00:43:31,390
fantastic and it supports pretty much

00:43:29,319 --> 00:43:32,920
all of the features that we support in

00:43:31,390 --> 00:43:37,150
metals including the advanced parts

00:43:32,920 --> 00:43:39,069
around completions and I would say it's

00:43:37,150 --> 00:43:40,569
the same issue as them but probably

00:43:39,069 --> 00:43:44,290
someone's gonna say no that's not the

00:43:40,569 --> 00:43:45,819
case you just need another plugin but if

00:43:44,290 --> 00:43:47,770
you want to have like a non-blocking UI

00:43:45,819 --> 00:43:51,640
widget to do imports it's kind of

00:43:47,770 --> 00:43:53,290
invasive and sublime texts I've never

00:43:51,640 --> 00:43:55,720
used really but I have like great

00:43:53,290 --> 00:43:58,089
respect for its primarily because it's

00:43:55,720 --> 00:44:01,300
legendarily lightweight and it has

00:43:58,089 --> 00:44:04,750
really good defaults in my opinion

00:44:01,300 --> 00:44:07,870
and it's not as comprehensive today as

00:44:04,750 --> 00:44:09,310
Remax and vim the LSP package but it's

00:44:07,870 --> 00:44:11,170
actively developed and I think there's

00:44:09,310 --> 00:44:12,820
an open pier adding some of the more

00:44:11,170 --> 00:44:15,580
advanced pieces and completions so it's

00:44:12,820 --> 00:44:17,380
getting there really close which makes

00:44:15,580 --> 00:44:20,080
me very optimistic and I think is great

00:44:17,380 --> 00:44:22,630
I would really wish sublime text like

00:44:20,080 --> 00:44:24,100
that sensible default philosophy they

00:44:22,630 --> 00:44:26,340
should just have LSP out of the box and

00:44:24,100 --> 00:44:29,200
it would be a huge boost for sublime and

00:44:26,340 --> 00:44:31,420
I just picked one thing I'm sure there

00:44:29,200 --> 00:44:33,160
are other things but we have commands

00:44:31,420 --> 00:44:35,440
like import build and currently have to

00:44:33,160 --> 00:44:36,970
like copy/paste JSON config every person

00:44:35,440 --> 00:44:39,070
has to do that there's no way for us to

00:44:36,970 --> 00:44:44,110
or maybe there is but I haven't figured

00:44:39,070 --> 00:44:47,260
out and lastly Adam it seems to be

00:44:44,110 --> 00:44:49,180
legendarily extensible it has really

00:44:47,260 --> 00:44:53,170
these nice UI widgets the same that vyas

00:44:49,180 --> 00:44:57,820
code has but sorry maybe someone is I

00:44:53,170 --> 00:44:59,440
mean the LSP support does not that the

00:44:57,820 --> 00:45:00,730
completions don't handle some of the

00:44:59,440 --> 00:45:03,250
more advanced refactorings that we do

00:45:00,730 --> 00:45:05,920
I'm not I'm not aware of any current PRS

00:45:03,250 --> 00:45:08,020
fixing these issues so like Auto imports

00:45:05,920 --> 00:45:09,160
like the imports just don't appear which

00:45:08,020 --> 00:45:11,440
is really a bad out-of-the-box

00:45:09,160 --> 00:45:13,600
experience I would not recommend this if

00:45:11,440 --> 00:45:15,640
you're showing it to beginners and say

00:45:13,600 --> 00:45:17,470
just install metals and use atom like

00:45:15,640 --> 00:45:19,810
some stuff doesn't work and there's

00:45:17,470 --> 00:45:23,830
nothing there's no way for us to figure

00:45:19,810 --> 00:45:27,340
work around that so that's it so future

00:45:23,830 --> 00:45:31,420
work as you can imagine an IDE is a huge

00:45:27,340 --> 00:45:33,880
task running and testing in debugging we

00:45:31,420 --> 00:45:35,710
have Maddock who is from various lab has

00:45:33,880 --> 00:45:37,240
been working on this full time now for

00:45:35,710 --> 00:45:40,180
over a month I think and I'm really

00:45:37,240 --> 00:45:43,180
excited I'm optimistic we'll be able to

00:45:40,180 --> 00:45:45,760
have just run and maybe down the road

00:45:43,180 --> 00:45:47,740
even debugging but also run tests and

00:45:45,760 --> 00:45:49,510
you could see the past test and the

00:45:47,740 --> 00:45:52,360
failed tests and I'm really excited

00:45:49,510 --> 00:45:53,890
about that getting close to that

00:45:52,360 --> 00:45:56,230
out-of-the-box experience for a beginner

00:45:53,890 --> 00:45:59,050
who doesn't even have to know what Scala

00:45:56,230 --> 00:46:01,660
test is or something and doesn't have to

00:45:59,050 --> 00:46:03,430
figure out the incantation for just

00:46:01,660 --> 00:46:04,810
testing a single unit test because all

00:46:03,430 --> 00:46:07,660
of the testing libraries have different

00:46:04,810 --> 00:46:09,220
syntax meaning the symbol we're pretty

00:46:07,660 --> 00:46:11,380
much there almost we have find

00:46:09,220 --> 00:46:12,770
references it requires a bit of more

00:46:11,380 --> 00:46:16,460
custom development to

00:46:12,770 --> 00:46:18,170
to be correct refactoring support is

00:46:16,460 --> 00:46:20,540
non-existent at the time

00:46:18,170 --> 00:46:23,630
LSP has great infrastructure for

00:46:20,540 --> 00:46:26,619
refactorings but we just don't implement

00:46:23,630 --> 00:46:29,660
at the moment and it's a big project

00:46:26,619 --> 00:46:30,980
worksheets I think would be fantastic to

00:46:29,660 --> 00:46:33,589
have if you could just open up a file

00:46:30,980 --> 00:46:35,030
and you can see the values in line what

00:46:33,589 --> 00:46:37,430
they are as you're just learning a new

00:46:35,030 --> 00:46:39,859
API and I would estimate this is not

00:46:37,430 --> 00:46:41,810
that even hard to add with our current

00:46:39,859 --> 00:46:44,380
infrastructure and the same thing it's

00:46:41,810 --> 00:46:48,170
pretty much the same thing for SBT and

00:46:44,380 --> 00:46:51,020
Scala script files so probably a hundred

00:46:48,170 --> 00:46:53,119
other features that could be added but

00:46:51,020 --> 00:46:57,640
these are the highlighting ones that I

00:46:53,119 --> 00:46:57,640
think are most exciting thank you

00:47:02,300 --> 00:47:08,570
no time feel free to come to me if you

00:47:06,530 --> 00:47:10,630
have any questions I'm out of time thank

00:47:08,570 --> 00:47:10,630
you

00:47:14,210 --> 00:47:17,320

YouTube URL: https://www.youtube.com/watch?v=MRQMylDxBJ8


