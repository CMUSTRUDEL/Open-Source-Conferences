Title: ScalaJS and Typescript: an unlikely romance - Jeremy Hughes
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/scalajs-and-typescript-an-unlikely-romance
Captions: 
	00:00:01,700 --> 00:00:08,270
okay hello everyone this is a love story

00:00:09,410 --> 00:00:15,839
I'm Jeremy Hughes

00:00:12,330 --> 00:00:19,670
I'm from New Zealand and everything I'm

00:00:15,839 --> 00:00:19,670
going to describe I saw with my own eyes

00:00:21,439 --> 00:00:26,750
these are the four colorful characters

00:00:23,789 --> 00:00:32,940
that will dominate the story Scala

00:00:26,750 --> 00:00:36,690
javascript DTS and typescript don't be

00:00:32,940 --> 00:00:40,950
put off by their appearance some are

00:00:36,690 --> 00:00:47,250
friendly some are dangerous the worst

00:00:40,950 --> 00:00:52,190
are both friendly and dangerous there's

00:00:47,250 --> 00:00:55,530
a Scala classy expensive tastes

00:00:52,190 --> 00:00:58,980
place honest likes Bertrand Russell and

00:00:55,530 --> 00:01:05,299
European history complicated but in an

00:00:58,980 --> 00:01:10,040
endearing fashion this is tight script a

00:01:05,299 --> 00:01:15,600
pragmatic empiricist likes the outdoors

00:01:10,040 --> 00:01:18,390
admires virgin stein here are some of

00:01:15,600 --> 00:01:19,830
the features of typescript I'm going to

00:01:18,390 --> 00:01:25,200
go through them one by one with some

00:01:19,830 --> 00:01:25,920
code examples typescript is structurally

00:01:25,200 --> 00:01:32,390
subtitled

00:01:25,920 --> 00:01:36,180
so in this example why is a subtype of X

00:01:32,390 --> 00:01:40,430
B for structural reasons not for nominal

00:01:36,180 --> 00:01:45,390
reasons so Y can be assigned to

00:01:40,430 --> 00:01:51,240
something that has type of X as untag

00:01:45,390 --> 00:01:53,460
unions just like Scala 3 has

00:01:51,240 --> 00:01:57,860
intersections so in this case we have a

00:01:53,460 --> 00:02:01,759
type X and type Y the type Z has

00:01:57,860 --> 00:02:06,649
properties of both x and y so it has

00:02:01,759 --> 00:02:06,649
alpha odd number and beta of string

00:02:07,229 --> 00:02:13,819
as the thing called index type accesses

00:02:10,489 --> 00:02:17,910
so you have an object in this case a and

00:02:13,819 --> 00:02:22,440
we can ask what is the type of the

00:02:17,910 --> 00:02:26,040
property on a of this literal string

00:02:22,440 --> 00:02:30,480
type so here is a the function value at

00:02:26,040 --> 00:02:33,150
just saying give me a key that exists on

00:02:30,480 --> 00:02:35,239
type a give me an object of type a and

00:02:33,150 --> 00:02:36,989
I'll give you the value correctly typed

00:02:35,239 --> 00:02:42,150
at that location

00:02:36,989 --> 00:02:43,950
and on a so say we have an object

00:02:42,150 --> 00:02:46,319
containing the name and the height of

00:02:43,950 --> 00:02:49,829
the world's tallest man and we want to

00:02:46,319 --> 00:02:51,660
get height we can pass in height and get

00:02:49,829 --> 00:02:54,660
back a value which will be currently

00:02:51,660 --> 00:02:58,049
typed as number if we passed in

00:02:54,660 --> 00:03:00,920
something other than height or name that

00:02:58,049 --> 00:03:00,920
would cause a compile-time error

00:03:02,660 --> 00:03:09,260
typescript has conditional types which

00:03:05,459 --> 00:03:14,239
are similar to scale threes match types

00:03:09,260 --> 00:03:18,359
example here is say I have a a codec

00:03:14,239 --> 00:03:22,500
which is a way of getting from a type a

00:03:18,359 --> 00:03:26,810
to some sort of binary or other

00:03:22,500 --> 00:03:30,269
serialization type o and back again I

00:03:26,810 --> 00:03:33,569
might want a convenience of method to

00:03:30,269 --> 00:03:36,209
jason on this codec which is only

00:03:33,569 --> 00:03:39,859
applicable to a codec where type is a

00:03:36,209 --> 00:03:43,230
subtype of Jason so here I can use

00:03:39,859 --> 00:03:46,859
conditional types which here I'm saying

00:03:43,230 --> 00:03:49,290
if o is a subtype of Jason then I

00:03:46,859 --> 00:03:53,130
require a value of a and I'm going to

00:03:49,290 --> 00:03:55,829
return its encoding and jason otherwise

00:03:53,130 --> 00:03:57,840
you can't give me anything it's an ever

00:03:55,829 --> 00:04:01,739
so if you try to call this method on a

00:03:57,840 --> 00:04:02,760
codec where o does not extend Jason it's

00:04:01,739 --> 00:04:04,500
going to be a compile time failed

00:04:02,760 --> 00:04:10,079
because you cannot give a single value

00:04:04,500 --> 00:04:13,079
to to JSON that will be correct perhaps

00:04:10,079 --> 00:04:15,599
a more familiar example is something

00:04:13,079 --> 00:04:19,940
similar to what Martin gave in his

00:04:15,599 --> 00:04:24,200
keynote where we have a couple type

00:04:19,940 --> 00:04:31,820
here it's a it's a union of empty and

00:04:24,200 --> 00:04:33,710
pair typescript only has untag Union so

00:04:31,820 --> 00:04:36,110
we emulate tag unions by having a

00:04:33,710 --> 00:04:38,240
literal type tag there that's either

00:04:36,110 --> 00:04:39,590
empty or peer and that what that's what

00:04:38,240 --> 00:04:42,800
allows us to discriminate between the

00:04:39,590 --> 00:04:47,030
two and then we have this concat type

00:04:42,800 --> 00:04:51,650
which uses the conditional typing of

00:04:47,030 --> 00:04:54,680
typescript to say if X as as a pair and

00:04:51,650 --> 00:04:59,900
Y's there's also a pair then we're going

00:04:54,680 --> 00:05:02,990
to return a a quad otherwise you'll just

00:04:59,900 --> 00:05:05,780
get X is all-wise I've got a demo that

00:05:02,990 --> 00:05:07,370
shows this working but I can show you at

00:05:05,780 --> 00:05:13,040
the end of the talk not during because

00:05:07,370 --> 00:05:18,110
such a hassle to switch between also has

00:05:13,040 --> 00:05:20,930
map types which is a way of encoding

00:05:18,110 --> 00:05:23,630
something similar to hire kind of data

00:05:20,930 --> 00:05:26,930
types and Scala where you have a data

00:05:23,630 --> 00:05:32,120
type that takes maybe a functor so that

00:05:26,930 --> 00:05:36,980
the values could be identity or option

00:05:32,120 --> 00:05:42,470
or that kind of thing so here we pass

00:05:36,980 --> 00:05:46,210
into a mint type this type literal of

00:05:42,470 --> 00:05:48,820
alpha of number and beta of string and

00:05:46,210 --> 00:05:51,500
the map types is for every key in

00:05:48,820 --> 00:05:56,860
whatever type you passed me pass back an

00:05:51,500 --> 00:05:59,950
array that's sorry pass back yeah a and

00:05:56,860 --> 00:06:04,700
for that key value which is an array of

00:05:59,950 --> 00:06:06,320
whatever type is their key so pass an

00:06:04,700 --> 00:06:09,470
alpha of number beta of string and get

00:06:06,320 --> 00:06:12,160
back alpha of a rad number and beta of a

00:06:09,470 --> 00:06:12,160
rape of string

00:06:14,030 --> 00:06:21,980
this is javascript javascript is a

00:06:17,610 --> 00:06:25,140
topological nihilist everyone's friend

00:06:21,980 --> 00:06:27,720
everyone's unpredictable wackadoodle and

00:06:25,140 --> 00:06:31,800
friend you never knew just by looking

00:06:27,720 --> 00:06:33,780
what the yellow clown would do next the

00:06:31,800 --> 00:06:36,330
bravest or most foolish among us didn't

00:06:33,780 --> 00:06:37,950
let this bother bother us how we are

00:06:36,330 --> 00:06:39,630
cautious acquaintances wish they could

00:06:37,950 --> 00:06:42,390
invite the clown over to cook dinner

00:06:39,630 --> 00:06:44,070
before inviting the clown over to cook

00:06:42,390 --> 00:06:45,870
dinner just to make sure the cooking

00:06:44,070 --> 00:06:55,170
dinner didn't also include setting fire

00:06:45,870 --> 00:06:56,730
to the house finally this is DTS and DTS

00:06:55,170 --> 00:07:01,340
is favourite trick is to dress

00:06:56,730 --> 00:07:05,930
JavaScript up in typescripts clothes

00:07:01,340 --> 00:07:09,240
this fall's most people most of the time

00:07:05,930 --> 00:07:10,920
when you compile a typescript file where

00:07:09,240 --> 00:07:14,310
you can out the other end is a file of

00:07:10,920 --> 00:07:20,040
JavaScript and a file of typescript type

00:07:14,310 --> 00:07:21,930
declarations which is a DTS file DTS and

00:07:20,040 --> 00:07:24,180
those those files are then consumed in

00:07:21,930 --> 00:07:28,370
turn by typescript again if you depend

00:07:24,180 --> 00:07:31,350
on that module if you're pulling down

00:07:28,370 --> 00:07:33,840
some module that's just purely

00:07:31,350 --> 00:07:37,860
JavaScript you can provide a manually

00:07:33,840 --> 00:07:41,850
written DTS file describing the types of

00:07:37,860 --> 00:07:44,940
that JavaScript module that's what DTS

00:07:41,850 --> 00:07:47,210
does those are the characters in the

00:07:44,940 --> 00:07:47,210
story

00:07:47,840 --> 00:07:55,410
so he goes once upon a time in a far-off

00:07:51,120 --> 00:07:57,960
land the land of New Zealand there was a

00:07:55,410 --> 00:08:01,290
hill and on that health scarlet and

00:07:57,960 --> 00:08:03,930
typescript met one sunny day the

00:08:01,290 --> 00:08:07,490
attraction between them was palpable so

00:08:03,930 --> 00:08:07,490
Scala ventured a friendly greeting

00:08:09,320 --> 00:08:15,020
clearly did not understand the

00:08:13,880 --> 00:08:21,590
attraction was mutual

00:08:15,020 --> 00:08:26,330
so typescript said hello Scala did not

00:08:21,590 --> 00:08:27,710
understand so when your first attempt to

00:08:26,330 --> 00:08:31,040
get them to understand each other is to

00:08:27,710 --> 00:08:32,810
plug the code from one into the

00:08:31,040 --> 00:08:37,010
interpreter at the other this is what

00:08:32,810 --> 00:08:38,870
you get kind of doesn't work

00:08:37,010 --> 00:08:41,380
what about start - what could have been

00:08:38,870 --> 00:08:43,420
an epic romance thought Scala

00:08:41,380 --> 00:08:46,940
Scala went home depressed

00:08:43,420 --> 00:08:49,010
why bother and even if there is a reason

00:08:46,940 --> 00:08:51,950
to bother how are we ever going to

00:08:49,010 --> 00:08:52,850
understand each other and even if that

00:08:51,950 --> 00:08:54,650
works out

00:08:52,850 --> 00:08:58,610
when will we elope to the land of

00:08:54,650 --> 00:08:59,750
general availability on github it's

00:08:58,610 --> 00:09:07,400
going to be the structure of the story

00:08:59,750 --> 00:09:09,350
why how and when why why have this

00:09:07,400 --> 00:09:11,900
relationship in the first place well

00:09:09,350 --> 00:09:13,850
once upon a time there was a project the

00:09:11,900 --> 00:09:16,550
project had client which had to use

00:09:13,850 --> 00:09:20,210
JavaScript yet be protected from

00:09:16,550 --> 00:09:23,090
JavaScript's unpredictable nature had a

00:09:20,210 --> 00:09:25,760
server written and scala of course and

00:09:23,090 --> 00:09:27,650
it kind of no-man's land in between code

00:09:25,760 --> 00:09:31,750
that needed to be flexible to be run on

00:09:27,650 --> 00:09:34,730
the server or the client where necessary

00:09:31,750 --> 00:09:37,010
largely because we didn't yet know what

00:09:34,730 --> 00:09:38,660
we were doing and this is a project

00:09:37,010 --> 00:09:40,430
where there was a budget for

00:09:38,660 --> 00:09:42,440
experimentation they contained just

00:09:40,430 --> 00:09:49,100
enough latitude to reach into the

00:09:42,440 --> 00:09:50,450
unknown and find love what we needed to

00:09:49,100 --> 00:09:50,900
do is run on both the server and the

00:09:50,450 --> 00:09:53,030
client

00:09:50,900 --> 00:10:00,190
but exposed something better then

00:09:53,030 --> 00:10:08,329
untyped javascript to the client yeah

00:10:00,190 --> 00:10:12,139
love doesn't need a reason how did

00:10:08,329 --> 00:10:13,610
come about well Schuyler got up early

00:10:12,139 --> 00:10:16,339
and climbed a tall hill to get a better

00:10:13,610 --> 00:10:19,999
sense of perspective scholars friends

00:10:16,339 --> 00:10:22,879
came to everything looks so simple from

00:10:19,999 --> 00:10:25,850
here it's like standing on the shoulders

00:10:22,879 --> 00:10:29,749
of giants if you don't know this is the

00:10:25,850 --> 00:10:31,699
the logo for scholar day yes so thanks

00:10:29,749 --> 00:10:35,809
scholar jeaious and everyone that built

00:10:31,699 --> 00:10:38,360
it while up the other four friends had

00:10:35,809 --> 00:10:41,329
an epiphany Scala and Java Script could

00:10:38,360 --> 00:10:42,679
communicate javascript and typescript

00:10:41,329 --> 00:10:44,989
could communicate

00:10:42,679 --> 00:10:47,929
therefore by transitivity Scala and

00:10:44,989 --> 00:10:53,569
typescript could communicate dps in

00:10:47,929 --> 00:10:57,379
particular was delighted scaligeri it's

00:10:53,569 --> 00:11:00,049
us javascript already all we need to do

00:10:57,379 --> 00:11:03,049
is supply typescript type declarations

00:11:00,049 --> 00:11:07,129
for the JavaScript output of Scala dias

00:11:03,049 --> 00:11:11,989
and boom we're done creating the type

00:11:07,129 --> 00:11:14,329
declarations is all we need to do so the

00:11:11,989 --> 00:11:19,220
friends tried it out at once first Scala

00:11:14,329 --> 00:11:22,819
stood and improvised a short poem about

00:11:19,220 --> 00:11:27,949
length of string then JavaScript

00:11:22,819 --> 00:11:29,929
rendered and interpretation DDS saw that

00:11:27,949 --> 00:11:36,889
javascript had left out some important

00:11:29,929 --> 00:11:39,290
information so DTS added it back in so

00:11:36,889 --> 00:11:43,749
for obvious reasons JavaScript liftoff

00:11:39,290 --> 00:11:46,850
the types and easiest put the types Bank

00:11:43,749 --> 00:11:55,100
typescript heard and understood so

00:11:46,850 --> 00:11:57,259
everyone was very happy the end a really

00:11:55,100 --> 00:12:01,759
kind of concise example of of what you

00:11:57,259 --> 00:12:04,939
get put in Scala Jes get out javascript

00:12:01,759 --> 00:12:07,639
write the Declaration file for the

00:12:04,939 --> 00:12:13,549
JavaScript and then you can consume that

00:12:07,639 --> 00:12:20,449
from typescript not eand there are two

00:12:13,549 --> 00:12:22,539
problems problem one is that DTS the

00:12:20,449 --> 00:12:24,439
second favorite trick is

00:12:22,539 --> 00:12:30,470
misrepresentation and here's an example

00:12:24,439 --> 00:12:35,350
of that DDS provides a file containing a

00:12:30,470 --> 00:12:35,350
declaration for the current time get now

00:12:36,160 --> 00:12:42,519
typescript consumes this and creates a

00:12:40,490 --> 00:12:46,360
function for getting the current epoch

00:12:42,519 --> 00:12:50,689
number of milliseconds since UNIX 0

00:12:46,360 --> 00:12:53,209
everything type Chicks and blows up at

00:12:50,689 --> 00:12:57,399
runtime because get you to see

00:12:53,209 --> 00:13:00,769
milliseconds is not a function on date

00:12:57,399 --> 00:13:05,209
why is this well it's because DT is

00:13:00,769 --> 00:13:09,470
slide what javascript actually said was

00:13:05,209 --> 00:13:11,059
that get now returns a string so this is

00:13:09,470 --> 00:13:14,089
this is something that these es is very

00:13:11,059 --> 00:13:18,319
fond of misrepresentation here's another

00:13:14,089 --> 00:13:20,660
example a scholar and typescript Scala

00:13:18,319 --> 00:13:25,179
wants a flower presumably as a sign of

00:13:20,660 --> 00:13:28,489
affection I would like a flower

00:13:25,179 --> 00:13:30,669
typescript of course I'll give you a

00:13:28,489 --> 00:13:33,669
flower here's a flower

00:13:30,669 --> 00:13:33,669
however

00:13:34,119 --> 00:13:38,389
unbeknown to Scala and typescript

00:13:36,499 --> 00:13:44,509
typescript has once again been tricked

00:13:38,389 --> 00:13:47,329
by des so des is green and it's

00:13:44,509 --> 00:13:51,379
presumably told typescript that yep

00:13:47,329 --> 00:13:53,649
here's how to give a flower but at

00:13:51,379 --> 00:13:53,649
runtime

00:13:54,049 --> 00:13:57,850
what's happening this is giving a flame

00:13:56,299 --> 00:14:03,279
instead of a flower

00:13:57,850 --> 00:14:03,279
so scarlet dies and flaming agony

00:14:06,980 --> 00:14:15,290
problem is the typescript trusts DTS

00:14:09,620 --> 00:14:18,680
completely so if you make a change to

00:14:15,290 --> 00:14:22,940
whatever generates JavaScript and forget

00:14:18,680 --> 00:14:26,480
to update your definition files you get

00:14:22,940 --> 00:14:29,480
runtime problems if something you're

00:14:26,480 --> 00:14:31,790
depending on some upstream library makes

00:14:29,480 --> 00:14:34,310
a change and you update and don't

00:14:31,790 --> 00:14:36,620
realize and you don't change your DTS

00:14:34,310 --> 00:14:40,610
files then you're going to get problems

00:14:36,620 --> 00:14:44,990
at runtime if you update your DTS files

00:14:40,610 --> 00:14:47,170
but make a typo that type checks then

00:14:44,990 --> 00:14:49,730
you're going to get problems at runtime

00:14:47,170 --> 00:14:52,550
it's the worst of both worlds you have

00:14:49,730 --> 00:15:00,529
the confidence of types and the runtime

00:14:52,550 --> 00:15:04,269
failures of no types so if you use DTS

00:15:00,529 --> 00:15:09,170
in this vanilla way you will be sorry

00:15:04,269 --> 00:15:11,180
the second problem is that as we alluded

00:15:09,170 --> 00:15:14,000
to before scarlet as a platanus and

00:15:11,180 --> 00:15:14,480
typescript is a pragmatic and process so

00:15:14,000 --> 00:15:17,089
Scala

00:15:14,480 --> 00:15:20,839
believes and the Platonic abstract ideal

00:15:17,089 --> 00:15:22,399
of darkness for instance typescript

00:15:20,839 --> 00:15:24,640
believes that if it looks like a duck it

00:15:22,399 --> 00:15:24,640
is a duck

00:15:25,300 --> 00:15:33,170
so Scala see is his duck and here's how

00:15:29,269 --> 00:15:34,730
you give me a duck goes alright I've got

00:15:33,170 --> 00:15:38,769
a duck and I'm gonna give you a duck

00:15:34,730 --> 00:15:38,769
little type chicks that's sweet and

00:15:39,940 --> 00:15:47,570
Scala blows up at runtime but the

00:15:43,310 --> 00:15:50,779
JavaScript runtime blows up because you

00:15:47,570 --> 00:15:55,430
gave me an object which happens to have

00:15:50,779 --> 00:15:58,850
a name and I really wanted a duck so

00:15:55,430 --> 00:16:02,019
this is because scholar is nominally sub

00:15:58,850 --> 00:16:04,100
x and typescript is structurally sub x

00:16:02,019 --> 00:16:08,560
those are the two problems we need to

00:16:04,100 --> 00:16:10,790
overcome des lies and producers

00:16:08,560 --> 00:16:14,839
definitions that are just plain wrong

00:16:10,790 --> 00:16:16,459
and secondly Scala requires nominal

00:16:14,839 --> 00:16:18,110
types from typescript which doesn't

00:16:16,459 --> 00:16:19,700
believe in them

00:16:18,110 --> 00:16:22,510
so we could say in terms of the story

00:16:19,700 --> 00:16:24,950
once upon a time there were four friends

00:16:22,510 --> 00:16:28,220
JavaScript who could speak but was

00:16:24,950 --> 00:16:30,670
unintelligible DTS who could interpret

00:16:28,220 --> 00:16:33,350
but was a pathological liar

00:16:30,670 --> 00:16:35,029
typescript who trusted DTS implicitly

00:16:33,350 --> 00:16:38,420
and scholar who was pedantic about

00:16:35,029 --> 00:16:40,399
abstract platonic ideals how do we

00:16:38,420 --> 00:16:44,510
progress the plot because we want these

00:16:40,399 --> 00:16:52,100
guys to get together we said put two

00:16:44,510 --> 00:17:00,769
constraints on DTS constraint number one

00:16:52,100 --> 00:17:04,819
is we generate DTS from Scala so we cut

00:17:00,769 --> 00:17:06,799
out the manual process so provided our

00:17:04,819 --> 00:17:09,220
generation is correct we're not going to

00:17:06,799 --> 00:17:12,049
have the the update problem

00:17:09,220 --> 00:17:14,030
DTS might be just wrong or lying its

00:17:12,049 --> 00:17:16,939
face off anymore because it's being

00:17:14,030 --> 00:17:21,770
generated from the source of the types

00:17:16,939 --> 00:17:24,530
to begin with constraint number two is

00:17:21,770 --> 00:17:28,309
that we emulate nominal types in our DTS

00:17:24,530 --> 00:17:33,980
definitions here's an example it's a

00:17:28,309 --> 00:17:37,280
duck here's how to give me a duck and if

00:17:33,980 --> 00:17:41,299
in our DTS file so well here's a doc and

00:17:37,280 --> 00:17:43,669
his name type string it also has an

00:17:41,299 --> 00:17:47,840
additional property with a unique name

00:17:43,669 --> 00:17:50,179
fully qualified name of duck just by

00:17:47,840 --> 00:17:54,110
giving unique name of type never so it

00:17:50,179 --> 00:18:00,850
exists only at the type level but it

00:17:54,110 --> 00:18:02,309
makes duck structurally unique so then

00:18:00,850 --> 00:18:04,110
type script

00:18:02,309 --> 00:18:07,980
says well here's something that looks

00:18:04,110 --> 00:18:11,250
like a dunk gets a type error instead of

00:18:07,980 --> 00:18:16,890
a runtime error because what you've

00:18:11,250 --> 00:18:19,220
given to gimme is missing this this

00:18:16,890 --> 00:18:22,260
property fully qualified name of duck

00:18:19,220 --> 00:18:26,520
that's how we can emulate nominal types

00:18:22,260 --> 00:18:28,970
in typescript so those are the two

00:18:26,520 --> 00:18:32,640
constraints one is the process of

00:18:28,970 --> 00:18:35,549
generation and the second is how we

00:18:32,640 --> 00:18:36,450
create nominal types and now they lived

00:18:35,549 --> 00:18:41,280
happily ever after

00:18:36,450 --> 00:18:44,700
for real they end what I've got now is

00:18:41,280 --> 00:18:50,360
some examples of translating from the

00:18:44,700 --> 00:18:50,360
scallops into the typescript definitions

00:18:50,720 --> 00:18:59,280
here's a scarlet r8 which has two

00:18:54,409 --> 00:19:01,679
members offer and beta pretty

00:18:59,280 --> 00:19:04,530
straightforward translation into a

00:19:01,679 --> 00:19:09,919
typescript interface with the addition

00:19:04,530 --> 00:19:16,679
of this this property that only exists

00:19:09,919 --> 00:19:20,370
at the type level same thing with

00:19:16,679 --> 00:19:22,679
classes really we have an interface

00:19:20,370 --> 00:19:25,500
which describes the class just the same

00:19:22,679 --> 00:19:30,059
as the trait and an interface which

00:19:25,500 --> 00:19:32,549
describes the class constructor which in

00:19:30,059 --> 00:19:35,460
this case takes an alpha of string and

00:19:32,549 --> 00:19:37,289
then we declare that there's this value

00:19:35,460 --> 00:19:38,850
a class which has the type of the

00:19:37,289 --> 00:19:43,440
constructor and so now we can construct

00:19:38,850 --> 00:19:48,390
values of this class by supplying a

00:19:43,440 --> 00:19:50,789
string be tempting to leave off that

00:19:48,390 --> 00:19:53,669
second definition and class constructor

00:19:50,789 --> 00:19:55,740
which contains the new because as we've

00:19:53,669 --> 00:19:56,250
all heard new as parse a and we don't do

00:19:55,740 --> 00:20:02,419
that anymore

00:19:56,250 --> 00:20:07,919
but that new definition is how the

00:20:02,419 --> 00:20:09,870
typescript compiler knows that something

00:20:07,919 --> 00:20:13,159
can be an instance of a class so it's

00:20:09,870 --> 00:20:13,159
necessary we need to keep it around

00:20:16,180 --> 00:20:25,460
object suggests interfaces that have a

00:20:20,260 --> 00:20:27,680
value implementation and the the value

00:20:25,460 --> 00:20:32,690
side of all this stuff is supplied by

00:20:27,680 --> 00:20:37,490
Scala Janus so we're just supplying

00:20:32,690 --> 00:20:40,280
quite literally just the types so here's

00:20:37,490 --> 00:20:48,080
here's how in in typescript you get this

00:20:40,280 --> 00:20:50,990
default value we can create unions so

00:20:48,080 --> 00:20:52,880
for a for a scalar type that's kind of

00:20:50,990 --> 00:20:58,090
like either got result which can either

00:20:52,880 --> 00:21:05,030
be a success of a or a failure of B and

00:20:58,090 --> 00:21:10,040
typescript we generate two interfaces

00:21:05,030 --> 00:21:14,000
that share a common base so success and

00:21:10,040 --> 00:21:16,570
failure success of a failure of B never

00:21:14,000 --> 00:21:20,450
instead of nothing that's the same thing

00:21:16,570 --> 00:21:26,000
and then highlighted in pink is what

00:21:20,450 --> 00:21:31,130
turns it into a union it's a an untagged

00:21:26,000 --> 00:21:35,960
Union but because of seen in two classes

00:21:31,130 --> 00:21:39,620
we can use instance of checks to fold

00:21:35,960 --> 00:21:44,570
over the different possibilities and

00:21:39,620 --> 00:21:47,990
typescript as flow types so if rez is

00:21:44,570 --> 00:21:49,820
instance of success then the res that

00:21:47,990 --> 00:21:53,720
gets passed and to do success has a type

00:21:49,820 --> 00:21:55,220
of success and it's same for do failure

00:21:53,720 --> 00:21:59,000
and by the time you get down to total

00:21:55,220 --> 00:22:04,430
res will have a type of never and so the

00:21:59,000 --> 00:22:09,620
what the total function does is provides

00:22:04,430 --> 00:22:13,130
a compile time check that this this

00:22:09,620 --> 00:22:14,810
fault is indeed total and if something

00:22:13,130 --> 00:22:19,480
weird happens at run time it's going to

00:22:14,810 --> 00:22:19,480
blow up with the inconceivable message

00:22:21,410 --> 00:22:27,480
what we could do to get slightly

00:22:23,580 --> 00:22:30,090
different economics is add a tag to each

00:22:27,480 --> 00:22:33,690
of the classes in this case property

00:22:30,090 --> 00:22:37,260
called dollar sign variant using

00:22:33,690 --> 00:22:40,140
shapeless to create literal types of

00:22:37,260 --> 00:22:41,700
string success and failure and a scale 3

00:22:40,140 --> 00:22:47,240
obviously won't need shapeless to do

00:22:41,700 --> 00:22:49,050
that and then what gets generated is

00:22:47,240 --> 00:22:50,910
pretty much the same as the previous

00:22:49,050 --> 00:22:55,500
slide was the addition of this variant

00:22:50,910 --> 00:22:58,920
fields and a match type called I result

00:22:55,500 --> 00:23:01,860
because we end up indexing on the type

00:22:58,920 --> 00:23:04,020
of variant so success maps to the type

00:23:01,860 --> 00:23:06,780
of success and failure maps to the type

00:23:04,020 --> 00:23:12,600
of failure and then with a little bit of

00:23:06,780 --> 00:23:14,610
extra one time only type definitions we

00:23:12,600 --> 00:23:16,530
can create a function that will fold

00:23:14,610 --> 00:23:19,830
over any union that's been generated

00:23:16,530 --> 00:23:25,860
using this mechanism so first of all we

00:23:19,830 --> 00:23:30,210
define a tag Union as any union of you

00:23:25,860 --> 00:23:34,440
where the the objects of the Union

00:23:30,210 --> 00:23:36,210
contain this variant property and then

00:23:34,440 --> 00:23:39,900
what we're not passing into the fold

00:23:36,210 --> 00:23:43,080
method is this this object Union fault

00:23:39,900 --> 00:23:45,420
cases which is a map type that says for

00:23:43,080 --> 00:23:48,090
every case in the Union we need a

00:23:45,420 --> 00:23:52,559
function from that case to whatever

00:23:48,090 --> 00:23:56,450
we're whatever the result of folders the

00:23:52,559 --> 00:23:59,910
advantage of this over the instance of

00:23:56,450 --> 00:24:04,860
approach is that we get a label for each

00:23:59,910 --> 00:24:06,960
of the cases in our fault when you've

00:24:04,860 --> 00:24:08,520
got many cases it's handy to have labels

00:24:06,960 --> 00:24:10,320
so you you know where you are so we've

00:24:08,520 --> 00:24:17,160
got this label and failure label for

00:24:10,320 --> 00:24:21,210
each of the cases and the fault a third

00:24:17,160 --> 00:24:25,440
possibility which is when I'm finding

00:24:21,210 --> 00:24:28,960
increasingly well I guess better because

00:24:25,440 --> 00:24:33,130
there's less boilerplate and

00:24:28,960 --> 00:24:38,320
yeah is is to create the default cases

00:24:33,130 --> 00:24:42,720
type in Scala instead needs to be

00:24:38,320 --> 00:24:42,720
inherit gesture object so that

00:24:42,780 --> 00:24:46,900
JavaScript semantics apply including the

00:24:45,130 --> 00:24:49,090
ability to pass a nice structurally

00:24:46,900 --> 00:24:53,049
conforming object rather than one that

00:24:49,090 --> 00:24:58,240
has to be nominally typed and what that

00:24:53,049 --> 00:25:00,100
means is that we can call fold without

00:24:58,240 --> 00:25:03,400
having to supply the extra typescript

00:25:00,100 --> 00:25:06,640
stuff that we did in the previous slide

00:25:03,400 --> 00:25:10,890
so you get the same economics without

00:25:06,640 --> 00:25:10,890
the extra types being necessary

00:25:13,559 --> 00:25:18,370
typescript doesn't do higher kind of

00:25:15,789 --> 00:25:20,350
types like this there's an encoding a

00:25:18,370 --> 00:25:24,880
lightweight encoding similar to what Elm

00:25:20,350 --> 00:25:28,090
uses but it's it's pretty awful

00:25:24,880 --> 00:25:30,220
so if we have amps abstraction on the

00:25:28,090 --> 00:25:32,110
scholar side which takes a higher kind

00:25:30,220 --> 00:25:34,600
of type and we want to use it on the

00:25:32,110 --> 00:25:35,980
typescript side we need to kind of fill

00:25:34,600 --> 00:25:40,330
in the hole

00:25:35,980 --> 00:25:44,530
so if we have a type alias then that

00:25:40,330 --> 00:25:48,039
gets turned into a a a filled in

00:25:44,530 --> 00:25:53,650
interface on the typescript side so in

00:25:48,039 --> 00:25:59,830
this case abstraction of array we get

00:25:53,650 --> 00:26:07,600
the an instance that's populated with

00:25:59,830 --> 00:26:11,500
array as if final things are largely

00:26:07,600 --> 00:26:13,659
going to be obsoleted by scala 3 using

00:26:11,500 --> 00:26:18,490
the aesthetic Oh scalar new type package

00:26:13,659 --> 00:26:26,320
we can create new types on the scale

00:26:18,490 --> 00:26:28,960
side and they generate a tag type on the

00:26:26,320 --> 00:26:32,350
typescript side so here there's a fully

00:26:28,960 --> 00:26:38,130
qualified string literal type which is

00:26:32,350 --> 00:26:40,960
used as key there's a tag m in this case

00:26:38,130 --> 00:26:42,440
well on the scalar side where we're

00:26:40,960 --> 00:26:45,940
creating a new type of strengths

00:26:42,440 --> 00:26:49,700
on the typescript site we have a string

00:26:45,940 --> 00:26:54,890
intersected with a tight tag of the type

00:26:49,700 --> 00:26:56,900
of key the intersection is something

00:26:54,890 --> 00:27:01,580
that exists only at the type level so at

00:26:56,900 --> 00:27:03,590
runtime we've got a string but at type

00:27:01,580 --> 00:27:09,620
check time we have a string intersected

00:27:03,590 --> 00:27:14,150
with this unique tag that means that the

00:27:09,620 --> 00:27:18,580
only way to create a value of that type

00:27:14,150 --> 00:27:21,110
is with this tag method unless you're

00:27:18,580 --> 00:27:29,360
you're being deliberately nefarious and

00:27:21,110 --> 00:27:30,920
you've cast to the tech type to create a

00:27:29,360 --> 00:27:32,870
refinement instead of supplying

00:27:30,920 --> 00:27:37,330
something that simply tags you want to

00:27:32,870 --> 00:27:39,740
supply something that chicks and tags

00:27:37,330 --> 00:27:41,300
ideally you'd return an either there

00:27:39,740 --> 00:27:44,150
wasn't enough room on the slide so I'm

00:27:41,300 --> 00:27:50,030
just gonna throw if you want to make it

00:27:44,150 --> 00:27:53,480
opaque you switch new subtype for new

00:27:50,030 --> 00:27:57,260
type on the scale side and string for

00:27:53,480 --> 00:27:59,420
void on the typescript side void has no

00:27:57,260 --> 00:28:02,630
methods on it so the only thing you can

00:27:59,420 --> 00:28:05,960
do with the value of this void

00:28:02,630 --> 00:28:07,700
intersected with the tag is whatever

00:28:05,960 --> 00:28:09,500
methods you've supplied on the scala

00:28:07,700 --> 00:28:11,930
side in this case the only method is

00:28:09,500 --> 00:28:13,250
make all throw so we've kind of had a

00:28:11,930 --> 00:28:23,110
lot but we could have added something

00:28:13,250 --> 00:28:27,340
else on like concatenate you can do

00:28:23,110 --> 00:28:33,680
intersections sorry unions of literals

00:28:27,340 --> 00:28:35,930
it's pretty awful I pretty eager to see

00:28:33,680 --> 00:28:37,340
it go away and I think scale will make

00:28:35,930 --> 00:28:39,200
that possible

00:28:37,340 --> 00:28:41,510
at the moment it's kind of there because

00:28:39,200 --> 00:28:45,740
we need to use it internally as you can

00:28:41,510 --> 00:28:50,970
see it relies on some annotations which

00:28:45,740 --> 00:28:55,289
is kind of yak-1 problem we

00:28:50,970 --> 00:28:57,780
coming across was needing to pass types

00:28:55,289 --> 00:29:03,929
like either across from Scala to

00:28:57,780 --> 00:29:09,570
typescript and because Scala jeaious

00:29:03,929 --> 00:29:12,179
only emits JavaScript methods and things

00:29:09,570 --> 00:29:13,590
four types that have been annotated you

00:29:12,179 --> 00:29:17,100
don't get it for something like either

00:29:13,590 --> 00:29:18,809
so it's it's tempting and we tried

00:29:17,100 --> 00:29:22,919
initially to implement something like

00:29:18,809 --> 00:29:25,169
either on the scaligeri side so that we

00:29:22,919 --> 00:29:27,990
could use it in Scala and also in

00:29:25,169 --> 00:29:29,400
typescript but eventually came to the

00:29:27,990 --> 00:29:32,190
realization that it seems to work better

00:29:29,400 --> 00:29:34,789
if we implement either in typescript

00:29:32,190 --> 00:29:36,929
because we get typescript semantics

00:29:34,789 --> 00:29:40,200
typescript syntax just seems to work

00:29:36,929 --> 00:29:43,440
better with the rest of the app and

00:29:40,200 --> 00:29:48,539
instead from scale jeaious to just

00:29:43,440 --> 00:29:50,190
export this really simple either like

00:29:48,539 --> 00:29:53,700
object which just contains the fault

00:29:50,190 --> 00:29:57,990
method and then at the used site and

00:29:53,700 --> 00:30:03,960
typescript ninis rabbit with the either

00:29:57,990 --> 00:30:06,120
type we've implemented in typescript so

00:30:03,960 --> 00:30:10,140
we've got automatically generated from

00:30:06,120 --> 00:30:16,250
the skeletons traits classes objects

00:30:10,140 --> 00:30:19,440
unions and new types with a few caveats

00:30:16,250 --> 00:30:22,010
everything's read-only so if you want to

00:30:19,440 --> 00:30:26,039
take something you create a method that

00:30:22,010 --> 00:30:28,400
takes the new value in and do that in

00:30:26,039 --> 00:30:28,400
Scala

00:30:29,270 --> 00:30:34,080
everything's unconstrained there are no

00:30:31,500 --> 00:30:35,070
generic types of constraints yet but I

00:30:34,080 --> 00:30:37,909
think they'll be too difficult to

00:30:35,070 --> 00:30:42,620
implement at least simple ones but

00:30:37,909 --> 00:30:48,260
hasn't been necessary and there's no

00:30:42,620 --> 00:30:50,309
variants because typescript is

00:30:48,260 --> 00:30:51,630
structurally subtype that kind of does

00:30:50,309 --> 00:30:53,940
the variance thing without needing

00:30:51,630 --> 00:30:57,630
annotations but we haven't really

00:30:53,940 --> 00:31:01,610
explored how that would work between

00:30:57,630 --> 00:31:01,610
scale jeaious and typescript

00:31:03,500 --> 00:31:14,070
when would you want to use this if you

00:31:11,450 --> 00:31:17,760
can do everything in scale jeaious

00:31:14,070 --> 00:31:20,490
then do that if you don't need to

00:31:17,760 --> 00:31:22,500
consume scale J's from from JavaScript

00:31:20,490 --> 00:31:25,440
then by all means don't that's probably

00:31:22,500 --> 00:31:27,660
the best thing but if you need to

00:31:25,440 --> 00:31:30,770
consume Scala J's from typescript fro

00:31:27,660 --> 00:31:33,870
sorry need to consume Scala GS from

00:31:30,770 --> 00:31:35,220
JavaScript then that's where this comes

00:31:33,870 --> 00:31:39,500
in really useful because you get types

00:31:35,220 --> 00:31:41,669
if you want to consume JavaScript from

00:31:39,500 --> 00:31:45,480
Scala jeaious then you're gonna have to

00:31:41,669 --> 00:31:50,340
use something else and here are some

00:31:45,480 --> 00:31:54,990
possibilities for the skeleton

00:31:50,340 --> 00:31:58,350
typescript direction there's an existing

00:31:54,990 --> 00:31:59,340
project Scala TSI which takes quite a

00:31:58,350 --> 00:32:02,850
different approach it's worth checking

00:31:59,340 --> 00:32:04,770
out and for the opposite direction

00:32:02,850 --> 00:32:09,380
there's Sebastian's scale J's tier

00:32:04,770 --> 00:32:09,380
symporter and this other project as well

00:32:12,350 --> 00:32:18,090
winds are going to be available the

00:32:16,320 --> 00:32:20,700
answer is I don't know this is kind of

00:32:18,090 --> 00:32:22,200
part experience report as as well as

00:32:20,700 --> 00:32:24,480
going through how we did it the current

00:32:22,200 --> 00:32:29,580
implementation is a proof of concept as

00:32:24,480 --> 00:32:31,169
an SPT plugin in the future I think it

00:32:29,580 --> 00:32:33,809
would be worthwhile investigating

00:32:31,169 --> 00:32:36,150
integrating something like this into

00:32:33,809 --> 00:32:38,640
scale jeaious so as a flag or as a

00:32:36,150 --> 00:32:42,750
default you would just get types as well

00:32:38,640 --> 00:32:46,980
as JavaScript at the end and at some

00:32:42,750 --> 00:32:49,500
stage I'm looking forward to seeing how

00:32:46,980 --> 00:32:52,110
the changes that have come with scale

00:32:49,500 --> 00:32:54,059
three are going to influence what we do

00:32:52,110 --> 00:33:01,730
particularly literal types and an take

00:32:54,059 --> 00:33:01,730
unions that's it

00:33:02,700 --> 00:33:18,580
question time so you just mentioned its

00:33:15,879 --> 00:33:21,119
oriented you would see something like

00:33:18,580 --> 00:33:24,220
that integrated in size colleges what

00:33:21,119 --> 00:33:27,309
would benefit to you foresee from from

00:33:24,220 --> 00:33:32,159
that integration versus an external to

00:33:27,309 --> 00:33:32,159
all that can evolve in more freely

00:33:34,080 --> 00:33:40,690
expertise access to expertise perhaps at

00:33:37,479 --> 00:33:43,889
the moment what we've got as a result of

00:33:40,690 --> 00:33:47,769
me largely kind of figuring out how

00:33:43,889 --> 00:33:51,369
scholars type introspection stuff works

00:33:47,769 --> 00:33:54,190
on the fly so it's pretty ugly

00:33:51,369 --> 00:33:55,690
I guess initially I'd like to look at

00:33:54,190 --> 00:33:56,979
the internals of scale jeaious and see

00:33:55,690 --> 00:34:01,210
how that works because it'll probably

00:33:56,979 --> 00:34:04,450
help my implementation but also the

00:34:01,210 --> 00:34:06,970
possibility of having everything kind of

00:34:04,450 --> 00:34:12,010
generated in one pass without having to

00:34:06,970 --> 00:34:17,409
match things up yeah I have bad news for

00:34:12,010 --> 00:34:19,750
that because I mean so for your first

00:34:17,409 --> 00:34:23,619
expectation scholar jeaious works on the

00:34:19,750 --> 00:34:27,040
arrays two types anyway so everything

00:34:23,619 --> 00:34:33,609
type parameters you wouldn't get in any

00:34:27,040 --> 00:34:35,710
reasonable way and so that feeds into

00:34:33,609 --> 00:34:37,899
your second expectation which is you

00:34:35,710 --> 00:34:40,210
could do it in one pass well not really

00:34:37,899 --> 00:34:44,679
right you would have to do it in two I

00:34:40,210 --> 00:34:48,040
mean two passes anyway so then tasty is

00:34:44,679 --> 00:34:55,929
probably a more interesting future

00:34:48,040 --> 00:34:58,210
prospect these tears tasty solves

00:34:55,929 --> 00:35:03,099
problems but nothing related to scholar

00:34:58,210 --> 00:35:05,540
J's so really the compiler plugin or the

00:35:03,099 --> 00:35:08,400
discolor meta based

00:35:05,540 --> 00:35:11,099
so with the other the Campari plug-in

00:35:08,400 --> 00:35:12,930
would be your one pass thing because you

00:35:11,099 --> 00:35:16,550
would inject a face somewhere window in

00:35:12,930 --> 00:35:19,950
the beginning of the compiler right but

00:35:16,550 --> 00:35:23,820
otherwise like none of the none of the

00:35:19,950 --> 00:35:27,180
other things is going to really help you

00:35:23,820 --> 00:35:28,740
there okay so stick with an external

00:35:27,180 --> 00:35:30,930
library that we can use to race potato

00:35:28,740 --> 00:35:40,830
or a compiler plugin yeah tonight

00:35:30,930 --> 00:35:45,570
yeah so if I'm a typescript programmer

00:35:40,830 --> 00:35:48,980
and Scala gives me a doc can I actually

00:35:45,570 --> 00:35:53,460
use the field that's used as a tag and

00:35:48,980 --> 00:35:55,760
that has type never know would be a lie

00:35:53,460 --> 00:36:02,280
right no it's not

00:35:55,760 --> 00:36:07,260
but you can certainly try but the the

00:36:02,280 --> 00:36:10,260
reason that I had it as a string kate

00:36:07,260 --> 00:36:12,300
feel starting with the @ symbol is kind

00:36:10,260 --> 00:36:15,630
of like it's not gonna just

00:36:12,300 --> 00:36:18,210
automatically autocomplete for you stay

00:36:15,630 --> 00:36:21,930
away don't use this yeah yeah this is

00:36:18,210 --> 00:36:24,210
fairly common idiom fair enough well

00:36:21,930 --> 00:36:26,220
maybe you could do something that even

00:36:24,210 --> 00:36:28,320
if used doesn't lead to and soundness

00:36:26,220 --> 00:36:31,410
right like make up a type that's not

00:36:28,320 --> 00:36:36,150
usable yeah you could probably make it

00:36:31,410 --> 00:36:40,320
private mm-hmm and then you're not gonna

00:36:36,150 --> 00:36:43,640
be able to use it or cast to it unless

00:36:40,320 --> 00:36:43,640
you really really try

00:36:51,380 --> 00:37:01,430
anyone well thank you very much

00:36:56,700 --> 00:37:05,670
I guess I have another question

00:37:01,430 --> 00:37:06,960
so I mean you by defaults the classes

00:37:05,670 --> 00:37:08,970
that you write in scholar J's are not

00:37:06,960 --> 00:37:11,910
even visible to JavaScript to begin with

00:37:08,970 --> 00:37:16,340
so I I guess it was annotation that

00:37:11,910 --> 00:37:19,800
generates or tied to to chase export its

00:37:16,340 --> 00:37:21,210
numbers or things like that or yes we're

00:37:19,800 --> 00:37:22,850
gonna do something else

00:37:21,210 --> 00:37:26,070
yeah no it's it's taught to the

00:37:22,850 --> 00:37:30,930
scaligeri annotations which I neglected

00:37:26,070 --> 00:37:35,280
to include know that okay yeah yes yeah

00:37:30,930 --> 00:37:38,880
we have some some macro annotations to

00:37:35,280 --> 00:37:40,740
generate some of the scale jeaious

00:37:38,880 --> 00:37:51,840
annotations but that's kind of

00:37:40,740 --> 00:38:02,210
irrelevant yeah it's all done

00:37:51,840 --> 00:38:02,210

YouTube URL: https://www.youtube.com/watch?v=KTiU6SglU4s


