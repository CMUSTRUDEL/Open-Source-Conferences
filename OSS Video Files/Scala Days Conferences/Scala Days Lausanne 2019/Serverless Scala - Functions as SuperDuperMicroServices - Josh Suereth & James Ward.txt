Title: Serverless Scala - Functions as SuperDuperMicroServices - Josh Suereth & James Ward
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/serverless-scala---functions-as-superdupermicroservices
Captions: 
	00:00:00,280 --> 00:00:04,149
[Music]

00:00:05,890 --> 00:00:09,139
all right welcome everyone thanks for

00:00:08,270 --> 00:00:12,139
coming

00:00:09,139 --> 00:00:15,889
this is serverless Scala functions as

00:00:12,139 --> 00:00:19,850
super duper micro-services right yeah he

00:00:15,889 --> 00:00:22,100
co services nano nano services or bi

00:00:19,850 --> 00:00:24,350
services CI services there we go yeah

00:00:22,100 --> 00:00:27,470
I'm James Ward a developer advocate on

00:00:24,350 --> 00:00:29,570
Google cloud and I'm a Josh threat I'm

00:00:27,470 --> 00:00:34,160
an engineer at Google and I do stuff

00:00:29,570 --> 00:00:36,829
with Scala cool so let's dive in so one

00:00:34,160 --> 00:00:41,300
started talking about serverless what is

00:00:36,829 --> 00:00:42,350
serverless so my simple definition of

00:00:41,300 --> 00:00:44,180
what serverless

00:00:42,350 --> 00:00:48,500
is is that you pay for what you use

00:00:44,180 --> 00:00:50,630
managed hosting so well we'll talk more

00:00:48,500 --> 00:00:52,630
about pull that apart in just a second

00:00:50,630 --> 00:00:55,460
but a few ways that you might have

00:00:52,630 --> 00:00:56,870
interacted with serverless is one

00:00:55,460 --> 00:00:59,870
through what's called function as a

00:00:56,870 --> 00:01:02,270
service and this is where you deploy a

00:00:59,870 --> 00:01:04,339
function and it is serverless so you

00:01:02,270 --> 00:01:06,619
only pay for it when it's being used and

00:01:04,339 --> 00:01:07,700
it's in a managed environment so you

00:01:06,619 --> 00:01:10,189
don't have to deal with any

00:01:07,700 --> 00:01:12,229
infrastructure and then the other place

00:01:10,189 --> 00:01:15,259
where you might encounter serverless is

00:01:12,229 --> 00:01:17,600
and when you want to deploy not just a

00:01:15,259 --> 00:01:20,119
function but an entire application and

00:01:17,600 --> 00:01:22,490
this allows you to have multiple

00:01:20,119 --> 00:01:24,560
functions together obviously in a single

00:01:22,490 --> 00:01:27,159
package so it was serverless

00:01:24,560 --> 00:01:29,149
when we say you pay for what you use

00:01:27,159 --> 00:01:31,909
what that means is that there's usually

00:01:29,149 --> 00:01:34,819
like some way to charge based on number

00:01:31,909 --> 00:01:38,359
of requests or amount of processing time

00:01:34,819 --> 00:01:40,670
so if you know where there is multiple

00:01:38,359 --> 00:01:42,859
instances or multiple requests being

00:01:40,670 --> 00:01:44,509
handled by a single instance then you

00:01:42,859 --> 00:01:46,459
may only have to pay for the CPU time

00:01:44,509 --> 00:01:49,279
that those requests are being handled

00:01:46,459 --> 00:01:51,139
and not double pay that sort of thing so

00:01:49,279 --> 00:01:53,179
this means that if you're not using it

00:01:51,139 --> 00:01:56,240
you don't pay that's great and then as

00:01:53,179 --> 00:01:58,130
you use it more you pay more and then

00:01:56,240 --> 00:02:00,020
managed means that you don't have to

00:01:58,130 --> 00:02:02,289
worry about patching underlying

00:02:00,020 --> 00:02:04,130
operating systems or dealing with

00:02:02,289 --> 00:02:06,649
distributing an application across

00:02:04,130 --> 00:02:08,630
multiple servers and data centers and

00:02:06,649 --> 00:02:10,790
redundancy and restarting processes when

00:02:08,630 --> 00:02:13,040
they die that all that stuff is just

00:02:10,790 --> 00:02:13,890
managed for you and so that you don't

00:02:13,040 --> 00:02:16,890
have to think about

00:02:13,890 --> 00:02:18,480
or like pre allocating for spikes if you

00:02:16,890 --> 00:02:20,160
expect a traffic spike at a particular

00:02:18,480 --> 00:02:21,570
time and you want to make sure you have

00:02:20,160 --> 00:02:22,650
enough server load that's not your

00:02:21,570 --> 00:02:24,480
responsibility more that's

00:02:22,650 --> 00:02:27,030
responsibility your provider yeah yeah

00:02:24,480 --> 00:02:29,040
so in some ways it's just a new buzzword

00:02:27,030 --> 00:02:31,590
for some things that have been around

00:02:29,040 --> 00:02:34,020
for a while but I think really the the

00:02:31,590 --> 00:02:36,540
the kind of new nugget is that around

00:02:34,020 --> 00:02:39,270
serverless is that the scale the idea of

00:02:36,540 --> 00:02:40,770
scaling to zero so we've we've had this

00:02:39,270 --> 00:02:42,660
we've been trying to march towards

00:02:40,770 --> 00:02:45,410
utility computing only paying for what

00:02:42,660 --> 00:02:47,900
we use but it turned out that the the

00:02:45,410 --> 00:02:50,340
granularity of that pay for what you use

00:02:47,900 --> 00:02:52,590
allowed us to have a lot of unused

00:02:50,340 --> 00:02:54,870
resources that we were paying for and so

00:02:52,590 --> 00:02:57,840
with serverless not thinking about

00:02:54,870 --> 00:03:00,800
servers and instances we really only pay

00:02:57,840 --> 00:03:02,820
for what we use and it can scale to zero

00:03:00,800 --> 00:03:03,570
so often times when we talk about

00:03:02,820 --> 00:03:06,239
serverless

00:03:03,570 --> 00:03:08,010
we also talk about containers and so

00:03:06,239 --> 00:03:11,330
this is like docker containers or the

00:03:08,010 --> 00:03:13,830
new open container initiative and so

00:03:11,330 --> 00:03:15,720
containers can be an important piece in

00:03:13,830 --> 00:03:17,130
this we're gonna be using today so we'll

00:03:15,720 --> 00:03:19,860
give you just a brief overview of what

00:03:17,130 --> 00:03:23,190
containers are so essentially they're

00:03:19,860 --> 00:03:25,799
zip files and so you take a zip file

00:03:23,190 --> 00:03:27,870
kind of a zip file and you put some

00:03:25,799 --> 00:03:30,390
stuff into it and what you put into it

00:03:27,870 --> 00:03:32,580
is like a mini operating system and

00:03:30,390 --> 00:03:34,500
there's lots and lots of different base

00:03:32,580 --> 00:03:36,870
operating systems that you can use for

00:03:34,500 --> 00:03:39,239
this there's alpine linux is popular you

00:03:36,870 --> 00:03:40,380
can use your standard Ubuntu lots of

00:03:39,239 --> 00:03:41,670
different options there so you put your

00:03:40,380 --> 00:03:43,620
like mini operating system into your

00:03:41,670 --> 00:03:45,720
container and then you also put your

00:03:43,620 --> 00:03:48,120
application and any dependencies that it

00:03:45,720 --> 00:03:51,720
needs to run inside of that zip file as

00:03:48,120 --> 00:03:53,730
well and then the container has a start

00:03:51,720 --> 00:03:55,440
up command so that then when something

00:03:53,730 --> 00:03:56,820
runs this container it knows how to

00:03:55,440 --> 00:03:59,820
actually start the process that you want

00:03:56,820 --> 00:04:01,890
to start to startup your application so

00:03:59,820 --> 00:04:04,769
that's that's the basics of a container

00:04:01,890 --> 00:04:05,910
so at Google what we're going to be

00:04:04,769 --> 00:04:07,530
using today is something called cloud

00:04:05,910 --> 00:04:09,120
run which is serverless

00:04:07,530 --> 00:04:11,340
for containers so you take your

00:04:09,120 --> 00:04:14,970
containers and you upload them to Google

00:04:11,340 --> 00:04:17,160
cloud for cloud run and then we will run

00:04:14,970 --> 00:04:20,220
those server lessly so let me give you a

00:04:17,160 --> 00:04:23,430
quick little demonstration of that so I

00:04:20,220 --> 00:04:25,050
have a repo here on github and this is

00:04:23,430 --> 00:04:27,120
that as simple as things could possibly

00:04:25,050 --> 00:04:29,220
get so I'll show you the the docker

00:04:27,120 --> 00:04:32,040
file here what we do is we're gonna

00:04:29,220 --> 00:04:35,790
start with the alpine Linux distribution

00:04:32,040 --> 00:04:38,490
based image and then our command that

00:04:35,790 --> 00:04:40,830
we're gonna run to start our process is

00:04:38,490 --> 00:04:43,110
actually using netcat and so this is

00:04:40,830 --> 00:04:46,110
actually I think about the shortest web

00:04:43,110 --> 00:04:49,350
server you could possibly write so this

00:04:46,110 --> 00:04:51,449
is handling requests on port whatever is

00:04:49,350 --> 00:04:53,160
defined by the environment variable port

00:04:51,449 --> 00:04:56,280
and then it's gonna respond with hello

00:04:53,160 --> 00:04:58,290
world so let's go launch this thing on

00:04:56,280 --> 00:05:00,870
cloud run so I'm gonna click this little

00:04:58,290 --> 00:05:03,060
button and it's gonna verify that yes I

00:05:00,870 --> 00:05:05,910
in fact do you want to clone that github

00:05:03,060 --> 00:05:08,370
repo and I do want to deploy that on

00:05:05,910 --> 00:05:09,539
cloud run so what it's going to do is

00:05:08,370 --> 00:05:12,150
it's going to walk through a few steps

00:05:09,539 --> 00:05:15,180
it's going to run the docker build on

00:05:12,150 --> 00:05:17,520
that that github repo which will

00:05:15,180 --> 00:05:19,139
assemble the docker container and it's

00:05:17,520 --> 00:05:21,150
going to ask me here in a second where

00:05:19,139 --> 00:05:24,660
what project I want to use so I'll just

00:05:21,150 --> 00:05:26,880
hit yes for my JW demo project so now

00:05:24,660 --> 00:05:28,830
it's building the container storing the

00:05:26,880 --> 00:05:31,680
container image up on the Google

00:05:28,830 --> 00:05:33,539
container registry and then it's going

00:05:31,680 --> 00:05:37,050
to use cloud run to deploy that

00:05:33,539 --> 00:05:39,000
application up on the club so it should

00:05:37,050 --> 00:05:41,099
just take a second here to deploy that

00:05:39,000 --> 00:05:48,229
service and then we'll be able to go

00:05:41,099 --> 00:05:52,169
check it out so let's go Google go cloud

00:05:48,229 --> 00:05:54,030
how can you wait on Google I mean all

00:05:52,169 --> 00:05:56,660
the time but yeah I also wait on myself

00:05:54,030 --> 00:05:59,039
that's usually I'm the bottleneck but

00:05:56,660 --> 00:06:01,979
okay alright there we go we're up and

00:05:59,039 --> 00:06:04,199
running so now you'll see we got an HTTP

00:06:01,979 --> 00:06:06,300
endpoint and service is unavailable

00:06:04,199 --> 00:06:09,300
let's give it one more try there we go

00:06:06,300 --> 00:06:11,130
hello world so we just took that that

00:06:09,300 --> 00:06:13,740
container that we built deployed it and

00:06:11,130 --> 00:06:16,320
now it's running and Google will scale

00:06:13,740 --> 00:06:18,930
this to as many requests as we want to

00:06:16,320 --> 00:06:21,000
throw out the thing and so it'll handle

00:06:18,930 --> 00:06:23,789
all those requests and there we go we're

00:06:21,000 --> 00:06:28,440
running up on the cloud so that's our

00:06:23,789 --> 00:06:31,590
really basic intro thereto to cloud run

00:06:28,440 --> 00:06:34,800
and containers and serverless cloud run

00:06:31,590 --> 00:06:36,780
is a managed service so so we manage

00:06:34,800 --> 00:06:38,219
everything for you at Google but if you

00:06:36,780 --> 00:06:39,020
want to do everything on your own

00:06:38,219 --> 00:06:41,240
there's

00:06:39,020 --> 00:06:43,039
project the cloud run is based on an

00:06:41,240 --> 00:06:44,690
open-source project called K native

00:06:43,039 --> 00:06:47,509
which gives you the same functionality

00:06:44,690 --> 00:06:49,819
on top of kubernetes so you don't have

00:06:47,509 --> 00:06:52,370
to use us you can use K native on your

00:06:49,819 --> 00:06:53,810
own someone talked about cold starts

00:06:52,370 --> 00:06:55,610
real quick because this is something

00:06:53,810 --> 00:06:58,490
that comes up very quickly as you get

00:06:55,610 --> 00:07:00,830
into server less so what a cold start is

00:06:58,490 --> 00:07:03,349
is it's really a problem of being able

00:07:00,830 --> 00:07:04,810
to scale down the resources typically

00:07:03,349 --> 00:07:07,400
what we do in computing is that we

00:07:04,810 --> 00:07:09,650
over-provision our resources our servers

00:07:07,400 --> 00:07:12,830
so that we can handle spikes and things

00:07:09,650 --> 00:07:15,169
and as a service provider even if you're

00:07:12,830 --> 00:07:16,880
running your own stuff you probably want

00:07:15,169 --> 00:07:18,800
to be able to throttle down those

00:07:16,880 --> 00:07:20,300
resources and not over-provision them

00:07:18,800 --> 00:07:22,099
because if you're over provisioning them

00:07:20,300 --> 00:07:24,289
then you're not paying for what you use

00:07:22,099 --> 00:07:26,960
you're paying for things beyond what you

00:07:24,289 --> 00:07:29,150
use and so what happens with server

00:07:26,960 --> 00:07:30,469
lists is that things are scaled down so

00:07:29,150 --> 00:07:32,060
that you're only paying for them when

00:07:30,469 --> 00:07:33,800
you're using them but then there's some

00:07:32,060 --> 00:07:36,440
amount of time that it takes to scale

00:07:33,800 --> 00:07:38,150
things back up to start up the processes

00:07:36,440 --> 00:07:40,430
pull the containers out of the registry

00:07:38,150 --> 00:07:43,819
start up the processes warm those

00:07:40,430 --> 00:07:45,889
processes up and so what happens is if a

00:07:43,819 --> 00:07:48,110
request comes in and it has to go

00:07:45,889 --> 00:07:51,650
through this startup process then that's

00:07:48,110 --> 00:07:53,870
called a cold start and and it can can

00:07:51,650 --> 00:07:55,849
be a bad experience for users if they're

00:07:53,870 --> 00:07:58,669
sitting around waiting for large

00:07:55,849 --> 00:08:00,259
applications to start up so it's

00:07:58,669 --> 00:08:02,270
definitely a challenge in the the

00:08:00,259 --> 00:08:04,580
serverless world and one of the ways

00:08:02,270 --> 00:08:07,099
that we can deal with this particularly

00:08:04,580 --> 00:08:10,009
with with the application that we built

00:08:07,099 --> 00:08:11,949
with JVM applications is to use Graul so

00:08:10,009 --> 00:08:15,440
crawl it does ahead-of-time compilation

00:08:11,949 --> 00:08:17,659
so it takes our our Scala application

00:08:15,440 --> 00:08:19,340
that we're going to show you and it a

00:08:17,659 --> 00:08:21,199
head of time compiles that down into a

00:08:19,340 --> 00:08:23,810
native image which is much smaller and

00:08:21,199 --> 00:08:25,520
much faster to startup yes so you might

00:08:23,810 --> 00:08:27,620
be asking yourself like why am i doing

00:08:25,520 --> 00:08:29,330
ahead of time compilation if maybe like

00:08:27,620 --> 00:08:31,490
you know we've invested so much in the

00:08:29,330 --> 00:08:33,919
JIT so much in this runtime optimization

00:08:31,490 --> 00:08:35,209
so much like in the JVM and Java but

00:08:33,919 --> 00:08:37,610
really you need to think of it as a

00:08:35,209 --> 00:08:40,399
trade-off right I'm trading consistency

00:08:37,610 --> 00:08:42,140
in my art BC response latency in terms

00:08:40,399 --> 00:08:44,300
of startup time for these services and

00:08:42,140 --> 00:08:46,520
the throughput right I'm trying to trade

00:08:44,300 --> 00:08:48,199
consistency for optimal speed so I might

00:08:46,520 --> 00:08:50,180
not be able to make this one server

00:08:48,199 --> 00:08:51,830
completely optimal but I might be able

00:08:50,180 --> 00:08:54,020
to get a better through

00:08:51,830 --> 00:08:55,940
organization across the machines that

00:08:54,020 --> 00:08:58,190
I'm making use of under the covers by

00:08:55,940 --> 00:08:59,720
having more consistency it's easier to

00:08:58,190 --> 00:09:01,760
kind of understand load it's easier to

00:08:59,720 --> 00:09:03,110
kind of understand how long it takes to

00:09:01,760 --> 00:09:05,150
bring one of these services up and

00:09:03,110 --> 00:09:07,070
handle you know incoming traffic so

00:09:05,150 --> 00:09:09,230
you're making that trade-off and it's

00:09:07,070 --> 00:09:11,660
it's not like a zero-sum game right so

00:09:09,230 --> 00:09:13,070
sometimes you want the JVM sometimes you

00:09:11,660 --> 00:09:14,960
don't and this is one of the things

00:09:13,070 --> 00:09:16,310
where server lists kind of lets you go

00:09:14,960 --> 00:09:19,790
the other way and kind of reap those

00:09:16,310 --> 00:09:22,250
benefits yep yeah exactly yeah so that's

00:09:19,790 --> 00:09:23,770
that's one way to work on addressing the

00:09:22,250 --> 00:09:25,610
cold start issues

00:09:23,770 --> 00:09:27,830
okay so we've learned a bit about

00:09:25,610 --> 00:09:29,210
serverless and now we're gonna take a

00:09:27,830 --> 00:09:33,200
step to the other side and talked about

00:09:29,210 --> 00:09:35,720
building server apps so I've done a lot

00:09:33,200 --> 00:09:38,030
of play framework development in in my

00:09:35,720 --> 00:09:40,340
days and I love probably play fair

00:09:38,030 --> 00:09:42,620
markets a great framework and the the

00:09:40,340 --> 00:09:44,600
way that you handle requests in play is

00:09:42,620 --> 00:09:46,550
really simple you create this action

00:09:44,600 --> 00:09:49,130
which is really just a wrapper around a

00:09:46,550 --> 00:09:51,950
function that goes from a request to a

00:09:49,130 --> 00:09:54,470
response or a future of response it's a

00:09:51,950 --> 00:09:56,750
really nice API is that is that supposed

00:09:54,470 --> 00:09:58,460
to be a covers those are cut those are

00:09:56,750 --> 00:09:59,660
solid cover those are Scala cover I mean

00:09:58,460 --> 00:10:03,110
that's what I have on my bed at home

00:09:59,660 --> 00:10:05,180
that's that's look like I'm sure yeah

00:10:03,110 --> 00:10:07,850
but underneath those are all of these

00:10:05,180 --> 00:10:09,380
things that were hiding right so so

00:10:07,850 --> 00:10:11,780
under there I'm hiding access to my

00:10:09,380 --> 00:10:13,880
database I'm hiding just the the general

00:10:11,780 --> 00:10:16,790
serialization mechanism I used to go in

00:10:13,880 --> 00:10:18,020
and out of HTTP and all of that is

00:10:16,790 --> 00:10:19,970
actually kind of encoded in this

00:10:18,020 --> 00:10:21,590
function and I'm actually locked to it

00:10:19,970 --> 00:10:23,720
to some extent yeah it's in the class

00:10:21,590 --> 00:10:26,450
that you extend and comes in through

00:10:23,720 --> 00:10:28,100
injection but yeah there's a lot of a

00:10:26,450 --> 00:10:31,100
lot of stuff that's actually needed to

00:10:28,100 --> 00:10:33,800
be able to handle a request and it's as

00:10:31,100 --> 00:10:35,450
you said lurking under your covers likes

00:10:33,800 --> 00:10:39,050
it it's not something that you see in

00:10:35,450 --> 00:10:41,840
the function definition so it can be a

00:10:39,050 --> 00:10:43,700
little tricky sometimes to to test these

00:10:41,840 --> 00:10:45,350
things because they're functions that

00:10:43,700 --> 00:10:47,240
don't really work independently they

00:10:45,350 --> 00:10:50,000
need all of that context around them in

00:10:47,240 --> 00:10:51,470
order to work and this is where you see

00:10:50,000 --> 00:10:52,820
it is when you start writing tests right

00:10:51,470 --> 00:10:55,250
when I write tests I have to kind of

00:10:52,820 --> 00:10:56,960
step out these functions and for some of

00:10:55,250 --> 00:10:59,390
these applications they have to give you

00:10:56,960 --> 00:11:01,880
the affordance this hook to be able to

00:10:59,390 --> 00:11:03,560
override that behavior in a tests so

00:11:01,880 --> 00:11:05,690
that you can stub out some production

00:11:03,560 --> 00:11:07,880
service so I can run a local

00:11:05,690 --> 00:11:09,920
instance of it right I have this thing

00:11:07,880 --> 00:11:11,030
I'm talking to like a database but I

00:11:09,920 --> 00:11:12,500
don't really want to talk to a real

00:11:11,030 --> 00:11:13,880
database in my test but I want to talk

00:11:12,500 --> 00:11:15,590
to something close enough that I can

00:11:13,880 --> 00:11:18,470
make sure I'm doing the right thing you

00:11:15,590 --> 00:11:20,780
know and how do i plug in a testable

00:11:18,470 --> 00:11:22,160
component and make that work right all

00:11:20,780 --> 00:11:24,410
these frameworks basically provide you

00:11:22,160 --> 00:11:25,850
an API and then oh we have to do this

00:11:24,410 --> 00:11:27,710
security thing well let me provide you

00:11:25,850 --> 00:11:29,600
an API to test that you know and you

00:11:27,710 --> 00:11:32,660
keep you're constantly doing this battle

00:11:29,600 --> 00:11:35,480
yeah and it could be you can really bind

00:11:32,660 --> 00:11:37,370
your logic to the actual protocol that

00:11:35,480 --> 00:11:39,230
you're implementing in this way so

00:11:37,370 --> 00:11:42,260
that's that's one of the things that I

00:11:39,230 --> 00:11:43,820
found with play it's so easy but if I if

00:11:42,260 --> 00:11:45,440
my protocol changed or I wanted to

00:11:43,820 --> 00:11:47,660
implement a different protocol I had to

00:11:45,440 --> 00:11:54,050
do a lot of refactoring in order to be

00:11:47,660 --> 00:11:55,700
able to support that okay so so the the

00:11:54,050 --> 00:11:57,920
environment is effectively changing

00:11:55,700 --> 00:11:59,900
though as time goes on right instead of

00:11:57,920 --> 00:12:01,400
deploying like servers or the old j2ee

00:11:59,900 --> 00:12:02,930
model where I throw like a war somewhere

00:12:01,400 --> 00:12:04,880
and there's this big server that handles

00:12:02,930 --> 00:12:07,250
all these web applications we're kind of

00:12:04,880 --> 00:12:08,630
moving back to a little bit of that of I

00:12:07,250 --> 00:12:10,340
throw these functions out at the cloud

00:12:08,630 --> 00:12:12,020
and run those or I have this big

00:12:10,340 --> 00:12:14,090
kubernetes cluster and I spin up a whole

00:12:12,020 --> 00:12:17,410
bunch of instances on one machine but

00:12:14,090 --> 00:12:20,870
we're not in a write once run anywhere

00:12:17,410 --> 00:12:24,650
in the sense of like existential we're

00:12:20,870 --> 00:12:27,680
no write once run everywhere right so

00:12:24,650 --> 00:12:30,350
not only do I need to run my application

00:12:27,680 --> 00:12:32,330
like on the cloud I need to run it on my

00:12:30,350 --> 00:12:34,520
internal servers I need to run it in dev

00:12:32,330 --> 00:12:36,440
I need to run it in prod I have a micro

00:12:34,520 --> 00:12:38,060
service architecture so I make a change

00:12:36,440 --> 00:12:40,040
to something here and then I need to

00:12:38,060 --> 00:12:42,710
check the downstream works but I need to

00:12:40,040 --> 00:12:44,930
find a way to run my service and its

00:12:42,710 --> 00:12:46,310
dependencies with my service changed and

00:12:44,930 --> 00:12:47,660
then make sure all of the other

00:12:46,310 --> 00:12:49,490
production things that talk to it don't

00:12:47,660 --> 00:12:51,710
break right and so I might make a

00:12:49,490 --> 00:12:54,080
staging instance of this I might find

00:12:51,710 --> 00:12:56,330
ways to piecemeal you know redo my graph

00:12:54,080 --> 00:12:59,360
I'm actually running this block of code

00:12:56,330 --> 00:13:02,150
in many many many places not just a

00:12:59,360 --> 00:13:03,860
single place right so it's about

00:13:02,150 --> 00:13:06,890
understanding and adapting to your

00:13:03,860 --> 00:13:11,090
environment more so than just being able

00:13:06,890 --> 00:13:15,200
to run on any environment yeah wora

00:13:11,090 --> 00:13:16,700
to war oh no no no no not war that's

00:13:15,200 --> 00:13:17,780
right how do you say that we don't want

00:13:16,700 --> 00:13:19,280
to announce that word

00:13:17,780 --> 00:13:24,440
yeah that's a bad one y'all come up with

00:13:19,280 --> 00:13:26,150
another one okay so anyway we want to

00:13:24,440 --> 00:13:28,520
make migrating code really really really

00:13:26,150 --> 00:13:31,550
simple so the idea is when you're at a

00:13:28,520 --> 00:13:34,010
particular application level you need to

00:13:31,550 --> 00:13:35,480
focus on the logic appropriate to that

00:13:34,010 --> 00:13:38,570
level or the thing that you're doing so

00:13:35,480 --> 00:13:40,280
if I am in development of a feature I

00:13:38,570 --> 00:13:42,860
should be focusing on the business logic

00:13:40,280 --> 00:13:44,810
of my feature if I am worried about the

00:13:42,860 --> 00:13:46,580
production environment that I'm within

00:13:44,810 --> 00:13:48,590
I'm dealing with like latency I'm

00:13:46,580 --> 00:13:51,170
dealing with load I'm dealing with my

00:13:48,590 --> 00:13:52,190
99th percentile latency which is always

00:13:51,170 --> 00:13:54,440
fun

00:13:52,190 --> 00:13:58,070
that's my favorite problem right now 99

00:13:54,440 --> 00:13:59,600
p99 yeah hotness so if I'm dealing with

00:13:58,070 --> 00:14:00,830
you like there was one that one request

00:13:59,600 --> 00:14:02,660
that's slow where all the rest of them

00:14:00,830 --> 00:14:04,310
are fine right I want to be with

00:14:02,660 --> 00:14:05,720
thinking about concurrency I wanna be

00:14:04,310 --> 00:14:08,680
thinking about you know all of the

00:14:05,720 --> 00:14:10,700
different monitoring and over you know

00:14:08,680 --> 00:14:11,180
tracing that I need to figure this stuff

00:14:10,700 --> 00:14:12,530
out

00:14:11,180 --> 00:14:13,880
that's what I'm in my production layer

00:14:12,530 --> 00:14:15,230
and that's what I want to be talking

00:14:13,880 --> 00:14:16,760
that language but when I'm doing my

00:14:15,230 --> 00:14:18,920
features I don't want to be speaking

00:14:16,760 --> 00:14:20,690
that language in code that's not my

00:14:18,920 --> 00:14:22,610
intent when I read that code so we want

00:14:20,690 --> 00:14:24,560
to kind of divorce these things and then

00:14:22,610 --> 00:14:26,420
what I'm testing it's all about what's

00:14:24,560 --> 00:14:28,910
coming in and what's going out right am

00:14:26,420 --> 00:14:31,160
I am i abiding by these protocols that

00:14:28,910 --> 00:14:33,080
I'm telling other people I do so I want

00:14:31,160 --> 00:14:34,880
to be able to have those focuses yeah

00:14:33,080 --> 00:14:36,980
and can we test the protocol in

00:14:34,880 --> 00:14:37,820
different as it would be implemented in

00:14:36,980 --> 00:14:43,100
different environments

00:14:37,820 --> 00:14:45,080
exactly so yeah so we have an example

00:14:43,100 --> 00:14:47,420
that we built for this presentation

00:14:45,080 --> 00:14:48,860
using chat BOTS and so I want to show

00:14:47,420 --> 00:14:51,350
you just a little bit of that and then

00:14:48,860 --> 00:14:53,660
at the end we'll see the whole thing so

00:14:51,350 --> 00:14:55,880
just a little bit of a background on our

00:14:53,660 --> 00:14:57,830
chat bot is we wanted to illustrate

00:14:55,880 --> 00:14:59,450
different environments by providing

00:14:57,830 --> 00:15:01,820
different protocols that our chat BOTS

00:14:59,450 --> 00:15:03,350
can talk through so we've got a protocol

00:15:01,820 --> 00:15:06,320
for standard in and standard out telnet

00:15:03,350 --> 00:15:09,170
and then HTTP POST coming from Google

00:15:06,320 --> 00:15:10,610
Cloud for a Google action which gives us

00:15:09,170 --> 00:15:13,070
some state and then we return some

00:15:10,610 --> 00:15:16,460
speech back so the logic that we want to

00:15:13,070 --> 00:15:18,290
program to is really just the things we

00:15:16,460 --> 00:15:20,530
want to say and the questions we want to

00:15:18,290 --> 00:15:23,270
ask and and receiving the answers back

00:15:20,530 --> 00:15:25,130
so that's our little chat bot and I'm

00:15:23,270 --> 00:15:27,110
going to show you the standard in

00:15:25,130 --> 00:15:30,350
standard out version of it so this is

00:15:27,110 --> 00:15:30,990
all running locally here so you see this

00:15:30,350 --> 00:15:32,670
just

00:15:30,990 --> 00:15:34,890
standard standard in standard out let's

00:15:32,670 --> 00:15:36,720
the audience what would you say is your

00:15:34,890 --> 00:15:39,920
favorite line is your best what's the

00:15:36,720 --> 00:15:42,510
best program language best not favorite

00:15:39,920 --> 00:15:43,890
why I heard Python Python

00:15:42,510 --> 00:15:46,399
all right let's write Python Oh wrong

00:15:43,890 --> 00:15:51,620
wrong so try again

00:15:46,399 --> 00:15:54,450
Java ok Java wrong no no Scala

00:15:51,620 --> 00:15:58,980
correct yeah we got to leave all right

00:15:54,450 --> 00:16:00,810
okay so there's our very very simple

00:15:58,980 --> 00:16:03,899
chat bot running on standard and

00:16:00,810 --> 00:16:05,310
standard out so the protocol that we're

00:16:03,899 --> 00:16:07,589
using here is standard in and standard

00:16:05,310 --> 00:16:09,270
out but the logic that you'll see in in

00:16:07,589 --> 00:16:11,430
just a little bit is really just

00:16:09,270 --> 00:16:14,330
describing the conversation it's not

00:16:11,430 --> 00:16:21,620
describing not hooked into the protocol

00:16:14,330 --> 00:16:24,450
okay so that's our basic chat bot reload

00:16:21,620 --> 00:16:27,690
sequence ever okay there we go

00:16:24,450 --> 00:16:30,149
alright right so in pseudocode the way

00:16:27,690 --> 00:16:31,890
this looks is you say when I get

00:16:30,149 --> 00:16:34,380
something that the user has spoken to me

00:16:31,890 --> 00:16:35,550
right in via via typing or talking

00:16:34,380 --> 00:16:37,920
we're actually we have a Google home

00:16:35,550 --> 00:16:40,560
here so we're gonna we're gonna debit if

00:16:37,920 --> 00:16:43,050
the user has talked to me I need to

00:16:40,560 --> 00:16:44,700
figure out what they said and then you

00:16:43,050 --> 00:16:47,190
know do something based on what they

00:16:44,700 --> 00:16:48,540
said so in this case if they say that

00:16:47,190 --> 00:16:50,010
they like Scala of course they're

00:16:48,540 --> 00:16:51,329
correct but if they say any other

00:16:50,010 --> 00:16:54,120
language nah yeah

00:16:51,329 --> 00:16:55,950
sorry that was wrong and then in all

00:16:54,120 --> 00:16:58,200
other instances and we made a really fun

00:16:55,950 --> 00:17:00,420
syntax here for underscore it's the

00:16:58,200 --> 00:17:01,770
beautiful sky live ever seen we you you

00:17:00,420 --> 00:17:03,089
do not know how long we spent on this

00:17:01,770 --> 00:17:05,100
slide just for the underscores but

00:17:03,089 --> 00:17:07,079
anyway you have to pick words precisely

00:17:05,100 --> 00:17:08,760
so you get the right the right padding

00:17:07,079 --> 00:17:11,069
you know so you're not off by one yeah

00:17:08,760 --> 00:17:13,230
yeah tricky we're gonna ask you what

00:17:11,069 --> 00:17:16,020
what's the best language so the idea

00:17:13,230 --> 00:17:18,569
here is the speech is done through some

00:17:16,020 --> 00:17:20,790
sort of like text to intent recognizer

00:17:18,569 --> 00:17:22,770
and that's a module that's gonna run and

00:17:20,790 --> 00:17:25,050
this code is just running after that

00:17:22,770 --> 00:17:28,100
particular module okay how did you color

00:17:25,050 --> 00:17:31,290
that text I use some machine learning

00:17:28,100 --> 00:17:32,910
but applied to myself it's beautiful

00:17:31,290 --> 00:17:35,520
did a great job with that the colors

00:17:32,910 --> 00:17:38,929
match perfectly thank you

00:17:35,520 --> 00:17:41,100
yeah so what's the problem with this I

00:17:38,929 --> 00:17:43,410
it said it returned

00:17:41,100 --> 00:17:47,400
let's see you coming back to it unit

00:17:43,410 --> 00:17:49,350
yeah so hmm what is wrong with that so

00:17:47,400 --> 00:17:51,840
what's wrong with this is the the same

00:17:49,350 --> 00:17:54,450
method right and that asked method are

00:17:51,840 --> 00:17:56,850
tied to a particular implementation of

00:17:54,450 --> 00:17:59,310
say and asked right and I can't change

00:17:56,850 --> 00:18:01,350
it so if I move this code somewhere else

00:17:59,310 --> 00:18:03,780
those say and asked have to deal with

00:18:01,350 --> 00:18:05,460
all the complexity of figuring out how

00:18:03,780 --> 00:18:06,990
to implement themselves on all these

00:18:05,460 --> 00:18:09,960
different environments and sometimes

00:18:06,990 --> 00:18:12,900
that's not realistic right yeah and so

00:18:09,960 --> 00:18:15,060
these are effects right these are we we

00:18:12,900 --> 00:18:16,740
have in this code effects that are

00:18:15,060 --> 00:18:18,750
happening so it's things that are

00:18:16,740 --> 00:18:20,700
affecting something somewhere else and

00:18:18,750 --> 00:18:22,500
so that makes it so we've now tied

00:18:20,700 --> 00:18:24,660
ourselves to a particular protocol a

00:18:22,500 --> 00:18:26,280
particular environment so how did we

00:18:24,660 --> 00:18:29,460
solve this in the past does anyone

00:18:26,280 --> 00:18:31,230
remember like old-school C++ see when we

00:18:29,460 --> 00:18:32,820
had multiple architectures we need to

00:18:31,230 --> 00:18:36,650
write code we wanted to compile for this

00:18:32,820 --> 00:18:39,150
CPU and that CPU what do you do what

00:18:36,650 --> 00:18:41,250
yeah you you would you would virtualize

00:18:39,150 --> 00:18:43,170
right you'd like create a create an API

00:18:41,250 --> 00:18:45,420
that was you know you would interpret

00:18:43,170 --> 00:18:47,250
like the you'd have you'd have any a

00:18:45,420 --> 00:18:48,600
thing which abstract sout the

00:18:47,250 --> 00:18:50,340
environment you're going to run in and

00:18:48,600 --> 00:18:51,510
you would develop against that and then

00:18:50,340 --> 00:18:53,280
it'd be different implementations and

00:18:51,510 --> 00:18:56,790
yes they were done with pound defines

00:18:53,280 --> 00:18:59,040
and and and if deafs but the idea was i

00:18:56,790 --> 00:19:00,870
had the same api depending on what

00:18:59,040 --> 00:19:03,720
environment i'm on and there's a pattern

00:19:00,870 --> 00:19:06,300
for that you know the interpreter

00:19:03,720 --> 00:19:08,850
pattern is it an OA yeah it was it was

00:19:06,300 --> 00:19:10,110
you know this is the functional version

00:19:08,850 --> 00:19:13,800
of it which i think is the more elegant

00:19:10,110 --> 00:19:16,290
version of it yeah it's beautiful anyway

00:19:13,800 --> 00:19:18,120
so so here you know that you can see

00:19:16,290 --> 00:19:21,030
this is this is this is not dot a but

00:19:18,120 --> 00:19:22,530
man I want to make this be in a new that

00:19:21,030 --> 00:19:24,600
we have a shield trait hierarchy it's

00:19:22,530 --> 00:19:26,940
just an ADT of like the user can say

00:19:24,600 --> 00:19:28,200
something they can ask something or they

00:19:26,940 --> 00:19:29,910
can have an output which is some

00:19:28,200 --> 00:19:31,230
combination of telling people things and

00:19:29,910 --> 00:19:33,120
asking them questions at the same time

00:19:31,230 --> 00:19:34,530
right I don't know why it has two

00:19:33,120 --> 00:19:38,640
questions at the same time but you might

00:19:34,530 --> 00:19:43,980
so I've done it in conversation like how

00:19:38,640 --> 00:19:45,870
like when exactly haha okay so then we

00:19:43,980 --> 00:19:48,810
have our implementation which returns

00:19:45,870 --> 00:19:51,060
this this stage program to operate you

00:19:48,810 --> 00:19:52,620
know and this is this allows us to have

00:19:51,060 --> 00:19:53,970
this meta program this is something that

00:19:52,620 --> 00:19:55,830
you've probably heard a bajillion times

00:19:53,970 --> 00:19:57,269
in the Scala community and if this is

00:19:55,830 --> 00:19:59,519
the first time you're hearing it

00:19:57,269 --> 00:20:00,690
you will hear this a bajillion times in

00:19:59,519 --> 00:20:01,619
the in your future in the Scylla

00:20:00,690 --> 00:20:03,450
community you know

00:20:01,619 --> 00:20:05,639
yeah so we're what we're doing is we're

00:20:03,450 --> 00:20:08,489
separating out the effects from the

00:20:05,639 --> 00:20:10,139
interpreter we are just describing what

00:20:08,489 --> 00:20:12,029
our program should do instead of

00:20:10,139 --> 00:20:13,830
actually have our program do something

00:20:12,029 --> 00:20:17,999
and then the interpreter is what comes

00:20:13,830 --> 00:20:20,609
along and actually does something now

00:20:17,999 --> 00:20:22,349
Scala has had a very very long history

00:20:20,609 --> 00:20:24,419
and trying to figure out how to do this

00:20:22,349 --> 00:20:27,059
correct okay

00:20:24,419 --> 00:20:28,739
in 2012 there was this like free monad

00:20:27,059 --> 00:20:31,169
thing that Scala was experimenting with

00:20:28,739 --> 00:20:33,479
that had come from you know Haskell and

00:20:31,169 --> 00:20:36,149
some other things and then in 2015

00:20:33,479 --> 00:20:38,249
there's a paper on the freer monad very

00:20:36,149 --> 00:20:39,779
appropriately named to be you know

00:20:38,249 --> 00:20:42,779
slightly better than the free monad

00:20:39,779 --> 00:20:44,700
because it's even more free it turns out

00:20:42,779 --> 00:20:46,589
if you looked in the details the Freire

00:20:44,700 --> 00:20:49,259
monad is the free Mona just the first

00:20:46,589 --> 00:20:51,779
encoding wasn't you know 100% anyway

00:20:49,259 --> 00:20:53,580
then in 2017 we had this thing called

00:20:51,779 --> 00:20:55,200
tagless final which is hey this is

00:20:53,580 --> 00:20:56,549
faster than the free ramon ad for doing

00:20:55,200 --> 00:20:59,519
the interpreter pattern and even better

00:20:56,549 --> 00:21:01,559
and in 2018 we have this thing called z

00:20:59,519 --> 00:21:05,519
io coming in which is hey here's another

00:21:01,559 --> 00:21:06,869
way of doing it that's even better so so

00:21:05,519 --> 00:21:08,969
you can throw up they let's look into a

00:21:06,869 --> 00:21:12,059
crystal ball and yeah what's out there

00:21:08,969 --> 00:21:15,299
we are making a prediction that by the

00:21:12,059 --> 00:21:17,129
time we have colonized Mars we'll have a

00:21:15,299 --> 00:21:19,349
way of doing interpreters that is the

00:21:17,129 --> 00:21:21,089
standard way or slightly after that just

00:21:19,349 --> 00:21:23,219
a little bit after yeah sometime around

00:21:21,089 --> 00:21:24,899
then yeah time around it yeah for this

00:21:23,219 --> 00:21:27,659
talk where me covering z io it's the

00:21:24,899 --> 00:21:30,389
latest one it has there's pros and cons

00:21:27,659 --> 00:21:32,249
I do want to say if you look at the

00:21:30,389 --> 00:21:35,999
website it has a bunch of marketing

00:21:32,249 --> 00:21:37,259
which we don't appreciate there's a you

00:21:35,999 --> 00:21:39,269
know there's some divisive things about

00:21:37,259 --> 00:21:41,299
maybe a lot of segments of the scala

00:21:39,269 --> 00:21:44,190
community and and zio includes that but

00:21:41,299 --> 00:21:47,940
so we just wanted to use it to give it a

00:21:44,190 --> 00:21:49,950
try no specific endorsement yeah but but

00:21:47,940 --> 00:21:51,570
it has it has an interesting take which

00:21:49,950 --> 00:21:54,029
is slightly different from tagless final

00:21:51,570 --> 00:21:56,309
and I think is worth looking at on the

00:21:54,029 --> 00:21:57,869
interpreter pattern but this talk

00:21:56,309 --> 00:22:00,570
applies to any use of the interpreter

00:21:57,869 --> 00:22:02,789
pattern not just a zio use just just so

00:22:00,570 --> 00:22:04,229
you know it's a yeah I still think the

00:22:02,789 --> 00:22:06,690
scylla community's figured out the right

00:22:04,229 --> 00:22:09,570
that right API here and you've seen

00:22:06,690 --> 00:22:09,910
churn because nothing has really hit the

00:22:09,570 --> 00:22:12,490
mark

00:22:09,910 --> 00:22:16,450
yet and this one has potential this yeah

00:22:12,490 --> 00:22:18,790
yeah okay so just a quick little

00:22:16,450 --> 00:22:20,590
overview into Zeo and what it looks like

00:22:18,790 --> 00:22:23,260
so in Zeo what we do is we create

00:22:20,590 --> 00:22:26,800
programs as values so that's where we

00:22:23,260 --> 00:22:29,620
wrap our effects into this Zeo and

00:22:26,800 --> 00:22:32,020
there's three different aspects to Zeo

00:22:29,620 --> 00:22:35,020
there's the first the first type

00:22:32,020 --> 00:22:37,630
parameter is the environment type so

00:22:35,020 --> 00:22:40,150
this is all of the the resources that

00:22:37,630 --> 00:22:42,100
are Zeo this particular instance of a

00:22:40,150 --> 00:22:45,040
Zeo needs to actually be able to do

00:22:42,100 --> 00:22:47,140
something so what we do is we with our

00:22:45,040 --> 00:22:49,930
interpreter we provide the

00:22:47,140 --> 00:22:51,970
implementations of the interpreter that

00:22:49,930 --> 00:22:54,100
are going to go in and be used in the

00:22:51,970 --> 00:22:56,970
environment to then execute actually

00:22:54,100 --> 00:23:00,010
execute that thing so when it executes

00:22:56,970 --> 00:23:02,890
when a particular Zeo executes it can

00:23:00,010 --> 00:23:05,080
either return in air and so we have a

00:23:02,890 --> 00:23:07,600
type parameter there for the air type or

00:23:05,080 --> 00:23:09,670
it can return a result and so we

00:23:07,600 --> 00:23:11,650
prioritize the the result type as well

00:23:09,670 --> 00:23:14,230
and there's a great blog that goes into

00:23:11,650 --> 00:23:16,600
you more details on it's called like by

00:23:14,230 --> 00:23:18,310
functor io kind of this pattern for this

00:23:16,600 --> 00:23:21,730
but what you can think about is that the

00:23:18,310 --> 00:23:26,170
environment it provides the ability to

00:23:21,730 --> 00:23:28,210
to return in either air or result so

00:23:26,170 --> 00:23:29,590
that's the basic structure of Zeo and

00:23:28,210 --> 00:23:31,300
there's a lot of convenience functions

00:23:29,590 --> 00:23:34,240
for how to assemble and link together

00:23:31,300 --> 00:23:36,370
Zio's and create the that meta program

00:23:34,240 --> 00:23:40,210
that then will be executed by the

00:23:36,370 --> 00:23:42,640
interpreter so this is how we would

00:23:40,210 --> 00:23:46,150
abstract the environment for how we talk

00:23:42,640 --> 00:23:48,310
so in there's there's a few interesting

00:23:46,150 --> 00:23:51,850
parts here that we have to call out that

00:23:48,310 --> 00:23:53,110
will allow you to kind of wiggle around

00:23:51,850 --> 00:23:55,840
your environment as you write a program

00:23:53,110 --> 00:23:58,180
so here we create a talk service a talk

00:23:55,840 --> 00:24:01,060
service is a single value that

00:23:58,180 --> 00:24:03,250
implements a trait and the trait is your

00:24:01,060 --> 00:24:04,960
API this is the thing that you used to

00:24:03,250 --> 00:24:06,850
call that looks like it mutates right so

00:24:04,960 --> 00:24:08,290
I have a service that has say in prompt

00:24:06,850 --> 00:24:10,690
in it that takes in a message just like

00:24:08,290 --> 00:24:11,980
I had in my mutable interface all right

00:24:10,690 --> 00:24:14,560
and it's gonna return something wrapped

00:24:11,980 --> 00:24:16,150
in cio and I'm gonna define this trait

00:24:14,560 --> 00:24:19,480
talk service which is my environment

00:24:16,150 --> 00:24:21,640
this this describes in in my application

00:24:19,480 --> 00:24:23,380
anytime I see something that takes a

00:24:21,640 --> 00:24:24,850
talk service as an environment

00:24:23,380 --> 00:24:27,220
it means I have to provide an

00:24:24,850 --> 00:24:30,790
implementation of this API to run that

00:24:27,220 --> 00:24:33,640
code and then I have this convenience

00:24:30,790 --> 00:24:35,980
method down here where that's what users

00:24:33,640 --> 00:24:37,780
of Talk Service will do and so the way

00:24:35,980 --> 00:24:40,270
that code reads is basically I have a

00:24:37,780 --> 00:24:42,010
talk service where anytime someone calls

00:24:40,270 --> 00:24:43,870
say it's gonna look up the

00:24:42,010 --> 00:24:46,090
implementation and actually run it

00:24:43,870 --> 00:24:48,790
alright so this is this is boilerplate

00:24:46,090 --> 00:24:52,300
this is what I would say is possibly the

00:24:48,790 --> 00:24:54,300
the ugly gunk of Zi oh yeah it's it's

00:24:52,300 --> 00:24:57,220
kind of like a thing you have to do to

00:24:54,300 --> 00:24:59,710
then get the better api's on the other

00:24:57,220 --> 00:25:01,390
side and if you've ever done you know

00:24:59,710 --> 00:25:03,670
interpreter abstractions you kind of

00:25:01,390 --> 00:25:05,320
have this somewhere I haven't seen one

00:25:03,670 --> 00:25:07,300
that fully gets rid of this stuff but

00:25:05,320 --> 00:25:09,430
yeah this is this is what it looks like

00:25:07,300 --> 00:25:13,380
for Zi oh maybe Scala 3 will fix it for

00:25:09,430 --> 00:25:15,910
us yes of course of course yeah

00:25:13,380 --> 00:25:18,250
all right so then when I when I write

00:25:15,910 --> 00:25:20,350
that previous method that takes the user

00:25:18,250 --> 00:25:23,290
speech and decides what to do it looks

00:25:20,350 --> 00:25:25,150
very similar now right the the cool

00:25:23,290 --> 00:25:28,690
thing is because of some type inference

00:25:25,150 --> 00:25:31,210
and the the way these things return that

00:25:28,690 --> 00:25:33,460
cio takes a talk service as its

00:25:31,210 --> 00:25:34,990
environment it's telling me when I read

00:25:33,460 --> 00:25:36,580
this oh I need to provide an

00:25:34,990 --> 00:25:38,410
implementation a talk service to be able

00:25:36,580 --> 00:25:40,570
to test this function it's in the type

00:25:38,410 --> 00:25:42,640
system so I can't forget to provide it

00:25:40,570 --> 00:25:44,290
when I read a test I need to make sure

00:25:42,640 --> 00:25:47,050
that I've provided it or I can't run

00:25:44,290 --> 00:25:49,540
this function but everything is kind of

00:25:47,050 --> 00:25:54,640
staged yeah yeah I noticed a bug on our

00:25:49,540 --> 00:25:56,200
slide you see it last one the last day

00:25:54,640 --> 00:26:01,210
it's supposed to be asked oh it is asked

00:25:56,200 --> 00:26:03,010
yeah tested these things right anyway

00:26:01,210 --> 00:26:04,660
just just reinforcing that like talk

00:26:03,010 --> 00:26:07,750
service is called out it's in the type

00:26:04,660 --> 00:26:09,820
system I need this thing ok so what I

00:26:07,750 --> 00:26:12,070
want to provide an environment and I

00:26:09,820 --> 00:26:14,260
want to run the same application right I

00:26:12,070 --> 00:26:15,790
can call next with user intent and it's

00:26:14,260 --> 00:26:18,100
going to give me a stage program that

00:26:15,790 --> 00:26:21,430
hasn't run yet so I can decide to

00:26:18,100 --> 00:26:22,150
provide the service that will work on

00:26:21,430 --> 00:26:23,620
the cloud

00:26:22,150 --> 00:26:25,120
or I can provide the service that works

00:26:23,620 --> 00:26:26,620
on the console and this is actually if

00:26:25,120 --> 00:26:29,020
you look at our demo code which will

00:26:26,620 --> 00:26:31,630
show later or give you the link later

00:26:29,020 --> 00:26:33,160
you can see the console application and

00:26:31,630 --> 00:26:35,680
the cloud application are the exact same

00:26:33,160 --> 00:26:37,059
implementation and we're just providing

00:26:35,680 --> 00:26:39,249
different services

00:26:37,059 --> 00:26:41,080
environments form and so that's where we

00:26:39,249 --> 00:26:42,820
implement the different protocols that

00:26:41,080 --> 00:26:44,769
are going to be used so we have a

00:26:42,820 --> 00:26:46,840
protocol for telnet one for the web

00:26:44,769 --> 00:26:48,639
server which we wrote around web server

00:26:46,840 --> 00:26:51,190
for this which was super fun though yeah

00:26:48,639 --> 00:26:53,889
I don't recommend it yeah yes that's

00:26:51,190 --> 00:26:57,600
that's how we then abstract away the the

00:26:53,889 --> 00:26:58,809
meta program from the interpreter yeah

00:26:57,600 --> 00:27:01,360
right

00:26:58,809 --> 00:27:04,120
the other cool thing is if I make use of

00:27:01,360 --> 00:27:05,740
other services and other api's the

00:27:04,120 --> 00:27:07,570
reason you had that trait with that val

00:27:05,740 --> 00:27:12,299
is these these environments can compose

00:27:07,570 --> 00:27:15,220
with oh oh right we have this notion of

00:27:12,299 --> 00:27:16,869
it's it's kind of Scala two's version of

00:27:15,220 --> 00:27:19,840
Union type and it's way better in Scala

00:27:16,869 --> 00:27:22,690
3 but I can basically have all of these

00:27:19,840 --> 00:27:25,899
traits composed together and so if I

00:27:22,690 --> 00:27:28,720
have an API that requires a talk service

00:27:25,899 --> 00:27:31,929
and I'm using my monitoring API then

00:27:28,720 --> 00:27:34,539
that program will require a talk service

00:27:31,929 --> 00:27:37,690
with monitoring and will just work right

00:27:34,539 --> 00:27:40,659
so I can actually compose these api's

00:27:37,690 --> 00:27:43,360
and limit the type of any program to

00:27:40,659 --> 00:27:45,999
just the services it makes use of and if

00:27:43,360 --> 00:27:48,490
I start to see my cake explode real big

00:27:45,999 --> 00:27:51,519
maybe that's a sign to me to refactor

00:27:48,490 --> 00:27:53,379
right so you have this natural way of

00:27:51,519 --> 00:27:54,999
viewing your program and kind of

00:27:53,379 --> 00:27:58,690
limiting the amount of environment you

00:27:54,999 --> 00:28:00,909
require in any one function awesome ok

00:27:58,690 --> 00:28:02,740
so here's an example where we throw in

00:28:00,909 --> 00:28:06,129
monitoring we have a monitoring service

00:28:02,740 --> 00:28:08,049
and so we define a modern service that

00:28:06,129 --> 00:28:09,549
allows us to monitor what language

00:28:08,049 --> 00:28:12,190
people vote for when they don't choose

00:28:09,549 --> 00:28:13,749
Scala so we can figure out why we don't

00:28:12,190 --> 00:28:14,679
recognize other languages and whether we

00:28:13,749 --> 00:28:16,960
should add them to our language

00:28:14,679 --> 00:28:19,450
recognition or ignore them I don't know

00:28:16,960 --> 00:28:21,970
one of the two and so to do this all we

00:28:19,450 --> 00:28:23,769
didn't change the the actual effects

00:28:21,970 --> 00:28:26,860
here we just changed the the meta

00:28:23,769 --> 00:28:29,169
program added in monitoring so there was

00:28:26,860 --> 00:28:30,909
no impact on on anything and then we

00:28:29,169 --> 00:28:33,639
just had to add that monitoring trait

00:28:30,909 --> 00:28:35,499
into our environment to make this work

00:28:33,639 --> 00:28:37,299
yes so the the signature changed to

00:28:35,499 --> 00:28:40,499
require talk service with monitoring

00:28:37,299 --> 00:28:44,169
instead of just talk service yep yeah

00:28:40,499 --> 00:28:46,119
okay so so what why have we been talking

00:28:44,169 --> 00:28:48,159
about zo and effects and interpreters

00:28:46,119 --> 00:28:50,440
and where I think this gets really

00:28:48,159 --> 00:28:50,650
interesting is that what we can do is we

00:28:50,440 --> 00:28:52,360
can

00:28:50,650 --> 00:28:54,490
abstract away from our environment

00:28:52,360 --> 00:28:56,530
that's what the effects and interpreter

00:28:54,490 --> 00:28:58,570
separation allows us and then was

00:28:56,530 --> 00:29:00,970
serverless we can abstract away from our

00:28:58,570 --> 00:29:03,690
operations and then what we get is a

00:29:00,970 --> 00:29:06,700
beautiful baked cake in the cloud right

00:29:03,690 --> 00:29:09,940
yeah bake our cake in the cloud and so

00:29:06,700 --> 00:29:11,559
that those two allow us to have an

00:29:09,940 --> 00:29:14,140
application that is that is portable

00:29:11,559 --> 00:29:15,430
across environments and then I don't

00:29:14,140 --> 00:29:18,160
have to think about the operational side

00:29:15,430 --> 00:29:22,090
when it's running in a cloud so nice

00:29:18,160 --> 00:29:24,010
combination there of things so for this

00:29:22,090 --> 00:29:26,080
particular application the way that we

00:29:24,010 --> 00:29:27,130
set it up was the in our dev interpreter

00:29:26,080 --> 00:29:29,200
the one you saw earlier where you

00:29:27,130 --> 00:29:31,510
standard in standard out for our

00:29:29,200 --> 00:29:33,610
protocol interpreter for our test

00:29:31,510 --> 00:29:36,150
interpreter we actually used a mutable

00:29:33,610 --> 00:29:39,420
console and so this allows us then to

00:29:36,150 --> 00:29:41,830
assert on the the values that have been

00:29:39,420 --> 00:29:43,900
inserted in so the statements that have

00:29:41,830 --> 00:29:46,270
been inserted in and feed in different

00:29:43,900 --> 00:29:48,760
inputs and that sort of thing and then

00:29:46,270 --> 00:29:50,620
in the prod interpreter we have the web

00:29:48,760 --> 00:29:52,420
server and stack driver for for

00:29:50,620 --> 00:29:54,220
monitoring yeah and the beauty the

00:29:52,420 --> 00:29:55,840
beauty like the reason the reason we did

00:29:54,220 --> 00:29:58,390
this and have this demonstration that's

00:29:55,840 --> 00:30:00,820
nice and simple was to show you you know

00:29:58,390 --> 00:30:04,620
your your dev iteration cycle

00:30:00,820 --> 00:30:07,240
environment if that thing remains prod

00:30:04,620 --> 00:30:09,850
it becomes a problem over time right

00:30:07,240 --> 00:30:11,980
like when I have to actually go to prod

00:30:09,850 --> 00:30:14,470
and push things in prod and tests in

00:30:11,980 --> 00:30:16,090
prod and test against prod instances and

00:30:14,470 --> 00:30:18,370
kind of replace microservices this

00:30:16,090 --> 00:30:20,320
actually can cause a lot of developer

00:30:18,370 --> 00:30:22,300
friction it can cause a lot of slow down

00:30:20,320 --> 00:30:24,010
in your iteration cycle and you want to

00:30:22,300 --> 00:30:28,240
try as best as you can

00:30:24,010 --> 00:30:31,240
to find ways around that yep yeah and we

00:30:28,240 --> 00:30:36,510
think this is a good way okay so let's

00:30:31,240 --> 00:30:41,650
see a demo here so I'm gonna start with

00:30:36,510 --> 00:30:43,600
go up here to this one so what we've

00:30:41,650 --> 00:30:44,740
done is create an action on Google and

00:30:43,600 --> 00:30:49,690
maybe you can give a little overview on

00:30:44,740 --> 00:30:53,110
actions on Google cuz so this is this is

00:30:49,690 --> 00:30:54,940
a part of the Google assistant and can

00:30:53,110 --> 00:30:56,980
do more but the idea behind an action on

00:30:54,940 --> 00:30:58,450
Google is you have some tasks you want

00:30:56,980 --> 00:31:00,850
users to do and you have to collect data

00:30:58,450 --> 00:31:02,980
so you define like oh the user has to

00:31:00,850 --> 00:31:03,940
give me in this case what their favorite

00:31:02,980 --> 00:31:05,769
language is

00:31:03,940 --> 00:31:07,750
or you know they have to say a time of

00:31:05,769 --> 00:31:09,610
day and you collect all these pieces of

00:31:07,750 --> 00:31:12,250
data and then it's gonna make a webhook

00:31:09,610 --> 00:31:14,950
endpoint call to you and you have to

00:31:12,250 --> 00:31:16,629
take that data that came in figure out

00:31:14,950 --> 00:31:18,399
how to fulfill what the user wants and

00:31:16,629 --> 00:31:21,629
then tell them what you say back right

00:31:18,399 --> 00:31:22,809
it's it's a relatively simple simple API

00:31:21,629 --> 00:31:25,360
cool

00:31:22,809 --> 00:31:28,059
so for an action on Google we have an

00:31:25,360 --> 00:31:31,120
invocation and we give it a name so this

00:31:28,059 --> 00:31:33,450
one is Scala ZL and then we have an

00:31:31,120 --> 00:31:35,950
action and we've used something called

00:31:33,450 --> 00:31:38,769
dialog flow to actually define our

00:31:35,950 --> 00:31:41,590
action and so with dialog flow we define

00:31:38,769 --> 00:31:44,110
an intent so the first we've created one

00:31:41,590 --> 00:31:46,149
that handles a welcome event and then

00:31:44,110 --> 00:31:48,759
there's a parameter called language and

00:31:46,149 --> 00:31:50,590
so that's all we had to set up in the

00:31:48,759 --> 00:31:52,809
intent you'll see that we are telling it

00:31:50,590 --> 00:31:55,059
to call out to a web hook and so if we

00:31:52,809 --> 00:31:57,700
go to fulfillment you'll see that here's

00:31:55,059 --> 00:31:59,409
my app running up on cloud run with our

00:31:57,700 --> 00:32:01,720
zio application and that's what's

00:31:59,409 --> 00:32:03,370
actually gonna get those requests so

00:32:01,720 --> 00:32:05,080
when the Welcome event happens it's

00:32:03,370 --> 00:32:06,519
going to make a request when the user

00:32:05,080 --> 00:32:10,059
answers it's going to make a request

00:32:06,519 --> 00:32:13,240
that sort of thing okay so that's that's

00:32:10,059 --> 00:32:15,070
our intent in our action anything else

00:32:13,240 --> 00:32:17,320
do the simulator open I just want to

00:32:15,070 --> 00:32:19,600
show this oh yeah so on the simulator

00:32:17,320 --> 00:32:22,269
you can actually hit your live web hook

00:32:19,600 --> 00:32:25,240
right but again it's your live web hook

00:32:22,269 --> 00:32:27,720
so if you're testing and you replace

00:32:25,240 --> 00:32:31,320
that web hook with something else and

00:32:27,720 --> 00:32:33,909
you accidentally have that be public oh

00:32:31,320 --> 00:32:37,029
I just broke the whole world right yeah

00:32:33,909 --> 00:32:39,070
yeah so what often happens when people

00:32:37,029 --> 00:32:40,960
are doing local dev on this type of web

00:32:39,070 --> 00:32:43,659
hook is they use something like an grok

00:32:40,960 --> 00:32:45,700
to explore expose their local machine to

00:32:43,659 --> 00:32:47,590
the Internet so then Google can make a

00:32:45,700 --> 00:32:51,220
call to that thing which then routes to

00:32:47,590 --> 00:32:52,960
their development machine and that's a

00:32:51,220 --> 00:32:54,669
process that we're trying to move away

00:32:52,960 --> 00:32:57,730
from and that we think effects and

00:32:54,669 --> 00:32:59,710
interpreters can help with yep okay so

00:32:57,730 --> 00:33:03,549
let's just take a look at a little bit

00:32:59,710 --> 00:33:05,080
of code here so here is our kind of our

00:33:03,549 --> 00:33:07,000
main application and let me actually

00:33:05,080 --> 00:33:10,000
start a little bit higher where we can

00:33:07,000 --> 00:33:11,710
see our traits here so we have a survey

00:33:10,000 --> 00:33:13,720
intent which can be start to serve a

00:33:11,710 --> 00:33:16,890
give us a language choice and the survey

00:33:13,720 --> 00:33:18,030
survey state and it question are done

00:33:16,890 --> 00:33:21,720
and then what we're doing is we're

00:33:18,030 --> 00:33:23,820
building up a Zeo that that essentially

00:33:21,720 --> 00:33:27,330
knows how to handle an incoming intent

00:33:23,820 --> 00:33:29,760
and then produce the survey state out of

00:33:27,330 --> 00:33:33,630
that so you can see what it returns out

00:33:29,760 --> 00:33:35,970
is that survey state so input survey

00:33:33,630 --> 00:33:37,920
intent output survey state you'll see

00:33:35,970 --> 00:33:39,660
that we're using Zeo so we give it the

00:33:37,920 --> 00:33:41,370
environment that it needs and that

00:33:39,660 --> 00:33:44,190
includes the monitoring and that

00:33:41,370 --> 00:33:46,260
includes the console which provides the

00:33:44,190 --> 00:33:49,110
protocol and then we can throw an

00:33:46,260 --> 00:33:50,520
ioexception but one thing you'll notice

00:33:49,110 --> 00:33:52,260
this looks different than the slides we

00:33:50,520 --> 00:33:54,060
showed before and the primary reason is

00:33:52,260 --> 00:33:56,010
this first thing of handle language

00:33:54,060 --> 00:33:58,590
where if you said acceptable language

00:33:56,010 --> 00:33:59,790
we're gonna say correct and if you

00:33:58,590 --> 00:34:01,560
didn't say acceptable language we'll say

00:33:59,790 --> 00:34:03,840
wrong and will reap romped you to say

00:34:01,560 --> 00:34:06,210
hey what was the best language right if

00:34:03,840 --> 00:34:08,010
you saw that in the console application

00:34:06,210 --> 00:34:09,600
so this this was a little bit more code

00:34:08,010 --> 00:34:10,679
than would fit on a slide but that's

00:34:09,600 --> 00:34:15,630
that's effectively what you're seeing

00:34:10,679 --> 00:34:17,580
here yep yeah so so this is just us kind

00:34:15,630 --> 00:34:19,770
of putting together Zeo so we're linking

00:34:17,580 --> 00:34:22,860
together different Zeos together to

00:34:19,770 --> 00:34:25,620
create the kind of outer Zeo and at any

00:34:22,860 --> 00:34:27,000
Zeo level we can we can test that thing

00:34:25,620 --> 00:34:28,470
we can provide it the environment that

00:34:27,000 --> 00:34:32,370
it needs and we can actually test it

00:34:28,470 --> 00:34:35,130
with a unit test or on in a dev instance

00:34:32,370 --> 00:34:37,080
or however we want to test that so let

00:34:35,130 --> 00:34:39,149
me show you the actual unit test that we

00:34:37,080 --> 00:34:40,649
wrote for some of this so you can see in

00:34:39,149 --> 00:34:42,480
this one we're saying like the

00:34:40,649 --> 00:34:45,899
conversation must reject a non scala

00:34:42,480 --> 00:34:48,270
languages and so we just call that that

00:34:45,899 --> 00:34:50,310
method to get our Zeo we provide it the

00:34:48,270 --> 00:34:54,360
environment that it needs and then we do

00:34:50,310 --> 00:34:58,470
this unsafe run on that so result here

00:34:54,360 --> 00:35:01,350
is a zo of clock IO exceptions survey

00:34:58,470 --> 00:35:03,540
state and so we actually run that with

00:35:01,350 --> 00:35:06,000
the interpreter that we've provided it

00:35:03,540 --> 00:35:08,640
and then we make sure that what we get

00:35:06,000 --> 00:35:09,870
back is a question which is the state

00:35:08,640 --> 00:35:13,910
that we should get back with the wrong

00:35:09,870 --> 00:35:13,910
answer yeah and if you look further down

00:35:14,810 --> 00:35:19,410
if you look further down we actually

00:35:17,910 --> 00:35:20,700
checked monitoring where we have an

00:35:19,410 --> 00:35:22,170
implementation monitoring that all it

00:35:20,700 --> 00:35:23,610
does is record all the calls that have

00:35:22,170 --> 00:35:26,340
been made into monitoring and here we

00:35:23,610 --> 00:35:27,900
can assert that when you said c-sharp we

00:35:26,340 --> 00:35:29,490
make sure that the recorder also

00:35:27,900 --> 00:35:30,300
recorded c-sharp to make sure that our

00:35:29,490 --> 00:35:33,060
monitoring calls

00:35:30,300 --> 00:35:35,040
are in the right place yeah so if we

00:35:33,060 --> 00:35:37,200
were to show up higher in the file you'd

00:35:35,040 --> 00:35:39,240
see where we have the the mutable part

00:35:37,200 --> 00:35:41,820
of the environment that allows us to

00:35:39,240 --> 00:35:43,800
store those things in the test

00:35:41,820 --> 00:35:45,420
environment yeah but we would never want

00:35:43,800 --> 00:35:47,700
to do it that way in production you can

00:35:45,420 --> 00:35:49,680
imagine that this is given how trivial

00:35:47,700 --> 00:35:51,270
or business logic is it doesn't it's not

00:35:49,680 --> 00:35:52,770
as impressive but when you actually do

00:35:51,270 --> 00:35:55,170
one of these dialogues for real you end

00:35:52,770 --> 00:35:57,060
up with a lot more complicated logic and

00:35:55,170 --> 00:35:58,500
so making sure that you log something in

00:35:57,060 --> 00:36:01,260
this little tiny instance is a lot

00:35:58,500 --> 00:36:03,570
harder and more important to verify yeah

00:36:01,260 --> 00:36:06,000
you know what's nice is that we can we

00:36:03,570 --> 00:36:08,760
can test the Zeos at any level of Zeos

00:36:06,000 --> 00:36:10,470
like because they're just the Zeos we

00:36:08,760 --> 00:36:11,940
can we can combine them together chain

00:36:10,470 --> 00:36:13,740
them together but then we can also test

00:36:11,940 --> 00:36:15,660
them at any point as well any point that

00:36:13,740 --> 00:36:17,850
we expose from our application yep

00:36:15,660 --> 00:36:20,910
that's nice ok so let me show you the

00:36:17,850 --> 00:36:24,390
docker file the is used to use growl to

00:36:20,910 --> 00:36:26,490
create the application the native image

00:36:24,390 --> 00:36:31,020
part of this application so I'm using

00:36:26,490 --> 00:36:32,880
the growl VM seee image and then running

00:36:31,020 --> 00:36:34,650
this install for native image which is

00:36:32,880 --> 00:36:37,650
the tool to do the ahead of time

00:36:34,650 --> 00:36:40,590
compliation and then SBT native packager

00:36:37,650 --> 00:36:43,500
thanks Josh and many others everyone

00:36:40,590 --> 00:36:47,490
else that's right you're long gone so

00:36:43,500 --> 00:36:49,500
growl VM native image is a task provided

00:36:47,490 --> 00:36:52,530
by the native packager which is going to

00:36:49,500 --> 00:36:54,780
run growl and and then do the process to

00:36:52,530 --> 00:36:57,410
create that that ahead of time compiled

00:36:54,780 --> 00:36:59,940
an image so that's how we build our

00:36:57,410 --> 00:37:02,460
artifact our application or native

00:36:59,940 --> 00:37:04,620
application so then to actually run it

00:37:02,460 --> 00:37:07,500
we're going to use the alpine linux

00:37:04,620 --> 00:37:10,440
image and then we're gonna copy the app

00:37:07,500 --> 00:37:12,690
that was compiled from SBT and Graul and

00:37:10,440 --> 00:37:15,420
then here's the command that we use to

00:37:12,690 --> 00:37:18,060
start it up so the nice thing here is

00:37:15,420 --> 00:37:20,340
this is taking our application and

00:37:18,060 --> 00:37:22,320
running it in Brawl and we can actually

00:37:20,340 --> 00:37:24,030
define this as our cloud run we can have

00:37:22,320 --> 00:37:26,310
this be like a production deployment but

00:37:24,030 --> 00:37:27,900
again if we wanted to have a non growl

00:37:26,310 --> 00:37:29,760
image and have a non growl way of

00:37:27,900 --> 00:37:32,280
starting this for development that has a

00:37:29,760 --> 00:37:34,770
faster iteration cycle you just make a

00:37:32,280 --> 00:37:37,020
different docker file for that thing and

00:37:34,770 --> 00:37:38,490
you build it in that way right like you

00:37:37,020 --> 00:37:39,060
should be able to have different

00:37:38,490 --> 00:37:41,040
environments

00:37:39,060 --> 00:37:43,080
this is production this is the native

00:37:41,040 --> 00:37:44,490
this is the fast restart this is the one

00:37:43,080 --> 00:37:46,890
where I want you know

00:37:44,490 --> 00:37:48,450
to know exactly what my latency is but

00:37:46,890 --> 00:37:51,690
that doesn't mean this is good for your

00:37:48,450 --> 00:37:52,920
developer right how long did it take us

00:37:51,690 --> 00:37:54,570
to build this grill image and this is

00:37:52,920 --> 00:37:56,370
like a very very small program it's like

00:37:54,570 --> 00:37:57,840
seven minutes seven minutes right that's

00:37:56,370 --> 00:37:59,490
great for pushing to Prague that's a

00:37:57,840 --> 00:38:02,280
beautiful push to Prague that is not a

00:37:59,490 --> 00:38:04,350
good dev iteration cycle time right I

00:38:02,280 --> 00:38:05,790
don't want to grow things for dev

00:38:04,350 --> 00:38:08,520
iteration cycles

00:38:05,790 --> 00:38:10,170
yessuh with Zeo we need to have some

00:38:08,520 --> 00:38:12,090
point where we kind of bake the cake and

00:38:10,170 --> 00:38:15,330
the way that we've done that is we've

00:38:12,090 --> 00:38:17,670
used command flags and args to do that

00:38:15,330 --> 00:38:19,650
and so when you specify - web that's

00:38:17,670 --> 00:38:22,130
going to assemble the web server into

00:38:19,650 --> 00:38:25,590
the environment put the web server

00:38:22,130 --> 00:38:28,140
protocol provider into that environment

00:38:25,590 --> 00:38:30,120
so that then we can handle web requests

00:38:28,140 --> 00:38:33,090
versus handling you doing it through

00:38:30,120 --> 00:38:35,370
standard and standard out or the telnet

00:38:33,090 --> 00:38:37,890
server yeah so you know there's also -

00:38:35,370 --> 00:38:41,760
telnet and I think nothing means console

00:38:37,890 --> 00:38:43,770
yes yeah yeah yeah okay so we have

00:38:41,760 --> 00:38:45,900
already deployed this application up on

00:38:43,770 --> 00:38:48,870
the cloud so that's if we want to go

00:38:45,900 --> 00:38:53,460
check that out we'll go see it here in

00:38:48,870 --> 00:38:56,160
the cloud run console here it is rzo

00:38:53,460 --> 00:38:58,320
laying survey so you'll see there's our

00:38:56,160 --> 00:39:00,300
endpoint we can check out the logs and

00:38:58,320 --> 00:39:02,600
see revisions and that sort of thing and

00:39:00,300 --> 00:39:04,530
throwing some hairs there at some point

00:39:02,600 --> 00:39:06,780
that's okay

00:39:04,530 --> 00:39:08,160
okay so that our application is now

00:39:06,780 --> 00:39:10,140
we've gone through the process of

00:39:08,160 --> 00:39:12,660
creating the docker image and deploying

00:39:10,140 --> 00:39:15,380
that on cloud run so now we should be

00:39:12,660 --> 00:39:16,950
able to actually talk to it from our

00:39:15,380 --> 00:39:21,150
Google what do you call this thing

00:39:16,950 --> 00:39:23,160
Google home go home mini right or is it

00:39:21,150 --> 00:39:26,760
a micro I mean no one can see it here oh

00:39:23,160 --> 00:39:28,410
yeah we lift it up and show them okay so

00:39:26,760 --> 00:39:29,070
let's let's give it a try and see if it

00:39:28,410 --> 00:39:34,050
actually works

00:39:29,070 --> 00:39:37,800
hey Google talk to Scala zo okay here's

00:39:34,050 --> 00:39:39,570
the test version of Scala zo survey says

00:39:37,800 --> 00:39:44,970
what is the best programming language

00:39:39,570 --> 00:39:47,160
Scala correct yeah all right first time

00:39:44,970 --> 00:39:50,190
first time yeah good job

00:39:47,160 --> 00:39:51,570
good good job on that yeah yeah nice so

00:39:50,190 --> 00:39:53,850
anyway so that's that's our little

00:39:51,570 --> 00:39:55,510
application okay let's hop back to you

00:39:53,850 --> 00:39:59,980
slides

00:39:55,510 --> 00:40:01,420
and let's check them out okay you saw

00:39:59,980 --> 00:40:02,440
the demo of putting all those different

00:40:01,420 --> 00:40:03,850
things together we didn't show the

00:40:02,440 --> 00:40:05,830
telnet environment but you did get to

00:40:03,850 --> 00:40:09,369
see the standard and standard out and

00:40:05,830 --> 00:40:12,700
the the test the unit test and then the

00:40:09,369 --> 00:40:14,320
web server environment so the concept we

00:40:12,700 --> 00:40:16,990
really really really want to emphasize

00:40:14,320 --> 00:40:18,580
here is like the idea of making things

00:40:16,990 --> 00:40:20,350
portable through staging and

00:40:18,580 --> 00:40:23,290
understanding that my production

00:40:20,350 --> 00:40:25,210
environment and my dev iteration cycle

00:40:23,290 --> 00:40:27,730
environment and my test environment are

00:40:25,210 --> 00:40:29,680
different and any time I write a program

00:40:27,730 --> 00:40:32,200
I actually have more than one

00:40:29,680 --> 00:40:33,850
environment target no matter what like

00:40:32,200 --> 00:40:36,100
even if I only have one production

00:40:33,850 --> 00:40:38,350
environment I'm still targeting many

00:40:36,100 --> 00:40:42,010
different environments for the lifecycle

00:40:38,350 --> 00:40:44,650
this project right well write once run

00:40:42,010 --> 00:40:47,220
everywhere write like more than one

00:40:44,650 --> 00:40:50,109
place for the lifecycle of that thing

00:40:47,220 --> 00:40:52,540
yeah yeah it's the future it's the

00:40:50,109 --> 00:40:53,890
future yeah and we do expect you know

00:40:52,540 --> 00:40:56,650
these tools and things will get better

00:40:53,890 --> 00:40:58,510
over time this is just yeah what we

00:40:56,650 --> 00:41:01,390
think is pretty cool right now yeah yeah

00:40:58,510 --> 00:41:03,760
chip your meta program right yeah yeah

00:41:01,390 --> 00:41:04,090
and staging you know that's gonna make

00:41:03,760 --> 00:41:07,300
it better

00:41:04,090 --> 00:41:10,030
definitely cool all right so all the

00:41:07,300 --> 00:41:14,050
code is up on my github there is yo lang

00:41:10,030 --> 00:41:15,760
survey on James Ward and gab and Josh

00:41:14,050 --> 00:41:18,430
did most of the work so thank you for

00:41:15,760 --> 00:41:20,170
that so even that's on my github I've

00:41:18,430 --> 00:41:22,900
taken all the credit but Josh actually

00:41:20,170 --> 00:41:25,210
did all the work so that's not true

00:41:22,900 --> 00:41:26,770
anyway okay I think we have a few

00:41:25,210 --> 00:41:30,010
minutes for questions yeah a couple

00:41:26,770 --> 00:41:34,000
minutes for questions yeah oh thank you

00:41:30,010 --> 00:41:35,470
Thanks let's see how should people ask

00:41:34,000 --> 00:41:37,210
questions you have we have floating mics

00:41:35,470 --> 00:41:42,390
so just raise your hand if you have a

00:41:37,210 --> 00:41:45,220
question it's a big room don't be shy

00:41:42,390 --> 00:41:49,180
we'll also be around afterwards if

00:41:45,220 --> 00:41:52,510
anybody has any questions Annie okay it

00:41:49,180 --> 00:41:53,440
was it was flawless perfect okay all

00:41:52,510 --> 00:41:54,940
right well thank you all so I think

00:41:53,440 --> 00:41:57,190
we're coming buddy you have questions

00:41:54,940 --> 00:42:00,190
Thanks all right we actually have a

00:41:57,190 --> 00:42:03,280
question sorry sorry yeah we can't see

00:42:00,190 --> 00:42:04,119
with some of the words hello I have a

00:42:03,280 --> 00:42:06,490
question

00:42:04,119 --> 00:42:11,830
isn't there a specific

00:42:06,490 --> 00:42:15,820
Romario when the interpreter is able to

00:42:11,830 --> 00:42:19,600
crash the application so I mean let's

00:42:15,820 --> 00:42:22,900
assume that the application runs

00:42:19,600 --> 00:42:25,840
perfectly in the test time alignment but

00:42:22,900 --> 00:42:29,130
with a different interpreter it breaks

00:42:25,840 --> 00:42:33,100
yeah so that's a great question that

00:42:29,130 --> 00:42:34,740
that does happen and the idea one of the

00:42:33,100 --> 00:42:37,150
one of the things you're trying to do is

00:42:34,740 --> 00:42:38,530
the person who writes the interpreter

00:42:37,150 --> 00:42:41,260
might not be the same person who writes

00:42:38,530 --> 00:42:44,170
the business logic and the people who

00:42:41,260 --> 00:42:46,300
can debug in production bugs might not

00:42:44,170 --> 00:42:48,550
be the same people who are efficient at

00:42:46,300 --> 00:42:50,650
writing domain code and so this allows

00:42:48,550 --> 00:42:53,860
you to kind of specialize where someone

00:42:50,650 --> 00:42:56,080
kind of owns the interpreter for

00:42:53,860 --> 00:42:57,850
production and they work on those bugs

00:42:56,080 --> 00:42:59,640
and they specialize on those bugs and

00:42:57,850 --> 00:43:02,380
they are more efficient at those bugs

00:42:59,640 --> 00:43:03,970
then then your entire team having to

00:43:02,380 --> 00:43:05,740
deal with them at the same time right

00:43:03,970 --> 00:43:07,690
it's it's it's a specialization

00:43:05,740 --> 00:43:10,390
trade-off now if your team is small

00:43:07,690 --> 00:43:12,369
enough it might just be you are the

00:43:10,390 --> 00:43:14,590
domain logic and the interpreter and

00:43:12,369 --> 00:43:17,500
this other thing but it lets you divide

00:43:14,590 --> 00:43:18,460
your own time in the same way and it's

00:43:17,500 --> 00:43:20,500
up to you whether or not you think

00:43:18,460 --> 00:43:22,510
that's you know useful but especially as

00:43:20,500 --> 00:43:25,030
teams get bigger we find that there

00:43:22,510 --> 00:43:27,369
tends to be specialized you know persons

00:43:25,030 --> 00:43:28,720
and so dealing with production tends to

00:43:27,369 --> 00:43:31,570
be certain people deal with certain

00:43:28,720 --> 00:43:33,580
production components so the better we

00:43:31,570 --> 00:43:35,290
can tune those bugs to that person and

00:43:33,580 --> 00:43:37,359
optimize their work the better off we

00:43:35,290 --> 00:43:40,230
are as opposed to forcing everyone to

00:43:37,359 --> 00:43:44,619
learn that even people who never will

00:43:40,230 --> 00:43:47,290
and yeah yeah yeah and yeah to add on to

00:43:44,619 --> 00:43:48,910
the in this example we actually had a

00:43:47,290 --> 00:43:50,859
situation where a request was coming in

00:43:48,910 --> 00:43:52,480
that wasn't able to be parsed and so it

00:43:50,859 --> 00:43:53,920
was actually crashing our server because

00:43:52,480 --> 00:43:56,500
there was an exception that was not

00:43:53,920 --> 00:43:58,720
being handled correctly and so that was

00:43:56,500 --> 00:44:01,210
I'd looked at the the logs and was like

00:43:58,720 --> 00:44:02,590
luckily the the application was being

00:44:01,210 --> 00:44:03,850
restarted so I didn't have to think

00:44:02,590 --> 00:44:05,710
about that but then I was able to go

00:44:03,850 --> 00:44:07,540
look at the logs and be like oh there's

00:44:05,710 --> 00:44:10,150
an exception that actually made it all

00:44:07,540 --> 00:44:12,609
the way out and crashed my process and

00:44:10,150 --> 00:44:13,540
my you know bug on me yep I should have

00:44:12,609 --> 00:44:15,520
handled that and that was in the

00:44:13,540 --> 00:44:17,200
interpreter was where that actually was

00:44:15,520 --> 00:44:20,100
yeah what's interesting for this

00:44:17,200 --> 00:44:21,810
application so I implemented the

00:44:20,100 --> 00:44:24,090
version and James implement in the cloud

00:44:21,810 --> 00:44:25,350
version and independently like we didn't

00:44:24,090 --> 00:44:27,630
even really have to look at each other's

00:44:25,350 --> 00:44:29,400
code yeah well I chopped heed you're

00:44:27,630 --> 00:44:30,870
telling that could no it's fine yeah

00:44:29,400 --> 00:44:31,820
don't tell anybody I copied it from

00:44:30,870 --> 00:44:34,820
somewhere else

00:44:31,820 --> 00:44:37,200
okay contact overflow and stack overflow

00:44:34,820 --> 00:44:38,190
alright anyway we are out of time so

00:44:37,200 --> 00:44:40,310
thank you so much

00:44:38,190 --> 00:44:44,460
oh one more question sorry well yeah Oh

00:44:40,310 --> 00:44:49,710
keep giving you false false ends no more

00:44:44,460 --> 00:44:52,770
question sorry just a quick one

00:44:49,710 --> 00:44:56,910
I saw you mention I saw you showing

00:44:52,770 --> 00:44:59,130
google cloud but the support is of Scala

00:44:56,910 --> 00:45:03,360
throughout Google cloud services is it

00:44:59,130 --> 00:45:05,400
better or is it because I used up engine

00:45:03,360 --> 00:45:08,700
and I saw that the supporter is more for

00:45:05,400 --> 00:45:11,550
Java I saw some libraries around Carla

00:45:08,700 --> 00:45:14,160
but I I wasn't sure there's a direct

00:45:11,550 --> 00:45:15,990
support towards the language itself

00:45:14,160 --> 00:45:18,180
yeah I heard there's a direct support

00:45:15,990 --> 00:45:20,130
what we're because we're using cloud run

00:45:18,180 --> 00:45:22,350
you can run anything that runs in a

00:45:20,130 --> 00:45:23,940
docker container essentially and so so

00:45:22,350 --> 00:45:25,320
there isn't specific support but in the

00:45:23,940 --> 00:45:27,600
case of cloud run we don't actually need

00:45:25,320 --> 00:45:29,520
any specific support that's definitely

00:45:27,600 --> 00:45:31,830
one reason why you choose cloud run over

00:45:29,520 --> 00:45:35,220
Google App Engine is that you can run

00:45:31,830 --> 00:45:38,250
anything with cloud run yes but you

00:45:35,220 --> 00:45:42,030
would recommend cloud run over appengine

00:45:38,250 --> 00:45:43,530
in general also or on there there are

00:45:42,030 --> 00:45:44,910
some limitations with cloud run today

00:45:43,530 --> 00:45:46,530
like for instance it doesn't support

00:45:44,910 --> 00:45:49,460
WebSockets yet which is been a bummer

00:45:46,530 --> 00:45:51,810
for some things that I've worked on and

00:45:49,460 --> 00:45:54,270
Google App Engine just added WebSocket

00:45:51,810 --> 00:45:55,890
support and so so there are some

00:45:54,270 --> 00:45:57,960
variations and what you can do between

00:45:55,890 --> 00:46:00,480
the two but for me I'd like to just

00:45:57,960 --> 00:46:02,820
deploy a docker container and I like

00:46:00,480 --> 00:46:04,200
that it's based on K native so that I

00:46:02,820 --> 00:46:05,850
can you know pour out of that

00:46:04,200 --> 00:46:08,130
environment if I need to and do it on my

00:46:05,850 --> 00:46:10,020
own kubernetes so so for me cloud run is

00:46:08,130 --> 00:46:12,150
kind of the default choice for execution

00:46:10,020 --> 00:46:13,560
but but there are some limitations with

00:46:12,150 --> 00:46:15,450
it yeah I think think about it this way

00:46:13,560 --> 00:46:17,940
if most of your applications and most

00:46:15,450 --> 00:46:20,490
your micro services are very simple K

00:46:17,940 --> 00:46:23,220
native and cloud run give you a really

00:46:20,490 --> 00:46:24,900
good way to bootstrap and kickstart if

00:46:23,220 --> 00:46:26,090
you get more complicated you have to

00:46:24,900 --> 00:46:28,650
pick something a little more complicated

00:46:26,090 --> 00:46:32,150
but that can hint they should be able to

00:46:28,650 --> 00:46:34,430
handle a lot like just those two things

00:46:32,150 --> 00:46:36,020
okay alright we'll really be done this

00:46:34,430 --> 00:46:38,200
time we'll be around if there's any

00:46:36,020 --> 00:46:42,900
other questions thank you thank you

00:46:38,200 --> 00:46:42,900

YouTube URL: https://www.youtube.com/watch?v=YS98ropk_yk


