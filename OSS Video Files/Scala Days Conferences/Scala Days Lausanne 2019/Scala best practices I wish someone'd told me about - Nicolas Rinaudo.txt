Title: Scala best practices I wish someone'd told me about - Nicolas Rinaudo
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/scala-best-practices-i-wish-someoned-told-me-about
Captions: 
	00:00:00,030 --> 00:00:04,200
all right so I'm here this afternoon to

00:00:02,580 --> 00:00:06,480
talk to you about best practices in

00:00:04,200 --> 00:00:08,220
Scala and just to give you a bit of

00:00:06,480 --> 00:00:10,019
background on me so that you understand

00:00:08,220 --> 00:00:12,059
why I actually can talk about these

00:00:10,019 --> 00:00:14,790
things I'm the CTO of a company called

00:00:12,059 --> 00:00:16,859
busy dough we recently merged free

00:00:14,790 --> 00:00:19,859
completely different teams one doing

00:00:16,859 --> 00:00:22,560
node one doing Java and when doing Scala

00:00:19,859 --> 00:00:24,949
and we're trying to come together with

00:00:22,560 --> 00:00:27,420
the same processes and technologies it's

00:00:24,949 --> 00:00:29,970
working out about as bad as it expect

00:00:27,420 --> 00:00:31,800
but we have finally agreed that scarra

00:00:29,970 --> 00:00:34,320
was probably the language we all wanted

00:00:31,800 --> 00:00:35,820
to use and this is giving you pretty

00:00:34,320 --> 00:00:38,070
interesting perspectives because I'm

00:00:35,820 --> 00:00:40,260
getting to see talented developers that

00:00:38,070 --> 00:00:42,059
know nothing about Scala or functional

00:00:40,260 --> 00:00:44,550
programming struggle with learning the

00:00:42,059 --> 00:00:48,000
language and rediscovering all the

00:00:44,550 --> 00:00:50,280
things that really troubled me as I was

00:00:48,000 --> 00:00:52,800
learning the language so I'm seeing lots

00:00:50,280 --> 00:00:54,090
of problems that keep coming up and I'm

00:00:52,800 --> 00:00:55,980
writing down these problems and

00:00:54,090 --> 00:01:00,090
solutions to them and this presentation

00:00:55,980 --> 00:01:01,500
is the best ones the most common ones

00:01:00,090 --> 00:01:04,170
the most interesting ones or the

00:01:01,500 --> 00:01:07,260
completely not one that I want to share

00:01:04,170 --> 00:01:10,189
with you so the way this is going to

00:01:07,260 --> 00:01:13,830
work is I'm going to show you some code

00:01:10,189 --> 00:01:17,189
you are going to have to work out what I

00:01:13,830 --> 00:01:18,540
think is wrong with the code explain it

00:01:17,189 --> 00:01:19,860
to me if we can or if you don't have the

00:01:18,540 --> 00:01:21,000
time I'll just give the solution I'm

00:01:19,860 --> 00:01:25,170
going to tell you what's wrong with it

00:01:21,000 --> 00:01:31,920
how to work around it and in the next

00:01:25,170 --> 00:01:33,720
one so let's get started it's a very

00:01:31,920 --> 00:01:37,079
first bit of code that I want to show

00:01:33,720 --> 00:01:40,740
you is this so hang on again right so

00:01:37,079 --> 00:01:42,630
what why do you guys feel that I don't

00:01:40,740 --> 00:01:44,880
like this code I'm just comparing two

00:01:42,630 --> 00:01:49,229
arrays in saqqara now there's a bit of a

00:01:44,880 --> 00:01:51,390
hint often the title of the slides is a

00:01:49,229 --> 00:01:53,189
good idea but what the answer is going

00:01:51,390 --> 00:01:56,369
to be so here quite obviously the

00:01:53,189 --> 00:01:59,430
problem is with array comparison can

00:01:56,369 --> 00:02:01,549
anyone tell me why this is probably not

00:01:59,430 --> 00:02:01,549
great

00:02:03,079 --> 00:02:09,899
okay the main problem of that is it

00:02:06,299 --> 00:02:11,790
doesn't actually work array is the only

00:02:09,899 --> 00:02:14,040
collection in the entire color

00:02:11,790 --> 00:02:16,620
collection library that doesn't have a

00:02:14,040 --> 00:02:18,629
working equals method so comparing

00:02:16,620 --> 00:02:22,410
arrays like that is going to not work

00:02:18,629 --> 00:02:23,849
ever and we know that we as kind of

00:02:22,410 --> 00:02:26,459
developers we have had that problem

00:02:23,849 --> 00:02:29,040
before so we don't use a razor when we

00:02:26,459 --> 00:02:30,720
do we don't compare in that way but to

00:02:29,040 --> 00:02:32,400
beginners to people who come from a Java

00:02:30,720 --> 00:02:34,709
background or a JavaScript background or

00:02:32,400 --> 00:02:36,510
any other background these doesn't make

00:02:34,709 --> 00:02:37,769
any sort of sense this is completely

00:02:36,510 --> 00:02:39,660
nuts

00:02:37,769 --> 00:02:41,579
the reason doesn't work has to do with

00:02:39,660 --> 00:02:43,290
the weights encoding the JVM arrays have

00:02:41,579 --> 00:02:45,750
reference equality not value equality

00:02:43,290 --> 00:02:49,829
it's not super interesting it's just it

00:02:45,750 --> 00:02:53,610
doesn't work so instead of using equals

00:02:49,829 --> 00:02:55,680
for arrays use same elements and again

00:02:53,610 --> 00:02:56,610
you have to know that and it's going to

00:02:55,680 --> 00:02:59,220
buy you some time

00:02:56,610 --> 00:03:00,959
if you don't know it so I've shown it to

00:02:59,220 --> 00:03:02,760
you here and if you didn't know about

00:03:00,959 --> 00:03:08,130
that great I'll just save you hours of

00:03:02,760 --> 00:03:11,100
painting production right so that was my

00:03:08,130 --> 00:03:13,380
first problem with array compare regions

00:03:11,100 --> 00:03:16,680
and given the fact that this is canadaÃ­s

00:03:13,380 --> 00:03:19,590
I'm also going to try and for everything

00:03:16,680 --> 00:03:23,220
one of this problem explain how they are

00:03:19,590 --> 00:03:26,069
fixed or improved or not at all in later

00:03:23,220 --> 00:03:28,380
version of Scala and so in for array

00:03:26,069 --> 00:03:31,500
scanner to that 13 has immutable arrays

00:03:28,380 --> 00:03:33,329
which behaves sanely with requests to

00:03:31,500 --> 00:03:34,380
equals and not some of the stuff so if

00:03:33,329 --> 00:03:37,200
you're using immutable array is

00:03:34,380 --> 00:03:38,700
perfectly fine the mutable arrays even

00:03:37,200 --> 00:03:40,950
in dotty as far as I can tell are

00:03:38,700 --> 00:03:46,769
completely nuts and and try to stay away

00:03:40,950 --> 00:03:48,959
from them if you can right so this bit

00:03:46,769 --> 00:03:51,030
of code which looks perfectly fine

00:03:48,959 --> 00:03:57,389
does anybody have any clue what I don't

00:03:51,030 --> 00:03:58,410
like it come again right so this is not

00:03:57,389 --> 00:04:00,180
the first time somebody gives me the

00:03:58,410 --> 00:04:01,709
answer probably should change this slide

00:04:00,180 --> 00:04:05,849
this is completely correct but not the

00:04:01,709 --> 00:04:10,439
point of the slide again there's often a

00:04:05,849 --> 00:04:12,989
hint the problem here is that I haven't

00:04:10,439 --> 00:04:14,459
type annotated my method so he could

00:04:12,989 --> 00:04:15,690
return any time in the compiler you can

00:04:14,459 --> 00:04:17,580
try to infer it and

00:04:15,690 --> 00:04:19,950
best time you can infer the best type it

00:04:17,580 --> 00:04:22,049
can infer here what you'd expect it to

00:04:19,950 --> 00:04:24,230
be option of a especially given the fact

00:04:22,049 --> 00:04:28,950
that I have named my method as option

00:04:24,230 --> 00:04:31,860
it's actually going to be a sum which is

00:04:28,950 --> 00:04:33,420
not a massive deal most of the time if

00:04:31,860 --> 00:04:35,520
you have a sum it's a subtype of option

00:04:33,420 --> 00:04:38,040
so it's alright but it could be a

00:04:35,520 --> 00:04:40,110
problem say if this is a library and I

00:04:38,040 --> 00:04:42,000
were to publish that then the type of

00:04:40,110 --> 00:04:43,500
the method actually changed and you

00:04:42,000 --> 00:04:48,000
break binary compatibility just like

00:04:43,500 --> 00:04:50,520
that so when you have public methods

00:04:48,000 --> 00:04:52,830
public members type annotate them

00:04:50,520 --> 00:04:54,750
because otherwise you will eventually

00:04:52,830 --> 00:04:56,700
break something and the types are

00:04:54,750 --> 00:04:58,350
inferred are not actually the type you

00:04:56,700 --> 00:05:02,280
think are inferred or at least not not

00:04:58,350 --> 00:05:05,220
all the time so just fix it that way put

00:05:02,280 --> 00:05:07,590
an explicit type annotation and then

00:05:05,220 --> 00:05:10,560
everything will accept just fine this is

00:05:07,590 --> 00:05:12,600
kind of improved in scanner free because

00:05:10,560 --> 00:05:14,940
implicit members have to have a type

00:05:12,600 --> 00:05:16,860
annotation but at the same time implicit

00:05:14,940 --> 00:05:18,780
are being deprecated in scanner free so

00:05:16,860 --> 00:05:20,900
doesn't actually change all that much so

00:05:18,780 --> 00:05:23,040
this is still pretty much a problem in

00:05:20,900 --> 00:05:27,240
2013 and it's kind of free as far as I

00:05:23,040 --> 00:05:35,270
know and do two type annotation on any

00:05:27,240 --> 00:05:38,130
of your public members Unicode operators

00:05:35,270 --> 00:05:41,640
this is problematic can anybody tell me

00:05:38,130 --> 00:05:45,480
why so first what is this code supposed

00:05:41,640 --> 00:05:48,570
to do this syntax here is expected to

00:05:45,480 --> 00:05:50,460
read create a tuple whose left member is

00:05:48,570 --> 00:05:55,650
1 and whose right member is 4 divided by

00:05:50,460 --> 00:05:57,450
2 and this is what happened if you wrote

00:05:55,650 --> 00:05:59,070
that using the ASCII operators and the

00:05:57,450 --> 00:06:00,960
documentation tells you that the ascii

00:05:59,070 --> 00:06:02,370
operators and their Unicode equivalents

00:06:00,960 --> 00:06:06,030
are exactly the same

00:06:02,370 --> 00:06:09,300
there they are in fact not the same this

00:06:06,030 --> 00:06:12,360
does not compile but if you were to use

00:06:09,300 --> 00:06:15,480
yes key operator composters fine so the

00:06:12,360 --> 00:06:17,310
problem here is very subtle the problem

00:06:15,480 --> 00:06:20,490
has to do with operator priority in

00:06:17,310 --> 00:06:22,230
Scala where the rules the rules are a

00:06:20,490 --> 00:06:24,800
bit weird and hard-coded but if your

00:06:22,230 --> 00:06:27,520
operator starts with an iPhone with -

00:06:24,800 --> 00:06:31,330
then it's going to have

00:06:27,520 --> 00:06:33,669
lower priorities and say divide but this

00:06:31,330 --> 00:06:36,280
corrector here does not start with a -

00:06:33,669 --> 00:06:38,099
so it's not actually the same operator

00:06:36,280 --> 00:06:39,849
as the ASCII arrow

00:06:38,099 --> 00:06:41,770
contrary to what the documentation

00:06:39,849 --> 00:06:45,160
explicitly states so this is very

00:06:41,770 --> 00:06:47,110
confusing and it is but most of the time

00:06:45,160 --> 00:06:50,199
to use the ASCII operator instead even

00:06:47,110 --> 00:06:54,729
though it looks much nicer with unicode

00:06:50,199 --> 00:06:56,470
characters there are ways you still have

00:06:54,729 --> 00:06:58,780
a nice display you can use fonts with

00:06:56,470 --> 00:07:00,580
ligatures you can use some advanced

00:06:58,780 --> 00:07:02,919
editor's such as Emacs have pretty

00:07:00,580 --> 00:07:04,930
printing but it's not going to be my

00:07:02,919 --> 00:07:08,139
problem much longer anyway because it's

00:07:04,930 --> 00:07:10,419
deprecated in 2013 so if you guys like

00:07:08,139 --> 00:07:11,740
me had rules to turn all your ascii

00:07:10,419 --> 00:07:13,479
operators into Unicode because you like

00:07:11,740 --> 00:07:17,099
that you're going to have to revert that

00:07:13,479 --> 00:07:17,099
because it's not going to apply anymore

00:07:19,949 --> 00:07:25,599
enumerations what is wrong with the way

00:07:23,289 --> 00:07:30,400
this is implemented first does anybody

00:07:25,599 --> 00:07:32,259
not know what enumeration is okay we're

00:07:30,400 --> 00:07:37,020
going to assume everybody does does

00:07:32,259 --> 00:07:43,599
anybody know does anybody even know why

00:07:37,020 --> 00:07:48,400
this is problematic I couldn't quite

00:07:43,599 --> 00:07:51,759
hear that I'm sorry that is a very good

00:07:48,400 --> 00:07:54,490
answer where to start this is a lot of

00:07:51,759 --> 00:07:56,259
problems is that mostly the whole thing

00:07:54,490 --> 00:07:57,430
is problematic but the one thing I'm

00:07:56,259 --> 00:08:01,360
going to focus on because I think it's

00:07:57,430 --> 00:08:03,310
very important is that once you have

00:08:01,360 --> 00:08:04,900
written your animation like that where

00:08:03,310 --> 00:08:07,259
you have declared an enumeration of type

00:08:04,900 --> 00:08:10,870
status with members okay and not okay

00:08:07,259 --> 00:08:13,389
then this code is going to compile

00:08:10,870 --> 00:08:15,490
without any sort of warning you can

00:08:13,389 --> 00:08:17,440
pattern match on the value of type state

00:08:15,490 --> 00:08:19,479
status dot value and have a

00:08:17,440 --> 00:08:20,889
non-exhaustive pattern match it's going

00:08:19,479 --> 00:08:22,810
to compile and it's going to fail at

00:08:20,889 --> 00:08:25,240
runtime and we don't like it when things

00:08:22,810 --> 00:08:28,030
fail at runtime especially since in

00:08:25,240 --> 00:08:30,310
saqqara we tend to assume that per match

00:08:28,030 --> 00:08:32,950
is smart and he's going to warn you

00:08:30,310 --> 00:08:34,810
whenever it's not exhaustive this

00:08:32,950 --> 00:08:36,250
compound without a single warning he

00:08:34,810 --> 00:08:38,560
crashes at runtime it's everything

00:08:36,250 --> 00:08:40,000
that's wrong with with a lot of the

00:08:38,560 --> 00:08:42,220
errors that we have in

00:08:40,000 --> 00:08:46,750
so don't do that don't use an

00:08:42,220 --> 00:08:49,750
immigration used use seal trade

00:08:46,750 --> 00:08:52,660
hierarchies instead where the way this

00:08:49,750 --> 00:08:55,750
works here is have declared the sealed

00:08:52,660 --> 00:08:59,470
trait sealed means that they cannot be

00:08:55,750 --> 00:09:01,360
any subtype of status declared outside

00:08:59,470 --> 00:09:03,610
of the file in which status was declared

00:09:01,360 --> 00:09:06,430
so the compiler knows that having

00:09:03,610 --> 00:09:09,010
declared okay as a subtype of status not

00:09:06,430 --> 00:09:11,320
okay as a subtype of status and those

00:09:09,010 --> 00:09:14,050
are the only subtypes of status in this

00:09:11,320 --> 00:09:17,320
file that can not possibly be any other

00:09:14,050 --> 00:09:21,790
subtype of status so the compiler knows

00:09:17,320 --> 00:09:23,470
now that this is not legal and he's

00:09:21,790 --> 00:09:25,270
going to warn you that you shouldn't be

00:09:23,470 --> 00:09:28,240
doing that and it's been going to tell

00:09:25,270 --> 00:09:30,190
you that it's going to fail on that

00:09:28,240 --> 00:09:32,230
value so we can give you quite a good

00:09:30,190 --> 00:09:33,730
error message just because you stopped

00:09:32,230 --> 00:09:38,140
using enumeration so don't use

00:09:33,730 --> 00:09:40,030
enumerations ever just one thing this is

00:09:38,140 --> 00:09:41,520
actually a warning not the computation

00:09:40,030 --> 00:09:43,510
failure

00:09:41,520 --> 00:09:45,370
something that's pretty important if you

00:09:43,510 --> 00:09:49,000
want to write correct scanner turn on

00:09:45,370 --> 00:09:50,920
fatal warnings I have had a lot of bugs

00:09:49,000 --> 00:09:52,780
found that way I've never had a false

00:09:50,920 --> 00:09:54,790
positive scanner sees very smart that

00:09:52,780 --> 00:10:00,490
way warnings fix them it's very

00:09:54,790 --> 00:10:02,650
important it's kind of free might even

00:10:00,490 --> 00:10:05,350
chi duplicate enumeration in favor of

00:10:02,650 --> 00:10:07,750
the enum keyword have seen discussions

00:10:05,350 --> 00:10:09,400
on that matter last time I checked he

00:10:07,750 --> 00:10:12,520
was not a proper tickets there was not a

00:10:09,400 --> 00:10:14,020
proper pull request on that but given

00:10:12,520 --> 00:10:15,220
that having sex this weekend lots of

00:10:14,020 --> 00:10:16,780
things I mean I think this week it might

00:10:15,220 --> 00:10:18,700
actually be going on now I don't know

00:10:16,780 --> 00:10:21,900
but this is something that might

00:10:18,700 --> 00:10:21,900
actually disappear from the language

00:10:23,160 --> 00:10:29,100
filtrate right I just told you CEO

00:10:25,620 --> 00:10:30,720
traits were nice and this is very

00:10:29,100 --> 00:10:32,550
similar to what I showed you before but

00:10:30,720 --> 00:10:38,720
I believe something is wrong with that

00:10:32,550 --> 00:10:38,720
code does anybody have an any idea why

00:10:40,070 --> 00:10:49,020
yes you're in the back it louder thank

00:10:48,600 --> 00:10:53,520
you

00:10:49,020 --> 00:10:56,880
so Barry's not final and the problem

00:10:53,520 --> 00:10:58,070
with that is when you see a sealed trait

00:10:56,880 --> 00:11:00,570
and I've just given you the definition

00:10:58,070 --> 00:11:03,270
sealed means you can't have a subtype

00:11:00,570 --> 00:11:04,760
you can't have a direct subtype outside

00:11:03,270 --> 00:11:08,130
of the file in which type was declared

00:11:04,760 --> 00:11:11,400
but direct is very important here most

00:11:08,130 --> 00:11:15,210
people don't really realize that but bar

00:11:11,400 --> 00:11:17,760
is a direct subtype of foo and you can

00:11:15,210 --> 00:11:19,950
only have bar as a direct subtype of

00:11:17,760 --> 00:11:23,070
anywhere in the rest of the code bar

00:11:19,950 --> 00:11:24,720
itself though it is not final so you can

00:11:23,070 --> 00:11:26,790
go into an other file and declare a

00:11:24,720 --> 00:11:30,660
scepter you can declare a subtype of bar

00:11:26,790 --> 00:11:32,130
and foo bar here is not a direct subtype

00:11:30,660 --> 00:11:34,050
of food because there's a level of

00:11:32,130 --> 00:11:35,430
indirection this bar in the middle so

00:11:34,050 --> 00:11:37,620
this is correct this is perfectly valid

00:11:35,430 --> 00:11:40,140
this is exactly how seal is supposed to

00:11:37,620 --> 00:11:42,540
behave it's also for people who have

00:11:40,140 --> 00:11:43,920
just learned about sealed not at all

00:11:42,540 --> 00:11:46,290
what you'd expect and it can be very

00:11:43,920 --> 00:11:48,450
surprising so it's not a huge deal and

00:11:46,290 --> 00:11:50,700
sometimes it's what you might want to do

00:11:48,450 --> 00:11:51,990
but you have to know that it behaves

00:11:50,700 --> 00:11:53,700
that way and unless you have a good

00:11:51,990 --> 00:11:56,340
reason for subtypes of a sealed trait

00:11:53,700 --> 00:11:59,070
not to be final to make them final or

00:11:56,340 --> 00:12:00,780
show themselves because it's a good

00:11:59,070 --> 00:12:02,130
default it's not an absolute rule but

00:12:00,780 --> 00:12:07,110
it's a good default unless you have

00:12:02,130 --> 00:12:08,970
reasons to not follow that role right so

00:12:07,110 --> 00:12:11,460
solution is to prefer final

00:12:08,970 --> 00:12:13,620
co-defendants and as far as I can tell

00:12:11,460 --> 00:12:16,850
nothing's changed in that says you know

00:12:13,620 --> 00:12:16,850
or dotty about that

00:12:17,230 --> 00:12:24,209
right how'd it break data taps so I

00:12:21,670 --> 00:12:29,670
showed you that just before it's

00:12:24,209 --> 00:12:31,779
basically the same code and now um

00:12:29,670 --> 00:12:34,240
something's wrong with that something's

00:12:31,779 --> 00:12:44,560
a bit weird with that yes you in the

00:12:34,240 --> 00:12:49,089
back right so this is a very good answer

00:12:44,560 --> 00:12:51,519
but just a wrong slide very soon so keep

00:12:49,089 --> 00:12:53,949
that answer and then answer it I think

00:12:51,519 --> 00:12:55,240
it's two slides down the road I'm not

00:12:53,949 --> 00:12:56,470
going to repeat it because I don't want

00:12:55,240 --> 00:12:59,560
everybody to know the answers to the

00:12:56,470 --> 00:13:03,310
next trick but no the problem here is

00:12:59,560 --> 00:13:05,620
that this killer compiler can some time

00:13:03,310 --> 00:13:07,990
in for some pretty wonky types so here

00:13:05,620 --> 00:13:10,360
if you create a list of stages okay

00:13:07,990 --> 00:13:13,510
instead it's not okay you'd expect the

00:13:10,360 --> 00:13:16,990
type to be list of status and instead

00:13:13,510 --> 00:13:18,519
you get this abomination which doesn't

00:13:16,990 --> 00:13:20,829
really change all that much but again

00:13:18,519 --> 00:13:22,600
this is from the perspective of somebody

00:13:20,829 --> 00:13:23,769
learning the language somebody who's new

00:13:22,600 --> 00:13:26,649
to the language and trying to work out

00:13:23,769 --> 00:13:28,720
how the bloody thing works and when they

00:13:26,649 --> 00:13:30,880
see that they can't help but think this

00:13:28,720 --> 00:13:32,110
is magic and it is magic a bit and it's

00:13:30,880 --> 00:13:34,060
not what you'd expect and you don't

00:13:32,110 --> 00:13:35,560
understand where you have that and the

00:13:34,060 --> 00:13:38,380
reason for that is perfectly clear in a

00:13:35,560 --> 00:13:39,339
coherent it's even possible for some

00:13:38,380 --> 00:13:40,839
people to explain it I'm going to

00:13:39,339 --> 00:13:44,350
attempt it not sure was he going to get

00:13:40,839 --> 00:13:48,279
it but the reason this happened is that

00:13:44,350 --> 00:13:51,610
because here is going to try and find

00:13:48,279 --> 00:13:53,800
the closest possible subtypes that is

00:13:51,610 --> 00:13:55,810
super type that is common to both okay

00:13:53,800 --> 00:13:58,089
and that's okay one of these types is

00:13:55,810 --> 00:14:01,329
status because okay and not okay extent

00:13:58,089 --> 00:14:03,880
status but that's not all because by

00:14:01,329 --> 00:14:06,970
virtue of being case objects okay not

00:14:03,880 --> 00:14:08,529
okay also extend implicitly series of

00:14:06,970 --> 00:14:10,540
all and product which you don't need to

00:14:08,529 --> 00:14:13,240
know it's absolutely not interesting at

00:14:10,540 --> 00:14:16,870
all its implementation detail but it

00:14:13,240 --> 00:14:18,910
means that the least this abounds so the

00:14:16,870 --> 00:14:21,250
closest to the types that is common to

00:14:18,910 --> 00:14:22,569
both of them is product with serviceable

00:14:21,250 --> 00:14:26,440
with status it's an implementation

00:14:22,569 --> 00:14:27,399
details that leaks out to the user who

00:14:26,440 --> 00:14:30,279
really doesn't want to hear about that

00:14:27,399 --> 00:14:30,970
and who gets rican fused and when you

00:14:30,279 --> 00:14:32,650
have to explain

00:14:30,970 --> 00:14:35,590
what I just said to people who are

00:14:32,650 --> 00:14:37,450
learning Scala you lose about 50 percent

00:14:35,590 --> 00:14:39,430
of in there yeah okay skies a bit magic

00:14:37,450 --> 00:14:41,800
I don't want that let me get back to

00:14:39,430 --> 00:14:44,290
JavaScript so that doesn't really work

00:14:41,800 --> 00:14:48,090
and the way to trick the compiler into

00:14:44,290 --> 00:14:51,010
doing what you expect is to have your

00:14:48,090 --> 00:14:55,270
ADT extent product with variable because

00:14:51,010 --> 00:14:57,250
all of sudden magically okay do extend

00:14:55,270 --> 00:15:00,070
status and product is serviceable not

00:14:57,250 --> 00:15:02,320
okay as well but both of them but status

00:15:00,070 --> 00:15:05,650
is also a project that n is reasonable

00:15:02,320 --> 00:15:08,380
and so the least upper bound is going to

00:15:05,650 --> 00:15:12,520
be status so this works this behaviors

00:15:08,380 --> 00:15:17,310
expected there's kind of three kind of

00:15:12,520 --> 00:15:21,130
improves on that by trying to hide it so

00:15:17,310 --> 00:15:23,680
the enum keywords will by default not

00:15:21,130 --> 00:15:26,230
return the type that you expect a return

00:15:23,680 --> 00:15:28,690
the super type but it still can happen

00:15:26,230 --> 00:15:31,060
if you use that if you use constructors

00:15:28,690 --> 00:15:32,500
directly details are not super

00:15:31,060 --> 00:15:35,200
interesting if you want to read about

00:15:32,500 --> 00:15:36,670
that this is clickable once I link the

00:15:35,200 --> 00:15:39,220
slides at the end of the talk you can go

00:15:36,670 --> 00:15:41,590
and have a look at how this works but so

00:15:39,220 --> 00:15:44,650
dart makes this better but it's not

00:15:41,590 --> 00:15:51,400
fixed it's just kind of hidden under the

00:15:44,650 --> 00:15:54,880
rug that was your answer so what's the

00:15:51,400 --> 00:15:57,790
problem with that case class and the

00:15:54,880 --> 00:15:59,500
answer was this case is non final and if

00:15:57,790 --> 00:16:01,720
it's not final then you get really weird

00:15:59,500 --> 00:16:05,320
behaviors that was in a sense your

00:16:01,720 --> 00:16:09,340
answer right so an example of my

00:16:05,320 --> 00:16:11,200
behavior is foo being non final I'm

00:16:09,340 --> 00:16:13,510
allowed to extend it here and have

00:16:11,200 --> 00:16:16,390
created a class bar with two members I

00:16:13,510 --> 00:16:19,839
and S which are in some strings and I

00:16:16,390 --> 00:16:21,730
maps to Foos I personal problem and then

00:16:19,839 --> 00:16:24,160
we have the additional string member and

00:16:21,730 --> 00:16:27,010
this means that this code here is going

00:16:24,160 --> 00:16:29,920
to compile and it's going to return true

00:16:27,010 --> 00:16:34,110
which is not what anybody's saying would

00:16:29,920 --> 00:16:37,210
expect and I've actually taken the most

00:16:34,110 --> 00:16:38,740
obviously the easiest example to

00:16:37,210 --> 00:16:42,879
understand because what happens if you

00:16:38,740 --> 00:16:46,419
put these two whoops sorry

00:16:42,879 --> 00:16:46,929
back there if you put these two in a

00:16:46,419 --> 00:16:48,789
hashmap

00:16:46,929 --> 00:16:50,079
is that one of them is going to have

00:16:48,789 --> 00:16:51,729
already other and you're never going to

00:16:50,079 --> 00:16:53,919
figure out what and when that happens in

00:16:51,729 --> 00:16:58,119
production and you don't know why you're

00:16:53,919 --> 00:16:59,379
losing elements it's happened to me I

00:16:58,119 --> 00:17:02,169
hope it doesn't happen to you it's a

00:16:59,379 --> 00:17:03,759
proper nightmare so there's a reason for

00:17:02,169 --> 00:17:07,059
that because I promise then you know

00:17:03,759 --> 00:17:08,860
that it explained why this happens if

00:17:07,059 --> 00:17:13,289
some of you guys have some Java

00:17:08,860 --> 00:17:15,610
experience what happens here is that foo

00:17:13,289 --> 00:17:17,799
being a case class it gets a lot of

00:17:15,610 --> 00:17:20,949
synthetic code lots of methods generated

00:17:17,799 --> 00:17:23,519
for it such as equals to string hash

00:17:20,949 --> 00:17:26,589
code all these kind of things and so foo

00:17:23,519 --> 00:17:28,569
has an equals method that is implemented

00:17:26,589 --> 00:17:30,879
in a way that makes sense to basically

00:17:28,569 --> 00:17:32,350
wraps an int so if we have two foods I

00:17:30,879 --> 00:17:33,700
have to insert have the same values and

00:17:32,350 --> 00:17:36,730
both of them are equal and that makes

00:17:33,700 --> 00:17:41,110
sense but when you extend when you

00:17:36,730 --> 00:17:45,399
subtype foo then bar inherits from the

00:17:41,110 --> 00:17:47,139
same equals method and so when you call

00:17:45,399 --> 00:17:50,470
that the method that's going to be

00:17:47,139 --> 00:17:53,230
called is it's a method sorry this is a

00:17:50,470 --> 00:17:54,519
bit fiddly so maybe equals method

00:17:53,230 --> 00:17:58,210
defined in foo which doesn't even know

00:17:54,519 --> 00:18:00,100
there's an S field it's a string so this

00:17:58,210 --> 00:18:01,179
is absolutely normal this is exactly

00:18:00,100 --> 00:18:03,279
what's expected but you know what's

00:18:01,179 --> 00:18:04,240
going on it's also super confusing and

00:18:03,279 --> 00:18:09,820
then it really does make the language

00:18:04,240 --> 00:18:12,970
feel like magic so prefer making final

00:18:09,820 --> 00:18:15,039
case classes there's a reason why this

00:18:12,970 --> 00:18:16,299
is not the default it apparently is

00:18:15,039 --> 00:18:19,570
there's one person in the whole entire

00:18:16,299 --> 00:18:22,120
words so does declare non final case

00:18:19,570 --> 00:18:23,799
classes and has a use case from it that

00:18:22,120 --> 00:18:26,110
person is apparently much in other ski

00:18:23,799 --> 00:18:28,840
so when that happens you don't get to

00:18:26,110 --> 00:18:31,509
change it I wish I wish it did change

00:18:28,840 --> 00:18:34,840
but unfortunately that's nothing's

00:18:31,509 --> 00:18:36,730
changing in either 213 or dot e so when

00:18:34,840 --> 00:18:38,230
you declare a class make it final please

00:18:36,730 --> 00:18:42,879
that's going to save a lot of pain in

00:18:38,230 --> 00:18:44,950
the end custom extractors right does

00:18:42,879 --> 00:18:49,830
everybody know what's a custom extractor

00:18:44,950 --> 00:18:52,450
is I'll take that as a yes

00:18:49,830 --> 00:18:55,360
so what's going on here

00:18:52,450 --> 00:18:59,230
is on declaring an object extract some

00:18:55,360 --> 00:19:01,720
within an apply method for any sum he's

00:18:59,230 --> 00:19:03,520
going to return a value of type option

00:19:01,720 --> 00:19:07,480
of a and this allows me to use extracts

00:19:03,520 --> 00:19:10,060
I'm in a patent match and this is really

00:19:07,480 --> 00:19:14,890
very wrong and does anybody know why

00:19:10,060 --> 00:19:17,430
when I found out I I got kind of angry

00:19:14,890 --> 00:19:20,860
does anybody know what's wrong with that

00:19:17,430 --> 00:19:23,830
nope okay have fun

00:19:20,860 --> 00:19:26,620
working it out so what happens here when

00:19:23,830 --> 00:19:30,280
you do that this code here he's going to

00:19:26,620 --> 00:19:33,730
compile no problem even though it's

00:19:30,280 --> 00:19:36,340
quite clear that given the fact that my

00:19:33,730 --> 00:19:39,070
own apply method only takes a sum it's

00:19:36,340 --> 00:19:41,830
not defined for none it's quite clear

00:19:39,070 --> 00:19:47,290
that here if my o

00:19:41,830 --> 00:19:49,750
isn't none which can be Jesus this is

00:19:47,290 --> 00:19:51,850
going to crush at runtime because a

00:19:49,750 --> 00:19:54,660
pattern match is not exhaustive but the

00:19:51,850 --> 00:19:58,420
component doesn't know that somehow and

00:19:54,660 --> 00:20:00,730
this will fail at runtime it's perfectly

00:19:58,420 --> 00:20:04,630
valid code but the compiler cannot work

00:20:00,730 --> 00:20:08,410
out that it has a problem so so reason

00:20:04,630 --> 00:20:12,190
for that was explained to me baby boy is

00:20:08,410 --> 00:20:13,660
done to really work that thing and I'm

00:20:12,190 --> 00:20:15,520
not going to try to explain it so parent

00:20:13,660 --> 00:20:19,420
matching exhaustively checking is quite

00:20:15,520 --> 00:20:21,670
wonky in Scala 2.12 and in order to

00:20:19,420 --> 00:20:23,380
avoid this kind of problem that solution

00:20:21,670 --> 00:20:25,270
would be to never define custom

00:20:23,380 --> 00:20:28,510
extractors if you can do that but if you

00:20:25,270 --> 00:20:31,480
can't try to make irrefutable extractors

00:20:28,510 --> 00:20:34,150
return some resident option because that

00:20:31,480 --> 00:20:37,420
actually fixes the issue and you do get

00:20:34,150 --> 00:20:39,640
the expected warning here this kind of

00:20:37,420 --> 00:20:40,840
free makes this whole thing a lot better

00:20:39,640 --> 00:20:42,910
there have been a lot of research done

00:20:40,840 --> 00:20:46,120
on exhaustively checking for pattern

00:20:42,910 --> 00:20:48,040
matches and so the problem is completely

00:20:46,120 --> 00:20:49,720
gone in dot E and you don't need to

00:20:48,040 --> 00:20:51,520
worry about it as soon as you move to

00:20:49,720 --> 00:20:55,560
scale of free but until then be careful

00:20:51,520 --> 00:20:55,560
with custom extractors they're weird

00:20:56,130 --> 00:21:02,290
structural types do I need to give a

00:21:00,460 --> 00:21:04,510
quick quick explanation about what a

00:21:02,290 --> 00:21:05,590
structural type is does would anybody

00:21:04,510 --> 00:21:09,250
like that

00:21:05,590 --> 00:21:11,260
think up of nods okay structural typing

00:21:09,250 --> 00:21:13,060
is for those of you who have used

00:21:11,260 --> 00:21:16,120
dynamic languages this is duck typing

00:21:13,060 --> 00:21:18,250
but in a statically typed language this

00:21:16,120 --> 00:21:21,550
allows me to say that my add one method

00:21:18,250 --> 00:21:25,000
here will accept any type provided that

00:21:21,550 --> 00:21:28,270
type defines a def get methods that

00:21:25,000 --> 00:21:29,380
returns an int and then I can just call

00:21:28,270 --> 00:21:31,270
that method because the only thing I

00:21:29,380 --> 00:21:34,450
know about that x value is that it's got

00:21:31,270 --> 00:21:37,690
a cat method so I get that and add one

00:21:34,450 --> 00:21:39,790
that's what I returned and then

00:21:37,690 --> 00:21:41,680
conveniently I can define define this

00:21:39,790 --> 00:21:45,310
case class notice how its final

00:21:41,680 --> 00:21:46,900
important that wraps an int and define a

00:21:45,310 --> 00:21:49,540
get method or not and I'm completely

00:21:46,900 --> 00:21:53,100
allowed to pass wrapper to my advantage

00:21:49,540 --> 00:21:55,420
even though I have not defined any hard

00:21:53,100 --> 00:21:57,700
subtyping relationship so structural

00:21:55,420 --> 00:22:00,640
typing is a way to do subtyping without

00:21:57,700 --> 00:22:02,380
having to declare it beforehand it's

00:22:00,640 --> 00:22:04,990
quite convenient it's it's a great tool

00:22:02,380 --> 00:22:09,810
but in Scala is suffers from a few flaws

00:22:04,990 --> 00:22:14,560
does anybody know what the flows are yes

00:22:09,810 --> 00:22:16,390
right okay so the rent man said

00:22:14,560 --> 00:22:20,920
reflection which basically covers my to

00:22:16,390 --> 00:22:23,560
point this is implemented in Scala as

00:22:20,920 --> 00:22:26,680
reflection so the compiler knows this

00:22:23,560 --> 00:22:28,360
works because it knows everything that

00:22:26,680 --> 00:22:30,400
is in wrapper it knows that wrapper has

00:22:28,360 --> 00:22:32,500
occurred so it knows this can't fail but

00:22:30,400 --> 00:22:35,620
at runtime he's going to have to use

00:22:32,500 --> 00:22:39,490
reflection to dig into the values that I

00:22:35,620 --> 00:22:42,130
received extract a method object call

00:22:39,490 --> 00:22:43,930
that manually and this is much more

00:22:42,130 --> 00:22:45,520
expensive than not doing anything so it

00:22:43,930 --> 00:22:48,060
has a runtime cost it's not massive

00:22:45,520 --> 00:22:50,170
runtime cost and that should not

00:22:48,060 --> 00:22:52,300
discourage you from using structural

00:22:50,170 --> 00:22:56,170
typing when it makes sense but the other

00:22:52,300 --> 00:22:57,730
problem is that at least on the JVM this

00:22:56,170 --> 00:22:59,770
might not actually run at all because

00:22:57,730 --> 00:23:02,800
it's possible and Jai being in the JVM

00:22:59,770 --> 00:23:04,390
to disable runtime reflection as a

00:23:02,800 --> 00:23:06,250
configuration option through security

00:23:04,390 --> 00:23:07,510
managers so the compiler is going to

00:23:06,250 --> 00:23:08,950
compare that there's no problem with

00:23:07,510 --> 00:23:10,780
that code but I'll run time you're going

00:23:08,950 --> 00:23:12,130
to find out that you can't actually do

00:23:10,780 --> 00:23:14,610
that then you have no way of knowing

00:23:12,130 --> 00:23:14,610
that in advance

00:23:16,320 --> 00:23:23,580
so the preferred approach is type

00:23:20,340 --> 00:23:26,700
classes and I'm having a bit

00:23:23,580 --> 00:23:27,690
over-enthusiastic here so I don't think

00:23:26,700 --> 00:23:29,990
I have the time to go through all the

00:23:27,690 --> 00:23:32,250
slide if I go through this whole thing

00:23:29,990 --> 00:23:33,750
if anybody wants to know more about the

00:23:32,250 --> 00:23:35,940
type classes I'm going to explain that

00:23:33,750 --> 00:23:37,350
after the talk but I want to cover a few

00:23:35,940 --> 00:23:39,480
more of these before before we're

00:23:37,350 --> 00:23:40,679
stopped so I'm going to skip the

00:23:39,480 --> 00:23:42,360
explanation if you know what the type

00:23:40,679 --> 00:23:46,559
classes use that instead of a structural

00:23:42,360 --> 00:23:52,350
type and it's kind of free does overall

00:23:46,559 --> 00:23:54,000
the entire virtual type API but I don't

00:23:52,350 --> 00:23:56,070
think it changes the core of the issue

00:23:54,000 --> 00:23:58,830
because the default implementation still

00:23:56,070 --> 00:24:00,179
relies on reflection reflection and I

00:23:58,830 --> 00:24:02,040
don't see any ways that it could be

00:24:00,179 --> 00:24:03,360
anything but reflection from those cases

00:24:02,040 --> 00:24:06,710
I don't think it's going to be fixed

00:24:03,360 --> 00:24:06,710
it's improved that not fixed at all

00:24:07,400 --> 00:24:17,790
exceptions can anybody tell me what's

00:24:10,679 --> 00:24:19,910
wrong with these two bits of code come

00:24:17,790 --> 00:24:23,280
again

00:24:19,910 --> 00:24:24,960
right so persons might throw a number

00:24:23,280 --> 00:24:26,600
from that exception because most strings

00:24:24,960 --> 00:24:29,250
are not actually married integers and

00:24:26,600 --> 00:24:31,320
element at might thrown arraigned except

00:24:29,250 --> 00:24:34,860
an exception or some such thing because

00:24:31,320 --> 00:24:38,610
I might be outside of the arrays bound

00:24:34,860 --> 00:24:40,770
and the problem with exceptions well

00:24:38,610 --> 00:24:42,840
there's not very many problems with

00:24:40,770 --> 00:24:45,900
exceptions but the one I've chosen to

00:24:42,840 --> 00:24:48,900
focus on here our first thing is okay so

00:24:45,900 --> 00:24:50,429
this one is not entirely honest but it

00:24:48,900 --> 00:24:52,080
works wonders when you're trying to

00:24:50,429 --> 00:24:53,340
explain to other people so what happens

00:24:52,080 --> 00:24:54,929
very often is I'm working with a Java

00:24:53,340 --> 00:24:56,580
programmer reviewing the code that I

00:24:54,929 --> 00:24:58,710
wrote in Scala and when they get invited

00:24:56,580 --> 00:25:00,450
into itself for an exception and I'll

00:24:58,710 --> 00:25:02,250
point out that maybe don't want to throw

00:25:00,450 --> 00:25:03,900
an exception maybe exceptions should not

00:25:02,250 --> 00:25:05,850
be used and they look at me like I'm

00:25:03,900 --> 00:25:07,500
crazy I've been doing exceptions my

00:25:05,850 --> 00:25:08,840
whole life in Java why should not do

00:25:07,500 --> 00:25:11,940
that what's wrong with them

00:25:08,840 --> 00:25:13,530
and then what I do is I ask them okay

00:25:11,940 --> 00:25:16,470
would you use a go-to statement in your

00:25:13,530 --> 00:25:17,669
code course not nobody uses go-to

00:25:16,470 --> 00:25:19,260
statements there are famous papers

00:25:17,669 --> 00:25:21,630
written just about the fact that you

00:25:19,260 --> 00:25:23,220
should not be using go-to statements and

00:25:21,630 --> 00:25:24,960
then you ask but well then what's the

00:25:23,220 --> 00:25:26,520
difference between a go-to statement an

00:25:24,960 --> 00:25:27,780
exception can you explain to me what's

00:25:26,520 --> 00:25:30,020
the critical difference between the two

00:25:27,780 --> 00:25:33,550
all and most of the time I have

00:25:30,020 --> 00:25:36,170
they get playing for 30 seconds then oh

00:25:33,550 --> 00:25:39,170
okay and they get with the exception we

00:25:36,170 --> 00:25:40,640
carry on so this is not entirely honest

00:25:39,170 --> 00:25:42,260
on my part because there's very many

00:25:40,640 --> 00:25:46,210
differences between exceptions and go-to

00:25:42,260 --> 00:25:48,650
statements but there are a few critical

00:25:46,210 --> 00:25:50,870
similarities the first one is the

00:25:48,650 --> 00:25:52,670
problem with a go-to statement is when

00:25:50,870 --> 00:25:54,590
you're at the label or the go-to

00:25:52,670 --> 00:25:56,420
statement you have no idea where you're

00:25:54,590 --> 00:25:57,770
coming from you could come from anywhere

00:25:56,420 --> 00:25:59,780
in the source code so you don't know

00:25:57,770 --> 00:26:01,280
your state and this is something that

00:25:59,780 --> 00:26:02,690
you have exception as well you don't

00:26:01,280 --> 00:26:04,430
know where the exception was from you

00:26:02,690 --> 00:26:06,500
have no idea you might have mutable

00:26:04,430 --> 00:26:09,770
states that he's not gonna say could

00:26:06,500 --> 00:26:11,450
expect so you can't know and this is

00:26:09,770 --> 00:26:14,600
very similar between go-to statements

00:26:11,450 --> 00:26:16,130
and exceptions it's kind of inverse for

00:26:14,600 --> 00:26:18,680
exceptions because when you write a

00:26:16,130 --> 00:26:21,560
go-to statement the compiler is going to

00:26:18,680 --> 00:26:22,850
fall if there is no Associated label so

00:26:21,560 --> 00:26:24,410
you know when you write to go-to

00:26:22,850 --> 00:26:27,470
statement that is going to go somewhere

00:26:24,410 --> 00:26:29,150
with an exception is basically I'm going

00:26:27,470 --> 00:26:30,590
to bail out now somebody catch me

00:26:29,150 --> 00:26:34,250
otherwise crash don't know don't care

00:26:30,590 --> 00:26:35,390
your problem and it's even worse you

00:26:34,250 --> 00:26:37,970
don't know that anybody's going to

00:26:35,390 --> 00:26:40,340
handle it you can't you can't check that

00:26:37,970 --> 00:26:42,680
so that's the first reason why I don't

00:26:40,340 --> 00:26:44,390
like exceptions it's it's essentially a

00:26:42,680 --> 00:26:45,430
go-to statement for all the wrong things

00:26:44,390 --> 00:26:48,500
that matter

00:26:45,430 --> 00:26:49,910
it's unchecked in Scala so this is

00:26:48,500 --> 00:26:52,130
specific to Skylar and a few other

00:26:49,910 --> 00:26:54,740
languages but in some languages such as

00:26:52,130 --> 00:26:57,170
Java exceptions are part of the type

00:26:54,740 --> 00:26:59,420
signature of the method that declares n

00:26:57,170 --> 00:27:01,460
so the compiler can tell you

00:26:59,420 --> 00:27:02,600
well you haven't caught that exception

00:27:01,460 --> 00:27:04,370
you haven't dealt with that error case

00:27:02,600 --> 00:27:06,080
so please do that and otherwise I'm not

00:27:04,370 --> 00:27:08,510
going to compile but we skele the

00:27:06,080 --> 00:27:11,330
compiler completely ignores exception

00:27:08,510 --> 00:27:12,800
you have no way when you call the method

00:27:11,330 --> 00:27:16,040
that was an exception you have no way to

00:27:12,800 --> 00:27:17,750
know whether you have actually dealt

00:27:16,040 --> 00:27:19,370
with all possible error cases a mad

00:27:17,750 --> 00:27:22,070
crush on run time and you have no way of

00:27:19,370 --> 00:27:25,580
checking that and lastly it's

00:27:22,070 --> 00:27:27,620
referentially or PAC which is a very

00:27:25,580 --> 00:27:28,180
barbaric term which I'm going to explain

00:27:27,620 --> 00:27:32,120
now

00:27:28,180 --> 00:27:35,840
so referential transparent referential

00:27:32,120 --> 00:27:37,400
transparency is a property of code that

00:27:35,840 --> 00:27:40,250
we really like because it helps us

00:27:37,400 --> 00:27:42,870
reason about code at the local level it

00:27:40,250 --> 00:27:47,190
means that when you have

00:27:42,870 --> 00:27:49,200
an expression you can replace it by

00:27:47,190 --> 00:27:50,880
whatever it evaluates to without

00:27:49,200 --> 00:27:54,060
changing the meaning of the code so you

00:27:50,880 --> 00:27:55,650
can ignore whatever else goes on around

00:27:54,060 --> 00:27:57,150
the whole thing and focus on that

00:27:55,650 --> 00:27:59,190
expression that all that matters

00:27:57,150 --> 00:28:01,800
so an expression is said to be

00:27:59,190 --> 00:28:04,530
referentially transparents if you can

00:28:01,800 --> 00:28:06,000
replace put what it evaluates to in a

00:28:04,530 --> 00:28:07,770
variable then use the variable

00:28:06,000 --> 00:28:09,660
everywhere else and throwing an

00:28:07,770 --> 00:28:11,280
exception if it was refreshingly

00:28:09,660 --> 00:28:13,020
transparent wouldn't means that this to

00:28:11,280 --> 00:28:15,840
implementation would be the same because

00:28:13,020 --> 00:28:17,280
in that one I have a test that doesn't

00:28:15,840 --> 00:28:20,820
make much sense it's never going to be

00:28:17,280 --> 00:28:22,170
evaluated but if false is true then I'm

00:28:20,820 --> 00:28:25,230
going to throw an exception otherwise

00:28:22,170 --> 00:28:27,810
return to and the other implementation

00:28:25,230 --> 00:28:30,030
does the referential transparent test

00:28:27,810 --> 00:28:32,430
thing where it's going to put the result

00:28:30,030 --> 00:28:34,110
of that expression into a variable and

00:28:32,430 --> 00:28:36,120
then it's going to use them in the rest

00:28:34,110 --> 00:28:38,130
of the code then obviously that doesn't

00:28:36,120 --> 00:28:39,840
actually work out the first one we're

00:28:38,130 --> 00:28:42,210
evaluating terminate the second one

00:28:39,840 --> 00:28:45,150
fails so these two expressions are not

00:28:42,210 --> 00:28:47,130
equivalent and so throwing exceptions is

00:28:45,150 --> 00:28:48,900
not refresh a transparent and you don't

00:28:47,130 --> 00:28:52,820
want to desert in your code because it

00:28:48,900 --> 00:28:52,820
leads to all sorts of headaches

00:28:53,940 --> 00:28:58,710
you should eat as much as possible

00:28:55,890 --> 00:29:02,220
prefer encoding your error types inside

00:28:58,710 --> 00:29:05,370
of the return type of your view methods

00:29:02,220 --> 00:29:07,890
so concretely rather than throwing an

00:29:05,370 --> 00:29:10,530
exception if you want to convey the

00:29:07,890 --> 00:29:12,600
absence of a value return an option if

00:29:10,530 --> 00:29:15,210
you want if you have some sort of fancy

00:29:12,600 --> 00:29:17,040
error code or things like that put it in

00:29:15,210 --> 00:29:18,780
an either so the right side of the

00:29:17,040 --> 00:29:20,190
either is a successful path the left

00:29:18,780 --> 00:29:21,990
side of the user is worth

00:29:20,190 --> 00:29:26,160
it's the error code your message

00:29:21,990 --> 00:29:27,720
whatever and if you have if you

00:29:26,160 --> 00:29:29,670
absolutely have to work with exceptions

00:29:27,720 --> 00:29:32,340
like you're doing some Java interrupts

00:29:29,670 --> 00:29:35,070
for example try is going to help you

00:29:32,340 --> 00:29:36,660
it's basically a neither that contains

00:29:35,070 --> 00:29:38,700
an exception on the left so if you have

00:29:36,660 --> 00:29:40,190
to use exceptions use a try rather than

00:29:38,700 --> 00:29:43,170
Anisa

00:29:40,190 --> 00:29:47,940
and unfortunately nothing changed in

00:29:43,170 --> 00:29:49,590
dotty about that now I was starting to

00:29:47,940 --> 00:29:55,230
put together things that we have said

00:29:49,590 --> 00:29:56,870
before this is one almost completely

00:29:55,230 --> 00:29:59,960
varied way of encoding

00:29:56,870 --> 00:30:03,830
so this is a very simplified ADT which

00:29:59,960 --> 00:30:05,990
we talked about before which is meant to

00:30:03,830 --> 00:30:08,360
encode all possible error cases when you

00:30:05,990 --> 00:30:09,530
try to connect it to a database and in

00:30:08,360 --> 00:30:11,390
order for the whole thing to fit in one

00:30:09,530 --> 00:30:13,670
slide I've just declared two possible

00:30:11,390 --> 00:30:15,470
implementation one which is the sequel

00:30:13,670 --> 00:30:17,750
you try to run it's not valid and the

00:30:15,470 --> 00:30:20,030
other one is try to connect but lost the

00:30:17,750 --> 00:30:22,910
connection please try again and

00:30:20,030 --> 00:30:24,830
something is not ideal with that

00:30:22,910 --> 00:30:26,600
implementation but you know it does have

00:30:24,830 --> 00:30:28,460
all the thing I've said so far it's a

00:30:26,600 --> 00:30:30,440
cell trait it extends products we say

00:30:28,460 --> 00:30:32,600
reasonable case objects everywhere it

00:30:30,440 --> 00:30:34,600
sits it follows all the rules have given

00:30:32,600 --> 00:30:38,030
so far but it's still not quite right

00:30:34,600 --> 00:30:43,610
does anyone know why or how you could

00:30:38,030 --> 00:30:46,910
improve on that okay the problem is a

00:30:43,610 --> 00:30:48,920
lot of API in the standard library rely

00:30:46,910 --> 00:30:51,530
on exceptions to convey errors mostly

00:30:48,920 --> 00:30:53,330
try in future and you have lots of

00:30:51,530 --> 00:30:56,510
libraries that will use future or will

00:30:53,330 --> 00:30:59,510
use try and you can't stick your DB here

00:30:56,510 --> 00:31:02,390
error in that of inside of you to try

00:30:59,510 --> 00:31:04,040
so in order to work around that what

00:31:02,390 --> 00:31:06,290
you're absolutely allowed to do is use

00:31:04,040 --> 00:31:10,580
exceptions but you're not throwing them

00:31:06,290 --> 00:31:14,030
just tagging your type just tagging your

00:31:10,580 --> 00:31:17,090
type with an exception and so DB error

00:31:14,030 --> 00:31:19,930
is now an exception which product answer

00:31:17,090 --> 00:31:23,410
usable and you can absolutely stick

00:31:19,930 --> 00:31:26,570
values of type DB error in the left or

00:31:23,410 --> 00:31:29,450
in a tribe's array or in the future it's

00:31:26,570 --> 00:31:31,460
not a problem at all so they have a

00:31:29,450 --> 00:31:33,620
trick that but it allows your exceptions

00:31:31,460 --> 00:31:37,780
ADT is to be a lot more usable when

00:31:33,620 --> 00:31:37,780
interacting with the standard library

00:31:38,740 --> 00:31:47,490
right now the return keyword okay what's

00:31:44,110 --> 00:31:47,490
wrong with that aside from everything

00:31:49,290 --> 00:31:54,700
well done the return keyword so there's

00:31:52,570 --> 00:31:57,580
lots and lots and lots of reasons to not

00:31:54,700 --> 00:31:58,810
want to use written we have the whole

00:31:57,580 --> 00:32:00,970
go-to statement thing again it's

00:31:58,810 --> 00:32:02,710
basically same discussion direct

00:32:00,970 --> 00:32:04,390
referential transparency again same

00:32:02,710 --> 00:32:07,270
discussion but mostly it's just

00:32:04,390 --> 00:32:13,120
completely insane it doesn't not at all

00:32:07,270 --> 00:32:14,410
do what you think it does coming in up

00:32:13,120 --> 00:32:21,040
well we're going to go through that

00:32:14,410 --> 00:32:23,140
right so this code here looks kind of

00:32:21,040 --> 00:32:24,970
sane this is what somebody who's come

00:32:23,140 --> 00:32:27,400
from JavaScript for example Matt right

00:32:24,970 --> 00:32:30,010
it makes a lot of sense you have a list

00:32:27,400 --> 00:32:31,510
of int and you want to map on it and add

00:32:30,010 --> 00:32:33,580
one to absolutely every single value in

00:32:31,510 --> 00:32:36,970
it so you create an enemies function

00:32:33,580 --> 00:32:38,440
which returns n plus 1 I unless you know

00:32:36,970 --> 00:32:41,080
to look for return this makes a lot of

00:32:38,440 --> 00:32:43,780
sense but the compiler doesn't quite

00:32:41,080 --> 00:32:45,490
agree it's telling me that I've said it

00:32:43,780 --> 00:32:48,310
was a list event but we should be an int

00:32:45,490 --> 00:32:50,020
that doesn't make much sense to me

00:32:48,310 --> 00:32:52,690
mapping in a list should return the list

00:32:50,020 --> 00:32:54,640
but compiler is often more smart than I

00:32:52,690 --> 00:32:56,800
am so I'm going to trust it and play

00:32:54,640 --> 00:32:58,930
along so I do what he does well he

00:32:56,800 --> 00:33:02,080
suggests and now this is not a list of

00:32:58,930 --> 00:33:05,470
incidents new complaint should sorry

00:33:02,080 --> 00:33:07,420
should be list of nothing when nothing

00:33:05,470 --> 00:33:10,600
occurs in the type that you have

00:33:07,420 --> 00:33:12,760
inferred something's really really wrong

00:33:10,600 --> 00:33:14,260
and I have no idea what's happening here

00:33:12,760 --> 00:33:17,440
but I'm just going to follow zero

00:33:14,260 --> 00:33:19,060
messages back to it well you found a

00:33:17,440 --> 00:33:21,340
list of nothing but I really wanted an

00:33:19,060 --> 00:33:21,940
end to what the hell so I don't know

00:33:21,340 --> 00:33:23,410
what's going on

00:33:21,940 --> 00:33:24,760
I don't want to know what's going on I

00:33:23,410 --> 00:33:29,140
don't want to understand what's going on

00:33:24,760 --> 00:33:30,370
I use return it makes no sense you're

00:33:29,140 --> 00:33:32,170
going to try to understand at some point

00:33:30,370 --> 00:33:33,580
you won't you will fail you will you

00:33:32,170 --> 00:33:35,020
will remember that slide and you will

00:33:33,580 --> 00:33:36,730
think I should not have tried to

00:33:35,020 --> 00:33:41,170
understand it don't don't do it

00:33:36,730 --> 00:33:46,360
it's a nightmare don't use return ever

00:33:41,170 --> 00:33:48,610
just scrub it and there are possible

00:33:46,360 --> 00:33:50,890
improvement in scanner free in that

00:33:48,610 --> 00:33:52,040
non-local return statement might be

00:33:50,890 --> 00:33:53,690
forbidden I

00:33:52,040 --> 00:33:58,910
and what that means so maybe it's a good

00:33:53,690 --> 00:34:02,840
thing I don't know implicit conversions

00:33:58,910 --> 00:34:06,560
right so this here a method defined as

00:34:02,840 --> 00:34:08,450
implicit means that it's an implicit

00:34:06,560 --> 00:34:12,620
conversion so whenever the compiler is

00:34:08,450 --> 00:34:14,720
going to find a string that he would

00:34:12,620 --> 00:34:16,790
like to be an int he's going to call

00:34:14,720 --> 00:34:17,380
this method and turn my string into an

00:34:16,790 --> 00:34:20,120
end

00:34:17,380 --> 00:34:21,710
this looks pretty nice it's pretty it's

00:34:20,120 --> 00:34:27,770
very fun do you know what's wrong with

00:34:21,710 --> 00:34:30,470
that right so if you muttering it I'm

00:34:27,770 --> 00:34:35,570
not going to hear it without you I came

00:34:30,470 --> 00:34:37,639
up with the answer oh absolutely will

00:34:35,570 --> 00:34:39,500
for an exception because it lets you

00:34:37,639 --> 00:34:41,240
write beautiful code like that foo bar

00:34:39,500 --> 00:34:43,460
divided by 2 and the compiler is going

00:34:41,240 --> 00:34:45,770
to be very happy to compile that and

00:34:43,460 --> 00:34:47,659
carry on as if nothing happened and this

00:34:45,770 --> 00:34:49,340
is basically you lying to the compiler

00:34:47,659 --> 00:34:51,139
returning it right I know better than

00:34:49,340 --> 00:34:54,200
you do this string it's actually an int

00:34:51,139 --> 00:34:56,690
and this is most of the time not true

00:34:54,200 --> 00:34:58,460
there are infinitely many strings and

00:34:56,690 --> 00:35:00,800
infinitely many more strings that are

00:34:58,460 --> 00:35:02,690
not instance ensuring there are inch so

00:35:00,800 --> 00:35:05,060
this is going to break eventually sooner

00:35:02,690 --> 00:35:05,600
rather than later and you never want to

00:35:05,060 --> 00:35:08,030
do that

00:35:05,600 --> 00:35:12,890
the main problem being that this

00:35:08,030 --> 00:35:15,320
implicit conversion is not total so if

00:35:12,890 --> 00:35:18,920
this was total so say transform ins into

00:35:15,320 --> 00:35:20,270
floats it's iffy but it's ok because it

00:35:18,920 --> 00:35:21,320
can't fail at runtime still weird if

00:35:20,270 --> 00:35:23,660
you're getting the types to lie to each

00:35:21,320 --> 00:35:25,250
other but it will not fail at runtime

00:35:23,660 --> 00:35:31,490
but this is this is horrible I don't

00:35:25,250 --> 00:35:35,480
want to do that instead well you could

00:35:31,490 --> 00:35:37,010
do this remaster thing sorry you could

00:35:35,480 --> 00:35:40,550
do this rhiness to think and be explicit

00:35:37,010 --> 00:35:42,770
about your conversions or you could just

00:35:40,550 --> 00:35:46,510
try not to divide foobar ways to could

00:35:42,770 --> 00:35:46,510
make much sense it's also a possibility

00:35:46,540 --> 00:35:53,570
so this is at least in Scala - there's a

00:35:51,890 --> 00:35:55,970
reason to have implicit conversions is

00:35:53,570 --> 00:35:59,060
this is how all libraries are exposed

00:35:55,970 --> 00:36:00,710
Ted classes will allow you to add syntax

00:35:59,060 --> 00:36:02,030
this is how you can have the map method

00:36:00,710 --> 00:36:03,730
when you have a factor instance for

00:36:02,030 --> 00:36:05,619
example it's very nice

00:36:03,730 --> 00:36:08,680
implicit conversions to enrich existing

00:36:05,619 --> 00:36:11,440
types existing types are okay they're

00:36:08,680 --> 00:36:13,869
also completely unneeded in Scala free

00:36:11,440 --> 00:36:16,359
because you have extension methods so as

00:36:13,869 --> 00:36:17,950
soon as color free happens stop using

00:36:16,359 --> 00:36:19,240
visit conversions the compiler is going

00:36:17,950 --> 00:36:20,859
to fight you over it anyway because it's

00:36:19,240 --> 00:36:22,660
going to ask you to enable the

00:36:20,859 --> 00:36:25,150
compilation flag and then to be very

00:36:22,660 --> 00:36:28,030
explicit about it this kind of free

00:36:25,150 --> 00:36:31,200
implicit conversions are kind of frowned

00:36:28,030 --> 00:36:31,200
upon and this is a good thing

00:36:31,980 --> 00:36:38,440
implicit resolution so I'm going to go

00:36:37,450 --> 00:36:41,890
through that one directly because it's a

00:36:38,440 --> 00:36:44,710
bit subtle what happens here is after

00:36:41,890 --> 00:36:46,330
define a type config which contains a

00:36:44,710 --> 00:36:48,520
port for some sort of network

00:36:46,330 --> 00:36:52,540
configuration and I've defined a get

00:36:48,520 --> 00:36:54,220
port method that for any config value in

00:36:52,540 --> 00:36:56,530
scope is going to return the port so

00:36:54,220 --> 00:36:58,690
that way you could implement a default

00:36:56,530 --> 00:37:00,550
configuration here so by default my

00:36:58,690 --> 00:37:05,320
configuration is going to have port 8080

00:37:00,550 --> 00:37:06,880
and if I call get port like that then is

00:37:05,320 --> 00:37:09,100
going to work out that the default

00:37:06,880 --> 00:37:10,690
implementation here and your default

00:37:09,100 --> 00:37:12,700
port is going to be 8080 it's quite

00:37:10,690 --> 00:37:16,540
convenient mechanism but in skylight

00:37:12,700 --> 00:37:19,540
suffers from a pretty big problem which

00:37:16,540 --> 00:37:23,109
has to do with implicit shadowing so

00:37:19,540 --> 00:37:25,240
here in another object I define a new

00:37:23,109 --> 00:37:29,170
implicit value of a completely different

00:37:25,240 --> 00:37:32,109
type default config here is of type

00:37:29,170 --> 00:37:34,480
config default config here is of type

00:37:32,109 --> 00:37:37,359
int the only thing they have in common

00:37:34,480 --> 00:37:40,540
is their name and that should not have

00:37:37,359 --> 00:37:43,270
an impact then the name of a term when

00:37:40,540 --> 00:37:45,250
you resolve type but it does when you

00:37:43,270 --> 00:37:46,840
import both a1 and a2 you get the

00:37:45,250 --> 00:37:49,030
dreaded could not find implicit value

00:37:46,840 --> 00:37:51,790
for parameter blah blah blah and this is

00:37:49,030 --> 00:37:54,670
very confusing because this is not what

00:37:51,790 --> 00:37:56,020
you'd expect it's actually quite clear

00:37:54,670 --> 00:37:58,030
what happens when you remove the

00:37:56,020 --> 00:38:00,910
implicitness of this if you were to

00:37:58,030 --> 00:38:02,560
import both a1 and a2 and ask the

00:38:00,910 --> 00:38:03,790
compiler to use the full config is going

00:38:02,560 --> 00:38:06,609
to tell you well it's ambiguous

00:38:03,790 --> 00:38:08,410
I have it both from a1 and a2 which one

00:38:06,609 --> 00:38:10,720
do you want to use and this is very

00:38:08,410 --> 00:38:11,800
clear this error message so when I don't

00:38:10,720 --> 00:38:14,200
have an implicit

00:38:11,800 --> 00:38:14,970
thing stuck in the middle I understand

00:38:14,200 --> 00:38:18,530
what happens

00:38:14,970 --> 00:38:21,060
but what actually happens is you get

00:38:18,530 --> 00:38:24,630
could not find miss Perry for parameter

00:38:21,060 --> 00:38:25,800
and this is black magic to most people

00:38:24,630 --> 00:38:28,319
who start learning the language

00:38:25,800 --> 00:38:31,880
this is extremely confusing and the bad

00:38:28,319 --> 00:38:34,829
news there is no real workaround

00:38:31,880 --> 00:38:36,630
provided that you don't have a perfectly

00:38:34,829 --> 00:38:38,640
unique name it's going to happen

00:38:36,630 --> 00:38:39,630
eventually and you can't guarantee that

00:38:38,640 --> 00:38:41,339
you're going to have a completely unique

00:38:39,630 --> 00:38:41,730
name anybody can be using same name as

00:38:41,339 --> 00:38:45,690
you

00:38:41,730 --> 00:38:47,190
and with worse thing is here when you do

00:38:45,690 --> 00:38:49,260
that you might not know that a -

00:38:47,190 --> 00:38:51,359
declares an implicit value of the wrong

00:38:49,260 --> 00:38:52,829
name so you might have no idea that you

00:38:51,359 --> 00:38:53,760
causing the problem you don't know what

00:38:52,829 --> 00:38:55,980
you're importing because you're

00:38:53,760 --> 00:38:57,750
importing everything so this is very

00:38:55,980 --> 00:39:01,020
confusing to beginners and what happens

00:38:57,750 --> 00:39:02,640
it's a nightmare to explain it so when

00:39:01,020 --> 00:39:04,770
you do it when you have to declare

00:39:02,640 --> 00:39:07,440
implicit values give them city names

00:39:04,770 --> 00:39:10,440
really long names with with your name in

00:39:07,440 --> 00:39:13,290
it Nicholas's fancy fubar instance for

00:39:10,440 --> 00:39:14,730
type int look city but the whole point

00:39:13,290 --> 00:39:16,380
it's an implicit value nobody's going to

00:39:14,730 --> 00:39:18,450
see the name use not supposed to many

00:39:16,380 --> 00:39:20,339
play the names of implicit values so so

00:39:18,450 --> 00:39:21,960
it's not a problem but it's still not

00:39:20,339 --> 00:39:23,220
perfect somebody might also be called

00:39:21,960 --> 00:39:24,000
Nikolas and have the same naming

00:39:23,220 --> 00:39:26,790
convention as I do

00:39:24,000 --> 00:39:30,210
so that might still be a problem luckily

00:39:26,790 --> 00:39:31,890
in Scala 3 first you have import implied

00:39:30,210 --> 00:39:34,440
which means you know that you imply

00:39:31,890 --> 00:39:37,079
importing implicit into implicit values

00:39:34,440 --> 00:39:39,210
so it's less likely to happen because

00:39:37,079 --> 00:39:41,460
you can't do it by mistake but more

00:39:39,210 --> 00:39:43,079
importantly implicit name shadowing

00:39:41,460 --> 00:39:44,819
doesn't exist so the problem just

00:39:43,079 --> 00:39:50,000
completely gone in scot-free so it's

00:39:44,819 --> 00:39:52,890
major improvement string concatenation

00:39:50,000 --> 00:39:55,069
can anybody tell me what's wrong with

00:39:52,890 --> 00:39:55,069
that

00:39:57,710 --> 00:40:04,849
excuse me okay well um here string

00:40:02,960 --> 00:40:06,859
concatenation I'm using plus to do

00:40:04,849 --> 00:40:10,609
string quick animation this is this is a

00:40:06,859 --> 00:40:12,619
mistake because plus he's kind of insane

00:40:10,609 --> 00:40:15,319
it doesn't behave very coherently so

00:40:12,619 --> 00:40:18,230
here I have a list of string and I plus

00:40:15,319 --> 00:40:20,000
bar it so I do not string to it and this

00:40:18,230 --> 00:40:22,430
is going to return a string which has a

00:40:20,000 --> 00:40:24,079
value not super interesting but it's

00:40:22,430 --> 00:40:27,079
going to do that on the other hand if I

00:40:24,079 --> 00:40:28,670
have a set of strings and a bar that

00:40:27,079 --> 00:40:31,069
it's going to add it to the collection

00:40:28,670 --> 00:40:35,210
and it doesn't have the same type at all

00:40:31,069 --> 00:40:36,890
so this is weird when you know what

00:40:35,210 --> 00:40:37,309
happens underneath you understand it

00:40:36,890 --> 00:40:39,950
then you go

00:40:37,309 --> 00:40:40,970
of course without thinking but when try

00:40:39,950 --> 00:40:43,700
to explain that to somebody who's

00:40:40,970 --> 00:40:45,230
learning the language of course it

00:40:43,700 --> 00:40:46,400
behaved that way could not work out why

00:40:45,230 --> 00:40:47,720
the person is going to look at you like

00:40:46,400 --> 00:40:49,760
you're nuts and he's going to go away

00:40:47,720 --> 00:40:51,410
never discolor anymore

00:40:49,760 --> 00:40:54,740
and I'm not even talking about these

00:40:51,410 --> 00:40:57,319
absolute nightmare where you add to a

00:40:54,740 --> 00:41:01,069
list of int and the compilation error is

00:40:57,319 --> 00:41:03,529
well I expected a string why why would

00:41:01,069 --> 00:41:05,779
you expect a string again it makes sense

00:41:03,529 --> 00:41:07,730
when you know that any two string add

00:41:05,779 --> 00:41:10,160
either thing if you do know that any

00:41:07,730 --> 00:41:10,730
string add it does exist and you know

00:41:10,160 --> 00:41:12,589
what it does

00:41:10,730 --> 00:41:17,529
I'm sorry for your pain I went through

00:41:12,589 --> 00:41:20,660
it as well I think it's deprecated it is

00:41:17,529 --> 00:41:23,569
deprecated in 2013 has been removed from

00:41:20,660 --> 00:41:27,049
2014 magically back in Scala free I'm

00:41:23,569 --> 00:41:29,089
not sure why I think is going to I think

00:41:27,049 --> 00:41:31,520
it's just that error free hasn't been

00:41:29,089 --> 00:41:35,779
rebased on to the two dots in standard

00:41:31,520 --> 00:41:39,589
library I hope I hope but so instead

00:41:35,779 --> 00:41:42,680
don't use string concatenation use

00:41:39,589 --> 00:41:45,380
string interpolation instead this is

00:41:42,680 --> 00:41:46,789
first I find a lot more readable and it

00:41:45,380 --> 00:41:49,039
doesn't have the same problem because

00:41:46,789 --> 00:41:50,539
it's not using plus and also yesterday

00:41:49,039 --> 00:41:52,970
Daniel I was making the point that

00:41:50,539 --> 00:41:55,099
string concatenation is much slower than

00:41:52,970 --> 00:41:58,400
string interpolation so there's as well

00:41:55,099 --> 00:42:05,079
if you if you care about efficiency use

00:41:58,400 --> 00:42:05,079
string interpolation in conclusion

00:42:05,299 --> 00:42:10,770
how do we enforce best practices how do

00:42:08,880 --> 00:42:12,059
we make sure that all of this stuff that

00:42:10,770 --> 00:42:12,869
I have shown you and there's a lot more

00:42:12,059 --> 00:42:15,150
where that came from

00:42:12,869 --> 00:42:17,910
I've just picked the best how do we make

00:42:15,150 --> 00:42:22,079
sure that this thing doesn't crop up in

00:42:17,910 --> 00:42:23,730
your code well first code reviews I know

00:42:22,079 --> 00:42:25,920
that a lot of people don't actually like

00:42:23,730 --> 00:42:28,500
Kirby news but there's some very solid

00:42:25,920 --> 00:42:30,779
research that proves that code reviews

00:42:28,500 --> 00:42:32,849
actually does drastically reduce the

00:42:30,779 --> 00:42:34,349
amount of defects in software so when

00:42:32,849 --> 00:42:36,420
you get a slide you can click that it's

00:42:34,349 --> 00:42:39,059
going to link you to the publication's

00:42:36,420 --> 00:42:40,799
to that effect do code reviews it's

00:42:39,059 --> 00:42:42,750
great and it helps you avoid these

00:42:40,799 --> 00:42:46,049
things and it helps you teach them to

00:42:42,750 --> 00:42:48,480
people who don't know them use tools

00:42:46,049 --> 00:42:50,809
that automate the finding of these

00:42:48,480 --> 00:42:53,520
problems so that's a bunch of that's I

00:42:50,809 --> 00:42:55,829
think I think that at the moment that's

00:42:53,520 --> 00:42:57,690
all that exists but the landscape keeps

00:42:55,829 --> 00:42:58,950
changing and we're Perry big on Tooting

00:42:57,690 --> 00:43:00,329
at the moment so I wouldn't be surprised

00:42:58,950 --> 00:43:02,910
that by next week we have another one

00:43:00,329 --> 00:43:06,450
but at the moment we've got scapegoat

00:43:02,910 --> 00:43:08,130
what remover scale info scaler style so

00:43:06,450 --> 00:43:10,380
can I say especially if you go through

00:43:08,130 --> 00:43:13,619
Rubner issues personal subject which

00:43:10,380 --> 00:43:16,230
makes us kind of kind of sane again and

00:43:13,619 --> 00:43:17,880
calorific so all these tools are going

00:43:16,230 --> 00:43:19,859
to make your code much much more

00:43:17,880 --> 00:43:20,880
reliable also switch to scalar free as

00:43:19,859 --> 00:43:23,250
soon as you can because that you could

00:43:20,880 --> 00:43:30,630
see it fixed a lot of the problems that

00:43:23,250 --> 00:43:33,059
that I had this were my favorite but

00:43:30,630 --> 00:43:34,190
well either bad or best practices

00:43:33,059 --> 00:43:37,020
depending on which way you look at it

00:43:34,190 --> 00:43:39,089
there's a lot more than them and I'm

00:43:37,020 --> 00:43:42,210
pretty sure I don't know all of them so

00:43:39,089 --> 00:43:43,289
if you guys have things that you think I

00:43:42,210 --> 00:43:44,880
should have talked about and I haven't

00:43:43,289 --> 00:43:46,529
I'd love to hear about them and I'd love

00:43:44,880 --> 00:43:49,859
to learn a bit more and I'd love to

00:43:46,529 --> 00:43:51,329
include them into my next version of

00:43:49,859 --> 00:43:54,599
this talk or into the website that I've

00:43:51,329 --> 00:43:56,730
created to go with that I wanted to

00:43:54,599 --> 00:43:59,339
thank these color contributors and

00:43:56,730 --> 00:44:01,680
Dottie get a channel especially a mouth

00:43:59,339 --> 00:44:04,109
I don't know whether he's here but he's

00:44:01,680 --> 00:44:06,000
basically written all of the future

00:44:04,109 --> 00:44:08,250
improvement sections he's basically

00:44:06,000 --> 00:44:09,990
leaving database we never asked

00:44:08,250 --> 00:44:11,819
something like how does that work oh not

00:44:09,990 --> 00:44:13,589
a problem here publication here to get

00:44:11,819 --> 00:44:15,150
here mud requests five seconds he knew

00:44:13,589 --> 00:44:17,000
zero rails by heart I don't know he does

00:44:15,150 --> 00:44:19,130
so he's really quite impressive

00:44:17,000 --> 00:44:21,290
but if you're wondering about its kind

00:44:19,130 --> 00:44:22,430
of weirdness in the language or how

00:44:21,290 --> 00:44:24,200
these winners are going to be fixed in

00:44:22,430 --> 00:44:28,820
the future these together channels are

00:44:24,200 --> 00:44:30,290
really really great more information so

00:44:28,820 --> 00:44:37,460
the slides are already available here

00:44:30,290 --> 00:44:40,640
and if you want to have proper articles

00:44:37,460 --> 00:44:43,310
on all of these rules and more there's a

00:44:40,640 --> 00:44:45,050
companion site at this URL where I took

00:44:43,310 --> 00:44:48,380
the time to write these things down

00:44:45,050 --> 00:44:50,599
properly not just a slide can follow me

00:44:48,380 --> 00:44:52,550
on Twitter I work the Phaedo blah blah

00:44:50,599 --> 00:44:54,770
blah this is all done with remote by

00:44:52,550 --> 00:44:57,200
Rimmel Gia's and I don't know if Robin

00:44:54,770 --> 00:44:59,420
are still here I saw him before

00:44:57,200 --> 00:45:01,460
chat is an amazing tool that will make

00:44:59,420 --> 00:45:03,859
sure that all the code is so in these

00:45:01,460 --> 00:45:05,390
slides is correct and evaluates to what

00:45:03,859 --> 00:45:07,310
you've seen because it's actually

00:45:05,390 --> 00:45:08,630
executed when the slides are compiled so

00:45:07,310 --> 00:45:12,740
it's not possible to get it's like to

00:45:08,630 --> 00:45:18,520
compile and not show the truth and do we

00:45:12,740 --> 00:45:18,520
have any questions thanks

00:45:22,500 --> 00:45:32,710
[Applause]

00:45:23,970 --> 00:45:36,820
yes yes thank you thank you first and I

00:45:32,710 --> 00:45:39,310
have a question raises color fix and is

00:45:36,820 --> 00:45:42,300
it possible to add such cases what you

00:45:39,310 --> 00:45:44,410
described to be automatically reported

00:45:42,300 --> 00:45:46,180
right so that's the point of the

00:45:44,410 --> 00:45:47,590
automated tool so was the first part of

00:45:46,180 --> 00:45:50,530
the question where is color fix because

00:45:47,590 --> 00:45:54,070
wait what is or where is what is what

00:45:50,530 --> 00:45:56,410
you question what is good coming in okay

00:45:54,070 --> 00:45:58,150
right and so these tools will

00:45:56,410 --> 00:45:59,860
automatically analyze the code and

00:45:58,150 --> 00:46:02,290
failed your build if they find one of

00:45:59,860 --> 00:46:04,240
these parents they're pretty opinionated

00:46:02,290 --> 00:46:07,990
what remover in particular is really

00:46:04,240 --> 00:46:09,880
hardcore a reports you can turn off some

00:46:07,990 --> 00:46:11,740
some things that you might not agree

00:46:09,880 --> 00:46:13,540
with for example I know that what

00:46:11,740 --> 00:46:16,030
remover is going to fall any code that

00:46:13,540 --> 00:46:17,440
defines default value for methods but

00:46:16,030 --> 00:46:18,850
sometimes quite important to have them

00:46:17,440 --> 00:46:22,240
so I don't actually agree with that what

00:46:18,850 --> 00:46:24,910
so but but all these tools will fail

00:46:22,240 --> 00:46:26,320
your builds if they find some sort of

00:46:24,910 --> 00:46:28,090
pattern and you can pick and choose and

00:46:26,320 --> 00:46:29,410
add whatever you want and get I mean I

00:46:28,090 --> 00:46:33,150
think that all the things I showed here

00:46:29,410 --> 00:46:33,150
are reported by one of these tools

00:46:34,050 --> 00:46:37,320
gentleman in the back

00:46:44,040 --> 00:46:54,390
I have a question about using try I mean

00:46:51,780 --> 00:46:59,250
in every place where exception may

00:46:54,390 --> 00:47:08,820
happen I have a experience that such

00:46:59,250 --> 00:47:13,080
pure way may occur in some try orgy so

00:47:08,820 --> 00:47:16,770
you write a code and you'll end with

00:47:13,080 --> 00:47:20,150
code where in every place you should

00:47:16,770 --> 00:47:26,070
somehow handle a try

00:47:20,150 --> 00:47:29,040
didn't you think that do you have any

00:47:26,070 --> 00:47:32,940
experience that maybe it will be some

00:47:29,040 --> 00:47:34,680
threshold that okay in these cases I

00:47:32,940 --> 00:47:38,580
should use a try

00:47:34,680 --> 00:47:41,340
but there are some cases where throw

00:47:38,580 --> 00:47:43,380
exception is completely okay right

00:47:41,340 --> 00:47:47,250
absolutely this is a very good question

00:47:43,380 --> 00:47:49,710
so exceptions are absolutely ok provided

00:47:47,250 --> 00:47:52,410
they actually are exceptional so if you

00:47:49,710 --> 00:47:54,660
run into an error such as CPU not found

00:47:52,410 --> 00:47:55,770
it's ok to crush your prime not going to

00:47:54,660 --> 00:47:58,440
be able to recover from that

00:47:55,770 --> 00:48:00,960
but the exam for the game here where for

00:47:58,440 --> 00:48:02,880
example string to int and number for

00:48:00,960 --> 00:48:05,070
that exception most strings are not in

00:48:02,880 --> 00:48:07,110
s-- it's not the exceptional case it's a

00:48:05,070 --> 00:48:08,760
common case that this is a failure so

00:48:07,110 --> 00:48:10,740
this is not an exceptional exception

00:48:08,760 --> 00:48:12,390
it's an expected exception and you

00:48:10,740 --> 00:48:14,340
should not use an exception for that you

00:48:12,390 --> 00:48:15,660
should use a return type but for

00:48:14,340 --> 00:48:19,830
anything that you're not likely to

00:48:15,660 --> 00:48:20,580
survive from or that just doesn't make

00:48:19,830 --> 00:48:23,340
any sense

00:48:20,580 --> 00:48:25,860
just let that go absolutely let fatal

00:48:23,340 --> 00:48:27,570
errors be from that's not a problem at

00:48:25,860 --> 00:48:29,100
all don't we have much of a choice

00:48:27,570 --> 00:48:33,660
anyway I mean you don't have a seat to

00:48:29,100 --> 00:48:37,400
you just what am I gonna do anyway and

00:48:33,660 --> 00:48:39,750
for the question the man over there oh

00:48:37,400 --> 00:48:41,640
sorry right ok so I don't have time for

00:48:39,750 --> 00:48:42,960
public questions I will be here if you

00:48:41,640 --> 00:48:46,200
have further question don't hesitate to

00:48:42,960 --> 00:48:47,710
come over and ask them and that's me

00:48:46,200 --> 00:48:49,999
done thank you very much

00:48:47,710 --> 00:48:49,999

YouTube URL: https://www.youtube.com/watch?v=DGa58FfiMqc


