Title: Compiling to preserve our privacy - Manohar Jonnalagedda & Jakob Odersky
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/compiling-to-preserve-our-privacy
Captions: 
	00:00:00,829 --> 00:00:07,200
well hello good morning still thank you

00:00:04,859 --> 00:00:11,820
for coming right before lunch to our

00:00:07,200 --> 00:00:14,280
talk so yeah my name is Manohar and so I

00:00:11,820 --> 00:00:17,010
was a PhD student at Martin or Dan skis

00:00:14,280 --> 00:00:19,439
lab working on programming languages and

00:00:17,010 --> 00:00:21,840
then after finish my PhD I me ended

00:00:19,439 --> 00:00:24,210
around a bit did some research with

00:00:21,840 --> 00:00:27,689
Microsoft India but then you know I

00:00:24,210 --> 00:00:31,380
decided academia was enough so I would

00:00:27,689 --> 00:00:34,530
switch I would switch to the industry

00:00:31,380 --> 00:00:36,329
and you know the main the main reason to

00:00:34,530 --> 00:00:37,770
switch for the industry for me was well

00:00:36,329 --> 00:00:41,399
it's basic common sense you earn a lot

00:00:37,770 --> 00:00:42,600
more money right but you know so I

00:00:41,399 --> 00:00:44,550
really wanted to find out the true

00:00:42,600 --> 00:00:46,980
academic that I was I wanted to compare

00:00:44,550 --> 00:00:48,739
you know do I really unknown II and how

00:00:46,980 --> 00:00:53,460
does it stand and how does it stack up

00:00:48,739 --> 00:00:56,129
with respect to sorry with respect to I

00:00:53,460 --> 00:00:58,020
guess the rest of the people so you know

00:00:56,129 --> 00:01:00,780
I went and asked my colleague Jakob hey

00:00:58,020 --> 00:01:02,010
how much do you earn yes sir I had

00:01:00,780 --> 00:01:04,470
already been in the industry for a while

00:01:02,010 --> 00:01:06,600
and I was a bit surprised when ma asked

00:01:04,470 --> 00:01:13,729
me because we never he talked about this

00:01:06,600 --> 00:01:17,250
in the industry so what we did is okay

00:01:13,729 --> 00:01:20,460
order of slides we went to talk to our

00:01:17,250 --> 00:01:22,439
CTO dmitar and asked him like what we

00:01:20,460 --> 00:01:24,090
should do and he suggested well you know

00:01:22,439 --> 00:01:25,590
what instead of revealing everyone's

00:01:24,090 --> 00:01:28,560
salary why don't we just try to get an

00:01:25,590 --> 00:01:31,320
average so we came up with this basic

00:01:28,560 --> 00:01:33,090
protocol calculating an average problem

00:01:31,320 --> 00:01:35,490
here is it doesn't really solve the

00:01:33,090 --> 00:01:36,840
problem that with that we could meet

00:01:35,490 --> 00:01:41,130
that we would like to hide our

00:01:36,840 --> 00:01:42,780
individual salaries either we need to

00:01:41,130 --> 00:01:45,420
all reveal it or we need to trust the

00:01:42,780 --> 00:01:49,079
third party to have access to all of our

00:01:45,420 --> 00:01:50,220
salaries so instead we can understand

00:01:49,079 --> 00:01:51,720
why you did not want to reveal his

00:01:50,220 --> 00:01:54,540
salary as well

00:01:51,720 --> 00:01:57,090
instead he suggested we could come up

00:01:54,540 --> 00:01:59,899
with a different kind of protocol

00:01:57,090 --> 00:02:03,829
protocol that is privacy-preserving so

00:01:59,899 --> 00:02:05,909
with some clever mathematics we can

00:02:03,829 --> 00:02:08,670
calculate the average without revealing

00:02:05,909 --> 00:02:13,220
our individual salaries so here's how

00:02:08,670 --> 00:02:15,320
this protocol goes every one of us

00:02:13,220 --> 00:02:18,230
we have a secret number we would like to

00:02:15,320 --> 00:02:19,520
to keep secret which is the number in

00:02:18,230 --> 00:02:24,860
which are the numbers in red you see

00:02:19,520 --> 00:02:28,010
here we each also generate three random

00:02:24,860 --> 00:02:31,520
numbers all numbers must be random but

00:02:28,010 --> 00:02:33,950
the total sum must be zero we'll get to

00:02:31,520 --> 00:02:37,370
that in a minute how would we model this

00:02:33,950 --> 00:02:41,630
in Scala well the first thing we should

00:02:37,370 --> 00:02:43,220
introduce is two types one the secret

00:02:41,630 --> 00:02:44,570
value we would like to represent in this

00:02:43,220 --> 00:02:48,710
case it's just an integer in this

00:02:44,570 --> 00:02:51,170
example and then the concept of a shared

00:02:48,710 --> 00:02:53,660
number so the shared number is the list

00:02:51,170 --> 00:02:55,430
of secret numbers it corresponds to what

00:02:53,660 --> 00:03:00,230
you've seen on the left here this

00:02:55,430 --> 00:03:02,330
sequence of numbers and the key part

00:03:00,230 --> 00:03:05,300
here is in this model in Scala is every

00:03:02,330 --> 00:03:10,930
element of the list is only accessible

00:03:05,300 --> 00:03:13,490
by one by the corresponding person then

00:03:10,930 --> 00:03:15,950
well we have a function that generates

00:03:13,490 --> 00:03:18,350
these random numbers and we generate

00:03:15,950 --> 00:03:22,690
three one for the meter one for myself

00:03:18,350 --> 00:03:26,290
and one for mana half in a table view

00:03:22,690 --> 00:03:29,330
how would this look like a bit like this

00:03:26,290 --> 00:03:32,590
we have again the the parties involved

00:03:29,330 --> 00:03:35,750
in the computation on every row you have

00:03:32,590 --> 00:03:40,370
the shared 0 so DJ and M are actually

00:03:35,750 --> 00:03:41,810
all sum up to 0 and our secret data then

00:03:40,370 --> 00:03:49,280
the protocol goes as follows

00:03:41,810 --> 00:03:52,340
we each sum up our shares of of 0 so our

00:03:49,280 --> 00:03:55,850
own share and what we have received from

00:03:52,340 --> 00:03:59,900
other players this gives us a shared

00:03:55,850 --> 00:04:04,100
some this value here is published to

00:03:59,900 --> 00:04:07,070
every other player and the final sum of

00:04:04,100 --> 00:04:13,489
all values will equal the sum of all our

00:04:07,070 --> 00:04:17,690
private data then yes here is we can see

00:04:13,489 --> 00:04:19,880
in call out was I just mentioned as a

00:04:17,690 --> 00:04:21,890
numeric example it might be more

00:04:19,880 --> 00:04:24,650
illustrative to see how it works we're

00:04:21,890 --> 00:04:27,110
getting to the security in a second we

00:04:24,650 --> 00:04:29,000
see here every row indeed sums up to 0

00:04:27,110 --> 00:04:32,750
old numbers here have been randomly

00:04:29,000 --> 00:04:36,410
generate generated and if we sum up all

00:04:32,750 --> 00:04:39,380
the the shared sums we arrive at the

00:04:36,410 --> 00:04:42,740
same sum as if we had summed up our all

00:04:39,380 --> 00:04:45,080
our data now why does this work

00:04:42,740 --> 00:04:49,340
the key thing again here is that all the

00:04:45,080 --> 00:04:51,470
shared zeros sorry all the shared the

00:04:49,340 --> 00:04:53,840
triplets we generated they all sum up to

00:04:51,470 --> 00:04:57,860
0 so that means the total sum gets

00:04:53,840 --> 00:05:00,259
cancelled out and why is it secure well

00:04:57,860 --> 00:05:02,120
it's because no player has full

00:05:00,259 --> 00:05:04,909
information if we look at the point of

00:05:02,120 --> 00:05:06,259
view of Dimitar Dimitar knows what's in

00:05:04,909 --> 00:05:08,509
this row because these are the numbers

00:05:06,259 --> 00:05:09,889
that he generated and he knows what's in

00:05:08,509 --> 00:05:13,789
the column because these are the numbers

00:05:09,889 --> 00:05:16,520
that he has received for myself I have a

00:05:13,789 --> 00:05:18,949
different view of the world and manohar

00:05:16,520 --> 00:05:22,159
again so unless someone is able to

00:05:18,949 --> 00:05:26,830
intercept all communication there's no

00:05:22,159 --> 00:05:30,310
way to define the original secret data

00:05:26,830 --> 00:05:32,599
how will we model this exchange in Scala

00:05:30,310 --> 00:05:35,090
well we need to introduce what it means

00:05:32,599 --> 00:05:38,180
to add numbers first so there's one

00:05:35,090 --> 00:05:42,530
concept which is adding shares so adding

00:05:38,180 --> 00:05:44,960
parts adding essentially two numbers D

00:05:42,530 --> 00:05:47,210
and J what that means it's just an

00:05:44,960 --> 00:05:49,639
element-wise addition of the individual

00:05:47,210 --> 00:05:51,320
secret numbers and then we also need to

00:05:49,639 --> 00:05:54,460
introduce a concept of what it means to

00:05:51,320 --> 00:05:59,750
reveal a value and that again is just

00:05:54,460 --> 00:06:02,930
summing up all parts of the of the all

00:05:59,750 --> 00:06:04,159
individual secret shares then on the

00:06:02,930 --> 00:06:05,870
right of the table you'll see a

00:06:04,159 --> 00:06:07,219
one-to-one mapping of the sections of

00:06:05,870 --> 00:06:09,680
what I just described and how we can

00:06:07,219 --> 00:06:12,710
model that in Scala so again the green

00:06:09,680 --> 00:06:15,110
part we generate the 0 shares the red

00:06:12,710 --> 00:06:16,639
part we model the secret data we have

00:06:15,110 --> 00:06:18,949
which we would not like to reveal and

00:06:16,639 --> 00:06:21,889
then finally in the shared some we use

00:06:18,949 --> 00:06:24,849
the additions we just defined to compute

00:06:21,889 --> 00:06:27,919
the final sum and reveal it to the world

00:06:24,849 --> 00:06:32,240
this for the sake of the demonstration

00:06:27,919 --> 00:06:34,699
here we have addition and secret

00:06:32,240 --> 00:06:37,250
addition defined on element wise of

00:06:34,699 --> 00:06:39,020
course with some neat Escala tricks we

00:06:37,250 --> 00:06:40,810
can make this look much nicer but for

00:06:39,020 --> 00:06:45,620
the demo we we did not do this

00:06:40,810 --> 00:06:46,640
so happy as I was to now know the

00:06:45,620 --> 00:06:49,250
average of the salaries

00:06:46,640 --> 00:06:52,070
I also learned something new so what you

00:06:49,250 --> 00:06:54,920
have just seen is an example of what is

00:06:52,070 --> 00:06:57,920
known as secure multi-party computation

00:06:54,920 --> 00:07:01,940
so this is actually a subfield of

00:06:57,920 --> 00:07:05,270
cryptography where the goal is to create

00:07:01,940 --> 00:07:08,960
protocols or algorithms for different

00:07:05,270 --> 00:07:10,940
parties to compute a joint function such

00:07:08,960 --> 00:07:14,000
that without revealing their private

00:07:10,940 --> 00:07:17,320
data so to illustrate this again what it

00:07:14,000 --> 00:07:21,830
means is you have secret shared data

00:07:17,320 --> 00:07:25,190
that is sort of hidden only I know my

00:07:21,830 --> 00:07:28,190
share but when we join it together we

00:07:25,190 --> 00:07:31,700
get something we get a result so we can

00:07:28,190 --> 00:07:33,230
of course go back and forth right the

00:07:31,700 --> 00:07:35,540
idea is to draw a computer joint

00:07:33,230 --> 00:07:39,770
function which gives you something that

00:07:35,540 --> 00:07:41,750
you are looking for all together so well

00:07:39,770 --> 00:07:44,240
how does MPC work so what we have seen

00:07:41,750 --> 00:07:47,480
is an example of addition so as we said

00:07:44,240 --> 00:07:49,430
an average is you reveal a sum and you

00:07:47,480 --> 00:07:51,230
get the error and then you compute the

00:07:49,430 --> 00:07:54,440
average by dividing by the number of

00:07:51,230 --> 00:07:56,090
people well addition is great but it's

00:07:54,440 --> 00:07:59,870
not enough really is it we may need a

00:07:56,090 --> 00:08:02,030
bit more so what about multiplication of

00:07:59,870 --> 00:08:04,670
secret values so multiplication is a

00:08:02,030 --> 00:08:09,140
nonlinear function how would we do that

00:08:04,670 --> 00:08:11,900
well I won't go too much into the exact

00:08:09,140 --> 00:08:14,570
details about it but the general idea is

00:08:11,900 --> 00:08:16,900
that we can also do multiplication and

00:08:14,570 --> 00:08:19,520
please come talk to us to find out more

00:08:16,900 --> 00:08:21,290
but the main idea is that we can do

00:08:19,520 --> 00:08:24,200
multiplication but to make it a bit more

00:08:21,290 --> 00:08:27,860
efficient in terms of in terms of

00:08:24,200 --> 00:08:30,560
performance we introduce a the concept

00:08:27,860 --> 00:08:33,440
of a trusted dealer here so remember in

00:08:30,560 --> 00:08:36,770
the earlier example so Jakob Demeter and

00:08:33,440 --> 00:08:38,900
myself we created our own shares of zero

00:08:36,770 --> 00:08:42,830
and then we exchanged it amongst each

00:08:38,900 --> 00:08:45,530
other in this case we rely on mr.

00:08:42,830 --> 00:08:47,750
question mark here to do that work for

00:08:45,530 --> 00:08:50,720
us so mr. question mark is only involved

00:08:47,750 --> 00:08:52,730
in giving the shares to us but when we

00:08:50,720 --> 00:08:53,960
actually do the computation he's out of

00:08:52,730 --> 00:08:57,800
the picture so this is

00:08:53,960 --> 00:09:00,170
what my trusted dealer and what does

00:08:57,800 --> 00:09:03,830
what do these shares allow us to do well

00:09:00,170 --> 00:09:05,780
basically for multiplication this mr.

00:09:03,830 --> 00:09:09,290
questionmark needs to give us some pre

00:09:05,780 --> 00:09:11,090
computed values which we use for doing

00:09:09,290 --> 00:09:13,310
something which is called mask and

00:09:11,090 --> 00:09:16,160
reveal and in the case of multiplication

00:09:13,310 --> 00:09:18,770
this is known as beaver triplets there's

00:09:16,160 --> 00:09:19,940
a lot of new words don't worry about it

00:09:18,770 --> 00:09:23,090
you don't need to know much about the

00:09:19,940 --> 00:09:25,040
words just as I said come talk to us to

00:09:23,090 --> 00:09:27,470
know more I just put these here because

00:09:25,040 --> 00:09:30,070
you know when you see the videos it's

00:09:27,470 --> 00:09:33,140
nice for you to go and Wikipedia them

00:09:30,070 --> 00:09:35,660
great so we have edition of secret

00:09:33,140 --> 00:09:38,120
values we have multiplication of secret

00:09:35,660 --> 00:09:40,010
values which means we can actually do

00:09:38,120 --> 00:09:42,290
quite a lot of things because with

00:09:40,010 --> 00:09:45,350
addition multiplication we can express

00:09:42,290 --> 00:09:48,650
any polynomial so which means we can do

00:09:45,350 --> 00:09:51,020
actual serious interesting stuff in

00:09:48,650 --> 00:09:52,880
particular we can do things like linear

00:09:51,020 --> 00:09:56,090
regression and logistic regression

00:09:52,880 --> 00:10:00,370
because you know they can be expressed

00:09:56,090 --> 00:10:03,290
as polynomials wait how is exponential a

00:10:00,370 --> 00:10:04,820
polynomial right well I don't know if

00:10:03,290 --> 00:10:07,340
you remember your calculus classes for

00:10:04,820 --> 00:10:10,460
me also it was a while back thankfully I

00:10:07,340 --> 00:10:14,570
also learned that amongst in addition to

00:10:10,460 --> 00:10:16,280
my average exponential you can you can

00:10:14,570 --> 00:10:18,410
approximate an exponential function

00:10:16,280 --> 00:10:21,290
using something like a Taylor polynomial

00:10:18,410 --> 00:10:24,040
so again back to polynomials so it all

00:10:21,290 --> 00:10:26,750
kind of works out quite neatly and so

00:10:24,040 --> 00:10:28,970
these are just mathematical formulas but

00:10:26,750 --> 00:10:32,300
what you really can do once you have

00:10:28,970 --> 00:10:36,710
such functions is classification right

00:10:32,300 --> 00:10:39,380
so I mean I wouldn't want to be one of

00:10:36,710 --> 00:10:42,530
those Chihuahuas there in public right

00:10:39,380 --> 00:10:44,720
it would be it would be quite quite

00:10:42,530 --> 00:10:46,820
unfortunately bit confused to the muffin

00:10:44,720 --> 00:10:50,960
yeah I don't like to be good clear to be

00:10:46,820 --> 00:10:52,430
confused with a muffin yeah so when we

00:10:50,960 --> 00:10:54,650
get those when we get the polynomials

00:10:52,430 --> 00:10:58,190
then we can actually go to the real

00:10:54,650 --> 00:11:00,170
world and MPC is actually valid and

00:10:58,190 --> 00:11:01,880
valuable use case it has value eight use

00:11:00,170 --> 00:11:03,890
case in the real world let's look at a

00:11:01,880 --> 00:11:05,990
sort of a general picture of the

00:11:03,890 --> 00:11:07,460
different kinds of use cases that we we

00:11:05,990 --> 00:11:09,410
may have here

00:11:07,460 --> 00:11:11,960
we have different sectors financial

00:11:09,410 --> 00:11:14,440
services healthcare and genomics digital

00:11:11,960 --> 00:11:18,350
advertising defense and manufacturing so

00:11:14,440 --> 00:11:21,620
basically anytime you want to compute

00:11:18,350 --> 00:11:24,020
something but you're not allowed to

00:11:21,620 --> 00:11:26,450
share data for various reasons right the

00:11:24,020 --> 00:11:28,670
data is sensitive they can be legal they

00:11:26,450 --> 00:11:31,610
can be just computational they can be

00:11:28,670 --> 00:11:35,510
anything you can use a technique like

00:11:31,610 --> 00:11:37,790
ours like MPC to do this so let's go

00:11:35,510 --> 00:11:40,720
into you know one of the bank cases this

00:11:37,790 --> 00:11:44,630
is a case that we studied with ing

00:11:40,720 --> 00:11:45,920
example ing is a bank it has very rich

00:11:44,630 --> 00:11:49,160
customers in some of the richest

00:11:45,920 --> 00:11:51,890
countries in Europe and what it wants to

00:11:49,160 --> 00:11:56,450
do is build some sort of credit scoring

00:11:51,890 --> 00:11:59,870
model on all its clients but the problem

00:11:56,450 --> 00:12:02,030
is the user data I can't cross a country

00:11:59,870 --> 00:12:03,950
because you know of various laws in

00:12:02,030 --> 00:12:06,140
particular I'm sure you have heard of

00:12:03,950 --> 00:12:08,420
gdpr which was you know there was well

00:12:06,140 --> 00:12:10,870
maybe one of the biggest things in the

00:12:08,420 --> 00:12:15,830
last two years in terms of privacy

00:12:10,870 --> 00:12:18,890
privacy related computations legally

00:12:15,830 --> 00:12:21,320
speaking of course so if you have

00:12:18,890 --> 00:12:23,420
something like a multi-party computation

00:12:21,320 --> 00:12:26,380
engine then you could still build your

00:12:23,420 --> 00:12:30,110
model without the data having to cross

00:12:26,380 --> 00:12:32,990
borders let's look at a slightly more

00:12:30,110 --> 00:12:35,480
fun example let's say you have you know

00:12:32,990 --> 00:12:37,250
the usual Russians and Americans maybe

00:12:35,480 --> 00:12:39,170
Chinese now because that's what the

00:12:37,250 --> 00:12:40,670
world is like currently who have

00:12:39,170 --> 00:12:41,870
satellites on earth and they don't want

00:12:40,670 --> 00:12:44,390
to reveal where the positions the

00:12:41,870 --> 00:12:49,310
satellites are yet they don't want to

00:12:44,390 --> 00:12:51,860
create destruction in the outer space so

00:12:49,310 --> 00:12:54,140
you may want to secretly compute

00:12:51,860 --> 00:12:58,010
secretly detect collisions and this is

00:12:54,140 --> 00:13:02,030
not an imaginary example we had such a

00:12:58,010 --> 00:13:04,610
thing happen in 2009 and you know it's

00:13:02,030 --> 00:13:08,480
just nice to avoid such things because

00:13:04,610 --> 00:13:09,950
this actually then resulted in the

00:13:08,480 --> 00:13:12,950
International Space Station having to

00:13:09,950 --> 00:13:14,330
maneuver because just to avoid and avoid

00:13:12,950 --> 00:13:19,230
the debris and stuff like that so this

00:13:14,330 --> 00:13:22,380
is not a joke really it is serious stuff

00:13:19,230 --> 00:13:24,960
and so of course we also you know we

00:13:22,380 --> 00:13:26,310
know that computationally we can

00:13:24,960 --> 00:13:28,410
preserve privacy we can have the

00:13:26,310 --> 00:13:32,160
security but it's also nice to know that

00:13:28,410 --> 00:13:33,920
we you know consulted lawyers and Baker

00:13:32,160 --> 00:13:37,260
McKenzie are experts in this area and

00:13:33,920 --> 00:13:40,350
they have concluded as well that we

00:13:37,260 --> 00:13:43,380
don't you know cross we don't violate

00:13:40,350 --> 00:13:44,880
the GD P R so that's also great news

00:13:43,380 --> 00:13:46,830
legally speaking if you're interested in

00:13:44,880 --> 00:13:52,110
solution this is definitely one way to

00:13:46,830 --> 00:13:55,920
go so I we showed you a short example of

00:13:52,110 --> 00:13:59,160
an embedding in Scala we have done a bit

00:13:55,920 --> 00:14:01,200
more work in our prototype here we have

00:13:59,160 --> 00:14:02,670
multiplication involved so even if you

00:14:01,200 --> 00:14:05,010
don't want to come to talk to us you can

00:14:02,670 --> 00:14:08,900
definitely see the code and find out how

00:14:05,010 --> 00:14:13,830
it works great well thank you very much

00:14:08,900 --> 00:14:16,590
is it enough it's enough to have a

00:14:13,830 --> 00:14:20,100
direct embedding so what does the direct

00:14:16,590 --> 00:14:20,670
embedding give us once more what have we

00:14:20,100 --> 00:14:22,860
done here

00:14:20,670 --> 00:14:26,460
we've taken code now we can write code

00:14:22,860 --> 00:14:28,320
in a declarative or machine learning

00:14:26,460 --> 00:14:30,570
style we can write machine learning

00:14:28,320 --> 00:14:32,280
algorithms as if they were written in

00:14:30,570 --> 00:14:34,980
Scala or Python or your favorite

00:14:32,280 --> 00:14:36,990
language and due to the embedding we

00:14:34,980 --> 00:14:39,500
were able to get the security

00:14:36,990 --> 00:14:44,430
multi-party computation protocols

00:14:39,500 --> 00:14:46,950
running but actually in reality we in a

00:14:44,430 --> 00:14:49,350
bit more right because in reality the

00:14:46,950 --> 00:14:52,170
computations are distributed they're not

00:14:49,350 --> 00:14:54,660
just an array and so we must target a

00:14:52,170 --> 00:14:56,550
runtime which runs securely in each of

00:14:54,660 --> 00:14:57,810
the parties so that's one reason why

00:14:56,550 --> 00:15:01,800
it's not enough just to have an

00:14:57,810 --> 00:15:03,480
embedding the other reason actually more

00:15:01,800 --> 00:15:07,080
fundamentally mathematically speaking is

00:15:03,480 --> 00:15:10,670
we need to do some static analysis of

00:15:07,080 --> 00:15:14,880
our programs such that we can sort of

00:15:10,670 --> 00:15:17,370
optimize for memory and for

00:15:14,880 --> 00:15:19,530
communication purposes and we also want

00:15:17,370 --> 00:15:24,890
to be able to compute some statistical

00:15:19,530 --> 00:15:24,890
distributions which we will get into in

00:15:26,210 --> 00:15:33,470
yes so rather than having only a library

00:15:29,000 --> 00:15:36,320
we decided to write a compiler the the

00:15:33,470 --> 00:15:39,080
idea here is that we will take a

00:15:36,320 --> 00:15:40,720
high-level language something data

00:15:39,080 --> 00:15:43,040
scientists will be familiar with

00:15:40,720 --> 00:15:47,890
something that looks maybe like Python

00:15:43,040 --> 00:15:47,890
matlab's and linear algebra style and

00:15:48,370 --> 00:15:53,720
this high-level language will abstract

00:15:51,200 --> 00:15:56,089
away completely of any kind of low-level

00:15:53,720 --> 00:15:57,980
NPC details so anyone could use this

00:15:56,089 --> 00:16:00,830
language to write a program as they

00:15:57,980 --> 00:16:04,010
would you would would usually do the

00:16:00,830 --> 00:16:05,410
compiler will then generate a transform

00:16:04,010 --> 00:16:10,149
this program into low-level primitives

00:16:05,410 --> 00:16:12,860
that get distributed and actually run so

00:16:10,149 --> 00:16:14,570
that that's that touches the case for

00:16:12,860 --> 00:16:16,339
the the real-life deployment and then of

00:16:14,570 --> 00:16:18,050
course there's also a lot of static

00:16:16,339 --> 00:16:21,680
analysis that is done kind of what

00:16:18,050 --> 00:16:24,830
manner I just mentioned I'll give you a

00:16:21,680 --> 00:16:26,839
quick overview to of the the system we

00:16:24,830 --> 00:16:32,180
have at info and how the compiler fits

00:16:26,839 --> 00:16:34,250
into this distributed reality so there

00:16:32,180 --> 00:16:38,029
are a couple components involved to do a

00:16:34,250 --> 00:16:40,459
real life secret computation I will

00:16:38,029 --> 00:16:43,250
start going from the bottom work our way

00:16:40,459 --> 00:16:45,980
to the top in terms of abstraction so at

00:16:43,250 --> 00:16:47,870
the bottom we have players who so

00:16:45,980 --> 00:16:51,020
players like is the technical term for

00:16:47,870 --> 00:16:53,360
parties that have data we have the

00:16:51,020 --> 00:16:55,160
players who have access to some data

00:16:53,360 --> 00:16:57,890
which they would not like to reveal each

00:16:55,160 --> 00:17:00,260
one of them will run a virtual machine

00:16:57,890 --> 00:17:02,150
on their system that has access to the

00:17:00,260 --> 00:17:05,750
data this virtual machine can be

00:17:02,150 --> 00:17:10,970
verified that there there is no data

00:17:05,750 --> 00:17:12,350
ever leaked out then these these works

00:17:10,970 --> 00:17:13,850
so these virtual machines will do the

00:17:12,350 --> 00:17:17,120
number crunching these will actually run

00:17:13,850 --> 00:17:19,970
the secret compute algorithm to receive

00:17:17,120 --> 00:17:22,400
the true the algorithm this is where the

00:17:19,970 --> 00:17:24,709
compiler fits into the picture

00:17:22,400 --> 00:17:26,179
we also have the trusted dealer which is

00:17:24,709 --> 00:17:28,250
what we mentioned what manner I

00:17:26,179 --> 00:17:31,160
mentioned earlier to support any some

00:17:28,250 --> 00:17:32,960
more advanced computations and just to

00:17:31,160 --> 00:17:36,169
make it a little bit easier to use there

00:17:32,960 --> 00:17:40,070
is also a nice front-end the compiler is

00:17:36,169 --> 00:17:41,960
hosted by infer the engines

00:17:40,070 --> 00:17:44,300
the things running the programs are of

00:17:41,960 --> 00:17:45,530
course hosted by customers so how would

00:17:44,300 --> 00:17:49,460
it look like if we want to run a

00:17:45,530 --> 00:17:51,140
computation well the analysts through a

00:17:49,460 --> 00:17:53,000
front-end would submit a computation to

00:17:51,140 --> 00:17:55,040
the compiler a compiler compiles the

00:17:53,000 --> 00:17:58,090
program distributes it amongst all

00:17:55,040 --> 00:18:01,010
players then the trust the dealer

00:17:58,090 --> 00:18:02,210
generates random numbers sends them to

00:18:01,010 --> 00:18:04,120
the players so the trust the dealer

00:18:02,210 --> 00:18:07,450
knows of course what random numbers to

00:18:04,120 --> 00:18:09,440
generate thanks to the compiler and a

00:18:07,450 --> 00:18:13,460
cooperation between the compiler and

00:18:09,440 --> 00:18:16,010
some engine components and then there is

00:18:13,460 --> 00:18:17,720
a the computation actually starts

00:18:16,010 --> 00:18:20,510
amongst the engines is a communication

00:18:17,720 --> 00:18:22,910
exchange of data and finally the end

00:18:20,510 --> 00:18:26,360
result gets sent back to the one who

00:18:22,910 --> 00:18:28,310
submitted the operation now this trust

00:18:26,360 --> 00:18:29,900
the deal I just want to take two minutes

00:18:28,310 --> 00:18:31,010
to dig into detail here while this is

00:18:29,900 --> 00:18:33,590
still secure because you could think

00:18:31,010 --> 00:18:35,630
like hey we generate random numbers why

00:18:33,590 --> 00:18:37,520
should anyone trust us we could spy on

00:18:35,630 --> 00:18:41,180
you right after that and the key thing

00:18:37,520 --> 00:18:42,650
here is you'll notice that after the

00:18:41,180 --> 00:18:44,180
trusted dealer has sent out numbers

00:18:42,650 --> 00:18:46,280
there is no more communication with the

00:18:44,180 --> 00:18:49,160
trusted dealer so that means we do not

00:18:46,280 --> 00:18:52,130
have any knowledge of any data that

00:18:49,160 --> 00:18:54,230
leaves the data sources so that even if

00:18:52,130 --> 00:18:56,480
we had a malicious intent and knew all

00:18:54,230 --> 00:18:58,100
the random numbers that we generated we

00:18:56,480 --> 00:18:59,210
would not know any intermediate results

00:18:58,100 --> 00:19:01,900
and there would be no way for us to

00:18:59,210 --> 00:19:05,900
reverse what comes out of it

00:19:01,900 --> 00:19:09,230
so that was a the distributed part the

00:19:05,900 --> 00:19:11,120
overview of the architecture now well

00:19:09,230 --> 00:19:12,860
why else do I need a compiler so we're

00:19:11,120 --> 00:19:15,890
talking about you know the actual

00:19:12,860 --> 00:19:18,770
mathematical properties behind this so

00:19:15,890 --> 00:19:21,440
this is going to be the most technical

00:19:18,770 --> 00:19:23,120
part of this talk but I just want to

00:19:21,440 --> 00:19:26,240
give you an intuition about what it

00:19:23,120 --> 00:19:28,370
means to mask numbers so what do we mean

00:19:26,240 --> 00:19:30,200
by masking numbers well earlier in the

00:19:28,370 --> 00:19:32,210
example we had we were masking our

00:19:30,200 --> 00:19:33,650
salary by generating these random

00:19:32,210 --> 00:19:36,140
numbers and adding them up such that

00:19:33,650 --> 00:19:40,160
when I look at a number I couldn't

00:19:36,140 --> 00:19:44,780
really make out what the initial or the

00:19:40,160 --> 00:19:48,260
original plaintext value was so of

00:19:44,780 --> 00:19:49,580
course we did with integers right so how

00:19:48,260 --> 00:19:53,330
do we mask integers

00:19:49,580 --> 00:19:56,899
well it's a relatively easy

00:19:53,330 --> 00:20:00,399
easy thing to do an integer let's look

00:19:56,899 --> 00:20:02,960
at the 64-bit integer so we have a fixed

00:20:00,399 --> 00:20:04,940
we have a fixed size we have a fixed

00:20:02,960 --> 00:20:08,450
range and which means that I can

00:20:04,940 --> 00:20:13,279
uniformly at random pick any integer and

00:20:08,450 --> 00:20:15,110
add it to my plaintext and so what is so

00:20:13,279 --> 00:20:16,940
how do I know that how do I know that

00:20:15,110 --> 00:20:21,350
this is secure enough well the security

00:20:16,940 --> 00:20:25,070
model is given to given two masked

00:20:21,350 --> 00:20:27,859
values can I differentiate them can i

00:20:25,070 --> 00:20:31,249
distinguish one from the other and in

00:20:27,859 --> 00:20:33,230
this info in this integer case I can't

00:20:31,249 --> 00:20:35,840
because it's everything is picked

00:20:33,230 --> 00:20:38,179
uniformly at random so I'm none the

00:20:35,840 --> 00:20:40,129
wiser really with masked values and this

00:20:38,179 --> 00:20:42,049
gives us something a property which is

00:20:40,129 --> 00:20:44,749
very very nice which is called

00:20:42,049 --> 00:20:46,639
information theoretic security so this

00:20:44,749 --> 00:20:50,749
is sort of the best of the best that I

00:20:46,639 --> 00:20:53,570
can do unfortunately in real life we

00:20:50,749 --> 00:20:55,789
have floating-point numbers and those

00:20:53,570 --> 00:20:57,289
are slightly higher harder to mask so

00:20:55,789 --> 00:20:59,749
I'm going to try to give you a bit of

00:20:57,289 --> 00:21:00,950
intuition as to why that is well in

00:20:59,749 --> 00:21:02,809
floating-point numbers the first thing

00:21:00,950 --> 00:21:04,940
is the fixed range is something that

00:21:02,809 --> 00:21:07,850
does not exist we have basically it's

00:21:04,940 --> 00:21:09,859
essentially real numbers and so how do I

00:21:07,850 --> 00:21:13,869
mask real numbers well the best I can

00:21:09,859 --> 00:21:16,249
really do is to take my plaintext and

00:21:13,869 --> 00:21:20,450
have a normal distribution around it and

00:21:16,249 --> 00:21:22,369
then pick something in that now if I

00:21:20,450 --> 00:21:25,429
pick a normal if I pick a distribution

00:21:22,369 --> 00:21:27,409
that is too small then I may be able to

00:21:25,429 --> 00:21:29,450
distinguish two values and that's sort

00:21:27,409 --> 00:21:32,989
of on the left with the double camel

00:21:29,450 --> 00:21:34,730
hump here so think of me picking two

00:21:32,989 --> 00:21:36,919
different values I think here it's sort

00:21:34,730 --> 00:21:41,109
of 0 and 1 and I put the small

00:21:36,919 --> 00:21:43,940
distribution not a big variance and so

00:21:41,109 --> 00:21:46,309
the only the only way these two values

00:21:43,940 --> 00:21:48,549
are distinguishable is if I fall you

00:21:46,309 --> 00:21:51,769
know between the legs of the camel here

00:21:48,549 --> 00:21:55,489
if if I'm if I'm able to pick something

00:21:51,769 --> 00:21:57,080
that's in this in this space then I'm

00:21:55,489 --> 00:22:00,440
good that means I can't distinguish the

00:21:57,080 --> 00:22:03,919
values however if I happen to have

00:22:00,440 --> 00:22:05,869
generated my zero in this area in the

00:22:03,919 --> 00:22:06,710
left hump and my 1 in the right hump

00:22:05,869 --> 00:22:08,510
that means I can

00:22:06,710 --> 00:22:09,860
clearly distinguish both and that's a

00:22:08,510 --> 00:22:13,460
problem because that means an attacker

00:22:09,860 --> 00:22:17,659
can I knows and you're leaking leaking

00:22:13,460 --> 00:22:21,529
your data right so what you note also is

00:22:17,659 --> 00:22:22,730
that well so these humps are large so it

00:22:21,529 --> 00:22:26,390
means I have a very high probability

00:22:22,730 --> 00:22:29,510
here of falling into a case where I can

00:22:26,390 --> 00:22:32,600
easily distinguish my numbers so what is

00:22:29,510 --> 00:22:34,399
the solution there the solution is on

00:22:32,600 --> 00:22:36,320
the right so instead of taking a smaller

00:22:34,399 --> 00:22:38,299
distribution I take a very large one I

00:22:36,320 --> 00:22:41,450
take some that I can I take things that

00:22:38,299 --> 00:22:43,309
are sufficiently large you see that the

00:22:41,450 --> 00:22:47,679
scales have considerably changed on the

00:22:43,309 --> 00:22:51,039
right hand side such that the humps are

00:22:47,679 --> 00:22:55,490
very very small or sufficiently small so

00:22:51,039 --> 00:22:57,350
what is sufficiently small mean so

00:22:55,490 --> 00:22:59,720
sufficiently small means that I have a

00:22:57,350 --> 00:23:02,659
very low probability of falling in those

00:22:59,720 --> 00:23:06,340
humps and I get computational security

00:23:02,659 --> 00:23:09,470
so I want so my attacker could actually

00:23:06,340 --> 00:23:11,510
maybe distinguish the value but to do

00:23:09,470 --> 00:23:14,539
that he would have to do a lot of work

00:23:11,510 --> 00:23:16,669
because you'd have to send up to a large

00:23:14,539 --> 00:23:19,970
number of queries just to be able to

00:23:16,669 --> 00:23:21,559
distinguish the values so we don't have

00:23:19,970 --> 00:23:22,490
information theoretic security where

00:23:21,559 --> 00:23:25,850
we're none the wiser

00:23:22,490 --> 00:23:27,529
with the masked values however what we

00:23:25,850 --> 00:23:30,380
have here is we're making the work of an

00:23:27,529 --> 00:23:31,909
attacker much more difficult by making

00:23:30,380 --> 00:23:36,080
the humps as small as possible

00:23:31,909 --> 00:23:38,600
and and yeah that's that's what you get

00:23:36,080 --> 00:23:40,730
with computational security but however

00:23:38,600 --> 00:23:43,039
the problem is now as I told you we have

00:23:40,730 --> 00:23:45,140
this we have these humps let's go back

00:23:43,039 --> 00:23:48,590
to these humps so if I take a very large

00:23:45,140 --> 00:23:49,970
distribution that means that what in in

00:23:48,590 --> 00:23:51,529
practice what does it mean it means that

00:23:49,970 --> 00:23:53,779
if I have a floating point let's say

00:23:51,529 --> 00:23:56,270
that's 10 bits long so it's smaller than

00:23:53,779 --> 00:23:57,919
about 1,024 if I I need to take a

00:23:56,270 --> 00:24:00,799
sufficiently large distribution so I

00:23:57,919 --> 00:24:03,500
need to mask using maybe 40 extra bits

00:24:00,799 --> 00:24:06,260
because I want my attacker to be able to

00:24:03,500 --> 00:24:10,610
be work to work very hard so it means

00:24:06,260 --> 00:24:13,690
for a 10 bit number I'm using a 40 bit

00:24:10,610 --> 00:24:16,669
number so if I multiply two such numbers

00:24:13,690 --> 00:24:18,799
then you know I can't blow up right so

00:24:16,669 --> 00:24:20,610
if I have when I multiply plaintext if I

00:24:18,799 --> 00:24:21,930
have a 10 bit number

00:24:20,610 --> 00:24:23,760
and I multiplied with another TEDMED

00:24:21,930 --> 00:24:26,400
number then I can get a 20-bit number at

00:24:23,760 --> 00:24:27,720
most 20 but numbers still is fine

00:24:26,400 --> 00:24:30,900
because it's a floating point it can

00:24:27,720 --> 00:24:34,559
still fit under 64 bits but at 1440 well

00:24:30,900 --> 00:24:36,390
you know I'm really blowing up and so

00:24:34,559 --> 00:24:40,650
that's an issue so those are the kind of

00:24:36,390 --> 00:24:43,700
things that you know we basically need

00:24:40,650 --> 00:24:46,410
to on the compiler side analyze and

00:24:43,700 --> 00:24:49,920
estimate such that we can sort of ensure

00:24:46,410 --> 00:24:52,260
that we don't blow up so there's a

00:24:49,920 --> 00:24:53,550
little bit of you know what we do is we

00:24:52,260 --> 00:24:55,890
don't really use a floating-point

00:24:53,550 --> 00:24:57,540
representation we use something that's

00:24:55,890 --> 00:25:00,840
called a fixed point representation to

00:24:57,540 --> 00:25:03,510
represent floating points in our

00:25:00,840 --> 00:25:06,600
back-end and these different number

00:25:03,510 --> 00:25:08,580
representation sort of helps us avoiding

00:25:06,600 --> 00:25:11,640
this format explosion or we at least

00:25:08,580 --> 00:25:13,020
don't explore as quickly and this is

00:25:11,640 --> 00:25:15,679
what we analyze statically in the

00:25:13,020 --> 00:25:18,510
compiler so that we can propagate the

00:25:15,679 --> 00:25:21,179
statistical bounds correctly to the

00:25:18,510 --> 00:25:25,020
whole program before we sending to the

00:25:21,179 --> 00:25:29,610
engine yes exactly

00:25:25,020 --> 00:25:31,860
so I'll give a quick overview know now

00:25:29,610 --> 00:25:35,730
of what the compiler actually does and

00:25:31,860 --> 00:25:38,790
how the input language looks like let's

00:25:35,730 --> 00:25:41,400
jump right into it this is some source

00:25:38,790 --> 00:25:43,710
code for um our language it looks pretty

00:25:41,400 --> 00:25:46,250
much like Scala except semicolon is

00:25:43,710 --> 00:25:46,250
still required

00:25:46,309 --> 00:25:50,990
well why it's a long story

00:25:52,920 --> 00:25:58,500
the it doesn't look really exceptional

00:25:55,470 --> 00:26:00,990
and that's by design we want it to be as

00:25:58,500 --> 00:26:03,960
easy to use for anyone who does not know

00:26:00,990 --> 00:26:06,510
anything about MPC so it really looks

00:26:03,960 --> 00:26:09,990
like some yes some some linear algebra

00:26:06,510 --> 00:26:15,030
code the only thing you'll note is there

00:26:09,990 --> 00:26:17,040
are these eggs or dot things these are

00:26:15,030 --> 00:26:19,110
you can think of them as calls to a

00:26:17,040 --> 00:26:22,490
standard library or some primitive

00:26:19,110 --> 00:26:25,590
instructions this is these things are

00:26:22,490 --> 00:26:29,990
known by the engines known by the

00:26:25,590 --> 00:26:32,040
machines that have access to data but

00:26:29,990 --> 00:26:33,750
not others so they're not they're not

00:26:32,040 --> 00:26:35,460
known quite like this

00:26:33,750 --> 00:26:37,500
again not showing here are all these

00:26:35,460 --> 00:26:40,050
parameters these masking parameters

00:26:37,500 --> 00:26:42,450
sizes which which are not of relevance

00:26:40,050 --> 00:26:48,120
for a developer but of course very

00:26:42,450 --> 00:26:50,940
important in the actual runtime so on

00:26:48,120 --> 00:26:53,010
top of these primitives then we build a

00:26:50,940 --> 00:26:56,430
language on it it is strongly typed in

00:26:53,010 --> 00:27:00,420
fact it everything is always in lined

00:26:56,430 --> 00:27:03,200
everything gets constant folded so that

00:27:00,420 --> 00:27:06,090
that these primitives that we can infer

00:27:03,200 --> 00:27:07,320
parameters such as masking sizes to the

00:27:06,090 --> 00:27:09,630
primitives when we actually generate the

00:27:07,320 --> 00:27:13,320
code we'll get into that in introduced

00:27:09,630 --> 00:27:16,590
in a second so when you compile a

00:27:13,320 --> 00:27:20,970
program you just submit it as a source

00:27:16,590 --> 00:27:22,770
file and the compiler is goes through

00:27:20,970 --> 00:27:25,020
various phases it's built like a

00:27:22,770 --> 00:27:26,910
traditional compiler for around eight

00:27:25,020 --> 00:27:29,670
phases so we do things like while

00:27:26,910 --> 00:27:32,220
parsing type checking etc and then we

00:27:29,670 --> 00:27:34,590
get into some more details where we

00:27:32,220 --> 00:27:37,740
actually do the cryptographic part and

00:27:34,590 --> 00:27:40,110
this is where we need to check that for

00:27:37,740 --> 00:27:43,620
example if we multiply two numbers that

00:27:40,110 --> 00:27:46,530
we the that although the the resulting

00:27:43,620 --> 00:27:49,020
number may be or will be larger that the

00:27:46,530 --> 00:27:51,390
mask does not just naively get doubled

00:27:49,020 --> 00:27:53,010
maybe we can because we know something

00:27:51,390 --> 00:27:55,410
about the distribution of data we can

00:27:53,010 --> 00:28:00,120
take a smaller mask and thus be much

00:27:55,410 --> 00:28:02,820
more efficient this is what comes out of

00:28:00,120 --> 00:28:05,460
the compiler so might look a little bit

00:28:02,820 --> 00:28:07,530
daunting and it looks a bit like

00:28:05,460 --> 00:28:10,920
assembly because this is what it is it's

00:28:07,530 --> 00:28:12,900
assembly for the NPC engines but we'll

00:28:10,920 --> 00:28:15,720
walk you through through some of what

00:28:12,900 --> 00:28:20,310
happens here so that you can understand

00:28:15,720 --> 00:28:23,910
what's going on the first part is memory

00:28:20,310 --> 00:28:25,020
management so right in the beginning we

00:28:23,910 --> 00:28:27,630
said that one of the jobs of the

00:28:25,020 --> 00:28:28,620
compiler is to to make sure we're as

00:28:27,630 --> 00:28:31,080
efficient as possible

00:28:28,620 --> 00:28:33,300
and we're doing matrix multiplications

00:28:31,080 --> 00:28:34,560
these things require a lot of memory so

00:28:33,300 --> 00:28:36,300
we need to make sure that we can

00:28:34,560 --> 00:28:39,030
actually so that we allocate and

00:28:36,300 --> 00:28:41,460
deallocate memory when variables are no

00:28:39,030 --> 00:28:45,210
longer used so in blue you see currently

00:28:41,460 --> 00:28:46,320
all the the create calls of so these are

00:28:45,210 --> 00:28:47,700
like it this is like a malloc

00:28:46,320 --> 00:28:49,470
essentially

00:28:47,700 --> 00:28:51,990
delete is not on the slide it happens

00:28:49,470 --> 00:28:58,169
just below but don't worry about that

00:28:51,990 --> 00:29:00,539
then we have the built-ins so built-ins

00:28:58,169 --> 00:29:02,090
always work on containers a container is

00:29:00,539 --> 00:29:05,399
again like I think of it like a variable

00:29:02,090 --> 00:29:08,370
these built-ins and however so these

00:29:05,399 --> 00:29:10,230
built-ins map to to what I showed here

00:29:08,370 --> 00:29:13,919
the these eggs or these language

00:29:10,230 --> 00:29:17,970
built-ins the difference however is that

00:29:13,919 --> 00:29:19,889
we now show the all built-ins have some

00:29:17,970 --> 00:29:23,010
extra parameters pass to them and these

00:29:19,889 --> 00:29:27,149
are the result of the compiler there is

00:29:23,010 --> 00:29:28,799
also all dimensions of any input

00:29:27,149 --> 00:29:31,740
variables so these are the things you

00:29:28,799 --> 00:29:34,409
see in brown here they all get folded

00:29:31,740 --> 00:29:37,320
they all get replaced by the actual

00:29:34,409 --> 00:29:40,110
values so in the end so the example I'm

00:29:37,320 --> 00:29:42,750
showing here is we have a number of rows

00:29:40,110 --> 00:29:45,269
and a number of columns these are taken

00:29:42,750 --> 00:29:47,700
from the input values but however at

00:29:45,269 --> 00:29:51,000
runtime since it's a distributed

00:29:47,700 --> 00:29:52,409
computation we need to and to be as

00:29:51,000 --> 00:29:55,380
efficient as possible we need to know

00:29:52,409 --> 00:29:57,059
the sizes of all input in advance and

00:29:55,380 --> 00:30:00,149
that gets propagated through the program

00:29:57,059 --> 00:30:02,750
and then finally in red this is actually

00:30:00,149 --> 00:30:05,340
the key part of the compiler is

00:30:02,750 --> 00:30:08,940
inferring these parameters so these are

00:30:05,340 --> 00:30:11,659
these magical masking values that we try

00:30:08,940 --> 00:30:13,950
to minimize in the compiler to make as

00:30:11,659 --> 00:30:16,380
computations as efficient as possible

00:30:13,950 --> 00:30:19,950
now you could technically write this by

00:30:16,380 --> 00:30:21,090
hand all right but of course that's

00:30:19,950 --> 00:30:23,100
actually what we have done right in the

00:30:21,090 --> 00:30:26,130
beginning but using a compiler also

00:30:23,100 --> 00:30:28,139
allows us to compose programs much much

00:30:26,130 --> 00:30:30,480
better so rather than writing a

00:30:28,139 --> 00:30:32,340
prepackaged linear regression you know

00:30:30,480 --> 00:30:36,059
assembly routine you could you can

00:30:32,340 --> 00:30:38,340
actually build a full full mathematical

00:30:36,059 --> 00:30:41,760
library with these these operations and

00:30:38,340 --> 00:30:44,279
compose them to your liking so what we

00:30:41,760 --> 00:30:47,039
currently have is the compiler only

00:30:44,279 --> 00:30:49,380
works with NPC so this is the protocol

00:30:47,039 --> 00:30:51,179
we talked about however since it's a

00:30:49,380 --> 00:30:54,899
compiler and we can work one on these

00:30:51,179 --> 00:30:56,549
again these high level languages it

00:30:54,899 --> 00:30:57,779
would be nice if in the future we can

00:30:56,549 --> 00:31:01,130
integrate other privacy-preserving

00:30:57,779 --> 00:31:02,780
techniques here this is

00:31:01,130 --> 00:31:04,550
something more aspirational that we

00:31:02,780 --> 00:31:08,480
would like to get to currently we are

00:31:04,550 --> 00:31:10,940
focusing on MPC but the compiler is in a

00:31:08,480 --> 00:31:14,500
in a prime spot to be able to work as an

00:31:10,940 --> 00:31:14,500
intermediate for all these technologies

00:31:14,680 --> 00:31:20,480
finally I want to give a quick word

00:31:17,750 --> 00:31:22,750
about our team were currently six people

00:31:20,480 --> 00:31:27,500
working on the compiler at info a

00:31:22,750 --> 00:31:30,500
company we're quite some more we're

00:31:27,500 --> 00:31:35,930
actually growing and the salary is not

00:31:30,500 --> 00:31:37,550
as bad as we mentioned in the example so

00:31:35,930 --> 00:31:47,090
yes please come talk to us if you want

00:31:37,550 --> 00:31:56,750
more details and thank you I think we

00:31:47,090 --> 00:32:00,410
have enough time for questions yes

00:31:56,750 --> 00:32:02,540
please take microphone yeah that's

00:32:00,410 --> 00:32:04,310
pretty cool thanks doc I'm pretty

00:32:02,540 --> 00:32:05,330
curious about though I mean I guess we

00:32:04,310 --> 00:32:07,340
will have many questions will come to

00:32:05,330 --> 00:32:09,590
your proof later but about the type

00:32:07,340 --> 00:32:12,500
system do you infer the matrix a

00:32:09,590 --> 00:32:14,480
dimension I guess yes so if I if I ever

00:32:12,500 --> 00:32:16,430
miss much of the matrix dimension you

00:32:14,480 --> 00:32:20,990
can compile time you will tell me that's

00:32:16,430 --> 00:32:21,890
good yeah the compiler is it's not a

00:32:20,990 --> 00:32:23,720
Turing complete language

00:32:21,890 --> 00:32:25,490
everything must terminate and we need to

00:32:23,720 --> 00:32:27,250
know a lot of information about the

00:32:25,490 --> 00:32:30,200
input so the shapes we need to know

00:32:27,250 --> 00:32:32,630
sizes of the input so actually when you

00:32:30,200 --> 00:32:36,890
see this X or input built-in you see

00:32:32,630 --> 00:32:39,770
here this X needs to be known by oh yeah

00:32:36,890 --> 00:32:41,270
we need to know that yeah so we need to

00:32:39,770 --> 00:32:43,130
it's important to emphasize that we need

00:32:41,270 --> 00:32:48,020
to know just the properties of the data

00:32:43,130 --> 00:32:50,060
and if that's not the data itself and

00:32:48,020 --> 00:32:52,910
then this value that you you infer that

00:32:50,060 --> 00:32:54,830
or for you know this complex multi-party

00:32:52,910 --> 00:32:56,090
computation you do is it also part of

00:32:54,830 --> 00:32:59,140
the type system this is something you

00:32:56,090 --> 00:33:02,810
infer as part of the type checker so

00:32:59,140 --> 00:33:04,520
that's actually a bit of a trick

00:33:02,810 --> 00:33:08,480
question and a complex question so let

00:33:04,520 --> 00:33:11,090
me disambiguate that a little bit so we

00:33:08,480 --> 00:33:13,039
don't encode it in the type system in

00:33:11,090 --> 00:33:16,019
our implementation

00:33:13,039 --> 00:33:17,789
what we do instead is you know through

00:33:16,019 --> 00:33:20,759
the multiple phases with a bit of

00:33:17,789 --> 00:33:22,289
partial evaluation and so on but yeah

00:33:20,759 --> 00:33:26,210
with I mean I guess with Scala three and

00:33:22,289 --> 00:33:26,210
literal types it would be very fun with

00:33:29,210 --> 00:33:32,729
it wrist would be so that address is

00:33:32,039 --> 00:33:34,219
something that I would like to

00:33:32,729 --> 00:33:37,019
experiment as well to play around with

00:33:34,219 --> 00:33:39,269
but I think the key really is here is

00:33:37,019 --> 00:33:41,580
you still at some point need something

00:33:39,269 --> 00:33:44,129
like a compiler so you need to go from

00:33:41,580 --> 00:33:46,409
sort of you know shallow embedding to a

00:33:44,129 --> 00:33:48,839
deep embedding yes and actually actually

00:33:46,409 --> 00:33:51,210
have access to your trees because in

00:33:48,839 --> 00:33:52,999
particular I mean if you look at phase

00:33:51,210 --> 00:33:55,859
four here

00:33:52,999 --> 00:33:59,279
SSA is actually very critical for us

00:33:55,859 --> 00:34:01,379
because we want to generate efficient

00:33:59,279 --> 00:34:03,419
assembly such that memory is properly

00:34:01,379 --> 00:34:06,779
allocated and D allocated and so you

00:34:03,419 --> 00:34:10,529
need to convert to some nice form so

00:34:06,779 --> 00:34:12,480
that you can you can do yeah it makes

00:34:10,529 --> 00:34:15,649
sense anyway you want mostly more

00:34:12,480 --> 00:34:17,549
physics because you have very specific

00:34:15,649 --> 00:34:20,579
essentially the key part what we're

00:34:17,549 --> 00:34:22,349
focusing mostly is anything after round

00:34:20,579 --> 00:34:25,319
phase eight anything before that is

00:34:22,349 --> 00:34:26,940
general compiler construction yeah

00:34:25,319 --> 00:34:29,609
the the front end like how the language

00:34:26,940 --> 00:34:31,379
looks this is something we could imagine

00:34:29,609 --> 00:34:37,369
changing and saving multiple of them

00:34:31,379 --> 00:34:37,369
writes potentially thank you thank you

00:34:40,039 --> 00:34:47,010
yeah several questions first is how R is

00:34:44,039 --> 00:34:49,799
insensitive to noisy freedom if you want

00:34:47,010 --> 00:34:52,740
to use apply machine learning using some

00:34:49,799 --> 00:34:55,200
back propagation freedom using

00:34:52,740 --> 00:34:58,380
exponential functions if you just use

00:34:55,200 --> 00:35:01,380
approximation then you add some random

00:34:58,380 --> 00:35:04,529
numbers into the input which might make

00:35:01,380 --> 00:35:10,319
the back pro-beijing have problems

00:35:04,529 --> 00:35:12,599
hobbies of this currently we don't know

00:35:10,319 --> 00:35:15,750
so this is definitely something we're

00:35:12,599 --> 00:35:17,549
working on so whenever you need to

00:35:15,750 --> 00:35:19,349
propagate to get some results back from

00:35:17,549 --> 00:35:21,690
another computation as input to a new

00:35:19,349 --> 00:35:23,220
computation we need to submit a new

00:35:21,690 --> 00:35:26,640
program at the moment and save

00:35:23,220 --> 00:35:29,190
intermediate results to another place

00:35:26,640 --> 00:35:33,470
we were working on maybe making this

00:35:29,190 --> 00:35:35,730
more seamless into and with regards to

00:35:33,470 --> 00:35:38,880
precision right of course we're

00:35:35,730 --> 00:35:42,930
approximating but what we try to we try

00:35:38,880 --> 00:35:44,640
very hard to do is we want sort of the

00:35:42,930 --> 00:35:48,089
same precision whether you would do it

00:35:44,640 --> 00:35:50,549
in plain text or with NPC and so our

00:35:48,089 --> 00:35:53,369
current benchmarks are that we're we're

00:35:50,549 --> 00:35:57,510
in the seven to eight decimal points and

00:35:53,369 --> 00:35:59,609
after the after the unit so which is

00:35:57,510 --> 00:36:03,390
what our customers also expect us to

00:35:59,609 --> 00:36:04,680
have that's already okay so you mean

00:36:03,390 --> 00:36:10,200
that's you can always keep this

00:36:04,680 --> 00:36:13,260
precision regard what kind of inputs yes

00:36:10,200 --> 00:36:14,640
so that's that's what the the the key or

00:36:13,260 --> 00:36:17,880
the most difficult part for us is with

00:36:14,640 --> 00:36:22,349
the static analysis yes okay thank you

00:36:17,880 --> 00:36:25,559
my next question is what is inputs for

00:36:22,349 --> 00:36:32,640
the trusted dealers in general for all

00:36:25,559 --> 00:36:35,250
roadways for your libraries what kind of

00:36:32,640 --> 00:36:37,650
information use in general you provide

00:36:35,250 --> 00:36:40,049
for the chasity doors yes so the the

00:36:37,650 --> 00:36:42,480
trusted so this compiled program which

00:36:40,049 --> 00:36:46,250
comes out of it is you can think of it

00:36:42,480 --> 00:36:49,079
as a graph it's a dag essentially and

00:36:46,250 --> 00:36:51,059
this gets fed into the trusted dealer so

00:36:49,079 --> 00:36:53,549
the trusted dealer knows how much memory

00:36:51,059 --> 00:36:56,220
like so how many secret shares are ever

00:36:53,549 --> 00:36:59,549
need to be generated generates them and

00:36:56,220 --> 00:37:01,789
then sends them to the engines we give

00:36:59,549 --> 00:37:09,000
the trusted deal of the compiled program

00:37:01,789 --> 00:37:11,279
ok ok ok we can discuss later I have

00:37:09,000 --> 00:37:14,940
some more question so my last question

00:37:11,279 --> 00:37:17,640
is because he's a visual computing all

00:37:14,940 --> 00:37:20,519
right what if there are some failures

00:37:17,640 --> 00:37:27,539
happening on one of the nodes how I can

00:37:20,519 --> 00:37:30,089
two-way fight currently large amounts of

00:37:27,539 --> 00:37:33,390
data not large amounts of parties in it

00:37:30,089 --> 00:37:34,619
so we'll have I mean we can have several

00:37:33,390 --> 00:37:37,349
parties but we wouldn't have like

00:37:34,619 --> 00:37:38,609
thousands of parties in a computation so

00:37:37,349 --> 00:37:40,500
if something goes wrong we would just

00:37:38,609 --> 00:37:43,500
restart the computation

00:37:40,500 --> 00:37:47,040
and the how how do you verify like as if

00:37:43,500 --> 00:37:53,510
it's correct some knots right that's a

00:37:47,040 --> 00:38:05,040
good question we can just get that's

00:37:53,510 --> 00:38:06,840
okay okay I think just to summarize so

00:38:05,040 --> 00:38:08,510
the non-interactive zero knowledge

00:38:06,840 --> 00:38:10,830
protocols that could independently

00:38:08,510 --> 00:38:13,260
verify the correctness of the

00:38:10,830 --> 00:38:15,090
computation and just to give an idea so

00:38:13,260 --> 00:38:16,920
one of the the protocols that are used

00:38:15,090 --> 00:38:18,780
there is used also in this cryptographic

00:38:16,920 --> 00:38:22,880
currency Z cache

00:38:18,780 --> 00:38:22,880
so it's called ZK snarks you can do

00:38:29,990 --> 00:38:36,510
unlike we are putting a new public rock

00:38:33,480 --> 00:38:39,450
chain we we investigate the decay

00:38:36,510 --> 00:38:41,730
protocols like people so one is really

00:38:39,450 --> 00:38:43,800
not practical at war if you want to

00:38:41,730 --> 00:38:46,620
provide proofs or if you want really

00:38:43,800 --> 00:38:49,800
just walk with it is like for one

00:38:46,620 --> 00:38:52,920
community it could be like even seconds

00:38:49,800 --> 00:38:55,080
to generates approves you know so you

00:38:52,920 --> 00:38:57,210
can you can provide proof certain

00:38:55,080 --> 00:38:59,180
certain techniques in which we can

00:38:57,210 --> 00:39:02,940
provide proofs we even did it with a

00:38:59,180 --> 00:39:05,430
external company who specializes in non

00:39:02,940 --> 00:39:07,620
interactive zero knowledge protocols so

00:39:05,430 --> 00:39:10,410
for example the program that you saw

00:39:07,620 --> 00:39:14,910
there for that program we can give you a

00:39:10,410 --> 00:39:17,190
proof that convinces the that writing

00:39:14,910 --> 00:39:19,260
zero knowledge proof that the function

00:39:17,190 --> 00:39:21,690
is minimized the objective function in

00:39:19,260 --> 00:39:23,190
machine learning is minimized so if I

00:39:21,690 --> 00:39:24,660
may interrupt please take this offline

00:39:23,190 --> 00:39:26,160
because a few more questions at the back

00:39:24,660 --> 00:39:33,060
that Victor had a question thank you

00:39:26,160 --> 00:39:36,360
thank you I think this may be going to

00:39:33,060 --> 00:39:38,100
the to the hard parts but so do I infer

00:39:36,360 --> 00:39:41,130
correctly that you you need to estimate

00:39:38,100 --> 00:39:43,320
the ranges of these real number

00:39:41,130 --> 00:39:47,280
approximations that you're encountering

00:39:43,320 --> 00:39:49,290
yes exactly so we have actually one of

00:39:47,280 --> 00:39:52,310
the inputs is not only necessary the

00:39:49,290 --> 00:39:55,430
size also distribution of the data

00:39:52,310 --> 00:39:58,460
so for certain types of computations we

00:39:55,430 --> 00:40:00,770
need to know that okay so ii do type

00:39:58,460 --> 00:40:02,090
systems help that or do you feel that

00:40:00,770 --> 00:40:06,130
kind of abstract interpretation

00:40:02,090 --> 00:40:06,130
numerical domains they're a better match

00:40:06,160 --> 00:40:13,160
so i think i think honestly it's a big

00:40:08,720 --> 00:40:15,590
mix of both again for us since so we're

00:40:13,160 --> 00:40:18,290
using sort of a cheated partial

00:40:15,590 --> 00:40:21,440
evaluation to do this but sort of the

00:40:18,290 --> 00:40:23,360
calculus itself is so we haven't

00:40:21,440 --> 00:40:25,310
formalized this but i think something

00:40:23,360 --> 00:40:29,890
like i mean you need you need the actual

00:40:25,310 --> 00:40:32,360
sort of distributions there may be one

00:40:29,890 --> 00:40:34,280
one sort of answer that gives us a

00:40:32,360 --> 00:40:36,680
probable probably future technique is

00:40:34,280 --> 00:40:38,900
sometimes statically estimating them

00:40:36,680 --> 00:40:41,510
using static mathematical knowledge of

00:40:38,900 --> 00:40:43,670
distributions may not be enough so you

00:40:41,510 --> 00:40:46,040
may need to do some computations at

00:40:43,670 --> 00:40:47,740
compile time some random sampling at

00:40:46,040 --> 00:40:53,300
compile time to get you better

00:40:47,740 --> 00:41:00,350
bounds essentially some simulation thank

00:40:53,300 --> 00:41:06,050
you could you please point some public

00:41:00,350 --> 00:41:08,990
results that explain so yeah definitely

00:41:06,050 --> 00:41:11,980
so there is the sort of the main

00:41:08,990 --> 00:41:14,960
reference for what we do is called

00:41:11,980 --> 00:41:17,990
unfortunately flights but it's called

00:41:14,960 --> 00:41:22,580
the dispatch speeds protocol so SP TZ

00:41:17,990 --> 00:41:24,590
for the four offers that and this is

00:41:22,580 --> 00:41:27,790
this is sort of the setting that we use

00:41:24,590 --> 00:41:32,150
which is you know honest but curious

00:41:27,790 --> 00:41:34,220
with trusted dealer that would be a good

00:41:32,150 --> 00:41:37,670
good place to start another good place

00:41:34,220 --> 00:41:39,530
to start I would say is checkout so

00:41:37,670 --> 00:41:41,780
actually check out our repo because

00:41:39,530 --> 00:41:44,660
we've posted a few links and there's one

00:41:41,780 --> 00:41:47,150
other tutorial by Morton dal he goes

00:41:44,660 --> 00:41:54,350
into some of the details it's very very

00:41:47,150 --> 00:41:56,700
educative yeah so he sorry

00:41:54,350 --> 00:41:59,030
our language do we want to open source

00:41:56,700 --> 00:42:01,290
it so that's um that's a very

00:41:59,030 --> 00:42:04,680
interesting question and sort of tough

00:42:01,290 --> 00:42:08,310
question because actually we have this

00:42:04,680 --> 00:42:11,940
yeah so we have the the problem is so

00:42:08,310 --> 00:42:13,650
our security model sort of tolerates

00:42:11,940 --> 00:42:18,860
some things but there are other attacks

00:42:13,650 --> 00:42:21,750
so particularly if I can send multiple

00:42:18,860 --> 00:42:23,700
sort of orchestrated values to the

00:42:21,750 --> 00:42:27,720
secret computation such that I can

00:42:23,700 --> 00:42:31,020
recover the other person's data and so

00:42:27,720 --> 00:42:33,390
this is where something like a privacy

00:42:31,020 --> 00:42:35,370
budget would be nice so you want to have

00:42:33,390 --> 00:42:38,430
a static analysis which tells you hey

00:42:35,370 --> 00:42:41,160
you sort of york the computation you're

00:42:38,430 --> 00:42:44,520
doing will leak data and we don't have

00:42:41,160 --> 00:42:47,040
this for now and so since our costs for

00:42:44,520 --> 00:42:49,260
now our customers are fairly have very

00:42:47,040 --> 00:42:51,330
sensitive data we don't want them to

00:42:49,260 --> 00:42:53,190
shoot themselves in the food just yet an

00:42:51,330 --> 00:42:55,140
example would be you just it's an O of

00:42:53,190 --> 00:42:57,180
the identity or even just transpose a

00:42:55,140 --> 00:42:59,190
matrix and give me the result back well

00:42:57,180 --> 00:43:01,500
you can trivially revert that so we

00:42:59,190 --> 00:43:03,270
don't have this concept yet but it's

00:43:01,500 --> 00:43:06,770
something which would be super exciting

00:43:03,270 --> 00:43:06,770
if we could do some research into that

00:43:09,740 --> 00:43:14,400
so if I understand correctly there's

00:43:11,820 --> 00:43:16,650
some trade-off between like your how

00:43:14,400 --> 00:43:19,710
complex from masking is and like how

00:43:16,650 --> 00:43:22,710
security security is versus how much

00:43:19,710 --> 00:43:24,920
your computation is time a computation

00:43:22,710 --> 00:43:33,630
time you're going to take so how do you

00:43:24,920 --> 00:43:35,940
choose what trader currently 40-bit yeah

00:43:33,630 --> 00:43:38,820
so security is actually paramount for us

00:43:35,940 --> 00:43:40,380
I mean Dimitar confirm that but the idea

00:43:38,820 --> 00:43:43,890
is again

00:43:40,380 --> 00:43:45,930
customers are you know they need the

00:43:43,890 --> 00:43:47,460
actual some level of security which in

00:43:45,930 --> 00:43:49,500
this case is the computational security

00:43:47,460 --> 00:43:51,030
I was mentioning earlier so we need to

00:43:49,500 --> 00:43:54,000
do we need to make sure that all our

00:43:51,030 --> 00:43:55,740
algorithms and protocols match this

00:43:54,000 --> 00:43:58,500
security requirement so that's the

00:43:55,740 --> 00:44:00,180
trade-off so basically if you think

00:43:58,500 --> 00:44:03,330
about standard symmetric encryption

00:44:00,180 --> 00:44:05,490
nowadays there are standards for how

00:44:03,330 --> 00:44:08,340
many bits of security you want

00:44:05,490 --> 00:44:10,110
and what is the amount of work that you

00:44:08,340 --> 00:44:14,070
need to do in order to break a scheme

00:44:10,110 --> 00:44:16,800
for example AES so people advice make

00:44:14,070 --> 00:44:19,680
certainly over 80 bits of security so

00:44:16,800 --> 00:44:22,140
based on that these standards you could

00:44:19,680 --> 00:44:24,930
define your global compiler parameters

00:44:22,140 --> 00:44:31,670
that are going to guarantee security if

00:44:24,930 --> 00:44:35,970
you follow the protocol to to the 40

00:44:31,670 --> 00:44:37,620
bits 40 bits for online operations so

00:44:35,970 --> 00:44:40,380
interactive queries which is largely

00:44:37,620 --> 00:44:42,390
sufficient for any data at rest that you

00:44:40,380 --> 00:44:44,520
could like if you were to take it and

00:44:42,390 --> 00:44:47,880
analyze it we're much more secure like

00:44:44,520 --> 00:44:49,680
AES 1 to 20 over 128 or something like

00:44:47,880 --> 00:44:55,710
this yes so you want to match the

00:44:49,680 --> 00:44:57,750
security of AES 128 actually names to

00:44:55,710 --> 00:44:59,790
the our product is called XOR and

00:44:57,750 --> 00:45:01,130
there's many reasons one of them is XOR

00:44:59,790 --> 00:45:03,270
is from the one-time pad

00:45:01,130 --> 00:45:04,890
information-theoretic security I mean

00:45:03,270 --> 00:45:08,100
it's it's also fast and used in many

00:45:04,890 --> 00:45:10,100
cryptographic operations well no

00:45:08,100 --> 00:45:13,230
question the back yeah

00:45:10,100 --> 00:45:16,280
thanks I have a question regarding gdpr

00:45:13,230 --> 00:45:20,220
because there is right to be forgotten

00:45:16,280 --> 00:45:23,250
in GDP and from the algorithm itself it

00:45:20,220 --> 00:45:27,420
looks like if one of their employees

00:45:23,250 --> 00:45:29,190
like on your first example exercises the

00:45:27,420 --> 00:45:31,920
right to be forgotten then I need to

00:45:29,190 --> 00:45:34,230
recompute the values for everyone else

00:45:31,920 --> 00:45:36,480
and it feels like a very computation

00:45:34,230 --> 00:45:41,610
heavy in case you have a lot of users

00:45:36,480 --> 00:45:44,220
how do you tackle that well I so my

00:45:41,610 --> 00:45:48,360
answer to this is that I mean I can't

00:45:44,220 --> 00:45:50,160
use cases we don't so we don't have

00:45:48,360 --> 00:45:52,050
currently haven't faced this issue

00:45:50,160 --> 00:45:54,120
directly because most of our current use

00:45:52,050 --> 00:45:57,960
cases are about sort of one entity

00:45:54,120 --> 00:45:59,580
managing multiple distinct but sensitive

00:45:57,960 --> 00:46:01,740
entities right like a bank for instance

00:45:59,580 --> 00:46:04,140
so all their data sources are belong to

00:46:01,740 --> 00:46:08,430
them they're just the lords allows them

00:46:04,140 --> 00:46:10,770
to sort of exchange things I'm a user of

00:46:08,430 --> 00:46:13,320
the bank and I can request my data to be

00:46:10,770 --> 00:46:14,850
forgotten forever by the bank so I don't

00:46:13,320 --> 00:46:16,800
want it to be used in the training of

00:46:14,850 --> 00:46:18,850
the models I don't want it to be used

00:46:16,800 --> 00:46:21,730
everywhere and it's my gdpr right

00:46:18,850 --> 00:46:23,650
so it feels like in that case the bank

00:46:21,730 --> 00:46:25,990
needs will be enough like recomputing a

00:46:23,650 --> 00:46:29,500
lot of things so that's why we need to

00:46:25,990 --> 00:46:31,480
make it very efficient I guess we don't

00:46:29,500 --> 00:46:33,310
address this problem we are really in

00:46:31,480 --> 00:46:35,470
privacy-preserving so I don't know maybe

00:46:33,310 --> 00:46:38,320
this I don't know the exact legal

00:46:35,470 --> 00:46:40,390
details of GDP are but is it maybe it's

00:46:38,320 --> 00:46:42,790
sufficient if you an anonymize maybe

00:46:40,390 --> 00:46:46,900
user handles or anything before they

00:46:42,790 --> 00:46:49,030
they get they get shared so what is

00:46:46,900 --> 00:46:51,040
important is that your data never leaves

00:46:49,030 --> 00:46:53,410
the bank never leaves the source with

00:46:51,040 --> 00:46:55,630
this protocol that's why big maker

00:46:53,410 --> 00:47:01,390
McKinsey estimated that this falls

00:46:55,630 --> 00:47:04,770
outside of the scope of GDP are any

00:47:01,390 --> 00:47:08,860
other questions or one more question

00:47:04,770 --> 00:47:14,980
hello how does your solution currently

00:47:08,860 --> 00:47:17,250
compares to a technical what of a

00:47:14,980 --> 00:47:20,560
solution for privacy-preserving

00:47:17,250 --> 00:47:25,470
computation like what you you can have

00:47:20,560 --> 00:47:25,470
in a tons of refrigerated and open mind

00:47:26,850 --> 00:47:31,630
so how does the solution from a

00:47:29,740 --> 00:47:36,880
cryptographic side compares to a

00:47:31,630 --> 00:47:39,280
transfer flow was that the question well

00:47:36,880 --> 00:47:42,070
it would be more on the commercial side

00:47:39,280 --> 00:47:46,480
because you your competitors today

00:47:42,070 --> 00:47:50,290
they're people like your tens of tons of

00:47:46,480 --> 00:47:52,330
about by by Google and they using tons

00:47:50,290 --> 00:47:55,450
of a fidelity you can do secure

00:47:52,330 --> 00:47:57,820
multi-party computation right right I

00:47:55,450 --> 00:47:59,110
see the question so so this is a there

00:47:57,820 --> 00:48:00,600
is a good distinction between

00:47:59,110 --> 00:48:02,920
[Music]

00:48:00,600 --> 00:48:04,960
multi-party computation and federated

00:48:02,920 --> 00:48:07,570
learning so federated learning is a

00:48:04,960 --> 00:48:09,640
protocol where we could all collectively

00:48:07,570 --> 00:48:12,100
do a computation here

00:48:09,640 --> 00:48:14,590
everybody in this room so everybody

00:48:12,100 --> 00:48:16,990
computes locally on a device and then

00:48:14,590 --> 00:48:19,120
sends a local resolve to a server that

00:48:16,990 --> 00:48:22,960
is going to aggregate the result of the

00:48:19,120 --> 00:48:24,610
computation so obviously this is this is

00:48:22,960 --> 00:48:27,550
very different than secure multi-party

00:48:24,610 --> 00:48:31,569
computation where you're not sending in

00:48:27,550 --> 00:48:34,359
any kind of even aggregated data

00:48:31,569 --> 00:48:36,880
artists they just computing completely

00:48:34,359 --> 00:48:38,920
decentralized distributed normal and

00:48:36,880 --> 00:48:40,989
then at the end of the computation you

00:48:38,920 --> 00:48:42,969
are getting the result in sacred shared

00:48:40,989 --> 00:48:45,489
so you don't have to even reveal the

00:48:42,969 --> 00:48:48,489
result to that to the public or to the

00:48:45,489 --> 00:48:50,529
analyst so it's it's very different but

00:48:48,489 --> 00:48:53,289
the Torah in the very different use

00:48:50,529 --> 00:48:56,259
cases and in the situation where for

00:48:53,289 --> 00:48:59,079
example you want to compute between a

00:48:56,259 --> 00:49:01,239
handful of hospitals then secure

00:48:59,079 --> 00:49:03,279
multi-party competitions for various

00:49:01,239 --> 00:49:05,859
mathematical functions is much more

00:49:03,279 --> 00:49:07,690
appropriate than then federated learning

00:49:05,859 --> 00:49:09,219
Google is interested in federated

00:49:07,690 --> 00:49:12,249
learning obviously because they have

00:49:09,219 --> 00:49:14,920
they want many many many parties to do a

00:49:12,249 --> 00:49:16,599
collective computation but even from a

00:49:14,920 --> 00:49:23,739
security point of view it's it's it's

00:49:16,599 --> 00:49:25,779
very different does that answer great

00:49:23,739 --> 00:49:28,040
looks like then it's time to have lunch

00:49:25,779 --> 00:49:30,420
thank you very much

00:49:28,040 --> 00:49:30,420

YouTube URL: https://www.youtube.com/watch?v=44EL11N3tOs


