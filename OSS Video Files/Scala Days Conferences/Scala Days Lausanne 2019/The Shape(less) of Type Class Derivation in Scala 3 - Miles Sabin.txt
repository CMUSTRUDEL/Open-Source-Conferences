Title: The Shape(less) of Type Class Derivation in Scala 3 - Miles Sabin
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/the-shapeless-of-type-class-derivation-in-scala-3
Captions: 
	00:00:00,000 --> 00:00:19,320
oh well well good afternoon everybody

00:00:14,120 --> 00:00:21,330
welcome again to the 10th anniversary of

00:00:19,320 --> 00:00:25,230
scarlet eyes this is a much much bigger

00:00:21,330 --> 00:00:29,820
room bigger stage than I I had when I

00:00:25,230 --> 00:00:31,529
was here ten years ago more people it's

00:00:29,820 --> 00:00:32,850
very bright someone else mentioned that

00:00:31,529 --> 00:00:36,690
it's incredibly bright it's quite hard

00:00:32,850 --> 00:00:38,430
to see everybody and hopefully this time

00:00:36,690 --> 00:00:40,469
around I'm also gonna be talking talking

00:00:38,430 --> 00:00:41,960
that's me a little bit more exciting my

00:00:40,469 --> 00:00:46,579
topic

00:00:41,960 --> 00:00:50,329
ten years ago I'm gonna be talking about

00:00:46,579 --> 00:00:54,570
tantric last derivation in Scylla three

00:00:50,329 --> 00:00:55,680
I'm kind of reporting on I suppose

00:00:54,570 --> 00:00:58,920
reporting back on work that I've been

00:00:55,680 --> 00:01:00,870
doing jointly with Martin and his group

00:00:58,920 --> 00:01:04,080
EPFL I guess I've been working on it

00:01:00,870 --> 00:01:06,900
more or less restful time since since

00:01:04,080 --> 00:01:08,070
October but it's also a kind of a

00:01:06,900 --> 00:01:13,710
continuation of other work that I've

00:01:08,070 --> 00:01:18,830
been doing with with welcome Tati work

00:01:13,710 --> 00:01:25,380
with Scala compiler team at light band

00:01:18,830 --> 00:01:28,080
basically trying to make the the Scala

00:01:25,380 --> 00:01:31,549
three future safe for for the kinds of

00:01:28,080 --> 00:01:31,549
things that people have been using

00:01:31,700 --> 00:01:37,619
shapeless for in scarlet - given the

00:01:36,180 --> 00:01:40,799
fact that things are going to change so

00:01:37,619 --> 00:01:42,930
much in Scala three uses so it makes it

00:01:40,799 --> 00:01:45,570
fairly essential use of a ton of macros

00:01:42,930 --> 00:01:47,490
which as we now understand there's

00:01:45,570 --> 00:01:50,250
really really very prospect of those

00:01:47,490 --> 00:01:53,460
things carrying forward across the gap

00:01:50,250 --> 00:01:55,770
between Scala - in Scala 3 and I've also

00:01:53,460 --> 00:01:57,869
used this process as being a fantastic

00:01:55,770 --> 00:02:00,570
opportunity to really just sit down and

00:01:57,869 --> 00:02:04,490
take a completely fresh look at how

00:02:00,570 --> 00:02:06,450
tight derivation should work in Scala

00:02:04,490 --> 00:02:07,890
reevaluate some of the decisions I made

00:02:06,450 --> 00:02:10,319
in shape with something it's been around

00:02:07,890 --> 00:02:11,130
for quite a few years now there are many

00:02:10,319 --> 00:02:13,080
many things

00:02:11,130 --> 00:02:15,030
that you know with the benefit of

00:02:13,080 --> 00:02:16,530
hindsight but not the greatest ideas and

00:02:15,030 --> 00:02:19,080
it's a wonderful opportunity to

00:02:16,530 --> 00:02:24,330
basically have a chance to start again

00:02:19,080 --> 00:02:27,210
from scratch and yeah so it's great

00:02:24,330 --> 00:02:28,410
opportunity and and I I think I'm very

00:02:27,210 --> 00:02:32,280
happy with the way things have gone I

00:02:28,410 --> 00:02:34,170
mean obviously it's not it's not really

00:02:32,280 --> 00:02:35,850
for me to judge it's really for the

00:02:34,170 --> 00:02:37,380
people who actually end up and I'm using

00:02:35,850 --> 00:02:39,480
this stuff to decide whether or not I've

00:02:37,380 --> 00:02:43,560
been successful but certainly I had a

00:02:39,480 --> 00:02:48,120
ton of long-standing open problems in

00:02:43,560 --> 00:02:51,600
shapeless that that I it took me a very

00:02:48,120 --> 00:02:53,550
very long time perhaps perhaps longer

00:02:51,600 --> 00:02:55,050
than that maybe was reasonable but I

00:02:53,550 --> 00:02:56,640
mean it certainly take me taking me a

00:02:55,050 --> 00:03:01,140
long time to actually actually get my

00:02:56,640 --> 00:03:04,530
way to somewhere really satisfactory but

00:03:01,140 --> 00:03:05,880
I kind of feel like I've got there so

00:03:04,530 --> 00:03:08,910
I'm quite I'm quite I'm quite pleased

00:03:05,880 --> 00:03:10,320
with the result I was also very

00:03:08,910 --> 00:03:12,990
interested to see that when Martin did

00:03:10,320 --> 00:03:15,960
his sort of informal Twitter poll of you

00:03:12,990 --> 00:03:19,560
know the most anticipated eagerly

00:03:15,960 --> 00:03:21,840
anticipated features for the scottie

00:03:19,560 --> 00:03:24,180
features in scarlet 3 for expert

00:03:21,840 --> 00:03:26,160
programmers that talk last ovation came

00:03:24,180 --> 00:03:27,660
out top and there's kind of a couple of

00:03:26,160 --> 00:03:29,130
conclusions I draw from that and one of

00:03:27,660 --> 00:03:30,930
them is obviously that you know total

00:03:29,130 --> 00:03:35,670
isolation is something which people find

00:03:30,930 --> 00:03:38,310
very interesting and and are trying to

00:03:35,670 --> 00:03:40,050
do and the other conclusion I draw is

00:03:38,310 --> 00:03:42,060
that is that is that they find it quite

00:03:40,050 --> 00:03:43,140
difficult at the moment for a variety of

00:03:42,060 --> 00:03:45,990
reasons and they're probably using

00:03:43,140 --> 00:03:48,960
shadeless to do it and which suggests

00:03:45,990 --> 00:03:50,880
that you know for all that shake their

00:03:48,960 --> 00:03:52,320
souls a bunch of problems yeah that

00:03:50,880 --> 00:03:52,950
brings a bunch of its own problems in

00:03:52,320 --> 00:03:55,980
its wake

00:03:52,950 --> 00:03:58,020
and people are probably quite actually

00:03:55,980 --> 00:04:00,630
necessarily desperate but we're quite

00:03:58,020 --> 00:04:02,940
keen to see something happening in Scala

00:04:00,630 --> 00:04:04,980
3 that that makes their lives easier so

00:04:02,940 --> 00:04:07,790
and again hopefully hopefully the kind

00:04:04,980 --> 00:04:10,370
of stuff that so I've come up with will

00:04:07,790 --> 00:04:13,920
ease some of the pain that people feel

00:04:10,370 --> 00:04:15,720
anyway without more ado here we go hard

00:04:13,920 --> 00:04:17,330
clustering what is it well I kind of

00:04:15,720 --> 00:04:19,830
assume that most of the people here and

00:04:17,330 --> 00:04:22,280
know what it is but just a brief

00:04:19,830 --> 00:04:22,280
reminder

00:04:22,310 --> 00:04:26,840
what curse that derivation is a

00:04:24,710 --> 00:04:29,360
mechanism for automatically inferring

00:04:26,840 --> 00:04:33,590
tight class instances for algebraic data

00:04:29,360 --> 00:04:39,080
types based on structure of the

00:04:33,590 --> 00:04:41,570
algebraic data type and given instances

00:04:39,080 --> 00:04:45,380
of that by class or perhaps related to

00:04:41,570 --> 00:04:48,200
our classes for the component parts of

00:04:45,380 --> 00:04:50,360
the algebraic data type so here's an

00:04:48,200 --> 00:04:52,220
example of the kind of thing we're

00:04:50,360 --> 00:04:54,440
talking about suppose we have you know

00:04:52,220 --> 00:04:59,630
show type class the show type class from

00:04:54,440 --> 00:05:04,820
cats or something similar we have a case

00:04:59,630 --> 00:05:07,280
class case class imaginatively named is

00:05:04,820 --> 00:05:12,040
B because it contains an integer string

00:05:07,280 --> 00:05:15,650
and a boolean a simple product type and

00:05:12,040 --> 00:05:20,260
we have instances for the components of

00:05:15,650 --> 00:05:22,160
that type so we have a we're assuming I

00:05:20,260 --> 00:05:24,550
suppose these should be delegates now

00:05:22,160 --> 00:05:27,590
that anyway we're assuming that we have

00:05:24,550 --> 00:05:29,900
instances available in scoped for show

00:05:27,590 --> 00:05:32,300
for an industry in a boolean and then

00:05:29,900 --> 00:05:35,620
what we're saying is that we would like

00:05:32,300 --> 00:05:42,200
the compiler to help us synthesize a

00:05:35,620 --> 00:05:44,140
sensible show instance for is B based

00:05:42,200 --> 00:05:49,280
purely on the structure of the type and

00:05:44,140 --> 00:05:52,430
the and the the type los instances for

00:05:49,280 --> 00:05:55,580
the components so we should be able to

00:05:52,430 --> 00:05:57,200
summon an instance of show is B without

00:05:55,580 --> 00:06:03,680
writing any more code that's that's the

00:05:57,200 --> 00:06:06,830
essential idea okay so what so the way I

00:06:03,680 --> 00:06:09,110
guess you know tiny bit the way

00:06:06,830 --> 00:06:10,400
the way people address this in Scala to

00:06:09,110 --> 00:06:14,840
currently is using libraries like

00:06:10,400 --> 00:06:16,370
shapeless that will help generate help

00:06:14,840 --> 00:06:19,700
automate the process of doing that and

00:06:16,370 --> 00:06:21,800
so what what is what is what is Scala 3

00:06:19,700 --> 00:06:23,600
going to bring to the table that I

00:06:21,800 --> 00:06:25,670
thought I think proves on that or

00:06:23,600 --> 00:06:30,980
replaces that

00:06:25,670 --> 00:06:32,930
or whatever so the way that Joseon

00:06:30,980 --> 00:06:35,240
scholar three are going to support type

00:06:32,930 --> 00:06:39,020
class derivation is for accommodation of

00:06:35,240 --> 00:06:41,210
a small number of compiler supported

00:06:39,020 --> 00:06:45,500
primitives and these are sort of

00:06:41,210 --> 00:06:50,060
primitive types and primitive types of

00:06:45,500 --> 00:06:53,420
mechanisms we have a type called mirror

00:06:50,060 --> 00:06:56,020
which plays a similar kind of role to

00:06:53,420 --> 00:06:59,600
the one that generic plays in trailers

00:06:56,020 --> 00:07:02,210
we have derives clauses these are ways

00:06:59,600 --> 00:07:07,880
of annotating algebraic data types to

00:07:02,210 --> 00:07:09,920
say that you would that the consumer of

00:07:07,880 --> 00:07:13,550
those data types would like instances

00:07:09,920 --> 00:07:17,090
for some known set of type classes to be

00:07:13,550 --> 00:07:22,520
as it were pre computed and and made

00:07:17,090 --> 00:07:26,020
available in an in a in a cached form I

00:07:22,520 --> 00:07:30,070
suppose without without requiring

00:07:26,020 --> 00:07:34,430
re recreation that each each education

00:07:30,070 --> 00:07:37,970
where they used and the third component

00:07:34,430 --> 00:07:40,450
which interacts with the first is a sort

00:07:37,970 --> 00:07:43,370
of a concurrent convention driven

00:07:40,450 --> 00:07:46,750
mechanism whereby authors of type

00:07:43,370 --> 00:07:50,180
classes can opt into a mechanism

00:07:46,750 --> 00:07:53,540
enabling those derives clauses to

00:07:50,180 --> 00:07:55,480
compute instances of type classes

00:07:53,540 --> 00:07:58,220
without having to go directly through

00:07:55,480 --> 00:08:02,110
interest resolution mechanisms so that

00:07:58,220 --> 00:08:04,670
those are the compiler provided

00:08:02,110 --> 00:08:06,050
components and as I mentioned that

00:08:04,670 --> 00:08:07,640
they're very minimal we'll go through

00:08:06,050 --> 00:08:10,820
them in a little bit more detail in a

00:08:07,640 --> 00:08:14,110
second and they aren't I think although

00:08:10,820 --> 00:08:17,780
Martin has been sort of demonstrating

00:08:14,110 --> 00:08:20,230
some he showed in his keynote yesterday

00:08:17,780 --> 00:08:24,680
evening he showed how one might go about

00:08:20,230 --> 00:08:27,590
implementing the derived method for a

00:08:24,680 --> 00:08:30,320
retired class on its high cost companion

00:08:27,590 --> 00:08:31,580
object and using using a combination of

00:08:30,320 --> 00:08:32,270
dotted features in particular

00:08:31,580 --> 00:08:33,860
interlining

00:08:32,270 --> 00:08:38,029
inline matches and

00:08:33,860 --> 00:08:40,489
implicit matches it's it's probably

00:08:38,029 --> 00:08:42,259
something you wouldn't want to do by

00:08:40,489 --> 00:08:44,179
hand it's quite it's quite a because

00:08:42,259 --> 00:08:46,459
because the mechanisms provided are

00:08:44,179 --> 00:08:48,529
really quite low level you end up

00:08:46,459 --> 00:08:51,499
certainly you would have to write a lot

00:08:48,529 --> 00:08:55,189
of code yourself that code it's taking

00:08:51,499 --> 00:08:56,720
one particular kind of stance on what

00:08:55,189 --> 00:08:59,059
what kind of goals you might want to

00:08:56,720 --> 00:09:00,649
have so you use this aggressive inlining

00:08:59,059 --> 00:09:02,720
which you know in some circumstances

00:09:00,649 --> 00:09:04,220
could could produce very very

00:09:02,720 --> 00:09:05,660
efficiently this is very high very high

00:09:04,220 --> 00:09:07,309
performance code on the other hand

00:09:05,660 --> 00:09:11,959
produces a lot of code and a lot of code

00:09:07,309 --> 00:09:13,309
is often not a good thing and so this

00:09:11,959 --> 00:09:16,670
isn't necessarily the approach you want

00:09:13,309 --> 00:09:18,100
to take it's it requires a lot of work

00:09:16,670 --> 00:09:21,639
by

00:09:18,100 --> 00:09:27,350
high-class authors library maintainer x'

00:09:21,639 --> 00:09:29,689
and Annie and it has a certain amount of

00:09:27,350 --> 00:09:31,999
at least you know overhead in terms of

00:09:29,689 --> 00:09:35,269
bytecode footprints and such like so um

00:09:31,999 --> 00:09:38,899
the the other component of type class

00:09:35,269 --> 00:09:40,819
derivation for scale three is going to

00:09:38,899 --> 00:09:42,949
be provided by third-party libraries and

00:09:40,819 --> 00:09:45,439
and sort of in conjunction with working

00:09:42,949 --> 00:09:49,009
on the cost over version primitives I

00:09:45,439 --> 00:09:52,610
have also been working on a a version of

00:09:49,009 --> 00:09:55,869
shapeless three currently only the type

00:09:52,610 --> 00:09:58,519
cost derivation components making use of

00:09:55,869 --> 00:10:01,790
these facilities partly is a

00:09:58,519 --> 00:10:03,559
demonstration that that we're baking

00:10:01,790 --> 00:10:05,420
into the language baking are actually

00:10:03,559 --> 00:10:07,850
good enough to do the job well enough

00:10:05,420 --> 00:10:09,889
and but also you know because because

00:10:07,850 --> 00:10:11,749
because these are primitives people we

00:10:09,889 --> 00:10:13,549
won't be wanting people to use these

00:10:11,749 --> 00:10:15,559
things directly to have something

00:10:13,549 --> 00:10:17,110
available people can start playing

00:10:15,559 --> 00:10:19,879
around as soon as possible

00:10:17,110 --> 00:10:22,129
so it's a preview it's on github we'll

00:10:19,879 --> 00:10:24,529
get to a little bit later ok so what do

00:10:22,129 --> 00:10:27,319
we get we get mirrors so that's the

00:10:24,529 --> 00:10:30,860
first component of the compiler support

00:10:27,319 --> 00:10:32,749
that I mentioned so a mirror is it's a

00:10:30,860 --> 00:10:35,480
generic programming primitive it's a

00:10:32,749 --> 00:10:37,910
compiler intrinsic for scarlet algebraic

00:10:35,480 --> 00:10:40,189
data types by Mitch by which we mean

00:10:37,910 --> 00:10:42,889
sealed traits and case classes but also

00:10:40,189 --> 00:10:43,830
in on some in the new there is really no

00:10:42,889 --> 00:10:45,690
difference

00:10:43,830 --> 00:10:47,250
in terms of support between steel tropes

00:10:45,690 --> 00:10:51,060
and coast glasses and in ups in this

00:10:47,250 --> 00:10:53,340
respect and crucially and this this is

00:10:51,060 --> 00:10:55,110
the this is the thing that I'm I'm

00:10:53,340 --> 00:10:58,140
personally I'm quite excited about and

00:10:55,110 --> 00:11:02,010
it supports algebraic data types of all

00:10:58,140 --> 00:11:03,480
kinds we'll see in a second

00:11:02,010 --> 00:11:06,210
this has been something which is which

00:11:03,480 --> 00:11:08,970
in my opinion has sort of caused

00:11:06,210 --> 00:11:12,030
shapeless ease ongoing developments sort

00:11:08,970 --> 00:11:13,140
of grind to a halt over well over a year

00:11:12,030 --> 00:11:14,460
ago I think trying to wrestle with

00:11:13,140 --> 00:11:16,500
exactly how to deal with that now so

00:11:14,460 --> 00:11:19,140
this is this represents from my point of

00:11:16,500 --> 00:11:20,370
view real real progress and and as I

00:11:19,140 --> 00:11:23,580
mentioned it's intentionally very low

00:11:20,370 --> 00:11:29,760
level so what do you get so the mirror

00:11:23,580 --> 00:11:34,530
type is essentially a really it's it's a

00:11:29,760 --> 00:11:36,750
bag of types and one method each for

00:11:34,530 --> 00:11:38,640
each of some types which correspond to

00:11:36,750 --> 00:11:43,770
seal traits or the top level of an enum

00:11:38,640 --> 00:11:46,500
and one method for product types and so

00:11:43,770 --> 00:11:47,940
the types that's unless and roughly

00:11:46,500 --> 00:11:50,040
speaking these you can imagine these

00:11:47,940 --> 00:11:54,210
things being implemented by the

00:11:50,040 --> 00:11:55,980
companion objects of of the summer

00:11:54,210 --> 00:11:57,870
product type so for example if we have

00:11:55,980 --> 00:12:00,810
case class a case class has a companion

00:11:57,870 --> 00:12:03,990
object we would expect a case class to

00:12:00,810 --> 00:12:11,370
implement the the product trait that you

00:12:03,990 --> 00:12:13,410
can see slide here and a sealed trait

00:12:11,370 --> 00:12:15,960
well sealed trait doesn't automatically

00:12:13,410 --> 00:12:17,490
I have a companion objects an enum on

00:12:15,960 --> 00:12:18,630
the other hand does automatically have a

00:12:17,490 --> 00:12:20,520
companion object so we would imagine

00:12:18,630 --> 00:12:22,620
certainly the enum well it is the

00:12:20,520 --> 00:12:25,860
companion object we would imagine that

00:12:22,620 --> 00:12:29,940
unum directly implementing the the

00:12:25,860 --> 00:12:34,770
mirror some subtype and so let's see

00:12:29,940 --> 00:12:37,500
what these these things are off so let's

00:12:34,770 --> 00:12:41,880
have a look so here is our instinct

00:12:37,500 --> 00:12:44,550
boolean face class so what we get from

00:12:41,880 --> 00:12:46,590
this as a combination of things which

00:12:44,550 --> 00:12:48,090
are provided by the case cross companion

00:12:46,590 --> 00:12:49,500
and also things which are as it were

00:12:48,090 --> 00:12:52,080
synthesized by the compiler when you

00:12:49,500 --> 00:12:54,210
actually ask for an instance of the

00:12:52,080 --> 00:12:57,000
mirror at as a call site for a

00:12:54,210 --> 00:13:00,660
particular type is you get

00:12:57,000 --> 00:13:03,750
a value of this product mirror product

00:13:00,660 --> 00:13:05,880
type and it contains a number of types

00:13:03,750 --> 00:13:07,740
the time you're going to ask for it by

00:13:05,880 --> 00:13:10,500
is the mirrored type so this is the type

00:13:07,740 --> 00:13:12,180
I'm requesting a mirror for and you can

00:13:10,500 --> 00:13:15,330
see this is done via a tight refinement

00:13:12,180 --> 00:13:17,220
and there is this thing called a

00:13:15,330 --> 00:13:18,750
mirrored monotype which will become a

00:13:17,220 --> 00:13:20,880
little bit clearer well that means in a

00:13:18,750 --> 00:13:24,390
slide or two and then we have a number

00:13:20,880 --> 00:13:26,900
of things which may be kind of slightly

00:13:24,390 --> 00:13:30,630
peculiar but but what we have are types

00:13:26,900 --> 00:13:32,910
corresponding to the the name of the

00:13:30,630 --> 00:13:37,140
type so this is a singleton little or a

00:13:32,910 --> 00:13:39,180
string literal type and also a type

00:13:37,140 --> 00:13:40,740
corresponding to the labels of the

00:13:39,180 --> 00:13:43,350
element as you can see we've got a tuple

00:13:40,740 --> 00:13:46,050
here and it's a tuple of the string

00:13:43,350 --> 00:13:47,160
literal types is and B corresponding to

00:13:46,050 --> 00:13:50,600
the labels of the elements of the type

00:13:47,160 --> 00:13:53,100
now what the rationale for making these

00:13:50,600 --> 00:13:54,650
type members run value members is its

00:13:53,100 --> 00:13:57,600
footprint and these things are types

00:13:54,650 --> 00:14:00,870
they have no they have no they leave no

00:13:57,600 --> 00:14:02,550
traces in byte code may be apart from

00:14:00,870 --> 00:14:04,320
Scala signatures but in terms of byte

00:14:02,550 --> 00:14:05,730
code that has to be loaded by a JVM when

00:14:04,320 --> 00:14:07,440
you're running code there is nothing

00:14:05,730 --> 00:14:10,500
there this is this is all stuff which is

00:14:07,440 --> 00:14:13,080
computed consumed at compile time so the

00:14:10,500 --> 00:14:16,050
idea here is then we are going to be if

00:14:13,080 --> 00:14:17,970
we need them using type level

00:14:16,050 --> 00:14:20,550
programming mechanisms the sort of

00:14:17,970 --> 00:14:22,110
scholars sort of near dependently type

00:14:20,550 --> 00:14:24,000
mechanism is to sort of bridge the gap

00:14:22,110 --> 00:14:25,440
between something which is represented

00:14:24,000 --> 00:14:26,730
by a string literal type and an actual

00:14:25,440 --> 00:14:28,890
runtime value which we can use

00:14:26,730 --> 00:14:31,020
mechanisms provided by the compiler to

00:14:28,890 --> 00:14:33,540
give it to give us one of those the

00:14:31,020 --> 00:14:35,130
other crucial component is the element

00:14:33,540 --> 00:14:37,770
types so you can see here this is a

00:14:35,130 --> 00:14:40,860
tuple so for our is B type which

00:14:37,770 --> 00:14:42,750
contains an int of string boolean the

00:14:40,860 --> 00:14:45,180
element type is itself for two buildings

00:14:42,750 --> 00:14:46,170
and string a food here and people who've

00:14:45,180 --> 00:14:47,820
played around with show course will

00:14:46,170 --> 00:14:49,470
recognize immediately see there's a bit

00:14:47,820 --> 00:14:51,330
of a difference there are no age lists

00:14:49,470 --> 00:14:52,980
here these are just two ports and it

00:14:51,330 --> 00:14:56,510
turns out that we really just don't need

00:14:52,980 --> 00:15:01,050
to have any kind of specialized

00:14:56,510 --> 00:15:02,640
representation for for these collections

00:15:01,050 --> 00:15:03,840
and types tuples typically just fine I

00:15:02,640 --> 00:15:05,670
mean that they're perfectly good things

00:15:03,840 --> 00:15:08,990
for representing representing

00:15:05,670 --> 00:15:08,990
essentially a list of types

00:15:09,100 --> 00:15:14,510
okay so that's that's that's for a

00:15:12,230 --> 00:15:16,760
single simple product well what about

00:15:14,510 --> 00:15:22,820
something a bit more interesting so here

00:15:16,760 --> 00:15:26,780
we have a an ad T it is both polymorphic

00:15:22,820 --> 00:15:30,680
and it's also it's also represents a sum

00:15:26,780 --> 00:15:33,860
of 2 products so the the obviously this

00:15:30,680 --> 00:15:36,860
should remind you of option in from the

00:15:33,860 --> 00:15:38,720
standard library and and if we have a

00:15:36,860 --> 00:15:40,880
look here at what what the differences

00:15:38,720 --> 00:15:43,490
are between what we saw on the previous

00:15:40,880 --> 00:15:47,360
slide what we saw on this slide so here

00:15:43,490 --> 00:15:48,770
the mirror type is is opt now if you've

00:15:47,360 --> 00:15:50,150
not seen the way things work in dotty

00:15:48,770 --> 00:15:53,180
before this may look a bit odd because

00:15:50,150 --> 00:15:55,280
previously I had type mirror equals and

00:15:53,180 --> 00:15:58,040
then a then a fully applied type here I

00:15:55,280 --> 00:16:00,290
have tried the mirrored type equals opt

00:15:58,040 --> 00:16:02,210
opt itself as a higher kind of tight as

00:16:00,290 --> 00:16:03,890
a type of the type parameter so the key

00:16:02,210 --> 00:16:09,230
thing we have here is that this mirrored

00:16:03,890 --> 00:16:11,630
type type member is in effect a poly

00:16:09,230 --> 00:16:14,690
kind it it's strictly speaking it's not

00:16:11,630 --> 00:16:15,830
in principle it could be defined on the

00:16:14,690 --> 00:16:18,110
mirror trait we saw earlier with the

00:16:15,830 --> 00:16:20,750
bound of any kind which is the way that

00:16:18,110 --> 00:16:24,170
kind of whole mind polymorphism has been

00:16:20,750 --> 00:16:26,180
added to it turns out it's actually not

00:16:24,170 --> 00:16:29,270
necessary and in fact this is something

00:16:26,180 --> 00:16:30,470
that you can model in scarlet too and

00:16:29,270 --> 00:16:32,930
effectively what we're doing is we're

00:16:30,470 --> 00:16:35,540
just refining the mirror type with a new

00:16:32,930 --> 00:16:38,540
type member and we're allowed to specify

00:16:35,540 --> 00:16:41,930
in effect the kind of the type member as

00:16:38,540 --> 00:16:43,310
we refine and so here again as well as

00:16:41,930 --> 00:16:44,690
seeing that difference in the review

00:16:43,310 --> 00:16:46,280
previous like we can also now see a

00:16:44,690 --> 00:16:48,470
difference between mirror type of

00:16:46,280 --> 00:16:50,630
mirrored monotype so mirrored

00:16:48,470 --> 00:16:52,250
mano-a-mano a mirrored monotype is

00:16:50,630 --> 00:16:54,560
essentially the existentially quantified

00:16:52,250 --> 00:16:57,950
version of the of the mirror type so

00:16:54,560 --> 00:16:59,780
it's basically what what is the the most

00:16:57,950 --> 00:17:02,450
general type the most general fully

00:16:59,780 --> 00:17:04,880
applied type that you can get given that

00:17:02,450 --> 00:17:06,470
you have a higher kinda JH mirrored type

00:17:04,880 --> 00:17:10,760
so that's so basically we're plugging

00:17:06,470 --> 00:17:13,490
the holes and this is used if we go back

00:17:10,760 --> 00:17:17,360
a few slides you can see that the the

00:17:13,490 --> 00:17:18,950
two methods both concrete methods which

00:17:17,360 --> 00:17:25,040
defined on

00:17:18,950 --> 00:17:27,440
on values of the on the the Companions

00:17:25,040 --> 00:17:33,110
of the the sons of products are defined

00:17:27,440 --> 00:17:34,700
in terms of myriad monotype so you'll

00:17:33,110 --> 00:17:36,110
also see the main difference here as far

00:17:34,700 --> 00:17:37,850
as the remaining remaining difference

00:17:36,110 --> 00:17:40,040
here is the fact that our element types

00:17:37,850 --> 00:17:44,720
are now defined in terms of a higher

00:17:40,040 --> 00:17:48,410
kinda JH type definition so here you can

00:17:44,720 --> 00:17:51,200
see that there is a using the new double

00:17:48,410 --> 00:17:54,470
arrow to represent a year type lambda so

00:17:51,200 --> 00:17:56,000
here the the element types are now now

00:17:54,470 --> 00:17:58,160
has a type parameter and you what you

00:17:56,000 --> 00:18:01,780
should see is that the the type

00:17:58,160 --> 00:18:04,580
parameter of the algebraic data type

00:18:01,780 --> 00:18:06,020
corresponds directly so it's kind the

00:18:04,580 --> 00:18:08,150
kind of the algebraic data type of

00:18:06,020 --> 00:18:09,530
corresponds directly to the kind obvious

00:18:08,150 --> 00:18:11,240
representation type and this is this is

00:18:09,530 --> 00:18:16,280
a really crucial component of getting

00:18:11,240 --> 00:18:19,490
the the generalization to multiple kinds

00:18:16,280 --> 00:18:20,840
working nicely okay so that was that was

00:18:19,490 --> 00:18:24,290
that much that was if you like the roots

00:18:20,840 --> 00:18:29,690
the some part of the the some parts of

00:18:24,290 --> 00:18:31,520
the ADT if we go on to the the first of

00:18:29,690 --> 00:18:32,930
the product branches you see again this

00:18:31,520 --> 00:18:36,860
has the similar structure to the

00:18:32,930 --> 00:18:38,660
previous one and again we have this

00:18:36,860 --> 00:18:39,980
distinction between merit type and me

00:18:38,660 --> 00:18:43,220
ramana type because again it's put a

00:18:39,980 --> 00:18:48,200
morphic and you can again see here that

00:18:43,220 --> 00:18:49,760
the element types are is also a type

00:18:48,200 --> 00:18:51,380
lambda again of course with the same

00:18:49,760 --> 00:18:53,060
kind corresponding to the the target

00:18:51,380 --> 00:18:57,610
structure and you can also see that the

00:18:53,060 --> 00:19:04,660
monotype is it's different from the type

00:18:57,610 --> 00:19:07,750
and again and again for the for the

00:19:04,660 --> 00:19:11,600
nothing type sorry the none that type

00:19:07,750 --> 00:19:13,520
this is basically it so it is a product

00:19:11,600 --> 00:19:14,780
type it's a special case Singleton's but

00:19:13,520 --> 00:19:18,700
it's still a product type essentially

00:19:14,780 --> 00:19:18,700
and of course this is not polymorphic so

00:19:21,430 --> 00:19:29,130
so

00:19:23,720 --> 00:19:31,770
those are our mirrors for if you like

00:19:29,130 --> 00:19:33,360
the natural mirror so in other words the

00:19:31,770 --> 00:19:35,700
mirror which corresponds directly to the

00:19:33,360 --> 00:19:37,950
kind of the type that is a mirror for

00:19:35,700 --> 00:19:38,820
but you might also be wondering well you

00:19:37,950 --> 00:19:42,300
know there are lots of things that you

00:19:38,820 --> 00:19:44,430
do with high prices were free to say for

00:19:42,300 --> 00:19:47,670
example you want to define a show

00:19:44,430 --> 00:19:50,010
instance of a type class for option of

00:19:47,670 --> 00:19:51,540
end well here we've actually sort of

00:19:50,010 --> 00:19:53,190
plugged the hole in the type so you

00:19:51,540 --> 00:19:58,350
might wonder how that that's going to

00:19:53,190 --> 00:20:01,200
work well we can also ask for a mirror

00:19:58,350 --> 00:20:03,150
for our type constructor applied to a

00:20:01,200 --> 00:20:04,980
time so here we have the mirror for

00:20:03,150 --> 00:20:07,170
option of int and here you can see

00:20:04,980 --> 00:20:09,060
actually now it suddenly lost its

00:20:07,170 --> 00:20:11,250
polymorphism as far as the mirror is

00:20:09,060 --> 00:20:13,080
concerned mirrored type is option of int

00:20:11,250 --> 00:20:14,880
so it's a fully applied type type of

00:20:13,080 --> 00:20:17,190
quite star mirrored monotype is now the

00:20:14,880 --> 00:20:20,580
same again because it's also fully

00:20:17,190 --> 00:20:23,160
applied so this looks much more like the

00:20:20,580 --> 00:20:29,250
the the mirror that you've got for the

00:20:23,160 --> 00:20:32,330
ISB case class okay let's look at some

00:20:29,250 --> 00:20:32,330
of those let's see what we get

00:20:34,010 --> 00:20:43,260
so here you can see we have the in

00:20:40,170 --> 00:20:47,430
string boolean if I just quickly compile

00:20:43,260 --> 00:20:49,260
this this is gonna spit out the trees

00:20:47,430 --> 00:21:00,210
that the compiler is generating at it as

00:20:49,260 --> 00:21:03,450
it can we can we spot what's going on

00:21:00,210 --> 00:21:08,060
here so here is the here's the companion

00:21:03,450 --> 00:21:12,480
object for is B you can see that it

00:21:08,060 --> 00:21:15,240
extends mirror dot product and you can

00:21:12,480 --> 00:21:17,340
see that it defines the from product

00:21:15,240 --> 00:21:20,490
methods so from product is going to take

00:21:17,340 --> 00:21:21,600
a an arbitrary product remember what I

00:21:20,490 --> 00:21:24,270
said about this being low level this is

00:21:21,600 --> 00:21:25,500
low level and somewhat weakly typed so

00:21:24,270 --> 00:21:27,660
it's going to take it's going to take a

00:21:25,500 --> 00:21:29,930
product that essentially a tuple and

00:21:27,660 --> 00:21:32,640
it's going to give you back a value of

00:21:29,930 --> 00:21:34,980
the monotype so the minimum mirrored

00:21:32,640 --> 00:21:36,120
monotype here is is B so really it's

00:21:34,980 --> 00:21:36,450
just doing the obvious thing that you

00:21:36,120 --> 00:21:38,010
would think

00:21:36,450 --> 00:21:40,650
you would do with a product pulling out

00:21:38,010 --> 00:21:42,720
the elements casting them stuffing them

00:21:40,650 --> 00:21:43,410
in the appropriate places of an isp

00:21:42,720 --> 00:21:45,540
constructor

00:21:43,410 --> 00:21:46,950
now remember of course no human writes

00:21:45,540 --> 00:21:49,580
this code this is this is this is

00:21:46,950 --> 00:21:51,840
essentially a sort of partially a raised

00:21:49,580 --> 00:21:54,000
rendering of the code that it's

00:21:51,840 --> 00:21:55,740
generated by the compiler so if you're

00:21:54,000 --> 00:21:57,170
worried about this not being well typed

00:21:55,740 --> 00:21:59,490
enough don't

00:21:57,170 --> 00:22:03,060
okay and so that's showing some of the

00:21:59,490 --> 00:22:10,350
some aspects of it if we now have a look

00:22:03,060 --> 00:22:15,120
at what happens when you try and summon

00:22:10,350 --> 00:22:17,910
an instance of it here what we can see

00:22:15,120 --> 00:22:19,170
is there's a bunch of stuff so one of

00:22:17,910 --> 00:22:21,090
the things you're seeing here are sort

00:22:19,170 --> 00:22:25,190
of interesting kind of artifacts of the

00:22:21,090 --> 00:22:28,230
way that the in-line scarlet Dottie's

00:22:25,190 --> 00:22:30,240
inlining mechanism works the details

00:22:28,230 --> 00:22:31,140
don't need to bother us right now but

00:22:30,240 --> 00:22:36,390
anyway here you can see we're getting

00:22:31,140 --> 00:22:37,770
back a value of this mirror type here we

00:22:36,390 --> 00:22:39,060
have the mirror of monotype filled and

00:22:37,770 --> 00:22:42,450
we have the mirror type filled in we

00:22:39,060 --> 00:22:44,040
have the label type filled in we have

00:22:42,450 --> 00:22:46,590
the element types filled in we have the

00:22:44,040 --> 00:22:49,080
element labels so now you could start

00:22:46,590 --> 00:22:51,780
using this thing to do computations to

00:22:49,080 --> 00:22:54,870
realize some of these type tied members

00:22:51,780 --> 00:22:57,690
actual runtime values now the one

00:22:54,870 --> 00:23:00,170
interesting thing to see here hopefully

00:22:57,690 --> 00:23:00,170
it's visible

00:23:00,230 --> 00:23:11,070
is that in effect what we're actually

00:23:06,510 --> 00:23:12,720
getting is the companion objects this is

00:23:11,070 --> 00:23:14,960
the companion object this is a reference

00:23:12,720 --> 00:23:18,480
to the companion object of is be

00:23:14,960 --> 00:23:20,840
essentially just cast so we're basically

00:23:18,480 --> 00:23:24,600
taking the companion objects were in

00:23:20,840 --> 00:23:28,920
superimposing the the interesting the

00:23:24,600 --> 00:23:30,930
interesting generic generic programming

00:23:28,920 --> 00:23:32,850
type on top of it and yielding that as

00:23:30,930 --> 00:23:34,080
the value and that's that that's that's

00:23:32,850 --> 00:23:37,410
kind of crucial because it means we're

00:23:34,080 --> 00:23:40,140
not there is no additional runtime cost

00:23:37,410 --> 00:23:41,220
of having these things around compared

00:23:40,140 --> 00:23:43,050
to just what you would have with a

00:23:41,220 --> 00:23:44,550
vanilla face class and this is this is

00:23:43,050 --> 00:23:47,130
this is definitely from a kind of

00:23:44,550 --> 00:23:49,160
runtime footprint point of view a big

00:23:47,130 --> 00:23:53,130
win compared

00:23:49,160 --> 00:24:08,540
compared to shapeless so now we could

00:23:53,130 --> 00:24:08,540
also have a quick look polymorphic case

00:24:16,220 --> 00:24:28,920
look at that so here again you can see

00:24:20,040 --> 00:24:34,380
that we have a okay so here we have the

00:24:28,920 --> 00:24:35,460
mirrored monotype is now is now is now

00:24:34,380 --> 00:24:39,510
the the existentially quantified

00:24:35,460 --> 00:24:41,700
wildcard leader main type constructor

00:24:39,510 --> 00:24:44,310
and now you can see what we actually get

00:24:41,700 --> 00:24:45,540
for the definition of ordinal so again

00:24:44,310 --> 00:24:48,750
this is a method which is defined on the

00:24:45,540 --> 00:24:50,730
companion object of opt this is the

00:24:48,750 --> 00:24:52,320
ordinal method it takes an argument of

00:24:50,730 --> 00:24:55,560
the merit Bona type so essentially an

00:24:52,320 --> 00:24:58,050
existentially quantified option type and

00:24:55,560 --> 00:25:01,530
it does a match on it and it will give

00:24:58,050 --> 00:25:04,230
you back a an ordinal corresponding to

00:25:01,530 --> 00:25:06,930
which path which branch in the ATT

00:25:04,230 --> 00:25:12,300
you've taken and so between those two

00:25:06,930 --> 00:25:15,450
things from products from for product

00:25:12,300 --> 00:25:19,770
types in face classes and the ordinal

00:25:15,450 --> 00:25:22,800
method for for some type SEAL traits or

00:25:19,770 --> 00:25:24,360
Ananse and basically these are the

00:25:22,800 --> 00:25:25,950
primitives you need to actually do all

00:25:24,360 --> 00:25:27,870
the work actually that's not quite true

00:25:25,950 --> 00:25:29,490
we're also going to use things like some

00:25:27,870 --> 00:25:32,160
of these are the sort of rather old old

00:25:29,490 --> 00:25:35,610
fashions sort of product iterator stuff

00:25:32,160 --> 00:25:36,840
from the product right again these are

00:25:35,610 --> 00:25:38,730
low level primitives they're not

00:25:36,840 --> 00:25:40,860
intended to be used directly there will

00:25:38,730 --> 00:25:42,240
be a sensibly time to veneer placed on

00:25:40,860 --> 00:25:45,390
top of them and that that's that's what

00:25:42,240 --> 00:25:48,570
we're going to get to shortly so again

00:25:45,390 --> 00:25:53,520
I'm just going to very quickly show you

00:25:48,570 --> 00:25:55,770
what we get for I'll do it I'll show you

00:25:53,520 --> 00:25:58,940
two cases actually so I'll show you what

00:25:55,770 --> 00:26:01,820
the summoned

00:25:58,940 --> 00:26:05,809
the summoned opt looks like so here you

00:26:01,820 --> 00:26:07,609
can see opps with the various additional

00:26:05,809 --> 00:26:10,090
components filled in so we've got the

00:26:07,609 --> 00:26:12,919
label we have the the full element types

00:26:10,090 --> 00:26:15,919
of some type land and we have the labels

00:26:12,919 --> 00:26:21,859
of the individual branches now I'll also

00:26:15,919 --> 00:26:23,690
show you what we get when instead of

00:26:21,859 --> 00:26:28,460
doing that we actually try instantiating

00:26:23,690 --> 00:26:31,879
this thing so what we've done here is

00:26:28,460 --> 00:26:35,450
now asking for the thing opt

00:26:31,879 --> 00:26:37,039
instantiated it int so now we get the

00:26:35,450 --> 00:26:38,419
mirrored monotype and the merit either

00:26:37,039 --> 00:26:41,359
the same the both option int is now a

00:26:38,419 --> 00:26:42,379
monomorphic and our element types again

00:26:41,359 --> 00:26:45,049
we have now have just a simple

00:26:42,379 --> 00:27:01,099
monomorphic tuple of you know some some

00:26:45,049 --> 00:27:05,090
int or nothing okay right so the next

00:27:01,099 --> 00:27:11,059
thing is the derived clause so look at

00:27:05,090 --> 00:27:15,109
this so derives courses are annotations

00:27:11,059 --> 00:27:19,609
that come an ADT author the the author

00:27:15,109 --> 00:27:22,519
of a datatype can add to to the

00:27:19,609 --> 00:27:27,799
declaration of their sum or product type

00:27:22,519 --> 00:27:31,039
and the compiler will see that as a

00:27:27,799 --> 00:27:36,259
request to generate instances for the

00:27:31,039 --> 00:27:39,529
specified type classes directly in the

00:27:36,259 --> 00:27:44,330
companion objects off of the datatype

00:27:39,529 --> 00:27:49,580
you define it for so here we have now

00:27:44,330 --> 00:27:52,669
familiar is b type we have we have were

00:27:49,580 --> 00:27:55,070
referring to the the the the show type

00:27:52,669 --> 00:27:58,840
class that we had was the beginning this

00:27:55,070 --> 00:28:03,830
is the companion of the show the show

00:27:58,840 --> 00:28:06,109
type class and we define assuming the

00:28:03,830 --> 00:28:09,499
title of the Munsell that wants to opt

00:28:06,109 --> 00:28:11,599
into the mechanism we define a derived

00:28:09,499 --> 00:28:12,390
method the derived method is polymorphic

00:28:11,599 --> 00:28:16,350
in in

00:28:12,390 --> 00:28:19,799
in some type t it's handed a mirror of t

00:28:16,350 --> 00:28:23,700
and it promises to give you back a show

00:28:19,799 --> 00:28:27,179
of t leave this blank for the second and

00:28:23,700 --> 00:28:30,210
so what what does the compiler do well

00:28:27,179 --> 00:28:34,710
the compiler in the companion object is

00:28:30,210 --> 00:28:37,980
going to as well as having is be

00:28:34,710 --> 00:28:42,500
extending product at the product mirror

00:28:37,980 --> 00:28:45,630
it will also provide a definition of

00:28:42,500 --> 00:28:47,660
basically the the instance we would be

00:28:45,630 --> 00:28:49,740
asking for so in this case show of is B

00:28:47,660 --> 00:28:53,370
whoops I left the type parameter off

00:28:49,740 --> 00:28:57,690
first that's a mistake it does that

00:28:53,370 --> 00:28:59,669
simply by calling while compiling a

00:28:57,690 --> 00:29:01,380
right-hand side which is a call directly

00:28:59,669 --> 00:29:02,700
not it's not implicit there's no

00:29:01,380 --> 00:29:03,780
implicit search direct and no there's no

00:29:02,700 --> 00:29:06,780
implicit search involved in here it

00:29:03,780 --> 00:29:10,549
directly calls the derived method on the

00:29:06,780 --> 00:29:13,110
companion of the type class trait

00:29:10,549 --> 00:29:15,510
providing itself because he itself is

00:29:13,110 --> 00:29:17,660
actually a mirror as the argument and

00:29:15,510 --> 00:29:20,309
and it relies on the type class

00:29:17,660 --> 00:29:22,650
companion method delivering back a

00:29:20,309 --> 00:29:24,600
suitable suitable value to put here and

00:29:22,650 --> 00:29:26,280
people who actually want to look at this

00:29:24,600 --> 00:29:28,380
stuff I may show you just in a second

00:29:26,280 --> 00:29:30,419
will notice that there currently this is

00:29:28,380 --> 00:29:31,559
defined as a death rather than a vowel

00:29:30,419 --> 00:29:34,490
that's oh that's a bug in the

00:29:31,559 --> 00:29:34,490
implementation right now

00:29:51,790 --> 00:29:56,140
so let's see how that looks

00:30:10,710 --> 00:30:22,600
so here you can see basically what we've

00:30:14,860 --> 00:30:24,669
got so here is our show here is the show

00:30:22,600 --> 00:30:28,240
members as I mentioned this is this is

00:30:24,669 --> 00:30:31,240
this is a deaf it should be a vowel it's

00:30:28,240 --> 00:30:36,270
a show is B it has been produced by

00:30:31,240 --> 00:30:39,279
calling the derived method on the show

00:30:36,270 --> 00:30:40,510
but it's not very enlightening because I

00:30:39,279 --> 00:30:41,950
think it's implemented as triple

00:30:40,510 --> 00:30:47,520
question right yes yes it is

00:30:41,950 --> 00:30:52,840
stop there lost it just there for

00:30:47,520 --> 00:30:58,419
reasons we will come back to you so it's

00:30:52,840 --> 00:31:01,600
a call on show derived handing handing

00:30:58,419 --> 00:31:04,360
itself as an argument and we're assuming

00:31:01,600 --> 00:31:06,610
so magic happens and we'll get the right

00:31:04,360 --> 00:31:08,080
kind of value so before I move on and

00:31:06,610 --> 00:31:09,809
show you what what that magic might be I

00:31:08,080 --> 00:31:20,350
just want to show you one other thing

00:31:09,809 --> 00:31:24,309
actually no so now if we if we say so so

00:31:20,350 --> 00:31:25,990
this is this is some use in the code so

00:31:24,309 --> 00:31:28,570
this is some call site where we've

00:31:25,990 --> 00:31:30,880
requested the show instance for is B

00:31:28,570 --> 00:31:32,919
what you see here is this this is the

00:31:30,880 --> 00:31:34,179
result again of inlining that a lot of

00:31:32,919 --> 00:31:35,559
these things as things are in line the

00:31:34,179 --> 00:31:38,679
artifacts you can expect these things to

00:31:35,559 --> 00:31:41,799
disappear but basically you have what is

00:31:38,679 --> 00:31:45,880
in effect a direct reference to that

00:31:41,799 --> 00:31:47,919
member of the is B so in terms of in

00:31:45,880 --> 00:31:49,510
terms of cashing these instances not

00:31:47,919 --> 00:31:52,360
producing them repeatedly not

00:31:49,510 --> 00:31:53,799
duplicating them this is this is really

00:31:52,360 --> 00:31:54,909
really very nice this is this is

00:31:53,799 --> 00:31:57,010
completely subsuming all the

00:31:54,909 --> 00:32:01,870
functionality that we had with things

00:31:57,010 --> 00:32:03,730
like cached implicit in Chaves okay so

00:32:01,870 --> 00:32:06,220
you might ask yourself as I kind of

00:32:03,730 --> 00:32:11,789
alluded to earlier what happens in the

00:32:06,220 --> 00:32:11,789
case of a polymorphic type

00:32:12,440 --> 00:32:17,290
quick look at that so it's the same show

00:32:19,240 --> 00:32:37,550
does this do for us well what do we get

00:32:34,910 --> 00:32:38,990
we got a derived show but now this is

00:32:37,550 --> 00:32:42,290
interesting any kind of you think about

00:32:38,990 --> 00:32:44,780
it has to be the case because option

00:32:42,290 --> 00:32:46,850
which is what we were deriving for it's

00:32:44,780 --> 00:32:49,360
a polymorphic type so it has a hole in

00:32:46,850 --> 00:32:53,000
it and so we can't produce a single

00:32:49,360 --> 00:32:56,450
value corresponding to show for option

00:32:53,000 --> 00:32:58,250
because we need somehow other fill the

00:32:56,450 --> 00:32:59,510
hole for the T which is a polymorphic in

00:32:58,250 --> 00:33:01,850
show so what we actually get in this

00:32:59,510 --> 00:33:04,730
case is this is correctly a death this

00:33:01,850 --> 00:33:07,490
time we have a derived show which is now

00:33:04,730 --> 00:33:09,350
polymorphic in T and it will take an

00:33:07,490 --> 00:33:12,680
implicit argument which is the show for

00:33:09,350 --> 00:33:15,440
the member the member sorry the the the

00:33:12,680 --> 00:33:17,300
parameterised element of type T and then

00:33:15,440 --> 00:33:23,170
it will give us back an option of T and

00:33:17,300 --> 00:33:26,320
again this is done in terms of a call on

00:33:23,170 --> 00:33:26,320
where is it

00:33:29,229 --> 00:33:34,029
Oh here right okay

00:33:31,899 --> 00:33:34,989
right so in fact what's what's happened

00:33:34,029 --> 00:33:37,629
here is there's actually completely

00:33:34,989 --> 00:33:42,419
inlined the the implementation of the

00:33:37,629 --> 00:33:42,419
show method so drop a question mark here

00:33:57,419 --> 00:34:06,549
and now what you can see is that yes so

00:34:04,539 --> 00:34:10,029
this is again this is now the definition

00:34:06,549 --> 00:34:11,500
of derive show again but here you can

00:34:10,029 --> 00:34:13,149
see now that it's not in the lines away

00:34:11,500 --> 00:34:16,149
to nothing you can see that we've got a

00:34:13,149 --> 00:34:24,669
direct call on the drive method again

00:34:16,149 --> 00:34:26,169
taking the taking the the mirror but now

00:34:24,669 --> 00:34:31,210
it is parametrized in terms of

00:34:26,169 --> 00:34:35,289
parameters in terms of T we can kind of

00:34:31,210 --> 00:34:48,819
see that in action if we look at what a

00:34:35,289 --> 00:34:54,299
you site might be so now you can see the

00:34:48,819 --> 00:34:57,430
u site here so what we've got now is

00:34:54,299 --> 00:35:00,309
effectively a direct call on the the

00:34:57,430 --> 00:35:02,109
method in opt this is the odds companion

00:35:00,309 --> 00:35:06,700
we're calling derived show and it's

00:35:02,109 --> 00:35:08,170
filled in the instance argument for show

00:35:06,700 --> 00:35:11,079
which is the time Rama to fit into here

00:35:08,170 --> 00:35:13,869
so and we're not we're not obviously we

00:35:11,079 --> 00:35:15,369
get a new value each time but but but

00:35:13,869 --> 00:35:17,160
clearly any any infrastructure any

00:35:15,369 --> 00:35:19,900
boilerplate code which is had to be

00:35:17,160 --> 00:35:22,690
generated to so as it were fill out the

00:35:19,900 --> 00:35:24,579
surrounding structure around this int

00:35:22,690 --> 00:35:26,950
instance that's only ever been done once

00:35:24,579 --> 00:35:29,710
so that's been done once computed once

00:35:26,950 --> 00:35:33,430
and now all we're doing is summoning a

00:35:29,710 --> 00:35:35,890
value by applying a function to an

00:35:33,430 --> 00:35:38,500
instance for the parametrized type which

00:35:35,890 --> 00:35:41,200
is optimal I mean I don't think you're

00:35:38,500 --> 00:35:57,430
gonna do

00:35:41,200 --> 00:35:59,200
okay so right so I showed you some

00:35:57,430 --> 00:36:03,010
general question marks and and and up

00:35:59,200 --> 00:36:06,190
here I put you know dot dot dot and well

00:36:03,010 --> 00:36:08,740
what is that dot dot dot and Martin

00:36:06,190 --> 00:36:10,660
showed you one possible way to fill out

00:36:08,740 --> 00:36:12,160
that by defining things in terms

00:36:10,660 --> 00:36:15,010
directly in terms of in line methods

00:36:12,160 --> 00:36:16,990
competing directly other mirrors and I

00:36:15,010 --> 00:36:19,420
personally think that's that's that's

00:36:16,990 --> 00:36:22,059
too much to ask people to do and I think

00:36:19,420 --> 00:36:24,250
it's a good demonstration of of you know

00:36:22,059 --> 00:36:29,920
the power and flexibility that the this

00:36:24,250 --> 00:36:35,290
mechanism provides and the Dottie's sort

00:36:29,920 --> 00:36:37,900
of more disciplined meta programming

00:36:35,290 --> 00:36:42,940
facilities allow you to do but I I don't

00:36:37,900 --> 00:36:46,359
think it's economics is particularly

00:36:42,940 --> 00:36:49,359
good so in conjunction with doing doing

00:36:46,359 --> 00:36:51,640
work on designing the the Marian derives

00:36:49,359 --> 00:36:55,680
mechanisms I've also simultaneously as I

00:36:51,640 --> 00:36:57,930
mentioned been designing the next major

00:36:55,680 --> 00:37:00,670
essentially rewrite of shape is three

00:36:57,930 --> 00:37:04,349
shape the stroke of three and this is

00:37:00,670 --> 00:37:10,920
kind of what what we're looking at and

00:37:04,349 --> 00:37:13,990
so shape us three has a generic type

00:37:10,920 --> 00:37:16,440
which corresponds to the generic type

00:37:13,990 --> 00:37:19,569
that exists in Chapter two

00:37:16,440 --> 00:37:23,770
however it is completely poly kinda JH

00:37:19,569 --> 00:37:26,020
so shapeless to has sort of a very

00:37:23,770 --> 00:37:29,230
half-hearted and sort of slightly

00:37:26,020 --> 00:37:31,630
confused the tense handling two kinds it

00:37:29,230 --> 00:37:33,700
handles kind star so fully applied types

00:37:31,630 --> 00:37:36,670
in start iris star so types with a

00:37:33,700 --> 00:37:38,260
single type argument and and it's it's

00:37:36,670 --> 00:37:39,160
it's it's really quite row P the way it

00:37:38,260 --> 00:37:40,329
works there's huge amounts of

00:37:39,160 --> 00:37:42,280
duplication and lots of really

00:37:40,329 --> 00:37:45,670
horrendous gnarly macros it's not very

00:37:42,280 --> 00:37:47,559
nice and getting rid of all of that that

00:37:45,670 --> 00:37:49,960
nests been one of my major goals with

00:37:47,559 --> 00:37:52,900
with this redesign the new design is

00:37:49,960 --> 00:37:57,040
it's completely poly kinda j--

00:37:52,900 --> 00:38:03,100
and all of the duplication that I had to

00:37:57,040 --> 00:38:04,510
endure in in is gone it's implemented

00:38:03,100 --> 00:38:06,580
directly in terms of mirror so it

00:38:04,510 --> 00:38:10,510
actually turns out now that generic is

00:38:06,580 --> 00:38:13,990
is actually essentially a a type alias

00:38:10,510 --> 00:38:15,730
for a refinement of the mirror type so

00:38:13,990 --> 00:38:19,690
it really is directly defined in terms

00:38:15,730 --> 00:38:23,830
of mirrors now this gives you a facility

00:38:19,690 --> 00:38:26,440
which is essentially equivalent to a

00:38:23,830 --> 00:38:28,840
poly kinda generalization of this as it

00:38:26,440 --> 00:38:30,970
is now to work with it you would need to

00:38:28,840 --> 00:38:33,850
work with similar kinds of techniques

00:38:30,970 --> 00:38:35,260
that you work with shapers to so this is

00:38:33,850 --> 00:38:36,850
this has pros and cons on the one hand

00:38:35,260 --> 00:38:38,440
it is very very general you do basically

00:38:36,850 --> 00:38:42,070
anything with it on the other hand you

00:38:38,440 --> 00:38:43,810
end up with lots and lots of foals this

00:38:42,070 --> 00:38:49,240
is you you have to work with an explicit

00:38:43,810 --> 00:38:50,830
representation type and and and it can

00:38:49,240 --> 00:38:52,150
be quite complicated to work with there

00:38:50,830 --> 00:38:54,370
are some there are some sort of

00:38:52,150 --> 00:38:56,590
mitigations in in in in in dot e in as

00:38:54,370 --> 00:38:58,240
much as some of those some of those

00:38:56,590 --> 00:39:00,340
folds can be well in for all of those

00:38:58,240 --> 00:39:02,470
folds they no longer have to be

00:39:00,340 --> 00:39:04,390
implemented in terms of sort of the

00:39:02,470 --> 00:39:05,850
logic programming style implicit sui can

00:39:04,390 --> 00:39:07,660
work directly with inline functions

00:39:05,850 --> 00:39:09,280
specialising in line functions which

00:39:07,660 --> 00:39:11,770
means that many of those kinds of

00:39:09,280 --> 00:39:16,210
recursions can be captured in code which

00:39:11,770 --> 00:39:18,160
looks like normal functional code but

00:39:16,210 --> 00:39:22,150
even so i think i think i think that is

00:39:18,160 --> 00:39:23,740
still not something that people

00:39:22,150 --> 00:39:25,240
typically want to do is if there are

00:39:23,740 --> 00:39:27,400
simpler alternative so one of the things

00:39:25,240 --> 00:39:30,520
it also has the downside that it

00:39:27,400 --> 00:39:32,920
involves a certain amount of well

00:39:30,520 --> 00:39:34,060
involves a significant amount of

00:39:32,920 --> 00:39:36,010
inlining which means that you have

00:39:34,060 --> 00:39:38,080
cogeneration which means let's say your

00:39:36,010 --> 00:39:39,940
instances in your companion objects are

00:39:38,080 --> 00:39:44,200
large so we want something which is much

00:39:39,940 --> 00:39:47,140
much more compact so I I kind of I kind

00:39:44,200 --> 00:39:50,260
of looked at seeing if I could come up

00:39:47,140 --> 00:39:53,590
with a scheme which would basically do

00:39:50,260 --> 00:39:56,320
the optimal thing for type classes which

00:39:53,590 --> 00:39:58,690
fit into a particular kind of regular or

00:39:56,320 --> 00:40:01,180
annoyed all kind of pattern so type

00:39:58,690 --> 00:40:04,240
classes where basically if I've got a

00:40:01,180 --> 00:40:05,280
type which has components a B and C it

00:40:04,240 --> 00:40:08,280
can be defined

00:40:05,280 --> 00:40:10,290
in terms of instances type loss

00:40:08,280 --> 00:40:15,440
incidents can be defined in terms of

00:40:10,290 --> 00:40:15,440
instances for those component types and

00:40:16,010 --> 00:40:22,050
this can be done in a much much much

00:40:18,300 --> 00:40:25,110
simpler way for that subset of types

00:40:22,050 --> 00:40:30,060
there's a number of substandard folds

00:40:25,110 --> 00:40:34,290
and fold like operations that's I think

00:40:30,060 --> 00:40:36,150
adequate for most purposes and capture

00:40:34,290 --> 00:40:40,620
capture a very very large proportion of

00:40:36,150 --> 00:40:43,620
the territory and it's implemented in

00:40:40,620 --> 00:40:45,660
terms of generic it's consequently poly

00:40:43,620 --> 00:40:51,510
kind in exactly the same way but the

00:40:45,660 --> 00:40:53,670
generic generic is due to its extension

00:40:51,510 --> 00:40:58,800
Lumira if you were to squint at the kind

00:40:53,670 --> 00:40:59,940
star case of instances you would you

00:40:58,800 --> 00:41:02,730
would see something that might remind

00:40:59,940 --> 00:41:04,860
you a bit of Magnolia and it was an it

00:41:02,730 --> 00:41:09,480
was a I think an accidental discovery

00:41:04,860 --> 00:41:11,010
and but it turns out that something a

00:41:09,480 --> 00:41:13,650
little bit like Magnolia actually works

00:41:11,010 --> 00:41:15,890
in the current star case so you could

00:41:13,650 --> 00:41:18,960
think of this as being a poly kind of

00:41:15,890 --> 00:41:22,080
generalization of that and okay so what

00:41:18,960 --> 00:41:25,350
do you get so this is generic this

00:41:22,080 --> 00:41:27,300
should look very very similar to people

00:41:25,350 --> 00:41:30,990
who have worked with generic and

00:41:27,300 --> 00:41:34,170
shapeless we have a product generic it

00:41:30,990 --> 00:41:35,670
works in terms of mapping from our base

00:41:34,170 --> 00:41:40,050
type to a representation type and back

00:41:35,670 --> 00:41:42,450
again it works both for products it also

00:41:40,050 --> 00:41:46,020
works for Coke products the difference

00:41:42,450 --> 00:41:47,100
here is that our representation types

00:41:46,020 --> 00:41:47,730
are actually now going to be straight

00:41:47,100 --> 00:41:50,700
tuples

00:41:47,730 --> 00:41:53,610
there's no age lists anymore here in the

00:41:50,700 --> 00:41:55,140
case of if you remember that for the

00:41:53,610 --> 00:41:58,620
some types and they were also

00:41:55,140 --> 00:42:01,380
represented as tuples of tuples of types

00:41:58,620 --> 00:42:03,150
rather than sort of nested ideas which

00:42:01,380 --> 00:42:05,190
is what the shape Cisco product type is

00:42:03,150 --> 00:42:10,530
that's now gone what happens is we can

00:42:05,190 --> 00:42:12,270
use a dotty match type to take a tuple

00:42:10,530 --> 00:42:14,100
of types and turn it into a union of

00:42:12,270 --> 00:42:16,980
types which is actually something in the

00:42:14,100 --> 00:42:18,120
works really very nicely in this context

00:42:16,980 --> 00:42:18,840
because then we end up with the

00:42:18,120 --> 00:42:22,080
from--and

00:42:18,840 --> 00:42:23,670
representation methods of generic for

00:42:22,080 --> 00:42:25,260
copilot or basically identity functions

00:42:23,670 --> 00:42:28,770
which is which is which is really quite

00:42:25,260 --> 00:42:34,770
neat so this is kind star so this

00:42:28,770 --> 00:42:37,860
corresponds to types like a sv type for

00:42:34,770 --> 00:42:39,870
kind star arrow star it's basically the

00:42:37,860 --> 00:42:41,640
same but you can see obviously now that

00:42:39,870 --> 00:42:43,560
we have we have additional type

00:42:41,640 --> 00:42:45,000
parameters threaded through this was the

00:42:43,560 --> 00:42:47,390
thing that was called basically causing

00:42:45,000 --> 00:42:49,950
me to as you'll see from the next slide

00:42:47,390 --> 00:42:51,630
when we get to kind star arrow star

00:42:49,950 --> 00:42:56,790
things got started getting painful then

00:42:51,630 --> 00:42:59,970
we now have the table flip kind and so

00:42:56,790 --> 00:43:03,270
the the the kit of parts that ships with

00:42:59,970 --> 00:43:07,410
shapeless three is you get support for

00:43:03,270 --> 00:43:10,080
kite star star a star star arrow start

00:43:07,410 --> 00:43:13,020
arrow star arrow star and star arrow

00:43:10,080 --> 00:43:15,270
star a star so we can basically do these

00:43:13,020 --> 00:43:15,750
out of box with a certain amount of

00:43:15,270 --> 00:43:18,510
boilerplate

00:43:15,750 --> 00:43:22,320
but it's very simple it's comparatively

00:43:18,510 --> 00:43:26,040
simple mechanical boilerplate and as

00:43:22,320 --> 00:43:28,560
I've said here you know if you need a

00:43:26,040 --> 00:43:30,750
kind which doesn't ship by default with

00:43:28,560 --> 00:43:35,010
with shape is fairly straightforward to

00:43:30,750 --> 00:43:37,200
add it anywhere in any library anyway

00:43:35,010 --> 00:43:41,070
I'm in terms of what do you get with

00:43:37,200 --> 00:43:44,700
generic as I said the refinements of the

00:43:41,070 --> 00:43:47,490
mirror types the two rapper and from

00:43:44,700 --> 00:43:48,930
rapper stuff that are per kind extension

00:43:47,490 --> 00:43:52,170
methods so this is using the boss's new

00:43:48,930 --> 00:43:53,430
extension method mechanism and the

00:43:52,170 --> 00:43:55,350
reason they have to be done that way is

00:43:53,430 --> 00:43:56,880
because there's simply no mechanism

00:43:55,350 --> 00:43:59,460
available to abstract over those

00:43:56,880 --> 00:44:01,200
differences in method type signatures

00:43:59,460 --> 00:44:03,900
including the you know the different

00:44:01,200 --> 00:44:06,930
number and kind of type parameters on

00:44:03,900 --> 00:44:08,520
the from and to methods beyond maybe

00:44:06,930 --> 00:44:11,100
maybe in a future version of da see you

00:44:08,520 --> 00:44:13,110
may be in 3.1 we might go for a more a

00:44:11,100 --> 00:44:14,400
more full-blooded version of kind

00:44:13,110 --> 00:44:16,080
polymorphism which would allow us to

00:44:14,400 --> 00:44:19,320
abstract over those signatures but I

00:44:16,080 --> 00:44:23,820
think I think I think it's that's that's

00:44:19,320 --> 00:44:25,050
the step too far for 3.0 and I think I

00:44:23,820 --> 00:44:26,280
think we can wait for that this is this

00:44:25,050 --> 00:44:27,570
is good enough for now I think it will

00:44:26,280 --> 00:44:28,119
give us a good sense of what's actually

00:44:27,570 --> 00:44:34,329
need

00:44:28,119 --> 00:44:36,089
and as I said yes and so even even

00:44:34,329 --> 00:44:38,799
though even though these methods are

00:44:36,089 --> 00:44:39,999
obviously distinct and the signatures

00:44:38,799 --> 00:44:41,529
can't be in fight it actually turns out

00:44:39,999 --> 00:44:43,539
everything it raises the same thing

00:44:41,529 --> 00:44:46,299
because ultimately we're turning a value

00:44:43,539 --> 00:44:47,920
into a value and the signatures they all

00:44:46,299 --> 00:44:49,569
go away they all compile away so we can

00:44:47,920 --> 00:44:50,890
actually implement the whole thing in

00:44:49,569 --> 00:44:52,479
terms of a support of what I've been

00:44:50,890 --> 00:44:54,699
calling a raised kernel so it's

00:44:52,479 --> 00:44:59,219
basically a kernel of shapeless where

00:44:54,699 --> 00:45:01,359
everything is traveling akka any-to-any

00:44:59,219 --> 00:45:02,769
but you never get to see that because

00:45:01,359 --> 00:45:05,499
you only get to interact your own you

00:45:02,769 --> 00:45:13,769
get to interact it interact with it via

00:45:05,499 --> 00:45:16,689
a per kind fully tight okay so instances

00:45:13,769 --> 00:45:19,509
this is the the sort of a more slightly

00:45:16,689 --> 00:45:22,779
Magnolia flavored thing captures common

00:45:19,509 --> 00:45:25,809
folds it will pretty much completely

00:45:22,779 --> 00:45:27,339
eliminate implicit induction boilerplate

00:45:25,809 --> 00:45:29,499
for for things with regular monoidal

00:45:27,339 --> 00:45:30,849
type classes it's implemented as I said

00:45:29,499 --> 00:45:32,739
in terms of generics so it has the same

00:45:30,849 --> 00:45:35,439
kind of poly mode poly kind of structure

00:45:32,739 --> 00:45:37,239
and it's also implemented in terms of an

00:45:35,439 --> 00:45:39,579
arrays kernel which means you have no

00:45:37,239 --> 00:45:41,619
code duplication which is great so I eat

00:45:39,579 --> 00:45:44,349
means we keep our footprint our bytecode

00:45:41,619 --> 00:45:47,380
footprint absolutely minimal and so

00:45:44,349 --> 00:45:50,559
consequently it has excellent compile

00:45:47,380 --> 00:45:52,299
time performance and and bytecode

00:45:50,559 --> 00:45:54,910
footprint is small that's very very good

00:45:52,299 --> 00:45:56,109
means we are a load time if you if

00:45:54,910 --> 00:45:59,829
you're generating something a very very

00:45:56,109 --> 00:46:01,509
large ADT you know you could you could

00:45:59,829 --> 00:46:04,569
pay a significant cost just in terms of

00:46:01,509 --> 00:46:08,189
like code verification time loading a

00:46:04,569 --> 00:46:14,559
very very large massively inlined

00:46:08,189 --> 00:46:16,119
generated derived instance as I said so

00:46:14,559 --> 00:46:17,559
there is the risk there is some work

00:46:16,119 --> 00:46:23,319
being done so the the some work being

00:46:17,559 --> 00:46:27,549
done by Nicola and I gloss olivier as

00:46:23,319 --> 00:46:30,189
well on doing a version of this in terms

00:46:27,549 --> 00:46:32,650
of staging and one of the things we're

00:46:30,189 --> 00:46:33,999
going to do at some point is try to sort

00:46:32,650 --> 00:46:36,420
of evaluate what the pros and cons of

00:46:33,999 --> 00:46:38,730
more aggressive inlining versus this

00:46:36,420 --> 00:46:41,850
or in terms of in terms of in terms of

00:46:38,730 --> 00:46:47,490
runtime performance and okay I think I'm

00:46:41,850 --> 00:46:50,070
beginning to run out of time I always do

00:46:47,490 --> 00:46:56,580
and so these are the kinds of folds you

00:46:50,070 --> 00:46:57,930
get for products these are the kinds of

00:46:56,580 --> 00:46:59,970
folds you get so products don't worry I

00:46:57,930 --> 00:47:01,110
will explain a little bit when we get to

00:46:59,970 --> 00:47:04,680
some signature so I'm only showing you

00:47:01,110 --> 00:47:08,450
the stuff for Coinstar but basically

00:47:04,680 --> 00:47:12,390
both products and co products you can

00:47:08,450 --> 00:47:15,740
define a mechanism for compute if you

00:47:12,390 --> 00:47:20,400
can define a mechanism for computing a a

00:47:15,740 --> 00:47:23,220
value of your T from PI plus instances

00:47:20,400 --> 00:47:24,750
here of the components of T so that

00:47:23,220 --> 00:47:26,340
could be the elements of a case class or

00:47:24,750 --> 00:47:28,560
it could be the branches of a some type

00:47:26,340 --> 00:47:31,140
and a value of one of those elements

00:47:28,560 --> 00:47:34,050
then you can produce a value of the

00:47:31,140 --> 00:47:35,160
whole type so you're possibly an

00:47:34,050 --> 00:47:36,810
interesting thing you'll notice here is

00:47:35,160 --> 00:47:39,870
the use of a polymorphic function type

00:47:36,810 --> 00:47:41,790
which is another another new addition in

00:47:39,870 --> 00:47:44,460
dot e which makes a lot of this stuff

00:47:41,790 --> 00:47:46,530
enormous ly easier this produces really

00:47:44,460 --> 00:47:48,810
very very simple type signatures as

00:47:46,530 --> 00:47:52,410
we'll see in an example in a second and

00:47:48,810 --> 00:47:55,410
for products specifically you can

00:47:52,410 --> 00:47:56,670
construct a value if you construct if

00:47:55,410 --> 00:47:58,140
you can construct values of all the

00:47:56,670 --> 00:48:00,570
components and that's what's essentially

00:47:58,140 --> 00:48:02,370
happening here you can unfold value so

00:48:00,570 --> 00:48:05,940
if you've got some sort of seed you can

00:48:02,370 --> 00:48:08,340
unfold it if you can construct a value

00:48:05,940 --> 00:48:12,540
which sort of consumes bits of the seed

00:48:08,340 --> 00:48:15,330
and say an instance for for some of the

00:48:12,540 --> 00:48:17,700
components of the product type and you

00:48:15,330 --> 00:48:20,220
can then at that point get that possibly

00:48:17,700 --> 00:48:23,160
get back an instance of of the type and

00:48:20,220 --> 00:48:24,690
maybe some some some partially consumed

00:48:23,160 --> 00:48:26,370
seed this is this is this is something

00:48:24,690 --> 00:48:28,110
which is useful for doing D

00:48:26,370 --> 00:48:30,060
serialization and we're constructing a

00:48:28,110 --> 00:48:33,240
value of a product of nibbling away at

00:48:30,060 --> 00:48:36,210
bits of bits of say some input and

00:48:33,240 --> 00:48:38,430
producing a producing a value possibly

00:48:36,210 --> 00:48:43,410
an optional value and maybe some

00:48:38,430 --> 00:48:44,670
additional continuation of input map to

00:48:43,410 --> 00:48:46,350
that's the kind of thing you want to do

00:48:44,670 --> 00:48:48,270
if you're say trying to combine a pair

00:48:46,350 --> 00:48:49,090
of a compare of products like you would

00:48:48,270 --> 00:48:54,220
in a

00:48:49,090 --> 00:48:56,260
in a in a monoid fault left allows you

00:48:54,220 --> 00:48:58,690
to sort of compute a single value from a

00:48:56,260 --> 00:49:00,820
single product fault left to allows you

00:48:58,690 --> 00:49:01,960
to compute a single value from a pair of

00:49:00,820 --> 00:49:04,180
products and this is the kind of thing

00:49:01,960 --> 00:49:07,330
you might do if your computing say say

00:49:04,180 --> 00:49:08,770
an EQ any type class instance you'll

00:49:07,330 --> 00:49:10,510
notice that both of these things allow

00:49:08,770 --> 00:49:12,520
have this thing called complete or I

00:49:10,510 --> 00:49:14,620
don't know if that's necessarily going

00:49:12,520 --> 00:49:16,300
to be a permanent fixture if that goes

00:49:14,620 --> 00:49:17,650
somewhere else but this is essentially

00:49:16,300 --> 00:49:21,070
something which allows you to compute

00:49:17,650 --> 00:49:23,020
curved to a computer value and either

00:49:21,070 --> 00:49:24,520
continue or just say we're done so this

00:49:23,020 --> 00:49:26,140
is allows you to do sort of short short

00:49:24,520 --> 00:49:27,910
circuit evaluations if you're computing

00:49:26,140 --> 00:49:29,250
Inc you can stop the same as you see the

00:49:27,910 --> 00:49:31,750
first difference

00:49:29,250 --> 00:49:36,310
the co-products things are slightly

00:49:31,750 --> 00:49:38,620
different here although they coincide on

00:49:36,310 --> 00:49:41,380
map both products and co products can

00:49:38,620 --> 00:49:42,310
both support this map thing you can

00:49:41,380 --> 00:49:44,470
project out you've we've got this

00:49:42,310 --> 00:49:47,860
branching branching structure you can

00:49:44,470 --> 00:49:51,790
choose one way to go and some kind of

00:49:47,860 --> 00:49:53,020
seed value and then you can provide the

00:49:51,790 --> 00:49:54,910
thing with a function which will take

00:49:53,020 --> 00:49:57,700
the seed value an instance for that

00:49:54,910 --> 00:49:59,290
branch and then compute a value so again

00:49:57,700 --> 00:50:01,930
this would be something you might might

00:49:59,290 --> 00:50:04,660
might might work with doing a DC

00:50:01,930 --> 00:50:05,920
realization framework and then fold is

00:50:04,660 --> 00:50:08,110
something which is essentially going to

00:50:05,920 --> 00:50:11,080
collapse the branches pick the branch

00:50:08,110 --> 00:50:14,050
which is actually realized and give you

00:50:11,080 --> 00:50:15,790
the realized value the corresponding

00:50:14,050 --> 00:50:17,500
type class instance for the branch and

00:50:15,790 --> 00:50:19,660
allow you to compute a result and fold

00:50:17,500 --> 00:50:20,440
to essentially says if you have two

00:50:19,660 --> 00:50:22,780
co-products

00:50:20,440 --> 00:50:24,910
they both align on which branch they're

00:50:22,780 --> 00:50:26,710
on then you can compute a value from

00:50:24,910 --> 00:50:29,110
them and that's that again you would use

00:50:26,710 --> 00:50:32,730
that in the context of a geek so that's

00:50:29,110 --> 00:50:37,420
that's that's essentially the shape of

00:50:32,730 --> 00:50:38,710
the instance types for kite star I'm not

00:50:37,420 --> 00:50:39,730
going to show you the generalizations of

00:50:38,710 --> 00:50:40,840
those because obviously can imagine

00:50:39,730 --> 00:50:42,100
every single one of these things is

00:50:40,840 --> 00:50:43,690
going to have additional type parameters

00:50:42,100 --> 00:50:45,100
threaded through them its ends up

00:50:43,690 --> 00:50:47,320
looking very very ugly so I'm not going

00:50:45,100 --> 00:50:53,900
to bother to show you that just quickly

00:50:47,320 --> 00:50:57,530
show you an example of a type class

00:50:53,900 --> 00:50:57,530
defined that way

00:51:00,260 --> 00:51:05,240
so most of this this is most of this is

00:51:02,700 --> 00:51:07,260
just the standard the standard

00:51:05,240 --> 00:51:10,140
boilerplate you would expect to have

00:51:07,260 --> 00:51:12,390
anyway so we've got that's the tie clasp

00:51:10,140 --> 00:51:15,540
we have instances for a bunch of

00:51:12,390 --> 00:51:17,850
primitive types here is the hook that

00:51:15,540 --> 00:51:20,340
derives clause the dot e derives clause

00:51:17,850 --> 00:51:21,840
is going to call back to now you if you

00:51:20,340 --> 00:51:23,220
remember on the slide I showed it being

00:51:21,840 --> 00:51:25,530
parameters in terms of mirror

00:51:23,220 --> 00:51:27,000
well product generic actually just is a

00:51:25,530 --> 00:51:28,140
mirror it's just a refinement of mirror

00:51:27,000 --> 00:51:32,220
so this is a perfectly acceptable

00:51:28,140 --> 00:51:33,900
signature for derived any other type

00:51:32,220 --> 00:51:35,990
reservation framework that wanted to do

00:51:33,900 --> 00:51:39,000
the same thing as long as they also

00:51:35,990 --> 00:51:40,350
refine the mirror they can also fit into

00:51:39,000 --> 00:51:43,170
the framework in exactly the same way

00:51:40,350 --> 00:51:46,020
this is very nice all it does is it

00:51:43,170 --> 00:51:48,300
basically says you've been handed a

00:51:46,020 --> 00:51:52,430
generic I can turn that generic into one

00:51:48,300 --> 00:51:57,210
of those instances types and then pass

00:51:52,430 --> 00:51:58,680
and then call a instance here non inline

00:51:57,210 --> 00:52:02,910
now so this is this is just vanilla

00:51:58,680 --> 00:52:06,420
ordinary code and I can now define the

00:52:02,910 --> 00:52:10,250
mono eight instance generically using

00:52:06,420 --> 00:52:12,510
the the folds the maps defined on

00:52:10,250 --> 00:52:14,490
defined on the the instances type that

00:52:12,510 --> 00:52:16,400
we saw earlier so I can construct a

00:52:14,490 --> 00:52:18,840
value of type T if I can construct

00:52:16,400 --> 00:52:27,330
values from all nodes for the elements

00:52:18,840 --> 00:52:30,330
of T and similarly I can combine two A's

00:52:27,330 --> 00:52:31,590
if I can combine them element wise in

00:52:30,330 --> 00:52:33,950
the you know it's just it's just and

00:52:31,590 --> 00:52:36,180
that's that's that is now a one-liner

00:52:33,950 --> 00:52:40,350
they very very simple one-liner for

00:52:36,180 --> 00:52:42,150
doing doing the the derivation and this

00:52:40,350 --> 00:52:43,620
would become much more complicated to

00:52:42,150 --> 00:52:47,220
write in terms of inline methods in dot

00:52:43,620 --> 00:52:49,680
e and this is I think very very similar

00:52:47,220 --> 00:52:51,660
to what you would get using magnolia

00:52:49,680 --> 00:52:53,340
apparently I think it's not it's not

00:52:51,660 --> 00:52:55,560
very different from that it's possibly

00:52:53,340 --> 00:52:58,320
it's probably more concise because of

00:52:55,560 --> 00:53:00,540
the way that it uses polymorphic

00:52:58,320 --> 00:53:04,170
function literals here which I think I

00:53:00,540 --> 00:53:06,030
think help a lot and obviously it hooks

00:53:04,170 --> 00:53:11,160
in very nicely with the with the

00:53:06,030 --> 00:53:14,520
structure an ich is another good example

00:53:11,160 --> 00:53:17,670
so this this one I only have instances

00:53:14,520 --> 00:53:27,120
from products this has products on Co

00:53:17,670 --> 00:53:28,740
products so here we have a similar kind

00:53:27,120 --> 00:53:30,270
of derived clause we get handed a

00:53:28,740 --> 00:53:31,440
generic this time it's it's neutral

00:53:30,270 --> 00:53:33,390
whether it's whether it's a product

00:53:31,440 --> 00:53:35,010
generic or a co-product generic we had a

00:53:33,390 --> 00:53:36,450
little bit of infrastructure which

00:53:35,010 --> 00:53:39,390
decides whether we're going to follow

00:53:36,450 --> 00:53:40,470
the product or the co-product branch but

00:53:39,390 --> 00:53:43,050
essentially it's kind of what you'd

00:53:40,470 --> 00:53:43,860
expect so for a product we're just doing

00:53:43,050 --> 00:53:46,470
a fold

00:53:43,860 --> 00:53:48,150
starting with true and then we'll just

00:53:46,470 --> 00:53:50,820
continue and we'll either will either

00:53:48,150 --> 00:53:52,710
bail out the false early or will

00:53:50,820 --> 00:53:55,470
continue with true until we've exhausted

00:53:52,710 --> 00:53:56,730
the structure and for the co product

00:53:55,470 --> 00:53:58,950
type well basically we just we just

00:53:56,730 --> 00:54:00,780
followed the one single bra well if the

00:53:58,950 --> 00:54:03,480
- if we're handed two values if the two

00:54:00,780 --> 00:54:09,990
branches align we'll will compare them

00:54:03,480 --> 00:54:14,070
element wise otherwise so something a

00:54:09,990 --> 00:54:15,870
bit more sexy and so this is basically

00:54:14,070 --> 00:54:19,950
the state-of-the-art with shape just to

00:54:15,870 --> 00:54:26,370
so deriving type classes four types of

00:54:19,950 --> 00:54:32,630
kind star arrow star so that's a functor

00:54:26,370 --> 00:54:36,950
type okay I'm over time I'm over time

00:54:32,630 --> 00:54:39,490
nevermind and I'll just show you anyway

00:54:36,950 --> 00:54:42,050
whoops

00:54:39,490 --> 00:54:44,270
it's a break next isn't it is it a break

00:54:42,050 --> 00:54:45,890
next can someone tell me is it a break

00:54:44,270 --> 00:54:56,870
would you like me to carry on it which I

00:54:45,890 --> 00:54:59,000
stopped carry on yeah okay okay thanks a

00:54:56,870 --> 00:55:01,610
factor right okay folks it's really cool

00:54:59,000 --> 00:55:03,320
I I'm really I'm so I'm really excited

00:55:01,610 --> 00:55:05,780
by this because there is a huge amount

00:55:03,320 --> 00:55:06,890
of stuff in kittens which is a type

00:55:05,780 --> 00:55:09,350
conservation for cats

00:55:06,890 --> 00:55:12,040
it sort of does as much as it possibly

00:55:09,350 --> 00:55:13,970
can with with sort of third for the

00:55:12,040 --> 00:55:15,800
attempt at higher kind of stuff and

00:55:13,970 --> 00:55:17,090
shape us at the moment and it dries

00:55:15,800 --> 00:55:18,500
functors but it's just so much more

00:55:17,090 --> 00:55:21,710
complicated in this and this is this is

00:55:18,500 --> 00:55:23,710
just so we got the derived clause making

00:55:21,710 --> 00:55:26,630
this funk products and co-products

00:55:23,710 --> 00:55:29,150
coincide for functor I guess it's kind

00:55:26,630 --> 00:55:30,770
of unsurprising that they would but

00:55:29,150 --> 00:55:32,450
basically you just map over the

00:55:30,770 --> 00:55:37,580
instances for the components that you've

00:55:32,450 --> 00:55:38,810
done which is just awesome and then it

00:55:37,580 --> 00:55:40,160
also turns out that there are these

00:55:38,810 --> 00:55:41,870
other things like higher candied

00:55:40,160 --> 00:55:47,110
functors okay how about that so

00:55:41,870 --> 00:55:49,430
which is which is a something which is a

00:55:47,110 --> 00:55:50,930
type parameterised in terms of a higher

00:55:49,430 --> 00:55:51,980
country type itself and then and then

00:55:50,930 --> 00:55:54,320
you map over it with a natural

00:55:51,980 --> 00:55:56,210
transformation so something like this so

00:55:54,320 --> 00:55:58,970
this is well beyond shapelessness

00:55:56,210 --> 00:56:01,640
capabilities and hey presto it's

00:55:58,970 --> 00:56:05,650
identical look at that look at that we

00:56:01,640 --> 00:56:10,220
just map over with a single one-line

00:56:05,650 --> 00:56:12,530
mapping over we get handed the the the

00:56:10,220 --> 00:56:14,900
individual type class instances for the

00:56:12,530 --> 00:56:17,210
the elements of the the higher kind is

00:56:14,900 --> 00:56:21,440
high kind of type or type with our hike

00:56:17,210 --> 00:56:24,080
I did elements and it's lovely it's

00:56:21,440 --> 00:56:26,210
absolutely lovely okay so these one last

00:56:24,080 --> 00:56:30,320
thing I want to show you is an example

00:56:26,210 --> 00:56:36,230
of something which is not possible to

00:56:30,320 --> 00:56:38,120
represent using using in sort of the

00:56:36,230 --> 00:56:41,450
regular stuff so this is something that

00:56:38,120 --> 00:56:42,950
is currently I guess a USP for shapeless

00:56:41,450 --> 00:56:45,800
and I think will continue to be a use

00:56:42,950 --> 00:56:48,200
USP for this for shape is three so this

00:56:45,800 --> 00:56:49,520
is a transform type and basically this

00:56:48,200 --> 00:56:51,260
is something which allow you see so you

00:56:49,520 --> 00:56:52,670
have a pair of a pair of case classes

00:56:51,260 --> 00:56:55,549
they kind

00:56:52,670 --> 00:56:57,680
side-on on some fields by type and name

00:56:55,549 --> 00:56:59,089
and you essentially want to extend the

00:56:57,680 --> 00:57:00,950
smaller ones the bigger one by filling

00:56:59,089 --> 00:57:02,569
in possibly permuting the elements if

00:57:00,950 --> 00:57:05,470
they're in different orders and then

00:57:02,569 --> 00:57:08,270
filling in filling in components with

00:57:05,470 --> 00:57:10,329
with stuff drawn from say from a monoid

00:57:08,270 --> 00:57:16,460
site for example as a default value and

00:57:10,329 --> 00:57:48,079
this I'm just going to show you this

00:57:16,460 --> 00:57:49,549
chunk really so here we're just so this

00:57:48,079 --> 00:57:51,260
this can't quite fit in with the derives

00:57:49,549 --> 00:57:52,460
infrastructure but it doesn't really

00:57:51,260 --> 00:57:54,020
matter that it doesn't it's not

00:57:52,460 --> 00:57:56,049
something you would necessarily expect

00:57:54,020 --> 00:57:58,430
it to be able to but you can basically

00:57:56,049 --> 00:58:00,530
hand it a pair of generics one for each

00:57:58,430 --> 00:58:02,510
of the type so this is this is why it

00:58:00,530 --> 00:58:05,299
can't be modelers or as a regular type

00:58:02,510 --> 00:58:08,680
class but then we can just we can we can

00:58:05,299 --> 00:58:10,910
we can essentially merge the two

00:58:08,680 --> 00:58:14,299
corresponding records so this is making

00:58:10,910 --> 00:58:15,530
use of of the labels so we get we make

00:58:14,299 --> 00:58:16,250
use the element label so this is the

00:58:15,530 --> 00:58:19,400
kind of stuff that you would in

00:58:16,250 --> 00:58:21,349
shapeless is labeled generic we can

00:58:19,400 --> 00:58:23,059
write code which look actually it's much

00:58:21,349 --> 00:58:26,569
more like real code than the stuff that

00:58:23,059 --> 00:58:28,099
uses implicit Cinch APIs - we can merge

00:58:26,569 --> 00:58:30,500
the records and then and then and then

00:58:28,099 --> 00:58:33,440
just tape the record back into the into

00:58:30,500 --> 00:58:42,380
the expanded data value which is just

00:58:33,440 --> 00:58:44,930
very nice okay so that was that so

00:58:42,380 --> 00:58:46,490
what's next back port 2 to 13 to 14

00:58:44,930 --> 00:58:49,990
believe it or not I think it's possible

00:58:46,490 --> 00:58:53,420
so it doesn't depend on any of Dottie's

00:58:49,990 --> 00:58:54,740
poly kind kind polymorphism stuff it's

00:58:53,420 --> 00:58:57,190
done the refinements that can be back

00:58:54,740 --> 00:58:59,569
ported and the the additions to

00:58:57,190 --> 00:59:00,770
companions are really tiny you know if

00:58:59,569 --> 00:59:03,079
you compare them to the amount of stuff

00:59:00,770 --> 00:59:04,970
that's generated by by case classes in

00:59:03,079 --> 00:59:05,829
general the the additions are really

00:59:04,970 --> 00:59:07,829
minimal so I think

00:59:05,829 --> 00:59:10,809
think it's it's small it's low low risk

00:59:07,829 --> 00:59:13,089
it's mainly you know adding half a dozen

00:59:10,809 --> 00:59:15,989
fight members to two companion objects

00:59:13,089 --> 00:59:18,069
futures which is really no no big deal

00:59:15,989 --> 00:59:20,200
so the fact that it's minimal is a real

00:59:18,069 --> 00:59:23,709
real real huge help to doing that and

00:59:20,200 --> 00:59:26,079
then back portray plus three itself to

00:59:23,709 --> 00:59:28,269
Scala to either it you know if in terms

00:59:26,079 --> 00:59:29,589
of a back ported mirror or in terms of

00:59:28,269 --> 00:59:30,219
Scala Maps color to micros and that

00:59:29,589 --> 00:59:32,979
that's fine

00:59:30,219 --> 00:59:34,660
so then maybe a compatibility layer that

00:59:32,979 --> 00:59:36,910
will help people get from shapers to two

00:59:34,660 --> 00:59:38,289
chambers three and then we have of the

00:59:36,910 --> 00:59:39,789
migration path to the Dossey which is

00:59:38,289 --> 00:59:43,869
which is kind of what I've been trying

00:59:39,789 --> 00:59:46,180
to get at so them half is kind of start

00:59:43,869 --> 00:59:47,979
by moving from shakers to to shapeless

00:59:46,180 --> 00:59:50,769
three on Scala to thirteen or fourteen

00:59:47,979 --> 00:59:52,660
and then having done that you're in a

00:59:50,769 --> 00:59:54,219
good position to move from from from

00:59:52,660 --> 00:59:58,420
Scylla to to Scylla three if you're

00:59:54,219 --> 01:00:00,430
using this stuff okay other things sort

00:59:58,420 --> 01:00:01,809
of more administrivia Sheamus is going

01:00:00,430 --> 01:00:03,579
to move to the type of all github

01:00:01,809 --> 01:00:05,709
organization the artifact is going to

01:00:03,579 --> 01:00:06,880
come out of comm qusai and go into orbit

01:00:05,709 --> 01:00:08,799
height level which it really should have

01:00:06,880 --> 01:00:10,390
done a very long time ago amongst other

01:00:08,799 --> 01:00:11,949
things that maintain it enables a much

01:00:10,390 --> 01:00:13,719
larger pool of maintenance and

01:00:11,949 --> 01:00:16,839
publishers to work on the stuff without

01:00:13,719 --> 01:00:24,009
me being necessarily the bottleneck you

01:00:16,839 --> 01:00:25,690
can find the preview here and well I've

01:00:24,009 --> 01:00:32,369
blown my budget

01:00:25,690 --> 01:00:32,369
[Applause]

01:00:33,060 --> 01:00:36,910
do i mean do i mean is it is it a sila

01:00:35,890 --> 01:00:39,220
break if people still want to ask

01:00:36,910 --> 01:00:43,950
questions then I'm happy to you want to

01:00:39,220 --> 01:00:43,950

YouTube URL: https://www.youtube.com/watch?v=yUzcQJpbT2k


