Title: Pick your number type with Spire - Denis Rosset
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/pick-your-number-type-with-spire
Captions: 
	00:00:00,920 --> 00:00:07,080
so I guess we've seen the description of

00:00:04,020 --> 00:00:09,960
that talk what happened is that I joined

00:00:07,080 --> 00:00:12,240
the Scala days even on Monday first

00:00:09,960 --> 00:00:14,750
talking to people in the compiler team

00:00:12,240 --> 00:00:18,300
and then on Tuesday we had the spray and

00:00:14,750 --> 00:00:19,560
a lot of things change because I look at

00:00:18,300 --> 00:00:20,430
the community and I could interact with

00:00:19,560 --> 00:00:22,260
people

00:00:20,430 --> 00:00:25,080
my name is Denise rosettes I'm a

00:00:22,260 --> 00:00:27,570
physicist so it's pretty far from like I

00:00:25,080 --> 00:00:30,150
would say what the bulk of people are

00:00:27,570 --> 00:00:32,640
doing here and it colors what I do on

00:00:30,150 --> 00:00:34,260
spire like I love abstract math so I'm

00:00:32,640 --> 00:00:36,239
going to put like a lot of type classes

00:00:34,260 --> 00:00:37,829
and you know play with it there are many

00:00:36,239 --> 00:00:39,780
libraries in the sky ecosystem you know

00:00:37,829 --> 00:00:41,940
people like to build a pox abstraction

00:00:39,780 --> 00:00:43,800
and maybe the liberal library is

00:00:41,940 --> 00:00:46,530
beautiful but you don't have much

00:00:43,800 --> 00:00:48,420
documentation I would be in that camp

00:00:46,530 --> 00:00:50,219
but I realize I want this to be useful

00:00:48,420 --> 00:00:51,989
so maybe we should extract something

00:00:50,219 --> 00:00:53,340
nice out of it you know and and give it

00:00:51,989 --> 00:00:56,430
to the community and make it accessible

00:00:53,340 --> 00:00:58,530
so basically I get my money from tamatha

00:00:56,430 --> 00:01:01,530
Institute which is a public research

00:00:58,530 --> 00:01:03,300
institution unpaid by some foundation

00:01:01,530 --> 00:01:05,790
that gives money for for national

00:01:03,300 --> 00:01:08,400
physics like I don't need to do anything

00:01:05,790 --> 00:01:11,189
useful and follow up I walk on type

00:01:08,400 --> 00:01:13,020
level spire your deaf deafened ways to

00:01:11,189 --> 00:01:15,090
contact me the best is my email address

00:01:13,020 --> 00:01:17,820
I'm new to Twitter but it seems my dark

00:01:15,090 --> 00:01:21,299
messages are planned so feel free and I

00:01:17,820 --> 00:01:24,330
have a github account it's like a lot of

00:01:21,299 --> 00:01:26,250
things but you will quickly get a feel

00:01:24,330 --> 00:01:27,840
of is this like something you can use or

00:01:26,250 --> 00:01:30,390
share or it's something I just put there

00:01:27,840 --> 00:01:34,079
you know like all all get up profiles of

00:01:30,390 --> 00:01:36,210
these things maybe before I go with the

00:01:34,079 --> 00:01:39,270
talk like just to share what all I

00:01:36,210 --> 00:01:41,159
started with by muscala so I walk in

00:01:39,270 --> 00:01:42,600
quantum physics and we have something

00:01:41,159 --> 00:01:44,970
really important in our research called

00:01:42,600 --> 00:01:46,799
Bell inequalities just just a world and

00:01:44,970 --> 00:01:48,689
during my thesis I realized oh I can

00:01:46,799 --> 00:01:50,939
organize those things and I want to

00:01:48,689 --> 00:01:52,680
build a database so that people can look

00:01:50,939 --> 00:01:57,950
at the research result you know and

00:01:52,680 --> 00:02:00,180
click and display them in various ways

00:01:57,950 --> 00:02:02,430
otherwise you know which programming

00:02:00,180 --> 00:02:03,960
language am I going to use for that I

00:02:02,430 --> 00:02:06,390
wanted something that was robust

00:02:03,960 --> 00:02:08,940
something with static types something

00:02:06,390 --> 00:02:10,470
that could run on the web and something

00:02:08,940 --> 00:02:13,410
that could interface with Java because a

00:02:10,470 --> 00:02:15,960
lot of matlab mathematica things

00:02:13,410 --> 00:02:17,670
well with Java then I started use Scala

00:02:15,960 --> 00:02:20,100
and I thought that that's really nice

00:02:17,670 --> 00:02:24,060
that we called spire that encoded

00:02:20,100 --> 00:02:26,400
basically arithmetic and like day-to-day

00:02:24,060 --> 00:02:28,080
Matt and I started to work on it what I

00:02:26,400 --> 00:02:30,000
want to say that I did not write spire

00:02:28,080 --> 00:02:32,370
I'm just know like the Crone maintainer

00:02:30,000 --> 00:02:34,830
and I realize what it is to work with

00:02:32,370 --> 00:02:36,420
the legacy code base they are passed the

00:02:34,830 --> 00:02:38,340
tile I just don't know what they walk

00:02:36,420 --> 00:02:41,010
and to understand how they work it would

00:02:38,340 --> 00:02:44,940
take me a month so still I'm going to

00:02:41,010 --> 00:02:46,650
push this forward a few thing about the

00:02:44,940 --> 00:02:50,190
title there are like three key words

00:02:46,650 --> 00:02:53,040
number type and inspire what's a number

00:02:50,190 --> 00:02:54,630
it's actually a good question we have

00:02:53,040 --> 00:02:56,520
integers in math we are we all number

00:02:54,630 --> 00:02:58,560
fraction complex number polynomials

00:02:56,520 --> 00:03:01,620
nothing maybe in business you will walk

00:02:58,560 --> 00:03:04,020
with timestamps GPS coordinates time

00:03:01,620 --> 00:03:06,720
offsets are those numbers or do we

00:03:04,020 --> 00:03:08,280
manipulate them money is also like could

00:03:06,720 --> 00:03:11,970
be like a number there's maybe a

00:03:08,280 --> 00:03:13,470
currency attached to it so it's a good

00:03:11,970 --> 00:03:17,220
question I think like what's a number

00:03:13,470 --> 00:03:18,410
second thing is type and here we move to

00:03:17,220 --> 00:03:20,640
something else

00:03:18,410 --> 00:03:21,959
it's really nice to work with abstract

00:03:20,640 --> 00:03:23,670
math and have colleagues who are very

00:03:21,959 --> 00:03:26,010
happy to prove that something exists

00:03:23,670 --> 00:03:28,380
even if they come show it to me like

00:03:26,010 --> 00:03:29,640
just an existence but when you walk on a

00:03:28,380 --> 00:03:33,330
computer you need to be able to

00:03:29,640 --> 00:03:35,340
represent what you what you're doing and

00:03:33,330 --> 00:03:36,810
I think the most important question is

00:03:35,340 --> 00:03:39,690
or do you anchor numbers on a computer

00:03:36,810 --> 00:03:41,910
what's going to be the data type what

00:03:39,690 --> 00:03:44,370
what are your person you can do the API

00:03:41,910 --> 00:03:46,920
and often like writing an API is going

00:03:44,370 --> 00:03:49,320
to steal users towards doing the right

00:03:46,920 --> 00:03:51,870
thing or not I think a lot of people

00:03:49,320 --> 00:03:55,410
know like F P because if you use FP you

00:03:51,870 --> 00:03:56,730
kind of force to do the right thing the

00:03:55,410 --> 00:03:59,459
internal representation that goes with

00:03:56,730 --> 00:04:01,020
the first one and you're going to take

00:03:59,459 --> 00:04:02,790
that word like care of all the we

00:04:01,020 --> 00:04:05,670
interact with the world and people who

00:04:02,790 --> 00:04:08,070
use JSON for example or do you transform

00:04:05,670 --> 00:04:09,750
number between JSON and and Scala it's

00:04:08,070 --> 00:04:12,390
actually not very clear if you want to

00:04:09,750 --> 00:04:14,160
be to be precise I'm not going to speak

00:04:12,390 --> 00:04:15,510
about that just to say that it can be an

00:04:14,160 --> 00:04:18,120
issue

00:04:15,510 --> 00:04:20,690
what is fire I already spoke that it's a

00:04:18,120 --> 00:04:23,580
type level project I did not start it

00:04:20,690 --> 00:04:25,080
now it's compatible with cats so there

00:04:23,580 --> 00:04:25,500
is an intersection between cats and

00:04:25,080 --> 00:04:27,240
spire

00:04:25,500 --> 00:04:30,990
it's basically a quality

00:04:27,240 --> 00:04:33,000
and comparison order then on top of cats

00:04:30,990 --> 00:04:35,069
you have Twitter there's something

00:04:33,000 --> 00:04:37,199
called algebra that basically makes that

00:04:35,069 --> 00:04:39,330
Twitter and spire used the same

00:04:37,199 --> 00:04:40,800
abstraction for numbers Twitter

00:04:39,330 --> 00:04:43,410
something called algebra that I don't

00:04:40,800 --> 00:04:45,780
know much spyro is eight years old it's

00:04:43,410 --> 00:04:48,930
for medium-sized project thirty-three

00:04:45,780 --> 00:04:50,220
thousand lines of code so you see like

00:04:48,930 --> 00:04:52,620
plotting that with Scala tree is going

00:04:50,220 --> 00:04:55,110
to be fun and the version number is not

00:04:52,620 --> 00:04:57,270
1.0 and that's that's a big problem like

00:04:55,110 --> 00:04:59,220
all do we get one point all and I can

00:04:57,270 --> 00:05:01,440
tell you in you know like please use it

00:04:59,220 --> 00:05:02,789
actually I came to Scala days I oh I'm

00:05:01,440 --> 00:05:04,259
going to advertise the debris and

00:05:02,789 --> 00:05:07,020
everybody is using it and then I realize

00:05:04,259 --> 00:05:08,699
we're going to pop those like 50,000

00:05:07,020 --> 00:05:10,080
lines of code to Scala tree should I

00:05:08,699 --> 00:05:13,169
tell you to use it if we don't have a

00:05:10,080 --> 00:05:14,669
migration story you know it's very

00:05:13,169 --> 00:05:17,340
different between being an academic and

00:05:14,669 --> 00:05:19,080
writing code just fold this year paper

00:05:17,340 --> 00:05:21,720
and then you forget about it or running

00:05:19,080 --> 00:05:23,699
a business on it so I mean I have a

00:05:21,720 --> 00:05:26,099
cultural gap so the end of that talk is

00:05:23,699 --> 00:05:31,530
going to be me asking question what do

00:05:26,099 --> 00:05:36,719
you want out of this so what what a spy

00:05:31,530 --> 00:05:38,880
on inside there is an API for numbers if

00:05:36,719 --> 00:05:40,590
you work with the Skylar stone of

00:05:38,880 --> 00:05:43,169
library you know that you can for

00:05:40,590 --> 00:05:45,539
example on any collection you can call

00:05:43,169 --> 00:05:47,729
that son and it's going to give you the

00:05:45,539 --> 00:05:49,830
sum of things but you're not going to

00:05:47,729 --> 00:05:51,930
call some doubles and float some int

00:05:49,830 --> 00:05:54,599
there is a mechanism that whatever is

00:05:51,930 --> 00:05:56,580
your number inside your sequence it's

00:05:54,599 --> 00:05:58,650
going to compute the sum of that spider

00:05:56,580 --> 00:06:00,180
is this on steroids like it's it's much

00:05:58,650 --> 00:06:02,190
more precise and it gives you much more

00:06:00,180 --> 00:06:05,520
expressive bility maybe too much we'll

00:06:02,190 --> 00:06:08,430
see that goes with a generic programming

00:06:05,520 --> 00:06:10,409
if you use goal you need to write some

00:06:08,430 --> 00:06:12,180
operation for every type if you use

00:06:10,409 --> 00:06:14,340
Scala inspire you can just write it once

00:06:12,180 --> 00:06:19,800
and then it's available for whatever

00:06:14,340 --> 00:06:22,409
type as that API available and finally

00:06:19,800 --> 00:06:24,750
we have data types if you need to work

00:06:22,409 --> 00:06:27,030
with fractional numbers they would give

00:06:24,750 --> 00:06:28,979
you exact computation on your computer

00:06:27,030 --> 00:06:30,870
and we have a bunch of things maybe

00:06:28,979 --> 00:06:32,849
maybe interval arithmetic is going to be

00:06:30,870 --> 00:06:35,099
useful to represent a number that you

00:06:32,849 --> 00:06:37,110
don't know very precisely and a complex

00:06:35,099 --> 00:06:38,470
in quadrants more like fancy fancy stuff

00:06:37,110 --> 00:06:43,150
that's

00:06:38,470 --> 00:06:45,100
under me people actually use it what I

00:06:43,150 --> 00:06:47,340
won't say what what power gives you more

00:06:45,100 --> 00:06:49,330
than than the standard library I

00:06:47,340 --> 00:06:51,730
mentioned that you can take in in scale

00:06:49,330 --> 00:06:54,490
you can take any sequence and this would

00:06:51,730 --> 00:06:57,970
be like the mechanism on 2.13 on any

00:06:54,490 --> 00:07:00,970
sequence you can call some what liq

00:06:57,970 --> 00:07:03,190
elements are integrals of double

00:07:00,970 --> 00:07:05,380
floating-point numbers it's going to

00:07:03,190 --> 00:07:08,080
walk why because when you call the

00:07:05,380 --> 00:07:10,480
method son there is an implicit or no

00:07:08,080 --> 00:07:12,340
delegate for scalar tree that's going to

00:07:10,480 --> 00:07:14,380
come into play and it's going to do the

00:07:12,340 --> 00:07:17,350
right thing start with zero and add

00:07:14,380 --> 00:07:21,120
those numbers one by one to this

00:07:17,350 --> 00:07:24,010
accumulated Sun and it works really well

00:07:21,120 --> 00:07:26,620
but there are like three things that you

00:07:24,010 --> 00:07:29,350
could be could be done better the first

00:07:26,620 --> 00:07:32,230
things that it's not very precise if you

00:07:29,350 --> 00:07:35,710
say this number is numeric you have to

00:07:32,230 --> 00:07:37,630
actually extend ordering and you can be

00:07:35,710 --> 00:07:40,240
more precise than that so as an example

00:07:37,630 --> 00:07:43,000
if you walk with what onions some people

00:07:40,240 --> 00:07:44,919
do like 3d graphics with what onions or

00:07:43,000 --> 00:07:47,470
complex numbers for some reason complex

00:07:44,919 --> 00:07:49,450
numbers maybe in electrical systems

00:07:47,470 --> 00:07:50,740
those numbers they're on the plane they

00:07:49,450 --> 00:07:53,260
are not they don't have an ordering on

00:07:50,740 --> 00:07:55,150
the line so you would have to lie there

00:07:53,260 --> 00:07:57,580
like in Python you define a class and

00:07:55,150 --> 00:08:01,360
just do C's dot error or not implemented

00:07:57,580 --> 00:08:02,620
which is not very Scala like and then if

00:08:01,360 --> 00:08:04,600
you think that I don't know the

00:08:02,620 --> 00:08:07,840
semantics of like there is this API and

00:08:04,600 --> 00:08:09,610
I don't know precisely what it is the

00:08:07,840 --> 00:08:13,180
second thing is every time you do a sec

00:08:09,610 --> 00:08:15,160
Sun it will box so if you have an array

00:08:13,180 --> 00:08:17,979
of a known million double floating-point

00:08:15,160 --> 00:08:20,050
numbers and you call some on it maybe

00:08:17,979 --> 00:08:22,030
denies doing something clever today but

00:08:20,050 --> 00:08:23,530
in 2.10 it was not doing something

00:08:22,030 --> 00:08:27,040
clever what it's going to do is

00:08:23,530 --> 00:08:29,320
allocates a million double boxes on the

00:08:27,040 --> 00:08:31,210
hip and you know manipulate them and

00:08:29,320 --> 00:08:33,580
give you written in something that

00:08:31,210 --> 00:08:35,560
that's a box of a double and then BAM

00:08:33,580 --> 00:08:36,430
bring in back to a primitive type so

00:08:35,560 --> 00:08:38,440
you're going to have like crazy

00:08:36,430 --> 00:08:40,870
allocation and if you have like odd

00:08:38,440 --> 00:08:42,520
spots in your code with that stuff it's

00:08:40,870 --> 00:08:44,860
going to be slow so then maybe you're

00:08:42,520 --> 00:08:46,150
going to write a while loop and go back

00:08:44,860 --> 00:08:48,040
to something you would do with Wisco

00:08:46,150 --> 00:08:50,589
which is not maybe what we want and

00:08:48,040 --> 00:08:51,700
other things like when you say something

00:08:50,589 --> 00:08:54,550
is ordered

00:08:51,700 --> 00:08:56,640
seeing as a plus operation there are a

00:08:54,550 --> 00:08:58,960
series of laws that they should obey for

00:08:56,640 --> 00:09:01,990
people to build the algorithm on top of

00:08:58,960 --> 00:09:04,150
it but but those types don't specify

00:09:01,990 --> 00:09:06,010
exactly what are those laws and you have

00:09:04,150 --> 00:09:10,480
no way to check them so this is what

00:09:06,010 --> 00:09:11,950
spire brings to the to the table no I'm

00:09:10,480 --> 00:09:15,580
going to the plan and I just want to

00:09:11,950 --> 00:09:19,480
check the time that's very nice ten

00:09:15,580 --> 00:09:21,150
minutes it's going very well I'm going

00:09:19,480 --> 00:09:24,730
to dig a bit more into those things

00:09:21,150 --> 00:09:26,920
speak about numbers maybe you all nobody

00:09:24,730 --> 00:09:28,930
it maybe not feel free to ask question

00:09:26,920 --> 00:09:30,520
interrupt there is some slack in that

00:09:28,930 --> 00:09:34,060
presentation so it's it's more laid-back

00:09:30,520 --> 00:09:35,830
not trying to cram second thing I'm

00:09:34,060 --> 00:09:39,070
going to show you like all styles

00:09:35,830 --> 00:09:41,800
provide api's for numbers no I'm just

00:09:39,070 --> 00:09:43,630
going to give an overview and then have

00:09:41,800 --> 00:09:45,160
a benchmark we are going to see or

00:09:43,630 --> 00:09:48,400
perform on those implementation are

00:09:45,160 --> 00:09:51,010
across the JVM JavaScript and scalar

00:09:48,400 --> 00:09:53,020
native I really wanted to do grow a VM

00:09:51,010 --> 00:09:54,370
but I don't understand well the

00:09:53,020 --> 00:09:56,110
performance story there do you don't

00:09:54,370 --> 00:09:59,490
want to add something on top but that's

00:09:56,110 --> 00:10:06,490
that's the planner so to look at that

00:09:59,490 --> 00:10:08,280
what are numbers so I will add something

00:10:06,490 --> 00:10:11,080
if we take natural numbers and everybody

00:10:08,280 --> 00:10:13,570
know what they are but I remember being

00:10:11,080 --> 00:10:14,860
here like in Geneva Switzerland and in

00:10:13,570 --> 00:10:18,040
primary school and we learned what

00:10:14,860 --> 00:10:20,830
numbers were and they tried to teach us

00:10:18,040 --> 00:10:23,050
about binary and you know decimal bases

00:10:20,830 --> 00:10:24,190
when we were like eight years old so it

00:10:23,050 --> 00:10:27,100
was very useful for me to go into

00:10:24,190 --> 00:10:28,660
computing but normally you we all went

00:10:27,100 --> 00:10:30,460
to school and we learn about natural

00:10:28,660 --> 00:10:33,880
none or something that we know we know

00:10:30,460 --> 00:10:35,080
what they are like counting and then if

00:10:33,880 --> 00:10:36,760
you have a way to works on natural

00:10:35,080 --> 00:10:39,100
numbers you just add a sign and maybe

00:10:36,760 --> 00:10:41,170
maybe a zero and you get basically the

00:10:39,100 --> 00:10:43,300
sign numbers and that's a type that's

00:10:41,170 --> 00:10:46,420
very easy to represent on a computer you

00:10:43,300 --> 00:10:49,810
just allocate as many bytes you need to

00:10:46,420 --> 00:10:52,480
encode all the all the bits that compose

00:10:49,810 --> 00:10:54,430
your number and to sign whatever sign

00:10:52,480 --> 00:10:57,850
representation you use and bam you of

00:10:54,430 --> 00:10:59,740
your type there is if you want to work

00:10:57,850 --> 00:11:02,500
on fraction it's something what's going

00:10:59,740 --> 00:11:04,960
next when you when you do like first

00:11:02,500 --> 00:11:07,450
year mathematics at the University

00:11:04,960 --> 00:11:09,760
you looking at fractions it's very easy

00:11:07,450 --> 00:11:12,040
to take a sign number for the numerator

00:11:09,760 --> 00:11:14,110
and a natural number of the denominator

00:11:12,040 --> 00:11:16,540
or would you do that in a programming

00:11:14,110 --> 00:11:19,390
language it's just a couple of big

00:11:16,540 --> 00:11:20,590
integers but then something weird

00:11:19,390 --> 00:11:22,570
happens when you learn about real

00:11:20,590 --> 00:11:24,790
numbers why I took the Wikipedia

00:11:22,570 --> 00:11:27,790
definition that's actually pretty cool

00:11:24,790 --> 00:11:29,890
it's a value of a continuous quantity

00:11:27,790 --> 00:11:32,410
that's basically a distance on a line

00:11:29,890 --> 00:11:34,090
it's very natural but what would you

00:11:32,410 --> 00:11:36,520
represent a distance along a line on a

00:11:34,090 --> 00:11:38,380
computer it's not very clear so then

00:11:36,520 --> 00:11:40,770
maybe you look all the mathematician

00:11:38,380 --> 00:11:43,000
construct wheel numbers and it's crazy

00:11:40,770 --> 00:11:45,670
so there are like six construction I

00:11:43,000 --> 00:11:47,820
don't understand them but the things

00:11:45,670 --> 00:11:50,410
that none of this construction can be

00:11:47,820 --> 00:11:53,050
you can do that efficiently on on a

00:11:50,410 --> 00:11:56,080
computer sometimes even impossible to

00:11:53,050 --> 00:11:59,920
compute with that so what do you do you

00:11:56,080 --> 00:12:01,540
resort to approximations so there are

00:11:59,920 --> 00:12:09,190
two ways to do that and I will is

00:12:01,540 --> 00:12:18,040
something like I will remove my badge

00:12:09,190 --> 00:12:19,980
and we get rid of that this should be

00:12:18,040 --> 00:12:27,720
better yeah there we go

00:12:19,980 --> 00:12:30,280
I will not move so what do we have here

00:12:27,720 --> 00:12:33,100
as we seen before if you compute with

00:12:30,280 --> 00:12:34,840
rational numbers it's exact you will

00:12:33,100 --> 00:12:36,640
never have precision issues but you

00:12:34,840 --> 00:12:39,040
you're very limited you can only do the

00:12:36,640 --> 00:12:42,910
four basic operation no way to compute

00:12:39,040 --> 00:12:44,740
the sinus of something for example if

00:12:42,910 --> 00:12:47,410
you just want to use like roots square

00:12:44,740 --> 00:12:48,340
root for example you can move to

00:12:47,410 --> 00:12:50,140
something that's called algebraic

00:12:48,340 --> 00:12:53,350
numbers and you have those operations on

00:12:50,140 --> 00:12:55,660
top and you can still compute exactly so

00:12:53,350 --> 00:12:57,550
maybe I don't know if you do geometry

00:12:55,660 --> 00:12:59,290
and you want to intersect I don't know

00:12:57,550 --> 00:13:03,310
maybe engineering problem you want to

00:12:59,290 --> 00:13:04,720
intersect a sphere with I don't know

00:13:03,310 --> 00:13:06,460
with the surface maybe you're going to

00:13:04,720 --> 00:13:07,840
use algebraic numbers and you you're

00:13:06,460 --> 00:13:10,030
sure that your computer computation are

00:13:07,840 --> 00:13:11,860
correct to the end but I want to say

00:13:10,030 --> 00:13:13,750
that computing with exact numbers it's

00:13:11,860 --> 00:13:15,160
very hard in general on the slides I

00:13:13,750 --> 00:13:16,750
will have a link you can look that

00:13:15,160 --> 00:13:18,000
actually it's proven it's impossible to

00:13:16,750 --> 00:13:20,280
do that

00:13:18,000 --> 00:13:22,620
to use like everything you want and be

00:13:20,280 --> 00:13:25,980
exact so the other thing that people do

00:13:22,620 --> 00:13:27,360
they use approximations and in the jvm

00:13:25,980 --> 00:13:30,750
world we have basically two different

00:13:27,360 --> 00:13:33,030
types of approximations either you just

00:13:30,750 --> 00:13:35,580
write an integer and then you decide all

00:13:33,030 --> 00:13:36,600
many digits but decimal digits go on the

00:13:35,580 --> 00:13:40,770
right of the comma

00:13:36,600 --> 00:13:42,810
that would be big decimal or you say I

00:13:40,770 --> 00:13:44,870
have the same thing an integer and I

00:13:42,810 --> 00:13:48,300
move digits to the right of the decimal

00:13:44,870 --> 00:13:50,070
of the point but no it's in binary

00:13:48,300 --> 00:13:51,930
representation and that's going to be

00:13:50,070 --> 00:13:54,570
floating point and it's the usual float

00:13:51,930 --> 00:13:56,340
and double there is a third approach

00:13:54,570 --> 00:13:58,740
that's used more like in mathematics

00:13:56,340 --> 00:14:00,360
mathematical but basically you keep the

00:13:58,740 --> 00:14:02,160
whole expression in memory and when you

00:14:00,360 --> 00:14:05,220
need to do computation you maybe

00:14:02,160 --> 00:14:07,050
traverse the tree and ask maybe maybe 15

00:14:05,220 --> 00:14:08,970
digits was not enough let's do more and

00:14:07,050 --> 00:14:10,650
you compute more and more digits until

00:14:08,970 --> 00:14:12,600
you're satisfied that you have a correct

00:14:10,650 --> 00:14:17,640
answer I don't know much about that and

00:14:12,600 --> 00:14:20,940
it's not inspire so we can know things

00:14:17,640 --> 00:14:24,210
like why does this matter actually it's

00:14:20,940 --> 00:14:25,740
it's fun because if you compute with a

00:14:24,210 --> 00:14:28,050
lot of numbers and you do I don't know a

00:14:25,740 --> 00:14:29,610
million or billion additions in the end

00:14:28,050 --> 00:14:32,040
maybe you're going to present a summary

00:14:29,610 --> 00:14:33,990
of those numbers like accounting you're

00:14:32,040 --> 00:14:35,220
going to present a balance sheet and if

00:14:33,990 --> 00:14:38,130
you have like a 1 cent difference

00:14:35,220 --> 00:14:39,570
between I don't know billions I can't on

00:14:38,130 --> 00:14:42,270
don't love that because they see if you

00:14:39,570 --> 00:14:43,950
have like a small imprecisions probably

00:14:42,270 --> 00:14:45,300
that something bigger is hidden

00:14:43,950 --> 00:14:46,890
underneath and it will really dig

00:14:45,300 --> 00:14:48,210
through your stuff so if you compute

00:14:46,890 --> 00:14:50,490
with money you're not going to use

00:14:48,210 --> 00:14:53,430
floats because you just feed on our way

00:14:50,490 --> 00:14:55,860
with 10,000 floats and of like 10 cents

00:14:53,430 --> 00:14:57,900
and you sum and it should give you a

00:14:55,860 --> 00:14:59,370
thousand but actually not a thousand

00:14:57,900 --> 00:15:03,090
something there is a very small

00:14:59,370 --> 00:15:07,050
difference so this is why you use big

00:15:03,090 --> 00:15:10,110
decimal because big decimal is on base

00:15:07,050 --> 00:15:12,030
10 so something like 0.1 can be actually

00:15:10,110 --> 00:15:13,560
represented exactly on the computer and

00:15:12,030 --> 00:15:17,700
when you do the same thing you get

00:15:13,560 --> 00:15:20,160
actually 0 which is what you want when I

00:15:17,700 --> 00:15:22,020
see people doing like blockchain stuff

00:15:20,160 --> 00:15:23,340
Bitcoin and so on in JavaScript and they

00:15:22,020 --> 00:15:27,210
don't use the correct floating point

00:15:23,340 --> 00:15:29,160
like the correct number type I wonder

00:15:27,210 --> 00:15:30,780
like all along they're going to run with

00:15:29,160 --> 00:15:32,610
us having discrepancies in the

00:15:30,780 --> 00:15:35,130
in their accounting so that that's

00:15:32,610 --> 00:15:36,600
important stuff what I wanted to say

00:15:35,130 --> 00:15:39,990
because floating point numbers they use

00:15:36,600 --> 00:15:44,130
this exponent based on to something like

00:15:39,990 --> 00:15:46,230
0.25 is 1/4 4 is a power of two so if

00:15:44,130 --> 00:15:48,600
you do the same thing with 0.25 actually

00:15:46,230 --> 00:15:50,100
that computation is exact so it really

00:15:48,600 --> 00:15:56,220
depends what you're going to use big

00:15:50,100 --> 00:15:59,550
decimal or floats no what do you have on

00:15:56,220 --> 00:16:01,310
the JVM Scala's Piatt kind of already

00:15:59,550 --> 00:16:05,070
said that but I'm going to restate it

00:16:01,310 --> 00:16:06,810
the JVM has a few primitive types but

00:16:05,070 --> 00:16:09,930
mostly we're going to use those those

00:16:06,810 --> 00:16:12,300
fall in 10 on the approximate natural

00:16:09,930 --> 00:16:14,670
nor like signed numbers what they do is

00:16:12,300 --> 00:16:18,150
they cut like the range of what you can

00:16:14,670 --> 00:16:19,350
express steep pretty big but depending

00:16:18,150 --> 00:16:22,860
what you do you may want something

00:16:19,350 --> 00:16:25,950
that's safer and can overflow because

00:16:22,860 --> 00:16:28,770
they don't overflow nicely float and

00:16:25,950 --> 00:16:30,600
double they are encoded in that binary

00:16:28,770 --> 00:16:32,520
representation but if you look like at

00:16:30,600 --> 00:16:34,800
what happens when you write them using

00:16:32,520 --> 00:16:36,780
like human decimal notation float give

00:16:34,800 --> 00:16:38,490
you six to nine decimal digits the

00:16:36,780 --> 00:16:40,710
exponent wire is still pretty pretty

00:16:38,490 --> 00:16:43,770
mighty and double has a bit more

00:16:40,710 --> 00:16:47,250
precision fifteen sixteen digits and the

00:16:43,770 --> 00:16:49,290
exponent range is pretty huge so this is

00:16:47,250 --> 00:16:51,210
in fact is never going to be a problem

00:16:49,290 --> 00:16:55,920
but often you're going to be to be

00:16:51,210 --> 00:16:57,480
limited there may be a give you already

00:16:55,920 --> 00:16:59,820
kind of atom all of that because it's

00:16:57,480 --> 00:17:04,079
very abstract and we will need something

00:16:59,820 --> 00:17:05,699
to kind of refresh our minds and I need

00:17:04,079 --> 00:17:08,189
to distract you a little bit before we

00:17:05,699 --> 00:17:11,520
go on with more abstract stuff so what's

00:17:08,189 --> 00:17:13,800
this I don't know who has heard of the

00:17:11,520 --> 00:17:15,329
Mandelbrot fractal because I was

00:17:13,800 --> 00:17:17,490
fascinated with that as a kid I was like

00:17:15,329 --> 00:17:19,470
seven and I will as I can do that right

00:17:17,490 --> 00:17:21,569
now then I'm 36 I can use that stuff you

00:17:19,470 --> 00:17:23,699
know to talk about numbers pretty cool

00:17:21,569 --> 00:17:25,650
so what happens here is that I refresh

00:17:23,699 --> 00:17:28,290
that thing as fast as I can I show the

00:17:25,650 --> 00:17:31,050
FPS so that's kind of a benchmark I call

00:17:28,290 --> 00:17:32,970
fast can i compute that image I'm using

00:17:31,050 --> 00:17:34,890
scary facts and I did not optimize the

00:17:32,970 --> 00:17:37,080
graphics backs and so it's pretty stupid

00:17:34,890 --> 00:17:39,330
but I'm not rooted it's not a hot spot

00:17:37,080 --> 00:17:41,340
I'm not losing much time just putting

00:17:39,330 --> 00:17:43,299
this pushing pixel on the screen so it's

00:17:41,340 --> 00:17:46,840
basically limited by the

00:17:43,299 --> 00:17:49,000
Oh fasiqun computes and what I'm what I

00:17:46,840 --> 00:17:51,220
can do I push the number one to five and

00:17:49,000 --> 00:17:55,179
I can compute you see on the console

00:17:51,220 --> 00:17:57,370
there with floats so 32 bits double 64

00:17:55,179 --> 00:17:59,230
bits and I have two things we're going

00:17:57,370 --> 00:18:00,820
to see later what if we use generics to

00:17:59,230 --> 00:18:02,890
do we lose performance that's going to

00:18:00,820 --> 00:18:05,620
be a topic later so I'm going to go to

00:18:02,890 --> 00:18:08,919
floats and every time I double click

00:18:05,620 --> 00:18:10,690
zoom on part of that factor and we set

00:18:08,919 --> 00:18:12,669
that float have like six to nine digits

00:18:10,690 --> 00:18:15,429
so it means after every time i zoom it's

00:18:12,669 --> 00:18:17,200
a power of ten I can zoom ten times so

00:18:15,429 --> 00:18:18,970
maybe after after six or seven clicks

00:18:17,200 --> 00:18:20,799
we'll see what happens

00:18:18,970 --> 00:18:27,659
so right now it looks really good I

00:18:20,799 --> 00:18:34,480
assume I'll zoom two three four five Oh

00:18:27,659 --> 00:18:36,700
kids six so now I don't have enough

00:18:34,480 --> 00:18:39,130
precision to actually represent every

00:18:36,700 --> 00:18:41,289
value of the pixel composing that image

00:18:39,130 --> 00:18:43,840
and I when I do the iteration that

00:18:41,289 --> 00:18:46,360
confused the Mandelbrot set I'm going to

00:18:43,840 --> 00:18:50,460
have like precision problems now if I

00:18:46,360 --> 00:18:53,440
switch to double I get like the correct

00:18:50,460 --> 00:18:55,179
picture it's still an approximation but

00:18:53,440 --> 00:18:58,169
the approximation at that stage doesn't

00:18:55,179 --> 00:19:08,279
matter and if i zoom more and more and

00:18:58,169 --> 00:19:10,840
more three four five six seven ten and

00:19:08,279 --> 00:19:13,149
now I'm at the limit of the ball and

00:19:10,840 --> 00:19:14,620
with the JVM I'm going to run in a

00:19:13,149 --> 00:19:16,210
problem that I don't have any type

00:19:14,620 --> 00:19:18,399
that's a primitive type that as

00:19:16,210 --> 00:19:20,169
performant as double I can switch to

00:19:18,399 --> 00:19:23,350
something that's called double double

00:19:20,169 --> 00:19:25,929
it's a clever hack but no all my object

00:19:23,350 --> 00:19:28,000
because they are 128 bits they are going

00:19:25,929 --> 00:19:30,130
to be allocated on the heap so it's

00:19:28,000 --> 00:19:32,470
going to be slightly slower as you can

00:19:30,130 --> 00:19:34,539
see I don't still have something on the

00:19:32,470 --> 00:19:37,720
screen it's only going to take 15 or 20

00:19:34,539 --> 00:19:41,020
seconds to compute the new image I'll

00:19:37,720 --> 00:19:42,669
see if it's not too too slow because i

00:19:41,020 --> 00:19:45,010
zoom in a random part yeah and then I

00:19:42,669 --> 00:19:47,110
get my image so you see that if you use

00:19:45,010 --> 00:19:49,600
float double performance will be very

00:19:47,110 --> 00:19:51,490
good if you switch to more precise types

00:19:49,600 --> 00:19:53,110
it's going to be much slower the same

00:19:51,490 --> 00:19:55,419
story would happen with big decimal or

00:19:53,110 --> 00:19:57,070
Washington numbers you get several order

00:19:55,419 --> 00:19:59,080
of magnitude slowdowns due to

00:19:57,070 --> 00:20:02,710
due to proceed on adding Chris precision

00:19:59,080 --> 00:20:04,960
and memory allocation okay I was moving

00:20:02,710 --> 00:20:06,700
to this but I don't if you have question

00:20:04,960 --> 00:20:08,020
until then because I don't know if

00:20:06,700 --> 00:20:10,390
that's too abstract who like is it

00:20:08,020 --> 00:20:14,080
useful or you know like like feel free

00:20:10,390 --> 00:20:16,120
to interrupt cool so we've seen like

00:20:14,080 --> 00:20:18,010
primitive types no I want to see it says

00:20:16,120 --> 00:20:20,020
quickly something about reference types

00:20:18,010 --> 00:20:21,280
so this thing they can stay in the CPU

00:20:20,020 --> 00:20:24,070
registers they're going to be pretty

00:20:21,280 --> 00:20:26,380
fast this is going to be allocated on

00:20:24,070 --> 00:20:29,530
the heap but you can use an arbitrary

00:20:26,380 --> 00:20:31,480
amount of memory which is what provides

00:20:29,530 --> 00:20:33,430
big integer an arbitrary range you're

00:20:31,480 --> 00:20:34,740
never going to overflow it's safe in

00:20:33,430 --> 00:20:37,270
that respect

00:20:34,740 --> 00:20:39,310
big desimilus on arbitrary range and

00:20:37,270 --> 00:20:46,890
then you need to use like implicit right

00:20:39,310 --> 00:20:46,890
now to design under the most digits yeah

00:20:47,370 --> 00:20:53,950
yes yes that's that's correct

00:20:50,560 --> 00:20:55,270
I said a brittle range but of course

00:20:53,950 --> 00:20:57,460
we're limited by the memory of the

00:20:55,270 --> 00:20:59,020
computer and at some stage we have been

00:20:57,460 --> 00:21:01,150
limited by the number of atoms in the

00:20:59,020 --> 00:21:02,440
universe to encode that number so indeed

00:21:01,150 --> 00:21:05,110
we are never going to have like the

00:21:02,440 --> 00:21:06,610
mathematical abstract thing we are

00:21:05,110 --> 00:21:08,290
always going to run into limitation the

00:21:06,610 --> 00:21:09,970
questions do they matter but that's a

00:21:08,290 --> 00:21:13,150
really good question

00:21:09,970 --> 00:21:20,620
like remark same thing with arrays like

00:21:13,150 --> 00:21:22,150
we're limited by the allocation what we

00:21:20,620 --> 00:21:24,160
what I just said that they're located on

00:21:22,150 --> 00:21:26,770
the heap so you lose a bit of off speed

00:21:24,160 --> 00:21:29,220
there sometime the JVM is clever and can

00:21:26,770 --> 00:21:32,980
see ok but actually I can use the stack

00:21:29,220 --> 00:21:37,720
I did not do like a deep analysis of

00:21:32,980 --> 00:21:40,780
that but sometime it helps know what

00:21:37,720 --> 00:21:42,580
does color on top of that so Scala has a

00:21:40,780 --> 00:21:45,970
few L parameters on the Java primitive

00:21:42,580 --> 00:21:47,740
types when you use them in a general

00:21:45,970 --> 00:21:48,790
context Tajin collection they box so

00:21:47,740 --> 00:21:51,460
they are going to be allocated on the

00:21:48,790 --> 00:21:54,880
heap which is sometime a performance

00:21:51,460 --> 00:21:57,490
problem begin to perhaps big integer and

00:21:54,880 --> 00:22:00,070
brings big integrand to the scala Araki

00:21:57,490 --> 00:22:02,200
and big decimal I think it's of what but

00:22:00,070 --> 00:22:05,560
I did not dig into internals it's it's

00:22:02,200 --> 00:22:06,760
the same name know if you move to Scala

00:22:05,560 --> 00:22:09,100
GS

00:22:06,760 --> 00:22:10,570
I think hume told me that they did a lot

00:22:09,100 --> 00:22:14,980
of work to bring the same cemetery

00:22:10,570 --> 00:22:18,130
of the jvm to scholar Jes and they got

00:22:14,980 --> 00:22:19,600
it what you it works extremely well we

00:22:18,130 --> 00:22:22,480
are going to see later what's the

00:22:19,600 --> 00:22:24,490
performance profile and they speak about

00:22:22,480 --> 00:22:26,799
the semantics over there we was really

00:22:24,490 --> 00:22:29,350
little and then Schuyler native is

00:22:26,799 --> 00:22:31,509
adding on the primitive types just the

00:22:29,350 --> 00:22:33,250
inside integral Long's and so on but

00:22:31,509 --> 00:22:36,490
that's who interoperate with saccade

00:22:33,250 --> 00:22:38,889
which as the unsigned integer types know

00:22:36,490 --> 00:22:40,750
what the spire does spy actually brings

00:22:38,889 --> 00:22:43,419
the same kind of unsigned integer types

00:22:40,750 --> 00:22:45,639
but using any value so it's it has this

00:22:43,419 --> 00:22:49,000
real performance profile that if you use

00:22:45,639 --> 00:22:50,799
it in a non-generic card it's as good as

00:22:49,000 --> 00:22:53,409
a primitive type but as soon as it's

00:22:50,799 --> 00:22:57,490
generic or you put it in in your

00:22:53,409 --> 00:23:00,309
collection it's going to box and spire

00:22:57,490 --> 00:23:01,600
gives you a lot of types that I mean if

00:23:00,309 --> 00:23:03,159
you need them you know what to find them

00:23:01,600 --> 00:23:06,009
like portion on number algebraic and so

00:23:03,159 --> 00:23:10,779
on and the quality of those is very good

00:23:06,009 --> 00:23:12,669
inspire took so here in my slide I have

00:23:10,779 --> 00:23:16,659
a few references on what I just like

00:23:12,669 --> 00:23:18,100
touched all you can be bitten by

00:23:16,659 --> 00:23:21,220
floating-point arithmetic there is a

00:23:18,100 --> 00:23:23,980
really great paper that tells you but I

00:23:21,220 --> 00:23:25,450
sometimes madam equivalent mathematical

00:23:23,980 --> 00:23:27,610
expression are not equivalent when you

00:23:25,450 --> 00:23:29,080
when you compute so sometime you need to

00:23:27,610 --> 00:23:33,159
wiggle things around to get what you

00:23:29,080 --> 00:23:34,120
want it's a very nice paper and somebody

00:23:33,159 --> 00:23:36,570
has complained about a call

00:23:34,120 --> 00:23:39,190
floating-point semantics were

00:23:36,570 --> 00:23:41,289
constructed for the JVM if you're really

00:23:39,190 --> 00:23:42,720
interested into the internals of the JVM

00:23:41,289 --> 00:23:46,149
and like the trade off in the design

00:23:42,720 --> 00:23:48,909
that's a great resource if you want to

00:23:46,149 --> 00:23:51,309
learn like use the library the spell

00:23:48,909 --> 00:23:53,440
library he lives on the type level it's

00:23:51,309 --> 00:23:56,169
a huge thing if you want to see like oh

00:23:53,440 --> 00:23:58,179
it works I've extracted like around two

00:23:56,169 --> 00:24:00,279
thousand lines of code from that library

00:23:58,179 --> 00:24:02,139
so it's something can read in an

00:24:00,279 --> 00:24:04,809
afternoon it's called mini spiral it's

00:24:02,139 --> 00:24:06,730
over there I don't have the slides

00:24:04,809 --> 00:24:07,330
online yet I'm probably going to tweet

00:24:06,730 --> 00:24:09,220
them later

00:24:07,330 --> 00:24:13,179
today just take a picture of that screen

00:24:09,220 --> 00:24:16,600
if you need and I'm going to move to the

00:24:13,179 --> 00:24:18,820
second topic second topic is API and

00:24:16,600 --> 00:24:22,990
laws for that I'm not going to have side

00:24:18,820 --> 00:24:24,400
I'm going to look at the code and we are

00:24:22,990 --> 00:24:33,130
going going directly in the code

00:24:24,400 --> 00:24:35,710
of spiah Duke okay watch my stuff about

00:24:33,130 --> 00:24:42,100
the pain and I can probably Mouse here

00:24:35,710 --> 00:24:44,410
excellent so here I have the mini

00:24:42,100 --> 00:24:48,850
inspire projects and we are going to dig

00:24:44,410 --> 00:24:51,610
into the core and we have he extracted

00:24:48,850 --> 00:24:55,930
like the interesting stuff from spire

00:24:51,610 --> 00:24:58,090
and we have for example egg egg is to

00:24:55,930 --> 00:25:00,220
test for quality so anytime you have a

00:24:58,090 --> 00:25:01,990
method that's as a generic type and that

00:25:00,220 --> 00:25:04,180
mental needs to know to compare things

00:25:01,990 --> 00:25:06,880
for quality you're going to provide that

00:25:04,180 --> 00:25:08,440
an insane of that type class just one

00:25:06,880 --> 00:25:11,920
question who is familiar with type

00:25:08,440 --> 00:25:14,980
classes here we use cats so it's kind of

00:25:11,920 --> 00:25:16,630
help the room as an approximation you

00:25:14,980 --> 00:25:19,180
can think of a type class as kind of a

00:25:16,630 --> 00:25:21,730
list of methods that apply to a

00:25:19,180 --> 00:25:24,340
particular type it looks pretty much

00:25:21,730 --> 00:25:26,290
like Java as something called comparator

00:25:24,340 --> 00:25:28,510
something like don't run out the name

00:25:26,290 --> 00:25:30,850
for Java but you you're going to provide

00:25:28,510 --> 00:25:33,550
a function to your sorting routine or to

00:25:30,850 --> 00:25:35,490
see the syllable result as you pass a

00:25:33,550 --> 00:25:37,690
parameter is a function that takes two

00:25:35,490 --> 00:25:40,030
element of your type and returns whether

00:25:37,690 --> 00:25:41,860
they're all they compare so that's

00:25:40,030 --> 00:25:44,950
exactly the same thing or do you compare

00:25:41,860 --> 00:25:48,010
x and y of type a return true if they

00:25:44,950 --> 00:25:50,200
are equivalent but ech does something on

00:25:48,010 --> 00:25:53,410
top of just providing your a dictionary

00:25:50,200 --> 00:25:55,710
of methods there is this sentence here X

00:25:53,410 --> 00:25:58,300
should form an equivalence relation

00:25:55,710 --> 00:26:00,790
equivalence relation means if X is

00:25:58,300 --> 00:26:04,540
equivalent to Y and wising well one to Z

00:26:00,790 --> 00:26:07,680
then X is equivalent to Z so things will

00:26:04,540 --> 00:26:12,640
form a chain and now we can move to

00:26:07,680 --> 00:26:15,250
something more complex it's going to be

00:26:12,640 --> 00:26:16,780
order it's it's when you you can compare

00:26:15,250 --> 00:26:20,920
things with like less than or greater

00:26:16,780 --> 00:26:24,060
than so this this is going to be X is

00:26:20,920 --> 00:26:26,110
less like well than Y and now if you

00:26:24,060 --> 00:26:28,510
although is really the thing you want if

00:26:26,110 --> 00:26:31,030
you want to sort sequence for example

00:26:28,510 --> 00:26:33,640
and any sorting algorithm that you're

00:26:31,030 --> 00:26:36,790
going to call will walk only because

00:26:33,640 --> 00:26:37,740
other is sound and although it sound if

00:26:36,790 --> 00:26:40,160
you have a few low

00:26:37,740 --> 00:26:43,050
that are respected so the thing is

00:26:40,160 --> 00:26:44,670
numbers should always compare like x and

00:26:43,050 --> 00:26:47,820
y you always have a relation that one is

00:26:44,670 --> 00:26:50,520
greater than the other the second thing

00:26:47,820 --> 00:26:50,820
is if you have a chain if it goes both

00:26:50,520 --> 00:26:54,300
ways

00:26:50,820 --> 00:26:56,730
X is less than Y and the reverse then

00:26:54,300 --> 00:26:59,190
they actually equal so now it's going to

00:26:56,730 --> 00:27:00,990
relate a comparison with like the

00:26:59,190 --> 00:27:02,670
Equality that we have seen before and

00:27:00,990 --> 00:27:05,780
the other thing is if X is less than Y

00:27:02,670 --> 00:27:10,460
and Y is less than X then it basically

00:27:05,780 --> 00:27:12,570
transmitter transmits the dot relation

00:27:10,460 --> 00:27:16,860
and you have like the description of

00:27:12,570 --> 00:27:19,350
everything here what if you use Piatt we

00:27:16,860 --> 00:27:23,190
are going to give you that type class so

00:27:19,350 --> 00:27:25,440
although the order type class for types

00:27:23,190 --> 00:27:27,920
in the Scala libraries for example there

00:27:25,440 --> 00:27:31,200
is something what happens for integrals

00:27:27,920 --> 00:27:33,990
comparison of integrals so everything is

00:27:31,200 --> 00:27:36,140
over there equality we basically use

00:27:33,990 --> 00:27:39,480
this knowledge of a thing

00:27:36,140 --> 00:27:42,090
that's not stuff on int and this compare

00:27:39,480 --> 00:27:45,270
method written either minus 1 0 plus 1

00:27:42,090 --> 00:27:49,200
like the compare to in in Java it's

00:27:45,270 --> 00:27:51,000
implemented over there and on the

00:27:49,200 --> 00:27:54,450
consumer side so that's that's all you

00:27:51,000 --> 00:27:58,170
define your structure but no spy also

00:27:54,450 --> 00:28:00,660
sorting algorithm so that stuff over

00:27:58,170 --> 00:28:02,820
there is an insertion sort we also a

00:28:00,660 --> 00:28:06,390
fast assault quicksort deserves own

00:28:02,820 --> 00:28:08,100
merge sort in that stable in inspire you

00:28:06,390 --> 00:28:10,280
take an array of type a you are like

00:28:08,100 --> 00:28:13,679
starting in a start and an end point

00:28:10,280 --> 00:28:15,120
you're going to say ok if I want to move

00:28:13,679 --> 00:28:16,890
things around and compare things in that

00:28:15,120 --> 00:28:20,040
array first of all I need to deal with

00:28:16,890 --> 00:28:21,720
array so that's class tag everything we

00:28:20,040 --> 00:28:26,010
have to deal with that encoding on the

00:28:21,720 --> 00:28:29,870
JVM and we need to compare elements and

00:28:26,010 --> 00:28:29,870
we are going to compare elements here

00:28:30,290 --> 00:28:38,640
data it's sort of type A and item here

00:28:34,230 --> 00:28:39,929
as well but no we use that operator and

00:28:38,640 --> 00:28:42,660
something magic is coming it's coming

00:28:39,929 --> 00:28:44,760
here spyin knows that when you use that

00:28:42,660 --> 00:28:48,140
operator and you have a type class order

00:28:44,760 --> 00:28:50,880
in scope there is an extension method

00:28:48,140 --> 00:28:51,240
Martin on the opening keynote spoke

00:28:50,880 --> 00:28:53,460
about

00:28:51,240 --> 00:28:56,309
extension method and delegates that's

00:28:53,460 --> 00:28:57,960
basically that mechanism for that you

00:28:56,309 --> 00:29:00,870
just need to import the valence attacks

00:28:57,960 --> 00:29:04,230
from aspire and you can work with the

00:29:00,870 --> 00:29:06,480
usual operators greater than plus and so

00:29:04,230 --> 00:29:08,490
on and the magic will happen like spire

00:29:06,480 --> 00:29:12,029
is going to use the type class instead

00:29:08,490 --> 00:29:15,390
of the either for comparison on integral

00:29:12,029 --> 00:29:17,279
long or called the method so that that

00:29:15,390 --> 00:29:26,130
enables that the January city in the

00:29:17,279 --> 00:29:28,020
code there is another took the last

00:29:26,130 --> 00:29:30,870
thing so here I don't know if it's

00:29:28,020 --> 00:29:32,700
actually relevant for you use cases you

00:29:30,870 --> 00:29:35,490
probably are using libraries that you

00:29:32,700 --> 00:29:37,620
know do sorting binary search in arrays

00:29:35,490 --> 00:29:39,210
but once that problem is solved you

00:29:37,620 --> 00:29:41,760
don't need to basically write code that

00:29:39,210 --> 00:29:43,740
does that at the end of the presentation

00:29:41,760 --> 00:29:47,190
I'm going to ask you like are you

00:29:43,740 --> 00:29:50,340
actually writing code that's where you

00:29:47,190 --> 00:29:52,409
can shift the number type at when you

00:29:50,340 --> 00:29:54,750
use it like is it something relevant to

00:29:52,409 --> 00:29:56,370
you I'm writing general code and at the

00:29:54,750 --> 00:29:59,880
last possible minute I decide if I use

00:29:56,370 --> 00:30:01,470
float double big decimal that's what spy

00:29:59,880 --> 00:30:04,200
enabled but I don't know what I want it

00:30:01,470 --> 00:30:06,870
is to the bigger community that's coming

00:30:04,200 --> 00:30:09,450
later the other thing that's very cool

00:30:06,870 --> 00:30:13,169
is that anytime you write your own

00:30:09,450 --> 00:30:16,049
number type so something I did here it

00:30:13,169 --> 00:30:18,020
was format stuff I implemented exact

00:30:16,049 --> 00:30:20,190
number that called cyclotomic numbers

00:30:18,020 --> 00:30:23,039
they're basically fraction but then you

00:30:20,190 --> 00:30:25,260
can use like cosign and signs of

00:30:23,039 --> 00:30:27,299
rational numbers and it's very useful

00:30:25,260 --> 00:30:29,490
for for for group CEO in Matz

00:30:27,299 --> 00:30:31,190
okay I wrote these numbers you can do

00:30:29,490 --> 00:30:33,659
square which with them it's pretty cool

00:30:31,190 --> 00:30:34,980
but I need to test that they they walk

00:30:33,659 --> 00:30:37,529
well so I have this continuous

00:30:34,980 --> 00:30:39,419
integration over there and I want to

00:30:37,529 --> 00:30:41,399
test like all the laws that we know in

00:30:39,419 --> 00:30:43,100
maths should all phone numbers so I have

00:30:41,399 --> 00:30:45,570
like those hundred and something tests

00:30:43,100 --> 00:30:48,360
but actually what I brought in my own

00:30:45,570 --> 00:30:50,760
card is this but is 200 tests they come

00:30:48,360 --> 00:30:51,480
from that I'm seeing implemented that

00:30:50,760 --> 00:30:53,669
number type

00:30:51,480 --> 00:30:56,309
cycle Atomics check that it's a field

00:30:53,669 --> 00:30:57,270
check that it behaves well on the

00:30:56,309 --> 00:31:00,149
conjugation

00:30:57,270 --> 00:31:02,399
I'll check that it's ordered check that

00:31:00,149 --> 00:31:04,560
it behaves well like the addition in the

00:31:02,399 --> 00:31:06,450
order like translation works well

00:31:04,560 --> 00:31:08,580
I'll just buy those five lines and I get

00:31:06,450 --> 00:31:10,590
to test for free I think this is where

00:31:08,580 --> 00:31:12,630
the Calico system is moving a little bit

00:31:10,590 --> 00:31:14,760
with cats but anytime you implement

00:31:12,630 --> 00:31:16,680
something you try not to write thousand

00:31:14,760 --> 00:31:18,570
of unit tests if you have some

00:31:16,680 --> 00:31:21,510
structures you can explode them and do

00:31:18,570 --> 00:31:22,980
something like that quickly so I'll say

00:31:21,510 --> 00:31:25,170
this is the second advantage of using

00:31:22,980 --> 00:31:29,940
the machine we have spire that you get

00:31:25,170 --> 00:31:32,280
that robustness I don't have done any

00:31:29,940 --> 00:31:34,680
question I win super fast like just to

00:31:32,280 --> 00:31:36,150
say what I'll show you there we use like

00:31:34,680 --> 00:31:39,870
the whole morning at the scallop spread

00:31:36,150 --> 00:31:41,310
who you know look at oh it works this

00:31:39,870 --> 00:31:43,650
like a burning question and we'll answer

00:31:41,310 --> 00:31:46,530
it right now otherwise on the last slide

00:31:43,650 --> 00:31:47,910
the people of this free accepted that

00:31:46,530 --> 00:31:49,860
they put the Twitter handle or email

00:31:47,910 --> 00:31:51,510
addresses on the slide they are the

00:31:49,860 --> 00:31:54,150
conference so you can talk to them and

00:31:51,510 --> 00:31:56,100
you know email me email them to you know

00:31:54,150 --> 00:31:58,290
dig a bit more like outside that session

00:31:56,100 --> 00:31:59,570
but if there is like a question I'm glad

00:31:58,290 --> 00:32:02,370
to answer it right now

00:31:59,570 --> 00:32:06,900
otherwise we just move to to the next

00:32:02,370 --> 00:32:12,810
exciting topics let me check my plan I

00:32:06,900 --> 00:32:15,080
still have we've done that I'm not going

00:32:12,810 --> 00:32:18,570
to see what's the precision story the OI

00:32:15,080 --> 00:32:21,920
performance story so not moving to the

00:32:18,570 --> 00:32:24,870
nice fractal that we've seen before and

00:32:21,920 --> 00:32:27,840
we are going to see what's the the

00:32:24,870 --> 00:32:29,730
project this is public so what I did I

00:32:27,840 --> 00:32:31,680
put all the computation related to the

00:32:29,730 --> 00:32:34,650
Mandelbrot fractal in a shared

00:32:31,680 --> 00:32:37,860
repository and I have three back ends

00:32:34,650 --> 00:32:39,330
one for gs-14 JVM in one for native that

00:32:37,860 --> 00:32:42,240
basically shows a window and then you

00:32:39,330 --> 00:32:43,950
can drag things around so I can look at

00:32:42,240 --> 00:32:46,170
the performance of all these types on

00:32:43,950 --> 00:32:47,670
these three platforms but first we're

00:32:46,170 --> 00:32:52,320
going to look at all this computational

00:32:47,670 --> 00:32:55,710
run so I'm going to share the Bing Bing

00:32:52,320 --> 00:32:57,450
Bing Bing so basically what I have I

00:32:55,710 --> 00:32:59,610
have a Mondale broad try it's very

00:32:57,450 --> 00:33:01,560
generic it takes a

00:32:59,610 --> 00:33:04,170
abstraction that tells me how to push

00:33:01,560 --> 00:33:05,820
pixels to an image and like what's the

00:33:04,170 --> 00:33:08,550
current view point in the fractal well

00:33:05,820 --> 00:33:11,820
what did i zoom and I've to

00:33:08,550 --> 00:33:13,590
implementation of that thing two of them

00:33:11,820 --> 00:33:15,570
are specialized like the way you would

00:33:13,590 --> 00:33:17,700
write code in in any problem in language

00:33:15,570 --> 00:33:18,750
you pick the type you're using and then

00:33:17,700 --> 00:33:21,270
you write everything with

00:33:18,750 --> 00:33:22,950
that so I'm going to look at float and

00:33:21,270 --> 00:33:25,380
then we are going to see that the bar is

00:33:22,950 --> 00:33:27,960
basically cut and paste and fine and

00:33:25,380 --> 00:33:31,010
replace so the main thing is that

00:33:27,960 --> 00:33:34,170
iteration function I'm basically taking

00:33:31,010 --> 00:33:36,840
position in the in the plane and there

00:33:34,170 --> 00:33:39,510
is like the rule of old way iterate that

00:33:36,840 --> 00:33:41,460
number until it escapes that's the story

00:33:39,510 --> 00:33:44,370
of the Mandelbrot set I check if it

00:33:41,460 --> 00:33:48,210
escaped that while loop or not and if it

00:33:44,370 --> 00:33:52,560
escaped then I plot how many iteration

00:33:48,210 --> 00:33:54,540
did I need to escape that the set all I

00:33:52,560 --> 00:33:58,830
just loop and I have a cut off like this

00:33:54,540 --> 00:34:01,020
max iterations really pretty pretty

00:33:58,830 --> 00:34:04,500
standard arithmetic but know what I did

00:34:01,020 --> 00:34:07,950
was to say my coordinates are floats so

00:34:04,500 --> 00:34:10,649
if I need to change the number to get a

00:34:07,950 --> 00:34:12,120
bit more precision I'm going to do a

00:34:10,649 --> 00:34:13,889
search and replace input double and

00:34:12,120 --> 00:34:16,379
maybe later put big decimal or something

00:34:13,889 --> 00:34:18,810
else so all of this is pretty pretty

00:34:16,379 --> 00:34:22,889
boring and you can introduce bugs so the

00:34:18,810 --> 00:34:27,290
other way is to use generic code and as

00:34:22,889 --> 00:34:31,409
you can look it looks pretty similar I

00:34:27,290 --> 00:34:32,700
just did something for optimization if I

00:34:31,409 --> 00:34:34,110
need to compute why something is better

00:34:32,700 --> 00:34:37,710
just to add it so I define a function

00:34:34,110 --> 00:34:40,080
that's twice does just a plus a but the

00:34:37,710 --> 00:34:44,070
code looks exactly the same except this

00:34:40,080 --> 00:34:46,440
is generate now and instead of not

00:34:44,070 --> 00:34:50,190
having a type parameter on my class know

00:34:46,440 --> 00:34:52,500
I can decide that I'm going to choose

00:34:50,190 --> 00:34:55,710
that nano type when I instantiate that

00:34:52,500 --> 00:34:58,110
class so a type a and the current thing

00:34:55,710 --> 00:35:00,420
field in order means I need what that

00:34:58,110 --> 00:35:02,460
type this implicit in scope to be able

00:35:00,420 --> 00:35:04,740
to run that because those implicit are

00:35:02,460 --> 00:35:06,930
going to give me the multiplication the

00:35:04,740 --> 00:35:10,280
comparison operator and so on that's the

00:35:06,930 --> 00:35:13,590
mechanism we have seen before

00:35:10,280 --> 00:35:15,450
I'm not going to dig into that but if

00:35:13,590 --> 00:35:19,230
you that a notation called specialized

00:35:15,450 --> 00:35:22,290
what happens with Scala is that you can

00:35:19,230 --> 00:35:23,670
have generic and performant code when

00:35:22,290 --> 00:35:25,530
you compile something with float and

00:35:23,670 --> 00:35:28,080
double is going to quit just for you a

00:35:25,530 --> 00:35:31,260
special version that use primitive times

00:35:28,080 --> 00:35:32,490
on the Java machine so what what I'm

00:35:31,260 --> 00:35:37,020
going to do now for the path

00:35:32,490 --> 00:35:40,950
one story is to run the the code that we

00:35:37,020 --> 00:35:42,930
have seen four times one the float

00:35:40,950 --> 00:35:45,150
implementation wants the double

00:35:42,930 --> 00:35:47,910
implementation and then the generic

00:35:45,150 --> 00:35:49,830
implementation that uses spire and float

00:35:47,910 --> 00:35:52,080
and double but a bit and basically

00:35:49,830 --> 00:35:54,480
choosing that when anything sheds

00:35:52,080 --> 00:35:58,130
instantiates the same so if I look at

00:35:54,480 --> 00:35:58,130
the let's say scale effects back-end

00:36:00,230 --> 00:36:07,500
over there I basically have my

00:36:05,270 --> 00:36:10,860
congressional engine here it's in a

00:36:07,500 --> 00:36:14,490
vowel so I can switch it it starts with

00:36:10,860 --> 00:36:16,619
the generic double but when I press one

00:36:14,490 --> 00:36:18,360
of the digits here I'm just going to

00:36:16,619 --> 00:36:21,210
switch it it of an instance of float

00:36:18,360 --> 00:36:22,770
double or the generic that node takes a

00:36:21,210 --> 00:36:24,900
float parameter generic that takes of

00:36:22,770 --> 00:36:27,300
the ball parameter and I make the

00:36:24,900 --> 00:36:29,730
decision of which one to use when I when

00:36:27,300 --> 00:36:30,540
I create an instance of that class so

00:36:29,730 --> 00:36:34,140
let's see how it goes for the

00:36:30,540 --> 00:36:40,320
performance of that so I'm switching to

00:36:34,140 --> 00:36:43,710
the JVM projects running it so right now

00:36:40,320 --> 00:36:46,710
I'm using float when the card is

00:36:43,710 --> 00:36:49,980
specialized I specialized by hand I'm a

00:36:46,710 --> 00:36:51,869
14.5 frame per second if I switch to

00:36:49,980 --> 00:36:54,060
double which doubles the precision you

00:36:51,869 --> 00:36:56,790
see that the basically the speed is

00:36:54,060 --> 00:36:59,400
exactly the same because the CPU is

00:36:56,790 --> 00:37:00,900
using exactly the same path to compute

00:36:59,400 --> 00:37:03,900
with single precision or double

00:37:00,900 --> 00:37:05,880
precision double uses twice the memory

00:37:03,900 --> 00:37:07,859
so if you have big arrays that may be a

00:37:05,880 --> 00:37:10,890
decision you're going to make I want to

00:37:07,859 --> 00:37:12,720
cut memory using half or if you want

00:37:10,890 --> 00:37:14,550
things on the GPU that may be a choice

00:37:12,720 --> 00:37:16,830
that GPU will be faster for single

00:37:14,550 --> 00:37:18,869
precision but if you just run this on

00:37:16,830 --> 00:37:21,660
JVM the story small s and you don't use

00:37:18,869 --> 00:37:23,040
memory then the story is the same no

00:37:21,660 --> 00:37:25,530
what's really cool is that

00:37:23,040 --> 00:37:28,140
if you switch between generic code

00:37:25,530 --> 00:37:30,990
that's specialized when you when you

00:37:28,140 --> 00:37:34,260
call it or code that you specialized by

00:37:30,990 --> 00:37:36,980
hand basically you don't see any

00:37:34,260 --> 00:37:40,650
difference so spire has all these crazy

00:37:36,980 --> 00:37:42,810
magic to enable you to write generic

00:37:40,650 --> 00:37:45,310
code you can write a some function on

00:37:42,810 --> 00:37:46,570
any array type

00:37:45,310 --> 00:37:48,820
and the performance is going to be the

00:37:46,570 --> 00:37:51,430
same what are you specialized by hand or

00:37:48,820 --> 00:37:53,580
you use the special mechanism I think

00:37:51,430 --> 00:37:55,600
that's a great achievement of style I

00:37:53,580 --> 00:37:58,500
don't want to get like your expectation

00:37:55,600 --> 00:38:06,100
too high because if I know switch to

00:37:58,500 --> 00:38:08,260
JavaScript so the same story same same

00:38:06,100 --> 00:38:10,150
code on the on the computational side

00:38:08,260 --> 00:38:12,340
but the graphic back-end is different of

00:38:10,150 --> 00:38:16,720
course and you have the frame per second

00:38:12,340 --> 00:38:18,130
in the little side over there a tongue

00:38:16,720 --> 00:38:19,720
thing is very readable for you on that

00:38:18,130 --> 00:38:21,520
screen but it's basically four point

00:38:19,720 --> 00:38:23,110
five so what it means if you have

00:38:21,520 --> 00:38:25,480
numerical code that runs at some speed

00:38:23,110 --> 00:38:28,420
on the JVM on the modern JavaScript

00:38:25,480 --> 00:38:29,560
engine is going to be super fast I think

00:38:28,420 --> 00:38:33,160
that's a great achievement of the

00:38:29,560 --> 00:38:37,780
scholar Jes team but one thing that

00:38:33,160 --> 00:38:40,660
actually walks less well on scale is if

00:38:37,780 --> 00:38:45,310
I switch so that's two specialized code

00:38:40,660 --> 00:38:49,330
by hand and I go now to the generic the

00:38:45,310 --> 00:38:51,940
ball I lose I don't think you can read

00:38:49,330 --> 00:38:53,550
that number well take the core are very

00:38:51,940 --> 00:38:56,580
different can you see that number here

00:38:53,550 --> 00:38:59,980
okay so I'm going to tell you what it is

00:38:56,580 --> 00:39:02,910
on the specialist pass 4.5 frame per

00:38:59,980 --> 00:39:10,150
seconds I moved to genomic the ball no

00:39:02,910 --> 00:39:12,550
oh I think my in JavaScript JIT kicked

00:39:10,150 --> 00:39:15,580
in it's one now actually there is no

00:39:12,550 --> 00:39:18,490
difference no not so much when it's one

00:39:15,580 --> 00:39:23,530
that's pretty cool but now if I do the

00:39:18,490 --> 00:39:29,370
last thing and I go to major and I run

00:39:23,530 --> 00:39:29,370
it so I got a surprise doing that

00:39:31,410 --> 00:39:37,110
maybe I should remove the debug mode

00:39:33,700 --> 00:39:37,110
that's maybe the problem

00:39:40,620 --> 00:39:46,290
so with the default options it give me

00:39:44,580 --> 00:39:49,140
giving me help the performance of the

00:39:46,290 --> 00:39:54,630
JVM and I see a difference between using

00:39:49,140 --> 00:39:55,560
generic path I reduce the performance so

00:39:54,630 --> 00:39:57,720
this is something I need to investigate

00:39:55,560 --> 00:39:59,550
like I just got the scale a native

00:39:57,720 --> 00:40:01,830
running this week I don't know what the

00:39:59,550 --> 00:40:04,320
performance course story is going to be

00:40:01,830 --> 00:40:06,150
for that but if we see the

00:40:04,320 --> 00:40:08,400
specialization is not working for native

00:40:06,150 --> 00:40:11,160
maybe we need to rethink the way we we

00:40:08,400 --> 00:40:15,450
provide the mechanism I'm not really

00:40:11,160 --> 00:40:17,010
close to finishing the talk yeah I

00:40:15,450 --> 00:40:19,110
wanted to speak about loss that's going

00:40:17,010 --> 00:40:22,680
to be like I did that on the card I'm

00:40:19,110 --> 00:40:25,560
going to skip how much time remains like

00:40:22,680 --> 00:40:28,140
three minutes and we usually finish on

00:40:25,560 --> 00:40:30,420
time right so let's do this now you have

00:40:28,140 --> 00:40:32,130
a few questions for you first question

00:40:30,420 --> 00:40:36,600
who has used generic programming do you

00:40:32,130 --> 00:40:42,750
use sex or by sex some ordering of

00:40:36,600 --> 00:40:45,900
numeric which is that okay who has used

00:40:42,750 --> 00:40:50,070
float and double in their code okay

00:40:45,900 --> 00:40:54,150
let's use big int okay cool where's use

00:40:50,070 --> 00:41:00,930
big decimal nice I've used other types

00:40:54,150 --> 00:41:02,520
for numbers and oh ho can you just tell

00:41:00,930 --> 00:41:04,760
me what those number type we're like

00:41:02,520 --> 00:41:10,200
just shout we don't think we need

00:41:04,760 --> 00:41:12,360
Washington from spire okay and in Scala

00:41:10,200 --> 00:41:15,720
like other types in Scala is it like the

00:41:12,360 --> 00:41:17,130
same story oh okay so I'm going to

00:41:15,720 --> 00:41:19,050
change my questions out on the screen

00:41:17,130 --> 00:41:20,940
would you like like did you know that

00:41:19,050 --> 00:41:23,070
rationale was available for Scala or

00:41:20,940 --> 00:41:25,560
things like that would that be useful

00:41:23,070 --> 00:41:28,050
for you like I just want to like get a

00:41:25,560 --> 00:41:30,600
feeling maybe it's not that important

00:41:28,050 --> 00:41:32,310
you know like and I know I need to know

00:41:30,600 --> 00:41:35,400
where we take spire-like us as an

00:41:32,310 --> 00:41:39,420
ecosystem will you about spider before

00:41:35,400 --> 00:41:43,770
coming to the talk okay and are you

00:41:39,420 --> 00:41:46,620
using it with using it in projects with

00:41:43,770 --> 00:41:47,830
you using it in production god that's

00:41:46,620 --> 00:41:52,380
scary

00:41:47,830 --> 00:41:53,830
okay we need to talk we need to talk

00:41:52,380 --> 00:41:55,780
[Music]

00:41:53,830 --> 00:41:56,980
like that's doing the most important

00:41:55,780 --> 00:41:59,380
message I still have two minutes for

00:41:56,980 --> 00:42:02,260
that what I want to say is aspire is a

00:41:59,380 --> 00:42:03,730
very precise call like the all algebraic

00:42:02,260 --> 00:42:04,900
operation and structure like the type of

00:42:03,730 --> 00:42:07,150
classes it's beautiful

00:42:04,900 --> 00:42:08,680
maybe it's too precise we basically we

00:42:07,150 --> 00:42:10,420
have things like non commutative

00:42:08,680 --> 00:42:12,760
additive semigroups

00:42:10,420 --> 00:42:14,380
I've never seen even in abstract math

00:42:12,760 --> 00:42:17,860
I've never seen that true so maybe we

00:42:14,380 --> 00:42:20,140
need to drop it but that's basically API

00:42:17,860 --> 00:42:22,540
design and I'm not going to be the only

00:42:20,140 --> 00:42:23,980
person having an input there we have

00:42:22,540 --> 00:42:26,200
external normal types like algebraic

00:42:23,980 --> 00:42:28,480
it's it's crazy card I don't understand

00:42:26,200 --> 00:42:31,120
that card but I have exercises for many

00:42:28,480 --> 00:42:34,690
angles it never broke so that that's

00:42:31,120 --> 00:42:36,790
pretty cool the rest of the code the

00:42:34,690 --> 00:42:39,460
quality varies we have a run like 50%

00:42:36,790 --> 00:42:42,550
code coverage cut is a nearly a hundred

00:42:39,460 --> 00:42:45,220
percent 50% we don't have any excuses

00:42:42,550 --> 00:42:46,900
because we basically have everything as

00:42:45,220 --> 00:42:49,960
a type class everything can be checked

00:42:46,900 --> 00:42:54,340
we should get this at least two to 75 or

00:42:49,960 --> 00:42:56,170
80% the other problem is that Spyro

00:42:54,340 --> 00:42:58,090
became kind of the you know magnet for

00:42:56,170 --> 00:43:00,550
everything related to numeric so a lot

00:42:58,090 --> 00:43:03,670
of people contributed the pet class or

00:43:00,550 --> 00:43:07,270
pets feature and now it's very difficult

00:43:03,670 --> 00:43:08,950
to see like we didn't can you tell us

00:43:07,270 --> 00:43:10,690
about like what what what what the

00:43:08,950 --> 00:43:12,640
design consideration because we need to

00:43:10,690 --> 00:43:16,120
put it and we don't know exactly what it

00:43:12,640 --> 00:43:19,540
does so that's a problem now that code

00:43:16,120 --> 00:43:21,430
quality is over the place sparrows has

00:43:19,540 --> 00:43:25,570
really clever performance ax use macros

00:43:21,430 --> 00:43:27,640
all the time and on Monday the the

00:43:25,570 --> 00:43:29,440
discuss with people on a compiler team

00:43:27,640 --> 00:43:31,830
and they said for the tea tree we are

00:43:29,440 --> 00:43:34,210
considering dropping specialization and

00:43:31,830 --> 00:43:36,100
that's basically the whole spy of

00:43:34,210 --> 00:43:38,890
stories what do we do with that to say

00:43:36,100 --> 00:43:41,050
look we have in line we are staging so

00:43:38,890 --> 00:43:43,510
we are going to change the mechanism

00:43:41,050 --> 00:43:46,270
that spy uses but that means maybe that

00:43:43,510 --> 00:43:48,580
we are not going to port 50,000 lines of

00:43:46,270 --> 00:43:51,880
code to a completely new mechanism so we

00:43:48,580 --> 00:43:54,190
we need to decide like what to do the

00:43:51,880 --> 00:43:55,570
other problem is that spy is big like

00:43:54,190 --> 00:43:58,270
the best factor right now is like one

00:43:55,570 --> 00:44:01,430
point five last is helping a lot with

00:43:58,270 --> 00:44:04,190
like managing general stuff but

00:44:01,430 --> 00:44:07,460
think he used the code base in the

00:44:04,190 --> 00:44:08,569
internals a lot and I'm I basically

00:44:07,460 --> 00:44:11,180
don't understand some parts but

00:44:08,569 --> 00:44:14,569
understand the rest and then both of us

00:44:11,180 --> 00:44:16,069
are active so it's kind of scary to say

00:44:14,569 --> 00:44:18,099
like you guys are using that in

00:44:16,069 --> 00:44:21,410
production and I don't know you know

00:44:18,099 --> 00:44:23,180
what's going to happen with it so I

00:44:21,410 --> 00:44:26,119
would say it's okay just project elf and

00:44:23,180 --> 00:44:28,809
community goes so on on Tuesday we had

00:44:26,119 --> 00:44:31,160
the scallops pre we use mini spire

00:44:28,809 --> 00:44:33,650
previous cosplay I use the big spider

00:44:31,160 --> 00:44:35,210
and when I use mini spider to you know

00:44:33,650 --> 00:44:36,619
on board people they said oh it's very

00:44:35,210 --> 00:44:38,780
nice I want to contribute I want to do

00:44:36,619 --> 00:44:41,380
more things so that's okay maybe we

00:44:38,780 --> 00:44:45,109
should have something that's way more

00:44:41,380 --> 00:44:47,119
accessible for people to contribute so

00:44:45,109 --> 00:44:50,240
the idea right now is this but I just

00:44:47,119 --> 00:44:52,640
got this idea during the week so I

00:44:50,240 --> 00:44:54,619
really need your input and your feedback

00:44:52,640 --> 00:44:56,750
on that we want to identify core

00:44:54,619 --> 00:45:00,260
features and for each of those feature

00:44:56,750 --> 00:45:02,660
of a clear migration story reboot the

00:45:00,260 --> 00:45:04,640
project so for a long time there was

00:45:02,660 --> 00:45:06,619
this Scalzi project with a lot of symbol

00:45:04,640 --> 00:45:09,380
comparators and a community culture that

00:45:06,619 --> 00:45:12,349
was maybe not maybe maybe not beginner

00:45:09,380 --> 00:45:15,500
friendly and cuts started like having

00:45:12,349 --> 00:45:18,589
good documentation trying to involve

00:45:15,500 --> 00:45:20,599
beginners and I think we can do the same

00:45:18,589 --> 00:45:23,030
for spire like we did the project and

00:45:20,599 --> 00:45:25,369
provide a better contributor experience

00:45:23,030 --> 00:45:28,010
and I would say we only add features to

00:45:25,369 --> 00:45:30,319
that reboots when there is community

00:45:28,010 --> 00:45:32,299
attraction not because it's nice to have

00:45:30,319 --> 00:45:34,490
some abstract mathematical type but

00:45:32,299 --> 00:45:37,130
because people will be using it in an

00:45:34,490 --> 00:45:38,839
awfully in production the last thing I

00:45:37,130 --> 00:45:40,599
want to say that people on the scale

00:45:38,839 --> 00:45:43,130
Esprit said okay to share the

00:45:40,599 --> 00:45:45,740
communication details so I put like the

00:45:43,130 --> 00:45:48,260
name of people who look like all day and

00:45:45,740 --> 00:45:50,510
at spire internals so they will be able

00:45:48,260 --> 00:45:52,160
to look at the code with you and tell

00:45:50,510 --> 00:45:54,799
you a few things and I'm here doing

00:45:52,160 --> 00:45:58,040
until Friday Friday afternoon to to

00:45:54,799 --> 00:45:59,839
interact with you as well I think that's

00:45:58,040 --> 00:46:04,970
the end of my talk that's the end of my

00:45:59,839 --> 00:46:07,099
time I like to thank you but we should

00:46:04,970 --> 00:46:09,260
still get some time for like your

00:46:07,099 --> 00:46:11,270
feedback and your question you can go

00:46:09,260 --> 00:46:13,010
and like the talk is finished but I'd

00:46:11,270 --> 00:46:14,770
really like that people were interested

00:46:13,010 --> 00:46:16,090
in that story to stay and

00:46:14,770 --> 00:46:18,490
you know like tell me what you like

00:46:16,090 --> 00:46:22,380
about it or where you should when you

00:46:18,490 --> 00:46:22,380
want to see this going so thank you so

00:46:27,660 --> 00:46:38,500
Mike's and so on I don't know it works

00:46:31,590 --> 00:46:40,990
the finite fields inspire I think we

00:46:38,500 --> 00:46:43,870
have like it's at least in the tests

00:46:40,990 --> 00:46:46,750
like there's a class but know that we

00:46:43,870 --> 00:46:50,110
have singleton types in Scala 2.13 which

00:46:46,750 --> 00:46:52,150
would like put the we have a much better

00:46:50,110 --> 00:46:52,840
story for finite field and that's that's

00:46:52,150 --> 00:46:55,000
a possibility

00:46:52,840 --> 00:46:57,100
and another thing that interests me you

00:46:55,000 --> 00:46:59,830
have like complex types like polynomials

00:46:57,100 --> 00:47:02,860
intervals and complex numbers for

00:46:59,830 --> 00:47:04,690
example and in principle you can compose

00:47:02,860 --> 00:47:07,510
complex number of two rational numbers

00:47:04,690 --> 00:47:10,630
or two big decimals or two floats over

00:47:07,510 --> 00:47:13,000
yeah do you do that yes absolutely and

00:47:10,630 --> 00:47:14,620
and mova if you do complex number of

00:47:13,000 --> 00:47:16,900
integrals it's something called Gaussian

00:47:14,620 --> 00:47:18,970
integrals you don't get the division but

00:47:16,900 --> 00:47:21,070
if you do complex number of floats you

00:47:18,970 --> 00:47:23,290
get the division so spires was the

00:47:21,070 --> 00:47:27,990
efficient mechanism that it gives you as

00:47:23,290 --> 00:47:27,990
much structure as your Scala type gives

00:47:34,680 --> 00:47:41,860
such a good visualization of those

00:47:36,970 --> 00:47:44,610
things maybe you asked what could we do

00:47:41,860 --> 00:47:47,770
inspire different I think there is core

00:47:44,610 --> 00:47:50,920
mathematics in it and some like we I'm

00:47:47,770 --> 00:47:53,080
using in production interval try okay

00:47:50,920 --> 00:47:57,690
and it's more because of those ranges

00:47:53,080 --> 00:48:02,500
and sort of more business more of

00:47:57,690 --> 00:48:04,450
business appealing some core mathematics

00:48:02,500 --> 00:48:06,190
so I think a good separation of those

00:48:04,450 --> 00:48:12,870
things what is really really core and

00:48:06,190 --> 00:48:14,980
what could be leveraging more okay okay

00:48:12,870 --> 00:48:16,470
I'd love that we stay in touch like

00:48:14,980 --> 00:48:19,510
everybody was a business case for

00:48:16,470 --> 00:48:21,370
computing with numbers I'd love to hear

00:48:19,510 --> 00:48:23,350
your story enough that's as like a basis

00:48:21,370 --> 00:48:24,790
for the next API so please like send me

00:48:23,350 --> 00:48:27,070
an email or direct message on Twitter

00:48:24,790 --> 00:48:27,900
like no and then I'll collect those

00:48:27,070 --> 00:48:29,789
names

00:48:27,900 --> 00:48:31,470
we'll see work or we build a community

00:48:29,789 --> 00:48:33,180
of like you know kind of a focus group

00:48:31,470 --> 00:48:44,880
for for what we do next

00:48:33,180 --> 00:48:45,710
thanks for your input yeah I have two

00:48:44,880 --> 00:48:49,529
questions

00:48:45,710 --> 00:48:52,049
first yeah first I mean you focus on the

00:48:49,529 --> 00:48:54,480
performance quite a lot and I noticed

00:48:52,049 --> 00:48:56,099
that you like using the syntax does it

00:48:54,480 --> 00:48:57,569
affect performance because of the extra

00:48:56,099 --> 00:48:59,520
locations because you need like kind of

00:48:57,569 --> 00:49:04,289
you know to create an ops class and then

00:48:59,520 --> 00:49:05,700
like no in the performance good remark

00:49:04,289 --> 00:49:07,319
so normally when you have those

00:49:05,700 --> 00:49:09,480
enrichment metals you can you can have

00:49:07,319 --> 00:49:12,119
an eval or things like that and then

00:49:09,480 --> 00:49:13,680
you're going to call type class a method

00:49:12,119 --> 00:49:16,349
of that type class so there are few

00:49:13,680 --> 00:49:19,799
levels of indirection spiral uses macro

00:49:16,349 --> 00:49:21,270
to remove extra layers but you're still

00:49:19,799 --> 00:49:23,130
going to have an indirection that

00:49:21,270 --> 00:49:25,440
instead of example comparing flows

00:49:23,130 --> 00:49:27,510
directly you call a method that compares

00:49:25,440 --> 00:49:29,190
floats what we've seen on the

00:49:27,510 --> 00:49:32,220
performance of visualizations that the

00:49:29,190 --> 00:49:34,109
JVM is clever enough to inline that but

00:49:32,220 --> 00:49:36,510
so maybe the native background doesn't

00:49:34,109 --> 00:49:38,640
know at runtime like where this come

00:49:36,510 --> 00:49:41,670
from and is not able to do that in

00:49:38,640 --> 00:49:44,279
lining so that's that's the story and I

00:49:41,670 --> 00:49:46,140
did not choose growl VM but I'd love to

00:49:44,279 --> 00:49:47,400
see what it does because maybe it

00:49:46,140 --> 00:49:49,279
doesn't have enough information at

00:49:47,400 --> 00:49:52,500
compile time to do this in lining

00:49:49,279 --> 00:49:55,559
maybe we can provide better hints I have

00:49:52,500 --> 00:49:57,779
no idea but that's kind of a space that

00:49:55,559 --> 00:49:59,130
opens now like until recently one me at

00:49:57,779 --> 00:50:02,010
the JVM but no we have like other

00:49:59,130 --> 00:50:03,210
platforms and but on the JVM we do the

00:50:02,010 --> 00:50:11,400
right thing like white now we do the

00:50:03,210 --> 00:50:12,280
right thing other questions

00:50:11,400 --> 00:50:16,379
yeah

00:50:12,280 --> 00:50:16,379

YouTube URL: https://www.youtube.com/watch?v=S3WMJZrgsP4


