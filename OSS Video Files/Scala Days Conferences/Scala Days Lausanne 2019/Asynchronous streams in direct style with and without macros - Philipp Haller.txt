Title: Asynchronous streams in direct style with and without macros - Philipp Haller
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/asynchronous-streams-in-direct-style-with-and-without-macros
Captions: 
	00:00:00,030 --> 00:00:06,960
okay welcome to my talk I'm gonna talk

00:00:04,500 --> 00:00:13,019
about asynchronous streams in direct

00:00:06,960 --> 00:00:16,350
style with and without macros and so I'm

00:00:13,019 --> 00:00:21,990
an associate professor at kth in

00:00:16,350 --> 00:00:23,910
Stockholm and before going to academia I

00:00:21,990 --> 00:00:27,029
actually worked at typesafe which is now

00:00:23,910 --> 00:00:31,019
light Bend and I actually did my PhD

00:00:27,029 --> 00:00:37,290
here at EPFL so it's nice to be nice to

00:00:31,019 --> 00:00:38,610
be back so let's introduce today's topic

00:00:37,290 --> 00:00:42,270
with a simple task

00:00:38,610 --> 00:00:45,270
okay so we're given an asynchronous

00:00:42,270 --> 00:00:49,320
method that returns the day of the year

00:00:45,270 --> 00:00:52,079
as a string wrapped in a future right so

00:00:49,320 --> 00:00:56,579
day of year returns a future string and

00:00:52,079 --> 00:01:00,960
it can return strings you know like 0 4

00:00:56,579 --> 00:01:06,299
/ 11 for April 11 and and so on

00:01:00,960 --> 00:01:08,970
and now sometimes this method can return

00:01:06,299 --> 00:01:11,640
can complete the future with an empty

00:01:08,970 --> 00:01:16,170
string or was now or nope

00:01:11,640 --> 00:01:19,580
and what we should do is now it should

00:01:16,170 --> 00:01:23,340
create a future that's completed either

00:01:19,580 --> 00:01:29,790
with the string it's months like it's

00:01:23,340 --> 00:01:32,729
April or whatever where we turn the

00:01:29,790 --> 00:01:36,000
number into a textual representation or

00:01:32,729 --> 00:01:40,530
it should are completed with not a date

00:01:36,000 --> 00:01:44,399
mate okay so that's shouldn't be too

00:01:40,530 --> 00:01:47,490
difficult also we're in the expert track

00:01:44,399 --> 00:01:49,560
so I'm sure you can come up with a

00:01:47,490 --> 00:01:53,460
program that does that so we can for

00:01:49,560 --> 00:01:57,240
example use futures and for

00:01:53,460 --> 00:02:00,000
comprehensions to to do that first we

00:01:57,240 --> 00:02:04,020
should actually define our reg X here

00:02:00,000 --> 00:02:04,829
and actually I think Greg's are quite

00:02:04,020 --> 00:02:07,770
nice in Scala

00:02:04,829 --> 00:02:09,989
so they're actually nicely integrated

00:02:07,770 --> 00:02:11,940
with extractors so if you haven't used

00:02:09,989 --> 00:02:13,800
them before give it a try and actually

00:02:11,940 --> 00:02:17,790
as a side note since we're at EP

00:02:13,800 --> 00:02:20,880
fell the directs support in the standard

00:02:17,790 --> 00:02:23,370
library actually originated as a student

00:02:20,880 --> 00:02:27,740
project that I supervised the DP FL a

00:02:23,370 --> 00:02:31,560
long time ago so timeframe 2007 or so

00:02:27,740 --> 00:02:34,950
but so basically we have our reg X here

00:02:31,560 --> 00:02:38,970
and well now we're just go ahead and say

00:02:34,950 --> 00:02:40,890
well when day of air completes when that

00:02:38,970 --> 00:02:44,670
future is completed we have add a string

00:02:40,890 --> 00:02:49,440
and we can match on that string against

00:02:44,670 --> 00:02:50,880
our reg ex extract the month and what I

00:02:49,440 --> 00:02:52,860
didn't mention before is the other

00:02:50,880 --> 00:02:54,600
constraint is we need to use the name of

00:02:52,860 --> 00:02:57,360
months and that's another method that

00:02:54,600 --> 00:02:59,670
returns the future okay like imagine

00:02:57,360 --> 00:03:01,800
you're composing you know more complex

00:02:59,670 --> 00:03:03,900
things and you have you know you call

00:03:01,800 --> 00:03:06,510
into services and then whatnot so then

00:03:03,900 --> 00:03:07,890
you know futures are really everywhere

00:03:06,510 --> 00:03:10,320
so that's what we're trying to simulate

00:03:07,890 --> 00:03:14,670
so name of month returns a future as

00:03:10,320 --> 00:03:18,510
well and so that means since we need

00:03:14,670 --> 00:03:21,180
that result as well we construct another

00:03:18,510 --> 00:03:23,390
future that using another for

00:03:21,180 --> 00:03:27,600
comprehension a nested for comprehension

00:03:23,390 --> 00:03:31,280
and which you know reels or results in

00:03:27,600 --> 00:03:35,010
the future completed with the it's

00:03:31,280 --> 00:03:37,200
whatever the name is otherwise if the

00:03:35,010 --> 00:03:39,600
string doesn't match our reg X we can

00:03:37,200 --> 00:03:44,640
create a future that's already are

00:03:39,600 --> 00:03:44,940
completed yeah so that's how we can do

00:03:44,640 --> 00:03:48,930
it

00:03:44,940 --> 00:03:51,510
it takes a while to explain that so the

00:03:48,930 --> 00:03:54,680
question is can we improve readability a

00:03:51,510 --> 00:03:58,140
little bit and of course the answer is

00:03:54,680 --> 00:04:02,390
we can and so this is one of the

00:03:58,140 --> 00:04:06,000
examples actually that we used before to

00:04:02,390 --> 00:04:10,530
introduce Scala async so as Connor icing

00:04:06,000 --> 00:04:13,200
is essentially designed to simplify

00:04:10,530 --> 00:04:15,600
asynchronous programming primarily based

00:04:13,200 --> 00:04:17,910
on futures although you know there was

00:04:15,600 --> 00:04:19,890
some some work and some ideas on how to

00:04:17,910 --> 00:04:22,289
how to make it more general but in

00:04:19,890 --> 00:04:26,910
practice people use it pretty much only

00:04:22,289 --> 00:04:27,710
with futures Scala async was created by

00:04:26,910 --> 00:04:31,340
Jay

00:04:27,710 --> 00:04:36,199
Zog from light bend and myself and we

00:04:31,340 --> 00:04:42,530
really sat in first in 2013 and it's

00:04:36,199 --> 00:04:46,070
actually a fairly popular project so it

00:04:42,530 --> 00:04:51,970
is used also by the way who of you has

00:04:46,070 --> 00:04:56,110
used it before some some people not not

00:04:51,970 --> 00:04:58,669
not everyone but we can we can use it to

00:04:56,110 --> 00:05:01,610
simplify things a little bit so we can

00:04:58,669 --> 00:05:04,460
say well what we need to do is we need

00:05:01,610 --> 00:05:07,190
to create a future so let's just create

00:05:04,460 --> 00:05:10,639
an async block and within the async

00:05:07,190 --> 00:05:14,060
block we can compute the result right

00:05:10,639 --> 00:05:16,580
and so it's similar to the future apply

00:05:14,060 --> 00:05:19,970
method right we can just sort of provide

00:05:16,580 --> 00:05:21,770
a body that computes the result and so

00:05:19,970 --> 00:05:24,740
all right we do the same thing we did

00:05:21,770 --> 00:05:28,130
before with our EDX except that now

00:05:24,740 --> 00:05:32,539
since we need the day of year the result

00:05:28,130 --> 00:05:35,150
of that future we call a weight and what

00:05:32,539 --> 00:05:38,300
a weight does is it first checks if the

00:05:35,150 --> 00:05:41,960
future is completed if it is we can

00:05:38,300 --> 00:05:46,250
actually continue with our code if it's

00:05:41,960 --> 00:05:49,280
if day of year is not completed yet the

00:05:46,250 --> 00:05:53,810
async block is the body of the aging

00:05:49,280 --> 00:05:56,360
clock is suspended so that the the

00:05:53,810 --> 00:05:58,729
underlying thread which is normally a

00:05:56,360 --> 00:06:00,740
worker thread of a thread pool that was

00:05:58,729 --> 00:06:03,320
executing the async block that the body

00:06:00,740 --> 00:06:06,560
of the agent block that thread now is

00:06:03,320 --> 00:06:08,630
freed again to execute other tasks and

00:06:06,560 --> 00:06:10,039
tasks that it should execute right it's

00:06:08,630 --> 00:06:12,590
a full thread so it should really

00:06:10,039 --> 00:06:14,930
process all the tasks in the pool and so

00:06:12,590 --> 00:06:18,440
that's what a away does it frees up the

00:06:14,930 --> 00:06:22,310
thread and but it stores the it stores

00:06:18,440 --> 00:06:24,590
the execution state of this async block

00:06:22,310 --> 00:06:28,520
so that later on we can actually resume

00:06:24,590 --> 00:06:31,419
the async block exactly from that place

00:06:28,520 --> 00:06:33,860
from the point where we called await

00:06:31,419 --> 00:06:36,680
right and so this is what happens when

00:06:33,860 --> 00:06:38,659
the day of year future is completed so a

00:06:36,680 --> 00:06:41,689
weight also registers a completion

00:06:38,659 --> 00:06:45,139
handler which

00:06:41,689 --> 00:06:48,800
when the completion handler runs then

00:06:45,139 --> 00:06:51,729
essentially we take the result of the

00:06:48,800 --> 00:06:55,400
future of the day of year future and

00:06:51,729 --> 00:06:57,909
logically we replace the await call with

00:06:55,400 --> 00:07:00,949
that result and resume the execution

00:06:57,909 --> 00:07:05,210
right so we resume here and do the match

00:07:00,949 --> 00:07:07,969
on the result right and so this is this

00:07:05,210 --> 00:07:11,300
is what a weight does and so we can

00:07:07,969 --> 00:07:14,900
really use a weight as a straightforward

00:07:11,300 --> 00:07:16,550
way to just you know suspend until we

00:07:14,900 --> 00:07:20,509
have the result and we don't have to

00:07:16,550 --> 00:07:23,150
worry about the underlying thread being

00:07:20,509 --> 00:07:25,900
pinned because of that right it's not

00:07:23,150 --> 00:07:32,719
happening so it's very friendly method

00:07:25,900 --> 00:07:34,129
to use all right and so also I think

00:07:32,719 --> 00:07:35,719
what's interesting to point out in

00:07:34,129 --> 00:07:37,939
comparison to the previous solution

00:07:35,719 --> 00:07:40,250
there's some interesting differences so

00:07:37,939 --> 00:07:43,219
for example we don't have to name all

00:07:40,250 --> 00:07:45,889
the intermediate results okay we all

00:07:43,219 --> 00:07:47,419
know naming is hard so if you're forced

00:07:45,889 --> 00:07:50,750
to come up with names all the time

00:07:47,419 --> 00:07:53,629
that's not ideal right especially if it

00:07:50,750 --> 00:07:55,250
doesn't improve readability so here for

00:07:53,629 --> 00:07:57,529
example we had to come up with a name

00:07:55,250 --> 00:07:59,659
for that result you know we had to come

00:07:57,529 --> 00:08:00,889
up with a name for the response and we

00:07:59,659 --> 00:08:03,020
have to come up with a name for this

00:08:00,889 --> 00:08:04,879
name here and you know we end up with

00:08:03,020 --> 00:08:07,729
these generic names that don't really

00:08:04,879 --> 00:08:10,129
help readability at all so like if we

00:08:07,729 --> 00:08:12,800
can avoid that that's good so this is

00:08:10,129 --> 00:08:15,500
one advantage of course we are free to

00:08:12,800 --> 00:08:18,339
introduce names as much as we want but

00:08:15,500 --> 00:08:21,289
at least we're not forced to do that

00:08:18,339 --> 00:08:25,219
also we don't need to explicitly

00:08:21,289 --> 00:08:26,449
construct completed futures okay and and

00:08:25,219 --> 00:08:29,150
I think this is actually important

00:08:26,449 --> 00:08:32,000
because it's the fact that we have to do

00:08:29,150 --> 00:08:34,070
this in a previous solution tells you

00:08:32,000 --> 00:08:36,229
that you know the fact that there's an

00:08:34,070 --> 00:08:39,769
flat map underneath actually kind of

00:08:36,229 --> 00:08:41,120
leaks to the surface right it's fine if

00:08:39,769 --> 00:08:43,579
you know that you know we're actually

00:08:41,120 --> 00:08:46,310
doing flat map and you know how to write

00:08:43,579 --> 00:08:48,800
the code explicitly using flat map

00:08:46,310 --> 00:08:53,180
that's good but it's certainly doesn't

00:08:48,800 --> 00:08:53,990
help clarity also as interesting is that

00:08:53,180 --> 00:08:56,810
the async

00:08:53,990 --> 00:08:59,930
actually allocates fewer closers right

00:08:56,810 --> 00:09:02,750
so one async block is exactly one

00:08:59,930 --> 00:09:05,960
closure right so if you if you go back

00:09:02,750 --> 00:09:09,080
to the for comprehension code since the

00:09:05,960 --> 00:09:13,250
D Sugar's to map and flatmap calls we

00:09:09,080 --> 00:09:15,470
allocate more closures right each for

00:09:13,250 --> 00:09:19,630
each called map or flat map we have

00:09:15,470 --> 00:09:22,850
another new closure that's allocated and

00:09:19,630 --> 00:09:26,150
that's a performance seat but also if we

00:09:22,850 --> 00:09:28,760
pass values into and out of closures

00:09:26,150 --> 00:09:30,800
there's a lot of boxing going on often

00:09:28,760 --> 00:09:32,840
so we can even avoid some of this boxing

00:09:30,800 --> 00:09:36,470
if you just make sure we just have one

00:09:32,840 --> 00:09:38,150
closure and you know all the you know

00:09:36,470 --> 00:09:40,400
all the shuffling of results and so on

00:09:38,150 --> 00:09:41,840
it happens internally so there's even it

00:09:40,400 --> 00:09:47,420
can even be a performance improvement

00:09:41,840 --> 00:09:49,220
here so it's actually rather nice but

00:09:47,420 --> 00:09:51,710
let's do something more complex so that

00:09:49,220 --> 00:09:54,710
we test the limits here a little bit and

00:09:51,710 --> 00:09:56,900
so how about we instead of converting a

00:09:54,710 --> 00:10:01,100
single string we need to consume a

00:09:56,900 --> 00:10:03,380
stream of multiple strings and also the

00:10:01,100 --> 00:10:07,370
output of our solution should actually

00:10:03,380 --> 00:10:10,490
be a publisher that that produces

00:10:07,370 --> 00:10:12,740
multiple results so it's not enough to

00:10:10,490 --> 00:10:16,010
just return a future that eventually is

00:10:12,740 --> 00:10:20,120
completed and so if you talk about

00:10:16,010 --> 00:10:23,750
streams we should talk about reactive

00:10:20,120 --> 00:10:28,070
streams or as they're also known as

00:10:23,750 --> 00:10:31,520
which is Java util concurrent flow all

00:10:28,070 --> 00:10:35,540
right so since steady Kanine you know

00:10:31,520 --> 00:10:39,440
these interfaces actually are now in

00:10:35,540 --> 00:10:44,720
this flow class and so it's a set of a

00:10:39,440 --> 00:10:47,030
small set of interfaces very few of them

00:10:44,720 --> 00:10:48,620
the processor is not even essential so

00:10:47,030 --> 00:10:54,290
we're actually talking about like three

00:10:48,620 --> 00:10:56,240
interfaces and they so what do they do

00:10:54,290 --> 00:11:00,470
well I mean they they allow you to

00:10:56,240 --> 00:11:03,080
construct asynchronous streams right so

00:11:00,470 --> 00:11:06,770
producers like publishers that publish

00:11:03,080 --> 00:11:07,529
events asynchronously and subscribers

00:11:06,770 --> 00:11:09,439
that can

00:11:07,529 --> 00:11:12,810
scribe to publishers to receive events

00:11:09,439 --> 00:11:14,370
asynchronously and the subscription is

00:11:12,810 --> 00:11:17,790
also actually quite important because

00:11:14,370 --> 00:11:21,569
it's allows subscribers to control the

00:11:17,790 --> 00:11:25,139
flow of the events and now this work

00:11:21,569 --> 00:11:26,699
didn't happen in a vacuum there was

00:11:25,139 --> 00:11:28,259
actually some key prior work and I think

00:11:26,699 --> 00:11:30,180
we should probably start by mentioning

00:11:28,259 --> 00:11:31,949
the observer design pattern it's a

00:11:30,180 --> 00:11:36,809
classic Gang of Four pattern right where

00:11:31,949 --> 00:11:39,689
you have an observer and sorry a subject

00:11:36,809 --> 00:11:44,009
a subject and observers and when the

00:11:39,689 --> 00:11:48,649
subject changes its state say we can

00:11:44,009 --> 00:11:53,730
have zero or more observers modified and

00:11:48,649 --> 00:11:55,439
and probably the most important probably

00:11:53,730 --> 00:11:58,529
work here is actually the the work on

00:11:55,439 --> 00:12:00,720
reactive extensions by Eric Meyer where

00:11:58,529 --> 00:12:03,720
he essentially put the asynchronous

00:12:00,720 --> 00:12:07,170
streams on a solid foundation right by

00:12:03,720 --> 00:12:09,329
saying well what is actually an

00:12:07,170 --> 00:12:11,939
observable of T like what does it mean

00:12:09,329 --> 00:12:15,870
in relation to other types that we know

00:12:11,939 --> 00:12:20,600
like iterables for example right and and

00:12:15,870 --> 00:12:23,300
where he basically said well let's use

00:12:20,600 --> 00:12:28,199
functional programming concepts to

00:12:23,300 --> 00:12:30,000
provide ways to compose observables so

00:12:28,199 --> 00:12:32,370
observable and publisher I'm gonna use

00:12:30,000 --> 00:12:36,750
those interchangeably quite often here

00:12:32,370 --> 00:12:39,660
so bear with me but so how to compose

00:12:36,750 --> 00:12:43,290
observables using higher-order functions

00:12:39,660 --> 00:12:44,550
right and and that's been really

00:12:43,290 --> 00:12:46,649
successful right with many

00:12:44,550 --> 00:12:49,889
implementations for various languages

00:12:46,649 --> 00:12:51,720
and and so on and and then I think like

00:12:49,889 --> 00:12:55,920
the key innovation of reactive streams

00:12:51,720 --> 00:12:59,670
then is to have back pressure control

00:12:55,920 --> 00:13:02,100
right so that the subscribers are not

00:12:59,670 --> 00:13:05,129
just flooded with events from publishers

00:13:02,100 --> 00:13:06,959
but they can actually tell via the

00:13:05,129 --> 00:13:09,720
subscription object you can tell the

00:13:06,959 --> 00:13:13,709
publisher to say well I'm only I only

00:13:09,720 --> 00:13:16,230
want to receive at most 512 events or

00:13:13,709 --> 00:13:19,310
whatever right and sort of adjusts the

00:13:16,230 --> 00:13:21,110
the flow of against that way

00:13:19,310 --> 00:13:23,690
so just to bring everyone on the same

00:13:21,110 --> 00:13:26,510
page here's a quick run through these

00:13:23,690 --> 00:13:29,360
interfaces so publisher is very simple

00:13:26,510 --> 00:13:31,460
and I'm gonna use the JDK 9 once because

00:13:29,360 --> 00:13:35,170
those are the that this is what

00:13:31,460 --> 00:13:39,200
everyone's gonna migrate to anyways so

00:13:35,170 --> 00:13:42,890
the publisher has a subscribed method

00:13:39,200 --> 00:13:46,160
that takes a subscriber and the

00:13:42,890 --> 00:13:48,370
subscriber needs to be able to receive

00:13:46,160 --> 00:13:52,010
events of type T because publisher

00:13:48,370 --> 00:13:54,950
publishes the events of type T alright

00:13:52,010 --> 00:13:56,779
and then the subscriber is essentially

00:13:54,950 --> 00:13:59,960
the interface that the publisher uses to

00:13:56,779 --> 00:14:02,050
publish events to the each subscriber so

00:13:59,960 --> 00:14:05,089
it has methods for each kind of event

00:14:02,050 --> 00:14:07,400
the first event actually happens when

00:14:05,089 --> 00:14:10,160
there's subscription from a subscriber

00:14:07,400 --> 00:14:13,610
right so when a subscriber subscribes to

00:14:10,160 --> 00:14:15,380
a publisher the publisher like in a

00:14:13,610 --> 00:14:17,750
successful case you know creates a

00:14:15,380 --> 00:14:21,020
subscription object and calls the on

00:14:17,750 --> 00:14:23,540
subscribe method so that from then on

00:14:21,020 --> 00:14:28,220
the subscriber can use that subscription

00:14:23,540 --> 00:14:32,450
object to control things and then

00:14:28,220 --> 00:14:36,140
following that if the subscriber has

00:14:32,450 --> 00:14:38,480
expressed interest that needs to be the

00:14:36,140 --> 00:14:41,030
case right then the publisher can

00:14:38,480 --> 00:14:42,680
publish events and publish them to use

00:14:41,030 --> 00:14:44,900
of drivers using those methods so if

00:14:42,680 --> 00:14:48,230
there's a next event of type T we call

00:14:44,900 --> 00:14:51,530
our next on each subscriber if there's

00:14:48,230 --> 00:14:54,830
an error if the publisher terminates

00:14:51,530 --> 00:14:58,070
with an error we the subscribers need to

00:14:54,830 --> 00:14:59,810
be notified of that as well and the

00:14:58,070 --> 00:15:03,760
subscribers are also notified if the

00:14:59,810 --> 00:15:06,670
publisher terminates terminates normally

00:15:03,760 --> 00:15:09,020
okay and then finally the subscription

00:15:06,670 --> 00:15:11,900
interface that I mentioned right where

00:15:09,020 --> 00:15:15,380
these which has message that should only

00:15:11,900 --> 00:15:19,610
be called by by subscribers and they can

00:15:15,380 --> 00:15:22,390
request a number of items from the

00:15:19,610 --> 00:15:26,240
publisher right they can say I request

00:15:22,390 --> 00:15:29,000
256 items and and then the publisher

00:15:26,240 --> 00:15:31,540
needs to adhere to the contract which

00:15:29,000 --> 00:15:33,300
says well you cannot omit more than that

00:15:31,540 --> 00:15:35,490
more than those events

00:15:33,300 --> 00:15:39,750
to the subscriber and of course we can

00:15:35,490 --> 00:15:41,459
cancel the subscription as well good so

00:15:39,750 --> 00:15:44,580
now these are sort of the base

00:15:41,459 --> 00:15:47,130
interfaces here and they are of course

00:15:44,580 --> 00:15:50,279
rather low-level so normally how people

00:15:47,130 --> 00:15:51,990
use these things is they build they use

00:15:50,279 --> 00:15:55,459
libraries that build on top of these

00:15:51,990 --> 00:15:57,570
interfaces and one important such

00:15:55,459 --> 00:15:59,760
framework is the this reactive

00:15:57,570 --> 00:16:01,110
extensions framework right so if you you

00:15:59,760 --> 00:16:04,170
should know about that one

00:16:01,110 --> 00:16:08,040
if you if you know about streams right

00:16:04,170 --> 00:16:09,769
so it's some the key is that we that we

00:16:08,040 --> 00:16:13,459
have a library that provides

00:16:09,769 --> 00:16:17,760
higher-order functions to compose

00:16:13,459 --> 00:16:20,910
publishers and I just wanted to give you

00:16:17,760 --> 00:16:23,070
a very short example which is actually

00:16:20,910 --> 00:16:25,920
taken from the original article by Eric

00:16:23,070 --> 00:16:27,779
Meyer on reactive on on reactive

00:16:25,920 --> 00:16:32,820
extensions and so this is written in C

00:16:27,779 --> 00:16:35,220
sharp but the idea is that we have we

00:16:32,820 --> 00:16:39,930
provide methods that construct

00:16:35,220 --> 00:16:41,910
publishers or subscribers right and we

00:16:39,930 --> 00:16:45,660
can put and have higher of Combinator's

00:16:41,910 --> 00:16:48,839
so for example text changes here is a

00:16:45,660 --> 00:16:52,110
method that creates a publisher that

00:16:48,839 --> 00:16:55,740
publishes in an event for each each time

00:16:52,110 --> 00:16:58,709
the text in an input field changes right

00:16:55,740 --> 00:17:00,779
so each time I type in the in an input

00:16:58,709 --> 00:17:02,850
field I make a change there is a new

00:17:00,779 --> 00:17:06,510
event published with with the current

00:17:02,850 --> 00:17:08,160
contents of the input field and so

00:17:06,510 --> 00:17:12,120
that's the simple publisher of strings

00:17:08,160 --> 00:17:15,870
and on that one I call select and select

00:17:12,120 --> 00:17:17,610
actually would be called map so in in

00:17:15,870 --> 00:17:19,819
our X Java for example it's called map

00:17:17,610 --> 00:17:22,350
right it's called select here because

00:17:19,819 --> 00:17:25,530
because reactive send is integrated with

00:17:22,350 --> 00:17:29,580
link and there the in link the message

00:17:25,530 --> 00:17:32,030
you know map is called select so you can

00:17:29,580 --> 00:17:34,770
use comprehensions for that as well so

00:17:32,030 --> 00:17:37,679
so we call select and what select does

00:17:34,770 --> 00:17:39,900
is it transforms the publisher into or

00:17:37,679 --> 00:17:42,840
in this case and observable transforms

00:17:39,900 --> 00:17:45,480
it to a new observable such that for

00:17:42,840 --> 00:17:47,170
each word it's published by the first

00:17:45,480 --> 00:17:50,890
observable

00:17:47,170 --> 00:17:53,080
we publish a an event which is the

00:17:50,890 --> 00:17:54,910
completions for that word right so

00:17:53,080 --> 00:17:56,590
imagine you have a search engine you

00:17:54,910 --> 00:17:58,540
type a word and then they're a

00:17:56,590 --> 00:18:01,060
synchronously their completions being

00:17:58,540 --> 00:18:02,860
suggested to you right and so that's

00:18:01,060 --> 00:18:08,020
what happens here so that means for each

00:18:02,860 --> 00:18:11,860
event for each word the result of select

00:18:08,020 --> 00:18:14,380
publishes and observable so completions

00:18:11,860 --> 00:18:15,970
actually some observable itself okay so

00:18:14,380 --> 00:18:18,060
there is the result of select is

00:18:15,970 --> 00:18:22,600
actually an observable of observables

00:18:18,060 --> 00:18:27,640
and right but select select itself is

00:18:22,600 --> 00:18:32,530
just map okay and but then we use switch

00:18:27,640 --> 00:18:36,250
which is somewhat more complex right

00:18:32,530 --> 00:18:38,620
where since we have a publisher of or an

00:18:36,250 --> 00:18:40,990
observable of observables what it does

00:18:38,620 --> 00:18:44,200
is it says well when you receive the

00:18:40,990 --> 00:18:46,060
first observable as an event you start

00:18:44,200 --> 00:18:48,250
publishing its events these are the read

00:18:46,060 --> 00:18:49,900
events initially and as soon as you

00:18:48,250 --> 00:18:52,630
received the next observable you publish

00:18:49,900 --> 00:18:55,060
its events so we and then so we switch

00:18:52,630 --> 00:18:56,680
to the yellow observable because that's

00:18:55,060 --> 00:18:58,240
the next observable we have received and

00:18:56,680 --> 00:19:01,450
these are the completions for the

00:18:58,240 --> 00:19:04,170
changed word right so initially we have

00:19:01,450 --> 00:19:07,030
a word in the text box and we have

00:19:04,170 --> 00:19:10,660
completions and then eventually the user

00:19:07,030 --> 00:19:12,580
types something and and then we receive

00:19:10,660 --> 00:19:14,470
an observable for the completions of the

00:19:12,580 --> 00:19:17,410
changed where it says the yellow events

00:19:14,470 --> 00:19:19,030
right and but the user can type again so

00:19:17,410 --> 00:19:20,680
that means we may receive another

00:19:19,030 --> 00:19:22,300
observable for the completions for next

00:19:20,680 --> 00:19:25,000
you end and of course we have to switch

00:19:22,300 --> 00:19:27,880
always to the completions for the latest

00:19:25,000 --> 00:19:29,800
word okay and this is what switch does

00:19:27,880 --> 00:19:35,070
so as you can tell you can actually

00:19:29,800 --> 00:19:37,510
build quite complex combinators here and

00:19:35,070 --> 00:19:42,430
yeah so this is how programs look like

00:19:37,510 --> 00:19:44,890
here and so there are some challenges I

00:19:42,430 --> 00:19:46,690
always leave one is we often need

00:19:44,890 --> 00:19:48,970
diagrams to understand what's going on

00:19:46,690 --> 00:19:50,800
right and so if you read the

00:19:48,970 --> 00:19:52,960
documentation for reactive extensions

00:19:50,800 --> 00:19:56,020
you see a lot of so-called marble

00:19:52,960 --> 00:19:58,960
diagrams which are an evolution of of

00:19:56,020 --> 00:20:00,940
these of these event diagrams right

00:19:58,960 --> 00:20:05,080
they've sort of formalized the way

00:20:00,940 --> 00:20:07,720
to present these things and and in fact

00:20:05,080 --> 00:20:10,390
if you try to create Combinator's these

00:20:07,720 --> 00:20:13,240
higher-order Combinator's like select or

00:20:10,390 --> 00:20:14,860
switch or zip what-have-you

00:20:13,240 --> 00:20:18,160
this can be quite challenging

00:20:14,860 --> 00:20:19,470
particularly if they're stateful and the

00:20:18,160 --> 00:20:21,690
the key here is that actually

00:20:19,470 --> 00:20:25,030
combinators that combine multiple

00:20:21,690 --> 00:20:27,010
observables they're often they are

00:20:25,030 --> 00:20:29,770
stateful internally right even though

00:20:27,010 --> 00:20:33,700
the the statefulness cannot be there's

00:20:29,770 --> 00:20:35,380
no observable state right but internally

00:20:33,700 --> 00:20:38,260
just to implement them they're stateful

00:20:35,380 --> 00:20:42,190
so if you even just implementing zip you

00:20:38,260 --> 00:20:44,050
Scout I have stayed inside ok so and

00:20:42,190 --> 00:20:46,150
that makes it somewhat challenging and

00:20:44,050 --> 00:20:47,680
finally of course we have an inversion

00:20:46,150 --> 00:20:51,190
of control going on which means we're

00:20:47,680 --> 00:20:53,050
actually building programs that like

00:20:51,190 --> 00:20:55,540
they're not running on the current

00:20:53,050 --> 00:20:57,820
thread no I mean we're just building

00:20:55,540 --> 00:20:59,920
computations and they're like submitted

00:20:57,820 --> 00:21:02,050
for execution with by the runtime you

00:20:59,920 --> 00:21:04,690
know using some schedulers and thread

00:21:02,050 --> 00:21:07,300
pools and so on so the code we write is

00:21:04,690 --> 00:21:09,540
of course very different from sequential

00:21:07,300 --> 00:21:11,950
code that runs on the current thread

00:21:09,540 --> 00:21:14,520
there's a very big difference right

00:21:11,950 --> 00:21:16,630
between these two things

00:21:14,520 --> 00:21:18,940
so now let's now that we know about

00:21:16,630 --> 00:21:21,880
streams let's go back to our task at

00:21:18,940 --> 00:21:26,200
hand so we're supposed to convert a

00:21:21,880 --> 00:21:29,110
stream of strings into or we want to

00:21:26,200 --> 00:21:31,660
create a publisher that consumes those

00:21:29,110 --> 00:21:35,410
events and produces a stream of results

00:21:31,660 --> 00:21:38,610
now we want to try and do this like

00:21:35,410 --> 00:21:41,170
without the reactive extensions style

00:21:38,610 --> 00:21:44,680
but instead the question is can we do

00:21:41,170 --> 00:21:46,330
something similar to a sinker weight now

00:21:44,680 --> 00:21:51,400
if we try to do this we run into some

00:21:46,330 --> 00:21:54,700
issues ok first problem is trying to

00:21:51,400 --> 00:21:56,350
await events of publishers is actually

00:21:54,700 --> 00:21:59,320
not really possible because a Weight

00:21:56,350 --> 00:22:03,190
takes futures as arguments so we can't

00:21:59,320 --> 00:22:06,070
wait for the next event of a publisher

00:22:03,190 --> 00:22:11,130
for example so that doesn't work

00:22:06,070 --> 00:22:11,130
also async creates only a future so we

00:22:11,160 --> 00:22:14,470
but we need to create a publisher that

00:22:13,750 --> 00:22:17,380
can yield

00:22:14,470 --> 00:22:21,880
events so that doesn't work

00:22:17,380 --> 00:22:25,330
unfortunately and so this is sort of one

00:22:21,880 --> 00:22:29,110
of the motivations for this proposal

00:22:25,330 --> 00:22:31,120
which I called Scala async flow now here

00:22:29,110 --> 00:22:33,909
which is just saying well can we make

00:22:31,120 --> 00:22:36,760
Scala async a bit more general to

00:22:33,909 --> 00:22:44,590
support streams and so the idea is that

00:22:36,760 --> 00:22:48,700
we extend a single weight such that we

00:22:44,590 --> 00:22:50,770
have a variant of async that can create

00:22:48,700 --> 00:22:54,370
publishers right or it's not enough to

00:22:50,770 --> 00:22:56,320
just create a future and so to

00:22:54,370 --> 00:22:59,830
distinguish that from the previous one

00:22:56,320 --> 00:23:02,620
we call it our async and we also need to

00:22:59,830 --> 00:23:04,590
generalize a weight so we need to be

00:23:02,620 --> 00:23:07,210
able to pass not just a future but

00:23:04,590 --> 00:23:09,750
streams in there so that we can await

00:23:07,210 --> 00:23:13,049
the different stream events also and

00:23:09,750 --> 00:23:16,210
finally we need to be able to yield

00:23:13,049 --> 00:23:19,000
events so we need to be able to yield

00:23:16,210 --> 00:23:22,990
the next event of the publisher may be

00:23:19,000 --> 00:23:27,039
yield an error or yield done to indicate

00:23:22,990 --> 00:23:29,049
that the publisher is has terminated so

00:23:27,039 --> 00:23:30,970
first was their weight it's actually

00:23:29,049 --> 00:23:34,000
quite simple so previously we had a

00:23:30,970 --> 00:23:38,980
weight and we pass in a future of T and

00:23:34,000 --> 00:23:40,720
the result is T so I forgot to put in

00:23:38,980 --> 00:23:44,950
this picture which says I can't believe

00:23:40,720 --> 00:23:47,080
it's not blocking right but um so okay

00:23:44,950 --> 00:23:48,669
but that's fine the thing is we need to

00:23:47,080 --> 00:23:51,490
make this more general right so we need

00:23:48,669 --> 00:23:52,960
to say well this should be difference

00:23:51,490 --> 00:23:54,490
would not just be future so we need some

00:23:52,960 --> 00:23:56,440
kind of an object it's like an async

00:23:54,490 --> 00:24:00,039
object we need the notion of an async

00:23:56,440 --> 00:24:02,380
object and which has a simple interface

00:24:00,039 --> 00:24:04,360
so here I actually named it somehow but

00:24:02,380 --> 00:24:06,400
as it probably is even what be even

00:24:04,360 --> 00:24:09,250
better to have a F this is a structural

00:24:06,400 --> 00:24:11,500
notion to say well it needs to be an

00:24:09,250 --> 00:24:15,039
async object needs to provide these two

00:24:11,500 --> 00:24:19,059
methods right where essentially we can

00:24:15,039 --> 00:24:20,860
query whether it's completed actually I

00:24:19,059 --> 00:24:24,220
think the term completed isn't maybe not

00:24:20,860 --> 00:24:26,830
ideal but because a stream in this case

00:24:24,220 --> 00:24:27,700
would complete many times but we need

00:24:26,830 --> 00:24:29,830
them

00:24:27,700 --> 00:24:31,299
is analogous to future okay that's why

00:24:29,830 --> 00:24:33,880
it's called like that but we need a

00:24:31,299 --> 00:24:37,330
method that says do we have something to

00:24:33,880 --> 00:24:40,779
receive is there an event that we can

00:24:37,330 --> 00:24:44,139
get right now and for a future it's you

00:24:40,779 --> 00:24:46,480
know is the future completed and if so

00:24:44,139 --> 00:24:49,919
please give me the try so failure or

00:24:46,480 --> 00:24:54,220
success right for a stream it would say

00:24:49,919 --> 00:24:58,600
is the next event available yes or no

00:24:54,220 --> 00:25:00,220
right and by the way so if it's if it's

00:24:58,600 --> 00:25:03,100
available we get the try if it's not

00:25:00,220 --> 00:25:07,210
available we get now so it's either now

00:25:03,100 --> 00:25:09,909
or a try and and uncomplete is of course

00:25:07,210 --> 00:25:12,909
analogous to the on complete on futures

00:25:09,909 --> 00:25:17,409
where it takes a handler from try of t2s

00:25:12,909 --> 00:25:19,929
and requires an execution context and

00:25:17,409 --> 00:25:23,260
that's of course used so that we can say

00:25:19,929 --> 00:25:26,830
well we can register a completion

00:25:23,260 --> 00:25:31,210
Handler that runs when the async object

00:25:26,830 --> 00:25:33,309
is completed or when the ace extreme

00:25:31,210 --> 00:25:39,610
publish its next event or when it

00:25:33,309 --> 00:25:41,080
terminates all right now once we've done

00:25:39,610 --> 00:25:45,130
this extension right we can actually

00:25:41,080 --> 00:25:47,919
formulate the solution quite simply by

00:25:45,130 --> 00:25:52,809
saying well let's make use this our

00:25:47,919 --> 00:25:54,159
async to create a publisher of string so

00:25:52,809 --> 00:25:55,870
unfortunately we have to provide a type

00:25:54,159 --> 00:25:58,840
argument here but you know there are

00:25:55,870 --> 00:26:02,710
reasons for that but um okay it's gonna

00:25:58,840 --> 00:26:05,580
be a publisher of string and now we can

00:26:02,710 --> 00:26:08,529
just wait we can call a wait and provide

00:26:05,580 --> 00:26:11,769
the date stream so that's the upstream

00:26:08,529 --> 00:26:13,539
publisher of date strings I don't show

00:26:11,769 --> 00:26:15,840
this I'm showing the date stream but

00:26:13,539 --> 00:26:20,590
it's you know it's just a publisher that

00:26:15,840 --> 00:26:22,779
pushes out date strings and now the the

00:26:20,590 --> 00:26:25,299
result of a wait is an option because

00:26:22,779 --> 00:26:29,950
the stream could be terminated normally

00:26:25,299 --> 00:26:32,830
in which case we get none as a result or

00:26:29,950 --> 00:26:35,769
we could have some of X where X is the

00:26:32,830 --> 00:26:40,030
next event published by the date stream

00:26:35,769 --> 00:26:43,330
and by the way if the date stream

00:26:40,030 --> 00:26:46,470
terminated with an exception then the

00:26:43,330 --> 00:26:49,750
call to a wait throws that exception

00:26:46,470 --> 00:26:52,260
right so it's just like normal what we

00:26:49,750 --> 00:26:56,050
would expect actually for that one right

00:26:52,260 --> 00:26:57,790
and so then we can we can check okay if

00:26:56,050 --> 00:27:01,210
the option is as long as the option is

00:26:57,790 --> 00:27:04,770
non-empty we can access it and match it

00:27:01,210 --> 00:27:11,410
against our reg X and yield yield

00:27:04,770 --> 00:27:11,890
whatever the next event is now what's

00:27:11,410 --> 00:27:13,810
interesting

00:27:11,890 --> 00:27:17,560
sorry about that what's interesting is

00:27:13,810 --> 00:27:21,090
that the inside here we actually call a

00:27:17,560 --> 00:27:22,870
wait with a method that returns a future

00:27:21,090 --> 00:27:24,940
right and this is actually interesting

00:27:22,870 --> 00:27:27,370
why well because here we wait for a

00:27:24,940 --> 00:27:28,930
stream for this is a publisher right

00:27:27,370 --> 00:27:33,820
publisher string and but this is a

00:27:28,930 --> 00:27:36,010
future of string so we need to be able

00:27:33,820 --> 00:27:37,690
to wait for different async objects we

00:27:36,010 --> 00:27:39,280
can't just fix one of them right would

00:27:37,690 --> 00:27:43,320
be too limited if you fix it to

00:27:39,280 --> 00:27:47,110
publisher in this case right so that's

00:27:43,320 --> 00:27:49,030
important and yeah and so then years

00:27:47,110 --> 00:27:52,450
next of course we can call multiple

00:27:49,030 --> 00:27:56,590
times in a loop here right so once we've

00:27:52,450 --> 00:27:58,870
yielded the next event we can go back

00:27:56,590 --> 00:28:00,940
and wait for the next event from the

00:27:58,870 --> 00:28:05,040
stream and as long as that's not empty

00:28:00,940 --> 00:28:05,040
we continue and finally we do yield um

00:28:05,970 --> 00:28:13,930
okay now how can we implement these

00:28:10,390 --> 00:28:15,490
things well there are some alternatives

00:28:13,930 --> 00:28:19,840
right we can either extend the Scala

00:28:15,490 --> 00:28:21,970
async macro that's certainly possible we

00:28:19,840 --> 00:28:26,710
can try to put direct compiler support

00:28:21,970 --> 00:28:29,050
in there and in fact yesterday Adrienne

00:28:26,710 --> 00:28:30,790
Morris told me that there's a branch

00:28:29,050 --> 00:28:34,630
that he created a branch which is does

00:28:30,790 --> 00:28:37,330
that so um at least for the plane a

00:28:34,630 --> 00:28:39,490
single wait so that's possible of course

00:28:37,330 --> 00:28:41,920
and we can build on on top of

00:28:39,490 --> 00:28:44,620
continuations or fibers and that's what

00:28:41,920 --> 00:28:46,750
I'm also going to show here so let's

00:28:44,620 --> 00:28:50,490
start maybe with the interface with the

00:28:46,750 --> 00:28:54,330
API right so our async takes a body and

00:28:50,490 --> 00:28:54,330
now this body of course

00:28:54,490 --> 00:29:01,130
well we should have so the body needs a

00:28:57,440 --> 00:29:07,310
context which we call flow of tea here

00:29:01,130 --> 00:29:10,730
and the context is there because if we

00:29:07,310 --> 00:29:12,830
call a weight inside the erasing block

00:29:10,730 --> 00:29:14,300
well we need to know we need to have you

00:29:12,830 --> 00:29:16,880
need we need to be in the context where

00:29:14,300 --> 00:29:18,590
we can do that right and also if you

00:29:16,880 --> 00:29:20,420
want to yield an event we need to be in

00:29:18,590 --> 00:29:23,120
the context where we can yield the event

00:29:20,420 --> 00:29:26,390
of that of the current publisher and

00:29:23,120 --> 00:29:29,240
that's provided by this context right

00:29:26,390 --> 00:29:33,860
and so we use a contextual function to

00:29:29,240 --> 00:29:38,510
do that and right and the result will be

00:29:33,860 --> 00:29:42,550
a publisher of tea and so then a weight

00:29:38,510 --> 00:29:45,200
here right it'll have this async object

00:29:42,550 --> 00:29:48,110
as an argument and it also needs a

00:29:45,200 --> 00:29:49,910
context both the flow and and it needs

00:29:48,110 --> 00:29:52,310
an execution context as well because

00:29:49,910 --> 00:29:54,170
it'll register a completion Handler and

00:29:52,310 --> 00:29:56,270
for that one we have to say where it

00:29:54,170 --> 00:30:00,860
should run so that's where we need the

00:29:56,270 --> 00:30:05,030
execution context and yield next well

00:30:00,860 --> 00:30:07,640
that's super easy we're we can use it

00:30:05,030 --> 00:30:09,770
inside when when there's the context

00:30:07,640 --> 00:30:12,590
available here and so then we can easily

00:30:09,770 --> 00:30:13,970
just use the next event so it's really

00:30:12,590 --> 00:30:19,190
kind of like the Builder pattern that

00:30:13,970 --> 00:30:21,970
Martin showed in his keynote so now the

00:30:19,190 --> 00:30:25,580
you know the tricky bit okay how do we

00:30:21,970 --> 00:30:27,260
transform this our async block and I'm

00:30:25,580 --> 00:30:30,890
going to show you the probably as simple

00:30:27,260 --> 00:30:32,330
as possible publisher which in the end

00:30:30,890 --> 00:30:35,360
it's it's written in in like

00:30:32,330 --> 00:30:37,280
excruciating detail on purpose okay I've

00:30:35,360 --> 00:30:39,920
used the VAR on purpose I've used the

00:30:37,280 --> 00:30:41,810
type annotation on purpose and so on so

00:30:39,920 --> 00:30:45,590
we're just like just to show well we

00:30:41,810 --> 00:30:47,690
have a local variable X that's reassign

00:30:45,590 --> 00:30:49,340
able right so initially it's numb but

00:30:47,690 --> 00:30:52,610
then later we're going to call a wait

00:30:49,340 --> 00:30:54,800
and assign the result to X and then

00:30:52,610 --> 00:30:57,020
after the await the only thing we do is

00:30:54,800 --> 00:31:00,620
we call get on X right it's like the

00:30:57,020 --> 00:31:03,470
simplest possible thing you can think of

00:31:00,620 --> 00:31:05,170
it's like forwarding one event somehow

00:31:03,470 --> 00:31:06,730
so

00:31:05,170 --> 00:31:08,500
what do we do well we need to be able to

00:31:06,730 --> 00:31:11,830
suspend inside this erasing block right

00:31:08,500 --> 00:31:13,690
so and the the way the Scala async macro

00:31:11,830 --> 00:31:16,510
works and this is very similar to how to

00:31:13,690 --> 00:31:19,870
c-sharp compiler works is it creates a

00:31:16,510 --> 00:31:21,490
state machine where this is a simple

00:31:19,870 --> 00:31:25,930
class and that's essentially our closure

00:31:21,490 --> 00:31:28,240
right it's one class and it has a state

00:31:25,930 --> 00:31:31,740
variable so we number our states because

00:31:28,240 --> 00:31:34,990
we need to transition between states and

00:31:31,740 --> 00:31:36,310
there's a result promise here that's

00:31:34,990 --> 00:31:37,780
actually more like an implementation

00:31:36,310 --> 00:31:42,430
detail but okay

00:31:37,780 --> 00:31:44,140
and now the VAR x option of int this is

00:31:42,430 --> 00:31:46,570
this used to be a local variable now

00:31:44,140 --> 00:31:49,480
it's a field right it has to be a field

00:31:46,570 --> 00:31:52,780
because we're gonna have to be able to

00:31:49,480 --> 00:31:54,880
access it in different states of the

00:31:52,780 --> 00:31:57,730
state machine right so we can't keep it

00:31:54,880 --> 00:32:00,130
as a local variable and so the state

00:31:57,730 --> 00:32:03,490
machine we can start it from the

00:32:00,130 --> 00:32:05,580
beginning from state zero okay and we do

00:32:03,490 --> 00:32:08,020
the for calling apply it takes a try

00:32:05,580 --> 00:32:10,720
usually there's no try to provide so we

00:32:08,020 --> 00:32:12,880
just provide null essentially and we

00:32:10,720 --> 00:32:14,770
start in state zero and what we do is

00:32:12,880 --> 00:32:16,390
well we start the code from the

00:32:14,770 --> 00:32:20,380
beginning what do we do in the beginning

00:32:16,390 --> 00:32:22,240
we assign num to X this is the initial

00:32:20,380 --> 00:32:25,420
code here right this is like the first

00:32:22,240 --> 00:32:28,150
thing we do we assign num to X now you

00:32:25,420 --> 00:32:31,090
see why I have this excruciating detail

00:32:28,150 --> 00:32:34,360
because this is some code we do could be

00:32:31,090 --> 00:32:35,740
more complex right and the next thing we

00:32:34,360 --> 00:32:38,650
do because the next thing we do is

00:32:35,740 --> 00:32:41,500
already calling a weight that's the very

00:32:38,650 --> 00:32:44,290
next thing we do right we call a weight

00:32:41,500 --> 00:32:47,710
so how does that work well S is given

00:32:44,290 --> 00:32:50,500
that's a publisher we somehow need to

00:32:47,710 --> 00:32:52,870
find the corresponding subscription for

00:32:50,500 --> 00:32:55,690
that one but we have a context flow so

00:32:52,870 --> 00:32:57,790
we can look it up in the context and the

00:32:55,690 --> 00:33:00,160
subscription we can check if there is a

00:32:57,790 --> 00:33:04,780
next event there so we call get

00:33:00,160 --> 00:33:07,570
completed if it's now it means there's

00:33:04,780 --> 00:33:10,540
no next event yet so you've got to

00:33:07,570 --> 00:33:11,950
suspend it's the only thing you can do

00:33:10,540 --> 00:33:15,700
is really suspend and register our

00:33:11,950 --> 00:33:17,560
completion handler so we do that we but

00:33:15,700 --> 00:33:18,200
before we register the completion

00:33:17,560 --> 00:33:20,390
handler we

00:33:18,200 --> 00:33:22,700
change state to two so that once we

00:33:20,390 --> 00:33:25,280
resume the state machine we resume in

00:33:22,700 --> 00:33:27,140
state two right and the completion

00:33:25,280 --> 00:33:31,100
handler basically says Oh

00:33:27,140 --> 00:33:33,800
once I'm completed I'm gonna call the

00:33:31,100 --> 00:33:35,750
state machine with that event so that's

00:33:33,800 --> 00:33:37,790
the try that we were but it's passed

00:33:35,750 --> 00:33:39,740
into the state machine but this is gonna

00:33:37,790 --> 00:33:41,570
happen apply is gonna be called when

00:33:39,740 --> 00:33:43,880
state is two so that means when it

00:33:41,570 --> 00:33:45,710
completes when it completes we call

00:33:43,880 --> 00:33:50,470
apply and we are in state two so that

00:33:45,710 --> 00:33:52,730
means in state two we have a try right

00:33:50,470 --> 00:33:54,050
and we can check if it's a failure or

00:33:52,730 --> 00:33:57,530
not it's a failure we complete our

00:33:54,050 --> 00:34:00,860
promise with that failure if not we can

00:33:57,530 --> 00:34:02,540
we can get the X you have to get the

00:34:00,860 --> 00:34:06,020
result out of the tribe because it's a

00:34:02,540 --> 00:34:08,870
success can get it out and change state

00:34:06,020 --> 00:34:12,890
to one right and one is the state where

00:34:08,870 --> 00:34:16,010
we run after the weight we resumed after

00:34:12,890 --> 00:34:17,660
the await do this kind of this case two

00:34:16,010 --> 00:34:20,060
is actually bookkeeping right this is

00:34:17,660 --> 00:34:22,490
happening when this thing is completed

00:34:20,060 --> 00:34:23,990
or we have the next event right and we

00:34:22,490 --> 00:34:25,870
do the bookkeeping to know what should

00:34:23,990 --> 00:34:29,780
happen next what what do we need to do

00:34:25,870 --> 00:34:32,420
but the actual code that runs after the

00:34:29,780 --> 00:34:34,010
wait is actually in state one right so

00:34:32,420 --> 00:34:36,860
we change the state one call apply which

00:34:34,010 --> 00:34:38,630
means we end up here and the X get is

00:34:36,860 --> 00:34:40,190
actually the entire piece of code that

00:34:38,630 --> 00:34:42,320
comes here so of course it could be a

00:34:40,190 --> 00:34:44,630
complex expression in this case it's

00:34:42,320 --> 00:34:48,470
just X dot get so this is what we do

00:34:44,630 --> 00:34:51,380
here and we complete the promise okay so

00:34:48,470 --> 00:34:53,120
um that's essentially how it works

00:34:51,380 --> 00:34:54,170
I hope that made some sense I don't have

00:34:53,120 --> 00:34:57,740
really time to go to have a number

00:34:54,170 --> 00:34:59,660
details but um so that that's one way to

00:34:57,740 --> 00:35:01,030
do it and the compiler can do it and

00:34:59,660 --> 00:35:04,940
macro can do it

00:35:01,030 --> 00:35:06,520
well macros may not read maybe should

00:35:04,940 --> 00:35:10,610
not do it because they just become

00:35:06,520 --> 00:35:13,550
compiler phases that do it so um but we

00:35:10,610 --> 00:35:16,940
can also think of running on a runtime

00:35:13,550 --> 00:35:19,010
system that provides a bit more support

00:35:16,940 --> 00:35:22,220
like continuations so and that's what

00:35:19,010 --> 00:35:25,460
project loon in the open JDK does and

00:35:22,220 --> 00:35:27,560
the idea is to provide features that we

00:35:25,460 --> 00:35:28,930
can use to build lightweight

00:35:27,560 --> 00:35:31,430
high-throughput

00:35:28,930 --> 00:35:32,670
concurrency constructs and particularly

00:35:31,430 --> 00:35:35,100
provides

00:35:32,670 --> 00:35:39,290
delimited continuations and fibers so

00:35:35,100 --> 00:35:41,550
fibers are essentially user-mode threads

00:35:39,290 --> 00:35:45,810
but they're interesting because of their

00:35:41,550 --> 00:35:46,800
integration with the JDK but um and this

00:35:45,810 --> 00:35:48,600
is of course still under active

00:35:46,800 --> 00:35:50,600
development so you can't there's no

00:35:48,600 --> 00:35:53,760
release that has that yet but it's

00:35:50,600 --> 00:35:57,480
there's a lot of people now working on

00:35:53,760 --> 00:35:58,860
so it's looks quite promising so how do

00:35:57,480 --> 00:36:03,030
you know how these continuations look

00:35:58,860 --> 00:36:05,310
like well the basic idea is that you can

00:36:03,030 --> 00:36:08,160
take a runnable and turn it into a

00:36:05,310 --> 00:36:10,170
continuation so this is actually quite

00:36:08,160 --> 00:36:13,020
simple right you just provide a runnable

00:36:10,170 --> 00:36:15,620
and in the body here you can actually

00:36:13,020 --> 00:36:19,890
suspend and resume the continuation

00:36:15,620 --> 00:36:22,680
right and now the thing is this is a

00:36:19,890 --> 00:36:25,440
super low level API clearly like the if

00:36:22,680 --> 00:36:27,720
you want to pass in values and out of

00:36:25,440 --> 00:36:28,470
the body you need to build higher level

00:36:27,720 --> 00:36:30,090
abstractions

00:36:28,470 --> 00:36:35,010
that's not provided right so you need to

00:36:30,090 --> 00:36:37,890
do that yourself and so here is like the

00:36:35,010 --> 00:36:39,630
hello world example of continuations I'm

00:36:37,890 --> 00:36:41,580
just very very quickly run through it

00:36:39,630 --> 00:36:44,880
but it's it's really simple like you

00:36:41,580 --> 00:36:46,560
create a continuation you call run when

00:36:44,880 --> 00:36:49,590
you call run you start it from the

00:36:46,560 --> 00:36:51,690
beginning right and it runs until either

00:36:49,590 --> 00:36:53,580
the end or until it suspends which is

00:36:51,690 --> 00:36:55,860
stunned with yield right so you can

00:36:53,580 --> 00:37:00,540
yield at the continuation and that makes

00:36:55,860 --> 00:37:02,010
run so that so run completes and okay in

00:37:00,540 --> 00:37:04,410
check whether the continuation is

00:37:02,010 --> 00:37:07,320
actually finished or not this case it's

00:37:04,410 --> 00:37:08,880
not so we set continue to true and then

00:37:07,320 --> 00:37:12,750
we can resume the candidates were

00:37:08,880 --> 00:37:15,230
calling run again so we run we resume by

00:37:12,750 --> 00:37:19,920
picking up from the yield point here and

00:37:15,230 --> 00:37:22,110
you know resume things that's very

00:37:19,920 --> 00:37:25,230
simple and of course this is makes it

00:37:22,110 --> 00:37:28,830
quite easy to implement this model

00:37:25,230 --> 00:37:31,680
because in our async essentially when

00:37:28,830 --> 00:37:35,510
we're given this body we just need to

00:37:31,680 --> 00:37:40,410
create a continuation where our task

00:37:35,510 --> 00:37:44,130
evaluates body and it can do that

00:37:40,410 --> 00:37:45,720
because the flow here the delegate is

00:37:44,130 --> 00:37:48,690
actually in scope so

00:37:45,720 --> 00:37:50,930
it works without any issues here right

00:37:48,690 --> 00:37:53,520
the body has access to the delegate and

00:37:50,930 --> 00:37:58,170
everything works out fine and inside the

00:37:53,520 --> 00:38:03,840
body we could have invocations of yield

00:37:58,170 --> 00:38:05,520
or a weight yeah when I'm sure you I'm

00:38:03,840 --> 00:38:07,440
going to show you a way to but if it

00:38:05,520 --> 00:38:08,460
runs into completion we can omit events

00:38:07,440 --> 00:38:10,140
and/or

00:38:08,460 --> 00:38:12,180
you know there's an exception we can

00:38:10,140 --> 00:38:14,840
catch it and so on

00:38:12,180 --> 00:38:20,220
and a weight now is very simple to

00:38:14,840 --> 00:38:22,140
basically we're given our context and we

00:38:20,220 --> 00:38:24,630
can check whether we're already we have

00:38:22,140 --> 00:38:25,950
something to consume if it's now then we

00:38:24,630 --> 00:38:28,140
don't which means we need to register

00:38:25,950 --> 00:38:32,580
completion handler the completion

00:38:28,140 --> 00:38:35,430
handler can resume the continuation so

00:38:32,580 --> 00:38:37,710
the flow context you know provides a way

00:38:35,430 --> 00:38:41,700
to resume the the corresponding

00:38:37,710 --> 00:38:43,170
continuation and and once the right is

00:38:41,700 --> 00:38:47,580
the the handle is registered we can

00:38:43,170 --> 00:38:50,430
suspend and and of course resumption

00:38:47,580 --> 00:38:53,990
will will happen right after the suspend

00:38:50,430 --> 00:38:57,450
call so it's at that point we can we can

00:38:53,990 --> 00:39:00,540
resume okay so this is actually very

00:38:57,450 --> 00:39:03,570
simple and there's even more like we

00:39:00,540 --> 00:39:06,119
even like wrote a paper about this so

00:39:03,570 --> 00:39:12,060
you have like you know 30-something

00:39:06,119 --> 00:39:14,280
pages of text which which actually has a

00:39:12,060 --> 00:39:17,300
also formalizations which is actually

00:39:14,280 --> 00:39:18,710
the first reduction semantics for

00:39:17,300 --> 00:39:22,830
observables

00:39:18,710 --> 00:39:25,349
before that Eric Meyer and and others

00:39:22,830 --> 00:39:27,080
did that denotational semantics but it's

00:39:25,349 --> 00:39:30,030
actually a reduction semantics so it's

00:39:27,080 --> 00:39:33,480
quite nice and you can do type sounds

00:39:30,030 --> 00:39:36,060
proofs and protocol conformance that

00:39:33,480 --> 00:39:38,070
publisher doesn't doesn't publish more

00:39:36,060 --> 00:39:39,660
events after it has terminated for

00:39:38,070 --> 00:39:43,320
example that's like an invariant that

00:39:39,660 --> 00:39:44,760
actually the type system provides and we

00:39:43,320 --> 00:39:48,390
also talked a bit more about the macro

00:39:44,760 --> 00:39:50,040
based implementation there yeah so there

00:39:48,390 --> 00:39:51,869
are some open issues as you mentioned so

00:39:50,040 --> 00:39:55,109
one is the red and blue functions issue

00:39:51,869 --> 00:39:58,080
right where if you want to call a

00:39:55,109 --> 00:39:59,069
sustainable method which in our case

00:39:58,080 --> 00:40:01,349
it's

00:39:59,069 --> 00:40:04,709
methods that have that required the flow

00:40:01,349 --> 00:40:07,609
context and that means this caller has

00:40:04,709 --> 00:40:09,479
to be suspended well - so that means

00:40:07,609 --> 00:40:13,369
particularly if I have a higher order

00:40:09,479 --> 00:40:17,849
function like map it takes function and

00:40:13,369 --> 00:40:20,519
assume I want the argument function to

00:40:17,849 --> 00:40:22,890
be possibly suspending well then I need

00:40:20,519 --> 00:40:25,019
to prepare map that map for that I need

00:40:22,890 --> 00:40:27,569
a very end of map that allows me to

00:40:25,019 --> 00:40:30,779
suspend you know that allows me to

00:40:27,569 --> 00:40:32,519
recall a suspend of all function whereas

00:40:30,779 --> 00:40:35,789
I need two variants for each of these

00:40:32,519 --> 00:40:39,809
higher-order functions right so red and

00:40:35,789 --> 00:40:43,049
blue variants so that's not good

00:40:39,809 --> 00:40:45,930
and of course monads suffer from the

00:40:43,049 --> 00:40:48,809
same issue and so that's something to

00:40:45,930 --> 00:40:50,009
work on lume continuations themselves

00:40:48,809 --> 00:40:52,849
actually don't suffer from the problem

00:40:50,009 --> 00:40:55,079
so we can actually use suspend anywhere

00:40:52,849 --> 00:40:58,579
as long as there is an active

00:40:55,079 --> 00:41:00,869
continuation and so this suggests that

00:40:58,579 --> 00:41:02,940
we may actually be able to relax the

00:41:00,869 --> 00:41:06,890
need for the for the flow capabilities

00:41:02,940 --> 00:41:10,349
right and so I think there's some

00:41:06,890 --> 00:41:14,219
promising work I think that's possible

00:41:10,349 --> 00:41:17,459
on on like API design - to do that yeah

00:41:14,219 --> 00:41:21,739
so um I'm gonna come to the end here so

00:41:17,459 --> 00:41:24,269
we have some resources so the prototype

00:41:21,739 --> 00:41:26,940
implementations that the two ones one

00:41:24,269 --> 00:41:30,539
based on macros one on the continuations

00:41:26,940 --> 00:41:35,180
is on my github and you may want to look

00:41:30,539 --> 00:41:37,799
at the can't brag because well it uses

00:41:35,180 --> 00:41:39,779
Project loon continuations and it's

00:41:37,799 --> 00:41:41,369
actually also the only branch that

00:41:39,779 --> 00:41:45,660
actually makes use of Scala three so

00:41:41,369 --> 00:41:49,109
it's more interesting and also here I

00:41:45,660 --> 00:41:51,539
try to you know release preprints of

00:41:49,109 --> 00:41:58,440
things that you're not behind paywalls

00:41:51,539 --> 00:42:03,960
always and yeah that's it thank you

00:41:58,440 --> 00:42:05,140
[Applause]

00:42:03,960 --> 00:42:15,280
questions

00:42:05,140 --> 00:42:20,490
ah there's a question over there sir

00:42:15,280 --> 00:42:20,490
microphone okay oh there

00:42:28,829 --> 00:42:32,650
Thanks

00:42:30,039 --> 00:42:34,420
it's really interesting what you're

00:42:32,650 --> 00:42:35,680
trying to do a little bridge this two

00:42:34,420 --> 00:42:38,289
worlds

00:42:35,680 --> 00:42:41,499
I'm wondering if you could show an

00:42:38,289 --> 00:42:44,339
example or explain how it would look for

00:42:41,499 --> 00:42:48,640
a little bit more complex example like

00:42:44,339 --> 00:42:50,619
flatmap concat and with the buffer just

00:42:48,640 --> 00:42:57,730
sort of there's this imperative style

00:42:50,619 --> 00:42:59,710
how will work out in practice hmm yeah

00:42:57,730 --> 00:43:02,650
so I mean well there there are some more

00:42:59,710 --> 00:43:04,720
examples in fact if so this paper I

00:43:02,650 --> 00:43:10,240
mentioned this actually has an kind of

00:43:04,720 --> 00:43:13,359
an I like it another maybe I can find it

00:43:10,240 --> 00:43:23,289
real quick see I copied and pasted code

00:43:13,359 --> 00:43:25,119
here so let me show you a bit more in

00:43:23,289 --> 00:43:27,029
fact if you have statefulness and things

00:43:25,119 --> 00:43:40,239
like that it really becomes much easier

00:43:27,029 --> 00:43:43,239
to use direct style sorry yeah so so zip

00:43:40,239 --> 00:43:45,359
for example zip is actually interesting

00:43:43,239 --> 00:43:48,160
it's more complex than you think right

00:43:45,359 --> 00:43:51,099
you think you may think of zip that's

00:43:48,160 --> 00:43:54,160
easy we just well in this case it's a

00:43:51,099 --> 00:43:57,579
quite general zip method because it dips

00:43:54,160 --> 00:43:59,589
up a whole sequence of observables so

00:43:57,579 --> 00:44:02,470
replace observables publisher and you

00:43:59,589 --> 00:44:05,410
get the same picture but the idea is we

00:44:02,470 --> 00:44:07,170
have a dis a rather general zip method

00:44:05,410 --> 00:44:11,109
it takes the sequence of observables and

00:44:07,170 --> 00:44:15,249
the zipper combines is a function that

00:44:11,109 --> 00:44:19,509
combines the elements recommenced events

00:44:15,249 --> 00:44:21,670
of each observable and so the result is

00:44:19,509 --> 00:44:25,989
observable of our and so what we can do

00:44:21,670 --> 00:44:31,509
here is we need to keep track of a whole

00:44:25,989 --> 00:44:34,900
bunch of stuff so in particular we need

00:44:31,509 --> 00:44:38,220
to wait for the next event of each

00:44:34,900 --> 00:44:41,760
source right

00:44:38,220 --> 00:44:49,130
Oh someone's calling that's too bad I'll

00:44:41,760 --> 00:44:51,660
have to delay that but um so so we

00:44:49,130 --> 00:44:55,290
create an array that can hold the next

00:44:51,660 --> 00:44:57,180
events and we can actually just loop

00:44:55,290 --> 00:44:58,650
through and just wait for the for the

00:44:57,180 --> 00:45:01,170
for the events and the cool thing is

00:44:58,650 --> 00:45:03,510
that this will not decrease performance

00:45:01,170 --> 00:45:06,210
right because when we suspend on the

00:45:03,510 --> 00:45:08,880
first one well we can still that the

00:45:06,210 --> 00:45:10,680
next producer can can already produce

00:45:08,880 --> 00:45:12,690
the event that will be immediately

00:45:10,680 --> 00:45:14,880
available once we go to the next event

00:45:12,690 --> 00:45:17,310
wait call and so on so we can actually

00:45:14,880 --> 00:45:20,730
just collect these things and then

00:45:17,310 --> 00:45:23,280
decide ok what to do do we have you know

00:45:20,730 --> 00:45:27,900
can we is it okay to run the combiner

00:45:23,280 --> 00:45:29,010
function and so on right so um and you

00:45:27,900 --> 00:45:30,720
know at some point these streams

00:45:29,010 --> 00:45:32,640
terminate and they can terminate at

00:45:30,720 --> 00:45:34,380
different points they don't maybe don't

00:45:32,640 --> 00:45:37,590
produce the same number of items either

00:45:34,380 --> 00:45:40,200
we have to handle that I mean with

00:45:37,590 --> 00:45:41,610
direct style it's actually it's rather

00:45:40,200 --> 00:45:43,770
trivial if you can do sequential

00:45:41,610 --> 00:45:47,070
programming you should be able to do

00:45:43,770 --> 00:45:48,810
this also right so I think it's yeah

00:45:47,070 --> 00:45:51,750
it's quite nice so I encourage you to

00:45:48,810 --> 00:45:53,760
look at the article and also because

00:45:51,750 --> 00:45:56,160
there are some other examples as well so

00:45:53,760 --> 00:45:58,710
there's like a challenge problem with a

00:45:56,160 --> 00:46:00,450
solution also here where it's also a bit

00:45:58,710 --> 00:46:02,670
like combining different streams and

00:46:00,450 --> 00:46:04,740
have some statefulness in there as well

00:46:02,670 --> 00:46:07,950
actually with buffers and windowing also

00:46:04,740 --> 00:46:10,590
going on right so you can like you can

00:46:07,950 --> 00:46:15,390
say well I have two streams I combined

00:46:10,590 --> 00:46:17,820
them but I need a window right and and I

00:46:15,390 --> 00:46:20,940
need to reduce multiple events of one

00:46:17,820 --> 00:46:23,970
window and check conditions and and

00:46:20,940 --> 00:46:27,030
what-have-you right and not always

00:46:23,970 --> 00:46:30,330
publish an event for each received event

00:46:27,030 --> 00:46:32,850
no but I have a condition that doesn't

00:46:30,330 --> 00:46:35,160
it makes it much less regular and so on

00:46:32,850 --> 00:46:39,960
so my advice is just to look at the

00:46:35,160 --> 00:46:44,400
examples in the paper also any other

00:46:39,960 --> 00:46:47,580
question okay so in your example you've

00:46:44,400 --> 00:46:49,470
you have used mutable variable where the

00:46:47,580 --> 00:46:52,140
wire loop my question is would be would

00:46:49,470 --> 00:46:54,330
it it possible to rewrite this exam

00:46:52,140 --> 00:46:57,570
using more like idiomatic functional

00:46:54,330 --> 00:47:01,650
style with maybe a full comprehension or

00:46:57,570 --> 00:47:05,780
or tail-recursive function are you

00:47:01,650 --> 00:47:07,890
talking about this one where yes okay

00:47:05,780 --> 00:47:11,270
yeah I mean there's nothing that

00:47:07,890 --> 00:47:13,920
prevents you from from just using

00:47:11,270 --> 00:47:16,560
Combinator's to combine publishers to

00:47:13,920 --> 00:47:18,720
write so I think that I mean this is

00:47:16,560 --> 00:47:20,490
maybe not like the best example the

00:47:18,720 --> 00:47:23,340
example what this shows here is that

00:47:20,490 --> 00:47:25,950
it's very simple to go from a future

00:47:23,340 --> 00:47:27,150
based code to stream based code right

00:47:25,950 --> 00:47:29,190
like this would looks very similar to

00:47:27,150 --> 00:47:32,370
the initial future based acing a way to

00:47:29,190 --> 00:47:34,590
usage right but I mean I agree with you

00:47:32,370 --> 00:47:36,510
that I think this is the this is like a

00:47:34,590 --> 00:47:39,320
very regular example so there's it's not

00:47:36,510 --> 00:47:42,660
so difficult so sure you can just use

00:47:39,320 --> 00:47:45,060
use map on a publisher or whatever and

00:47:42,660 --> 00:47:46,740
it will work the same way so like you're

00:47:45,060 --> 00:47:53,610
not forced to write it this in this way

00:47:46,740 --> 00:47:53,970
but you can well we are already out of

00:47:53,610 --> 00:47:56,300
time

00:47:53,970 --> 00:48:00,859
okay so thank you thank you

00:47:56,300 --> 00:48:00,859

YouTube URL: https://www.youtube.com/watch?v=s1cfdqIa40A


