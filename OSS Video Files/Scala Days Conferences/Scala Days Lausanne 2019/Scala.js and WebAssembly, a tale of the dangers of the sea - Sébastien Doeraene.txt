Title: Scala.js and WebAssembly, a tale of the dangers of the sea - SÃ©bastien Doeraene
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/scala-js-and-webassembly-a-tale-of-the-dangers-of-the-sea
Captions: 
	00:00:07,820 --> 00:00:13,530
hello

00:00:09,560 --> 00:00:16,919
so it starts for a session on on

00:00:13,530 --> 00:00:18,659
colleges and webassembly a tale of the

00:00:16,919 --> 00:00:21,589
dangers of the sea when I submitted the

00:00:18,659 --> 00:00:24,779
talk I felt like being very poetic and

00:00:21,589 --> 00:00:26,640
then when you actually get to prepare to

00:00:24,779 --> 00:00:28,289
talk in the technical details and then

00:00:26,640 --> 00:00:30,229
suddenly you realize maybe that was not

00:00:28,289 --> 00:00:34,920
a good idea

00:00:30,229 --> 00:00:37,050
so but anyway otherwise we'll will of

00:00:34,920 --> 00:00:39,359
course take to two to the content but

00:00:37,050 --> 00:00:41,160
you might not see as many images of

00:00:39,359 --> 00:00:45,989
characters and secure as you might have

00:00:41,160 --> 00:00:49,289
wanted also fair warning there won't be

00:00:45,989 --> 00:00:53,550
any demo in this talk and none of what

00:00:49,289 --> 00:00:57,149
I'm going to talk about works so if you

00:00:53,550 --> 00:00:58,800
wanted to see something that works you

00:00:57,149 --> 00:01:02,429
still have time to run to one of the

00:00:58,800 --> 00:01:05,220
other talks you wanted to see so this is

00:01:02,429 --> 00:01:08,940
completely purely theoretical if you

00:01:05,220 --> 00:01:11,810
were at Kelly's doctors before she was

00:01:08,940 --> 00:01:15,180
talking about talk driven development

00:01:11,810 --> 00:01:17,220
when she submits a talk and then she

00:01:15,180 --> 00:01:19,380
learns or implements the things she she

00:01:17,220 --> 00:01:22,860
wants to talk about that was kind of the

00:01:19,380 --> 00:01:24,330
idea that I did with this talk except I

00:01:22,860 --> 00:01:28,290
didn't need to get to actually take the

00:01:24,330 --> 00:01:30,630
time to implement any of this so this is

00:01:28,290 --> 00:01:34,640
all purely theoretical but hopefully it

00:01:30,630 --> 00:01:40,350
was so interesting okay let me start by

00:01:34,640 --> 00:01:43,350
asking it's a small question basically

00:01:40,350 --> 00:01:46,110
like think about for you what what is

00:01:43,350 --> 00:01:48,180
college is like is it is the compiler is

00:01:46,110 --> 00:01:51,680
the macro is the language this is a

00:01:48,180 --> 00:01:57,090
JavaScript library is it a side project

00:01:51,680 --> 00:01:58,860
and or is it an ecosystem and I won't do

00:01:57,090 --> 00:02:00,420
a show of answers to complicate it takes

00:01:58,860 --> 00:02:03,480
too soon too much time and I haven't

00:02:00,420 --> 00:02:05,580
prepared nice-nice online polls like

00:02:03,480 --> 00:02:08,280
like the keynote so let me just answer

00:02:05,580 --> 00:02:09,030
the questions for you so it is a

00:02:08,280 --> 00:02:11,850
compiler

00:02:09,030 --> 00:02:14,550
it is also an ecosystem

00:02:11,850 --> 00:02:16,500
and for that I'm super glad that people

00:02:14,550 --> 00:02:18,690
in the community actually like those

00:02:16,500 --> 00:02:21,690
every reason some of its because

00:02:18,690 --> 00:02:23,880
otherwise it wouldn't be useful but most

00:02:21,690 --> 00:02:29,160
importantly for the purpose of this talk

00:02:23,880 --> 00:02:30,270
it is a language so I probably many of

00:02:29,160 --> 00:02:32,700
you taught that scholar with the

00:02:30,270 --> 00:02:34,890
language and Scarlet Reyes is like the

00:02:32,700 --> 00:02:37,230
same language so why is it really

00:02:34,890 --> 00:02:40,140
language well because it's actually

00:02:37,230 --> 00:02:42,690
relatively distinct from scholar JVM I

00:02:40,140 --> 00:02:44,880
am very proud of always talking about

00:02:42,690 --> 00:02:47,370
how portable it is and how you can take

00:02:44,880 --> 00:02:49,770
any any library and just change the

00:02:47,370 --> 00:02:53,040
build and then suddenly it also compiles

00:02:49,770 --> 00:02:55,800
for the Java platform but the reality is

00:02:53,040 --> 00:02:58,500
there are also a few things that make it

00:02:55,800 --> 00:03:01,080
quite distinct from Scala JVM as a

00:02:58,500 --> 00:03:03,600
language you might have heard of anti

00:03:01,080 --> 00:03:05,940
fine behaviors there was a talk

00:03:03,600 --> 00:03:08,880
yesterday that said if you access an

00:03:05,940 --> 00:03:12,720
array out of bounds it will just do

00:03:08,880 --> 00:03:14,280
stuff instead of reliably throwing an

00:03:12,720 --> 00:03:17,460
array index out of bounds exception or

00:03:14,280 --> 00:03:19,560
something like that the two string

00:03:17,460 --> 00:03:23,100
called the primitive values is not quite

00:03:19,560 --> 00:03:25,200
the same the test type tests as well but

00:03:23,100 --> 00:03:28,290
those are details in the grand scheme of

00:03:25,200 --> 00:03:31,590
things and especially for today what is

00:03:28,290 --> 00:03:33,600
relevant is there is no Java Interop of

00:03:31,590 --> 00:03:37,260
course but there is JavaScript Interop

00:03:33,600 --> 00:03:40,440
and that's actually a big part of what's

00:03:37,260 --> 00:03:42,990
colleges as a language is you can't just

00:03:40,440 --> 00:03:44,730
like compiles color to JavaScript and

00:03:42,990 --> 00:03:47,490
and call it a day

00:03:44,730 --> 00:03:50,970
that's the easy part and when I say easy

00:03:47,490 --> 00:03:54,660
I truly mean it I did that in two weeks

00:03:50,970 --> 00:03:59,400
I think and then it took me six years to

00:03:54,660 --> 00:04:02,070
get to where we are now so so JavaScript

00:03:59,400 --> 00:04:07,200
Interop is really the soul of scholar

00:04:02,070 --> 00:04:09,270
J's and it's more than just what people

00:04:07,200 --> 00:04:13,040
would call an FF is a foreign function

00:04:09,270 --> 00:04:16,350
interface it's really bi-directional

00:04:13,040 --> 00:04:21,419
intro bility with objects function

00:04:16,350 --> 00:04:24,030
values state properties methods all of

00:04:21,419 --> 00:04:26,200
that you can call javascript things

00:04:24,030 --> 00:04:28,810
charles who can call you

00:04:26,200 --> 00:04:31,060
in synchronous way in asynchronous ways

00:04:28,810 --> 00:04:34,000
using callbacks using futures and

00:04:31,060 --> 00:04:37,330
promises all of that stuff so here you

00:04:34,000 --> 00:04:40,780
have an example code that mixes and

00:04:37,330 --> 00:04:44,620
match to the maximum I managed to do in

00:04:40,780 --> 00:04:46,960
six lines of code Java scripts and and

00:04:44,620 --> 00:04:48,910
Scala so you have Scala classes like

00:04:46,960 --> 00:04:51,970
points which is even a case class and

00:04:48,910 --> 00:04:55,440
States which is which inside contains

00:04:51,970 --> 00:04:58,360
some reference to a JavaScript array and

00:04:55,440 --> 00:05:00,760
that javascript array contains itself

00:04:58,360 --> 00:05:05,020
points which are against Carla

00:05:00,760 --> 00:05:07,540
constructs and then you can call the add

00:05:05,020 --> 00:05:10,210
event listener method from JavaScript

00:05:07,540 --> 00:05:13,450
and give it a lambda and that lambda is

00:05:10,210 --> 00:05:15,910
defined in the Scala code but it ends up

00:05:13,450 --> 00:05:18,850
being a JavaScript function that holds

00:05:15,910 --> 00:05:22,000
in its captures the Scala states and

00:05:18,850 --> 00:05:23,800
then it mutates that thing and so

00:05:22,000 --> 00:05:27,130
basically like you can do this sort of

00:05:23,800 --> 00:05:32,320
stuff welcome back to this example in

00:05:27,130 --> 00:05:34,930
about 38 slides in the meantime let's go

00:05:32,320 --> 00:05:37,120
a lot of a talk a bit about what is web

00:05:34,930 --> 00:05:39,850
based and working and that you might

00:05:37,120 --> 00:05:42,550
have even less of an idea so it is the

00:05:39,850 --> 00:05:45,460
compiler is the virtual machine is the

00:05:42,550 --> 00:05:48,010
language is the binary format it is

00:05:45,460 --> 00:05:52,230
specific to the web I mean you might

00:05:48,010 --> 00:05:55,660
expect that it is an oval standard so

00:05:52,230 --> 00:05:57,970
it's another compiler at all it's really

00:05:55,660 --> 00:06:00,580
a language binary format and an open

00:05:57,970 --> 00:06:04,690
standard and it's not specific to the

00:06:00,580 --> 00:06:07,080
web and again most importantly for the

00:06:04,690 --> 00:06:09,910
purposes of this talk it is a language

00:06:07,080 --> 00:06:13,780
so it might not be a language that you

00:06:09,910 --> 00:06:18,669
might want to write by hand at least not

00:06:13,780 --> 00:06:21,520
for more than 10 or 20 lines of codes so

00:06:18,669 --> 00:06:23,740
in practice it's typically a language

00:06:21,520 --> 00:06:26,190
that is the result of compiling from

00:06:23,740 --> 00:06:26,190
another language

00:06:26,450 --> 00:06:33,400
so this is a bit what webassembly can

00:06:30,440 --> 00:06:37,640
look like so on the left you have some

00:06:33,400 --> 00:06:39,020
C++ code or C or both I never remember

00:06:37,640 --> 00:06:41,840
the difference

00:06:39,020 --> 00:06:44,570
it's a factorial it's not tail recursive

00:06:41,840 --> 00:06:46,510
I never write tail recursive functions I

00:06:44,570 --> 00:06:49,880
don't know what people have with them

00:06:46,510 --> 00:06:55,250
and on the right if you compile this

00:06:49,880 --> 00:07:00,860
with a with a situ webassembly compiler

00:06:55,250 --> 00:07:04,040
that is very smart what you might get is

00:07:00,860 --> 00:07:05,870
the results on the right this is not

00:07:04,040 --> 00:07:08,270
actually what you will get with typical

00:07:05,870 --> 00:07:10,910
compilers right now but it's the easiest

00:07:08,270 --> 00:07:14,510
code I could find like kind of fits the

00:07:10,910 --> 00:07:16,400
bill so you can see that it's a it's

00:07:14,510 --> 00:07:18,080
basically a stack machine so every

00:07:16,400 --> 00:07:20,300
instruction puts something on the stack

00:07:18,080 --> 00:07:26,080
or pops things on the stack just

00:07:20,300 --> 00:07:28,690
computations it looks like by codes but

00:07:26,080 --> 00:07:31,670
control flow is structured so

00:07:28,690 --> 00:07:34,010
instructions are all linear expressions

00:07:31,670 --> 00:07:36,320
are expressed on the stack but control

00:07:34,010 --> 00:07:39,920
flow like an F else is structured so

00:07:36,320 --> 00:07:42,950
there are blocks of if and else we'll

00:07:39,920 --> 00:07:45,440
we'll look more into details later about

00:07:42,950 --> 00:07:49,810
what kind of things we can do but you

00:07:45,440 --> 00:07:53,260
can see there that we have in 64 we have

00:07:49,810 --> 00:07:56,020
some primitive operations like sub

00:07:53,260 --> 00:07:59,630
multiplication we can call methods

00:07:56,020 --> 00:08:04,640
including recursive recursive calls and

00:07:59,630 --> 00:08:07,240
that kind of stuff so basically this is

00:08:04,640 --> 00:08:10,460
what you have in webassembly

00:08:07,240 --> 00:08:12,980
you have a linear memory model so the

00:08:10,460 --> 00:08:16,880
kinds of what you would get in in C

00:08:12,980 --> 00:08:21,500
basically so basically the memory is one

00:08:16,880 --> 00:08:24,590
giant array of bytes and you can have

00:08:21,500 --> 00:08:27,440
pointers into that array which were big

00:08:24,590 --> 00:08:29,780
Li and this is into the array and there

00:08:27,440 --> 00:08:31,160
is absolutely no PC okay so this is what

00:08:29,780 --> 00:08:33,150
you get with word web personally right

00:08:31,160 --> 00:08:36,479
now

00:08:33,150 --> 00:08:38,580
so whether assembly can sort of talk to

00:08:36,479 --> 00:08:41,010
JavaScript but in very limited ways and

00:08:38,580 --> 00:08:44,029
in in a way that I would in this case

00:08:41,010 --> 00:08:47,730
qualifiers in for a function interface

00:08:44,029 --> 00:08:50,960
this is way too much code but what you

00:08:47,730 --> 00:08:55,200
can see is I have on the left some

00:08:50,960 --> 00:08:58,370
JavaScript functions that I somehow give

00:08:55,200 --> 00:09:01,230
access to to JavaScript to web assembly

00:08:58,370 --> 00:09:03,690
in webassembly I can import those

00:09:01,230 --> 00:09:06,950
functions that's the fourth line on the

00:09:03,690 --> 00:09:09,510
slides and then I can call them later

00:09:06,950 --> 00:09:12,150
down down the line this is an

00:09:09,510 --> 00:09:15,570
alternative text version of web assembly

00:09:12,150 --> 00:09:17,940
which is more like Lisp and the two

00:09:15,570 --> 00:09:20,070
versions are basically one-to-one

00:09:17,940 --> 00:09:23,190
correspondence is just a different way

00:09:20,070 --> 00:09:25,200
of expressing some intense though it was

00:09:23,190 --> 00:09:26,700
just for the show and also because it

00:09:25,200 --> 00:09:29,490
was the output of the comparator I used

00:09:26,700 --> 00:09:30,810
I didn't want to translate to the other

00:09:29,490 --> 00:09:35,850
forum but I will stick to the other

00:09:30,810 --> 00:09:38,580
forum for the rest of the talk so here

00:09:35,850 --> 00:09:39,900
you can see that we have functions in

00:09:38,580 --> 00:09:45,830
JavaScript that take floats as

00:09:39,900 --> 00:09:48,180
parameters and return sorry I probably

00:09:45,830 --> 00:09:52,680
mixed up on the left of course you have

00:09:48,180 --> 00:09:56,190
some C codes so it takes floats it

00:09:52,680 --> 00:10:01,520
returns floats or void and that's about

00:09:56,190 --> 00:10:03,930
all you gets it's numbers and that's it

00:10:01,520 --> 00:10:07,830
so yeah FF I with JavaScript is really

00:10:03,930 --> 00:10:09,830
limited to past saying 32-bit integers

00:10:07,830 --> 00:10:11,390
to the two bit and 64 bit floats and

00:10:09,830 --> 00:10:14,250
that's it

00:10:11,390 --> 00:10:18,270
like literal is all the only thing you

00:10:14,250 --> 00:10:23,820
can like give between web as million and

00:10:18,270 --> 00:10:28,730
JavaScript so strings nope objects nope

00:10:23,820 --> 00:10:33,170
higher-order functions definitely not

00:10:28,730 --> 00:10:36,000
okay let's get to the fun part which is

00:10:33,170 --> 00:10:39,000
let's try and compare this ecology as to

00:10:36,000 --> 00:10:44,190
what was it mr. Fortner for buy some

00:10:39,000 --> 00:10:46,589
bling this is house colleges works but

00:10:44,190 --> 00:10:50,100
now you understand all of ecology is

00:10:46,589 --> 00:10:51,510
basically you have scholars forces you

00:10:50,100 --> 00:10:53,100
give them to the scholar compared to

00:10:51,510 --> 00:10:58,200
this college is comparator it spits out

00:10:53,100 --> 00:11:00,450
some SGS IR IR files which stands for s

00:10:58,200 --> 00:11:04,770
colleges intermediate representation

00:11:00,450 --> 00:11:06,690
very original and then maybe you put

00:11:04,770 --> 00:11:08,730
that on maven or you pull other

00:11:06,690 --> 00:11:13,080
artifacts from maven that contain those

00:11:08,730 --> 00:11:15,000
s jsrf falls and you give them to

00:11:13,080 --> 00:11:19,020
discourage it atomizer which massage

00:11:15,000 --> 00:11:20,700
system spits out optimized IR and then

00:11:19,020 --> 00:11:25,890
there is a last type that takes that IR

00:11:20,700 --> 00:11:27,870
and outputs one big javascript file so

00:11:25,890 --> 00:11:31,200
if we want to compile a scholar just

00:11:27,870 --> 00:11:33,779
webassembly we can reuse the sources

00:11:31,200 --> 00:11:36,330
hopefully we can reuse the Scala

00:11:33,779 --> 00:11:39,150
compiler we can reuse the SJ sorrowful

00:11:36,330 --> 00:11:42,360
files like all of the we can reuse

00:11:39,150 --> 00:11:45,510
colleges denizer to a large extent some

00:11:42,360 --> 00:11:47,910
of the things it does are specific to

00:11:45,510 --> 00:11:51,360
optimizing for JavaScript but we would

00:11:47,910 --> 00:11:53,700
just deactivate those parts the one

00:11:51,360 --> 00:11:56,220
thing that we need to rewrite as the

00:11:53,700 --> 00:11:58,950
very last part which takes the optimizer

00:11:56,220 --> 00:12:02,490
irn image webassembly instead of

00:11:58,950 --> 00:12:05,279
javascript so that means that i will

00:12:02,490 --> 00:12:08,310
show a lot of scholar J's ir in this

00:12:05,279 --> 00:12:11,220
talk because s or input format really

00:12:08,310 --> 00:12:13,110
for what we're trying to do so to give

00:12:11,220 --> 00:12:15,779
you an idea what it looks like here is a

00:12:13,110 --> 00:12:19,890
factorial function again the non terry

00:12:15,779 --> 00:12:23,010
cursive one but written in scala above

00:12:19,890 --> 00:12:24,810
for colleges to be precise and if you

00:12:23,010 --> 00:12:27,630
compile it with this college is

00:12:24,810 --> 00:12:31,529
compiler you end up with this ir which

00:12:27,630 --> 00:12:35,130
looks very similar what you see is that

00:12:31,529 --> 00:12:36,590
all method names have a mangled name so

00:12:35,130 --> 00:12:39,410
that overloading

00:12:36,590 --> 00:12:43,250
is compiled the way you have primitives

00:12:39,410 --> 00:12:45,770
like ends every operation is tagged with

00:12:43,250 --> 00:12:47,600
the type of operands it takes like the

00:12:45,770 --> 00:12:51,710
Equality comparison is an equality of

00:12:47,600 --> 00:12:53,780
ends not of something else and it has

00:12:51,710 --> 00:12:56,000
structured comfort control flow with

00:12:53,780 --> 00:13:01,910
if-else etcetera and but it also has

00:12:56,000 --> 00:13:04,310
full-blown expressions like The Times

00:13:01,910 --> 00:13:08,180
operator and the the method call and

00:13:04,310 --> 00:13:09,920
inside the subtraction and basically the

00:13:08,180 --> 00:13:13,550
type system is very similar to that of

00:13:09,920 --> 00:13:15,680
Java at this point so it's object

00:13:13,550 --> 00:13:16,760
I mean classes and interfaces without

00:13:15,680 --> 00:13:20,260
type parameters

00:13:16,760 --> 00:13:21,440
that's all arrays the way and primitives

00:13:20,260 --> 00:13:24,650
okay

00:13:21,440 --> 00:13:29,150
so let's take this IR and compile it to

00:13:24,650 --> 00:13:31,820
web assembly so we can start at the top

00:13:29,150 --> 00:13:34,670
at the top of the function look at the

00:13:31,820 --> 00:13:38,420
if-else is structured and we can compile

00:13:34,670 --> 00:13:41,680
it down to the structured control flow F

00:13:38,420 --> 00:13:46,880
else of web assembly so far so good

00:13:41,680 --> 00:13:49,970
then you can see that the the if in web

00:13:46,880 --> 00:13:51,620
assembly is annotated with high 32

00:13:49,970 --> 00:13:54,350
which means that the result of stiff of

00:13:51,620 --> 00:13:57,470
this if-else is an expression that

00:13:54,350 --> 00:14:00,830
returns an int 32 so it's like in Scala

00:13:57,470 --> 00:14:05,350
if-else are can be expressions and can

00:14:00,830 --> 00:14:08,420
return a value we can compile the

00:14:05,350 --> 00:14:11,810
condition of the F which comes before

00:14:08,420 --> 00:14:13,880
the structured F because it's going to

00:14:11,810 --> 00:14:17,960
put on the stack a boolean value that

00:14:13,880 --> 00:14:20,420
says yes or no and so how we compile

00:14:17,960 --> 00:14:24,140
these things is we load the local

00:14:20,420 --> 00:14:26,810
variable 0 which is n we and we put it

00:14:24,140 --> 00:14:30,080
on the stack then we put the constant 0

00:14:26,810 --> 00:14:32,120
on the stack and then we compare the two

00:14:30,080 --> 00:14:35,750
things on top of the stack and we put

00:14:32,120 --> 00:14:37,520
back the results and then the F is going

00:14:35,750 --> 00:14:39,650
to pop the boolean value of the stack

00:14:37,520 --> 00:14:41,330
and if it's true answer the dead branch

00:14:39,650 --> 00:14:45,410
and otherwise really else branch this is

00:14:41,330 --> 00:14:48,710
how it works so in the dead branch it's

00:14:45,410 --> 00:14:49,850
super easy we have the constant 1 we can

00:14:48,710 --> 00:14:52,850
load it put in

00:14:49,850 --> 00:14:54,800
the stack and that's it so the thing

00:14:52,850 --> 00:14:56,300
that's that's on the stack at the end of

00:14:54,800 --> 00:15:00,949
the den branch is going to be the result

00:14:56,300 --> 00:15:03,680
of the if expression on the in the else

00:15:00,949 --> 00:15:09,199
parts we can look at what the the

00:15:03,680 --> 00:15:11,600
topmost operation it's the times so at

00:15:09,199 --> 00:15:13,399
the very end we're going to say multiply

00:15:11,600 --> 00:15:17,810
the two things that are on top of the

00:15:13,399 --> 00:15:20,870
stack and on the Left we have the local

00:15:17,810 --> 00:15:23,870
variable and which so we load the local

00:15:20,870 --> 00:15:25,850
0 we put it on the stack on the right we

00:15:23,870 --> 00:15:29,060
first need to compute the argument to

00:15:25,850 --> 00:15:32,389
the method so load n put one on the

00:15:29,060 --> 00:15:34,040
stack subtract and we get something else

00:15:32,389 --> 00:15:36,230
on the stack which is then going to be

00:15:34,040 --> 00:15:38,360
the argument to the call to the

00:15:36,230 --> 00:15:40,970
recursive call to factorial and then the

00:15:38,360 --> 00:15:44,120
result of that call will be on top of

00:15:40,970 --> 00:15:47,089
the stack so we can multiply the two

00:15:44,120 --> 00:15:49,250
values so this is the this is really how

00:15:47,089 --> 00:15:51,709
it works so so far it seems like we're

00:15:49,250 --> 00:15:56,449
good at the translation from the Scala

00:15:51,709 --> 00:15:59,990
JSI R to webassembly it looks easy super

00:15:56,449 --> 00:16:02,630
easy we can even do a tail recursive

00:15:59,990 --> 00:16:06,800
factorial because otherwise someone will

00:16:02,630 --> 00:16:08,060
kill me at some points so this is the

00:16:06,800 --> 00:16:10,639
tail recursive factorial with an

00:16:08,060 --> 00:16:13,069
accumulator and if you compare it with

00:16:10,639 --> 00:16:15,319
the Scala JCR with the sculptor's

00:16:13,069 --> 00:16:18,589
compiler you get the IR that's at the

00:16:15,319 --> 00:16:22,189
bottom it is fairly complicated it has a

00:16:18,589 --> 00:16:27,350
few weird things like those labelled

00:16:22,189 --> 00:16:30,490
blocks this X and whatever thingy then

00:16:27,350 --> 00:16:33,889
while true and then inside has returns

00:16:30,490 --> 00:16:36,439
but with a label that's like name of a

00:16:33,889 --> 00:16:38,449
blog anyway we're going to look at it I

00:16:36,439 --> 00:16:42,050
don't really want to go into too much

00:16:38,449 --> 00:16:43,699
detail of how this really works but we

00:16:42,050 --> 00:16:46,370
have this weird constraint which is this

00:16:43,699 --> 00:16:49,490
labeled block and the returns and the

00:16:46,370 --> 00:16:52,399
fun part is that webassembly has exactly

00:16:49,490 --> 00:16:54,319
the same weird construct that nobody

00:16:52,399 --> 00:16:56,089
invented before in scholar J's invented

00:16:54,319 --> 00:16:58,850
it and weber simply invented it and they

00:16:56,089 --> 00:17:00,649
invented the same thing so it's really

00:16:58,850 --> 00:17:02,480
nice because that means that when we

00:17:00,649 --> 00:17:03,120
compile as ecology is to webassembly we

00:17:02,480 --> 00:17:04,650
can map

00:17:03,120 --> 00:17:09,180
one to the other because they mean the

00:17:04,650 --> 00:17:11,430
same thing so here we we can compile

00:17:09,180 --> 00:17:13,380
this thing first we're going to look at

00:17:11,430 --> 00:17:14,790
the local variable declarations we're

00:17:13,380 --> 00:17:17,400
going to lift them out at the top

00:17:14,790 --> 00:17:19,319
because webassembly only has local

00:17:17,400 --> 00:17:22,589
variables occurred at the top of the

00:17:19,319 --> 00:17:27,600
functions and then we start from the

00:17:22,589 --> 00:17:30,780
outermost part of the methods and we

00:17:27,600 --> 00:17:32,790
encountered this labels block so we omit

00:17:30,780 --> 00:17:36,000
in webassembly a block whose name is

00:17:32,790 --> 00:17:41,610
dollar X and the returned value of the

00:17:36,000 --> 00:17:44,490
block will be a int 32 and then inside

00:17:41,610 --> 00:17:48,000
we have this loop which is a while true

00:17:44,490 --> 00:17:49,500
so it loops indefinitely so basically in

00:17:48,000 --> 00:17:52,350
web-based only what you would do is have

00:17:49,500 --> 00:17:54,480
a loop construct that has a name and at

00:17:52,350 --> 00:17:58,380
the end of the loop you branch back to

00:17:54,480 --> 00:18:01,080
the loop label so it's going to loop

00:17:58,380 --> 00:18:03,510
indefinitely except of course if from

00:18:01,080 --> 00:18:07,250
within the block at some point you exit

00:18:03,510 --> 00:18:07,250
it in a more brutal fashion

00:18:09,260 --> 00:18:14,760
inside we encounter another labeled

00:18:11,580 --> 00:18:18,290
block but this one it returns void or

00:18:14,760 --> 00:18:20,550
unit or whatever so we translate it to

00:18:18,290 --> 00:18:23,309
simply a label block in webassembly

00:18:20,550 --> 00:18:26,340
and then we have the same kind of if

00:18:23,309 --> 00:18:30,210
expression here so same thing as before

00:18:26,340 --> 00:18:32,250
and the if is an expression again we

00:18:30,210 --> 00:18:35,070
load on the local which is the

00:18:32,250 --> 00:18:39,380
accumulator then we have this thing to

00:18:35,070 --> 00:18:41,510
load n put 1 subtract store

00:18:39,380 --> 00:18:44,460
same thing with the multiplication

00:18:41,510 --> 00:18:47,940
boring and then we have this thing where

00:18:44,460 --> 00:18:49,920
we just move things around by loading

00:18:47,940 --> 00:18:52,559
locals and setting local somewhere else

00:18:49,920 --> 00:18:55,950
and finally we have this return thing

00:18:52,559 --> 00:18:58,380
which is really like jump at a break

00:18:55,950 --> 00:19:00,780
from this label so that's what we say

00:18:58,380 --> 00:19:02,760
break from this label and webassembly

00:19:00,780 --> 00:19:05,309
and it's the same thing that's amazing

00:19:02,760 --> 00:19:08,880
and we have the same with with the

00:19:05,309 --> 00:19:10,980
return but this return takes actually a

00:19:08,880 --> 00:19:15,030
parameter and that will be the return

00:19:10,980 --> 00:19:15,389
value of the block so at the at the end

00:19:15,030 --> 00:19:18,149
of the

00:19:15,389 --> 00:19:20,219
else here it's a it's an expression if

00:19:18,149 --> 00:19:23,099
else with it puts something on the stack

00:19:20,219 --> 00:19:25,919
and this branch is going to pop that

00:19:23,099 --> 00:19:30,239
thing from the stack and return it as a

00:19:25,919 --> 00:19:32,639
result of the big block so that's how it

00:19:30,239 --> 00:19:35,609
works anyway this was just to show off

00:19:32,639 --> 00:19:37,889
that scholar jason webassembly have the

00:19:35,609 --> 00:19:43,129
same kind of control flow so here for

00:19:37,889 --> 00:19:47,809
that now things get more complicated

00:19:43,129 --> 00:19:51,089
classes as you know Scala has classes

00:19:47,809 --> 00:19:53,429
here is a non case class it is the final

00:19:51,089 --> 00:19:56,909
class point and we have a method that

00:19:53,429 --> 00:19:58,829
just makes a point and this is how it

00:19:56,909 --> 00:20:01,709
would be compiled in this garage is IRS

00:19:58,829 --> 00:20:04,049
so you can see a class that extends

00:20:01,709 --> 00:20:06,499
object it has fields it has accessors

00:20:04,049 --> 00:20:09,570
for these fields it has a constructor

00:20:06,499 --> 00:20:11,399
which takes two ins puts them into this

00:20:09,570 --> 00:20:16,249
and called a super constructor it's

00:20:11,399 --> 00:20:20,129
really boring and this is how you would

00:20:16,249 --> 00:20:26,190
somehow compile this web assembly using

00:20:20,129 --> 00:20:28,169
the linear memory so the important thing

00:20:26,190 --> 00:20:32,459
here which apparently I forgot to

00:20:28,169 --> 00:20:37,079
highlight on the slide is the fact that

00:20:32,459 --> 00:20:39,839
we have a call to dollar malloc so we're

00:20:37,079 --> 00:20:41,700
actually like allocating memory from the

00:20:39,839 --> 00:20:46,799
linear memory and then we're putting

00:20:41,700 --> 00:20:48,989
things inside and and we end up with a

00:20:46,799 --> 00:20:50,700
pointer really to to you to the class

00:20:48,989 --> 00:20:53,129
and we have to store things like a

00:20:50,700 --> 00:20:55,139
reference to what class this is and then

00:20:53,129 --> 00:20:58,109
we store the values that sits right and

00:20:55,139 --> 00:20:59,509
we can we call the constructor all of

00:20:58,109 --> 00:21:03,259
that kind of stuff

00:20:59,509 --> 00:21:06,359
and here is the body of the constructor

00:21:03,259 --> 00:21:09,570
which also called the super constructor

00:21:06,359 --> 00:21:13,589
and then stores things inside the fields

00:21:09,570 --> 00:21:16,649
it's relatively straightforward if you

00:21:13,589 --> 00:21:18,959
imagine that an object lives in a linear

00:21:16,649 --> 00:21:21,709
heap and you have memory that you have

00:21:18,959 --> 00:21:21,709
to fill in right

00:21:22,100 --> 00:21:29,270
and then we have a lot of things that we

00:21:26,540 --> 00:21:31,280
need to encode from job from world Java

00:21:29,270 --> 00:21:34,190
or Scala is the same thing basically at

00:21:31,280 --> 00:21:37,220
this point virtual dispatch interfaces

00:21:34,190 --> 00:21:41,360
garbage collection you can implement all

00:21:37,220 --> 00:21:49,430
of that it's possible it's very tedious

00:21:41,360 --> 00:21:52,780
but it's doable and then comes the

00:21:49,430 --> 00:21:56,090
interpreter interoperability problem and

00:21:52,780 --> 00:22:02,150
this is this is the attack of one of the

00:21:56,090 --> 00:22:05,930
monsters of the sea but yeah so here is

00:22:02,150 --> 00:22:09,170
a simplified scenario and ecology is

00:22:05,930 --> 00:22:11,480
where I would use the JavaScript timers

00:22:09,170 --> 00:22:13,850
especially the global function set

00:22:11,480 --> 00:22:15,500
timeouts I give you the function I give

00:22:13,850 --> 00:22:18,740
it a delay which is basically a number

00:22:15,500 --> 00:22:23,420
and this is how it would be compiled to

00:22:18,740 --> 00:22:26,180
the Scala desires so you have you get we

00:22:23,420 --> 00:22:27,950
have access to the global set timeout

00:22:26,180 --> 00:22:30,500
function and then we have a call and

00:22:27,950 --> 00:22:32,450
then we have a an arrow lambda so

00:22:30,500 --> 00:22:36,140
basically a JavaScript anonymous

00:22:32,450 --> 00:22:39,080
function that lambda calls another

00:22:36,140 --> 00:22:41,600
methods and that method also gets the

00:22:39,080 --> 00:22:45,620
global console object called the log

00:22:41,600 --> 00:22:50,410
method with a parameter hello as a an

00:22:45,620 --> 00:22:54,590
argument and here things are problematic

00:22:50,410 --> 00:22:57,650
because just look at at the last line

00:22:54,590 --> 00:23:02,060
which tries to write hello on the

00:22:57,650 --> 00:23:04,420
console this thing runs to read read

00:23:02,060 --> 00:23:08,720
access to a global JavaScript value

00:23:04,420 --> 00:23:10,850
which is an object its console problem

00:23:08,720 --> 00:23:11,540
there is no such thing as an object in

00:23:10,850 --> 00:23:15,200
webassembly

00:23:11,540 --> 00:23:18,380
so you can't even take that in your

00:23:15,200 --> 00:23:20,420
hands it you have no handle to this

00:23:18,380 --> 00:23:22,250
thing which is a JavaScript object you

00:23:20,420 --> 00:23:25,850
cannot you can't talk about it in

00:23:22,250 --> 00:23:27,590
webassembly you have strings you cannot

00:23:25,850 --> 00:23:29,150
talk about strings and way about

00:23:27,590 --> 00:23:32,210
somebody but you can put this array of

00:23:29,150 --> 00:23:33,860
cars in the memory but those are not

00:23:32,210 --> 00:23:35,130
JavaScript strings there are C strings

00:23:33,860 --> 00:23:36,750
you cannot

00:23:35,130 --> 00:23:38,790
holding your hands and JavaScript string

00:23:36,750 --> 00:23:41,340
so you're stuck there as well

00:23:38,790 --> 00:23:44,220
and then and then you have this desmet

00:23:41,340 --> 00:23:46,950
call to a javascript function which is

00:23:44,220 --> 00:23:49,650
which is even more complicated like we

00:23:46,950 --> 00:23:52,020
cannot even talk about the things that

00:23:49,650 --> 00:23:55,350
that make up this function call let

00:23:52,020 --> 00:23:57,270
alone the function call itself and above

00:23:55,350 --> 00:23:59,580
like imagine like you have a higher

00:23:57,270 --> 00:24:00,320
order function but what do you do with

00:23:59,580 --> 00:24:04,680
these things

00:24:00,320 --> 00:24:09,560
so webassembly just just doesn't have

00:24:04,680 --> 00:24:12,600
the ability to talk about these things

00:24:09,560 --> 00:24:13,260
you can't you can't get access to any of

00:24:12,600 --> 00:24:15,690
these things

00:24:13,260 --> 00:24:17,850
so if you write out in Scala dress like

00:24:15,690 --> 00:24:21,990
it's completely it's it's it's done

00:24:17,850 --> 00:24:25,290
alright so are we completely stuck like

00:24:21,990 --> 00:24:28,980
this is the end of the talk and well

00:24:25,290 --> 00:24:33,540
there are a few things we can try one is

00:24:28,980 --> 00:24:38,430
let's drop interoperability maybe I

00:24:33,540 --> 00:24:41,700
don't know that's the other monster if

00:24:38,430 --> 00:24:44,460
we do that well we basically lose all

00:24:41,700 --> 00:24:47,070
attempts of any kind of portability of

00:24:44,460 --> 00:24:50,310
of our code right the scholar GS code

00:24:47,070 --> 00:24:54,360
that has been written for for several

00:24:50,310 --> 00:24:57,290
years just won't work and what you end

00:24:54,360 --> 00:25:00,300
up with actually is a different language

00:24:57,290 --> 00:25:03,660
you basically dropped interoperability

00:25:00,300 --> 00:25:06,300
from Scala J's which was the sole which

00:25:03,660 --> 00:25:08,430
I mean for which interrupt was the sole

00:25:06,300 --> 00:25:10,290
Scala is so what you get instead is

00:25:08,430 --> 00:25:15,770
another language you might have heard

00:25:10,290 --> 00:25:21,930
about it it's called any idea

00:25:15,770 --> 00:25:23,340
Scala native and this is the third

00:25:21,930 --> 00:25:25,050
language that you might want to

00:25:23,340 --> 00:25:26,520
experiment with there is College avian

00:25:25,050 --> 00:25:28,290
there is color Jason and there is colony

00:25:26,520 --> 00:25:30,570
- if it's it's a third language that

00:25:28,290 --> 00:25:32,760
language can be compiled to web as an

00:25:30,570 --> 00:25:35,280
wing but that languages and talk to Java

00:25:32,760 --> 00:25:37,890
scripts so it's a different different

00:25:35,280 --> 00:25:42,410
language different trade-offs and that's

00:25:37,890 --> 00:25:42,410
not my project so I don't care

00:25:42,900 --> 00:25:49,620
okay so what we did we do instead well

00:25:46,410 --> 00:25:52,410
basically in it was in verse version one

00:25:49,620 --> 00:25:55,590
the there was them that is available

00:25:52,410 --> 00:25:57,930
today in your browsers we are actually

00:25:55,590 --> 00:26:00,530
completely stuck there is nothing we can

00:25:57,930 --> 00:26:00,530
do about it

00:26:00,830 --> 00:26:10,770
sociology is dead but there is hope in

00:26:07,040 --> 00:26:13,770
proposals for future versions of web

00:26:10,770 --> 00:26:17,040
assembly so now we start looking into

00:26:13,770 --> 00:26:23,160
the future of what might be possible

00:26:17,040 --> 00:26:26,760
and there is one proposal which is about

00:26:23,160 --> 00:26:30,600
reference types you can go and click on

00:26:26,760 --> 00:26:32,490
that link if you want but I'm going to

00:26:30,600 --> 00:26:34,380
present a little bit what it does so

00:26:32,490 --> 00:26:38,550
basically the reference types proposal

00:26:34,380 --> 00:26:42,110
is an extension to add well basically

00:26:38,550 --> 00:26:46,200
one type to webassembly which so far had

00:26:42,110 --> 00:26:50,300
integers floats and doubles and now it

00:26:46,200 --> 00:26:55,400
has four types it has also any ref and

00:26:50,300 --> 00:26:59,309
an any ref is a reference to some thing

00:26:55,400 --> 00:27:02,070
from the host environment it could be

00:26:59,309 --> 00:27:03,450
the JavaScript heap for example so it

00:27:02,070 --> 00:27:05,190
could be a reference to a JavaScript

00:27:03,450 --> 00:27:07,410
object or it could be a reference to a

00:27:05,190 --> 00:27:11,100
JavaScript string or it could be a

00:27:07,410 --> 00:27:14,340
reference to a JavaScript number because

00:27:11,100 --> 00:27:18,870
that's also a JavaScript thing from the

00:27:14,340 --> 00:27:23,010
host environment and you can have you

00:27:18,870 --> 00:27:24,750
can have any ref in on the stack with

00:27:23,010 --> 00:27:27,540
four local variables four parameters two

00:27:24,750 --> 00:27:29,760
functions as a result of functions and

00:27:27,540 --> 00:27:32,220
you have also a separate heap that is

00:27:29,760 --> 00:27:35,309
distinct from the linear memory in which

00:27:32,220 --> 00:27:37,380
you can store any riffs so you still

00:27:35,309 --> 00:27:39,750
have the giant array of bytes which is

00:27:37,380 --> 00:27:42,809
the reader of memory on which you can

00:27:39,750 --> 00:27:48,960
basically put bytes and then there is

00:27:42,809 --> 00:27:51,420
another array of any refs but you cannot

00:27:48,960 --> 00:27:53,640
put any refs inside the linear memory

00:27:51,420 --> 00:27:56,610
that's not possible and you cannot cast

00:27:53,640 --> 00:27:59,770
on any ref to an int pointer

00:27:56,610 --> 00:28:02,830
because otherwise the JavaScript GC

00:27:59,770 --> 00:28:08,410
would have issues okay so what can we do

00:28:02,830 --> 00:28:12,960
with that well let's look let's look

00:28:08,410 --> 00:28:16,060
again at our hello methods which was

00:28:12,960 --> 00:28:21,390
impossible to get before now it's it's

00:28:16,060 --> 00:28:24,220
only very awkward so what we can do is

00:28:21,390 --> 00:28:25,930
decompose the things so the first thing

00:28:24,220 --> 00:28:29,620
we need to do is reach the global

00:28:25,930 --> 00:28:33,040
variable console and for that on the web

00:28:29,620 --> 00:28:35,080
a simply side on the right well you

00:28:33,040 --> 00:28:36,760
can't really there is nothing in

00:28:35,080 --> 00:28:38,560
webassembly even with reference types

00:28:36,760 --> 00:28:40,540
that lets you access a global variable

00:28:38,560 --> 00:28:44,650
from JavaScript the only thing you can

00:28:40,540 --> 00:28:47,230
do is import some functions from

00:28:44,650 --> 00:28:49,930
JavaScript so you can write a function

00:28:47,230 --> 00:28:52,840
in JavaScript on the left that is called

00:28:49,930 --> 00:28:55,570
get console that returns the console and

00:28:52,840 --> 00:28:57,610
you can import that function from web

00:28:55,570 --> 00:29:00,070
assembly and then you can call that

00:28:57,610 --> 00:29:01,960
function it doesn't take any parameter

00:29:00,070 --> 00:29:03,550
and we'll put on the stack to resolve

00:29:01,960 --> 00:29:07,500
the function which is a console object

00:29:03,550 --> 00:29:13,630
which is in any race okay so far so good

00:29:07,500 --> 00:29:17,350
then I have to put the string log on on

00:29:13,630 --> 00:29:19,320
the on the stack but webassembly doesn't

00:29:17,350 --> 00:29:22,510
know how to create a JavaScript string

00:29:19,320 --> 00:29:24,570
but it's not a problem we can write a

00:29:22,510 --> 00:29:28,600
JavaScript function that returns the

00:29:24,570 --> 00:29:30,340
constant log which is a string and we

00:29:28,600 --> 00:29:32,110
can import that function and we can call

00:29:30,340 --> 00:29:35,290
that function and we receive the string

00:29:32,110 --> 00:29:37,240
as in any ref and we can do the same

00:29:35,290 --> 00:29:40,270
with the other constants in our program

00:29:37,240 --> 00:29:42,610
like the string hello and finally when

00:29:40,270 --> 00:29:46,030
we put those three things on the stack

00:29:42,610 --> 00:29:48,580
the console object the log string and in

00:29:46,030 --> 00:29:50,650
the hello string we want to call the

00:29:48,580 --> 00:29:54,070
methods but we recently doesn't know how

00:29:50,650 --> 00:29:55,540
to call a JavaScript method but it's not

00:29:54,070 --> 00:29:57,340
a problem you can write a JavaScript

00:29:55,540 --> 00:30:01,600
function that is going to call a method

00:29:57,340 --> 00:30:04,030
and you call that method call method one

00:30:01,600 --> 00:30:06,790
it takes an object a method and an

00:30:04,030 --> 00:30:08,230
argument and it's going to call the

00:30:06,790 --> 00:30:10,640
method and then you can import that

00:30:08,230 --> 00:30:13,670
function from web assembly

00:30:10,640 --> 00:30:16,640
and you can call it so you've called

00:30:13,670 --> 00:30:18,320
things from JavaScript outside to put

00:30:16,640 --> 00:30:20,390
things on your stack and you called

00:30:18,320 --> 00:30:23,660
another Java C to actually use those

00:30:20,390 --> 00:30:27,610
things from your stack so it's good

00:30:23,660 --> 00:30:32,470
right we managed to print something

00:30:27,610 --> 00:30:32,470
which is a step to step up from before

00:30:32,710 --> 00:30:36,890
let's look at the set timer thing with

00:30:35,929 --> 00:30:39,460
with the lambda

00:30:36,890 --> 00:30:44,840
all right can we do something about that

00:30:39,460 --> 00:30:48,380
we can it's just very awkward but we can

00:30:44,840 --> 00:30:50,750
we can create a function in so actually

00:30:48,380 --> 00:30:53,000
this one is relatively easy because it

00:30:50,750 --> 00:30:57,500
doesn't have any captures so we can

00:30:53,000 --> 00:31:00,919
actually write a function on your right

00:30:57,500 --> 00:31:03,950
with which is a web assembly function

00:31:00,919 --> 00:31:06,140
that is the lambda and it doesn't take

00:31:03,950 --> 00:31:09,320
any argument and returns in any ref and

00:31:06,140 --> 00:31:11,809
it calls the the other the other actual

00:31:09,320 --> 00:31:16,160
methods and you can actually use this

00:31:11,809 --> 00:31:21,620
rafted func up operation and whereas

00:31:16,160 --> 00:31:24,740
only to get a javascript version of that

00:31:21,620 --> 00:31:26,630
function so that's possible but all

00:31:24,740 --> 00:31:29,030
because it doesn't have captures but

00:31:26,630 --> 00:31:31,940
that'sthat's already quite good so you

00:31:29,030 --> 00:31:35,270
can put that on the stack and then you

00:31:31,940 --> 00:31:40,130
can put the constant 1000s double on the

00:31:35,270 --> 00:31:42,410
stack but then you cannot actually give

00:31:40,130 --> 00:31:44,929
that to javascript at least not in a

00:31:42,410 --> 00:31:47,750
relatively generic way because what you

00:31:44,929 --> 00:31:50,720
want is really any refs so what you need

00:31:47,750 --> 00:31:53,630
is a function that takes a double and

00:31:50,720 --> 00:31:55,730
returns in any ref for that double and

00:31:53,630 --> 00:31:58,190
web person Lee doesn't have an operation

00:31:55,730 --> 00:32:00,350
for that but no problem you can write a

00:31:58,190 --> 00:32:03,799
function in JavaScript on the left which

00:32:00,350 --> 00:32:07,040
is called box table that takes a double

00:32:03,799 --> 00:32:09,799
and returns the same thing so that was

00:32:07,040 --> 00:32:12,049
useless right except that if you look on

00:32:09,799 --> 00:32:14,690
the right we give a type to that

00:32:12,049 --> 00:32:17,480
function from webassembly side and we

00:32:14,690 --> 00:32:19,910
say it takes as a parameter an F 64 so a

00:32:17,480 --> 00:32:21,830
double and it returns in any ref and

00:32:19,910 --> 00:32:24,010
because of how web assembly in

00:32:21,830 --> 00:32:25,890
JavaScript talks to each other

00:32:24,010 --> 00:32:28,960
double that was on the stack will be

00:32:25,890 --> 00:32:30,730
given as an F 64 to JavaScript which

00:32:28,960 --> 00:32:32,890
will turn it into a primitive number and

00:32:30,730 --> 00:32:35,410
will returns to web assembly which

00:32:32,890 --> 00:32:38,049
expects in any ref that number will be

00:32:35,410 --> 00:32:42,370
interpreted as an any Rev version of

00:32:38,049 --> 00:32:44,260
that number so yeah for that now that we

00:32:42,370 --> 00:32:45,700
have those things on the stack we can we

00:32:44,260 --> 00:32:49,600
can use a similar mechanism to actually

00:32:45,700 --> 00:32:54,400
call the function etc etc okay so so we

00:32:49,600 --> 00:32:58,660
can do that he was a real problem

00:32:54,400 --> 00:33:00,160
references across heaps because remember

00:32:58,660 --> 00:33:03,040
I told you that any reps you can put

00:33:00,160 --> 00:33:05,410
them on the stack and on a separate heap

00:33:03,040 --> 00:33:10,210
but you cannot put them inside the

00:33:05,410 --> 00:33:13,299
linear memory so I told you we were

00:33:10,210 --> 00:33:16,299
going to come back to this example and

00:33:13,299 --> 00:33:18,429
here is a schematic version of the

00:33:16,299 --> 00:33:22,450
references across the two heaps that we

00:33:18,429 --> 00:33:23,919
need here we need in the JavaScript heap

00:33:22,450 --> 00:33:26,080
at the end of the day we end up with the

00:33:23,919 --> 00:33:28,299
Dom event listeners thing from from the

00:33:26,080 --> 00:33:31,419
browser which reference a lambda which

00:33:28,299 --> 00:33:35,919
is a child transfer function that Chavez

00:33:31,419 --> 00:33:38,770
can function in his captures hold has

00:33:35,919 --> 00:33:40,840
access to the states thing which is an

00:33:38,770 --> 00:33:43,210
instance from the Scala heap and that

00:33:40,840 --> 00:33:45,460
thing contains a value points which is a

00:33:43,210 --> 00:33:47,559
JSA race so it comes from the JavaScript

00:33:45,460 --> 00:33:49,780
heap and that thing again contains

00:33:47,559 --> 00:33:58,169
points which are things from the Scala

00:33:49,780 --> 00:34:01,450
heap so now you have this thing and well

00:33:58,169 --> 00:34:05,320
from pointers from the JavaScript heap

00:34:01,450 --> 00:34:08,169
to Scala heap well the only thing we can

00:34:05,320 --> 00:34:09,580
remember that on the Scala heap objects

00:34:08,169 --> 00:34:13,060
are just pointers in the linear memory

00:34:09,580 --> 00:34:15,909
so basically they're numbers so yeah you

00:34:13,060 --> 00:34:17,139
could you can hold a number in in

00:34:15,909 --> 00:34:19,300
JavaScript that's okay

00:34:17,139 --> 00:34:22,629
but the problem is then that the Scala

00:34:19,300 --> 00:34:24,490
GC cannot know which objects are

00:34:22,629 --> 00:34:27,639
reachable or not so it can never get

00:34:24,490 --> 00:34:30,369
collect anything and then the the other

00:34:27,639 --> 00:34:31,629
arrows from Scala to JavaScript since we

00:34:30,369 --> 00:34:33,450
cannot put any wraps in the reader

00:34:31,629 --> 00:34:36,500
memory what we're going to do is put

00:34:33,450 --> 00:34:38,899
ideas integer IDs the

00:34:36,500 --> 00:34:40,580
there are busy keys in a map in

00:34:38,899 --> 00:34:42,909
JavaScript that will actually map to the

00:34:40,580 --> 00:34:46,280
real objects from the JavaScript side

00:34:42,909 --> 00:34:47,600
but then the JavaScript GCC can never

00:34:46,280 --> 00:34:50,330
know when these things are not only

00:34:47,600 --> 00:34:53,210
reachable and you can make this work to

00:34:50,330 --> 00:34:56,060
some extent but if you do have cycles at

00:34:53,210 --> 00:34:58,220
some point then it's it's dead like your

00:34:56,060 --> 00:35:00,830
cycle your cycles are never going to be

00:34:58,220 --> 00:35:02,270
collected and I don't even want to talk

00:35:00,830 --> 00:35:07,760
about the performance aspect of these

00:35:02,270 --> 00:35:10,460
things so what you really need at some

00:35:07,760 --> 00:35:12,950
point is full cooperation between the

00:35:10,460 --> 00:35:15,200
two GCS the GC from the web assembly

00:35:12,950 --> 00:35:18,950
scholar side and the GC from the

00:35:15,200 --> 00:35:21,740
JavaScript side because you need to

00:35:18,950 --> 00:35:23,690
support cycles between between the two

00:35:21,740 --> 00:35:26,840
heaps like Scala is full of cycles

00:35:23,690 --> 00:35:29,450
javascript is full of cycles scholar J's

00:35:26,840 --> 00:35:32,270
is full of cycles between the two so if

00:35:29,450 --> 00:35:36,920
we don't have support for cycles it's

00:35:32,270 --> 00:35:39,770
it's a no-go so with any refs alone we

00:35:36,920 --> 00:35:43,190
can get far we can actually get

00:35:39,770 --> 00:35:45,620
something that is correct that will

00:35:43,190 --> 00:35:50,180
implement the entire scaligeri

00:35:45,620 --> 00:35:53,300
specification correctly but there was

00:35:50,180 --> 00:35:57,320
just one little caveat it won't garbage

00:35:53,300 --> 00:36:02,470
collect I don't know might be good

00:35:57,320 --> 00:36:05,630
enough for you okay so so then then what

00:36:02,470 --> 00:36:10,790
well there is another proposal from web

00:36:05,630 --> 00:36:13,250
assembly for a GC so I'm very happy

00:36:10,790 --> 00:36:17,090
about this one it's at a very vague

00:36:13,250 --> 00:36:20,290
Stage two so but there is document that

00:36:17,090 --> 00:36:22,730
says more or less what they want to do

00:36:20,290 --> 00:36:25,550
and basically what they want to do is

00:36:22,730 --> 00:36:27,530
two things they want new types in

00:36:25,550 --> 00:36:31,580
addition to the integers the floats and

00:36:27,530 --> 00:36:34,820
the any refs they want two poles and a

00:36:31,580 --> 00:36:36,740
race and then they want references to

00:36:34,820 --> 00:36:38,900
those things so you can have it's not a

00:36:36,740 --> 00:36:42,080
pointer it's a reference you have a

00:36:38,900 --> 00:36:43,960
reference to a tuple or a reference to

00:36:42,080 --> 00:36:47,860
an array

00:36:43,960 --> 00:36:50,200
and those references will supposedly be

00:36:47,860 --> 00:36:53,650
garbage collectors like you can actually

00:36:50,200 --> 00:36:55,840
create a garbage collected heap in

00:36:53,650 --> 00:36:58,900
weather assembly that will be taken care

00:36:55,840 --> 00:37:02,200
of by the webassembly GC and that one is

00:36:58,900 --> 00:37:04,960
is designed to cooperate with the

00:37:02,200 --> 00:37:08,020
JavaScript heap and the josma GC so

00:37:04,960 --> 00:37:12,190
that's good so let's let's look at what

00:37:08,020 --> 00:37:15,580
we could do here so far for the for the

00:37:12,190 --> 00:37:18,790
class points which has two ins we would

00:37:15,580 --> 00:37:21,820
define two types first the type point

00:37:18,790 --> 00:37:24,760
struct which defines the the internal

00:37:21,820 --> 00:37:27,760
representation which is actually three

00:37:24,760 --> 00:37:31,750
inch not just two

00:37:27,760 --> 00:37:33,760
the first one is just a an identifier

00:37:31,750 --> 00:37:35,590
for the class point because we need to

00:37:33,760 --> 00:37:37,780
remember that for instance off and that

00:37:35,590 --> 00:37:40,150
kind of stuff and the two other ends or

00:37:37,780 --> 00:37:42,160
the actual X&Y and then we define

00:37:40,150 --> 00:37:45,040
another type which is point which we

00:37:42,160 --> 00:37:51,510
define as a reference to a point struct

00:37:45,040 --> 00:37:54,070
and the state is similar here it has a

00:37:51,510 --> 00:37:58,420
struct with an int which is again the

00:37:54,070 --> 00:38:00,900
class states and then in any ref because

00:37:58,420 --> 00:38:05,470
that's a that's a JavaScript array so

00:38:00,900 --> 00:38:07,240
here in in destructs we can actually

00:38:05,470 --> 00:38:10,570
have any refs

00:38:07,240 --> 00:38:14,410
and this time right so we can have gee

00:38:10,570 --> 00:38:17,470
seeds objects webassembly that actually

00:38:14,410 --> 00:38:21,310
refer directly to g seed stuff from the

00:38:17,470 --> 00:38:25,870
JavaScript world and vice versa so yay

00:38:21,310 --> 00:38:28,510
for that so if we if we had that or

00:38:25,870 --> 00:38:34,240
probably we will have it at some point

00:38:28,510 --> 00:38:36,430
this is what we can do for this so first

00:38:34,240 --> 00:38:38,680
we create an empty array but of course

00:38:36,430 --> 00:38:40,600
ja web base image doesn't know how to

00:38:38,680 --> 00:38:42,280
create an empty JavaScript array but

00:38:40,600 --> 00:38:44,170
that's okay you can you can write a

00:38:42,280 --> 00:38:45,880
function in JavaScript that creates an

00:38:44,170 --> 00:38:49,000
empty array and returns it - JA - to

00:38:45,880 --> 00:38:52,050
webassembly as an as an any ref right

00:38:49,000 --> 00:38:55,630
and you can put it on the stack okay

00:38:52,050 --> 00:38:57,010
then there is allocating an instance of

00:38:55,630 --> 00:38:59,890
state

00:38:57,010 --> 00:39:02,590
first you would put on the stack the the

00:38:59,890 --> 00:39:06,250
identifier that that's for the class

00:39:02,590 --> 00:39:08,350
states and then you put a null on the

00:39:06,250 --> 00:39:12,790
stack which will be the initial value of

00:39:08,350 --> 00:39:15,100
the of the points field and and then you

00:39:12,790 --> 00:39:19,030
call this this this operator from

00:39:15,100 --> 00:39:22,180
webassembly with with the GC proposal

00:39:19,030 --> 00:39:24,400
which is new and then you give the type

00:39:22,180 --> 00:39:26,740
of a struct and that will allocate a

00:39:24,400 --> 00:39:28,650
struct with the initial values taken

00:39:26,740 --> 00:39:31,270
from the stack and return you a

00:39:28,650 --> 00:39:34,450
reference to that struct another pointer

00:39:31,270 --> 00:39:36,250
a reference and then you can call the

00:39:34,450 --> 00:39:38,500
constructor which will take the

00:39:36,250 --> 00:39:42,640
reference fill in the cylinder and the

00:39:38,500 --> 00:39:44,380
fields etc so that's good and later when

00:39:42,640 --> 00:39:46,840
you want to create the land that that

00:39:44,380 --> 00:39:48,850
has captures and it has a capture of

00:39:46,840 --> 00:39:52,870
type States which is a JavaScript a

00:39:48,850 --> 00:39:55,030
Scala object and the reference div which

00:39:52,870 --> 00:39:58,060
is anything because it's a JavaScript

00:39:55,030 --> 00:40:01,210
thing you can actually do that you just

00:39:58,060 --> 00:40:03,340
have to well webassembly doesn't really

00:40:01,210 --> 00:40:05,170
know how to create captures for

00:40:03,340 --> 00:40:06,580
functions but that's okay you can write

00:40:05,170 --> 00:40:10,600
a JavaScript function they will capture

00:40:06,580 --> 00:40:12,790
things for you and you can call it and

00:40:10,600 --> 00:40:14,620
this is how you how you do it so

00:40:12,790 --> 00:40:16,630
basically if we have this this cheesy

00:40:14,620 --> 00:40:19,090
proposal at some point we will be able

00:40:16,630 --> 00:40:21,130
to encode all of Scala trees to

00:40:19,090 --> 00:40:25,230
webassembly with reference types and the

00:40:21,130 --> 00:40:28,480
GC proposal in a way that's correct and

00:40:25,230 --> 00:40:33,370
and that actually garbage collects which

00:40:28,480 --> 00:40:35,770
would be a good thing so when do we get

00:40:33,370 --> 00:40:38,560
this well first we need a reference

00:40:35,770 --> 00:40:40,450
types proposal which is at a stage

00:40:38,560 --> 00:40:43,800
called implementation stage currently

00:40:40,450 --> 00:40:47,280
for web assembly so that means the

00:40:43,800 --> 00:40:50,050
engines are encouraged to implement

00:40:47,280 --> 00:40:52,420
whatever the spec says at the moment so

00:40:50,050 --> 00:40:56,590
that we can get feedback on the proposal

00:40:52,420 --> 00:40:59,620
and so far as far as I know the the

00:40:56,590 --> 00:41:03,610
Firefox engine implements the current

00:40:59,620 --> 00:41:06,310
state of reference types then we need

00:41:03,610 --> 00:41:08,230
the GC proposal and that one is at a

00:41:06,310 --> 00:41:08,849
very early stage there is there isn't

00:41:08,230 --> 00:41:13,170
even a speck

00:41:08,849 --> 00:41:16,440
at this point it's ideas ideas for a

00:41:13,170 --> 00:41:19,650
type system more or less specified but

00:41:16,440 --> 00:41:23,819
not really so that will take some time

00:41:19,650 --> 00:41:26,880
and and then when that's done then then

00:41:23,819 --> 00:41:29,460
we can actually implement the the

00:41:26,880 --> 00:41:31,529
support in in SkyDrive or at least we

00:41:29,460 --> 00:41:33,479
hope to actually do that in empower with

00:41:31,529 --> 00:41:35,579
the development of G of the GC proposal

00:41:33,479 --> 00:41:40,229
so that we can feed back into the

00:41:35,579 --> 00:41:42,749
proposal if something is wrong for us so

00:41:40,229 --> 00:41:46,049
it will still take a while I'm sorry

00:41:42,749 --> 00:41:48,960
about that so that's all I had

00:41:46,049 --> 00:41:50,809
I'm happy to take one or two questions I

00:41:48,960 --> 00:42:03,359
think we have a few minutes

00:41:50,809 --> 00:42:06,960
thanks microphone is coming the filter

00:42:03,359 --> 00:42:08,430
question I'm wondering because there's

00:42:06,960 --> 00:42:10,229
another path that can be taken but I

00:42:08,430 --> 00:42:12,839
wonder what why you cannot be taken here

00:42:10,229 --> 00:42:14,369
for example maybe you saw what I think

00:42:12,839 --> 00:42:16,710
it's Asturias the name of the project

00:42:14,369 --> 00:42:18,660
which is a basically a THC back-end that

00:42:16,710 --> 00:42:21,690
goes to Azen and I think what they do

00:42:18,660 --> 00:42:24,269
that they sterilize the veil the values

00:42:21,690 --> 00:42:25,619
between is it because Sky's not

00:42:24,269 --> 00:42:32,400
referenced early transparent that you

00:42:25,619 --> 00:42:36,259
cannot do it there is yeah so so

00:42:32,400 --> 00:42:36,259
certainly if your language is entirely

00:42:36,589 --> 00:42:42,599
referentially transparent you can you

00:42:39,960 --> 00:42:44,219
can do that and you have an overall is

00:42:42,599 --> 00:42:47,160
that you have to implement in the wisdom

00:42:44,219 --> 00:42:50,069
but then you can say yeah I can but it's

00:42:47,160 --> 00:42:53,999
a bit of a lie though because what if

00:42:50,069 --> 00:42:57,719
you need to serialize a value of type I

00:42:53,999 --> 00:43:00,660
oh well you never do that well as scale

00:42:57,719 --> 00:43:03,839
you never you know yeah but the thing is

00:43:00,660 --> 00:43:05,489
like this is the kind of expressivity in

00:43:03,839 --> 00:43:07,829
terms of communicating with JavaScript

00:43:05,489 --> 00:43:11,819
that scholar J's has and that the

00:43:07,829 --> 00:43:14,309
language that doesn't doesn't have this

00:43:11,819 --> 00:43:15,989
this binary synchronous interoperability

00:43:14,309 --> 00:43:18,760
with JavaScript like everything you can

00:43:15,989 --> 00:43:22,030
do in Java you can do it in Scala trace

00:43:18,760 --> 00:43:24,940
if if you if you cannot serialize an IO

00:43:22,030 --> 00:43:27,340
basically a state in between two calls

00:43:24,940 --> 00:43:29,350
to JavaScript what would be a complete

00:43:27,340 --> 00:43:31,540
use case of that where you will need to

00:43:29,350 --> 00:43:34,750
send that to you the small snippet I

00:43:31,540 --> 00:43:38,109
showed earlier which interleaves calls

00:43:34,750 --> 00:43:40,300
to mutable JavaScript things and my own

00:43:38,109 --> 00:43:41,980
code and then calls again something from

00:43:40,300 --> 00:43:44,109
the JavaScript well then when you are in

00:43:41,980 --> 00:43:47,190
worsen how can you call the external

00:43:44,109 --> 00:43:49,450
world how can you launch a missile right

00:43:47,190 --> 00:43:51,609
you can do that because you can import

00:43:49,450 --> 00:43:54,100
Java functions which we did with the

00:43:51,609 --> 00:43:55,420
imports statement yes we called it yes

00:43:54,100 --> 00:43:58,600
but I mean if you take that path you

00:43:55,420 --> 00:44:03,100
take all the communication between that

00:43:58,600 --> 00:44:05,920
info interface right it's it gets it

00:44:03,100 --> 00:44:08,560
gets an unwieldy and at some point you

00:44:05,920 --> 00:44:10,420
realize you can't get everything right

00:44:08,560 --> 00:44:15,300
but if you want we can we don't talk

00:44:10,420 --> 00:44:22,450
further applying any other questions

00:44:15,300 --> 00:44:24,880
there at the back I serve estrin so I

00:44:22,450 --> 00:44:26,650
guess my question would be this what you

00:44:24,880 --> 00:44:28,900
presented would work but would what

00:44:26,650 --> 00:44:31,090
would be the advantage gained over the

00:44:28,900 --> 00:44:34,359
current encoding like is it worth the

00:44:31,090 --> 00:44:36,609
big change in encoding and possibly all

00:44:34,359 --> 00:44:38,140
the overheads for the all the stubs that

00:44:36,609 --> 00:44:39,940
you are forced to implement in order to

00:44:38,140 --> 00:44:42,630
just move to a different runtime versus

00:44:39,940 --> 00:44:45,580
what we already have now as a thinner

00:44:42,630 --> 00:44:47,170
translation to JavaScript I do what do

00:44:45,580 --> 00:44:49,090
you think of the relative pros and cons

00:44:47,170 --> 00:44:53,410
of the two approaches given that they

00:44:49,090 --> 00:44:56,470
both can work well nobody nobody really

00:44:53,410 --> 00:44:58,540
knows if you if you ask Brandon people

00:44:56,470 --> 00:45:03,700
on the internet they will say compared

00:44:58,540 --> 00:45:08,170
to web a somebody is going to be fast no

00:45:03,700 --> 00:45:10,000
that's not how it works if you compile C

00:45:08,170 --> 00:45:13,090
to web assembly is going to be fast

00:45:10,000 --> 00:45:16,960
relative to compiling C to to JavaScript

00:45:13,090 --> 00:45:20,380
because compared to C JavaScript has too

00:45:16,960 --> 00:45:23,130
many features and and recovering them

00:45:20,380 --> 00:45:25,750
from to the level of series is

00:45:23,130 --> 00:45:27,220
problematic so this is why web as me was

00:45:25,750 --> 00:45:29,380
invited in the first place which is

00:45:27,220 --> 00:45:30,090
going from City webassembly you don't

00:45:29,380 --> 00:45:33,690
have the

00:45:30,090 --> 00:45:37,890
mismatched were not losing thanks but

00:45:33,690 --> 00:45:39,480
you're also not gaining anything if you

00:45:37,890 --> 00:45:43,980
compare the garbage collected language

00:45:39,480 --> 00:45:46,320
to aggressively with the GC proposal

00:45:43,980 --> 00:45:49,140
hopefully you expect to not lose things

00:45:46,320 --> 00:45:50,670
and that's how you gain performance you

00:45:49,140 --> 00:45:53,070
only gain performance in webassembly

00:45:50,670 --> 00:45:55,770
because going from your social language

00:45:53,070 --> 00:45:58,200
you are not losing things so why would

00:45:55,770 --> 00:46:00,750
we not what things would we not lose

00:45:58,200 --> 00:46:03,270
well we wouldn't lose for example our

00:46:00,750 --> 00:46:05,490
types or these or monomorphic types the

00:46:03,270 --> 00:46:08,340
same the same kind of times we have on

00:46:05,490 --> 00:46:11,430
the JVM so as long as you're staying in

00:46:08,340 --> 00:46:13,410
your compute intensive for some portion

00:46:11,430 --> 00:46:16,380
of your program that only manipulates

00:46:13,410 --> 00:46:17,700
Scala types you remain in the realm of

00:46:16,380 --> 00:46:20,250
webassembly where everything is

00:46:17,700 --> 00:46:23,100
statically typed and in theory you can

00:46:20,250 --> 00:46:26,100
get something similar performance to the

00:46:23,100 --> 00:46:28,020
JVM except that of course JVM is going

00:46:26,100 --> 00:46:31,320
to do polymorphic inlining and that kind

00:46:28,020 --> 00:46:34,020
of things which in webassembly right now

00:46:31,320 --> 00:46:39,240
I still know go like you cannot you

00:46:34,020 --> 00:46:41,940
cannot do profile based optimizations at

00:46:39,240 --> 00:46:47,190
runtime like this is this this is not

00:46:41,940 --> 00:46:50,280
happening yet so I think what we can

00:46:47,190 --> 00:46:53,370
gain if if really all of this happens is

00:46:50,280 --> 00:46:56,160
for the large portions of scholarship

00:46:53,370 --> 00:47:02,220
programs that actually stay within the

00:46:56,160 --> 00:47:05,250
Scala subsets those will basically

00:47:02,220 --> 00:47:07,230
perform better but if you have a portion

00:47:05,250 --> 00:47:09,630
of your colleges programs as constantly

00:47:07,230 --> 00:47:12,480
talks to JavaScript back and forth that

00:47:09,630 --> 00:47:14,850
might actually lose performance because

00:47:12,480 --> 00:47:16,380
it would constantly like cross the

00:47:14,850 --> 00:47:17,880
boundary between web as a million Java

00:47:16,380 --> 00:47:20,910
scripts and depending on how that's

00:47:17,880 --> 00:47:22,380
implemented at the engine level we could

00:47:20,910 --> 00:47:24,600
lose performance or at least we won't

00:47:22,380 --> 00:47:26,250
gain anything that's that's definite

00:47:24,600 --> 00:47:28,079
case and then for things like virtual

00:47:26,250 --> 00:47:31,589
dispatch and

00:47:28,079 --> 00:47:34,170
and in lining of those things it's it's

00:47:31,589 --> 00:47:44,130
unclear the future is still very much

00:47:34,170 --> 00:47:45,599
uncertain at this point yeah thank you

00:47:44,130 --> 00:47:49,559
for the talk

00:47:45,599 --> 00:47:53,789
maybe a crazy question so do you think

00:47:49,559 --> 00:47:55,679
it's possible to to compile the GBM

00:47:53,789 --> 00:48:01,019
itself in webassembly

00:47:55,679 --> 00:48:04,469
yes it's been done so then this Karagias

00:48:01,019 --> 00:48:11,429
code can be can become bytecode and the

00:48:04,469 --> 00:48:15,209
gbesi gb M can interpret nope discolor

00:48:11,429 --> 00:48:17,819
JVM source codes can be combat code and

00:48:15,209 --> 00:48:20,160
can be interpreted by the JVM but again

00:48:17,819 --> 00:48:23,579
is the same problem as with Scala native

00:48:20,160 --> 00:48:25,529
it's a different language and if you

00:48:23,579 --> 00:48:27,269
write Scala JVM code you can call Java

00:48:25,529 --> 00:48:29,160
libraries but you cannot call JavaScript

00:48:27,269 --> 00:48:31,650
libraries you cannot manipulate the Dom

00:48:29,160 --> 00:48:35,249
you cannot manipulate your webpage you

00:48:31,650 --> 00:48:38,400
cannot use the zillions NPM packages out

00:48:35,249 --> 00:48:40,410
there so again it's important to go back

00:48:38,400 --> 00:48:42,900
to the semantics of your language

00:48:40,410 --> 00:48:45,269
and remember that Scala JVM scholar

00:48:42,900 --> 00:48:47,009
Jason Scala native or three different

00:48:45,269 --> 00:48:49,739
languages with different semantics and

00:48:47,009 --> 00:48:51,420
different capabilities and yes you can

00:48:49,739 --> 00:48:54,359
compile a JVM to web assembly and you

00:48:51,420 --> 00:48:56,609
can run Scala JVM code on that VM but

00:48:54,359 --> 00:49:05,390
you cannot run scholar J's code on that

00:48:56,609 --> 00:49:07,559
VM the last question thanks for a talk

00:49:05,390 --> 00:49:09,630
sounds very exciting and I look forward

00:49:07,559 --> 00:49:12,119
to things happening in webassembly so

00:49:09,630 --> 00:49:14,880
that they can also happen in in Scala

00:49:12,119 --> 00:49:18,599
yes I was wondering if on the language

00:49:14,880 --> 00:49:22,109
Scala language side we got effects would

00:49:18,599 --> 00:49:23,640
that improve the performance or expose

00:49:22,109 --> 00:49:25,079
opportunities for certain kinds of

00:49:23,640 --> 00:49:28,289
optimizations since we mentioned what

00:49:25,079 --> 00:49:30,209
GHC is able to do and also obviously

00:49:28,289 --> 00:49:32,939
garbage collection here is important so

00:49:30,209 --> 00:49:35,269
if you could establish that certain

00:49:32,939 --> 00:49:39,150
parts of code don't do certain things

00:49:35,269 --> 00:49:41,520
how much do you think this could help or

00:49:39,150 --> 00:49:46,369
to not of always optimize for worst case

00:49:41,520 --> 00:49:46,369
do you have funding for a PhD students I

00:49:49,070 --> 00:49:56,280
think it's it's a it's really a research

00:49:53,580 --> 00:49:58,470
topic I we don't know how to do how to

00:49:56,280 --> 00:50:01,320
do these things like given the current

00:49:58,470 --> 00:50:05,730
hardware and the currents of tomorrow's

00:50:01,320 --> 00:50:07,800
and it's still unclear what an effect

00:50:05,730 --> 00:50:11,280
system is actually able to provide in

00:50:07,800 --> 00:50:13,980
terms of of optimizations in general so

00:50:11,280 --> 00:50:18,540
let alone in the constrained environment

00:50:13,980 --> 00:50:21,840
of webassembly I think this is it's it's

00:50:18,540 --> 00:50:23,970
worth thinking about it but yeah as my

00:50:21,840 --> 00:50:29,340
initial answer suggested I think it's

00:50:23,970 --> 00:50:31,890
pretty worth an entire PhD yeah thanks

00:50:29,340 --> 00:50:37,250
okay I'll be happy to take further

00:50:31,890 --> 00:50:37,250
questions here or after the sock Thanks

00:50:37,970 --> 00:50:41,489

YouTube URL: https://www.youtube.com/watch?v=QsOHofFJpig


