Title: Develop seamless web services with Mu - Oli Makhasoeva
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/develop-seamless-web-services-with-mu
Captions: 
	00:00:00,030 --> 00:00:05,160
so have i oh thank you for coming this

00:00:02,190 --> 00:00:09,050
is the last session for today so thank

00:00:05,160 --> 00:00:12,990
you for surviving hopefully I won't take

00:00:09,050 --> 00:00:15,450
a lot of time so Dean your scholar

00:00:12,990 --> 00:00:17,630
lovers do you know what's gonna love

00:00:15,450 --> 00:00:21,060
this

00:00:17,630 --> 00:00:22,949
yes so for those who don't know scholar

00:00:21,060 --> 00:00:24,960
laughs is a podcast about Scala

00:00:22,949 --> 00:00:28,380
programming language and its community

00:00:24,960 --> 00:00:29,429
it's all about you people and I'm the

00:00:28,380 --> 00:00:32,219
host Olli

00:00:29,429 --> 00:00:38,010
so I hope to share some scholar laughs

00:00:32,219 --> 00:00:40,170
with you today so let's get started as I

00:00:38,010 --> 00:00:43,910
said I'm Olli and I work as a Solutions

00:00:40,170 --> 00:00:46,710
Architect at 47° consulting company

00:00:43,910 --> 00:00:49,710
we're focused on functional programming

00:00:46,710 --> 00:00:53,129
using Scala language and coupling and

00:00:49,710 --> 00:00:56,280
all related technologies and we help our

00:00:53,129 --> 00:00:58,920
clients and one of the areas that we

00:00:56,280 --> 00:01:01,379
focused on is web services and we'll

00:00:58,920 --> 00:01:04,799
build a beautiful framework for you

00:01:01,379 --> 00:01:08,310
called new in order to help you to build

00:01:04,799 --> 00:01:10,549
your micro services painlessly so when I

00:01:08,310 --> 00:01:12,990
was preparing this presentation

00:01:10,549 --> 00:01:15,210
initially I thought I would give you an

00:01:12,990 --> 00:01:17,520
introduction to service-oriented

00:01:15,210 --> 00:01:20,850
architecture to micro services through

00:01:17,520 --> 00:01:23,340
api's to rs2 HTTP or serialization

00:01:20,850 --> 00:01:25,740
formats but then I realized that you

00:01:23,340 --> 00:01:28,920
don't have to know that in order to use

00:01:25,740 --> 00:01:30,720
our library it's so simple you don't

00:01:28,920 --> 00:01:32,520
have to know anything actually it is

00:01:30,720 --> 00:01:35,610
functional but you don't have to know

00:01:32,520 --> 00:01:39,119
that have you ever had a Prada buff

00:01:35,610 --> 00:01:41,579
headache like you want to change field

00:01:39,119 --> 00:01:43,369
you want to remove filth you want to add

00:01:41,579 --> 00:01:46,350
that and then you have binary

00:01:43,369 --> 00:01:49,950
incompatibility and then all this

00:01:46,350 --> 00:01:51,659
generated code Adam just gave talk about

00:01:49,950 --> 00:01:56,219
concurrency and he was talking about

00:01:51,659 --> 00:01:59,159
things like monix akka or Zaya

00:01:56,219 --> 00:02:01,680
and that's what I want to use right but

00:01:59,159 --> 00:02:05,130
what I have now is that the generated

00:02:01,680 --> 00:02:08,849
code from my Prada or a ver has future

00:02:05,130 --> 00:02:13,580
the future to worry about nothing else

00:02:08,849 --> 00:02:16,670
and you allows you to AB cert over it

00:02:13,580 --> 00:02:19,970
so I want to go ahead and show how you

00:02:16,670 --> 00:02:22,130
do that so in order to define your first

00:02:19,970 --> 00:02:25,610
micro-service all you need to do is use

00:02:22,130 --> 00:02:28,550
these two annotations message this is

00:02:25,610 --> 00:02:29,960
the tact case class which eventually

00:02:28,550 --> 00:02:32,510
will be serialized

00:02:29,960 --> 00:02:34,790
deserialized sent by a network and this

00:02:32,510 --> 00:02:36,950
is will be your request or response and

00:02:34,790 --> 00:02:39,380
the service annotation which you put on

00:02:36,950 --> 00:02:42,410
a trade on your algebra and that's how

00:02:39,380 --> 00:02:44,720
you expose an operation and it will be

00:02:42,410 --> 00:02:49,900
publicly available while a network is

00:02:44,720 --> 00:02:53,210
that simple that's it no more protocol

00:02:49,900 --> 00:02:55,760
specific definition no more thinking oh

00:02:53,210 --> 00:02:59,840
my god I need to put attack is it used

00:02:55,760 --> 00:03:02,000
is it not nothing like that so and I

00:02:59,840 --> 00:03:05,300
encourage you to use this Gatorade

00:03:02,000 --> 00:03:07,480
template to start to build a new macro

00:03:05,300 --> 00:03:09,980
service on your local machine right now

00:03:07,480 --> 00:03:14,870
because that's that's that's super

00:03:09,980 --> 00:03:18,350
simple - come come on - comments is

00:03:14,870 --> 00:03:22,760
between you and server but you need to

00:03:18,350 --> 00:03:24,440
publish part of the service of that the

00:03:22,760 --> 00:03:26,780
generated cut would be available in a

00:03:24,440 --> 00:03:31,340
client as well and then you run the

00:03:26,780 --> 00:03:34,370
server so IE it didn't start did it now

00:03:31,340 --> 00:03:38,030
here you go so and the second command

00:03:34,370 --> 00:03:41,900
for the client which will be using the

00:03:38,030 --> 00:03:44,410
published artifact inside so this

00:03:41,900 --> 00:03:49,370
example is just a simple ping-pong game

00:03:44,410 --> 00:03:53,420
where client the signup beam and server

00:03:49,370 --> 00:03:57,709
responds with spawn very simple I don't

00:03:53,420 --> 00:03:59,959
super easy but let's take a look at how

00:03:57,709 --> 00:04:01,970
we build micro services when you're a

00:03:59,959 --> 00:04:03,950
building micro service which you really

00:04:01,970 --> 00:04:06,739
want to do is focus on your business

00:04:03,950 --> 00:04:10,400
logic on a core the thing that makes

00:04:06,739 --> 00:04:13,280
your project unique but instead you have

00:04:10,400 --> 00:04:15,290
to deal with transportation layer you

00:04:13,280 --> 00:04:18,530
have to look at the product calls RPC

00:04:15,290 --> 00:04:20,989
HTTP message brokers something else you

00:04:18,530 --> 00:04:23,270
have to look at the serialization jason

00:04:20,989 --> 00:04:27,320
ever prod about three if maybe something

00:04:23,270 --> 00:04:30,920
that you build in house before 47°

00:04:27,320 --> 00:04:33,830
Expedia and we had our own serialization

00:04:30,920 --> 00:04:37,580
format called Tesla it's open-source you

00:04:33,830 --> 00:04:41,300
can take a look but you don't have to

00:04:37,580 --> 00:04:45,350
basically when you add a comment there

00:04:41,300 --> 00:04:52,300
and you add a white space it will result

00:04:45,350 --> 00:04:54,890
in a new version not so funny

00:04:52,300 --> 00:04:57,200
also you need to look at the ways to

00:04:54,890 --> 00:04:59,750
profile the system login metrics

00:04:57,200 --> 00:05:01,280
instrument 8 really know what's inside

00:04:59,750 --> 00:05:03,800
system and you spend time on the

00:05:01,280 --> 00:05:05,930
integration was oldest framework which

00:05:03,800 --> 00:05:10,070
support HTTP or whatever you choose

00:05:05,930 --> 00:05:14,600
right and the problem is you need to

00:05:10,070 --> 00:05:18,010
decide what to use at the beginning at

00:05:14,600 --> 00:05:21,410
the earliest stage of the project and

00:05:18,010 --> 00:05:24,200
then the cost of the change will

00:05:21,410 --> 00:05:28,970
increase after a while because you

00:05:24,200 --> 00:05:32,180
deeply in your original choice and then

00:05:28,970 --> 00:05:35,180
say you're building your new shiny API

00:05:32,180 --> 00:05:38,270
what do you do research right you google

00:05:35,180 --> 00:05:42,530
it and you can find that it's widely

00:05:38,270 --> 00:05:44,980
discussed over Internet and you start to

00:05:42,530 --> 00:05:49,520
think okay the first thing is the

00:05:44,980 --> 00:05:53,020
message size I want to send as less

00:05:49,520 --> 00:05:55,430
bytes over network as possible right

00:05:53,020 --> 00:05:57,560
then how fast this is just saw relies

00:05:55,430 --> 00:06:00,370
you realize and things like that but

00:05:57,560 --> 00:06:03,440
then the requirements that you have

00:06:00,370 --> 00:06:06,650
initially might change the business

00:06:03,440 --> 00:06:08,630
might go in other direction where you

00:06:06,650 --> 00:06:12,680
might misunderstood something

00:06:08,630 --> 00:06:16,540
and now here you go you know that every

00:06:12,680 --> 00:06:20,630
would be more compact but it's too late

00:06:16,540 --> 00:06:23,090
it's really too late so we're trying to

00:06:20,630 --> 00:06:25,700
solve this problem but before I show you

00:06:23,090 --> 00:06:28,730
how to solve this I want to pawn on few

00:06:25,700 --> 00:06:30,980
things so if you take a look at the

00:06:28,730 --> 00:06:33,140
interface definition language although

00:06:30,980 --> 00:06:38,540
they are very different from each other

00:06:33,140 --> 00:06:40,490
they have things in common the first

00:06:38,540 --> 00:06:49,180
thing is

00:06:40,490 --> 00:06:55,220
a message another one is color types

00:06:49,180 --> 00:06:57,740
each ideal supports color types then

00:06:55,220 --> 00:07:01,569
optional well use car products or

00:06:57,740 --> 00:07:04,250
enumerations nested types as well

00:07:01,569 --> 00:07:06,669
collections and it's interesting in prod

00:07:04,250 --> 00:07:12,099
above there is no actual connection but

00:07:06,669 --> 00:07:15,250
collection but there is a keyword

00:07:12,099 --> 00:07:18,560
repeated which means that there will be

00:07:15,250 --> 00:07:20,990
repeated records which eventually you

00:07:18,560 --> 00:07:22,819
can combine and create a list of it or

00:07:20,990 --> 00:07:25,069
whatever you use in your language it's

00:07:22,819 --> 00:07:29,830
not miss trellis color right and the

00:07:25,069 --> 00:07:34,039
services the list of operations which

00:07:29,830 --> 00:07:36,979
will be exposed for your server so it's

00:07:34,039 --> 00:07:40,900
not specific to Prada or ever it's also

00:07:36,979 --> 00:07:47,990
true for thrived for open API json api

00:07:40,900 --> 00:07:50,060
json schema for all of them but still

00:07:47,990 --> 00:07:52,669
there there is a difference let's take a

00:07:50,060 --> 00:07:53,419
look at how how we actually encode the

00:07:52,669 --> 00:07:57,139
prod of us

00:07:53,419 --> 00:08:02,330
so each part of our field has a type

00:07:57,139 --> 00:08:06,979
annotation and field tag field tag is a

00:08:02,330 --> 00:08:11,270
number and if you take a look at this

00:08:06,979 --> 00:08:17,120
example it filled a has a type integer

00:08:11,270 --> 00:08:19,849
and number one then field name type of

00:08:17,120 --> 00:08:26,930
string has attacked two and there has to

00:08:19,849 --> 00:08:30,409
be unique so this tags are a compact way

00:08:26,930 --> 00:08:34,310
to refer to a specific field without

00:08:30,409 --> 00:08:34,849
having to spelling out the full name of

00:08:34,310 --> 00:08:37,909
it

00:08:34,849 --> 00:08:41,390
so in json for example if you call the

00:08:37,909 --> 00:08:44,630
field a and then rename it somehow then

00:08:41,390 --> 00:08:48,020
instead of a one byte it will take as

00:08:44,630 --> 00:08:51,920
many bytes as as as long as the length

00:08:48,020 --> 00:08:53,420
of your new name so we will send more

00:08:51,920 --> 00:08:56,990
information over a network

00:08:53,420 --> 00:08:58,820
whereas it's just the name doesn't have

00:08:56,990 --> 00:09:01,510
to be the same so how encoded

00:08:58,820 --> 00:09:07,490
information looks like the first byte 0

00:09:01,510 --> 00:09:13,550
8 is for tag and type combined then it's

00:09:07,490 --> 00:09:18,640
followed by the value so 96 0 9 is 150

00:09:13,550 --> 00:09:23,120
in variable sized integer notation

00:09:18,640 --> 00:09:28,070
I'm sending high to Martin which Martin

00:09:23,120 --> 00:09:31,730
can you guess then 12 is the same thing

00:09:28,070 --> 00:09:35,240
for string and it's tag followed by the

00:09:31,730 --> 00:09:39,050
size of the string Martin six letters

00:09:35,240 --> 00:09:43,310
and number six and then encoded so

00:09:39,050 --> 00:09:47,050
overall it took us eleven bytes to

00:09:43,310 --> 00:09:50,690
encode this so let's take a look at ever

00:09:47,050 --> 00:09:55,220
immediately you can see no tags and in

00:09:50,690 --> 00:09:59,270
fact this format does not use does not

00:09:55,220 --> 00:10:05,089
encode type information or tag

00:09:59,270 --> 00:10:08,300
information and it has downside both

00:10:05,089 --> 00:10:11,570
reader and writer has have to have the

00:10:08,300 --> 00:10:15,589
same schema otherwise they will not be

00:10:11,570 --> 00:10:17,000
able to read the message it's just

00:10:15,589 --> 00:10:18,650
impossible because you don't have enough

00:10:17,000 --> 00:10:20,420
information you don't know type you

00:10:18,650 --> 00:10:23,810
don't know tag you don't know name you

00:10:20,420 --> 00:10:27,620
don't know nothing but on the other side

00:10:23,810 --> 00:10:30,740
it took us 10 bytes this is a simple

00:10:27,620 --> 00:10:33,380
example I want to point that it's only

00:10:30,740 --> 00:10:37,160
two fields and the very short message

00:10:33,380 --> 00:10:38,750
but it's already 10% difference it can

00:10:37,160 --> 00:10:42,200
be more or less dependent on you get

00:10:38,750 --> 00:10:45,290
data but if you count that you have like

00:10:42,200 --> 00:10:46,940
million requests per second then you can

00:10:45,290 --> 00:10:49,070
understand that this is tremendous

00:10:46,940 --> 00:10:52,550
difference and that's why it's very

00:10:49,070 --> 00:10:57,260
important to pick the correct data

00:10:52,550 --> 00:10:59,870
serialization so of course I did not

00:10:57,260 --> 00:11:02,029
cover everything but I I just wanted to

00:10:59,870 --> 00:11:05,480
you to have some intuition why it's

00:11:02,029 --> 00:11:06,770
important and there is a great article

00:11:05,480 --> 00:11:10,339
about

00:11:06,770 --> 00:11:13,490
protocol comparison reason by marci and

00:11:10,339 --> 00:11:16,880
clapper I believe so I encourage you to

00:11:13,490 --> 00:11:19,970
check it out inside mu we use to

00:11:16,880 --> 00:11:24,310
libraries PB direct and other 4s which

00:11:19,970 --> 00:11:28,220
allows us to see relies directly from

00:11:24,310 --> 00:11:32,209
his classes from Scala classes to byte

00:11:28,220 --> 00:11:34,399
stream so we don't have to use protocol

00:11:32,209 --> 00:11:38,540
different dot product hours or every DL

00:11:34,399 --> 00:11:41,540
files it does exactly the the exercise

00:11:38,540 --> 00:11:45,020
that we did manually it has it

00:11:41,540 --> 00:11:47,089
automatically but I'm also running

00:11:45,020 --> 00:11:52,480
another podcast in Russian about Scala

00:11:47,089 --> 00:11:57,110
again yes yeah I love it

00:11:52,480 --> 00:11:59,510
whatever and one of my house started to

00:11:57,110 --> 00:12:03,500
ride this library called Juke of jukka

00:11:59,510 --> 00:12:08,990
visit marshal from Soviet Union and it's

00:12:03,500 --> 00:12:11,390
because it's marshal er yeah so he got

00:12:08,990 --> 00:12:16,700
frustrated a little bit that PB direct

00:12:11,390 --> 00:12:19,940
was it is it depends on google part of

00:12:16,700 --> 00:12:22,399
off library which means that it Cyril

00:12:19,940 --> 00:12:25,839
eyes it everything into byte stream but

00:12:22,399 --> 00:12:28,970
what he wanted is to use a courage to be

00:12:25,839 --> 00:12:33,680
which does not depend on byte stream so

00:12:28,970 --> 00:12:36,260
he would need to transform that whatever

00:12:33,680 --> 00:12:39,910
do my mapping and he didn't want that so

00:12:36,260 --> 00:12:44,600
he started this new project and he's a

00:12:39,910 --> 00:12:46,700
big fan of zero dependency libraries so

00:12:44,600 --> 00:12:50,570
it just saralidze ever seen in every

00:12:46,700 --> 00:12:53,270
bite and you can then transform that for

00:12:50,570 --> 00:12:57,709
whatever you want very flexible but it's

00:12:53,270 --> 00:12:59,870
early stages but still he uses a macro

00:12:57,709 --> 00:13:02,470
derivation instead of like generic

00:12:59,870 --> 00:13:05,750
programming which is used in others and

00:13:02,470 --> 00:13:09,140
if what I said does not make any sense

00:13:05,750 --> 00:13:13,579
for you the rhesus talk given by an

00:13:09,140 --> 00:13:18,550
adult omits summit last year in New York

00:13:13,579 --> 00:13:20,480
at Scala days he's a creator of Scala PB

00:13:18,550 --> 00:13:23,270
he was talking exactly

00:13:20,480 --> 00:13:28,000
this problem how to write the library

00:13:23,270 --> 00:13:35,840
which will serialize Scala classes into

00:13:28,000 --> 00:13:39,610
byte stream and he covers runtime

00:13:35,840 --> 00:13:39,610
reflection which is slow and painful

00:13:39,670 --> 00:13:51,860
generic programming shapeless then macro

00:13:46,150 --> 00:13:54,200
annotations and another example is

00:13:51,860 --> 00:13:57,140
serial it's kind of abundant but it's a

00:13:54,200 --> 00:14:04,100
good example of using scott ik library

00:13:57,140 --> 00:14:06,800
to just a license or li strict so let's

00:14:04,100 --> 00:14:12,770
go further now when we are almost

00:14:06,800 --> 00:14:14,180
experts we know that memory matters now

00:14:12,770 --> 00:14:18,350
we're going to take a look at

00:14:14,180 --> 00:14:23,200
performance so at 47 we asked ourself a

00:14:18,350 --> 00:14:27,890
hundred times what use our PC or HTTP

00:14:23,200 --> 00:14:30,350
HTTP or our PC to be or not to be and we

00:14:27,890 --> 00:14:33,170
built you probably ask the same question

00:14:30,350 --> 00:14:36,110
yourself we build the project called

00:14:33,170 --> 00:14:39,290
Metro Fire which is available under four

00:14:36,110 --> 00:14:44,930
to seven degrees it happen which is

00:14:39,290 --> 00:14:49,190
benchmark compares HTTP and point versus

00:14:44,930 --> 00:14:52,640
our PC Prada and point and our PC averin

00:14:49,190 --> 00:14:55,490
point yeah jerk PC can use whatever

00:14:52,640 --> 00:14:58,100
serialization format you give it but

00:14:55,490 --> 00:15:03,770
your business is just to provide a

00:14:58,100 --> 00:15:07,490
marshal err so here we can see it's on

00:15:03,770 --> 00:15:11,540
my local machine that our PC was Prada

00:15:07,490 --> 00:15:15,500
is much more faster is much faster than

00:15:11,540 --> 00:15:19,030
others then even a ver however we still

00:15:15,500 --> 00:15:24,650
twice as fast as HTTP over a standpoint

00:15:19,030 --> 00:15:27,280
this HTTP uses HTTP for s others use

00:15:24,650 --> 00:15:27,280
move

00:15:27,420 --> 00:15:34,750
but I I want to point that it does not

00:15:30,910 --> 00:15:37,270
mean that HTTP wrath should be

00:15:34,750 --> 00:15:39,420
deprecated there are still use cases

00:15:37,270 --> 00:15:45,100
there are technologists which make it

00:15:39,420 --> 00:15:49,270
better for usage like cache a lot of

00:15:45,100 --> 00:15:52,990
others so this is example on running the

00:15:49,270 --> 00:15:58,930
same thing on the Google cloud maybe

00:15:52,990 --> 00:16:01,870
it's more fair courtesy it's almost the

00:15:58,930 --> 00:16:05,800
same still different it's it's a fairly

00:16:01,870 --> 00:16:09,490
simple project probably everyone at

00:16:05,800 --> 00:16:13,120
least once had written it it's like

00:16:09,490 --> 00:16:17,080
create person create get person get info

00:16:13,120 --> 00:16:18,610
for person get list of person composed

00:16:17,080 --> 00:16:23,070
all of them we're a functional program

00:16:18,610 --> 00:16:23,070
we lacked composing we should check

00:16:24,180 --> 00:16:37,360
composition so that's how painful were

00:16:33,910 --> 00:16:40,720
how long the investigation usually takes

00:16:37,360 --> 00:16:43,960
and then you realize ok now I'm

00:16:40,720 --> 00:16:45,820
absolutely sure I'm using our PC with

00:16:43,960 --> 00:16:50,160
protobuf but then something changed and

00:16:45,820 --> 00:16:53,380
you were like oh my god no impossible I

00:16:50,160 --> 00:16:55,900
already stuck to a sprout above see the

00:16:53,380 --> 00:16:59,890
service annotation has one parameter for

00:16:55,900 --> 00:17:05,830
above I'm stuck I'm thinning love

00:16:59,890 --> 00:17:10,240
letters it's inaudible yeah so and this

00:17:05,830 --> 00:17:14,260
is a trick this is a trick how you

00:17:10,240 --> 00:17:16,630
change that for 2 hour with me simple

00:17:14,260 --> 00:17:19,180
I'm actually I don't know I'm impressed

00:17:16,630 --> 00:17:22,090
I haven't seen that before it's so easy

00:17:19,180 --> 00:17:27,910
I just changed one parameter indentation

00:17:22,090 --> 00:17:30,010
and here we go I can take an advantage

00:17:27,910 --> 00:17:34,320
of

00:17:30,010 --> 00:17:41,500
smaller side this message is right

00:17:34,320 --> 00:17:45,130
against Indian love letters what about

00:17:41,500 --> 00:17:48,340
the rest rest was mu relaxed was mu take

00:17:45,130 --> 00:17:51,730
a break with me huh I thought we should

00:17:48,340 --> 00:17:56,140
say something about library like have a

00:17:51,730 --> 00:18:00,730
fantastic day write in more scala while

00:17:56,140 --> 00:18:03,370
not writing her busy stuff not worry

00:18:00,730 --> 00:18:06,990
about this so say you have something

00:18:03,370 --> 00:18:10,840
which you are already exposed to our RPC

00:18:06,990 --> 00:18:13,420
using our right and you want to expel

00:18:10,840 --> 00:18:15,520
the same thing with space t to be it's

00:18:13,420 --> 00:18:17,620
often times it happens when you migrate

00:18:15,520 --> 00:18:20,530
something when you have different

00:18:17,620 --> 00:18:23,530
clients one of them once HTTP another

00:18:20,530 --> 00:18:28,210
one RPC for legacy problem or for

00:18:23,530 --> 00:18:32,920
whatever other things and we have

00:18:28,210 --> 00:18:36,670
another annotation for that HTTP so now

00:18:32,920 --> 00:18:39,130
it is available wine HTTP all you need

00:18:36,670 --> 00:18:42,820
to do here i want to point that the red

00:18:39,130 --> 00:18:47,470
lines are something from mu generated by

00:18:42,820 --> 00:18:49,540
me were part of new library so here it

00:18:47,470 --> 00:18:54,940
would generate a route and the client

00:18:49,540 --> 00:18:58,390
for you so you can use it and provide a

00:18:54,940 --> 00:19:03,220
host and port and write your business

00:18:58,390 --> 00:19:07,480
logic hello I'm oli and that's all you

00:19:03,220 --> 00:19:12,070
need to do HTTP stuff that's fascinating

00:19:07,480 --> 00:19:15,520
who's me so I want to make an overview

00:19:12,070 --> 00:19:20,680
of what made us so uncommunicative layer

00:19:15,520 --> 00:19:24,550
as the so we support your PC and REST

00:19:20,680 --> 00:19:26,680
API Anza realization JSON a ver and

00:19:24,550 --> 00:19:30,880
protocol buffers in it can be easily

00:19:26,680 --> 00:19:33,040
extent metrics it is important to know

00:19:30,880 --> 00:19:35,470
what's going on with your system right

00:19:33,040 --> 00:19:37,870
and it's really easy to integrate with

00:19:35,470 --> 00:19:40,300
fermius and drop is or which are the

00:19:37,870 --> 00:19:42,050
most important things over here for

00:19:40,300 --> 00:19:47,630
metrics i think

00:19:42,050 --> 00:19:49,850
then security streaming yes streaming we

00:19:47,630 --> 00:19:50,300
want to use FS to write the first three

00:19:49,850 --> 00:19:54,100
already

00:19:50,300 --> 00:19:57,140
I don't know and 1x observable and

00:19:54,100 --> 00:20:03,110
schema definition if you for some reason

00:19:57,140 --> 00:20:05,450
need further or a video file so far we

00:20:03,110 --> 00:20:07,400
didn't look at code much but I want us

00:20:05,450 --> 00:20:10,010
to know how to actually implement the

00:20:07,400 --> 00:20:13,220
service so let's take a look it's a

00:20:10,010 --> 00:20:15,860
simple example with which takes two

00:20:13,220 --> 00:20:20,450
integers and sum them and returns right

00:20:15,860 --> 00:20:25,690
so predictably unique to random business

00:20:20,450 --> 00:20:29,660
logic just sum them and trough inside us

00:20:25,690 --> 00:20:31,490
nothing fancy and here you need to

00:20:29,660 --> 00:20:36,410
provide implicit evidence that will be

00:20:31,490 --> 00:20:40,370
used later on math service dog line

00:20:36,410 --> 00:20:43,730
service is generated by mu and it

00:20:40,370 --> 00:20:47,450
provided service definition of what

00:20:43,730 --> 00:20:49,430
methods you have what types of parameter

00:20:47,450 --> 00:20:52,010
it takes and what it returns your

00:20:49,430 --> 00:20:55,100
request response in the method name and

00:20:52,010 --> 00:20:59,810
service just add that to prop that so

00:20:55,100 --> 00:21:04,550
that would be available for request

00:20:59,810 --> 00:21:07,340
registry then you build a server from

00:21:04,550 --> 00:21:09,290
this config and drop it inside your PC

00:21:07,340 --> 00:21:12,830
server dot server which provides a

00:21:09,290 --> 00:21:16,340
graceful shutdown for a server so this

00:21:12,830 --> 00:21:22,400
this is all you need to write your

00:21:16,340 --> 00:21:24,290
server so the blue one is something your

00:21:22,400 --> 00:21:27,640
business logic where your configuration

00:21:24,290 --> 00:21:30,440
that you have to provide the red one is

00:21:27,640 --> 00:21:32,930
something generated by mu the rest is

00:21:30,440 --> 00:21:34,930
more or less boilerplate but in

00:21:32,930 --> 00:21:38,230
comparison with other solutions it's

00:21:34,930 --> 00:21:38,230
much less

00:21:45,520 --> 00:21:54,100
so now we have server available on this

00:21:49,970 --> 00:21:57,700
port we want to build a client as well

00:21:54,100 --> 00:22:04,490
of course you need to provide a channel

00:21:57,700 --> 00:22:08,870
on the same port same host then again

00:22:04,490 --> 00:22:12,010
generated code client which you pass it

00:22:08,870 --> 00:22:15,890
for connection information and you

00:22:12,010 --> 00:22:18,290
receive a resource of your service and

00:22:15,890 --> 00:22:23,630
three source is the classroom Katz

00:22:18,290 --> 00:22:27,260
library it manages resources so that

00:22:23,630 --> 00:22:31,520
they would allocate they would be lazily

00:22:27,260 --> 00:22:35,780
allocated and it will get rid of it once

00:22:31,520 --> 00:22:37,970
it's no longer needed and this is your

00:22:35,780 --> 00:22:42,350
business logic you just say I use this

00:22:37,970 --> 00:22:44,120
service and Cole method on it it just

00:22:42,350 --> 00:22:45,650
happens to be that it's the only method

00:22:44,120 --> 00:22:49,420
but it could be something different

00:22:45,650 --> 00:22:53,480
right that's it

00:22:49,420 --> 00:22:57,400
server and client so testing can you

00:22:53,480 --> 00:23:00,440
imagine now someone can actually imagine

00:22:57,400 --> 00:23:07,100
enterprise system without testing but

00:23:00,440 --> 00:23:10,160
we're not like that so there is a method

00:23:07,100 --> 00:23:13,610
with service channel in muir pc test and

00:23:10,160 --> 00:23:17,060
package which allows which gives you a

00:23:13,610 --> 00:23:21,460
memory run an instance of certs of

00:23:17,060 --> 00:23:24,220
server so that he could test the

00:23:21,460 --> 00:23:29,000
communication was client without having

00:23:24,220 --> 00:23:33,140
any type of side effects here we pass a

00:23:29,000 --> 00:23:35,780
function to check the result the blue

00:23:33,140 --> 00:23:38,420
one but it can be anything it can be

00:23:35,780 --> 00:23:41,090
obstructed but the point is that it's in

00:23:38,420 --> 00:23:43,040
memory and very convenient and it's all

00:23:41,090 --> 00:23:46,840
possible because we use tagless final

00:23:43,040 --> 00:23:49,840
notation which abstracts you from effect

00:23:46,840 --> 00:23:52,970
and you focus on your business logic and

00:23:49,840 --> 00:23:54,020
can check everything without messing

00:23:52,970 --> 00:23:57,200
with network

00:23:54,020 --> 00:23:59,300
so we will never see your test failing

00:23:57,200 --> 00:24:01,880
because of network issues or anything

00:23:59,300 --> 00:24:04,400
and if you're not familiar with the

00:24:01,880 --> 00:24:08,150
tagless final and Destin was tagless

00:24:04,400 --> 00:24:10,010
final I grabbed a few links I really

00:24:08,150 --> 00:24:14,929
like it talk by Luca

00:24:10,010 --> 00:24:17,900
he gave it at lambda world 2018 and

00:24:14,929 --> 00:24:22,100
she's talking exactly about this how

00:24:17,900 --> 00:24:25,070
Telus final house to test stuff then I

00:24:22,100 --> 00:24:27,640
need to promote my meetups sorry I'm

00:24:25,070 --> 00:24:30,860
running meetup as well in Bell V

00:24:27,640 --> 00:24:33,380
Washington you say so come over if you

00:24:30,860 --> 00:24:37,460
were from there and John Durr goes gave

00:24:33,380 --> 00:24:40,010
this live coding session refactoring

00:24:37,460 --> 00:24:41,900
FP to the max refactoring from the

00:24:40,010 --> 00:24:44,740
imperative style to functional

00:24:41,900 --> 00:24:48,200
programming to tagless spinal

00:24:44,740 --> 00:24:51,160
step-by-step it's interesting and that's

00:24:48,200 --> 00:24:54,380
all based on this paper of a lack

00:24:51,160 --> 00:24:58,870
kiselev tagless panel where he

00:24:54,380 --> 00:25:02,240
introduced the approach but it's

00:24:58,870 --> 00:25:03,860
trending so if you're a teen scholar you

00:25:02,240 --> 00:25:05,870
probably want to know about that and

00:25:03,860 --> 00:25:11,390
please google there are a lot of

00:25:05,870 --> 00:25:14,390
articles blogs talks about that so it's

00:25:11,390 --> 00:25:16,730
easy to find anyway so say you're

00:25:14,390 --> 00:25:21,140
working with other teams which use other

00:25:16,730 --> 00:25:27,530
languages I don't know why they would do

00:25:21,140 --> 00:25:31,880
that he's ever since color yeah so and

00:25:27,530 --> 00:25:34,130
you you were given a product definition

00:25:31,880 --> 00:25:38,090
and you wanted to do

00:25:34,130 --> 00:25:42,230
Scala classes firm it so there is a way

00:25:38,090 --> 00:25:44,360
Moo has SBT plugin which allows you to

00:25:42,230 --> 00:25:46,370
generate exactly the same type of

00:25:44,360 --> 00:25:50,000
definition that was so before with

00:25:46,370 --> 00:25:53,450
annotations and never seen from Averell

00:25:50,000 --> 00:25:55,640
Prada or there are the way around if you

00:25:53,450 --> 00:25:59,140
were having someone who's writing in oh

00:25:55,640 --> 00:26:02,929
my god JavaScript you're giving them

00:25:59,140 --> 00:26:04,210
profile using this plug-in has two

00:26:02,929 --> 00:26:07,659
comments

00:26:04,210 --> 00:26:12,970
and it's all possible because we have

00:26:07,659 --> 00:26:14,369
another project called skew morph and in

00:26:12,970 --> 00:26:19,509
the beginning I was talking about

00:26:14,369 --> 00:26:23,049
communalities that all this schemas all

00:26:19,509 --> 00:26:26,169
this ideals have like messages option

00:26:23,049 --> 00:26:29,200
tag blah blah blah and it's canonical

00:26:26,169 --> 00:26:31,860
schema definition and going from this

00:26:29,200 --> 00:26:36,279
canonical schema definition we can

00:26:31,860 --> 00:26:40,509
generate other definitions and it's

00:26:36,279 --> 00:26:42,759
based on the recursion schemes so it's

00:26:40,509 --> 00:26:46,590
very abstract you don't have to mass

00:26:42,759 --> 00:26:51,159
with Traverse if you want to add your

00:26:46,590 --> 00:26:54,419
IDL you can go ahead and just say this

00:26:51,159 --> 00:26:57,389
type maps to this type in canonical

00:26:54,419 --> 00:27:00,159
schema definition in skeuomorph

00:26:57,389 --> 00:27:01,749
again if it doesn't make a lot of sense

00:27:00,159 --> 00:27:04,809
to you where this recursion scheme

00:27:01,749 --> 00:27:06,940
please check out the first episode of

00:27:04,809 --> 00:27:10,509
scallop with Valentin Costas he's

00:27:06,940 --> 00:27:11,230
basically obsessed with recursion

00:27:10,509 --> 00:27:14,820
schemes

00:27:11,230 --> 00:27:19,360
he's a maintainer of Ecology schema and

00:27:14,820 --> 00:27:22,360
gave a bunch of talks about that and in

00:27:19,360 --> 00:27:26,730
show notes you'll find a lot of useful

00:27:22,360 --> 00:27:29,830
links to that also check out droste it's

00:27:26,730 --> 00:27:35,080
it is used inside skew more for

00:27:29,830 --> 00:27:40,570
recursion schemes then I want to wrap up

00:27:35,080 --> 00:27:43,779
with answering the question why why we

00:27:40,570 --> 00:27:45,730
wanted to build that right we wanted to

00:27:43,779 --> 00:27:50,110
build something that will allow your

00:27:45,730 --> 00:27:53,139
rabbit API development just like that

00:27:50,110 --> 00:27:56,399
you have your algebra and you want to

00:27:53,139 --> 00:27:59,139
expel that just do that HTTP here you go

00:27:56,399 --> 00:28:02,619
very easy then we wanted it to be

00:27:59,139 --> 00:28:05,740
flexible available we want to adapt to

00:28:02,619 --> 00:28:08,169
changes that we have you know a business

00:28:05,740 --> 00:28:13,840
logic right then

00:28:08,169 --> 00:28:16,389
modular the magnitude of features that

00:28:13,840 --> 00:28:17,700
mu brings is huge we don't want to

00:28:16,389 --> 00:28:23,200
create a mass

00:28:17,700 --> 00:28:25,780
dependency how in your build so ever

00:28:23,200 --> 00:28:26,830
seen is modular you just add the modules

00:28:25,780 --> 00:28:33,360
that you want to use

00:28:26,830 --> 00:28:36,789
monix efforts to Nettie okay HTTP

00:28:33,360 --> 00:28:40,840
something else and it's very accessible

00:28:36,789 --> 00:28:45,990
again because it's modular five classes

00:28:40,840 --> 00:28:48,220
you know so you can add your own

00:28:45,990 --> 00:28:50,590
serialization format just need to

00:28:48,220 --> 00:28:52,750
provide a way how does realize this

00:28:50,590 --> 00:28:53,700
relies and then the rest will be done

00:28:52,750 --> 00:28:57,549
for you

00:28:53,700 --> 00:29:00,340
we're new transfer it we have an hour

00:28:57,549 --> 00:29:04,780
roadmap you Kafka and view Cassandra

00:29:00,340 --> 00:29:07,570
projects so soon I hope soon you'll be

00:29:04,780 --> 00:29:10,059
able to use that to with other type of

00:29:07,570 --> 00:29:13,289
transfers and testability is fashionable

00:29:10,059 --> 00:29:16,870
programming right everything is testable

00:29:13,289 --> 00:29:19,179
reliable so it's easy to test that's

00:29:16,870 --> 00:29:22,870
what we wanted and it's open source you

00:29:19,179 --> 00:29:26,860
know we use a lot of things in this

00:29:22,870 --> 00:29:29,890
project like macros or tag list final

00:29:26,860 --> 00:29:33,190
super fancy recursion schemes if you

00:29:29,890 --> 00:29:35,500
want to work on them just we're always

00:29:33,190 --> 00:29:39,130
working contributed or better we're

00:29:35,500 --> 00:29:46,740
hiring so you can be paint working on

00:29:39,130 --> 00:29:46,740
such amazing projects huh afterwards

00:29:46,770 --> 00:29:56,590
yeah and thank you please check out the

00:29:51,490 --> 00:29:59,850
MU website Harken s dot io / mu also we

00:29:56,590 --> 00:30:04,799
wrote a bunch of blog post about it on

00:29:59,850 --> 00:30:09,070
47° dot-com / blog follow me on Twitter

00:30:04,799 --> 00:30:12,659
Olie underscore Kitty and as I said

00:30:09,070 --> 00:30:17,020
around my skull laughs I host call us

00:30:12,659 --> 00:30:20,140
the true also mine meet up everything

00:30:17,020 --> 00:30:28,429
for you thank you for listening

00:30:20,140 --> 00:30:28,429
[Applause]

00:30:35,879 --> 00:30:41,259
okay so I have a few questions about the

00:30:38,769 --> 00:30:45,129
macro mechanics of this library so first

00:30:41,259 --> 00:30:48,340
of all there's a lot of micro notations

00:30:45,129 --> 00:30:51,850
and I wanted to ask if these annotations

00:30:48,340 --> 00:30:55,179
have support for type parameterised case

00:30:51,850 --> 00:31:00,879
classes and and synth carries so ADT in

00:30:55,179 --> 00:31:03,369
general and also there's reflection on

00:31:00,879 --> 00:31:06,220
interfaces going on in these micro

00:31:03,369 --> 00:31:10,029
annotations if I understand correctly so

00:31:06,220 --> 00:31:16,179
do you have any ideas or plans on how

00:31:10,029 --> 00:31:16,659
this is how how how is that going to

00:31:16,179 --> 00:31:19,600
work

00:31:16,659 --> 00:31:23,039
in spite of sky 3 coming so are there

00:31:19,600 --> 00:31:30,129
any possibly migration plans or vision

00:31:23,039 --> 00:31:32,230
so the first question is how our my

00:31:30,129 --> 00:31:38,710
current annotations work was firm tries

00:31:32,230 --> 00:31:40,749
classes right so the question is simply

00:31:38,710 --> 00:31:42,999
can you put an annotation on the type on

00:31:40,749 --> 00:31:46,779
a case class which has a generic will it

00:31:42,999 --> 00:31:50,529
work so for now it won't work but we're

00:31:46,779 --> 00:31:54,789
it's basically also because IDL's

00:31:50,529 --> 00:31:58,990
had their limitations right so it's hard

00:31:54,789 --> 00:32:01,570
to explain describe that define that in

00:31:58,990 --> 00:32:05,409
IDL but we're working on that and

00:32:01,570 --> 00:32:08,049
hopefully we will come up with some like

00:32:05,409 --> 00:32:12,669
link or whatever in code some kind of

00:32:08,049 --> 00:32:16,809
encoding or add options not options from

00:32:12,669 --> 00:32:18,820
scholar but options in the ideal prodded

00:32:16,809 --> 00:32:21,820
them so this is the first question and

00:32:18,820 --> 00:32:24,399
the second that was about reflection on

00:32:21,820 --> 00:32:26,710
interfaces done in macros and how's that

00:32:24,399 --> 00:32:29,019
how do you find to migrate this to scale

00:32:26,710 --> 00:32:31,799
3 because it looks like these these

00:32:29,019 --> 00:32:37,510
things are going to be missing

00:32:31,799 --> 00:32:52,570
absolutely but there is time to go and

00:32:37,510 --> 00:32:53,320
solve the problem thank you that was a

00:32:52,570 --> 00:32:56,380
great talk

00:32:53,320 --> 00:32:59,500
increasingly clients and servers are

00:32:56,380 --> 00:33:03,040
using WebSockets particularly allowing

00:32:59,500 --> 00:33:05,919
servers to push out to clients is that

00:33:03,040 --> 00:33:19,750
addressed or is that you know something

00:33:05,919 --> 00:33:22,030
you could put in you as well it's not if

00:33:19,750 --> 00:33:24,669
you are using your PC it also supports

00:33:22,030 --> 00:33:27,280
streaming I don't know if your support

00:33:24,669 --> 00:33:29,860
is streaming but you can the and then

00:33:27,280 --> 00:33:32,980
it's it's yeah if you're doing rest

00:33:29,860 --> 00:33:35,679
cause you want to do WebSocket so you go

00:33:32,980 --> 00:33:38,590
from each from from HTTP to WebSocket to

00:33:35,679 --> 00:33:41,470
do protocol change but if you are doing

00:33:38,590 --> 00:33:44,410
your PC your client is able to stream to

00:33:41,470 --> 00:33:47,309
the server using the stream tech

00:33:44,410 --> 00:33:50,200
knowledge that you are using your job

00:33:47,309 --> 00:33:53,440
and then I my question is when you are

00:33:50,200 --> 00:33:59,770
using your PC which streaming can you

00:33:53,440 --> 00:34:02,890
use can you can I choose but also it has

00:33:59,770 --> 00:34:05,970
some limitations if you use RPC was say

00:34:02,890 --> 00:34:09,909
ever which does not have notion of

00:34:05,970 --> 00:34:10,619
streaming in the language then it's just

00:34:09,909 --> 00:34:13,960
not possible

00:34:10,619 --> 00:34:16,720
yeah so it has limitations still but for

00:34:13,960 --> 00:34:18,760
a Prader and your PC it works fine and

00:34:16,720 --> 00:34:23,940
you can choose and then you choose the

00:34:18,760 --> 00:34:23,940
de streaming technology great

00:34:38,859 --> 00:34:44,739
all right stay happy guys thank you for

00:34:43,479 --> 00:34:48,099
coming

00:34:44,739 --> 00:34:48,099

YouTube URL: https://www.youtube.com/watch?v=NFB5hYTNYOE


