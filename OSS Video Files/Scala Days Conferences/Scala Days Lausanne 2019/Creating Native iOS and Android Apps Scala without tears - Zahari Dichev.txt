Title: Creating Native iOS and Android Apps Scala without tears - Zahari Dichev
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/creating-native-ios-and-android-apps-in-scala-without-tears
Captions: 
	00:00:00,030 --> 00:00:05,549
and this presentation is about creating

00:00:02,540 --> 00:00:07,200
1985's and Android apps in Scala and

00:00:05,549 --> 00:00:10,800
before we actually start with the

00:00:07,200 --> 00:00:14,420
presentation it's probably worth showing

00:00:10,800 --> 00:00:14,420
a very quick demo

00:00:42,010 --> 00:00:49,910
so these are two applications that

00:00:46,270 --> 00:00:51,830
effectively run on Android and iOS and

00:00:49,910 --> 00:00:55,070
the interesting part about it

00:00:51,830 --> 00:00:58,910
despite the fact that they're not really

00:00:55,070 --> 00:01:02,090
capable of doing much is that they are

00:00:58,910 --> 00:01:04,610
both written in Scala and not only that

00:01:02,090 --> 00:01:07,540
but they're effectively crud

00:01:04,610 --> 00:01:09,860
applications and there is a back-end

00:01:07,540 --> 00:01:14,479
service also written in Scala that's

00:01:09,860 --> 00:01:17,800
running in the background so now you can

00:01:14,479 --> 00:01:20,000
do simple things like delete an entry

00:01:17,800 --> 00:01:23,570
refresh here and obviously that's going

00:01:20,000 --> 00:01:32,140
to reflect into the other app and you

00:01:23,570 --> 00:01:35,979
can also access things like photos and

00:01:32,140 --> 00:01:35,979
add new entries

00:01:43,350 --> 00:01:49,290
and all of that will be shared across

00:01:45,690 --> 00:01:51,240
the back end and again the the

00:01:49,290 --> 00:01:53,520
interesting part about all of that is

00:01:51,240 --> 00:01:58,050
that it's all Scala code and even the

00:01:53,520 --> 00:02:03,410
details that are exchanged even details

00:01:58,050 --> 00:02:06,290
that are exchanged through through the

00:02:03,410 --> 00:02:08,340
through the back end are effectively

00:02:06,290 --> 00:02:12,590
Scala objects and they are shared

00:02:08,340 --> 00:02:17,700
between the server and the client

00:02:12,590 --> 00:02:20,280
so this this talk was actually called

00:02:17,700 --> 00:02:22,530
native iOS and Android apps in Scala

00:02:20,280 --> 00:02:26,100
without tears but I had to amend the

00:02:22,530 --> 00:02:28,640
title because it turned out when we were

00:02:26,100 --> 00:02:31,440
actually writing all of that it's I

00:02:28,640 --> 00:02:37,890
don't know that it really wasn't without

00:02:31,440 --> 00:02:40,110
much tears so as a matter of fact let's

00:02:37,890 --> 00:02:42,480
actually look at how all of that is

00:02:40,110 --> 00:02:46,500
possible and and and and what's the

00:02:42,480 --> 00:02:50,930
roles we talk we we took in order to get

00:02:46,500 --> 00:02:50,930
to that point I think I just need to

00:02:54,110 --> 00:03:00,200
kind of set up my presenter screen here

00:03:10,099 --> 00:03:23,389
yeah well anyway so really imagine that

00:03:21,530 --> 00:03:25,730
you are putting in a situation where you

00:03:23,389 --> 00:03:27,739
are a team of developers and you want to

00:03:25,730 --> 00:03:32,510
have yourself a mobile application right

00:03:27,739 --> 00:03:34,189
and there are a few ways that a few

00:03:32,510 --> 00:03:37,659
different ways that you can that you can

00:03:34,189 --> 00:03:41,209
go about that one of them is to go the

00:03:37,659 --> 00:03:43,700
native way and respect the right your

00:03:41,209 --> 00:03:46,760
version for iOS and Android and on

00:03:43,700 --> 00:03:50,329
androids you benefit from using Java or

00:03:46,760 --> 00:03:54,169
Kotlin it sits there stones of know how

00:03:50,329 --> 00:03:55,699
to and support in the community and you

00:03:54,169 --> 00:03:57,199
end up with native looking applications

00:03:55,699 --> 00:03:59,449
that play nicely with the under

00:03:57,199 --> 00:04:01,370
underlying platform not only that but

00:03:59,449 --> 00:04:04,010
you're running on a mature VM that

00:04:01,370 --> 00:04:07,340
that's you're probably all quite

00:04:04,010 --> 00:04:09,949
familiar with you're running the JVM on

00:04:07,340 --> 00:04:13,549
iOS you end up writing your code in

00:04:09,949 --> 00:04:16,459
objective-c or Swift and you benefit

00:04:13,549 --> 00:04:19,310
from great development workflow you're

00:04:16,459 --> 00:04:21,289
writing in Xcode probably so it's quite

00:04:19,310 --> 00:04:24,979
mature and well known IDE that that's

00:04:21,289 --> 00:04:26,479
also I I actually quite liked and of

00:04:24,979 --> 00:04:28,220
course you have the added benefit that

00:04:26,479 --> 00:04:30,770
your runtime is tailored towards

00:04:28,220 --> 00:04:33,320
particular range of devices because you

00:04:30,770 --> 00:04:35,990
know Apple just has sort of a limited

00:04:33,320 --> 00:04:38,270
range of devices of hardware that it

00:04:35,990 --> 00:04:42,680
produces unlike with Android and of

00:04:38,270 --> 00:04:45,229
course because you are because you're

00:04:42,680 --> 00:04:48,680
running on Apple and Apple take security

00:04:45,229 --> 00:04:50,330
very very seriously so you benefit on of

00:04:48,680 --> 00:04:54,169
that as well and this is especially

00:04:50,330 --> 00:04:57,349
important if you are in a sort of a more

00:04:54,169 --> 00:04:58,909
corporate domain so what are some of the

00:04:57,349 --> 00:04:59,389
drawbacks though of this particular

00:04:58,909 --> 00:05:01,490
approach

00:04:59,389 --> 00:05:04,669
well first of all introducing a new

00:05:01,490 --> 00:05:09,289
language or two can be quite challenge

00:05:04,669 --> 00:05:11,090
in teams that are if you don't have the

00:05:09,289 --> 00:05:13,310
capacity to hire more people and you

00:05:11,090 --> 00:05:16,789
need people to learn new languages that

00:05:13,310 --> 00:05:19,039
that can be a bit hard also going back

00:05:16,789 --> 00:05:22,190
to an old language so if you're well old

00:05:19,039 --> 00:05:23,630
if you're a scholar shop and that it

00:05:22,190 --> 00:05:24,020
could be quite demoralizing for some

00:05:23,630 --> 00:05:26,630
people

00:05:24,020 --> 00:05:29,420
she write Java code in case they want to

00:05:26,630 --> 00:05:31,490
do Android and you know but the biggest

00:05:29,420 --> 00:05:33,410
problem is probably the fact that you

00:05:31,490 --> 00:05:35,690
pretty much end up having this joint

00:05:33,410 --> 00:05:39,200
code bases so you end up implementing

00:05:35,690 --> 00:05:41,630
the same feature twice most likely for

00:05:39,200 --> 00:05:46,190
Android on iOS for example and all that

00:05:41,630 --> 00:05:48,290
gets even more painful if your client

00:05:46,190 --> 00:05:50,570
logic so if your app logic is quite

00:05:48,290 --> 00:05:54,860
complicated so in our particular case

00:05:50,570 --> 00:05:57,860
our our application was offline capable

00:05:54,860 --> 00:06:00,620
so it had quite a bit of had quite a bit

00:05:57,860 --> 00:06:02,270
of logic around eventually syncing with

00:06:00,620 --> 00:06:05,180
the backend so a lot of conflict

00:06:02,270 --> 00:06:06,560
resolution logic written that was not

00:06:05,180 --> 00:06:08,780
very trivial and maintaining that

00:06:06,560 --> 00:06:11,240
codebase in two different languages can

00:06:08,780 --> 00:06:13,730
quickly become quite the bottleneck so

00:06:11,240 --> 00:06:16,670
what is what is another thing that you

00:06:13,730 --> 00:06:18,890
can that you can do you can sort of turn

00:06:16,670 --> 00:06:20,510
turn yourself towards using technologies

00:06:18,890 --> 00:06:22,370
such as growl and you probably are all

00:06:20,510 --> 00:06:24,860
familiar with that but just to summarize

00:06:22,370 --> 00:06:27,470
growl is a high performance jet compiler

00:06:24,860 --> 00:06:30,230
that is written in Java and if screw

00:06:27,470 --> 00:06:32,990
hooks through the JVM JVM CI interface

00:06:30,230 --> 00:06:36,440
and on top of that you have substrate VI

00:06:32,990 --> 00:06:38,360
and that is that allows you completion

00:06:36,440 --> 00:06:43,670
of Java programs into self-contained

00:06:38,360 --> 00:06:45,770
executables and as a matter of fact the

00:06:43,670 --> 00:06:48,200
native image support for that can pretty

00:06:45,770 --> 00:06:51,800
much work with jvm languages like Java

00:06:48,200 --> 00:06:55,970
Scala and closure and because the arm 64

00:06:51,800 --> 00:06:58,910
support is currently being worked on you

00:06:55,970 --> 00:07:02,390
pretty much can write code in Java and

00:06:58,910 --> 00:07:03,950
run it on iOS and this is this is

00:07:02,390 --> 00:07:06,500
actually quite nice so it's incredibly

00:07:03,950 --> 00:07:07,880
powerful technology however when we were

00:07:06,500 --> 00:07:09,620
at the time when we were considering

00:07:07,880 --> 00:07:14,390
that we there were some drawbacks that

00:07:09,620 --> 00:07:17,090
that we that that we saw and namely one

00:07:14,390 --> 00:07:18,920
of them was the fact that at that point

00:07:17,090 --> 00:07:20,840
the ecosystem around ours iOS support

00:07:18,920 --> 00:07:23,060
was pretty much non-existent so you

00:07:20,840 --> 00:07:25,070
don't only need to compile some code and

00:07:23,060 --> 00:07:27,950
run it on on a phone that prints hello

00:07:25,070 --> 00:07:30,050
world but you kind of need to have a

00:07:27,950 --> 00:07:32,170
mature UI framework that you can use in

00:07:30,050 --> 00:07:36,530
order to design your applications and

00:07:32,170 --> 00:07:38,600
and kind of structure them in a good way

00:07:36,530 --> 00:07:40,550
so at that point in time that was that

00:07:38,600 --> 00:07:42,230
was not really present and there were

00:07:40,550 --> 00:07:45,280
some other restrictions that I'm not

00:07:42,230 --> 00:07:49,250
going to go into much detail into but

00:07:45,280 --> 00:07:52,010
you know reflection well dynamic class

00:07:49,250 --> 00:07:54,020
loading is not really always possible if

00:07:52,010 --> 00:07:55,490
you don't know in advance so the other

00:07:54,020 --> 00:07:57,200
other things that are going to be loaded

00:07:55,490 --> 00:07:59,300
so there are some limitations there that

00:07:57,200 --> 00:08:01,280
in practice are not that big but the

00:07:59,300 --> 00:08:03,020
main point was that work was still

00:08:01,280 --> 00:08:05,180
undergoing in that space and there was

00:08:03,020 --> 00:08:07,130
not really a mature ecosystem but this

00:08:05,180 --> 00:08:08,900
is changing so I advise you to actually

00:08:07,130 --> 00:08:10,490
go and check out the gravity and talk

00:08:08,900 --> 00:08:12,830
that's later in this conference and I

00:08:10,490 --> 00:08:15,620
think they've made amazing progress and

00:08:12,830 --> 00:08:19,790
this is a space that deserves being

00:08:15,620 --> 00:08:23,240
watched so another another opportunity

00:08:19,790 --> 00:08:25,790
that you can obviously kind of look at

00:08:23,240 --> 00:08:27,440
is hybrid solutions right so hybrid

00:08:25,790 --> 00:08:29,780
mobile applications are effectively

00:08:27,440 --> 00:08:32,630
mobile apps they're web apps in these

00:08:29,780 --> 00:08:34,850
guys right so what you end up using is

00:08:32,630 --> 00:08:38,900
the usual run-of-the-mill web stack like

00:08:34,850 --> 00:08:40,910
JavaScript CSS and HTML and they run in

00:08:38,900 --> 00:08:42,680
a webview running pretty much the same

00:08:40,910 --> 00:08:45,820
code on every platform and on some

00:08:42,680 --> 00:08:48,170
platform like iOS they can benefit from

00:08:45,820 --> 00:08:50,920
some platform specific optimizations

00:08:48,170 --> 00:08:54,500
like the neutral JavaScript JIT compiler

00:08:50,920 --> 00:08:57,020
but nevertheless these are effectively

00:08:54,500 --> 00:09:01,520
web applications that are running on the

00:08:57,020 --> 00:09:03,590
phone right and as a matter of fact one

00:09:01,520 --> 00:09:05,240
thing that you can probably see quite

00:09:03,590 --> 00:09:08,210
often in that space is the combination

00:09:05,240 --> 00:09:09,500
of Cordova plus ionic and some of the

00:09:08,210 --> 00:09:12,500
parts that make up such an application

00:09:09,500 --> 00:09:14,570
are the Cordova webview which is where

00:09:12,500 --> 00:09:16,130
the application actually renders so this

00:09:14,570 --> 00:09:18,830
is sort of like a web browser in these

00:09:16,130 --> 00:09:20,600
guys and then you have the web app which

00:09:18,830 --> 00:09:23,930
pretty much contains over JavaScript

00:09:20,600 --> 00:09:26,510
logic does the assets HTML and CSS and

00:09:23,930 --> 00:09:28,250
then you have Cordova plugins that are

00:09:26,510 --> 00:09:30,170
effectively plugins that hook into the

00:09:28,250 --> 00:09:32,050
native functionality of the underlying

00:09:30,170 --> 00:09:36,320
platform so you can access stuff like

00:09:32,050 --> 00:09:39,350
camera sensors and whatnot and then you

00:09:36,320 --> 00:09:41,330
most likely end up implementing your app

00:09:39,350 --> 00:09:42,920
using the ionic framework which is a set

00:09:41,330 --> 00:09:47,790
of front-end components that try to

00:09:42,920 --> 00:09:52,440
mimic the way the way native

00:09:47,790 --> 00:09:54,390
UI components look like and you know

00:09:52,440 --> 00:09:56,220
from a schematic point of view like if

00:09:54,390 --> 00:09:58,860
you look up that combination you'll

00:09:56,220 --> 00:10:00,750
probably see a picture that looks like

00:09:58,860 --> 00:10:02,520
this you have the web app and the

00:10:00,750 --> 00:10:05,930
plugins of the sites that you can that

00:10:02,520 --> 00:10:08,730
you can tap into in order to access

00:10:05,930 --> 00:10:11,090
functionality and and and the web app is

00:10:08,730 --> 00:10:15,000
rendered in the HTML rendering view

00:10:11,090 --> 00:10:17,520
however some of the cons that that that

00:10:15,000 --> 00:10:19,320
this brings is the fact that you might

00:10:17,520 --> 00:10:24,930
very well have some performance problems

00:10:19,320 --> 00:10:27,330
on other phones and you also are limited

00:10:24,930 --> 00:10:31,080
to the native functionality that's

00:10:27,330 --> 00:10:34,320
provided by plugins and from my research

00:10:31,080 --> 00:10:36,930
a little while ago I not all of the

00:10:34,320 --> 00:10:39,020
plugins are quite up to date so you're

00:10:36,930 --> 00:10:41,910
kind of relying on a lot of third-party

00:10:39,020 --> 00:10:43,890
stuff that that's in the ecosystem and

00:10:41,910 --> 00:10:45,330
of course as you might imagine this is

00:10:43,890 --> 00:10:48,270
not really suited for high end graphics

00:10:45,330 --> 00:10:50,550
after all this particular these

00:10:48,270 --> 00:10:54,210
particular technologies for web

00:10:50,550 --> 00:10:57,300
applications and it's also there is this

00:10:54,210 --> 00:10:59,850
thing that's not necessarily a that's

00:10:57,300 --> 00:11:02,550
not necessarily a drawback it's a bit

00:10:59,850 --> 00:11:04,860
hard to get that feel quite native from

00:11:02,550 --> 00:11:07,020
what I've seen but this of course is not

00:11:04,860 --> 00:11:10,590
always bad because there are great apps

00:11:07,020 --> 00:11:12,930
that that are actually such as Spotify

00:11:10,590 --> 00:11:15,090
for example kora they are great apps

00:11:12,930 --> 00:11:17,220
they don't look native at all but

00:11:15,090 --> 00:11:21,510
nevertheless they work and they're very

00:11:17,220 --> 00:11:24,210
nice to use so another thing that you

00:11:21,510 --> 00:11:26,700
might consider as using react native

00:11:24,210 --> 00:11:28,560
write and react native is a pretty great

00:11:26,700 --> 00:11:31,500
framework that allows developers to

00:11:28,560 --> 00:11:33,920
build native applications using

00:11:31,500 --> 00:11:37,440
javascript and while Cordova actually

00:11:33,920 --> 00:11:40,020
runs inside a webview react native is

00:11:37,440 --> 00:11:42,630
using native UI components in the hood

00:11:40,020 --> 00:11:44,880
for the respective platform so for

00:11:42,630 --> 00:11:46,770
example a next native text input for iOS

00:11:44,880 --> 00:11:52,080
and Android will have a corresponding

00:11:46,770 --> 00:11:54,390
react native component that will that

00:11:52,080 --> 00:11:57,360
that you interact with in JavaScript and

00:11:54,390 --> 00:12:00,150
it you delegate and it delegates to the

00:11:57,360 --> 00:12:01,680
native components so in essence there is

00:12:00,150 --> 00:12:03,480
no compilation of Java

00:12:01,680 --> 00:12:06,600
tripped into native code base into

00:12:03,480 --> 00:12:12,690
native codes on the device and there is

00:12:06,600 --> 00:12:14,310
no way view HTML or CSS so pretty much

00:12:12,690 --> 00:12:16,470
the big picture is that you end up with

00:12:14,310 --> 00:12:18,330
sort of a towards the worlds that are

00:12:16,470 --> 00:12:20,190
connected you have your native code the

00:12:18,330 --> 00:12:22,709
modules that are written in objective-c

00:12:20,190 --> 00:12:24,959
or Swift or Java and then on the other

00:12:22,709 --> 00:12:28,709
head you on the other hand you have a

00:12:24,959 --> 00:12:30,720
very lightweight JavaScript VM which

00:12:28,709 --> 00:12:32,940
runs the JavaScript code that you have

00:12:30,720 --> 00:12:34,470
written and these two worlds communicate

00:12:32,940 --> 00:12:36,630
over the react native bridge which is a

00:12:34,470 --> 00:12:38,640
component that's responsible for between

00:12:36,630 --> 00:12:41,970
the for the communication between these

00:12:38,640 --> 00:12:44,250
two threads so what happens when you

00:12:41,970 --> 00:12:46,770
actually run an app our react native app

00:12:44,250 --> 00:12:49,440
well a bundler pretty much packages es

00:12:46,770 --> 00:12:51,690
code into a single JS file and applies

00:12:49,440 --> 00:12:53,970
some transformations on it then the

00:12:51,690 --> 00:12:57,510
entry point is loaded on your device and

00:12:53,970 --> 00:13:00,089
that spawns the JavaScript VM thread and

00:12:57,510 --> 00:13:01,290
then the JavaScript the JavaScript VM

00:13:00,089 --> 00:13:03,570
threads and the native thread

00:13:01,290 --> 00:13:05,190
communicate over the bridge so if you

00:13:03,570 --> 00:13:06,660
have to draw it it kind of looks a bit

00:13:05,190 --> 00:13:08,190
like this you have these two words that

00:13:06,660 --> 00:13:10,589
are that are connected by the bridge

00:13:08,190 --> 00:13:16,200
that's passing messages in by a

00:13:10,589 --> 00:13:18,300
proprietary protocol so how does an

00:13:16,200 --> 00:13:20,940
actual react native app look like from

00:13:18,300 --> 00:13:21,930
sort of a anatomy perspective well it's

00:13:20,940 --> 00:13:23,640
first of all it's important to

00:13:21,930 --> 00:13:26,940
understand some of the concepts around

00:13:23,640 --> 00:13:29,339
react native react native apps are built

00:13:26,940 --> 00:13:31,770
of components and that's what's the

00:13:29,339 --> 00:13:34,860
building block of applications and these

00:13:31,770 --> 00:13:37,020
components encompass props States and

00:13:34,860 --> 00:13:38,700
the render logic and then we have the

00:13:37,020 --> 00:13:41,820
render logic which is pretty much a

00:13:38,700 --> 00:13:44,839
function of state and props and it as a

00:13:41,820 --> 00:13:46,940
matter of fact defines how your how your

00:13:44,839 --> 00:13:50,370
what's going to be rendered on screen

00:13:46,940 --> 00:13:51,690
props are much like constructor

00:13:50,370 --> 00:13:54,570
arguments that they allow you to

00:13:51,690 --> 00:13:56,820
parametrize to parameterize your

00:13:54,570 --> 00:13:59,190
components but they're a bit smarter

00:13:56,820 --> 00:14:03,270
because react native uses them in order

00:13:59,190 --> 00:14:05,339
to do some smart defend the render logic

00:14:03,270 --> 00:14:06,930
and then you have state which is the

00:14:05,339 --> 00:14:09,950
internal state of the component at any

00:14:06,930 --> 00:14:12,510
point that will be mutated unlike props

00:14:09,950 --> 00:14:14,550
so it could be imitated by input from

00:14:12,510 --> 00:14:15,360
the user and whatnot and whenever that

00:14:14,550 --> 00:14:16,980
state is maintained

00:14:15,360 --> 00:14:18,630
it's most of the time the result of that

00:14:16,980 --> 00:14:21,480
is the revaluation of the render

00:14:18,630 --> 00:14:23,730
function and then you also have style

00:14:21,480 --> 00:14:25,470
which is a special prop that most of the

00:14:23,730 --> 00:14:28,829
core components taken kind of defines

00:14:25,470 --> 00:14:30,690
how your components look like so how

00:14:28,829 --> 00:14:33,709
does a very simple component look like

00:14:30,690 --> 00:14:37,649
this is this is sort of a this is a

00:14:33,709 --> 00:14:39,329
JavaScript code there's gonna be Scala

00:14:37,649 --> 00:14:41,220
later I promise

00:14:39,329 --> 00:14:44,640
that that defines a very simple

00:14:41,220 --> 00:14:47,220
component that pretty much defines two

00:14:44,640 --> 00:14:49,410
children components a text input where

00:14:47,220 --> 00:14:51,029
you can type some text and then the text

00:14:49,410 --> 00:14:55,850
box that's gonna reflect what you've

00:14:51,029 --> 00:14:58,440
typed right and there is there is a

00:14:55,850 --> 00:15:00,480
callback function on the text input that

00:14:58,440 --> 00:15:02,010
pretty much does a state update so

00:15:00,480 --> 00:15:04,230
updates the state of the component with

00:15:02,010 --> 00:15:06,240
what you've just entered and when that

00:15:04,230 --> 00:15:08,550
happens your render function is

00:15:06,240 --> 00:15:10,680
reevaluated so you're showing now the

00:15:08,550 --> 00:15:14,730
new the new the new stuff on screen that

00:15:10,680 --> 00:15:16,440
you've entered so if you want to think

00:15:14,730 --> 00:15:17,970
about it from a dataflow perspective it

00:15:16,440 --> 00:15:19,829
it kind of looks like this you have the

00:15:17,970 --> 00:15:22,370
route component and then the state is

00:15:19,829 --> 00:15:25,170
passed as props so your initial state is

00:15:22,370 --> 00:15:28,170
initiated based on these props and then

00:15:25,170 --> 00:15:30,680
props are passed down to the inputs when

00:15:28,170 --> 00:15:34,620
the input modifies the state it calls

00:15:30,680 --> 00:15:36,089
set state via the callback and then this

00:15:34,620 --> 00:15:37,860
triggers three evaluation of the root

00:15:36,089 --> 00:15:43,170
component render function and effect the

00:15:37,860 --> 00:15:44,670
stuff changes on screen so if you think

00:15:43,170 --> 00:15:46,260
about it so far we have a pretty mature

00:15:44,670 --> 00:15:47,790
technology that's giving you quite a bit

00:15:46,260 --> 00:15:49,920
of power for creating native apps

00:15:47,790 --> 00:15:51,540
because you're using native native

00:15:49,920 --> 00:15:53,730
components underneath there is sensible

00:15:51,540 --> 00:15:54,930
performance because these native

00:15:53,730 --> 00:15:57,959
components have been engineered

00:15:54,930 --> 00:15:59,550
particularly for this platform and you

00:15:57,959 --> 00:16:03,320
also have easy access to the platform

00:15:59,550 --> 00:16:05,850
native functionalities of the device so

00:16:03,320 --> 00:16:07,920
in on top of that you're developing in

00:16:05,850 --> 00:16:09,839
JavaScript so by that time we already

00:16:07,920 --> 00:16:13,649
know that we can use a single language

00:16:09,839 --> 00:16:16,170
that's that's you know is JavaScript but

00:16:13,649 --> 00:16:16,920
do we actually want that that's that's

00:16:16,170 --> 00:16:21,990
the question

00:16:16,920 --> 00:16:25,589
so going further we might ask ourselves

00:16:21,990 --> 00:16:27,540
whether we can do better and in order to

00:16:25,589 --> 00:16:28,720
answer that question it scholar J's

00:16:27,540 --> 00:16:30,459
deserves a look

00:16:28,720 --> 00:16:33,250
right so it's a compiler that turns your

00:16:30,459 --> 00:16:35,350
Scala codes in the equivalent JavaScript

00:16:33,250 --> 00:16:37,449
one and the great thing about is that

00:16:35,350 --> 00:16:39,459
you obtain the long-term benefits of

00:16:37,449 --> 00:16:43,360
writing codes in a statically typed

00:16:39,459 --> 00:16:46,209
language and you you you can use the

00:16:43,360 --> 00:16:48,459
Scala echo system the ID in the compiler

00:16:46,209 --> 00:16:49,810
and and and this is all pretty great

00:16:48,459 --> 00:16:52,990
especially for people who are scholar

00:16:49,810 --> 00:16:54,699
developers but probably the biggest

00:16:52,990 --> 00:16:56,350
selling point is the fact that you can

00:16:54,699 --> 00:16:58,870
share code between the server and the

00:16:56,350 --> 00:17:01,660
clan right and through cross compilation

00:16:58,870 --> 00:17:03,370
so this is this is probably the biggest

00:17:01,660 --> 00:17:05,020
selling point some things that you

00:17:03,370 --> 00:17:07,390
probably have to consider though when

00:17:05,020 --> 00:17:10,449
you're doing that is that you know where

00:17:07,390 --> 00:17:12,130
you're writing Scala code and that has

00:17:10,449 --> 00:17:13,990
that is going to be compared with Scala

00:17:12,130 --> 00:17:16,150
GS you probably need to remember that

00:17:13,990 --> 00:17:18,970
there shouldn't really be any blocking

00:17:16,150 --> 00:17:20,919
everything to say sync and there is no

00:17:18,970 --> 00:17:22,630
real concurrency as the jet engine is

00:17:20,919 --> 00:17:24,970
pretty much single threaded as far as I

00:17:22,630 --> 00:17:28,390
know and another interesting aspects is

00:17:24,970 --> 00:17:30,400
that runtime type tests are based on

00:17:28,390 --> 00:17:32,860
values so so you know you have

00:17:30,400 --> 00:17:35,470
everything that's for example larger

00:17:32,860 --> 00:17:40,510
than hundred and twenty-eight can match

00:17:35,470 --> 00:17:42,640
short in float or double so and you also

00:17:40,510 --> 00:17:44,970
need to be aware that to avoid the

00:17:42,640 --> 00:17:47,440
additional overheads of error handling

00:17:44,970 --> 00:17:48,850
the error handling is simplified so

00:17:47,440 --> 00:17:51,730
there is no array index out of bounds

00:17:48,850 --> 00:17:54,250
exception and then and and that kind of

00:17:51,730 --> 00:17:56,650
stuff and of course reflection is

00:17:54,250 --> 00:17:58,809
prohibited as it makes that called

00:17:56,650 --> 00:18:01,030
elimination quite hard and that's that's

00:17:58,809 --> 00:18:03,070
something that's that you see why it's

00:18:01,030 --> 00:18:06,669
important later so what is the

00:18:03,070 --> 00:18:08,890
compilation pipeline in in sort of a

00:18:06,669 --> 00:18:10,360
port side perspective so that you have

00:18:08,890 --> 00:18:12,789
the initial compilation that turns your

00:18:10,360 --> 00:18:15,070
Scala files to dot class and thus

00:18:12,789 --> 00:18:16,840
colleges intermediate representation and

00:18:15,070 --> 00:18:18,490
then you can go above two ways so you

00:18:16,840 --> 00:18:20,190
can do a fast optimization which pretty

00:18:18,490 --> 00:18:24,760
much does that called elimination

00:18:20,190 --> 00:18:27,070
inlining and reduces your the size of

00:18:24,760 --> 00:18:29,020
your output quite significantly but you

00:18:27,070 --> 00:18:31,659
can also do for optimization which as

00:18:29,020 --> 00:18:33,610
far as I know runs the Google closure

00:18:31,659 --> 00:18:35,549
compiler on top of that an advanced

00:18:33,610 --> 00:18:37,169
optimization mode and

00:18:35,549 --> 00:18:40,350
and this produces even smaller

00:18:37,169 --> 00:18:43,080
executables and this is some of the

00:18:40,350 --> 00:18:45,899
statistics that that I got pretty much

00:18:43,080 --> 00:18:47,759
if you if you think about it for for an

00:18:45,899 --> 00:18:52,559
example problem that's a foo output of

00:18:47,759 --> 00:18:55,019
around 20 mega bytes after the first opt

00:18:52,559 --> 00:18:56,970
you're down to around 600 kilobytes and

00:18:55,019 --> 00:19:00,659
then if you run the Google closure

00:18:56,970 --> 00:19:04,379
compiler on top of that you're

00:19:00,659 --> 00:19:09,419
effectively you're effectively down

00:19:04,379 --> 00:19:11,730
around 200 megabyte kilobytes so if we

00:19:09,419 --> 00:19:14,399
kind of need to step back what what what

00:19:11,730 --> 00:19:16,470
do we have so far so we can we know that

00:19:14,399 --> 00:19:18,840
we can write JavaScript that interfaces

00:19:16,470 --> 00:19:22,019
directly with native UI components right

00:19:18,840 --> 00:19:23,909
and we know also that Scala GS allows

00:19:22,019 --> 00:19:26,129
you to write for seeds for J's libraries

00:19:23,909 --> 00:19:30,779
and use them directly from your Scala

00:19:26,129 --> 00:19:32,759
code and all that provides us with the

00:19:30,779 --> 00:19:35,609
needed parts to actually write some

00:19:32,759 --> 00:19:40,200
Scala code that cause native components

00:19:35,609 --> 00:19:43,799
on on on the on the underlying device so

00:19:40,200 --> 00:19:46,470
that's that's kind of the rationale that

00:19:43,799 --> 00:19:48,840
led us to creating this framework Skaar

00:19:46,470 --> 00:19:51,749
that we are using for our application

00:19:48,840 --> 00:19:53,340
development and Skaar is effectively

00:19:51,749 --> 00:19:56,970
this it allows you to write Scala code

00:19:53,340 --> 00:19:59,789
that drives your mobile applications and

00:19:56,970 --> 00:20:02,879
is compiled to JavaScript and deploy it

00:19:59,789 --> 00:20:08,519
to to your mobile device and it uses

00:20:02,879 --> 00:20:10,109
react native to to render things so it

00:20:08,519 --> 00:20:12,749
provides a very thin wrapper around

00:20:10,109 --> 00:20:14,970
three-act native primitives and allows

00:20:12,749 --> 00:20:17,039
to allows you to write types color code

00:20:14,970 --> 00:20:20,070
of course worse both on Android and iOS

00:20:17,039 --> 00:20:22,080
and it provides quite adequate

00:20:20,070 --> 00:20:25,379
performance as it delegates to native UI

00:20:22,080 --> 00:20:27,239
components and you can also of course

00:20:25,379 --> 00:20:30,480
leverage the already existing react

00:20:27,239 --> 00:20:31,859
native frameworks so if you have to kind

00:20:30,480 --> 00:20:35,789
of think about what you can do with that

00:20:31,859 --> 00:20:40,499
is so when you write some scholar codes

00:20:35,789 --> 00:20:42,450
you can take a few ways you can use in

00:20:40,499 --> 00:20:44,850
Scala the react native core components

00:20:42,450 --> 00:20:47,999
such as text flat lists and whatnot that

00:20:44,850 --> 00:20:49,299
we've provided say it for you can also

00:20:47,999 --> 00:20:50,679
pull in external

00:20:49,299 --> 00:20:53,080
react native component that you write

00:20:50,679 --> 00:20:55,059
say it's for you can also pull in any

00:20:53,080 --> 00:21:00,309
JavaScript library that you write a save

00:20:55,059 --> 00:21:02,889
for but what's probably even more great

00:21:00,309 --> 00:21:05,230
is that you can cross compile a

00:21:02,889 --> 00:21:08,980
libraries with colleges so for example

00:21:05,230 --> 00:21:12,639
you pick Oh on mute s by the Howey it's

00:21:08,980 --> 00:21:14,350
in there their libraries that that that

00:21:12,639 --> 00:21:17,440
you can that you can use bottom you're

00:21:14,350 --> 00:21:19,119
on your mobile client and on your server

00:21:17,440 --> 00:21:21,190
because they are cross compact and after

00:21:19,119 --> 00:21:23,590
all after you decide to use all of these

00:21:21,190 --> 00:21:24,909
things or some of them this all of your

00:21:23,590 --> 00:21:26,950
code goes through the Scala J's compiler

00:21:24,909 --> 00:21:29,320
and then the react native bundler picks

00:21:26,950 --> 00:21:32,710
it up bundles it and runs it on your on

00:21:29,320 --> 00:21:35,289
your device so what does the not me have

00:21:32,710 --> 00:21:37,869
a simple app look like so again looking

00:21:35,289 --> 00:21:39,549
at our JavaScript code we that we

00:21:37,869 --> 00:21:47,710
already saw it looks a bit like this

00:21:39,549 --> 00:21:50,799
right so if you have to translate that

00:21:47,710 --> 00:21:58,389
to Scala and using scar it would sort of

00:21:50,799 --> 00:22:00,369
look like this right it's it's it's the

00:21:58,389 --> 00:22:02,799
skull equivalent so if we compare these

00:22:00,369 --> 00:22:05,080
two versions you can quickly see that

00:22:02,799 --> 00:22:06,070
they're structurally the same so if

00:22:05,080 --> 00:22:08,789
you're familiar with react native

00:22:06,070 --> 00:22:11,609
concepts you can quickly jump in and

00:22:08,789 --> 00:22:13,989
understand what's going on here

00:22:11,609 --> 00:22:15,700
despite well there is a bit of a

00:22:13,989 --> 00:22:19,989
difference you know on the scholar sites

00:22:15,700 --> 00:22:22,749
we have we have typed objects so our

00:22:19,989 --> 00:22:26,169
props and state are in fact types that

00:22:22,749 --> 00:22:29,649
our case classes and it's not just any

00:22:26,169 --> 00:22:31,450
kind of object and your callback as well

00:22:29,649 --> 00:22:34,840
is tight so you get a string and now you

00:22:31,450 --> 00:22:37,059
can benefit from all the stuff around in

00:22:34,840 --> 00:22:43,690
your in your in your standard Scala

00:22:37,059 --> 00:22:46,029
library so we also provide a base screen

00:22:43,690 --> 00:22:47,859
class component that's that's provides

00:22:46,029 --> 00:22:50,019
you with some some interesting things so

00:22:47,859 --> 00:22:52,419
it contains facilities to enable

00:22:50,019 --> 00:22:54,700
navigation like going between screens

00:22:52,419 --> 00:22:56,259
back and forth and it also contains

00:22:54,700 --> 00:22:58,240
logic to properly serialize and

00:22:56,259 --> 00:23:00,309
deserialize react native props for

00:22:58,240 --> 00:23:01,280
passing across the GS in the native

00:23:00,309 --> 00:23:03,530
bridge

00:23:01,280 --> 00:23:04,970
and it of course also enforces the

00:23:03,530 --> 00:23:07,190
implementation of the needed functions

00:23:04,970 --> 00:23:08,780
like render and whatnot it also provides

00:23:07,190 --> 00:23:10,790
you Hook's

00:23:08,780 --> 00:23:12,560
so methods that you can override to hook

00:23:10,790 --> 00:23:15,230
yourself in to the lifecycle of the

00:23:12,560 --> 00:23:18,260
components and it also gives you a typed

00:23:15,230 --> 00:23:25,610
ability to define your initial state

00:23:18,260 --> 00:23:29,030
based on props so apart from apart from

00:23:25,610 --> 00:23:31,970
all of that a lot of the applications

00:23:29,030 --> 00:23:33,950
that are that are actually running out

00:23:31,970 --> 00:23:39,200
there on your mobile devices use some

00:23:33,950 --> 00:23:42,560
kind of persistence so we also wanted to

00:23:39,200 --> 00:23:44,300
use persistence and we wanted to have a

00:23:42,560 --> 00:23:46,370
database that's that's and that's

00:23:44,300 --> 00:23:50,420
running on on the phone on the device

00:23:46,370 --> 00:23:52,940
and we wanted to actually use instead of

00:23:50,420 --> 00:23:54,470
just issuing simple commands we wanted

00:23:52,940 --> 00:23:58,640
to actually use some kind of more

00:23:54,470 --> 00:24:01,940
high-level query representation for that

00:23:58,640 --> 00:24:05,000
functionality so we decided to look at

00:24:01,940 --> 00:24:08,480
quail and quail as probably a lot of you

00:24:05,000 --> 00:24:10,670
know or all of you uses quoted queries

00:24:08,480 --> 00:24:12,560
so it passes each quality block at

00:24:10,670 --> 00:24:16,940
compile time and translates into an

00:24:12,560 --> 00:24:19,490
internal AST and this lasts for compile

00:24:16,940 --> 00:24:21,410
time query generation which is pretty

00:24:19,490 --> 00:24:25,370
great because at compile time when you

00:24:21,410 --> 00:24:27,260
have your petition est you can quick and

00:24:25,370 --> 00:24:29,180
generate into the target language for

00:24:27,260 --> 00:24:33,650
the specific for the particular platform

00:24:29,180 --> 00:24:36,620
and this allows you to this this

00:24:33,650 --> 00:24:38,930
provides for quite minimum overhead at

00:24:36,620 --> 00:24:40,910
run time because at the end of the day

00:24:38,930 --> 00:24:44,360
at runtime you're just ending up with

00:24:40,910 --> 00:24:46,360
using the the the role sequel string or

00:24:44,360 --> 00:24:50,690
whatever target language representation

00:24:46,360 --> 00:24:53,540
this is and and this pretty much from an

00:24:50,690 --> 00:24:57,830
overhead perspective just kind of boils

00:24:53,540 --> 00:25:02,090
down to almost using a driver directly

00:24:57,830 --> 00:25:03,410
and supplying sequel to it so it benefit

00:25:02,090 --> 00:25:05,410
of all that is that you can also do

00:25:03,410 --> 00:25:09,290
compile time validation against your

00:25:05,410 --> 00:25:11,180
against your database schema in Quail so

00:25:09,290 --> 00:25:12,710
this is this is pretty great and of

00:25:11,180 --> 00:25:14,030
course it can be extensible because you

00:25:12,710 --> 00:25:14,930
can hook it with any kind of database

00:25:14,030 --> 00:25:20,650
drive

00:25:14,930 --> 00:25:23,540
if you writes this the context for it so

00:25:20,650 --> 00:25:25,310
we pretty much after so we put in

00:25:23,540 --> 00:25:26,960
quavers the dependency cross-compile its

00:25:25,310 --> 00:25:29,720
colleges and we ended up being able to

00:25:26,960 --> 00:25:32,870
do the following right so this code that

00:25:29,720 --> 00:25:34,550
can actually run on the device you have

00:25:32,870 --> 00:25:36,140
a lookup method that pretty much gives

00:25:34,550 --> 00:25:38,990
you one device back so it looks up from

00:25:36,140 --> 00:25:40,910
at the device is stable and gets the

00:25:38,990 --> 00:25:42,980
first record if there is any so what

00:25:40,910 --> 00:25:45,230
happens when you run that well first of

00:25:42,980 --> 00:25:49,400
all when you compile that the sequel is

00:25:45,230 --> 00:25:53,480
generated right at that point this is

00:25:49,400 --> 00:25:58,610
passed to custom sequel light context

00:25:53,480 --> 00:26:00,230
that you wrote and that's working with

00:25:58,610 --> 00:26:03,290
quill and on top of that we also wrote

00:26:00,230 --> 00:26:05,360
the C sociology associate for sequel

00:26:03,290 --> 00:26:07,490
light so there is a react native cycle

00:26:05,360 --> 00:26:09,830
light storage plug-in that you can use

00:26:07,490 --> 00:26:14,390
and we put that in as a dependency you

00:26:09,830 --> 00:26:15,710
rewrote of a save for it so this is this

00:26:14,390 --> 00:26:18,230
context delegate is directly to

00:26:15,710 --> 00:26:20,180
dissociate and what's and what ends up

00:26:18,230 --> 00:26:22,730
happening at the end of the day is that

00:26:20,180 --> 00:26:25,340
this is getting run on your device and

00:26:22,730 --> 00:26:29,420
it's calling the sequel Lite database

00:26:25,340 --> 00:26:35,150
that's there so but you know we wanted

00:26:29,420 --> 00:26:37,430
to have also add a bit more Principality

00:26:35,150 --> 00:26:39,140
to the whole thing right it's we want it

00:26:37,430 --> 00:26:42,470
a bit more tight integration between DB

00:26:39,140 --> 00:26:44,480
and in the UI right and we realize that

00:26:42,470 --> 00:26:46,100
why do you actually need a database

00:26:44,480 --> 00:26:48,170
right and what do you want to do with it

00:26:46,100 --> 00:26:50,570
when you're on the device well pretty

00:26:48,170 --> 00:26:52,160
much what's what ends up happening at

00:26:50,570 --> 00:26:54,770
least in our scenario is quite often is

00:26:52,160 --> 00:26:57,800
that we want to be able to mutate the

00:26:54,770 --> 00:27:00,020
state of our components based on some

00:26:57,800 --> 00:27:01,760
changes in the database that are

00:27:00,020 --> 00:27:04,010
happening so what we ended up doing is

00:27:01,760 --> 00:27:07,160
that we decided to write a component

00:27:04,010 --> 00:27:09,110
that represent a single dispatch entry

00:27:07,160 --> 00:27:11,180
point for all database operations on the

00:27:09,110 --> 00:27:12,890
device and there is this mechanism

00:27:11,180 --> 00:27:15,710
that's a dynamic publish/subscribe

00:27:12,890 --> 00:27:18,860
mechanism for database updates that are

00:27:15,710 --> 00:27:21,140
happening on the device so you end up

00:27:18,860 --> 00:27:23,420
being able to subscribe to database

00:27:21,140 --> 00:27:26,690
changes and your screen state

00:27:23,420 --> 00:27:28,240
dynamically updates on whenever anything

00:27:26,690 --> 00:27:30,100
about the database is changed

00:27:28,240 --> 00:27:33,040
and this is pretty great because it

00:27:30,100 --> 00:27:34,630
propagates across screens as well so if

00:27:33,040 --> 00:27:37,890
you have to kind of if you have to

00:27:34,630 --> 00:27:37,890
illustrate that with a simple example

00:27:38,700 --> 00:27:43,510
what we what we have is imagine we have

00:27:41,770 --> 00:27:46,150
these three case classes right so you

00:27:43,510 --> 00:27:48,760
have the user state which is a screen

00:27:46,150 --> 00:27:50,740
state so that's a component state and it

00:27:48,760 --> 00:27:53,560
contains the first the last name and the

00:27:50,740 --> 00:27:55,510
times time when it was loaded right and

00:27:53,560 --> 00:27:57,900
then you have the props that are passed

00:27:55,510 --> 00:28:02,350
to the screen this is just the user ID

00:27:57,900 --> 00:28:04,750
and you also have a user that's the case

00:28:02,350 --> 00:28:08,640
class that's the DB record right that

00:28:04,750 --> 00:28:11,620
you're going to get back from quote so

00:28:08,640 --> 00:28:14,350
that's a that's again a pretty silly

00:28:11,620 --> 00:28:18,730
example but that's as much as I could

00:28:14,350 --> 00:28:21,220
fit on screen really so it's it's its

00:28:18,730 --> 00:28:24,370
unquote written with scar it's a screen

00:28:21,220 --> 00:28:25,300
that extends DB enabled screen so

00:28:24,370 --> 00:28:27,640
provides all of that database

00:28:25,300 --> 00:28:37,000
functionality so what happens here is

00:28:27,640 --> 00:28:39,400
that you you end up when when you when

00:28:37,000 --> 00:28:42,430
you load your screen pretty much you

00:28:39,400 --> 00:28:44,350
pass it props that are the idea of some

00:28:42,430 --> 00:28:47,890
of some user and what's happening is

00:28:44,350 --> 00:28:50,920
that you're querying the you're loading

00:28:47,890 --> 00:28:53,320
a particular user from from G from the

00:28:50,920 --> 00:28:56,110
database and you're displaying its first

00:28:53,320 --> 00:28:57,850
and last name on screen and you have a

00:28:56,110 --> 00:28:59,140
button and when you press that button

00:28:57,850 --> 00:29:02,080
what's gonna happen is that you're gonna

00:28:59,140 --> 00:29:03,370
shuffle or reverse the first name of the

00:29:02,080 --> 00:29:06,510
user and then you're going to update

00:29:03,370 --> 00:29:09,820
that entry into the database and then

00:29:06,510 --> 00:29:11,950
your your your screen will render and

00:29:09,820 --> 00:29:13,630
show the updated version so it's like

00:29:11,950 --> 00:29:14,920
you're not directly mutating the state

00:29:13,630 --> 00:29:17,620
of the screen you're going through the

00:29:14,920 --> 00:29:20,890
database and that of course goes through

00:29:17,620 --> 00:29:22,630
to all the rest of the screens so really

00:29:20,890 --> 00:29:25,210
from from from a data flow perspective

00:29:22,630 --> 00:29:27,460
again the way to imagine it is that

00:29:25,210 --> 00:29:29,080
let's say we have one DB enabled screen

00:29:27,460 --> 00:29:31,710
right and we have this component called

00:29:29,080 --> 00:29:35,100
the DB event dispatcher that we that we

00:29:31,710 --> 00:29:37,750
but we provide it

00:29:35,100 --> 00:29:41,260
whenever the screen appears what's

00:29:37,750 --> 00:29:41,870
happening is that it registers itself

00:29:41,260 --> 00:29:45,940
with

00:29:41,870 --> 00:29:48,950
with the dispatcher on mounting and

00:29:45,940 --> 00:29:54,980
initially it reads the state from the

00:29:48,950 --> 00:29:56,539
database and displays it so when you

00:29:54,980 --> 00:29:57,740
press the button to reverse the name

00:29:56,539 --> 00:30:02,360
what's happening is that you're issuing

00:29:57,740 --> 00:30:06,020
the database right commands that's that

00:30:02,360 --> 00:30:09,049
dispatches this right to this event this

00:30:06,020 --> 00:30:10,940
debate and dispatcher and these did that

00:30:09,049 --> 00:30:16,850
right entry point is a single entry

00:30:10,940 --> 00:30:19,549
point and these DB rights are it sort of

00:30:16,850 --> 00:30:24,169
implicitly serialized stuff and when

00:30:19,549 --> 00:30:27,500
this dispatcher rights rights to the

00:30:24,169 --> 00:30:30,020
database and operation completes all of

00:30:27,500 --> 00:30:32,059
the subscribers subscribe screens are

00:30:30,020 --> 00:30:34,789
not fight that there is a state change

00:30:32,059 --> 00:30:37,159
in database and really the notification

00:30:34,789 --> 00:30:40,070
is not more than just going through

00:30:37,159 --> 00:30:42,370
through the lists and calling the on DB

00:30:40,070 --> 00:30:44,480
update method on the particular screen

00:30:42,370 --> 00:30:46,490
and of course you can hook into that

00:30:44,480 --> 00:30:50,990
screen and most of the time what you

00:30:46,490 --> 00:30:53,870
would want to do is most likely pretty

00:30:50,990 --> 00:30:56,390
much reload the state from the database

00:30:53,870 --> 00:30:59,080
that you're interested in because you

00:30:56,390 --> 00:31:02,630
know that there is some state change and

00:30:59,080 --> 00:31:06,230
you know the beauty the beauty of most

00:31:02,630 --> 00:31:09,409
of that is that as a matter of fact this

00:31:06,230 --> 00:31:12,350
is all quite easy to implement because

00:31:09,409 --> 00:31:13,700
you don't really you don't really care

00:31:12,350 --> 00:31:16,070
too much about concurrency or like

00:31:13,700 --> 00:31:18,020
thread safety because you know that this

00:31:16,070 --> 00:31:20,960
will this particular part will actually

00:31:18,020 --> 00:31:24,289
run in the on the JavaScript VM on the

00:31:20,960 --> 00:31:26,090
device so you don't need some fancy

00:31:24,289 --> 00:31:27,919
concurrent data structures to store that

00:31:26,090 --> 00:31:29,899
stuff and you don't care about

00:31:27,919 --> 00:31:34,399
visibility and all that because you know

00:31:29,899 --> 00:31:38,860
you're safe with that so we also added

00:31:34,399 --> 00:31:43,460
some stuff around navigation right so

00:31:38,860 --> 00:31:46,730
there is there is a project called react

00:31:43,460 --> 00:31:50,539
native navigation week-three a native

00:31:46,730 --> 00:31:52,640
navigation that provides 100% native a

00:31:50,539 --> 00:31:55,879
platform navigation for both Android and

00:31:52,640 --> 00:31:57,379
iOS so it's pretty great it it uses

00:31:55,879 --> 00:31:58,909
it uses the native navigation

00:31:57,379 --> 00:31:59,629
functionalities I've done the like

00:31:58,909 --> 00:32:03,259
platform

00:31:59,629 --> 00:32:06,710
it supports various layouts such as

00:32:03,259 --> 00:32:09,049
stock popped layout and and it looks

00:32:06,710 --> 00:32:10,999
quite nice and it also provides you

00:32:09,049 --> 00:32:12,979
additional some some additional life

00:32:10,999 --> 00:32:15,169
hooks into the into the screen life of

00:32:12,979 --> 00:32:20,090
cycle components such as component deed

00:32:15,169 --> 00:32:22,999
update etc so we really kind of defined

00:32:20,090 --> 00:32:27,859
these this sort of these are some of the

00:32:22,999 --> 00:32:32,869
methods that are that are on this in

00:32:27,859 --> 00:32:35,029
JavaScript verse 8 and but if you want

00:32:32,869 --> 00:32:37,759
to read more you probably just you're

00:32:35,029 --> 00:32:39,710
better off just going to to and checking

00:32:37,759 --> 00:32:42,559
out under Ariadne navigation but we have

00:32:39,710 --> 00:32:43,729
that as a dependency in it's per se that

00:32:42,559 --> 00:32:48,919
we provide for it

00:32:43,729 --> 00:32:51,559
however it's it's not so directly

00:32:48,919 --> 00:32:53,539
exposed we are using that but we figured

00:32:51,559 --> 00:32:55,460
out that we don't really need a lot more

00:32:53,539 --> 00:32:57,049
than just going between screens and

00:32:55,460 --> 00:32:59,479
returning back from screen and and

00:32:57,049 --> 00:33:02,210
returning we also provide some

00:32:59,479 --> 00:33:04,669
functionality for a screen having a

00:33:02,210 --> 00:33:07,279
return value so if you go to screen for

00:33:04,669 --> 00:33:10,129
example and you input your password or

00:33:07,279 --> 00:33:12,109
something we want the screen that was

00:33:10,129 --> 00:33:13,909
that initiated that action to actually

00:33:12,109 --> 00:33:15,710
obtain the result once it's done so

00:33:13,909 --> 00:33:17,869
things like that that provide for a bit

00:33:15,710 --> 00:33:21,919
more ergonomics around around

00:33:17,869 --> 00:33:24,759
development so with all that said there

00:33:21,919 --> 00:33:28,369
are some you know there are some

00:33:24,759 --> 00:33:32,029
different tiers that's that were present

00:33:28,369 --> 00:33:35,840
in the whole process and that was mainly

00:33:32,029 --> 00:33:38,210
due to the fact that me and I was

00:33:35,840 --> 00:33:41,019
working with Android varga and was

00:33:38,210 --> 00:33:43,940
here's donuts and then in bullet and

00:33:41,019 --> 00:33:47,710
none of us were really experts and in

00:33:43,940 --> 00:33:50,690
mobile UI development or or or

00:33:47,710 --> 00:33:52,909
JavaScript or react native or scholar

00:33:50,690 --> 00:33:54,859
J's for that matter so all that stuff

00:33:52,909 --> 00:33:57,229
was quite new to us and we encountered

00:33:54,859 --> 00:33:59,899
some pretty interesting challenges I

00:33:57,229 --> 00:34:02,869
must say so first of all we had quite a

00:33:59,899 --> 00:34:05,299
challenge around building right so as I

00:34:02,869 --> 00:34:07,220
already mentioned metro is at the

00:34:05,299 --> 00:34:09,079
bundler used by react native to bundle

00:34:07,220 --> 00:34:09,869
all of your jf codes to be loaded on the

00:34:09,079 --> 00:34:11,849
device and it

00:34:09,869 --> 00:34:14,009
kind of does a few a few things that are

00:34:11,849 --> 00:34:15,599
that are more notable so you have

00:34:14,009 --> 00:34:17,190
resolution that pretty much builds a

00:34:15,599 --> 00:34:19,230
graph of all the modules that we depend

00:34:17,190 --> 00:34:20,549
on in your JavaScript code then you have

00:34:19,230 --> 00:34:22,079
the transformation which kind of

00:34:20,549 --> 00:34:25,829
optimize you is this your Java code

00:34:22,079 --> 00:34:28,710
JavaScript code so it does it does some

00:34:25,829 --> 00:34:31,049
kind of static analysis and it optimizes

00:34:28,710 --> 00:34:32,369
your JavaScript code further and then

00:34:31,049 --> 00:34:34,740
you have civilization which pretty much

00:34:32,369 --> 00:34:36,599
is the point at which all all of your

00:34:34,740 --> 00:34:40,230
transport modules are combined into a

00:34:36,599 --> 00:34:42,839
single JS file and upload it in the

00:34:40,230 --> 00:34:45,149
device now the problem that we kept

00:34:42,839 --> 00:34:47,819
facing was that when we were compiling

00:34:45,149 --> 00:34:51,119
with with Scala Jas and we had these

00:34:47,819 --> 00:34:55,079
pretty big JavaScript files Metro was

00:34:51,119 --> 00:34:57,930
choking on on them right so as I said

00:34:55,079 --> 00:34:59,490
our app is quite non-trivial in terms of

00:34:57,930 --> 00:35:01,890
logic so it's like a lot of Scala code

00:34:59,490 --> 00:35:06,480
right and you end up with a pretty

00:35:01,890 --> 00:35:08,849
sizable javascript file so what ended up

00:35:06,480 --> 00:35:11,609
happening is that we started seeing

00:35:08,849 --> 00:35:15,200
these we started seeing these timeout

00:35:11,609 --> 00:35:20,519
errors that's that's that were happening

00:35:15,200 --> 00:35:22,529
and we just couldn't really get around

00:35:20,519 --> 00:35:24,299
that very easily even increasing the

00:35:22,529 --> 00:35:25,619
timeout it's just not sensible I mean

00:35:24,299 --> 00:35:28,109
waiting for five minutes to just

00:35:25,619 --> 00:35:30,480
transform your codes it's it's horrible

00:35:28,109 --> 00:35:31,680
development experience right so we

00:35:30,480 --> 00:35:37,339
started thinking well why is that

00:35:31,680 --> 00:35:40,019
happening and what is going on so

00:35:37,339 --> 00:35:41,700
actually what's happening is quite

00:35:40,019 --> 00:35:46,650
interesting right the transformation

00:35:41,700 --> 00:35:50,789
phase with our Metro pretty much builds

00:35:46,650 --> 00:35:55,170
a few of your code right and this has

00:35:50,789 --> 00:35:57,420
been engineered for sizes of small sizes

00:35:55,170 --> 00:36:00,150
in terms of your JavaScript code so

00:35:57,420 --> 00:36:04,710
small files once you go over the ten

00:36:00,150 --> 00:36:11,069
megabytes of code Metro starts to choke

00:36:04,710 --> 00:36:13,200
quite quite quickly and we read that as

00:36:11,069 --> 00:36:14,339
a matter of fact it's probably not such

00:36:13,200 --> 00:36:16,170
a bad idea to circumvent that

00:36:14,339 --> 00:36:19,380
transformation face altogether because

00:36:16,170 --> 00:36:21,380
after all for our production deployment

00:36:19,380 --> 00:36:23,210
view our running

00:36:21,380 --> 00:36:26,210
the Google closure compiler on top of it

00:36:23,210 --> 00:36:28,100
and and as far as we've read it's it's

00:36:26,210 --> 00:36:30,260
just pretty aggressive optimization so

00:36:28,100 --> 00:36:33,800
most likely we're not getting too much

00:36:30,260 --> 00:36:35,570
out of the metro transformer itself so

00:36:33,800 --> 00:36:39,680
why don't we just forget about it and

00:36:35,570 --> 00:36:42,890
and and and just surpass it

00:36:39,680 --> 00:36:47,390
and this is exactly what we did so we

00:36:42,890 --> 00:36:50,810
actually in in in in the metro in the

00:36:47,390 --> 00:36:52,610
metro bundling pipeline we had to write

00:36:50,810 --> 00:36:54,380
our custom transformer which is really

00:36:52,610 --> 00:36:59,000
not all that complicated but what it

00:36:54,380 --> 00:37:02,330
does is pretty much it it it looks for

00:36:59,000 --> 00:37:04,910
it it looks for the files that that are

00:37:02,330 --> 00:37:07,160
output with with with from scholar J s

00:37:04,910 --> 00:37:09,320
and that had been optimized and it just

00:37:07,160 --> 00:37:11,810
skipped skipped the transformation phase

00:37:09,320 --> 00:37:13,790
with them and effective for all the

00:37:11,810 --> 00:37:18,800
other files it delegates to the default

00:37:13,790 --> 00:37:20,720
transformer so one of the problems with

00:37:18,800 --> 00:37:22,670
that was the fact that we had some

00:37:20,720 --> 00:37:24,770
problems with source maps so it's like

00:37:22,670 --> 00:37:26,990
debugging became quite quite quite quite

00:37:24,770 --> 00:37:29,030
hard and this is something that we are

00:37:26,990 --> 00:37:31,310
still working on to sort of figure out

00:37:29,030 --> 00:37:36,560
how to correctly

00:37:31,310 --> 00:37:38,180
apart from that we experienced so there

00:37:36,560 --> 00:37:39,620
was another project that was sort of

00:37:38,180 --> 00:37:43,640
trying to do the same thing and and

00:37:39,620 --> 00:37:45,320
indeed it just called Fri and the thing

00:37:43,640 --> 00:37:47,570
that we noticed with with this

00:37:45,320 --> 00:37:51,800
particular product is that they were

00:37:47,570 --> 00:37:57,530
relying quite heavily on traits that

00:37:51,800 --> 00:37:59,720
were extending JS object so native

00:37:57,530 --> 00:38:02,540
JavaScript classes and they had to do

00:37:59,720 --> 00:38:04,130
that because this is what for example

00:38:02,540 --> 00:38:07,430
your props need to be they need to be

00:38:04,130 --> 00:38:08,900
JavaScript objects and we kind of really

00:38:07,430 --> 00:38:11,390
wanted to have case classes for that

00:38:08,900 --> 00:38:15,310
right so be completing scholar land and

00:38:11,390 --> 00:38:15,310
that was that was a bit of a problem so

00:38:16,180 --> 00:38:22,940
what we did is that we we defined this

00:38:20,000 --> 00:38:25,070
JS object abstraction that combined with

00:38:22,940 --> 00:38:27,230
some macro magic allows you to pretty

00:38:25,070 --> 00:38:28,520
much take your case classes and and and

00:38:27,230 --> 00:38:31,750
bundle them into the respective

00:38:28,520 --> 00:38:35,360
JavaScript JavaScript object format

00:38:31,750 --> 00:38:37,040
and it was it's it's quite interesting

00:38:35,360 --> 00:38:40,610
that that actually solved our problem so

00:38:37,040 --> 00:38:42,320
Matias was working on that and in it and

00:38:40,610 --> 00:38:45,560
he's pretty good with with macros and

00:38:42,320 --> 00:38:47,330
types in general so it's it's kind of

00:38:45,560 --> 00:38:50,720
provided for a really a lot more

00:38:47,330 --> 00:38:52,670
ergonomic experience and apart from that

00:38:50,720 --> 00:38:56,240
what the additional added benefit of

00:38:52,670 --> 00:38:59,230
that the additional added benefit of all

00:38:56,240 --> 00:39:04,850
that was that we were able to kind of

00:38:59,230 --> 00:39:07,010
mode our mold our J's objects and just

00:39:04,850 --> 00:39:10,520
say it's a little bit better so for

00:39:07,010 --> 00:39:13,400
example if you look at the native react

00:39:10,520 --> 00:39:16,640
native view component and it's

00:39:13,400 --> 00:39:20,290
documentation you quickly see that it

00:39:16,640 --> 00:39:22,610
actually contains a huge list of

00:39:20,290 --> 00:39:26,000
arguments that this constructor takes

00:39:22,610 --> 00:39:30,620
some of them are specific to iOS some of

00:39:26,000 --> 00:39:33,230
them are specific to Android and and

00:39:30,620 --> 00:39:35,570
this is not really great from our

00:39:33,230 --> 00:39:37,610
organization perspective of your code so

00:39:35,570 --> 00:39:39,080
we came up with this JS object flattened

00:39:37,610 --> 00:39:41,090
abstraction that pretty much allows you

00:39:39,080 --> 00:39:44,680
to group these things together into case

00:39:41,090 --> 00:39:47,570
classes and and at the end of the day

00:39:44,680 --> 00:39:50,390
when that gets to the JavaScript code

00:39:47,570 --> 00:39:52,040
all of that will be exploded and it will

00:39:50,390 --> 00:39:54,700
be flattened into one long list of

00:39:52,040 --> 00:39:57,290
argyll and so this allows for better

00:39:54,700 --> 00:40:00,800
organization of your code so you can

00:39:57,290 --> 00:40:02,960
have androids just Android specific

00:40:00,800 --> 00:40:05,300
props separate it into a separate case

00:40:02,960 --> 00:40:08,200
class and an iOS specific props that

00:40:05,300 --> 00:40:12,470
that your that you're working with

00:40:08,200 --> 00:40:14,630
so in summary Skaar is a pretty

00:40:12,470 --> 00:40:16,280
lightweight framework that enables you

00:40:14,630 --> 00:40:20,240
to use color for your mobile

00:40:16,280 --> 00:40:22,850
applications and it provides economic

00:40:20,240 --> 00:40:25,300
abstractions for handling navigation and

00:40:22,850 --> 00:40:27,470
persistence and that was something that

00:40:25,300 --> 00:40:29,210
aerodynamic to us right they might not

00:40:27,470 --> 00:40:30,980
be that diagramming to the community but

00:40:29,210 --> 00:40:34,160
this was something that we needed and we

00:40:30,980 --> 00:40:37,190
saw we saw some of the pain points and

00:40:34,160 --> 00:40:38,570
and we provided solutions for that and

00:40:37,190 --> 00:40:40,970
of course there were some tears involved

00:40:38,570 --> 00:40:43,610
in the development process it wasn't all

00:40:40,970 --> 00:40:44,710
smooth as as I said none of us were

00:40:43,610 --> 00:40:47,950
really that was the

00:40:44,710 --> 00:40:50,230
time for for all of us work is still

00:40:47,950 --> 00:40:53,640
undergoing can we plan to open source

00:40:50,230 --> 00:40:57,160
that we just want to make it a bit more

00:40:53,640 --> 00:41:00,250
ergonomic so and then we want to

00:40:57,160 --> 00:41:02,290
abstract the user of the library as much

00:41:00,250 --> 00:41:04,540
as possible from all the intricacies

00:41:02,290 --> 00:41:06,400
around deploying react native apps and

00:41:04,540 --> 00:41:12,730
initializing creative projects and

00:41:06,400 --> 00:41:14,770
whatnot so this is this is this is kind

00:41:12,730 --> 00:41:18,310
of it thank you for all the attention

00:41:14,770 --> 00:41:28,990
and I hope you liked that presentation

00:41:18,310 --> 00:41:30,490
and I hope you use car once is out so we

00:41:28,990 --> 00:41:33,040
have three minutes left for some

00:41:30,490 --> 00:41:36,430
questions so for the one who wants I

00:41:33,040 --> 00:41:50,589
asked you to be very brief who would

00:41:36,430 --> 00:41:53,890
like to ask a question it's a very very

00:41:50,589 --> 00:41:56,349
quick question you mentioned that we

00:41:53,890 --> 00:41:59,890
wish us to use car once it's out so one

00:41:56,349 --> 00:42:02,290
is the release official release yeah

00:41:59,890 --> 00:42:07,150
unfortunately we don't have a we don't

00:42:02,290 --> 00:42:09,310
have a date that's that set in stone I'd

00:42:07,150 --> 00:42:11,859
say that the work is done so so this

00:42:09,310 --> 00:42:13,480
this this thing is running we're and

00:42:11,859 --> 00:42:15,070
it's not just kind of an experiment

00:42:13,480 --> 00:42:17,680
that's it's like oh yeah look at this

00:42:15,070 --> 00:42:19,540
with the death it's weird our production

00:42:17,680 --> 00:42:22,810
up depends on that so so this is working

00:42:19,540 --> 00:42:25,060
it's ready it's just a matter of really

00:42:22,810 --> 00:42:27,609
pulling it out and an open sourcing it

00:42:25,060 --> 00:42:29,109
and that was my path personally and I

00:42:27,609 --> 00:42:30,940
should have been ready by now but

00:42:29,109 --> 00:42:34,810
unfortunately you know you're always

00:42:30,940 --> 00:42:38,109
like 99% ready in this case not even

00:42:34,810 --> 00:42:40,450
started so hey I hope like after the

00:42:38,109 --> 00:42:41,920
conference I'll have a bit more time so

00:42:40,450 --> 00:42:44,230
I hope I'll take the time and and

00:42:41,920 --> 00:42:48,280
actually open source that it's all about

00:42:44,230 --> 00:42:48,760
just admins stuff really just putting it

00:42:48,280 --> 00:42:50,380
on github

00:42:48,760 --> 00:42:52,510
setting up builds writing some test

00:42:50,380 --> 00:42:54,640
writing proper documentation so it's

00:42:52,510 --> 00:42:57,580
easy for everyone to kind of approach

00:42:54,640 --> 00:43:01,630
that but I think it's a very interesting

00:42:57,580 --> 00:43:04,810
thing because it's the big part about is

00:43:01,630 --> 00:43:07,540
that we really managed to share scholar

00:43:04,810 --> 00:43:08,950
code that is really really non-trivial I

00:43:07,540 --> 00:43:10,960
mean we have some very complicated

00:43:08,950 --> 00:43:12,700
scholar logic around conflict resolution

00:43:10,960 --> 00:43:14,530
and conflict aware types we have

00:43:12,700 --> 00:43:16,630
shapeless and this and that and all of

00:43:14,530 --> 00:43:18,970
that it's shared in our common module

00:43:16,630 --> 00:43:21,550
and runs both on the back end and on

00:43:18,970 --> 00:43:33,330
Android and iOS so it's it's great

00:43:21,550 --> 00:43:36,910
thanks to college is mostly hi so I've

00:43:33,330 --> 00:43:39,520
clicked two questions one is that once

00:43:36,910 --> 00:43:42,190
it's released there will there be enough

00:43:39,520 --> 00:43:46,030
materials and tutorials and probably

00:43:42,190 --> 00:43:48,670
some videos to help us use that or and

00:43:46,030 --> 00:43:52,690
another question is it this it dependent

00:43:48,670 --> 00:43:54,910
on react native right so once in a

00:43:52,690 --> 00:43:57,609
Google releases new Android or

00:43:54,910 --> 00:44:00,609
Louis's new iOS and if there are some

00:43:57,609 --> 00:44:03,099
changes then you need to wait until they

00:44:00,609 --> 00:44:04,900
react native respond to that and then

00:44:03,099 --> 00:44:07,690
also your company need to respond to

00:44:04,900 --> 00:44:09,760
rise so do you think that your company

00:44:07,690 --> 00:44:11,859
will be creeping up to you know make

00:44:09,760 --> 00:44:14,650
changes to work with the new button so

00:44:11,859 --> 00:44:16,780
well hopefully yeah I mean it's well

00:44:14,650 --> 00:44:19,180
first all to the first question it's

00:44:16,780 --> 00:44:20,440
it's that's why it's not released yet

00:44:19,180 --> 00:44:22,510
right because we need to get

00:44:20,440 --> 00:44:24,430
documentation and then tutorials and

00:44:22,510 --> 00:44:28,210
whatnot so that's why it's not released

00:44:24,430 --> 00:44:31,720
and secondly yes I hope that you have

00:44:28,210 --> 00:44:33,520
the capacity to quickly enough you know

00:44:31,720 --> 00:44:34,990
quickly enough follow up with with all

00:44:33,520 --> 00:44:38,079
release affair native and whatnot

00:44:34,990 --> 00:44:40,119
although it's not as easy there are

00:44:38,079 --> 00:44:43,000
always some problems involved to be

00:44:40,119 --> 00:44:44,440
honest like this ecosystem is very yeah

00:44:43,000 --> 00:44:47,049
there is always some problems involved

00:44:44,440 --> 00:44:48,910
but I hope we'll be able to to provide

00:44:47,049 --> 00:44:50,680
adequate support and after all this is

00:44:48,910 --> 00:44:52,210
why it's released to the community so

00:44:50,680 --> 00:44:54,700
the community itself can also pick it up

00:44:52,210 --> 00:44:58,569
and work with it and hopefully provide

00:44:54,700 --> 00:45:01,089
some support yeah I guess that key would

00:44:58,569 --> 00:45:02,950
be the you know open source right so if

00:45:01,089 --> 00:45:05,619
you want you guys often associate and

00:45:02,950 --> 00:45:07,660
many many more people can have yes

00:45:05,619 --> 00:45:09,039
exactly exactly and we don't really know

00:45:07,660 --> 00:45:10,420
whether people are actually excited

00:45:09,039 --> 00:45:12,880
about that or whether they are actually

00:45:10,420 --> 00:45:14,829
gonna pick it up and use it because it's

00:45:12,880 --> 00:45:20,020
yeah we don't really know but it was

00:45:14,829 --> 00:45:22,270
useful to us definitely thank you so if

00:45:20,020 --> 00:45:24,369
there is not more question

00:45:22,270 --> 00:45:27,700
so I thank you for your attention and

00:45:24,369 --> 00:45:30,700
things also you the wonderful speaker

00:45:27,700 --> 00:45:33,940
that we had and we meet in 15 minutes in

00:45:30,700 --> 00:45:37,930
this room to have the akka stream to the

00:45:33,940 --> 00:45:38,650
extreme by eyeko sea burger so see you

00:45:37,930 --> 00:45:44,510
later

00:45:38,650 --> 00:45:44,510

YouTube URL: https://www.youtube.com/watch?v=j2OMNkIbIuM


