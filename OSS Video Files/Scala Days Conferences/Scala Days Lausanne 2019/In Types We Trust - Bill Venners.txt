Title: In Types We Trust - Bill Venners
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/in-types-we-trust
Captions: 
	00:00:00,030 --> 00:00:09,360
oh you can hear me good morning good

00:00:04,680 --> 00:00:11,580
morning okay well I just thought you'd

00:00:09,360 --> 00:00:13,410
say good morning back to me my name is

00:00:11,580 --> 00:00:18,869
Bill Venters and this talk is kind of

00:00:13,410 --> 00:00:20,670
about faith I have been thinking about

00:00:18,869 --> 00:00:22,230
how to make testing better for many

00:00:20,670 --> 00:00:26,670
years because we do Scala tests at our

00:00:22,230 --> 00:00:30,240
tema and that led me towards proofs and

00:00:26,670 --> 00:00:31,920
so today I might talk kind of builds on

00:00:30,240 --> 00:00:33,930
a couple other talks that I gave in the

00:00:31,920 --> 00:00:36,210
last few years so I'd like to start out

00:00:33,930 --> 00:00:37,590
by kind of refreshing going back to a

00:00:36,210 --> 00:00:40,829
couple things I I talked about in the

00:00:37,590 --> 00:00:43,530
past two years ago at Scala days I had a

00:00:40,829 --> 00:00:46,559
talk called the essence of testing and

00:00:43,530 --> 00:00:48,750
what I did in that talk is is a very

00:00:46,559 --> 00:00:53,430
short version of it I showed this slide

00:00:48,750 --> 00:00:56,570
this is a page of eiffel code eiffel is

00:00:53,430 --> 00:00:59,730
a language created by Bertrand Meyer who

00:00:56,570 --> 00:01:01,260
was French still is French and he named

00:00:59,730 --> 00:01:02,760
his language after the Eiffel Tower and

00:01:01,260 --> 00:01:06,210
he had an idea and they are called

00:01:02,760 --> 00:01:10,430
design by contract that was what he

00:01:06,210 --> 00:01:13,080
called this idea of using assertions to

00:01:10,430 --> 00:01:16,680
specify the behavior of functions

00:01:13,080 --> 00:01:18,509
behavior of your software so what you do

00:01:16,680 --> 00:01:20,909
an Eiffel this this is the a square root

00:01:18,509 --> 00:01:22,830
function in Eiffel is I can't just like

00:01:20,909 --> 00:01:24,689
to write square root implement the

00:01:22,830 --> 00:01:26,610
algorithm to compute the square root I

00:01:24,689 --> 00:01:30,270
also have to specify the behavior of

00:01:26,610 --> 00:01:31,920
this this function which he called the

00:01:30,270 --> 00:01:35,159
contract and it's kind of like what the

00:01:31,920 --> 00:01:37,229
service provider promises and what the

00:01:35,159 --> 00:01:39,990
person using it promises he kind of

00:01:37,229 --> 00:01:42,000
captures that in assertions so there's

00:01:39,990 --> 00:01:44,820
three parts to a function in Eiffel you

00:01:42,000 --> 00:01:46,590
have the require clause which is what he

00:01:44,820 --> 00:01:47,759
called preconditions that's basically

00:01:46,590 --> 00:01:49,409
had three kinds of assertions

00:01:47,759 --> 00:01:51,630
preconditions post conditions and

00:01:49,409 --> 00:01:53,340
invariants so here what I'm saying is

00:01:51,630 --> 00:01:55,829
that squared is actually a partial

00:01:53,340 --> 00:01:58,229
function because it's not defined on

00:01:55,829 --> 00:02:00,360
negative real numbers so it's only

00:01:58,229 --> 00:02:03,570
defined on some of its input values not

00:02:00,360 --> 00:02:06,270
all of them so what will happen is that

00:02:03,570 --> 00:02:08,039
if a negative number is passed a square

00:02:06,270 --> 00:02:11,370
root this will throw assertion error

00:02:08,039 --> 00:02:12,930
essentially at runtime right but what

00:02:11,370 --> 00:02:13,560
you're doing here is also specifying

00:02:12,930 --> 00:02:15,330
that

00:02:13,560 --> 00:02:17,459
client and this is the responsibility of

00:02:15,330 --> 00:02:21,480
the client in the design by contract

00:02:17,459 --> 00:02:24,360
world view the responsibility to pass in

00:02:21,480 --> 00:02:26,430
only positive or zero positive reals or

00:02:24,360 --> 00:02:28,319
zero is the responsibility of the

00:02:26,430 --> 00:02:31,319
programmers who are calling square-root

00:02:28,319 --> 00:02:34,440
right and if they fail to do that that's

00:02:31,319 --> 00:02:36,180
a bug and they are punished you are we

00:02:34,440 --> 00:02:39,030
are punished by getting an exception

00:02:36,180 --> 00:02:41,040
right assertion error okay then do is

00:02:39,030 --> 00:02:44,190
where you do the algorithm and like

00:02:41,040 --> 00:02:45,930
actually compute the square root ensure

00:02:44,190 --> 00:02:48,500
is called the post condition that's

00:02:45,930 --> 00:02:51,600
another assertion so what that is

00:02:48,500 --> 00:02:55,170
capturing is what is the person who

00:02:51,600 --> 00:02:58,980
implements this algorithm promising

00:02:55,170 --> 00:03:00,540
right so what this one does is there's

00:02:58,980 --> 00:03:04,049
magically an eyeful something called

00:03:00,540 --> 00:03:06,540
result and that is the result that's

00:03:04,049 --> 00:03:08,819
about to be returned from the square

00:03:06,540 --> 00:03:12,030
root function that was computed by the

00:03:08,819 --> 00:03:13,590
do part and so we square that and

00:03:12,030 --> 00:03:15,209
basically this is supposed to be the

00:03:13,590 --> 00:03:16,709
square root of x right so if you squared

00:03:15,209 --> 00:03:19,230
the square root of x in the mathematical

00:03:16,709 --> 00:03:21,000
world it would just be X you know but in

00:03:19,230 --> 00:03:23,100
the world of floating point math so this

00:03:21,000 --> 00:03:24,420
is like float or double in Scala there

00:03:23,100 --> 00:03:26,940
may be some rounding differences right

00:03:24,420 --> 00:03:29,310
so we do is we square the X we square

00:03:26,940 --> 00:03:30,870
the result that's about to be returned

00:03:29,310 --> 00:03:34,319
you subtract the original X and then the

00:03:30,870 --> 00:03:35,850
ideal world that would be zero right but

00:03:34,319 --> 00:03:38,549
there may be plus or minus a little bit

00:03:35,850 --> 00:03:39,600
of rounding difference and so we take

00:03:38,549 --> 00:03:41,459
the absolute value that to make sure

00:03:39,600 --> 00:03:43,470
it's a positive difference and then just

00:03:41,459 --> 00:03:45,030
make sure it's below a certain tolerance

00:03:43,470 --> 00:03:48,090
we're willing to accept for rounding

00:03:45,030 --> 00:03:50,549
right and that's the post condition so

00:03:48,090 --> 00:03:53,220
one of the ideas that that he flushed

00:03:50,549 --> 00:03:54,750
out in Eiffel is that assertions can be

00:03:53,220 --> 00:03:55,680
turned off at runtime in production

00:03:54,750 --> 00:03:56,970
because they actually take time to

00:03:55,680 --> 00:03:59,310
compute and they're more about like

00:03:56,970 --> 00:04:03,420
making sure you got your code right so

00:03:59,310 --> 00:04:04,859
in develop and test like if you you know

00:04:03,420 --> 00:04:06,569
have a s QA Department that's just

00:04:04,859 --> 00:04:08,220
responsible for testing in those

00:04:06,569 --> 00:04:09,690
scenarios you would enable all the

00:04:08,220 --> 00:04:12,150
assertions and they'd be checking all

00:04:09,690 --> 00:04:13,470
the time it might be a little slower but

00:04:12,150 --> 00:04:15,060
when you deploy to production you might

00:04:13,470 --> 00:04:16,560
turn these off and he had a very

00:04:15,060 --> 00:04:19,260
fine-grained way of turning things on

00:04:16,560 --> 00:04:20,430
and off you could turn on post

00:04:19,260 --> 00:04:23,550
conditions and preconditions and

00:04:20,430 --> 00:04:24,900
invariance separately and actually just

00:04:23,550 --> 00:04:26,710
turn them on and off for one particular

00:04:24,900 --> 00:04:27,970
function if you want to an Eiffel

00:04:26,710 --> 00:04:30,310
so that's that's what that was his idea

00:04:27,970 --> 00:04:32,380
and this didn't really win in the

00:04:30,310 --> 00:04:36,190
marketplace of you know what happened

00:04:32,380 --> 00:04:39,789
was that I feel kind of lost a C++ he

00:04:36,190 --> 00:04:42,729
was competing with C++ for mind share

00:04:39,789 --> 00:04:44,289
and sort of lost and C++ didn't have

00:04:42,729 --> 00:04:48,310
this and then Java came along it also

00:04:44,289 --> 00:04:49,810
didn't have this and then j-unit came

00:04:48,310 --> 00:04:50,830
along and test-driven development and

00:04:49,810 --> 00:04:52,570
that really did succeed in the

00:04:50,830 --> 00:04:55,030
marketplace so what we actually do on

00:04:52,570 --> 00:04:57,789
the JVM not just in Scala but also but

00:04:55,030 --> 00:05:00,610
also just generally on the JVM is we do

00:04:57,789 --> 00:05:03,220
what's the default in Eiffel that a

00:05:00,610 --> 00:05:05,289
Fault in Eiffel is require run are

00:05:03,220 --> 00:05:08,710
turned on they're enabled and ensure is

00:05:05,289 --> 00:05:12,610
disabled right so we all do in like if

00:05:08,710 --> 00:05:14,380
this is a square root function in Scala

00:05:12,610 --> 00:05:19,030
I would normally have a require Clause

00:05:14,380 --> 00:05:21,220
to capture my preconditions and what

00:05:19,030 --> 00:05:22,990
this function does is if you you've

00:05:21,220 --> 00:05:24,729
passed a negative in term at a negative

00:05:22,990 --> 00:05:27,580
number to math dot square root it will

00:05:24,729 --> 00:05:29,710
give you not a number so here it will

00:05:27,580 --> 00:05:30,940
instead give you an exception all right

00:05:29,710 --> 00:05:33,010
so that's sort of the value add if you

00:05:30,940 --> 00:05:35,110
call that value getting an exception

00:05:33,010 --> 00:05:36,789
instead of not a number over map that

00:05:35,110 --> 00:05:39,310
square root that's what we're doing so

00:05:36,789 --> 00:05:41,260
we say require that the number passed is

00:05:39,310 --> 00:05:43,210
not not a number it's greater than equal

00:05:41,260 --> 00:05:46,720
zero and it's not positive infinity if

00:05:43,210 --> 00:05:48,490
that's all cool then we can call Mathis

00:05:46,720 --> 00:05:51,220
Square and return the result right and

00:05:48,490 --> 00:05:53,320
then we don't check the post condition

00:05:51,220 --> 00:05:56,530
now yesterday Martin showed insuring in

00:05:53,320 --> 00:05:58,720
the keynote and ensuring is really set a

00:05:56,530 --> 00:06:00,340
Scala's answer to ensure in Eiffel so

00:05:58,720 --> 00:06:02,949
you can do designed by contract in Scala

00:06:00,340 --> 00:06:04,300
also and he showed that in Scala three

00:06:02,949 --> 00:06:05,650
with implicit function types you can

00:06:04,300 --> 00:06:06,430
actually just say result just like you

00:06:05,650 --> 00:06:09,130
could an Eiffel

00:06:06,430 --> 00:06:10,419
so it's anyway that's that's not common

00:06:09,130 --> 00:06:11,590
he asked how many people use that and I

00:06:10,419 --> 00:06:13,030
I was in the front row so either

00:06:11,590 --> 00:06:14,680
everybody behind me used it and I just

00:06:13,030 --> 00:06:16,900
don't know but I think most people don't

00:06:14,680 --> 00:06:18,340
use that right what we do is we take

00:06:16,900 --> 00:06:24,750
that post condition and we put the in

00:06:18,340 --> 00:06:28,630
this other place called the tests so

00:06:24,750 --> 00:06:30,250
test-driven development development was

00:06:28,630 --> 00:06:31,870
kind of like suggesting that you write a

00:06:30,250 --> 00:06:34,810
test first so I might write this first

00:06:31,870 --> 00:06:38,110
assertion first square root of 0 should

00:06:34,810 --> 00:06:39,750
be 0 and then I go implement my square

00:06:38,110 --> 00:06:41,430
root function and just return 0

00:06:39,750 --> 00:06:43,650
and now my test passes then I'll add

00:06:41,430 --> 00:06:45,150
another test another assertion square

00:06:43,650 --> 00:06:47,190
root of 1 should equal 1 now my test

00:06:45,150 --> 00:06:48,690
fails again so I'll go actually

00:06:47,190 --> 00:06:54,690
implement my algorithm for square root

00:06:48,690 --> 00:06:57,050
right and what that doesn't do though is

00:06:54,690 --> 00:07:01,050
it doesn't capture the generality of

00:06:57,050 --> 00:07:02,970
what Bertrand Meyer had in Eiffel it if

00:07:01,050 --> 00:07:06,090
you look back here what he's saying is

00:07:02,970 --> 00:07:09,060
really about all possible values of type

00:07:06,090 --> 00:07:10,620
real all inhabitants of type real for

00:07:09,060 --> 00:07:12,750
all reals

00:07:10,620 --> 00:07:16,710
you know if X is greater than or equal

00:07:12,750 --> 00:07:18,990
to 0 then after you you know the answer

00:07:16,710 --> 00:07:20,370
you that comes back from this function

00:07:18,990 --> 00:07:23,820
should hope you know the post condition

00:07:20,370 --> 00:07:26,190
should be helped be true about so this

00:07:23,820 --> 00:07:27,540
just says well 1 and 0 and maybe 42 or

00:07:26,190 --> 00:07:32,160
whatever I think are useful things to

00:07:27,540 --> 00:07:33,690
try and this came to be called example

00:07:32,160 --> 00:07:35,580
based testing after property based

00:07:33,690 --> 00:07:38,520
testing came along so what you can also

00:07:35,580 --> 00:07:40,050
do in Scala is use a property based test

00:07:38,520 --> 00:07:42,690
where you get the sort of the same

00:07:40,050 --> 00:07:46,650
generality that you get with Eiffel with

00:07:42,690 --> 00:07:48,570
divided by contract I can say for all

00:07:46,650 --> 00:07:50,070
doubles whenever and then I just repeat

00:07:48,570 --> 00:07:52,910
the precondition so I'm repeating myself

00:07:50,070 --> 00:07:55,370
so I say it in the require in the

00:07:52,910 --> 00:08:00,680
production code and then I say it in the

00:07:55,370 --> 00:08:00,680
whenever and the this is like Scala test

00:08:00,950 --> 00:08:06,510
property and then I compute I call

00:08:04,650 --> 00:08:07,830
square root and pass in X and I get a

00:08:06,510 --> 00:08:09,479
result so that's where my result comes

00:08:07,830 --> 00:08:10,919
from and then I do this sort of the post

00:08:09,479 --> 00:08:13,200
condition check that's the post

00:08:10,919 --> 00:08:15,750
condition check same post condition

00:08:13,200 --> 00:08:18,030
check so that's actually what happens to

00:08:15,750 --> 00:08:19,680
design my contract if you if you don't

00:08:18,030 --> 00:08:21,540
stick it in the code and you actually

00:08:19,680 --> 00:08:24,150
move it out to the outside is you you

00:08:21,540 --> 00:08:26,010
you need a for all and so that actually

00:08:24,150 --> 00:08:28,140
looks like predicate logic so the talk I

00:08:26,010 --> 00:08:29,490
would give two years ago yes since of

00:08:28,140 --> 00:08:33,930
testing I said well this is actually

00:08:29,490 --> 00:08:36,030
what a test is sort of thing the by

00:08:33,930 --> 00:08:38,250
Nature it's a statement of logic that

00:08:36,030 --> 00:08:42,690
and the upside down a is for all so for

00:08:38,250 --> 00:08:43,979
all X P and Q are predicates if this

00:08:42,690 --> 00:08:45,900
predicate logic you can have a predicate

00:08:43,979 --> 00:08:49,350
function that takes input and returns

00:08:45,900 --> 00:08:51,780
boolean right so P I've actually kind of

00:08:49,350 --> 00:08:53,010
said 4 by square root function f is

00:08:51,780 --> 00:08:56,010
square root that's the function

00:08:53,010 --> 00:08:57,330
specifying the type of X is double so

00:08:56,010 --> 00:08:58,830
for all X that actually means for all

00:08:57,330 --> 00:08:59,820
inhabitants of double and that includes

00:08:58,830 --> 00:09:04,170
not a number because that's an

00:08:59,820 --> 00:09:05,760
inhabitant of double so add FP double it

00:09:04,170 --> 00:09:07,440
takes a double returns boolean it just

00:09:05,760 --> 00:09:09,150
has that precondition it's true or false

00:09:07,440 --> 00:09:10,890
right that's the precondition so if

00:09:09,150 --> 00:09:14,460
that's true that little arrow there

00:09:10,890 --> 00:09:17,280
means implies and that means sort of

00:09:14,460 --> 00:09:19,680
if-then right so if the predicate holds

00:09:17,280 --> 00:09:20,970
then the post condition should hold if

00:09:19,680 --> 00:09:23,220
the precondition that's true then the

00:09:20,970 --> 00:09:24,890
post Kishin must be true and the post

00:09:23,220 --> 00:09:28,830
condition is a predicate function that

00:09:24,890 --> 00:09:32,640
works off of the input like X and the

00:09:28,830 --> 00:09:34,740
result f of X so in our case I'm going

00:09:32,640 --> 00:09:36,780
to pass in the X and was and result and

00:09:34,740 --> 00:09:40,050
I do my post condition that's the same

00:09:36,780 --> 00:09:42,780
post condition math so that's that was

00:09:40,050 --> 00:09:46,850
the essence of testing is that that you

00:09:42,780 --> 00:09:49,500
could specify a function on the outside

00:09:46,850 --> 00:09:51,090
with a statement of logic when you

00:09:49,500 --> 00:09:53,160
specify on the inside it looks like

00:09:51,090 --> 00:09:55,740
designed by contract okay so that was

00:09:53,160 --> 00:09:57,150
that talk and then a year ago or two two

00:09:55,740 --> 00:09:59,640
years ago I gave a talk called hope

00:09:57,150 --> 00:10:01,770
faith and proof which is mostly about

00:09:59,640 --> 00:10:04,680
where to use assertions in production

00:10:01,770 --> 00:10:06,780
code and one of the places I suggested

00:10:04,680 --> 00:10:08,910
that we should we do use assertions and

00:10:06,780 --> 00:10:10,920
then it makes sense is require clauses

00:10:08,910 --> 00:10:12,570
which are precondition checks and the

00:10:10,920 --> 00:10:14,010
reason is that if something really is

00:10:12,570 --> 00:10:16,140
partial the square roots of partial

00:10:14,010 --> 00:10:19,650
function we want to actually capture

00:10:16,140 --> 00:10:20,940
that early so I mean one thing using a

00:10:19,650 --> 00:10:23,160
require Clause does is it makes it

00:10:20,940 --> 00:10:24,900
really obvious that this is a pre you

00:10:23,160 --> 00:10:26,160
know that this has this precondition it

00:10:24,900 --> 00:10:28,530
kind of says that very clearly in the

00:10:26,160 --> 00:10:30,120
code but also at runtime you don't ever

00:10:28,530 --> 00:10:31,350
want that to actually happen in

00:10:30,120 --> 00:10:32,640
production but if it does you want it to

00:10:31,350 --> 00:10:34,440
happen as soon as possible as soon as

00:10:32,640 --> 00:10:36,810
you can detect it so you don't want to

00:10:34,440 --> 00:10:38,580
like just not check it and then go much

00:10:36,810 --> 00:10:39,870
farther and save some corrupt data the

00:10:38,580 --> 00:10:46,620
database before you notice there's a

00:10:39,870 --> 00:10:49,290
problem right so anyway what what the

00:10:46,620 --> 00:10:52,410
other idea that I I kind of had in that

00:10:49,290 --> 00:10:53,610
talk was that if you have a require it's

00:10:52,410 --> 00:10:54,960
good to do them if you have a partial

00:10:53,610 --> 00:10:56,700
function but every time you do them you

00:10:54,960 --> 00:10:58,410
should think well can I get rid of this

00:10:56,700 --> 00:10:59,790
by moving it into the type so if I

00:10:58,410 --> 00:11:01,110
actually had a type that promised it's

00:10:59,790 --> 00:11:02,430
not an odd number it's greater than

00:11:01,110 --> 00:11:04,140
equal zero and it's not positive

00:11:02,430 --> 00:11:06,300
infinity then I could get rid of the

00:11:04,140 --> 00:11:08,040
require clause so that looks like this

00:11:06,300 --> 00:11:09,930
so I actually could go to the shelf and

00:11:08,040 --> 00:11:12,840
pull off a positive or zero finite

00:11:09,930 --> 00:11:14,850
double type then I could get rid of the

00:11:12,840 --> 00:11:18,420
require clause and what I did is I

00:11:14,850 --> 00:11:19,740
remove one place that this could blow up

00:11:18,420 --> 00:11:22,230
in production and I called this an

00:11:19,740 --> 00:11:25,260
expression of hope because I hope no one

00:11:22,230 --> 00:11:27,240
ever passes you know negative three to

00:11:25,260 --> 00:11:30,510
this but I have no evidence that they

00:11:27,240 --> 00:11:32,220
won't write when I do this the problem

00:11:30,510 --> 00:11:33,840
with it is I've just moved the problem

00:11:32,220 --> 00:11:35,700
to the call sites because if somebody

00:11:33,840 --> 00:11:36,900
wants to call square root and they have

00:11:35,700 --> 00:11:40,800
a double in hand they're gonna have to

00:11:36,900 --> 00:11:42,840
convert it to this thing and that could

00:11:40,800 --> 00:11:45,930
involve blowing up with an exception

00:11:42,840 --> 00:11:48,930
right if it's negative but what I think

00:11:45,930 --> 00:11:50,790
is usually the case at the call site is

00:11:48,930 --> 00:11:52,710
you have nearby evidence that it will

00:11:50,790 --> 00:11:54,330
always succeed so the other kind of

00:11:52,710 --> 00:11:56,670
assertion that I suggested it's good to

00:11:54,330 --> 00:11:58,800
use in production code is the kind where

00:11:56,670 --> 00:12:01,050
you make an assertion with nearby

00:11:58,800 --> 00:12:02,940
evidence that it will always succeed if

00:12:01,050 --> 00:12:05,790
you believe it will always succeed and

00:12:02,940 --> 00:12:09,330
you move it to the type so this would

00:12:05,790 --> 00:12:12,000
like move this knowledge that you know

00:12:09,330 --> 00:12:13,770
this is true about this value to the

00:12:12,000 --> 00:12:15,510
type and capture the type and then I

00:12:13,770 --> 00:12:17,880
never have to check it again and what

00:12:15,510 --> 00:12:22,530
that illustrates is that we trust types

00:12:17,880 --> 00:12:24,630
to fulfill their contract so just if you

00:12:22,530 --> 00:12:27,630
pass me an int I never you know do an

00:12:24,630 --> 00:12:29,280
assertion is the value greater than or

00:12:27,630 --> 00:12:31,700
equal to a min int and less than equal

00:12:29,280 --> 00:12:33,690
to max int I just trust that right

00:12:31,700 --> 00:12:35,190
because of I didn't trust types to

00:12:33,690 --> 00:12:36,960
implement their contractor to fulfill

00:12:35,190 --> 00:12:39,030
their promises I'd have to put all kinds

00:12:36,960 --> 00:12:42,000
of sessions all over the place so that's

00:12:39,030 --> 00:12:43,710
where we hang our our belief on we

00:12:42,000 --> 00:12:45,270
believe that types going to fulfill

00:12:43,710 --> 00:12:46,740
their contact and we pretend even though

00:12:45,270 --> 00:12:47,760
we know there are bugs out there and

00:12:46,740 --> 00:12:49,200
sometimes they won't fulfill the

00:12:47,760 --> 00:12:52,490
contracts meet the way we program is

00:12:49,200 --> 00:12:54,690
that we trust them okay so that's

00:12:52,490 --> 00:12:56,760
essentially the two things from from

00:12:54,690 --> 00:12:59,310
past talks I wanted to kind of read and

00:12:56,760 --> 00:13:01,050
start with because this talk builds on

00:12:59,310 --> 00:13:03,120
top of them the first one is that's sort

00:13:01,050 --> 00:13:05,100
of the nature of how you would specify a

00:13:03,120 --> 00:13:08,250
function f of X is a little statement of

00:13:05,100 --> 00:13:09,930
predicate logic and then we trust types

00:13:08,250 --> 00:13:11,700
to correctly implement their contracts

00:13:09,930 --> 00:13:14,750
in practice when we program when we

00:13:11,700 --> 00:13:17,160
write code ok so now to the new stuff

00:13:14,750 --> 00:13:18,810
for this I'm going to use natural number

00:13:17,160 --> 00:13:23,700
as an example

00:13:18,810 --> 00:13:26,250
and what this is also kind of like if

00:13:23,700 --> 00:13:27,420
then the top if the thing on top of the

00:13:26,250 --> 00:13:29,640
line is true then the thing on the

00:13:27,420 --> 00:13:32,640
bottom of the line is true so what a

00:13:29,640 --> 00:13:34,350
natural number is is well in computer

00:13:32,640 --> 00:13:36,960
science we usually start with 0 0 1 2 3

00:13:34,350 --> 00:13:41,160
4 5 6 7 . right so it's actually an

00:13:36,960 --> 00:13:44,430
infinite set of numbers

00:13:41,160 --> 00:13:47,610
it never ends right so what this is is a

00:13:44,430 --> 00:13:50,700
way to this is using induction to define

00:13:47,610 --> 00:13:52,890
an infinite set with a very finite set

00:13:50,700 --> 00:13:55,140
of rules right so the first rule is the

00:13:52,890 --> 00:13:56,730
base case and that is sort of like we

00:13:55,140 --> 00:13:58,410
don't have any precondition that has to

00:13:56,730 --> 00:14:00,290
be true before on top there's nothing

00:13:58,410 --> 00:14:03,630
out there so that's going to like true

00:14:00,290 --> 00:14:06,210
so there's just a 0 we're just going to

00:14:03,630 --> 00:14:09,210
Clare zero as a natural number that's

00:14:06,210 --> 00:14:11,730
kind of like let there be zero and then

00:14:09,210 --> 00:14:14,100
the second rule here is the inductive

00:14:11,730 --> 00:14:16,080
rule which says if P is a natural number

00:14:14,100 --> 00:14:17,550
then the successor to P is a natural

00:14:16,080 --> 00:14:22,710
number and I pick B because that stands

00:14:17,550 --> 00:14:27,900
for predecessor so you know on the

00:14:22,710 --> 00:14:30,690
zeroeth day when you wake up you can get

00:14:27,900 --> 00:14:32,850
0 because it's just that's free it's

00:14:30,690 --> 00:14:37,410
just 0 exists right let there be 0 on

00:14:32,850 --> 00:14:38,880
day 1 the next day I can say well 0 is a

00:14:37,410 --> 00:14:40,380
natural number therefore the successor

00:14:38,880 --> 00:14:42,330
to 0 is a natural number and I get 1

00:14:40,380 --> 00:14:45,600
right and then on day 2

00:14:42,330 --> 00:14:46,860
I got 0 and 1 so I can say well what is

00:14:45,600 --> 00:14:48,390
a natural number therefore the successor

00:14:46,860 --> 00:14:50,010
to 1 is a natural number and that's two

00:14:48,390 --> 00:14:52,460
right so that goes that sort of is how

00:14:50,010 --> 00:14:54,839
you define with induction an infinite

00:14:52,460 --> 00:14:55,350
data type and in Scala you could do it

00:14:54,839 --> 00:14:58,620
this way

00:14:55,350 --> 00:15:03,990
I say seal trade net case object 0

00:14:58,620 --> 00:15:06,330
extends net and case classic suck it

00:15:03,990 --> 00:15:09,839
takes a predicate a private sorry a

00:15:06,330 --> 00:15:12,839
predecessor which is a natural number

00:15:09,839 --> 00:15:14,640
right P is a subtype of net and that's

00:15:12,839 --> 00:15:17,029
my two cases and I can just demo that

00:15:14,640 --> 00:15:17,029
real quick

00:15:21,120 --> 00:15:27,089
okay go over there this guy just paste

00:15:24,389 --> 00:15:28,949
that in there so I could say Val's ero

00:15:27,089 --> 00:15:31,680
the little Z is zero

00:15:28,949 --> 00:15:33,389
well one so this is now that I have zero

00:15:31,680 --> 00:15:35,759
I can use the other rule the inductive

00:15:33,389 --> 00:15:38,790
rule and say one is the successor to

00:15:35,759 --> 00:15:41,399
zero I can say - is this successor to

00:15:38,790 --> 00:15:43,230
one right and then I could I could keep

00:15:41,399 --> 00:15:48,209
going but I only have 40 minutes for

00:15:43,230 --> 00:15:50,129
this talk but it goes forever right so

00:15:48,209 --> 00:15:51,809
what you'll see here I you know the way

00:15:50,129 --> 00:15:56,040
I wrote this you it does capture in the

00:15:51,809 --> 00:15:57,540
type what the number is - and in the two

00:15:56,040 --> 00:16:00,389
string you can see the nesting of these

00:15:57,540 --> 00:16:02,339
suck classes and you can just count them

00:16:00,389 --> 00:16:05,639
so you know this is a one because it has

00:16:02,339 --> 00:16:08,490
one suck constructor invitation there's

00:16:05,639 --> 00:16:09,889
two sucks here and that's two right and

00:16:08,490 --> 00:16:15,899
there's zero sucks here so that's zero

00:16:09,889 --> 00:16:20,040
okay so that's that guy and then now I

00:16:15,899 --> 00:16:23,879
want to add a method to it - I want to

00:16:20,040 --> 00:16:26,490
add add to add to natural numbers so I

00:16:23,879 --> 00:16:28,709
define just a an abstract method in my

00:16:26,490 --> 00:16:33,689
sealed trait net that is + takes a matte

00:16:28,709 --> 00:16:36,420
and returns an at and then in my zero

00:16:33,689 --> 00:16:37,860
case I just returned the right-hand side

00:16:36,420 --> 00:16:39,720
so it takes I called it our because

00:16:37,860 --> 00:16:41,999
that's the right-hand side and you know

00:16:39,720 --> 00:16:43,980
adding zero to anything to zero is that

00:16:41,999 --> 00:16:45,899
whatever you add it to zero so that's

00:16:43,980 --> 00:16:49,980
that's that one and then over in the

00:16:45,899 --> 00:16:51,829
successor case what I do is basically

00:16:49,980 --> 00:16:58,290
the call side you have successor of P

00:16:51,829 --> 00:17:01,800
plus one so let's say P is 3 plus 1 so

00:16:58,290 --> 00:17:04,559
the successor to 3 is 4 plus 1 is 5

00:17:01,800 --> 00:17:07,620
right so what I what I do here is I say

00:17:04,559 --> 00:17:10,409
well if you just add 4 plus 1 I'm sorry

00:17:07,620 --> 00:17:11,970
the successor to 3p is 3 3 plus 1 that

00:17:10,409 --> 00:17:13,289
gives me 4 and then I take the sis of

00:17:11,970 --> 00:17:15,329
that that gives me 5 that's the same

00:17:13,289 --> 00:17:17,390
thing and I'm what I'm doing is I'm

00:17:15,329 --> 00:17:20,789
calling myself recursively with one less

00:17:17,390 --> 00:17:22,649
than this so it will eventually hit the

00:17:20,789 --> 00:17:26,459
zero case which doesn't recurse anymore

00:17:22,649 --> 00:17:33,030
so I can demo that just so you believe

00:17:26,459 --> 00:17:34,620
that it actually does add some ask you

00:17:33,030 --> 00:17:41,350
my

00:17:34,620 --> 00:17:44,350
my little inventing I could not try to

00:17:41,350 --> 00:17:48,280
talk while I'm doing this equals equals

00:17:44,350 --> 00:17:49,990
successor of two through one that would

00:17:48,280 --> 00:17:51,460
loop forever and then I'll just make it

00:17:49,990 --> 00:17:53,530
free for the heck of it three equals

00:17:51,460 --> 00:17:57,940
success or of two so you get the idea so

00:17:53,530 --> 00:18:00,490
if I say for example 0 plus 1 I get 1

00:17:57,940 --> 00:18:01,780
there's one stuck there 0 plus 3 I get I

00:18:00,490 --> 00:18:05,440
should get 3 sucks

00:18:01,780 --> 00:18:07,299
yep that's 3 if I say 2 plus 3 I should

00:18:05,440 --> 00:18:11,650
get 5 so I'm gonna count them there's

00:18:07,299 --> 00:18:19,630
one two whoops three four or five right

00:18:11,650 --> 00:18:22,480
so that's addition okay so so that was

00:18:19,630 --> 00:18:24,360
addition and now what I want to do is

00:18:22,480 --> 00:18:27,429
write a test I didn't write a test first

00:18:24,360 --> 00:18:30,039
so I want to write a test second and I

00:18:27,429 --> 00:18:31,990
want to say that my plus method is going

00:18:30,039 --> 00:18:37,990
to promise that it will be associative

00:18:31,990 --> 00:18:39,370
right so when I I say basically a plus

00:18:37,990 --> 00:18:43,090
if I have three natural numbers a B and

00:18:39,370 --> 00:18:46,570
C a plus B plus C equals a plus B plus C

00:18:43,090 --> 00:18:49,230
right so I could do a few example based

00:18:46,570 --> 00:18:52,150
tests like this 1 plus 1 plus 2 Plus 3

00:18:49,230 --> 00:18:54,340
must equal 1 plus 2 plus 3 right and

00:18:52,150 --> 00:18:56,530
then I have another one and so on right

00:18:54,340 --> 00:18:58,390
so that's example based test but you

00:18:56,530 --> 00:19:00,460
could also do the for all the thing I

00:18:58,390 --> 00:19:02,710
mean essentially it doesn't capture this

00:19:00,460 --> 00:19:06,429
notion of that it's for all natural

00:19:02,710 --> 00:19:08,230
numbers ABC I want this to be

00:19:06,429 --> 00:19:10,720
associative so I could do it for all

00:19:08,230 --> 00:19:14,650
like this I'll just say for all natural

00:19:10,720 --> 00:19:18,610
numbers a B and C a plus B plus C must

00:19:14,650 --> 00:19:20,950
equal a plus B plus B that's kinda hard

00:19:18,610 --> 00:19:23,530
to say but so I'll show you that that's

00:19:20,950 --> 00:19:25,450
I got that over here so you see here's

00:19:23,530 --> 00:19:31,240
my natural number that's just like I had

00:19:25,450 --> 00:19:32,860
on the slide there and then in this to

00:19:31,240 --> 00:19:34,960
use a property-based test that one other

00:19:32,860 --> 00:19:37,419
thing I need is I need a generator for

00:19:34,960 --> 00:19:39,460
natural numbers and so here I just used

00:19:37,419 --> 00:19:41,169
took an in generator and said from 0 and

00:19:39,460 --> 00:19:42,280
100 because these things actually do

00:19:41,169 --> 00:19:43,750
take up memory are probably in

00:19:42,280 --> 00:19:45,760
production would use a larger one but

00:19:43,750 --> 00:19:47,110
you want to don't want to have it like 0

00:19:45,760 --> 00:19:48,399
2 billion because you might run out of

00:19:47,110 --> 00:19:50,379
memory

00:19:48,399 --> 00:19:52,539
so let's just say 0 200 and I just have

00:19:50,379 --> 00:19:54,460
a to NAT method that's recursively you

00:19:52,539 --> 00:19:58,000
know takes an int and turns it into a

00:19:54,460 --> 00:19:59,889
natural number and then down here I just

00:19:58,000 --> 00:20:07,779
say for all natural numbers a b and c

00:19:59,889 --> 00:20:09,009
and there's my little assertion so i can

00:20:07,779 --> 00:20:12,220
actually just exit here and just run the

00:20:09,009 --> 00:20:15,190
test and you will see it passes all

00:20:12,220 --> 00:20:18,309
right so what I also wrote here just to

00:20:15,190 --> 00:20:23,129
gonna let you see what what's going on

00:20:18,309 --> 00:20:25,870
is a little function called two int that

00:20:23,129 --> 00:20:28,149
put inside here to int will take a

00:20:25,870 --> 00:20:30,549
natural number and return it goes the

00:20:28,149 --> 00:20:32,830
other direction as my little tune add up

00:20:30,549 --> 00:20:36,549
here and it's again it's a recursive

00:20:32,830 --> 00:20:38,379
tail recursive loop and so what I'm

00:20:36,549 --> 00:20:40,360
gonna do now is for each one of these

00:20:38,379 --> 00:20:42,100
tests that we test I'm gonna print out

00:20:40,360 --> 00:20:43,809
so you can see what's printing so you'll

00:20:42,100 --> 00:20:45,370
see the integer version of it and then

00:20:43,809 --> 00:20:47,440
you'll see the actual natural number

00:20:45,370 --> 00:20:49,360
version of it here so now when I run my

00:20:47,440 --> 00:20:51,519
test you'll see a bunch of you know

00:20:49,360 --> 00:20:53,409
print statements and in this is scala

00:20:51,519 --> 00:20:56,529
test generator that will be out in 3.1

00:20:53,409 --> 00:21:01,440
and we do 20% edge cases combination so

00:20:56,529 --> 00:21:04,990
here's 100 101 so though there's like

00:21:01,440 --> 00:21:07,149
what's the next one one zero a hundred

00:21:04,990 --> 00:21:08,529
so here's one here's zero and this is

00:21:07,149 --> 00:21:09,850
what a hundred looks like and it thinks

00:21:08,529 --> 00:21:12,129
hundred is an edge case because I use it

00:21:09,850 --> 00:21:14,080
in scenes ero and a hundred then we just

00:21:12,129 --> 00:21:15,879
kind of randomly all over the place try

00:21:14,080 --> 00:21:19,629
stuff but one of the things I did in try

00:21:15,879 --> 00:21:23,850
is 101 right because I'm only going 0 to

00:21:19,629 --> 00:21:28,950
100 so even though this looks like

00:21:23,850 --> 00:21:32,440
predicate logic this for all it actually

00:21:28,950 --> 00:21:33,490
doesn't it's still example based testing

00:21:32,440 --> 00:21:41,440
in a sense because I'm just trying

00:21:33,490 --> 00:21:42,730
different things so what I wanted I had

00:21:41,440 --> 00:21:45,610
this slide also in my hope faith and

00:21:42,730 --> 00:21:47,350
proof talk and it's called maybe I said

00:21:45,610 --> 00:21:50,080
cuz my instead is often quoted as saying

00:21:47,350 --> 00:21:52,299
this but there was actually no evidence

00:21:50,080 --> 00:21:54,639
after the fact that he said it so maybe

00:21:52,299 --> 00:21:55,899
he didn't say it but what what the quote

00:21:54,639 --> 00:21:58,360
is is that no amount of experimentation

00:21:55,899 --> 00:21:59,660
can ever prove me right a single

00:21:58,360 --> 00:22:02,270
experiment can prove me

00:21:59,660 --> 00:22:03,980
and so like the theory of relativity

00:22:02,270 --> 00:22:06,860
because it's it's like a theory it's a

00:22:03,980 --> 00:22:08,180
mathematical model of reality so the

00:22:06,860 --> 00:22:11,600
scientific method says we don't just

00:22:08,180 --> 00:22:13,190
take that on faith we try it we do

00:22:11,600 --> 00:22:17,240
experiments to see if that you know

00:22:13,190 --> 00:22:20,300
actually holds and no matter how many of

00:22:17,240 --> 00:22:23,210
those experiments you do that's not a

00:22:20,300 --> 00:22:25,250
proof that it's correct some day like

00:22:23,210 --> 00:22:27,650
tomorrow there could be an experiment

00:22:25,250 --> 00:22:29,390
that actually shows there's a problem

00:22:27,650 --> 00:22:31,370
with it and it needs to be updated right

00:22:29,390 --> 00:22:33,260
so that's kind of what we do with

00:22:31,370 --> 00:22:35,900
software development today when we write

00:22:33,260 --> 00:22:36,920
tests is where we're doing science where

00:22:35,900 --> 00:22:39,070
we're saying well I'm not gonna have

00:22:36,920 --> 00:22:41,540
faith that my thing works even though

00:22:39,070 --> 00:22:44,000
you know maybe I'm thinking it looks

00:22:41,540 --> 00:22:48,410
like it should work I'm gonna test it

00:22:44,000 --> 00:22:49,610
and make sure right and those tests even

00:22:48,410 --> 00:22:53,570
if it's a for all because we're just

00:22:49,610 --> 00:22:58,400
trying certain certain values doesn't

00:22:53,570 --> 00:23:02,030
prove that it works right it just makes

00:22:58,400 --> 00:23:04,490
me more confident that it works but if

00:23:02,030 --> 00:23:06,850
you have a test that fails that's pretty

00:23:04,490 --> 00:23:09,500
close to a proof that there's a problem

00:23:06,850 --> 00:23:10,670
either there's a bug in my algorithm or

00:23:09,500 --> 00:23:12,260
there's a bug in my tests or there's a

00:23:10,670 --> 00:23:14,540
misunderstanding so there's a bug in our

00:23:12,260 --> 00:23:16,190
or communication or there could be a bug

00:23:14,540 --> 00:23:21,290
in the hardware who knows but there's a

00:23:16,190 --> 00:23:22,670
problem okay so what you can do in in in

00:23:21,290 --> 00:23:25,070
programming is you actually can do

00:23:22,670 --> 00:23:27,350
better because programming at least the

00:23:25,070 --> 00:23:30,620
functional part of your code is like

00:23:27,350 --> 00:23:32,510
kind of can be treated mathematically

00:23:30,620 --> 00:23:35,120
and then you can do proofs so what I'm

00:23:32,510 --> 00:23:37,730
gonna do is I'm gonna prove 1 plus 2 1

00:23:35,120 --> 00:23:40,190
plus 2 plus 3 equals 1 plus 2 plus 3

00:23:37,730 --> 00:23:43,130
right so what I'll do is I'll start with

00:23:40,190 --> 00:23:46,640
the left-hand side of that equality and

00:23:43,130 --> 00:23:51,560
then I can say well 1 plus 2 is 3 3 plus

00:23:46,640 --> 00:23:53,960
3 is 6 well 6 is 1 plus 5 right and 5 is

00:23:51,560 --> 00:23:56,150
2 plus 3 and what I did is I started on

00:23:53,960 --> 00:23:57,560
the left hand side and I ended up on the

00:23:56,150 --> 00:24:01,370
right hand side so that's that's my

00:23:57,560 --> 00:24:02,690
proof so in when you see mathematicians

00:24:01,370 --> 00:24:04,400
doing proofs they either end it with a

00:24:02,690 --> 00:24:05,300
QED or this little square which is

00:24:04,400 --> 00:24:08,090
pronounced voila

00:24:05,300 --> 00:24:10,580
it means here's my proof right so I just

00:24:08,090 --> 00:24:12,470
did it so I could do that again with

00:24:10,580 --> 00:24:13,460
with this other example but this is kind

00:24:12,470 --> 00:24:16,549
of like example based

00:24:13,460 --> 00:24:18,770
proof right what I haven't done is I

00:24:16,549 --> 00:24:20,539
haven't said that I've proven that for

00:24:18,770 --> 00:24:22,580
all natural numbers a B and C

00:24:20,539 --> 00:24:29,840
associative you know addition is

00:24:22,580 --> 00:24:30,590
associative right so to do that I so

00:24:29,840 --> 00:24:32,960
that's what I'm going to try to do now

00:24:30,590 --> 00:24:34,909
and what I'm going to do is I'm going to

00:24:32,960 --> 00:24:40,640
pull some sort of mathematical equality

00:24:34,909 --> 00:24:42,200
x' out of my code so for the 0 case what

00:24:40,640 --> 00:24:45,200
I can say is that 0 plus R equals R

00:24:42,200 --> 00:24:48,470
because if a client says 0 plus R what

00:24:45,200 --> 00:24:49,669
execute is it returns R so you can kind

00:24:48,470 --> 00:24:52,070
of like see the left side of the equal

00:24:49,669 --> 00:24:54,890
side a sign is the client code the right

00:24:52,070 --> 00:24:58,460
side of equal sign is the body right and

00:24:54,890 --> 00:25:00,110
then for the successor case the left

00:24:58,460 --> 00:25:01,789
side of the equal sign here is sort of

00:25:00,110 --> 00:25:03,289
the client could again successor of P

00:25:01,789 --> 00:25:07,130
plus R that will invoke this function

00:25:03,289 --> 00:25:09,169
and that kind of substitutes the the

00:25:07,130 --> 00:25:11,990
right-hand side expressions which is the

00:25:09,169 --> 00:25:14,419
body right successor of P plus part are

00:25:11,990 --> 00:25:18,260
in parentheses so now I basically want

00:25:14,419 --> 00:25:21,289
to prove you know my for all for all ABC

00:25:18,260 --> 00:25:24,740
addition is associative for all natural

00:25:21,289 --> 00:25:26,149
numbers and I know these things and I

00:25:24,740 --> 00:25:31,730
also am I going to allow myself to add

00:25:26,149 --> 00:25:33,230
or remove parentheses ok so because I

00:25:31,730 --> 00:25:34,850
mean one way to do this is just

00:25:33,230 --> 00:25:37,669
enumerate them right I say one plus two

00:25:34,850 --> 00:25:39,140
plus three equals one plus two plus

00:25:37,669 --> 00:25:41,360
three I just proved that so I could say

00:25:39,140 --> 00:25:43,909
well 1 plus 2 plus 4 equals 1 plus 2

00:25:41,360 --> 00:25:45,679
plus 4 right but of course again it's

00:25:43,909 --> 00:25:48,500
infinite so that you can never enter

00:25:45,679 --> 00:25:51,649
right all of them so I'm gonna prove by

00:25:48,500 --> 00:25:57,080
induction which kind of mirrors the way

00:25:51,649 --> 00:26:00,049
I defined the the data type in the first

00:25:57,080 --> 00:26:02,630
place so I'm going to prove basically

00:26:00,049 --> 00:26:06,710
I'm going to substitute a for either 0

00:26:02,630 --> 00:26:08,840
or a successor of P so in the 0 case I'm

00:26:06,710 --> 00:26:12,500
gonna basically a plus B plus C becomes

00:26:08,840 --> 00:26:15,260
0 plus B plus C and that equals 0 plus

00:26:12,500 --> 00:26:17,419
and then / in parens B plus C and that

00:26:15,260 --> 00:26:21,039
one I'm just going to prove like I did 1

00:26:17,419 --> 00:26:23,419
2 3 right just prove it right out right

00:26:21,039 --> 00:26:26,570
but then the rest of it I'll use an

00:26:23,419 --> 00:26:27,410
inductive kind of proof where I I say

00:26:26,570 --> 00:26:33,530
well

00:26:27,410 --> 00:26:36,050
P plus B plus C equals P plus B plus C

00:26:33,530 --> 00:26:39,080
that that's my like precondition if

00:26:36,050 --> 00:26:42,050
that's true then successor of P plus B

00:26:39,080 --> 00:26:44,300
and Prince plus C equals successor of P

00:26:42,050 --> 00:26:46,820
plus B plus C and that that's sort of my

00:26:44,300 --> 00:26:48,710
you know I have to prove that and what

00:26:46,820 --> 00:26:50,360
my my my

00:26:48,710 --> 00:26:55,520
you know claim is is that if I prove

00:26:50,360 --> 00:26:57,670
both of these then that proves that my

00:26:55,520 --> 00:27:02,180
addition is associated my dition method

00:26:57,670 --> 00:27:03,320
okay so because we're programmers and

00:27:02,180 --> 00:27:06,320
well because I'm a programmer I think of

00:27:03,320 --> 00:27:10,640
this as a algorithm so like given an a

00:27:06,320 --> 00:27:12,260
if a is 0 like you know you can say a

00:27:10,640 --> 00:27:15,020
match case is 0 right

00:27:12,260 --> 00:27:19,610
if it's a 0 then I need to prove this

00:27:15,020 --> 00:27:23,000
for all B C 0 plus B plus C equals 0

00:27:19,610 --> 00:27:24,530
plus B plus C right otherwise you know

00:27:23,000 --> 00:27:27,230
since a isn't 0 that means it has to be

00:27:24,530 --> 00:27:31,070
a successor and there's a P in there so

00:27:27,230 --> 00:27:32,510
I would need to prove for all P BC and

00:27:31,070 --> 00:27:37,420
there's my if n right there's like the

00:27:32,510 --> 00:27:40,760
top and the bottom of that rule if

00:27:37,420 --> 00:27:43,460
peoples B in parens plus C equals P plus

00:27:40,760 --> 00:27:45,440
B plus C right if that's true then I

00:27:43,460 --> 00:27:48,860
need to prove this this bottom line

00:27:45,440 --> 00:27:52,490
right ok so that's my algorithm so let's

00:27:48,860 --> 00:27:53,450
do it the 0 case first so I'm going to

00:27:52,490 --> 00:27:57,230
start with the left hand side so

00:27:53,450 --> 00:27:58,940
basically a is 0 now and so that means

00:27:57,230 --> 00:28:02,210
that the you know the left hand side of

00:27:58,940 --> 00:28:03,680
my equation is 0 plus B and parens plus

00:28:02,210 --> 00:28:05,360
C so what I can

00:28:03,680 --> 00:28:07,880
the first rewrite I can do is because I

00:28:05,360 --> 00:28:10,760
know 0 plus R equals R I can get rid of

00:28:07,880 --> 00:28:12,110
the 0 plus there all right in other

00:28:10,760 --> 00:28:14,000
words I have one of these you know

00:28:12,110 --> 00:28:16,280
equation 0 plus R equals R that's

00:28:14,000 --> 00:28:20,540
actually from my code that I'm trying to

00:28:16,280 --> 00:28:22,460
prove is correct so so I can use it to

00:28:20,540 --> 00:28:24,590
do a substitution and then I can get rid

00:28:22,460 --> 00:28:26,150
of the parentheses because I'm allowed

00:28:24,590 --> 00:28:27,590
to do that and then I can actually add a

00:28:26,150 --> 00:28:30,500
different set of parentheses because I'm

00:28:27,590 --> 00:28:32,990
allowed to do that right and now I can

00:28:30,500 --> 00:28:35,840
go back to my my rule but go from right

00:28:32,990 --> 00:28:38,780
to left so B plus C in parentheses you

00:28:35,840 --> 00:28:40,500
can see as R on the right hand side so I

00:28:38,780 --> 00:28:43,170
can stick a 0 plus in front of it

00:28:40,500 --> 00:28:44,520
right and now I basically ended up with

00:28:43,170 --> 00:28:45,870
the right hand side of my equality this

00:28:44,520 --> 00:28:50,190
is just kind of like the way I prove one

00:28:45,870 --> 00:28:54,210
two three I got I got two basically I

00:28:50,190 --> 00:28:58,170
just proved that base case so that's

00:28:54,210 --> 00:29:00,900
that one and so now the more tricky one

00:28:58,170 --> 00:29:05,990
is this guy so I'm going to start with

00:29:00,900 --> 00:29:09,540
the left hand side again and it's

00:29:05,990 --> 00:29:13,470
essentially I'm over here I substituted

00:29:09,540 --> 00:29:16,050
0 for a at the top line there 0 plus B

00:29:13,470 --> 00:29:18,840
plus C that's one case the other case is

00:29:16,050 --> 00:29:19,650
I'm substituting successor of P for a so

00:29:18,840 --> 00:29:23,220
that's why I start with that

00:29:19,650 --> 00:29:24,960
so successor P plus B and Prinze plus C

00:29:23,220 --> 00:29:28,800
that's what I start with so now what I

00:29:24,960 --> 00:29:31,650
can do is inside the Prince there I have

00:29:28,800 --> 00:29:34,080
the left hand side like I have the shape

00:29:31,650 --> 00:29:37,710
successor of Y plus R except you know Y

00:29:34,080 --> 00:29:39,840
is P and R as B so I can actually change

00:29:37,710 --> 00:29:41,640
it to the right hand side so now inside

00:29:39,840 --> 00:29:44,010
the the outer friends there it's its

00:29:41,640 --> 00:29:45,750
successor of P plus B that was that's

00:29:44,010 --> 00:29:51,990
actually from my code that's what my

00:29:45,750 --> 00:29:54,210
codes gonna do and then I can get rid of

00:29:51,990 --> 00:29:55,890
those extra prints that I don't need

00:29:54,210 --> 00:29:58,400
anymore for that that same rule of being

00:29:55,890 --> 00:30:00,540
able to add and remove put the C's and

00:29:58,400 --> 00:30:02,670
I'm going to use this rule again it's

00:30:00,540 --> 00:30:06,300
the same like the lit has that left hand

00:30:02,670 --> 00:30:09,120
shape again where Y is now P plus B and

00:30:06,300 --> 00:30:10,290
R is C so I can make it look like the

00:30:09,120 --> 00:30:11,820
right hand side again this is like

00:30:10,290 --> 00:30:15,900
referring to my code this is my codes

00:30:11,820 --> 00:30:20,100
gonna do the successor of now I have a

00:30:15,900 --> 00:30:24,750
successor of P plus B plus C so the now

00:30:20,100 --> 00:30:29,070
I'm stuck so I'm gonna do something kind

00:30:24,750 --> 00:30:30,990
of iffy here and I'm actually gonna call

00:30:29,070 --> 00:30:32,640
the proof that I'm using I'm gonna

00:30:30,990 --> 00:30:35,130
actually use the proof that I'm haven't

00:30:32,640 --> 00:30:38,310
finished yet in the hope that I will be

00:30:35,130 --> 00:30:39,840
able to finish it so what if you look at

00:30:38,310 --> 00:30:42,180
the inside of the parentheses so it says

00:30:39,840 --> 00:30:45,510
successor parens so look what's inside

00:30:42,180 --> 00:30:48,270
there it's in parens P plus B then plus

00:30:45,510 --> 00:30:51,929
C right if you look up on top that's the

00:30:48,270 --> 00:30:52,980
shape of the left-hand side alright

00:30:51,929 --> 00:30:54,660
that's that's actually the shape the

00:30:52,980 --> 00:30:56,820
left inside

00:30:54,660 --> 00:30:58,620
and it's also the shape of like if you

00:30:56,820 --> 00:31:00,720
look at the first line their successor

00:30:58,620 --> 00:31:04,230
of P plus B plus C right it's the same

00:31:00,720 --> 00:31:05,850
shape so this proof what I'm praying to

00:31:04,230 --> 00:31:08,070
prove is this is associative and if I

00:31:05,850 --> 00:31:09,990
actually succeed then I'll be able to

00:31:08,070 --> 00:31:11,190
actually change that to that that's what

00:31:09,990 --> 00:31:13,920
I'm trying to prove so actually can

00:31:11,190 --> 00:31:17,090
every curse call this proof recursively

00:31:13,920 --> 00:31:20,400
if you think of it as an algorithm and

00:31:17,090 --> 00:31:22,350
but I'm gonna replace successor of P by

00:31:20,400 --> 00:31:25,890
P so if you look at the first line it

00:31:22,350 --> 00:31:28,560
says successor of p + b + prince + c and

00:31:25,890 --> 00:31:30,660
now here the second the bottom line it

00:31:28,560 --> 00:31:33,300
says p + b + C so you see it's actually

00:31:30,660 --> 00:31:35,310
one smaller and so the reason I can I

00:31:33,300 --> 00:31:37,700
believe I can do this is because I went

00:31:35,310 --> 00:31:42,270
1 small or any even if I start at it at

00:31:37,700 --> 00:31:43,890
you know a quintillion eventually like

00:31:42,270 --> 00:31:47,310
this will recurse and get all the way to

00:31:43,890 --> 00:31:48,570
0 which doesn't recurse right so anyway

00:31:47,310 --> 00:31:53,490
as long as I'm able to finish my proof

00:31:48,570 --> 00:31:55,020
this should be ok and now the last thing

00:31:53,490 --> 00:31:56,760
I need to do there's just one more step

00:31:55,020 --> 00:32:04,020
though is I can do one of these rewrites

00:31:56,760 --> 00:32:05,790
again so this one is basically the the

00:32:04,020 --> 00:32:06,510
second the last line means back up one

00:32:05,790 --> 00:32:10,170
this line

00:32:06,510 --> 00:32:11,130
looks like the right hand side now so

00:32:10,170 --> 00:32:13,770
what I can do is I can pull the

00:32:11,130 --> 00:32:16,140
successor out and so its successor of PA

00:32:13,770 --> 00:32:17,670
plus B plus B and that's actually what I

00:32:16,140 --> 00:32:20,280
was trying to get at that then that

00:32:17,670 --> 00:32:21,690
proves the the successor so so that's

00:32:20,280 --> 00:32:24,410
sort of like the feel of how you do

00:32:21,690 --> 00:32:27,990
proofs and and what I did is I took I

00:32:24,410 --> 00:32:29,070
sort of took my code and pulled it out

00:32:27,990 --> 00:32:30,630
into sort of these little mathematical

00:32:29,070 --> 00:32:33,020
statements and then I could do a proof

00:32:30,630 --> 00:32:37,110
with that okay

00:32:33,020 --> 00:32:39,420
and it's hard so what there's been a lot

00:32:37,110 --> 00:32:40,860
of research in in recent years about in

00:32:39,420 --> 00:32:43,050
the functional programming world about

00:32:40,860 --> 00:32:44,910
doing proofs like dependent light using

00:32:43,050 --> 00:32:46,410
a dependently type language so what I

00:32:44,910 --> 00:32:48,480
want to show you is what this looks like

00:32:46,410 --> 00:32:50,970
in OGG dog des is a dependently fully

00:32:48,480 --> 00:32:54,390
dependent lis type language which means

00:32:50,970 --> 00:32:58,190
you can the terms can show up in types

00:32:54,390 --> 00:33:00,570
you can index a type by a term and so

00:32:58,190 --> 00:33:02,400
what I would have to do to do this proof

00:33:00,570 --> 00:33:06,600
in August or tough like emulate my Scala

00:33:02,400 --> 00:33:07,660
code so I've got a an ADT there that

00:33:06,600 --> 00:33:11,710
sort of has the same shape

00:33:07,660 --> 00:33:17,170
as my natural number and I didn't show

00:33:11,710 --> 00:33:18,790
the addition method but what I have down

00:33:17,170 --> 00:33:22,810
here at the bottom is like you can think

00:33:18,790 --> 00:33:25,990
of s hawk as a vowel and : and then to

00:33:22,810 --> 00:33:27,580
the right of that is its type and it's a

00:33:25,990 --> 00:33:29,830
function type the arrow there is a like

00:33:27,580 --> 00:33:32,500
a function arrow so it's a like a vowel

00:33:29,830 --> 00:33:34,090
that refers to a function and it takes

00:33:32,500 --> 00:33:35,260
three natural numbers for all is kind of

00:33:34,090 --> 00:33:38,950
like syntax sugar

00:33:35,260 --> 00:33:45,640
it takes three natural numbers and what

00:33:38,950 --> 00:33:49,330
it produces is is evidence that a plus B

00:33:45,640 --> 00:33:52,600
in parens plus C will always be equal to

00:33:49,330 --> 00:33:56,560
a plus B plus C in print so this it

00:33:52,600 --> 00:34:00,690
doesn't compute it computes something of

00:33:56,560 --> 00:34:03,040
that type and so the what what these

00:34:00,690 --> 00:34:05,800
dependently type languages like Idris

00:34:03,040 --> 00:34:09,040
and Agha do is they use the curry hard

00:34:05,800 --> 00:34:10,540
ice morphism to say that propositions

00:34:09,040 --> 00:34:12,150
are the same thing as types or like

00:34:10,540 --> 00:34:15,760
they're they correspond to types and

00:34:12,150 --> 00:34:18,429
programs correspond to proofs so if you

00:34:15,760 --> 00:34:21,490
actually can you know you can describe a

00:34:18,429 --> 00:34:23,290
proposition in a type and then if you

00:34:21,490 --> 00:34:25,360
can actually get your program to compile

00:34:23,290 --> 00:34:27,310
get an inhabitant like actually

00:34:25,360 --> 00:34:29,980
implement that you know make an

00:34:27,310 --> 00:34:31,419
initialize that of a value of that type

00:34:29,980 --> 00:34:33,760
that actually is a proof that that

00:34:31,419 --> 00:34:35,590
proposition is true so that looks like

00:34:33,760 --> 00:34:37,300
this this is actually the same algorithm

00:34:35,590 --> 00:34:40,390
I just went through one well not on

00:34:37,300 --> 00:34:41,830
paper but on slides this is how you

00:34:40,390 --> 00:34:44,860
would do it in augured escape from fill

00:34:41,830 --> 00:34:48,750
water fill Wadler has a programming

00:34:44,860 --> 00:34:51,610
language foundations in ogden book so he

00:34:48,750 --> 00:34:53,230
this came from there but this is how it

00:34:51,610 --> 00:34:56,830
look so you can actually do it

00:34:53,230 --> 00:34:59,260
mechanically and it's like programming

00:34:56,830 --> 00:35:01,330
so instead of writing tests which is

00:34:59,260 --> 00:35:04,230
like programming you would write proofs

00:35:01,330 --> 00:35:08,950
which is like programming sometimes okay

00:35:04,230 --> 00:35:11,320
so anyway that's that's what that looks

00:35:08,950 --> 00:35:13,120
like and so it'll be you know the

00:35:11,320 --> 00:35:14,470
description of this talk I talked about

00:35:13,120 --> 00:35:16,690
like using statements of predicate logic

00:35:14,470 --> 00:35:18,490
to defined contracts so so going back to

00:35:16,690 --> 00:35:20,839
Bertrand Meyer he said let's define

00:35:18,490 --> 00:35:23,210
contracts formally with a

00:35:20,839 --> 00:35:24,529
her shins and what I'm suggesting and I

00:35:23,210 --> 00:35:26,269
kind of wanted to like propose this as

00:35:24,529 --> 00:35:28,099
an idea and actually I'll be here the

00:35:26,269 --> 00:35:30,140
nice thing about having my talk to be

00:35:28,099 --> 00:35:31,160
first is you guys can come up and talk

00:35:30,140 --> 00:35:32,509
to me and tell me what you think I was

00:35:31,160 --> 00:35:34,579
kind of curious what you think of this

00:35:32,509 --> 00:35:36,559
idea that we would as programmers

00:35:34,579 --> 00:35:38,329
actually do the kind of the the more

00:35:36,559 --> 00:35:40,690
formal specification of the contract but

00:35:38,329 --> 00:35:44,059
it would not be assertions it would be

00:35:40,690 --> 00:35:46,819
statements of logic so like I might say

00:35:44,059 --> 00:35:50,359
for my plus method on net zero plus our

00:35:46,819 --> 00:35:52,460
Azhar our plus zero is our that's like

00:35:50,359 --> 00:35:54,920
left identity right identity this is

00:35:52,460 --> 00:35:56,390
like the body of my my successor method

00:35:54,920 --> 00:35:57,559
I could say that that's gonna always be

00:35:56,390 --> 00:36:02,690
true

00:35:57,559 --> 00:36:05,539
and then then I have for all ABC a plus

00:36:02,690 --> 00:36:08,150
B plus C equals a plus B plus C that's

00:36:05,539 --> 00:36:09,829
associative then I have commutative and

00:36:08,150 --> 00:36:11,989
I may have other things right and that's

00:36:09,829 --> 00:36:13,489
my more formal specification of the

00:36:11,989 --> 00:36:16,420
contract usually the what we do on the

00:36:13,489 --> 00:36:19,039
Java platform is we write it in English

00:36:16,420 --> 00:36:22,130
for the most part you know we say what

00:36:19,039 --> 00:36:26,839
this thing does because if you do this

00:36:22,130 --> 00:36:29,239
then you can either use property based

00:36:26,839 --> 00:36:32,509
tests or proofs to sort of give yourself

00:36:29,239 --> 00:36:35,900
confidence that you are meeting your

00:36:32,509 --> 00:36:37,339
promise and essentially I'm promising

00:36:35,900 --> 00:36:41,989
all those things as the implementer of

00:36:37,339 --> 00:36:46,009
NAT and I proofs are really hard so

00:36:41,989 --> 00:36:49,969
maybe I don't have time or or whatever

00:36:46,009 --> 00:36:52,009
so I can use a test and I think that's

00:36:49,969 --> 00:36:53,809
fine because because we have faith in

00:36:52,009 --> 00:36:56,269
types right but this would allow us to

00:36:53,809 --> 00:36:58,910
sort of gives an extra tool like if we

00:36:56,269 --> 00:37:00,380
could add like a in addition to a test

00:36:58,910 --> 00:37:01,640
framework you had a nice proof framework

00:37:00,380 --> 00:37:03,890
that sometimes you could use where it

00:37:01,640 --> 00:37:05,839
was where it made sense then you'd have

00:37:03,890 --> 00:37:07,489
actually be better than testing it would

00:37:05,839 --> 00:37:14,650
be better than science right it would be

00:37:07,489 --> 00:37:19,779
mathematical proofs so so anyway the the

00:37:14,650 --> 00:37:22,789
the other idea that I wanted to sort of

00:37:19,779 --> 00:37:27,969
throw out there is that because we trust

00:37:22,789 --> 00:37:30,529
types we should be able to use the

00:37:27,969 --> 00:37:33,349
contract which is like these statements

00:37:30,529 --> 00:37:34,520
of logic of any of the involved types

00:37:33,349 --> 00:37:37,250
that we use

00:37:34,520 --> 00:37:38,510
as axioms so if we don't have to we can

00:37:37,250 --> 00:37:39,710
just trust that they are they are

00:37:38,510 --> 00:37:41,750
fulfilling their contract whether they

00:37:39,710 --> 00:37:43,250
had proofs or not and if they have if

00:37:41,750 --> 00:37:45,050
they're just tested I mean I don't think

00:37:43,250 --> 00:37:46,670
there's an there's I don't know that

00:37:45,050 --> 00:37:48,860
there's any proofs for ant on the JVM

00:37:46,670 --> 00:37:51,230
that it fulfills its contract but I

00:37:48,860 --> 00:37:53,990
trust that it's going to be between you

00:37:51,230 --> 00:37:56,990
know minutes and maxint and that's fine

00:37:53,990 --> 00:37:59,210
but you know so I can actually use the

00:37:56,990 --> 00:38:02,930
like for my to nth method that I showed

00:37:59,210 --> 00:38:05,240
you that sort of did the output in the

00:38:02,930 --> 00:38:08,390
test one of the things that that would

00:38:05,240 --> 00:38:09,770
have to do is it's only if this is a

00:38:08,390 --> 00:38:11,420
partial function because it's not going

00:38:09,770 --> 00:38:15,500
to work for any int greater than two

00:38:11,420 --> 00:38:17,090
well greater than MaxEnt right so that

00:38:15,500 --> 00:38:20,210
would be my precondition sort of like

00:38:17,090 --> 00:38:24,950
the P X and then I'd have to somehow

00:38:20,210 --> 00:38:26,720
Express that you know if you count the

00:38:24,950 --> 00:38:31,760
the nested levels or something then

00:38:26,720 --> 00:38:35,210
you'd get the output right in that Ana

00:38:31,760 --> 00:38:38,120
proof of that I could use all these all

00:38:35,210 --> 00:38:40,130
these guys for example because I trust

00:38:38,120 --> 00:38:41,600
NAT to fulfill its contract and I would

00:38:40,130 --> 00:38:43,790
not actually use the code even though

00:38:41,600 --> 00:38:45,950
like here they're like sort of this was

00:38:43,790 --> 00:38:48,410
based on the code I could refactor that

00:38:45,950 --> 00:38:50,390
code and I'd need to make sure that

00:38:48,410 --> 00:38:53,060
still is true even if I'm using a more

00:38:50,390 --> 00:38:56,450
efficient algorithm than then successor

00:38:53,060 --> 00:38:58,670
of P plus R or something you know I need

00:38:56,450 --> 00:39:00,380
to be like the other proofs need to

00:38:58,670 --> 00:39:03,080
depend on the interface not the

00:39:00,380 --> 00:39:09,110
implementation of the code so anyway

00:39:03,080 --> 00:39:11,960
that's that's that's the idea so and and

00:39:09,110 --> 00:39:13,850
the I kind of was thinking they're like

00:39:11,960 --> 00:39:16,160
unit test unit tests just look at one

00:39:13,850 --> 00:39:17,600
thing so unit proofs is not trying to

00:39:16,160 --> 00:39:19,790
prove everything works I'll have to

00:39:17,600 --> 00:39:22,220
prove NAT and int work just to prove my

00:39:19,790 --> 00:39:23,570
to end works I just assume all that

00:39:22,220 --> 00:39:25,880
other stuff works I take that as an

00:39:23,570 --> 00:39:28,160
axiom and then really what my proof says

00:39:25,880 --> 00:39:30,200
is so long as NAT an int fulfill their

00:39:28,160 --> 00:39:31,880
contract then two went you know I've

00:39:30,200 --> 00:39:33,950
proven that it fulfills its contract so

00:39:31,880 --> 00:39:35,870
that's I called a unit proof so anyway

00:39:33,950 --> 00:39:37,850
that is my talk so before I go to

00:39:35,870 --> 00:39:39,530
questions I just want to mention that we

00:39:37,850 --> 00:39:41,510
do we are hiring at our team that we do

00:39:39,530 --> 00:39:43,940
consulting we were available if you need

00:39:41,510 --> 00:39:47,030
help and then I'm also a member of the

00:39:43,940 --> 00:39:48,920
advisory board of the Scala Center so I

00:39:47,030 --> 00:39:51,170
actually represent the community

00:39:48,920 --> 00:39:52,460
so if you have any concern please come

00:39:51,170 --> 00:39:55,850
up to me at the conference I look like

00:39:52,460 --> 00:39:57,980
this and I also do these brown bags so

00:39:55,850 --> 00:40:00,020
if your company would like me to come in

00:39:57,980 --> 00:40:02,150
like over liming probably over video or

00:40:00,020 --> 00:40:05,240
whatever it's kind of like a psychiatry

00:40:02,150 --> 00:40:07,430
session you get on the couch and I show

00:40:05,240 --> 00:40:09,620
you ink blots and I say if this you know

00:40:07,430 --> 00:40:11,540
if this is Scala what do you see and you

00:40:09,620 --> 00:40:12,860
tell me like what your concerns are what

00:40:11,540 --> 00:40:14,150
you like what you don't like and I can

00:40:12,860 --> 00:40:17,180
kind of bring that back to the Scala

00:40:14,150 --> 00:40:19,070
Center so anyway are there any questions

00:40:17,180 --> 00:40:27,040
they have a like a few minutes for

00:40:19,070 --> 00:40:29,030
questions yeah he's gonna bring around

00:40:27,040 --> 00:40:30,950
the microphone if somebody has a

00:40:29,030 --> 00:40:31,400
question thank you for your talk you're

00:40:30,950 --> 00:40:36,640
welcome

00:40:31,400 --> 00:40:36,640
where are you oh there you are hi I did

00:40:37,660 --> 00:40:44,780
uncomfortable because it's not really

00:40:40,940 --> 00:40:51,070
full numbers because computers are

00:40:44,780 --> 00:40:54,770
limited how would you manage that oh

00:40:51,070 --> 00:40:59,000
well I think what you're saying is that

00:40:54,770 --> 00:41:03,500
if I do this proof here for example this

00:40:59,000 --> 00:41:06,830
guy it's not you can never go back to

00:41:03,500 --> 00:41:11,000
this nice to go back to this guy if I

00:41:06,830 --> 00:41:12,560
prove this it actually I think it's okay

00:41:11,000 --> 00:41:13,850
because what you're saying is computers

00:41:12,560 --> 00:41:16,960
actually can't get up to a Quinn

00:41:13,850 --> 00:41:16,960
trillion because we won't fit in memory

00:41:16,990 --> 00:41:23,960
but all the ones that can get to are I

00:41:21,310 --> 00:41:26,060
would I would I've proven that is

00:41:23,960 --> 00:41:28,430
correct all the ones the computer could

00:41:26,060 --> 00:41:32,030
actually feel it fit in memory and

00:41:28,430 --> 00:41:36,590
that's better than testing is my point

00:41:32,030 --> 00:41:38,990
so I think you know that it's like proof

00:41:36,590 --> 00:41:40,220
in the mathematical sense isn't proof or

00:41:38,990 --> 00:41:43,490
like especially a unit proof it's not

00:41:40,220 --> 00:41:45,560
proof absolute proof beyond all reason

00:41:43,490 --> 00:41:52,190
absolute proof beyond any doubt it isn't

00:41:45,560 --> 00:41:53,570
but it's so useful it's like if you know

00:41:52,190 --> 00:41:55,790
it's kind of like an axiom if everything

00:41:53,570 --> 00:41:57,410
fits in memory and you know natural

00:41:55,790 --> 00:41:58,730
number and ant fulfill their contract

00:41:57,410 --> 00:42:00,650
then my to int method and this guy

00:41:58,730 --> 00:42:02,030
fulfills its contract that's all I'm

00:42:00,650 --> 00:42:05,140
proven it's like a unit proof

00:42:02,030 --> 00:42:06,350
and that's good enough I think that's

00:42:05,140 --> 00:42:08,450
yeah

00:42:06,350 --> 00:42:10,160
does anybody have another question so

00:42:08,450 --> 00:42:12,580
people are spread out way back in the

00:42:10,160 --> 00:42:12,580
back yes

00:42:22,110 --> 00:42:27,830
hi thank you for thank you for your talk

00:42:25,050 --> 00:42:30,960
it was great thank you

00:42:27,830 --> 00:42:33,600
most of the surgeons you did was using

00:42:30,960 --> 00:42:35,430
proofs by induction yeah and in maths

00:42:33,600 --> 00:42:38,070
there are a different type of proofs

00:42:35,430 --> 00:42:40,890
including proof of God by contradiction

00:42:38,070 --> 00:42:44,550
or yeah otherwise have you considered

00:42:40,890 --> 00:42:46,320
any of that yeah I mean if you look up

00:42:44,550 --> 00:42:49,470
associate proofs for associative it's a

00:42:46,320 --> 00:42:52,500
bunch of different ways to do it so what

00:42:49,470 --> 00:42:54,090
I wanted to do was you well basically

00:42:52,500 --> 00:42:55,080
want to do programming right so I want

00:42:54,090 --> 00:42:57,030
to use one of these dependently type

00:42:55,080 --> 00:42:58,800
language you can think of like Agda as a

00:42:57,030 --> 00:42:59,880
proof framework for Scala

00:42:58,800 --> 00:43:02,760
that you have to it's not very

00:42:59,880 --> 00:43:05,550
integrated and that's one of the things

00:43:02,760 --> 00:43:10,350
Ogden does is that kind of recursive

00:43:05,550 --> 00:43:13,290
recursion but yeah III don't this is as

00:43:10,350 --> 00:43:17,730
far as I got is is just sort of kind of

00:43:13,290 --> 00:43:20,760
figuring out that the this is sort of

00:43:17,730 --> 00:43:22,320
like I think that just makes sense I

00:43:20,760 --> 00:43:24,750
just think it'd be nice to have a more

00:43:22,320 --> 00:43:29,760
formal specification of contracts and it

00:43:24,750 --> 00:43:31,920
ended up looking like logic which if

00:43:29,760 --> 00:43:33,480
perfectly match you know property based

00:43:31,920 --> 00:43:36,000
tests looked exactly like that but sort

00:43:33,480 --> 00:43:38,400
of proof so that that's you know how to

00:43:36,000 --> 00:43:41,010
actually do proofs is it I don't know I

00:43:38,400 --> 00:43:43,020
haven't done too much with that and I

00:43:41,010 --> 00:43:45,300
just think what I would have observed is

00:43:43,020 --> 00:43:46,290
it's really hard to do proofs I think

00:43:45,300 --> 00:43:48,180
it's kind of fun it's like solving

00:43:46,290 --> 00:43:49,860
puzzles but it's not like you know you

00:43:48,180 --> 00:43:55,850
can write a test but you can't

00:43:49,860 --> 00:43:55,850
necessarily do a proof so anybody else

00:43:58,340 --> 00:44:05,020
once I may not be seeing a hand okay

00:44:02,010 --> 00:44:10,289
cool well thank you

00:44:05,020 --> 00:44:10,289

YouTube URL: https://www.youtube.com/watch?v=oK1P7cPu0i0


