Title: Immutable Sequential Maps – Keeping order while hashed - Odd Möller
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/immutable-sequential-maps--keeping-order-while-hashed
Captions: 
	00:00:00,030 --> 00:00:08,010
yes hi everybody is still here this late

00:00:04,859 --> 00:00:11,880
in the the day I'm gonna speak about a

00:00:08,010 --> 00:00:16,980
new kind of map a new type of collection

00:00:11,880 --> 00:00:20,010
in 213 it's an in it's sequential Maps

00:00:16,980 --> 00:00:21,900
so there but I'm gonna focus on the

00:00:20,010 --> 00:00:26,880
immutable ones but there are also

00:00:21,900 --> 00:00:28,859
mutable one mutable implementation and

00:00:26,880 --> 00:00:30,570
it's yeah the the challenge with those

00:00:28,859 --> 00:00:34,739
kinds of maps is that you want to keep

00:00:30,570 --> 00:00:36,930
the order while still using a basically

00:00:34,739 --> 00:00:39,629
using your hash map which is not ordered

00:00:36,930 --> 00:00:43,649
so that's the the what you are trying to

00:00:39,629 --> 00:00:46,260
solve yeah so we're gonna look a bit

00:00:43,649 --> 00:00:49,140
about first an introduction then we go

00:00:46,260 --> 00:00:50,820
through through the challenges going to

00:00:49,140 --> 00:00:55,500
look at some of the implementations both

00:00:50,820 --> 00:00:58,350
the ones in the 213 but also a set of

00:00:55,500 --> 00:01:00,660
other possible implementations because

00:00:58,350 --> 00:01:02,730
there are quite a few way of ways of

00:01:00,660 --> 00:01:05,010
implementing especially the immutable

00:01:02,730 --> 00:01:09,049
ones we're gonna look a little bit about

00:01:05,010 --> 00:01:11,010
how you can benchmark these kinds of

00:01:09,049 --> 00:01:13,799
implementations against each other and

00:01:11,010 --> 00:01:17,189
also which tools to use or which I used

00:01:13,799 --> 00:01:18,869
anyway and have a look at the results

00:01:17,189 --> 00:01:20,970
see what what came out of the

00:01:18,869 --> 00:01:23,850
benchmarking and also a little bit about

00:01:20,970 --> 00:01:31,259
how how it is to start contributing to

00:01:23,850 --> 00:01:34,710
scholars especially yep so my name is Ed

00:01:31,259 --> 00:01:38,340
Miller I'm from Sweden Stockholm I've

00:01:34,710 --> 00:01:40,590
been using Scala since I don't remember

00:01:38,340 --> 00:01:43,380
really this year but it was version two

00:01:40,590 --> 00:01:46,860
seven five I think so it's over ten

00:01:43,380 --> 00:01:49,979
years now yeah and I've been coding

00:01:46,860 --> 00:01:52,500
since since forever almost so but now

00:01:49,979 --> 00:01:58,259
the last ten years almost exclusively in

00:01:52,500 --> 00:02:00,630
Scala so what is a sequential map yeah

00:01:58,259 --> 00:02:02,850
it's a new type it's added in 213 and

00:02:00,630 --> 00:02:06,210
it's an interface or a trait called seek

00:02:02,850 --> 00:02:09,959
map and it's but exists both as a

00:02:06,210 --> 00:02:12,470
general type and also has a like one

00:02:09,959 --> 00:02:14,060
mutable version and one immutable

00:02:12,470 --> 00:02:16,970
as it's common in the in the collections

00:02:14,060 --> 00:02:19,700
library in general it's like a regular

00:02:16,970 --> 00:02:24,620
map but the entries are ordered by

00:02:19,700 --> 00:02:28,580
insertion and not sorted so it's

00:02:24,620 --> 00:02:31,010
basically the the way the the yeah the

00:02:28,580 --> 00:02:35,030
series of events that you put stuff in

00:02:31,010 --> 00:02:37,820
they they remain in the same order so no

00:02:35,030 --> 00:02:39,860
external ordering function is needed so

00:02:37,820 --> 00:02:42,110
you don't have to have an ordering the

00:02:39,860 --> 00:02:45,740
you order is is based on the operations

00:02:42,110 --> 00:02:49,190
you perform and there are both mutable

00:02:45,740 --> 00:02:52,730
and immutable variants even though seek

00:02:49,190 --> 00:02:55,760
map is a new trait there have been a

00:02:52,730 --> 00:02:59,170
couple of implementations around for for

00:02:55,760 --> 00:03:02,090
quite a while in in Scala as we'll see

00:02:59,170 --> 00:03:02,390
so what are you what can you use them

00:03:02,090 --> 00:03:04,910
for

00:03:02,390 --> 00:03:08,630
well anytime you need the entries of a

00:03:04,910 --> 00:03:10,850
map to have a stable ordering so you

00:03:08,630 --> 00:03:13,280
want them to remain in the order you you

00:03:10,850 --> 00:03:15,440
insert them regardless of like if you

00:03:13,280 --> 00:03:17,720
restart your prod program or whatever

00:03:15,440 --> 00:03:21,739
you still want to have a like a defined

00:03:17,720 --> 00:03:24,020
order with like a hash map it can be

00:03:21,739 --> 00:03:27,230
reordered on each restore so it's very

00:03:24,020 --> 00:03:29,630
unstable but this one is stable and you

00:03:27,230 --> 00:03:31,520
could represent hierarchical data such

00:03:29,630 --> 00:03:33,400
as JSON even though Jason isn't ordered

00:03:31,520 --> 00:03:36,290
but it's still nice to have it ordered

00:03:33,400 --> 00:03:39,410
or XML or other stuff and you can also

00:03:36,290 --> 00:03:41,870
use them for keeping like you want the

00:03:39,410 --> 00:03:44,050
map that's maybe a thousand items or

00:03:41,870 --> 00:03:49,430
entries long and you want to remove the

00:03:44,050 --> 00:03:51,470
oldest one here you have all the time so

00:03:49,430 --> 00:03:54,140
today we'll look at some different ways

00:03:51,470 --> 00:03:56,989
to implement the seek map we look at

00:03:54,140 --> 00:03:59,030
their internal structure a little bit we

00:03:56,989 --> 00:04:01,040
look at each yeah they've done smoking

00:03:59,030 --> 00:04:04,840
results for some of the more important

00:04:01,040 --> 00:04:07,250
operations yeah we'll see what how they

00:04:04,840 --> 00:04:09,440
differ performance wise for those

00:04:07,250 --> 00:04:13,040
operations and also a little bit about

00:04:09,440 --> 00:04:14,750
the memory usage and hopefully you'll

00:04:13,040 --> 00:04:16,459
get an understanding of the trade-offs

00:04:14,750 --> 00:04:19,280
between the difference different

00:04:16,459 --> 00:04:23,360
implementations so so you can say when

00:04:19,280 --> 00:04:26,180
to use which and of course there's

00:04:23,360 --> 00:04:26,840
challenges with with the especially the

00:04:26,180 --> 00:04:30,590
immutable

00:04:26,840 --> 00:04:34,580
and the basic thing with the seek map is

00:04:30,590 --> 00:04:37,610
that it's it fulfilled two separate

00:04:34,580 --> 00:04:39,800
roles it's a mapping when used through

00:04:37,610 --> 00:04:42,470
key based operations so such lookup and

00:04:39,800 --> 00:04:45,320
other stuff and it's also an ordering so

00:04:42,470 --> 00:04:47,590
there is an index based mechanist

00:04:45,320 --> 00:04:50,120
to look up or iterate through something

00:04:47,590 --> 00:04:53,780
and that's yeah so then you need to

00:04:50,120 --> 00:04:55,310
fulfill both those roles and an optimal

00:04:53,780 --> 00:04:58,250
implementation would have a single

00:04:55,310 --> 00:05:00,290
representation for both those of course

00:04:58,250 --> 00:05:05,120
and while still having the best possible

00:05:00,290 --> 00:05:07,100
or at least so far and complexity for

00:05:05,120 --> 00:05:10,400
both those cases but that's really hard

00:05:07,100 --> 00:05:13,729
to get unless you are willing to trade

00:05:10,400 --> 00:05:15,200
lots of memory and like double store

00:05:13,729 --> 00:05:17,900
everything then might you might get

00:05:15,200 --> 00:05:21,050
close to that to the performance you

00:05:17,900 --> 00:05:23,090
want and there's also different

00:05:21,050 --> 00:05:26,919
difference here between the mutable one

00:05:23,090 --> 00:05:26,919
and the immutable one as we'll see

00:05:27,280 --> 00:05:33,410
so the most essential operations for a

00:05:31,070 --> 00:05:35,870
for a seek map is yeah you have to add

00:05:33,410 --> 00:05:39,590
be able to add and crystal and they're

00:05:35,870 --> 00:05:42,349
always appended so when you add a new

00:05:39,590 --> 00:05:44,810
key value binding if the key isn't

00:05:42,349 --> 00:05:48,800
already present in the map it's always a

00:05:44,810 --> 00:05:52,130
planted at the end and when you remove

00:05:48,800 --> 00:05:53,810
elements you can remove of course the

00:05:52,130 --> 00:05:57,260
first one and so on but you can also

00:05:53,810 --> 00:05:59,810
remove by key that could be potentially

00:05:57,260 --> 00:06:02,240
in the middle over middle of the map

00:05:59,810 --> 00:06:06,190
where it could be by index like your

00:06:02,240 --> 00:06:08,960
index into it's like a seek and

00:06:06,190 --> 00:06:12,160
retrieval can be done by key of course

00:06:08,960 --> 00:06:16,010
since it's a map but also by by indexing

00:06:12,160 --> 00:06:22,070
and all iteration or alt reversals need

00:06:16,010 --> 00:06:25,490
to be done in order so we'll have a look

00:06:22,070 --> 00:06:27,220
at the different types of or the

00:06:25,490 --> 00:06:30,169
implementations

00:06:27,220 --> 00:06:32,090
yeah and therefore we have to say that

00:06:30,169 --> 00:06:34,310
there's there's lots of prior our chair

00:06:32,090 --> 00:06:38,330
we have some install already

00:06:34,310 --> 00:06:40,129
and Pascal of course has implementations

00:06:38,330 --> 00:06:41,739
as well as Java

00:06:40,129 --> 00:06:44,089
the Coplin they all have different

00:06:41,739 --> 00:06:46,339
implementations and all the ones I'm

00:06:44,089 --> 00:06:49,009
going through today will see that yes

00:06:46,339 --> 00:06:50,689
some of them they don't all all use the

00:06:49,009 --> 00:06:52,099
same because it's really hard to know

00:06:50,689 --> 00:06:56,869
that it's different trade off so

00:06:52,099 --> 00:06:59,779
different implementations we start with

00:06:56,869 --> 00:07:03,110
the mutable one and yeah that's

00:06:59,779 --> 00:07:06,199
basically just one link - map it's it's

00:07:03,110 --> 00:07:08,749
a really good op really good it has good

00:07:06,199 --> 00:07:11,209
performance doesn't take that much more

00:07:08,749 --> 00:07:15,129
memory than a regular hash map and it's

00:07:11,209 --> 00:07:18,909
it's been around since in Java since 1.4

00:07:15,129 --> 00:07:23,059
and in Scala since 1 dot Oh

00:07:18,909 --> 00:07:25,759
I had to check that but yeah and the

00:07:23,059 --> 00:07:27,050
entries of a link - map form a doubly

00:07:25,759 --> 00:07:30,139
linked list

00:07:27,050 --> 00:07:31,579
this is mutable you can you can you can

00:07:30,139 --> 00:07:33,229
have a doubly linked list that's really

00:07:31,579 --> 00:07:35,300
it it's impossible for a for an

00:07:33,229 --> 00:07:38,539
immutable one but for a mutable one it's

00:07:35,300 --> 00:07:41,179
fine and lookup is done the same way as

00:07:38,539 --> 00:07:45,079
for an hash map but the the entries in

00:07:41,179 --> 00:07:47,990
the hash map point to each other and

00:07:45,079 --> 00:07:49,699
traverser it becomes very performant you

00:07:47,990 --> 00:07:52,219
just follow the next reference to the

00:07:49,699 --> 00:07:54,679
next entry and you so you don't even

00:07:52,219 --> 00:07:57,379
have to you can just fetch the first one

00:07:54,679 --> 00:08:00,110
and then walk the references to the next

00:07:57,379 --> 00:08:02,929
all the way till the end if you want to

00:08:00,110 --> 00:08:06,139
traverse it remover so simple yeah you

00:08:02,929 --> 00:08:08,629
update the previous/next entries those

00:08:06,139 --> 00:08:12,050
subtle so they point to each other and

00:08:08,629 --> 00:08:14,599
you skip the one in the middle and the

00:08:12,050 --> 00:08:16,759
java implementation supports both

00:08:14,599 --> 00:08:20,240
modification insertion of course but

00:08:16,759 --> 00:08:22,669
also modification and access order being

00:08:20,240 --> 00:08:25,519
immutable it can it can update its

00:08:22,669 --> 00:08:28,819
internal State on access and then you

00:08:25,519 --> 00:08:33,019
can use it like a least recently used

00:08:28,819 --> 00:08:37,479
map or a cache or something which is

00:08:33,019 --> 00:08:39,159
commonly done the immutable

00:08:37,479 --> 00:08:41,930
implementation or the

00:08:39,159 --> 00:08:44,149
the set of immutable implementations

00:08:41,930 --> 00:08:46,959
because there are several and there's no

00:08:44,149 --> 00:08:49,850
known perfect strategy so it's really

00:08:46,959 --> 00:08:51,680
you have to make a trade of different

00:08:49,850 --> 00:08:53,060
trade-offs gives different performance

00:08:51,680 --> 00:08:57,850
or memory

00:08:53,060 --> 00:08:59,769
and as I said there are very many or

00:08:57,850 --> 00:09:02,330
considerable amount of different

00:08:59,769 --> 00:09:06,920
implementations that exist in these

00:09:02,330 --> 00:09:08,680
different languages there's one strategy

00:09:06,920 --> 00:09:13,070
for implementing these kind of

00:09:08,680 --> 00:09:15,560
sequential maps that are you can see it

00:09:13,070 --> 00:09:18,260
in several of the implementations and it

00:09:15,560 --> 00:09:19,220
that is to use a hash map for the

00:09:18,260 --> 00:09:22,760
mapping side

00:09:19,220 --> 00:09:25,040
you keep key to ya value it maybe with

00:09:22,760 --> 00:09:29,360
some metadata and then you combine that

00:09:25,040 --> 00:09:32,209
with an ordering of the keys that means

00:09:29,360 --> 00:09:35,329
that you will have you will have some

00:09:32,209 --> 00:09:37,040
kind of a certain amount of double

00:09:35,329 --> 00:09:40,040
storage because the keys will be

00:09:37,040 --> 00:09:42,769
referenced from two distinct data

00:09:40,040 --> 00:09:45,500
structures one used when you when you

00:09:42,769 --> 00:09:49,610
traverse and one used when you just want

00:09:45,500 --> 00:09:51,829
to see them get the values and for

00:09:49,610 --> 00:09:54,140
immutable data structures in general

00:09:51,829 --> 00:09:56,990
trees are really nice because you can

00:09:54,140 --> 00:09:59,120
you can make a new like if you add

00:09:56,990 --> 00:10:01,850
something you can use almost the entire

00:09:59,120 --> 00:10:04,550
tree or perhaps the entire tree way for

00:10:01,850 --> 00:10:07,760
the new ones so it's not you can reuse a

00:10:04,550 --> 00:10:11,240
lot of the the nodes in the tree and

00:10:07,760 --> 00:10:14,570
this is you can be see them as a one

00:10:11,240 --> 00:10:18,500
branch tree so lists are also a good way

00:10:14,570 --> 00:10:21,440
of implementing these so a couple of

00:10:18,500 --> 00:10:24,529
definitions before we get started I'm

00:10:21,440 --> 00:10:27,410
going to use these as names in the in

00:10:24,529 --> 00:10:30,440
the following images so when you see

00:10:27,410 --> 00:10:34,520
ABCD it's basically that seek map and

00:10:30,440 --> 00:10:38,690
when you see ABCDE yeah I have added

00:10:34,520 --> 00:10:41,930
like an e to e binding on that one an

00:10:38,690 --> 00:10:47,000
abd then you remove the C binding or key

00:10:41,930 --> 00:10:49,610
from the ABCD yeah you get it soon we're

00:10:47,000 --> 00:10:51,380
stopped by list map this is actually the

00:10:49,610 --> 00:10:54,380
oldest one in in Scala since it's been

00:10:51,380 --> 00:10:56,120
since color one dodo and the entries of

00:10:54,380 --> 00:11:00,440
this transform a singly linked list so

00:10:56,120 --> 00:11:04,970
it's basically a list immutable list you

00:11:00,440 --> 00:11:05,970
add the entries at the head so de la the

00:11:04,970 --> 00:11:10,139
most recently

00:11:05,970 --> 00:11:13,439
added is at the head of the list this

00:11:10,139 --> 00:11:16,589
this makes adding really efficient you

00:11:13,439 --> 00:11:19,170
just prepared something to a list but it

00:11:16,589 --> 00:11:22,079
requires that you Roo reverse reverse

00:11:19,170 --> 00:11:25,670
the list before or before you can do

00:11:22,079 --> 00:11:28,829
anything else anything index based so so

00:11:25,670 --> 00:11:31,589
anything all the operations you doing on

00:11:28,829 --> 00:11:35,670
a list map that can't be described that

00:11:31,589 --> 00:11:37,410
as a in in it last decomposition they're

00:11:35,670 --> 00:11:39,750
really slow but in it last disco the

00:11:37,410 --> 00:11:42,930
composition is fast so if you can make

00:11:39,750 --> 00:11:45,149
your operation express it in terms of

00:11:42,930 --> 00:11:49,439
the concept the composition of in it

00:11:45,149 --> 00:11:54,029
last and it's going to be really fast so

00:11:49,439 --> 00:11:56,910
this is basically a list map so you use

00:11:54,029 --> 00:11:59,040
you in this case you've added a then you

00:11:56,910 --> 00:12:03,389
add B then you add C and then you are D

00:11:59,040 --> 00:12:05,490
or the mapping DT so that that's it's

00:12:03,389 --> 00:12:09,230
really simple it's it's a linked list

00:12:05,490 --> 00:12:13,920
with both the key and the value

00:12:09,230 --> 00:12:18,089
yeah and by the way this nice pictures I

00:12:13,920 --> 00:12:23,129
I don't use in my presentation I can

00:12:18,089 --> 00:12:25,649
recommend that this ref tree it's really

00:12:23,129 --> 00:12:28,319
nice way of being able to display your

00:12:25,649 --> 00:12:33,029
data structures you wanna see how they

00:12:28,319 --> 00:12:34,920
how they look and behave so if you look

00:12:33,029 --> 00:12:37,829
at addition one of the important

00:12:34,920 --> 00:12:42,660
operations for for for a list map we can

00:12:37,829 --> 00:12:49,740
see that when we yeah we start with ABCD

00:12:42,660 --> 00:12:52,620
as usual here and then we add e the e

00:12:49,740 --> 00:12:54,540
mapping we see that you can reuse the

00:12:52,620 --> 00:12:58,100
whole list and just prepared something

00:12:54,540 --> 00:13:01,170
to the list so that's really really nice

00:12:58,100 --> 00:13:04,319
but when we have the removal case here

00:13:01,170 --> 00:13:07,019
then we have to do a little bit more so

00:13:04,319 --> 00:13:09,750
we remove and then we in this case we

00:13:07,019 --> 00:13:12,089
remove the C element or binding so we

00:13:09,750 --> 00:13:14,550
the C here it's going to most disappear

00:13:12,089 --> 00:13:16,800
so then we must restructure the list all

00:13:14,550 --> 00:13:19,379
the way this part can be shared but the

00:13:16,800 --> 00:13:26,369
restaurants we ABCD here's and

00:13:19,379 --> 00:13:29,189
pointer to this part yeah so that's

00:13:26,369 --> 00:13:31,919
listen this is list maps it's quite good

00:13:29,189 --> 00:13:34,619
in those cases unless you want to remove

00:13:31,919 --> 00:13:35,999
something close to the to the start of

00:13:34,619 --> 00:13:39,599
the list and as you have gonna have to

00:13:35,999 --> 00:13:42,329
reconstruct the list all the way up yeah

00:13:39,599 --> 00:13:46,139
and this is one of that that's new in

00:13:42,329 --> 00:13:48,929
213 the vector map it uses a hash map

00:13:46,139 --> 00:13:51,839
for the mapping and it uses a vector for

00:13:48,929 --> 00:13:56,069
the ordering so if the hash map contains

00:13:51,839 --> 00:13:58,729
not only the the key and value but also

00:13:56,069 --> 00:14:01,199
the index in the vector for each key

00:13:58,729 --> 00:14:04,319
this means that when you remove

00:14:01,199 --> 00:14:07,499
something by key you have to find which

00:14:04,319 --> 00:14:12,829
index is this located at so you can

00:14:07,499 --> 00:14:15,779
remove it from the ordering as well and

00:14:12,829 --> 00:14:17,970
this is also the default implementation

00:14:15,779 --> 00:14:23,009
of a seek map in or immutable seek map

00:14:17,970 --> 00:14:27,529
in 213 it looks like this this is the is

00:14:23,009 --> 00:14:30,779
a simplified picture did this disappear

00:14:27,529 --> 00:14:36,419
so I'm gonna use this form to describe

00:14:30,779 --> 00:14:39,359
the hash map this is not the correct in

00:14:36,419 --> 00:14:41,489
reality this is quite a large tree like

00:14:39,359 --> 00:14:44,129
structure for the immutable hash map but

00:14:41,489 --> 00:14:47,189
I'm gonna use this because that for many

00:14:44,129 --> 00:14:49,379
of the of these implementations they all

00:14:47,189 --> 00:14:51,989
use this kind of to make the picture

00:14:49,379 --> 00:14:53,519
simpler as I'm concentrating on the

00:14:51,989 --> 00:14:56,970
ordering part because that's what's

00:14:53,519 --> 00:14:58,949
gonna differ and here you see the vector

00:14:56,970 --> 00:15:01,350
map it has the mapping and the ordering

00:14:58,949 --> 00:15:04,289
and in the ordering you have the yeah

00:15:01,350 --> 00:15:08,009
the usual vector and I've abbreviated

00:15:04,289 --> 00:15:11,069
here so in reality this array is 32

00:15:08,009 --> 00:15:15,119
elements long so when you have added

00:15:11,069 --> 00:15:18,089
ABCD you get a nice ABCD here and the

00:15:15,119 --> 00:15:23,479
rest is or no or nulls in this long

00:15:18,089 --> 00:15:30,329
array so when you add something to

00:15:23,479 --> 00:15:32,680
vector map you start with ABCD there and

00:15:30,329 --> 00:15:37,930
we we add the e mapping

00:15:32,680 --> 00:15:39,850
so we use or this one will be this will

00:15:37,930 --> 00:15:42,610
be an updated hash map but it will

00:15:39,850 --> 00:15:46,089
change or add a note here but I won't

00:15:42,610 --> 00:15:47,860
show that as I said but the vector it

00:15:46,089 --> 00:15:50,350
needs to build a new vector because it

00:15:47,860 --> 00:15:53,350
can't share this part with the earlier

00:15:50,350 --> 00:15:55,660
one since it's still not there if you

00:15:53,350 --> 00:15:58,120
have more than 32 then you could share

00:15:55,660 --> 00:15:59,709
the first part of the vector but in this

00:15:58,120 --> 00:16:06,970
case you need to build a new vector here

00:15:59,709 --> 00:16:10,480
and for removal this is interesting case

00:16:06,970 --> 00:16:13,000
for vector map we have the vector here

00:16:10,480 --> 00:16:17,910
and remember when we remove stuff the

00:16:13,000 --> 00:16:20,980
new a new vector it will won't it won't

00:16:17,910 --> 00:16:22,570
remove the C from here you see in the

00:16:20,980 --> 00:16:25,110
third position we have a see you won't

00:16:22,570 --> 00:16:30,190
remove me remove it instead it will

00:16:25,110 --> 00:16:31,839
insert a film tombstone here that says

00:16:30,190 --> 00:16:34,420
that you have to skip this element skip

00:16:31,839 --> 00:16:36,880
one element ahead if your indexes is

00:16:34,420 --> 00:16:39,580
three and the reason for that is that if

00:16:36,880 --> 00:16:41,410
you changed all the indexes then we then

00:16:39,580 --> 00:16:44,830
this part wouldn't be able to share

00:16:41,410 --> 00:16:46,930
anything like the then we would have to

00:16:44,830 --> 00:16:50,350
have a new we would have to map the

00:16:46,930 --> 00:16:54,250
entire map hashmap because all the

00:16:50,350 --> 00:16:58,750
indexes would change so to keep this

00:16:54,250 --> 00:17:02,770
part as stable as possible we instead

00:16:58,750 --> 00:17:12,429
replace the the DC element with the tone

00:17:02,770 --> 00:17:17,170
terms down here yes so this is when this

00:17:12,429 --> 00:17:20,400
project or during the 213 work and the

00:17:17,170 --> 00:17:22,600
collection Stroman work before that I

00:17:20,400 --> 00:17:24,880
initially created this one as a

00:17:22,600 --> 00:17:26,770
reference implementation because if you

00:17:24,880 --> 00:17:28,540
think about this problem like from the

00:17:26,770 --> 00:17:31,770
start you might imagine that you have a

00:17:28,540 --> 00:17:35,230
hash map you want to have this key to

00:17:31,770 --> 00:17:37,450
index and value a mapping so why don't

00:17:35,230 --> 00:17:39,309
store the keys in in a tree map that's

00:17:37,450 --> 00:17:41,800
going to be sorted and you use an

00:17:39,309 --> 00:17:45,190
ordinal that you increase on each insert

00:17:41,800 --> 00:17:46,450
then then you have one word ring from

00:17:45,190 --> 00:17:49,510
the ordinals to the

00:17:46,450 --> 00:17:52,149
you know the hashmap as usual so I

00:17:49,510 --> 00:17:53,889
implemented that and thought about

00:17:52,149 --> 00:17:58,690
having it like a reference point for

00:17:53,889 --> 00:18:03,399
benchmarking and so on and it basically

00:17:58,690 --> 00:18:14,649
looks like this it's a the same mapping

00:18:03,399 --> 00:18:18,460
here sorry so this is the same same hash

00:18:14,649 --> 00:18:19,720
map and this is the the tree map you

00:18:18,460 --> 00:18:23,529
know with the it's a red black tree

00:18:19,720 --> 00:18:25,600
underneath the immutable tree map and

00:18:23,529 --> 00:18:27,730
here you do you have an ordinal in this

00:18:25,600 --> 00:18:30,250
case it's been increased to four so you

00:18:27,730 --> 00:18:31,299
have that node with one less the B and

00:18:30,250 --> 00:18:35,610
ya so on

00:18:31,299 --> 00:18:39,519
zero we say and then 1 + b + 2 c + 3 d

00:18:35,610 --> 00:18:43,240
so that's the d layout and when you add

00:18:39,519 --> 00:18:46,269
something to this one you get a new so

00:18:43,240 --> 00:18:48,549
it it reuses the some of the nodes you

00:18:46,269 --> 00:18:51,669
see the zero how it doesn't doesn't need

00:18:48,549 --> 00:18:54,510
to create a new one the rest area but it

00:18:51,669 --> 00:19:01,210
can reuse a certain amount of the the

00:18:54,510 --> 00:19:02,110
the nodes from the the existing ordering

00:19:01,210 --> 00:19:05,559
so that's nice

00:19:02,110 --> 00:19:09,039
and when you remove stuff from this kind

00:19:05,559 --> 00:19:12,100
of collection it's the same same way so

00:19:09,039 --> 00:19:14,380
you can reuse certain nodes here from

00:19:12,100 --> 00:19:17,139
the new green one it can still point to

00:19:14,380 --> 00:19:20,260
some of the nodes so you have to create

00:19:17,139 --> 00:19:25,679
only those two and the no representation

00:19:20,260 --> 00:19:29,230
up here so it's it's quite good there

00:19:25,679 --> 00:19:31,929
but the thing is that the tree map isn't

00:19:29,230 --> 00:19:34,240
optimal for this case like if you want

00:19:31,929 --> 00:19:38,169
to have a if you want to have a mapping

00:19:34,240 --> 00:19:40,240
from intz to keys there is a better

00:19:38,169 --> 00:19:46,210
collection in the already in this

00:19:40,240 --> 00:19:49,990
scholar and it's the intimate so this

00:19:46,210 --> 00:19:54,190
one is it only it you only need to send

00:19:49,990 --> 00:19:56,320
in the the K the key type because it's

00:19:54,190 --> 00:19:59,770
the int is already under student as the

00:19:56,320 --> 00:20:04,990
the cake yeah so it goes from Institute

00:19:59,770 --> 00:20:08,380
two keys or in this case and it performs

00:20:04,990 --> 00:20:11,050
quite good for all operations but it

00:20:08,380 --> 00:20:13,540
opieop eyes 50% more memory than vector

00:20:11,050 --> 00:20:15,580
map so so in this case we trade memory

00:20:13,540 --> 00:20:18,070
for a little better performance

00:20:15,580 --> 00:20:20,190
especially in some operations as we'll

00:20:18,070 --> 00:20:24,220
see

00:20:20,190 --> 00:20:32,260
so this tree seek map it looks like this

00:20:24,220 --> 00:20:35,860
in memory this is basically a a bit try

00:20:32,260 --> 00:20:39,040
so it has a prefix this is these are all

00:20:35,860 --> 00:20:42,460
done on the bit bit values and a mask

00:20:39,040 --> 00:20:44,440
and then it says there like one one

00:20:42,460 --> 00:20:46,780
branch to the left and one to the to the

00:20:44,440 --> 00:20:50,350
right and the can either be tips or they

00:20:46,780 --> 00:20:52,150
can be composited nodes called bins so

00:20:50,350 --> 00:20:55,330
you have the tips with the values and

00:20:52,150 --> 00:20:58,000
you construct it like this and it's

00:20:55,330 --> 00:21:00,850
while it has quite a few levels this one

00:20:58,000 --> 00:21:04,180
which is why it takes more memory it's

00:21:00,850 --> 00:21:07,360
also all the branching can be calculated

00:21:04,180 --> 00:21:10,450
by simple bit operations on int so

00:21:07,360 --> 00:21:12,760
they're very fast so that's that's one

00:21:10,450 --> 00:21:16,930
of the good things and when you add

00:21:12,760 --> 00:21:20,260
stuff to this looks like this so this

00:21:16,930 --> 00:21:22,480
one also uses quite a lot of the old old

00:21:20,260 --> 00:21:24,640
tree here two nodes can be reused in

00:21:22,480 --> 00:21:26,950
this simple case while adding a new one

00:21:24,640 --> 00:21:30,250
there and those two in intermediate

00:21:26,950 --> 00:21:33,760
nodes and when you want to when you

00:21:30,250 --> 00:21:36,640
remove stuff it's the same the the new

00:21:33,760 --> 00:21:43,740
one can keep using a lot of the the

00:21:36,640 --> 00:21:47,790
existing tree here and the last

00:21:43,740 --> 00:21:51,970
implementation we'll talk about is the

00:21:47,790 --> 00:21:54,100
queue seek map this isn't in Scala at

00:21:51,970 --> 00:21:57,010
all it doesn't exist in Scala standard

00:21:54,100 --> 00:21:59,890
library it's just made for reference or

00:21:57,010 --> 00:22:03,490
for comparison and this one uses a hash

00:21:59,890 --> 00:22:06,670
map K from k2 keys to values for the

00:22:03,490 --> 00:22:10,260
mapping and also a queue of the K keys

00:22:06,670 --> 00:22:15,090
and this is an immutable queue so it's

00:22:10,260 --> 00:22:18,320
a little bit special and the immutable

00:22:15,090 --> 00:22:20,970
queue has a front list and a back list

00:22:18,320 --> 00:22:24,900
and it builds as long as you you're

00:22:20,970 --> 00:22:27,120
building it prepends here and then it

00:22:24,900 --> 00:22:30,240
switches in certain situations and adds

00:22:27,120 --> 00:22:33,570
in the front in the back reverses it and

00:22:30,240 --> 00:22:37,470
then it can start again to add on you

00:22:33,570 --> 00:22:40,860
can read more about this in it's a it's

00:22:37,470 --> 00:22:42,660
a no Chris Sasaki it has written a book

00:22:40,860 --> 00:22:45,179
about these kind of data structures and

00:22:42,660 --> 00:22:49,230
he mentioned it's also called a banker's

00:22:45,179 --> 00:22:54,980
queue and the hash map is still the same

00:22:49,230 --> 00:22:59,549
there so when you add something here

00:22:54,980 --> 00:23:02,429
you have to you have to prepend here the

00:22:59,549 --> 00:23:05,150
e is prepended so it's a new queue here

00:23:02,429 --> 00:23:07,710
but it's the Li this list should be

00:23:05,150 --> 00:23:10,679
should have been reused here I don't

00:23:07,710 --> 00:23:14,220
know why it didn't maybe it's wrong how

00:23:10,679 --> 00:23:17,700
it draws it but but it's in principle

00:23:14,220 --> 00:23:20,220
should be able to reuse it and remove

00:23:17,700 --> 00:23:22,049
all it's the same so you just remove VC

00:23:20,220 --> 00:23:24,960
and you get a new list and now you see

00:23:22,049 --> 00:23:28,010
it's been switched to the frontier while

00:23:24,960 --> 00:23:28,010
it was in the back there

00:23:31,900 --> 00:23:37,270
and then we have another one and this

00:23:35,260 --> 00:23:42,760
one is a bit special because this isn't

00:23:37,270 --> 00:23:45,420
a one mapping and another ordering this

00:23:42,760 --> 00:23:49,060
one instead mimics the linked hash map

00:23:45,420 --> 00:23:52,330
and so so so it's only a hash map but

00:23:49,060 --> 00:23:57,390
instead of having the regular entries up

00:23:52,330 --> 00:24:00,580
here it has the an entry that also keeps

00:23:57,390 --> 00:24:04,780
the key of the net of the previous and

00:24:00,580 --> 00:24:06,430
the next entry so the difference towards

00:24:04,780 --> 00:24:09,070
the mutable ones is that the MU bond has

00:24:06,430 --> 00:24:11,320
a pointer directly to the entry so it's

00:24:09,070 --> 00:24:13,570
just a pointer the reference to get the

00:24:11,320 --> 00:24:14,110
next entry and then you can continue the

00:24:13,570 --> 00:24:17,980
traversal

00:24:14,110 --> 00:24:21,280
so while this one has the key of the

00:24:17,980 --> 00:24:24,430
next time tree so it needs to go to the

00:24:21,280 --> 00:24:26,470
top of the the hash map and navigate

00:24:24,430 --> 00:24:30,310
once more down to the earth to find the

00:24:26,470 --> 00:24:32,650
so there's if you travel traverse you

00:24:30,310 --> 00:24:34,380
have to do lookups for each step while

00:24:32,650 --> 00:24:39,520
in the immutable one you can just

00:24:34,380 --> 00:24:41,020
dereference the the next pointer so

00:24:39,520 --> 00:24:46,870
that's a little bit more costly of

00:24:41,020 --> 00:24:50,440
course so you see here that the first

00:24:46,870 --> 00:24:53,280
key is a the last key is D and then it

00:24:50,440 --> 00:24:57,190
has a hash map here that has entries

00:24:53,280 --> 00:24:59,680
where where the value is in the middle

00:24:57,190 --> 00:25:03,010
and the previous pointer or the previous

00:24:59,680 --> 00:25:05,290
sorry the previous key is to the left

00:25:03,010 --> 00:25:06,970
and the next keys to right so if you

00:25:05,290 --> 00:25:09,190
have no previous key it's a special and

00:25:06,970 --> 00:25:11,650
all the value here but you here you see

00:25:09,190 --> 00:25:13,530
that you go by a and then you find B

00:25:11,650 --> 00:25:17,590
then you have to go up here and and

00:25:13,530 --> 00:25:19,810
traverse again and you find B B is there

00:25:17,590 --> 00:25:22,840
yeah and you see that the previous entry

00:25:19,810 --> 00:25:24,670
here is a and the next one is C so there

00:25:22,840 --> 00:25:27,870
you go plant and this hash mark looks

00:25:24,670 --> 00:25:30,550
order here that is just by coincidence

00:25:27,870 --> 00:25:32,500
in this case it's a hash map for and

00:25:30,550 --> 00:25:35,430
those are ordered but but in the general

00:25:32,500 --> 00:25:39,160
case this will be not be ordered by

00:25:35,430 --> 00:25:42,720
ABCDE this will be like a hash order so

00:25:39,160 --> 00:25:42,720
it's completely unpredictable

00:25:43,179 --> 00:25:53,330
so when you add stuff to this one it

00:25:48,260 --> 00:25:55,940
looks like this so you see not we added

00:25:53,330 --> 00:25:58,700
the e and it now it came first here so

00:25:55,940 --> 00:26:00,710
this this isn't ordered but still you

00:25:58,700 --> 00:26:05,420
have the a so you can go there and it

00:26:00,710 --> 00:26:07,549
can it can this one reuses very also

00:26:05,420 --> 00:26:09,410
quite a lot of the previous its they

00:26:07,549 --> 00:26:12,920
only need to change like the surrounding

00:26:09,410 --> 00:26:14,809
entries in this case the last one

00:26:12,920 --> 00:26:17,150
because the the previous last ones needs

00:26:14,809 --> 00:26:22,940
to be replaced and the new last one

00:26:17,150 --> 00:26:28,010
needs to be added and when you remove

00:26:22,940 --> 00:26:30,020
stuff here it's the same same basic

00:26:28,010 --> 00:26:32,570
thing you see the it can reuse much of

00:26:30,020 --> 00:26:36,440
the previous node or the earlier nodes

00:26:32,570 --> 00:26:42,470
while while changing so it gets a new

00:26:36,440 --> 00:26:49,640
last one and so on this actually looks

00:26:42,470 --> 00:26:51,770
wrong I have to fix that all right so I

00:26:49,640 --> 00:26:54,710
hope you got a little bit of an

00:26:51,770 --> 00:26:58,940
understanding of the be how the the

00:26:54,710 --> 00:27:02,809
different invitations are built up and

00:26:58,940 --> 00:27:05,840
we're going to look at how I dance mark

00:27:02,809 --> 00:27:07,520
those and when you benchmark in Scala or

00:27:05,840 --> 00:27:12,559
Java for that matter but especially

00:27:07,520 --> 00:27:15,470
Scala there's a nice tool called jmh the

00:27:12,559 --> 00:27:19,250
java micro benchmark harness and it

00:27:15,470 --> 00:27:23,000
helps you it's from from open JDK and it

00:27:19,250 --> 00:27:25,370
helps you avoid many common pitfalls in

00:27:23,000 --> 00:27:28,460
benchmarking it's very easy to think

00:27:25,370 --> 00:27:31,610
you're you write the benchmark and like

00:27:28,460 --> 00:27:33,830
a micro benchmark and it might be all

00:27:31,610 --> 00:27:37,010
optimized away or something if it's too

00:27:33,830 --> 00:27:39,740
trivial so some jmh provides you with

00:27:37,010 --> 00:27:43,190
with tools to keep that from happening

00:27:39,740 --> 00:27:45,590
and also because benchmarks are tend to

00:27:43,190 --> 00:27:48,470
be pretty small and maybe do nothing

00:27:45,590 --> 00:27:52,460
meaningful and then it's easy to get

00:27:48,470 --> 00:27:55,380
lost with the that they just in time

00:27:52,460 --> 00:27:58,290
compiler optimizes away all your

00:27:55,380 --> 00:28:00,930
your code almost and if you're gonna use

00:27:58,290 --> 00:28:07,590
a image with with Scala

00:28:00,930 --> 00:28:09,900
there's a nice plug-in SBT game jmh that

00:28:07,590 --> 00:28:12,860
helps it makes it very easy to run this

00:28:09,900 --> 00:28:16,130
kind of benchmark from from SBT and

00:28:12,860 --> 00:28:20,310
there's also a tool called the yey image

00:28:16,130 --> 00:28:24,290
visualizer that lets you drag your drag

00:28:20,310 --> 00:28:27,600
and drop your results file JSON file

00:28:24,290 --> 00:28:30,120
into that and it will draw the diagrams

00:28:27,600 --> 00:28:32,730
and stuff so that's really nice and it

00:28:30,120 --> 00:28:36,420
also supports if you want to run run

00:28:32,730 --> 00:28:41,030
your benchmarks on say on JDK 8 JDK 11

00:28:36,420 --> 00:28:44,760
withdraw without all those kind of stuff

00:28:41,030 --> 00:28:47,910
so this is an example of a jmh program

00:28:44,760 --> 00:28:50,100
or benchmark I don't know if you've seen

00:28:47,910 --> 00:28:52,320
it but this is like the simplest

00:28:50,100 --> 00:28:55,950
possible you say your sizes that you

00:28:52,320 --> 00:28:57,720
want to use and then you have a subject

00:28:55,950 --> 00:29:00,000
you want to test and then you initialize

00:28:57,720 --> 00:29:03,750
it in a set up meant methods you created

00:29:00,000 --> 00:29:07,050
of various sizes then and then you

00:29:03,750 --> 00:29:10,350
define your benchmark as a method like

00:29:07,050 --> 00:29:12,300
this traverse iterator so get a traitor

00:29:10,350 --> 00:29:15,180
from the subject and then move through

00:29:12,300 --> 00:29:19,140
it and down here you have a black hole

00:29:15,180 --> 00:29:22,500
here the BH and that makes it that's

00:29:19,140 --> 00:29:27,300
there for to ensure that the the it

00:29:22,500 --> 00:29:29,520
doesn't open doesn't know see here that

00:29:27,300 --> 00:29:31,890
with us we don't use the result of the

00:29:29,520 --> 00:29:33,930
next year so it could skip potential

00:29:31,890 --> 00:29:36,690
skip this old while loop but by

00:29:33,930 --> 00:29:38,790
consuming it we hide from the yeast what

00:29:36,690 --> 00:29:45,450
we do with it so it can't optimize a way

00:29:38,790 --> 00:29:49,140
the the logic yeah and this is the

00:29:45,450 --> 00:29:51,290
visualizer I thought I might try to open

00:29:49,140 --> 00:29:51,290
this

00:29:54,060 --> 00:29:59,440
so this is how it looks when you go in

00:29:56,500 --> 00:30:01,510
there you get like a screen where you

00:29:59,440 --> 00:30:06,670
can or a drop area where you can drop

00:30:01,510 --> 00:30:09,360
your files see you can start by them

00:30:06,670 --> 00:30:09,360
with the memory

00:30:23,770 --> 00:30:28,350
all right if I can get drag-and-drop to

00:30:26,200 --> 00:30:28,350
work

00:30:41,860 --> 00:30:47,679
so then it shows the the would escape of

00:30:45,610 --> 00:30:50,769
the diagram here and here you can see

00:30:47,679 --> 00:30:52,659
that yeah out here is the name of the

00:30:50,769 --> 00:30:54,399
the benchmark so this is the

00:30:52,659 --> 00:30:58,179
implementations we have like healing

00:30:54,399 --> 00:31:00,549
seek map vector map Q seek map and so on

00:30:58,179 --> 00:31:07,169
and here we see that for the memory

00:31:00,549 --> 00:31:07,169
usage in this case the tree seek map is

00:31:07,380 --> 00:31:14,049
quite bad it is it were uses a lot more

00:31:11,980 --> 00:31:15,970
memory than the other ones like double

00:31:14,049 --> 00:31:18,970
the amount of memory almost off on some

00:31:15,970 --> 00:31:21,779
of them while the best one seems to be

00:31:18,970 --> 00:31:24,370
the linked linked hash map appeared st

00:31:21,779 --> 00:31:28,090
that's the mutable one so that's really

00:31:24,370 --> 00:31:31,570
good memory wise and we also see that

00:31:28,090 --> 00:31:33,490
the and the important thing vector map

00:31:31,570 --> 00:31:36,130
here one of the the default implantation

00:31:33,490 --> 00:31:38,279
that's quite good memory usage if you

00:31:36,130 --> 00:31:42,909
hold your mouse over you get like the

00:31:38,279 --> 00:31:49,090
actual figures and so on so that's the

00:31:42,909 --> 00:31:52,389
memory and we can do the same for do the

00:31:49,090 --> 00:31:58,269
same for some operations let me shake

00:31:52,389 --> 00:32:06,580
here lots of results here you can take

00:31:58,269 --> 00:32:09,970
one leg and take concatenating two of

00:32:06,580 --> 00:32:12,029
these arrays or seek maps together and

00:32:09,970 --> 00:32:15,720
look look closer at that operation

00:32:12,029 --> 00:32:15,720
checking that get this

00:32:28,140 --> 00:32:40,320
should have had a mouse doesn't seem too

00:32:43,590 --> 00:32:48,450
yeah you can also load stuff from URLs

00:32:45,540 --> 00:32:53,610
and from guests so you can publish your

00:32:48,450 --> 00:32:56,360
results on the net if you want to use

00:32:53,610 --> 00:32:56,360
just one instant

00:33:01,090 --> 00:33:08,490
just a moment sir time results

00:33:12,859 --> 00:33:19,269
it will take some concat was that the

00:33:16,519 --> 00:33:19,269
one I wanted

00:33:26,610 --> 00:33:32,340
so this is a sample of the concat it's

00:33:29,700 --> 00:33:35,940
only for two sizes so there's not no not

00:33:32,340 --> 00:33:39,090
many there's only two one sixty sixty

00:33:35,940 --> 00:33:43,320
three elements and one for 4096 elements

00:33:39,090 --> 00:33:44,970
here you can see that the like the

00:33:43,320 --> 00:33:48,419
vector map isn't especially good at

00:33:44,970 --> 00:33:51,750
concatenate inherits the value there is

00:33:48,419 --> 00:33:54,450
nine almost a million while and if you

00:33:51,750 --> 00:33:59,130
the fastest one is the freehand seek map

00:33:54,450 --> 00:34:01,649
it has like three hundred and seventy

00:33:59,130 --> 00:34:03,659
thousand and also the three seek map is

00:34:01,649 --> 00:34:07,799
quite a bit faster than vector map or

00:34:03,659 --> 00:34:09,690
half less than half so concat is one

00:34:07,799 --> 00:34:12,270
operation where they would there's quite

00:34:09,690 --> 00:34:15,589
a few differences but the most most

00:34:12,270 --> 00:34:33,349
operations are actually almost the same

00:34:15,589 --> 00:34:33,349
independent of which can hear like

00:34:33,500 --> 00:34:40,440
appending maybe so here's the the time

00:34:38,790 --> 00:34:43,470
it takes Japan but it's a really slow

00:34:40,440 --> 00:34:45,510
really low numbers so even though they

00:34:43,470 --> 00:34:50,310
seem to differ quite a bit it's still

00:34:45,510 --> 00:34:52,649
almost the same and then appending is

00:34:50,310 --> 00:34:56,909
really fast for almost all of them

00:34:52,649 --> 00:34:59,250
I haven't list map is not included in

00:34:56,909 --> 00:35:02,339
this because if you include list map on

00:34:59,250 --> 00:35:05,849
the operations where it's not not any

00:35:02,339 --> 00:35:07,530
good it's so slow that it's like skews

00:35:05,849 --> 00:35:10,920
the whole result you see nothing else

00:35:07,530 --> 00:35:14,070
except list map so I've excluded that

00:35:10,920 --> 00:35:18,750
from my from my runs but one instrument

00:35:14,070 --> 00:35:23,730
interesting one interesting result here

00:35:18,750 --> 00:35:27,570
me let me load it where they differ

00:35:23,730 --> 00:35:32,400
quite a bit and this is also that the

00:35:27,570 --> 00:35:36,859
reason that tree seek map is included at

00:35:32,400 --> 00:35:36,859
all I think in the in two thirteen

00:35:52,340 --> 00:36:00,230
so in this one this is if you add

00:35:56,780 --> 00:36:03,760
elements and then you remove them in the

00:36:00,230 --> 00:36:06,500
same order you added them then you will

00:36:03,760 --> 00:36:08,780
for the vector map you will keep

00:36:06,500 --> 00:36:10,730
removing indexes after one another in

00:36:08,780 --> 00:36:13,190
the erase you have to replace those with

00:36:10,730 --> 00:36:16,460
Rome stones the point too but when

00:36:13,190 --> 00:36:18,770
you're like when you remove have many

00:36:16,460 --> 00:36:20,660
such thumbs down in a row then you need

00:36:18,770 --> 00:36:23,150
to go that it becomes like a linear

00:36:20,660 --> 00:36:25,070
update to change each one of those stone

00:36:23,150 --> 00:36:27,200
stones to point to the to the next

00:36:25,070 --> 00:36:28,880
because you're the one thereupon Kimpo

00:36:27,200 --> 00:36:31,070
is now removed so you need to update the

00:36:28,880 --> 00:36:35,630
pointer one more incremental pointer and

00:36:31,070 --> 00:36:39,410
that's really really expensive so you

00:36:35,630 --> 00:36:41,620
see that way to map here has almost you

00:36:39,410 --> 00:36:44,600
go to a logarithmic scale here instead

00:36:41,620 --> 00:36:48,200
you see that that the the vector map has

00:36:44,600 --> 00:36:52,250
maybe yeah for a four hundred and forty

00:36:48,200 --> 00:36:55,910
thousand no million and then you shake

00:36:52,250 --> 00:37:01,040
the fastest one is creasing map here and

00:36:55,910 --> 00:37:04,160
that one has two two and a half 2.2

00:37:01,040 --> 00:37:08,180
million so that's quite a quite a gap

00:37:04,160 --> 00:37:09,830
between those two so so yeah that that's

00:37:08,180 --> 00:37:12,620
one of the lessons you can learn from

00:37:09,830 --> 00:37:24,400
from this benchmarking results let's get

00:37:12,620 --> 00:37:24,400
back to the presentation so the

00:37:25,330 --> 00:37:30,080
conclusions what what conclusions can

00:37:27,830 --> 00:37:32,960
make about these implementations well

00:37:30,080 --> 00:37:35,450
i've been i've said some of those of

00:37:32,960 --> 00:37:37,430
these but this map is really fast for

00:37:35,450 --> 00:37:40,010
operations based on in it last he comes

00:37:37,430 --> 00:37:41,570
it decomposition so if that's if you

00:37:40,010 --> 00:37:44,360
know that's what you're gonna do you can

00:37:41,570 --> 00:37:46,700
keep using this map it's actually the

00:37:44,360 --> 00:37:48,560
best performer in those cases but it's

00:37:46,700 --> 00:37:51,170
also really slow offering anything else

00:37:48,560 --> 00:37:53,420
and that's because it has to reverse the

00:37:51,170 --> 00:37:55,430
list on each each operation and that's

00:37:53,420 --> 00:38:00,860
quite costly if the list is growing

00:37:55,430 --> 00:38:02,900
large three hash seek map is simple to

00:38:00,860 --> 00:38:05,750
implement it's almost trivial to

00:38:02,900 --> 00:38:10,400
implement but it's also

00:38:05,750 --> 00:38:14,420
quite slow and and memory intensive so

00:38:10,400 --> 00:38:16,609
and that's why three seek map is an

00:38:14,420 --> 00:38:18,710
improvement of that one vector map is is

00:38:16,609 --> 00:38:20,690
fast overall it's a really good choice

00:38:18,710 --> 00:38:24,140
for everything except consecutive

00:38:20,690 --> 00:38:26,900
removals so if you remove stuff in the

00:38:24,140 --> 00:38:32,480
same order you you put it in then it

00:38:26,900 --> 00:38:34,490
might not be the best choice and the

00:38:32,480 --> 00:38:37,579
three sake map it's it's on par with

00:38:34,490 --> 00:38:41,059
vector map overall except for removal

00:38:37,579 --> 00:38:44,119
where it's very much faster so it buddy

00:38:41,059 --> 00:38:46,609
it requires 50% more memory than vector

00:38:44,119 --> 00:38:50,150
map at least a version that's currently

00:38:46,609 --> 00:38:51,829
in 213 does and there's I've been

00:38:50,150 --> 00:38:55,099
working on an improvement that might get

00:38:51,829 --> 00:38:58,609
that down to 20% more or something the

00:38:55,099 --> 00:39:02,539
Keeling seek map is promising but I

00:38:58,609 --> 00:39:05,619
haven't had iris added it quite recently

00:39:02,539 --> 00:39:08,059
and so I haven't done the most extensive

00:39:05,619 --> 00:39:11,630
testing testing on it but it looks quite

00:39:08,059 --> 00:39:15,730
quite nice and I I believe that it might

00:39:11,630 --> 00:39:18,740
be able you might be able to make that

00:39:15,730 --> 00:39:21,500
like a good compromise between vector

00:39:18,740 --> 00:39:25,430
map and tree seek map so it might be the

00:39:21,500 --> 00:39:29,539
maybe for future scholar version that

00:39:25,430 --> 00:39:32,799
will be the one instead so double

00:39:29,539 --> 00:39:36,170
basically the stuff I had about the

00:39:32,799 --> 00:39:38,480
implementations I also I'm also going to

00:39:36,170 --> 00:39:40,130
speak a little bit about how it was to

00:39:38,480 --> 00:39:42,109
start contributing because I'm even

00:39:40,130 --> 00:39:45,380
though I mean using Scala for ten years

00:39:42,109 --> 00:39:47,119
I haven't been a contributor maybe fix

00:39:45,380 --> 00:39:49,420
some bug or something like that in in a

00:39:47,119 --> 00:39:53,390
few projects but I haven't had time to

00:39:49,420 --> 00:39:55,849
to contribute more than that but but

00:39:53,390 --> 00:39:58,609
I've been doing that now and it started

00:39:55,849 --> 00:40:00,799
with the collection Stroman project I

00:39:58,609 --> 00:40:04,279
don't know if everyone know that but I

00:40:00,799 --> 00:40:06,440
was like a like a test ground for new

00:40:04,279 --> 00:40:12,859
collections the ones that are now in in

00:40:06,440 --> 00:40:14,539
213 and I got interested in that one and

00:40:12,859 --> 00:40:17,960
I thought yeah that's really nice and it

00:40:14,539 --> 00:40:18,980
was I started developing a collection

00:40:17,960 --> 00:40:21,920
type there

00:40:18,980 --> 00:40:24,950
that's and I called spandex but it it

00:40:21,920 --> 00:40:27,260
wasn't it was like the ERISA that's also

00:40:24,950 --> 00:40:29,510
a new implementation in 213 but it was

00:40:27,260 --> 00:40:32,990
circular so you could append as well as

00:40:29,510 --> 00:40:36,590
prepend to it and it supports his right

00:40:32,990 --> 00:40:38,930
once mutation which makes it really good

00:40:36,590 --> 00:40:44,270
in some cases or many cases but also

00:40:38,930 --> 00:40:46,040
have some hard to handle corner cases it

00:40:44,270 --> 00:40:51,560
was I did not succeed in getting it

00:40:46,040 --> 00:40:55,490
merged so yeah so I continued instead

00:40:51,560 --> 00:40:58,670
because i am i liked the to work on my

00:40:55,490 --> 00:41:01,010
spare time on scala so I got interested

00:40:58,670 --> 00:41:04,280
in the seek map work initiated by

00:41:01,010 --> 00:41:06,080
massive didi Trish and I wrote this

00:41:04,280 --> 00:41:07,940
simple tree map hash map paste

00:41:06,080 --> 00:41:10,310
implementation to use as a reference for

00:41:07,940 --> 00:41:12,230
benchmarking then I started thinking

00:41:10,310 --> 00:41:14,720
ways to optimize that implementation and

00:41:12,230 --> 00:41:21,980
he ended up with the tree seek map and

00:41:14,720 --> 00:41:24,830
that converged in 213 and the scholar

00:41:21,980 --> 00:41:28,100
community I found was very very well

00:41:24,830 --> 00:41:33,200
welcoming the stromal project especially

00:41:28,100 --> 00:41:36,890
was very very nice to to have a starting

00:41:33,200 --> 00:41:39,859
point and I'd like to thank Hylian

00:41:36,890 --> 00:41:43,510
didn't Richard for though he did a good

00:41:39,859 --> 00:41:44,800
helped helped a lot when you started out

00:41:43,510 --> 00:41:50,900
[Music]

00:41:44,800 --> 00:41:53,960
so if you're gonna have a like maybe

00:41:50,900 --> 00:41:56,750
those kind of this off of the side

00:41:53,960 --> 00:41:59,540
projects or a good way of getting new

00:41:56,750 --> 00:42:02,270
contributors to start contributing at

00:41:59,540 --> 00:42:04,850
least it was for me because like instead

00:42:02,270 --> 00:42:06,830
of getting to know the full scholar it's

00:42:04,850 --> 00:42:08,750
quite complex with all the the modules

00:42:06,830 --> 00:42:11,330
and and how the structure in the in the

00:42:08,750 --> 00:42:13,609
source tree and so on you can start with

00:42:11,330 --> 00:42:18,410
something smaller and and grow from

00:42:13,609 --> 00:42:22,160
there and I always got good feedback and

00:42:18,410 --> 00:42:24,040
advice on any pull requests I made the

00:42:22,160 --> 00:42:28,940
maintainer is of course they're they're

00:42:24,040 --> 00:42:30,500
often quite busy or very busy so they of

00:42:28,940 --> 00:42:31,970
course you can't expect immediate

00:42:30,500 --> 00:42:36,020
feedback

00:42:31,970 --> 00:42:40,640
but I like if you ping them once in a

00:42:36,020 --> 00:42:42,230
while if they they'll come around just

00:42:40,640 --> 00:42:44,109
be nice to them because they have so

00:42:42,230 --> 00:42:47,720
much to do

00:42:44,109 --> 00:42:51,400
yeah that was basically it so I'm

00:42:47,720 --> 00:43:02,809
thinking about taking some questions

00:42:51,400 --> 00:43:05,930
anyone yes did you explore this idea

00:43:02,809 --> 00:43:08,539
that you have like a mutable collection

00:43:05,930 --> 00:43:11,089
and then you switch it to become

00:43:08,539 --> 00:43:13,609
immutable like Ruby does that is as

00:43:11,089 --> 00:43:16,849
operation freeze and closure has

00:43:13,609 --> 00:43:19,549
something quite similar where you work

00:43:16,849 --> 00:43:21,770
with a mutable thing and then you make

00:43:19,549 --> 00:43:27,710
it in constant time immutable

00:43:21,770 --> 00:43:30,289
thank you yes yes that's one way to

00:43:27,710 --> 00:43:34,910
there's just two aspects of that one is

00:43:30,289 --> 00:43:39,200
that in in if you have a persisting like

00:43:34,910 --> 00:43:41,480
a immutable collection and you can we

00:43:39,200 --> 00:43:43,490
have builders in Scala and those you can

00:43:41,480 --> 00:43:45,710
like even for the immutable collections

00:43:43,490 --> 00:43:49,099
you can while you have that builder you

00:43:45,710 --> 00:43:51,440
can use mutation and so on in in there

00:43:49,099 --> 00:43:54,170
if it's an underlying array or something

00:43:51,440 --> 00:43:56,000
and then once you call result it knows

00:43:54,170 --> 00:43:58,940
now it's finished so then it can return

00:43:56,000 --> 00:44:00,920
it but then a common way of working with

00:43:58,940 --> 00:44:04,880
with like with a list is that you have a

00:44:00,920 --> 00:44:08,240
list and you can add pens and item to it

00:44:04,880 --> 00:44:10,430
and the the old list is still valid so

00:44:08,240 --> 00:44:14,720
you don't know if that's going to be

00:44:10,430 --> 00:44:17,029
kept on you to be used so you can't if

00:44:14,720 --> 00:44:17,900
you have like an array sick that's an

00:44:17,029 --> 00:44:21,410
immutable array

00:44:17,900 --> 00:44:25,099
you can't start even even though the

00:44:21,410 --> 00:44:27,920
array might allow or a buffer allows

00:44:25,099 --> 00:44:29,900
that you have put stuff in it you don't

00:44:27,920 --> 00:44:33,109
know if any of the anyone has a

00:44:29,900 --> 00:44:35,210
reference to the old old states you need

00:44:33,109 --> 00:44:38,270
that that statement needs to be kept

00:44:35,210 --> 00:44:40,880
forever basically so that that's one

00:44:38,270 --> 00:44:44,450
thing if the API in Scala would have

00:44:40,880 --> 00:44:45,740
been more like that you were forced to

00:44:44,450 --> 00:44:47,390
call some seal

00:44:45,740 --> 00:44:49,220
that at the end or something then you

00:44:47,390 --> 00:44:51,050
might have that's like the Builder

00:44:49,220 --> 00:44:53,900
result method then you would know that

00:44:51,050 --> 00:44:55,970
air from here on you can't change it but

00:44:53,900 --> 00:44:58,250
but up to here you can when I did the

00:44:55,970 --> 00:44:59,300
spandex work that actually changes

00:44:58,250 --> 00:45:01,850
behind your back

00:44:59,300 --> 00:45:04,190
but it only does so if it knows that no

00:45:01,850 --> 00:45:06,830
one no one else has changed it before

00:45:04,190 --> 00:45:09,560
but once it's changed that slot will

00:45:06,830 --> 00:45:14,450
never be able to change again so it's

00:45:09,560 --> 00:45:16,760
more like a right once and and the bad

00:45:14,450 --> 00:45:19,190
thing with that it that you like if

00:45:16,760 --> 00:45:20,930
someone has a big array and writes one

00:45:19,190 --> 00:45:23,600
something in a free slot and that

00:45:20,930 --> 00:45:26,410
becomes sealed then if someone has the

00:45:23,600 --> 00:45:29,390
array that hasn't sealed that hasn't

00:45:26,410 --> 00:45:30,860
like one one step further if they try to

00:45:29,390 --> 00:45:32,960
write you have to copy the full array

00:45:30,860 --> 00:45:35,800
each time so that that's quite expensive

00:45:32,960 --> 00:45:39,020
and it might be surprising that that

00:45:35,800 --> 00:45:42,800
adding one element is it's a really

00:45:39,020 --> 00:45:44,660
expensive expensive operation so that's

00:45:42,800 --> 00:45:48,310
that's a reason why it didn't get merged

00:45:44,660 --> 00:45:56,680
I think but thank you a good question

00:45:48,310 --> 00:45:56,680
anyone else all right

00:45:57,920 --> 00:46:06,940
thank you

00:46:00,250 --> 00:46:06,940

YouTube URL: https://www.youtube.com/watch?v=lcI-jmh5Cf0


