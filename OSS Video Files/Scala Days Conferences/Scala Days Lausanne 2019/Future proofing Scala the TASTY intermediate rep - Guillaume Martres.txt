Title: Future proofing Scala the TASTY intermediate rep - Guillaume Martres
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/future-proofing-scala-the-tasty-intermediate-representation
Captions: 
	00:00:03,740 --> 00:00:10,230
okay hi everyone my name is Guillaume

00:00:07,080 --> 00:00:11,639
I'm a PhD student at EPFL working on the

00:00:10,230 --> 00:00:13,920
dotty compiler and today I'd like to

00:00:11,639 --> 00:00:15,870
talk to you about this cooling you from

00:00:13,920 --> 00:00:18,000
what we called tasty and what it means

00:00:15,870 --> 00:00:21,060
for the future of skaara

00:00:18,000 --> 00:00:24,029
so to begin with I'd like to talk about

00:00:21,060 --> 00:00:26,789
upgrading sky so imagine you're writing

00:00:24,029 --> 00:00:30,359
this like really cool up in SCARA and

00:00:26,789 --> 00:00:31,949
choosing sky to 12 but scott to 14 was

00:00:30,359 --> 00:00:33,270
just raised a few days ago it has all

00:00:31,949 --> 00:00:35,399
these cool new things like the new

00:00:33,270 --> 00:00:36,630
collections and you really want to use

00:00:35,399 --> 00:00:38,820
it so you say okay i'm just going to

00:00:36,630 --> 00:00:42,690
change the scalar version in my program

00:00:38,820 --> 00:00:44,399
from 212 to 214 and if you just use the

00:00:42,690 --> 00:00:46,920
scale a standard library and that's fine

00:00:44,399 --> 00:00:49,770
but as soon as you have dependencies

00:00:46,920 --> 00:00:52,050
which have been already compared against

00:00:49,770 --> 00:00:53,940
212 you can't do that

00:00:52,050 --> 00:00:56,160
because those dependencies won't be able

00:00:53,940 --> 00:00:59,640
to use the new standard library and the

00:00:56,160 --> 00:01:01,530
new version of SCARA and this

00:00:59,640 --> 00:01:04,739
dependencies themselves might not be

00:01:01,530 --> 00:01:06,450
able to upgrade to square to 13 until

00:01:04,739 --> 00:01:11,729
their own dependencies have been

00:01:06,450 --> 00:01:27,119
upgraded to scare 214 will screen is a

00:01:11,729 --> 00:01:30,509
little bit of so what needs to happen is

00:01:27,119 --> 00:01:32,220
first all the dependencies of the root

00:01:30,509 --> 00:01:35,850
of the tree which usually are things

00:01:32,220 --> 00:01:40,200
like sky test sky check cats need to

00:01:35,850 --> 00:01:42,299
upgrade to 213 then the library is what

00:01:40,200 --> 00:01:44,640
uses less libraries that you depend on

00:01:42,299 --> 00:01:48,210
need to upgrade and then finally you can

00:01:44,640 --> 00:01:51,079
start using Scala 214 so why does this

00:01:48,210 --> 00:01:53,159
happen why what's going on here exactly

00:01:51,079 --> 00:01:56,479
so to explain that first I need to

00:01:53,159 --> 00:02:00,329
explain what binary compatibility is so

00:01:56,479 --> 00:02:02,909
in a very big nutshell imagine I have

00:02:00,329 --> 00:02:06,390
project a which is compared against some

00:02:02,909 --> 00:02:08,670
specific version X of project B and then

00:02:06,390 --> 00:02:11,849
I want to run this project with a

00:02:08,670 --> 00:02:13,170
different version of project B and if it

00:02:11,849 --> 00:02:16,050
doesn't work

00:02:13,170 --> 00:02:18,480
dozen 4qj means a crush at runtime when

00:02:16,050 --> 00:02:20,790
we say that X and one y are binary

00:02:18,480 --> 00:02:22,890
incompatible and if you want more

00:02:20,790 --> 00:02:25,410
details you should go see this awesome

00:02:22,890 --> 00:02:28,140
torque which is on youtube by sebastian

00:02:25,410 --> 00:02:31,440
about how to design libraries for source

00:02:28,140 --> 00:02:33,450
and binary compatibility okay so we

00:02:31,440 --> 00:02:36,270
understand this but why why does kinda

00:02:33,450 --> 00:02:38,550
need to break binary compatibility every

00:02:36,270 --> 00:02:43,200
two years like is this just a fact of

00:02:38,550 --> 00:02:45,300
life so so usually it's because like you

00:02:43,200 --> 00:02:46,650
want to change things like because you

00:02:45,300 --> 00:02:48,600
realized there's some other way to do

00:02:46,650 --> 00:02:49,980
things or better way to do things or a

00:02:48,600 --> 00:02:51,959
way that didn't exist before

00:02:49,980 --> 00:02:54,540
but some changes are really hard or

00:02:51,959 --> 00:02:58,440
almost impossible to make without

00:02:54,540 --> 00:03:01,200
breaking binary compatibility so in the

00:02:58,440 --> 00:03:02,970
event two to twelve transitioned biggest

00:03:01,200 --> 00:03:05,160
of these changes were multiple ones but

00:03:02,970 --> 00:03:08,400
will biggest one was a new encoding for

00:03:05,160 --> 00:03:10,800
traits based on the new support for

00:03:08,400 --> 00:03:12,660
default methods in Java 8 which means

00:03:10,800 --> 00:03:14,489
among other things that the

00:03:12,660 --> 00:03:17,299
implementation of stretch was much

00:03:14,489 --> 00:03:18,989
simpler but it also means that we

00:03:17,299 --> 00:03:20,549
including it had to be completely

00:03:18,989 --> 00:03:25,290
different so if you used a scale a to

00:03:20,549 --> 00:03:28,560
eleven compiled classifier you couldn't

00:03:25,290 --> 00:03:31,560
use it with Scylla to twelve compiled

00:03:28,560 --> 00:03:36,630
class file because we just didn't speak

00:03:31,560 --> 00:03:39,510
the same language and from 212 to 213

00:03:36,630 --> 00:03:42,030
the main reason for working binary

00:03:39,510 --> 00:03:44,100
compatibility was not the level of

00:03:42,030 --> 00:03:46,380
language itself but that were level of

00:03:44,100 --> 00:03:48,900
standard library we have standard

00:03:46,380 --> 00:03:50,910
collection was redesigned and not clever

00:03:48,900 --> 00:03:53,070
hierarchy of classes which is something

00:03:50,910 --> 00:03:55,110
that is very basically impossible to

00:03:53,070 --> 00:03:57,590
change without breaking binary

00:03:55,110 --> 00:04:01,410
compatibility due to how the JVM works

00:03:57,590 --> 00:04:05,190
okay but yeah there's always a good

00:04:01,410 --> 00:04:07,019
reason basically but can we can we

00:04:05,190 --> 00:04:09,690
maintain compatibility while still

00:04:07,019 --> 00:04:12,170
evolving Scala and yeah I don't really

00:04:09,690 --> 00:04:14,489
know but maybe we should try because

00:04:12,170 --> 00:04:17,669
like breaking compatibility all the time

00:04:14,489 --> 00:04:19,859
is is such like makes it really hard for

00:04:17,669 --> 00:04:21,810
people to upgrade to try new versions so

00:04:19,859 --> 00:04:25,370
so maybe we can try to do things a

00:04:21,810 --> 00:04:25,370
little bit different and see how it goes

00:04:25,389 --> 00:04:31,120
and I think like when interesting

00:04:27,539 --> 00:04:32,889
example of how things can be done exists

00:04:31,120 --> 00:04:36,099
already in Scala and that's skellige is

00:04:32,889 --> 00:04:38,560
so so it's you can say well it's not

00:04:36,099 --> 00:04:40,659
really like its own language but I mean

00:04:38,560 --> 00:04:42,159
kind of is really it's it pretends to be

00:04:40,659 --> 00:04:43,900
a compare again but it's really like

00:04:42,159 --> 00:04:45,129
Google compiler does a lot of things

00:04:43,900 --> 00:04:48,099
it's crazy

00:04:45,129 --> 00:04:50,199
and what's really crazy is that it has

00:04:48,099 --> 00:04:52,060
maintained binary compatibility for more

00:04:50,199 --> 00:04:54,659
than four years like longer than the

00:04:52,060 --> 00:04:58,629
times the lifetime of fiscal aversion

00:04:54,659 --> 00:05:00,659
and what what this means so this means

00:04:58,629 --> 00:05:04,990
multiple things cause Karagias provides

00:05:00,659 --> 00:05:08,080
JVM API for like using the square J's

00:05:04,990 --> 00:05:10,539
compiler for SBT plug-in stuff like that

00:05:08,080 --> 00:05:12,849
which also in VN is going to output

00:05:10,539 --> 00:05:16,419
JavaScript but when you make a square

00:05:12,849 --> 00:05:19,870
jeaious project and you like to wish

00:05:16,419 --> 00:05:23,680
your jar to maven the jar doesn't

00:05:19,870 --> 00:05:26,219
contain JS files inside contains SJS ir

00:05:23,680 --> 00:05:28,509
files which is this like own custom

00:05:26,219 --> 00:05:31,539
intermediate representation that

00:05:28,509 --> 00:05:32,669
sketchiest uses and when you compile

00:05:31,539 --> 00:05:35,650
your own project

00:05:32,669 --> 00:05:37,419
the scheduler is going to take all this

00:05:35,650 --> 00:05:39,759
SJS ir files from all your dependencies

00:05:37,419 --> 00:05:42,639
as input to eventually produce

00:05:39,759 --> 00:05:43,990
javascript and that enables a bunch of

00:05:42,639 --> 00:05:46,599
interesting things like full program

00:05:43,990 --> 00:05:48,729
optimization since like schedules can

00:05:46,599 --> 00:05:51,190
see everything that uses it's able to do

00:05:48,729 --> 00:05:54,610
really really crazy optimizations but it

00:05:51,190 --> 00:05:57,580
also means that if they decide to change

00:05:54,610 --> 00:06:00,669
how to generate JavaScript they can

00:05:57,580 --> 00:06:02,830
still use old as gsi our files and

00:06:00,669 --> 00:06:06,159
because there's a quick version number

00:06:02,830 --> 00:06:07,930
investors have fire we can just decide

00:06:06,159 --> 00:06:10,629
oh this is an old file but we know how

00:06:07,930 --> 00:06:13,120
to interpret it to make it do things the

00:06:10,629 --> 00:06:15,159
way we want to do now and that's like

00:06:13,120 --> 00:06:18,120
the secret to maintaining compatibility

00:06:15,159 --> 00:06:21,669
for a very long time

00:06:18,120 --> 00:06:24,219
ok so when we get from that like can we

00:06:21,669 --> 00:06:29,889
make one format which will be a bit what

00:06:24,219 --> 00:06:35,289
HGS ir is to JavaScript to 2j to JVM

00:06:29,889 --> 00:06:37,209
class files maybe so the idea will be to

00:06:35,289 --> 00:06:38,289
store the output of one of the compiler

00:06:37,209 --> 00:06:41,169
phases

00:06:38,289 --> 00:06:44,259
and based on that we can like restart

00:06:41,169 --> 00:06:46,629
the computation from that point on but

00:06:44,259 --> 00:06:49,059
when we put this thing in the comparable

00:06:46,629 --> 00:06:54,039
pencil to explain that I have to show

00:06:49,059 --> 00:06:56,740
you the compiler pipeline so you start

00:06:54,039 --> 00:06:59,439
with some source car fire and then like

00:06:56,740 --> 00:07:03,009
magic happens and in VN you get one or

00:06:59,439 --> 00:07:05,139
more classifiers so now we need to get a

00:07:03,009 --> 00:07:07,089
bit deep into the magic to explain

00:07:05,139 --> 00:07:09,669
what's going on so the first thing is

00:07:07,089 --> 00:07:12,729
we're going to pass that file into a

00:07:09,669 --> 00:07:15,490
tree what does that mean

00:07:12,729 --> 00:07:18,099
so I start by passing let's say I'm

00:07:15,490 --> 00:07:20,740
pressing an expression like Bob here is

00:07:18,099 --> 00:07:22,749
an expression the parser is going to say

00:07:20,740 --> 00:07:26,349
to see that and say ok that's as an

00:07:22,749 --> 00:07:29,619
identifier and the identifier is via the

00:07:26,349 --> 00:07:32,830
string up basically and then if I do

00:07:29,619 --> 00:07:34,270
object LM then the passer because of a

00:07:32,830 --> 00:07:35,919
dot know that this is some kind of

00:07:34,270 --> 00:07:39,490
selection so that's represented with a

00:07:35,919 --> 00:07:42,610
select tree nod which takes the thing we

00:07:39,490 --> 00:07:48,099
parse for Rob and then selects Adam out

00:07:42,610 --> 00:07:50,229
of it and then if I put parens and put

00:07:48,099 --> 00:07:51,550
some constant here then this becomes an

00:07:50,229 --> 00:07:55,089
application of something which is

00:07:51,550 --> 00:07:58,449
represented with the apply node which as

00:07:55,089 --> 00:08:03,550
a second parameter takes a literal which

00:07:58,449 --> 00:08:07,089
is constant five okay so so that makes

00:08:03,550 --> 00:08:08,499
sense but once you have this tree what

00:08:07,089 --> 00:08:11,680
can we do with it you can't really do

00:08:08,499 --> 00:08:13,599
anything with it yet because it's only

00:08:11,680 --> 00:08:15,519
syntactic it doesn't have any semantic

00:08:13,599 --> 00:08:18,550
information doesn't tell you like what

00:08:15,519 --> 00:08:21,819
the code is doing so the next step the

00:08:18,550 --> 00:08:25,689
big step is typer which is like taking

00:08:21,819 --> 00:08:27,759
this one type 3 and type checking it and

00:08:25,689 --> 00:08:30,369
the way type checking works I'm not

00:08:27,759 --> 00:08:33,760
going to explain like of details because

00:08:30,369 --> 00:08:37,509
that's many many more torques worth of

00:08:33,760 --> 00:08:39,630
material but we start at the top of the

00:08:37,509 --> 00:08:42,039
wood so we have already passed three and

00:08:39,630 --> 00:08:43,509
we type check apply first we need to

00:08:42,039 --> 00:08:45,790
type check it's children swimming to

00:08:43,509 --> 00:08:48,939
type check select and type check select

00:08:45,790 --> 00:08:52,209
you need to type ident and to type I

00:08:48,939 --> 00:08:54,399
don't we know all this is an identifier

00:08:52,209 --> 00:08:56,620
so at this point we have some

00:08:54,399 --> 00:08:59,860
information and I would like scrubs we

00:08:56,620 --> 00:09:02,500
know what names we already have in your

00:08:59,860 --> 00:09:04,779
current source file we know what's on

00:09:02,500 --> 00:09:07,360
our class path and based on that we can

00:09:04,779 --> 00:09:10,680
see that like up in this context

00:09:07,360 --> 00:09:12,790
resolves to a dot opps for example and

00:09:10,680 --> 00:09:15,430
here I'm not showing the details but

00:09:12,790 --> 00:09:18,279
basically there's another tree like

00:09:15,430 --> 00:09:20,769
structure to represent types but here

00:09:18,279 --> 00:09:22,810
understand this is a dot that's really

00:09:20,769 --> 00:09:26,019
if a compiler is going to like make ups

00:09:22,810 --> 00:09:27,910
on some type for a and then it's going

00:09:26,019 --> 00:09:33,160
to make up some type for selecting herbs

00:09:27,910 --> 00:09:36,190
out of a so ok now we have the type of

00:09:33,160 --> 00:09:38,769
or if and we can go back up one level to

00:09:36,190 --> 00:09:42,130
type you select so to type the Select we

00:09:38,769 --> 00:09:45,149
need to look for some element so for

00:09:42,130 --> 00:09:48,550
some field called LM in a dot edge and

00:09:45,149 --> 00:09:51,279
it's going to get a type like maybe int

00:09:48,550 --> 00:09:55,329
to int and once we have this information

00:09:51,279 --> 00:09:58,149
we can then type the apply node by first

00:09:55,329 --> 00:10:01,540
typing constant five and the type of

00:09:58,149 --> 00:10:04,990
five is five because we have singleton

00:10:01,540 --> 00:10:06,760
types for literals and we know when we

00:10:04,990 --> 00:10:08,920
can just very easily see that by

00:10:06,760 --> 00:10:14,410
applying this thing - that thing we must

00:10:08,920 --> 00:10:15,880
get an int and there's one very big

00:10:14,410 --> 00:10:19,990
thing I've ghost over here is what

00:10:15,880 --> 00:10:21,370
typing can also create new trees so as

00:10:19,990 --> 00:10:24,970
you're probably familiar if I write

00:10:21,370 --> 00:10:27,100
lists of one two then this is going to

00:10:24,970 --> 00:10:30,790
be equivalent writing list dot apply of

00:10:27,100 --> 00:10:33,310
one two and the way this works is when

00:10:30,790 --> 00:10:35,110
I'm type checking list so this is like

00:10:33,310 --> 00:10:37,990
an apply note that we've seen before and

00:10:35,110 --> 00:10:38,920
then this is some identifier and once

00:10:37,990 --> 00:10:41,199
I've type checked it

00:10:38,920 --> 00:10:44,350
I'm going to look at the expected type

00:10:41,199 --> 00:10:46,060
and the expected type is something that

00:10:44,350 --> 00:10:48,519
must be applied and we know this because

00:10:46,060 --> 00:10:50,949
we are coming from an apply note

00:10:48,519 --> 00:10:53,140
so because of this the compiler is going

00:10:50,949 --> 00:10:55,690
to say okay I have to introduce a dot

00:10:53,140 --> 00:10:58,089
apply here to be able to type check this

00:10:55,690 --> 00:11:00,100
thing correctly and there's many many

00:10:58,089 --> 00:11:02,560
ways in which the type checker can

00:11:00,100 --> 00:11:04,630
create new trees and of course the most

00:11:02,560 --> 00:11:05,530
important one in sky just implicit

00:11:04,630 --> 00:11:10,390
resolution

00:11:05,530 --> 00:11:13,600
or do you get resolution so for access

00:11:10,390 --> 00:11:15,310
that max when we get to when we have

00:11:13,600 --> 00:11:17,080
seen a tree looking power is going to

00:11:15,310 --> 00:11:20,350
see oh this is actually a method that

00:11:17,080 --> 00:11:22,420
takes some given parameter some implicit

00:11:20,350 --> 00:11:24,700
parameter and I'm just going to give it

00:11:22,420 --> 00:11:29,020
so it's going to resolve that parameter

00:11:24,700 --> 00:11:30,720
is going to create a tree for it and the

00:11:29,020 --> 00:11:34,390
other important thing to note is that

00:11:30,720 --> 00:11:36,700
this is an idempotent process so if we

00:11:34,390 --> 00:11:39,010
take this tree which has been typed once

00:11:36,700 --> 00:11:40,630
and if you try to retype it again the

00:11:39,010 --> 00:11:42,280
compare is not going to keep inserting

00:11:40,630 --> 00:11:44,140
new trees except if there's a blog and

00:11:42,280 --> 00:11:48,940
when it does not apply a topcoat apply

00:11:44,140 --> 00:11:51,130
that happen before and this is going to

00:11:48,940 --> 00:11:52,660
be very important for what I'm going to

00:11:51,130 --> 00:11:54,730
show later but it's already very very

00:11:52,660 --> 00:11:57,790
useful as a concept for debugging

00:11:54,730 --> 00:11:59,560
because it means that as we go through

00:11:57,790 --> 00:12:02,170
the compiler phases and we start

00:11:59,560 --> 00:12:03,940
transforming the trees we can always

00:12:02,170 --> 00:12:06,370
like sanity check that what we are doing

00:12:03,940 --> 00:12:09,820
makes sense by redoing the type checking

00:12:06,370 --> 00:12:16,540
and verifying that indeed all four types

00:12:09,820 --> 00:12:18,790
match out right okay so now we've seen

00:12:16,540 --> 00:12:21,190
like the biggest piece of the compiler

00:12:18,790 --> 00:12:25,600
and now there's I can replace the magic

00:12:21,190 --> 00:12:27,190
by the actual rest of the compiler so

00:12:25,600 --> 00:12:33,070
I'm going to explain what these things

00:12:27,190 --> 00:12:35,710
do so PQ is in something that exists

00:12:33,070 --> 00:12:38,830
both in scale - and carefree and the

00:12:35,710 --> 00:12:43,360
original motivation is separate

00:12:38,830 --> 00:12:46,030
compilation so if you just produce some

00:12:43,360 --> 00:12:47,980
classifier in your class file you're

00:12:46,030 --> 00:12:50,350
going to have methods and with me photos

00:12:47,980 --> 00:12:53,740
are going to have types but these types

00:12:50,350 --> 00:12:55,900
are going to be JVM types like if you

00:12:53,740 --> 00:12:59,350
write list of int with JVM type is going

00:12:55,900 --> 00:13:02,680
to be list because the JVM because Java

00:12:59,350 --> 00:13:04,810
supports generous there's also some

00:13:02,680 --> 00:13:09,100
extra information that the JVM doesn't

00:13:04,810 --> 00:13:10,900
use but that Java C uses to get type

00:13:09,100 --> 00:13:12,820
parameter information so at some point

00:13:10,900 --> 00:13:15,040
somewhere in that class I will write all

00:13:12,820 --> 00:13:18,040
this method but we say return the list

00:13:15,040 --> 00:13:21,160
actually it returns a list of int

00:13:18,040 --> 00:13:22,839
but that mechanism doesn't Shabbat

00:13:21,160 --> 00:13:25,329
of course all the Scalia types because

00:13:22,839 --> 00:13:27,939
Kara has many more sort of types than

00:13:25,329 --> 00:13:29,019
Java has and particularly will have

00:13:27,939 --> 00:13:33,819
higher content types

00:13:29,019 --> 00:13:35,829
union types all that kind of stuff so we

00:13:33,819 --> 00:13:39,339
need to store this information somewhere

00:13:35,829 --> 00:13:42,999
in the classifier or around where we can

00:13:39,339 --> 00:13:47,319
use it because if I compile two files a

00:13:42,999 --> 00:13:49,869
dot scanner and B dot skaara if I'm done

00:13:47,319 --> 00:13:52,149
compiling a dakara I start comparing be

00:13:49,869 --> 00:13:53,980
dots color with the result of the first

00:13:52,149 --> 00:13:57,309
compilation on my class path I need to

00:13:53,980 --> 00:13:59,619
know the types of but the skeleton

00:13:57,309 --> 00:14:03,009
palette used for the first thing I

00:13:59,619 --> 00:14:04,899
compiled so this information is picking

00:14:03,009 --> 00:14:07,449
information which is taught in the

00:14:04,899 --> 00:14:10,779
classifier in skeleton and I'm going to

00:14:07,449 --> 00:14:14,499
explain how it's taught in key in a few

00:14:10,779 --> 00:14:16,959
minutes so tickler itself is not going

00:14:14,499 --> 00:14:19,779
to transform any tree it's just going to

00:14:16,959 --> 00:14:21,549
like not information and store it aside

00:14:19,779 --> 00:14:23,559
and then it's going to take the type

00:14:21,549 --> 00:14:25,239
check tree and pass it to the next phase

00:14:23,559 --> 00:14:29,290
you know it's the next phase it's

00:14:25,239 --> 00:14:31,989
actually next fifty phase so all of

00:14:29,290 --> 00:14:34,809
these small phases are going to take

00:14:31,989 --> 00:14:37,959
this very high-level type check tree we

00:14:34,809 --> 00:14:40,389
have which represents our scale program

00:14:37,959 --> 00:14:43,239
and bit by bit we are going to transform

00:14:40,389 --> 00:14:46,689
them into something which can be run on

00:14:43,239 --> 00:14:48,850
the JVM or on some other back-end and

00:14:46,689 --> 00:14:52,959
once we've done all the simplification

00:14:48,850 --> 00:14:55,089
steps we get to the backend and which is

00:14:52,959 --> 00:14:57,910
back end is just the piece of code which

00:14:55,089 --> 00:15:00,819
is going to take our trees and going to

00:14:57,910 --> 00:15:04,119
emit classifiers for them or JavaScript

00:15:00,819 --> 00:15:06,369
or something some other thing okay

00:15:04,119 --> 00:15:09,850
another question is among all these

00:15:06,369 --> 00:15:12,100
things that where should we put this new

00:15:09,850 --> 00:15:14,980
intermediate representation that we want

00:15:12,100 --> 00:15:15,459
to star and of course I put it in the

00:15:14,980 --> 00:15:19,239
middle

00:15:15,459 --> 00:15:22,419
it's the picker because

00:15:19,239 --> 00:15:25,029
when we add a picker phase we are just

00:15:22,419 --> 00:15:27,339
after with type check trees which means

00:15:25,029 --> 00:15:29,739
we have all the semantic information in

00:15:27,339 --> 00:15:30,550
that to understand what our program has

00:15:29,739 --> 00:15:33,070
to do

00:15:30,550 --> 00:15:37,000
but we haven't yet done other

00:15:33,070 --> 00:15:43,020
simplifications which eventually allow

00:15:37,000 --> 00:15:45,880
us to run on some specific runtime so

00:15:43,020 --> 00:15:47,350
well what do we put in this file exactly

00:15:45,880 --> 00:15:50,710
what what's the point

00:15:47,350 --> 00:15:52,390
so the first main point is is something

00:15:50,710 --> 00:15:55,180
that can be that should be able to

00:15:52,390 --> 00:15:57,730
evolve as we go for new scale versions

00:15:55,180 --> 00:15:59,410
we have new ideas we find things that

00:15:57,730 --> 00:16:02,350
didn't really work out we want to be

00:15:59,410 --> 00:16:04,470
able to add stuff remove stuff or not

00:16:02,350 --> 00:16:09,790
remove stuff but duplicate stuff without

00:16:04,470 --> 00:16:11,590
breaking existing files and it has to be

00:16:09,790 --> 00:16:13,630
as compact as possible because this

00:16:11,590 --> 00:16:17,500
these files are going to be in every jar

00:16:13,630 --> 00:16:20,320
you distribute so we try to make the

00:16:17,500 --> 00:16:23,620
format something that does not have a

00:16:20,320 --> 00:16:25,330
huge overhead and it has to preserve all

00:16:23,620 --> 00:16:27,910
the information you need for computation

00:16:25,330 --> 00:16:31,210
so you you need to be able to take the

00:16:27,910 --> 00:16:33,160
testifiers input and get to the same

00:16:31,210 --> 00:16:35,670
thing that you would have gotten if you

00:16:33,160 --> 00:16:38,230
had started from the source files and

00:16:35,670 --> 00:16:40,240
then as long as we are doing all of that

00:16:38,230 --> 00:16:42,490
maybe we can add some extra information

00:16:40,240 --> 00:16:47,410
that can be used for tooling like ideas

00:16:42,490 --> 00:16:49,900
repairs documentation generation etc ok

00:16:47,410 --> 00:16:52,450
so now I'm going to explain a binary

00:16:49,900 --> 00:16:53,740
format of tasty in some details and to

00:16:52,450 --> 00:16:57,910
make that less boring I'm going to use

00:16:53,740 --> 00:17:01,090
like nice diagrams so the first thing is

00:16:57,910 --> 00:17:03,640
with all some constant which is how you

00:17:01,090 --> 00:17:07,780
see that the file is a tasty file and

00:17:03,640 --> 00:17:09,910
after that the next two thing are

00:17:07,780 --> 00:17:11,980
represented as natural numbers and I'm

00:17:09,910 --> 00:17:13,839
going to show which encoding we use for

00:17:11,980 --> 00:17:15,880
natural numbers and they represent the

00:17:13,839 --> 00:17:19,750
module version and the minor version of

00:17:15,880 --> 00:17:22,060
the format and like the end goal is this

00:17:19,750 --> 00:17:25,870
thing is going to be fixed for like the

00:17:22,060 --> 00:17:28,150
next century and we can just increment

00:17:25,870 --> 00:17:31,240
the minor version without breaking

00:17:28,150 --> 00:17:33,010
compatibility after that comes the name

00:17:31,240 --> 00:17:35,110
table which is where we store all the

00:17:33,010 --> 00:17:38,110
names that we are going to refer to in

00:17:35,110 --> 00:17:41,200
our program and after that comes a bunch

00:17:38,110 --> 00:17:43,390
of sections which are where we actually

00:17:41,200 --> 00:17:44,380
put the type checked abstract syntax

00:17:43,390 --> 00:17:47,740
trees bye

00:17:44,380 --> 00:17:49,390
that's why it's called tasty and any

00:17:47,740 --> 00:17:51,880
extra information we want so there can

00:17:49,390 --> 00:17:56,080
be one or more of a section which is

00:17:51,880 --> 00:18:00,010
what you have this loop here so the name

00:17:56,080 --> 00:18:01,960
table is just you need to when you

00:18:00,010 --> 00:18:04,600
encode it you have to choose like you

00:18:01,960 --> 00:18:06,160
have to write down its length and then

00:18:04,600 --> 00:18:09,160
you just write down a bunch of names and

00:18:06,160 --> 00:18:13,960
names interesting themselves not just

00:18:09,160 --> 00:18:15,549
like a bunch of of string constants but

00:18:13,960 --> 00:18:20,049
they can have some semantic information

00:18:15,549 --> 00:18:22,570
so you have just basic names which are

00:18:20,049 --> 00:18:23,980
just like a bunch of utf-8 code points

00:18:22,570 --> 00:18:26,049
then you have some more interesting

00:18:23,980 --> 00:18:30,100
things like for finance so for example

00:18:26,049 --> 00:18:32,080
sometimes we need to to represent scale

00:18:30,100 --> 00:18:35,559
a dot int and we could represent it as a

00:18:32,080 --> 00:18:36,940
string where the dot is how we we see

00:18:35,559 --> 00:18:39,659
that this is actually verified things

00:18:36,940 --> 00:18:42,909
but this is pretty problematic because

00:18:39,659 --> 00:18:46,840
it becomes very hard to distinguish

00:18:42,909 --> 00:18:48,429
between the names that have meaning that

00:18:46,840 --> 00:18:50,200
the compiler uses and the name that

00:18:48,429 --> 00:18:52,630
we'll use of what and especially in

00:18:50,200 --> 00:18:54,549
Scala where you can put pretty much

00:18:52,630 --> 00:18:56,890
anything you want in the names of the

00:18:54,549 --> 00:19:00,940
definition if you just enclose them in

00:18:56,890 --> 00:19:03,280
backticks so query sign name is

00:19:00,940 --> 00:19:06,970
represented using some some tags so this

00:19:03,280 --> 00:19:09,730
is some constant then some length

00:19:06,970 --> 00:19:11,289
information and then just to support the

00:19:09,730 --> 00:19:13,750
qualifier so in this case it will be

00:19:11,289 --> 00:19:16,659
scarab and the thing you're selecting

00:19:13,750 --> 00:19:20,200
which in this case would be int and name

00:19:16,659 --> 00:19:22,360
ref is just going to be a natural number

00:19:20,200 --> 00:19:24,370
which is going to be enough set in the

00:19:22,360 --> 00:19:27,820
name table so this is all just pointers

00:19:24,370 --> 00:19:31,230
to other things okay and now we get to

00:19:27,820 --> 00:19:34,030
the meat of tasty format with estimate

00:19:31,230 --> 00:19:36,549
which is the abstract syntax tree

00:19:34,030 --> 00:19:38,380
section so it starts with a string which

00:19:36,549 --> 00:19:40,600
isn't real your string is going to be an

00:19:38,380 --> 00:19:44,559
index in the name table but you get it

00:19:40,600 --> 00:19:46,360
and then a bunch of statements and a

00:19:44,559 --> 00:19:47,919
statement I'm not going to show all of

00:19:46,360 --> 00:19:51,929
them because there's a bunch of them but

00:19:47,919 --> 00:19:55,540
those are basically the trees of the

00:19:51,929 --> 00:19:57,650
format so you can have a package tree to

00:19:55,540 --> 00:20:01,990
represent the package

00:19:57,650 --> 00:20:04,700
in poetry tree for defining Val and

00:20:01,990 --> 00:20:06,290
those are very close to how they are

00:20:04,700 --> 00:20:08,870
represented internally by the compiler

00:20:06,290 --> 00:20:12,200
so for example there is something which

00:20:08,870 --> 00:20:14,720
has a name it has a type it may or may

00:20:12,200 --> 00:20:16,850
not have a right-hand side because it

00:20:14,720 --> 00:20:19,670
might be abstract and you can have

00:20:16,850 --> 00:20:24,950
modifier like private that kind of thing

00:20:19,670 --> 00:20:30,710
and then the other important part is

00:20:24,950 --> 00:20:32,830
types whim selves so types there's also

00:20:30,710 --> 00:20:35,809
a lot of them as you might have guessed

00:20:32,830 --> 00:20:38,240
but a few interesting ones but you might

00:20:35,809 --> 00:20:41,059
recognize is type bounds so this is like

00:20:38,240 --> 00:20:43,370
when you write super type of something

00:20:41,059 --> 00:20:48,230
subtype of something we represent that

00:20:43,370 --> 00:20:50,929
with a type bounds tag followed by the

00:20:48,230 --> 00:20:52,970
representation of your bound for a level

00:20:50,929 --> 00:20:54,770
presentation of the high amount and the

00:20:52,970 --> 00:20:57,170
type application like a list of int

00:20:54,770 --> 00:21:01,250
that's represented with an applied type

00:20:57,170 --> 00:21:03,020
tag of representation of Lists and then

00:21:01,250 --> 00:21:08,929
representation of its arguments which

00:21:03,020 --> 00:21:10,429
can be 0 and then terms so that's very

00:21:08,929 --> 00:21:15,040
close to what we've seen before with the

00:21:10,429 --> 00:21:18,530
ident and select nodes but here we are

00:21:15,040 --> 00:21:21,950
advil of tasty format so it's a bit

00:21:18,530 --> 00:21:24,140
lower level and here there's an

00:21:21,950 --> 00:21:26,929
interesting an important point

00:21:24,140 --> 00:21:29,690
that's not very obvious is that not all

00:21:26,929 --> 00:21:31,940
of the terms have types but we aren't

00:21:29,690 --> 00:21:36,290
typed language so what does that mean so

00:21:31,940 --> 00:21:38,270
in fact to avoid wasting space we don't

00:21:36,290 --> 00:21:40,520
need to store the types of everything

00:21:38,270 --> 00:21:43,610
because we need to really to store the

00:21:40,520 --> 00:21:46,850
types of leaves of the trees so for

00:21:43,610 --> 00:21:49,880
example the identifier once we've looked

00:21:46,850 --> 00:21:51,350
up in the scopes what have you what do

00:21:49,880 --> 00:21:55,240
they represent we can store that

00:21:51,350 --> 00:21:58,280
information in the type of the ident tag

00:21:55,240 --> 00:22:00,470
but when I do an application I don't

00:21:58,280 --> 00:22:02,960
need to store the result of the type of

00:22:00,470 --> 00:22:05,240
the application because when I'm going

00:22:02,960 --> 00:22:08,150
to read the testee tree I can just look

00:22:05,240 --> 00:22:11,060
at the type of function the type of its

00:22:08,150 --> 00:22:13,490
arguments and then I can we

00:22:11,060 --> 00:22:19,760
we find out again the type of the

00:22:13,490 --> 00:22:23,360
application and now we get to the extra

00:22:19,760 --> 00:22:27,230
sections which after the abstract syntax

00:22:23,360 --> 00:22:29,390
tree section so very simple one but very

00:22:27,230 --> 00:22:32,690
useful one is just the comment section

00:22:29,390 --> 00:22:35,960
which is going to store every square

00:22:32,690 --> 00:22:38,960
document in your file and the way this

00:22:35,960 --> 00:22:41,750
works is we for every comment we are

00:22:38,960 --> 00:22:46,490
going to store the pointer to which

00:22:41,750 --> 00:22:50,750
definition in the TSE testify it refers

00:22:46,490 --> 00:22:52,760
to the length of the comment the set of

00:22:50,750 --> 00:22:55,820
code points which represent the string

00:22:52,760 --> 00:22:58,190
of the comments and then the position of

00:22:55,820 --> 00:22:59,780
this comment in the source file and this

00:22:58,190 --> 00:23:01,910
information is completely useless for

00:22:59,780 --> 00:23:04,730
compiling of course but it's really

00:23:01,910 --> 00:23:08,660
useful if you're an IDE and you want to

00:23:04,730 --> 00:23:10,730
show to the user a comment the

00:23:08,660 --> 00:23:14,210
documentation comment for the thing he

00:23:10,730 --> 00:23:15,830
is hovering over and we are also using

00:23:14,210 --> 00:23:19,490
it for example in the dhoti wrapper

00:23:15,830 --> 00:23:21,530
while we can type : duck space and then

00:23:19,490 --> 00:23:24,170
the name of some method is going to look

00:23:21,530 --> 00:23:26,360
up the documentation comments from the

00:23:24,170 --> 00:23:29,510
testifier and that's a much more direct

00:23:26,360 --> 00:23:33,170
wave and going through like getting the

00:23:29,510 --> 00:23:38,000
source jar processing it and trying to

00:23:33,170 --> 00:23:41,450
mad much that with the trees you have in

00:23:38,000 --> 00:23:43,460
your compiler and finally a very

00:23:41,450 --> 00:23:46,550
important section is the position

00:23:43,460 --> 00:23:48,950
section which stores the position so the

00:23:46,550 --> 00:23:51,470
offset from the beginning of the file of

00:23:48,950 --> 00:23:52,010
every tree that has been written by the

00:23:51,470 --> 00:23:54,500
user

00:23:52,010 --> 00:23:55,220
I say user written free because as we've

00:23:54,500 --> 00:23:56,960
seen before

00:23:55,220 --> 00:24:00,080
when you type check your program you're

00:23:56,960 --> 00:24:02,770
going to create new trees which are not

00:24:00,080 --> 00:24:05,180
written by the users and so these trees

00:24:02,770 --> 00:24:07,370
you need to be able to distinguish them

00:24:05,180 --> 00:24:09,590
from those but the user wrote because

00:24:07,370 --> 00:24:11,240
when you hover although something in

00:24:09,590 --> 00:24:14,270
your idea for example you want to see

00:24:11,240 --> 00:24:16,010
the type of the thing that's written

00:24:14,270 --> 00:24:19,340
done and not the type of a synthetic

00:24:16,010 --> 00:24:23,120
thing the compiler put on top of your

00:24:19,340 --> 00:24:24,330
code and this uses a pretty interesting

00:24:23,120 --> 00:24:26,039
data

00:24:24,330 --> 00:24:28,769
but I'm not going to detect because it's

00:24:26,039 --> 00:24:30,750
a bit complicated but you can see the

00:24:28,769 --> 00:24:33,600
free grammar with an explanation of this

00:24:30,750 --> 00:24:37,890
in the tasty format scarifier in the

00:24:33,600 --> 00:24:42,120
dotty repository okay cool but what can

00:24:37,890 --> 00:24:44,130
we do with that stuff so very quickly we

00:24:42,120 --> 00:24:45,899
can start with a program I have a

00:24:44,130 --> 00:24:47,850
library a which is compiled with Skylar

00:24:45,899 --> 00:24:50,039
free dot one I want to use it with graph

00:24:47,850 --> 00:24:53,240
reader - how do I do that

00:24:50,039 --> 00:24:55,799
do I wait for the offers of library a to

00:24:53,240 --> 00:24:56,340
republish it first clarify that - I can

00:24:55,799 --> 00:24:58,919
do that

00:24:56,340 --> 00:25:02,250
otherwise if I'm very impatient I could

00:24:58,919 --> 00:25:05,460
fetch you a job or a deed with class

00:25:02,250 --> 00:25:07,440
files cause very we don't matter and

00:25:05,460 --> 00:25:11,269
just regenerate them from the tasty

00:25:07,440 --> 00:25:13,559
files which are also in the jar and

00:25:11,269 --> 00:25:15,330
instead of doing that by hand you could

00:25:13,559 --> 00:25:17,010
imagine that you're built who can

00:25:15,330 --> 00:25:19,409
automatically do that in the same way

00:25:17,010 --> 00:25:22,500
that when you are working with a bit

00:25:19,409 --> 00:25:24,090
rule that works on sources it's going to

00:25:22,500 --> 00:25:26,580
automatically fetch resources and

00:25:24,090 --> 00:25:30,179
compile them and cache one for you your

00:25:26,580 --> 00:25:34,370
bill could fetch tasty and compile them

00:25:30,179 --> 00:25:37,260
and catch them for you oh and that's

00:25:34,370 --> 00:25:39,840
yeah I hadn't thought about that JSON

00:25:37,260 --> 00:25:41,370
joke proposed a few days ago you could

00:25:39,840 --> 00:25:45,090
imagine that you have something like

00:25:41,370 --> 00:25:48,600
maven or a mirror of maven that can

00:25:45,090 --> 00:25:51,179
automatically from the existing jobs

00:25:48,600 --> 00:25:53,399
published maven create new jobs with

00:25:51,179 --> 00:25:54,779
updated class files which I think would

00:25:53,399 --> 00:25:57,330
be pretty cool because it means that

00:25:54,779 --> 00:26:02,250
this would work with any bit will you

00:25:57,330 --> 00:26:04,080
want even and of course this isn't

00:26:02,250 --> 00:26:06,690
really a silver bullet this is only

00:26:04,080 --> 00:26:08,429
going to work if the standard library of

00:26:06,690 --> 00:26:10,889
video 2 is designed to be compatible

00:26:08,429 --> 00:26:12,750
with the standard library of 3.1 the

00:26:10,889 --> 00:26:15,750
kind of things that this can help with

00:26:12,750 --> 00:26:17,909
is if for example in sky Frida - we

00:26:15,750 --> 00:26:20,820
change again the encoding of traits for

00:26:17,909 --> 00:26:25,279
some weird reason or if we change any of

00:26:20,820 --> 00:26:29,250
the details of how we encode things

00:26:25,279 --> 00:26:31,980
after type checking and before and code

00:26:29,250 --> 00:26:33,240
generation so you could say ok well I

00:26:31,980 --> 00:26:36,049
could do that

00:26:33,240 --> 00:26:39,529
or I could use the source files and

00:26:36,049 --> 00:26:42,169
compile everything from source

00:26:39,529 --> 00:26:45,320
and that's pretty much the same then but

00:26:42,169 --> 00:26:47,840
it's not really the same because when

00:26:45,320 --> 00:26:49,370
you're using source files you then you

00:26:47,840 --> 00:26:50,360
don't have binary compatibility as a

00:26:49,370 --> 00:26:52,130
problem that you have sauce

00:26:50,360 --> 00:26:55,970
compatibility in particular when you

00:26:52,130 --> 00:26:58,279
upgrade calibration because the type

00:26:55,970 --> 00:27:00,940
checker evolves and because type

00:26:58,279 --> 00:27:03,440
inference is so powerful in skyrise

00:27:00,940 --> 00:27:05,330
possible sometimes at your program stops

00:27:03,440 --> 00:27:07,549
type checking does something slightly

00:27:05,330 --> 00:27:10,970
different just because type inference

00:27:07,549 --> 00:27:12,740
now works in a different way you don't

00:27:10,970 --> 00:27:14,779
have this problem when you use tasty

00:27:12,740 --> 00:27:17,000
because the taste it Rizza after type

00:27:14,779 --> 00:27:19,070
checking which means we have resolved

00:27:17,000 --> 00:27:21,770
implicit we have inferred all the types

00:27:19,070 --> 00:27:24,200
we have resolved the overload so all

00:27:21,770 --> 00:27:26,360
these kind of things which can like

00:27:24,200 --> 00:27:28,039
change depending on what the compiler

00:27:26,360 --> 00:27:33,890
decides to do with look at your world

00:27:28,039 --> 00:27:37,159
are not going to change so so tasty of

00:27:33,890 --> 00:27:38,330
course if it was just this binary format

00:27:37,159 --> 00:27:40,610
you couldn't really do anything useful

00:27:38,330 --> 00:27:42,980
with it but we have some ring around it

00:27:40,610 --> 00:27:45,200
which makes it much more useful so first

00:27:42,980 --> 00:27:47,299
we can of course it in red testify but

00:27:45,200 --> 00:27:49,130
super easy you just take dot e you

00:27:47,299 --> 00:27:50,480
compile stuff and next to your dot

00:27:49,130 --> 00:27:54,590
classifiers it's going to make dot

00:27:50,480 --> 00:27:58,309
testifies and then you can also compile

00:27:54,590 --> 00:28:00,830
from the testee files directly using -

00:27:58,309 --> 00:28:03,049
from - tasty when you run the compiler

00:28:00,830 --> 00:28:04,779
you can also different fire and the

00:28:03,049 --> 00:28:07,460
companion basically means taking the

00:28:04,779 --> 00:28:09,500
tasty trees and then pretty printing it

00:28:07,460 --> 00:28:12,770
and that can be done using the -

00:28:09,500 --> 00:28:15,049
decompile flag or just by opening the TC

00:28:12,770 --> 00:28:17,620
files in vs code when you have the dotty

00:28:15,049 --> 00:28:22,039
plug-in installed

00:28:17,620 --> 00:28:25,220
ok and so so far taystee is basically

00:28:22,039 --> 00:28:29,090
the internal format used by dotty but we

00:28:25,220 --> 00:28:31,399
have grandeur like bigger aims and that

00:28:29,090 --> 00:28:33,320
we want it to be the format for

00:28:31,399 --> 00:28:35,440
instrumental representation of oil scale

00:28:33,320 --> 00:28:38,149
and to prove that this can be done

00:28:35,440 --> 00:28:42,110
there's a proof-of-concept scale to

00:28:38,149 --> 00:28:45,200
plugin we were last year that can take a

00:28:42,110 --> 00:28:50,750
scare to trees and convert that convert

00:28:45,200 --> 00:28:51,750
them into tasty and so far it has just

00:28:50,750 --> 00:28:54,059
been a province

00:28:51,750 --> 00:28:58,409
but we'd like to like try to get this

00:28:54,059 --> 00:29:01,440
into a more user state and the main

00:28:58,409 --> 00:29:03,720
remaining technical issue to fix to do

00:29:01,440 --> 00:29:05,280
that is just to move all the logic I

00:29:03,720 --> 00:29:07,650
want testing which is currently like

00:29:05,280 --> 00:29:09,780
part of dotty itself into its own

00:29:07,650 --> 00:29:13,559
project which will cross compile between

00:29:09,780 --> 00:29:15,299
scale at Windscale free and once we have

00:29:13,559 --> 00:29:17,159
that we can also think about doing the

00:29:15,299 --> 00:29:21,090
other direction when we take dot tasty

00:29:17,159 --> 00:29:22,919
files and produce and squeeze able to

00:29:21,090 --> 00:29:26,010
understand them and we can do that that

00:29:22,919 --> 00:29:28,409
means you could use the libraries in

00:29:26,010 --> 00:29:30,720
schedule projects of course there's like

00:29:28,409 --> 00:29:32,400
a big asterisk here of the slack many

00:29:30,720 --> 00:29:33,480
things that need to be taken into

00:29:32,400 --> 00:29:35,850
account to make sure that this is

00:29:33,480 --> 00:29:40,320
possible but in principle this is

00:29:35,850 --> 00:29:42,690
something we can achieve I think okay

00:29:40,320 --> 00:29:44,909
and now that you've seen all that you

00:29:42,690 --> 00:29:48,480
might wonder okay well should I use this

00:29:44,909 --> 00:29:49,559
TC thing to build tools and the answer

00:29:48,480 --> 00:29:51,890
is like most of the time you not

00:29:49,559 --> 00:29:54,210
actually need to because there's this

00:29:51,890 --> 00:29:57,539
different but very much related thing

00:29:54,210 --> 00:29:59,190
called tests to reflect which is going

00:29:57,539 --> 00:30:02,460
to be easier to use because directly

00:29:59,190 --> 00:30:06,980
manipulating teste trees is not easy

00:30:02,460 --> 00:30:10,590
well Stacey reflect is something that

00:30:06,980 --> 00:30:12,840
men use cases replacing scalar to macros

00:30:10,590 --> 00:30:15,539
and provides an API which is similar to

00:30:12,840 --> 00:30:21,179
a to macros when you're manipulating

00:30:15,539 --> 00:30:24,210
trees using library but it can also be

00:30:21,179 --> 00:30:28,919
used for for tooling because trees but

00:30:24,210 --> 00:30:32,010
tasty reflect exposes whereas in Scala

00:30:28,919 --> 00:30:34,350
to the macro API exposed basically the

00:30:32,010 --> 00:30:35,820
compiler intern or necessary flag tries

00:30:34,350 --> 00:30:38,159
to expose something which matches the

00:30:35,820 --> 00:30:40,039
test expect which means it should be

00:30:38,159 --> 00:30:42,840
something that can be evolved and

00:30:40,039 --> 00:30:47,130
something which you can rely on for

00:30:42,840 --> 00:30:49,549
tooling in particular we wrote dot

00:30:47,130 --> 00:30:54,059
tested at Symantec DB

00:30:49,549 --> 00:30:56,039
transpire basically which works using

00:30:54,059 --> 00:30:58,380
which is implemented using test effects

00:30:56,039 --> 00:31:00,360
instead of like as a compiler phase or

00:30:58,380 --> 00:31:02,970
something which directly reads testy

00:31:00,360 --> 00:31:03,899
trees and we also have a

00:31:02,970 --> 00:31:04,650
work-in-progress

00:31:03,899 --> 00:31:07,650
implementation

00:31:04,650 --> 00:31:09,930
of which testifies and generate HTML

00:31:07,650 --> 00:31:12,180
documentation so let's get doc

00:31:09,930 --> 00:31:13,770
replacement basically and that's very

00:31:12,180 --> 00:31:15,230
interesting because if you start from

00:31:13,770 --> 00:31:18,060
tasty to generate your documentation

00:31:15,230 --> 00:31:19,860
instead of starting from sources then

00:31:18,060 --> 00:31:21,300
that makes documentation generation much

00:31:19,860 --> 00:31:24,060
faster because you don't have to type

00:31:21,300 --> 00:31:28,500
check your whole program just to be able

00:31:24,060 --> 00:31:30,750
to generate HTML and for more

00:31:28,500 --> 00:31:34,250
information you should go see an

00:31:30,750 --> 00:31:53,970
equalist or come it up running to more

00:31:34,250 --> 00:31:58,290
thank you very much so it sounds like

00:31:53,970 --> 00:32:01,170
you could take the tasty files and pack

00:31:58,290 --> 00:32:03,360
them into the jars to put up on a repo

00:32:01,170 --> 00:32:06,810
yes is that what I'm understanding so

00:32:03,360 --> 00:32:08,550
when you by default when you you can

00:32:06,810 --> 00:32:10,320
find stuff if you compile you're going

00:32:08,550 --> 00:32:11,790
to get both the class and tasty files

00:32:10,320 --> 00:32:13,800
into the same output directory and

00:32:11,790 --> 00:32:15,960
they're going to be part of a jar you

00:32:13,800 --> 00:32:19,590
that gets published okay so the second

00:32:15,960 --> 00:32:22,740
follow-on is if you can make a pretty

00:32:19,590 --> 00:32:25,710
print image of what went into the

00:32:22,740 --> 00:32:27,690
compiled code doesn't that mean that you

00:32:25,710 --> 00:32:33,060
need to do obfuscation or something to

00:32:27,690 --> 00:32:35,340
keep people's code yes so if you well so

00:32:33,060 --> 00:32:37,080
when you when you have Java bytecode you

00:32:35,340 --> 00:32:38,850
already like very close to a source and

00:32:37,080 --> 00:32:40,530
you might want to obfuscate that if you

00:32:38,850 --> 00:32:42,780
really don't want to share your code and

00:32:40,530 --> 00:32:45,150
in the same way that we've testy you

00:32:42,780 --> 00:32:47,550
could obfuscate it but that's pretty

00:32:45,150 --> 00:32:50,400
complicated instead what you could do is

00:32:47,550 --> 00:32:52,650
just and what we probably will offer is

00:32:50,400 --> 00:32:54,630
a way to to not generate the full tested

00:32:52,650 --> 00:32:56,940
face with all the implementations but

00:32:54,630 --> 00:32:59,670
just generate enough information to get

00:32:56,940 --> 00:33:02,700
types of all the methods in your program

00:32:59,670 --> 00:33:07,110
which is the bare minimum needed to do

00:33:02,700 --> 00:33:09,120
separate compilation and but that's not

00:33:07,110 --> 00:33:10,620
enough to do things like inlining where

00:33:09,120 --> 00:33:12,600
to inline a method you need to actually

00:33:10,620 --> 00:33:16,050
get the code of an effort for example

00:33:12,600 --> 00:33:17,130
but for a lot of other use cases you

00:33:16,050 --> 00:33:19,110
don't need to

00:33:17,130 --> 00:33:20,700
information of tasty and we could have a

00:33:19,110 --> 00:33:33,690
mode where the compiler doesn't generate

00:33:20,700 --> 00:33:36,390
misinformation what about the JDK

00:33:33,690 --> 00:33:39,990
I mean Scala also makes use of large

00:33:36,390 --> 00:33:48,630
Java libraries right so do you also

00:33:39,990 --> 00:33:50,760
store which version of JDK so no so it's

00:33:48,630 --> 00:33:52,890
true but if you like if you write your

00:33:50,760 --> 00:33:55,370
own library that uses a specific version

00:33:52,890 --> 00:33:58,350
like if first-class standard library

00:33:55,370 --> 00:33:59,940
suddenly is compiled with Java 12 you

00:33:58,350 --> 00:34:04,820
won't be able to use it in your project

00:33:59,940 --> 00:34:06,960
with Java 8 easily if it uses new

00:34:04,820 --> 00:34:13,980
methods which have been introduced since

00:34:06,960 --> 00:34:16,050
Java 8 we there might be a good good

00:34:13,980 --> 00:34:17,820
point that we should have a field in the

00:34:16,050 --> 00:34:20,760
testing which reference which version of

00:34:17,820 --> 00:34:22,590
the JDK we are compiling against but in

00:34:20,760 --> 00:34:25,560
general this is the same if you would

00:34:22,590 --> 00:34:27,270
have with any dependency like if you use

00:34:25,560 --> 00:34:29,639
some specific version of a dependency

00:34:27,270 --> 00:34:39,659
when everything that depends on you need

00:34:29,639 --> 00:34:41,370
to use at least this version if I'm

00:34:39,659 --> 00:34:44,070
starting a tooling project right now

00:34:41,370 --> 00:34:46,860
should I focus on taystee or semantic DB

00:34:44,070 --> 00:34:50,370
or in with your use cases should I

00:34:46,860 --> 00:34:52,409
choose one over the other it depends on

00:34:50,370 --> 00:34:55,740
what kind of treating you're interested

00:34:52,409 --> 00:34:57,180
in so the binary formats themselves are

00:34:55,740 --> 00:34:59,670
probably not what you want to focus on

00:34:57,180 --> 00:35:02,850
you want to focus on what gives me the

00:34:59,670 --> 00:35:05,700
API to do things I want to do so lacks

00:35:02,850 --> 00:35:08,070
calamita uses semantics DB as a way to

00:35:05,700 --> 00:35:10,020
store information but the interesting

00:35:08,070 --> 00:35:12,810
part is more like the API is let's

00:35:10,020 --> 00:35:17,040
commit I give you to do kristef and if

00:35:12,810 --> 00:35:17,910
this idea is are what you what works to

00:35:17,040 --> 00:35:21,120
the best for your project then you

00:35:17,910 --> 00:35:24,360
should use that if you're more

00:35:21,120 --> 00:35:26,940
interested in doing something that that

00:35:24,360 --> 00:35:28,440
can use new features of scale-free for

00:35:26,940 --> 00:35:30,390
example then

00:35:28,440 --> 00:35:41,610
maybe you can try using tests you affect

00:35:30,390 --> 00:35:44,550
instead so it depends basically in your

00:35:41,610 --> 00:35:47,070
one example you explained that you will

00:35:44,550 --> 00:35:48,930
still have this standard library

00:35:47,070 --> 00:35:52,500
compatibility issue like when you said

00:35:48,930 --> 00:35:54,840
ok I'm going to use something in 3.2

00:35:52,500 --> 00:35:56,700
yeah how is this going to be software

00:35:54,840 --> 00:36:00,360
like is it solvable or and what are you

00:35:56,700 --> 00:36:03,000
plans to do that yes oh very sure would

00:36:00,360 --> 00:36:05,400
be if if southern is color free point

00:36:03,000 --> 00:36:07,560
who decides to to change the name of a

00:36:05,400 --> 00:36:11,070
fist to something else because we didn't

00:36:07,560 --> 00:36:13,230
like the name like that but what would

00:36:11,070 --> 00:36:15,300
be very hard to to make compatible it

00:36:13,230 --> 00:36:17,940
it's not impossible to imagine some way

00:36:15,300 --> 00:36:20,370
to paper over what kind of things but I

00:36:17,940 --> 00:36:23,070
think what we'd like to do instead is

00:36:20,370 --> 00:36:27,210
just have more discipline saying ok now

00:36:23,070 --> 00:36:29,430
that we have tooling the ways to but

00:36:27,210 --> 00:36:33,240
maintaining binary compatibilities for

00:36:29,430 --> 00:36:37,170
like many years is a possibility we just

00:36:33,240 --> 00:36:40,410
need to be more strict in how we evolve

00:36:37,170 --> 00:36:44,490
this class than a library so like not

00:36:40,410 --> 00:36:50,580
redesign it every two years which I

00:36:44,490 --> 00:36:53,120
think people will also appreciate other

00:36:50,580 --> 00:36:53,120
questions

00:36:57,250 --> 00:37:03,130
you know kind of related question like

00:37:00,500 --> 00:37:05,420
if you discussed using Java nine modules

00:37:03,130 --> 00:37:07,640
mm-hmm kind of paper over that

00:37:05,420 --> 00:37:10,190
difference by just saying okay well this

00:37:07,640 --> 00:37:12,080
this module depends on Scala to 11 and

00:37:10,190 --> 00:37:14,180
this module depends on Scala to 12 and

00:37:12,080 --> 00:37:16,760
they kind of live in the same name in a

00:37:14,180 --> 00:37:19,520
namespace but yes so they use like a

00:37:16,760 --> 00:37:22,040
Java compatible API just to cool between

00:37:19,520 --> 00:37:24,020
themselves and there's no Scala yeah

00:37:22,040 --> 00:37:26,060
types exposed between them like you

00:37:24,020 --> 00:37:28,790
could kind of make that work I kind of

00:37:26,060 --> 00:37:31,580
make that work yes but it's yeah hard

00:37:28,790 --> 00:37:33,230
part is you can make like isolated

00:37:31,580 --> 00:37:35,330
things using their own class photos or

00:37:33,230 --> 00:37:37,910
whatever but then when you need them to

00:37:35,330 --> 00:37:40,040
interact it gets it gets complicated and

00:37:37,910 --> 00:37:42,110
I mean people have been trying to do

00:37:40,040 --> 00:37:45,110
that with 20 like for 20 years with like

00:37:42,110 --> 00:38:00,170
OSGi and I don't think it's it's like

00:37:45,110 --> 00:38:03,830
satisfying yet would it be like in the

00:38:00,170 --> 00:38:06,260
realm of possibilities to like use tasty

00:38:03,830 --> 00:38:07,940
as a target for Java or even other

00:38:06,260 --> 00:38:11,360
languages yeah that you could

00:38:07,940 --> 00:38:14,210
automatically you know use Java

00:38:11,360 --> 00:38:18,160
libraries and Scala GS or native stuff

00:38:14,210 --> 00:38:20,690
like that so it's it's I think it's it's

00:38:18,160 --> 00:38:22,880
possible you'd have to extend taste if

00:38:20,690 --> 00:38:24,650
somewhat maybe for some of the features

00:38:22,880 --> 00:38:26,330
of a languages that couldn't be

00:38:24,650 --> 00:38:27,760
expressed in Scala but I think it's a

00:38:26,330 --> 00:38:30,680
very interesting thing to explore

00:38:27,760 --> 00:38:33,290
because it's true that if you can leaven

00:38:30,680 --> 00:38:35,000
if you are like a long way to writer you

00:38:33,290 --> 00:38:37,460
make your own language if you can use

00:38:35,000 --> 00:38:39,530
tasty as a back-end then you get a lot

00:38:37,460 --> 00:38:43,660
of things for free you get super

00:38:39,530 --> 00:38:47,000
optimized J's back-end JVM native

00:38:43,660 --> 00:38:50,930
eventually and you can use libraries

00:38:47,000 --> 00:38:53,210
from the sky ecosystem and like to

00:38:50,930 --> 00:38:55,910
linger on Scala too so it's I think it's

00:38:53,210 --> 00:38:58,240
a very interesting thing too that could

00:38:55,910 --> 00:38:58,240
be explored

00:39:04,110 --> 00:39:10,870
so you suggested that people could or

00:39:08,110 --> 00:39:14,290
should use future scalar versions to

00:39:10,870 --> 00:39:16,750
recompile publish tasty files and does

00:39:14,290 --> 00:39:18,520
that mean the Scala compiler will need

00:39:16,750 --> 00:39:20,500
to maintain backward compatibility for

00:39:18,520 --> 00:39:21,910
this for the semantics of water tasted

00:39:20,500 --> 00:39:23,800
she will do in all possible future

00:39:21,910 --> 00:39:29,740
versions and if so does that constrain

00:39:23,800 --> 00:39:32,050
any possible yes yes tension between

00:39:29,740 --> 00:39:35,550
like evolving things and keeping

00:39:32,050 --> 00:39:40,510
compatible and that's why I pointed to

00:39:35,550 --> 00:39:42,430
Scala yes which fool like the lifetime

00:39:40,510 --> 00:39:44,380
of the zero point six series has

00:39:42,430 --> 00:39:47,350
maintained compatibility for their own

00:39:44,380 --> 00:39:50,290
internal representation while still

00:39:47,350 --> 00:39:52,270
evolving needs and yeah yeah you have to

00:39:50,290 --> 00:39:55,570
work a bit harder to be able to do this

00:39:52,270 --> 00:39:59,020
like you have to reinterpret old

00:39:55,570 --> 00:40:00,880
versions of files in the new way you you

00:39:59,020 --> 00:40:04,360
want things to be done but I think it

00:40:00,880 --> 00:40:14,500
can be done for things we want to do

00:40:04,360 --> 00:40:17,380
like to do for tasty do I understand

00:40:14,500 --> 00:40:19,180
correctly that binary compatibility is

00:40:17,380 --> 00:40:21,790
only on tasty level meaning if you have

00:40:19,180 --> 00:40:23,530
a tower library consuming your Scala

00:40:21,790 --> 00:40:26,560
library and your update you new version

00:40:23,530 --> 00:40:29,650
of scholar that it might break yeah you

00:40:26,560 --> 00:40:31,540
have a point when I say binary

00:40:29,650 --> 00:40:34,660
compatibility it's a bit weird because

00:40:31,540 --> 00:40:36,730
what does binary mean like class

00:40:34,660 --> 00:40:42,070
classifiers are binaries but taste is

00:40:36,730 --> 00:40:43,930
also binary so to be clear as we will

00:40:42,070 --> 00:40:47,200
maintain tasty compatibility but not

00:40:43,930 --> 00:40:51,060
binary compatibility but then even your

00:40:47,200 --> 00:40:54,490
Java project will be able to make use of

00:40:51,060 --> 00:40:58,360
recompile class files to what were

00:40:54,490 --> 00:41:00,010
compiled with a new version but this

00:40:58,360 --> 00:41:00,790
projects themselves will not be

00:41:00,010 --> 00:41:03,400
recompiled

00:41:00,790 --> 00:41:04,690
from DC if they don't output this unless

00:41:03,400 --> 00:41:07,660
someone next to the test

00:41:04,690 --> 00:41:09,990
Java tasty back-end for Java which will

00:41:07,660 --> 00:41:09,990
be cool

00:41:10,880 --> 00:41:18,020
I have two questions one is when we do

00:41:15,140 --> 00:41:19,970
cross compilation using SBT like you

00:41:18,020 --> 00:41:22,820
know when we want to target to say toot

00:41:19,970 --> 00:41:24,140
11.1 toon world or to those kind of

00:41:22,820 --> 00:41:26,360
things are we going to generate

00:41:24,140 --> 00:41:28,640
different testy files or it's just one

00:41:26,360 --> 00:41:32,930
testi file that's one question you know

00:41:28,640 --> 00:41:36,140
there is let's say we have run into this

00:41:32,930 --> 00:41:38,240
JDK compatibility issues right GDK

00:41:36,140 --> 00:41:41,060
classifies easy would there be a way to

00:41:38,240 --> 00:41:43,120
recover like you know let's say you use

00:41:41,060 --> 00:41:45,860
the testify land you try to compile with

00:41:43,120 --> 00:41:48,530
you know new version of Scala 3 but it

00:41:45,860 --> 00:41:50,600
uses a different version of JDK is there

00:41:48,530 --> 00:41:55,160
a way to recover from it like you know

00:41:50,600 --> 00:41:59,450
only recompile R so it really depends

00:41:55,160 --> 00:42:02,750
like if like Steve asked a solid library

00:41:59,450 --> 00:42:04,460
is compiled against a new JDK but it

00:42:02,750 --> 00:42:06,850
doesn't use any of the new features of

00:42:04,460 --> 00:42:09,050
a.j any of the new methods for example

00:42:06,850 --> 00:42:14,630
then you might still be able to

00:42:09,050 --> 00:42:16,280
recompile that to Java 8 byte code if it

00:42:14,630 --> 00:42:18,350
does use like new methods and react

00:42:16,280 --> 00:42:20,510
there's not much you can do like

00:42:18,350 --> 00:42:24,310
consumable methods that exist in the JDK

00:42:20,510 --> 00:42:27,050
version you're trying to use and

00:42:24,310 --> 00:42:29,270
therefore your first question yeah when

00:42:27,050 --> 00:42:33,350
you cross compile you'd see won't we

00:42:29,270 --> 00:42:36,890
meet two different test files if say in

00:42:33,350 --> 00:42:38,540
the new version of the compiler you you

00:42:36,890 --> 00:42:40,430
generate you have a different way of

00:42:38,540 --> 00:42:42,350
representing things like you you need

00:42:40,430 --> 00:42:46,670
somehow to store this in a in a

00:42:42,350 --> 00:42:49,250
different file and this cool this would

00:42:46,670 --> 00:42:54,260
have to well you could imagine putting

00:42:49,250 --> 00:42:56,690
everything in like one big jar and using

00:42:54,260 --> 00:42:59,060
something like what Java supports where

00:42:56,690 --> 00:43:00,860
you can put like different versions of

00:42:59,060 --> 00:43:03,590
class files in different sub directories

00:43:00,860 --> 00:43:07,400
based on the version of Java that you're

00:43:03,590 --> 00:43:09,950
using you can do like 8/8 dot class 9/8

00:43:07,400 --> 00:43:11,450
dot class in the same jar and then one

00:43:09,950 --> 00:43:14,390
of them is going to be read by Java 8

00:43:11,450 --> 00:43:16,760
and V over by Java 9 we could maybe have

00:43:14,390 --> 00:43:20,210
something similar for tasty files in a

00:43:16,760 --> 00:43:22,770
jar depending on the scale version not

00:43:20,210 --> 00:43:33,880
sure how useful that would be

00:43:22,770 --> 00:43:36,040
okay one last question how would you

00:43:33,880 --> 00:43:39,850
work with Scala features that maybe

00:43:36,040 --> 00:43:44,880
don't exist in previous versions so you

00:43:39,850 --> 00:43:48,520
have a tasty file you compile with three

00:43:44,880 --> 00:43:51,730
and you use union types but you want to

00:43:48,520 --> 00:43:56,200
use it in a 2:12 version yeah good

00:43:51,730 --> 00:43:57,820
question so reading TC from Sky to has a

00:43:56,200 --> 00:43:59,560
bunch of changes in one of them is just

00:43:57,820 --> 00:44:02,470
that they are dirty features that don't

00:43:59,560 --> 00:44:04,540
exist in sky 2 so you have to go on a

00:44:02,470 --> 00:44:07,870
case-by-case basis some of these

00:44:04,540 --> 00:44:10,720
features you can emulate some of them

00:44:07,870 --> 00:44:14,380
maybe we'll add some like the minimum

00:44:10,720 --> 00:44:16,210
amount of logic we need in like the next

00:44:14,380 --> 00:44:18,340
version of Scylla to to make them usable

00:44:16,210 --> 00:44:20,820
and some of them you just if you try to

00:44:18,340 --> 00:44:22,900
use them they just won't work like we

00:44:20,820 --> 00:44:24,490
compile which we knew like you can

00:44:22,900 --> 00:44:26,740
choose this method from schedule because

00:44:24,490 --> 00:44:30,250
it uses a match type and I don't know

00:44:26,740 --> 00:44:32,950
how to interpret match types so then a

00:44:30,250 --> 00:44:37,150
library designer when writing like the

00:44:32,950 --> 00:44:39,220
public API of their library will have to

00:44:37,150 --> 00:44:47,410
be careful to like write things which

00:44:39,220 --> 00:44:50,110
can be interpreted by boxcar 2 & 3 thank

00:44:47,410 --> 00:44:53,899
you very much thank you

00:44:50,110 --> 00:44:53,899

YouTube URL: https://www.youtube.com/watch?v=zQFjC3zLYwo


