Title: Implementing the Scala 2.13 collections - Stefan Zeiger
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/implementing-the-scala-2-13-collections
Captions: 
	00:00:00,140 --> 00:00:06,440
hi welcome to the last talk of the day I

00:00:03,659 --> 00:00:10,380
hope you got enough sleep last night

00:00:06,440 --> 00:00:13,049
this is about implementing the Scala 213

00:00:10,380 --> 00:00:15,089
collections my name is Stefan saga I'm a

00:00:13,049 --> 00:00:21,470
member of the Scala team at light band

00:00:15,089 --> 00:00:21,470
and we just released Scala 213 yesterday

00:00:26,900 --> 00:00:32,099
the major feature is the redesigned

00:00:29,490 --> 00:00:34,320
collection library the main goal was to

00:00:32,099 --> 00:00:36,840
make it easier for users with better

00:00:34,320 --> 00:00:39,870
discoverability better error messages so

00:00:36,840 --> 00:00:41,489
no more use cases in the Scala Docs no

00:00:39,870 --> 00:00:43,770
more can build from leaking out and

00:00:41,489 --> 00:00:45,390
error messages when things go wrong but

00:00:43,770 --> 00:00:47,370
it's also easier for collection

00:00:45,390 --> 00:00:50,070
implementers because it's more regular

00:00:47,370 --> 00:00:53,520
but there's still plenty of necessary

00:00:50,070 --> 00:00:56,539
complexity so I'm going to show you how

00:00:53,520 --> 00:00:58,949
to implement different collections

00:00:56,539 --> 00:01:00,270
before we get to the actual collections

00:00:58,949 --> 00:01:03,000
though I'd like to start with a type

00:01:00,270 --> 00:01:07,890
called iterable once which is not quite

00:01:03,000 --> 00:01:10,439
a collection but it can be consumed by

00:01:07,890 --> 00:01:12,030
many collection methods iterable wants

00:01:10,439 --> 00:01:15,090
basically means it has an iterator

00:01:12,030 --> 00:01:18,450
method so that's similar to iterable in

00:01:15,090 --> 00:01:21,689
Java except that in Scala with iterable

00:01:18,450 --> 00:01:24,330
once we also allow types that only allow

00:01:21,689 --> 00:01:26,640
a single traversal most importantly

00:01:24,330 --> 00:01:28,619
iterators so iterator extends iterable

00:01:26,640 --> 00:01:32,820
ones and it's iterator method just

00:01:28,619 --> 00:01:34,770
returns itself and this is a lightweight

00:01:32,820 --> 00:01:36,000
interface that doesn't have any of the

00:01:34,770 --> 00:01:37,650
additional methods that you would

00:01:36,000 --> 00:01:39,689
previously find on types like

00:01:37,650 --> 00:01:41,520
traversable ones so it can be

00:01:39,689 --> 00:01:44,549
implemented easily by non collection

00:01:41,520 --> 00:01:47,130
types in particular we now have option

00:01:44,549 --> 00:01:51,540
implementing iterable once this was not

00:01:47,130 --> 00:01:53,369
true previously so let's see what you

00:01:51,540 --> 00:01:57,090
have to do to implement iterable once

00:01:53,369 --> 00:01:59,399
yourself now this is the simplest thing

00:01:57,090 --> 00:02:01,979
you can do you just extend iterable once

00:01:59,399 --> 00:02:03,780
in this case off int and you define an

00:02:01,979 --> 00:02:08,250
iterate iterator method that's all you

00:02:03,780 --> 00:02:10,649
need to do there are two more things you

00:02:08,250 --> 00:02:13,050
might want to add though one is override

00:02:10,649 --> 00:02:13,900
known size if you do know the size

00:02:13,050 --> 00:02:15,549
because it

00:02:13,900 --> 00:02:17,860
can be used to optimize certain

00:02:15,549 --> 00:02:19,689
collection operations if you look at the

00:02:17,860 --> 00:02:21,879
bottom there's this example where I'm

00:02:19,689 --> 00:02:24,819
creating an array buffer and then adding

00:02:21,879 --> 00:02:26,110
an instance of an iterable once for

00:02:24,819 --> 00:02:27,670
three elements it doesn't really make a

00:02:26,110 --> 00:02:29,890
difference but if you have a lot of data

00:02:27,670 --> 00:02:33,159
in there the array buffer may have to

00:02:29,890 --> 00:02:35,170
regrow several times in order to fit all

00:02:33,159 --> 00:02:38,170
the data but if you overwrite known size

00:02:35,170 --> 00:02:42,129
then it will pre allocate that correct

00:02:38,170 --> 00:02:44,790
size the second thing you may want to

00:02:42,129 --> 00:02:47,560
implement or override is the stepper

00:02:44,790 --> 00:02:50,079
stepper is a type that was previously

00:02:47,560 --> 00:02:53,079
part of the Scala Java eight compat

00:02:50,079 --> 00:02:57,340
library and is now in the standard

00:02:53,079 --> 00:02:59,769
library so a stepper is basically like

00:02:57,340 --> 00:03:04,810
Java splitter a derp it allows both

00:02:59,769 --> 00:03:08,019
parallel kind consuming of iterator like

00:03:04,810 --> 00:03:12,480
things and it also allows primitive

00:03:08,019 --> 00:03:15,700
specialization for int long and double

00:03:12,480 --> 00:03:17,829
so and here we do this just by

00:03:15,700 --> 00:03:21,609
delegating to data dot stepper which

00:03:17,829 --> 00:03:23,590
gets a stepper from an array if you look

00:03:21,609 --> 00:03:26,590
at an actual usage this is something we

00:03:23,590 --> 00:03:29,019
can do this with a stepper so first we

00:03:26,590 --> 00:03:31,780
get the stepper by calling dot stepper

00:03:29,019 --> 00:03:33,879
and this is actually of type int stepper

00:03:31,780 --> 00:03:37,139
it's not just a stepper of int this

00:03:33,879 --> 00:03:39,040
explains why we need this strange

00:03:37,139 --> 00:03:41,709
functional dependency here with a

00:03:39,040 --> 00:03:43,599
stepper shape so stepper shape computes

00:03:41,709 --> 00:03:46,299
the correct stepper type for whatever

00:03:43,599 --> 00:03:47,829
element type we have that's because we

00:03:46,299 --> 00:03:50,620
need to support Javas primitive

00:03:47,829 --> 00:03:53,199
specialization so now we have an instep

00:03:50,620 --> 00:03:55,389
ER and if we call java iterator it will

00:03:53,199 --> 00:03:58,629
give us a primitive iterator of int and

00:03:55,389 --> 00:04:01,359
then when you call next this is actually

00:03:58,629 --> 00:04:04,359
a primitive int method which doesn't

00:04:01,359 --> 00:04:06,940
involve any boxing around boxing you

00:04:04,359 --> 00:04:09,099
could use the same code at the call side

00:04:06,940 --> 00:04:11,560
without overriding a stepper method but

00:04:09,099 --> 00:04:13,930
the default stepper implementation just

00:04:11,560 --> 00:04:16,449
goes through iterator so that that means

00:04:13,930 --> 00:04:23,500
it will box primitives and it will not

00:04:16,449 --> 00:04:26,750
support parallel processing okay let's

00:04:23,500 --> 00:04:28,710
move on to the real collections though

00:04:26,750 --> 00:04:31,350
let's start with something like this

00:04:28,710 --> 00:04:33,300
we're going to implement a sequence of

00:04:31,350 --> 00:04:35,580
elements with arbitrary types

00:04:33,300 --> 00:04:37,950
it's supposed to be immutable and have

00:04:35,580 --> 00:04:40,530
array like performance characteristic so

00:04:37,950 --> 00:04:42,710
it's basically immutable dot array seek

00:04:40,530 --> 00:04:45,270
which exists in the standard library

00:04:42,710 --> 00:04:48,060
well we won't do the real thing which

00:04:45,270 --> 00:04:50,460
has 450 lines of code so it might get a

00:04:48,060 --> 00:04:53,490
bit bad to read at the back of the room

00:04:50,460 --> 00:04:55,820
if I put it on a slide but the size is

00:04:53,490 --> 00:04:58,230
mainly because it supports all the

00:04:55,820 --> 00:05:00,480
manually specialized versions for

00:04:58,230 --> 00:05:02,340
primitive types we can do a simple

00:05:00,480 --> 00:05:05,490
version which just keeps its data always

00:05:02,340 --> 00:05:08,670
boxed in an array of any so we have our

00:05:05,490 --> 00:05:12,150
class my seek which extends some type

00:05:08,670 --> 00:05:17,160
and contains the data so let's see which

00:05:12,150 --> 00:05:19,620
type we should actually extend here we

00:05:17,160 --> 00:05:22,980
have a few different abstract collection

00:05:19,620 --> 00:05:25,350
types to choose from at the top level

00:05:22,980 --> 00:05:28,440
there is collection iterable that's the

00:05:25,350 --> 00:05:30,840
basic type of a collection and it is

00:05:28,440 --> 00:05:33,360
extended by immutable iterable and

00:05:30,840 --> 00:05:35,310
mutable iterable in general you do not

00:05:33,360 --> 00:05:35,730
want to extend the type like collection

00:05:35,310 --> 00:05:37,320
in araba

00:05:35,730 --> 00:05:41,060
always pick the immutable immutable

00:05:37,320 --> 00:05:44,640
version depending on which you implement

00:05:41,060 --> 00:05:46,710
at the level below we have types like

00:05:44,640 --> 00:05:48,930
Zeke and again there are three versions

00:05:46,710 --> 00:05:50,850
of Zeke there is a collection see

00:05:48,930 --> 00:05:52,980
there's an immutable Zeke and there's a

00:05:50,850 --> 00:05:55,830
mutable Zeke and it works the same way

00:05:52,980 --> 00:05:58,380
for all of these types the immutable and

00:05:55,830 --> 00:06:00,690
mutable versions always extend both

00:05:58,380 --> 00:06:02,640
they're immutable immutable parent type

00:06:00,690 --> 00:06:05,070
and their generic version in the

00:06:02,640 --> 00:06:06,750
collection package so to keep this

00:06:05,070 --> 00:06:09,510
diagram a bit simpler we are going to

00:06:06,750 --> 00:06:13,380
collapse them like this and now we can

00:06:09,510 --> 00:06:15,930
take a look at the full hierarchy we

00:06:13,380 --> 00:06:18,330
start with iterable and we have seek

00:06:15,930 --> 00:06:20,970
below it on the left and it is further

00:06:18,330 --> 00:06:24,320
divided into linear seek and indexed

00:06:20,970 --> 00:06:27,540
seek and linear seek is one that

00:06:24,320 --> 00:06:30,510
supports a an efficient tail operation

00:06:27,540 --> 00:06:33,030
and an index seek supports efficient

00:06:30,510 --> 00:06:35,580
apply and length operations so depending

00:06:33,030 --> 00:06:37,980
on how you want to consume them you may

00:06:35,580 --> 00:06:39,630
want a linear seek or index seek and of

00:06:37,980 --> 00:06:42,390
course depending on what you

00:06:39,630 --> 00:06:43,860
in your implementation you usually want

00:06:42,390 --> 00:06:46,260
to extend one of the two but it's

00:06:43,860 --> 00:06:50,040
perfectly fine to extend the generic

00:06:46,260 --> 00:06:52,530
seek to Hewlett in the mutable universe

00:06:50,040 --> 00:06:55,850
we also have mutable buffer which is a

00:06:52,530 --> 00:06:59,100
Seikh that allows growing and shrinking

00:06:55,850 --> 00:07:01,950
then next to seek we have both set and

00:06:59,100 --> 00:07:04,980
map they are based on the standard

00:07:01,950 --> 00:07:07,110
equals and hashcode contract and they

00:07:04,980 --> 00:07:09,980
are extended by sorted set and sorted

00:07:07,110 --> 00:07:14,610
map these take an additional ordering

00:07:09,980 --> 00:07:16,770
constraint and they keep their keys or

00:07:14,610 --> 00:07:20,250
elements in case of a set in this

00:07:16,770 --> 00:07:24,000
ordering map is further extended by seek

00:07:20,250 --> 00:07:25,830
map which is a map that has a seek like

00:07:24,000 --> 00:07:29,130
ordering for its key so they are by

00:07:25,830 --> 00:07:31,830
insertion order and finally we have the

00:07:29,130 --> 00:07:35,070
views there's a view type extended by

00:07:31,830 --> 00:07:36,930
seek view and map view but you don't

00:07:35,070 --> 00:07:40,170
generally extend them if you want to

00:07:36,930 --> 00:07:41,340
implement collections if anything you

00:07:40,170 --> 00:07:44,670
may use them in too in your

00:07:41,340 --> 00:07:47,340
implementations seek view and map view

00:07:44,670 --> 00:07:49,950
just add some specific operations for

00:07:47,340 --> 00:07:51,630
views that come from Zeke's or Maps you

00:07:49,950 --> 00:07:53,190
may be wondering why are they not

00:07:51,630 --> 00:07:56,130
actually Sikhs or Maps

00:07:53,190 --> 00:07:59,790
well that's because of equality equality

00:07:56,130 --> 00:08:03,420
is defined at this level so every Sikh

00:07:59,790 --> 00:08:05,790
can only be equal to another Sikh never

00:08:03,420 --> 00:08:08,880
to asset map of you even if they contain

00:08:05,790 --> 00:08:11,100
the same elements and since equality has

00:08:08,880 --> 00:08:13,380
to be transitive you cannot implement

00:08:11,100 --> 00:08:18,390
more than one of these top-level types

00:08:13,380 --> 00:08:21,630
and still get equality correct okay so

00:08:18,390 --> 00:08:25,680
the one that we want is the red one here

00:08:21,630 --> 00:08:30,600
that's in immutable index Sikh so let's

00:08:25,680 --> 00:08:33,599
do that so we add extents index seek of

00:08:30,600 --> 00:08:37,289
a and there are two methods we have to

00:08:33,599 --> 00:08:38,250
implement they are length and apply the

00:08:37,289 --> 00:08:40,500
implementations are pretty

00:08:38,250 --> 00:08:42,210
straightforward again we just forward to

00:08:40,500 --> 00:08:45,120
the array methods because we want to do

00:08:42,210 --> 00:08:46,890
the simplest possible thing here I added

00:08:45,120 --> 00:08:49,530
one other feature which is to override

00:08:46,890 --> 00:08:52,410
class name just so we get the nice

00:08:49,530 --> 00:08:53,340
output here in the console this was done

00:08:52,410 --> 00:08:55,410
with something

00:08:53,340 --> 00:08:58,230
election hack by default and previous

00:08:55,410 --> 00:09:01,680
versions but we removed that because it

00:08:58,230 --> 00:09:04,170
just leads to confusion and now with

00:09:01,680 --> 00:09:07,800
this in place you can create a new my

00:09:04,170 --> 00:09:10,350
seek and you can call for each or index

00:09:07,800 --> 00:09:13,470
where or any number of other collection

00:09:10,350 --> 00:09:17,880
operations and this already works quite

00:09:13,470 --> 00:09:19,800
well but it's it's bit ugly to create it

00:09:17,880 --> 00:09:21,630
by by calling the constructor and

00:09:19,800 --> 00:09:24,180
passing this internal data structure

00:09:21,630 --> 00:09:26,160
that you're not supposed to see so the

00:09:24,180 --> 00:09:28,770
next thing I'd like to do is to add a

00:09:26,160 --> 00:09:31,290
factory implementation every collection

00:09:28,770 --> 00:09:35,550
usually has a factory in its companion

00:09:31,290 --> 00:09:39,060
object so we have object my seek and we

00:09:35,550 --> 00:09:41,640
extend seek factory of my seek there is

00:09:39,060 --> 00:09:44,130
no specific index seek factory so we

00:09:41,640 --> 00:09:47,340
take the next best thing by going up in

00:09:44,130 --> 00:09:49,800
the hierarchy and at seek factory and a

00:09:47,340 --> 00:09:52,950
factory has to implement three methods

00:09:49,800 --> 00:09:54,750
they are empty new builder and from you

00:09:52,950 --> 00:09:57,300
will see the same pattern in many

00:09:54,750 --> 00:09:59,000
different instances further on empty

00:09:57,300 --> 00:10:01,410
just returns an empty instance and

00:09:59,000 --> 00:10:02,970
because we have an immutable collection

00:10:01,410 --> 00:10:05,700
it makes sense to always return the same

00:10:02,970 --> 00:10:08,610
one so we have a cached instance that we

00:10:05,700 --> 00:10:11,010
return then there's new builder that may

00:10:08,610 --> 00:10:13,500
be familiar to you from the Scala 212

00:10:11,010 --> 00:10:15,330
collections where you always created a

00:10:13,500 --> 00:10:17,910
builder in order to build a collection

00:10:15,330 --> 00:10:19,650
but that a strict building only it

00:10:17,910 --> 00:10:22,650
doesn't support lazy collections like

00:10:19,650 --> 00:10:24,600
stream or the new lazy list that's why

00:10:22,650 --> 00:10:27,500
we have two versions now the basic one

00:10:24,600 --> 00:10:30,510
is from which also allows lazy building

00:10:27,500 --> 00:10:32,430
imagine passing an iterator to from it

00:10:30,510 --> 00:10:34,530
takes an iterable once so you can pass

00:10:32,430 --> 00:10:36,720
any iterator and then just returning

00:10:34,530 --> 00:10:39,180
some wrapper which never consumes the

00:10:36,720 --> 00:10:41,670
iterator so this is a lazy collection

00:10:39,180 --> 00:10:43,770
this is the way you build it and now you

00:10:41,670 --> 00:10:49,020
can then later consume the iterator one

00:10:43,770 --> 00:10:51,810
by one as needed so array already has a

00:10:49,020 --> 00:10:54,980
from method so we can reuse it and we

00:10:51,810 --> 00:10:57,960
just wrap it in a my seek and we're done

00:10:54,980 --> 00:10:59,670
new builder works the same way we have

00:10:57,960 --> 00:11:01,710
to return a builder the reason why we

00:10:59,670 --> 00:11:03,570
have new builder in addition to from is

00:11:01,710 --> 00:11:05,640
because for strict collections it's

00:11:03,570 --> 00:11:07,649
usually more efficient to use a builder

00:11:05,640 --> 00:11:09,839
so you always have

00:11:07,649 --> 00:11:11,910
you could implement one in terms of the

00:11:09,839 --> 00:11:13,709
other as a default but I looked through

00:11:11,910 --> 00:11:16,949
the collection implementations actually

00:11:13,709 --> 00:11:19,410
and there is not a single case that I

00:11:16,949 --> 00:11:20,910
saw where we use this default we always

00:11:19,410 --> 00:11:23,279
overwrite them separately for

00:11:20,910 --> 00:11:26,880
performance reasons so that's what we're

00:11:23,279 --> 00:11:29,040
doing here to array has a new builder

00:11:26,880 --> 00:11:34,529
method so we reuse it and again we map

00:11:29,040 --> 00:11:38,250
the result in a new seek so let's use

00:11:34,529 --> 00:11:40,319
the factory we have the usual factory

00:11:38,250 --> 00:11:42,300
methods available out of the box just by

00:11:40,319 --> 00:11:44,790
implementing these methods we can call

00:11:42,300 --> 00:11:47,399
things like tabulate or we can use it

00:11:44,790 --> 00:11:51,649
here when converting an existing

00:11:47,399 --> 00:11:51,649
collection to a my seek so this works

00:11:51,949 --> 00:11:58,500
but not everything works we still have

00:11:55,829 --> 00:12:02,579
these two cases to deal with so one is

00:11:58,500 --> 00:12:03,930
an example of one case and the other

00:12:02,579 --> 00:12:06,060
one's a bit different we'll see the

00:12:03,930 --> 00:12:08,730
difference on the next slide we're

00:12:06,060 --> 00:12:10,860
calling filter and map here and the

00:12:08,730 --> 00:12:13,260
values you get in the result are correct

00:12:10,860 --> 00:12:16,380
that's exactly what you expect but the

00:12:13,260 --> 00:12:20,310
types are wrong so both return and index

00:12:16,380 --> 00:12:22,290
seek but not in my seek that that's what

00:12:20,310 --> 00:12:24,089
we want and the index seek is

00:12:22,290 --> 00:12:26,130
implemented by a vector that's because

00:12:24,089 --> 00:12:30,470
vector is a default implementation of

00:12:26,130 --> 00:12:34,350
the immutable index seek so why is this

00:12:30,470 --> 00:12:36,959
well we extended index seek of a and

00:12:34,350 --> 00:12:41,100
this in turn extends a trait called

00:12:36,959 --> 00:12:45,180
index seek ops and indexing Ops has

00:12:41,100 --> 00:12:48,510
these type parameters they are they're

00:12:45,180 --> 00:12:52,019
called a c c and c z is the collection

00:12:48,510 --> 00:12:54,420
constructor c is the collection type in

00:12:52,019 --> 00:12:58,110
our case the collection constructors

00:12:54,420 --> 00:13:01,529
index seek and map returns an index zeke

00:12:58,110 --> 00:13:03,839
of b and the collection type is C which

00:13:01,529 --> 00:13:08,220
is indexed seek of a so filter returns

00:13:03,839 --> 00:13:10,740
an index seek of a we always use this C

00:13:08,220 --> 00:13:12,630
type when we don't change the element

00:13:10,740 --> 00:13:14,639
type so that means when we reuse

00:13:12,630 --> 00:13:16,589
elements from the current collection to

00:13:14,639 --> 00:13:18,990
build a new collection as in filter if

00:13:16,589 --> 00:13:21,030
we have to change the element type and

00:13:18,990 --> 00:13:22,200
built some in

00:13:21,030 --> 00:13:25,740
sense of the collection with new

00:13:22,200 --> 00:13:28,500
elements we use the CC type here so what

00:13:25,740 --> 00:13:30,810
can we do to improve that well as you

00:13:28,500 --> 00:13:34,050
can see here both are covariant that's

00:13:30,810 --> 00:13:36,810
plus CC and plus C so we can override

00:13:34,050 --> 00:13:40,230
them and specify subtypes so that's

00:13:36,810 --> 00:13:43,470
exactly what we do we extend not just

00:13:40,230 --> 00:13:46,920
indexing of a but also indexing of opps

00:13:43,470 --> 00:13:49,230
of a comma my seek come on my seek of a

00:13:46,920 --> 00:13:52,860
so we're overriding the inherited

00:13:49,230 --> 00:13:55,170
versions and the compiler would complain

00:13:52,860 --> 00:13:57,000
at this point because the types no

00:13:55,170 --> 00:13:59,190
longer match so we have to implement an

00:13:57,000 --> 00:14:01,170
iterable factory which is just the

00:13:59,190 --> 00:14:05,370
factory that we previously implemented

00:14:01,170 --> 00:14:07,440
and this gives us a my seek constructor

00:14:05,370 --> 00:14:09,360
basically that's the way to build a my

00:14:07,440 --> 00:14:13,260
seek instance so this corresponds to the

00:14:09,360 --> 00:14:17,700
CC type and in order to also get the C

00:14:13,260 --> 00:14:20,730
type right we extend iterable factory

00:14:17,700 --> 00:14:23,040
defaults well we will later see how to

00:14:20,730 --> 00:14:25,260
do this manually you have to implement a

00:14:23,040 --> 00:14:30,000
few more methods for this but often the

00:14:25,260 --> 00:14:31,860
pattern is that C is just C C of a and

00:14:30,000 --> 00:14:36,270
in this case we can use a default

00:14:31,860 --> 00:14:38,510
version and now we have a fully

00:14:36,270 --> 00:14:40,560
functional collection of implementation

00:14:38,510 --> 00:14:43,530
everything that you want to do with an

00:14:40,560 --> 00:14:45,390
index seek works with this thing there's

00:14:43,530 --> 00:14:49,650
just a few more optimizations you may

00:14:45,390 --> 00:14:52,710
want to make first everything we

00:14:49,650 --> 00:14:54,570
extended so far are traits and if you

00:14:52,710 --> 00:14:56,700
extend a lot of trades you generate a

00:14:54,570 --> 00:14:59,280
lot of bytecode due to were due to the

00:14:56,700 --> 00:15:01,800
way the encoding works so we have a few

00:14:59,280 --> 00:15:03,900
abstract classes that you can reuse to

00:15:01,800 --> 00:15:05,910
reduce the bytecode size there is no

00:15:03,900 --> 00:15:07,860
abstract index seek but there is an

00:15:05,910 --> 00:15:11,240
abstract eeeek so what we can do is to

00:15:07,860 --> 00:15:13,680
extend abstract seek with index seek and

00:15:11,240 --> 00:15:16,470
then as I mentioned the default of

00:15:13,680 --> 00:15:18,270
building collections is lazy which is

00:15:16,470 --> 00:15:20,190
not always the fastest for strict

00:15:18,270 --> 00:15:23,220
collections since we're building a

00:15:20,190 --> 00:15:26,220
strict collection we have a special

00:15:23,220 --> 00:15:29,160
strict optimized trait that you can use

00:15:26,220 --> 00:15:31,770
instead so there is again no strict

00:15:29,160 --> 00:15:34,019
optimized index seek up so instead we

00:15:31,770 --> 00:15:37,259
extend index seek ops with

00:15:34,019 --> 00:15:39,480
strict optimize see cops we just use the

00:15:37,259 --> 00:15:42,660
best available one which contains the

00:15:39,480 --> 00:15:44,550
optimizations for our type and finally

00:15:42,660 --> 00:15:47,519
it would be nice to make it serializable

00:15:44,550 --> 00:15:50,759
and we have a default serializable trade

00:15:47,519 --> 00:15:53,429
that works for any standard collection

00:15:50,759 --> 00:15:54,480
kind so you get the same serialization

00:15:53,429 --> 00:15:56,309
that most of the standard library

00:15:54,480 --> 00:15:57,749
collections use there's there's nothing

00:15:56,309 --> 00:15:59,610
else you have to do about it because it

00:15:57,749 --> 00:16:01,249
just uses your factory and the iterator

00:15:59,610 --> 00:16:06,119
to perform the serialization

00:16:01,249 --> 00:16:09,239
serialization and the only thing left to

00:16:06,119 --> 00:16:11,189
do now is to optimize based on the

00:16:09,239 --> 00:16:13,709
actual collection implementation so

00:16:11,189 --> 00:16:15,809
usually you want to override some

00:16:13,709 --> 00:16:18,269
methods to make them more efficient for

00:16:15,809 --> 00:16:21,389
the data structure you implement so for

00:16:18,269 --> 00:16:23,009
example map previously in 212 there

00:16:21,389 --> 00:16:24,449
would have been some can't build from

00:16:23,009 --> 00:16:26,489
shenanigans and you need to get a

00:16:24,449 --> 00:16:28,860
builder and have some special cases in

00:16:26,489 --> 00:16:31,589
there that's all gone so the map method

00:16:28,860 --> 00:16:33,720
that you override looks exactly as you

00:16:31,589 --> 00:16:36,389
would naively write it and the

00:16:33,720 --> 00:16:39,119
implementation is it's totally

00:16:36,389 --> 00:16:42,179
straightforward yeah

00:16:39,119 --> 00:16:44,339
we this is just a simple example where

00:16:42,179 --> 00:16:46,410
we use the array to our advantage and we

00:16:44,339 --> 00:16:52,350
return in my seek in the end there's

00:16:46,410 --> 00:16:55,170
nothing special about this ok let's take

00:16:52,350 --> 00:16:58,350
a quick detour at this point and talk

00:16:55,170 --> 00:17:02,399
about collection kinds so we'll first

00:16:58,350 --> 00:17:04,380
start with kinds from type theory so in

00:17:02,399 --> 00:17:08,069
type theory kinds are used to classify

00:17:04,380 --> 00:17:11,240
types like types classify values so

00:17:08,069 --> 00:17:15,179
basically a kind is the type of a type

00:17:11,240 --> 00:17:17,250
so we have the standard or in the

00:17:15,179 --> 00:17:20,370
standard type there we have proper types

00:17:17,250 --> 00:17:24,089
which are of kind type just written as I

00:17:20,370 --> 00:17:26,909
star and that is the the kind of type

00:17:24,089 --> 00:17:31,549
that a proper value has every value in

00:17:26,909 --> 00:17:36,029
your program has a type of kind type and

00:17:31,549 --> 00:17:39,049
examples are string int but also list of

00:17:36,029 --> 00:17:42,389
int a value can have a type list event

00:17:39,049 --> 00:17:45,809
next we have you Larry type constructors

00:17:42,389 --> 00:17:47,940
of kind type 2 type these use some

00:17:45,809 --> 00:17:49,889
Haskell ID notation there's nothing

00:17:47,940 --> 00:17:52,679
specific for Scala I didn't want to

00:17:49,889 --> 00:17:55,559
invent it here this would be for example

00:17:52,679 --> 00:17:57,330
list or set or my seek that we just

00:17:55,559 --> 00:17:59,009
implemented that's a unary type

00:17:57,330 --> 00:18:02,029
constructor it takes a single type

00:17:59,009 --> 00:18:05,129
argument and then we have things like

00:18:02,029 --> 00:18:07,230
binary type constructors of type type

00:18:05,129 --> 00:18:09,299
two type two type they are written in a

00:18:07,230 --> 00:18:12,480
curried version because again it comes

00:18:09,299 --> 00:18:15,720
from Haskell like a map it takes two

00:18:12,480 --> 00:18:18,840
type parameters and produces a proper

00:18:15,720 --> 00:18:21,870
type in the end that's not quite enough

00:18:18,840 --> 00:18:24,120
for Scala those we'd have to extend it

00:18:21,870 --> 00:18:26,730
to support upper and lower bounds and

00:18:24,120 --> 00:18:29,580
variance that's something Adrienne did

00:18:26,730 --> 00:18:32,070
in this paper I'm linking here so

00:18:29,580 --> 00:18:36,080
basically we have to add an upper and a

00:18:32,070 --> 00:18:43,200
lower bound to every every proper type

00:18:36,080 --> 00:18:46,320
so like this and we have to add a kind

00:18:43,200 --> 00:18:47,909
kind annotation to the arrow this is

00:18:46,320 --> 00:18:49,799
this is really not important for what

00:18:47,909 --> 00:18:53,519
we're trying to do I'm just giving you

00:18:49,799 --> 00:18:56,009
some background here so the kind of the

00:18:53,519 --> 00:18:59,940
immutable map would have this plus arrow

00:18:56,009 --> 00:19:02,669
here because there's a plus on this type

00:18:59,940 --> 00:19:05,129
parameter and for any ref map which has

00:19:02,669 --> 00:19:07,559
a constraint that the key type must

00:19:05,129 --> 00:19:11,279
extend any ref we would see the same

00:19:07,559 --> 00:19:14,639
thing here in the kind but even these

00:19:11,279 --> 00:19:19,340
Scala extended kinds are not enough for

00:19:14,639 --> 00:19:22,259
the collection coins that we want so

00:19:19,340 --> 00:19:25,110
what we need to do mostly is track

00:19:22,259 --> 00:19:28,039
context bounds a context bound is

00:19:25,110 --> 00:19:31,200
similar to a type bound but not quite

00:19:28,039 --> 00:19:34,049
the the main difference where we deviate

00:19:31,200 --> 00:19:37,200
from the type 0 definition of a kind is

00:19:34,049 --> 00:19:41,610
that a type with a missing context bound

00:19:37,200 --> 00:19:45,480
implicit cannot be instantiated but it

00:19:41,610 --> 00:19:49,230
is still a valid type basically when you

00:19:45,480 --> 00:19:52,529
have a violation of a subtype bound on

00:19:49,230 --> 00:19:55,620
it only kind the type itself is invalid

00:19:52,529 --> 00:19:58,259
but we care not only about valid types

00:19:55,620 --> 00:20:01,650
but also about being able to instantiate

00:19:58,259 --> 00:20:04,110
these types and their values

00:20:01,650 --> 00:20:08,220
so that's why we we use this extended

00:20:04,110 --> 00:20:10,680
not quite correct definition of kinds we

00:20:08,220 --> 00:20:13,140
have a few different standard kinds that

00:20:10,680 --> 00:20:14,640
we are support in the standard library

00:20:13,140 --> 00:20:17,490
out of the box with different

00:20:14,640 --> 00:20:19,350
abstractions we've already seen iterable

00:20:17,490 --> 00:20:22,470
in our my seek implementation that's

00:20:19,350 --> 00:20:24,360
just type to type and there's both an

00:20:22,470 --> 00:20:27,120
abstract collection type for this and

00:20:24,360 --> 00:20:29,790
there is a factory type that you can use

00:20:27,120 --> 00:20:32,940
for this kind then we have map which is

00:20:29,790 --> 00:20:36,750
a binary type constructor that skipped

00:20:32,940 --> 00:20:39,480
the scary one for now let's look at

00:20:36,750 --> 00:20:41,960
sorted iterable that is really just an

00:20:39,480 --> 00:20:45,480
iterable with an additional ordering

00:20:41,960 --> 00:20:47,360
constraint on the element type so that's

00:20:45,480 --> 00:20:50,670
the context bound on the element type

00:20:47,360 --> 00:20:53,220
and now if we look again at the scary

00:20:50,670 --> 00:20:55,260
one at the evidence iterable this is

00:20:53,220 --> 00:20:58,800
really a sorted interval where we

00:20:55,260 --> 00:21:01,740
abstract over the ordering so it's not

00:20:58,800 --> 00:21:06,510
only ordering we first have to get this

00:21:01,740 --> 00:21:08,550
type in which is also of kind type to

00:21:06,510 --> 00:21:10,830
type and then we can use it as a context

00:21:08,550 --> 00:21:14,820
bond so it's a further generalization of

00:21:10,830 --> 00:21:17,850
of ordering related iterables of

00:21:14,820 --> 00:21:20,160
soldered iterables but we do not have an

00:21:17,850 --> 00:21:23,429
abstract type for that because what does

00:21:20,160 --> 00:21:28,170
it mean if a if a collection takes some

00:21:23,429 --> 00:21:30,059
arbitrary context bound for its element

00:21:28,170 --> 00:21:31,890
type it doesn't have any meaning so

00:21:30,059 --> 00:21:34,320
there cannot be an abstract collection

00:21:31,890 --> 00:21:36,690
type but we do have a factory because we

00:21:34,320 --> 00:21:40,559
know how to construct these by giving it

00:21:36,690 --> 00:21:42,480
this context bound and then next

00:21:40,559 --> 00:21:45,960
assorted iterable we have sorted map

00:21:42,480 --> 00:21:48,179
which is the same for map types with an

00:21:45,960 --> 00:21:49,370
ordering constraint and we have specific

00:21:48,179 --> 00:21:52,350
iterables

00:21:49,370 --> 00:21:55,230
for example bit set these are already

00:21:52,350 --> 00:22:01,440
proper types and they also are supported

00:21:55,230 --> 00:22:05,460
directly with a factory type so if we go

00:22:01,440 --> 00:22:08,309
back to our type hierarchy let's look at

00:22:05,460 --> 00:22:12,390
where these these kinds these collection

00:22:08,309 --> 00:22:15,179
kinds show up we see them here but

00:22:12,390 --> 00:22:17,249
there's an inheritance hierarchy here so

00:22:15,179 --> 00:22:20,820
what does that mean well it means that

00:22:17,249 --> 00:22:22,950
every map is not just a kind map it is

00:22:20,820 --> 00:22:26,279
also of kind iterable because it extends

00:22:22,950 --> 00:22:28,649
iterable and every sorted map is not

00:22:26,279 --> 00:22:31,589
just of kind sorted map it is of kind

00:22:28,649 --> 00:22:33,839
sorted map it is of kind map and it is

00:22:31,589 --> 00:22:36,479
of kind iterable we have to implement

00:22:33,839 --> 00:22:39,869
all the different kinds for it for these

00:22:36,479 --> 00:22:44,519
collection types so how how would we do

00:22:39,869 --> 00:22:46,440
this well it goes back to the CC types

00:22:44,519 --> 00:22:48,629
to the collection constructors that we

00:22:46,440 --> 00:22:50,969
use because these are different for the

00:22:48,629 --> 00:22:53,669
different kinds and the way we do this

00:22:50,969 --> 00:22:55,499
is by having separate ones for each kind

00:22:53,669 --> 00:22:58,049
so if you look at the definition of map

00:22:55,499 --> 00:23:03,359
ops here slightly simplified it's it

00:22:58,049 --> 00:23:05,549
takes a CC type parameter which has two

00:23:03,359 --> 00:23:06,960
type parameters itself it's a binary

00:23:05,549 --> 00:23:11,849
type constructor here

00:23:06,960 --> 00:23:15,450
that's our map CC but the CC it passes

00:23:11,849 --> 00:23:18,210
on to iterable ops is not this CC that's

00:23:15,450 --> 00:23:21,509
just adorable so these are separate CC

00:23:18,210 --> 00:23:25,229
types for each kind the same for sorted

00:23:21,509 --> 00:23:29,869
map ops it takes a CC but the one it

00:23:25,229 --> 00:23:29,869
passes on to map ops is just map

00:23:29,960 --> 00:23:35,159
generally you don't care about these

00:23:32,219 --> 00:23:37,679
inherited ones you only ever want to

00:23:35,159 --> 00:23:39,690
refine the most concrete one but you

00:23:37,679 --> 00:23:42,259
could refine all of them if if that's

00:23:39,690 --> 00:23:44,879
what you need in your collection so

00:23:42,259 --> 00:23:47,399
maybe it becomes clearer if you if we

00:23:44,879 --> 00:23:50,779
look at an actual implementation so the

00:23:47,399 --> 00:23:53,159
simplest one we can do here is a map

00:23:50,779 --> 00:23:56,580
let's start with the factory this time

00:23:53,159 --> 00:23:58,889
there's a special map factory type and

00:23:56,580 --> 00:24:00,509
the implementation looks very much the

00:23:58,889 --> 00:24:02,249
same as the other factory that we've

00:24:00,509 --> 00:24:04,169
implemented there's really only one

00:24:02,249 --> 00:24:06,960
difference here the three methods we

00:24:04,169 --> 00:24:09,089
have to implement empty from a new

00:24:06,960 --> 00:24:10,799
builder now take two type parameters

00:24:09,089 --> 00:24:13,019
that's the only difference

00:24:10,799 --> 00:24:15,529
what they do is exactly the same and we

00:24:13,019 --> 00:24:19,169
implement them in the same way basically

00:24:15,529 --> 00:24:20,789
there's also a custom builder

00:24:19,169 --> 00:24:22,579
implementation that I wrote to you just

00:24:20,789 --> 00:24:24,749
because there there wasn't anything

00:24:22,579 --> 00:24:27,659
really fast enough in the standard

00:24:24,749 --> 00:24:28,740
library to reuse so these are all also

00:24:27,659 --> 00:24:30,600
pretty simple to write

00:24:28,740 --> 00:24:32,490
in a few lines of code but the main

00:24:30,600 --> 00:24:34,500
takeaway here is that these factories

00:24:32,490 --> 00:24:36,929
all look the same except for the

00:24:34,500 --> 00:24:38,910
parameters if we were to implement a

00:24:36,929 --> 00:24:41,910
sorted map factory it would again be the

00:24:38,910 --> 00:24:48,390
same just with a an ordering constraint

00:24:41,910 --> 00:24:53,400
on all these K types so if we look at

00:24:48,390 --> 00:24:56,300
the actual collection class my map what

00:24:53,400 --> 00:24:59,910
I'm doing here is its wrapping a mutable

00:24:56,300 --> 00:25:01,920
Java hash map in an immutable Scala

00:24:59,910 --> 00:25:03,450
collection it's not something you want

00:25:01,920 --> 00:25:05,820
to do in practice usually for

00:25:03,450 --> 00:25:10,110
performance reasons but it's easy to

00:25:05,820 --> 00:25:14,460
implement so we extend some abstract map

00:25:10,110 --> 00:25:18,059
type we mix in strict optimized map ops

00:25:14,460 --> 00:25:21,960
which has key and value type parameters

00:25:18,059 --> 00:25:25,500
it has a cc type the one for map and it

00:25:21,960 --> 00:25:29,130
has AC type my map of the key and value

00:25:25,500 --> 00:25:31,020
type the same basically as my seek just

00:25:29,130 --> 00:25:33,720
with the to time type parameters instead

00:25:31,020 --> 00:25:35,790
of one we also extend map factory

00:25:33,720 --> 00:25:38,970
defaults because again we have this

00:25:35,790 --> 00:25:44,580
relationship we have my map of K comma V

00:25:38,970 --> 00:25:47,520
for my map and K and V so all we have to

00:25:44,580 --> 00:25:49,950
do is implement override a map factory

00:25:47,520 --> 00:25:52,080
method you'll notice that this is now a

00:25:49,950 --> 00:25:55,290
map factory it's not a durable factory

00:25:52,080 --> 00:25:57,450
this was a was a bit tricky in the old

00:25:55,290 --> 00:26:01,920
collections because they didn't have any

00:25:57,450 --> 00:26:03,809
factory abstractions in this way for for

00:26:01,920 --> 00:26:05,940
collections that are not of iterable

00:26:03,809 --> 00:26:08,040
kind now we have them so we do not

00:26:05,940 --> 00:26:10,020
override iterable factory in fact we

00:26:08,040 --> 00:26:12,360
inherit this one the one I commented out

00:26:10,020 --> 00:26:15,390
is the one we inherit iterable factory

00:26:12,360 --> 00:26:18,000
is just immutable iterable because we do

00:26:15,390 --> 00:26:20,880
not change the iterable CC type here we

00:26:18,000 --> 00:26:27,780
only change the map CC type so we

00:26:20,880 --> 00:26:30,540
overwrite map factory for the actual

00:26:27,780 --> 00:26:32,580
implementation there are four methods we

00:26:30,540 --> 00:26:34,320
need for the map you need to get an

00:26:32,580 --> 00:26:36,929
iterator then there is a gap method

00:26:34,320 --> 00:26:39,419
which returns a value there's a remove

00:26:36,929 --> 00:26:41,790
method that creates a new map

00:26:39,419 --> 00:26:42,269
implementation without that value and an

00:26:41,790 --> 00:26:44,849
update

00:26:42,269 --> 00:26:47,549
a method that creates a new map with a

00:26:44,849 --> 00:26:52,099
new binding the implementation here is

00:26:47,549 --> 00:26:52,099
fairly straightforward and uninteresting

00:26:53,659 --> 00:27:00,029
instead let's look at how you would

00:26:56,399 --> 00:27:01,889
override methods for performance so I

00:27:00,029 --> 00:27:05,580
showed you earlier that we overrode the

00:27:01,889 --> 00:27:07,679
map method in my seek with a custom

00:27:05,580 --> 00:27:10,830
implementation so we can do the same for

00:27:07,679 --> 00:27:12,929
my map except there are now two map

00:27:10,830 --> 00:27:14,879
methods and that's because we implement

00:27:12,929 --> 00:27:17,519
two different collection kinds so we

00:27:14,879 --> 00:27:20,789
have to map map map methods the first

00:27:17,519 --> 00:27:22,889
one is the one from a map ops it takes

00:27:20,789 --> 00:27:25,229
both a key and a value type parameter

00:27:22,889 --> 00:27:27,779
and and it applies whenever your mapping

00:27:25,229 --> 00:27:29,820
returns another key value pair because

00:27:27,779 --> 00:27:32,609
then you want to get another map back in

00:27:29,820 --> 00:27:34,889
this case in my map the second one

00:27:32,609 --> 00:27:37,409
applies when you return something else

00:27:34,889 --> 00:27:39,179
that is not a key value pair and then

00:27:37,409 --> 00:27:41,779
you just built the iterable that's the

00:27:39,179 --> 00:27:44,849
map method we inherit from iterable ops

00:27:41,779 --> 00:27:47,070
if you override one you generally should

00:27:44,849 --> 00:27:50,089
override the others and just called

00:27:47,070 --> 00:27:52,919
super that's because of the way implicit

00:27:50,089 --> 00:27:54,809
overload resolution works so the

00:27:52,919 --> 00:27:56,339
compiler might otherwise get confused

00:27:54,809 --> 00:27:57,570
which one you want to call when they

00:27:56,339 --> 00:27:59,639
come from different points in the

00:27:57,570 --> 00:28:02,579
hierarchy so it's always best to

00:27:59,639 --> 00:28:03,929
override all of them and only in one of

00:28:02,579 --> 00:28:08,119
these you would put your actual

00:28:03,929 --> 00:28:10,259
implementation and this applies to

00:28:08,119 --> 00:28:13,320
generally to all the methods that return

00:28:10,259 --> 00:28:15,570
ACC because we have different CC types

00:28:13,320 --> 00:28:18,209
at the different levels any method that

00:28:15,570 --> 00:28:19,919
returns ACC will be overloaded at that

00:28:18,209 --> 00:28:22,440
level the most important ones that you

00:28:19,919 --> 00:28:25,169
see in the in the standard collection

00:28:22,440 --> 00:28:27,239
ops traits or map flatmap collect and

00:28:25,169 --> 00:28:34,019
concat so these are the ones you usually

00:28:27,239 --> 00:28:36,179
want to overwrite in this way so what

00:28:34,019 --> 00:28:38,099
about non-standard collection kinds I've

00:28:36,179 --> 00:28:39,479
shown you a few of the standard ones but

00:28:38,099 --> 00:28:42,119
maybe you want something completely

00:28:39,479 --> 00:28:43,979
different and you wouldn't be the first

00:28:42,119 --> 00:28:46,139
one to want that because we even have

00:28:43,979 --> 00:28:48,809
them in the standard library they're

00:28:46,139 --> 00:28:51,269
just not worth adding any abstractions

00:28:48,809 --> 00:28:52,969
for them but these are just individual

00:28:51,269 --> 00:28:55,800
implementations of collections that

00:28:52,969 --> 00:28:58,830
support even other other kinds

00:28:55,800 --> 00:29:01,770
the first one is any ref map which is a

00:28:58,830 --> 00:29:06,120
map whose key type must be a subtype of

00:29:01,770 --> 00:29:09,059
any ref so if you recall the slide about

00:29:06,120 --> 00:29:12,570
the extended scala types we have to take

00:29:09,059 --> 00:29:14,370
the this this super type and subtype

00:29:12,570 --> 00:29:17,880
constraints into account so it's a

00:29:14,370 --> 00:29:20,400
different kind so we need something more

00:29:17,880 --> 00:29:23,070
specific than just map for it there's

00:29:20,400 --> 00:29:25,350
also int map and long map which are maps

00:29:23,070 --> 00:29:27,480
that have int or long respectively as

00:29:25,350 --> 00:29:30,600
their key types and you only can can

00:29:27,480 --> 00:29:33,600
only parameterize the values then we

00:29:30,600 --> 00:29:36,780
have bit set which is always a set of

00:29:33,600 --> 00:29:38,760
int sounds simple enough as a as an

00:29:36,780 --> 00:29:39,420
implementation but we'll get back to

00:29:38,760 --> 00:29:42,120
that in a minute

00:29:39,420 --> 00:29:45,210
and finally there's collision proof hash

00:29:42,120 --> 00:29:52,080
map that's a new map implementation in

00:29:45,210 --> 00:29:57,300
Scala 213 which uses an ordering to to

00:29:52,080 --> 00:30:02,220
combat excessively bad performance in in

00:29:57,300 --> 00:30:05,460
case of of hash collision attacks that's

00:30:02,220 --> 00:30:06,510
something that can happen in the 212 map

00:30:05,460 --> 00:30:08,610
implementations

00:30:06,510 --> 00:30:11,700
if someone produces deliberate hash

00:30:08,610 --> 00:30:13,770
collisions you get bad performance in a

00:30:11,700 --> 00:30:16,470
hash map so this can be used as an

00:30:13,770 --> 00:30:19,920
attack vector vector the sky that Java

00:30:16,470 --> 00:30:22,200
hash map has a clever hack for that it

00:30:19,920 --> 00:30:24,900
it checks if the type implements

00:30:22,200 --> 00:30:28,740
comparable and then further checks with

00:30:24,900 --> 00:30:30,840
some reflection magic if it's comparable

00:30:28,740 --> 00:30:32,670
to itself and then it performs this

00:30:30,840 --> 00:30:35,700
optimization just hoping for the best

00:30:32,670 --> 00:30:38,640
basically but in scala we have ordering

00:30:35,700 --> 00:30:41,010
as a type class and generally you don't

00:30:38,640 --> 00:30:43,380
implement comparable so this wouldn't

00:30:41,010 --> 00:30:47,309
work for your custom type so and instead

00:30:43,380 --> 00:30:50,880
what we do is you get a map that has an

00:30:47,309 --> 00:30:54,120
ordering context bound for the key type

00:30:50,880 --> 00:30:55,410
but it is not a sorted map that that's

00:30:54,120 --> 00:30:56,760
the main takeaway here

00:30:55,410 --> 00:30:59,010
it needs the ordering constraint but

00:30:56,760 --> 00:31:00,600
it's not a sorted map so it cannot use

00:30:59,010 --> 00:31:04,440
the standard abstractions for sorted

00:31:00,600 --> 00:31:07,260
maps I don't want you to show I want to

00:31:04,440 --> 00:31:09,160
show you any any full implementations

00:31:07,260 --> 00:31:11,500
for these types

00:31:09,160 --> 00:31:13,300
we're just going to look at individual

00:31:11,500 --> 00:31:15,370
features they are mostly the same

00:31:13,300 --> 00:31:17,770
problems you will encounter in all of

00:31:15,370 --> 00:31:18,670
these but it's easier to see in some

00:31:17,770 --> 00:31:22,150
than in others

00:31:18,670 --> 00:31:25,440
let's start with immutable bit set so

00:31:22,150 --> 00:31:29,830
you can see we extend strict optimized

00:31:25,440 --> 00:31:32,680
sorted set ups and the CC type is sorted

00:31:29,830 --> 00:31:35,530
set and the C type is bit set it is not

00:31:32,680 --> 00:31:38,620
sorted set of int because if you map

00:31:35,530 --> 00:31:40,540
from a bit set and return int values it

00:31:38,620 --> 00:31:42,940
would be nice to produce another bit set

00:31:40,540 --> 00:31:47,770
as the results that's what all this can

00:31:42,940 --> 00:31:50,590
build from magic did in 212 so that

00:31:47,770 --> 00:31:53,500
means there is no factory default Strait

00:31:50,590 --> 00:31:55,240
the factory defaults traits are only

00:31:53,500 --> 00:31:58,990
available if you have this

00:31:55,240 --> 00:32:02,440
correspondence that C equals CC of a so

00:31:58,990 --> 00:32:05,790
what we do instead is to implement a way

00:32:02,440 --> 00:32:08,770
to produce a bit set the C type directly

00:32:05,790 --> 00:32:10,930
again there are three methods and they

00:32:08,770 --> 00:32:13,240
should be rather familiar to you they

00:32:10,930 --> 00:32:14,830
were empty from specific and new

00:32:13,240 --> 00:32:16,960
specific builder it's basically a

00:32:14,830 --> 00:32:20,710
factory for the C type that we have to

00:32:16,960 --> 00:32:22,570
implement and we're doing this similarly

00:32:20,710 --> 00:32:24,940
to the other collections by having a

00:32:22,570 --> 00:32:26,620
bits at factory but that's not an

00:32:24,940 --> 00:32:29,500
override and we're not implementing

00:32:26,620 --> 00:32:31,390
anything that's that's just a convenient

00:32:29,500 --> 00:32:36,160
way of writing it and then we're

00:32:31,390 --> 00:32:38,200
delegating to this factory but if you

00:32:36,160 --> 00:32:40,300
forget about those or what the exact

00:32:38,200 --> 00:32:43,120
signatures are the compiler will tell

00:32:40,300 --> 00:32:47,140
you we've a previously in a state in

00:32:43,120 --> 00:32:49,450
like 212 milestone 4 or 5 where we had

00:32:47,140 --> 00:32:51,190
some extra track abstractions we could

00:32:49,450 --> 00:32:53,410
actually forget this and you to some

00:32:51,190 --> 00:32:55,180
unsoundness in the compiler it wouldn't

00:32:53,410 --> 00:32:57,190
tell you that you forgot to implement

00:32:55,180 --> 00:32:59,440
them so we changed that there's a bit

00:32:57,190 --> 00:33:01,690
more boilerplate now but it is safe the

00:32:59,440 --> 00:33:03,430
compiler will tell you when you forget

00:33:01,690 --> 00:33:09,520
this just like it will tell you when you

00:33:03,430 --> 00:33:11,590
forget to over at the factory so let's

00:33:09,520 --> 00:33:13,930
move on to the collision proof hash map

00:33:11,590 --> 00:33:17,170
as I mentioned it requires an ordering

00:33:13,930 --> 00:33:21,690
for the key type but it is not a sorted

00:33:17,170 --> 00:33:25,340
map but we still add a sorted map

00:33:21,690 --> 00:33:29,730
to rehear and that's perfectly fine

00:33:25,340 --> 00:33:31,650
we only extend map ops with map so it's

00:33:29,730 --> 00:33:33,990
there's no sorted map ups to be seen

00:33:31,650 --> 00:33:36,390
anywhere but we can use the factory

00:33:33,990 --> 00:33:38,550
because the factory just cares about how

00:33:36,390 --> 00:33:40,350
to build this and in order to build this

00:33:38,550 --> 00:33:42,660
you need to give it an ordering for the

00:33:40,350 --> 00:33:44,640
key type the same as for a sorted map

00:33:42,660 --> 00:33:47,280
this there's nothing really starting

00:33:44,640 --> 00:33:57,180
specific in the factory type so we reuse

00:33:47,280 --> 00:34:02,670
it here in int map we can see it extends

00:33:57,180 --> 00:34:05,940
strict optimized map ops of int comity

00:34:02,670 --> 00:34:07,680
comma map comma int map of T so of

00:34:05,940 --> 00:34:10,950
course we have the same same problem

00:34:07,680 --> 00:34:13,260
again with the was a default straight we

00:34:10,950 --> 00:34:14,640
have to implement our our three factory

00:34:13,260 --> 00:34:16,830
methods are not showing them here

00:34:14,640 --> 00:34:20,400
instead what I want to show is yet

00:34:16,830 --> 00:34:23,610
another map method because if you call

00:34:20,400 --> 00:34:27,870
map on an int map and you return a pair

00:34:23,610 --> 00:34:30,210
whose first element is another int so

00:34:27,870 --> 00:34:32,760
this thing here it would be nice to

00:34:30,210 --> 00:34:36,810
return another int map and not just a

00:34:32,760 --> 00:34:38,580
map so again we override we overload it

00:34:36,810 --> 00:34:41,250
you that's another overloading of the

00:34:38,580 --> 00:34:44,460
map method being already inherit the

00:34:41,250 --> 00:34:46,169
other two ones from map and and iterable

00:34:44,460 --> 00:34:47,940
and we can overload it again this is

00:34:46,169 --> 00:34:49,850
something you would have avoided in in

00:34:47,940 --> 00:34:52,320
earlier Scala versions mainly because

00:34:49,850 --> 00:34:55,080
type inference just didn't work for

00:34:52,320 --> 00:34:57,060
these overloaded methods you would have

00:34:55,080 --> 00:34:59,220
to annotate every call side with the

00:34:57,060 --> 00:35:01,890
precise type so you never did this kind

00:34:59,220 --> 00:35:04,260
of code but we greatly improved overload

00:35:01,890 --> 00:35:06,450
resolution in Scala 2:13 so you can

00:35:04,260 --> 00:35:11,030
easily do things like that and have the

00:35:06,450 --> 00:35:14,250
compiler figure out all the types and

00:35:11,030 --> 00:35:16,560
the implementation is something you will

00:35:14,250 --> 00:35:19,080
commonly see if you if you write these

00:35:16,560 --> 00:35:22,140
abstractions this is basically the base

00:35:19,080 --> 00:35:23,760
line implementation of most methods in

00:35:22,140 --> 00:35:26,460
the library at least the ones that are

00:35:23,760 --> 00:35:29,730
not specific to strict collections you

00:35:26,460 --> 00:35:31,800
create a view for the operation which

00:35:29,730 --> 00:35:33,390
works because we already have this

00:35:31,800 --> 00:35:35,440
operation we already have map

00:35:33,390 --> 00:35:38,140
implementations so there is a map

00:35:35,440 --> 00:35:40,120
for that so we just wrapped this in a

00:35:38,140 --> 00:35:43,450
view like the view figure out how to do

00:35:40,120 --> 00:35:45,730
the map and then use this int map from

00:35:43,450 --> 00:35:48,580
method that we provide here to build our

00:35:45,730 --> 00:35:50,620
intimate from the view of course you can

00:35:48,580 --> 00:35:53,140
optimize it further but this is a

00:35:50,620 --> 00:35:55,540
reasonable default just just to get the

00:35:53,140 --> 00:36:03,000
basic signature in there and to make it

00:35:55,540 --> 00:36:06,640
work and here's the info Factory the

00:36:03,000 --> 00:36:08,140
most interesting part about it so far is

00:36:06,640 --> 00:36:11,110
actually that the it's not really

00:36:08,140 --> 00:36:14,290
interesting it doesn't extend anything

00:36:11,110 --> 00:36:16,900
it's just a simple object there is no

00:36:14,290 --> 00:36:19,150
abstraction for building an int map that

00:36:16,900 --> 00:36:21,280
the type theoretic kind of it is the

00:36:19,150 --> 00:36:23,340
same as if us for iterable but of course

00:36:21,280 --> 00:36:26,980
building it works differently you need

00:36:23,340 --> 00:36:28,870
pairs of int and that other type to

00:36:26,980 --> 00:36:31,240
build an intimate and we don't have a

00:36:28,870 --> 00:36:32,920
factory time for that so you can just

00:36:31,240 --> 00:36:35,620
implement whatever you want you build

00:36:32,920 --> 00:36:38,560
your own factory here we have the usual

00:36:35,620 --> 00:36:40,060
methods methods to to make it look like

00:36:38,560 --> 00:36:41,590
the other factories so that's what you

00:36:40,060 --> 00:36:44,250
generally do but you're free to do

00:36:41,590 --> 00:36:44,250
whatever you want

00:36:44,880 --> 00:36:52,090
there's one piece that's missing though

00:36:48,070 --> 00:36:54,400
because well if you went to the keynote

00:36:52,090 --> 00:36:58,660
yesterday Martin told you there is no

00:36:54,400 --> 00:37:02,560
more can build from in Scala to 13 he is

00:36:58,660 --> 00:37:07,150
technically correct there are actually

00:37:02,560 --> 00:37:10,330
two of them now and they are called

00:37:07,150 --> 00:37:12,070
built from and factory but having to

00:37:10,330 --> 00:37:15,340
some sounds worse but it's actually

00:37:12,070 --> 00:37:17,940
better because you have one axis here

00:37:15,340 --> 00:37:20,740
you have one axis here for these two and

00:37:17,940 --> 00:37:22,900
can build from previously gave you all

00:37:20,740 --> 00:37:24,840
this area in between and all that has

00:37:22,900 --> 00:37:28,390
gone away all the complexity in there

00:37:24,840 --> 00:37:30,760
now we only have factory to build to

00:37:28,390 --> 00:37:34,030
enable building driven by a static type

00:37:30,760 --> 00:37:36,100
and built from for collection building

00:37:34,030 --> 00:37:37,510
driven by a dynamic type well you

00:37:36,100 --> 00:37:40,270
already have an instance of that

00:37:37,510 --> 00:37:44,470
collection and you want something of the

00:37:40,270 --> 00:37:47,290
same dynamic type for a concrete

00:37:44,470 --> 00:37:49,150
collection implementation so not for

00:37:47,290 --> 00:37:50,980
defining new abstractions

00:37:49,150 --> 00:37:52,990
this doesn't really make a difference

00:37:50,980 --> 00:37:55,120
because if you if you have a concrete

00:37:52,990 --> 00:37:58,240
collection type then static and dynamic

00:37:55,120 --> 00:38:00,040
type are the same so it's just the same

00:37:58,240 --> 00:38:04,810
boilerplate you have to write twice for

00:38:00,040 --> 00:38:07,560
both of them and not having can build

00:38:04,810 --> 00:38:10,120
from is also correct in the sense that

00:38:07,560 --> 00:38:13,120
all of the methods we've seen so far

00:38:10,120 --> 00:38:16,840
have not used can build from you will

00:38:13,120 --> 00:38:18,550
will only find one or two methods maybe

00:38:16,840 --> 00:38:21,070
in the whole collections library that

00:38:18,550 --> 00:38:25,690
that use these types they are very rare

00:38:21,070 --> 00:38:27,730
and only used in corner cases both of

00:38:25,690 --> 00:38:30,610
them have two different ways of using

00:38:27,730 --> 00:38:33,130
them one is by an implicit conversion of

00:38:30,610 --> 00:38:36,160
the companion object which sounds

00:38:33,130 --> 00:38:39,070
strange at first but it's quite natural

00:38:36,160 --> 00:38:42,370
and you've already seen it used so the

00:38:39,070 --> 00:38:44,020
typical one for Factory is this you have

00:38:42,370 --> 00:38:47,320
an existing collection and you call the

00:38:44,020 --> 00:38:49,990
two method on it and you just pass some

00:38:47,320 --> 00:38:51,610
other companion object and this works

00:38:49,990 --> 00:38:53,890
for an Internet even though internet

00:38:51,610 --> 00:38:56,200
doesn't extend any of the standard

00:38:53,890 --> 00:38:58,120
collection factory types and it works

00:38:56,200 --> 00:39:00,580
because int map provides an implicit

00:38:58,120 --> 00:39:04,180
conversion to factory from this object

00:39:00,580 --> 00:39:06,910
and the other way of using it is with an

00:39:04,180 --> 00:39:09,610
implicit instance for the type I have

00:39:06,910 --> 00:39:11,110
written implicitly here just to show you

00:39:09,610 --> 00:39:13,980
how it works so the conjuring up a

00:39:11,110 --> 00:39:16,480
factory from int to list of int I'm

00:39:13,980 --> 00:39:19,090
writing implicit implicitly because

00:39:16,480 --> 00:39:20,800
there is not a single abstraction in the

00:39:19,090 --> 00:39:23,260
standard library that actually uses this

00:39:20,800 --> 00:39:26,530
but you can't use it in your own code if

00:39:23,260 --> 00:39:28,660
you want to this can be useful for stuff

00:39:26,530 --> 00:39:30,910
like type driven serialization or D

00:39:28,660 --> 00:39:34,960
serialization that's that's the use

00:39:30,910 --> 00:39:37,090
cases we had in mind and then future are

00:39:34,960 --> 00:39:39,730
built from is is actually used typically

00:39:37,090 --> 00:39:43,420
in this way the main use case is for

00:39:39,730 --> 00:39:46,420
future dot sequence so we have an

00:39:43,420 --> 00:39:48,370
iterable of future of int and this

00:39:46,420 --> 00:39:51,340
iterable could be anything it could be a

00:39:48,370 --> 00:39:53,350
vector or list may be and if you call

00:39:51,340 --> 00:39:55,570
future dot sequence you will get a

00:39:53,350 --> 00:39:57,820
future of iterable off and it just swaps

00:39:55,570 --> 00:39:59,020
the two type constructors and it would

00:39:57,820 --> 00:40:01,330
be nice to have the actual

00:39:59,020 --> 00:40:02,160
implementation of those iterables be the

00:40:01,330 --> 00:40:04,440
same as the

00:40:02,160 --> 00:40:06,150
you put in even though statically you

00:40:04,440 --> 00:40:08,880
only know that it's an inner upper and

00:40:06,150 --> 00:40:11,040
that's what built from thus so if you

00:40:08,880 --> 00:40:14,850
put in a list of future event you will

00:40:11,040 --> 00:40:19,140
get out a future of list of end not

00:40:14,850 --> 00:40:21,000
statically but at runtime what you can

00:40:19,140 --> 00:40:23,970
also do is rely on the implicit

00:40:21,000 --> 00:40:26,520
conversion of the companion object and

00:40:23,970 --> 00:40:28,950
just append this so this is usually the

00:40:26,520 --> 00:40:31,260
implicit parameter here and it's that

00:40:28,950 --> 00:40:33,590
we're passing a list so that means build

00:40:31,260 --> 00:40:35,970
a list that's the replacement for

00:40:33,590 --> 00:40:38,610
collection that break out that you may

00:40:35,970 --> 00:40:40,770
have used in 212 but it only works in

00:40:38,610 --> 00:40:44,480
these very specific cases like future

00:40:40,770 --> 00:40:44,480
dot sequence where it is actually used

00:40:46,040 --> 00:40:52,620
so here's our in map Factory that this

00:40:50,460 --> 00:40:56,100
looks like a lot of code and and it is

00:40:52,620 --> 00:40:59,970
but it's boilerplate so there is not

00:40:56,100 --> 00:41:02,070
much to it what we have is a factory we

00:40:59,970 --> 00:41:04,020
can just use a singleton object here

00:41:02,070 --> 00:41:07,020
that we cast to whatever type we need

00:41:04,020 --> 00:41:08,490
and again it has the same methods that

00:41:07,020 --> 00:41:11,130
we've already seen there's a from

00:41:08,490 --> 00:41:14,100
specific and there is a new builder

00:41:11,130 --> 00:41:16,610
method that we implement and both are

00:41:14,100 --> 00:41:20,730
straightforward and then we have an

00:41:16,610 --> 00:41:23,280
iterable factory method that returns any

00:41:20,730 --> 00:41:25,920
an implicit factory for whatever type

00:41:23,280 --> 00:41:28,710
and we have a two factory method that

00:41:25,920 --> 00:41:32,880
takes as a dummy parameter this object

00:41:28,710 --> 00:41:35,490
itself and converts it to that type so

00:41:32,880 --> 00:41:37,260
this wires a factory and then we have

00:41:35,490 --> 00:41:40,500
exactly the same thing again for built

00:41:37,260 --> 00:41:43,140
from the only difference here is really

00:41:40,500 --> 00:41:46,110
that this these methods

00:41:43,140 --> 00:41:48,480
additionally take if from parameter but

00:41:46,110 --> 00:41:50,250
we don't use it anywhere because we

00:41:48,480 --> 00:41:52,020
don't care about the object because the

00:41:50,250 --> 00:41:54,660
static and dynamic type are always the

00:41:52,020 --> 00:41:59,610
same so the implementations are the same

00:41:54,660 --> 00:42:03,960
as they are for factory ok we're getting

00:41:59,610 --> 00:42:06,300
to the end so let's sum up what we

00:42:03,960 --> 00:42:09,570
hopefully learned or what I try to show

00:42:06,300 --> 00:42:12,420
you at least the first thing is that the

00:42:09,570 --> 00:42:15,350
integration of non collection types can

00:42:12,420 --> 00:42:17,780
be done via a table once iterable once

00:42:15,350 --> 00:42:19,670
connects this the sequential collection

00:42:17,780 --> 00:42:22,250
from the standard library and the

00:42:19,670 --> 00:42:24,820
parallel collections and also Java 8

00:42:22,250 --> 00:42:28,850
streams for both sequential and parallel

00:42:24,820 --> 00:42:33,380
iteration and it also supports unbox

00:42:28,850 --> 00:42:36,500
iteration of collections then we used

00:42:33,380 --> 00:42:38,360
collection factories and we saw that

00:42:36,500 --> 00:42:40,940
there is no special treatment of

00:42:38,360 --> 00:42:42,890
iterable kind of collections anymore all

00:42:40,940 --> 00:42:45,140
the different kinds are on equal footing

00:42:42,890 --> 00:42:46,910
and they're all supported and you can

00:42:45,140 --> 00:42:49,190
add your own abstractions just remove a

00:42:46,910 --> 00:42:54,410
bit of boilerplate for built from and

00:42:49,190 --> 00:42:56,840
factory and these last two types replace

00:42:54,410 --> 00:43:00,470
candles from in a simpler and more

00:42:56,840 --> 00:43:02,330
directed way if you'd like to know more

00:43:00,470 --> 00:43:04,220
about the architecture of the 213

00:43:02,330 --> 00:43:06,560
collections there is an overview

00:43:04,220 --> 00:43:09,080
documents they are called the

00:43:06,560 --> 00:43:11,840
architecture of Scala 213th collections

00:43:09,080 --> 00:43:14,450
which was rewritten for scott 213

00:43:11,840 --> 00:43:18,440
specifically it's on Doc's calendar orc

00:43:14,450 --> 00:43:20,780
and the main collection documentation on

00:43:18,440 --> 00:43:23,330
that website has also been updated for

00:43:20,780 --> 00:43:25,490
213 so if you go there you'll find two

00:43:23,330 --> 00:43:29,360
different versions for 212 and earlier

00:43:25,490 --> 00:43:31,250
and for 213 now and you can find the

00:43:29,360 --> 00:43:33,020
demo project with these types that are

00:43:31,250 --> 00:43:35,420
whose implementations I showed you and

00:43:33,020 --> 00:43:38,000
some sample code to run them on my

00:43:35,420 --> 00:43:39,500
github together with these slides and if

00:43:38,000 --> 00:43:42,320
you want you can follow me on twitter

00:43:39,500 --> 00:43:46,580
thank you

00:43:42,320 --> 00:43:53,360
[Applause]

00:43:46,580 --> 00:43:57,610
I think we're out of time start right if

00:43:53,360 --> 00:43:57,610
people have questions or you have time

00:43:58,480 --> 00:44:09,200
there's a question yes is there any

00:44:06,950 --> 00:44:11,210
movement for collections that are kind

00:44:09,200 --> 00:44:13,550
of exceeding the size of the int as

00:44:11,210 --> 00:44:15,590
indexing so that you have like lists

00:44:13,550 --> 00:44:19,490
that are indexed by long and servant

00:44:15,590 --> 00:44:21,770
I remember seeing a ticket about that

00:44:19,490 --> 00:44:24,010
but we didn't do any work on in this

00:44:21,770 --> 00:44:24,010
area

00:44:30,220 --> 00:44:35,560
oh that's right accumulators they

00:44:32,740 --> 00:44:37,150
support this that that's another type

00:44:35,560 --> 00:44:43,180
for integrating with parallel

00:44:37,150 --> 00:44:44,320
collections in Java 8 streams thanks for

00:44:43,180 --> 00:44:45,910
the talk

00:44:44,320 --> 00:44:48,720
are we expecting the same architecture

00:44:45,910 --> 00:44:52,450
for dotty or is it gonna change again I

00:44:48,720 --> 00:44:55,540
expect some minor changes in 214 but

00:44:52,450 --> 00:44:57,850
that's basically it because 214 is a a

00:44:55,540 --> 00:44:59,740
compiler focused release not a library

00:44:57,850 --> 00:45:02,140
focused one so it will just be standard

00:44:59,740 --> 00:45:04,780
maintenance and then dotty or scholar

00:45:02,140 --> 00:45:07,090
3.0 will use the 214 collections

00:45:04,780 --> 00:45:15,720
verbatim because it uses the exact same

00:45:07,090 --> 00:45:17,950
standard library thanks for your talk

00:45:15,720 --> 00:45:20,830
you talked a bit about the collection

00:45:17,950 --> 00:45:22,930
breakout in the case of the future but

00:45:20,830 --> 00:45:24,820
how is it gonna work if I want to map

00:45:22,930 --> 00:45:26,800
collection to a different one without

00:45:24,820 --> 00:45:29,890
having the overhead of double conversion

00:45:26,800 --> 00:45:32,350
you use an iterator generally called

00:45:29,890 --> 00:45:34,120
iterator and then almost all of the

00:45:32,350 --> 00:45:37,600
collection methods are also an iterator

00:45:34,120 --> 00:45:39,490
in some cases like for map methods that

00:45:37,600 --> 00:45:41,680
may not be on iterated they're probably

00:45:39,490 --> 00:45:44,080
available on view so you can call that

00:45:41,680 --> 00:45:46,060
view instead of that iterator and in the

00:45:44,080 --> 00:45:56,730
end you just call to and build whatever

00:45:46,060 --> 00:45:56,730
you want from it there's another one up

00:46:00,870 --> 00:46:11,260
I just want to know if we can use

00:46:05,050 --> 00:46:16,120
non-standard implementation to type

00:46:11,260 --> 00:46:21,970
proof in pattern mashing like receiving

00:46:16,120 --> 00:46:26,680
aikka sorry I didn't understand that can

00:46:21,970 --> 00:46:31,890
you use some kind of new features to to

00:46:26,680 --> 00:46:38,170
be type proof with pattern matching if I

00:46:31,890 --> 00:46:42,770
match a case list of ends and list of

00:46:38,170 --> 00:46:46,170
string it's one work it's both lists

00:46:42,770 --> 00:46:48,810
yes sir that's right you'd have to get a

00:46:46,170 --> 00:46:51,900
a class tag somewhere for the element

00:46:48,810 --> 00:46:54,210
type from you context so that's just due

00:46:51,900 --> 00:46:56,940
to erasure so the there's really not

00:46:54,210 --> 00:46:59,130
much we can do as a default in a

00:46:56,940 --> 00:47:01,440
standard library there is class tag and

00:46:59,130 --> 00:47:12,960
that's what you need to use so you have

00:47:01,440 --> 00:47:16,610
to wire it up yourself basically so

00:47:12,960 --> 00:47:21,270
there's a scholar fix rule to migrate to

00:47:16,610 --> 00:47:23,640
two thirteen collections yes in the in

00:47:21,270 --> 00:47:25,470
the Scala collections compact repository

00:47:23,640 --> 00:47:29,370
there's a set of rules to perform the

00:47:25,470 --> 00:47:32,070
migration so one of my co-workers Shane

00:47:29,370 --> 00:47:34,950
Delmore told me to ask you

00:47:32,070 --> 00:47:36,570
he tried it and code broke because

00:47:34,950 --> 00:47:39,600
there's like a mismatch between

00:47:36,570 --> 00:47:41,850
immutable immutable collections yeah

00:47:39,600 --> 00:47:45,330
that's right I already replied to him on

00:47:41,850 --> 00:47:48,120
git er about this okay what was that so

00:47:45,330 --> 00:47:49,680
he wanted me to say basically you should

00:47:48,120 --> 00:47:53,550
be more opinionated but I have no idea

00:47:49,680 --> 00:47:54,780
what's happening so well that's why this

00:47:53,550 --> 00:47:58,530
rule doesn't exist

00:47:54,780 --> 00:48:01,440
so the thing here is you can get some

00:47:58,530 --> 00:48:03,600
breakages because seek in 213 is now

00:48:01,440 --> 00:48:06,990
immutable seek by default the same goes

00:48:03,600 --> 00:48:09,330
for index seek so the easy thing to do

00:48:06,990 --> 00:48:11,730
would be to provide a rule that changes

00:48:09,330 --> 00:48:14,070
every existing seek and index seek to be

00:48:11,730 --> 00:48:18,780
of the generic collection dot whatever

00:48:14,070 --> 00:48:20,700
kind but that would not be idiomatic 213

00:48:18,780 --> 00:48:23,550
code because in most cases you really

00:48:20,700 --> 00:48:26,340
want an immutable seek or an immutable

00:48:23,550 --> 00:48:29,550
index seek and it was only not immutable

00:48:26,340 --> 00:48:32,940
by default just accidentally in in 212

00:48:29,550 --> 00:48:35,460
and it's good if you if you go through

00:48:32,940 --> 00:48:37,260
your code and update those to be really

00:48:35,460 --> 00:48:40,200
immutable and only use the generic ones

00:48:37,260 --> 00:48:41,850
where you need to but it would make

00:48:40,200 --> 00:48:44,340
sense to have it as an optional rule

00:48:41,850 --> 00:48:46,230
just to do the the easy thing so does

00:48:44,340 --> 00:48:49,980
your rule take the generic one and then

00:48:46,230 --> 00:48:51,810
convert it into a mutable one as far as

00:48:49,980 --> 00:48:54,300
I know there is no rule at the moment to

00:48:51,810 --> 00:48:56,339
do any of that but it would be a nice

00:48:54,300 --> 00:48:58,079
addition to have one that just a note

00:48:56,339 --> 00:49:01,019
it's the types basically so when you

00:48:58,079 --> 00:49:03,180
just use Scala seek it would change it

00:49:01,019 --> 00:49:06,210
into skeletal collection dot six you get

00:49:03,180 --> 00:49:10,289
the same thing okay cool and how would

00:49:06,210 --> 00:49:13,440
that be added to Scala collections come

00:49:10,289 --> 00:49:15,329
back open a pull request cool I have

00:49:13,440 --> 00:49:18,119
never actually implemented a rule myself

00:49:15,329 --> 00:49:20,489
so you you'll have to ask Julia or

00:49:18,119 --> 00:49:24,630
someone else who actually worked on this

00:49:20,489 --> 00:49:26,809
I only know that they exist one last

00:49:24,630 --> 00:49:26,809
question

00:49:33,589 --> 00:49:40,589
so there is a trait for a strict

00:49:36,479 --> 00:49:43,499
optimized operations but does this mean

00:49:40,589 --> 00:49:46,829
that the collection who implement this

00:49:43,499 --> 00:49:49,859
trait has all the operations implemented

00:49:46,829 --> 00:49:53,729
as a strict so optimized to be strict or

00:49:49,859 --> 00:49:58,170
we have still variability depending on

00:49:53,729 --> 00:50:00,779
the meter so whether a collection is

00:49:58,170 --> 00:50:03,660
strict or lazy first of all depends on

00:50:00,779 --> 00:50:06,119
how you build it if your from method

00:50:03,660 --> 00:50:08,460
builds it in a strict way by consuming

00:50:06,119 --> 00:50:10,859
the iterable once that it gets then your

00:50:08,460 --> 00:50:12,869
collection is fully strict because

00:50:10,859 --> 00:50:15,089
building it always consumes the source

00:50:12,869 --> 00:50:17,670
so this is just a performance

00:50:15,089 --> 00:50:19,410
optimization we over wrote the methods

00:50:17,670 --> 00:50:23,309
where it makes sense to override them to

00:50:19,410 --> 00:50:25,200
get better performance but at that point

00:50:23,309 --> 00:50:27,930
all the operations are all very dinner

00:50:25,200 --> 00:50:32,940
to be able to be more optimized to be

00:50:27,930 --> 00:50:34,440
strict or improvement or or where it

00:50:32,940 --> 00:50:36,839
makes them where it made sense or

00:50:34,440 --> 00:50:39,059
possibly not all of them because we just

00:50:36,839 --> 00:50:41,369
didn't manage to benchmark every single

00:50:39,059 --> 00:50:43,170
operations but the critical ones we

00:50:41,369 --> 00:50:44,819
noticed it's better to implement them in

00:50:43,170 --> 00:50:46,799
a strict way or they were previously

00:50:44,819 --> 00:50:48,660
implemented in a strict way those are

00:50:46,799 --> 00:50:51,170
overridden there is a documentation

00:50:48,660 --> 00:50:53,670
about what is implemented and overridden

00:50:51,170 --> 00:50:55,259
there is no documentation you have to

00:50:53,670 --> 00:50:57,479
look at the source and see what it

00:50:55,259 --> 00:50:59,309
actually overrides thank you but again

00:50:57,479 --> 00:51:01,739
it's just a performance optimization

00:50:59,309 --> 00:51:03,329
it's not about strict versus lazy

00:51:01,739 --> 00:51:04,829
everything is strict if you're builders

00:51:03,329 --> 00:51:09,700
if you're building the collection in a

00:51:04,829 --> 00:51:10,150
strict way thank you very much

00:51:09,700 --> 00:51:13,310
[Applause]

00:51:10,150 --> 00:51:17,179
[Music]

00:51:13,310 --> 00:51:17,179

YouTube URL: https://www.youtube.com/watch?v=L1lxZ1LBuGI


