Title: Cellular Automata How to become an artist with a few lines - Maciej Gorywoda
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/cellular-automata-how-to-become-an-artist-with-a-few-lines
Captions: 
	00:00:02,179 --> 00:00:09,650
okay hello everyone my name is matcha I

00:00:05,370 --> 00:00:12,420
work in wire in Berlin we are doing this

00:00:09,650 --> 00:00:16,230
encrypt that secure messenger and we use

00:00:12,420 --> 00:00:18,630
color on Android but today's attack will

00:00:16,230 --> 00:00:20,939
not be about that the talk will be about

00:00:18,630 --> 00:00:23,550
something called cellular automata which

00:00:20,939 --> 00:00:26,550
is a way to model complex distributed

00:00:23,550 --> 00:00:29,699
computations but it's not a library it's

00:00:26,550 --> 00:00:31,619
not not a framework you will not be able

00:00:29,699 --> 00:00:34,739
to do something useful with it

00:00:31,619 --> 00:00:37,290
immediately it's a concept in computer

00:00:34,739 --> 00:00:39,780
science so just maybe one day when you

00:00:37,290 --> 00:00:41,700
design your project you will just think

00:00:39,780 --> 00:00:45,030
AHA this is something that I can use as

00:00:41,700 --> 00:00:47,399
well but it needs some work from you we

00:00:45,030 --> 00:00:50,100
will talk for a moment in a moment what

00:00:47,399 --> 00:00:53,309
our fellow automata in detail or we'll

00:00:50,100 --> 00:00:56,699
talk was history of that in computer

00:00:53,309 --> 00:01:00,629
science and what are the practical uses

00:00:56,699 --> 00:01:02,940
of it but practical uses are kind of

00:01:00,629 --> 00:01:06,450
complex and I don't have time to talk

00:01:02,940 --> 00:01:09,869
about it in 40 minutes so we will more

00:01:06,450 --> 00:01:11,640
focus on simpler examples because fellow

00:01:09,869 --> 00:01:14,369
automata can also be used for something

00:01:11,640 --> 00:01:18,479
fun and pretty just to generate some

00:01:14,369 --> 00:01:20,549
trippy paintings on the screen so there

00:01:18,479 --> 00:01:22,770
will be Conway's Game of Life which is

00:01:20,549 --> 00:01:25,530
like the for the first the most

00:01:22,770 --> 00:01:27,960
important cellular automata and not

00:01:25,530 --> 00:01:30,000
talking about slow automata can be done

00:01:27,960 --> 00:01:32,150
without mentioning it there will be

00:01:30,000 --> 00:01:35,600
Langdon's and another example and

00:01:32,150 --> 00:01:38,130
electrons and if we apply some

00:01:35,600 --> 00:01:41,689
modifications and make it colorful it

00:01:38,130 --> 00:01:43,829
can create some interesting pictures

00:01:41,689 --> 00:01:45,450
then I would like to tell you something

00:01:43,829 --> 00:01:48,119
about connection between cellular

00:01:45,450 --> 00:01:49,950
automata and artificial intelligence and

00:01:48,119 --> 00:01:53,850
if we have time there will be one more

00:01:49,950 --> 00:01:58,409
example connected to that okay so what

00:01:53,850 --> 00:02:01,860
exactly are matter in a way we can say

00:01:58,409 --> 00:02:03,570
that this is we can complex processes by

00:02:01,860 --> 00:02:06,509
breaking them in two sets of rules

00:02:03,570 --> 00:02:09,750
applied again and again over time on

00:02:06,509 --> 00:02:11,760
data spread over like the discrete board

00:02:09,750 --> 00:02:13,459
of cells so we we have something very

00:02:11,760 --> 00:02:17,090
complex but there is a way

00:02:13,459 --> 00:02:20,659
to make it simpler but iterative we can

00:02:17,090 --> 00:02:23,840
do it with automata we need five things

00:02:20,659 --> 00:02:26,209
for that we need a cell which is like a

00:02:23,840 --> 00:02:29,060
data structure in and in scallops will

00:02:26,209 --> 00:02:31,790
be a case glass we need a board which is

00:02:29,060 --> 00:02:34,670
like a collection of cells but it's also

00:02:31,790 --> 00:02:37,519
a structure in space so in case it's

00:02:34,670 --> 00:02:39,980
color that will be a map of positions on

00:02:37,519 --> 00:02:42,620
the board on two-dimensional board to

00:02:39,980 --> 00:02:44,870
cells themselves map does not

00:02:42,620 --> 00:02:48,980
necessarily have to be two-dimensional I

00:02:44,870 --> 00:02:50,989
will come back to it in a moment there

00:02:48,980 --> 00:02:53,120
is a concept of neighborhood a

00:02:50,989 --> 00:02:55,549
neighborhood if if we have a central

00:02:53,120 --> 00:03:00,079
cell and there are data in central Seoul

00:02:55,549 --> 00:03:03,019
and we want to compute the data for the

00:03:00,079 --> 00:03:06,169
central cell then we can access the data

00:03:03,019 --> 00:03:08,209
of the cells around it so two classical

00:03:06,169 --> 00:03:11,450
ways to do it - classical neighborhoods

00:03:08,209 --> 00:03:12,620
von Neumann neighborhood which is like

00:03:11,450 --> 00:03:15,889
we have a cell on a two-dimensional

00:03:12,620 --> 00:03:18,019
board and we have cells up down left and

00:03:15,889 --> 00:03:19,819
right of it and there is a more

00:03:18,019 --> 00:03:24,280
neighborhood which is like all eight

00:03:19,819 --> 00:03:25,579
surrounded but boards can be also

00:03:24,280 --> 00:03:28,340
three-dimensional can be

00:03:25,579 --> 00:03:30,409
multi-dimensional this is anything that

00:03:28,340 --> 00:03:32,479
has any space and also a cell does not

00:03:30,409 --> 00:03:35,299
have to be square it can be for example

00:03:32,479 --> 00:03:39,500
hexagonal boards are kind of interesting

00:03:35,299 --> 00:03:41,209
and popular so yeah we have this concept

00:03:39,500 --> 00:03:44,720
of neighborhood which in Scala will be a

00:03:41,209 --> 00:03:46,729
function from a cell to a map of other

00:03:44,720 --> 00:03:50,989
cells that are in the neighborhood and

00:03:46,729 --> 00:03:53,090
their distinctive positions and this is

00:03:50,989 --> 00:03:56,629
important because it means that automata

00:03:53,090 --> 00:03:59,500
work on local data we don't have to

00:03:56,629 --> 00:04:03,530
access something that is very far away

00:03:59,500 --> 00:04:06,709
there are rules also rules simply

00:04:03,530 --> 00:04:09,169
functions from a cell to us so a cell

00:04:06,709 --> 00:04:13,040
itself is immutable which is which also

00:04:09,169 --> 00:04:14,689
in Scala makes it easier to use but we

00:04:13,040 --> 00:04:16,280
were taking the so we're taking the

00:04:14,689 --> 00:04:18,739
neighborhood of that cell but we can

00:04:16,280 --> 00:04:20,959
take that neighborhood from the cell

00:04:18,739 --> 00:04:24,410
itself and we create a new updated

00:04:20,959 --> 00:04:27,050
version of that cell with from new data

00:04:24,410 --> 00:04:29,930
and then we want to take it up the data

00:04:27,050 --> 00:04:32,980
and apply the same rules again and again

00:04:29,930 --> 00:04:35,360
and again so we need some kind of a loop

00:04:32,980 --> 00:04:41,540
in case of Scala that will be just

00:04:35,360 --> 00:04:45,100
iterator over the whole map yeah

00:04:41,540 --> 00:04:47,690
so that's exactly it of them the basics

00:04:45,100 --> 00:04:51,250
the history is a bit more complicated

00:04:47,690 --> 00:04:54,980
the grandfather of cellular automaton is

00:04:51,250 --> 00:04:57,350
John von Neumann son one lemon is a guy

00:04:54,980 --> 00:05:01,760
who invented quite a lot of computer

00:04:57,350 --> 00:05:03,950
science just after the war in the 40s he

00:05:01,760 --> 00:05:07,670
had this idea that we can have like a

00:05:03,950 --> 00:05:10,490
factory of robots and robots can take

00:05:07,670 --> 00:05:12,890
resources from the environment and they

00:05:10,490 --> 00:05:14,600
can create their own copies and those

00:05:12,890 --> 00:05:17,210
copies of the robots can create their

00:05:14,600 --> 00:05:20,420
own copies taking the resources and

00:05:17,210 --> 00:05:23,360
moving around this was clearly inspired

00:05:20,420 --> 00:05:25,520
by a petri dishes and microbes moving

00:05:23,360 --> 00:05:28,490
around in that reduces eating from it's

00:05:25,520 --> 00:05:32,210
also smooth playing and so on and since

00:05:28,490 --> 00:05:35,150
he was Roman then he when he pitched

00:05:32,210 --> 00:05:38,540
this idea he wasn't ignored immediately

00:05:35,150 --> 00:05:40,280
but anyway for mathematicians the this

00:05:38,540 --> 00:05:42,590
was more like a mystery and for

00:05:40,280 --> 00:05:44,840
mathematicians we would like to have

00:05:42,590 --> 00:05:47,120
something that is more well-defined

00:05:44,840 --> 00:05:50,270
maybe not simplified but more abstract

00:05:47,120 --> 00:05:53,240
so john von neumann used some time to

00:05:50,270 --> 00:05:56,390
create some definitions and theorems but

00:05:53,240 --> 00:05:58,940
he died soon after and only a few

00:05:56,390 --> 00:06:01,370
decades later another guy stefan of

00:05:58,940 --> 00:06:07,000
Wolfram who is pretty active and alive

00:06:01,370 --> 00:06:10,310
still pick up that idea and like

00:06:07,000 --> 00:06:13,820
advanced developed more about it he

00:06:10,310 --> 00:06:16,910
mainly focused on the one-dimensional

00:06:13,820 --> 00:06:20,030
floor automata which you might seen from

00:06:16,910 --> 00:06:24,020
where this is this triangle it's called

00:06:20,030 --> 00:06:25,850
share Pinsky strangle and well it's not

00:06:24,020 --> 00:06:27,980
a board it's one-dimensional flow

00:06:25,850 --> 00:06:30,410
tomaten means that the board is just a

00:06:27,980 --> 00:06:32,030
line and we every cell has only two

00:06:30,410 --> 00:06:37,010
neighbors to the left and to the right

00:06:32,030 --> 00:06:38,300
and in case of Stefan Warren's ideas the

00:06:37,010 --> 00:06:40,430
cell itself

00:06:38,300 --> 00:06:43,220
only one bullying of data so we can be

00:06:40,430 --> 00:06:48,889
either white or black and it can change

00:06:43,220 --> 00:06:51,110
its data and looking at this to

00:06:48,889 --> 00:06:53,930
neighbors to the left or to the right so

00:06:51,110 --> 00:06:56,210
in this case that triangle is created

00:06:53,930 --> 00:06:59,479
like that that we have this one line

00:06:56,210 --> 00:07:02,120
board horizontally but vertically it's

00:06:59,479 --> 00:07:07,129
time so we can see that the triangle

00:07:02,120 --> 00:07:11,000
unfolds on over the iterations vote from

00:07:07,129 --> 00:07:13,819
created a set of rules like this that

00:07:11,000 --> 00:07:17,030
say that if we have for example only one

00:07:13,819 --> 00:07:19,340
so the central cylinder which is black

00:07:17,030 --> 00:07:20,930
and there are two cells around the

00:07:19,340 --> 00:07:23,409
twitter white then in the next

00:07:20,930 --> 00:07:26,300
iterations that cell will stay black and

00:07:23,409 --> 00:07:28,729
if that if the cell is white but there

00:07:26,300 --> 00:07:30,379
is a neighbor which is black the third

00:07:28,729 --> 00:07:30,770
in the next station will be black as

00:07:30,379 --> 00:07:32,719
well

00:07:30,770 --> 00:07:34,849
but if then we go to the next iteration

00:07:32,719 --> 00:07:37,669
and if we have three cells and the

00:07:34,849 --> 00:07:41,319
central soul is black and then even next

00:07:37,669 --> 00:07:44,029
iteration that cell will be white yes so

00:07:41,319 --> 00:07:46,159
generally looking at it this way he

00:07:44,029 --> 00:07:49,340
created some naming conventions and

00:07:46,159 --> 00:07:52,729
classifications he noticed that most of

00:07:49,340 --> 00:07:55,699
the flula automata like this pretty

00:07:52,729 --> 00:07:57,590
boring and stable there are some of the

00:07:55,699 --> 00:07:59,150
matters that are chaotic they just make

00:07:57,590 --> 00:08:01,789
a mess on the board and nothing

00:07:59,150 --> 00:08:04,370
interesting concept of it but former in

00:08:01,789 --> 00:08:06,500
the middle between them there is a

00:08:04,370 --> 00:08:09,740
lagoon this interesting part that is

00:08:06,500 --> 00:08:14,509
both chaotic and stable there are

00:08:09,740 --> 00:08:17,840
patterns which were and for which unfold

00:08:14,509 --> 00:08:19,550
chaotically but then they come to the

00:08:17,840 --> 00:08:22,009
moment of stability but not a perfect

00:08:19,550 --> 00:08:23,840
stability then they unfold again and we

00:08:22,009 --> 00:08:27,400
can use that for computations or

00:08:23,840 --> 00:08:31,639
something like artificial intelligence

00:08:27,400 --> 00:08:35,140
okay but what are practical implications

00:08:31,639 --> 00:08:38,959
of all that first of all if you ever

00:08:35,140 --> 00:08:41,240
looked at the weather and ask you okay

00:08:38,959 --> 00:08:45,050
will be raining in Lausanne for the

00:08:41,240 --> 00:08:47,720
whole week it was probably then that

00:08:45,050 --> 00:08:50,779
somewhere under the whole forecasting

00:08:47,720 --> 00:08:51,740
there is probably a model that looks a

00:08:50,779 --> 00:08:55,430
bit like

00:08:51,740 --> 00:08:58,070
the mutton only more complicated we have

00:08:55,430 --> 00:09:00,589
our planet but we don't have like a one

00:08:58,070 --> 00:09:03,350
single equation that can tell us about

00:09:00,589 --> 00:09:06,880
the weather on the whole planet instead

00:09:03,350 --> 00:09:10,790
we divide the planet into smaller cells

00:09:06,880 --> 00:09:13,250
three-dimensional sort of and in every

00:09:10,790 --> 00:09:16,370
cell we have some physical processes we

00:09:13,250 --> 00:09:21,140
have atmosphere we have some land and

00:09:16,370 --> 00:09:24,529
water we have we have Sun which warmth

00:09:21,140 --> 00:09:27,020
all this we have some wind conditions

00:09:24,529 --> 00:09:29,000
and so on and this is not magic we

00:09:27,020 --> 00:09:31,910
exactly know from physics how it works

00:09:29,000 --> 00:09:36,020
how this will change over time so we can

00:09:31,910 --> 00:09:38,420
take the data in one cell we can apply

00:09:36,020 --> 00:09:42,200
the rules than the physics and we can

00:09:38,420 --> 00:09:44,480
also look at the cells around it to

00:09:42,200 --> 00:09:48,290
create an updated version of our cell

00:09:44,480 --> 00:09:51,440
and then again and again iterating over

00:09:48,290 --> 00:09:54,709
this we at some point create our

00:09:51,440 --> 00:09:57,050
forecasts of the weather in the next day

00:09:54,709 --> 00:10:00,560
next Tuesday

00:09:57,050 --> 00:10:02,000
apart from weather forecasting Solar

00:10:00,560 --> 00:10:04,760
automata can be used for modeling

00:10:02,000 --> 00:10:09,050
physical laws for example dynamics of

00:10:04,760 --> 00:10:11,720
fluids is pretty complicated somehow we

00:10:09,050 --> 00:10:14,149
can simulate all things that are somehow

00:10:11,720 --> 00:10:16,940
related to real world that have space we

00:10:14,149 --> 00:10:18,770
have a if we have a planet or we have an

00:10:16,940 --> 00:10:22,130
ecosystem or we have some kind of an

00:10:18,770 --> 00:10:24,860
economy and then we have some rules that

00:10:22,130 --> 00:10:27,079
lock out because in real world things

00:10:24,860 --> 00:10:29,510
that do not happen immediately

00:10:27,079 --> 00:10:30,950
everywhere they it something happens in

00:10:29,510 --> 00:10:33,740
one place and it's only slowly

00:10:30,950 --> 00:10:36,680
propagated over the whole system then we

00:10:33,740 --> 00:10:39,890
can use cellular automata to simulate

00:10:36,680 --> 00:10:41,810
that we can of course also use that for

00:10:39,890 --> 00:10:44,050
microbials that's called artificial life

00:10:41,810 --> 00:10:47,600
and it's like going full circle from

00:10:44,050 --> 00:10:51,140
microbes which inspired the matter sorry

00:10:47,600 --> 00:10:53,089
we can use it also for some kind of a

00:10:51,140 --> 00:10:57,440
low level of the visual intelligence I

00:10:53,089 --> 00:10:59,990
will come back to it later but one more

00:10:57,440 --> 00:11:03,260
thing is that we can generate data for

00:10:59,990 --> 00:11:05,660
with solute Amata this is used in

00:11:03,260 --> 00:11:08,540
encryption but it can also be you

00:11:05,660 --> 00:11:15,280
simply to create functional that looks

00:11:08,540 --> 00:11:20,830
like alright the game of life was

00:11:15,280 --> 00:11:24,380
invented by this guy John Conway who is

00:11:20,830 --> 00:11:27,590
professor emeritus in Princeton I think

00:11:24,380 --> 00:11:31,700
and it's important because it's like the

00:11:27,590 --> 00:11:35,480
simplest version of of a saloon

00:11:31,700 --> 00:11:38,660
automaton which is still the interesting

00:11:35,480 --> 00:11:41,750
kind it's not stable it's not chaotic it

00:11:38,660 --> 00:11:44,480
creates patterns so the idea is like

00:11:41,750 --> 00:11:47,750
this we have a cell which can be also we

00:11:44,480 --> 00:11:49,970
have only one boolean of data we can we

00:11:47,750 --> 00:11:52,490
it can be alive or that we have a board

00:11:49,970 --> 00:11:56,120
which is like a typical to demand salt

00:11:52,490 --> 00:11:58,370
but in fact in the 70s the first game of

00:11:56,120 --> 00:12:00,490
life was played on the board of trackers

00:11:58,370 --> 00:12:03,530
not on a computer we have the most

00:12:00,490 --> 00:12:06,020
neighborhood so for the given cell we

00:12:03,530 --> 00:12:08,390
have eight cells around it which form

00:12:06,020 --> 00:12:12,290
the neighborhood and the rules goes like

00:12:08,390 --> 00:12:14,900
that if the cell is that but is white

00:12:12,290 --> 00:12:17,630
but in the neighborhood we have three

00:12:14,900 --> 00:12:20,420
cells that are alive then the next in

00:12:17,630 --> 00:12:23,360
the next iteration doesn't also will be

00:12:20,420 --> 00:12:25,790
alive if the soul is alive and in the

00:12:23,360 --> 00:12:28,220
neighborhood we have two or three cells

00:12:25,790 --> 00:12:29,900
that are alive as well then the cell

00:12:28,220 --> 00:12:32,630
will stay alive in the next night and

00:12:29,900 --> 00:12:37,100
next iteration otherwise the cell will

00:12:32,630 --> 00:12:42,800
die either because of like it's crowded

00:12:37,100 --> 00:12:51,500
too much or it's too lonely and before I

00:12:42,800 --> 00:12:54,770
show you the first example yeah so we

00:12:51,500 --> 00:12:56,630
can create from populate the board first

00:12:54,770 --> 00:12:58,280
because if the boat is only white then

00:12:56,630 --> 00:13:02,270
nothing really interesting is happening

00:12:58,280 --> 00:13:05,840
but if we add some black that if live

00:13:02,270 --> 00:13:08,780
cells on it it will go like this we have

00:13:05,840 --> 00:13:12,290
we can see that we have some stable

00:13:08,780 --> 00:13:15,370
things for example we can see that this

00:13:12,290 --> 00:13:17,930
part is just flipping around from one

00:13:15,370 --> 00:13:20,390
safe to another but nothing

00:13:17,930 --> 00:13:22,640
happens we can see that we have some K

00:13:20,390 --> 00:13:24,620
of here we don't really know what will

00:13:22,640 --> 00:13:26,540
happen in the next few iterations about

00:13:24,620 --> 00:13:29,899
it but we also have something very

00:13:26,540 --> 00:13:34,190
interesting this is called a glider a

00:13:29,899 --> 00:13:37,130
glider is moving around like this it's

00:13:34,190 --> 00:13:39,920
not really existing like itself its self

00:13:37,130 --> 00:13:42,050
sort of flipping from white to black and

00:13:39,920 --> 00:13:45,860
we only see it as an object but it's

00:13:42,050 --> 00:13:48,620
really but it's stable but dynamic and

00:13:45,860 --> 00:13:50,899
then it hits something and bam okay it

00:13:48,620 --> 00:13:52,880
disappeared anyway we can see that we

00:13:50,899 --> 00:13:57,500
have still some chaotic part of the

00:13:52,880 --> 00:14:16,790
screen that moves and that's basically

00:13:57,500 --> 00:14:22,130
Oh going back to the okay let's go back

00:14:16,790 --> 00:14:26,630
to this no okay so how to how can we do

00:14:22,130 --> 00:14:29,120
it in Scala we have it we just have to

00:14:26,630 --> 00:14:32,839
implement all those things a cell about

00:14:29,120 --> 00:14:36,970
neighborhood to the rules we have a case

00:14:32,839 --> 00:14:40,670
class game of life which takes a boolean

00:14:36,970 --> 00:14:42,680
and it's well it also has to have an

00:14:40,670 --> 00:14:46,070
access to the board but the problem is

00:14:42,680 --> 00:14:48,709
the board also have to have an access to

00:14:46,070 --> 00:14:50,360
itself so we can't create a cell which

00:14:48,709 --> 00:14:52,160
already know about the board which is

00:14:50,360 --> 00:14:54,800
not yet created slick and I can chicken

00:14:52,160 --> 00:14:58,100
problem we can go around by making it

00:14:54,800 --> 00:14:59,990
more lazy instead of having the cell or

00:14:58,100 --> 00:15:01,850
giving the cell the reference to the

00:14:59,990 --> 00:15:04,490
board we can give it information about

00:15:01,850 --> 00:15:06,740
its own position on the board and we can

00:15:04,490 --> 00:15:08,510
give it a function because we need that

00:15:06,740 --> 00:15:10,730
refers to the board to find the

00:15:08,510 --> 00:15:13,430
neighborhood the more neighborhood but

00:15:10,730 --> 00:15:16,760
if we simply give a function that will

00:15:13,430 --> 00:15:19,490
find upon another cell on the board then

00:15:16,760 --> 00:15:21,140
we don't really need the boat yet we

00:15:19,490 --> 00:15:24,709
will need the boat only in the moment of

00:15:21,140 --> 00:15:29,370
looking for that so and that works we

00:15:24,709 --> 00:15:32,640
can go around the eager that the problem

00:15:29,370 --> 00:15:36,230
so then we need a method which I called

00:15:32,640 --> 00:15:40,200
update then method implements the rules

00:15:36,230 --> 00:15:44,640
which are above and on that we need a

00:15:40,200 --> 00:15:46,860
class board which takes the dimension we

00:15:44,640 --> 00:15:51,540
need to know how big the board is and it

00:15:46,860 --> 00:15:54,930
takes a map of from some identifier to

00:15:51,540 --> 00:15:58,589
the self game of life and for that we

00:15:54,930 --> 00:16:02,910
and in that board we implement the find

00:15:58,589 --> 00:16:04,500
so method and we implement methods that

00:16:02,910 --> 00:16:07,400
will create a new board from the

00:16:04,500 --> 00:16:11,730
existing one depending on all the rules

00:16:07,400 --> 00:16:17,400
the thing is I told you before that the

00:16:11,730 --> 00:16:19,830
map is only from positions to the game

00:16:17,400 --> 00:16:22,440
of life but today to the cells but let's

00:16:19,830 --> 00:16:24,540
think about it a bit they can't be

00:16:22,440 --> 00:16:27,360
really one to an a position if not

00:16:24,540 --> 00:16:31,830
really an identifier and that's why

00:16:27,360 --> 00:16:34,470
because we have a board like this if we

00:16:31,830 --> 00:16:36,380
talk about a cell in the middle of the

00:16:34,470 --> 00:16:38,940
board and okay we have all the eight

00:16:36,380 --> 00:16:42,000
neighbors around it but what happens if

00:16:38,940 --> 00:16:44,940
we talk about cell which is on the edge

00:16:42,000 --> 00:16:48,540
in the code and that's like literally a

00:16:44,940 --> 00:16:50,880
corner case Q such cell has only three

00:16:48,540 --> 00:16:55,500
neighbors and we would either need to do

00:16:50,880 --> 00:16:58,470
some corner cases rules exactly for

00:16:55,500 --> 00:17:00,540
those cells or we need to change the

00:16:58,470 --> 00:17:05,490
board somehow for example we can make it

00:17:00,540 --> 00:17:09,000
into like we talked before into a planet

00:17:05,490 --> 00:17:13,380
if we have a if we can wrap around our

00:17:09,000 --> 00:17:15,240
board then when when we talk about a

00:17:13,380 --> 00:17:16,920
board on the left and we are going to

00:17:15,240 --> 00:17:19,110
take a neighbor from even more to the

00:17:16,920 --> 00:17:21,329
left than this one then we simply go

00:17:19,110 --> 00:17:24,660
around and we take the neighbor from the

00:17:21,329 --> 00:17:27,030
most right position and vice versa the

00:17:24,660 --> 00:17:29,730
problem is on the poles but the pole

00:17:27,030 --> 00:17:32,670
still can't have this

00:17:29,730 --> 00:17:36,660
we still can't move from the most

00:17:32,670 --> 00:17:39,630
northern most upper on the from this

00:17:36,660 --> 00:17:41,300
position to this position but in case of

00:17:39,630 --> 00:17:43,880
our

00:17:41,300 --> 00:17:45,530
selamat on board we can do it again we

00:17:43,880 --> 00:17:47,240
can wrap it again we can create

00:17:45,530 --> 00:17:51,650
something that is called the torus which

00:17:47,240 --> 00:17:54,950
looks like this donut here and and this

00:17:51,650 --> 00:17:57,140
way we have the possibility to move both

00:17:54,950 --> 00:18:00,940
ways either horizontally and vertically

00:17:57,140 --> 00:18:04,130
and there is no corner cases anymore

00:18:00,940 --> 00:18:08,660
well there are no planets that look like

00:18:04,130 --> 00:18:11,000
this in reality but it is used sometimes

00:18:08,660 --> 00:18:14,330
in video games I think in Ultima Online

00:18:11,000 --> 00:18:16,160
I think I saw a mod to civilization and

00:18:14,330 --> 00:18:18,140
this is basically because of that we

00:18:16,160 --> 00:18:22,280
don't know if we use a board like this

00:18:18,140 --> 00:18:24,730
in a game we don't need corner cases so

00:18:22,280 --> 00:18:27,920
right we have a board the board is

00:18:24,730 --> 00:18:30,050
calling its next method to create their

00:18:27,920 --> 00:18:34,790
own another boat and another boat and so

00:18:30,050 --> 00:18:38,230
on over time and in Scala that will be

00:18:34,790 --> 00:18:42,260
an entitled that simply a class that

00:18:38,230 --> 00:18:46,460
creates new boards every time the next

00:18:42,260 --> 00:18:49,300
method is called so we implement the

00:18:46,460 --> 00:18:52,630
class it's simply an iterator over the

00:18:49,300 --> 00:18:57,050
the board and we call it automaton and

00:18:52,630 --> 00:18:59,600
for that we need a dimension again the

00:18:57,050 --> 00:19:03,650
size of the board we need a function

00:18:59,600 --> 00:19:08,270
that will take the position of on the

00:19:03,650 --> 00:19:10,880
board and the function that will this

00:19:08,270 --> 00:19:13,340
will be a function that will find

00:19:10,880 --> 00:19:17,510
another cell on the board basing on the

00:19:13,340 --> 00:19:21,200
position and that cell will be created

00:19:17,510 --> 00:19:23,570
from the method then we also need

00:19:21,200 --> 00:19:27,020
another method that will create a board

00:19:23,570 --> 00:19:29,210
from the board we already have so this

00:19:27,020 --> 00:19:31,610
will be called apply board in the

00:19:29,210 --> 00:19:34,910
automaton and apply board takes the

00:19:31,610 --> 00:19:38,179
dimension and takes a function that will

00:19:34,910 --> 00:19:40,640
create cells in that new board and this

00:19:38,179 --> 00:19:45,410
is probably the most magical line in the

00:19:40,640 --> 00:19:48,100
whole project in the we create a bow a

00:19:45,410 --> 00:19:50,780
first in so board by applying this

00:19:48,100 --> 00:19:54,260
method apply board that takes the

00:19:50,780 --> 00:19:55,410
dimension and thanks and that creates

00:19:54,260 --> 00:19:58,800
self

00:19:55,410 --> 00:20:01,680
and apply felt takes the position on the

00:19:58,800 --> 00:20:03,870
board but it also needs a function that

00:20:01,680 --> 00:20:07,290
will find self on the board and the

00:20:03,870 --> 00:20:10,190
board is not yet created this way we can

00:20:07,290 --> 00:20:14,400
go around it this is exactly the way and

00:20:10,190 --> 00:20:16,440
there are 30 trivial we have the next

00:20:14,400 --> 00:20:19,140
method which simply creates a new

00:20:16,440 --> 00:20:21,540
version of the board we have a half next

00:20:19,140 --> 00:20:23,850
for this iterator but it is house next

00:20:21,540 --> 00:20:26,340
is always true and then we can do all

00:20:23,850 --> 00:20:31,320
the things that iterators can do in

00:20:26,340 --> 00:20:34,310
scala alright so another example here

00:20:31,320 --> 00:20:40,410
Langdon's and it was created by

00:20:34,310 --> 00:20:43,050
Christopher Langdon in 86 this is a bit

00:20:40,410 --> 00:20:45,720
different in case of Game of Life we

00:20:43,050 --> 00:20:47,700
heard those microbes all over the board

00:20:45,720 --> 00:20:50,880
in case of lagoons and we have just like

00:20:47,700 --> 00:20:53,580
one ant one cell that is doing something

00:20:50,880 --> 00:20:55,920
and so the rules goes like this we have

00:20:53,580 --> 00:20:57,750
a cell again black and white although in

00:20:55,920 --> 00:21:01,080
the next version it will be more

00:20:57,750 --> 00:21:04,500
colorful we have the direct song like we

00:21:01,080 --> 00:21:06,090
have if the cell has an ant and what we

00:21:04,500 --> 00:21:10,230
are interested in really if dove the

00:21:06,090 --> 00:21:13,530
direction dance is heading or it can be

00:21:10,230 --> 00:21:15,630
none if there is no and on the cell the

00:21:13,530 --> 00:21:17,160
boat is again two-dimensional the

00:21:15,630 --> 00:21:18,780
neighborhood this time if only one

00:21:17,160 --> 00:21:20,630
moment so it means that we were only

00:21:18,780 --> 00:21:24,440
interested in the up-down left-right

00:21:20,630 --> 00:21:29,130
positions all right and the thing is

00:21:24,440 --> 00:21:33,720
that now we have two rules not not only

00:21:29,130 --> 00:21:37,650
one the first tool is about the if the

00:21:33,720 --> 00:21:39,390
how the ant is moving and ok this is a

00:21:37,650 --> 00:21:42,960
bit complicated on the screen but

00:21:39,390 --> 00:21:44,520
basically if we have a central cell we

00:21:42,960 --> 00:21:45,510
were looking for an ant in the

00:21:44,520 --> 00:21:47,370
neighborhood

00:21:45,510 --> 00:21:49,590
if there is an ant in the neighborhood

00:21:47,370 --> 00:21:52,380
we were moving the end to the central

00:21:49,590 --> 00:21:55,140
cell and then depending on the color of

00:21:52,380 --> 00:22:00,150
that central so we either take the ant

00:21:55,140 --> 00:22:03,680
to turn right if the color is white or

00:22:00,150 --> 00:22:06,360
to turn left if the color is black

00:22:03,680 --> 00:22:09,720
otherwise if there is no and in the

00:22:06,360 --> 00:22:13,290
neighborhood the cell will stay the same

00:22:09,720 --> 00:22:15,680
therefore all about the color if there

00:22:13,290 --> 00:22:20,330
is no and than the color stay the same

00:22:15,680 --> 00:22:25,700
otherwise if we have an ant then we will

00:22:20,330 --> 00:22:25,700
change the color of the cell all right

00:22:26,300 --> 00:22:33,660
so we start with a simple single place

00:22:29,880 --> 00:22:37,440
we just run the whole thing and lactose

00:22:33,660 --> 00:22:39,420
ant is moving into this kinda chaotic

00:22:37,440 --> 00:22:43,400
pattern even though they're also pretty

00:22:39,420 --> 00:22:47,370
simple it creates something like a maze

00:22:43,400 --> 00:22:49,410
but we know that after some time no

00:22:47,370 --> 00:22:51,930
matter how much we can even add some

00:22:49,410 --> 00:22:55,560
other ants on the screen or other

00:22:51,930 --> 00:22:59,520
obstacles if there is enough time the

00:22:55,560 --> 00:23:02,690
ant will at some point create a stable

00:22:59,520 --> 00:23:05,640
pattern but dynamic stable pattern okay

00:23:02,690 --> 00:23:10,490
and it will just move like this on a

00:23:05,640 --> 00:23:15,510
highway going in one direction until it

00:23:10,490 --> 00:23:18,750
until it hits something that was already

00:23:15,510 --> 00:23:21,690
created before and then again it will go

00:23:18,750 --> 00:23:24,540
to the chaotic face and at some point it

00:23:21,690 --> 00:23:26,940
will go back to the to creating that

00:23:24,540 --> 00:23:32,960
pattern if there is a possibility for

00:23:26,940 --> 00:23:32,960
that and alright let's go back to the

00:23:44,120 --> 00:23:49,530
okay for how to do it again we have a

00:23:47,340 --> 00:23:52,080
case class Lincoln and we have a color

00:23:49,530 --> 00:23:55,440
we have a direction we have a position

00:23:52,080 --> 00:23:58,170
and and we have the the function that

00:23:55,440 --> 00:24:01,260
will find the neighbor cell and we have

00:23:58,170 --> 00:24:03,930
the update method and this is all that

00:24:01,260 --> 00:24:05,460
we need again to implement that even

00:24:03,930 --> 00:24:08,550
though Lankans aunt looks very different

00:24:05,460 --> 00:24:12,600
from Game of Life now because of that we

00:24:08,550 --> 00:24:15,240
can think about making it all more

00:24:12,600 --> 00:24:16,920
abstract so there are clearly some kind

00:24:15,240 --> 00:24:19,920
some parts of the code that are the same

00:24:16,920 --> 00:24:23,220
in both cases we can create a straight

00:24:19,920 --> 00:24:26,960
cold ultimatum cell that is the thing is

00:24:23,220 --> 00:24:30,570
this is lower bound of that automatic so

00:24:26,960 --> 00:24:32,790
if itself because for the function that

00:24:30,570 --> 00:24:35,430
finds the cell we need to return the

00:24:32,790 --> 00:24:38,310
cell itself not just the trade because

00:24:35,430 --> 00:24:40,440
we need to access data of that that cell

00:24:38,310 --> 00:24:44,970
I don't like them sound game of life or

00:24:40,440 --> 00:24:47,760
whatever yeah but all the rest all the

00:24:44,970 --> 00:24:50,760
rest is basically the same in both cases

00:24:47,760 --> 00:24:53,910
and we can now rewrite at the board and

00:24:50,760 --> 00:25:01,440
we write it out on item using the trait

00:24:53,910 --> 00:25:04,860
instead of the particular class and this

00:25:01,440 --> 00:25:06,900
is also one thing that this is the first

00:25:04,860 --> 00:25:09,720
time in my career of a scalar product

00:25:06,900 --> 00:25:14,990
actually parallel map made a difference

00:25:09,720 --> 00:25:17,370
because for because all the cells are

00:25:14,990 --> 00:25:19,920
calculated independently they don't

00:25:17,370 --> 00:25:22,500
always conditions they don't interact

00:25:19,920 --> 00:25:25,770
with each other so even changing a

00:25:22,500 --> 00:25:31,920
simple map to parallel map gave me some

00:25:25,770 --> 00:25:36,060
like 30% of better performance alright

00:25:31,920 --> 00:25:39,030
so all we need now after that change is

00:25:36,060 --> 00:25:41,310
to implement the actual data of the

00:25:39,030 --> 00:25:44,280
given automaton in this case this is the

00:25:41,310 --> 00:25:48,540
color and the direction and we need to

00:25:44,280 --> 00:25:50,730
implement rules in the update method and

00:25:48,540 --> 00:25:54,330
that's that again this time in columns

00:25:50,730 --> 00:25:56,340
so we have in this time we have a case

00:25:54,330 --> 00:25:57,180
class that tells us something about the

00:25:56,340 --> 00:26:00,060
call

00:25:57,180 --> 00:26:02,610
of the and and we have a bit different

00:26:00,060 --> 00:26:05,580
case class of the cell that tells us

00:26:02,610 --> 00:26:07,890
that there can be many ants with many

00:26:05,580 --> 00:26:11,280
colors they don't interact with each

00:26:07,890 --> 00:26:14,850
other they just go from the if they are

00:26:11,280 --> 00:26:17,250
taken to the central cell they will just

00:26:14,850 --> 00:26:19,230
move their way to right or left they're

00:26:17,250 --> 00:26:22,790
only interested in their own colors but

00:26:19,230 --> 00:26:30,060
the colors would stay in the cell can be

00:26:22,790 --> 00:26:36,480
mixed and and give some from interesting

00:26:30,060 --> 00:26:38,250
pattern that's not just okay so for

00:26:36,480 --> 00:26:42,450
example here we have three yellow and

00:26:38,250 --> 00:26:46,460
one magenta and we can add four more

00:26:42,450 --> 00:26:49,590
now there's one fire ant and when they

00:26:46,460 --> 00:26:54,210
come to the same place like for example

00:26:49,590 --> 00:26:57,990
here then the colors mix so we can have

00:26:54,210 --> 00:26:59,970
blue and red and but the answer

00:26:57,990 --> 00:27:00,680
themselves they just move around as if

00:26:59,970 --> 00:27:03,810
nothing happened

00:27:00,680 --> 00:27:08,340
although the magenta one magenta and if

00:27:03,810 --> 00:27:11,430
it goes if it sees another magenta color

00:27:08,340 --> 00:27:14,910
made by another emergent and that will

00:27:11,430 --> 00:27:17,520
interact but the colored deck and food

00:27:14,910 --> 00:27:20,540
different colors stay completely

00:27:17,520 --> 00:27:23,570
independent and also after some time

00:27:20,540 --> 00:27:26,880
create their own highways their own

00:27:23,570 --> 00:27:30,650
dynamic patterns even here we can see

00:27:26,880 --> 00:27:34,220
that they go to their own territories

00:27:30,650 --> 00:27:37,890
yeah something like that

00:27:34,220 --> 00:27:40,230
all right unfortunately now I will have

00:27:37,890 --> 00:27:42,780
to go back to the exact place in the

00:27:40,230 --> 00:27:45,350
presentation all right that's something

00:27:42,780 --> 00:27:45,350
like this

00:27:48,910 --> 00:27:59,860
okay so using that idea that we have

00:27:56,430 --> 00:28:02,350
cellular automata that can go to phases

00:27:59,860 --> 00:28:06,330
through more chaotic and more stable

00:28:02,350 --> 00:28:09,660
things we can think how to use it to

00:28:06,330 --> 00:28:13,450
form like more general-purpose

00:28:09,660 --> 00:28:15,810
artificial intelligence imagine that we

00:28:13,450 --> 00:28:20,320
want to again we want to do some

00:28:15,810 --> 00:28:23,800
forecasting we have some huge data set

00:28:20,320 --> 00:28:26,950
with data about the past and the present

00:28:23,800 --> 00:28:30,340
and how it's changed we can then like

00:28:26,950 --> 00:28:33,370
divide the whole thing we can say that

00:28:30,340 --> 00:28:35,800
we have this represents our past this

00:28:33,370 --> 00:28:40,510
represents our present moment or like

00:28:35,800 --> 00:28:44,350
more recent past and we get we have some

00:28:40,510 --> 00:28:48,280
artificial intelligence we feed the past

00:28:44,350 --> 00:28:51,550
the data set to the dual intelligence

00:28:48,280 --> 00:28:53,890
and we get some prediction about the

00:28:51,550 --> 00:28:56,250
present moment so because we already

00:28:53,890 --> 00:28:59,350
know the present moment we can then

00:28:56,250 --> 00:29:01,420
compare the present and the prediction

00:28:59,350 --> 00:29:07,690
we can get some feedback and we can

00:29:01,420 --> 00:29:10,870
start teaching the AI here so next time

00:29:07,690 --> 00:29:12,610
when we do the same thing the prediction

00:29:10,870 --> 00:29:14,260
will be closer to the truth

00:29:12,610 --> 00:29:16,360
and when we think that okay the

00:29:14,260 --> 00:29:18,580
prediction is just like the truth lots

00:29:16,360 --> 00:29:21,100
of like the present moment we can like

00:29:18,580 --> 00:29:24,100
move the time window and we can feed the

00:29:21,100 --> 00:29:25,780
AI the present moment and to get some

00:29:24,100 --> 00:29:28,330
prediction about the future

00:29:25,780 --> 00:29:31,300
and well assume that this is a good

00:29:28,330 --> 00:29:34,200
prediction so if we were talking about

00:29:31,300 --> 00:29:37,960
artificial neural networks that's

00:29:34,200 --> 00:29:43,060
usually back propagation in in work here

00:29:37,960 --> 00:29:45,280
we we use some algorithms that tweak the

00:29:43,060 --> 00:29:47,350
neural network into a better prediction

00:29:45,280 --> 00:29:48,040
in cellular automata that is not

00:29:47,350 --> 00:29:53,430
possible

00:29:48,040 --> 00:29:56,350
well if the automaton is complex enough

00:29:53,430 --> 00:29:59,120
then probably there will be a lot of

00:29:56,350 --> 00:30:01,790
coefficients like we have

00:29:59,120 --> 00:30:03,770
for maps of death we want to transform

00:30:01,790 --> 00:30:07,010
it into format of that and there will be

00:30:03,770 --> 00:30:07,790
some coefficient a percent or in another

00:30:07,010 --> 00:30:11,480
way

00:30:07,790 --> 00:30:13,010
used in that transformation and if there

00:30:11,480 --> 00:30:15,230
are enough because we have those

00:30:13,010 --> 00:30:17,510
coefficient and we can use some kind of

00:30:15,230 --> 00:30:19,700
a statistical methods like we can use

00:30:17,510 --> 00:30:20,270
generally quick our gardens of Monte

00:30:19,700 --> 00:30:24,440
Carlo

00:30:20,270 --> 00:30:27,970
that will tweak those CAF isms but quite

00:30:24,440 --> 00:30:32,020
often in case of silhouette Amata all

00:30:27,970 --> 00:30:34,550
making the didn't simulation better

00:30:32,020 --> 00:30:38,030
requires actually to have a better

00:30:34,550 --> 00:30:41,360
models of how rules work and that needs

00:30:38,030 --> 00:30:44,120
actual humans who will sit down and

00:30:41,360 --> 00:30:46,190
think about those models there are some

00:30:44,120 --> 00:30:47,420
advantages though we have better

00:30:46,190 --> 00:30:50,900
understanding of the underlying

00:30:47,420 --> 00:30:52,820
processes we are used to think about the

00:30:50,900 --> 00:30:55,460
space and we are used to think about

00:30:52,820 --> 00:30:58,580
local events not something very complex

00:30:55,460 --> 00:31:01,220
and very Universal over the whole system

00:30:58,580 --> 00:31:05,060
the maps are simple because we just

00:31:01,220 --> 00:31:08,180
break down all the complex equations

00:31:05,060 --> 00:31:10,250
into something that can work only on our

00:31:08,180 --> 00:31:12,140
central cell and its neighborhood the

00:31:10,250 --> 00:31:14,450
communication is easier because we are

00:31:12,140 --> 00:31:16,970
talking about things that we can imagine

00:31:14,450 --> 00:31:20,410
and we can assume that other people

00:31:16,970 --> 00:31:25,280
imagine it in a similar way than we do

00:31:20,410 --> 00:31:32,990
alright and for example we can use it in

00:31:25,280 --> 00:31:36,830
ways that can be not so obvious my my

00:31:32,990 --> 00:31:41,390
personal project is to use automatic in

00:31:36,830 --> 00:31:46,280
videogame we can think like in an in a

00:31:41,390 --> 00:31:51,910
normal way if we have a hero who enters

00:31:46,280 --> 00:31:55,340
a scene an area and there are from NPCs

00:31:51,910 --> 00:31:57,620
which are controlled by the computer and

00:31:55,340 --> 00:32:01,880
they want to kill the hero and the hero

00:31:57,620 --> 00:32:04,730
wants to kill those and disease then the

00:32:01,880 --> 00:32:07,130
every NPC has something like AI unit

00:32:04,730 --> 00:32:10,270
attached to it so we have something like

00:32:07,130 --> 00:32:14,140
a 12 brain that controls that one

00:32:10,270 --> 00:32:17,080
one character but in case if we want to

00:32:14,140 --> 00:32:19,179
think about it from the fellow out the

00:32:17,080 --> 00:32:22,420
matin point of view we can think that

00:32:19,179 --> 00:32:25,570
the whole area is one floor automatic in

00:32:22,420 --> 00:32:27,850
when there is no hero no no person then

00:32:25,570 --> 00:32:32,710
the symbol of the mountain stays stable

00:32:27,850 --> 00:32:35,940
but entering the area is like adding a

00:32:32,710 --> 00:32:38,440
new data changing some cells and that

00:32:35,940 --> 00:32:41,950
triggers the filler automaton into the

00:32:38,440 --> 00:32:44,679
chaotic state and given if the rules are

00:32:41,950 --> 00:32:47,620
good then the outer mutton wants to

00:32:44,679 --> 00:32:51,190
become stable again and it can do it by

00:32:47,620 --> 00:32:53,970
killing the hero what we get for free in

00:32:51,190 --> 00:32:56,110
this situation is that our entities

00:32:53,970 --> 00:32:59,140
communicate with each other all the time

00:32:56,110 --> 00:33:03,340
and in case of like a classical approach

00:32:59,140 --> 00:33:07,990
the teamwork between NPCs is usually

00:33:03,340 --> 00:33:12,940
very complicated thing so that's

00:33:07,990 --> 00:33:16,179
basically it this is linked to the place

00:33:12,940 --> 00:33:19,240
on github where you can see all the code

00:33:16,179 --> 00:33:22,929
and the documentation of the project I'm

00:33:19,240 --> 00:33:25,780
trying to work the same to do the same

00:33:22,929 --> 00:33:30,030
in the rest and make it in make it into

00:33:25,780 --> 00:33:32,920
like more videogame approach we trust

00:33:30,030 --> 00:33:34,600
you can also see because salado mutton

00:33:32,920 --> 00:33:37,179
is like just a concept it doesn't matter

00:33:34,600 --> 00:33:40,710
which language he use so we can also see

00:33:37,179 --> 00:33:43,240
how it translates in Scala and how is

00:33:40,710 --> 00:33:47,500
the rest approach different or similar

00:33:43,240 --> 00:33:50,650
to it for the whole presentation

00:33:47,500 --> 00:33:53,980
I used a book by Andrew Larkin skillful

00:33:50,650 --> 00:33:56,020
automata a discrete universe you can

00:33:53,980 --> 00:34:00,280
find me on Twitter you can find me of

00:33:56,020 --> 00:34:04,470
wire if you of wire so differ the

00:34:00,280 --> 00:34:04,470
handles and thank you very much

00:34:12,310 --> 00:34:19,540
stealth questions Oh

00:34:24,850 --> 00:34:38,540
how did you make your presentation yes

00:34:29,350 --> 00:34:42,649
okay if you want to know more difficult

00:34:38,540 --> 00:34:45,380
video scribe it's usually used for sorta

00:34:42,649 --> 00:34:47,300
educational videos on YouTube but as you

00:34:45,380 --> 00:34:57,850
can see something like this is also

00:34:47,300 --> 00:35:00,940
possible okay well thank you very much

00:34:57,850 --> 00:35:00,940

YouTube URL: https://www.youtube.com/watch?v=vXNClgyHud0


