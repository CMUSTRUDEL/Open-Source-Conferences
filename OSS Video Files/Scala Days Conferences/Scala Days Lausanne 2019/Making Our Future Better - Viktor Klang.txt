Title: Making Our Future Better - Viktor Klang
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/making-our-future-better
Captions: 
	00:00:00,000 --> 00:00:04,950
a lot of people in the audience I'm I'm

00:00:03,480 --> 00:00:07,170
very thankful for that given how many

00:00:04,950 --> 00:00:10,410
good talks there are at the same slot as

00:00:07,170 --> 00:00:12,179
this one so thank you welcome I have a

00:00:10,410 --> 00:00:15,920
lot of material that I want to get

00:00:12,179 --> 00:00:19,320
through and I always am pessimistic

00:00:15,920 --> 00:00:22,109
about how much material I have given how

00:00:19,320 --> 00:00:24,689
much time I have so we'll see how things

00:00:22,109 --> 00:00:28,140
end up I want to get through as much as

00:00:24,689 --> 00:00:32,700
possible of course as always if you have

00:00:28,140 --> 00:00:34,649
a question I'd rather you sort of raise

00:00:32,700 --> 00:00:36,690
your hand and let's answer that

00:00:34,649 --> 00:00:38,219
immediately because some other person

00:00:36,690 --> 00:00:40,079
here could have the same problem or

00:00:38,219 --> 00:00:43,410
would like to have an explanation as

00:00:40,079 --> 00:00:47,309
well and that helps everybody if as many

00:00:43,410 --> 00:00:52,110
as possible are up to speed or have the

00:00:47,309 --> 00:00:54,329
same shared context so yeah cool so we

00:00:52,110 --> 00:00:59,399
see we have a few more people arriving

00:00:54,329 --> 00:01:01,920
I'll let you grab a seat so this

00:00:59,399 --> 00:01:05,760
presentation is about making our future

00:01:01,920 --> 00:01:08,630
better and I think whenever there is a

00:01:05,760 --> 00:01:11,750
session on futures you have to have some

00:01:08,630 --> 00:01:14,580
half good half bad pun in the title so

00:01:11,750 --> 00:01:19,619
this is my this is my attempt at doing

00:01:14,580 --> 00:01:24,390
that how many of you know who I am since

00:01:19,619 --> 00:01:27,780
before do I need to okay fair amount so

00:01:24,390 --> 00:01:30,450
I've been doing concurrency in in on the

00:01:27,780 --> 00:01:34,650
JVM and in Scala for basically the

00:01:30,450 --> 00:01:38,040
better part of a decade and it's been a

00:01:34,650 --> 00:01:40,680
fun ride so I would like to share with

00:01:38,040 --> 00:01:46,020
you today the latest improvements for

00:01:40,680 --> 00:01:49,009
Scala 213 but before that I think we

00:01:46,020 --> 00:01:51,570
need to go through how we got here I

00:01:49,009 --> 00:01:54,869
also had while doing this presentation I

00:01:51,570 --> 00:01:56,820
had a really scary thought that I might

00:01:54,869 --> 00:02:02,549
be the one who knows most about the

00:01:56,820 --> 00:02:03,240
future in the world so please get

00:02:02,549 --> 00:02:05,549
involved

00:02:03,240 --> 00:02:07,770
have a look at the implementation and

00:02:05,549 --> 00:02:09,810
stuff and that would be awesome I don't

00:02:07,770 --> 00:02:13,530
want to be I don't want to be the one

00:02:09,810 --> 00:02:16,110
who knows the most about the future so

00:02:13,530 --> 00:02:17,820
I worked for light Bend I've been

00:02:16,110 --> 00:02:21,120
working out light band since before the

00:02:17,820 --> 00:02:24,390
dawn of time basically I was a part of

00:02:21,120 --> 00:02:27,210
scalable solutions with Jonas paneer and

00:02:24,390 --> 00:02:31,080
then we fused with Scala solutions so we

00:02:27,210 --> 00:02:34,850
are a Swiss Swedish fusion which is

00:02:31,080 --> 00:02:39,510
pretty cool and now we're live end so

00:02:34,850 --> 00:02:41,850
let's have a look at what futures are

00:02:39,510 --> 00:02:44,850
how many how many of you have never used

00:02:41,850 --> 00:02:49,070
futures at all in Scala never not at all

00:02:44,850 --> 00:02:53,940
no we got one we got two cool all right

00:02:49,070 --> 00:02:56,940
so then you know this already a future

00:02:53,940 --> 00:03:01,560
in Scala represents the capability to

00:02:56,940 --> 00:03:05,060
read a value at some time so it's

00:03:01,560 --> 00:03:08,220
essentially a value detached from time

00:03:05,060 --> 00:03:10,290
which is pretty cool because if we can

00:03:08,220 --> 00:03:11,790
remove time from the equation then we

00:03:10,290 --> 00:03:16,860
can program with things with that we do

00:03:11,790 --> 00:03:19,850
not have which is also pretty cool and a

00:03:16,860 --> 00:03:23,519
problem is of course represents an

00:03:19,850 --> 00:03:25,980
obligation to write some value at some

00:03:23,519 --> 00:03:29,420
point in time why is this important

00:03:25,980 --> 00:03:31,350
so if you have a reference to a promise

00:03:29,420 --> 00:03:35,580
how do you know what you're supposed to

00:03:31,350 --> 00:03:37,080
do with it well if you have a reference

00:03:35,580 --> 00:03:40,470
to a promise then somebody has given you

00:03:37,080 --> 00:03:42,060
the obligation to complete it so unless

00:03:40,470 --> 00:03:43,410
you hand off that obligation to

00:03:42,060 --> 00:03:45,390
something else then it's very likely

00:03:43,410 --> 00:03:49,430
that if you do not complete that thing

00:03:45,390 --> 00:03:49,430
then something will not happen

00:03:52,190 --> 00:03:59,910
one question that arrives quite

00:03:57,570 --> 00:04:02,579
frequently on Stack Overflow at Stack

00:03:59,910 --> 00:04:08,000
Overflow and on Twitter and everywhere

00:04:02,579 --> 00:04:08,000
else is why are not futures cancelable

00:04:08,480 --> 00:04:17,100
well if a future were cancelable then it

00:04:13,500 --> 00:04:19,410
would mean that anybody having that

00:04:17,100 --> 00:04:21,900
capability to write to read a value

00:04:19,410 --> 00:04:24,240
would also have the capability to write

00:04:21,900 --> 00:04:26,550
that value they would have the

00:04:24,240 --> 00:04:29,639
capability of canceling it

00:04:26,550 --> 00:04:31,800
so if you've created a promise and

00:04:29,639 --> 00:04:34,979
you've handed out futures to that

00:04:31,800 --> 00:04:37,500
promise and then somewhere somebody with

00:04:34,979 --> 00:04:40,560
that future decides to cancel it they

00:04:37,500 --> 00:04:42,319
will cancel it for everybody so that

00:04:40,560 --> 00:04:44,789
would make really hard to reason about

00:04:42,319 --> 00:04:47,460
what you could be doing with your future

00:04:44,789 --> 00:04:50,789
would you need to sort of like copy it

00:04:47,460 --> 00:04:52,349
somehow and pass a copy so it would be

00:04:50,789 --> 00:04:54,210
really hard to reason about it so it's

00:04:52,349 --> 00:05:01,080
really good that futures are for reading

00:04:54,210 --> 00:05:03,630
promises are for writing a long while

00:05:01,080 --> 00:05:07,169
ago now we introduced futures and

00:05:03,630 --> 00:05:10,229
promises into scholar to nine via the

00:05:07,169 --> 00:05:12,930
scholar improvement proposal 14 and you

00:05:10,229 --> 00:05:14,490
can you can read the link down below if

00:05:12,930 --> 00:05:17,639
you want to have more background on it

00:05:14,490 --> 00:05:20,340
but I think the main key was to get a

00:05:17,639 --> 00:05:21,860
standardized set of interfaces so that

00:05:20,340 --> 00:05:25,680
we could have maximum interoperability

00:05:21,860 --> 00:05:28,139
for scholar applications there were

00:05:25,680 --> 00:05:30,349
numerous promise and future

00:05:28,139 --> 00:05:32,669
implementations at the time and

00:05:30,349 --> 00:05:35,310
everybody would essentially have to

00:05:32,669 --> 00:05:39,090
write converters between all of them and

00:05:35,310 --> 00:05:41,159
that was not feasible also of course

00:05:39,090 --> 00:05:43,650
it's not enough to just have the

00:05:41,159 --> 00:05:45,389
interfaces you need to have some sort of

00:05:43,650 --> 00:05:46,949
canonical implementation otherwise you

00:05:45,389 --> 00:05:49,650
would end up not knowing which

00:05:46,949 --> 00:05:51,300
implementation to use so there is an

00:05:49,650 --> 00:05:54,509
implementation in the standard library

00:05:51,300 --> 00:05:56,310
so that as many as possible can use

00:05:54,509 --> 00:05:58,050
futures and promises without going

00:05:56,310 --> 00:06:04,500
outside of the sakala standard library

00:05:58,050 --> 00:06:07,289
to do so I don't know if you've thought

00:06:04,500 --> 00:06:10,229
about it but essentially with futures

00:06:07,289 --> 00:06:12,680
you have three distinct api's rolled

00:06:10,229 --> 00:06:12,680
into one

00:06:17,060 --> 00:06:23,080
we have a palling API you can check

00:06:19,910 --> 00:06:27,830
whether a future has been completed or

00:06:23,080 --> 00:06:30,970
if there is a value at this moment so

00:06:27,830 --> 00:06:30,970
that is essentially doing poly

00:06:31,660 --> 00:06:37,850
there's also callback based api's they

00:06:35,750 --> 00:06:41,690
are sort of we have deprecated on

00:06:37,850 --> 00:06:44,420
success and on failure mainly because

00:06:41,690 --> 00:06:47,750
you can do future dot failed dot for

00:06:44,420 --> 00:06:50,240
each if you want to just react to the

00:06:47,750 --> 00:06:52,340
failure and then for each is basically

00:06:50,240 --> 00:06:56,630
on success so you could just use that

00:06:52,340 --> 00:06:59,169
instead but we also have beyond Pauling

00:06:56,630 --> 00:07:03,770
and callbacks

00:06:59,169 --> 00:07:05,360
we have transformations transformations

00:07:03,770 --> 00:07:09,400
that you have probably used many many

00:07:05,360 --> 00:07:16,040
times like mapping over future

00:07:09,400 --> 00:07:20,000
recovering from a failure on a future so

00:07:16,040 --> 00:07:22,460
three distinct API sin one sometimes you

00:07:20,000 --> 00:07:25,640
need one of them the other time you need

00:07:22,460 --> 00:07:28,790
another so they're all necessary some

00:07:25,640 --> 00:07:31,550
for interoperability and some for just

00:07:28,790 --> 00:07:37,460
having clean code or having a code that

00:07:31,550 --> 00:07:41,030
you can reason about so let's just have

00:07:37,460 --> 00:07:45,979
a very trivial example of using futures

00:07:41,030 --> 00:07:47,180
and promises so essentially we need to

00:07:45,979 --> 00:07:50,300
be able to create some sort of promise

00:07:47,180 --> 00:07:53,600
and we need to be able to obtain The

00:07:50,300 --> 00:07:55,669
Associated future with that promise and

00:07:53,600 --> 00:07:57,919
then of course if we have to be able to

00:07:55,669 --> 00:07:59,900
be detached from time then we need to be

00:07:57,919 --> 00:08:02,600
able to operate on that value even

00:07:59,900 --> 00:08:04,940
though we don't have it so map in this

00:08:02,600 --> 00:08:08,600
case we'll do an upper case on that

00:08:04,940 --> 00:08:10,970
value once it's available and then we

00:08:08,600 --> 00:08:12,979
complete that promise with a string and

00:08:10,970 --> 00:08:16,430
then we return the future that

00:08:12,979 --> 00:08:18,560
represents the transformed value and in

00:08:16,430 --> 00:08:24,770
this case it's a very roundabout way of

00:08:18,560 --> 00:08:26,930
doing future successful to write but

00:08:24,770 --> 00:08:31,120
there are quite a few things involved

00:08:26,930 --> 00:08:31,120
here that we haven't talked about yet

00:08:33,060 --> 00:08:41,789
execution context how many of you know

00:08:37,599 --> 00:08:41,789
what an execution context is and does

00:08:42,149 --> 00:08:51,130
basically 2/3 if not more that's great

00:08:45,850 --> 00:08:54,700
because we need to figure out where

00:08:51,130 --> 00:08:57,940
things are executed when they're

00:08:54,700 --> 00:09:01,630
executed and how they're executed so if

00:08:57,940 --> 00:09:04,120
we want to decouple the description of

00:09:01,630 --> 00:09:08,740
some transformation then we also need to

00:09:04,120 --> 00:09:12,190
decouple what does it so an execution

00:09:08,740 --> 00:09:14,560
context is a way of doing that so we

00:09:12,190 --> 00:09:15,610
detach things from time and we detach

00:09:14,560 --> 00:09:18,339
things from the underlying

00:09:15,610 --> 00:09:20,140
implementation so you only need to worry

00:09:18,339 --> 00:09:23,940
about having an execution context in

00:09:20,140 --> 00:09:26,800
scope and there's been quite many

00:09:23,940 --> 00:09:28,959
discussions on when you should be using

00:09:26,800 --> 00:09:31,149
execution context or oh there is so much

00:09:28,959 --> 00:09:34,209
overhead in passing an execution context

00:09:31,149 --> 00:09:36,850
around but the thing is if you don't

00:09:34,209 --> 00:09:38,920
want to be able to say where things are

00:09:36,850 --> 00:09:42,640
executed then how can you reason about

00:09:38,920 --> 00:09:44,440
the program this was just like magically

00:09:42,640 --> 00:09:46,329
the executors somewhere it has like

00:09:44,440 --> 00:09:49,959
infinite resources infinite number of

00:09:46,329 --> 00:09:53,260
threads infinite scalability that's not

00:09:49,959 --> 00:09:55,959
that's not reality so if we want to have

00:09:53,260 --> 00:09:59,079
a very disciplined way of saying this is

00:09:55,959 --> 00:10:01,779
what I want to want to do and here's

00:09:59,079 --> 00:10:03,790
where that happens because otherwise it

00:10:01,779 --> 00:10:09,430
will happen either on the thread that

00:10:03,790 --> 00:10:11,769
completes the promise or at the time you

00:10:09,430 --> 00:10:14,079
add the callback because it was already

00:10:11,769 --> 00:10:16,420
completed at that time so then you don't

00:10:14,079 --> 00:10:19,149
know when you add a callback am I also

00:10:16,420 --> 00:10:21,790
going to be running this code maybe I

00:10:19,149 --> 00:10:24,190
don't want to be running this code or

00:10:21,790 --> 00:10:26,709
perhaps the thing that is completing the

00:10:24,190 --> 00:10:28,959
promise is not equipped to do this heavy

00:10:26,709 --> 00:10:32,320
lifting that this transformation is

00:10:28,959 --> 00:10:34,660
doing so this is a very sort of this is

00:10:32,320 --> 00:10:36,490
how we do it there is a single thing

00:10:34,660 --> 00:10:37,899
that controls it and if you want to

00:10:36,490 --> 00:10:40,600
think about it it's really an

00:10:37,899 --> 00:10:43,290
interpreter so the execution context

00:10:40,600 --> 00:10:47,790
interprets the transformation

00:10:43,290 --> 00:10:50,310
some point it's just that the thing to

00:10:47,790 --> 00:10:56,310
be interpreted is an algebra of runnable

00:10:50,310 --> 00:10:58,709
it's not super super duper advanced so

00:10:56,310 --> 00:11:01,560
on the topic of execution context I

00:10:58,709 --> 00:11:04,019
think it's very it's very common that

00:11:01,560 --> 00:11:06,089
people don't know how they should be

00:11:04,019 --> 00:11:07,980
threading their execution context in

00:11:06,089 --> 00:11:10,589
their code so like should I be passing

00:11:07,980 --> 00:11:13,829
it in or should I create one or how do i

00:11:10,589 --> 00:11:15,269
how do I manage execution context and so

00:11:13,829 --> 00:11:18,060
I just thought I'd just throw this in

00:11:15,269 --> 00:11:21,959
there so that you you just know what my

00:11:18,060 --> 00:11:25,639
recommendation is so if the component

00:11:21,959 --> 00:11:29,190
itself should control the execution then

00:11:25,639 --> 00:11:32,850
you have some method within that thing

00:11:29,190 --> 00:11:34,290
that returns the execution context so if

00:11:32,850 --> 00:11:37,139
it's in its own control then you could

00:11:34,290 --> 00:11:40,170
instantiate it or whatever it's it's

00:11:37,139 --> 00:11:43,230
something it shouldn't be passed in on

00:11:40,170 --> 00:11:44,550
the other hand if the instantiate er of

00:11:43,230 --> 00:11:46,190
that component should control it then of

00:11:44,550 --> 00:11:49,920
course it needs to be some sort of

00:11:46,190 --> 00:11:53,819
constructor parameter so that you can

00:11:49,920 --> 00:11:55,290
pass it in and last but not least it's

00:11:53,819 --> 00:11:57,930
not uncommon at all that you want to

00:11:55,290 --> 00:12:00,569
have the caller of the component be

00:11:57,930 --> 00:12:01,620
specifying the execution context so then

00:12:00,569 --> 00:12:04,980
of course you make it an implicit

00:12:01,620 --> 00:12:07,740
parameter to that method so these are my

00:12:04,980 --> 00:12:09,779
recommendations and they've served me

00:12:07,740 --> 00:12:12,839
quite well and it's it's rather easy to

00:12:09,779 --> 00:12:19,740
reason about there's not much conflict

00:12:12,839 --> 00:12:21,120
in there so the global execution context

00:12:19,740 --> 00:12:23,100
which is the only one that comes out of

00:12:21,120 --> 00:12:26,790
the box that's the only thing that is

00:12:23,100 --> 00:12:29,040
already there and it just works it's

00:12:26,790 --> 00:12:31,230
usually based on or it's currently based

00:12:29,040 --> 00:12:34,050
on the fork joint pool in Java util

00:12:31,230 --> 00:12:37,410
concurrent and what's good about that is

00:12:34,050 --> 00:12:40,019
that it has a means of doing controlled

00:12:37,410 --> 00:12:42,839
blocking and it's also a fairly

00:12:40,019 --> 00:12:46,649
performant and it's a very sort of

00:12:42,839 --> 00:12:49,470
handling most cases rather well there is

00:12:46,649 --> 00:12:52,439
no sort of generic optimal solution to

00:12:49,470 --> 00:12:55,280
thread scheduling or task scheduling but

00:12:52,439 --> 00:12:56,900
it's a fairly good compromise

00:12:55,280 --> 00:12:59,030
and it can do these sort of evasive

00:12:56,900 --> 00:13:01,690
actions when there is blocking involved

00:12:59,030 --> 00:13:04,550
in order to keep liveness and throughput

00:13:01,690 --> 00:13:07,100
available so you don't necessarily make

00:13:04,550 --> 00:13:10,720
everything grind to a halt if you use

00:13:07,100 --> 00:13:15,800
blocking but what you might not know is

00:13:10,720 --> 00:13:18,320
that it's possible to configure the

00:13:15,800 --> 00:13:20,210
global execution context how many of you

00:13:18,320 --> 00:13:23,440
have changed this configuration in their

00:13:20,210 --> 00:13:26,270
applications a fair number of people

00:13:23,440 --> 00:13:27,980
those of you who haven't I really

00:13:26,270 --> 00:13:30,920
recommend having a look at this because

00:13:27,980 --> 00:13:33,050
it's really hard to provide the best

00:13:30,920 --> 00:13:36,700
default there's no such thing as a best

00:13:33,050 --> 00:13:38,870
default there's just a compromise and

00:13:36,700 --> 00:13:41,420
the standard library doesn't know what

00:13:38,870 --> 00:13:42,950
your application is doing so of course

00:13:41,420 --> 00:13:44,990
you're going to know more about where

00:13:42,950 --> 00:13:46,310
app what your application is doing then

00:13:44,990 --> 00:13:49,490
than I am

00:13:46,310 --> 00:13:51,460
so if you tweak those parameters you

00:13:49,490 --> 00:13:54,440
might actually get better performance or

00:13:51,460 --> 00:13:58,310
better fairness in your program so it's

00:13:54,440 --> 00:13:59,990
worth having a look at that something

00:13:58,310 --> 00:14:03,950
which is fairly common as well as that

00:13:59,990 --> 00:14:06,200
if you have poor performance how many of

00:14:03,950 --> 00:14:10,990
you have increased the number of threads

00:14:06,200 --> 00:14:14,690
I will I will raise my hand

00:14:10,990 --> 00:14:17,390
it's very infrequent that that will

00:14:14,690 --> 00:14:19,100
actually help anything because you're

00:14:17,390 --> 00:14:22,339
increasing contention you're increasing

00:14:19,100 --> 00:14:24,890
overhead in scheduling and if you're

00:14:22,339 --> 00:14:29,690
essentially blocking then you're not

00:14:24,890 --> 00:14:31,610
doing anything so try if you have poor

00:14:29,690 --> 00:14:33,620
performance and you might be CPU bound

00:14:31,610 --> 00:14:39,320
it might actually be better to lower the

00:14:33,620 --> 00:14:42,050
number to like point six factor so you

00:14:39,320 --> 00:14:44,060
have sixty percent of your available

00:14:42,050 --> 00:14:47,210
course and the reason is fairly simple

00:14:44,060 --> 00:14:49,550
because when you run on a platform that

00:14:47,210 --> 00:14:51,020
does garbage collection then there are

00:14:49,550 --> 00:14:53,150
garbage collecting threads that also

00:14:51,020 --> 00:14:54,830
need to be able to run so if your

00:14:53,150 --> 00:14:56,540
application is starving the garbage

00:14:54,830 --> 00:14:59,660
collector then of course it's going to

00:14:56,540 --> 00:15:01,220
take longer so it might actually make

00:14:59,660 --> 00:15:03,380
sense to lower the number of threads at

00:15:01,220 --> 00:15:06,800
times just to see how the application

00:15:03,380 --> 00:15:09,080
behaves did that change I've seen cases

00:15:06,800 --> 00:15:12,380
where there have been like 600

00:15:09,080 --> 00:15:16,160
and I don't think that that will perform

00:15:12,380 --> 00:15:18,410
as well as doing something else how many

00:15:16,160 --> 00:15:22,459
of you know what the max extra threats

00:15:18,410 --> 00:15:28,910
thing does and anybody yeah yeah what

00:15:22,459 --> 00:15:30,890
does it do yes so it will limit the

00:15:28,910 --> 00:15:34,490
number of threats that are spawned when

00:15:30,890 --> 00:15:36,740
you do manage blocking so sometimes if

00:15:34,490 --> 00:15:39,860
you have lots of looking occuring you

00:15:36,740 --> 00:15:42,200
want to be able to maintain the system's

00:15:39,860 --> 00:15:43,579
responsiveness and that means that you

00:15:42,200 --> 00:15:45,829
have to spawn a new thread that sort of

00:15:43,579 --> 00:15:48,140
takes over for the current thread for as

00:15:45,829 --> 00:15:49,820
long as it's booking and of course you

00:15:48,140 --> 00:15:51,350
can't just keep on doing that because

00:15:49,820 --> 00:15:52,880
then you will run out our threads and

00:15:51,350 --> 00:15:55,910
then your application will completely

00:15:52,880 --> 00:15:58,640
crash so there needs to be a sealing to

00:15:55,910 --> 00:16:01,880
this and the current ceiling is 256

00:15:58,640 --> 00:16:05,089
threads so once you go beyond that it

00:16:01,880 --> 00:16:06,800
will not create more threads for you but

00:16:05,089 --> 00:16:09,399
it's a good thing to have to sort of

00:16:06,800 --> 00:16:12,230
handle smoothing out some of the

00:16:09,399 --> 00:16:17,000
situations where there are a lot of

00:16:12,230 --> 00:16:21,430
concurrently blocking things so how do

00:16:17,000 --> 00:16:25,690
we know that something is blocking well

00:16:21,430 --> 00:16:29,029
we don't so you'll have to tell us and

00:16:25,690 --> 00:16:32,480
there are two ways of doing that so one

00:16:29,029 --> 00:16:35,570
is a weight and one is to use the

00:16:32,480 --> 00:16:37,220
blocking sort of construct and blocking

00:16:35,570 --> 00:16:38,779
is defined in Scala concurrent so you

00:16:37,220 --> 00:16:40,880
can just write walking and then a block

00:16:38,779 --> 00:16:44,300
and then do the thing that does the

00:16:40,880 --> 00:16:46,910
blocking within there and the reason we

00:16:44,300 --> 00:16:50,870
did this and there's been both

00:16:46,910 --> 00:16:54,560
complaints but also some appreciation

00:16:50,870 --> 00:16:57,740
for this is that once blocking is seen

00:16:54,560 --> 00:17:01,040
tactically obvious then it's easier to

00:16:57,740 --> 00:17:02,540
reason about the program because if you

00:17:01,040 --> 00:17:04,400
call something and you don't know that

00:17:02,540 --> 00:17:07,069
it's blocking then how will somebody who

00:17:04,400 --> 00:17:08,839
does the code review know that if you

00:17:07,069 --> 00:17:10,459
know that it's blocking by reading the

00:17:08,839 --> 00:17:12,530
code then it's much easier to reason

00:17:10,459 --> 00:17:15,770
about and then somebody can say hey I'm

00:17:12,530 --> 00:17:16,100
really sorry we can't block here we just

00:17:15,770 --> 00:17:21,319
can't

00:17:16,100 --> 00:17:22,970
it won't work or you disallow it hey we

00:17:21,319 --> 00:17:26,450
don't allow calling away

00:17:22,970 --> 00:17:29,240
dot result in our code base but then

00:17:26,450 --> 00:17:33,040
there's a single method to essentially

00:17:29,240 --> 00:17:39,140
check for so it's also a means of doing

00:17:33,040 --> 00:17:41,870
doing more analysis on your code but how

00:17:39,140 --> 00:17:43,370
do we know this like we have this how

00:17:41,870 --> 00:17:46,040
does this information that something is

00:17:43,370 --> 00:17:48,140
blocking how is that transferred to the

00:17:46,040 --> 00:17:50,210
execution context well so we have

00:17:48,140 --> 00:17:51,680
something called block context and they

00:17:50,210 --> 00:17:53,360
are installable I won't go through the

00:17:51,680 --> 00:17:56,750
code here but I think it's worth knowing

00:17:53,360 --> 00:17:59,690
so for the the global execution context

00:17:56,750 --> 00:18:02,420
we implement block context and what that

00:17:59,690 --> 00:18:04,880
block context does is that it wraps

00:18:02,420 --> 00:18:06,980
everything in a fork/join pool managed

00:18:04,880 --> 00:18:08,960
blocker which is the construct that the

00:18:06,980 --> 00:18:13,550
fork/join pool uses to essentially

00:18:08,960 --> 00:18:16,130
manage blocking right and what you could

00:18:13,550 --> 00:18:18,710
do though is that I mean I've done it

00:18:16,130 --> 00:18:22,430
you can create a block context that this

00:18:18,710 --> 00:18:24,800
allows blocking because you you are able

00:18:22,430 --> 00:18:26,270
to intercept a chunk of code that will

00:18:24,800 --> 00:18:30,220
do blocking and instead of running that

00:18:26,270 --> 00:18:30,220
you can just throw an exception nope

00:18:31,210 --> 00:18:36,230
so I haven't seen many uses in practice

00:18:34,610 --> 00:18:44,240
but I think it's useful to know that

00:18:36,230 --> 00:18:47,420
it's there however sometimes blocking is

00:18:44,240 --> 00:18:48,920
unavoidable and of course my my

00:18:47,420 --> 00:18:51,350
recommendation is always like do not

00:18:48,920 --> 00:18:53,090
block but sometimes you have no choice

00:18:51,350 --> 00:18:56,630
you're calling some third party API that

00:18:53,090 --> 00:18:58,250
you are not in control of you have to

00:18:56,630 --> 00:19:00,410
return a strict result because you're

00:18:58,250 --> 00:19:04,430
implementing some sort of interface and

00:19:00,410 --> 00:19:07,220
it only deals with strict results so you

00:19:04,430 --> 00:19:09,620
can't return the future on the other

00:19:07,220 --> 00:19:12,140
hand I think there is a class of

00:19:09,620 --> 00:19:15,970
blocking that doesn't get any attention

00:19:12,140 --> 00:19:18,500
at all and that is very CPU intensive

00:19:15,970 --> 00:19:21,530
operations that are not locking in the

00:19:18,500 --> 00:19:23,990
sense of it's changing the thread state

00:19:21,530 --> 00:19:28,760
if you so well it's just gonna take a

00:19:23,990 --> 00:19:32,000
long while to get through this so from

00:19:28,760 --> 00:19:33,830
the sake of the runtime for all intents

00:19:32,000 --> 00:19:37,049
and purposes it is blocking it is

00:19:33,830 --> 00:19:40,139
preventing progress on this thread of

00:19:37,049 --> 00:19:42,690
execution nothing else can run while

00:19:40,139 --> 00:19:44,429
this thing is running on this thread so

00:19:42,690 --> 00:19:45,299
for some things that you know are

00:19:44,429 --> 00:19:47,789
expensive

00:19:45,299 --> 00:19:50,129
you might make sense to have a look at

00:19:47,789 --> 00:19:53,789
what does the application look like if I

00:19:50,129 --> 00:19:56,249
add a blocking construct around it or

00:19:53,789 --> 00:19:58,950
only for documentation like hey this

00:19:56,249 --> 00:20:01,190
thing can be extremely costly and we

00:19:58,950 --> 00:20:07,950
don't want this to risk essentially

00:20:01,190 --> 00:20:11,759
tanking the entire system so the old

00:20:07,950 --> 00:20:15,210
implementation in Scala 2:12 of future

00:20:11,759 --> 00:20:17,759
and promise relied really heavily on

00:20:15,210 --> 00:20:20,700
this combination of having uncomplete

00:20:17,759 --> 00:20:23,399
callbacks and having promises complete

00:20:20,700 --> 00:20:24,600
things and it's a very powerful model

00:20:23,399 --> 00:20:27,379
you can implement all of the

00:20:24,600 --> 00:20:31,769
combinations using this super-powerful

00:20:27,379 --> 00:20:35,369
great but if you do this which we have

00:20:31,769 --> 00:20:37,830
learned then you have like on complete

00:20:35,369 --> 00:20:42,509
and promise all the things you have some

00:20:37,830 --> 00:20:47,009
issues so let me go through this so

00:20:42,509 --> 00:20:51,330
here's how map at least into throw to 12

00:20:47,009 --> 00:20:53,220
used to be implemented so we use

00:20:51,330 --> 00:20:58,679
transform and transform takes a function

00:20:53,220 --> 00:21:00,480
from a try to a try and in this case the

00:20:58,679 --> 00:21:04,230
try will be either the success or the

00:21:00,480 --> 00:21:06,029
failure of the current future and map of

00:21:04,230 --> 00:21:08,100
course only applies the function if it's

00:21:06,029 --> 00:21:13,769
a success and then it returns another

00:21:08,100 --> 00:21:16,429
another another try try of try so yeah

00:21:13,769 --> 00:21:20,070
this is this is how you implement map

00:21:16,429 --> 00:21:22,200
it's super useful well it doesn't really

00:21:20,070 --> 00:21:23,460
do anything just delegate sit right you

00:21:22,200 --> 00:21:25,980
can't really say that oh it's super easy

00:21:23,460 --> 00:21:27,960
to implement map because this is not

00:21:25,980 --> 00:21:29,669
implementing map this is just using

00:21:27,960 --> 00:21:32,700
something to implement map so let's

00:21:29,669 --> 00:21:35,460
implement map so then we need to

00:21:32,700 --> 00:21:39,779
implement transform and here it gets a

00:21:35,460 --> 00:21:41,910
bit more difficult than the previous

00:21:39,779 --> 00:21:45,730
example right

00:21:41,910 --> 00:21:46,510
so we need to take some create some new

00:21:45,730 --> 00:21:48,370
promise

00:21:46,510 --> 00:21:51,070
the default promise is the default

00:21:48,370 --> 00:21:54,100
implementation in the codebase and of

00:21:51,070 --> 00:21:55,900
course this is the current future so

00:21:54,100 --> 00:21:59,380
when the current future gets completed

00:21:55,900 --> 00:22:02,550
we will take the result and we will

00:21:59,380 --> 00:22:07,480
complete the promise that we created

00:22:02,550 --> 00:22:11,050
with the result of the result having

00:22:07,480 --> 00:22:14,290
been applied to some function f and of

00:22:11,050 --> 00:22:17,590
course F can throw exceptions or even

00:22:14,290 --> 00:22:19,750
errors so we need to wrap this around a

00:22:17,590 --> 00:22:22,120
try-catch and we need to make sure that

00:22:19,750 --> 00:22:24,760
we only capture failures that are not

00:22:22,120 --> 00:22:26,290
fail fatal because if there are fatal

00:22:24,760 --> 00:22:34,180
errors we don't want to hide them

00:22:26,290 --> 00:22:36,670
somewhere so any spontaneous reactions

00:22:34,180 --> 00:22:47,380
to why this is not a good idea in

00:22:36,670 --> 00:22:50,410
practice how do you deal when there is

00:22:47,380 --> 00:22:51,850
no direct connection between the

00:22:50,410 --> 00:22:55,510
callback and the thing that gets

00:22:51,850 --> 00:22:58,030
completed by the callback how do you

00:22:55,510 --> 00:23:01,480
deal when it's interrupted you don't

00:22:58,030 --> 00:23:02,920
have a runnable like it only takes run

00:23:01,480 --> 00:23:05,830
you can't really say oh I was

00:23:02,920 --> 00:23:09,340
interrupted there's no way to pass that

00:23:05,830 --> 00:23:12,430
information in or when you complete the

00:23:09,340 --> 00:23:15,880
promise and you're trying to submit the

00:23:12,430 --> 00:23:17,410
callback to the execution context what

00:23:15,880 --> 00:23:21,310
if there is a rejected execution

00:23:17,410 --> 00:23:25,180
exception what do you do like I got an

00:23:21,310 --> 00:23:28,180
exception and I have a runnable what do

00:23:25,180 --> 00:23:29,560
I do but also what is the what is the

00:23:28,180 --> 00:23:31,360
overhead of this implementation because

00:23:29,560 --> 00:23:34,810
clearly you need to allocate several

00:23:31,360 --> 00:23:36,970
closures or thunks once you do this you

00:23:34,810 --> 00:23:38,770
need to allocate the promise you need to

00:23:36,970 --> 00:23:40,480
allocate the callback you need to

00:23:38,770 --> 00:23:43,600
probably allocate the function because

00:23:40,480 --> 00:23:45,250
we implement that map as transform so we

00:23:43,600 --> 00:23:47,140
needed to create the transformation

00:23:45,250 --> 00:23:50,740
function so there are quite a bit of

00:23:47,140 --> 00:23:52,770
allocations but also when you write code

00:23:50,740 --> 00:23:56,850
like that

00:23:52,770 --> 00:24:00,029
in your callback how easy is it to

00:23:56,850 --> 00:24:06,360
reason about what gets captured within

00:24:00,029 --> 00:24:08,309
this closure not really right so since

00:24:06,360 --> 00:24:09,929
we use a closure for this it becomes

00:24:08,309 --> 00:24:13,200
harder to reason about what gets

00:24:09,929 --> 00:24:15,750
captured by the by the compiler as

00:24:13,200 --> 00:24:17,370
you're doing this and you might not want

00:24:15,750 --> 00:24:18,779
to capture everything or you might want

00:24:17,370 --> 00:24:20,640
to store things away before because you

00:24:18,779 --> 00:24:24,899
don't want to hold on to memory longer

00:24:20,640 --> 00:24:27,840
than you need so this method of

00:24:24,899 --> 00:24:29,760
implementing it is actually tricky from

00:24:27,840 --> 00:24:31,350
that perspective so there has been a

00:24:29,760 --> 00:24:33,450
couple of cases where it was not

00:24:31,350 --> 00:24:36,990
apparent that something was being held

00:24:33,450 --> 00:24:39,149
onto so memory not memory leaks

00:24:36,990 --> 00:24:40,770
necessarily but a lot of memory just

00:24:39,149 --> 00:24:50,460
hanging around until things got

00:24:40,770 --> 00:24:55,350
completed so for Scala 2:13 what should

00:24:50,460 --> 00:25:00,090
we do what has changed well let's just

00:24:55,350 --> 00:25:02,130
start with something really light how

00:25:00,090 --> 00:25:06,690
many of you have used the apply method

00:25:02,130 --> 00:25:08,549
on a future like future like parentheses

00:25:06,690 --> 00:25:11,700
and doing something a lot of people

00:25:08,549 --> 00:25:13,799
there's a super useful thing super

00:25:11,700 --> 00:25:14,970
useful a lot of people you said even in

00:25:13,799 --> 00:25:18,919
times that they shouldn't be using it

00:25:14,970 --> 00:25:23,220
but it's interesting to know I think

00:25:18,919 --> 00:25:25,890
that the apply method is implemented in

00:25:23,220 --> 00:25:28,140
terms of future unit which is a

00:25:25,890 --> 00:25:32,820
statically allocated future that is

00:25:28,140 --> 00:25:35,580
essentially a successful unit dot map

00:25:32,820 --> 00:25:37,409
and then do nothing with the unit

00:25:35,580 --> 00:25:40,110
because we don't we don't use the unit

00:25:37,409 --> 00:25:42,570
for anything and then just evaluate the

00:25:40,110 --> 00:25:48,750
body of the expression so this is how

00:25:42,570 --> 00:25:51,299
apply is implemented now how how does

00:25:48,750 --> 00:25:54,270
how does it work when you have an

00:25:51,299 --> 00:25:56,190
expression that yields a future like

00:25:54,270 --> 00:25:59,159
it's good for expressions like future

00:25:56,190 --> 00:26:00,870
parentheses expression and parentheses

00:25:59,159 --> 00:26:03,059
but if you have an expression that

00:26:00,870 --> 00:26:04,950
returns a future then you would do this

00:26:03,059 --> 00:26:07,279
and then you would do flattened for

00:26:04,950 --> 00:26:07,279
instance

00:26:07,610 --> 00:26:16,490
so in 213 this has been added to make

00:26:12,960 --> 00:26:18,360
this case really apparent because

00:26:16,490 --> 00:26:20,519
sometimes when you have an expression

00:26:18,360 --> 00:26:22,019
that evaluates to a future you don't

00:26:20,519 --> 00:26:25,740
know if that expression is going to

00:26:22,019 --> 00:26:28,409
throw exceptions so if you want to defer

00:26:25,740 --> 00:26:31,889
or essentially delegate the execution of

00:26:28,409 --> 00:26:34,769
that expression to an execution context

00:26:31,889 --> 00:26:37,230
and get the response as a future of T is

00:26:34,769 --> 00:26:39,419
that a future of future of T then the

00:26:37,230 --> 00:26:41,490
delegate will do that for you and it's

00:26:39,419 --> 00:26:43,320
interesting to note because this is or

00:26:41,490 --> 00:26:46,110
like map and flatmap and being used and

00:26:43,320 --> 00:26:47,250
it's super useful I've seen a lot of

00:26:46,110 --> 00:26:49,139
cases where there are expressions

00:26:47,250 --> 00:26:50,669
returning futures that are evaluated in

00:26:49,139 --> 00:26:52,850
place rather than being transferred

00:26:50,669 --> 00:26:57,179
somewhere else so it's useful to have

00:26:52,850 --> 00:27:00,330
however going through the stuff that we

00:26:57,179 --> 00:27:02,759
wanted to fix right we want to be able

00:27:00,330 --> 00:27:05,340
to handle interruptions really nicely we

00:27:02,759 --> 00:27:06,779
want to have a consistent path for fatal

00:27:05,340 --> 00:27:09,110
exceptions so that we know that there

00:27:06,779 --> 00:27:10,350
aren't different paths that could be

00:27:09,110 --> 00:27:12,539
differently

00:27:10,350 --> 00:27:18,059
it's-it's if you don't want to have that

00:27:12,539 --> 00:27:19,620
especially not for fatal things and we

00:27:18,059 --> 00:27:21,539
need to be able to deal with rejected

00:27:19,620 --> 00:27:23,159
execution exceptions well it's very

00:27:21,539 --> 00:27:25,980
common when you shut down a thread pool

00:27:23,159 --> 00:27:27,629
that it starts to generate rejected

00:27:25,980 --> 00:27:30,419
execution exceptions so you might have a

00:27:27,629 --> 00:27:34,230
phase where certain things just get

00:27:30,419 --> 00:27:36,539
dropped if you don't and I've seen a lot

00:27:34,230 --> 00:27:38,940
of cases where people implement their

00:27:36,539 --> 00:27:42,090
own execution contexts that execute

00:27:38,940 --> 00:27:44,549
things synchronously and they're always

00:27:42,090 --> 00:27:45,990
bugged so I want to fix that and of

00:27:44,549 --> 00:27:48,750
course I mean who doesn't want to

00:27:45,990 --> 00:27:53,070
improve performance of stuff right we

00:27:48,750 --> 00:27:55,620
just want to make it fast so we can

00:27:53,070 --> 00:27:57,960
solve three of these things with

00:27:55,620 --> 00:28:00,059
something called transformation so it

00:27:57,960 --> 00:28:01,980
takes the uncomplete and the promise and

00:28:00,059 --> 00:28:04,289
essentially makes a transformation which

00:28:01,980 --> 00:28:05,820
is both a callback and a promise at the

00:28:04,289 --> 00:28:08,399
same time so now we have this link

00:28:05,820 --> 00:28:10,259
between the two so then we can deal with

00:28:08,399 --> 00:28:12,539
the interruptions we can deal the same

00:28:10,259 --> 00:28:14,340
way with fatal exceptions all the way

00:28:12,539 --> 00:28:18,019
around and we can deal with the rejected

00:28:14,340 --> 00:28:18,019
execution exceptions so that's nice

00:28:18,090 --> 00:28:24,490
but also I've seen a lot of these like a

00:28:22,180 --> 00:28:27,160
lot of these implementations of like

00:28:24,490 --> 00:28:31,090
calling thread execution contexts over

00:28:27,160 --> 00:28:35,590
the years and at first try to ignore it

00:28:31,090 --> 00:28:37,750
and we're at first I actually don't do

00:28:35,590 --> 00:28:39,220
that I told people not to do it and then

00:28:37,750 --> 00:28:41,830
I started ignoring it and then I figured

00:28:39,220 --> 00:28:44,260
well if they're gonna do it then I might

00:28:41,830 --> 00:28:48,190
as well just add something which isn't

00:28:44,260 --> 00:28:50,770
broken at least so I want to warn you

00:28:48,190 --> 00:28:52,990
like don't use it unless you really know

00:28:50,770 --> 00:28:53,650
what you're doing but if you know what

00:28:52,990 --> 00:28:55,290
you're doing

00:28:53,650 --> 00:28:57,940
use this rather than rolling your own

00:28:55,290 --> 00:29:00,850
and it's called parasitic I think it has

00:28:57,940 --> 00:29:02,440
a negative enough connotation so when

00:29:00,850 --> 00:29:06,130
you review somebody's code and there's

00:29:02,440 --> 00:29:09,430
all parasitic that sounds nice I hope I

00:29:06,130 --> 00:29:12,580
hope it gives the right weight to the

00:29:09,430 --> 00:29:16,090
thing yeah it's Syria I'm dead serious

00:29:12,580 --> 00:29:21,520
100% serious this is what happens when

00:29:16,090 --> 00:29:23,920
I'm involved in naming things so so we

00:29:21,520 --> 00:29:27,400
fixed the first three plus the buggy

00:29:23,920 --> 00:29:30,250
things so if we want to have a faster

00:29:27,400 --> 00:29:33,850
future implementation what do we need to

00:29:30,250 --> 00:29:36,760
do well first we need to go through like

00:29:33,850 --> 00:29:39,010
performance optimization 101 like we

00:29:36,760 --> 00:29:41,070
want to reduce allocations we want to

00:29:39,010 --> 00:29:44,160
reduce in directions we want to reduce

00:29:41,070 --> 00:29:46,690
contention especially since future is a

00:29:44,160 --> 00:29:48,400
concurrency or a coordinating data

00:29:46,690 --> 00:29:50,770
structure so we want to reduce

00:29:48,400 --> 00:29:53,320
contention on shared resources on the

00:29:50,770 --> 00:29:54,460
memory bus and of course when you

00:29:53,320 --> 00:29:56,140
optimize something you don't want to

00:29:54,460 --> 00:29:57,940
optimize for the really rare case

00:29:56,140 --> 00:29:59,350
because that would just be a waste of

00:29:57,940 --> 00:30:02,140
time so you want to optimize for the

00:29:59,350 --> 00:30:03,880
really common cases and of course you

00:30:02,140 --> 00:30:06,370
don't know if you succeed or not if you

00:30:03,880 --> 00:30:09,910
don't measure and verify so I've been

00:30:06,370 --> 00:30:12,820
using a jmh for doing the the the

00:30:09,910 --> 00:30:16,090
verification and SBT jmh to actually run

00:30:12,820 --> 00:30:18,250
it and of course we have some

00:30:16,090 --> 00:30:20,200
constraints we can't just optimize

00:30:18,250 --> 00:30:22,270
however we want like make it super fast

00:30:20,200 --> 00:30:24,460
we don't care about anything just make

00:30:22,270 --> 00:30:27,160
it fast we want to preserve lightness

00:30:24,460 --> 00:30:29,680
and we want to preserve fairness so that

00:30:27,160 --> 00:30:31,630
things keep executing and nothing can

00:30:29,680 --> 00:30:34,240
sort of stall everything else for

00:30:31,630 --> 00:30:36,010
as long as they want we want to preserve

00:30:34,240 --> 00:30:37,420
compatibility I mean this is a standard

00:30:36,010 --> 00:30:39,760
library thing of course we want to

00:30:37,420 --> 00:30:41,080
maintain compatibility right but also we

00:30:39,760 --> 00:30:43,540
want to make life easier for ourselves

00:30:41,080 --> 00:30:45,390
and our users to make both the

00:30:43,540 --> 00:30:47,710
implementation and the use of the code

00:30:45,390 --> 00:30:49,170
maintainable so those are the

00:30:47,710 --> 00:30:52,270
constraints that we need to work within

00:30:49,170 --> 00:30:56,470
and of course we have some limitations

00:30:52,270 --> 00:30:57,970
that we've chosen ourselves like future

00:30:56,470 --> 00:31:00,760
promise in execution context their

00:30:57,970 --> 00:31:03,940
traits so their interfaces we allow you

00:31:00,760 --> 00:31:06,460
to implement your own we allow there to

00:31:03,940 --> 00:31:07,930
be multiple implementations and invoke

00:31:06,460 --> 00:31:10,060
interface is always going to be slower

00:31:07,930 --> 00:31:11,470
than invoke static so that's a Chosen

00:31:10,060 --> 00:31:14,620
limitation of performance that we've

00:31:11,470 --> 00:31:17,200
chosen from the outset and also our use

00:31:14,620 --> 00:31:19,090
of Atomics for doing the the save memory

00:31:17,200 --> 00:31:21,580
management they're not as fast as

00:31:19,090 --> 00:31:23,290
register type so if future didn't need

00:31:21,580 --> 00:31:25,630
to deal with concurrency then it could

00:31:23,290 --> 00:31:27,010
be much faster but clearly it wouldn't

00:31:25,630 --> 00:31:29,500
be a future it would just be something

00:31:27,010 --> 00:31:32,470
else like a bar that wouldn't be super

00:31:29,500 --> 00:31:36,250
useful but also we can't do any

00:31:32,470 --> 00:31:39,040
automatic option because we have a

00:31:36,250 --> 00:31:41,320
strict thing and an eager thing and hey

00:31:39,040 --> 00:31:42,970
you could have handed out a reference to

00:31:41,320 --> 00:31:44,620
your old future before you add a

00:31:42,970 --> 00:31:48,970
transformation so we can't just do

00:31:44,620 --> 00:31:52,360
automatic observation however you can do

00:31:48,970 --> 00:31:54,730
manual ops fusion so if you use

00:31:52,360 --> 00:31:57,340
transform and you have a try then you

00:31:54,730 --> 00:32:00,070
can do try map filter collect on the try

00:31:57,340 --> 00:32:03,100
itself and those operations will be

00:32:00,070 --> 00:32:06,160
fused by you it and it's even not more

00:32:03,100 --> 00:32:09,670
colored because it's actually basically

00:32:06,160 --> 00:32:11,200
the same and of course we have our

00:32:09,670 --> 00:32:12,850
feature stability we don't just want to

00:32:11,200 --> 00:32:15,340
drop features for the sake of

00:32:12,850 --> 00:32:18,420
performance like Oh future would be so

00:32:15,340 --> 00:32:22,060
much faster if we didn't have flat map

00:32:18,420 --> 00:32:23,500
that's not that's a no-go all right so

00:32:22,060 --> 00:32:25,810
we can't sacrifice features for

00:32:23,500 --> 00:32:27,310
performance so how do we how do we how

00:32:25,810 --> 00:32:27,850
do we do this if we want to increase

00:32:27,310 --> 00:32:30,400
performance

00:32:27,850 --> 00:32:33,730
well the resulting recipe and I mean I'm

00:32:30,400 --> 00:32:35,560
no I'm no chef ask anybody I'm no chef

00:32:33,730 --> 00:32:38,080
like I will I would go to a restaurant I

00:32:35,560 --> 00:32:41,570
will order in but this is the recipe

00:32:38,080 --> 00:32:43,530
that I I can do performance optimization

00:32:41,570 --> 00:32:47,130
so we need one bucket of these

00:32:43,530 --> 00:32:49,740
transformations and we need 1 tablespoon

00:32:47,130 --> 00:32:53,040
of improved linking a really important

00:32:49,740 --> 00:32:54,570
feature very unknown but it's necessary

00:32:53,040 --> 00:32:55,860
it's like one of these ingredients that

00:32:54,570 --> 00:32:59,070
you don't know what it does

00:32:55,860 --> 00:33:01,140
like bay leaves what does a bay leaf

00:32:59,070 --> 00:33:05,280
nobody knows you just like add a bay

00:33:01,140 --> 00:33:06,990
leaf yeah okay we need two dollops of

00:33:05,280 --> 00:33:08,640
the improved batching executor that's

00:33:06,990 --> 00:33:10,080
also like an implemented implementation

00:33:08,640 --> 00:33:12,000
detail but I'm going to get to why

00:33:10,080 --> 00:33:13,530
that's important next and of course we

00:33:12,000 --> 00:33:18,150
need to improve the callback management

00:33:13,530 --> 00:33:19,200
clearly and of course I mean once you go

00:33:18,150 --> 00:33:21,450
through the code you're just gonna

00:33:19,200 --> 00:33:23,130
sprinkle like season generously with all

00:33:21,450 --> 00:33:25,470
micro optimizations you can come up with

00:33:23,130 --> 00:33:27,270
you just you're good that's what you do

00:33:25,470 --> 00:33:32,300
and of course you need to bake this

00:33:27,270 --> 00:33:36,750
thing so I bake this on my my aunt

00:33:32,300 --> 00:33:39,900
remember remember it can get too hot so

00:33:36,750 --> 00:33:46,560
do it in a well-ventilated area with a

00:33:39,900 --> 00:33:47,580
Tacey right so with our transformation

00:33:46,560 --> 00:33:49,530
we have something which is both a

00:33:47,580 --> 00:33:50,850
callback and a promise that reduces the

00:33:49,530 --> 00:33:52,620
number of allocations we don't need to

00:33:50,850 --> 00:33:55,140
allocate to things we just allocate one

00:33:52,620 --> 00:33:56,910
and that also reduces indirection

00:33:55,140 --> 00:33:58,260
because it's the same thing you don't

00:33:56,910 --> 00:34:03,030
need to jump between things

00:33:58,260 --> 00:34:05,520
and I found out that it's better for

00:34:03,030 --> 00:34:08,150
performance in some cases to you

00:34:05,520 --> 00:34:10,620
manually encode your own dispatch table

00:34:08,150 --> 00:34:12,150
because if you have lots of permutations

00:34:10,620 --> 00:34:14,010
of transformations like imagine if you

00:34:12,150 --> 00:34:15,990
have map transformation flat metal

00:34:14,010 --> 00:34:18,000
transformation all these things as their

00:34:15,990 --> 00:34:21,240
own classes then all the invocations

00:34:18,000 --> 00:34:22,740
would be would be mega morphic and I've

00:34:21,240 --> 00:34:26,010
actually benchmarked it's faster to do

00:34:22,740 --> 00:34:29,490
it yourself for this specific case so I

00:34:26,010 --> 00:34:32,070
did that and of course linking is when

00:34:29,490 --> 00:34:35,370
you link a future to another future so

00:34:32,070 --> 00:34:37,890
essentially if you're doing recursive

00:34:35,370 --> 00:34:41,310
future completion so like this future

00:34:37,890 --> 00:34:42,990
will be result of that future which will

00:34:41,310 --> 00:34:45,180
be a result of that future and that's

00:34:42,990 --> 00:34:46,620
sort of a nested thing then we link the

00:34:45,180 --> 00:34:48,720
futures together so that you can

00:34:46,620 --> 00:34:50,790
complete the first thing that you

00:34:48,720 --> 00:34:53,160
created because when you create futures

00:34:50,790 --> 00:34:55,070
remember you need to hand something back

00:34:53,160 --> 00:34:57,020
before the thing that you created

00:34:55,070 --> 00:34:59,600
done so there's always a link to

00:34:57,020 --> 00:35:01,010
something that you had first and to

00:34:59,600 --> 00:35:04,370
something that will complete it at some

00:35:01,010 --> 00:35:06,380
time those are called links and once you

00:35:04,370 --> 00:35:07,670
have a long chain of links clearly you

00:35:06,380 --> 00:35:09,230
don't want to keep all of that in memory

00:35:07,670 --> 00:35:12,380
so you want to be able to compress those

00:35:09,230 --> 00:35:14,930
links as fast as possible so we're doing

00:35:12,380 --> 00:35:17,150
very aggressive link compression and of

00:35:14,930 --> 00:35:18,980
course once it's done once it does has

00:35:17,150 --> 00:35:21,200
about a half a value then you want to

00:35:18,980 --> 00:35:23,420
remove that link because you want to

00:35:21,200 --> 00:35:25,700
just have it as if it was just a normal

00:35:23,420 --> 00:35:26,930
promise in the first place so we want to

00:35:25,700 --> 00:35:34,160
unlink Thanks

00:35:26,930 --> 00:35:35,570
unlink links aggressively so in order to

00:35:34,160 --> 00:35:38,090
do this yeah

00:35:35,570 --> 00:35:42,050
remember the parasitic thing so for

00:35:38,090 --> 00:35:43,850
synchronous execution context we if we

00:35:42,050 --> 00:35:46,910
want to execute things synchronously

00:35:43,850 --> 00:35:49,370
safely and the reason why the calling

00:35:46,910 --> 00:35:52,130
thread execution context was not not

00:35:49,370 --> 00:35:54,170
safe is because it's not it will blow

00:35:52,130 --> 00:35:56,090
the stack because it doesn't do any

00:35:54,170 --> 00:35:57,470
stack management so if you use the same

00:35:56,090 --> 00:35:59,930
thing recursively then it will blow the

00:35:57,470 --> 00:36:03,500
stack so if you want to be stack safe

00:35:59,930 --> 00:36:05,180
but also want to be fast then we need

00:36:03,500 --> 00:36:06,980
some way of doing that and bashing

00:36:05,180 --> 00:36:10,010
executor is that thing

00:36:06,980 --> 00:36:12,710
so parasitic users batching executor to

00:36:10,010 --> 00:36:14,570
make it as fast as possible for this

00:36:12,710 --> 00:36:18,170
sort of synchronous execution use case

00:36:14,570 --> 00:36:21,110
and the strategy is up until a certain

00:36:18,170 --> 00:36:23,000
number just executed on stack and then

00:36:21,110 --> 00:36:25,730
once you go beyond that threshold you

00:36:23,000 --> 00:36:28,430
will start to allocate a heap a stack

00:36:25,730 --> 00:36:31,700
that you will then fill up and then you

00:36:28,430 --> 00:36:33,260
will essentially grow lazily because you

00:36:31,700 --> 00:36:35,000
want to avoid doing allocations when

00:36:33,260 --> 00:36:37,760
you're in the sort of hot thing that

00:36:35,000 --> 00:36:39,800
spins on the CPU and of course you just

00:36:37,760 --> 00:36:44,320
want to optimize all the hot paths

00:36:39,800 --> 00:36:48,190
across this thing so it does that but

00:36:44,320 --> 00:36:51,380
for async execution context like global

00:36:48,190 --> 00:36:54,170
it's also extending batching executor

00:36:51,380 --> 00:36:56,960
now so you want to do almost the same

00:36:54,170 --> 00:36:59,660
thing you want to grow capacity lazily

00:36:56,960 --> 00:37:02,150
and you of course want to with mice all

00:36:59,660 --> 00:37:04,250
the hot paths but what it does is that

00:37:02,150 --> 00:37:06,080
it submits locally on the current thread

00:37:04,250 --> 00:37:07,430
so it avoids going through the

00:37:06,080 --> 00:37:08,850
submission queue of the thread pool

00:37:07,430 --> 00:37:12,090
unless it has to

00:37:08,850 --> 00:37:14,490
and there is a bit of a resubmit

00:37:12,090 --> 00:37:16,560
interval so if you process X number of

00:37:14,490 --> 00:37:17,760
things then it will schedule itself onto

00:37:16,560 --> 00:37:19,140
the submission queue

00:37:17,760 --> 00:37:24,960
it's essentially like the throughput

00:37:19,140 --> 00:37:27,180
setting in Arcis dispatcher and it's

00:37:24,960 --> 00:37:28,590
possible to to essentially check if

00:37:27,180 --> 00:37:30,090
something should be badged or if it

00:37:28,590 --> 00:37:31,620
should be submitted to the submission

00:37:30,090 --> 00:37:36,420
queue directly so you're in control of

00:37:31,620 --> 00:37:38,970
Arista runs also it hooks in a block

00:37:36,420 --> 00:37:41,160
context so if you do blocking in this

00:37:38,970 --> 00:37:43,830
thing where you've submitted things on

00:37:41,160 --> 00:37:45,510
your local thread you will prevent the

00:37:43,830 --> 00:37:47,310
progress of everything that you kept in

00:37:45,510 --> 00:37:49,170
memory and even if the fork/join pool is

00:37:47,310 --> 00:37:51,540
a work-stealing one it can't steal the

00:37:49,170 --> 00:37:54,120
current tasks so what the block context

00:37:51,540 --> 00:37:55,800
does is that if you did if you do

00:37:54,120 --> 00:37:57,630
blocking like a weight or the booking

00:37:55,800 --> 00:37:59,010
construct when you're running one of

00:37:57,630 --> 00:38:01,500
these things it will actually take that

00:37:59,010 --> 00:38:03,240
batch and say ok then I will put it into

00:38:01,500 --> 00:38:05,880
the submission queue so someone else can

00:38:03,240 --> 00:38:11,550
continue so it provides a little bit of

00:38:05,880 --> 00:38:13,650
safety around us and of course we need

00:38:11,550 --> 00:38:15,300
to store callbacks so we improve that we

00:38:13,650 --> 00:38:17,190
have a custom list because you don't

00:38:15,300 --> 00:38:19,560
want to be allocating lists separately

00:38:17,190 --> 00:38:22,350
from the callbacks so we have our own

00:38:19,560 --> 00:38:24,420
and we found out that it's very common

00:38:22,350 --> 00:38:27,570
for a future to only have a single

00:38:24,420 --> 00:38:30,510
callback so you don't want to allocate

00:38:27,570 --> 00:38:32,280
anything unless you have to so in the

00:38:30,510 --> 00:38:33,930
case of one callback it's just a single

00:38:32,280 --> 00:38:36,660
transformation and you can just run it

00:38:33,930 --> 00:38:39,540
so there's no extra thing there and of

00:38:36,660 --> 00:38:41,100
course we can exploit some facts around

00:38:39,540 --> 00:38:43,020
callbacks like they don't have any

00:38:41,100 --> 00:38:44,910
interdependencies while they are on the

00:38:43,020 --> 00:38:49,590
same future so you can reorder them

00:38:44,910 --> 00:38:51,300
however you want so let's go to the fun

00:38:49,590 --> 00:38:56,740
stuff we have five minutes left

00:38:51,300 --> 00:39:00,700
are you ready come on

00:38:56,740 --> 00:39:04,570
whoo come on alright so for clarity this

00:39:00,700 --> 00:39:06,420
is the machine and this is the software

00:39:04,570 --> 00:39:10,330
that it was running and the settings

00:39:06,420 --> 00:39:12,160
just for understanding there is if you

00:39:10,330 --> 00:39:13,750
look at the link below there's a link to

00:39:12,160 --> 00:39:17,200
the benchmarks that I ran so you can run

00:39:13,750 --> 00:39:18,580
it on your own machine and let's have a

00:39:17,200 --> 00:39:20,650
look at this thing and of course I mean

00:39:18,580 --> 00:39:23,109
all the caveats in the world applies

00:39:20,650 --> 00:39:25,780
here like this is a synthetic benchmark

00:39:23,109 --> 00:39:30,430
it does like your mileage may vary

00:39:25,780 --> 00:39:32,830
carpe diem whatever this is synthetic

00:39:30,430 --> 00:39:34,599
against synthetic so it's interesting

00:39:32,830 --> 00:39:36,160
from that perspective we're comparing

00:39:34,599 --> 00:39:41,800
something to something else

00:39:36,160 --> 00:39:46,869
synthetically so alright so if you're

00:39:41,800 --> 00:39:49,000
ever used and then it's post the post

00:39:46,869 --> 00:39:51,550
state is when you complete the future

00:39:49,000 --> 00:39:52,869
after you run the benchmark so you've

00:39:51,550 --> 00:39:55,210
already done everything and you're

00:39:52,869 --> 00:39:56,830
completing it at the end and pre is when

00:39:55,210 --> 00:39:58,420
it's already completed when you start

00:39:56,830 --> 00:40:00,430
the thing so that we can separate if

00:39:58,420 --> 00:40:03,849
there are any performance differences so

00:40:00,430 --> 00:40:06,520
and then it's between 100 and 200 give

00:40:03,849 --> 00:40:09,690
or take faster and if you need more than

00:40:06,520 --> 00:40:11,680
20 to 40 million operations per second

00:40:09,690 --> 00:40:17,980
you should send me an email and we can

00:40:11,680 --> 00:40:26,349
look at it filter so basically between

00:40:17,980 --> 00:40:28,119
120 and 240 flatmap it's it's been very

00:40:26,349 --> 00:40:29,710
much improved in terms of relative

00:40:28,119 --> 00:40:35,430
performance to the old version so

00:40:29,710 --> 00:40:41,609
between three to five times faster map

00:40:35,430 --> 00:40:46,060
more moderate 124 percent to 200% faster

00:40:41,609 --> 00:40:49,680
recover almost five times faster or

00:40:46,060 --> 00:40:49,680
between three and five times faster

00:40:49,800 --> 00:40:56,140
recover with used to be rather slow but

00:40:53,619 --> 00:41:00,310
it's now between four and seven times

00:40:56,140 --> 00:41:02,349
faster transform which is a very

00:41:00,310 --> 00:41:03,760
important operation because you can do a

00:41:02,349 --> 00:41:08,470
lot of stuff with transform so it's

00:41:03,760 --> 00:41:10,900
between 130 and 200

00:41:08,470 --> 00:41:14,560
percent improvement so it's not like

00:41:10,900 --> 00:41:18,430
it's it's 24% faster it's a hundred and

00:41:14,560 --> 00:41:20,230
twenty four percent faster transform

00:41:18,430 --> 00:41:22,150
with also really useful when you do

00:41:20,230 --> 00:41:24,160
composition with stuff it returns

00:41:22,150 --> 00:41:29,050
features between like three and five

00:41:24,160 --> 00:41:30,670
times faster and sit with also extremely

00:41:29,050 --> 00:41:33,160
useful when you want to combine futures

00:41:30,670 --> 00:41:34,810
and do some transformation it's not that

00:41:33,160 --> 00:41:36,579
much faster because it involves more

00:41:34,810 --> 00:41:38,369
work it you first have to join them and

00:41:36,579 --> 00:41:42,280
then need to apply something but it's

00:41:38,369 --> 00:41:45,520
seventy-seven percent faster and what I

00:41:42,280 --> 00:41:47,140
think is most important is what I call

00:41:45,520 --> 00:41:49,750
the various benchmark and the various

00:41:47,140 --> 00:41:51,430
benchmark does a map followed by a flat

00:41:49,750 --> 00:41:53,020
map full of by a filter followed by a

00:41:51,430 --> 00:41:56,560
sip with followed by transformed full

00:41:53,020 --> 00:41:59,109
byte recover as its operation chain so

00:41:56,560 --> 00:42:01,510
these are very common things to do not

00:41:59,109 --> 00:42:02,800
necessarily just this order but doing

00:42:01,510 --> 00:42:04,540
these sort of sequence of difference

00:42:02,800 --> 00:42:06,790
transformations at the same time and

00:42:04,540 --> 00:42:10,210
that's been improved by approximately

00:42:06,790 --> 00:42:12,310
two hundred percent for common stuff so

00:42:10,210 --> 00:42:14,680
remember that this entire chain you can

00:42:12,310 --> 00:42:18,069
do more than three million times a

00:42:14,680 --> 00:42:20,560
second and this is just running on one

00:42:18,069 --> 00:42:22,810
single core so imagine that you're

00:42:20,560 --> 00:42:28,030
you're you're running on sixteen or

00:42:22,810 --> 00:42:30,069
something so I think just in closing I

00:42:28,030 --> 00:42:31,900
think these are some really encouraging

00:42:30,069 --> 00:42:34,510
results I think that the future is

00:42:31,900 --> 00:42:36,609
looking really bright and I hope you

00:42:34,510 --> 00:42:38,829
have an awesome conference I'm really

00:42:36,609 --> 00:42:41,349
happy to have you all here I hope you

00:42:38,829 --> 00:42:44,050
learned something today I hope I got you

00:42:41,349 --> 00:42:45,940
interested in researching this more and

00:42:44,050 --> 00:42:47,650
I would love your feedback on all this

00:42:45,940 --> 00:42:50,440
so if you have something that uses

00:42:47,650 --> 00:42:51,880
future something which is performant

00:42:50,440 --> 00:42:55,630
since the day for something like that

00:42:51,880 --> 00:42:58,000
try it out try Scala 213 cero out give

00:42:55,630 --> 00:43:00,069
me feedback if there are any regressions

00:42:58,000 --> 00:43:03,430
or bugs that we haven't caught just let

00:43:00,069 --> 00:43:04,180
us know and just take it for a spin and

00:43:03,430 --> 00:43:07,319
tell me what you think

00:43:04,180 --> 00:43:07,319
thank you all for coming

00:43:15,209 --> 00:43:22,239
thank you for the talk and maybe we have

00:43:18,369 --> 00:43:25,299
time for some questions yeah one minute

00:43:22,239 --> 00:43:41,109
just raise your hand and I come for the

00:43:25,299 --> 00:43:45,880
mucus I hear you okay hi

00:43:41,109 --> 00:43:53,170
Hey great work thank you just I'm

00:43:45,880 --> 00:43:56,259
wondering about how predictable these

00:43:53,170 --> 00:43:59,380
futures are on on which thread pool they

00:43:56,259 --> 00:44:01,029
run and especially I've been just last

00:43:59,380 --> 00:44:02,440
week I've been diving into a java

00:44:01,029 --> 00:44:05,469
application debugging because of

00:44:02,440 --> 00:44:07,349
concurrency was a mess and I tried to

00:44:05,469 --> 00:44:12,219
create a simple application with

00:44:07,349 --> 00:44:14,410
computable futures and now even the the

00:44:12,219 --> 00:44:18,549
even when you pass thread pools it's

00:44:14,410 --> 00:44:21,339
completely not that deterministic which

00:44:18,549 --> 00:44:23,769
thread pool this is actually using and

00:44:21,339 --> 00:44:26,589
it even changes if if some computation

00:44:23,769 --> 00:44:28,299
takes longer than the result on which

00:44:26,589 --> 00:44:30,999
thread pools use it even even more

00:44:28,299 --> 00:44:32,979
different than okay so I was just

00:44:30,999 --> 00:44:35,890
wondering you know what you're taking

00:44:32,979 --> 00:44:39,190
this and how how can it be can it be

00:44:35,890 --> 00:44:42,039
even predictive or predictable Oh so

00:44:39,190 --> 00:44:44,170
this is at 100% predictable like it will

00:44:42,039 --> 00:44:48,670
use the execution context that you pass

00:44:44,170 --> 00:44:51,369
to it period so you pass in something it

00:44:48,670 --> 00:44:53,890
will run there but then if you map or

00:44:51,369 --> 00:44:55,449
transform on that future which thread

00:44:53,890 --> 00:44:56,920
pool is then even if it's using the same

00:44:55,449 --> 00:44:59,739
execution context then it will be on the

00:44:56,920 --> 00:45:03,309
same one so it's really predictable and

00:44:59,739 --> 00:45:05,549
if you have a batching version like

00:45:03,309 --> 00:45:09,999
global it will actually run that

00:45:05,549 --> 00:45:12,279
underneath like nested so it can't take

00:45:09,999 --> 00:45:13,959
advantage of stuff like that but it's

00:45:12,279 --> 00:45:15,729
really 100% predictable which is why

00:45:13,959 --> 00:45:17,829
sort of the parasitic one is not

00:45:15,729 --> 00:45:20,440
recommended because that now becomes a

00:45:17,829 --> 00:45:23,380
timing question who completes the

00:45:20,440 --> 00:45:26,740
future or promised by which time but

00:45:23,380 --> 00:45:35,109
this is 100% reliable in terms of where

00:45:26,740 --> 00:45:37,109
it's we're stop fronts so I like to go

00:45:35,109 --> 00:45:42,190
back to the question of consolation

00:45:37,109 --> 00:45:45,670
where are you right here so many people

00:45:42,190 --> 00:45:48,069
yes so I'd like to go back to the

00:45:45,670 --> 00:45:51,130
question of consolation and I think your

00:45:48,069 --> 00:45:52,810
point about basically future being a

00:45:51,130 --> 00:45:54,730
reed and a promise being right is very

00:45:52,810 --> 00:45:56,589
well taken but on the other hand have

00:45:54,730 --> 00:45:58,750
common pattern at least in the

00:45:56,589 --> 00:46:00,490
applications with those and I think I've

00:45:58,750 --> 00:46:03,400
seen in other countries as well is that

00:46:00,490 --> 00:46:05,260
there's only one really thread or one

00:46:03,400 --> 00:46:07,480
caller that takes a reference to the

00:46:05,260 --> 00:46:09,900
future and sometimes it really just

00:46:07,480 --> 00:46:12,700
wants to abandon the computation yeah so

00:46:09,900 --> 00:46:15,670
with a construct like cancelable future

00:46:12,700 --> 00:46:17,829
that's separate from the standard future

00:46:15,670 --> 00:46:20,829
but might have an additional operation

00:46:17,829 --> 00:46:24,520
of cancel the synchronous be something

00:46:20,829 --> 00:46:27,130
that what you saw or I've looked at the

00:46:24,520 --> 00:46:29,470
different sort of options so if you go

00:46:27,130 --> 00:46:32,589
to Victor clang comm slash blog there's

00:46:29,470 --> 00:46:35,020
a blog post on like why we ended up with

00:46:32,589 --> 00:46:37,000
cancellation as we have and there's some

00:46:35,020 --> 00:46:39,160
proposals for how you would do it like

00:46:37,000 --> 00:46:40,839
when you have more specific knowledge

00:46:39,160 --> 00:46:43,089
like how something is used then of

00:46:40,839 --> 00:46:45,400
course you you're like I can rule out

00:46:43,089 --> 00:46:47,230
these these problems and then you can

00:46:45,400 --> 00:46:49,930
use something else but it's really it's

00:46:47,230 --> 00:46:52,390
really possible and to implement your

00:46:49,930 --> 00:46:55,329
own cancellation construct for yourself

00:46:52,390 --> 00:46:57,579
I think that the the rule is like you

00:46:55,329 --> 00:47:00,640
you've passed something that has a heap

00:46:57,579 --> 00:47:01,869
like a function that cancels the thing

00:47:00,640 --> 00:47:03,550
and then you can separate the things we

00:47:01,869 --> 00:47:06,010
actually ended up doing just that yeah

00:47:03,550 --> 00:47:07,569
so but but have a look there if you're

00:47:06,010 --> 00:47:09,880
interested in knowing more like the back

00:47:07,569 --> 00:47:12,280
story and what what we considered and

00:47:09,880 --> 00:47:15,430
why we ended up as we are I think

00:47:12,280 --> 00:47:17,349
especially something like a task that is

00:47:15,430 --> 00:47:19,410
a lifted representation where you

00:47:17,349 --> 00:47:21,849
essentially describe some sort of

00:47:19,410 --> 00:47:24,460
transformation process something like

00:47:21,849 --> 00:47:27,880
that is easier to deal with cancellation

00:47:24,460 --> 00:47:29,560
because you have a much much more

00:47:27,880 --> 00:47:31,359
control over how that is going to be

00:47:29,560 --> 00:47:33,069
executed so it might also be one of

00:47:31,359 --> 00:47:33,809
these things for cancellation makes

00:47:33,069 --> 00:47:35,509
sense on

00:47:33,809 --> 00:47:38,269
to level rather than running

00:47:35,509 --> 00:47:44,999
implementation level so have a look

00:47:38,269 --> 00:47:48,059
thank you it was yeah yeah sorry a bit

00:47:44,999 --> 00:47:52,499
of a question I don't know if you are

00:47:48,059 --> 00:47:55,529
aware I recently had to look about

00:47:52,499 --> 00:47:57,359
futures in in Java again my

00:47:55,529 --> 00:48:00,660
understanding is that in Java they are

00:47:57,359 --> 00:48:03,660
somewhat blocking I haven't seen the new

00:48:00,660 --> 00:48:07,109
Java versions because there's a new

00:48:03,660 --> 00:48:10,489
version every six month now so are you

00:48:07,109 --> 00:48:13,890
aware of the difference in speed maybe

00:48:10,489 --> 00:48:15,749
regarding latest Java versions and color

00:48:13,890 --> 00:48:17,309
I haven't really compared the two

00:48:15,749 --> 00:48:20,390
because they have essentially

00:48:17,309 --> 00:48:23,400
fundamentally different design

00:48:20,390 --> 00:48:25,229
constraints so I haven't sort of pitted

00:48:23,400 --> 00:48:28,799
them against each other because it is a

00:48:25,229 --> 00:48:31,849
hard thing to do there are things that

00:48:28,799 --> 00:48:33,959
you can do in terms of essentially

00:48:31,849 --> 00:48:36,359
shielding yourself from the blocking

00:48:33,959 --> 00:48:38,789
parts by having a completion stage

00:48:36,359 --> 00:48:40,679
rather than completable future as your

00:48:38,789 --> 00:48:42,779
dependency type because then you don't

00:48:40,679 --> 00:48:46,709
get the get and the other blocking

00:48:42,779 --> 00:48:49,079
methods so I'm I'm curious I'll have a

00:48:46,709 --> 00:48:51,719
look at the if I can come up with some

00:48:49,079 --> 00:48:57,479
sort of good a good way of comparing the

00:48:51,719 --> 00:49:01,079
two okay thank you thank you thank you

00:48:57,479 --> 00:49:03,689
for answering the questions and well

00:49:01,079 --> 00:49:05,130
thank you again thank you all for coming

00:49:03,689 --> 00:49:05,759
on I'm super stoked that you're still

00:49:05,130 --> 00:49:09,420
here

00:49:05,759 --> 00:49:11,099
so have a great conference and I'm happy

00:49:09,420 --> 00:49:13,799
to be here this is like I was here at

00:49:11,099 --> 00:49:16,049
the first Scala day so it's it's a bit

00:49:13,799 --> 00:49:18,029
of like a path down memory lane for me

00:49:16,049 --> 00:49:20,120
as well so it's great to see so many

00:49:18,029 --> 00:49:25,920
people here

00:49:20,120 --> 00:49:25,920

YouTube URL: https://www.youtube.com/watch?v=5FTJUUoT6y4


