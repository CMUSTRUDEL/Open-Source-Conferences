Title: Akka Streams to the Extreme - Heiko Seeberger
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/akka-streams-to-the-extreme
Captions: 
	00:00:00,170 --> 00:00:07,020
this is already an excellent example for

00:00:03,540 --> 00:00:09,990
an extreme stream I mean stream of

00:00:07,020 --> 00:00:18,300
people flowing into this room almost

00:00:09,990 --> 00:00:20,430
endlessly so took in 2010 I was giving a

00:00:18,300 --> 00:00:23,580
presentation at the first Scala days I

00:00:20,430 --> 00:00:30,119
think it was about Scala

00:00:23,580 --> 00:00:37,320
DSL for OSGi and a little later I added

00:00:30,119 --> 00:00:39,750
OSGi support to akka unfortunately and

00:00:37,320 --> 00:00:41,969
now this cycle sort of closes because

00:00:39,750 --> 00:00:43,649
I'm talking about akka again here at

00:00:41,969 --> 00:00:48,450
this tenth or is it the ninth

00:00:43,649 --> 00:00:53,190
anniversary I don't know 2010 until 2019

00:00:48,450 --> 00:00:58,289
whatever let's call it the 10th I'm very

00:00:53,190 --> 00:01:01,230
glad to be here anyway okay so in this

00:00:58,289 --> 00:01:04,080
presentation I would like to talk about

00:01:01,230 --> 00:01:08,280
some advanced features of ARCA streams

00:01:04,080 --> 00:01:12,090
not necessarily extreme but I think it

00:01:08,280 --> 00:01:15,570
sounds good stream an extreme who've you

00:01:12,090 --> 00:01:21,530
know is a kasturi's or is or has been

00:01:15,570 --> 00:01:25,170
using ARCA streams that's good okay so

00:01:21,530 --> 00:01:27,720
what I'm going to show you is already

00:01:25,170 --> 00:01:30,990
used in production at Moya my office

00:01:27,720 --> 00:01:34,909
right staring in a couple of German

00:01:30,990 --> 00:01:37,619
cities like Hamburg and Hannover and

00:01:34,909 --> 00:01:42,659
when I became engaged in a project last

00:01:37,619 --> 00:01:45,030
year I had the chance to work on a

00:01:42,659 --> 00:01:46,950
particular sub project which was a

00:01:45,030 --> 00:01:49,829
greenfield project and we decided to use

00:01:46,950 --> 00:01:52,680
a lot of akka streams in it so what

00:01:49,829 --> 00:01:57,869
you're seeing today is not the actual

00:01:52,680 --> 00:02:01,200
code base of Moya but a very simplified

00:01:57,869 --> 00:02:06,990
form of the things which are really used

00:02:01,200 --> 00:02:08,640
there Moya offers ride-sharing with

00:02:06,990 --> 00:02:10,560
those beautiful shuttles I have shown on

00:02:08,640 --> 00:02:13,040
the previous slide they're running on

00:02:10,560 --> 00:02:17,360
AWS using kubernetes

00:02:13,040 --> 00:02:21,480
they have Micro source architecture for

00:02:17,360 --> 00:02:24,769
lot of parts of their systems and for

00:02:21,480 --> 00:02:28,010
some sources they are using akka HCP and

00:02:24,769 --> 00:02:31,140
for some they are also using a cluster

00:02:28,010 --> 00:02:34,620
and if you know more about how to manage

00:02:31,140 --> 00:02:35,819
naka cluster on kubernetes you can later

00:02:34,620 --> 00:02:38,010
today at 15:30

00:02:35,819 --> 00:02:40,230
go to the talk of my buddy Marcus you

00:02:38,010 --> 00:02:46,230
are he was working at Moria who will

00:02:40,230 --> 00:02:47,880
cover all the details so when I was

00:02:46,230 --> 00:02:49,530
engaged in that project we had the

00:02:47,880 --> 00:02:53,099
following situation which is a

00:02:49,530 --> 00:02:56,660
simplification in this diagram there's

00:02:53,099 --> 00:03:01,349
not hey sleepy API offering protobuf and

00:02:56,660 --> 00:03:05,099
Jason endpoints then taking the HTTP

00:03:01,349 --> 00:03:09,209
requests and marshaling them to domain

00:03:05,099 --> 00:03:11,099
requests and then going for actors which

00:03:09,209 --> 00:03:16,500
most of you probably do when you use are

00:03:11,099 --> 00:03:19,230
HTTP right and then some actors talk to

00:03:16,500 --> 00:03:23,670
other actors which might even live on

00:03:19,230 --> 00:03:26,370
different nodes as shown here now what

00:03:23,670 --> 00:03:30,090
do you think could be a problem in the

00:03:26,370 --> 00:03:35,450
scenario when kubernetes decides to shut

00:03:30,090 --> 00:03:35,450
down a pod any ideas

00:03:39,280 --> 00:03:48,620
okay I couldn't hear anything sorry for

00:03:42,409 --> 00:03:51,049
that you could lose requests right in

00:03:48,620 --> 00:03:54,439
particular if conan's decides to shut

00:03:51,049 --> 00:03:57,950
down node B while this act here has not

00:03:54,439 --> 00:03:59,920
yet replied to this actor over there the

00:03:57,950 --> 00:04:02,629
request which has started in no they

00:03:59,920 --> 00:04:05,420
cannot get completed so you lose that

00:04:02,629 --> 00:04:10,700
request and potentially Moya is losing a

00:04:05,420 --> 00:04:14,599
customer so that's no good so what could

00:04:10,700 --> 00:04:17,539
we do against that first of all we could

00:04:14,599 --> 00:04:19,940
use a feature of our case VP which is

00:04:17,539 --> 00:04:24,350
the terminate method which is defined on

00:04:19,940 --> 00:04:27,919
the server binding class interestingly

00:04:24,350 --> 00:04:32,510
that has been added around June last

00:04:27,919 --> 00:04:34,880
year and it gives you what you want it

00:04:32,510 --> 00:04:37,639
does no longer accept new connection but

00:04:34,880 --> 00:04:40,310
it drains existing connections so until

00:04:37,639 --> 00:04:42,880
this termination deadline all the

00:04:40,310 --> 00:04:47,389
requests that had been accepted will be

00:04:42,880 --> 00:04:52,430
completed and only then the shutdown of

00:04:47,389 --> 00:04:55,849
the actor system will continue this is

00:04:52,430 --> 00:04:57,320
really good and we added that in the

00:04:55,849 --> 00:04:59,510
meantime initially we didn't know about

00:04:57,320 --> 00:05:01,220
it but in the meantime we added it but

00:04:59,510 --> 00:05:06,169
the question is is this good enough

00:05:01,220 --> 00:05:09,500
let's revisit this picture here the

00:05:06,169 --> 00:05:12,979
terminate method refers to the server

00:05:09,500 --> 00:05:15,699
binding so if this node a accepts a

00:05:12,979 --> 00:05:19,729
request and Cunha's wants to shut down

00:05:15,699 --> 00:05:22,880
node a all is good the certain will be

00:05:19,729 --> 00:05:27,409
delayed but what if command s wants to

00:05:22,880 --> 00:05:30,229
shut down not be well node B is not

00:05:27,409 --> 00:05:35,270
related to any HTTP request directly so

00:05:30,229 --> 00:05:40,400
the logic shown here sorry here on node

00:05:35,270 --> 00:05:43,039
B does not delay the certain of no B so

00:05:40,400 --> 00:05:46,580
we would still lose requests

00:05:43,039 --> 00:05:49,460
and that's no good as I said so we

00:05:46,580 --> 00:05:51,740
needed to come up with something better

00:05:49,460 --> 00:05:53,629
in our design idea was why not implement

00:05:51,740 --> 00:06:00,619
all the requests handing processes with

00:05:53,629 --> 00:06:03,199
ARCA streams using extremes would also

00:06:00,619 --> 00:06:06,800
give us other benefits for example type

00:06:03,199 --> 00:06:10,219
nests well there's a type actors or

00:06:06,800 --> 00:06:13,270
archetype now but experiences also typed

00:06:10,219 --> 00:06:18,259
and backpressure

00:06:13,270 --> 00:06:20,839
so this seems like a great idea and your

00:06:18,259 --> 00:06:23,089
more detail a request hunting process

00:06:20,839 --> 00:06:25,699
conceptually is a flow from a request to

00:06:23,089 --> 00:06:30,499
a response or to an either error or

00:06:25,699 --> 00:06:33,259
response and in this design approach

00:06:30,499 --> 00:06:35,659
actors are only used for for state which

00:06:33,259 --> 00:06:38,749
is spanning multiple processing stages

00:06:35,659 --> 00:06:44,089
or processes so for data transformation

00:06:38,749 --> 00:06:47,509
use streams and for long-lived state use

00:06:44,089 --> 00:06:52,729
actors so use a lot less actors than

00:06:47,509 --> 00:06:55,550
before and the running processes the

00:06:52,729 --> 00:06:57,319
materialized processes they need to be

00:06:55,550 --> 00:07:00,620
suitably hooked into the coronary

00:06:57,319 --> 00:07:02,059
shutdown to no longer accept new

00:07:00,620 --> 00:07:04,819
requests and delay the shutdown until

00:07:02,059 --> 00:07:07,639
accepted requests have been processed

00:07:04,819 --> 00:07:09,709
and that means have been processed

00:07:07,639 --> 00:07:11,360
across the whole pipeline here and this

00:07:09,709 --> 00:07:14,839
is still the act of pipeline sorry

00:07:11,360 --> 00:07:17,659
the high level design of of the new

00:07:14,839 --> 00:07:20,479
approach would be that we have those

00:07:17,659 --> 00:07:26,899
running streams running processes here

00:07:20,479 --> 00:07:29,779
the red boxes on multiple nodes and if a

00:07:26,899 --> 00:07:32,959
request comes in it runs through various

00:07:29,779 --> 00:07:35,860
stages in this process and at some point

00:07:32,959 --> 00:07:41,330
this process branches out to some other

00:07:35,860 --> 00:07:43,009
running process on another node and the

00:07:41,330 --> 00:07:45,019
response from that process comes back

00:07:43,009 --> 00:07:48,259
here and so on and so on and it's

00:07:45,019 --> 00:07:50,779
important that those processes those two

00:07:48,259 --> 00:07:52,519
processes in this example are suitably

00:07:50,779 --> 00:07:54,949
hooked into coordinates a turn of their

00:07:52,519 --> 00:07:55,820
respective machines to avoid losing

00:07:54,949 --> 00:08:00,440
requests

00:07:55,820 --> 00:08:00,440
now that idea makes sense

00:08:00,590 --> 00:08:05,419
great

00:08:01,800 --> 00:08:08,130
so benefit would be accomplished

00:08:05,419 --> 00:08:11,430
compositionality hard work for me to say

00:08:08,130 --> 00:08:16,110
you could compose your overall system

00:08:11,430 --> 00:08:18,000
from steps from logical steps from flows

00:08:16,110 --> 00:08:21,330
or maybe even more complicated or

00:08:18,000 --> 00:08:27,000
complex graphs but you could have

00:08:21,330 --> 00:08:29,810
reasonably small sized processing steps

00:08:27,000 --> 00:08:35,459
then of course you get back pressure

00:08:29,810 --> 00:08:38,120
which is not the case if you have HDPE

00:08:35,459 --> 00:08:40,860
route that is directly asking an actor

00:08:38,120 --> 00:08:45,000
and the most important thing lossless

00:08:40,860 --> 00:08:46,470
deployments but of course there are some

00:08:45,000 --> 00:08:51,330
challenges and I'm trying to address

00:08:46,470 --> 00:08:53,120
those during the rest of the talk so how

00:08:51,330 --> 00:08:56,580
can we link our HDPE routes and

00:08:53,120 --> 00:08:59,130
processes then how can we connect to

00:08:56,580 --> 00:09:02,220
running processes I mean what does that

00:08:59,130 --> 00:09:07,529
mean at all and how can we even stream

00:09:02,220 --> 00:09:08,730
across cluster nodes these are probably

00:09:07,529 --> 00:09:11,100
interesting questions to you unless you

00:09:08,730 --> 00:09:14,100
have them already solved but normally

00:09:11,100 --> 00:09:17,430
you define a flow you materialize it

00:09:14,100 --> 00:09:19,650
everything is local elements don't

00:09:17,430 --> 00:09:23,310
branch out of the flow into some other

00:09:19,650 --> 00:09:24,690
running stream and so on so these are

00:09:23,310 --> 00:09:28,529
really interesting challenges and we

00:09:24,690 --> 00:09:31,650
have solved all of them and to solve

00:09:28,529 --> 00:09:33,360
those we have applied those tools so

00:09:31,650 --> 00:09:35,160
these are a couple of these advanced

00:09:33,360 --> 00:09:39,480
features or varka streams like flow with

00:09:35,160 --> 00:09:43,490
context and to be honest that isn't yet

00:09:39,480 --> 00:09:46,770
used at moya hopefully we will get there

00:09:43,490 --> 00:09:49,440
sauce humor table kills which sync ref

00:09:46,770 --> 00:09:52,680
or so stream rafts for remote streaming

00:09:49,440 --> 00:09:54,720
and restart sync do you know all of

00:09:52,680 --> 00:09:59,430
these who knows all of these and has

00:09:54,720 --> 00:10:02,320
used all of those okay who is used at

00:09:59,430 --> 00:10:05,500
least one of these okay

00:10:02,320 --> 00:10:07,329
that makes sense okay so I have a very

00:10:05,500 --> 00:10:09,310
simplified demo

00:10:07,329 --> 00:10:11,320
it's a HTTP endpoint called shuffle

00:10:09,310 --> 00:10:14,529
texts you pass a text like hello

00:10:11,320 --> 00:10:17,649
Lausanne and then after a short delay

00:10:14,529 --> 00:10:19,180
which is the first processing stage you

00:10:17,649 --> 00:10:22,600
have another processing stage that

00:10:19,180 --> 00:10:24,459
shuffles the individual world words like

00:10:22,600 --> 00:10:27,550
yeah you can almost read it through the

00:10:24,459 --> 00:10:30,069
Enzo I don't know you can still read it

00:10:27,550 --> 00:10:34,240
probably if you know what the original

00:10:30,069 --> 00:10:36,130
was so that's the simplified demo let me

00:10:34,240 --> 00:10:44,680
just run it for you here to make sure

00:10:36,130 --> 00:10:47,680
everything works okay listen I gotta get

00:10:44,680 --> 00:10:50,319
rid of that and two seconds delay and

00:10:47,680 --> 00:10:52,889
then the result is there great if you

00:10:50,319 --> 00:11:00,759
run it again two seconds delay probably

00:10:52,889 --> 00:11:02,410
differently shuffled yes so let's try to

00:11:00,759 --> 00:11:05,170
solve the first challenge how to link

00:11:02,410 --> 00:11:11,319
archive see the routes and processes in

00:11:05,170 --> 00:11:14,319
our case you were out in this scenario

00:11:11,319 --> 00:11:18,699
looks like this if we focus on this part

00:11:14,319 --> 00:11:21,970
here we have a path shuffle text we take

00:11:18,699 --> 00:11:25,060
the get word or FTP verb we extract the

00:11:21,970 --> 00:11:27,910
parameter text and then we want to

00:11:25,060 --> 00:11:31,690
create the shuffle to text and then we

00:11:27,910 --> 00:11:34,060
complete the request travel text is a

00:11:31,690 --> 00:11:39,089
future of string and in this demo here

00:11:34,060 --> 00:11:43,810
at that stage we are already using a a

00:11:39,089 --> 00:11:47,139
flow or a running stream which is

00:11:43,810 --> 00:11:51,420
defined here so we have a single request

00:11:47,139 --> 00:11:56,380
method that starts with a source single

00:11:51,420 --> 00:12:00,420
of the text to be shuffled then we go

00:11:56,380 --> 00:12:04,779
via a flow which is defined up there and

00:12:00,420 --> 00:12:07,389
this flow has this delay and it doesn't

00:12:04,779 --> 00:12:10,240
map a sink with 42 because that's the

00:12:07,389 --> 00:12:12,699
best number ever and then it branches

00:12:10,240 --> 00:12:16,480
out to another flow

00:12:12,699 --> 00:12:18,670
story stream because it runs this other

00:12:16,480 --> 00:12:22,540
is that the flow is called shuffle word

00:12:18,670 --> 00:12:25,509
and shuttle bird is called with all the

00:12:22,540 --> 00:12:30,009
words after splitting the initial text

00:12:25,509 --> 00:12:33,009
by the blank okay and then we met back

00:12:30,009 --> 00:12:36,100
to the proper outcome of this flow so

00:12:33,009 --> 00:12:38,709
the type the process type is flow up

00:12:36,100 --> 00:12:43,660
here from the command shuffle text to

00:12:38,709 --> 00:12:47,279
text travel of course this is not what

00:12:43,660 --> 00:12:50,170
we want in the API because here we are

00:12:47,279 --> 00:12:53,259
materializing and running this stream

00:12:50,170 --> 00:12:55,600
for every request that doesn't fit into

00:12:53,259 --> 00:12:57,639
our design idea in our design idea we

00:12:55,600 --> 00:13:01,059
won't have long long lasting long

00:12:57,639 --> 00:13:03,009
running flows or so yeah because only

00:13:01,059 --> 00:13:06,699
those can probably hook up into the

00:13:03,009 --> 00:13:09,279
coordinator shutdown and also apply that

00:13:06,699 --> 00:13:15,249
pressure to all the backend systems like

00:13:09,279 --> 00:13:17,350
I don't know kenosis or a QP or whatever

00:13:15,249 --> 00:13:19,899
is used and talking to external services

00:13:17,350 --> 00:13:22,449
where we have global rate limits and

00:13:19,899 --> 00:13:25,360
things like that so we cannot just rerun

00:13:22,449 --> 00:13:26,410
for every request a flow because then

00:13:25,360 --> 00:13:29,199
all these things don't apply because

00:13:26,410 --> 00:13:31,360
source single is not really something

00:13:29,199 --> 00:13:34,779
where I can apply rate limits and stuff

00:13:31,360 --> 00:13:36,790
right okay so this is just for the demo

00:13:34,779 --> 00:13:42,040
to make it work so we need to find a

00:13:36,790 --> 00:13:45,339
better way and in order to feed

00:13:42,040 --> 00:13:48,519
something into a running stream we can

00:13:45,339 --> 00:13:51,670
use a source queue a source queue there

00:13:48,519 --> 00:13:54,279
is a source which materializes to

00:13:51,670 --> 00:13:56,199
something called sauce queue or even

00:13:54,279 --> 00:13:58,540
source queue with complete but we can

00:13:56,199 --> 00:14:01,720
ignore them with complete for this talk

00:13:58,540 --> 00:14:04,059
and you have to pass a buffer size we

00:14:01,720 --> 00:14:07,179
just use one here and an overflow

00:14:04,059 --> 00:14:11,290
strategy for the endpoints of our

00:14:07,179 --> 00:14:13,029
processes drop new seems to be a good

00:14:11,290 --> 00:14:17,290
strategy because this gives us fail-fast

00:14:13,029 --> 00:14:19,439
of our service itself is overloaded if

00:14:17,290 --> 00:14:22,959
the process cannot accept any new

00:14:19,439 --> 00:14:25,779
requests it will drop a new request and

00:14:22,959 --> 00:14:29,050
that means that we can immediately tell

00:14:25,779 --> 00:14:34,660
the client the HDP client that the

00:14:29,050 --> 00:14:37,890
service unavailable 503 the source queue

00:14:34,660 --> 00:14:41,589
has an offer method so we can offer

00:14:37,890 --> 00:14:44,800
requests or elements into the running

00:14:41,589 --> 00:14:47,260
stream and that gives us a future of

00:14:44,800 --> 00:14:50,050
offer a queue offer result which could

00:14:47,260 --> 00:14:55,870
be in queued or dropped or some other

00:14:50,050 --> 00:14:58,180
error which should not happen now how do

00:14:55,870 --> 00:15:00,610
we get things out of the running stream

00:14:58,180 --> 00:15:06,160
in order to do that we have to pass

00:15:00,610 --> 00:15:10,180
along a promise okay if you look at this

00:15:06,160 --> 00:15:12,640
example here with a source queue which

00:15:10,180 --> 00:15:17,769
takes a request and a promise for the

00:15:12,640 --> 00:15:20,769
response and then after running this

00:15:17,769 --> 00:15:24,640
process here or feeding sorry feeding

00:15:20,769 --> 00:15:28,450
those tuples into that process we have a

00:15:24,640 --> 00:15:31,269
thing for each where we complete the

00:15:28,450 --> 00:15:33,850
promise and this complete promise or the

00:15:31,269 --> 00:15:35,649
relayed future can then be used to

00:15:33,850 --> 00:15:38,709
complete the HTTP request as you will

00:15:35,649 --> 00:15:41,350
see in a moment what we also have to

00:15:38,709 --> 00:15:44,320
consider here is what that means for the

00:15:41,350 --> 00:15:46,750
process our sauce queue is now required

00:15:44,320 --> 00:15:50,070
it takes no tuples or pairs of requests

00:15:46,750 --> 00:15:54,610
and promise well that means that our

00:15:50,070 --> 00:16:00,870
process needs to read along a promise is

00:15:54,610 --> 00:16:05,350
that nice who thinks this is nice good

00:16:00,870 --> 00:16:07,810
it's not nice at all and therefore we

00:16:05,350 --> 00:16:10,120
use a new feature called flow with

00:16:07,810 --> 00:16:15,300
context which is essentially just a

00:16:10,120 --> 00:16:22,120
wrapper around a flow of pair a and

00:16:15,300 --> 00:16:24,100
context to objects and then offering all

00:16:22,120 --> 00:16:26,620
the methods you know like map and filter

00:16:24,100 --> 00:16:29,110
which only work on the first element so

00:16:26,620 --> 00:16:32,350
the context is transparently threaded

00:16:29,110 --> 00:16:34,990
along so if our process now is a flow

00:16:32,350 --> 00:16:37,529
with context which takes a request and

00:16:34,990 --> 00:16:40,959
the promise of this for the response

00:16:37,529 --> 00:16:42,130
producing a response and not changing

00:16:40,959 --> 00:16:44,020
the type of

00:16:42,130 --> 00:16:47,560
the context object which could be done

00:16:44,020 --> 00:16:49,330
but we don't do it then we can call map

00:16:47,560 --> 00:16:53,080
and all these things only on the

00:16:49,330 --> 00:16:55,540
requests we could even then at some

00:16:53,080 --> 00:16:58,390
point when we need it get back the

00:16:55,540 --> 00:17:00,310
tuples by calling as flow because then

00:16:58,390 --> 00:17:05,230
we have the requests and the promised

00:17:00,310 --> 00:17:10,470
response with these tools in place let's

00:17:05,230 --> 00:17:10,470
try to make our example a little better

00:17:12,480 --> 00:17:17,250
so what has been prepared now is the

00:17:16,449 --> 00:17:21,610
following

00:17:17,250 --> 00:17:27,040
we are still in the API so in the API

00:17:21,610 --> 00:17:29,860
down there in the route we change things

00:17:27,040 --> 00:17:34,060
but before we can change things we need

00:17:29,860 --> 00:17:38,250
to set up a proper running flow and we

00:17:34,060 --> 00:17:42,970
call that processor because a processor

00:17:38,250 --> 00:17:46,930
is for running processes ok I hope you

00:17:42,970 --> 00:17:54,730
like the wording so let's take a source

00:17:46,930 --> 00:17:58,230
dot Q and the type here should be from

00:17:54,730 --> 00:18:05,700
shuffle text or a shuffle text to

00:17:58,230 --> 00:18:11,200
promise text shuffled size one and

00:18:05,700 --> 00:18:17,590
overflow strategy drop new good then we

00:18:11,200 --> 00:18:20,460
we go via our text shuffler dot process

00:18:17,590 --> 00:18:26,530
that is handed in as a parameter here

00:18:20,460 --> 00:18:35,880
and then we do our for each sorry we go

00:18:26,530 --> 00:18:37,750
to sync dot for each and here we get out

00:18:35,880 --> 00:18:40,180
the pairs again

00:18:37,750 --> 00:18:42,880
so we have our shuffle text and we have

00:18:40,180 --> 00:18:48,650
the promise and we can try to complete

00:18:42,880 --> 00:18:53,070
the promise successfully of course

00:18:48,650 --> 00:18:54,780
and then we just run that sorry we have

00:18:53,070 --> 00:18:57,600
a materializing scope so what this will

00:18:54,780 --> 00:19:02,520
run which means here we get our sauce

00:18:57,600 --> 00:19:04,470
cue with complete cool now this is a

00:19:02,520 --> 00:19:07,140
running stream and we can feed requests

00:19:04,470 --> 00:19:08,870
into it and that's what we are going to

00:19:07,140 --> 00:19:11,520
do down there

00:19:08,870 --> 00:19:13,650
we need a promise and for that purpose

00:19:11,520 --> 00:19:17,580
we are using an expiring promise because

00:19:13,650 --> 00:19:19,440
we won't have a timeout right and an

00:19:17,580 --> 00:19:24,299
expiring promise is just a utility class

00:19:19,440 --> 00:19:26,370
which is defined here not too hard to

00:19:24,299 --> 00:19:28,610
understand you can take a look later if

00:19:26,370 --> 00:19:31,020
you want to see more details

00:19:28,610 --> 00:19:34,530
it's a promise which expires after the

00:19:31,020 --> 00:19:39,720
processor timeout given here so we take

00:19:34,530 --> 00:19:48,270
our shuffle no text shuffler processor

00:19:39,720 --> 00:19:51,510
and we offer a couple of this shuffle

00:19:48,270 --> 00:19:54,000
text command with the text that has been

00:19:51,510 --> 00:19:58,860
extracted from the request and our

00:19:54,000 --> 00:20:03,559
promise text shuffled yeah ok cool so

00:19:58,860 --> 00:20:09,480
that we can offer and then we will get

00:20:03,559 --> 00:20:13,020
back a future so we had use flat map and

00:20:09,480 --> 00:20:14,549
look at whether this request and promise

00:20:13,020 --> 00:20:21,809
for the response tablet could be in

00:20:14,549 --> 00:20:29,010
queued if so we have our promise text

00:20:21,809 --> 00:20:32,630
shuffled we can get the future from the

00:20:29,010 --> 00:20:36,270
promise and we can call map to extract

00:20:32,630 --> 00:20:40,169
the text which is a string that should

00:20:36,270 --> 00:20:47,000
be the shuffled string in other cases

00:20:40,169 --> 00:20:47,000
like dropped we fail a future

00:20:48,020 --> 00:20:55,100
with a processor unavailable just some

00:20:52,010 --> 00:20:58,430
name processor unavailable is just the

00:20:55,100 --> 00:21:01,910
case class exception defined in this

00:20:58,430 --> 00:21:04,400
project and case other which should not

00:21:01,910 --> 00:21:08,560
happen but we still need to take care of

00:21:04,400 --> 00:21:14,600
that also failed with a processor error

00:21:08,560 --> 00:21:17,810
with the course other okay so this is

00:21:14,600 --> 00:21:20,450
really all we need so we get sorry wrong

00:21:17,810 --> 00:21:23,210
one the shuffle text here is a future

00:21:20,450 --> 00:21:25,820
string so that is what we get from

00:21:23,210 --> 00:21:28,640
feeding the request into this drawing

00:21:25,820 --> 00:21:30,590
stream we get it out again as a future

00:21:28,640 --> 00:21:33,680
of string and that we can use to

00:21:30,590 --> 00:21:47,570
complete a request cool let's see

00:21:33,680 --> 00:21:51,590
whether this works okay listening one

00:21:47,570 --> 00:21:54,920
two yeah seems to work and the nice

00:21:51,590 --> 00:21:57,470
thing is if I now send a lot of requests

00:21:54,920 --> 00:21:59,840
and you have seen I've put the buffer

00:21:57,470 --> 00:22:08,810
sizes to one and I have a delay and all

00:21:59,840 --> 00:22:12,260
of that we get a couple of responses we

00:22:08,810 --> 00:22:14,330
have I started so here you can see 503

00:22:12,260 --> 00:22:17,180
service unavailable 503 service

00:22:14,330 --> 00:22:20,000
unavailable here two hundred and two

00:22:17,180 --> 00:22:23,170
hundred four requests to could being

00:22:20,000 --> 00:22:25,910
hewed the others were dropped and

00:22:23,170 --> 00:22:29,930
rejected in a fail fast fashion I think

00:22:25,910 --> 00:22:34,880
this is really nice okay that was the

00:22:29,930 --> 00:22:39,700
first step but we have chief now is that

00:22:34,880 --> 00:22:43,550
we can hand requests with local

00:22:39,700 --> 00:22:45,590
processors but we need to be able to

00:22:43,550 --> 00:22:51,740
branch out into other processes and then

00:22:45,590 --> 00:22:54,140
branch out into remote processes okay so

00:22:51,740 --> 00:22:56,539
how can we link to processes to running

00:22:54,140 --> 00:22:59,389
processes to streams

00:22:56,539 --> 00:23:03,539
well there's a few too called merge hub

00:22:59,389 --> 00:23:08,539
the merge hub is a little bit like this

00:23:03,539 --> 00:23:13,230
source queue because it allows you to

00:23:08,539 --> 00:23:15,570
connect into a running stream but it

00:23:13,230 --> 00:23:17,070
doesn't have this overflow strategy

00:23:15,570 --> 00:23:19,409
thingy because you don't really offer

00:23:17,070 --> 00:23:22,769
it's really for linking to streams and

00:23:19,409 --> 00:23:25,049
therefore the linked stream will just

00:23:22,769 --> 00:23:27,799
backpressure the other one and that's

00:23:25,049 --> 00:23:31,200
what we want if we have streams that

00:23:27,799 --> 00:23:32,610
branch out into sub streams not real sub

00:23:31,200 --> 00:23:34,919
streams but yeah branch out into other

00:23:32,610 --> 00:23:37,379
streams and then the result of these

00:23:34,919 --> 00:23:38,610
other streams go back then we did what

00:23:37,379 --> 00:23:41,250
don't want to drop anything you want to

00:23:38,610 --> 00:23:43,740
back pressure right dropping should only

00:23:41,250 --> 00:23:48,059
happen at the very end of the overall

00:23:43,740 --> 00:23:50,700
process so the merge hub allows us to

00:23:48,059 --> 00:23:53,370
start with a source for some elements we

00:23:50,700 --> 00:23:57,899
again have to use a request and response

00:23:53,370 --> 00:24:00,389
tap own then we go via some process this

00:23:57,899 --> 00:24:04,500
again has to be a flow with context to

00:24:00,389 --> 00:24:05,730
thread along the the promise which is no

00:24:04,500 --> 00:24:09,149
longer promised by the way it's already

00:24:05,730 --> 00:24:13,049
a respond D sorry for that it could be a

00:24:09,149 --> 00:24:15,389
promise locally but if we want to move

00:24:13,049 --> 00:24:19,950
on to the cluster where we want to

00:24:15,389 --> 00:24:22,769
compose streams which run on various

00:24:19,950 --> 00:24:26,940
nodes we can never go use a promise do

00:24:22,769 --> 00:24:30,659
you know why yeah promises don't get

00:24:26,940 --> 00:24:35,639
sterilized we we knew that but we still

00:24:30,659 --> 00:24:37,110
tried it it took us more than five

00:24:35,639 --> 00:24:41,460
minutes to figure out what is not very

00:24:37,110 --> 00:24:44,480
messy recession that was me yeah funny

00:24:41,460 --> 00:24:48,240
thing so respond he's just an actor F

00:24:44,480 --> 00:24:51,960
which gets initialized with a promise

00:24:48,240 --> 00:24:54,450
and this actor F can remote to be sent

00:24:51,960 --> 00:24:57,029
around and you can send a response

00:24:54,450 --> 00:24:59,940
message to the responding actor it's a

00:24:57,029 --> 00:25:01,950
typed actor and when you receive the

00:24:59,940 --> 00:25:05,549
responds in time it will complete the

00:25:01,950 --> 00:25:08,100
promise else it will fare the promise so

00:25:05,549 --> 00:25:08,480
it's more or less a remote able promise

00:25:08,100 --> 00:25:12,770
you

00:25:08,480 --> 00:25:14,600
say which is an active good so therefore

00:25:12,770 --> 00:25:17,240
the whole thing looks very similar to

00:25:14,600 --> 00:25:20,450
before but it's not the source cue it's

00:25:17,240 --> 00:25:23,210
the merge hub and here in the thing for

00:25:20,450 --> 00:25:26,690
each we have to send this response

00:25:23,210 --> 00:25:28,970
message to the respond the actor F okay

00:25:26,690 --> 00:25:31,309
but other than that the merge hub is

00:25:28,970 --> 00:25:35,780
similar so we can hook into some other

00:25:31,309 --> 00:25:46,760
stream oh and that's all good then let

00:25:35,780 --> 00:25:51,830
me show you that where do you want to

00:25:46,760 --> 00:25:53,570
move here okay a couple of things have

00:25:51,830 --> 00:25:56,030
been prepared but there's two question

00:25:53,570 --> 00:26:00,020
marks in the code so let's first take a

00:25:56,030 --> 00:26:06,400
look at this text settler and watch

00:26:00,020 --> 00:26:11,360
shuffler again The Verge traveler now is

00:26:06,400 --> 00:26:17,540
flow with context with the respond D of

00:26:11,360 --> 00:26:20,090
word shuffled and in order to run that

00:26:17,540 --> 00:26:21,770
process we need to apply what I have

00:26:20,090 --> 00:26:28,520
just shown you so we go for the merge

00:26:21,770 --> 00:26:30,110
hub that's so sorry do we need the types

00:26:28,520 --> 00:26:39,770
here I don't know let's fly without

00:26:30,110 --> 00:26:46,820
types what's wrong source yeah here we

00:26:39,770 --> 00:26:51,320
go okay then we go via our process so we

00:26:46,820 --> 00:26:58,580
are in the word shuffler okay and then

00:26:51,320 --> 00:27:00,380
we go to this sync dot for each this is

00:26:58,580 --> 00:27:04,370
a new machine now having a hard time

00:27:00,380 --> 00:27:08,450
typing as you can see we have the word

00:27:04,370 --> 00:27:11,840
shuffled and we have the respond e and

00:27:08,450 --> 00:27:17,090
we can say respond deep bang respond e

00:27:11,840 --> 00:27:21,040
dot response word shuffled and then we

00:27:17,090 --> 00:27:25,480
finally can say run hooray seems to work

00:27:21,040 --> 00:27:28,120
great now this is all we have to do here

00:27:25,480 --> 00:27:29,920
in the word shuffler this is still

00:27:28,120 --> 00:27:31,390
essentially the same process like before

00:27:29,920 --> 00:27:33,460
just travelling the world very very

00:27:31,390 --> 00:27:36,160
simple process using this method here

00:27:33,460 --> 00:27:38,170
which is not important to know this was

00:27:36,160 --> 00:27:42,430
the algorithm for shuffling individual

00:27:38,170 --> 00:27:44,170
birds let's go to the text traveler and

00:27:42,430 --> 00:27:49,780
maybe for you to better understand that

00:27:44,170 --> 00:27:53,200
let me go back to this diagram here now

00:27:49,780 --> 00:27:57,910
the the texts are Fleur would be on this

00:27:53,200 --> 00:28:00,070
node right and at some point it would

00:27:57,910 --> 00:28:02,230
try to branch out into the word shuffler

00:28:00,070 --> 00:28:05,230
which might reside on a different node

00:28:02,230 --> 00:28:07,690
it will not recite there yet that's been

00:28:05,230 --> 00:28:11,260
the next step but it would still already

00:28:07,690 --> 00:28:15,820
be a box of its own a red box a running

00:28:11,260 --> 00:28:22,240
stream of its own ok so how do we get

00:28:15,820 --> 00:28:25,510
into that into that traveler I have

00:28:22,240 --> 00:28:29,170
forgot to mention what we get back from

00:28:25,510 --> 00:28:30,970
the murids hub when we materialize it

00:28:29,170 --> 00:28:36,130
when we call the run method we get back

00:28:30,970 --> 00:28:37,780
a sink ok so this thing is to be used by

00:28:36,130 --> 00:28:41,110
other flows

00:28:37,780 --> 00:28:43,030
let's think arbitrary times and every

00:28:41,110 --> 00:28:45,100
time it gets them at your materialized

00:28:43,030 --> 00:28:48,520
it can it can be materialized arbitrary

00:28:45,100 --> 00:28:50,320
times and all these other flows or

00:28:48,520 --> 00:28:53,200
running streams after materialization

00:28:50,320 --> 00:28:55,000
can then send elements into that sink

00:28:53,200 --> 00:28:57,780
which means they end up here in that

00:28:55,000 --> 00:29:01,930
sauce and then they flow through this

00:28:57,780 --> 00:29:05,260
linked stream so therefore what we have

00:29:01,930 --> 00:29:08,250
is a think of shuffle word respond e

00:29:05,260 --> 00:29:11,830
were shuffled ok that's what we have now

00:29:08,250 --> 00:29:15,910
we need a respond ear right so here we

00:29:11,830 --> 00:29:19,170
have our subtle world command mm-hmm and

00:29:15,910 --> 00:29:22,290
first we need to create a respond D so

00:29:19,170 --> 00:29:26,980
that's a little hard

00:29:22,290 --> 00:29:31,300
innaka typed and therefore I'm using

00:29:26,980 --> 00:29:33,470
untyped here so that's first quite a

00:29:31,300 --> 00:29:40,150
promise well P

00:29:33,470 --> 00:29:47,950
was promised we have this couple we need

00:29:40,150 --> 00:29:47,950
something's wrong here one too many no

00:29:48,700 --> 00:29:57,980
yeah this order thank you who pesky and

00:29:55,210 --> 00:30:01,840
then we create respond de so we go to

00:29:57,980 --> 00:30:05,419
the untyped system and type system dot

00:30:01,840 --> 00:30:07,809
spawn anonymous we can cause anonymous

00:30:05,419 --> 00:30:12,370
because we have the coexistence

00:30:07,809 --> 00:30:17,419
conversions here the behavior is our

00:30:12,370 --> 00:30:20,030
respond de and that takes this promise

00:30:17,419 --> 00:30:23,990
and a timeout the word shuffle process

00:30:20,030 --> 00:30:26,690
timeout okay now we have a shuffle word

00:30:23,990 --> 00:30:29,179
command we have a promise and on tap

00:30:26,690 --> 00:30:32,450
system we return all of that for the

00:30:29,179 --> 00:30:39,140
time being you will see why so shuffle

00:30:32,450 --> 00:30:42,669
word the promise and the respond e which

00:30:39,140 --> 00:30:42,669
we should assign to eval

00:30:45,820 --> 00:30:52,280
ok cool now we have that in order to

00:30:49,820 --> 00:30:56,080
feed the shuffle word and the respond D

00:30:52,280 --> 00:31:02,150
into this other thing which we have here

00:30:56,080 --> 00:31:04,460
we use the also to operation also to now

00:31:02,150 --> 00:31:09,530
we need to apply some more domestic

00:31:04,460 --> 00:31:15,309
because we have this flow of shuffle

00:31:09,530 --> 00:31:26,270
word sorry it's a triple damn and

00:31:15,309 --> 00:31:29,600
promise promise of this couple I wish

00:31:26,270 --> 00:31:34,760
type inference was better and finally we

00:31:29,600 --> 00:31:37,610
have our respond D ok cool then we map

00:31:34,760 --> 00:31:41,360
that because we don't need all of that

00:31:37,610 --> 00:31:43,610
so we have the shuttle word so recall

00:31:41,360 --> 00:31:44,920
that shuffle word the promise in the

00:31:43,610 --> 00:31:47,710
respond D we met

00:31:44,920 --> 00:31:49,750
that to shuttleworth only in responded

00:31:47,710 --> 00:31:51,370
because that's what we need for this

00:31:49,750 --> 00:31:53,740
thing right this thing here takes

00:31:51,370 --> 00:31:59,280
shuttle bird and respond D so we can

00:31:53,740 --> 00:32:04,450
feed that to our word shuffler sync no

00:31:59,280 --> 00:32:07,060
no okay I screwed something up I've got

00:32:04,450 --> 00:32:09,280
the case thank you that should no longer

00:32:07,060 --> 00:32:11,410
be necessary in dari nice to screw

00:32:09,280 --> 00:32:12,790
something up anyway I will show you a

00:32:11,410 --> 00:32:14,560
sample solution in one second it's

00:32:12,790 --> 00:32:16,690
probably just some braces and I don't

00:32:14,560 --> 00:32:26,620
know and then finally what we should get

00:32:16,690 --> 00:32:32,350
back in here we use map async 42 again

00:32:26,620 --> 00:32:35,860
of course and here we have our case of a

00:32:32,350 --> 00:32:38,020
word from the Swiss Pondy by the way we

00:32:35,860 --> 00:32:39,940
don't need the sorry we don't need this

00:32:38,020 --> 00:32:44,850
here we don't need to promise a promise

00:32:39,940 --> 00:32:48,040
that future and that should be it okay

00:32:44,850 --> 00:32:52,990
and I screwed things up so let me just

00:32:48,040 --> 00:32:54,250
scroll here to the simple solution which

00:32:52,990 --> 00:32:57,490
should more or less look the same

00:32:54,250 --> 00:33:02,430
hopefully I screwed something up here

00:32:57,490 --> 00:33:09,040
anyway so as you can see here those

00:33:02,430 --> 00:33:11,920
lines allow you to feed stuff into this

00:33:09,040 --> 00:33:13,420
remote able other stream so we're using

00:33:11,920 --> 00:33:16,290
the well that's just a little

00:33:13,420 --> 00:33:20,170
boilerplate to create a respond D okay

00:33:16,290 --> 00:33:22,390
which is also to to feed that stuff into

00:33:20,170 --> 00:33:24,460
that sink and then we have met a sink

00:33:22,390 --> 00:33:28,150
and of course this is all generic code

00:33:24,460 --> 00:33:31,720
so we have a library which does all of

00:33:28,150 --> 00:33:36,720
that and gives you an into method you

00:33:31,720 --> 00:33:36,720
just call into the sink and all is good

00:33:37,590 --> 00:33:41,320
thank you

00:33:38,950 --> 00:33:43,660
so let's run that and see whether it

00:33:41,320 --> 00:33:48,490
really works so in the main method I

00:33:43,660 --> 00:33:51,720
haven't shown you here the main class we

00:33:48,490 --> 00:33:53,980
are actually running this text shuffler

00:33:51,720 --> 00:33:56,710
with this brush of the sink and a

00:33:53,980 --> 00:33:58,360
virtual sink is really running the

00:33:56,710 --> 00:34:00,520
process so this is this is

00:33:58,360 --> 00:34:07,680
actually if this this thing you get so

00:34:00,520 --> 00:34:07,680
we have to running processes okay ooh

00:34:09,910 --> 00:34:15,640
still running very good now finally

00:34:13,470 --> 00:34:18,820
we're still on one note we want to go to

00:34:15,640 --> 00:34:23,370
two notes we want to deploy some stuff

00:34:18,820 --> 00:34:26,380
on other nodes and then connect

00:34:23,370 --> 00:34:28,000
different processes so how can we stream

00:34:26,380 --> 00:34:30,190
across cluster nodes and I still have 10

00:34:28,000 --> 00:34:32,590
minutes but that should that should be

00:34:30,190 --> 00:34:33,340
fine in order to do that we have to use

00:34:32,590 --> 00:34:35,320
sync refs

00:34:33,340 --> 00:34:39,340
they have been added quite recently to

00:34:35,320 --> 00:34:43,660
ARCA streams and they allow to stream

00:34:39,340 --> 00:34:46,990
across the network here's a nice diagram

00:34:43,660 --> 00:34:52,360
or it has been here wait a moment where

00:34:46,990 --> 00:34:55,210
is it stream rafts come on it's gone are

00:34:52,360 --> 00:34:58,090
here oh it's not so yeah I don't know

00:34:55,210 --> 00:34:59,620
whether you can can see that but you can

00:34:58,090 --> 00:35:02,650
look it up in the ARCA Docs that's house

00:34:59,620 --> 00:35:11,440
these stream refs work in the case of an

00:35:02,650 --> 00:35:13,330
sync ref essentially what we do is we

00:35:11,440 --> 00:35:15,970
use the API stream breaths

00:35:13,330 --> 00:35:20,410
Tata sync ref my whisk uses a source we

00:35:15,970 --> 00:35:24,450
can then using a stream so we go to our

00:35:20,410 --> 00:35:27,340
sink and then we run that particular

00:35:24,450 --> 00:35:30,280
flow we have defined and we get back a

00:35:27,340 --> 00:35:33,790
sync ref and the sync ref can then be

00:35:30,280 --> 00:35:37,330
used to send it around across the

00:35:33,790 --> 00:35:40,710
cluster and the sync revs you a sync and

00:35:37,330 --> 00:35:43,360
that thing can be materialized and then

00:35:40,710 --> 00:35:47,380
all the elements flowing into that sync

00:35:43,360 --> 00:35:50,610
on the remote node end up here in this

00:35:47,380 --> 00:35:52,870
thing on this node this is quite awesome

00:35:50,610 --> 00:35:55,660
and it's taking into consideration a lot

00:35:52,870 --> 00:35:57,940
of the problems that might occur on the

00:35:55,660 --> 00:36:01,480
network like sequencing and buffering

00:35:57,940 --> 00:36:05,410
delay for for for the latency and it's

00:36:01,480 --> 00:36:08,470
pretty awesome and this is what we need

00:36:05,410 --> 00:36:11,230
we also need a kill switch why do we

00:36:08,470 --> 00:36:14,770
need to kill switch well we need that

00:36:11,230 --> 00:36:20,609
to hook into the coordinated shutdown

00:36:14,770 --> 00:36:23,680
where we run those remote able flows so

00:36:20,609 --> 00:36:26,619
the example we have seen earlier for the

00:36:23,680 --> 00:36:31,270
for the word shuffler was the merge hub

00:36:26,619 --> 00:36:32,800
we add a single kill switch here so we

00:36:31,270 --> 00:36:33,510
can then call the shutdown method on the

00:36:32,800 --> 00:36:35,770
kill switch

00:36:33,510 --> 00:36:39,609
during coordinated shutdown and that

00:36:35,770 --> 00:36:44,790
will ensure that all the elements which

00:36:39,609 --> 00:36:47,020
are already here in the process will be

00:36:44,790 --> 00:36:49,090
continued or other requests which have

00:36:47,020 --> 00:36:52,420
ended up here have been accepted will be

00:36:49,090 --> 00:36:55,660
completed before the whole thing is shut

00:36:52,420 --> 00:36:59,590
down and finally we need to restart

00:36:55,660 --> 00:37:03,010
thing because when we are in the cluster

00:36:59,590 --> 00:37:08,230
when we are in the network things might

00:37:03,010 --> 00:37:11,530
go wrong so our sync we get once might

00:37:08,230 --> 00:37:17,040
no longer be alive so we need to restart

00:37:11,530 --> 00:37:17,040
that let me show you how this is working

00:37:20,970 --> 00:37:26,980
okay so what we have in place here for

00:37:24,130 --> 00:37:28,960
the work shuffler we have converted that

00:37:26,980 --> 00:37:31,900
into an actor which is a protocol called

00:37:28,960 --> 00:37:37,150
get sync ref it's a command you send it

00:37:31,900 --> 00:37:39,670
and you get back a sync ref cool so

00:37:37,150 --> 00:37:42,520
whenever it receives this message gets

00:37:39,670 --> 00:37:47,410
inked RAF we do what I have shown you

00:37:42,520 --> 00:37:52,030
with stream ref start sync ref dot V or

00:37:47,410 --> 00:37:56,170
I think it's dot to sink sink and then

00:37:52,030 --> 00:37:58,000
we run it and that gives us a future of

00:37:56,170 --> 00:38:03,250
the sync ref so we have to do the

00:37:58,000 --> 00:38:07,900
uncomplete okay okay success value is a

00:38:03,250 --> 00:38:15,590
sync ref we send it back to our reply to

00:38:07,900 --> 00:38:18,179
actor else we just

00:38:15,590 --> 00:38:32,140
[Music]

00:38:18,179 --> 00:38:36,130
log blah blah blah doesn't matter

00:38:32,140 --> 00:38:37,239
I'm running out of time sorry the

00:38:36,130 --> 00:38:41,669
exactly our message is not that

00:38:37,239 --> 00:38:45,369
important so that is how we could reply

00:38:41,669 --> 00:38:50,799
with a sync ref and we have to use that

00:38:45,369 --> 00:38:55,119
in the text shuffler and that is shown

00:38:50,799 --> 00:38:59,669
here so we have a reference to the word

00:38:55,119 --> 00:39:03,249
shuffler we ask it to get a sync ref

00:38:59,669 --> 00:39:05,469
with an ask timeout and so on and we

00:39:03,249 --> 00:39:07,479
also want to recover with trying again

00:39:05,469 --> 00:39:10,929
because this could of course go wrong

00:39:07,479 --> 00:39:12,130
for example if our cluster sharding our

00:39:10,929 --> 00:39:16,739
cluster single turn or whatever we are

00:39:12,130 --> 00:39:21,099
using to deploy the works of the actor

00:39:16,739 --> 00:39:24,189
decides to redeploy that actor on some

00:39:21,099 --> 00:39:25,749
other node or if it gets restart in the

00:39:24,189 --> 00:39:29,499
same node after failing whatever

00:39:25,749 --> 00:39:31,869
so we recover and then we have a future

00:39:29,499 --> 00:39:35,769
of this think ref great so the last

00:39:31,869 --> 00:39:39,669
missing piece is the the the restart

00:39:35,769 --> 00:39:45,219
sync because when something goes wrong

00:39:39,669 --> 00:39:47,650
while the sync is at work so we have we

00:39:45,219 --> 00:39:52,289
have got it here it's working with our

00:39:47,650 --> 00:39:56,279
nice process down here but then

00:39:52,289 --> 00:39:59,709
kubernetes decides to redeploy the parts

00:39:56,279 --> 00:40:02,140
it will no longer work so we need to

00:39:59,709 --> 00:40:04,719
restart the sync to continue our

00:40:02,140 --> 00:40:08,199
processes so here we use research sync

00:40:04,719 --> 00:40:12,959
with back off we have to apply some back

00:40:08,199 --> 00:40:15,640
AHS and then we have to provide a

00:40:12,959 --> 00:40:19,539
factory function for the sync

00:40:15,640 --> 00:40:24,429
unfortunately the API app API wants us

00:40:19,539 --> 00:40:27,309
to create a thing here there's an issue

00:40:24,429 --> 00:40:29,150
I have created that a future thing will

00:40:27,309 --> 00:40:33,009
also work it's not yet there

00:40:29,150 --> 00:40:35,749
so we would work shuffler sync ref

00:40:33,009 --> 00:40:39,349
college here and then a wait just some

00:40:35,749 --> 00:40:42,109
time so with that it should compile of

00:40:39,349 --> 00:40:45,559
course it would not run so let me drill

00:40:42,109 --> 00:40:50,329
next and we have some proper time outs

00:40:45,559 --> 00:40:54,829
here and the final demonstration will

00:40:50,329 --> 00:40:57,700
show you how this is really running on

00:40:54,829 --> 00:40:57,700
multiple nodes

00:41:00,400 --> 00:41:13,670
okay that's oh sorry it's over there

00:41:04,059 --> 00:41:16,279
starting it again okay the first note is

00:41:13,670 --> 00:41:23,450
up so this should already work let me

00:41:16,279 --> 00:41:28,720
see okay cool mmm the word shuffler

00:41:23,450 --> 00:41:32,119
actor by the way is deployed using

00:41:28,720 --> 00:41:34,940
cluster singleton so I have started the

00:41:32,119 --> 00:41:38,079
first node first so the virtual actor

00:41:34,940 --> 00:41:43,339
with its process is sitting there on

00:41:38,079 --> 00:41:48,799
this node okay let's start the second

00:41:43,339 --> 00:41:55,329
node which will listen on a second

00:41:48,799 --> 00:41:55,329
interface if I have edited I don't know

00:42:03,740 --> 00:42:12,180
okay it's listening there so just in

00:42:07,110 --> 00:42:15,630
time we go to the second node and hooray

00:42:12,180 --> 00:42:20,820
that does the remote streaming so let me

00:42:15,630 --> 00:42:23,520
go back to this picture here what we

00:42:20,820 --> 00:42:26,250
have seen now is this is node 1 this is

00:42:23,520 --> 00:42:28,440
no - we have sent a request - no - that

00:42:26,250 --> 00:42:32,670
was talking to the word seller which is

00:42:28,440 --> 00:42:39,690
sitting on node 1 and we can even stop

00:42:32,670 --> 00:42:41,730
that which should make this whole thing

00:42:39,690 --> 00:42:45,630
still to work because we have the backup

00:42:41,730 --> 00:42:48,750
sync which now reconnects tries to get a

00:42:45,630 --> 00:42:52,230
new sink ref it gets it because cluster

00:42:48,750 --> 00:42:55,640
Singleton has moved the actor to node

00:42:52,230 --> 00:43:00,510
number 2 and everything is working again

00:42:55,640 --> 00:43:04,800
alright that was the demo and yeah I'm

00:43:00,510 --> 00:43:07,440
just in time that's great we have put

00:43:04,800 --> 00:43:09,480
these feature into a library called

00:43:07,440 --> 00:43:11,550
stream II which is currently lacking

00:43:09,480 --> 00:43:13,200
behind we haven't yet really used the

00:43:11,550 --> 00:43:16,140
flow with context there properly so some

00:43:13,200 --> 00:43:17,940
things are a little different but

00:43:16,140 --> 00:43:19,890
nevertheless it's out there you can take

00:43:17,940 --> 00:43:22,470
a look and look at the commit history

00:43:19,890 --> 00:43:25,520
and see all the various things we tried

00:43:22,470 --> 00:43:30,320
and sometimes failed and then improved

00:43:25,520 --> 00:43:31,650
and I want to thank you for your

00:43:30,320 --> 00:43:33,840
attention

00:43:31,650 --> 00:43:35,520
you can take a look at the demo code and

00:43:33,840 --> 00:43:39,240
the slides they are available in github

00:43:35,520 --> 00:43:40,290
and I wish you a really nice and

00:43:39,240 --> 00:43:42,140
entertaining

00:43:40,290 --> 00:43:48,869
Scottie's conference thank you

00:43:42,140 --> 00:43:52,150
[Applause]

00:43:48,869 --> 00:43:55,119
and I'm around for questions I think we

00:43:52,150 --> 00:43:58,810
have run out of time but I didn't find

00:43:55,119 --> 00:44:02,290
me to a question but you have to be very

00:43:58,810 --> 00:44:05,640
very brief if you want okay so who would

00:44:02,290 --> 00:44:05,640
like but to be very brief

00:44:23,650 --> 00:44:28,630
instead of using promises and all the

00:44:25,720 --> 00:44:32,080
fellows from that why not use a body

00:44:28,630 --> 00:44:33,850
flow like HTTP itself doesn't just mesh

00:44:32,080 --> 00:44:35,620
requests with responses that come out

00:44:33,850 --> 00:44:37,480
the other end this was this would also

00:44:35,620 --> 00:44:40,390
give back back pressure in the other

00:44:37,480 --> 00:44:43,180
direction sorry I didn't understand that

00:44:40,390 --> 00:44:45,430
Akash TDP exposes a PD flow be

00:44:43,180 --> 00:44:47,710
directional flow with requests in one

00:44:45,430 --> 00:44:51,180
direction responses in the other why not

00:44:47,710 --> 00:44:53,290
use that model instead of promises which

00:44:51,180 --> 00:44:56,020
promises need all the extra stuff you'll

00:44:53,290 --> 00:44:57,400
discuss in the lecture ok so I think if

00:44:56,020 --> 00:44:59,320
I understand the question correctly you

00:44:57,400 --> 00:45:04,150
are suggesting we should use akka

00:44:59,320 --> 00:45:06,610
ATP as a layer now ok so maybe we should

00:45:04,150 --> 00:45:08,080
then discuss that later because yeah so

00:45:06,610 --> 00:45:10,180
the intention of this approach is to

00:45:08,080 --> 00:45:14,350
really have domain processes which are

00:45:10,180 --> 00:45:17,500
only sending around two main elements

00:45:14,350 --> 00:45:20,590
domain messages no HCP really stuff but

00:45:17,500 --> 00:45:26,050
yeah we can discuss that later another

00:45:20,590 --> 00:45:27,640
question then for the one who wants to

00:45:26,050 --> 00:45:29,410
stay in this room there will be

00:45:27,640 --> 00:45:32,230
massively parallel distribute

00:45:29,410 --> 00:45:36,430
distributed sky compare collab sorry

00:45:32,230 --> 00:45:41,940
compilation and you if you are staying

00:45:36,430 --> 00:45:41,940

YouTube URL: https://www.youtube.com/watch?v=CrpJJYPzdJE


