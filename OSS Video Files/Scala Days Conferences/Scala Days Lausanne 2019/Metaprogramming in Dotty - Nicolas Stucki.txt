Title: Metaprogramming in Dotty - Nicolas Stucki
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/metaprogramming-in-dotty
Captions: 
	00:00:00,920 --> 00:00:08,550
hello new class Sookie I work in the

00:00:04,500 --> 00:00:13,200
lamp here at EPFL and and I'm working on

00:00:08,550 --> 00:00:15,750
metal programming for dotty so first

00:00:13,200 --> 00:00:19,020
we're going to focus more on macros than

00:00:15,750 --> 00:00:22,920
other kind of meta programming in this

00:00:19,020 --> 00:00:24,720
presentation so to start this talk where

00:00:22,920 --> 00:00:28,289
I'm going to quickly say something about

00:00:24,720 --> 00:00:31,170
the Scala to macros so the

00:00:28,289 --> 00:00:34,050
implementation was quite coupled with

00:00:31,170 --> 00:00:37,260
the the the compiler Scala C compiler

00:00:34,050 --> 00:00:40,410
internals this led to some portability

00:00:37,260 --> 00:00:46,050
issues even in in a different version of

00:00:40,410 --> 00:00:48,329
Scala to 2x which make it quite

00:00:46,050 --> 00:00:49,670
impossible to to port to dotty there

00:00:48,329 --> 00:00:53,059
were a quite a few attempts and

00:00:49,670 --> 00:00:56,100
unfortunate it was deemed impossible

00:00:53,059 --> 00:00:57,690
so what we did for that is redesign the

00:00:56,100 --> 00:01:02,989
core of the of the meta programming

00:00:57,690 --> 00:01:06,450
infrastructure and we focused on the

00:01:02,989 --> 00:01:10,229
firstly more more portable leveraging

00:01:06,450 --> 00:01:14,040
the tasty file format that we have now

00:01:10,229 --> 00:01:17,220
and we also focus on making life simpler

00:01:14,040 --> 00:01:20,130
and safer for both the implementers of

00:01:17,220 --> 00:01:24,960
of the macros and the users of the

00:01:20,130 --> 00:01:28,829
macros and we also added some new

00:01:24,960 --> 00:01:31,140
language features which sometimes are or

00:01:28,829 --> 00:01:32,579
just can just be used instead instead of

00:01:31,140 --> 00:01:37,110
the macros that we have we would have

00:01:32,579 --> 00:01:39,630
used in Scala too and so we're going to

00:01:37,110 --> 00:01:42,600
cover these three topics first is in

00:01:39,630 --> 00:01:45,030
line as metric programming feature then

00:01:42,600 --> 00:01:47,070
we're going to cover much types to

00:01:45,030 --> 00:01:51,149
compute new types and then we're going

00:01:47,070 --> 00:01:53,189
to into macros which is really user

00:01:51,149 --> 00:01:56,250
written code that will execute some code

00:01:53,189 --> 00:02:00,869
to compute some new program that will be

00:01:56,250 --> 00:02:02,850
generated in place and there we have two

00:02:00,869 --> 00:02:04,649
subsections which are the quota splices

00:02:02,850 --> 00:02:06,689
which is a simple a high-level API and

00:02:04,649 --> 00:02:09,060
then we have the taste inflection which

00:02:06,689 --> 00:02:12,150
is the equivalent of the abstraction

00:02:09,060 --> 00:02:13,370
that we have right now in in the Scala

00:02:12,150 --> 00:02:15,110
to macros

00:02:13,370 --> 00:02:17,090
they're a bit more restrictive and we're

00:02:15,110 --> 00:02:22,780
going to see exactly what are the

00:02:17,090 --> 00:02:26,810
details of that later so first in line

00:02:22,780 --> 00:02:29,000
so in line seems like it's just an

00:02:26,810 --> 00:02:31,250
optimization I'm going to take this code

00:02:29,000 --> 00:02:33,920
and I'm going to put it wherever I am

00:02:31,250 --> 00:02:36,310
going to call this method but later

00:02:33,920 --> 00:02:38,060
we're going to see how we can make this

00:02:36,310 --> 00:02:40,180
do much more

00:02:38,060 --> 00:02:43,310
so first let's hit the syntax so we have

00:02:40,180 --> 00:02:45,799
this new inline keyword that we can put

00:02:43,310 --> 00:02:48,769
in our death and in this case we have a

00:02:45,799 --> 00:02:49,579
lock lock method that will take a

00:02:48,769 --> 00:02:52,220
message

00:02:49,579 --> 00:02:54,920
print it and then we'll compute some

00:02:52,220 --> 00:02:58,280
chunk well will print the result and

00:02:54,920 --> 00:02:59,870
then we'll return that result so having

00:02:58,280 --> 00:03:02,420
this inline keyword will guarantee us

00:02:59,870 --> 00:03:04,340
that this method will be inlined it

00:03:02,420 --> 00:03:08,750
might also be recursive so we can use

00:03:04,340 --> 00:03:10,940
log inside of log you also have a way to

00:03:08,750 --> 00:03:14,060
specialize a return type I'm going to go

00:03:10,940 --> 00:03:17,630
more in depth later and it's also the

00:03:14,060 --> 00:03:20,510
entry point for macros so a macro is

00:03:17,630 --> 00:03:25,069
just a way to implement this inline

00:03:20,510 --> 00:03:27,109
method so here we can see the class the

00:03:25,069 --> 00:03:31,819
object loader where we implement this

00:03:27,109 --> 00:03:35,060
log function method and here we defined

00:03:31,819 --> 00:03:38,780
an idea variable ident which which is

00:03:35,060 --> 00:03:40,340
public and then inside of the

00:03:38,780 --> 00:03:43,220
implementation what we do is print the

00:03:40,340 --> 00:03:45,799
message we increase this ident then we

00:03:43,220 --> 00:03:49,780
compute the result of the pair of the

00:03:45,799 --> 00:03:53,739
tank and finally we decrease the ident

00:03:49,780 --> 00:03:58,370
now the important part here is that

00:03:53,739 --> 00:03:59,750
chunk must is by name because we don't

00:03:58,370 --> 00:04:02,900
want to compute it before we print the

00:03:59,750 --> 00:04:05,269
message and below there is a snippet

00:04:02,900 --> 00:04:07,489
where we actually use this this log

00:04:05,269 --> 00:04:09,319
operation which with a power function

00:04:07,489 --> 00:04:11,209
and we print a message just before that

00:04:09,319 --> 00:04:15,919
basically tells us which power we're

00:04:11,209 --> 00:04:17,150
computing so when we inline this code it

00:04:15,919 --> 00:04:20,989
will look something like this

00:04:17,150 --> 00:04:24,770
so the message will be put it on in a

00:04:20,989 --> 00:04:27,130
Val then we're going to have the print

00:04:24,770 --> 00:04:28,510
line just before the ident well

00:04:27,130 --> 00:04:31,150
we're going to preface it because we're

00:04:28,510 --> 00:04:35,920
not directly inside of the of the object

00:04:31,150 --> 00:04:39,100
anymore and we are going to have done

00:04:35,920 --> 00:04:43,720
the computation of the power we're going

00:04:39,100 --> 00:04:46,480
to continue new with the intention we

00:04:43,720 --> 00:04:47,890
print the result so as I said before

00:04:46,480 --> 00:04:51,580
it's important to have this distinction

00:04:47,890 --> 00:04:54,490
between by name and by value so if you

00:04:51,580 --> 00:04:59,890
have a by name parameter what we usually

00:04:54,490 --> 00:05:01,390
do is evaluate the the argument and then

00:04:59,890 --> 00:05:04,840
pass the result of the function but with

00:05:01,390 --> 00:05:08,290
a by name parameter we just pass a way

00:05:04,840 --> 00:05:10,570
to compute this in inside of the body of

00:05:08,290 --> 00:05:14,710
log so we need to keep the semantics

00:05:10,570 --> 00:05:17,020
when we in line here we to do that we

00:05:14,710 --> 00:05:19,510
just in line completely the code that

00:05:17,020 --> 00:05:26,410
was in the tank directly in where it's

00:05:19,510 --> 00:05:29,980
used now imagine if our ident variable

00:05:26,410 --> 00:05:31,630
would be private then wherever we're

00:05:29,980 --> 00:05:35,860
going to inline this we might actually

00:05:31,630 --> 00:05:38,470
not have access to this ident to

00:05:35,860 --> 00:05:43,470
overcome this limitation whenever we

00:05:38,470 --> 00:05:47,260
refer to to a private or protected

00:05:43,470 --> 00:05:49,480
member we may create accessors and

00:05:47,260 --> 00:05:51,400
setters for those variables to be able

00:05:49,480 --> 00:05:53,770
to access them from outside though those

00:05:51,400 --> 00:05:55,870
accessors will not be visible from the

00:05:53,770 --> 00:06:01,800
user it will just be generated that

00:05:55,870 --> 00:06:05,260
later in the pipeline now what about

00:06:01,800 --> 00:06:07,240
recursive lien lining some code so here

00:06:05,260 --> 00:06:14,410
we see a power function quite standard

00:06:07,240 --> 00:06:16,030
where we if the values if the if the

00:06:14,410 --> 00:06:21,840
exponent is zero then we just returned

00:06:16,030 --> 00:06:25,450
as one if the exponent is is odd we will

00:06:21,840 --> 00:06:28,440
multiply one the value and then do the

00:06:25,450 --> 00:06:31,920
power of X to the power of minus one and

00:06:28,440 --> 00:06:37,600
if we have an odd power we're going to

00:06:31,920 --> 00:06:39,600
multiply X price and and undo the

00:06:37,600 --> 00:06:41,700
exponent of that to the

00:06:39,600 --> 00:06:43,770
half of what we had before so here we're

00:06:41,700 --> 00:06:46,500
using power inside of the definition of

00:06:43,770 --> 00:06:49,740
power so how are we actually going to

00:06:46,500 --> 00:06:52,740
inline this code let's see if a couple

00:06:49,740 --> 00:06:56,660
with power of X and ten we know

00:06:52,740 --> 00:06:58,710
statically what the value of ten is and

00:06:56,660 --> 00:07:00,420
therefore when we inline this code it

00:06:58,710 --> 00:07:04,290
will look something like that we see

00:07:00,420 --> 00:07:05,850
that because we knew statically ten we

00:07:04,290 --> 00:07:09,000
could constant fold it and use it

00:07:05,850 --> 00:07:11,220
wherever we had before n and then we

00:07:09,000 --> 00:07:13,800
also know static we can also constant

00:07:11,220 --> 00:07:16,680
fold those conditions and know that the

00:07:13,800 --> 00:07:20,430
first two are always false so we know

00:07:16,680 --> 00:07:23,280
we're only going to get the last branch

00:07:20,430 --> 00:07:27,750
therefore the actual result will be this

00:07:23,280 --> 00:07:30,180
code and then we have again a call to

00:07:27,750 --> 00:07:32,150
power which we can recursively in line

00:07:30,180 --> 00:07:36,120
until we don't have any more and we get

00:07:32,150 --> 00:07:44,160
some code that looks like this which

00:07:36,120 --> 00:07:45,690
does not refer in any way to n now what

00:07:44,160 --> 00:07:48,270
happens if we actually don't know

00:07:45,690 --> 00:07:50,550
statically the value of n double here we

00:07:48,270 --> 00:07:52,920
have a bad power where n is just a

00:07:50,550 --> 00:07:54,900
parameter and we don't know so if we

00:07:52,920 --> 00:07:57,090
start inlining we're going to to get

00:07:54,900 --> 00:07:59,300
more and more code and if you see all

00:07:57,090 --> 00:08:03,840
those conditions inside of the ills if

00:07:59,300 --> 00:08:04,950
if we we're never going to be able to to

00:08:03,840 --> 00:08:06,600
know if they're going to be true or

00:08:04,950 --> 00:08:11,100
false therefore this will be just an

00:08:06,600 --> 00:08:15,000
infinite recursion to overcome this

00:08:11,100 --> 00:08:16,590
issue we have or one way to overcome

00:08:15,000 --> 00:08:20,960
this issue is to have this inline

00:08:16,590 --> 00:08:23,030
parameter so what what it does is

00:08:20,960 --> 00:08:25,740
wherever we're going to call this power

00:08:23,030 --> 00:08:28,140
power function we need the argument to

00:08:25,740 --> 00:08:30,090
do that parameter to be a concern a

00:08:28,140 --> 00:08:32,460
constant value unknown constant value

00:08:30,090 --> 00:08:35,219
therefore we're going to be able to

00:08:32,460 --> 00:08:36,930
constant fold later on and this works on

00:08:35,219 --> 00:08:40,020
any primitive values that the compiler

00:08:36,930 --> 00:08:43,590
knows about some take classes such as

00:08:40,020 --> 00:08:45,450
option basically things that the

00:08:43,590 --> 00:08:49,470
compiler already knows how to optimize

00:08:45,450 --> 00:08:51,480
and understands the semantics of it you

00:08:49,470 --> 00:08:52,740
know there's another way to achieve the

00:08:51,480 --> 00:08:54,860
same thing

00:08:52,740 --> 00:08:58,890
for this particular case and it's

00:08:54,860 --> 00:09:00,360
telling that if that it must be reduced

00:08:58,890 --> 00:09:04,560
whenever it's in line so we add this

00:09:00,360 --> 00:09:06,750
this inline keyword but this time on the

00:09:04,560 --> 00:09:09,270
under if statement before they've

00:09:06,750 --> 00:09:12,840
statement to tell wherever I'm going to

00:09:09,270 --> 00:09:16,530
inline this if the condition is known

00:09:12,840 --> 00:09:18,300
then reduce it and if it's not then fail

00:09:16,530 --> 00:09:21,960
and tell me that this thing cannot be

00:09:18,300 --> 00:09:24,180
reduced and don't try to continue and

00:09:21,960 --> 00:09:26,970
this also this will guarantee us that we

00:09:24,180 --> 00:09:29,750
only take one branch of that so if we

00:09:26,970 --> 00:09:33,810
know how this should be reduced and that

00:09:29,750 --> 00:09:35,130
things that variables decrease then we

00:09:33,810 --> 00:09:39,390
know that we're eventually going to

00:09:35,130 --> 00:09:40,950
finish and the error that we would get

00:09:39,390 --> 00:09:43,470
is something similar to that where I say

00:09:40,950 --> 00:09:45,030
we could not reduce because and we talk

00:09:43,470 --> 00:09:50,550
we cannot reduce N equals zero because

00:09:45,030 --> 00:09:54,420
we don't know what n is now this doesn't

00:09:50,550 --> 00:09:56,550
only apply to two if-then-else but you

00:09:54,420 --> 00:10:00,210
can also be used for pattern matching

00:09:56,550 --> 00:10:04,650
with a match so for this let's take this

00:10:00,210 --> 00:10:07,380
simple encoding of piano as an ADT where

00:10:04,650 --> 00:10:10,770
we have a natural number which has two

00:10:07,380 --> 00:10:15,660
cases zero or as a successor of another

00:10:10,770 --> 00:10:19,100
natural and we're going to use it to

00:10:15,660 --> 00:10:23,130
create a twins net method that should

00:10:19,100 --> 00:10:25,440
result after inlining as just the value

00:10:23,130 --> 00:10:28,170
2 for this particular example because we

00:10:25,440 --> 00:10:31,500
have successor of successor 0 so how

00:10:28,170 --> 00:10:35,370
would we implement this we put the in

00:10:31,500 --> 00:10:38,670
line before the the match and then this

00:10:35,370 --> 00:10:41,160
means that one of those branches should

00:10:38,670 --> 00:10:42,960
match whenever we in line this code in

00:10:41,160 --> 00:10:44,790
this case we're going to match twice

00:10:42,960 --> 00:10:47,520
over the successor and then at the end

00:10:44,790 --> 00:10:49,560
once on the zero and we're going to then

00:10:47,520 --> 00:10:54,330
concern for the plus operation or needs

00:10:49,560 --> 00:10:55,950
to create the two and this also

00:10:54,330 --> 00:11:00,490
guarantees that we're only going to take

00:10:55,950 --> 00:11:02,920
one of those branches but

00:11:00,490 --> 00:11:05,290
sometimes we might want to be even more

00:11:02,920 --> 00:11:09,700
precise what happens if we also want to

00:11:05,290 --> 00:11:14,080
refine the type of what is returned so

00:11:09,700 --> 00:11:17,920
for that we have this new notation where

00:11:14,080 --> 00:11:20,050
we are saying the result type is not a

00:11:17,920 --> 00:11:24,250
normal result type but it's just a

00:11:20,050 --> 00:11:27,000
subtype of int that means that after in

00:11:24,250 --> 00:11:30,070
lining this will either have an int or

00:11:27,000 --> 00:11:35,140
or a more precise type such as a literal

00:11:30,070 --> 00:11:38,160
constant type like 1 2 3 therefore we

00:11:35,140 --> 00:11:42,340
could just rewrite using the same

00:11:38,160 --> 00:11:45,070
implementation we could just get it in

00:11:42,340 --> 00:11:50,080
line and know that not 2 has actually

00:11:45,070 --> 00:11:53,920
typed literal 2 and to see another

00:11:50,080 --> 00:11:56,260
example of this let's introduce a class

00:11:53,920 --> 00:11:59,110
hierarchy where we have a Class A and

00:11:56,260 --> 00:12:02,710
Class B that extends a and B has a

00:11:59,110 --> 00:12:04,480
matter that a doesn't have and then we

00:12:02,710 --> 00:12:07,870
have an online method choose that will

00:12:04,480 --> 00:12:10,390
take a boolean on depending on what if

00:12:07,870 --> 00:12:15,490
it's true or false it will either return

00:12:10,390 --> 00:12:18,910
A or B now if it's true it will return a

00:12:15,490 --> 00:12:22,510
and if it's possible return B so if you

00:12:18,910 --> 00:12:26,890
use that thing in that implementation we

00:12:22,510 --> 00:12:30,130
will for Val a of type uppercase a

00:12:26,890 --> 00:12:33,610
choose of true will return us an a but

00:12:30,130 --> 00:12:35,320
with if we if we do it with shoes of

00:12:33,610 --> 00:12:37,500
false we can refine the type to

00:12:35,320 --> 00:12:39,730
something more precise which is B

00:12:37,500 --> 00:12:42,880
usually if we would have just written

00:12:39,730 --> 00:12:45,130
return type as a we would have gotten an

00:12:42,880 --> 00:12:49,840
error there and therefore we can

00:12:45,130 --> 00:12:51,960
actually use choose of a to restrict to

00:12:49,840 --> 00:12:55,900
know that we can actually call methods

00:12:51,960 --> 00:12:58,660
method math on untruth false because we

00:12:55,900 --> 00:13:06,160
have a B which we would would have been

00:12:58,660 --> 00:13:08,470
impossible before last but last but not

00:13:06,160 --> 00:13:11,890
least in this category we imagine if we

00:13:08,470 --> 00:13:13,600
want to implement the set for function

00:13:11,890 --> 00:13:14,050
that will take a type parameter and

00:13:13,600 --> 00:13:18,459
return us

00:13:14,050 --> 00:13:21,850
of that part that type and what we want

00:13:18,459 --> 00:13:25,810
is that if we have an order on the part

00:13:21,850 --> 00:13:27,760
on the T we want a to use a tree set and

00:13:25,810 --> 00:13:31,149
if we don't have an order we just fall

00:13:27,760 --> 00:13:33,149
back to a heart set so in Scala 2 we

00:13:31,149 --> 00:13:35,890
would have to have done some

00:13:33,149 --> 00:13:38,829
prioritization of implicit quite clunky

00:13:35,890 --> 00:13:42,519
in a clunky way but here we can just say

00:13:38,829 --> 00:13:44,980
okay we have this implicit much but here

00:13:42,519 --> 00:13:47,290
we were not giving it anything to the

00:13:44,980 --> 00:13:49,360
match for the value that we're going to

00:13:47,290 --> 00:13:52,660
take is going to be searched so when

00:13:49,360 --> 00:13:54,579
when we say case ordering of T we're

00:13:52,660 --> 00:13:57,490
going to look for that ordering of T and

00:13:54,579 --> 00:13:59,440
if we have it then we're going to take

00:13:57,490 --> 00:14:02,980
that branch and we will instantiate the

00:13:59,440 --> 00:14:10,899
tree set if we don't have it then we

00:14:02,980 --> 00:14:14,440
just fall back to the other set so so

00:14:10,899 --> 00:14:17,170
far we have seen how to refine terms

00:14:14,440 --> 00:14:19,690
into terms and get more precise types

00:14:17,170 --> 00:14:22,660
from terms but there's another way to

00:14:19,690 --> 00:14:25,240
get more precise types and it's getting

00:14:22,660 --> 00:14:28,329
a type from another type so that's what

00:14:25,240 --> 00:14:31,660
type matches are for and so as a first

00:14:28,329 --> 00:14:34,060
example let's see this simple LM match

00:14:31,660 --> 00:14:37,149
type so on the right hand side we see

00:14:34,060 --> 00:14:40,360
that there is an a type X that matches

00:14:37,149 --> 00:14:41,980
some cases usually we at least take one

00:14:40,360 --> 00:14:43,540
parameter for these things because we're

00:14:41,980 --> 00:14:46,750
going to match on that parameter but we

00:14:43,540 --> 00:14:48,880
could have more type parameters in this

00:14:46,750 --> 00:14:50,829
case the first case will take a string

00:14:48,880 --> 00:14:52,600
and if it's a string our element of our

00:14:50,829 --> 00:14:54,940
individual element of a string will be a

00:14:52,600 --> 00:14:56,920
character if it's an array then we're

00:14:54,940 --> 00:14:59,260
going to bind a type that comes from

00:14:56,920 --> 00:15:01,630
that array if it an array of int it will

00:14:59,260 --> 00:15:03,790
be int and if it's an array of boolean

00:15:01,630 --> 00:15:05,500
it will be boolean we use the same

00:15:03,790 --> 00:15:10,529
notation as in normal pattern matching

00:15:05,500 --> 00:15:14,260
where lowercase names mean type bindings

00:15:10,529 --> 00:15:17,230
and now let's see some examples so as I

00:15:14,260 --> 00:15:19,480
said the element of string would be

00:15:17,230 --> 00:15:21,940
equal to correct equivalent to character

00:15:19,480 --> 00:15:24,940
and the element of an array of int would

00:15:21,940 --> 00:15:27,130
be just int because we patter we will go

00:15:24,940 --> 00:15:29,290
into much the second case

00:15:27,130 --> 00:15:32,200
and the element of a list of float will

00:15:29,290 --> 00:15:35,110
be float because we muster case and the

00:15:32,200 --> 00:15:37,149
element of an of Neal would be nothing

00:15:35,110 --> 00:15:39,070
because Neal is actually a list of

00:15:37,149 --> 00:15:44,380
nothing so that's the nothing that we

00:15:39,070 --> 00:15:47,290
get there so to get into a more complex

00:15:44,380 --> 00:15:50,620
example let's introduce this topple

00:15:47,290 --> 00:15:53,980
obstruction where we have a topo which

00:15:50,620 --> 00:15:56,589
has two two subtypes unit which is kind

00:15:53,980 --> 00:16:00,279
of the tail of the of the topple and and

00:15:56,589 --> 00:16:03,250
then we have a cons operator with star

00:16:00,279 --> 00:16:06,450
column then that has a head type and a

00:16:03,250 --> 00:16:09,730
tail type and we're going to construct

00:16:06,450 --> 00:16:12,279
topples by composing those types so but

00:16:09,730 --> 00:16:16,420
on below on the left we can see how we

00:16:12,279 --> 00:16:17,980
would write type with this on the right

00:16:16,420 --> 00:16:24,399
we see the same thing but on the on the

00:16:17,980 --> 00:16:28,870
terms now we're going to add some some

00:16:24,399 --> 00:16:32,829
interesting operations on this the first

00:16:28,870 --> 00:16:36,670
one is the concentrator so we're going

00:16:32,829 --> 00:16:38,260
to inline it to produce some some actual

00:16:36,670 --> 00:16:40,420
code but what you can see is that the

00:16:38,260 --> 00:16:41,950
return type is a constant which is well

00:16:40,420 --> 00:16:45,820
trivially the definition of the cons

00:16:41,950 --> 00:16:48,700
cons so there is no issue there but now

00:16:45,820 --> 00:16:51,790
what happens if we go to Khan cut then

00:16:48,700 --> 00:16:55,450
traditionally we wouldn't have a direct

00:16:51,790 --> 00:16:57,010
way to express that I have my left topo

00:16:55,450 --> 00:16:59,649
and I have my right topple and I want

00:16:57,010 --> 00:17:02,230
the type that corresponds to those two -

00:16:59,649 --> 00:17:05,020
tapas concatenated we would encode that

00:17:02,230 --> 00:17:07,120
with implicit and some more complex

00:17:05,020 --> 00:17:09,130
machinery but here we can just say okay

00:17:07,120 --> 00:17:14,530
give me those two types and I'm going to

00:17:09,130 --> 00:17:16,270
compute the full graduated type and we

00:17:14,530 --> 00:17:19,929
do the same for size but in this case

00:17:16,270 --> 00:17:21,610
we're going to say that size is it's

00:17:19,929 --> 00:17:24,429
either an int if I don't know the size

00:17:21,610 --> 00:17:28,030
of my top oh statically from the type or

00:17:24,429 --> 00:17:33,670
it's going to be a literal int if I know

00:17:28,030 --> 00:17:35,890
the size let's see the first example

00:17:33,670 --> 00:17:37,690
that we already seen in the in the in

00:17:35,890 --> 00:17:39,340
Martin's keynote this is the

00:17:37,690 --> 00:17:42,010
concatenation

00:17:39,340 --> 00:17:45,250
it's quite a forward we take the left

00:17:42,010 --> 00:17:48,130
and the right as x and y then we we say

00:17:45,250 --> 00:17:51,450
that the result of concat will always be

00:17:48,130 --> 00:17:53,920
a topple but maybe something non precise

00:17:51,450 --> 00:17:56,350
and then we give the actual definition

00:17:53,920 --> 00:17:58,900
that will compute the type so we're

00:17:56,350 --> 00:18:02,710
going to say that if the right hand side

00:17:58,900 --> 00:18:05,290
of the of the concat is empty then we

00:18:02,710 --> 00:18:08,520
just take the left hand side if we have

00:18:05,290 --> 00:18:11,020
a non empty topple we're going to take

00:18:08,520 --> 00:18:13,830
the head and we're going to concatenate

00:18:11,020 --> 00:18:16,540
tail no we're going to concert with the

00:18:13,830 --> 00:18:18,790
concatenation of the tail and why this

00:18:16,540 --> 00:18:20,890
is quite familiar because we would have

00:18:18,790 --> 00:18:25,330
implemented it almost the same way on

00:18:20,890 --> 00:18:29,380
lists where and the key difference here

00:18:25,330 --> 00:18:31,210
is that within the match and on the top

00:18:29,380 --> 00:18:33,010
everything is the type to the de

00:18:31,210 --> 00:18:35,530
scrutiny so type the patterns are types

00:18:33,010 --> 00:18:37,900
and the right hand side are types and in

00:18:35,530 --> 00:18:41,440
the normal case in the concat on list

00:18:37,900 --> 00:18:42,760
its we're patching on a term and then we

00:18:41,440 --> 00:18:46,810
have a term as a pattern and we have a

00:18:42,760 --> 00:18:49,600
right hand side which is a term now

00:18:46,810 --> 00:18:53,020
let's look at another type match so this

00:18:49,600 --> 00:18:56,410
is the type match for the successor of

00:18:53,020 --> 00:19:00,490
some particular int so ideally we should

00:18:56,410 --> 00:19:03,460
pass it literal literal int which is

00:19:00,490 --> 00:19:05,950
either 1 2 3 and so on and we want to

00:19:03,460 --> 00:19:07,560
return the successor of that point so

00:19:05,950 --> 00:19:09,850
one way to implement it is like this

00:19:07,560 --> 00:19:12,370
which is straightforward but of course

00:19:09,850 --> 00:19:16,930
it is will not scale so we actually

00:19:12,370 --> 00:19:19,360
implement it directly in the compiler as

00:19:16,930 --> 00:19:22,810
and that can be found in the package

00:19:19,360 --> 00:19:25,090
scholar compile-time s for the Type S of

00:19:22,810 --> 00:19:29,170
successor and now we can use this type

00:19:25,090 --> 00:19:31,780
to compute sighs so sighs we'll take the

00:19:29,170 --> 00:19:35,440
the type of the topple we know that it

00:19:31,780 --> 00:19:38,680
will return at least at most and now if

00:19:35,440 --> 00:19:41,050
the the type of the topple is unit then

00:19:38,680 --> 00:19:44,110
we know statically that these topple is

00:19:41,050 --> 00:19:47,110
is empty and if not if it's not empty we

00:19:44,110 --> 00:19:49,330
can just say that it's the successor of

00:19:47,110 --> 00:19:51,520
the size of the total which would be

00:19:49,330 --> 00:19:53,020
equivalent to a plus 1 if it would have

00:19:51,520 --> 00:19:59,770
been doing the

00:19:53,020 --> 00:20:02,290
on the term level so so far we have seen

00:19:59,770 --> 00:20:05,290
how to how to compute types really

00:20:02,290 --> 00:20:08,050
precise types but we haven't seen how to

00:20:05,290 --> 00:20:10,870
get those types back into terms so for

00:20:08,050 --> 00:20:13,929
this we have those two methods constant

00:20:10,870 --> 00:20:16,510
value and cons value upped the first one

00:20:13,929 --> 00:20:19,300
we'll take a literal and if it's a

00:20:16,510 --> 00:20:22,990
literal it will read just return that

00:20:19,300 --> 00:20:24,760
literal and if it's not it will fail

00:20:22,990 --> 00:20:26,559
compilation on the other hand the second

00:20:24,760 --> 00:20:28,540
one if it's not literal it will return

00:20:26,559 --> 00:20:32,110
none if it's a literal it will return

00:20:28,540 --> 00:20:34,840
some of that literal so now we can

00:20:32,110 --> 00:20:36,429
actually implement our inline method

00:20:34,840 --> 00:20:41,230
size because we're saying that will

00:20:36,429 --> 00:20:45,429
return a size inside we can just take

00:20:41,230 --> 00:20:48,550
that size that we computed asked for the

00:20:45,429 --> 00:20:50,980
value and then we can patter much on

00:20:48,550 --> 00:20:52,750
that value and just optimize away so if

00:20:50,980 --> 00:20:54,429
we actually know the value then we just

00:20:52,750 --> 00:20:55,809
use that value if not we're going to

00:20:54,429 --> 00:21:04,840
compute a fallback and compute at

00:20:55,809 --> 00:21:07,750
runtime so so far we've seen how to to

00:21:04,840 --> 00:21:09,760
generate code by leveraging the mostly

00:21:07,750 --> 00:21:12,190
the constant folding of the compiler but

00:21:09,760 --> 00:21:14,559
here we're going to introduce two to see

00:21:12,190 --> 00:21:17,020
how what happens if we actually want

00:21:14,559 --> 00:21:19,840
custom logic that should do the constant

00:21:17,020 --> 00:21:22,929
folding that's where we introduce macros

00:21:19,840 --> 00:21:25,030
which is more the domain of the old

00:21:22,929 --> 00:21:29,470
skeleton macros but we're going to start

00:21:25,030 --> 00:21:31,660
with a simpler simpler approach to to

00:21:29,470 --> 00:21:33,640
implement them so for that we're going

00:21:31,660 --> 00:21:36,960
to introduce to two different concepts

00:21:33,640 --> 00:21:41,559
quotes and splices so the first quote is

00:21:36,960 --> 00:21:43,150
has this notation it has a quote and

00:21:41,559 --> 00:21:45,340
unblock and inside of a block there is

00:21:43,150 --> 00:21:52,179
an expression that expression in that

00:21:45,340 --> 00:21:54,670
case has type T and what this this block

00:21:52,179 --> 00:21:56,320
means is I'm not going to execute this

00:21:54,670 --> 00:21:59,080
code right now I'm just going to keep it

00:21:56,320 --> 00:22:02,200
as code for later and I'm going to use

00:21:59,080 --> 00:22:04,530
it later in some program and on the

00:22:02,200 --> 00:22:06,730
other hand we have the splice where

00:22:04,530 --> 00:22:08,740
inside of some program and

00:22:06,730 --> 00:22:11,740
case inside of this quote I'm going to

00:22:08,740 --> 00:22:13,570
splice this piece of code and I'm going

00:22:11,740 --> 00:22:16,450
to replace the code that is inside by

00:22:13,570 --> 00:22:21,309
this piece of code this means that X X

00:22:16,450 --> 00:22:25,500
is of type X of T and whatever's inside

00:22:21,309 --> 00:22:29,140
of this splice is going to be computed

00:22:25,500 --> 00:22:30,730
computed when we compute the quote but

00:22:29,140 --> 00:22:33,400
we're going to retain everything that is

00:22:30,730 --> 00:22:35,280
in between the quote under splice this

00:22:33,400 --> 00:22:40,510
is quite similar to swing interpolator

00:22:35,280 --> 00:22:43,929
the syntax is the syntax rules are quite

00:22:40,510 --> 00:22:45,580
similar and but the difference is that

00:22:43,929 --> 00:22:48,250
whatever C directly inside of a code is

00:22:45,580 --> 00:22:50,620
actually a term that can be used within

00:22:48,250 --> 00:22:52,600
the splice again we're going to see some

00:22:50,620 --> 00:22:54,370
examples of that later so we can do

00:22:52,600 --> 00:22:57,520
exactly the same on types we can quote a

00:22:54,370 --> 00:23:04,960
type and then we can splice a type into

00:22:57,520 --> 00:23:07,600
a piece of program so now what how would

00:23:04,960 --> 00:23:09,280
you define the macro with that so we're

00:23:07,600 --> 00:23:13,240
going to retake the same in line def

00:23:09,280 --> 00:23:15,970
power of long and in line int as before

00:23:13,240 --> 00:23:17,500
but instead of implementing directly

00:23:15,970 --> 00:23:20,410
we're going to say okay I have a splice

00:23:17,500 --> 00:23:24,460
here I'm going to compute this

00:23:20,410 --> 00:23:26,049
expression for X unknown N and I'm going

00:23:24,460 --> 00:23:30,549
to insert this code wherever I'm in line

00:23:26,049 --> 00:23:33,520
it so the user will actually not see any

00:23:30,549 --> 00:23:36,460
of those expert types it will only see

00:23:33,520 --> 00:23:42,400
the in line and the normal types that

00:23:36,460 --> 00:23:45,640
you would expect from the user but

00:23:42,400 --> 00:23:47,140
before I said that we had to insert a

00:23:45,640 --> 00:23:49,630
splice inside of another quote or

00:23:47,140 --> 00:23:52,390
program so in this case we don't really

00:23:49,630 --> 00:23:55,840
have a quote directly visible but we're

00:23:52,390 --> 00:23:57,429
assuming that by aligning where our

00:23:55,840 --> 00:24:01,320
quote is actually the program where

00:23:57,429 --> 00:24:03,880
we're in lining this this piece of code

00:24:01,320 --> 00:24:05,679
and this is the exception and the only

00:24:03,880 --> 00:24:10,059
place where you can use a splice that is

00:24:05,679 --> 00:24:11,020
not within another quote now let's do a

00:24:10,059 --> 00:24:13,479
parallel between the previous

00:24:11,020 --> 00:24:17,409
implementation and

00:24:13,479 --> 00:24:21,369
and how we would implement this this X

00:24:17,409 --> 00:24:24,459
this power X so first we can see that

00:24:21,369 --> 00:24:27,609
the type signature differ a bit so

00:24:24,459 --> 00:24:28,839
before we have we had an inline M which

00:24:27,609 --> 00:24:32,529
now becomes just a man

00:24:28,839 --> 00:24:34,869
so before we wanted to know it to

00:24:32,529 --> 00:24:36,399
enforce it to be a constant value and

00:24:34,869 --> 00:24:37,809
now we're just saying okay this is a

00:24:36,399 --> 00:24:41,529
value that I know right now when I'm

00:24:37,809 --> 00:24:44,979
executing this code and on the other

00:24:41,529 --> 00:24:48,339
hand the DX that before we just had it

00:24:44,979 --> 00:24:51,339
as some normal parameter now we have it

00:24:48,339 --> 00:24:53,409
as an extra as an expert of long which

00:24:51,339 --> 00:24:55,450
means that we have some code to refer to

00:24:53,409 --> 00:25:03,579
it but we don't actually know what's its

00:24:55,450 --> 00:25:06,940
value so now wherever we had the inline

00:25:03,579 --> 00:25:09,820
if where we expected it to partially

00:25:06,940 --> 00:25:12,549
evaluate this condition and then

00:25:09,820 --> 00:25:14,679
probably the the remove one of those

00:25:12,549 --> 00:25:17,219
branches instead of that we just have a

00:25:14,679 --> 00:25:21,459
normal program that will just run on

00:25:17,219 --> 00:25:24,489
execute the N equals zero it could be

00:25:21,459 --> 00:25:28,029
any other arbitrary method that the user

00:25:24,489 --> 00:25:30,839
defines but now the result will be a

00:25:28,029 --> 00:25:33,279
quote which means that we're going to

00:25:30,839 --> 00:25:38,259
return a piece of code that we're going

00:25:33,279 --> 00:25:39,849
to insert somewhere you can see that

00:25:38,259 --> 00:25:42,190
there is quite a lot of syntactic

00:25:39,849 --> 00:25:46,089
overhead additional synthetic overhead

00:25:42,190 --> 00:25:48,249
for this but this comes with the with

00:25:46,089 --> 00:25:52,599
the benefit of being able to run

00:25:48,249 --> 00:25:55,779
arbitrary code and here we see how to

00:25:52,599 --> 00:25:59,109
how we can just if our piece of code in

00:25:55,779 --> 00:26:02,320
these cases is defining the Val act and

00:25:59,109 --> 00:26:04,779
it's going to refer twice to the value

00:26:02,320 --> 00:26:06,700
of x that is defined somewhere else and

00:26:04,779 --> 00:26:10,209
then we're going to use that to compute

00:26:06,700 --> 00:26:11,589
the power X with Y and minus two inside

00:26:10,209 --> 00:26:13,329
of the splice and now we're going to

00:26:11,589 --> 00:26:16,889
take whatever was computed from there

00:26:13,329 --> 00:26:16,889
and insert it in this piece of code

00:26:22,350 --> 00:26:30,880
so well type macros cannot go wrong so

00:26:26,680 --> 00:26:34,120
we do have some nice rules to make this

00:26:30,880 --> 00:26:36,970
type check correctly and the the the

00:26:34,120 --> 00:26:39,160
basically the unique rule is for any

00:26:36,970 --> 00:26:41,020
free variable reference the number of

00:26:39,160 --> 00:26:43,060
quoted scopes on the number of spliced

00:26:41,020 --> 00:26:46,530
scopes between the reference and its

00:26:43,060 --> 00:26:49,840
definition must be equal if we have this

00:26:46,530 --> 00:26:51,490
then we can ensure that if this program

00:26:49,840 --> 00:26:58,300
is well well typed whatever we're going

00:26:51,490 --> 00:27:01,630
to generate will also be well typed so

00:26:58,300 --> 00:27:04,420
for example here we have we defined the

00:27:01,630 --> 00:27:05,830
value I and we're using it inside but

00:27:04,420 --> 00:27:07,570
you can see that there is first a splice

00:27:05,830 --> 00:27:09,790
and then a quote in between the

00:27:07,570 --> 00:27:13,140
definition and the use side so we have

00:27:09,790 --> 00:27:16,450
the equal numbers and we can use it and

00:27:13,140 --> 00:27:18,400
the same for X and n but in this case we

00:27:16,450 --> 00:27:22,110
first have a quote and then we wherever

00:27:18,400 --> 00:27:31,000
you use X we have a splice in between

00:27:22,110 --> 00:27:33,190
and the same for n we can also see that

00:27:31,000 --> 00:27:36,550
we have references for example too long

00:27:33,190 --> 00:27:38,230
and the x operation and other operations

00:27:36,550 --> 00:27:40,000
those are not really free variables

00:27:38,230 --> 00:27:42,100
because they're known statically and

00:27:40,000 --> 00:27:44,710
globally so they don't depend on the

00:27:42,100 --> 00:27:47,500
current context of this method so those

00:27:44,710 --> 00:27:54,880
anything that is globally defined can be

00:27:47,500 --> 00:27:57,070
accessed inside of a quote now what

00:27:54,880 --> 00:27:59,920
about white box macros actually this

00:27:57,070 --> 00:28:02,500
becomes fairly trivial well because it's

00:27:59,920 --> 00:28:03,910
basically just a combination of the

00:28:02,500 --> 00:28:08,200
specialized return type that we said

00:28:03,910 --> 00:28:10,270
before and I'm across a body for the

00:28:08,200 --> 00:28:13,620
inline method so basically if we compute

00:28:10,270 --> 00:28:16,630
some expression within that that splice

00:28:13,620 --> 00:28:18,430
if it's more if it's more precise than X

00:28:16,630 --> 00:28:22,780
in this case then we're actually going

00:28:18,430 --> 00:28:24,910
to insert something that is more precise

00:28:22,780 --> 00:28:28,090
and we're going to use that type at the

00:28:24,910 --> 00:28:33,100
call site just like with normal in line

00:28:28,090 --> 00:28:36,440
with the sub type return type

00:28:33,100 --> 00:28:38,810
so what if we actually want to inspect

00:28:36,440 --> 00:28:42,530
inside and see what's the value inside

00:28:38,810 --> 00:28:47,440
of a fact of some expression so let's

00:28:42,530 --> 00:28:50,990
take this example where we have a topo

00:28:47,440 --> 00:28:53,480
we want we want to swap the elements and

00:28:50,990 --> 00:28:55,220
this particular implementation if it

00:28:53,480 --> 00:28:57,020
receives a reference and it will just

00:28:55,220 --> 00:28:59,360
call the normals what method on the

00:28:57,020 --> 00:29:00,770
topple but if we receive it explicitly

00:28:59,360 --> 00:29:03,680
we'll just swap the elements and

00:29:00,770 --> 00:29:06,320
construct the topple directly here we

00:29:03,680 --> 00:29:08,060
take this topple by name because in the

00:29:06,320 --> 00:29:09,950
second case where we swap the topple we

00:29:08,060 --> 00:29:13,130
don't want to evaluate the first topple

00:29:09,950 --> 00:29:15,050
in the first place now to actually

00:29:13,130 --> 00:29:17,990
implement this is quite straightforward

00:29:15,050 --> 00:29:21,200
because we can just take this topple

00:29:17,990 --> 00:29:23,900
that we have as an input and just utter

00:29:21,200 --> 00:29:26,270
much on it with a quote as pattern so

00:29:23,900 --> 00:29:28,490
here we can see that we're pattern we

00:29:26,270 --> 00:29:31,130
were expecting at at a pole of size two

00:29:28,490 --> 00:29:33,200
and we're going to get each of the

00:29:31,130 --> 00:29:34,490
reference which was the elements and

00:29:33,200 --> 00:29:36,680
we're going to then construct another

00:29:34,490 --> 00:29:40,690
topple and we're going to put those

00:29:36,680 --> 00:29:44,180
elements in but in the reverse order so

00:29:40,690 --> 00:29:49,640
one important note here is that this

00:29:44,180 --> 00:29:52,190
pattern is is fully typed and the type

00:29:49,640 --> 00:29:53,630
of x one is statically known and will be

00:29:52,190 --> 00:29:55,750
statically known on the other side when

00:29:53,630 --> 00:29:59,780
we were constructed therefore everything

00:29:55,750 --> 00:30:01,280
everything is again fully typed this has

00:29:59,780 --> 00:30:04,940
some limitations because we could not

00:30:01,280 --> 00:30:07,090
ask am i calling some method called

00:30:04,940 --> 00:30:11,330
apply without being a subtype of

00:30:07,090 --> 00:30:12,950
function or something like that now if

00:30:11,330 --> 00:30:15,800
you look at the other example we were

00:30:12,950 --> 00:30:23,570
basically going to just use the topple

00:30:15,800 --> 00:30:25,190
and call upon it so lastly I added here

00:30:23,570 --> 00:30:28,100
we can see that there is an extra

00:30:25,190 --> 00:30:30,410
parameter called reflection this is what

00:30:28,100 --> 00:30:33,410
allows us to look to to decompose the

00:30:30,410 --> 00:30:35,810
top I'm going to go in and describe what

00:30:33,410 --> 00:30:38,240
it actually does internally later but

00:30:35,810 --> 00:30:40,700
for now as long as we just partner much

00:30:38,240 --> 00:30:43,450
on in quotes we just need to have it but

00:30:40,700 --> 00:30:46,070
we don't care about what's inside now

00:30:43,450 --> 00:30:48,710
for another example

00:30:46,070 --> 00:30:49,910
the previous example we were we were

00:30:48,710 --> 00:30:52,640
pattern matching on the shape of the

00:30:49,910 --> 00:30:55,190
tree but sometimes we want to do to get

00:30:52,640 --> 00:30:59,270
some other properties of the of the of

00:30:55,190 --> 00:31:02,720
the expression so let's retake the the

00:30:59,270 --> 00:31:05,059
power function like we had in the

00:31:02,720 --> 00:31:07,460
previous version but this one is just

00:31:05,059 --> 00:31:10,840
the one that just computes the power and

00:31:07,460 --> 00:31:15,770
then the power X will compute the code

00:31:10,840 --> 00:31:18,260
for a power for a known and and we're

00:31:15,770 --> 00:31:22,040
going to use it in our implementation of

00:31:18,260 --> 00:31:23,840
this expert 2 that will receive 2

00:31:22,040 --> 00:31:26,900
expressions so we don't statically know

00:31:23,840 --> 00:31:29,799
any of the values but we can pattern

00:31:26,900 --> 00:31:34,220
match on both with this Const and

00:31:29,799 --> 00:31:37,460
extractor that will return match if the

00:31:34,220 --> 00:31:39,020
value inside if the if the expression is

00:31:37,460 --> 00:31:41,390
actually a value and we just return is

00:31:39,020 --> 00:31:43,669
the value so if we know about values we

00:31:41,390 --> 00:31:45,890
can just call at want at compile time

00:31:43,669 --> 00:31:48,110
the power function and then take that

00:31:45,890 --> 00:31:51,559
that value that we have computed and

00:31:48,110 --> 00:31:53,360
create an expression from it I'm insert

00:31:51,559 --> 00:32:00,020
it into a program if we only know the

00:31:53,360 --> 00:32:01,940
the the the exponent then we can use the

00:32:00,020 --> 00:32:07,120
power expert to generate the optimal

00:32:01,940 --> 00:32:10,190
code for for that that doesn't reference

00:32:07,120 --> 00:32:13,130
anymore and if we don't know anything

00:32:10,190 --> 00:32:14,600
then we can just quote the the power

00:32:13,130 --> 00:32:17,000
function which means that we're going to

00:32:14,600 --> 00:32:22,190
compute this power function later on at

00:32:17,000 --> 00:32:27,130
runtime and again we need this

00:32:22,190 --> 00:32:27,130
reflection refraction parameter

00:32:28,950 --> 00:32:35,730
so so far we've seen well typed macros

00:32:33,120 --> 00:32:38,970
so now we're going to go into what is

00:32:35,730 --> 00:32:43,320
more similar to to just color to macros

00:32:38,970 --> 00:32:49,470
and where we are going to just use an IP

00:32:43,320 --> 00:32:51,840
I directly on trees to really deep deep

00:32:49,470 --> 00:32:58,980
into all the properties of the of the

00:32:51,840 --> 00:33:02,760
expression so first we have this tasty

00:32:58,980 --> 00:33:05,250
concept we have it as both as a file

00:33:02,760 --> 00:33:10,620
format which is a standard encoding for

00:33:05,250 --> 00:33:13,440
Scala tree type trees and these type s3

00:33:10,620 --> 00:33:17,990
ASDs have a source position they also

00:33:13,440 --> 00:33:20,430
contain color comments it's extendable

00:33:17,990 --> 00:33:23,490
and on the other hand we have things to

00:33:20,430 --> 00:33:25,890
reflect which is what we used before as

00:33:23,490 --> 00:33:28,230
parameters so this is just an interface

00:33:25,890 --> 00:33:31,790
on top of those trees that allow us to

00:33:28,230 --> 00:33:34,500
allows us to inspect and construct trees

00:33:31,790 --> 00:33:39,540
it also allows us to inspect positions

00:33:34,500 --> 00:33:43,110
and dot comments and it's double the

00:33:39,540 --> 00:33:46,890
stability of this interface is given by

00:33:43,110 --> 00:33:50,430
the stability of the file format so

00:33:46,890 --> 00:33:52,230
that's one of the reasons why we will

00:33:50,430 --> 00:33:54,330
not have the same portability problem as

00:33:52,230 --> 00:33:55,740
with Scala to Macross because our

00:33:54,330 --> 00:33:59,780
interface is not with the compiler

00:33:55,740 --> 00:33:59,780
itself it's with this table file format

00:34:01,430 --> 00:34:06,930
so before I showed how to use this Const

00:34:05,070 --> 00:34:10,169
extractor but now we're going to see how

00:34:06,930 --> 00:34:12,360
we actually implement it so the

00:34:10,169 --> 00:34:16,940
implementation here will receive this

00:34:12,360 --> 00:34:20,310
reflection which is our API ie on trees

00:34:16,940 --> 00:34:22,380
first were to use it we're just going to

00:34:20,310 --> 00:34:24,870
import the contents of this reflection

00:34:22,380 --> 00:34:27,240
which will give us access to all the

00:34:24,870 --> 00:34:29,820
types of the methods and everything that

00:34:27,240 --> 00:34:33,900
is all the logic that we could do on on

00:34:29,820 --> 00:34:36,060
trees so to use that we first at the

00:34:33,900 --> 00:34:39,600
bottom have an expression and we will

00:34:36,060 --> 00:34:42,179
want to unseal it that means taking an

00:34:39,600 --> 00:34:44,760
expression and viewing it as a tree

00:34:42,179 --> 00:34:46,440
and in this particular case because it's

00:34:44,760 --> 00:34:51,240
an expression it's actually a term which

00:34:46,440 --> 00:34:57,059
is about some type of tree that we're

00:34:51,240 --> 00:35:01,760
going to work on so we can also pattern

00:34:57,059 --> 00:35:04,890
match on different internal trees in

00:35:01,760 --> 00:35:07,410
this case we are going to just if it's a

00:35:04,890 --> 00:35:10,349
little then we're going to take it if

00:35:07,410 --> 00:35:11,700
it's a block with empty statements we're

00:35:10,349 --> 00:35:14,779
just going to ignore the statements and

00:35:11,700 --> 00:35:18,890
say yeah it's it's a literal it's fine

00:35:14,779 --> 00:35:21,630
but note that there is a cast here

00:35:18,890 --> 00:35:23,390
because we take the value from a term

00:35:21,630 --> 00:35:25,829
the term doesn't have the information

00:35:23,390 --> 00:35:28,619
formation as we had with the expression

00:35:25,829 --> 00:35:30,119
so here we we lose some some some

00:35:28,619 --> 00:35:32,549
assurance from the type system that this

00:35:30,119 --> 00:35:34,289
will actually succeed but of course in

00:35:32,549 --> 00:35:36,029
this case we know it will because we

00:35:34,289 --> 00:35:38,910
know that we got an expression of that

00:35:36,029 --> 00:35:47,549
key so if it's if it contains a value it

00:35:38,910 --> 00:35:49,829
must be a value of that same T so we

00:35:47,549 --> 00:35:53,010
have we already have some some quite

00:35:49,829 --> 00:35:56,430
advanced prototypes so for for one there

00:35:53,010 --> 00:35:59,069
is the shapeless tree which uses special

00:35:56,430 --> 00:36:01,470
line is in line test in line matches an

00:35:59,069 --> 00:36:03,750
implicit match it doesn't use any macros

00:36:01,470 --> 00:36:07,289
currently we're going to experiment to

00:36:03,750 --> 00:36:11,910
see what happens if we use them what

00:36:07,289 --> 00:36:13,680
else can we do then the implementation

00:36:11,910 --> 00:36:15,510
that I showed before of the topple is

00:36:13,680 --> 00:36:17,849
actually a simplification of what we

00:36:15,510 --> 00:36:19,680
actually do in the compiler in our

00:36:17,849 --> 00:36:23,329
standard library to extend the tuples

00:36:19,680 --> 00:36:26,900
and have topples of rit more than 22

00:36:23,329 --> 00:36:32,609
we basically generalized topples to have

00:36:26,900 --> 00:36:35,339
normal h list properties and for that we

00:36:32,609 --> 00:36:38,490
just used much types and inline nothing

00:36:35,339 --> 00:36:45,299
more and then we use a few optimizations

00:36:38,490 --> 00:36:48,089
inside we also implement help for

00:36:45,299 --> 00:36:49,820
implementing all the macros in scala

00:36:48,089 --> 00:36:57,470
test

00:36:49,820 --> 00:37:00,320
the it was quite a lot of work and then

00:36:57,470 --> 00:37:03,650
we have a couple of other outliers where

00:37:00,320 --> 00:37:05,270
we some string interpolators term across

00:37:03,650 --> 00:37:06,950
andhra implemented with mattress so

00:37:05,270 --> 00:37:09,410
there is there F interpolator that is in

00:37:06,950 --> 00:37:12,260
the standard library which uses the

00:37:09,410 --> 00:37:14,720
macros to check that the contents of the

00:37:12,260 --> 00:37:17,030
three that the F interpolator are are

00:37:14,720 --> 00:37:20,620
correctly formatted and it will not fail

00:37:17,030 --> 00:37:24,500
the parsing of the formatting at runtime

00:37:20,620 --> 00:37:28,160
and we also have an XML string

00:37:24,500 --> 00:37:30,380
interpolator which uses macros which I'm

00:37:28,160 --> 00:37:32,830
specializing in line in this case the

00:37:30,380 --> 00:37:36,710
other one that did has only used macros

00:37:32,830 --> 00:37:45,830
and the XML interpreter is intended to

00:37:36,710 --> 00:38:11,750
replace the XML literals so thank you is

00:37:45,830 --> 00:38:14,030
there any questions in the center hi how

00:38:11,750 --> 00:38:16,330
does this connect with if it's round

00:38:14,030 --> 00:38:22,880
Scour meter

00:38:16,330 --> 00:38:24,320
it doesn't really connect so we had

00:38:22,880 --> 00:38:26,930
another actually we have another

00:38:24,320 --> 00:38:28,820
prototype where we but we didn't use

00:38:26,930 --> 00:38:34,220
exactly macro infrastructure but we use

00:38:28,820 --> 00:38:36,770
the Tastee reflect interface to to take

00:38:34,220 --> 00:38:42,380
the tasty trees and generate the

00:38:36,770 --> 00:38:45,650
semantics DB that that meta uses so it's

00:38:42,380 --> 00:38:47,290
kind of separate but we can generate one

00:38:45,650 --> 00:38:53,860
from the other

00:38:47,290 --> 00:38:57,850
Thanks will there be any replacement for

00:38:53,860 --> 00:39:01,400
two runtime reflection in particular

00:38:57,850 --> 00:39:03,350
reflecting over types at runtime yeah

00:39:01,400 --> 00:39:18,620
not not right now not with

00:39:03,350 --> 00:39:21,650
infrastructure okay two questions first

00:39:18,620 --> 00:39:24,200
one how do you raise custom compilation

00:39:21,650 --> 00:39:30,380
errors from inline methods and macro oh

00:39:24,200 --> 00:39:34,010
yeah but we have a couple of other

00:39:30,380 --> 00:39:37,000
methods in the compile time package for

00:39:34,010 --> 00:39:40,160
inline med method so if you there is an

00:39:37,000 --> 00:39:42,170
scholar compile time error method that

00:39:40,160 --> 00:39:44,450
if you call inside of an online method

00:39:42,170 --> 00:39:48,560
and it gets in line and then that branch

00:39:44,450 --> 00:39:49,940
is not eliminated then it will emit an

00:39:48,560 --> 00:39:59,000
error with the message that you wrote

00:39:49,940 --> 00:40:01,820
inside okay and for if we have quotes or

00:39:59,000 --> 00:40:04,480
slices we have a similar but different

00:40:01,820 --> 00:40:11,210
mechanism to also raise exceptions and

00:40:04,480 --> 00:40:13,460
if we actually if you use the reflect

00:40:11,210 --> 00:40:15,470
API then we can even go more precise for

00:40:13,460 --> 00:40:17,090
example in the in the string

00:40:15,470 --> 00:40:19,520
interpolators we could get error

00:40:17,090 --> 00:40:21,140
messages for sub part of the string and

00:40:19,520 --> 00:40:24,980
say this part of the string is not

00:40:21,140 --> 00:40:27,320
correctly formatted okay I also wanted

00:40:24,980 --> 00:40:30,050
to ask about the example with much types

00:40:27,320 --> 00:40:32,900
I noticed that you have matched nil type

00:40:30,050 --> 00:40:37,370
against an iterable type oh yeah which

00:40:32,900 --> 00:40:40,850
kind of assumed the subtyping what if I

00:40:37,370 --> 00:40:45,140
wanted to match a type exactly against

00:40:40,850 --> 00:40:47,810
an interval and this way I wanted I

00:40:45,140 --> 00:40:49,790
didn't want to accept the subtype of a

00:40:47,810 --> 00:40:52,210
literal but exactly an iterable of

00:40:49,790 --> 00:40:52,210
something

00:40:56,590 --> 00:41:03,060
I think this was visible in one of the

00:40:58,960 --> 00:41:07,000
next slides yes this one right oh yes

00:41:03,060 --> 00:41:21,640
yeah I'm actually not sure how we would

00:41:07,000 --> 00:41:25,090
encode yeah Martin so so one thing you

00:41:21,640 --> 00:41:28,000
could do is you put both these scrutiny

00:41:25,090 --> 00:41:30,580
the X and the pattern in a non variant

00:41:28,000 --> 00:41:33,220
tight black box right so you say is

00:41:30,580 --> 00:41:35,140
boutonnieres box of X and you pattern

00:41:33,220 --> 00:41:37,240
match against box of iterable because

00:41:35,140 --> 00:41:39,100
box is non variant together subtype only

00:41:37,240 --> 00:41:42,600
if it's exactly the type so that's

00:41:39,100 --> 00:41:42,600
that's how you would do it I guess

00:41:47,430 --> 00:41:53,230
will there be quasi quotes or just do

00:41:50,980 --> 00:41:56,560
the other quotes in spices kind of

00:41:53,230 --> 00:41:58,930
supplant that so yeah Costa quotes and

00:41:56,560 --> 00:42:03,790
the quotes on spices are quite like were

00:41:58,930 --> 00:42:05,950
different because Co so spices as I show

00:42:03,790 --> 00:42:08,020
them are just expressions the quasi

00:42:05,950 --> 00:42:15,220
quotes were countries so the Casa codes

00:42:08,020 --> 00:42:18,550
are a nice way to abstract over the

00:42:15,220 --> 00:42:20,350
trees so it's not currently the plan to

00:42:18,550 --> 00:42:23,050
actually implement them but it would be

00:42:20,350 --> 00:42:26,320
possible to edit later just as a layer

00:42:23,050 --> 00:42:28,960
on top of the tree API but because we

00:42:26,320 --> 00:42:32,710
already had this nice nice quotes or

00:42:28,960 --> 00:42:36,280
splices we usually can do most of the

00:42:32,710 --> 00:42:38,080
work directly on that and whenever we

00:42:36,280 --> 00:42:41,110
have to put switch to the other it's

00:42:38,080 --> 00:42:44,440
really not too big so it has not so far

00:42:41,110 --> 00:42:51,109
has been really necessary to write short

00:42:44,440 --> 00:42:54,269
code um is this feature

00:42:51,109 --> 00:42:59,039
experimental like macros in Scala 2 or

00:42:54,269 --> 00:43:01,739
is really feature color 3 it is a so all

00:42:59,039 --> 00:43:04,200
the first one first which was with type

00:43:01,739 --> 00:43:07,190
matches and in line are concrete

00:43:04,200 --> 00:43:11,400
features the code set splices will be

00:43:07,190 --> 00:43:17,569
probably for Scala tree one and and the

00:43:11,400 --> 00:43:20,279
other one under the the the reflect

00:43:17,569 --> 00:43:22,769
we're going to use it internally at

00:43:20,279 --> 00:43:25,970
least I'm not sure if it will will be

00:43:22,769 --> 00:43:31,799
fully stable by three one but eventually

00:43:25,970 --> 00:43:33,809
it should be also part of because in

00:43:31,799 --> 00:43:37,920
this case what we're actually reflecting

00:43:33,809 --> 00:43:40,980
is the is the tasty format which will be

00:43:37,920 --> 00:43:43,859
stable from we want to ensure that will

00:43:40,980 --> 00:43:46,099
be stable from 3 1 onwards so from there

00:43:43,859 --> 00:43:54,720
onwards we should also be able to just

00:43:46,099 --> 00:43:57,869
have a stable API for that will in

00:43:54,720 --> 00:43:59,940
lining the solution to overcome type

00:43:57,869 --> 00:44:05,640
erasure or will you still need class

00:43:59,940 --> 00:44:09,390
text for that we can leverage in line to

00:44:05,640 --> 00:44:12,660
to leverage type erasure I actually

00:44:09,390 --> 00:44:15,890
showed some example to to Dennis who

00:44:12,660 --> 00:44:20,519
does aspire that is presenting right now

00:44:15,890 --> 00:44:24,390
where if so the main idea is if you have

00:44:20,519 --> 00:44:26,279
a type parameter and you create an

00:44:24,390 --> 00:44:28,950
inline method this method will be in

00:44:26,279 --> 00:44:31,319
line before it's the type is irate so

00:44:28,950 --> 00:44:33,119
whenever we are going to specialize will

00:44:31,319 --> 00:44:36,329
already know the more precise type

00:44:33,119 --> 00:44:38,730
information now we have to discover

00:44:36,329 --> 00:44:40,920
that's not trivial for all the cases

00:44:38,730 --> 00:44:43,980
sometimes we may need to find the

00:44:40,920 --> 00:44:47,099
correct coding patterns to achieve all

00:44:43,980 --> 00:44:50,549
that we want with a razor but for the

00:44:47,099 --> 00:44:56,819
most straightforward things it's it's

00:44:50,549 --> 00:44:58,710
trivial is there a rule of thumbs as to

00:44:56,819 --> 00:45:01,829
when you should use inline and when you

00:44:58,710 --> 00:45:03,589
should use macros the rule is start with

00:45:01,829 --> 00:45:05,839
inline if that were

00:45:03,589 --> 00:45:07,940
for your ears case then probably stick

00:45:05,839 --> 00:45:11,359
with it if you need more power then go

00:45:07,940 --> 00:45:13,339
to macros but because you saw that the

00:45:11,359 --> 00:45:14,900
the the inline definition is exactly the

00:45:13,339 --> 00:45:16,339
same you don't need to change the

00:45:14,900 --> 00:45:18,349
interface that the user will see so you

00:45:16,339 --> 00:45:19,849
create an inline def you you create our

00:45:18,349 --> 00:45:22,039
method and then you see oh I need more

00:45:19,849 --> 00:45:26,509
then you just change the implementation

00:45:22,039 --> 00:45:30,079
to use something more powerful thank you

00:45:26,509 --> 00:45:32,690
for to talk what with what will happen

00:45:30,079 --> 00:45:38,690
if I create an infinite loop in a match

00:45:32,690 --> 00:45:40,940
type there are some mechanisms the

00:45:38,690 --> 00:45:43,940
compiler will keep track of recursion

00:45:40,940 --> 00:45:46,849
and if you go too far it will just tell

00:45:43,940 --> 00:45:50,869
you how we reach this maximum recursion

00:45:46,849 --> 00:45:53,539
limit and if it's actually a I mean if

00:45:50,869 --> 00:46:00,319
you actually have a really long type you

00:45:53,539 --> 00:46:05,539
may increase that limits manually hello

00:46:00,319 --> 00:46:06,979
thank you for the talk ok we thought it

00:46:05,539 --> 00:46:10,489
was fantastic and I learned quite a lot

00:46:06,979 --> 00:46:12,440
like dimensions tasty is intended to be

00:46:10,489 --> 00:46:15,890
a non compiler is specific which I

00:46:12,440 --> 00:46:17,809
really love is there anything that it

00:46:15,890 --> 00:46:19,849
would be useful for kind of from an

00:46:17,809 --> 00:46:21,440
external tooling standpoint at this

00:46:19,849 --> 00:46:24,289
point or is it right now just the first

00:46:21,440 --> 00:46:27,140
phase of some more general concept Oh

00:46:24,289 --> 00:46:29,509
tasty we're already using tasty for the

00:46:27,140 --> 00:46:31,759
ID for example okay so we get all the

00:46:29,509 --> 00:46:33,410
information that the edid once from the

00:46:31,759 --> 00:46:35,839
tasty so we compile down to tasty and

00:46:33,410 --> 00:46:37,249
then the ID just loads that and looks at

00:46:35,839 --> 00:46:38,779
the tree is the position it finds the

00:46:37,249 --> 00:46:40,460
position it can find where the

00:46:38,779 --> 00:46:42,829
references are from that and all those

00:46:40,460 --> 00:46:44,989
kinds of things we also can do

00:46:42,829 --> 00:46:46,640
documentation from it because we all

00:46:44,989 --> 00:46:47,869
have all the documents in there so we

00:46:46,640 --> 00:46:49,130
are actually just compiling and then

00:46:47,869 --> 00:46:51,160
there is an other thing that will

00:46:49,130 --> 00:46:55,210
consume that tasty and generate the docs

00:46:51,160 --> 00:46:55,210
it makes me very happy thank you

00:47:06,010 --> 00:47:09,460
thanks for the talk

00:47:09,619 --> 00:47:16,220
how it's an inland F represented and

00:47:13,460 --> 00:47:20,900
tasty as a completely in light already

00:47:16,220 --> 00:47:27,820
or is it still as a function or oh yeah

00:47:20,900 --> 00:47:30,560
so in tasty we we basically keep the the

00:47:27,820 --> 00:47:32,930
whenever we have a we keep the whole

00:47:30,560 --> 00:47:35,390
tree inside of the author of the file so

00:47:32,930 --> 00:47:37,670
whenever we're we just keep that tree we

00:47:35,390 --> 00:47:40,310
keep we will mark it as in line and we

00:47:37,670 --> 00:47:43,520
massage a bit the body of the in line

00:47:40,310 --> 00:47:45,740
method to make it be inlinable easily in

00:47:43,520 --> 00:47:48,020
liable but then whenever you're going to

00:47:45,740 --> 00:47:50,510
in line it what we need to do is just

00:47:48,020 --> 00:47:53,210
grow into tasty you read the tasty take

00:47:50,510 --> 00:47:55,310
that tree that is there and take that

00:47:53,210 --> 00:48:04,099
tree directly and then start constant

00:47:55,310 --> 00:48:07,040
folding and doing the rest alright thank

00:48:04,099 --> 00:48:09,770
you very much for the talk Nicola guys

00:48:07,040 --> 00:48:11,720
we are really running over time I think

00:48:09,770 --> 00:48:12,880
we have to stop the question answer

00:48:11,720 --> 00:48:19,059
session thank you

00:48:12,880 --> 00:48:19,059

YouTube URL: https://www.youtube.com/watch?v=ZfDS_gJyPTc


