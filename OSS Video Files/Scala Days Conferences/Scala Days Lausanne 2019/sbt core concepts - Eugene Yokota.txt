Title: sbt core concepts - Eugene Yokota
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/sbt-core-concepts
Captions: 
	00:00:08,809 --> 00:00:17,190
well thanks for coming to my talk this

00:00:13,170 --> 00:00:20,880
is a SVT core concepts I am using your

00:00:17,190 --> 00:00:24,660
quota from light band Scala team and

00:00:20,880 --> 00:00:29,849
also the SVT or current maintainer so

00:00:24,660 --> 00:00:32,369
the goal of this talk is to kind of gain

00:00:29,849 --> 00:00:35,010
bitter intuition about SVT I'm gonna go

00:00:32,369 --> 00:00:36,390
over a lot of details today but don't

00:00:35,010 --> 00:00:39,149
really worry about like fully

00:00:36,390 --> 00:00:41,219
understanding like details because the

00:00:39,149 --> 00:00:44,309
you know the whole point is to kind of

00:00:41,219 --> 00:00:46,710
like see what the design philosophy or

00:00:44,309 --> 00:00:49,980
the design principles behind SVT and

00:00:46,710 --> 00:00:52,440
kind of like understand like why and

00:00:49,980 --> 00:00:55,110
what's happening rather than like the

00:00:52,440 --> 00:00:59,039
details so to put it into a little

00:00:55,110 --> 00:01:01,590
context a speakeasy point 3 if you

00:00:59,039 --> 00:01:05,280
google it it came out and like December

00:01:01,590 --> 00:01:07,470
of 2008 so it's actually now a ten and a

00:01:05,280 --> 00:01:09,659
half year old the build tool which is

00:01:07,470 --> 00:01:12,479
really amazing basically kind of trailed

00:01:09,659 --> 00:01:14,820
right behind the bird you know the Scala

00:01:12,479 --> 00:01:18,240
and yeah so it has a really long history

00:01:14,820 --> 00:01:19,710
and all these different things and I've

00:01:18,240 --> 00:01:23,040
been fortunate to basically maintain

00:01:19,710 --> 00:01:25,590
maybe last like four or five years of

00:01:23,040 --> 00:01:28,740
history of you know making it better to

00:01:25,590 --> 00:01:31,350
old basically so before I go ahead and

00:01:28,740 --> 00:01:33,780
get into the actual talk I want to just

00:01:31,350 --> 00:01:36,869
like a plug this thing called the SBT by

00:01:33,780 --> 00:01:40,259
example this is one of the reference

00:01:36,869 --> 00:01:43,770
manual has this one page that introduces

00:01:40,259 --> 00:01:47,130
you on how do we basically use SBT and

00:01:43,770 --> 00:01:49,950
one single page starting from the

00:01:47,130 --> 00:01:52,890
minimal build which is actually just

00:01:49,950 --> 00:01:55,259
like touch build Scala and that's like a

00:01:52,890 --> 00:01:57,780
blank file and that's actually a minimal

00:01:55,259 --> 00:02:00,689
build and then from there it basically

00:01:57,780 --> 00:02:03,329
shows you how to put a skull aversion in

00:02:00,689 --> 00:02:05,850
there all the way to how to make a dark

00:02:03,329 --> 00:02:06,930
rise application like you know check the

00:02:05,850 --> 00:02:10,020
weather or something like that

00:02:06,930 --> 00:02:11,520
so let's law if you know someone and you

00:02:10,020 --> 00:02:13,440
know if your colleague is asking how do

00:02:11,520 --> 00:02:17,580
I get into a Spiti this is pretty a good

00:02:13,440 --> 00:02:20,640
good start so what's up the old stool

00:02:17,580 --> 00:02:26,220
uh-huh alright it's there's a paper that

00:02:20,640 --> 00:02:27,630
came out last year by mu golf not sure

00:02:26,220 --> 00:02:30,210
if I'm pronouncing it the last name

00:02:27,630 --> 00:02:32,670
correctly Mitchell and actually Simon

00:02:30,210 --> 00:02:36,570
Keaton Jones wrote this paper called the

00:02:32,670 --> 00:02:39,330
the build system ala carte on using

00:02:36,570 --> 00:02:42,330
their definition built system or build

00:02:39,330 --> 00:02:46,830
tool is something that automates

00:02:42,330 --> 00:02:49,470
repeatable tasks so in there sort of

00:02:46,830 --> 00:02:51,240
like a framework of thinking excel is

00:02:49,470 --> 00:02:54,450
actually a build tool if you think about

00:02:51,240 --> 00:02:55,800
it you set up a bunch of functions all

00:02:54,450 --> 00:02:57,930
right and then you plug in some numbers

00:02:55,800 --> 00:02:58,620
you're like a quarter new cells or

00:02:57,930 --> 00:03:00,930
something like that

00:02:58,620 --> 00:03:03,120
and then the other cells that calculates

00:03:00,930 --> 00:03:04,950
these numbers but you basically set

00:03:03,120 --> 00:03:07,740
something up so that you can repeat that

00:03:04,950 --> 00:03:10,530
process and to some you know build

00:03:07,740 --> 00:03:13,050
basically is there's all our things that

00:03:10,530 --> 00:03:15,270
happens that basically sets up the

00:03:13,050 --> 00:03:18,000
repeatable tasks and there are specific

00:03:15,270 --> 00:03:21,870
designs that the build tool use which

00:03:18,000 --> 00:03:24,410
will look into the other aspect I think

00:03:21,870 --> 00:03:27,990
that isn't really specifically set out

00:03:24,410 --> 00:03:30,600
and SVT's manual or the getting started

00:03:27,990 --> 00:03:32,880
page but it's kind of like got to know

00:03:30,600 --> 00:03:36,330
more and more as I was maintaining SVT

00:03:32,880 --> 00:03:38,940
it's it's a casually functional build

00:03:36,330 --> 00:03:41,370
tool what do I mean by that is that I'm

00:03:38,940 --> 00:03:44,910
not going to really claim like purely

00:03:41,370 --> 00:03:47,790
functional build all right but it's

00:03:44,910 --> 00:03:49,470
actually like I sometimes joke that the

00:03:47,790 --> 00:03:50,880
SVT is one of the build tool that

00:03:49,470 --> 00:03:55,890
pretends that the side effect doesn't

00:03:50,880 --> 00:03:58,080
exist it's a lot of the core philosophy

00:03:55,890 --> 00:04:01,650
or constant you know the concept around

00:03:58,080 --> 00:04:03,930
SVT is based on the functional

00:04:01,650 --> 00:04:07,170
programming and there are several key

00:04:03,930 --> 00:04:08,910
aspects of that like the I think the use

00:04:07,170 --> 00:04:13,050
of the immutable data structures oh

00:04:08,910 --> 00:04:16,500
that's one of them and the as we'll get

00:04:13,050 --> 00:04:20,340
into it the its it really thinks about

00:04:16,500 --> 00:04:23,340
how and when the effects are triggered

00:04:20,340 --> 00:04:25,560
and how it's handled and it's you know

00:04:23,340 --> 00:04:26,220
there's a lot of thinking towards when

00:04:25,560 --> 00:04:28,440
and how and

00:04:26,220 --> 00:04:30,510
how you compose effects so that's

00:04:28,440 --> 00:04:33,360
basically what makes it more functional

00:04:30,510 --> 00:04:38,390
bill tool I think than the more

00:04:33,360 --> 00:04:42,090
traditional ones so you know traditional

00:04:38,390 --> 00:04:43,890
good start porting starting point for

00:04:42,090 --> 00:04:47,210
the functional programming I think it's

00:04:43,890 --> 00:04:50,760
a think about effect right because by

00:04:47,210 --> 00:04:52,800
capturing an effect as a data structure

00:04:50,760 --> 00:04:55,440
basically you're making the rest of the

00:04:52,800 --> 00:04:57,960
application more like a repeatable pure

00:04:55,440 --> 00:05:01,050
function essentially so there is

00:04:57,960 --> 00:05:04,920
actually a data structure inside of SVG

00:05:01,050 --> 00:05:09,840
equal state and what do we track in

00:05:04,920 --> 00:05:13,530
there is basically we track the build

00:05:09,840 --> 00:05:17,340
structure and it doesn't really track it

00:05:13,530 --> 00:05:21,210
but conceptually it also Maps into your

00:05:17,340 --> 00:05:23,970
disk so your source code your you know

00:05:21,210 --> 00:05:25,410
class files and jars and libraries you

00:05:23,970 --> 00:05:32,640
can think of them essentially as an

00:05:25,410 --> 00:05:37,580
effect right and there is a concept

00:05:32,640 --> 00:05:40,200
called the command inside of the SBT and

00:05:37,580 --> 00:05:43,440
as a first kind of like approximation

00:05:40,200 --> 00:05:46,620
you can think of command as the state

00:05:43,440 --> 00:05:49,740
transformation function right so you

00:05:46,620 --> 00:05:52,200
start off with some sort of state that

00:05:49,740 --> 00:05:54,030
has some file and then you do some sort

00:05:52,200 --> 00:05:59,820
of thing using command then you go to

00:05:54,030 --> 00:06:01,320
the next state right so that's kind of

00:05:59,820 --> 00:06:05,790
like a one important thing is the

00:06:01,320 --> 00:06:07,740
current or process sequentially is like

00:06:05,790 --> 00:06:11,090
a state monad you know like if you're

00:06:07,740 --> 00:06:14,850
familiar with that so basically it Maps

00:06:11,090 --> 00:06:17,070
procedural code and it's you have the

00:06:14,850 --> 00:06:18,930
state and then you go to another state

00:06:17,070 --> 00:06:21,900
as you process something using command

00:06:18,930 --> 00:06:24,330
and this is fairly low-level construct

00:06:21,900 --> 00:06:24,810
so if you're like a plug-in authors out

00:06:24,330 --> 00:06:28,320
there

00:06:24,810 --> 00:06:31,020
my suggestion actually is to avoid using

00:06:28,320 --> 00:06:33,660
command you're creating providing

00:06:31,020 --> 00:06:37,560
command but it's also important to know

00:06:33,660 --> 00:06:39,780
that the what aspect of SBT is handled

00:06:37,560 --> 00:06:42,060
by command and why it behaves answer

00:06:39,780 --> 00:06:43,340
ways so let's kind of see the examples

00:06:42,060 --> 00:06:46,200
of a command sorry

00:06:43,340 --> 00:06:49,950
although I helpful command I'll say is

00:06:46,200 --> 00:06:52,260
actually help so you know if you're kind

00:06:49,950 --> 00:06:54,420
of long familiar with SVT you know or

00:06:52,260 --> 00:06:56,130
kind of like get to learn more help is

00:06:54,420 --> 00:06:57,510
actually a pretty good command or you

00:06:56,130 --> 00:07:00,390
just type help and just kind of list

00:06:57,510 --> 00:07:03,930
bunch of commands in there tasks is

00:07:00,390 --> 00:07:05,640
another interesting command that this is

00:07:03,930 --> 00:07:07,770
not really doing anything was just

00:07:05,640 --> 00:07:09,810
listing a bunch of like tasks that's all

00:07:07,770 --> 00:07:13,500
you know located into your a build

00:07:09,810 --> 00:07:16,590
structure projects project hello

00:07:13,500 --> 00:07:20,040
basically these are also listing out the

00:07:16,590 --> 00:07:21,690
sub projects in your build set becomes a

00:07:20,040 --> 00:07:26,130
little more interesting right like a set

00:07:21,690 --> 00:07:30,330
is basically a command that changes your

00:07:26,130 --> 00:07:34,140
build by taking the setting expression

00:07:30,330 --> 00:07:35,880
the I'm not sure if everyone is familiar

00:07:34,140 --> 00:07:41,280
with the next one it's a semicolon

00:07:35,880 --> 00:07:44,669
command so command is composable using a

00:07:41,280 --> 00:07:50,669
multi command called semicolon this is a

00:07:44,669 --> 00:07:53,840
this particular syntax is new to SBT 1.3

00:07:50,669 --> 00:07:56,220
which is our CQ came out a few days ago

00:07:53,840 --> 00:07:58,500
before you needed like a semicolon in

00:07:56,220 --> 00:08:00,720
the front also you have to say semicolon

00:07:58,500 --> 00:08:02,520
command 1 and then semicolon command -

00:08:00,720 --> 00:08:05,070
or in the newer version it will be

00:08:02,520 --> 00:08:06,479
command 1 semicolon command - but

00:08:05,070 --> 00:08:09,080
basically you're able to compose

00:08:06,479 --> 00:08:12,330
sequentially or a bunch of commands and

00:08:09,080 --> 00:08:14,610
the other one that more people may be

00:08:12,330 --> 00:08:17,580
familiar with is a plus plus command

00:08:14,610 --> 00:08:21,030
that switches the current scholar

00:08:17,580 --> 00:08:24,540
version and plus plus scholars version

00:08:21,030 --> 00:08:26,520
Tang that basically forces a particular

00:08:24,540 --> 00:08:29,580
SCADA version even if it's not listed in

00:08:26,520 --> 00:08:33,330
the cross color all versions list then

00:08:29,580 --> 00:08:35,640
plus command basically you know issues

00:08:33,330 --> 00:08:38,070
the command against different versions

00:08:35,640 --> 00:08:40,110
of the scholar so again you know like

00:08:38,070 --> 00:08:42,750
these are basically details you'd have

00:08:40,110 --> 00:08:45,420
to memorize this but you can see how

00:08:42,750 --> 00:08:48,900
command basically is kind of composed of

00:08:45,420 --> 00:08:51,080
almost like string lis right so command

00:08:48,900 --> 00:08:53,279
is something that you see every day

00:08:51,080 --> 00:08:56,160
without really not

00:08:53,279 --> 00:08:59,069
issuing is the actual interactive shell

00:08:56,160 --> 00:09:02,670
itself is implemented as a command

00:08:59,069 --> 00:09:05,040
that's querying you to type something in

00:09:02,670 --> 00:09:08,459
there's just only one of the command and

00:09:05,040 --> 00:09:11,220
then once it it's done it is use the

00:09:08,459 --> 00:09:13,490
show command again so it's basically a

00:09:11,220 --> 00:09:16,800
command designed to ask you one question

00:09:13,490 --> 00:09:19,589
we get into the act command the Arctic

00:09:16,800 --> 00:09:22,680
command is the sort of like are lifting

00:09:19,589 --> 00:09:25,709
command there's more details we need to

00:09:22,680 --> 00:09:28,769
get into to like explain what this

00:09:25,709 --> 00:09:31,430
exactly is but when you type compile our

00:09:28,769 --> 00:09:35,579
act command is what's actually

00:09:31,430 --> 00:09:38,009
processing the other tasks so getting

00:09:35,579 --> 00:09:41,540
back to the state right so what state

00:09:38,009 --> 00:09:43,860
are these bunch of things changing um

00:09:41,540 --> 00:09:46,319
help in tasks like I said I don't think

00:09:43,860 --> 00:09:49,709
it's really changing your state but

00:09:46,319 --> 00:09:52,559
remember SVT's state concept tracks both

00:09:49,709 --> 00:09:55,350
the build structure as well as your desk

00:09:52,559 --> 00:09:57,720
right so when you type project hello

00:09:55,350 --> 00:09:59,879
it's actually changing the build

00:09:57,720 --> 00:10:01,709
structure a little bit because there is

00:09:59,879 --> 00:10:05,220
a one of the build structure is looking

00:10:01,709 --> 00:10:07,019
at your current project so that will

00:10:05,220 --> 00:10:09,839
change the interpretation of when you

00:10:07,019 --> 00:10:11,309
type compile a test or something like

00:10:09,839 --> 00:10:14,850
that right because you just switch to

00:10:11,309 --> 00:10:16,800
your current a sub-project set obviously

00:10:14,850 --> 00:10:19,439
that issues another setting so that

00:10:16,800 --> 00:10:21,180
changed the build structure and the

00:10:19,439 --> 00:10:23,250
other is basically kind of changes both

00:10:21,180 --> 00:10:25,709
or depending on what the command one is

00:10:23,250 --> 00:10:27,689
and after command like I said it affects

00:10:25,709 --> 00:10:32,250
more of your desk because that's where

00:10:27,689 --> 00:10:36,120
compilation happens so let's think about

00:10:32,250 --> 00:10:40,230
like why where do we create like stay

00:10:36,120 --> 00:10:44,160
and command right this kind of gets back

00:10:40,230 --> 00:10:48,649
to the the paper of the build system on

00:10:44,160 --> 00:10:52,559
the cart which is that if you think of

00:10:48,649 --> 00:10:56,730
the you know state to be like a flow of

00:10:52,559 --> 00:10:58,559
water like this the command basically

00:10:56,730 --> 00:11:01,500
kind of gives you like a predictable

00:10:58,559 --> 00:11:03,779
check point now like the SPT will come

00:11:01,500 --> 00:11:06,710
to the stop point right and it's kind of

00:11:03,779 --> 00:11:09,440
like this down and it's you the user

00:11:06,710 --> 00:11:12,500
you get to change which way the next

00:11:09,440 --> 00:11:14,600
flow of the water is going to be um so

00:11:12,500 --> 00:11:17,240
if you want to do like home piyo or test

00:11:14,600 --> 00:11:20,750
ah that's the sort of a stopping point

00:11:17,240 --> 00:11:24,770
where it gives you and this kind of like

00:11:20,750 --> 00:11:27,410
is designed partially because SPT is an

00:11:24,770 --> 00:11:30,170
interactive built tool like if we didn't

00:11:27,410 --> 00:11:32,029
have like interaction you don't really

00:11:30,170 --> 00:11:34,910
need to have state or are you just like

00:11:32,029 --> 00:11:38,390
do your thing but because we come back

00:11:34,910 --> 00:11:41,510
to the you know thus interactiveness or

00:11:38,390 --> 00:11:43,490
it cannot make sense to write this and

00:11:41,510 --> 00:11:45,740
like a state and like the transition of

00:11:43,490 --> 00:11:47,540
the state so to quite like a make a

00:11:45,740 --> 00:11:50,149
diagram about this it kind of looks like

00:11:47,540 --> 00:11:51,800
this right so we have a shell like I say

00:11:50,149 --> 00:11:55,339
it's designed to ask you exactly one

00:11:51,800 --> 00:11:57,140
question and you type some command and I

00:11:55,339 --> 00:12:01,130
think effects happened sort of on the

00:11:57,140 --> 00:12:03,320
side it almost doesn't matter if the jar

00:12:01,130 --> 00:12:05,660
file is created or not a lot of times

00:12:03,320 --> 00:12:07,970
because you know you're kind of mostly

00:12:05,660 --> 00:12:09,260
working with the like a error message or

00:12:07,970 --> 00:12:10,700
something like that the fact that it

00:12:09,260 --> 00:12:12,740
compiled it's probably good or not right

00:12:10,700 --> 00:12:14,570
and we're like are you running a pasty

00:12:12,740 --> 00:12:16,250
or you're not really looking at the jar

00:12:14,570 --> 00:12:19,070
of the test you're actually looking at

00:12:16,250 --> 00:12:21,650
the result of the test so the fact that

00:12:19,070 --> 00:12:24,140
I failed or succeeded those are more

00:12:21,650 --> 00:12:26,120
interesting things and why are they you

00:12:24,140 --> 00:12:28,970
know presented us today these are logs

00:12:26,120 --> 00:12:31,220
basically so you issue commands and what

00:12:28,970 --> 00:12:34,570
you get back is the logs and then the

00:12:31,220 --> 00:12:34,570
effect is kind of happens on the side

00:12:34,630 --> 00:12:43,459
next I want to talk about the UH this uh

00:12:39,010 --> 00:12:47,089
British movie called the about time so

00:12:43,459 --> 00:12:49,070
some people call it the time travel

00:12:47,089 --> 00:12:52,250
actually because it's the same I think

00:12:49,070 --> 00:12:53,870
director as Love Actually and the I like

00:12:52,250 --> 00:12:56,750
watching different like a movie that

00:12:53,870 --> 00:12:58,850
involves like a time traveling and yeah

00:12:56,750 --> 00:13:01,040
I think this one like you get into the

00:12:58,850 --> 00:13:02,930
closet and all the men in the family

00:13:01,040 --> 00:13:04,850
they are able to go back to the past

00:13:02,930 --> 00:13:09,380
point in their life and then they redo

00:13:04,850 --> 00:13:11,810
it and there's one paper that was

00:13:09,380 --> 00:13:13,970
written I think in like 1978 or

00:13:11,810 --> 00:13:16,190
something like that called er time

00:13:13,970 --> 00:13:18,980
clocks and the ordering of events in the

00:13:16,190 --> 00:13:20,420
distributed system and it's like I only

00:13:18,980 --> 00:13:21,889
really like one or two

00:13:20,420 --> 00:13:24,320
papers but this is like one really

00:13:21,889 --> 00:13:26,029
interesting paper I really recommend not

00:13:24,320 --> 00:13:27,740
just for like people who's interested in

00:13:26,029 --> 00:13:31,000
like functional programming but like

00:13:27,740 --> 00:13:33,829
distributive systems like haka and stuff

00:13:31,000 --> 00:13:35,630
so I'm not gonna get into the full paper

00:13:33,829 --> 00:13:38,060
that talks about like you know logical

00:13:35,630 --> 00:13:39,470
clock and all that cool stuff but see if

00:13:38,060 --> 00:13:41,360
your tongue traveling one of the things

00:13:39,470 --> 00:13:44,510
you have to worry about is like like

00:13:41,360 --> 00:13:46,459
event coordination but like just time

00:13:44,510 --> 00:13:49,370
alright like you don't really have a

00:13:46,459 --> 00:13:52,670
physical clock that works right if you

00:13:49,370 --> 00:13:54,260
think about like the speed of light and

00:13:52,670 --> 00:13:57,470
observer abilities and all that stuff

00:13:54,260 --> 00:13:59,660
you can't really rely on physical time

00:13:57,470 --> 00:14:01,820
so while you have to actually think

00:13:59,660 --> 00:14:04,430
about in the distributed systems or even

00:14:01,820 --> 00:14:08,620
like threads and stuff like that is to

00:14:04,430 --> 00:14:12,199
think about time without using clock and

00:14:08,620 --> 00:14:13,790
this is what like this a process the up

00:14:12,199 --> 00:14:16,940
arrow that's going upward that's

00:14:13,790 --> 00:14:20,269
actually time that's going up and you

00:14:16,940 --> 00:14:23,060
can think of process P Q and R it's like

00:14:20,269 --> 00:14:25,100
an event individual person or in our

00:14:23,060 --> 00:14:25,910
case like a thread or program or

00:14:25,100 --> 00:14:29,930
something like that

00:14:25,910 --> 00:14:33,560
right and the points like p1 p2 p3 these

00:14:29,930 --> 00:14:36,350
are core events so a distributed event

00:14:33,560 --> 00:14:38,720
so as long as the some event is

00:14:36,350 --> 00:14:41,959
happening within the single process you

00:14:38,720 --> 00:14:43,610
know what happened before is pretty easy

00:14:41,959 --> 00:14:45,769
to track because it's happening within

00:14:43,610 --> 00:14:46,550
the single you know like a clock or

00:14:45,769 --> 00:14:50,000
something like that

00:14:46,550 --> 00:14:55,190
right so this arrow this lamport's arrow

00:14:50,000 --> 00:14:59,630
is says it happened before so a happened

00:14:55,190 --> 00:15:02,660
before B right well what if there's like

00:14:59,630 --> 00:15:04,910
two processes right so what how do you

00:15:02,660 --> 00:15:06,230
define that is basically you're let's

00:15:04,910 --> 00:15:09,740
say you're able to somehow send the

00:15:06,230 --> 00:15:12,680
messaging right so the sending of the

00:15:09,740 --> 00:15:17,510
message is an event a reception of the

00:15:12,680 --> 00:15:20,660
message is also an event and the it says

00:15:17,510 --> 00:15:22,970
that when the message was received the

00:15:20,660 --> 00:15:25,399
it's assumed that you know the reception

00:15:22,970 --> 00:15:27,980
of the message or the sending of the

00:15:25,399 --> 00:15:30,650
message happens before B so similarly

00:15:27,980 --> 00:15:32,770
you can draw this exact same arrow here

00:15:30,650 --> 00:15:35,840
and this how distribute events work

00:15:32,770 --> 00:15:38,600
right to summarize in like more like us

00:15:35,840 --> 00:15:42,800
easier to write fashion it's like a ro B

00:15:38,600 --> 00:15:46,010
and a not our all B means it does not

00:15:42,800 --> 00:15:48,790
happen before B what's interesting is

00:15:46,010 --> 00:15:51,530
the the using this you can actually

00:15:48,790 --> 00:15:54,170
almost like a mathematically defying the

00:15:51,530 --> 00:15:57,020
definition of our concurrent means in

00:15:54,170 --> 00:15:59,200
this definition concurrent means that

00:15:57,020 --> 00:16:03,800
two distinct events a and B are

00:15:59,200 --> 00:16:08,050
concurrent if neither you know a happens

00:16:03,800 --> 00:16:09,890
before B nor B happens before I

00:16:08,050 --> 00:16:13,460
sometimes this is called like

00:16:09,890 --> 00:16:15,050
independent events but I think Ryan kind

00:16:13,460 --> 00:16:19,240
of like sounds cool all right because

00:16:15,050 --> 00:16:21,740
people think of it in terms of time so

00:16:19,240 --> 00:16:24,320
what this means is that in the

00:16:21,740 --> 00:16:27,730
distributed system sense concurrency is

00:16:24,320 --> 00:16:32,300
actually about causal effect right

00:16:27,730 --> 00:16:35,480
because if two events if there there is

00:16:32,300 --> 00:16:39,380
no consolidate between those two these

00:16:35,480 --> 00:16:42,320
are called concurrent so coming back to

00:16:39,380 --> 00:16:44,810
kind of functional programming how do

00:16:42,320 --> 00:16:49,190
you express this concept in functional

00:16:44,810 --> 00:16:50,960
programming is the applicative functor i

00:16:49,190 --> 00:16:52,700
don't want to get too much into this

00:16:50,960 --> 00:16:54,050
because applicative functor itself all

00:16:52,700 --> 00:16:56,510
we will be like a really great talk

00:16:54,050 --> 00:16:59,480
which there actually is all right which

00:16:56,510 --> 00:17:03,830
I linked call all the things you

00:16:59,480 --> 00:17:06,530
traverse by Luca last years or Scala

00:17:03,830 --> 00:17:10,940
days talks about this he called it the

00:17:06,530 --> 00:17:13,610
the monoidal functor so basically you

00:17:10,940 --> 00:17:15,470
think you can think of it as map and all

00:17:13,610 --> 00:17:17,780
right in this example at the code

00:17:15,470 --> 00:17:19,640
snippet I wrote you have like three dots

00:17:17,780 --> 00:17:22,430
are more like a sum of three and two

00:17:19,640 --> 00:17:24,770
dots on and you're adding those two

00:17:22,430 --> 00:17:25,190
things so that's basically all there is

00:17:24,770 --> 00:17:28,130
to it

00:17:25,190 --> 00:17:30,890
ah but if you think about what these two

00:17:28,130 --> 00:17:33,170
things are two and three they're in the

00:17:30,890 --> 00:17:35,480
box right and they don't really see each

00:17:33,170 --> 00:17:38,450
other they it doesn't matter if they

00:17:35,480 --> 00:17:40,730
happen before or you know they're

00:17:38,450 --> 00:17:42,960
basically expressed as something that's

00:17:40,730 --> 00:17:47,320
happening sort of concurrently

00:17:42,960 --> 00:17:51,640
and compare this against a for

00:17:47,320 --> 00:17:54,370
comprehension which is basically uh like

00:17:51,640 --> 00:17:57,990
I'm you know you know like a flat map

00:17:54,370 --> 00:17:59,800
basically right so if in using font map

00:17:57,990 --> 00:18:02,320
everything is sort of like seek

00:17:59,800 --> 00:18:04,960
sequential right it's like because

00:18:02,320 --> 00:18:07,570
there's a potential at which the value

00:18:04,960 --> 00:18:12,010
that was returned from the first might

00:18:07,570 --> 00:18:16,200
be used in the next so the semantics of

00:18:12,010 --> 00:18:18,640
the monad is basically similar to like a

00:18:16,200 --> 00:18:23,070
procedural syntax essentially and

00:18:18,640 --> 00:18:26,530
Haskell uses do and in Scala we use for

00:18:23,070 --> 00:18:29,020
right so if you can draw like the the

00:18:26,530 --> 00:18:32,020
land ports arrow the there is an arrow

00:18:29,020 --> 00:18:33,910
from like get lying and then to print

00:18:32,020 --> 00:18:34,450
land and then get lying again something

00:18:33,910 --> 00:18:35,620
like that

00:18:34,450 --> 00:18:40,240
so you can almost write it as a

00:18:35,620 --> 00:18:46,540
procedural code right compare this

00:18:40,240 --> 00:18:49,660
against the build SPT basically icarly

00:18:46,540 --> 00:18:53,080
world this out using the older or SPT

00:18:49,660 --> 00:18:56,140
0.12 style do you kindly emphasize the

00:18:53,080 --> 00:18:59,650
connection to the applicative functor so

00:18:56,140 --> 00:19:02,860
you have a top all of compiling compile

00:18:59,650 --> 00:19:06,100
and some like made-up function call I

00:19:02,860 --> 00:19:07,780
mean the task name bar right there was

00:19:06,100 --> 00:19:10,690
this thing called like tuples and then

00:19:07,780 --> 00:19:13,000
you can type map and these two things

00:19:10,690 --> 00:19:16,270
CMB would happen essentially

00:19:13,000 --> 00:19:18,730
concurrently because you know this it's

00:19:16,270 --> 00:19:20,530
happening in topple and then combining

00:19:18,730 --> 00:19:23,890
these two effects you do something else

00:19:20,530 --> 00:19:26,740
and then you put that into foo ah this

00:19:23,890 --> 00:19:28,360
was kind of like it makes sense once you

00:19:26,740 --> 00:19:30,850
understand this well it was kind of

00:19:28,360 --> 00:19:34,750
difficult as an introductory thing to

00:19:30,850 --> 00:19:36,280
kind of get into so SB t1 or swami's

00:19:34,750 --> 00:19:39,550
earther King introduced this thought

00:19:36,280 --> 00:19:41,500
value macro in a way it's good and bad

00:19:39,550 --> 00:19:44,140
because kind of like a high is these

00:19:41,500 --> 00:19:46,120
aspect under the rug so like you don't

00:19:44,140 --> 00:19:48,760
fully reach the understanding or what's

00:19:46,120 --> 00:19:53,010
kind of happening but that value is

00:19:48,760 --> 00:19:53,010
pretty much doing what's written above

00:19:53,809 --> 00:19:59,330
so that's basically an applicative

00:19:56,599 --> 00:20:01,460
competition that's happening and if you

00:19:59,330 --> 00:20:03,649
are draw like a this diagram a little

00:20:01,460 --> 00:20:06,859
better like having will be easier to

00:20:03,649 --> 00:20:11,570
understand so similarly the time goes

00:20:06,859 --> 00:20:14,840
upward right so you have compile slash

00:20:11,570 --> 00:20:19,879
compiled that's in a box bar also in a

00:20:14,840 --> 00:20:26,950
box and interestingly like these two

00:20:19,879 --> 00:20:30,679
tasks are is happening before too so

00:20:26,950 --> 00:20:34,039
there is sort of a lying in the sand of

00:20:30,679 --> 00:20:37,309
a time space almost so which means that

00:20:34,039 --> 00:20:40,070
by the time this opening curly brace of

00:20:37,309 --> 00:20:45,379
the foo is hit compilation is already

00:20:40,070 --> 00:20:47,690
done so in the build SPT DSL that value

00:20:45,379 --> 00:20:51,049
is not a function call it's basically

00:20:47,690 --> 00:20:56,690
the declaration that your task depends

00:20:51,049 --> 00:20:58,879
on the other tasks and this can be

00:20:56,690 --> 00:21:02,149
actually compose you know multiple

00:20:58,879 --> 00:21:04,249
layers basically and so if you have like

00:21:02,149 --> 00:21:06,229
a test test that quickly depends on

00:21:04,249 --> 00:21:08,109
compile which is typically how tests are

00:21:06,229 --> 00:21:10,879
right like it's internally depending

00:21:08,109 --> 00:21:13,839
transitory on your completion and then

00:21:10,879 --> 00:21:19,909
you also depend on some other food tasks

00:21:13,839 --> 00:21:21,289
these things basically compose so what's

00:21:19,909 --> 00:21:25,210
the point of this alright like why are

00:21:21,289 --> 00:21:31,070
we doing this like a dag like a graph

00:21:25,210 --> 00:21:34,249
and it's basically like this concept

00:21:31,070 --> 00:21:40,479
called minimality and that is when

00:21:34,249 --> 00:21:44,989
you're running a grand the task is

00:21:40,479 --> 00:21:48,139
executed at most once and for the input

00:21:44,989 --> 00:21:51,979
that was changed right the SPT doesn't

00:21:48,139 --> 00:21:56,389
fully do the second part for some of the

00:21:51,979 --> 00:21:59,059
other tasks but the if you think about

00:21:56,389 --> 00:22:01,279
what that means so like what's

00:21:59,059 --> 00:22:03,200
substituted instead of dot value let's

00:22:01,279 --> 00:22:04,700
say imagine this was like a function

00:22:03,200 --> 00:22:07,309
call or something like that right so

00:22:04,700 --> 00:22:10,970
there's a function name compile what

00:22:07,309 --> 00:22:12,909
happen is that the compilot will just

00:22:10,970 --> 00:22:16,309
run like three four five different times

00:22:12,909 --> 00:22:18,220
every time it needs to be like called

00:22:16,309 --> 00:22:21,649
right if it's just a pure function

00:22:18,220 --> 00:22:24,529
because like a Foose is calling compile

00:22:21,649 --> 00:22:26,929
test is calling compile you know like

00:22:24,529 --> 00:22:29,480
some other jarring and whatever is

00:22:26,929 --> 00:22:32,860
calling compile so in order to avoid

00:22:29,480 --> 00:22:34,940
that you want to basically calculate um

00:22:32,860 --> 00:22:37,129
sorta like in a way like that you can

00:22:34,940 --> 00:22:39,409
think of it as a caching mechanism that

00:22:37,129 --> 00:22:45,759
compiled during the course of a single

00:22:39,409 --> 00:22:45,759
rung of a command is called exactly once

00:22:45,820 --> 00:22:50,899
the second part right that kind of like

00:22:49,309 --> 00:22:52,490
makes it more interesting and that's why

00:22:50,899 --> 00:22:56,629
I was mentioning this whole time thing

00:22:52,490 --> 00:22:59,029
is if you can calculate that certain

00:22:56,629 --> 00:23:01,669
tasks are essentially independent or

00:22:59,029 --> 00:23:05,029
concurrent you can do parallel

00:23:01,669 --> 00:23:07,249
processing and SBT does this by default

00:23:05,029 --> 00:23:08,360
automatically just by looking at the

00:23:07,249 --> 00:23:12,590
graph of tasks

00:23:08,360 --> 00:23:17,090
it will concurrently or in parallel

00:23:12,590 --> 00:23:19,369
process your tasks and finally we can

00:23:17,090 --> 00:23:22,929
kind of talk about what a command is

00:23:19,369 --> 00:23:25,279
doing there's like I'm minor details

00:23:22,929 --> 00:23:28,669
called the aggregate thing or if you

00:23:25,279 --> 00:23:30,019
have done the the multiple project thing

00:23:28,669 --> 00:23:32,960
are you've seen this thing core

00:23:30,019 --> 00:23:36,230
aggregate what it's doing is that when

00:23:32,960 --> 00:23:40,429
you type compile it basically broadcasts

00:23:36,230 --> 00:23:42,649
the task processing to current process

00:23:40,429 --> 00:23:44,960
of project as well as the ones that's

00:23:42,649 --> 00:23:46,759
listed in the aggregate list so if

00:23:44,960 --> 00:23:50,509
you're in the root in this case or

00:23:46,759 --> 00:23:53,509
aggregate you tell compile core compile

00:23:50,509 --> 00:23:55,279
and the root compile basically and then

00:23:53,509 --> 00:23:58,730
it basically does all parallel

00:23:55,279 --> 00:24:01,129
processing of the particular task all

00:23:58,730 --> 00:24:06,200
that was typed in that's why I could

00:24:01,129 --> 00:24:08,119
command it's doing so how does this kind

00:24:06,200 --> 00:24:11,539
of relate back to like the state diagram

00:24:08,119 --> 00:24:14,240
I was writing right so this is kind of

00:24:11,539 --> 00:24:14,899
how conceptually I think of the what's

00:24:14,240 --> 00:24:17,419
happening

00:24:14,899 --> 00:24:20,700
might not be exactly like this but like

00:24:17,419 --> 00:24:23,340
so first there is a command go reload

00:24:20,700 --> 00:24:26,100
which actually is what happens when you

00:24:23,340 --> 00:24:28,529
boot up SBT itself and that basically

00:24:26,100 --> 00:24:31,769
sets bunch of settings right so setting

00:24:28,529 --> 00:24:35,279
itself is also in the cataract graph and

00:24:31,769 --> 00:24:37,559
then it goes goes to like s0 state like

00:24:35,279 --> 00:24:41,429
your initial state when s PT says hello

00:24:37,559 --> 00:24:43,409
okay it's ready to do some stuff that's

00:24:41,429 --> 00:24:45,720
when all the your settings are now

00:24:43,409 --> 00:24:49,139
initialized and evaluated using the tag

00:24:45,720 --> 00:24:51,690
on and then you type something in there

00:24:49,139 --> 00:24:54,960
then it will basically pull pass this

00:24:51,690 --> 00:24:56,999
bunch of tasks and then goes to s1 and

00:24:54,960 --> 00:24:58,799
then you type something else and you go

00:24:56,999 --> 00:25:01,340
to s2 right so this is probably

00:24:58,799 --> 00:25:06,149
distinguished a distinction between

00:25:01,340 --> 00:25:09,600
setting versus tasks basically is the

00:25:06,149 --> 00:25:12,269
the task of the one that would like the

00:25:09,600 --> 00:25:17,989
get fired up once you like issue the

00:25:12,269 --> 00:25:21,659
commands so if your plugin authors

00:25:17,989 --> 00:25:23,429
prefer tasks for the plug-in extensions

00:25:21,659 --> 00:25:28,619
because this is basically automatically

00:25:23,429 --> 00:25:31,139
composable and command is stateful and

00:25:28,619 --> 00:25:34,200
it's sequential but if you want

00:25:31,139 --> 00:25:35,789
something sequential Quran might

00:25:34,200 --> 00:25:37,559
actually be exactly what you've been

00:25:35,789 --> 00:25:39,570
looking for right like if you think

00:25:37,559 --> 00:25:41,519
about release procedure this is

00:25:39,570 --> 00:25:43,830
something you want something to be like

00:25:41,519 --> 00:25:45,899
really sequential like even if it takes

00:25:43,830 --> 00:25:48,090
a little bit of time you want to tag

00:25:45,899 --> 00:25:50,730
things you want to test things you want

00:25:48,090 --> 00:25:53,970
to release things right so I actually

00:25:50,730 --> 00:25:57,600
have like a few like custom command I

00:25:53,970 --> 00:26:00,629
use only for releasing things but for

00:25:57,600 --> 00:26:07,649
majority of the times I think task is a

00:26:00,629 --> 00:26:09,239
really good place to start second deal

00:26:07,649 --> 00:26:14,039
this is one of the things we've been

00:26:09,239 --> 00:26:16,019
working on a lot and the SPT 1.3 and

00:26:14,039 --> 00:26:18,299
it's like we've improved and the last

00:26:16,019 --> 00:26:21,389
might go you know recently is a tilde

00:26:18,299 --> 00:26:23,399
command so remember the whole like all

00:26:21,389 --> 00:26:25,169
the water thing that you have to hand

00:26:23,399 --> 00:26:26,909
crank to type to compile or something

00:26:25,169 --> 00:26:30,809
every time and let's say you just want

00:26:26,909 --> 00:26:33,210
to like just let SBT say test all the

00:26:30,809 --> 00:26:34,110
time I'll compile all the time todo is

00:26:33,210 --> 00:26:36,480
actually really

00:26:34,110 --> 00:26:39,210
a way to basically see kill dog test

00:26:36,480 --> 00:26:42,299
quick test test quick is basically a

00:26:39,210 --> 00:26:44,910
command a task that runs only the failed

00:26:42,299 --> 00:26:46,559
task and whatever that was changed

00:26:44,910 --> 00:26:50,340
so it's essentially incremental tester

00:26:46,559 --> 00:26:52,710
so tell the test quick if you want like

00:26:50,340 --> 00:26:57,690
an remember one thing it's pretty great

00:26:52,710 --> 00:27:01,200
way and SB t13 uses a native code to

00:26:57,690 --> 00:27:04,770
look into the file system on Mac Linux

00:27:01,200 --> 00:27:07,590
and Windows and detects any file changes

00:27:04,770 --> 00:27:10,169
and then shoots it off so combine this

00:27:07,590 --> 00:27:12,510
with the turbo mode it gives really

00:27:10,169 --> 00:27:13,190
great experience of just like running

00:27:12,510 --> 00:27:18,990
tests

00:27:13,190 --> 00:27:23,190
anytime you save the file so to kind of

00:27:18,990 --> 00:27:25,140
like dive a little bit into the state

00:27:23,190 --> 00:27:28,110
right now because I've mentioned that

00:27:25,140 --> 00:27:29,280
we're build structure a little bit maybe

00:27:28,110 --> 00:27:31,440
I was just going to give like a quick

00:27:29,280 --> 00:27:33,450
overview of what what's inside of the

00:27:31,440 --> 00:27:35,460
build structure I don't think there's

00:27:33,450 --> 00:27:38,400
anything super surprising well there's

00:27:35,460 --> 00:27:40,260
like a weird behaviors you know people

00:27:38,400 --> 00:27:43,650
may have kind of vague ideas so I'm just

00:27:40,260 --> 00:27:46,380
gonna clarify what's happening so no

00:27:43,650 --> 00:27:49,160
structure basically there is like build

00:27:46,380 --> 00:27:52,590
there's each build has associated URI

00:27:49,160 --> 00:27:54,510
URI typically is your just like your you

00:27:52,590 --> 00:27:56,700
know absolute path in your desk

00:27:54,510 --> 00:27:59,820
basically but it can actually

00:27:56,700 --> 00:28:02,510
potentially refer to other places

00:27:59,820 --> 00:28:04,860
in the desk to have like a multiple

00:28:02,510 --> 00:28:08,640
building which is called the source

00:28:04,860 --> 00:28:10,950
dependency I have a plugin named SVT

00:28:08,640 --> 00:28:14,130
sriracha that's able to switch between

00:28:10,950 --> 00:28:16,520
the source dependency and the binary

00:28:14,130 --> 00:28:20,460
dependency if you wanna check it out

00:28:16,520 --> 00:28:23,820
build mostly is like you can think of it

00:28:20,460 --> 00:28:29,040
as a set of sub projects and the key

00:28:23,820 --> 00:28:31,559
value store and sub project consists

00:28:29,040 --> 00:28:33,900
pretty much of like a scholar version

00:28:31,559 --> 00:28:35,520
which sometimes I call it like axis of

00:28:33,900 --> 00:28:37,830
evil' because it's the one that kind of

00:28:35,520 --> 00:28:43,290
mutates acts like an axis but it's

00:28:37,830 --> 00:28:45,830
actually not and configuration right

00:28:43,290 --> 00:28:48,420
what's configuration

00:28:45,830 --> 00:28:51,450
confusion is like what you see like it's

00:28:48,420 --> 00:28:53,250
compiled runtime test or you can make

00:28:51,450 --> 00:28:55,770
your custom ones but I generally

00:28:53,250 --> 00:28:58,890
recommend you don't really make too many

00:28:55,770 --> 00:29:00,480
of these and the what makes a

00:28:58,890 --> 00:29:03,240
configuration versus something that's

00:29:00,480 --> 00:29:05,670
not my test is that if it has its own

00:29:03,240 --> 00:29:09,270
source code and it has its own

00:29:05,670 --> 00:29:11,340
dependency graph it's likely it's a

00:29:09,270 --> 00:29:12,870
configuration right so test is a great

00:29:11,340 --> 00:29:15,420
example right because it has its own

00:29:12,870 --> 00:29:17,520
test as a source code and as test has

00:29:15,420 --> 00:29:19,830
its own different like the dependency

00:29:17,520 --> 00:29:22,260
graph well it kinda has this a kind like

00:29:19,830 --> 00:29:24,540
intrinsic relationship with uh you know

00:29:22,260 --> 00:29:27,150
in the compiled runtime is the one that

00:29:24,540 --> 00:29:29,550
you use like as a provided and stuff

00:29:27,150 --> 00:29:31,080
like that where some things are not

00:29:29,550 --> 00:29:32,670
available during the runtime but you

00:29:31,080 --> 00:29:34,380
want to use it only during the compile

00:29:32,670 --> 00:29:38,160
so there's a slight distinction between

00:29:34,380 --> 00:29:41,040
the run and compile but mostly you think

00:29:38,160 --> 00:29:43,410
about compiling test right so there is

00:29:41,040 --> 00:29:45,720
the extension like the extends

00:29:43,410 --> 00:29:48,990
relationship test extends runtime and

00:29:45,720 --> 00:29:54,210
runtime extends compile and then there's

00:29:48,990 --> 00:29:57,360
this kV store key value store basically

00:29:54,210 --> 00:29:59,430
you have name version organization like

00:29:57,360 --> 00:30:03,510
your use you know usual like the setting

00:29:59,430 --> 00:30:06,000
kind of stuff but we actually scoped

00:30:03,510 --> 00:30:09,150
these things and different like the

00:30:06,000 --> 00:30:13,470
dimensions so you can say this build

00:30:09,150 --> 00:30:16,050
version this build organization or foo

00:30:13,470 --> 00:30:17,940
compile compile or something like that

00:30:16,050 --> 00:30:20,820
like and these basically will have

00:30:17,940 --> 00:30:24,120
distinct values for each the different

00:30:20,820 --> 00:30:27,330
like a scope things so let's kind of

00:30:24,120 --> 00:30:28,950
dive into the disk oping because this is

00:30:27,330 --> 00:30:31,110
kind of like a more confusing part I

00:30:28,950 --> 00:30:35,220
think about SPT is that there is

00:30:31,110 --> 00:30:36,990
basically three scoping ons PT or the

00:30:35,220 --> 00:30:40,410
maximum you can have is like this like

00:30:36,990 --> 00:30:46,560
foo compile console Scala C options

00:30:40,410 --> 00:30:50,000
right and first is a sub-project there's

00:30:46,560 --> 00:30:53,400
pretty clear right you have sub-project

00:30:50,000 --> 00:30:56,580
as an axis and you don't have to specify

00:30:53,400 --> 00:30:59,190
it then it actually goes to the current

00:30:56,580 --> 00:31:01,980
project so typically when you start name

00:30:59,190 --> 00:31:06,019
that means it's current projects name so

00:31:01,980 --> 00:31:08,100
if you say this build this build is

00:31:06,019 --> 00:31:10,860
actually you can think of it as a

00:31:08,100 --> 00:31:13,950
special sub project you can scope things

00:31:10,860 --> 00:31:16,669
in so if you want to have a setting

00:31:13,950 --> 00:31:19,649
that's common to all your sub projects

00:31:16,669 --> 00:31:23,940
that's the one that I typically use like

00:31:19,649 --> 00:31:26,490
a version number or Scala version or in

00:31:23,940 --> 00:31:28,799
like any of these like some type of

00:31:26,490 --> 00:31:31,679
publishing settings you want to paly

00:31:28,799 --> 00:31:34,190
scope it in this build so that you don't

00:31:31,679 --> 00:31:37,200
have to like Reis Pesa fire inside each

00:31:34,190 --> 00:31:39,029
sub project sometimes it doesn't work

00:31:37,200 --> 00:31:41,159
because there is like overriding rules

00:31:39,029 --> 00:31:45,600
and all that stuff but this build is

00:31:41,159 --> 00:31:48,659
pretty good zero is one that you don't

00:31:45,600 --> 00:31:50,279
usually see as a build authors but like

00:31:48,659 --> 00:31:53,370
if your plugin authors you want to be

00:31:50,279 --> 00:31:55,950
kind of be aware of the existence it's

00:31:53,370 --> 00:31:58,049
basically the older like a name was

00:31:55,950 --> 00:32:00,750
global but global was kind of a bit

00:31:58,049 --> 00:32:02,840
confusing so I renamed it to zero global

00:32:00,750 --> 00:32:06,000
basically is zero slash zero slash zero

00:32:02,840 --> 00:32:08,789
so for a Singh single access it's zero

00:32:06,000 --> 00:32:11,309
configuration again we talked about like

00:32:08,789 --> 00:32:14,669
compile and test it's pretty clear in

00:32:11,309 --> 00:32:17,370
task is kind like a weird one where you

00:32:14,669 --> 00:32:18,179
can scope a setting to a specific task

00:32:17,370 --> 00:32:20,700
ah

00:32:18,179 --> 00:32:23,309
again this typically you see this more

00:32:20,700 --> 00:32:25,590
as like a plug-in settings but the

00:32:23,309 --> 00:32:27,330
console slash Scala see option is kind

00:32:25,590 --> 00:32:29,669
of like yeah it's a Scala see option

00:32:27,330 --> 00:32:30,740
that gets activated only during console

00:32:29,669 --> 00:32:33,720
task

00:32:30,740 --> 00:32:35,639
all right so yeah I already talked about

00:32:33,720 --> 00:32:38,399
the fact that keys are automatically

00:32:35,639 --> 00:32:41,220
scoped to current sub-project right the

00:32:38,399 --> 00:32:45,510
other stuff basically default to zero so

00:32:41,220 --> 00:32:47,610
let's say if you type name that's

00:32:45,510 --> 00:32:50,730
basically food let's say current project

00:32:47,610 --> 00:32:53,639
is foo so it's full slash name and the

00:32:50,730 --> 00:32:56,880
other you know axes basically default

00:32:53,639 --> 00:33:01,080
zero so it's food zero zero name so

00:32:56,880 --> 00:33:04,289
that's basically out so what's the point

00:33:01,080 --> 00:33:06,210
of key value store right so I mean apart

00:33:04,289 --> 00:33:08,190
from the fact that we use this for this

00:33:06,210 --> 00:33:10,980
whole applicative composition thing

00:33:08,190 --> 00:33:11,690
well the interesting thing about this

00:33:10,980 --> 00:33:14,259
fact

00:33:11,690 --> 00:33:18,259
we have this explicit kyun value is

00:33:14,259 --> 00:33:20,539
money SP TAS be able to self inspect

00:33:18,259 --> 00:33:24,049
what the build looks like like you can

00:33:20,539 --> 00:33:27,409
do that by typing inspected ah so if you

00:33:24,049 --> 00:33:29,809
type inspect test that will basically

00:33:27,409 --> 00:33:32,570
point out why SP key would eventually

00:33:29,809 --> 00:33:36,139
resolve that particular command into a

00:33:32,570 --> 00:33:38,330
specific key and what that task depends

00:33:36,139 --> 00:33:41,600
on and what's the delegation ordering

00:33:38,330 --> 00:33:43,549
and if you type inspect tree test it

00:33:41,600 --> 00:33:45,320
basically comes up with this like ASCII

00:33:43,549 --> 00:33:47,360
art is like one of the first thing I

00:33:45,320 --> 00:33:49,639
think I contributed to SPT was to

00:33:47,360 --> 00:33:53,929
display this thing it just repetitively

00:33:49,639 --> 00:33:56,840
calls the inspect and finds out what the

00:33:53,929 --> 00:33:59,029
transitive task our test would call and

00:33:56,840 --> 00:34:02,870
this kind of goes into you know many

00:33:59,029 --> 00:34:05,360
pages probably so another interesting

00:34:02,870 --> 00:34:07,490
aspect let's say compared to like Navin

00:34:05,360 --> 00:34:09,649
or something is that yeah

00:34:07,490 --> 00:34:12,950
because this is a key and value you can

00:34:09,649 --> 00:34:14,869
like reassign these or rewire these kind

00:34:12,950 --> 00:34:17,210
of gives you like almost like a super

00:34:14,869 --> 00:34:19,460
flexible extensibility extension points

00:34:17,210 --> 00:34:21,560
if you want to like customized tasks or

00:34:19,460 --> 00:34:24,109
customized completion or customize all

00:34:21,560 --> 00:34:26,929
sorts of things it's like it's right

00:34:24,109 --> 00:34:30,800
there for you to just switch it out

00:34:26,929 --> 00:34:34,129
basically and also the plugins

00:34:30,800 --> 00:34:36,319
themselves they also expose certain

00:34:34,129 --> 00:34:39,260
extension points right so there's like

00:34:36,319 --> 00:34:41,149
web jars and or like a play and all

00:34:39,260 --> 00:34:42,919
these different things these are a lot

00:34:41,149 --> 00:34:45,800
of times implement that partially as our

00:34:42,919 --> 00:34:48,109
SPT plugin you can then customize the

00:34:45,800 --> 00:34:49,369
behavior of done uh which is kind of

00:34:48,109 --> 00:34:51,829
more difficult if there's like a

00:34:49,369 --> 00:34:53,780
specific phases like and like a mavens

00:34:51,829 --> 00:34:55,579
case or you kind of have to like make

00:34:53,780 --> 00:34:57,500
sure you know what other plugins are

00:34:55,579 --> 00:35:00,589
doing before you or after you and stuff

00:34:57,500 --> 00:35:03,950
like that alright so the sitting

00:35:00,589 --> 00:35:07,460
expressions are pretty basic you know

00:35:03,950 --> 00:35:10,819
they have some sort of key an operator

00:35:07,460 --> 00:35:13,609
and the body the operators are we

00:35:10,819 --> 00:35:15,470
recommend are calling equals plus equals

00:35:13,609 --> 00:35:18,740
and plus plus equals there used to be

00:35:15,470 --> 00:35:22,130
more but typically we recommend these

00:35:18,740 --> 00:35:24,580
three and what's kind of like it's not

00:35:22,130 --> 00:35:26,920
super clear is

00:35:24,580 --> 00:35:30,580
this is essentially like a command right

00:35:26,920 --> 00:35:33,190
because we're changing the state of the

00:35:30,580 --> 00:35:35,860
build so in a way you can think of this

00:35:33,190 --> 00:35:37,630
as your issuing like a sec command so

00:35:35,860 --> 00:35:40,750
this is like you start off with a blank

00:35:37,630 --> 00:35:42,970
slate and individual setting expressions

00:35:40,750 --> 00:35:45,160
is actually mutating to stay a little

00:35:42,970 --> 00:35:47,200
bit I mean this happens like when we

00:35:45,160 --> 00:35:49,090
load so it's not explicitly doing that

00:35:47,200 --> 00:35:51,340
but if you can kind of mentally think of

00:35:49,090 --> 00:35:55,930
it as like these are like a you know

00:35:51,340 --> 00:35:57,640
changing of the internal build state so

00:35:55,930 --> 00:36:00,070
the sitting expression itself you know

00:35:57,640 --> 00:36:02,950
you can use a scoping like this so like

00:36:00,070 --> 00:36:05,890
builds this build slash organization and

00:36:02,950 --> 00:36:07,900
dot value is the one that basically

00:36:05,890 --> 00:36:11,620
looks it up and you know what you talked

00:36:07,900 --> 00:36:17,130
about this whole tag relationship the

00:36:11,620 --> 00:36:19,660
tricky part is next how do they delegate

00:36:17,130 --> 00:36:25,690
right so when you have something like

00:36:19,660 --> 00:36:28,900
core test console skocy options there is

00:36:25,690 --> 00:36:30,640
a specific rule that SPT uses is like I

00:36:28,900 --> 00:36:32,940
can't like I try to reverse engineer it

00:36:30,640 --> 00:36:37,180
by like looking at the source code and

00:36:32,940 --> 00:36:40,900
there is no documentation and SVT but

00:36:37,180 --> 00:36:44,770
the it's basically just five rules right

00:36:40,900 --> 00:36:48,640
um so first it's kind of trying really

00:36:44,770 --> 00:36:50,860
hard to look for this exact for ax Nino

00:36:48,640 --> 00:36:53,230
look of you know axes thing right core

00:36:50,860 --> 00:36:56,950
test consoles cause the options what if

00:36:53,230 --> 00:37:00,010
it's not there the first thing is going

00:36:56,950 --> 00:37:03,910
to try is it's gonna get rid of the in

00:37:00,010 --> 00:37:06,580
task and so the substitute that what

00:37:03,910 --> 00:37:09,220
zero like I use this dot arrow notation

00:37:06,580 --> 00:37:10,540
to say it's gonna substitute so it's

00:37:09,220 --> 00:37:12,850
core test

00:37:10,540 --> 00:37:16,750
Scalzi options is what's gonna look

00:37:12,850 --> 00:37:18,430
first and then then what next thing is

00:37:16,750 --> 00:37:22,900
kind of trying is that okay like I'm

00:37:18,430 --> 00:37:24,670
gonna put it back so it's gonna try it's

00:37:22,900 --> 00:37:27,090
not in test what if it's in the wrong

00:37:24,670 --> 00:37:30,610
time so it's gonna try core runtime

00:37:27,090 --> 00:37:33,400
consoles cause the options and compile

00:37:30,610 --> 00:37:35,280
and then zero and then eventually it

00:37:33,400 --> 00:37:38,880
will go up to the

00:37:35,280 --> 00:37:40,619
you know the sub-project axis and it's

00:37:38,880 --> 00:37:43,440
right if it's not in core is it in this

00:37:40,619 --> 00:37:47,700
build is it in zero so if Connick goes

00:37:43,440 --> 00:37:50,700
up these different like routes to almost

00:37:47,700 --> 00:37:53,400
like in inheritance basically to look

00:37:50,700 --> 00:37:57,270
for this particular setting value of

00:37:53,400 --> 00:38:01,470
Scala see options what is kind of weird

00:37:57,270 --> 00:38:04,349
is that it doesn't the transitive

00:38:01,470 --> 00:38:07,950
evaluation doesn't carry its original

00:38:04,349 --> 00:38:09,540
context and this is going like if I say

00:38:07,950 --> 00:38:10,890
this in English it almost doesn't make

00:38:09,540 --> 00:38:13,680
sense or I'm talking about right so

00:38:10,890 --> 00:38:18,060
let's let me kind of like explain this

00:38:13,680 --> 00:38:19,800
is in the object-oriented language there

00:38:18,060 --> 00:38:22,410
is this concept called a dynamic

00:38:19,800 --> 00:38:25,170
dispatch or something where the pointer

00:38:22,410 --> 00:38:27,359
of this would dispatch into the

00:38:25,170 --> 00:38:29,339
sub-projects method right so if you

00:38:27,359 --> 00:38:33,300
imagine something like this build slash

00:38:29,339 --> 00:38:35,760
version colony calls name right you

00:38:33,300 --> 00:38:38,400
expect the name to be the present

00:38:35,760 --> 00:38:41,579
stuff's name when the version is

00:38:38,400 --> 00:38:45,390
referred to inside of the lazy bail P

00:38:41,579 --> 00:38:47,579
projects or something tasks but that's

00:38:45,390 --> 00:38:51,210
not how it works in SBT basically that

00:38:47,579 --> 00:38:53,880
contacts the fact that this version is

00:38:51,210 --> 00:38:57,089
referred to from be project doesn't

00:38:53,880 --> 00:38:59,480
carry over so this build slash version

00:38:57,089 --> 00:39:01,020
would probably contain the root

00:38:59,480 --> 00:39:04,140
project's name

00:39:01,020 --> 00:39:07,230
therefore the something calling equals

00:39:04,140 --> 00:39:10,640
would end up showing up the root

00:39:07,230 --> 00:39:12,720
project's name instead of the this bees

00:39:10,640 --> 00:39:15,569
name so that's kind of like something

00:39:12,720 --> 00:39:20,280
you have to remember essentially is this

00:39:15,569 --> 00:39:22,619
makes the fact that the this build or

00:39:20,280 --> 00:39:26,190
global settings needs to be essentially

00:39:22,619 --> 00:39:30,050
closed on its own this bill can only

00:39:26,190 --> 00:39:33,030
refer to this build settings and the

00:39:30,050 --> 00:39:35,220
global can only refer to other global

00:39:33,030 --> 00:39:39,839
settings only so that's kind of like a

00:39:35,220 --> 00:39:42,270
lot of weird things the other kind of

00:39:39,839 --> 00:39:48,570
interesting things you can kind of take

00:39:42,270 --> 00:39:51,750
advantage of the scoping is the

00:39:48,570 --> 00:39:58,740
can you make your plugins if your plugin

00:39:51,750 --> 00:40:00,750
out there maximally flexible right so in

00:39:58,740 --> 00:40:03,900
order to make like a maximal like a

00:40:00,750 --> 00:40:07,650
flexible space as a plugin author what

00:40:03,900 --> 00:40:12,150
you should try to do is define your keys

00:40:07,650 --> 00:40:16,080
in the widest scope but reference the

00:40:12,150 --> 00:40:18,270
keys in the narrowest scope right so

00:40:16,080 --> 00:40:21,270
this basically allows the delegation

00:40:18,270 --> 00:40:23,520
rule to visit you know three four

00:40:21,270 --> 00:40:27,570
different places so here's like just

00:40:23,520 --> 00:40:32,100
kind of came up with a few skate as you

00:40:27,570 --> 00:40:33,960
know like a task and let's say there is

00:40:32,100 --> 00:40:37,380
something called logic you want to use

00:40:33,960 --> 00:40:40,830
like an algorithm right so you want to

00:40:37,380 --> 00:40:42,630
as a plug-in provide the obstacle logic

00:40:40,830 --> 00:40:47,160
at the global which is zero zero zero

00:40:42,630 --> 00:40:49,140
right and as a default value but when

00:40:47,160 --> 00:40:51,420
you actually provide the obstacle ask

00:40:49,140 --> 00:40:53,640
itself you scope it inside of the

00:40:51,420 --> 00:40:55,500
compile because this is a compiled of

00:40:53,640 --> 00:40:58,430
seek aid and this is automatically

00:40:55,500 --> 00:41:03,030
scoped again to the current sub project

00:40:58,430 --> 00:41:06,360
which then basically allows the your

00:41:03,030 --> 00:41:09,420
user or the build users the global this

00:41:06,360 --> 00:41:12,690
build project and the project compile

00:41:09,420 --> 00:41:16,290
but for different places to basically

00:41:12,690 --> 00:41:19,590
customize the observation logic so like

00:41:16,290 --> 00:41:21,900
you know if you know in typically you

00:41:19,590 --> 00:41:24,360
only care about one thing then you can

00:41:21,900 --> 00:41:25,800
just say this build slash off the gate

00:41:24,360 --> 00:41:28,800
logic and you change it to some other

00:41:25,800 --> 00:41:30,930
logic but if you have like five

00:41:28,800 --> 00:41:33,480
different sub projects and you only want

00:41:30,930 --> 00:41:35,730
one of them to be changed you can then

00:41:33,480 --> 00:41:41,490
the user can scope it and this won't

00:41:35,730 --> 00:41:47,970
work so there is kind of like I tried to

00:41:41,490 --> 00:41:50,090
make a four dimensional map so this is

00:41:47,970 --> 00:41:54,510
basically how the visual presentation of

00:41:50,090 --> 00:41:58,470
how this whole thing works so there is

00:41:54,510 --> 00:42:00,540
zero although in the center and the

00:41:58,470 --> 00:42:02,609
sub-project coming this way

00:42:00,540 --> 00:42:05,730
so let's go

00:42:02,609 --> 00:42:08,549
look at the sub-project first right so

00:42:05,730 --> 00:42:10,910
foo in this particular case like coming

00:42:08,549 --> 00:42:13,710
all the way in the bottom of the screen

00:42:10,910 --> 00:42:16,410
that's your sub project so it's like a

00:42:13,710 --> 00:42:19,589
few name or food base directory right

00:42:16,410 --> 00:42:21,960
and then when it can't find the stuff it

00:42:19,589 --> 00:42:25,349
goes up to this build and zero right and

00:42:21,960 --> 00:42:27,529
then there is configuration so anything

00:42:25,349 --> 00:42:31,140
that depends on the base directory

00:42:27,529 --> 00:42:33,059
basically kind of like is on the right

00:42:31,140 --> 00:42:36,299
hand side I put it on like tours alright

00:42:33,059 --> 00:42:39,059
so you have something like food /

00:42:36,299 --> 00:42:42,049
compile / of compile and then for the

00:42:39,059 --> 00:42:45,390
runtime compile and food touch compile

00:42:42,049 --> 00:42:49,739
and then eventually you have this like a

00:42:45,390 --> 00:42:51,720
hyper axis that's going in tasks so

00:42:49,739 --> 00:42:54,150
basically you can if you can remember

00:42:51,720 --> 00:42:57,509
the whole delegation rule you'll first

00:42:54,150 --> 00:42:59,940
try the foo compile scholar see options

00:42:57,509 --> 00:43:02,160
and then if you can't find that it was

00:42:59,940 --> 00:43:03,839
just kind of like try traversing this

00:43:02,160 --> 00:43:11,539
list kind of downward and stuff like

00:43:03,839 --> 00:43:15,509
that so Carla quickly to summarize the

00:43:11,539 --> 00:43:17,099
like it's not looking ahead to s pg-13 I

00:43:15,509 --> 00:43:20,989
mean it's not looking exactly I had

00:43:17,099 --> 00:43:24,569
ahead because it's now RC - is there is

00:43:20,989 --> 00:43:27,989
the so one of the features that we

00:43:24,569 --> 00:43:31,920
shipped is course EA our default is

00:43:27,989 --> 00:43:33,690
turned on it's great and there is this

00:43:31,920 --> 00:43:36,140
thing called super shell which displays

00:43:33,690 --> 00:43:39,059
are currently pretty all executing tasks

00:43:36,140 --> 00:43:41,489
so if you're doing Perl processing you

00:43:39,059 --> 00:43:43,769
know this SPT now tells you which two

00:43:41,489 --> 00:43:46,980
tasks that's all Aurel processing and

00:43:43,769 --> 00:43:50,069
then there's turbo mode that enables the

00:43:46,980 --> 00:43:53,220
layer class loader so previously we were

00:43:50,069 --> 00:43:55,950
only caching in the Scala standard

00:43:53,220 --> 00:43:58,619
library now we will cache that when the

00:43:55,950 --> 00:44:01,739
turbo mode is turned on the class loader

00:43:58,619 --> 00:44:04,650
for the the library dependency is also

00:44:01,739 --> 00:44:07,799
cached so I definitely encourage you to

00:44:04,650 --> 00:44:11,609
try the turbo mode this makes the test

00:44:07,799 --> 00:44:15,239
and ron tasks really fast to get up

00:44:11,609 --> 00:44:16,340
because it doesn't reload and JIT which

00:44:15,239 --> 00:44:19,400
takes like few sec

00:44:16,340 --> 00:44:24,380
stiva and longer also your test ones

00:44:19,400 --> 00:44:28,610
look really fast okay so this is pretty

00:44:24,380 --> 00:44:30,650
much what I have um thank you and the if

00:44:28,610 --> 00:44:32,570
you have any questions maybe I can take

00:44:30,650 --> 00:44:35,180
one question but like I think the lunch

00:44:32,570 --> 00:44:38,180
is also starting so if you have

00:44:35,180 --> 00:44:40,220
questions I'll take now well otherwise

00:44:38,180 --> 00:44:52,460
you can just come talk to me later

00:44:40,220 --> 00:44:54,680
oh yeah okay okay so I'm not sure if I

00:44:52,460 --> 00:44:56,750
understood correctly the relation

00:44:54,680 --> 00:44:59,960
relationship between settings and

00:44:56,750 --> 00:45:02,330
configurations so what does it actually

00:44:59,960 --> 00:45:04,460
mean for a configuration to extend to

00:45:02,330 --> 00:45:08,110
extend another configuration is the

00:45:04,460 --> 00:45:10,580
effect only visible in source

00:45:08,110 --> 00:45:15,470
directories and dependencies or is it

00:45:10,580 --> 00:45:17,750
also visible in settings so an extending

00:45:15,470 --> 00:45:19,880
configuration doesn't does the and

00:45:17,750 --> 00:45:22,970
extending conservation configuration

00:45:19,880 --> 00:45:27,550
inherit settings from an extended

00:45:22,970 --> 00:45:30,860
configuration no there is no automatic

00:45:27,550 --> 00:45:32,690
setting inheritance you still have to as

00:45:30,860 --> 00:45:35,240
a plug-in author if you make your own

00:45:32,690 --> 00:45:39,860
configuration you still have to redefine

00:45:35,240 --> 00:45:43,160
all the settings so the part that gets I

00:45:39,860 --> 00:45:44,990
think when you publish to like the palm

00:45:43,160 --> 00:45:47,990
or something maybe that part becomes

00:45:44,990 --> 00:45:50,320
useful to inherit something but from the

00:45:47,990 --> 00:45:53,150
point of view of basically traversal

00:45:50,320 --> 00:45:54,920
it's basically used to traverse if it

00:45:53,150 --> 00:45:57,440
doesn't exist in test it goes up to

00:45:54,920 --> 00:46:01,010
compile that's where it's mostly

00:45:57,440 --> 00:46:04,420
relevant and yeah the inheritance

00:46:01,010 --> 00:46:07,430
doesn't really mean like exactly I think

00:46:04,420 --> 00:46:09,500
yeah you still have to do a lot of work

00:46:07,430 --> 00:46:14,110
yourself if you provide your customer

00:46:09,500 --> 00:46:17,000
configuration ok so extending is about

00:46:14,110 --> 00:46:20,890
source directories and dependencies

00:46:17,000 --> 00:46:20,890
essentially right yeah okay think

00:46:22,329 --> 00:46:32,410
all right so I have a plug I make

00:46:28,539 --> 00:46:35,829
mixtapes so you go to my Twitter handle

00:46:32,410 --> 00:46:37,689
or my website I have a mixtape by make

00:46:35,829 --> 00:46:41,100
every three months so check this out

00:46:37,689 --> 00:46:46,510
yeah thank you

00:46:41,100 --> 00:46:46,510

YouTube URL: https://www.youtube.com/watch?v=-shamsTC7rQ


