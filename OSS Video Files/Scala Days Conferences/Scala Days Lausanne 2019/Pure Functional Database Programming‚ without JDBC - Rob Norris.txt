Title: Pure Functional Database Programmingâ€š without JDBC - Rob Norris
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/pure-functional-database-programming-without-jdbc
Captions: 
	00:00:06,680 --> 00:00:15,839
Wow it is bright miles warned me about

00:00:10,320 --> 00:00:18,109
this Wow cool thank you for coming I'm

00:00:15,839 --> 00:00:21,330
really excited to be here I think this

00:00:18,109 --> 00:00:23,400
Scala days gets better every year and

00:00:21,330 --> 00:00:25,619
the quality of the talks this time has

00:00:23,400 --> 00:00:27,990
just blown me away it's it's just a

00:00:25,619 --> 00:00:31,109
fantastic conference so I'm honored to

00:00:27,990 --> 00:00:39,960
be here and I hope I can tell you

00:00:31,109 --> 00:00:43,140
something interesting let's see what's

00:00:39,960 --> 00:00:45,930
going on there we go

00:00:43,140 --> 00:00:50,070
so this is a near infrared image of a

00:00:45,930 --> 00:00:51,149
nebula called g g g g g d 27 it was

00:00:50,070 --> 00:00:53,550
taken with an instrument called

00:00:51,149 --> 00:01:01,620
flamingos 2 at the gemini south

00:00:53,550 --> 00:01:03,809
telescope in Chile so my name is Rob I'm

00:01:01,620 --> 00:01:05,309
really easy to find online I'm T pole

00:01:03,809 --> 00:01:08,400
ket everywhere

00:01:05,309 --> 00:01:10,770
I am a type level member work on some of

00:01:08,400 --> 00:01:12,810
the type level projects and I am your

00:01:10,770 --> 00:01:16,290
community representative for the Scala

00:01:12,810 --> 00:01:21,090
Center along with Bill Venters so if you

00:01:16,290 --> 00:01:22,799
have questions or ideas about what a

00:01:21,090 --> 00:01:25,049
Scala Center is working on or should be

00:01:22,799 --> 00:01:31,049
working on please reach out and talk to

00:01:25,049 --> 00:01:34,439
me or or to Bill this is where I work

00:01:31,049 --> 00:01:36,000
this is the Gemini Observatory this was

00:01:34,439 --> 00:01:38,130
taken at night but the moon is up so

00:01:36,000 --> 00:01:39,750
it's kind of bright we have two eight

00:01:38,130 --> 00:01:42,509
and a half meter telescopes one is in

00:01:39,750 --> 00:01:45,270
Chile one is in Hawaii and they are

00:01:42,509 --> 00:01:48,390
amazing machines and my job is to write

00:01:45,270 --> 00:01:53,329
software that helps scientists use them

00:01:48,390 --> 00:01:53,329
to look up and and learn new things and

00:01:54,049 --> 00:02:00,479
we are hiring

00:01:55,770 --> 00:02:02,820
so if science programming and database

00:02:00,479 --> 00:02:04,110
program or not database burger if

00:02:02,820 --> 00:02:07,170
science programming and functional

00:02:04,110 --> 00:02:09,599
programming interests you let me know

00:02:07,170 --> 00:02:12,289
because I think it's really interesting

00:02:09,599 --> 00:02:12,289
work we do

00:02:12,430 --> 00:02:19,670
so let's talk about database programming

00:02:15,349 --> 00:02:21,170
on the JVM so I to motivate this talk

00:02:19,670 --> 00:02:28,129
I've got to put it in some context so

00:02:21,170 --> 00:02:32,540
here's a timeline with 2019 so cats 1.0

00:02:28,129 --> 00:02:36,310
came out a couple years ago 2017 Scala

00:02:32,540 --> 00:02:38,840
212 came out I should have added to 13

00:02:36,310 --> 00:02:41,690
came out of 2016

00:02:38,840 --> 00:02:44,090
Dubey which is a database library that I

00:02:41,690 --> 00:02:46,220
worked on that I work on that we're

00:02:44,090 --> 00:02:49,670
gonna talk about a little bit the first

00:02:46,220 --> 00:02:51,709
usable version came out in 2015 slick

00:02:49,670 --> 00:02:53,500
another great database library came out

00:02:51,709 --> 00:02:56,660
in 2013

00:02:53,500 --> 00:02:59,140
shapeless 1.0 came out in 2011 we're

00:02:56,660 --> 00:03:01,340
starting to get into deep history

00:02:59,140 --> 00:03:07,280
applicative functors were invented in

00:03:01,340 --> 00:03:10,989
2008 iPhone came out in 2007 the iPod

00:03:07,280 --> 00:03:16,750
came out in 2001 everybody remember that

00:03:10,989 --> 00:03:20,930
Google was founded in 1998 ok and JDBC

00:03:16,750 --> 00:03:23,470
came out in 1996 all right

00:03:20,930 --> 00:03:28,579
that's just one year after Java came out

00:03:23,470 --> 00:03:32,569
ok so my point here is that JDBC is old

00:03:28,579 --> 00:03:34,280
it's really old technology so it's got a

00:03:32,569 --> 00:03:36,889
bunch of issues so it's not it's

00:03:34,280 --> 00:03:39,889
blocking unpredictably you never know

00:03:36,889 --> 00:03:42,560
when it's going to block not very

00:03:39,889 --> 00:03:44,389
typesafe it's really easy to get class

00:03:42,560 --> 00:03:46,609
cast exception there are lots of integer

00:03:44,389 --> 00:03:49,370
flags and stuff that are easy to get

00:03:46,609 --> 00:03:53,709
mixed up it's it's not the way you would

00:03:49,370 --> 00:03:56,500
write a modern API lots of nulls

00:03:53,709 --> 00:03:58,970
exceptions

00:03:56,500 --> 00:04:01,430
lots of behavior depends on the

00:03:58,970 --> 00:04:03,130
underlying database so even though you

00:04:01,430 --> 00:04:05,500
get a common API for everything

00:04:03,130 --> 00:04:09,310
depending on which database you're using

00:04:05,500 --> 00:04:14,720
your program may behave very differently

00:04:09,310 --> 00:04:17,510
obviously not functional at all and it's

00:04:14,720 --> 00:04:20,269
not fun I mean it's just and that's

00:04:17,510 --> 00:04:22,039
really important to me I think it's

00:04:20,269 --> 00:04:23,890
important to enjoy the work we do and we

00:04:22,039 --> 00:04:26,020
deserve libraries that are fun to use

00:04:23,890 --> 00:04:29,229
and JDBC doesn't

00:04:26,020 --> 00:04:31,240
doesn't really do it for me so a few

00:04:29,229 --> 00:04:35,080
years ago I wrote a library called

00:04:31,240 --> 00:04:38,520
doobie that kind of tried to fix some of

00:04:35,080 --> 00:04:42,099
those problems and and it it's not bad

00:04:38,520 --> 00:04:44,949
so it's a pure functional JDBC library

00:04:42,099 --> 00:04:46,270
so there are no side effects it's built

00:04:44,949 --> 00:04:47,800
on the free monads so you can have

00:04:46,270 --> 00:04:50,259
custom interpreters which is kind of

00:04:47,800 --> 00:04:51,970
cool if you want to do testing and want

00:04:50,259 --> 00:04:55,629
to provoke things that are really hard

00:04:51,970 --> 00:04:58,240
to do in with a real database the

00:04:55,629 --> 00:05:00,759
operations map one to one with JDBC so

00:04:58,240 --> 00:05:05,349
if you understand JDBC you can make

00:05:00,759 --> 00:05:07,479
sense of a duty program and and the best

00:05:05,349 --> 00:05:09,310
thing is that all of these refactoring

00:05:07,479 --> 00:05:10,569
tricks that we get with functional

00:05:09,310 --> 00:05:12,400
programming which is kind of the whole

00:05:10,569 --> 00:05:14,319
point of doing functional programming

00:05:12,400 --> 00:05:16,659
you can do all this stuff now with your

00:05:14,319 --> 00:05:18,940
JDBC programs which you can't do you

00:05:16,659 --> 00:05:22,030
know in Java or whatever so so that so

00:05:18,940 --> 00:05:25,090
it's a big win but there also some

00:05:22,030 --> 00:05:28,449
issues still you are still using JDBC

00:05:25,090 --> 00:05:32,259
and JDBC is bad and there's only so much

00:05:28,449 --> 00:05:33,729
you can sweep under the rug Diagnostics

00:05:32,259 --> 00:05:36,639
are really bad when something goes wrong

00:05:33,729 --> 00:05:39,610
it's hard to know what's gone wrong

00:05:36,639 --> 00:05:42,729
that's partly the fault of JDBC partly

00:05:39,610 --> 00:05:46,509
the fault of Dubey I think Otto

00:05:42,729 --> 00:05:49,900
derivation of codex is probably bad I

00:05:46,509 --> 00:05:53,110
think it was a mistake you end up

00:05:49,900 --> 00:05:55,270
spending a lot of time convincing the

00:05:53,110 --> 00:05:58,270
derivation machinery to derive the thing

00:05:55,270 --> 00:06:01,300
you want so I think I could improve on

00:05:58,270 --> 00:06:03,759
that and you know it works but it's not

00:06:01,300 --> 00:06:07,090
that fun right it's it's better but it's

00:06:03,759 --> 00:06:08,289
still not a joy to use it's with JDBC

00:06:07,090 --> 00:06:10,569
the bar is really low and it's better

00:06:08,289 --> 00:06:13,779
than that but it's it's not what I want

00:06:10,569 --> 00:06:15,310
so last year I started thinking about

00:06:13,779 --> 00:06:18,699
how I would build one of these things

00:06:15,310 --> 00:06:22,659
just up from nothing the API that I want

00:06:18,699 --> 00:06:26,740
with the behavior that I want using new

00:06:22,659 --> 00:06:29,050
technologies so I started work on a new

00:06:26,740 --> 00:06:34,960
project called skunk and there's no logo

00:06:29,050 --> 00:06:36,490
yet and here are the big ideas first of

00:06:34,960 --> 00:06:38,199
all all I care about is Postgres that's

00:06:36,490 --> 00:06:39,360
the database I use that's what most

00:06:38,199 --> 00:06:41,250
people seem

00:06:39,360 --> 00:06:45,300
to use so that's all I'm worrying about

00:06:41,250 --> 00:06:47,280
is supporting Postgres there is no in

00:06:45,300 --> 00:06:49,409
direction through a driver it talks

00:06:47,280 --> 00:06:54,349
straight to the database over the

00:06:49,409 --> 00:06:59,120
network so you get very high fidelity

00:06:54,349 --> 00:07:01,229
with the semantics of Postgres

00:06:59,120 --> 00:07:02,669
completely non blocking so you don't

00:07:01,229 --> 00:07:07,830
have to worry about fed pools and stuff

00:07:02,669 --> 00:07:09,659
like that the api mirrors the way

00:07:07,830 --> 00:07:11,039
Postgres likes to think about things so

00:07:09,659 --> 00:07:12,900
you don't have this sort of least common

00:07:11,039 --> 00:07:16,800
denominator layer that everything gets

00:07:12,900 --> 00:07:19,259
squeezed through like you do with JDBC I

00:07:16,800 --> 00:07:20,129
put a lot of effort into error reporting

00:07:19,259 --> 00:07:22,080
and I'm going to show you some

00:07:20,129 --> 00:07:26,219
demonstrations of that right at the end

00:07:22,080 --> 00:07:28,650
and oh yeah and it's built with really

00:07:26,219 --> 00:07:30,360
good technology so just in the last like

00:07:28,650 --> 00:07:33,210
two years we've gotten to the point

00:07:30,360 --> 00:07:36,569
where we can build really just complete

00:07:33,210 --> 00:07:38,909
applications using full using pure

00:07:36,569 --> 00:07:42,599
functional style with type level

00:07:38,909 --> 00:07:45,089
libraries and really these libraries are

00:07:42,599 --> 00:07:46,680
doing all the heavy lifting this is just

00:07:45,089 --> 00:07:48,960
an application of these libraries all

00:07:46,680 --> 00:07:53,639
the hard stuff is kind of given to me

00:07:48,960 --> 00:07:55,430
for free by using these things so so

00:07:53,639 --> 00:07:59,370
that's what I want to talk about today

00:07:55,430 --> 00:08:00,659
our goals learn a little bit about how

00:07:59,370 --> 00:08:04,800
Postgres works I think it's kind of

00:08:00,659 --> 00:08:07,830
interesting see some API design tagless

00:08:04,800 --> 00:08:12,089
style with cats effect functional

00:08:07,830 --> 00:08:15,089
network programming demos and and be

00:08:12,089 --> 00:08:16,349
inspired to to look into this stuff and

00:08:15,089 --> 00:08:17,969
think about this kind of programming

00:08:16,349 --> 00:08:20,610
even if you're not in the market for a

00:08:17,969 --> 00:08:22,349
database library I hope there will be

00:08:20,610 --> 00:08:24,529
something here for you that you find

00:08:22,349 --> 00:08:24,529
interesting

00:08:27,379 --> 00:08:34,769
so the compositional nature of

00:08:31,650 --> 00:08:36,899
functional programming kind of tends

00:08:34,769 --> 00:08:38,370
toward bottom-up programming you take

00:08:36,899 --> 00:08:39,719
little programs and you compose them and

00:08:38,370 --> 00:08:42,839
make bigger programs and kind of build

00:08:39,719 --> 00:08:45,600
things up so we're going to start the

00:08:42,839 --> 00:08:47,040
talk doing some bottom-up work and then

00:08:45,600 --> 00:08:48,120
we'll come back you gotta have a

00:08:47,040 --> 00:08:50,160
destination you got to know where you're

00:08:48,120 --> 00:08:51,660
going so we're gonna we're gonna flip

00:08:50,160 --> 00:08:52,590
over and look and look at the high-level

00:08:51,660 --> 00:08:54,900
stuff and

00:08:52,590 --> 00:09:01,830
and see what that looks like in the

00:08:54,900 --> 00:09:02,910
second half of the talk right so the

00:09:01,830 --> 00:09:06,120
first part of the talk we're going to

00:09:02,910 --> 00:09:09,029
talk about talking to Postgres so here's

00:09:06,120 --> 00:09:11,160
the big picture clients and servers

00:09:09,029 --> 00:09:13,920
communicate over TCP so the socket

00:09:11,160 --> 00:09:16,410
programming we're doing and they

00:09:13,920 --> 00:09:19,710
communicate by sending these tagged

00:09:16,410 --> 00:09:22,830
lengths prefixed messages back and forth

00:09:19,710 --> 00:09:24,270
okay and the payload is interpreted in

00:09:22,830 --> 00:09:28,320
different ways depending on what that

00:09:24,270 --> 00:09:30,570
message type tag is so logically this is

00:09:28,320 --> 00:09:33,630
just an ADT there are 53 different

00:09:30,570 --> 00:09:35,279
messages 53 the different tags and

00:09:33,630 --> 00:09:38,040
depending on the tag the payload meats

00:09:35,279 --> 00:09:39,600
different things and that's it so

00:09:38,040 --> 00:09:42,900
everything you can do with Postgres can

00:09:39,600 --> 00:09:44,430
be done by exchanging those messages and

00:09:42,900 --> 00:09:46,740
it's documented

00:09:44,430 --> 00:09:48,270
it's so awesome so one of the reasons

00:09:46,740 --> 00:09:51,800
why Postgres is really good software as

00:09:48,270 --> 00:09:54,000
their doc is really good chapter 52

00:09:51,800 --> 00:09:55,290
specifies this there's no secret

00:09:54,000 --> 00:09:56,700
knowledge here there's no reverse

00:09:55,290 --> 00:10:01,260
engineering it's all very plainly

00:09:56,700 --> 00:10:02,730
spelled out which is fantastic all right

00:10:01,260 --> 00:10:05,460
so we need to do some pure functional

00:10:02,730 --> 00:10:07,530
socket programming and let's think about

00:10:05,460 --> 00:10:10,250
what a Scala interface for a socket

00:10:07,530 --> 00:10:13,140
might look like okay well here's one

00:10:10,250 --> 00:10:14,580
this is a tagless interface which is a

00:10:13,140 --> 00:10:16,470
style of programming that parameter

00:10:14,580 --> 00:10:18,960
eise's everything over the effect and

00:10:16,470 --> 00:10:21,990
which values are computed so that F is

00:10:18,960 --> 00:10:23,730
the effect type so it's probably going

00:10:21,990 --> 00:10:26,850
to be something like IO in the real

00:10:23,730 --> 00:10:29,430
world in a real you know instantiation

00:10:26,850 --> 00:10:32,310
of this trait but you can mock something

00:10:29,430 --> 00:10:33,780
up using you know state T or something

00:10:32,310 --> 00:10:38,730
like that if you wanted to simulate

00:10:33,780 --> 00:10:40,589
stuff or test or test things then we

00:10:38,730 --> 00:10:42,300
need two fundamental operations we need

00:10:40,589 --> 00:10:44,880
to read some number of bytes and we need

00:10:42,300 --> 00:10:47,250
to write some number of bytes and both

00:10:44,880 --> 00:10:49,800
of those operations can timeout in which

00:10:47,250 --> 00:10:54,060
case an error error will be raised in

00:10:49,800 --> 00:10:56,250
this in this F effect so it turns out

00:10:54,060 --> 00:10:59,100
there's already an implementation a lot

00:10:56,250 --> 00:11:02,430
like this that's provided by FS too so

00:10:59,100 --> 00:11:05,850
they have a socket and it looks a lot

00:11:02,430 --> 00:11:06,330
like what I was looking for it uses this

00:11:05,850 --> 00:11:08,190
thing called

00:11:06,330 --> 00:11:10,110
Chunk instead of a byte array a Chuck

00:11:08,190 --> 00:11:13,080
chunk it's just kind of it's like a it's

00:11:10,110 --> 00:11:14,520
like an immutable array and another

00:11:13,080 --> 00:11:15,780
difference is that when we read a chunk

00:11:14,520 --> 00:11:18,240
we get back none

00:11:15,780 --> 00:11:20,580
if the socket is terminated before we

00:11:18,240 --> 00:11:21,930
get that many bytes so it's not exactly

00:11:20,580 --> 00:11:24,090
what we want but it's really close so

00:11:21,930 --> 00:11:27,540
we'll start with this and let's look at

00:11:24,090 --> 00:11:31,080
how we construct one of these sockets so

00:11:27,540 --> 00:11:34,080
there's there's a is a factory method

00:11:31,080 --> 00:11:35,160
that takes an AI net socket address and

00:11:34,080 --> 00:11:36,870
a bunch of other things that have

00:11:35,160 --> 00:11:38,400
reasonable defaults and a bunch of

00:11:36,870 --> 00:11:39,900
constraints and if you do programming

00:11:38,400 --> 00:11:42,750
with ket's effect you'll know what about

00:11:39,900 --> 00:11:44,160
concurrent and context shift if you

00:11:42,750 --> 00:11:47,520
don't I'm going to come back to them in

00:11:44,160 --> 00:11:50,220
a few minutes okay like what but what is

00:11:47,520 --> 00:11:51,900
that that's kind of an annoyance we have

00:11:50,220 --> 00:11:53,670
to deal with we need to get an

00:11:51,900 --> 00:11:57,240
asynchronous channel group somehow and

00:11:53,670 --> 00:11:58,860
that's an N i/o thing that the FS 2

00:11:57,240 --> 00:12:01,470
needs in order to construct this

00:11:58,860 --> 00:12:03,780
non-blocking and i/o socket down and

00:12:01,470 --> 00:12:05,820
down in the guts so we've got to deal

00:12:03,780 --> 00:12:07,410
with that and they're improving that

00:12:05,820 --> 00:12:10,350
right now actually so this is a little

00:12:07,410 --> 00:12:13,290
bit out of date and then there's this

00:12:10,350 --> 00:12:15,000
thing so this factory method does not

00:12:13,290 --> 00:12:17,580
return a socket and it doesn't even

00:12:15,000 --> 00:12:23,580
return F of socket it returns a resource

00:12:17,580 --> 00:12:26,870
of F of socket so so what's that okay so

00:12:23,580 --> 00:12:33,360
resource is defined kind of like this

00:12:26,870 --> 00:12:35,670
it's close enough so it's a monad which

00:12:33,360 --> 00:12:39,330
is useful you can get - well let me back

00:12:35,670 --> 00:12:41,220
up so what a resource is it is a data

00:12:39,330 --> 00:12:44,460
type from Katz effect and it's for

00:12:41,220 --> 00:12:46,260
working with lifetime managed values

00:12:44,460 --> 00:12:50,670
okay that need to be cleaned up when

00:12:46,260 --> 00:12:52,110
you're done using them okay so it's a

00:12:50,670 --> 00:12:53,880
monad which means you can take resources

00:12:52,110 --> 00:12:55,350
and compose them together so you have if

00:12:53,880 --> 00:12:57,180
you have three resources you can flat

00:12:55,350 --> 00:12:58,590
map them together and you get a new big

00:12:57,180 --> 00:13:00,600
resource and when you're done with it

00:12:58,590 --> 00:13:01,860
all three components will get cleaned up

00:13:00,600 --> 00:13:04,980
when you're done so has nice

00:13:01,860 --> 00:13:08,310
compositional properties and this is the

00:13:04,980 --> 00:13:11,280
important bit right here when you use a

00:13:08,310 --> 00:13:13,320
resource it hands you this managed value

00:13:11,280 --> 00:13:15,660
and you can compute some value in F and

00:13:13,320 --> 00:13:18,860
what you get back from this call is an F

00:13:15,660 --> 00:13:18,860
okay and

00:13:18,870 --> 00:13:22,589
this lets you kind of get out of

00:13:20,400 --> 00:13:24,960
resource and back to your normal fact

00:13:22,589 --> 00:13:27,510
type and this usage has guaranteed

00:13:24,960 --> 00:13:30,300
cleanup so no matter what happens no

00:13:27,510 --> 00:13:31,560
matter what F does even if F never even

00:13:30,300 --> 00:13:35,130
if ever gets cancelled and never

00:13:31,560 --> 00:13:36,540
completes the the resource will be

00:13:35,130 --> 00:13:42,540
cleaned up for us so it's a really nice

00:13:36,540 --> 00:13:44,700
abstraction okay so this is a good

00:13:42,540 --> 00:13:46,500
application right now because we need

00:13:44,700 --> 00:13:48,240
this asynchronous channel group and and

00:13:46,500 --> 00:13:49,950
the way this thing works is you've got

00:13:48,240 --> 00:13:51,300
to construct this thing and it owns a

00:13:49,950 --> 00:13:52,650
thread pool and then when you're done

00:13:51,300 --> 00:13:53,730
with it you have to shut it down so

00:13:52,650 --> 00:13:55,050
that's a good application of the

00:13:53,730 --> 00:13:59,700
resource so let's see how we might

00:13:55,050 --> 00:14:01,680
construct one okay so a resource that

00:13:59,700 --> 00:14:04,980
yields an asynchronous channel group

00:14:01,680 --> 00:14:06,570
looks like this you have two parts first

00:14:04,980 --> 00:14:09,870
you have this little allocation program

00:14:06,570 --> 00:14:11,220
that computes the managed value and what

00:14:09,870 --> 00:14:14,700
we're doing is we're constructing it

00:14:11,220 --> 00:14:18,690
inside sync delay okay so let's let's

00:14:14,700 --> 00:14:19,980
look at what sync does sync is something

00:14:18,690 --> 00:14:21,690
from Katz effect it's kind of the

00:14:19,980 --> 00:14:23,970
interface with the site affecting part

00:14:21,690 --> 00:14:26,940
of the language so it takes a side

00:14:23,970 --> 00:14:30,029
effect as an argument and then what it

00:14:26,940 --> 00:14:31,950
returns is a value that will compute

00:14:30,029 --> 00:14:34,529
that side effect at runtime and that

00:14:31,950 --> 00:14:38,370
call itself is not a side effect so so

00:14:34,529 --> 00:14:40,290
our code is is still pure okay so we

00:14:38,370 --> 00:14:43,260
have that allocation that creates the

00:14:40,290 --> 00:14:45,390
channel group and then we have a free

00:14:43,260 --> 00:14:47,310
program that takes it and shuts it down

00:14:45,390 --> 00:14:50,670
again and delay because that's a side

00:14:47,310 --> 00:14:53,100
effect okay and then we can just say

00:14:50,670 --> 00:14:54,959
resource dot make with the allocation

00:14:53,100 --> 00:14:57,240
and the free and that gives us a

00:14:54,959 --> 00:15:00,180
resource that will yield a synchronous

00:14:57,240 --> 00:15:03,180
channel groups and now if we have one of

00:15:00,180 --> 00:15:05,100
those we can construct a socket so here

00:15:03,180 --> 00:15:08,940
we go we've got a method it takes a host

00:15:05,100 --> 00:15:10,470
and a string and it creates the

00:15:08,940 --> 00:15:13,140
asynchronous channel group and what flat

00:15:10,470 --> 00:15:16,080
maps that into the socket constructor

00:15:13,140 --> 00:15:18,630
that fs2 provides okay and the result is

00:15:16,080 --> 00:15:20,130
a resource that gives us a socket when

00:15:18,630 --> 00:15:21,330
we're done using it the socket will be

00:15:20,130 --> 00:15:24,720
closed and the channel group will be

00:15:21,330 --> 00:15:27,180
closed this doesn't compile because we

00:15:24,720 --> 00:15:29,010
don't have the right constraints so the

00:15:27,180 --> 00:15:32,810
compiler errors will tell us that we

00:15:29,010 --> 00:15:32,810
need concurrent and context

00:15:33,390 --> 00:15:38,770
okay and then when I write code in this

00:15:37,030 --> 00:15:40,660
style and tag list style this is what I

00:15:38,770 --> 00:15:42,940
do I write the code that I want and then

00:15:40,660 --> 00:15:45,160
I rely on the compiler errors to tell me

00:15:42,940 --> 00:15:48,220
which constraints I need so that I don't

00:15:45,160 --> 00:15:49,570
accidentally over constrain stuff so

00:15:48,220 --> 00:15:53,530
we're finally ready to write a program

00:15:49,570 --> 00:15:57,420
that actually uses a socket okay so

00:15:53,530 --> 00:16:00,040
here's a program that is in IO app ok

00:15:57,420 --> 00:16:05,080
let's talk for a minute about what i/o

00:16:00,040 --> 00:16:06,610
app is so it's a trait provided by Kats

00:16:05,080 --> 00:16:08,980
effect that gives you a pure functional

00:16:06,610 --> 00:16:11,620
entry point for your program so it just

00:16:08,980 --> 00:16:13,900
computes an i/o value and then IO app

00:16:11,620 --> 00:16:15,730
takes care of actually side effecting

00:16:13,900 --> 00:16:18,730
and running it for you so that the side

00:16:15,730 --> 00:16:20,530
effect is not part of your program it

00:16:18,730 --> 00:16:22,750
also gives you some type class instances

00:16:20,530 --> 00:16:24,300
that are useful it gives you a timer for

00:16:22,750 --> 00:16:28,030
i/o that lets you do non blocking

00:16:24,300 --> 00:16:29,580
non-blocking sleeping gives you a

00:16:28,030 --> 00:16:31,960
context shift that's what allows

00:16:29,580 --> 00:16:34,870
computations to shift between thread

00:16:31,960 --> 00:16:37,240
pools and because that's available you

00:16:34,870 --> 00:16:38,650
get a concurrent instance for i/o and

00:16:37,240 --> 00:16:44,080
that lets you run things in parallel

00:16:38,650 --> 00:16:46,540
let's you fork and join computations ok

00:16:44,080 --> 00:16:50,440
so what does this do

00:16:46,540 --> 00:16:51,820
we create a socket and then we use it

00:16:50,440 --> 00:16:53,050
and we're gonna hit Google because we

00:16:51,820 --> 00:16:55,600
don't have enough structure to talk to

00:16:53,050 --> 00:16:57,610
Postgres yet then we're just gonna

00:16:55,600 --> 00:17:00,550
arbitrary arbitrarily read back the

00:16:57,610 --> 00:17:01,930
first 256 bytes we get back and that

00:17:00,550 --> 00:17:04,510
gives us an option and we'll traverse

00:17:01,930 --> 00:17:06,130
the option to print out whatever we got

00:17:04,510 --> 00:17:10,330
and we'll just turn it into an ASCII

00:17:06,130 --> 00:17:12,370
string ok so this works but the way I

00:17:10,330 --> 00:17:14,590
like to write these programs is instead

00:17:12,370 --> 00:17:18,160
of having run do everything I write a

00:17:14,590 --> 00:17:20,950
run F program write a run F method that

00:17:18,160 --> 00:17:22,840
is parameterised on its effect ok and

00:17:20,950 --> 00:17:25,330
the nice in in the run method I

00:17:22,840 --> 00:17:27,640
instantiate run F to i/o okay and the

00:17:25,330 --> 00:17:29,830
reason I do that is because when I

00:17:27,640 --> 00:17:31,420
refactor things out of this main method

00:17:29,830 --> 00:17:32,470
into my larger program I don't end up

00:17:31,420 --> 00:17:34,960
with bits and pieces that are

00:17:32,470 --> 00:17:37,450
specialized to i/o I want as much as I I

00:17:34,960 --> 00:17:40,600
want as much of my code as possible to

00:17:37,450 --> 00:17:42,550
be parameterised on the effect the

00:17:40,600 --> 00:17:44,540
compiler tells us whether we need the

00:17:42,550 --> 00:17:50,120
concurrent and context shift

00:17:44,540 --> 00:17:50,120
okay so we can run this and it works

00:17:50,360 --> 00:17:56,070
okay so this is fine but we don't want

00:17:54,300 --> 00:17:57,870
to be dealing in chunks we want to be

00:17:56,070 --> 00:17:59,880
dealing in a binary data type that's

00:17:57,870 --> 00:18:02,250
easy to work with because we need to

00:17:59,880 --> 00:18:06,810
encode these Postgres messages okay so

00:18:02,250 --> 00:18:10,020
let's talk about bit vectors so here's

00:18:06,810 --> 00:18:12,750
our current socket interface and what we

00:18:10,020 --> 00:18:14,130
want is something like this okay so

00:18:12,750 --> 00:18:16,050
instead of dealing with chunks we're

00:18:14,130 --> 00:18:18,270
dealing with bit vectors because that's

00:18:16,050 --> 00:18:20,850
what s codec uses for encoding and

00:18:18,270 --> 00:18:22,020
decoding binary data and that's what

00:18:20,850 --> 00:18:25,680
we're going to be using so let's talk

00:18:22,020 --> 00:18:27,660
about bit vector bit vector acts like a

00:18:25,680 --> 00:18:30,090
sequence of boolean's okay but the data

00:18:27,660 --> 00:18:31,710
is all packed into bytes and it's easy

00:18:30,090 --> 00:18:35,670
to convert back and forth to two byte

00:18:31,710 --> 00:18:38,040
arrays a really cool feature is that

00:18:35,670 --> 00:18:39,930
this concatenation operation is constant

00:18:38,040 --> 00:18:41,700
time so if you're familiar with the

00:18:39,930 --> 00:18:44,880
chain data type from Katz it's a lot

00:18:41,700 --> 00:18:46,980
like that it's super super optimized for

00:18:44,880 --> 00:18:48,390
dealing with binary data so if that is

00:18:46,980 --> 00:18:52,620
what you're doing this is the data type

00:18:48,390 --> 00:18:55,320
you want to be using it's fantastic and

00:18:52,620 --> 00:18:56,670
also I've internalized those timeouts

00:18:55,320 --> 00:18:58,260
I'm just gonna say look when I create

00:18:56,670 --> 00:19:00,240
one of these things I'll specify my time

00:18:58,260 --> 00:19:02,100
I'd out so I don't have to do that

00:19:00,240 --> 00:19:05,400
everywhere okay and instead of returning

00:19:02,100 --> 00:19:07,800
option on read we're just going to deal

00:19:05,400 --> 00:19:10,920
with the end of the end of socket error

00:19:07,800 --> 00:19:13,740
the end of file as an error and it gives

00:19:10,920 --> 00:19:15,060
us a simpler interface so given a socket

00:19:13,740 --> 00:19:20,550
we should be able to make one of these

00:19:15,060 --> 00:19:22,350
things okay so here's our method we have

00:19:20,550 --> 00:19:24,090
a socket and a couple durations and what

00:19:22,350 --> 00:19:27,110
we want to get back is a bit vector

00:19:24,090 --> 00:19:30,360
socket okay so how can we implement this

00:19:27,110 --> 00:19:33,240
so for read what we're gonna do is we'll

00:19:30,360 --> 00:19:35,400
read the bytes and if we got a chunk

00:19:33,240 --> 00:19:37,560
we'll turn it into a bit vector and if

00:19:35,400 --> 00:19:39,840
we didn't get one we're going to gently

00:19:37,560 --> 00:19:42,120
raise an error in F we're not throwing

00:19:39,840 --> 00:19:45,150
it where we're handing it to F and F is

00:19:42,120 --> 00:19:47,460
going to continue in a normal normal

00:19:45,150 --> 00:19:49,530
functional execution it'll just have

00:19:47,460 --> 00:19:53,910
this error in its error Channel

00:19:49,530 --> 00:19:56,100
okay and then the compiler will tell us

00:19:53,910 --> 00:19:57,220
we need the Monad yeah we need Monat

00:19:56,100 --> 00:19:58,840
error

00:19:57,220 --> 00:20:01,510
because we are flat mapping and we're

00:19:58,840 --> 00:20:02,919
raising errors then the right method is

00:20:01,510 --> 00:20:04,539
easy it just takes the bit vector and

00:20:02,919 --> 00:20:07,570
turns it into a Chunkin and writes it

00:20:04,539 --> 00:20:10,210
out okay so now we can write a method

00:20:07,570 --> 00:20:11,919
that constructs this bit vector socket

00:20:10,210 --> 00:20:14,289
by constructing and wrapping a regular

00:20:11,919 --> 00:20:14,860
socket okay so we take the host port

00:20:14,289 --> 00:20:19,870
time-outs

00:20:14,860 --> 00:20:21,780
and we create a socket which is a

00:20:19,870 --> 00:20:24,700
resource

00:20:21,780 --> 00:20:26,500
yeah we create the resource and then we

00:20:24,700 --> 00:20:28,120
just use map to turn the socket into a

00:20:26,500 --> 00:20:29,710
bit vector socket so now we have the

00:20:28,120 --> 00:20:32,130
type we want when we're done with it all

00:20:29,710 --> 00:20:34,780
the underlying stuff will be cleaned up

00:20:32,130 --> 00:20:38,100
now the compiler tells us we need those

00:20:34,780 --> 00:20:41,409
constraints so here's our original

00:20:38,100 --> 00:20:43,380
program that uses a regular socket and

00:20:41,409 --> 00:20:45,610
here's one that uses a bit vector socket

00:20:43,380 --> 00:20:47,350
okay

00:20:45,610 --> 00:20:49,150
it doesn't look at that different except

00:20:47,350 --> 00:20:52,600
now we're using this thing called utf-8

00:20:49,150 --> 00:20:57,400
from s codec and that's a thing that

00:20:52,600 --> 00:20:59,350
knows how to encode strings and into bit

00:20:57,400 --> 00:21:01,120
vectors and decode strings from bit

00:20:59,350 --> 00:21:02,700
vectors and we'll come back to this in a

00:21:01,120 --> 00:21:07,270
little while

00:21:02,700 --> 00:21:09,130
any case we run this thing and and it

00:21:07,270 --> 00:21:10,450
works it's the same thing it looks the

00:21:09,130 --> 00:21:12,250
same but now we have a better API

00:21:10,450 --> 00:21:16,780
because we're talking in bit vectors and

00:21:12,250 --> 00:21:19,690
we can start encoding messages so let's

00:21:16,780 --> 00:21:22,299
talk about messages again they look like

00:21:19,690 --> 00:21:25,240
this there's a tag and a length prefixed

00:21:22,299 --> 00:21:26,830
payload so it turns out when you connect

00:21:25,240 --> 00:21:28,299
to Postgres you open a socket and the

00:21:26,830 --> 00:21:30,309
first thing you do is you send a startup

00:21:28,299 --> 00:21:33,730
message so this is how we're gonna

00:21:30,309 --> 00:21:35,830
represent it weird for now we're just

00:21:33,730 --> 00:21:38,289
gonna send the username in the database

00:21:35,830 --> 00:21:39,820
in our startup message and if you have

00:21:38,289 --> 00:21:41,559
security setup in a very relaxed way

00:21:39,820 --> 00:21:42,940
it'll say ok you're logged in and that's

00:21:41,559 --> 00:21:45,250
and that's all you need so that's all

00:21:42,940 --> 00:21:47,110
we're gonna do right now so now we need

00:21:45,250 --> 00:21:49,840
a way to encode this for the network and

00:21:47,110 --> 00:21:51,909
we're going to use an S codec encoder to

00:21:49,840 --> 00:21:54,400
do this so this is what encoder looks

00:21:51,909 --> 00:21:56,770
like it's a contravariant

00:21:54,400 --> 00:21:59,470
data type and it has a method that says

00:21:56,770 --> 00:22:01,929
given an a give me an attempt of bit

00:21:59,470 --> 00:22:04,870
vector and attempt is just either error

00:22:01,929 --> 00:22:07,900
or bit vector so this just gives you a

00:22:04,870 --> 00:22:10,660
way to fail on encoding

00:22:07,900 --> 00:22:13,540
so here's our startup message and here

00:22:10,660 --> 00:22:15,910
is how we can encode the payload okay

00:22:13,540 --> 00:22:18,130
this is the part that is specific to to

00:22:15,910 --> 00:22:19,780
the startup message so the spec says to

00:22:18,130 --> 00:22:24,790
do it this way so the first thing we're

00:22:19,780 --> 00:22:26,380
gonna do is encode a 32-bit integer with

00:22:24,790 --> 00:22:27,880
this magic number and that number just

00:22:26,380 --> 00:22:30,430
specifies the protocol version that

00:22:27,880 --> 00:22:33,790
we're speaking and then we're going to

00:22:30,430 --> 00:22:36,550
encode a series of key value pairs which

00:22:33,790 --> 00:22:39,490
are C there C strings there there

00:22:36,550 --> 00:22:40,809
null-terminated strings so the user and

00:22:39,490 --> 00:22:44,350
the database and then we end the whole

00:22:40,809 --> 00:22:47,340
thing with a null with a 0 okay and then

00:22:44,350 --> 00:22:49,870
each of these things that we're encoding

00:22:47,340 --> 00:22:52,929
returns a bit vector and we use this

00:22:49,870 --> 00:22:56,860
awesome constant time append to add them

00:22:52,929 --> 00:22:58,960
all together and we're done we have some

00:22:56,860 --> 00:23:00,580
commonality here in between the way

00:22:58,960 --> 00:23:02,730
we're treating user and database so we

00:23:00,580 --> 00:23:06,130
can make a Combinator to deal with that

00:23:02,730 --> 00:23:08,530
so this takes a key and it gives back an

00:23:06,130 --> 00:23:12,700
encoder for string that will encode the

00:23:08,530 --> 00:23:16,870
key and the string as as null terminated

00:23:12,700 --> 00:23:18,610
strings so here's our old encoder and we

00:23:16,870 --> 00:23:20,380
can create a new one that's a little

00:23:18,610 --> 00:23:24,059
shorter it's just an example of how you

00:23:20,380 --> 00:23:25,960
can refactor stuff and and and and

00:23:24,059 --> 00:23:29,890
factor stuff out really easily and

00:23:25,960 --> 00:23:31,600
functional code the startup message is a

00:23:29,890 --> 00:23:33,220
special case it doesn't actually have a

00:23:31,600 --> 00:23:36,309
tag so we don't need to worry about that

00:23:33,220 --> 00:23:37,870
but it does have a length prefix so we

00:23:36,309 --> 00:23:40,840
can write another Combinator to do that

00:23:37,870 --> 00:23:43,000
so this length prefix Combinator takes

00:23:40,840 --> 00:23:46,390
an encoder and it returns an equivalent

00:23:43,000 --> 00:23:47,920
encoder that prefixes the payload with

00:23:46,390 --> 00:23:50,260
the length so what are we going to do

00:23:47,920 --> 00:23:52,660
we're gonna run the original encoder and

00:23:50,260 --> 00:23:56,820
get a bit vector back then we're going

00:23:52,660 --> 00:23:59,230
to encode a 32-bit integer that is the

00:23:56,820 --> 00:24:01,720
the size of the payload divided by 8

00:23:59,230 --> 00:24:03,940
because the size of bits and then we add

00:24:01,720 --> 00:24:06,010
four because it's the length and the

00:24:03,940 --> 00:24:11,200
length of the entire message including

00:24:06,010 --> 00:24:12,910
the length of the message all right so

00:24:11,200 --> 00:24:14,920
our final encoder looks like this so

00:24:12,910 --> 00:24:18,429
it's just a length prefixed encoder for

00:24:14,920 --> 00:24:19,820
the payload so our previous method looks

00:24:18,429 --> 00:24:22,370
like this

00:24:19,820 --> 00:24:23,330
and we're speaking HTTP and now we're

00:24:22,370 --> 00:24:25,700
going to talk to

00:24:23,330 --> 00:24:27,919
Postgres okay so we're gonna connect to

00:24:25,700 --> 00:24:30,649
the Postgres port we're gonna use that

00:24:27,919 --> 00:24:31,940
socket okay so we're gonna create the

00:24:30,649 --> 00:24:33,860
startup message and we'll use the

00:24:31,940 --> 00:24:35,120
startup encoder to get a bit vector out

00:24:33,860 --> 00:24:37,669
of it we're going to write it to the

00:24:35,120 --> 00:24:39,770
socket and then do the same thing with

00:24:37,669 --> 00:24:44,600
the results we're just gonna read the

00:24:39,770 --> 00:24:47,179
beginning of the first 256 bytes and it

00:24:44,600 --> 00:24:49,130
works so we get something back right

00:24:47,179 --> 00:24:50,899
Postgres is answering and it's giving

00:24:49,130 --> 00:24:54,080
something giving us something that looks

00:24:50,899 --> 00:24:55,640
like you know it might be meaningful so

00:24:54,080 --> 00:24:59,840
what we need to do now is figure out how

00:24:55,640 --> 00:25:03,590
to decode those messages so there are 53

00:24:59,840 --> 00:25:05,360
messages altogether but a good way to

00:25:03,590 --> 00:25:07,940
start is just decode everything the same

00:25:05,360 --> 00:25:11,710
way so we'll decode every message like

00:25:07,940 --> 00:25:14,870
this just a tag which is a single byte

00:25:11,710 --> 00:25:17,360
but they end up being ASCII characters

00:25:14,870 --> 00:25:20,539
so we'll turn into a character and then

00:25:17,360 --> 00:25:22,370
the data just as a raw bit vector so how

00:25:20,539 --> 00:25:24,919
do we decode a bit vector into the

00:25:22,370 --> 00:25:28,190
datatype well use a decoder so it's a

00:25:24,919 --> 00:25:30,710
contravariant datatype also from s codec

00:25:28,190 --> 00:25:32,659
that's just the dual of encoder so it

00:25:30,710 --> 00:25:36,500
takes bits and tries to turn them into

00:25:32,659 --> 00:25:40,480
an a so how do we read the unknown

00:25:36,500 --> 00:25:43,370
message well here's how we do it so

00:25:40,480 --> 00:25:48,169
given a bit vector socket we read 5

00:25:43,370 --> 00:25:53,270
bytes okay and then what we're gonna do

00:25:48,169 --> 00:25:56,090
is we're gonna create a decoder by by

00:25:53,270 --> 00:25:59,149
composing these two things so a byte is

00:25:56,090 --> 00:26:03,350
a decoder that will decode a single byte

00:25:59,149 --> 00:26:04,760
and 32 will decode a 32-bit integer we

00:26:03,350 --> 00:26:07,880
can compose them together with this

00:26:04,760 --> 00:26:10,190
little twiddle thing which basically is

00:26:07,880 --> 00:26:15,260
a way to construct left-leaning nested

00:26:10,190 --> 00:26:16,640
pairs okay so what we get back is a the

00:26:15,260 --> 00:26:18,289
tag and the length and we can also

00:26:16,640 --> 00:26:21,110
destructor using the twiddle which is

00:26:18,289 --> 00:26:24,440
kind of nice and then what we're gonna

00:26:21,110 --> 00:26:26,390
do is we're gonna read length - 4 bytes

00:26:24,440 --> 00:26:28,789
back because we have to subtract the 4

00:26:26,390 --> 00:26:30,420
bytes that we've already read and then

00:26:28,789 --> 00:26:32,010
we're going to construct our unknown

00:26:30,420 --> 00:26:33,720
and let's see what this looks like and

00:26:32,010 --> 00:26:37,350
the compiler says we need flat map for

00:26:33,720 --> 00:26:39,540
that so we don't know how many messages

00:26:37,350 --> 00:26:40,770
were getting back after we send the

00:26:39,540 --> 00:26:43,230
startup message so we're just going to

00:26:40,770 --> 00:26:45,930
write a loop here that'll just read an

00:26:43,230 --> 00:26:47,910
unknown message and then print it out

00:26:45,930 --> 00:26:49,050
and then do the same thing forever so

00:26:47,910 --> 00:26:53,100
we'll just read forever and hit

00:26:49,050 --> 00:26:54,810
control-c de to stop our program so

00:26:53,100 --> 00:26:57,990
here's our program that we had before

00:26:54,810 --> 00:27:00,120
that reads 256 bytes and prints them out

00:26:57,990 --> 00:27:02,790
and our no 1 just calls this finished

00:27:00,120 --> 00:27:06,270
startup method that we wrote so if we

00:27:02,790 --> 00:27:09,810
run this ok now we're getting somewhere

00:27:06,270 --> 00:27:11,400
right we've got a bunch of messages we

00:27:09,810 --> 00:27:12,960
got something tagged with an R and a

00:27:11,400 --> 00:27:15,270
bunch of things tagged with s and then a

00:27:12,960 --> 00:27:19,380
K and then a Z so we're getting

00:27:15,270 --> 00:27:23,820
something back so let's step up another

00:27:19,380 --> 00:27:25,920
level so we know how to read and write

00:27:23,820 --> 00:27:28,080
bit vectors ok and we know how to encode

00:27:25,920 --> 00:27:31,020
and decode messages so really just a

00:27:28,080 --> 00:27:34,200
matter of writing out all the cases and

00:27:31,020 --> 00:27:36,930
we can make something like this ok a

00:27:34,200 --> 00:27:38,730
message socket and this is from skunk

00:27:36,930 --> 00:27:41,460
and this is where we really want to be

00:27:38,730 --> 00:27:43,680
because this this is a socket that

00:27:41,460 --> 00:27:45,210
speaks in terms of Postgres messages you

00:27:43,680 --> 00:27:46,650
have front you have back end messages

00:27:45,210 --> 00:27:47,940
that come from the database and front

00:27:46,650 --> 00:27:50,340
end messages that you send to the

00:27:47,940 --> 00:27:51,780
database ok I don't have time to go

00:27:50,340 --> 00:27:53,040
through this full implementation but I

00:27:51,780 --> 00:27:57,030
hope you can see that we have all the

00:27:53,040 --> 00:27:59,670
pieces we need to build this up so you

00:27:57,030 --> 00:28:02,700
can draw the rest of the owl in your

00:27:59,670 --> 00:28:04,950
head and let's talk about what really is

00:28:02,700 --> 00:28:08,160
happening when we do this startup

00:28:04,950 --> 00:28:09,930
exchange so we send a startup message to

00:28:08,160 --> 00:28:12,510
Postgres and then we're going to get

00:28:09,930 --> 00:28:13,980
back an authentication ok message and a

00:28:12,510 --> 00:28:16,380
whole bunch of these parameter status

00:28:13,980 --> 00:28:18,810
messages and these tell us things about

00:28:16,380 --> 00:28:20,640
the runtime state of the database and

00:28:18,810 --> 00:28:23,360
about the properties of our session so

00:28:20,640 --> 00:28:26,100
we get things like the time zone and the

00:28:23,360 --> 00:28:29,130
the style and which dates are formatted

00:28:26,100 --> 00:28:32,070
and that sort of thing then we get some

00:28:29,130 --> 00:28:33,960
backend key data this is used to cancel

00:28:32,070 --> 00:28:35,880
long-running operations you can connect

00:28:33,960 --> 00:28:37,470
on another socket and pass this secret

00:28:35,880 --> 00:28:38,120
information back and it will cancel what

00:28:37,470 --> 00:28:40,620
you're doing

00:28:38,120 --> 00:28:42,150
and then finally we get ready for query

00:28:40,620 --> 00:28:43,130
and that means ok we're all set we're

00:28:42,150 --> 00:28:44,840
done and

00:28:43,130 --> 00:28:46,520
and we're our connection is established

00:28:44,840 --> 00:28:52,430
and now we can start doing database

00:28:46,520 --> 00:28:57,320
stuff so here's our old Finnish startup

00:28:52,430 --> 00:28:58,910
routine and now we can do better so what

00:28:57,320 --> 00:29:00,740
we can do is now that if we have a

00:28:58,910 --> 00:29:02,510
message socket we can pattern match on

00:29:00,740 --> 00:29:07,850
the messages that we are getting back

00:29:02,510 --> 00:29:12,350
and we can do different things depending

00:29:07,850 --> 00:29:16,850
on which messages we get so what are we

00:29:12,350 --> 00:29:19,430
doing here we've got a loop what we're

00:29:16,850 --> 00:29:21,680
gonna do is build up a map of all those

00:29:19,430 --> 00:29:23,780
parameter all those database parameters

00:29:21,680 --> 00:29:26,360
that we get back so we will receive a

00:29:23,780 --> 00:29:27,320
message if it's ready for query then

00:29:26,360 --> 00:29:29,300
we're done we're just going to return

00:29:27,320 --> 00:29:31,160
the accumulated map if we get a

00:29:29,300 --> 00:29:33,200
parameter status message we will add it

00:29:31,160 --> 00:29:36,200
to the map and go back and recurse into

00:29:33,200 --> 00:29:38,180
another do another receive otherwise

00:29:36,200 --> 00:29:41,590
we'll just ignore the message and loop

00:29:38,180 --> 00:29:45,950
back and we'll start with an empty map

00:29:41,590 --> 00:29:47,870
so before this is our old program with

00:29:45,950 --> 00:29:51,790
the bit vector socket and here's the new

00:29:47,870 --> 00:29:54,740
one and this is this is this is real

00:29:51,790 --> 00:29:56,480
Skunk types so we make a bit vector

00:29:54,740 --> 00:29:58,760
socket from that we make a message

00:29:56,480 --> 00:30:02,840
socket we're gonna send the startup

00:29:58,760 --> 00:30:05,030
message directly and then we will call

00:30:02,840 --> 00:30:06,020
our finished startup routine which is

00:30:05,030 --> 00:30:07,670
going to return all those parameters

00:30:06,020 --> 00:30:11,600
that we read and then we'll traverse the

00:30:07,670 --> 00:30:14,480
list and print them out and when we run

00:30:11,600 --> 00:30:15,890
that I'm doing this with an instrumented

00:30:14,480 --> 00:30:17,270
version of the code that shows the

00:30:15,890 --> 00:30:19,040
messages going back and forth and

00:30:17,270 --> 00:30:22,280
there's the the result that we got back

00:30:19,040 --> 00:30:23,690
okay so we're we're very close to being

00:30:22,280 --> 00:30:27,200
able to do something useful let's let's

00:30:23,690 --> 00:30:29,120
try to run a query the query exchange

00:30:27,200 --> 00:30:31,370
for simple the simple query protocol

00:30:29,120 --> 00:30:33,830
looks like this you send a query message

00:30:31,370 --> 00:30:35,210
with a query in it you get back a row

00:30:33,830 --> 00:30:37,250
description that tells you information

00:30:35,210 --> 00:30:39,830
about the columns and their types and

00:30:37,250 --> 00:30:41,960
their names you get a whole bunch of row

00:30:39,830 --> 00:30:45,320
data back and it's just each row is a

00:30:41,960 --> 00:30:46,340
list of nullable strings you get

00:30:45,320 --> 00:30:48,650
something that says there are no more

00:30:46,340 --> 00:30:50,240
rows back and then you get ready for

00:30:48,650 --> 00:30:52,730
query again and we're ready to do the

00:30:50,240 --> 00:30:58,710
next thing so let's talk about how we

00:30:52,730 --> 00:31:01,480
can do that so given a message socket

00:30:58,710 --> 00:31:05,019
let's build up let's let's make a a

00:31:01,480 --> 00:31:07,149
useful Combinator here so this expect F

00:31:05,019 --> 00:31:08,769
Combinator is kind of like flat map what

00:31:07,149 --> 00:31:10,659
it does is it takes a partial function

00:31:08,769 --> 00:31:12,789
instead of instead of a regular function

00:31:10,659 --> 00:31:15,159
and we'll say look we're gonna receive

00:31:12,789 --> 00:31:17,049
this thing we're gonna receive a message

00:31:15,159 --> 00:31:18,429
and if we have a handler for it will run

00:31:17,049 --> 00:31:20,649
the handler otherwise we'll raise an

00:31:18,429 --> 00:31:22,179
error in F and that way we can be a

00:31:20,649 --> 00:31:24,940
little bit more optimistic about the way

00:31:22,179 --> 00:31:29,830
we're dealing with messages we can make

00:31:24,940 --> 00:31:31,450
another one that is the kind that's

00:31:29,830 --> 00:31:32,799
similar that's similar to map it's the

00:31:31,450 --> 00:31:37,389
equivalent to map and we could define it

00:31:32,799 --> 00:31:38,620
in terms of expect F okay so when we run

00:31:37,389 --> 00:31:41,409
the query we're going to get a bunch of

00:31:38,620 --> 00:31:44,470
rows bunch of row data is back so here

00:31:41,409 --> 00:31:46,990
we have a unroll method that's going to

00:31:44,470 --> 00:31:49,120
accumulate all those rows back okay and

00:31:46,990 --> 00:31:52,090
it's similar to what we had before will

00:31:49,120 --> 00:31:54,909
call expect F instead of flat map and if

00:31:52,090 --> 00:31:58,029
we have a row data we will recurse and

00:31:54,909 --> 00:31:59,350
adding the row data to our list if we

00:31:58,029 --> 00:32:01,000
have command complete that means there

00:31:59,350 --> 00:32:02,769
are no more rows and we can reverse the

00:32:01,000 --> 00:32:05,370
list and return it so it's very similar

00:32:02,769 --> 00:32:05,370
to what we did before

00:32:05,519 --> 00:32:11,919
okay and now here is our final sort of

00:32:09,279 --> 00:32:13,779
sub program for processing the results

00:32:11,919 --> 00:32:15,370
so we send the query and then we get

00:32:13,779 --> 00:32:19,389
back a row description which will ignore

00:32:15,370 --> 00:32:21,820
will unroll the row data and then we

00:32:19,389 --> 00:32:23,289
will assume we will expect to get a

00:32:21,820 --> 00:32:29,049
ready for query message and then

00:32:23,289 --> 00:32:30,669
assuming we do will yield the rows so

00:32:29,049 --> 00:32:34,539
here's the message here's the program we

00:32:30,669 --> 00:32:37,450
had before but now in after we do the

00:32:34,539 --> 00:32:39,070
finish startup instead of printing that

00:32:37,450 --> 00:32:42,010
stuff out what we're gonna do is run a

00:32:39,070 --> 00:32:46,000
query so we'll send a query message with

00:32:42,010 --> 00:32:47,529
a simple query to our database and then

00:32:46,000 --> 00:32:52,899
we'll call process results and print the

00:32:47,529 --> 00:32:56,500
results out and when we run this a bunch

00:32:52,899 --> 00:32:59,230
of messages go by and we yeah these are

00:32:56,500 --> 00:33:00,549
the it's all the stuff that's gone past

00:32:59,230 --> 00:33:06,159
and here's the data that we've collected

00:33:00,549 --> 00:33:08,019
okay so we have gone from zero like

00:33:06,159 --> 00:33:10,060
literally nothing we've gone from zero

00:33:08,019 --> 00:33:13,930
to being able to run a query against

00:33:10,060 --> 00:33:15,160
Postgres with no JDBC driver okay and

00:33:13,930 --> 00:33:17,530
and it hasn't been a whole lot of

00:33:15,160 --> 00:33:20,050
trouble to do this so I hope you can see

00:33:17,530 --> 00:33:23,290
how we can we can sort of take this this

00:33:20,050 --> 00:33:24,760
pretty simple basis and and and and and

00:33:23,290 --> 00:33:28,420
built up something though there's

00:33:24,760 --> 00:33:29,890
something that's that's useful this

00:33:28,420 --> 00:33:34,150
ended up being way easier than I

00:33:29,890 --> 00:33:35,800
expected it to be so let me talk about

00:33:34,150 --> 00:33:39,370
the kind of the whole stack of stuff

00:33:35,800 --> 00:33:41,380
that we've got so at the very bottom

00:33:39,370 --> 00:33:44,560
we've got socket and that abstracts away

00:33:41,380 --> 00:33:46,060
the the TCP stuff and fs2 provides that

00:33:44,560 --> 00:33:48,310
and then we have the bit vector socket

00:33:46,060 --> 00:33:51,760
that we created that abstracts away the

00:33:48,310 --> 00:33:55,360
byte arrays message socket abstracts

00:33:51,760 --> 00:33:57,180
away the bit vectors I'm not going to

00:33:55,360 --> 00:33:59,710
show you this one

00:33:57,180 --> 00:34:01,390
buffered message socket is interesting

00:33:59,710 --> 00:34:03,520
though it deals with asynchronous

00:34:01,390 --> 00:34:06,970
messages it turns out Postgres can send

00:34:03,520 --> 00:34:08,670
you messages that that are not in

00:34:06,970 --> 00:34:11,110
response to anything that you've done

00:34:08,670 --> 00:34:12,280
and they tell you interesting things and

00:34:11,110 --> 00:34:16,120
I'm going to show you an example of

00:34:12,280 --> 00:34:19,900
using that the Katz effect concurrent

00:34:16,120 --> 00:34:21,490
stuff is really important here on top of

00:34:19,900 --> 00:34:23,770
that we've got a protocol layer and what

00:34:21,490 --> 00:34:25,360
that does is abstracts out all these

00:34:23,770 --> 00:34:29,080
message exchanges and turns them into

00:34:25,360 --> 00:34:31,090
atomic operations because while you're

00:34:29,080 --> 00:34:33,550
doing the simple query you can't be

00:34:31,090 --> 00:34:35,740
doing anything else so that's kind of

00:34:33,550 --> 00:34:37,540
one atomic action and then at the very

00:34:35,740 --> 00:34:40,050
top there's this session object which is

00:34:37,540 --> 00:34:42,640
the the high level API that people use

00:34:40,050 --> 00:34:45,280
so this is as much as I'm going to talk

00:34:42,640 --> 00:34:47,170
about the low level implementation and

00:34:45,280 --> 00:34:50,400
because that was a hundred slides I'm

00:34:47,170 --> 00:34:50,400
going to show you another pretty picture

00:34:52,710 --> 00:34:57,760
this is another near-infrared image is

00:34:56,440 --> 00:35:01,780
taken with an instrument called gems

00:34:57,760 --> 00:35:05,170
with GSA oh I adaptive optics this is a

00:35:01,780 --> 00:35:08,040
star formation star formation field in

00:35:05,170 --> 00:35:10,540
the Large Magellanic Cloud which is a

00:35:08,040 --> 00:35:14,530
little satellite galaxy of the Milky Way

00:35:10,540 --> 00:35:19,230
it's about 153 158 thousand light-years

00:35:14,530 --> 00:35:19,230
from here so it's basically next

00:35:19,430 --> 00:35:26,670
all right so I want to talk about the

00:35:22,530 --> 00:35:28,170
end user API now because this is really

00:35:26,670 --> 00:35:33,059
bad economics I'm just going to show you

00:35:28,170 --> 00:35:47,880
some some demos so I need to do some

00:35:33,059 --> 00:35:51,240
things with big enough okay so here is a

00:35:47,880 --> 00:35:53,250
minimal skunk program it connects to the

00:35:51,240 --> 00:35:56,579
database and gets the current date and

00:35:53,250 --> 00:35:58,190
prints it out okay so let's look at the

00:35:56,579 --> 00:36:01,319
different pieces this is an i/o app

00:35:58,190 --> 00:36:02,609
we've talked about i/o app the first

00:36:01,319 --> 00:36:04,890
thing we're going to do is that we're

00:36:02,609 --> 00:36:07,530
gonna construct a resource that will

00:36:04,890 --> 00:36:09,030
yield sessions so we just give it the

00:36:07,530 --> 00:36:11,849
host in the user in the database and

00:36:09,030 --> 00:36:14,579
that's all we need so here's our main

00:36:11,849 --> 00:36:16,559
method what we're gonna do is take that

00:36:14,579 --> 00:36:19,950
session and we'll use it so this s thing

00:36:16,559 --> 00:36:23,190
here's a session and then let's do this

00:36:19,950 --> 00:36:26,069
one inside out so start off come on

00:36:23,190 --> 00:36:29,160
metals so we have a sequel statement

00:36:26,069 --> 00:36:31,710
that is just select the current date we

00:36:29,160 --> 00:36:34,170
are saying this is a query and that it's

00:36:31,710 --> 00:36:36,690
Postgres type the row type that we're

00:36:34,170 --> 00:36:39,839
getting back is a date okay so this is a

00:36:36,690 --> 00:36:42,240
Postgres date and if we look at it is a

00:36:39,839 --> 00:36:44,010
codec for a local date that means it

00:36:42,240 --> 00:36:46,250
will be decoded into the Scala type

00:36:44,010 --> 00:36:48,809
local date so if you've used Dubey

00:36:46,250 --> 00:36:51,480
you'll remember that if you say doc

00:36:48,809 --> 00:36:53,190
query you pass it a type as an argument

00:36:51,480 --> 00:36:55,859
and it looks up the decoder based on the

00:36:53,190 --> 00:36:57,869
type and it's all type driven I've

00:36:55,859 --> 00:37:03,270
decided I don't like that pattern so in

00:36:57,869 --> 00:37:05,730
in Skunk you just you pass decoders that

00:37:03,270 --> 00:37:08,670
are that speak in terms of Postgres

00:37:05,730 --> 00:37:11,849
types we're telling the session that we

00:37:08,670 --> 00:37:13,710
expect this this query to return a

00:37:11,849 --> 00:37:16,589
single result and then we're going to

00:37:13,710 --> 00:37:19,040
print it out so let's see what that

00:37:16,589 --> 00:37:19,040
looks like

00:37:20,490 --> 00:37:26,990
okay then okay so that works

00:37:23,910 --> 00:37:31,050
I printed out the current date if we do

00:37:26,990 --> 00:37:33,420
if we pass debug it was true to this

00:37:31,050 --> 00:37:35,040
resource will see all the messages that

00:37:33,420 --> 00:37:37,550
go back and forth so you can see it's a

00:37:35,040 --> 00:37:41,369
lot like what we've we've seen before

00:37:37,550 --> 00:37:52,320
okay any questions about this one before

00:37:41,369 --> 00:37:54,420
I move on okay this one okay this one is

00:37:52,320 --> 00:37:57,240
a little more involved we've got a

00:37:54,420 --> 00:37:59,310
session like before this time we're

00:37:57,240 --> 00:38:02,339
creating constructing a data type we've

00:37:59,310 --> 00:38:04,890
got a data type that has a country code

00:38:02,339 --> 00:38:06,390
a name and a population and now we're

00:38:04,890 --> 00:38:08,520
going to create a decoder for it and

00:38:06,390 --> 00:38:10,560
this looks a lot like the way s codec

00:38:08,520 --> 00:38:14,369
decoders work because I stole this stuff

00:38:10,560 --> 00:38:19,050
from from s codec so this is going to

00:38:14,369 --> 00:38:22,349
take a Postgres blank padded char column

00:38:19,050 --> 00:38:25,770
of length 3 and of our char and an int

00:38:22,349 --> 00:38:28,589
for column and it will map that it will

00:38:25,770 --> 00:38:32,250
take the values that are read from those

00:38:28,589 --> 00:38:35,330
from those types and pattern match on

00:38:32,250 --> 00:38:38,070
the results and construct the country so

00:38:35,330 --> 00:38:41,250
this is a codec of string this is a

00:38:38,070 --> 00:38:42,839
codec of string this is a codec event

00:38:41,250 --> 00:38:46,800
and you notice that there are different

00:38:42,839 --> 00:38:49,950
types here for they both of these things

00:38:46,800 --> 00:38:51,240
map to Scala strings okay but they have

00:38:49,950 --> 00:38:53,040
to be represented with their underlying

00:38:51,240 --> 00:38:56,580
schema types because it's very important

00:38:53,040 --> 00:38:58,530
to me that the type mapping is exact so

00:38:56,580 --> 00:38:59,970
we know exactly what we're what we're

00:38:58,530 --> 00:39:02,760
getting back and what we're and what

00:38:59,970 --> 00:39:06,630
we're putting in the database our select

00:39:02,760 --> 00:39:07,410
statement here has an argument as a

00:39:06,630 --> 00:39:10,080
parameter

00:39:07,410 --> 00:39:11,849
so what we're interpolating here in do

00:39:10,080 --> 00:39:15,150
be you interpolate values in Skunk you

00:39:11,849 --> 00:39:17,849
interpolate encoders and varchar' is an

00:39:15,150 --> 00:39:19,800
encoder that takes a string a codec is a

00:39:17,849 --> 00:39:22,320
super type of encoder and decoder so you

00:39:19,800 --> 00:39:25,770
can use it for both and then the rows

00:39:22,320 --> 00:39:27,750
the row type is country okay so we

00:39:25,770 --> 00:39:30,869
expect to get countries back

00:39:27,750 --> 00:39:32,099
okay because this is a prepared

00:39:30,869 --> 00:39:34,440
statement we have a different usage

00:39:32,099 --> 00:39:36,060
pattern we'll use the session and then

00:39:34,440 --> 00:39:39,150
when we prepare the statement what we're

00:39:36,060 --> 00:39:41,940
going to get back is prepared query okay

00:39:39,150 --> 00:39:45,090
and then the prepared query is able to

00:39:41,940 --> 00:39:47,099
stream results so we're gonna stream

00:39:45,090 --> 00:39:49,530
this thing we passed the argument which

00:39:47,099 --> 00:39:52,230
is we're gonna say any any country that

00:39:49,530 --> 00:39:54,869
starts with a is the pattern we're

00:39:52,230 --> 00:39:56,880
looking for so we're gonna stream this

00:39:54,869 --> 00:39:58,500
thing in chunks of eight countries and

00:39:56,880 --> 00:40:00,090
then we're gonna print them all out so

00:39:58,500 --> 00:40:02,490
this is an FS two stream that we have

00:40:00,090 --> 00:40:11,160
here so all this stuff is kind of get

00:40:02,490 --> 00:40:14,430
for free so if we run this one we get

00:40:11,160 --> 00:40:26,280
these countries back and if we look at

00:40:14,430 --> 00:40:28,710
the message exchange we will see okay so

00:40:26,280 --> 00:40:30,599
we'll see that we we really are

00:40:28,710 --> 00:40:32,609
streaming this thing and chunk in small

00:40:30,599 --> 00:40:35,849
chunks so we only have eight countries

00:40:32,609 --> 00:40:38,369
in memory at a time so we read eight and

00:40:35,849 --> 00:40:39,390
then and then send them out the stream

00:40:38,369 --> 00:40:41,339
and print them and then we read another

00:40:39,390 --> 00:40:49,800
eight so this lets you stream stuff in

00:40:41,339 --> 00:40:51,990
constant time okay I'm gonna do a couple

00:40:49,800 --> 00:40:54,619
more this one is kind of a party trick I

00:40:51,990 --> 00:40:58,589
like this one

00:40:54,619 --> 00:41:02,070
okay so Postgres has this has this

00:40:58,589 --> 00:41:04,109
concept called a channel and the way

00:41:02,070 --> 00:41:06,690
that works is you can create a channel

00:41:04,109 --> 00:41:09,599
and you can send messages to it and then

00:41:06,690 --> 00:41:12,359
you can also subscribe to it okay and

00:41:09,599 --> 00:41:14,030
these and if someone publishes a message

00:41:12,359 --> 00:41:19,849
to a channel you'll get a notification

00:41:14,030 --> 00:41:19,849
asynchronously so let's run this one

00:41:21,680 --> 00:41:25,950
okay nothing's happening well let's look

00:41:24,030 --> 00:41:26,970
at what it does before you run it so we

00:41:25,950 --> 00:41:28,740
use the session what we're doing is

00:41:26,970 --> 00:41:31,230
we're creating we're saying look we want

00:41:28,740 --> 00:41:33,450
to identify the channel called foo we're

00:41:31,230 --> 00:41:35,849
gonna listen to that channel and 42 is

00:41:33,450 --> 00:41:37,050
just the it's just the the buffer link

00:41:35,849 --> 00:41:38,280
that's how long that's how many things

00:41:37,050 --> 00:41:40,560
that will accumulate before it blocks

00:41:38,280 --> 00:41:41,140
well take the first three of them and

00:41:40,560 --> 00:41:44,200
we'll

00:41:41,140 --> 00:41:45,220
I'm out okay so this program is idle

00:41:44,200 --> 00:41:46,930
it's not really doing he's doing

00:41:45,220 --> 00:41:51,910
anything right now it's not blocking any

00:41:46,930 --> 00:41:57,900
threads so now I'm over my post Chris

00:41:51,910 --> 00:42:01,260
show and I can say notify hello

00:41:57,900 --> 00:42:11,529
okay and I get my notification up here

00:42:01,260 --> 00:42:15,579
okay I can start a transaction and send

00:42:11,529 --> 00:42:17,170
a notification nothing happens until I

00:42:15,579 --> 00:42:22,809
commit and then the notification comes

00:42:17,170 --> 00:42:24,849
through okay so um and if I notify again

00:42:22,809 --> 00:42:27,180
the program will terminate because I was

00:42:24,849 --> 00:42:29,559
only reading the first three yeah so

00:42:27,180 --> 00:42:31,510
what you can do here is you can have you

00:42:29,559 --> 00:42:34,599
can use the Postgres rule system to

00:42:31,510 --> 00:42:37,359
attach to attach handlers to tables so

00:42:34,599 --> 00:42:39,640
you insert a row and it will notify some

00:42:37,359 --> 00:42:41,019
channel right so your database program

00:42:39,640 --> 00:42:42,940
can get notified when things are

00:42:41,019 --> 00:42:44,650
happening on the database you don't have

00:42:42,940 --> 00:42:46,359
to pole you don't have to re query on

00:42:44,650 --> 00:42:48,940
stuff this is really really powerful

00:42:46,359 --> 00:42:50,259
I've never seen anybody use it but I

00:42:48,940 --> 00:42:53,349
think it's it's just it's a

00:42:50,259 --> 00:42:57,640
fantastically sort of tantalizing

00:42:53,349 --> 00:43:04,029
feature okay the last thing I want to

00:42:57,640 --> 00:43:06,759
show you is error handling so I've got a

00:43:04,029 --> 00:43:10,509
query here and it's got some problems in

00:43:06,759 --> 00:43:17,230
it and I just want to try and run this

00:43:10,509 --> 00:43:21,220
thing and see what happens so okay so I

00:43:17,230 --> 00:43:26,009
tried to run this thing and it's telling

00:43:21,220 --> 00:43:28,539
me a lot of stuff about what's wrong so

00:43:26,009 --> 00:43:30,250
it's telling me what the error code is

00:43:28,539 --> 00:43:32,170
the fact that it is an error where it

00:43:30,250 --> 00:43:33,970
was raised in the Postgres source if you

00:43:32,170 --> 00:43:37,660
really want to dig and see what's going

00:43:33,970 --> 00:43:40,059
on it says that column doesn't exist

00:43:37,660 --> 00:43:42,069
maybe this other one does exist it tells

00:43:40,059 --> 00:43:45,250
us where the statement was defined so we

00:43:42,069 --> 00:43:49,329
can we can click on that and get back to

00:43:45,250 --> 00:43:51,400
our source it identifies the position in

00:43:49,329 --> 00:43:53,799
the query where the error happened and

00:43:51,400 --> 00:43:54,299
even tells you if it turns out that's an

00:43:53,799 --> 00:43:56,880
error that

00:43:54,299 --> 00:43:58,380
want to trap in your program this is the

00:43:56,880 --> 00:43:59,849
name of the error and this is the way

00:43:58,380 --> 00:44:00,749
you can trap it in your program and

00:43:59,849 --> 00:44:06,689
handle it

00:44:00,749 --> 00:44:07,049
okay so let's correct that error what

00:44:06,689 --> 00:44:14,069
did I do

00:44:07,049 --> 00:44:15,749
so population and try it again okay so

00:44:14,069 --> 00:44:17,910
now it's telling us that this operator

00:44:15,749 --> 00:44:22,079
doesn't exist you can't compare integers

00:44:17,910 --> 00:44:23,579
and varchars okay and the reason it

00:44:22,079 --> 00:44:27,809
knows this stuff that knows the exact

00:44:23,579 --> 00:44:31,559
types of the of the parameters because

00:44:27,809 --> 00:44:34,400
we've specified them so like good

00:44:31,559 --> 00:44:39,599
programs we just cast this to a bar char

00:44:34,400 --> 00:44:48,469
try again now what happens the industry

00:44:39,599 --> 00:44:48,469
craters and character vary around

00:44:51,880 --> 00:44:57,319
okay now it gets a little bit farther

00:44:54,769 --> 00:44:59,720
and now it's saying that the the actual

00:44:57,319 --> 00:45:02,539
and asserted column types are different

00:44:59,720 --> 00:45:04,549
so we're saying that we want to read

00:45:02,539 --> 00:45:09,650
down here of our char followed by an

00:45:04,549 --> 00:45:12,829
in-form that's not of our char or this

00:45:09,650 --> 00:45:16,839
is not a this is not an N for this is a

00:45:12,829 --> 00:45:21,470
blank paddock char so we can fix that

00:45:16,839 --> 00:45:25,339
okay so it's sort of it's sort of

00:45:21,470 --> 00:45:26,839
guiding us toward fixing all these

00:45:25,339 --> 00:45:28,700
programs and hopefully giving us enough

00:45:26,839 --> 00:45:30,079
clues to know what to do okay so now

00:45:28,700 --> 00:45:33,619
it's gotten a little farther and it says

00:45:30,079 --> 00:45:36,829
look that's not a valid integer the

00:45:33,619 --> 00:45:39,049
string foo and it's showing us weird

00:45:36,829 --> 00:45:40,250
what the arguments are and it's also

00:45:39,049 --> 00:45:42,710
telling us where the arguments were

00:45:40,250 --> 00:45:44,720
supplied because the query and the

00:45:42,710 --> 00:45:45,769
arguments may appear in different parts

00:45:44,720 --> 00:45:48,950
of the program so you get that

00:45:45,769 --> 00:45:59,420
information too I think if we change

00:45:48,950 --> 00:46:02,059
this to an actual int oh yeah so now

00:45:59,420 --> 00:46:04,069
it's saying exactly one row was expected

00:46:02,059 --> 00:46:06,890
but we got more so we said this is going

00:46:04,069 --> 00:46:09,470
to be unique but it's not I so now we

00:46:06,890 --> 00:46:13,160
can say limit one to make sure we only

00:46:09,470 --> 00:46:15,950
get one row back at most or exactly one

00:46:13,160 --> 00:46:17,329
okay and now the finale is it doesn't it

00:46:15,950 --> 00:46:23,869
doesn't actually do anything but all the

00:46:17,329 --> 00:46:29,049
years ago so okay so that's all I got I

00:46:23,869 --> 00:46:32,690
think I'm out of time too so um I hope

00:46:29,049 --> 00:46:37,640
this was interesting I think I kind of

00:46:32,690 --> 00:46:39,589
under the on the abstract so I hope you

00:46:37,640 --> 00:46:42,289
guys didn't actually read it before you

00:46:39,589 --> 00:46:45,319
came to the talk Oh what happened oh

00:46:42,289 --> 00:46:46,789
there we go I have some contact

00:46:45,319 --> 00:46:48,859
information all right so if you're

00:46:46,789 --> 00:46:52,039
interested in this project it's on my

00:46:48,859 --> 00:46:55,880
github it is not ready to use do not use

00:46:52,039 --> 00:46:57,980
it but I want to get a potentially

00:46:55,880 --> 00:46:59,839
usable version of it out in the next few

00:46:57,980 --> 00:47:03,090
weeks and working on the documentation I

00:46:59,839 --> 00:47:05,550
think the Scala doc is really good so

00:47:03,090 --> 00:47:08,280
if the stuff interests you I take a look

00:47:05,550 --> 00:47:10,830
feel free to experiment and get in touch

00:47:08,280 --> 00:47:20,310
I'm happy to talk about this stuff and

00:47:10,830 --> 00:47:21,780
that's all I got thank you and I'm I'm

00:47:20,310 --> 00:47:41,550
happy to take questions if anybody has

00:47:21,780 --> 00:47:43,470
any thank you

00:47:41,550 --> 00:47:46,440
the only question I have is about

00:47:43,470 --> 00:47:48,990
long-running programs for example web

00:47:46,440 --> 00:47:52,650
application how do you do a resource

00:47:48,990 --> 00:47:54,030
management in in this case okay so for a

00:47:52,650 --> 00:47:57,870
long-running program something I didn't

00:47:54,030 --> 00:47:59,070
show you is is pool connections so in

00:47:57,870 --> 00:48:01,710
these programs we're just creating a

00:47:59,070 --> 00:48:04,410
single connection but you can there's

00:48:01,710 --> 00:48:06,090
also a pool and it's it's the interface

00:48:04,410 --> 00:48:07,890
looks the same it's a resource that gets

00:48:06,090 --> 00:48:09,540
you stream it gives you sessions but

00:48:07,890 --> 00:48:12,240
when you're done with them they get they

00:48:09,540 --> 00:48:13,560
get sort of cleaned up and reset and and

00:48:12,240 --> 00:48:14,580
a check is done to make sure there's

00:48:13,560 --> 00:48:16,560
still healthy and it puts them back in

00:48:14,580 --> 00:48:20,190
the pool so what you would do in a case

00:48:16,560 --> 00:48:22,980
like that is like if it's HTTP for s

00:48:20,190 --> 00:48:24,870
that you're using for instance your

00:48:22,980 --> 00:48:26,760
program is just going to be basically a

00:48:24,870 --> 00:48:28,620
resource and part of one of the things

00:48:26,760 --> 00:48:30,810
that you're constructing is going to be

00:48:28,620 --> 00:48:33,710
the session pool and another will be

00:48:30,810 --> 00:48:35,580
your web server and and and and so

00:48:33,710 --> 00:48:37,200
essentially it's go run for the whole

00:48:35,580 --> 00:48:38,310
life of your program and you hit control

00:48:37,200 --> 00:48:40,320
C and everything will get shut down

00:48:38,310 --> 00:48:43,170
which you don't really care about but

00:48:40,320 --> 00:48:45,150
basically this you would create a

00:48:43,170 --> 00:48:47,760
session at the outermost shell of your

00:48:45,150 --> 00:48:49,860
program and pass that down and use it

00:48:47,760 --> 00:48:51,870
that way if you're not using something

00:48:49,860 --> 00:48:56,190
like HTTP for us if you're using you

00:48:51,870 --> 00:48:59,010
know some some other web server you can

00:48:56,190 --> 00:49:01,290
create this pool and just side-effect

00:48:59,010 --> 00:49:03,000
locally to get the vet to get the the

00:49:01,290 --> 00:49:05,190
resource out and and and pass that

00:49:03,000 --> 00:49:07,410
around and as long as you only do that

00:49:05,190 --> 00:49:08,850
once here you're you're okay so at the

00:49:07,410 --> 00:49:11,100
edge of your program sometimes you have

00:49:08,850 --> 00:49:13,470
nasty stuff like that if you use HTTP

00:49:11,100 --> 00:49:14,900
for s then everything's pure all the way

00:49:13,470 --> 00:49:20,190
through

00:49:14,900 --> 00:49:24,240
yes I thanks for the talk um I was

00:49:20,190 --> 00:49:27,480
wondering is there core of your library

00:49:24,240 --> 00:49:34,170
that you could extract for protocol

00:49:27,480 --> 00:49:35,340
development I wouldn't I wouldn't go

00:49:34,170 --> 00:49:39,420
that far

00:49:35,340 --> 00:49:41,670
it's pretty it's pretty specific to this

00:49:39,420 --> 00:49:45,530
use case it would be nice to be able to

00:49:41,670 --> 00:49:48,930
do that there's a ton of research in

00:49:45,530 --> 00:49:50,850
doing protocol stuff with much more

00:49:48,930 --> 00:49:52,260
specific much more precise types and

00:49:50,850 --> 00:49:57,540
what I'm using so you can you can write

00:49:52,260 --> 00:49:59,850
code where the the types the types drive

00:49:57,540 --> 00:50:03,300
these these exchanges so that you you

00:49:59,850 --> 00:50:04,890
you can stuff doesn't compile if you do

00:50:03,300 --> 00:50:06,480
things on the wrong order for instance

00:50:04,890 --> 00:50:07,890
so there's a ton of research out there

00:50:06,480 --> 00:50:11,390
what I'm doing is kind of the least that

00:50:07,890 --> 00:50:13,470
I can get away with so maybe someday I

00:50:11,390 --> 00:50:15,980
wouldn't I wouldn't say I could do it

00:50:13,470 --> 00:50:15,980
right now though

00:50:20,349 --> 00:50:26,690
I'm curious if you might reconsider your

00:50:23,479 --> 00:50:32,569
position on the derivation side seeing

00:50:26,690 --> 00:50:39,319
some talks so far right so the problem

00:50:32,569 --> 00:50:43,069
with derivation is not it's not speed so

00:50:39,319 --> 00:50:47,329
much it's it's that what will happen a

00:50:43,069 --> 00:50:49,249
lot of the time is for instance we saw

00:50:47,329 --> 00:50:52,359
an example you've got a string right and

00:50:49,249 --> 00:50:55,640
you want to you want you want to map

00:50:52,359 --> 00:50:56,690
some database type into a string there

00:50:55,640 --> 00:50:58,400
are a lot of different data type

00:50:56,690 --> 00:51:02,809
database types that might map in the

00:50:58,400 --> 00:51:04,880
string and vice versa and in order to

00:51:02,809 --> 00:51:06,799
for instance in order to make do B's

00:51:04,880 --> 00:51:10,099
query checker happy you might have to

00:51:06,799 --> 00:51:11,660
create a new type just to convince the

00:51:10,099 --> 00:51:14,989
derivation machinery to pick a different

00:51:11,660 --> 00:51:18,410
underlying JDBC type to associate string

00:51:14,989 --> 00:51:20,299
with and and what I've found in in

00:51:18,410 --> 00:51:22,940
writing do B programs is I spend a lot

00:51:20,299 --> 00:51:26,269
of time constructing new types in order

00:51:22,940 --> 00:51:28,130
to select new instances just in order to

00:51:26,269 --> 00:51:31,759
get the derivation machinery to give me

00:51:28,130 --> 00:51:34,190
the instance that I want so it's the

00:51:31,759 --> 00:51:37,849
kind of thing that we could you know I I

00:51:34,190 --> 00:51:40,039
could do it we could automate some of

00:51:37,849 --> 00:51:42,880
this stuff and I might decide that the

00:51:40,039 --> 00:51:45,739
way I have it where it's all kind of

00:51:42,880 --> 00:51:47,719
explicit ends up being a pain and it's

00:51:45,739 --> 00:51:48,979
easier to make it type driven I just

00:51:47,719 --> 00:51:50,449
wanted to try this other approach

00:51:48,979 --> 00:51:51,859
because I think I've come to the

00:51:50,449 --> 00:51:53,900
conclusion really that codecs that

00:51:51,859 --> 00:51:55,519
encoders and decoders really aren't type

00:51:53,900 --> 00:51:58,609
classes it's it's more they're more like

00:51:55,519 --> 00:52:01,130
parser Combinator's and for matters that

00:51:58,609 --> 00:52:02,509
I think this is kind of a sliding scale

00:52:01,130 --> 00:52:03,979
there's stuff that really wants to be

00:52:02,509 --> 00:52:07,549
typed driven and stuff that really wants

00:52:03,979 --> 00:52:09,739
to be sort of constructed manually and

00:52:07,549 --> 00:52:12,440
this stuff's kind of in the middle and I

00:52:09,739 --> 00:52:13,910
think you can go both ways so it's it's

00:52:12,440 --> 00:52:14,839
a good question I don't know the answer

00:52:13,910 --> 00:52:19,999
but I'm gonna try it and see what

00:52:14,839 --> 00:52:20,880
happens that's one way in the back I

00:52:19,999 --> 00:52:34,019
think

00:52:20,880 --> 00:52:36,499
somebody wants to hike answer thank you

00:52:34,019 --> 00:52:41,220
for your talk and for a nice library

00:52:36,499 --> 00:52:43,920
recently this year our 2d BC came out

00:52:41,220 --> 00:52:47,400
which is reactive database connectivity

00:52:43,920 --> 00:52:52,170
for Java it's not that cool likes cover

00:52:47,400 --> 00:52:56,069
of course but what are the differences

00:52:52,170 --> 00:52:58,140
is what what implementation both

00:52:56,069 --> 00:53:01,440
implementations differ I mean used a

00:52:58,140 --> 00:53:05,640
synchronous channel sockets and I know

00:53:01,440 --> 00:53:07,970
what exactly does are 2d BC use I don't

00:53:05,640 --> 00:53:15,359
know very much about it

00:53:07,970 --> 00:53:17,369
the my big my big issue was really not

00:53:15,359 --> 00:53:20,279
with asynchrony it was with the

00:53:17,369 --> 00:53:23,819
imprecision of talking to a database

00:53:20,279 --> 00:53:26,219
through this JDBC intermediary because

00:53:23,819 --> 00:53:28,049
it it MUX around with the type mappings

00:53:26,219 --> 00:53:29,339
it rewrites your queries it does all

00:53:28,049 --> 00:53:31,410
kinds of stuff

00:53:29,339 --> 00:53:32,700
that make it really hard to know what's

00:53:31,410 --> 00:53:35,069
going on when you're talking to the

00:53:32,700 --> 00:53:36,660
database so you know if you've ever

00:53:35,069 --> 00:53:38,219
tried to deal with dates on time zones

00:53:36,660 --> 00:53:39,299
talking to a database it's just a

00:53:38,219 --> 00:53:40,769
complete nightmare because you never

00:53:39,299 --> 00:53:42,839
know what JDBC is going to do and where

00:53:40,769 --> 00:53:44,759
the driver is going to do so that's

00:53:42,839 --> 00:53:45,960
really what I wanted to get away from so

00:53:44,759 --> 00:53:48,539
I haven't really been paying that much

00:53:45,960 --> 00:53:50,069
attention to the new asynchronous JDBC

00:53:48,539 --> 00:53:52,650
that's that's a really good question I

00:53:50,069 --> 00:53:57,210
think maybe do be will be able to switch

00:53:52,650 --> 00:54:01,559
to that if it ends up being better yeah

00:53:57,210 --> 00:54:03,100
good question any more I think we're

00:54:01,559 --> 00:54:07,380
done thank you

00:54:03,100 --> 00:54:07,380

YouTube URL: https://www.youtube.com/watch?v=NJrgj1vQeAI


