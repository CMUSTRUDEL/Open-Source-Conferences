Title: Build a Recommender System in Apache Spark and Integrate It Using Akka - by Willem Meints
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Machine Learning to some is still very magical. The truth however is that this magic is actually much easier to use than you'd expect. Come and learn how you can use Apache Spark and Akka together to build a service that recommends items to users. In this session, I'm going to show you some of the bits that go into building a recommender system, how to actually implement one in Spark and finally how to integrate the recommender system into your application using Akka HTTP.
Captions: 
	00:00:02,700 --> 00:00:08,490
hi good afternoon I hope you don't fall

00:00:06,240 --> 00:00:12,299
asleep during my presentation after such

00:00:08,490 --> 00:00:15,030
a hefty lunch hopefully I'm not going to

00:00:12,299 --> 00:00:18,180
make it worse by showing to you too much

00:00:15,030 --> 00:00:19,890
science behind machine learning but I'm

00:00:18,180 --> 00:00:22,340
going to talk to you about building a

00:00:19,890 --> 00:00:26,670
recommender system using apache spark

00:00:22,340 --> 00:00:29,010
and integrated using acha while back I

00:00:26,670 --> 00:00:31,410
started working on now a knowledge

00:00:29,010 --> 00:00:32,910
management system and one of the things

00:00:31,410 --> 00:00:35,700
that worked on was recommending

00:00:32,910 --> 00:00:38,160
knowledge to people and as part of that

00:00:35,700 --> 00:00:42,060
I experimented a little bit with apache

00:00:38,160 --> 00:00:43,530
spark and found out how to use it and i

00:00:42,060 --> 00:00:46,260
thought would be good story to tell you

00:00:43,530 --> 00:00:49,920
and show you what goes into building a

00:00:46,260 --> 00:00:51,420
recommender system and using it in your

00:00:49,920 --> 00:00:53,550
application so it's going to be a bit of

00:00:51,420 --> 00:00:55,980
a practical session instead of talking

00:00:53,550 --> 00:00:57,780
too much formulas cost functions and all

00:00:55,980 --> 00:01:00,090
that sort of stuff if you're into death

00:00:57,780 --> 00:01:02,489
I suggest you watch one of the other

00:01:00,090 --> 00:01:07,289
spark sessions that's going on during

00:01:02,489 --> 00:01:10,429
the conference I need your ratings so if

00:01:07,289 --> 00:01:12,990
you like the session rated otherwise no

00:01:10,429 --> 00:01:17,700
just tell me what you what you liked and

00:01:12,990 --> 00:01:20,819
didn't like and hopefully it will be a

00:01:17,700 --> 00:01:23,039
good session for you so who am i I'm a

00:01:20,819 --> 00:01:24,630
technical evangelist for info support is

00:01:23,039 --> 00:01:27,209
sort of the commercial talk for me and

00:01:24,630 --> 00:01:29,939
stops right here I'm just very very

00:01:27,209 --> 00:01:34,200
happy to do machine learning I love

00:01:29,939 --> 00:01:37,579
working on smart systems that help you

00:01:34,200 --> 00:01:40,859
beyond just showing data to the user I

00:01:37,579 --> 00:01:44,579
love systems that sort of help you along

00:01:40,859 --> 00:01:48,779
the way for example recommendations for

00:01:44,579 --> 00:01:50,639
knowledge obviously but also is this a

00:01:48,779 --> 00:01:52,829
smart thing to buy now or is it

00:01:50,639 --> 00:01:54,869
something that I would buy later train

00:01:52,829 --> 00:01:58,619
the computer to help you make smarter

00:01:54,869 --> 00:02:01,499
decisions that's what I like I'm is also

00:01:58,619 --> 00:02:03,990
kind of weird scala days normal

00:02:01,499 --> 00:02:10,259
microsoft MVP apparently you can't be

00:02:03,990 --> 00:02:12,420
these days if you do scala so if you

00:02:10,259 --> 00:02:14,069
look at the internet and if i browse the

00:02:12,420 --> 00:02:15,970
internet and especially netflix and

00:02:14,069 --> 00:02:20,140
spotify and stuff like that

00:02:15,970 --> 00:02:23,170
I was wondering how it's interesting

00:02:20,140 --> 00:02:25,860
there's a lot of movies 35,000 movies on

00:02:23,170 --> 00:02:29,560
Netflix that's a whole lot of stuff and

00:02:25,860 --> 00:02:31,870
of course you can search it's all right

00:02:29,560 --> 00:02:35,530
but what do you find the things you know

00:02:31,870 --> 00:02:37,360
that's what you find it's going to be a

00:02:35,530 --> 00:02:39,010
problem Google invented the search

00:02:37,360 --> 00:02:40,930
engine if you ask me the worst sir

00:02:39,010 --> 00:02:44,290
changes before but okay Debbie it's

00:02:40,930 --> 00:02:46,090
smarter but there's a limit to it you

00:02:44,290 --> 00:02:48,340
only find what you what you were looking

00:02:46,090 --> 00:02:50,050
for if you know what to search the

00:02:48,340 --> 00:02:52,209
Google can help you a surgeon teen is a

00:02:50,050 --> 00:02:55,060
perfect place but if you look at the

00:02:52,209 --> 00:02:57,100
case where Netflix and Spotify yet

00:02:55,060 --> 00:02:59,110
there's a small problem there could be

00:02:57,100 --> 00:03:01,690
music in there that I really really like

00:02:59,110 --> 00:03:04,120
but I don't know the title of the Elden

00:03:01,690 --> 00:03:07,110
of the title of the song so I'm never

00:03:04,120 --> 00:03:10,330
going to see it same goes for a movie I

00:03:07,110 --> 00:03:12,190
know I like the Avengers but there could

00:03:10,330 --> 00:03:14,620
be another movie that is very similar to

00:03:12,190 --> 00:03:17,260
the Avengers but I've never heard of it

00:03:14,620 --> 00:03:19,270
so how am I going to find it I won't

00:03:17,260 --> 00:03:21,370
because I don't know how how it's called

00:03:19,270 --> 00:03:23,560
I don't know where to find it but the

00:03:21,370 --> 00:03:25,959
keywords are and hopefully someone

00:03:23,560 --> 00:03:28,450
tagged the movies so I can search for

00:03:25,959 --> 00:03:31,209
category and then we'll get to the to

00:03:28,450 --> 00:03:36,670
the alternative to Avengers but yeah

00:03:31,209 --> 00:03:38,380
it's kinda so how do these companies

00:03:36,670 --> 00:03:40,930
solve this problem well they they start

00:03:38,380 --> 00:03:43,570
to recommend stuff to you they start to

00:03:40,930 --> 00:03:45,910
learn from you as a user what you like

00:03:43,570 --> 00:03:48,010
so if you're watching the movie Avengers

00:03:45,910 --> 00:03:49,390
the system will records that you like

00:03:48,010 --> 00:03:51,010
the adventures and that the adventures

00:03:49,390 --> 00:03:54,010
is an action movie it's about

00:03:51,010 --> 00:03:57,670
superheroes it's about action may be

00:03:54,010 --> 00:03:59,530
shooting all sorts of stuff and the next

00:03:57,670 --> 00:04:02,190
thing they do is they try to profile

00:03:59,530 --> 00:04:04,390
what what you are for kind of person and

00:04:02,190 --> 00:04:07,170
they're going to recommend you movie

00:04:04,390 --> 00:04:11,380
that are very similar based on some

00:04:07,170 --> 00:04:14,040
common properties of the movie so that's

00:04:11,380 --> 00:04:17,109
what what recommender systems are in

00:04:14,040 --> 00:04:19,510
essence the just a piece of software

00:04:17,109 --> 00:04:21,549
that profiles you that knows what you

00:04:19,510 --> 00:04:25,300
like and what you didn't like and then

00:04:21,549 --> 00:04:27,820
tries to find other stuff based on those

00:04:25,300 --> 00:04:30,030
properties that you like and recommend

00:04:27,820 --> 00:04:30,030
it to you

00:04:30,199 --> 00:04:36,449
and there are many many ways to do there

00:04:34,349 --> 00:04:39,479
these are just three of those methods

00:04:36,449 --> 00:04:41,789
matchbox matchbox recommendations as one

00:04:39,479 --> 00:04:44,849
of them I'm not going to explain them

00:04:41,789 --> 00:04:46,770
all today and these are just a few ideas

00:04:44,849 --> 00:04:48,419
and i'm going to show you the

00:04:46,770 --> 00:04:51,419
alternating least squares algorithm

00:04:48,419 --> 00:04:53,719
which is implemented by apache spark hmm

00:04:51,419 --> 00:04:55,590
surprise price why would you do that

00:04:53,719 --> 00:04:58,860
because the other ones are not

00:04:55,590 --> 00:05:02,819
implemented in apache spark the idea is

00:04:58,860 --> 00:05:07,770
that no matter what you choose they're

00:05:02,819 --> 00:05:09,599
all going to be wrong and you were

00:05:07,770 --> 00:05:13,500
thinking he's going to say there's one

00:05:09,599 --> 00:05:15,240
that's the best there isn't because you

00:05:13,500 --> 00:05:19,199
don't know what the user likes and

00:05:15,240 --> 00:05:24,050
doesn't like machine learning is this

00:05:19,199 --> 00:05:27,089
art of approximation I'd like to call in

00:05:24,050 --> 00:05:29,699
that she would say it is the kunst

00:05:27,089 --> 00:05:31,620
photography r doesn't sound anything

00:05:29,699 --> 00:05:33,930
like approximation but what we're going

00:05:31,620 --> 00:05:37,849
to do is we're going to get as close as

00:05:33,930 --> 00:05:41,610
possible to what the user likes and so

00:05:37,849 --> 00:05:45,870
you're never going to reach 100 percent

00:05:41,610 --> 00:05:48,990
and if you think about it if you don't

00:05:45,870 --> 00:05:51,149
want to reach 100 percent then why would

00:05:48,990 --> 00:05:52,500
you invest a lot of time and researching

00:05:51,149 --> 00:05:55,409
all these algorithms and these are just

00:05:52,500 --> 00:05:58,949
three and there were a lot of love other

00:05:55,409 --> 00:06:01,139
algorithms that you can use here's one

00:05:58,949 --> 00:06:03,240
tip I would like to give you before we

00:06:01,139 --> 00:06:07,169
start talking about codes and doing

00:06:03,240 --> 00:06:09,089
other things if at some point you want

00:06:07,169 --> 00:06:12,229
recommendations in your system you think

00:06:09,089 --> 00:06:15,500
the user needs help finding new stuff

00:06:12,229 --> 00:06:17,939
basically then choose whatever you like

00:06:15,500 --> 00:06:21,419
choose a product that you are familiar

00:06:17,939 --> 00:06:25,560
with such as apache spark there are

00:06:21,419 --> 00:06:29,129
others mahout hadoop that's even

00:06:25,560 --> 00:06:33,389
microsoft products as your ml actually

00:06:29,129 --> 00:06:36,629
don't use it it's very expensive no

00:06:33,389 --> 00:06:38,430
matter what you do pick it to lick you

00:06:36,629 --> 00:06:41,819
like and pick a tool that you let you

00:06:38,430 --> 00:06:42,810
know and use that don't worry about

00:06:41,819 --> 00:06:44,160
these algorithms

00:06:42,810 --> 00:06:46,410
and we're going to talk about one

00:06:44,160 --> 00:06:54,800
algorithm but don't worry it will be all

00:06:46,410 --> 00:07:02,010
right any people that you spark today

00:06:54,800 --> 00:07:05,330
who listen I hope for it ah ok so apache

00:07:02,010 --> 00:07:09,030
spark is it's a tool that allows you to

00:07:05,330 --> 00:07:11,780
build distributed programs that work on

00:07:09,030 --> 00:07:14,910
a set of data and can calculate stuff

00:07:11,780 --> 00:07:16,950
it's my version of what apache spark

00:07:14,910 --> 00:07:19,169
actually does one of the cool things

00:07:16,950 --> 00:07:20,639
that I found in Apache spark is that it

00:07:19,169 --> 00:07:22,919
offers you a lot of machine learning

00:07:20,639 --> 00:07:25,860
algorithms for example there are binary

00:07:22,919 --> 00:07:28,950
classifiers so it can tell you this

00:07:25,860 --> 00:07:31,590
email is a spam email or not there is a

00:07:28,950 --> 00:07:35,070
linear regression algorithm in there so

00:07:31,590 --> 00:07:38,910
it can predict what your car will sell

00:07:35,070 --> 00:07:41,130
for given a number of properties and

00:07:38,910 --> 00:07:44,010
loads and loads more of that kind of

00:07:41,130 --> 00:07:46,440
stuff and the cool thing about apache

00:07:44,010 --> 00:07:50,070
spark also is is that it runs everything

00:07:46,440 --> 00:07:53,700
in memory so it's very fast you can do

00:07:50,070 --> 00:08:00,930
real-time computations well as real time

00:07:53,700 --> 00:08:02,850
as a computer get so that so how does it

00:08:00,930 --> 00:08:04,440
work there's a number of ways in which

00:08:02,850 --> 00:08:08,580
you can build spark programs actually

00:08:04,440 --> 00:08:10,530
run them basically and it all comes down

00:08:08,580 --> 00:08:14,310
to this sort of structure there's a

00:08:10,530 --> 00:08:16,560
spark master in your network this is the

00:08:14,310 --> 00:08:18,780
place where you submit your job your

00:08:16,560 --> 00:08:21,210
spark jump the spark job I will get to

00:08:18,780 --> 00:08:24,090
that in a minute it's a small Scala or

00:08:21,210 --> 00:08:28,139
Java program or pointing for anyone let

00:08:24,090 --> 00:08:30,690
like set anyone doing whiten if you okay

00:08:28,139 --> 00:08:33,240
you can run Python on spark so it's cool

00:08:30,690 --> 00:08:35,459
if you like that and once you've

00:08:33,240 --> 00:08:37,860
submitted your job to spark to the spark

00:08:35,459 --> 00:08:40,320
master it will split up your data into

00:08:37,860 --> 00:08:43,740
partitions and try to distribute it over

00:08:40,320 --> 00:08:46,830
a number of slaves which makes it a lot

00:08:43,740 --> 00:08:49,529
faster because if you have a terabyte of

00:08:46,830 --> 00:08:52,260
data and because we'll go to one

00:08:49,529 --> 00:08:53,910
computer it will take some time if you

00:08:52,260 --> 00:08:55,650
split it up into hundred computers it

00:08:53,910 --> 00:08:59,830
will get faster

00:08:55,650 --> 00:09:03,160
so this is how spark works and the idea

00:08:59,830 --> 00:09:06,310
is that you write the program and that's

00:09:03,160 --> 00:09:08,470
all you have to care about at least

00:09:06,310 --> 00:09:11,910
after you've installed spark on your

00:09:08,470 --> 00:09:19,390
computer or on your data center and

00:09:11,910 --> 00:09:22,480
configured it spark programs aren't my

00:09:19,390 --> 00:09:25,780
opinion not very complex what you need

00:09:22,480 --> 00:09:27,100
to do is you need to in your application

00:09:25,780 --> 00:09:31,860
you need to create a new spark

00:09:27,100 --> 00:09:35,740
configuration object set a master and

00:09:31,860 --> 00:09:37,240
set the appt name and the reason why i'm

00:09:35,740 --> 00:09:39,460
setting the app name is because

00:09:37,240 --> 00:09:42,310
otherwise if you have a large spark

00:09:39,460 --> 00:09:44,350
closer to bruns multiple jobs there's no

00:09:42,310 --> 00:09:47,140
way you're going to find your job if you

00:09:44,350 --> 00:09:50,320
don't set a name so one of those little

00:09:47,140 --> 00:09:52,000
tips that I give people always say the

00:09:50,320 --> 00:09:54,430
name for your application otherwise you

00:09:52,000 --> 00:09:56,050
will get lost okay if you're on your

00:09:54,430 --> 00:09:58,720
development machine doesn't matter much

00:09:56,050 --> 00:10:00,790
but it's a good practice and I'd like to

00:09:58,720 --> 00:10:04,270
stick to it and the last thing you need

00:10:00,790 --> 00:10:07,420
to do is you create a spark contacts I

00:10:04,270 --> 00:10:11,950
learned and normally AC sharp guy so

00:10:07,420 --> 00:10:15,160
this is kind of okay Scarlett developers

00:10:11,950 --> 00:10:18,370
like to write less code so i don't know

00:10:15,160 --> 00:10:21,420
if this is too long for your taste but i

00:10:18,370 --> 00:10:26,620
managed still at least compress this one

00:10:21,420 --> 00:10:30,030
IC spark context it i heard someone say

00:10:26,620 --> 00:10:30,030
white once read never

00:10:30,089 --> 00:10:34,800
that's good it's what i learned from

00:10:33,329 --> 00:10:41,129
scarlet i don't know if it's a good idea

00:10:34,800 --> 00:10:43,350
or not probably not good yeah so once

00:10:41,129 --> 00:10:45,749
you have the spark contacts you can

00:10:43,350 --> 00:10:48,059
start to run code again against your

00:10:45,749 --> 00:10:50,370
spark cluster the spark contacts will

00:10:48,059 --> 00:10:52,620
take care of everything the partitioning

00:10:50,370 --> 00:10:55,439
sending data off to the slave getting

00:10:52,620 --> 00:10:58,860
data back everything what you can do for

00:10:55,439 --> 00:11:02,699
example is say okay sport contacts read

00:10:58,860 --> 00:11:04,379
a text file some file dot CSV it comes

00:11:02,699 --> 00:11:06,389
from the local hard drive so this is

00:11:04,379 --> 00:11:08,100
kind of interesting remaining in a

00:11:06,389 --> 00:11:09,389
distributed environment and I'm going to

00:11:08,100 --> 00:11:11,879
the local hard drive don't do this on

00:11:09,389 --> 00:11:14,579
production doesn't work what you need a

00:11:11,879 --> 00:11:16,410
production is HDFS or Cassandra server

00:11:14,579 --> 00:11:18,839
or the sequel server or at least

00:11:16,410 --> 00:11:21,749
something that is shared amongst the

00:11:18,839 --> 00:11:23,999
surface that are running spark the next

00:11:21,749 --> 00:11:26,160
thing I can do is say okay I get lines

00:11:23,999 --> 00:11:29,009
out of the text file and I can split

00:11:26,160 --> 00:11:33,480
them on the coma comma separated file so

00:11:29,009 --> 00:11:40,170
and after that I can convert it to a set

00:11:33,480 --> 00:11:42,209
of some data case classes the above part

00:11:40,170 --> 00:11:45,360
the first three lines of code do nothing

00:11:42,209 --> 00:11:49,439
if you don't do the count and that's

00:11:45,360 --> 00:11:54,540
because you tell spark to basically

00:11:49,439 --> 00:11:56,490
build a program the map part of your

00:11:54,540 --> 00:11:58,439
program and then once you start account

00:11:56,490 --> 00:12:01,139
there's a reduced operation then it will

00:11:58,439 --> 00:12:03,240
send the data off to the to the slaves

00:12:01,139 --> 00:12:07,019
and run the computation and come back

00:12:03,240 --> 00:12:09,959
for the result before that it doesn't

00:12:07,019 --> 00:12:12,149
know how to do that once you ask for a

00:12:09,959 --> 00:12:14,610
countable now okay i have to partition

00:12:12,149 --> 00:12:18,120
the data on every server run account and

00:12:14,610 --> 00:12:21,360
then i sum over them and then i give

00:12:18,120 --> 00:12:25,709
this we saw back that's the idea so

00:12:21,360 --> 00:12:29,399
that's let's spark very short you can do

00:12:25,709 --> 00:12:31,379
a lot more stuff spark has support for

00:12:29,399 --> 00:12:34,740
streams it has machine learning support

00:12:31,379 --> 00:12:37,079
it has graph support so you can run

00:12:34,740 --> 00:12:40,709
graph computations shorter path analysis

00:12:37,079 --> 00:12:43,010
and all that sort of stuff very cool if

00:12:40,709 --> 00:12:48,470
you haven't tried go try it out

00:12:43,010 --> 00:12:50,410
and leave it to eat if you like if you

00:12:48,470 --> 00:12:56,030
have any questions or some want to try

00:12:50,410 --> 00:12:58,160
something out okay so neither if you you

00:12:56,030 --> 00:13:02,390
seen your first spark program I'll go

00:12:58,160 --> 00:13:05,780
very fast over here by no means an

00:13:02,390 --> 00:13:07,970
expert at the end I think let's go back

00:13:05,780 --> 00:13:10,960
to our recommendation system so what our

00:13:07,970 --> 00:13:13,640
recommendations actually if you look at

00:13:10,960 --> 00:13:17,000
items and users and how to relate to

00:13:13,640 --> 00:13:18,920
each other then there's a matrix that I

00:13:17,000 --> 00:13:23,120
can build and I can say okay I've

00:13:18,920 --> 00:13:24,920
watched the movie Avengers and I really

00:13:23,120 --> 00:13:29,090
really like it I gave it a rating of

00:13:24,920 --> 00:13:31,480
five so I really like that movie I do

00:13:29,090 --> 00:13:33,710
that for a number of other movies so

00:13:31,480 --> 00:13:35,630
horizontally that the columns in the

00:13:33,710 --> 00:13:38,650
matrix those are the movies that are

00:13:35,630 --> 00:13:42,160
like and horizontally the in the Rose

00:13:38,650 --> 00:13:46,900
those are the users that like the movie

00:13:42,160 --> 00:13:52,100
so far with me makes sense right okay

00:13:46,900 --> 00:13:54,710
now here comes the trick apache spark

00:13:52,100 --> 00:13:57,140
implements the alternating least square

00:13:54,710 --> 00:14:00,580
algorithm and what it basically tries to

00:13:57,140 --> 00:14:05,420
do is build a formula that does this i

00:14:00,580 --> 00:14:07,820
have those users and items I've given a

00:14:05,420 --> 00:14:11,630
rating then why did I give that rating

00:14:07,820 --> 00:14:15,650
to the movie well that happens because I

00:14:11,630 --> 00:14:17,870
did like five properties of the movie I

00:14:15,650 --> 00:14:20,780
liked adventures because it is an action

00:14:17,870 --> 00:14:23,000
movie like adventures because someone

00:14:20,780 --> 00:14:24,230
played in it I liked the adventure

00:14:23,000 --> 00:14:27,230
movies because it's about superheroes

00:14:24,230 --> 00:14:30,580
those are properties that you can choose

00:14:27,230 --> 00:14:32,930
and i'm going to say choose because

00:14:30,580 --> 00:14:34,550
actually it doesn't have to be those

00:14:32,930 --> 00:14:37,090
provinces that I just meant mentioned

00:14:34,550 --> 00:14:40,970
I'm only going to tell the computer I

00:14:37,090 --> 00:14:43,700
would like five properties thank you

00:14:40,970 --> 00:14:45,740
very much there are five properties that

00:14:43,700 --> 00:14:47,620
describe the movie and there are five

00:14:45,740 --> 00:14:50,870
properties that describe the user and

00:14:47,620 --> 00:14:56,019
those are the same properties so if you

00:14:50,870 --> 00:14:59,439
multiply one of those properties for

00:14:56,019 --> 00:15:03,790
user with an item I should get back the

00:14:59,439 --> 00:15:10,139
rating so far so good still make sense

00:15:03,790 --> 00:15:15,399
right it's not very complicated there's

00:15:10,139 --> 00:15:18,999
bear with me I'm really so this is

00:15:15,399 --> 00:15:22,749
actually the formula but you have to

00:15:18,999 --> 00:15:24,549
agree with me how am I going to find

00:15:22,749 --> 00:15:27,970
those five properties in the first place

00:15:24,549 --> 00:15:30,970
I just check them out of my tongue I

00:15:27,970 --> 00:15:32,619
said five properties okay random guess I

00:15:30,970 --> 00:15:37,660
don't know if that's go go to be correct

00:15:32,619 --> 00:15:39,639
right it could be 10 I don't know and at

00:15:37,660 --> 00:15:43,209
the same time if you look at this

00:15:39,639 --> 00:15:45,459
formula there are two terms in formula

00:15:43,209 --> 00:15:48,879
that are unknown because I randomly

00:15:45,459 --> 00:15:50,499
choose five properties so there's no way

00:15:48,879 --> 00:15:53,290
you're going to find the most optimal

00:15:50,499 --> 00:15:56,739
solution for this so we're going to do

00:15:53,290 --> 00:16:00,459
another trick it's all these factors

00:15:56,739 --> 00:16:02,559
these decent matrices and what i've done

00:16:00,459 --> 00:16:09,369
i've choosen random numbers for one of

00:16:02,559 --> 00:16:11,949
them oh I was puzzled I was looking at

00:16:09,369 --> 00:16:13,899
the code is Apache spark and develop set

00:16:11,949 --> 00:16:17,889
in the comment choose random numbers

00:16:13,899 --> 00:16:21,179
from one of them her why would you do

00:16:17,889 --> 00:16:25,899
that that's simply because i cannot i

00:16:21,179 --> 00:16:27,790
cannot solve them both at once values

00:16:25,899 --> 00:16:29,529
for the properties of a user and the

00:16:27,790 --> 00:16:33,189
values for properties of a movie you

00:16:29,529 --> 00:16:35,410
cannot do that at the same time it's a

00:16:33,189 --> 00:16:37,959
non convex problem for the

00:16:35,410 --> 00:16:41,319
mathematicians among us and it means

00:16:37,959 --> 00:16:43,600
there's no optimal solution if you try

00:16:41,319 --> 00:16:47,049
to solve both of these parts of the

00:16:43,600 --> 00:16:48,669
formula so what do you do well the

00:16:47,049 --> 00:16:51,490
scientists came up with a solution what

00:16:48,669 --> 00:16:53,679
they did is I'm going to take the U

00:16:51,490 --> 00:16:55,839
matrix for the user I'm going to pick

00:16:53,679 --> 00:16:58,589
random numbers for every cell in a

00:16:55,839 --> 00:17:02,559
matrix and then I'm going to try and

00:16:58,589 --> 00:17:06,909
approach the rating matrix that i showed

00:17:02,559 --> 00:17:08,870
earlier most left part by modifying the

00:17:06,909 --> 00:17:12,350
values in the other

00:17:08,870 --> 00:17:15,350
matrix in the Arctic matrix and you can

00:17:12,350 --> 00:17:18,040
do that there is a so-called cost

00:17:15,350 --> 00:17:22,699
function that you can use and you can

00:17:18,040 --> 00:17:25,130
run a formula least squares is the

00:17:22,699 --> 00:17:27,350
formula and that's an approximation what

00:17:25,130 --> 00:17:29,210
it tries to do is try them to minimize

00:17:27,350 --> 00:17:33,140
the error between the predicted rating

00:17:29,210 --> 00:17:34,430
and the actual rating and for those of

00:17:33,140 --> 00:17:36,830
you that have done machine learning

00:17:34,430 --> 00:17:40,940
before linear regression it's very much

00:17:36,830 --> 00:17:43,040
that it tries to take a real value that

00:17:40,940 --> 00:17:45,040
rating 5 and try to approach it by

00:17:43,040 --> 00:17:48,110
modifying the formula so that the

00:17:45,040 --> 00:17:51,470
computer can predict it's a very same

00:17:48,110 --> 00:17:53,090
value it won't reach it and especially

00:17:51,470 --> 00:17:56,420
in a recommender system it won't reach

00:17:53,090 --> 00:17:58,400
it and it happens because this formula

00:17:56,420 --> 00:18:00,890
has two unknown parts and one of them is

00:17:58,400 --> 00:18:05,630
random and the other one I try to

00:18:00,890 --> 00:18:06,590
optimize computer can't solve this so

00:18:05,630 --> 00:18:09,140
like I said at the start of the

00:18:06,590 --> 00:18:13,360
presentation is the art of approximation

00:18:09,140 --> 00:18:16,420
it will get there somehow a little bit

00:18:13,360 --> 00:18:18,950
we'll try to approach what it really is

00:18:16,420 --> 00:18:23,150
but it cannot do that because we don't

00:18:18,950 --> 00:18:26,000
know what you like Netflix is incapable

00:18:23,150 --> 00:18:29,090
of guessing did you like action movies

00:18:26,000 --> 00:18:31,970
it doesn't know because it never tracked

00:18:29,090 --> 00:18:34,340
that sort of information so what it

00:18:31,970 --> 00:18:38,559
sorry to do is model that in these

00:18:34,340 --> 00:18:40,970
matrixes that's what we're trying to do

00:18:38,559 --> 00:18:44,240
so we've picked random numbers for the

00:18:40,970 --> 00:18:46,100
first one and we solved the second and

00:18:44,240 --> 00:18:47,929
what we do is it's alternating least

00:18:46,100 --> 00:18:51,620
squares so we're going to do the same

00:18:47,929 --> 00:18:53,840
trick we pick the souls matrix Ford I

00:18:51,620 --> 00:18:57,530
component in this formula and we're

00:18:53,840 --> 00:18:59,620
going to try again to optimize values in

00:18:57,530 --> 00:19:02,870
the user matrix and we're going to

00:18:59,620 --> 00:19:05,480
alternate that a number of times ten

00:19:02,870 --> 00:19:07,760
times approximately fifteen times you

00:19:05,480 --> 00:19:09,290
didn't know yet because it's a problem

00:19:07,760 --> 00:19:12,110
that a computer cannot solve for a

00:19:09,290 --> 00:19:14,420
hundred percent so called np-hard

00:19:12,110 --> 00:19:16,040
problems are very difficult for the

00:19:14,420 --> 00:19:22,300
computer it might never reach an optimal

00:19:16,040 --> 00:19:24,440
state so yeah recommendations ha

00:19:22,300 --> 00:19:26,840
it's more difficult than you think at

00:19:24,440 --> 00:19:28,490
first I have to start out with a matrix

00:19:26,840 --> 00:19:30,650
rating matrix and to tell you there's a

00:19:28,490 --> 00:19:34,970
reason why you get this rating then

00:19:30,650 --> 00:19:38,450
you're all okay I was like that too ok

00:19:34,970 --> 00:19:42,500
and then adult then I jumped into this

00:19:38,450 --> 00:19:45,320
formula and I was thinking how are you

00:19:42,500 --> 00:19:48,710
doing this I don't get it anymore cost

00:19:45,320 --> 00:19:50,870
functions partial derivatives if you're

00:19:48,710 --> 00:19:52,700
into that sort of thing there's a mess

00:19:50,870 --> 00:19:55,040
of online course and course around a

00:19:52,700 --> 00:19:58,280
machine learning I suggest you watch

00:19:55,040 --> 00:20:01,850
that one time and then stop never look

00:19:58,280 --> 00:20:04,640
back because why do we need to know all

00:20:01,850 --> 00:20:08,600
that all we need to know is that a

00:20:04,640 --> 00:20:10,730
computer somehow tries to find out why

00:20:08,600 --> 00:20:13,340
you like a movie of why you like a song

00:20:10,730 --> 00:20:16,760
or why you like a certain article on the

00:20:13,340 --> 00:20:19,640
web blog this is the thought that you

00:20:16,760 --> 00:20:21,740
need to keep in mind ok there has to be

00:20:19,640 --> 00:20:29,060
a sort of approximation why I am I

00:20:21,740 --> 00:20:32,420
liking this so Owens new is this I'm

00:20:29,060 --> 00:20:35,180
asking spark hello this park I would

00:20:32,420 --> 00:20:39,080
like the user rating table I'd like to

00:20:35,180 --> 00:20:42,410
get rating objects out of it that have a

00:20:39,080 --> 00:20:44,840
user ID usually get the rating an item

00:20:42,410 --> 00:20:47,380
ID the item that I like and the rating i

00:20:44,840 --> 00:20:50,570
gave and then i'm going to say

00:20:47,380 --> 00:20:52,370
alternating least squares train hello

00:20:50,570 --> 00:20:54,790
the alternate leaning squares i would

00:20:52,370 --> 00:20:58,060
like to you to try to solve the formula

00:20:54,790 --> 00:21:00,140
so it all boils down to one line and

00:20:58,060 --> 00:21:03,950
there's still a lot of magic in this

00:21:00,140 --> 00:21:05,870
don't get me wrong because i still

00:21:03,950 --> 00:21:07,910
haven't showed you whether this is

00:21:05,870 --> 00:21:13,820
correct on all these settings could be

00:21:07,910 --> 00:21:16,820
well wrong remember it's a random so

00:21:13,820 --> 00:21:18,530
yeah I don't know so what I've done I've

00:21:16,820 --> 00:21:23,090
picked three numbers that are coming

00:21:18,530 --> 00:21:24,170
from the documentation rank 10 those are

00:21:23,090 --> 00:21:28,400
the 10 properties on trying to

00:21:24,170 --> 00:21:30,170
approximate iterations how many times go

00:21:28,400 --> 00:21:34,280
I'm are going to do the alternating

00:21:30,170 --> 00:21:35,240
procedure and last longer is learning

00:21:34,280 --> 00:21:37,610
rate is the

00:21:35,240 --> 00:21:39,740
it has to do with linear regression

00:21:37,610 --> 00:21:42,200
formula it is trying to use to optimize

00:21:39,740 --> 00:21:45,350
the predicted rating versus the actual

00:21:42,200 --> 00:21:47,840
rating and all you need to know about

00:21:45,350 --> 00:21:57,350
the last one lambda is that it needs to

00:21:47,840 --> 00:22:01,280
be very small 001 is about right i'll

00:21:57,350 --> 00:22:04,370
get back so what you will get out of

00:22:01,280 --> 00:22:06,410
this is a matrix factorization model

00:22:04,370 --> 00:22:08,090
that's what it's called in a matrix

00:22:06,410 --> 00:22:13,610
factorization model you can ask for

00:22:08,090 --> 00:22:16,790
recommendations later on so now that I

00:22:13,610 --> 00:22:20,120
know that I have a train model I can use

00:22:16,790 --> 00:22:23,150
it in my applications of course you

00:22:20,120 --> 00:22:25,370
could just run the apache spark job and

00:22:23,150 --> 00:22:26,900
let it generate recommendation for all

00:22:25,370 --> 00:22:28,880
the users is stored and in the database

00:22:26,900 --> 00:22:32,000
and then use that in my application you

00:22:28,880 --> 00:22:35,120
could do that but i thought of a better

00:22:32,000 --> 00:22:36,980
way at least this morning I talked to

00:22:35,120 --> 00:22:39,710
someone from live band and he showed me

00:22:36,980 --> 00:22:42,080
another way which is even more cool so

00:22:39,710 --> 00:22:47,200
maybe i will use that for Berlin but not

00:22:42,080 --> 00:22:50,480
today and what I did is I used acha to

00:22:47,200 --> 00:22:53,390
provide a way to talk to my trained

00:22:50,480 --> 00:22:54,770
model of my recommendation system so the

00:22:53,390 --> 00:22:55,940
application looks like this there's a

00:22:54,770 --> 00:22:59,150
recommender system in my application

00:22:55,940 --> 00:23:02,570
because that is what it's about and it

00:22:59,150 --> 00:23:04,840
has model so these are all actors except

00:23:02,570 --> 00:23:07,250
for the most left party HTTP port and

00:23:04,840 --> 00:23:12,140
what you can do is you can send a

00:23:07,250 --> 00:23:13,850
message over HTTP to my service hi I

00:23:12,140 --> 00:23:16,210
would like recommendations and then

00:23:13,850 --> 00:23:18,410
we'll get you back recommendations and

00:23:16,210 --> 00:23:20,150
the other thing you can do is you can

00:23:18,410 --> 00:23:22,280
send the message to train a model and

00:23:20,150 --> 00:23:24,020
I've made it in such a way that if you

00:23:22,280 --> 00:23:25,730
are training a model which can take a

00:23:24,020 --> 00:23:29,059
long time machine learning algorithms to

00:23:25,730 --> 00:23:31,370
run for a long time while carrying them

00:23:29,059 --> 00:23:35,450
is very fast so there's a good thing to

00:23:31,370 --> 00:23:37,880
keep in mind every so clearing them very

00:23:35,450 --> 00:23:39,830
fast and I need to scale out for the

00:23:37,880 --> 00:23:42,140
number of users that are using my rest

00:23:39,830 --> 00:23:44,270
surface and on the back end if I have a

00:23:42,140 --> 00:23:46,370
large amount of data that i use to

00:23:44,270 --> 00:23:49,100
generate recommendations to train my

00:23:46,370 --> 00:23:51,590
model basically then that needs to scale

00:23:49,100 --> 00:23:55,490
based on the number of Records I have in

00:23:51,590 --> 00:23:57,890
the database this is a another tip think

00:23:55,490 --> 00:24:03,350
about where you want scale and how your

00:23:57,890 --> 00:24:08,539
mana scale I'm not going to bore you

00:24:03,350 --> 00:24:10,760
with bits about the HTTP routes and all

00:24:08,539 --> 00:24:13,070
that sort of stuff the codes on github

00:24:10,760 --> 00:24:14,780
so you can try it out over there I'm

00:24:13,070 --> 00:24:17,120
just going to walk you through some of

00:24:14,780 --> 00:24:19,610
the general things that I've done one of

00:24:17,120 --> 00:24:25,429
the things that I've done is the

00:24:19,610 --> 00:24:30,770
recommender system has an optional model

00:24:25,429 --> 00:24:32,990
and I chose this option because I think

00:24:30,770 --> 00:24:35,270
that if the model is not trained the

00:24:32,990 --> 00:24:37,990
service should just generate no

00:24:35,270 --> 00:24:40,309
recommendation it shouldn't crash never

00:24:37,990 --> 00:24:44,510
there's no use in the crushing service

00:24:40,309 --> 00:24:46,220
instead give me a slight hints like yeah

00:24:44,510 --> 00:24:49,520
sorry i don't have recommendations for

00:24:46,220 --> 00:24:52,130
you doesn't work today sorry what will

00:24:49,520 --> 00:24:53,870
happen is once i start to send it the

00:24:52,130 --> 00:24:58,429
message to drain it will start to train

00:24:53,870 --> 00:25:00,110
a model and to train the model it will

00:24:58,429 --> 00:25:02,299
spin up the recommender system trainer

00:25:00,110 --> 00:25:08,320
actor and that actually will talk to

00:25:02,299 --> 00:25:11,390
spark and call the LSO train method and

00:25:08,320 --> 00:25:13,909
so what I've actually done if I are I

00:25:11,390 --> 00:25:16,330
have distributed my job to the

00:25:13,909 --> 00:25:19,640
background good boy I don't want to know

00:25:16,330 --> 00:25:21,080
get back to me when you're done and the

00:25:19,640 --> 00:25:26,900
rest of the rest of us will keep on

00:25:21,080 --> 00:25:29,900
running so in an initial case the the

00:25:26,900 --> 00:25:31,750
model is empty there's there's none so

00:25:29,900 --> 00:25:34,760
the user will get empty recommendations

00:25:31,750 --> 00:25:37,130
but once there is a model it will keep

00:25:34,760 --> 00:25:41,809
on serving that model until I didn't I

00:25:37,130 --> 00:25:44,990
am done training in another model so you

00:25:41,809 --> 00:25:47,090
could theoretically continuously train

00:25:44,990 --> 00:25:50,750
your recommender system based on changes

00:25:47,090 --> 00:25:52,159
that happen by the users but one of the

00:25:50,750 --> 00:25:55,250
other things that that happens in

00:25:52,159 --> 00:25:57,620
machine learning is that ok I've made

00:25:55,250 --> 00:25:59,990
this slightly simpler to work with spark

00:25:57,620 --> 00:26:02,409
but the model will be get it will be

00:25:59,990 --> 00:26:02,409
becoming

00:26:02,429 --> 00:26:07,409
much worse actually it starts out bad

00:26:04,950 --> 00:26:10,379
eighty percent that's what I'm aiming

00:26:07,409 --> 00:26:12,929
for but gradually as you start watching

00:26:10,379 --> 00:26:16,289
movies and listening to music I will

00:26:12,929 --> 00:26:18,299
learn new patterns because I recommended

00:26:16,289 --> 00:26:21,119
some weird band from Germany or

00:26:18,299 --> 00:26:23,610
something to you and you really like

00:26:21,119 --> 00:26:25,740
that and based on that I will discover

00:26:23,610 --> 00:26:28,980
that you like German music I don't know

00:26:25,740 --> 00:26:31,649
if that happens every much but it could

00:26:28,980 --> 00:26:34,679
be so the model gets worse so I provide

00:26:31,649 --> 00:26:36,539
an especial and specialized endpoint to

00:26:34,679 --> 00:26:41,210
explicitly start to train a model again

00:26:36,539 --> 00:26:41,210
and replace my old model when I'm done

00:26:43,549 --> 00:26:49,950
so how do i generate recommendations

00:26:46,139 --> 00:26:52,740
well once I have the model I can ask it

00:26:49,950 --> 00:26:57,269
for recommendations and I've done a very

00:26:52,740 --> 00:27:00,360
functional trick I say model the flat

00:26:57,269 --> 00:27:02,850
map and flat map on an optional will not

00:27:00,360 --> 00:27:06,119
fire if it's a nun if it's a some it

00:27:02,850 --> 00:27:08,519
will fire & microbe will continue hey no

00:27:06,119 --> 00:27:13,499
exception handling which we have done in

00:27:08,519 --> 00:27:16,799
c-sharp then when my flat nap runs it

00:27:13,499 --> 00:27:20,580
will my model will recommend products

00:27:16,799 --> 00:27:22,470
and I will generate products from a user

00:27:20,580 --> 00:27:25,139
that I specified and the number of

00:27:22,470 --> 00:27:28,769
products are wall and it's very generic

00:27:25,139 --> 00:27:31,619
what it will do it will from the matrix

00:27:28,769 --> 00:27:34,080
that are generated with the predictions

00:27:31,619 --> 00:27:37,169
for items that I didn't know yet if

00:27:34,080 --> 00:27:40,919
you'll pick the top 10 most relevant

00:27:37,169 --> 00:27:45,629
items based on the calculated rating and

00:27:40,919 --> 00:27:48,600
that's what you get back so once i get

00:27:45,629 --> 00:27:51,230
that get that back i will say ok convert

00:27:48,600 --> 00:27:55,470
it to my own internal representation and

00:27:51,230 --> 00:27:58,980
if everything else fails give me an

00:27:55,470 --> 00:28:00,330
empty list that's all it does and also

00:27:58,980 --> 00:28:05,309
has recommendations i will get them back

00:28:00,330 --> 00:28:11,520
over the rest surface in this case acha

00:28:05,309 --> 00:28:17,700
has HTTP does it sound complicated

00:28:11,520 --> 00:28:23,010
to use I see one question just think

00:28:17,700 --> 00:28:25,200
just thinking okay can happen it happens

00:28:23,010 --> 00:28:28,970
to me all the time that's why I come up

00:28:25,200 --> 00:28:32,820
with it is it weird it is but ok so far

00:28:28,970 --> 00:28:35,850
I've asked my computer based on ratings

00:28:32,820 --> 00:28:39,150
that I have in my database to generate a

00:28:35,850 --> 00:28:42,210
set of random numbers for a set of

00:28:39,150 --> 00:28:47,010
recommendations it could go wrong very

00:28:42,210 --> 00:28:50,820
wrong I mean how on earth is that going

00:28:47,010 --> 00:28:53,700
to work well there's a very scientific

00:28:50,820 --> 00:28:57,150
approach to test this sort of thing and

00:28:53,700 --> 00:28:59,250
that is what you do is every time the

00:28:57,150 --> 00:29:00,990
user asked for recommendations store

00:28:59,250 --> 00:29:02,610
them somewhere in a database the fact

00:29:00,990 --> 00:29:06,710
that you've generated recommendations

00:29:02,610 --> 00:29:11,670
for the user and it's as simple as this

00:29:06,710 --> 00:29:15,090
user ID item ID and score and when

00:29:11,670 --> 00:29:17,730
you've generated if you like it doesn't

00:29:15,090 --> 00:29:20,940
really is not necessary to have that but

00:29:17,730 --> 00:29:23,010
could be useful next thing you do is you

00:29:20,940 --> 00:29:25,470
implement a small piece of code in your

00:29:23,010 --> 00:29:28,410
application that records that when

00:29:25,470 --> 00:29:30,720
someone selects an item in a database

00:29:28,410 --> 00:29:34,080
you record somewhere in the database

00:29:30,720 --> 00:29:36,960
that item is selected and first and the

00:29:34,080 --> 00:29:39,060
third step is ok I've generated a list

00:29:36,960 --> 00:29:43,260
of recommended items for the user and he

00:29:39,060 --> 00:29:46,800
has clicked the few items I'm assuming

00:29:43,260 --> 00:29:48,840
here that the items he selected in the

00:29:46,800 --> 00:29:51,090
front end or the items he finds

00:29:48,840 --> 00:29:54,090
interesting mind you did is not very

00:29:51,090 --> 00:29:55,800
scientific but it works we've tried this

00:29:54,090 --> 00:30:00,840
on production we call it stealth testing

00:29:55,800 --> 00:30:03,690
and we use this very often for all sorts

00:30:00,840 --> 00:30:06,630
of processes and this way we can find

00:30:03,690 --> 00:30:09,750
out if the recommendations of remotely

00:30:06,630 --> 00:30:11,940
correct so the first time your

00:30:09,750 --> 00:30:14,520
recommendations will be wrong I'm just

00:30:11,940 --> 00:30:17,300
saying the first attempt you you take

00:30:14,520 --> 00:30:19,950
this will be very very very very wrong

00:30:17,300 --> 00:30:24,860
don't worry if you do continuous

00:30:19,950 --> 00:30:27,220
delivery I hope you do anybody doing

00:30:24,860 --> 00:30:32,049
continuous employment on production I

00:30:27,220 --> 00:30:36,890
hope so hope so there's one hand oh

00:30:32,049 --> 00:30:41,360
there's not a serious nobody doing this

00:30:36,890 --> 00:30:43,220
yeah I can really recommend this for if

00:30:41,360 --> 00:30:47,179
you're building this the first time it

00:30:43,220 --> 00:30:48,350
will be wrong so if you want to fix this

00:30:47,179 --> 00:30:51,650
if you discover that your

00:30:48,350 --> 00:30:53,900
recommendations are wrong I suggest that

00:30:51,650 --> 00:30:55,309
you implement some form of continuous

00:30:53,900 --> 00:30:57,049
deployment so that you can tweak those

00:30:55,309 --> 00:31:00,200
parameters I talked about earlier the

00:30:57,049 --> 00:31:02,840
iterations the rank and alumni so dad

00:31:00,200 --> 00:31:04,790
you can quickly improve the

00:31:02,840 --> 00:31:07,640
recommendations this is how it works

00:31:04,790 --> 00:31:09,830
this is what we do what no now we take

00:31:07,640 --> 00:31:11,900
this algorithm be deployed on production

00:31:09,830 --> 00:31:14,419
we want these three steps and we

00:31:11,900 --> 00:31:17,780
discovered oh it's wrong ok I'm going to

00:31:14,419 --> 00:31:19,700
tweak it and try again and we can do

00:31:17,780 --> 00:31:22,640
that every five minutes or so because

00:31:19,700 --> 00:31:25,100
our build is slow but yeah you gotta go

00:31:22,640 --> 00:31:27,290
somewhere so back returns to the number

00:31:25,100 --> 00:31:30,620
crunching so this is how it works what

00:31:27,290 --> 00:31:32,360
we do is we say items that are really

00:31:30,620 --> 00:31:35,870
interesting those are the items that the

00:31:32,360 --> 00:31:37,130
user clicked clicked the other items

00:31:35,870 --> 00:31:40,400
that you should didn't click in a

00:31:37,130 --> 00:31:44,030
database are not interesting also an

00:31:40,400 --> 00:31:45,860
assumption because i don't know but well

00:31:44,030 --> 00:31:48,850
you gotta start somewhere yeah you have

00:31:45,860 --> 00:31:52,549
to do something to solve this problem

00:31:48,850 --> 00:31:54,830
next I'm going to look at the predicted

00:31:52,549 --> 00:31:56,809
items items that I've predicted in the

00:31:54,830 --> 00:31:59,210
front end that I've shown to the user

00:31:56,809 --> 00:32:02,720
are interesting at least I think they

00:31:59,210 --> 00:32:05,240
are the other items I didn't show are

00:32:02,720 --> 00:32:07,160
potentially not interesting again this

00:32:05,240 --> 00:32:10,190
is an assumption I could be wrong

00:32:07,160 --> 00:32:12,980
because item number ten to twenty eleven

00:32:10,190 --> 00:32:15,590
to 220 could still be interesting but

00:32:12,980 --> 00:32:18,049
I've never shown them so you never know

00:32:15,590 --> 00:32:20,840
what's going to happen and from these

00:32:18,049 --> 00:32:23,390
numbers in the confusion matrix if

00:32:20,840 --> 00:32:25,880
you're if you're interested in in more

00:32:23,390 --> 00:32:27,559
of this I suggest you google for

00:32:25,880 --> 00:32:28,970
confusion matrix is one of the

00:32:27,559 --> 00:32:31,880
validation techniques in machine

00:32:28,970 --> 00:32:35,510
learning to validate recommendation

00:32:31,880 --> 00:32:37,429
systems and from this matrix you can

00:32:35,510 --> 00:32:38,590
calculate a position that's the amount

00:32:37,429 --> 00:32:42,779
of items that I

00:32:38,590 --> 00:32:44,950
predicted that were also correct so I

00:32:42,779 --> 00:32:47,710
calculate the items that I've

00:32:44,950 --> 00:32:52,690
recommended in front end and then and

00:32:47,710 --> 00:32:56,260
that were interested and I add to that

00:32:52,690 --> 00:32:59,440
the number of items that were truly not

00:32:56,260 --> 00:33:01,990
interesting and divided by the total

00:32:59,440 --> 00:33:03,880
number of items that I have and that

00:33:01,990 --> 00:33:07,450
will get me a position how many items of

00:33:03,880 --> 00:33:09,429
what I predicted were correct so that

00:33:07,450 --> 00:33:14,020
means that if you recommend 10 movies

00:33:09,429 --> 00:33:17,140
and say out of those 10 movies 8 were

00:33:14,020 --> 00:33:19,840
good we're the ones that I like and I'm

00:33:17,140 --> 00:33:22,659
doing pretty good eight percent the

00:33:19,840 --> 00:33:24,490
other metric is how many items from the

00:33:22,659 --> 00:33:28,539
set of items that I have in a database

00:33:24,490 --> 00:33:31,330
for example if i recommend you ten

00:33:28,539 --> 00:33:35,140
movies out of 35,000 then I could say

00:33:31,330 --> 00:33:37,750
recall is a little bit low but from

00:33:35,140 --> 00:33:41,350
those 45,000 only a thousand could be

00:33:37,750 --> 00:33:42,640
interesting I don't know yet but using

00:33:41,350 --> 00:33:44,940
the confusion matrix you can calculate

00:33:42,640 --> 00:33:44,940
this

00:33:48,140 --> 00:33:51,980
there is an interesting relationship

00:33:50,210 --> 00:33:55,010
between the two and that's the reason

00:33:51,980 --> 00:33:58,940
why I'm showing them precision I'd say

00:33:55,010 --> 00:34:02,030
it's pretty important however if I'm

00:33:58,940 --> 00:34:05,720
trying to sell ghouls shoes then it

00:34:02,030 --> 00:34:09,350
could be more important to have all the

00:34:05,720 --> 00:34:10,970
shoes available in front end as many

00:34:09,350 --> 00:34:13,159
issues from my collection as possible

00:34:10,970 --> 00:34:14,630
because that's increasing the chance

00:34:13,159 --> 00:34:17,840
that your book good actually going to

00:34:14,630 --> 00:34:20,330
buy shoes it's a sort of fault so recall

00:34:17,840 --> 00:34:22,550
could sometimes be more important than

00:34:20,330 --> 00:34:28,100
precision and there's an interesting

00:34:22,550 --> 00:34:31,070
problem with these two measurements if I

00:34:28,100 --> 00:34:32,690
show just one item to the user I have a

00:34:31,070 --> 00:34:35,780
fifty percent chance that that's correct

00:34:32,690 --> 00:34:38,810
so potentially the position in that case

00:34:35,780 --> 00:34:42,020
of a single item could be zero which is

00:34:38,810 --> 00:34:46,790
pretty bad but it could also be hundred

00:34:42,020 --> 00:34:51,679
percent getting lucky so what do you do

00:34:46,790 --> 00:34:56,120
well the the solution is showing more

00:34:51,679 --> 00:34:58,850
items for example 5 but then the

00:34:56,120 --> 00:35:02,480
precision lowers but recall increases

00:34:58,850 --> 00:35:04,490
because yeah there's a larger amount of

00:35:02,480 --> 00:35:08,150
items that I pull from the database and

00:35:04,490 --> 00:35:10,900
show to the user that's a recall so you

00:35:08,150 --> 00:35:13,370
cannot maximize precision and recall

00:35:10,900 --> 00:35:17,480
nothing not at the same time so you have

00:35:13,370 --> 00:35:19,280
to make a choice and here's where it

00:35:17,480 --> 00:35:21,010
gets interesting where I think it gets

00:35:19,280 --> 00:35:23,470
very cool with if you talk about

00:35:21,010 --> 00:35:25,460
recommender systems and why I think

00:35:23,470 --> 00:35:28,190
Netflix is actually doing a pretty good

00:35:25,460 --> 00:35:31,220
job despite the fact that some people

00:35:28,190 --> 00:35:32,810
may be disliked recommendations is there

00:35:31,220 --> 00:35:34,910
anyone in the room that has ever had

00:35:32,810 --> 00:35:37,460
only good movies from the

00:35:34,910 --> 00:35:41,440
recommendations from netflix you know

00:35:37,460 --> 00:35:43,820
one hambre never huh another question

00:35:41,440 --> 00:35:47,530
did you ever click on a movie that you

00:35:43,820 --> 00:35:50,000
didn't like at first sight on Netflix

00:35:47,530 --> 00:35:55,490
maybe I'm a boring saturday night

00:35:50,000 --> 00:35:59,630
raining yeah that's because they choose

00:35:55,490 --> 00:36:03,680
a sweet spot somewhere halfway the graph

00:35:59,630 --> 00:36:05,000
it's weird huh on one hand if you try to

00:36:03,680 --> 00:36:06,980
approach one hundred percent in

00:36:05,000 --> 00:36:09,920
precision you're going to show the

00:36:06,980 --> 00:36:11,660
movies the user expects to see and those

00:36:09,920 --> 00:36:16,250
are probably the movies that he already

00:36:11,660 --> 00:36:18,920
saw because i can approximate dos the

00:36:16,250 --> 00:36:21,950
best with this algorithm on the other

00:36:18,920 --> 00:36:24,140
hand if i don't do that and I maximize

00:36:21,950 --> 00:36:27,700
recall I get movies you've never seen

00:36:24,140 --> 00:36:30,050
and you probably go right like huh

00:36:27,700 --> 00:36:31,820
forget a netflix i'm going to the to the

00:36:30,050 --> 00:36:34,340
next neighbor I don't know Hulu or

00:36:31,820 --> 00:36:39,020
something in stage do you have any

00:36:34,340 --> 00:36:40,910
alternative to netflix amazon prime for

00:36:39,020 --> 00:36:44,750
example because they choose a different

00:36:40,910 --> 00:36:46,430
setting I mean that's how it goes so if

00:36:44,750 --> 00:36:47,810
you're going to add recommendations to

00:36:46,430 --> 00:36:50,540
your system think about this and

00:36:47,810 --> 00:36:52,070
sometimes deliberately choose a fail you

00:36:50,540 --> 00:36:55,130
for a position that's lower than the

00:36:52,070 --> 00:36:57,200
eighty percent it promotes discovery of

00:36:55,130 --> 00:36:59,330
new content that user hasn't seen before

00:36:57,200 --> 00:37:01,100
well its main at the same time

00:36:59,330 --> 00:37:03,380
maintaining the feeling that it's

00:37:01,100 --> 00:37:06,470
connected to you that the user has it

00:37:03,380 --> 00:37:10,400
has an idea of I know this yeah oh the

00:37:06,470 --> 00:37:12,800
other movie is also cool so in this case

00:37:10,400 --> 00:37:15,980
in this specific appliance of machine

00:37:12,800 --> 00:37:20,060
learning it's best to spend a little bit

00:37:15,980 --> 00:37:22,040
of time tuning this and sweet spot is

00:37:20,060 --> 00:37:25,220
somewhere in there sometimes it's better

00:37:22,040 --> 00:37:30,280
to use higher vehicle sometimes it's

00:37:25,220 --> 00:37:33,230
better to use a higher position so I

00:37:30,280 --> 00:37:36,290
thought about it and I got a lot of

00:37:33,230 --> 00:37:37,820
questions about this during my I do a

00:37:36,290 --> 00:37:40,130
course on machine learning for own

00:37:37,820 --> 00:37:43,580
company and a lot of people that follow

00:37:40,130 --> 00:37:46,730
the course a talk to me and say well

00:37:43,580 --> 00:37:50,090
yeah I can't write unit tests for this

00:37:46,730 --> 00:37:52,670
no you can't well you could do a little

00:37:50,090 --> 00:37:54,740
bit maybe a mock for your recommender

00:37:52,670 --> 00:37:57,320
system and try to see if the HTTP

00:37:54,740 --> 00:37:59,000
connection is ok we do that but

00:37:57,320 --> 00:38:01,460
obviously for machine learning solutions

00:37:59,000 --> 00:38:03,740
there is no way you're going to write a

00:38:01,460 --> 00:38:07,220
single unit test is always right it will

00:38:03,740 --> 00:38:09,590
probably flip during the build sometimes

00:38:07,220 --> 00:38:12,150
read sometimes dream because yeah it's

00:38:09,590 --> 00:38:14,799
an np-hard problem you can't get there

00:38:12,150 --> 00:38:17,740
so another tip I'd like to give you if

00:38:14,799 --> 00:38:20,940
you're going to build a machine solution

00:38:17,740 --> 00:38:20,940
machine learning solution like this

00:38:22,470 --> 00:38:28,809
spend a little bit more money and

00:38:24,970 --> 00:38:37,390
monitoring the system spend some time

00:38:28,809 --> 00:38:39,460
and money on these steps this is where

00:38:37,390 --> 00:38:42,069
your investment should be from machine

00:38:39,460 --> 00:38:43,990
unique solution get real feedback from

00:38:42,069 --> 00:38:47,109
the users ask them what they liked and

00:38:43,990 --> 00:38:50,609
didn't like because machine learning is

00:38:47,109 --> 00:38:53,650
very very cool i really like it i

00:38:50,609 --> 00:38:56,680
suggest you use it for everything that

00:38:53,650 --> 00:38:58,690
you build i don't mind but please be

00:38:56,680 --> 00:39:02,369
aware that a human is always the last

00:38:58,690 --> 00:39:02,369
one to check if it's right or not

00:39:02,910 --> 00:39:09,190
because machines are like this they

00:39:06,880 --> 00:39:11,349
don't see left and right they don't have

00:39:09,190 --> 00:39:13,900
a gut feeling they don't have emotions

00:39:11,349 --> 00:39:16,569
they don't know they just know the

00:39:13,900 --> 00:39:18,279
mathematical formula formula for

00:39:16,569 --> 00:39:21,970
recommendations and they got it wrong

00:39:18,279 --> 00:39:24,450
too I mean how are you going to trust

00:39:21,970 --> 00:39:28,329
that so if you're trying this out and

00:39:24,450 --> 00:39:29,829
you've got a code up on github it's open

00:39:28,329 --> 00:39:31,599
source you can download it you can leave

00:39:29,829 --> 00:39:34,089
issues if you like if you run into any

00:39:31,599 --> 00:39:36,430
trouble the readme file is very short at

00:39:34,089 --> 00:39:39,339
the moment download this load a bunch of

00:39:36,430 --> 00:39:43,390
data and that's it but I will extend

00:39:39,339 --> 00:39:47,069
that and yeah if you have any questions

00:39:43,390 --> 00:39:47,069
please shout out

00:39:49,140 --> 00:40:00,109
yes the question is how do I measure

00:39:56,039 --> 00:40:03,839
false positives well the false negatives

00:40:00,109 --> 00:40:07,529
those are very hard to predict those are

00:40:03,839 --> 00:40:09,539
items that I didn't recommend but are in

00:40:07,529 --> 00:40:11,369
the database so the question for four

00:40:09,539 --> 00:40:14,630
people that didn't hear how do I measure

00:40:11,369 --> 00:40:16,980
false negatives well the the thing is

00:40:14,630 --> 00:40:20,130
this is all based around a bunch of

00:40:16,980 --> 00:40:22,740
assumptions so sometimes the user clicks

00:40:20,130 --> 00:40:27,960
on an item that I haven't recommended as

00:40:22,740 --> 00:40:30,150
a false negative yeah so the whole

00:40:27,960 --> 00:40:32,609
measurements thing is is based around a

00:40:30,150 --> 00:40:34,829
totally disconnected system there's no

00:40:32,609 --> 00:40:36,930
relationship between the clickstream so

00:40:34,829 --> 00:40:38,819
to speak dice would use click and a

00:40:36,930 --> 00:40:41,789
recommender system we haven't done that

00:40:38,819 --> 00:40:44,309
in no now or anywhere else because

00:40:41,789 --> 00:40:46,940
that's it would be kind of hard to do

00:40:44,309 --> 00:40:49,859
that what about you wouldn't be able to

00:40:46,940 --> 00:40:52,680
extract the false negatives so does that

00:40:49,859 --> 00:40:54,829
answer your question cool more question

00:40:52,680 --> 00:40:54,829
yeah

00:41:11,630 --> 00:41:15,299
there's a good question i have a two

00:41:13,619 --> 00:41:19,020
dimensional matrix that i'm trying to

00:41:15,299 --> 00:41:32,369
solve and I assume you're talking about

00:41:19,020 --> 00:41:33,960
the confusion matrix yeah mm-hmm that's

00:41:32,369 --> 00:41:37,440
a good question which process approach

00:41:33,960 --> 00:41:39,750
is the best there isn't it totally

00:41:37,440 --> 00:41:41,010
depends on what you're doing you can use

00:41:39,750 --> 00:41:44,270
a recommender system for recommending

00:41:41,010 --> 00:41:47,730
movies and like i said netflix

00:41:44,270 --> 00:41:51,390
approaches this in a way that they say

00:41:47,730 --> 00:41:54,630
okay we're going for the middle of the

00:41:51,390 --> 00:41:56,130
chart that I showed we're going for a

00:41:54,630 --> 00:42:00,839
little bit precision a little bit recall

00:41:56,130 --> 00:42:02,279
about 5050 but if you are if you have to

00:42:00,839 --> 00:42:06,359
recommend items that the user already

00:42:02,279 --> 00:42:08,579
knows it's I can't come up with a use

00:42:06,359 --> 00:42:10,829
case for that right now but if you want

00:42:08,579 --> 00:42:13,529
to use that then position is more

00:42:10,829 --> 00:42:16,650
important but if you're a web shop and

00:42:13,529 --> 00:42:20,160
you're trying to show as many items in

00:42:16,650 --> 00:42:21,900
your catalog as you as you want as

00:42:20,160 --> 00:42:24,359
possible then recall is more percent and

00:42:21,900 --> 00:42:27,569
more important there's one thing to keep

00:42:24,359 --> 00:42:30,660
in mind you can maximize both you cannot

00:42:27,569 --> 00:42:35,779
do that so sorry there's no best

00:42:30,660 --> 00:42:35,779
approach any other question

00:43:07,080 --> 00:43:12,610
yeah so that's a good there's a good

00:43:09,550 --> 00:43:14,860
good one to mention I've simplified this

00:43:12,610 --> 00:43:17,100
scenario to a number of items but you

00:43:14,860 --> 00:43:20,830
can imagine thirty five thousand titles

00:43:17,100 --> 00:43:23,980
100-plus million users this guitar is

00:43:20,830 --> 00:43:27,370
getting pretty big and I'm not sure how

00:43:23,980 --> 00:43:30,970
Netflix manages the size but if you're

00:43:27,370 --> 00:43:33,250
an online retailer like you said and you

00:43:30,970 --> 00:43:35,280
have trouble getting the data into a

00:43:33,250 --> 00:43:38,350
manageable size you could always run

00:43:35,280 --> 00:43:41,740
individual training runs per category on

00:43:38,350 --> 00:43:44,410
your web shop again I'm not sure what

00:43:41,740 --> 00:43:46,690
the results will be like I don't know it

00:43:44,410 --> 00:43:48,640
could be all wrong but you have to try

00:43:46,690 --> 00:43:50,650
it out this is pure experimentation

00:43:48,640 --> 00:43:52,210
that's why I mentioned continuous

00:43:50,650 --> 00:43:55,510
deployment if you can deploy these

00:43:52,210 --> 00:43:58,330
solutions quickly you can experiment and

00:43:55,510 --> 00:44:24,250
see what use is like and don't like yeah

00:43:58,330 --> 00:44:26,700
another question oh that's a good one

00:44:24,250 --> 00:44:26,700
yeah

00:44:28,370 --> 00:44:35,940
the question is would it be possible to

00:44:33,480 --> 00:44:37,980
let the user ques whether the he would

00:44:35,940 --> 00:44:45,330
like position versus recoil as the most

00:44:37,980 --> 00:44:47,970
important measure for example does one

00:44:45,330 --> 00:44:51,180
solution there's one problem you when

00:44:47,970 --> 00:44:53,430
you train the system and you can start

00:44:51,180 --> 00:44:56,820
to gather feedback then you will have to

00:44:53,430 --> 00:44:59,280
fiddle with the rank the iterations and

00:44:56,820 --> 00:45:01,350
alumni and that's those three measures

00:44:59,280 --> 00:45:04,260
are for everyone it is not for a single

00:45:01,350 --> 00:45:07,290
user that's going to be a big problem

00:45:04,260 --> 00:45:09,630
otherwise what you would do is train a

00:45:07,290 --> 00:45:12,200
single model for every user I don't know

00:45:09,630 --> 00:45:15,890
how crazy that is could be worth a try

00:45:12,200 --> 00:45:15,890
yeah it could be

00:45:23,079 --> 00:45:29,950
yeah you could do that yeah you could

00:45:25,739 --> 00:45:31,930
train three models that would add 11 for

00:45:29,950 --> 00:45:35,289
precision 14 the middle situation and

00:45:31,930 --> 00:45:37,839
one photo recall you could do that again

00:45:35,289 --> 00:45:39,700
it did it all depends on the data size

00:45:37,839 --> 00:45:41,170
you have if you have a feel terrible I

00:45:39,700 --> 00:45:43,950
think it would be manageable if you have

00:45:41,170 --> 00:45:48,609
something like Netflix hmm I don't know

00:45:43,950 --> 00:45:51,670
yeah and and it's good to mention this

00:45:48,609 --> 00:45:53,680
is a very simplified picture of the

00:45:51,670 --> 00:45:57,640
situation netflix netflix these days

00:45:53,680 --> 00:46:00,130
uses six models combined so i don't know

00:45:57,640 --> 00:46:03,309
it's kind of a different ball on

00:46:00,130 --> 00:46:05,670
ballpark any more questions you know

00:46:03,309 --> 00:46:05,670
Holden

00:46:11,970 --> 00:46:24,330
i as a good question is the measurement

00:46:22,320 --> 00:46:26,430
of position and recall between each

00:46:24,330 --> 00:46:29,849
training running the same no they

00:46:26,430 --> 00:46:32,130
fluctuate a little bit so sometimes it

00:46:29,849 --> 00:46:33,990
could happen that you that you have the

00:46:32,130 --> 00:46:35,700
same settings will run the training

00:46:33,990 --> 00:46:38,760
session two times and you get a

00:46:35,700 --> 00:46:41,700
different error rate that's because it's

00:46:38,760 --> 00:46:44,630
an MP hard situation and the computers

00:46:41,700 --> 00:46:46,320
choosing random numbers so that's why

00:46:44,630 --> 00:46:48,240
monitoring this sort of thing is

00:46:46,320 --> 00:46:50,580
important you have to follow the

00:46:48,240 --> 00:46:53,910
precision and recall over time and if it

00:46:50,580 --> 00:46:56,430
suddenly drops but suddenly is higher

00:46:53,910 --> 00:46:58,349
than then what you expect then you have

00:46:56,430 --> 00:47:01,020
to do something then you have to go and

00:46:58,349 --> 00:47:02,580
find out what what's going on do I need

00:47:01,020 --> 00:47:05,280
to change the rank do i need to change

00:47:02,580 --> 00:47:10,260
the iterations do we need two things

00:47:05,280 --> 00:47:14,099
like that so yeah does that answer your

00:47:10,260 --> 00:47:21,530
question okay cool I think I have time

00:47:14,099 --> 00:47:24,530
for one more question now cool thanks oh

00:47:21,530 --> 00:47:24,530
yeah

00:47:30,100 --> 00:47:34,570
you get a score for every recommendation

00:47:37,930 --> 00:47:44,000
yeah that's that's how we work so you

00:47:41,480 --> 00:47:47,000
calculate a predicted rating for every

00:47:44,000 --> 00:47:49,040
item and it sorted from highest to

00:47:47,000 --> 00:47:54,230
lowest and the top 10 is the one the one

00:47:49,040 --> 00:48:00,950
you are giving back but still the top 10

00:47:54,230 --> 00:48:03,170
could be wrong it could still happen

00:48:00,950 --> 00:48:05,510
that you predicted a rating of 5 for an

00:48:03,170 --> 00:48:08,240
item but it's actually a 1 it could

00:48:05,510 --> 00:48:11,660
happen and then is it doesn't know

00:48:08,240 --> 00:48:14,330
working so yeah that's why I chose this

00:48:11,660 --> 00:48:17,390
validation method of over some other

00:48:14,330 --> 00:48:21,500
methods while you look at the score yeah

00:48:17,390 --> 00:48:23,740
just what happens to be cool thanks for

00:48:21,500 --> 00:48:23,740

YouTube URL: https://www.youtube.com/watch?v=203uXty1Vu4


