Title: Towards a safe, sane I O library in Scala - by Pathikrit Bhowmick
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Doing I/O in Scala (and Java) involves either invoking some magic "FileUtil" or browsing through StackOverflow. In this talk, we will introduce better-files (https://github.com/pathikrit/better-files) - a thin wrapper around Java NIO to enable simple, safe and sane I/O in Scala. We will also discuss problems with designing an I/O library that would make everyone happy and different schools of thoughts e.g. monadic vs non-blocking vs effect-based APIs
Captions: 
	00:00:13,850 --> 00:00:33,180
so so when I stalk about filesystem IO

00:00:31,470 --> 00:00:35,460
file system operations is things like

00:00:33,180 --> 00:00:38,430
basic things like reading a string from

00:00:35,460 --> 00:00:41,640
a file appending some lines moving a

00:00:38,430 --> 00:00:45,330
directory here copying stuff maybe zip

00:00:41,640 --> 00:00:47,040
unzip changing owners stuff like that so

00:00:45,330 --> 00:00:48,870
all the things that I listed here you

00:00:47,040 --> 00:00:50,700
could probably do if you are familiar

00:00:48,870 --> 00:00:52,170
with the UNIX command line you could

00:00:50,700 --> 00:00:57,480
probably do it on your sleep like okay

00:00:52,170 --> 00:00:58,770
mm v RM cat echo so on and so forth but

00:00:57,480 --> 00:01:03,630
if I were to ask you to do the same

00:00:58,770 --> 00:01:05,460
things in Scala well I doubt many of you

00:01:03,630 --> 00:01:08,460
would correctly do it in a fair amount

00:01:05,460 --> 00:01:10,350
of time and unfortunately the state of

00:01:08,460 --> 00:01:13,620
the art right now is this you'll

00:01:10,350 --> 00:01:15,390
probably Google it find something I'll

00:01:13,620 --> 00:01:18,180
stack overflow copy/paste and move on

00:01:15,390 --> 00:01:20,159
because that's how it is done unless you

00:01:18,180 --> 00:01:23,490
already wrote your own library which

00:01:20,159 --> 00:01:28,020
does a lot of these things I mean this

00:01:23,490 --> 00:01:30,600
is just an example I guess the point is

00:01:28,020 --> 00:01:32,340
not that clear here but it's some

00:01:30,600 --> 00:01:34,080
screenshots from Stack Overflow all I

00:01:32,340 --> 00:01:35,820
want to say is these are very basic

00:01:34,080 --> 00:01:36,630
questions about how to read and write a

00:01:35,820 --> 00:01:39,150
file of Scour

00:01:36,630 --> 00:01:40,530
then this screenshots were taking like I

00:01:39,150 --> 00:01:43,080
don't know a couple of weeks ago when I

00:01:40,530 --> 00:01:45,930
made these slides that they have this

00:01:43,080 --> 00:01:47,940
much lot of people voting them starring

00:01:45,930 --> 00:01:51,299
them and this guy have been pointed out

00:01:47,940 --> 00:01:53,100
like hey this is how I read a file is

00:01:51,299 --> 00:01:55,140
called and Ruby Python and some other

00:01:53,100 --> 00:01:57,150
language it's literally one line like

00:01:55,140 --> 00:01:58,790
you open the file and you reel it

00:01:57,150 --> 00:02:01,049
what's the best way to do it in Scala

00:01:58,790 --> 00:02:03,659
actually the top answers in both these

00:02:01,049 --> 00:02:06,180
questions are not that great this guy

00:02:03,659 --> 00:02:08,549
the top answer here I see to use a

00:02:06,180 --> 00:02:10,649
library which has whose last commit was

00:02:08,549 --> 00:02:12,610
four or five years ago and the top

00:02:10,649 --> 00:02:15,790
answer here actually

00:02:12,610 --> 00:02:16,990
the filestream open or did not the top

00:02:15,790 --> 00:02:19,240
and so the accepted answer

00:02:16,990 --> 00:02:24,100
so even copying from stackoverflow might

00:02:19,240 --> 00:02:26,140
bite youth so let's take a simple

00:02:24,100 --> 00:02:29,670
example I want to append some text to a

00:02:26,140 --> 00:02:32,680
file and let me write it in the most

00:02:29,670 --> 00:02:34,720
idiomatic way or the most simple way so

00:02:32,680 --> 00:02:36,700
this is what my code would look like

00:02:34,720 --> 00:02:39,160
this is some reasonable code I'm not

00:02:36,700 --> 00:02:43,180
using an external library for the rest

00:02:39,160 --> 00:02:45,850
of this talk and I I have a file a Java

00:02:43,180 --> 00:02:48,940
dot IO dot file has some text I'm gonna

00:02:45,850 --> 00:02:50,950
need a codec this is something you most

00:02:48,940 --> 00:02:52,660
of the time you don't care about but to

00:02:50,950 --> 00:02:55,870
write a good library you need to give

00:02:52,660 --> 00:02:59,500
your users ability to pass in custom

00:02:55,870 --> 00:03:03,550
Kasich's or codec so and this is stuff

00:02:59,500 --> 00:03:06,670
like utf-8 a sky stuff in Java it's the

00:03:03,550 --> 00:03:08,590
Java dot IO dot car set in Scala it's

00:03:06,670 --> 00:03:10,000
color dot IO dot codec but they have

00:03:08,590 --> 00:03:11,440
implicit converters between each other

00:03:10,000 --> 00:03:13,120
so you don't have to worry about it most

00:03:11,440 --> 00:03:17,140
of the time and this is how you read it

00:03:13,120 --> 00:03:20,830
I mean okay you had to write - five six

00:03:17,140 --> 00:03:23,350
seven lines of code not bad alright but

00:03:20,830 --> 00:03:24,459
you can smell like this is not something

00:03:23,350 --> 00:03:26,440
you want to do it over and over again

00:03:24,459 --> 00:03:30,519
this is you want this to be in a library

00:03:26,440 --> 00:03:33,130
like and plus there are some caveats to

00:03:30,519 --> 00:03:35,950
this like doing IO is hard like that's

00:03:33,130 --> 00:03:38,769
why very few libraries exist even now

00:03:35,950 --> 00:03:42,280
that correctly does this covers all

00:03:38,769 --> 00:03:44,049
cases like I just listed some corner

00:03:42,280 --> 00:03:46,660
cases like it's not obvious from this

00:03:44,049 --> 00:03:48,610
code like what happen if the file does

00:03:46,660 --> 00:03:50,920
not exist what if you're trying to write

00:03:48,610 --> 00:03:52,570
your directory what if you don't have

00:03:50,920 --> 00:03:55,090
write permissions what if it's a symlink

00:03:52,570 --> 00:03:56,709
maybe you want to handle those cases

00:03:55,090 --> 00:03:58,239
separately if it's assembling to a legit

00:03:56,709 --> 00:04:01,480
file you may want to follow the same

00:03:58,239 --> 00:04:03,760
link or not what if that's the right

00:04:01,480 --> 00:04:06,670
lock I mean does the OS - it does Java

00:04:03,760 --> 00:04:08,799
do it what's going on and and it's not

00:04:06,670 --> 00:04:10,420
obvious like that's like a whole ton of

00:04:08,799 --> 00:04:12,400
things that could go wrong with this

00:04:10,420 --> 00:04:16,510
code and you would have to handle

00:04:12,400 --> 00:04:20,109
exceptions okay so in my previous slide

00:04:16,510 --> 00:04:23,830
I did not use any Java niño so that's

00:04:20,109 --> 00:04:25,220
the new i/o library that Java introduced

00:04:23,830 --> 00:04:28,370
in Java 7

00:04:25,220 --> 00:04:32,630
it was part of the jsr so let's use Java

00:04:28,370 --> 00:04:34,490
in i/o so wow that's great you want to

00:04:32,630 --> 00:04:36,920
copy a file from a source to a

00:04:34,490 --> 00:04:38,810
destination so in Java and i/o they set

00:04:36,920 --> 00:04:42,020
up a Java dot IO dot file is the legacy

00:04:38,810 --> 00:04:44,030
thing use Java dot n io dot file dot

00:04:42,020 --> 00:04:46,220
path and there's this files util which

00:04:44,030 --> 00:04:47,900
lets you do a lot of things and you're

00:04:46,220 --> 00:04:50,180
like ok this is great I don't need I

00:04:47,900 --> 00:04:52,120
need a library anymore this NR is

00:04:50,180 --> 00:04:54,560
awesome this will solve all my problems

00:04:52,120 --> 00:04:58,520
until you read the documentation or

00:04:54,560 --> 00:05:00,950
actually try it it says only files can

00:04:58,520 --> 00:05:03,020
be copied by files not copy or a

00:05:00,950 --> 00:05:05,230
directory can be quoted only if the

00:05:03,020 --> 00:05:08,660
directory is empty

00:05:05,230 --> 00:05:11,360
it actually throws Java dot IO dot file

00:05:08,660 --> 00:05:16,490
dot directory not empty exception if

00:05:11,360 --> 00:05:18,320
your directory is not empty this thing

00:05:16,490 --> 00:05:21,080
this this kind of things makes you lose

00:05:18,320 --> 00:05:23,419
trust in the library it makes you think

00:05:21,080 --> 00:05:25,700
well every time you use this files you

00:05:23,419 --> 00:05:27,740
tell from Java dot IO you don't know

00:05:25,700 --> 00:05:29,210
what else you're missing I mean there

00:05:27,740 --> 00:05:32,090
are caveats to this that's not even

00:05:29,210 --> 00:05:34,040
covered here like what if what if this

00:05:32,090 --> 00:05:36,350
thing did copy directories what if it

00:05:34,040 --> 00:05:38,630
was a symlink and it was assembling to a

00:05:36,350 --> 00:05:40,100
directory would that work it's not even

00:05:38,630 --> 00:05:42,169
obvious from this documentation like

00:05:40,100 --> 00:05:46,880
what if some links to directly should

00:05:42,169 --> 00:05:50,720
work or not all right so let's copy

00:05:46,880 --> 00:05:52,340
directories correctly using Scala this

00:05:50,720 --> 00:05:54,410
is what the code looks like and I did

00:05:52,340 --> 00:05:57,850
not obviously try to make the code

00:05:54,410 --> 00:05:59,930
longer I went to the doc start Oracle

00:05:57,850 --> 00:06:02,330
examples copied Java

00:05:59,930 --> 00:06:04,040
and took the Java code which was 50

00:06:02,330 --> 00:06:07,220
lines long and wrote it in the most

00:06:04,040 --> 00:06:10,460
idiomatic scholar who way possible and

00:06:07,220 --> 00:06:11,660
this is how you do it you're not going

00:06:10,460 --> 00:06:13,940
to write like this is something that

00:06:11,660 --> 00:06:15,020
you're not gonna be able to write it in

00:06:13,940 --> 00:06:17,630
your sleep like you shouldn't be able

00:06:15,020 --> 00:06:18,800
you shouldn't be worrying about IO every

00:06:17,630 --> 00:06:20,180
time you want to do some code you want

00:06:18,800 --> 00:06:24,710
to copy some files if you have coming

00:06:20,180 --> 00:06:27,880
from the shell is CP - are YC p - r is

00:06:24,710 --> 00:06:30,530
this here well ok

00:06:27,880 --> 00:06:34,310
again it has other stuff that's not i

00:06:30,530 --> 00:06:36,050
didn't and now so let's look at

00:06:34,310 --> 00:06:37,729
solutions obviously we are not the first

00:06:36,050 --> 00:06:38,310
people to run into it people have been

00:06:37,729 --> 00:06:42,030
using the j

00:06:38,310 --> 00:06:44,190
the system for 20 25 years so what are

00:06:42,030 --> 00:06:47,070
what exists out there before we go and

00:06:44,190 --> 00:06:49,470
reinvent the wheel so there's two very

00:06:47,070 --> 00:06:51,360
good widely used libraries in the Java

00:06:49,470 --> 00:06:54,660
ecosystem which is Apache Commons and

00:06:51,360 --> 00:06:57,240
Google guava it works great I have no

00:06:54,660 --> 00:06:58,950
qualms against them I used to work in

00:06:57,240 --> 00:07:01,740
one of them in Google and we used to

00:06:58,950 --> 00:07:03,810
have all the time it's great but there's

00:07:01,740 --> 00:07:05,160
some caviar stirred I feel like dirty

00:07:03,810 --> 00:07:08,280
every time I have to depend on a Java

00:07:05,160 --> 00:07:10,650
library I don't know what you also the

00:07:08,280 --> 00:07:12,390
idioms don't translate over like you

00:07:10,650 --> 00:07:16,320
have to always do this some kind of util

00:07:12,390 --> 00:07:20,040
dot some things and you are do util dot

00:07:16,320 --> 00:07:22,170
do this versus if you are too in Scala I

00:07:20,040 --> 00:07:25,830
would use probably implicit stood Ecker

00:07:22,170 --> 00:07:27,990
ate my file course to add this secondly

00:07:25,830 --> 00:07:30,210
the Java type system is not that

00:07:27,990 --> 00:07:31,530
powerful yeah I don't know if you're

00:07:30,210 --> 00:07:35,190
familiar with the scanner class from

00:07:31,530 --> 00:07:38,490
Java Java dot IO which lets you slurp

00:07:35,190 --> 00:07:40,710
inputs and scan integers and strings of

00:07:38,490 --> 00:07:45,450
whatnot from the command line from any

00:07:40,710 --> 00:07:47,220
file and you get this dot next int but

00:07:45,450 --> 00:07:49,530
in Scala I would probably write it as

00:07:47,220 --> 00:07:53,760
dot next and pass the integer type class

00:07:49,530 --> 00:07:55,380
and I would probably implement like type

00:07:53,760 --> 00:07:57,660
plus here for things that I can't read

00:07:55,380 --> 00:08:01,020
so it this would probably a colon read

00:07:57,660 --> 00:08:04,560
and that way this is extensible I can

00:08:01,020 --> 00:08:08,130
use the same scanner to read to define

00:08:04,560 --> 00:08:13,040
custom parsers let's say and it's not

00:08:08,130 --> 00:08:16,740
possible here like this is not flexible

00:08:13,040 --> 00:08:18,660
and okay so the next option is okay fine

00:08:16,740 --> 00:08:21,480
you don't want to use Java library you

00:08:18,660 --> 00:08:23,940
just use plain Java and as I said before

00:08:21,480 --> 00:08:26,790
like Java and IO is full of surprises

00:08:23,940 --> 00:08:29,280
like this is an example that has bitten

00:08:26,790 --> 00:08:31,140
me in the past so if you want to count

00:08:29,280 --> 00:08:34,290
the number of lines in a file that

00:08:31,140 --> 00:08:36,210
should be trivial so again use that

00:08:34,290 --> 00:08:38,520
files util fine I don't wanna use you

00:08:36,210 --> 00:08:41,480
toes but what can I do is Java I do dot

00:08:38,520 --> 00:08:44,340
line start count this actually does not

00:08:41,480 --> 00:08:47,330
it works there's a nasty bug in it it

00:08:44,340 --> 00:08:49,720
leaves a file handler open it opens a

00:08:47,330 --> 00:08:51,819
Java stream and

00:08:49,720 --> 00:08:53,769
it never closes it so if you you just

00:08:51,819 --> 00:08:55,209
have a long on this side you'll forget

00:08:53,769 --> 00:08:57,040
that this thing opened the stream if you

00:08:55,209 --> 00:08:59,889
do it enough times you would get too

00:08:57,040 --> 00:09:03,009
many file open exception or something so

00:08:59,889 --> 00:09:05,170
again there are traps everywhere and

00:09:03,009 --> 00:09:07,930
this makes you lose confidence in Java

00:09:05,170 --> 00:09:10,750
and IO and this is another one of my

00:09:07,930 --> 00:09:12,310
favorite examples this code has no bugs

00:09:10,750 --> 00:09:15,519
in it nothing in it it's just the

00:09:12,310 --> 00:09:17,829
verbosity so if you're familiar with the

00:09:15,519 --> 00:09:20,560
sound command from UNIX it all it does

00:09:17,829 --> 00:09:22,029
it takes the file takes our owner signs

00:09:20,560 --> 00:09:25,629
that owner to the file changes the 1 or

00:09:22,029 --> 00:09:28,300
2 the of the file to the string so if I

00:09:25,629 --> 00:09:30,160
were to write it in using plain Java and

00:09:28,300 --> 00:09:32,439
I oh this is what I have to do file

00:09:30,160 --> 00:09:34,750
start set on our file get the file

00:09:32,439 --> 00:09:37,300
system get the user principle lookup

00:09:34,750 --> 00:09:38,910
service then look up the principle by

00:09:37,300 --> 00:09:41,920
name and set it

00:09:38,910 --> 00:09:44,709
this is no way you could upon this and

00:09:41,920 --> 00:09:47,860
who you know the Java Docs by heart or

00:09:44,709 --> 00:09:50,829
you look it up on Stack Overflow alright

00:09:47,860 --> 00:09:54,639
ok enough about Java let's look at what

00:09:50,829 --> 00:09:56,079
can we do in Scala so there is in the

00:09:54,639 --> 00:09:59,350
standard library the scholar diode or

00:09:56,079 --> 00:10:02,949
source it does not solve most of our

00:09:59,350 --> 00:10:04,990
problems like exhibtion finding the

00:10:02,949 --> 00:10:07,180
number of lines in a file it doesn't

00:10:04,990 --> 00:10:09,550
solve any of that if you just want to

00:10:07,180 --> 00:10:12,100
like do basic io like read and write

00:10:09,550 --> 00:10:14,500
maybe does but again it's not the ideal

00:10:12,100 --> 00:10:16,300
and from what I've heard from the Scala

00:10:14,500 --> 00:10:19,019
team that it's actually targeted for

00:10:16,300 --> 00:10:22,740
application in the next few versions

00:10:19,019 --> 00:10:25,779
there's scholar dot IO or Scala - IO

00:10:22,740 --> 00:10:27,970
again so this is kind of interesting so

00:10:25,779 --> 00:10:30,819
this there was a lot of activity on it

00:10:27,970 --> 00:10:32,920
and the last commit was four years ago

00:10:30,819 --> 00:10:35,259
and even the last commit was like a

00:10:32,920 --> 00:10:38,470
readme update and the last actual commit

00:10:35,259 --> 00:10:42,420
was in 2011 ok it's all library do all

00:10:38,470 --> 00:10:45,490
that breeze work but it has it has this

00:10:42,420 --> 00:10:48,279
idiosyncrasy it tried to do too much it

00:10:45,490 --> 00:10:51,100
tried to have it try to introduce new

00:10:48,279 --> 00:10:52,689
concepts new abstractions for everything

00:10:51,100 --> 00:10:54,069
that we have in Java like all the

00:10:52,689 --> 00:10:56,649
buffered readers and input stream

00:10:54,069 --> 00:10:58,569
writers and or whatnot and in the end it

00:10:56,649 --> 00:11:01,199
became this bloated thing that was

00:10:58,569 --> 00:11:03,720
almost as hard to use as caller:i oh and

00:11:01,199 --> 00:11:07,620
who didn't do a lot of the

00:11:03,720 --> 00:11:09,790
developer day-to-day stuff easily and I

00:11:07,620 --> 00:11:11,230
bet like the developers would have

00:11:09,790 --> 00:11:12,399
reached a better point if it was

00:11:11,230 --> 00:11:15,339
maintained but it's an unmaintained

00:11:12,399 --> 00:11:18,339
library and then there is ammonite ops

00:11:15,339 --> 00:11:22,180
this is by our favorite scholar develop

00:11:18,339 --> 00:11:25,180
early Howie I have no qualms against it

00:11:22,180 --> 00:11:27,100
go use this library it's awesome there

00:11:25,180 --> 00:11:28,480
are some minor things that I don't like

00:11:27,100 --> 00:11:30,790
about it it's nothing to do with the

00:11:28,480 --> 00:11:33,610
library it's basically it has a very

00:11:30,790 --> 00:11:35,680
UNIX see Shelley flavor up to it

00:11:33,610 --> 00:11:38,350
like if you want to remove a directory

00:11:35,680 --> 00:11:41,830
you do this little thing and that

00:11:38,350 --> 00:11:43,420
actually works for the intended purposes

00:11:41,830 --> 00:11:45,490
or into the original intended purpose of

00:11:43,420 --> 00:11:47,230
ammonite which was for the a monoid

00:11:45,490 --> 00:11:50,260
shell at the ammonite repple which lets

00:11:47,230 --> 00:11:53,410
you which gives you scholar shell and do

00:11:50,260 --> 00:11:55,750
stuff as if you're in a UNIX shell but

00:11:53,410 --> 00:11:57,820
it's actually a strongly typed shelf

00:11:55,750 --> 00:11:59,890
gives you filter some of this all that

00:11:57,820 --> 00:12:01,839
and for that a monoid office is awesome

00:11:59,890 --> 00:12:05,649
like this is the kind of syntax you may

00:12:01,839 --> 00:12:08,709
like in there and the other thing that

00:12:05,649 --> 00:12:10,540
is hard with ammonite ops is if you want

00:12:08,709 --> 00:12:12,220
to do any custom things like if you want

00:12:10,540 --> 00:12:13,990
to pass in your own codec like you don't

00:12:12,220 --> 00:12:15,910
want to write a utf-8 file you want to

00:12:13,990 --> 00:12:18,880
write something else you want to pipe an

00:12:15,910 --> 00:12:20,170
input stream because your other library

00:12:18,880 --> 00:12:23,320
that you depend on gives you an input

00:12:20,170 --> 00:12:25,180
stream or you want to give it a custom

00:12:23,320 --> 00:12:26,470
link option saying it's a symlink or

00:12:25,180 --> 00:12:32,680
something like it becomes hard with a

00:12:26,470 --> 00:12:35,020
monoid ops and there is this rolling

00:12:32,680 --> 00:12:38,140
your own like if you actually google for

00:12:35,020 --> 00:12:41,560
IO util dot Scala you would see tons of

00:12:38,140 --> 00:12:43,060
results on github of pretty much every

00:12:41,560 --> 00:12:44,680
library having something called file

00:12:43,060 --> 00:12:47,170
util or I we do know that Scala which

00:12:44,680 --> 00:12:49,329
does all these things and I mean you

00:12:47,170 --> 00:12:51,130
just as there is dry which is do not

00:12:49,329 --> 00:12:52,720
repeat yourself I think there's a more

00:12:51,130 --> 00:12:54,550
important paradigm we should learn it

00:12:52,720 --> 00:12:57,940
which is do not repeat other people

00:12:54,550 --> 00:13:00,010
including yourself and there's no reason

00:12:57,940 --> 00:13:03,010
everyone has to check in an io util dot

00:13:00,010 --> 00:13:04,450
current is there every project and then

00:13:03,010 --> 00:13:08,020
there is better files which is the

00:13:04,450 --> 00:13:10,870
library I'm going to talk about it grew

00:13:08,020 --> 00:13:12,459
out of my frustrations I'd now realize

00:13:10,870 --> 00:13:15,000
it's a pretty bad name for a library

00:13:12,459 --> 00:13:15,000
better files

00:13:15,280 --> 00:13:20,170
there's a historical reason for it it

00:13:16,990 --> 00:13:22,390
grew from me adding implicit Stu Java

00:13:20,170 --> 00:13:24,160
dot IO dot file I'm just calling it all

00:13:22,390 --> 00:13:26,140
the put out the M plus s in one file

00:13:24,160 --> 00:13:27,790
called it better faster Scala and it

00:13:26,140 --> 00:13:30,130
would add all the things that I need but

00:13:27,790 --> 00:13:36,370
it give to be popular enough now that I

00:13:30,130 --> 00:13:38,800
regret this name but ok alright so

00:13:36,370 --> 00:13:40,660
before I go into the design like the

00:13:38,800 --> 00:13:42,910
beta files library I want to take a step

00:13:40,660 --> 00:13:46,180
back and think about what an ideal IO

00:13:42,910 --> 00:13:48,070
library should look like in Scala you

00:13:46,180 --> 00:13:51,060
know what's great about Scala it's it's

00:13:48,070 --> 00:13:53,290
a melting pot of ideas like you have

00:13:51,060 --> 00:13:56,290
ideas a lot of different language

00:13:53,290 --> 00:13:58,180
concepts that come together in Scala not

00:13:56,290 --> 00:13:59,860
necessarily they work with each other in

00:13:58,180 --> 00:14:02,080
the best ways but there are all there

00:13:59,860 --> 00:14:05,050
and this leads to some interesting

00:14:02,080 --> 00:14:07,000
situations like when you want to design

00:14:05,050 --> 00:14:11,680
some high level paradigm or a new kind

00:14:07,000 --> 00:14:13,600
of library how do you go about it you

00:14:11,680 --> 00:14:16,090
can actually see this manifest in this

00:14:13,600 --> 00:14:18,400
github issue so this was a Scala slip of

00:14:16,090 --> 00:14:21,010
someone saying hey Scala should have a

00:14:18,400 --> 00:14:23,050
library and this went on for pages and

00:14:21,010 --> 00:14:24,940
pages of discussions where everyone had

00:14:23,050 --> 00:14:27,520
their own opinion of what's the best way

00:14:24,940 --> 00:14:29,650
to do about it so some of the paradigms

00:14:27,520 --> 00:14:32,410
we can think about when designing an i/o

00:14:29,650 --> 00:14:35,440
library would be we can either go a more

00:14:32,410 --> 00:14:36,880
functional way like pure i/o all all

00:14:35,440 --> 00:14:39,340
your side effects are captured using

00:14:36,880 --> 00:14:42,520
monads reach through a reader monad

00:14:39,340 --> 00:14:46,240
writer monad knows no exceptions no

00:14:42,520 --> 00:14:48,580
side-effects that's one way another is

00:14:46,240 --> 00:14:51,700
if you're if you're more from the icarus

00:14:48,580 --> 00:14:53,380
trimming paradigm you want streaming i/o

00:14:51,700 --> 00:14:55,630
you want to think about joining pipes

00:14:53,380 --> 00:14:58,660
and floats and sinks and sources and

00:14:55,630 --> 00:15:03,040
that's how you want to move model i/o

00:14:58,660 --> 00:15:05,560
through back pressures and even this

00:15:03,040 --> 00:15:07,030
college s there's a lot of people who

00:15:05,560 --> 00:15:08,620
are interested colleges like how do you

00:15:07,030 --> 00:15:09,940
make it compatible like if you depend on

00:15:08,620 --> 00:15:12,550
Java and I know it's probably not gonna

00:15:09,940 --> 00:15:14,950
work on colleges but ok even that aside

00:15:12,550 --> 00:15:17,800
like even know jess has this philosophy

00:15:14,950 --> 00:15:19,690
or this programming model very fast in

00:15:17,800 --> 00:15:22,390
callbacks when this is on error and

00:15:19,690 --> 00:15:23,680
that's how you are on success and that's

00:15:22,390 --> 00:15:26,170
how you handle those things so you don't

00:15:23,680 --> 00:15:27,730
do a try-catch that doesn't I haven't

00:15:26,170 --> 00:15:28,870
seen that used in any Scala library yet

00:15:27,730 --> 00:15:31,510
but there have this

00:15:28,870 --> 00:15:33,550
in the thread to do it that way and we

00:15:31,510 --> 00:15:36,670
also have a lot of Java baggage like the

00:15:33,550 --> 00:15:38,380
Java dot IO gives you all those buffered

00:15:36,670 --> 00:15:40,089
readers and output stream writers and

00:15:38,380 --> 00:15:43,660
input stream readers you don't know

00:15:40,089 --> 00:15:45,430
which one to use I mean few of you would

00:15:43,660 --> 00:15:48,490
know which one to use in which situation

00:15:45,430 --> 00:15:50,110
what's best for oh and you'd hear all

00:15:48,490 --> 00:15:51,880
this like Stack Overflow questions like

00:15:50,110 --> 00:15:53,440
oh I have an input stream I need an

00:15:51,880 --> 00:15:56,250
output stream right or how do I convert

00:15:53,440 --> 00:15:58,660
those two things from one to another and

00:15:56,250 --> 00:16:01,300
so we have to do with a lot of Java

00:15:58,660 --> 00:16:04,180
baggage on a day to day basis and you

00:16:01,300 --> 00:16:05,800
want the library to just work like you

00:16:04,180 --> 00:16:07,720
don't you don't even think about it you

00:16:05,800 --> 00:16:09,370
don't think about when you're using the

00:16:07,720 --> 00:16:13,390
Scala collections library you just use

00:16:09,370 --> 00:16:15,010
map and flatmap and filter so Scala IO

00:16:13,390 --> 00:16:17,470
should also be like that you shouldn't

00:16:15,010 --> 00:16:21,730
have to think about what do I do or look

00:16:17,470 --> 00:16:24,520
it up open your Chrome Google it so I

00:16:21,730 --> 00:16:27,130
went and had my own design goals for

00:16:24,520 --> 00:16:28,480
this library and I didn't listen to any

00:16:27,130 --> 00:16:31,210
of the things I was that in the thread I

00:16:28,480 --> 00:16:33,520
so this is what I want and if people

00:16:31,210 --> 00:16:36,160
like it so use it if not go for this

00:16:33,520 --> 00:16:39,910
library start your own so the first

00:16:36,160 --> 00:16:41,529
thing I wanted is to be catch off like I

00:16:39,910 --> 00:16:44,709
should not have to depend on any other

00:16:41,529 --> 00:16:46,660
i/o library ever so I went and made a

00:16:44,709 --> 00:16:49,870
list of all the i/o utils in Google

00:16:46,660 --> 00:16:52,029
guava Apache Commons IO jar is another

00:16:49,870 --> 00:16:55,270
excellent Java library which has a bunch

00:16:52,029 --> 00:16:57,850
of utilities and even the Java n io path

00:16:55,270 --> 00:16:59,550
and file utils I just made a giant list

00:16:57,850 --> 00:17:02,020
of them I literally printed them

00:16:59,550 --> 00:17:06,819
checkmark and move them to a1 say okay

00:17:02,020 --> 00:17:07,990
this is my feature set and another thing

00:17:06,819 --> 00:17:09,959
is like I didn't want any external

00:17:07,990 --> 00:17:12,370
dependencies I just wanted to depend on

00:17:09,959 --> 00:17:15,579
the the Scala standard library Java

00:17:12,370 --> 00:17:17,559
standard library this is another thing

00:17:15,579 --> 00:17:20,079
so when I wanted to implement this

00:17:17,559 --> 00:17:21,040
interface I did not want to do a lot of

00:17:20,079 --> 00:17:23,079
things myself

00:17:21,040 --> 00:17:26,140
I wanted to delegate everything to Java

00:17:23,079 --> 00:17:28,449
niño but wrap it around in a safe

00:17:26,140 --> 00:17:31,030
package so you when you actually call

00:17:28,449 --> 00:17:33,550
copy here it doesn't throw a directory

00:17:31,030 --> 00:17:36,390
not empty exception or something it will

00:17:33,550 --> 00:17:38,890
work as you expect you think it work

00:17:36,390 --> 00:17:41,290
also I didn't want to introduce a lot of

00:17:38,890 --> 00:17:42,730
new classes like every time I use Java I

00:17:41,290 --> 00:17:45,309
don't know bufferedreader

00:17:42,730 --> 00:17:47,590
the output stream writer versus reader

00:17:45,309 --> 00:17:50,740
and print writer there's like 50 of them

00:17:47,590 --> 00:17:52,929
I don't know which one to use that

00:17:50,740 --> 00:17:54,490
that's not the case in better files you

00:17:52,929 --> 00:17:56,679
should be able to have just one file for

00:17:54,490 --> 00:17:57,700
us that should do everything or one path

00:17:56,679 --> 00:18:01,870
class that should be able to do

00:17:57,700 --> 00:18:03,790
everything and we would use implicit to

00:18:01,870 --> 00:18:06,010
add capabilities to this one file class

00:18:03,790 --> 00:18:08,770
it started out historically as implicit

00:18:06,010 --> 00:18:10,600
added to Java dot IO dot file but then

00:18:08,770 --> 00:18:12,280
we realized that no one actually wants

00:18:10,600 --> 00:18:14,679
Java dot IO dot file they look like a

00:18:12,280 --> 00:18:16,780
Scala one so this is a Scala file class

00:18:14,679 --> 00:18:18,790
but there is a low priority implicit you

00:18:16,780 --> 00:18:21,040
can import which it convert between the

00:18:18,790 --> 00:18:24,190
Scala one and the Java one if you do

00:18:21,040 --> 00:18:25,750
want to use a Java and yeah just I

00:18:24,190 --> 00:18:27,940
mentioned this before I didn't want any

00:18:25,750 --> 00:18:31,179
surprises like if you I showed you the

00:18:27,940 --> 00:18:32,799
API signature and no documentation and

00:18:31,179 --> 00:18:41,590
asked you what do you think it would

00:18:32,799 --> 00:18:42,760
have do you'd probably correct this is

00:18:41,590 --> 00:18:46,419
another thing that I have been striving

00:18:42,760 --> 00:18:49,630
to get at I haven't quite reached there

00:18:46,419 --> 00:18:51,160
for version 3 this will be there so what

00:18:49,630 --> 00:18:54,429
I mean about this is like you should not

00:18:51,160 --> 00:18:58,150
be able to write a string to a directory

00:18:54,429 --> 00:19:01,000
and well if you try to do it in Java

00:18:58,150 --> 00:19:02,350
this is you get an exception the

00:19:01,000 --> 00:19:03,730
question is this is an open question I

00:19:02,350 --> 00:19:05,559
have some designs for it this is a

00:19:03,730 --> 00:19:07,660
future work it's like how do you do it

00:19:05,559 --> 00:19:11,440
in Scala so that you can catch it at

00:19:07,660 --> 00:19:13,270
compile time and you can you can you can

00:19:11,440 --> 00:19:14,380
have a class hierarchy for different

00:19:13,270 --> 00:19:17,020
kinds of files a regular file a

00:19:14,380 --> 00:19:18,669
directory or a symbolic link and which

00:19:17,020 --> 00:19:20,260
would have different operations that

00:19:18,669 --> 00:19:22,299
lets you you can't even call dot write

00:19:20,260 --> 00:19:25,720
on a directory but you sacrifice a

00:19:22,299 --> 00:19:27,510
little bit of simplicity in the code you

00:19:25,720 --> 00:19:30,309
might have to write a match you may not

00:19:27,510 --> 00:19:32,230
so I will go over that later when I'll

00:19:30,309 --> 00:19:35,860
show you the examples as how you want to

00:19:32,230 --> 00:19:38,440
prevent it at compile time and we want

00:19:35,860 --> 00:19:40,750
automatic resource management we don't

00:19:38,440 --> 00:19:42,940
want to what happens if you forget to

00:19:40,750 --> 00:19:46,210
close a file handler or some output

00:19:42,940 --> 00:19:48,610
stream or input stream you want things

00:19:46,210 --> 00:19:51,000
to be closed by default and a couple of

00:19:48,610 --> 00:19:54,190
clever ways better file achieves that

00:19:51,000 --> 00:19:56,120
one by I didn't want to say the M word

00:19:54,190 --> 00:19:58,799
one by using a monad

00:19:56,120 --> 00:20:00,570
you get a traversable where I override

00:19:58,799 --> 00:20:02,309
the 40 for each so when it's done it

00:20:00,570 --> 00:20:04,350
players itself

00:20:02,309 --> 00:20:05,910
I also added implicit Stu the Java

00:20:04,350 --> 00:20:08,400
stream classes so when you finish

00:20:05,910 --> 00:20:10,919
iterating over the stream it will auto

00:20:08,400 --> 00:20:12,270
close the stream for you what happens if

00:20:10,919 --> 00:20:15,840
you don't finish iterating the stream it

00:20:12,270 --> 00:20:20,450
will leave the stream open I'll go over

00:20:15,840 --> 00:20:22,500
that do and you want configurable

00:20:20,450 --> 00:20:24,179
configurability for example as the

00:20:22,500 --> 00:20:26,100
examples I mentioned you want custom

00:20:24,179 --> 00:20:27,630
open options you want to open the file

00:20:26,100 --> 00:20:30,330
in a read role any mode or write only

00:20:27,630 --> 00:20:31,500
mode read write mode or custom link

00:20:30,330 --> 00:20:35,909
options you want to follow a symbolic

00:20:31,500 --> 00:20:39,240
link or not you want to find be able to

00:20:35,909 --> 00:20:40,679
use custom code xhy utf-8 utf-16 but

00:20:39,240 --> 00:20:42,630
then you don't want the method signature

00:20:40,679 --> 00:20:44,429
to be like this long and you have to

00:20:42,630 --> 00:20:47,400
fill in like five things to write a file

00:20:44,429 --> 00:20:49,440
so even though the signature is that

00:20:47,400 --> 00:20:52,500
long most of them have same default

00:20:49,440 --> 00:20:56,130
arguments I try to follow the default of

00:20:52,500 --> 00:20:56,610
Java like if you did just do files start

00:20:56,130 --> 00:20:59,159
a band

00:20:56,610 --> 00:21:01,740
it would have expanded in the operating

00:20:59,159 --> 00:21:03,150
system's default cache said it would not

00:21:01,740 --> 00:21:05,250
have followed it would have followed

00:21:03,150 --> 00:21:07,530
symlink so on and so forth but you can

00:21:05,250 --> 00:21:10,710
override all of those is in the default

00:21:07,530 --> 00:21:13,140
argument section good test coverage this

00:21:10,710 --> 00:21:14,940
is obvious there's a CI build it goes

00:21:13,140 --> 00:21:16,950
and creates a test report and you can

00:21:14,940 --> 00:21:19,909
see what line or what

00:21:16,950 --> 00:21:23,159
which lines are covered documentation I

00:21:19,909 --> 00:21:28,620
this this top motivated me to improve

00:21:23,159 --> 00:21:29,970
the documentation so that's good yeah

00:21:28,620 --> 00:21:33,120
this is another thing I didn't want it

00:21:29,970 --> 00:21:34,650
to be slower than Java should be as fast

00:21:33,120 --> 00:21:37,110
as Java I have a little star there

00:21:34,650 --> 00:21:39,360
because I'd go over one case where it's

00:21:37,110 --> 00:21:41,370
about eight times faster than Java but

00:21:39,360 --> 00:21:44,850
most of the cases are the rest of the

00:21:41,370 --> 00:21:46,770
cases with as fast as Java and this is

00:21:44,850 --> 00:21:47,820
this has been alluded to like the

00:21:46,770 --> 00:21:49,620
probably the third time in this

00:21:47,820 --> 00:21:52,140
conference martin also mentioned it this

00:21:49,620 --> 00:21:55,080
is like Howie's article about the

00:21:52,140 --> 00:21:59,640
principle of least power so here prints

00:21:55,080 --> 00:22:01,860
the least power is Java so I don't want

00:21:59,640 --> 00:22:04,679
the core to introduce any brand new

00:22:01,860 --> 00:22:07,530
concepts or techniques I just wanted the

00:22:04,679 --> 00:22:09,700
core to be a simple wrapper around Java

00:22:07,530 --> 00:22:11,679
and IO so the core

00:22:09,700 --> 00:22:14,139
you this might make most of you unhappy

00:22:11,679 --> 00:22:16,720
in this room the core is not reactive

00:22:14,139 --> 00:22:19,090
not monadic nor effect based not pure it

00:22:16,720 --> 00:22:22,299
just calls Java dot niño wraps around it

00:22:19,090 --> 00:22:24,639
covers corner cases for you and that

00:22:22,299 --> 00:22:27,669
doesn't mean that you sacrifice all

00:22:24,639 --> 00:22:29,590
these things all these nice things there

00:22:27,669 --> 00:22:33,639
are upstream libraries built on top of

00:22:29,590 --> 00:22:35,620
the core which does does introduce new

00:22:33,639 --> 00:22:37,600
concepts so there's a file watcher so

00:22:35,620 --> 00:22:39,899
the default file watcher is a blocking

00:22:37,600 --> 00:22:42,250
thread based file watcher but there is a

00:22:39,899 --> 00:22:44,919
library built on top of better files

00:22:42,250 --> 00:22:47,200
which is uses akka so it's a reactive

00:22:44,919 --> 00:22:48,850
file watcher you can attach callbacks to

00:22:47,200 --> 00:22:51,370
the attach callbacks monitor you get all

00:22:48,850 --> 00:22:53,019
the archive goodies similarly for

00:22:51,370 --> 00:22:56,169
scanner if you're familiar with scanner

00:22:53,019 --> 00:22:58,149
at all it's loves inputs right now it's

00:22:56,169 --> 00:23:01,750
just the only thing you can get is like

00:22:58,149 --> 00:23:04,149
basic strings and ends but there's a

00:23:01,750 --> 00:23:06,190
shapeless scanner you can say like I

00:23:04,149 --> 00:23:08,230
want to read this H list from my input

00:23:06,190 --> 00:23:09,850
and it will you'll get back that H list

00:23:08,230 --> 00:23:13,049
and again that's not part of the core

00:23:09,850 --> 00:23:16,269
libraries built on top of better files

00:23:13,049 --> 00:23:18,970
so as I said this dog gave me a

00:23:16,269 --> 00:23:21,039
motivation to improve the documentation

00:23:18,970 --> 00:23:23,440
and literally going to spend some few

00:23:21,039 --> 00:23:26,429
minutes going over the dots on github to

00:23:23,440 --> 00:23:26,429
give you a tour of the API

00:23:42,539 --> 00:23:45,199
okay

00:23:46,720 --> 00:23:54,400
so yeah this is the github page and we

00:23:51,130 --> 00:23:58,210
have there's a tutorial here as I said

00:23:54,400 --> 00:24:00,640
this is the SBT you can add it to this

00:23:58,210 --> 00:24:02,680
how you add better files and these are

00:24:00,640 --> 00:24:04,270
one example of an upstream integration

00:24:02,680 --> 00:24:05,410
if you want to get the akka best file

00:24:04,270 --> 00:24:07,240
monitor you need to add another

00:24:05,410 --> 00:24:10,150
dependency so this one does bring in

00:24:07,240 --> 00:24:13,990
akka for you but by default this has no

00:24:10,150 --> 00:24:15,910
external dependencies so yeah so let's

00:24:13,990 --> 00:24:20,530
look at how do you actually create a

00:24:15,910 --> 00:24:21,880
file so the most easy way is to just

00:24:20,530 --> 00:24:25,710
pass in a string to this file

00:24:21,880 --> 00:24:28,150
constructor so here you might see that

00:24:25,710 --> 00:24:30,730
this file is actually the scala one the

00:24:28,150 --> 00:24:33,580
better files one and I renamed the Java

00:24:30,730 --> 00:24:35,260
one to J file but some people don't like

00:24:33,580 --> 00:24:37,300
that you can go the other way you can

00:24:35,260 --> 00:24:40,240
rename the Scala one discover file and

00:24:37,300 --> 00:24:42,580
use the Java dot IO dot file but for the

00:24:40,240 --> 00:24:44,800
rest of the this this talk or this

00:24:42,580 --> 00:24:47,740
president this tutorial when you see

00:24:44,800 --> 00:24:50,350
file it means the Scala one and if you

00:24:47,740 --> 00:24:51,430
see J file it means the Java one and

00:24:50,350 --> 00:24:53,350
there are a bunch of other ways you can

00:24:51,430 --> 00:24:56,740
stand she ate it you can use a string

00:24:53,350 --> 00:24:58,930
interpolator it adds some in implicit

00:24:56,740 --> 00:25:01,900
stew the Java one so you can just do dot

00:24:58,930 --> 00:25:04,300
two scholar and get the Scala one from

00:25:01,900 --> 00:25:05,860
the Java and there's some BS else Britt

00:25:04,300 --> 00:25:08,290
with like the front slash operator

00:25:05,860 --> 00:25:10,840
it's just binary operator which you can

00:25:08,290 --> 00:25:13,420
use to go up to particular directory is

00:25:10,840 --> 00:25:15,340
this one lets you go up and this tilde

00:25:13,420 --> 00:25:22,200
is the home directory so there's all

00:25:15,340 --> 00:25:24,700
kinds of nice little DSL in it so and

00:25:22,200 --> 00:25:26,680
this is the most basic thing when

00:25:24,700 --> 00:25:28,810
someone's talking about IO is how do I

00:25:26,680 --> 00:25:31,300
read and write a file it's pretty easy

00:25:28,810 --> 00:25:34,960
you get a file you can do all kinds of

00:25:31,300 --> 00:25:39,220
pen line app and override that's little

00:25:34,960 --> 00:25:41,830
pure fan of using symbols you can I

00:25:39,220 --> 00:25:43,750
don't recommend it but can you use write

00:25:41,830 --> 00:25:45,790
and appends so on and so forth and

00:25:43,750 --> 00:25:50,010
there's some write associative symbols

00:25:45,790 --> 00:25:54,610
too with using the colon so most of the

00:25:50,010 --> 00:25:56,430
actually all the api's return the file

00:25:54,610 --> 00:25:58,810
itself or let's say if you're copying

00:25:56,430 --> 00:26:00,880
from source to destination it returns

00:25:58,810 --> 00:26:03,610
the destination all the API

00:26:00,880 --> 00:26:06,250
so this lets you write very fluent code

00:26:03,610 --> 00:26:08,590
so here I'm creating a file create if

00:26:06,250 --> 00:26:10,360
not exists appending a line spending a

00:26:08,590 --> 00:26:12,430
bunch of other lines moving it to My

00:26:10,360 --> 00:26:14,950
Documents renaming it changing this

00:26:12,430 --> 00:26:16,420
diction and reading the line spec so

00:26:14,950 --> 00:26:18,880
I'll go with this later this lines

00:26:16,420 --> 00:26:22,750
returns even there it has an iterator of

00:26:18,880 --> 00:26:24,340
strings it's a self closing a trader so

00:26:22,750 --> 00:26:26,680
if you finish iterating over it it will

00:26:24,340 --> 00:26:30,130
close the file for you or if you do dot

00:26:26,680 --> 00:26:32,530
to left or dot to stream or or dot to

00:26:30,130 --> 00:26:34,420
let's start out to seek it will close

00:26:32,530 --> 00:26:36,970
the it will get rid over the files and

00:26:34,420 --> 00:26:39,300
close the stream for you but if you

00:26:36,970 --> 00:26:41,650
iterate halfway through the file and

00:26:39,300 --> 00:26:44,500
leave it at it and move on it will not

00:26:41,650 --> 00:26:45,700
close the file handler for you and for

00:26:44,500 --> 00:26:49,780
those cases just another way of doing

00:26:45,700 --> 00:26:51,670
things we'll go over it later and yeah

00:26:49,780 --> 00:26:58,450
this is the streaming API so if you just

00:26:51,670 --> 00:27:00,340
don't want good in this case if you just

00:26:58,450 --> 00:27:01,810
don't want the text you want a stream

00:27:00,340 --> 00:27:04,360
you get an iterator these are self

00:27:01,810 --> 00:27:06,070
closing iterators and it does have some

00:27:04,360 --> 00:27:08,170
facilities to get back the Scarlett or

00:27:06,070 --> 00:27:12,070
diode or source classes so you can do

00:27:08,170 --> 00:27:13,930
this and you can again write iterate as

00:27:12,070 --> 00:27:16,480
back into the file this is the byte one

00:27:13,930 --> 00:27:19,810
and this is the print Alliance this is

00:27:16,480 --> 00:27:22,180
an example where the thing I was talking

00:27:19,810 --> 00:27:24,610
about it's configurable so you can just

00:27:22,180 --> 00:27:26,550
call dot write and skip this part it

00:27:24,610 --> 00:27:29,530
will write hello work but if you use the

00:27:26,550 --> 00:27:31,750
whatever the default care status which

00:27:29,530 --> 00:27:34,960
is usually utf-8 but you can give it a

00:27:31,750 --> 00:27:37,510
custom codec you can you give a pass in

00:27:34,960 --> 00:27:39,520
Scarborough dot codec or you can pass in

00:27:37,510 --> 00:27:42,730
Java dot IO dot car set that's implicit

00:27:39,520 --> 00:27:45,190
converter between those two you can also

00:27:42,730 --> 00:27:46,690
import the this implicit from that this

00:27:45,190 --> 00:27:48,940
is all from the standard library this is

00:27:46,690 --> 00:27:50,500
called I or got codec the string to

00:27:48,940 --> 00:27:54,190
codec and you can say hey I want to use

00:27:50,500 --> 00:27:55,510
a custom codec us - Rast I this might

00:27:54,190 --> 00:27:57,790
give you runtime exceptions if the

00:27:55,510 --> 00:28:01,330
codecs not installed Java says if you I

00:27:57,790 --> 00:28:02,680
don't know how to parse this codec but

00:28:01,330 --> 00:28:04,510
yeah this is this is a lot of

00:28:02,680 --> 00:28:06,820
configuration and this is not the only

00:28:04,510 --> 00:28:08,800
default parameters is about five of them

00:28:06,820 --> 00:28:12,160
and I'll go over those in the Scala docs

00:28:08,800 --> 00:28:14,690
you can open this file and tell it how

00:28:12,160 --> 00:28:17,190
to process symlinks and so on

00:28:14,690 --> 00:28:18,960
and this is the part where I mention we

00:28:17,190 --> 00:28:21,480
have to deal with a Java baggage like

00:28:18,960 --> 00:28:23,970
the Java has this is not even it that's

00:28:21,480 --> 00:28:26,820
50 of these things bufferedreader output

00:28:23,970 --> 00:28:28,559
stream file system random access file

00:28:26,820 --> 00:28:29,610
file reader file writer print writer

00:28:28,559 --> 00:28:33,929
writer reader

00:28:29,610 --> 00:28:35,669
Java and you don't have to ever Google

00:28:33,929 --> 00:28:38,520
like how do I get one of these things

00:28:35,669 --> 00:28:40,440
given a file they're all built in your

00:28:38,520 --> 00:28:43,470
ID should be able to start suggested

00:28:40,440 --> 00:28:46,230
it's in the color dogs you should or

00:28:43,470 --> 00:28:47,880
just go for new and give it this name

00:28:46,230 --> 00:28:50,280
and you should be able to get that thing

00:28:47,880 --> 00:28:53,309
back and again most of these things

00:28:50,280 --> 00:28:55,410
takes in more three or four arguments

00:28:53,309 --> 00:28:57,240
they all have same default arguments so

00:28:55,410 --> 00:28:58,679
most of the time you don't want to worry

00:28:57,240 --> 00:29:01,049
about it but let's say you didn't want

00:28:58,679 --> 00:29:03,000
to open a file channel with an offset of

00:29:01,049 --> 00:29:06,120
100 bytes you can pass an offset equal

00:29:03,000 --> 00:29:11,640
200 bytes right here by but by default

00:29:06,120 --> 00:29:13,590
it would open at offset 0 and same for

00:29:11,640 --> 00:29:16,919
this that's implicit conversions between

00:29:13,590 --> 00:29:18,360
any of the Java I of libraries that

00:29:16,919 --> 00:29:21,030
could be converted to another Java or

00:29:18,360 --> 00:29:22,230
library when I simplistic conversions

00:29:21,030 --> 00:29:24,990
they're not implicitly converted for you

00:29:22,230 --> 00:29:27,600
there are methods added to these classes

00:29:24,990 --> 00:29:29,460
which lets you convert them so given

00:29:27,600 --> 00:29:31,290
let's say you did get an input stream

00:29:29,460 --> 00:29:33,120
and you want to convert it into a

00:29:31,290 --> 00:29:34,950
buffered input stream so this dot

00:29:33,120 --> 00:29:37,020
buffered is added to the inputs Java

00:29:34,950 --> 00:29:40,020
input stream class so you can do all

00:29:37,020 --> 00:29:43,830
kinds of conversions again all of these

00:29:40,020 --> 00:29:45,510
have converged method parameters that I

00:29:43,830 --> 00:29:47,220
didn't document that I didn't display

00:29:45,510 --> 00:29:48,660
here but they all taken all kinds of

00:29:47,220 --> 00:29:51,390
configurations and they all have

00:29:48,660 --> 00:29:54,809
defaults so this code all of these

00:29:51,390 --> 00:29:59,250
compiles I'm using that to compile my

00:29:54,809 --> 00:30:02,490
documentation so this is the thing that

00:29:59,250 --> 00:30:05,970
I was alluding to about the compile time

00:30:02,490 --> 00:30:11,030
safety of operations so you can use

00:30:05,970 --> 00:30:14,070
pattern matching to get to get a nice

00:30:11,030 --> 00:30:16,290
nice syntax for example I want to check

00:30:14,070 --> 00:30:18,210
if a file is empty so I want to do this

00:30:16,290 --> 00:30:19,980
so if it's a symlink check of the

00:30:18,210 --> 00:30:21,750
destination of the Simulink is empty if

00:30:19,980 --> 00:30:22,799
it's a directory check if the directory

00:30:21,750 --> 00:30:24,809
is empty which is I don't have any

00:30:22,799 --> 00:30:26,460
children if it's a final check if it has

00:30:24,809 --> 00:30:29,220
0 bytes file

00:30:26,460 --> 00:30:30,929
so you can use this pattern matcher so

00:30:29,220 --> 00:30:32,789
filed our Tiber symbol explained it

00:30:30,929 --> 00:30:35,309
gives you it unn applies to the

00:30:32,789 --> 00:30:37,289
destination the directory unup lies to

00:30:35,309 --> 00:30:41,190
the list of children or direct children

00:30:37,289 --> 00:30:44,159
not it's recursive children and this is

00:30:41,190 --> 00:30:48,059
just a regular file a pattern matches to

00:30:44,159 --> 00:30:50,159
an iterator of bite and you can do

00:30:48,059 --> 00:30:51,419
whatever you want and these are not the

00:30:50,159 --> 00:30:53,399
only three kinds of files that are

00:30:51,419 --> 00:30:56,519
possible believe it or not you can have

00:30:53,399 --> 00:30:59,070
UNIX processes pipes so on those are

00:30:56,519 --> 00:31:00,419
modeled as files in the UNIX system so

00:30:59,070 --> 00:31:01,730
but they're not exposed

00:31:00,419 --> 00:31:05,519
you just have to handle them one by one

00:31:01,730 --> 00:31:07,409
so and of course if you're familiar with

00:31:05,519 --> 00:31:09,269
the scholar you probably notice that you

00:31:07,409 --> 00:31:11,549
can also use extract s on the right hand

00:31:09,269 --> 00:31:13,049
side on the left hand side so here I

00:31:11,549 --> 00:31:14,519
have some file on the right and some

00:31:13,049 --> 00:31:16,830
other direction on the right hand side

00:31:14,519 --> 00:31:20,610
I'm using pattern matching to get all

00:31:16,830 --> 00:31:24,360
the children under this directory so

00:31:20,610 --> 00:31:25,799
that's a nice trick you can use again it

00:31:24,360 --> 00:31:27,659
has all these utils for if you're

00:31:25,799 --> 00:31:30,360
familiar with Python our shell that you

00:31:27,659 --> 00:31:33,389
can do this syntax of globbing this

00:31:30,360 --> 00:31:35,700
finds all the Java and Scala files you

00:31:33,389 --> 00:31:39,330
can use some other syntax you can pass

00:31:35,700 --> 00:31:42,799
in some regex and tax to do this to glob

00:31:39,330 --> 00:31:47,309
and these are again strongly tab you can

00:31:42,799 --> 00:31:53,190
pass in some weird and some random

00:31:47,309 --> 00:31:55,440
syntax are self supported all right so

00:31:53,190 --> 00:31:56,940
these are the file system operations are

00:31:55,440 --> 00:31:59,399
talking about so these are things like

00:31:56,940 --> 00:32:03,299
touch which updates the last update time

00:31:59,399 --> 00:32:05,669
delete clear rename move copy you can

00:32:03,299 --> 00:32:09,769
create a new symbolic link these are all

00:32:05,669 --> 00:32:13,499
the checksum you can compute md5 sha-1

00:32:09,769 --> 00:32:17,039
sha-512 set of owner set group you can

00:32:13,499 --> 00:32:20,429
use the write associative operators to

00:32:17,039 --> 00:32:23,190
this is kind of inspired by the cat I

00:32:20,429 --> 00:32:24,600
don't recommend using operators unless

00:32:23,190 --> 00:32:26,999
this one this one's I think is

00:32:24,600 --> 00:32:29,039
reasonable sorry not this particular one

00:32:26,999 --> 00:32:32,519
but for using the forward slash for

00:32:29,039 --> 00:32:35,070
going into children and it has the some

00:32:32,519 --> 00:32:37,710
nice little temporary file and temporary

00:32:35,070 --> 00:32:39,539
directory utils so all of these as I

00:32:37,710 --> 00:32:40,179
mentioned before our fluent they return

00:32:39,539 --> 00:32:42,429
the file

00:32:40,179 --> 00:32:43,869
unless it's this one so it has moved to

00:32:42,429 --> 00:32:46,149
destination or tells the destination

00:32:43,869 --> 00:32:48,190
instead of the source so you can chain

00:32:46,149 --> 00:32:52,389
these things if you want it looks pretty

00:32:48,190 --> 00:32:55,269
nice so this is kind of inspired by the

00:32:52,389 --> 00:32:57,070
ammonite ops library so if you want to

00:32:55,269 --> 00:33:01,509
look your make your code look like Yonex

00:32:57,070 --> 00:33:04,450
you can import this commands package it

00:33:01,509 --> 00:33:06,639
just gives you a nice way of calling

00:33:04,450 --> 00:33:08,799
file dot touch they were calling filer

00:33:06,639 --> 00:33:11,169
touch but you can just make it look like

00:33:08,799 --> 00:33:13,389
some unix commands you're familiar with

00:33:11,169 --> 00:33:14,710
there's way more of this it's about 50

00:33:13,389 --> 00:33:16,570
of these I didn't get time to document

00:33:14,710 --> 00:33:21,519
all of them here in the readme but can

00:33:16,570 --> 00:33:24,070
read this color dock so this is the

00:33:21,519 --> 00:33:27,330
attributes API so things like name

00:33:24,070 --> 00:33:30,399
extensions so if you actually try to get

00:33:27,330 --> 00:33:32,409
name in Java you think it's gonna be

00:33:30,399 --> 00:33:34,119
simple is this file surname but it

00:33:32,409 --> 00:33:36,820
actually does some weird stuff like if

00:33:34,119 --> 00:33:38,909
returns null if you're the name if it's

00:33:36,820 --> 00:33:41,440
a root file the root directory and

00:33:38,909 --> 00:33:43,029
extension it returns now if it doesn't

00:33:41,440 --> 00:33:45,539
have any extension or something that so

00:33:43,029 --> 00:33:47,679
these are all type safe so name returns

00:33:45,539 --> 00:33:49,629
empty string and there's also name

00:33:47,679 --> 00:33:51,700
option which should return none for

00:33:49,629 --> 00:33:54,279
roots and some string for every other

00:33:51,700 --> 00:33:56,289
file same for extension it returns an

00:33:54,279 --> 00:33:58,240
option string and again you can pass in

00:33:56,289 --> 00:33:59,860
a bunch of parameters to extension

00:33:58,240 --> 00:34:01,600
there's like six parameters extension so

00:33:59,860 --> 00:34:03,580
why would you need six parameters to do

00:34:01,600 --> 00:34:05,950
extension so if you have a file like dot

00:34:03,580 --> 00:34:07,210
scholar dot HTML do you want dot HTML or

00:34:05,950 --> 00:34:09,250
do you want the whole part how many

00:34:07,210 --> 00:34:10,599
parts do you want do you want the dot or

00:34:09,250 --> 00:34:12,819
do you not what the dot those are all

00:34:10,599 --> 00:34:14,260
configurable as deep but the default

00:34:12,819 --> 00:34:16,929
arguments are not shown here you can

00:34:14,260 --> 00:34:22,329
read in scholar doc same for this last

00:34:16,929 --> 00:34:26,889
modified time this returns Java 310 Java

00:34:22,329 --> 00:34:29,109
instance so and so forth so it's the

00:34:26,889 --> 00:34:30,909
size is interesting it actually works

00:34:29,109 --> 00:34:33,040
for directories if you come calculate

00:34:30,909 --> 00:34:34,899
you call file that size on a directory

00:34:33,040 --> 00:34:36,700
it would just get back the size of the

00:34:34,899 --> 00:34:39,990
i/o node which is like four bikes or

00:34:36,700 --> 00:34:42,460
something in Java but this actually

00:34:39,990 --> 00:34:44,589
gives you an option do you want the I on

00:34:42,460 --> 00:34:46,210
outside is going to be as big as four

00:34:44,589 --> 00:34:48,129
clover it's all the time or do you want

00:34:46,210 --> 00:34:51,790
the recursive size of the directory or

00:34:48,129 --> 00:34:53,260
so how much depth you want is empty use

00:34:51,790 --> 00:34:54,109
example I showed about you can get all

00:34:53,260 --> 00:34:55,940
the POSIX

00:34:54,109 --> 00:34:58,220
the dog attributes and there are some

00:34:55,940 --> 00:34:59,630
nice little tree operations you can do

00:34:58,220 --> 00:35:00,950
we can check if it's a parent or

00:34:59,630 --> 00:35:03,650
something sibling or something get

00:35:00,950 --> 00:35:07,009
siblings I don't know grandchildren or

00:35:03,650 --> 00:35:10,309
grand siblings or something and that's

00:35:07,009 --> 00:35:18,650
another example of so this link option

00:35:10,309 --> 00:35:20,150
is well so this link option is it's not

00:35:18,650 --> 00:35:21,680
something I invented this is from Java

00:35:20,150 --> 00:35:25,279
and I ordered link option and you can

00:35:21,680 --> 00:35:27,499
give when you do is directory and you're

00:35:25,279 --> 00:35:29,089
asking a symlink if it's a directory or

00:35:27,499 --> 00:35:30,410
not do you actually mean that similarly

00:35:29,089 --> 00:35:32,059
it's a directory or the target of the

00:35:30,410 --> 00:35:36,109
something is a directory so you can

00:35:32,059 --> 00:35:38,720
fasten the link option and this is also

00:35:36,109 --> 00:35:41,029
so this is if you want to pass in the

00:35:38,720 --> 00:35:43,009
more job the exact Java instance or you

00:35:41,029 --> 00:35:46,549
can pass in the Scala one which is

00:35:43,009 --> 00:35:48,410
slightly more code style wise better I

00:35:46,549 --> 00:35:50,569
get doesn't do this all caps thing and

00:35:48,410 --> 00:35:55,609
underscore so but they are the same

00:35:50,569 --> 00:35:57,470
thing this again example if jamar you

00:35:55,609 --> 00:35:58,880
can do add permission remove formation

00:35:57,470 --> 00:36:01,099
this Pizitz file permission you can add

00:35:58,880 --> 00:36:05,150
an invented this is from Java dot IO and

00:36:01,099 --> 00:36:07,489
it also has better files equivalent so

00:36:05,150 --> 00:36:10,730
which to read which follows Scala code

00:36:07,489 --> 00:36:12,769
style so again camel K is no uppercase

00:36:10,730 --> 00:36:17,809
things like that but you can also pass

00:36:12,769 --> 00:36:19,910
in the Java one so file comparison I

00:36:17,809 --> 00:36:21,739
again I would not recommend you to use

00:36:19,910 --> 00:36:24,230
double equals what does it mean file

00:36:21,739 --> 00:36:26,509
equal to equal to file to but actually

00:36:24,230 --> 00:36:28,789
this it what it does is cause checks if

00:36:26,509 --> 00:36:30,769
the two files are the same path and the

00:36:28,789 --> 00:36:31,880
triple equals checks at the same the

00:36:30,769 --> 00:36:33,349
files are the same content

00:36:31,880 --> 00:36:34,700
it works for directories also it would

00:36:33,349 --> 00:36:36,920
recursively check the directory

00:36:34,700 --> 00:36:38,089
structure but again like someone else

00:36:36,920 --> 00:36:39,529
reading the code doesn't know where

00:36:38,089 --> 00:36:41,480
double equal and triple equal means so I

00:36:39,529 --> 00:36:45,559
would recommend use same content as same

00:36:41,480 --> 00:36:47,450
path s and same for the Nords but I know

00:36:45,559 --> 00:36:51,829
some of you love symbol so that symbols

00:36:47,450 --> 00:36:54,079
for you and there so when you're listing

00:36:51,829 --> 00:36:57,650
files you have the option to pass in

00:36:54,079 --> 00:36:59,539
custom ordering I know you can do it in

00:36:57,650 --> 00:37:00,769
scholar you can do sort by but these are

00:36:59,539 --> 00:37:02,930
the things that are available down at

00:37:00,769 --> 00:37:04,849
the operating system level also so there

00:37:02,930 --> 00:37:07,700
are some default orders built in you can

00:37:04,849 --> 00:37:11,359
write your own so there's you can order

00:37:07,700 --> 00:37:14,450
name by size by how by modification time

00:37:11,359 --> 00:37:17,030
you want the first one the most recently

00:37:14,450 --> 00:37:19,040
updated one before or after or by

00:37:17,030 --> 00:37:21,710
directories first or by directories law

00:37:19,040 --> 00:37:24,440
so that's gospel of ordering freaking

00:37:21,710 --> 00:37:26,119
fast and also when you are listing and

00:37:24,440 --> 00:37:30,200
zip you don't have to depend on any zip

00:37:26,119 --> 00:37:33,470
api's this works so it's trivial if you

00:37:30,200 --> 00:37:35,270
have a zip file you can just say unzip

00:37:33,470 --> 00:37:37,220
to and you don't even have to pass in

00:37:35,270 --> 00:37:39,440
the destination by default it unzips to

00:37:37,220 --> 00:37:41,810
a temporary directory and returns you

00:37:39,440 --> 00:37:44,089
that directory I might have used it

00:37:41,810 --> 00:37:45,500
somewhere yeah this is the one so you

00:37:44,089 --> 00:37:50,960
don't even have to pass in destination

00:37:45,500 --> 00:37:53,660
same for zip you you don't have to say

00:37:50,960 --> 00:37:55,880
what's my destination you can here I do

00:37:53,660 --> 00:37:57,950
I said ok put it in my desktop but again

00:37:55,880 --> 00:38:01,700
it returns for temporary zip file so you

00:37:57,950 --> 00:38:04,430
can do all that things it helps I

00:38:01,700 --> 00:38:08,810
support for gun zip this is an example

00:38:04,430 --> 00:38:11,060
you can how simple is to parse it this

00:38:08,810 --> 00:38:18,290
thing will be like 100 lines of code in

00:38:11,060 --> 00:38:21,500
Java this is the part where better fast

00:38:18,290 --> 00:38:23,240
does resource management for you so it

00:38:21,500 --> 00:38:26,510
doesn't leave file handlers and strings

00:38:23,240 --> 00:38:29,150
open or tries not to so all the things

00:38:26,510 --> 00:38:31,670
so this is kind this is a little bit of

00:38:29,150 --> 00:38:33,260
dark magic because it looks at the

00:38:31,670 --> 00:38:35,960
structural type and sees if there is a

00:38:33,260 --> 00:38:39,109
closed unit on the Java class and it

00:38:35,960 --> 00:38:43,099
adds implicit to it called auto closed

00:38:39,109 --> 00:38:44,630
which returns traversable you don't need

00:38:43,099 --> 00:38:46,010
to know that implementation details

00:38:44,630 --> 00:38:48,410
about pretty much anything that has a

00:38:46,010 --> 00:38:50,720
dot closed in Java you can call dot Auto

00:38:48,410 --> 00:38:52,849
closed and you get back a traversable at

00:38:50,720 --> 00:38:54,890
the end of which at the end of the 4h it

00:38:52,849 --> 00:39:00,170
closes the string for you so you can

00:38:54,890 --> 00:39:02,540
read this in this syntax same for like

00:39:00,170 --> 00:39:04,390
all the things is another example and if

00:39:02,540 --> 00:39:07,220
you don't always want to write dot new

00:39:04,390 --> 00:39:08,720
Java class dot Auto closed there's a

00:39:07,220 --> 00:39:10,640
shortcut for it you can just start you

00:39:08,720 --> 00:39:12,230
can skip the new skip the order close

00:39:10,640 --> 00:39:14,960
then just write bufferedreader or input

00:39:12,230 --> 00:39:17,060
stream it would it would return this

00:39:14,960 --> 00:39:20,109
managed resource this is basically a

00:39:17,060 --> 00:39:24,999
monad on bufferedreader and you can

00:39:20,109 --> 00:39:27,160
map and flatmap over egg so yeah this

00:39:24,999 --> 00:39:30,219
thing is safe this will close the stream

00:39:27,160 --> 00:39:32,859
for you once the reader is done fold and

00:39:30,219 --> 00:39:35,619
once this thing execute and the only

00:39:32,859 --> 00:39:37,779
caveat is again this has to traverse

00:39:35,619 --> 00:39:39,039
like let's say for a some like halfway

00:39:37,779 --> 00:39:47,769
through this food throws an exception

00:39:39,039 --> 00:39:50,589
you would leave a 500 over this is this

00:39:47,769 --> 00:39:52,209
is an example of how to write you know

00:39:50,589 --> 00:39:54,009
you can write your own auto closing

00:39:52,209 --> 00:39:58,719
iterators are out of closing strings and

00:39:54,009 --> 00:40:01,479
this is an example scanner so many of

00:39:58,719 --> 00:40:03,640
you have used the java scanner that i

00:40:01,479 --> 00:40:05,289
talked about it briefly before but this

00:40:03,640 --> 00:40:07,719
is a more scholar friendly one so you

00:40:05,289 --> 00:40:09,339
have some hello world 1 2 2 3 you can

00:40:07,719 --> 00:40:13,509
create a new scanner again using that

00:40:09,339 --> 00:40:14,859
thing new person and the thing then you

00:40:13,509 --> 00:40:16,779
don't have to do next string you put a

00:40:14,859 --> 00:40:18,729
next type class and you can pass in

00:40:16,779 --> 00:40:21,459
tuples there's a library built on top

00:40:18,729 --> 00:40:27,099
you can pass with h list a shapeless h

00:40:21,459 --> 00:40:28,959
list and this thing is actually if you

00:40:27,099 --> 00:40:32,160
can we click on the benchmarks here

00:40:28,959 --> 00:40:35,619
I can't open new tabs for some reason

00:40:32,160 --> 00:40:37,299
it's actually 8 times faster than the

00:40:35,619 --> 00:40:39,339
Java scanner the reason being the Java

00:40:37,299 --> 00:40:41,529
scanner uses regex is to find the next

00:40:39,339 --> 00:40:44,680
integer or next strings this one uses

00:40:41,529 --> 00:40:46,749
vanilla partial Combinator strength

00:40:44,680 --> 00:40:52,239
organizers and it turns out to be way

00:40:46,749 --> 00:40:55,239
far faster than reg axis and this is an

00:40:52,239 --> 00:40:58,119
example where it shows a superior color

00:40:55,239 --> 00:40:59,529
using scholar type classes because you

00:40:58,119 --> 00:41:03,160
can right here so you let's say you have

00:40:59,529 --> 00:41:05,589
your own plus animal and it has two

00:41:03,160 --> 00:41:07,719
kinds of animals dogs and cats and you

00:41:05,589 --> 00:41:09,670
want to parse an animal so you just have

00:41:07,719 --> 00:41:11,799
to implement the scannable type class

00:41:09,670 --> 00:41:14,170
saying ok given a scanner how do I get

00:41:11,799 --> 00:41:15,969
back an animal ok this is some stupid

00:41:14,170 --> 00:41:19,890
example it says if it's Garfield the cat

00:41:15,969 --> 00:41:22,329
is a dog but now once this implicit

00:41:19,890 --> 00:41:24,339
evidence is there that ok given a

00:41:22,329 --> 00:41:26,589
scanner I can get an animal you can just

00:41:24,339 --> 00:41:30,599
do scanner dot next and pass an animal

00:41:26,589 --> 00:41:30,599
this is something that's not possible

00:41:31,250 --> 00:41:36,570
while monitoring so I don't know how

00:41:35,430 --> 00:41:38,310
many of you use while monitoring is

00:41:36,570 --> 00:41:40,140
basically like if some changes happen to

00:41:38,310 --> 00:41:42,450
a file system you want to get back get

00:41:40,140 --> 00:41:44,970
back a call back there's a whole another

00:41:42,450 --> 00:41:49,250
talk I can do on this it's like how the

00:41:44,970 --> 00:41:51,750
Java one is terrible has so many bugs

00:41:49,250 --> 00:41:54,030
actually documented them if you actually

00:41:51,750 --> 00:41:56,160
go to the monitoring there's a readme on

00:41:54,030 --> 00:41:58,230
it it tells you all the other caveats

00:41:56,160 --> 00:42:00,270
and bugs with the Java one so this

00:41:58,230 --> 00:42:03,119
solves and the interface is terrible for

00:42:00,270 --> 00:42:05,760
the Java one so the one in better files

00:42:03,119 --> 00:42:07,650
all you have to do is you pass in what

00:42:05,760 --> 00:42:09,630
file you want to watch you can say it

00:42:07,650 --> 00:42:11,670
you want to watch if it's a directory

00:42:09,630 --> 00:42:13,350
watch it recursively or not or you can

00:42:11,670 --> 00:42:16,320
pass in a max depth also you can it by

00:42:13,350 --> 00:42:17,520
default is inter max value but and then

00:42:16,320 --> 00:42:20,250
you get to override these three things

00:42:17,520 --> 00:42:21,960
and that's it and that's actually a

00:42:20,250 --> 00:42:24,240
fourth one on exception if an exception

00:42:21,960 --> 00:42:26,280
does happen while watching a file the OS

00:42:24,240 --> 00:42:27,450
doesn't let you even watch that so there

00:42:26,280 --> 00:42:29,520
are four things you override and that's

00:42:27,450 --> 00:42:35,090
it and you can start at any time stop at

00:42:29,520 --> 00:42:37,950
any time and this is one if you want to

00:42:35,090 --> 00:42:39,300
create custom events like these are the

00:42:37,950 --> 00:42:41,730
three events also possible in most

00:42:39,300 --> 00:42:43,830
operating systems for some reason you

00:42:41,730 --> 00:42:46,710
want to do more stuff you can do it this

00:42:43,830 --> 00:42:49,470
way too so this is the example so the

00:42:46,710 --> 00:42:54,000
previous one was it was called a thread

00:42:49,470 --> 00:42:56,190
back Oh monitor so this is a very simple

00:42:54,000 --> 00:42:59,760
abstraction it uses Java dot util dot

00:42:56,190 --> 00:43:01,020
threads underneath but this is an

00:42:59,760 --> 00:43:03,359
example where we build a much more

00:43:01,020 --> 00:43:04,680
powerful paradigm on top of it so this

00:43:03,359 --> 00:43:05,460
is a separate library you have to depend

00:43:04,680 --> 00:43:09,750
on better files

00:43:05,460 --> 00:43:12,680
- akka so this lets you design file

00:43:09,750 --> 00:43:14,940
monitors but using our characters so you

00:43:12,680 --> 00:43:16,859
you get a message saying that's a new

00:43:14,940 --> 00:43:22,680
something happened and you can react to

00:43:16,859 --> 00:43:26,250
it so and you can yeah it has this DSL

00:43:22,680 --> 00:43:27,960
you can attach on the event type you get

00:43:26,250 --> 00:43:30,480
a function saying this is the callback

00:43:27,960 --> 00:43:32,990
or you can attach multiple one so for if

00:43:30,480 --> 00:43:37,200
there's a create or modify happened on

00:43:32,990 --> 00:43:39,150
this this directory and then do

00:43:37,200 --> 00:43:44,390
something

00:43:39,150 --> 00:43:44,390
that's my tour of better files

00:43:59,180 --> 00:44:02,499
go back to the presentation

00:44:06,900 --> 00:44:12,420
I'm not going to go over this but Martin

00:44:09,570 --> 00:44:14,460
already talked about things like the

00:44:12,420 --> 00:44:16,110
future of this color ecosystem like

00:44:14,460 --> 00:44:19,980
something like this belonging in the

00:44:16,110 --> 00:44:22,320
Scala library that's called a default

00:44:19,980 --> 00:44:23,820
library or not I as many of you probably

00:44:22,320 --> 00:44:25,860
realize it's color library

00:44:23,820 --> 00:44:27,450
it's very slow-moving because we're all

00:44:25,860 --> 00:44:29,340
backwards compatibility reason that's

00:44:27,450 --> 00:44:32,550
like one liter month or model is a year

00:44:29,340 --> 00:44:33,990
and something like this probably belongs

00:44:32,550 --> 00:44:36,420
in the standard library once we do a

00:44:33,990 --> 00:44:38,900
split where we have the core which is

00:44:36,420 --> 00:44:42,090
just the minimum needed to get the

00:44:38,900 --> 00:44:44,520
scholarship working and anything else

00:44:42,090 --> 00:44:47,280
goes like in this universe where you

00:44:44,520 --> 00:44:51,120
have net Jason and I oh maybe belongs

00:44:47,280 --> 00:44:54,150
there so I'm not gonna go over this so

00:44:51,120 --> 00:44:56,960
that's it for the talk so the source is

00:44:54,150 --> 00:45:00,570
here there's an active Gator channel

00:44:56,960 --> 00:45:02,190
there are no open bugs yet or no open

00:45:00,570 --> 00:45:04,770
bugs that are right now there were bugs

00:45:02,190 --> 00:45:07,410
before that are closed there are some 20

00:45:04,770 --> 00:45:09,600
feature requests the library is less

00:45:07,410 --> 00:45:12,330
it's for 40 lines of code that's what it

00:45:09,600 --> 00:45:13,890
that's a very small library in fact

00:45:12,330 --> 00:45:15,330
there are more people who start the

00:45:13,890 --> 00:45:20,430
project on github than there are lines

00:45:15,330 --> 00:45:24,960
of code but it has about 3,000 lines of

00:45:20,430 --> 00:45:28,020
code which for tests and benchmarks it's

00:45:24,960 --> 00:45:29,160
being used by my company and some other

00:45:28,020 --> 00:45:31,890
places there's a lot of mayo and

00:45:29,160 --> 00:45:40,950
downloads I'm saying but you have user

00:45:31,890 --> 00:45:43,670
report bugs pull requests that's it you

00:45:40,950 --> 00:45:43,670
have any questions

00:45:51,080 --> 00:46:02,140
oh you have the microphone just yell

00:45:55,190 --> 00:46:02,140
I'll repeat your question mm-hm

00:46:03,190 --> 00:46:10,810
Mac ah okay so the question was for file

00:46:08,180 --> 00:46:13,490
monitoring how does it operate across

00:46:10,810 --> 00:46:16,610
operating systems like Windows versus

00:46:13,490 --> 00:46:18,830
the next verses Mac Mac I don't I use

00:46:16,610 --> 00:46:21,290
the Java file watcher there's in Java

00:46:18,830 --> 00:46:22,850
dot ni oh there's a file water and it's

00:46:21,290 --> 00:46:24,730
pretty terrible it has all kinds of bugs

00:46:22,850 --> 00:46:26,900
like if you create a new directory

00:46:24,730 --> 00:46:30,320
inside a directory or watching it will

00:46:26,900 --> 00:46:31,760
not Auto watch it or if you it cannot

00:46:30,320 --> 00:46:33,200
you can only watch the directories it

00:46:31,760 --> 00:46:35,030
can never watch a file so you have to do

00:46:33,200 --> 00:46:36,710
a trick to watch the parent of a file

00:46:35,030 --> 00:46:38,690
and just look for the changes in that

00:46:36,710 --> 00:46:41,720
file so it handles all those tricks for

00:46:38,690 --> 00:46:43,760
you but I don't do any operating system

00:46:41,720 --> 00:46:46,000
level checks because that's handled by

00:46:43,760 --> 00:46:46,000
Java

00:46:55,860 --> 00:46:58,520
yes

00:47:12,280 --> 00:47:14,910
right

00:47:14,990 --> 00:47:20,060
right so that's a good question so the

00:47:18,080 --> 00:47:22,190
question is about there are things that

00:47:20,060 --> 00:47:23,720
are not recommended which is mostly the

00:47:22,190 --> 00:47:26,560
symbolic stuff like do you want to use

00:47:23,720 --> 00:47:30,080
this symbol or not right now there is no

00:47:26,560 --> 00:47:31,430
no differentiation there are a couple of

00:47:30,080 --> 00:47:33,050
ways to solve it one is put all the

00:47:31,430 --> 00:47:34,970
things that I don't like the symbols in

00:47:33,050 --> 00:47:37,070
a separate import if you want some

00:47:34,970 --> 00:47:40,150
bollocks I think it kind of goes with

00:47:37,070 --> 00:47:43,130
that UNIX see DSL if you want it or not

00:47:40,150 --> 00:47:44,810
the other way is to add some annotation

00:47:43,130 --> 00:47:46,010
or something but that's something I

00:47:44,810 --> 00:47:48,190
haven't done yet but I'll be doing it

00:47:46,010 --> 00:47:48,190
soon

00:48:00,380 --> 00:48:03,039
right

00:48:04,990 --> 00:48:07,589
right

00:48:07,599 --> 00:48:12,239
yeah yeah yeah

00:48:18,780 --> 00:48:27,990
the witch class ah yeah so you have the

00:48:25,410 --> 00:48:29,940
there are two ways you can if you can

00:48:27,990 --> 00:48:32,609
write an option saying like I was able

00:48:29,940 --> 00:48:34,109
to scan or not so that two flavors to it

00:48:32,609 --> 00:48:36,240
I didn't go really deep into it so

00:48:34,109 --> 00:48:37,500
there's a one exceptionally one throw an

00:48:36,240 --> 00:48:39,570
exception and that's like an option one

00:48:37,500 --> 00:48:43,950
which says I could scan or not so

00:48:39,570 --> 00:48:47,640
they're two flavors of it quick question

00:48:43,950 --> 00:48:49,950
are you using Scala - are for resource

00:48:47,640 --> 00:48:53,460
management caller what

00:48:49,950 --> 00:48:55,020
Scala - erm no no it does not depend on

00:48:53,460 --> 00:48:57,480
any external library okay

00:48:55,020 --> 00:49:02,810
yeah but there are things that I learned

00:48:57,480 --> 00:49:02,810
from Scala RM to use they are em in here

00:49:09,020 --> 00:49:12,380

YouTube URL: https://www.youtube.com/watch?v=uaYKkpqs6CE


