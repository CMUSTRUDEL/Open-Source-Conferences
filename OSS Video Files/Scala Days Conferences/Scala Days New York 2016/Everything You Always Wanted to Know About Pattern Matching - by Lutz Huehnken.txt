Title: Everything You Always Wanted to Know About Pattern Matching - by Lutz Huehnken
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Pattern Matching is a great and very popular feature in Scala - yet many are quite unsure about how it works exactly. What can I match on? How efficient is it? What do case classes have to do with it? What's an extractor? What's the deal with unapply and unapplySeq? And what exactly is the role of "::" or "+:" when matching sequences? If I build my own extractors, what exactly goes in, what comes out? This is an entry level talk for developers who'd like to look "under the hood" of pattern matching, and who haven't written their own extractors yet.
Captions: 
	00:00:07,410 --> 00:00:13,690
let's start

00:00:09,700 --> 00:00:13,690
my name is Luke Zurich rely

00:00:14,130 --> 00:00:21,210
in scour because I think it's a very

00:00:16,260 --> 00:00:22,590
interesting topic um ooh okay well this

00:00:21,210 --> 00:00:24,779
is not gonna happen on the other side I

00:00:22,590 --> 00:00:27,750
just made this one up uh I am actually

00:00:24,779 --> 00:00:29,250
here in person which I just learned this

00:00:27,750 --> 00:00:31,290
is gonna be recorded so if you're

00:00:29,250 --> 00:00:35,010
watching the recording I'm not there but

00:00:31,290 --> 00:00:36,540
here I am so make use of that you can

00:00:35,010 --> 00:00:38,880
you can ask me things you can interrupt

00:00:36,540 --> 00:00:40,320
me you can try out or let's make this a

00:00:38,880 --> 00:00:42,329
bit interactive well with any reason

00:00:40,320 --> 00:00:44,430
you're not supposed to serve interrupt

00:00:42,329 --> 00:00:45,540
me all the time but well in the end I

00:00:44,430 --> 00:00:47,010
have the power to say we're going to

00:00:45,540 --> 00:00:48,570
come back to this question later or

00:00:47,010 --> 00:00:50,790
whatever or just fun it I'd rather have

00:00:48,570 --> 00:00:53,940
it to be a bit interactive than all of

00:00:50,790 --> 00:00:58,680
you to dozing away because it's last

00:00:53,940 --> 00:01:00,330
session of the day and so on so what are

00:00:58,680 --> 00:01:02,430
we talking about pattern matching a lot

00:01:00,330 --> 00:01:04,170
of people that do Scala programming did

00:01:02,430 --> 00:01:06,450
Java programming before and they know

00:01:04,170 --> 00:01:08,009
the switch statement and in Java but

00:01:06,450 --> 00:01:10,710
pattern matching in Scala of course is

00:01:08,009 --> 00:01:12,810
quite different so for example as

00:01:10,710 --> 00:01:14,880
basically everything in Scala it's an

00:01:12,810 --> 00:01:18,090
expression it evaluates to something

00:01:14,880 --> 00:01:19,859
right I can say Val X equals and then I

00:01:18,090 --> 00:01:22,560
have my pattern matching expression over

00:01:19,859 --> 00:01:24,329
here the result there's no fall foo I

00:01:22,560 --> 00:01:27,689
don't have the I don't have to use break

00:01:24,329 --> 00:01:31,530
to avoid to for the next case to be

00:01:27,689 --> 00:01:32,969
executed and I have to be have to be

00:01:31,530 --> 00:01:35,039
exhaustive like if I don't match

00:01:32,969 --> 00:01:37,740
anything then I'm actually going to get

00:01:35,039 --> 00:01:39,299
an exception I'm going to go through the

00:01:37,740 --> 00:01:42,749
first couple of slides quickly you see I

00:01:39,299 --> 00:01:44,450
have a few again if there's something on

00:01:42,749 --> 00:01:47,249
it that you find very disturbing or

00:01:44,450 --> 00:01:50,060
uncomfortable than please interrupt me

00:01:47,249 --> 00:01:54,299
so what does the pattern look like or a

00:01:50,060 --> 00:01:56,490
match expression in our one case an RMF

00:01:54,299 --> 00:01:58,619
expression we have the case keyword

00:01:56,490 --> 00:02:00,450
followed by a pattern and there are only

00:01:58,619 --> 00:02:02,100
certain types of patterns we can use we

00:02:00,450 --> 00:02:04,799
cannot use arbitrary expressions there

00:02:02,100 --> 00:02:06,689
all right so we're going to look at some

00:02:04,799 --> 00:02:09,420
patterns pattern types that we can use

00:02:06,689 --> 00:02:11,700
if the pattern matches the result will

00:02:09,420 --> 00:02:14,430
be evaluated and only that one like it's

00:02:11,700 --> 00:02:16,680
not going to go to the next one the

00:02:14,430 --> 00:02:19,319
order matters they're the simplest case

00:02:16,680 --> 00:02:23,010
we match everything the wildcard pattern

00:02:19,319 --> 00:02:24,690
the underscore of newsstand Scala to

00:02:23,010 --> 00:02:26,850
express something that's not defined or

00:02:24,690 --> 00:02:27,630
that we're not interested in here we say

00:02:26,850 --> 00:02:29,580
it's

00:02:27,630 --> 00:02:31,620
this ramesh everything let me try this

00:02:29,580 --> 00:02:34,710
replica thing out so I can run this and

00:02:31,620 --> 00:02:37,920
cause a match or this pony below maybe

00:02:34,710 --> 00:02:43,950
for some of you but um you know whatever

00:02:37,920 --> 00:02:47,420
right um it's a match how did I get back

00:02:43,950 --> 00:02:47,420
to this line yeah

00:02:48,110 --> 00:02:51,660
also very simple

00:02:49,860 --> 00:02:54,510
the constant pattern after to say

00:02:51,660 --> 00:02:57,120
compare it to this actual value here and

00:02:54,510 --> 00:02:59,040
I use the underscore the wildcat pattern

00:02:57,120 --> 00:03:01,140
I showed before as the default case so I

00:02:59,040 --> 00:03:06,240
don't get the Mexican match exception

00:03:01,140 --> 00:03:08,700
right and oh yeah and I can also use I

00:03:06,240 --> 00:03:10,500
can introduce variable identifier so I

00:03:08,700 --> 00:03:12,420
can introduce identifiers and they will

00:03:10,500 --> 00:03:15,090
be a variable in the scope of the met

00:03:12,420 --> 00:03:17,760
expression right so here it has exactly

00:03:15,090 --> 00:03:20,970
the same effect as the underscore this

00:03:17,760 --> 00:03:22,500
will match everything because x is has

00:03:20,970 --> 00:03:24,000
not been is not bound right it has not

00:03:22,500 --> 00:03:28,290
been defined before it matches

00:03:24,000 --> 00:03:32,700
everything that's one this see here oh

00:03:28,290 --> 00:03:34,110
no and I was caught in what metrics yeah

00:03:32,700 --> 00:03:36,180
he said oh yeah and of course the

00:03:34,110 --> 00:03:38,010
advantage of this is as opposed to the

00:03:36,180 --> 00:03:40,260
underscore that I can actually refer to

00:03:38,010 --> 00:03:42,780
the value that was passed in by the name

00:03:40,260 --> 00:03:45,150
now I can use the X in the right hand

00:03:42,780 --> 00:03:47,400
side of my case all pretty standard

00:03:45,150 --> 00:03:49,380
stuff oh but this now we're already

00:03:47,400 --> 00:03:50,640
getting started with these or more with

00:03:49,380 --> 00:03:55,290
things that happen when people use

00:03:50,640 --> 00:03:56,790
parametric so I have this I have this

00:03:55,290 --> 00:03:59,640
constant here PI so I want to do a

00:03:56,790 --> 00:04:03,060
constant match I also have a variable or

00:03:59,640 --> 00:04:07,110
I have a value PI so what what's going

00:04:03,060 --> 00:04:09,420
to happen here what's going to be the

00:04:07,110 --> 00:04:12,560
result if I say so I want to check if

00:04:09,420 --> 00:04:15,799
something is PI or not PI if I do m1 and

00:04:12,560 --> 00:04:18,690
well let's say 5 is not PI right

00:04:15,799 --> 00:04:21,600
it says it's not PI that's fine what's

00:04:18,690 --> 00:04:25,410
going to happen if I say m2 may have

00:04:21,600 --> 00:04:27,720
magic is true well we kind of expect

00:04:25,410 --> 00:04:30,660
it's the same result but it isn't right

00:04:27,720 --> 00:04:33,510
because here here I'm not actually

00:04:30,660 --> 00:04:36,120
comparable let me get this back I'm not

00:04:33,510 --> 00:04:38,580
actually comparing with the value PI or

00:04:36,120 --> 00:04:40,380
with my constant PI I'm introducing a

00:04:38,580 --> 00:04:41,310
new identifier like this one shadows

00:04:40,380 --> 00:04:43,440
whatever I've defined

00:04:41,310 --> 00:04:45,930
side it's a very common mistake people

00:04:43,440 --> 00:04:47,760
do that all not all the time but if

00:04:45,930 --> 00:04:49,140
people start doing Scala and they get

00:04:47,760 --> 00:04:51,090
into pattern matching they tend to do

00:04:49,140 --> 00:04:53,460
these things and this can actually be a

00:04:51,090 --> 00:04:56,790
bit annoying what can you do just say I

00:04:53,460 --> 00:04:59,430
I want to so I have this value that I

00:04:56,790 --> 00:05:01,260
have defined outside of my math

00:04:59,430 --> 00:05:03,750
expression then I want to refer to and

00:05:01,260 --> 00:05:06,060
for some reason I did not want to use an

00:05:03,750 --> 00:05:07,830
uppercase identifier how can I actually

00:05:06,060 --> 00:05:12,570
get to the value rather than defining a

00:05:07,830 --> 00:05:15,510
new a new identifier a new variable okay

00:05:12,570 --> 00:05:17,250
the rule behind this is uppercase this

00:05:15,510 --> 00:05:18,750
is actually quite interesting when we

00:05:17,250 --> 00:05:20,640
look at at at pattern matching we're

00:05:18,750 --> 00:05:23,190
gonna see there are some conventions in

00:05:20,640 --> 00:05:25,260
place there's some things that be some

00:05:23,190 --> 00:05:27,510
compiler fills in for us or some rules

00:05:25,260 --> 00:05:28,980
we just have to know and one of those is

00:05:27,510 --> 00:05:32,190
if it's uppercase it's assumed to be

00:05:28,980 --> 00:05:35,310
constant if it's lowercase it's assumed

00:05:32,190 --> 00:05:37,710
to be a new identifier but I can also be

00:05:35,310 --> 00:05:40,710
explicit about this and can say okay I

00:05:37,710 --> 00:05:44,160
can use a fully qualified name like this

00:05:40,710 --> 00:05:46,140
dot PI we've heard to the PI member of

00:05:44,160 --> 00:05:48,330
this obviously or I can use backticks

00:05:46,140 --> 00:05:50,580
backticks also very popular in Scala to

00:05:48,330 --> 00:05:52,770
use anything as an identifier that does

00:05:50,580 --> 00:05:55,080
not match the the common identifier

00:05:52,770 --> 00:05:56,670
rules if I have some something that's a

00:05:55,080 --> 00:05:59,190
keyword for example if I want to have

00:05:56,670 --> 00:06:01,740
something that's called Val I can just

00:05:59,190 --> 00:06:03,180
use it because val is a keyword and i

00:06:01,740 --> 00:06:05,910
can put it in backticks and then it

00:06:03,180 --> 00:06:13,020
becomes a valid identifier very useful

00:06:05,910 --> 00:06:14,670
in scala various um so here what should

00:06:13,020 --> 00:06:17,300
happen field actually worldwide so these

00:06:14,670 --> 00:06:22,680
should not be PI and neither for this be

00:06:17,300 --> 00:06:24,480
yeah so problem solved to refer to

00:06:22,680 --> 00:06:26,730
lowercase values either use the

00:06:24,480 --> 00:06:30,720
qualified name or your spec takes of

00:06:26,730 --> 00:06:32,400
course don't and just use uppercase then

00:06:30,720 --> 00:06:35,070
we have to construct a pattern also very

00:06:32,400 --> 00:06:36,450
very popular in combination with case

00:06:35,070 --> 00:06:39,570
classes why you have a case class and

00:06:36,450 --> 00:06:41,610
you match on case classes like that's

00:06:39,570 --> 00:06:43,970
why they're called case classes right so

00:06:41,610 --> 00:06:47,100
it looks like calling constructor of

00:06:43,970 --> 00:06:49,950
course this works it's not even not a

00:06:47,100 --> 00:06:51,360
bother to to show you this a nice thing

00:06:49,950 --> 00:06:53,520
about this is that you can nest these

00:06:51,360 --> 00:06:54,870
right so you can do deep nesting and you

00:06:53,520 --> 00:06:57,060
can match to something

00:06:54,870 --> 00:06:58,560
you have a case of us that has a member

00:06:57,060 --> 00:07:02,250
that is caseless and it has another

00:06:58,560 --> 00:07:03,570
member and you can touch on that another

00:07:02,250 --> 00:07:05,310
thing you can measure on so we saw some

00:07:03,570 --> 00:07:06,900
patterns here I said you can only match

00:07:05,310 --> 00:07:08,220
against legal patterns you cannot match

00:07:06,900 --> 00:07:09,840
against a new expression so we saw

00:07:08,220 --> 00:07:12,810
constants we saw wildcards we saw

00:07:09,840 --> 00:07:15,030
identifiers now we saw case classes and

00:07:12,810 --> 00:07:20,160
there are also sequences we can match

00:07:15,030 --> 00:07:27,840
against sequences let's run this so what

00:07:20,160 --> 00:07:29,460
should happen for l1 this has exactly

00:07:27,840 --> 00:07:31,500
four elements and starts with the one oh

00:07:29,460 --> 00:07:36,810
that's a good one too yeah that's what

00:07:31,500 --> 00:07:41,850
it says l2 is just five so it starts

00:07:36,810 --> 00:07:46,260
with five same for l3 right and what we

00:07:41,850 --> 00:07:48,930
see here is you can match a fixed sized

00:07:46,260 --> 00:07:53,520
sequence or you can use this asterisk

00:07:48,930 --> 00:07:58,740
notation as you would for argument lists

00:07:53,520 --> 00:08:00,840
right um or you can use the different of

00:07:58,740 --> 00:08:04,050
this different syntax which looks more

00:08:00,840 --> 00:08:06,060
like which is very very popular on you

00:08:04,050 --> 00:08:09,300
so in a another functional language you

00:08:06,060 --> 00:08:10,979
have this consular where you construct

00:08:09,300 --> 00:08:11,639
your list by having one element that you

00:08:10,979 --> 00:08:13,260
prepend

00:08:11,639 --> 00:08:15,750
to the rest of your destroyed and you

00:08:13,260 --> 00:08:17,669
can deconstruct this in a pattern match

00:08:15,750 --> 00:08:21,990
so here we want to iterate over

00:08:17,669 --> 00:08:23,729
something we recurse over a list and if

00:08:21,990 --> 00:08:26,400
it's nil as this our end conditional we

00:08:23,729 --> 00:08:31,020
stop if it's what's the point here if it

00:08:26,400 --> 00:08:33,150
contains 5y okay so if it's if the first

00:08:31,020 --> 00:08:35,130
element is not if it's empty it doesn't

00:08:33,150 --> 00:08:37,070
contain five okay if the first element

00:08:35,130 --> 00:08:39,450
is five do we don't care about the rest

00:08:37,070 --> 00:08:41,219
obviously it contains five if it's not

00:08:39,450 --> 00:08:45,029
then we just call the same thing on the

00:08:41,219 --> 00:08:48,750
tail so very nice syntax what is this

00:08:45,029 --> 00:08:50,160
thing though what is this + + : it's not

00:08:48,750 --> 00:08:51,870
billion it I can tell you that much it's

00:08:50,160 --> 00:08:53,490
not the keyboard it's not an operator

00:08:51,870 --> 00:08:57,390
that's built into the language foreign

00:08:53,490 --> 00:08:59,070
language definition we know it's also

00:08:57,390 --> 00:09:01,020
there is a method is that there is the

00:08:59,070 --> 00:09:02,730
prepend method on sequence that allows

00:09:01,020 --> 00:09:04,050
us to put an element in front of

00:09:02,730 --> 00:09:06,150
something else but that doesn't really

00:09:04,050 --> 00:09:08,360
make sense you that we don't have a we

00:09:06,150 --> 00:09:11,120
call this on underscore to construct

00:09:08,360 --> 00:09:11,839
some sequence obviously not so it's

00:09:11,120 --> 00:09:14,450
something else

00:09:11,839 --> 00:09:22,029
what does it what is it doesn't anyone

00:09:14,450 --> 00:09:23,300
know what what's the type of it hmm oh

00:09:22,029 --> 00:09:25,820
yeah

00:09:23,300 --> 00:09:28,459
that's what I did so you just go to your

00:09:25,820 --> 00:09:29,980
ID and click on it it's an object that's

00:09:28,459 --> 00:09:33,320
in Scala that's one of the nice things

00:09:29,980 --> 00:09:34,850
in Scala Scala is not so fuzzy about how

00:09:33,320 --> 00:09:38,050
you name your objects you can actually

00:09:34,850 --> 00:09:40,490
define an object that's called + : and

00:09:38,050 --> 00:09:42,709
the nice thing about this particular

00:09:40,490 --> 00:09:46,130
object it is it has a method called uh

00:09:42,709 --> 00:09:48,550
apply right so we call these objects and

00:09:46,130 --> 00:09:51,589
they have the uh apply method extractors

00:09:48,550 --> 00:09:53,510
so what it does it well actually in the

00:09:51,589 --> 00:09:57,290
pattern match it will call this an apply

00:09:53,510 --> 00:09:58,730
method and we'll put in are we going to

00:09:57,290 --> 00:10:00,529
talk about this and from some detail

00:09:58,730 --> 00:10:02,240
let's look at it so this is this is the

00:10:00,529 --> 00:10:04,730
actual source code of the + :

00:10:02,240 --> 00:10:06,200
it takes a sequence returns an option

00:10:04,730 --> 00:10:08,720
with the first element and see the rest

00:10:06,200 --> 00:10:11,660
of the sequence then you know and you

00:10:08,720 --> 00:10:14,690
say okay the UH apply mm-hmm it returns

00:10:11,660 --> 00:10:17,060
an option and then there's a tuple in

00:10:14,690 --> 00:10:18,860
the option so again there are probably

00:10:17,060 --> 00:10:20,600
some conventions at play right so an

00:10:18,860 --> 00:10:22,820
extractor is a scala object with an

00:10:20,600 --> 00:10:24,199
unemployment it doesn't have to be a

00:10:22,820 --> 00:10:25,640
named object by the way like it doesn't

00:10:24,199 --> 00:10:29,029
have to be singleton you can put the uh

00:10:25,640 --> 00:10:31,100
apply in any instance really it's it's

00:10:29,029 --> 00:10:32,750
called an appliance if you've looked at

00:10:31,100 --> 00:10:35,269
case classes and companion objects you

00:10:32,750 --> 00:10:37,310
all know the apply method right the one

00:10:35,269 --> 00:10:39,949
that you never write apply because it's

00:10:37,310 --> 00:10:42,890
applied when you just use the name of

00:10:39,949 --> 00:10:45,589
the companion object and and put in some

00:10:42,890 --> 00:10:49,310
parameters so and this is kind of the

00:10:45,589 --> 00:10:51,589
the the other side of that just like you

00:10:49,310 --> 00:10:53,839
apply and create your object you can

00:10:51,589 --> 00:10:55,850
under ply and kind of get access to the

00:10:53,839 --> 00:10:57,829
contents without having to actually look

00:10:55,850 --> 00:11:00,800
into it because of course we're going to

00:10:57,829 --> 00:11:02,329
encapsulate the information um it takes

00:11:00,800 --> 00:11:03,740
the value you match as a parameter

00:11:02,329 --> 00:11:05,000
there's sometimes confusing we're going

00:11:03,740 --> 00:11:06,529
to look at that but when we turn

00:11:05,000 --> 00:11:09,320
something was going to look at that and

00:11:06,529 --> 00:11:12,500
whatever it returns is going to be bound

00:11:09,320 --> 00:11:14,839
to the pattern you have there mm-hmm so

00:11:12,500 --> 00:11:17,149
let's write our own we already know okay

00:11:14,839 --> 00:11:19,970
it's simple and apply say we have a time

00:11:17,149 --> 00:11:21,770
class or with hours and minutes and we

00:11:19,970 --> 00:11:22,040
just want to have a simple track and say

00:11:21,770 --> 00:11:23,630
if it

00:11:22,040 --> 00:11:26,420
in the morning or it's in if it's in the

00:11:23,630 --> 00:11:27,610
afternoon so we define our own extractor

00:11:26,420 --> 00:11:32,690
and say okay the unapplied

00:11:27,610 --> 00:11:36,910
method takes takes the time as a

00:11:32,690 --> 00:11:42,860
parameter and then returns true or false

00:11:36,910 --> 00:11:45,170
so know this right so this one here okay

00:11:42,860 --> 00:11:47,690
we don't we don't bind anything we don't

00:11:45,170 --> 00:11:48,980
find any variables afterwards so but we

00:11:47,690 --> 00:11:53,990
still have a parameter here right so

00:11:48,980 --> 00:11:56,810
this this T goes into the UH apply and

00:11:53,990 --> 00:11:58,760
whatever is returned well if we would

00:11:56,810 --> 00:12:00,290
return something meaningful then that

00:11:58,760 --> 00:12:02,000
will be bound to whatever is in these

00:12:00,290 --> 00:12:05,800
parentheses in this case nothing but

00:12:02,000 --> 00:12:05,800
we're going to see other examples so

00:12:13,680 --> 00:12:34,860
I did not understand the question yeah

00:12:20,730 --> 00:12:38,070
exactly this bin here yeah exactly yeah

00:12:34,860 --> 00:12:39,750
whatever is that is the your metric of

00:12:38,070 --> 00:12:42,120
this of the expression you you want to

00:12:39,750 --> 00:12:46,700
match against is what it's gonna be put

00:12:42,120 --> 00:12:49,440
into the unemployment um so I say greet

00:12:46,700 --> 00:12:51,750
at noon and it says good afternoon

00:12:49,440 --> 00:12:53,940
because okay we don't distinguish there

00:12:51,750 --> 00:12:56,640
it's either morning or afternoon if I

00:12:53,940 --> 00:12:58,410
say greet morn which is short for

00:12:56,640 --> 00:13:00,720
morning it says good morning

00:12:58,410 --> 00:13:03,270
okay so congratulations you put your

00:13:00,720 --> 00:13:09,839
first oh well I did I build your first

00:13:03,270 --> 00:13:12,000
extractor now a bit more involved now we

00:13:09,839 --> 00:13:13,650
want to we're gonna have access to the

00:13:12,000 --> 00:13:18,240
minutes and the hours on the right hand

00:13:13,650 --> 00:13:20,220
side of our case right so it's well it's

00:13:18,240 --> 00:13:23,670
the same to metric more logs to say more

00:13:20,220 --> 00:13:25,850
or less looks the same but we we return

00:13:23,670 --> 00:13:29,730
something else like we return an option

00:13:25,850 --> 00:13:33,750
with at Apple of hours and minutes so

00:13:29,730 --> 00:13:36,630
again what goes in here the time time

00:13:33,750 --> 00:13:38,790
that we supply here our tea is what goes

00:13:36,630 --> 00:13:40,260
into the pattern match the pedometer we

00:13:38,790 --> 00:13:42,360
turn an option with the tap of this top

00:13:40,260 --> 00:13:45,810
of this taken and the compiler or will

00:13:42,360 --> 00:13:48,180
at one time it will attempt to to bind

00:13:45,810 --> 00:13:49,650
this tuple to whatever you define here

00:13:48,180 --> 00:13:51,360
in the parenthesis also if I would

00:13:49,650 --> 00:13:53,010
change the number here would complain we

00:13:51,360 --> 00:13:54,900
say okay you're returning a pair but you

00:13:53,010 --> 00:14:00,000
only have one I want for a meeting there

00:13:54,900 --> 00:14:03,839
so um let me run it again if it's the

00:14:00,000 --> 00:14:07,650
work greet the morning good morning it's

00:14:03,839 --> 00:14:09,720
9 o'clock was not but that was so the

00:14:07,650 --> 00:14:11,370
definition of morning here and at noon

00:14:09,720 --> 00:14:12,150
and I guess it's 12:00 and it's gonna

00:14:11,370 --> 00:14:15,480
say good afternoon

00:14:12,150 --> 00:14:16,890
oh yeah it doesn't even print it out why

00:14:15,480 --> 00:14:20,270
another extractor now we have an

00:14:16,890 --> 00:14:22,530
extractor we know oh so what what's

00:14:20,270 --> 00:14:24,060
what's interesting about this or is

00:14:22,530 --> 00:14:27,030
something is there something that sort

00:14:24,060 --> 00:14:27,450
of grabs your attention we have very

00:14:27,030 --> 00:14:28,770
different

00:14:27,450 --> 00:14:30,450
return times right and there in the

00:14:28,770 --> 00:14:32,280
first example we just returned the

00:14:30,450 --> 00:14:34,200
bunion and the second one returned and

00:14:32,280 --> 00:14:35,910
we returned an option of a temple that's

00:14:34,200 --> 00:14:38,610
kind of what is the type of this what's

00:14:35,910 --> 00:14:42,930
of the by definition what is the return

00:14:38,610 --> 00:14:45,240
type of an apply oh well before we look

00:14:42,930 --> 00:14:48,930
into that there's another so there's a

00:14:45,240 --> 00:14:53,220
next one we can also just return oh no

00:14:48,930 --> 00:14:55,170
this is oh that's a nice little tidbit I

00:14:53,220 --> 00:14:57,360
almost forgot about this if we have this

00:14:55,170 --> 00:15:00,330
if we have an unemployment that returns

00:14:57,360 --> 00:15:02,700
a pair that has two returns two values

00:15:00,330 --> 00:15:05,460
or an option of repair we can actually

00:15:02,700 --> 00:15:09,900
write the extractor in line I don't have

00:15:05,460 --> 00:15:13,920
to wide am parentheses age M or whatever

00:15:09,900 --> 00:15:17,520
I can actually say my first value and my

00:15:13,920 --> 00:15:20,790
first variable am second one so this

00:15:17,520 --> 00:15:23,610
kind of explains the whole : the whole

00:15:20,790 --> 00:15:25,560
plus column thing right so we could also

00:15:23,610 --> 00:15:27,720
write it like this too so to emphasize

00:15:25,560 --> 00:15:29,670
that it's an extractor object it's not

00:15:27,720 --> 00:15:34,890
an operator it's not method we call on

00:15:29,670 --> 00:15:36,780
anything it's just like our AM extractor

00:15:34,890 --> 00:15:40,770
there's no magic there it's just called

00:15:36,780 --> 00:15:42,840
plus : it takes yeah it takes the list

00:15:40,770 --> 00:15:44,580
as a parameter the unemployment where we

00:15:42,840 --> 00:15:46,380
turn at Apple with an element of that

00:15:44,580 --> 00:15:47,820
list and the rest of the list and that's

00:15:46,380 --> 00:15:51,830
going to be bound through these two here

00:15:47,820 --> 00:15:51,830
this is yeah this will actually work so

00:15:52,880 --> 00:16:02,430
this doesn't contain 502 does contain 5

00:15:57,770 --> 00:16:04,830
so back to the oval so we saw two cases

00:16:02,430 --> 00:16:07,320
either I just want to say yes no it

00:16:04,830 --> 00:16:09,270
matters or doesn't its a.m. or it's even

00:16:07,320 --> 00:16:13,080
though uneven or whatever or I took the

00:16:09,270 --> 00:16:16,830
sleeve I returned an option of at Apple

00:16:13,080 --> 00:16:19,110
what if I have just one value there's no

00:16:16,830 --> 00:16:21,660
one tupple in scala right so there I can

00:16:19,110 --> 00:16:24,240
just return an option of that value in

00:16:21,660 --> 00:16:26,640
this case we take the hours again I'm

00:16:24,240 --> 00:16:30,120
just to prove that works I'm gonna run

00:16:26,640 --> 00:16:34,370
it again when we say greet and

00:16:30,120 --> 00:16:34,370
yeah it's 9:00 and noon it doesn't work

00:16:34,550 --> 00:16:39,090
so it becomes now it becomes even more

00:16:37,440 --> 00:16:41,009
mysterious right so we have three

00:16:39,090 --> 00:16:45,389
different possible return types

00:16:41,009 --> 00:16:49,139
it's either a boolean or a an option of

00:16:45,389 --> 00:16:56,459
a value or an option of at Apple yeah

00:16:49,139 --> 00:16:58,859
what can we make of that and also yeah

00:16:56,459 --> 00:16:59,609
and I am gonna come back to that just

00:16:58,859 --> 00:17:01,109
keep in mind

00:16:59,609 --> 00:17:02,970
interesting though another interesting

00:17:01,109 --> 00:17:06,260
thing is whatever we put in there that

00:17:02,970 --> 00:17:09,299
you see the definition of our and apply

00:17:06,260 --> 00:17:11,669
we actually define the uh apply or we

00:17:09,299 --> 00:17:13,829
are specific about the parameter type of

00:17:11,669 --> 00:17:17,459
the uh apply we say we only accept a

00:17:13,829 --> 00:17:19,740
time and we know now that this is gonna

00:17:17,459 --> 00:17:21,870
be the pattern match it's gonna be D

00:17:19,740 --> 00:17:23,669
Fraga it's gonna be expanded by the

00:17:21,870 --> 00:17:26,909
compiler true a method call it's gonna

00:17:23,669 --> 00:17:30,860
call the an apply but I can define my

00:17:26,909 --> 00:17:34,260
petty measuring like this I can say my

00:17:30,860 --> 00:17:36,210
my value and where the Metron is of type

00:17:34,260 --> 00:17:39,840
any so I have something that's of type

00:17:36,210 --> 00:17:41,639
any and I can still put it in there I

00:17:39,840 --> 00:17:44,130
can still create a method call where

00:17:41,639 --> 00:17:46,260
it's put in into a method that expects a

00:17:44,130 --> 00:17:48,809
time so what happens there is that will

00:17:46,260 --> 00:17:50,850
actually it will not directly take the

00:17:48,809 --> 00:17:53,130
value I provide and create the method

00:17:50,850 --> 00:17:55,200
call it will check the type and that

00:17:53,130 --> 00:17:57,570
becomes part of the pattern match right

00:17:55,200 --> 00:17:59,250
so before it invokes the uh apply it

00:17:57,570 --> 00:18:01,409
will check for the appropriate type and

00:17:59,250 --> 00:18:03,149
if the type does not match it will not

00:18:01,409 --> 00:18:05,130
attempt to call the unemployment so

00:18:03,149 --> 00:18:07,019
there's some is instance of an S

00:18:05,130 --> 00:18:10,289
instance of involved why is that

00:18:07,019 --> 00:18:11,549
important oh no I think somebody changed

00:18:10,289 --> 00:18:13,950
the order of my slides here without

00:18:11,549 --> 00:18:18,210
telling me so what have we learned so

00:18:13,950 --> 00:18:22,789
far extractors what goes in what goes in

00:18:18,210 --> 00:18:22,789
your match value why where is it defined

00:18:23,330 --> 00:18:28,889
in the unapplied method in your extract

00:18:26,580 --> 00:18:31,019
object what is returned and I've kind of

00:18:28,889 --> 00:18:33,630
been hinting at that all the time that

00:18:31,019 --> 00:18:35,130
there are a couple of options why if you

00:18:33,630 --> 00:18:36,899
have no variables you want to bind it's

00:18:35,130 --> 00:18:38,970
just can just be a boolean if you have

00:18:36,899 --> 00:18:41,279
one variable it's an option of that or

00:18:38,970 --> 00:18:43,529
if you have n variables it's an option

00:18:41,279 --> 00:18:46,950
of a couple of in there there's no type

00:18:43,529 --> 00:18:49,580
that has these constraints so yes it

00:18:46,950 --> 00:18:52,679
actually gets even better

00:18:49,580 --> 00:18:54,360
let's say if I have this pattern match

00:18:52,679 --> 00:18:56,190
and I have this unemployed and I

00:18:54,360 --> 00:18:57,810
we turn this option of at Apple there's

00:18:56,190 --> 00:18:59,700
quite some allocation going on might

00:18:57,810 --> 00:19:01,650
have to create an option object well I

00:18:59,700 --> 00:19:03,090
have to create the tupple to allocate

00:19:01,650 --> 00:19:06,570
the tupple and have to allocate the

00:19:03,090 --> 00:19:08,430
option and return that maybe maybe this

00:19:06,570 --> 00:19:11,490
is some hot spot imagination maybe IH

00:19:08,430 --> 00:19:14,310
rate over huge lists or maybe I run I

00:19:11,490 --> 00:19:16,590
don't run on the on ajv not on the

00:19:14,310 --> 00:19:19,230
Oracle JVM on the open JDK everyone on

00:19:16,590 --> 00:19:20,520
the dalvik VM on Android which has a

00:19:19,230 --> 00:19:23,190
different kind of garbage collection

00:19:20,520 --> 00:19:24,690
which might not be as effective so in

00:19:23,190 --> 00:19:26,940
certain cases it might be a bit

00:19:24,690 --> 00:19:30,090
expensive to create all these to have

00:19:26,940 --> 00:19:32,700
all these allocations so what I can do

00:19:30,090 --> 00:19:35,490
is I can just sort of create my own

00:19:32,700 --> 00:19:38,730
return object but I returned from the

00:19:35,490 --> 00:19:40,650
unemployment so the the some of the

00:19:38,730 --> 00:19:42,210
funny thing about this is it doesn't

00:19:40,650 --> 00:19:44,910
work on the type right it doesn't

00:19:42,210 --> 00:19:46,110
require the result of the unapplied to

00:19:44,910 --> 00:19:48,180
be of a certain type

00:19:46,110 --> 00:19:49,980
we already saw it can be a boolean it

00:19:48,180 --> 00:19:51,510
can be an option well an option of at

00:19:49,980 --> 00:19:53,340
Apollo an option of a venue so there is

00:19:51,510 --> 00:19:55,290
there wouldn't be a type in the type

00:19:53,340 --> 00:19:56,970
system that has these constraints or

00:19:55,290 --> 00:20:00,270
that allows all of these so it's

00:19:56,970 --> 00:20:02,610
actually um well it's based on on

00:20:00,270 --> 00:20:04,950
certain mechanics it takes whatever I

00:20:02,610 --> 00:20:07,830
returned from an apply and what call is

00:20:04,950 --> 00:20:09,510
empty on it if it's empty oh no first of

00:20:07,830 --> 00:20:11,960
all check if it's a boolean okay forgot

00:20:09,510 --> 00:20:16,080
about that step but let's say it's a

00:20:11,960 --> 00:20:18,210
it's something it will check is empty as

00:20:16,080 --> 00:20:20,730
it or on an optional would say of course

00:20:18,210 --> 00:20:22,590
get role yes or no oh well to a fault

00:20:20,730 --> 00:20:24,540
and we can simulate this I can just have

00:20:22,590 --> 00:20:28,410
my own is empty and then it will call

00:20:24,540 --> 00:20:32,010
get and whatever it gets as the result

00:20:28,410 --> 00:20:33,750
of that it will call the the field

00:20:32,010 --> 00:20:35,070
excesses of tuples so that's the

00:20:33,750 --> 00:20:37,530
underscore one for the first one

00:20:35,070 --> 00:20:40,590
underscore to further the second one so

00:20:37,530 --> 00:20:43,650
here I define my own time class that has

00:20:40,590 --> 00:20:45,690
its own SMT method its own get method

00:20:43,650 --> 00:20:48,780
and it allows me to access these fields

00:20:45,690 --> 00:20:53,400
as if it was a tuple and I can use this

00:20:48,780 --> 00:20:56,640
as the return value for pattern match so

00:20:53,400 --> 00:20:58,950
oh yeah and I need it of course if it's

00:20:56,640 --> 00:21:01,140
if it doesn't match I have to have some

00:20:58,950 --> 00:21:03,480
some constant that I return that where

00:21:01,140 --> 00:21:06,750
it says is empty is to write as this one

00:21:03,480 --> 00:21:11,030
here so is am

00:21:06,750 --> 00:21:11,030
I hope I still have the other ones here

00:21:11,809 --> 00:21:22,080
okay now he uses my old time class right

00:21:19,380 --> 00:21:26,390
because newness is another definition of

00:21:22,080 --> 00:21:26,390
time so I have to create a new time

00:21:33,629 --> 00:21:37,869
and now I can say is a new image should

00:21:36,070 --> 00:21:39,969
say good afternoon care it's the same

00:21:37,869 --> 00:21:42,429
mechanics here right so that's quite

00:21:39,969 --> 00:21:45,190
fascinating really and does it maybe

00:21:42,429 --> 00:21:47,019
remind you of something mmm if you do

00:21:45,190 --> 00:21:49,269
four expressions right it's it's kind of

00:21:47,019 --> 00:21:51,340
the same mechanics it doesn't matter

00:21:49,269 --> 00:21:53,320
what type you use within your four

00:21:51,340 --> 00:21:55,659
expressions it just matters that it has

00:21:53,320 --> 00:21:58,090
the map and flatmap and this and and

00:21:55,659 --> 00:22:00,070
with filter so it's just syntactic sugar

00:21:58,090 --> 00:22:01,690
it's rewritten by the compiler and it

00:22:00,070 --> 00:22:03,249
will still check at compile time though

00:22:01,690 --> 00:22:04,690
it's not something that's gonna happen

00:22:03,249 --> 00:22:07,089
at one time it will not track or the

00:22:04,690 --> 00:22:10,149
compiler will not just take anything and

00:22:07,089 --> 00:22:13,080
then call is empty at one time and we'll

00:22:10,149 --> 00:22:15,759
get a method not not found or whatever

00:22:13,080 --> 00:22:17,259
it will still check for the presence of

00:22:15,759 --> 00:22:20,799
these at compile time

00:22:17,259 --> 00:22:23,139
so for pattern matching this was only

00:22:20,799 --> 00:22:25,450
introduced in Scala 2.11 so it's still

00:22:23,139 --> 00:22:27,940
pretty recent it's called name based

00:22:25,450 --> 00:22:29,619
extractors a haiku is a beggar who may

00:22:27,940 --> 00:22:31,389
never talk here on this conference

00:22:29,619 --> 00:22:33,249
actually wrote a very nice blog post

00:22:31,389 --> 00:22:35,559
about it at the time and it's an

00:22:33,249 --> 00:22:38,409
optimization it avoids a couple of

00:22:35,559 --> 00:22:40,389
allocations but as a optimizations go

00:22:38,409 --> 00:22:41,979
are you should be a bit cautious with

00:22:40,389 --> 00:22:43,509
that it doesn't really make your classes

00:22:41,979 --> 00:22:45,879
more beautiful white people are going to

00:22:43,509 --> 00:22:49,719
wonder what's this underscore one doing

00:22:45,879 --> 00:22:51,009
or underscore two in your class or a

00:22:49,719 --> 00:22:53,049
couple of things you should or shouldn't

00:22:51,009 --> 00:22:54,669
do with with pattern matching well

00:22:53,049 --> 00:22:57,309
though pattern matching is nice and

00:22:54,669 --> 00:22:58,479
useful but of course there are things or

00:22:57,309 --> 00:23:00,129
there are cases where you shouldn't use

00:22:58,479 --> 00:23:01,929
it which I don't even talk about but

00:23:00,129 --> 00:23:03,999
there are also some things that might go

00:23:01,929 --> 00:23:11,469
wrong what's wrong with this yes

00:23:03,999 --> 00:23:15,580
does anyone see it at first sight which

00:23:11,469 --> 00:23:20,320
annotation okay oh I didn't even think

00:23:15,580 --> 00:23:21,399
of that yeah but in terms of so this is

00:23:20,320 --> 00:23:25,389
actually it's an interesting one this

00:23:21,399 --> 00:23:27,249
one this one so it it's again it's our

00:23:25,389 --> 00:23:30,609
our contains five thing it should work

00:23:27,249 --> 00:23:32,679
if I have a list that contains some five

00:23:30,609 --> 00:23:35,739
a five in some way weight

00:23:32,679 --> 00:23:39,519
so it's called contains five and I give

00:23:35,739 --> 00:23:43,110
it a list one two or eight one two three

00:23:39,519 --> 00:23:47,010
four five say right so this would be yes

00:23:43,110 --> 00:23:49,830
I could also of course it takes any

00:23:47,010 --> 00:23:52,799
sequence right I can take can say it's a

00:23:49,830 --> 00:24:01,460
Sikh it was their work I can say it's a

00:23:52,799 --> 00:24:03,840
vector vector and it doesn't hmm that's

00:24:01,460 --> 00:24:05,880
so it's it's annoying in a couple of

00:24:03,840 --> 00:24:08,700
ways so that the problem here of course

00:24:05,880 --> 00:24:12,779
is the type whatever I accept for the

00:24:08,700 --> 00:24:15,000
mattress just has to be a Sikh the um

00:24:12,779 --> 00:24:17,700
what's with a double colon right the

00:24:15,000 --> 00:24:20,639
double colon again is our extractor but

00:24:17,700 --> 00:24:25,769
this one in it's an apply method doesn't

00:24:20,639 --> 00:24:28,230
take a Sikh it takes a list and I told

00:24:25,769 --> 00:24:30,269
you're the type just as with the any and

00:24:28,230 --> 00:24:32,399
the time thing right I can have an NES

00:24:30,269 --> 00:24:34,049
there as my mentor value and have an

00:24:32,399 --> 00:24:36,000
unapplied that only takes a time that

00:24:34,049 --> 00:24:37,710
will not take will not result in the

00:24:36,000 --> 00:24:39,630
compiler error but at one time it's

00:24:37,710 --> 00:24:41,070
going to check if the times met it's

00:24:39,630 --> 00:24:43,519
going to do the instance of thing and

00:24:41,070 --> 00:24:45,929
then it's just it's just not gonna match

00:24:43,519 --> 00:24:48,269
so this is and this happens all the time

00:24:45,929 --> 00:24:50,190
people do this all the time I think it's

00:24:48,269 --> 00:24:52,320
actually an error that we didn't put

00:24:50,190 --> 00:24:56,549
double the double colon somewhere else

00:24:52,320 --> 00:24:58,289
or or we move it whenever Wendy so what

00:24:56,549 --> 00:25:00,120
it's very easy to avoid this if you just

00:24:58,289 --> 00:25:02,820
use the plus colon which is defined on

00:25:00,120 --> 00:25:05,850
seek right or well or your only work

00:25:02,820 --> 00:25:07,679
with this so double colon is a case

00:25:05,850 --> 00:25:11,880
class second parameter is a or the

00:25:07,679 --> 00:25:13,649
second class parameter is a list okay so

00:25:11,880 --> 00:25:15,929
in the under yeah oh it's a case class

00:25:13,649 --> 00:25:17,940
so the UH applies in a companion object

00:25:15,929 --> 00:25:22,740
there so and the the unemployed takes a

00:25:17,940 --> 00:25:24,539
list so um this is the difference so I

00:25:22,740 --> 00:25:27,149
think the double colon looks prettier

00:25:24,539 --> 00:25:29,039
but it's really safer to use the other

00:25:27,149 --> 00:25:30,929
one oh this and there's the reverse of

00:25:29,039 --> 00:25:33,090
that right there's a plus colon and

00:25:30,929 --> 00:25:35,039
there's the colon plus but it gives you

00:25:33,090 --> 00:25:38,750
the last element of your your collection

00:25:35,039 --> 00:25:38,750
how about this is this a good idea

00:25:39,409 --> 00:25:46,559
because I was people say no okay right

00:25:44,460 --> 00:25:48,210
and what do we pass in as a type if it

00:25:46,559 --> 00:25:50,309
was a vector what matter that much there

00:25:48,210 --> 00:25:53,340
we have constant access time but here

00:25:50,309 --> 00:25:56,100
it's we put in a list and a list takes

00:25:53,340 --> 00:25:56,470
has a linear complexity to get through

00:25:56,100 --> 00:25:59,230
the

00:25:56,470 --> 00:26:01,690
and to any element other than the first

00:25:59,230 --> 00:26:04,210
one right so here we can equip of that

00:26:01,690 --> 00:26:06,580
we go from linear complexity to a

00:26:04,210 --> 00:26:09,850
polynomial because for each we iterate

00:26:06,580 --> 00:26:11,770
over the list and in each iteration this

00:26:09,850 --> 00:26:13,179
one will iterate over the list as well

00:26:11,770 --> 00:26:15,280
because it has to get through the last

00:26:13,179 --> 00:26:19,919
element so don't do this this is very

00:26:15,280 --> 00:26:22,360
inefficient so now we have this here and

00:26:19,919 --> 00:26:24,190
this it we're very curious and we just

00:26:22,360 --> 00:26:26,110
want to know what does a compiler make

00:26:24,190 --> 00:26:28,210
of this I have to talk a bit faster now

00:26:26,110 --> 00:26:30,280
because I'm not gonna make it in time we

00:26:28,210 --> 00:26:32,200
only have 15 islets and it's only and

00:26:30,280 --> 00:26:35,860
I'm only getting started this was just

00:26:32,200 --> 00:26:37,600
the introduction so say I know that the

00:26:35,860 --> 00:26:39,429
compiler we now know okay there's a lot

00:26:37,600 --> 00:26:41,169
of detail going going on and there's

00:26:39,429 --> 00:26:42,700
gonna be some matching in some instance

00:26:41,169 --> 00:26:44,500
off and what the hell I want to see what

00:26:42,700 --> 00:26:47,409
the compiler makes of this how do I see

00:26:44,500 --> 00:26:48,970
what the compiler does this do you know

00:26:47,409 --> 00:26:51,820
have you looked at the compiler faces so

00:26:48,970 --> 00:26:53,830
you can you can print out the syntax

00:26:51,820 --> 00:26:57,460
tree of your program after compilation

00:26:53,830 --> 00:27:01,179
phases the Scala compiler is 25 or 27

00:26:57,460 --> 00:27:05,470
faces or so and 25 okay oh it's online

00:27:01,179 --> 00:27:07,659
and you see phase 5 is translate match

00:27:05,470 --> 00:27:09,549
expressions that's exactly what we're

00:27:07,659 --> 00:27:13,510
interested in that's great so I start a

00:27:09,549 --> 00:27:16,750
scanner ripple and say Scala scholar

00:27:13,510 --> 00:27:19,600
minus X print and then I say the

00:27:16,750 --> 00:27:21,130
compiler face which is Pat match and I

00:27:19,600 --> 00:27:24,669
actually prepare this earlier so I

00:27:21,130 --> 00:27:26,919
already have this here um I took if I

00:27:24,669 --> 00:27:31,960
prepared that one and so let's paste

00:27:26,919 --> 00:27:34,230
this in where was it I have to close

00:27:31,960 --> 00:27:40,059
this one otherwise I get confused um

00:27:34,230 --> 00:27:41,440
said paste I do this and everything I

00:27:40,059 --> 00:27:42,340
told you you can actually see here I

00:27:41,440 --> 00:27:46,049
hope so

00:27:42,340 --> 00:27:48,549
what that we do we define the case class

00:27:46,049 --> 00:27:51,090
when you find the Kate let's couldn't go

00:27:48,549 --> 00:27:51,090
back to the slide

00:27:53,370 --> 00:27:58,720
when you find a case last time and we

00:27:56,350 --> 00:28:00,250
have this pattern match here so here's

00:27:58,720 --> 00:28:02,680
our case last definition of course it's

00:28:00,250 --> 00:28:04,720
not super we table but here and we have

00:28:02,680 --> 00:28:07,660
an object and this is our companion

00:28:04,720 --> 00:28:10,420
object it extends abstract function and

00:28:07,660 --> 00:28:11,890
it has an unemployment just as we would

00:28:10,420 --> 00:28:14,770
expect it takes a time as a parameter

00:28:11,890 --> 00:28:16,870
returns an option of minutes and hours

00:28:14,770 --> 00:28:19,690
oh well hours and minutes and it does

00:28:16,870 --> 00:28:23,560
some stuff here and then the where are

00:28:19,690 --> 00:28:25,440
we um the actual pattern match so this

00:28:23,560 --> 00:28:27,790
is all the parametric is translated into

00:28:25,440 --> 00:28:29,850
conditional expressions why what's

00:28:27,790 --> 00:28:34,390
interesting here is if you look at this

00:28:29,850 --> 00:28:36,220
we know that these these case

00:28:34,390 --> 00:28:37,720
expressions they are basically evaluated

00:28:36,220 --> 00:28:40,780
line by line right it's going to check

00:28:37,720 --> 00:28:42,580
for the first condition if this if this

00:28:40,780 --> 00:28:45,010
holds true it's just going to execute

00:28:42,580 --> 00:28:47,740
this and then it goes to the next one

00:28:45,010 --> 00:28:49,510
but under the hood it's actually the

00:28:47,740 --> 00:28:51,340
whole pattern match expression is

00:28:49,510 --> 00:28:53,530
actually passed and it creates a tree of

00:28:51,340 --> 00:28:55,330
that so there's a little bit we can see

00:28:53,530 --> 00:28:57,280
right here for example this is incidence

00:28:55,330 --> 00:28:58,930
off which I told you earlier it's going

00:28:57,280 --> 00:29:01,660
to check for the type before it actually

00:28:58,930 --> 00:29:03,790
does the invocation um it's only X is

00:29:01,660 --> 00:29:07,060
only applied once right it only checks

00:29:03,790 --> 00:29:09,370
once if it's an instance of time and and

00:29:07,060 --> 00:29:11,170
then does the cast and then we have our

00:29:09,370 --> 00:29:14,380
guards here at X if the hours bigger

00:29:11,170 --> 00:29:16,150
than 11 or of the hour is less than 7

00:29:14,380 --> 00:29:24,010
which probably doesn't even make sense

00:29:16,150 --> 00:29:28,540
but never mind um and so the the result

00:29:24,010 --> 00:29:31,390
of the the the pattern match phase of

00:29:28,540 --> 00:29:33,820
the compiler it will actually be is kind

00:29:31,390 --> 00:29:37,600
of a decision tree white it's to

00:29:33,820 --> 00:29:39,580
optimize the the execution obviously and

00:29:37,600 --> 00:29:41,680
to see this I think the only real way to

00:29:39,580 --> 00:29:44,470
see is to look at the syntax tree after

00:29:41,680 --> 00:29:49,480
the Patman face this is how you do it

00:29:44,470 --> 00:29:51,490
again be a bit quick about this while we

00:29:49,480 --> 00:29:53,440
just have is I just switch this on so

00:29:51,490 --> 00:29:55,510
let's have another look case classes

00:29:53,440 --> 00:29:57,280
have you have you run into the 22 field

00:29:55,510 --> 00:29:58,750
issue in Scala if you've done that a

00:29:57,280 --> 00:30:01,270
little scallop program you know tuples

00:29:58,750 --> 00:30:04,190
functions there's this limit there's no

00:30:01,270 --> 00:30:06,730
variable argument tuple or no variable

00:30:04,190 --> 00:30:08,960
a number of arguments functions for each

00:30:06,730 --> 00:30:10,970
number of arguments there is a separate

00:30:08,960 --> 00:30:15,529
class for this function 1 2 3 and it

00:30:10,970 --> 00:30:18,440
goes up to 22 so now this for some

00:30:15,529 --> 00:30:21,830
reason I just can't come live with that

00:30:18,440 --> 00:30:24,019
I have this case class that has 23

00:30:21,830 --> 00:30:27,350
fields so what's going to happen here I

00:30:24,019 --> 00:30:31,039
define these case classes oh that's too

00:30:27,350 --> 00:30:32,570
much anybody wants to have a guess is a

00:30:31,039 --> 00:30:39,350
compiler going to take it or is it gonna

00:30:32,570 --> 00:30:42,379
be an error or is it hmm it doesn't like

00:30:39,350 --> 00:30:44,299
it that was so ok I don't think it's

00:30:42,379 --> 00:30:47,720
gonna tell us that uh-huh

00:30:44,299 --> 00:30:50,990
so kind of did it no error there it did

00:30:47,720 --> 00:30:52,639
it yeah so in I don't remember which

00:30:50,990 --> 00:30:55,070
version but at some point for case

00:30:52,639 --> 00:30:58,129
classes the 22 field limit was dropped

00:30:55,070 --> 00:31:00,049
and what for people but for all the

00:30:58,129 --> 00:31:01,909
other stuff in the for example let's

00:31:00,049 --> 00:31:11,000
look at the companion object if we look

00:31:01,909 --> 00:31:17,690
do we find this here copy with this is

00:31:11,000 --> 00:31:20,419
t2 hmm that was easier the last time so

00:31:17,690 --> 00:31:23,570
this is our companion object 42 two

00:31:20,419 --> 00:31:25,549
fields that implements abstract function

00:31:23,570 --> 00:31:27,470
true with serializable has all the stuff

00:31:25,549 --> 00:31:30,769
has an apply has a nun apply and so on

00:31:27,470 --> 00:31:32,509
and then we have the our T 23 and

00:31:30,769 --> 00:31:37,639
somewhere there's the companion object

00:31:32,509 --> 00:31:40,250
for that object T 23 oh that's a bit

00:31:37,639 --> 00:31:41,840
shorter right because we don't have the

00:31:40,250 --> 00:31:44,539
we don't have the Topol 22 the abstract

00:31:41,840 --> 00:31:46,399
ransom 22 and so on so the what you get

00:31:44,539 --> 00:31:48,919
into is you can't you can have case

00:31:46,399 --> 00:31:50,240
classes with more than 22 fields but

00:31:48,919 --> 00:31:52,370
they don't there were a couple of

00:31:50,240 --> 00:31:53,840
properties they don't have they don't

00:31:52,370 --> 00:31:55,370
have a none apply method but they don't

00:31:53,840 --> 00:31:57,289
have a toppled untroubled method things

00:31:55,370 --> 00:32:00,649
like that so you can have these case

00:31:57,289 --> 00:32:02,720
classes but the companion object does

00:32:00,649 --> 00:32:04,580
not have a none apply so now we just

00:32:02,720 --> 00:32:06,769
realize we just have been talking for a

00:32:04,580 --> 00:32:08,690
half an hour about the extractor objects

00:32:06,769 --> 00:32:13,159
and companion objects are extractors as

00:32:08,690 --> 00:32:15,799
well and that unflyable to to do this so

00:32:13,159 --> 00:32:17,730
what will happen if I have a pattern

00:32:15,799 --> 00:32:21,160
match

00:32:17,730 --> 00:32:34,330
where I want to match against a 23 field

00:32:21,160 --> 00:32:37,200
place class any guesses pun yeah that's

00:32:34,330 --> 00:32:41,620
a shame because that's the right answer

00:32:37,200 --> 00:32:47,520
so it compiles it once I can now match I

00:32:41,620 --> 00:32:50,860
can say match T 23 and it works because

00:32:47,520 --> 00:32:53,110
well like so maybe at some point in time

00:32:50,860 --> 00:32:55,780
it was the case that the unemployment

00:32:53,110 --> 00:32:57,400
was used but although the companion

00:32:55,780 --> 00:32:59,680
objects of case classes usually have the

00:32:57,400 --> 00:33:02,230
UH apply in pattern matching is a it's

00:32:59,680 --> 00:33:03,730
not used in case classes the pattern

00:33:02,230 --> 00:33:06,610
match will just use the field values

00:33:03,730 --> 00:33:09,640
directly and I think we could we we

00:33:06,610 --> 00:33:12,280
actually saw this earlier

00:33:09,640 --> 00:33:16,630
for example here with the hours or I

00:33:12,280 --> 00:33:20,050
don't find this right now but if I would

00:33:16,630 --> 00:33:22,300
paste it again or you can try this out

00:33:20,050 --> 00:33:24,970
at home you will see if you look at the

00:33:22,300 --> 00:33:27,040
syntax tree again after the Pat met face

00:33:24,970 --> 00:33:28,210
with case classes the unemployment is

00:33:27,040 --> 00:33:30,790
just not going to be there it's just

00:33:28,210 --> 00:33:32,710
going to access the fields directly so

00:33:30,790 --> 00:33:34,240
this is kind of an optimization that

00:33:32,710 --> 00:33:35,890
hasn't been done for case classes and

00:33:34,240 --> 00:33:38,080
that was also the order of things there

00:33:35,890 --> 00:33:39,850
was the we had the 22 field image then

00:33:38,080 --> 00:33:41,290
somebody said oh and pattern matching we

00:33:39,850 --> 00:33:42,700
don't actually have to use the uh apply

00:33:41,290 --> 00:33:45,520
for case classes constants the case

00:33:42,700 --> 00:33:48,010
class we know by definition the pattern

00:33:45,520 --> 00:33:50,080
match it works with the first argument

00:33:48,010 --> 00:33:53,110
list of the former you construct or

00:33:50,080 --> 00:33:54,940
whatever and and so we don't have to

00:33:53,110 --> 00:33:56,380
rely on an apply we can just access the

00:33:54,940 --> 00:33:59,320
fields directly make this optimization

00:33:56,380 --> 00:34:01,420
when somebody said can we maybe drop the

00:33:59,320 --> 00:34:03,730
22 field limit and people said oh well

00:34:01,420 --> 00:34:06,160
let's think the unapplied or we don't

00:34:03,730 --> 00:34:07,630
use this and parametric anyway so yeah

00:34:06,160 --> 00:34:10,890
why not drop the limit so you can

00:34:07,630 --> 00:34:13,890
pattern match with more than 22 fields

00:34:10,890 --> 00:34:13,890
so

00:34:17,839 --> 00:34:24,530
very good question I can answer though

00:34:20,010 --> 00:34:24,530
let me think about that hmm

00:34:25,460 --> 00:34:29,819
what if you don't know the number of

00:34:27,569 --> 00:34:30,659
variables we saw a matching with one

00:34:29,819 --> 00:34:32,339
variable also

00:34:30,659 --> 00:34:34,800
after the match binding to one binding

00:34:32,339 --> 00:34:37,700
to two variables well you can also sorry

00:34:34,800 --> 00:34:40,169
for the broken slide here you can have a

00:34:37,700 --> 00:34:41,760
variable number of variables right and

00:34:40,169 --> 00:34:43,710
we had this in our sequence example

00:34:41,760 --> 00:34:45,450
earlier when we didn't use the plus

00:34:43,710 --> 00:34:47,550
colon syntax but we use the underscore

00:34:45,450 --> 00:34:51,359
fourth kind of construct the like syntax

00:34:47,550 --> 00:34:52,770
and this happens with there's an

00:34:51,359 --> 00:34:55,770
alternative to unemployed which is

00:34:52,770 --> 00:34:59,520
called uh apply seek and there you can

00:34:55,770 --> 00:35:01,470
actually return a sequence so it just

00:34:59,520 --> 00:35:04,619
has to match the sequence usually so you

00:35:01,470 --> 00:35:06,030
can work with a and a variable number of

00:35:04,619 --> 00:35:08,640
arguments in your pattern match which is

00:35:06,030 --> 00:35:12,300
very useful for example here can be

00:35:08,640 --> 00:35:14,520
useful also with maybe with regular

00:35:12,300 --> 00:35:16,230
expressions I told you the your

00:35:14,520 --> 00:35:17,640
extractor objects don't have to be

00:35:16,230 --> 00:35:19,710
singleton objects they don't have to be

00:35:17,640 --> 00:35:21,270
named objects you can use any instance

00:35:19,710 --> 00:35:23,130
you have you can create a class that has

00:35:21,270 --> 00:35:25,440
a none apply method and each instance

00:35:23,130 --> 00:35:27,510
you create on this class can be used as

00:35:25,440 --> 00:35:29,520
an extractor this is the case for scala

00:35:27,510 --> 00:35:32,250
util reg X or what's the called util

00:35:29,520 --> 00:35:34,109
matching ray X so whenever you you use

00:35:32,250 --> 00:35:36,780
the e string or you have your pattern

00:35:34,109 --> 00:35:38,540
dot R and create your X you can use this

00:35:36,780 --> 00:35:43,950
regular expression in a pattern match

00:35:38,540 --> 00:35:46,290
and it gets even better so you can also

00:35:43,950 --> 00:35:48,839
wide string contexts Y this is how the

00:35:46,290 --> 00:35:51,630
the the substitution the string

00:35:48,839 --> 00:35:53,310
interpolator works right it creates a

00:35:51,630 --> 00:35:55,980
string context that will replace your

00:35:53,310 --> 00:35:58,740
fields with with variables or with the

00:35:55,980 --> 00:36:00,510
values of them and you can give that a

00:35:58,740 --> 00:36:05,369
none apply method or whether and an

00:36:00,510 --> 00:36:07,609
apply C right so in this case this will

00:36:05,369 --> 00:36:11,520
match whenever this regular expression

00:36:07,609 --> 00:36:13,230
if the string that we provide matches

00:36:11,520 --> 00:36:14,609
this regular expression which says it

00:36:13,230 --> 00:36:17,550
has to be a number with one or two

00:36:14,609 --> 00:36:20,069
digits with a colon and another number

00:36:17,550 --> 00:36:25,440
with one or two digits so it's could be

00:36:20,069 --> 00:36:28,340
a time again right so um and then I have

00:36:25,440 --> 00:36:33,220
to go back to execute it f4

00:36:28,340 --> 00:36:37,400
I think if I do this and the next one I

00:36:33,220 --> 00:36:38,660
can create another time twelve oh no of

00:36:37,400 --> 00:36:43,160
course not no I'm just using a string

00:36:38,660 --> 00:36:46,880
right I can say it's time nine and this

00:36:43,160 --> 00:36:51,410
is not a string this is also another

00:36:46,880 --> 00:36:56,180
string and this is one and if I would

00:36:51,410 --> 00:36:58,520
just say New York City it's not a time

00:36:56,180 --> 00:37:01,640
right and this is a pretty nice syntax I

00:36:58,520 --> 00:37:03,260
guess and a lot of people don't know

00:37:01,640 --> 00:37:05,300
that you can do this so the way this

00:37:03,260 --> 00:37:06,830
works with this T notation but pretty

00:37:05,300 --> 00:37:08,840
similar to the string interpolation you

00:37:06,830 --> 00:37:11,300
do with the s is that it creates a

00:37:08,840 --> 00:37:14,060
string context let me go back a slide

00:37:11,300 --> 00:37:16,160
here and you can put an unapplied in the

00:37:14,060 --> 00:37:16,880
string context so you can you can do

00:37:16,160 --> 00:37:19,520
this

00:37:16,880 --> 00:37:21,350
oh this vector notation oh that's a good

00:37:19,520 --> 00:37:23,210
one have you come across the spiritual

00:37:21,350 --> 00:37:25,220
notation it's also it's a funny a

00:37:23,210 --> 00:37:28,820
notation for example the place you put

00:37:25,220 --> 00:37:31,160
it right so you put it behind your your

00:37:28,820 --> 00:37:33,170
mash regular and what does this do with

00:37:31,160 --> 00:37:35,690
this picture notation so the switch and

00:37:33,170 --> 00:37:38,240
Java is actually just a sort of a

00:37:35,690 --> 00:37:40,280
manifestation of byte code there is

00:37:38,240 --> 00:37:42,050
actually a switch what's called switch

00:37:40,280 --> 00:37:44,930
table or lookup table I forgot the name

00:37:42,050 --> 00:37:46,820
in Java bytecode but that only works

00:37:44,930 --> 00:37:49,280
well in the way the switch in Java works

00:37:46,820 --> 00:37:52,640
it only works with constants and as of

00:37:49,280 --> 00:37:55,340
Java 6 with Scala pre 212 compiles to

00:37:52,640 --> 00:38:01,100
not even within contents so constants so

00:37:55,340 --> 00:38:03,290
it has to be numbers basically and so

00:38:01,100 --> 00:38:04,790
and this is a bit more efficient we saw

00:38:03,290 --> 00:38:08,270
the conditional expressions why the

00:38:04,790 --> 00:38:10,490
methods case 1 2 3 4 5 6 7 8 and there

00:38:08,270 --> 00:38:11,960
lot of meta calls involved but if you

00:38:10,490 --> 00:38:14,510
can do this on the by code level can

00:38:11,960 --> 00:38:17,660
just can use the actual lookup switch

00:38:14,510 --> 00:38:20,270
there then that's a bit faster so this

00:38:17,660 --> 00:38:22,400
annotation if I do something like this

00:38:20,270 --> 00:38:27,680
where I have different types and this

00:38:22,400 --> 00:38:28,460
cannot be cannot be translated or we're

00:38:27,680 --> 00:38:33,530
kind of doing here

00:38:28,460 --> 00:38:37,550
to the to the lookup switch with what

00:38:33,530 --> 00:38:40,660
did I call this so this one would not

00:38:37,550 --> 00:38:40,660
hear the a warning

00:38:41,480 --> 00:38:50,490
here let me get this happily present and

00:38:48,869 --> 00:39:01,740
I paste this here okay that's gonna give

00:38:50,490 --> 00:39:03,900
a lot of outfit I guess hmm could not

00:39:01,740 --> 00:39:06,690
limits with force which annotated match

00:39:03,900 --> 00:39:09,030
right so it could not be translated into

00:39:06,690 --> 00:39:12,480
a lookup swiftlets oh well let's look at

00:39:09,030 --> 00:39:15,869
it angry um so the other one the

00:39:12,480 --> 00:39:19,880
previous one would create very different

00:39:15,869 --> 00:39:23,700
code I know if I paste it from here I

00:39:19,880 --> 00:39:26,780
get all the the stars within their just

00:39:23,700 --> 00:39:26,780
paste it from here

00:39:33,600 --> 00:39:38,550
you see the yeah this is after the

00:39:37,230 --> 00:39:40,950
patent face it just still looks like

00:39:38,550 --> 00:39:45,080
this is later gonna be translated to as

00:39:40,950 --> 00:39:46,530
I said the bytecode the lookups fiction

00:39:45,080 --> 00:39:53,460
Java bytecode

00:39:46,530 --> 00:39:55,920
um interestingly it well let's say what

00:39:53,460 --> 00:39:58,110
about this now I have this these could

00:39:55,920 --> 00:40:00,450
be these are just integer constants so

00:39:58,110 --> 00:40:02,970
these could be translated into lookups

00:40:00,450 --> 00:40:04,560
which bytecode I used the switch

00:40:02,970 --> 00:40:06,600
annotation for one of those and not for

00:40:04,560 --> 00:40:09,510
the other what's gonna happen is this

00:40:06,600 --> 00:40:11,430
gonna be different by code Oh times up

00:40:09,510 --> 00:40:15,900
I'm just gonna use the next five minutes

00:40:11,430 --> 00:40:17,250
anyway um what do you think well I'll

00:40:15,900 --> 00:40:19,230
just give you the answer it's going to

00:40:17,250 --> 00:40:20,550
result in the same bytecode it's an

00:40:19,230 --> 00:40:21,270
annotation it's like the tail back

00:40:20,550 --> 00:40:23,550
annotation

00:40:21,270 --> 00:40:26,450
it's an annotation that expresses the

00:40:23,550 --> 00:40:28,920
developer's intent right I say I believe

00:40:26,450 --> 00:40:30,600
this Swift annotation I wrote here can

00:40:28,920 --> 00:40:33,510
be translated into the lookups which

00:40:30,600 --> 00:40:35,880
bytecode just as with tail back where I

00:40:33,510 --> 00:40:38,700
say I asked the developer I believe this

00:40:35,880 --> 00:40:40,560
is tail recursive the compiler will make

00:40:38,700 --> 00:40:42,630
the tail call optimization anyway even

00:40:40,560 --> 00:40:44,640
if it's a recursive the compiler will

00:40:42,630 --> 00:40:48,300
optimize it if I use the annotation or

00:40:44,640 --> 00:40:51,300
not but maybe I think it is and it isn't

00:40:48,300 --> 00:40:53,040
which would be bad so I have this

00:40:51,300 --> 00:40:55,080
possibility to express this intent and

00:40:53,040 --> 00:40:56,280
get the warning if it's not and this is

00:40:55,080 --> 00:41:00,660
exactly the same with the special

00:40:56,280 --> 00:41:04,440
notation yeah and that's about it so you

00:41:00,660 --> 00:41:06,870
can also you can kind of get around Java

00:41:04,440 --> 00:41:08,820
type arranger with pattern matching but

00:41:06,870 --> 00:41:10,650
it really uses implicit and uses the

00:41:08,820 --> 00:41:11,820
class tag right but you can use this in

00:41:10,650 --> 00:41:14,520
pair for measuring but this of course

00:41:11,820 --> 00:41:16,200
does not work here would always say list

00:41:14,520 --> 00:41:19,050
of strings no matter what you put in

00:41:16,200 --> 00:41:22,980
because at one time the the type

00:41:19,050 --> 00:41:24,630
parameters are erased on the JVM but we

00:41:22,980 --> 00:41:26,580
have something in Scala called the class

00:41:24,630 --> 00:41:29,040
tag oh there's also a type tag but here

00:41:26,580 --> 00:41:31,380
I use the class tag and this will sort

00:41:29,040 --> 00:41:33,210
of the compiler will enrich this

00:41:31,380 --> 00:41:36,690
information will enrich this this match

00:41:33,210 --> 00:41:38,550
and provide the actual the type

00:41:36,690 --> 00:41:41,790
parameter of it so you can actually

00:41:38,550 --> 00:41:43,530
match on the on the type parameter and

00:41:41,790 --> 00:41:47,100
it will distinguish between classes or

00:41:43,530 --> 00:41:49,560
like lists of indent lists of strings

00:41:47,100 --> 00:41:51,870
you can also match against types you can

00:41:49,560 --> 00:41:54,090
have met alternatives you can actually

00:41:51,870 --> 00:41:55,770
match against type alternatives which

00:41:54,090 --> 00:41:57,840
are fairly interesting you can use this

00:41:55,770 --> 00:42:02,360
ad to bind the result of your hold

00:41:57,840 --> 00:42:05,760
expression to some some variable and oh

00:42:02,360 --> 00:42:07,380
I messed around with this code but the

00:42:05,760 --> 00:42:08,940
funny thing else is I think the notation

00:42:07,380 --> 00:42:11,040
is kind of funny with e with the

00:42:08,940 --> 00:42:13,230
alternatives and the types there it's a

00:42:11,040 --> 00:42:15,540
bit like as if there were a union types

00:42:13,230 --> 00:42:17,430
wide if as if I could define the type

00:42:15,540 --> 00:42:19,860
that this either end or long in this

00:42:17,430 --> 00:42:21,540
case or string or indoors like the Union

00:42:19,860 --> 00:42:22,590
times if you saw Martins keynote the

00:42:21,540 --> 00:42:26,250
Union types that are going to be

00:42:22,590 --> 00:42:27,960
introduced and dotty it's not gonna the

00:42:26,250 --> 00:42:29,370
compiler does not infer union type

00:42:27,960 --> 00:42:31,560
though in Scala there is no Union type

00:42:29,370 --> 00:42:33,450
in Scala so he's just gonna be any at

00:42:31,560 --> 00:42:35,850
compile time we don't have Union times

00:42:33,450 --> 00:42:37,230
yet it will be interesting to see how

00:42:35,850 --> 00:42:39,300
that works and Dottie probably it will

00:42:37,230 --> 00:42:42,420
the resulting type will be the Union

00:42:39,300 --> 00:42:43,890
type it makes sense so to sum it up why

00:42:42,420 --> 00:42:46,740
do I think parametric is interesting

00:42:43,890 --> 00:42:49,020
it's I think it's kind of it's Scala

00:42:46,740 --> 00:42:52,200
asking the ways what I mean is a lot of

00:42:49,020 --> 00:42:53,970
things we see in parametric are patterns

00:42:52,200 --> 00:42:56,700
that we see in other parts of scale as

00:42:53,970 --> 00:42:59,670
well for example it's not built-in in

00:42:56,700 --> 00:43:01,410
the syntax the things we you see it's I

00:42:59,670 --> 00:43:11,580
told you about extract or objects right

00:43:01,410 --> 00:43:13,740
we don't have keywords like yeah I would

00:43:11,580 --> 00:43:18,270
say it uses unapplied yeah that's not

00:43:13,740 --> 00:43:21,060
the case class right so yeah no I don't

00:43:18,270 --> 00:43:23,160
think it's a special case no it just the

00:43:21,060 --> 00:43:24,270
the Reg X class actually has an

00:43:23,160 --> 00:43:27,420
underflow method yeah man

00:43:24,270 --> 00:43:29,580
so each instance has two so it's in the

00:43:27,420 --> 00:43:31,020
library that's very common oh that's one

00:43:29,580 --> 00:43:33,000
of the principles and scallops you can

00:43:31,020 --> 00:43:34,770
do it in the library give the power to

00:43:33,000 --> 00:43:36,660
the developers to the library developers

00:43:34,770 --> 00:43:39,930
you can use the funny names for your

00:43:36,660 --> 00:43:41,850
objects like double colon and plus : so

00:43:39,930 --> 00:43:43,620
and so it looks like like language

00:43:41,850 --> 00:43:45,350
syntax but it's really just library

00:43:43,620 --> 00:43:47,820
methods or objects as we know it now

00:43:45,350 --> 00:43:49,650
there are a couple of conventions that

00:43:47,820 --> 00:43:51,660
play that like rules you should we saw

00:43:49,650 --> 00:43:53,250
the uppercase thing and and of course

00:43:51,660 --> 00:43:55,050
the unapplied thing we never why done

00:43:53,250 --> 00:43:56,970
apply pretty much like we never write

00:43:55,050 --> 00:43:58,350
apply so these are things that happen in

00:43:56,970 --> 00:44:01,440
the background you that you just have

00:43:58,350 --> 00:44:04,320
know there's a lot of flexibility and

00:44:01,440 --> 00:44:06,510
types pretty much like and for

00:44:04,320 --> 00:44:08,430
expressions you can return anything from

00:44:06,510 --> 00:44:11,220
from your uh apply but it's still

00:44:08,430 --> 00:44:12,930
checked at compile-time also a very

00:44:11,220 --> 00:44:14,880
important principle and Scala anything

00:44:12,930 --> 00:44:16,320
you can check in compiled time you check

00:44:14,880 --> 00:44:18,180
at compile time because we want this

00:44:16,320 --> 00:44:19,590
type safety there and you couldn't of

00:44:18,180 --> 00:44:25,260
course build your own make it look like

00:44:19,590 --> 00:44:28,080
language syntax and lastly is scalloped

00:44:25,260 --> 00:44:29,970
pattern matching simple so I think it is

00:44:28,080 --> 00:44:31,860
in a way right so I could talk about

00:44:29,970 --> 00:44:34,020
this obviously I've talked about this

00:44:31,860 --> 00:44:36,870
for 45 minutes now so that there's a lot

00:44:34,020 --> 00:44:38,940
to say about parametric but there was an

00:44:36,870 --> 00:44:41,310
interview with Martin once about

00:44:38,940 --> 00:44:43,080
simplicity and I I don't remember the

00:44:41,310 --> 00:44:44,460
exact words but it was of the sort of

00:44:43,080 --> 00:44:46,290
the general director was there are

00:44:44,460 --> 00:44:48,840
different kinds of simplicity you can

00:44:46,290 --> 00:44:51,030
have a very simple language in a man in

00:44:48,840 --> 00:44:52,950
in the sense that it has a very simple

00:44:51,030 --> 00:44:54,840
specification that they were very so

00:44:52,950 --> 00:44:56,910
it's very limited as what you can do

00:44:54,840 --> 00:44:58,500
with it what can express that makes the

00:44:56,910 --> 00:45:01,200
language specification simple but the

00:44:58,500 --> 00:45:04,050
resulting code might be you know might

00:45:01,200 --> 00:45:06,240
be horrible and for scholar of course

00:45:04,050 --> 00:45:08,550
the objective was was a different one we

00:45:06,240 --> 00:45:10,410
define these all these accept all these

00:45:08,550 --> 00:45:13,920
rules and these conventions they're for

00:45:10,410 --> 00:45:16,080
pattern matching so there's a lot that

00:45:13,920 --> 00:45:18,210
you can know about it but the resulting

00:45:16,080 --> 00:45:19,680
code I think can be can be very clear

00:45:18,210 --> 00:45:21,900
and very simple because now we can

00:45:19,680 --> 00:45:23,580
actually write things as we did like

00:45:21,900 --> 00:45:25,020
iterating over collections by

00:45:23,580 --> 00:45:27,480
deconstructing them and things like that

00:45:25,020 --> 00:45:30,540
so I would say yes pattern matching is

00:45:27,480 --> 00:45:31,860
is simple in this sense and it's another

00:45:30,540 --> 00:45:34,890
reason why it's interesting because it

00:45:31,860 --> 00:45:38,400
corresponds with the the complexity and

00:45:34,890 --> 00:45:39,840
simplicity of Scala and I'm sorry for

00:45:38,400 --> 00:45:42,450
taking all the time for the talk so

00:45:39,840 --> 00:45:44,460
technically there's no no time for

00:45:42,450 --> 00:45:45,960
questions but there's no other talk so

00:45:44,460 --> 00:45:50,360
you can still ask questions if you want

00:45:45,960 --> 00:45:50,360
to and please yeah that was it thank you

00:45:51,720 --> 00:45:53,780

YouTube URL: https://www.youtube.com/watch?v=BIt3jLLGY0s


