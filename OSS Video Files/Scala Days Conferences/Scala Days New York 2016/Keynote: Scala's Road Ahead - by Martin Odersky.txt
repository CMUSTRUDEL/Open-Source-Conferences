Title: Keynote: Scala's Road Ahead - by Martin Odersky
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
After a fairly quiet 2015, things are heating up this year. To name just three major developments among many: A major new release, Scala 2.12, is about to be completed. The Scala Center provides a new focus point for community collaboration. And there's a new experimental platform, dotty, which lets us prototype designs for the next generation of the language.

In my talk I'd like to look a bit further ahead and focus on where I see Scala in the next 5 years, touching topics like: What is Scala's unique identity as a programming language? How should it evolve? What exciting new technologies are on the horizon?
Captions: 
	00:00:03,680 --> 00:00:13,100
so glad we could get get this set up

00:00:08,720 --> 00:00:15,660
I'm thank you for having come so

00:00:13,100 --> 00:00:18,120
numerously to the scatter days in New

00:00:15,660 --> 00:00:20,310
York we sold out it's great to see you I

00:00:18,120 --> 00:00:24,240
see some t-shirts from scattered in New

00:00:20,310 --> 00:00:27,390
York three years ago the the bright blue

00:00:24,240 --> 00:00:30,090
ones I have one myself here so it's

00:00:27,390 --> 00:00:31,560
great to be back after three years what

00:00:30,090 --> 00:00:35,040
I'm going to talk about today is

00:00:31,560 --> 00:00:37,290
essentially the future of SCADA the near

00:00:35,040 --> 00:00:40,500
future and also quite a bit about the

00:00:37,290 --> 00:00:42,750
further future so if we talk about the

00:00:40,500 --> 00:00:47,820
near future or let's look first at the

00:00:42,750 --> 00:00:50,910
near past as years ago 2015 was a was a

00:00:47,820 --> 00:00:52,739
fairly quiet year so there weren't so

00:00:50,910 --> 00:00:55,170
many developments that were there was

00:00:52,739 --> 00:00:58,079
steady growth however so here you see

00:00:55,170 --> 00:01:00,390
two graphs one is the job zone in deep

00:00:58,079 --> 00:01:03,120
calm and the other is the Google Trends

00:01:00,390 --> 00:01:05,369
and the jobs go up and down but they go

00:01:03,120 --> 00:01:07,650
mostly up and what's quite amazing is

00:01:05,369 --> 00:01:09,869
that on Google Trends the trend for

00:01:07,650 --> 00:01:12,299
scanner tutorial it has been a really

00:01:09,869 --> 00:01:14,580
smooth and steady curve so every year

00:01:12,299 --> 00:01:17,580
was more than the year before and so we

00:01:14,580 --> 00:01:19,890
really see not a hockey stick growth but

00:01:17,580 --> 00:01:23,250
continuous growth and that's in a sense

00:01:19,890 --> 00:01:27,600
more organic and and and very very

00:01:23,250 --> 00:01:30,780
impressive in if you see that graph now

00:01:27,600 --> 00:01:34,290
2016 things are heating up again so this

00:01:30,780 --> 00:01:36,420
won't be that that slow paced

00:01:34,290 --> 00:01:38,759
development there are many many things

00:01:36,420 --> 00:01:40,770
that have recently happened or that will

00:01:38,759 --> 00:01:41,549
happen very soon and I'm going to talk

00:01:40,770 --> 00:01:43,979
about those

00:01:41,549 --> 00:01:46,920
so among the most important things that

00:01:43,979 --> 00:01:50,490
happen are the scalar center it has been

00:01:46,920 --> 00:01:54,270
funded founded and funded the scatter to

00:01:50,490 --> 00:01:56,850
12 release the plans to rethink some of

00:01:54,270 --> 00:01:59,579
the scatter libraries the developments

00:01:56,850 --> 00:02:01,979
on new target platforms and then the

00:01:59,579 --> 00:02:04,939
work on dot the foundations of Scala and

00:02:01,979 --> 00:02:08,220
Dottie the new Scala compiler code base

00:02:04,939 --> 00:02:10,859
so let's take that one by one first one

00:02:08,220 --> 00:02:12,720
scalar center with the scalar Center we

00:02:10,859 --> 00:02:15,150
now have a new steward for sky

00:02:12,720 --> 00:02:17,850
essentially a foundation like entity

00:02:15,150 --> 00:02:19,220
that will focus and organize the

00:02:17,850 --> 00:02:21,810
community and the community

00:02:19,220 --> 00:02:24,090
contributions around scanner so its

00:02:21,810 --> 00:02:26,210
mission is to undertake projects that

00:02:24,090 --> 00:02:29,970
benefit all of the SCADA community and

00:02:26,210 --> 00:02:33,060
we have quite heavy and industrial

00:02:29,970 --> 00:02:36,420
support from like goldman sachs nitro

00:02:33,060 --> 00:02:39,300
IBM 47Â° and Verizon and I thank these

00:02:36,420 --> 00:02:41,310
companies for helping us here I won't

00:02:39,300 --> 00:02:43,380
dwell further on that because Heather

00:02:41,310 --> 00:02:46,110
Miller will talk about that in her

00:02:43,380 --> 00:02:48,890
keynote tomorrow in much more detail so

00:02:46,110 --> 00:02:52,920
I will just defer to Heather for now

00:02:48,890 --> 00:02:55,530
Scylla to 12:00 is around the corner we

00:02:52,920 --> 00:02:58,980
will come out this summer and Scala 2:12

00:02:55,530 --> 00:03:00,840
is a significant step because it's the

00:02:58,980 --> 00:03:04,290
first version of SCADA that's optimized

00:03:00,840 --> 00:03:07,010
for Java 8 so it means it uses Java aids

00:03:04,290 --> 00:03:10,140
lambdas and default methods in its

00:03:07,010 --> 00:03:12,000
bytecode generation which means in turn

00:03:10,140 --> 00:03:14,550
that the code can be more compact

00:03:12,000 --> 00:03:16,440
sometimes also faster and also that

00:03:14,550 --> 00:03:18,930
compilation times will be helped because

00:03:16,440 --> 00:03:21,000
essentially all those inner classes that

00:03:18,930 --> 00:03:23,340
we're simulating the lambdas took quite

00:03:21,000 --> 00:03:27,050
a lot of compilation time to generate so

00:03:23,340 --> 00:03:29,850
the code will be slimmer and the the the

00:03:27,050 --> 00:03:32,910
Interop with Java 8 of course will be

00:03:29,850 --> 00:03:36,870
vastly improved projected release date

00:03:32,910 --> 00:03:38,220
is mid 2016 in case you're still on Java

00:03:36,870 --> 00:03:41,250
6 or 7

00:03:38,220 --> 00:03:43,110
rest assured Scala - 11 will be around

00:03:41,250 --> 00:03:45,209
for quite a while so enlightement

00:03:43,110 --> 00:03:48,900
as is planning to actually have an

00:03:45,209 --> 00:03:51,810
extended maintenance cycle 4 to 11 in

00:03:48,900 --> 00:03:56,310
order to make this transition and less

00:03:51,810 --> 00:03:58,110
abrupt in detail there 33 features new

00:03:56,310 --> 00:04:02,400
features in the release notes so it's

00:03:58,110 --> 00:04:04,830
just the start of the list there are 336

00:04:02,400 --> 00:04:08,430
pool requests close with another 40 more

00:04:04,830 --> 00:04:10,590
to go protected to be merged before the

00:04:08,430 --> 00:04:12,989
final releases out and their 65

00:04:10,590 --> 00:04:15,390
committers so you just see the top of

00:04:12,989 --> 00:04:18,330
the committed page so all a significant

00:04:15,390 --> 00:04:19,859
effort and we're very happy to see this

00:04:18,330 --> 00:04:23,010
come to a

00:04:19,859 --> 00:04:25,320
release this year and also I'm very

00:04:23,010 --> 00:04:27,480
happy that finally programming in Scala

00:04:25,320 --> 00:04:30,090
version 3 is out and that it has been

00:04:27,480 --> 00:04:32,340
updated 4 to 12 so it will be the first

00:04:30,090 --> 00:04:35,160
book that actually contains the to 12

00:04:32,340 --> 00:04:37,620
editions and there's a book signing on

00:04:35,160 --> 00:04:39,600
Tuesday over lunch at the our team

00:04:37,620 --> 00:04:41,580
abouthe so I'll be there to sign the

00:04:39,600 --> 00:04:43,890
books even though I must say that with

00:04:41,580 --> 00:04:46,440
the third book I had not that much to do

00:04:43,890 --> 00:04:48,150
not as much to do as with the previous

00:04:46,440 --> 00:04:50,580
two editions but I'm really very very

00:04:48,150 --> 00:04:52,610
glad that it's out and I advise the

00:04:50,580 --> 00:04:57,240
author team of what to do there

00:04:52,610 --> 00:04:59,220
so beyond 2 to 12 since to 12 will be

00:04:57,240 --> 00:05:02,100
out this year it's time to actually look

00:04:59,220 --> 00:05:05,880
at the next steps after that so what are

00:05:02,100 --> 00:05:08,640
we planning to do 4 to 13 to 14 and so

00:05:05,880 --> 00:05:11,610
on so to 13 that's the next release

00:05:08,640 --> 00:05:13,380
after to 12 we plan to focus on the

00:05:11,610 --> 00:05:16,740
libraries so to 12 has essentially

00:05:13,380 --> 00:05:19,440
focused on the compiler generation the

00:05:16,740 --> 00:05:21,870
compiler back-end to 13 will be about

00:05:19,440 --> 00:05:25,800
the libraries in particular we plan we

00:05:21,870 --> 00:05:28,560
plan to study ways to revamp the

00:05:25,800 --> 00:05:31,080
collections to make them even simpler to

00:05:28,560 --> 00:05:32,940
use because despite the glitches and

00:05:31,080 --> 00:05:35,520
corner cases I think by and large

00:05:32,940 --> 00:05:37,169
collections are pretty easy to use but

00:05:35,520 --> 00:05:39,450
the question is can we keep that ease of

00:05:37,169 --> 00:05:44,729
use and maybe remove some of the corner

00:05:39,450 --> 00:05:47,910
cases an important guidance an important

00:05:44,729 --> 00:05:50,310
point of inspiration there is what

00:05:47,910 --> 00:05:54,000
sparked it with collections in

00:05:50,310 --> 00:05:56,010
particular that spark has this mode to

00:05:54,000 --> 00:05:58,560
actually construct collection operations

00:05:56,010 --> 00:06:00,060
lazily to essentially construct the

00:05:58,560 --> 00:06:02,729
operation and then run a complex

00:06:00,060 --> 00:06:06,930
operation in one step and also the way

00:06:02,729 --> 00:06:10,140
spark has integrated pair rdds or pair

00:06:06,930 --> 00:06:12,690
data sets now essentially collections

00:06:10,140 --> 00:06:14,160
over pairs in a very smooth way in the

00:06:12,690 --> 00:06:16,500
general collections is something that's

00:06:14,160 --> 00:06:18,840
definitely worth imitating in my mind so

00:06:16,500 --> 00:06:20,490
we will essentially plan to experiment

00:06:18,840 --> 00:06:22,320
with with that and see whether we can

00:06:20,490 --> 00:06:25,530
import some of that in standard

00:06:22,320 --> 00:06:27,300
collections the way we go about that is

00:06:25,530 --> 00:06:28,620
that we currently have strong and

00:06:27,300 --> 00:06:30,450
proposals under study

00:06:28,620 --> 00:06:32,050
so because collections is it's a big

00:06:30,450 --> 00:06:33,970
library take significant

00:06:32,050 --> 00:06:35,470
for to write one so they're not many

00:06:33,970 --> 00:06:37,449
people who actually would put up all

00:06:35,470 --> 00:06:39,190
that efforts to write a trial and then

00:06:37,449 --> 00:06:41,199
see it all go to waste because it's not

00:06:39,190 --> 00:06:42,879
adopted so what we did first is

00:06:41,199 --> 00:06:44,979
essentially reduce the scope and said

00:06:42,879 --> 00:06:48,120
when can we sort of study the problems

00:06:44,979 --> 00:06:51,099
with collections in the lab in the small

00:06:48,120 --> 00:06:53,440
so that we have a prototype that would

00:06:51,099 --> 00:06:55,479
take ideally less than 500 lines so

00:06:53,440 --> 00:06:57,639
which would be not that difficult to

00:06:55,479 --> 00:07:01,780
write and that could already highlight

00:06:57,639 --> 00:07:04,090
the design issues and potential design

00:07:01,780 --> 00:07:06,539
problems with collections so far we have

00:07:04,090 --> 00:07:09,789
two of those straumann proposals one

00:07:06,539 --> 00:07:11,650
traditional like the current collections

00:07:09,789 --> 00:07:14,110
are pretty much inheritance base the

00:07:11,650 --> 00:07:16,270
other decorator based and there's an

00:07:14,110 --> 00:07:19,259
open invitation to probably provide more

00:07:16,270 --> 00:07:24,009
of these from and proposals in all the

00:07:19,259 --> 00:07:27,069
in all this the the over the guideline

00:07:24,009 --> 00:07:29,169
of course is to stay essentially for the

00:07:27,069 --> 00:07:31,479
end-user compatible what's out there so

00:07:29,169 --> 00:07:34,090
what we want to do is mostly things

00:07:31,479 --> 00:07:37,300
under the hood that we say well we want

00:07:34,090 --> 00:07:40,090
to essentially give you a nicer way to

00:07:37,300 --> 00:07:42,159
interact with collections and maybe we

00:07:40,090 --> 00:07:44,080
can simplify some of the types but rest

00:07:42,159 --> 00:07:46,719
assured nobody will want to take back

00:07:44,080 --> 00:07:51,069
map or filter or flat map or operations

00:07:46,719 --> 00:07:52,810
like that okay the other thing beyond

00:07:51,069 --> 00:07:55,659
2:12 if you have just started of

00:07:52,810 --> 00:07:57,490
thinking and that in a little ways

00:07:55,659 --> 00:08:01,240
because it's connected to the questions

00:07:57,490 --> 00:08:04,360
of the of the collections is how can we

00:08:01,240 --> 00:08:06,250
achieve better modernization so the

00:08:04,360 --> 00:08:09,669
current standard library is a big jar

00:08:06,250 --> 00:08:12,219
and the advantage of a big jar is that

00:08:09,669 --> 00:08:14,139
it's somewhat of a batteries included

00:08:12,219 --> 00:08:16,300
thing but there are also issues with

00:08:14,139 --> 00:08:17,979
what if some of the batteries in this

00:08:16,300 --> 00:08:19,539
thing actually wore out and they're

00:08:17,979 --> 00:08:22,599
they're actually better solutions out

00:08:19,539 --> 00:08:25,270
there now in different libraries it will

00:08:22,599 --> 00:08:27,219
be very hard to switch over also the

00:08:25,270 --> 00:08:29,500
problem is the bigger the thing is and

00:08:27,219 --> 00:08:31,750
harder this demented the maintainer to

00:08:29,500 --> 00:08:35,079
made to ensure binary compatibility and

00:08:31,750 --> 00:08:37,630
so on so one interesting proposal is to

00:08:35,079 --> 00:08:39,640
actually split the standard library into

00:08:37,630 --> 00:08:40,870
a scholar core as Coe library which

00:08:39,640 --> 00:08:42,880
would be smaller than the current

00:08:40,870 --> 00:08:44,000
scanner library but I believe would

00:08:42,880 --> 00:08:47,180
still contact

00:08:44,000 --> 00:08:49,400
essentials like the collections and into

00:08:47,180 --> 00:08:51,200
a scholar platform which would be bigger

00:08:49,400 --> 00:08:52,760
than the current scholar library and

00:08:51,200 --> 00:08:56,770
that would include much needed new

00:08:52,760 --> 00:09:00,830
editions like maybe Jason handling IO

00:08:56,770 --> 00:09:02,630
things like that so that that has is

00:09:00,830 --> 00:09:05,630
something that the asker community has

00:09:02,630 --> 00:09:07,490
done and I believe it's an interesting

00:09:05,630 --> 00:09:09,260
thing to study to see whether we want to

00:09:07,490 --> 00:09:11,390
do the same thing the advantage would be

00:09:09,260 --> 00:09:13,100
that essentially different people would

00:09:11,390 --> 00:09:15,380
care about different parts of the

00:09:13,100 --> 00:09:17,000
libraries the core library you see would

00:09:15,380 --> 00:09:19,370
be essentially it's got a compiler team

00:09:17,000 --> 00:09:21,050
which has to look after the core library

00:09:19,370 --> 00:09:23,270
because the compiler will depend on it

00:09:21,050 --> 00:09:26,360
but for the platform we could hopefully

00:09:23,270 --> 00:09:28,490
enlist new groups of people that you

00:09:26,360 --> 00:09:30,950
can't take care of the platform the

00:09:28,490 --> 00:09:33,710
platform could be more organic and

00:09:30,950 --> 00:09:36,110
dynamic than a single jar so I would

00:09:33,710 --> 00:09:39,290
very much during these days maybe also

00:09:36,110 --> 00:09:41,450
sample your input or if some of you say

00:09:39,290 --> 00:09:42,950
well platform great idea I want to help

00:09:41,450 --> 00:09:45,110
and maybe take care of some of these

00:09:42,950 --> 00:09:47,420
things that would also be great if we

00:09:45,110 --> 00:09:50,960
could kick off some some initiatives

00:09:47,420 --> 00:09:56,480
there the other thing that also has

00:09:50,960 --> 00:09:59,360
happened in in 212 sorry in 2016 are the

00:09:56,480 --> 00:10:03,710
alternative platforms so scholar Jes is

00:09:59,360 --> 00:10:06,230
now 0 6 9 and I think the question

00:10:03,710 --> 00:10:08,870
always is well when will it jump to 1.0

00:10:06,230 --> 00:10:11,390
which I'm not sure maybe Sebastian will

00:10:08,870 --> 00:10:14,120
answer it in his talk but it's it's

00:10:11,390 --> 00:10:18,320
actually very very mature for a version

00:10:14,120 --> 00:10:20,480
number that's that low as 0 6 so the new

00:10:18,320 --> 00:10:22,850
additions there where native anonymous

00:10:20,480 --> 00:10:25,760
classes support native support for

00:10:22,850 --> 00:10:29,839
tuples j-unit supports and faster code

00:10:25,760 --> 00:10:30,920
generation and a shiny new website the

00:10:29,839 --> 00:10:32,600
other thing which is much more

00:10:30,920 --> 00:10:34,460
mysterious and we're going to find out

00:10:32,600 --> 00:10:36,830
more about that later on in the

00:10:34,460 --> 00:10:38,839
conference is this thing here so that's

00:10:36,830 --> 00:10:41,180
a web page and if you click on the

00:10:38,839 --> 00:10:46,130
double arrow here at the bottom it says

00:10:41,180 --> 00:10:48,710
coming soon and so so it's it's an

00:10:46,130 --> 00:10:51,050
interesting question what that's going

00:10:48,710 --> 00:10:53,350
to be well it's going to be a Scala

00:10:51,050 --> 00:10:57,269
compiler for our LLVM

00:10:53,350 --> 00:11:00,459
at very much in the early stages but

00:10:57,269 --> 00:11:03,720
again we find out more in Dennis shovel

00:11:00,459 --> 00:11:07,180
in stock later at the conference and

00:11:03,720 --> 00:11:10,300
then there's a duct so there's been lots

00:11:07,180 --> 00:11:14,620
of movements and developments around the

00:11:10,300 --> 00:11:18,160
dot dot of course is the dependent

00:11:14,620 --> 00:11:22,079
object calculus which we have finally

00:11:18,160 --> 00:11:26,589
proven to be a sound foundation of SCADA

00:11:22,079 --> 00:11:28,779
so dot is what the researchers and like

00:11:26,589 --> 00:11:31,060
to call it calculus which means it's a

00:11:28,779 --> 00:11:32,980
mini language that can be formally

00:11:31,060 --> 00:11:35,560
studied and of about which we can

00:11:32,980 --> 00:11:37,480
establish properties which are then

00:11:35,560 --> 00:11:39,579
actually proved by machine so they

00:11:37,480 --> 00:11:42,069
Revere perfectly sure that the

00:11:39,579 --> 00:11:44,230
properties actually hold the language

00:11:42,069 --> 00:11:46,839
subset is chosen so that we can prove

00:11:44,230 --> 00:11:50,170
formal statements about it and it should

00:11:46,839 --> 00:11:52,110
be suitable to encode in one way or

00:11:50,170 --> 00:11:56,230
another the rest of the language in it

00:11:52,110 --> 00:11:58,600
that is actually an huge step because it

00:11:56,230 --> 00:12:00,550
concludes an eight-year effort where we

00:11:58,600 --> 00:12:03,040
try to come up with such a foundation

00:12:00,550 --> 00:12:04,839
and we got stuck for a long time in our

00:12:03,040 --> 00:12:08,019
efforts to actually prove this

00:12:04,839 --> 00:12:10,240
foundation sound so the later in the

00:12:08,019 --> 00:12:12,459
last year and beginning of this year we

00:12:10,240 --> 00:12:15,220
have made significant progress and now

00:12:12,459 --> 00:12:17,860
are much it we can happily say that

00:12:15,220 --> 00:12:19,269
Scala is on much firmer foundations that

00:12:17,860 --> 00:12:21,910
it was a year ago

00:12:19,269 --> 00:12:23,949
also this opens the door to do language

00:12:21,910 --> 00:12:26,170
work with much better confidence than

00:12:23,949 --> 00:12:27,790
before so we can now actually when

00:12:26,170 --> 00:12:30,069
there's a new feature in Scala for

00:12:27,790 --> 00:12:33,279
proposal we can now actually evaluate

00:12:30,069 --> 00:12:34,930
and say well this addition and most

00:12:33,279 --> 00:12:38,170
additions would affect the type system

00:12:34,930 --> 00:12:40,089
is that actually sound or would we have

00:12:38,170 --> 00:12:43,389
doubts and the way we will do this is

00:12:40,089 --> 00:12:45,490
who we used to say well let's try to

00:12:43,389 --> 00:12:47,350
find an encoding in our base calculus

00:12:45,490 --> 00:12:48,970
and if that encoding is sound we know

00:12:47,350 --> 00:12:50,949
the base calculus is sound then the

00:12:48,970 --> 00:12:55,930
whole thing is sound so I wanted to give

00:12:50,949 --> 00:12:58,029
you a quick overview not that I just -

00:12:55,930 --> 00:13:00,130
for those of you that don't know what

00:12:58,029 --> 00:13:02,410
this sort of calculus is what it looks

00:13:00,130 --> 00:13:05,170
like so it's essentially a mini mini

00:13:02,410 --> 00:13:07,540
subset of Scala

00:13:05,170 --> 00:13:10,149
the only values in that subsets are

00:13:07,540 --> 00:13:14,620
functions which we write here so they're

00:13:10,149 --> 00:13:16,870
anonymous functions the and anonymous

00:13:14,620 --> 00:13:21,130
classes so that's the top here that you

00:13:16,870 --> 00:13:23,980
see under values then under definitions

00:13:21,130 --> 00:13:26,820
we have only parameterless method

00:13:23,980 --> 00:13:29,880
definitions so just def a equals t and

00:13:26,820 --> 00:13:33,790
type aliases that's all we have and

00:13:29,880 --> 00:13:36,519
under terms we have the values that

00:13:33,790 --> 00:13:38,829
you've seen then we have variables we

00:13:36,519 --> 00:13:41,709
have function application we have field

00:13:38,829 --> 00:13:44,380
selection and we have local definitions

00:13:41,709 --> 00:13:48,040
so essentially a vowel in a block that's

00:13:44,380 --> 00:13:51,730
all that we have here about the types we

00:13:48,040 --> 00:13:54,089
similarly minimum so we have the top

00:13:51,730 --> 00:13:57,339
type an e with the bottom type nothing

00:13:54,089 --> 00:14:00,880
type projection or selection X dot a

00:13:57,339 --> 00:14:03,300
then the function type and then in

00:14:00,880 --> 00:14:05,740
essentially methods with the single

00:14:03,300 --> 00:14:08,019
sorry records with a single definition

00:14:05,740 --> 00:14:08,829
like the parameter this method

00:14:08,019 --> 00:14:12,640
declaration

00:14:08,829 --> 00:14:14,199
that's a colon T then a an abstract type

00:14:12,640 --> 00:14:17,279
which has a lower bound and an upper

00:14:14,199 --> 00:14:20,140
bound and intersection of two types and

00:14:17,279 --> 00:14:22,120
recursion intersection you might say ah

00:14:20,140 --> 00:14:24,160
we don't have that in Scala that's true

00:14:22,120 --> 00:14:25,899
but I'll come back to that we will

00:14:24,160 --> 00:14:27,970
actually have that in the new Scala

00:14:25,899 --> 00:14:30,040
versions so essentially for now you can

00:14:27,970 --> 00:14:32,620
think of the ampersand and as a with

00:14:30,040 --> 00:14:35,440
it's close enough as a first first

00:14:32,620 --> 00:14:37,209
approximation okay so that's our mini

00:14:35,440 --> 00:14:40,029
language and it turns out that if you

00:14:37,209 --> 00:14:42,250
think about it that it is not

00:14:40,029 --> 00:14:44,320
straightforward but possible to

00:14:42,250 --> 00:14:46,779
essentially take the rest of the scalar

00:14:44,320 --> 00:14:49,300
language and condense it so that you can

00:14:46,779 --> 00:14:51,940
for every feature you can encode it into

00:14:49,300 --> 00:14:52,420
this mini language the encoding czar not

00:14:51,940 --> 00:14:55,300
pretty

00:14:52,420 --> 00:14:56,769
nobody would expect programmers to

00:14:55,300 --> 00:14:58,510
actually do that that's why we have a

00:14:56,769 --> 00:15:00,760
richer language and not a mini language

00:14:58,510 --> 00:15:04,120
like that but for the theory it's just

00:15:00,760 --> 00:15:08,110
important that they're doable so what we

00:15:04,120 --> 00:15:11,680
prove them is the following theorem that

00:15:08,110 --> 00:15:15,040
we said if a term so an expression has

00:15:11,680 --> 00:15:16,310
some type T and the evaluation of the

00:15:15,040 --> 00:15:17,960
term

00:15:16,310 --> 00:15:21,500
so the program will come to a halt and

00:15:17,960 --> 00:15:24,140
the result will be a value V of the same

00:15:21,500 --> 00:15:26,300
type T that's what type sound says so

00:15:24,140 --> 00:15:28,340
so she types on it says the compiler

00:15:26,300 --> 00:15:30,380
doesn't lie the compiler says well this

00:15:28,340 --> 00:15:32,600
program has this type this expression

00:15:30,380 --> 00:15:35,060
has this type then at runtime it will

00:15:32,600 --> 00:15:38,270
evaluate to a value that has this type

00:15:35,060 --> 00:15:40,520
or it might not terminate by going into

00:15:38,270 --> 00:15:42,800
an infinite loop it's recursion throwing

00:15:40,520 --> 00:15:44,330
it throwing and an exception and so on

00:15:42,800 --> 00:15:47,570
those are the things that we chose not

00:15:44,330 --> 00:15:49,730
to talk about this looks like a pretty

00:15:47,570 --> 00:15:51,710
harmless theorem but I told you it takes

00:15:49,730 --> 00:15:56,120
it took us eight years to prove it so it

00:15:51,710 --> 00:15:58,310
was a pretty pretty large Essen so why

00:15:56,120 --> 00:16:00,770
is it important because it gives us a

00:15:58,310 --> 00:16:02,540
technique to also reason about the

00:16:00,770 --> 00:16:04,730
correctness of other language features

00:16:02,540 --> 00:16:06,410
and I will show you later that actually

00:16:04,730 --> 00:16:08,540
there are language features in Scala

00:16:06,410 --> 00:16:09,920
where we have shown by this technique

00:16:08,540 --> 00:16:11,630
that they are not correct that they're

00:16:09,920 --> 00:16:14,900
unsound and I'll show you what we are

00:16:11,630 --> 00:16:17,720
going to do with them okay so that was

00:16:14,900 --> 00:16:20,000
dot dot is the theory the other thing I

00:16:17,720 --> 00:16:22,910
want to talk about quickly is the

00:16:20,000 --> 00:16:26,600
compiler that's based on the theory so

00:16:22,910 --> 00:16:29,510
that's called dot e dot E is the working

00:16:26,600 --> 00:16:32,210
name for our new Scala compiler so it's

00:16:29,510 --> 00:16:34,550
a new code base it takes some bits of

00:16:32,210 --> 00:16:36,890
the old Scala compiler NEC but not too

00:16:34,550 --> 00:16:40,130
many most of them are built up from

00:16:36,890 --> 00:16:43,250
scratch and most importantly it builds

00:16:40,130 --> 00:16:46,070
on dot in its internal data structures

00:16:43,250 --> 00:16:47,690
so essentially it has the same internal

00:16:46,070 --> 00:16:50,180
data structures that you see in this

00:16:47,690 --> 00:16:52,490
minimal calculus and it doesn't quite a

00:16:50,180 --> 00:16:54,500
lot of simplifications to get there to

00:16:52,490 --> 00:16:58,250
get to these minimal data structures in

00:16:54,500 --> 00:17:01,660
particular it doesn't we it will pretend

00:16:58,250 --> 00:17:05,390
that the language doesn't have any

00:17:01,660 --> 00:17:08,390
parameters or any type parameters you

00:17:05,390 --> 00:17:11,270
say well no generic functions no generic

00:17:08,390 --> 00:17:13,550
things no generic classes that seems

00:17:11,270 --> 00:17:15,290
rather radical but of course again the

00:17:13,550 --> 00:17:18,650
language would have the type parameters

00:17:15,290 --> 00:17:21,560
but they are encoded as what you've seen

00:17:18,650 --> 00:17:23,839
in the in D calculus abstract types with

00:17:21,560 --> 00:17:27,140
upper and lower bounds and essentially

00:17:23,839 --> 00:17:28,820
type selection type projection so the

00:17:27,140 --> 00:17:30,710
compiler is quite radical in that

00:17:28,820 --> 00:17:33,440
that it really tries to reduce very

00:17:30,710 --> 00:17:35,690
quickly to this minimal subset of the

00:17:33,440 --> 00:17:40,580
language that we is the one that we

00:17:35,690 --> 00:17:43,370
understand very well so for that

00:17:40,580 --> 00:17:46,850
compiler the first Developer Preview is

00:17:43,370 --> 00:17:50,600
around the corner we hope that we will

00:17:46,850 --> 00:17:51,710
get something out by the next gala days

00:17:50,600 --> 00:17:54,080
in Berlin maybe

00:17:51,710 --> 00:17:56,740
and that first Developer Preview is

00:17:54,080 --> 00:17:58,309
really targeted at contributors and

00:17:56,740 --> 00:18:00,139
experimenters so it's not

00:17:58,309 --> 00:18:03,139
production-ready it won't be production

00:18:00,139 --> 00:18:07,490
ready for awhile but if you want to get

00:18:03,139 --> 00:18:11,450
involved in that and help experiment

00:18:07,490 --> 00:18:13,789
with it contributed a play with it now

00:18:11,450 --> 00:18:16,639
is a good time to get started

00:18:13,789 --> 00:18:18,440
technical data of the compiler it's

00:18:16,639 --> 00:18:20,690
currently a bit more than half the size

00:18:18,440 --> 00:18:23,389
of the current Scala compiler about

00:18:20,690 --> 00:18:27,830
45,000 lines of code and Scala compiler

00:18:23,389 --> 00:18:30,889
has measured by the same inclusion of

00:18:27,830 --> 00:18:32,480
modules about 75,000 lines and it's

00:18:30,889 --> 00:18:34,970
about twice the speed of the current

00:18:32,480 --> 00:18:36,860
scalar compiler but that actually should

00:18:34,970 --> 00:18:38,509
improve significantly in the future

00:18:36,860 --> 00:18:40,549
because we have still lots and lots of

00:18:38,509 --> 00:18:43,100
debug code that we have in this in this

00:18:40,549 --> 00:18:46,370
compiler that we haven't taken out yet

00:18:43,100 --> 00:18:50,360
and that we know slows down compilation

00:18:46,370 --> 00:18:52,909
significant significantly so the IQ

00:18:50,360 --> 00:18:54,649
texture of the dottie compiler you see

00:18:52,909 --> 00:18:56,929
here on that picture on the left hand

00:18:54,649 --> 00:18:58,549
side you have the new compiler dot e on

00:18:56,929 --> 00:19:02,779
the right hand is essentially the old

00:18:58,549 --> 00:19:05,779
ones the NSC and both compilers are

00:19:02,779 --> 00:19:08,840
innocent similar in that they both have

00:19:05,779 --> 00:19:11,960
a front end a parser that produces an

00:19:08,840 --> 00:19:14,120
AST or abstract syntax tree and then

00:19:11,960 --> 00:19:17,029
they are transforms I would gradually

00:19:14,120 --> 00:19:18,409
simplify that ASDs and then they go is

00:19:17,029 --> 00:19:21,200
essentially to the back end that

00:19:18,409 --> 00:19:23,029
generates a bytecode on the JVM and that

00:19:21,200 --> 00:19:25,629
back end is actually shared so Gen B

00:19:23,029 --> 00:19:28,220
code is the same one for NSC and Daddy

00:19:25,629 --> 00:19:32,509
the other interesting bit is what

00:19:28,220 --> 00:19:35,360
happens with the pickled information so

00:19:32,509 --> 00:19:37,580
pickling is used to support separate

00:19:35,360 --> 00:19:39,529
compilation when compiler compiles a

00:19:37,580 --> 00:19:40,800
file it has to essentially make the

00:19:39,529 --> 00:19:44,190
information that file

00:19:40,800 --> 00:19:45,930
available to other compilation units so

00:19:44,190 --> 00:19:47,730
it pickles them that's typical and

00:19:45,930 --> 00:19:49,860
attribute in the class file that's what

00:19:47,730 --> 00:19:53,310
the Scala compiler knows about his

00:19:49,860 --> 00:19:57,120
Scholar Program and the pickling info in

00:19:53,310 --> 00:19:59,550
dotty is has has changed so it is now

00:19:57,120 --> 00:20:02,250
something called tasty so tasty is

00:19:59,550 --> 00:20:04,770
essentially a serialized version of

00:20:02,250 --> 00:20:06,660
these same ast s so it can be much more

00:20:04,770 --> 00:20:09,720
it's much more complete and much more

00:20:06,660 --> 00:20:13,850
precise than what we had in the in the

00:20:09,720 --> 00:20:17,190
old scholar C compiler and it opens the

00:20:13,850 --> 00:20:19,440
road to many interesting possibilities

00:20:17,190 --> 00:20:21,150
some of which you will also hear this

00:20:19,440 --> 00:20:24,180
conference name the whole program

00:20:21,150 --> 00:20:28,670
optimization and including the linker

00:20:24,180 --> 00:20:31,350
another thing that we haven't really

00:20:28,670 --> 00:20:33,060
finished yet but which i think is very

00:20:31,350 --> 00:20:35,640
very interesting is that tasty also

00:20:33,060 --> 00:20:38,700
gives us a way to avoid binary

00:20:35,640 --> 00:20:40,650
compatibility problems because it gives

00:20:38,700 --> 00:20:42,360
us a new way to ship libraries so

00:20:40,650 --> 00:20:45,150
libraries can now ship with this thing

00:20:42,360 --> 00:20:47,600
and then it's actually adapted on the

00:20:45,150 --> 00:20:49,890
platform that you're running the

00:20:47,600 --> 00:20:52,440
diversion of Scala the wizard version of

00:20:49,890 --> 00:20:54,900
Java or maybe sky Egeus or natives

00:20:52,440 --> 00:20:57,300
depending on essentially what your what

00:20:54,900 --> 00:20:59,310
is set up on the user on the client is

00:20:57,300 --> 00:21:01,650
so tasty gives us essentially a

00:20:59,310 --> 00:21:05,880
universal interchange format for Scala

00:21:01,650 --> 00:21:09,300
files and that's why it's exciting ok so

00:21:05,880 --> 00:21:13,950
that was the part about the compiler now

00:21:09,300 --> 00:21:16,500
the purpose of that compiler is that it

00:21:13,950 --> 00:21:18,860
gives us a better way to go forward also

00:21:16,500 --> 00:21:22,050
evolving the language because

00:21:18,860 --> 00:21:24,990
essentially having a cleaner codebase

00:21:22,050 --> 00:21:26,970
lets you move faster when you want to

00:21:24,990 --> 00:21:28,680
essentially change things and it lets

00:21:26,970 --> 00:21:31,290
you move with more confidence they're

00:21:28,680 --> 00:21:33,660
less essentially stupid backwards

00:21:31,290 --> 00:21:35,580
compatibility requirements there let's

00:21:33,660 --> 00:21:37,230
see such a historical accidents that

00:21:35,580 --> 00:21:41,760
prevent you from doing the right thing

00:21:37,230 --> 00:21:44,160
so the reason for actually spending now

00:21:41,760 --> 00:21:46,680
almost three we think three years on

00:21:44,160 --> 00:21:50,200
this compiler was really to be able to

00:21:46,680 --> 00:21:54,399
move more confidently in evolving the

00:21:50,200 --> 00:21:56,590
now why do we want to do that well why

00:21:54,399 --> 00:21:58,299
do I want to do that that's just my

00:21:56,590 --> 00:22:00,640
personal goal my personal goal has

00:21:58,299 --> 00:22:02,890
always been to make Scala the best

00:22:00,640 --> 00:22:05,649
programming language I know how to make

00:22:02,890 --> 00:22:07,600
and I also know that this work is never

00:22:05,649 --> 00:22:10,740
finished because we will always learn

00:22:07,600 --> 00:22:12,820
new ways and essentially we will discard

00:22:10,740 --> 00:22:15,070
techniques that we thought with state of

00:22:12,820 --> 00:22:17,380
the art before and we will refine new

00:22:15,070 --> 00:22:20,649
techniques and I also know that any such

00:22:17,380 --> 00:22:23,320
best notion of best can only be a local

00:22:20,649 --> 00:22:26,470
optimum because of course people differ

00:22:23,320 --> 00:22:28,659
on what they think is best and even wait

00:22:26,470 --> 00:22:31,779
for one person different applications

00:22:28,659 --> 00:22:34,000
has has different best tools but what

00:22:31,779 --> 00:22:37,390
you definitely can do is to say well for

00:22:34,000 --> 00:22:39,159
the for the application domain that we

00:22:37,390 --> 00:22:41,110
have the language for the applications

00:22:39,159 --> 00:22:43,960
that are out there can we find

00:22:41,110 --> 00:22:46,149
essentially a language that is a local

00:22:43,960 --> 00:22:48,760
optimum or the energy that locally

00:22:46,149 --> 00:22:50,740
improves without changing the character

00:22:48,760 --> 00:22:52,090
of the language just saying well there

00:22:50,740 --> 00:22:54,549
is something that brings out that

00:22:52,090 --> 00:22:58,360
character that application profile

00:22:54,549 --> 00:23:00,070
better than what we have before so what

00:22:58,360 --> 00:23:02,289
is that application profile that

00:23:00,070 --> 00:23:05,409
character well for me really is the

00:23:02,289 --> 00:23:07,210
legally fundamental cornerstones of

00:23:05,409 --> 00:23:07,659
Scala is that we have a functional

00:23:07,210 --> 00:23:09,520
language

00:23:07,659 --> 00:23:12,100
you also have an object-oriented

00:23:09,520 --> 00:23:14,309
language essentially supporting

00:23:12,100 --> 00:23:17,380
modularity through classes and objects

00:23:14,309 --> 00:23:20,409
the function will be an evaluation is

00:23:17,380 --> 00:23:23,140
strict so we won't try to pretend to be

00:23:20,409 --> 00:23:25,840
a lazy language the type inference is

00:23:23,140 --> 00:23:29,049
local based on propagation we won't try

00:23:25,840 --> 00:23:31,120
to essentially get a gig in it become

00:23:29,049 --> 00:23:32,470
too fancy within vanilla because we know

00:23:31,120 --> 00:23:34,570
that it would restrict a lot of the

00:23:32,470 --> 00:23:36,700
other features nothing against in Hindi

00:23:34,570 --> 00:23:38,649
Miller it's a fantastic type inference

00:23:36,700 --> 00:23:40,929
technique but it does restrict a lot of

00:23:38,649 --> 00:23:43,090
the other design choices that you have

00:23:40,929 --> 00:23:45,520
in a language and Scala has essentially

00:23:43,090 --> 00:23:47,919
violated a lot of them already and the

00:23:45,520 --> 00:23:49,929
fifth one which I also think as we have

00:23:47,919 --> 00:23:51,850
learned that it's much more important

00:23:49,929 --> 00:23:53,710
than we thought before is implicit

00:23:51,850 --> 00:23:55,840
now implicit a lot of you might shake

00:23:53,710 --> 00:23:58,690
your head and said well elicits I have a

00:23:55,840 --> 00:23:59,700
bad or a bad rep right that's also there

00:23:58,690 --> 00:24:04,139
really

00:23:59,700 --> 00:24:06,240
a but I think a lot of the bad

00:24:04,139 --> 00:24:08,580
reputations from implicit scums from the

00:24:06,240 --> 00:24:11,519
past but we just didn't know how to use

00:24:08,580 --> 00:24:13,649
them correctly and I think we I will say

00:24:11,519 --> 00:24:17,010
later at the end of the talk some ideas

00:24:13,649 --> 00:24:19,769
how to we might actually get to a stage

00:24:17,010 --> 00:24:21,779
where we can avoid the worst abuses of

00:24:19,769 --> 00:24:23,880
implicit but the more I look at the

00:24:21,779 --> 00:24:26,130
implicit that I think the more potential

00:24:23,880 --> 00:24:28,799
they have and other languages are noting

00:24:26,130 --> 00:24:30,870
that as well for instance Oh camel the

00:24:28,799 --> 00:24:33,240
language which is fairly close to Scala

00:24:30,870 --> 00:24:35,220
much older and Scala but very close in

00:24:33,240 --> 00:24:37,470
its orientation strict functional

00:24:35,220 --> 00:24:39,870
language with an object system recently

00:24:37,470 --> 00:24:42,269
added implicit very similar to Scala

00:24:39,870 --> 00:24:45,059
implicit to their language book I think

00:24:42,269 --> 00:24:47,429
it's a proposal stage but I expect that

00:24:45,059 --> 00:24:49,320
it will be accepted generally a lot of

00:24:47,429 --> 00:24:52,470
languages are moving in this game in the

00:24:49,320 --> 00:24:55,289
space color has the spacecraft scale is

00:24:52,470 --> 00:24:57,480
established not just a camera but if you

00:24:55,289 --> 00:24:59,279
look at Swift or couplet and/or the

00:24:57,480 --> 00:25:01,230
later versions of c-sharp you see that

00:24:59,279 --> 00:25:03,960
it's a lot of language that acted

00:25:01,230 --> 00:25:07,649
actually move in this space and what I

00:25:03,960 --> 00:25:09,929
do not want to try is such a beat these

00:25:07,649 --> 00:25:12,510
languages feature by feature I would

00:25:09,929 --> 00:25:14,340
rather try to find it essentially a

00:25:12,510 --> 00:25:16,529
language it has a smaller number of

00:25:14,340 --> 00:25:18,840
features but that brings them out more

00:25:16,529 --> 00:25:21,269
clearly so that's essentially the goal

00:25:18,840 --> 00:25:22,620
that I have and I think we have the you

00:25:21,269 --> 00:25:24,960
have the advantage of a lot of

00:25:22,620 --> 00:25:28,049
experience in that space so we we are we

00:25:24,960 --> 00:25:30,840
have many many years ahead of a lot of

00:25:28,049 --> 00:25:33,870
the later languages here so the goals

00:25:30,840 --> 00:25:35,610
are of this work then I - for me to

00:25:33,870 --> 00:25:37,590
deepen the synthesis of functional

00:25:35,610 --> 00:25:39,360
programming and modular programming so

00:25:37,590 --> 00:25:41,669
you know to do functional programming

00:25:39,360 --> 00:25:44,639
but to bring it together with modules

00:25:41,669 --> 00:25:46,590
objects classes that's what it's got a

00:25:44,639 --> 00:25:49,350
pioneered and I think that's what we can

00:25:46,590 --> 00:25:52,440
improve we can still improve on we

00:25:49,350 --> 00:25:54,480
should continue doing that improve the

00:25:52,440 --> 00:25:56,880
connection of Scala with its theoretical

00:25:54,480 --> 00:25:59,130
foundations first step there are

00:25:56,880 --> 00:26:01,049
theoretical foundations so now we just

00:25:59,130 --> 00:26:03,570
essentially have to take them seriously

00:26:01,049 --> 00:26:05,970
and have to say well essentially what

00:26:03,570 --> 00:26:08,730
how do we map the language to those

00:26:05,970 --> 00:26:10,860
foundations improve the guarantees of

00:26:08,730 --> 00:26:12,700
the type system so I think that's

00:26:10,860 --> 00:26:15,529
something that we have

00:26:12,700 --> 00:26:18,080
learned over the years when SCADA was

00:26:15,529 --> 00:26:21,980
came out essentially any notion of

00:26:18,080 --> 00:26:23,919
static type was dubious the hot kids of

00:26:21,980 --> 00:26:26,960
the day where languages like Ruby and

00:26:23,919 --> 00:26:29,750
Python and JavaScript

00:26:26,960 --> 00:26:31,159
so essentially dynamic programming was

00:26:29,750 --> 00:26:33,230
all the rage and the static type system

00:26:31,159 --> 00:26:36,470
was essentially betting on the wrong

00:26:33,230 --> 00:26:39,169
horse at the time so at the time the

00:26:36,470 --> 00:26:41,840
design of Scala was pretty conservative

00:26:39,169 --> 00:26:43,669
in the way what we want to capture in

00:26:41,840 --> 00:26:46,250
the types we want to say well the most

00:26:43,669 --> 00:26:48,590
important thing is that Ruby program is

00:26:46,250 --> 00:26:51,350
not completely disgusted when they see

00:26:48,590 --> 00:26:53,299
Scala types right so you want to make

00:26:51,350 --> 00:26:55,880
them write white we don't want to be too

00:26:53,299 --> 00:26:58,549
dogmatic we don't want to essentially

00:26:55,880 --> 00:27:01,010
make life difficult even though we might

00:26:58,549 --> 00:27:03,409
catch some error here or there

00:27:01,010 --> 00:27:05,059
doesn't matter the important thing is

00:27:03,409 --> 00:27:07,279
that we do have a strong typing

00:27:05,059 --> 00:27:09,110
discipline I think that has changed we

00:27:07,279 --> 00:27:11,450
have seen the community move much more

00:27:09,110 --> 00:27:13,250
into directions where certain features

00:27:11,450 --> 00:27:14,840
that where we had as a matter of course

00:27:13,250 --> 00:27:16,940
like exceptions

00:27:14,840 --> 00:27:18,470
now our dubious because I said well we

00:27:16,940 --> 00:27:20,570
don't the types don't catch the

00:27:18,470 --> 00:27:22,970
exceptions should you use exceptions and

00:27:20,570 --> 00:27:25,010
in my mind I think exceptions do have a

00:27:22,970 --> 00:27:26,750
role but I definitely see the point that

00:27:25,010 --> 00:27:28,279
the types don't capture it so the

00:27:26,750 --> 00:27:31,130
question is can we actually enrich the

00:27:28,279 --> 00:27:34,399
types to capture things like exceptions

00:27:31,130 --> 00:27:36,590
and other things but among all that I

00:27:34,399 --> 00:27:39,049
really wanted to stay simple and

00:27:36,590 --> 00:27:41,110
approachable so those are the goals so

00:27:39,049 --> 00:27:43,309
what I will do now is I will give you a

00:27:41,110 --> 00:27:46,850
whirlwind tour of what we have so far

00:27:43,309 --> 00:27:49,370
and what we might plan in the future so

00:27:46,850 --> 00:27:51,470
a whirlwind tour of duckie so the first

00:27:49,370 --> 00:27:53,090
thing is we want to take it seriously

00:27:51,470 --> 00:27:54,950
that we want to keep the language simple

00:27:53,090 --> 00:27:56,720
and if you want to keep the language

00:27:54,950 --> 00:27:58,460
simple then you have to start by cutting

00:27:56,720 --> 00:28:01,039
out some features because otherwise you

00:27:58,460 --> 00:28:03,409
get accretion so we cut out quite a few

00:28:01,039 --> 00:28:06,350
features that we either can get replaced

00:28:03,409 --> 00:28:08,270
by something simpler or that we just

00:28:06,350 --> 00:28:11,000
found they didn't carry their weight

00:28:08,270 --> 00:28:11,779
first is procedure syntax well that's an

00:28:11,000 --> 00:28:14,720
easy one

00:28:11,779 --> 00:28:16,909
so everybody hates the bank maybe not

00:28:14,720 --> 00:28:19,159
hate but the consensus is you can really

00:28:16,909 --> 00:28:21,890
do without the procedure syntax for the

00:28:19,159 --> 00:28:23,750
run here above and what's more is we can

00:28:21,890 --> 00:28:25,110
rewrite that automatically to

00:28:23,750 --> 00:28:27,059
essentially

00:28:25,110 --> 00:28:30,090
the slightly more verbose thing at the

00:28:27,059 --> 00:28:32,309
bottom so that's been done delayed in it

00:28:30,090 --> 00:28:37,080
really wasn't used a lot so it gets

00:28:32,309 --> 00:28:39,809
capped without replacements macros so

00:28:37,080 --> 00:28:41,220
macros are a difficult one that's why

00:28:39,809 --> 00:28:44,130
they're the biggest thing here in the

00:28:41,220 --> 00:28:46,320
middle the current kind of macros was

00:28:44,130 --> 00:28:47,790
always experimental as you know so

00:28:46,320 --> 00:28:52,770
essentially macros is an experimental

00:28:47,790 --> 00:28:55,650
feature and we have come to realize that

00:28:52,770 --> 00:28:58,320
what what's out there is really not

00:28:55,650 --> 00:29:00,270
something we want to go with in the long

00:28:58,320 --> 00:29:03,000
run we want something different which is

00:29:00,270 --> 00:29:05,669
much simpler much more robust and in

00:29:03,000 --> 00:29:07,380
which in particular is not based on

00:29:05,669 --> 00:29:08,549
reflection I think that's one of the

00:29:07,380 --> 00:29:11,040
problems of the current macros that

00:29:08,549 --> 00:29:13,470
essentially they execute at runtime

00:29:11,040 --> 00:29:15,270
using Java reflection or Java reflection

00:29:13,470 --> 00:29:18,059
you ever say well what with other

00:29:15,270 --> 00:29:20,160
platforms there is no Java reflection

00:29:18,059 --> 00:29:22,080
and the other thing is Java reflection

00:29:20,160 --> 00:29:24,450
means during the compiler you execute

00:29:22,080 --> 00:29:27,270
arbitrary code and that's for me very

00:29:24,450 --> 00:29:29,490
scary so not not just during the

00:29:27,270 --> 00:29:31,590
compiler potentially during the IDE on

00:29:29,490 --> 00:29:34,410
every keystroke there's something that

00:29:31,590 --> 00:29:38,340
you execute here so so that's why I

00:29:34,410 --> 00:29:40,049
think we should rethink that early

00:29:38,340 --> 00:29:42,750
initializes who here knows what early

00:29:40,049 --> 00:29:47,490
visualizers are and some of him do good

00:29:42,750 --> 00:29:50,130
yeah so well it's it's this thing here

00:29:47,490 --> 00:29:52,830
so what we had so far most of you don't

00:29:50,130 --> 00:29:55,650
know what it is rightfully so so it's

00:29:52,830 --> 00:29:57,809
that we essentially could initialize

00:29:55,650 --> 00:30:00,030
something before we call the superclass

00:29:57,809 --> 00:30:03,000
constructor so that that was the syntax

00:30:00,030 --> 00:30:05,970
for it and the reasons were basically

00:30:03,000 --> 00:30:08,820
where that with traits the only you

00:30:05,970 --> 00:30:11,100
can't do anything before you run the

00:30:08,820 --> 00:30:12,690
initializer of a trait normally and

00:30:11,100 --> 00:30:14,130
sometimes the initializer of a trade

00:30:12,690 --> 00:30:15,929
needs to know something of the base

00:30:14,130 --> 00:30:17,220
class like the setting of a feel for

00:30:15,929 --> 00:30:20,490
things like that and there was no way

00:30:17,220 --> 00:30:23,100
around it and that's why we had this

00:30:20,490 --> 00:30:25,500
syntax where we said well that here if D

00:30:23,100 --> 00:30:29,100
is a trait then we can ensure that we

00:30:25,500 --> 00:30:33,020
have this thing here so they will be

00:30:29,100 --> 00:30:35,820
replaced by trade parameters thankfully

00:30:33,020 --> 00:30:37,980
existential types so the more

00:30:35,820 --> 00:30:38,500
complicated forms of existential types

00:30:37,980 --> 00:30:40,600
the one you

00:30:38,500 --> 00:30:42,970
see here at the top they no longer

00:30:40,600 --> 00:30:46,210
supported wild cards are still supported

00:30:42,970 --> 00:30:48,510
the reason is that almost all code and

00:30:46,210 --> 00:30:51,220
actually use these existential types was

00:30:48,510 --> 00:30:53,290
extremely brittle so I came to realize

00:30:51,220 --> 00:30:55,300
that except that these complex extension

00:30:53,290 --> 00:30:57,700
types they are almost a code smell and

00:30:55,300 --> 00:30:59,170
the second that just don't really fit

00:30:57,700 --> 00:31:02,350
with the foundations they are

00:30:59,170 --> 00:31:04,480
essentially an addition that sits very

00:31:02,350 --> 00:31:06,760
uneasily with this dependent type

00:31:04,480 --> 00:31:09,430
formalization that we have so that they

00:31:06,760 --> 00:31:12,130
are going to be dropped a general type

00:31:09,430 --> 00:31:15,190
projection so that was this hash code

00:31:12,130 --> 00:31:19,690
the projection code and that we love by

00:31:15,190 --> 00:31:22,180
some because it lets you do lambda

00:31:19,690 --> 00:31:24,670
calculus in a type system so that's the

00:31:22,180 --> 00:31:27,130
thing that's the reason for scholars

00:31:24,670 --> 00:31:30,880
type systems turing completeness or one

00:31:27,130 --> 00:31:33,430
of the reasons so you can do sk k sk i

00:31:30,880 --> 00:31:34,990
Combinator calculus in a type system you

00:31:33,430 --> 00:31:37,600
can look it up on the web it's quite

00:31:34,990 --> 00:31:40,450
quite amazing unfortunately it's also

00:31:37,600 --> 00:31:43,450
unsound so there's an issue issue fifty

00:31:40,450 --> 00:31:45,520
in the Dottie issue issue list that

00:31:43,450 --> 00:31:47,350
actually shows that these things lead to

00:31:45,520 --> 00:31:47,950
an soundness so two class cast exception

00:31:47,350 --> 00:31:52,150
z--

00:31:47,950 --> 00:31:54,490
at runtime and furthermore by what we

00:31:52,150 --> 00:31:56,610
learned in the dot calculus we found

00:31:54,490 --> 00:31:59,140
that there's not really a good way to

00:31:56,610 --> 00:32:00,790
essentially make this sound because we

00:31:59,140 --> 00:32:02,560
essentially developed these proof

00:32:00,790 --> 00:32:03,970
principles and it just didn't work with

00:32:02,560 --> 00:32:06,730
the approach of these general type

00:32:03,970 --> 00:32:08,890
projections so there we go as well about

00:32:06,730 --> 00:32:10,750
the class projection where C is just a

00:32:08,890 --> 00:32:13,660
class which you use to essentially

00:32:10,750 --> 00:32:15,760
express inner classes like the ones you

00:32:13,660 --> 00:32:17,710
see from Java that's actually turns out

00:32:15,760 --> 00:32:23,170
to be perfectly sound and that will

00:32:17,710 --> 00:32:26,800
still be available okay so we have taken

00:32:23,170 --> 00:32:29,440
a lot of things away maybe some of them

00:32:26,800 --> 00:32:33,340
will hurt but I hope good riddance for

00:32:29,440 --> 00:32:34,870
most of them so what do we add so the

00:32:33,340 --> 00:32:36,550
first thing we add is something that you

00:32:34,870 --> 00:32:39,070
saw in the dot calculus that was this

00:32:36,550 --> 00:32:40,990
ampersand intersection types and that

00:32:39,070 --> 00:32:44,350
replaces the what we call a compound

00:32:40,990 --> 00:32:47,470
type T with you but it's much nicer it's

00:32:44,350 --> 00:32:50,050
nicer because it's cumulative so T and U

00:32:47,470 --> 00:32:51,430
is really the same thing as U and T if

00:32:50,050 --> 00:32:53,320
you try that out with

00:32:51,430 --> 00:32:55,540
that's actually not true that Smoove was

00:32:53,320 --> 00:32:57,550
one of the glitches that that we had in

00:32:55,540 --> 00:32:59,650
Scottish type system and essentially the

00:32:57,550 --> 00:33:01,830
reason or the route the source of the

00:32:59,650 --> 00:33:04,150
error is that we confound it

00:33:01,830 --> 00:33:05,950
implementation inheritance where it very

00:33:04,150 --> 00:33:07,750
much matters what you get last because

00:33:05,950 --> 00:33:10,390
that's that's going to be the overriding

00:33:07,750 --> 00:33:12,430
implementation with types where you only

00:33:10,390 --> 00:33:14,620
talk about what is in a type but not how

00:33:12,430 --> 00:33:16,840
you implement it so it's a typical it's

00:33:14,620 --> 00:33:18,970
sort of goes in the same thing that you

00:33:16,840 --> 00:33:21,220
confuse subtyping with sup with

00:33:18,970 --> 00:33:23,980
inheritance here we make that mistake

00:33:21,220 --> 00:33:26,440
and we're going to correct it now if you

00:33:23,980 --> 00:33:29,380
have intersection types then the dual of

00:33:26,440 --> 00:33:31,720
intersection types is Union types and we

00:33:29,380 --> 00:33:35,200
can have them also so they're union

00:33:31,720 --> 00:33:37,540
types which are written T or u human

00:33:35,200 --> 00:33:40,990
types have some interesting applications

00:33:37,540 --> 00:33:43,840
in software so they're definitely useful

00:33:40,990 --> 00:33:46,960
but for me the biggest biggest plus of

00:33:43,840 --> 00:33:49,450
human types is that they avoid exploding

00:33:46,960 --> 00:33:51,850
labs so that all these examples are

00:33:49,450 --> 00:33:54,310
round that essentially a type error goes

00:33:51,850 --> 00:33:56,710
over many many pages and that was you

00:33:54,310 --> 00:33:58,360
this because essentially the previous

00:33:56,710 --> 00:34:00,310
fear the current SCADA doesn't have unit

00:33:58,360 --> 00:34:02,170
types so the compiler has to approximate

00:34:00,310 --> 00:34:04,300
them somehow the way the compile

00:34:02,170 --> 00:34:07,120
approximates it it essentially says the

00:34:04,300 --> 00:34:10,120
union of T and u is take all the super

00:34:07,120 --> 00:34:12,070
types of T and U and put them all

00:34:10,120 --> 00:34:13,630
together with an ant so essentially I go

00:34:12,070 --> 00:34:15,970
take the super types and put them all

00:34:13,630 --> 00:34:18,430
together with an end and unfortunately

00:34:15,970 --> 00:34:22,900
sometimes this can get huge it can even

00:34:18,430 --> 00:34:25,000
get infinite infinitely huge so the that

00:34:22,900 --> 00:34:29,470
that's a real problem that either you

00:34:25,000 --> 00:34:32,020
have fairly arbitrary kind of rules for

00:34:29,470 --> 00:34:34,990
the labs that where you say well at some

00:34:32,020 --> 00:34:37,390
point you just don't care anymore or you

00:34:34,990 --> 00:34:39,460
you have these huge things in practice

00:34:37,390 --> 00:34:41,380
the current scalar C compiler hash test

00:34:39,460 --> 00:34:44,350
box it had fairly arbitrary cutoff rules

00:34:41,380 --> 00:34:45,730
and huge things and it's that just just

00:34:44,350 --> 00:34:49,300
shows that it's very very hard to

00:34:45,730 --> 00:34:51,400
control okay so that's why we have union

00:34:49,300 --> 00:34:55,300
types the third one is a pretty small

00:34:51,400 --> 00:34:56,770
one but it removes an annoyance remember

00:34:55,300 --> 00:34:58,990
that sometimes you have to write this

00:34:56,770 --> 00:35:00,580
case for instance if you have a list of

00:34:58,990 --> 00:35:01,840
pairs and you want to map over that

00:35:00,580 --> 00:35:03,610
because map takes only a single

00:35:01,840 --> 00:35:06,010
parameter such as you want to

00:35:03,610 --> 00:35:07,990
essentially pattern match on the pair so

00:35:06,010 --> 00:35:11,830
you have to do this with this case but

00:35:07,990 --> 00:35:13,420
yeah I guess most of us have already at

00:35:11,830 --> 00:35:15,280
some point or other reached for this

00:35:13,420 --> 00:35:16,780
syntax here and then the compiler told

00:35:15,280 --> 00:35:19,090
us that it wasn't available that he

00:35:16,780 --> 00:35:21,430
couldn't do it now in the future you it

00:35:19,090 --> 00:35:23,950
will be available there's a conversion

00:35:21,430 --> 00:35:27,700
that that actually lets you essentially

00:35:23,950 --> 00:35:30,130
write this and do the other the next

00:35:27,700 --> 00:35:32,800
thing is like I said try parameters so

00:35:30,130 --> 00:35:34,450
traits can have parameters like classes

00:35:32,800 --> 00:35:39,340
can have so they're very much in line

00:35:34,450 --> 00:35:43,960
with classes now so that basically means

00:35:39,340 --> 00:35:45,880
that traits and classes are such a two

00:35:43,960 --> 00:35:48,100
sides of the same thing if it's abstract

00:35:45,880 --> 00:35:50,290
and used right if it's concrete used

00:35:48,100 --> 00:35:53,050
class as the first guidance I think

00:35:50,290 --> 00:35:55,990
that's that's a pretty good rule of

00:35:53,050 --> 00:35:59,260
thumb the next thing is static methods

00:35:55,990 --> 00:36:01,300
and fields so you can run now right so

00:35:59,260 --> 00:36:02,920
you have a static annotation you write

00:36:01,300 --> 00:36:04,990
it in the object but it will mean that

00:36:02,920 --> 00:36:08,110
these things are implemented as static

00:36:04,990 --> 00:36:11,560
members in the underlying Java bytecode

00:36:08,110 --> 00:36:13,660
which should help a lot

00:36:11,560 --> 00:36:15,730
sometimes for performance these things

00:36:13,660 --> 00:36:18,430
are still a little bit faster than

00:36:15,730 --> 00:36:22,230
actually going by an object and more so

00:36:18,430 --> 00:36:25,600
for interrupt because in a lot of the

00:36:22,230 --> 00:36:27,490
Java frameworks has fairly strict

00:36:25,600 --> 00:36:29,920
requirements what should be static a

00:36:27,490 --> 00:36:32,620
static field like for serialization and

00:36:29,920 --> 00:36:35,950
hibernate and and things like that so it

00:36:32,620 --> 00:36:40,030
should help with that multiversal

00:36:35,950 --> 00:36:41,800
equality I just had a proposal out there

00:36:40,030 --> 00:36:44,050
so it's not yet merged but I guess it

00:36:41,800 --> 00:36:46,830
probably will be so that means we will

00:36:44,050 --> 00:36:51,090
make equals and not equals type size

00:36:46,830 --> 00:36:51,090
equals an article's thank you

00:36:51,360 --> 00:36:57,730
that was like the last holdout of the

00:36:54,990 --> 00:37:01,060
dynamically-typed nature and essentially

00:36:57,730 --> 00:37:03,370
you can you can have the excuse we got

00:37:01,060 --> 00:37:10,450
it from Java but it's not really a good

00:37:03,370 --> 00:37:13,390
excuse so so the the problems are most

00:37:10,450 --> 00:37:15,600
before refactorings that I really had a

00:37:13,390 --> 00:37:18,250
case where I wanted to do a refactoring

00:37:15,600 --> 00:37:20,350
both rather involved in the body

00:37:18,250 --> 00:37:22,240
compiler code base and let's get away

00:37:20,350 --> 00:37:24,580
from it because I said well with these

00:37:22,240 --> 00:37:26,680
things we will never be able to control

00:37:24,580 --> 00:37:28,330
essentially all the points where we

00:37:26,680 --> 00:37:29,980
might introduce essentially an

00:37:28,330 --> 00:37:32,350
incompatibility that doesn't get

00:37:29,980 --> 00:37:34,420
detected scan is pretty good in all

00:37:32,350 --> 00:37:36,130
other instances to say well it requires

00:37:34,420 --> 00:37:38,170
your cooperation of course you have to

00:37:36,130 --> 00:37:40,600
put in very good types of precise types

00:37:38,170 --> 00:37:43,180
for your data types but when you do then

00:37:40,600 --> 00:37:45,160
it gives us in return the assurance that

00:37:43,180 --> 00:37:48,580
you can refactor with confidence

00:37:45,160 --> 00:37:50,770
except for Universal equality so I think

00:37:48,580 --> 00:37:56,920
that's the last holdout so you're going

00:37:50,770 --> 00:37:59,200
to fix that named sorry and here the

00:37:56,920 --> 00:38:02,260
last one was named type parameters so

00:37:59,200 --> 00:38:05,770
that's essentially a thing where on the

00:38:02,260 --> 00:38:08,080
one hand it fixes a sort of an asymmetry

00:38:05,770 --> 00:38:10,270
that you can say you can have normal

00:38:08,080 --> 00:38:13,450
parameters with Mal and that means it's

00:38:10,270 --> 00:38:15,820
a field in the class now for the type

00:38:13,450 --> 00:38:17,980
parameters we said internally a type

00:38:15,820 --> 00:38:19,360
parameters are field of the class it

00:38:17,980 --> 00:38:21,730
will be a field with a name that's

00:38:19,360 --> 00:38:23,200
unvisible to you because otherwise the

00:38:21,730 --> 00:38:26,170
name might conflict with other things

00:38:23,200 --> 00:38:28,320
but of course that's a opportunity to

00:38:26,170 --> 00:38:31,240
say we might give you that that that

00:38:28,320 --> 00:38:33,160
power to say well if I want the type

00:38:31,240 --> 00:38:36,070
parameter to really be a field in the

00:38:33,160 --> 00:38:38,350
class then now there's very very concise

00:38:36,070 --> 00:38:40,420
syntax for that and one of the immediate

00:38:38,350 --> 00:38:43,000
advantages of doing that is that it

00:38:40,420 --> 00:38:44,710
gives you a neat way also to get to for

00:38:43,000 --> 00:38:46,690
partial type parameterization

00:38:44,710 --> 00:38:48,250
because now you could write with map

00:38:46,690 --> 00:38:50,080
like that you could write map of key

00:38:48,250 --> 00:38:52,990
equals int and that means you haven't

00:38:50,080 --> 00:38:55,300
specified the value and if that map is

00:38:52,990 --> 00:38:57,010
not a type but a function and you can do

00:38:55,300 --> 00:38:58,510
that and the other type will just be

00:38:57,010 --> 00:39:00,130
inferred so that's something that people

00:38:58,510 --> 00:39:02,750
have asked for a long time that we said

00:39:00,130 --> 00:39:04,160
well if you have many complicated types

00:39:02,750 --> 00:39:06,110
either you have to give them all and

00:39:04,160 --> 00:39:08,480
it's tedious or you have to rely on

00:39:06,110 --> 00:39:10,910
inference from on them all but what if I

00:39:08,480 --> 00:39:12,350
may be some type can't be inferred so I

00:39:10,910 --> 00:39:14,600
have to give it but the others should be

00:39:12,350 --> 00:39:17,660
inferred so that's that's an advantage

00:39:14,600 --> 00:39:20,270
here so motivation here where overall

00:39:17,660 --> 00:39:26,210
better foundations easier safer to use

00:39:20,270 --> 00:39:28,790
and more orthogonal T so there are also

00:39:26,210 --> 00:39:29,480
some improvements in detail so type

00:39:28,790 --> 00:39:31,360
system

00:39:29,480 --> 00:39:33,590
like I said strongly influenced by dot

00:39:31,360 --> 00:39:36,530
there's a better integration of type

00:39:33,590 --> 00:39:40,460
refinements the type inference has been

00:39:36,530 --> 00:39:44,360
redone from the ground up so now we have

00:39:40,460 --> 00:39:46,700
essentially a fairly simple inference

00:39:44,360 --> 00:39:48,620
algorithm that works with a subtyping

00:39:46,700 --> 00:39:50,150
constraint solver previously we didn't

00:39:48,620 --> 00:39:51,920
have that it was sort of an ad hoc way

00:39:50,150 --> 00:39:55,670
we did we dealt with these things and

00:39:51,920 --> 00:39:57,440
that means that we can actually I'm very

00:39:55,670 --> 00:39:58,940
confident we haven't done it yet but I'm

00:39:57,440 --> 00:40:00,590
very confident that it will be much

00:39:58,940 --> 00:40:02,990
simpler to actually specify what

00:40:00,590 --> 00:40:06,110
inference does because we essentially

00:40:02,990 --> 00:40:07,490
can say okay type inference it traverses

00:40:06,110 --> 00:40:09,170
your program it generates these

00:40:07,490 --> 00:40:11,450
constraints and the constraints what we

00:40:09,170 --> 00:40:13,520
solve that certain points and that's the

00:40:11,450 --> 00:40:17,300
job of the constraints over but which

00:40:13,520 --> 00:40:19,580
can be specified declaratively we worked

00:40:17,300 --> 00:40:22,430
on implicit search so search algorithm

00:40:19,580 --> 00:40:24,500
got faster and it's now better behaved

00:40:22,430 --> 00:40:26,990
for contravariant types implicit search

00:40:24,500 --> 00:40:29,030
was pretty useless for types like that

00:40:26,990 --> 00:40:32,090
very naturally contravariant like

00:40:29,030 --> 00:40:35,560
equality types or comparison and things

00:40:32,090 --> 00:40:38,270
like that we worked on value classes so

00:40:35,560 --> 00:40:40,820
nested value classes has been done in

00:40:38,270 --> 00:40:43,430
arrays of value classes will be in the

00:40:40,820 --> 00:40:45,590
code base very shortly okay

00:40:43,430 --> 00:40:48,740
so who's working on how that so so far

00:40:45,590 --> 00:40:50,840
it was mostly my team at EPFL including

00:40:48,740 --> 00:40:53,810
Demetri patrasche goku your mattress

00:40:50,840 --> 00:40:56,330
vladimir nikolayevich mother and many

00:40:53,810 --> 00:40:58,850
others that i've not not mentioned so

00:40:56,330 --> 00:41:01,190
them a lot of young people coming into

00:40:58,850 --> 00:41:03,050
the development and that's great it's

00:41:01,190 --> 00:41:04,730
got a teammate like band also helped in

00:41:03,050 --> 00:41:07,370
particular with infrastructures

00:41:04,730 --> 00:41:09,680
reviews and suggestions and that's a

00:41:07,370 --> 00:41:11,900
thing where again contributions and

00:41:09,680 --> 00:41:14,410
collaborations by others would be very

00:41:11,900 --> 00:41:14,410
much appreciated

00:41:14,740 --> 00:41:21,990
might ask well where's the tooling well

00:41:17,230 --> 00:41:24,880
it's just coming along not enough that

00:41:21,990 --> 00:41:27,790
but the developments are all very recent

00:41:24,880 --> 00:41:29,980
so we have a basic SPT integration so

00:41:27,790 --> 00:41:32,470
you can run it on this PT that can't be

00:41:29,980 --> 00:41:34,870
working on incremental compilation so 30

00:41:32,470 --> 00:41:36,910
compilation from SPT we have a wrapper

00:41:34,870 --> 00:41:41,980
and the repple even if says syntax

00:41:36,910 --> 00:41:44,140
highlighting yeah an IDE I'm very much

00:41:41,980 --> 00:41:46,270
looking forward to IntelliJ stock later

00:41:44,140 --> 00:41:48,010
the conference at the conference where

00:41:46,270 --> 00:41:52,090
they will tell us where they are with it

00:41:48,010 --> 00:41:55,390
they worked on it doc generation is

00:41:52,090 --> 00:41:57,660
under work so particularly the new doc

00:41:55,390 --> 00:41:59,710
doc generation tool will have dynamic

00:41:57,660 --> 00:42:01,870
hyperlinks so that you can cross link

00:41:59,710 --> 00:42:03,940
libraries that means Java Script thing

00:42:01,870 --> 00:42:06,600
is that previously the problem as you

00:42:03,940 --> 00:42:09,880
know is that what once you defer to a

00:42:06,600 --> 00:42:11,740
function sin or items in another library

00:42:09,880 --> 00:42:13,240
then you didn't get the links anymore

00:42:11,740 --> 00:42:15,640
because everything had to be compared

00:42:13,240 --> 00:42:18,610
together so the documentation was

00:42:15,640 --> 00:42:22,930
incompatible with separate compilation

00:42:18,610 --> 00:42:24,610
and again I will only say 3/4 of words

00:42:22,930 --> 00:42:27,220
is this linker which is a whole program

00:42:24,610 --> 00:42:30,040
analyser optimizer using tasty for

00:42:27,220 --> 00:42:32,350
serialization and it among several other

00:42:30,040 --> 00:42:35,350
things it makes specialization cheaper

00:42:32,350 --> 00:42:36,600
and much more robust and that would be

00:42:35,350 --> 00:42:39,040
all of it from me because

00:42:36,600 --> 00:42:44,380
Dimity we'll talk later about it at the

00:42:39,040 --> 00:42:46,810
conference good and so far so good but

00:42:44,380 --> 00:42:49,800
question is well this looks like a

00:42:46,810 --> 00:42:53,770
fairly major problem a project which

00:42:49,800 --> 00:42:55,870
which solve some things some itches

00:42:53,770 --> 00:42:58,210
which is nice but is it really worth

00:42:55,870 --> 00:43:00,430
sort of betting on it or is it really

00:42:58,210 --> 00:43:01,720
worth getting involved in it so I also

00:43:00,430 --> 00:43:03,220
wanted to tell you a little bit where I

00:43:01,720 --> 00:43:05,770
see the future because that's the thing

00:43:03,220 --> 00:43:08,680
that at least for me invites excites me

00:43:05,770 --> 00:43:11,010
most so what we have planned and in some

00:43:08,680 --> 00:43:14,530
imparts we have very concrete plans are

00:43:11,010 --> 00:43:17,250
several things that we want to add and

00:43:14,530 --> 00:43:19,750
explore so here the most important ones

00:43:17,250 --> 00:43:22,930
Scala meta implicit function types

00:43:19,750 --> 00:43:25,750
effect systems now safety generic

00:43:22,930 --> 00:43:27,800
programming and better records so let me

00:43:25,750 --> 00:43:31,240
take them again one by one and after

00:43:27,800 --> 00:43:33,650
I guarantee that your head spins so

00:43:31,240 --> 00:43:35,600
Kalamata is essentially Eugene ver

00:43:33,650 --> 00:43:36,980
Marcos new project on which it's been

00:43:35,600 --> 00:43:38,780
working for a while and which is

00:43:36,980 --> 00:43:39,200
scheduled to essentially be integrated

00:43:38,780 --> 00:43:41,840
in dari

00:43:39,200 --> 00:43:44,000
so the way it's integrated will differ a

00:43:41,840 --> 00:43:46,040
little bit from macros so you see that

00:43:44,000 --> 00:43:49,850
here so essentially what we plan to have

00:43:46,040 --> 00:43:52,070
is two new keywords one is called inline

00:43:49,850 --> 00:43:54,260
and the other is called meta so inline

00:43:52,070 --> 00:43:56,030
is the name implies is just enlightening

00:43:54,260 --> 00:43:58,400
it says you have this thing and it is a

00:43:56,030 --> 00:43:59,900
compiled known compile time thing it's a

00:43:58,400 --> 00:44:02,660
compile time method body

00:43:59,900 --> 00:44:04,820
it's a compile-time constant particular

00:44:02,660 --> 00:44:06,110
inline will replace final as this funny

00:44:04,820 --> 00:44:08,600
way to say this is a compile-time

00:44:06,110 --> 00:44:10,820
constant so final was sort of taken from

00:44:08,600 --> 00:44:12,830
Java but it was very weird so now you

00:44:10,820 --> 00:44:15,020
say in line x equals three and you know

00:44:12,830 --> 00:44:16,760
it's a compile-time constant three and

00:44:15,020 --> 00:44:19,280
you can also say inline to a parameter

00:44:16,760 --> 00:44:20,750
which means well leap or the actual

00:44:19,280 --> 00:44:22,700
value at this point must be a

00:44:20,750 --> 00:44:25,760
compile-time constant so you will be

00:44:22,700 --> 00:44:27,710
able to specify that and all that has

00:44:25,760 --> 00:44:29,480
nothing with to do with meta program is

00:44:27,710 --> 00:44:31,100
just simple inlining partial evaluation

00:44:29,480 --> 00:44:33,140
you could say but you can already do

00:44:31,100 --> 00:44:35,600
quite a bit of that then the next step

00:44:33,140 --> 00:44:37,970
is meta so meta is essentially the

00:44:35,600 --> 00:44:40,850
switch where you can now go from is a g

00:44:37,970 --> 00:44:43,310
compiler values to trees so you say well

00:44:40,850 --> 00:44:46,040
if you have an int then let's say here's

00:44:43,310 --> 00:44:49,550
a float as a parameter then inside the

00:44:46,040 --> 00:44:51,860
meta block I will know that this the

00:44:49,550 --> 00:44:53,750
actual argument is a syntax tree and

00:44:51,860 --> 00:44:55,880
absolute syntax tree that gives me a

00:44:53,750 --> 00:44:57,800
float at the end so I can inspect that

00:44:55,880 --> 00:44:59,660
syntax tree with quasi quotes and I

00:44:57,800 --> 00:45:02,150
can't construct new syntax trees and

00:44:59,660 --> 00:45:05,180
return them on the other hand if the

00:45:02,150 --> 00:45:07,940
actual argument is an inline X int then

00:45:05,180 --> 00:45:10,250
the meta part will know well that's now

00:45:07,940 --> 00:45:12,830
an integer that's an intelligent integer

00:45:10,250 --> 00:45:15,890
that I know and can use so that's the

00:45:12,830 --> 00:45:18,740
new separation the other thing that's

00:45:15,890 --> 00:45:20,570
very important is that we will no longer

00:45:18,740 --> 00:45:22,730
run this with reflection that means we

00:45:20,570 --> 00:45:25,250
will write an interpreter that

00:45:22,730 --> 00:45:27,020
essentially will interpret SCADA as far

00:45:25,250 --> 00:45:29,180
as it's needed for marking expansion

00:45:27,020 --> 00:45:30,680
which is pretty much everything in an

00:45:29,180 --> 00:45:33,020
interpreter that can be run by the

00:45:30,680 --> 00:45:35,030
compiler the advantage of running it

00:45:33,020 --> 00:45:37,490
with an interpreter is not only is it's

00:45:35,030 --> 00:45:39,160
portable but it's also sandboxed we can

00:45:37,490 --> 00:45:41,560
say well we won't actually

00:45:39,160 --> 00:45:43,030
take all your heap take arbitrary lot of

00:45:41,560 --> 00:45:45,100
time to do that the compiler can

00:45:43,030 --> 00:45:47,590
actually have very strict limits what

00:45:45,100 --> 00:45:50,590
macros are allowed to do and that would

00:45:47,590 --> 00:45:52,060
at least me let me sleep much sounder

00:45:50,590 --> 00:45:56,110
than then right now

00:45:52,060 --> 00:45:58,150
so that was got a meta the next thing is

00:45:56,110 --> 00:46:00,820
something that looks really small but

00:45:58,150 --> 00:46:03,220
it's actually huge that's implicit

00:46:00,820 --> 00:46:05,470
function types so an implicit function

00:46:03,220 --> 00:46:07,450
type you see that here at the top it's

00:46:05,470 --> 00:46:10,000
actually rather simple you have a normal

00:46:07,450 --> 00:46:11,740
function type context arrow s and you

00:46:10,000 --> 00:46:14,230
can write implicit in front of the

00:46:11,740 --> 00:46:17,890
context like an implicit parameter but

00:46:14,230 --> 00:46:22,150
in the function type so the meaning of

00:46:17,890 --> 00:46:26,710
that is that if you call the function f

00:46:22,150 --> 00:46:29,350
with some so if you call a function that

00:46:26,710 --> 00:46:32,770
has as its result type an implicit

00:46:29,350 --> 00:46:36,610
function type like context s then of

00:46:32,770 --> 00:46:38,020
course as if there was an exit as if

00:46:36,610 --> 00:46:39,880
there was an implicit parameter you'd

00:46:38,020 --> 00:46:41,770
given directly that the thing gets

00:46:39,880 --> 00:46:44,920
caught so it's like an implicit method

00:46:41,770 --> 00:46:47,560
and furthermore in in the body of the

00:46:44,920 --> 00:46:49,870
function we can also essentially refer

00:46:47,560 --> 00:46:51,490
to this context thing because that's

00:46:49,870 --> 00:46:53,980
essentially as part of this result type

00:46:51,490 --> 00:46:57,040
we assume that an implicit thing is

00:46:53,980 --> 00:46:59,440
passed so this looks rather small it's

00:46:57,040 --> 00:47:01,570
just essentially a way to essentially

00:46:59,440 --> 00:47:03,250
hide these implicit parameters but it's

00:47:01,570 --> 00:47:06,190
actually huge because it's the first

00:47:03,250 --> 00:47:08,350
time we can abstract over implicit

00:47:06,190 --> 00:47:10,900
parameters previously implicit

00:47:08,350 --> 00:47:12,670
parameters had had be written out every

00:47:10,900 --> 00:47:14,590
time you use them you had to write them

00:47:12,670 --> 00:47:17,230
out again there was no way to abbreviate

00:47:14,590 --> 00:47:20,590
them and as you all know once I have a

00:47:17,230 --> 00:47:22,870
mean of abstraction I can go enormously

00:47:20,590 --> 00:47:24,250
far with that so now we have about a

00:47:22,870 --> 00:47:26,320
very important feature in Scott an

00:47:24,250 --> 00:47:28,480
implicit parameter so we have a way to

00:47:26,320 --> 00:47:30,970
actually abstract that and that gives us

00:47:28,480 --> 00:47:34,240
enormous power it also eliminates a lot

00:47:30,970 --> 00:47:36,940
of boilerplate so that leads us directly

00:47:34,240 --> 00:47:41,080
to the next thing which is even bigger

00:47:36,940 --> 00:47:43,810
and that's effects so the way to treat

00:47:41,080 --> 00:47:47,140
effects we will try to treat the effects

00:47:43,810 --> 00:47:49,750
in Scala is as implicit capabilities so

00:47:47,140 --> 00:47:51,980
instead of saying well here's the thing

00:47:49,750 --> 00:47:54,109
that throws an exception as I

00:47:51,980 --> 00:47:56,930
is a thing that needs the capability to

00:47:54,109 --> 00:47:58,730
throw an exception and I expressed that

00:47:56,930 --> 00:48:01,280
capability as an implicit parameter

00:47:58,730 --> 00:48:03,470
first as a parameter somebody is to pass

00:48:01,280 --> 00:48:07,340
the capability and then I make it

00:48:03,470 --> 00:48:09,230
implicit because it means that I avoid

00:48:07,340 --> 00:48:10,730
all the boilerplate of passing but you

00:48:09,230 --> 00:48:12,380
can throw this exception you can throw

00:48:10,730 --> 00:48:14,150
this exception I can essentially hide

00:48:12,380 --> 00:48:16,910
that in the type but it's still there it

00:48:14,150 --> 00:48:19,400
will give you a type error if you do

00:48:16,910 --> 00:48:21,109
something unexpected and of course with

00:48:19,400 --> 00:48:23,990
the implicit function types we can make

00:48:21,109 --> 00:48:26,359
this very very concise as concise as the

00:48:23,990 --> 00:48:30,200
best of the effect systems out there so

00:48:26,359 --> 00:48:32,720
I recently got got a grant to look at

00:48:30,200 --> 00:48:35,600
that over the next years with

00:48:32,720 --> 00:48:39,619
significant resources so we can expect

00:48:35,600 --> 00:48:41,600
some something very interesting in that

00:48:39,619 --> 00:48:44,150
domain but it's something where we say

00:48:41,600 --> 00:48:46,490
we will be out you'd have planned now

00:48:44,150 --> 00:48:48,770
let's put it in emotion and implement it

00:48:46,490 --> 00:48:50,960
and then evaluate it and hopefully it

00:48:48,770 --> 00:48:53,960
will will work out but it's too early to

00:48:50,960 --> 00:48:57,859
make any promises here okay the next

00:48:53,960 --> 00:48:59,780
thing then would be malleable types so

00:48:57,859 --> 00:49:01,280
it's kind of an embarrassment for

00:48:59,780 --> 00:49:04,190
scarlet it's kind of sort of the last

00:49:01,280 --> 00:49:06,080
language that still is know right so a

00:49:04,190 --> 00:49:09,350
lot of newer languages don't have it

00:49:06,080 --> 00:49:11,090
anymore coupling or or swift or none of

00:49:09,350 --> 00:49:19,550
these languages has now they say our

00:49:11,090 --> 00:49:21,859
Scala ho-oh retro is that so so there

00:49:19,550 --> 00:49:26,270
were some efforts to actually do that

00:49:21,859 --> 00:49:28,490
avoid make now explicit previously but

00:49:26,270 --> 00:49:31,130
they were sort of got stuck very early

00:49:28,490 --> 00:49:34,010
because there's the objection which I

00:49:31,130 --> 00:49:36,200
totally get it to say well we asked our

00:49:34,010 --> 00:49:38,480
community we don't really use now that

00:49:36,200 --> 00:49:39,920
much it's been sort of replaced people

00:49:38,480 --> 00:49:41,240
almost never have null pointer

00:49:39,920 --> 00:49:43,460
exceptions because they have learnt to

00:49:41,240 --> 00:49:45,260
use options or other ways to treat it so

00:49:43,460 --> 00:49:47,510
it's not that important but actually

00:49:45,260 --> 00:49:49,550
there's another thing that has become

00:49:47,510 --> 00:49:51,230
more important and that's again has to

00:49:49,550 --> 00:49:53,030
do with the foundations that you say now

00:49:51,230 --> 00:49:55,490
that we actually have good foundations

00:49:53,030 --> 00:49:57,830
now is an embarrassment because with now

00:49:55,490 --> 00:50:01,300
you can really do horrible trickeries

00:49:57,830 --> 00:50:03,160
that really don't have any way to

00:50:01,300 --> 00:50:05,050
to be modeled in the foundations the

00:50:03,160 --> 00:50:07,210
foundations require that certain things

00:50:05,050 --> 00:50:08,890
are not now or otherwise you would say

00:50:07,210 --> 00:50:11,200
all bets are off and of course there

00:50:08,890 --> 00:50:13,330
many amusing counter examples where

00:50:11,200 --> 00:50:16,420
Scala compiler you're drunker that

00:50:13,330 --> 00:50:19,060
involve a lot of them invoke involve

00:50:16,420 --> 00:50:21,310
some creative use of notes so it would

00:50:19,060 --> 00:50:23,590
be interesting and I think important to

00:50:21,310 --> 00:50:26,230
avoid that and also it would be very

00:50:23,590 --> 00:50:28,600
cheap now for several reasons one is we

00:50:26,230 --> 00:50:30,190
can actually model now as a union type

00:50:28,600 --> 00:50:32,620
we are union type so we can have a type

00:50:30,190 --> 00:50:34,660
for now we said well that's the null

00:50:32,620 --> 00:50:38,280
object and no other object is in that

00:50:34,660 --> 00:50:40,690
type and we have or so we can say the

00:50:38,280 --> 00:50:42,970
proposed syntax the question mark is

00:50:40,690 --> 00:50:45,940
actually key or now Salem did the same

00:50:42,970 --> 00:50:48,340
thing and that means we have a very good

00:50:45,940 --> 00:50:50,410
basis to talk about these things and the

00:50:48,340 --> 00:50:52,570
other thing that's very interesting here

00:50:50,410 --> 00:50:54,310
is to say well what do we do about now

00:50:52,570 --> 00:50:56,290
dereferencing so there's the

00:50:54,310 --> 00:50:57,940
embarrassing situation here like you

00:50:56,290 --> 00:50:59,770
have system out and it's a print stream

00:50:57,940 --> 00:51:03,250
question mark becomes it because it

00:50:59,770 --> 00:51:05,470
comes from Java it can be now right so

00:51:03,250 --> 00:51:07,300
if you want to write system out of print

00:51:05,470 --> 00:51:07,990
on and the type system aside no no you

00:51:07,300 --> 00:51:10,360
can't do that

00:51:07,990 --> 00:51:11,740
but that's that's kind of annoying we

00:51:10,360 --> 00:51:14,520
want to keep writing out the writing

00:51:11,740 --> 00:51:17,290
system out print right so the

00:51:14,520 --> 00:51:20,560
interesting thing here would be to say

00:51:17,290 --> 00:51:22,540
well raising a nullpointerexception is

00:51:20,560 --> 00:51:24,310
an effect like raising other exceptions

00:51:22,540 --> 00:51:26,620
as well and we will essentially force

00:51:24,310 --> 00:51:28,150
you to declare it explicitly but there's

00:51:26,620 --> 00:51:29,890
a mode actually which we need for

00:51:28,150 --> 00:51:31,630
backwards compatibility anyway that says

00:51:29,890 --> 00:51:33,430
I'm impure I can raise whatever

00:51:31,630 --> 00:51:35,710
exceptions that do whatever are the side

00:51:33,430 --> 00:51:37,630
effects and most all scholar programs

00:51:35,710 --> 00:51:40,660
will start out in in pure state and

00:51:37,630 --> 00:51:42,520
maybe gradually might move towards pure

00:51:40,660 --> 00:51:44,830
state by essentially taking away these

00:51:42,520 --> 00:51:46,210
capabilities to be impure so it means

00:51:44,830 --> 00:51:48,040
that we can actually give you a choice

00:51:46,210 --> 00:51:50,080
to say as long as I mean I'm impure I

00:51:48,040 --> 00:51:52,450
can also write system out of print on if

00:51:50,080 --> 00:51:54,250
I claim I won't ever raise a null point

00:51:52,450 --> 00:51:56,260
exception that yes of course you can't

00:51:54,250 --> 00:51:58,480
do that anymore because the out might be

00:51:56,260 --> 00:51:59,710
male and you have to essentially guard

00:51:58,480 --> 00:52:01,690
against that thing but the choice is

00:51:59,710 --> 00:52:03,520
yours as a programmer so that's that's

00:52:01,690 --> 00:52:07,590
why I think this thing has actually a

00:52:03,520 --> 00:52:10,210
chance of flying now next thing is

00:52:07,590 --> 00:52:12,520
generic programming so that's another

00:52:10,210 --> 00:52:13,570
thing that said she has been a long way

00:52:12,520 --> 00:52:17,590
in coming the

00:52:13,570 --> 00:52:18,610
Barriss meant this topic 2222 all these

00:52:17,590 --> 00:52:20,380
22s

00:52:18,610 --> 00:52:22,990
maybe it may be that time should be up

00:52:20,380 --> 00:52:25,260
and there ways to do it shapeless has

00:52:22,990 --> 00:52:27,640
demonstrated at Haskell as demonstrated

00:52:25,260 --> 00:52:31,630
scrap your boiler plate before and I

00:52:27,640 --> 00:52:33,280
think we should work hard and make make

00:52:31,630 --> 00:52:36,330
a serious effort to actually get that

00:52:33,280 --> 00:52:39,430
into into the bass language so one way

00:52:36,330 --> 00:52:41,560
we will do that for instance is to say

00:52:39,430 --> 00:52:43,900
if you have at a pole like a 3-tuple

00:52:41,560 --> 00:52:46,540
SD us types and that's really at

00:52:43,900 --> 00:52:49,450
radiation only for essentially something

00:52:46,540 --> 00:52:51,850
that in shapeless would be described by

00:52:49,450 --> 00:52:55,060
an age list so essentially a pair of

00:52:51,850 --> 00:52:57,640
pair of pair of your head so these these

00:52:55,060 --> 00:52:59,950
these these tablets would have a lisp

00:52:57,640 --> 00:53:02,050
like structure but unless unlike

00:52:59,950 --> 00:53:04,090
shapeless they would be implemented as

00:53:02,050 --> 00:53:07,000
efficiently as now so we would actually

00:53:04,090 --> 00:53:09,670
have essentially classes for temples up

00:53:07,000 --> 00:53:11,980
to four otherwise I literally would use

00:53:09,670 --> 00:53:16,150
an array to not essentially have any

00:53:11,980 --> 00:53:18,610
indirection in these things okay and

00:53:16,150 --> 00:53:20,320
finally better records so essentially

00:53:18,610 --> 00:53:22,570
watch an egg programming was for tuples

00:53:20,320 --> 00:53:24,610
we want to do when we have labels as

00:53:22,570 --> 00:53:27,850
well so that's also needed for let's say

00:53:24,610 --> 00:53:30,130
things to support such a data engines

00:53:27,850 --> 00:53:31,720
like slick or spark really well so

00:53:30,130 --> 00:53:34,900
that's another thing that we want to

00:53:31,720 --> 00:53:37,690
look at here good

00:53:34,900 --> 00:53:41,980
so lots of blue-sky thing lots of

00:53:37,690 --> 00:53:44,260
excitement you might say well are these

00:53:41,980 --> 00:53:46,300
our problems don't we have other

00:53:44,260 --> 00:53:49,450
problems as a scholar community what

00:53:46,300 --> 00:53:51,880
about the guardrails because after all I

00:53:49,450 --> 00:53:53,800
think scadas premise has been always and

00:53:51,880 --> 00:53:56,980
still is that we want to trust

00:53:53,800 --> 00:53:59,230
developers to do the right thing that

00:53:56,980 --> 00:54:02,200
was always that's gotta appeal to always

00:53:59,230 --> 00:54:04,990
appeal to develop a duty to to give you

00:54:02,200 --> 00:54:06,430
a lot of power give you an only return

00:54:04,990 --> 00:54:09,490
trust you to do the right thing with

00:54:06,430 --> 00:54:11,830
with that power but what if you don't or

00:54:09,490 --> 00:54:15,670
can you even agree what the right thing

00:54:11,830 --> 00:54:17,920
is so I want to compute that talk with

00:54:15,670 --> 00:54:19,450
some essentially thoughts about how what

00:54:17,920 --> 00:54:21,430
we can do about these things without

00:54:19,450 --> 00:54:22,810
actually cutting down the language too

00:54:21,430 --> 00:54:25,150
much and making the language very

00:54:22,810 --> 00:54:26,810
complicated with lots of ad hoc rules

00:54:25,150 --> 00:54:29,120
because we think we might be

00:54:26,810 --> 00:54:31,310
we should prevent one or the other of

00:54:29,120 --> 00:54:34,490
doing a terrible thing so I think my

00:54:31,310 --> 00:54:36,500
first advice would be read that's me how

00:54:34,490 --> 00:54:38,420
I use blog strategic scholar style

00:54:36,500 --> 00:54:40,970
principle of least power if you haven't

00:54:38,420 --> 00:54:43,580
read it yet please do read it make your

00:54:40,970 --> 00:54:46,670
collaborators read it agree as a team

00:54:43,580 --> 00:54:49,940
that this is the guy that the route to

00:54:46,670 --> 00:54:51,710
fall out if somebody violates this

00:54:49,940 --> 00:54:54,170
principle of least power then

00:54:51,710 --> 00:54:55,610
essentially put it in the pole request

00:54:54,170 --> 00:54:57,620
review and these things that's very

00:54:55,610 --> 00:55:00,440
important printer of these powers and

00:54:57,620 --> 00:55:02,270
possess for everything you do you should

00:55:00,440 --> 00:55:04,790
use the language construct with the

00:55:02,270 --> 00:55:07,340
least power that achieves that thing or

00:55:04,790 --> 00:55:08,750
another ice go don't go overboard with

00:55:07,340 --> 00:55:11,210
essentially playing with a lot of

00:55:08,750 --> 00:55:13,160
advanced technology because that

00:55:11,210 --> 00:55:15,590
essentially the users of that library

00:55:13,160 --> 00:55:18,530
will be a hard time the reason for using

00:55:15,590 --> 00:55:20,720
the least expressive thing is that also

00:55:18,530 --> 00:55:23,240
a principle of minimal surprise if

00:55:20,720 --> 00:55:27,200
they're less powerful you take the

00:55:23,240 --> 00:55:28,730
techniques are achieve that thing the

00:55:27,200 --> 00:55:31,220
more that your design space is

00:55:28,730 --> 00:55:32,900
constrained and somebody who reads your

00:55:31,220 --> 00:55:34,670
code once the design space to be

00:55:32,900 --> 00:55:36,290
constrained because the more constraint

00:55:34,670 --> 00:55:38,120
it is the closer it will fit your

00:55:36,290 --> 00:55:39,800
expectations and the easier it will be

00:55:38,120 --> 00:55:43,250
to find things there was something that

00:55:39,800 --> 00:55:45,110
I always regret it a little bit to see

00:55:43,250 --> 00:55:46,850
well if I look at Python because Python

00:55:45,110 --> 00:55:48,820
is sort of has a different culture and

00:55:46,850 --> 00:55:52,100
it doesn't have types that actually can

00:55:48,820 --> 00:55:54,200
can sustain very complex operations a

00:55:52,100 --> 00:55:56,540
lot of the Python API is a super super

00:55:54,200 --> 00:55:58,400
simple and that's a quality that's great

00:55:56,540 --> 00:56:02,570
that's what what we should strive to get

00:55:58,400 --> 00:56:04,370
more of in in Scala but what if it

00:56:02,570 --> 00:56:06,230
doesn't happen what if you deal with a

00:56:04,370 --> 00:56:08,180
library that does something crazy like I

00:56:06,230 --> 00:56:12,860
talked about implicit at the beginning

00:56:08,180 --> 00:56:14,510
of the talk so what if the libraries

00:56:12,860 --> 00:56:16,280
that we use defines let's say an

00:56:14,510 --> 00:56:18,650
implicit conversion like this one here

00:56:16,280 --> 00:56:22,240
from him to straight well maybe inspired

00:56:18,650 --> 00:56:24,470
by JavaScript so

00:56:22,240 --> 00:56:26,150
actually things like this maybe not from

00:56:24,470 --> 00:56:28,880
into string but from some type to

00:56:26,150 --> 00:56:31,040
unrelated type just prompted an implicit

00:56:28,880 --> 00:56:32,510
conversion there they unfortunately much

00:56:31,040 --> 00:56:35,390
more common in practice than you'd like

00:56:32,510 --> 00:56:36,369
to think so if you use a library like

00:56:35,390 --> 00:56:37,960
that and you imp

00:56:36,369 --> 00:56:40,029
or to package with that in clinical

00:56:37,960 --> 00:56:42,420
version then instead of least power you

00:56:40,029 --> 00:56:47,710
get maximal surprise in your code

00:56:42,420 --> 00:56:50,230
so one modest proposal that I have here

00:56:47,710 --> 00:56:52,059
is to say well for a conversion like

00:56:50,230 --> 00:56:54,970
this here so you have a conversion from

00:56:52,059 --> 00:56:57,579
A to B make it a style error if the

00:56:54,970 --> 00:57:00,249
conversion is not defined in one of the

00:56:57,579 --> 00:57:02,470
packages containing a or B and is itself

00:57:00,249 --> 00:57:04,119
public so that means the thing I want to

00:57:02,470 --> 00:57:06,069
avoid is that essentially I have a type

00:57:04,119 --> 00:57:07,720
here I have a type there somebody else

00:57:06,069 --> 00:57:09,609
comes in a different package and says

00:57:07,720 --> 00:57:12,369
let me relate the two with a magical

00:57:09,609 --> 00:57:14,019
conversion because that's so great and

00:57:12,369 --> 00:57:15,549
obviously nobody ever has thought of

00:57:14,019 --> 00:57:19,029
this but I'm the first but obviously

00:57:15,549 --> 00:57:21,309
it's a great idea to do that so so if

00:57:19,029 --> 00:57:23,440
that is the case then you can do

00:57:21,309 --> 00:57:25,480
whatever you want in your own package

00:57:23,440 --> 00:57:27,309
but outside your package maybe for

00:57:25,480 --> 00:57:28,990
libraries that use that that should be

00:57:27,309 --> 00:57:33,640
something that could be flagged as an

00:57:28,990 --> 00:57:35,890
error as a styler and if you want to do

00:57:33,640 --> 00:57:37,960
that then the error checking as sort of

00:57:35,890 --> 00:57:41,140
to transcend library so if a library

00:57:37,960 --> 00:57:43,359
uses these things and somebody uses the

00:57:41,140 --> 00:57:45,489
library then I think the client fairly

00:57:43,359 --> 00:57:47,259
should be warned as well because it's a

00:57:45,489 --> 00:57:49,299
client who will have to suffer from that

00:57:47,259 --> 00:57:51,069
from that conversion so that requires

00:57:49,299 --> 00:57:54,190
some engineering how we want to do that

00:57:51,069 --> 00:57:57,249
and the last thing has to do about

00:57:54,190 --> 00:57:59,470
flexibility so Scala has great syntactic

00:57:57,249 --> 00:58:03,730
flexibility and sometimes this can be a

00:57:59,470 --> 00:58:06,160
burden and for instance I myself since

00:58:03,730 --> 00:58:09,549
you switched many many times between

00:58:06,160 --> 00:58:12,849
this style here excess dadada and that

00:58:09,549 --> 00:58:14,650
style here excess underscore mass you

00:58:12,849 --> 00:58:18,279
might have your preference for one of

00:58:14,650 --> 00:58:20,049
the other but and as I had but my

00:58:18,279 --> 00:58:22,359
preference changed every couple of

00:58:20,049 --> 00:58:25,239
months from one to the other because

00:58:22,359 --> 00:58:27,609
it's not so easy they say I found no

00:58:25,239 --> 00:58:29,589
universal rule works works everywhere

00:58:27,609 --> 00:58:32,380
because what about for instance this one

00:58:29,589 --> 00:58:34,359
here where it's just this one here what

00:58:32,380 --> 00:58:36,759
about this versus that so here I would

00:58:34,359 --> 00:58:38,769
say well probably the longer this are

00:58:36,759 --> 00:58:40,839
they're more legible the dots versus the

00:58:38,769 --> 00:58:42,430
in fix where for something like men you

00:58:40,839 --> 00:58:44,829
might argue what minis are very

00:58:42,430 --> 00:58:49,700
perfectly now mathematical operator it's

00:58:44,829 --> 00:58:51,620
it is commutative so the asymmetric

00:58:49,700 --> 00:58:53,360
patient just is not aesthetic for me

00:58:51,620 --> 00:58:54,950
right so you could you could say one or

00:58:53,360 --> 00:58:57,590
the other and I'm sure people in this

00:58:54,950 --> 00:58:58,940
room would violently disagree about all

00:58:57,590 --> 00:59:02,120
of these points with each other

00:58:58,940 --> 00:59:05,180
so the proposal that I have here is to

00:59:02,120 --> 00:59:07,550
just add an annotation and fix that

00:59:05,180 --> 00:59:09,740
indicates that an operator is supposed

00:59:07,550 --> 00:59:11,090
to be used in fix so the provider of a

00:59:09,740 --> 00:59:13,630
library would say well I really think

00:59:11,090 --> 00:59:16,730
men make sense as an operator index I

00:59:13,630 --> 00:59:19,130
don't really care whether the library

00:59:16,730 --> 00:59:20,810
provider says that or not the important

00:59:19,130 --> 00:59:23,720
thing is that the users of that library

00:59:20,810 --> 00:59:25,940
agree on the usage because otherwise you

00:59:23,720 --> 00:59:28,580
get this edgy code bases where one part

00:59:25,940 --> 00:59:31,070
is in fix and the other part apart isn't

00:59:28,580 --> 00:59:32,930
so I propose to make it a style array if

00:59:31,070 --> 00:59:35,480
the operator is used in the wrong mode

00:59:32,930 --> 00:59:37,850
so x-men why would be okay

00:59:35,480 --> 00:59:40,460
where's excess map F unless math is here

00:59:37,850 --> 00:59:43,160
also annotated in six would give you a

00:59:40,460 --> 00:59:44,930
warning and but when we are at that then

00:59:43,160 --> 00:59:49,010
I think we can go one step further and

00:59:44,930 --> 00:59:50,690
say for the symbolic operators this

00:59:49,010 --> 00:59:52,910
color is of course gotten a lot of bad

00:59:50,690 --> 00:59:54,890
rap about symbolic operators but most of

00:59:52,910 --> 00:59:56,420
that is in the past of us now but I

00:59:54,890 --> 00:59:59,540
think there's still time to react Chua

00:59:56,420 --> 01:00:01,370
ly fix it and improve things for the

00:59:59,540 --> 01:00:04,040
symbolic operators we could actually

01:00:01,370 --> 01:00:06,710
require that the in fixed annotation

01:00:04,040 --> 01:00:08,810
gets a legible name like attend four

01:00:06,710 --> 01:00:10,880
plus equals and it would be a style

01:00:08,810 --> 01:00:13,880
error if that Elias is missing so that

01:00:10,880 --> 01:00:16,190
would essentially say well you won't

01:00:13,880 --> 01:00:18,380
outlaw symbolic operators so it's very

01:00:16,190 --> 01:00:20,450
useful for scanner but we will require

01:00:18,380 --> 01:00:24,320
that every symbolic operator comes with

01:00:20,450 --> 01:00:26,850
essentially a word that first says how

01:00:24,320 --> 01:00:28,740
to pronounce it that's already been

01:00:26,850 --> 01:00:30,690
and and ii might give you some

01:00:28,740 --> 01:00:33,210
indication of what what its meaning is

01:00:30,690 --> 01:00:36,960
to be work so here i always talked about

01:00:33,210 --> 01:00:38,700
style errors so which sort of indicates

01:00:36,960 --> 01:00:41,160
that maybe the proper place for that is

01:00:38,700 --> 01:00:43,410
not the compiler but a lint tool or

01:00:41,160 --> 01:00:45,540
maybe a mode in the compiler that that's

01:00:43,410 --> 01:00:48,030
the formatting and linting because

01:00:45,540 --> 01:00:49,860
there's this sort of controversy that

01:00:48,030 --> 01:00:53,130
what we hear talk about is very much

01:00:49,860 --> 01:00:55,140
essentially usability factors and they

01:00:53,130 --> 01:00:56,520
can change and they are a little bit at

01:00:55,140 --> 01:00:58,830
hoc and then the compiler at the

01:00:56,520 --> 01:01:00,810
language you try to keep things as lean

01:00:58,830 --> 01:01:03,030
and clean as possible so these things

01:01:00,810 --> 01:01:05,160
typically tend to miss these things up

01:01:03,030 --> 01:01:08,940
but I'm not completely decided about

01:01:05,160 --> 01:01:10,740
that item okay so I think I have pipe I

01:01:08,940 --> 01:01:13,320
have our homes

01:01:10,740 --> 01:01:15,720
yeah it just spent one hour on it so

01:01:13,320 --> 01:01:18,530
which is probably more than I had so

01:01:15,720 --> 01:01:18,530
thank you for listening

01:01:25,910 --> 01:01:27,970

YouTube URL: https://www.youtube.com/watch?v=_2oGY8l67jk


