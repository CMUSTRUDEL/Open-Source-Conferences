Title: Principles of Elegance - by Jon Pretty
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Scala combines a comprehensive array of syntactic features with a rich static type system. At the intersection between Scala's syntactic versatility and its reliable type-level constraints, there exists a narrow window of opportunity for designing APIs that are both expressive and safe; for writing code that is elegant.

We will explore this unique "elegance zone" offered by Scala, with useful real-world examples from Rapture, a collection of libraries for familiar everyday programming tasks, such as working with JSON, XML, HTML and CSV, time, internationalization, logging and I/O. Rapture's philosophy is to drive forwards the state of the art in typesafety, whilst at the same time maintaining the most intuitive syntax.

Ultimately, we will show that features of Scala like implicits and type inference offer some very exciting possibilities for developing software that provides both clearer code and offers more static guarantees, and that writing elegant code in Scala is within everyone's graspâ€”this is Scala's great chance to outshine other languages!
Captions: 
	00:00:04,160 --> 00:00:10,410
the talk is going to be all that's one

00:00:08,340 --> 00:00:12,480
of the one of those vague topics that I

00:00:10,410 --> 00:00:14,430
I give some generalized advice or at

00:00:12,480 --> 00:00:17,250
least my own my own opinions on what

00:00:14,430 --> 00:00:21,060
some generalized notion of elegancies

00:00:17,250 --> 00:00:22,740
and you all you all have your own

00:00:21,060 --> 00:00:27,110
opinions and probably disagree with me

00:00:22,740 --> 00:00:30,630
I'm going to start with a definition of

00:00:27,110 --> 00:00:32,550
this elegance concept which which I'm

00:00:30,630 --> 00:00:34,559
then going to try and apply to Scala

00:00:32,550 --> 00:00:37,050
code and come up with idea as to what

00:00:34,559 --> 00:00:40,859
that means so elegance is combining

00:00:37,050 --> 00:00:45,449
simplicity power and a certain ineffable

00:00:40,859 --> 00:00:47,129
grace of design so what is this what

00:00:45,449 --> 00:00:52,129
does this mean in the context of Scala

00:00:47,129 --> 00:00:55,409
code well I think elegant code is

00:00:52,129 --> 00:00:58,799
intuitive necessarily it must be it must

00:00:55,409 --> 00:01:01,079
be readable but also inner in a language

00:00:58,799 --> 00:01:03,239
like Scala type safety is absolutely

00:01:01,079 --> 00:01:04,920
critical and it's the intersection

00:01:03,239 --> 00:01:07,350
between these two things but between

00:01:04,920 --> 00:01:09,270
beautiful beautiful syntax that is that

00:01:07,350 --> 00:01:15,990
is very readable very intuitive very

00:01:09,270 --> 00:01:20,159
understandable and type safety now why

00:01:15,990 --> 00:01:25,109
why is Scala wise wise the context of

00:01:20,159 --> 00:01:26,490
Scala interesting well I think we can

00:01:25,109 --> 00:01:29,509
all agree that Scala is probably more

00:01:26,490 --> 00:01:34,859
complex than most programming languages

00:01:29,509 --> 00:01:36,929
it has a big design space and at the

00:01:34,859 --> 00:01:39,750
same time it's useful by users of

00:01:36,929 --> 00:01:43,200
different abilities it transcends these

00:01:39,750 --> 00:01:44,880
these different ability groups and you

00:01:43,200 --> 00:01:46,560
can use you can use Scarlett coming

00:01:44,880 --> 00:01:48,149
straight from Java you can program

00:01:46,560 --> 00:01:54,479
scholar for ten years and still be

00:01:48,149 --> 00:01:56,490
learning new stuff and I think I think

00:01:54,479 --> 00:01:59,789
very few languages have the same kind of

00:01:56,490 --> 00:02:03,810
depth as a scholar does and consequently

00:01:59,789 --> 00:02:05,240
with with its reason we vast array of

00:02:03,810 --> 00:02:10,670
features

00:02:05,240 --> 00:02:13,620
it encourages inventiveness in syntax

00:02:10,670 --> 00:02:16,200
who here has written some code at some

00:02:13,620 --> 00:02:19,620
point in Scala and wondered to

00:02:16,200 --> 00:02:22,080
themselves is this standard is this is

00:02:19,620 --> 00:02:24,480
this normal Scala code I'm writing or am

00:02:22,080 --> 00:02:29,550
I just inventing something new and hands

00:02:24,480 --> 00:02:31,020
up let you've almost all done it and the

00:02:29,550 --> 00:02:33,080
language encourages it there's there's

00:02:31,020 --> 00:02:37,200
such a such a vast area features that

00:02:33,080 --> 00:02:38,640
are mostly orthogonal but any any

00:02:37,200 --> 00:02:42,030
combination of those seems like it's

00:02:38,640 --> 00:02:44,670
inventing something new and of course a

00:02:42,030 --> 00:02:49,680
language this size needs unique feature

00:02:44,670 --> 00:02:52,740
unique solutions so I'm going to talk

00:02:49,680 --> 00:02:57,480
through what I've called principles of

00:02:52,740 --> 00:03:00,690
elegance these are eight very rough

00:02:57,480 --> 00:03:03,150
guidelines for how you might decide to

00:03:00,690 --> 00:03:05,150
design a library in Scala so you are the

00:03:03,150 --> 00:03:12,030
library designer you are writing code

00:03:05,150 --> 00:03:13,980
for other users to tip to use now most

00:03:12,030 --> 00:03:16,530
of the ideas here a specific to scarlet

00:03:13,980 --> 00:03:19,410
not all of them it's also worth pointing

00:03:16,530 --> 00:03:21,090
out that I've come up with eight I think

00:03:19,410 --> 00:03:23,970
if I'd had a longer flight here that

00:03:21,090 --> 00:03:25,500
might have been ten if I'd been given if

00:03:23,970 --> 00:03:26,750
I'd been given an hour instead of 45

00:03:25,500 --> 00:03:29,160
minutes we might have a different number

00:03:26,750 --> 00:03:32,100
it's a work in progress don't take them

00:03:29,160 --> 00:03:33,239
too seriously by all means disagree by

00:03:32,100 --> 00:03:35,700
all means tell me afterwards that you

00:03:33,239 --> 00:03:40,520
disagree and maybe they can evolve into

00:03:35,700 --> 00:03:44,130
something more more generally useful and

00:03:40,520 --> 00:03:45,510
it's also worth noting that although i

00:03:44,130 --> 00:03:46,890
want to write code that is elegance

00:03:45,510 --> 00:03:48,420
because i think the the properties of

00:03:46,890 --> 00:03:50,880
elegance as I've described it at the

00:03:48,420 --> 00:03:53,070
beginning are very good that might not

00:03:50,880 --> 00:03:54,030
be your primary goal so there are other

00:03:53,070 --> 00:03:55,860
things you what you may want to do

00:03:54,030 --> 00:03:57,780
performance might be a much more

00:03:55,860 --> 00:04:00,540
important consideration than having

00:03:57,780 --> 00:04:02,840
carry that is that is elegant and that's

00:04:00,540 --> 00:04:02,840
fine

00:04:03,370 --> 00:04:11,060
I've missed a slide there so number one

00:04:06,800 --> 00:04:14,480
of the eight keep your public API is

00:04:11,060 --> 00:04:18,590
minimal keep them small why do we want

00:04:14,480 --> 00:04:21,410
to do this well a small API is easy to

00:04:18,590 --> 00:04:24,380
learn it's simple there is less

00:04:21,410 --> 00:04:25,760
distraction it's easy to maintain that

00:04:24,380 --> 00:04:28,460
code so from your point of view as the

00:04:25,760 --> 00:04:32,800
maintainer of this library think things

00:04:28,460 --> 00:04:35,690
easier for for you as well as your users

00:04:32,800 --> 00:04:37,520
and all this more importantly than all

00:04:35,690 --> 00:04:41,660
of these it's it's easier to compose

00:04:37,520 --> 00:04:44,810
small api's if your type only has one

00:04:41,660 --> 00:04:47,200
method that's that's less work to do

00:04:44,810 --> 00:04:50,660
when when providing an implementation

00:04:47,200 --> 00:04:52,970
it's easier to combine these things if

00:04:50,660 --> 00:04:57,590
there are fewer fewer methods fewer

00:04:52,970 --> 00:05:00,830
interactions to deal with you should

00:04:57,590 --> 00:05:03,280
avoid polluting your public API use this

00:05:00,830 --> 00:05:07,490
polluting word quite liberally with

00:05:03,280 --> 00:05:10,400
types with members with classes and so

00:05:07,490 --> 00:05:15,890
on that exists only really for your own

00:05:10,400 --> 00:05:18,169
internal usage you can expect users to

00:05:15,890 --> 00:05:20,210
import things using the underscore

00:05:18,169 --> 00:05:22,820
because it's the simplest way of getting

00:05:20,210 --> 00:05:24,890
access to to all the all types and

00:05:22,820 --> 00:05:27,229
members in a package so you should

00:05:24,890 --> 00:05:31,130
expect people to do that but whenever

00:05:27,229 --> 00:05:33,530
they do they pull in an entire entire

00:05:31,130 --> 00:05:35,300
namespace into their own or an entire

00:05:33,530 --> 00:05:38,300
set of types and terms into their own

00:05:35,300 --> 00:05:41,360
namespace which should not be given away

00:05:38,300 --> 00:05:42,770
lightly if you have a big API you're

00:05:41,360 --> 00:05:47,120
pulling in lots of names that you can't

00:05:42,770 --> 00:05:50,539
easily use in your in your code you

00:05:47,120 --> 00:05:53,840
can't easily use other people's

00:05:50,539 --> 00:05:57,830
libraries if there's a risk that any two

00:05:53,840 --> 00:06:01,250
of these names complete so this is this

00:05:57,830 --> 00:06:03,140
is a tricky strong motivation for for

00:06:01,250 --> 00:06:05,430
not just not having so much stuff in

00:06:03,140 --> 00:06:07,680
your in your packages

00:06:05,430 --> 00:06:09,750
in general if you can if you can

00:06:07,680 --> 00:06:13,860
refactor your code to have fewer more

00:06:09,750 --> 00:06:15,900
general methods don't don't have don't

00:06:13,860 --> 00:06:17,940
have many different specific methods

00:06:15,900 --> 00:06:23,220
just for convenience encourage your

00:06:17,940 --> 00:06:26,340
users to to use generic methods add type

00:06:23,220 --> 00:06:27,990
parameters don't don't provide a string

00:06:26,340 --> 00:06:32,480
version and inversion a double version

00:06:27,990 --> 00:06:32,480
of the same thing user user parameter

00:06:33,500 --> 00:06:38,630
how can we do this we can use public and

00:06:36,600 --> 00:06:41,270
private sorry private and protected

00:06:38,630 --> 00:06:46,440
you're probably all familiar with that

00:06:41,270 --> 00:06:49,620
that works fine most of the time but but

00:06:46,440 --> 00:06:52,680
if you if you for example miss this the

00:06:49,620 --> 00:06:54,120
point later on we can use week whose

00:06:52,680 --> 00:06:57,660
type classes instead of overloading

00:06:54,120 --> 00:07:00,630
that's that's a solution using I think

00:06:57,660 --> 00:07:03,600
if you read the article on the magnet

00:07:00,630 --> 00:07:05,820
patent that will give you a good idea of

00:07:03,600 --> 00:07:08,910
how how to do that point I was about to

00:07:05,820 --> 00:07:11,460
make is sometimes you can't mark things

00:07:08,910 --> 00:07:12,990
as private or protected because you you

00:07:11,460 --> 00:07:15,630
need them accessible in your your own

00:07:12,990 --> 00:07:18,990
other packages you can't have them than

00:07:15,630 --> 00:07:21,150
private so what you can do is you can

00:07:18,990 --> 00:07:22,890
you can hide them put them put them

00:07:21,150 --> 00:07:26,430
inside objects put them inside companion

00:07:22,890 --> 00:07:29,550
objects structure your code and add more

00:07:26,430 --> 00:07:31,140
structure to it too to effectively hide

00:07:29,550 --> 00:07:34,950
things from the main namespace that

00:07:31,140 --> 00:07:37,470
people will be importing here's an

00:07:34,950 --> 00:07:40,050
example of how that might work so

00:07:37,470 --> 00:07:41,550
instead of doing the top the the top

00:07:40,050 --> 00:07:43,410
version up here where you you have a

00:07:41,550 --> 00:07:44,790
food then you've got two different

00:07:43,410 --> 00:07:48,200
versions of that all in the main

00:07:44,790 --> 00:07:51,780
namespace basic foo and advanced food

00:07:48,200 --> 00:07:54,660
take those two classes and put them

00:07:51,780 --> 00:07:56,880
inside the food companion objects I mean

00:07:54,660 --> 00:07:59,700
this this is really simple point but

00:07:56,880 --> 00:08:01,970
we're adding structure to avoid

00:07:59,700 --> 00:08:05,330
introducing lots more lots more names

00:08:01,970 --> 00:08:05,330
into our API

00:08:07,240 --> 00:08:13,949
so that that's the first of the eight

00:08:09,780 --> 00:08:13,949
principles keeping you API small

00:08:15,210 --> 00:08:19,889
naming things one of the one of the two

00:08:18,330 --> 00:08:23,130
most difficult problems in computer

00:08:19,889 --> 00:08:24,210
science this this point I'm not going to

00:08:23,130 --> 00:08:27,740
spend long on this because I think you

00:08:24,210 --> 00:08:27,740
all know that naming stuff is important

00:08:27,770 --> 00:08:34,289
we need to give things names we have we

00:08:31,710 --> 00:08:36,089
have a type system that is is designed

00:08:34,289 --> 00:08:39,990
around the names of the names of things

00:08:36,089 --> 00:08:43,560
rather than their structure so classes

00:08:39,990 --> 00:08:47,130
types traits packages values definitions

00:08:43,560 --> 00:08:49,290
they all need to have names and they fit

00:08:47,130 --> 00:08:53,100
into the term namespace or the type

00:08:49,290 --> 00:08:55,320
namespace but the names we choose should

00:08:53,100 --> 00:08:56,730
communicate something they should

00:08:55,320 --> 00:09:00,899
communicate they should give information

00:08:56,730 --> 00:09:04,529
to the to the programmer about what that

00:09:00,899 --> 00:09:06,180
thing does what it represents and this I

00:09:04,529 --> 00:09:08,339
think is why it's so difficult to name

00:09:06,180 --> 00:09:11,330
things because different users have

00:09:08,339 --> 00:09:14,100
different perceptions of what a name is

00:09:11,330 --> 00:09:15,870
preconceptions in fact some these are

00:09:14,100 --> 00:09:17,459
good I mean if we can if we can give

00:09:15,870 --> 00:09:20,690
something a name and someone already has

00:09:17,459 --> 00:09:26,670
a fair idea as to what that is then

00:09:20,690 --> 00:09:29,640
that's that's great if they have a name

00:09:26,670 --> 00:09:31,950
which either gives no information or I

00:09:29,640 --> 00:09:34,860
think worse than that gives some

00:09:31,950 --> 00:09:39,770
indication that it's something subtly

00:09:34,860 --> 00:09:43,079
different that can be problematic and

00:09:39,770 --> 00:09:44,760
the the English language is is very rich

00:09:43,079 --> 00:09:48,440
with with synonyms for different things

00:09:44,760 --> 00:09:52,500
and they all have subtle nuances that

00:09:48,440 --> 00:09:53,880
may may hint to two programmers that it

00:09:52,500 --> 00:09:57,690
means one thing or the other and there's

00:09:53,880 --> 00:10:00,360
also the context of programming we have

00:09:57,690 --> 00:10:02,910
our own esoteric meanings that we we've

00:10:00,360 --> 00:10:06,779
ascribed to certain words and these will

00:10:02,910 --> 00:10:09,360
have to be taken into account so does

00:10:06,779 --> 00:10:11,100
does the method you're trying to name or

00:10:09,360 --> 00:10:13,670
an influencer familiar concepts that's a

00:10:11,100 --> 00:10:13,670
question to ask

00:10:16,070 --> 00:10:24,860
how long should the name be now I think

00:10:20,990 --> 00:10:27,560
I think how Ely in an article or naming

00:10:24,860 --> 00:10:32,030
which i'm about to mend mention in the

00:10:27,560 --> 00:10:36,410
next point he talked about names roughly

00:10:32,030 --> 00:10:38,750
being Huffman encodings for information

00:10:36,410 --> 00:10:40,340
in that if you're using a if you're

00:10:38,750 --> 00:10:43,640
using a name when identify more

00:10:40,340 --> 00:10:46,090
frequently then it would be shorter now

00:10:43,640 --> 00:10:50,830
this is this is this is a very rough

00:10:46,090 --> 00:10:53,450
suggestion but it kind of works but

00:10:50,830 --> 00:10:57,380
sometimes short names have more

00:10:53,450 --> 00:10:59,390
opportunity to to be to be misleading a

00:10:57,380 --> 00:11:03,260
long descriptive name is generally

00:10:59,390 --> 00:11:07,430
better so this this is these are all

00:11:03,260 --> 00:11:10,730
very very very very very rough points

00:11:07,430 --> 00:11:12,110
which the may the may arise different

00:11:10,730 --> 00:11:18,440
reasons why you'd want to ignore them

00:11:12,110 --> 00:11:20,290
but in general in in general v's that

00:11:18,440 --> 00:11:24,560
these I think are reasonable good luck

00:11:20,290 --> 00:11:28,850
guidelines 11 specific issue with Scala

00:11:24,560 --> 00:11:31,850
is that implicit have names even if you

00:11:28,850 --> 00:11:35,150
even if you import them in scope with an

00:11:31,850 --> 00:11:36,560
underscore and you never really see

00:11:35,150 --> 00:11:38,240
those names you never have to write the

00:11:36,560 --> 00:11:40,610
names the names are significant because

00:11:38,240 --> 00:11:44,270
if you have to implicit with the same

00:11:40,610 --> 00:11:47,510
name does anyone know what happens you

00:11:44,270 --> 00:11:50,780
important both in scope whichever one

00:11:47,510 --> 00:11:54,260
you import last will shadow the one you

00:11:50,780 --> 00:11:55,490
import first this is this might be

00:11:54,260 --> 00:11:58,700
deliberate I do it deliberately

00:11:55,490 --> 00:12:01,010
sometimes but frequently if they have a

00:11:58,700 --> 00:12:04,510
short name I think Martin showed her an

00:12:01,010 --> 00:12:08,840
example of an implicit called I i2s

00:12:04,510 --> 00:12:10,390
yesterday if you had to call I to s the

00:12:08,840 --> 00:12:13,610
second one new import would override

00:12:10,390 --> 00:12:15,650
shadow the first one so this is

00:12:13,610 --> 00:12:18,460
accidental shadowing and we want to want

00:12:15,650 --> 00:12:21,260
to avoid surprise as much as possible

00:12:18,460 --> 00:12:24,410
so how use post was called conciseness

00:12:21,260 --> 00:12:26,480
and names it's well worth reading it's

00:12:24,410 --> 00:12:29,600
quite long but that covers many of the

00:12:26,480 --> 00:12:33,230
ideas that could actually fill out fill

00:12:29,600 --> 00:12:35,240
an entire talk so that's that's a lot

00:12:33,230 --> 00:12:39,380
naming I'm basically saying with regard

00:12:35,240 --> 00:12:44,150
to naming go and go and read read read

00:12:39,380 --> 00:12:46,430
the blog number three you should embrace

00:12:44,150 --> 00:12:51,580
the type system type system is your

00:12:46,430 --> 00:12:55,130
friend it empowers us with constraints

00:12:51,580 --> 00:12:58,070
Runa I gave a talk at scala world last

00:12:55,130 --> 00:13:01,640
year about being liberated by

00:12:58,070 --> 00:13:03,290
constraints and this is kind of this is

00:13:01,640 --> 00:13:05,630
kind of what it feels like to have these

00:13:03,290 --> 00:13:07,790
these these type systems maybe these

00:13:05,630 --> 00:13:10,580
these types available to us to tell us

00:13:07,790 --> 00:13:12,440
actually you can't do that you can't do

00:13:10,580 --> 00:13:15,770
something which is guaranteed to fail at

00:13:12,440 --> 00:13:19,940
runtime you're stopping us from from

00:13:15,770 --> 00:13:22,070
from from from getting burned and it

00:13:19,940 --> 00:13:23,510
gives us a lot of confidence to to

00:13:22,070 --> 00:13:25,940
reason about our code when we have this

00:13:23,510 --> 00:13:30,380
types its type system as a safety net it

00:13:25,940 --> 00:13:33,700
stops us from doing things which can

00:13:30,380 --> 00:13:35,750
only possibly end in tears and

00:13:33,700 --> 00:13:40,250
consequently it should give us

00:13:35,750 --> 00:13:41,720
confidence to refactor our code years

00:13:40,250 --> 00:13:44,360
ago when I was trying to convince people

00:13:41,720 --> 00:13:45,740
who are familiar only with Java that the

00:13:44,360 --> 00:13:49,960
skull was a good thing I used to talk

00:13:45,740 --> 00:13:52,340
about how i would spend a couple of days

00:13:49,960 --> 00:13:54,260
refactoring code without a single

00:13:52,340 --> 00:13:55,760
successful compilation I would change

00:13:54,260 --> 00:13:59,030
thousand lines of code I would move

00:13:55,760 --> 00:14:00,980
methods around I would make all kinds of

00:13:59,030 --> 00:14:04,000
changes and I would make those changes

00:14:00,980 --> 00:14:05,870
without ever really planning them i

00:14:04,000 --> 00:14:09,110
would i would make the changes than the

00:14:05,870 --> 00:14:10,580
compiler would tell me what i need to

00:14:09,110 --> 00:14:12,230
fix it would tell me a little give me a

00:14:10,580 --> 00:14:14,990
list of errors with line numbers I'm go

00:14:12,230 --> 00:14:16,430
to each line number and fix whatever the

00:14:14,990 --> 00:14:18,410
problem was there and it would maybe

00:14:16,430 --> 00:14:20,390
take me a couple of days to to fix that

00:14:18,410 --> 00:14:22,810
and at the end I would hopefully get

00:14:20,390 --> 00:14:25,270
something that that compiled

00:14:22,810 --> 00:14:29,260
but once it did I could be reasonably

00:14:25,270 --> 00:14:30,820
confident that it would work now these

00:14:29,260 --> 00:14:31,720
Java uses that I would I would try and

00:14:30,820 --> 00:14:33,700
convince they just wouldn't believe me

00:14:31,720 --> 00:14:35,020
that this would happen though that you

00:14:33,700 --> 00:14:36,130
would spend two days working on

00:14:35,020 --> 00:14:38,230
something without a successful

00:14:36,130 --> 00:14:40,720
compilation and then at the end of it it

00:14:38,230 --> 00:14:42,730
would just work first time but on many

00:14:40,720 --> 00:14:44,320
occasions i would i would experience

00:14:42,730 --> 00:14:47,010
this and this this is this is what got

00:14:44,320 --> 00:14:47,010
me hooked on scala

00:14:50,339 --> 00:14:56,550
so some some guidelines on on how we can

00:14:53,850 --> 00:15:00,420
have been do this how we can take

00:14:56,550 --> 00:15:01,709
advantage of the type system you should

00:15:00,420 --> 00:15:04,050
avoid primitive types as much as

00:15:01,709 --> 00:15:05,879
possible you have something which is an

00:15:04,050 --> 00:15:08,100
int well is it is it an int is it the

00:15:05,879 --> 00:15:12,509
same kind of int as another method which

00:15:08,100 --> 00:15:14,459
users mins maybe maybe not can we

00:15:12,509 --> 00:15:16,980
actually say this is some sort of

00:15:14,459 --> 00:15:18,720
measurement is it is it a length should

00:15:16,980 --> 00:15:21,389
we be comparing a length length with a

00:15:18,720 --> 00:15:24,600
with a depth can we can we actually use

00:15:21,389 --> 00:15:28,430
those types instead of the more generic

00:15:24,600 --> 00:15:28,430
int type or string

00:15:31,500 --> 00:15:39,740
I'd also recommend avoiding pure

00:15:35,370 --> 00:15:44,340
structural types so option has its uses

00:15:39,740 --> 00:15:47,400
as does either but I mean in the case of

00:15:44,340 --> 00:15:49,560
either I guess you're all familiar with

00:15:47,400 --> 00:15:51,150
either it has a left branch and a right

00:15:49,560 --> 00:15:53,550
branch these are the two possibilities

00:15:51,150 --> 00:15:55,800
for and either but what does left mean

00:15:53,550 --> 00:15:58,440
and what does right mean why using left

00:15:55,800 --> 00:16:00,030
and right why not use red and green if

00:15:58,440 --> 00:16:03,540
you're describing something that is red

00:16:00,030 --> 00:16:06,090
and green create a new type have a

00:16:03,540 --> 00:16:11,850
really low bar for introducing new types

00:16:06,090 --> 00:16:13,440
of things now that the performance the

00:16:11,850 --> 00:16:18,150
punk performs implications with that as

00:16:13,440 --> 00:16:19,950
well potentially but and the size of the

00:16:18,150 --> 00:16:25,500
bike code is generated will be will be

00:16:19,950 --> 00:16:27,060
will be greater but my my subject

00:16:25,500 --> 00:16:30,060
matters a is elegance in code and

00:16:27,060 --> 00:16:36,120
performance is not such a consideration

00:16:30,060 --> 00:16:38,390
here so I'm putting that to one side the

00:16:36,120 --> 00:16:41,070
most important thing you can do with

00:16:38,390 --> 00:16:43,310
when designing a type isn't sure that it

00:16:41,070 --> 00:16:48,270
does not make it possible to represent

00:16:43,310 --> 00:16:49,890
states you consider illegal strings are

00:16:48,270 --> 00:16:51,990
really bad at this because using a

00:16:49,890 --> 00:16:53,580
string to represent something that the

00:16:51,990 --> 00:16:56,930
string can be any length they can have

00:16:53,580 --> 00:17:03,930
any content all we know is that it's

00:16:56,930 --> 00:17:07,189
it's a series of characters and then

00:17:03,930 --> 00:17:07,189
many things this isn't useful

00:17:08,530 --> 00:17:13,600
on the performance issue we do have one

00:17:10,950 --> 00:17:15,930
there's one option to use value glasses

00:17:13,600 --> 00:17:18,490
who here is familiar with value classes

00:17:15,930 --> 00:17:19,810
so i'd say about half maybe a bit fewer

00:17:18,490 --> 00:17:23,350
than half people have put their hand up

00:17:19,810 --> 00:17:26,650
their value classes give us the

00:17:23,350 --> 00:17:29,950
performance of primitives but the safety

00:17:26,650 --> 00:17:32,080
of types it's basically like a

00:17:29,950 --> 00:17:34,260
lightweight wrapper around a primitive

00:17:32,080 --> 00:17:37,390
type so these these are one way of

00:17:34,260 --> 00:17:41,440
getting the benefits of type safety

00:17:37,390 --> 00:17:44,500
without the performance cost and we can

00:17:41,440 --> 00:17:48,610
also use macros I don't normally resort

00:17:44,500 --> 00:17:52,750
to macros for for for many many things I

00:17:48,610 --> 00:17:54,040
want to do in scarlet because it's it

00:17:52,750 --> 00:17:56,500
can it can erode some of the confidence

00:17:54,040 --> 00:18:00,160
we have from the type system so macros

00:17:56,500 --> 00:18:02,500
are to be used with caution but i'm

00:18:00,160 --> 00:18:06,490
going to show an example here of where i

00:18:02,500 --> 00:18:07,810
use a macro in in rapture so rat rapture

00:18:06,490 --> 00:18:09,520
is a collection of libraries i've

00:18:07,810 --> 00:18:11,920
written that I'm going to use several

00:18:09,520 --> 00:18:13,120
examples from Raptor today to to

00:18:11,920 --> 00:18:18,550
demonstrate a few of these these

00:18:13,120 --> 00:18:22,720
principles of elegance can you see the

00:18:18,550 --> 00:18:26,500
pointer there this is a CSS value that

00:18:22,720 --> 00:18:30,580
you can represent in in rapture assessed

00:18:26,500 --> 00:18:32,050
value is basically a series of CSS

00:18:30,580 --> 00:18:35,080
properties that you could use in in a

00:18:32,050 --> 00:18:37,480
web page for example now what happens

00:18:35,080 --> 00:18:39,160
here is I'm using a string context

00:18:37,480 --> 00:18:40,090
you've probably seen string context

00:18:39,160 --> 00:18:41,740
where you start a string with a

00:18:40,090 --> 00:18:45,070
lowercase s and you can substitute

00:18:41,740 --> 00:18:46,690
variables into it this is actually part

00:18:45,070 --> 00:18:48,220
of a more general concept in Scala you

00:18:46,690 --> 00:18:50,560
can actually prefix you can even define

00:18:48,220 --> 00:18:54,600
methods whereby you prefix a string with

00:18:50,560 --> 00:18:58,960
any identifier so I'm using CSS here and

00:18:54,600 --> 00:19:03,250
that will that will translate in the

00:18:58,960 --> 00:19:06,910
compiler to a method call and I'm using

00:19:03,250 --> 00:19:09,670
a macro to look at the string that is

00:19:06,910 --> 00:19:12,250
passed that method and the macro is

00:19:09,670 --> 00:19:14,800
looking into the structure of the string

00:19:12,250 --> 00:19:16,840
is parsing it in fact and it's checking

00:19:14,800 --> 00:19:18,740
that i'm using a property here that

00:19:16,840 --> 00:19:21,500
actually is part of the CSS spec

00:19:18,740 --> 00:19:22,850
it's checking that the format is right

00:19:21,500 --> 00:19:27,050
there's a coal on there that these are

00:19:22,850 --> 00:19:29,540
separated by a semicolon it's basically

00:19:27,050 --> 00:19:33,230
checking that the content in here is

00:19:29,540 --> 00:19:36,890
genuine CSS and this is something you

00:19:33,230 --> 00:19:39,440
can do quite easily with with string

00:19:36,890 --> 00:19:42,860
context and macros and consequently it

00:19:39,440 --> 00:19:45,580
makes it impossible to create a type an

00:19:42,860 --> 00:19:49,610
instance of a type CSS in this example

00:19:45,580 --> 00:19:51,170
which is not valid it's it we know that

00:19:49,610 --> 00:19:55,780
if we've successfully managed to create

00:19:51,170 --> 00:19:55,780
this that it is it is valid

00:19:58,470 --> 00:20:01,220
ok

00:20:02,390 --> 00:20:09,320
so we're also designed for user

00:20:04,790 --> 00:20:11,420
experience and I don't know how many

00:20:09,320 --> 00:20:15,100
people here are familiar with UX design

00:20:11,420 --> 00:20:18,700
but many of the same principles apply to

00:20:15,100 --> 00:20:22,550
to code an API design as apply to as

00:20:18,700 --> 00:20:28,040
apply to designing user interfaces and

00:20:22,550 --> 00:20:29,120
user experiences the users are the

00:20:28,040 --> 00:20:31,400
programmers who will consume your

00:20:29,120 --> 00:20:32,720
library now we know for start they're

00:20:31,400 --> 00:20:37,400
all programmers so we can we can make

00:20:32,720 --> 00:20:39,140
certain assumptions about them but they

00:20:37,400 --> 00:20:44,060
also have different abilities different

00:20:39,140 --> 00:20:47,300
capabilities different expectations very

00:20:44,060 --> 00:20:49,420
advanced users of Scala who've been

00:20:47,300 --> 00:20:51,890
using the language for maybe five years

00:20:49,420 --> 00:20:54,380
will approach code very differently from

00:20:51,890 --> 00:20:56,930
oral approach a new API may be very

00:20:54,380 --> 00:21:02,060
differently from beginners who have come

00:20:56,930 --> 00:21:03,410
more recently from Java for example and

00:21:02,060 --> 00:21:07,270
those expectations we should take

00:21:03,410 --> 00:21:09,410
advantage of them where where possible

00:21:07,270 --> 00:21:13,910
but at the same time it's not pertaining

00:21:09,410 --> 00:21:16,040
to you to educate educate users you

00:21:13,910 --> 00:21:19,610
shouldn't really compromise on your

00:21:16,040 --> 00:21:22,790
design just because users have a certain

00:21:19,610 --> 00:21:25,070
expectation about what about the way it

00:21:22,790 --> 00:21:28,160
will be implemented I think a lot of a

00:21:25,070 --> 00:21:29,420
lot of libraries can be let down by sort

00:21:28,160 --> 00:21:31,570
of admitting to themselves that people

00:21:29,420 --> 00:21:36,620
are doing it wrong and accommodating

00:21:31,570 --> 00:21:38,450
accommodating that in the future if

00:21:36,620 --> 00:21:41,390
people doing things wrong if people are

00:21:38,450 --> 00:21:43,190
making false assumptions try and fix it

00:21:41,390 --> 00:21:46,330
try and educate users that there are

00:21:43,190 --> 00:21:46,330
better ways of doing it

00:21:46,930 --> 00:21:54,970
there's an aesthetic point here boiler

00:21:50,530 --> 00:21:56,470
boiler plate it's a necessary part of

00:21:54,970 --> 00:21:57,790
some library some libraries require to

00:21:56,470 --> 00:22:01,960
write what what can be considered

00:21:57,790 --> 00:22:03,490
boilerplate repetitive code and there

00:22:01,960 --> 00:22:06,010
are ways of designing libraries to avoid

00:22:03,490 --> 00:22:09,880
that as much as possible sensible

00:22:06,010 --> 00:22:13,840
defaults combining sets of properties

00:22:09,880 --> 00:22:15,160
into a single in a single namespace a

00:22:13,840 --> 00:22:18,850
single object for example which we

00:22:15,160 --> 00:22:20,620
import from these are all ways we can we

00:22:18,850 --> 00:22:23,440
can try to make the experience better

00:22:20,620 --> 00:22:27,970
for users by removing boilerplate and

00:22:23,440 --> 00:22:30,400
consequently every line in our code

00:22:27,970 --> 00:22:33,640
should be should be meaningful we should

00:22:30,400 --> 00:22:36,370
be able to read it line by line and say

00:22:33,640 --> 00:22:39,480
this is actually I I can see what's

00:22:36,370 --> 00:22:43,750
happening in each of these lines and and

00:22:39,480 --> 00:22:45,940
ascribe some meaning to it and as a

00:22:43,750 --> 00:22:48,400
whole your code should be readable by

00:22:45,940 --> 00:22:50,620
someone who is unfamiliar with the

00:22:48,400 --> 00:22:52,750
library with the libraries you're using

00:22:50,620 --> 00:22:53,560
or your you're developing and they

00:22:52,750 --> 00:22:57,670
should be able to have some

00:22:53,560 --> 00:22:59,170
understanding of what it does based on

00:22:57,670 --> 00:23:02,320
the names you've chosen to things based

00:22:59,170 --> 00:23:05,050
on the the structure of the the dsl's

00:23:02,320 --> 00:23:07,030
you perhaps written you should be able

00:23:05,050 --> 00:23:08,920
to read it line by line and and have a

00:23:07,030 --> 00:23:12,880
have a reasonable understanding that's

00:23:08,920 --> 00:23:14,680
that's the goal so I want to list some

00:23:12,880 --> 00:23:17,610
usability heuristics here drawing

00:23:14,680 --> 00:23:19,840
parallels with the with the real world

00:23:17,610 --> 00:23:23,350
consistency in standards error

00:23:19,840 --> 00:23:27,370
prevention recognition not recall so

00:23:23,350 --> 00:23:29,620
maybe that's not remembering for example

00:23:27,370 --> 00:23:31,480
that a method is called flat map but

00:23:29,620 --> 00:23:33,610
instead identifying the parameter type

00:23:31,480 --> 00:23:35,680
in the return type and being able to

00:23:33,610 --> 00:23:37,030
recognize therefore what it does maybe

00:23:35,680 --> 00:23:39,070
flat maps a bad example because everyone

00:23:37,030 --> 00:23:40,450
knows it well but other other similar

00:23:39,070 --> 00:23:43,860
methods which we can identify by their

00:23:40,450 --> 00:23:47,310
shape rather than their their name

00:23:43,860 --> 00:23:51,330
flexibility and efficiency of use

00:23:47,310 --> 00:23:51,330
aesthetic and minimalist design

00:23:51,640 --> 00:23:58,390
now these you can probably read this

00:23:55,000 --> 00:24:00,550
list and think these all apply these are

00:23:58,390 --> 00:24:04,050
all sensible suggestions relating to API

00:24:00,550 --> 00:24:06,520
design I actually lifted them from a

00:24:04,050 --> 00:24:08,260
blog post on 10 usability heuristics for

00:24:06,520 --> 00:24:10,810
user interface design completely

00:24:08,260 --> 00:24:13,600
unrelated to programming so the same

00:24:10,810 --> 00:24:18,340
concept to apply across these these

00:24:13,600 --> 00:24:20,410
disciplines i also want to talk about

00:24:18,340 --> 00:24:24,670
you site first design this is something

00:24:20,410 --> 00:24:27,010
I often do I want to optimize my my

00:24:24,670 --> 00:24:29,790
library for the use side I write the

00:24:27,010 --> 00:24:32,710
horrible code so you don't have to i

00:24:29,790 --> 00:24:35,560
want i want the use i want the code that

00:24:32,710 --> 00:24:37,750
the my users right who are using my

00:24:35,560 --> 00:24:39,130
library i want that to be elegant that

00:24:37,750 --> 00:24:43,150
one that to have the the beautiful

00:24:39,130 --> 00:24:47,560
aesthetic syntax so that's what I

00:24:43,150 --> 00:24:48,850
optimized for and maybe I can I can I

00:24:47,560 --> 00:24:51,690
can do this best buy first of all

00:24:48,850 --> 00:24:54,100
writing the code I want to write it

00:24:51,690 --> 00:24:57,760
won't compile because it's not defined

00:24:54,100 --> 00:25:00,220
yet but but just write down in code what

00:24:57,760 --> 00:25:03,760
I would like to see in in my in my user

00:25:00,220 --> 00:25:05,520
code it's also worth while writing down

00:25:03,760 --> 00:25:08,590
some things which shouldn't compile

00:25:05,520 --> 00:25:11,610
writing down things which you expect to

00:25:08,590 --> 00:25:11,610
result in type errors

00:25:12,659 --> 00:25:17,039
and then given those definitions you can

00:25:14,639 --> 00:25:18,840
write in this tests if you like you can

00:25:17,039 --> 00:25:22,349
then try and write the code that makes

00:25:18,840 --> 00:25:24,929
them compile and there's the several

00:25:22,349 --> 00:25:28,739
iterations here you need you need to

00:25:24,929 --> 00:25:31,470
maybe review your your perceptions of

00:25:28,739 --> 00:25:34,649
what's possible in Scala and skyla has a

00:25:31,470 --> 00:25:38,609
lot of scope for dsl's and different

00:25:34,649 --> 00:25:39,809
ways of writing them and it's it's

00:25:38,609 --> 00:25:41,190
difficult to get the right first time

00:25:39,809 --> 00:25:42,899
it's difficult to know exactly what's

00:25:41,190 --> 00:25:44,940
possible and what's not but after

00:25:42,899 --> 00:25:47,759
several iterations maybe you get to the

00:25:44,940 --> 00:25:53,789
point where you've got your samples to

00:25:47,759 --> 00:25:57,779
compile maybe you happened and maybe

00:25:53,789 --> 00:26:01,559
needs to compromise but Scarlett with

00:25:57,779 --> 00:26:04,649
all its depth of features I propose that

00:26:01,559 --> 00:26:06,119
you only compromised when you've

00:26:04,649 --> 00:26:08,940
exhausted all the possibilities in the

00:26:06,119 --> 00:26:10,320
language if your if your sample code

00:26:08,940 --> 00:26:12,809
that your writing is genuinely what you

00:26:10,320 --> 00:26:15,419
want to be able to write and you're

00:26:12,809 --> 00:26:17,970
confident to that then go through all

00:26:15,419 --> 00:26:20,399
the scholars various features try them

00:26:17,970 --> 00:26:24,149
out try different types try implicit try

00:26:20,399 --> 00:26:26,309
higher kind of types and then give up

00:26:24,149 --> 00:26:29,989
and then start compromising on on your

00:26:26,309 --> 00:26:29,989
on your sample code

00:26:31,490 --> 00:26:41,030
I saw said try macros that opens up a

00:26:35,660 --> 00:26:42,380
whole wealth of other possibilities this

00:26:41,030 --> 00:26:44,660
I was with disappoints actually Martin

00:26:42,380 --> 00:26:46,550
in his keynote yesterday talked about

00:26:44,660 --> 00:26:49,910
the principle of least power that does

00:26:46,550 --> 00:26:52,280
conflict slightly slightly with that I'm

00:26:49,910 --> 00:26:55,670
gonna use my get-out-of-jail-free card

00:26:52,280 --> 00:26:59,270
again and say the goal the goal of

00:26:55,670 --> 00:27:02,030
elegance is not always always consistent

00:26:59,270 --> 00:27:06,010
with them with what how you described in

00:27:02,030 --> 00:27:06,010
his blog on principle of least power but

00:27:06,160 --> 00:27:15,440
here's an example of some code I wrote

00:27:09,890 --> 00:27:17,330
for a new site first design this is an

00:27:15,440 --> 00:27:20,660
example from Raptor HTML which allows

00:27:17,330 --> 00:27:23,809
you to write HTML syntax we import some

00:27:20,660 --> 00:27:26,540
stuff here and then this is representing

00:27:23,809 --> 00:27:30,230
a very simple HTML page this is this is

00:27:26,540 --> 00:27:33,890
properly valid Scala code it's also much

00:27:30,230 --> 00:27:40,760
more type safe than other other HTML

00:27:33,890 --> 00:27:42,980
libraries so one thing rapture wall will

00:27:40,760 --> 00:27:46,250
do is it will allow you to missed a

00:27:42,980 --> 00:27:48,380
title inside a head inside HTML that's

00:27:46,250 --> 00:27:50,540
fine because title can validly go inside

00:27:48,380 --> 00:27:53,120
a head head can go inside HTML that's

00:27:50,540 --> 00:27:56,030
all good if for example I put the title

00:27:53,120 --> 00:27:58,220
inside HTML directly without putting it

00:27:56,030 --> 00:28:01,010
inside her head first that results to

00:27:58,220 --> 00:28:03,380
compile error so I had some other code

00:28:01,010 --> 00:28:05,929
samples where that that was intended to

00:28:03,380 --> 00:28:07,850
to fail compilation I had had loads of

00:28:05,929 --> 00:28:10,490
examples of these then I went through an

00:28:07,850 --> 00:28:15,820
implement to all of it and we now get

00:28:10,490 --> 00:28:19,340
html5 syntax with nesting constraints

00:28:15,820 --> 00:28:23,540
enforced so this is all really super

00:28:19,340 --> 00:28:26,500
type-safe at one example here of an

00:28:23,540 --> 00:28:32,660
attribute so the style attribute which

00:28:26,500 --> 00:28:36,690
is a parameter here and this has a value

00:28:32,660 --> 00:28:39,570
of type CSS from roche to the CSS before

00:28:36,690 --> 00:28:41,100
and then this is basically what night

00:28:39,570 --> 00:28:44,760
what I decided early on that I wanted to

00:28:41,100 --> 00:28:45,840
write and I then went back tried to

00:28:44,760 --> 00:28:48,960
implement the code that would allow me

00:28:45,840 --> 00:28:50,130
to compile those samples and I'll very

00:28:48,960 --> 00:28:54,630
quickly go through the things I needed

00:28:50,130 --> 00:28:57,540
to to use to get that has anyone seen

00:28:54,630 --> 00:29:00,000
scholars we have an identifier

00:28:57,540 --> 00:29:02,340
underscore equals syntax for a setter

00:29:00,000 --> 00:29:05,490
this is quite old syntax like a few

00:29:02,340 --> 00:29:06,840
people have seen it most people don't

00:29:05,490 --> 00:29:10,040
use it it was very popular back when

00:29:06,840 --> 00:29:13,230
getters and setters were all the rage

00:29:10,040 --> 00:29:16,560
less so now but it still exists it still

00:29:13,230 --> 00:29:17,910
works so I use that far args we've got

00:29:16,560 --> 00:29:20,520
implicit parameters involved in that

00:29:17,910 --> 00:29:24,420
HTML library implicit conversions I'm

00:29:20,520 --> 00:29:28,500
chaining so implicit existential types

00:29:24,420 --> 00:29:31,220
they were necessary variant both at the

00:29:28,500 --> 00:29:33,960
definition site and the youth site

00:29:31,220 --> 00:29:38,010
dependent method types I haven't said

00:29:33,960 --> 00:29:39,900
macros yet singleton types and a number

00:29:38,010 --> 00:29:43,200
of hacks I management do it all avoiding

00:29:39,900 --> 00:29:45,240
macros but it did result in all of these

00:29:43,200 --> 00:29:47,160
different features of Scala being used

00:29:45,240 --> 00:29:48,840
but at the end of it after many

00:29:47,160 --> 00:29:50,790
iterations I did get I did get this

00:29:48,840 --> 00:29:53,130
syntax to work I've got all of the test

00:29:50,790 --> 00:29:58,740
cases to to pass I got all the failures

00:29:53,130 --> 00:30:02,520
to fail as desired but it was a lot of

00:29:58,740 --> 00:30:05,280
work so elegance is possible but often

00:30:02,520 --> 00:30:07,620
you need to invest a lot of time a lot

00:30:05,280 --> 00:30:09,780
of experimentation in in getting that

00:30:07,620 --> 00:30:11,990
syntax that has the aesthetic that you

00:30:09,780 --> 00:30:11,990
want

00:30:13,170 --> 00:30:18,970
now this is maybe a slightly contentious

00:30:15,490 --> 00:30:21,370
point but I think it's very important

00:30:18,970 --> 00:30:23,230
especially if you if you work for a

00:30:21,370 --> 00:30:24,880
large organization with a lot of

00:30:23,230 --> 00:30:27,420
developers you're frequently onboarding

00:30:24,880 --> 00:30:30,250
new people you're training people

00:30:27,420 --> 00:30:34,720
training people up on on scarlet as you

00:30:30,250 --> 00:30:40,080
go I really think you shouldn't need to

00:30:34,720 --> 00:30:41,920
be a library author to use the library

00:30:40,080 --> 00:30:43,360
you should be able to get started

00:30:41,920 --> 00:30:45,910
straight away now in the other room

00:30:43,360 --> 00:30:48,700
Daniel Spiewak is I think teaching

00:30:45,910 --> 00:30:53,679
people how to write shapeless without

00:30:48,700 --> 00:30:55,330
without shapeless this is great I mean

00:30:53,679 --> 00:30:58,240
it's really interesting stuff I'm kind

00:30:55,330 --> 00:31:01,110
of sorry I'm missing it but most users

00:30:58,240 --> 00:31:03,280
don't want to have to write shapeless or

00:31:01,110 --> 00:31:06,090
understand the details of shapeless or

00:31:03,280 --> 00:31:08,800
that goes for any other library Fakher

00:31:06,090 --> 00:31:10,540
it always use it the library men should

00:31:08,800 --> 00:31:12,850
be providing an abstraction that saves

00:31:10,540 --> 00:31:17,140
you saves you the trouble of learning

00:31:12,850 --> 00:31:21,270
those differences advanced features like

00:31:17,140 --> 00:31:23,950
implicit macros or high kinda types

00:31:21,270 --> 00:31:28,570
these should not be a barrier to using a

00:31:23,950 --> 00:31:31,270
library now when you're when you're

00:31:28,570 --> 00:31:36,100
starting out as all of us did at some

00:31:31,270 --> 00:31:37,510
point I would describe the way suddenly

00:31:36,100 --> 00:31:40,650
the way I was coding I was loading

00:31:37,510 --> 00:31:42,460
recipes I was I was copy pasting code

00:31:40,650 --> 00:31:46,420
not from the internet because it didn't

00:31:42,460 --> 00:31:49,240
exist then but i was i was typing out

00:31:46,420 --> 00:31:50,410
code from from magazines and I didn't

00:31:49,240 --> 00:31:56,320
really understand what it did i just

00:31:50,410 --> 00:31:58,120
copied it and tried it and i would tweak

00:31:56,320 --> 00:31:59,350
it but if it continued to work that was

00:31:58,120 --> 00:32:00,820
good i learned something i learned that

00:31:59,350 --> 00:32:02,700
i could tweak it in particular ways i

00:32:00,820 --> 00:32:06,730
learned also there are other ways when I

00:32:02,700 --> 00:32:10,480
couldn't I couldn't tweak it and I think

00:32:06,730 --> 00:32:13,660
that's fine I think I think code should

00:32:10,480 --> 00:32:15,910
be I think using using code should be a

00:32:13,660 --> 00:32:17,200
learning process and we should

00:32:15,910 --> 00:32:20,050
accommodate users who are using it in

00:32:17,200 --> 00:32:21,169
that way I think that's it's very

00:32:20,050 --> 00:32:23,539
important

00:32:21,169 --> 00:32:27,029
so here's an example I'm going to ask

00:32:23,539 --> 00:32:30,989
this is sort of ask the audience can

00:32:27,029 --> 00:32:33,979
anyone tell me what's going on in this

00:32:30,989 --> 00:32:38,209
in this little expression here that

00:32:33,979 --> 00:32:41,009
isn't immediately obvious to to the user

00:32:38,209 --> 00:32:44,249
any any suggestions as to what might be

00:32:41,009 --> 00:32:45,689
have now I'll position the cursor there

00:32:44,249 --> 00:32:47,399
there might be something there that we

00:32:45,689 --> 00:32:48,749
can't see there might be something there

00:32:47,399 --> 00:32:50,729
we can't see and there might be

00:32:48,749 --> 00:32:55,979
something there we can't see any

00:32:50,729 --> 00:33:00,259
suggestions oh yeah I miss yeah there's

00:32:55,979 --> 00:33:02,129
there's a Plymouth affair anything else

00:33:00,259 --> 00:33:03,029
well there aren't there are four arcs

00:33:02,129 --> 00:33:06,389
yeah so I mean that's that's

00:33:03,029 --> 00:33:14,099
constructing a sequence behind the

00:33:06,389 --> 00:33:17,879
scenes visit shout louder sagan implicit

00:33:14,099 --> 00:33:18,869
yeah this is implicit haven't this one

00:33:17,879 --> 00:33:21,569
there but there's definitely one there

00:33:18,869 --> 00:33:24,599
because it can build from there's a lot

00:33:21,569 --> 00:33:27,419
of things happening there's a type

00:33:24,599 --> 00:33:31,499
parameter on the apply method that gets

00:33:27,419 --> 00:33:32,819
inferred there's a return type that's

00:33:31,499 --> 00:33:37,829
inferred as well I mean that's that's

00:33:32,819 --> 00:33:42,390
not shown vector can anyone tell me

00:33:37,829 --> 00:33:48,030
anything about vector sorry

00:33:42,390 --> 00:33:49,890
it's a ArrayList now the point I was I

00:33:48,030 --> 00:33:51,300
was going to make was that this is

00:33:49,890 --> 00:33:53,910
actually a higher kind of type this is a

00:33:51,300 --> 00:33:57,450
type constructor now that sounds sounds

00:33:53,910 --> 00:33:58,860
quite advanced but this this simple

00:33:57,450 --> 00:34:01,890
expression is very intuitive it's very

00:33:58,860 --> 00:34:04,760
clear to see that we have vector what

00:34:01,890 --> 00:34:07,290
we're converting this list to a vector

00:34:04,760 --> 00:34:09,929
we don't need to know necessarily that

00:34:07,290 --> 00:34:12,419
the kind of this type here it that it's

00:34:09,929 --> 00:34:13,860
a type constructor type kind from star

00:34:12,419 --> 00:34:18,179
to star we don't we don't need to see

00:34:13,860 --> 00:34:20,190
that to be able to use it and it's quite

00:34:18,179 --> 00:34:23,280
quite conceivable we've just copy that

00:34:20,190 --> 00:34:25,919
paste it and change vector to ArrayList

00:34:23,280 --> 00:34:29,550
or whatever you like and we would expect

00:34:25,919 --> 00:34:31,110
that to work so this is this is

00:34:29,550 --> 00:34:35,179
something that I find really nice about

00:34:31,110 --> 00:34:39,750
scala it it's good for abstraction at

00:34:35,179 --> 00:34:41,520
the youth site we we hide syntax and its

00:34:39,750 --> 00:34:44,669
library authors where there is some

00:34:41,520 --> 00:34:46,350
complexity going on it's it's kind of

00:34:44,669 --> 00:34:48,840
what we want we want to be able to hide

00:34:46,350 --> 00:34:52,679
that from from users who shouldn't have

00:34:48,840 --> 00:34:53,940
to worry about it so I gave this example

00:34:52,679 --> 00:34:55,530
say its height parameters inferred

00:34:53,940 --> 00:34:57,300
return type Sanford's implicit

00:34:55,530 --> 00:34:58,650
parameters get inferred all of these

00:34:57,300 --> 00:35:01,950
things happen without us needing to

00:34:58,650 --> 00:35:04,830
explicitly type them it helps hide

00:35:01,950 --> 00:35:08,310
complexity and it's basically

00:35:04,830 --> 00:35:11,600
abstraction we're abstracting for our

00:35:08,310 --> 00:35:14,550
abstract infer are users use of our code

00:35:11,600 --> 00:35:16,620
the dirty details of what's really

00:35:14,550 --> 00:35:18,510
happening so that they don't have to

00:35:16,620 --> 00:35:22,460
worry about it and this is something

00:35:18,510 --> 00:35:22,460
Scala I think does very very well

00:35:24,570 --> 00:35:30,600
so principle number six you should be

00:35:26,520 --> 00:35:33,180
modular i looked up modularity in the

00:35:30,600 --> 00:35:38,310
dictionary how easily components can be

00:35:33,180 --> 00:35:40,860
separated and recombined so that's so

00:35:38,310 --> 00:35:42,780
that's still rather vague concept what's

00:35:40,860 --> 00:35:47,160
the components what does it mean to

00:35:42,780 --> 00:35:48,150
separate them and recombine them the

00:35:47,160 --> 00:35:51,120
point I'm getting at is that you should

00:35:48,150 --> 00:35:54,000
use type classes so going from this very

00:35:51,120 --> 00:35:56,550
very vague assertion I'm saying that the

00:35:54,000 --> 00:35:58,890
solution to many of your problems it

00:35:56,550 --> 00:36:00,150
does feel like this when you when you

00:35:58,890 --> 00:36:02,790
when you start using type classes that

00:36:00,150 --> 00:36:05,700
they are such a wonderful solution to

00:36:02,790 --> 00:36:07,350
many things how many people here I

00:36:05,700 --> 00:36:10,250
noticed that one person is leaving as

00:36:07,350 --> 00:36:12,810
soon as I mentioned type classes thanks

00:36:10,250 --> 00:36:17,040
how many people here are not familiar

00:36:12,810 --> 00:36:20,010
with sight glasses how many people are

00:36:17,040 --> 00:36:22,160
familiar with type classes so those two

00:36:20,010 --> 00:36:24,300
didn't add up to everyone in the room so

00:36:22,160 --> 00:36:26,820
I'm going to assume people who didn't

00:36:24,300 --> 00:36:29,730
put their hand up are not familiar and

00:36:26,820 --> 00:36:33,060
show you a slide which I hope will give

00:36:29,730 --> 00:36:34,770
a brief overview of why I think type

00:36:33,060 --> 00:36:39,990
glasses are such a great solution for

00:36:34,770 --> 00:36:41,310
for many things so we you're you're

00:36:39,990 --> 00:36:44,580
writing a project this is this is your

00:36:41,310 --> 00:36:46,560
project here along this line now you

00:36:44,580 --> 00:36:50,010
will depend on upstream projects for

00:36:46,560 --> 00:36:53,100
example the standard library and other

00:36:50,010 --> 00:36:54,630
people will depend on you so your

00:36:53,100 --> 00:36:56,580
project in this example is gonna be a

00:36:54,630 --> 00:36:59,630
JSON library and you have a type that

00:36:56,580 --> 00:37:01,920
you're you're writing called Jason okay

00:36:59,630 --> 00:37:03,150
I'm gonna using example of string from

00:37:01,920 --> 00:37:06,330
the standard library that's that's from

00:37:03,150 --> 00:37:08,250
from that stream project and users of

00:37:06,330 --> 00:37:10,320
your Jason library well maybe they want

00:37:08,250 --> 00:37:12,930
to define invoices there they're writing

00:37:10,320 --> 00:37:14,490
an ordering system so i'm going to use

00:37:12,930 --> 00:37:18,030
these three these three types as

00:37:14,490 --> 00:37:22,710
examples that that come from each of

00:37:18,030 --> 00:37:24,860
these each of these projects upstream to

00:37:22,710 --> 00:37:28,640
finding yourself and downstream projects

00:37:24,860 --> 00:37:28,640
now with inheritance

00:37:28,680 --> 00:37:34,359
we could define so we wanted to define

00:37:32,500 --> 00:37:37,839
whether something is writable whether we

00:37:34,359 --> 00:37:40,180
can write it to two discs or two to a

00:37:37,839 --> 00:37:42,550
string don't worry too much about what

00:37:40,180 --> 00:37:45,910
that means but rightful is the concept

00:37:42,550 --> 00:37:47,619
of some kind of capability now with

00:37:45,910 --> 00:37:49,599
inheritance we would say well I Jason

00:37:47,619 --> 00:37:51,040
type extends writable and we would

00:37:49,599 --> 00:37:53,410
implement some methods and then we'll be

00:37:51,040 --> 00:37:56,470
able to call dot write on it that that's

00:37:53,410 --> 00:37:59,470
how inheritance works and in our project

00:37:56,470 --> 00:38:04,869
we can we can write Jason extends

00:37:59,470 --> 00:38:07,630
writable projects downstream of us they

00:38:04,869 --> 00:38:09,160
can they can say well invoice invoice

00:38:07,630 --> 00:38:13,900
extends right sort of also invoices

00:38:09,160 --> 00:38:16,000
become writable that's all good but you

00:38:13,900 --> 00:38:18,220
can't say that strings the rightful Lord

00:38:16,000 --> 00:38:20,260
Jason is rightful in a downstream

00:38:18,220 --> 00:38:24,250
project you can't even say that string

00:38:20,260 --> 00:38:25,869
is rifle in your own project whereas if

00:38:24,250 --> 00:38:28,750
we use type classes we we would define

00:38:25,869 --> 00:38:30,970
to find the writer writer is a type

00:38:28,750 --> 00:38:32,890
class interface and we would to find

00:38:30,970 --> 00:38:35,730
instances of that type class interface

00:38:32,890 --> 00:38:38,290
so we could define a writer for Jason

00:38:35,730 --> 00:38:42,040
that's equivalent to Jason extends

00:38:38,290 --> 00:38:44,440
rightful there we could to find a writer

00:38:42,040 --> 00:38:47,800
for Strings as well we could retro

00:38:44,440 --> 00:38:51,099
actively say this this type which has

00:38:47,800 --> 00:38:52,450
been defined in an upstream project we

00:38:51,099 --> 00:38:53,859
can add this capability to it we are

00:38:52,450 --> 00:38:57,609
retro actually adding that capability to

00:38:53,859 --> 00:39:00,250
someone else's type I'm also leaving

00:38:57,609 --> 00:39:04,359
open the possibility that the downstream

00:39:00,250 --> 00:39:09,430
projects can define for example the

00:39:04,359 --> 00:39:11,680
writer as so the invoice is writable the

00:39:09,430 --> 00:39:13,330
damn three projects also redefine the

00:39:11,680 --> 00:39:15,780
writer for Jason or redefine the writer

00:39:13,330 --> 00:39:15,780
for string

00:39:19,170 --> 00:39:24,599
so there's clearly more capabilities

00:39:22,170 --> 00:39:28,130
here with with with type glasses and

00:39:24,599 --> 00:39:31,109
what they can what will they can define

00:39:28,130 --> 00:39:33,869
they allow us to separate data types

00:39:31,109 --> 00:39:36,240
from the operations on those data types

00:39:33,869 --> 00:39:39,150
and that's that's done frequently with

00:39:36,240 --> 00:39:41,940
extension methods so extension methods

00:39:39,150 --> 00:39:43,530
make it to allow it to look like a lot

00:39:41,940 --> 00:39:46,290
lower co2 look like the method is a

00:39:43,530 --> 00:39:49,140
member of that type but actually have it

00:39:46,290 --> 00:39:51,059
to find somewhere else but it makes it

00:39:49,140 --> 00:39:55,190
very natural to to use for the for the

00:39:51,059 --> 00:39:58,230
user this is all done with scar implicit

00:39:55,190 --> 00:39:59,190
and essentially what type trusts are

00:39:58,230 --> 00:40:00,690
doing their they're providing more

00:39:59,190 --> 00:40:03,569
general form of polymorphism than

00:40:00,690 --> 00:40:07,859
inheritance provides it's a bad hawk

00:40:03,569 --> 00:40:09,780
polymorphism and fundamentally it allows

00:40:07,859 --> 00:40:14,010
this functionality the capabilities to

00:40:09,780 --> 00:40:16,140
be retro-fitted to two types to find

00:40:14,010 --> 00:40:18,500
outside of your own outside of your own

00:40:16,140 --> 00:40:18,500
control

00:40:20,310 --> 00:40:26,460
now there's also quite a neat thing you

00:40:23,340 --> 00:40:29,250
can do with with Cheney implicit because

00:40:26,460 --> 00:40:31,920
as we all know we should avoid writing

00:40:29,250 --> 00:40:34,560
everything twice we should avoid

00:40:31,920 --> 00:40:38,340
repeating ourselves we should avoid

00:40:34,560 --> 00:40:40,650
making several similar points and so on

00:40:38,340 --> 00:40:47,760
we don't want we don't want to have to

00:40:40,650 --> 00:40:49,320
write the same things all the time so

00:40:47,760 --> 00:40:52,800
when I define a tight class so let's say

00:40:49,320 --> 00:40:54,900
I've got a writer type class as I as I

00:40:52,800 --> 00:40:56,130
showed you in the previous slide we were

00:40:54,900 --> 00:40:57,690
not need to find that for a particular

00:40:56,130 --> 00:40:59,220
type like int I've got a writer friend

00:40:57,690 --> 00:41:02,190
I've got a writer for string and I've

00:40:59,220 --> 00:41:06,120
got a writer for double that's all great

00:41:02,190 --> 00:41:08,640
but I want to be able to support options

00:41:06,120 --> 00:41:11,220
event options of string and options of

00:41:08,640 --> 00:41:13,470
double as well what I don't want to have

00:41:11,220 --> 00:41:17,700
to do is write three more type class

00:41:13,470 --> 00:41:19,980
instances six in total into double

00:41:17,700 --> 00:41:21,600
strings.options option option double and

00:41:19,980 --> 00:41:24,390
options string I don't have to write all

00:41:21,600 --> 00:41:28,830
six what I would much rather do is say

00:41:24,390 --> 00:41:32,160
well if I've got a type class for X then

00:41:28,830 --> 00:41:34,980
I can build I either either a why type

00:41:32,160 --> 00:41:37,440
class for sorry if i've got x like ty +

00:41:34,980 --> 00:41:39,780
40 i would like to be able to build

00:41:37,440 --> 00:41:43,290
automatically given that type class a

00:41:39,780 --> 00:41:48,660
why type class for it or in the example

00:41:43,290 --> 00:41:50,760
i just described there if i have a type

00:41:48,660 --> 00:41:52,380
class 40 i want to automatically be able

00:41:50,760 --> 00:41:56,340
to generate a type class for option of

00:41:52,380 --> 00:41:59,640
tea now we can do this by chaining

00:41:56,340 --> 00:42:01,460
implicit we can write an implicit which

00:41:59,640 --> 00:42:04,020
takes another implicit as a parameter

00:42:01,460 --> 00:42:06,720
and this gives us the ability of writing

00:42:04,020 --> 00:42:08,880
a if you look at just this this top

00:42:06,720 --> 00:42:12,300
version here we've got the implicit

00:42:08,880 --> 00:42:15,120
death for an opt extractor so this is an

00:42:12,300 --> 00:42:19,380
extractor i said i should say sterilizer

00:42:15,120 --> 00:42:20,960
i change this code an oxy rÃ©aliser that

00:42:19,380 --> 00:42:26,050
the name doesn't matter in this case but

00:42:20,960 --> 00:42:28,610
it sorry names do matter that was point2

00:42:26,050 --> 00:42:33,950
you should you should definitely not use

00:42:28,610 --> 00:42:36,940
misleading names opt serializer takes

00:42:33,950 --> 00:42:40,550
another implicit as a parameter and

00:42:36,940 --> 00:42:43,880
given given the type T it'll give us an

00:42:40,550 --> 00:42:48,350
option of T so this works for all cases

00:42:43,880 --> 00:42:50,830
if we can find if we can infer it start

00:42:48,350 --> 00:42:55,130
again if we can find an implicit

00:42:50,830 --> 00:42:56,480
extractor for sorry serializer 40 then

00:42:55,130 --> 00:42:58,220
we can create a series of four operation

00:42:56,480 --> 00:42:59,510
of tea I've not shown you the

00:42:58,220 --> 00:43:00,950
implementation but let's assume that we

00:42:59,510 --> 00:43:03,230
can we can implement something that fits

00:43:00,950 --> 00:43:04,490
those types this shorthand for writing

00:43:03,230 --> 00:43:05,930
since Carlo we don't need to write the

00:43:04,490 --> 00:43:07,400
implicit block we can use the context

00:43:05,930 --> 00:43:10,690
found there so if you've got a

00:43:07,400 --> 00:43:13,490
sterilizer 40 then we can create a

00:43:10,690 --> 00:43:15,830
generic one and you can you can write up

00:43:13,490 --> 00:43:17,240
just one implicit we're not repeating

00:43:15,830 --> 00:43:19,910
every single one one implicit which

00:43:17,240 --> 00:43:21,560
deals with options of something or lists

00:43:19,910 --> 00:43:23,780
of something you've even generalized

00:43:21,560 --> 00:43:25,730
overall collections that's that's the

00:43:23,780 --> 00:43:28,580
purpose of the can build from 5 class

00:43:25,730 --> 00:43:30,830
and you can even change some places

00:43:28,580 --> 00:43:34,940
together and end up with actually quite

00:43:30,830 --> 00:43:36,230
complicated trees of implicit search but

00:43:34,940 --> 00:43:38,030
from the user's point if you don't see

00:43:36,230 --> 00:43:40,640
that you just know that you have

00:43:38,030 --> 00:43:43,820
available an option of anything that you

00:43:40,640 --> 00:43:45,740
can you can sterilize so implicit sigh I

00:43:43,820 --> 00:43:47,210
do encourage using implicit but they

00:43:45,740 --> 00:43:48,770
they're not without their problems it's

00:43:47,210 --> 00:43:50,090
often difficult to see where an implicit

00:43:48,770 --> 00:43:52,730
comes from if you've got some code which

00:43:50,090 --> 00:43:54,200
compiles it pulls it implicit from

00:43:52,730 --> 00:43:57,500
somewhere but nobody's really sure where

00:43:54,200 --> 00:43:58,370
a lot of the time and conversely if

00:43:57,500 --> 00:44:01,120
you've got some code that doesn't

00:43:58,370 --> 00:44:04,070
compile because an implicit is missing

00:44:01,120 --> 00:44:05,540
you need to import that from somewhere

00:44:04,070 --> 00:44:08,480
but it's not always obvious where that

00:44:05,540 --> 00:44:10,820
that is implicit not found is an

00:44:08,480 --> 00:44:13,730
annotation you can write on on on type

00:44:10,820 --> 00:44:17,870
classes that will help us help direct

00:44:13,730 --> 00:44:19,880
users where to find that but i think the

00:44:17,870 --> 00:44:21,850
tooling still needs to improve to to

00:44:19,880 --> 00:44:26,030
make it easier for us and and

00:44:21,850 --> 00:44:28,280
documentation it's also one area that I

00:44:26,030 --> 00:44:30,050
need to improve with pigment with my

00:44:28,280 --> 00:44:32,980
code but I think generally the entire

00:44:30,050 --> 00:44:35,830
ecosystem could do with better document

00:44:32,980 --> 00:44:39,140
naming conflicts they they happen and

00:44:35,830 --> 00:44:40,610
then we kind of rely on the slow process

00:44:39,140 --> 00:44:42,830
of people discovering these things

00:44:40,610 --> 00:44:44,720
accomplished two people to define in

00:44:42,830 --> 00:44:46,070
classes with the same name trying to

00:44:44,720 --> 00:44:47,660
import them both into scope at the same

00:44:46,070 --> 00:44:49,670
a user is trying to important both in

00:44:47,660 --> 00:44:51,920
scope at the same time something's got

00:44:49,670 --> 00:44:53,780
to give maybe you have to start

00:44:51,920 --> 00:44:56,210
rewriting rewriting your imports if

00:44:53,780 --> 00:44:59,510
you've seen them but ultimately the

00:44:56,210 --> 00:45:01,610
ecosystem will very slowly evolved and

00:44:59,510 --> 00:45:03,650
and fix itself someone will change the

00:45:01,610 --> 00:45:07,580
name hopefully and that's something

00:45:03,650 --> 00:45:09,530
which which I hope will happen complex

00:45:07,580 --> 00:45:12,260
types Daniel right now is probably

00:45:09,530 --> 00:45:15,770
building an H list in in the other room

00:45:12,260 --> 00:45:17,750
if you haven't really finished if it by

00:45:15,770 --> 00:45:20,750
the way who here has used shapeless or

00:45:17,750 --> 00:45:22,370
used an H list so a few people you've

00:45:20,750 --> 00:45:25,340
seen probably the very complicated types

00:45:22,370 --> 00:45:27,380
you end up with very long types you get

00:45:25,340 --> 00:45:31,300
a type mismatch 1h list doesn't match

00:45:27,380 --> 00:45:36,890
another one is it difficult to read them

00:45:31,300 --> 00:45:38,270
yeah it is and then we can have code

00:45:36,890 --> 00:45:41,630
that looks very Alec elegant in the

00:45:38,270 --> 00:45:43,340
source code but this elegance melts away

00:45:41,630 --> 00:45:46,940
when we have to deal with error messages

00:45:43,340 --> 00:45:49,250
that that Express for example type

00:45:46,940 --> 00:45:52,370
mismatch so the question is can we do

00:45:49,250 --> 00:45:54,980
better so my my last my last slide is

00:45:52,370 --> 00:46:00,140
going to talk through one one weird

00:45:54,980 --> 00:46:01,940
trick for fixing your type errors so

00:46:00,140 --> 00:46:03,710
number one work out what kinds of types

00:46:01,940 --> 00:46:05,900
you were all type mismatches you want to

00:46:03,710 --> 00:46:08,180
you want to handle so for example 8

00:46:05,900 --> 00:46:11,600
lists work out what are the generic

00:46:08,180 --> 00:46:15,380
parts of those eight lists and write

00:46:11,600 --> 00:46:18,230
write write them down and then write the

00:46:15,380 --> 00:46:19,790
implicit conversion that would if I mean

00:46:18,230 --> 00:46:21,860
if that implicit conversion could ever

00:46:19,790 --> 00:46:25,700
be implemented it would it would fix the

00:46:21,860 --> 00:46:28,040
type error so it's implicit from from

00:46:25,700 --> 00:46:34,420
your broken type to the type you want in

00:46:28,040 --> 00:46:36,970
the in in in in in working compiled code

00:46:34,420 --> 00:46:39,160
so this is not the end this will I mean

00:46:36,970 --> 00:46:40,960
this this will fix your it'll make your

00:46:39,160 --> 00:46:43,750
type errors go away but it won't it

00:46:40,960 --> 00:46:44,980
won't solve any problems at all it's

00:46:43,750 --> 00:46:47,470
important it should be a low priority

00:46:44,980 --> 00:46:51,609
implicit lower than lower than anything

00:46:47,470 --> 00:46:53,940
else so make it a default and then

00:46:51,609 --> 00:46:58,240
implement that implicit with the macro

00:46:53,940 --> 00:47:00,790
you all following me so far so you write

00:46:58,240 --> 00:47:04,839
a macro that is implementing an implicit

00:47:00,790 --> 00:47:08,470
conversion and then in that macro look

00:47:04,839 --> 00:47:12,040
at the get get get type tags on the

00:47:08,470 --> 00:47:17,290
parameter type and the expected result

00:47:12,040 --> 00:47:19,020
type okay so you've got those type tags

00:47:17,290 --> 00:47:22,470
in there in the body of the macro and

00:47:19,020 --> 00:47:26,200
the macro can deconstruct those types

00:47:22,470 --> 00:47:27,670
you can you can look at the look at the

00:47:26,200 --> 00:47:30,940
type you can you can write code that

00:47:27,670 --> 00:47:33,309
will execute iteratively it can it can

00:47:30,940 --> 00:47:36,609
do comparisons between these two these

00:47:33,309 --> 00:47:37,839
two types and then you can you can spend

00:47:36,609 --> 00:47:39,609
as much time as you like writing nice

00:47:37,839 --> 00:47:40,930
error messages that describe the

00:47:39,609 --> 00:47:42,760
problems you could you could do a diff

00:47:40,930 --> 00:47:45,309
for example with H list you could say

00:47:42,760 --> 00:47:47,500
that well it's correct apart from this

00:47:45,309 --> 00:47:49,780
missing element here or there the right

00:47:47,500 --> 00:47:51,190
length or the types are wrong all this

00:47:49,780 --> 00:47:55,690
information is available inside the

00:47:51,190 --> 00:47:59,200
macro and consequently when the when the

00:47:55,690 --> 00:48:01,480
compiler invokes that implicit though

00:47:59,200 --> 00:48:03,730
those types become available to macro to

00:48:01,480 --> 00:48:05,380
to to use it print the error message out

00:48:03,730 --> 00:48:07,630
when you've got it but make sure the

00:48:05,380 --> 00:48:11,130
macro fails every time make sure it does

00:48:07,630 --> 00:48:13,750
not succeed if it succeeds then it will

00:48:11,130 --> 00:48:15,730
your code will compile so we still want

00:48:13,750 --> 00:48:18,430
it not to compile we just want to output

00:48:15,730 --> 00:48:21,010
some more information to the user to

00:48:18,430 --> 00:48:23,980
make it clearer what the reason was why

00:48:21,010 --> 00:48:25,930
this why this didn't work so this this

00:48:23,980 --> 00:48:28,750
is something I've used a couple of times

00:48:25,930 --> 00:48:30,970
and it does allow you to produce some

00:48:28,750 --> 00:48:33,940
much nicer error messages and this I

00:48:30,970 --> 00:48:35,829
think is a valid I mean I'm generally

00:48:33,940 --> 00:48:37,390
quite reluctant to use macros more than

00:48:35,829 --> 00:48:39,130
what the mess over this I think a valid

00:48:37,390 --> 00:48:42,400
use because the macro doesn't actually

00:48:39,130 --> 00:48:43,990
generate any code it never succeeds it

00:48:42,400 --> 00:48:46,829
just outputs some some more information

00:48:43,990 --> 00:48:46,829
in the compiler

00:48:47,520 --> 00:48:55,990
during compilation during failed

00:48:49,690 --> 00:48:59,710
compilation 7 okay with us so very very

00:48:55,990 --> 00:49:02,260
quickly to to wrap up the eight points

00:48:59,710 --> 00:49:05,760
six of which I actually talked about we

00:49:02,260 --> 00:49:08,410
have keeping your your API is small

00:49:05,760 --> 00:49:10,690
think about naming think about the user

00:49:08,410 --> 00:49:12,670
experience the aesthetics keep things

00:49:10,690 --> 00:49:16,470
modular and I'm basically saying use

00:49:12,670 --> 00:49:19,030
type classes embrace the type system

00:49:16,470 --> 00:49:21,430
accommodate beginners as much as

00:49:19,030 --> 00:49:23,890
possible and and don't don't don't

00:49:21,430 --> 00:49:28,600
vilify this idea of mindless copy

00:49:23,890 --> 00:49:30,550
pasting amending scoping and organizing

00:49:28,600 --> 00:49:32,140
types using types of bodies I didn't I

00:49:30,550 --> 00:49:35,770
didn't talk about but i'll publish the

00:49:32,140 --> 00:49:40,060
slides later and they should be at least

00:49:35,770 --> 00:49:44,619
as readable as the ones who did see so

00:49:40,060 --> 00:49:47,550
to conclude I I was attempting to define

00:49:44,619 --> 00:49:51,190
elegance combining simplicity power and

00:49:47,550 --> 00:49:55,090
this is certain in F of all grace of

00:49:51,190 --> 00:49:56,950
design we all know about type safety and

00:49:55,090 --> 00:49:59,140
readability but hopefully I've gone some

00:49:56,950 --> 00:50:04,440
way to exploring that that very gray

00:49:59,140 --> 00:50:06,880
space of what by definition ineffable

00:50:04,440 --> 00:50:10,869
there's this ineffable grace of design

00:50:06,880 --> 00:50:12,880
actually encompasses so I this slide

00:50:10,869 --> 00:50:14,890
says any questions I think I have no

00:50:12,880 --> 00:50:16,690
time so i'm gonna i'm going to stop

00:50:14,890 --> 00:50:20,460
there and come and find me outside

00:50:16,690 --> 00:50:20,460
afterwards i'm happy to answer questions

00:50:20,960 --> 00:50:23,020

YouTube URL: https://www.youtube.com/watch?v=bUO_oLwe4Og


