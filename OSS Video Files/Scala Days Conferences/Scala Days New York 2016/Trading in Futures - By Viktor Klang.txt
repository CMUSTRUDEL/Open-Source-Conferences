Title: Trading in Futures - By Viktor Klang
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Scala Futures are one of the most, if not the most, used abstractions for dealing with asynchrony and concurrency in Scala. In this session we're going to go through what's new for Future in Scala 2.12 and how to take advantage of it, and discuss common pitfalls & useful programming patterns for dealing with Futures. The session may or may not also contain rants on designing primitives for concurrency control, spontaneous rebuttals of common criticisms around Futures, and extremely poor and nonsensical analogies.
Captions: 
	00:00:06,279 --> 00:00:11,360
before we start here today I have no

00:00:09,440 --> 00:00:13,219
idea how long this is gonna take this is

00:00:11,360 --> 00:00:15,230
the this could take forever like I could

00:00:13,219 --> 00:00:17,660
stand here for hours and you would have

00:00:15,230 --> 00:00:21,830
to sort of throw me out so let's just

00:00:17,660 --> 00:00:25,130
take it as it goes there are multiple

00:00:21,830 --> 00:00:28,249
levels of jokes in the title I have a

00:00:25,130 --> 00:00:30,710
very very bad sense of humor so it might

00:00:28,249 --> 00:00:33,050
not really shine through but that was

00:00:30,710 --> 00:00:38,329
sort of that was the intent behind the

00:00:33,050 --> 00:00:42,920
title all right should we start

00:00:38,329 --> 00:00:46,280
everybody feel like we should start but

00:00:42,920 --> 00:00:52,399
let's let's get the ball rolling awesome

00:00:46,280 --> 00:00:58,480
all right first question what is a Scala

00:00:52,399 --> 00:00:58,480
concurrent future what is it

00:01:00,039 --> 00:01:10,729
any any ideas suggestions it's a box

00:01:05,290 --> 00:01:15,439
alright fair enough there's something

00:01:10,729 --> 00:01:17,509
highlighted on the screen has something

00:01:15,439 --> 00:01:21,430
to do with concurrency right or

00:01:17,509 --> 00:01:25,640
hopefully naming is hard but hopefully

00:01:21,430 --> 00:01:29,200
right it's like I hear here quite a bit

00:01:25,640 --> 00:01:32,689
so one section of this talk is about

00:01:29,200 --> 00:01:36,200
what's coming in the future right but

00:01:32,689 --> 00:01:40,939
this section of the talk is about the

00:01:36,200 --> 00:01:42,890
current future right the what are we

00:01:40,939 --> 00:01:46,280
working with here and I think there's a

00:01:42,890 --> 00:01:49,009
bit of confusion so what's it what's a

00:01:46,280 --> 00:01:52,219
concurrent future because why isn't why

00:01:49,009 --> 00:01:55,130
isn't it a task what what what's the

00:01:52,219 --> 00:01:58,939
concurrent part well the concurrent part

00:01:55,130 --> 00:02:02,060
is that has to do with coordination of

00:01:58,939 --> 00:02:03,680
some sort right trying to coordinate

00:02:02,060 --> 00:02:08,660
between different concurrent things

00:02:03,680 --> 00:02:11,060
perhaps make sense useful passing things

00:02:08,660 --> 00:02:14,840
around between logical threats of

00:02:11,060 --> 00:02:16,700
control execution hey it does have to do

00:02:14,840 --> 00:02:18,819
with concurrency so let's keep that in

00:02:16,700 --> 00:02:21,980
mind

00:02:18,819 --> 00:02:25,250
so technically you could view it as

00:02:21,980 --> 00:02:28,040
something that is initially unknown for

00:02:25,250 --> 00:02:32,540
some definition of initially and then

00:02:28,040 --> 00:02:34,819
some value or some exception so there's

00:02:32,540 --> 00:02:37,670
there's there's an error there it's it

00:02:34,819 --> 00:02:39,830
doesn't go back from that once it

00:02:37,670 --> 00:02:42,019
becomes a value or an exception it

00:02:39,830 --> 00:02:51,140
doesn't go back to be sort of undefined

00:02:42,019 --> 00:02:54,250
or unknown so in types it would sort of

00:02:51,140 --> 00:02:57,709
be like it and eventually of try of T

00:02:54,250 --> 00:03:00,799
right and eventually is not an actual

00:02:57,709 --> 00:03:02,810
thing but it's eventually a try which is

00:03:00,799 --> 00:03:08,209
a data structure that represents a value

00:03:02,810 --> 00:03:10,930
of type T or an exception or everybody

00:03:08,209 --> 00:03:16,459
feel like this is comfortable

00:03:10,930 --> 00:03:21,349
uncomfortable horrible alright okay so

00:03:16,459 --> 00:03:27,700
we're cool more technically it's an away

00:03:21,349 --> 00:03:35,510
table of T why is that important anybody

00:03:27,700 --> 00:03:37,310
anybody fast you can block sorry get a

00:03:35,510 --> 00:03:40,880
value out of it yeah so the values the T

00:03:37,310 --> 00:03:44,870
and you can block on it and why does it

00:03:40,880 --> 00:03:50,090
make sense to encode this in a type why

00:03:44,870 --> 00:03:56,380
would you want to do that do you want to

00:03:50,090 --> 00:03:59,349
do that why do I want to do that sorry

00:03:56,380 --> 00:04:02,079
yeah so I can keep on going but also

00:03:59,349 --> 00:04:04,190
because it's an effort concern right

00:04:02,079 --> 00:04:07,700
wouldn't necessarily have to support

00:04:04,190 --> 00:04:11,060
blocking and if it is its own type it

00:04:07,700 --> 00:04:15,609
could have its own API and we could know

00:04:11,060 --> 00:04:15,609
what's blocking what isn't block right

00:04:17,200 --> 00:04:27,469
all right so let's have some history so

00:04:21,260 --> 00:04:30,289
one of the first futures take the the

00:04:27,469 --> 00:04:32,440
java.util concurrent future has a very

00:04:30,289 --> 00:04:35,000
sort of blocking API

00:04:32,440 --> 00:04:36,470
getting stuff out within a certain time

00:04:35,000 --> 00:04:39,710
or blocking and definitely to get

00:04:36,470 --> 00:04:45,500
something out but there are more api's

00:04:39,710 --> 00:04:46,130
so it's completed right polling is it

00:04:45,500 --> 00:04:49,430
done yet

00:04:46,130 --> 00:04:51,200
I don't want to block I just want to

00:04:49,430 --> 00:04:53,870
know if it's done and if it's done I'm

00:04:51,200 --> 00:04:56,840
going to pull something out so that's

00:04:53,870 --> 00:05:01,820
one API a polling API but there are more

00:04:56,840 --> 00:05:05,270
api's I called me callback api so on

00:05:01,820 --> 00:05:08,320
success or i'm complete or on failure

00:05:05,270 --> 00:05:13,970
whether you supply some sort of callback

00:05:08,320 --> 00:05:17,600
that's one api but i think in the end

00:05:13,970 --> 00:05:21,560
we've arrived at really sort of pushing

00:05:17,600 --> 00:05:23,570
the transformational api sort of taking

00:05:21,560 --> 00:05:26,090
something that will be available at some

00:05:23,570 --> 00:05:30,080
point and transforming it once that

00:05:26,090 --> 00:05:31,760
happens and producing something you why

00:05:30,080 --> 00:05:34,090
is this important

00:05:31,760 --> 00:05:39,230
why is this sort of progression

00:05:34,090 --> 00:05:42,410
important because we don't stop just

00:05:39,230 --> 00:05:44,590
because we've found a solution we

00:05:42,410 --> 00:05:49,270
continue until we find a better solution

00:05:44,590 --> 00:05:51,170
hey some use cases do not support

00:05:49,270 --> 00:05:54,200
transformation some use cases only

00:05:51,170 --> 00:05:56,300
supports polling for instance so there's

00:05:54,200 --> 00:05:59,620
still value in providing multiple api's

00:05:56,300 --> 00:06:02,300
it's just a question of how do we

00:05:59,620 --> 00:06:03,800
promote certain API in certain

00:06:02,300 --> 00:06:06,020
situations and other aps and other

00:06:03,800 --> 00:06:09,260
situations and how do you communicate

00:06:06,020 --> 00:06:11,900
with users and how the users internalize

00:06:09,260 --> 00:06:14,600
when API is for appropriate use and

00:06:11,900 --> 00:06:16,040
which API they should be using and I

00:06:14,600 --> 00:06:19,610
think today what I want to tell you is

00:06:16,040 --> 00:06:22,250
that if you have the choice of using the

00:06:19,610 --> 00:06:25,400
transformational API you should use the

00:06:22,250 --> 00:06:30,400
transformational API I'm going to try to

00:06:25,400 --> 00:06:30,400
to enunciate why why that is the case so

00:06:32,650 --> 00:06:42,560
async versus synchronous what happens

00:06:37,580 --> 00:06:45,500
where and what so one common criticism

00:06:42,560 --> 00:06:45,939
against the current scholar concurrent

00:06:45,500 --> 00:06:49,219
future

00:06:45,939 --> 00:06:52,610
implementation is that it needs to have

00:06:49,219 --> 00:06:54,349
this execution context right why do we

00:06:52,610 --> 00:06:58,069
need to have this execution context and

00:06:54,349 --> 00:07:01,520
why can't I just add my stuff and stuff

00:06:58,069 --> 00:07:05,229
just happens why can't I have good

00:07:01,520 --> 00:07:05,229
things yes

00:07:05,289 --> 00:07:14,060
like a pool arc pool lock starvation

00:07:11,029 --> 00:07:15,490
it's a good good good comment there you

00:07:14,060 --> 00:07:19,360
comment there

00:07:15,490 --> 00:07:23,409
threads are aren't cheap exactly

00:07:19,360 --> 00:07:26,599
also let's say that you were to add a

00:07:23,409 --> 00:07:29,569
transformation to be executed once the

00:07:26,599 --> 00:07:33,770
future has been completed what thread

00:07:29,569 --> 00:07:37,069
would actually run that so in the case

00:07:33,770 --> 00:07:42,500
of the completing thread invokes this

00:07:37,069 --> 00:07:46,550
transformation what happens if that is

00:07:42,500 --> 00:07:48,379
an expensive transformation what happens

00:07:46,550 --> 00:07:51,289
if that transformation triggers more

00:07:48,379 --> 00:07:55,689
transformations what happens if that

00:07:51,289 --> 00:07:58,490
happens in a sort of infinite sequence

00:07:55,689 --> 00:08:00,379
where the thread needs to call the next

00:07:58,490 --> 00:08:02,060
callback to call the next callback to

00:08:00,379 --> 00:08:03,710
call the next callback when does that

00:08:02,060 --> 00:08:08,180
thread get back to doing what it was

00:08:03,710 --> 00:08:11,210
supposed to do also there is a race

00:08:08,180 --> 00:08:13,909
condition involved here right so what if

00:08:11,210 --> 00:08:17,589
we add the transformation after it's

00:08:13,909 --> 00:08:21,050
being completed then we run the callback

00:08:17,589 --> 00:08:24,710
so now we have a built in race condition

00:08:21,050 --> 00:08:31,310
into our program I think that's a bad

00:08:24,710 --> 00:08:32,719
idea so how about we pick something and

00:08:31,310 --> 00:08:34,909
we just make sure that that's what

00:08:32,719 --> 00:08:37,550
happened what happens like we we like

00:08:34,909 --> 00:08:39,409
determinism in the sense that it helps

00:08:37,550 --> 00:08:42,409
us recent about our code so if we know

00:08:39,409 --> 00:08:46,910
that this thing will always be invoked

00:08:42,409 --> 00:08:48,410
in an asynchronous manner seems like a

00:08:46,910 --> 00:08:51,019
better trade off than it's always

00:08:48,410 --> 00:08:52,940
executed synchronous right because we

00:08:51,019 --> 00:08:55,130
wouldn't know what would execute it

00:08:52,940 --> 00:08:56,779
secrets which brick the completing

00:08:55,130 --> 00:08:58,750
thread or the thread that asks the

00:08:56,779 --> 00:09:03,560
callback

00:08:58,750 --> 00:09:06,560
right so this is why being able to say

00:09:03,560 --> 00:09:09,350
this runs on this execution context

00:09:06,560 --> 00:09:11,120
makes sense because if you have a piece

00:09:09,350 --> 00:09:13,690
of logic that produces values for

00:09:11,120 --> 00:09:15,830
futures you might want to isolate that

00:09:13,690 --> 00:09:18,530
logically from the rest of your program

00:09:15,830 --> 00:09:20,360
saying that this thing is run on this

00:09:18,530 --> 00:09:22,220
thread pool and this other thing here is

00:09:20,360 --> 00:09:23,540
running on this other thread pool and I

00:09:22,220 --> 00:09:29,630
don't want them to interfere with each

00:09:23,540 --> 00:09:34,310
other all right so since we have this

00:09:29,630 --> 00:09:38,660
concurrent future what do we need when

00:09:34,310 --> 00:09:42,530
we do concurrent programming we need

00:09:38,660 --> 00:09:45,500
relationships right how do we know how

00:09:42,530 --> 00:09:49,400
things happen so this is this is an

00:09:45,500 --> 00:09:51,950
important guarantee the completion of a

00:09:49,400 --> 00:09:54,140
promise happens before which is a very

00:09:51,950 --> 00:09:57,740
very well established terms in terms of

00:09:54,140 --> 00:10:01,040
of memory visibility the invocation of

00:09:57,740 --> 00:10:03,650
the callback we know that if we publish

00:10:01,040 --> 00:10:05,780
something into this promise it will be

00:10:03,650 --> 00:10:10,450
safely published to all the consumers of

00:10:05,780 --> 00:10:13,100
its future important super important

00:10:10,450 --> 00:10:15,860
this is not super well stated in the

00:10:13,100 --> 00:10:20,090
current documentation so I think this is

00:10:15,860 --> 00:10:25,780
an important slide all right

00:10:20,090 --> 00:10:25,780
so going back to the execution context

00:10:26,410 --> 00:10:32,060
something clicked for me when I realized

00:10:28,970 --> 00:10:34,820
that it's about an interpreter you're

00:10:32,060 --> 00:10:37,660
essentially saying that this logic

00:10:34,820 --> 00:10:40,580
should be executed by this interpreter

00:10:37,660 --> 00:10:44,090
so if you think about execution context

00:10:40,580 --> 00:10:46,580
as an interpreter to me it might not be

00:10:44,090 --> 00:10:50,930
to you but it's a suggestion it makes

00:10:46,580 --> 00:10:53,870
sense I'm adding an interpreter for this

00:10:50,930 --> 00:11:00,650
program that gets run on this completion

00:10:53,870 --> 00:11:05,570
of this future all right so let's just

00:11:00,650 --> 00:11:07,610
try a demo here and this is this is live

00:11:05,570 --> 00:11:10,790
coding people I mean everything can

00:11:07,610 --> 00:11:13,450
happen here probably will let's just

00:11:10,790 --> 00:11:13,450
roll with

00:11:13,540 --> 00:11:23,630
all right so let's say that execution

00:11:18,530 --> 00:11:25,520
context is an interpreter right if we

00:11:23,630 --> 00:11:33,770
wanted to create our own interpreter

00:11:25,520 --> 00:11:35,780
implementation here we extend a a nice

00:11:33,770 --> 00:11:37,850
concurrent link you because we need to

00:11:35,780 --> 00:11:41,150
add things concurrently that would be

00:11:37,850 --> 00:11:44,750
nice just used the Java thing well we

00:11:41,150 --> 00:11:47,570
all test it and for each of the things

00:11:44,750 --> 00:11:50,840
that we should interpret we added

00:11:47,570 --> 00:11:54,040
through our cue our cells here so we're

00:11:50,840 --> 00:11:57,560
just up anything strong terone cue

00:11:54,040 --> 00:12:01,130
everybody with me if somebody's like

00:11:57,560 --> 00:12:07,940
dude that's crazy just tell me and we'll

00:12:01,130 --> 00:12:10,340
sort it out and while this may not be

00:12:07,940 --> 00:12:13,820
super important one of the important

00:12:10,340 --> 00:12:18,050
things that I think was in the execution

00:12:13,820 --> 00:12:21,470
context definition was the ability to

00:12:18,050 --> 00:12:25,100
log errors that were there weren't any

00:12:21,470 --> 00:12:26,930
apparent receiver of an error so let's

00:12:25,100 --> 00:12:31,460
say that you have a completion callback

00:12:26,930 --> 00:12:36,020
and that fails for some reason who would

00:12:31,460 --> 00:12:40,850
know right if a tree falls in the forest

00:12:36,020 --> 00:12:43,670
that nobody's there did it happen with

00:12:40,850 --> 00:12:46,130
this API it can actually scream into the

00:12:43,670 --> 00:12:50,480
internets and everybody knew that the

00:12:46,130 --> 00:12:51,860
tree fell right all right so let's say

00:12:50,480 --> 00:12:54,650
that we now have an interpreter that

00:12:51,860 --> 00:12:57,770
just stores things to interpret and and

00:12:54,650 --> 00:13:01,760
mind you runnable might not be the most

00:12:57,770 --> 00:13:04,370
elaborate of algebras to interpret might

00:13:01,760 --> 00:13:06,230
actually be one of the smallest because

00:13:04,370 --> 00:13:10,600
it's essentially like a function from

00:13:06,230 --> 00:13:16,730
unit to unit but at least it's something

00:13:10,600 --> 00:13:18,530
and let us define a method that allows

00:13:16,730 --> 00:13:20,450
us to interpret the next thing to

00:13:18,530 --> 00:13:22,010
interpret and return a boolean whether

00:13:20,450 --> 00:13:24,160
there are more things to interpret after

00:13:22,010 --> 00:13:24,160
this

00:13:24,930 --> 00:13:32,939
so we're pulling our queue and his pole

00:13:30,959 --> 00:13:35,999
can return a novel we rather than an

00:13:32,939 --> 00:13:38,249
option use options fold to return false

00:13:35,999 --> 00:13:40,079
if it was empty and if there was

00:13:38,249 --> 00:13:43,949
something called our which is our

00:13:40,079 --> 00:13:47,220
runnable we print it out because that

00:13:43,949 --> 00:13:49,290
makes sense we run it and we return

00:13:47,220 --> 00:13:51,600
whether we were empty or not so if

00:13:49,290 --> 00:13:53,850
there's more information that makes

00:13:51,600 --> 00:13:59,850
sense everybody with me we can interpret

00:13:53,850 --> 00:14:02,100
rumbles awesome all right so let us say

00:13:59,850 --> 00:14:05,999
that we have this program which has the

00:14:02,100 --> 00:14:09,949
manual execution context and we create a

00:14:05,999 --> 00:14:12,990
future of a list of make foo nutbar

00:14:09,949 --> 00:14:14,879
right and we want to create a spring out

00:14:12,990 --> 00:14:17,879
of that because that's a very sensible

00:14:14,879 --> 00:14:19,350
thing to do concurrently right don't

00:14:17,879 --> 00:14:22,670
want to do that in your own thread

00:14:19,350 --> 00:14:25,589
that's someone else do it

00:14:22,670 --> 00:14:30,360
this won't really do anything right

00:14:25,589 --> 00:14:33,870
until we interpret the code right so if

00:14:30,360 --> 00:14:36,600
we don't interpret anything this test

00:14:33,870 --> 00:14:39,420
should fail right are we are we cool

00:14:36,600 --> 00:14:45,019
with that all right

00:14:39,420 --> 00:14:45,019
let's try it out let's see what happens

00:14:58,910 --> 00:15:04,150
so he fails right so we didn't interpret

00:15:02,240 --> 00:15:07,370
what was supposed to be interpreted and

00:15:04,150 --> 00:15:10,210
we were waiting for the result but it

00:15:07,370 --> 00:15:13,940
never showed up or within our time out

00:15:10,210 --> 00:15:17,090
so let's try to to fix the program right

00:15:13,940 --> 00:15:19,370
we interpret the single thing that we

00:15:17,090 --> 00:15:21,980
should interpret and hopefully this time

00:15:19,370 --> 00:15:24,290
it will actually pass so we've created

00:15:21,980 --> 00:15:26,350
our own execution context we've decided

00:15:24,290 --> 00:15:29,860
when we want to to interpret things

00:15:26,350 --> 00:15:33,230
right simple enough

00:15:29,860 --> 00:15:39,700
all right so let's say we get really

00:15:33,230 --> 00:15:42,020
adventurous and we want to map identity

00:15:39,700 --> 00:15:44,990
because this this is one of the most

00:15:42,020 --> 00:15:48,650
useful transformations I found because

00:15:44,990 --> 00:15:50,950
it doesn't destroy any information what

00:15:48,650 --> 00:15:50,950
should happen

00:15:54,130 --> 00:16:03,290
it fails doesn't fail doesn't fail fail

00:15:59,800 --> 00:16:11,300
hey else all right let's see what

00:16:03,290 --> 00:16:12,590
happens Dave is right because we added

00:16:11,300 --> 00:16:14,930
something more to interpret and we

00:16:12,590 --> 00:16:18,020
didn't interpret that thing so let's say

00:16:14,930 --> 00:16:23,260
that we want to fix this this problem we

00:16:18,020 --> 00:16:23,260
do right

00:16:26,430 --> 00:16:33,650
passes it

00:16:30,500 --> 00:16:35,840
short circuit we don't interpret unless

00:16:33,650 --> 00:16:37,700
there's anything run and we only

00:16:35,840 --> 00:16:43,100
interpret again if there was anything

00:16:37,700 --> 00:16:47,300
else to do all right let's get back to

00:16:43,100 --> 00:16:49,220
this one so have I sold you the idea of

00:16:47,300 --> 00:16:53,270
execution context being a sort of an

00:16:49,220 --> 00:16:56,810
interpreter no not really

00:16:53,270 --> 00:17:00,800
oh man this is gonna take forever

00:16:56,810 --> 00:17:03,620
all right so what's new well four to

00:17:00,800 --> 00:17:10,490
twelve a success and a failure is

00:17:03,620 --> 00:17:12,800
deprecated why right why well turns out

00:17:10,490 --> 00:17:16,069
that our success is just a partial

00:17:12,800 --> 00:17:20,959
version of for each takes a partial

00:17:16,069 --> 00:17:25,970
function right and our failure is just a

00:17:20,959 --> 00:17:27,920
partial version of failed for each right

00:17:25,970 --> 00:17:31,670
so why have multiple ways of doing the

00:17:27,920 --> 00:17:33,950
same thing when would you decide to use

00:17:31,670 --> 00:17:39,200
whichever of them well that's why

00:17:33,950 --> 00:17:41,660
they're deprecated all right so one

00:17:39,200 --> 00:17:43,400
annoying thing that I found and if I

00:17:41,660 --> 00:17:46,310
read Stack Overflow correctly others

00:17:43,400 --> 00:17:48,860
have found this as well having to

00:17:46,310 --> 00:17:51,680
flatten futures using flat map identity

00:17:48,860 --> 00:17:56,170
is not necessarily the most ergonomic

00:17:51,680 --> 00:18:03,410
way of doing it why is that the case

00:17:56,170 --> 00:18:08,710
ideas suggestions hate mail screams of

00:18:03,410 --> 00:18:08,710
insanity nothing

00:18:12,540 --> 00:18:23,559
doing it all the time this oh if you end

00:18:21,160 --> 00:18:28,059
up doing it a lot one one sort of dirty

00:18:23,559 --> 00:18:30,429
secret is that identity is a method it's

00:18:28,059 --> 00:18:32,260
not a function so whenever you do this

00:18:30,429 --> 00:18:36,250
you're allocating an identity function

00:18:32,260 --> 00:18:37,030
literal out of the identity method so

00:18:36,250 --> 00:18:40,390
you're going to be creating a new

00:18:37,030 --> 00:18:42,669
identity function needlessly because

00:18:40,390 --> 00:18:45,900
it's a very trivial operation but also

00:18:42,669 --> 00:18:51,780
it requires an execution context right

00:18:45,900 --> 00:18:55,540
you can put any code in that F good like

00:18:51,780 --> 00:19:00,330
it's just an exit or something so we

00:18:55,540 --> 00:19:08,890
can't really optimize anything so

00:19:00,330 --> 00:19:11,260
flatten is new right feels fresh doesn't

00:19:08,890 --> 00:19:14,169
require any execution context because we

00:19:11,260 --> 00:19:16,450
can prove that we're just unlisting a

00:19:14,169 --> 00:19:18,220
future so it's not an expensive a weird

00:19:16,450 --> 00:19:21,070
operation that wouldn't necessarily need

00:19:18,220 --> 00:19:25,020
to live somewhere else we can just pop

00:19:21,070 --> 00:19:27,730
in the future it saves some typing right

00:19:25,020 --> 00:19:36,210
but also it saves us from allocating

00:19:27,730 --> 00:19:40,260
things needlessly all right so one thing

00:19:36,210 --> 00:19:42,850
when you want to combine two futures and

00:19:40,260 --> 00:19:44,799
take the results of both and do a

00:19:42,850 --> 00:19:47,890
transformation you either need to do

00:19:44,799 --> 00:19:51,880
this sort of flat map map dance what I

00:19:47,890 --> 00:19:53,260
call the the soup map that crap you sift

00:19:51,880 --> 00:19:57,610
them first and then you map over them

00:19:53,260 --> 00:20:00,220
and then you create yourself what why is

00:19:57,610 --> 00:20:05,049
this necessary really I mean it should

00:20:00,220 --> 00:20:06,429
be some sort of like core thing to want

00:20:05,049 --> 00:20:12,309
to be able to combine two things and

00:20:06,429 --> 00:20:17,530
transform their results right so how

00:20:12,309 --> 00:20:19,270
about sit with right take some future

00:20:17,530 --> 00:20:20,800
Civet with some other future and supply

00:20:19,270 --> 00:20:22,990
it with a function to transform the

00:20:20,800 --> 00:20:25,690
values no need to create the interim

00:20:22,990 --> 00:20:31,030
get tuple no need to do this sort of

00:20:25,690 --> 00:20:34,720
two-step async dance she's nice right

00:20:31,030 --> 00:20:36,730
looks good should be nice and also as we

00:20:34,720 --> 00:20:42,270
can see that sip is actually a special

00:20:36,730 --> 00:20:47,290
case of sip with people to apply cool

00:20:42,270 --> 00:20:53,700
alright so this is one of the most

00:20:47,290 --> 00:20:59,110
exciting news of the two twelve futures

00:20:53,700 --> 00:21:01,030
so all all your future aficionados that

00:20:59,110 --> 00:21:03,820
that have read the the skull of future

00:21:01,030 --> 00:21:05,740
documentation over and over and over

00:21:03,820 --> 00:21:07,780
again you might know that there is

00:21:05,740 --> 00:21:12,100
already a method called transform before

00:21:07,780 --> 00:21:14,410
right but they're that transform is more

00:21:12,100 --> 00:21:16,630
clunky it takes like a function from

00:21:14,410 --> 00:21:21,340
from the result type and then sort of

00:21:16,630 --> 00:21:22,900
like a by map sort of transforming an

00:21:21,340 --> 00:21:25,600
exception case and transforming it

00:21:22,900 --> 00:21:29,440
success case this version of transform

00:21:25,600 --> 00:21:32,800
is strictly more advanced so what what

00:21:29,440 --> 00:21:45,250
is what is the the thing below the the

00:21:32,800 --> 00:21:49,920
definition it's it's code right that's

00:21:45,250 --> 00:21:53,110
map yeah that's math transform the try

00:21:49,920 --> 00:21:55,690
by mapping it using a future so try has

00:21:53,110 --> 00:22:02,380
a map function so this is the definition

00:21:55,690 --> 00:22:03,309
of the map operation on future turns out

00:22:02,380 --> 00:22:05,830
that there is another interesting

00:22:03,309 --> 00:22:10,179
function called transform with that is

00:22:05,830 --> 00:22:15,580
new right what's this what what are

00:22:10,179 --> 00:22:18,130
these two seemingly weird things we need

00:22:15,580 --> 00:22:26,320
the definition or the declaration of the

00:22:18,130 --> 00:22:31,790
method any takers in the spirit of the

00:22:26,320 --> 00:22:33,200
the of the previous answer spot map

00:22:31,790 --> 00:22:42,050
the first one is flatmap what is the

00:22:33,200 --> 00:22:47,270
second takes a failure case applies a

00:22:42,050 --> 00:22:54,530
partial function recover recover with

00:22:47,270 --> 00:22:57,530
even awesome right so we have this more

00:22:54,530 --> 00:23:00,740
powerful operation that we can encode

00:22:57,530 --> 00:23:03,740
these other operations with that's

00:23:00,740 --> 00:23:05,990
pretty cool they're a team that there

00:23:03,740 --> 00:23:08,630
was something strictly more powerful

00:23:05,990 --> 00:23:10,820
that was just hiding just behind flat

00:23:08,630 --> 00:23:20,210
map and and map and recover or recover

00:23:10,820 --> 00:23:22,940
with all right so let's try another demo

00:23:20,210 --> 00:23:24,350
I'm not sure we have time but I said

00:23:22,940 --> 00:23:29,390
that this was gonna take forever and you

00:23:24,350 --> 00:23:34,250
agreed so ah let's see here all right so

00:23:29,390 --> 00:23:37,490
one common criticism is that it's

00:23:34,250 --> 00:23:40,460
impossible to compose behaviors for

00:23:37,490 --> 00:23:42,110
futures without requiring a an execution

00:23:40,460 --> 00:23:44,240
context have you heard this before have

00:23:42,110 --> 00:23:47,630
you experienced it before have you sort

00:23:44,240 --> 00:23:51,380
of silently hated me for that have you

00:23:47,630 --> 00:23:53,450
verbally hated that right this is a

00:23:51,380 --> 00:23:55,070
common thing right why do we need to

00:23:53,450 --> 00:23:58,070
require an execution context to do the

00:23:55,070 --> 00:24:00,200
most basic of things well I'm saying

00:23:58,070 --> 00:24:02,480
that from 2-12 and forward

00:24:00,200 --> 00:24:06,350
you don't strictly necessarily need to

00:24:02,480 --> 00:24:08,960
have that problem because if we have a

00:24:06,350 --> 00:24:11,720
method that takes a function from try to

00:24:08,960 --> 00:24:16,280
try and a function that takes to try to

00:24:11,720 --> 00:24:20,210
future and we can compose those so let's

00:24:16,280 --> 00:24:25,400
say that we have something we call parse

00:24:20,210 --> 00:24:29,660
in takes a try tries the parson in from

00:24:25,400 --> 00:24:32,500
that things that's successful and if we

00:24:29,660 --> 00:24:37,610
have a try of int and we want to apply

00:24:32,500 --> 00:24:39,560
to a hex string we can do that we can

00:24:37,610 --> 00:24:44,030
compose I mean this is function

00:24:39,560 --> 00:24:45,560
composition sounds amazing right it

00:24:44,030 --> 00:24:49,250
sounds like something that could be very

00:24:45,560 --> 00:24:51,380
people in a functional language right so

00:24:49,250 --> 00:24:53,990
if we can compose these two things we

00:24:51,380 --> 00:24:56,560
have a new function so we have now

00:24:53,990 --> 00:25:00,170
composed the behavior for our thing and

00:24:56,560 --> 00:25:05,390
we haven't seen the need for an

00:25:00,170 --> 00:25:07,640
execution context yet right so if we

00:25:05,390 --> 00:25:12,440
then complete our promise of a string

00:25:07,640 --> 00:25:16,010
with this amazing number and then supply

00:25:12,440 --> 00:25:18,380
our transformation to transform we give

00:25:16,010 --> 00:25:21,170
it some execution context to perform

00:25:18,380 --> 00:25:25,790
this transformation right we give it and

00:25:21,170 --> 00:25:29,710
the interpreter when we need to we

00:25:25,790 --> 00:25:31,600
should get a cafe out of that right I

00:25:29,710 --> 00:25:36,400
think so

00:25:31,600 --> 00:25:42,740
you don't seem super convinced right

00:25:36,400 --> 00:25:46,910
what we do we could create a

00:25:42,740 --> 00:25:48,860
transformation in itself compose it and

00:25:46,910 --> 00:25:53,120
supply it to a future when we needed to

00:25:48,860 --> 00:25:55,190
right so not strictly necessarily having

00:25:53,120 --> 00:25:59,630
to pass around an execution context at

00:25:55,190 --> 00:26:06,400
all points in time you don't seem super

00:25:59,630 --> 00:26:06,400
convinced here what's the difference

00:26:06,920 --> 00:26:12,980
so how would you compose these things so

00:26:10,070 --> 00:26:16,570
if you were to use map for it and just

00:26:12,980 --> 00:26:19,040
use normal functions from T to R right

00:26:16,570 --> 00:26:21,320
instead of trying to you to try to VAR

00:26:19,040 --> 00:26:23,960
you couldn't necessarily do the recover

00:26:21,320 --> 00:26:25,490
case you couldn't necessarily deal with

00:26:23,960 --> 00:26:26,930
those things so this is strictly more

00:26:25,490 --> 00:26:29,120
powerful but you could do something

00:26:26,930 --> 00:26:30,500
similar but you couldn't really deal

00:26:29,120 --> 00:26:32,470
with the fingers you would have to

00:26:30,500 --> 00:26:39,770
resort to your own sort a try-catch

00:26:32,470 --> 00:26:44,060
stuff all right back to the talk all

00:26:39,770 --> 00:26:54,460
right this is this is huge right we have

00:26:44,060 --> 00:26:54,460
a future in 212 called unit I mean right

00:26:55,120 --> 00:27:04,900
we have that now so one of the biggest

00:26:59,660 --> 00:27:08,720
news and to be fair it's it's only a

00:27:04,900 --> 00:27:10,970
future that holds the value unit but

00:27:08,720 --> 00:27:12,860
it's amazing often you need that I've

00:27:10,970 --> 00:27:14,630
seen it so many times where somebody

00:27:12,860 --> 00:27:18,350
creates a new a future successful of

00:27:14,630 --> 00:27:20,930
unit not even funny so having a

00:27:18,350 --> 00:27:26,420
dedicated unit for this is is pretty

00:27:20,930 --> 00:27:28,370
nice why is this nice well you might ask

00:27:26,420 --> 00:27:33,730
yourself did Victor just really pull off

00:27:28,370 --> 00:27:40,130
a bacon lambda well I think it did right

00:27:33,730 --> 00:27:43,010
if you think about it the apply method

00:27:40,130 --> 00:27:46,610
on future to create a future out of a an

00:27:43,010 --> 00:27:55,100
expression is just syntactic bacon for

00:27:46,610 --> 00:27:58,520
future unit map right it's actually

00:27:55,100 --> 00:28:00,700
implemented like that there's no

00:27:58,520 --> 00:28:00,700
difference

00:28:03,320 --> 00:28:10,950
all right so going with the the theme

00:28:07,160 --> 00:28:17,220
there's a future never it's a very grim

00:28:10,950 --> 00:28:23,970
future for sure so what is the problem

00:28:17,220 --> 00:28:28,230
with the code above or what is a problem

00:28:23,970 --> 00:28:32,450
with the code above what is the good

00:28:28,230 --> 00:28:36,810
thing about the code above before

00:28:32,450 --> 00:28:38,820
happens before not an issue but what

00:28:36,810 --> 00:28:40,830
happens if you want to represent a

00:28:38,820 --> 00:28:42,830
future that never completes and you

00:28:40,830 --> 00:28:45,720
passed that around in your program and

00:28:42,830 --> 00:28:51,750
somebody adds a gazillion callbacks to

00:28:45,720 --> 00:28:55,140
that what happens well you have a memory

00:28:51,750 --> 00:28:56,640
leak because it will gladly sit around

00:28:55,140 --> 00:28:57,780
there because it can never be completed

00:28:56,640 --> 00:29:03,360
because there is no value of nothing

00:28:57,780 --> 00:29:09,480
right there's no value of not that's

00:29:03,360 --> 00:29:12,210
pretty deep but there is a solution for

00:29:09,480 --> 00:29:14,730
that now so you can actually pass around

00:29:12,210 --> 00:29:16,830
future never in the case you want to

00:29:14,730 --> 00:29:23,580
represent that and that will not leak

00:29:16,830 --> 00:29:26,720
memory all right so one thing that

00:29:23,580 --> 00:29:29,640
really got me hooked to futures was a

00:29:26,720 --> 00:29:32,640
programming style I think it was Marius

00:29:29,640 --> 00:29:35,370
Ericsson at Twitter that I saw doing

00:29:32,640 --> 00:29:36,750
this the first time and I call the async

00:29:35,370 --> 00:29:38,720
continuation passing style I don't know

00:29:36,750 --> 00:29:42,570
what he calls it but he's probably right

00:29:38,720 --> 00:29:47,180
you have to call it a CPS now for now

00:29:42,570 --> 00:29:50,880
and while the code here might look

00:29:47,180 --> 00:29:56,970
unnecessarily contrived let's imagine

00:29:50,880 --> 00:29:59,850
that we wanted to abstract over mapping

00:29:56,970 --> 00:30:01,560
over a sequence or an interval of

00:29:59,850 --> 00:30:03,450
something over something and only

00:30:01,560 --> 00:30:06,810
continue with the next transformation

00:30:03,450 --> 00:30:08,130
once the previous one completes so we

00:30:06,810 --> 00:30:11,670
want to do it step by step but

00:30:08,130 --> 00:30:14,240
asynchronously creating a new iterable

00:30:11,670 --> 00:30:14,240
out of that

00:30:15,950 --> 00:30:24,330
so what happens here is if you look at

00:30:21,149 --> 00:30:26,669
the the last line first we're creating

00:30:24,330 --> 00:30:30,720
an iterator over the the past in

00:30:26,669 --> 00:30:34,200
iterable and we're using the amazing can

00:30:30,720 --> 00:30:38,249
build from API that has been very highly

00:30:34,200 --> 00:30:40,740
esteemed for a long time to create the

00:30:38,249 --> 00:30:43,830
initial builder for this we want to

00:30:40,740 --> 00:30:53,070
build the the next collection out of

00:30:43,830 --> 00:30:56,009
this and once we have an iterator if we

00:30:53,070 --> 00:31:02,869
have something in it there's some more

00:30:56,009 --> 00:31:08,970
values we create a future that in itself

00:31:02,869 --> 00:31:11,070
calls F applies the next thing returns

00:31:08,970 --> 00:31:14,220
that as a future right so we have the

00:31:11,070 --> 00:31:16,259
value of the application of F to the

00:31:14,220 --> 00:31:19,559
next thing in the iterator are you with

00:31:16,259 --> 00:31:26,179
me we have transformed one element right

00:31:19,559 --> 00:31:29,340
now using F and using flatmap we recurse

00:31:26,179 --> 00:31:34,440
right we do flat map we have the builder

00:31:29,340 --> 00:31:36,350
right we apply the next step so we're

00:31:34,440 --> 00:31:40,549
sitting essentially doing async

00:31:36,350 --> 00:31:44,759
recursion and since we're calling next

00:31:40,549 --> 00:31:47,879
once I no longer pass next and we'll

00:31:44,759 --> 00:31:51,269
return in future that has the successful

00:31:47,879 --> 00:31:54,080
value of the result of the builder that

00:31:51,269 --> 00:31:56,100
is the termination point we have now

00:31:54,080 --> 00:32:00,169
transformed all the things in this

00:31:56,100 --> 00:32:01,970
iterable and here's the new collection

00:32:00,169 --> 00:32:05,759
does this make sense

00:32:01,970 --> 00:32:08,759
so the ACPs part of this is using flat

00:32:05,759 --> 00:32:13,019
map or or recover width to essentially

00:32:08,759 --> 00:32:18,600
recurse super powerful pattern once you

00:32:13,019 --> 00:32:20,820
once you once you get to use it so

00:32:18,600 --> 00:32:23,519
there's one problem that gets exposed by

00:32:20,820 --> 00:32:25,619
this kind of pattern and the solution is

00:32:23,519 --> 00:32:28,340
called root compression because if you

00:32:25,619 --> 00:32:31,340
have this sort of if you look at the

00:32:28,340 --> 00:32:33,350
of calling right so you have you return

00:32:31,340 --> 00:32:35,659
a future immediately right that's the

00:32:33,350 --> 00:32:37,100
point of the future construct to be able

00:32:35,659 --> 00:32:38,809
to return it immediately and doing the

00:32:37,100 --> 00:32:40,760
transformation asynchronously in the

00:32:38,809 --> 00:32:42,919
background it means that the first

00:32:40,760 --> 00:32:45,919
future that was returned will be

00:32:42,919 --> 00:32:47,809
completed last right after all the

00:32:45,919 --> 00:32:50,419
things are done that's when he gets

00:32:47,809 --> 00:32:53,990
completed so it creates this sort of

00:32:50,419 --> 00:32:56,029
chain of futures that don't have any

00:32:53,990 --> 00:33:00,169
value until the end and then you sort of

00:32:56,029 --> 00:33:03,289
unwind the the proverbial stack until it

00:33:00,169 --> 00:33:04,610
has the final result now there is an

00:33:03,289 --> 00:33:06,610
optimization technique called route

00:33:04,610 --> 00:33:10,370
compression that eliminates the

00:33:06,610 --> 00:33:12,950
intermediate results so when you

00:33:10,370 --> 00:33:15,350
complete the last future you complete

00:33:12,950 --> 00:33:16,940
the the primordial future immediately

00:33:15,350 --> 00:33:20,330
not going through all these other

00:33:16,940 --> 00:33:24,049
futures so that can save a lot of memory

00:33:20,330 --> 00:33:26,240
leaks and what's new in 212 is that

00:33:24,049 --> 00:33:28,279
since we have this transform with

00:33:26,240 --> 00:33:30,230
Combinator we can apply the route

00:33:28,279 --> 00:33:34,130
transformation for that specific thing

00:33:30,230 --> 00:33:35,990
so no matter if you mix flat map or

00:33:34,130 --> 00:33:38,090
recover with using this sort of async

00:33:35,990 --> 00:33:40,940
continuation passing style you'll you'll

00:33:38,090 --> 00:33:44,539
get the root compression built it so you

00:33:40,940 --> 00:33:55,330
don't have to worry about that make

00:33:44,539 --> 00:33:57,830
sense sort of issue not at all hello yes

00:33:55,330 --> 00:34:00,830
so sort of like Street fusion it's more

00:33:57,830 --> 00:34:02,960
like three fusion is more collapsing the

00:34:00,830 --> 00:34:07,820
the processing this is more collapsing

00:34:02,960 --> 00:34:11,349
the result creation so it's it's similar

00:34:07,820 --> 00:34:17,179
in in in spirit but not necessarily in

00:34:11,349 --> 00:34:19,849
execution some of the non system that I

00:34:17,179 --> 00:34:21,919
did find was there was no protection

00:34:19,849 --> 00:34:25,669
against trying to complete a promise

00:34:21,919 --> 00:34:28,339
with itself so that has been sort of

00:34:25,669 --> 00:34:33,290
quietly fixed that that doesn't make

00:34:28,339 --> 00:34:37,580
sense at all and something that I I

00:34:33,290 --> 00:34:41,030
think doesn't get the necessary praise /

00:34:37,580 --> 00:34:42,290
attention that it might might or

00:34:41,030 --> 00:34:44,690
probably should

00:34:42,290 --> 00:34:47,660
is the block context and I don't know if

00:34:44,690 --> 00:34:49,970
you've ever seen this it's sort of it's

00:34:47,660 --> 00:34:52,429
there but it you don't really

00:34:49,970 --> 00:34:56,060
necessarily see it unless you go looking

00:34:52,429 --> 00:34:59,150
for it so the block context is a means

00:34:56,060 --> 00:35:01,130
of letting the underlying thread pool

00:34:59,150 --> 00:35:02,870
know that all right we're going to

00:35:01,130 --> 00:35:05,540
attempt to do some blocking here and

00:35:02,870 --> 00:35:08,300
that is useful for many reasons one is

00:35:05,540 --> 00:35:10,070
debugging if I can install a block

00:35:08,300 --> 00:35:11,810
context that will print out before it

00:35:10,070 --> 00:35:13,670
tries to do any blocking it's much

00:35:11,810 --> 00:35:16,190
easier to find out whether some blocking

00:35:13,670 --> 00:35:18,710
was involved or not and this only works

00:35:16,190 --> 00:35:22,160
if you actually use the block context

00:35:18,710 --> 00:35:24,770
and the blocking construct here in the

00:35:22,160 --> 00:35:27,070
sub method which uses blocking and does

00:35:24,770 --> 00:35:29,840
the demarcation of the blocking section

00:35:27,070 --> 00:35:34,870
so you can wrap whatever blocking thing

00:35:29,840 --> 00:35:37,640
that you do in in the blocking block a

00:35:34,870 --> 00:35:39,710
lot of blocking I don't necessarily like

00:35:37,640 --> 00:35:45,620
blocking so it's it's it's this is

00:35:39,710 --> 00:35:50,870
painful so let's try and see what we can

00:35:45,620 --> 00:35:52,340
do with block context I have no idea if

00:35:50,870 --> 00:35:53,360
I'm running out of time or not but

00:35:52,340 --> 00:35:58,550
you're sitting here and you're not

00:35:53,360 --> 00:36:00,020
screaming so let's roll with it so let's

00:35:58,550 --> 00:36:03,230
say that we want to create our own block

00:36:00,020 --> 00:36:05,750
context it has this really peculiar

00:36:03,230 --> 00:36:08,780
looking method which is it's only method

00:36:05,750 --> 00:36:13,340
is called block on that takes a type

00:36:08,780 --> 00:36:15,710
parameter T and a thunk right a thunk

00:36:13,340 --> 00:36:18,440
that evaluates to T and it has this

00:36:15,710 --> 00:36:20,660
implicit permission to be able to awake

00:36:18,440 --> 00:36:23,270
and this is important because it

00:36:20,660 --> 00:36:25,820
prevents code from calling this method

00:36:23,270 --> 00:36:27,680
directly because you have to supply this

00:36:25,820 --> 00:36:31,040
sort of proof that you're allowed to

00:36:27,680 --> 00:36:34,940
block be sure of a adult supervision

00:36:31,040 --> 00:36:37,310
kind of thing but let's say that we

00:36:34,940 --> 00:36:42,610
wanted to install a block context that

00:36:37,310 --> 00:36:42,610
prevents blocking right

00:36:45,640 --> 00:36:53,039
so we create this future that will

00:36:49,390 --> 00:36:56,799
produce the the fantastic string pig-dog

00:36:53,039 --> 00:37:00,130
and we would like to wait for that

00:36:56,799 --> 00:37:03,779
future to be done for waiting 10 seconds

00:37:00,130 --> 00:37:06,519
and we have this sort of implicit global

00:37:03,779 --> 00:37:09,670
execution context so imagine that this

00:37:06,519 --> 00:37:12,339
piece of code is any library code or any

00:37:09,670 --> 00:37:13,960
other person's code or perhaps your code

00:37:12,339 --> 00:37:16,029
from six months ago does really matter

00:37:13,960 --> 00:37:19,029
what matters is that this doesn't

00:37:16,029 --> 00:37:21,430
necessarily deal with any of the block

00:37:19,029 --> 00:37:23,739
hunting stuff right the only thing we

00:37:21,430 --> 00:37:25,299
see is a wait result which is a very

00:37:23,739 --> 00:37:30,819
good API because it means that it's easy

00:37:25,299 --> 00:37:33,099
to disallow so if we wanted to install

00:37:30,819 --> 00:37:36,910
the block context that does not allow

00:37:33,099 --> 00:37:42,059
blocking right so we install this here

00:37:36,910 --> 00:37:44,769
oh this really does not wrap around well

00:37:42,059 --> 00:37:47,710
right we install this block context

00:37:44,769 --> 00:37:51,910
around the invocation to some API call

00:37:47,710 --> 00:37:53,380
right and if things work well it should

00:37:51,910 --> 00:37:59,739
produce this illegal State exception

00:37:53,380 --> 00:38:05,980
right are we are we okay with this so

00:37:59,739 --> 00:38:13,589
what should happen here right what

00:38:05,980 --> 00:38:13,589
should happen here all right

00:38:14,380 --> 00:38:18,940
so we don't allow blocking anymore we

00:38:17,380 --> 00:38:23,800
throw an exception before the code that

00:38:18,940 --> 00:38:25,690
does blocking so this allows us to do

00:38:23,800 --> 00:38:28,480
some very interesting things like the

00:38:25,690 --> 00:38:30,510
the the global execution context tries

00:38:28,480 --> 00:38:33,970
to compensate by creating more threats

00:38:30,510 --> 00:38:36,250
so before you do the blocking let me

00:38:33,970 --> 00:38:38,560
create a new thread so that the thread

00:38:36,250 --> 00:38:40,420
pool will remain alive or responsive

00:38:38,560 --> 00:38:41,680
while you're doing this blocking or you

00:38:40,420 --> 00:38:42,790
might want to do some logging or you

00:38:41,680 --> 00:38:46,930
might just want to prevent people from

00:38:42,790 --> 00:38:52,210
doing block the the possibility is our

00:38:46,930 --> 00:38:54,840
internet sort of all right so some

00:38:52,210 --> 00:38:57,400
things that most people are not aware of

00:38:54,840 --> 00:38:59,920
the global execution context it's

00:38:57,400 --> 00:39:04,090
actually configurable from the command

00:38:59,920 --> 00:39:06,370
line so there's this notion of minimum

00:39:04,090 --> 00:39:09,100
number of threads number of threads

00:39:06,370 --> 00:39:11,410
which is sort of the ideal number a max

00:39:09,100 --> 00:39:13,570
number of threats and a max number of

00:39:11,410 --> 00:39:15,760
extra threads and the extra threads are

00:39:13,570 --> 00:39:18,550
the threads that will sort of prevent

00:39:15,760 --> 00:39:20,590
the thread pool from starving if there

00:39:18,550 --> 00:39:22,900
is blocking so that's the max number of

00:39:20,590 --> 00:39:28,180
extra threads to keep the thread pool

00:39:22,900 --> 00:39:30,150
alive in case of walking and 4 to 12 the

00:39:28,180 --> 00:39:36,690
threads actually have sensible names

00:39:30,150 --> 00:39:43,600
that's pretty cool all right

00:39:36,690 --> 00:39:45,910
so given that 212 is for Java 8 you may

00:39:43,600 --> 00:39:49,110
want to consider using pork joint pools

00:39:45,910 --> 00:39:51,930
common pool because that's already there

00:39:49,110 --> 00:39:55,120
it's already being used and and sort of

00:39:51,930 --> 00:39:58,060
mind you that when the next execution

00:39:55,120 --> 00:40:00,700
context global was created we actually

00:39:58,060 --> 00:40:03,760
had our own sort of private Fork of Fork

00:40:00,700 --> 00:40:08,440
joint because there was no common pool

00:40:03,760 --> 00:40:11,500
at all one mistake that I very regularly

00:40:08,440 --> 00:40:13,810
see is that you create your own

00:40:11,500 --> 00:40:16,380
execution context rather than requiring

00:40:13,810 --> 00:40:19,270
from from your caller

00:40:16,380 --> 00:40:22,140
really require it from your caller

00:40:19,270 --> 00:40:25,660
because if you write your program

00:40:22,140 --> 00:40:27,100
quote-unquote correctly the only place

00:40:25,660 --> 00:40:28,090
in your code where you will have to

00:40:27,100 --> 00:40:30,370
specify an execute

00:40:28,090 --> 00:40:32,440
context is when you actually start your

00:40:30,370 --> 00:40:34,360
program because that will then be passed

00:40:32,440 --> 00:40:37,060
down to all the places where it's needed

00:40:34,360 --> 00:40:38,860
so please do that because otherwise

00:40:37,060 --> 00:40:40,660
there becomes like this proliferation of

00:40:38,860 --> 00:40:42,810
thread pools and it's really hard to

00:40:40,660 --> 00:40:45,130
figure out what's executing what and win

00:40:42,810 --> 00:40:46,900
so if you have your own execution

00:40:45,130 --> 00:40:48,910
context really have a good reason for

00:40:46,900 --> 00:40:51,070
having your own like I want to isolate

00:40:48,910 --> 00:40:52,860
this piece of my system from this other

00:40:51,070 --> 00:40:57,820
piece of my system that's a good reason

00:40:52,860 --> 00:41:00,660
but don't sort of create your own just

00:40:57,820 --> 00:41:00,660
for the sake of doing it

00:41:02,460 --> 00:41:11,620
remember think first I see this all the

00:41:09,880 --> 00:41:13,660
time and especially with concurrent and

00:41:11,620 --> 00:41:15,700
asynchronous programs it's well worth

00:41:13,660 --> 00:41:17,950
investing in thinking about the problem

00:41:15,700 --> 00:41:19,930
before we encode the solution because

00:41:17,950 --> 00:41:22,920
it's so much harder to debug concurrent

00:41:19,930 --> 00:41:26,710
code that was just sort of put together

00:41:22,920 --> 00:41:29,080
in a rush than to deal with something

00:41:26,710 --> 00:41:30,580
that was really thought out before so

00:41:29,080 --> 00:41:33,160
you won't really necessarily be able to

00:41:30,580 --> 00:41:38,860
solve your problem by just throwing code

00:41:33,160 --> 00:41:41,170
together so really for me skl of us a

00:41:38,860 --> 00:41:44,470
lot about having to think before you

00:41:41,170 --> 00:41:47,620
code and I think this is a really good

00:41:44,470 --> 00:41:50,260
thing and don't worry about not having

00:41:47,620 --> 00:41:52,210
written any line of code yet and it's

00:41:50,260 --> 00:41:54,370
been an hour because if you've thought

00:41:52,210 --> 00:41:55,750
about it you might actually not create

00:41:54,370 --> 00:42:00,340
lines of code that will create a problem

00:41:55,750 --> 00:42:05,440
with someone else or yourself and I

00:42:00,340 --> 00:42:11,080
pulled off a bacon v2 this is one of my

00:42:05,440 --> 00:42:17,200
better images that I've made I think I

00:42:11,080 --> 00:42:22,180
think this is this is historic so do you

00:42:17,200 --> 00:42:25,620
guys have any questions or do you feel

00:42:22,180 --> 00:42:25,620
like you have like a future overload

00:42:28,450 --> 00:42:35,700
you're completely mind blown or bored

00:42:32,770 --> 00:42:35,700
out of your minds

00:42:38,220 --> 00:42:48,340
yeah yes that's a really good comment so

00:42:45,670 --> 00:42:49,870
when you do a lot of work

00:42:48,340 --> 00:42:51,490
it doesn't really necessarily just have

00:42:49,870 --> 00:42:53,440
to do with doing future compasses or

00:42:51,490 --> 00:42:56,170
function composition but when you do a

00:42:53,440 --> 00:42:57,910
lot of work in one transformation you're

00:42:56,170 --> 00:43:01,080
essentially hogging a thread until

00:42:57,910 --> 00:43:04,390
you're done that's the trade-off between

00:43:01,080 --> 00:43:07,330
fairness by doing a lot of small stuff

00:43:04,390 --> 00:43:10,600
and letting other things run interleaved

00:43:07,330 --> 00:43:12,880
or being efficient and hopefully getting

00:43:10,600 --> 00:43:15,040
better throughput by doing things while

00:43:12,880 --> 00:43:17,200
you're doing it right I might just as

00:43:15,040 --> 00:43:18,790
well do more because I already have a CP

00:43:17,200 --> 00:43:22,120
and doing stuff but that's it that's a

00:43:18,790 --> 00:43:23,980
good comment and it's I think it's the

00:43:22,120 --> 00:43:29,170
same recommendation as with any code

00:43:23,980 --> 00:43:32,800
like try to keep logic to us a good sort

00:43:29,170 --> 00:43:35,650
of boundary or a sensible I think it's

00:43:32,800 --> 00:43:37,930
hard right it's it's about taste like

00:43:35,650 --> 00:43:39,490
having sensibly sized methods and

00:43:37,930 --> 00:43:42,850
functions and not really doing too much

00:43:39,490 --> 00:43:44,890
but at least that's easier to profile

00:43:42,850 --> 00:43:47,350
because you know what's running you can

00:43:44,890 --> 00:43:49,620
expect what's running but yeah it is a

00:43:47,350 --> 00:43:57,660
trade-off between sort of fairness and

00:43:49,620 --> 00:43:57,660
throughput cool all right

00:44:09,630 --> 00:44:20,260
so what are good resources to learn more

00:44:12,640 --> 00:44:24,220
about futures um I don't want to sort of

00:44:20,260 --> 00:44:26,800
promote myself too much but I have done

00:44:24,220 --> 00:44:29,500
a lot of future talks so some of them

00:44:26,800 --> 00:44:32,890
can be useful there is a blog series

00:44:29,500 --> 00:44:34,869
about the changes to future into twelve

00:44:32,890 --> 00:44:39,640
that you might want to look into what

00:44:34,869 --> 00:44:41,140
for reference I have promised myself but

00:44:39,640 --> 00:44:44,109
I won't make any promises for anyone

00:44:41,140 --> 00:44:48,450
else to to make the documentation even

00:44:44,109 --> 00:44:51,910
better in general though I feel like

00:44:48,450 --> 00:44:53,830
there's really not that much to learn

00:44:51,910 --> 00:44:57,099
about futures themselves but it's sort

00:44:53,830 --> 00:44:59,740
of incidental things around it a really

00:44:57,099 --> 00:45:01,420
common case that I see is the creation

00:44:59,740 --> 00:45:03,520
of futures in for comprehension and

00:45:01,420 --> 00:45:06,520
being surprised that they run not

00:45:03,520 --> 00:45:08,650
sequentially but triggered sequentially

00:45:06,520 --> 00:45:11,560
because monad comprehensions are

00:45:08,650 --> 00:45:15,330
essentially sequence sequential

00:45:11,560 --> 00:45:18,520
operations so whenever you want to do

00:45:15,330 --> 00:45:20,589
start futures or start computations in

00:45:18,520 --> 00:45:24,400
parallel you want to lift that outside

00:45:20,589 --> 00:45:30,940
of you for comprehension all right

00:45:24,400 --> 00:45:33,430
anything else yes is there a plan to

00:45:30,940 --> 00:45:35,800
implement tasks in Scala that's a really

00:45:33,430 --> 00:45:39,670
good question so personally I would love

00:45:35,800 --> 00:45:41,230
to have a task like functionality I

00:45:39,670 --> 00:45:44,770
think they complement each other very

00:45:41,230 --> 00:45:46,510
well so task is essentially staging it's

00:45:44,770 --> 00:45:49,359
a lifted representation of a workflow

00:45:46,510 --> 00:45:52,570
and I think they are really

00:45:49,359 --> 00:45:54,280
complementary so you could use a task to

00:45:52,570 --> 00:45:56,710
produce a value in the future that you

00:45:54,280 --> 00:45:59,800
could then expose to others because task

00:45:56,710 --> 00:46:01,480
is is not memorized so everybody who

00:45:59,800 --> 00:46:04,000
wants the result of the task needs to

00:46:01,480 --> 00:46:06,580
evaluate the task so I think they have

00:46:04,000 --> 00:46:08,650
really sort of complementary value and I

00:46:06,580 --> 00:46:11,530
would love to see I would love to see

00:46:08,650 --> 00:46:16,020
somebody propose something for that I

00:46:11,530 --> 00:46:16,020
think that would be very interesting yes

00:46:24,490 --> 00:46:27,570
to do what

00:46:32,850 --> 00:46:38,110
yeah and I think that's a good question

00:46:35,080 --> 00:46:40,119
so that comes up quite a bit so how do I

00:46:38,110 --> 00:46:42,040
know what to choose in terms of the

00:46:40,119 --> 00:46:46,270
abstraction to use for different things

00:46:42,040 --> 00:46:50,410
and for me futures are good because they

00:46:46,270 --> 00:46:52,450
are they have very sort of strict

00:46:50,410 --> 00:46:54,310
separation between the concerns of

00:46:52,450 --> 00:46:56,350
producing a value and consuming a value

00:46:54,310 --> 00:46:59,590
which I which I find nice

00:46:56,350 --> 00:47:01,090
they have very clean semantics they

00:46:59,590 --> 00:47:02,380
interoperate with a lot of things

00:47:01,090 --> 00:47:06,930
because they are sort of monadic in

00:47:02,380 --> 00:47:10,840
nature I think as long as you can have

00:47:06,930 --> 00:47:12,460
single sort of propagation futures are

00:47:10,840 --> 00:47:16,140
good but once you need to go into a

00:47:12,460 --> 00:47:19,390
streaming context using something like

00:47:16,140 --> 00:47:21,280
FST or rx Java or ARCA streams or

00:47:19,390 --> 00:47:24,700
something that is designed for for

00:47:21,280 --> 00:47:27,340
multiple values that come in

00:47:24,700 --> 00:47:30,369
asynchronously but these tend to really

00:47:27,340 --> 00:47:31,930
complement each other well so you use it

00:47:30,369 --> 00:47:33,910
something for some task and then you

00:47:31,930 --> 00:47:36,250
produce a future for something else and

00:47:33,910 --> 00:47:40,690
then you might go back and use that for

00:47:36,250 --> 00:47:43,320
something else I see I see a lot of

00:47:40,690 --> 00:47:46,570
usage of future that I didn't anticipate

00:47:43,320 --> 00:47:47,170
so like using future as a very good

00:47:46,570 --> 00:47:49,359
serve

00:47:47,170 --> 00:47:51,609
very good a very common default thing to

00:47:49,359 --> 00:47:53,350
do like we do it in a future because

00:47:51,609 --> 00:47:55,000
it's async and that we will be able to

00:47:53,350 --> 00:47:59,410
sort of scale it out using a thread pool

00:47:55,000 --> 00:48:03,040
and stuff like that so nothing should be

00:47:59,410 --> 00:48:05,170
overused and you really don't know what

00:48:03,040 --> 00:48:07,869
the right thing is until you have your

00:48:05,170 --> 00:48:10,990
sort of your requirements sort of more

00:48:07,869 --> 00:48:13,980
specified so it's it's hard to give like

00:48:10,990 --> 00:48:17,080
a blanket recommendation for stuff but

00:48:13,980 --> 00:48:20,220
at least the abstractions we have today

00:48:17,080 --> 00:48:23,619
are very much more user-friendly than

00:48:20,220 --> 00:48:26,260
let's say locks or semaphore sand and

00:48:23,619 --> 00:48:27,730
doing sort of stuff like that I feel

00:48:26,260 --> 00:48:33,790
feel like this is a good sort of end

00:48:27,730 --> 00:48:38,520
user API all right I'll be around so

00:48:33,790 --> 00:48:41,020
don't be a stranger let me know what you

00:48:38,520 --> 00:48:46,420
what you like about futures and what you

00:48:41,020 --> 00:48:48,510
don't like where your war stories thank

00:48:46,420 --> 00:48:48,510

YouTube URL: https://www.youtube.com/watch?v=K9lt6yjuzbM


