Title: Async Testing on the JVM and Scala.js - by Bill Venners
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
In ScalaTest 3.0's new async testing styles, tests have a result type of Future[Assertion]. Instead of blocking until a future completes, then performing assertions on the result, you map assertions onto the future and return the resulting Future[Assertion] to ScalaTest. The test will complete asynchronously when the Future[Assertion] completes. This non-blocking way of testing requires a very different mindset and different API. In this talk, Bill Venners will show you how async testing was integrated into ScalaTest and explain what motivated the design decisions. He'll show you how to use the new features, and suggest best practices for async testing on both the JVM and Scala.js.
Captions: 
	00:00:01,160 --> 00:00:06,229
this is about acing testing on the JVM

00:00:03,770 --> 00:00:08,600
on Innsmouth scala test on the JVM and

00:00:06,229 --> 00:00:13,690
scala jas it's something new in scale

00:00:08,600 --> 00:00:17,210
test 30 and 30 is on its way out i

00:00:13,690 --> 00:00:19,010
released RC 1 2 days ago before the

00:00:17,210 --> 00:00:20,330
conference started but did not put it up

00:00:19,010 --> 00:00:23,150
on the website yet because i didn't get

00:00:20,330 --> 00:00:25,250
time to get the scala doc out so that

00:00:23,150 --> 00:00:26,090
will come out in the next few days and i

00:00:25,250 --> 00:00:28,340
just wanted to give you a little preview

00:00:26,090 --> 00:00:32,360
of what i'm going to talk about these

00:00:28,340 --> 00:00:34,250
four functions i'm going to cover so the

00:00:32,360 --> 00:00:36,620
first one is actually JVM the platform

00:00:34,250 --> 00:00:40,129
before i get into a sink testing I want

00:00:36,620 --> 00:00:44,870
to kind of sit back a second and give it

00:00:40,129 --> 00:00:46,850
put into context what happened over a

00:00:44,870 --> 00:00:49,850
year ago as we decided to support Scala

00:00:46,850 --> 00:00:51,410
j/s so that you could use you can write

00:00:49,850 --> 00:00:53,449
tests in Scala tests to have them run on

00:00:51,410 --> 00:00:55,760
the JVM and have the same test run on on

00:00:53,449 --> 00:00:58,039
scala jes if that's what your your

00:00:55,760 --> 00:01:00,050
project does right so you have one full

00:00:58,039 --> 00:01:01,850
featured test framework that can be used

00:01:00,050 --> 00:01:04,970
on both and we thought it would take

00:01:01,850 --> 00:01:08,890
nine days it took its well it took over

00:01:04,970 --> 00:01:11,660
a year and the reason is because when i

00:01:08,890 --> 00:01:17,240
first wrote scala test and over the

00:01:11,660 --> 00:01:19,490
years our team has been doing it and it

00:01:17,240 --> 00:01:21,710
was always really up on the JVM so it

00:01:19,490 --> 00:01:24,320
was very tied to the JVM and that's why

00:01:21,710 --> 00:01:25,580
it was so hard this first function is I

00:01:24,320 --> 00:01:28,370
think kind of representative of what's

00:01:25,580 --> 00:01:31,580
happened to scala lately is that it's

00:01:28,370 --> 00:01:33,680
it's less well I mean it's still very

00:01:31,580 --> 00:01:36,440
focused on the JVM because that's how it

00:01:33,680 --> 00:01:38,030
started but now it runs on JavaScript

00:01:36,440 --> 00:01:39,650
and the previous hour there was a talk

00:01:38,030 --> 00:01:42,380
on Scala native right so it's now kind

00:01:39,650 --> 00:01:44,390
of being compiled to other targets so

00:01:42,380 --> 00:01:46,640
it's you write things differently if

00:01:44,390 --> 00:01:49,070
that's what it is right if you're trying

00:01:46,640 --> 00:01:51,800
to write libraries for it anyway and so

00:01:49,070 --> 00:01:55,370
a lot of what took so much time is DJ

00:01:51,800 --> 00:01:57,950
Emma fine JM specific defying I can use

00:01:55,370 --> 00:02:02,600
that as a verb skull tests sort code

00:01:57,950 --> 00:02:05,660
base ok so to kind of give you an

00:02:02,600 --> 00:02:07,100
example of what the problem was this is

00:02:05,660 --> 00:02:10,250
anybody well I was going to say is

00:02:07,100 --> 00:02:11,900
anybody know what API beds from sorry

00:02:10,250 --> 00:02:12,890
but you guys are so smart ok and then I

00:02:11,900 --> 00:02:14,049
realized I wrote it up there in a

00:02:12,890 --> 00:02:18,560
comment

00:02:14,049 --> 00:02:21,829
that is how you handle a request in java

00:02:18,560 --> 00:02:24,260
servlets from years ago 1990s and what

00:02:21,829 --> 00:02:28,879
you get when a request comes in from a

00:02:24,260 --> 00:02:30,349
client a browser is a this method is

00:02:28,879 --> 00:02:31,700
invoked you implement this method you

00:02:30,349 --> 00:02:33,680
get a request object that has

00:02:31,700 --> 00:02:35,090
information about the request and you

00:02:33,680 --> 00:02:37,879
get a response object which is kind of

00:02:35,090 --> 00:02:40,849
like a a wrapper around a socket so what

00:02:37,879 --> 00:02:42,409
you do is you look at the information in

00:02:40,849 --> 00:02:44,510
the request and then you just interact

00:02:42,409 --> 00:02:48,620
with the client through the socket

00:02:44,510 --> 00:02:52,639
essentially and then when do get returns

00:02:48,620 --> 00:02:54,829
the request response has finished so you

00:02:52,639 --> 00:02:56,180
would actually not return until it's

00:02:54,829 --> 00:02:59,000
finished so if you had to do something

00:02:56,180 --> 00:03:01,549
across an internal network like access a

00:02:59,000 --> 00:03:04,459
database that may take time T you have

00:03:01,549 --> 00:03:07,310
to have that thread block right so

00:03:04,459 --> 00:03:08,720
that's a not the best use of resources

00:03:07,310 --> 00:03:10,519
back in the early days of web maybe is

00:03:08,720 --> 00:03:11,900
ok but now there's a lot more traffic

00:03:10,519 --> 00:03:13,939
coming in and people need to scale more

00:03:11,900 --> 00:03:16,159
and I'm starting to sound like a

00:03:13,939 --> 00:03:19,599
reactive marketing talk but essentially

00:03:16,159 --> 00:03:22,519
that's the idea of like play and spray

00:03:19,599 --> 00:03:24,709
what they did differently is it is they

00:03:22,519 --> 00:03:27,169
try to get rid of blocking the need to

00:03:24,709 --> 00:03:29,120
block so the API is different and you

00:03:27,169 --> 00:03:33,230
can actually block if you want in play

00:03:29,120 --> 00:03:35,480
this is a play example and so what I did

00:03:33,230 --> 00:03:37,400
is I have some intensive consultation

00:03:35,480 --> 00:03:39,560
that maybe it's out on a network

00:03:37,400 --> 00:03:44,090
internal network or something it gives

00:03:39,560 --> 00:03:46,579
me back a future int so I can block on

00:03:44,090 --> 00:03:48,409
that future and then when it finishes

00:03:46,579 --> 00:03:49,760
i'll get an int back right and then i

00:03:48,409 --> 00:03:51,260
can return that to the client that's

00:03:49,760 --> 00:03:54,440
what that that's what how you do that

00:03:51,260 --> 00:03:58,069
that's very uneasy matic in play what

00:03:54,440 --> 00:04:02,510
you would normally do is actually map

00:03:58,069 --> 00:04:05,150
your response on to the future int and

00:04:02,510 --> 00:04:07,510
now you get a future response and you

00:04:05,150 --> 00:04:10,669
just return that future response to play

00:04:07,510 --> 00:04:11,930
so you hopefully uh have seen that kind

00:04:10,669 --> 00:04:16,519
of thing before that's sort of the cool

00:04:11,930 --> 00:04:21,739
way to do it and I was teaching the the

00:04:16,519 --> 00:04:25,969
play course a couple years ago and what

00:04:21,739 --> 00:04:27,020
everybody had says is you should never

00:04:25,969 --> 00:04:29,000
block

00:04:27,020 --> 00:04:32,240
in your production code it's okay to

00:04:29,000 --> 00:04:34,280
block in tests and I think there are it

00:04:32,240 --> 00:04:36,440
is different and it there are actually

00:04:34,280 --> 00:04:38,569
reasons for blocking your tests like

00:04:36,440 --> 00:04:39,949
it's not the same problem you're not

00:04:38,569 --> 00:04:41,990
trying to necessarily make maximum use

00:04:39,949 --> 00:04:43,280
of your resources because it doesn't

00:04:41,990 --> 00:04:45,319
cost you that much to have you know

00:04:43,280 --> 00:04:47,509
usually just have a most people just

00:04:45,319 --> 00:04:48,680
have a CI right it doesn't matter how

00:04:47,509 --> 00:04:52,009
long it takes that live weight or

00:04:48,680 --> 00:04:54,620
whatever and if you have too many things

00:04:52,009 --> 00:04:56,120
going at once then tests can timeout and

00:04:54,620 --> 00:04:58,039
you end up with test failure so there's

00:04:56,120 --> 00:05:00,110
some use for blocking but I got to

00:04:58,039 --> 00:05:02,120
wondering if you know why is it okay to

00:05:00,110 --> 00:05:04,810
block in your tests that was sort of the

00:05:02,120 --> 00:05:07,849
idea that popped in my head if you can

00:05:04,810 --> 00:05:09,650
return a future response to a web

00:05:07,849 --> 00:05:12,620
framework why can't you return a future

00:05:09,650 --> 00:05:15,740
assertion to a test framework so it

00:05:12,620 --> 00:05:18,860
would look like this so instead of doing

00:05:15,740 --> 00:05:20,539
this blocking call on the future getting

00:05:18,860 --> 00:05:23,150
the result back and then asserting and

00:05:20,539 --> 00:05:25,819
being finished you just map the

00:05:23,150 --> 00:05:28,129
assertion onto the future that you have

00:05:25,819 --> 00:05:31,159
in your hand it's very much like like

00:05:28,129 --> 00:05:34,190
plays math being a response okay so I

00:05:31,159 --> 00:05:37,009
thought that was mildly interesting but

00:05:34,190 --> 00:05:39,199
I didn't I was not at all convinced it

00:05:37,009 --> 00:05:40,789
was useful and and and if something's

00:05:39,199 --> 00:05:41,930
not useful I don't want to put it in the

00:05:40,789 --> 00:05:44,120
library because the library is already

00:05:41,930 --> 00:05:48,169
too big it's got a lot of stuff in it so

00:05:44,120 --> 00:05:52,639
everything has to be worth it right to

00:05:48,169 --> 00:05:55,099
put it in and then when we're about five

00:05:52,639 --> 00:05:56,210
months into scholars is poor thinking

00:05:55,099 --> 00:05:58,550
that was gonna take nine weeks but now

00:05:56,210 --> 00:06:00,370
we thank oh my god we thought was going

00:05:58,550 --> 00:06:06,169
to take nine weeks it took five months

00:06:00,370 --> 00:06:09,469
we got this issue which is a this

00:06:06,169 --> 00:06:13,219
doesn't work it time it fails and the

00:06:09,469 --> 00:06:14,599
reason is is we didn't so let me let me

00:06:13,219 --> 00:06:16,909
back up a second like one of the ways

00:06:14,599 --> 00:06:18,590
that the job javascript is different

00:06:16,909 --> 00:06:20,750
than the jb m is javascript is kind of

00:06:18,590 --> 00:06:23,960
like a WT or swing where there's just

00:06:20,750 --> 00:06:25,729
one thread that does things if there's

00:06:23,960 --> 00:06:27,979
just one thread in javascript going

00:06:25,729 --> 00:06:31,069
around in circles and it has a do list

00:06:27,979 --> 00:06:33,169
it's got a job queue and it'll go around

00:06:31,069 --> 00:06:34,580
and it'll pick up the next job it'll do

00:06:33,169 --> 00:06:36,469
it then they'll pick up the next job

00:06:34,580 --> 00:06:37,759
I'll do it that's all it ever does right

00:06:36,469 --> 00:06:39,649
so you really can't have anything

00:06:37,759 --> 00:06:40,670
multi-threaded in JavaScript so that's

00:06:39,649 --> 00:06:42,500
why I thought I was

00:06:40,670 --> 00:06:45,500
kind of naive about JavaScript I was a

00:06:42,500 --> 00:06:46,910
Java person and I just didn't have

00:06:45,500 --> 00:06:48,320
experience so I thought well we don't

00:06:46,910 --> 00:06:51,440
have to worry about it anything

00:06:48,320 --> 00:06:53,630
multi-threaded right but what you can do

00:06:51,440 --> 00:06:57,050
in javascript is call outside of the

00:06:53,630 --> 00:07:00,470
javascript vm and now you're in the land

00:06:57,050 --> 00:07:01,670
of c code or java code which does have

00:07:00,470 --> 00:07:04,550
multiple threads so you can actually

00:07:01,670 --> 00:07:06,200
call an API that outside the JavaScript

00:07:04,550 --> 00:07:08,270
I mean that one of the jobs that that

00:07:06,200 --> 00:07:09,920
JavaScript thread can do is call outside

00:07:08,270 --> 00:07:12,170
and now you can have another thread

00:07:09,920 --> 00:07:15,050
doing something asynchronously while

00:07:12,170 --> 00:07:16,790
this continues and then when it finishes

00:07:15,050 --> 00:07:19,160
it'll stick something at the end of the

00:07:16,790 --> 00:07:21,050
the job list right so there is actually

00:07:19,160 --> 00:07:22,790
ways to do things a sink and that's what

00:07:21,050 --> 00:07:25,250
this call to sample service that get

00:07:22,790 --> 00:07:28,510
data was doing is it went outside the vm

00:07:25,250 --> 00:07:30,650
i mean outside of javascript so

00:07:28,510 --> 00:07:32,450
basically what happens is immediately

00:07:30,650 --> 00:07:35,450
this assertion happens but it didn't

00:07:32,450 --> 00:07:38,180
complete yet right and future value we

00:07:35,450 --> 00:07:39,590
did port it because if you use if you're

00:07:38,180 --> 00:07:48,440
not calling outside the jail of the

00:07:39,590 --> 00:07:50,450
javascript p.m. and you use the run and

00:07:48,440 --> 00:07:53,420
now execution context in JavaScript this

00:07:50,450 --> 00:07:55,580
will actually work so i wanted to port

00:07:53,420 --> 00:07:57,140
have as many things work on the JVM and

00:07:55,580 --> 00:07:58,940
javascript is you could so that there's

00:07:57,140 --> 00:08:01,400
more code that we could use to work on

00:07:58,940 --> 00:08:04,040
both right but on the JVM future value

00:08:01,400 --> 00:08:05,990
blocks so on JavaScript can't block so

00:08:04,040 --> 00:08:07,400
it has already be finished right so

00:08:05,990 --> 00:08:08,960
until this person posted this we just

00:08:07,400 --> 00:08:10,100
thought it always would be because we

00:08:08,960 --> 00:08:11,600
didn't have the imagination to think

00:08:10,100 --> 00:08:14,720
people could call outside which is

00:08:11,600 --> 00:08:16,850
pretty basic but anyway when I looked at

00:08:14,720 --> 00:08:21,470
that I realized the only way to fix that

00:08:16,850 --> 00:08:24,260
was this we have to we can't block on

00:08:21,470 --> 00:08:25,670
JavaScript there's no way to block you

00:08:24,260 --> 00:08:27,350
don't have the choice so you have to

00:08:25,670 --> 00:08:29,660
return a future assertion to the

00:08:27,350 --> 00:08:30,890
framework on JavaScript and because we

00:08:29,660 --> 00:08:34,070
wanted to work on you know the same on

00:08:30,890 --> 00:08:36,890
both we either don't supports college is

00:08:34,070 --> 00:08:38,240
or we implement this some kind of a sink

00:08:36,890 --> 00:08:39,530
testing so that's that was sort of what

00:08:38,240 --> 00:08:41,360
this talk is about is how we got that in

00:08:39,530 --> 00:08:42,380
that took another six months and that

00:08:41,360 --> 00:08:43,880
wasn't the end of story there were other

00:08:42,380 --> 00:08:45,320
things we have other major overhauls we

00:08:43,880 --> 00:08:49,480
had to do just to finally get through

00:08:45,320 --> 00:08:52,130
this process of unjam fiying Scala test

00:08:49,480 --> 00:08:54,320
so just to give you a little bit of

00:08:52,130 --> 00:08:56,990
background before I get into a sink

00:08:54,320 --> 00:08:59,600
this is a ADT in Scala test that

00:08:56,990 --> 00:09:01,880
represents the result of a test it's an

00:08:59,600 --> 00:09:03,440
acting no test has an outcome and it's

00:09:01,880 --> 00:09:05,270
either succeeded which is a singleton

00:09:03,440 --> 00:09:08,210
object there's no information if a test

00:09:05,270 --> 00:09:09,740
succeeds you don't care usually what you

00:09:08,210 --> 00:09:11,180
don't usually care anything to know

00:09:09,740 --> 00:09:13,670
about it just that it succeeded and

00:09:11,180 --> 00:09:15,800
didn't fail if it's pending we also had

00:09:13,670 --> 00:09:17,180
just a sink with an object that means it

00:09:15,800 --> 00:09:19,610
hasn't been implemented yet or the code

00:09:17,180 --> 00:09:22,190
it tests hasn't been implemented yet but

00:09:19,610 --> 00:09:24,590
failed or cancelled has an exception

00:09:22,190 --> 00:09:26,180
inside of it because that's where

00:09:24,590 --> 00:09:27,620
actually you do want information and

00:09:26,180 --> 00:09:28,850
what you want is a stack trace to show

00:09:27,620 --> 00:09:30,230
you how you got there and what the

00:09:28,850 --> 00:09:31,880
problem was a little hint of what the

00:09:30,230 --> 00:09:36,110
problem was like one did not equal to or

00:09:31,880 --> 00:09:37,730
something and that's called outcome and

00:09:36,110 --> 00:09:41,360
then there's a method called with

00:09:37,730 --> 00:09:43,820
fixture which you can you inherit from

00:09:41,360 --> 00:09:45,140
sweet so it's in every test class it's a

00:09:43,820 --> 00:09:48,500
lifecycle method that you can override

00:09:45,140 --> 00:09:53,120
to do something with a test function so

00:09:48,500 --> 00:09:55,340
this test empty prins rocket outcome is

00:09:53,120 --> 00:09:58,820
the test function it gets passed into

00:09:55,340 --> 00:10:01,490
with fixture and then you could do for

00:09:58,820 --> 00:10:03,140
example some setup before invoking the

00:10:01,490 --> 00:10:05,330
test function in a try and then finally

00:10:03,140 --> 00:10:07,670
do the cleanup right so in the setup you

00:10:05,330 --> 00:10:09,590
could put some stuff in the database and

00:10:07,670 --> 00:10:12,380
then finally you could clean it out

00:10:09,590 --> 00:10:13,940
right or you can do other things you can

00:10:12,380 --> 00:10:15,650
actually change the outcome because the

00:10:13,940 --> 00:10:17,570
you know test returns an outcome and so

00:10:15,650 --> 00:10:19,160
it is with fixture so you could like

00:10:17,570 --> 00:10:20,690
catch something that's flickering and

00:10:19,160 --> 00:10:23,030
saying well let's try it one more time

00:10:20,690 --> 00:10:24,350
if it if it doesn't flicker that time

00:10:23,030 --> 00:10:26,510
we'll call it cancelled instead of

00:10:24,350 --> 00:10:27,530
failed or something like that right so

00:10:26,510 --> 00:10:32,000
there's all kinds of stuffs you can do

00:10:27,530 --> 00:10:33,500
and with fixture but you need to tell me

00:10:32,000 --> 00:10:35,060
the idea is that with fixture has to

00:10:33,500 --> 00:10:36,980
invoke the test function so the default

00:10:35,060 --> 00:10:39,620
implementation does so what I have

00:10:36,980 --> 00:10:42,290
recommended in the scholar doc is that

00:10:39,620 --> 00:10:45,740
you actually do this which is calling

00:10:42,290 --> 00:10:48,020
the superclass implementation and having

00:10:45,740 --> 00:10:49,490
and delegating to it to invoke the test

00:10:48,020 --> 00:10:52,550
function so super dealt with fix your

00:10:49,490 --> 00:10:54,260
test is your calling your super class

00:10:52,550 --> 00:10:56,630
implementation with fix your passing the

00:10:54,260 --> 00:10:58,400
test function up to hit and the last one

00:10:56,630 --> 00:11:00,200
the default one in suite just invokes it

00:10:58,400 --> 00:11:01,310
right so it'll always get invoked but

00:11:00,200 --> 00:11:03,500
that way you could stack several these

00:11:01,310 --> 00:11:04,760
behaviors and so one effect will happen

00:11:03,500 --> 00:11:06,140
the other effects will happen in it'll

00:11:04,760 --> 00:11:10,070
bill unhappen

00:11:06,140 --> 00:11:13,070
the reverse order right so that's two

00:11:10,070 --> 00:11:14,870
nuts in skala test two and then usually

00:11:13,070 --> 00:11:16,400
people just override that in their test

00:11:14,870 --> 00:11:18,470
class but occasionally if you have the

00:11:16,400 --> 00:11:20,660
same with fixture implementation in

00:11:18,470 --> 00:11:23,060
multiple test classes what you would do

00:11:20,660 --> 00:11:28,000
is factor it out into a mix int rate and

00:11:23,060 --> 00:11:30,440
then just mix in that mix in trait so

00:11:28,000 --> 00:11:32,780
this one is actually in Scala test and

00:11:30,440 --> 00:11:36,380
so I say abstract override with fixture

00:11:32,780 --> 00:11:37,820
and then I here I said super with

00:11:36,380 --> 00:11:39,020
fixture test that's delegating to the

00:11:37,820 --> 00:11:41,300
super class and then we do something

00:11:39,020 --> 00:11:43,550
with the outcome here on this one but

00:11:41,300 --> 00:11:45,530
the point is what you do when you do

00:11:43,550 --> 00:11:46,910
this is you extend sweet mix n which is

00:11:45,530 --> 00:11:48,530
a bunch of abstract methods for life

00:11:46,910 --> 00:11:50,630
cycle methods and you have your self

00:11:48,530 --> 00:11:54,530
type be sweet that's call it this too

00:11:50,630 --> 00:11:57,140
okay so the summary of the the situation

00:11:54,530 --> 00:11:59,030
that we faced was users can define with

00:11:57,140 --> 00:12:01,010
fixture methods and lots of people have

00:11:59,030 --> 00:12:03,980
so that's existing code and you can

00:12:01,010 --> 00:12:05,930
compose them by stacking treats people

00:12:03,980 --> 00:12:08,030
call super with fixture tests and they

00:12:05,930 --> 00:12:09,500
have done that and here was the real

00:12:08,030 --> 00:12:11,300
problem it's it was kind of like the

00:12:09,500 --> 00:12:17,120
survey lady pie I'm gonna back up and

00:12:11,300 --> 00:12:18,620
show you the by the types the test is

00:12:17,120 --> 00:12:21,140
already finished when with fix your

00:12:18,620 --> 00:12:22,610
returns right so because with fiction

00:12:21,140 --> 00:12:25,340
returns an outcome it's either succeeded

00:12:22,610 --> 00:12:27,110
failed Council printing already right so

00:12:25,340 --> 00:12:28,700
that doesn't work for a sink because it

00:12:27,110 --> 00:12:30,500
hasn't necessarily finished yet you have

00:12:28,700 --> 00:12:33,200
a future assertion coming out of the

00:12:30,500 --> 00:12:35,660
test body how do we get an outcome you

00:12:33,200 --> 00:12:37,550
would have to block right so that was

00:12:35,660 --> 00:12:40,720
one of the big problems how do we do

00:12:37,550 --> 00:12:43,070
that so the first thing I did is I

00:12:40,720 --> 00:12:44,480
didn't like like it's a future what

00:12:43,070 --> 00:12:49,280
right if you if you map an assertion

00:12:44,480 --> 00:12:51,260
onto a test you get a future what I mean

00:12:49,280 --> 00:12:54,410
in in play you get a future response

00:12:51,260 --> 00:12:55,910
right so I wanted to be able to I want

00:12:54,410 --> 00:12:58,250
it to be a future assertion because

00:12:55,910 --> 00:13:00,560
that's what it is conceptually so I'm

00:12:58,250 --> 00:13:04,880
actually made a type alias called

00:13:00,560 --> 00:13:07,990
assertion that is just the singleton

00:13:04,880 --> 00:13:11,030
type of succeeded so what if you have

00:13:07,990 --> 00:13:12,830
anything of type assertion it has to be

00:13:11,030 --> 00:13:15,200
typed it has to be the succeeded

00:13:12,830 --> 00:13:17,900
singleton so that's the only possible

00:13:15,200 --> 00:13:19,790
value of that so a cert and match your

00:13:17,900 --> 00:13:24,530
actually now return that so if this I

00:13:19,790 --> 00:13:25,880
can get this demo to work oh I think I

00:13:24,530 --> 00:13:32,600
forgot to see projects collet else that

00:13:25,880 --> 00:13:35,180
would be better just to console okay

00:13:32,600 --> 00:13:39,950
that way so if i say assert let's say

00:13:35,180 --> 00:13:42,560
Val x equals 1 a third x equals 2 you

00:13:39,950 --> 00:13:44,630
still get the same behavior it well when

00:13:42,560 --> 00:13:48,550
it assertion fails it throws in at the

00:13:44,630 --> 00:13:51,110
same exception right so that's the same

00:13:48,550 --> 00:13:53,330
but if it succeeds it instead of

00:13:51,110 --> 00:13:55,070
returning unit singleton now he returns

00:13:53,330 --> 00:13:56,630
succeeded singleton and it has type

00:13:55,070 --> 00:13:58,910
assertion see it's org scale test

00:13:56,630 --> 00:14:02,090
assertion and then the same thing with

00:13:58,910 --> 00:14:03,890
mattress i could say X should equal to

00:14:02,090 --> 00:14:07,040
and it gives me the same exception it

00:14:03,890 --> 00:14:09,530
did before but if it passes it instead

00:14:07,040 --> 00:14:11,060
of returning the unit singleton unit

00:14:09,530 --> 00:14:12,980
value it returns to succeed is single

00:14:11,060 --> 00:14:15,800
and the reason for that is couple things

00:14:12,980 --> 00:14:17,120
but it was really motivated by I don't

00:14:15,800 --> 00:14:19,970
want it to be future units or feature

00:14:17,120 --> 00:14:21,820
any and really the type of assertion in

00:14:19,970 --> 00:14:26,180
Scala test 1 and 2 where he was unit

00:14:21,820 --> 00:14:28,280
because it's unit testing I guess so

00:14:26,180 --> 00:14:29,990
there was really it was just I didn't

00:14:28,280 --> 00:14:32,060
know any better and that's what I did it

00:14:29,990 --> 00:14:34,250
was simple to what J unit did so now its

00:14:32,060 --> 00:14:36,530
type assertion and it means succeeded so

00:14:34,250 --> 00:14:39,350
that's first thing and then we what we

00:14:36,530 --> 00:14:42,290
did is we made a set and more boy

00:14:39,350 --> 00:14:45,350
basically we added bloat so for every

00:14:42,290 --> 00:14:47,510
style trade for not for everyone but for

00:14:45,350 --> 00:14:50,540
most of them like fun sweet there's now

00:14:47,510 --> 00:14:53,960
an async fun sweet for fun spec there's

00:14:50,540 --> 00:14:55,310
an async funds back so what the

00:14:53,960 --> 00:14:59,450
difference is is they're exactly the

00:14:55,310 --> 00:15:03,350
same except the type of a test in a sink

00:14:59,450 --> 00:15:07,100
x is future assertion so you have to end

00:15:03,350 --> 00:15:10,280
it with a future assertion exactly so

00:15:07,100 --> 00:15:12,290
this this person who shaundra code a her

00:15:10,280 --> 00:15:15,190
code who submitted that issue this how

00:15:12,290 --> 00:15:18,260
he'd fix his class and we fixed that in

00:15:15,190 --> 00:15:19,990
well we fixed a long time ago but I've

00:15:18,260 --> 00:15:22,520
now put our she went up there already so

00:15:19,990 --> 00:15:24,770
that's what how you do it today is you

00:15:22,520 --> 00:15:26,900
you just grab the future this is in on

00:15:24,770 --> 00:15:29,000
JavaScript that is root truly a sink but

00:15:26,900 --> 00:15:30,770
I Minnesota immediately comes back even

00:15:29,000 --> 00:15:31,699
though it's a sink and the JavaScript

00:15:30,770 --> 00:15:35,540
thread will say

00:15:31,699 --> 00:15:40,609
upon this assertion and then it just it

00:15:35,540 --> 00:15:42,319
just returns that future assertion to

00:15:40,609 --> 00:15:46,100
scala test and scala test puts it on the

00:15:42,319 --> 00:15:48,559
shelf just like play did it sort of

00:15:46,100 --> 00:15:51,199
registers a call back and when that

00:15:48,559 --> 00:15:55,309
completes whether it's javascript or JVM

00:15:51,199 --> 00:15:57,919
then scala tests the callback will it's

00:15:55,309 --> 00:15:59,720
not a you know the request it's not the

00:15:57,919 --> 00:16:02,419
web browser client it's just the

00:15:59,720 --> 00:16:04,069
reporter it sends test succeeded test

00:16:02,419 --> 00:16:06,499
failed the same kind of events to the

00:16:04,069 --> 00:16:09,139
reporter and that's that's how it works

00:16:06,499 --> 00:16:11,029
so there's also an implicit conversion

00:16:09,139 --> 00:16:12,699
from assertion to future assertion so

00:16:11,029 --> 00:16:14,720
you can mix them if you have like a

00:16:12,699 --> 00:16:15,799
synchronous like synchronous s you don't

00:16:14,720 --> 00:16:19,129
happen to have a feature you can mix

00:16:15,799 --> 00:16:21,139
into in this kind of celebrate okay so

00:16:19,129 --> 00:16:24,259
that's an async test but this doesn't

00:16:21,139 --> 00:16:27,439
work right because with fixture the type

00:16:24,259 --> 00:16:29,359
of you know in the type signature it

00:16:27,439 --> 00:16:30,559
says the things finished right you

00:16:29,359 --> 00:16:32,869
already have to have an outcome so I

00:16:30,559 --> 00:16:36,410
this was hard to figure out how to fit

00:16:32,869 --> 00:16:38,359
in and make it nice and so what we ended

00:16:36,410 --> 00:16:43,189
up doing is making two more blow two

00:16:38,359 --> 00:16:46,639
subclasses and I hadn't used the word

00:16:43,189 --> 00:16:48,559
test suite before so with fixture was in

00:16:46,639 --> 00:16:50,329
class sweet before or Treat sweet now

00:16:48,559 --> 00:16:51,949
it's in test suite so test suite and

00:16:50,329 --> 00:16:54,470
acing test fee that's the level at which

00:16:51,949 --> 00:16:56,329
with fixture well what the type of the

00:16:54,470 --> 00:16:58,519
test function is if that's what where

00:16:56,329 --> 00:17:00,139
it's defined so that's the only thing to

00:16:58,519 --> 00:17:02,629
change is we move with fixture down to

00:17:00,139 --> 00:17:05,029
this thing and there's a new one for a

00:17:02,629 --> 00:17:07,339
sink that where the type is future

00:17:05,029 --> 00:17:08,959
outcome and future outcome is something

00:17:07,339 --> 00:17:13,039
that wraps future square brackets

00:17:08,959 --> 00:17:14,449
outcome and makes a nicer API so so

00:17:13,039 --> 00:17:18,169
there's two with fixtures but basically

00:17:14,449 --> 00:17:20,089
what when you extend fun sweet it or fun

00:17:18,169 --> 00:17:21,319
spec it extends test Suites so all your

00:17:20,089 --> 00:17:24,829
old code will work because it has the

00:17:21,319 --> 00:17:27,049
same with fixture pacing test weight is

00:17:24,829 --> 00:17:28,429
new it has a different with fixture it

00:17:27,049 --> 00:17:33,260
just has a different signature one that

00:17:28,429 --> 00:17:37,370
makes sense so the only thing is that

00:17:33,260 --> 00:17:38,840
this kind of trait will break and the

00:17:37,370 --> 00:17:41,629
way you fix it is you put the word test

00:17:38,840 --> 00:17:44,690
and where it's dark purple so that's a

00:17:41,629 --> 00:17:45,590
breaking change in 30 but it's you know

00:17:44,690 --> 00:17:48,500
I think this is

00:17:45,590 --> 00:17:50,000
it's not uncommon but it's not as common

00:17:48,500 --> 00:17:51,650
as just making with fixtures in your

00:17:50,000 --> 00:17:54,320
test class so I think it shouldn't be

00:17:51,650 --> 00:17:56,860
too painful to upgrade so that's that's

00:17:54,320 --> 00:17:59,240
one breaking change there aren't many

00:17:56,860 --> 00:18:07,039
because we're really worked hard to not

00:17:59,240 --> 00:18:09,770
have many so that's basically you know

00:18:07,039 --> 00:18:11,299
you do the same thing i like the default

00:18:09,770 --> 00:18:12,529
implementation of this with fixture is

00:18:11,299 --> 00:18:14,029
the same it just invokes the test

00:18:12,529 --> 00:18:15,470
function so when you say super with fix

00:18:14,029 --> 00:18:17,059
your tests it invokes a test function

00:18:15,470 --> 00:18:20,029
but what comes back as a future outcome

00:18:17,059 --> 00:18:22,159
right and then there were other things

00:18:20,029 --> 00:18:24,350
that didn't work so I'm going to back up

00:18:22,159 --> 00:18:26,750
to the tri finally example I'll come

00:18:24,350 --> 00:18:31,340
back to this but if there was one here

00:18:26,750 --> 00:18:33,590
where I had tri finally right here this

00:18:31,340 --> 00:18:35,570
is one of the idiomatic one so if you

00:18:33,590 --> 00:18:38,059
set the fixture up and then you call the

00:18:35,570 --> 00:18:41,029
super with picture test if it returns a

00:18:38,059 --> 00:18:42,309
future outcome in the final clause

00:18:41,029 --> 00:18:44,750
you're doing your clean up too fast

00:18:42,309 --> 00:18:46,279
because the future has necessarily

00:18:44,750 --> 00:18:47,570
completed that means the test is not

00:18:46,279 --> 00:18:49,640
necessarily completed and you want to

00:18:47,570 --> 00:18:51,649
wait until the test completes before you

00:18:49,640 --> 00:18:54,289
clean up does that make sense so that

00:18:51,649 --> 00:18:56,809
doesn't work and there are some methods

00:18:54,289 --> 00:18:58,820
on future that can register callbacks

00:18:56,809 --> 00:19:00,679
but they didn't quite work the same and

00:18:58,820 --> 00:19:03,980
one of the things I wanted to try to do

00:19:00,679 --> 00:19:06,760
was make things work the same so for

00:19:03,980 --> 00:19:09,559
example one of the methods on future

00:19:06,760 --> 00:19:12,470
ignores an exception thrown in the

00:19:09,559 --> 00:19:13,820
cleanup or the callback whereas here if

00:19:12,470 --> 00:19:15,140
an exception was thrown in the finally

00:19:13,820 --> 00:19:16,990
that actually overrides whatever

00:19:15,140 --> 00:19:18,919
happened before and that fails the test

00:19:16,990 --> 00:19:22,899
right so I thought that should happen

00:19:18,919 --> 00:19:22,899
and then oh sorry

00:19:25,910 --> 00:19:29,090
I'm not usually popular so I didn't

00:19:27,800 --> 00:19:30,920
think to turn off my phone people don't

00:19:29,090 --> 00:19:35,870
call me but this is not a good time for

00:19:30,920 --> 00:19:39,200
me so I will not take that call but what

00:19:35,870 --> 00:19:41,860
was I talking about no yes so there was

00:19:39,200 --> 00:19:45,680
another there's another method that does

00:19:41,860 --> 00:19:49,060
the other thing I wanted was that you

00:19:45,680 --> 00:19:52,160
don't that you get a new future back

00:19:49,060 --> 00:19:53,570
that so that this test doesn't complete

00:19:52,160 --> 00:19:54,830
till the cleanup Spanish because that

00:19:53,570 --> 00:19:56,150
was true here so let's say this cleanup

00:19:54,830 --> 00:19:57,410
takes five minutes you don't want the

00:19:56,150 --> 00:19:59,510
test to finish until the cleanups

00:19:57,410 --> 00:20:02,170
finished get to bank it the same so we

00:19:59,510 --> 00:20:06,470
had to invent a new syntax called

00:20:02,170 --> 00:20:09,200
complete lastly so what complete takes

00:20:06,470 --> 00:20:11,330
anything that's got a futuristic type

00:20:09,200 --> 00:20:12,950
class so it's a future of anything or

00:20:11,330 --> 00:20:17,180
this future outcome thing that we

00:20:12,950 --> 00:20:19,490
created to make it a nicer API so

00:20:17,180 --> 00:20:22,220
basically this thing has to return

00:20:19,490 --> 00:20:26,150
something neither a future or a future

00:20:22,220 --> 00:20:27,530
outcome and then if that blows up with

00:20:26,150 --> 00:20:29,570
an exception then this works like

00:20:27,530 --> 00:20:32,000
finally it immediately does the cleanup

00:20:29,570 --> 00:20:35,030
but if it returns normally then it's

00:20:32,000 --> 00:20:36,860
going to transform that future istic

00:20:35,030 --> 00:20:39,050
thing either feature outcome or a future

00:20:36,860 --> 00:20:40,610
of anything into another futuristic

00:20:39,050 --> 00:20:43,760
thing the same kind future outcome or

00:20:40,610 --> 00:20:46,460
future of anything that will not

00:20:43,760 --> 00:20:54,770
complete until this cleanup code

00:20:46,460 --> 00:20:56,030
completes and it will if they're that

00:20:54,770 --> 00:20:58,340
blows up with an exception the test

00:20:56,030 --> 00:21:02,090
fails with it okay so that that's

00:20:58,340 --> 00:21:03,710
complete lastly and then there's another

00:21:02,090 --> 00:21:06,680
thing that didn't work is like expecting

00:21:03,710 --> 00:21:09,260
exceptions so in a future you've got

00:21:06,680 --> 00:21:10,700
success and failure if if something

00:21:09,260 --> 00:21:12,800
blows up asynchronous so you basically

00:21:10,700 --> 00:21:15,800
get a try back because you you're not

00:21:12,800 --> 00:21:17,180
there to catch a problem if something is

00:21:15,800 --> 00:21:19,520
you like fired off something

00:21:17,180 --> 00:21:23,390
asynchronously so that's why try was

00:21:19,520 --> 00:21:24,860
invented so that you could handle an

00:21:23,390 --> 00:21:27,890
exception that happened in a different

00:21:24,860 --> 00:21:32,240
thread right so if you're now testing a

00:21:27,890 --> 00:21:33,920
future you need to be able to well do

00:21:32,240 --> 00:21:35,060
something like intercept or you know

00:21:33,920 --> 00:21:36,230
should throw this exception that should

00:21:35,060 --> 00:21:37,730
have this message kind of thing

00:21:36,230 --> 00:21:38,929
but you have to do in a future space so

00:21:37,730 --> 00:21:41,570
this doesn't work the first one doesn't

00:21:38,929 --> 00:21:43,610
work and by the way acer throws is a new

00:21:41,570 --> 00:21:45,440
assertion that's just like intercept

00:21:43,610 --> 00:21:48,410
accept it returns assertion intercept

00:21:45,440 --> 00:21:50,510
returns exception so it's not you can't

00:21:48,410 --> 00:21:53,270
use it at the end of a a sink test body

00:21:50,510 --> 00:21:55,309
because it's not type assertion and you

00:21:53,270 --> 00:21:57,950
can always put succeed that that's just

00:21:55,309 --> 00:21:59,450
returns to succeed singleton so there's

00:21:57,950 --> 00:22:01,190
always fail canceled and pending and

00:21:59,450 --> 00:22:02,900
skeleton and three others a succeed so

00:22:01,190 --> 00:22:04,910
they're all of them there I think

00:22:02,900 --> 00:22:06,830
succeed succeed succeed is kind of good

00:22:04,910 --> 00:22:08,780
neuro linguistic programming if you have

00:22:06,830 --> 00:22:12,110
that over and over in your test anyway

00:22:08,780 --> 00:22:15,740
but it's I kind of I don't want to make

00:22:12,110 --> 00:22:17,990
you do that so we added a sir throws to

00:22:15,740 --> 00:22:19,460
indicate you expect this exception but

00:22:17,990 --> 00:22:22,880
you don't care anything else about it

00:22:19,460 --> 00:22:25,179
just that is that exception essentially

00:22:22,880 --> 00:22:27,799
this future fails the map won't happen

00:22:25,179 --> 00:22:29,240
right and if you do this outside here

00:22:27,799 --> 00:22:31,040
this is saying that the thing that

00:22:29,240 --> 00:22:32,419
returns the future you expect it to

00:22:31,040 --> 00:22:34,100
throw an exception not that the future

00:22:32,419 --> 00:22:36,080
is expected to fail with that exception

00:22:34,100 --> 00:22:38,600
right so that doesn't work so we had to

00:22:36,080 --> 00:22:44,240
invent a couple new you know add more

00:22:38,600 --> 00:22:47,450
bloat invent a couple new assertions

00:22:44,240 --> 00:22:50,860
that work on futures so the body here is

00:22:47,450 --> 00:22:53,630
a future so recover to exception if

00:22:50,860 --> 00:22:55,760
recover is what it's called on future if

00:22:53,630 --> 00:23:00,530
you are expecting exception that means

00:22:55,760 --> 00:23:04,429
you you recover and it from from it and

00:23:00,530 --> 00:23:05,720
change into something else there are

00:23:04,429 --> 00:23:06,980
methods there that we could the reason

00:23:05,720 --> 00:23:08,270
we can use any of those methods is they

00:23:06,980 --> 00:23:10,309
weren't specific enough it would like

00:23:08,270 --> 00:23:12,980
recover from any exception to this right

00:23:10,309 --> 00:23:14,929
we want to recover only if it's that

00:23:12,980 --> 00:23:16,910
exception in the test otherwise we want

00:23:14,929 --> 00:23:18,799
it to fail right just and you get the

00:23:16,910 --> 00:23:21,470
same kind of message expected illegal

00:23:18,799 --> 00:23:25,429
argument exception but got string index

00:23:21,470 --> 00:23:29,480
out of bounds exception right so that

00:23:25,429 --> 00:23:30,950
one returns a future exception so you

00:23:29,480 --> 00:23:32,030
can map another assertion onto it if you

00:23:30,950 --> 00:23:33,890
like care about what the message is

00:23:32,030 --> 00:23:37,490
that's where recovered to exception if

00:23:33,890 --> 00:23:38,780
recover to succeeded if just checks to

00:23:37,490 --> 00:23:41,090
make sure that this feature has failed

00:23:38,780 --> 00:23:43,190
with that exception and if it has it

00:23:41,090 --> 00:23:45,200
just returns a future assertion that has

00:23:43,190 --> 00:23:47,779
succeeded right which you get in the

00:23:45,200 --> 00:23:53,599
test with so those are new

00:23:47,779 --> 00:23:56,479
and all right whoops and so this is

00:23:53,599 --> 00:24:00,859
basically a couple different things i

00:23:56,479 --> 00:24:03,919
want to just touch on what i have here

00:24:00,859 --> 00:24:07,849
is is a async test with two tests that

00:24:03,919 --> 00:24:13,249
return oh I'm always giving away the

00:24:07,849 --> 00:24:15,139
answer but essentially I didn't know I

00:24:13,249 --> 00:24:17,809
mean futures are usually used for

00:24:15,139 --> 00:24:20,809
parallel right should this run in

00:24:17,809 --> 00:24:22,450
parallel by default in skul tests tests

00:24:20,809 --> 00:24:25,219
don't usually run in parallel by default

00:24:22,450 --> 00:24:27,349
but in futures they usually do so I just

00:24:25,219 --> 00:24:28,879
wasn't sure which one it should be so I

00:24:27,349 --> 00:24:30,109
initially released milestones where it

00:24:28,879 --> 00:24:31,659
was in parallel because I just sort of

00:24:30,109 --> 00:24:34,849
thought that's what people would expect

00:24:31,659 --> 00:24:36,469
so that you know you say test test test

00:24:34,849 --> 00:24:39,109
you return this future and then this

00:24:36,469 --> 00:24:40,549
future and it would just they could run

00:24:39,109 --> 00:24:45,229
in parallel and complete asynchronously

00:24:40,549 --> 00:24:48,460
in parallel but I got some requests to

00:24:45,229 --> 00:24:53,679
to not do that I think with ramen Abbas

00:24:48,460 --> 00:24:56,149
that requested that who gave a talk here

00:24:53,679 --> 00:24:59,779
because they sometimes want to reuse the

00:24:56,149 --> 00:25:02,749
same database or fixture they don't want

00:24:59,779 --> 00:25:06,589
them interfering and it actually that's

00:25:02,749 --> 00:25:09,200
why I made it the default anyway is it's

00:25:06,589 --> 00:25:11,179
just simpler and if you really want you

00:25:09,200 --> 00:25:13,190
add parallel test execution and the

00:25:11,179 --> 00:25:15,289
other reason was usually running your

00:25:13,190 --> 00:25:16,759
sweets and parallels enough parallel ISM

00:25:15,289 --> 00:25:19,339
to get the performance you want and

00:25:16,759 --> 00:25:20,749
having just tests isn't usually

00:25:19,339 --> 00:25:24,109
necessary so that's that was sort of why

00:25:20,749 --> 00:25:28,309
I did it that way and so that's the

00:25:24,109 --> 00:25:32,859
first thing is it even though I can kind

00:25:28,309 --> 00:25:32,859
of copy this code I think these guys are

00:25:33,099 --> 00:25:39,559
returning futures like this they do run

00:25:35,899 --> 00:25:45,080
one after the other so to do that what

00:25:39,559 --> 00:25:47,839
it has to do new ads sweet is it

00:25:45,080 --> 00:25:50,149
actually okay so first the first test

00:25:47,839 --> 00:25:52,609
runs and then the second test runs the

00:25:50,149 --> 00:25:55,580
way that works is we register running

00:25:52,609 --> 00:25:58,220
the second test as a call back on the

00:25:55,580 --> 00:26:00,649
future that represents the completion of

00:25:58,220 --> 00:26:01,430
the first test and we run we register

00:26:00,649 --> 00:26:03,200
running the third

00:26:01,430 --> 00:26:04,820
just as a callback for the future that

00:26:03,200 --> 00:26:06,950
represents the running of the second

00:26:04,820 --> 00:26:10,340
test all the way on down so it's just

00:26:06,950 --> 00:26:12,650
this big chain of futures and so so

00:26:10,340 --> 00:26:15,740
that's the default behavior and if you

00:26:12,650 --> 00:26:17,270
want if you really want it in parallel

00:26:15,740 --> 00:26:18,920
you make some parallel test execution so

00:26:17,270 --> 00:26:20,660
I actually like that better once that

00:26:18,920 --> 00:26:23,150
they asked for that because it's

00:26:20,660 --> 00:26:25,460
consistent and and so then I really try

00:26:23,150 --> 00:26:27,500
to make everything consistent that's how

00:26:25,460 --> 00:26:29,330
it is in synchronous and so this is how

00:26:27,500 --> 00:26:37,580
it is it hasten its it's one after

00:26:29,330 --> 00:26:39,050
another and it's if you wanted to be

00:26:37,580 --> 00:26:45,080
impaired of all you mix in parallel test

00:26:39,050 --> 00:26:47,270
execution same trade okay and then the

00:26:45,080 --> 00:26:49,730
other thing that I was worried about is

00:26:47,270 --> 00:26:51,310
the reason I didn't have a sink I'm

00:26:49,730 --> 00:26:54,500
sorry a parallel be the default in

00:26:51,310 --> 00:26:56,030
synchronous test was I if you really

00:26:54,500 --> 00:26:57,890
have tests in parallel beam people will

00:26:56,030 --> 00:27:01,400
sometimes share fixtures between tests

00:26:57,890 --> 00:27:04,070
like mutable objects or bars as instance

00:27:01,400 --> 00:27:05,480
variables and you actually need to think

00:27:04,070 --> 00:27:06,830
about synchronizing access to that I

00:27:05,480 --> 00:27:10,880
have multiple threads hitting those

00:27:06,830 --> 00:27:12,050
things so just to keep that like you

00:27:10,880 --> 00:27:15,830
don't have to usually think about it I

00:27:12,050 --> 00:27:17,540
made it not the default so here now you

00:27:15,830 --> 00:27:18,980
can have many futures like you can have

00:27:17,540 --> 00:27:20,060
features and then combine them and like

00:27:18,980 --> 00:27:21,290
if there's different threads going on

00:27:20,060 --> 00:27:27,230
inside one test you have that problem

00:27:21,290 --> 00:27:29,810
again so initially we had a you had to

00:27:27,230 --> 00:27:30,740
specify an execution context but I

00:27:29,810 --> 00:27:32,780
thought it was kind of annoying

00:27:30,740 --> 00:27:35,150
boilerplate so I wanted to pick one and

00:27:32,780 --> 00:27:37,790
they're different on JavaScript and the

00:27:35,150 --> 00:27:39,110
JVM so i wasn't sure to pick but then

00:27:37,790 --> 00:27:40,670
there was that also that problem of

00:27:39,110 --> 00:27:42,890
making trying to make it less

00:27:40,670 --> 00:27:44,180
error-prone with concurrency on the JVM

00:27:42,890 --> 00:27:47,210
on JavaScript you don't it actually

00:27:44,180 --> 00:27:49,040
isn't a problem but on JVM it is so what

00:27:47,210 --> 00:27:51,470
we did is we created a new execution

00:27:49,040 --> 00:27:52,970
context which we internally call serial

00:27:51,470 --> 00:27:55,460
execution context but that's the default

00:27:52,970 --> 00:27:58,310
and the way it works is whenever you

00:27:55,460 --> 00:28:00,740
like like with that map either these

00:27:58,310 --> 00:28:02,600
maps will grab an implicit execution

00:28:00,740 --> 00:28:05,690
context it grabs our execution context

00:28:02,600 --> 00:28:07,730
and it it doesn't give it to a thread

00:28:05,690 --> 00:28:09,440
pool it just puts it onto one of those

00:28:07,730 --> 00:28:11,030
job queues kind of like JavaScript has

00:28:09,440 --> 00:28:14,310
and remembers that I need to do that

00:28:11,030 --> 00:28:19,790
eventually right so that's what it does

00:28:14,310 --> 00:28:21,690
and then when the future completes the

00:28:19,790 --> 00:28:23,310
sorry win that it's not in the future

00:28:21,690 --> 00:28:25,770
place when the thread returns and gives

00:28:23,310 --> 00:28:27,510
you the future back that parrot is now

00:28:25,770 --> 00:28:30,060
available so what it does is it just

00:28:27,510 --> 00:28:34,770
goes through the job queue so if it

00:28:30,060 --> 00:28:37,620
actually if it's really a sink then the

00:28:34,770 --> 00:28:40,770
job who can empty and the test hasn't

00:28:37,620 --> 00:28:42,480
finished yet so I'm going to put that as

00:28:40,770 --> 00:28:44,520
a comment what do we do and Victor can't

00:28:42,480 --> 00:28:47,610
answer what do you guess we do when that

00:28:44,520 --> 00:28:48,720
happens which is kind of crazy it means

00:28:47,610 --> 00:28:51,000
crazy sounding but I think it makes

00:28:48,720 --> 00:28:55,710
sense for testing anyone want to venture

00:28:51,000 --> 00:29:00,360
a guess it's one syllable we rhymes with

00:28:55,710 --> 00:29:01,380
rock yeah see they're even afraid to say

00:29:00,360 --> 00:29:05,220
it there's somebody over there that's

00:29:01,380 --> 00:29:07,200
brave enough to say block we block and

00:29:05,220 --> 00:29:09,080
that's only on a JVM right but the

00:29:07,200 --> 00:29:11,960
reason is actually it was Victor who was

00:29:09,080 --> 00:29:13,620
mentioned this victor clang he said that

00:29:11,960 --> 00:29:14,670
you know if you just get all these

00:29:13,620 --> 00:29:17,310
things running at once they're going to

00:29:14,670 --> 00:29:19,440
start timing out maybe maybe and that's

00:29:17,310 --> 00:29:21,270
kind of what blocking did in synchronous

00:29:19,440 --> 00:29:22,860
testing historically is it did throttle

00:29:21,270 --> 00:29:25,800
how many tests are running at once and

00:29:22,860 --> 00:29:27,300
so that's the default behavior on the

00:29:25,800 --> 00:29:33,360
JVM it will block on the JavaScript it

00:29:27,300 --> 00:29:35,400
can't but but anyway so that's serial

00:29:33,360 --> 00:29:36,780
execution context and then before and

00:29:35,400 --> 00:29:39,600
after I just wanted to mention that is

00:29:36,780 --> 00:29:40,800
like I would recommend people I always

00:29:39,600 --> 00:29:42,660
recommended people use with fixture

00:29:40,800 --> 00:29:44,100
anyway because that's why it's you don't

00:29:42,660 --> 00:29:46,160
have to mix anything in to use it that

00:29:44,100 --> 00:29:48,000
was the sort of the recommended but

00:29:46,160 --> 00:29:49,770
everybody's familiar with setup and

00:29:48,000 --> 00:29:52,020
teardown in j unit and they kind of like

00:29:49,770 --> 00:29:53,700
to mix that in they like it that way so

00:29:52,020 --> 00:29:56,010
you just mix in one one thing and you

00:29:53,700 --> 00:29:58,080
get you've got before and after that

00:29:56,010 --> 00:30:00,120
also works even though it has to be a

00:29:58,080 --> 00:30:02,700
sink ified and i had already made things

00:30:00,120 --> 00:30:05,250
a sink into dotto I thought but when it

00:30:02,700 --> 00:30:07,410
was actually test became a sink then I

00:30:05,250 --> 00:30:10,770
found that I hadn't done it right there

00:30:07,410 --> 00:30:13,020
were bugs it's just no one never one hit

00:30:10,770 --> 00:30:15,210
them because everything was actually

00:30:13,020 --> 00:30:17,340
synchronous right so anyway that's

00:30:15,210 --> 00:30:18,960
that's a kind of an overview of some of

00:30:17,340 --> 00:30:21,180
the things but I tried to make it as

00:30:18,960 --> 00:30:22,630
consistent as I could with the existing

00:30:21,180 --> 00:30:28,580
stuff so that it's

00:30:22,630 --> 00:30:30,230
at least you can kind of it's easier to

00:30:28,580 --> 00:30:34,600
go back and forth and sort of learn how

00:30:30,230 --> 00:30:36,890
to use the new stuff so okay so any

00:30:34,600 --> 00:30:39,380
moment I have that's this guy so and

00:30:36,890 --> 00:30:45,320
I've got these three functions to talk

00:30:39,380 --> 00:30:48,500
about real quick does anybody recognize

00:30:45,320 --> 00:30:53,929
this function and just this is the

00:30:48,500 --> 00:30:57,470
function that represents the sort of

00:30:53,929 --> 00:30:59,960
economic way of how would you call it

00:30:57,470 --> 00:31:01,240
the if a function of how when you when

00:30:59,960 --> 00:31:04,309
you're working on open source

00:31:01,240 --> 00:31:08,570
essentially it because of software is

00:31:04,309 --> 00:31:10,670
free and it doesn't it isn't free to

00:31:08,570 --> 00:31:13,130
make it sound like freedom isn't free so

00:31:10,670 --> 00:31:14,300
what I've been doing this for eight

00:31:13,130 --> 00:31:17,270
years or nine years or something just

00:31:14,300 --> 00:31:19,730
because I really enjoy it and what the

00:31:17,270 --> 00:31:21,500
way we funded we actually hired people

00:31:19,730 --> 00:31:22,880
and they work on it we pay them to work

00:31:21,500 --> 00:31:27,260
on Scala tests which is how we get

00:31:22,880 --> 00:31:28,460
through all this this stuff and just

00:31:27,260 --> 00:31:30,380
funded it through consulting and

00:31:28,460 --> 00:31:33,380
training and books things that we sell

00:31:30,380 --> 00:31:34,670
plus we get features a paid for

00:31:33,380 --> 00:31:37,760
sometimes occasionally but it's very

00:31:34,670 --> 00:31:39,050
iffy so what I did and I reason I bring

00:31:37,760 --> 00:31:42,350
this up because I just deployed it to

00:31:39,050 --> 00:31:45,650
the website is I I want to explain

00:31:42,350 --> 00:31:50,270
myself I'll show you the oh no I can't

00:31:45,650 --> 00:31:55,400
get the browser why not it closed that

00:31:50,270 --> 00:31:58,070
guy there we go we came up with two ways

00:31:55,400 --> 00:32:02,540
to try and help fund the project that's

00:31:58,070 --> 00:32:05,030
more dependable and one of them is we're

00:32:02,540 --> 00:32:08,000
going to put a very hopefully uh Ninoy

00:32:05,030 --> 00:32:09,860
'add on the documentation and on the

00:32:08,000 --> 00:32:12,710
user guide so that's called a

00:32:09,860 --> 00:32:14,780
sponsorship and what I try to do is make

00:32:12,710 --> 00:32:17,030
it because it's if there's a lot of

00:32:14,780 --> 00:32:18,559
traffic there and they're all Scala

00:32:17,030 --> 00:32:21,410
people so I thought it would provide

00:32:18,559 --> 00:32:24,470
value to people who wanted to support

00:32:21,410 --> 00:32:25,940
the project so that's one of them and so

00:32:24,470 --> 00:32:27,410
it just rotates it's the only place it's

00:32:25,940 --> 00:32:31,520
sort of on every page and it's in the

00:32:27,410 --> 00:32:33,470
Scala talk to but anyway that's one

00:32:31,520 --> 00:32:34,740
thing that's a sponsorship and the other

00:32:33,470 --> 00:32:37,830
thing we did

00:32:34,740 --> 00:32:39,720
was I added a donate tab here and this

00:32:37,830 --> 00:32:41,880
is more like crowdfunding for people who

00:32:39,720 --> 00:32:45,990
just like the framework and want to

00:32:41,880 --> 00:32:47,460
contribute a little to help you get a

00:32:45,990 --> 00:32:49,740
nice thank-you gift so coffee cup

00:32:47,460 --> 00:32:51,000
something branded or t-shirt or or some

00:32:49,740 --> 00:32:54,120
cheat sheets and that sort of thing so

00:32:51,000 --> 00:33:00,270
that's I just sort of wanted to explain

00:32:54,120 --> 00:33:03,030
that and sort of get feedback on if that

00:33:00,270 --> 00:33:04,890
bothers anybody and you know it is

00:33:03,030 --> 00:33:07,320
always going to be free but it wasn't

00:33:04,890 --> 00:33:10,770
free to create so that's why I try to

00:33:07,320 --> 00:33:15,630
find some way to to get some funding for

00:33:10,770 --> 00:33:16,920
it so if anybody thinks that that that

00:33:15,630 --> 00:33:19,410
might make sense for them you just click

00:33:16,920 --> 00:33:24,179
on the donate button you can pitch in so

00:33:19,410 --> 00:33:26,400
that's this function and then another

00:33:24,179 --> 00:33:29,190
thing I'd like to ask for help on is

00:33:26,400 --> 00:33:30,360
this guy which is I'm really busy I

00:33:29,190 --> 00:33:32,670
don't have to try time to try out

00:33:30,360 --> 00:33:34,860
people's milestones and releases but

00:33:32,670 --> 00:33:36,570
this one is a huge one so anybody who

00:33:34,860 --> 00:33:38,520
has time to try it in their project I

00:33:36,570 --> 00:33:39,870
would really appreciate it you can

00:33:38,520 --> 00:33:41,940
already try it today it's out there I

00:33:39,870 --> 00:33:45,510
just you might wait till I get this call

00:33:41,940 --> 00:33:47,429
the doc out but um and give me feedback

00:33:45,510 --> 00:33:49,800
if it works great then tell me that as

00:33:47,429 --> 00:33:56,820
well because I want to release this

00:33:49,800 --> 00:33:57,929
final in Berlin and that's I think four

00:33:56,820 --> 00:33:59,520
weeks away or five weeks away something

00:33:57,929 --> 00:34:00,570
like that so I need to I need if there's

00:33:59,520 --> 00:34:02,790
a problem I need to know about as soon

00:34:00,570 --> 00:34:04,050
as possible and then the last one is Q 2

00:34:02,790 --> 00:34:06,210
a which is you guys get to ask the

00:34:04,050 --> 00:34:07,679
questions and I get left 10 minutes I

00:34:06,210 --> 00:34:09,450
want to leave some time for you guys to

00:34:07,679 --> 00:34:17,220
ask questions anyway I have any

00:34:09,450 --> 00:34:19,290
questions yes over here good what do i

00:34:17,220 --> 00:34:23,399
use the tests cultist not specs i use

00:34:19,290 --> 00:34:25,889
scala test and you know there's it seems

00:34:23,399 --> 00:34:27,990
like there's a potential that it could

00:34:25,889 --> 00:34:30,060
there could be a bug that passes because

00:34:27,990 --> 00:34:33,720
of the bug so I've always kind of

00:34:30,060 --> 00:34:35,580
worried slightly about that but but yeah

00:34:33,720 --> 00:34:40,020
that's what we do it's just like eating

00:34:35,580 --> 00:34:41,040
your own cupcakes or dog food how about

00:34:40,020 --> 00:34:44,600
you in a gray shirt i'm gonna get my

00:34:41,040 --> 00:34:44,600
glasses on so i can see better yes

00:34:46,750 --> 00:34:55,250
it hangs so what the question was just

00:34:51,650 --> 00:34:56,960
to repeat the question is the tests by

00:34:55,250 --> 00:34:59,420
default unless you mix in parallel test

00:34:56,960 --> 00:35:02,600
execution whereas it was this one right

00:34:59,420 --> 00:35:04,460
here the second test is sort of read the

00:35:02,600 --> 00:35:06,710
running of that is registered as a call

00:35:04,460 --> 00:35:08,600
back on the first test future completing

00:35:06,710 --> 00:35:10,760
if that one ever complace them the whole

00:35:08,600 --> 00:35:13,790
thing hangs that's true in synchronous

00:35:10,760 --> 00:35:15,500
tests to what you can do in actually

00:35:13,790 --> 00:35:18,500
heiko that was another thing hi co SI

00:35:15,500 --> 00:35:19,820
how can i get a timeout in a test and I

00:35:18,500 --> 00:35:22,040
wanted it to work the same way you mix

00:35:19,820 --> 00:35:23,450
in time limited tests it didn't work yet

00:35:22,040 --> 00:35:25,250
so that took a few more weeks to get

00:35:23,450 --> 00:35:26,390
working so if you if you do have

00:35:25,250 --> 00:35:29,180
something hanging then you just got to

00:35:26,390 --> 00:35:30,740
mix in the the thing that kills it but

00:35:29,180 --> 00:35:33,070
that was also another thing that didn't

00:35:30,740 --> 00:35:36,980
really work the same in futures because

00:35:33,070 --> 00:35:38,780
you can't cancel the future really what

00:35:36,980 --> 00:35:40,010
you can do is stop waiting for it so the

00:35:38,780 --> 00:35:44,030
future still keeps going on in the

00:35:40,010 --> 00:35:46,130
background but the test moves on and we

00:35:44,030 --> 00:35:49,640
mentioned that it failed but the future

00:35:46,130 --> 00:35:57,170
is still we can't kill it like tell it

00:35:49,640 --> 00:35:59,450
to stop the other thing I want to

00:35:57,170 --> 00:36:03,050
mention that i forgot to mention was

00:35:59,450 --> 00:36:05,780
that parallel test execution I didn't

00:36:03,050 --> 00:36:07,790
think made any sense on JavaScript but

00:36:05,780 --> 00:36:10,670
actually what you give this is running

00:36:07,790 --> 00:36:11,960
on JavaScript and in AD soon let's say

00:36:10,670 --> 00:36:14,060
it was at one of those API calls that

00:36:11,960 --> 00:36:15,290
goes outside the JVM let's say have ten

00:36:14,060 --> 00:36:17,810
of these and they take a minute each

00:36:15,290 --> 00:36:21,230
it's kind of nice to start 10 of those

00:36:17,810 --> 00:36:23,540
tests at once and have them executing in

00:36:21,230 --> 00:36:25,250
parallel outside the JV outside the

00:36:23,540 --> 00:36:27,650
JavaScript p.m. and then they complete

00:36:25,250 --> 00:36:29,750
it would speed it up so parallel test

00:36:27,650 --> 00:36:31,190
execution even works in JavaScript where

00:36:29,750 --> 00:36:33,730
there's just one thread and it makes

00:36:31,190 --> 00:36:37,850
sense so I forgot to mention that before

00:36:33,730 --> 00:36:40,720
anyway anybody else have a question yes

00:36:37,850 --> 00:36:40,720
sorry yes

00:36:51,500 --> 00:36:55,910
I don't think it would the question is

00:36:53,510 --> 00:36:58,820
will it take longer because it's at it's

00:36:55,910 --> 00:37:00,110
in the future space on this continuous

00:36:58,820 --> 00:37:02,750
integration server for example and I

00:37:00,110 --> 00:37:04,160
don't think so and I don't also think

00:37:02,750 --> 00:37:06,530
I'm not convinced it will be any faster

00:37:04,160 --> 00:37:08,150
either it's just on the javascript is

00:37:06,530 --> 00:37:10,220
the only way to do it and on JV I'm

00:37:08,150 --> 00:37:11,630
especially kind of I think it's what I

00:37:10,220 --> 00:37:13,610
liked about it before I even knew about

00:37:11,630 --> 00:37:15,440
the javascript stuff was that it was

00:37:13,610 --> 00:37:17,920
consistent like the way I write my

00:37:15,440 --> 00:37:20,360
production code I don't want to block I

00:37:17,920 --> 00:37:23,150
kind of like not changing that in the

00:37:20,360 --> 00:37:25,400
test its kind of feels good so I think

00:37:23,150 --> 00:37:30,170
that's the main benefit on the JVM but

00:37:25,400 --> 00:37:32,900
it's just kind of essentially the

00:37:30,170 --> 00:37:35,390
mindset you need for futures in general

00:37:32,900 --> 00:37:37,640
is you once you get in them you stay in

00:37:35,390 --> 00:37:40,160
them you don't block and get out and why

00:37:37,640 --> 00:37:42,380
not do that in your tests too it's

00:37:40,160 --> 00:37:49,100
basically on the JVM I think the main

00:37:42,380 --> 00:37:53,030
advantage anybody else okay oops just

00:37:49,100 --> 00:37:54,140
one see what time it is all right I have

00:37:53,030 --> 00:37:58,030
two more minutes of this one more

00:37:54,140 --> 00:37:58,030
question yes you in the back yes

00:38:03,350 --> 00:38:07,920
yes the question is with the parallel

00:38:06,510 --> 00:38:13,740
execution context can you tell it how

00:38:07,920 --> 00:38:15,750
big the pool is okay so the way you do

00:38:13,740 --> 00:38:19,110
that is by selecting an implicit

00:38:15,750 --> 00:38:21,360
execution context that does that but

00:38:19,110 --> 00:38:22,710
what I didn't but basically you can you

00:38:21,360 --> 00:38:24,870
can do that with the implicit execution

00:38:22,710 --> 00:38:26,820
context you have to define it just to

00:38:24,870 --> 00:38:29,430
find one here say implicit you know Val

00:38:26,820 --> 00:38:30,780
execution context equals whatever and

00:38:29,430 --> 00:38:34,260
they give it two threads or something

00:38:30,780 --> 00:38:36,000
what we didn't do is integrate with the

00:38:34,260 --> 00:38:37,440
command line and the command line if you

00:38:36,000 --> 00:38:41,700
run tests in parallel you can say how

00:38:37,440 --> 00:38:43,160
many threads to use that's how many

00:38:41,700 --> 00:38:46,050
threads are used to actually execute

00:38:43,160 --> 00:38:49,320
test Suites in parallel and test methods

00:38:46,050 --> 00:38:50,790
or test test bodies but it's not it's

00:38:49,320 --> 00:38:52,050
other threads that are in that execution

00:38:50,790 --> 00:38:54,360
kana so we don't try to combine those

00:38:52,050 --> 00:38:55,500
two so it's a separate a separate thing

00:38:54,360 --> 00:38:58,920
and then the other thing that's kind of

00:38:55,500 --> 00:39:00,960
clunky is the the execution context are

00:38:58,920 --> 00:39:03,240
very different on JavaScript in JVM so

00:39:00,960 --> 00:39:05,310
you have to like figure out how to get

00:39:03,240 --> 00:39:06,540
them if you do override the execution

00:39:05,310 --> 00:39:07,890
context and you're doing it on both

00:39:06,540 --> 00:39:12,720
platforms then you got to figure out how

00:39:07,890 --> 00:39:13,830
to like manage that and maybe you know

00:39:12,720 --> 00:39:15,360
conditionally I mean that basically I

00:39:13,830 --> 00:39:16,740
think you everybody has come up with a

00:39:15,360 --> 00:39:19,380
way to do that when they're using scale

00:39:16,740 --> 00:39:23,760
jeaious and JVM also so it's just that

00:39:19,380 --> 00:39:26,370
and I think that's all no no I have five

00:39:23,760 --> 00:39:27,450
more minutes I forgot anyway I can do

00:39:26,370 --> 00:39:30,140
another question otherwise we can oh

00:39:27,450 --> 00:39:30,140
yeah this one right there

00:39:34,109 --> 00:39:39,410
but the way yeah

00:39:44,710 --> 00:39:50,060
no it was just I basically the question

00:39:47,540 --> 00:39:53,870
was a I kind of said blow it a couple

00:39:50,060 --> 00:39:56,750
times in it in like a self critical way

00:39:53,870 --> 00:40:00,460
and and I just don't like it but its

00:39:56,750 --> 00:40:02,510
necessary what I found is that over time

00:40:00,460 --> 00:40:05,780
that's just like really small simple

00:40:02,510 --> 00:40:07,430
things that's my taste and it started

00:40:05,780 --> 00:40:09,680
out pretty small and simple but then

00:40:07,430 --> 00:40:12,100
this is now nine years old and I've seen

00:40:09,680 --> 00:40:15,950
things go get ridiculously bloated like

00:40:12,100 --> 00:40:17,450
JIRA is so powerful I can't figure out

00:40:15,950 --> 00:40:21,260
how to do simple things and I don't want

00:40:17,450 --> 00:40:23,440
that to happen to spell a test but if

00:40:21,260 --> 00:40:26,450
you don't do stuff like people want

00:40:23,440 --> 00:40:27,950
acing testing and they want a test

00:40:26,450 --> 00:40:30,020
framework they once felt it to work on

00:40:27,950 --> 00:40:33,140
Scala jayus and I worked really hard to

00:40:30,020 --> 00:40:34,940
make it make sure that moving doing that

00:40:33,140 --> 00:40:35,810
didn't hurt the JVM people because

00:40:34,940 --> 00:40:37,520
there's some people who don't care

00:40:35,810 --> 00:40:39,860
abouts college is so and I think we said

00:40:37,520 --> 00:40:41,960
I did achieve that but we didn't achieve

00:40:39,860 --> 00:40:43,730
keeping it I mean it still got more

00:40:41,960 --> 00:40:47,810
things in it the one thing I would say

00:40:43,730 --> 00:40:49,400
about like that is that i did also try

00:40:47,810 --> 00:40:51,980
that everything in scale test their

00:40:49,400 --> 00:40:53,900
trees lee traits it is very small and

00:40:51,980 --> 00:40:55,580
focused and just as a few things and

00:40:53,900 --> 00:40:58,250
it's a little bit more like unix it's

00:40:55,580 --> 00:40:59,690
got tons of stuff in it but you you pick

00:40:58,250 --> 00:41:02,720
a few commands and you put them together

00:40:59,690 --> 00:41:04,400
and that's what you use and that's kind

00:41:02,720 --> 00:41:07,790
of what's cultist is people it's more

00:41:04,400 --> 00:41:09,290
like a library than a framework and you

00:41:07,790 --> 00:41:11,150
grab the pieces you want you mix them

00:41:09,290 --> 00:41:16,910
together they fit together and then that

00:41:11,150 --> 00:41:19,010
simple but anyway I just I kept it as

00:41:16,910 --> 00:41:20,600
simple as I could but it just seems like

00:41:19,010 --> 00:41:23,600
the other thing we're going to do is we

00:41:20,600 --> 00:41:25,040
started moving like deprecating some

00:41:23,600 --> 00:41:27,290
names moving to package so we can do

00:41:25,040 --> 00:41:28,580
modularity so like there are certain

00:41:27,290 --> 00:41:30,320
things like Jane mock doesn't work on

00:41:28,580 --> 00:41:32,120
JavaScript and so that should be a

00:41:30,320 --> 00:41:34,100
module so if you hit will eventually be

00:41:32,120 --> 00:41:36,200
a skull to score once we go through the

00:41:34,100 --> 00:41:38,240
deprecation of the names that's smaller

00:41:36,200 --> 00:41:41,470
and I think that will will help a little

00:41:38,240 --> 00:41:48,490
bit and that's basically it yes

00:41:41,470 --> 00:41:51,430
ah oh yes the question is do we have

00:41:48,490 --> 00:41:53,290
plans for acha test kit and I think

00:41:51,430 --> 00:41:58,810
probably the background to that is that

00:41:53,290 --> 00:42:05,380
the Autodesk eight blocks and so I was

00:41:58,810 --> 00:42:07,859
teaching in at a company advanced scar

00:42:05,380 --> 00:42:11,410
advanced calc class and and as a project

00:42:07,859 --> 00:42:14,470
we took a test kit and we implemented it

00:42:11,410 --> 00:42:16,030
with a sink for with features and that

00:42:14,470 --> 00:42:18,099
there is some be venner's it's on my

00:42:16,030 --> 00:42:19,390
github you can see well actually you can

00:42:18,099 --> 00:42:21,760
see what is this work day everybody

00:42:19,390 --> 00:42:26,560
contributed it that was the class and

00:42:21,760 --> 00:42:27,910
and and it's there and we just have we

00:42:26,560 --> 00:42:29,530
haven't done anything more with it but

00:42:27,910 --> 00:42:31,390
it actually worked it was really fun

00:42:29,530 --> 00:42:33,220
everybody loved it because they could

00:42:31,390 --> 00:42:34,390
use the stuff that we were teaching and

00:42:33,220 --> 00:42:37,660
actually for something that maybe people

00:42:34,390 --> 00:42:39,490
would use some day but it's you know

00:42:37,660 --> 00:42:41,349
it's a it actually might block behind

00:42:39,490 --> 00:42:43,030
the scenes now but all the API is there

00:42:41,349 --> 00:42:45,369
is like we had to come up names and all

00:42:43,030 --> 00:42:47,470
that so I think that makes sense to have

00:42:45,369 --> 00:42:49,630
a scala tests plus acha or of new

00:42:47,470 --> 00:42:51,940
version of tests I mean that's grace

00:42:49,630 --> 00:42:53,830
Pacific discala test so maybe its skull

00:42:51,940 --> 00:42:57,330
tests plus acha that has that stuff in

00:42:53,830 --> 00:43:03,390
it but yeah we already started on that

00:42:57,330 --> 00:43:03,390
okay anybody else yes

00:43:08,069 --> 00:43:11,579
property basis oh yeah well we integrate

00:43:10,410 --> 00:43:14,339
with Scala check so the question was

00:43:11,579 --> 00:43:15,690
property based testing we do integrate

00:43:14,339 --> 00:43:18,059
with scholars check but one of the I

00:43:15,690 --> 00:43:19,559
mean I thought think of this skull j s

00:43:18,059 --> 00:43:23,880
thing is the biggest yak shape of my

00:43:19,559 --> 00:43:25,619
life BK yet i don't you guys anybody

00:43:23,880 --> 00:43:27,900
familiar with what why we say yak shave

00:43:25,619 --> 00:43:29,160
I don't actually remember what the

00:43:27,900 --> 00:43:30,390
original story was but somebody had to

00:43:29,160 --> 00:43:31,799
do something that seems simple but

00:43:30,390 --> 00:43:33,209
before he gets that done he has to go do

00:43:31,799 --> 00:43:34,829
something else but if we do that he'd do

00:43:33,209 --> 00:43:36,420
something else and then you know if the

00:43:34,829 --> 00:43:37,949
sort of like the end of that he had

00:43:36,420 --> 00:43:39,089
actually shaved yak before I could do

00:43:37,949 --> 00:43:40,859
this and he finally got everything done

00:43:39,089 --> 00:43:43,410
he could do the simple thing right so

00:43:40,859 --> 00:43:45,869
because we were so tied to the JVM we

00:43:43,410 --> 00:43:47,339
had to implement a bunch of stuff that

00:43:45,869 --> 00:43:49,979
seems ridiculous that's nothing to do

00:43:47,339 --> 00:43:52,739
with JavaScript like we used resource

00:43:49,979 --> 00:43:54,239
bundles in Scala test because we're I'm

00:43:52,739 --> 00:43:55,650
a good trying to be a good job of

00:43:54,239 --> 00:43:56,969
citizen and use Java

00:43:55,650 --> 00:43:58,890
internationalization well that doesn't

00:43:56,969 --> 00:43:59,999
work on us college is so I had to

00:43:58,890 --> 00:44:04,650
implement a internationalisation

00:43:59,999 --> 00:44:06,359
framework we did and so we did and we

00:44:04,650 --> 00:44:08,219
made it better because the one on the

00:44:06,359 --> 00:44:10,049
JVM you can occasionally we'll get a

00:44:08,219 --> 00:44:11,849
resource not found and ours is

00:44:10,049 --> 00:44:14,459
statically typed checked said I checked

00:44:11,849 --> 00:44:16,410
which is they should be right but it's

00:44:14,459 --> 00:44:17,459
not general we didn't do that i'm not

00:44:16,410 --> 00:44:22,829
going to release it it's just for us

00:44:17,459 --> 00:44:25,709
it's a code generator but scala check

00:44:22,829 --> 00:44:29,009
didn't work on scala j yes but we use it

00:44:25,709 --> 00:44:30,329
in our own tests so i found there were

00:44:29,009 --> 00:44:32,309
two other people who had come up with

00:44:30,329 --> 00:44:33,690
property based test frameworks that at

00:44:32,309 --> 00:44:35,449
one of which said they did work on scala

00:44:33,690 --> 00:44:38,729
JS so we ported our thing to that

00:44:35,449 --> 00:44:40,079
teasing tibetan malaysia overnight i

00:44:38,729 --> 00:44:42,029
thought it would be quick but it

00:44:40,079 --> 00:44:44,729
actually didn't work so he took a whole

00:44:42,029 --> 00:44:46,499
day you know trying to get it to work

00:44:44,729 --> 00:44:47,670
and if he was doing that it would have

00:44:46,499 --> 00:44:51,119
been better just try to get skull check

00:44:47,670 --> 00:44:54,119
to work but it really didn't work it was

00:44:51,119 --> 00:44:56,009
just as brand new is called yaya so we

00:44:54,119 --> 00:44:59,640
actually wrote started writing our own

00:44:56,009 --> 00:45:01,259
generator inside scala test and we use

00:44:59,640 --> 00:45:02,699
that we just wrote it again we just use

00:45:01,259 --> 00:45:06,420
it internally just enough for us to get

00:45:02,699 --> 00:45:08,420
our tests working but i think it's

00:45:06,420 --> 00:45:10,410
different than spell checks and we may

00:45:08,420 --> 00:45:11,819
you know now that we're finished with

00:45:10,410 --> 00:45:13,440
this that may actually come out someday

00:45:11,819 --> 00:45:15,209
and there's i had what i want to add

00:45:13,440 --> 00:45:16,829
some syntax for laws testing that is

00:45:15,209 --> 00:45:18,119
nice that works with cats and spell is e

00:45:16,829 --> 00:45:20,490
and whatever

00:45:18,119 --> 00:45:22,049
and so there's you know there's probably

00:45:20,490 --> 00:45:24,180
things coming in Scala test that

00:45:22,049 --> 00:45:26,190
actually address that more directly and

00:45:24,180 --> 00:45:27,210
not just the Scala checked integration

00:45:26,190 --> 00:45:30,329
which will always continue to work

00:45:27,210 --> 00:45:32,599
though okay that's that's it I think I'm

00:45:30,329 --> 00:45:36,410
thank you very much for coming and

00:45:32,599 --> 00:45:36,410

YouTube URL: https://www.youtube.com/watch?v=YEnlTpS7xEA


