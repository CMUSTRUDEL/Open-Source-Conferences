Title: Scala on the Move! - by Shadaj Laddad
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
In the past year, all of my projects have involved using Scala with some moving entity: musical notes, robots, garage doors, and so on. In this talk, I will show how Scala has been consistently helpful, no matter what I throw at it.
In a research project to categorize and identify musical recordings, Scala made a complex processing pipeline look beautiful with its collections. Processing pitches, building musical models, and applying machine learning algorithms could each be implemented as a data transformation.
On my high school robotics team, I was able to use Scala.js and Akka-HTTP to build a web-based dashboard for viewing live sensor and control loop data, as well as running automated calibration routines. The simplicity of both Scala.js and Akka-HTTP made it easy to send data produced by simple functions to clients over a WebSocket and have clients render the data as it arrives.
A combination of Akka, Play Framework, and Scala.js built Ash, a home-automation system with easy extensibility. Modeling server and client portions as actors allowed for easy communication between them. Akka also became a unifying factor for working across a diverse set of hardware -- PCs, mobile devices, and Raspberry Pis.
Captions: 
	00:00:00,000 --> 00:00:03,629
one pattern I noticed among all these is

00:00:01,920 --> 00:00:06,450
they always involve some type of moving

00:00:03,629 --> 00:00:09,570
entity be it on analyzing the motion

00:00:06,450 --> 00:00:12,420
between notes of music or tracking the

00:00:09,570 --> 00:00:14,969
data from live robots or even home

00:00:12,420 --> 00:00:18,750
automation they all required some type

00:00:14,969 --> 00:00:21,420
of moving entity and Scala and all these

00:00:18,750 --> 00:00:24,210
projects made it so simple and so easy

00:00:21,420 --> 00:00:26,430
to implement these projects and a lot of

00:00:24,210 --> 00:00:28,019
interesting patterns showed up and I'll

00:00:26,430 --> 00:00:33,030
be going through some of these in my

00:00:28,019 --> 00:00:35,940
talk so let's get started with the first

00:00:33,030 --> 00:00:39,329
project which is musical analysis with

00:00:35,940 --> 00:00:41,910
scholar collections so I participated

00:00:39,329 --> 00:00:44,309
this year in a science competition

00:00:41,910 --> 00:00:46,710
called the synopsis science championship

00:00:44,309 --> 00:00:48,570
and in it I took one of my interests

00:00:46,710 --> 00:00:51,239
which is playing the sitar an Indian

00:00:48,570 --> 00:00:52,980
classical music instrument and I built a

00:00:51,239 --> 00:00:54,239
machine learning algorithm that could

00:00:52,980 --> 00:00:57,719
take recordings of Indian classical

00:00:54,239 --> 00:01:01,980
music and classified into different

00:00:57,719 --> 00:01:05,129
types of what type of recording is being

00:01:01,980 --> 00:01:06,900
played so before we dive into the

00:01:05,129 --> 00:01:08,610
algorithm I'm going to give a brief

00:01:06,900 --> 00:01:12,689
overview of what is Indian classical

00:01:08,610 --> 00:01:16,020
music so the core concept in Indian

00:01:12,689 --> 00:01:19,080
classical music is a raga so whenever an

00:01:16,020 --> 00:01:21,290
artist is playing a performance they

00:01:19,080 --> 00:01:24,119
will be playing a certain raga and

00:01:21,290 --> 00:01:27,450
Rutgers are designed to convey specific

00:01:24,119 --> 00:01:30,000
feelings and they do this mainly in two

00:01:27,450 --> 00:01:32,390
ways the first aspect of our Agha is the

00:01:30,000 --> 00:01:34,909
scale so this is which notes are allowed

00:01:32,390 --> 00:01:38,820
what's the prominence of different notes

00:01:34,909 --> 00:01:40,950
and this specifies the basic structure

00:01:38,820 --> 00:01:43,530
of what you're going to be using within

00:01:40,950 --> 00:01:45,930
the raga but a really interesting thing

00:01:43,530 --> 00:01:48,030
is there exists raagas with the exact

00:01:45,930 --> 00:01:50,310
same skills but how do you tell them

00:01:48,030 --> 00:01:53,939
apart and that's where the movements

00:01:50,310 --> 00:01:56,399
come in so between different raagas what

00:01:53,939 --> 00:01:59,070
you'll often see is in certain raagas

00:01:56,399 --> 00:02:00,570
you have the same notes but the order in

00:01:59,070 --> 00:02:03,930
which you're allowed to play the notes

00:02:00,570 --> 00:02:06,390
is different I'm so based on this

00:02:03,930 --> 00:02:10,920
in order you can convey different

00:02:06,390 --> 00:02:14,640
feelings and you can separate out these

00:02:10,920 --> 00:02:19,590
raagas based on these transitions allow

00:02:14,640 --> 00:02:21,810
to between notes so let's take an

00:02:19,590 --> 00:02:23,880
example of what this would mean so here

00:02:21,810 --> 00:02:26,880
we're looking at the notes the scale

00:02:23,880 --> 00:02:28,530
allowed in raga dish so here I mean

00:02:26,880 --> 00:02:30,840
Indian classical music you have the

00:02:28,530 --> 00:02:34,920
notes I'm just like during me facility

00:02:30,840 --> 00:02:38,280
know you have sorry but honey and some

00:02:34,920 --> 00:02:40,590
and based on these different notes there

00:02:38,280 --> 00:02:43,320
are also variations that are sharp which

00:02:40,590 --> 00:02:46,790
is called tilde and flat which is called

00:02:43,320 --> 00:02:50,910
coma so in this case we have sorry gah

00:02:46,790 --> 00:02:54,810
normal fun Coleman me here so this flat

00:02:50,910 --> 00:02:59,450
me me and some so that's now let's

00:02:54,810 --> 00:03:02,850
see you look at another raka Yellin so

00:02:59,450 --> 00:03:05,610
raga yaman sheer some of the notes would

00:03:02,850 --> 00:03:07,860
have some differences too so here the

00:03:05,610 --> 00:03:11,040
norman law was removed and replaced with

00:03:07,860 --> 00:03:12,780
the dilemma and here we got rid of the

00:03:11,040 --> 00:03:16,320
coleman nice so we got rid of the flat

00:03:12,780 --> 00:03:18,810
me and so this is a scale differences

00:03:16,320 --> 00:03:21,239
now let's say we want to be able to

00:03:18,810 --> 00:03:24,570
distinguish these two rak'ahs but the

00:03:21,239 --> 00:03:27,120
artist only blaze me saw and really in

00:03:24,570 --> 00:03:28,890
some order and both of these all three

00:03:27,120 --> 00:03:31,200
of these notes are allowed in both ragas

00:03:28,890 --> 00:03:32,640
but how each other apart is the order so

00:03:31,200 --> 00:03:35,430
let's look at what would be allowed in

00:03:32,640 --> 00:03:38,040
raga dish so here you would start with

00:03:35,430 --> 00:03:40,200
me you would please stop and then race

00:03:38,040 --> 00:03:42,000
so here just to direct ascending order

00:03:40,200 --> 00:03:44,519
that would be allowed in rugged dish

00:03:42,000 --> 00:03:46,530
however this will not be allowed in raag

00:03:44,519 --> 00:03:49,440
yaman because you're not allowed to go

00:03:46,530 --> 00:03:51,150
to ray if you play some so instead you

00:03:49,440 --> 00:03:52,739
have to go into kind of a curvy fashion

00:03:51,150 --> 00:03:55,140
to be able to play all three notes so

00:03:52,739 --> 00:03:56,459
you start with you but you can't place a

00:03:55,140 --> 00:03:58,380
because after side you would have to pay

00:03:56,459 --> 00:04:01,320
rate which is not allowed so instead you

00:03:58,380 --> 00:04:03,329
go up to Ray and then you back track

00:04:01,320 --> 00:04:04,890
down to son this is the permutation that

00:04:03,329 --> 00:04:07,020
you would be allowed to play in Yemen

00:04:04,890 --> 00:04:10,110
and in fact this pattern

00:04:07,020 --> 00:04:13,200
NASA is one of the motifs of Yellin and

00:04:10,110 --> 00:04:16,620
if you hear that often times it's likely

00:04:13,200 --> 00:04:19,590
that what you're hearing is Yemen so

00:04:16,620 --> 00:04:22,890
these are the two facets of raagas that

00:04:19,590 --> 00:04:25,470
I extract and analyze in the algorithm

00:04:22,890 --> 00:04:27,210
and what I'm able to do is take

00:04:25,470 --> 00:04:29,880
recording with Indian classical music

00:04:27,210 --> 00:04:35,550
and classify them into which raga is ve

00:04:29,880 --> 00:04:38,610
played so let's do a demo what I fit

00:04:35,550 --> 00:04:40,890
here is I'm playing a recording by

00:04:38,610 --> 00:04:42,720
aashiqui chakravarthy she's one of the

00:04:40,890 --> 00:04:45,150
leading artists of the younger

00:04:42,720 --> 00:04:47,280
generation and here she is singing raga

00:04:45,150 --> 00:04:48,750
I should pasaba and the reason I think

00:04:47,280 --> 00:04:50,190
this is it's an afternoon rock so

00:04:48,750 --> 00:04:51,750
dragons are also associated with

00:04:50,190 --> 00:04:53,220
different types of days so something

00:04:51,750 --> 00:04:55,920
fitting for this time it should the

00:04:53,220 --> 00:04:58,260
center what I've actually set up with my

00:04:55,920 --> 00:05:00,180
audio system is I output my computer

00:04:58,260 --> 00:05:02,820
audio to a program called Stan flower

00:05:00,180 --> 00:05:04,500
which allows me to audio I'll put it to

00:05:02,820 --> 00:05:06,840
the microphone so that you guys can cure

00:05:04,500 --> 00:05:09,930
it but it also allows me to type in that

00:05:06,840 --> 00:05:13,220
audio as a microphone to my algorithm so

00:05:09,930 --> 00:05:16,320
I'm able to read back them up audio

00:05:13,220 --> 00:05:18,540
alright so I'm going to go ahead and

00:05:16,320 --> 00:05:20,730
launch this and actually forgot to talk

00:05:18,540 --> 00:05:24,780
about one thing so if I go back to my

00:05:20,730 --> 00:05:27,540
keyboard hear me put this if I go back

00:05:24,780 --> 00:05:29,190
to my keyboard here eyelid it out on a

00:05:27,540 --> 00:05:30,660
normal Western keyboard so you have

00:05:29,190 --> 00:05:32,850
these notes that would be associated

00:05:30,660 --> 00:05:34,110
with specific frequencies one of the

00:05:32,850 --> 00:05:36,330
interesting things about any classical

00:05:34,110 --> 00:05:38,190
music though is that these notes on a

00:05:36,330 --> 00:05:39,780
gum wad then you saw are not associated

00:05:38,190 --> 00:05:41,820
with specific frequency here I've just

00:05:39,780 --> 00:05:44,070
laid them out as a keyboard but all

00:05:41,820 --> 00:05:46,140
these notes are actually relative to

00:05:44,070 --> 00:05:48,530
this bass note of stop so different

00:05:46,140 --> 00:05:51,540
artists will sing their side a different

00:05:48,530 --> 00:05:54,720
frequency for example I Plymouth satara

00:05:51,540 --> 00:05:56,889
where the base notes I is played at D

00:05:54,720 --> 00:05:58,990
and so based on this on

00:05:56,889 --> 00:06:01,050
the notes are relative to that so one

00:05:58,990 --> 00:06:03,249
interesting thing I have to do here is

00:06:01,050 --> 00:06:04,629
when you start up the program when

00:06:03,249 --> 00:06:06,219
you're running this analysis you have to

00:06:04,629 --> 00:06:08,020
have to give the frequency with your son

00:06:06,219 --> 00:06:09,699
is so I'd be doing that at the beginning

00:06:08,020 --> 00:06:10,840
here so I'm going to go ahead and launch

00:06:09,699 --> 00:06:12,129
it now so this is the live

00:06:10,840 --> 00:06:14,379
classification algorithm it's going to

00:06:12,129 --> 00:06:17,650
read the audio and continue the update

00:06:14,379 --> 00:06:20,469
its model of which draaga is being

00:06:17,650 --> 00:06:23,409
played and we'll be able to see that

00:06:20,469 --> 00:06:28,090
here let me try these chemicals seem to

00:06:23,409 --> 00:06:30,729
cover it up all right so on the Left

00:06:28,090 --> 00:06:38,770
you'll be seeing a cutting on from the

00:06:30,729 --> 00:06:40,900
bottom two okay okay it should so what

00:06:38,770 --> 00:06:43,120
you're going to see here is on the left

00:06:40,900 --> 00:06:46,330
it'll be showing the percentage

00:06:43,120 --> 00:06:49,509
distribution of notes being played that

00:06:46,330 --> 00:06:51,069
is heard and on the right after passing

00:06:49,509 --> 00:06:53,379
it through a classifier ensure the

00:06:51,069 --> 00:06:54,879
probabilities of each raga and if

00:06:53,379 --> 00:06:56,080
everything goes right you should see

00:06:54,879 --> 00:06:59,339
should the sign with the high

00:06:56,080 --> 00:07:02,020
probability all right so I'm

00:06:59,339 --> 00:07:04,029
pre-calculated what is kaushiki

00:07:02,020 --> 00:07:06,550
chakrabarty is saw frequencies that's to

00:07:04,029 --> 00:07:10,689
32 Hertz so I'm going to go hit it with

00:07:06,550 --> 00:07:14,229
an end and now I can start playing this

00:07:10,689 --> 00:07:16,589
music let me move this to the top right

00:07:14,229 --> 00:07:16,589
corner

00:07:19,600 --> 00:07:29,690
okay so let's go ahead and start this so

00:07:22,940 --> 00:07:31,220
what she does at the beginning here so

00:07:29,690 --> 00:07:32,780
by seeing all these notes is able to

00:07:31,220 --> 00:07:35,390
quickly browse then it gets to the

00:07:32,780 --> 00:07:37,460
sudden however she's playing right now

00:07:35,390 --> 00:07:39,170
in the ilab section where you don't have

00:07:37,460 --> 00:07:42,320
percussion instruments and you usually

00:07:39,170 --> 00:07:45,350
don't have a fixed base pattern so here

00:07:42,320 --> 00:07:49,940
she's slowly exploring all of the nodes

00:07:45,350 --> 00:07:52,580
and intricacies of this raga and after

00:07:49,940 --> 00:07:54,500
she plays for example me here for a

00:07:52,580 --> 00:07:56,510
North time the algorithm starts getting

00:07:54,500 --> 00:07:57,650
a little bit confused saying okay I

00:07:56,510 --> 00:07:59,450
heard all these notes at the beginning

00:07:57,650 --> 00:08:02,360
but now she's paying me a lot more than

00:07:59,450 --> 00:08:04,490
the other yeah I misinterpreted but as

00:08:02,360 --> 00:08:06,650
soon as she starts coming back to the

00:08:04,490 --> 00:08:08,870
other notes that are into the sign the

00:08:06,650 --> 00:08:16,150
algorithm knocks on and now it knows

00:08:08,870 --> 00:08:19,580
that it is to desire and that is alright

00:08:16,150 --> 00:08:25,160
so now that we know that it works let's

00:08:19,580 --> 00:08:27,020
see how it does it so at the beginning I

00:08:25,160 --> 00:08:28,670
talked about these two facets of Indian

00:08:27,020 --> 00:08:30,200
classical music now when we actually

00:08:28,670 --> 00:08:31,760
pass them into a classifier we need to

00:08:30,200 --> 00:08:33,320
convert these into something the

00:08:31,760 --> 00:08:36,860
computer can understand not just say oh

00:08:33,320 --> 00:08:38,690
yeah this is a very happy rag or sad

00:08:36,860 --> 00:08:41,660
rock computers can understand that so

00:08:38,690 --> 00:08:44,390
what I design in this algorithm is more

00:08:41,660 --> 00:08:46,880
of modeling these two aspects as Markov

00:08:44,390 --> 00:08:48,830
chains and over what Markov chains are

00:08:46,880 --> 00:08:51,200
in a bit but here what we're doing is

00:08:48,830 --> 00:08:52,520
the scale is your order Markov chain

00:08:51,200 --> 00:08:55,490
which is just a percentage distribution

00:08:52,520 --> 00:08:58,340
of the notes and then movement is a

00:08:55,490 --> 00:09:00,620
Markov chain of order 1 plus which is

00:08:58,340 --> 00:09:01,490
able to capture that transitions between

00:09:00,620 --> 00:09:07,250
different

00:09:01,490 --> 00:09:10,430
values so now we're almost ready to jump

00:09:07,250 --> 00:09:11,959
into how this relates to scala but

00:09:10,430 --> 00:09:13,339
before we do that let's take a look at

00:09:11,959 --> 00:09:14,630
the game time because there are a lot of

00:09:13,339 --> 00:09:18,740
steps in here and this is actually where

00:09:14,630 --> 00:09:21,770
Scylla comes in to say how can we define

00:09:18,740 --> 00:09:23,240
this hold processing pipeline so we

00:09:21,770 --> 00:09:26,240
started with a transcription process

00:09:23,240 --> 00:09:28,459
here we have an audio stream i use the

00:09:26,240 --> 00:09:30,110
mcleod method algorithm to extract

00:09:28,459 --> 00:09:32,209
out which frequency is being played in

00:09:30,110 --> 00:09:34,310
each sample and that gives me my

00:09:32,209 --> 00:09:35,930
frequency stream now once i apply thats

00:09:34,310 --> 00:09:38,330
a shift because all the notes are

00:09:35,930 --> 00:09:40,430
relative i get my load stream i do a

00:09:38,330 --> 00:09:42,770
little bit of extra filtering on that

00:09:40,430 --> 00:09:44,570
because in Indian classical music one of

00:09:42,770 --> 00:09:47,660
the concepts is that of a mean so

00:09:44,570 --> 00:09:51,080
instead of displaying saw followed by

00:09:47,660 --> 00:09:53,360
Ray you'll go from saw and glide today

00:09:51,080 --> 00:09:55,730
but in between we might catch for

00:09:53,360 --> 00:09:58,160
example flattery and we don't want to

00:09:55,730 --> 00:10:02,029
record that as a note being played so

00:09:58,160 --> 00:10:04,760
with the little bit of analysis where

00:10:02,029 --> 00:10:06,380
I'm able to extract out those notes if I

00:10:04,760 --> 00:10:09,440
detect that it is on one of those mean

00:10:06,380 --> 00:10:10,730
curves alright so once we do that we get

00:10:09,440 --> 00:10:13,730
our filter treatment this is the input

00:10:10,730 --> 00:10:15,079
notes for our actual classification so

00:10:13,730 --> 00:10:16,880
I've been my model on this with this

00:10:15,079 --> 00:10:18,529
your throat of gin and in this case I'm

00:10:16,880 --> 00:10:21,589
actually only using a first order check

00:10:18,529 --> 00:10:24,260
in the future of higher bigger depth

00:10:21,589 --> 00:10:25,880
genes can be explored but for now first

00:10:24,260 --> 00:10:28,310
order to insert good enough to do some

00:10:25,880 --> 00:10:31,220
basic classification and so this is my

00:10:28,310 --> 00:10:33,380
model then I pass this in as training

00:10:31,220 --> 00:10:35,480
models to my classifier to teach the

00:10:33,380 --> 00:10:37,209
classifier what each agha is and then

00:10:35,480 --> 00:10:39,320
they also act as input models and

00:10:37,209 --> 00:10:41,660
whatever the classifier receives an

00:10:39,320 --> 00:10:46,190
input model it outputs which raga is we

00:10:41,660 --> 00:10:49,329
can play with what probability alright

00:10:46,190 --> 00:10:52,850
so now we get to jump into some code so

00:10:49,329 --> 00:10:55,339
the first step of this processing

00:10:52,850 --> 00:10:58,480
pipeline is getting the input data and

00:10:55,339 --> 00:11:03,279
one thing I wanted to make sure is I

00:10:58,480 --> 00:11:06,310
be agnostic of whether it's from an mp3

00:11:03,279 --> 00:11:08,139
file or from a live microphone input we

00:11:06,310 --> 00:11:10,779
need to be able to have a common way to

00:11:08,139 --> 00:11:12,940
describe these two types of data so i

00:11:10,779 --> 00:11:15,490
use a scholar iterator which represents

00:11:12,940 --> 00:11:17,649
a stream of data and there's not

00:11:15,490 --> 00:11:20,620
necessarily an end to this so what I do

00:11:17,649 --> 00:11:25,060
here is I create an iterator of a bunch

00:11:20,620 --> 00:11:27,070
of frames of audio data and I continue

00:11:25,060 --> 00:11:29,279
take it one at the successes as soon as

00:11:27,070 --> 00:11:32,230
it fails i know that i was playing a

00:11:29,279 --> 00:11:37,180
finite audio source and then i shut off

00:11:32,230 --> 00:11:40,810
the iterator so now once we do our whole

00:11:37,180 --> 00:11:42,399
processing our transcription part then

00:11:40,810 --> 00:11:46,269
we get into some of the more

00:11:42,399 --> 00:11:48,399
classification parts so i first go over

00:11:46,269 --> 00:11:50,699
one how markov chain works let's say we

00:11:48,399 --> 00:11:53,380
have these three states Sade and god

00:11:50,699 --> 00:11:55,839
what a Markov chain is able to describe

00:11:53,380 --> 00:11:59,199
is the motions between these three

00:11:55,839 --> 00:12:02,410
states so let's go from stock today to

00:11:59,199 --> 00:12:04,120
go back today and back to some what a

00:12:02,410 --> 00:12:06,279
Markov chain does is assign

00:12:04,120 --> 00:12:08,800
probabilities of these transitions so

00:12:06,279 --> 00:12:10,480
here we went from sowwy only want to

00:12:08,800 --> 00:12:12,880
raise that one hundred percent

00:12:10,480 --> 00:12:14,889
probability from Ray we went once to go

00:12:12,880 --> 00:12:16,990
once to sasha's fifty percent each and

00:12:14,889 --> 00:12:18,880
from God we always went to it so that's

00:12:16,990 --> 00:12:20,079
one hundred percent probability so this

00:12:18,880 --> 00:12:23,940
is how we're able to describe the

00:12:20,079 --> 00:12:27,839
transitions between nodes within errado

00:12:23,940 --> 00:12:30,160
and so now for building markov chains

00:12:27,839 --> 00:12:32,470
this is where the real scholar

00:12:30,160 --> 00:12:34,480
collections come in because what i'm

00:12:32,470 --> 00:12:37,540
going to do here is start with this

00:12:34,480 --> 00:12:41,680
input list of nodes and with just a

00:12:37,540 --> 00:12:43,690
bunch of calls to scholar collection

00:12:41,680 --> 00:12:46,600
api's i'm going to transform this into

00:12:43,690 --> 00:12:48,699
the markov chain so let's start by doing

00:12:46,600 --> 00:12:50,139
a sliding operation this will group it

00:12:48,699 --> 00:12:53,260
into all of the transitions that are

00:12:50,139 --> 00:12:55,360
occurring then I want to count how much

00:12:53,260 --> 00:12:58,720
of how many of each of these are

00:12:55,360 --> 00:13:00,430
occurring then I want to say okay which

00:12:58,720 --> 00:13:01,750
one of these are striving from Solomon's

00:13:00,430 --> 00:13:04,269
are starting from gray which ones are

00:13:01,750 --> 00:13:06,490
straying from God and then the last step

00:13:04,269 --> 00:13:08,110
is just dividing them all up so I say

00:13:06,490 --> 00:13:10,569
saw goes today with a percent

00:13:08,110 --> 00:13:12,010
probability raiga saw it fifty percent

00:13:10,569 --> 00:13:15,459
and got today with one hundred percent

00:13:12,010 --> 00:13:18,899
and so by just changing this these four

00:13:15,459 --> 00:13:21,910
steps I'm able to go from a list of

00:13:18,899 --> 00:13:23,980
notes to a Markov chain describing it

00:13:21,910 --> 00:13:26,670
and this is the true power of Scala that

00:13:23,980 --> 00:13:29,230
without getting too much into all these

00:13:26,670 --> 00:13:30,610
mutable maps you're updating everything

00:13:29,230 --> 00:13:31,959
you're just able to say I had this

00:13:30,610 --> 00:13:33,490
immutable collection I do these

00:13:31,959 --> 00:13:39,279
operations and I get a Markov chain and

00:13:33,490 --> 00:13:42,189
you're done so when we apply this these

00:13:39,279 --> 00:13:45,519
are the markov change that come on so

00:13:42,189 --> 00:13:47,110
this is a graph of this your order

00:13:45,519 --> 00:13:49,800
markov chain which is the percentage

00:13:47,110 --> 00:13:52,899
distribution and based on this profit

00:13:49,800 --> 00:13:55,449
percentages so here red is the recording

00:13:52,899 --> 00:13:57,189
and blue is expected where we can see

00:13:55,449 --> 00:13:59,139
that we can use these types of markov

00:13:57,189 --> 00:14:01,269
chains to get an idea of what's going on

00:13:59,139 --> 00:14:02,620
in the raga and a really good thing

00:14:01,269 --> 00:14:04,360
about Mark of James's they're not

00:14:02,620 --> 00:14:07,149
specific to Indian classical music

00:14:04,360 --> 00:14:10,750
they're used in all sorts of places from

00:14:07,149 --> 00:14:12,250
whether to buy informatics Markov chains

00:14:10,750 --> 00:14:13,930
are really great for describing all

00:14:12,250 --> 00:14:15,220
sorts of data and this that's where this

00:14:13,930 --> 00:14:17,170
algorithm has so many possibilities

00:14:15,220 --> 00:14:21,519
beyond just indian classical music you

00:14:17,170 --> 00:14:23,860
can apply a lot of places and when we

00:14:21,519 --> 00:14:25,930
classify it the algorithm is almost ten

00:14:23,860 --> 00:14:27,490
to the ten times more confident about it

00:14:25,930 --> 00:14:29,380
being yaman which is what it was being

00:14:27,490 --> 00:14:35,189
played any other runner is on a

00:14:29,380 --> 00:14:38,079
logarithmic scale alright so that was

00:14:35,189 --> 00:14:41,829
musical analysis with Scala collections

00:14:38,079 --> 00:14:45,490
now we start getting into more more the

00:14:41,829 --> 00:14:50,500
web stuff with acha HTTP and Scala GS so

00:14:45,490 --> 00:14:52,029
in this project I built a web-based

00:14:50,500 --> 00:14:54,880
dashboard that could be used for

00:14:52,029 --> 00:14:59,350
streaming live sensor data from a

00:14:54,880 --> 00:15:00,550
running robot so before we go into what

00:14:59,350 --> 00:15:02,439
this project is I want to give a little

00:15:00,550 --> 00:15:05,199
bit of background on wireless project

00:15:02,439 --> 00:15:08,529
was created I'm software lead on first

00:15:05,199 --> 00:15:09,130
robotics team 846 the funky monkeys it's

00:15:08,529 --> 00:15:11,950
a robotics

00:15:09,130 --> 00:15:13,660
part of my high school every year the

00:15:11,950 --> 00:15:15,730
organization that runs this competition

00:15:13,660 --> 00:15:18,520
releases a game which were supposed to

00:15:15,730 --> 00:15:21,190
design a robot to compete it and we're

00:15:18,520 --> 00:15:24,340
given six weeks we have to chat it

00:15:21,190 --> 00:15:26,290
design manufacture code up the whole

00:15:24,340 --> 00:15:27,850
robot and then we ship it off to two

00:15:26,290 --> 00:15:31,240
competitions so this is a robot this

00:15:27,850 --> 00:15:33,550
year the game was to be able to pick up

00:15:31,240 --> 00:15:35,710
boulders which are just foam balls and

00:15:33,550 --> 00:15:37,810
shoot them into high goals on the

00:15:35,710 --> 00:15:39,640
opponent's side so here our robots able

00:15:37,810 --> 00:15:42,310
to collect involves from this front in

00:15:39,640 --> 00:15:45,090
day and that part actually lifts up to

00:15:42,310 --> 00:15:47,550
shoot two balls into the high walls

00:15:45,090 --> 00:15:50,710
another thing we're really grateful this

00:15:47,550 --> 00:15:53,470
grateful for this year is time see if

00:15:50,710 --> 00:15:55,840
download a slight bend is a sponsor of

00:15:53,470 --> 00:15:57,340
our team and we're actually pretty

00:15:55,840 --> 00:16:00,810
heavily invested into the whole

00:15:57,340 --> 00:16:03,490
functional reactive platform we use a

00:16:00,810 --> 00:16:06,850
library that allows us to model our

00:16:03,490 --> 00:16:10,780
robotics components in a reactive way

00:16:06,850 --> 00:16:13,510
and we're using Scala and HTTP for this

00:16:10,780 --> 00:16:18,040
dashboard and now with that background

00:16:13,510 --> 00:16:20,590
out of the way let's do a demo so here

00:16:18,040 --> 00:16:23,230
since I can't bring a 100 pound robot

00:16:20,590 --> 00:16:24,910
with me to the stage I'm going to be

00:16:23,230 --> 00:16:28,150
displaying some stats about my computer

00:16:24,910 --> 00:16:33,600
on the starboard so I'm going to go

00:16:28,150 --> 00:16:39,120
ahead and launch the dashboard and once

00:16:33,600 --> 00:16:41,530
it compiles okay so once it's put it up

00:16:39,120 --> 00:16:43,630
that's on full screen I'm going to go

00:16:41,530 --> 00:16:45,460
ahead and open up the localhost 8080 and

00:16:43,630 --> 00:16:47,260
this civil from he left one looks like

00:16:45,460 --> 00:16:50,140
the idea of funky dashboard is to be

00:16:47,260 --> 00:16:52,720
able to easily view data coming live

00:16:50,140 --> 00:16:54,430
from any source and this can be used

00:16:52,720 --> 00:16:57,070
anywhere let's say you have some server

00:16:54,430 --> 00:16:59,650
running on AWS and you want to see

00:16:57,070 --> 00:17:01,150
what's the number of requests per minute

00:16:59,650 --> 00:17:03,580
that you're having you can use funky

00:17:01,150 --> 00:17:05,380
effort to view that in this case 7

00:17:03,580 --> 00:17:07,959
saying what percentage of my memory is

00:17:05,380 --> 00:17:11,530
free right now I'm so here I just have a

00:17:07,959 --> 00:17:13,510
graph that displays at data and

00:17:11,530 --> 00:17:16,270
desperate all sense of ability to stream

00:17:13,510 --> 00:17:18,430
video data so here I'm running a vision

00:17:16,270 --> 00:17:20,920
algorithm and it's putting a green boxer

00:17:18,430 --> 00:17:22,930
on my face so this is with opencv it

00:17:20,920 --> 00:17:24,790
detected my face and it's live streaming

00:17:22,930 --> 00:17:28,030
the output of that vision algorithm to

00:17:24,790 --> 00:17:30,580
the browser so that's the idea funky

00:17:28,030 --> 00:17:39,190
dashboard ok let me go ahead and shut

00:17:30,580 --> 00:17:41,290
this down now so what made us what made

00:17:39,190 --> 00:17:43,980
it possible to build funky dashboard

00:17:41,290 --> 00:17:47,050
this year was the switch to a new

00:17:43,980 --> 00:17:50,500
robotics control system so in past years

00:17:47,050 --> 00:17:52,800
we use a pretty small control system

00:17:50,500 --> 00:17:56,500
called the cereal which could only run a

00:17:52,800 --> 00:17:58,570
modified version of a Java 5 a virtual

00:17:56,500 --> 00:18:01,410
machine so we couldn't really do very

00:17:58,570 --> 00:18:05,470
much on that system no scholar for us

00:18:01,410 --> 00:18:08,080
but this year they put in a surprise and

00:18:05,470 --> 00:18:11,410
now we have this brand new squeaky clean

00:18:08,080 --> 00:18:14,380
Robo Rio controller which runs on linux

00:18:11,410 --> 00:18:16,750
and java SE eight so we can put all we

00:18:14,380 --> 00:18:20,770
wanted the robot this this year our

00:18:16,750 --> 00:18:22,720
robot actually runs up so it has main

00:18:20,770 --> 00:18:24,790
robot code is written with java we also

00:18:22,720 --> 00:18:27,060
have some scala we run an aqua HTTP

00:18:24,790 --> 00:18:30,010
webserver we have actors running on this

00:18:27,060 --> 00:18:32,200
system to handle efficient processing

00:18:30,010 --> 00:18:34,560
all sorts of stuff and it's really

00:18:32,200 --> 00:18:38,560
because of this switch to java SE eight

00:18:34,560 --> 00:18:40,450
so funky deptford was born and i'm

00:18:38,560 --> 00:18:44,020
really in the past few years we noticed

00:18:40,450 --> 00:18:45,550
that ok we june of this control loop we

00:18:44,020 --> 00:18:48,490
put on the robot and it doesn't do what

00:18:45,550 --> 00:18:49,870
we expected to do and most of the time

00:18:48,490 --> 00:18:52,480
it wasn't because our software was

00:18:49,870 --> 00:18:54,010
values sometimes we would unplug a wire

00:18:52,480 --> 00:18:57,340
or something like that but we would

00:18:54,010 --> 00:18:58,840
never know and when this often was bad

00:18:57,340 --> 00:19:00,370
we would blame it on the left

00:18:58,840 --> 00:19:02,350
guys saying you guys didn't wire up the

00:19:00,370 --> 00:19:06,430
robot right so there is never this

00:19:02,350 --> 00:19:09,430
clarity of what was going wrong whenever

00:19:06,430 --> 00:19:11,080
we were tuning anything so with funky

00:19:09,430 --> 00:19:13,180
network we had this ability to simply

00:19:11,080 --> 00:19:15,490
notable web page on an ipad or laptop

00:19:13,180 --> 00:19:20,590
wherever and we can know exactly what

00:19:15,490 --> 00:19:23,680
the robot perceives is happening now the

00:19:20,590 --> 00:19:26,170
way that all the streaming data and

00:19:23,680 --> 00:19:28,360
funky dashboard is model is you provide

00:19:26,170 --> 00:19:30,010
functions which say whenever any new

00:19:28,360 --> 00:19:32,440
data needs to be published this is the

00:19:30,010 --> 00:19:34,540
function you use to get that data so

00:19:32,440 --> 00:19:36,550
funny dashboard starts out with the

00:19:34,540 --> 00:19:39,760
timer this runs every 125 milliseconds

00:19:36,550 --> 00:19:43,210
whatever the timer goes off each of the

00:19:39,760 --> 00:19:46,810
functions is called which produces your

00:19:43,210 --> 00:19:48,880
JSON data so each card or each type of

00:19:46,810 --> 00:19:50,380
card can produce a JSON package saying

00:19:48,880 --> 00:19:53,320
one needs to be sent over to the client

00:19:50,380 --> 00:19:55,510
now we funnel together all of these JSON

00:19:53,320 --> 00:19:57,820
objects and we send it over a WebSocket

00:19:55,510 --> 00:20:00,370
here is just as text messages now the

00:19:57,820 --> 00:20:03,010
client when it first boots up it loads

00:20:00,370 --> 00:20:05,110
up a JSON file which specifies which

00:20:03,010 --> 00:20:07,480
data sets are going to be displayed in

00:20:05,110 --> 00:20:08,830
the dashboard so first of all it already

00:20:07,480 --> 00:20:10,240
knows what's going to be displayed and

00:20:08,830 --> 00:20:15,850
then whenever it receives this updated

00:20:10,240 --> 00:20:17,440
I'll get all of the graphs one of the

00:20:15,850 --> 00:20:18,790
things we wanted to make sure was a

00:20:17,440 --> 00:20:22,300
feature phone in effort with the ability

00:20:18,790 --> 00:20:24,280
to really easily add a data set and so

00:20:22,300 --> 00:20:27,190
now when we're when we want to add any

00:20:24,280 --> 00:20:30,310
ideas that you notice this is Java first

00:20:27,190 --> 00:20:32,170
of all our high school actually uses

00:20:30,310 --> 00:20:34,960
Java first computer science courses so

00:20:32,170 --> 00:20:36,670
we've got our robot in Java we're

00:20:34,960 --> 00:20:40,060
looking at moving to Scotland next year

00:20:36,670 --> 00:20:43,840
though so here whenever we want to add

00:20:40,060 --> 00:20:45,820
in a new data set we first specified

00:20:43,840 --> 00:20:46,810
verb so that's the left sidebar that you

00:20:45,820 --> 00:20:48,640
see where you have a lot of different

00:20:46,810 --> 00:20:50,170
groups then you add a data set you

00:20:48,640 --> 00:20:52,250
specify oh I'm constructing a time

00:20:50,170 --> 00:20:54,470
series in numeric which represents those

00:20:52,250 --> 00:20:56,510
line graphs we say this is the title

00:20:54,470 --> 00:20:57,830
potentiometer endeth and this is where

00:20:56,510 --> 00:21:00,800
the core part of where the data comes

00:20:57,830 --> 00:21:03,650
from this is a function so this is the

00:21:00,800 --> 00:21:06,080
Java wheels that are getting a function

00:21:03,650 --> 00:21:08,600
from this method get' angle so we say

00:21:06,080 --> 00:21:10,160
whatever you need to display this data

00:21:08,600 --> 00:21:13,730
set this is the function where you get

00:21:10,160 --> 00:21:16,940
the current data form and so when we

00:21:13,730 --> 00:21:19,490
move over to the Aqua HTTP and acha

00:21:16,940 --> 00:21:23,030
streamside when you want to construct

00:21:19,490 --> 00:21:25,310
our JSON stream without country TP it's

00:21:23,030 --> 00:21:28,010
as simple as constructing a source and a

00:21:25,310 --> 00:21:30,080
sink so we're what data do you want to

00:21:28,010 --> 00:21:33,230
send over to the browser and what do you

00:21:30,080 --> 00:21:34,940
want to do with any data so here what

00:21:33,230 --> 00:21:37,670
I'm doing is we have this timer every

00:21:34,940 --> 00:21:40,190
125 milliseconds we say every 125

00:21:37,670 --> 00:21:41,900
milliseconds you want to get the current

00:21:40,190 --> 00:21:43,460
data sets JSON and put it as a string

00:21:41,900 --> 00:21:46,250
and that's the message that you send

00:21:43,460 --> 00:21:47,930
over to the browser and that's a really

00:21:46,250 --> 00:21:50,150
great part about a kite should keep en

00:21:47,930 --> 00:21:52,610
after streams and since simple as that I

00:21:50,150 --> 00:21:56,480
want to construct a timer based flow

00:21:52,610 --> 00:21:58,370
that sends over that data done and then

00:21:56,480 --> 00:22:00,530
when I want to actually connect that to

00:21:58,370 --> 00:22:02,630
a WebSocket just a few more lines of

00:22:00,530 --> 00:22:04,640
code I say this is a text message not a

00:22:02,630 --> 00:22:08,090
binary message and then I say whenever I

00:22:04,640 --> 00:22:10,190
get a WebSocket request i use my source

00:22:08,090 --> 00:22:11,840
and I funky after this only one way

00:22:10,190 --> 00:22:14,270
there's no way to send back data as if

00:22:11,840 --> 00:22:19,310
now so we ignore any incoming messages

00:22:14,270 --> 00:22:22,280
and we're done now we get to even more

00:22:19,310 --> 00:22:23,870
Scala so on our climb said we wanted to

00:22:22,280 --> 00:22:25,820
use something which shared a kind of a

00:22:23,870 --> 00:22:29,060
similar background as our server which

00:22:25,820 --> 00:22:30,950
was in Java so we used Scala GS and for

00:22:29,060 --> 00:22:33,080
displaying the line charts we use the

00:22:30,950 --> 00:22:40,280
flock library which is built on top of

00:22:33,080 --> 00:22:42,530
jQuery now it's Karagias the really

00:22:40,280 --> 00:22:45,710
powerful thing is that you get the

00:22:42,530 --> 00:22:47,710
ability to have interop with whatever

00:22:45,710 --> 00:22:51,020
javascript is running in your browser

00:22:47,710 --> 00:22:51,940
but you have the ability to use them in

00:22:51,020 --> 00:22:53,620
a time

00:22:51,940 --> 00:22:56,019
so in this case when I'm accessing da

00:22:53,620 --> 00:22:58,360
maybe eyes there's already a library

00:22:56,019 --> 00:23:00,909
which provides static facades for this

00:22:58,360 --> 00:23:04,149
so when I do document upgrade element I

00:23:00,909 --> 00:23:05,980
can do create the element or any other

00:23:04,149 --> 00:23:08,289
misspelling of that because the compiler

00:23:05,980 --> 00:23:10,360
will shout at me not undefined is not a

00:23:08,289 --> 00:23:12,460
function that will never show up but I

00:23:10,360 --> 00:23:14,919
know here before I even load it up in my

00:23:12,460 --> 00:23:18,190
browser so here I'm building up an image

00:23:14,919 --> 00:23:20,649
and this is what I use for my computer

00:23:18,190 --> 00:23:22,570
vision whenever I receive new data which

00:23:20,649 --> 00:23:26,019
is just a string so basics before I

00:23:22,570 --> 00:23:27,399
scored a PNG I set it up and and another

00:23:26,019 --> 00:23:29,980
really great part about scholarships

00:23:27,399 --> 00:23:33,399
it's pure scala every feature other than

00:23:29,980 --> 00:23:35,590
reflection is available so if i want to

00:23:33,399 --> 00:23:38,679
use a string interpolation i do that and

00:23:35,590 --> 00:23:41,110
I embed my new data so I'm able to do

00:23:38,679 --> 00:23:46,179
anything I would in normal Scala but

00:23:41,110 --> 00:23:49,090
this all runs within the browser and now

00:23:46,179 --> 00:23:51,879
if I want to create my own static desire

00:23:49,090 --> 00:23:54,460
for flocked for example it's as simple

00:23:51,879 --> 00:23:57,009
as this I say I know this is part of the

00:23:54,460 --> 00:23:58,870
dollar dot so I don't have to I'm query

00:23:57,009 --> 00:24:02,350
an element to use this method so it's

00:23:58,870 --> 00:24:05,379
jquery Stanek which is a class in the

00:24:02,350 --> 00:24:07,659
scala GS jquery library and all i say is

00:24:05,379 --> 00:24:09,460
i define this method plot which takes

00:24:07,659 --> 00:24:12,909
which element i want to put it in and

00:24:09,460 --> 00:24:14,950
the data and all i have to do is to make

00:24:12,909 --> 00:24:17,590
this map to a javascript function is

00:24:14,950 --> 00:24:19,450
that that JSTOR native at the end and by

00:24:17,590 --> 00:24:22,330
putting that I'm able to create a

00:24:19,450 --> 00:24:24,039
statically typed facade now one thing

00:24:22,330 --> 00:24:26,289
you'll notice is I cut corners a little

00:24:24,039 --> 00:24:27,909
bit here I'm not doing area of the

00:24:26,289 --> 00:24:30,190
proper flow time I'm just doing JSTOR

00:24:27,909 --> 00:24:32,019
dynamic Andrey it's because what the day

00:24:30,190 --> 00:24:34,779
I wrote this time facade I was too lazy

00:24:32,019 --> 00:24:36,789
to actually buy that whole depth of

00:24:34,779 --> 00:24:39,370
types and this is another nice thing

00:24:36,789 --> 00:24:41,470
about Skylar geous it doesn't force the

00:24:39,370 --> 00:24:43,509
pony that or if you want to use anything

00:24:41,470 --> 00:24:46,240
you have to create all these direct

00:24:43,509 --> 00:24:47,860
facades you do it as we need it so if

00:24:46,240 --> 00:24:49,299
later i'm starting to create more

00:24:47,860 --> 00:24:51,340
complex types and i'm running into

00:24:49,299 --> 00:24:53,560
problems where this dynamics

00:24:51,340 --> 00:24:55,960
can't stay there anymore I just replace

00:24:53,560 --> 00:24:59,320
that with my own time but this works as

00:24:55,960 --> 00:25:03,730
well I'm able to use it just normally

00:24:59,320 --> 00:25:07,890
within my code and now for some live

00:25:03,730 --> 00:25:10,330
coding so here I showed the ability to

00:25:07,890 --> 00:25:12,010
put up the free memory in from the

00:25:10,330 --> 00:25:14,590
dashboard and now I'm going to add in

00:25:12,010 --> 00:25:17,770
another data set which shows what the

00:25:14,590 --> 00:25:20,050
current cpu load is on the system so i'm

00:25:17,770 --> 00:25:21,280
going to do dashboard it is a group and

00:25:20,050 --> 00:25:25,390
here i'm now if you're doing it in scala

00:25:21,280 --> 00:25:29,230
because you can use java from scala here

00:25:25,390 --> 00:25:33,640
i'm going to say activity and data set

00:25:29,230 --> 00:25:38,560
new your time series numeric alright so

00:25:33,640 --> 00:25:40,360
this is going to be a cpu load and every

00:25:38,560 --> 00:25:41,920
time i receive a tick the function to

00:25:40,360 --> 00:25:44,140
get the data here after you developed a

00:25:41,920 --> 00:25:45,700
number because since on the job and we

00:25:44,140 --> 00:25:48,640
use the Java number we have to do a

00:25:45,700 --> 00:25:52,410
conversion of that but all I need to do

00:25:48,640 --> 00:25:55,720
is OS bean get system cpu load and

00:25:52,410 --> 00:25:57,640
that's it and with those lines of code i

00:25:55,720 --> 00:25:59,230
just relaunch it no need to recompile

00:25:57,640 --> 00:26:01,870
the client or anything like that you

00:25:59,230 --> 00:26:03,910
just reboot your server and i shall v

00:26:01,870 --> 00:26:06,690
load here we can see the current cpu

00:26:03,910 --> 00:26:06,690
load on my system

00:26:11,490 --> 00:26:19,559
alright so that's funky dashboard and

00:26:15,120 --> 00:26:21,870
now with 15 minutes that we get to the

00:26:19,559 --> 00:26:24,809
last section which is a home automation

00:26:21,870 --> 00:26:26,880
system built with akka and scale ages

00:26:24,809 --> 00:26:28,800
and this is kind of a couple of

00:26:26,880 --> 00:26:31,050
combining everything here now we have a

00:26:28,800 --> 00:26:32,850
bunch of different entities around your

00:26:31,050 --> 00:26:35,130
house all moving in different ways and

00:26:32,850 --> 00:26:37,290
the idea of acts which is the home

00:26:35,130 --> 00:26:39,360
automation platform I bid is to provide

00:26:37,290 --> 00:26:41,400
a unifying platform to say i have this

00:26:39,360 --> 00:26:43,260
philips hue lines and this raspberry pi

00:26:41,400 --> 00:26:46,230
how do I get them to work with each

00:26:43,260 --> 00:26:49,350
other now ashes didn't it in its infancy

00:26:46,230 --> 00:26:51,030
it's really just some fun summer project

00:26:49,350 --> 00:26:53,550
i started to work on and I'm just

00:26:51,030 --> 00:26:58,410
continuing to build on it but even with

00:26:53,550 --> 00:27:00,540
a simple platform which can just can

00:26:58,410 --> 00:27:01,980
start to have different platforms

00:27:00,540 --> 00:27:04,800
talking with each other there's some

00:27:01,980 --> 00:27:08,280
really interesting patterns that show up

00:27:04,800 --> 00:27:11,880
and in this case it's using the actor

00:27:08,280 --> 00:27:14,400
the concept of actors to abstract out

00:27:11,880 --> 00:27:17,760
how communication works between all

00:27:14,400 --> 00:27:19,740
these different devices but before we

00:27:17,760 --> 00:27:24,270
get into all that actor stuff let's do a

00:27:19,740 --> 00:27:25,590
demo so here I need to switch out to my

00:27:24,270 --> 00:27:28,770
input device to the internal microphone

00:27:25,590 --> 00:27:34,380
because ash has voice commands I'm going

00:27:28,770 --> 00:27:36,330
to boot up my server SPT ash JVM run so

00:27:34,380 --> 00:27:40,050
this is it acha HTTP server that i'm

00:27:36,330 --> 00:27:43,350
going to put up once it loads i can go

00:27:40,050 --> 00:27:46,230
ahead and open it let me go ahead and

00:27:43,350 --> 00:27:48,800
open up crow again in the past his hand

00:27:46,230 --> 00:27:51,800
for office with detecting new inputs

00:27:48,800 --> 00:27:51,800
okay

00:27:53,240 --> 00:28:00,950
so here I forgot to combine this before

00:27:56,690 --> 00:28:03,590
i start at the stock so let's open up

00:28:00,950 --> 00:28:06,620
the fast alpha version so here I did sax

00:28:03,590 --> 00:28:08,480
run so this is mostly for development

00:28:06,620 --> 00:28:10,430
mode where I'm making changes to the

00:28:08,480 --> 00:28:12,920
client to the server on to be able to

00:28:10,430 --> 00:28:14,720
quickly test out new changes so here we

00:28:12,920 --> 00:28:17,870
use the strategist fast optimal which

00:28:14,720 --> 00:28:21,800
gives you a small-ish javascript file

00:28:17,870 --> 00:28:23,300
with a couple of seconds whereas if you

00:28:21,800 --> 00:28:26,090
want to run something on a production

00:28:23,300 --> 00:28:28,010
server you would use full off which runs

00:28:26,090 --> 00:28:29,930
cuckoo closure compiler and then outputs

00:28:28,010 --> 00:28:31,640
that then that can end up smaller but

00:28:29,930 --> 00:28:34,160
here since I'm just running testing out

00:28:31,640 --> 00:28:38,090
things locally I can use this let me go

00:28:34,160 --> 00:28:39,680
ahead and load this up so the first

00:28:38,090 --> 00:28:41,360
thing it's going to do the server is

00:28:39,680 --> 00:28:43,040
going to load up what song is for

00:28:41,360 --> 00:28:45,290
anything on Spotify since I can't bring

00:28:43,040 --> 00:28:46,670
any raspberry PI's or motors with me

00:28:45,290 --> 00:28:48,050
here and there's going to be testing out

00:28:46,670 --> 00:28:50,090
something locally so here I'm going to

00:28:48,050 --> 00:28:53,120
be controlling on the Spotify desktop

00:28:50,090 --> 00:28:54,560
application running on my computer so

00:28:53,120 --> 00:28:56,390
let's start by just controlling it

00:28:54,560 --> 00:28:59,300
through the web UI so this is something

00:28:56,390 --> 00:29:01,190
new so last year I did a demo of a

00:28:59,300 --> 00:29:03,110
really basic version of ash where I

00:29:01,190 --> 00:29:05,060
decided text box saying what did you see

00:29:03,110 --> 00:29:06,890
it and it said that command over to a

00:29:05,060 --> 00:29:10,520
place ever since then I've rewritten it

00:29:06,890 --> 00:29:12,440
and now it has this proper you I so I

00:29:10,520 --> 00:29:14,680
can start by just playing some music I

00:29:12,440 --> 00:29:17,840
can skip back I can skip forward

00:29:14,680 --> 00:29:19,940
whatever you do but the really cool

00:29:17,840 --> 00:29:21,920
thing happens the students you start

00:29:19,940 --> 00:29:25,340
using voice commands so let me go ahead

00:29:21,920 --> 00:29:27,110
and load this up so once it loads up

00:29:25,340 --> 00:29:28,430
because I probably filled up with voice

00:29:27,110 --> 00:29:32,660
detection with garbage while I'm

00:29:28,430 --> 00:29:38,630
explaining this okay ash play the next

00:29:32,660 --> 00:29:39,920
song I share to come get much illegal

00:29:38,630 --> 00:29:41,690
mission

00:29:39,920 --> 00:29:43,850
so with that I'm able to skip to the

00:29:41,690 --> 00:29:45,470
next song and it's able to give me back

00:29:43,850 --> 00:29:48,410
some information that I skip to the next

00:29:45,470 --> 00:29:51,100
on now if I go back on African has the

00:29:48,410 --> 00:29:53,150
ability q give contextually aware

00:29:51,100 --> 00:29:55,400
responses so here it'll be able to tell

00:29:53,150 --> 00:30:05,030
me that it went back to someone so i can

00:29:55,400 --> 00:30:07,610
say okay ash play the previous song was

00:30:05,030 --> 00:30:10,220
it recognized to the song changes i went

00:30:07,610 --> 00:30:13,610
back to top 10 anime feet they even get

00:30:10,220 --> 00:30:15,560
by so readily so now it's able to say

00:30:13,610 --> 00:30:17,570
okay I went back and we'll actually see

00:30:15,560 --> 00:30:19,820
how react comes in to make this all

00:30:17,570 --> 00:30:23,180
possible and is able to say I went back

00:30:19,820 --> 00:30:26,720
to this song so that's a quick overview

00:30:23,180 --> 00:30:32,510
of what ash can do and let's go ahead

00:30:26,720 --> 00:30:35,810
and open up so the basic control flow of

00:30:32,510 --> 00:30:37,400
ash is between your client which is

00:30:35,810 --> 00:30:41,870
running chrome and your server which is

00:30:37,400 --> 00:30:45,980
running an op HTTP server now on either

00:30:41,870 --> 00:30:48,020
end on both ends you have your services

00:30:45,980 --> 00:30:49,850
so as to split up into services in this

00:30:48,020 --> 00:30:52,220
case you would have a spotify service a

00:30:49,850 --> 00:30:53,600
Weather Service and these can all

00:30:52,220 --> 00:30:55,970
communicate with each other which is

00:30:53,600 --> 00:30:59,360
what allows for the communication across

00:30:55,970 --> 00:31:01,610
different types of devices let's say we

00:30:59,360 --> 00:31:03,170
have our client Spotify and I made a

00:31:01,610 --> 00:31:06,230
voice command play the next song now

00:31:03,170 --> 00:31:09,020
this client Spotify service need to send

00:31:06,230 --> 00:31:12,530
a message to the server side of Spotify

00:31:09,020 --> 00:31:15,050
service and the way this communication

00:31:12,530 --> 00:31:18,650
across platforms works is through a

00:31:15,050 --> 00:31:21,380
serialization I recall bhumika so it

00:31:18,650 --> 00:31:24,260
allows me to serialize scala objects on

00:31:21,380 --> 00:31:25,580
JavaScript or the JVM side into binary

00:31:24,260 --> 00:31:28,100
data and then I

00:31:25,580 --> 00:31:31,130
said that is over to a binary website so

00:31:28,100 --> 00:31:35,270
smart I sense an actor sends a message

00:31:31,130 --> 00:31:36,470
to the service service messenger and the

00:31:35,270 --> 00:31:38,510
service messenger is kind of the

00:31:36,470 --> 00:31:40,760
intermediary between these two ends it

00:31:38,510 --> 00:31:41,870
handles the pickling and unsafe lane so

00:31:40,760 --> 00:31:43,040
service messenger was because the

00:31:41,870 --> 00:31:44,900
message send it over to the other

00:31:43,040 --> 00:31:46,130
service messenger which unpick ins a

00:31:44,900 --> 00:31:50,060
message and send it over to the

00:31:46,130 --> 00:31:51,770
server-side actor and a really important

00:31:50,060 --> 00:31:53,270
thing when i worked on ash is I wanted

00:31:51,770 --> 00:31:55,100
to make sure it's symmetric on both ends

00:31:53,270 --> 00:31:56,240
so you should be able to write code the

00:31:55,100 --> 00:31:58,010
same way no matter if you're on the

00:31:56,240 --> 00:31:59,090
client to the server so when you're

00:31:58,010 --> 00:32:01,040
sending messages from the server it's

00:31:59,090 --> 00:32:02,660
the exact same flow the server-side

00:32:01,040 --> 00:32:05,210
actor server sends a message deserves

00:32:02,660 --> 00:32:06,950
messenger it pickles it sends over the

00:32:05,210 --> 00:32:11,060
web socket and it's under good and sent

00:32:06,950 --> 00:32:12,710
to the clamp now here when I was talking

00:32:11,060 --> 00:32:14,570
about a service this is what a service

00:32:12,710 --> 00:32:16,760
is composed off you have your JavaScript

00:32:14,570 --> 00:32:19,010
side which has an actor and I'll talk

00:32:16,760 --> 00:32:21,380
about how actors on the JavaScript and

00:32:19,010 --> 00:32:23,780
work in just a bit you have your voice

00:32:21,380 --> 00:32:26,990
handling so you can register up keywords

00:32:23,780 --> 00:32:30,320
and commands for voice detection and you

00:32:26,990 --> 00:32:32,030
have your user interface on the JVM sign

00:32:30,320 --> 00:32:33,830
you again have enacted this part of that

00:32:32,030 --> 00:32:35,840
symmetry that all your communication

00:32:33,830 --> 00:32:38,330
throughout ash will always be through

00:32:35,840 --> 00:32:39,860
after messages and so now whenever

00:32:38,330 --> 00:32:41,750
you're communicating either between your

00:32:39,860 --> 00:32:44,290
services or across from more devices

00:32:41,750 --> 00:32:48,020
it's always through this actor message

00:32:44,290 --> 00:32:49,850
system and with on your jvm and you'll

00:32:48,020 --> 00:32:51,290
probably talk to some third-party API so

00:32:49,850 --> 00:32:53,840
if you want to control Philips hue

00:32:51,290 --> 00:32:55,490
lights you can use that and lastly you

00:32:53,840 --> 00:32:58,790
can do remoting so actually has the

00:32:55,490 --> 00:33:02,240
ability to deploy jars to remote

00:32:58,790 --> 00:33:06,230
raspberry PI's those jars will broadcast

00:33:02,240 --> 00:33:08,450
out UDP data saying oh I'm here and the

00:33:06,230 --> 00:33:11,810
ash central server can tie in that

00:33:08,450 --> 00:33:15,980
remote devices actor to the main server

00:33:11,810 --> 00:33:17,390
and between these two is what makes all

00:33:15,980 --> 00:33:19,460
the communication work is these

00:33:17,390 --> 00:33:21,590
serializers that can be crossed compared

00:33:19,460 --> 00:33:23,240
to both ends with no difference in how

00:33:21,590 --> 00:33:26,140
to work so i'm able to see realize

00:33:23,240 --> 00:33:29,350
something in Scala Gia's send it over

00:33:26,140 --> 00:33:32,830
pickle a ninja jbn and opposite and all

00:33:29,350 --> 00:33:35,290
works in a really nice smooth flow so

00:33:32,830 --> 00:33:37,990
serializing data let's say we have a

00:33:35,290 --> 00:33:40,810
message called next song in this case

00:33:37,990 --> 00:33:42,130
because boo pickle at least when I was

00:33:40,810 --> 00:33:44,320
implementing this year that I said she

00:33:42,130 --> 00:33:46,390
didn't support case objects I have to

00:33:44,320 --> 00:33:49,180
use this case class with open closed

00:33:46,390 --> 00:33:50,920
parenthesis usually you have a trait

00:33:49,180 --> 00:33:52,930
which represents all of the messages

00:33:50,920 --> 00:33:55,630
that a certain service can set so your

00:33:52,930 --> 00:33:58,780
ex transport message I first serialize

00:33:55,630 --> 00:34:00,970
theft and that produces a byte buffer

00:33:58,780 --> 00:34:04,180
but this is not what I send over the

00:34:00,970 --> 00:34:06,310
WebSocket because since it clients what

00:34:04,180 --> 00:34:10,240
if I actor can talk to a server whether

00:34:06,310 --> 00:34:12,130
actor actor there's no guarantee that

00:34:10,240 --> 00:34:14,080
we'll be using the same serialization

00:34:12,130 --> 00:34:16,330
protocol for all messages so that's why

00:34:14,080 --> 00:34:17,500
we have this pickle message part and

00:34:16,330 --> 00:34:19,960
bigger message will contain information

00:34:17,500 --> 00:34:21,820
such as who sent it because on the

00:34:19,960 --> 00:34:23,740
server for example let's say after I

00:34:21,820 --> 00:34:25,480
Hector sends a message to the server the

00:34:23,740 --> 00:34:27,760
server can you send her as you would a

00:34:25,480 --> 00:34:30,310
caca and send a message back to the same

00:34:27,760 --> 00:34:32,140
time to actor so everything you expect

00:34:30,310 --> 00:34:33,460
to work a worse across these two

00:34:32,140 --> 00:34:35,350
platforms and that's what this pickle

00:34:33,460 --> 00:34:37,149
message step does I'm going to also

00:34:35,350 --> 00:34:38,500
includes things such as which protocol

00:34:37,149 --> 00:34:41,159
is is being sent under because the

00:34:38,500 --> 00:34:43,600
Spotify actor could use the weather

00:34:41,159 --> 00:34:47,200
vertical or the Spotify protocol when

00:34:43,600 --> 00:34:50,590
talking to a weather service but once he

00:34:47,200 --> 00:34:54,610
has a speaker message we pickle it again

00:34:50,590 --> 00:34:57,460
into our final byte buffer and this is

00:34:54,610 --> 00:34:59,740
what we send over the web socket as a

00:34:57,460 --> 00:35:02,230
binary message and this is all possible

00:34:59,740 --> 00:35:04,630
because of who pickle pickle is really

00:35:02,230 --> 00:35:07,690
great in model is everything as you have

00:35:04,630 --> 00:35:10,330
all these implicit a macro will generate

00:35:07,690 --> 00:35:12,960
up how the actual serialization process

00:35:10,330 --> 00:35:18,130
works and it works wherever you go um

00:35:12,960 --> 00:35:19,780
scala GS or the GPM now i've been

00:35:18,130 --> 00:35:20,800
talking all about the school actors on

00:35:19,780 --> 00:35:25,510
the clients that accurate

00:35:20,800 --> 00:35:27,610
97 and this is how it works so when I

00:35:25,510 --> 00:35:29,230
started out working with ash last year

00:35:27,610 --> 00:35:30,880
the server side portion was had been

00:35:29,230 --> 00:35:33,610
with actors but the glam said was just

00:35:30,880 --> 00:35:36,160
this inline JavaScript code which would

00:35:33,610 --> 00:35:37,660
send over Ajax requests and I'm really

00:35:36,160 --> 00:35:40,090
messy really has because I couldn't do

00:35:37,660 --> 00:35:41,770
any customization on the content so thus

00:35:40,090 --> 00:35:44,050
ecology has changed I wanted to make

00:35:41,770 --> 00:35:46,660
sure that you have the same way of

00:35:44,050 --> 00:35:49,450
communication on both ends and i miss

00:35:46,660 --> 00:35:51,250
Appa which is a fake acha for strategy

00:35:49,450 --> 00:35:54,750
yes aqua does not try to do anything

00:35:51,250 --> 00:35:59,410
fancy it won't set web workers it won't

00:35:54,750 --> 00:36:01,630
do anything fancy it's just actors state

00:35:59,410 --> 00:36:04,150
machines and actor riffs and even his

00:36:01,630 --> 00:36:07,770
actor reps you can't see realize after

00:36:04,150 --> 00:36:10,810
us or anything it just it gives you the

00:36:07,770 --> 00:36:13,540
abstraction of actors and allows you to

00:36:10,810 --> 00:36:15,760
use that those four concepts but in

00:36:13,540 --> 00:36:18,760
JavaScript and for those of you who

00:36:15,760 --> 00:36:20,710
don't know Appa is a flying bison in the

00:36:18,760 --> 00:36:22,450
TV show avatar the last airbender I've

00:36:20,710 --> 00:36:27,790
actually watched the all four seasons

00:36:22,450 --> 00:36:31,390
twice so in the pretty great show okay

00:36:27,790 --> 00:36:34,930
so first we have Appa this allows us to

00:36:31,390 --> 00:36:36,730
hand our clients of communication in a

00:36:34,930 --> 00:36:40,090
reactive way and often actually only

00:36:36,730 --> 00:36:42,130
through the files of code so that's open

00:36:40,090 --> 00:36:44,800
source and available but now how do we

00:36:42,130 --> 00:36:46,390
handle all of these you is that actually

00:36:44,800 --> 00:36:48,610
get displayed in the browser in a

00:36:46,390 --> 00:36:52,480
reactive functional programming way and

00:36:48,610 --> 00:36:54,370
there we get to react so when doing this

00:36:52,480 --> 00:36:56,350
rewrite i originally actually started

00:36:54,370 --> 00:36:58,450
out which is doing Dom manipulations and

00:36:56,350 --> 00:37:00,070
I did a little bit of Scala RX and I

00:36:58,450 --> 00:37:01,600
actually worked out fine for initial

00:37:00,070 --> 00:37:03,250
prototyping I could set up these

00:37:01,600 --> 00:37:05,980
variables update them whenever

00:37:03,250 --> 00:37:08,140
any messages but as things more and more

00:37:05,980 --> 00:37:10,150
and more complicated it just got a mess

00:37:08,140 --> 00:37:11,860
to maintain because of all this

00:37:10,150 --> 00:37:14,500
mutability and I never knew who is

00:37:11,860 --> 00:37:16,150
changing what when and that's when that

00:37:14,500 --> 00:37:18,310
I have got to the switch to react and

00:37:16,150 --> 00:37:20,440
this library scholar james react really

00:37:18,310 --> 00:37:22,660
made the switch so simple because in

00:37:20,440 --> 00:37:26,230
addition to providing static facades for

00:37:22,660 --> 00:37:28,300
the reactive library it also adds in a

00:37:26,230 --> 00:37:32,170
couple of extra bits to make everything

00:37:28,300 --> 00:37:34,390
feel more at home it feels like you're

00:37:32,170 --> 00:37:37,450
coding with the normal Scala library and

00:37:34,390 --> 00:37:39,010
actually my dad over there has his dog

00:37:37,450 --> 00:37:41,320
flu stocks Colin he'll be talking more

00:37:39,010 --> 00:37:45,310
about react and how we can be used in

00:37:41,320 --> 00:37:49,360
the browser which colleges so you should

00:37:45,310 --> 00:37:52,630
check out his dog so what how do we use

00:37:49,360 --> 00:37:56,770
react it's I mean if you see in Scala

00:37:52,630 --> 00:37:59,170
tax it's almost the same so the creator

00:37:56,770 --> 00:38:01,210
of colleges react to cle how I smell

00:37:59,170 --> 00:38:02,830
attacks delivers the modification to

00:38:01,210 --> 00:38:05,260
make it worth the work with react and

00:38:02,830 --> 00:38:07,150
here you have it in reality of two

00:38:05,260 --> 00:38:08,740
concepts properties which are handed

00:38:07,150 --> 00:38:10,930
down from a parent and state which is

00:38:08,740 --> 00:38:14,800
kept within the component so for example

00:38:10,930 --> 00:38:16,600
with a Spotify car component your

00:38:14,800 --> 00:38:18,610
properties would be things like what

00:38:16,600 --> 00:38:20,350
song is being played what is the

00:38:18,610 --> 00:38:23,950
progress on it and that would be pulled

00:38:20,350 --> 00:38:25,780
out from your remote service or wherever

00:38:23,950 --> 00:38:27,340
you get it from and stage would be

00:38:25,780 --> 00:38:28,690
things like maybe you have a search

00:38:27,340 --> 00:38:30,310
button which allows you to search of

00:38:28,690 --> 00:38:33,270
songs when you click on the search

00:38:30,310 --> 00:38:35,530
button you would enter a new state Oh

00:38:33,270 --> 00:38:37,090
being in this searching more and you

00:38:35,530 --> 00:38:37,870
would have different UI is associated

00:38:37,090 --> 00:38:43,600
with that so that's the difference

00:38:37,870 --> 00:38:44,980
between props and state and here I in

00:38:43,600 --> 00:38:47,320
this case when i'm setting up by you I i

00:38:44,980 --> 00:38:48,910
only use my props and what are you here

00:38:47,320 --> 00:38:50,590
to simplify the process of setting up

00:38:48,910 --> 00:38:53,170
the Dom I just import everything from my

00:38:50,590 --> 00:38:56,380
props case flat and things that here is

00:38:53,170 --> 00:38:59,350
add first property so if I detect that

00:38:56,380 --> 00:39:01,300
an added thing and Spotify I show a

00:38:59,350 --> 00:39:04,840
Spotify icon otherwise I use of course

00:39:01,300 --> 00:39:06,640
proxy to load up the image here saw me

00:39:04,840 --> 00:39:08,320
markas name these are all properties and

00:39:06,640 --> 00:39:11,500
so here I'm even

00:39:08,320 --> 00:39:13,990
read this data coming from a WebSocket a

00:39:11,500 --> 00:39:18,760
text wherever and I'm able to just

00:39:13,990 --> 00:39:23,250
easily embed this into my UI without

00:39:18,760 --> 00:39:23,250
anything no mutability nothing like that

00:39:24,150 --> 00:39:31,360
another really interesting thing that

00:39:26,470 --> 00:39:34,840
happened here is a spot reaction we used

00:39:31,360 --> 00:39:39,340
for things beyond just a UI even in the

00:39:34,840 --> 00:39:44,770
browser so react you start out by using

00:39:39,340 --> 00:39:48,730
it for just display gives an h1 but it

00:39:44,770 --> 00:39:53,410
also is ability to display of empty or

00:39:48,730 --> 00:39:56,020
not Dom elements and here we're i'm able

00:39:53,410 --> 00:39:59,170
to use the whole idea of react with

00:39:56,020 --> 00:40:01,450
properties and state to have a component

00:39:59,170 --> 00:40:02,980
which represents speech output and this

00:40:01,450 --> 00:40:05,590
is how i was able to do that

00:40:02,980 --> 00:40:08,770
contextually aware response to say i

00:40:05,590 --> 00:40:11,230
have this message i skipped two and here

00:40:08,770 --> 00:40:14,080
i'm doing string interpolation to embed

00:40:11,230 --> 00:40:18,670
the song name and artist name here i'm

00:40:14,080 --> 00:40:21,730
saying what defines this speech output

00:40:18,670 --> 00:40:25,120
so if an object which defined when it

00:40:21,730 --> 00:40:27,220
will change and here this this component

00:40:25,120 --> 00:40:30,490
can use it to say whenever that object

00:40:27,220 --> 00:40:33,220
changes we speak it out and here when

00:40:30,490 --> 00:40:34,630
i'm doing state equals play next as you

00:40:33,220 --> 00:40:37,900
saw in the previous started actually job

00:40:34,630 --> 00:40:40,210
back there in the spotify component we

00:40:37,900 --> 00:40:41,890
have the state of type speech in 10 so

00:40:40,210 --> 00:40:44,290
whenever you make a command is set its

00:40:41,890 --> 00:40:45,610
own state to say the user asked me to

00:40:44,290 --> 00:40:47,770
play the next song or it asked me to

00:40:45,610 --> 00:40:50,140
play the previous song and based on this

00:40:47,770 --> 00:40:52,120
I'm able to say I want to enable this

00:40:50,140 --> 00:40:54,550
speech component whenever I'm in that

00:40:52,120 --> 00:40:56,470
state so it gets spoken and the last

00:40:54,550 --> 00:40:58,210
thing is to say after it's been spoken

00:40:56,470 --> 00:41:03,580
what you want to do and in this case is

00:40:58,210 --> 00:41:06,400
just resetting the speech intent and now

00:41:03,580 --> 00:41:09,430
how is that implement it first of all I

00:41:06,400 --> 00:41:12,340
went ahead and created Stanley the app

00:41:09,430 --> 00:41:13,930
is to interface with the voice api is

00:41:12,340 --> 00:41:15,340
because there are lot of different

00:41:13,930 --> 00:41:17,920
things that go around here

00:41:15,340 --> 00:41:21,130
I didn't want to mess with dynamics for

00:41:17,920 --> 00:41:22,810
speech and widths colleges couple lines

00:41:21,130 --> 00:41:27,430
of code and boom you have your native

00:41:22,810 --> 00:41:29,650
API is for speech once i have that this

00:41:27,430 --> 00:41:31,240
is the all i had to write for the

00:41:29,650 --> 00:41:33,550
reaction but in the end of speech so

00:41:31,240 --> 00:41:37,840
i'll go through this one by one first

00:41:33,550 --> 00:41:41,260
step render a dollar too dull when you

00:41:37,840 --> 00:41:44,920
have a react component you have to

00:41:41,260 --> 00:41:47,290
specify how do you render the UI given

00:41:44,920 --> 00:41:49,450
the props and the state and here with

00:41:47,290 --> 00:41:51,010
react you can actually return null and

00:41:49,450 --> 00:41:53,770
that means that it should be an empty

00:41:51,010 --> 00:41:55,450
component and if you boot up ash inspect

00:41:53,770 --> 00:41:57,970
element you'll actually see a comment if

00:41:55,450 --> 00:42:00,190
you're in dev mode that says oh this is

00:41:57,970 --> 00:42:04,510
a md component that are to react would

00:42:00,190 --> 00:42:06,850
have created a then the next step is

00:42:04,510 --> 00:42:09,010
shouldn't component update so this is

00:42:06,850 --> 00:42:11,050
saying when do you want to go ahead and

00:42:09,010 --> 00:42:13,000
re-render in the case of a UI or in this

00:42:11,050 --> 00:42:14,740
case we speak the message and that's

00:42:13,000 --> 00:42:16,810
where i'm talking about that object to

00:42:14,740 --> 00:42:19,180
the second one any so this is just an

00:42:16,810 --> 00:42:21,400
object defining what it does this speech

00:42:19,180 --> 00:42:23,290
text me in and here I'm saying did it

00:42:21,400 --> 00:42:24,400
change if I change then the component

00:42:23,290 --> 00:42:28,630
should update otherwise i should just

00:42:24,400 --> 00:42:30,340
ignore anything else next component did

00:42:28,630 --> 00:42:33,640
not in component it up it is to do the

00:42:30,340 --> 00:42:36,310
same thing what a thing is whenever the

00:42:33,640 --> 00:42:40,840
component updated because of the chin

00:42:36,310 --> 00:42:42,670
and state up or properties or the

00:42:40,840 --> 00:42:44,830
component was loaded up onto the dome

00:42:42,670 --> 00:42:47,770
for the first time that amount then i

00:42:44,830 --> 00:42:50,020
want to possibly speak depending on it

00:42:47,770 --> 00:42:52,990
on this speech has been enabled and

00:42:50,020 --> 00:42:55,420
lastly build to put up put together this

00:42:52,990 --> 00:42:58,540
component and here maybe speak I have my

00:42:55,420 --> 00:43:00,910
properties which is the double that I

00:42:58,540 --> 00:43:02,980
provide and all I see is if it's enabled

00:43:00,910 --> 00:43:05,650
which is specified by that boolean I say

00:43:02,980 --> 00:43:09,910
it and then I call that function to say

00:43:05,650 --> 00:43:12,880
I spoke it and with that unable to set

00:43:09,910 --> 00:43:16,480
up a whole system for handling speech

00:43:12,880 --> 00:43:17,390
synthesis as a react component and a lot

00:43:16,480 --> 00:43:19,580
of this is big

00:43:17,390 --> 00:43:22,570
is so simple because of thats colleges

00:43:19,580 --> 00:43:24,590
react library it handles callbacks

00:43:22,570 --> 00:43:26,630
transforming JavaScript functions to

00:43:24,590 --> 00:43:27,980
scala functions and everything for you

00:43:26,630 --> 00:43:34,040
so you don't really have to worry about

00:43:27,980 --> 00:43:36,590
any of that interval ok so both of alpha

00:43:34,040 --> 00:43:39,710
and ash are open source and available at

00:43:36,590 --> 00:43:52,130
these URLs and now i can answer any

00:43:39,710 --> 00:44:01,190
questions ok see you in the slime so

00:43:52,130 --> 00:44:06,470
just wave your hand around it actually

00:44:01,190 --> 00:44:09,470
music I notice I got back to the music I

00:44:06,470 --> 00:44:13,270
noticed that there were different types

00:44:09,470 --> 00:44:17,720
of music I'm not as educated idea music

00:44:13,270 --> 00:44:21,890
but did you ever consider if a song

00:44:17,720 --> 00:44:26,000
would shift different types and you use

00:44:21,890 --> 00:44:29,240
some kind of local analysis or as it

00:44:26,000 --> 00:44:30,680
trans as it moves across time yeah ok

00:44:29,240 --> 00:44:33,500
that's a really good question so in

00:44:30,680 --> 00:44:35,840
certain performances this especially

00:44:33,500 --> 00:44:37,940
style of music in which the artist would

00:44:35,840 --> 00:44:40,370
kind of flew between different dragas

00:44:37,940 --> 00:44:42,020
and also it's fun to listen to because

00:44:40,370 --> 00:44:44,150
you notice when you switches and your

00:44:42,020 --> 00:44:46,340
life owes its subtle change completely

00:44:44,150 --> 00:44:50,480
transform the feeling in this case I

00:44:46,340 --> 00:44:54,310
don't have a less so in that try for you

00:44:50,480 --> 00:44:57,140
flow between raagas is a not very common

00:44:54,310 --> 00:44:59,420
in terms of recording so mostly it be

00:44:57,140 --> 00:45:00,800
that you have this one hour duration in

00:44:59,420 --> 00:45:02,540
which you play one raga and the artist

00:45:00,800 --> 00:45:04,010
will say ok thank you and that after

00:45:02,540 --> 00:45:06,200
intermission to play another Agra

00:45:04,010 --> 00:45:09,530
because usually raucous goes through a

00:45:06,200 --> 00:45:10,930
section called Allah which is slow kind

00:45:09,530 --> 00:45:13,089
of exploration

00:45:10,930 --> 00:45:14,800
then they're going to a park with the

00:45:13,089 --> 00:45:16,300
percussion so it ends up taking some

00:45:14,800 --> 00:45:18,040
time so the New Jersey kind of happened

00:45:16,300 --> 00:45:20,079
I'm being this raga okay now I stopped

00:45:18,040 --> 00:45:21,760
now I'm paying this rug I'm so whenever

00:45:20,079 --> 00:45:24,339
i received my training material that was

00:45:21,760 --> 00:45:26,230
always one rung at a time but it could

00:45:24,339 --> 00:45:38,500
be explored in the future to be able to

00:45:26,230 --> 00:45:44,500
detect different ragas all right any

00:45:38,500 --> 00:45:47,819
more questions okay going once going

00:45:44,500 --> 00:45:47,819

YouTube URL: https://www.youtube.com/watch?v=cngpLXViFCE


