Title: Dotty support in IntelliJ IDEA by Andrew Kozlov
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
The purpose of this talk is to introduce one to differences between Scala and Dotty, as well as to support for Dotty in Scala plugin for IntelliJ IDEA. First of all we will look at the differences between the type systems. Besides that one will learn which aspects of language support in IntelliJ IDEA have already been implemented or will be implemented in the near future. Among other things the talk will cover the build process of the project, the incremental compilation.
Captions: 
	00:00:04,010 --> 00:00:13,900
so I believe you quite you know quite

00:00:08,360 --> 00:00:17,270
enough about dot calculus and dirty to

00:00:13,900 --> 00:00:22,759
concentrate right now only on our goals

00:00:17,270 --> 00:00:27,740
as IDE developers so and a little server

00:00:22,759 --> 00:00:34,340
to just warm up who uses IntelliJ IDEA s

00:00:27,740 --> 00:00:42,859
and ever date IDE oh great and Eclipse

00:00:34,340 --> 00:00:49,940
IDE okay something like this V Emacs

00:00:42,859 --> 00:00:54,980
okay okay I see and who has any

00:00:49,940 --> 00:01:00,559
experience with dot T not so much okay

00:00:54,980 --> 00:01:05,410
and hello world included have you have

00:01:00,559 --> 00:01:09,440
somebody tried to compile something okay

00:01:05,410 --> 00:01:13,340
the third question is for those of you

00:01:09,440 --> 00:01:19,370
who is experienced with dot T and who

00:01:13,340 --> 00:01:22,190
used IntelliJ IDEA for it oh yeah it's

00:01:19,370 --> 00:01:28,880
that the outcome was quite predictable

00:01:22,190 --> 00:01:33,320
in general nobody health but might not

00:01:28,880 --> 00:01:38,000
not only me so the point of my today's

00:01:33,320 --> 00:01:39,650
talk is this we'd like to make an

00:01:38,000 --> 00:01:42,620
official announcement that we are

00:01:39,650 --> 00:01:44,870
working on dirty supportive and we're

00:01:42,620 --> 00:01:48,440
going to give it a full support in our

00:01:44,870 --> 00:01:50,870
plugin so the decision was made shortly

00:01:48,440 --> 00:01:54,730
after dirty bootstrap was introduced on

00:01:50,870 --> 00:01:57,770
October 23rd 2015

00:01:54,730 --> 00:02:03,050
well and then also in contain the list

00:01:57,770 --> 00:02:08,030
of next steps for dot T and IDE support

00:02:03,050 --> 00:02:12,170
was included so I decided to use this

00:02:08,030 --> 00:02:16,099
tweet as an epigraph for my speech I

00:02:12,170 --> 00:02:19,019
read it just two hours later than

00:02:16,099 --> 00:02:23,010
several thirty related commits were

00:02:19,019 --> 00:02:25,950
pushed so obviously it hasn't billions

00:02:23,010 --> 00:02:30,269
of thousand retweets it not get it Barry

00:02:25,950 --> 00:02:31,379
tweet so but why do we find this - it's

00:02:30,269 --> 00:02:34,620
important for us

00:02:31,379 --> 00:02:37,409
first of all it indicates interest in

00:02:34,620 --> 00:02:38,220
our water thank you your interest is

00:02:37,409 --> 00:02:42,930
appreciated

00:02:38,220 --> 00:02:45,659
moreover these two it indicates an

00:02:42,930 --> 00:02:50,159
interested of community interest in dot

00:02:45,659 --> 00:02:53,690
team so we are on the right wing so oh

00:02:50,159 --> 00:02:57,810
now I'm going to give a live demo for

00:02:53,690 --> 00:03:00,930
current da to stay so let's try with a

00:02:57,810 --> 00:03:01,409
new project we have an intelligent you

00:03:00,930 --> 00:03:04,319
yeah

00:03:01,409 --> 00:03:05,040
create new project and we can select

00:03:04,319 --> 00:03:08,010
Dottie

00:03:05,040 --> 00:03:11,400
Oh so it's a highly experimental

00:03:08,010 --> 00:03:14,010
features so it's only available in

00:03:11,400 --> 00:03:18,389
nightly builds so let me show you a

00:03:14,010 --> 00:03:22,260
little bit later how to set the update

00:03:18,389 --> 00:03:25,709
channel so we can try to create a dotty

00:03:22,260 --> 00:03:38,389
project let's title it something like

00:03:25,709 --> 00:03:38,389
test don't you oh okay excuse me

00:03:39,590 --> 00:03:48,770
yeah here we go so we can create a dirty

00:03:45,200 --> 00:03:51,950
SDK I've got dirty DK already downloaded

00:03:48,770 --> 00:03:54,920
to my laptop so but you can download it

00:03:51,950 --> 00:03:57,980
latest natural just with one hit of the

00:03:54,920 --> 00:04:03,019
button so there is no need to create a

00:03:57,980 --> 00:04:07,540
new one and we hit finish and here we go

00:04:03,019 --> 00:04:07,540
so first of all

00:04:13,500 --> 00:04:21,930
yeah okay first of all we will I am

00:04:18,810 --> 00:04:25,710
going to give you a hello world tour to

00:04:21,930 --> 00:04:28,740
that so you can try this in two simple

00:04:25,710 --> 00:04:31,910
ways that the first one is not so well

00:04:28,740 --> 00:04:33,330
known and obvious but it matches I think

00:04:31,910 --> 00:04:38,120
very good

00:04:33,330 --> 00:04:49,560
it's called scalar worksheet and we can

00:04:38,120 --> 00:04:52,880
create a file for world world just few

00:04:49,560 --> 00:04:52,880
seconds completion

00:04:56,590 --> 00:05:04,450
and here it is hello world what's

00:04:59,740 --> 00:05:07,750
printed so very nice but it's just too

00:05:04,450 --> 00:05:16,540
it's it can be written like a playground

00:05:07,750 --> 00:05:21,940
so let's try something more ok let's

00:05:16,540 --> 00:05:26,560
create an object Oh main with the main

00:05:21,940 --> 00:05:31,330
function and let's start let's get it

00:05:26,560 --> 00:05:36,160
started so I'll give you I'll show you

00:05:31,330 --> 00:05:39,460
some features that are dotty specific

00:05:36,160 --> 00:05:42,220
and I show you some features of our

00:05:39,460 --> 00:05:45,810
plugin that are already done for dirty

00:05:42,220 --> 00:05:52,900
so you can try it for example we create

00:05:45,810 --> 00:05:58,450
trade foo with one function and a trade

00:05:52,900 --> 00:06:01,060
bar with one function as far as you know

00:05:58,450 --> 00:06:07,650
there are intersection and union types

00:06:01,060 --> 00:06:07,650
in DotA so let's try to create something

00:06:09,000 --> 00:06:20,190
with Dyke fool with bar and create food

00:06:15,539 --> 00:06:24,280
so the obvious calisthenics is

00:06:20,190 --> 00:06:31,750
duplicated so we can replace with for

00:06:24,280 --> 00:06:33,760
example and and try to compile it okay

00:06:31,750 --> 00:06:37,840
let's

00:06:33,760 --> 00:06:40,700
let's have a seem was happening

00:06:37,840 --> 00:06:45,880
yeah don't miss much as predicted so

00:06:40,700 --> 00:06:47,120
let's just change ampersand to a bar

00:06:45,880 --> 00:06:57,940
right

00:06:47,120 --> 00:07:06,620
once again so it gets compiled and I

00:06:57,940 --> 00:07:11,810
forgot to print the value well the value

00:07:06,620 --> 00:07:17,660
as predicted is 1 and now we can try

00:07:11,810 --> 00:07:23,150
some idea stuff so first of all we have

00:07:17,660 --> 00:07:27,140
already some key features like find

00:07:23,150 --> 00:07:31,220
usages so we can see that trade foo has

00:07:27,140 --> 00:07:35,030
to use just one as type declaration one

00:07:31,220 --> 00:07:38,960
and you instance creation you we've got

00:07:35,030 --> 00:07:45,440
an icon here so trial has implementation

00:07:38,960 --> 00:07:49,790
we can jump here for example well this

00:07:45,440 --> 00:07:54,200
is very nice yesterday I was asked by

00:07:49,790 --> 00:08:01,250
Dmitry Petrov score if we have debugger

00:07:54,200 --> 00:08:05,650
and I didn't know so today I I'm gonna

00:08:01,250 --> 00:08:14,020
show you that we have debugger already

00:08:05,650 --> 00:08:24,750
ok something very simple and let's put

00:08:14,020 --> 00:08:24,750
here and let's debug it okay

00:08:27,830 --> 00:08:38,229
it's predicted and we've got already

00:08:32,140 --> 00:08:38,229
evaluate expression we can relate food

00:08:49,410 --> 00:08:52,220
the problem

00:08:56,690 --> 00:09:09,530
I have tried it 10 minutes ago but okay

00:09:03,100 --> 00:09:15,320
some bad stuff well and then we have

00:09:09,530 --> 00:09:20,630
done with this program so let's let's

00:09:15,320 --> 00:09:25,520
see some more complex code like like

00:09:20,630 --> 00:09:30,170
name it well as far as you know maybe

00:09:25,520 --> 00:09:33,860
know there are in you there is new

00:09:30,170 --> 00:09:37,640
syntax for the chief in some places so

00:09:33,860 --> 00:09:46,090
we already supported four types so and

00:09:37,640 --> 00:09:49,670
we you can write in this way so and it's

00:09:46,090 --> 00:09:53,330
sugar for something like this don't

00:09:49,670 --> 00:09:57,950
worry about red code not all the

00:09:53,330 --> 00:10:02,360
features are good at the moment so our

00:09:57,950 --> 00:10:05,060
conformance is a weak state but in

00:10:02,360 --> 00:10:09,100
general we can try it and use it already

00:10:05,060 --> 00:10:15,230
so let me show you the class pass I

00:10:09,100 --> 00:10:22,000
think it's very interesting so you don't

00:10:15,230 --> 00:10:22,000
need there is no versions troubles no

00:10:22,270 --> 00:10:33,980
class passed Center no clasp as trouble

00:10:28,340 --> 00:10:36,320
shootings you get it automatically you

00:10:33,980 --> 00:10:39,080
can update you can hit update snapshot

00:10:36,320 --> 00:10:43,130
button the newest snapshot will be

00:10:39,080 --> 00:10:47,300
downloaded and you can update it even

00:10:43,130 --> 00:10:57,080
every day so your snapshot will be the

00:10:47,300 --> 00:10:59,360
last one so ok let's go to the back to

00:10:57,080 --> 00:11:04,920
the presentation

00:10:59,360 --> 00:11:06,720
so Lenox it's like the basic approach to

00:11:04,920 --> 00:11:10,140
support new languages in ID

00:11:06,720 --> 00:11:13,140
the idea is very straightforward a new

00:11:10,140 --> 00:11:15,570
language implies a new plugin so it

00:11:13,140 --> 00:11:18,420
generally seems very obvious every

00:11:15,570 --> 00:11:23,510
language has its own grammar type system

00:11:18,420 --> 00:11:27,630
set of features concepts etc so but and

00:11:23,510 --> 00:11:30,779
here is the list of reasons to create a

00:11:27,630 --> 00:11:33,180
new plugin so if all the conditions are

00:11:30,779 --> 00:11:36,390
satisfied that you have got a new

00:11:33,180 --> 00:11:40,320
grammar a new set of features or

00:11:36,390 --> 00:11:42,240
something like that then then obviously

00:11:40,320 --> 00:11:45,720
you need a new one

00:11:42,240 --> 00:11:48,029
than you plug-in but what about what we

00:11:45,720 --> 00:11:52,520
shall do if the languages are quite

00:11:48,029 --> 00:11:57,870
similar in are there any examples of

00:11:52,520 --> 00:12:01,350
languages with the dialects yes there is

00:11:57,870 --> 00:12:03,420
such a language it's called SQL as far

00:12:01,350 --> 00:12:05,580
as you know moreover it has so many

00:12:03,420 --> 00:12:09,060
dialect that it brains released a

00:12:05,580 --> 00:12:12,690
special tool called data grip a few

00:12:09,060 --> 00:12:16,350
months ago to support SQL and databases

00:12:12,690 --> 00:12:18,750
so the problem is the unlike the SQL

00:12:16,350 --> 00:12:20,400
plug-in the scalar one wasn't designed

00:12:18,750 --> 00:12:26,550
to support dialects

00:12:20,400 --> 00:12:30,210
no no one had an idea that some day

00:12:26,550 --> 00:12:34,250
we're going to support some dialect so

00:12:30,210 --> 00:12:39,060
its color but it's this is the issue

00:12:34,250 --> 00:12:42,360
so since IntelliJ IDEA is a static code

00:12:39,060 --> 00:12:46,680
analysis tool it runs some compiler

00:12:42,360 --> 00:12:51,140
phases on its own it imitates them and

00:12:46,680 --> 00:12:51,140
some of them are mentioned on this slide

00:12:51,589 --> 00:13:00,270
like syntax analysis type inference it's

00:12:55,200 --> 00:13:00,839
the most complex space so and to fully

00:13:00,270 --> 00:13:05,670
support

00:13:00,839 --> 00:13:08,339
dottie in IDE an idea we need to have a

00:13:05,670 --> 00:13:12,060
suitable implementation for each other

00:13:08,339 --> 00:13:13,830
it phases in the concepts of the

00:13:12,060 --> 00:13:17,790
type inference is the most interesting

00:13:13,830 --> 00:13:20,970
thing but the product the first problem

00:13:17,790 --> 00:13:25,590
is that the rest of the compiler phases

00:13:20,970 --> 00:13:29,130
so concept has had no special interfaces

00:13:25,590 --> 00:13:34,140
and has the no ability to implement or

00:13:29,130 --> 00:13:37,620
implement it in the brand new way so ASD

00:13:34,140 --> 00:13:41,430
model is we've got it from the IntelliJ

00:13:37,620 --> 00:13:45,920
platform so it's it's kind of exception

00:13:41,430 --> 00:13:49,110
that there is very good interface but

00:13:45,920 --> 00:13:53,910
for the rest of them there is no such an

00:13:49,110 --> 00:13:58,380
interface so here's a list of ghosts

00:13:53,910 --> 00:14:01,500
that we were the problem the list of

00:13:58,380 --> 00:14:07,550
problems with that we faced to one

00:14:01,500 --> 00:14:12,630
decided to give the support so there are

00:14:07,550 --> 00:14:16,800
I think four of them big for them so

00:14:12,630 --> 00:14:21,680
since we've got multiple implementations

00:14:16,800 --> 00:14:24,030
we need to wait since we've got multiple

00:14:21,680 --> 00:14:26,970
implementations for scholar and for 30

00:14:24,030 --> 00:14:31,410
for example we need to choose a suitable

00:14:26,970 --> 00:14:36,450
one so when do you have your new plugin

00:14:31,410 --> 00:14:39,960
for idea.i the IntelliJ platform

00:14:36,450 --> 00:14:43,470
contains a dependency injection

00:14:39,960 --> 00:14:46,950
framework so you can use it you can roll

00:14:43,470 --> 00:14:51,210
it straight away so and it gives you

00:14:46,950 --> 00:14:54,770
such an opportunity so but the main

00:14:51,210 --> 00:15:00,180
difference between Scala and doji is the

00:14:54,770 --> 00:15:02,760
brand-new type system and there is no

00:15:00,180 --> 00:15:08,790
type system abstraction in IntelliJ

00:15:02,760 --> 00:15:14,060
platform because no one needed one at

00:15:08,790 --> 00:15:19,230
all so we were first to create our own

00:15:14,060 --> 00:15:21,210
registry on the plugin level to registry

00:15:19,230 --> 00:15:23,580
type systems and potentially are the

00:15:21,210 --> 00:15:28,800
components that

00:15:23,580 --> 00:15:33,180
will appear in our in our work so and we

00:15:28,800 --> 00:15:38,340
decided to implement it at Moscow like

00:15:33,180 --> 00:15:44,930
away with implicit parameters so and we

00:15:38,340 --> 00:15:50,330
are trying to use them very very often

00:15:44,930 --> 00:15:54,510
so most of the compiler phrases that are

00:15:50,330 --> 00:16:00,330
imitated by the plugin are now working

00:15:54,510 --> 00:16:02,820
over the type system so and it's a under

00:16:00,330 --> 00:16:05,760
construction right now so a lot of

00:16:02,820 --> 00:16:07,970
plug-in features will be available right

00:16:05,760 --> 00:16:11,460
after it

00:16:07,970 --> 00:16:15,480
right after the type system would be

00:16:11,460 --> 00:16:20,060
fully supported and moreover it's it

00:16:15,480 --> 00:16:28,080
will be their wall they'll work

00:16:20,060 --> 00:16:32,550
correctly with without any new line of

00:16:28,080 --> 00:16:37,950
code and it is very interesting so oh

00:16:32,550 --> 00:16:44,880
now we've got a plug-in for plug-in and

00:16:37,950 --> 00:16:48,110
we need to go deeper and now we've got

00:16:44,880 --> 00:16:51,960
an opportunity we created some

00:16:48,110 --> 00:16:54,980
interfaces and when you've got an

00:16:51,960 --> 00:16:58,080
opportunity to register data specific

00:16:54,980 --> 00:17:00,330
implementations work quickly so and the

00:16:58,080 --> 00:17:04,320
great advantage of this approach is that

00:17:00,330 --> 00:17:07,709
we can add syntax analysis for many new

00:17:04,320 --> 00:17:10,830
features very very quickly right after

00:17:07,709 --> 00:17:16,500
the one become introduced and yesterday

00:17:10,830 --> 00:17:21,150
our my team lead Alexander put

00:17:16,500 --> 00:17:23,970
hallucinate a joke that I could write an

00:17:21,150 --> 00:17:31,380
implementation for some of the features

00:17:23,970 --> 00:17:33,860
in 40 minutes today as an talk what's

00:17:31,380 --> 00:17:41,169
about type system

00:17:33,860 --> 00:17:44,390
why we can talk what I can tell you so

00:17:41,169 --> 00:17:47,299
there were there are some features that

00:17:44,390 --> 00:17:51,890
were removed and there are some features

00:17:47,299 --> 00:17:54,679
class types type classes that were added

00:17:51,890 --> 00:17:57,649
to the type system so intersection and

00:17:54,679 --> 00:18:02,929
you know ties were introduced yesterday

00:17:57,649 --> 00:18:06,940
and I don't think that I'm going to add

00:18:02,929 --> 00:18:10,970
something about them but I'm going to

00:18:06,940 --> 00:18:15,409
say something about the remove or the

00:18:10,970 --> 00:18:17,840
types that were removed it's well known

00:18:15,409 --> 00:18:20,600
that generic type parameters can be

00:18:17,840 --> 00:18:22,669
replaced with abstract types abstract

00:18:20,600 --> 00:18:25,450
type members since color but the

00:18:22,669 --> 00:18:30,559
scalloped type system uses both of the

00:18:25,450 --> 00:18:33,679
concepts and it implies some growing

00:18:30,559 --> 00:18:37,820
complexity potential bugs on the

00:18:33,679 --> 00:18:41,929
compiler site on the ide side and it's

00:18:37,820 --> 00:18:44,539
not so good so all the concepts from the

00:18:41,929 --> 00:18:47,659
right side were removed and they were

00:18:44,539 --> 00:18:53,179
emulated with a refinement of type

00:18:47,659 --> 00:18:59,000
members so I had I already have shown an

00:18:53,179 --> 00:19:02,419
example of this that we have a generic

00:18:59,000 --> 00:19:05,870
type and how it can be represented with

00:19:02,419 --> 00:19:09,700
type layers so and all of the of these

00:19:05,870 --> 00:19:13,090
four types were replaced just with one

00:19:09,700 --> 00:19:16,279
and this is very important as for

00:19:13,090 --> 00:19:23,809
language designers and also for us

00:19:16,279 --> 00:19:30,559
because because not only compilers type

00:19:23,809 --> 00:19:33,529
system becomes easily easier our type

00:19:30,559 --> 00:19:37,220
system becomes easy literal I'm sorry

00:19:33,529 --> 00:19:39,470
our plugin

00:19:37,220 --> 00:19:42,559
already performs most of the disagrees a

00:19:39,470 --> 00:19:45,590
ssin with these types so in DotA mode it

00:19:42,559 --> 00:19:48,079
uses only refinement types inside the

00:19:45,590 --> 00:19:50,839
type or so

00:19:48,079 --> 00:19:52,809
type parameters existence and types or

00:19:50,839 --> 00:20:00,199
something like that

00:19:52,809 --> 00:20:06,829
so what could I say about types that

00:20:00,199 --> 00:20:10,399
were in Scala and that the ones that red

00:20:06,829 --> 00:20:13,249
dot you can see contains so the set of

00:20:10,399 --> 00:20:13,809
the type classes can be split in three

00:20:13,249 --> 00:20:20,089
parts

00:20:13,809 --> 00:20:25,579
that is only 4:30 the ones that are only

00:20:20,089 --> 00:20:30,139
false color and some additional types

00:20:25,579 --> 00:20:36,159
like DVM types boolean incent like that

00:20:30,139 --> 00:20:39,889
Java array type and so on so now oh

00:20:36,159 --> 00:20:45,159
there won't be compound types exist an

00:20:39,889 --> 00:20:53,629
shal types and you have already seen

00:20:45,159 --> 00:20:56,209
that for example we the with type is

00:20:53,629 --> 00:20:59,569
deprecated so we have we've got an

00:20:56,209 --> 00:21:07,539
expection inspection to replace it with

00:20:59,569 --> 00:21:07,539
the unit type so our further roadmap is

00:21:07,869 --> 00:21:17,829
I'm going to check scallop plugin has a

00:21:14,509 --> 00:21:20,959
long and winding road of evolution and

00:21:17,829 --> 00:21:23,299
one is dirty for us no T is an

00:21:20,959 --> 00:21:25,459
opportunity for long which the

00:21:23,299 --> 00:21:28,149
developers dirty is an opportunity to

00:21:25,459 --> 00:21:32,299
develop some to improve the language

00:21:28,149 --> 00:21:34,789
make it simpler make it fast they this

00:21:32,299 --> 00:21:37,549
is a platform that gives an opportunity

00:21:34,789 --> 00:21:40,879
to experiment with some language

00:21:37,549 --> 00:21:44,299
features as you know same rules applies

00:21:40,879 --> 00:21:46,999
for us for us dot T is an opportunity to

00:21:44,299 --> 00:21:50,569
review the code base of the plugin to

00:21:46,999 --> 00:21:53,959
replan some processes in more modern or

00:21:50,569 --> 00:21:57,829
extendable way and extendibility

00:21:53,959 --> 00:21:59,399
is one of the points some of them may be

00:21:57,829 --> 00:22:04,379
rewritten we

00:21:59,399 --> 00:22:07,139
some recent color features implicit is

00:22:04,379 --> 00:22:10,469
the good example of this feature we'd

00:22:07,139 --> 00:22:14,940
like to have widely use it in our code

00:22:10,469 --> 00:22:17,700
base so also dirty is a motivation to be

00:22:14,940 --> 00:22:22,049
honest we have a lack of motivation to

00:22:17,700 --> 00:22:25,469
change some plug-in models like syntax

00:22:22,049 --> 00:22:29,519
analysis is the good example of such a

00:22:25,469 --> 00:22:31,859
model or maybe the best one so circley

00:22:29,519 --> 00:22:35,609
the scallop plugin contains a main main

00:22:31,859 --> 00:22:38,669
person it was written eight years ago

00:22:35,609 --> 00:22:43,979
and the number of language features in

00:22:38,669 --> 00:22:49,349
scala since 2000 that were introduced

00:22:43,979 --> 00:22:52,499
since 2008 doesn't make it better so the

00:22:49,349 --> 00:22:58,289
features were added piece by piece in

00:22:52,499 --> 00:23:03,029
some particular way and its motivation

00:22:58,289 --> 00:23:05,460
to implement it and nowadays it's quite

00:23:03,029 --> 00:23:06,739
common to use parser generators like

00:23:05,460 --> 00:23:13,619
NCLR

00:23:06,739 --> 00:23:17,159
so why do we like internal art so this

00:23:13,619 --> 00:23:20,249
approach will give us several advantages

00:23:17,159 --> 00:23:24,629
on the one hand it can boost the

00:23:20,249 --> 00:23:27,749
performance and prevent a lot of

00:23:24,629 --> 00:23:32,639
potential errors on the other hand it

00:23:27,749 --> 00:23:35,339
will give us an opportunity to it will

00:23:32,639 --> 00:23:40,589
give us a very simple and convenient way

00:23:35,339 --> 00:23:46,409
to support Scala dialects like dou G or

00:23:40,589 --> 00:23:50,039
subscript there is another one dialect

00:23:46,409 --> 00:23:53,339
so for example if you are interested in

00:23:50,039 --> 00:23:56,969
creating your own language based on dot

00:23:53,339 --> 00:24:01,919
calculus you can try it and you will be

00:23:56,969 --> 00:24:05,539
able to support it IntelliJ oh maybe one

00:24:01,919 --> 00:24:05,539
day we will support it on our own

00:24:06,139 --> 00:24:12,160
though the problem with the until are is

00:24:09,719 --> 00:24:15,670
that IntelliJ

00:24:12,160 --> 00:24:18,940
has its own model and NGO our has its

00:24:15,670 --> 00:24:22,630
own model of syntax trees and related

00:24:18,940 --> 00:24:26,710
concept concept so and I'm currently

00:24:22,630 --> 00:24:31,240
experimenting with this I try to figure

00:24:26,710 --> 00:24:34,180
out how to use it in our plugin or is it

00:24:31,240 --> 00:24:39,240
suitable for for our plugin on earth o

00:24:34,180 --> 00:24:42,130
do we need to implement it on our own

00:24:39,240 --> 00:24:45,400
what is coming soon

00:24:42,130 --> 00:24:51,940
some of the features were introduced

00:24:45,400 --> 00:24:54,520
yesterday during the even in keynote as

00:24:51,940 --> 00:24:58,090
I mentioned we can implement syntax

00:24:54,520 --> 00:25:01,450
analysis very quick so the syntax

00:24:58,090 --> 00:25:04,090
analysis for language features it's it

00:25:01,450 --> 00:25:07,270
is on its way and only two may be

00:25:04,090 --> 00:25:11,890
already ready before stellar their

00:25:07,270 --> 00:25:15,820
skeletons Berlin though the full support

00:25:11,890 --> 00:25:20,080
of the features may take a while but we

00:25:15,820 --> 00:25:23,800
ought to give you an opportunity even to

00:25:20,080 --> 00:25:26,460
just just to compile your code without

00:25:23,800 --> 00:25:26,460
errors

00:25:26,530 --> 00:25:32,980
the most interesting feature here is

00:25:30,180 --> 00:25:37,270
scalar to dirty project migration tool

00:25:32,980 --> 00:25:40,990
we were going to release it after dota

00:25:37,270 --> 00:25:43,180
compiler official early Izzard you will

00:25:40,990 --> 00:25:46,210
be able to move your scholar project to

00:25:43,180 --> 00:25:52,270
the don't even and dirty models is their

00:25:46,210 --> 00:25:55,960
feature the related feature so nowadays

00:25:52,270 --> 00:25:58,810
you can create a project and it will be

00:25:55,960 --> 00:26:01,330
compiled to either with Scala either

00:25:58,810 --> 00:26:05,080
with dirty and we're going to break this

00:26:01,330 --> 00:26:09,700
rule you can have one model compiled

00:26:05,080 --> 00:26:19,110
with Scala and the other model compiled

00:26:09,700 --> 00:26:22,570
with dirty so ok I think as I mentioned

00:26:19,110 --> 00:26:24,780
the talk wasn't very tough I think

00:26:22,570 --> 00:26:30,210
you've got some question right

00:26:24,780 --> 00:26:32,700
now and if you about to ask something

00:26:30,210 --> 00:26:36,000
personally about dota support you can

00:26:32,700 --> 00:26:41,580
reach me at the JetBrains dasker and you

00:26:36,000 --> 00:26:46,050
can even you can even propose something

00:26:41,580 --> 00:26:51,330
dirty applicable you are concerned about

00:26:46,050 --> 00:26:54,810
and we we we are going to support it

00:26:51,330 --> 00:27:00,450
maybe someday so and once again thank

00:26:54,810 --> 00:27:02,490
you for your time and your questions you

00:27:00,450 --> 00:27:04,470
said you saw on the slides that you

00:27:02,490 --> 00:27:06,510
remove the higher kind of types so I

00:27:04,470 --> 00:27:09,090
assume you encode them and something

00:27:06,510 --> 00:27:11,340
else is that the same as in the xxx

00:27:09,090 --> 00:27:15,060
compiler or what what do you use to

00:27:11,340 --> 00:27:24,450
encode higher current types on this

00:27:15,060 --> 00:27:30,480
slide this man yeah that's right yeah no

00:27:24,450 --> 00:27:33,480
I can honestly we didn't get too high

00:27:30,480 --> 00:27:39,300
kind of time so maybe it's my fault to

00:27:33,480 --> 00:27:48,780
introduce it in this list but I copied

00:27:39,300 --> 00:27:54,920
it from here because yeah work over type

00:27:48,780 --> 00:27:58,500
system is in progress so most of the

00:27:54,920 --> 00:28:03,420
thoughts are from the dodgy compiler we

00:27:58,500 --> 00:28:09,650
just look into the codebase when we

00:28:03,420 --> 00:28:13,730
started with the parser I had I opened a

00:28:09,650 --> 00:28:20,780
the Scala grammar and the dirty one and

00:28:13,730 --> 00:28:23,130
so the difference and implemented some

00:28:20,780 --> 00:28:30,260
bars

00:28:23,130 --> 00:28:30,260
parce modules so any other questions

00:28:35,450 --> 00:28:42,579
so I think that Ron no questions okay

00:28:39,049 --> 00:28:42,579

YouTube URL: https://www.youtube.com/watch?v=mompl2LR_7M


