Title: Domain Driven Design and Onion Architecture in Scala  - by Wade Waldron
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Domain Driven Design has been a game changer in my career.  Combined with Onion Architecture it has made improvements to my code, in both readability and maintainability.
Scala is ideally suited to Domain Driven Design.  Case classes and traits allow us to rapidly prototype a domain.  We can iterate over that domain quickly as we build. This makes it trivial to specify a rich description of a domain with very little code, and minimal investment of time.
Onion Architecture provides us with the tools needed to create clean package structures. It provides a framework for creating the abstraction layers to allow your code to be portable, testable, and easier to maintain.
In this code-driven talk, I will explore the techniques I developed while using Domain Driven Design and Onion Architecture in Scala.  I will discuss key features such as Repositories, Services, Aggregates, Bounded Contexts and more. I will explore how Onion Architecture can be used with Domain Driven Design to build up applications in fully portable layers.
Captions: 
	00:00:00,940 --> 00:00:06,399
so my name is Wade Waldron I am a senior

00:00:04,210 --> 00:00:09,490
consultant with light Bend

00:00:06,399 --> 00:00:11,530
I'm also the co-author of apply daca

00:00:09,490 --> 00:00:14,049
patterns with my colleague Mike Nash

00:00:11,530 --> 00:00:17,380
it's not available yet but will be

00:00:14,049 --> 00:00:19,119
hopefully shortly I'm also a light Bend

00:00:17,380 --> 00:00:21,820
certified trainer if you're doing any of

00:00:19,119 --> 00:00:24,010
the trainings after Scalla days then

00:00:21,820 --> 00:00:26,800
there's a chance that I might be I might

00:00:24,010 --> 00:00:29,080
be your trainer today I'm going to be

00:00:26,800 --> 00:00:32,470
talking about domain-driven design and

00:00:29,080 --> 00:00:34,780
onion architecture in Scala I wanted to

00:00:32,470 --> 00:00:37,120
talk about this particular topic because

00:00:34,780 --> 00:00:40,300
it was introduced to me a few years back

00:00:37,120 --> 00:00:42,700
and I found that once I started using it

00:00:40,300 --> 00:00:44,890
and using it heavily in my code it made

00:00:42,700 --> 00:00:47,199
a big difference in the quality of my

00:00:44,890 --> 00:00:49,440
code the clarity of my code and also the

00:00:47,199 --> 00:00:52,030
the portability of my code as well

00:00:49,440 --> 00:00:53,530
particularly with onion architecture and

00:00:52,030 --> 00:00:56,890
we'll talk about some of the elements of

00:00:53,530 --> 00:00:59,859
this but it enhanced my ability to swap

00:00:56,890 --> 00:01:01,329
out pieces and to change things without

00:00:59,859 --> 00:01:03,039
having to worry about whether I'm going

00:01:01,329 --> 00:01:07,210
to break everybody who's using the code

00:01:03,039 --> 00:01:09,250
that I've already written please don't

00:01:07,210 --> 00:01:13,090
forget to rate the presentation

00:01:09,250 --> 00:01:15,340
afterwards it's helpful for Scalla day's

00:01:13,090 --> 00:01:18,220
crew to know who should speak again next

00:01:15,340 --> 00:01:20,140
year and who shouldn't but also I'm

00:01:18,220 --> 00:01:23,220
hoping I get a little bit of feedback as

00:01:20,140 --> 00:01:28,060
well so please do write the presentation

00:01:23,220 --> 00:01:29,880
so let's get started so if you have done

00:01:28,060 --> 00:01:33,310
any research on domain-driven design

00:01:29,880 --> 00:01:36,430
you'll find that it is often tied up

00:01:33,310 --> 00:01:38,650
with CQRS event sourcing you might see

00:01:36,430 --> 00:01:40,150
onion architecture in there but I want

00:01:38,650 --> 00:01:41,890
to make it very clear that none of these

00:01:40,150 --> 00:01:44,200
things are actually required for you to

00:01:41,890 --> 00:01:46,030
do domain driven design you can do

00:01:44,200 --> 00:01:47,620
domain driven design without doing event

00:01:46,030 --> 00:01:50,260
sourcing you can do it without doing

00:01:47,620 --> 00:01:51,940
onion architecture or without doing CQRS

00:01:50,260 --> 00:01:53,710
just like you can do each of those

00:01:51,940 --> 00:01:56,160
things without doing domain driven

00:01:53,710 --> 00:01:58,990
design it just happens that they

00:01:56,160 --> 00:02:00,880
complement each other very well and so

00:01:58,990 --> 00:02:02,470
they are often used in conjunction with

00:02:00,880 --> 00:02:04,180
each other today we're going to be

00:02:02,470 --> 00:02:05,650
focusing on the core of domain driven

00:02:04,180 --> 00:02:08,200
design we're not going to be talking

00:02:05,650 --> 00:02:10,030
about CQRS or event sourcing we will

00:02:08,200 --> 00:02:11,610
talk about onion architecture and the

00:02:10,030 --> 00:02:14,230
reason for that is because I find that

00:02:11,610 --> 00:02:14,650
some of the concepts and onion

00:02:14,230 --> 00:02:18,129
architects

00:02:14,650 --> 00:02:23,709
to help clarify domain-driven design and

00:02:18,129 --> 00:02:25,390
help make it easier to understand we're

00:02:23,709 --> 00:02:27,640
going to look at a particular case study

00:02:25,390 --> 00:02:29,769
the case study we're going to look at is

00:02:27,640 --> 00:02:31,980
how to fry an egg using domain driven

00:02:29,769 --> 00:02:34,959
design and onion architecture

00:02:31,980 --> 00:02:37,209
specifically we're going to look at the

00:02:34,959 --> 00:02:39,159
moment when somebody requests an egg

00:02:37,209 --> 00:02:41,200
what is the process that it goes through

00:02:39,159 --> 00:02:43,030
in order to get prepared and then served

00:02:41,200 --> 00:02:45,370
back to the person who requested the egg

00:02:43,030 --> 00:02:47,379
so it's the preparation of that egg that

00:02:45,370 --> 00:02:50,470
we are looking at so why did I choose

00:02:47,379 --> 00:02:52,269
this case study I like it because it has

00:02:50,470 --> 00:02:54,400
a lot it has a surprising number of

00:02:52,269 --> 00:02:55,959
little nuances and edge cases that you

00:02:54,400 --> 00:02:58,840
don't really see until you start

00:02:55,959 --> 00:03:00,220
exploring the domain I also like it

00:02:58,840 --> 00:03:01,840
because it's very easy for everybody

00:03:00,220 --> 00:03:03,790
here to understand I don't have to spend

00:03:01,840 --> 00:03:05,739
20 minutes explaining the domain to you

00:03:03,790 --> 00:03:07,840
I can just stock up start talking about

00:03:05,739 --> 00:03:10,239
cooking eggs and hopefully everybody

00:03:07,840 --> 00:03:12,849
will have some frame of reference that

00:03:10,239 --> 00:03:15,489
they can understand it it's also not

00:03:12,849 --> 00:03:18,129
overdone so this is not a domain that

00:03:15,489 --> 00:03:19,900
you see a lot of people model usually

00:03:18,129 --> 00:03:22,389
you'll see the customer domain or

00:03:19,900 --> 00:03:25,180
whatever and I find sometimes when you

00:03:22,389 --> 00:03:26,590
get into those overdone domains it can

00:03:25,180 --> 00:03:28,510
get tricky because you're not quite sure

00:03:26,590 --> 00:03:30,549
well what is the actual domain and what

00:03:28,510 --> 00:03:32,680
is just how everybody's always done it

00:03:30,549 --> 00:03:34,840
so this gives us something fresh that we

00:03:32,680 --> 00:03:36,849
can explore that probably not a lot of

00:03:34,840 --> 00:03:42,129
you have ever explored this particular

00:03:36,849 --> 00:03:44,470
domain so what is a domain what is

00:03:42,129 --> 00:03:46,870
domain driven design well let's let's

00:03:44,470 --> 00:03:50,109
start with a domain this is a sphere of

00:03:46,870 --> 00:03:51,760
knowledge this can be anything it can be

00:03:50,109 --> 00:03:54,280
selling products if you're doing the

00:03:51,760 --> 00:03:57,699
customer domain it can be geological

00:03:54,280 --> 00:04:01,269
processes it can be cooking an egg so

00:03:57,699 --> 00:04:03,549
it's just a sphere of knowledge domain

00:04:01,269 --> 00:04:06,879
driven design then is about focusing on

00:04:03,549 --> 00:04:09,489
that core domain we want to focus on the

00:04:06,879 --> 00:04:11,199
rules that are part of that sphere of

00:04:09,489 --> 00:04:13,180
knowledge and the ideas that are part of

00:04:11,199 --> 00:04:15,519
that sphere of knowledge and in doing so

00:04:13,180 --> 00:04:17,349
we want to de-emphasize technologies we

00:04:15,519 --> 00:04:19,060
want to de-emphasize things like the

00:04:17,349 --> 00:04:20,849
user interfaces those things are

00:04:19,060 --> 00:04:23,200
important and we're going to need them

00:04:20,849 --> 00:04:24,909
but we don't want to focus on those

00:04:23,200 --> 00:04:26,889
things we want those things to be

00:04:24,909 --> 00:04:30,129
secondary to the core domain

00:04:26,889 --> 00:04:31,930
or business logic the reason that we do

00:04:30,129 --> 00:04:33,400
that is that the or part of the reason

00:04:31,930 --> 00:04:37,840
that we do that is that the core domain

00:04:33,400 --> 00:04:40,270
tends to be more constant so things like

00:04:37,840 --> 00:04:42,249
technologies you know are our database

00:04:40,270 --> 00:04:44,110
structure may change from one week to

00:04:42,249 --> 00:04:46,330
the next so if we focus on our database

00:04:44,110 --> 00:04:49,090
structure then we're constantly going to

00:04:46,330 --> 00:04:50,889
be rewriting our code on the other hand

00:04:49,090 --> 00:04:52,810
the core domain once we get it right

00:04:50,889 --> 00:04:54,699
there's a good chance that it's not

00:04:52,810 --> 00:04:56,560
going to change dramatically it does

00:04:54,699 --> 00:04:58,749
change from time to time new rules new

00:04:56,560 --> 00:05:01,120
laws get introduced new ideas come into

00:04:58,749 --> 00:05:02,949
play so it does change from time to time

00:05:01,120 --> 00:05:05,590
but it's likely going to change less

00:05:02,949 --> 00:05:08,229
than some of the other areas you know

00:05:05,590 --> 00:05:11,560
the UI for example will be could

00:05:08,229 --> 00:05:13,569
experience dramatic changes again so

00:05:11,560 --> 00:05:16,719
it's about capturing the truth of the

00:05:13,569 --> 00:05:18,699
real world model in what we call the

00:05:16,719 --> 00:05:20,919
domain model and what I want to

00:05:18,699 --> 00:05:23,469
emphasize here as well is that the

00:05:20,919 --> 00:05:25,060
software is not the domain model the

00:05:23,469 --> 00:05:27,999
software is an implementation of that

00:05:25,060 --> 00:05:30,520
domain model so the domain model is just

00:05:27,999 --> 00:05:33,310
our understanding of the business our

00:05:30,520 --> 00:05:34,779
understanding of the domain the software

00:05:33,310 --> 00:05:36,900
is an implementation but we could have

00:05:34,779 --> 00:05:38,650
other implementations so if we do

00:05:36,900 --> 00:05:40,960
documentation that's another

00:05:38,650 --> 00:05:43,419
implementation of the domain model if we

00:05:40,960 --> 00:05:45,639
do diagrams again another implementation

00:05:43,419 --> 00:05:47,830
of the domain model so we're just taking

00:05:45,639 --> 00:05:50,020
our understanding and reflecting it

00:05:47,830 --> 00:05:53,699
either encode or documentation or

00:05:50,020 --> 00:05:56,379
diagrams or whatever technique you need

00:05:53,699 --> 00:05:58,659
domain driven design in order to do this

00:05:56,379 --> 00:06:00,580
encourages strong communication between

00:05:58,659 --> 00:06:03,479
the domain experts and the technical

00:06:00,580 --> 00:06:05,889
experts so that your domain experts are

00:06:03,479 --> 00:06:08,699
people like I mean it depends on your

00:06:05,889 --> 00:06:10,899
business but in a in a geological

00:06:08,699 --> 00:06:14,319
software than it would be your

00:06:10,899 --> 00:06:16,960
geologists if we were in the customer

00:06:14,319 --> 00:06:19,930
domain then it might be your salespeople

00:06:16,960 --> 00:06:21,909
they might be domain experts if we're

00:06:19,930 --> 00:06:24,460
cooking an egg it might be the chef or

00:06:21,909 --> 00:06:26,409
the cook so these are just experts who

00:06:24,460 --> 00:06:29,710
can inform us about the rules of the

00:06:26,409 --> 00:06:31,659
business these experts in order to

00:06:29,710 --> 00:06:33,460
communicate with them we need a common

00:06:31,659 --> 00:06:35,469
language if I just stand there and start

00:06:33,460 --> 00:06:37,029
talking to talking to them using

00:06:35,469 --> 00:06:38,379
technical terms if I'm standing there

00:06:37,029 --> 00:06:39,870
talking to the chef and I start talking

00:06:38,379 --> 00:06:41,040
databases

00:06:39,870 --> 00:06:42,900
they're probably not going to have any

00:06:41,040 --> 00:06:44,580
clue what I'm talking about so we need a

00:06:42,900 --> 00:06:46,410
common language a way that we can

00:06:44,580 --> 00:06:48,990
communicate with each other and and

00:06:46,410 --> 00:06:51,450
understand each other without having to

00:06:48,990 --> 00:06:54,020
have a translator present although all

00:06:51,450 --> 00:06:55,860
of the time so domain-driven design

00:06:54,020 --> 00:06:58,920
introduces something called the

00:06:55,860 --> 00:07:01,020
ubiquitous language the ubiquitous

00:06:58,920 --> 00:07:02,970
language is the common language that is

00:07:01,020 --> 00:07:07,470
shared between the domain experts and

00:07:02,970 --> 00:07:09,840
the technical experts it's it's also we

00:07:07,470 --> 00:07:12,030
want to reflect this ubiquitous language

00:07:09,840 --> 00:07:13,920
in the code so when we build our

00:07:12,030 --> 00:07:16,350
software implementation of the domain

00:07:13,920 --> 00:07:19,110
model we want to use the same language

00:07:16,350 --> 00:07:21,510
in the code that we use when talking to

00:07:19,110 --> 00:07:24,540
the domain experts we want to avoid

00:07:21,510 --> 00:07:26,760
using vague terms like entity process or

00:07:24,540 --> 00:07:28,770
action unless of course your domain

00:07:26,760 --> 00:07:30,210
actually uses those terms in which case

00:07:28,770 --> 00:07:32,460
it would be perfectly acceptable to

00:07:30,210 --> 00:07:34,290
include them in your code but we want to

00:07:32,460 --> 00:07:36,390
avoid those in general and the reason

00:07:34,290 --> 00:07:37,830
that we want to do that is because we

00:07:36,390 --> 00:07:40,740
want to be able to sit down and have a

00:07:37,830 --> 00:07:43,410
conversation about the code with our

00:07:40,740 --> 00:07:45,240
domain experts if we can do that then

00:07:43,410 --> 00:07:46,860
when we start talking to them about the

00:07:45,240 --> 00:07:48,990
code using language that they can

00:07:46,860 --> 00:07:51,930
understand then they can end up in a

00:07:48,990 --> 00:07:53,310
situation where they might hear us say

00:07:51,930 --> 00:07:55,530
something and it might trigger them to

00:07:53,310 --> 00:07:58,470
go well now hold on a second no that's

00:07:55,530 --> 00:08:00,990
not really how it works and when they

00:07:58,470 --> 00:08:02,730
say that that's a cue for us to go well

00:08:00,990 --> 00:08:03,780
okay if that's not how it works in your

00:08:02,730 --> 00:08:05,670
understanding

00:08:03,780 --> 00:08:07,560
then maybe I understood it wrong when I

00:08:05,670 --> 00:08:10,380
implemented the model and maybe I need

00:08:07,560 --> 00:08:12,330
to re-implement that model and so we

00:08:10,380 --> 00:08:13,980
might have to go and make changes so by

00:08:12,330 --> 00:08:18,120
allowing us to talk to our domain

00:08:13,980 --> 00:08:20,460
experts it in turn allows us to detect

00:08:18,120 --> 00:08:24,780
problems in the model that maybe come

00:08:20,460 --> 00:08:26,910
from a lack of our understanding so

00:08:24,780 --> 00:08:30,660
here's a from our case study here's a

00:08:26,910 --> 00:08:33,420
few terms from the domain we have some

00:08:30,660 --> 00:08:37,290
nouns cook egg sunny-side up scrambled

00:08:33,420 --> 00:08:40,410
stove frying pan we have some verbs fry

00:08:37,290 --> 00:08:41,820
prepare crack these are all words that

00:08:40,410 --> 00:08:43,530
if I'm standing there having a

00:08:41,820 --> 00:08:45,150
conversation with a cook they are

00:08:43,530 --> 00:08:46,560
probably going to know what I mean and

00:08:45,150 --> 00:08:50,430
if they don't I probably need a

00:08:46,560 --> 00:08:52,200
different cook so I can have a

00:08:50,430 --> 00:08:53,470
conversation with my domain experts

00:08:52,200 --> 00:08:55,140
using these words and we're

00:08:53,470 --> 00:08:57,490
going to have a communication difficulty

00:08:55,140 --> 00:08:59,980
some of these terms may not end up in

00:08:57,490 --> 00:09:02,190
the final code that's fine this is not

00:08:59,980 --> 00:09:05,200
necessarily supposed to be the exact

00:09:02,190 --> 00:09:06,700
model that is reflected in the code but

00:09:05,200 --> 00:09:11,410
the point is that when we go to draw

00:09:06,700 --> 00:09:13,150
ideas from our domain model these are

00:09:11,410 --> 00:09:17,980
the kinds of words that we want to be

00:09:13,150 --> 00:09:19,600
using in the code now when we start

00:09:17,980 --> 00:09:22,090
doing this when we start building up our

00:09:19,600 --> 00:09:25,120
application oftentimes we can get into a

00:09:22,090 --> 00:09:28,390
situation where our code grows out of

00:09:25,120 --> 00:09:30,370
control if we if we start trying to take

00:09:28,390 --> 00:09:32,620
a large domain frying an eggs a pretty

00:09:30,370 --> 00:09:34,240
small domain but if we take a much

00:09:32,620 --> 00:09:36,520
larger domain and we start trying to

00:09:34,240 --> 00:09:38,590
capture all of the ideas and reflect

00:09:36,520 --> 00:09:40,450
them in the domain model our code starts

00:09:38,590 --> 00:09:43,600
to grow it becomes bloated it becomes

00:09:40,450 --> 00:09:44,380
ugly and and very quickly everything

00:09:43,600 --> 00:09:47,470
falls apart

00:09:44,380 --> 00:09:49,870
so domain driven design solves this

00:09:47,470 --> 00:09:52,780
using something called a bounded context

00:09:49,870 --> 00:09:54,190
if you're in von Vernon's talk yesterday

00:09:52,780 --> 00:09:56,800
then you would have heard a little bit

00:09:54,190 --> 00:09:58,630
about bounded contexts essentially a

00:09:56,800 --> 00:10:02,440
bounded context is a subset of the

00:09:58,630 --> 00:10:05,080
domain it is a setting where the ideas

00:10:02,440 --> 00:10:07,240
from the ubiquitous language apply but

00:10:05,080 --> 00:10:10,120
if you go from one bounded context to

00:10:07,240 --> 00:10:12,010
the next some of those ideas might take

00:10:10,120 --> 00:10:14,590
on a different meaning or they might not

00:10:12,010 --> 00:10:16,600
exist at all so we might have words that

00:10:14,590 --> 00:10:18,310
exist in one bounded context that don't

00:10:16,600 --> 00:10:20,680
really make sense in a different bounded

00:10:18,310 --> 00:10:23,950
context or like I said their meaning

00:10:20,680 --> 00:10:27,250
might change as Vaughn was mentioning

00:10:23,950 --> 00:10:29,980
yesterday bounded contexts go very well

00:10:27,250 --> 00:10:32,560
with microservices I won't go into a lot

00:10:29,980 --> 00:10:34,120
of detail there he actually gave a

00:10:32,560 --> 00:10:37,180
fairly good description of that

00:10:34,120 --> 00:10:40,840
yesterday but they're not necessarily a

00:10:37,180 --> 00:10:43,420
one-to-one relationship you can you can

00:10:40,840 --> 00:10:44,620
use them as a starting point but they

00:10:43,420 --> 00:10:48,880
don't necessarily have to be a

00:10:44,620 --> 00:10:50,230
one-to-one relationship so what about

00:10:48,880 --> 00:10:52,030
our case study what are some bounded

00:10:50,230 --> 00:10:53,110
context we might find in our case study

00:10:52,030 --> 00:10:54,790
well we're going to talk about the

00:10:53,110 --> 00:10:57,850
food-preparation bounded context today

00:10:54,790 --> 00:10:59,260
that's going to be our primary focus but

00:10:57,850 --> 00:11:01,360
of course if you're going to cook food

00:10:59,260 --> 00:11:02,710
then you need food to cook which means

00:11:01,360 --> 00:11:04,600
that at some point somebody's got to go

00:11:02,710 --> 00:11:06,460
grocery shopping so that could be

00:11:04,600 --> 00:11:08,440
another bounded context

00:11:06,460 --> 00:11:11,140
that could be you could think of that as

00:11:08,440 --> 00:11:13,420
your supply bounded context at the same

00:11:11,140 --> 00:11:14,800
time once we finish cooking the food

00:11:13,420 --> 00:11:16,390
somebody's got to clean up the mess we

00:11:14,800 --> 00:11:19,510
got to wash the dishes so that could be

00:11:16,390 --> 00:11:21,930
another bounded context you can think of

00:11:19,510 --> 00:11:25,120
that as your maintenance bounded context

00:11:21,930 --> 00:11:27,070
now think about some of our terms that

00:11:25,120 --> 00:11:29,410
we use in our different bounded contexts

00:11:27,070 --> 00:11:33,100
in our food preparation domain we have

00:11:29,410 --> 00:11:36,460
the concept of an egg now the concept of

00:11:33,100 --> 00:11:39,100
an egg is very interesting but it takes

00:11:36,460 --> 00:11:40,900
on different meaning depending on what

00:11:39,100 --> 00:11:42,580
bounded context you're and of course in

00:11:40,900 --> 00:11:44,800
the grocery shopping bounded context

00:11:42,580 --> 00:11:47,280
your egg is the thing that you're buying

00:11:44,800 --> 00:11:50,290
it's it's the product that you're buying

00:11:47,280 --> 00:11:51,580
in the washing dishes bounded context

00:11:50,290 --> 00:11:53,350
things get really interesting because

00:11:51,580 --> 00:11:55,540
again in the food preparation bounded

00:11:53,350 --> 00:11:56,980
context the egg is that tasty thing that

00:11:55,540 --> 00:11:59,020
you cook and you serve beside your toast

00:11:56,980 --> 00:12:01,300
in your bacon and everything else in the

00:11:59,020 --> 00:12:02,710
washing dishes bounded context the egg

00:12:01,300 --> 00:12:05,050
is the disgusting thing you're scraping

00:12:02,710 --> 00:12:07,060
out of your frying pan right now if we

00:12:05,050 --> 00:12:10,510
try to model both of those concepts

00:12:07,060 --> 00:12:13,660
using a single software model that's

00:12:10,510 --> 00:12:14,980
going to get really ugly and we're

00:12:13,660 --> 00:12:18,070
probably going to end up in a situation

00:12:14,980 --> 00:12:21,790
very fast where things don't make sense

00:12:18,070 --> 00:12:23,260
another example from the food

00:12:21,790 --> 00:12:28,240
preparation domain we might have the

00:12:23,260 --> 00:12:29,770
concept of a cook or a chef now again

00:12:28,240 --> 00:12:31,840
that has a lot of meaning in the food

00:12:29,770 --> 00:12:33,580
preparation domain does it have much

00:12:31,840 --> 00:12:35,230
meaning in the grocery shopping domain I

00:12:33,580 --> 00:12:37,180
don't need a cook or chef to buy

00:12:35,230 --> 00:12:40,000
groceries yeah they might the same

00:12:37,180 --> 00:12:42,340
person might be the person who buys the

00:12:40,000 --> 00:12:44,980
groceries but it's not necessarily the

00:12:42,340 --> 00:12:46,300
same concept they are up there a shopper

00:12:44,980 --> 00:12:49,210
at that point they are a customer

00:12:46,300 --> 00:12:50,820
they're not a cook anymore it doesn't

00:12:49,210 --> 00:12:53,200
matter whether they know how to cook

00:12:50,820 --> 00:12:54,760
they could be just some random person

00:12:53,200 --> 00:12:56,950
who goes to get the groceries and that's

00:12:54,760 --> 00:13:00,280
fine and by dividing these bounded

00:12:56,950 --> 00:13:02,350
context up we present or sorry prevent

00:13:00,280 --> 00:13:08,740
ourselves from ending up with a model

00:13:02,350 --> 00:13:10,090
that is too large and too bloated so in

00:13:08,740 --> 00:13:11,800
order to build using domain driven

00:13:10,090 --> 00:13:13,360
design we need some building blocks I'm

00:13:11,800 --> 00:13:16,270
not going to spend a lot of time on

00:13:13,360 --> 00:13:18,520
these if you want more information then

00:13:16,270 --> 00:13:19,960
you can check out Wikipedia or you can

00:13:18,520 --> 00:13:21,640
check out some of the books on

00:13:19,960 --> 00:13:26,320
domain-driven design like the original

00:13:21,640 --> 00:13:28,000
ddd book by Eric Evans but let's just go

00:13:26,320 --> 00:13:31,600
through the list very quickly here so we

00:13:28,000 --> 00:13:33,790
have value objects value objects are a

00:13:31,600 --> 00:13:35,890
domain object that is defined by its

00:13:33,790 --> 00:13:37,150
attributes if you have two value objects

00:13:35,890 --> 00:13:40,420
that have the same attributes you can

00:13:37,150 --> 00:13:42,820
consider them equivalent if you have an

00:13:40,420 --> 00:13:47,890
entity than it is a domain object that

00:13:42,820 --> 00:13:50,860
is defined by an identity or a key if

00:13:47,890 --> 00:13:52,780
you have two entities that have the that

00:13:50,860 --> 00:13:54,940
have the same identity then you can

00:13:52,780 --> 00:13:58,000
consider them the same regardless of

00:13:54,940 --> 00:13:59,800
what their attributes might be we have

00:13:58,000 --> 00:14:02,350
aggregates these are a collection of

00:13:59,800 --> 00:14:05,770
objects that are bound by a root entity

00:14:02,350 --> 00:14:07,510
and aggregates the root entity in an

00:14:05,770 --> 00:14:11,200
aggregate aggregate is usually called

00:14:07,510 --> 00:14:13,060
the aggregate root we have services we

00:14:11,200 --> 00:14:14,980
often use these to contain operations

00:14:13,060 --> 00:14:17,110
that don't fit into other domain objects

00:14:14,980 --> 00:14:19,030
so ideally you know if we have a

00:14:17,110 --> 00:14:21,310
particular operation we would attach it

00:14:19,030 --> 00:14:22,900
to either an aggregate or an entity or

00:14:21,310 --> 00:14:24,900
something like that but sometimes that

00:14:22,900 --> 00:14:29,770
doesn't work sometimes we end up with

00:14:24,900 --> 00:14:31,690
entities where the the sorry operations

00:14:29,770 --> 00:14:34,210
where it touches many different entities

00:14:31,690 --> 00:14:36,610
it might touch different aggregate roots

00:14:34,210 --> 00:14:38,560
or it just might not conceptually make

00:14:36,610 --> 00:14:40,480
sense in any of our entities in which

00:14:38,560 --> 00:14:43,420
case we might put a service in place to

00:14:40,480 --> 00:14:45,490
handle that we have repositories these

00:14:43,420 --> 00:14:47,650
are abstractions for retrieving

00:14:45,490 --> 00:14:49,480
instances of domain objects and then we

00:14:47,650 --> 00:14:51,820
have factories which are abstractions

00:14:49,480 --> 00:14:53,500
for creating instances of domain objects

00:14:51,820 --> 00:14:57,400
and I'll talk a little bit about more

00:14:53,500 --> 00:14:59,560
about some of these as we go okay so

00:14:57,400 --> 00:15:02,050
what about our case study what are what

00:14:59,560 --> 00:15:03,490
are some of the domain objects that we

00:15:02,050 --> 00:15:06,400
might find in our case study well we

00:15:03,490 --> 00:15:09,700
might find a cook we might find a cook

00:15:06,400 --> 00:15:12,250
factory cook repository egg egg style

00:15:09,700 --> 00:15:13,840
frying pan now if you'll notice these

00:15:12,250 --> 00:15:15,580
are all words that I basically just

00:15:13,840 --> 00:15:18,550
pulled directly off the ubiquitous

00:15:15,580 --> 00:15:20,590
language slide I did you know I added a

00:15:18,550 --> 00:15:23,010
few things like a cook factory factory

00:15:20,590 --> 00:15:25,390
wasn't part of our ubiquitous language

00:15:23,010 --> 00:15:26,920
but still you can understand you know

00:15:25,390 --> 00:15:29,200
it's a cook factory it's a thing that

00:15:26,920 --> 00:15:33,279
produces cooks okay that makes some

00:15:29,200 --> 00:15:35,439
sense so we're just pulling that that

00:15:33,279 --> 00:15:40,329
which directly from from our ubiquitous

00:15:35,439 --> 00:15:42,100
language so this is an example of the

00:15:40,329 --> 00:15:44,199
layers of a traditional layered

00:15:42,100 --> 00:15:45,040
architecture you might have more layers

00:15:44,199 --> 00:15:46,689
in there

00:15:45,040 --> 00:15:48,160
these are sort of some of the primary

00:15:46,689 --> 00:15:51,759
ones but you might subdivide these

00:15:48,160 --> 00:15:53,319
layers as well and you end up with like

00:15:51,759 --> 00:15:55,269
what I've heard people call the

00:15:53,319 --> 00:15:58,540
seven-layer burrito architecture things

00:15:55,269 --> 00:16:00,850
like that so this is uh this is a

00:15:58,540 --> 00:16:02,139
traditional architecture I'm not going

00:16:00,850 --> 00:16:04,809
to spend a lot of time on this but I

00:16:02,139 --> 00:16:06,790
just want to highlight it because it

00:16:04,809 --> 00:16:08,680
will be talking about onion architecture

00:16:06,790 --> 00:16:10,809
instead so basically you've got

00:16:08,680 --> 00:16:13,120
presentation domain data access

00:16:10,809 --> 00:16:15,129
presentation at the top data access at

00:16:13,120 --> 00:16:20,019
the bottom so how is that different from

00:16:15,129 --> 00:16:23,319
onion architecture so in onion

00:16:20,019 --> 00:16:25,569
architecture we have more of an onion

00:16:23,319 --> 00:16:27,879
shape in this case the application

00:16:25,569 --> 00:16:30,339
ideally is built around the domain now

00:16:27,879 --> 00:16:32,499
I'll go into the details of the layers

00:16:30,339 --> 00:16:34,300
in a moment it's in in my diagram it's

00:16:32,499 --> 00:16:37,449
not quite built around the domain but

00:16:34,300 --> 00:16:39,610
I'll explain that in a moment but what I

00:16:37,449 --> 00:16:41,439
do want to say is that this is if you

00:16:39,610 --> 00:16:43,000
look up on ioan architecture online you

00:16:41,439 --> 00:16:44,920
might see diagrams that are similar to

00:16:43,000 --> 00:16:47,709
this but slightly different this is kind

00:16:44,920 --> 00:16:50,410
of my interpretation of it what I find

00:16:47,709 --> 00:16:51,819
works best so if you if you've done a

00:16:50,410 --> 00:16:53,139
little bit of research then this might

00:16:51,819 --> 00:16:54,670
differ a little bit from what you've

00:16:53,139 --> 00:16:58,689
seen traditionally but it should be

00:16:54,670 --> 00:17:00,850
roughly equivalent so the idea behind

00:16:58,689 --> 00:17:03,910
onion architecture is that the outer

00:17:00,850 --> 00:17:06,370
layers depend on and are coupled to the

00:17:03,910 --> 00:17:09,490
inner layers so your infrastructure

00:17:06,370 --> 00:17:11,350
depends on your API your API depends on

00:17:09,490 --> 00:17:14,079
your domain so there's a dependency

00:17:11,350 --> 00:17:16,000
there but on the flip side the inner

00:17:14,079 --> 00:17:20,230
layers don't even know that the outer

00:17:16,000 --> 00:17:21,309
layers exist so your domain has no idea

00:17:20,230 --> 00:17:23,949
that there is an API

00:17:21,309 --> 00:17:27,730
it can't reference any of the code from

00:17:23,949 --> 00:17:29,080
that API in order to achieve this the

00:17:27,730 --> 00:17:31,890
inner layers will often define

00:17:29,080 --> 00:17:35,049
interfaces that may in turn be

00:17:31,890 --> 00:17:36,820
implemented in the outer layers so let's

00:17:35,049 --> 00:17:38,350
just go through the layers very quickly

00:17:36,820 --> 00:17:40,090
here just so that we understand them a

00:17:38,350 --> 00:17:44,740
little bit better at the center we have

00:17:40,090 --> 00:17:46,510
the core I consider the core to be like

00:17:44,740 --> 00:17:46,929
the building blocks the things that you

00:17:46,510 --> 00:17:48,399
build

00:17:46,929 --> 00:17:51,129
your domain out of so this is where you

00:17:48,399 --> 00:17:54,460
find simple things like lists and maps

00:17:51,129 --> 00:17:56,259
and if you're building using actors then

00:17:54,460 --> 00:17:59,080
you might actors might be part of the

00:17:56,259 --> 00:18:00,879
core this is where you put things that

00:17:59,080 --> 00:18:03,190
are not specific to your application

00:18:00,879 --> 00:18:05,350
they're reusable components that you

00:18:03,190 --> 00:18:07,840
could build another application using

00:18:05,350 --> 00:18:09,519
those same components and so they can't

00:18:07,840 --> 00:18:12,820
know anything about the domain or the

00:18:09,519 --> 00:18:14,200
API or the infrastructure outside of

00:18:12,820 --> 00:18:16,179
that we have the domain this is your

00:18:14,200 --> 00:18:19,389
core business logic your core domain

00:18:16,179 --> 00:18:21,940
logic all of that would exist in that

00:18:19,389 --> 00:18:27,970
layer and then outside of that we have

00:18:21,940 --> 00:18:30,070
the API the API is intended to be the

00:18:27,970 --> 00:18:31,960
way that you want other parts of the

00:18:30,070 --> 00:18:34,809
application to communicate with your

00:18:31,960 --> 00:18:37,749
domain it's basically defining the API

00:18:34,809 --> 00:18:39,730
to your domain I've also seen this

00:18:37,749 --> 00:18:41,980
called the services layer I prefer the

00:18:39,730 --> 00:18:44,740
term API just because Services is kind

00:18:41,980 --> 00:18:46,869
of overloaded especially in in domain

00:18:44,740 --> 00:18:48,700
driven design services take on a

00:18:46,869 --> 00:18:52,389
slightly different meaning so I prefer

00:18:48,700 --> 00:18:53,649
to call this the API layer the outside

00:18:52,389 --> 00:18:55,570
of that we have the infrastructure layer

00:18:53,649 --> 00:18:57,639
this is where you get all your external

00:18:55,570 --> 00:19:00,190
dependencies your user interfaces your

00:18:57,639 --> 00:19:02,710
databases all of that stuff exists

00:19:00,190 --> 00:19:06,460
inside of the infrastructure layer so

00:19:02,710 --> 00:19:08,619
we're basically taking our our external

00:19:06,460 --> 00:19:10,990
dependencies and we're pushing it to the

00:19:08,619 --> 00:19:13,749
outer layers rather than having it at

00:19:10,990 --> 00:19:18,429
the bottom or at the top we push it to

00:19:13,749 --> 00:19:20,889
the outer layers so we're going to start

00:19:18,429 --> 00:19:22,600
by talking about the API well wait a

00:19:20,889 --> 00:19:24,100
minute this is domain driven design what

00:19:22,600 --> 00:19:26,950
shouldn't we start by talking about the

00:19:24,100 --> 00:19:28,299
domain I like to start with the API and

00:19:26,950 --> 00:19:31,149
the reason that I like to start with the

00:19:28,299 --> 00:19:34,419
API is because it defines the questions

00:19:31,149 --> 00:19:36,039
that we want to ask about the domain it

00:19:34,419 --> 00:19:38,320
defines essentially our inputs and

00:19:36,039 --> 00:19:40,059
outputs once we have those inputs and

00:19:38,320 --> 00:19:45,610
outputs then we can start flushing out

00:19:40,059 --> 00:19:47,889
our domain so essentially what our API

00:19:45,610 --> 00:19:50,769
is doing is its insulating our domain

00:19:47,889 --> 00:19:52,779
from our infrastructure this keeps it

00:19:50,769 --> 00:19:55,240
consistent and keeps the to from

00:19:52,779 --> 00:19:57,490
bleeding into each other but it also

00:19:55,240 --> 00:20:00,669
provides us with a single consistent

00:19:57,490 --> 00:20:02,859
interface that various parts of the

00:20:00,669 --> 00:20:05,019
sure can talk too so once we've defined

00:20:02,859 --> 00:20:08,799
that API it doesn't matter whether we're

00:20:05,019 --> 00:20:11,529
implementing a REST API on top of it or

00:20:08,799 --> 00:20:13,179
a user interface on top of it or some

00:20:11,529 --> 00:20:15,999
other way of interfacing it with it we

00:20:13,179 --> 00:20:17,799
use the same API so we've essentially

00:20:15,999 --> 00:20:19,869
defined that and the other thing too is

00:20:17,799 --> 00:20:21,489
that once we've defined that API we

00:20:19,869 --> 00:20:23,289
could extract that and put it into a

00:20:21,489 --> 00:20:25,600
library and then we interface with the

00:20:23,289 --> 00:20:27,519
API so there's lots of things that we

00:20:25,600 --> 00:20:30,999
can do once we have that sort of clean

00:20:27,519 --> 00:20:32,619
consistent API that we can work with the

00:20:30,999 --> 00:20:34,659
other thing that this does is it allows

00:20:32,619 --> 00:20:37,359
us to restructure the domain as

00:20:34,659 --> 00:20:39,249
necessary without necessarily affecting

00:20:37,359 --> 00:20:41,470
the infrastructure so as we're evolving

00:20:39,249 --> 00:20:44,409
our code and as we're learning about the

00:20:41,470 --> 00:20:46,419
domain we might need to make changes and

00:20:44,409 --> 00:20:48,609
this allows us to make changes to the

00:20:46,419 --> 00:20:51,299
domain and as long as the API stays the

00:20:48,609 --> 00:20:53,379
same nobody needs to know the difference

00:20:51,299 --> 00:20:55,419
another thing is this is a good place to

00:20:53,379 --> 00:20:57,639
start testing what I like to do is I

00:20:55,419 --> 00:20:59,919
like to write my API and then I like to

00:20:57,639 --> 00:21:04,059
write a high level test and that high

00:20:59,919 --> 00:21:05,649
level test will be basically driving the

00:21:04,059 --> 00:21:09,190
implementation of the domain and we'll

00:21:05,649 --> 00:21:11,019
see an example of that in a moment so

00:21:09,190 --> 00:21:12,609
let's take a first crack at some code I

00:21:11,019 --> 00:21:15,279
did promise that this would be somewhat

00:21:12,609 --> 00:21:18,580
code driven so let's take a let's take a

00:21:15,279 --> 00:21:22,419
quick example here here we have the food

00:21:18,580 --> 00:21:25,059
prep API that I have implemented and it

00:21:22,419 --> 00:21:27,159
has a single method fry which takes a

00:21:25,059 --> 00:21:29,950
parameter of type egg and returns a

00:21:27,159 --> 00:21:33,460
fried egg looks very simple right it's

00:21:29,950 --> 00:21:36,159
actually kind of terrible so this is not

00:21:33,460 --> 00:21:38,470
a very good first attempt at an API so

00:21:36,159 --> 00:21:40,989
let's talk about what's wrong with it

00:21:38,470 --> 00:21:45,279
well first off how do I want my eggs

00:21:40,989 --> 00:21:46,809
cooked all I've done is said I have an

00:21:45,279 --> 00:21:48,759
egg and I'm going to get a fried egg did

00:21:46,809 --> 00:21:51,129
I want that sunny-side up scrambled

00:21:48,759 --> 00:21:52,600
poached there's a number of different

00:21:51,129 --> 00:21:56,289
ways you can cook an egg this does not

00:21:52,600 --> 00:21:57,669
capture that so that's one problem now

00:21:56,289 --> 00:22:00,279
another problem which actually relates

00:21:57,669 --> 00:22:01,960
more to the domain I mean that is a

00:22:00,279 --> 00:22:03,399
domain question as well but another

00:22:01,960 --> 00:22:07,119
problem that is is maybe a little more

00:22:03,399 --> 00:22:09,639
subtle is if I go in and ask somebody to

00:22:07,119 --> 00:22:11,230
cook me an egg do I ever walk up to them

00:22:09,639 --> 00:22:13,659
with an egg and say hey could you please

00:22:11,230 --> 00:22:14,440
cook this for me that's not usually how

00:22:13,659 --> 00:22:16,539
the real world

00:22:14,440 --> 00:22:19,179
works how the real world works as I walk

00:22:16,539 --> 00:22:21,519
up to a cook or a chef or whoever or a

00:22:19,179 --> 00:22:23,169
restaurant and I say I would like an egg

00:22:21,519 --> 00:22:25,659
and I would like it cooked sunny-side up

00:22:23,169 --> 00:22:27,159
and then it's up to them to figure out

00:22:25,659 --> 00:22:29,019
where that egg comes from I'm not going

00:22:27,159 --> 00:22:31,029
to give them give it to them I'll leave

00:22:29,019 --> 00:22:32,860
that to be their job so this doesn't

00:22:31,029 --> 00:22:36,820
really capture what's happening in the

00:22:32,860 --> 00:22:41,470
domain very well another problem here is

00:22:36,820 --> 00:22:44,679
that this is a synchronous API there's

00:22:41,470 --> 00:22:46,899
no way for me to to leave and come back

00:22:44,679 --> 00:22:49,360
when the egg is done this doesn't

00:22:46,899 --> 00:22:51,279
capture the element of time now when I

00:22:49,360 --> 00:22:52,899
ask for an egg to be cooked I don't want

00:22:51,279 --> 00:22:54,669
to have to sit there and wait and wait

00:22:52,899 --> 00:22:56,830
and wait I want to go sit down and read

00:22:54,669 --> 00:22:59,289
the paper or whatever it is I decide to

00:22:56,830 --> 00:23:01,299
do I don't want to be stuck waiting for

00:22:59,289 --> 00:23:02,169
that egg so this doesn't capture time

00:23:01,299 --> 00:23:06,580
very well

00:23:02,169 --> 00:23:10,389
so let's rework this so here's a new

00:23:06,580 --> 00:23:14,230
version of the API here we have a method

00:23:10,389 --> 00:23:18,610
prepare egg takes an egg style returns a

00:23:14,230 --> 00:23:21,700
future of cooked egg okay so how is this

00:23:18,610 --> 00:23:23,460
improved well we're now capturing the

00:23:21,700 --> 00:23:26,470
concept of the egg style that's good

00:23:23,460 --> 00:23:29,769
that's that means I can ask for my egg

00:23:26,470 --> 00:23:32,889
sunny-side up if I want to the other

00:23:29,769 --> 00:23:35,889
thing here is that we are no longer

00:23:32,889 --> 00:23:37,480
handing the egg to the cook and saying

00:23:35,889 --> 00:23:38,889
hey please cook this we're going to

00:23:37,480 --> 00:23:40,960
leave them to go to the fridge and pick

00:23:38,889 --> 00:23:42,370
up the egg that's good it represents

00:23:40,960 --> 00:23:45,149
what happens in the real world a little

00:23:42,370 --> 00:23:47,200
bit better and then another thing is it

00:23:45,149 --> 00:23:50,379
encapsulate s' the concept of time

00:23:47,200 --> 00:23:52,179
inside of the future so I can now make

00:23:50,379 --> 00:23:54,549
this request and then go about my

00:23:52,179 --> 00:23:56,860
business and and I will get notified

00:23:54,549 --> 00:23:59,500
when the egg is done so that's better as

00:23:56,860 --> 00:24:01,960
well another thing is this because we've

00:23:59,500 --> 00:24:04,509
used a future encapsulate s' the idea of

00:24:01,960 --> 00:24:07,570
failures as well which potentially is

00:24:04,509 --> 00:24:09,039
another good thing there's different

00:24:07,570 --> 00:24:11,919
types of failures that could happen in

00:24:09,039 --> 00:24:15,250
our domain so we can have a recoverable

00:24:11,919 --> 00:24:18,340
failure and a recoverable failure would

00:24:15,250 --> 00:24:19,960
be like the egg was dropped and in that

00:24:18,340 --> 00:24:21,309
case I would actually hope that you

00:24:19,960 --> 00:24:22,750
wouldn't come back to me and say I'm

00:24:21,309 --> 00:24:24,399
sorry I dropped your egg I'm going to

00:24:22,750 --> 00:24:27,120
have to cook it again just cook the egg

00:24:24,399 --> 00:24:29,610
again so in that case I would hope that

00:24:27,120 --> 00:24:30,510
we wouldn't actually see the failure but

00:24:29,610 --> 00:24:32,820
on the other hand there are

00:24:30,510 --> 00:24:34,710
unrecoverable failures what happens if

00:24:32,820 --> 00:24:38,059
you turns out somebody forgot to buy the

00:24:34,710 --> 00:24:40,860
eggs well now they can't legitimately

00:24:38,059 --> 00:24:43,080
supply the requests that I have given in

00:24:40,860 --> 00:24:45,000
which case I would need to see that that

00:24:43,080 --> 00:24:46,590
failure they would need to come back to

00:24:45,000 --> 00:24:49,920
me and say look I'm sorry I can't cook

00:24:46,590 --> 00:24:51,300
you an egg I don't have any so that's

00:24:49,920 --> 00:24:55,380
that's an example of an unrecoverable

00:24:51,300 --> 00:24:57,270
failure and this API captures that

00:24:55,380 --> 00:24:59,790
so I mentioned functional testing now

00:24:57,270 --> 00:25:03,150
that I've defined my API I can define a

00:24:59,790 --> 00:25:05,850
functional test around that API so here

00:25:03,150 --> 00:25:07,500
I have a very simple test prepare eggs

00:25:05,850 --> 00:25:10,140
should return a cooked egg with the

00:25:07,500 --> 00:25:12,330
specified style I have this thing called

00:25:10,140 --> 00:25:14,760
test module I'll hopefully explain a

00:25:12,330 --> 00:25:19,110
little bit about those later but then I

00:25:14,760 --> 00:25:21,360
have a style sunny-side up I have an

00:25:19,110 --> 00:25:24,210
expected cooked egg which takes a style

00:25:21,360 --> 00:25:26,309
and then I'm basically calling prepare

00:25:24,210 --> 00:25:28,980
egg and asserting that I get back what I

00:25:26,309 --> 00:25:31,020
expect now this is this is a very simple

00:25:28,980 --> 00:25:33,090
test I'm not testing any edge cases or

00:25:31,020 --> 00:25:34,770
anything like that usually when I'm

00:25:33,090 --> 00:25:36,480
doing a high-level test like this I

00:25:34,770 --> 00:25:39,210
wouldn't test all of the edge cases I

00:25:36,480 --> 00:25:41,460
leave that to the unit tests the point

00:25:39,210 --> 00:25:44,730
of this is that when I write this test

00:25:41,460 --> 00:25:47,340
I'm not mocking or stubbing anything I'm

00:25:44,730 --> 00:25:49,860
going to try to use real repositories

00:25:47,340 --> 00:25:51,840
and and real instances of everything

00:25:49,860 --> 00:25:53,490
wherever possible sometimes that's not

00:25:51,840 --> 00:25:55,380
possible sometimes you might have to do

00:25:53,490 --> 00:25:57,660
a mock or a stop but generally speaking

00:25:55,380 --> 00:25:59,880
I try to avoid that for the high level

00:25:57,660 --> 00:26:05,100
test for low level tests that might

00:25:59,880 --> 00:26:06,929
change now once we have this test we can

00:26:05,100 --> 00:26:10,740
use it to start driving out the domain

00:26:06,929 --> 00:26:13,460
the the API and the tests required us to

00:26:10,740 --> 00:26:17,400
implement a minimal amount of the domain

00:26:13,460 --> 00:26:20,610
classes once we have that we can then

00:26:17,400 --> 00:26:23,910
take the test and use it to drive out

00:26:20,610 --> 00:26:25,830
that that implementation further the API

00:26:23,910 --> 00:26:27,540
may evolve slightly as we go through

00:26:25,830 --> 00:26:29,040
this process and that's okay we don't

00:26:27,540 --> 00:26:31,320
necessarily expect to get it right the

00:26:29,040 --> 00:26:33,480
first time but we want to get it close

00:26:31,320 --> 00:26:35,040
so we want to think about the API as

00:26:33,480 --> 00:26:37,290
much as possible so that we're only

00:26:35,040 --> 00:26:39,770
making subtle evolutions as we drive out

00:26:37,290 --> 00:26:39,770
the domain

00:26:40,140 --> 00:26:44,050
okay so let's look at some of the

00:26:42,220 --> 00:26:47,170
examples of the things that we created

00:26:44,050 --> 00:26:49,750
so in order to implement the test we

00:26:47,170 --> 00:26:53,320
needed an egg style here I have a sealed

00:26:49,750 --> 00:26:55,420
trait which is called egg style I have

00:26:53,320 --> 00:26:57,880
an object egg style which has scrambled

00:26:55,420 --> 00:27:00,580
sunny-side up poached I have a sealed

00:26:57,880 --> 00:27:02,860
trait egg and then I have a raw egg and

00:27:00,580 --> 00:27:05,580
a cooked egg both of these are

00:27:02,860 --> 00:27:09,430
implemented as algebraic data types

00:27:05,580 --> 00:27:14,430
which are actually very good for domain

00:27:09,430 --> 00:27:17,970
driven design so why are they good

00:27:14,430 --> 00:27:21,730
algebraic data types allow us to capture

00:27:17,970 --> 00:27:24,070
domain logic in the type system so

00:27:21,730 --> 00:27:27,070
rather than trying to capture that logic

00:27:24,070 --> 00:27:28,870
through a number of tests and various

00:27:27,070 --> 00:27:30,790
methods and and things like that

00:27:28,870 --> 00:27:33,640
we can actually capture that in the type

00:27:30,790 --> 00:27:36,340
system this provides us with added type

00:27:33,640 --> 00:27:38,200
safety but the other thing is that it

00:27:36,340 --> 00:27:41,230
means that the compiler can actually be

00:27:38,200 --> 00:27:43,210
checking the rules of our domain rather

00:27:41,230 --> 00:27:44,920
than us having to write tests to do it

00:27:43,210 --> 00:27:47,830
don't get me wrong I love writing tests

00:27:44,920 --> 00:27:51,480
but if I can get the compiler to do the

00:27:47,830 --> 00:27:51,480
work for me that's going to be better a

00:27:51,600 --> 00:27:56,860
related concept to algebraic data types

00:27:54,250 --> 00:28:00,400
is tiny types sometimes called wrapper

00:27:56,860 --> 00:28:02,860
types and the basic idea here is rather

00:28:00,400 --> 00:28:03,670
than using things like strings integers

00:28:02,860 --> 00:28:06,340
floats

00:28:03,670 --> 00:28:08,770
you know just bear data types we use

00:28:06,340 --> 00:28:11,710
wrapper types instead and these

00:28:08,770 --> 00:28:14,290
lightweight wrapper types allow us to

00:28:11,710 --> 00:28:18,790
again capture more information about the

00:28:14,290 --> 00:28:22,240
domain in the types they allow us to for

00:28:18,790 --> 00:28:24,400
example put in things like validation

00:28:22,240 --> 00:28:26,470
logic if we need to we can attach those

00:28:24,400 --> 00:28:29,170
to the wrapper types we can as the

00:28:26,470 --> 00:28:30,670
domain grows these wrapper types may

00:28:29,170 --> 00:28:32,530
grow into something that is no longer

00:28:30,670 --> 00:28:34,540
really a lightweight wrapper type

00:28:32,530 --> 00:28:37,030
anymore this gives us a place to grow

00:28:34,540 --> 00:28:40,000
but the other thing is that that added

00:28:37,030 --> 00:28:44,140
type safety so in in our cooking domain

00:28:40,000 --> 00:28:48,010
if I'm cooking a big pan of eggs and I

00:28:44,140 --> 00:28:50,920
have to add a teaspoon of salt to those

00:28:48,010 --> 00:28:52,210
eggs now a teaspoon and a tablespoon are

00:28:50,920 --> 00:28:54,700
very different things

00:28:52,210 --> 00:28:57,610
if I add the wrong one I'm going to make

00:28:54,700 --> 00:29:00,279
a really big mess by capturing this

00:28:57,610 --> 00:29:02,049
information and the type rather so I

00:29:00,279 --> 00:29:04,990
would create a type of teaspoon or a

00:29:02,049 --> 00:29:07,510
type of tablespoon by capturing that in

00:29:04,990 --> 00:29:09,400
the type I prevent myself from making a

00:29:07,510 --> 00:29:11,320
mistake later like passing in

00:29:09,400 --> 00:29:12,789
tablespoons when I meant teaspoons which

00:29:11,320 --> 00:29:16,900
could happen if it was just an integer

00:29:12,789 --> 00:29:18,340
or a float or something like that the

00:29:16,900 --> 00:29:20,169
other thing too is this just enriches

00:29:18,340 --> 00:29:22,450
the domain when you have all of these

00:29:20,169 --> 00:29:25,270
types and you start looking at your code

00:29:22,450 --> 00:29:27,309
you see this rich domain with all of

00:29:25,270 --> 00:29:31,779
these you know tablespoon teaspoon egg

00:29:27,309 --> 00:29:34,149
eggs style all of these things it makes

00:29:31,779 --> 00:29:35,649
your domain very rich rather than being

00:29:34,149 --> 00:29:38,830
very anemic which is something that we

00:29:35,649 --> 00:29:41,049
want to try to avoid so here's an

00:29:38,830 --> 00:29:44,799
example of a tiny type I've just used a

00:29:41,049 --> 00:29:46,270
cook ID here so my my ID is going to be

00:29:44,799 --> 00:29:47,890
a string it could be anything it could

00:29:46,270 --> 00:29:49,990
be a good or an int or whatever but I've

00:29:47,890 --> 00:29:53,049
used a string but rather than using a

00:29:49,990 --> 00:29:55,570
bare string I've wrapped it in a cook ID

00:29:53,049 --> 00:29:57,549
and this means that I can't accidentally

00:29:55,570 --> 00:30:00,039
pass the cooks name when I meant to pass

00:29:57,549 --> 00:30:03,010
the cooks ID it just prevents those

00:30:00,039 --> 00:30:06,909
kinds of mistakes I've used the Scala an

00:30:03,010 --> 00:30:09,880
eval here and this allows me to reduce

00:30:06,909 --> 00:30:12,820
the cost of using this wrapper type it

00:30:09,880 --> 00:30:16,450
just makes the makes the memory usage a

00:30:12,820 --> 00:30:18,490
little more efficient and of course it

00:30:16,450 --> 00:30:20,260
allows us to later enrich the the class

00:30:18,490 --> 00:30:22,390
if I later needed to add validation

00:30:20,260 --> 00:30:27,210
logic here to ensure that it was a valid

00:30:22,390 --> 00:30:27,210
ID I could put that inside of this class

00:30:28,169 --> 00:30:34,360
okay so we have identified our cook we

00:30:32,350 --> 00:30:37,510
have an ID for them now this means that

00:30:34,360 --> 00:30:41,230
our cook is an entity the question then

00:30:37,510 --> 00:30:43,510
becomes is our cook an aggregate root I

00:30:41,230 --> 00:30:46,720
mentioned aggregate roots very briefly

00:30:43,510 --> 00:30:48,220
our cook could be an aggregate root but

00:30:46,720 --> 00:30:50,080
let's talk about it a little bit does

00:30:48,220 --> 00:30:52,179
does our cook aggregate other things

00:30:50,080 --> 00:30:54,940
they might they might aggregate a frying

00:30:52,179 --> 00:30:58,120
pan a spatula an egg timer these all

00:30:54,940 --> 00:31:00,909
might be underneath the cook but should

00:30:58,120 --> 00:31:04,440
they that's another question is is this

00:31:00,909 --> 00:31:04,440
a valid aggregation

00:31:04,480 --> 00:31:08,859
another thing that we have to ask

00:31:05,980 --> 00:31:11,200
ourselves is will we be doing a lot of

00:31:08,859 --> 00:31:13,239
operations with the cook or will we be

00:31:11,200 --> 00:31:15,999
going directly to the frying pan for

00:31:13,239 --> 00:31:18,220
example it's a good chance that we will

00:31:15,999 --> 00:31:20,590
be interfacing with the cook a lot so

00:31:18,220 --> 00:31:22,239
again that hints that this might be an

00:31:20,590 --> 00:31:23,889
aggregate route but let's let's take a

00:31:22,239 --> 00:31:25,989
look at this in a little more detail how

00:31:23,889 --> 00:31:28,149
do we know whether it's an aggregate

00:31:25,989 --> 00:31:30,070
route so what are the qualities of an

00:31:28,149 --> 00:31:33,129
aggregate route well it aggregates other

00:31:30,070 --> 00:31:35,799
entities it also controls access to

00:31:33,129 --> 00:31:37,419
those entities so if I have an aggregate

00:31:35,799 --> 00:31:39,190
route and I want to get access to

00:31:37,419 --> 00:31:41,350
something under that aggregate route I

00:31:39,190 --> 00:31:43,779
can't access it directly I have to go

00:31:41,350 --> 00:31:46,659
through the aggregate route other

00:31:43,779 --> 00:31:48,309
entities are forbidden from accessing

00:31:46,659 --> 00:31:52,029
without going through the aggregate

00:31:48,309 --> 00:31:54,220
route first it's not always obvious what

00:31:52,029 --> 00:31:55,419
your aggregate route is and to be

00:31:54,220 --> 00:31:58,899
perfectly honest if you're building

00:31:55,419 --> 00:32:01,059
using domain driven design it I wouldn't

00:31:58,899 --> 00:32:03,759
care if you got your aggregate routes

00:32:01,059 --> 00:32:05,230
wrong you know we expect to evolve

00:32:03,759 --> 00:32:07,929
things a little bit and it's not always

00:32:05,230 --> 00:32:09,789
obvious so so that that's okay but let's

00:32:07,929 --> 00:32:11,109
think about what are some of the some of

00:32:09,789 --> 00:32:13,539
the things we can use to determine

00:32:11,109 --> 00:32:16,090
whether our cook should be the aggregate

00:32:13,539 --> 00:32:18,879
route does it really aggregate frying

00:32:16,090 --> 00:32:22,769
pans spatula egg timer or are we just

00:32:18,879 --> 00:32:25,450
creating that aggregation arbitrarily

00:32:22,769 --> 00:32:27,639
well let's think about what happens when

00:32:25,450 --> 00:32:31,029
you delete a cook if you delete a cook

00:32:27,639 --> 00:32:32,950
does the frying pan go with it a lot of

00:32:31,029 --> 00:32:34,419
you probably would say well no I mean if

00:32:32,950 --> 00:32:35,980
you kick the cook out of the kitchen the

00:32:34,419 --> 00:32:38,080
frying pan stays behind it doesn't

00:32:35,980 --> 00:32:39,789
disappear so in that case maybe it's not

00:32:38,080 --> 00:32:41,559
maybe it's not an aggregate route maybe

00:32:39,789 --> 00:32:43,600
it doesn't aggregate the frying pan but

00:32:41,559 --> 00:32:45,220
let me ask you this if you kick the cook

00:32:43,600 --> 00:32:47,889
out of the kitchen does the frying pan

00:32:45,220 --> 00:32:51,129
ever have any purpose is it useful at

00:32:47,889 --> 00:32:53,049
all a frying pan without the presence of

00:32:51,129 --> 00:32:56,139
a cook is a big hunk of metal it has

00:32:53,049 --> 00:32:57,879
absolutely no purpose so in that respect

00:32:56,139 --> 00:33:00,369
you could almost think about it as well

00:32:57,879 --> 00:33:02,440
the cook needs to exist in order for the

00:33:00,369 --> 00:33:06,059
frying pan to do anything so maybe it

00:33:02,440 --> 00:33:09,129
does in fact aggregate the frying pan if

00:33:06,059 --> 00:33:10,749
that's the case then it's possible it's

00:33:09,129 --> 00:33:12,519
possible that it is part of an aggregate

00:33:10,749 --> 00:33:15,249
and possible that it could be the

00:33:12,519 --> 00:33:17,019
aggregate root and then we go back to

00:33:15,249 --> 00:33:18,200
the question of well when we do

00:33:17,019 --> 00:33:20,300
operations on the

00:33:18,200 --> 00:33:22,100
are we always interacting with the cook

00:33:20,300 --> 00:33:24,950
or are we interacting with something

00:33:22,100 --> 00:33:26,660
else again in this particular domain we

00:33:24,950 --> 00:33:28,100
probably start with the cook we go to

00:33:26,660 --> 00:33:30,470
the cook and say please cook me an egg

00:33:28,100 --> 00:33:33,440
so that's sort of our first entry point

00:33:30,470 --> 00:33:38,390
which again suggests the cook cut could

00:33:33,440 --> 00:33:39,950
be our aggregate route we talked about

00:33:38,390 --> 00:33:41,930
the frying pan so here we have an

00:33:39,950 --> 00:33:43,430
implementation of a frying pan now if

00:33:41,930 --> 00:33:44,900
everybody got up and started leaving

00:33:43,430 --> 00:33:47,500
after seeing this implementation I

00:33:44,900 --> 00:33:49,910
wouldn't blame you this is terrible

00:33:47,500 --> 00:33:52,160
the funny thing is this is actually the

00:33:49,910 --> 00:33:54,830
code that I started with so this is this

00:33:52,160 --> 00:33:56,630
is not something I mocked up for for the

00:33:54,830 --> 00:33:58,130
purpose of this presentation I started

00:33:56,630 --> 00:34:01,250
with this and went oh my god what have I

00:33:58,130 --> 00:34:06,290
written so let's take a look at why this

00:34:01,250 --> 00:34:08,420
is such terrible code alright so we have

00:34:06,290 --> 00:34:09,950
a frying pan the frying pan is going to

00:34:08,420 --> 00:34:12,740
be empty or full so we need to be able

00:34:09,950 --> 00:34:16,550
to add an egg to it so we have an option

00:34:12,740 --> 00:34:18,110
of partially cooked egg and we're going

00:34:16,550 --> 00:34:20,120
to default that to none so that our

00:34:18,110 --> 00:34:21,920
frying pan starts empty then we're going

00:34:20,120 --> 00:34:24,470
to have an ADD method where which is

00:34:21,920 --> 00:34:26,720
going to allow us to add an egg to the

00:34:24,470 --> 00:34:29,030
frying pan now that actually ends up

00:34:26,720 --> 00:34:30,710
returning a try because there's the

00:34:29,030 --> 00:34:32,360
possibility that when we go to add an

00:34:30,710 --> 00:34:33,590
egg to the frying pan there's already an

00:34:32,360 --> 00:34:34,970
egg in the frying pan and there's no

00:34:33,590 --> 00:34:36,290
room this is one of those tiny little

00:34:34,970 --> 00:34:39,710
frying pans that you buy at the grocery

00:34:36,290 --> 00:34:41,570
store it can only hold one egg so we go

00:34:39,710 --> 00:34:42,650
to put our egg in and it's full okay

00:34:41,570 --> 00:34:44,960
well now we're going to throw an

00:34:42,650 --> 00:34:47,620
exception a frying pan full exception

00:34:44,960 --> 00:34:50,180
and then later on we're going to try to

00:34:47,620 --> 00:34:51,380
remove an egg but oh you know what

00:34:50,180 --> 00:34:53,150
actually there wasn't an egg in the

00:34:51,380 --> 00:34:55,460
frying pan so now we got to throw an

00:34:53,150 --> 00:34:57,710
exception again so this code is not

00:34:55,460 --> 00:35:00,170
great it's it's awkward to use and it's

00:34:57,710 --> 00:35:00,890
awkward to test it's actually wrong as

00:35:00,170 --> 00:35:03,500
well

00:35:00,890 --> 00:35:06,170
what do I mean by that what I mean is

00:35:03,500 --> 00:35:09,980
this does not reflect the domain the

00:35:06,170 --> 00:35:11,960
domain in in the domain you never get a

00:35:09,980 --> 00:35:14,240
cook who walks up to an empty frying pan

00:35:11,960 --> 00:35:15,950
and drops an egg in or sorry a full

00:35:14,240 --> 00:35:18,230
frying pan and drops an egg in it that

00:35:15,950 --> 00:35:20,390
doesn't happen the cook is going to walk

00:35:18,230 --> 00:35:22,160
up to the frying pan look and go there's

00:35:20,390 --> 00:35:24,920
an egg in here I'm not going to try to

00:35:22,160 --> 00:35:26,420
add another one so they actually pay

00:35:24,920 --> 00:35:28,670
attention to that kind of thing so this

00:35:26,420 --> 00:35:30,350
doesn't reflect that this allows them to

00:35:28,670 --> 00:35:30,710
throw an egg into a full frying pan and

00:35:30,350 --> 00:35:33,230
then every

00:35:30,710 --> 00:35:35,690
just explodes which again doesn't

00:35:33,230 --> 00:35:37,430
reflect the domain very well so this is

00:35:35,690 --> 00:35:39,440
this is awkward and the other thing too

00:35:37,430 --> 00:35:41,599
is I'm showed this but the tests for

00:35:39,440 --> 00:35:44,180
this when I wrote them oh my god were

00:35:41,599 --> 00:35:45,710
they terrible like this many tests

00:35:44,180 --> 00:35:49,040
because I had to test all of those edge

00:35:45,710 --> 00:35:51,619
cases it was horrible okay so can we

00:35:49,040 --> 00:35:53,690
make this better so here's an

00:35:51,619 --> 00:35:58,190
alternative implementation which i think

00:35:53,690 --> 00:36:00,320
is better here we have a sealed trait

00:35:58,190 --> 00:36:02,510
frying pan we have an empty frying pan

00:36:00,320 --> 00:36:04,520
which extends frying pan and we have a

00:36:02,510 --> 00:36:07,010
full frying pan which extends frying pan

00:36:04,520 --> 00:36:09,859
what's interesting here is that now it's

00:36:07,010 --> 00:36:11,359
impossible to add an egg to a full part

00:36:09,859 --> 00:36:13,490
frying pan there's no method to do that

00:36:11,359 --> 00:36:15,710
it's also impossible to remove an egg

00:36:13,490 --> 00:36:17,690
from an empty frying pan again no method

00:36:15,710 --> 00:36:21,589
to do that you'll notice between the two

00:36:17,690 --> 00:36:25,160
our code is about half as much which is

00:36:21,589 --> 00:36:28,330
also interesting more importantly when

00:36:25,160 --> 00:36:33,050
you look about look at this options gone

00:36:28,330 --> 00:36:35,240
exceptions gone tries gone all of those

00:36:33,050 --> 00:36:37,430
complex things that we're giving us

00:36:35,240 --> 00:36:38,599
grief in the last slide completely gone

00:36:37,430 --> 00:36:41,690
away we don't have to deal with them

00:36:38,599 --> 00:36:44,210
anymore and this is a better

00:36:41,690 --> 00:36:46,460
representation of the domain we've

00:36:44,210 --> 00:36:50,390
actually encoded some of the logic into

00:36:46,460 --> 00:36:53,599
the type itself where we have said you

00:36:50,390 --> 00:36:55,990
can't add an egg to a full frying pan

00:36:53,599 --> 00:36:58,609
that logic is encoded in the type system

00:36:55,990 --> 00:37:00,440
that's fantastic because now we have

00:36:58,609 --> 00:37:03,230
compile time checking of our domain

00:37:00,440 --> 00:37:04,760
model which means that guess what

00:37:03,230 --> 00:37:07,220
happened to my tests when I wrote them

00:37:04,760 --> 00:37:09,680
they went from this many tests to this

00:37:07,220 --> 00:37:12,230
many tests because I don't have to test

00:37:09,680 --> 00:37:13,730
all those edge cases anymore and from a

00:37:12,230 --> 00:37:15,200
domain perspective this is more

00:37:13,730 --> 00:37:17,570
realistic because when I write the code

00:37:15,200 --> 00:37:20,150
for the cook the cook is going to go and

00:37:17,570 --> 00:37:22,250
look at the frying pan and say well is

00:37:20,150 --> 00:37:25,580
it an empty frying pan if so do this is

00:37:22,250 --> 00:37:27,500
it a full frying pan if so do that so

00:37:25,580 --> 00:37:32,510
this actually better reflects the domain

00:37:27,500 --> 00:37:35,330
as well so what's the point of that

00:37:32,510 --> 00:37:37,040
example the point of that example is

00:37:35,330 --> 00:37:39,530
that domain driven design is not about

00:37:37,040 --> 00:37:41,180
getting it right the first time we never

00:37:39,530 --> 00:37:42,950
know the truth of the domain until we've

00:37:41,180 --> 00:37:44,140
spent time with it until we've actually

00:37:42,950 --> 00:37:46,540
spent a little bit

00:37:44,140 --> 00:37:49,180
writing the code we don't know what the

00:37:46,540 --> 00:37:51,070
final result is going to look like the

00:37:49,180 --> 00:37:54,010
domain may change there may be new laws

00:37:51,070 --> 00:37:56,620
new technologies that come into play and

00:37:54,010 --> 00:37:59,170
we have to be prepared to evolve the

00:37:56,620 --> 00:38:02,080
model as we go domain models aren't

00:37:59,170 --> 00:38:05,800
fixed we need to be prepared to change

00:38:02,080 --> 00:38:07,390
them we can't couple them to other parts

00:38:05,800 --> 00:38:09,040
of our code because if we do that then

00:38:07,390 --> 00:38:12,340
we prevent ourselves from making those

00:38:09,040 --> 00:38:14,500
changes domain driven design and onion

00:38:12,340 --> 00:38:17,590
architecture to help us evolve the model

00:38:14,500 --> 00:38:18,760
by separating out those concerns the

00:38:17,590 --> 00:38:20,140
domain is separated from the

00:38:18,760 --> 00:38:23,470
infrastructure so it can evolve

00:38:20,140 --> 00:38:27,220
independently and the API layer provides

00:38:23,470 --> 00:38:30,730
that separation repositories and

00:38:27,220 --> 00:38:32,260
factories are part of the domain we can

00:38:30,730 --> 00:38:33,910
implement them in the nursery we can

00:38:32,260 --> 00:38:35,340
define them in the domain but we often

00:38:33,910 --> 00:38:38,590
implement them in the infrastructure

00:38:35,340 --> 00:38:40,420
they're usually there will be an element

00:38:38,590 --> 00:38:41,890
of the infrastructure like a file system

00:38:40,420 --> 00:38:44,260
or a database or something like that

00:38:41,890 --> 00:38:46,360
that we need in order to access them

00:38:44,260 --> 00:38:48,850
well we can't put that in the domain so

00:38:46,360 --> 00:38:50,650
we create a repository or a factory to

00:38:48,850 --> 00:38:52,150
wrap that and I just want to be clear

00:38:50,650 --> 00:38:54,370
here that this is not a wrapper around

00:38:52,150 --> 00:38:56,620
databases this is a wrapper around data

00:38:54,370 --> 00:39:03,310
access it could be a database but it

00:38:56,620 --> 00:39:05,710
could be other things as well so here's

00:39:03,310 --> 00:39:10,120
a very simple example of a trait for an

00:39:05,710 --> 00:39:11,620
egg repository I want to point out here

00:39:10,120 --> 00:39:14,590
that there's nothing here to indicate

00:39:11,620 --> 00:39:17,290
the nature of this repository this could

00:39:14,590 --> 00:39:20,830
be a carton could be a fridge it could

00:39:17,290 --> 00:39:22,300
be a chicken actually no I guess chicken

00:39:20,830 --> 00:39:24,370
would be more like an egg Factory I

00:39:22,300 --> 00:39:28,270
don't know how you would add an egg to a

00:39:24,370 --> 00:39:30,700
chicken but it sounds messy so in the

00:39:28,270 --> 00:39:32,650
example code for this I have provided in

00:39:30,700 --> 00:39:35,110
memory implementations of repositories

00:39:32,650 --> 00:39:37,060
but they could easily be replaced with

00:39:35,110 --> 00:39:39,580
database access or file system or REST

00:39:37,060 --> 00:39:40,780
API or whatever the point is that we're

00:39:39,580 --> 00:39:43,450
not tied to any particular

00:39:40,780 --> 00:39:47,110
implementation here and we can change it

00:39:43,450 --> 00:39:49,390
as necessary onion architecture in order

00:39:47,110 --> 00:39:50,530
to achieve a lot of this relies fairly

00:39:49,390 --> 00:39:52,450
heavily on the dependency inversion

00:39:50,530 --> 00:39:54,670
principle which is that high-level

00:39:52,450 --> 00:39:58,740
modules should not depend on low-level

00:39:54,670 --> 00:39:58,740
modules both should depend on abstract

00:39:59,099 --> 00:40:04,739
in that wording I guess the high level

00:40:03,089 --> 00:40:07,349
modules you can think of as the inner

00:40:04,739 --> 00:40:09,059
layers of the onion the low level

00:40:07,349 --> 00:40:13,289
modules then are the outer layers of the

00:40:09,059 --> 00:40:14,999
onion the domain often defines traits

00:40:13,289 --> 00:40:16,559
that are implemented in the

00:40:14,999 --> 00:40:19,289
infrastructure like in the case of the

00:40:16,559 --> 00:40:23,160
repository and we often use dependency

00:40:19,289 --> 00:40:24,900
injection in order to do this so what

00:40:23,160 --> 00:40:27,839
might that dependency injection look

00:40:24,900 --> 00:40:30,839
like hopefully you can read this it

00:40:27,839 --> 00:40:32,910
might be a little small but this is an

00:40:30,839 --> 00:40:35,009
example of dependency injection that I

00:40:32,910 --> 00:40:37,380
like to use this uses something called

00:40:35,009 --> 00:40:40,589
the thin cake pattern which I have

00:40:37,380 --> 00:40:43,380
adapted for onion architecture there's a

00:40:40,589 --> 00:40:44,729
blog post by i think adam wore ski who

00:40:43,380 --> 00:40:48,479
actually i think might be here today

00:40:44,729 --> 00:40:50,339
somewhere but there's a blog post on

00:40:48,479 --> 00:40:53,339
this online if you want more details I

00:40:50,339 --> 00:40:54,869
like this pattern because I find it

00:40:53,339 --> 00:40:57,829
gives you very clean code without having

00:40:54,869 --> 00:41:04,529
to rely on external dependency injection

00:40:57,829 --> 00:41:07,109
module or frameworks sorry basically

00:41:04,529 --> 00:41:10,440
here what we have is we create modules

00:41:07,109 --> 00:41:12,809
in my case because I'm using onion

00:41:10,440 --> 00:41:15,989
architecture I like to use modules that

00:41:12,809 --> 00:41:17,849
are named according to the piece of the

00:41:15,989 --> 00:41:20,640
onion that they are intended to create

00:41:17,849 --> 00:41:22,410
so I have a domain module an API module

00:41:20,640 --> 00:41:24,269
and an infrastructure module and you'll

00:41:22,410 --> 00:41:26,759
note that my dependencies match the

00:41:24,269 --> 00:41:28,979
onion arc architecture dependencies my

00:41:26,759 --> 00:41:31,710
infrastructure module depends on the API

00:41:28,979 --> 00:41:33,420
module and the domain module but my

00:41:31,710 --> 00:41:34,859
domain module depends on nothing it

00:41:33,420 --> 00:41:37,950
doesn't know that the other modules

00:41:34,859 --> 00:41:40,229
exist incidentally when I build using

00:41:37,950 --> 00:41:42,119
this style I separate my package

00:41:40,229 --> 00:41:44,700
structures the same so you would find

00:41:42,119 --> 00:41:47,519
the domain model in sorry domain module

00:41:44,700 --> 00:41:51,180
inside the domain package alongside all

00:41:47,519 --> 00:41:53,130
of the domain code and then because I've

00:41:51,180 --> 00:41:55,739
done that you will not find any

00:41:53,130 --> 00:41:57,329
references inside my domain package to

00:41:55,739 --> 00:42:04,920
anything inside the infrastructure

00:41:57,329 --> 00:42:07,499
package so enclosing domain driven

00:42:04,920 --> 00:42:10,119
design is evolutionary we don't build it

00:42:07,499 --> 00:42:13,089
once and call it done we have to learn

00:42:10,119 --> 00:42:15,339
as we go we saw many examples as I was

00:42:13,089 --> 00:42:16,690
working through code where I wrote some

00:42:15,339 --> 00:42:18,849
code and then I went well that kind of

00:42:16,690 --> 00:42:22,029
sucks and I rewrote the code we don't do

00:42:18,849 --> 00:42:25,509
it once and call it done domain driven

00:42:22,029 --> 00:42:27,279
design if you do it well can result in

00:42:25,509 --> 00:42:29,349
code that can be very readable very

00:42:27,279 --> 00:42:30,869
maintainable and very portable I

00:42:29,349 --> 00:42:34,420
mentioned the idea that you could take

00:42:30,869 --> 00:42:37,869
your API and extract that to a library

00:42:34,420 --> 00:42:41,019
which makes it very portable in past

00:42:37,869 --> 00:42:43,240
projects it was quite common for my team

00:42:41,019 --> 00:42:44,920
to invisibly change database

00:42:43,240 --> 00:42:47,019
implementations without anybody noticing

00:42:44,920 --> 00:42:48,670
and that could be anything from changing

00:42:47,019 --> 00:42:51,160
the table structure to literally

00:42:48,670 --> 00:42:54,490
swapping out a different database and

00:42:51,160 --> 00:42:57,190
nobody notices because the repository

00:42:54,490 --> 00:43:00,069
itself hasn't changed we would use that

00:42:57,190 --> 00:43:02,410
same technique to do live migrations

00:43:00,069 --> 00:43:05,259
where we're migrating from one database

00:43:02,410 --> 00:43:07,299
to another and everybody's still reading

00:43:05,259 --> 00:43:08,740
and writing to the database and nobody

00:43:07,299 --> 00:43:12,369
knows the difference because we've

00:43:08,740 --> 00:43:14,710
created a layer in between we also did

00:43:12,369 --> 00:43:17,349
things like we would implement a domain

00:43:14,710 --> 00:43:19,299
model with an API on top of it and then

00:43:17,349 --> 00:43:21,400
later we would go that's all wrong we've

00:43:19,299 --> 00:43:23,499
done this horribly horribly wrong it's

00:43:21,400 --> 00:43:25,539
inefficient there's problems and then we

00:43:23,499 --> 00:43:27,609
would rewrite the whole domain model but

00:43:25,539 --> 00:43:31,690
the API didn't change so nobody knew

00:43:27,609 --> 00:43:34,180
nobody knew that anything happened the

00:43:31,690 --> 00:43:36,099
idea here is that we want to move away

00:43:34,180 --> 00:43:37,989
from worrying about those specific

00:43:36,099 --> 00:43:39,940
implementation details about well what

00:43:37,989 --> 00:43:41,769
is the database what is the user

00:43:39,940 --> 00:43:44,589
interface what are all of these things

00:43:41,769 --> 00:43:47,319
we want to instead focus on how the

00:43:44,589 --> 00:43:49,029
software will be used not the user

00:43:47,319 --> 00:43:51,309
interface and things like that that's

00:43:49,029 --> 00:43:54,220
just presentation so what we really want

00:43:51,309 --> 00:43:55,900
to ask is if the software wasn't there

00:43:54,220 --> 00:43:57,970
if we remove the software from the

00:43:55,900 --> 00:43:59,950
equation what would it look like what

00:43:57,970 --> 00:44:02,220
would the model look like at that point

00:43:59,950 --> 00:44:04,329
and that's what we're trying to build

00:44:02,220 --> 00:44:06,339
domain driven design then is about

00:44:04,329 --> 00:44:08,499
finding the people who can answer those

00:44:06,339 --> 00:44:10,299
questions and talking to them in a

00:44:08,499 --> 00:44:11,859
language that they can understand if

00:44:10,299 --> 00:44:14,440
they can't understand us we can't have a

00:44:11,859 --> 00:44:16,749
conversation about it we then take that

00:44:14,440 --> 00:44:18,130
understanding and we reflect it in the

00:44:16,749 --> 00:44:19,869
code which is what I've been trying to

00:44:18,130 --> 00:44:23,140
do through the presentation using words

00:44:19,869 --> 00:44:24,000
like frying pan cook etc and if we're

00:44:23,140 --> 00:44:26,550
able to do that

00:44:24,000 --> 00:44:28,680
then we can create something that we can

00:44:26,550 --> 00:44:32,550
sit and have a conversation about with

00:44:28,680 --> 00:44:34,620
our our designers with our marketing

00:44:32,550 --> 00:44:36,600
people with anybody from our company and

00:44:34,620 --> 00:44:39,990
they will understand exactly what we're

00:44:36,600 --> 00:44:42,540
talking about if you want to see more

00:44:39,990 --> 00:44:44,940
details about the code it's all

00:44:42,540 --> 00:44:47,340
available at my github repo you can find

00:44:44,940 --> 00:44:49,890
me on Twitter and LinkedIn

00:44:47,340 --> 00:44:52,500
and otherwise please do remember to rate

00:44:49,890 --> 00:45:09,990
the session and if anybody has any

00:44:52,500 --> 00:45:12,420
questions I can take them now yes yes it

00:45:09,990 --> 00:45:15,210
returns an option in your tests how

00:45:12,420 --> 00:45:18,060
would you stub out that repository which

00:45:15,210 --> 00:45:20,760
you make like repository stub that

00:45:18,060 --> 00:45:25,500
returns egg and repository stub that

00:45:20,760 --> 00:45:27,120
returns no egg so I mean it depends I

00:45:25,500 --> 00:45:28,710
guess on whether you want to use a stub

00:45:27,120 --> 00:45:29,910
or a mocking framework or something like

00:45:28,710 --> 00:45:31,290
that I mean if you use a mocking

00:45:29,910 --> 00:45:33,990
framework then you can just

00:45:31,290 --> 00:45:36,510
conditionally say well sometimes return

00:45:33,990 --> 00:45:38,340
this or in this condition return

00:45:36,510 --> 00:45:42,000
something else you could create

00:45:38,340 --> 00:45:43,830
individual stubs you know one for an

00:45:42,000 --> 00:45:46,110
empty repository one for a full

00:45:43,830 --> 00:45:47,280
repository one thing that I will often

00:45:46,110 --> 00:45:48,900
do though is I will often actually

00:45:47,280 --> 00:45:50,400
create an in-memory version of the

00:45:48,900 --> 00:45:52,710
repository and then I'll just use that

00:45:50,400 --> 00:45:54,330
throughout my code so that's another

00:45:52,710 --> 00:45:56,550
possibility as well because you can add

00:45:54,330 --> 00:45:58,440
to it right so you can it at the

00:45:56,550 --> 00:46:00,810
beginning of your test you can add and

00:45:58,440 --> 00:46:02,700
then you know that there's an egg in

00:46:00,810 --> 00:46:04,530
there and then when you try to find it

00:46:02,700 --> 00:46:10,740
you'll get it so that's another way that

00:46:04,530 --> 00:46:14,490
I often do it as well so question more

00:46:10,740 --> 00:46:15,960
on domain driven design I whenever it's

00:46:14,490 --> 00:46:18,270
presented it's always talked about how

00:46:15,960 --> 00:46:20,400
it'll be easy to talk to product owners

00:46:18,270 --> 00:46:22,980
and business people I've actually

00:46:20,400 --> 00:46:25,590
experienced the exact opposite and that

00:46:22,980 --> 00:46:28,680
most of the product people in business

00:46:25,590 --> 00:46:31,110
people have been taught some level of

00:46:28,680 --> 00:46:34,350
technical information which I view is

00:46:31,110 --> 00:46:36,300
very bad because then they request new

00:46:34,350 --> 00:46:36,829
features in terms of technology they

00:46:36,300 --> 00:46:40,160
don't

00:46:36,829 --> 00:46:42,259
and from how do if you're in a larger

00:46:40,160 --> 00:46:46,009
organization where this is you know this

00:46:42,259 --> 00:46:49,249
is everywhere how do you get to talking

00:46:46,009 --> 00:46:51,589
at the domain level any any ideas or

00:46:49,249 --> 00:46:54,559
suggestions on how to instead of talking

00:46:51,589 --> 00:46:57,920
details and technologies how to how to

00:46:54,559 --> 00:46:59,599
shift to domain discussions yeah it's

00:46:57,920 --> 00:47:01,489
definitely a challenge and I mean I'm

00:46:59,599 --> 00:47:04,579
not sure that there's any one universal

00:47:01,489 --> 00:47:05,660
answer but you know in the past when

00:47:04,579 --> 00:47:07,009
I've been in those kinds of meetings

00:47:05,660 --> 00:47:09,410
where people start delving into

00:47:07,009 --> 00:47:11,059
implementation details often what I will

00:47:09,410 --> 00:47:13,519
do is I'll just basically say hold on

00:47:11,059 --> 00:47:15,319
now can we step back a level you know

00:47:13,519 --> 00:47:17,599
we've started we started talking about

00:47:15,319 --> 00:47:18,890
this particular problem and then all of

00:47:17,599 --> 00:47:22,640
a sudden now we're talking about the

00:47:18,890 --> 00:47:24,920
database excuse me but that's not really

00:47:22,640 --> 00:47:27,259
what we want to talk about that's not

00:47:24,920 --> 00:47:30,829
the purpose of this meeting so you kind

00:47:27,259 --> 00:47:32,869
of you just have to you just have to be

00:47:30,829 --> 00:47:35,479
prepared to you know in that meeting or

00:47:32,869 --> 00:47:38,119
whatever just be able to say can we just

00:47:35,479 --> 00:47:42,469
step back to the actual problem and not

00:47:38,119 --> 00:47:45,440
try to focus on the technology does that

00:47:42,469 --> 00:47:48,319
answer your question it does

00:47:45,440 --> 00:47:52,400
I was looking I've done that I'm

00:47:48,319 --> 00:47:54,650
thinking of more of a community if I'm

00:47:52,400 --> 00:47:57,259
good to do that how do I help everyone

00:47:54,650 --> 00:47:59,180
else do that yeah and I not I think the

00:47:57,259 --> 00:48:01,130
only answer to that is really just to

00:47:59,180 --> 00:48:02,779
keep doing it you know just to be

00:48:01,130 --> 00:48:04,819
stubborn about it

00:48:02,779 --> 00:48:07,279
and if people start you know trying to

00:48:04,819 --> 00:48:09,890
delve too deep into too deep in

00:48:07,279 --> 00:48:12,079
implementation details just constantly

00:48:09,890 --> 00:48:14,299
hound them to come back to the right

00:48:12,079 --> 00:48:15,859
level and have the discussion at that

00:48:14,299 --> 00:48:17,690
level because if you get if you delve

00:48:15,859 --> 00:48:19,609
too deep into the implementation details

00:48:17,690 --> 00:48:21,440
oftentimes the conversation gets lost

00:48:19,609 --> 00:48:23,089
and sidetracked and you don't really

00:48:21,440 --> 00:48:27,969
accomplish what the goal was anyway so

00:48:23,089 --> 00:48:27,969
awesome things yes

00:48:32,310 --> 00:48:36,850
um so it was the talking about the

00:48:35,500 --> 00:48:39,670
dependency no you're talking with the

00:48:36,850 --> 00:48:42,340
actual pattern for dependency injection

00:48:39,670 --> 00:48:43,960
I think it was Adam wore ski I think had

00:48:42,340 --> 00:48:46,450
a blog on it I don't know if he was the

00:48:43,960 --> 00:48:48,670
first one who wrote about it I actually

00:48:46,450 --> 00:48:50,560
kind of developed that pattern on my own

00:48:48,670 --> 00:48:52,780
and then I went googling at one point

00:48:50,560 --> 00:48:55,690
and came across his blog and whoa wait

00:48:52,780 --> 00:48:57,190
this is kind of what I'm doing so but

00:48:55,690 --> 00:49:00,400
yeah I think I think it was Adam or ski

00:48:57,190 --> 00:49:04,150
who who has a blog post about that it's

00:49:00,400 --> 00:49:04,990
based on the cake pattern which I think

00:49:04,150 --> 00:49:07,960
might have been

00:49:04,990 --> 00:49:10,150
I know yonas poner had might have been

00:49:07,960 --> 00:49:13,840
the person who originally proposed that

00:49:10,150 --> 00:49:16,360
but the the traditional cake pattern is

00:49:13,840 --> 00:49:18,370
a little more a little more complex than

00:49:16,360 --> 00:49:19,840
the thin cake pattern which i find is a

00:49:18,370 --> 00:49:26,980
little more lightweight a little easier

00:49:19,840 --> 00:49:28,660
to understand so anybody else know all

00:49:26,980 --> 00:49:32,550
right then thank you everybody for

00:49:28,660 --> 00:49:32,550

YouTube URL: https://www.youtube.com/watch?v=MnNeDXg3Qao


