Title: Hands on Introduction to Distributed Systems Concepts with Akka Clustering - by David Russell
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Learning the concepts of Distributed Systems can be confusing: What is cluster membership? What is a partition, and what happens to the system when it occurs? How do we scale up a system safely? What happens when you bring down a node with a baseball bat?
 
Raspberry Pi's provide an excellent mechanism to answer these questions - they are visible, tactile, portable and cheap.  Akka makes building and running distributed systems a breeze. This presentation will demonstrate a physical model of a distributed system using Akka and Raspberry Piâ€™s, with a gamified explanation of High Availability, Cluster Management, Gossip protocols, and Leader Election.
Captions: 
	00:00:00,060 --> 00:00:08,250
everybody my name is Dave Russell uh I

00:00:06,210 --> 00:00:09,840
will be presenting today in the beginner

00:00:08,250 --> 00:00:11,400
track on a literally hands-on

00:00:09,840 --> 00:00:13,860
introduction to distributed systems

00:00:11,400 --> 00:00:16,020
concepts with akka clustering it's a

00:00:13,860 --> 00:00:18,840
long title so I have to look at it each

00:00:16,020 --> 00:00:21,180
time I want to present okay that's yeah

00:00:18,840 --> 00:00:26,730
I said it right I'm from Vancouver

00:00:21,180 --> 00:00:29,269
British Columbia a lot of us made it out

00:00:26,730 --> 00:00:31,170
so getting this across the border was

00:00:29,269 --> 00:00:32,940
probably the most hopefully the most

00:00:31,170 --> 00:00:39,210
exciting thing that happens today we'll

00:00:32,940 --> 00:00:40,890
see how that goes right so let's see so

00:00:39,210 --> 00:00:44,910
anything else I need to do before we get

00:00:40,890 --> 00:00:48,480
started I think we're pretty good all

00:00:44,910 --> 00:00:50,910
right so yeah make sure you engage and

00:00:48,480 --> 00:00:52,469
review this presentation so I can get

00:00:50,910 --> 00:00:54,360
get some good feedback on how I can

00:00:52,469 --> 00:00:56,460
improve the next time I bring six

00:00:54,360 --> 00:00:58,879
raspberry PI's across the border and

00:00:56,460 --> 00:01:05,189
attach them to overly large balloons

00:00:58,879 --> 00:01:06,780
little good right so ideally this this

00:01:05,189 --> 00:01:08,159
presentation is targeted to those of you

00:01:06,780 --> 00:01:10,200
who are just getting started with the

00:01:08,159 --> 00:01:11,670
concepts of distributed computing most

00:01:10,200 --> 00:01:13,290
of us have probably been working in a

00:01:11,670 --> 00:01:16,020
distributed environment for quite a

00:01:13,290 --> 00:01:18,360
while if you are working on any sort of

00:01:16,020 --> 00:01:20,869
web front-end application that has

00:01:18,360 --> 00:01:24,330
server on the backend

00:01:20,869 --> 00:01:27,030
alright so Who am I as I said I'm Dave

00:01:24,330 --> 00:01:28,350
Russell I'm on Twitter at David Greg

00:01:27,030 --> 00:01:30,659
Greg is my middle name

00:01:28,350 --> 00:01:33,049
my mom and dad gave me the most

00:01:30,659 --> 00:01:35,610
ubiquitous name in the world so Greg

00:01:33,049 --> 00:01:37,770
yeah I'm the developer at HootSuite in

00:01:35,610 --> 00:01:40,320
Vancouver I work on the Android

00:01:37,770 --> 00:01:44,310
application and I write back-end

00:01:40,320 --> 00:01:46,530
services in Scala and akka what a suit

00:01:44,310 --> 00:01:48,509
suite HootSuite is the most widely used

00:01:46,530 --> 00:01:51,420
platform for managing social media it's

00:01:48,509 --> 00:01:54,149
used by 10 million people we have a web

00:01:51,420 --> 00:01:56,310
dashboard an Android and an iOS native

00:01:54,149 --> 00:01:57,930
app what you can do you can send

00:01:56,310 --> 00:01:59,310
messages you can schedule messages you

00:01:57,930 --> 00:02:03,079
can view incoming messages and get

00:01:59,310 --> 00:02:06,200
analytics so with all of that we've

00:02:03,079 --> 00:02:09,330
grown a bunch over the last six years

00:02:06,200 --> 00:02:10,429
started up with this PHP application for

00:02:09,330 --> 00:02:12,230
speed

00:02:10,429 --> 00:02:15,470
as soon as we started scaling that out

00:02:12,230 --> 00:02:17,120
were like speed dropped and so we

00:02:15,470 --> 00:02:19,280
started cutting away at our this

00:02:17,120 --> 00:02:21,769
monolithic PHP application into micro

00:02:19,280 --> 00:02:24,800
services but then the trade-off was that

00:02:21,769 --> 00:02:26,540
we got more services and more complexity

00:02:24,800 --> 00:02:29,330
around those services so we got highly

00:02:26,540 --> 00:02:30,799
invested in cluster management and the

00:02:29,330 --> 00:02:34,340
ability to actually scale up and down

00:02:30,799 --> 00:02:36,049
these services so here's the agenda for

00:02:34,340 --> 00:02:39,080
today the first is the motivation why

00:02:36,049 --> 00:02:41,540
would you do this and why would you use

00:02:39,080 --> 00:02:42,860
a distributed system after that we'll

00:02:41,540 --> 00:02:45,380
we'll talk a little bit about some of

00:02:42,860 --> 00:02:47,239
the complexities that come in into play

00:02:45,380 --> 00:02:49,190
when you when you decide on a

00:02:47,239 --> 00:02:51,799
distributed system and start doing the

00:02:49,190 --> 00:02:53,450
management of it and then we'll also

00:02:51,799 --> 00:02:57,470
talk then we'll get right into a cluster

00:02:53,450 --> 00:02:58,970
and the actual the the ways that a

00:02:57,470 --> 00:03:01,849
cluster can solve those complex

00:02:58,970 --> 00:03:03,860
complexities for us and then demo so the

00:03:01,849 --> 00:03:06,170
original presentation was going to have

00:03:03,860 --> 00:03:07,700
all of these all of these sort of

00:03:06,170 --> 00:03:09,349
interspersed through the demo but it

00:03:07,700 --> 00:03:10,549
turns out one of the one of the

00:03:09,349 --> 00:03:11,870
complexities of providing with the

00:03:10,549 --> 00:03:13,849
distributed system is that the network

00:03:11,870 --> 00:03:26,060
is unreliable so this 20 year old router

00:03:13,849 --> 00:03:28,579
this Linksys wrt54g I've in so the first

00:03:26,060 --> 00:03:32,150
question is like why why do I have a

00:03:28,579 --> 00:03:34,730
bunch of asbury pies yeah so there's a

00:03:32,150 --> 00:03:37,359
bunch of us at the company who were

00:03:34,730 --> 00:03:39,829
getting into reading white papers about

00:03:37,359 --> 00:03:41,510
you know raft and cluster protocol

00:03:39,829 --> 00:03:43,790
gossip protocols and all these different

00:03:41,510 --> 00:03:45,560
topics and distributed systems but

00:03:43,790 --> 00:03:47,720
there's this disconnect this feeling

00:03:45,560 --> 00:03:50,660
like it's all really good it's all out

00:03:47,720 --> 00:03:53,260
there kind of nebulous so the suggestion

00:03:50,660 --> 00:03:55,849
was hate let's just deploy all of our

00:03:53,260 --> 00:03:58,700
some samples onto these raspberry PI's

00:03:55,849 --> 00:04:01,430
they are eligible should be fine so we

00:03:58,700 --> 00:04:03,169
did and it's actually pretty great it's

00:04:01,430 --> 00:04:04,669
an actual physical representation you

00:04:03,169 --> 00:04:07,069
can start pulling wires you can take

00:04:04,669 --> 00:04:09,410
bolt cutters and cut wires you can hit

00:04:07,069 --> 00:04:11,840
stuff with baseball bats I opted out of

00:04:09,410 --> 00:04:14,060
the baseball bat just because I wasn't

00:04:11,840 --> 00:04:15,920
sure if I'd let go with a bat

00:04:14,060 --> 00:04:20,209
something really done so jumped over

00:04:15,920 --> 00:04:21,980
that all right so why a distributed

00:04:20,209 --> 00:04:24,020
system yeah like I said most of us are

00:04:21,980 --> 00:04:28,190
probably using it already but from like

00:04:24,020 --> 00:04:30,139
a intentional perspective you most

00:04:28,190 --> 00:04:31,790
likely are going to be moving from some

00:04:30,139 --> 00:04:32,690
application that you wrote quite quickly

00:04:31,790 --> 00:04:34,760
into something a little bit more

00:04:32,690 --> 00:04:36,350
scalable the coordination of the

00:04:34,760 --> 00:04:39,820
services that come out of that become

00:04:36,350 --> 00:04:42,200
increasingly increasingly complex

00:04:39,820 --> 00:04:46,940
Bitcoin uses a distributed consensus

00:04:42,200 --> 00:04:50,060
system to validate my Bitcoin miner to

00:04:46,940 --> 00:04:51,140
make sure that you know it's valid and a

00:04:50,060 --> 00:04:53,300
specific use case

00:04:51,140 --> 00:04:54,680
HootSuite uses a cluster to manage

00:04:53,300 --> 00:04:57,230
connections to Twitter's stateful

00:04:54,680 --> 00:04:58,600
streaming API we can reliably process

00:04:57,230 --> 00:05:01,730
two million users data in real time

00:04:58,600 --> 00:05:04,040
using a cluster so it's it's a proven

00:05:01,730 --> 00:05:06,440
technology works quite well alright so

00:05:04,040 --> 00:05:08,300
hopefully I've convinced you that you're

00:05:06,440 --> 00:05:10,550
either already using one or eventually

00:05:08,300 --> 00:05:12,830
will need to use one at some point so

00:05:10,550 --> 00:05:18,050
let's talk about the complexities of the

00:05:12,830 --> 00:05:21,200
distributed system right okay the first

00:05:18,050 --> 00:05:23,000
one the eight fallacies of distributed

00:05:21,200 --> 00:05:26,000
system how many people have actually

00:05:23,000 --> 00:05:28,400
been have heard of this just at quick

00:05:26,000 --> 00:05:32,180
hands yes half that's enough that I can

00:05:28,400 --> 00:05:33,740
keep talking about alright so the

00:05:32,180 --> 00:05:34,850
network is reliable I'm just going to I

00:05:33,740 --> 00:05:35,690
will just go over them really briefly

00:05:34,850 --> 00:05:37,250
most of them pretty self-explanatory

00:05:35,690 --> 00:05:40,640
I've starred the ones that I think

00:05:37,250 --> 00:05:42,770
active cluster actively helps with I'm

00:05:40,640 --> 00:05:45,500
not so sure I mean it might help with

00:05:42,770 --> 00:05:47,479
that there is one administrator but I'm

00:05:45,500 --> 00:05:50,350
not certain that that's the case but

00:05:47,479 --> 00:05:52,729
from a concepts of distributed systems

00:05:50,350 --> 00:05:53,870
these are things that these are

00:05:52,729 --> 00:05:55,220
fallacies that you need to make sure

00:05:53,870 --> 00:05:58,400
you're aware of when you're building

00:05:55,220 --> 00:06:00,760
your system each of them will can bite

00:05:58,400 --> 00:06:03,289
you in a certain in a certain use case

00:06:00,760 --> 00:06:05,479
yeah so those are those of them I'm not

00:06:03,289 --> 00:06:06,740
going to go too deeply into them ideally

00:06:05,479 --> 00:06:08,110
if you're starting to get get into this

00:06:06,740 --> 00:06:11,510
you'll you'll read about them and

00:06:08,110 --> 00:06:13,220
architect your system accordingly now

00:06:11,510 --> 00:06:16,850
the far more interesting one to me when

00:06:13,220 --> 00:06:19,729
I found about it was cap theorem cap

00:06:16,850 --> 00:06:22,099
theorem stent the see is an acronym see

00:06:19,729 --> 00:06:24,650
AP consistency availability and

00:06:22,099 --> 00:06:26,390
partition tolerance consistency is the

00:06:24,650 --> 00:06:26,960
idea that all nodes see the same data at

00:06:26,390 --> 00:06:28,310
the same time

00:06:26,960 --> 00:06:31,069
so you put a request on to the cluster

00:06:28,310 --> 00:06:33,020
you should get our consistent result no

00:06:31,069 --> 00:06:35,240
matter which node is actually servicing

00:06:33,020 --> 00:06:37,910
that request availability is the idea

00:06:35,240 --> 00:06:40,550
that every time I you put a request in

00:06:37,910 --> 00:06:42,770
to the cluster that you will get a

00:06:40,550 --> 00:06:45,110
timely response about whether the

00:06:42,770 --> 00:06:48,500
request succeeded or failed and the last

00:06:45,110 --> 00:06:50,690
one is partition tolerance a network

00:06:48,500 --> 00:06:52,009
partition is when you know you have a

00:06:50,690 --> 00:06:53,660
bunch of nodes in your cluster and

00:06:52,009 --> 00:06:54,740
there's like three of these here that

00:06:53,660 --> 00:06:56,930
can talk to these three and these two

00:06:54,740 --> 00:06:59,360
you can't talk to to these two etc and

00:06:56,930 --> 00:07:01,970
it becomes this idea of a split brain

00:06:59,360 --> 00:07:03,740
where you have two networks that are

00:07:01,970 --> 00:07:06,169
basically doing the exact same thing and

00:07:03,740 --> 00:07:09,349
when you're working in clustering that's

00:07:06,169 --> 00:07:10,669
almost never what you want so in real

00:07:09,349 --> 00:07:12,020
life it turns out that partition

00:07:10,669 --> 00:07:15,710
tolerance is not something that we have

00:07:12,020 --> 00:07:18,409
the option on we have to deal with it so

00:07:15,710 --> 00:07:19,970
the cap theorem explicitly says is

00:07:18,409 --> 00:07:21,680
impossible for a distributed computer

00:07:19,970 --> 00:07:24,169
system to simultaneously provide all

00:07:21,680 --> 00:07:25,789
three of the following guarantees and

00:07:24,169 --> 00:07:27,530
like I said in real life it turns out

00:07:25,789 --> 00:07:29,780
you definitely have to take care of

00:07:27,530 --> 00:07:31,940
partition tolerance so in the end you

00:07:29,780 --> 00:07:34,759
really have to pick P and you can pick

00:07:31,940 --> 00:07:36,259
consistency or availability we're

00:07:34,759 --> 00:07:37,970
something to say that your entire system

00:07:36,259 --> 00:07:39,590
has to always pick one or the other this

00:07:37,970 --> 00:07:41,539
is going to be a guiding principle that

00:07:39,590 --> 00:07:44,979
that drives the design of your system

00:07:41,539 --> 00:07:48,560
coupled with the nature of your data so

00:07:44,979 --> 00:07:51,320
a quick a quick example of how to see

00:07:48,560 --> 00:07:53,419
that this is an actual an actual thing

00:07:51,320 --> 00:07:56,870
imagine you have some users on the East

00:07:53,419 --> 00:07:58,820
Coast and some you some users on the

00:07:56,870 --> 00:08:01,250
west coast and some users on East Coast

00:07:58,820 --> 00:08:02,750
over here and the user on the west coast

00:08:01,250 --> 00:08:04,070
these are on the west coast puts in a

00:08:02,750 --> 00:08:05,810
right to into your system and says hey I

00:08:04,070 --> 00:08:07,580
want to write the state into the system

00:08:05,810 --> 00:08:09,770
and so he writes it into this node but

00:08:07,580 --> 00:08:12,650
before the data can get replicated over

00:08:09,770 --> 00:08:14,030
to the east coast there's a partition so

00:08:12,650 --> 00:08:15,590
now you're left with this this thing

00:08:14,030 --> 00:08:17,570
okay so you've done partition tolerance

00:08:15,590 --> 00:08:20,000
which means the system is still working

00:08:17,570 --> 00:08:22,550
that's that's like great but what

00:08:20,000 --> 00:08:24,940
happens to the guy on the East Coast I

00:08:22,550 --> 00:08:27,469
still own my clothes correctly anyway

00:08:24,940 --> 00:08:29,270
the guy in the East Coast goes and

00:08:27,469 --> 00:08:30,139
requests that same state that the guy

00:08:29,270 --> 00:08:34,039
over there

00:08:30,139 --> 00:08:35,479
just put in and so he gets in the system

00:08:34,039 --> 00:08:37,459
doesn't have that information so your

00:08:35,479 --> 00:08:40,390
options are either to wait for the

00:08:37,459 --> 00:08:41,980
network to be healed and then you can

00:08:40,390 --> 00:08:45,070
service this request from the guy over

00:08:41,980 --> 00:08:46,630
here or you just give him the stale data

00:08:45,070 --> 00:08:48,100
whatever was was written over here at

00:08:46,630 --> 00:08:51,490
that time and the user goes away with

00:08:48,100 --> 00:08:53,050
possibly incomplete information all

00:08:51,490 --> 00:08:57,670
right I think that covers cap there

00:08:53,050 --> 00:09:00,040
pretty well all right okay so yeah that

00:08:57,670 --> 00:09:02,140
was the first two sections of the

00:09:00,040 --> 00:09:03,970
presentation the last one is basically

00:09:02,140 --> 00:09:04,960
like all of the all of the things that

00:09:03,970 --> 00:09:06,760
we're going to talk about with akka

00:09:04,960 --> 00:09:09,160
cluster so this is the longest part of

00:09:06,760 --> 00:09:12,160
the section okay so for those of you who

00:09:09,160 --> 00:09:14,950
are just just beginning akka is a

00:09:12,160 --> 00:09:17,410
toolkit that wraps an actor/model which

00:09:14,950 --> 00:09:18,880
basically encapsulates some logical unit

00:09:17,410 --> 00:09:21,400
that then can pass messages to another

00:09:18,880 --> 00:09:23,290
actor over here what it provides you is

00:09:21,400 --> 00:09:25,420
high level concurrency and it lends

00:09:23,290 --> 00:09:31,510
itself really well to distributed

00:09:25,420 --> 00:09:33,430
systems so akka remoting is a way to get

00:09:31,510 --> 00:09:34,750
an actor onto a different system so that

00:09:33,430 --> 00:09:37,600
you don't actually have to care where

00:09:34,750 --> 00:09:40,330
these actor systems are living actor

00:09:37,600 --> 00:09:42,100
cluster akka cluster sorry is a

00:09:40,330 --> 00:09:44,140
membership service built on aqua

00:09:42,100 --> 00:09:45,910
remoting and each actor assisting that

00:09:44,140 --> 00:09:47,740
we thought of as a node in the cluster

00:09:45,910 --> 00:09:49,300
nodes don't need to live in the same

00:09:47,740 --> 00:09:53,050
area at all akka cluster is going to

00:09:49,300 --> 00:09:55,480
help you manage all that alright so uh

00:09:53,050 --> 00:09:57,940
yeah how do we pass information through

00:09:55,480 --> 00:10:01,630
the cluster so we've got all these nodes

00:09:57,940 --> 00:10:06,760
there to cluster how do you say move you

00:10:01,630 --> 00:10:08,410
know one one bit of data to the rest of

00:10:06,760 --> 00:10:11,740
the node the node cluster so the

00:10:08,410 --> 00:10:15,520
alternatives before gossip protocols

00:10:11,740 --> 00:10:18,220
were using Paxos which was a strict

00:10:15,520 --> 00:10:20,020
consistency model or you could use a

00:10:18,220 --> 00:10:21,700
centralized database to maintain your

00:10:20,020 --> 00:10:23,260
state the problem with both of those is

00:10:21,700 --> 00:10:24,790
that they don't scale well database goes

00:10:23,260 --> 00:10:25,930
down or you're spending a lot of

00:10:24,790 --> 00:10:27,610
infrastructure keeping that database

00:10:25,930 --> 00:10:28,620
alive not you're not your cluster they

00:10:27,610 --> 00:10:31,600
actually care about

00:10:28,620 --> 00:10:34,480
so yeah gossip protocols come in pretty

00:10:31,600 --> 00:10:37,060
handy what it gives you is a very

00:10:34,480 --> 00:10:39,580
resilient way of maintaining the the

00:10:37,060 --> 00:10:41,200
cluster state so yeah you let each node

00:10:39,580 --> 00:10:43,080
hold the state of the cluster and tell

00:10:41,200 --> 00:10:45,730
your neighbors about it real briefly

00:10:43,080 --> 00:10:47,530
let's have a look let's say you've got

00:10:45,730 --> 00:10:50,560
this cluster there the gray nodes and

00:10:47,530 --> 00:10:51,570
then some external thing says hey let's

00:10:50,560 --> 00:10:55,530
write seven into the in

00:10:51,570 --> 00:10:57,660
cluster so your first node receives the

00:10:55,530 --> 00:10:59,040
request it needs to tell the rest of the

00:10:57,660 --> 00:11:01,230
cluster so it randomly just picks two

00:10:59,040 --> 00:11:03,270
nodes and tells them about about the

00:11:01,230 --> 00:11:04,830
change those two nodes tell some

00:11:03,270 --> 00:11:06,780
neighbors and those neighbors tell

00:11:04,830 --> 00:11:11,030
neighbors to eventually all the nodes of

00:11:06,780 --> 00:11:12,870
scene have seen the change in a cluster

00:11:11,030 --> 00:11:15,180
and then you have something called

00:11:12,870 --> 00:11:16,500
convergence basically when the last node

00:11:15,180 --> 00:11:18,720
has seen that all of the other nodes

00:11:16,500 --> 00:11:21,330
also have the same data you can say that

00:11:18,720 --> 00:11:24,650
the cluster is converged akha cluster

00:11:21,330 --> 00:11:28,230
uses this state to make decisions for

00:11:24,650 --> 00:11:31,470
for managing the cluster and we'll get

00:11:28,230 --> 00:11:33,390
into that later on all right all right

00:11:31,470 --> 00:11:34,890
so that sort of helps us with like

00:11:33,390 --> 00:11:36,360
intentional changes to the cluster like

00:11:34,890 --> 00:11:38,100
when a node comes in we can gossip it

00:11:36,360 --> 00:11:39,480
when we want to bring down a node for

00:11:38,100 --> 00:11:41,700
maintenance we can get it out and we can

00:11:39,480 --> 00:11:43,500
gossip that but this is sort of this is

00:11:41,700 --> 00:11:45,540
sort of where we're rubber hits the road

00:11:43,500 --> 00:11:46,380
how do we detect when a node fails when

00:11:45,540 --> 00:11:48,990
it's something that we didn't actually

00:11:46,380 --> 00:11:50,460
try to do without a cluster you're

00:11:48,990 --> 00:11:52,650
looking at a third party up a third

00:11:50,460 --> 00:11:55,200
party tool that would probably need to

00:11:52,650 --> 00:11:59,240
monitor each node in the cluster or have

00:11:55,200 --> 00:12:01,380
some sort of like outside sort of idea

00:11:59,240 --> 00:12:03,510
sense it would be an option but that

00:12:01,380 --> 00:12:06,360
could be also cumbersome to scale so

00:12:03,510 --> 00:12:09,900
akka provides a failure detector so each

00:12:06,360 --> 00:12:12,780
node will get to that yes I like each

00:12:09,900 --> 00:12:14,880
node in the cluster has it runs a

00:12:12,780 --> 00:12:16,650
failure detector and what it does is it

00:12:14,880 --> 00:12:19,140
will be monitoring its neighbors and

00:12:16,650 --> 00:12:20,850
keeping an eye on them it descends heart

00:12:19,140 --> 00:12:22,920
B requests just to say hey are you up

00:12:20,850 --> 00:12:24,360
and then you get a response back so yeah

00:12:22,920 --> 00:12:27,330
so you've got a bunch of nodes asking

00:12:24,360 --> 00:12:29,850
one node if they're up if in I could

00:12:27,330 --> 00:12:31,200
cluster if any of these if any one of

00:12:29,850 --> 00:12:33,300
the knows doesn't receive a response

00:12:31,200 --> 00:12:34,950
from the node that it's watching it will

00:12:33,300 --> 00:12:37,770
alert the rest of the cluster that it is

00:12:34,950 --> 00:12:40,950
unreachable the rest of the nodes won't

00:12:37,770 --> 00:12:43,080
actually actively actively actively be

00:12:40,950 --> 00:12:45,240
used but they'll continue to they'll

00:12:43,080 --> 00:12:46,380
continue to send heartbeats to it so

00:12:45,240 --> 00:12:49,290
it'll happen easily get it to two states

00:12:46,380 --> 00:12:53,130
either that node was you know thrashing

00:12:49,290 --> 00:12:54,780
or you know maybe a JVM garbage halting

00:12:53,130 --> 00:12:57,120
or something like that or just a network

00:12:54,780 --> 00:12:59,850
partition and you'll get either one of

00:12:57,120 --> 00:13:01,710
two things either it'll come back up and

00:12:59,850 --> 00:13:03,780
your node will be will be brought back

00:13:01,710 --> 00:13:04,640
into the cluster or eventually after a

00:13:03,780 --> 00:13:06,410
certain amount of time

00:13:04,640 --> 00:13:08,149
will will actually quarantine that node

00:13:06,410 --> 00:13:09,290
and no more requests to go to it you'll

00:13:08,149 --> 00:13:10,700
actually have to bring that note all the

00:13:09,290 --> 00:13:14,839
way down and then add it back into the

00:13:10,700 --> 00:13:16,820
cluster later on alright so that's great

00:13:14,839 --> 00:13:18,800
we've got a system that can detect when

00:13:16,820 --> 00:13:21,620
there's a failure and we've got a system

00:13:18,800 --> 00:13:23,029
that can bring in and bring out a bunch

00:13:21,620 --> 00:13:24,589
of nodes but who's making the decisions

00:13:23,029 --> 00:13:27,170
about like when the node can come in

00:13:24,589 --> 00:13:30,560
what to do with a failed node so the

00:13:27,170 --> 00:13:31,940
idea this is the idea of a leader but

00:13:30,560 --> 00:13:32,899
before we get that we're going to hit

00:13:31,940 --> 00:13:35,029
that we'll talk a little bit about

00:13:32,899 --> 00:13:36,620
cluster Singleton's so this is this is a

00:13:35,029 --> 00:13:39,890
feature in akka for when you need

00:13:36,620 --> 00:13:43,160
exactly one of something yeah so the

00:13:39,890 --> 00:13:46,220
idea is if you've got one of your nodes

00:13:43,160 --> 00:13:49,490
running this role of say consuming

00:13:46,220 --> 00:13:50,930
messages off of a gym like a queue and

00:13:49,490 --> 00:13:53,750
it goes down you really need that that

00:13:50,930 --> 00:13:56,029
that functionality still so it goes down

00:13:53,750 --> 00:13:58,820
and another one will come up let's have

00:13:56,029 --> 00:14:01,670
a little really quick look at that this

00:13:58,820 --> 00:14:04,630
is pretty basic so node a is acting as

00:14:01,670 --> 00:14:09,199
the singleton node a becomes unreachable

00:14:04,630 --> 00:14:11,209
no D becomes the singleton by virtue of

00:14:09,199 --> 00:14:12,829
being the second oldest member in the

00:14:11,209 --> 00:14:15,769
cluster single fins are always assigned

00:14:12,829 --> 00:14:16,940
to the oldest member all right so now we

00:14:15,769 --> 00:14:21,220
can go back to who's making a decision

00:14:16,940 --> 00:14:23,089
so let's talk about a cluster leader so

00:14:21,220 --> 00:14:27,019
cluster leader is essentially a

00:14:23,089 --> 00:14:28,970
singleton basically what happens is it

00:14:27,019 --> 00:14:32,899
manages this state this is the state of

00:14:28,970 --> 00:14:35,540
of the Aqua cluster so a node comes in

00:14:32,899 --> 00:14:38,720
and sets itself to be a is in this

00:14:35,540 --> 00:14:40,970
joining state and at convergence the

00:14:38,720 --> 00:14:43,850
leader can move a node from joining to

00:14:40,970 --> 00:14:45,829
up the node can then tell the cluster

00:14:43,850 --> 00:14:47,630
that is leaving and the node will event

00:14:45,829 --> 00:14:49,490
are the leader will then move the node

00:14:47,630 --> 00:14:52,490
from leaving to exiting exiting to

00:14:49,490 --> 00:14:54,470
remove it'll just be gone at the same

00:14:52,490 --> 00:14:58,040
time if node becomes unreachable through

00:14:54,470 --> 00:15:03,500
the failure detector the the leader will

00:14:58,040 --> 00:15:05,480
move this into a downed state in sort of

00:15:03,500 --> 00:15:09,410
in a configurable way we'll talk about

00:15:05,480 --> 00:15:10,850
that as well all right so let's let's

00:15:09,410 --> 00:15:14,420
just run through a quick quick example

00:15:10,850 --> 00:15:16,670
so node f wants to join the node the

00:15:14,420 --> 00:15:18,040
cluster so we have this idea of a seed

00:15:16,670 --> 00:15:21,009
node you need to have one

00:15:18,040 --> 00:15:22,899
tact point one way to get a new note

00:15:21,009 --> 00:15:26,110
into the system it's not it's not magic

00:15:22,899 --> 00:15:27,550
so f currently is your seed node or

00:15:26,110 --> 00:15:31,870
sorry e as your seed note and we're

00:15:27,550 --> 00:15:33,509
trying to get F in so e e then gossips

00:15:31,870 --> 00:15:37,889
out to the rest of the cluster

00:15:33,509 --> 00:15:40,990
eventually we have convergence and the

00:15:37,889 --> 00:15:41,980
note F is moved into the Upstate now at

00:15:40,990 --> 00:15:43,959
this point at the when there's

00:15:41,980 --> 00:15:46,600
convergence what happens is you've got

00:15:43,959 --> 00:15:49,540
either could be a new a new F is now in

00:15:46,600 --> 00:15:51,100
so the leader at this point as far as

00:15:49,540 --> 00:15:54,130
leader election goes in the cluster it

00:15:51,100 --> 00:15:55,870
it is just whatever node is available to

00:15:54,130 --> 00:15:58,060
be the leader at that time and the

00:15:55,870 --> 00:16:00,459
implementation is actually the first

00:15:58,060 --> 00:16:04,209
node in the sorted list of all of the

00:16:00,459 --> 00:16:07,060
nodes in the cluster so the leader can

00:16:04,209 --> 00:16:08,649
change and there is AG no actual formal

00:16:07,060 --> 00:16:10,079
election process like you'd see in a

00:16:08,649 --> 00:16:14,259
raft protocol or something like that

00:16:10,079 --> 00:16:16,060
alright alright let's talk about

00:16:14,259 --> 00:16:19,600
handling partitions this is sort of the

00:16:16,060 --> 00:16:21,250
big deal if you're in the last session

00:16:19,600 --> 00:16:25,360
there was some chatter briefly about

00:16:21,250 --> 00:16:26,440
cluster a a split brain resolver we'll

00:16:25,360 --> 00:16:28,000
talk about that in just a second a

00:16:26,440 --> 00:16:30,459
partition like I said is basically when

00:16:28,000 --> 00:16:32,079
part of the system can't see our part of

00:16:30,459 --> 00:16:34,000
the cluster can't see the other part so

00:16:32,079 --> 00:16:36,040
the four on the left there are the right

00:16:34,000 --> 00:16:37,839
are going to not be able to see the the

00:16:36,040 --> 00:16:39,040
tool on the left and on the left

00:16:37,839 --> 00:16:42,550
conversely cannot see the what's on the

00:16:39,040 --> 00:16:43,990
right so there's kind of kind of few

00:16:42,550 --> 00:16:46,060
problems with this one is that there's

00:16:43,990 --> 00:16:47,829
no real way for the system to determine

00:16:46,060 --> 00:16:49,839
whether those four nodes on the right

00:16:47,829 --> 00:16:51,130
have crashed or if it's actually just

00:16:49,839 --> 00:16:52,899
like a network partition that eventually

00:16:51,130 --> 00:16:55,510
will come back up there's there's no way

00:16:52,899 --> 00:16:57,069
to solve that problem so what you can do

00:16:55,510 --> 00:16:58,990
is you basically say how long am I

00:16:57,069 --> 00:17:00,910
willing to wait for those to come back

00:16:58,990 --> 00:17:02,889
before I do something because we can't

00:17:00,910 --> 00:17:05,140
just leave them there well maybe you

00:17:02,889 --> 00:17:07,150
could but we'll talk about that so the

00:17:05,140 --> 00:17:09,970
first one that comes out of the box is

00:17:07,150 --> 00:17:12,159
an auto down so the leader can just say

00:17:09,970 --> 00:17:13,929
after its configured amount of time just

00:17:12,159 --> 00:17:16,630
you know throw them out those for not

00:17:13,929 --> 00:17:19,179
important that works pretty pretty

00:17:16,630 --> 00:17:21,189
pretty well to get you started but the

00:17:19,179 --> 00:17:23,829
problem with that is that what it leads

00:17:21,189 --> 00:17:25,480
to is those four still might be able to

00:17:23,829 --> 00:17:27,640
talk to each other and so you have this

00:17:25,480 --> 00:17:30,460
split brain where those four are now

00:17:27,640 --> 00:17:31,550
acting independently of the other two if

00:17:30,460 --> 00:17:32,960
another partition

00:17:31,550 --> 00:17:34,220
happens you'll see the same thing and

00:17:32,960 --> 00:17:36,680
you can have these little islands of

00:17:34,220 --> 00:17:39,800
clusters which is no good so that's not

00:17:36,680 --> 00:17:41,540
a great that's not a great cluster

00:17:39,800 --> 00:17:43,160
management strategy the second one is

00:17:41,540 --> 00:17:44,900
human intervention using some sort of

00:17:43,160 --> 00:17:46,520
monitoring tool you can say oh my

00:17:44,900 --> 00:17:48,650
network is having a hard time I'll get

00:17:46,520 --> 00:17:50,960
in there and fix it myself that's costly

00:17:48,650 --> 00:17:52,280
it doesn't scale well the third option

00:17:50,960 --> 00:17:53,900
is just leave the unreachable nodes

00:17:52,280 --> 00:17:57,530
alone maybe so when they're in an

00:17:53,900 --> 00:17:58,970
unreachable state no you know no no new

00:17:57,530 --> 00:17:59,360
requests will be sent to them they don't

00:17:58,970 --> 00:18:02,660
do any work

00:17:59,360 --> 00:18:04,970
they'll just be hanging out but the

00:18:02,660 --> 00:18:08,000
problem with that is that in a cluster

00:18:04,970 --> 00:18:09,980
when you're in a nun Revere nodes is in

00:18:08,000 --> 00:18:11,900
an unreachable State the leader can't

00:18:09,980 --> 00:18:15,080
make decisions it can't bring new actors

00:18:11,900 --> 00:18:18,860
in it can't down actors out it can't it

00:18:15,080 --> 00:18:21,530
can't do its job so that's also not

00:18:18,860 --> 00:18:24,050
ideal Singleton's can't move around yeah

00:18:21,530 --> 00:18:26,330
it's not great there is a feature called

00:18:24,050 --> 00:18:27,950
actors weekly up that lets you just sort

00:18:26,330 --> 00:18:31,730
of get them in but it's not quite it's

00:18:27,950 --> 00:18:33,710
not quite enough all right so how do we

00:18:31,730 --> 00:18:35,150
deal with partitions yeah so there's

00:18:33,710 --> 00:18:37,430
those two there's those two states one

00:18:35,150 --> 00:18:39,890
is let's wait for some amount of time

00:18:37,430 --> 00:18:41,360
and then the other is let's do something

00:18:39,890 --> 00:18:43,250
about this because we're kind of stuck

00:18:41,360 --> 00:18:44,510
so the first thing I want to talk to you

00:18:43,250 --> 00:18:47,390
about is distributed data it's an

00:18:44,510 --> 00:18:48,980
experimental feature in akka 2.4 played

00:18:47,390 --> 00:18:52,250
on it a little bit we should be able to

00:18:48,980 --> 00:18:54,290
see it in the demo today basically what

00:18:52,250 --> 00:18:55,220
it is is a merge friendly these merge

00:18:54,290 --> 00:18:59,030
friendly data types

00:18:55,220 --> 00:19:04,090
they're called CR DTS

00:18:59,030 --> 00:19:06,040
they're like commutative commutative

00:19:04,090 --> 00:19:08,360
conflict-free

00:19:06,040 --> 00:19:10,400
that is replicated out replicated us

00:19:08,360 --> 00:19:12,050
their community of replicated data types

00:19:10,400 --> 00:19:13,520
they're also called conflict-free

00:19:12,050 --> 00:19:13,880
replicated data types they're also

00:19:13,520 --> 00:19:16,550
called

00:19:13,880 --> 00:19:18,440
a conflict for this there's a bunch of

00:19:16,550 --> 00:19:19,940
the C's there's a bunch of seas but

00:19:18,440 --> 00:19:21,830
replicated data type is sort of the

00:19:19,940 --> 00:19:24,170
important part at the end what it means

00:19:21,830 --> 00:19:26,330
is when your network heals these data

00:19:24,170 --> 00:19:28,130
types we'll use some deterministic way

00:19:26,330 --> 00:19:29,960
to merge that data back in so you don't

00:19:28,130 --> 00:19:32,120
actually have to go in and and manually

00:19:29,960 --> 00:19:33,980
merge your data all right so that's that

00:19:32,120 --> 00:19:35,720
we'll get it to that later as well and

00:19:33,980 --> 00:19:37,910
split-brain resolver i think this is

00:19:35,720 --> 00:19:40,730
like this is like the big deal for a

00:19:37,910 --> 00:19:44,120
cluster what it gives you is strategies

00:19:40,730 --> 00:19:45,400
to bring down some partition so it acts

00:19:44,120 --> 00:19:48,310
on the last known state

00:19:45,400 --> 00:19:50,620
of your cluster so some of the modes in

00:19:48,310 --> 00:19:53,530
court include quorum sighs so you say

00:19:50,620 --> 00:19:55,270
okay well we need this many nodes to

00:19:53,530 --> 00:19:56,860
keep opera keep up so we'll just down

00:19:55,270 --> 00:19:58,690
the notes that aren't inside the quorum

00:19:56,860 --> 00:20:00,640
sighs there's a strategy called keep

00:19:58,690 --> 00:20:02,080
oldest so wherever the oldest note is

00:20:00,640 --> 00:20:05,710
we'll just down all the other notes on

00:20:02,080 --> 00:20:07,330
the other partition keep majority which

00:20:05,710 --> 00:20:09,400
is just like okay if there's five over

00:20:07,330 --> 00:20:10,630
here and the last notes date of these

00:20:09,400 --> 00:20:12,910
two is that there's five over there

00:20:10,630 --> 00:20:14,080
we'll down ourselves and then there's a

00:20:12,910 --> 00:20:15,610
keep referee was just like okay let's

00:20:14,080 --> 00:20:17,380
just have this one whatever wherever

00:20:15,610 --> 00:20:18,580
whatever nodes around this will keep

00:20:17,380 --> 00:20:21,220
this one a nut and that's stuff will

00:20:18,580 --> 00:20:23,230
down some of the danger of had is that

00:20:21,220 --> 00:20:25,150
like if your referee is the only thing

00:20:23,230 --> 00:20:26,410
in the partition and the rest of your

00:20:25,150 --> 00:20:28,480
cluster goes down you have all the load

00:20:26,410 --> 00:20:31,090
on your referee so things to think about

00:20:28,480 --> 00:20:32,920
so a little bit of discrepancy right now

00:20:31,090 --> 00:20:34,750
if you if you do for some reason want to

00:20:32,920 --> 00:20:37,810
use an experimental feature in your

00:20:34,750 --> 00:20:39,790
production akka two point four great you

00:20:37,810 --> 00:20:42,640
can use distributed data split brain

00:20:39,790 --> 00:20:45,520
resolvers on two point three and is also

00:20:42,640 --> 00:20:48,880
part of the you'll need a light-bending

00:20:45,520 --> 00:20:54,060
subscription to get that going all right

00:20:48,880 --> 00:20:56,530
let's do it Emma all right so um yeah

00:20:54,060 --> 00:21:00,730
let's keep going so this is this was the

00:20:56,530 --> 00:21:02,500
original plan we have we have a Wi-Fi we

00:21:00,730 --> 00:21:05,440
have a Wi-Fi router here as I said it's

00:21:02,500 --> 00:21:07,810
like ten years old so it's providing

00:21:05,440 --> 00:21:09,670
maybe six view Wi-Fi access which

00:21:07,810 --> 00:21:11,800
doesn't scale well and the network is

00:21:09,670 --> 00:21:13,780
not very reliable so I'm going to

00:21:11,800 --> 00:21:16,690
shortcut that by being by being the

00:21:13,780 --> 00:21:20,250
representative of the room on my on my

00:21:16,690 --> 00:21:23,290
laptop is a web server running akka HTTP

00:21:20,250 --> 00:21:25,290
which will be servicing requests those

00:21:23,290 --> 00:21:28,930
requests will then be routed using a

00:21:25,290 --> 00:21:32,200
akka akka remoting router in a round

00:21:28,930 --> 00:21:35,860
robin fashion on to the cluster each

00:21:32,200 --> 00:21:40,290
node will service that request and we'll

00:21:35,860 --> 00:21:40,290
see some we'll see some stuff all right

00:21:40,410 --> 00:21:47,450
whoo too far spoiler okay

00:21:44,680 --> 00:21:51,320
all right so what I'm going to try to do

00:21:47,450 --> 00:21:53,540
here is I'm going to bring my terminal

00:21:51,320 --> 00:22:05,140
over I do that now I got to bring down

00:21:53,540 --> 00:22:05,140
that stop presenting there it is yeah

00:22:06,970 --> 00:22:16,040
wrong screen there we go let's bring

00:22:10,850 --> 00:22:18,290
that over cool all right so down here is

00:22:16,040 --> 00:22:21,980
our scene don't move too many there

00:22:18,290 --> 00:22:22,820
almost you know there we go so all we're

00:22:21,980 --> 00:22:26,150
going to do here I'm going to run a

00:22:22,820 --> 00:22:27,410
script that should should bring up the

00:22:26,150 --> 00:22:29,890
seed node so it takes a while for the

00:22:27,410 --> 00:22:32,930
JVM on on a Raspberry Pi to load up

00:22:29,890 --> 00:22:35,120
that's just only raspberry pi is that's

00:22:32,930 --> 00:22:40,060
the only time yeah so what we'll see

00:22:35,120 --> 00:22:42,440
here is that the member is up and

00:22:40,060 --> 00:22:47,030
there's this there's this internal scene

00:22:42,440 --> 00:22:50,210
changed a vent what it mean it uses that

00:22:47,030 --> 00:22:51,500
to maintain convergence so you'll see

00:22:50,210 --> 00:22:54,020
that that flashing through the logs a

00:22:51,500 --> 00:22:59,380
little bit but we'll keep going so if I

00:22:54,020 --> 00:22:59,380
actually bring up my web server

00:23:08,890 --> 00:23:13,390
just a second just bringing spt huh all

00:23:12,799 --> 00:23:16,520
right

00:23:13,390 --> 00:23:19,960
you don't bring that over as well yeah I

00:23:16,520 --> 00:23:23,809
can all right so we're just going to run

00:23:19,960 --> 00:23:28,150
we need the note that I am so when I

00:23:23,809 --> 00:23:28,150
teamed up so I've been going okay Nyack

00:23:28,480 --> 00:23:34,429
- and then we need to provide the the

00:23:32,870 --> 00:23:36,799
note that it's actually going to be

00:23:34,429 --> 00:23:40,850
running on which is PI Jesus

00:23:36,799 --> 00:23:46,669
ooh nice save guys good work team

00:23:40,850 --> 00:23:47,000
okay now to locals that's not going to

00:23:46,669 --> 00:23:50,169
work

00:23:47,000 --> 00:23:52,490
guys you didn't say for two L's really

00:23:50,169 --> 00:23:59,950
too fast you write that slow that write

00:23:52,490 --> 00:23:59,950
down code Ruby

00:24:01,300 --> 00:24:13,710
I don't think I need the yeah no that

00:24:08,050 --> 00:24:13,710
should work there

00:24:15,450 --> 00:24:31,170
what's open oh no that's super

00:24:26,370 --> 00:24:33,960
interesting compilation failed value not

00:24:31,170 --> 00:24:37,170
found current node mode oh wow

00:24:33,960 --> 00:24:40,530
well that's a bit of a downer don't see

00:24:37,170 --> 00:24:42,450
if we can fix it real quick all right so

00:24:40,530 --> 00:24:43,590
let's get into the code which is

00:24:42,450 --> 00:24:48,840
actually what we're going to go anyway

00:24:43,590 --> 00:24:50,460
so oh that's totally why okay I made

00:24:48,840 --> 00:24:52,680
some I made some last-minute Justin's

00:24:50,460 --> 00:24:54,770
adjustments who thinks that's a good

00:24:52,680 --> 00:24:54,770
idea

00:24:55,340 --> 00:24:59,100
all right so what I was going to do is

00:24:57,540 --> 00:25:00,390
show you a bunch of stuff about like

00:24:59,100 --> 00:25:02,400
okay let's do this first and then we'll

00:25:00,390 --> 00:25:04,770
run through the code actually to get a

00:25:02,400 --> 00:25:05,910
cluster sorry I'm just dangling the demo

00:25:04,770 --> 00:25:08,460
in front of you guys you can't leave

00:25:05,910 --> 00:25:10,200
till you till you go throw this okay so

00:25:08,460 --> 00:25:12,990
I made some last-minute adjustments as

00:25:10,200 --> 00:25:14,160
you can see of my get history yeah

00:25:12,990 --> 00:25:16,950
getting getting this all set up was

00:25:14,160 --> 00:25:19,500
actually remarkably easy so what you do

00:25:16,950 --> 00:25:21,480
in your application configuration you

00:25:19,500 --> 00:25:24,300
provide an actor provider at the top

00:25:21,480 --> 00:25:27,120
online food looks like three cluster

00:25:24,300 --> 00:25:31,530
actor ref provider there's some required

00:25:27,120 --> 00:25:33,570
information from akka remoting you can

00:25:31,530 --> 00:25:36,720
provide the router here as well as where

00:25:33,570 --> 00:25:38,160
you'll route to and then you're kind of

00:25:36,720 --> 00:25:40,350
off to the races from from that

00:25:38,160 --> 00:25:43,410
perspective there's a bunch of some

00:25:40,350 --> 00:25:45,330
other stuff that we'll do there but the

00:25:43,410 --> 00:25:47,810
API app will need to revert all of my

00:25:45,330 --> 00:25:50,810
changes so this will actually work so

00:25:47,810 --> 00:25:50,810
just

00:25:52,240 --> 00:26:00,789
eventually just report those slowly but

00:25:59,379 --> 00:26:03,309
surely this is what you guys came to see

00:26:00,789 --> 00:26:12,330
right me reverting my code desperately

00:26:03,309 --> 00:26:12,330
on stage perfect perfect all right

00:26:15,539 --> 00:26:18,889
let's see if it compiles now

00:26:29,050 --> 00:26:38,250
better

00:26:31,410 --> 00:26:40,740
ah so much worse oh boy

00:26:38,250 --> 00:26:44,120
let's have a look number format

00:26:40,740 --> 00:26:44,120
exception for info okay

00:26:46,190 --> 00:26:54,480
dee doo dee dee dee this is like exactly

00:26:51,900 --> 00:26:56,070
what I wanted when I cheat almost except

00:26:54,480 --> 00:27:01,890
dad tutti tutti that's true

00:26:56,070 --> 00:27:03,360
hi to you our logo look sorry let's take

00:27:01,890 --> 00:27:12,290
a quick look shouldn't be too hard to

00:27:03,360 --> 00:27:12,290
figure out where are they oh there

00:27:14,240 --> 00:27:17,600
that's correct

00:27:18,900 --> 00:27:24,600
oh there you go yeah host:20 okay whoops

00:27:22,680 --> 00:27:26,730
no the scene no should be second right

00:27:24,600 --> 00:27:31,350
so the host is correct

00:27:26,730 --> 00:27:41,400
the args are acting and correct notes

00:27:31,350 --> 00:27:44,790
still up that should be oh no the ports

00:27:41,400 --> 00:27:47,940
already there let's expect the same

00:27:44,790 --> 00:27:53,220
result well that's gonna be rough for

00:27:47,940 --> 00:27:58,020
our demo however take one more quick

00:27:53,220 --> 00:28:00,660
crack at it what we can do is get the

00:27:58,020 --> 00:28:02,610
rest of the nodes working so um can we

00:28:00,660 --> 00:28:04,020
we bring the lights down on the right a

00:28:02,610 --> 00:28:07,290
little bit it's not possible

00:28:04,020 --> 00:28:09,240
so anyone running lights up there no all

00:28:07,290 --> 00:28:10,500
right that's fine hope the LEDs that I

00:28:09,240 --> 00:28:18,470
bought were ultra bright they should

00:28:10,500 --> 00:28:22,260
work okay so continuing on all right so

00:28:18,470 --> 00:28:24,929
we'll see how this goes so this JB will

00:28:22,260 --> 00:28:27,030
run up eventually what you'll see see

00:28:24,929 --> 00:28:28,679
this lights up yeah so I don't know if

00:28:27,030 --> 00:28:30,030
you see this in the back how good is the

00:28:28,679 --> 00:28:32,400
lighting can you see anything in these

00:28:30,030 --> 00:28:34,530
these lights from the back yeah well

00:28:32,400 --> 00:28:36,720
back left says good everyone else might

00:28:34,530 --> 00:28:41,280
need glasses if you can't see them all

00:28:36,720 --> 00:28:42,690
right so let's keep going so what I'm

00:28:41,280 --> 00:28:44,100
going to show you as the notes come up

00:28:42,690 --> 00:28:46,640
we'll get the last one and then we'll

00:28:44,100 --> 00:28:46,640
talk about it

00:28:55,590 --> 00:29:00,670
all right so what you see is these nodes

00:28:57,820 --> 00:29:02,560
start starting to communicate as I bring

00:29:00,670 --> 00:29:06,010
the nodes up what it is is the gossip

00:29:02,560 --> 00:29:09,000
protocol chatting back and forth we can

00:29:06,010 --> 00:29:09,000
talk about that for a little while

00:29:16,450 --> 00:29:21,820
so what you're going to see is these go

00:29:17,770 --> 00:29:24,790
on the cluster the the cluster receives

00:29:21,820 --> 00:29:27,130
adjoining requests as that happens what

00:29:24,790 --> 00:29:29,740
happens is the nodes start to gossip a

00:29:27,130 --> 00:29:31,810
cluster uses a bit of a more complicated

00:29:29,740 --> 00:29:32,500
gossiping protocol than then I went over

00:29:31,810 --> 00:29:36,040
in the slides

00:29:32,500 --> 00:29:40,510
it's a push-pull protocol where one node

00:29:36,040 --> 00:29:42,370
will only send it'll send just the

00:29:40,510 --> 00:29:43,900
information that it knows about and go

00:29:42,370 --> 00:29:45,250
sends that information out to the next

00:29:43,900 --> 00:29:47,020
node and says hey do you already have

00:29:45,250 --> 00:29:48,250
this state if it doesn't then there's a

00:29:47,020 --> 00:29:54,760
lot more communication between the two

00:29:48,250 --> 00:29:57,460
nodes to provide that state alright so

00:29:54,760 --> 00:30:00,880
as you'll see so I'm using for this demo

00:29:57,460 --> 00:30:02,380
a Kazakh clusters auto down it will down

00:30:00,880 --> 00:30:05,110
after 30 seconds so if any of these are

00:30:02,380 --> 00:30:07,180
sort of not working well we should see

00:30:05,110 --> 00:30:09,910
that in the other state what we'll see

00:30:07,180 --> 00:30:13,500
is that the seen by should turn into six

00:30:09,910 --> 00:30:15,490
nodes all across the board which it does

00:30:13,500 --> 00:30:19,810
yeah

00:30:15,490 --> 00:30:21,610
the akka HTTP would be great if I could

00:30:19,810 --> 00:30:23,850
get it to work but it looks like that

00:30:21,610 --> 00:30:32,710
might not be an option for the demo so

00:30:23,850 --> 00:30:35,100
what I'll do is probably sum up so let's

00:30:32,710 --> 00:30:35,100
go back

00:30:39,590 --> 00:30:42,730
not that one

00:30:57,480 --> 00:31:00,200
are you

00:31:00,370 --> 00:31:05,559
all right so yeah we're going to skip

00:31:03,820 --> 00:31:06,580
over the the quiz actually know what

00:31:05,559 --> 00:31:08,920
let's just do it anyway because we're

00:31:06,580 --> 00:31:10,990
here okay so uh yeah Canada holds 20

00:31:08,920 --> 00:31:14,350
percent of the world's put it round up

00:31:10,990 --> 00:31:18,180
if you think it's maple syrup nobody oh

00:31:14,350 --> 00:31:22,900
two people okay good green fresh water

00:31:18,180 --> 00:31:25,059
okay and hockey players okay I like the

00:31:22,900 --> 00:31:27,820
hockey players answer myself it's

00:31:25,059 --> 00:31:29,890
incorrect fresh water is the answer so

00:31:27,820 --> 00:31:30,880
one of the things that you would see if

00:31:29,890 --> 00:31:32,650
the demos work and we'll see if we can

00:31:30,880 --> 00:31:34,600
get adapter after this session I'll let

00:31:32,650 --> 00:31:36,130
anyone who wants to get out of here go

00:31:34,600 --> 00:31:38,590
but well I'll keep playing with it for a

00:31:36,130 --> 00:31:41,110
little while after what you would see is

00:31:38,590 --> 00:31:44,220
yeah so the clock as the cluster as the

00:31:41,110 --> 00:31:47,530
cluster goes through as we start voting

00:31:44,220 --> 00:31:48,970
and we bring nodes up the the data is

00:31:47,530 --> 00:31:50,770
starts getting replicated across the

00:31:48,970 --> 00:31:53,530
nodes and you see this eventual

00:31:50,770 --> 00:31:56,740
consistency model that akka cluster is

00:31:53,530 --> 00:31:57,850
quite good at but as it stands we won't

00:31:56,740 --> 00:31:58,990
be able to do that because the demo

00:31:57,850 --> 00:32:00,550
didn't quite go the way I wanted to

00:31:58,990 --> 00:32:03,610
should have named this presentation

00:32:00,550 --> 00:32:04,900
tempting the demo gods alright so in

00:32:03,610 --> 00:32:07,450
summary here's the things that we've

00:32:04,900 --> 00:32:09,040
learned we we've talked about why you

00:32:07,450 --> 00:32:12,610
might need a distributed system we've

00:32:09,040 --> 00:32:14,320
talked about how complex what

00:32:12,610 --> 00:32:16,390
complexities are added when you decide

00:32:14,320 --> 00:32:17,650
on a distributed system and we talked a

00:32:16,390 --> 00:32:20,080
little bit the features of echo cluster

00:32:17,650 --> 00:32:22,720
that will actually help immensely with

00:32:20,080 --> 00:32:23,170
managing that state so thank you very

00:32:22,720 --> 00:32:30,370
much

00:32:23,170 --> 00:32:32,080
are there any questions yes the code

00:32:30,370 --> 00:32:33,850
will be published on it's actually

00:32:32,080 --> 00:32:37,120
published on bitbucket right now but I

00:32:33,850 --> 00:32:40,600
feel like it will be published on github

00:32:37,120 --> 00:32:42,580
at their github slash David Gregg

00:32:40,600 --> 00:32:45,309
I'll also tweet tweet that location so

00:32:42,580 --> 00:32:48,040
yeah if you guys you guys spot that

00:32:45,309 --> 00:32:51,090
about that bug for the akka gtp we could

00:32:48,040 --> 00:32:56,940
get a pull request going yes

00:32:51,090 --> 00:33:00,920
I better in a diner how do you

00:32:56,940 --> 00:33:00,920
dynamically keep track of the seed note

00:33:01,370 --> 00:33:13,410
how do you maintain the IP address of

00:33:04,050 --> 00:33:16,440
the seed node Oh fair enough so the

00:33:13,410 --> 00:33:18,570
question was how do we how do we know if

00:33:16,440 --> 00:33:21,660
the seed node is even in the cluster is

00:33:18,570 --> 00:33:23,100
that sort of the idea right so it turns

00:33:21,660 --> 00:33:24,510
out that once here once your cluster is

00:33:23,100 --> 00:33:27,120
up and running you can connect to any of

00:33:24,510 --> 00:33:28,710
the known IP addresses in the cluster so

00:33:27,120 --> 00:33:30,510
you don't actually need the seed you

00:33:28,710 --> 00:33:34,410
need to seed to start the cluster but

00:33:30,510 --> 00:33:36,510
not to maintain so at the same way the

00:33:34,410 --> 00:33:39,930
failure detector the failure detector

00:33:36,510 --> 00:33:41,340
would down that seed node you'd know

00:33:39,930 --> 00:33:42,990
about and if you need it if you wanted a

00:33:41,340 --> 00:33:44,850
quick way to connect to it you could

00:33:42,990 --> 00:33:46,410
actually you could actually bring that

00:33:44,850 --> 00:33:47,640
node back up and then connect to it as

00:33:46,410 --> 00:33:49,410
well but you could do any of the other

00:33:47,640 --> 00:33:57,840
nodes in the system as well does that

00:33:49,410 --> 00:33:59,850
sort of answer your question you need to

00:33:57,840 --> 00:34:02,780
know at least one IP address of the

00:33:59,850 --> 00:34:02,780
cluster that's correct

00:34:05,300 --> 00:34:11,100
sure so currently we're using console to

00:34:08,520 --> 00:34:16,190
maintain that list of nodes yeah it

00:34:11,100 --> 00:34:16,190
works pretty well yes

00:34:21,149 --> 00:34:32,779
oh sorry

00:34:29,639 --> 00:34:32,779
ah can you repeat the question a

00:34:34,279 --> 00:34:52,619
complete graph in what in what way how

00:34:41,549 --> 00:34:54,960
do you mean not not exactly so each node

00:34:52,619 --> 00:34:56,909
is responsible for knowing about a set

00:34:54,960 --> 00:34:58,890
of neighbors so for example in the

00:34:56,909 --> 00:35:00,450
failure detector it nodes about it's

00:34:58,890 --> 00:35:05,190
configurable but out the out the box

00:35:00,450 --> 00:35:07,529
it's five it's five nodes the way that

00:35:05,190 --> 00:35:08,819
it it knows about those are when it

00:35:07,529 --> 00:35:10,319
registers at the beginning it knows

00:35:08,819 --> 00:35:23,460
about what should be there not

00:35:10,319 --> 00:35:27,900
necessarily what is up yeah yeah

00:35:23,460 --> 00:35:30,900
absolutely so there is a the way that

00:35:27,900 --> 00:35:33,569
there is hinting an inside the cluster

00:35:30,900 --> 00:35:38,010
specification in the documents talk

00:35:33,569 --> 00:35:40,140
about a an opinionated gossip so it uses

00:35:38,010 --> 00:35:42,450
it tries to find nodes sort of in the

00:35:40,140 --> 00:35:46,680
same in the same area that that node is

00:35:42,450 --> 00:35:50,450
in does that answer or yeah okay all

00:35:46,680 --> 00:35:50,450
right other questions yes

00:35:54,070 --> 00:35:59,420
other than for a great demo at Skala

00:35:56,390 --> 00:36:02,960
days no the question was what causes a

00:35:59,420 --> 00:36:05,480
partition and why why would you reserve

00:36:02,960 --> 00:36:07,850
her an opportune to want one the answer

00:36:05,480 --> 00:36:10,760
is almost universally no what happens is

00:36:07,850 --> 00:36:11,960
you have what could happen so the the

00:36:10,760 --> 00:36:13,820
demo let's say you know what we can do

00:36:11,960 --> 00:36:18,280
it with the command line it won't be it

00:36:13,820 --> 00:36:18,280
won't be as pretty as raspberry pies and

00:36:20,350 --> 00:36:24,770
let's get back in here okay so what

00:36:23,330 --> 00:36:26,300
you'll see here is that you've got all

00:36:24,770 --> 00:36:27,440
of the nodes have seen each other so we

00:36:26,300 --> 00:36:28,970
have convergence everything's working

00:36:27,440 --> 00:36:30,890
fine what I'm going to do is I'm going

00:36:28,970 --> 00:36:32,900
to pull this red cord oh I got really

00:36:30,890 --> 00:36:36,310
loud when I did that and nobody's gonna

00:36:32,900 --> 00:36:38,450
be able to see this but keep watching so

00:36:36,310 --> 00:36:39,740
I've pulled the cord between these two

00:36:38,450 --> 00:36:41,750
I've got two routers the wireless one

00:36:39,740 --> 00:36:45,230
and then this switch so I pull one and

00:36:41,750 --> 00:36:47,690
what you'll see is two these two nodes

00:36:45,230 --> 00:36:49,340
are on their own on the switch or on the

00:36:47,690 --> 00:36:51,190
router and these four are off to

00:36:49,340 --> 00:36:54,790
themselves so now we have basically a

00:36:51,190 --> 00:36:58,190
problem you've got these four up here

00:36:54,790 --> 00:37:00,200
that can not see these two and so what

00:36:58,190 --> 00:37:02,780
you're seeing is a cluster gossiping out

00:37:00,200 --> 00:37:04,310
detecting a different state so basically

00:37:02,780 --> 00:37:05,660
yeah like a physical accident somebody

00:37:04,310 --> 00:37:08,690
tripped over a cord in a really poorly

00:37:05,660 --> 00:37:10,220
built network you know a natural

00:37:08,690 --> 00:37:12,440
disaster could bring bring it down a

00:37:10,220 --> 00:37:15,170
really bad if you're running AWS some

00:37:12,440 --> 00:37:19,250
bad deploys on the idea of AWS I'd think

00:37:15,170 --> 00:37:21,050
there was recently an AWS issue yeah

00:37:19,250 --> 00:37:23,120
yeah let's see what happens so if I get

00:37:21,050 --> 00:37:24,590
it in time so I'm using auto downing

00:37:23,120 --> 00:37:26,210
after 30 seconds what it's going to do

00:37:24,590 --> 00:37:28,820
is automatically down those nodes but

00:37:26,210 --> 00:37:32,120
I'll plug it back in and see if we can

00:37:28,820 --> 00:37:39,260
get the the network running again let's

00:37:32,120 --> 00:37:41,000
see the other thing is that my my my

00:37:39,260 --> 00:37:42,800
terminal sessions might be might be dead

00:37:41,000 --> 00:37:44,030
but yeah usually what happens as I pull

00:37:42,800 --> 00:37:45,380
it out I wouldn't do this long

00:37:44,030 --> 00:37:48,020
explanation plug it back into yeah

00:37:45,380 --> 00:37:51,080
active cluster will then go out and talk

00:37:48,020 --> 00:37:52,340
using the failure detector go and ping

00:37:51,080 --> 00:37:53,420
those nodes again look for heartbeat if

00:37:52,340 --> 00:37:55,940
they come back up yeah you're you and

00:37:53,420 --> 00:37:56,510
your network will get healed does that

00:37:55,940 --> 00:38:00,290
answer your question

00:37:56,510 --> 00:38:03,280
great any other questions I think he

00:38:00,290 --> 00:38:03,280
okay yes

00:38:05,890 --> 00:38:10,240
is it possible to bring up instances

00:38:08,420 --> 00:38:14,570
dynamically I missed an part the inverse

00:38:10,240 --> 00:38:16,250
sorry only when it's needed so you'd

00:38:14,570 --> 00:38:17,920
probably need a different tool to

00:38:16,250 --> 00:38:21,080
actually like maintain like figure out

00:38:17,920 --> 00:38:23,480
how many how much load is on the cluster

00:38:21,080 --> 00:38:25,640
itself but as far as that goes akka

00:38:23,480 --> 00:38:27,320
cluster as far as I know doesn't provide

00:38:25,640 --> 00:38:30,160
that functionality to auto scale nodes I

00:38:27,320 --> 00:38:36,280
could use a third party tool for that

00:38:30,160 --> 00:38:36,280
okay any other questions yes

00:38:42,180 --> 00:38:47,460
this one yeah so one of the things

00:38:44,820 --> 00:38:49,680
you're not seeing is this note here so

00:38:47,460 --> 00:38:51,570
I've actually made the web server a node

00:38:49,680 --> 00:38:53,550
in in the cluster so what's happening is

00:38:51,570 --> 00:38:54,630
this is the sorted set I this is totally

00:38:53,550 --> 00:38:56,580
a guess we'll have to let you could look

00:38:54,630 --> 00:38:57,990
into the code for this but the sorted

00:38:56,580 --> 00:39:00,990
set I think is just like literally like

00:38:57,990 --> 00:39:02,280
this is 192.168.1.2 - - the rest are

00:39:00,990 --> 00:39:04,620
letters so I'm guessing it's just the

00:39:02,280 --> 00:39:06,270
leader always picks this one when it can

00:39:04,620 --> 00:39:07,440
so that's why you're not seeing it in

00:39:06,270 --> 00:39:13,560
this in this thing I wonder if I could

00:39:07,440 --> 00:39:15,780
get the the other one up oh no because

00:39:13,560 --> 00:39:17,340
this is the answer man oh wait this this

00:39:15,780 --> 00:39:18,540
isn't even in the city in the cluster I

00:39:17,340 --> 00:39:21,570
know because it didn't work did it yeah

00:39:18,540 --> 00:39:23,940
that's a good point um so you should see

00:39:21,570 --> 00:39:25,170
less we could you know what let's scroll

00:39:23,940 --> 00:39:27,270
up in the log so you should see like a

00:39:25,170 --> 00:39:28,470
leader changed it's also in the like you

00:39:27,270 --> 00:39:30,600
have to actually log this out to the

00:39:28,470 --> 00:39:33,590
console so if I'm not if I'm not logging

00:39:30,600 --> 00:39:33,590
it properly you won't see it either

00:39:37,580 --> 00:39:42,990
leaders moving node from here to

00:39:40,860 --> 00:39:45,390
somewhere else so I'm not sure if that's

00:39:42,990 --> 00:39:49,860
the exact timing of that one that looks

00:39:45,390 --> 00:39:51,540
high up like every time you move it move

00:39:49,860 --> 00:39:53,550
into a new convergent so bobbin is once

00:39:51,540 --> 00:39:55,230
you hit that once you hit that partition

00:39:53,550 --> 00:39:56,970
those two nodes will reach convergence

00:39:55,230 --> 00:39:58,440
and the the leader node may or may not

00:39:56,970 --> 00:40:04,520
move there's a chance they will enroll

00:39:58,440 --> 00:40:07,530
that's sort of any other questions yes

00:40:04,520 --> 00:40:09,300
so a data to trees extensive to do most

00:40:07,530 --> 00:40:12,770
of our monitoring it's quite handy yeah

00:40:09,300 --> 00:40:12,770
at page EDD to send up the alert

00:40:21,329 --> 00:40:26,500
receiving requests of some sort and

00:40:24,099 --> 00:40:28,690
dispatching out to whichever one happens

00:40:26,500 --> 00:40:30,480
to have Joe I have to build the load

00:40:28,690 --> 00:40:33,869
balancing myself for theirs

00:40:30,480 --> 00:40:35,880
yeah for sure so acrimony has a bunch of

00:40:33,869 --> 00:40:38,880
routers that you can use but there's a

00:40:35,880 --> 00:40:42,119
metrics extension that you can run in I

00:40:38,880 --> 00:40:44,160
think 2.4 that'll actually maintain it

00:40:42,119 --> 00:40:46,140
will retrieve metrics from your nodes to

00:40:44,160 --> 00:40:48,270
find out like what's what's high under

00:40:46,140 --> 00:40:51,420
high high load right now and it will

00:40:48,270 --> 00:40:52,980
adaptively pick which node which is

00:40:51,420 --> 00:40:57,210
really cool it's a really cool feature

00:40:52,980 --> 00:40:58,470
in my opinion yeah I want to say it's an

00:40:57,210 --> 00:41:00,150
experimental feature we should probably

00:40:58,470 --> 00:41:01,500
look into the docs for that it's like

00:41:00,150 --> 00:41:02,849
right on the specification page you can

00:41:01,500 --> 00:41:04,190
look right there I don't want to I don't

00:41:02,849 --> 00:41:07,980
want to give you bad information you

00:41:04,190 --> 00:41:10,820
okay any other questions all right guys

00:41:07,980 --> 00:41:10,820

YouTube URL: https://www.youtube.com/watch?v=WVHqUL-8FuM


