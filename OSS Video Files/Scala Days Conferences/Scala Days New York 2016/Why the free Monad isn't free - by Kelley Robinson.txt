Title: Why the free Monad isn't free - by Kelley Robinson
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Scala developers love to discuss Monads, their metaphors, and their many use cases. Recognizing that monadic design and development patterns have their place, this talk will discuss the price of implementing the Free Monad in your code - spoiler alert - it's not free. We will define the Free Monad (without using complicated category theory!) and give you the confidence to know when it is and is not the answer in your code. We will also discuss some alternatives and their tradeoffs in maintainability, performance and design.
Captions: 
	00:00:09,820 --> 00:00:18,669
hi everyone so a couple of years ago I

00:00:15,490 --> 00:00:20,529
was working at a small startup we had

00:00:18,669 --> 00:00:22,660
our application written in Scala and

00:00:20,529 --> 00:00:24,730
there was enough issues with it that we

00:00:22,660 --> 00:00:27,760
decided to completely overhaul our

00:00:24,730 --> 00:00:29,199
architecture we wanted to do it right we

00:00:27,760 --> 00:00:31,750
were going to be functional

00:00:29,199 --> 00:00:35,320
we added Scala Zed we added the state

00:00:31,750 --> 00:00:37,150
monad it was going to be beautiful until

00:00:35,320 --> 00:00:40,269
we started seeing stack overflow errors

00:00:37,150 --> 00:00:42,340
and this was just in testing we hadn't

00:00:40,269 --> 00:00:44,800
even deployed it to production yet so my

00:00:42,340 --> 00:00:47,710
coworker says let's just trampoline it

00:00:44,800 --> 00:00:51,879
and add the free monad and this is me

00:00:47,710 --> 00:00:53,739
being confused why he said that this was

00:00:51,879 --> 00:00:55,300
the first time I had even heard of the

00:00:53,739 --> 00:00:57,579
free monad and I didn't know what my

00:00:55,300 --> 00:00:59,710
coworker meant or why he intended it to

00:00:57,579 --> 00:01:01,660
solve our problems and then a couple

00:00:59,710 --> 00:01:03,940
years later I was at a different company

00:01:01,660 --> 00:01:05,979
than a different Scala code base and

00:01:03,940 --> 00:01:07,990
there was one application there that no

00:01:05,979 --> 00:01:10,390
one ever wanted to touch and I looked at

00:01:07,990 --> 00:01:12,070
the code and understood why we were

00:01:10,390 --> 00:01:14,350
using free monads to do all of our

00:01:12,070 --> 00:01:17,259
datastore app operations in this one

00:01:14,350 --> 00:01:19,750
code base as the function of the

00:01:17,259 --> 00:01:20,770
application was really simple but the

00:01:19,750 --> 00:01:25,299
code made it look really complicated

00:01:20,770 --> 00:01:26,740
this might sound familiar so small

00:01:25,299 --> 00:01:29,140
changes in that project took a long time

00:01:26,740 --> 00:01:30,759
and I wanted to understand if I was

00:01:29,140 --> 00:01:32,950
justified in being annoyed with that

00:01:30,759 --> 00:01:34,479
application so decided to figure out

00:01:32,950 --> 00:01:37,659
what the heck a free monad is so you

00:01:34,479 --> 00:01:39,939
don't have to my name is Kelly Robinson

00:01:37,659 --> 00:01:41,350
I'm a data and infrastructure engineer

00:01:39,939 --> 00:01:43,659
at a company in San Francisco called

00:01:41,350 --> 00:01:45,310
share through and today I'm going to

00:01:43,659 --> 00:01:49,149
talk to you about why the free monad

00:01:45,310 --> 00:01:51,310
isn't free so before we talk about why

00:01:49,149 --> 00:01:53,350
it's not free I promise to tell you what

00:01:51,310 --> 00:01:54,909
a free monad is and in order to do that

00:01:53,350 --> 00:01:57,009
we are going to do a brief introduction

00:01:54,909 --> 00:01:58,750
to ma nodes functors and monads we'll

00:01:57,009 --> 00:02:00,820
talk about the free version of those

00:01:58,750 --> 00:02:03,070
data structures and then talk about why

00:02:00,820 --> 00:02:05,680
people might want to use these and maybe

00:02:03,070 --> 00:02:07,240
why you shouldn't and then if you're not

00:02:05,680 --> 00:02:09,119
going to use the free monad what are the

00:02:07,240 --> 00:02:11,650
alternatives available to you and

00:02:09,119 --> 00:02:12,970
finally we'll wrap up by talking about

00:02:11,650 --> 00:02:14,950
some of the things that people are

00:02:12,970 --> 00:02:18,940
actually using this for in the real

00:02:14,950 --> 00:02:21,160
world this presentation has a lot of

00:02:18,940 --> 00:02:22,269
code it's all available on my github for

00:02:21,160 --> 00:02:23,290
you to reference later if you're

00:02:22,269 --> 00:02:24,969
interested

00:02:23,290 --> 00:02:27,939
to play around with it later it's all

00:02:24,969 --> 00:02:31,299
there for you so you've probably heard

00:02:27,939 --> 00:02:33,189
monads or burritos monads are just mono

00:02:31,299 --> 00:02:35,140
in the category of endo functor what

00:02:33,189 --> 00:02:40,629
does that mean we're not really going to

00:02:35,140 --> 00:02:42,549
get into that but we are going to use

00:02:40,629 --> 00:02:44,920
mono aids and functors to build up our

00:02:42,549 --> 00:02:47,829
understanding of monads so let's start

00:02:44,920 --> 00:02:50,230
with mono a mono is our some type that

00:02:47,829 --> 00:02:53,139
has a couple of methods and properties

00:02:50,230 --> 00:02:54,790
that it follows methods it has an append

00:02:53,139 --> 00:02:57,099
type that's going to take to of any type

00:02:54,790 --> 00:02:59,379
put it together and create one of that

00:02:57,099 --> 00:03:01,810
type and then some method usually called

00:02:59,379 --> 00:03:04,599
identity it's a value that's a no op or

00:03:01,810 --> 00:03:06,400
empty so again to one type coming

00:03:04,599 --> 00:03:10,239
together to create a single instance of

00:03:06,400 --> 00:03:12,609
the type that's am anointed about the

00:03:10,239 --> 00:03:14,019
properties this identity value it's

00:03:12,609 --> 00:03:16,659
going to be a no op it's going to have

00:03:14,019 --> 00:03:18,310
an empty value to it so that it doesn't

00:03:16,659 --> 00:03:20,680
do anything when you use with the append

00:03:18,310 --> 00:03:22,060
method and then associativity is just a

00:03:20,680 --> 00:03:23,680
way to say that the grouping of the

00:03:22,060 --> 00:03:25,930
append methods isn't going to matter

00:03:23,680 --> 00:03:27,909
buzz like yours right there are mono

00:03:25,930 --> 00:03:31,750
AIDS everywhere we can look at a couple

00:03:27,909 --> 00:03:34,090
examples string concatenation great

00:03:31,750 --> 00:03:35,409
example of a mono I'd you can take two

00:03:34,090 --> 00:03:37,000
strings and put them together and you

00:03:35,409 --> 00:03:38,709
have another string and then the

00:03:37,000 --> 00:03:42,010
identity the no op value there in that

00:03:38,709 --> 00:03:44,079
case is just an empty string we can look

00:03:42,010 --> 00:03:46,540
at a couple examples with integers and

00:03:44,079 --> 00:03:48,639
your addition great example of a mono

00:03:46,540 --> 00:03:51,280
I'd you can take two integers put them

00:03:48,639 --> 00:03:53,109
together and create another integer and

00:03:51,280 --> 00:03:56,340
then in order for the identity value to

00:03:53,109 --> 00:03:59,349
have no effect we set its value to zero

00:03:56,340 --> 00:04:01,810
another example with integers integer

00:03:59,349 --> 00:04:04,299
multiplication again you just use a

00:04:01,810 --> 00:04:05,620
different method to do the append in

00:04:04,299 --> 00:04:07,479
this case you're going to multiply two

00:04:05,620 --> 00:04:09,609
things together and then in order for

00:04:07,479 --> 00:04:12,760
the identity value to have no effect we

00:04:09,609 --> 00:04:15,400
set its value to one so there you have

00:04:12,760 --> 00:04:16,630
it mono is everywhere so far these are

00:04:15,400 --> 00:04:17,979
pretty standard to most every

00:04:16,630 --> 00:04:19,870
programming language and I'm sure you

00:04:17,979 --> 00:04:21,639
can think of others that use in Scala or

00:04:19,870 --> 00:04:23,620
other programming languages that you

00:04:21,639 --> 00:04:27,280
work with we can look at a slightly more

00:04:23,620 --> 00:04:29,470
complicated example function composition

00:04:27,280 --> 00:04:30,849
great example of a mono I'd here the

00:04:29,470 --> 00:04:33,729
append method is going to take two

00:04:30,849 --> 00:04:36,370
functions and compose them so you take

00:04:33,729 --> 00:04:38,500
some function from A to B and a function

00:04:36,370 --> 00:04:40,810
from B to C and put them together and

00:04:38,500 --> 00:04:42,699
get a function from A to C and then the

00:04:40,810 --> 00:04:44,530
identity method there is going to be a

00:04:42,699 --> 00:04:46,750
function that's still a no op so you

00:04:44,530 --> 00:04:48,850
take a function from a to a it's not

00:04:46,750 --> 00:04:50,530
going to do anything so you might have

00:04:48,850 --> 00:04:52,120
noticed that I commented out the extend

00:04:50,530 --> 00:04:53,740
there and that's because this doesn't

00:04:52,120 --> 00:04:56,080
quite compile in Scala if you

00:04:53,740 --> 00:04:59,169
instantiate it but that's okay these are

00:04:56,080 --> 00:05:01,240
just ideas that the language is using to

00:04:59,169 --> 00:05:02,650
implement and so we just want to show

00:05:01,240 --> 00:05:04,930
that this is a mono eight for a given

00:05:02,650 --> 00:05:07,180
shape and that shape is a function from

00:05:04,930 --> 00:05:08,530
one type to another type and even though

00:05:07,180 --> 00:05:10,270
those types are different they can be

00:05:08,530 --> 00:05:13,960
anything in Scala it's always going to

00:05:10,270 --> 00:05:16,150
follow that pattern in that shape and

00:05:13,960 --> 00:05:18,880
that brings us to functors so functors

00:05:16,150 --> 00:05:21,490
are going to be some family of types

00:05:18,880 --> 00:05:24,510
that has implemented the map method and

00:05:21,490 --> 00:05:26,830
so that map method is going to apply a

00:05:24,510 --> 00:05:28,270
function to every value in the

00:05:26,830 --> 00:05:29,949
collection depending on how you've

00:05:28,270 --> 00:05:31,570
defined it and then return a new

00:05:29,949 --> 00:05:36,220
collection a new instance of that

00:05:31,570 --> 00:05:37,539
collection so functors also have a

00:05:36,220 --> 00:05:39,669
couple of properties that they follow

00:05:37,539 --> 00:05:42,130
you have some identity property like you

00:05:39,669 --> 00:05:43,960
saw with monads or mono IDEs and that's

00:05:42,130 --> 00:05:46,240
going to still be a no op value that

00:05:43,960 --> 00:05:48,220
when it's used with the map method and

00:05:46,240 --> 00:05:49,990
then composition which is another way to

00:05:48,220 --> 00:05:51,910
say the grouping doesn't matter you can

00:05:49,990 --> 00:05:53,050
have one giant map or a bunch of maps in

00:05:51,910 --> 00:05:55,330
a row and that's not going to influence

00:05:53,050 --> 00:05:57,280
the end result so we can look at an

00:05:55,330 --> 00:05:59,800
example of this using scholars built-in

00:05:57,280 --> 00:06:03,039
option type we've redefined that here

00:05:59,800 --> 00:06:05,289
and then you can explicitly make that a

00:06:03,039 --> 00:06:07,660
functor by defining the map method and

00:06:05,289 --> 00:06:10,210
here we just pattern match on the option

00:06:07,660 --> 00:06:13,150
and then in the some case wrap it in

00:06:10,210 --> 00:06:15,580
another sum and apply the function and

00:06:13,150 --> 00:06:18,520
then we can test the properties apply

00:06:15,580 --> 00:06:21,760
I'm using Scala test and fun spec here

00:06:18,520 --> 00:06:23,620
to test this and we explicitly define

00:06:21,760 --> 00:06:25,240
the identity property and say that if we

00:06:23,620 --> 00:06:28,090
give that to the map function it's going

00:06:25,240 --> 00:06:29,470
to not affect the input result that the

00:06:28,090 --> 00:06:32,229
input in the output are going to be the

00:06:29,470 --> 00:06:33,699
same similarly we can do that with a

00:06:32,229 --> 00:06:35,620
composition and this is what I was

00:06:33,699 --> 00:06:37,300
talking about with the grouping doesn't

00:06:35,620 --> 00:06:39,669
matter you can create one big map

00:06:37,300 --> 00:06:42,550
function so that's the F and then G and

00:06:39,669 --> 00:06:44,080
then H or you can chain a bunch of maps

00:06:42,550 --> 00:06:48,729
together and these are both going to

00:06:44,080 --> 00:06:49,740
evaluate to Scala so a quick aside here

00:06:48,729 --> 00:06:52,560
for all

00:06:49,740 --> 00:06:54,750
Stickle purposes and Scala functors and

00:06:52,560 --> 00:06:56,250
endo functors are the same thing and it

00:06:54,750 --> 00:06:58,590
was a way to say mapping from one

00:06:56,250 --> 00:07:00,210
category to itself and in Scala that's

00:06:58,590 --> 00:07:02,729
going to mean mapping from a Scala type

00:07:00,210 --> 00:07:04,800
to a Scala type so when you hear that

00:07:02,729 --> 00:07:08,160
word just think functors you don't have

00:07:04,800 --> 00:07:11,880
to think anything fancy and that brings

00:07:08,160 --> 00:07:14,460
us to monads so I really like this term

00:07:11,880 --> 00:07:16,259
from a stack overflow post that says the

00:07:14,460 --> 00:07:18,539
term monad is a bit vacuous if you're

00:07:16,259 --> 00:07:21,660
not a mathematician an alternative term

00:07:18,539 --> 00:07:22,889
is computation builder this helps my

00:07:21,660 --> 00:07:24,569
argument you don't have to be a

00:07:22,889 --> 00:07:26,520
mathematician to understand this stuff

00:07:24,569 --> 00:07:31,380
so let's look at the definition of

00:07:26,520 --> 00:07:33,210
monads using Scala so omona ad is going

00:07:31,380 --> 00:07:36,120
to be some collection that has a couple

00:07:33,210 --> 00:07:38,970
of methods on it it's a container a

00:07:36,120 --> 00:07:41,310
context it has this method pure that's

00:07:38,970 --> 00:07:44,039
going to lift some value into that

00:07:41,310 --> 00:07:46,349
context and a flat map that's going to

00:07:44,039 --> 00:07:52,139
map like we saw with functors and then

00:07:46,349 --> 00:07:53,759
flat in that context it's going to yeah

00:07:52,139 --> 00:07:56,310
like I said flat in the context and so

00:07:53,759 --> 00:08:00,419
we can show how monads work by building

00:07:56,310 --> 00:08:02,639
on our option example so here we define

00:08:00,419 --> 00:08:04,979
the pure method to just wrap the value

00:08:02,639 --> 00:08:07,590
in a sum and that's going to create the

00:08:04,979 --> 00:08:09,120
option build the container and then when

00:08:07,590 --> 00:08:11,820
we flatmap very similar to the map

00:08:09,120 --> 00:08:13,650
operation before we pattern match and

00:08:11,820 --> 00:08:15,389
then apply the function in the sum case

00:08:13,650 --> 00:08:16,889
here we don't have to wrap it in the sum

00:08:15,389 --> 00:08:19,229
again because we don't want to keep

00:08:16,889 --> 00:08:24,150
building up those contexts we don't want

00:08:19,229 --> 00:08:26,340
to return a sum of sum of sum the

00:08:24,150 --> 00:08:28,440
interesting thing about this is now that

00:08:26,340 --> 00:08:30,930
we have the monad operations of flat map

00:08:28,440 --> 00:08:35,399
and pure we can work backwards to define

00:08:30,930 --> 00:08:37,200
the functor and mono eight operations so

00:08:35,399 --> 00:08:40,110
once you have pure and flat map you can

00:08:37,200 --> 00:08:42,060
define map more explicitly I've shown

00:08:40,110 --> 00:08:43,680
how you do that using those two methods

00:08:42,060 --> 00:08:47,940
so you don't have to redefine this for

00:08:43,680 --> 00:08:50,579
every monad that you make and similarly

00:08:47,940 --> 00:08:53,130
you can use flat map to define append as

00:08:50,579 --> 00:08:55,230
your concatenate Anor appending things

00:08:53,130 --> 00:08:57,540
together you can use flat map to do that

00:08:55,230 --> 00:08:59,100
and I've been explicit about how we did

00:08:57,540 --> 00:09:01,079
this here we are evaluating the

00:08:59,100 --> 00:09:02,820
functions in order to come out with our

00:09:01,079 --> 00:09:03,510
third new function that's going to

00:09:02,820 --> 00:09:12,120
return some

00:09:03,510 --> 00:09:15,329
from a to a context of C and the laws

00:09:12,120 --> 00:09:18,120
apply we still have this no op value for

00:09:15,329 --> 00:09:19,920
identity and we're still going to follow

00:09:18,120 --> 00:09:21,420
the composition property where we say

00:09:19,920 --> 00:09:25,110
the grouping of the flat maps isn't

00:09:21,420 --> 00:09:27,420
going to matter so we talked about how

00:09:25,110 --> 00:09:29,399
mapping is useful for composition it

00:09:27,420 --> 00:09:33,000
allows you to compose value and that's

00:09:29,399 --> 00:09:37,470
useful for managing side-effects monads

00:09:33,000 --> 00:09:38,730
make side-effects explicit and we see

00:09:37,470 --> 00:09:40,230
this everywhere in our program so you

00:09:38,730 --> 00:09:42,630
can think of things like lists and

00:09:40,230 --> 00:09:45,899
options and futures and like I said the

00:09:42,630 --> 00:09:47,850
value in a context is why monads are so

00:09:45,899 --> 00:09:50,130
useful it's because we don't want to end

00:09:47,850 --> 00:09:52,230
up with that nested context in the end

00:09:50,130 --> 00:09:54,329
of our programs we don't want the sum of

00:09:52,230 --> 00:09:59,850
sum of sum we just want some or none in

00:09:54,329 --> 00:10:01,889
the end so we can extend functor for the

00:09:59,850 --> 00:10:03,660
mono definition monad definition but we

00:10:01,889 --> 00:10:06,209
can't extend Mahanoy for similar reasons

00:10:03,660 --> 00:10:07,860
this doesn't quite compile in Scala but

00:10:06,209 --> 00:10:09,690
we want to extend it for a function

00:10:07,860 --> 00:10:11,430
shape and I mentioned that function

00:10:09,690 --> 00:10:13,589
shape so we can show that for the value

00:10:11,430 --> 00:10:15,899
in a context we keep talking about and

00:10:13,589 --> 00:10:17,430
all these methods are going to be using

00:10:15,899 --> 00:10:21,240
that shape even though they're using

00:10:17,430 --> 00:10:22,560
different types and I mention that so

00:10:21,240 --> 00:10:25,790
that we can look at the similarities

00:10:22,560 --> 00:10:28,620
between function composition and monads

00:10:25,790 --> 00:10:30,120
monads are going to take the function to

00:10:28,620 --> 00:10:32,310
the value in a context while the

00:10:30,120 --> 00:10:35,220
function composition example was a mono

00:10:32,310 --> 00:10:39,029
for just the function and so a monad is

00:10:35,220 --> 00:10:44,430
a mono I'd when it is a uses that type

00:10:39,029 --> 00:10:46,260
in that shape okay brief explanation of

00:10:44,430 --> 00:10:48,360
monads it was probably overview for some

00:10:46,260 --> 00:10:50,790
of you but it's useful so that now we

00:10:48,360 --> 00:10:53,670
can talk about the free versions of

00:10:50,790 --> 00:10:56,430
these contracts but before we talk about

00:10:53,670 --> 00:10:59,940
free it's useful to know what we mean

00:10:56,430 --> 00:11:04,139
when we say free so we mean free to be

00:10:59,940 --> 00:11:06,240
interpreted in any way we mean free to

00:11:04,139 --> 00:11:10,410
use in the sense of unrestricted and not

00:11:06,240 --> 00:11:13,410
zero cost or if you're a fan of Richard

00:11:10,410 --> 00:11:15,510
Stallman we mean free as in freedom not

00:11:13,410 --> 00:11:17,230
free as in beer similar the free

00:11:15,510 --> 00:11:19,060
software principles

00:11:17,230 --> 00:11:21,220
so there it is already the free monad

00:11:19,060 --> 00:11:22,750
isn't free but we're still going to

00:11:21,220 --> 00:11:28,510
explain what it is we're going to do

00:11:22,750 --> 00:11:30,370
that by starting with free ma nodes so

00:11:28,510 --> 00:11:31,840
quick refresh monolids they have some

00:11:30,370 --> 00:11:34,600
method that's going to append to of

00:11:31,840 --> 00:11:38,670
itself together so what makes a monoid

00:11:34,600 --> 00:11:40,840
free but we want it to be free from

00:11:38,670 --> 00:11:43,270
interpretation and we can't lose any

00:11:40,840 --> 00:11:45,550
data when we're doing that append step

00:11:43,270 --> 00:11:50,860
so that's pretty vague

00:11:45,550 --> 00:11:53,290
let's look at an example concatenated a

00:11:50,860 --> 00:11:53,710
list is a good example of a free mono

00:11:53,290 --> 00:11:56,440
IDE

00:11:53,710 --> 00:11:58,540
you can see here that we're just shoving

00:11:56,440 --> 00:11:59,860
data together there's no interpretation

00:11:58,540 --> 00:12:01,720
about what we're doing it when we're

00:11:59,860 --> 00:12:04,150
concatenating two lists we just put them

00:12:01,720 --> 00:12:05,770
together and then leave it and it's

00:12:04,150 --> 00:12:08,710
important that we define this with a

00:12:05,770 --> 00:12:10,750
generic type a we don't know what the

00:12:08,710 --> 00:12:13,270
underlying data is it could be anything

00:12:10,750 --> 00:12:15,910
it could be strings or int sore other

00:12:13,270 --> 00:12:18,130
complex types and that means that the

00:12:15,910 --> 00:12:19,750
only operations we can do on this are

00:12:18,130 --> 00:12:23,010
the mono a topper a shion's and that's

00:12:19,750 --> 00:12:26,710
what keeps it free from interpretation

00:12:23,010 --> 00:12:28,480
in contrast we can look at the integer

00:12:26,710 --> 00:12:31,930
addition example of something that's not

00:12:28,480 --> 00:12:33,550
free we're losing input data on the

00:12:31,930 --> 00:12:35,770
append step we're putting two numbers

00:12:33,550 --> 00:12:39,040
together we don't know what the input

00:12:35,770 --> 00:12:41,440
was once we produce the result there's a

00:12:39,040 --> 00:12:44,320
special algebra that's happening here

00:12:41,440 --> 00:12:46,510
that's very specific to that type the

00:12:44,320 --> 00:12:51,520
explicit type interpretation is what

00:12:46,510 --> 00:12:55,930
makes this not free so now we can talk

00:12:51,520 --> 00:12:58,840
about free monads like we saw with

00:12:55,930 --> 00:13:00,640
freamon's we don't want to lose any data

00:12:58,840 --> 00:13:02,560
when we're doing that flat map that

00:13:00,640 --> 00:13:04,630
append step when we're composing these

00:13:02,560 --> 00:13:07,210
together and so that's going to mean

00:13:04,630 --> 00:13:11,320
that we can't evaluate any functions as

00:13:07,210 --> 00:13:13,030
we're doing this before when we talked

00:13:11,320 --> 00:13:15,670
about this append step that we defined

00:13:13,030 --> 00:13:17,890
with our flat map we were explicitly

00:13:15,670 --> 00:13:19,860
evaluating functions and this isn't

00:13:17,890 --> 00:13:22,390
going to fly if we want it to be free

00:13:19,860 --> 00:13:26,410
we're losing data in this step this

00:13:22,390 --> 00:13:29,500
isn't a free app n so how do we build a

00:13:26,410 --> 00:13:31,000
free monad the trick is to store up the

00:13:29,500 --> 00:13:33,300
data store up the function

00:13:31,000 --> 00:13:35,889
as you're building the structure and

00:13:33,300 --> 00:13:39,040
you're going to build this syntax so

00:13:35,889 --> 00:13:43,689
that you can evaluate it later so let's

00:13:39,040 --> 00:13:45,610
see what that looks like we're going to

00:13:43,689 --> 00:13:47,500
find some trait free that's going to

00:13:45,610 --> 00:13:52,300
take a family of types and some generic

00:13:47,500 --> 00:13:54,430
type a will add a class return this is

00:13:52,300 --> 00:13:56,079
going to be used in our pure functions

00:13:54,430 --> 00:14:01,389
and to indicate that there's no more

00:13:56,079 --> 00:14:04,269
computation to be done we'll add a class

00:14:01,389 --> 00:14:06,930
suspend and this is going to suspend

00:14:04,269 --> 00:14:09,279
some computation on that container type

00:14:06,930 --> 00:14:14,050
until we're ready to process the data

00:14:09,279 --> 00:14:16,089
and then we'll add a case flat map

00:14:14,050 --> 00:14:18,220
that's going to take an instance of free

00:14:16,089 --> 00:14:21,129
and a function from a to another

00:14:18,220 --> 00:14:23,560
instance of free and this looks a lot

00:14:21,129 --> 00:14:25,420
like the flat map message signature or

00:14:23,560 --> 00:14:27,279
method signature which is going to help

00:14:25,420 --> 00:14:29,860
us out as we build up the structure as

00:14:27,279 --> 00:14:33,519
we nest these together to store the data

00:14:29,860 --> 00:14:35,589
and save it for later and finally we'll

00:14:33,519 --> 00:14:37,449
add some methods to help with our

00:14:35,589 --> 00:14:39,160
computation and help building up this

00:14:37,449 --> 00:14:42,790
syntax so that we can use Scala

00:14:39,160 --> 00:14:44,379
syntactic sugar and we'll build up the

00:14:42,790 --> 00:14:46,120
types to store the syntax and the

00:14:44,379 --> 00:14:48,819
functions but we're not going to

00:14:46,120 --> 00:14:50,439
evaluate anything this is just free from

00:14:48,819 --> 00:14:51,759
interpretation we're just storing these

00:14:50,439 --> 00:14:53,500
things for later and we don't know what

00:14:51,759 --> 00:14:55,540
this is going to mean until we write

00:14:53,500 --> 00:14:58,209
some kind of evaluator at a later point

00:14:55,540 --> 00:15:01,779
so let's look at an example of a free

00:14:58,209 --> 00:15:04,149
monad we can build a free monad for

00:15:01,779 --> 00:15:06,670
actions on a to-do list so we've defined

00:15:04,149 --> 00:15:09,850
a domain-specific language here DSL

00:15:06,670 --> 00:15:11,649
syntax for doing actions on a to do list

00:15:09,850 --> 00:15:13,870
and while we've defined the language we

00:15:11,649 --> 00:15:16,180
don't know what any of these mean yet so

00:15:13,870 --> 00:15:19,089
we have things like creating a task and

00:15:16,180 --> 00:15:21,730
completing a task and we'll add some

00:15:19,089 --> 00:15:24,309
operations that are going to lift that

00:15:21,730 --> 00:15:27,100
syntax into our free monads suspend them

00:15:24,309 --> 00:15:28,629
until we're ready to evaluate and again

00:15:27,100 --> 00:15:30,850
this is free because we haven't done

00:15:28,629 --> 00:15:33,639
anything we don't know what it means to

00:15:30,850 --> 00:15:35,620
do these like to do these tasks or to

00:15:33,639 --> 00:15:38,920
create a task or complete a task we're

00:15:35,620 --> 00:15:42,389
just creating this syntax so let's see

00:15:38,920 --> 00:15:42,389
what this would look like in our program

00:15:43,270 --> 00:15:47,180
so this is pretty cool you can use a for

00:15:45,800 --> 00:15:50,350
comprehension now that you have the

00:15:47,180 --> 00:15:52,790
Monad to chain operations together and

00:15:50,350 --> 00:15:54,890
this might look familiar to code in your

00:15:52,790 --> 00:15:57,430
code base you're chaining using four

00:15:54,890 --> 00:15:59,750
comprehensions flat mapping / structures

00:15:57,430 --> 00:16:01,370
but the difference here is that nothing

00:15:59,750 --> 00:16:04,040
has actually happened yet even though we

00:16:01,370 --> 00:16:05,420
say new tasks go to Scala days we

00:16:04,040 --> 00:16:07,640
haven't done anything with that data

00:16:05,420 --> 00:16:09,650
we've just built up the free monad

00:16:07,640 --> 00:16:14,270
structure so that we can evaluate it

00:16:09,650 --> 00:16:16,850
later more explicitly we can expand this

00:16:14,270 --> 00:16:18,470
into its explicit types and this is

00:16:16,850 --> 00:16:20,270
where those data structures we defined

00:16:18,470 --> 00:16:22,610
earlier are going to come in handy we

00:16:20,270 --> 00:16:25,670
built up this large data structure with

00:16:22,610 --> 00:16:28,160
all the information that we're using so

00:16:25,670 --> 00:16:30,020
that we can evaluate it later again

00:16:28,160 --> 00:16:32,180
we're shoving the data together as we

00:16:30,020 --> 00:16:34,370
chain it we're not evaluating anything

00:16:32,180 --> 00:16:36,740
we're saving it for later no operations

00:16:34,370 --> 00:16:44,110
have been defined on this and that's why

00:16:36,740 --> 00:16:47,860
it's free so why would anyone do this

00:16:44,110 --> 00:16:50,630
there are a couple reasons first

00:16:47,860 --> 00:16:53,540
delaying evaluation means deferring

00:16:50,630 --> 00:16:56,170
side-effects you're going to compose

00:16:53,540 --> 00:16:59,180
functions without computing them and

00:16:56,170 --> 00:17:01,430
that syntax tree that we define the DSL

00:16:59,180 --> 00:17:04,040
for the to-do list that means that we

00:17:01,430 --> 00:17:06,680
can use multiple interpretations of the

00:17:04,040 --> 00:17:10,100
data we can build multiple interpreters

00:17:06,680 --> 00:17:11,600
to interpret that DSL it's like if I

00:17:10,100 --> 00:17:12,950
wrote out a list of instructions and

00:17:11,600 --> 00:17:14,630
handed it to multiple people in this

00:17:12,950 --> 00:17:16,970
room and probably get interpreted a bit

00:17:14,630 --> 00:17:19,640
differently by each person we want to

00:17:16,970 --> 00:17:23,330
program those interpretations and use

00:17:19,640 --> 00:17:25,780
multiple of them for our programs and

00:17:23,330 --> 00:17:29,240
then when we talk about stack safety if

00:17:25,780 --> 00:17:31,460
you imagine some function like this and

00:17:29,240 --> 00:17:33,170
I'll leave it up to you to imagine what

00:17:31,460 --> 00:17:35,270
the do something functions do in this

00:17:33,170 --> 00:17:38,710
example they could throw a side effect

00:17:35,270 --> 00:17:41,810
or be some kind of recursive function

00:17:38,710 --> 00:17:44,030
but in the course of your programs it's

00:17:41,810 --> 00:17:46,700
going to look something like this every

00:17:44,030 --> 00:17:49,670
function in the monadic context is going

00:17:46,700 --> 00:17:52,340
to get added to the stack so remember my

00:17:49,670 --> 00:17:54,180
coworker let's just trampoline it and

00:17:52,340 --> 00:17:57,190
add the free monad

00:17:54,180 --> 00:17:58,900
when we talk about trampolining we talk

00:17:57,190 --> 00:18:01,420
about expressing all of the control flow

00:17:58,900 --> 00:18:03,370
all of the function passing all of those

00:18:01,420 --> 00:18:06,010
chain functions expressing those in a

00:18:03,370 --> 00:18:09,310
loop instead of putting additional

00:18:06,010 --> 00:18:11,800
functions on the stack the free monad

00:18:09,310 --> 00:18:13,840
uses trampolining in its evaluation this

00:18:11,800 --> 00:18:15,340
is also what the Scala compiler does

00:18:13,840 --> 00:18:16,500
when it optimizes tail-recursive

00:18:15,340 --> 00:18:19,680
functions

00:18:16,500 --> 00:18:21,910
we're exchanging stack for heap and

00:18:19,680 --> 00:18:25,300
that's what trampolining in the free

00:18:21,910 --> 00:18:27,460
monad come down to we built up that

00:18:25,300 --> 00:18:29,470
giant data structure to store all of our

00:18:27,460 --> 00:18:31,330
functions that's the he put we're using

00:18:29,470 --> 00:18:34,600
instead of putting all those functions

00:18:31,330 --> 00:18:36,910
on the stack when we built up this data

00:18:34,600 --> 00:18:38,830
structure we built up all the heap and

00:18:36,910 --> 00:18:40,840
we want to make sure that we take

00:18:38,830 --> 00:18:42,880
advantage of that and don't evaluate

00:18:40,840 --> 00:18:45,850
this using some other kind of recursion

00:18:42,880 --> 00:18:48,010
we already gotten this far so when we

00:18:45,850 --> 00:18:52,210
have this list like syntax let's

00:18:48,010 --> 00:18:54,580
evaluate it using a loop so now we can

00:18:52,210 --> 00:18:59,680
look at what it's going to be when we

00:18:54,580 --> 00:19:02,710
evaluate these functions so let's look

00:18:59,680 --> 00:19:05,320
at the function signature this run free

00:19:02,710 --> 00:19:07,660
function is going to be what we use to

00:19:05,320 --> 00:19:09,610
take a free monad and get the evaluation

00:19:07,660 --> 00:19:11,710
out of it this is what's going to handle

00:19:09,610 --> 00:19:13,450
the side-effects this is what's going to

00:19:11,710 --> 00:19:17,260
do that interpretation use your

00:19:13,450 --> 00:19:21,340
interpreter and so we'll take some input

00:19:17,260 --> 00:19:23,080
of your free monad and some transformer

00:19:21,340 --> 00:19:24,760
that's going to take an input functor

00:19:23,080 --> 00:19:26,230
and turn it into a new functor and

00:19:24,760 --> 00:19:28,420
that's why it's going to be called a

00:19:26,230 --> 00:19:31,120
functor transformer and then we have

00:19:28,420 --> 00:19:35,770
this implicit condition that the

00:19:31,120 --> 00:19:37,900
transformed function so a monad the

00:19:35,770 --> 00:19:41,950
tricky part about this is going to be

00:19:37,900 --> 00:19:43,450
that the functor transformer but this is

00:19:41,950 --> 00:19:45,640
what's going to allow us to have a

00:19:43,450 --> 00:19:50,800
generic way to have those multiple

00:19:45,640 --> 00:19:52,780
interpretations so when we talk about

00:19:50,800 --> 00:19:55,630
functor transformers you might also hear

00:19:52,780 --> 00:19:58,330
these called natural transformations but

00:19:55,630 --> 00:20:00,370
that's kind of a vague term or I've

00:19:58,330 --> 00:20:02,320
included that symbolic operator that's

00:20:00,370 --> 00:20:04,540
squiggly arrow but we all know how hard

00:20:02,320 --> 00:20:06,220
those are to search so I've been very

00:20:04,540 --> 00:20:07,510
explicit here and called it a functor

00:20:06,220 --> 00:20:12,330
transformer because that's

00:20:07,510 --> 00:20:14,740
it is so let's look at the function body

00:20:12,330 --> 00:20:16,360
this is already a lot of code so I've

00:20:14,740 --> 00:20:19,360
intentionally left to lump it out

00:20:16,360 --> 00:20:20,980
but the important parts are that we're

00:20:19,360 --> 00:20:25,300
going to pattern match on the on the

00:20:20,980 --> 00:20:27,880
case of the free monad if it's a return

00:20:25,300 --> 00:20:29,560
or a suspend or a flat map and then

00:20:27,880 --> 00:20:32,290
we're going to use tail recursion as

00:20:29,560 --> 00:20:34,720
much as possible to keep this trampoline

00:20:32,290 --> 00:20:37,240
to use this in a loop to run it in a

00:20:34,720 --> 00:20:42,190
loop and do that evaluation in a stack

00:20:37,240 --> 00:20:44,590
safe way one thing I will mention is

00:20:42,190 --> 00:20:46,740
what happens on the suspend cases and

00:20:44,590 --> 00:20:49,360
this is where we're going to apply that

00:20:46,740 --> 00:20:51,640
transformation so we take our input

00:20:49,360 --> 00:20:53,710
functor and that is going to be like

00:20:51,640 --> 00:20:55,150
that to do class that we defined and

00:20:53,710 --> 00:20:58,300
then we're going to transform it into

00:20:55,150 --> 00:21:00,760
something new and we can talk about what

00:20:58,300 --> 00:21:04,630
those interpreters look like but first

00:21:00,760 --> 00:21:06,760
we can be even more explicit about how

00:21:04,630 --> 00:21:08,530
we run this so this might look a little

00:21:06,760 --> 00:21:10,240
weird you if you're used to a functional

00:21:08,530 --> 00:21:11,860
style but this is a really good

00:21:10,240 --> 00:21:13,450
representation of what's happening under

00:21:11,860 --> 00:21:15,010
the hood we're going to run this in a

00:21:13,450 --> 00:21:16,810
loop and the business logic here is

00:21:15,010 --> 00:21:20,260
going to be exactly the same as it was

00:21:16,810 --> 00:21:22,330
for the tail recursive version but it's

00:21:20,260 --> 00:21:24,910
just being explicit showing that you can

00:21:22,330 --> 00:21:27,070
do this by running it in a loop so when

00:21:24,910 --> 00:21:30,070
we evaluate we want to apply the

00:21:27,070 --> 00:21:31,870
transformation on the suspend case and

00:21:30,070 --> 00:21:33,700
we want to make sure that we use

00:21:31,870 --> 00:21:38,260
trampolining and run things in a loop

00:21:33,700 --> 00:21:42,220
for stack safety so now we can go back

00:21:38,260 --> 00:21:43,900
and look at what it will be like to

00:21:42,220 --> 00:21:45,640
write an interpreter what does this

00:21:43,900 --> 00:21:47,920
functor transform are going to look like

00:21:45,640 --> 00:21:49,420
let's see what it's going to look like

00:21:47,920 --> 00:21:51,910
for our to-do list

00:21:49,420 --> 00:21:56,020
so let's write one that we can use to

00:21:51,910 --> 00:21:58,870
test I've created a trivial context here

00:21:56,020 --> 00:21:59,530
that I'd type because we don't care what

00:21:58,870 --> 00:22:03,550
the output is

00:21:59,530 --> 00:22:05,410
and then this test evaluator is going to

00:22:03,550 --> 00:22:07,030
take a mutable map in place of whatever

00:22:05,410 --> 00:22:11,680
data store you're using for your

00:22:07,030 --> 00:22:13,750
production and then that apply method is

00:22:11,680 --> 00:22:15,520
what's going to build the transformer

00:22:13,750 --> 00:22:17,500
it's going to take our to-do list and

00:22:15,520 --> 00:22:20,200
turn it into that aid context that

00:22:17,500 --> 00:22:21,250
trivial context we created so in the

00:22:20,200 --> 00:22:22,300
body of that apply

00:22:21,250 --> 00:22:24,820
function it's going to look something

00:22:22,300 --> 00:22:26,560
like this so this is why the DSL was

00:22:24,820 --> 00:22:28,300
useful because in the end you're going

00:22:26,560 --> 00:22:30,610
to end up pattern matching in all of

00:22:28,300 --> 00:22:32,560
those cases that you would defined so

00:22:30,610 --> 00:22:35,740
now is when you taste a what it actually

00:22:32,560 --> 00:22:37,450
means to do when you have a new task in

00:22:35,740 --> 00:22:39,280
this case we're adding it to the map

00:22:37,450 --> 00:22:41,680
when we're completing the task we're

00:22:39,280 --> 00:22:43,600
doing something different we're

00:22:41,680 --> 00:22:45,910
performing actions based on what the

00:22:43,600 --> 00:22:50,200
syntax tells us to do and building up

00:22:45,910 --> 00:22:53,080
that model and then this is how you run

00:22:50,200 --> 00:22:55,180
it you give your list of two dues to the

00:22:53,080 --> 00:22:58,210
run free function and then feed it the

00:22:55,180 --> 00:23:00,700
evaluator that you want to use and here

00:22:58,210 --> 00:23:04,900
we can confirm that our expected output

00:23:00,700 --> 00:23:06,790
is indeed what we produce but this test

00:23:04,900 --> 00:23:09,160
might be shadowing business logic we've

00:23:06,790 --> 00:23:10,870
included some boolean logic there so we

00:23:09,160 --> 00:23:14,980
can write an even different type of test

00:23:10,870 --> 00:23:17,440
interpreter so this action test

00:23:14,980 --> 00:23:20,110
evaluator is going to build up a list of

00:23:17,440 --> 00:23:22,660
the expected actions this is going to be

00:23:20,110 --> 00:23:24,730
the event source version of our test if

00:23:22,660 --> 00:23:28,680
you will this is also going to test the

00:23:24,730 --> 00:23:31,120
order of the actions in which they occur

00:23:28,680 --> 00:23:32,740
very similarly in the body of that

00:23:31,120 --> 00:23:35,560
function it's still going to pattern

00:23:32,740 --> 00:23:37,990
match on the different types but instead

00:23:35,560 --> 00:23:40,330
now is just going to append those to the

00:23:37,990 --> 00:23:42,550
actions list so that we can test the

00:23:40,330 --> 00:23:47,740
expected order of the actions that we

00:23:42,550 --> 00:23:49,900
want to see and here we have a list that

00:23:47,740 --> 00:23:52,990
we return and we can test that those are

00:23:49,900 --> 00:23:55,540
the same thing and this is useful

00:23:52,990 --> 00:23:57,040
because your production interpreters in

00:23:55,540 --> 00:23:59,380
this case are probably going to be doing

00:23:57,040 --> 00:24:01,900
database rights or something else with

00:23:59,380 --> 00:24:03,850
side effects and the useful thing about

00:24:01,900 --> 00:24:05,500
having multiple interpreters is that you

00:24:03,850 --> 00:24:07,360
can do one thing in production that has

00:24:05,500 --> 00:24:09,280
side effects and then suppress those

00:24:07,360 --> 00:24:12,340
side effects in your test evaluator and

00:24:09,280 --> 00:24:18,490
still have a ability to test things

00:24:12,340 --> 00:24:20,110
without using any kind of mocks so let's

00:24:18,490 --> 00:24:22,810
look at an example of the production

00:24:20,110 --> 00:24:26,110
interpreter here we've written it to

00:24:22,810 --> 00:24:27,700
transform to an option it's not the same

00:24:26,110 --> 00:24:29,410
as that aid type that we define for the

00:24:27,700 --> 00:24:31,600
tests and it's probably not going to be

00:24:29,410 --> 00:24:33,790
that's why it's useful that we wrote

00:24:31,600 --> 00:24:36,640
this in a generic way

00:24:33,790 --> 00:24:39,070
and it's also important that the

00:24:36,640 --> 00:24:41,560
transform type is a monad because as you

00:24:39,070 --> 00:24:44,410
see here will return a sum if the DB

00:24:41,560 --> 00:24:46,720
right succeeds and a nun if it fails and

00:24:44,410 --> 00:24:48,640
because it's a monad we can stop the

00:24:46,720 --> 00:24:50,770
execution in the chain if something

00:24:48,640 --> 00:24:53,080
fails if something returns to nun we're

00:24:50,770 --> 00:24:58,690
not going to keep doing execution on

00:24:53,080 --> 00:25:00,850
that chain so again reasons people do

00:24:58,690 --> 00:25:02,260
this you want to defer side-effects and

00:25:00,850 --> 00:25:04,410
that's for things like you would be

00:25:02,260 --> 00:25:07,390
doing in production in queueing messages

00:25:04,410 --> 00:25:09,640
asynchronous HTTP HTTP requests or

00:25:07,390 --> 00:25:11,290
database rights and then in test you can

00:25:09,640 --> 00:25:15,990
suppress those or maybe you have a need

00:25:11,290 --> 00:25:19,210
for multiple production interpreters and

00:25:15,990 --> 00:25:20,680
then we talked about stack safety and

00:25:19,210 --> 00:25:23,020
deferring side effects and all of that

00:25:20,680 --> 00:25:25,600
the other reason that a lot of people

00:25:23,020 --> 00:25:28,510
use the free monad or want to or talk

00:25:25,600 --> 00:25:30,430
about it is simply because they can it's

00:25:28,510 --> 00:25:32,440
a neat solution but that's the problem

00:25:30,430 --> 00:25:34,630
with Scala a lot of times you find these

00:25:32,440 --> 00:25:40,000
neat solutions and there's usually an

00:25:34,630 --> 00:25:41,860
easier way there's this excellent talk

00:25:40,000 --> 00:25:44,230
from Jessica Kerr at last year's Scala

00:25:41,860 --> 00:25:47,140
exchange called blue skies Scala where

00:25:44,230 --> 00:25:49,660
she talks about the meat of our business

00:25:47,140 --> 00:25:51,310
logic in our applications that's

00:25:49,660 --> 00:25:53,620
somewhere between the green grass the

00:25:51,310 --> 00:25:57,340
easy stuff and outerspace the

00:25:53,620 --> 00:25:58,570
complicated stuff the free monad isn't

00:25:57,340 --> 00:26:01,300
free because it falls into that

00:25:58,570 --> 00:26:04,300
outerspace category it's applications

00:26:01,300 --> 00:26:07,000
are impressive and effective but the

00:26:04,300 --> 00:26:12,880
path to get there is complicated and

00:26:07,000 --> 00:26:15,310
broken composition is really good but

00:26:12,880 --> 00:26:17,140
the boilerplate that DSL that we had to

00:26:15,310 --> 00:26:18,820
build up for our todoist example that's

00:26:17,140 --> 00:26:20,680
going to get really expensive really

00:26:18,820 --> 00:26:22,750
fast we had three actions that we

00:26:20,680 --> 00:26:25,030
defined for our toy example but in

00:26:22,750 --> 00:26:26,980
production that might not be manageable

00:26:25,030 --> 00:26:29,530
because what you're going to have to do

00:26:26,980 --> 00:26:32,050
is take any implicit action in your code

00:26:29,530 --> 00:26:34,240
and suddenly codify that make it

00:26:32,050 --> 00:26:36,490
explicit create a data type that's going

00:26:34,240 --> 00:26:37,600
to represent that action and so you're

00:26:36,490 --> 00:26:40,060
not only going to have a lot of

00:26:37,600 --> 00:26:42,250
boilerplate that you're using to build

00:26:40,060 --> 00:26:43,810
up those expectations but then you're

00:26:42,250 --> 00:26:45,130
interpreters are going to be huge to

00:26:43,810 --> 00:26:46,910
because you're going to have to pattern

00:26:45,130 --> 00:26:49,490
match on all of these different cases

00:26:46,910 --> 00:26:51,740
and then you can talk about the learning

00:26:49,490 --> 00:26:53,480
curve for this it's really easy to be

00:26:51,740 --> 00:26:55,700
frustrated for not understanding what

00:26:53,480 --> 00:26:58,870
monads or free monads are and that's not

00:26:55,700 --> 00:27:01,610
because they're explicitly complicated

00:26:58,870 --> 00:27:04,160
but because a lot of the explanations

00:27:01,610 --> 00:27:06,680
out there are in the wrong context they

00:27:04,160 --> 00:27:10,070
assume that you're a category theorist

00:27:06,680 --> 00:27:11,870
or a Haskell programmer I shouldn't have

00:27:10,070 --> 00:27:13,760
to go read learn you a Haskell for a

00:27:11,870 --> 00:27:18,800
great good to be a competent Scala

00:27:13,760 --> 00:27:20,300
developer and that makes including

00:27:18,800 --> 00:27:23,240
things like this in your code bases

00:27:20,300 --> 00:27:25,940
pretty hard to maintain we want to stay

00:27:23,240 --> 00:27:28,610
in the blue sky we can take an airplane

00:27:25,940 --> 00:27:33,980
to get from point A to point B a rocket

00:27:28,610 --> 00:27:37,010
ship is too expensive so if you're not

00:27:33,980 --> 00:27:41,420
going to use the free monad what are the

00:27:37,010 --> 00:27:42,980
alternatives available to you so first

00:27:41,420 --> 00:27:45,200
we want to know our domain I'm not

00:27:42,980 --> 00:27:47,390
saying that we can't use this but just

00:27:45,200 --> 00:27:49,100
to be mindful about the situations and

00:27:47,390 --> 00:27:51,950
applications that we do use these

00:27:49,100 --> 00:27:53,810
constructs this is programming it's all

00:27:51,950 --> 00:27:56,390
about trade-offs and that's going to be

00:27:53,810 --> 00:27:58,460
dependent on your domain so know your

00:27:56,390 --> 00:28:00,260
domain Scala is extremely powerful

00:27:58,460 --> 00:28:03,440
there's a lot of ways that you can write

00:28:00,260 --> 00:28:05,480
your Scala code a lot of people think of

00:28:03,440 --> 00:28:07,880
Scala is some functional spectrum from

00:28:05,480 --> 00:28:10,760
Java to Haskell and how functionally

00:28:07,880 --> 00:28:13,730
your code base is no the expertise of

00:28:10,760 --> 00:28:17,000
your team a lot of my current team came

00:28:13,730 --> 00:28:19,640
from Java so we're somewhat centered on

00:28:17,000 --> 00:28:22,700
this spectrum we definitely make use of

00:28:19,640 --> 00:28:25,880
a functional style but we're more likely

00:28:22,700 --> 00:28:28,160
to hire X Ruby or X Java developers then

00:28:25,880 --> 00:28:30,290
we are X Haskell or even X Scala

00:28:28,160 --> 00:28:32,150
developers and that makes the

00:28:30,290 --> 00:28:35,480
maintenance cost of super functional

00:28:32,150 --> 00:28:38,390
style projects kind of annoying so if

00:28:35,480 --> 00:28:40,430
you are doing Greenfield ask yourself is

00:28:38,390 --> 00:28:42,920
this something your coworkers are going

00:28:40,430 --> 00:28:45,470
to be able to help you maintain do you

00:28:42,920 --> 00:28:48,860
have the time and the tooling for these

00:28:45,470 --> 00:28:51,610
abstractions and is it necessary for

00:28:48,860 --> 00:28:51,610
your business logic

00:28:54,510 --> 00:29:00,540
and this motivates how we think about

00:28:57,090 --> 00:29:02,850
our alternatives so if your code base is

00:29:00,540 --> 00:29:04,740
very object driven and imperative it's a

00:29:02,850 --> 00:29:07,919
lot easier for me to suggest that you

00:29:04,740 --> 00:29:09,360
use loops to maintain stack safety but

00:29:07,919 --> 00:29:11,190
that can be hard if you're highly

00:29:09,360 --> 00:29:13,049
invested in functional paradigms and

00:29:11,190 --> 00:29:15,330
that's why things like the free monad

00:29:13,049 --> 00:29:17,160
came into existence if you have a code

00:29:15,330 --> 00:29:19,260
base it's heavily reliant on flat Maps

00:29:17,160 --> 00:29:20,790
it might be easier for you to add

00:29:19,260 --> 00:29:23,400
something like this and it would be to

00:29:20,790 --> 00:29:23,850
tell you to just use a loop but keep in

00:29:23,400 --> 00:29:26,610
mind

00:29:23,850 --> 00:29:29,160
looping can be better if you ever look

00:29:26,610 --> 00:29:31,080
at the Scala standard library a lot of

00:29:29,160 --> 00:29:33,240
the operations on collections there are

00:29:31,080 --> 00:29:36,840
built using a lot of bars and can build

00:29:33,240 --> 00:29:38,880
from it turns out looping and mutating

00:29:36,840 --> 00:29:41,580
state is more efficient and that's why

00:29:38,880 --> 00:29:45,000
the Scala standard library has optimized

00:29:41,580 --> 00:29:48,330
this for us this is ugly but it's a good

00:29:45,000 --> 00:29:54,210
extraction and I'm grateful because now

00:29:48,330 --> 00:29:56,549
we don't have to think about it so a

00:29:54,210 --> 00:29:58,770
side note Munnar speaks a lot about free

00:29:56,549 --> 00:30:00,150
monads talks a lot about them writes a

00:29:58,770 --> 00:30:01,850
lot about them in Scala and it's really

00:30:00,150 --> 00:30:04,830
useful stuff and was useful for me

00:30:01,850 --> 00:30:07,110
preparing this presentation but a lot of

00:30:04,830 --> 00:30:14,790
his presentations too he'll preface it

00:30:07,110 --> 00:30:16,890
by saying this stuff is just for fun so

00:30:14,790 --> 00:30:19,410
we can talk about alternatives for

00:30:16,890 --> 00:30:22,080
managing side-effects you can use other

00:30:19,410 --> 00:30:25,140
built-in monads in the language option

00:30:22,080 --> 00:30:27,990
either and you can error handle over

00:30:25,140 --> 00:30:29,940
exception prone cold keep in mind you

00:30:27,990 --> 00:30:32,340
might not want to suppress all of your

00:30:29,940 --> 00:30:34,950
side-effects things like logging are

00:30:32,340 --> 00:30:36,660
really helpful and if you have a free

00:30:34,950 --> 00:30:38,400
monad you're not going to see any of

00:30:36,660 --> 00:30:41,760
your logs until the very end which is

00:30:38,400 --> 00:30:43,770
annoying and then I wanted to mention a

00:30:41,760 --> 00:30:46,200
project that was talked about it last

00:30:43,770 --> 00:30:48,059
year Scala by the Bay Rob Norris talked

00:30:46,200 --> 00:30:50,669
about his project called Dubey it's a

00:30:48,059 --> 00:30:54,179
free monad abstraction layer on top of

00:30:50,669 --> 00:30:57,660
the JDBC it allows you to chain

00:30:54,179 --> 00:30:59,400
operations together using JDBC code so

00:30:57,660 --> 00:31:02,850
his argument is that there's too many

00:30:59,400 --> 00:31:04,740
problems with code like this he talks

00:31:02,850 --> 00:31:06,780
about the result set there's a lifetime

00:31:04,740 --> 00:31:08,070
managed object you could leak it by

00:31:06,780 --> 00:31:10,859
assigning it to a var

00:31:08,070 --> 00:31:13,470
and then the operations on the results

00:31:10,859 --> 00:31:16,919
that they call side effects they might

00:31:13,470 --> 00:31:19,950
throw exceptions it's not safe and

00:31:16,919 --> 00:31:22,289
that's all true but the only way to deal

00:31:19,950 --> 00:31:25,889
with it is not to use free monads

00:31:22,289 --> 00:31:28,320
there's other ways first don't assign

00:31:25,889 --> 00:31:30,720
results that's of ours and error

00:31:28,320 --> 00:31:32,460
handling is good but Martineau darsky

00:31:30,720 --> 00:31:35,299
probably isn't going to smite you if you

00:31:32,460 --> 00:31:37,649
throw some code into a try accept block

00:31:35,299 --> 00:31:40,229
so here's an example of some code that I

00:31:37,649 --> 00:31:42,629
wrote a couple months ago you can't

00:31:40,229 --> 00:31:45,929
chain it and I'm aware of that but it

00:31:42,629 --> 00:31:47,820
does its job to handle exceptions and it

00:31:45,929 --> 00:31:50,399
was a pretty easy fix for an internal

00:31:47,820 --> 00:31:53,309
service of ours that we just wanted to

00:31:50,399 --> 00:31:54,690
suppress the errors that were coming

00:31:53,309 --> 00:31:57,320
from some sequel code that we were

00:31:54,690 --> 00:32:01,470
writing we didn't want to be surfacing

00:31:57,320 --> 00:32:02,729
stack errors for internal services and

00:32:01,470 --> 00:32:05,369
so this worked and it was an easy

00:32:02,729 --> 00:32:07,289
solution to a production service that

00:32:05,369 --> 00:32:10,340
was otherwise pretty stable we didn't

00:32:07,289 --> 00:32:10,340
want to invest a lot in it

00:32:10,729 --> 00:32:14,759
this stuff is all about trade-offs if

00:32:13,229 --> 00:32:16,349
there's an easy way to make something

00:32:14,759 --> 00:32:19,349
more functional I'm usually going to

00:32:16,349 --> 00:32:25,559
take that but keep in mind your domain

00:32:19,349 --> 00:32:28,710
so now we can talk about some of the

00:32:25,559 --> 00:32:31,200
real practical use cases that we see of

00:32:28,710 --> 00:32:33,419
this if you are going to be using the

00:32:31,200 --> 00:32:37,349
free monad you don't have to implement

00:32:33,419 --> 00:32:39,119
this yourself Scala's add and cats are

00:32:37,349 --> 00:32:40,889
both functional programming language

00:32:39,119 --> 00:32:42,809
libraries for Scala that you might be

00:32:40,889 --> 00:32:44,429
familiar with these both have

00:32:42,809 --> 00:32:46,229
implementations of the free monad

00:32:44,429 --> 00:32:48,059
built-in and a lot of other data

00:32:46,229 --> 00:32:49,889
structures that use the free monad

00:32:48,059 --> 00:32:52,080
underneath we can talk about that in a

00:32:49,889 --> 00:32:53,399
bit but again if this is something that

00:32:52,080 --> 00:32:54,899
you want to play around with or you're

00:32:53,399 --> 00:32:56,519
interested in learning more about you

00:32:54,899 --> 00:32:59,629
can see how these libraries have

00:32:56,519 --> 00:32:59,629
implemented this code

00:33:02,490 --> 00:33:06,990
so other examples of people that are

00:33:04,860 --> 00:33:09,480
actually using this I talked about Dubey

00:33:06,990 --> 00:33:11,670
for all of my talk of alternatives it's

00:33:09,480 --> 00:33:13,620
a pretty good library the abstractions

00:33:11,670 --> 00:33:15,030
are really clean and Rob Norris seems

00:33:13,620 --> 00:33:16,710
like a nice guy so if you have any

00:33:15,030 --> 00:33:20,510
questions I'm volunteering him to help

00:33:16,710 --> 00:33:23,280
you out and then we can talk about

00:33:20,510 --> 00:33:25,650
Scalzi's concurrent tasks this is

00:33:23,280 --> 00:33:28,110
something that's pretty common used for

00:33:25,650 --> 00:33:31,020
concurrent programming multi-threading

00:33:28,110 --> 00:33:35,370
here's an example of how we use it to in

00:33:31,020 --> 00:33:37,920
queue messages to Amazon SQS and this is

00:33:35,370 --> 00:33:39,840
really useful and it uses a free monad

00:33:37,920 --> 00:33:42,300
underneath nothing is happening until

00:33:39,840 --> 00:33:43,980
you do that attempt run it's just

00:33:42,300 --> 00:33:49,740
building up a data structure underneath

00:33:43,980 --> 00:33:51,600
trampolining it on its attempt this is a

00:33:49,740 --> 00:33:53,880
clean abstraction and I'm really

00:33:51,600 --> 00:33:57,000
grateful for it because underneath it

00:33:53,880 --> 00:34:00,900
looks something like this and that's

00:33:57,000 --> 00:34:02,760
just the object instantiation you might

00:34:00,900 --> 00:34:04,020
love working with type lambdas but I

00:34:02,760 --> 00:34:06,450
don't want to have to think about that

00:34:04,020 --> 00:34:07,770
during my daily job and this is a type

00:34:06,450 --> 00:34:12,120
of code that motivated this talk

00:34:07,770 --> 00:34:15,000
somewhat from a place of pessimism so

00:34:12,120 --> 00:34:17,550
what happened with my experience so

00:34:15,000 --> 00:34:19,140
shortly after the co-worker suggested

00:34:17,550 --> 00:34:23,960
that we solve our stack overflow errors

00:34:19,140 --> 00:34:23,960
by using free monads he left the company

00:34:24,680 --> 00:34:29,820
we refactored some recursion and never

00:34:27,960 --> 00:34:32,220
added a free monad to that codebase and

00:34:29,820 --> 00:34:33,810
that was good because at that time we

00:34:32,220 --> 00:34:36,870
were writing a back-end to a pretty

00:34:33,810 --> 00:34:38,550
basic web app and in our case even

00:34:36,870 --> 00:34:41,160
though we were using a lot of monadic

00:34:38,550 --> 00:34:43,050
code stack overflow errors meant that we

00:34:41,160 --> 00:34:45,420
had grossly over complicated something

00:34:43,050 --> 00:34:47,040
in our business logic I understand some

00:34:45,420 --> 00:34:49,170
of you might have large-scale problems

00:34:47,040 --> 00:34:52,410
that necessitate these kinds of

00:34:49,170 --> 00:34:55,080
abstractions but in that situation we

00:34:52,410 --> 00:34:56,820
could avoid it and then there's that

00:34:55,080 --> 00:35:00,030
datastore application that no one ever

00:34:56,820 --> 00:35:01,620
wants to touch and after doing a lot of

00:35:00,030 --> 00:35:03,420
this research in the last year I

00:35:01,620 --> 00:35:06,150
concluded the issues with that program

00:35:03,420 --> 00:35:07,590
we're not related to the factor semi

00:35:06,150 --> 00:35:09,690
unrelated to the fact that I use the

00:35:07,590 --> 00:35:11,340
free monad it was definitely over

00:35:09,690 --> 00:35:13,080
engineered though and I think that's

00:35:11,340 --> 00:35:15,530
part of the problem with abstractions

00:35:13,080 --> 00:35:19,190
like this it's really easy to over end

00:35:15,530 --> 00:35:20,900
near using these things we have to keep

00:35:19,190 --> 00:35:23,150
in mind most of us are getting paid by a

00:35:20,900 --> 00:35:26,540
company that's trying to use us to make

00:35:23,150 --> 00:35:28,400
money and like I said about a lot of us

00:35:26,540 --> 00:35:30,140
don't have these large scale problems

00:35:28,400 --> 00:35:35,170
that necessitate these kinds of

00:35:30,140 --> 00:35:35,170
abstractions so again know your domain

00:35:35,920 --> 00:35:40,730
after talking to a lot of people about

00:35:38,720 --> 00:35:42,530
the free monad I'm still not convinced

00:35:40,730 --> 00:35:44,450
it's the best solution you do find this

00:35:42,530 --> 00:35:46,340
in production in certain circumstances

00:35:44,450 --> 00:35:49,460
but it's mostly abstracted away in

00:35:46,340 --> 00:35:51,530
library code and that's okay and I can

00:35:49,460 --> 00:35:53,420
see how it does make those libraries

00:35:51,530 --> 00:35:55,970
composable and safe and maybe why

00:35:53,420 --> 00:35:57,980
certain things like doobie and Scala

00:35:55,970 --> 00:36:02,360
Zedd are using it under the hood to

00:35:57,980 --> 00:36:02,990
optimize if you're a fan of the free

00:36:02,360 --> 00:36:05,000
monad

00:36:02,990 --> 00:36:07,370
let's talk I'd love to hear how you're

00:36:05,000 --> 00:36:08,990
using it just last week Chris Myers gave

00:36:07,370 --> 00:36:13,070
a talk at flatmap özil it was anyone

00:36:08,990 --> 00:36:15,080
there maybe so I would like to see that

00:36:13,070 --> 00:36:17,240
talk and see how his team has used it

00:36:15,080 --> 00:36:19,340
because he said it's made kids novice

00:36:17,240 --> 00:36:20,780
teams productive I don't know if I buy

00:36:19,340 --> 00:36:24,590
that but I'm interested to see what he

00:36:20,780 --> 00:36:26,540
said it all comes down to the fact that

00:36:24,590 --> 00:36:28,910
we have to be judicious in our use of

00:36:26,540 --> 00:36:31,820
these abstractions just because we can

00:36:28,910 --> 00:36:34,250
doesn't mean we should this comes down

00:36:31,820 --> 00:36:36,170
to that principle of least power that

00:36:34,250 --> 00:36:37,970
Martin orders he was talking about at

00:36:36,170 --> 00:36:39,350
the keynote last night we want to make

00:36:37,970 --> 00:36:41,660
sure that we use the least powerful

00:36:39,350 --> 00:36:45,110
solution the free monad is definitely

00:36:41,660 --> 00:36:46,760
not that sometimes it's okay to trade

00:36:45,110 --> 00:36:49,400
the most functional style for both the

00:36:46,760 --> 00:36:53,480
sanity of your code and the sanity of

00:36:49,400 --> 00:36:55,670
your team I used to think the free monad

00:36:53,480 --> 00:36:58,490
was pretty awful I don't think that's

00:36:55,670 --> 00:37:00,890
true anymore but if you're like me about

00:36:58,490 --> 00:37:03,140
a year ago and someone is talking about

00:37:00,890 --> 00:37:05,210
introducing this into your codebase I

00:37:03,140 --> 00:37:06,890
hope I've given you some tools to

00:37:05,210 --> 00:37:10,790
evaluate whether or not that's a good

00:37:06,890 --> 00:37:12,530
idea once again my name is Kelly

00:37:10,790 --> 00:37:15,790
Robinson here's my contact information

00:37:12,530 --> 00:37:15,790
and thank you for listening

00:37:23,569 --> 00:38:05,430
questions no we haven't cuz no one wants

00:38:02,160 --> 00:38:06,930
to touch that codebase but that's good

00:38:05,430 --> 00:38:08,520
to know it's useful because these things

00:38:06,930 --> 00:38:10,170
are always being developed and we want

00:38:08,520 --> 00:38:12,119
to use them and that's why the libraries

00:38:10,170 --> 00:38:13,589
are making these abstractions more

00:38:12,119 --> 00:38:24,540
useful and so that's that's great to

00:38:13,589 --> 00:38:26,730
know that I don't know how we're doing

00:38:24,540 --> 00:38:28,349
it or we did it in that program actually

00:38:26,730 --> 00:38:29,609
I think we were writing on specific

00:38:28,349 --> 00:38:30,900
implementations of the natural

00:38:29,609 --> 00:38:32,490
transformation because the other thing

00:38:30,900 --> 00:38:33,990
that you can do is you don't have to do

00:38:32,490 --> 00:38:35,280
this with natural transformations you

00:38:33,990 --> 00:38:38,150
would just have to have a non-generic

00:38:35,280 --> 00:38:38,150
run function

00:39:26,330 --> 00:39:30,770
first let me thank you for the I think

00:39:28,880 --> 00:39:33,770
the clearest explanation of these

00:39:30,770 --> 00:39:42,260
concepts that I've ever seen it was high

00:39:33,770 --> 00:39:44,090
praise second when I saw the title of

00:39:42,260 --> 00:39:48,800
the talk I thought you were also talking

00:39:44,090 --> 00:39:51,260
about the runtime costs because I never

00:39:48,800 --> 00:39:52,940
measured these things but my suspicion

00:39:51,260 --> 00:39:55,070
is that once you go jump through the

00:39:52,940 --> 00:39:57,530
hoops of a free Mona you lose one to two

00:39:55,070 --> 00:40:00,740
orders of magnitude and performance have

00:39:57,530 --> 00:40:03,290
you any experience or data that could

00:40:00,740 --> 00:40:05,330
corroborate that claim or contradicted

00:40:03,290 --> 00:40:06,890
so I was wondering about that too and it

00:40:05,330 --> 00:40:08,270
wasn't something I got around to but it

00:40:06,890 --> 00:40:09,950
was something I was interested in seeing

00:40:08,270 --> 00:40:12,470
if we wrote similar code using like the

00:40:09,950 --> 00:40:14,090
JDBC then the Dubey implementation and I

00:40:12,470 --> 00:40:15,830
think it would see it would depend on

00:40:14,090 --> 00:40:18,140
how the implementation was run I mean

00:40:15,830 --> 00:40:19,850
like I mentioned the Scala standard

00:40:18,140 --> 00:40:22,160
library optimizes a lot of this using

00:40:19,850 --> 00:40:24,680
loops and so some of it might be faster

00:40:22,160 --> 00:40:26,510
but no I don't I don't have the data for

00:40:24,680 --> 00:40:27,830
that okay I guess if you deal with

00:40:26,510 --> 00:40:29,960
database code it probably wouldn't

00:40:27,830 --> 00:40:40,330
matter if that's just your intensive

00:40:29,960 --> 00:40:40,330
yeah yeah anyone else thank you

00:40:43,760 --> 00:40:45,820

YouTube URL: https://www.youtube.com/watch?v=U0lK0hnbc4U


