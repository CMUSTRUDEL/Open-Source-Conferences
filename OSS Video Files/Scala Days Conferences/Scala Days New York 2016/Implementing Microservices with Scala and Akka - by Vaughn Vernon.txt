Title: Implementing Microservices with Scala and Akka - by Vaughn Vernon
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
What are microservices all about, and are they practical for your enterprise? How granular should a microservice be, and what approach should you use to determine the proper and appropriate boundaries between microservices? How can each microservice communicate with others in a distributed computing environment to correctly fulfill business objectives? How can my microservices adhere to the tenets of reactive software, being responsive, resilient, elastic, and message driven? Using Scala and Akka to implement microservices, this talk will demonstrate how you can implement microservices while answering all of the questions posed, and more. The talk will show you how to carefully craft microservices and to model the business domain within. You will experience advanced use of Akka throughout.
Captions: 
	00:00:00,180 --> 00:00:05,540
so I'm the author of this book maybe

00:00:02,610 --> 00:00:08,370
you've seen it before if not it is about

00:00:05,540 --> 00:00:11,219
implementing domain-driven design it's

00:00:08,370 --> 00:00:13,919
goes beyond theory but helps you to put

00:00:11,219 --> 00:00:17,490
into practice domain driven design I'm

00:00:13,919 --> 00:00:19,259
also the author of this book reactive

00:00:17,490 --> 00:00:22,710
messaging patterns with the actor model

00:00:19,259 --> 00:00:25,259
it's a Scala Anaka book that basically

00:00:22,710 --> 00:00:28,980
takes the integration or the enterprise

00:00:25,259 --> 00:00:34,620
integration patterns and implements

00:00:28,980 --> 00:00:37,490
those in akka and Scala and my latest

00:00:34,620 --> 00:00:41,100
book which will be out in a few weeks is

00:00:37,490 --> 00:00:44,610
domain driven design distilled so a lot

00:00:41,100 --> 00:00:47,850
of people have had trouble grasping

00:00:44,610 --> 00:00:50,130
domain driven design you know in a six

00:00:47,850 --> 00:00:53,990
to eight hundred page book so this book

00:00:50,130 --> 00:00:58,790
is meant to give you a very practical

00:00:53,990 --> 00:01:01,740
approach to using domain driven design

00:00:58,790 --> 00:01:05,309
to start off with I just wanted to say

00:01:01,740 --> 00:01:08,940
that I think oftentimes we are in an

00:01:05,309 --> 00:01:13,260
industry of extremes what do I mean by

00:01:08,940 --> 00:01:16,409
that it seems like we kind of latch on

00:01:13,260 --> 00:01:20,280
to an idea and we take things to an

00:01:16,409 --> 00:01:23,220
extreme where we should really use

00:01:20,280 --> 00:01:29,300
things in a more moderate way here's an

00:01:23,220 --> 00:01:32,909
example acid everybody has come to

00:01:29,300 --> 00:01:36,600
respect that acid transactions are

00:01:32,909 --> 00:01:40,170
something that are very useful on the

00:01:36,600 --> 00:01:43,560
other hand should everything be acid in

00:01:40,170 --> 00:01:48,270
fact should we use XA or two-phase

00:01:43,560 --> 00:01:51,840
commit and try to make our systems be in

00:01:48,270 --> 00:01:55,920
harmony with one another in what appears

00:01:51,840 --> 00:02:00,000
to be an acid transaction when you think

00:01:55,920 --> 00:02:06,229
about it what was life like what was

00:02:00,000 --> 00:02:06,229
business like before acid transactions

00:02:07,310 --> 00:02:15,470
how do businesses work people had a

00:02:10,760 --> 00:02:18,630
wooden or metal inbox on their desk

00:02:15,470 --> 00:02:21,599
we're folders or papers were dropped

00:02:18,630 --> 00:02:28,620
into and whenever that person got around

00:02:21,599 --> 00:02:33,330
to approving something or finishing some

00:02:28,620 --> 00:02:36,390
work and a workflow it could take not

00:02:33,330 --> 00:02:41,459
only minutes but hours or even days

00:02:36,390 --> 00:02:46,800
sometimes for transactions to be

00:02:41,459 --> 00:02:51,720
completed so ask yourself do we really

00:02:46,800 --> 00:02:57,380
need acid transactions or transactional

00:02:51,720 --> 00:02:59,670
integrity around everything actually

00:02:57,380 --> 00:03:06,510
everything used to be eventually

00:02:59,670 --> 00:03:10,410
consistent and today many things can

00:03:06,510 --> 00:03:15,260
actually be eventually consistent who do

00:03:10,410 --> 00:03:18,299
you think is or are the correct

00:03:15,260 --> 00:03:20,340
individuals to determine whether

00:03:18,299 --> 00:03:24,799
something can be eventually consistent

00:03:20,340 --> 00:03:30,650
or must be acid transactionally

00:03:24,799 --> 00:03:35,780
consistent who do we ask any ideas who

00:03:30,650 --> 00:03:39,810
humans but do we ask the programmers

00:03:35,780 --> 00:03:42,930
domain experts good so it's really the

00:03:39,810 --> 00:03:45,750
business that knows whether something

00:03:42,930 --> 00:03:48,660
must be transactionally consistent or if

00:03:45,750 --> 00:03:52,769
it can be eventually consistent so we

00:03:48,660 --> 00:03:56,040
ask the business and oftentimes we can

00:03:52,769 --> 00:03:59,280
reason with the business around eventual

00:03:56,040 --> 00:04:02,579
consistency and especially if we can

00:03:59,280 --> 00:04:04,859
show them that if we try to make

00:04:02,579 --> 00:04:07,170
something transactionally consistent it

00:04:04,859 --> 00:04:11,549
could be a bad thing we could actually

00:04:07,170 --> 00:04:14,340
cause failure on other transactions or

00:04:11,549 --> 00:04:17,459
our own transaction if we try to make

00:04:14,340 --> 00:04:20,150
everything in the system consistent and

00:04:17,459 --> 00:04:24,650
in harmony all at once

00:04:20,150 --> 00:04:28,520
here's another extreme that I see

00:04:24,650 --> 00:04:31,740
monolith or micro service

00:04:28,520 --> 00:04:35,400
often times companies will live and die

00:04:31,740 --> 00:04:37,320
by the monolith actually there may not

00:04:35,400 --> 00:04:42,020
be anything wrong with the monolith in

00:04:37,320 --> 00:04:46,740
some cases but should we be using

00:04:42,020 --> 00:04:49,520
micro-services and if we do what is your

00:04:46,740 --> 00:04:53,130
definition of a micro service

00:04:49,520 --> 00:04:56,220
how big is a micro service

00:04:53,130 --> 00:04:58,950
how big is a monolith is there some way

00:04:56,220 --> 00:05:06,480
to find a practical balance between

00:04:58,950 --> 00:05:10,950
monolith and micro service so oftentimes

00:05:06,480 --> 00:05:16,440
a monolith will turn into what's called

00:05:10,950 --> 00:05:19,410
a big ball of mud and a big ball of mud

00:05:16,440 --> 00:05:21,260
does not have to be formed over years

00:05:19,410 --> 00:05:27,090
and years of time it can actually happen

00:05:21,260 --> 00:05:31,800
within weeks or months this is where you

00:05:27,090 --> 00:05:37,410
have multiple domain models that should

00:05:31,800 --> 00:05:42,630
be separated but instead are all tangled

00:05:37,410 --> 00:05:45,840
together in one place to the point where

00:05:42,630 --> 00:05:50,970
you can't even distinguish where your

00:05:45,840 --> 00:05:55,650
domain models are separate within this

00:05:50,970 --> 00:05:59,040
one monolith application and to the

00:05:55,650 --> 00:06:02,580
point where you can't actually make

00:05:59,040 --> 00:06:07,230
logical sense of the code when

00:06:02,580 --> 00:06:10,350
considering it in the mindset or the

00:06:07,230 --> 00:06:15,570
mental model of the business business

00:06:10,350 --> 00:06:18,210
experts so a big ball of mud is not only

00:06:15,570 --> 00:06:21,240
a monolith but it's worse than a

00:06:18,210 --> 00:06:28,980
monolith because you actually can model

00:06:21,240 --> 00:06:33,510
a monolith in a respectable way but what

00:06:28,980 --> 00:06:34,560
about micro services what is the size of

00:06:33,510 --> 00:06:38,750
a micro Service

00:06:34,560 --> 00:06:40,770
how many micro services should there be

00:06:38,750 --> 00:06:42,230
do you know what these numbers have

00:06:40,770 --> 00:06:45,320
income

00:06:42,230 --> 00:06:49,520
one hundred four hundred and a thousand

00:06:45,320 --> 00:06:51,980
these are actually all line counts of

00:06:49,520 --> 00:06:55,440
microservices that I've seen or heard

00:06:51,980 --> 00:06:57,450
defined some people will say there

00:06:55,440 --> 00:07:00,600
should be no more than one hundred lines

00:06:57,450 --> 00:07:02,310
of code in a micro-service there should

00:07:00,600 --> 00:07:04,980
be no more than four hundred lines of

00:07:02,310 --> 00:07:07,710
code in a micro-service there should be

00:07:04,980 --> 00:07:15,540
no more than one thousand lines of code

00:07:07,710 --> 00:07:22,190
in a micro service whose correct so it's

00:07:15,540 --> 00:07:24,660
an interesting proposal now someone

00:07:22,190 --> 00:07:28,110
named Fred George who hears heard of

00:07:24,660 --> 00:07:30,260
Fred George he's actually many of you

00:07:28,110 --> 00:07:34,500
haven't heard of them he's actually

00:07:30,260 --> 00:07:37,380
credited or credits himself with coming

00:07:34,500 --> 00:07:41,310
up with the idea of the modern-day micro

00:07:37,380 --> 00:07:45,000
service so he was working in monolith

00:07:41,310 --> 00:07:47,160
land for quite a long time in fact he

00:07:45,000 --> 00:07:52,560
says that he was working on one of the

00:07:47,160 --> 00:07:53,600
largest JE applications on the earth on

00:07:52,560 --> 00:07:57,900
the planet

00:07:53,600 --> 00:08:01,140
but after that he got into what he

00:07:57,900 --> 00:08:04,950
termed were micro services and you can

00:08:01,140 --> 00:08:11,430
watch Fred George's presentation here on

00:08:04,950 --> 00:08:15,480
on Vimeo at this URI and what Fred

00:08:11,430 --> 00:08:20,310
George says there is that one page of

00:08:15,480 --> 00:08:24,390
code makes a good micro service now if

00:08:20,310 --> 00:08:27,000
we think about pages in old terms like

00:08:24,390 --> 00:08:34,440
what I remember what was that sixty two

00:08:27,000 --> 00:08:39,390
lines of code 65 Oh what was it 25 25

00:08:34,440 --> 00:08:41,760
page 25 line page okay maybe anyway it's

00:08:39,390 --> 00:08:43,890
hard to even define how big a micro

00:08:41,760 --> 00:08:46,260
service should be by this definition

00:08:43,890 --> 00:08:49,230
because even within this room we have

00:08:46,260 --> 00:08:52,820
different definitions of what is a page

00:08:49,230 --> 00:08:56,110
of code so

00:08:52,820 --> 00:09:00,140
how many microservices should we have

00:08:56,110 --> 00:09:02,440
how big should a microservice be what

00:09:00,140 --> 00:09:06,380
I'm going to do today is give you a

00:09:02,440 --> 00:09:08,330
prescriptive approach to doing this and

00:09:06,380 --> 00:09:12,380
one approach that you may want to

00:09:08,330 --> 00:09:15,140
consider or even use if you look again

00:09:12,380 --> 00:09:18,380
at Fred George's definition of

00:09:15,140 --> 00:09:21,800
micro-service he says that in some of

00:09:18,380 --> 00:09:24,230
the enterprises where he has worked and

00:09:21,800 --> 00:09:28,250
created micro services that they

00:09:24,230 --> 00:09:34,700
actually have many even an untold number

00:09:28,250 --> 00:09:38,390
or unidentified set of services that no

00:09:34,700 --> 00:09:40,880
one even knows are running they actually

00:09:38,390 --> 00:09:45,350
just leave them out there whether they

00:09:40,880 --> 00:09:47,750
still have any purpose or not and Fred

00:09:45,350 --> 00:09:50,840
George says that it only costs the

00:09:47,750 --> 00:09:52,460
company about 40 dollars a month to

00:09:50,840 --> 00:09:55,310
leave those services running so why

00:09:52,460 --> 00:09:58,610
bother why bother looking now to me

00:09:55,310 --> 00:10:02,540
that's a problem I don't like not

00:09:58,610 --> 00:10:06,100
knowing what's running I don't like even

00:10:02,540 --> 00:10:09,380
the thought of not caring what's running

00:10:06,100 --> 00:10:13,090
because it could have consequences also

00:10:09,380 --> 00:10:16,640
when we think about infrastructure

00:10:13,090 --> 00:10:20,030
infrastructure can have a really big

00:10:16,640 --> 00:10:24,650
impact on how many micro services we

00:10:20,030 --> 00:10:31,600
want to run think about having a cluster

00:10:24,650 --> 00:10:37,310
of servers to run a single entity and

00:10:31,600 --> 00:10:40,670
that is what those such as Fred George

00:10:37,310 --> 00:10:44,030
recommend if I have 100 lines of code

00:10:40,670 --> 00:10:50,270
for a micro service those micro services

00:10:44,030 --> 00:10:52,580
are going to need to be resilient we're

00:10:50,270 --> 00:10:57,020
going to have to be able to recover

00:10:52,580 --> 00:10:59,950
under failure if a service fails or

00:10:57,020 --> 00:11:03,320
various other things how many clusters

00:10:59,950 --> 00:11:04,220
could you actually have running in an

00:11:03,320 --> 00:11:06,769
enterprise

00:11:04,220 --> 00:11:10,519
if you define your micros

00:11:06,769 --> 00:11:13,970
services like this so what do you think

00:11:10,519 --> 00:11:17,600
is a practical way to measure the size

00:11:13,970 --> 00:11:21,290
of a micro service what I am going to do

00:11:17,600 --> 00:11:24,439
is talk to you about what domain-driven

00:11:21,290 --> 00:11:29,230
design offers regarding the size of

00:11:24,439 --> 00:11:32,019
micro services and in specific or

00:11:29,230 --> 00:11:34,999
specifically I'm going to talk about

00:11:32,019 --> 00:11:37,579
bounded context how many of you here are

00:11:34,999 --> 00:11:40,399
at least somewhat familiar with what a

00:11:37,579 --> 00:11:48,730
DDD bounded context is hey excellent

00:11:40,399 --> 00:11:53,329
good probably about half now even within

00:11:48,730 --> 00:11:57,230
the micro services community there is

00:11:53,329 --> 00:11:59,569
the use of this term bounded context but

00:11:57,230 --> 00:12:03,679
I want to make clear that it is not

00:11:59,569 --> 00:12:08,179
always used in the way that domain

00:12:03,679 --> 00:12:11,990
driven design means that pattern to or

00:12:08,179 --> 00:12:15,920
defines that pattern to me and what I'm

00:12:11,990 --> 00:12:19,279
saying by that is again some will say

00:12:15,920 --> 00:12:21,860
that a single entity a single concept

00:12:19,279 --> 00:12:25,160
such as product let's just take the

00:12:21,860 --> 00:12:29,059
concept concept of a product that that

00:12:25,160 --> 00:12:35,029
product is actually in its own bounded

00:12:29,059 --> 00:12:40,610
context okay it could be but it shares

00:12:35,029 --> 00:12:44,480
no other linguistic conceptual ideas

00:12:40,610 --> 00:12:51,049
with any other thing in your enterprise

00:12:44,480 --> 00:12:53,569
I would say that that's questionable so

00:12:51,049 --> 00:12:56,709
when I talk about building micro

00:12:53,569 --> 00:13:00,189
services using bounded context I'm

00:12:56,709 --> 00:13:02,869
roughly referring to what Sam Newman

00:13:00,189 --> 00:13:06,319
describes in his book building micro

00:13:02,869 --> 00:13:10,160
services he does in his book talk about

00:13:06,319 --> 00:13:13,639
using true domain driven design bounded

00:13:10,160 --> 00:13:18,319
context and so what is the size of a

00:13:13,639 --> 00:13:19,690
bounded context any ideas is it just one

00:13:18,319 --> 00:13:23,450
entity

00:13:19,690 --> 00:13:26,630
do you know how we know what the bounded

00:13:23,450 --> 00:13:32,090
context holds we have to ask our

00:13:26,630 --> 00:13:37,160
ubiquitous language we can't we can't

00:13:32,090 --> 00:13:40,520
say specifically that a bounded context

00:13:37,160 --> 00:13:43,640
has just one entity or five entities or

00:13:40,520 --> 00:13:46,520
ten entities it really depends it

00:13:43,640 --> 00:13:51,260
depends on the ubiquitous language and

00:13:46,520 --> 00:13:58,130
so that's the other idea that I'm

00:13:51,260 --> 00:14:02,210
promoting today is model micro-services

00:13:58,130 --> 00:14:06,230
in a bounded context that is determined

00:14:02,210 --> 00:14:12,290
in size by how big the ubiquitous

00:14:06,230 --> 00:14:16,550
languages linguistic components are

00:14:12,290 --> 00:14:20,720
cohesive and therefore I think that many

00:14:16,550 --> 00:14:22,670
times within a bounded context while you

00:14:20,720 --> 00:14:25,570
can think of the components within that

00:14:22,670 --> 00:14:31,000
bounded context as being in themselves

00:14:25,570 --> 00:14:31,000
microservices and actors for that matter

00:14:31,030 --> 00:14:36,100
we probably would not want to separate

00:14:34,070 --> 00:14:39,830
those because they have a natural

00:14:36,100 --> 00:14:44,930
cohesiveness where they collaborate

00:14:39,830 --> 00:14:50,680
together in some way so let's take an

00:14:44,930 --> 00:14:54,680
example this is what I would call a

00:14:50,680 --> 00:14:57,890
fairly reasonably sized bounded context

00:14:54,680 --> 00:15:00,590
because it addresses the ubiquitous

00:14:57,890 --> 00:15:03,350
language of scrum and if you've looked

00:15:00,590 --> 00:15:09,200
at my implementing domain-driven design

00:15:03,350 --> 00:15:12,100
book you're somewhat familiar with the

00:15:09,200 --> 00:15:17,630
concepts of this specific domain model

00:15:12,100 --> 00:15:19,820
product backlog item release sprint teen

00:15:17,630 --> 00:15:22,970
team member and product owner these are

00:15:19,820 --> 00:15:26,720
the concepts within the ubiquitous

00:15:22,970 --> 00:15:32,410
language of scrum we have a set of

00:15:26,720 --> 00:15:36,449
abstractions that represent the concepts

00:15:32,410 --> 00:15:40,629
of a scrum based application or a

00:15:36,449 --> 00:15:43,050
project management tool and so if you

00:15:40,629 --> 00:15:50,050
think about a micro service as being

00:15:43,050 --> 00:15:52,240
this size it can really be practical but

00:15:50,050 --> 00:15:54,939
we aren't talking about creating a

00:15:52,240 --> 00:15:58,120
monolith in any way because actually in

00:15:54,939 --> 00:16:01,180
this case we see that we have four micro

00:15:58,120 --> 00:16:05,290
services or for bounded contexts that

00:16:01,180 --> 00:16:08,439
are interacting in some way and each of

00:16:05,290 --> 00:16:10,810
them are addressing a specific part of

00:16:08,439 --> 00:16:13,589
the business that needs to be addressed

00:16:10,810 --> 00:16:16,810
so we have the agile project management

00:16:13,589 --> 00:16:18,879
context that's the scrum based system

00:16:16,810 --> 00:16:22,269
that I spoke about we have a different

00:16:18,879 --> 00:16:25,420
ubiquitous language for collaboration we

00:16:22,269 --> 00:16:28,269
have an issue tracker context and an

00:16:25,420 --> 00:16:31,329
identity and access context for

00:16:28,269 --> 00:16:34,569
different micro services for different

00:16:31,329 --> 00:16:39,069
bounded contexts now think about this

00:16:34,569 --> 00:16:42,370
for a moment let's add a fifth micro

00:16:39,069 --> 00:16:45,399
service into this mix and count how many

00:16:42,370 --> 00:16:50,910
entities are in each of those bounded

00:16:45,399 --> 00:16:53,889
contexts or micro services actually it's

00:16:50,910 --> 00:16:57,009
35 different entities if you were to

00:16:53,889 --> 00:17:05,110
count them now how many here would like

00:16:57,009 --> 00:17:08,350
to have 35 deployed cluster units to

00:17:05,110 --> 00:17:10,120
represent your micro services or how

00:17:08,350 --> 00:17:13,620
many of you would rather deal with five

00:17:10,120 --> 00:17:15,970
can I see the vote for five versus 35

00:17:13,620 --> 00:17:19,360
okay fair enough

00:17:15,970 --> 00:17:23,470
I think that's a good conclusion to

00:17:19,360 --> 00:17:27,970
reach so what I am proposing is that at

00:17:23,470 --> 00:17:31,270
least to get yourself started with micro

00:17:27,970 --> 00:17:34,450
services use bounded context you'll

00:17:31,270 --> 00:17:37,390
probably find that bounded context works

00:17:34,450 --> 00:17:40,659
very well in general for the long term

00:17:37,390 --> 00:17:42,429
for micro services but if you find you

00:17:40,659 --> 00:17:46,230
know that that you're becoming more and

00:17:42,429 --> 00:17:49,140
more comfortable with micro services

00:17:46,230 --> 00:17:51,600
over time and you want to make smaller

00:17:49,140 --> 00:17:54,210
deployment units that's not out of the

00:17:51,600 --> 00:17:57,630
question but I think it's wise to start

00:17:54,210 --> 00:18:00,900
with this granularity to begin with it's

00:17:57,630 --> 00:18:05,780
larger than one entity but it's much

00:18:00,900 --> 00:18:08,730
much much smaller than a monolith

00:18:05,780 --> 00:18:12,780
so the ubiquitous language that I am

00:18:08,730 --> 00:18:17,730
talking about is greater than entity

00:18:12,780 --> 00:18:21,000
names a ubiquitous language is really

00:18:17,730 --> 00:18:23,970
the language that the business comes up

00:18:21,000 --> 00:18:27,830
with and that developers help the

00:18:23,970 --> 00:18:33,320
business refine in a close-knit team and

00:18:27,830 --> 00:18:36,780
so a ubiquitous language grows it

00:18:33,320 --> 00:18:39,090
expands it contracts over time but it's

00:18:36,780 --> 00:18:43,290
greater than just the entity names it

00:18:39,090 --> 00:18:46,590
includes from a reactive development

00:18:43,290 --> 00:18:50,850
perspective not only the entities but

00:18:46,590 --> 00:18:52,890
also command messages and event messages

00:18:50,850 --> 00:18:58,049
so that's what we're going to talk about

00:18:52,890 --> 00:19:01,940
next is the commands and events that are

00:18:58,049 --> 00:19:05,160
part of the ubiquitous language of scrub

00:19:01,940 --> 00:19:09,780
so we have our product entity we have

00:19:05,160 --> 00:19:12,390
our backlog item entity and we have a

00:19:09,780 --> 00:19:15,450
command message and if you're thinking

00:19:12,390 --> 00:19:20,970
in terms of akka this would literally be

00:19:15,450 --> 00:19:26,340
a message that gets sent to the product

00:19:20,970 --> 00:19:29,960
actor so backlog or a plan backlog item

00:19:26,340 --> 00:19:35,160
would be a case class for example in

00:19:29,960 --> 00:19:39,150
Scala we create an instance of that case

00:19:35,160 --> 00:19:43,830
class we pass the message to the product

00:19:39,150 --> 00:19:48,230
plan backlog item product then emits if

00:19:43,830 --> 00:19:54,150
that is a valid command it emits a

00:19:48,230 --> 00:19:56,700
backlog item planned domain event this

00:19:54,150 --> 00:19:59,300
is part of your ubiquitous language when

00:19:56,700 --> 00:20:06,930
we think about the backlog item

00:19:59,300 --> 00:20:12,090
entity again an actor and we have a case

00:20:06,930 --> 00:20:14,250
class defined tasks an instance of that

00:20:12,090 --> 00:20:18,780
case class is sent to backlog item

00:20:14,250 --> 00:20:23,730
define a task and what that backlog item

00:20:18,780 --> 00:20:26,190
emits is tasks defined domain event so

00:20:23,730 --> 00:20:28,320
this is all part of your ubiquitous

00:20:26,190 --> 00:20:38,850
language this is all within a single

00:20:28,320 --> 00:20:44,300
micro service note to that your micro

00:20:38,850 --> 00:20:48,630
service ie bounded context owns

00:20:44,300 --> 00:20:50,520
databases it owns an event journal so

00:20:48,630 --> 00:20:54,770
those two events that you saw being

00:20:50,520 --> 00:20:54,770
emitted by those two different entities

00:20:56,000 --> 00:21:02,040
those events are being saved into an

00:20:59,700 --> 00:21:04,080
event journal which is a sequential

00:21:02,040 --> 00:21:07,770
journal of all events that have ever

00:21:04,080 --> 00:21:11,790
occurred within that micro service or

00:21:07,770 --> 00:21:15,450
bounded context this makes up the event

00:21:11,790 --> 00:21:22,350
streams and the entire event journal for

00:21:15,450 --> 00:21:23,850
that bounded context over time so this

00:21:22,350 --> 00:21:26,340
is what I'm talking about

00:21:23,850 --> 00:21:32,090
you put events in in the order in which

00:21:26,340 --> 00:21:36,990
they occurred and events can also be

00:21:32,090 --> 00:21:40,530
published out to other micro services so

00:21:36,990 --> 00:21:45,000
that they can function properly we also

00:21:40,530 --> 00:21:51,390
have what's called a query model so this

00:21:45,000 --> 00:21:58,230
view is event sourcing which corresponds

00:21:51,390 --> 00:22:01,620
to akka persistence and then we can take

00:21:58,230 --> 00:22:05,130
the events from our micro service or

00:22:01,620 --> 00:22:08,370
bounded context and create a model that

00:22:05,130 --> 00:22:11,340
is query optimized for the kinds of

00:22:08,370 --> 00:22:12,390
queries that our users and integrating

00:22:11,340 --> 00:22:16,620
service

00:22:12,390 --> 00:22:20,100
is need so again we're talking about

00:22:16,620 --> 00:22:23,550
actors as asynchronous services and if

00:22:20,100 --> 00:22:26,100
you will you can actually architect your

00:22:23,550 --> 00:22:29,460
system in such a way that the actors

00:22:26,100 --> 00:22:34,730
within a single bounded context are like

00:22:29,460 --> 00:22:34,730
many micro-services with it okay

00:22:34,790 --> 00:22:45,300
what I want to emphasize next is to

00:22:38,130 --> 00:22:50,930
never ever ever do this don't ever take

00:22:45,300 --> 00:22:58,890
a request into one like perform some

00:22:50,930 --> 00:23:01,940
transaction with an entity and then send

00:22:58,890 --> 00:23:06,350
a request to another micro service

00:23:01,940 --> 00:23:09,630
because this is trying to mimic XA right

00:23:06,350 --> 00:23:14,700
except it doesn't so if you have a

00:23:09,630 --> 00:23:17,370
failure right here it means that your

00:23:14,700 --> 00:23:19,010
system is out of harmony and that's a

00:23:17,370 --> 00:23:21,630
bad situation to be in

00:23:19,010 --> 00:23:24,360
so what do we want to do well this is

00:23:21,630 --> 00:23:27,810
where I agree with Fred George Fred

00:23:24,360 --> 00:23:31,680
George talks about Rapids rivers and

00:23:27,810 --> 00:23:33,770
ponds Rapids we're going to talk about

00:23:31,680 --> 00:23:36,930
Rapids first what are they

00:23:33,770 --> 00:23:39,690
Rapids is where every single micro

00:23:36,930 --> 00:23:43,050
service in your enterprise publishes

00:23:39,690 --> 00:23:49,110
domain events and all of those domain

00:23:43,050 --> 00:23:52,850
events go into one big bus topic let's

00:23:49,110 --> 00:23:58,230
say think of it as the all topic

00:23:52,850 --> 00:24:01,950
everything goes in there and then so it

00:23:58,230 --> 00:24:05,190
kind of looks like this we have a micro

00:24:01,950 --> 00:24:07,980
service publishing events into a topic

00:24:05,190 --> 00:24:12,620
and each of the micro services gets

00:24:07,980 --> 00:24:15,930
every single one of those domain events

00:24:12,620 --> 00:24:18,390
so every other micro service knows about

00:24:15,930 --> 00:24:22,020
the domain events that happen in every

00:24:18,390 --> 00:24:23,850
other micro service however well first

00:24:22,020 --> 00:24:25,010
of all this requires a high-performance

00:24:23,850 --> 00:24:28,850
bus

00:24:25,010 --> 00:24:33,230
to make it really simple actually a rest

00:24:28,850 --> 00:24:35,870
for Adam publish Adam pub kind of

00:24:33,230 --> 00:24:38,240
approach works really well you can also

00:24:35,870 --> 00:24:41,540
use Kafka RabbitMQ or something like

00:24:38,240 --> 00:24:44,480
that for the rapids alright and we can

00:24:41,540 --> 00:24:48,490
linger on that a little bit later but

00:24:44,480 --> 00:24:50,830
the rivers are where the individual

00:24:48,490 --> 00:24:56,720
micro-services are bounded context

00:24:50,830 --> 00:24:59,900
subscribe to the all topic events and

00:24:56,720 --> 00:25:02,300
then they filter out the events that

00:24:59,900 --> 00:25:03,800
they're not interested in and the events

00:25:02,300 --> 00:25:07,490
that they are interested in are

00:25:03,800 --> 00:25:16,780
dispatched to actors within that micro

00:25:07,490 --> 00:25:19,430
service like this so the topics service

00:25:16,780 --> 00:25:21,350
it's a micro service in its own sense

00:25:19,430 --> 00:25:25,850
but it's not really a bounded context

00:25:21,350 --> 00:25:29,060
this is a technical service where domain

00:25:25,850 --> 00:25:32,120
events are flowing in and then being

00:25:29,060 --> 00:25:34,970
published out to an interested micro

00:25:32,120 --> 00:25:41,840
service and an event is turned into a

00:25:34,970 --> 00:25:44,270
command because an event is a matter of

00:25:41,840 --> 00:25:48,110
fact you cannot dispute that the event

00:25:44,270 --> 00:25:52,100
occurred but the command can be rejected

00:25:48,110 --> 00:25:55,070
so in this case we're saying that this

00:25:52,100 --> 00:25:59,320
event translates to this command and our

00:25:55,070 --> 00:25:59,320
micro service or bounded context and

00:25:59,560 --> 00:26:07,460
possibly this entity will accept that

00:26:02,420 --> 00:26:14,090
command if it does what will it do well

00:26:07,460 --> 00:26:17,450
it's going to save its entity state as a

00:26:14,090 --> 00:26:21,650
series of it domain events part of your

00:26:17,450 --> 00:26:27,620
ubiquitous language into the event story

00:26:21,650 --> 00:26:32,420
event journal and then the actors will

00:26:27,620 --> 00:26:37,670
omit those events back to the Rapids so

00:26:32,420 --> 00:26:38,930
you see the circle and now again other

00:26:37,670 --> 00:26:42,620
micro services

00:26:38,930 --> 00:26:47,240
can take advantage of the fact that

00:26:42,620 --> 00:26:51,440
those events have occurred channel

00:26:47,240 --> 00:26:54,890
services may have a very very small

00:26:51,440 --> 00:26:58,880
ubiquitous language and here's what I'm

00:26:54,890 --> 00:27:02,950
talking about in this case you may have

00:26:58,880 --> 00:27:07,370
an enterprise that looks for or is

00:27:02,950 --> 00:27:10,240
interested in an offers that users would

00:27:07,370 --> 00:27:14,900
like to see some kind of offer

00:27:10,240 --> 00:27:17,690
maybe it's plane fares trips vacation

00:27:14,900 --> 00:27:22,190
rentals something like that so you have

00:27:17,690 --> 00:27:24,110
an offers detector but how do you

00:27:22,190 --> 00:27:26,960
actually make the reservation is the

00:27:24,110 --> 00:27:31,400
reservation part of this ubiquitous

00:27:26,960 --> 00:27:33,410
language or would you conclude that it's

00:27:31,400 --> 00:27:35,150
in a separate micro service a separate

00:27:33,410 --> 00:27:39,230
ubiquitous language well it really

00:27:35,150 --> 00:27:42,050
depends on your conversations with the

00:27:39,230 --> 00:27:45,140
business experts but it could be that

00:27:42,050 --> 00:27:50,270
your ubiquitous language 4-channel

00:27:45,140 --> 00:27:54,260
services are much smaller even just a

00:27:50,270 --> 00:27:57,350
very few entities so what about reactive

00:27:54,260 --> 00:28:00,140
with micro services we're interested in

00:27:57,350 --> 00:28:04,360
micro services being responsive

00:28:00,140 --> 00:28:09,710
resilient elastic and message driven

00:28:04,360 --> 00:28:15,280
responsive in my experience using scala

00:28:09,710 --> 00:28:21,050
akka and play i often times see rest

00:28:15,280 --> 00:28:25,030
endpoints take a request and provide a

00:28:21,050 --> 00:28:28,940
response within 12 to 20 milliseconds

00:28:25,030 --> 00:28:31,310
timeframe so this is a very very highly

00:28:28,940 --> 00:28:36,140
responsive environment that I'm

00:28:31,310 --> 00:28:40,250
describing what about resilient the

00:28:36,140 --> 00:28:46,870
interesting thing about akka and the

00:28:40,250 --> 00:28:51,410
actor model is that when you have an

00:28:46,870 --> 00:28:54,200
exception thrown by some actor component

00:28:51,410 --> 00:28:58,039
it's not the client that has to deal

00:28:54,200 --> 00:29:01,940
with that exception it's the parent of

00:28:58,039 --> 00:29:05,120
the actor that throws the exception that

00:29:01,940 --> 00:29:08,330
deals with it and the parent is the

00:29:05,120 --> 00:29:10,460
component that best understands what to

00:29:08,330 --> 00:29:13,700
do under those circumstances so we

00:29:10,460 --> 00:29:15,770
aren't leaving it to every client for

00:29:13,700 --> 00:29:17,750
example of the domain model to

00:29:15,770 --> 00:29:21,020
understand what needs to happen under

00:29:17,750 --> 00:29:24,520
every situation where an exception might

00:29:21,020 --> 00:29:28,400
get thrown instead the parent of that

00:29:24,520 --> 00:29:31,669
component is what deals with it can help

00:29:28,400 --> 00:29:39,080
the system to recover quickly even to

00:29:31,669 --> 00:29:42,830
self-heal and then all that the client

00:29:39,080 --> 00:29:47,390
needs to understand is was my request

00:29:42,830 --> 00:29:50,659
honored or was it not honored if it was

00:29:47,390 --> 00:29:54,380
honored we're good if it wasn't honored

00:29:50,659 --> 00:29:59,510
I can retry or offer a failure condition

00:29:54,380 --> 00:30:02,799
to the user that's all that the client

00:29:59,510 --> 00:30:09,409
needs to understand and the client can

00:30:02,799 --> 00:30:13,250
build a circuit breaker for retries it

00:30:09,409 --> 00:30:15,830
can use back off exponential capped back

00:30:13,250 --> 00:30:18,799
off can use a lot of different

00:30:15,830 --> 00:30:23,140
approaches for retries or it can simply

00:30:18,799 --> 00:30:27,679
offer a failure condition to the user

00:30:23,140 --> 00:30:32,450
elastic well if you haven't seen the

00:30:27,679 --> 00:30:36,470
other talks about akka cluster and how

00:30:32,450 --> 00:30:38,830
akka cluster is elastic then I I would

00:30:36,470 --> 00:30:41,000
say that you should watch those videos

00:30:38,830 --> 00:30:43,190
after the conference I'm not going to

00:30:41,000 --> 00:30:47,270
linger on this but you can actually

00:30:43,190 --> 00:30:49,150
shrink and grow a micro service on

00:30:47,270 --> 00:30:53,510
demand

00:30:49,150 --> 00:30:56,919
message driven to be clear actors our

00:30:53,510 --> 00:31:00,830
message driven and the rapids approach

00:30:56,919 --> 00:31:03,950
to publishing all events and subscribing

00:31:00,830 --> 00:31:06,889
to all events in a given system

00:31:03,950 --> 00:31:10,309
is message driven and I also want to

00:31:06,889 --> 00:31:15,110
talk about the nature of the throughput

00:31:10,309 --> 00:31:17,570
of the high performance bus you know

00:31:15,110 --> 00:31:22,850
we're talking about being able to with

00:31:17,570 --> 00:31:26,029
rest publish and subscribe to tens of

00:31:22,850 --> 00:31:29,860
thousands of events per second and with

00:31:26,029 --> 00:31:33,610
Kafka even hundreds of thousands if not

00:31:29,860 --> 00:31:36,350
higher numbers of events per second and

00:31:33,610 --> 00:31:38,110
there there's actually a RabbitMQ

00:31:36,350 --> 00:31:42,970
service that you can get from Google

00:31:38,110 --> 00:31:47,299
where you can publish as in send and

00:31:42,970 --> 00:31:50,480
receive two million messages per second

00:31:47,299 --> 00:31:53,980
and I'm talking about 1 million in and 1

00:31:50,480 --> 00:31:57,799
million out so probably for a lot of us

00:31:53,980 --> 00:32:00,320
that kind of throughput in the Rapids

00:31:57,799 --> 00:32:03,639
will will probably work pretty well for

00:32:00,320 --> 00:32:03,639
us ok

00:32:06,940 --> 00:32:12,460
so let's talk about how to implement

00:32:09,419 --> 00:32:15,159
micro-services using Scala and akka and

00:32:12,460 --> 00:32:18,869
this is the distributed computing use

00:32:15,159 --> 00:32:23,289
case that I'm going to show you in this

00:32:18,869 --> 00:32:26,289
demo what we have is as step one you see

00:32:23,289 --> 00:32:29,440
at the top step one we have an incoming

00:32:26,289 --> 00:32:32,889
command message the command message is

00:32:29,440 --> 00:32:36,129
create a product this is in the scrum

00:32:32,889 --> 00:32:37,840
agile project management context so

00:32:36,129 --> 00:32:40,899
we're going to create a new scrum

00:32:37,840 --> 00:32:44,470
product a scrum product in the

00:32:40,899 --> 00:32:46,330
ubiquitous language is defined as the

00:32:44,470 --> 00:32:49,320
software that we're building that is

00:32:46,330 --> 00:32:56,289
what a scrum product is to an agile team

00:32:49,320 --> 00:33:00,399
using scrum the command comes in we emit

00:32:56,289 --> 00:33:03,460
two domain events from our product or

00:33:00,399 --> 00:33:07,330
the potential for two domain events we

00:33:03,460 --> 00:33:10,599
definitely knit product created which

00:33:07,330 --> 00:33:14,580
says that this product has been created

00:33:10,599 --> 00:33:19,720
but if the command message also

00:33:14,580 --> 00:33:21,999
stipulated that a discussion a

00:33:19,720 --> 00:33:26,109
collaborative forum based discussion

00:33:21,999 --> 00:33:28,809
should be created in addition to the

00:33:26,109 --> 00:33:32,529
product we will also emit a discussion

00:33:28,809 --> 00:33:34,989
request a domain event that domain event

00:33:32,529 --> 00:33:37,210
will end up in the river or in the

00:33:34,989 --> 00:33:40,090
rapids I should say and then eventually

00:33:37,210 --> 00:33:46,119
into the river of the collaboration

00:33:40,090 --> 00:33:51,700
micro service discussion requested and a

00:33:46,119 --> 00:33:54,789
forum and discussion entity will be

00:33:51,700 --> 00:33:57,759
created in the collaboration micro

00:33:54,789 --> 00:33:59,679
service and then a discussion started

00:33:57,759 --> 00:34:05,440
domain event will end up back in the

00:33:59,679 --> 00:34:07,779
rapids and then it will go back to the

00:34:05,440 --> 00:34:12,339
agile project management context micro

00:34:07,779 --> 00:34:16,389
service as discussion started and the

00:34:12,339 --> 00:34:19,590
product will now have an identity that

00:34:16,389 --> 00:34:22,750
says I have a discussion available

00:34:19,590 --> 00:34:24,669
through another micro-service so

00:34:22,750 --> 00:34:28,450
whenever our users want to have a chat

00:34:24,669 --> 00:34:31,990
about this scrum product in particular

00:34:28,450 --> 00:34:35,320
they can use this threaded discussion to

00:34:31,990 --> 00:34:43,000
to carry that out so let's look at the

00:34:35,320 --> 00:34:50,250
code and what I want to show you is

00:34:43,000 --> 00:34:52,780
first of all in each micro-service

00:34:50,250 --> 00:34:57,580
you're going to need some sort of

00:34:52,780 --> 00:34:59,320
startup so in your when you have a micro

00:34:57,580 --> 00:35:01,990
service such as the agile project

00:34:59,320 --> 00:35:04,119
management context or the collaboration

00:35:01,990 --> 00:35:06,400
context or any other kind of service

00:35:04,119 --> 00:35:10,780
you're going to need to get in touch

00:35:06,400 --> 00:35:13,380
with the rest of the micro services and

00:35:10,780 --> 00:35:18,609
the way that you do that is you have

00:35:13,380 --> 00:35:21,369
what's called a service registry and so

00:35:18,609 --> 00:35:27,030
as you start up can everybody see this

00:35:21,369 --> 00:35:30,119
code okay not so good a little bigger

00:35:27,030 --> 00:35:30,119
let me

00:35:35,260 --> 00:35:43,839
okay all right

00:35:38,210 --> 00:35:47,720
so what we have is and this is using

00:35:43,839 --> 00:35:50,630
dependency injection within play within

00:35:47,720 --> 00:35:53,900
the play framework so we have we're

00:35:50,630 --> 00:35:56,809
going to bind what's called a start up

00:35:53,900 --> 00:36:00,710
runner that's really just this singleton

00:35:56,809 --> 00:36:06,050
class right here and this start up

00:36:00,710 --> 00:36:09,040
runner is going to bind in eagerly which

00:36:06,050 --> 00:36:11,450
means whenever the service starts up

00:36:09,040 --> 00:36:15,470
this is going to be the first thing that

00:36:11,450 --> 00:36:18,710
happens all right and we register this

00:36:15,470 --> 00:36:22,130
start up module in our application comp

00:36:18,710 --> 00:36:24,349
file of play you can look at the details

00:36:22,130 --> 00:36:27,980
of how to do that I won't show you right

00:36:24,349 --> 00:36:29,270
now but it's very simple all right so

00:36:27,980 --> 00:36:34,510
this is the first thing that's going to

00:36:29,270 --> 00:36:37,760
happen when your service comes alive now

00:36:34,510 --> 00:36:41,180
your startup Runner is going to do a few

00:36:37,760 --> 00:36:44,540
things it's going to create a topics

00:36:41,180 --> 00:36:47,420
feeder which is going to be responsible

00:36:44,540 --> 00:36:51,260
for taking all domain events that occur

00:36:47,420 --> 00:36:54,619
in your micro service and putting those

00:36:51,260 --> 00:36:58,030
into the rapids or that topics service

00:36:54,619 --> 00:37:01,910
and then we're also going to start a

00:36:58,030 --> 00:37:05,030
topics reader which will read all new

00:37:01,910 --> 00:37:08,510
domain events from the rapids and bring

00:37:05,030 --> 00:37:10,640
them in to our micro service so that we

00:37:08,510 --> 00:37:12,680
can filter and get the events that we're

00:37:10,640 --> 00:37:23,589
interested in in our particular micro

00:37:12,680 --> 00:37:27,260
service then we create a heartbeat actor

00:37:23,589 --> 00:37:29,349
that registers this particular micro

00:37:27,260 --> 00:37:32,960
service with the service registry it

00:37:29,349 --> 00:37:36,530
says under this name I provide these

00:37:32,960 --> 00:37:40,579
URIs ok just to put it simply as you can

00:37:36,530 --> 00:37:44,299
see at the very top of this code here I

00:37:40,579 --> 00:37:47,089
have a home URI I have a new product URI

00:37:44,299 --> 00:37:49,730
so this is how another service would

00:37:47,089 --> 00:37:50,870
would send a request to my service to

00:37:49,730 --> 00:37:57,440
create a new

00:37:50,870 --> 00:38:02,600
a agile product or it could be a UI that

00:37:57,440 --> 00:38:08,380
uses this and then we can also get so do

00:38:02,600 --> 00:38:12,800
a query on a product through the product

00:38:08,380 --> 00:38:14,600
name all right so that's the kind of

00:38:12,800 --> 00:38:19,130
thing that happens and then and then

00:38:14,600 --> 00:38:22,670
every few mike milliseconds this actor

00:38:19,130 --> 00:38:24,650
will re register itself with the service

00:38:22,670 --> 00:38:28,010
which allows the service to actually

00:38:24,650 --> 00:38:31,580
move around or and and it also allows

00:38:28,010 --> 00:38:33,260
the service registry to check health the

00:38:31,580 --> 00:38:37,370
next component that I want to show you

00:38:33,260 --> 00:38:40,550
is the products controller so this is in

00:38:37,370 --> 00:38:43,160
the agile project management micro

00:38:40,550 --> 00:38:47,450
service it is the controller that will

00:38:43,160 --> 00:38:49,070
take rest requests so if you can make

00:38:47,450 --> 00:38:53,000
out here I have a comment which is a

00:38:49,070 --> 00:38:54,770
curl command and this curl command can

00:38:53,000 --> 00:38:57,770
be used to create a new product I'll

00:38:54,770 --> 00:39:02,900
demonstrate that in a moment and this

00:38:57,770 --> 00:39:08,470
curl command can be used to get the

00:39:02,900 --> 00:39:08,470
state of a product by its ID okay

00:39:08,560 --> 00:39:16,070
so what we're going to do is for example

00:39:11,720 --> 00:39:20,660
when we create a product we're going to

00:39:16,070 --> 00:39:23,930
get the product description as JSON data

00:39:20,660 --> 00:39:28,880
from the rest request and then we're

00:39:23,930 --> 00:39:35,150
going to get the identity for the

00:39:28,880 --> 00:39:40,340
product the identity is going to be sent

00:39:35,150 --> 00:39:42,650
in with this command create product

00:39:40,340 --> 00:39:48,440
remember our our command message is

00:39:42,650 --> 00:39:53,450
being sent in create product to the new

00:39:48,440 --> 00:39:59,510
product which is an actor we get a

00:39:53,450 --> 00:40:01,870
future back we map to we map the future

00:39:59,510 --> 00:40:01,870
to

00:40:03,590 --> 00:40:11,640
create product result message and then

00:40:08,280 --> 00:40:13,260
we map that to a result and we're going

00:40:11,640 --> 00:40:16,220
to assume that the product was created

00:40:13,260 --> 00:40:19,770
you would have potential failure

00:40:16,220 --> 00:40:23,000
recovery in this situation but if we

00:40:19,770 --> 00:40:27,810
have created we're going to send a 201

00:40:23,000 --> 00:40:32,010
created message with the location URI of

00:40:27,810 --> 00:40:34,050
where that product can be found so if

00:40:32,010 --> 00:40:37,140
you wanted to immediately query back and

00:40:34,050 --> 00:40:38,700
ask where's this product or what what

00:40:37,140 --> 00:40:39,060
does this product look like you could do

00:40:38,700 --> 00:40:46,890
that

00:40:39,060 --> 00:40:48,450
okay so we've actually looked at service

00:40:46,890 --> 00:40:51,900
startup we've looked at a service

00:40:48,450 --> 00:40:55,590
endpoint now let's look at the potential

00:40:51,900 --> 00:41:00,030
need for a process manager a process

00:40:55,590 --> 00:41:04,170
manager is described in enterprise

00:41:00,030 --> 00:41:06,990
integration patterns and shown how to

00:41:04,170 --> 00:41:12,180
you how to create a process manager in

00:41:06,990 --> 00:41:14,340
my book reactive messaging patterns with

00:41:12,180 --> 00:41:19,040
the actor model I'm going to show you an

00:41:14,340 --> 00:41:21,750
example of this in code so this is as

00:41:19,040 --> 00:41:27,180
you can see here the start forum

00:41:21,750 --> 00:41:29,160
discussion process or the start form or

00:41:27,180 --> 00:41:32,940
the I'm sorry the form discussion

00:41:29,160 --> 00:41:36,960
starter which is a process manager this

00:41:32,940 --> 00:41:42,990
process manager is interested in just

00:41:36,960 --> 00:41:47,100
three messages one message is start

00:41:42,990 --> 00:41:50,640
forum discussion so as its default

00:41:47,100 --> 00:41:55,980
receive block it's going to take a start

00:41:50,640 --> 00:41:59,760
forum discussion and it will then create

00:41:55,980 --> 00:42:02,369
a new entity called forum and this

00:41:59,760 --> 00:42:07,410
entity will be sent a start forum

00:42:02,369 --> 00:42:11,490
message and internally this forum

00:42:07,410 --> 00:42:13,640
discussion starter will become a start

00:42:11,490 --> 00:42:17,490
forum discussion info

00:42:13,640 --> 00:42:22,849
listener which is the next block down

00:42:17,490 --> 00:42:28,880
and notice that I I give this block an

00:42:22,849 --> 00:42:32,810
info a start form discussion info object

00:42:28,880 --> 00:42:37,320
so that when it receives a forum started

00:42:32,810 --> 00:42:40,140
message domain event message it knows

00:42:37,320 --> 00:42:44,550
that it can then properly create the

00:42:40,140 --> 00:42:49,859
discussion within the forum and then

00:42:44,550 --> 00:42:53,570
this block tells the listener to become

00:42:49,859 --> 00:42:57,570
a discussion started listener and

00:42:53,570 --> 00:43:01,349
finally we reply back to the original

00:42:57,570 --> 00:43:09,410
sender that we started a forum

00:43:01,349 --> 00:43:18,930
discussion all right now an example of a

00:43:09,410 --> 00:43:23,579
an entity or a persistent actor this is

00:43:18,930 --> 00:43:28,619
the product entity in the agile project

00:43:23,579 --> 00:43:31,339
management context and it's going to

00:43:28,619 --> 00:43:34,710
receive a create product command and

00:43:31,339 --> 00:43:40,140
what will it emit it will emit at least

00:43:34,710 --> 00:43:45,630
a product created event and if a

00:43:40,140 --> 00:43:49,190
discussion was requested right here it

00:43:45,630 --> 00:43:52,800
will also emit a discussion requested

00:43:49,190 --> 00:43:56,490
domain event this domain event will flow

00:43:52,800 --> 00:44:01,410
over through the rapids into the river

00:43:56,490 --> 00:44:06,920
of the collaboration context and that is

00:44:01,410 --> 00:44:10,710
where this forum discussion starter

00:44:06,920 --> 00:44:12,930
process manager is going to see that

00:44:10,710 --> 00:44:15,920
domain event or a command based on the

00:44:12,930 --> 00:44:20,640
that domain event and it's going to run

00:44:15,920 --> 00:44:25,200
so what I want to do is show you each of

00:44:20,640 --> 00:44:27,020
these services running so I'm going to

00:44:25,200 --> 00:44:35,030
start the service register

00:44:27,020 --> 00:44:36,620
be on port 9001 and I'm since this is in

00:44:35,030 --> 00:44:39,770
development mode I'm just going to ping

00:44:36,620 --> 00:44:43,970
this service registry and make it start

00:44:39,770 --> 00:44:47,080
running then I'm going to start the

00:44:43,970 --> 00:44:52,880
rapids this is the topics service

00:44:47,080 --> 00:44:58,940
running on port 9000 2 and I'm going to

00:44:52,880 --> 00:45:01,220
ping that service as well so these are

00:44:58,940 --> 00:45:03,050
two technical services they're not

00:45:01,220 --> 00:45:04,910
really taking care of any business

00:45:03,050 --> 00:45:08,420
function they're just taking care of

00:45:04,910 --> 00:45:12,850
service registration and pub/sub

00:45:08,420 --> 00:45:16,580
essentially now I'm going to go to my

00:45:12,850 --> 00:45:20,390
collaboration bounded context this is

00:45:16,580 --> 00:45:26,660
actually a business micro service and

00:45:20,390 --> 00:45:33,590
it's going to run on port 9000 3 and I'm

00:45:26,660 --> 00:45:37,520
going to ping this service so that it

00:45:33,590 --> 00:45:41,410
starts running and now I'm going to go

00:45:37,520 --> 00:45:49,150
over to the agile project management

00:45:41,410 --> 00:45:51,530
context micro service and let me ping

00:45:49,150 --> 00:45:54,440
this service with something actually

00:45:51,530 --> 00:45:59,060
meaningful so now the curl command that

00:45:54,440 --> 00:46:03,740
I'm running here is actually going to

00:45:59,060 --> 00:46:06,110
post to create a new product in the

00:46:03,740 --> 00:46:08,740
agile project management context and

00:46:06,110 --> 00:46:12,140
what you should look for is in the

00:46:08,740 --> 00:46:15,380
topics you're going to see so in the

00:46:12,140 --> 00:46:18,590
upper right corner you're going to see a

00:46:15,380 --> 00:46:21,680
message come across that is the domain

00:46:18,590 --> 00:46:25,430
event that fires from the agile project

00:46:21,680 --> 00:46:28,610
management context so here we go you see

00:46:25,430 --> 00:46:32,480
the agile p.m. is starting to run we're

00:46:28,610 --> 00:46:37,130
going to get a request look up at the

00:46:32,480 --> 00:46:39,859
topics you see the topics that message

00:46:37,130 --> 00:46:43,160
was just delivered over here to

00:46:39,859 --> 00:46:45,489
the collaboration context and we finally

00:46:43,160 --> 00:46:50,140
got back in the agile project management

00:46:45,489 --> 00:46:50,140
context indication that

00:46:55,870 --> 00:47:04,930
got the mess the domain event that we

00:46:59,650 --> 00:47:06,790
were looking for that the discussion was

00:47:04,930 --> 00:47:11,860
started and if you want to look in the

00:47:06,790 --> 00:47:24,040
collaboration context to go back aways

00:47:11,860 --> 00:47:26,730
here you can see that the topic for all

00:47:24,040 --> 00:47:31,140
message was received

00:47:26,730 --> 00:47:37,450
we got a collaboration discussion

00:47:31,140 --> 00:47:41,050
requested event that caused a forum and

00:47:37,450 --> 00:47:42,760
discussion entity to be created in the

00:47:41,050 --> 00:47:45,520
collaboration context through that

00:47:42,760 --> 00:47:48,130
process manager and then the topics

00:47:45,520 --> 00:47:53,440
reader consumer said that completed

00:47:48,130 --> 00:47:56,020
successfully and if we look back in our

00:47:53,440 --> 00:47:59,470
agile project management context we see

00:47:56,020 --> 00:48:01,540
that this discussion was started we got

00:47:59,470 --> 00:48:04,780
a discussion discussion start a domain

00:48:01,540 --> 00:48:11,200
event and that allowed us to marry up

00:48:04,780 --> 00:48:20,320
the discussion ID with the agile project

00:48:11,200 --> 00:48:26,500
management product ok all right so you

00:48:20,320 --> 00:48:28,540
got to see an actor aggregate let me

00:48:26,500 --> 00:48:30,910
just show you I we're actually a little

00:48:28,540 --> 00:48:34,810
bit over time if anybody absolutely

00:48:30,910 --> 00:48:40,090
needs to leave feel free to do so but I

00:48:34,810 --> 00:48:43,770
did want to show you also the CQRS part

00:48:40,090 --> 00:48:43,770
of this CQRS

00:48:44,700 --> 00:48:55,480
stands for command query responsibility

00:48:52,060 --> 00:48:57,430
segregation and this is where we're

00:48:55,480 --> 00:48:59,980
going to take the domain events from our

00:48:57,430 --> 00:49:03,010
own bounded context to our own micro

00:48:59,980 --> 00:49:07,300
service and we're going to create

00:49:03,010 --> 00:49:10,050
optimal query views for how the user

00:49:07,300 --> 00:49:13,000
would want to consume

00:49:10,050 --> 00:49:16,690
the information within this micro

00:49:13,000 --> 00:49:20,560
service for example on a UI so we get a

00:49:16,690 --> 00:49:25,170
tick event every so many milliseconds

00:49:20,560 --> 00:49:27,340
and this tick event is used to read a

00:49:25,170 --> 00:49:30,130
persistence query or to use a

00:49:27,340 --> 00:49:34,390
persistence query from akka persistence

00:49:30,130 --> 00:49:37,980
query and to read any new domain events

00:49:34,390 --> 00:49:42,270
that have been received into our

00:49:37,980 --> 00:49:45,880
persistence into our event journal and

00:49:42,270 --> 00:49:51,840
each of those is projected each event is

00:49:45,880 --> 00:49:51,840
projected into the proper view so now

00:49:52,320 --> 00:50:04,080
whenever we receive a query product view

00:49:59,170 --> 00:50:09,660
we can return a product view result

00:50:04,080 --> 00:50:14,470
object that has the view of a given a

00:50:09,660 --> 00:50:17,380
gelada sizz tuned for how the user wants

00:50:14,470 --> 00:50:19,270
to view which is different from the

00:50:17,380 --> 00:50:22,750
product aggregate or product entity

00:50:19,270 --> 00:50:25,500
which is tuned for commands all right so

00:50:22,750 --> 00:50:25,500
any questions

00:50:30,759 --> 00:50:33,759
yep

00:50:48,900 --> 00:50:59,339
yeah okay so I think I think what you're

00:50:52,410 --> 00:51:06,599
asking is in thinking about this

00:50:59,339 --> 00:51:10,609
component should we have more specific

00:51:06,599 --> 00:51:10,609
topics top

00:51:18,140 --> 00:51:30,499
okay but but everything that's going in

00:51:20,450 --> 00:51:32,359
here is just a JSON representation yeah

00:51:30,499 --> 00:51:36,859
well you have to yes you have to take

00:51:32,359 --> 00:51:39,440
into consideration versioning of domain

00:51:36,859 --> 00:51:42,859
events or replacing domain events so

00:51:39,440 --> 00:51:45,410
yeah that's that's a thing for sure but

00:51:42,859 --> 00:51:52,249
maybe we could take that one offline any

00:51:45,410 --> 00:51:55,249
other questions about this yeah so

00:51:52,249 --> 00:51:58,970
regarding the bounded context yep

00:51:55,249 --> 00:52:01,579
say for example you have only two

00:51:58,970 --> 00:52:03,470
services in a particular bounded context

00:52:01,579 --> 00:52:05,420
that are overloaded do you have the

00:52:03,470 --> 00:52:07,220
flexibility of scaling only those two

00:52:05,420 --> 00:52:09,890
services or do you have to scale the

00:52:07,220 --> 00:52:14,779
entire bounded context I see what you're

00:52:09,890 --> 00:52:18,019
saying so yeah that so essentially what

00:52:14,779 --> 00:52:21,410
your argument is that if I have one

00:52:18,019 --> 00:52:23,150
micro service per entity one entity per

00:52:21,410 --> 00:52:28,819
micro service I can scale those

00:52:23,150 --> 00:52:32,180
independently right so that yeah that

00:52:28,819 --> 00:52:35,359
could be one reason to break one entity

00:52:32,180 --> 00:52:37,400
out and and deploy it separately but

00:52:35,359 --> 00:52:40,299
logically it's still part of that

00:52:37,400 --> 00:52:44,019
ubiquitous language so I'm not I'm not

00:52:40,299 --> 00:52:48,619
necessarily saying that you should never

00:52:44,019 --> 00:52:51,769
deploy individual entities separately

00:52:48,619 --> 00:52:52,999
you can do that I but I argue that

00:52:51,769 --> 00:52:54,980
there's still part of the same

00:52:52,999 --> 00:52:56,509
ubiquitous language or just you just

00:52:54,980 --> 00:52:59,440
have a different deployment strategy

00:52:56,509 --> 00:52:59,440
okay

00:53:05,029 --> 00:53:08,029
right

00:53:10,660 --> 00:53:17,430
right right yeah scaling is definitely a

00:53:14,019 --> 00:53:17,430
reason to break them out

00:53:24,359 --> 00:53:28,369
I can't hear I'm sorry

00:53:29,720 --> 00:53:33,920
in this diagram the persistence our

00:53:32,210 --> 00:53:36,770
journaling is happening in the product

00:53:33,920 --> 00:53:38,150
right yes the and even the view

00:53:36,770 --> 00:53:41,329
projection is also happening in the

00:53:38,150 --> 00:53:43,849
product right yeah right I know the Brut

00:53:41,329 --> 00:53:47,059
the view projection is happening

00:53:43,849 --> 00:53:53,720
out-of-band from the product okay so I

00:53:47,059 --> 00:53:58,670
actually have this products views is a

00:53:53,720 --> 00:54:01,069
separate actor okay yep and you can you

00:53:58,670 --> 00:54:04,160
can send a query message to that actor

00:54:01,069 --> 00:54:06,289
and in the background or you know every

00:54:04,160 --> 00:54:09,500
so many milliseconds that actor is

00:54:06,289 --> 00:54:12,890
looking for any new interesting domain

00:54:09,500 --> 00:54:15,160
events such as product created

00:54:12,890 --> 00:54:17,510
discussion requested discussion attached

00:54:15,160 --> 00:54:27,970
right and it's building the view from

00:54:17,510 --> 00:54:27,970
that okay any other questions go ahead

00:54:32,260 --> 00:54:40,670
um go ahead

00:54:37,400 --> 00:54:43,160
where are you sometime - why am i using

00:54:40,670 --> 00:54:44,810
time yeah every five seconds like that

00:54:43,160 --> 00:54:45,920
would just subscribe to the vents and

00:54:44,810 --> 00:54:52,360
get the events that they are where do

00:54:45,920 --> 00:54:56,570
you see fights oh yeah my like good eye

00:54:52,360 --> 00:54:59,620
yeah Oh two seconds yeah so actually the

00:54:56,570 --> 00:55:02,750
for practical purposes this is for

00:54:59,620 --> 00:55:05,960
teaching okay but this would obviously

00:55:02,750 --> 00:55:07,850
be maybe like ten milliseconds or 100

00:55:05,960 --> 00:55:11,740
milliseconds or something like that we

00:55:07,850 --> 00:55:14,720
don't want to just pound the this this

00:55:11,740 --> 00:55:16,750
pub/sub interface is running over rest

00:55:14,720 --> 00:55:20,570
and and we don't want to just constantly

00:55:16,750 --> 00:55:22,010
pound the the reader but you know

00:55:20,570 --> 00:55:27,230
certainly you have to find the right

00:55:22,010 --> 00:55:29,560
threshold for for reading events did you

00:55:27,230 --> 00:55:29,560
have another

00:55:31,470 --> 00:55:36,920
during the same service yes they are

00:55:42,080 --> 00:55:53,790
yeah interesting yeah

00:55:48,390 --> 00:55:56,340
so when that when scalability is the

00:55:53,790 --> 00:55:57,900
thing right you definitely have to

00:55:56,340 --> 00:56:01,290
approach this differently

00:55:57,900 --> 00:56:04,370
but what I'm saying is to start out with

00:56:01,290 --> 00:56:07,770
with this sort of conceptual

00:56:04,370 --> 00:56:13,620
architecture of micro services is going

00:56:07,770 --> 00:56:16,290
to greatly simplify your ability to to

00:56:13,620 --> 00:56:21,140
succeed with micro services to start

00:56:16,290 --> 00:56:25,740
with then as you see that individual

00:56:21,140 --> 00:56:28,410
entities or some kind of component needs

00:56:25,740 --> 00:56:31,890
to scale greater then you can pull that

00:56:28,410 --> 00:56:34,110
one out from the micro from the one

00:56:31,890 --> 00:56:36,330
micro service and deploy it separately

00:56:34,110 --> 00:56:39,120
but it would still logically be part of

00:56:36,330 --> 00:56:45,870
the same bounded context same ubiquitous

00:56:39,120 --> 00:56:47,100
language huh yes you're talking about a

00:56:45,870 --> 00:56:49,140
service registry for all of your

00:56:47,100 --> 00:56:53,910
endpoints so where does that go and what

00:56:49,140 --> 00:56:56,160
is the purpose of it so that that is a

00:56:53,910 --> 00:56:59,730
technical service it's running here and

00:56:56,160 --> 00:57:02,370
it is it's in your infrastructure it's

00:56:59,730 --> 00:57:06,240
it's a service that that needs to run

00:57:02,370 --> 00:57:10,620
and what it's doing is that just think

00:57:06,240 --> 00:57:13,680
of it as a as a global map so to speak

00:57:10,620 --> 00:57:15,870
where I have a key value pair and the

00:57:13,680 --> 00:57:19,050
key is the name of my service and the

00:57:15,870 --> 00:57:21,090
value is another map that that says

00:57:19,050 --> 00:57:24,420
these are the endpoints that I support

00:57:21,090 --> 00:57:27,420
or it at a minimum it would be a key

00:57:24,420 --> 00:57:30,030
with a single value that says here is my

00:57:27,420 --> 00:57:34,760
home location and from there you can

00:57:30,030 --> 00:57:34,760
navigate to all my other endpoints right

00:57:34,820 --> 00:57:44,980
is it a real time what

00:57:40,460 --> 00:57:51,440
no no it's actually that that is how

00:57:44,980 --> 00:57:53,740
that is how anything knows that that it

00:57:51,440 --> 00:57:56,900
can use the agile project management

00:57:53,740 --> 00:57:59,390
context or it knows that it can use the

00:57:56,900 --> 00:58:02,450
collaboration context it's basically

00:57:59,390 --> 00:58:03,619
like a service lookup it's where you do

00:58:02,450 --> 00:58:05,770
your service lookup

00:58:03,619 --> 00:58:08,570
some people call it service locator I

00:58:05,770 --> 00:58:12,320
swear off that word because it gets me

00:58:08,570 --> 00:58:14,750
in trouble every time I use it but it is

00:58:12,320 --> 00:58:16,880
a service registry it's where it's it's

00:58:14,750 --> 00:58:20,270
sort of a central location that in

00:58:16,880 --> 00:58:22,609
itself can scale and provides the means

00:58:20,270 --> 00:58:28,369
for all other services to know where it

00:58:22,609 --> 00:58:31,940
can find a certain service right all

00:58:28,369 --> 00:58:33,410
right makes sense okay I can meet

00:58:31,940 --> 00:58:37,240
outside if anybody has any other

00:58:33,410 --> 00:58:37,240

YouTube URL: https://www.youtube.com/watch?v=19rbbQ46LB4


