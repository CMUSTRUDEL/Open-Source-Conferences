Title: The Structure of Programming Revolutions - by Noel Welsh
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
What does it mean to think like a functional programmer? Why is it so hard to adopt functional programming if you are steeped in OO? In this talk, I'll address these questions, using ideas from the philosophy of science. The talk will give new insight into the process of becoming productive in Scala and the mindset needed to aid this process. Using the framework of "The Structure of Scientific Revolutions", we can see programming as undergoing three revolutions: Structured programming, object-oriented programming, and now, functional programming. Each revolution brings with a new paradigm - basic assumptions and values that make moving across paradigms difficult to achieve. In this talk, I'll describe the paradigm of the functional programmer: What is valued and what is considered good code. I will contrast this to the paradigm of the object-oriented programmer and finally consider if it is possible to reconcile these two approaches to programming.
Captions: 
	00:00:01,669 --> 00:00:06,210
all right everybody shall we get going

00:00:04,220 --> 00:00:08,460
thanks coming on to my talk

00:00:06,210 --> 00:00:10,830
my name is Noah Welsh and I am a

00:00:08,460 --> 00:00:12,929
consultant at a company called

00:00:10,830 --> 00:00:15,870
underscore I'm not here to talk about

00:00:12,929 --> 00:00:19,050
that I'm here to talk about some weighty

00:00:15,870 --> 00:00:22,710
philosophical topics so let's start with

00:00:19,050 --> 00:00:27,330
a bit of audience participation here on

00:00:22,710 --> 00:00:29,130
this topic is python a good language so

00:00:27,330 --> 00:00:32,160
one of the ways that we can set all

00:00:29,130 --> 00:00:34,110
things is with utilitarianism which is

00:00:32,160 --> 00:00:36,420
you go for the greatest good so let's

00:00:34,110 --> 00:00:39,059
have a vote and we use utilitarianism

00:00:36,420 --> 00:00:40,829
decide in the audience is Python very

00:00:39,059 --> 00:00:43,469
good language the put hand up you think

00:00:40,829 --> 00:00:46,079
it is a good language I will vote on the

00:00:43,469 --> 00:00:48,960
side of good and put your hand up you

00:00:46,079 --> 00:00:50,969
think is a bad language all right we

00:00:48,960 --> 00:00:54,000
have a few hands going out so the

00:00:50,969 --> 00:00:57,239
audience says that Python is a good

00:00:54,000 --> 00:00:59,039
language and this question was what

00:00:57,239 --> 00:01:02,820
motivated this talk initially somebody

00:00:59,039 --> 00:01:08,310
asking me isn't Python a good language

00:01:02,820 --> 00:01:13,260
and I thought well you know what is what

00:01:08,310 --> 00:01:15,119
is good and can we can we really give us

00:01:13,260 --> 00:01:17,040
a definition of good outside of a

00:01:15,119 --> 00:01:20,780
context particularly for programming

00:01:17,040 --> 00:01:22,650
languages and particularly for when the

00:01:20,780 --> 00:01:23,909
programming language switches are in

00:01:22,650 --> 00:01:25,770
different kind of paradigms

00:01:23,909 --> 00:01:28,619
object-oriented and functional

00:01:25,770 --> 00:01:29,630
programming so this talk I want to talk

00:01:28,619 --> 00:01:31,229
about the difference between

00:01:29,630 --> 00:01:35,009
object-oriented and functional

00:01:31,229 --> 00:01:36,630
programming what it means to be sort of

00:01:35,009 --> 00:01:39,600
object into program or what it means to

00:01:36,630 --> 00:01:43,369
be functional programmer and hopefully

00:01:39,600 --> 00:01:46,049
if you are new to Scala maybe give you

00:01:43,369 --> 00:01:48,720
some ideas and how you can more easily

00:01:46,049 --> 00:01:51,240
adopt the functional programming mindset

00:01:48,720 --> 00:01:53,430
and if you are more experienced scholar

00:01:51,240 --> 00:01:55,259
developer then it's likely that you're

00:01:53,430 --> 00:01:56,820
training people at some point in time so

00:01:55,259 --> 00:02:00,750
maybe you can use these ideas to help

00:01:56,820 --> 00:02:03,000
train people so yeah looking at our

00:02:00,750 --> 00:02:04,950
versus FP what sort of means to think in

00:02:03,000 --> 00:02:08,399
these different ways and what it means

00:02:04,950 --> 00:02:11,520
to be a functional programmer but before

00:02:08,399 --> 00:02:12,660
I get into that I want to discuss some

00:02:11,520 --> 00:02:16,260
other ideas

00:02:12,660 --> 00:02:17,250
tax so let's talk about some wild ideas

00:02:16,260 --> 00:02:18,930
from the 60s

00:02:17,250 --> 00:02:20,130
now let's let me have another look at

00:02:18,930 --> 00:02:23,010
the audience I'm gonna guess a nobody

00:02:20,130 --> 00:02:24,740
here remembers the 60s but if you think

00:02:23,010 --> 00:02:27,600
of the sixties you probably think of

00:02:24,740 --> 00:02:30,270
Woodstock or maybe the Beatles or things

00:02:27,600 --> 00:02:32,160
like that but there's some pretty wild

00:02:30,270 --> 00:02:33,750
ideas coming out of Paris in the 60s I

00:02:32,160 --> 00:02:36,120
won't discuss some of them I suspect

00:02:33,750 --> 00:02:38,460
they're pretty not familiar so let's

00:02:36,120 --> 00:02:41,430
talk about firstly taxonomy of angels I

00:02:38,460 --> 00:02:44,490
don't even consider this are angels all

00:02:41,430 --> 00:02:46,200
one species or angels separate species

00:02:44,490 --> 00:02:48,390
well it's been argued that angels are

00:02:46,200 --> 00:02:50,370
separate species because angels do not

00:02:48,390 --> 00:02:53,040
have meta and you cannot distinguish

00:02:50,370 --> 00:02:54,840
things that you can distinguish

00:02:53,040 --> 00:02:56,520
individuals because I do not have matter

00:02:54,840 --> 00:02:58,280
if they're all the same species so

00:02:56,520 --> 00:03:02,280
angels must be of different species

00:02:58,280 --> 00:03:03,960
interesting idea what about the nature

00:03:02,280 --> 00:03:05,430
of intellect well you can use the same

00:03:03,960 --> 00:03:07,080
argument because they'll all educated

00:03:05,430 --> 00:03:10,200
people no intellect has no material

00:03:07,080 --> 00:03:11,520
material substance and therefore we

00:03:10,200 --> 00:03:13,350
can't distinguish the individual

00:03:11,520 --> 00:03:15,600
intellect so all humans share the same

00:03:13,350 --> 00:03:17,790
intellect so that's kind of an

00:03:15,600 --> 00:03:19,110
interesting thing it kind of makes the

00:03:17,790 --> 00:03:20,760
whole talk pointless right if we all

00:03:19,110 --> 00:03:23,000
share same use back then I don't need to

00:03:20,760 --> 00:03:27,540
tell you anything so you know it already

00:03:23,000 --> 00:03:31,020
no well um how about this one

00:03:27,540 --> 00:03:32,459
on the amove ability of the universe God

00:03:31,020 --> 00:03:35,130
cannot move the universe in a straight

00:03:32,459 --> 00:03:36,720
line because to do so would be to cause

00:03:35,130 --> 00:03:40,940
a vacuum to exist where the universe was

00:03:36,720 --> 00:03:43,680
and as we all know vacuum is impossible

00:03:40,940 --> 00:03:45,780
reasonable idea

00:03:43,680 --> 00:03:47,340
I should probably this point point out

00:03:45,780 --> 00:03:54,299
when I talk about 60s I'm talking about

00:03:47,340 --> 00:03:56,579
12 60s and the the ideas here are given

00:03:54,299 --> 00:03:59,040
to some people called the Latin a very

00:03:56,579 --> 00:04:01,769
West and Thomas Aquinas you may have

00:03:59,040 --> 00:04:03,390
heard of and they were considered pretty

00:04:01,769 --> 00:04:06,030
far at the time and there's one thing

00:04:03,390 --> 00:04:08,069
you can expect if you're got fired ideas

00:04:06,030 --> 00:04:14,519
in the Middle Ages and that of course is

00:04:08,069 --> 00:04:18,930
the Inquisition so in 1270 the Bishop of

00:04:14,519 --> 00:04:20,820
Paris had this condemnation of the ideas

00:04:18,930 --> 00:04:22,139
are given previously and here's some

00:04:20,820 --> 00:04:25,350
more of the ideas that were condemned do

00:04:22,139 --> 00:04:26,850
you want loudest you think in 1270 the

00:04:25,350 --> 00:04:29,070
soul separated from the body by death

00:04:26,850 --> 00:04:30,570
cannot suffer from bodily fire God

00:04:29,070 --> 00:04:33,120
cannot grant immortality in corruption

00:04:30,570 --> 00:04:35,160
to a mortal incredible thing God does

00:04:33,120 --> 00:04:36,750
not know singular individuals creatures

00:04:35,160 --> 00:04:39,690
God does not know things other than

00:04:36,750 --> 00:04:41,669
himself and many more if you really want

00:04:39,690 --> 00:04:43,289
to insight into how strange things were

00:04:41,669 --> 00:04:46,889
in the Middle Ages looking at these or

00:04:43,289 --> 00:04:49,229
the condemnation of 1277 it's

00:04:46,889 --> 00:04:52,110
interesting now what I find interesting

00:04:49,229 --> 00:04:54,240
about these ideas is they seem very

00:04:52,110 --> 00:04:58,530
strange to us but they seem strange in a

00:04:54,240 --> 00:05:00,300
very strange way it's not like somebody

00:04:58,530 --> 00:05:01,800
saying dynamic typing is the best way of

00:05:00,300 --> 00:05:03,120
programming that's something I can

00:05:01,800 --> 00:05:04,229
imagine having a reasonable debate about

00:05:03,120 --> 00:05:06,270
something where we have some common

00:05:04,229 --> 00:05:07,860
ground and even though I don't believe

00:05:06,270 --> 00:05:09,990
dynamic typing is the best way to

00:05:07,860 --> 00:05:12,330
program it's you know something I think

00:05:09,990 --> 00:05:14,400
I could discuss whereas if somebody

00:05:12,330 --> 00:05:17,729
asked me to discuss the taxonomy of

00:05:14,400 --> 00:05:19,470
angels angels one species or many

00:05:17,729 --> 00:05:22,260
species I don't know where to start I

00:05:19,470 --> 00:05:23,880
mean what is an angel what are the rules

00:05:22,260 --> 00:05:25,800
nip you dating an angel me like a sort

00:05:23,880 --> 00:05:27,930
of vaguely remembered D&D third edition

00:05:25,800 --> 00:05:31,440
but I don't think that's really going to

00:05:27,930 --> 00:05:33,229
be helping me in this context it's it's

00:05:31,440 --> 00:05:35,909
it's something where I don't even have a

00:05:33,229 --> 00:05:40,740
intellectual basis to start thinking

00:05:35,909 --> 00:05:41,909
about this from so to try to assault pin

00:05:40,740 --> 00:05:44,130
down what's going on here I think we

00:05:41,909 --> 00:05:47,430
need to turn to some wild ideas from the

00:05:44,130 --> 00:05:50,220
60s but here I am talking about 1962 in

00:05:47,430 --> 00:05:52,620
particular and this book the structure

00:05:50,220 --> 00:05:53,710
of scientific revolutions a guy called

00:05:52,620 --> 00:05:57,160
Thomas Cohn

00:05:53,710 --> 00:05:59,230
and this was a landmark publication in

00:05:57,160 --> 00:06:00,940
the philosophy of science and up until

00:05:59,230 --> 00:06:02,380
this time people had seen science is a

00:06:00,940 --> 00:06:05,200
very acceleration approach s and he

00:06:02,380 --> 00:06:08,890
introduced an element of the human to it

00:06:05,200 --> 00:06:12,100
and his model science was divided into

00:06:08,890 --> 00:06:14,230
two stages mainly what was normal

00:06:12,100 --> 00:06:16,090
science when you're running around in

00:06:14,230 --> 00:06:17,680
your lab coat having a good time doing

00:06:16,090 --> 00:06:20,170
experiments writing papers getting

00:06:17,680 --> 00:06:22,840
results everything's working well you're

00:06:20,170 --> 00:06:24,670
working thinning some existing theory so

00:06:22,840 --> 00:06:26,500
your experiments tend to record of that

00:06:24,670 --> 00:06:29,310
theory they make sense when you

00:06:26,500 --> 00:06:31,390
interpret them under that theory but

00:06:29,310 --> 00:06:33,400
every once in a while things go wrong

00:06:31,390 --> 00:06:36,310
you have to storm the barricades and you

00:06:33,400 --> 00:06:38,890
have a scientific revolution and this is

00:06:36,310 --> 00:06:41,170
when the old theory just can't explain

00:06:38,890 --> 00:06:42,850
the results you're seeing sufficiently

00:06:41,170 --> 00:06:44,770
and you have to come up some new ideas a

00:06:42,850 --> 00:06:46,480
whole new way of thinking about the

00:06:44,770 --> 00:06:49,870
world that's going to explain these

00:06:46,480 --> 00:06:51,520
results so examples are the Copernican

00:06:49,870 --> 00:06:53,800
Revolution where we went from the

00:06:51,520 --> 00:06:56,620
Ptolemaic astronomy everything revolves

00:06:53,800 --> 00:06:58,030
around the Sun you got to understand it

00:06:56,620 --> 00:06:59,650
wasn't just everything revolves around

00:06:58,030 --> 00:07:01,390
the Sun with the laws of motions we

00:06:59,650 --> 00:07:03,700
understand them we had things like

00:07:01,390 --> 00:07:05,680
vacuum cannot exist and things like this

00:07:03,700 --> 00:07:08,530
so I sort of worked out theory of the

00:07:05,680 --> 00:07:10,210
universe but a one that didn't really do

00:07:08,530 --> 00:07:11,650
a very good job of explaining the

00:07:10,210 --> 00:07:13,780
observations of the planets we could see

00:07:11,650 --> 00:07:15,670
to the the model that we have today

00:07:13,780 --> 00:07:17,500
where everything's revolve around the

00:07:15,670 --> 00:07:20,250
Sun rather than revolve around the earth

00:07:17,500 --> 00:07:22,770
taking mindset that our own way around

00:07:20,250 --> 00:07:25,390
yeah more recently we had things like

00:07:22,770 --> 00:07:26,890
relativity and quantum physics which

00:07:25,390 --> 00:07:29,740
gave us a completely new way of looking

00:07:26,890 --> 00:07:31,330
at at the world where things a much less

00:07:29,740 --> 00:07:34,570
certain than we believed in the kind of

00:07:31,330 --> 00:07:36,100
Newtonian mechanics and we have these

00:07:34,570 --> 00:07:37,960
strange effects when you move very fast

00:07:36,100 --> 00:07:43,870
your time dilation all that kind of

00:07:37,960 --> 00:07:46,840
stuff so this is what a revolution is

00:07:43,870 --> 00:07:49,210
and this book structure of scientific

00:07:46,840 --> 00:07:51,550
revolutions actually coined the term

00:07:49,210 --> 00:07:53,080
paradigm shift so the next time you see

00:07:51,550 --> 00:07:54,970
a manager telling you what we need is a

00:07:53,080 --> 00:07:56,940
complete paradigm shift you've got a

00:07:54,970 --> 00:08:00,400
philosopher in your ranks is that cool

00:07:56,940 --> 00:08:02,680
don't you use so this idea of going from

00:08:00,400 --> 00:08:03,970
one sort of way of looking at the world

00:08:02,680 --> 00:08:05,189
to another way of looking the world is

00:08:03,970 --> 00:08:09,969
the paradigm shift

00:08:05,189 --> 00:08:11,409
another thing that we have is when we go

00:08:09,969 --> 00:08:13,090
from one paradigm to another there's a

00:08:11,409 --> 00:08:15,789
technical term though in commensurate

00:08:13,090 --> 00:08:18,159
which basically means that from one

00:08:15,789 --> 00:08:19,240
paradigm you have just this way of

00:08:18,159 --> 00:08:20,979
looking in the world that you can't

00:08:19,240 --> 00:08:22,870
really square up with a book in the

00:08:20,979 --> 00:08:25,120
world from the other paradigm and so

00:08:22,870 --> 00:08:26,409
when people from one paradigm talk to

00:08:25,120 --> 00:08:28,419
people in another paradigm they just

00:08:26,409 --> 00:08:29,710
don't make sense to each other and I

00:08:28,419 --> 00:08:32,919
think that's what we sort of saw with

00:08:29,710 --> 00:08:34,870
those medieval philosophies to us they

00:08:32,919 --> 00:08:37,419
just they're not even sensible questions

00:08:34,870 --> 00:08:39,339
to ask let alone looking at the kind of

00:08:37,419 --> 00:08:41,320
answers they've got their arguments just

00:08:39,339 --> 00:08:43,779
why would you even be talking about this

00:08:41,320 --> 00:08:45,399
why do you even be discussing whether

00:08:43,779 --> 00:08:49,750
God can move the universe in a straight

00:08:45,399 --> 00:08:56,170
line it doesn't make sense and that's

00:08:49,750 --> 00:09:00,010
what I mean by incommensurate so we can

00:08:56,170 --> 00:09:01,420
take these ideas and we can look at

00:09:00,010 --> 00:09:03,130
object-oriented and functional

00:09:01,420 --> 00:09:05,829
programming in this lens that's what I

00:09:03,130 --> 00:09:08,470
want to do now the instructional

00:09:05,829 --> 00:09:10,300
programming revolutions so in my mind

00:09:08,470 --> 00:09:13,180
there been three main revolutions in

00:09:10,300 --> 00:09:15,490
history of programming the first one was

00:09:13,180 --> 00:09:17,410
structure programming which started in

00:09:15,490 --> 00:09:19,209
the mid 50's so up until this time

00:09:17,410 --> 00:09:23,470
people were written in pure assembler if

00:09:19,209 --> 00:09:26,920
I had assembly and you had so many ad

00:09:23,470 --> 00:09:28,750
hoc control flow I think most people

00:09:26,920 --> 00:09:30,790
probably if you did a computer science

00:09:28,750 --> 00:09:33,070
degree you'll learn a bit about this in

00:09:30,790 --> 00:09:34,480
1968 we had this publication Gogi

00:09:33,070 --> 00:09:37,570
statement considered harmful which is

00:09:34,480 --> 00:09:38,829
kind of like the set the intellectual

00:09:37,570 --> 00:09:41,920
programs you like of structured

00:09:38,829 --> 00:09:43,660
programming and the idea was to provide

00:09:41,920 --> 00:09:45,760
some structure to the control flow

00:09:43,660 --> 00:09:47,890
that's where we can have four loops and

00:09:45,760 --> 00:09:50,290
while loops I think we can say by the

00:09:47,890 --> 00:09:51,760
80s and the mid 80s this idea of

00:09:50,290 --> 00:09:55,480
structured programming dominated the

00:09:51,760 --> 00:09:57,490
industry so I think C was probably the

00:09:55,480 --> 00:10:00,269
most commonly used language then turbo

00:09:57,490 --> 00:10:03,370
Pascal those type of things

00:10:00,269 --> 00:10:05,470
structured programming next we had

00:10:03,370 --> 00:10:08,589
object-oriented programming started

00:10:05,470 --> 00:10:13,600
sometime in 60s I think 67 similar 67

00:10:08,589 --> 00:10:15,910
was the first language hit is maybe it's

00:10:13,600 --> 00:10:18,730
sort of high-water mark is small talk 83

00:10:15,910 --> 00:10:24,339
and then by the late 90s certainly

00:10:18,730 --> 00:10:26,199
say dominated industry C++ and Java you

00:10:24,339 --> 00:10:29,339
know function programming you might

00:10:26,199 --> 00:10:31,600
recognize face there behind the slide

00:10:29,339 --> 00:10:33,610
you could say it may be started in the

00:10:31,600 --> 00:10:36,100
50s was less but I would say it started

00:10:33,610 --> 00:10:38,350
more in the mid 70s with scheme over

00:10:36,100 --> 00:10:41,079
here in the US and ml over in Edinburgh

00:10:38,350 --> 00:10:42,779
really bringing for the ideas that we

00:10:41,079 --> 00:10:45,220
have in modern functional programming

00:10:42,779 --> 00:10:46,449
what's quite interesting here is if you

00:10:45,220 --> 00:10:48,670
look at this timeline you see things

00:10:46,449 --> 00:10:51,250
that are very recent so Haskell 1990

00:10:48,670 --> 00:10:53,970
monads only 1995 that's really quite

00:10:51,250 --> 00:10:57,100
recent a picutre functors something that

00:10:53,970 --> 00:11:00,550
you may or may not use quite a bit 2007

00:10:57,100 --> 00:11:02,350
and we could go down this list things

00:11:00,550 --> 00:11:05,019
like the the free monitor only really

00:11:02,350 --> 00:11:06,610
became popularized or widely known in

00:11:05,019 --> 00:11:10,209
the program community within the last

00:11:06,610 --> 00:11:12,610
five years or so - hope ala carte is one

00:11:10,209 --> 00:11:16,810
of the publication's around I think

00:11:12,610 --> 00:11:19,300
that's 2010 so functional programming is

00:11:16,810 --> 00:11:21,820
really quite new this of the foundations

00:11:19,300 --> 00:11:23,560
are old but the fully developed theory a

00:11:21,820 --> 00:11:25,389
functional programming is quite new and

00:11:23,560 --> 00:11:27,190
is it's ongoing right now that's so this

00:11:25,389 --> 00:11:29,649
is this is the revolution that is

00:11:27,190 --> 00:11:31,630
sweeping the industry right now so we

00:11:29,649 --> 00:11:33,610
are going through a change in the

00:11:31,630 --> 00:11:35,769
industry from object into programming to

00:11:33,610 --> 00:11:37,569
functional programming and you look

00:11:35,769 --> 00:11:39,610
around the industry uses everywhere so

00:11:37,569 --> 00:11:42,610
obviously we have Scala on the JVM and

00:11:39,610 --> 00:11:43,839
of course as Carla runs on JavaScript

00:11:42,610 --> 00:11:44,920
and will no doubt be running a native

00:11:43,839 --> 00:11:49,269
code as well as we'll find out later

00:11:44,920 --> 00:11:52,420
today but other platforms iOS we got

00:11:49,269 --> 00:11:54,639
Swift very new rust for systems

00:11:52,420 --> 00:11:56,470
programming in the JavaScript world

00:11:54,639 --> 00:11:58,329
other than Scala we have lots of really

00:11:56,470 --> 00:12:01,720
interesting stuff going on Elm and pure

00:11:58,329 --> 00:12:03,220
script flow which is a type checker and

00:12:01,720 --> 00:12:05,980
react coming out of Facebook using

00:12:03,220 --> 00:12:07,740
functional ideas distributive systems of

00:12:05,980 --> 00:12:09,730
course Scala lives in there as well but

00:12:07,740 --> 00:12:10,750
thank just like pony are doing really

00:12:09,730 --> 00:12:12,130
interesting things and bringing

00:12:10,750 --> 00:12:15,880
functional programming ideas type

00:12:12,130 --> 00:12:19,149
systems to distributed system so every

00:12:15,880 --> 00:12:21,399
interesting stuff there I think so if

00:12:19,149 --> 00:12:22,600
you accept this model of paradigm shift

00:12:21,399 --> 00:12:24,519
and that the functional programming

00:12:22,600 --> 00:12:27,069
revolution is the paradigm shift

00:12:24,519 --> 00:12:28,390
happening in our industry then the

00:12:27,069 --> 00:12:30,730
obvious thing to ask is what is the

00:12:28,390 --> 00:12:33,460
functional programming paradigm

00:12:30,730 --> 00:12:37,540
and how does an object-oriented

00:12:33,460 --> 00:12:41,500
programmer make the change so I want to

00:12:37,540 --> 00:12:46,150
talk about that now what does it mean to

00:12:41,500 --> 00:12:48,280
be a functional programmer in particular

00:12:46,150 --> 00:12:50,290
well I think of the paradigm you think

00:12:48,280 --> 00:12:52,210
it was the basis of your of your

00:12:50,290 --> 00:12:54,160
thinking about programs so how would you

00:12:52,210 --> 00:12:56,770
how would you describe programs or how

00:12:54,160 --> 00:12:59,920
do you think about programs working in

00:12:56,770 --> 00:13:02,260
terms of sort of program executing or

00:12:59,920 --> 00:13:04,600
not executing and how you view them and

00:13:02,260 --> 00:13:06,070
then what is your son aesthetic what do

00:13:04,600 --> 00:13:07,600
you see as being good caring how do you

00:13:06,070 --> 00:13:09,700
separate good code from bad code how do

00:13:07,600 --> 00:13:14,740
you decide how you should use the

00:13:09,700 --> 00:13:17,650
language constructs to construct code so

00:13:14,740 --> 00:13:20,830
to give a bit context in fact let's do a

00:13:17,650 --> 00:13:22,330
bit of audience participation I've seen

00:13:20,830 --> 00:13:24,760
most people to have experience with our

00:13:22,330 --> 00:13:27,000
lives so he would like to tell me how I

00:13:24,760 --> 00:13:28,600
think in our program I might think about

00:13:27,000 --> 00:13:34,030
programs what do you think the

00:13:28,600 --> 00:13:36,100
components of programs are anyone it's

00:13:34,030 --> 00:13:38,490
not a trick question you can't get the

00:13:36,100 --> 00:13:38,490
answer wrong

00:13:38,640 --> 00:13:43,870
sorry nouns yeah okay so nouns nouns are

00:13:42,490 --> 00:13:53,290
objects yeah

00:13:43,870 --> 00:13:55,210
dude how'd yeah right so an object is

00:13:53,290 --> 00:13:58,630
something captivating data and the

00:13:55,210 --> 00:13:59,950
methods that work on that data and that

00:13:58,630 --> 00:14:04,080
is coming object is a noun yep

00:13:59,950 --> 00:14:10,270
definitely agree that anything else

00:14:04,080 --> 00:14:10,950
how Dex communicate no Wow tough

00:14:10,270 --> 00:14:13,990
audience

00:14:10,950 --> 00:14:17,230
yeah messages the message passing by

00:14:13,990 --> 00:14:19,270
degrade anything else you're all Scala

00:14:17,230 --> 00:14:20,500
programs already all complain competing

00:14:19,270 --> 00:14:21,910
the function programming paradigm and

00:14:20,500 --> 00:14:29,160
what I'm talking about it's absolute

00:14:21,910 --> 00:14:30,760
nonsense it doesn't make any sense yeah

00:14:29,160 --> 00:14:32,620
yeah definitely

00:14:30,760 --> 00:14:35,560
okay great so we've got some some

00:14:32,620 --> 00:14:37,900
answers here so I would say objects

00:14:35,560 --> 00:14:40,120
message passing polymorphism maybe be

00:14:37,900 --> 00:14:41,740
the fundamentals of alternative

00:14:40,120 --> 00:14:43,330
programming the problem with this stuff

00:14:41,740 --> 00:14:44,529
is not very clearly defined you sort of

00:14:43,330 --> 00:14:46,360
become like

00:14:44,529 --> 00:14:47,800
biblical scholars of the 1260 taiking

00:14:46,360 --> 00:14:53,889
about alan case writing what the true

00:14:47,800 --> 00:14:55,660
meaning of oh where is that yeah you

00:14:53,889 --> 00:14:58,089
mentioned solid principles single

00:14:55,660 --> 00:14:59,860
responsibility principle i have here so

00:14:58,089 --> 00:15:01,569
these are some of the things that object

00:14:59,860 --> 00:15:03,759
orange programmers use to think about

00:15:01,569 --> 00:15:08,230
currently and to guide themselves to

00:15:03,759 --> 00:15:10,749
writing good code important points here

00:15:08,230 --> 00:15:12,059
is this is quite an informal model like

00:15:10,749 --> 00:15:15,699
I said earlier use this kind of

00:15:12,059 --> 00:15:17,319
discussion of Alan Kay's writing is how

00:15:15,699 --> 00:15:20,319
do you interpret is writing to determine

00:15:17,319 --> 00:15:21,670
the true oo nature so it's quite

00:15:20,319 --> 00:15:23,199
informal it's also quite anthropomorphic

00:15:21,670 --> 00:15:25,629
which I think it's just interesting to

00:15:23,199 --> 00:15:28,600
point out this idea of objects being

00:15:25,629 --> 00:15:33,579
kind of active things talking to each

00:15:28,600 --> 00:15:36,850
other by message passing and it's also I

00:15:33,579 --> 00:15:38,230
find quite a dynamic model so one of the

00:15:36,850 --> 00:15:39,550
things about polymorphisms that many

00:15:38,230 --> 00:15:40,959
different objects can accept the same

00:15:39,550 --> 00:15:44,620
message and whatever they do is that

00:15:40,959 --> 00:15:45,699
message is is up to them so the meaning

00:15:44,620 --> 00:15:47,620
of your program what your program does

00:15:45,699 --> 00:15:52,180
is really only truly known at runtime

00:15:47,620 --> 00:15:55,870
and that I say is fairly important they

00:15:52,180 --> 00:15:57,519
know they're thinking no anyone disagree

00:15:55,870 --> 00:16:01,689
with that or sort of like to have extra

00:15:57,519 --> 00:16:02,740
points okay you're a great fantastic so

00:16:01,689 --> 00:16:04,509
let's move on to functional programming

00:16:02,740 --> 00:16:06,850
then had a functional programming

00:16:04,509 --> 00:16:08,980
potential programs think about I would

00:16:06,850 --> 00:16:10,120
say the cool thing for an FP person is

00:16:08,980 --> 00:16:12,730
you look at a program as a

00:16:10,120 --> 00:16:16,959
transformation data secret sequence of

00:16:12,730 --> 00:16:21,459
transformations and if I had to boil

00:16:16,959 --> 00:16:23,529
down into two ideas what are the core

00:16:21,459 --> 00:16:26,139
things that functional programmers value

00:16:23,529 --> 00:16:28,120
I would say simplicity and static

00:16:26,139 --> 00:16:32,350
reasoning and these require more

00:16:28,120 --> 00:16:33,279
exploration so simplicity simplicity is

00:16:32,350 --> 00:16:34,899
one of these kind of words that

00:16:33,279 --> 00:16:36,970
programmers used to hit other

00:16:34,899 --> 00:16:40,300
programmers with migrate is simple yours

00:16:36,970 --> 00:16:42,790
is convoluted you know and often people

00:16:40,300 --> 00:16:44,319
what they mean by simplicity is my code

00:16:42,790 --> 00:16:47,230
uses things I understand your code

00:16:44,319 --> 00:16:49,740
doesn't so we need to be clear on

00:16:47,230 --> 00:16:49,740
simplicity

00:16:49,770 --> 00:16:53,850
and you know many languages were claimed

00:16:52,230 --> 00:16:55,830
to be simple Python claimed to be a

00:16:53,850 --> 00:16:57,540
simple language go particular claims to

00:16:55,830 --> 00:17:00,660
be a simple language that's one of the

00:16:57,540 --> 00:17:03,630
main sort of points I make in their kind

00:17:00,660 --> 00:17:06,210
of philosophy and so if go is a very

00:17:03,630 --> 00:17:08,670
unfunctional language haha how is this

00:17:06,210 --> 00:17:10,590
simplicity dis different to the kind of

00:17:08,670 --> 00:17:14,220
simplicity I'm talking about maybe the

00:17:10,590 --> 00:17:16,830
simplicity of scarlet or Haskell so what

00:17:14,220 --> 00:17:19,050
I mean by simplicity is if there's few

00:17:16,830 --> 00:17:20,460
concepts as possible at all scales and

00:17:19,050 --> 00:17:23,460
it's this at all scales which is

00:17:20,460 --> 00:17:24,930
important bit so having a few possible

00:17:23,460 --> 00:17:26,220
concepts at the low level and at the

00:17:24,930 --> 00:17:27,150
high level and let's see some

00:17:26,220 --> 00:17:29,550
implications of that

00:17:27,150 --> 00:17:31,740
so one notification at the low level you

00:17:29,550 --> 00:17:33,480
have control structures in your typical

00:17:31,740 --> 00:17:35,130
over language sort of inspired by

00:17:33,480 --> 00:17:36,720
structural program structure programming

00:17:35,130 --> 00:17:38,940
you have four loops and while loops and

00:17:36,720 --> 00:17:40,140
do loops and you have recursion and the

00:17:38,940 --> 00:17:42,120
functional programming language what you

00:17:40,140 --> 00:17:43,470
say is let's get rid of most of those

00:17:42,120 --> 00:17:44,970
who just have recursion because

00:17:43,470 --> 00:17:47,250
recursion does everything you can do is

00:17:44,970 --> 00:17:48,720
have looping constructs and more so why

00:17:47,250 --> 00:17:50,010
have it these extra things when you

00:17:48,720 --> 00:17:54,540
don't need them you can just have terror

00:17:50,010 --> 00:17:57,360
curse of loops and everyone happy then

00:17:54,540 --> 00:17:59,910
the high level should look at

00:17:57,360 --> 00:18:02,370
abstraction so if we have these things

00:17:59,910 --> 00:18:05,160
listed I option a future a be familiar

00:18:02,370 --> 00:18:07,320
to scarlet programmers in your typical

00:18:05,160 --> 00:18:09,750
object only language what can you say

00:18:07,320 --> 00:18:14,370
about these things together and I think

00:18:09,750 --> 00:18:15,540
the answer is nothing I'm sure you

00:18:14,370 --> 00:18:18,570
looked at that and thought well that's a

00:18:15,540 --> 00:18:21,240
monad but our languages don't typically

00:18:18,570 --> 00:18:22,650
express the concept of monads or they

00:18:21,240 --> 00:18:24,330
don't have the language features like hi

00:18:22,650 --> 00:18:27,800
kind of types needed to make this

00:18:24,330 --> 00:18:30,060
abstraction an abstraction makes things

00:18:27,800 --> 00:18:31,680
simple because it makes different things

00:18:30,060 --> 00:18:34,470
the same so you can have one mental

00:18:31,680 --> 00:18:36,330
model like them on add and you can think

00:18:34,470 --> 00:18:39,030
about all these different things using

00:18:36,330 --> 00:18:40,580
that one mental model that also can

00:18:39,030 --> 00:18:42,930
explain why things like monads are

00:18:40,580 --> 00:18:44,700
difficult to understand because they are

00:18:42,930 --> 00:18:46,230
so abstract they get that power from

00:18:44,700 --> 00:18:47,720
being abstract because you can explain

00:18:46,230 --> 00:18:50,070
many different things and it's one way

00:18:47,720 --> 00:18:52,260
but we all have difficulty reasoning

00:18:50,070 --> 00:18:54,390
about abstract concepts so it can be

00:18:52,260 --> 00:19:00,030
difficult to learn how to use that

00:18:54,390 --> 00:19:04,160
abstraction the things Rick Ricky said

00:19:00,030 --> 00:19:09,060
simple and easy are not the same thing

00:19:04,160 --> 00:19:09,810
another way we can look at aspects of

00:19:09,060 --> 00:19:12,900
the kind of functional programming

00:19:09,810 --> 00:19:16,860
paradigm is how we model evaluation of a

00:19:12,900 --> 00:19:18,830
program only said that oh whoa what view

00:19:16,860 --> 00:19:20,880
of a program is a very dynamic process

00:19:18,830 --> 00:19:22,560
whatever happens at runtime is what

00:19:20,880 --> 00:19:24,680
happens because your polymorph and so on

00:19:22,560 --> 00:19:26,670
an object sending each other methods

00:19:24,680 --> 00:19:30,180
whereas the functional programming world

00:19:26,670 --> 00:19:32,790
we have this model substitution that we

00:19:30,180 --> 00:19:35,970
leaned on heavily so here is an example

00:19:32,790 --> 00:19:37,860
program one plus one and can anyone tell

00:19:35,970 --> 00:19:41,240
me what this evaluates to it's not a

00:19:37,860 --> 00:19:43,410
trick question again come on

00:19:41,240 --> 00:19:44,640
okay thank you I was really begin to

00:19:43,410 --> 00:19:48,740
worry about the Equality of the u.s.

00:19:44,640 --> 00:19:52,400
education system so that evaluates to 2

00:19:48,740 --> 00:19:57,300
right and if you have this program here

00:19:52,400 --> 00:19:59,370
it's complicated one what we see is it's

00:19:57,300 --> 00:20:01,380
got one plus one we saw earlier was two

00:19:59,370 --> 00:20:03,690
and one plus one we said earlier was two

00:20:01,380 --> 00:20:05,790
and what substitution says is wherever

00:20:03,690 --> 00:20:08,880
you see an expression you can substitute

00:20:05,790 --> 00:20:10,080
in the value so we can say r1 plus 1 I

00:20:08,880 --> 00:20:12,630
know what that is that's 2 and that one

00:20:10,080 --> 00:20:15,540
was also 2 so we get 2 plus 2 I think

00:20:12,630 --> 00:20:17,330
you tell me or 2 plus 2 is excellent for

00:20:15,540 --> 00:20:19,710
ok there we go

00:20:17,330 --> 00:20:21,360
so hopefully this seemed really kind of

00:20:19,710 --> 00:20:22,470
silly and stupid to you and that's kind

00:20:21,360 --> 00:20:25,320
of the point is that this is really

00:20:22,470 --> 00:20:27,210
really easy it's simple it's just one

00:20:25,320 --> 00:20:30,000
concept so my definition of simplicity

00:20:27,210 --> 00:20:32,580
this is this one concept it's very easy

00:20:30,000 --> 00:20:36,480
to work with we we learn how to do this

00:20:32,580 --> 00:20:42,210
in probably primary school maybe high

00:20:36,480 --> 00:20:44,510
school yeah I don't know you might call

00:20:42,210 --> 00:20:46,950
the schools different things here

00:20:44,510 --> 00:20:48,990
another point is that is compositional

00:20:46,950 --> 00:20:51,630
so when we looked at the meaning of 1

00:20:48,990 --> 00:20:53,070
plus 1 plus 1 plus 1 we can look at

00:20:51,630 --> 00:20:55,620
these the meaning of these two things

00:20:53,070 --> 00:20:57,360
separately irineu that this part of the

00:20:55,620 --> 00:20:59,790
expression site is not going to affect

00:20:57,360 --> 00:21:02,280
the meaning of this part so we can

00:20:59,790 --> 00:21:04,410
reason about them individually and then

00:21:02,280 --> 00:21:07,410
the meaning of the two individual parts

00:21:04,410 --> 00:21:07,860
just comes from combining those two bits

00:21:07,410 --> 00:21:10,410
together

00:21:07,860 --> 00:21:11,490
so that's compositionality for you where

00:21:10,410 --> 00:21:14,280
you can think about things in isolation

00:21:11,490 --> 00:21:20,830
and income

00:21:14,280 --> 00:21:22,630
so substitution is a a very nice thing

00:21:20,830 --> 00:21:25,660
and how is that expressed in our our

00:21:22,630 --> 00:21:28,300
language well one way is at the low

00:21:25,660 --> 00:21:30,550
level we have expression oriented

00:21:28,300 --> 00:21:31,930
languages so in Java if you're doing

00:21:30,550 --> 00:21:34,960
some kind of comparison you might write

00:21:31,930 --> 00:21:38,080
something like this because if is not an

00:21:34,960 --> 00:21:40,510
expression doesn't return a value you'd

00:21:38,080 --> 00:21:43,710
have some variable and you just have to

00:21:40,510 --> 00:21:47,590
sign the variable this fan of this

00:21:43,710 --> 00:21:50,370
comparison cross in Scala you can write

00:21:47,590 --> 00:21:52,900
like this instead about x equals if

00:21:50,370 --> 00:21:55,930
that's a bit of a mental leap for

00:21:52,900 --> 00:21:58,810
someone used to if being a statement non

00:21:55,930 --> 00:22:00,520
expression tend to make but it does give

00:21:58,810 --> 00:22:02,230
you this is one rule this is however

00:22:00,520 --> 00:22:04,900
then you can just use substitution here

00:22:02,230 --> 00:22:06,670
to think about this you can't think

00:22:04,900 --> 00:22:08,650
about this just with substitution

00:22:06,670 --> 00:22:12,370
because you have state and state break

00:22:08,650 --> 00:22:14,290
substitution okay so that's kind of how

00:22:12,370 --> 00:22:17,220
things work at a low level with trying

00:22:14,290 --> 00:22:20,410
to maintain substitution at a high level

00:22:17,220 --> 00:22:22,930
something we often see is separating

00:22:20,410 --> 00:22:25,570
describing and running a computation

00:22:22,930 --> 00:22:27,730
that sounds really fancy but it's it's a

00:22:25,570 --> 00:22:30,100
reasonably simple idea and here's a

00:22:27,730 --> 00:22:32,200
small sort of small example using kind

00:22:30,100 --> 00:22:34,930
of IO monad pseudocode let me explain

00:22:32,200 --> 00:22:36,970
what's going on here hopefully you can

00:22:34,930 --> 00:22:39,100
read this just as courage here we're

00:22:36,970 --> 00:22:40,690
opening a file when reading all the

00:22:39,100 --> 00:22:43,060
lines from the file we're printing them

00:22:40,690 --> 00:22:45,430
all out to the console I guess and then

00:22:43,060 --> 00:22:46,570
we're closing the file and returning the

00:22:45,430 --> 00:22:50,320
number of lines that were in the the

00:22:46,570 --> 00:22:52,900
file what's important about this code is

00:22:50,320 --> 00:22:56,320
nothing actually happens this code

00:22:52,900 --> 00:22:58,330
doesn't do anything until we call run so

00:22:56,320 --> 00:23:00,010
here we have an IO int a program that

00:22:58,330 --> 00:23:03,150
when we run it will generate an int and

00:23:00,010 --> 00:23:07,870
do some IO and here we run the program

00:23:03,150 --> 00:23:10,120
and we get back an integer and the

00:23:07,870 --> 00:23:12,670
important thing about this is that until

00:23:10,120 --> 00:23:15,880
we run things so we actually do this

00:23:12,670 --> 00:23:18,490
running bit we can use substitution in

00:23:15,880 --> 00:23:19,870
here so substitution is maintaining

00:23:18,490 --> 00:23:21,820
substitution is what motivates

00:23:19,870 --> 00:23:23,470
techniques like monads

00:23:21,820 --> 00:23:25,330
or one of the motivations for techniques

00:23:23,470 --> 00:23:26,220
like monads so it allows the maintain

00:23:25,330 --> 00:23:29,070
substitution

00:23:26,220 --> 00:23:38,809
programs let me do kind of high-level

00:23:29,070 --> 00:23:38,809
stuff right another way where we see

00:23:38,870 --> 00:23:44,009
differences between o and F P is in the

00:23:41,220 --> 00:23:46,320
use of type so if in a language like

00:23:44,009 --> 00:23:46,950
Java types are really I feel like

00:23:46,320 --> 00:23:48,389
busywork

00:23:46,950 --> 00:23:50,460
you're just doing them to get the

00:23:48,389 --> 00:23:52,169
compile to shut the hell up and the

00:23:50,460 --> 00:23:56,250
trade-off is you get the compiler shut

00:23:52,169 --> 00:23:57,509
up you get fast code and you know

00:23:56,250 --> 00:24:00,480
there's quite a sort of intellectual

00:23:57,509 --> 00:24:02,399
movement in oo world away from static

00:24:00,480 --> 00:24:05,690
typing to the dynamic typing is small

00:24:02,399 --> 00:24:08,149
talk dynamic types Ruby in Python so on

00:24:05,690 --> 00:24:10,340
but in functional programming we have a

00:24:08,149 --> 00:24:12,779
different view which is that types

00:24:10,340 --> 00:24:14,429
integral to helping us to understand and

00:24:12,779 --> 00:24:19,679
to write our program so let me give you

00:24:14,429 --> 00:24:21,629
just a quick examples of that what does

00:24:19,679 --> 00:24:24,720
this method do without seeing the body

00:24:21,629 --> 00:24:31,669
can anybody not Raul tell me what the

00:24:24,720 --> 00:24:37,529
method is gonna do so yeah returns in

00:24:31,669 --> 00:24:47,490
and why is that the case is gonna tell

00:24:37,529 --> 00:24:49,440
me no okay right okay yeah yeah so yeah

00:24:47,490 --> 00:24:52,830
we have type erasure which basically

00:24:49,440 --> 00:24:55,110
means that type is the type this generic

00:24:52,830 --> 00:24:58,559
type is an abstraction boundary you've

00:24:55,110 --> 00:25:00,990
said here that there is some some type a

00:24:58,559 --> 00:25:03,600
but when you inside the body of this

00:25:00,990 --> 00:25:04,950
code and then we put a body this is

00:25:03,600 --> 00:25:06,690
anything can write so it's the identity

00:25:04,950 --> 00:25:10,259
function or their dental method I guess

00:25:06,690 --> 00:25:12,389
in Scala you can't break open this

00:25:10,259 --> 00:25:14,309
abstraction boundary you can't look at

00:25:12,389 --> 00:25:16,590
what this type is at runtime so there's

00:25:14,309 --> 00:25:20,870
only one thing you can do there you have

00:25:16,590 --> 00:25:20,870
to return or throw an exception diverge

00:25:21,379 --> 00:25:25,950
so what this means is that if you're the

00:25:23,909 --> 00:25:27,779
programmer you don't have to know what

00:25:25,950 --> 00:25:29,490
is going on inside this function when

00:25:27,779 --> 00:25:32,309
you look at the type as a kind of a user

00:25:29,490 --> 00:25:35,159
of this this method it doesn't matter

00:25:32,309 --> 00:25:36,809
what it's called what it's doing you can

00:25:35,159 --> 00:25:38,610
only do one thing so you can use the

00:25:36,809 --> 00:25:39,600
type to help you understand the code the

00:25:38,610 --> 00:25:41,660
type here is giving you

00:25:39,600 --> 00:25:45,750
Meishan this has to be the identity

00:25:41,660 --> 00:25:47,100
function here's another example a little

00:25:45,750 --> 00:25:52,230
bit more complicated

00:25:47,100 --> 00:25:54,090
we got a right map on an option this is

00:25:52,230 --> 00:25:56,750
something we often do is a case items

00:25:54,090 --> 00:25:58,799
training it's something that the new

00:25:56,750 --> 00:26:00,510
scarves developers find quite

00:25:58,799 --> 00:26:02,760
challenging or but I want to show you

00:26:00,510 --> 00:26:04,440
that really it's just following the

00:26:02,760 --> 00:26:07,049
types type is it going to help us write

00:26:04,440 --> 00:26:08,160
this code so because you're a tough

00:26:07,049 --> 00:26:10,380
audience I'm not going to ask you to do

00:26:08,160 --> 00:26:12,059
this I'm gonna lead you through it there

00:26:10,380 --> 00:26:14,039
are three steps so we'll start with map

00:26:12,059 --> 00:26:18,210
this is the signature of map I've got a

00:26:14,039 --> 00:26:20,370
type by the ocean of that a in there if

00:26:18,210 --> 00:26:23,220
you write the body that first thing we

00:26:20,370 --> 00:26:26,070
know about option is is an algebraic

00:26:23,220 --> 00:26:27,750
data type being an algebraic data type

00:26:26,070 --> 00:26:30,960
means we can just apply structural

00:26:27,750 --> 00:26:35,610
recursion and this gets us this skeleton

00:26:30,960 --> 00:26:39,059
straightaway okay so none and some

00:26:35,610 --> 00:26:42,299
spinner enough okay now let's look at

00:26:39,059 --> 00:26:43,650
this first part here we have once you

00:26:42,299 --> 00:26:47,700
really have to return something of type

00:26:43,650 --> 00:26:50,010
option B the only way we have

00:26:47,700 --> 00:26:52,350
constructing something of option B is

00:26:50,010 --> 00:26:55,110
using sorry of type B is using this

00:26:52,350 --> 00:26:58,080
function from A to B where we have

00:26:55,110 --> 00:27:00,659
nothing of type a to give to that

00:26:58,080 --> 00:27:03,750
function there's only one possible thing

00:27:00,659 --> 00:27:07,980
we can do here we have to return none

00:27:03,750 --> 00:27:09,539
it's the only possible result that will

00:27:07,980 --> 00:27:14,429
make this code compile putting none in

00:27:09,539 --> 00:27:16,880
there look at the second case well what

00:27:14,429 --> 00:27:20,190
can we do here we could return none or

00:27:16,880 --> 00:27:21,539
we have something of type A here we

00:27:20,190 --> 00:27:23,520
could put that into this function get to

00:27:21,539 --> 00:27:29,940
that something of type B and wrap that

00:27:23,520 --> 00:27:31,980
up in a sum getting some F of a so we

00:27:29,940 --> 00:27:33,870
had two choices there so we had to do a

00:27:31,980 --> 00:27:35,789
minuscule amount of thinking to

00:27:33,870 --> 00:27:38,640
distinguish the correct option from

00:27:35,789 --> 00:27:40,950
incorrect one but largely the types are

00:27:38,640 --> 00:27:42,270
guiding us towards the solution they're

00:27:40,950 --> 00:27:43,950
only two possible paths we could have

00:27:42,270 --> 00:27:45,450
gone down that the type system would let

00:27:43,950 --> 00:27:48,330
us go down there we have to choose the

00:27:45,450 --> 00:27:50,760
right one so this is an example of how

00:27:48,330 --> 00:27:53,080
types guide you to the implementation of

00:27:50,760 --> 00:27:55,210
code you get the structure the type

00:27:53,080 --> 00:27:58,180
correct the code and often cases just

00:27:55,210 --> 00:27:59,800
follows automatically and taking that to

00:27:58,180 --> 00:28:02,380
its ultimate conclusion is doing stuff

00:27:59,800 --> 00:28:05,100
flight we do a shapeless type driven

00:28:02,380 --> 00:28:08,290
boil flow generation so the example is

00:28:05,100 --> 00:28:09,550
generating jason's serialization just

00:28:08,290 --> 00:28:12,490
from the structure of your types

00:28:09,550 --> 00:28:14,740
something you do in dynamic languages

00:28:12,490 --> 00:28:16,480
typically with reflection you can do

00:28:14,740 --> 00:28:18,760
purely at compile time with shapeless

00:28:16,480 --> 00:28:21,310
and you get performance advantages and

00:28:18,760 --> 00:28:24,700
the safety guarantees of doing this

00:28:21,310 --> 00:28:25,830
stuff in a typed manner sounds really

00:28:24,700 --> 00:28:30,450
powerful stuff

00:28:25,830 --> 00:28:33,910
so a quick summary of what we've seen

00:28:30,450 --> 00:28:35,950
we've seen simplicity and static

00:28:33,910 --> 00:28:38,890
reasoning this idea about understanding

00:28:35,950 --> 00:28:41,650
your code before it's run I think are

00:28:38,890 --> 00:28:46,390
that the main things that a functional

00:28:41,650 --> 00:28:47,950
program evaluator Vuli into this idea of

00:28:46,390 --> 00:28:50,860
understanding occurred before we run it

00:28:47,950 --> 00:28:53,080
and some of the consequences we've seen

00:28:50,860 --> 00:28:55,690
in this are substitution model of

00:28:53,080 --> 00:28:57,160
evaluation which is very easy to work is

00:28:55,690 --> 00:28:59,980
very simple which is one rule we can

00:28:57,160 --> 00:29:01,180
apply to all of our programs and it

00:28:59,980 --> 00:29:05,620
helps us to understand our programs

00:29:01,180 --> 00:29:08,680
before we run them composition is very

00:29:05,620 --> 00:29:09,610
useful for understanding programs again

00:29:08,680 --> 00:29:11,470
because you can understand a little

00:29:09,610 --> 00:29:13,810
class in isolation so we try to maintain

00:29:11,470 --> 00:29:15,430
compositional code therefore you don't

00:29:13,810 --> 00:29:17,080
have to know the whole code base to

00:29:15,430 --> 00:29:20,770
understand just a bit you're interested

00:29:17,080 --> 00:29:22,090
in types again help us as we've seen it

00:29:20,770 --> 00:29:25,150
help us write carry they help us reason

00:29:22,090 --> 00:29:26,800
about code and one of the other things

00:29:25,150 --> 00:29:28,480
here is this precision so you have these

00:29:26,800 --> 00:29:30,880
much more precise definitions of

00:29:28,480 --> 00:29:32,620
concepts than we saw in in the overworld

00:29:30,880 --> 00:29:35,170
it's much more sort of mathematical feel

00:29:32,620 --> 00:29:38,350
which does scare some people

00:29:35,170 --> 00:29:43,800
I think it's ultimately an important

00:29:38,350 --> 00:29:46,510
part of it so the next question is then

00:29:43,800 --> 00:29:49,060
if you're not a programmer like I think

00:29:46,510 --> 00:29:54,670
most people are your background Aero how

00:29:49,060 --> 00:29:58,770
do you cross from arrow to FP now one

00:29:54,670 --> 00:30:03,510
theory is that that's just of can't

00:29:58,770 --> 00:30:07,160
she was give up and die but I don't

00:30:03,510 --> 00:30:11,610
think that's necessarily the truth

00:30:07,160 --> 00:30:13,110
luckily so what I find really

00:30:11,610 --> 00:30:18,030
interesting is if you look at kind of

00:30:13,110 --> 00:30:19,860
the intellectual history of Polly the

00:30:18,030 --> 00:30:22,309
design pattern staff that was started in

00:30:19,860 --> 00:30:28,290
94 and I think it was pretty active

00:30:22,309 --> 00:30:30,000
through 2000s a lot of FP ideas are

00:30:28,290 --> 00:30:33,809
present in object-oriented design

00:30:30,000 --> 00:30:35,580
patterns almost people familiar with

00:30:33,809 --> 00:30:40,679
design pens anyone not heard of design

00:30:35,580 --> 00:30:42,720
patterns okay right so the daily patents

00:30:40,679 --> 00:30:44,820
in Omo were kind of like they were ways

00:30:42,720 --> 00:30:46,500
of using our languages collections of

00:30:44,820 --> 00:30:48,210
our languages features if it said this

00:30:46,500 --> 00:30:49,620
is a good way of using classes and

00:30:48,210 --> 00:30:51,000
objects and so on to achieve this one

00:30:49,620 --> 00:30:53,940
particular goal here's how you might do

00:30:51,000 --> 00:30:55,679
things possibly the best known patent

00:30:53,940 --> 00:30:56,850
and the one that everyone hates is the

00:30:55,679 --> 00:31:00,929
singleton where you only want to have

00:30:56,850 --> 00:31:02,160
one instance of a class so you can say

00:31:00,929 --> 00:31:05,940
in scarlet we don't need Singleton's

00:31:02,160 --> 00:31:08,130
because we have objects more interesting

00:31:05,940 --> 00:31:10,260
are things like these patterns chain of

00:31:08,130 --> 00:31:12,270
responsibility command and strategy

00:31:10,260 --> 00:31:14,100
pattern I'm not going to go into details

00:31:12,270 --> 00:31:17,370
of what they are I don't even really

00:31:14,100 --> 00:31:18,360
remember to be honest but what's what is

00:31:17,370 --> 00:31:19,920
interesting about them is they're

00:31:18,360 --> 00:31:23,580
already just variations on first-class

00:31:19,920 --> 00:31:26,580
functions so yeah the command pattern is

00:31:23,580 --> 00:31:27,600
sort of wrapping up in an object command

00:31:26,580 --> 00:31:29,390
if you like something's gonna do

00:31:27,600 --> 00:31:31,470
something that's a function basically

00:31:29,390 --> 00:31:34,350
though it might have some state in here

00:31:31,470 --> 00:31:37,160
a strategy is a kind of a way of doing

00:31:34,350 --> 00:31:41,700
things again is if you have an object

00:31:37,160 --> 00:31:43,830
function a verb and change of

00:31:41,700 --> 00:31:46,380
responsibility is kind of a a pipeline

00:31:43,830 --> 00:31:48,440
of objects passing stuff down down the

00:31:46,380 --> 00:31:54,630
pipeline and as function composition

00:31:48,440 --> 00:31:56,400
there so they didn't see it at the time

00:31:54,630 --> 00:31:59,100
but they were they were exploring

00:31:56,400 --> 00:32:03,510
functional programming idioms with these

00:31:59,100 --> 00:32:05,460
object oriented patterns it's important

00:32:03,510 --> 00:32:07,950
though that I do think the paradigm is

00:32:05,460 --> 00:32:09,240
different so in my days design patterns

00:32:07,950 --> 00:32:10,500
were all seen this kind little extra

00:32:09,240 --> 00:32:11,320
garnish you put on top of your program

00:32:10,500 --> 00:32:13,090
that's

00:32:11,320 --> 00:32:17,920
something you necessarily had your core

00:32:13,090 --> 00:32:19,570
program and I think you know this is

00:32:17,920 --> 00:32:21,250
stuff is these ideas much more pervasive

00:32:19,570 --> 00:32:22,420
in functional program and of course we

00:32:21,250 --> 00:32:25,090
have a different aesthetic of what we

00:32:22,420 --> 00:32:29,260
consider to be good code as discussed

00:32:25,090 --> 00:32:30,490
earlier so I think looking at looking at

00:32:29,260 --> 00:32:33,040
the design patterns if you have a strong

00:32:30,490 --> 00:32:34,300
background looking them and then finding

00:32:33,040 --> 00:32:35,410
the equivalents in functional

00:32:34,300 --> 00:32:36,670
programming world will help you to

00:32:35,410 --> 00:32:40,660
understand how to use functional

00:32:36,670 --> 00:32:41,950
programming language effectively but it

00:32:40,660 --> 00:32:44,230
won't give you that sort of aesthetic

00:32:41,950 --> 00:32:46,120
you need to guide yourself towards what

00:32:44,230 --> 00:32:50,230
is good code versus bad carried into

00:32:46,120 --> 00:32:52,750
that you need to adopt the paradigm so

00:32:50,230 --> 00:32:56,650
conclusions I start something

00:32:52,750 --> 00:32:58,480
controversial multi-paradigm development

00:32:56,650 --> 00:32:59,980
doesn't make sense it's kind of like by

00:32:58,480 --> 00:33:02,020
definition if you accept the definition

00:32:59,980 --> 00:33:03,730
of Thomas Condon multi-paradigm

00:33:02,020 --> 00:33:04,210
development doesn't make sense does not

00:33:03,730 --> 00:33:07,030
make sense

00:33:04,210 --> 00:33:08,280
um I don't think it makes sense either I

00:33:07,030 --> 00:33:10,870
don't think you can simultaneously

00:33:08,280 --> 00:33:12,460
maintain a kind of over aesthetic and a

00:33:10,870 --> 00:33:14,470
functional programming aesthetic at the

00:33:12,460 --> 00:33:16,030
same time so I think they are contrary

00:33:14,470 --> 00:33:17,640
in contradiction I don't think you can

00:33:16,030 --> 00:33:21,700
do both

00:33:17,640 --> 00:33:25,480
ask me often talk so these were some

00:33:21,700 --> 00:33:27,370
questions from that I do believe though

00:33:25,480 --> 00:33:28,630
if you have strong oo background you can

00:33:27,370 --> 00:33:30,730
look at that these other patterns and

00:33:28,630 --> 00:33:32,260
you'll find equivalent in in FP and yeah

00:33:30,730 --> 00:33:33,330
it can help you to understand how to use

00:33:32,260 --> 00:33:36,460
a functional programming language

00:33:33,330 --> 00:33:39,520
effectively but I do think you need to

00:33:36,460 --> 00:33:41,950
adopt that paradigm as well and I hope

00:33:39,520 --> 00:33:44,860
that I have shown that the paradigm FP

00:33:41,950 --> 00:33:46,540
paradigm is not really so difficult but

00:33:44,860 --> 00:33:48,340
it does take time to internalize that

00:33:46,540 --> 00:33:49,990
needs so quickly you can learn things it

00:33:48,340 --> 00:33:54,970
will take a journey will take some time

00:33:49,990 --> 00:33:57,730
so that's all I have to say actually one

00:33:54,970 --> 00:33:58,630
more thing the history of philosophy

00:33:57,730 --> 00:33:59,620
podcast

00:33:58,630 --> 00:34:00,910
you should go listen to if you don't

00:33:59,620 --> 00:34:02,200
listen to read it is quite really fun

00:34:00,910 --> 00:34:03,760
and that's where I learned about the

00:34:02,200 --> 00:34:07,840
lesson in various and all this kind of

00:34:03,760 --> 00:34:09,760
stuff that's all I got to say thank you

00:34:07,840 --> 00:34:11,800
for your attention and for answering my

00:34:09,760 --> 00:34:13,450
inane questions and if you have any

00:34:11,800 --> 00:34:13,840
questions now I'll be very happy to take

00:34:13,450 --> 00:34:18,690
them

00:34:13,840 --> 00:34:21,160
it's only fair ok gentleman in the back

00:34:18,690 --> 00:34:22,720
right so the question is what do I see

00:34:21,160 --> 00:34:25,030
is the sort of paradigm beyond

00:34:22,720 --> 00:34:26,350
functional programming yeah

00:34:25,030 --> 00:34:27,700
it's a really good question now it's

00:34:26,350 --> 00:34:29,980
really interesting one and I think one

00:34:27,700 --> 00:34:33,520
answer is I don't know if you can see

00:34:29,980 --> 00:34:35,950
the other paradigm from within one

00:34:33,520 --> 00:34:37,330
paradigm or that's kind of a wheezing

00:34:35,950 --> 00:34:38,679
out of it or you might say well we need

00:34:37,330 --> 00:34:40,360
to run into the problems of functional

00:34:38,679 --> 00:34:42,310
programming first before we can really

00:34:40,360 --> 00:34:43,540
start developing now the next paradigm

00:34:42,310 --> 00:34:44,710
and in the way that you have sort of

00:34:43,540 --> 00:34:46,720
rounded the problems of Newtonian

00:34:44,710 --> 00:34:48,730
mechanics before relativity was

00:34:46,720 --> 00:34:51,940
motivated and we're not at that stage

00:34:48,730 --> 00:34:57,400
yet again that's a survey doing the

00:34:51,940 --> 00:34:58,870
question I think so I would say I think

00:34:57,400 --> 00:35:01,300
that in the future we might have things

00:34:58,870 --> 00:35:02,860
like dependent typing which you might

00:35:01,300 --> 00:35:04,230
see as an evolution of functional

00:35:02,860 --> 00:35:09,010
programming or you might see as

00:35:04,230 --> 00:35:10,510
something different I do think that

00:35:09,010 --> 00:35:12,240
function program because it's based on a

00:35:10,510 --> 00:35:14,830
much more rigorous theory I think this

00:35:12,240 --> 00:35:16,810
kind of mathematical theory it's much it

00:35:14,830 --> 00:35:20,920
is likely to last longer and it's likely

00:35:16,810 --> 00:35:22,780
to have maybe be more correct or have

00:35:20,920 --> 00:35:24,910
more influence than the things that came

00:35:22,780 --> 00:35:28,630
before hand in the way that you can see

00:35:24,910 --> 00:35:30,220
relativity as it doesn't completely it

00:35:28,630 --> 00:35:33,430
just extends really Newtonian mechanics

00:35:30,220 --> 00:35:34,990
rather than replacing it and we might

00:35:33,430 --> 00:35:36,640
see the same thing with future paradigms

00:35:34,990 --> 00:35:38,050
extending this foundation of a

00:35:36,640 --> 00:35:43,290
functional programming rather than

00:35:38,050 --> 00:35:43,290
replacing it is that a reasonable answer

00:35:44,760 --> 00:35:51,580
that's right okay so the question was

00:35:49,450 --> 00:35:53,710
he's you've read that you should sort of

00:35:51,580 --> 00:35:56,170
80/20 be coded functional 20% of bidi

00:35:53,710 --> 00:35:57,790
mutation and so on and but I said that

00:35:56,170 --> 00:35:59,680
over and functional programming don't

00:35:57,790 --> 00:36:03,760
I'm not commensurate let's use our fancy

00:35:59,680 --> 00:36:04,720
fancy terms function programs I don't

00:36:03,760 --> 00:36:06,850
think I should have put in the function

00:36:04,720 --> 00:36:08,470
program we love fancy words absolutely

00:36:06,850 --> 00:36:10,270
love and algebraic data hive structures

00:36:08,470 --> 00:36:14,380
and you know these great names fantastic

00:36:10,270 --> 00:36:16,150
stuff so okay I think that's a really

00:36:14,380 --> 00:36:18,370
interesting question and it's something

00:36:16,150 --> 00:36:21,970
I didn't really get into because it

00:36:18,370 --> 00:36:23,200
really made the talk so long one think

00:36:21,970 --> 00:36:25,840
about function programmers you don't

00:36:23,200 --> 00:36:27,940
it's not state yourself that's a problem

00:36:25,840 --> 00:36:30,280
it's just controlling state so this idea

00:36:27,940 --> 00:36:31,660
of separating a program from describing

00:36:30,280 --> 00:36:33,130
the program and then running it when you

00:36:31,660 --> 00:36:34,690
run it you can have all sorts of side

00:36:33,130 --> 00:36:35,770
effects I saw this invented to you meant

00:36:34,690 --> 00:36:36,220
of side effects and state and that's

00:36:35,770 --> 00:36:37,570
fine

00:36:36,220 --> 00:36:38,510
because he just have this clear

00:36:37,570 --> 00:36:40,160
separation so you

00:36:38,510 --> 00:36:41,240
here's a program this part the program

00:36:40,160 --> 00:36:44,720
you can reason about with substitution

00:36:41,240 --> 00:36:45,920
is everything's happy then you go and

00:36:44,720 --> 00:36:46,550
run things and then you can just do

00:36:45,920 --> 00:36:49,840
whatever you want

00:36:46,550 --> 00:36:52,790
side effects open files print things

00:36:49,840 --> 00:36:55,460
graphic that's fine and that's we care

00:36:52,790 --> 00:36:58,760
you can of gnarly techniques there's

00:36:55,460 --> 00:37:01,010
another thing so I talked about how if

00:36:58,760 --> 00:37:03,280
you sort of follow our design patterns

00:37:01,010 --> 00:37:07,940
you end up in functional programming

00:37:03,280 --> 00:37:11,420
there's a convergence happening on some

00:37:07,940 --> 00:37:15,310
directions so we have to talk about the

00:37:11,420 --> 00:37:19,070
so Freeman air and that's yesterday

00:37:15,310 --> 00:37:22,790
there's a similar idea Kota finally

00:37:19,070 --> 00:37:27,170
tagless interpreter told you function

00:37:22,790 --> 00:37:29,180
programmers love fancy words and if you

00:37:27,170 --> 00:37:30,500
look at this is finally tagless stuff

00:37:29,180 --> 00:37:33,010
and you look at it something coming out

00:37:30,500 --> 00:37:35,570
of our world could object algebras

00:37:33,010 --> 00:37:39,140
slightly less fancy term but actually

00:37:35,570 --> 00:37:40,880
really doing the same thing they have a

00:37:39,140 --> 00:37:44,060
slightly different basis they're coming

00:37:40,880 --> 00:37:45,620
from the lack of high kind of types in

00:37:44,060 --> 00:37:48,520
the in the Aero world and Tom makes the

00:37:45,620 --> 00:37:52,310
object algebra stuff a little bit more

00:37:48,520 --> 00:37:53,750
painful but it's essentially reaching

00:37:52,310 --> 00:37:58,760
for the same spot no they're almost

00:37:53,750 --> 00:38:00,980
equivalent so I do think that there's

00:37:58,760 --> 00:38:02,300
some convergence going on here and if

00:38:00,980 --> 00:38:03,890
you sort of go down the rabbit hole far

00:38:02,300 --> 00:38:05,840
enough in functional programming you pop

00:38:03,890 --> 00:38:08,330
out in oh oh and if you go down the

00:38:05,840 --> 00:38:09,740
rabbit hole far enough sort of pop out a

00:38:08,330 --> 00:38:11,840
functional programming Lance I think

00:38:09,740 --> 00:38:16,070
there is more there's more synthesis

00:38:11,840 --> 00:38:22,510
there then then I perhaps led on in this

00:38:16,070 --> 00:38:27,140
talk and again you could you can see

00:38:22,510 --> 00:38:28,190
objects as being sort of dual to your

00:38:27,140 --> 00:38:30,680
programming ideas and it was getting

00:38:28,190 --> 00:38:32,750
into more kind of nerdy what your

00:38:30,680 --> 00:38:36,650
programming speak first I think there's

00:38:32,750 --> 00:38:38,200
something there is a kind of synthesis

00:38:36,650 --> 00:38:44,840
there that's something I want to explore

00:38:38,200 --> 00:38:46,550
my own talk ok so there's a question of

00:38:44,840 --> 00:38:49,850
repeated four people in here back and

00:38:46,550 --> 00:38:53,000
for the video is is responsibility the

00:38:49,850 --> 00:38:56,850
scala community too

00:38:53,000 --> 00:38:59,640
just to to develop Scala as an

00:38:56,850 --> 00:39:02,220
object-oriented functional hybrid or to

00:38:59,640 --> 00:39:07,110
treat the OO spot as your way into Scala

00:39:02,220 --> 00:39:09,150
and then we want to go functional yeah I

00:39:07,110 --> 00:39:10,680
think certainly there is there's

00:39:09,150 --> 00:39:12,060
divisions in the scala community we

00:39:10,680 --> 00:39:13,620
don't all agree on how we should write

00:39:12,060 --> 00:39:15,210
code and different people write code in

00:39:13,620 --> 00:39:18,120
different ways and I should have

00:39:15,210 --> 00:39:19,590
mentioned within the Scarlet community

00:39:18,120 --> 00:39:21,750
might seem safe there's a third paradigm

00:39:19,590 --> 00:39:23,280
which is the actor paradigm which is

00:39:21,750 --> 00:39:26,400
kind of our ish and this message passing

00:39:23,280 --> 00:39:31,980
but it's also has its own differences

00:39:26,400 --> 00:39:33,390
and this is why many people like I don't

00:39:31,980 --> 00:39:35,370
particularly like akka because I don't

00:39:33,390 --> 00:39:40,260
like the fact is in a different paradigm

00:39:35,370 --> 00:39:43,140
doesn't maintain my values but yeah

00:39:40,260 --> 00:39:43,980
getting back to your question now one

00:39:43,140 --> 00:39:47,070
thing I think is interesting about

00:39:43,980 --> 00:39:50,040
martin said his keynote was that Scala

00:39:47,070 --> 00:39:53,160
is a functional modular hybrid not a

00:39:50,040 --> 00:39:54,690
functional oo hybrid and at the risk of

00:39:53,160 --> 00:39:59,720
being a bit of a biblical scholar trying

00:39:54,690 --> 00:40:02,970
to read the tea leaves I have found that

00:39:59,720 --> 00:40:05,910
where I like using objects as modules as

00:40:02,970 --> 00:40:08,460
namespaces classes as as namespaces

00:40:05,910 --> 00:40:10,920
works very well for me but things like

00:40:08,460 --> 00:40:12,420
our patterns are of inheritance and

00:40:10,920 --> 00:40:14,610
there's kind of deep inheritance graphs

00:40:12,420 --> 00:40:17,100
and encapsulating state and that kind of

00:40:14,610 --> 00:40:20,460
stuff doesn't work so I do think there

00:40:17,100 --> 00:40:22,260
is a I think we can use these away

00:40:20,460 --> 00:40:24,030
features of objects and so on in a way

00:40:22,260 --> 00:40:28,680
that it works within the functional

00:40:24,030 --> 00:40:29,940
programming paradigm but there's sort of

00:40:28,680 --> 00:40:31,920
our language features but we're not

00:40:29,940 --> 00:40:34,680
using them in an overlay we're not

00:40:31,920 --> 00:40:37,650
creating deep graphs of inheritance list

00:40:34,680 --> 00:40:39,480
and using States and stuff like that so

00:40:37,650 --> 00:40:43,950
I think there's one way of kind of

00:40:39,480 --> 00:40:46,110
uniting the two I do think though that

00:40:43,950 --> 00:40:48,150
the I do think that ollo patterns if you

00:40:46,110 --> 00:40:49,920
like the things that tip people

00:40:48,150 --> 00:40:51,960
typically use in in our language they

00:40:49,920 --> 00:40:53,520
for me they don't work I can't

00:40:51,960 --> 00:40:55,470
understand them I can't understand code

00:40:53,520 --> 00:40:56,970
written with them they don't they don't

00:40:55,470 --> 00:40:59,790
give me the kind of flexibility I want

00:40:56,970 --> 00:41:01,410
so I do think though the over way

00:40:59,790 --> 00:41:02,250
thinking yeah as your way into Scala and

00:41:01,410 --> 00:41:05,670
you should

00:41:02,250 --> 00:41:08,490
adamant towards an FPU way of course I'm

00:41:05,670 --> 00:41:10,170
in the FP paradigm I would say that but

00:41:08,490 --> 00:41:14,900
I do think that the language features

00:41:10,170 --> 00:41:14,900
are objects and and so on us have value

00:41:15,109 --> 00:41:25,830
not the differing degrees of value but

00:41:18,180 --> 00:41:34,349
they certainly have values so any any

00:41:25,830 --> 00:41:36,950
more questions okay well thank you very

00:41:34,349 --> 00:41:36,950

YouTube URL: https://www.youtube.com/watch?v=AL1J5AT4pfY


