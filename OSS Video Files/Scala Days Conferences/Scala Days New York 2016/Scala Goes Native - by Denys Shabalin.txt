Title: Scala Goes Native - by Denys Shabalin
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Scala has historically been a JVM-centric programming language. The situation has started to change with appearance of the Scala.js that opened a door of front-end development to Scala programmers. This talk will expand the horizons of Scala even more. Weâ€™re going to announce a new ahead-of-time compiler and lightweight managed runtime designed specifically for Scala.
Captions: 
	00:00:01,689 --> 00:00:07,899
so every piece of technology no matter

00:00:04,420 --> 00:00:09,550
how small or Bay or dejenne Deak has

00:00:07,899 --> 00:00:11,530
some kind of backstory behind it you

00:00:09,550 --> 00:00:13,120
know someone somewhere was pissed off

00:00:11,530 --> 00:00:16,330
about something that's how like most of

00:00:13,120 --> 00:00:19,260
things starts and this story is not

00:00:16,330 --> 00:00:21,519
going to be an exception you know but

00:00:19,260 --> 00:00:24,189
before we get about things that I'm

00:00:21,519 --> 00:00:26,439
unhappy little it's kind of like have a

00:00:24,189 --> 00:00:29,349
small background of where it all began

00:00:26,439 --> 00:00:32,080
so for me my first experience with

00:00:29,349 --> 00:00:34,149
programming was Pascal and it was my

00:00:32,080 --> 00:00:36,670
first programming language and I

00:00:34,149 --> 00:00:38,079
actually still think it's kind of was

00:00:36,670 --> 00:00:41,370
the first language to do a lot of things

00:00:38,079 --> 00:00:44,680
right it had a very fast compiler it was

00:00:41,370 --> 00:00:47,260
low-level but it still it wasn't

00:00:44,680 --> 00:00:48,820
possible to easily shoot yourself so if

00:00:47,260 --> 00:00:51,100
you want to shoot yourself you had to be

00:00:48,820 --> 00:00:53,500
really explicit about it like all the

00:00:51,100 --> 00:00:55,329
things in Pascal because it was like the

00:00:53,500 --> 00:00:59,140
most verbose language I've ever used in

00:00:55,329 --> 00:01:01,359
my life but this kind of explicit

00:00:59,140 --> 00:01:04,780
verbosity had something nice about it

00:01:01,359 --> 00:01:05,820
because it was really really hard to do

00:01:04,780 --> 00:01:10,480
something horribly wrong

00:01:05,820 --> 00:01:12,760
after that I learned C and it was really

00:01:10,480 --> 00:01:14,800
fun I could type so much code like

00:01:12,760 --> 00:01:18,130
immediately like compared to Pascal that

00:01:14,800 --> 00:01:21,160
like had all this like long keywords I

00:01:18,130 --> 00:01:23,470
could just take Harley Bryson that my

00:01:21,160 --> 00:01:25,650
code would just happen you know it was

00:01:23,470 --> 00:01:28,240
still a level but at the same time it

00:01:25,650 --> 00:01:30,520
was completely different experience

00:01:28,240 --> 00:01:32,320
because it was just so easy to shoot

00:01:30,520 --> 00:01:34,360
yourself and when I say shoot yourself

00:01:32,320 --> 00:01:36,880
you just basically just blow parts of

00:01:34,360 --> 00:01:38,590
your body weights just it's not just

00:01:36,880 --> 00:01:42,760
your average just like heard yourself

00:01:38,590 --> 00:01:45,330
kind of way after that I learned to

00:01:42,760 --> 00:01:46,990
c-sharp c-sharp was my first

00:01:45,330 --> 00:01:48,640
object-oriented and when I say

00:01:46,990 --> 00:01:52,270
object-oriented I mean class oriented

00:01:48,640 --> 00:01:54,730
language everything is a class but

00:01:52,270 --> 00:01:56,050
luckily they still have structs and not

00:01:54,730 --> 00:01:58,960
many people know but they still have

00:01:56,050 --> 00:02:01,690
pointers and they for cases when you

00:01:58,960 --> 00:02:03,580
need them to so see harp was actually a

00:02:01,690 --> 00:02:05,680
pretty good language but it had one kind

00:02:03,580 --> 00:02:07,780
of like title issue you know it was tied

00:02:05,680 --> 00:02:09,429
to Microsoft of the old days when they

00:02:07,780 --> 00:02:11,500
were still against my open-source and

00:02:09,429 --> 00:02:14,260
everything so it felt really kind of

00:02:11,500 --> 00:02:15,380
dangerous to stay in this ecosystem

00:02:14,260 --> 00:02:17,030
where

00:02:15,380 --> 00:02:19,010
only run in Windows you cannot round on

00:02:17,030 --> 00:02:20,990
the next Elantra or anywhere else but

00:02:19,010 --> 00:02:24,560
windows so again

00:02:20,990 --> 00:02:27,680
Samson was wrong so next language next

00:02:24,560 --> 00:02:30,860
language was pison pison you know it was

00:02:27,680 --> 00:02:33,830
my first truly dynamic language and it

00:02:30,860 --> 00:02:35,960
felt like I had so much freedom I could

00:02:33,830 --> 00:02:38,540
like do really anything about everything

00:02:35,960 --> 00:02:40,730
I could just generate types at runtime I

00:02:38,540 --> 00:02:43,760
could do whatever I wanted basically

00:02:40,730 --> 00:02:45,620
just it was really fun to write code but

00:02:43,760 --> 00:02:47,900
it was really hard to maintain it

00:02:45,620 --> 00:02:50,420
afterwards and I say it as a guy who

00:02:47,900 --> 00:02:52,760
kind of just wrote a simple 20 key lines

00:02:50,420 --> 00:02:55,070
of code app in Python and it was

00:02:52,760 --> 00:02:57,110
impossible to refactor it was impossible

00:02:55,070 --> 00:03:01,750
to do anything with it after he wrote it

00:02:57,110 --> 00:03:01,750
but writing it was fun so there is that

00:03:03,220 --> 00:03:08,090
elephant bison I think one of the big

00:03:05,840 --> 00:03:11,570
issues in the community is kind of not

00:03:08,090 --> 00:03:14,090
acknowledging threads and dill as an

00:03:11,570 --> 00:03:15,890
issue and it was kind of like scary to

00:03:14,090 --> 00:03:19,970
stay there and was also not very fast

00:03:15,890 --> 00:03:22,640
you could do first things with capi but

00:03:19,970 --> 00:03:25,550
it was like capi he likes it had a lot

00:03:22,640 --> 00:03:27,860
of the issues with CID skull before so

00:03:25,550 --> 00:03:32,030
again I was looking for something better

00:03:27,860 --> 00:03:34,010
and I think the person that introduced

00:03:32,030 --> 00:03:37,280
me to Scala was Daniel speak with his

00:03:34,010 --> 00:03:38,900
talk about higher current types at the

00:03:37,280 --> 00:03:41,180
time I was just a Python developer I

00:03:38,900 --> 00:03:45,050
could not comprehend what was going on I

00:03:41,180 --> 00:03:47,990
just I I realized there is something

00:03:45,050 --> 00:03:49,940
amazingly cool about it but I could not

00:03:47,990 --> 00:03:52,400
understand any of it so I kind of

00:03:49,940 --> 00:03:55,010
reversed it like five times and it

00:03:52,400 --> 00:03:57,530
didn't help so I bought a book about

00:03:55,010 --> 00:03:59,060
Scala and I read half of it and then

00:03:57,530 --> 00:04:03,500
like I watched it again and then it was

00:03:59,060 --> 00:04:04,910
mostly fine yeah but in the matter of

00:04:03,500 --> 00:04:08,720
fact eternal Scala is a pretty cool

00:04:04,910 --> 00:04:10,280
language they discovered randomly and it

00:04:08,720 --> 00:04:13,370
actually ticked a lot of the boxes in my

00:04:10,280 --> 00:04:15,950
book it was fast it was parallel so

00:04:13,370 --> 00:04:17,120
there were no jail so you could do fun

00:04:15,950 --> 00:04:21,320
stuff with concurrency and parallelism

00:04:17,120 --> 00:04:25,220
and it was typed so many things were

00:04:21,320 --> 00:04:28,250
actually quite right many things and

00:04:25,220 --> 00:04:29,250
here comes a part you know that that

00:04:28,250 --> 00:04:31,440
don't like

00:04:29,250 --> 00:04:33,510
you know actually the part that I don't

00:04:31,440 --> 00:04:37,680
like about scarlet have little to do

00:04:33,510 --> 00:04:39,780
with scarlet itself and mostly all of

00:04:37,680 --> 00:04:42,120
the issues that we inherited by the fact

00:04:39,780 --> 00:04:43,680
that we are mostly a JVM language now

00:04:42,120 --> 00:04:46,440
miss ecology of course is not true but

00:04:43,680 --> 00:04:48,360
not so long ago it was we were basically

00:04:46,440 --> 00:04:49,800
just a JVM on the language that kind of

00:04:48,360 --> 00:04:53,940
had all of the same issues that Java has

00:04:49,800 --> 00:04:54,660
and I would call a JVM basically a

00:04:53,940 --> 00:04:57,300
golden cage

00:04:54,660 --> 00:04:59,190
because it's very very nice and comfy it

00:04:57,300 --> 00:05:02,100
has like basically everything you need

00:04:59,190 --> 00:05:04,530
it's fast it's really fast one once it's

00:05:02,100 --> 00:05:05,190
warmed up it's really fast if your code

00:05:04,530 --> 00:05:07,350
looks like

00:05:05,190 --> 00:05:10,430
like after compilation looks like Java

00:05:07,350 --> 00:05:12,630
code and it's really fast if you are

00:05:10,430 --> 00:05:14,550
reasonable about your allocation rates

00:05:12,630 --> 00:05:16,470
and as you could notice there are lots

00:05:14,550 --> 00:05:22,470
of lots of butts so it's not all perfect

00:05:16,470 --> 00:05:25,890
but it's really nice now another thing

00:05:22,470 --> 00:05:27,840
is that it's kind of like GBM still have

00:05:25,890 --> 00:05:29,550
a safe environment where people that

00:05:27,840 --> 00:05:33,419
build it work kind of like went to

00:05:29,550 --> 00:05:35,430
extreme of making it safe they made it

00:05:33,419 --> 00:05:38,070
like so safe so blood probes that you

00:05:35,430 --> 00:05:43,230
could you would find a hard time doing

00:05:38,070 --> 00:05:44,970
some some low-level on JVM and the only

00:05:43,230 --> 00:05:46,890
few api is like some miss can't save our

00:05:44,970 --> 00:05:49,200
were never designed to be public they

00:05:46,890 --> 00:05:51,540
were just happened to be available and

00:05:49,200 --> 00:05:54,540
people use them and in fact something

00:05:51,540 --> 00:05:55,979
like comes moral level for high

00:05:54,540 --> 00:05:59,280
performance frameworks it's often needed

00:05:55,979 --> 00:06:01,290
and if you just look around like most

00:05:59,280 --> 00:06:04,020
high performance frameworks like spark

00:06:01,290 --> 00:06:06,630
most HTTP frameworks like just about

00:06:04,020 --> 00:06:08,370
everybody uses unsafe because you cannot

00:06:06,630 --> 00:06:10,740
build a high performance system without

00:06:08,370 --> 00:06:12,510
having lower level primitives and Java

00:06:10,740 --> 00:06:13,919
has this weird kind of like policy where

00:06:12,510 --> 00:06:16,290
safety is more important than

00:06:13,919 --> 00:06:18,960
expressivity and except is the most

00:06:16,290 --> 00:06:20,790
Explorer important thing and of course

00:06:18,960 --> 00:06:22,710
you cannot talk to native code easily

00:06:20,790 --> 00:06:24,300
because that would undermine safety

00:06:22,710 --> 00:06:27,630
because native code is obviously not

00:06:24,300 --> 00:06:30,120
safe so let's make talk into native code

00:06:27,630 --> 00:06:32,010
as hard as possible and just a bit

00:06:30,120 --> 00:06:37,110
harder afterwards okay and the base

00:06:32,010 --> 00:06:38,580
could you Jay and I okay and yeah so I

00:06:37,110 --> 00:06:40,410
don't really have much to say about

00:06:38,580 --> 00:06:42,240
j'ni apart from it being like a

00:06:40,410 --> 00:06:42,960
complicated mess that no one in their

00:06:42,240 --> 00:06:45,000
own same

00:06:42,960 --> 00:06:47,190
would use I think it was intentional

00:06:45,000 --> 00:06:48,240
probably because the only explanation

00:06:47,190 --> 00:06:50,160
how you can make something so

00:06:48,240 --> 00:06:55,860
complicated to solve such a simple

00:06:50,160 --> 00:06:57,270
problem now we know all of things I

00:06:55,860 --> 00:06:59,370
don't like so let's kind of daydream a

00:06:57,270 --> 00:07:01,590
bit like what would the things that

00:06:59,370 --> 00:07:03,270
would be nice to have you know I love J

00:07:01,590 --> 00:07:08,340
dreaming I did to him a lot and

00:07:03,270 --> 00:07:10,370
sometimes I'd go so far into dated a

00:07:08,340 --> 00:07:12,660
dream world did I forget the stuff

00:07:10,370 --> 00:07:16,050
separation between stuff that I want and

00:07:12,660 --> 00:07:18,630
don't exist and stuff it exists and and

00:07:16,050 --> 00:07:20,130
it's hard you know I just want to use a

00:07:18,630 --> 00:07:23,310
feature which I appreciate had in mind

00:07:20,130 --> 00:07:27,330
but it's not there so what kind of

00:07:23,310 --> 00:07:29,400
features are those first of all for me

00:07:27,330 --> 00:07:33,120
personally I don't care about just that

00:07:29,400 --> 00:07:35,070
much I don't really want my coat to be

00:07:33,120 --> 00:07:37,949
slow for like 10 like for like few

00:07:35,070 --> 00:07:40,470
seconds for and dependent code can be

00:07:37,949 --> 00:07:43,050
like 10 seconds to just warm up because

00:07:40,470 --> 00:07:44,550
JVM need to interpret to collect the

00:07:43,050 --> 00:07:47,159
best profile information to compile the

00:07:44,550 --> 00:07:48,780
code the best way possible you know I

00:07:47,159 --> 00:07:50,310
don't really care about any of this I

00:07:48,780 --> 00:07:53,220
just want my code to run when I say it

00:07:50,310 --> 00:07:55,289
wrong so if I say do work I just wanted

00:07:53,220 --> 00:07:59,909
to do work I don't want it to warm up to

00:07:55,289 --> 00:08:04,199
do work to do work I want to have value

00:07:59,909 --> 00:08:06,599
types I really want not to allocate

00:08:04,199 --> 00:08:08,460
sometimes I don't really get this whole

00:08:06,599 --> 00:08:12,360
paradigm of not having any Vella types

00:08:08,460 --> 00:08:16,770
in a language and VM and I think Java is

00:08:12,360 --> 00:08:18,210
only a top used language is top use

00:08:16,770 --> 00:08:20,340
compiled language that still doesn't

00:08:18,210 --> 00:08:22,680
have hello types and it's kind of really

00:08:20,340 --> 00:08:24,330
unfortunate I want teletypes I want to

00:08:22,680 --> 00:08:29,550
stack allocate things I want it to be

00:08:24,330 --> 00:08:31,430
easy and effortless and lastly memory

00:08:29,550 --> 00:08:34,020
management of course we have GC and

00:08:31,430 --> 00:08:36,029
because we don't have value types GCS

00:08:34,020 --> 00:08:39,029
also all we have to kind of pass stuff

00:08:36,029 --> 00:08:41,399
around and once your other gate

00:08:39,029 --> 00:08:43,320
something on GC here beside like super

00:08:41,399 --> 00:08:46,020
cheap you just allocate stuff it's up to

00:08:43,320 --> 00:08:48,899
like allocations immediately fast it's

00:08:46,020 --> 00:08:51,540
amazing like but at the same time use a

00:08:48,899 --> 00:08:53,910
very high cost of forgetting things so

00:08:51,540 --> 00:08:56,290
the more archaism already you remember

00:08:53,910 --> 00:08:58,780
the more working it to do to clean

00:08:56,290 --> 00:09:00,310
let's mess up you know it's not free so

00:08:58,780 --> 00:09:04,450
there is kind of a non-trivial cost of

00:09:00,310 --> 00:09:06,910
allocating things on GE on GC heap and I

00:09:04,450 --> 00:09:09,250
would really want to kind of like have

00:09:06,910 --> 00:09:11,110
other options too you know GC is fine

00:09:09,250 --> 00:09:14,020
and I think it's actually a kind of good

00:09:11,110 --> 00:09:16,030
main paradigm for language but it's not

00:09:14,020 --> 00:09:18,850
really like if it's your only way you

00:09:16,030 --> 00:09:24,970
are bound to be using something like

00:09:18,850 --> 00:09:27,040
unsafe really fast and lastly I really

00:09:24,970 --> 00:09:31,900
kind of think that talking toilet code

00:09:27,040 --> 00:09:33,910
should be a non-issue and 2016 and you

00:09:31,900 --> 00:09:35,920
know it should not cause any performance

00:09:33,910 --> 00:09:37,750
overhead it should not cause any mental

00:09:35,920 --> 00:09:40,300
overhead you should just be able to call

00:09:37,750 --> 00:09:43,480
stuff and it should not be horribly

00:09:40,300 --> 00:09:45,790
complicated but it's kind of daydreaming

00:09:43,480 --> 00:09:47,320
right just like none of this exists so

00:09:45,790 --> 00:09:50,200
so we are back to are kind of like day

00:09:47,320 --> 00:09:51,430
jobs somewhere and we are asked to I

00:09:50,200 --> 00:09:52,780
kind of like to port some kind of like

00:09:51,430 --> 00:09:57,730
super important business application

00:09:52,780 --> 00:10:00,550
from C++ it's it's obviously kind of

00:09:57,730 --> 00:10:01,870
like very very fast because it was hand

00:10:00,550 --> 00:10:05,590
optimized by the previous guy you know

00:10:01,870 --> 00:10:08,770
and so let's try to understand what it

00:10:05,590 --> 00:10:09,820
does you know so first we have this kind

00:10:08,770 --> 00:10:14,050
of struct

00:10:09,820 --> 00:10:16,810
it's big enough I can make it bigger now

00:10:14,050 --> 00:10:19,870
okay okay it's fine okay so first of all

00:10:16,810 --> 00:10:21,880
we have this kind of struct type so what

00:10:19,870 --> 00:10:24,820
this actually is just this Sri field

00:10:21,880 --> 00:10:27,760
it's a vector with three fields and then

00:10:24,820 --> 00:10:31,360
we have some operations on it like plus

00:10:27,760 --> 00:10:33,130
minus multiply normalize dot product and

00:10:31,360 --> 00:10:36,310
so on to force so this are kind of like

00:10:33,130 --> 00:10:38,260
normal messy operations director that's

00:10:36,310 --> 00:10:40,720
fine that's kind of like still simple we

00:10:38,260 --> 00:10:44,350
were not doing anything crazier then we

00:10:40,720 --> 00:10:46,150
have this truck tray that has origin and

00:10:44,350 --> 00:10:48,220
destination and it's basically array in

00:10:46,150 --> 00:10:51,520
3d space and it corresponds to whatever

00:10:48,220 --> 00:10:52,750
domain specifical logic we have right we

00:10:51,520 --> 00:10:54,880
don't understand any of this because

00:10:52,750 --> 00:10:59,980
we're just pouring stuff over it's fine

00:10:54,880 --> 00:11:02,530
so then we have this genome and we have

00:10:59,980 --> 00:11:05,670
more geometry we have some global

00:11:02,530 --> 00:11:05,670
mutable state is fine

00:11:08,070 --> 00:11:13,300
let me have some helpers you know again

00:11:10,870 --> 00:11:15,010
some messy looking code you know just

00:11:13,300 --> 00:11:16,540
maths you know just simple stuff you

00:11:15,010 --> 00:11:18,910
just add stuff stops truck stuff some

00:11:16,540 --> 00:11:20,950
for loop or here nothing too special you

00:11:18,910 --> 00:11:24,340
know it's not some kind of any here it

00:11:20,950 --> 00:11:26,140
goes and here goes our basically

00:11:24,340 --> 00:11:29,440
business value of our products or

00:11:26,140 --> 00:11:31,180
something like that the most complicated

00:11:29,440 --> 00:11:33,400
and overblown a kind of like piece of

00:11:31,180 --> 00:11:35,200
code like anywhere just it's like hand

00:11:33,400 --> 00:11:37,120
optimized and so on the force but it has

00:11:35,200 --> 00:11:39,340
to work exactly the way it is and we

00:11:37,120 --> 00:11:42,310
cannot change it right so so let's kind

00:11:39,340 --> 00:11:43,990
of like just so we can try to read it

00:11:42,310 --> 00:11:47,320
but basically what it does it has like

00:11:43,990 --> 00:11:50,530
three branches does different things

00:11:47,320 --> 00:11:52,240
based on this kind of flag called ruffle

00:11:50,530 --> 00:11:54,220
and it does different things and

00:11:52,240 --> 00:11:56,350
actually this third piece is actually

00:11:54,220 --> 00:11:57,520
another branch but we don't really care

00:11:56,350 --> 00:11:58,920
about what it does it we just need to

00:11:57,520 --> 00:12:01,660
port it to Scala because we are told to

00:11:58,920 --> 00:12:03,750
because Scala is a new popular language

00:12:01,660 --> 00:12:06,610
you know Everson has to be in Scala

00:12:03,750 --> 00:12:09,160
so obviously it's kind of like a very

00:12:06,610 --> 00:12:11,350
kind of like non-trivial code so we we

00:12:09,160 --> 00:12:14,020
need to pour it like you know so we do

00:12:11,350 --> 00:12:15,820
our best so we start porting and we just

00:12:14,020 --> 00:12:17,110
map stuff to like normal Scala code a

00:12:15,820 --> 00:12:20,230
construct so we don't have structure

00:12:17,110 --> 00:12:22,510
we'll have to use classes so we have

00:12:20,230 --> 00:12:24,670
class vector with all of the same stuff

00:12:22,510 --> 00:12:28,600
we've seen before we have cause ray we

00:12:24,670 --> 00:12:32,890
we don't have in ohms in a language yeah

00:12:28,600 --> 00:12:34,420
so we emulated with a hint and so

00:12:32,890 --> 00:12:37,930
basically just pour stuff over there's

00:12:34,420 --> 00:12:40,390
nothing special about it so we still

00:12:37,930 --> 00:12:42,580
have the state somewhere here and we

00:12:40,390 --> 00:12:46,270
allocate ever seen on GC heat because we

00:12:42,580 --> 00:12:48,089
cannot allocate anywhere else so most of

00:12:46,270 --> 00:12:50,620
the cow just pours over just nicely

00:12:48,089 --> 00:12:53,320
there are some funny parts were babe

00:12:50,620 --> 00:12:55,480
where we could that we could do in C++

00:12:53,320 --> 00:12:57,130
and we could not do here ramble here we

00:12:55,480 --> 00:12:59,380
have these two variables which are like

00:12:57,130 --> 00:13:03,120
this funny arrays of one element and

00:12:59,380 --> 00:13:03,120
what we're trying to emulate is

00:13:03,190 --> 00:13:10,459
by reference argument will be held in

00:13:05,329 --> 00:13:12,680
C++ codes for ample here we had TT and

00:13:10,459 --> 00:13:14,029
in tidied pass by reference so we cannot

00:13:12,680 --> 00:13:17,300
do this so we need to allocate a box

00:13:14,029 --> 00:13:19,010
might as well use array we can also do

00:13:17,300 --> 00:13:21,350
something else it doesn't really matter

00:13:19,010 --> 00:13:25,040
so it's just a box that is passed over

00:13:21,350 --> 00:13:26,810
and that is basically used to return

00:13:25,040 --> 00:13:29,360
more than one value at the same time

00:13:26,810 --> 00:13:31,579
then report over all of our domain

00:13:29,360 --> 00:13:35,750
specific code hopefully not introducing

00:13:31,579 --> 00:13:37,190
any bugs hopefully yeah and it mostly

00:13:35,750 --> 00:13:39,950
just fine so we don't use any of the

00:13:37,190 --> 00:13:42,350
fancy features we just use wire loops

00:13:39,950 --> 00:13:43,640
instead of for loops because this code

00:13:42,350 --> 00:13:46,490
is like super important so we cannot

00:13:43,640 --> 00:13:49,490
really make it any slower so it's fine

00:13:46,490 --> 00:13:52,190
right so now we are like mostly down

00:13:49,490 --> 00:13:54,950
here so we poured it like it all or we

00:13:52,190 --> 00:13:57,620
even like run some like original tests

00:13:54,950 --> 00:13:59,480
and now it likes a hard time you know we

00:13:57,620 --> 00:14:01,970
need to make it as fast as previous one

00:13:59,480 --> 00:14:07,519
right so the previous code we use we

00:14:01,970 --> 00:14:11,420
compiled with Clank over here some

00:14:07,519 --> 00:14:14,540
orange is fine so it would do whatever

00:14:11,420 --> 00:14:18,560
it does it will do whatever it does and

00:14:14,540 --> 00:14:21,680
something like ten seconds I think it

00:14:18,560 --> 00:14:23,899
has nice progress bar this nice noise so

00:14:21,680 --> 00:14:24,230
like seven seconds actually so so it's

00:14:23,899 --> 00:14:26,959
fine

00:14:24,230 --> 00:14:29,300
I mean so we ported code over like

00:14:26,959 --> 00:14:30,829
faithfully right it has to be the same

00:14:29,300 --> 00:14:34,190
performance because gvm it should be

00:14:30,829 --> 00:14:36,680
fast that's true right because we did

00:14:34,190 --> 00:14:41,990
not use a single scala feature like that

00:14:36,680 --> 00:14:43,940
is like nice we used arrays we used we

00:14:41,990 --> 00:14:45,860
didn't like really do anything fancy

00:14:43,940 --> 00:14:47,209
like we just poured stuff like naively

00:14:45,860 --> 00:14:50,060
from one place to the other it was

00:14:47,209 --> 00:14:53,930
basically the same thing you know but

00:14:50,060 --> 00:14:57,709
like so with of course we just compile

00:14:53,930 --> 00:14:59,990
it and we run it and you know and it's

00:14:57,709 --> 00:15:02,930
not quite as fast for some reason you

00:14:59,990 --> 00:15:04,760
know it's not quite exactly the same I

00:15:02,930 --> 00:15:06,920
mean we port it we did everything right

00:15:04,760 --> 00:15:09,949
we didn't like do anything like we

00:15:06,920 --> 00:15:11,690
didn't use for loops or didn't write

00:15:09,949 --> 00:15:13,640
functional code for already scared like

00:15:11,690 --> 00:15:15,230
so and our code is like twice slower now

00:15:13,640 --> 00:15:16,640
what happens you know

00:15:15,230 --> 00:15:18,830
then we

00:15:16,640 --> 00:15:21,470
we can start profiling and trying to

00:15:18,830 --> 00:15:24,860
figure out what's going on and after a

00:15:21,470 --> 00:15:26,330
few kind of hours of hitting your head

00:15:24,860 --> 00:15:28,390
against the wall and trying to profile

00:15:26,330 --> 00:15:32,270
this code actually sees it our like

00:15:28,390 --> 00:15:34,550
boxes over here and our kind of classes

00:15:32,270 --> 00:15:37,010
instead of structs over here and here

00:15:34,550 --> 00:15:39,470
are actually stress in GC and they're

00:15:37,010 --> 00:15:42,080
like doing it really hard because we are

00:15:39,470 --> 00:15:43,700
basically half we have like the super

00:15:42,080 --> 00:15:49,700
important domain specific function in

00:15:43,700 --> 00:15:53,030
here called radians it's called like 800

00:15:49,700 --> 00:15:55,220
x 600 times four times so whatever

00:15:53,030 --> 00:15:59,120
happens there happens a lot so we

00:15:55,220 --> 00:16:01,460
allocate two boxes like just here they

00:15:59,120 --> 00:16:03,920
actually kind of stress GC and suddenly

00:16:01,460 --> 00:16:06,920
the code that would used just one core

00:16:03,920 --> 00:16:09,530
and ten megabytes of memory would easily

00:16:06,920 --> 00:16:13,280
use four cores and 100 bytes of memory

00:16:09,530 --> 00:16:18,350
and be twice lower that's that's cool

00:16:13,280 --> 00:16:19,820
yeah so so then the question is like so

00:16:18,350 --> 00:16:20,930
this is really important code so we need

00:16:19,820 --> 00:16:22,580
to make it fast

00:16:20,930 --> 00:16:26,030
and we need to make it fast like now

00:16:22,580 --> 00:16:27,770
okay so we can do some fancy stuff like

00:16:26,030 --> 00:16:30,140
we can try use ton miss can't a we can

00:16:27,770 --> 00:16:34,250
allocate memory of heap we can reuse

00:16:30,140 --> 00:16:35,900
allocations to remove the stress GC

00:16:34,250 --> 00:16:37,280
pressure because we allocate lots of

00:16:35,900 --> 00:16:39,500
vectors when we compute stuff

00:16:37,280 --> 00:16:41,120
mathematically we can try to reduce

00:16:39,500 --> 00:16:42,560
instances with like all of this crazy

00:16:41,120 --> 00:16:44,930
stuff you know just this code was

00:16:42,560 --> 00:16:47,420
already kind of too ugly for me you know

00:16:44,930 --> 00:16:49,490
and like we can probably make it a bit

00:16:47,420 --> 00:16:51,860
faster and a bit awkward but this kind

00:16:49,490 --> 00:16:55,130
of like you know defeats the point

00:16:51,860 --> 00:16:56,930
because actually this code in C++ wasn't

00:16:55,130 --> 00:16:59,870
that horrible if we think about it

00:16:56,930 --> 00:17:02,420
because it was fast and was actually

00:16:59,870 --> 00:17:04,520
like it was as obvious and as clear and

00:17:02,420 --> 00:17:06,650
as easy to read as whatever reported to

00:17:04,520 --> 00:17:09,890
we didn't make it nice enough on the way

00:17:06,650 --> 00:17:12,199
and but you're like what people suggest

00:17:09,890 --> 00:17:13,730
means conversation just like use Salamis

00:17:12,199 --> 00:17:15,110
can save and make it uglier like even

00:17:13,730 --> 00:17:16,670
uglier why would you want to make out

00:17:15,110 --> 00:17:19,250
uglier than what I already had in C++

00:17:16,670 --> 00:17:21,709
you know it's kind of like that's not

00:17:19,250 --> 00:17:23,920
what we want so you hit your head

00:17:21,709 --> 00:17:29,180
against the wall for for awhile right

00:17:23,920 --> 00:17:32,150
because this kind of like issue that cab

00:17:29,180 --> 00:17:32,570
do it fix itself you know and you try

00:17:32,150 --> 00:17:34,160
everything

00:17:32,570 --> 00:17:35,870
it doesn't quite seem to work like

00:17:34,160 --> 00:17:37,880
people give you different advices how to

00:17:35,870 --> 00:17:39,380
make this code faster but it's kind of

00:17:37,880 --> 00:17:41,420
like too hard you know all of it is just

00:17:39,380 --> 00:17:44,090
you know you just have us here and like

00:17:41,420 --> 00:17:46,430
maybe C++ is not horrible language and

00:17:44,090 --> 00:17:52,670
then you just realize what you just said

00:17:46,430 --> 00:17:54,680
you know yeah yeah so then so what

00:17:52,670 --> 00:17:56,270
happens you just like you go somewhere

00:17:54,680 --> 00:17:57,620
insolent in some village and just

00:17:56,270 --> 00:18:00,860
isolate yourself from the rest of the

00:17:57,620 --> 00:18:02,510
world for nine months and hack and and

00:18:00,860 --> 00:18:04,040
hopefully like ninth month later you

00:18:02,510 --> 00:18:07,850
have something else to show right

00:18:04,040 --> 00:18:09,980
hopefully so here is this this some

00:18:07,850 --> 00:18:11,930
snail stamps and hopefully so as you can

00:18:09,980 --> 00:18:15,410
see it has this skull a naked dog native

00:18:11,930 --> 00:18:16,700
import and on top and it means we are

00:18:15,410 --> 00:18:19,130
doing something else we are not doing

00:18:16,700 --> 00:18:20,540
exactly the same thing we did before so

00:18:19,130 --> 00:18:23,270
actually we have this kind of like

00:18:20,540 --> 00:18:26,990
abstract annotation now it came from

00:18:23,270 --> 00:18:29,030
this underscore import and it probably

00:18:26,990 --> 00:18:31,430
does something that makes made to make

00:18:29,030 --> 00:18:34,640
it faster but like let's keep reading so

00:18:31,430 --> 00:18:36,020
so we made ever since tracks we made

00:18:34,640 --> 00:18:40,010
ever since track so it's hopefully it

00:18:36,020 --> 00:18:43,520
will not cause any GC pressure we also

00:18:40,010 --> 00:18:45,860
have this extern thing it calls it looks

00:18:43,520 --> 00:18:48,770
like some signature for some c function

00:18:45,860 --> 00:18:53,570
somewhere probably some kind of intro

00:18:48,770 --> 00:18:55,430
player I know yeah but like or fancy

00:18:53,570 --> 00:18:58,130
global mutable state is now just

00:18:55,430 --> 00:19:01,400
allocated in a non GC heap just easily

00:18:58,130 --> 00:19:03,200
and basically it's almost the same code

00:19:01,400 --> 00:19:05,570
with some minor changes and remember our

00:19:03,200 --> 00:19:07,160
like tight spot before or here where we

00:19:05,570 --> 00:19:09,170
had new array of one element we have

00:19:07,160 --> 00:19:12,110
this like fancy stack allocate of T now

00:19:09,170 --> 00:19:15,020
so we can just select allocate and snap

00:19:12,110 --> 00:19:17,060
you know again not to stress the GC and

00:19:15,020 --> 00:19:18,830
in the end we basically have almost the

00:19:17,060 --> 00:19:20,710
same code you know if it would dip it it

00:19:18,830 --> 00:19:23,090
would just have a very minor kind of ik

00:19:20,710 --> 00:19:25,150
differences here and there mostly the

00:19:23,090 --> 00:19:29,660
same code so but like

00:19:25,150 --> 00:19:31,040
shall we run it so I compile it before

00:19:29,660 --> 00:19:33,760
because compilation like we don't mesh

00:19:31,040 --> 00:19:36,800
Marc compilation but basically it just

00:19:33,760 --> 00:19:38,600
it runs it doesn't look too slow

00:19:36,800 --> 00:19:40,920
definitely looks faster than previous

00:19:38,600 --> 00:19:45,240
one so let's see

00:19:40,920 --> 00:19:48,930
oh now it's like a tweet ten seconds

00:19:45,240 --> 00:19:51,300
versus seven seconds on C++ and 14

00:19:48,930 --> 00:19:53,340
almost 15 seconds for Java ah so I guess

00:19:51,300 --> 00:19:55,860
that's not too bad I mean I would

00:19:53,340 --> 00:19:57,330
definitely see kind of like going with

00:19:55,860 --> 00:20:00,720
this you know just like 20% slower

00:19:57,330 --> 00:20:04,290
that's not too bad I guess we can roll

00:20:00,720 --> 00:20:06,540
with the tail and and actually it still

00:20:04,290 --> 00:20:08,790
uses the same amount of resources as C++

00:20:06,540 --> 00:20:11,540
app it still does not allocate anything

00:20:08,790 --> 00:20:14,970
on GC heap we allocate everything either

00:20:11,540 --> 00:20:15,330
manually or stack allocated and it

00:20:14,970 --> 00:20:17,220
actually

00:20:15,330 --> 00:20:20,190
basically has the same performance

00:20:17,220 --> 00:20:23,190
profile C++ code with some miners slow

00:20:20,190 --> 00:20:25,050
down I guess it's not too high price to

00:20:23,190 --> 00:20:26,880
pay and it's pretty nice we didn't

00:20:25,050 --> 00:20:34,770
really change much code right that's

00:20:26,880 --> 00:20:36,660
good now I - I probably confusing

00:20:34,770 --> 00:20:40,950
Morrison has an answered with this kind

00:20:36,660 --> 00:20:42,120
of demo and here I'll just like quickly

00:20:40,950 --> 00:20:44,880
answer all the questions that people

00:20:42,120 --> 00:20:48,090
just asked me before and there are kind

00:20:44,880 --> 00:20:50,670
of like lots of them right so first of

00:20:48,090 --> 00:20:53,910
all is it based on LVM well yeah of

00:20:50,670 --> 00:20:56,760
course what else would you base it on

00:20:53,910 --> 00:20:59,190
it's like is the only reasonable choice

00:20:56,760 --> 00:21:00,800
for in a head of time compiler for Scala

00:20:59,190 --> 00:21:03,570
and that's what it is

00:21:00,800 --> 00:21:05,910
can't optimize telcos someone asked me

00:21:03,570 --> 00:21:08,040
on Twitter yeah it can optimize telcos

00:21:05,910 --> 00:21:10,920
LVM is pretty good optimizing them and

00:21:08,040 --> 00:21:13,830
it can also do mutual tail calls that's

00:21:10,920 --> 00:21:16,920
nice that's very good it is the same

00:21:13,830 --> 00:21:18,450
language well mostly it's the same

00:21:16,920 --> 00:21:21,300
language plus the extra stuff that they

00:21:18,450 --> 00:21:24,720
really wanted like pointers and structs

00:21:21,300 --> 00:21:28,020
and and others like stuff like stack

00:21:24,720 --> 00:21:32,880
allocate and it's basically Scala was a

00:21:28,020 --> 00:21:34,710
bit more loyal filter it is it just back

00:21:32,880 --> 00:21:36,390
end you know because nowadays all

00:21:34,710 --> 00:21:37,890
backends look like this right so you

00:21:36,390 --> 00:21:41,040
have a compiler and part of the compiler

00:21:37,890 --> 00:21:43,320
is back and right it's kind of like but

00:21:41,040 --> 00:21:45,180
not really because this kind of like

00:21:43,320 --> 00:21:46,470
approach doesn't really scale if you

00:21:45,180 --> 00:21:49,560
want to do anything non-trivial

00:21:46,470 --> 00:21:51,150
so how it looks and in practice is

00:21:49,560 --> 00:21:53,190
actually a bit more complicated because

00:21:51,150 --> 00:21:55,230
you would really want to support more

00:21:53,190 --> 00:21:57,330
than one front-end you would want

00:21:55,230 --> 00:21:59,730
both Scalzi and does it benefit from

00:21:57,330 --> 00:22:02,429
this nice stuff and for this you need a

00:21:59,730 --> 00:22:03,630
front end backhand and something in

00:22:02,429 --> 00:22:06,390
between to communicate between the two

00:22:03,630 --> 00:22:08,340
and so we have like this kind of like a

00:22:06,390 --> 00:22:09,600
bit more complicated scheme where where

00:22:08,340 --> 00:22:14,460
we compiled first 2ir

00:22:09,600 --> 00:22:18,960
that we assemble it together and compile

00:22:14,460 --> 00:22:20,910
the whole app telegram and as you can

00:22:18,960 --> 00:22:24,390
see in dotty you have this nice fancy

00:22:20,910 --> 00:22:25,559
LTO singing see it's kinda it's kind of

00:22:24,390 --> 00:22:28,200
a bit different from what we have for

00:22:25,559 --> 00:22:31,830
Scala see and this one is because of the

00:22:28,200 --> 00:22:33,539
like new fancy linker by Dimitri and you

00:22:31,830 --> 00:22:35,220
know this whole image is gonna be even

00:22:33,539 --> 00:22:36,960
fancier like was over time with

00:22:35,220 --> 00:22:41,760
domain-specific technicians and so on to

00:22:36,960 --> 00:22:43,260
force its garbage collected so what I've

00:22:41,760 --> 00:22:44,760
showed you is basically like allocated

00:22:43,260 --> 00:22:47,460
everything manually do you have to do

00:22:44,760 --> 00:22:49,230
this of course not like Scala is garbage

00:22:47,460 --> 00:22:52,230
collected language and it's gonna stay

00:22:49,230 --> 00:22:55,500
garbage collected for observable periods

00:22:52,230 --> 00:22:57,690
of time it's the first release of Scala

00:22:55,500 --> 00:23:00,419
even already happens it's gonna be with

00:22:57,690 --> 00:23:05,190
Boheme GC and it cannot only get better

00:23:00,419 --> 00:23:07,620
from there you know yeah so what kind of

00:23:05,190 --> 00:23:10,049
hardware do we support so we compiled to

00:23:07,620 --> 00:23:13,230
native code it means our like final

00:23:10,049 --> 00:23:16,230
output is native binary and dense first

00:23:13,230 --> 00:23:19,650
we can't like develop on Intel's 64-bit

00:23:16,230 --> 00:23:23,789
we've had a lot of requests for arm both

00:23:19,650 --> 00:23:27,570
32 and 64-bit and this some people are

00:23:23,789 --> 00:23:28,950
interested in so library support what

00:23:27,570 --> 00:23:31,020
kind of libraries can you use in Scala

00:23:28,950 --> 00:23:33,570
life so first of all whatever heavens

00:23:31,020 --> 00:23:35,909
see in any way either standard or

00:23:33,570 --> 00:23:38,190
non-standard you can use easily as we've

00:23:35,909 --> 00:23:40,110
seen before is external objects thing it

00:23:38,190 --> 00:23:42,030
just lets you to just define a signature

00:23:40,110 --> 00:23:43,530
for C function and just call it for

00:23:42,030 --> 00:23:46,789
frog's legs you don't you don't need to

00:23:43,530 --> 00:23:49,740
make this all of this ceremony about

00:23:46,789 --> 00:23:53,010
gni about about trying to kind of like I

00:23:49,740 --> 00:23:55,049
have multiple layers of signatures one

00:23:53,010 --> 00:23:56,429
on Java side one on the side and so on

00:23:55,049 --> 00:24:00,200
so forth so it should be like easy and

00:23:56,429 --> 00:24:04,799
this easy and of course we

00:24:00,200 --> 00:24:08,039
Scala has a reasonably small side

00:24:04,799 --> 00:24:10,499
library and so we

00:24:08,039 --> 00:24:12,869
a subset of Java libraries built in some

00:24:10,499 --> 00:24:15,239
small subsets that people actually care

00:24:12,869 --> 00:24:17,190
about so if it's not there and you care

00:24:15,239 --> 00:24:20,129
about it in a just come to us and tell

00:24:17,190 --> 00:24:26,269
us quit and we'll probably it is it open

00:24:20,129 --> 00:24:26,269
source yeah it is open source like now

00:24:27,350 --> 00:24:51,139
yay no not this one oh come on just let

00:24:46,979 --> 00:24:55,669
me do it yeah should be public now okay

00:24:51,139 --> 00:24:58,789
okay okay so is it released yet yeah

00:24:55,669 --> 00:25:00,359
still down with scribing yeah and

00:24:58,789 --> 00:25:04,289
actually not yet

00:25:00,359 --> 00:25:06,389
and it's gonna be already like one day

00:25:04,289 --> 00:25:07,950
in near future I will not say any kind

00:25:06,389 --> 00:25:10,019
of like stupid things like in one month

00:25:07,950 --> 00:25:12,739
or useless so I've never said this or

00:25:10,019 --> 00:25:15,119
I'm not saying this end so we're gonna

00:25:12,739 --> 00:25:17,519
release it once ready so we have twitter

00:25:15,119 --> 00:25:19,889
account or we can follow us and get

00:25:17,519 --> 00:25:21,479
latest updates and what going on we have

00:25:19,889 --> 00:25:23,279
milestones on github so you can also

00:25:21,479 --> 00:25:24,830
follow those that give you some

00:25:23,279 --> 00:25:27,419
indication of what's going on around

00:25:24,830 --> 00:25:28,769
thanks questions what what kind of

00:25:27,419 --> 00:25:30,269
subset of the scala standard library

00:25:28,769 --> 00:25:32,399
works because so much of the standard

00:25:30,269 --> 00:25:34,559
library sort of inherits semantics from

00:25:32,399 --> 00:25:36,779
Java right which is which is a problem

00:25:34,559 --> 00:25:38,970
back in the MS IL days but like it's no

00:25:36,779 --> 00:25:42,149
problem now so basically everything is

00:25:38,970 --> 00:25:45,229
used for standard library will we when I

00:25:42,149 --> 00:25:47,309
say everything I mean everything in a

00:25:45,229 --> 00:25:49,590
reasonable like for collections and so

00:25:47,309 --> 00:25:50,729
on to force we will expect to have on

00:25:49,590 --> 00:25:52,289
the first release we already have a

00:25:50,729 --> 00:25:54,559
small subset of Java libraries

00:25:52,289 --> 00:25:56,940
implemented so it like whatever kind of

00:25:54,559 --> 00:25:58,349
whatever we happen to depend on in Scala

00:25:56,940 --> 00:26:01,619
library most likely would be implement

00:25:58,349 --> 00:26:03,419
in Java in Java a library subset so this

00:26:01,619 --> 00:26:06,479
would not be any issue some parts are

00:26:03,419 --> 00:26:08,009
not supported what parts exactly are not

00:26:06,479 --> 00:26:10,320
supported it's kind of like a question

00:26:08,009 --> 00:26:11,909
to be discussed but most like normal

00:26:10,320 --> 00:26:17,690
skeleton code like collections and stuff

00:26:11,909 --> 00:26:17,690
should just work yeah

00:26:19,070 --> 00:26:25,220
the question was how do you debug so so

00:26:22,490 --> 00:26:27,290
right now it's basically on elevating

00:26:25,220 --> 00:26:29,000
like on JVM we use JV and the bars and

00:26:27,290 --> 00:26:31,010
they're nice you know they kind of like

00:26:29,000 --> 00:26:34,460
give you a reasonably high level view of

00:26:31,010 --> 00:26:36,470
code on LLVM you can debug with ldb it's

00:26:34,460 --> 00:26:39,050
elegant debugger that kind of like takes

00:26:36,470 --> 00:26:41,410
advantage of LLVM representation and

00:26:39,050 --> 00:26:43,610
knows about it currently we don't emit

00:26:41,410 --> 00:26:46,940
symbols necessary to make it super nice

00:26:43,610 --> 00:26:49,520
in the future will emit necessary

00:26:46,940 --> 00:26:52,220
opposition information about fur coat so

00:26:49,520 --> 00:26:55,670
that you could just step in in l DB so l

00:26:52,220 --> 00:27:00,010
DB is kind of like our strategy in the

00:26:55,670 --> 00:27:00,010
space yeah

00:27:03,000 --> 00:27:08,820
so how can you make entry points into

00:27:05,790 --> 00:27:11,220
the Scala code from that you can call

00:27:08,820 --> 00:27:14,010
from see for example make a library

00:27:11,220 --> 00:27:17,910
writing the Scala code so you want to

00:27:14,010 --> 00:27:21,240
call from C 2's color yeah so we have

00:27:17,910 --> 00:27:23,690
this external object and if you use C++

00:27:21,240 --> 00:27:26,700
in C++ we have this external scopes and

00:27:23,690 --> 00:27:28,620
the two are very similar so basically

00:27:26,700 --> 00:27:30,690
it's kind of like is it this should not

00:27:28,620 --> 00:27:32,220
answer your question I think so if you

00:27:30,690 --> 00:27:34,700
say extra object in define stuff there

00:27:32,220 --> 00:27:38,640
is external

00:27:34,700 --> 00:27:40,680
yeah so how about dealing with like

00:27:38,640 --> 00:27:41,940
callbacks a lot of C libraries more

00:27:40,680 --> 00:27:43,920
callbacks right me take function

00:27:41,940 --> 00:27:45,660
pointers or things like that like how do

00:27:43,920 --> 00:27:54,030
you deal with that will have function

00:27:45,660 --> 00:27:58,200
pointers what about concurrency

00:27:54,030 --> 00:28:00,750
the first release is going to be not

00:27:58,200 --> 00:28:04,470
parallel but concurrent so we will not

00:28:00,750 --> 00:28:05,940
have multiple stress from day one it's

00:28:04,470 --> 00:28:07,790
an implementation of restrictions and

00:28:05,940 --> 00:28:12,080
will never release one zero without

00:28:07,790 --> 00:28:13,770
parallelism of course that's crap

00:28:12,080 --> 00:28:16,460
sometime in the future will happen

00:28:13,770 --> 00:28:16,460
hopefully

00:28:19,720 --> 00:28:23,970
I'm going around yep

00:28:25,280 --> 00:28:30,380
anyone else oh okay

00:28:28,250 --> 00:28:35,210
mike is going in the direction I think

00:28:30,380 --> 00:28:37,659
yeah have you thought about or have you

00:28:35,210 --> 00:28:40,280
seen any situations where for example

00:28:37,659 --> 00:28:41,750
the static allocation caller you were

00:28:40,280 --> 00:28:44,030
doing in one of your functions

00:28:41,750 --> 00:28:47,120
could that have you seen a situation

00:28:44,030 --> 00:28:50,090
where maybe the compiler can determine

00:28:47,120 --> 00:28:52,039
whether that can be stacked so that you

00:28:50,090 --> 00:28:54,020
don't have to call it explicitly I see

00:28:52,039 --> 00:28:55,760
what you mean so what they're saying is

00:28:54,020 --> 00:28:57,260
Kenny compiler automatically stack

00:28:55,760 --> 00:29:00,770
allocate stuff so that we don't have to

00:28:57,260 --> 00:29:03,470
and the answer is TV and compiler

00:29:00,770 --> 00:29:06,250
already tries to lose it on JVM and but

00:29:03,470 --> 00:29:08,390
the question is it doesn't always work

00:29:06,250 --> 00:29:10,159
the way it's supposed to be because it

00:29:08,390 --> 00:29:11,690
is dependent on analysis to make sure

00:29:10,159 --> 00:29:13,340
that you cannot just stack allocate

00:29:11,690 --> 00:29:15,590
stuff randomly so you need to do an

00:29:13,340 --> 00:29:17,419
analysis to make sure it whatever like

00:29:15,590 --> 00:29:20,500
you stuck allocate that doesn't escape

00:29:17,419 --> 00:29:22,610
some definition of escape so it's safe

00:29:20,500 --> 00:29:24,799
we listen your API is to kind of like

00:29:22,610 --> 00:29:27,620
say I know what I'm doing so it's fine

00:29:24,799 --> 00:29:29,659
so you don't need to be paranoid about

00:29:27,620 --> 00:29:32,179
it but it's really hard to make it work

00:29:29,659 --> 00:29:33,620
for every single case when it's a

00:29:32,179 --> 00:29:36,140
compiler optimizations in some cases

00:29:33,620 --> 00:29:37,400
wilshire a compiler might be able to

00:29:36,140 --> 00:29:39,919
stack allocate things but trample here

00:29:37,400 --> 00:29:42,350
we can see on JVM if you profile that we

00:29:39,919 --> 00:29:46,010
had like the second code it cannot stack

00:29:42,350 --> 00:29:48,380
allocate nicer vectors nor arrays of one

00:29:46,010 --> 00:29:50,900
element because just an analysis did not

00:29:48,380 --> 00:29:55,539
quite work very it supposed to I mean

00:29:50,900 --> 00:29:55,539
yeah yeah

00:30:01,070 --> 00:30:07,519
yeah over here

00:30:02,849 --> 00:30:11,759
oh hello okay someone keep going left

00:30:07,519 --> 00:30:13,950
left yeah okay cool um what did the

00:30:11,759 --> 00:30:16,320
startup costs associated with like

00:30:13,950 --> 00:30:18,509
starting a JVM and since versus LLVM

00:30:16,320 --> 00:30:21,330
from a time perspective of course of

00:30:18,509 --> 00:30:23,070
course startup is an issue it's kind of

00:30:21,330 --> 00:30:25,859
the whole point of culinary of not

00:30:23,070 --> 00:30:29,009
having this issue basically so in some

00:30:25,859 --> 00:30:31,379
cases but again here the main issue was

00:30:29,009 --> 00:30:33,149
not startup time because we are

00:30:31,379 --> 00:30:36,960
basically just stressing but you see

00:30:33,149 --> 00:30:39,749
here in so kind of main issue here it's

00:30:36,960 --> 00:30:42,210
not strapped I mean it definitely made

00:30:39,749 --> 00:30:47,849
it look even worse because of the VM

00:30:42,210 --> 00:30:51,749
time yeah do you have a feel for what

00:30:47,849 --> 00:30:53,549
accounts for that 20% difference yeah I

00:30:51,749 --> 00:30:55,289
think I have like a number of features

00:30:53,549 --> 00:30:57,119
in Scala which we sort of like need to

00:30:55,289 --> 00:31:00,619
optimize before LVM because the LA VM is

00:30:57,119 --> 00:31:03,089
not perfectly handled for us for example

00:31:00,619 --> 00:31:07,080
we don't have top level functions so I

00:31:03,089 --> 00:31:08,519
can see so whenever we call a function

00:31:07,080 --> 00:31:09,989
in a module you actually need to check

00:31:08,519 --> 00:31:12,059
that it's initialized you know like

00:31:09,989 --> 00:31:14,489
modules are lately initialized and then

00:31:12,059 --> 00:31:16,830
I think it's one of the causes for where

00:31:14,489 --> 00:31:19,379
we see a slowdown because our code is in

00:31:16,830 --> 00:31:22,469
objects and whenever you do it because

00:31:19,379 --> 00:31:25,169
there it has a potential extra check I

00:31:22,469 --> 00:31:27,359
think it might be possible to remove

00:31:25,169 --> 00:31:29,539
that gap but I will not promise you

00:31:27,359 --> 00:31:29,539
anything

00:31:37,530 --> 00:31:43,680
hi a couple of questions the first one

00:31:40,980 --> 00:31:46,890
is do you think this will open the door

00:31:43,680 --> 00:31:48,590
for iOS development given that you can

00:31:46,890 --> 00:31:52,110
compile to the OPM

00:31:48,590 --> 00:31:54,120
there too and the other one was what

00:31:52,110 --> 00:31:55,980
about things that depend on threads like

00:31:54,120 --> 00:31:58,920
thread pools executor services their

00:31:55,980 --> 00:32:03,120
libraries or code that we had today tied

00:31:58,920 --> 00:32:06,240
to the Java okay so for iOS answer is

00:32:03,120 --> 00:32:08,820
like once we have tested and kind of

00:32:06,240 --> 00:32:12,630
like published deployed and kind of like

00:32:08,820 --> 00:32:14,220
approved arm supports basically it's

00:32:12,630 --> 00:32:16,080
called an ad from LLVM point of view

00:32:14,220 --> 00:32:18,780
from a tool chain like after us looks

00:32:16,080 --> 00:32:21,930
like any other C app so it does doesn't

00:32:18,780 --> 00:32:23,790
do anything completely crazy so if you

00:32:21,930 --> 00:32:26,430
can build something with clang somewhere

00:32:23,790 --> 00:32:30,450
it for receivables that you can port

00:32:26,430 --> 00:32:32,400
colonize this platform and arm in

00:32:30,450 --> 00:32:34,700
particular has been a great interest to

00:32:32,400 --> 00:32:37,890
many people so it's like we will

00:32:34,700 --> 00:32:41,040
prioritize that only supplies ones who

00:32:37,890 --> 00:32:42,660
like support but of course at first

00:32:41,040 --> 00:32:47,820
we'll have just Intel but in the future

00:32:42,660 --> 00:32:50,190
would this list will hopefully grows and

00:32:47,820 --> 00:32:51,990
speaking about circles I'm sorry like a

00:32:50,190 --> 00:32:54,930
second question about circles and so on

00:32:51,990 --> 00:32:57,690
the force so right now we are single

00:32:54,930 --> 00:33:00,180
edge from a rest point of you can have

00:32:57,690 --> 00:33:01,470
concurrency and you can even try to use

00:33:00,180 --> 00:33:04,770
darling strands but it will not do

00:33:01,470 --> 00:33:06,690
anything meaningful to you and but the

00:33:04,770 --> 00:33:07,950
question is like what kind of like

00:33:06,690 --> 00:33:09,450
Parliament story are we going to have

00:33:07,950 --> 00:33:10,830
it's kind of like open questions for

00:33:09,450 --> 00:33:14,420
next release so I cannot really kind of

00:33:10,830 --> 00:33:14,420
like Saints in there

00:33:17,660 --> 00:33:23,490
how's the exception handling like

00:33:20,160 --> 00:33:23,970
especially the undefined behavior oh and

00:33:23,490 --> 00:33:27,510
they find me here

00:33:23,970 --> 00:33:29,520
yeah so all of the unsafe features will

00:33:27,510 --> 00:33:32,190
have undefined behavior similar to what

00:33:29,520 --> 00:33:33,420
we have in C so basically whatever is

00:33:32,190 --> 00:33:34,830
undefined in Siebel probably will

00:33:33,420 --> 00:33:36,600
probably be undefined this cognitive

00:33:34,830 --> 00:33:38,130
like if you do something crazy with

00:33:36,600 --> 00:33:39,900
pointers and then it's not safe it will

00:33:38,130 --> 00:33:42,180
be not safe because obviously it's not

00:33:39,900 --> 00:33:45,450
it's not a kind of bulletproof API this

00:33:42,180 --> 00:33:47,220
is why it gives us benefits because we

00:33:45,450 --> 00:33:49,950
don't need to check at run time anything

00:33:47,220 --> 00:33:51,300
right so we will definitely have

00:33:49,950 --> 00:33:52,980
undefined behavior around unsafe

00:33:51,300 --> 00:33:54,350
features yes so there's still a null

00:33:52,980 --> 00:33:56,610
pointer them

00:33:54,350 --> 00:33:59,010
yeah especially kind of like if you'd

00:33:56,610 --> 00:34:02,120
reference pointer of T its undefined

00:33:59,010 --> 00:34:02,120
behavior if it's not

00:34:07,780 --> 00:34:15,970
yep okay so the two examples one looks

00:34:13,120 --> 00:34:19,990
like it's written for the JVM the other

00:34:15,970 --> 00:34:22,210
example is written for the ll yep are

00:34:19,990 --> 00:34:24,610
you going to have a where you can have

00:34:22,210 --> 00:34:27,760
the same code source and compile it

00:34:24,610 --> 00:34:29,379
either way so as I said before the goal

00:34:27,760 --> 00:34:31,330
is to have the same language so we don't

00:34:29,379 --> 00:34:32,940
try to have a different language so

00:34:31,330 --> 00:34:34,899
whatever we kind of add is just a

00:34:32,940 --> 00:34:36,700
strictly an addition so whatever

00:34:34,899 --> 00:34:39,840
whatever was there as its color before

00:34:36,700 --> 00:34:42,790
is this now today we are it's our goal

00:34:39,840 --> 00:34:44,379
but to give it the way it is so you can

00:34:42,790 --> 00:34:49,389
also run a second coat if you want to

00:34:44,379 --> 00:34:52,000
that's fine yeah yeah so right now we're

00:34:49,389 --> 00:34:53,950
in a situation with Scala is where all

00:34:52,000 --> 00:34:56,160
of the projects especially upstream

00:34:53,950 --> 00:34:59,110
dependencies like you know Scala Zed or

00:34:56,160 --> 00:35:00,280
shapeless or something like that you

00:34:59,110 --> 00:35:02,320
know if people want to use them with

00:35:00,280 --> 00:35:04,630
both you know skull on the JVM and Scala

00:35:02,320 --> 00:35:07,570
j/s those upstream libraries have to be

00:35:04,630 --> 00:35:09,880
compiled with both is this is this just

00:35:07,570 --> 00:35:11,560
sort of adding adding to that problem do

00:35:09,880 --> 00:35:12,580
you see any way to get around this so

00:35:11,560 --> 00:35:14,200
right now we sort of add into this

00:35:12,580 --> 00:35:16,570
problem and it's gonna be like you need

00:35:14,200 --> 00:35:19,330
like if you want really cross-platform

00:35:16,570 --> 00:35:21,730
library you will need to publish for JVM

00:35:19,330 --> 00:35:24,490
GS and native but hopefully this dog is

00:35:21,730 --> 00:35:27,100
gonna be better with tasty but I'm again

00:35:24,490 --> 00:35:29,020
it's kind of like in the future so

00:35:27,100 --> 00:35:31,180
hopefully maybe we'll be able to just

00:35:29,020 --> 00:35:36,970
publish tasty and everybody will be

00:35:31,180 --> 00:35:39,880
happy about it yeah it's not it's not

00:35:36,970 --> 00:35:46,260
for sure but it's kind of a future I

00:35:39,880 --> 00:35:46,260
want to see you any more questions

00:35:47,530 --> 00:35:51,210
any options to interoperate with C++

00:35:50,500 --> 00:35:56,200
code

00:35:51,210 --> 00:35:59,080
I knew this question will happen yeah so

00:35:56,200 --> 00:36:02,290
basically we can enter up with

00:35:59,080 --> 00:36:05,530
externally parts of C++ so if you if you

00:36:02,290 --> 00:36:07,660
export anything with extern C and if you

00:36:05,530 --> 00:36:09,940
kind of like we can like the same way as

00:36:07,660 --> 00:36:12,010
you would like do it if you want to

00:36:09,940 --> 00:36:14,080
interrupt between C and C++ you can you

00:36:12,010 --> 00:36:16,810
can do externally or up everything into

00:36:14,080 --> 00:36:18,520
a helper function in C++ sides and then

00:36:16,810 --> 00:36:21,070
you can use it from Scala native you

00:36:18,520 --> 00:36:27,720
cannot directly use mangled names from

00:36:21,070 --> 00:36:27,720
C++ from scholars okay or there

00:36:36,930 --> 00:36:45,930
Oh what about the something like

00:36:40,800 --> 00:36:48,800
OpenCL can you call that from scholar so

00:36:45,930 --> 00:36:52,470
as far as I know OpenCL is primarily

00:36:48,800 --> 00:36:54,480
exposed as capi if it's a capi you can

00:36:52,470 --> 00:36:56,280
call it can you generate the scholar to

00:36:54,480 --> 00:36:57,690
OpenCL that's kind of notice out of

00:36:56,280 --> 00:37:06,660
scope of the project so we are

00:36:57,690 --> 00:37:10,460
definitely not doing that any more

00:37:06,660 --> 00:37:10,460
questions okay

00:37:11,800 --> 00:37:20,630
well because like you know okay the

00:37:18,200 --> 00:37:23,270
question is why do we want to support

00:37:20,630 --> 00:37:25,220
both Scala C and dotty well because I

00:37:23,270 --> 00:37:26,840
think one of the good questions good

00:37:25,220 --> 00:37:30,770
answer this question is basically this

00:37:26,840 --> 00:37:33,200
LTO part at the well by Dmitri it kind

00:37:30,770 --> 00:37:35,150
of promises you to have more

00:37:33,200 --> 00:37:37,550
domain-specific and language specific

00:37:35,150 --> 00:37:39,770
optimizations so it's culinary we also

00:37:37,550 --> 00:37:41,930
kind of slightly optimize your code but

00:37:39,770 --> 00:37:43,849
we really want to be fast to compile we

00:37:41,930 --> 00:37:45,980
it's not our purpose to be fastest to

00:37:43,849 --> 00:37:48,290
compile in LT or Dimitri tries to kind

00:37:45,980 --> 00:37:50,420
of like really get the best out of your

00:37:48,290 --> 00:37:52,520
code possible assuming Scala semantics

00:37:50,420 --> 00:37:54,530
and assuming even a domain-specific

00:37:52,520 --> 00:37:56,210
knowledge about libraries like

00:37:54,530 --> 00:37:59,420
collection library since I want of

00:37:56,210 --> 00:38:01,400
course we are definitely it doesn't look

00:37:59,420 --> 00:38:03,650
good we are not going to get this on

00:38:01,400 --> 00:38:09,609
Scala C so it definitely makes sense to

00:38:03,650 --> 00:38:09,609
have both yeah any more questions

00:38:13,390 --> 00:38:17,530
yeah what primitive types are going to

00:38:15,850 --> 00:38:18,790
be supported so for instance letter is

00:38:17,530 --> 00:38:30,340
there going to be support for like

00:38:18,790 --> 00:38:36,700
unsigned int unsigned long yes I guess

00:38:30,340 --> 00:38:38,020
no more questions okay another one so so

00:38:36,700 --> 00:38:40,000
what do you do with things like string

00:38:38,020 --> 00:38:45,760
and stuff they're already going into see

00:38:40,000 --> 00:38:47,260
now so we have like so whatever we had

00:38:45,760 --> 00:38:48,670
before like all of the Java stuff like

00:38:47,260 --> 00:38:50,650
Java extra we all we still have it

00:38:48,670 --> 00:38:52,690
and whatever C has we still have it and

00:38:50,650 --> 00:38:55,300
this two are separate so when you write

00:38:52,690 --> 00:38:58,690
a string Gojo in Scala it's a Java style

00:38:55,300 --> 00:39:00,720
string and you also have C style strings

00:38:58,690 --> 00:39:02,620
and you have you even have a special

00:39:00,720 --> 00:39:04,390
little index for those so you can

00:39:02,620 --> 00:39:07,210
actually create either of those but

00:39:04,390 --> 00:39:10,150
depending on what you want and of course

00:39:07,210 --> 00:39:11,530
you can convert this means the two but

00:39:10,150 --> 00:39:12,520
to a different or nothing

00:39:11,530 --> 00:39:16,500
yeah because they they have different

00:39:12,520 --> 00:39:16,500
memory layout yeah

00:39:25,210 --> 00:39:31,030
so I saw in the example that you have a

00:39:27,369 --> 00:39:33,520
stack allocated box pipe yeah and you

00:39:31,030 --> 00:39:35,349
would also mention GC heap do you have

00:39:33,520 --> 00:39:38,470
non GC heap available

00:39:35,349 --> 00:39:40,329
I mean malloc is non non GC heap and you

00:39:38,470 --> 00:39:41,260
allow references back and forth between

00:39:40,329 --> 00:39:43,869
the different heaps

00:39:41,260 --> 00:39:45,700
no no so it's the same restriction some

00:39:43,869 --> 00:39:47,940
JVM this part but you can do more of

00:39:45,700 --> 00:39:50,520
heap now so it's kind of like a

00:39:47,940 --> 00:39:52,780
references back are kind of like

00:39:50,520 --> 00:39:56,740
unpossible there goes like you cannot

00:39:52,780 --> 00:39:59,890
really it does not want to traverse non

00:39:56,740 --> 00:40:02,109
GC heap to do a GC because that would be

00:39:59,890 --> 00:40:03,819
hard but if I the whole point so you

00:40:02,109 --> 00:40:06,069
actually have to have this restriction

00:40:03,819 --> 00:40:07,510
but if you use unsafe features you might

00:40:06,069 --> 00:40:11,400
hack your way through but this kind of

00:40:07,510 --> 00:40:11,400
like unsafe unsound unsupported okay

00:40:13,079 --> 00:40:19,559
yeah okay no more questions so it's nice

00:40:16,349 --> 00:40:19,559

YouTube URL: https://www.youtube.com/watch?v=ArWWlwQl37A


