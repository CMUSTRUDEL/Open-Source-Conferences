Title: One Microservices is no microservice: They come in systems - by Markus Eisele
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Building a complete system out of individual Microservices is not as simple as we're being told. While Microservices-based Architecture continues to draw more and more attention we're also starting to learn about the trade-offs and drawbacks. Individual Microservices are fairly easy to understand and implement, but they only make sense as systems, and it is in-between the services that the most challenging (and interesting) problems arise—here we are entering the world of distributed systems.
As we all know, distributed systems are inherently complex and we enterprise developers have been spoiled by centralized servers for too long to easily understand what this really means. Just slicing an existing system into various REST services and wiring them back together again with synchronous protocols and traditional enterprise tools—designed for a monolithic architectures—will set you up for failure.
This talk is going to distill the essence Microservices-based systems and then introduce you to a new development approach to Microservices which gets you started quickly with a guided, minimalistic approach on your local machine and supports you every single step on the way to a productive scaled out Microservices-based system composed of hundreds of services. At the end of this talk, you've experienced first hand how creating systems of microservices on the JVM is dead-simple, intuitive, frictionless and last and more importantly—a lot of fun!
Captions: 
	00:00:05,990 --> 00:00:10,940
good morning everybody it's actually not

00:00:09,410 --> 00:00:13,670
really good morning anymore right it's

00:00:10,940 --> 00:00:16,640
5p you've been so brave sitting in all

00:00:13,670 --> 00:00:19,580
those sessions I can tell you secret 5

00:00:16,640 --> 00:00:21,380
p's of your obviously a valid time of

00:00:19,580 --> 00:00:24,230
the day to start drinking beer at least

00:00:21,380 --> 00:00:28,010
in Germany and this is seriously where I

00:00:24,230 --> 00:00:31,699
come from my name is my fear um I do

00:00:28,010 --> 00:00:34,489
work for like Bend and I try to be a

00:00:31,699 --> 00:00:36,650
developer advocate actually that's not

00:00:34,489 --> 00:00:39,140
my main profession because I've been a

00:00:36,650 --> 00:00:42,379
software architect for almost 14 years

00:00:39,140 --> 00:00:45,229
by now and I've been working with big

00:00:42,379 --> 00:00:47,900
companies on very very large projects

00:00:45,229 --> 00:00:51,170
for almost all of my professional time

00:00:47,900 --> 00:00:54,080
and at some point back in the days I

00:00:51,170 --> 00:00:56,299
started to write a little blog and I

00:00:54,080 --> 00:00:59,030
wanted to share whatever I learned

00:00:56,299 --> 00:01:00,949
during all the times that I've been

00:00:59,030 --> 00:01:03,680
sitting in a dark basement room with

00:01:00,949 --> 00:01:06,830
customers and trying to make the

00:01:03,680 --> 00:01:09,759
impossible happen right and those

00:01:06,830 --> 00:01:13,579
knowledge sharing over time became

00:01:09,759 --> 00:01:16,219
little profession so the block grew and

00:01:13,579 --> 00:01:18,500
I got more readers and I started to give

00:01:16,219 --> 00:01:21,799
my first conference talks obviously in

00:01:18,500 --> 00:01:23,840
German first and I started to travel a

00:01:21,799 --> 00:01:27,079
lot and I'm speaking a lot last year was

00:01:23,840 --> 00:01:30,409
like 35 conferences in total but you've

00:01:27,079 --> 00:01:32,119
probably not seen me so far and I have

00:01:30,409 --> 00:01:34,280
to admit this is my first scala days

00:01:32,119 --> 00:01:36,469
ever and the reason for that is pretty

00:01:34,280 --> 00:01:40,009
simple because i'm a java champion and

00:01:36,469 --> 00:01:42,710
i'm not able to write a single line of

00:01:40,009 --> 00:01:47,170
Scala code if I don't copy and paste it

00:01:42,710 --> 00:01:50,659
from somewhere the funny part is that

00:01:47,170 --> 00:01:52,219
microservices is such a big topic that

00:01:50,659 --> 00:01:55,039
we all want to learn about and

00:01:52,219 --> 00:01:57,380
especially the java community especially

00:01:55,039 --> 00:02:00,469
the enterprise's out there they are

00:01:57,380 --> 00:02:02,569
driving the modernization approaches

00:02:00,469 --> 00:02:06,729
behind microservices at the very moment

00:02:02,569 --> 00:02:10,130
and the reason for that is pretty simple

00:02:06,729 --> 00:02:12,700
because they've been actually locked in

00:02:10,130 --> 00:02:16,520
on something called application servers

00:02:12,700 --> 00:02:17,560
for many many years and i'm pretty sure

00:02:16,520 --> 00:02:19,300
that at least

00:02:17,560 --> 00:02:23,650
a couple of you had to deal with that

00:02:19,300 --> 00:02:26,739
kind of monsters in the past it looked

00:02:23,650 --> 00:02:30,459
pretty decent right it's still hardly

00:02:26,739 --> 00:02:33,640
readable it's still a lot of annotations

00:02:30,459 --> 00:02:37,959
it's a lot of restful it's a lot of

00:02:33,640 --> 00:02:40,269
evangelizing Venge eliza ng j2ee java ee

00:02:37,959 --> 00:02:41,920
api is out there when it comes to micro

00:02:40,269 --> 00:02:45,040
services and this is pretty much the

00:02:41,920 --> 00:02:47,260
first thing that you read about when you

00:02:45,040 --> 00:02:49,480
start to reach research your own

00:02:47,260 --> 00:02:52,390
information around microsoft somebody is

00:02:49,480 --> 00:02:56,260
telling you all you have to do to slice

00:02:52,390 --> 00:03:01,390
up your monolith is to exactly slice up

00:02:56,260 --> 00:03:05,230
your existing working application into

00:03:01,390 --> 00:03:10,239
individual rest endpoints and chain them

00:03:05,230 --> 00:03:15,099
together again in some way and this is

00:03:10,239 --> 00:03:19,150
not exactly true I mean just an example

00:03:15,099 --> 00:03:23,620
at that point if I would like to access

00:03:19,150 --> 00:03:26,260
another rest endpoint from my own rest

00:03:23,620 --> 00:03:29,109
endpoint I will have to start to hard

00:03:26,260 --> 00:03:34,269
code stuff in there I would have to hard

00:03:29,109 --> 00:03:37,420
code the other responds URL I would have

00:03:34,269 --> 00:03:39,730
to actually query that like as a client

00:03:37,420 --> 00:03:42,940
on the server there are so many

00:03:39,730 --> 00:03:46,329
architectural wrongs in this example I

00:03:42,940 --> 00:03:49,930
couldn't even name them and I'm thinking

00:03:46,329 --> 00:03:56,109
that a little bit further than just with

00:03:49,930 --> 00:03:58,840
that fancy java ee example here what

00:03:56,109 --> 00:04:03,549
does it actually mean if i'm going to

00:03:58,840 --> 00:04:06,209
deploy a java ee microservice it's not

00:04:03,549 --> 00:04:09,970
like the one file right and it's not

00:04:06,209 --> 00:04:13,420
easy we are going to package everything

00:04:09,970 --> 00:04:16,570
up in an endless chain of jar files zip

00:04:13,420 --> 00:04:19,570
files put everything into this magic

00:04:16,570 --> 00:04:21,160
application servers thing and we have a

00:04:19,570 --> 00:04:25,330
virtual machine we have an operating

00:04:21,160 --> 00:04:28,160
system this is insane isn't it seriously

00:04:25,330 --> 00:04:31,540
do I want to run a single rest and

00:04:28,160 --> 00:04:34,430
mind with a complete stack somewhere

00:04:31,540 --> 00:04:36,470
this is why Java applications have been

00:04:34,430 --> 00:04:41,180
very successful in enterprises because

00:04:36,470 --> 00:04:44,780
they actually were able to build out a

00:04:41,180 --> 00:04:47,030
process around those things putting a

00:04:44,780 --> 00:04:49,610
monolithic application in production at

00:04:47,030 --> 00:04:51,890
a reasonable three-letter shortcut

00:04:49,610 --> 00:04:58,100
company in Germany building elders and

00:04:51,890 --> 00:05:00,590
cars took actually 18 programmers for

00:04:58,100 --> 00:05:03,500
business analysts keep counting to

00:05:00,590 --> 00:05:09,020
project managers six quality insurance

00:05:03,500 --> 00:05:13,400
engineers three dbas to compliance

00:05:09,020 --> 00:05:17,930
officers and no less than six operation

00:05:13,400 --> 00:05:19,430
guys whoa so this is the thing we're

00:05:17,930 --> 00:05:21,350
going to slice apart right at s

00:05:19,430 --> 00:05:26,260
microservices and we're going to make it

00:05:21,350 --> 00:05:29,990
better what is actually happening here

00:05:26,260 --> 00:05:33,230
if we're slicing up one of those old

00:05:29,990 --> 00:05:36,410
monolithic applications the exact

00:05:33,230 --> 00:05:39,850
opposite happens of what everybody wants

00:05:36,410 --> 00:05:44,840
to tell you right now the complexity is

00:05:39,850 --> 00:05:48,919
just totally blowing up you have a ton

00:05:44,840 --> 00:05:52,220
of teams and you need to actually make

00:05:48,919 --> 00:05:54,020
that whole thing work so Java EE

00:05:52,220 --> 00:05:55,880
application servers in that kind of

00:05:54,020 --> 00:05:59,690
enterprise-e settings with that kind of

00:05:55,880 --> 00:06:03,410
big teams is senseless right that's the

00:05:59,690 --> 00:06:07,340
point and we have to admit that breaking

00:06:03,410 --> 00:06:11,630
up the monolithic applications is really

00:06:07,340 --> 00:06:13,550
needed today for many reasons back in

00:06:11,630 --> 00:06:15,320
the days we had a web browser we had a

00:06:13,550 --> 00:06:17,600
server we had all our logic on the

00:06:15,320 --> 00:06:20,540
server everything got rendered today

00:06:17,600 --> 00:06:24,380
we're using like mobile devices even my

00:06:20,540 --> 00:06:28,310
car talks back to his manufacturer and

00:06:24,380 --> 00:06:30,140
delivers data and the worst cases they

00:06:28,310 --> 00:06:32,330
call me and tell me something's wrong

00:06:30,140 --> 00:06:35,060
with my car what do you what do you

00:06:32,330 --> 00:06:37,550
believe is doing all the magic in the

00:06:35,060 --> 00:06:40,740
back end and it's not only my own car

00:06:37,550 --> 00:06:42,960
its twenty thousand millions whatever

00:06:40,740 --> 00:06:45,000
cars and they are all talking to some

00:06:42,960 --> 00:06:47,160
kind of back end and just imagine that

00:06:45,000 --> 00:06:50,130
cluster of java ee application servers

00:06:47,160 --> 00:06:52,110
and the trillions of people you need to

00:06:50,130 --> 00:06:55,289
make that happen obviously the

00:06:52,110 --> 00:07:00,599
architectural approaches of yesterday

00:06:55,289 --> 00:07:02,069
are to be modernized and i think those

00:07:00,599 --> 00:07:04,020
two worlds like talking about

00:07:02,069 --> 00:07:07,020
microservices talking more generally

00:07:04,020 --> 00:07:09,690
about modernization they just happen to

00:07:07,020 --> 00:07:12,569
clash and happen to fit very nicely into

00:07:09,690 --> 00:07:15,000
each other and this is why microservices

00:07:12,569 --> 00:07:17,130
is such a thing right now and everybody

00:07:15,000 --> 00:07:22,050
is trying to jump on the on the micro

00:07:17,130 --> 00:07:24,330
services wagon i am letting go of java

00:07:22,050 --> 00:07:29,370
ee at that point so feel relieved what I

00:07:24,330 --> 00:07:32,430
still want to do I want to try to try to

00:07:29,370 --> 00:07:35,699
explain why microservices are so

00:07:32,430 --> 00:07:39,990
attractive to enterprises to customers

00:07:35,699 --> 00:07:43,199
at the very moment software really

00:07:39,990 --> 00:07:45,780
creates value when it is put into

00:07:43,199 --> 00:07:48,840
production when it is running when

00:07:45,780 --> 00:07:51,389
customers can order cars when I can do

00:07:48,840 --> 00:07:54,300
whatever I want to do online that's

00:07:51,389 --> 00:07:58,020
where software starts to sell back its

00:07:54,300 --> 00:08:00,240
initial investment if you look at the

00:07:58,020 --> 00:08:02,639
classical monolithic system that we've

00:08:00,240 --> 00:08:05,400
been building for 16 plus years by now

00:08:02,639 --> 00:08:08,849
and if you look at all those people

00:08:05,400 --> 00:08:12,449
behind it it definitely takes six to

00:08:08,849 --> 00:08:17,520
nine months for some companies to bring

00:08:12,449 --> 00:08:20,639
changes into production and this is not

00:08:17,520 --> 00:08:22,620
like that's not acceptable but it's as a

00:08:20,639 --> 00:08:25,409
matter of fact the only way they can do

00:08:22,620 --> 00:08:27,419
it and they are pretty proud about their

00:08:25,409 --> 00:08:29,340
perfect processes and everything is

00:08:27,419 --> 00:08:32,610
quality in short and nothing happens and

00:08:29,340 --> 00:08:36,510
3d bays look over every database schema

00:08:32,610 --> 00:08:38,820
change so everything works but it would

00:08:36,510 --> 00:08:41,159
be a lot more attractive to be able to

00:08:38,820 --> 00:08:45,029
stage something into production on a

00:08:41,159 --> 00:08:47,670
daily basis a lot more even for those

00:08:45,029 --> 00:08:49,140
companies it's even more interesting to

00:08:47,670 --> 00:08:53,640
have something productive in 12 weeks

00:08:49,140 --> 00:08:56,020
like everything that makes it faster

00:08:53,640 --> 00:08:58,450
business value is not the only reason I

00:08:56,020 --> 00:09:01,750
mean the requirements actually change a

00:08:58,450 --> 00:09:04,210
lot and I can only speak for Germany or

00:09:01,750 --> 00:09:05,800
the you but if something happens like in

00:09:04,210 --> 00:09:07,950
the insurance market and we get new

00:09:05,800 --> 00:09:10,930
regulations from the European Union

00:09:07,950 --> 00:09:13,330
stuff has to be changed in less than

00:09:10,930 --> 00:09:15,220
nine month this is something this is

00:09:13,330 --> 00:09:18,820
going to be in effect in two months for

00:09:15,220 --> 00:09:20,410
example and just imagine a mainframe in

00:09:18,820 --> 00:09:22,960
the basement that's just no longer

00:09:20,410 --> 00:09:23,980
working beside the fact that nobody

00:09:22,960 --> 00:09:27,330
wants to have a mainframe in the

00:09:23,980 --> 00:09:31,060
basement but that's another thing even

00:09:27,330 --> 00:09:33,280
12 weeks would be perfect and if we can

00:09:31,060 --> 00:09:38,590
size down the deployments and the

00:09:33,280 --> 00:09:41,710
production setting units the services we

00:09:38,590 --> 00:09:44,560
would be highly flexible we would be

00:09:41,710 --> 00:09:47,620
very efficient which is obviously one

00:09:44,560 --> 00:09:49,390
thing that Germans can do best am I

00:09:47,620 --> 00:09:51,520
allowed to tell a joke about Germans I

00:09:49,390 --> 00:09:56,380
am a German I do right how many Germans

00:09:51,520 --> 00:10:02,380
does it take to change a light bulb I'm

00:09:56,380 --> 00:10:04,360
listening at three it's actually one we

00:10:02,380 --> 00:10:10,300
are insanely efficient and don't have

00:10:04,360 --> 00:10:12,640
any humor at all so the point I'm trying

00:10:10,300 --> 00:10:16,030
to make is um whenever somebody is

00:10:12,640 --> 00:10:17,380
talking about microservices the

00:10:16,030 --> 00:10:19,600
assumption is that they are talking

00:10:17,380 --> 00:10:22,120
about one rest endpoint that they are

00:10:19,600 --> 00:10:23,830
talking about breaking apart a teensy

00:10:22,120 --> 00:10:26,830
little bit out of something insanely

00:10:23,830 --> 00:10:28,750
baked and this is honestly this is the

00:10:26,830 --> 00:10:31,030
easiest thing you could do with every

00:10:28,750 --> 00:10:34,180
technology on the planet even JavaScript

00:10:31,030 --> 00:10:36,340
nodejs absolutely perfect but if you

00:10:34,180 --> 00:10:40,240
start to build a system out of those

00:10:36,340 --> 00:10:43,050
individual composable units it is going

00:10:40,240 --> 00:10:49,650
to be a hell lot more complicated and

00:10:43,050 --> 00:10:53,020
then this is probably the first thing to

00:10:49,650 --> 00:10:54,880
really think about when you start to

00:10:53,020 --> 00:10:59,560
work with the micro service architecture

00:10:54,880 --> 00:11:01,610
approach don't make easy assumptions at

00:10:59,560 --> 00:11:05,490
that point

00:11:01,610 --> 00:11:08,220
rest is a very easy protocol and Jason

00:11:05,490 --> 00:11:11,040
is all over it as a as a data format

00:11:08,220 --> 00:11:13,320
even in the database if you look at

00:11:11,040 --> 00:11:16,260
solution lo secret solutions today like

00:11:13,320 --> 00:11:18,840
document Center databases but it's just

00:11:16,260 --> 00:11:22,470
not not really effective and the way

00:11:18,840 --> 00:11:25,470
classical architects tend to refactor

00:11:22,470 --> 00:11:27,870
modernize their monolithic applications

00:11:25,470 --> 00:11:30,420
they are just cutting them apart putting

00:11:27,870 --> 00:11:33,510
rest endpoints all over the place they

00:11:30,420 --> 00:11:36,260
are looking happy but if you start to

00:11:33,510 --> 00:11:39,750
change the chain those rest endpoints

00:11:36,260 --> 00:11:41,760
you get insanely long response times

00:11:39,750 --> 00:11:44,460
which is like an obvious reason that's

00:11:41,760 --> 00:11:48,720
network halls in between right and I've

00:11:44,460 --> 00:11:53,970
seen a lot of patterns evangelizing all

00:11:48,720 --> 00:11:56,790
kinds of Microsoft's chaining things and

00:11:53,970 --> 00:12:00,870
chaining patterns when we're talking

00:11:56,790 --> 00:12:03,090
about rest over HTTP which is like the

00:12:00,870 --> 00:12:05,160
basic assumption that everybody does

00:12:03,090 --> 00:12:08,910
even if rest is just an architectural

00:12:05,160 --> 00:12:16,940
style this is impractical it's not going

00:12:08,910 --> 00:12:20,700
to work but how should we actually build

00:12:16,940 --> 00:12:23,280
microservice based systems I keep

00:12:20,700 --> 00:12:26,640
telling you what not to do and what is

00:12:23,280 --> 00:12:31,670
definitely going to fail but how do we

00:12:26,640 --> 00:12:31,670
really want to build our applications I

00:12:32,120 --> 00:12:37,800
like this Gartner quote I mean I pretty

00:12:35,970 --> 00:12:41,820
much spent all of my professional career

00:12:37,800 --> 00:12:45,270
in Java EE in a traditional application

00:12:41,820 --> 00:12:48,120
architecture platform something that I

00:12:45,270 --> 00:12:49,950
loved back in the days because it was so

00:12:48,120 --> 00:12:52,050
easy for me I didn't even have a think

00:12:49,950 --> 00:12:56,160
about transactions I didn't have to

00:12:52,050 --> 00:12:58,380
think about threats threading whatever

00:12:56,160 --> 00:13:00,510
if I just had a reasonable amount of

00:12:58,380 --> 00:13:02,880
workload on that machine everything was

00:13:00,510 --> 00:13:06,480
fine and Gardner says whatever we've

00:13:02,880 --> 00:13:08,750
been doing for 16 years and more is dead

00:13:06,480 --> 00:13:08,750
now

00:13:09,950 --> 00:13:14,090
and you know that I've been an architect

00:13:12,380 --> 00:13:16,340
right so one of the guys painting

00:13:14,090 --> 00:13:18,170
powerpoints and whatnot I have to admit

00:13:16,340 --> 00:13:20,930
I've always tried coding and I've always

00:13:18,170 --> 00:13:23,240
been part of my teens so there's been at

00:13:20,930 --> 00:13:25,610
least one feature no matter big the team

00:13:23,240 --> 00:13:27,650
was that I've been responsible for and

00:13:25,610 --> 00:13:29,960
that I had to implement just because i

00:13:27,650 --> 00:13:31,850
wanted to i just wanted to understand

00:13:29,960 --> 00:13:33,530
what's happening here I didn't want

00:13:31,850 --> 00:13:37,120
really want to be a PowerPoint architect

00:13:33,530 --> 00:13:41,090
and the one thing I learned during those

00:13:37,120 --> 00:13:43,880
modernization projects is that the basic

00:13:41,090 --> 00:13:47,690
architectural principles that we all

00:13:43,880 --> 00:13:51,710
probably know are still very valid and

00:13:47,690 --> 00:13:55,010
if you look into microservices I have to

00:13:51,710 --> 00:14:00,830
admit they matter even more today than

00:13:55,010 --> 00:14:02,960
yesterday it is insanely important to

00:14:00,830 --> 00:14:05,210
think about each of those and I'm pretty

00:14:02,960 --> 00:14:08,360
sure you have I've seen them like loose

00:14:05,210 --> 00:14:10,550
coupling separation of concerns that's

00:14:08,360 --> 00:14:14,510
been the base of what we doing and

00:14:10,550 --> 00:14:17,510
software development since 1992 i don't

00:14:14,510 --> 00:14:23,630
know like ever at least as long as i can

00:14:17,510 --> 00:14:27,950
think and you really have to realize

00:14:23,630 --> 00:14:31,370
that there's nothing rocket science

00:14:27,950 --> 00:14:35,870
nothing magic about microservices it is

00:14:31,370 --> 00:14:39,020
a solid system architecture that you

00:14:35,870 --> 00:14:41,840
have to implement and you can easily use

00:14:39,020 --> 00:14:44,930
and reuse the lessons we learned from

00:14:41,840 --> 00:14:47,450
SOA based installations all this

00:14:44,930 --> 00:14:49,880
knowledge isn't isn't wasted at the end

00:14:47,450 --> 00:14:52,550
of the day micro services are just

00:14:49,880 --> 00:14:58,370
smaller they are just a little bit

00:14:52,550 --> 00:15:02,020
different but how do we get there like

00:14:58,370 --> 00:15:05,780
how do we cut the monolithic application

00:15:02,020 --> 00:15:07,940
the first experience are telling us that

00:15:05,780 --> 00:15:11,120
the main driven design is a very good

00:15:07,940 --> 00:15:14,210
fit we need to identify individual

00:15:11,120 --> 00:15:16,280
services in their contexts and this is

00:15:14,210 --> 00:15:19,450
exactly what domain driven design helps

00:15:16,280 --> 00:15:22,130
us with if we're looking at traditional

00:15:19,450 --> 00:15:23,830
architectures which are layered into

00:15:22,130 --> 00:15:26,410
front end

00:15:23,830 --> 00:15:30,070
business and persistence this is not

00:15:26,410 --> 00:15:32,080
necessarily something that helps

00:15:30,070 --> 00:15:34,960
transitioning into a domain driven

00:15:32,080 --> 00:15:36,610
design approach in general mostly

00:15:34,960 --> 00:15:40,510
because the data models underneath are

00:15:36,610 --> 00:15:42,430
totally messed up over the years average

00:15:40,510 --> 00:15:47,440
run time for an enterprise system in

00:15:42,430 --> 00:15:50,140
Java this easy 10 years I'm putting that

00:15:47,440 --> 00:15:54,340
into a new architectural approach a new

00:15:50,140 --> 00:15:59,890
design approach literally is no longer a

00:15:54,340 --> 00:16:01,720
refactoring but a rebuilding but there

00:15:59,890 --> 00:16:05,710
are other things that just doesn't work

00:16:01,720 --> 00:16:07,840
anymore if you think about the amount of

00:16:05,710 --> 00:16:11,020
data that's processed from those

00:16:07,840 --> 00:16:14,740
applications today and you think about

00:16:11,020 --> 00:16:19,390
jdbc and you think about classical

00:16:14,740 --> 00:16:22,960
queries over blocking api's I mean who

00:16:19,390 --> 00:16:27,400
had a debug like a JDBC issue in encode

00:16:22,960 --> 00:16:29,830
ever probably right and it's always been

00:16:27,400 --> 00:16:32,640
performance-related something didn't

00:16:29,830 --> 00:16:36,490
work and this is when the dbas came in

00:16:32,640 --> 00:16:40,180
they optimize the database for the

00:16:36,490 --> 00:16:41,800
performance issue related case and we

00:16:40,180 --> 00:16:44,680
all know that you can only optimize a

00:16:41,800 --> 00:16:48,070
database for one thing either for reads

00:16:44,680 --> 00:16:51,370
or for rights you can't actually have

00:16:48,070 --> 00:16:55,090
both easily so whatever happened it

00:16:51,370 --> 00:16:57,730
influenced the other side and this is

00:16:55,090 --> 00:17:00,160
another thing that microservices that

00:16:57,730 --> 00:17:02,260
are being called frequently and chained

00:17:00,160 --> 00:17:05,290
and accessing all kinds of domain

00:17:02,260 --> 00:17:07,390
objects that are persisted do

00:17:05,290 --> 00:17:10,300
differently they need to have read and

00:17:07,390 --> 00:17:14,530
write side mostly and they really need

00:17:10,300 --> 00:17:16,750
to be comparable fast I don't want to

00:17:14,530 --> 00:17:18,940
have like long run times we're not

00:17:16,750 --> 00:17:21,190
talking about accessing a back-end

00:17:18,940 --> 00:17:23,080
system a mainframe and having

00:17:21,190 --> 00:17:25,270
transactions that run for more than two

00:17:23,080 --> 00:17:27,310
minutes what's the longest time you

00:17:25,270 --> 00:17:30,840
stare at your phone when you look at

00:17:27,310 --> 00:17:30,840
facebook and try to refresh

00:17:32,280 --> 00:17:40,010
five seconds I think the average is

00:17:37,200 --> 00:17:42,720
according to Nielsen group below three

00:17:40,010 --> 00:17:45,000
if we have to wait for something on our

00:17:42,720 --> 00:17:49,490
phones to happen longer than three

00:17:45,000 --> 00:17:53,300
seconds we're just not using it and

00:17:49,490 --> 00:17:55,950
imagine a service that takes that long

00:17:53,300 --> 00:17:58,470
just because he has to persist really

00:17:55,950 --> 00:18:01,290
complex data graph down to the database

00:17:58,470 --> 00:18:03,360
that's not working so we have actually

00:18:01,290 --> 00:18:06,030
solutions for that problem one of them

00:18:03,360 --> 00:18:09,240
is c QR s at the command query

00:18:06,030 --> 00:18:12,450
separation we have a read side we have a

00:18:09,240 --> 00:18:14,940
right side it's a very unusual pattern

00:18:12,450 --> 00:18:18,480
in the classical enterprise Java EE /

00:18:14,940 --> 00:18:21,900
Java world but it works pretty well for

00:18:18,480 --> 00:18:24,630
micro services and hardly anybody does

00:18:21,900 --> 00:18:28,860
it right now another concept our

00:18:24,630 --> 00:18:32,130
transactions I love application servers

00:18:28,860 --> 00:18:35,400
I could send a message I could persist

00:18:32,130 --> 00:18:38,250
the data an entity into my database and

00:18:35,400 --> 00:18:41,760
I could just have a transaction boundary

00:18:38,250 --> 00:18:43,830
around it and I'd nothing to do with it

00:18:41,760 --> 00:18:48,510
most of the time it just magically

00:18:43,830 --> 00:18:51,060
worked hopefully and it did but if we

00:18:48,510 --> 00:18:53,100
have services like does rest as an

00:18:51,060 --> 00:18:57,020
architectural style and as a HTTP

00:18:53,100 --> 00:19:01,230
implementation support transactions know

00:18:57,020 --> 00:19:04,920
how should that the a I mean enterprise

00:19:01,230 --> 00:19:08,280
if i buy a BMW online i'm pretty sure

00:19:04,920 --> 00:19:11,700
BMW is insisting on getting their money

00:19:08,280 --> 00:19:14,580
I mean I they can't just drop money

00:19:11,700 --> 00:19:17,790
because the payment service is not

00:19:14,580 --> 00:19:22,140
available eventual consistency has

00:19:17,790 --> 00:19:24,210
various scenarios and even you business

00:19:22,140 --> 00:19:27,450
requirements that we need to take into

00:19:24,210 --> 00:19:29,850
account this is something that classical

00:19:27,450 --> 00:19:32,940
application designs just did differently

00:19:29,850 --> 00:19:37,340
in the days so we don't have

00:19:32,940 --> 00:19:41,570
transactions usually in micro services

00:19:37,340 --> 00:19:41,570
we need to find a way to deal with that

00:19:43,389 --> 00:19:50,840
one of my favorite examples to explain

00:19:47,509 --> 00:19:53,389
that is actually Emma's amazon prime so

00:19:50,840 --> 00:19:54,820
Germans are a little bit laid back when

00:19:53,389 --> 00:19:57,649
it comes to technology adoption

00:19:54,820 --> 00:20:00,469
Americans are way ahead when it comes to

00:19:57,649 --> 00:20:04,279
that but I got actually Prime very early

00:20:00,469 --> 00:20:06,109
and they have one of the first micro

00:20:04,279 --> 00:20:09,259
service-based architectures underneath

00:20:06,109 --> 00:20:12,529
like Netflix also so seems to be a very

00:20:09,259 --> 00:20:14,619
good idea to use that I think that's

00:20:12,529 --> 00:20:17,869
where the hype started initially and

00:20:14,619 --> 00:20:21,889
when you buy it the movie on Amazon or

00:20:17,869 --> 00:20:25,729
rent one and the payment service is not

00:20:21,889 --> 00:20:30,349
available what happens do you get your

00:20:25,729 --> 00:20:33,229
movie or do you get an error right

00:20:30,349 --> 00:20:35,869
amazon decided in the first couple of

00:20:33,229 --> 00:20:38,089
years at least where they started to

00:20:35,869 --> 00:20:41,059
experiment with that from a business

00:20:38,089 --> 00:20:44,749
case it's even more important to us to

00:20:41,059 --> 00:20:47,989
have a very satisfied customer than to

00:20:44,749 --> 00:20:51,019
gain money so they are giving away a

00:20:47,989 --> 00:20:54,259
movie for free just to make you happy as

00:20:51,019 --> 00:20:55,759
a customer again the BMW example that's

00:20:54,259 --> 00:20:58,759
probably not going to work everywhere

00:20:55,759 --> 00:21:00,649
and especially in enterprise settings it

00:20:58,759 --> 00:21:05,119
might be very challenging to implement

00:21:00,649 --> 00:21:06,950
those new business ideas and models and

00:21:05,119 --> 00:21:08,419
I acknowledge that but still it's

00:21:06,950 --> 00:21:11,779
something that we could definitely work

00:21:08,419 --> 00:21:13,580
with if we can't find those new business

00:21:11,779 --> 00:21:15,080
requirements we definitely need to work

00:21:13,580 --> 00:21:17,989
with something like compensating

00:21:15,080 --> 00:21:21,769
transactions or events that roll

00:21:17,989 --> 00:21:24,919
everything back that we did so far also

00:21:21,769 --> 00:21:30,019
very interesting the most important part

00:21:24,919 --> 00:21:33,139
I think is that we need to build

00:21:30,019 --> 00:21:35,839
flexible systems from now on so the

00:21:33,139 --> 00:21:39,289
biggest concern is no longer efficiency

00:21:35,839 --> 00:21:43,450
and robustness it's more embracing

00:21:39,289 --> 00:21:45,619
failure embracing resiliency and

00:21:43,450 --> 00:21:47,869
starting to build a system where it can

00:21:45,619 --> 00:21:50,269
really pull apart an individual service

00:21:47,869 --> 00:21:52,989
without breaking down the complete rest

00:21:50,269 --> 00:21:52,989
of the system

00:21:53,380 --> 00:21:57,580
does that start a sound familiar

00:21:59,260 --> 00:22:08,000
responsive resilient elastic message

00:22:03,230 --> 00:22:11,929
driven where does that come from mm-hmm

00:22:08,000 --> 00:22:15,679
the react of manifest arrived and this

00:22:11,929 --> 00:22:18,679
is the this is a perfect fit for

00:22:15,679 --> 00:22:21,140
microservices the ideas that have been

00:22:18,679 --> 00:22:25,900
implemented and around the wrecked of

00:22:21,140 --> 00:22:29,530
manifesto are very very solid guidelines

00:22:25,900 --> 00:22:32,059
when you start implement those systems

00:22:29,530 --> 00:22:34,669
great we're done we're done here let's

00:22:32,059 --> 00:22:36,950
meet offstage I mean Scala carplay

00:22:34,669 --> 00:22:38,750
they're all great and they're all just a

00:22:36,950 --> 00:22:42,860
perfect fit right so we don't really

00:22:38,750 --> 00:22:44,059
need to care but I have to admit I told

00:22:42,860 --> 00:22:45,950
you I'm a Java developer so I never

00:22:44,059 --> 00:22:47,809
really looked into Scala and I never

00:22:45,950 --> 00:22:50,630
really looked into occur even if there's

00:22:47,809 --> 00:22:53,110
always a Java API it's not we could do

00:22:50,630 --> 00:22:56,690
better in documenting them I agree

00:22:53,110 --> 00:22:58,700
taking complaints so you had a build a

00:22:56,690 --> 00:23:01,280
lot around and we have a lot of

00:22:58,700 --> 00:23:03,500
successful customers who did exactly

00:23:01,280 --> 00:23:06,169
that build a micro services based

00:23:03,500 --> 00:23:10,820
architecture a successful system with

00:23:06,169 --> 00:23:12,289
the existing tools out there if you

00:23:10,820 --> 00:23:15,620
don't want to build something yourself

00:23:12,289 --> 00:23:18,440
and if you are not really familiar with

00:23:15,620 --> 00:23:20,240
the tools you're using and with the

00:23:18,440 --> 00:23:25,909
tools that would be an obvious good fit

00:23:20,240 --> 00:23:27,919
in that whole setting what do you do you

00:23:25,909 --> 00:23:29,780
come up with a new idea and you try to

00:23:27,919 --> 00:23:34,760
make everything a little bit easier for

00:23:29,780 --> 00:23:36,380
everybody and this is where the exactly

00:23:34,760 --> 00:23:39,169
the direction where logon is heading

00:23:36,380 --> 00:23:41,299
into an miqo'te a co-worker of mine it

00:23:39,169 --> 00:23:44,030
was giving a very deep dive technical

00:23:41,299 --> 00:23:46,520
talk just before my session in another

00:23:44,030 --> 00:23:47,960
room but knowing that every session is

00:23:46,520 --> 00:23:50,840
going to be recorded so I highly

00:23:47,960 --> 00:23:55,760
recommend what re watching his his

00:23:50,840 --> 00:23:59,480
session laga miss actually build around

00:23:55,760 --> 00:24:02,840
developer experience I'm not saying that

00:23:59,480 --> 00:24:05,030
it's trying to be as convenient as

00:24:02,840 --> 00:24:06,530
application servers went over the years

00:24:05,030 --> 00:24:08,870
but instead

00:24:06,530 --> 00:24:12,080
of just having 20 million terminals open

00:24:08,870 --> 00:24:14,720
and starting individual services and not

00:24:12,080 --> 00:24:16,040
having hot reloading features like stuff

00:24:14,720 --> 00:24:20,180
that we really got used to over the

00:24:16,040 --> 00:24:23,180
years lagom comes with a developer

00:24:20,180 --> 00:24:26,000
mindset if you have a micro service

00:24:23,180 --> 00:24:29,030
based system 20 services and you run

00:24:26,000 --> 00:24:30,980
your system with log on log on fires up

00:24:29,030 --> 00:24:32,950
everything you need including the

00:24:30,980 --> 00:24:37,490
databases and the individual services

00:24:32,950 --> 00:24:40,610
with a gateway it's perfect and easy to

00:24:37,490 --> 00:24:43,940
manage and you don't actually have to

00:24:40,610 --> 00:24:46,640
have a bunch of scripts around which is

00:24:43,940 --> 00:24:51,350
something that we probably all did to

00:24:46,640 --> 00:24:54,530
start services in that case and it also

00:24:51,350 --> 00:24:57,680
takes you through the production which

00:24:54,530 --> 00:25:00,250
is kind of the most important part if

00:24:57,680 --> 00:25:03,080
you have just a bunch of fat jars that

00:25:00,250 --> 00:25:06,170
you would need to package up in a docker

00:25:03,080 --> 00:25:08,120
container and deliver them and make sure

00:25:06,170 --> 00:25:10,970
everything is wired correctly together

00:25:08,120 --> 00:25:12,710
there's a lot a lot of work that log

00:25:10,970 --> 00:25:14,900
them actually and combination with

00:25:12,710 --> 00:25:18,740
conductor takes off your plate in those

00:25:14,900 --> 00:25:21,680
projects and if we just peel away the

00:25:18,740 --> 00:25:25,880
marketing label this is the list of

00:25:21,680 --> 00:25:29,180
technologies that are in log on this is

00:25:25,880 --> 00:25:32,540
pretty interesting because it says Scala

00:25:29,180 --> 00:25:35,660
here logon is built with Scala but it

00:25:32,540 --> 00:25:39,350
doesn't have a scala API yet so for the

00:25:35,660 --> 00:25:41,600
moment it's Java API first and that

00:25:39,350 --> 00:25:43,460
shouldn't hinder you looking at it we

00:25:41,600 --> 00:25:46,040
have a couple of examples out there how

00:25:43,460 --> 00:25:48,440
to use log armed services and api's from

00:25:46,040 --> 00:25:53,690
Scala so you can do that it's just a

00:25:48,440 --> 00:25:56,750
little bit of work around what does it

00:25:53,690 --> 00:26:00,020
what what is in Lago what what is really

00:25:56,750 --> 00:26:02,390
the great thing the great thing is that

00:26:00,020 --> 00:26:05,390
log on doesn't try to solve all your

00:26:02,390 --> 00:26:08,750
problems as a matter of fact that's

00:26:05,390 --> 00:26:11,990
highly opinionated and it really wants

00:26:08,750 --> 00:26:16,160
to give a very top level guidance on

00:26:11,990 --> 00:26:18,280
building microservices the right way and

00:26:16,160 --> 00:26:20,250
nobody really likes the word

00:26:18,280 --> 00:26:23,700
microservices by the way because

00:26:20,250 --> 00:26:28,560
it implies that the service needs to

00:26:23,700 --> 00:26:30,570
have a specific small micro size but

00:26:28,560 --> 00:26:33,480
size in terms of services is probably

00:26:30,570 --> 00:26:34,740
the worst thing to look for the first

00:26:33,480 --> 00:26:37,710
couple of sessions I gave about

00:26:34,740 --> 00:26:40,980
microservices the number one question I

00:26:37,710 --> 00:26:45,300
got asked was how big do you think has a

00:26:40,980 --> 00:26:48,540
micro service to be 20 lines of code and

00:26:45,300 --> 00:26:51,870
I was like seriously yeah really asking

00:26:48,540 --> 00:26:53,970
that question I like to call them logon

00:26:51,870 --> 00:26:56,340
services from here on and logon is

00:26:53,970 --> 00:26:58,740
actually a Swedish word and it stands

00:26:56,340 --> 00:27:01,200
for just right or just the right amount

00:26:58,740 --> 00:27:04,800
and that's a pretty perfect translation

00:27:01,200 --> 00:27:07,230
because we should be looking for right

00:27:04,800 --> 00:27:10,680
sized services and no longer for

00:27:07,230 --> 00:27:12,450
services that try to imply any size

00:27:10,680 --> 00:27:17,310
regulations like lines of code or

00:27:12,450 --> 00:27:21,420
whatnot so we have basically a service

00:27:17,310 --> 00:27:25,260
API which helps you with IO and

00:27:21,420 --> 00:27:27,120
communications streaming between

00:27:25,260 --> 00:27:30,750
services is one of the the most

00:27:27,120 --> 00:27:33,960
important parts it's all based on our

00:27:30,750 --> 00:27:38,250
cross streams stuff that we all know and

00:27:33,960 --> 00:27:41,880
Java developers didn't so far it makes

00:27:38,250 --> 00:27:45,480
it pretty easy to use and it gives you a

00:27:41,880 --> 00:27:47,370
build and resiliency just by using those

00:27:45,480 --> 00:27:49,710
tools and giving you the guidelines like

00:27:47,370 --> 00:27:53,430
it's it's your manual for micro services

00:27:49,710 --> 00:27:55,460
this is what logon tries to be and the

00:27:53,430 --> 00:27:57,530
service is actually abounded context

00:27:55,460 --> 00:28:01,200
according to the domain driven design

00:27:57,530 --> 00:28:04,800
architectures you have clients we have

00:28:01,200 --> 00:28:07,410
endpoints if you want to have a code

00:28:04,800 --> 00:28:09,420
deep dive again Mirko did that perfect

00:28:07,410 --> 00:28:12,240
and the other thing that logon provides

00:28:09,420 --> 00:28:15,240
is actually a persistence API and this

00:28:12,240 --> 00:28:18,360
is not sleek this is not something that

00:28:15,240 --> 00:28:21,270
we already had so far this is a very

00:28:18,360 --> 00:28:25,290
solid and nice implementation of the sea

00:28:21,270 --> 00:28:27,900
QRS event sourcing model and logon comes

00:28:25,290 --> 00:28:30,840
with a very easy usable data base

00:28:27,900 --> 00:28:32,870
underneath so cassandra is built in you

00:28:30,840 --> 00:28:35,510
can sweat without that's no not in a

00:28:32,870 --> 00:28:39,010
but it works pretty well and you can

00:28:35,510 --> 00:28:42,290
just persist your domain entities and

00:28:39,010 --> 00:28:45,950
send persistence events so you can

00:28:42,290 --> 00:28:49,790
replay stayed it makes it comparable

00:28:45,950 --> 00:28:52,100
easy the development environment I have

00:28:49,790 --> 00:28:58,100
no idea what you expected but as a

00:28:52,100 --> 00:29:00,830
matter of fact it's spt so spt and log

00:28:58,100 --> 00:29:03,200
them and a couple of plugins that's what

00:29:00,830 --> 00:29:05,510
makes all the magic happen what you see

00:29:03,200 --> 00:29:08,840
here is basically that run all as a

00:29:05,510 --> 00:29:11,600
command on your logon based project

00:29:08,840 --> 00:29:14,210
starts up your Cassandra instance your

00:29:11,600 --> 00:29:15,740
service located your gateway and the

00:29:14,210 --> 00:29:18,679
individual services this is the hello

00:29:15,740 --> 00:29:22,570
world example that kind of comes with

00:29:18,679 --> 00:29:22,570
log on I have a couple of links for you

00:29:23,590 --> 00:29:29,690
one of the next steps for log on this is

00:29:27,890 --> 00:29:33,650
in no particular order this is no

00:29:29,690 --> 00:29:35,150
promise I still refuse to talk about any

00:29:33,650 --> 00:29:37,460
of them but this is what we're thinking

00:29:35,150 --> 00:29:39,170
right now if you really want to be

00:29:37,460 --> 00:29:42,350
involved with the project and want to

00:29:39,170 --> 00:29:44,870
learn a lot more again I have a bunch of

00:29:42,350 --> 00:29:47,330
links here you can contribute on github

00:29:44,870 --> 00:29:50,480
the complete thing is apache license and

00:29:47,330 --> 00:29:53,300
open and I if you again highly recommend

00:29:50,480 --> 00:29:56,240
to contribute give feedback talk to our

00:29:53,300 --> 00:29:57,800
engineers on the public channels we have

00:29:56,240 --> 00:30:01,160
actually have a public mailing list and

00:29:57,800 --> 00:30:05,150
i'm pretty sure that everybody can

00:30:01,160 --> 00:30:07,720
discuss about that further if you need

00:30:05,150 --> 00:30:11,090
more background on the principles behind

00:30:07,720 --> 00:30:16,280
logon there's a pretty amazing book

00:30:11,090 --> 00:30:19,190
written by jonas plein air he yeah this

00:30:16,280 --> 00:30:21,830
is the architecture behind log on if you

00:30:19,190 --> 00:30:24,679
want to understand why we did it this is

00:30:21,830 --> 00:30:27,620
our those are the reasons and it's a

00:30:24,679 --> 00:30:30,380
free ebook you can download it for free

00:30:27,620 --> 00:30:33,200
it has like 60 pages maybe on your

00:30:30,380 --> 00:30:35,300
flight back home or whenever you have a

00:30:33,200 --> 00:30:39,140
couple of minutes this is exactly your

00:30:35,300 --> 00:30:42,950
read and there's a follow-up book that I

00:30:39,140 --> 00:30:45,110
just published and finished which is the

00:30:42,950 --> 00:30:48,799
implementation guide

00:30:45,110 --> 00:30:51,200
I'm so kind of as an apologize for not

00:30:48,799 --> 00:30:53,360
showing code or doing a demo today I

00:30:51,200 --> 00:30:56,179
basically wrote a book and made it free

00:30:53,360 --> 00:31:00,679
for you I hope that works the first time

00:30:56,179 --> 00:31:02,450
I ever did that you get the slides

00:31:00,679 --> 00:31:05,870
afterwards anyway right so you have

00:31:02,450 --> 00:31:09,559
access to all the links if you want to

00:31:05,870 --> 00:31:14,059
start over project site is unlike bent

00:31:09,559 --> 00:31:15,590
accomplished log on you can work more or

00:31:14,059 --> 00:31:17,540
less directly with the team on the

00:31:15,590 --> 00:31:20,870
github repository everything's open and

00:31:17,540 --> 00:31:23,600
transparent and the documentation is

00:31:20,870 --> 00:31:26,570
just insanely great that's all I can

00:31:23,600 --> 00:31:29,210
tell you so you're totally free and

00:31:26,570 --> 00:31:34,460
happy and welcome to check it out and

00:31:29,210 --> 00:31:35,780
learn it's very very easy and I think we

00:31:34,460 --> 00:31:43,030
have a couple of minutes left for

00:31:35,780 --> 00:31:43,030
questions and answers at that point yeah

00:31:46,140 --> 00:31:53,040
best practices for handling versioning

00:31:49,140 --> 00:31:55,600
there a couple of approaches log gum

00:31:53,040 --> 00:31:58,120
doesn't really have one right now at

00:31:55,600 --> 00:32:00,460
least not on the API level you can

00:31:58,120 --> 00:32:03,220
basically go API level you can go

00:32:00,460 --> 00:32:06,970
service versioning level you can go

00:32:03,220 --> 00:32:08,559
source code versioning level I think the

00:32:06,970 --> 00:32:10,860
most practical thing is to have

00:32:08,559 --> 00:32:13,660
something in the in the descriptor

00:32:10,860 --> 00:32:22,750
interface the scripture or have an API

00:32:13,660 --> 00:32:26,340
management solution in between thanks

00:32:22,750 --> 00:32:26,340

YouTube URL: https://www.youtube.com/watch?v=PYXqVbVCIBA


