Title: Roll Your Own Shapeless - by Daniel Spiewak
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Shapeless is a remarkable framework.  It gives us the power to represent astonishingly rich constraints and generalize code over very broad structural classes, but it isn't magic!  The tools with which shapeless is crafted are present in your version of scalac just as much as they are in Miles Sabin's, and learning to take advantage of them unlocks a rich palette of expression otherwise untapped in the language.  In this talk, we will recreate some of the major elements of shapeless, learning how to harness a fully armed and operational type system, all while avoiding any hint of macro programming!  Particular focus will be given to understanding the general patterns and ideas involved, and not just the end result.
Captions: 
	00:00:00,870 --> 00:00:05,939
a fun little game here let's simply

00:00:04,140 --> 00:00:09,259
figure out which of these pictures was

00:00:05,939 --> 00:00:09,259
taken most recently

00:00:09,990 --> 00:00:15,370
it's kind of hard right and of course of

00:00:14,020 --> 00:00:18,369
course the answer to this is mild

00:00:15,370 --> 00:00:20,500
statement and miles is is really best

00:00:18,369 --> 00:00:24,460
known for his work on the Scala Eclipse

00:00:20,500 --> 00:00:28,060
IEP but in his spare time between this

00:00:24,460 --> 00:00:30,520
he has worked on shameless and the

00:00:28,060 --> 00:00:32,199
shapeless project is is really cool and

00:00:30,520 --> 00:00:33,520
a lot of people when they think of

00:00:32,199 --> 00:00:35,290
shapeless they probably think of things

00:00:33,520 --> 00:00:37,030
like AngelList and home products which

00:00:35,290 --> 00:00:38,500
are sort of like you know these core

00:00:37,030 --> 00:00:39,730
sort of flagship parts of the library

00:00:38,500 --> 00:00:41,379
but these are really just a

00:00:39,730 --> 00:00:43,059
demonstration right there they're a

00:00:41,379 --> 00:00:44,890
demonstration of some some techniques

00:00:43,059 --> 00:00:46,210
that we can use to do other really cool

00:00:44,890 --> 00:00:49,830
things many of which are already in

00:00:46,210 --> 00:00:52,180
shapeless shapeless is a series of tools

00:00:49,830 --> 00:00:54,040
for library authors it's it's intended

00:00:52,180 --> 00:00:56,830
as a framework that allows library

00:00:54,040 --> 00:00:58,600
authors to create rich type full you

00:00:56,830 --> 00:01:00,370
know generic interfaces that abstract

00:00:58,600 --> 00:01:03,070
over arity and present those interfaces

00:01:00,370 --> 00:01:05,430
to end-users but more importantly

00:01:03,070 --> 00:01:07,780
shapeless is kind of a playground for

00:01:05,430 --> 00:01:10,180
experimenting with techniques and idioms

00:01:07,780 --> 00:01:12,640
for type level programming programming

00:01:10,180 --> 00:01:14,320
the type system and these idioms

00:01:12,640 --> 00:01:16,300
basically give us a way and these

00:01:14,320 --> 00:01:17,680
patterns give us a way of looking at

00:01:16,300 --> 00:01:19,210
code at the type level and actually

00:01:17,680 --> 00:01:21,040
being able to reason about it and write

00:01:19,210 --> 00:01:22,270
more of it and you know not kind of pull

00:01:21,040 --> 00:01:24,760
our hair out because it's it's a

00:01:22,270 --> 00:01:25,690
relatively calm clumsy system most

00:01:24,760 --> 00:01:28,960
importantly though

00:01:25,690 --> 00:01:31,000
shapeless is not magical there's nothing

00:01:28,960 --> 00:01:33,520
there's no special secret sauce that's

00:01:31,000 --> 00:01:35,860
in mild Saban's copy of scala see that

00:01:33,520 --> 00:01:37,930
is absent from my copy of Scala C so we

00:01:35,860 --> 00:01:40,390
can do all of this stuff ourselves and

00:01:37,930 --> 00:01:41,980
in fact in this talk that is exactly

00:01:40,390 --> 00:01:44,680
what we're going to do we are going to

00:01:41,980 --> 00:01:46,420
create our own version of shapeless

00:01:44,680 --> 00:01:47,980
we're going to recreate a lot of these

00:01:46,420 --> 00:01:49,660
primitives that exist in shapeless and

00:01:47,980 --> 00:01:50,890
we're going to do it in this talk for

00:01:49,660 --> 00:01:54,280
fun and profit and your your

00:01:50,890 --> 00:01:57,250
entertainment pleasure so previously

00:01:54,280 --> 00:01:59,110
some years ago I gave a talk entitled

00:01:57,250 --> 00:02:02,380
high wizardry in the land of Scala and

00:01:59,110 --> 00:02:04,060
and in this talk we implemented a very

00:02:02,380 --> 00:02:05,020
very straightforward ageless data

00:02:04,060 --> 00:02:06,550
structure

00:02:05,020 --> 00:02:07,900
there really wasn't much to this I

00:02:06,550 --> 00:02:10,479
didn't put much in it there was

00:02:07,900 --> 00:02:11,590
basically just append both of the value

00:02:10,479 --> 00:02:13,330
level on the type level that's basically

00:02:11,590 --> 00:02:14,950
where we stopped because backings cut

00:02:13,330 --> 00:02:17,560
out 2.7 that's about as much as you

00:02:14,950 --> 00:02:19,780
could do we're not in scala 2.7 anymore

00:02:17,560 --> 00:02:21,310
we can do a lot more and in fact this

00:02:19,780 --> 00:02:23,049
seems like a pretty good starting point

00:02:21,310 --> 00:02:23,500
for doing a lot more in this talk so

00:02:23,049 --> 00:02:25,300
we're going to

00:02:23,500 --> 00:02:28,720
implement a whole bunch of functions on

00:02:25,300 --> 00:02:30,820
H list similar to as they are as they

00:02:28,720 --> 00:02:32,350
exist in shapeless and we'll learn about

00:02:30,820 --> 00:02:34,240
how to do programming at the type level

00:02:32,350 --> 00:02:36,040
while we're doing that so here's the

00:02:34,240 --> 00:02:38,980
here's the H list implementation from

00:02:36,040 --> 00:02:40,810
that talk we we have an H list rate that

00:02:38,980 --> 00:02:42,970
has an append function and append type

00:02:40,810 --> 00:02:44,410
it's a type level function value level

00:02:42,970 --> 00:02:46,209
function and they mirror each other and

00:02:44,410 --> 00:02:47,860
we just have two different cases that

00:02:46,209 --> 00:02:49,570
implement this we have an H cons case

00:02:47,860 --> 00:02:51,550
and an H nil case and they both

00:02:49,570 --> 00:02:52,930
implement append in basically the way

00:02:51,550 --> 00:02:56,320
you would expect um you notice we have

00:02:52,930 --> 00:02:57,400
to do this HTML not thing I'll talk

00:02:56,320 --> 00:02:58,360
about that a little bit more in a second

00:02:57,400 --> 00:02:59,470
but this is just basically getting

00:02:58,360 --> 00:03:02,080
around a bug in the Scala compiler

00:02:59,470 --> 00:03:03,310
whenever you're doing objects you you

00:03:02,080 --> 00:03:04,660
that you have to represent at the type

00:03:03,310 --> 00:03:06,850
level you have to kind of do stuff like

00:03:04,660 --> 00:03:08,470
this but you notice there's something a

00:03:06,850 --> 00:03:10,690
little bit weird going on here in the H

00:03:08,470 --> 00:03:12,610
cons case for pen and that's where we're

00:03:10,690 --> 00:03:14,800
sort of you know getting a tight

00:03:12,610 --> 00:03:17,500
projection on this type T which is a

00:03:14,800 --> 00:03:19,180
parameter that is of you know type H

00:03:17,500 --> 00:03:20,920
list so it's sort of like open recursion

00:03:19,180 --> 00:03:23,230
and the type level it's it's sort of

00:03:20,920 --> 00:03:25,300
this weird thing it's kind of a neat

00:03:23,230 --> 00:03:27,430
trick but this is how a lot of these

00:03:25,300 --> 00:03:31,780
sort of you know type constructor based

00:03:27,430 --> 00:03:33,459
you know type level functions work we're

00:03:31,780 --> 00:03:35,500
going to do to make a chest a little bit

00:03:33,459 --> 00:03:37,150
more palatable to work with is we're

00:03:35,500 --> 00:03:39,190
gonna implement some some sort of

00:03:37,150 --> 00:03:40,780
syntactic stuff on top of this so we're

00:03:39,190 --> 00:03:42,280
gonna have a cons type that makes it

00:03:40,780 --> 00:03:44,320
easier to work with the the H con sting

00:03:42,280 --> 00:03:46,030
we're also gonna have a cons method so

00:03:44,320 --> 00:03:47,769
that when we have an H list we can cons

00:03:46,030 --> 00:03:49,030
things onto it just like with lists and

00:03:47,769 --> 00:03:51,310
you notice what we have to do is we

00:03:49,030 --> 00:03:53,500
can't actually put this method on H list

00:03:51,310 --> 00:03:55,630
itself because we need the specific type

00:03:53,500 --> 00:03:56,769
of the H list we're operating on so what

00:03:55,630 --> 00:03:59,110
we're gonna do is we're gonna use this

00:03:56,769 --> 00:04:01,299
implicit syntax thing and enrich it onto

00:03:59,110 --> 00:04:03,160
H list the only reason we're doing this

00:04:01,299 --> 00:04:04,450
is so that we can have the specific type

00:04:03,160 --> 00:04:06,880
of the H let's we're dealing with L

00:04:04,450 --> 00:04:09,160
extends H list that's the specific type

00:04:06,880 --> 00:04:10,570
so now rather than just H list it's a

00:04:09,160 --> 00:04:12,760
very common pattern when we're doing

00:04:10,570 --> 00:04:14,140
programming at the type level is you

00:04:12,760 --> 00:04:15,730
know we will go through all this effort

00:04:14,140 --> 00:04:17,560
to get a really specific type

00:04:15,730 --> 00:04:19,510
we don't want subtyping to just throw

00:04:17,560 --> 00:04:21,640
that away and say oh actually secretly

00:04:19,510 --> 00:04:23,229
you just have an H list you know we want

00:04:21,640 --> 00:04:24,550
the specific type to be carried along so

00:04:23,229 --> 00:04:26,500
we're gonna do a lot of this sort of

00:04:24,550 --> 00:04:28,780
thing in this talk and by the way the

00:04:26,500 --> 00:04:30,040
type H nail and Val H know thing again

00:04:28,780 --> 00:04:32,050
that's that's getting around a bug in

00:04:30,040 --> 00:04:34,090
Scala see just that we can actually call

00:04:32,050 --> 00:04:36,639
it H nil and have both the type in the

00:04:34,090 --> 00:04:38,949
value but coming back to a pen right

00:04:36,639 --> 00:04:40,210
and is a type level function and it's a

00:04:38,949 --> 00:04:41,889
type level function that's that's

00:04:40,210 --> 00:04:44,409
implemented solely in terms of type

00:04:41,889 --> 00:04:46,389
aliasing and it turns out that this is

00:04:44,409 --> 00:04:48,189
actually a very special sort of type

00:04:46,389 --> 00:04:50,409
level function it is a context

00:04:48,189 --> 00:04:53,139
independent type level function

00:04:50,409 --> 00:04:54,999
it's contact independent and and as a

00:04:53,139 --> 00:04:57,370
consequence of being context independent

00:04:54,999 --> 00:05:00,340
we get some nice properties one of them

00:04:57,370 --> 00:05:02,349
is structural definition so upend is

00:05:00,340 --> 00:05:04,719
basically this is really only one way to

00:05:02,349 --> 00:05:06,310
implement upend over this age list right

00:05:04,719 --> 00:05:07,840
you have the cons case in the nil case

00:05:06,310 --> 00:05:10,210
and everything just sort of falls out in

00:05:07,840 --> 00:05:12,789
this very sort of way that arise

00:05:10,210 --> 00:05:14,469
directly from the data one of the things

00:05:12,789 --> 00:05:17,409
that's nice about this is when we're

00:05:14,469 --> 00:05:18,909
encoding you know sort of more complex

00:05:17,409 --> 00:05:21,009
programs at the type level we get a

00:05:18,909 --> 00:05:23,439
really strong separation of concerns we

00:05:21,009 --> 00:05:25,779
can have we can define a way of sort of

00:05:23,439 --> 00:05:27,430
decomposing a structure using a context

00:05:25,779 --> 00:05:29,169
independent type level function and then

00:05:27,430 --> 00:05:30,699
we can use that mechanism for

00:05:29,169 --> 00:05:32,830
decomposition in other type level

00:05:30,699 --> 00:05:34,629
functions without having to redefine it

00:05:32,830 --> 00:05:36,460
and we can we talk more about this later

00:05:34,629 --> 00:05:37,779
well actually see examples of where this

00:05:36,460 --> 00:05:39,520
is relevant cuz we're just working with

00:05:37,779 --> 00:05:41,050
H list but for more complex data

00:05:39,520 --> 00:05:44,860
structures this is really serious

00:05:41,050 --> 00:05:46,569
concern context independent functions as

00:05:44,860 --> 00:05:48,610
the name implies context independent

00:05:46,569 --> 00:05:50,319
functions produce the same result the

00:05:48,610 --> 00:05:53,319
same type regardless of the scope in

00:05:50,319 --> 00:05:55,629
which you call them so you know users

00:05:53,319 --> 00:05:57,639
can't like import something or have some

00:05:55,629 --> 00:05:59,349
sort of weird definition that changes

00:05:57,639 --> 00:06:01,599
the result of this function and more

00:05:59,349 --> 00:06:03,939
importantly Scala seeing knows that

00:06:01,599 --> 00:06:05,289
users can't import anything or do some

00:06:03,939 --> 00:06:07,089
weird definition which changes the

00:06:05,289 --> 00:06:09,279
result of this type it's always the same

00:06:07,089 --> 00:06:11,349
type regardless of where you use it and

00:06:09,279 --> 00:06:12,639
so this this allows Scala C to do some

00:06:11,349 --> 00:06:14,490
things and the language to do some

00:06:12,639 --> 00:06:17,110
things that we can take advantage of

00:06:14,490 --> 00:06:18,879
this is also because it's just a type

00:06:17,110 --> 00:06:20,439
alias it's literally just a type we can

00:06:18,879 --> 00:06:22,389
use it in any position that you can use

00:06:20,439 --> 00:06:24,250
a type n this is something that you

00:06:22,389 --> 00:06:25,629
can't say about implicit switch we're

00:06:24,250 --> 00:06:26,800
going to be which are basically the

00:06:25,629 --> 00:06:27,990
primary mechanism that we're going to be

00:06:26,800 --> 00:06:30,729
using to program the type system

00:06:27,990 --> 00:06:31,930
implicit sar tied to method definitions

00:06:30,729 --> 00:06:34,210
which which makes them a little bit

00:06:31,930 --> 00:06:37,379
constrained but unfortunately all of

00:06:34,210 --> 00:06:39,279
this is gone and dotty why you can't you

00:06:37,379 --> 00:06:41,229
sort of looked at Martin's keynote

00:06:39,279 --> 00:06:43,659
yesterday but like this tight projection

00:06:41,229 --> 00:06:45,310
thing on the this sort of onion Oh fixed

00:06:43,659 --> 00:06:46,990
type variable that sort of came from

00:06:45,310 --> 00:06:48,399
magic land and open recursion you can't

00:06:46,990 --> 00:06:49,310
do that you can't do that in dotty

00:06:48,399 --> 00:06:50,540
anymore and

00:06:49,310 --> 00:06:52,040
good reason right there there's a good

00:06:50,540 --> 00:06:53,810
reasons that that stuff is gone but for

00:06:52,040 --> 00:06:55,490
now this is kind of an important

00:06:53,810 --> 00:06:57,080
technique to keep in mind

00:06:55,490 --> 00:06:59,570
unfortunately this technique is also

00:06:57,080 --> 00:07:01,910
very very limited you can't really do

00:06:59,570 --> 00:07:03,470
anything other than basic open recursion

00:07:01,910 --> 00:07:05,150
at the type level like this is nothing

00:07:03,470 --> 00:07:06,350
nothing more complicated in that in fact

00:07:05,150 --> 00:07:08,300
it's it's very very straightforward

00:07:06,350 --> 00:07:10,580
induction so anything more complicated

00:07:08,300 --> 00:07:12,380
than H list append probably cannot be

00:07:10,580 --> 00:07:14,930
encoded in this way you can't do

00:07:12,380 --> 00:07:17,540
branching so there's no like you know if

00:07:14,930 --> 00:07:18,980
I see you know some type over here do

00:07:17,540 --> 00:07:20,630
this thing if I see this other type do

00:07:18,980 --> 00:07:22,040
this other more different thing there's

00:07:20,630 --> 00:07:24,110
no type equivalence or anything like

00:07:22,040 --> 00:07:25,250
that so any you know it's the only thing

00:07:24,110 --> 00:07:28,040
that you can do is stuff that's very

00:07:25,250 --> 00:07:30,350
very clearly structurally definitional

00:07:28,040 --> 00:07:32,360
things like if it's an H cons do this if

00:07:30,350 --> 00:07:33,500
it's an HTS other thing you can do that

00:07:32,360 --> 00:07:35,660
you can't do anything more complicated

00:07:33,500 --> 00:07:37,610
and you can't pair these things with

00:07:35,660 --> 00:07:39,800
value level transformations so of course

00:07:37,610 --> 00:07:41,180
the append type function is paired with

00:07:39,800 --> 00:07:43,580
the value transformation the append

00:07:41,180 --> 00:07:45,740
value level function but we can only do

00:07:43,580 --> 00:07:47,270
that because it's trivial like this is a

00:07:45,740 --> 00:07:49,490
really straightforward function and it's

00:07:47,270 --> 00:07:51,230
so straightforward that Scala C is able

00:07:49,490 --> 00:07:52,760
to sort of track the type equivalences

00:07:51,230 --> 00:07:55,130
through the proof and sort of keep

00:07:52,760 --> 00:07:56,810
things along the the entire way but

00:07:55,130 --> 00:07:59,690
Scala C is really really aggressive

00:07:56,810 --> 00:08:01,760
about throwing away type proofs and it

00:07:59,690 --> 00:08:04,160
loses the information that types are

00:08:01,760 --> 00:08:05,270
equivalent really really easily so most

00:08:04,160 --> 00:08:07,340
of the time when we're doing more

00:08:05,270 --> 00:08:08,750
complicated things we have to kind of

00:08:07,340 --> 00:08:10,610
hold its hand a little bit more and be

00:08:08,750 --> 00:08:12,770
explicit about when types are actually

00:08:10,610 --> 00:08:14,570
proven to be equivalent so we really

00:08:12,770 --> 00:08:17,330
can't do that with context independent

00:08:14,570 --> 00:08:18,950
functions type constructors type

00:08:17,330 --> 00:08:20,930
constructors are context independent

00:08:18,950 --> 00:08:22,730
functions and there's and append is like

00:08:20,930 --> 00:08:24,620
I said it's a type constructor but like

00:08:22,730 --> 00:08:25,880
I said the primary mechanism that we're

00:08:24,620 --> 00:08:27,560
going to be using to program the

00:08:25,880 --> 00:08:30,170
compiler is not type constructors but

00:08:27,560 --> 00:08:33,560
actually type classes and type classes

00:08:30,170 --> 00:08:35,240
are context dependent functions context

00:08:33,560 --> 00:08:37,880
dependent and there's some really really

00:08:35,240 --> 00:08:39,650
important distinctions here so context

00:08:37,880 --> 00:08:41,390
independence is good when you can do it

00:08:39,650 --> 00:08:43,010
like when it's an option to have a

00:08:41,390 --> 00:08:44,750
context independent function you should

00:08:43,010 --> 00:08:46,460
definitely definitely do it but it's

00:08:44,750 --> 00:08:48,050
really really limited so you get these

00:08:46,460 --> 00:08:49,460
nice properties like you know it's

00:08:48,050 --> 00:08:51,020
usable an arbitrary scope and you know

00:08:49,460 --> 00:08:52,520
users can't change it and whatnot but

00:08:51,020 --> 00:08:54,280
you know you just don't have that much

00:08:52,520 --> 00:08:57,050
flexibility and it's a really awkward

00:08:54,280 --> 00:08:58,880
you know awkward unexpressive thing to

00:08:57,050 --> 00:09:00,920
work with basically it's just lambda

00:08:58,880 --> 00:09:02,780
calculus at the type level and you know

00:09:00,920 --> 00:09:03,290
lambda calculus is turn and complete I

00:09:02,780 --> 00:09:05,509
mean you can do

00:09:03,290 --> 00:09:07,430
anything you want with it but that

00:09:05,509 --> 00:09:09,110
doesn't mean it's particularly nice

00:09:07,430 --> 00:09:12,110
so it's turing-complete it's not Turing

00:09:09,110 --> 00:09:13,940
pleasant so we're we're basically going

00:09:12,110 --> 00:09:16,009
to steer clear of this as much as we can

00:09:13,940 --> 00:09:18,170
and instead of using context independent

00:09:16,009 --> 00:09:19,639
functions where we're sort of stuck

00:09:18,170 --> 00:09:21,709
doing a very very limited set of things

00:09:19,639 --> 00:09:23,810
we're gonna use type classes and context

00:09:21,709 --> 00:09:25,040
dependent functions context dependent

00:09:23,810 --> 00:09:26,630
functions are really messy they have a

00:09:25,040 --> 00:09:28,069
really awkward syntax you kind of tear

00:09:26,630 --> 00:09:30,290
your hair out this is really indirect

00:09:28,069 --> 00:09:32,540
encoding but they're very very very

00:09:30,290 --> 00:09:34,220
powerful you can do so many things with

00:09:32,540 --> 00:09:35,920
the implicit system and nearly

00:09:34,220 --> 00:09:38,630
everything that we want to do is this

00:09:35,920 --> 00:09:40,100
basically rather than rather than giving

00:09:38,630 --> 00:09:42,279
us lambda calculus at the type level

00:09:40,100 --> 00:09:44,329
which is what type constructors give us

00:09:42,279 --> 00:09:46,459
context dependent functions give us

00:09:44,329 --> 00:09:48,589
Prolog at the type level now Prolog is

00:09:46,459 --> 00:09:50,600
still kind of a sideways language to

00:09:48,589 --> 00:09:52,699
work with but it's clearly much much

00:09:50,600 --> 00:09:54,259
much more powerful and ultimately much

00:09:52,699 --> 00:09:55,850
more pleasant than lambda calculus and

00:09:54,259 --> 00:09:57,829
and this is in fact what we're going to

00:09:55,850 --> 00:10:01,310
take advantage of so when we have

00:09:57,829 --> 00:10:04,220
context dependent functions we lose we

00:10:01,310 --> 00:10:05,720
lose some flexibility we basically like

00:10:04,220 --> 00:10:07,490
I said we're tied to function

00:10:05,720 --> 00:10:09,110
declarations we need to be working with

00:10:07,490 --> 00:10:11,480
an implicit parameter block which in

00:10:09,110 --> 00:10:14,149
Scala like you can't you can't just put

00:10:11,480 --> 00:10:15,980
that in an arbitrary type you also have

00:10:14,149 --> 00:10:17,720
this problem that the structural

00:10:15,980 --> 00:10:20,180
decomposition so the decomposition of

00:10:17,720 --> 00:10:21,920
your data and your sort of data types is

00:10:20,180 --> 00:10:23,540
tied to the operation you're performing

00:10:21,920 --> 00:10:25,190
so if you have some weird sort of

00:10:23,540 --> 00:10:27,410
complex structure and you want to define

00:10:25,190 --> 00:10:28,910
how to decompose that in one area over

00:10:27,410 --> 00:10:31,220
here and define that decomposition once

00:10:28,910 --> 00:10:32,899
and then use that decomposition over in

00:10:31,220 --> 00:10:34,430
other sort of type multiple type level

00:10:32,899 --> 00:10:36,380
functions without redefining it if

00:10:34,430 --> 00:10:38,060
you're only working in terms of context

00:10:36,380 --> 00:10:40,100
dependent functions you're basically out

00:10:38,060 --> 00:10:41,240
of luck like there's no way you can do

00:10:40,100 --> 00:10:43,610
that you have to redefine the

00:10:41,240 --> 00:10:44,899
decomposition every time whereas if you

00:10:43,610 --> 00:10:46,790
can define the decomposition with a

00:10:44,899 --> 00:10:48,110
context independent function and then

00:10:46,790 --> 00:10:49,639
all of your operations with context

00:10:48,110 --> 00:10:50,959
dependent functions then you can

00:10:49,639 --> 00:10:52,970
actually have strong separation of

00:10:50,959 --> 00:10:56,360
concerns so that's really powerful but

00:10:52,970 --> 00:10:58,220
not always applicable with context

00:10:56,360 --> 00:11:00,439
dependent functions what we gain is the

00:10:58,220 --> 00:11:02,000
ability to express arbitrary proofs at

00:11:00,439 --> 00:11:04,040
the type level and we do this by

00:11:02,000 --> 00:11:06,110
expressing facts in terms of implicit

00:11:04,040 --> 00:11:07,730
values and then Scala sees implicit

00:11:06,110 --> 00:11:09,079
search we'll go and assemble the proof

00:11:07,730 --> 00:11:11,120
for us and sort of put everything

00:11:09,079 --> 00:11:13,910
together and and so generate the

00:11:11,120 --> 00:11:15,319
generate the proof one sort of random

00:11:13,910 --> 00:11:17,550
consequence of this is towers of Hanoi

00:11:15,319 --> 00:11:20,040
which is basically prologues version of

00:11:17,550 --> 00:11:21,510
like word counter fibonacci is actually

00:11:20,040 --> 00:11:24,149
really really easy to express in

00:11:21,510 --> 00:11:26,130
scholars type system I'm sure all of us

00:11:24,149 --> 00:11:27,750
all day long need to write programs that

00:11:26,130 --> 00:11:29,700
only compile if they're a valid towers

00:11:27,750 --> 00:11:33,810
binoy solver and you know now you know

00:11:29,700 --> 00:11:34,800
that it's possible so in this talk we've

00:11:33,810 --> 00:11:36,810
already talked about a pen we're gonna

00:11:34,800 --> 00:11:38,100
talk about three more functions at the

00:11:36,810 --> 00:11:40,680
type level and they're all gonna be of

00:11:38,100 --> 00:11:42,839
the context-dependent variety we're

00:11:40,680 --> 00:11:44,040
gonna talk about remove remove is a

00:11:42,839 --> 00:11:45,750
function that will just pull things out

00:11:44,040 --> 00:11:47,490
of an H list will talk about map which

00:11:45,750 --> 00:11:49,260
is the map that you would expect and

00:11:47,490 --> 00:11:51,990
we're going to talk about M which

00:11:49,260 --> 00:11:55,230
shapeless calls apply I call it empty

00:11:51,990 --> 00:11:57,750
because I like syntax so remove remove

00:11:55,230 --> 00:11:59,940
what is removed well remove is a type

00:11:57,750 --> 00:12:02,220
indexed deletion function and you

00:11:59,940 --> 00:12:04,440
basically you give it an H list and you

00:12:02,220 --> 00:12:06,660
give it a type in this case int and it

00:12:04,440 --> 00:12:08,490
will remove all of the instances of that

00:12:06,660 --> 00:12:10,260
type from the H list and return the

00:12:08,490 --> 00:12:12,930
resulting H list you so in this case the

00:12:10,260 --> 00:12:14,310
result is false cons H now and if I had

00:12:12,930 --> 00:12:16,260
a whole bunch of other ins in there like

00:12:14,310 --> 00:12:18,089
you know one cons to cons false cons

00:12:16,260 --> 00:12:19,800
three cons H no the result would still

00:12:18,089 --> 00:12:21,570
be false cons H now because it's

00:12:19,800 --> 00:12:24,149
removing all instances of that int and

00:12:21,570 --> 00:12:26,190
clearly this function is going to need

00:12:24,149 --> 00:12:27,690
to be context dependent right where

00:12:26,190 --> 00:12:29,220
we're doing type equivalence here we're

00:12:27,690 --> 00:12:30,660
giving an int type and we're trying to

00:12:29,220 --> 00:12:33,089
like look for all of the instances of

00:12:30,660 --> 00:12:34,860
that and if it's not an int type we want

00:12:33,089 --> 00:12:36,600
to not do something with it there's

00:12:34,860 --> 00:12:38,160
there's a really not there's a sort of a

00:12:36,600 --> 00:12:39,360
non structural thing that's going on

00:12:38,160 --> 00:12:41,730
here right there's no material

00:12:39,360 --> 00:12:43,649
structural difference between a cons

00:12:41,730 --> 00:12:45,390
cell that contains an int and a cons

00:12:43,649 --> 00:12:46,620
cell that contains a boolean but we're

00:12:45,390 --> 00:12:48,779
trying to do something different with

00:12:46,620 --> 00:12:51,029
each one so we need a context dependent

00:12:48,779 --> 00:12:52,200
function in order to do this so how are

00:12:51,029 --> 00:12:53,820
we going to implement it right how are

00:12:52,200 --> 00:12:55,230
we actually gonna make this work because

00:12:53,820 --> 00:12:57,270
this this function is sort of going to

00:12:55,230 --> 00:12:59,040
be our canary in the in a type systems

00:12:57,270 --> 00:13:00,750
coal mine well what we're gonna do is

00:12:59,040 --> 00:13:02,370
we're gonna put the remove function in

00:13:00,750 --> 00:13:03,779
the implicit syntax class that we

00:13:02,370 --> 00:13:05,610
defined earlier because again we need

00:13:03,779 --> 00:13:06,899
the specific type of the H list that

00:13:05,610 --> 00:13:09,060
we're working on just like we needed

00:13:06,899 --> 00:13:11,670
with cons and what we'll do is we'll

00:13:09,060 --> 00:13:13,470
define a remover type class that will

00:13:11,670 --> 00:13:15,180
implement this function the remove

00:13:13,470 --> 00:13:16,800
function itself on H list won't do

00:13:15,180 --> 00:13:18,570
anything other than delegate to this

00:13:16,800 --> 00:13:20,610
type class and you should think of this

00:13:18,570 --> 00:13:24,029
not as a type class but as an implicit

00:13:20,610 --> 00:13:25,829
proof we're going to build a proof by

00:13:24,029 --> 00:13:28,709
you know sort of defining some facts

00:13:25,829 --> 00:13:30,460
prove that we can remove a given type

00:13:28,709 --> 00:13:32,320
from the H list

00:13:30,460 --> 00:13:35,020
and in the process of proving it

00:13:32,320 --> 00:13:36,580
actually do the removal right so we've

00:13:35,020 --> 00:13:38,410
proved that it's possible to remove a

00:13:36,580 --> 00:13:40,540
type and if it's possible to remove it

00:13:38,410 --> 00:13:42,010
do the removal something that's

00:13:40,540 --> 00:13:43,630
interesting is if we were working solely

00:13:42,010 --> 00:13:44,980
in terms of phantom types which is

00:13:43,630 --> 00:13:47,649
something that you do you know quite a

00:13:44,980 --> 00:13:49,029
bit at the compile time we we wouldn't

00:13:47,649 --> 00:13:50,560
actually even need to do the value level

00:13:49,029 --> 00:13:52,360
transformation all we would need to do

00:13:50,560 --> 00:13:54,190
is just like you prove that the types

00:13:52,360 --> 00:13:55,450
line up and that's enough for Scala C

00:13:54,190 --> 00:13:59,020
and everything would just sort of unify

00:13:55,450 --> 00:14:00,490
out so but unfortunately we do we do

00:13:59,020 --> 00:14:02,649
manipulate values because we're boring

00:14:00,490 --> 00:14:03,910
and we are actually going to do that

00:14:02,649 --> 00:14:06,040
transformation so here's what here's

00:14:03,910 --> 00:14:07,839
what it looks like in code we have this

00:14:06,040 --> 00:14:09,610
H list syntax class remember that we

00:14:07,839 --> 00:14:11,380
know the implicit class that enriches

00:14:09,610 --> 00:14:13,270
the H list type and we have the specific

00:14:11,380 --> 00:14:15,100
type of the H list we define remove

00:14:13,270 --> 00:14:19,660
which takes some parameter a and an

00:14:15,100 --> 00:14:22,209
implicit an implicit remover for type a

00:14:19,660 --> 00:14:24,040
and list L so an implicit proof that

00:14:22,209 --> 00:14:27,670
given given a list we can remove this

00:14:24,040 --> 00:14:30,279
type from this list and this this type

00:14:27,670 --> 00:14:31,510
class has a particular return type and

00:14:30,279 --> 00:14:32,680
this is you if you've never seen this

00:14:31,510 --> 00:14:34,480
syntax before this might look a little

00:14:32,680 --> 00:14:37,330
bit weird because what we're doing is

00:14:34,480 --> 00:14:39,970
we're using a dependent method type sort

00:14:37,330 --> 00:14:42,760
of a dependent output type from value R

00:14:39,970 --> 00:14:44,410
so value R has some type out on it we're

00:14:42,760 --> 00:14:46,209
pulling that type we're pulling that

00:14:44,410 --> 00:14:47,709
type out and that's the return result of

00:14:46,209 --> 00:14:48,970
our function so it's a really common

00:14:47,709 --> 00:14:51,610
idiom in doing this sort of thing

00:14:48,970 --> 00:14:54,160
because of how sort of how various

00:14:51,610 --> 00:14:56,709
limitations in in Scala's inference

00:14:54,160 --> 00:14:58,330
solver so the type class itself is

00:14:56,709 --> 00:15:00,130
really really really trivial the

00:14:58,330 --> 00:15:01,990
definition of it right we have you know

00:15:00,130 --> 00:15:03,610
we take two parameters a and L we have

00:15:01,990 --> 00:15:05,709
this this dependent output type that we

00:15:03,610 --> 00:15:07,450
talked about out which is a subtype of H

00:15:05,709 --> 00:15:09,279
list and we have an apply method that we

00:15:07,450 --> 00:15:11,230
just apply to the H list and return the

00:15:09,279 --> 00:15:12,610
output type but down in the companion

00:15:11,230 --> 00:15:14,050
object we're doing something interesting

00:15:12,610 --> 00:15:15,490
and this is one of those patterns and

00:15:14,050 --> 00:15:16,630
idioms that I was talking about write

00:15:15,490 --> 00:15:18,640
shapeless does this a lot

00:15:16,630 --> 00:15:20,890
whenever you have dependent output types

00:15:18,640 --> 00:15:22,750
you're accepting some limitations in the

00:15:20,890 --> 00:15:25,630
Scala compiler that I'll talk about more

00:15:22,750 --> 00:15:27,459
in a second but it's very very useful to

00:15:25,630 --> 00:15:29,440
sometimes bypass those limitations and

00:15:27,459 --> 00:15:31,240
move into a different context sometimes

00:15:29,440 --> 00:15:32,890
instead of what having dependent output

00:15:31,240 --> 00:15:35,459
type sometimes we actually wanted to

00:15:32,890 --> 00:15:37,930
pretend that out was just a parameter of

00:15:35,459 --> 00:15:39,430
remove and you know remove would have

00:15:37,930 --> 00:15:41,230
three type parameters instead of two and

00:15:39,430 --> 00:15:43,540
so shapeless gives us a pattern for

00:15:41,230 --> 00:15:44,120
doing this called aux so the aux type is

00:15:43,540 --> 00:15:47,630
litter

00:15:44,120 --> 00:15:49,190
it just takes al and out and it returns

00:15:47,630 --> 00:15:51,589
the particular type that is you know

00:15:49,190 --> 00:15:53,060
remover of al would type out so this is

00:15:51,589 --> 00:15:54,200
a way that when you don't want to use

00:15:53,060 --> 00:15:56,210
depending on the types and you want to

00:15:54,200 --> 00:15:58,880
use type parameters instead this is how

00:15:56,210 --> 00:15:59,960
you can do it so why would we use

00:15:58,880 --> 00:16:01,130
dependent output types in the first

00:15:59,960 --> 00:16:02,420
place right this seems a lot of like

00:16:01,130 --> 00:16:04,310
random trouble for something that I

00:16:02,420 --> 00:16:05,810
haven't actually explained yet well it

00:16:04,310 --> 00:16:07,580
basically relates back to the way that

00:16:05,810 --> 00:16:10,330
Scala see kind of does things under the

00:16:07,580 --> 00:16:13,029
surface because Scala C is solving

00:16:10,330 --> 00:16:15,230
solving a solution a constraint set

00:16:13,029 --> 00:16:16,850
based on the implicit so that it's able

00:16:15,230 --> 00:16:18,620
to find and it's trying to solve a set

00:16:16,850 --> 00:16:20,570
of types such that it can find an

00:16:18,620 --> 00:16:21,950
unambiguous implicit for that set of

00:16:20,570 --> 00:16:24,020
types and then it will sort of generate

00:16:21,950 --> 00:16:25,490
that for you now in the context of

00:16:24,020 --> 00:16:28,010
remove there's nothing really to solve

00:16:25,490 --> 00:16:30,170
because we as users are our specifying

00:16:28,010 --> 00:16:32,000
type a but if this were a more complex

00:16:30,170 --> 00:16:33,650
thing a would be a type that's part of

00:16:32,000 --> 00:16:36,020
the solution space and in Scala sees

00:16:33,650 --> 00:16:37,490
trying to like pin this down so a is

00:16:36,020 --> 00:16:39,290
basically a fact you can think of it as

00:16:37,490 --> 00:16:41,180
a fact in the solution set and if we had

00:16:39,290 --> 00:16:43,160
multiple type parameters here multiple

00:16:41,180 --> 00:16:44,750
free variables Scala C would be trying

00:16:43,160 --> 00:16:46,400
to solve them all they're basically

00:16:44,750 --> 00:16:48,080
solved from left to right within the

00:16:46,400 --> 00:16:49,730
parameter block there's some exceptions

00:16:48,080 --> 00:16:51,740
to this but more or less you can see it

00:16:49,730 --> 00:16:53,540
is like drilling in and sort of reading

00:16:51,740 --> 00:16:56,020
from left to right the problem is that

00:16:53,540 --> 00:16:58,790
some types cannot be solved in this way

00:16:56,020 --> 00:17:00,740
you run into some weird problems there's

00:16:58,790 --> 00:17:02,720
very famous bugs with like si to seven

00:17:00,740 --> 00:17:05,030
one two for example is is sort of a bug

00:17:02,720 --> 00:17:07,220
in this particular sort of quirk of

00:17:05,030 --> 00:17:08,750
Scala see there's other problems that

00:17:07,220 --> 00:17:10,220
you can run into with D aliasing and

00:17:08,750 --> 00:17:11,809
stuff like that where Scala see just

00:17:10,220 --> 00:17:13,490
basically is going to refuse to come up

00:17:11,809 --> 00:17:16,160
with a solution even though it's kind of

00:17:13,490 --> 00:17:18,530
patently obvious and unambiguous so what

00:17:16,160 --> 00:17:20,360
you can do to get around this is use

00:17:18,530 --> 00:17:23,000
these dependent output types because

00:17:20,360 --> 00:17:25,040
dependent output types are restricted in

00:17:23,000 --> 00:17:26,750
many ways they can't be used at they

00:17:25,040 --> 00:17:28,850
can't be part of a solution for a later

00:17:26,750 --> 00:17:30,770
parameter and so because of these

00:17:28,850 --> 00:17:33,620
limitations they forced Scala C to

00:17:30,770 --> 00:17:35,450
ignore certain possibilities that and

00:17:33,620 --> 00:17:36,830
sort of you know metaphorically compute

00:17:35,450 --> 00:17:39,200
the type rather than actually solving

00:17:36,830 --> 00:17:40,790
for it and that will get that will allow

00:17:39,200 --> 00:17:43,670
you to do some inference in cases where

00:17:40,790 --> 00:17:45,380
Scala C won't normally work so just as a

00:17:43,670 --> 00:17:46,429
general pattern if you have an if you

00:17:45,380 --> 00:17:48,860
have an output you know sort of

00:17:46,429 --> 00:17:50,870
production that you're producing as a

00:17:48,860 --> 00:17:52,970
result of some type level computation

00:17:50,870 --> 00:17:54,980
you know a sort of logical return type

00:17:52,970 --> 00:17:56,600
if you will you generally want to put it

00:17:54,980 --> 00:17:57,580
as a dependent output type and if you

00:17:56,600 --> 00:18:00,280
need it as a parameter you

00:17:57,580 --> 00:18:02,140
always use the Ox type so there are as I

00:18:00,280 --> 00:18:03,940
said there are restrictions here in

00:18:02,140 --> 00:18:06,820
Scala C dependent output types can't be

00:18:03,940 --> 00:18:08,320
used in various things most notably they

00:18:06,820 --> 00:18:10,480
can't be used in a computational

00:18:08,320 --> 00:18:11,950
continuation so you can't have some type

00:18:10,480 --> 00:18:13,630
class that computes a dependent output

00:18:11,950 --> 00:18:15,460
type and then another you know implicit

00:18:13,630 --> 00:18:17,230
proof that you resolve that uses that

00:18:15,460 --> 00:18:18,910
previously computed depend not the type

00:18:17,230 --> 00:18:21,460
to compute more things that's not

00:18:18,910 --> 00:18:24,460
possible in Scala C you can't derive new

00:18:21,460 --> 00:18:26,710
implicit as a function of out without

00:18:24,460 --> 00:18:27,970
using the ox type and the ox type again

00:18:26,710 --> 00:18:29,680
like that takes the dependent output

00:18:27,970 --> 00:18:31,750
type it moves it back into parametric

00:18:29,680 --> 00:18:33,370
position you accept all the limitations

00:18:31,750 --> 00:18:35,070
of parameters when you do that but

00:18:33,370 --> 00:18:37,240
sometimes that's what you have to do

00:18:35,070 --> 00:18:39,400
multiple implicit blocks are the

00:18:37,240 --> 00:18:40,510
solution to this there's there's a pull

00:18:39,400 --> 00:18:42,460
request out there that does this

00:18:40,510 --> 00:18:44,140
multiple implicit blacks solved like so

00:18:42,460 --> 00:18:45,460
many things so like if you love Scala

00:18:44,140 --> 00:18:49,170
you love implicit blocks that they're

00:18:45,460 --> 00:18:51,310
really really really great and and yeah

00:18:49,170 --> 00:18:53,470
yeah adrian is sort of scowling at me

00:18:51,310 --> 00:18:55,060
right now the the other thing that you

00:18:53,470 --> 00:18:57,580
can do which will make Adrian scowl even

00:18:55,060 --> 00:19:01,480
more is a continuation passing style at

00:18:57,580 --> 00:19:04,480
the type level yeah that okay now he's

00:19:01,480 --> 00:19:06,220
crying but the basically if you're

00:19:04,480 --> 00:19:07,720
familiar with Scala said Zhun apply or

00:19:06,220 --> 00:19:09,280
Katz's unapplied where it's basically

00:19:07,720 --> 00:19:10,660
there's this type class that takes

00:19:09,280 --> 00:19:12,430
another type class that it's going to

00:19:10,660 --> 00:19:14,290
implicitly resolve and sort of move

00:19:12,430 --> 00:19:15,910
along with computation this is another

00:19:14,290 --> 00:19:17,770
way that you can shift dependent output

00:19:15,910 --> 00:19:19,780
types back into sort of a continuation

00:19:17,770 --> 00:19:21,430
constraint space we won't talk about

00:19:19,780 --> 00:19:22,990
this very much today other than this

00:19:21,430 --> 00:19:25,360
slide because it's really a complicated

00:19:22,990 --> 00:19:27,340
thing to show but if you need it it is a

00:19:25,360 --> 00:19:28,720
technique that's out there and until we

00:19:27,340 --> 00:19:31,690
get multiple implicit blocks this is

00:19:28,720 --> 00:19:34,600
kind of the state of the art so that

00:19:31,690 --> 00:19:36,310
yeah that yes Adrian that is a threat so

00:19:34,600 --> 00:19:38,260
remover how are we going to implement

00:19:36,310 --> 00:19:39,490
remover because I have we spend all this

00:19:38,260 --> 00:19:41,380
time digressing what are we actually

00:19:39,490 --> 00:19:43,450
gonna implement this type class well

00:19:41,380 --> 00:19:45,220
we're gonna start with a base case and

00:19:43,450 --> 00:19:47,050
the base case is going to be the

00:19:45,220 --> 00:19:48,940
rightmost instance of the type that

00:19:47,050 --> 00:19:51,370
we're trying to remove right so the very

00:19:48,940 --> 00:19:52,660
very final the final instance of it in

00:19:51,370 --> 00:19:54,550
the H list we're gonna try to remove

00:19:52,660 --> 00:19:56,260
that and then we're gonna have a rebuild

00:19:54,550 --> 00:19:57,880
case which is Co inductive and we're

00:19:56,260 --> 00:19:59,890
gonna sort of be rebuilding the list and

00:19:57,880 --> 00:20:01,150
passing over types that we don't want to

00:19:59,890 --> 00:20:03,220
remove so we just want to put them back

00:20:01,150 --> 00:20:05,410
in the output list and then finally we

00:20:03,220 --> 00:20:07,060
have a co inductive remove case which is

00:20:05,410 --> 00:20:08,890
well we already removed at least one

00:20:07,060 --> 00:20:10,510
type so now we're trying to you know

00:20:08,890 --> 00:20:11,020
rebuild the list but we ran into some

00:20:10,510 --> 00:20:12,880
more type

00:20:11,020 --> 00:20:15,070
we're on removed because remember this

00:20:12,880 --> 00:20:17,080
removed function doesn't just remove the

00:20:15,070 --> 00:20:18,970
first value that it sees the first type

00:20:17,080 --> 00:20:21,820
that it sees it removes all instances of

00:20:18,970 --> 00:20:23,080
this type now if you look really closely

00:20:21,820 --> 00:20:25,810
at this you'll see that there's an

00:20:23,080 --> 00:20:28,150
ambiguity here because the base case and

00:20:25,810 --> 00:20:30,070
the co inductive remove case would in

00:20:28,150 --> 00:20:31,690
theory both apply in the same sorts of

00:20:30,070 --> 00:20:33,490
things right you know the base case is

00:20:31,690 --> 00:20:35,290
saying remove the rightmost thing but we

00:20:33,490 --> 00:20:36,760
have to make sure that we we've encoded

00:20:35,290 --> 00:20:38,950
in some way that it is truly the

00:20:36,760 --> 00:20:40,120
rightmost thing not the the any type you

00:20:38,950 --> 00:20:43,480
know this is the first type that comes

00:20:40,120 --> 00:20:46,090
across so fortunately Scala simplicity

00:20:43,480 --> 00:20:47,710
prioritization system does give us a way

00:20:46,090 --> 00:20:49,510
of encoding this priority and

00:20:47,710 --> 00:20:51,970
disambiguating between the base case and

00:20:49,510 --> 00:20:54,010
then and the remove case and the idiom

00:20:51,970 --> 00:20:56,170
usually shows up as this low priority

00:20:54,010 --> 00:20:57,640
implicit straight because it turns out

00:20:56,170 --> 00:20:59,680
that what skele c will do is when it

00:20:57,640 --> 00:21:01,570
looks in companion objects for implicit

00:20:59,680 --> 00:21:03,550
s-- it's going to look first in the

00:21:01,570 --> 00:21:04,990
companion object itself then it's going

00:21:03,550 --> 00:21:06,850
to look at inherited members from the

00:21:04,990 --> 00:21:08,680
immediate supertype then inheriting

00:21:06,850 --> 00:21:10,060
members from that super type and so on

00:21:08,680 --> 00:21:11,770
and so on but there's this strong

00:21:10,060 --> 00:21:13,540
ordering to it right and make sure that

00:21:11,770 --> 00:21:15,160
all of the ones in the base type do not

00:21:13,540 --> 00:21:16,750
apply before it starts moving on to the

00:21:15,160 --> 00:21:18,520
super type so what we're gonna do is

00:21:16,750 --> 00:21:20,260
we're gonna put the more general the

00:21:18,520 --> 00:21:22,510
less specific implicit sin the super

00:21:20,260 --> 00:21:24,130
type in this case the base case right so

00:21:22,510 --> 00:21:25,990
you notice that implicit def base it

00:21:24,130 --> 00:21:29,650
doesn't take any implicit parameters

00:21:25,990 --> 00:21:31,630
right this will apply to any h list that

00:21:29,650 --> 00:21:34,480
has type a in it and it will give us a

00:21:31,630 --> 00:21:36,070
remover for type a so so given an h list

00:21:34,480 --> 00:21:38,200
that happens you know the head of the h

00:21:36,070 --> 00:21:40,030
list is an int and there's some more

00:21:38,200 --> 00:21:41,710
stuff beyond it and we're trying to

00:21:40,030 --> 00:21:43,060
remove it in from the h list we're just

00:21:41,710 --> 00:21:44,680
going to return the tail right that's

00:21:43,060 --> 00:21:46,210
that's what this implicit fact is

00:21:44,680 --> 00:21:49,120
stating you can see that in the remover

00:21:46,210 --> 00:21:50,290
ox type but clearly this is completely

00:21:49,120 --> 00:21:52,450
unconstrained right it will just like

00:21:50,290 --> 00:21:54,700
randomly grab any of them so what we

00:21:52,450 --> 00:21:57,910
need to do then is also define the more

00:21:54,700 --> 00:21:59,980
specific co inductive case in the base

00:21:57,910 --> 00:22:01,420
type remover so the co inductive case

00:21:59,980 --> 00:22:03,250
here looks really similar right we have

00:22:01,420 --> 00:22:05,110
some type a and we have an h list L and

00:22:03,250 --> 00:22:07,150
the type a is at the head of the H list

00:22:05,110 --> 00:22:09,700
but we furthermore have this constraint

00:22:07,150 --> 00:22:12,790
that we have a remover R then we were

00:22:09,700 --> 00:22:14,410
able to remove type a from the tail so

00:22:12,790 --> 00:22:16,960
this this constraint obviously will not

00:22:14,410 --> 00:22:20,200
apply if we're not the absolute last

00:22:16,960 --> 00:22:21,520
type a that's in the list so if we're

00:22:20,200 --> 00:22:23,110
the absolute last type a we fall through

00:22:21,520 --> 00:22:24,380
the base case otherwise we're in the co

00:22:23,110 --> 00:22:25,880
recursive case

00:22:24,380 --> 00:22:27,350
and you can see right here this is the

00:22:25,880 --> 00:22:29,210
sort of signature that you should zero

00:22:27,350 --> 00:22:30,830
in on if you're just sort of x-raying

00:22:29,210 --> 00:22:33,049
through all this boilerplate is we're

00:22:30,830 --> 00:22:35,929
defining a remover of type a remover for

00:22:33,049 --> 00:22:38,780
type a given an H list that starts with

00:22:35,929 --> 00:22:39,919
type A the code inductive rebuild case

00:22:38,780 --> 00:22:41,179
is a little bit you know more

00:22:39,919 --> 00:22:43,280
complicated but it's still the same idea

00:22:41,179 --> 00:22:45,380
right now we're defining a remover for

00:22:43,280 --> 00:22:47,450
type a for an h list that starts with

00:22:45,380 --> 00:22:48,860
type B and the result is of course just

00:22:47,450 --> 00:22:50,660
like we're taking B and you know

00:22:48,860 --> 00:22:51,590
depending it to the you know prepending

00:22:50,660 --> 00:22:53,630
it to the Ageless that we're building

00:22:51,590 --> 00:22:55,820
back right the result type is the output

00:22:53,630 --> 00:22:58,789
of the ox it's the third parameter B

00:22:55,820 --> 00:23:01,070
cons are not out and it turns out that

00:22:58,789 --> 00:23:02,780
this is actually all we need to do so

00:23:01,070 --> 00:23:04,760
these three cases these implicit here

00:23:02,780 --> 00:23:07,130
these implicit facts that Scala C is

00:23:04,760 --> 00:23:09,260
going to solve for us this is the

00:23:07,130 --> 00:23:11,679
remover type class and remove now works

00:23:09,260 --> 00:23:13,610
exactly the way we wanted it to

00:23:11,679 --> 00:23:15,770
surprisingly this is the most

00:23:13,610 --> 00:23:17,690
complicated implicit proof that we will

00:23:15,770 --> 00:23:19,669
see today everything else that we do

00:23:17,690 --> 00:23:21,799
from this point forward is easier so

00:23:19,669 --> 00:23:23,299
good congratulations you've struggled

00:23:21,799 --> 00:23:27,350
through the hard stuff now we get to do

00:23:23,299 --> 00:23:29,000
the easy stuff like map now map on H

00:23:27,350 --> 00:23:30,350
list is kind of a funny function because

00:23:29,000 --> 00:23:33,260
when I talk to people about shape

00:23:30,350 --> 00:23:34,659
Lissette at sort of meetups and and you

00:23:33,260 --> 00:23:37,070
know conferences and things like that

00:23:34,659 --> 00:23:39,679
the very first thing that people say to

00:23:37,070 --> 00:23:41,840
me is how does shape let how does H List

00:23:39,679 --> 00:23:44,510
have map like how is that even possible

00:23:41,840 --> 00:23:46,250
and and the confusion is obvious right

00:23:44,510 --> 00:23:47,960
if you look at the you know functor

00:23:46,250 --> 00:23:50,419
which is this sort of defining signature

00:23:47,960 --> 00:23:52,549
for map the signature of your map takes

00:23:50,419 --> 00:23:56,840
an F of a and a function from A to B and

00:23:52,549 --> 00:23:59,179
returns an F of B but but what is a like

00:23:56,840 --> 00:24:01,309
 hey H list has many many aids

00:23:59,179 --> 00:24:02,809
inside of it which one do we pick right

00:24:01,309 --> 00:24:05,090
how do we decide which one to pass to

00:24:02,809 --> 00:24:06,260
this function is it any like what what

00:24:05,090 --> 00:24:09,289
are we doing here then another that

00:24:06,260 --> 00:24:10,820
actually makes any sense so the

00:24:09,289 --> 00:24:12,500
confusion is really natural so let's

00:24:10,820 --> 00:24:14,179
let's think about if you know if we were

00:24:12,500 --> 00:24:16,039
to define map if we were to somehow do

00:24:14,179 --> 00:24:19,100
this on each list what sort of primitive

00:24:16,039 --> 00:24:20,090
would we need to make it work well

00:24:19,100 --> 00:24:21,950
clearly we would need a way of

00:24:20,090 --> 00:24:23,330
representing this function so that we

00:24:21,950 --> 00:24:25,039
can have a function that takes many

00:24:23,330 --> 00:24:27,500
different ace and you know maybe even

00:24:25,039 --> 00:24:29,750
returns many different bees and you know

00:24:27,500 --> 00:24:31,460
we can select at compile time you know

00:24:29,750 --> 00:24:33,679
which which case of the function we're

00:24:31,460 --> 00:24:36,470
working with so a set of functions

00:24:33,679 --> 00:24:37,250
indexed by type and we want to be able

00:24:36,470 --> 00:24:38,630
to choose

00:24:37,250 --> 00:24:40,580
the implementation of this function

00:24:38,630 --> 00:24:43,040
depending on which type in the Ageless

00:24:40,580 --> 00:24:44,570
that we're applying to we want to do the

00:24:43,040 --> 00:24:46,250
second pile time we're not going to be

00:24:44,570 --> 00:24:47,480
messing around with like run time right

00:24:46,250 --> 00:24:49,220
cuz if we're doing this at run time we

00:24:47,480 --> 00:24:50,750
just say every type as any and then do

00:24:49,220 --> 00:24:52,160
pattern matching and throw exceptions

00:24:50,750 --> 00:24:53,120
and all sorts of nasty stuff right we

00:24:52,160 --> 00:24:54,950
don't we don't want to do that right

00:24:53,120 --> 00:24:57,650
we're gonna try to be you know solely at

00:24:54,950 --> 00:24:59,780
compile time because we're cool and we

00:24:57,650 --> 00:25:01,850
clearly if we if we try to apply this

00:24:59,780 --> 00:25:04,310
function to a type for which it does not

00:25:01,850 --> 00:25:06,230
have a case it just shouldn't compile

00:25:04,310 --> 00:25:08,360
right we don't want to match error we

00:25:06,230 --> 00:25:10,760
just it just shouldn't compile so how

00:25:08,360 --> 00:25:12,590
are we gonna do this how is this

00:25:10,760 --> 00:25:15,560
actually possible within Scala is it

00:25:12,590 --> 00:25:17,540
possible well it turns out the answer to

00:25:15,560 --> 00:25:20,480
this comes back to implicit as

00:25:17,540 --> 00:25:23,870
everything always does so implicit

00:25:20,480 --> 00:25:25,340
search considers the Companions of types

00:25:23,870 --> 00:25:28,420
specifically it's looking at the

00:25:25,340 --> 00:25:30,410
companion objects for all component

00:25:28,420 --> 00:25:33,470
components of the type that it's

00:25:30,410 --> 00:25:35,030
searching for so remover for example

00:25:33,470 --> 00:25:37,640
remover in the previous example was a

00:25:35,030 --> 00:25:38,870
component so that the companion object

00:25:37,640 --> 00:25:41,120
was considered when was looking for

00:25:38,870 --> 00:25:43,900
implicit now classes have companion

00:25:41,120 --> 00:25:48,440
objects we all know this objects are

00:25:43,900 --> 00:25:51,080
singleton instances of classes so this

00:25:48,440 --> 00:25:53,990
raises a really really obvious question

00:25:51,080 --> 00:25:58,220
what is the companion object for an

00:25:53,990 --> 00:26:00,430
object's class and the answer is the

00:25:58,220 --> 00:26:04,190
object itself

00:26:00,430 --> 00:26:05,990
who knew but that's that just like

00:26:04,190 --> 00:26:07,730
completely blew my mind so this is

00:26:05,990 --> 00:26:09,050
really in a very sort of strange way

00:26:07,730 --> 00:26:11,180
right objects are like their own

00:26:09,050 --> 00:26:13,190
companion but it's really really weird

00:26:11,180 --> 00:26:15,950
and it turns out that we can use this to

00:26:13,190 --> 00:26:17,990
do something extremely powerful so what

00:26:15,950 --> 00:26:20,090
we're gonna do is we're gonna say we're

00:26:17,990 --> 00:26:21,950
gonna make object the object self type

00:26:20,090 --> 00:26:24,200
right the class type of the object

00:26:21,950 --> 00:26:25,700
itself a component of the type that

00:26:24,200 --> 00:26:28,460
we're trying to search for in the

00:26:25,700 --> 00:26:30,080
implicit search and then the object that

00:26:28,460 --> 00:26:32,600
we're defining will have an implicit

00:26:30,080 --> 00:26:34,820
case the case actually defined as

00:26:32,600 --> 00:26:37,460
implicit for every type that we're

00:26:34,820 --> 00:26:39,410
trying to define a function for and then

00:26:37,460 --> 00:26:41,150
when we apply the polymorphic function

00:26:39,410 --> 00:26:42,950
we'll look up the case that we care

00:26:41,150 --> 00:26:47,150
about based on the inferred type so

00:26:42,950 --> 00:26:48,980
given this infer that you know sort of

00:26:47,150 --> 00:26:49,850
implicitly matches this and it's really

00:26:48,980 --> 00:26:51,380
easy to give

00:26:49,850 --> 00:26:53,690
I'll errors if this is not applicable

00:26:51,380 --> 00:26:55,250
because it's just implicit not found we

00:26:53,690 --> 00:26:56,750
can even customize this compile error

00:26:55,250 --> 00:26:59,030
with an annotation so it's really really

00:26:56,750 --> 00:27:01,549
easy it's also very easy to do

00:26:59,030 --> 00:27:03,470
polymorphism like default cases or cases

00:27:01,549 --> 00:27:05,120
where other type classes are defined for

00:27:03,470 --> 00:27:07,100
a particular type because you just say

00:27:05,120 --> 00:27:08,960
like you know def default square bracket

00:27:07,100 --> 00:27:10,429
a close grab acting equals case right

00:27:08,960 --> 00:27:12,410
you know it's like it's an implicit def

00:27:10,429 --> 00:27:14,690
default like then we're good and really

00:27:12,410 --> 00:27:17,000
really really critically this is going

00:27:14,690 --> 00:27:18,950
to have very good syntax and very good

00:27:17,000 --> 00:27:20,720
type inference this is the point that I

00:27:18,950 --> 00:27:22,730
think we tend to overlook as library

00:27:20,720 --> 00:27:24,650
authors we come up with this crazy cool

00:27:22,730 --> 00:27:26,390
idea for like how do we exploit some

00:27:24,650 --> 00:27:28,370
random bug and Scala to do something

00:27:26,390 --> 00:27:29,840
cool and we're like yeah users are gonna

00:27:28,370 --> 00:27:31,880
want to do this but the truth of it is

00:27:29,840 --> 00:27:33,740
if you're making users write some really

00:27:31,880 --> 00:27:35,809
crazy complicated syntax so you sort of

00:27:33,740 --> 00:27:38,600
write down some really you know arcane

00:27:35,809 --> 00:27:41,419
type in order to use your trick no one

00:27:38,600 --> 00:27:42,950
will use your trick it's true no one

00:27:41,419 --> 00:27:45,020
will do it because users care about

00:27:42,950 --> 00:27:46,340
syntax so it's really important that

00:27:45,020 --> 00:27:48,020
whenever we're coming up with this stuff

00:27:46,340 --> 00:27:50,450
we make sure that the type inference is

00:27:48,020 --> 00:27:51,799
happy with it because otherwise it

00:27:50,450 --> 00:27:54,530
doesn't matter and we're just sort of

00:27:51,799 --> 00:27:56,150
like shouting in the duct so the syntax

00:27:54,530 --> 00:27:58,730
for this is really good and it looks

00:27:56,150 --> 00:28:00,350
like so so here we're defining a

00:27:58,730 --> 00:28:02,539
polymorphic function square that's

00:28:00,350 --> 00:28:05,030
defined on three numeric types int float

00:28:02,539 --> 00:28:06,590
and double and it will literally square

00:28:05,030 --> 00:28:09,740
those numeric types and return the

00:28:06,590 --> 00:28:11,870
specific type that it's squared so if we

00:28:09,740 --> 00:28:13,970
say square four it's gonna return 16

00:28:11,870 --> 00:28:15,919
that is an int if we say square 3.14 it

00:28:13,970 --> 00:28:18,230
will return a double there's no any

00:28:15,919 --> 00:28:19,760
valeting here there's no sort of

00:28:18,230 --> 00:28:21,770
coercing to double because that's

00:28:19,760 --> 00:28:23,780
horrible and you should never do it it's

00:28:21,770 --> 00:28:25,130
all like retained within the specific

00:28:23,780 --> 00:28:27,140
type and all of this is done at compile

00:28:25,130 --> 00:28:29,840
time we can test this by trying to apply

00:28:27,140 --> 00:28:31,490
to a string and lo and behold this will

00:28:29,840 --> 00:28:33,679
fail like it just won't compile it off

00:28:31,490 --> 00:28:35,690
so this is doing what we expect and the

00:28:33,679 --> 00:28:38,539
syntax is not terrible right this is

00:28:35,690 --> 00:28:38,960
relatively fun so how do we define this

00:28:38,539 --> 00:28:41,299
what does

00:28:38,960 --> 00:28:44,690
she look like well we're gonna tell a

00:28:41,299 --> 00:28:46,159
poly train and the public train is going

00:28:44,690 --> 00:28:47,899
to kind of add function excitement that

00:28:46,159 --> 00:28:50,120
takes a signal tight perimeter hang and

00:28:47,899 --> 00:28:52,340
returns it a new type that attorney has

00:28:50,120 --> 00:28:56,059
apply method now if you've never seen

00:28:52,340 --> 00:28:57,679
this new curly brace sort of syntax good

00:28:56,059 --> 00:29:00,200
it's terrible don't use it it's good for

00:28:57,679 --> 00:29:01,610
slides nothing else but basically all

00:29:00,200 --> 00:29:04,640
I'm trying to do here is make sure that

00:29:01,610 --> 00:29:06,409
user is specifying any type and the B

00:29:04,640 --> 00:29:08,690
type which is the outlet end and

00:29:06,409 --> 00:29:10,610
function is infirm right that's all I'm

00:29:08,690 --> 00:29:14,090
trying to do it's just again tricks for

00:29:10,610 --> 00:29:16,340
good syntax so def apply being takes a

00:29:14,090 --> 00:29:19,610
function from A to B and returns a case

00:29:16,340 --> 00:29:21,590
AME now face is an inner train right

00:29:19,610 --> 00:29:23,690
it's a tight fit to find inside of the

00:29:21,590 --> 00:29:25,850
poly type which means that the type of

00:29:23,690 --> 00:29:27,049
case is going to contain the type of

00:29:25,850 --> 00:29:28,850
public which is the thing that's really

00:29:27,049 --> 00:29:30,320
really important to us okay say B it

00:29:28,850 --> 00:29:32,390
just hasn't applied that implies a

00:29:30,320 --> 00:29:34,880
determines B so that means that let me

00:29:32,390 --> 00:29:37,220
say implicit mouth is people's back in

00:29:34,880 --> 00:29:39,950
the inferred type here is going to be

00:29:37,220 --> 00:29:42,590
case and it takes an int returns event

00:29:39,950 --> 00:29:44,440
could return something else so this is

00:29:42,590 --> 00:29:46,730
the machinery how does it actually apply

00:29:44,440 --> 00:29:47,870
well they planned that the Naftali is

00:29:46,730 --> 00:29:49,820
relatively straightforward

00:29:47,870 --> 00:29:51,559
it has two type parameters a and B in

00:29:49,820 --> 00:29:53,510
first type a for the parameter that

00:29:51,559 --> 00:29:54,919
we're flying to you know like inter

00:29:53,510 --> 00:29:57,049
double or something like that and then

00:29:54,919 --> 00:30:02,210
it looks for an implicit value of type

00:29:57,049 --> 00:30:04,340
this dot takes a to B and this is the

00:30:02,210 --> 00:30:06,260
component of the type that will have

00:30:04,340 --> 00:30:08,809
that that that Scala C is going to go

00:30:06,260 --> 00:30:10,580
through and find the implicit values

00:30:08,809 --> 00:30:12,230
that were looking for because this in

00:30:10,580 --> 00:30:14,059
this case is square not type right

00:30:12,230 --> 00:30:15,890
remember for our example from earlier

00:30:14,059 --> 00:30:18,260
when we had no square extent appalling

00:30:15,890 --> 00:30:19,399
thing Square not type is the type that

00:30:18,260 --> 00:30:19,820
it's going to look at the companion

00:30:19,399 --> 00:30:21,170
Clark

00:30:19,820 --> 00:30:23,300
the companion is where that type is

00:30:21,170 --> 00:30:26,000
square so it finds these implicit values

00:30:23,300 --> 00:30:28,190
looks it up and lo and behold the square

00:30:26,000 --> 00:30:30,890
parental application works the way we

00:30:28,190 --> 00:30:32,870
wanted to pretty cool right we need to

00:30:30,890 --> 00:30:34,430
do fun things like emulate JavaScript

00:30:32,870 --> 00:30:36,620
semantics for you know integer addition

00:30:34,430 --> 00:30:40,370
right because that's exactly the sort of

00:30:36,620 --> 00:30:41,240
game and everything Watson yeah it was a

00:30:40,370 --> 00:30:43,430
complete waste of time

00:30:41,240 --> 00:30:45,200
but the there are there are some

00:30:43,430 --> 00:30:47,270
downsides here right there's problems

00:30:45,200 --> 00:30:49,970
with his encoding probably the one we

00:30:47,270 --> 00:30:51,500
can't parameterize the apartment for

00:30:49,970 --> 00:30:53,450
exactly like in the previous slide we

00:30:51,500 --> 00:30:55,280
had add one it would be kind of cool to

00:30:53,450 --> 00:30:56,870
have a den where you just take you know

00:30:55,280 --> 00:31:01,220
n is the thing that you're adding nope

00:30:56,870 --> 00:31:02,510
can't do it this is not as much of a

00:31:01,220 --> 00:31:03,770
limitation in practice as you would

00:31:02,510 --> 00:31:05,600
think it's sort of surprising but you

00:31:03,770 --> 00:31:07,190
almost never run into this but it is it

00:31:05,600 --> 00:31:09,560
is a limitation right is something to

00:31:07,190 --> 00:31:11,000
keep in mind there's no anonymous syntax

00:31:09,560 --> 00:31:13,460
if you think about this as normal

00:31:11,000 --> 00:31:14,840
functions right we have Def and we have

00:31:13,460 --> 00:31:16,910
this named thing but we don't we don't

00:31:14,840 --> 00:31:18,380
have lambda and that means that you have

00:31:16,910 --> 00:31:19,490
to name everything and the syntax is

00:31:18,380 --> 00:31:21,260
kind of bulkier than you would like

00:31:19,490 --> 00:31:23,660
that's kind of annoying I don't know

00:31:21,260 --> 00:31:25,190
it's hard to pass these things around as

00:31:23,660 --> 00:31:26,600
values right so there's polymorphic

00:31:25,190 --> 00:31:28,490
function thing it's it's difficult to

00:31:26,600 --> 00:31:30,350
sort of pass it around and be you know

00:31:28,490 --> 00:31:31,610
be generic an abstract over it because

00:31:30,350 --> 00:31:33,410
what you need to do is capture the

00:31:31,610 --> 00:31:35,210
precise type just like we have in our H

00:31:33,410 --> 00:31:37,070
list syntax class you basically say you

00:31:35,210 --> 00:31:40,130
know sort of square bracket P extends

00:31:37,070 --> 00:31:42,080
poly right it's not it's not impossible

00:31:40,130 --> 00:31:43,970
it's just weird you just have to kind of

00:31:42,080 --> 00:31:46,370
like keep track of it and that's that's

00:31:43,970 --> 00:31:48,230
sort of suboptimal but it works it works

00:31:46,370 --> 00:31:49,820
and the syntax is sort of you know past

00:31:48,230 --> 00:31:52,190
the uncanny valley where people won't

00:31:49,820 --> 00:31:52,730
use it as an exercise for those of you

00:31:52,190 --> 00:31:55,220
at home

00:31:52,730 --> 00:31:56,660
you can implement a compose function for

00:31:55,220 --> 00:31:58,640
this which takes to Polly's and returns

00:31:56,660 --> 00:32:00,140
a poly by function composition and also

00:31:58,640 --> 00:32:02,090
a union which takes to Polly's and

00:32:00,140 --> 00:32:03,440
returns a poly that has the o the union

00:32:02,090 --> 00:32:06,020
of all the cases within them these are

00:32:03,440 --> 00:32:07,670
very easy functions to implement and

00:32:06,020 --> 00:32:09,640
it's very instructive to do that but you

00:32:07,670 --> 00:32:12,770
teaches you a lot about how things work

00:32:09,640 --> 00:32:14,720
so we've got poly this is the primitive

00:32:12,770 --> 00:32:16,540
that we claimed would be enough for us

00:32:14,720 --> 00:32:19,370
to implement map so let's implement map

00:32:16,540 --> 00:32:21,770
we're gonna put a map function on H this

00:32:19,370 --> 00:32:24,980
syntax that takes some P extends poly

00:32:21,770 --> 00:32:26,720
and an implicit mapper for some H list

00:32:24,980 --> 00:32:28,220
and for some poly P that returns an

00:32:26,720 --> 00:32:29,750
output type again same pattern that we

00:32:28,220 --> 00:32:31,250
had before we're just like completely

00:32:29,750 --> 00:32:32,960
empty function delegating to explicit

00:32:31,250 --> 00:32:34,460
mapper is

00:32:32,960 --> 00:32:36,529
just like we had before it has an output

00:32:34,460 --> 00:32:38,539
type in and apply nothing fancy and it's

00:32:36,529 --> 00:32:40,279
gonna have two cases this time it's

00:32:38,539 --> 00:32:42,440
gonna have the base case which is for

00:32:40,279 --> 00:32:43,640
whatever poly that we're going on where

00:32:42,440 --> 00:32:45,250
if you're mapping over the empty list

00:32:43,640 --> 00:32:47,510
the result is the empty list

00:32:45,250 --> 00:32:48,559
nothing nothing too crazy there it

00:32:47,510 --> 00:32:50,899
really doesn't matter what poly were

00:32:48,559 --> 00:32:52,730
given however if we're not in the empty

00:32:50,899 --> 00:32:55,460
list case we need to actually do some

00:32:52,730 --> 00:32:57,980
more implicit work so in the in the Co

00:32:55,460 --> 00:32:59,450
recursive case we have a poly a P we

00:32:57,980 --> 00:33:02,600
have an H list L and we're going to

00:32:59,450 --> 00:33:03,919
infer two types a and B a is constrained

00:33:02,600 --> 00:33:05,299
to be the type that's at the head of the

00:33:03,919 --> 00:33:07,669
H list which you can see if looking at

00:33:05,299 --> 00:33:09,169
the map rocks thing B is going to be the

00:33:07,669 --> 00:33:10,850
type that's at the head of the output H

00:33:09,169 --> 00:33:13,010
list the third parameter in mapper Docs

00:33:10,850 --> 00:33:15,919
and we're gonna have to implicit

00:33:13,010 --> 00:33:20,120
constraints one is that we can find a P

00:33:15,919 --> 00:33:22,789
hash case for a B what that means is

00:33:20,120 --> 00:33:26,090
given the poly type lookup an implicit

00:33:22,789 --> 00:33:27,740
case for type a producing type B and B

00:33:26,090 --> 00:33:29,539
is the type that we're inferring here so

00:33:27,740 --> 00:33:31,370
P in this case is the type component

00:33:29,539 --> 00:33:33,260
this is the sort of square type thing

00:33:31,370 --> 00:33:36,260
right that will type infer it will be

00:33:33,260 --> 00:33:37,940
the type of the class for the object

00:33:36,260 --> 00:33:39,649
which means the object will be found as

00:33:37,940 --> 00:33:42,529
the companion for that class and then

00:33:39,649 --> 00:33:44,539
everything will sort of work out and lo

00:33:42,529 --> 00:33:45,799
and behold if we do all of this like

00:33:44,539 --> 00:33:49,429
that's all the machinery that we need

00:33:45,799 --> 00:33:50,659
surprisingly this example now works so

00:33:49,429 --> 00:33:52,100
we have an H list we have a simple

00:33:50,659 --> 00:33:53,750
transformation on the nature list we map

00:33:52,100 --> 00:33:55,490
the transform over the H list and we get

00:33:53,750 --> 00:33:57,350
another H list as a result with the

00:33:55,490 --> 00:33:59,630
specific type that's pretty cool

00:33:57,350 --> 00:34:02,149
that's really really cool this is all we

00:33:59,630 --> 00:34:03,649
needed to do it nothing magic no crazy

00:34:02,149 --> 00:34:05,929
sort of compiler hacks or anything like

00:34:03,649 --> 00:34:07,669
that just using the implicit scope so

00:34:05,929 --> 00:34:09,679
this is kind of a general rule when

00:34:07,669 --> 00:34:10,849
you're stuck and you're trying to do

00:34:09,679 --> 00:34:12,710
something cool at the type level and

00:34:10,849 --> 00:34:14,389
you're stuck try to see if you can abuse

00:34:12,710 --> 00:34:17,119
the implicit scope somehow because

00:34:14,389 --> 00:34:19,010
there's so many like corners and dusted

00:34:17,119 --> 00:34:20,359
like random skeletons hanging out you

00:34:19,010 --> 00:34:22,879
probably hide something behind that

00:34:20,359 --> 00:34:24,619
skeleton and it'll work so this is this

00:34:22,879 --> 00:34:28,070
is a really cool really cool thing to do

00:34:24,619 --> 00:34:29,960
and and and I said as I said this this

00:34:28,070 --> 00:34:31,580
you you know shapeless calls this apply

00:34:29,960 --> 00:34:33,260
it's called apply when it's on list

00:34:31,580 --> 00:34:35,750
we're calling a temp it's literally just

00:34:33,260 --> 00:34:37,550
using an integer to index into an H list

00:34:35,750 --> 00:34:40,220
and it looks like this we have an H list

00:34:37,550 --> 00:34:41,750
42 cons false cons nil and we can get

00:34:40,220 --> 00:34:44,149
the zeroth element and it knows the

00:34:41,750 --> 00:34:46,260
compiler knows that it's 42 of type nil

00:34:44,149 --> 00:34:48,120
not of type any of type male and

00:34:46,260 --> 00:34:49,830
get the second element one it's it's

00:34:48,120 --> 00:34:53,940
false and if we try to ask for the third

00:34:49,830 --> 00:34:54,510
element this won't compile so this is

00:34:53,940 --> 00:34:56,850
crazy

00:34:54,510 --> 00:35:00,870
how do you do this right how is this

00:34:56,850 --> 00:35:02,250
even possible in Scala well I mean I you

00:35:00,870 --> 00:35:04,100
know that that's a good question well

00:35:02,250 --> 00:35:06,270
assuming that it is possible right

00:35:04,100 --> 00:35:08,910
presumably we need some way of

00:35:06,270 --> 00:35:10,260
representing numbers at the type level

00:35:08,910 --> 00:35:12,210
right because we need to be able to

00:35:10,260 --> 00:35:13,800
represent these indexes so that we can

00:35:12,210 --> 00:35:15,330
find the specific type that we're

00:35:13,800 --> 00:35:17,610
looking at so what if we have something

00:35:15,330 --> 00:35:20,730
like I don't know case object one case

00:35:17,610 --> 00:35:22,860
object two case object three this is a

00:35:20,730 --> 00:35:24,450
terrible plan this is a terrible

00:35:22,860 --> 00:35:27,750
terrible plan and not just because it

00:35:24,450 --> 00:35:28,620
requires me typing for infinity like we

00:35:27,750 --> 00:35:30,840
should we should try to come up with

00:35:28,620 --> 00:35:32,400
something else and and what we can do is

00:35:30,840 --> 00:35:34,260
we can look back in the literature of

00:35:32,400 --> 00:35:36,600
logic and type theory and see if we can

00:35:34,260 --> 00:35:38,190
find a way of representing numbers you

00:35:36,600 --> 00:35:40,530
know via some sort of recursive

00:35:38,190 --> 00:35:41,850
structure that would allow us to allow

00:35:40,530 --> 00:35:43,500
us to get at these things and manipulate

00:35:41,850 --> 00:35:44,910
them at the type level and it turns out

00:35:43,500 --> 00:35:46,890
that there's already such a system it's

00:35:44,910 --> 00:35:48,480
called piano arithmetic and piano

00:35:46,890 --> 00:35:50,670
arithmetic is really straightforward you

00:35:48,480 --> 00:35:52,230
have a base case zero which is sort of

00:35:50,670 --> 00:35:54,360
empty right and then you have a

00:35:52,230 --> 00:35:56,460
successor case and the successor case

00:35:54,360 --> 00:35:58,710
has inside of it another natural number

00:35:56,460 --> 00:36:02,010
so what this means is that you can say

00:35:58,710 --> 00:36:04,050
that one is the successor of zero three

00:36:02,010 --> 00:36:05,730
is the successor of the successor of the

00:36:04,050 --> 00:36:07,680
successor of zero and it's really

00:36:05,730 --> 00:36:09,450
unpleasant to talk about but it does

00:36:07,680 --> 00:36:11,190
work right this clearly encodes the

00:36:09,450 --> 00:36:13,020
entire space of natural numbers we don't

00:36:11,190 --> 00:36:14,340
get negatives we don't get decimals but

00:36:13,020 --> 00:36:15,680
honestly we don't care because all we're

00:36:14,340 --> 00:36:18,330
trying to do is index into an ageless

00:36:15,680 --> 00:36:20,790
now as you would expect it's relatively

00:36:18,330 --> 00:36:22,890
easy to write a type low you know a sort

00:36:20,790 --> 00:36:26,010
of a function that converts a type level

00:36:22,890 --> 00:36:27,930
natural number and sub type NAT to its

00:36:26,010 --> 00:36:28,950
integer value and this is really I do

00:36:27,930 --> 00:36:31,530
recommend you do this because this is

00:36:28,950 --> 00:36:33,510
makes it debugging much much easier so

00:36:31,530 --> 00:36:35,040
in the cases are straightforward right

00:36:33,510 --> 00:36:38,100
it's pretty trivial the base case for

00:36:35,040 --> 00:36:39,660
zero returns integer zero base case for

00:36:38,100 --> 00:36:42,090
another the co inductive case for

00:36:39,660 --> 00:36:45,450
successor returns you know 1 plus the

00:36:42,090 --> 00:36:47,580
you know the inner type and we can apply

00:36:45,450 --> 00:36:48,870
it to type suck suck suck suck int or

00:36:47,580 --> 00:36:50,310
sex like sex like zero and and

00:36:48,870 --> 00:36:52,410
everything works sort of the way we

00:36:50,310 --> 00:36:53,280
would expect right returns it and this

00:36:52,410 --> 00:36:55,710
is the easy part

00:36:53,280 --> 00:36:57,480
okay so piano arithmetic gives us

00:36:55,710 --> 00:36:59,040
numbers at the type level and they do

00:36:57,480 --> 00:37:01,170
have some sort of

00:36:59,040 --> 00:37:04,020
value level representation right suck is

00:37:01,170 --> 00:37:05,460
is a case class zero is a case object so

00:37:04,020 --> 00:37:07,140
there is there is a value level

00:37:05,460 --> 00:37:08,730
implementation but it's really awkward

00:37:07,140 --> 00:37:11,130
to work with and remember what I said

00:37:08,730 --> 00:37:13,860
before about how important syntax is

00:37:11,130 --> 00:37:16,050
it's really really vitally important

00:37:13,860 --> 00:37:17,940
that our syntax is not completely eye

00:37:16,050 --> 00:37:19,620
gouging the unpleasant to work with

00:37:17,940 --> 00:37:22,050
because otherwise users don't care and

00:37:19,620 --> 00:37:23,970
our feature doesn't exist so really what

00:37:22,050 --> 00:37:26,220
we want is what I showed on the first

00:37:23,970 --> 00:37:29,040
slide which is that we're just using an

00:37:26,220 --> 00:37:30,780
int to sort of do this indexing rather

00:37:29,040 --> 00:37:34,410
than using this suck suck suck suck sort

00:37:30,780 --> 00:37:36,030
of sort of really sucky thing so what we

00:37:34,410 --> 00:37:38,190
want is a function like this right the

00:37:36,030 --> 00:37:40,290
takes that takes an integer so NAT from

00:37:38,190 --> 00:37:42,630
him and returns it now can we implement

00:37:40,290 --> 00:37:46,730
this function can we take an integer

00:37:42,630 --> 00:37:52,260
literal and lift it into a type level

00:37:46,730 --> 00:37:55,560
piano natural number well yeah we can do

00:37:52,260 --> 00:37:59,510
this we totally can do this how how you

00:37:55,560 --> 00:38:01,830
may ask well the answer is cheating

00:37:59,510 --> 00:38:03,390
macros are a mechanism for cheating in

00:38:01,830 --> 00:38:06,500
my abstract and there are mechanism for

00:38:03,390 --> 00:38:09,600
cheating in my talk man macros are

00:38:06,500 --> 00:38:10,830
really dangerous don't use them we're

00:38:09,600 --> 00:38:13,710
going to use them they allow the

00:38:10,830 --> 00:38:15,150
introduction of new primitives new

00:38:13,710 --> 00:38:16,860
primitives in the language new

00:38:15,150 --> 00:38:20,190
primitives in the type system they do

00:38:16,860 --> 00:38:23,160
not replace the existing type level

00:38:20,190 --> 00:38:25,110
facilities I cannot stress how important

00:38:23,160 --> 00:38:27,090
this is let's say you have these crazy

00:38:25,110 --> 00:38:28,740
this crazy idea for like this cool thing

00:38:27,090 --> 00:38:30,210
you want to do in the type system in

00:38:28,740 --> 00:38:33,870
Scala and you're like I know how to do

00:38:30,210 --> 00:38:35,730
this I'll just write a macro no no don't

00:38:33,870 --> 00:38:37,770
do that what you want to do is you want

00:38:35,730 --> 00:38:39,690
to compose new primitives that are

00:38:37,770 --> 00:38:41,460
constructed with macros using the

00:38:39,690 --> 00:38:43,830
existing implicit and type level

00:38:41,460 --> 00:38:45,450
mechanisms always try to do it with the

00:38:43,830 --> 00:38:47,490
existing mechanism don't just introduce

00:38:45,450 --> 00:38:48,840
primitives just because you can because

00:38:47,490 --> 00:38:50,460
it's probably gonna do it wrong because

00:38:48,840 --> 00:38:53,430
I do it wrong and miles does it wrong

00:38:50,460 --> 00:38:54,780
and like word it's terrible like it's

00:38:53,430 --> 00:38:56,040
awful like things will blow up and

00:38:54,780 --> 00:38:59,100
they're really really brittle so don't

00:38:56,040 --> 00:39:00,810
don't do this unless you absolutely have

00:38:59,100 --> 00:39:02,610
to and you've tried everything else in

00:39:00,810 --> 00:39:05,220
this case I tried everything else it

00:39:02,610 --> 00:39:06,690
didn't work so we're gonna do a macro so

00:39:05,220 --> 00:39:08,190
the from int function from it function

00:39:06,690 --> 00:39:09,930
is going to take an ant return an at and

00:39:08,190 --> 00:39:11,269
it's gonna be implemented by a macro to

00:39:09,930 --> 00:39:13,339
find in NAT

00:39:11,269 --> 00:39:14,659
crows not materialise okay this is kind

00:39:13,339 --> 00:39:16,369
of we're starting to do the boilerplate

00:39:14,659 --> 00:39:18,199
that you do for macros from current in

00:39:16,369 --> 00:39:19,999
the current version of Scala so what

00:39:18,199 --> 00:39:24,229
does NAT macros look like I'm glad you

00:39:19,999 --> 00:39:26,119
asked it's kind of madness

00:39:24,229 --> 00:39:27,949
this is the white box macro it takes it

00:39:26,119 --> 00:39:29,779
context imports each universe which is

00:39:27,949 --> 00:39:32,329
literally the entire freaking compiler

00:39:29,779 --> 00:39:33,739
and and then it has this materialized

00:39:32,329 --> 00:39:35,569
function that takes a tree and returns a

00:39:33,739 --> 00:39:36,859
tree all of this is boilerplate all we

00:39:35,569 --> 00:39:38,449
care about is the stuff that's in the

00:39:36,859 --> 00:39:39,589
middle here now the stuff that's in the

00:39:38,449 --> 00:39:42,019
middle here is going to match on the

00:39:39,589 --> 00:39:44,659
tree and it's gonna look for a constant

00:39:42,019 --> 00:39:46,279
integer literal that is greater than or

00:39:44,659 --> 00:39:47,989
equal to zero and if it doesn't find one

00:39:46,279 --> 00:39:49,849
it'll produce a compile error but if it

00:39:47,989 --> 00:39:51,469
does find one we just do this simple

00:39:49,849 --> 00:39:53,479
loop which remember this is running at

00:39:51,469 --> 00:39:55,399
compile time in the compiler so we just

00:39:53,479 --> 00:39:57,259
do this simple loop to use klausy quotes

00:39:55,399 --> 00:40:00,729
to construct suck suck suck suck suck

00:39:57,259 --> 00:40:03,439
suck suck suck suck zero and I'm gonna

00:40:00,729 --> 00:40:05,479
this is this is generating a tree which

00:40:03,439 --> 00:40:09,019
the compiler will use and it turns out

00:40:05,479 --> 00:40:11,869
that this will in fact suit our needs if

00:40:09,019 --> 00:40:14,449
we call NAT dot from it three we get a

00:40:11,869 --> 00:40:16,489
value that is of type suck square

00:40:14,449 --> 00:40:18,019
rackets suck square brackets suck zero

00:40:16,489 --> 00:40:25,489
pretty cool right

00:40:18,019 --> 00:40:26,509
yes value types don't work so the

00:40:25,489 --> 00:40:29,509
question was whether or not I could do

00:40:26,509 --> 00:40:31,239
three dot type you can sort of the

00:40:29,509 --> 00:40:33,319
problem is twofold there number one

00:40:31,239 --> 00:40:36,709
Scala C is really aggressive about

00:40:33,319 --> 00:40:38,179
throwing away value types so like the

00:40:36,709 --> 00:40:40,309
compiler does actually have a notion of

00:40:38,179 --> 00:40:41,959
like three dot type that is sort of in

00:40:40,309 --> 00:40:43,759
there it does sort of work but the

00:40:41,959 --> 00:40:45,439
compiler just very very quickly tosses

00:40:43,759 --> 00:40:47,149
it out unless you do some other tricks

00:40:45,439 --> 00:40:48,709
the other problem is that's not a

00:40:47,149 --> 00:40:50,989
structural representation it's a nominal

00:40:48,709 --> 00:40:52,909
representation so three dot type is

00:40:50,989 --> 00:40:54,439
completely distinct from two dot type

00:40:52,909 --> 00:40:57,769
and there's no like relation that we

00:40:54,439 --> 00:40:59,089
have between them so basically in order

00:40:57,769 --> 00:41:00,229
to do this stuff we want to do we would

00:40:59,089 --> 00:41:02,719
need a little bit more information than

00:41:00,229 --> 00:41:06,229
that I wanted to do it that way though I

00:41:02,719 --> 00:41:07,609
wanted to and I couldn't so anyway we

00:41:06,229 --> 00:41:09,979
have the snap from in thing it returns

00:41:07,609 --> 00:41:11,630
the specific type that's great we sort

00:41:09,979 --> 00:41:12,979
of had this magical tool now for lifting

00:41:11,630 --> 00:41:14,679
integer literals to the compiled out

00:41:12,979 --> 00:41:17,479
level but it's still not quite enough

00:41:14,679 --> 00:41:19,579
because remember our syntax here given

00:41:17,479 --> 00:41:21,769
the age list you know we there's no NAT

00:41:19,579 --> 00:41:24,230
from int going on here we want users to

00:41:21,769 --> 00:41:28,040
just type X's dot M

00:41:24,230 --> 00:41:30,650
remember syntax syntax syntax we don't

00:41:28,040 --> 00:41:32,480
want users to type nap from int we don't

00:41:30,650 --> 00:41:34,700
want them to have to explicitly convert

00:41:32,480 --> 00:41:36,290
from an integer to inapt

00:41:34,700 --> 00:41:37,940
so it would be really great if there

00:41:36,290 --> 00:41:40,460
were some feature in the scala language

00:41:37,940 --> 00:41:43,640
that allowed us to implicitly

00:41:40,460 --> 00:41:45,350
apply a conversion of some sort that

00:41:43,640 --> 00:41:46,820
maybe is a feature that we don't use

00:41:45,350 --> 00:41:48,710
very often because most of the time it

00:41:46,820 --> 00:41:50,090
blows up in our face well nothing could

00:41:48,710 --> 00:41:53,300
possibly go wrong when we're doing this

00:41:50,090 --> 00:41:54,980
with macros right we apply the implicit

00:41:53,300 --> 00:41:57,380
modifier we'll just throw that on the

00:41:54,980 --> 00:41:58,670
DEF nothing could go wrong and it turns

00:41:57,380 --> 00:42:00,260
out in this case that nothing does go

00:41:58,670 --> 00:42:04,040
right which really surprised the heck

00:42:00,260 --> 00:42:06,170
out of me this works I can't I can't

00:42:04,040 --> 00:42:08,480
even believe it this totally works

00:42:06,170 --> 00:42:10,400
and we're doing an implicit conversion

00:42:08,480 --> 00:42:13,250
as a macro Wow

00:42:10,400 --> 00:42:14,720
all right um so so how do we how do we

00:42:13,250 --> 00:42:16,220
use this how do how do we write the end

00:42:14,720 --> 00:42:17,540
function well it's pretty

00:42:16,220 --> 00:42:19,040
straightforward we throw it on the H

00:42:17,540 --> 00:42:20,420
list syntax type just like we have in

00:42:19,040 --> 00:42:22,430
the past and we're gonna have we're

00:42:20,420 --> 00:42:24,410
gonna capture the implicit naturally

00:42:22,430 --> 00:42:26,840
these sort of precise type of the NAT

00:42:24,410 --> 00:42:28,970
and subtype NAT and we'll have some

00:42:26,840 --> 00:42:30,860
implicit type class enter you know that

00:42:28,970 --> 00:42:33,290
for an at and for an H list we'll we'll

00:42:30,860 --> 00:42:34,820
find the nth value this type class is

00:42:33,290 --> 00:42:36,170
very very straightforward it's just like

00:42:34,820 --> 00:42:37,760
map it's so trivial we're not even going

00:42:36,170 --> 00:42:39,650
to implement it but we have a problem

00:42:37,760 --> 00:42:41,360
here and the problem is that we're

00:42:39,650 --> 00:42:44,480
trying to capture this precise type of

00:42:41,360 --> 00:42:46,940
map by doing n sub type map and it turns

00:42:44,480 --> 00:42:50,120
out that Scala C will not oblige with

00:42:46,940 --> 00:42:51,890
this Scala C will not trigger implicit

00:42:50,120 --> 00:42:54,230
conversions when you're doing this sort

00:42:51,890 --> 00:42:56,390
of like whole capture the precise type

00:42:54,230 --> 00:42:59,570
madness thing and so our our magical

00:42:56,390 --> 00:43:00,980
implicit conversion doesn't work so we

00:42:59,570 --> 00:43:02,720
want our magical implicit conversion to

00:43:00,980 --> 00:43:05,150
work because we're cool so how are we

00:43:02,720 --> 00:43:07,640
gonna do this well we have to be careful

00:43:05,150 --> 00:43:10,850
what we're gonna do is we're gonna put a

00:43:07,640 --> 00:43:14,330
type and subtype Matt on the nat trait

00:43:10,850 --> 00:43:17,240
itself and then type n is going to be

00:43:14,330 --> 00:43:19,490
the specific type of the nat in question

00:43:17,240 --> 00:43:22,550
so type N for 0 is just going to be 0

00:43:19,490 --> 00:43:24,670
type n for you know suck of valve and

00:43:22,550 --> 00:43:26,870
naught is gonna be sucker been not

00:43:24,670 --> 00:43:28,640
really really straightforward it's the

00:43:26,870 --> 00:43:31,370
specific type of the NAT you have in

00:43:28,640 --> 00:43:33,530
your hand which means now that down in

00:43:31,370 --> 00:43:35,300
the syntax rather than saying n sub type

00:43:33,530 --> 00:43:37,670
NAT we're going to say and I'm type not

00:43:35,300 --> 00:43:39,680
and then in the implicit

00:43:37,670 --> 00:43:43,160
block we can use dependent method types

00:43:39,680 --> 00:43:45,140
to shift that specific type end into the

00:43:43,160 --> 00:43:47,809
implicit parameter and use it in

00:43:45,140 --> 00:43:49,970
building the proof and this is how you

00:43:47,809 --> 00:43:51,440
get around the problem then the end the

00:43:49,970 --> 00:43:52,940
end of type nap will trigger the

00:43:51,440 --> 00:43:54,380
implicit conversion will get the

00:43:52,940 --> 00:43:56,329
specific type as a type member and

00:43:54,380 --> 00:43:59,960
everything works sort of astoundingly

00:43:56,329 --> 00:44:01,549
this now is functional we've now

00:43:59,960 --> 00:44:02,930
implemented all of the machinery you've

00:44:01,549 --> 00:44:04,490
literally seen it on a slide I haven't

00:44:02,930 --> 00:44:06,230
left anything out here this is all of

00:44:04,490 --> 00:44:10,609
the machinery necessary to make indexing

00:44:06,230 --> 00:44:11,990
into an H list work Wow like this think

00:44:10,609 --> 00:44:13,640
about what's going on and subscribe

00:44:11,990 --> 00:44:16,400
expression right we have an implicit

00:44:13,640 --> 00:44:18,559
conversion from int to nap that triggers

00:44:16,400 --> 00:44:20,750
a macro and the macro runs at compile

00:44:18,559 --> 00:44:22,309
time and generates a peon numeral which

00:44:20,750 --> 00:44:23,930
is represented as a series of nested

00:44:22,309 --> 00:44:25,849
type constructors and then we use

00:44:23,930 --> 00:44:27,980
dependent method types to shift the

00:44:25,849 --> 00:44:30,530
specific type over into the implicit

00:44:27,980 --> 00:44:32,510
blocks and an implicit type class which

00:44:30,530 --> 00:44:34,849
generates a proof that the indexing is

00:44:32,510 --> 00:44:36,619
valid for some piatto numeral and some H

00:44:34,849 --> 00:44:38,089
list and then when we're done we just

00:44:36,619 --> 00:44:40,970
generate a result because values are

00:44:38,089 --> 00:44:43,430
trivial so like that's a lot of stuff

00:44:40,970 --> 00:44:45,319
and it's all go it's all hidden in that

00:44:43,430 --> 00:44:46,730
tiny little expression and we did this

00:44:45,319 --> 00:44:49,880
we should feel very proud of ourselves

00:44:46,730 --> 00:44:51,500
so this is kind of magical right we're

00:44:49,880 --> 00:44:52,819
taking an integer literal we're doing

00:44:51,500 --> 00:44:54,170
some things with it at the type level

00:44:52,819 --> 00:44:55,790
and the value level we're kind of

00:44:54,170 --> 00:44:57,380
lifting things around we're getting them

00:44:55,790 --> 00:44:59,119
getting them represented so this sort of

00:44:57,380 --> 00:45:01,069
begs a really obvious question right

00:44:59,119 --> 00:45:03,470
with all of this stuff does that mean

00:45:01,069 --> 00:45:05,270
that Scala is sort of like AG de or

00:45:03,470 --> 00:45:07,579
address where it has like real real

00:45:05,270 --> 00:45:09,619
dependent types that you can sort of the

00:45:07,579 --> 00:45:10,819
value has Taiyo a specific type thank

00:45:09,619 --> 00:45:13,579
you manipulate the type level and vice

00:45:10,819 --> 00:45:15,890
versa well I think the answer to that is

00:45:13,579 --> 00:45:19,790
yeah Scala is a dependently type

00:45:15,890 --> 00:45:21,829
language the syntax is crazy and it's

00:45:19,790 --> 00:45:23,690
gonna break and random ways but Scala is

00:45:21,829 --> 00:45:25,400
totally dependent lis typed language so

00:45:23,690 --> 00:45:27,140
all of the stuff that the cool kids are

00:45:25,400 --> 00:45:28,339
doing in address you know you can go

00:45:27,140 --> 00:45:34,030
tell your friends that you could do it

00:45:28,339 --> 00:45:34,030
in Scala - Adrian says don't tell them

00:45:34,480 --> 00:45:39,890
so ok so Adrian Adrian is complaining

00:45:38,720 --> 00:45:41,930
that might have definition of the family

00:45:39,890 --> 00:45:45,290
typed is weird we can we can have a

00:45:41,930 --> 00:45:47,450
Smackdown later but that is basically

00:45:45,290 --> 00:45:49,880
all that I have for my talk we talked

00:45:47,450 --> 00:45:50,750
about context dependent and context

00:45:49,880 --> 00:45:53,180
dependent got

00:45:50,750 --> 00:45:54,619
independent functions and how you know

00:45:53,180 --> 00:45:56,300
sort of important it is to be context

00:45:54,619 --> 00:45:58,130
independent if you can but most of the

00:45:56,300 --> 00:45:59,390
time you're gonna write implicit so

00:45:58,130 --> 00:46:00,890
you're gonna be a context dependent

00:45:59,390 --> 00:46:02,330
function when you write a kind of

00:46:00,890 --> 00:46:04,340
dependent function you form an implicit

00:46:02,330 --> 00:46:06,320
proof right think of this as a proof

00:46:04,340 --> 00:46:08,240
system like prologue or coq or something

00:46:06,320 --> 00:46:10,670
like that you form an implicit proof of

00:46:08,240 --> 00:46:12,470
your action and you encode rules that

00:46:10,670 --> 00:46:14,750
the compiler will solve rules that are

00:46:12,470 --> 00:46:16,820
implicit values then you use dependent

00:46:14,750 --> 00:46:19,220
output types to move the solved types

00:46:16,820 --> 00:46:21,020
into the output position without running

00:46:19,220 --> 00:46:23,810
into sort of da liasing bugs and weird

00:46:21,020 --> 00:46:25,910
stuff like that always abuse the

00:46:23,810 --> 00:46:26,960
implicit scope fine the skeleton hide

00:46:25,910 --> 00:46:28,849
the note behind it

00:46:26,960 --> 00:46:30,800
do the jump scare all of that's great

00:46:28,849 --> 00:46:33,200
Scala C has lots of that stuff music use

00:46:30,800 --> 00:46:34,490
it and when in doubt like when you're

00:46:33,200 --> 00:46:37,640
when you've absolutely run out of

00:46:34,490 --> 00:46:42,190
options and not before then you can use

00:46:37,640 --> 00:46:42,190
macros does anybody have any questions

00:46:47,930 --> 00:46:58,099
yes what if shape was using for apply

00:46:54,410 --> 00:47:00,440
what shapeless is using a couple of

00:46:58,099 --> 00:47:02,390
macros for for the fourth shapeless --is

00:47:00,440 --> 00:47:04,369
apply yeah they use the same macro that

00:47:02,390 --> 00:47:05,510
I have basically except they didn't

00:47:04,369 --> 00:47:07,130
implement it with quasi clothes because

00:47:05,510 --> 00:47:08,930
they did it before quasi coats existed

00:47:07,130 --> 00:47:10,609
shapeless also has a couple of other

00:47:08,930 --> 00:47:12,859
macros that are primitives like the

00:47:10,609 --> 00:47:14,299
generic type class that is a it's

00:47:12,859 --> 00:47:16,460
there's a macro under the surface but

00:47:14,299 --> 00:47:17,839
again you you compose primitives with

00:47:16,460 --> 00:47:19,789
implicit so you're using the generic

00:47:17,839 --> 00:47:23,150
type class you know sort of with other

00:47:19,789 --> 00:47:27,380
implicit and implicit search anyone else

00:47:23,150 --> 00:47:30,680
I in the back I think it's a microphone

00:47:27,380 --> 00:47:31,279
coming when you do the map over the age

00:47:30,680 --> 00:47:33,619
list

00:47:31,279 --> 00:47:35,359
can you just construct the object right

00:47:33,619 --> 00:47:39,650
in the map call instead of defining it

00:47:35,359 --> 00:47:41,750
beforehand you mean the the the poly

00:47:39,650 --> 00:47:44,599
object or the h list object at the poly

00:47:41,750 --> 00:47:46,279
object yes and in fact I so in previous

00:47:44,599 --> 00:47:47,569
iterations of this talk where I didn't

00:47:46,279 --> 00:47:49,730
forget what I was saying I did actually

00:47:47,569 --> 00:47:51,650
talk about that because yeah you're not

00:47:49,730 --> 00:47:53,630
you if you notice the mapper the the

00:47:51,650 --> 00:47:55,520
mapper type class doesn't pass along the

00:47:53,630 --> 00:47:57,349
poly value we're just looking up the

00:47:55,520 --> 00:47:59,059
poly value it via the implicit scope

00:47:57,349 --> 00:48:00,500
because it's a single tip so yeah that's

00:47:59,059 --> 00:48:01,760
exactly what you said it was we don't

00:48:00,500 --> 00:48:02,809
have to bother passing things around at

00:48:01,760 --> 00:48:09,819
the value level because we have the type

00:48:02,809 --> 00:48:09,819
level anyway else think over there

00:48:11,740 --> 00:48:16,819
are you guys dreaming up some ideas on

00:48:14,480 --> 00:48:19,539
how this will work when mackerels are no

00:48:16,819 --> 00:48:22,069
longer available oh God

00:48:19,539 --> 00:48:24,020
alright so what's being referenced here

00:48:22,069 --> 00:48:26,359
is the fact that macros in their current

00:48:24,020 --> 00:48:29,030
form are kind of terrible and and being

00:48:26,359 --> 00:48:31,970
removed in dotty especially like there's

00:48:29,030 --> 00:48:34,280
no in dotty there's no parallel for

00:48:31,970 --> 00:48:35,750
white-box macros so critically what I

00:48:34,280 --> 00:48:37,160
was using there was a white box macro

00:48:35,750 --> 00:48:38,869
which allows me to manipulate trees and

00:48:37,160 --> 00:48:42,650
return a specific type rather than some

00:48:38,869 --> 00:48:43,940
sort of natsu per type there's no

00:48:42,650 --> 00:48:47,510
functionality that allows us to do that

00:48:43,940 --> 00:48:48,920
in dotty nothing there's various ways

00:48:47,510 --> 00:48:51,500
that we can do some of it so like

00:48:48,920 --> 00:48:53,359
Polly's still work and other things

00:48:51,500 --> 00:48:55,369
still work as long as we have multiple

00:48:53,359 --> 00:48:58,609
implicit blocks but this particular one

00:48:55,369 --> 00:49:00,619
is gone so what I would like is for

00:48:58,609 --> 00:49:02,930
dotty to have some mechanism for us to

00:49:00,619 --> 00:49:05,000
introduce new types at the type level

00:49:02,930 --> 00:49:06,440
ideally without the full generality of

00:49:05,000 --> 00:49:08,420
white box macros because wetbacks

00:49:06,440 --> 00:49:09,710
backers are terrible like it's really

00:49:08,420 --> 00:49:11,809
you can do awful things with the

00:49:09,710 --> 00:49:17,119
language by doing that but right now no

00:49:11,809 --> 00:49:19,460
such mechanism exists I think we're

00:49:17,119 --> 00:49:20,930
probably out of time so we should stop

00:49:19,460 --> 00:49:23,170
before people yell at us thank you very

00:49:20,930 --> 00:49:23,170

YouTube URL: https://www.youtube.com/watch?v=GKIfu1WtSz4


