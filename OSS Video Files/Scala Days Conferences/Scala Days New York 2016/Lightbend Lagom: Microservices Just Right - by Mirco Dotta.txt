Title: Lightbend Lagom: Microservices Just Right - by Mirco Dotta
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Microservices architecture are becoming a de-facto industry standard, but are you satisfied with the current state of the art? We are not, as we believe that building microservices today is more challenging than it should be. Lagom is here to take on this challenge. First, Lagom is opinionated and it will take some of the hard decisions for you, guiding you to produce microservices that adheres to the Reactive tenents. Second, Lagom was built from the ground up around you, the developer, to push your productivity to the next level. If you are familiar with the Play Framework's development environment, imagine that but tuned for building microservices; we are sure you are going to love it! Third, Lagom comes with batteries included for deploying in production: going from development to production could not be easier. In this session, you will get an introduction to the Lightbend Lagom framework. There will be code and live demos to show you in practice how it works and what you can do with it, making you fully equipped to build your next microservices with Lightbend Lagom!
Captions: 
	00:00:02,409 --> 00:00:07,220
my name is Mir Kurata I'm a software

00:00:05,450 --> 00:00:09,230
engineer a life man

00:00:07,220 --> 00:00:12,469
the company that was formerly known as

00:00:09,230 --> 00:00:14,990
typesafe and today I'm going to talk

00:00:12,469 --> 00:00:16,520
about light than Lagaan which is an

00:00:14,990 --> 00:00:20,539
open-source framework for writing

00:00:16,520 --> 00:00:22,730
reactive micro services on the JVM so

00:00:20,539 --> 00:00:24,919
you may be wondering what Lagaan means

00:00:22,730 --> 00:00:27,259
and why did we pick like all in the

00:00:24,919 --> 00:00:30,769
first place so like Elm is a Swedish

00:00:27,259 --> 00:00:33,710
word meaning adequate sufficient just

00:00:30,769 --> 00:00:36,800
right and the reason why we pick this

00:00:33,710 --> 00:00:39,350
name is because often in discussions in

00:00:36,800 --> 00:00:41,180
articles people get really focused on

00:00:39,350 --> 00:00:44,390
the micro part of the micro services

00:00:41,180 --> 00:00:46,490
name and we really think that's not what

00:00:44,390 --> 00:00:49,490
micro services is about is not the

00:00:46,490 --> 00:00:51,850
essence of micro services you should

00:00:49,490 --> 00:00:55,700
really be focusing all right size for

00:00:51,850 --> 00:00:57,740
services should be looking for finding

00:00:55,700 --> 00:01:01,160
the boundary requirements of your

00:00:57,740 --> 00:01:04,939
services isolating what has to be

00:01:01,160 --> 00:01:07,999
isolated and separating what you don't

00:01:04,939 --> 00:01:09,560
need to know in within a service so you

00:01:07,999 --> 00:01:15,380
should really be focusing on writing

00:01:09,560 --> 00:01:17,899
logon size services here is the agenda

00:01:15,380 --> 00:01:21,049
of the talk I'll start by telling you

00:01:17,899 --> 00:01:23,719
why we create a logon what are the

00:01:21,049 --> 00:01:26,210
principles behind it and then we'll dive

00:01:23,719 --> 00:01:29,179
in into the three main components of

00:01:26,210 --> 00:01:31,700
Lacombe the development environment the

00:01:29,179 --> 00:01:34,789
service API and the persistence API

00:01:31,700 --> 00:01:40,310
last but not least will discuss how to

00:01:34,789 --> 00:01:45,889
run logon services in production legume

00:01:40,310 --> 00:01:48,590
is opinionated so we want you to find an

00:01:45,889 --> 00:01:51,740
easy and consistent way for building

00:01:48,590 --> 00:01:54,139
reactive micro services in fact when you

00:01:51,740 --> 00:01:56,149
build like Armed Services they will all

00:01:54,139 --> 00:01:58,850
look fairly similar one to another

00:01:56,149 --> 00:02:01,240
the main difference being the domain

00:01:58,850 --> 00:02:04,880
that each service is going to take home

00:02:01,240 --> 00:02:07,520
so that actually simplifies you as a

00:02:04,880 --> 00:02:09,679
developer to move between teams between

00:02:07,520 --> 00:02:12,739
different services because you'll find

00:02:09,679 --> 00:02:14,640
armed structures that look pretty

00:02:12,739 --> 00:02:17,650
similar one to the other

00:02:14,640 --> 00:02:20,829
Lacombe is built on top of play and akka

00:02:17,650 --> 00:02:24,340
so it's asynchronous and non-blocking

00:02:20,829 --> 00:02:27,970
in its core and we're advocating for

00:02:24,340 --> 00:02:30,790
even sourcing and CQRS the reason is

00:02:27,970 --> 00:02:33,940
that we feel it's a really good and nice

00:02:30,790 --> 00:02:36,400
pattern for micro services it really

00:02:33,940 --> 00:02:39,340
fits in it doesn't mean that you need to

00:02:36,400 --> 00:02:41,980
write you need to use even sourcing in

00:02:39,340 --> 00:02:43,989
your if you if you're writing lagoon

00:02:41,980 --> 00:02:45,519
services but we think you should think

00:02:43,989 --> 00:02:47,590
about it you should consider that

00:02:45,519 --> 00:02:49,180
architecture pattern and you should see

00:02:47,590 --> 00:02:52,480
the benefits that it can lend you and

00:02:49,180 --> 00:02:56,560
I'll talk a lot more about this during

00:02:52,480 --> 00:02:58,989
the talk another important principle of

00:02:56,560 --> 00:03:01,139
legume is that it puts you the developer

00:02:58,989 --> 00:03:03,310
at the center of the oil experience I

00:03:01,139 --> 00:03:04,780
don't think there is any other micro

00:03:03,310 --> 00:03:07,980
service framework at the moment that

00:03:04,780 --> 00:03:10,930
does that so if you're familiar we play

00:03:07,980 --> 00:03:14,170
it really as a similar feeling in the

00:03:10,930 --> 00:03:16,359
sense that with a single task you can

00:03:14,170 --> 00:03:20,319
run all your services within a single

00:03:16,359 --> 00:03:22,269
JVM and it gives you a hot reload so

00:03:20,319 --> 00:03:24,250
whenever you do a change in your code it

00:03:22,269 --> 00:03:25,989
actually reloads the service for you

00:03:24,250 --> 00:03:27,849
without you having to do anything so

00:03:25,989 --> 00:03:30,069
you're actually always focusing on the

00:03:27,849 --> 00:03:31,590
task end and you like the development

00:03:30,069 --> 00:03:34,239
environment take care of the rest

00:03:31,590 --> 00:03:36,190
so there is no script that you like to

00:03:34,239 --> 00:03:37,419
create in order to know how to run your

00:03:36,190 --> 00:03:38,859
services

00:03:37,419 --> 00:03:40,180
there is no screed that you need to

00:03:38,859 --> 00:03:41,889
maintain across different machine

00:03:40,180 --> 00:03:44,139
possibly because your colleagues are

00:03:41,889 --> 00:03:45,609
using Windows that you use a Mac you

00:03:44,139 --> 00:03:48,609
don't have to do that we actually took

00:03:45,609 --> 00:03:50,709
care of that for you inter service

00:03:48,609 --> 00:03:52,180
communication is built in it's not

00:03:50,709 --> 00:03:56,650
something that your life to think about

00:03:52,180 --> 00:03:59,409
and we'll see how it works and it takes

00:03:56,650 --> 00:04:02,739
you through to production deployment as

00:03:59,409 --> 00:04:04,599
well so again we'd really want to get

00:04:02,739 --> 00:04:06,129
you cover not just you're in development

00:04:04,599 --> 00:04:09,430
but throughout your experience and

00:04:06,129 --> 00:04:13,510
lifecycle of your system and application

00:04:09,430 --> 00:04:15,250
development so under the hood I already

00:04:13,510 --> 00:04:17,919
mentioned some of its components it's

00:04:15,250 --> 00:04:20,079
built with SBT in fact the development

00:04:17,919 --> 00:04:24,729
environment is beta is built as a Dom

00:04:20,079 --> 00:04:26,760
SBT plugin it uses play and akka to the

00:04:24,729 --> 00:04:28,290
fourth they come

00:04:26,760 --> 00:04:30,210
bounine so to the four that we

00:04:28,290 --> 00:04:33,840
use its class restreams and pretend the

00:04:30,210 --> 00:04:36,750
persistence module Cassandra is the

00:04:33,840 --> 00:04:39,030
default data store I am going to

00:04:36,750 --> 00:04:41,040
emphasize that even though it's the

00:04:39,030 --> 00:04:44,250
default data store it doesn't mean that

00:04:41,040 --> 00:04:46,200
you have to use Cassandra but we're

00:04:44,250 --> 00:04:47,940
opinionated we had to pick something

00:04:46,200 --> 00:04:51,210
within the Cassandra is actually a

00:04:47,940 --> 00:04:54,390
really good fit for producing reactive

00:04:51,210 --> 00:04:56,100
services because it has a good

00:04:54,390 --> 00:04:58,470
scalability and good resilience ease

00:04:56,100 --> 00:05:00,780
guarantees so that's what we integrate

00:04:58,470 --> 00:05:05,070
it also it is also possible to run it

00:05:00,780 --> 00:05:06,990
within the JVM so we embedded one we

00:05:05,070 --> 00:05:08,580
embedded Cassandra in the development

00:05:06,990 --> 00:05:10,830
environment again to simplify this

00:05:08,580 --> 00:05:13,130
getting started experience but you're

00:05:10,830 --> 00:05:16,170
free to use something else

00:05:13,130 --> 00:05:18,060
Jackson is used for JSON serialization

00:05:16,170 --> 00:05:21,380
will see that JSON is the default

00:05:18,060 --> 00:05:24,150
serialization format in Lagaan juice a

00:05:21,380 --> 00:05:26,370
dependency injection framework and we

00:05:24,150 --> 00:05:29,040
have some architecture concept in Lagaan

00:05:26,370 --> 00:05:30,570
so immutability and the reason for

00:05:29,040 --> 00:05:32,370
immutability is because you get thread

00:05:30,570 --> 00:05:36,090
safety for free so you can really scale

00:05:32,370 --> 00:05:38,190
a scale app even sourcing and CQRS as

00:05:36,090 --> 00:05:40,800
already mentioned and then be talking

00:05:38,190 --> 00:05:43,740
about this later on and circuit breakers

00:05:40,800 --> 00:05:44,940
which are built-in in every service so

00:05:43,740 --> 00:05:46,410
you don't have to do anything it's

00:05:44,940 --> 00:05:51,840
something that is already built in in

00:05:46,410 --> 00:05:54,450
Lego alright enough light stay for a

00:05:51,840 --> 00:05:56,910
demo and I'm going to show you the

00:05:54,450 --> 00:06:02,070
development experience that you like by

00:05:56,910 --> 00:06:03,090
writing like armed services so we have a

00:06:02,070 --> 00:06:05,700
sample application

00:06:03,090 --> 00:06:06,420
it's a Twitter like extremely simple

00:06:05,700 --> 00:06:09,450
application

00:06:06,420 --> 00:06:13,410
it's called chipper it's an SBT project

00:06:09,450 --> 00:06:16,200
so I just type SBT I'll enter into the

00:06:13,410 --> 00:06:18,780
SBT console again ah you'll you're

00:06:16,200 --> 00:06:21,030
liable links are to go and fetch the

00:06:18,780 --> 00:06:23,910
code and and try things on your own so

00:06:21,030 --> 00:06:25,230
you don't have to yeah you know you

00:06:23,910 --> 00:06:27,900
don't have to really know where these

00:06:25,230 --> 00:06:31,100
things are at the moment and the one

00:06:27,900 --> 00:06:34,170
task that you need to run is ran all

00:06:31,100 --> 00:06:36,290
this is going to start the embedded

00:06:34,170 --> 00:06:39,330
Cassandra server which is used for

00:06:36,290 --> 00:06:42,030
persisting information for your my

00:06:39,330 --> 00:06:44,280
services then we start a service locator

00:06:42,030 --> 00:06:46,949
in a service gateway the service locator

00:06:44,280 --> 00:06:49,439
allows services to discover each other

00:06:46,949 --> 00:06:52,590
and communicate and the service gateway

00:06:49,439 --> 00:06:55,680
gives you an easy way for querying your

00:06:52,590 --> 00:06:57,210
different services because every service

00:06:55,680 --> 00:06:59,250
is going to be started on a different

00:06:57,210 --> 00:07:01,500
port so you don't want to remember what

00:06:59,250 --> 00:07:04,530
port each service is started you use the

00:07:01,500 --> 00:07:07,349
service gateway as a proxy to access

00:07:04,530 --> 00:07:09,449
your different services and then we have

00:07:07,349 --> 00:07:11,909
a sequence of services as you can see

00:07:09,449 --> 00:07:14,940
JIRA is made up of a few service that is

00:07:11,909 --> 00:07:16,860
there also started for you one thing I

00:07:14,940 --> 00:07:19,020
want to emphasize is that these services

00:07:16,860 --> 00:07:21,150
are started on but you can see they're

00:07:19,020 --> 00:07:23,819
started like on some ports these ports

00:07:21,150 --> 00:07:26,159
are actually assigned consistently so if

00:07:23,819 --> 00:07:28,469
I run into your per and one of my

00:07:26,159 --> 00:07:29,969
colleagues is running cheaper the same

00:07:28,469 --> 00:07:32,639
port is going to be used on both

00:07:29,969 --> 00:07:34,409
machines which is actually a benefit

00:07:32,639 --> 00:07:36,840
because it allows you to have scripts

00:07:34,409 --> 00:07:38,310
for like loading maybe taste data or

00:07:36,840 --> 00:07:43,020
things like that that you can share

00:07:38,310 --> 00:07:45,650
across your tips so let's just quickly

00:07:43,020 --> 00:07:48,960
see if it works

00:07:45,650 --> 00:07:55,430
so I'll so this is the cheaper app

00:07:48,960 --> 00:08:00,779
really simple you can follow people and

00:07:55,430 --> 00:08:06,360
you can just tweet or cheer and it will

00:08:00,779 --> 00:08:08,520
appear on your stream and that's really

00:08:06,360 --> 00:08:11,310
what you get and now I'm going to show

00:08:08,520 --> 00:08:13,529
you that I'll be doing some modification

00:08:11,310 --> 00:08:16,169
in the code and what happens in the

00:08:13,529 --> 00:08:18,180
development environment so let's say

00:08:16,169 --> 00:08:22,370
that I'm going to add a print line I'm

00:08:18,180 --> 00:08:26,639
just going to log something and let's go

00:08:22,370 --> 00:08:28,229
go back as you can see the sir the

00:08:26,639 --> 00:08:31,080
development environment picked up the

00:08:28,229 --> 00:08:35,729
change and it's already recompiling that

00:08:31,080 --> 00:08:42,240
service it's reloaded and now if I'm

00:08:35,729 --> 00:08:43,550
going back and treat again and lo let's

00:08:42,240 --> 00:08:46,170
see

00:08:43,550 --> 00:08:46,950
where do they make the change or get

00:08:46,170 --> 00:08:50,400
light chips

00:08:46,950 --> 00:08:53,610
okay I'm going to reload this and

00:08:50,400 --> 00:08:56,970
hopefully we'll see the message there so

00:08:53,610 --> 00:08:59,190
everything up for you underneath you

00:08:56,970 --> 00:09:02,490
could just focus on writing your code

00:08:59,190 --> 00:09:03,960
focusing on your domain and the

00:09:02,490 --> 00:09:04,940
development environment takes care of

00:09:03,960 --> 00:09:11,720
the rest

00:09:04,940 --> 00:09:11,720
so I'll stop and get back to the slide

00:09:18,400 --> 00:09:24,940
so the anatomy of a logging project

00:09:21,610 --> 00:09:29,260
it's an SBT build it's you're going to

00:09:24,940 --> 00:09:31,870
be used color 211 and JDK 8 and for each

00:09:29,260 --> 00:09:34,060
service definition in your build you'll

00:09:31,870 --> 00:09:37,300
have two different projects so each

00:09:34,060 --> 00:09:39,700
service you create two SBT projects one

00:09:37,300 --> 00:09:40,839
is an API project the other one is the

00:09:39,700 --> 00:09:43,089
implementation project the

00:09:40,839 --> 00:09:45,520
implementation project implements the

00:09:43,089 --> 00:09:51,190
EPI and we'll see what it means in

00:09:45,520 --> 00:09:53,620
practice in the code so let's have a

00:09:51,190 --> 00:09:57,850
look at the service API how do we define

00:09:53,620 --> 00:09:59,830
our services we create a trade a low

00:09:57,850 --> 00:10:03,190
service so we're going to create under

00:09:59,830 --> 00:10:05,130
low word a micro service I know that

00:10:03,190 --> 00:10:07,779
talking about a low word is usually very

00:10:05,130 --> 00:10:09,730
trivial it's a trivial example but

00:10:07,779 --> 00:10:13,660
you'll see that actually these other

00:10:09,730 --> 00:10:15,430
word services is quite representative of

00:10:13,660 --> 00:10:18,279
how you're going to create your art your

00:10:15,430 --> 00:10:20,170
own services it's at the end of the day

00:10:18,279 --> 00:10:22,930
you'll be exposing some endpoints and

00:10:20,170 --> 00:10:24,820
you'll be doing something in reaction to

00:10:22,930 --> 00:10:26,970
codes to your endpoints so they all

00:10:24,820 --> 00:10:31,630
going to look very similar to this

00:10:26,970 --> 00:10:33,670
trivial example so we we define this

00:10:31,630 --> 00:10:36,459
straight a lustre and low service that

00:10:33,670 --> 00:10:38,260
extends the logon service interface and

00:10:36,459 --> 00:10:42,100
we're going to have to implement one

00:10:38,260 --> 00:10:45,790
method the descriptor method descriptor

00:10:42,100 --> 00:10:49,209
is just a set of endpoints couple with

00:10:45,790 --> 00:10:52,360
metadata about how the service calls are

00:10:49,209 --> 00:10:55,000
to be served so in this case we're

00:10:52,360 --> 00:10:58,270
providing a name for our service the

00:10:55,000 --> 00:10:59,890
name is going to be useful for services

00:10:58,270 --> 00:11:02,170
to communicate with between each other

00:10:59,890 --> 00:11:03,279
in fact if you remember before what I

00:11:02,170 --> 00:11:04,990
showed you in the development

00:11:03,279 --> 00:11:06,850
environment when the services are

00:11:04,990 --> 00:11:09,520
started they're actually registering

00:11:06,850 --> 00:11:11,320
themselves to the service locator which

00:11:09,520 --> 00:11:13,750
is also started for you in the Velma and

00:11:11,320 --> 00:11:16,900
what they're going to register is their

00:11:13,750 --> 00:11:20,650
name together with the URL on which you

00:11:16,900 --> 00:11:23,470
can find them and then we have an

00:11:20,650 --> 00:11:26,770
endpoint that we exposed these are at a

00:11:23,470 --> 00:11:28,959
static path alone and on the right hand

00:11:26,770 --> 00:11:31,190
side we have the action that should be

00:11:28,959 --> 00:11:34,220
triggered when that part is going to

00:11:31,190 --> 00:11:35,690
be cold so it's all very similar to well

00:11:34,220 --> 00:11:38,780
if you're familiar with play it should

00:11:35,690 --> 00:11:41,480
look fairly similar and the underscore

00:11:38,780 --> 00:11:44,420
after the CLO method is just a syntactic

00:11:41,480 --> 00:11:47,470
thingy for lifting a method into a

00:11:44,420 --> 00:11:50,240
function object that's all it is and

00:11:47,470 --> 00:11:52,400
then we have this after method say

00:11:50,240 --> 00:11:54,560
yellow that is going to return something

00:11:52,400 --> 00:11:56,810
that is of type service call well we're

00:11:54,560 --> 00:11:59,600
going to talk about service calling the

00:11:56,810 --> 00:12:01,430
next slide and this is the only source

00:11:59,600 --> 00:12:07,010
in this case that we're going to place

00:12:01,430 --> 00:12:09,560
in our API project this is it so let's

00:12:07,010 --> 00:12:11,330
look at service call what it is so

00:12:09,560 --> 00:12:14,150
service call is just a trade that takes

00:12:11,330 --> 00:12:16,100
a request and returns a future a

00:12:14,150 --> 00:12:18,170
response in the future so it's

00:12:16,100 --> 00:12:19,790
asynchronous that's all it means so you

00:12:18,170 --> 00:12:23,690
can really see that as a function that

00:12:19,790 --> 00:12:25,550
takes a request and returns something so

00:12:23,690 --> 00:12:27,980
request is the type of the incoming

00:12:25,550 --> 00:12:30,050
incoming messages it can be really any

00:12:27,980 --> 00:12:32,660
type for instance string but it could be

00:12:30,050 --> 00:12:35,990
your own types and response again is any

00:12:32,660 --> 00:12:38,540
type again in our previous example it

00:12:35,990 --> 00:12:42,110
was a string but it could be a a model

00:12:38,540 --> 00:12:43,820
class that you define Jason as I

00:12:42,110 --> 00:12:46,040
mentioned at the beginning on the slides

00:12:43,820 --> 00:12:48,380
I use the default serialization format

00:12:46,040 --> 00:12:51,110
of course you can plug something

00:12:48,380 --> 00:12:53,440
different if you need to but our were

00:12:51,110 --> 00:12:55,880
opinionated so that's the default and

00:12:53,440 --> 00:12:57,380
there are two kinds of requests and

00:12:55,880 --> 00:12:59,870
response messages we have strict

00:12:57,380 --> 00:13:02,420
response request the response messages

00:12:59,870 --> 00:13:05,810
that is actually what we've we've been

00:13:02,420 --> 00:13:07,550
seen before the those are strict well

00:13:05,810 --> 00:13:12,410
the string in that case is a strict

00:13:07,550 --> 00:13:14,030
message and we're streamed so let's see

00:13:12,410 --> 00:13:18,290
what is the difference between these two

00:13:14,030 --> 00:13:20,450
panel messages so in this case it's a

00:13:18,290 --> 00:13:22,580
strict message friend ID and not use

00:13:20,450 --> 00:13:25,010
their strict messages not use it's only

00:13:22,580 --> 00:13:26,839
expressing the fact that the response is

00:13:25,010 --> 00:13:28,730
not something that we need we're not

00:13:26,839 --> 00:13:33,410
interested in the in the response it's

00:13:28,730 --> 00:13:35,330
like saying it's void it's unit and one

00:13:33,410 --> 00:13:38,030
thing I would also like to mention is

00:13:35,330 --> 00:13:40,820
that before we were using named call for

00:13:38,030 --> 00:13:42,860
this for creating the endpoint now we're

00:13:40,820 --> 00:13:44,330
using path call so what is the

00:13:42,860 --> 00:13:44,690
difference between these two kind of

00:13:44,330 --> 00:13:47,060
code

00:13:44,690 --> 00:13:49,610
so in the case of named it was a static

00:13:47,060 --> 00:13:51,770
pad in the case of Pat Cole it's a

00:13:49,610 --> 00:13:54,410
dynamic pad in fact we're extracting

00:13:51,770 --> 00:14:00,170
something from the pad and we're passing

00:13:54,410 --> 00:14:02,480
it to the addfriend method so print ID

00:14:00,170 --> 00:14:04,490
not use those are strict messages and

00:14:02,480 --> 00:14:10,040
that means that they're fully buffered

00:14:04,490 --> 00:14:12,440
in memory let's say we want to do

00:14:10,040 --> 00:14:14,360
streaming because well let's say that we

00:14:12,440 --> 00:14:16,990
have a sequence of elements that we want

00:14:14,360 --> 00:14:19,160
to send or receive from another service

00:14:16,990 --> 00:14:21,710
you don't want to bother everything in

00:14:19,160 --> 00:14:25,130
memory right so in that case you should

00:14:21,710 --> 00:14:28,360
be using streaming and I'll how do we

00:14:25,130 --> 00:14:30,980
use streaming well we with the clarity

00:14:28,360 --> 00:14:33,350
request the response to be a source of

00:14:30,980 --> 00:14:35,830
sending if you're familiar with akha

00:14:33,350 --> 00:14:39,010
stream that is an extreme source and

00:14:35,830 --> 00:14:41,270
what we get is actually back pressured

00:14:39,010 --> 00:14:47,750
asynchronous streaming across our

00:14:41,270 --> 00:14:51,020
services source our if before our

00:14:47,750 --> 00:14:53,660
messages were the transport protocol was

00:14:51,020 --> 00:14:55,580
going to be HTTP at this point in time

00:14:53,660 --> 00:14:58,190
in Lagaan the default transport protocol

00:14:55,580 --> 00:15:01,400
is HTTP we can add other things in the

00:14:58,190 --> 00:15:03,200
future if you if you're declaring your

00:15:01,400 --> 00:15:04,970
response or request messages to be a

00:15:03,200 --> 00:15:10,580
source that will be mapped into a

00:15:04,970 --> 00:15:14,300
WebSocket at the moment alright so

00:15:10,580 --> 00:15:16,430
remember our service definition let's

00:15:14,300 --> 00:15:21,920
see what implementation of this service

00:15:16,430 --> 00:15:24,800
looks like very simple we have class

00:15:21,920 --> 00:15:27,410
service implementation it extends our

00:15:24,800 --> 00:15:29,750
trade and we need to provide an

00:15:27,410 --> 00:15:32,060
implementation of the clo method and

00:15:29,750 --> 00:15:35,210
what that implementation does is simply

00:15:32,060 --> 00:15:39,410
returning a future of a string that's

00:15:35,210 --> 00:15:41,000
really what it is and this source file

00:15:39,410 --> 00:15:43,370
is going to be placed into your

00:15:41,000 --> 00:15:45,170
implementation project so the

00:15:43,370 --> 00:15:48,470
implementation project since I need to

00:15:45,170 --> 00:15:51,880
extend the allow service tray it has to

00:15:48,470 --> 00:15:51,880
depends on the API project

00:15:52,960 --> 00:15:57,470
now let's say that I have another

00:15:55,100 --> 00:15:59,510
service and I want this service this new

00:15:57,470 --> 00:16:02,090
service to communicate with our elawar

00:15:59,510 --> 00:16:04,520
service how can I do that that's

00:16:02,090 --> 00:16:07,880
actually extremely simple I simply need

00:16:04,520 --> 00:16:11,060
to inject the allo service interface or

00:16:07,880 --> 00:16:14,150
trade into my implementation class and

00:16:11,060 --> 00:16:16,190
then anywhere so in this case in the

00:16:14,150 --> 00:16:19,580
implementation of our say hello Lagoon

00:16:16,190 --> 00:16:23,750
method I'm going to invoke the service

00:16:19,580 --> 00:16:29,450
yellow service endpoint so really really

00:16:23,750 --> 00:16:35,300
simple good

00:16:29,450 --> 00:16:39,410
so the persistent so what I show you is

00:16:35,300 --> 00:16:41,600
how to write stateless services right

00:16:39,410 --> 00:16:44,000
but at some point you will want to

00:16:41,600 --> 00:16:46,670
persist information in your services and

00:16:44,000 --> 00:16:48,530
this is where the persistence API will

00:16:46,670 --> 00:16:51,350
be handy so let's explore the

00:16:48,530 --> 00:16:55,280
persistence API there are a couple of

00:16:51,350 --> 00:16:59,180
principle one is a each service should

00:16:55,280 --> 00:17:02,510
mast own its data so only the service

00:16:59,180 --> 00:17:04,820
has access to its database any other

00:17:02,510 --> 00:17:07,670
service that is interested in the data

00:17:04,820 --> 00:17:11,360
that is old by one one service you

00:17:07,670 --> 00:17:14,180
should ask for information but it does

00:17:11,360 --> 00:17:15,829
never have access to the database that

00:17:14,180 --> 00:17:20,390
is owned by you know the specific

00:17:15,829 --> 00:17:24,410
service and we advocate the use of even

00:17:20,390 --> 00:17:26,300
sourcing and secure s not sure whether

00:17:24,410 --> 00:17:29,300
you're familiar or not with the concept

00:17:26,300 --> 00:17:31,940
but at the very high level even sourcing

00:17:29,300 --> 00:17:34,970
is about camp capturing all state

00:17:31,940 --> 00:17:38,720
changes in your applications as events

00:17:34,970 --> 00:17:41,840
so if you compare that to a crap data

00:17:38,720 --> 00:17:43,370
store it means that so we crack what you

00:17:41,840 --> 00:17:45,200
know is that you know you always know

00:17:43,370 --> 00:17:46,640
the current state but you have no idea

00:17:45,200 --> 00:17:48,680
how did you get there

00:17:46,640 --> 00:17:50,780
you don't know that you can only know

00:17:48,680 --> 00:17:53,060
about where is what is the state today

00:17:50,780 --> 00:17:55,760
at this point in time but you don't know

00:17:53,060 --> 00:17:58,100
how you got there with event sourcing

00:17:55,760 --> 00:18:00,230
you're actually capturing the events so

00:17:58,100 --> 00:18:02,450
the facts that actually made your state

00:18:00,230 --> 00:18:03,230
evolve throughout the life of your

00:18:02,450 --> 00:18:05,750
application

00:18:03,230 --> 00:18:07,760
so these are all familiar

00:18:05,750 --> 00:18:10,460
with functional programming you could

00:18:07,760 --> 00:18:13,490
see the current state as a left fold of

00:18:10,460 --> 00:18:21,470
the events that you had in your system

00:18:13,490 --> 00:18:23,600
and cqs is a pattern for that basically

00:18:21,470 --> 00:18:26,300
tells you that are it's interesting or

00:18:23,600 --> 00:18:28,970
it's a good idea to see separate the

00:18:26,300 --> 00:18:31,160
modules were right and read so that you

00:18:28,970 --> 00:18:32,930
can scale both you can tune both

00:18:31,160 --> 00:18:34,850
accordingly because you have different

00:18:32,930 --> 00:18:40,040
needs when you read data and when you

00:18:34,850 --> 00:18:42,500
write data there are a couple of things

00:18:40,040 --> 00:18:45,860
that I want to point out before we get

00:18:42,500 --> 00:18:49,190
into the API because he often get people

00:18:45,860 --> 00:18:51,770
confused in Lagaan you don't have to do

00:18:49,190 --> 00:18:53,900
even sourcing and CQRS it's something

00:18:51,770 --> 00:18:56,840
we're advocating but it doesn't mean

00:18:53,900 --> 00:18:57,770
that is the only way we're using

00:18:56,840 --> 00:19:00,470
Cassandra

00:18:57,770 --> 00:19:03,230
so the persistence API is tightly

00:19:00,470 --> 00:19:05,330
coupled with Cassandra if you don't want

00:19:03,230 --> 00:19:07,490
to use Cassandra you're simply not going

00:19:05,330 --> 00:19:10,490
to use the persistence module off logon

00:19:07,490 --> 00:19:12,110
you lose something different and if you

00:19:10,490 --> 00:19:14,270
don't want to do even sourcing and

00:19:12,110 --> 00:19:16,160
secure s but you still want to do it use

00:19:14,270 --> 00:19:18,770
Cassandra you can still use the

00:19:16,160 --> 00:19:20,660
persistence API but you're not going to

00:19:18,770 --> 00:19:25,430
use the abstraction that we created for

00:19:20,660 --> 00:19:27,680
doing even sourcing f-secure s so some

00:19:25,430 --> 00:19:30,230
of the benefits of even sourcing and

00:19:27,680 --> 00:19:34,040
secure s it allows you to try it to time

00:19:30,230 --> 00:19:36,020
trouble why well because you have events

00:19:34,040 --> 00:19:37,940
or what determine the state of your

00:19:36,020 --> 00:19:40,570
application since you're storing all the

00:19:37,940 --> 00:19:43,610
events you can just go back in time and

00:19:40,570 --> 00:19:45,020
replay the events up to that moment to

00:19:43,610 --> 00:19:48,500
see what was the state of your

00:19:45,020 --> 00:19:51,830
application you get an audit log for

00:19:48,500 --> 00:19:54,200
free and it opens up for future business

00:19:51,830 --> 00:19:55,730
opportunities because you are recording

00:19:54,200 --> 00:19:59,840
everything you're not losing any

00:19:55,730 --> 00:20:01,880
information right so let's say that the

00:19:59,840 --> 00:20:03,590
reason there is one of your business

00:20:01,880 --> 00:20:05,450
persons come to you and say well I'd

00:20:03,590 --> 00:20:08,900
really like to implement this new use

00:20:05,450 --> 00:20:10,820
case can we do it you can say yes you

00:20:08,900 --> 00:20:12,770
can actually benefit from having stored

00:20:10,820 --> 00:20:16,430
everything about your application and

00:20:12,770 --> 00:20:16,960
use those data so that um in a useful

00:20:16,430 --> 00:20:19,460
way

00:20:16,960 --> 00:20:21,649
there is no need for an

00:20:19,460 --> 00:20:23,659
RM there is no need for that because

00:20:21,649 --> 00:20:26,990
there is no impedance mismatch the

00:20:23,659 --> 00:20:30,010
events which is what define your state

00:20:26,990 --> 00:20:32,960
transition is actually what you store

00:20:30,010 --> 00:20:34,340
there is no migration script ever that

00:20:32,960 --> 00:20:36,350
you need to create and the reason for

00:20:34,340 --> 00:20:38,960
that is because your tables your read

00:20:36,350 --> 00:20:41,659
tables the query tables you can recreate

00:20:38,960 --> 00:20:43,429
them starting from events again the

00:20:41,659 --> 00:20:45,260
events are the only single source of

00:20:43,429 --> 00:20:47,179
truth and everything else can be

00:20:45,260 --> 00:20:51,610
recreated based on the events that you

00:20:47,179 --> 00:20:54,649
start you will never delete events and

00:20:51,610 --> 00:20:56,270
there are good and interesting things

00:20:54,649 --> 00:20:58,940
related to performance and scalability

00:20:56,270 --> 00:21:00,740
again because ah you can have different

00:20:58,940 --> 00:21:03,710
databases for instance for writes and

00:21:00,740 --> 00:21:06,020
reads that are tuned for the specific

00:21:03,710 --> 00:21:08,860
needs that you have and they're usually

00:21:06,020 --> 00:21:13,070
very easy to test and debug even sourced

00:21:08,860 --> 00:21:15,169
systems because you can send commands

00:21:13,070 --> 00:21:16,340
the generate events and those are the

00:21:15,169 --> 00:21:18,049
things that actually generate

00:21:16,340 --> 00:21:20,630
state-transition in your application so

00:21:18,049 --> 00:21:22,460
it's very easy to reproduce a problem

00:21:20,630 --> 00:21:24,320
because you can just go in the log you

00:21:22,460 --> 00:21:27,200
see what were the commands that were

00:21:24,320 --> 00:21:29,210
sent to my application and you reproduce

00:21:27,200 --> 00:21:30,890
those in your in your test and your

00:21:29,210 --> 00:21:36,500
application will be exactly in the same

00:21:30,890 --> 00:21:40,580
stay so let's see how it works event

00:21:36,500 --> 00:21:43,220
sourcing in logon so you like to create

00:21:40,580 --> 00:21:45,740
command any bank classes I didn't

00:21:43,220 --> 00:21:48,440
mention this yet back command are things

00:21:45,740 --> 00:21:50,510
you'd like the system to do events are

00:21:48,440 --> 00:21:54,159
things that the system has done they're

00:21:50,510 --> 00:21:57,950
fact things that are already happen so

00:21:54,159 --> 00:22:01,700
when you send a command you may trigger

00:21:57,950 --> 00:22:03,799
an event or it may not be depend if the

00:22:01,700 --> 00:22:05,600
system is is okay in handling that

00:22:03,799 --> 00:22:08,179
commander is going to be an event that

00:22:05,600 --> 00:22:11,090
is generated out of that command but a

00:22:08,179 --> 00:22:15,409
system can also reject a command and so

00:22:11,090 --> 00:22:17,210
there will be no event generated and so

00:22:15,409 --> 00:22:19,399
after creating your command and event

00:22:17,210 --> 00:22:21,380
classes that are just Cal object scalar

00:22:19,399 --> 00:22:25,100
classes case classes in the specific

00:22:21,380 --> 00:22:28,520
case you'll have to subclass persistent

00:22:25,100 --> 00:22:30,700
entity so persistent entity it will just

00:22:28,520 --> 00:22:33,639
define command and event handlers

00:22:30,700 --> 00:22:36,580
and state-transition so the precision

00:22:33,639 --> 00:22:38,919
entity is is going to represent the

00:22:36,580 --> 00:22:41,049
state of your entity will see what an

00:22:38,919 --> 00:22:44,499
entity is with a specific example and

00:22:41,049 --> 00:22:47,559
your same command to this arm persistent

00:22:44,499 --> 00:22:51,249
entity command will generate events so

00:22:47,559 --> 00:22:53,139
we'll store events and events means that

00:22:51,249 --> 00:22:54,940
we're also going to transition the state

00:22:53,139 --> 00:22:56,919
because the persistent entity represent

00:22:54,940 --> 00:22:59,379
the current state of your application in

00:22:56,919 --> 00:23:01,470
memory right and events are things that

00:22:59,379 --> 00:23:06,600
you're going to store in your database

00:23:01,470 --> 00:23:11,190
and if you're familiar with DDD a

00:23:06,600 --> 00:23:11,190
persistent entity is an aggregate root

00:23:11,879 --> 00:23:18,700
so let's implement the add friend

00:23:16,389 --> 00:23:22,600
functionality of our twitter-like

00:23:18,700 --> 00:23:25,359
application that I showcase before we're

00:23:22,600 --> 00:23:28,450
going to define frame commands a tray

00:23:25,359 --> 00:23:30,909
and add friend is going to be our

00:23:28,450 --> 00:23:34,779
command that we're going to send to the

00:23:30,909 --> 00:23:39,789
persistent entity so we want to add a

00:23:34,779 --> 00:23:45,429
friend with a specific user ID to a to a

00:23:39,789 --> 00:23:47,679
user let's create the event that will be

00:23:45,429 --> 00:23:50,799
triggered if the command is accepted by

00:23:47,679 --> 00:23:52,659
the system so events or facts are things

00:23:50,799 --> 00:23:57,070
that happen and that's why we call it

00:23:52,659 --> 00:24:00,100
friend added ok that's a fact once the

00:23:57,070 --> 00:24:05,470
event is accept is produced it means

00:24:00,100 --> 00:24:08,470
that it's an accepted fact and now we

00:24:05,470 --> 00:24:11,379
implement our persistent entity so we

00:24:08,470 --> 00:24:13,359
just extends persistent entity and we

00:24:11,379 --> 00:24:16,210
have this initial behavior method that

00:24:13,359 --> 00:24:19,019
we need to implement so let's see what

00:24:16,210 --> 00:24:21,489
we put inside we have a command handler

00:24:19,019 --> 00:24:25,779
so what is the command is this add

00:24:21,489 --> 00:24:27,789
friend right so we set a command and

00:24:25,779 --> 00:24:32,739
learn that takes had friend and it will

00:24:27,789 --> 00:24:35,049
answer a will and any will react by well

00:24:32,739 --> 00:24:37,029
let's check the state the current state

00:24:35,049 --> 00:24:39,789
of the entity let's see if there is a

00:24:37,029 --> 00:24:42,009
user if there is no user then we can add

00:24:39,789 --> 00:24:44,070
a friend to that user right so if the

00:24:42,009 --> 00:24:47,610
persistent entity state as

00:24:44,070 --> 00:24:54,690
a user then we're going to produce an

00:24:47,610 --> 00:24:57,600
event friend added and and here it's um

00:24:54,690 --> 00:24:59,880
the response that we're going to send

00:24:57,600 --> 00:25:04,320
back one when different when the friend

00:24:59,880 --> 00:25:07,560
command is um is sent when the friend

00:25:04,320 --> 00:25:11,550
command is sent to our persistent entity

00:25:07,560 --> 00:25:13,380
and in the case that there is no user so

00:25:11,550 --> 00:25:15,450
if there is no user we can't and a

00:25:13,380 --> 00:25:17,550
friend right and if we can't add a

00:25:15,450 --> 00:25:19,290
friend then we can do validation and say

00:25:17,550 --> 00:25:21,720
well we can't accept this command and

00:25:19,290 --> 00:25:24,060
this is the case when no events is going

00:25:21,720 --> 00:25:26,160
to be persisted because we cannot be

00:25:24,060 --> 00:25:30,600
adding a friend if we don't have a user

00:25:26,160 --> 00:25:35,850
in the first place then we're also going

00:25:30,600 --> 00:25:38,670
to create an event handler so ah the

00:25:35,850 --> 00:25:41,460
type is going to be friend added in this

00:25:38,670 --> 00:25:43,380
case that and the friend added event was

00:25:41,460 --> 00:25:47,640
produced by our command and learned that

00:25:43,380 --> 00:25:50,490
we've seen before and what this event

00:25:47,640 --> 00:25:53,640
under will do is that it will update the

00:25:50,490 --> 00:25:57,090
state of the brain of our friend entity

00:25:53,640 --> 00:25:59,700
right it will update the state by adding

00:25:57,090 --> 00:26:03,000
the specific friend to the set of

00:25:59,700 --> 00:26:05,340
friends of our user important thing is

00:26:03,000 --> 00:26:09,210
that there are no side effects that

00:26:05,340 --> 00:26:11,220
should be done here and the reason why

00:26:09,210 --> 00:26:13,710
there should be no side effect and there

00:26:11,220 --> 00:26:15,660
let's say that let's say that we're

00:26:13,710 --> 00:26:17,880
talking about like for purchase orders

00:26:15,660 --> 00:26:20,190
and one side effect could be like I want

00:26:17,880 --> 00:26:22,020
to send an email saying that your order

00:26:20,190 --> 00:26:24,300
has been accepted you should have been

00:26:22,020 --> 00:26:26,700
doing it there because in an event

00:26:24,300 --> 00:26:28,860
sourcing system you want to be able to

00:26:26,700 --> 00:26:32,130
recreate the state by replaying the

00:26:28,860 --> 00:26:33,870
events so if I'm replaying the events it

00:26:32,130 --> 00:26:37,170
means that I would be resetting emails

00:26:33,870 --> 00:26:40,680
to all our for all porches which is not

00:26:37,170 --> 00:26:45,600
something you want to do right so that

00:26:40,680 --> 00:26:49,050
lambda has to be side-effect free and

00:26:45,600 --> 00:26:51,900
finally uh this is the French state so

00:26:49,050 --> 00:26:54,780
this is the current state of our friend

00:26:51,900 --> 00:26:57,750
entity and that was the addfriend method

00:26:54,780 --> 00:26:59,400
that we were calling before in the event

00:26:57,750 --> 00:27:01,980
Center that we have just seen I'll just

00:26:59,400 --> 00:27:05,400
go back one slide you see when you when

00:27:01,980 --> 00:27:07,770
we do state that friend this is the

00:27:05,400 --> 00:27:15,540
state that is managed and all the memory

00:27:07,770 --> 00:27:18,300
by our friend entity good so we have

00:27:15,540 --> 00:27:20,640
defined these different commands events

00:27:18,300 --> 00:27:23,670
the friend entity different state so we

00:27:20,640 --> 00:27:25,680
got all the different components now we

00:27:23,670 --> 00:27:28,200
want to use this procedure this friend

00:27:25,680 --> 00:27:31,170
entity how do we do that well in our

00:27:28,200 --> 00:27:33,360
friend service implementation we have a

00:27:31,170 --> 00:27:35,720
meta that frame right there is going to

00:27:33,360 --> 00:27:38,160
be an endpoint for adding a friend

00:27:35,720 --> 00:27:40,890
exposed by the service to add a friend

00:27:38,160 --> 00:27:43,740
and so what we need to do is we need to

00:27:40,890 --> 00:27:47,340
inject that persistent entity registry

00:27:43,740 --> 00:27:49,980
in our implementation class the first

00:27:47,340 --> 00:27:54,120
thing we want to do is register the

00:27:49,980 --> 00:27:56,820
friend entity to this persistent entity

00:27:54,120 --> 00:27:58,740
registry and then in the add friend

00:27:56,820 --> 00:28:02,460
functionality we want to get a reference

00:27:58,740 --> 00:28:06,150
to the persistent entity for a specific

00:28:02,460 --> 00:28:08,190
user ID so we are going in our cluster

00:28:06,150 --> 00:28:11,240
we're going to have only one instance of

00:28:08,190 --> 00:28:13,380
a persistent entity for every entity ID

00:28:11,240 --> 00:28:15,750
right you don't want to have more than

00:28:13,380 --> 00:28:18,660
one otherwise you get problems about

00:28:15,750 --> 00:28:20,760
data corruption right there is only one

00:28:18,660 --> 00:28:22,830
truth and every persistent entity is

00:28:20,760 --> 00:28:24,990
going to exist only in one node

00:28:22,830 --> 00:28:27,950
somewhere in the cluster it's not up to

00:28:24,990 --> 00:28:30,030
you to know it's all handled for you and

00:28:27,950 --> 00:28:33,030
what we're going to do is that we're

00:28:30,030 --> 00:28:36,420
going to send a command add frame to our

00:28:33,030 --> 00:28:38,310
persistent entity right and then this

00:28:36,420 --> 00:28:40,950
the persistent entity will decide

00:28:38,310 --> 00:28:43,830
whether it can handle that command and

00:28:40,950 --> 00:28:45,210
so produce an event or not as we've seen

00:28:43,830 --> 00:28:51,360
before in the implementation of the

00:28:45,210 --> 00:28:56,430
command handler so that was the right

00:28:51,360 --> 00:28:59,100
side now let's look at the read side the

00:28:56,430 --> 00:28:59,790
right side is tightly integrated with

00:28:59,100 --> 00:29:02,390
Cassandra

00:28:59,790 --> 00:29:06,000
so you see you like to use things like

00:29:02,390 --> 00:29:10,470
the Cassandra query language to extract

00:29:06,000 --> 00:29:13,409
information from your query table and

00:29:10,470 --> 00:29:15,809
how do you create your query table you

00:29:13,409 --> 00:29:18,380
need to subclass Cassandra read site

00:29:15,809 --> 00:29:21,929
processor that's again a lagoon

00:29:18,380 --> 00:29:26,039
abstraction and what you will do in this

00:29:21,929 --> 00:29:28,049
class you will be consuming events that

00:29:26,039 --> 00:29:36,600
are produced by the persistent entity

00:29:28,049 --> 00:29:38,340
and you will update your tables right so

00:29:36,600 --> 00:29:40,350
we're really separating the right side

00:29:38,340 --> 00:29:43,440
from the right side there are two

00:29:40,350 --> 00:29:46,830
different things and the red side is

00:29:43,440 --> 00:29:49,350
really a view of the right side we can

00:29:46,830 --> 00:29:51,570
always change that view that's why there

00:29:49,350 --> 00:29:54,510
is no need for migration script if

00:29:51,570 --> 00:29:56,909
tomorrow we want to change the way we

00:29:54,510 --> 00:29:59,039
want to represent our information we

00:29:56,909 --> 00:30:00,830
only go and change the tables in the red

00:29:59,039 --> 00:30:03,750
in the Ritter in the right view our

00:30:00,830 --> 00:30:07,049
facts our events they're not going to

00:30:03,750 --> 00:30:09,600
change they're always the same and so

00:30:07,049 --> 00:30:11,909
you can really your view can be really

00:30:09,600 --> 00:30:14,880
highly optimized for let's say the

00:30:11,909 --> 00:30:19,530
screens if you're building a web app or

00:30:14,880 --> 00:30:26,840
whatever need for wagon for the way you

00:30:19,530 --> 00:30:29,059
want to consume your information so

00:30:26,840 --> 00:30:33,360
running in production

00:30:29,059 --> 00:30:36,080
Lagaan supports or integrates with SBT

00:30:33,360 --> 00:30:38,820
native packager so you can produce

00:30:36,080 --> 00:30:41,700
executive bill well you can produce the

00:30:38,820 --> 00:30:47,280
RPM docker images pretty much anything

00:30:41,700 --> 00:30:50,370
in one and it is integrated with a light

00:30:47,280 --> 00:30:52,350
band conductor so by that it doesn't

00:30:50,370 --> 00:30:54,840
mean that Lagoon knows anything about

00:30:52,350 --> 00:30:57,120
our conductor is the other way around

00:30:54,840 --> 00:31:00,270
conductor knows how to run logon

00:30:57,120 --> 00:31:02,159
services so it's really really easy to

00:31:00,270 --> 00:31:04,169
transition from the metalman to

00:31:02,159 --> 00:31:05,760
production because you don't have to do

00:31:04,169 --> 00:31:08,100
anything if you're using light bank

00:31:05,760 --> 00:31:10,080
conductor so like that conductor is

00:31:08,100 --> 00:31:13,169
actually available for free for

00:31:10,080 --> 00:31:15,750
development so I encourage you to try it

00:31:13,169 --> 00:31:19,850
out and see how it works it's all for

00:31:15,750 --> 00:31:23,370
free if you don't want to use conductor

00:31:19,850 --> 00:31:25,290
it's ok you can

00:31:23,370 --> 00:31:27,059
use utter orchestration tools we don't

00:31:25,290 --> 00:31:30,480
have support for that yet I've talked a

00:31:27,059 --> 00:31:32,460
bit about that in at the end but what

00:31:30,480 --> 00:31:34,670
you need to do is basically only provide

00:31:32,460 --> 00:31:37,380
an implementation of the service locator

00:31:34,670 --> 00:31:39,360
interface of Lagaan that's all it's

00:31:37,380 --> 00:31:41,340
needed

00:31:39,360 --> 00:31:45,180
there is the commendation for that and

00:31:41,340 --> 00:31:47,730
we actually already started a project or

00:31:45,180 --> 00:31:49,860
a new module for providing integration

00:31:47,730 --> 00:31:51,630
with kubernetes we're not actively

00:31:49,860 --> 00:31:53,850
working on it we hope that the community

00:31:51,630 --> 00:31:56,460
also can help us but we're definitely

00:31:53,850 --> 00:31:58,410
not against running like on services

00:31:56,460 --> 00:32:02,610
another orchestration tool actually

00:31:58,410 --> 00:32:05,700
would be quite cool a couple of things

00:32:02,610 --> 00:32:08,429
that you get by using conductor and the

00:32:05,700 --> 00:32:11,280
light band reactive platform is that you

00:32:08,429 --> 00:32:13,110
get monitoring support so I told you at

00:32:11,280 --> 00:32:15,570
the beginning that circuit breakers are

00:32:13,110 --> 00:32:17,820
building into the GaN and the monitoring

00:32:15,570 --> 00:32:20,250
that we have actually can show you the

00:32:17,820 --> 00:32:22,950
state of your circuit breakers so you

00:32:20,250 --> 00:32:25,080
can see whether let's say your service

00:32:22,950 --> 00:32:29,400
is being hammered so it's not ready to

00:32:25,080 --> 00:32:31,320
to to handle any any any other call any

00:32:29,400 --> 00:32:33,960
other requests so in that case you'll

00:32:31,320 --> 00:32:36,450
see that the circuit break the circuit

00:32:33,960 --> 00:32:40,170
breaker is closed otherwise you see that

00:32:36,450 --> 00:32:42,090
is open and we're going to be adding of

00:32:40,170 --> 00:32:45,630
course more and more things like you

00:32:42,090 --> 00:32:47,130
want to see our your futures we're going

00:32:45,630 --> 00:32:49,710
to add future support streaming support

00:32:47,130 --> 00:32:52,830
kind of seeing what's happening in each

00:32:49,710 --> 00:32:56,490
of your services and spray blame it's

00:32:52,830 --> 00:32:58,290
pretty split brain resolver is it's

00:32:56,490 --> 00:33:01,470
really important for handling Network

00:32:58,290 --> 00:33:04,410
partitions which again it's something

00:33:01,470 --> 00:33:06,030
that you you want to check when you want

00:33:04,410 --> 00:33:10,140
to when you're going to be running your

00:33:06,030 --> 00:33:11,760
services in production it's not it's not

00:33:10,140 --> 00:33:14,910
related to legume it's really a general

00:33:11,760 --> 00:33:18,330
thing what happens if there is a network

00:33:14,910 --> 00:33:21,120
partition in your cluster and if you're

00:33:18,330 --> 00:33:22,500
using light bank conductor you actually

00:33:21,120 --> 00:33:25,230
are ok with that there are strategies

00:33:22,500 --> 00:33:26,730
that we am we've implemented and this is

00:33:25,230 --> 00:33:29,220
what split brain resolve worries about

00:33:26,730 --> 00:33:32,610
you make sure that in case of a network

00:33:29,220 --> 00:33:34,950
partition the cluster will manage how to

00:33:32,610 --> 00:33:36,390
resolve the problem if you're not using

00:33:34,950 --> 00:33:39,870
light bag conductor then

00:33:36,390 --> 00:33:41,460
to be aware of this problem and see

00:33:39,870 --> 00:33:42,900
whether the orchestration tool the

00:33:41,460 --> 00:33:47,640
specific orchestration tool you are

00:33:42,900 --> 00:33:52,980
using can handle that so the current

00:33:47,640 --> 00:33:55,860
version of Lagaan is 1 0 m 2 1 0 final

00:33:52,980 --> 00:34:00,330
is coming soon what I show you before

00:33:55,860 --> 00:34:01,650
was using Scala with the Java API fact

00:34:00,330 --> 00:34:03,870
I'd like to hear what you guys think

00:34:01,650 --> 00:34:05,730
because I thought it was fairly dramatic

00:34:03,870 --> 00:34:07,350
like it would be hard to tell that I was

00:34:05,730 --> 00:34:11,880
using the Java API at least that's how I

00:34:07,350 --> 00:34:15,409
felt so my point is that you can use

00:34:11,880 --> 00:34:17,490
scarlet today with the Lagaan java api

00:34:15,409 --> 00:34:21,060
everything all the benefits of using

00:34:17,490 --> 00:34:23,520
Scala like keys classes it's huge like

00:34:21,060 --> 00:34:26,190
when I compare the sample application

00:34:23,520 --> 00:34:27,840
written in Scala and in Java there's

00:34:26,190 --> 00:34:32,850
just no question about which one I'd

00:34:27,840 --> 00:34:36,929
like to maintain and that is the link to

00:34:32,850 --> 00:34:39,000
the sample app written in Scala the

00:34:36,929 --> 00:34:41,340
scholar API will come we're working on

00:34:39,000 --> 00:34:47,580
it there are two people are working on

00:34:41,340 --> 00:34:49,110
it and at one of them so but I don't

00:34:47,580 --> 00:34:50,399
think that things will be completely

00:34:49,110 --> 00:34:54,750
different actually I think they'll be

00:34:50,399 --> 00:34:58,050
fairly similar at the end so in the

00:34:54,750 --> 00:35:00,900
future this is a list of things we would

00:34:58,050 --> 00:35:02,280
like to work on is not prioritized or

00:35:00,900 --> 00:35:04,920
anything it's actually sorted

00:35:02,280 --> 00:35:08,010
alphabetically so we're going to add

00:35:04,920 --> 00:35:09,990
maven support this is mostly for well I

00:35:08,010 --> 00:35:12,120
would say this is mainly for our Java

00:35:09,990 --> 00:35:14,760
user but I'm sure that many of you also

00:35:12,120 --> 00:35:17,910
are wouldn't mind having a a maven

00:35:14,760 --> 00:35:19,410
support in the enterprise message broker

00:35:17,910 --> 00:35:23,250
integration which is needed for

00:35:19,410 --> 00:35:25,770
decoupling your services Scalia P I

00:35:23,250 --> 00:35:27,720
already mentioned that support for adder

00:35:25,770 --> 00:35:30,540
orchestration tools I told you about

00:35:27,720 --> 00:35:32,310
that support for writing integration

00:35:30,540 --> 00:35:34,530
tests so that's actually something we

00:35:32,310 --> 00:35:37,970
would like to do what we would like to

00:35:34,530 --> 00:35:41,370
do is allow you to write your tests and

00:35:37,970 --> 00:35:43,440
somehow be able to run the Rhinos task

00:35:41,370 --> 00:35:44,730
in the background so that you can

00:35:43,440 --> 00:35:45,710
actually test against the real

00:35:44,730 --> 00:35:50,210
implementation

00:35:45,710 --> 00:35:55,369
your of your services and swagger

00:35:50,210 --> 00:35:59,450
integration which would be extremely nd4

00:35:55,369 --> 00:36:02,210
avoiding binary coupling so i told why

00:35:59,450 --> 00:36:04,369
why do i talk about binary couplings so

00:36:02,210 --> 00:36:06,800
what happens when I want a service to

00:36:04,369 --> 00:36:09,950
communicate with another service well at

00:36:06,800 --> 00:36:12,349
the moment my service project has to

00:36:09,950 --> 00:36:15,050
depend on a different service project

00:36:12,349 --> 00:36:17,980
right and what that means is that I'm

00:36:15,050 --> 00:36:21,020
actually narrating all the classpath of

00:36:17,980 --> 00:36:23,420
you know that micro service into my

00:36:21,020 --> 00:36:24,950
class but that is not good because we

00:36:23,420 --> 00:36:27,589
might be wanting to use different

00:36:24,950 --> 00:36:29,810
version of libraries and incompatible

00:36:27,589 --> 00:36:32,030
versions of libraries right so you don't

00:36:29,810 --> 00:36:33,800
want that by having swagger integration

00:36:32,030 --> 00:36:35,810
what we're going to be able to do is

00:36:33,800 --> 00:36:39,950
that you can actually generate this

00:36:35,810 --> 00:36:41,480
interface basically dynamically so that

00:36:39,950 --> 00:36:45,680
there is no coupling you're going to

00:36:41,480 --> 00:36:47,930
depend on a specification and then we'll

00:36:45,680 --> 00:36:50,570
generate those DUHS implementation for

00:36:47,930 --> 00:36:55,010
you so so you will get no coupling no

00:36:50,570 --> 00:36:58,510
binary coupling between your service so

00:36:55,010 --> 00:37:01,369
next steps try loggin gives us feedback

00:36:58,510 --> 00:37:04,430
it's definitely a great moment to

00:37:01,369 --> 00:37:07,880
provide feedback use this color wheel

00:37:04,430 --> 00:37:09,160
ago and follow that link it's a guitar

00:37:07,880 --> 00:37:12,650
project

00:37:09,160 --> 00:37:15,500
yonis poner book if you don't have it

00:37:12,650 --> 00:37:18,619
yet just come to our booth and you can

00:37:15,500 --> 00:37:20,750
pick a free copy and there is a really

00:37:18,619 --> 00:37:23,570
great presentation by greg young who is

00:37:20,750 --> 00:37:26,839
actually well the guy behind even

00:37:23,570 --> 00:37:29,480
sourcing about why even sourcing is is a

00:37:26,839 --> 00:37:31,820
great architectural pattern so I'd

00:37:29,480 --> 00:37:35,750
encourage you to listen to him if you're

00:37:31,820 --> 00:37:39,200
interested on the topic thanks everyone

00:37:35,750 --> 00:37:40,820
for your attention and you find if you

00:37:39,200 --> 00:37:43,300
have any questions I will be happy to

00:37:40,820 --> 00:37:43,300
answer them

00:37:49,430 --> 00:37:53,610
right so the question is about

00:37:51,420 --> 00:37:58,500
deployment support for legume services

00:37:53,610 --> 00:38:02,900
and so our orchestration tool light been

00:37:58,500 --> 00:38:06,690
legume it is a male for deployment and

00:38:02,900 --> 00:38:09,210
worried as BIA it has lots of feature

00:38:06,690 --> 00:38:11,700
and things that were working on is for

00:38:09,210 --> 00:38:16,890
rolling up great so that you basically

00:38:11,700 --> 00:38:18,930
never have to turn well ever how do you

00:38:16,890 --> 00:38:22,230
say like turn down the service because

00:38:18,930 --> 00:38:24,750
you you want to bring on a new version

00:38:22,230 --> 00:38:26,490
of that service it actually provides you

00:38:24,750 --> 00:38:29,060
a way for doing that smoothly so that

00:38:26,490 --> 00:38:33,660
you have no downtime when when upgrading

00:38:29,060 --> 00:38:36,420
and and publishing a new service so we

00:38:33,660 --> 00:38:39,510
don't have integration with Amazon what

00:38:36,420 --> 00:38:42,810
what are you you should consider adding

00:38:39,510 --> 00:38:46,260
a look at is our orchestration to light

00:38:42,810 --> 00:38:49,680
bed lagoon and if you don't want to use

00:38:46,260 --> 00:38:51,630
that as I said we we we are thinking of

00:38:49,680 --> 00:38:54,060
adding support for other orchestration

00:38:51,630 --> 00:38:57,960
tools but at the moment that's only

00:38:54,060 --> 00:39:01,890
really the one that we support it's a 1

00:38:57,960 --> 00:39:03,570
0 m2 as well so we had we had to focus

00:39:01,890 --> 00:39:05,160
on something and it made sense that the

00:39:03,570 --> 00:39:08,160
first thing we would support is what we

00:39:05,160 --> 00:39:10,770
produce but it's an open source project

00:39:08,160 --> 00:39:13,970
as well so we really intrude that the

00:39:10,770 --> 00:39:16,650
community will like what's in there and

00:39:13,970 --> 00:39:20,010
we'd be happy and thrilled to see

00:39:16,650 --> 00:39:22,560
contribution from the community right so

00:39:20,010 --> 00:39:24,860
the question is about our swagger

00:39:22,560 --> 00:39:28,500
integration will avoid binary coupling

00:39:24,860 --> 00:39:30,480
so at the moment we brought a document

00:39:28,500 --> 00:39:34,190
about that internally kind of getting a

00:39:30,480 --> 00:39:37,110
rough idea of how it's going to work but

00:39:34,190 --> 00:39:39,510
so if you look at how things are at the

00:39:37,110 --> 00:39:41,880
moment is you have this service

00:39:39,510 --> 00:39:44,280
interface where you provide a descriptor

00:39:41,880 --> 00:39:45,750
and it's all in code right and you're

00:39:44,280 --> 00:39:49,560
basically describing what are at the

00:39:45,750 --> 00:39:51,570
endpoints and then your you're also

00:39:49,560 --> 00:39:53,840
adding metadata about how these

00:39:51,570 --> 00:39:56,490
endpoints are going to be served right

00:39:53,840 --> 00:39:58,560
well what we want to do is instead of

00:39:56,490 --> 00:40:01,770
describing that in the code let's

00:39:58,560 --> 00:40:03,420
describe that using swagger and then

00:40:01,770 --> 00:40:04,740
from that we can generate the code for

00:40:03,420 --> 00:40:08,940
you but you don't have to know

00:40:04,740 --> 00:40:10,950
so that services will depart it will

00:40:08,940 --> 00:40:13,080
depend on this wagger specification and

00:40:10,950 --> 00:40:14,550
then on the fly we can well on the fly a

00:40:13,080 --> 00:40:16,470
compile time it doesn't really matter

00:40:14,550 --> 00:40:19,349
when we do it as long as you don't have

00:40:16,470 --> 00:40:22,500
like a binary dependency on on on the

00:40:19,349 --> 00:40:23,670
thing that we produced but is it does

00:40:22,500 --> 00:40:34,109
that answer

00:40:23,670 --> 00:40:36,690
oh no the problem with binary dependency

00:40:34,109 --> 00:40:38,730
is that so you have two micro services

00:40:36,690 --> 00:40:40,050
and one want to talk to the other so the

00:40:38,730 --> 00:40:43,589
problem at the moment is that in order

00:40:40,050 --> 00:40:46,980
to talk to service B I need to have in

00:40:43,589 --> 00:40:49,190
my class pad the service B API project

00:40:46,980 --> 00:40:51,390
the service B API project may have

00:40:49,190 --> 00:40:53,220
different things in this class but right

00:40:51,390 --> 00:40:54,960
and one of the principles of micro

00:40:53,220 --> 00:40:57,119
services is that they should really be

00:40:54,960 --> 00:40:59,490
the couple like I should be free of

00:40:57,119 --> 00:41:02,070
doing any change in my micro service

00:40:59,490 --> 00:41:06,119
because the only communication channel

00:41:02,070 --> 00:41:10,349
is my endpoints definition right that's

00:41:06,119 --> 00:41:13,050
the only way for you to get access or to

00:41:10,349 --> 00:41:15,660
get information about what I'm doing so

00:41:13,050 --> 00:41:18,089
I shouldn't be leaking implementation

00:41:15,660 --> 00:41:19,589
details and binaries our implementation

00:41:18,089 --> 00:41:21,720
details and so that's something we

00:41:19,589 --> 00:41:23,550
shouldn't want to make and that's why

00:41:21,720 --> 00:41:27,599
we're going to be working on swagger

00:41:23,550 --> 00:41:29,849
integration but you know it might be it

00:41:27,599 --> 00:41:33,990
really also depends on what you're doing

00:41:29,849 --> 00:41:35,670
it might be okay in within a company to

00:41:33,990 --> 00:41:38,339
say we're going to standardize no

00:41:35,670 --> 00:41:41,849
specific version of let's say juice

00:41:38,339 --> 00:41:43,530
other than different libraries and say

00:41:41,849 --> 00:41:46,140
this is actually the version that we're

00:41:43,530 --> 00:41:47,580
going to use across all our services and

00:41:46,140 --> 00:41:49,290
maybe in that case you don't need

00:41:47,580 --> 00:41:50,609
swagger integration you can just you

00:41:49,290 --> 00:41:52,349
know it's totally fine to have those

00:41:50,609 --> 00:41:55,109
binary dependencies because you decided

00:41:52,349 --> 00:41:56,730
to own and decide what version across

00:41:55,109 --> 00:41:59,099
all different services you're going to

00:41:56,730 --> 00:42:00,810
use so it's I would say it's an

00:41:59,099 --> 00:42:02,970
additional feature it doesn't mean that

00:42:00,810 --> 00:42:03,900
everyone will have to use that thanks

00:42:02,970 --> 00:42:05,960
again

00:42:03,900 --> 00:42:05,960

YouTube URL: https://www.youtube.com/watch?v=fRlx_fxar-U


