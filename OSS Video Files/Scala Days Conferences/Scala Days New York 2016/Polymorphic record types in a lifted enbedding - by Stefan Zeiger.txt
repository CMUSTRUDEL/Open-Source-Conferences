Title: Polymorphic record types in a lifted enbedding - by Stefan Zeiger
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
This talk gives an overview of the "lifted embedding" at the core of the Scala DSL in Slick, Lightbend's relational database library. With standard Scala language features we can provide a DSL that allows you to work with database tables using a syntax similar to Scala collections. Of particular interest are abstractions for record types, such as tuples. While earlier versions of Slick had to get by with custom types for all tuple sizes to represent flat tuples of individual columns, the "Shape" abstraction paved the way for using standard Scala tuples in the DSL, with arbitrary nesting. The same abstraction is used to support Slick's own HList implementation, and with only a few lines of code, your own custom record types or other HList implementations. The core language feature behind this design is called "functional dependencies". It was added to Scala in release 2.8 to be able to implement the "CanBuildFrom" abstraction in the new collections framework.
Captions: 
	00:00:06,220 --> 00:00:12,000
my name is Stefan and I work on the

00:00:09,900 --> 00:00:13,709
Scala team now and I used to be the

00:00:12,000 --> 00:00:15,240
creator of slick oh by the way don't

00:00:13,709 --> 00:00:17,400
forget to rate this

00:00:15,240 --> 00:00:20,580
that's why they had me put the slide

00:00:17,400 --> 00:00:23,010
here so I'm the original creator of

00:00:20,580 --> 00:00:24,630
slick or Scala query as it was called

00:00:23,010 --> 00:00:27,570
and nowadays I spend most of my time

00:00:24,630 --> 00:00:30,029
working on the scala team so I'm doing a

00:00:27,570 --> 00:00:33,200
talk in the intersection of slick and

00:00:30,029 --> 00:00:36,000
Scala so we're going to look at

00:00:33,200 --> 00:00:38,399
implementation details of slick but the

00:00:36,000 --> 00:00:41,370
technique I'm going to show is plain

00:00:38,399 --> 00:00:45,329
Scala stuff so you don't need any slick

00:00:41,370 --> 00:00:47,370
knowledge to follow this may be a show

00:00:45,329 --> 00:00:52,230
show of hands how many of you have used

00:00:47,370 --> 00:00:54,510
slick okay that's most but not all of

00:00:52,230 --> 00:00:58,890
you so for those who don't know what it

00:00:54,510 --> 00:01:01,890
is slick is the database library that we

00:00:58,890 --> 00:01:03,929
built at light Bend it's for relational

00:01:01,890 --> 00:01:06,810
databases and you write your data quiz

00:01:03,929 --> 00:01:10,860
based query in Scala like here using

00:01:06,810 --> 00:01:13,830
Scala collections so this Val queue here

00:01:10,860 --> 00:01:16,890
is a database query we have a user's

00:01:13,830 --> 00:01:19,050
table and we filter by ID less than 42

00:01:16,890 --> 00:01:22,530
and map to just the first name of the

00:01:19,050 --> 00:01:25,649
user and then you run this on a database

00:01:22,530 --> 00:01:28,079
you just say DB run and your query and

00:01:25,649 --> 00:01:30,509
of course the whole thing is statically

00:01:28,079 --> 00:01:36,780
typed so this result is actually of the

00:01:30,509 --> 00:01:39,030
tag future of vector of string so the

00:01:36,780 --> 00:01:40,710
way this works in slick is that you

00:01:39,030 --> 00:01:44,219
write the query in slicks

00:01:40,710 --> 00:01:46,340
lifted embedding Scala DSL we used to

00:01:44,219 --> 00:01:50,070
call it lifted embedding for a few years

00:01:46,340 --> 00:01:52,079
mostly because we also had a direct

00:01:50,070 --> 00:01:56,130
embedding which we now removed so it's

00:01:52,079 --> 00:01:59,159
just called the scala api these days but

00:01:56,130 --> 00:02:01,200
for the topic of this talk we'll call it

00:01:59,159 --> 00:02:03,930
the lifted embedding and this is just

00:02:01,200 --> 00:02:06,320
plain Scala code there are no macros no

00:02:03,930 --> 00:02:09,119
pre-processing managed magic or anything

00:02:06,320 --> 00:02:12,330
actually there are a few macros and

00:02:09,119 --> 00:02:14,700
slick but they're just syntactic sugar

00:02:12,330 --> 00:02:15,990
basically you don't really need them for

00:02:14,700 --> 00:02:20,100
anything and we're going to do without

00:02:15,990 --> 00:02:22,470
them today so the list of embedding that

00:02:20,100 --> 00:02:24,960
you write your code in then builds a

00:02:22,470 --> 00:02:27,110
slick AST so we don't have an

00:02:24,960 --> 00:02:29,630
interpreter or anything at

00:02:27,110 --> 00:02:31,820
directly to this embedding instead we

00:02:29,630 --> 00:02:33,920
first build an AST from the code that

00:02:31,820 --> 00:02:36,620
you write which is not a Scala ast it's

00:02:33,920 --> 00:02:40,280
a slick AST that we define ourselves and

00:02:36,620 --> 00:02:42,380
this reifies the computations so it just

00:02:40,280 --> 00:02:46,370
captures everything that you wrote in

00:02:42,380 --> 00:02:50,030
your query as close to the original

00:02:46,370 --> 00:02:54,650
query as possible and this ast is then

00:02:50,030 --> 00:02:57,560
compiled to an SQL statement a database

00:02:54,650 --> 00:03:00,440
specific one and the statement gets

00:02:57,560 --> 00:03:02,780
executed on a database usually by a JDBC

00:03:00,440 --> 00:03:06,080
and then your results are delivered

00:03:02,780 --> 00:03:11,000
asynchronously as a future or a reactive

00:03:06,080 --> 00:03:14,930
stream would we go to use today though

00:03:11,000 --> 00:03:17,300
is toy slick which I created from by

00:03:14,930 --> 00:03:20,239
starting with the real current slick

00:03:17,300 --> 00:03:24,020
master branch and removing everything

00:03:20,239 --> 00:03:26,600
that's not really needed so it cannot

00:03:24,020 --> 00:03:28,550
execute any queries there is no query

00:03:26,600 --> 00:03:31,400
compiler in there you can compile

00:03:28,550 --> 00:03:33,470
queries the ast is untyped

00:03:31,400 --> 00:03:35,000
usually the real slick ast captures some

00:03:33,470 --> 00:03:37,459
type information we don't need that

00:03:35,000 --> 00:03:40,820
there are no database specific profiles

00:03:37,459 --> 00:03:43,430
there are only very few operations there

00:03:40,820 --> 00:03:45,410
are no option types that's a very big

00:03:43,430 --> 00:03:47,630
change because option types usually

00:03:45,410 --> 00:03:52,040
complicate the slick lift and embedding

00:03:47,630 --> 00:03:53,860
and the slick compiler so we'll just

00:03:52,040 --> 00:03:56,450
leave them out to keep things simple

00:03:53,860 --> 00:03:58,610
there are no type constructors for query

00:03:56,450 --> 00:04:01,100
so everything collection valued is just

00:03:58,610 --> 00:04:02,989
called a seek and there are no shape

00:04:01,100 --> 00:04:05,000
levels in case you've seen them in the

00:04:02,989 --> 00:04:07,010
slick internal sometimes they pop up in

00:04:05,000 --> 00:04:09,980
error messages we don't need them either

00:04:07,010 --> 00:04:13,519
so all we're still going to do in toy

00:04:09,980 --> 00:04:16,070
slick is to take a lift is simplified

00:04:13,519 --> 00:04:21,410
lifted embedding and build a simplified

00:04:16,070 --> 00:04:25,250
AST from that so let's start with the

00:04:21,410 --> 00:04:27,350
ast the abstract syntax tree these are

00:04:25,250 --> 00:04:31,100
the operations that we need we have a

00:04:27,350 --> 00:04:35,180
basic trait node as a super type for all

00:04:31,100 --> 00:04:37,760
ast nodes and then we have a literal

00:04:35,180 --> 00:04:40,009
node which contains a literal value of

00:04:37,760 --> 00:04:42,439
whatever type that you put into the AST

00:04:40,009 --> 00:04:45,139
like the number 42 in the example that

00:04:42,439 --> 00:04:49,249
we saw and we have a product node which

00:04:45,139 --> 00:04:51,949
represents a product or tuple of

00:04:49,249 --> 00:04:53,930
individual expressions so so all the

00:04:51,949 --> 00:04:56,059
notes are expression C there are no non

00:04:53,930 --> 00:04:58,580
expression nodes in our simplified AST

00:04:56,059 --> 00:05:00,649
the product node is a product or couple

00:04:58,580 --> 00:05:03,409
of expressions we have a table node

00:05:00,649 --> 00:05:06,580
which represents a basic database table

00:05:03,409 --> 00:05:10,189
which is a collection value thing and

00:05:06,580 --> 00:05:14,689
for operations we have map and filter

00:05:10,189 --> 00:05:16,520
they act on queries the way these are

00:05:14,689 --> 00:05:19,159
implemented is that you get a symbol

00:05:16,520 --> 00:05:21,020
which in the case of toys Lake is just a

00:05:19,159 --> 00:05:25,370
wrapper for a name there's nothing else

00:05:21,020 --> 00:05:27,740
in it so you have a symbol and whatever

00:05:25,370 --> 00:05:30,439
it it starts with the source of the

00:05:27,740 --> 00:05:34,879
computation and then a select or where

00:05:30,439 --> 00:05:38,080
node in there which uses this symbol so

00:05:34,879 --> 00:05:41,240
we have no separate representation for

00:05:38,080 --> 00:05:43,309
lambdas they are just integrated into

00:05:41,240 --> 00:05:46,099
the map and filter node you'll see that

00:05:43,309 --> 00:05:48,409
in an example shortly and in order to

00:05:46,099 --> 00:05:52,389
refer to these symbols we need a ref

00:05:48,409 --> 00:05:56,029
node which just references a symbol and

00:05:52,389 --> 00:05:59,180
we also have a select operation that's

00:05:56,029 --> 00:06:02,599
like when you have an expression a dot B

00:05:59,180 --> 00:06:05,689
this would be a select or feel to be in

00:06:02,599 --> 00:06:08,919
a ref of a that's how you encode

00:06:05,689 --> 00:06:11,930
arbitrary paths in the query language

00:06:08,919 --> 00:06:14,749
and finally we have an apply operation

00:06:11,930 --> 00:06:17,089
which is used for all kinds of function

00:06:14,749 --> 00:06:18,620
application or operators like the less

00:06:17,089 --> 00:06:21,139
than operator that we saw that's

00:06:18,620 --> 00:06:22,849
implemented as an apply and which

00:06:21,139 --> 00:06:25,999
operator to apply in this case the less

00:06:22,849 --> 00:06:28,729
than is again encoded in a symbol and it

00:06:25,999 --> 00:06:31,580
just takes a number of child nodes which

00:06:28,729 --> 00:06:35,120
are the arguments so that's all for the

00:06:31,580 --> 00:06:39,019
ast here's an example again users start

00:06:35,120 --> 00:06:41,809
filter and then a dot map so the last

00:06:39,019 --> 00:06:47,899
thing that happens is a a map so we

00:06:41,809 --> 00:06:52,189
start with that and the map has a symbol

00:06:47,899 --> 00:06:53,750
you see that here it's from s2 that's

00:06:52,189 --> 00:06:57,560
the symbol that we generated

00:06:53,750 --> 00:07:02,480
so the select expression uses this

00:06:57,560 --> 00:07:05,360
symbol in a ref so we say the D lambda

00:07:02,480 --> 00:07:08,360
is basically in the in the Select closed

00:07:05,360 --> 00:07:11,270
on down here is basically s two two s

00:07:08,360 --> 00:07:14,420
two dot first we don't know that it was

00:07:11,270 --> 00:07:16,580
originally called you because we do not

00:07:14,420 --> 00:07:18,920
see those names they are lost there's no

00:07:16,580 --> 00:07:20,990
way that Scala gives us access to these

00:07:18,920 --> 00:07:24,350
original variable names without using

00:07:20,990 --> 00:07:27,110
macros or similar techniques so we have

00:07:24,350 --> 00:07:30,260
to generate new names and then in the

00:07:27,110 --> 00:07:32,390
from clause of this map we have the

00:07:30,260 --> 00:07:34,880
filter operation which looks similar we

00:07:32,390 --> 00:07:38,990
have a symbol s1 and we have an a where

00:07:34,880 --> 00:07:42,530
clause which encodes this s1 dot ID less

00:07:38,990 --> 00:07:49,580
than 42 and the from clause of the

00:07:42,530 --> 00:07:52,730
filter operation is the table users so

00:07:49,580 --> 00:07:55,640
now that we've seen the ast which is as

00:07:52,730 --> 00:07:57,260
simple as as I could make it for for

00:07:55,640 --> 00:08:00,680
tourists late let's look at lifted

00:07:57,260 --> 00:08:03,380
embedding so what does that mean lifted

00:08:00,680 --> 00:08:06,110
embedding well an embedding means that a

00:08:03,380 --> 00:08:08,780
query language is embedded in Scala

00:08:06,110 --> 00:08:12,919
so it's an internal DSL we're using a

00:08:08,780 --> 00:08:16,540
Scala library basically to embed another

00:08:12,919 --> 00:08:19,520
language the query language in Scala and

00:08:16,540 --> 00:08:23,690
lifted refers to the fact that any type

00:08:19,520 --> 00:08:25,790
T is lifted into a type wrap of T so

00:08:23,690 --> 00:08:28,580
whenever you think you seen an int or

00:08:25,790 --> 00:08:32,210
string in the query it's actually a rep

00:08:28,580 --> 00:08:34,159
event or a wrap of string so that

00:08:32,210 --> 00:08:36,500
already takes care of half of the title

00:08:34,159 --> 00:08:39,760
of this talk we'll get to the other half

00:08:36,500 --> 00:08:42,860
later so let's look at the lifted

00:08:39,760 --> 00:08:45,380
representation this wrap of T so here's

00:08:42,860 --> 00:08:48,380
the simplified version we need a basic

00:08:45,380 --> 00:08:50,810
operation to note because we want to

00:08:48,380 --> 00:08:53,240
build an ast from the lifted embedding

00:08:50,810 --> 00:08:57,470
so we have two node which gives us the

00:08:53,240 --> 00:08:59,950
sta representing this rep and then we

00:08:57,470 --> 00:09:03,820
have another operation which is in

00:08:59,950 --> 00:09:06,250
Grethe which takes a path it's called

00:09:03,820 --> 00:09:10,990
path yards a node it represents a path

00:09:06,250 --> 00:09:15,100
and we want this rep to stand for that

00:09:10,990 --> 00:09:17,620
path so the invariant here is that after

00:09:15,100 --> 00:09:20,620
you call in code ref on a path it gives

00:09:17,620 --> 00:09:22,870
you a new rep of T and when you call to

00:09:20,620 --> 00:09:25,330
note on that you get the original path

00:09:22,870 --> 00:09:28,470
back you've seen that in the previous

00:09:25,330 --> 00:09:31,150
example like this s 2 2 s 2 dot first

00:09:28,470 --> 00:09:33,580
whatever the object the rep in there was

00:09:31,150 --> 00:09:36,370
we need to tell that now your s 2

00:09:33,580 --> 00:09:40,030
because we want this s 2 dot first to

00:09:36,370 --> 00:09:42,730
come out when we call to ast on the

00:09:40,030 --> 00:09:45,190
right-hand side of the of the filter

00:09:42,730 --> 00:09:49,360
condition so we need to be able to

00:09:45,190 --> 00:09:51,370
encode something into the lap and down

00:09:49,360 --> 00:09:55,480
there in the object we have a way to

00:09:51,370 --> 00:09:57,520
create a very simple rep of T where we

00:09:55,480 --> 00:10:00,760
just pass the note directly and that's

00:09:57,520 --> 00:10:02,860
the intrinsic note of the ast and as

00:10:00,760 --> 00:10:05,920
soon as you call in code Ref this note

00:10:02,860 --> 00:10:07,630
is dropped and instead when you call to

00:10:05,920 --> 00:10:11,200
note you get out whatever you put in

00:10:07,630 --> 00:10:16,990
before this works for all primitive

00:10:11,200 --> 00:10:19,480
types so this in code ref here it

00:10:16,990 --> 00:10:23,080
returns a rep of T what we really mean

00:10:19,480 --> 00:10:25,930
is something more elaborate like this so

00:10:23,080 --> 00:10:30,070
we want to be able to return some type R

00:10:25,930 --> 00:10:32,680
which is a subtype of rep of T and R but

00:10:30,070 --> 00:10:35,440
this would make the types much more

00:10:32,680 --> 00:10:37,390
complicated and probably type inference

00:10:35,440 --> 00:10:38,980
would fail for this if we tried it but

00:10:37,390 --> 00:10:41,290
we have different ways to enforce this

00:10:38,980 --> 00:10:43,990
in variant so for now it's enough to

00:10:41,290 --> 00:10:47,110
know that we have to read encode into

00:10:43,990 --> 00:10:49,810
something that's like the original type

00:10:47,110 --> 00:10:52,060
for all primitive types it's enough to

00:10:49,810 --> 00:10:54,250
have the rep of T for other types we'll

00:10:52,060 --> 00:11:00,340
see that we need subtypes and we'll also

00:10:54,250 --> 00:11:03,040
see how we enforce this later so let's

00:11:00,340 --> 00:11:07,930
start with primitive values the simplest

00:11:03,040 --> 00:11:11,650
case we have a literal rep which takes a

00:11:07,930 --> 00:11:12,690
value of some arbitrary type T as long

00:11:11,650 --> 00:11:15,990
as we have it

00:11:12,690 --> 00:11:18,780
heiped type 40 and this literal rap of

00:11:15,990 --> 00:11:20,850
course extends rap of T the two note

00:11:18,780 --> 00:11:24,090
builds a literal note as you might

00:11:20,850 --> 00:11:26,100
expect and encode ref doesn't have to

00:11:24,090 --> 00:11:27,570
build another literal rap it just builds

00:11:26,100 --> 00:11:30,210
a rep of the new note

00:11:27,570 --> 00:11:32,730
new note because having a rep is enough

00:11:30,210 --> 00:11:34,500
in this case so what does this typed

00:11:32,730 --> 00:11:36,450
type mean and why is it called typed

00:11:34,500 --> 00:11:40,290
type is it's doubly typed

00:11:36,450 --> 00:11:43,500
well the real slick has a a class called

00:11:40,290 --> 00:11:45,840
type which represents a type and Slick's

00:11:43,500 --> 00:11:47,940
type system so that's different from a

00:11:45,840 --> 00:11:51,720
scholar type and then a sub type of this

00:11:47,940 --> 00:11:54,540
type is typed type of T which is also a

00:11:51,720 --> 00:11:56,820
scholar type so we carry the scholar

00:11:54,540 --> 00:12:00,840
type in the Schlichter this allows us to

00:11:56,820 --> 00:12:04,650
use this typed type as a context bound

00:12:00,840 --> 00:12:07,470
here so we can say we want any tea that

00:12:04,650 --> 00:12:10,890
has a typed type and those are exactly

00:12:07,470 --> 00:12:13,590
the types that can can be used in

00:12:10,890 --> 00:12:16,470
individual columns as primitive types in

00:12:13,590 --> 00:12:23,130
our toy slick this is boolean int and

00:12:16,470 --> 00:12:27,000
string and we want to be able to call

00:12:23,130 --> 00:12:29,490
methods on these reptile use you've seen

00:12:27,000 --> 00:12:33,030
something like underscored that ID less

00:12:29,490 --> 00:12:34,560
than 42 that's the less than is usually

00:12:33,030 --> 00:12:36,750
available on int we want it to be

00:12:34,560 --> 00:12:39,660
available on rep of int so we have

00:12:36,750 --> 00:12:42,270
extension methods so here are two simple

00:12:39,660 --> 00:12:44,850
ones less than and equals they're

00:12:42,270 --> 00:12:46,620
defined on everything that is a typed

00:12:44,850 --> 00:12:49,350
type so we don't restrict them to

00:12:46,620 --> 00:12:51,900
numeric types but the real slick has

00:12:49,350 --> 00:12:54,540
different classes of extension methods

00:12:51,900 --> 00:12:56,780
for numerix and for all types and for

00:12:54,540 --> 00:13:02,010
strings and boolean's and whatever and

00:12:56,780 --> 00:13:05,940
the way these work is that you take the

00:13:02,010 --> 00:13:10,860
original rep you take another rep and

00:13:05,940 --> 00:13:13,950
then you build a new rep in this case a

00:13:10,860 --> 00:13:17,100
rep of boolean which contains the ast to

00:13:13,950 --> 00:13:19,170
return so that's an apply because we

00:13:17,100 --> 00:13:22,800
have a function or operator application

00:13:19,170 --> 00:13:23,220
and the children are n dot - no dandy

00:13:22,800 --> 00:13:27,350
dot

00:13:23,220 --> 00:13:27,350
to know the two sides of the operator

00:13:28,579 --> 00:13:35,300
okay so we can write scalar computations

00:13:32,819 --> 00:13:41,220
now on primitive values and columns

00:13:35,300 --> 00:13:43,500
what about tables now a table is defined

00:13:41,220 --> 00:13:46,470
through an abstract class table of T

00:13:43,500 --> 00:13:48,480
which extends rep of T and in the

00:13:46,470 --> 00:13:52,560
example below you can see we have a a

00:13:48,480 --> 00:13:55,259
class users which extends table of tuple

00:13:52,560 --> 00:13:57,629
of int string and string now this is a

00:13:55,259 --> 00:14:01,079
case where just knowing that it's a rep

00:13:57,629 --> 00:14:03,930
of T is not enough anymore because we

00:14:01,079 --> 00:14:05,850
don't just want a rep of couple of in

00:14:03,930 --> 00:14:09,600
string and string we want to be able to

00:14:05,850 --> 00:14:12,899
say u dot ID or u dot first so we need

00:14:09,600 --> 00:14:15,180
to keep those column names available

00:14:12,899 --> 00:14:24,180
that means we need to know it's actually

00:14:15,180 --> 00:14:28,220
an instance of users and width we extend

00:14:24,180 --> 00:14:31,740
this table class and we add methods to

00:14:28,220 --> 00:14:35,699
it or we we add columns to it by calling

00:14:31,740 --> 00:14:38,519
a column method again it takes a a type

00:14:35,699 --> 00:14:41,550
which is a has a typed type evidence

00:14:38,519 --> 00:14:49,379
available so we restrict it to primitive

00:14:41,550 --> 00:14:52,259
types and it builds a select which is

00:14:49,379 --> 00:14:56,160
based on whatever the two node returns

00:14:52,259 --> 00:14:58,500
for the table and then we generate a

00:14:56,160 --> 00:15:00,720
symbol with the field name so if the

00:14:58,500 --> 00:15:06,089
table is currently tacked as s to and

00:15:00,720 --> 00:15:10,290
you call the column ID then you then the

00:15:06,089 --> 00:15:16,009
ast will say a s would say s 2 dot ID so

00:15:10,290 --> 00:15:16,009
that's a select or field ID in s 2

00:15:19,060 --> 00:15:25,900
so since we need to keep the real

00:15:23,070 --> 00:15:30,160
subtype of the table not just a rep of

00:15:25,900 --> 00:15:32,890
tea we need a way to rebuild this table

00:15:30,160 --> 00:15:35,410
instance in encode ref therefore it's

00:15:32,890 --> 00:15:38,170
not enough that we just give slick an

00:15:35,410 --> 00:15:40,180
instance of this table class we need to

00:15:38,170 --> 00:15:42,340
give it a constructor from which slick

00:15:40,180 --> 00:15:45,550
can build new instances of the table

00:15:42,340 --> 00:15:48,700
class that's what this tag is for so

00:15:45,550 --> 00:15:52,060
what you give slick when you want to

00:15:48,700 --> 00:15:55,180
build a table query the original users

00:15:52,060 --> 00:15:58,840
query that we started with is a function

00:15:55,180 --> 00:16:00,670
from attack to the user's table that's

00:15:58,840 --> 00:16:06,640
just a constructor of the user's table

00:16:00,670 --> 00:16:10,960
and the actual logic of encode ref and

00:16:06,640 --> 00:16:14,670
to to note is implemented in the tag so

00:16:10,960 --> 00:16:17,350
we this kind of goes goes recursively

00:16:14,670 --> 00:16:20,980
through the table and attack so that

00:16:17,350 --> 00:16:23,710
whenever we call encode ref on the table

00:16:20,980 --> 00:16:29,200
it's called encode ref on the table tag

00:16:23,710 --> 00:16:33,700
and this calls the original constructor

00:16:29,200 --> 00:16:38,500
again and initially we put in a tag that

00:16:33,700 --> 00:16:43,420
returns this note that we pass to to

00:16:38,500 --> 00:16:47,110
note so that's up here that's a table

00:16:43,420 --> 00:16:49,900
note so there's there's a an in string

00:16:47,110 --> 00:16:52,660
intrinsic table note inside a table but

00:16:49,900 --> 00:16:55,630
as soon as you encode some path into it

00:16:52,660 --> 00:16:59,010
then you get the path out just like you

00:16:55,630 --> 00:16:59,010
would for a standard rep

00:17:02,280 --> 00:17:09,720
so we got primitive values we got tables

00:17:05,420 --> 00:17:12,000
now we need tapas so what what are we

00:17:09,720 --> 00:17:14,339
going to do well we start with what I

00:17:12,000 --> 00:17:19,920
started with in Scala query when I

00:17:14,339 --> 00:17:21,630
created this back in 2008 2009 with the

00:17:19,920 --> 00:17:24,810
assumption that everything needs to be a

00:17:21,630 --> 00:17:27,089
rep of T so we need a lifted

00:17:24,810 --> 00:17:30,060
representation for a tuples some rep of

00:17:27,089 --> 00:17:33,350
T that stands for at a port so here's

00:17:30,060 --> 00:17:37,350
one example that's a rep topple - of

00:17:33,350 --> 00:17:39,510
course in Scala query I had them from 2

00:17:37,350 --> 00:17:44,460
to 20 - they're auto-generated from

00:17:39,510 --> 00:17:48,300
template and you use this by starting

00:17:44,460 --> 00:17:50,610
with any rep value that has a typed type

00:17:48,300 --> 00:17:53,610
so you can only put primitive values

00:17:50,610 --> 00:17:55,740
into one of these Scala query style

00:17:53,610 --> 00:17:59,580
projections and then you call this

00:17:55,740 --> 00:18:01,560
tilled method and this gives you a rep

00:17:59,580 --> 00:18:03,570
tuple - and then you call the tilled

00:18:01,560 --> 00:18:08,100
method on laptop of - and it gives you a

00:18:03,570 --> 00:18:10,140
rep top of 3 and so on and of course the

00:18:08,100 --> 00:18:12,960
to note gives you a product note as

00:18:10,140 --> 00:18:18,990
expected the encode ref builds another

00:18:12,960 --> 00:18:22,320
rep top of 2 also as expected so what we

00:18:18,990 --> 00:18:24,180
can do now is something like this we

00:18:22,320 --> 00:18:26,790
have a map call from you - you don't

00:18:24,180 --> 00:18:30,000
idea till you dot first tilt you dot

00:18:26,790 --> 00:18:32,130
last that's nice and gets the job done

00:18:30,000 --> 00:18:34,980
but it's not really what we want because

00:18:32,130 --> 00:18:37,760
I don't want users to learn this new

00:18:34,980 --> 00:18:41,070
syntax even though it's sort of elegant

00:18:37,760 --> 00:18:43,320
what I want to be able to ride is this I

00:18:41,070 --> 00:18:46,950
want to use real scholar tuples here

00:18:43,320 --> 00:18:49,020
because it's much easier to use and west

00:18:46,950 --> 00:18:51,180
up at scalloped tuples with primitive

00:18:49,020 --> 00:18:53,700
element types in them when I join two

00:18:51,180 --> 00:18:55,380
tables I don't want to take all the

00:18:53,700 --> 00:18:58,110
columns apart and then put them back

00:18:55,380 --> 00:19:00,870
into one single tuple like I had to do

00:18:58,110 --> 00:19:02,880
in Scala query I want to be able to put

00:19:00,870 --> 00:19:06,030
whole objects in there like the users

00:19:02,880 --> 00:19:08,820
row I put the whole row in there and au

00:19:06,030 --> 00:19:11,190
dot first and you don't last and if we

00:19:08,820 --> 00:19:15,300
can already put compound values like a

00:19:11,190 --> 00:19:15,930
table row inside of it why not another

00:19:15,300 --> 00:19:19,950
top

00:19:15,930 --> 00:19:22,620
so let's do nested tuples and if we can

00:19:19,950 --> 00:19:25,740
do nested tuples why stop there why not

00:19:22,620 --> 00:19:29,910
H lists H lists are just mr tuples as

00:19:25,740 --> 00:19:31,650
you learned from Daniels talk so what do

00:19:29,910 --> 00:19:35,270
all these things have in common though

00:19:31,650 --> 00:19:40,020
all these types that we see here well

00:19:35,270 --> 00:19:43,140
they are not a rep of T so we have to

00:19:40,020 --> 00:19:45,570
let go of this very basic assumption of

00:19:43,140 --> 00:19:48,300
the lifted embedding that every value

00:19:45,570 --> 00:19:52,740
that we work with has a type that is a

00:19:48,300 --> 00:19:55,800
rep of T what these types instead are is

00:19:52,740 --> 00:19:57,780
polymorphic record types so now we will

00:19:55,800 --> 00:20:02,250
define the second part of the the talks

00:19:57,780 --> 00:20:04,320
title so what is a record type it's a

00:20:02,250 --> 00:20:07,950
pretty common common term when working

00:20:04,320 --> 00:20:10,380
with database technology a record type

00:20:07,950 --> 00:20:14,700
has a fixed number of elements with a

00:20:10,380 --> 00:20:16,620
known type so these are ordered or named

00:20:14,700 --> 00:20:19,170
usually the definition is that they have

00:20:16,620 --> 00:20:20,700
names but when you have tuples the

00:20:19,170 --> 00:20:22,770
tupple elements have names that just

00:20:20,700 --> 00:20:26,130
underscore one underscore two and so on

00:20:22,770 --> 00:20:29,340
in Port the important fact is that it's

00:20:26,130 --> 00:20:32,820
a fixed number of elements and the types

00:20:29,340 --> 00:20:34,470
are also fixed and known H lists kind of

00:20:32,820 --> 00:20:37,020
fall under this definition even though

00:20:34,470 --> 00:20:39,480
they can reproduce represent values of

00:20:37,020 --> 00:20:41,910
arbitrary sizes because the size is

00:20:39,480 --> 00:20:45,450
still determined by the by the concrete

00:20:41,910 --> 00:20:47,910
type that's enough for us and

00:20:45,450 --> 00:20:50,100
polymorphic means that the abstract over

00:20:47,910 --> 00:20:52,860
element types the important bit here is

00:20:50,100 --> 00:20:55,740
that you can have the same record type

00:20:52,860 --> 00:20:58,470
to hold values of a primitive scalar

00:20:55,740 --> 00:21:00,870
type like int or string and of the

00:20:58,470 --> 00:21:05,670
corresponding Lifta type like wrap of

00:21:00,870 --> 00:21:07,830
int and rip off string so here are some

00:21:05,670 --> 00:21:08,340
examples of these polymorphic record

00:21:07,830 --> 00:21:10,980
types

00:21:08,340 --> 00:21:14,040
well tuples obviously you can have a

00:21:10,980 --> 00:21:16,440
tuple of in string and string and also a

00:21:14,040 --> 00:21:18,990
couple of wrap of int wrap of string and

00:21:16,440 --> 00:21:21,660
wrap of string and you can put something

00:21:18,990 --> 00:21:23,960
like a user's table in there as we see

00:21:21,660 --> 00:21:26,820
in the in the third example here and

00:21:23,960 --> 00:21:28,590
then there are other product like types

00:21:26,820 --> 00:21:30,020
they don't have to be actual sky

00:21:28,590 --> 00:21:32,730
products just something that's

00:21:30,020 --> 00:21:34,830
isomorphic to a table like this pair

00:21:32,730 --> 00:21:36,539
that's like it Apple - it's the same

00:21:34,830 --> 00:21:39,720
thing except it has a different name and

00:21:36,539 --> 00:21:42,650
we call the values V 1 and V 2 instead

00:21:39,720 --> 00:21:45,570
of underscore 1 and underscore 2 and

00:21:42,650 --> 00:21:48,360
since we can have nested tuples we can

00:21:45,570 --> 00:21:54,840
also allow H lists because they are

00:21:48,360 --> 00:21:57,690
isomorphic to less the tuples okay we

00:21:54,840 --> 00:22:00,720
need one basic prerequisite in order to

00:21:57,690 --> 00:22:02,370
be able to encode these polymorphic

00:22:00,720 --> 00:22:04,860
record types and that's functional

00:22:02,370 --> 00:22:06,570
dependencies now what are functional

00:22:04,860 --> 00:22:11,000
dependencies there are dependencies

00:22:06,570 --> 00:22:14,340
between type parameters we can use a

00:22:11,000 --> 00:22:16,830
technique to encode a function at the

00:22:14,340 --> 00:22:19,679
type level that translates from one type

00:22:16,830 --> 00:22:22,110
parameter to another and of course the

00:22:19,679 --> 00:22:26,220
mechanism we use for this as usual in

00:22:22,110 --> 00:22:29,789
Scala is implicit so let's start with a

00:22:26,220 --> 00:22:32,159
simple implicit example we have a

00:22:29,789 --> 00:22:35,640
function or method F with two type

00:22:32,159 --> 00:22:38,909
parameters t1 t2 it takes a value of

00:22:35,640 --> 00:22:42,510
type t1 and returns a value of type t2

00:22:38,909 --> 00:22:46,049
and it does that by calling a converter

00:22:42,510 --> 00:22:48,990
function and this converter function is

00:22:46,049 --> 00:22:51,690
an object convert of t1 and t2 and it's

00:22:48,990 --> 00:22:54,270
passed implicitly and we are three of

00:22:51,690 --> 00:22:58,080
them predefined from into long from long

00:22:54,270 --> 00:23:00,240
to string from string to end so if you

00:22:58,080 --> 00:23:05,669
look at the example at the bottom we

00:23:00,240 --> 00:23:09,360
have a a value of type int we put that

00:23:05,669 --> 00:23:13,590
in here so we get t1 it's now defined

00:23:09,360 --> 00:23:18,570
and we know that we have a long so we

00:23:13,590 --> 00:23:23,580
know t2 you know both of T's these types

00:23:18,570 --> 00:23:27,960
here so we go from int to long there's

00:23:23,580 --> 00:23:31,500
only one match and we put that in here

00:23:27,960 --> 00:23:32,909
and everything compiles right this

00:23:31,500 --> 00:23:37,039
doesn't need functional dependencies

00:23:32,909 --> 00:23:40,409
this is just basic implicit now the

00:23:37,039 --> 00:23:41,190
interesting part is I can remove all the

00:23:40,409 --> 00:23:45,330
type and

00:23:41,190 --> 00:23:46,560
down here and it still compiles that's

00:23:45,330 --> 00:23:49,590
where we need the functional

00:23:46,560 --> 00:23:56,130
dependencies for so what happens in this

00:23:49,590 --> 00:24:03,540
case well we start with an int so that's

00:23:56,130 --> 00:24:05,610
our t1 we know t1 isn't int okay but we

00:24:03,540 --> 00:24:08,340
do not know the result type of this

00:24:05,610 --> 00:24:10,980
computation this is undetermined it's

00:24:08,340 --> 00:24:14,340
just a vowel L whatever this this type

00:24:10,980 --> 00:24:16,140
will be eventually so let's mark this

00:24:14,340 --> 00:24:19,530
with an underscore because we don't know

00:24:16,140 --> 00:24:22,470
it yet we can still perform an implicit

00:24:19,530 --> 00:24:24,900
search from int to whatever because

00:24:22,470 --> 00:24:27,270
there's only one convert instance that

00:24:24,900 --> 00:24:29,310
starts with an int it's this one if we

00:24:27,270 --> 00:24:33,420
still find the right instance that's in

00:24:29,310 --> 00:24:35,880
too long and we put it down here and now

00:24:33,420 --> 00:24:40,560
the interesting part happens the type

00:24:35,880 --> 00:24:44,130
inference err now knows that t2 has to

00:24:40,560 --> 00:24:49,050
be long because it now has this

00:24:44,130 --> 00:24:55,230
information so we put the long back here

00:24:49,050 --> 00:24:58,020
and of course back here and this is the

00:24:55,230 --> 00:25:03,030
return type so now we know the return

00:24:58,020 --> 00:25:06,420
type is long and this Val L below is of

00:25:03,030 --> 00:25:10,920
type long and then when we do the next

00:25:06,420 --> 00:25:13,830
conversion we start with a long and we

00:25:10,920 --> 00:25:17,930
have a a converter from long to string

00:25:13,830 --> 00:25:21,180
so we now know that s is a string and

00:25:17,930 --> 00:25:24,990
finally we convert from string to int as

00:25:21,180 --> 00:25:28,920
before the types are determined through

00:25:24,990 --> 00:25:34,230
this convert type class and you can

00:25:28,920 --> 00:25:35,850
almost imagine these arrows here this is

00:25:34,230 --> 00:25:38,130
a function that we've written that

00:25:35,850 --> 00:25:40,230
translates from one type to another it

00:25:38,130 --> 00:25:45,750
translates from int to long from long to

00:25:40,230 --> 00:25:49,620
string and from string to int here's

00:25:45,750 --> 00:25:52,470
another example can build from in the

00:25:49,620 --> 00:25:54,040
Scala standard library this was actually

00:25:52,470 --> 00:25:55,630
the reason for adding five

00:25:54,040 --> 00:25:58,150
functional dependencies to Scala in the

00:25:55,630 --> 00:26:00,490
first place they were they were added in

00:25:58,150 --> 00:26:03,370
Scala 2.8 with the collections

00:26:00,490 --> 00:26:06,810
redesigned and this gave us can build

00:26:03,370 --> 00:26:10,480
from what this enables is to write

00:26:06,810 --> 00:26:12,700
implementations like map very high up in

00:26:10,480 --> 00:26:15,310
the collections hierarchy like here we

00:26:12,700 --> 00:26:17,110
see the class is traversable like which

00:26:15,310 --> 00:26:18,910
is way up in the collections hierarchy

00:26:17,110 --> 00:26:22,240
if you have something like a vector of

00:26:18,910 --> 00:26:26,020
int then this vector extends index seek

00:26:22,240 --> 00:26:28,960
extents seek extends while they serve it

00:26:26,020 --> 00:26:32,410
sends a mutable index extends immutable

00:26:28,960 --> 00:26:34,480
sig extends generic sig extends generic

00:26:32,410 --> 00:26:36,430
traversable extends generic traversable

00:26:34,480 --> 00:26:39,730
like that's that's pretty much how it

00:26:36,430 --> 00:26:42,280
goes and map is already defined up there

00:26:39,730 --> 00:26:44,320
in traversable like of implementations

00:26:42,280 --> 00:26:46,960
can still override it further down in

00:26:44,320 --> 00:26:49,390
the hierarchy but they don't have to

00:26:46,960 --> 00:26:52,480
it's only for performance but still this

00:26:49,390 --> 00:26:54,610
map needs to build an instance of the

00:26:52,480 --> 00:26:57,280
right collection usually the one you put

00:26:54,610 --> 00:26:59,110
in if you have a vector you want and you

00:26:57,280 --> 00:27:02,020
call map on it you want to get another

00:26:59,110 --> 00:27:05,110
vector out of that so that's what you

00:27:02,020 --> 00:27:08,500
use can build from for so you can see

00:27:05,110 --> 00:27:10,240
this type a you know vector of in the

00:27:08,500 --> 00:27:13,750
example that would be Internet's the

00:27:10,240 --> 00:27:15,940
element type and rapper that's the

00:27:13,750 --> 00:27:20,020
actual subtype so this would be vector

00:27:15,940 --> 00:27:24,310
of int and then we look for a in in map

00:27:20,020 --> 00:27:29,350
we look for a can built from from rapper

00:27:24,310 --> 00:27:30,760
of int and B which is what the mapping

00:27:29,350 --> 00:27:33,610
function returns so if you have a

00:27:30,760 --> 00:27:37,120
function from inch to string we look for

00:27:33,610 --> 00:27:39,430
it can build from of vector of int comma

00:27:37,120 --> 00:27:41,470
string comma whatever and this whatever

00:27:39,430 --> 00:27:43,200
is the return type and there are

00:27:41,470 --> 00:27:47,080
implicit in the collections

00:27:43,200 --> 00:27:50,050
implementation which define these return

00:27:47,080 --> 00:27:53,950
types in a very elaborate and easy to

00:27:50,050 --> 00:27:57,250
break way it allows some neat tricks

00:27:53,950 --> 00:27:59,530
like when you have a bit set which is a

00:27:57,250 --> 00:28:03,010
specialized set implementation that only

00:27:59,530 --> 00:28:05,500
works on integer values and you have a

00:28:03,010 --> 00:28:06,460
map call on that which produces another

00:28:05,500 --> 00:28:07,990
integer you

00:28:06,460 --> 00:28:10,780
get a bit set out of that and it

00:28:07,990 --> 00:28:14,170
statically typed as a bit set if you

00:28:10,780 --> 00:28:16,810
provided a map a function that converts

00:28:14,170 --> 00:28:19,180
the integer to a string you get some

00:28:16,810 --> 00:28:21,250
generic hash set out of it and that's

00:28:19,180 --> 00:28:29,080
encoded through these functional

00:28:21,250 --> 00:28:31,060
dependencies why I can build from so

00:28:29,080 --> 00:28:34,120
let's see how we can use that in our

00:28:31,060 --> 00:28:39,130
lifted embedding and the types there the

00:28:34,120 --> 00:28:41,410
type there is called shape every value

00:28:39,130 --> 00:28:43,810
our expression our lifted embedding

00:28:41,410 --> 00:28:48,070
which does no longer have to be a rep of

00:28:43,810 --> 00:28:51,100
T now needs to have an implicit shape

00:28:48,070 --> 00:28:55,120
available so instead of hard-coding a

00:28:51,100 --> 00:28:59,280
rep of t eventually produces a value of

00:28:55,120 --> 00:29:02,320
type t we now say a mixed type

00:28:59,280 --> 00:29:05,350
eventually produces an unpacked type

00:29:02,320 --> 00:29:10,030
provided there is an implicit shape from

00:29:05,350 --> 00:29:12,220
mixed to unpacked available and the

00:29:10,030 --> 00:29:14,800
lookup is always done by this mixed type

00:29:12,220 --> 00:29:17,020
the shapes are the implicit shapes are

00:29:14,800 --> 00:29:19,060
defined uniquely by the mixed type so

00:29:17,020 --> 00:29:20,980
when all you know is the next time you

00:29:19,060 --> 00:29:23,740
can still look up the correct shape and

00:29:20,980 --> 00:29:27,100
you will get the unpacked type and also

00:29:23,740 --> 00:29:29,920
the packed type automatically the unpack

00:29:27,100 --> 00:29:32,800
type is the same as in rep of T goes to

00:29:29,920 --> 00:29:35,080
T that's just the T what you get out

00:29:32,800 --> 00:29:37,990
when you run this thing the packed type

00:29:35,080 --> 00:29:41,260
is basically the reverse of that so it

00:29:37,990 --> 00:29:44,050
has reps everywhere so if you start with

00:29:41,260 --> 00:29:47,050
an int you go to a wrap event if you

00:29:44,050 --> 00:29:52,870
look at the packed type you'll see why

00:29:47,050 --> 00:29:56,680
we need that a bit later so let's start

00:29:52,870 --> 00:29:58,930
with the primitive shapes well we want

00:29:56,680 --> 00:30:02,320
every value to have a shape so for

00:29:58,930 --> 00:30:05,230
example there's a implicit and implicit

00:30:02,320 --> 00:30:08,230
death primitive shape which works for

00:30:05,230 --> 00:30:11,140
any type T which is primitive so it has

00:30:08,230 --> 00:30:14,860
a typed type in our case in string and

00:30:11,140 --> 00:30:19,740
boolean and this gives us a shape of T

00:30:14,860 --> 00:30:23,370
comma T comma wrap of T so we start with

00:30:19,740 --> 00:30:26,130
an INT and this unpacks tuning which it

00:30:23,370 --> 00:30:29,520
already is and it packs to a rep of int

00:30:26,130 --> 00:30:31,919
and we also have a column shape which is

00:30:29,520 --> 00:30:36,870
very similar because it also requires a

00:30:31,919 --> 00:30:40,230
typed type T but it gives us a shape for

00:30:36,870 --> 00:30:44,309
a rep of T which unpacks tweety and

00:30:40,230 --> 00:30:48,059
factory rep of T and we have a table

00:30:44,309 --> 00:30:51,720
shape which is available for every type

00:30:48,059 --> 00:30:54,659
c which is a subtype of table and it

00:30:51,720 --> 00:31:00,419
gives us a shape for see which unpacks

00:30:54,659 --> 00:31:02,549
to T and pax to see this implicit here

00:31:00,419 --> 00:31:05,520
that's to overcome a limitation of the

00:31:02,549 --> 00:31:08,730
type in furniture because we we need AC

00:31:05,520 --> 00:31:10,799
which is a subtype of table of T and

00:31:08,730 --> 00:31:17,789
this is a neat little trick to get both

00:31:10,799 --> 00:31:19,320
both of them inferred correctly so what

00:31:17,789 --> 00:31:22,049
do we do about tuples

00:31:19,320 --> 00:31:28,500
well obviously we need to provide a

00:31:22,049 --> 00:31:31,500
shape for them so we have a tuple to

00:31:28,500 --> 00:31:33,390
shape and again these are generated in

00:31:31,500 --> 00:31:35,309
the toy slick project you can actually

00:31:33,390 --> 00:31:38,640
see the expanded versions but in the

00:31:35,309 --> 00:31:42,870
real slick they are generated by a free

00:31:38,640 --> 00:31:45,870
market template so tuple to shape gives

00:31:42,870 --> 00:31:49,740
us a shape for a table let's see how

00:31:45,870 --> 00:31:51,990
this is used in implicit search above

00:31:49,740 --> 00:31:55,649
here you see an example of a map call

00:31:51,990 --> 00:31:58,070
and map requires an implicit shape for

00:31:55,649 --> 00:32:01,950
the return type so in this case it's

00:31:58,070 --> 00:32:05,100
equivalent to saying implicitly of shape

00:32:01,950 --> 00:32:08,940
of tuple of wrap of string and int and

00:32:05,100 --> 00:32:12,809
the other two types are undetermined so

00:32:08,940 --> 00:32:18,620
we know that we need a shape for a tuple

00:32:12,809 --> 00:32:22,460
too and we get this from top of to shape

00:32:18,620 --> 00:32:26,190
alright this is the top of to and then

00:32:22,460 --> 00:32:29,490
tap to shape says I can only give you a

00:32:26,190 --> 00:32:32,370
shape for a tuple two of M 1 and M 2 if

00:32:29,490 --> 00:32:32,730
you already have a shape for M 1 and a

00:32:32,370 --> 00:32:37,410
shave

00:32:32,730 --> 00:32:39,750
for m2 so m1 is rep of string so we have

00:32:37,410 --> 00:32:44,460
to go to column shape and look this up

00:32:39,750 --> 00:32:47,309
because this gives us a shape for rep of

00:32:44,460 --> 00:32:49,980
string and for M two we have to go to

00:32:47,309 --> 00:32:53,490
primitive shape which gives us a shape

00:32:49,980 --> 00:32:57,000
of int and because of functional

00:32:53,490 --> 00:32:59,880
dependencies then the unpacked and

00:32:57,000 --> 00:33:02,370
packed types flow back up in this

00:32:59,880 --> 00:33:07,860
implicit search so we now know these

00:33:02,370 --> 00:33:12,299
types here and these types and they flow

00:33:07,860 --> 00:33:16,500
back up and back up so we can now

00:33:12,299 --> 00:33:19,770
determine the unpacked and packed types

00:33:16,500 --> 00:33:23,340
for the whole shape it's done in a

00:33:19,770 --> 00:33:26,220
recursive way so this also means of

00:33:23,340 --> 00:33:29,190
course that if you have nest the tuples

00:33:26,220 --> 00:33:31,679
it just works automatically you have a

00:33:29,190 --> 00:33:34,500
recursive definition as long as they

00:33:31,679 --> 00:33:36,540
have a shape for something it works even

00:33:34,500 --> 00:33:41,340
if that nested shape is again a topple

00:33:36,540 --> 00:33:44,220
shape so here we have a tuple 2 which is

00:33:41,340 --> 00:33:49,140
this thing so we need a tuple to shape

00:33:44,220 --> 00:33:51,870
and then the first side is a rep of

00:33:49,140 --> 00:33:59,190
string the second one is another tuple -

00:33:51,870 --> 00:34:03,600
and of course that means we go back to

00:33:59,190 --> 00:34:07,110
topple to shape and again when you go

00:34:03,600 --> 00:34:09,179
down in the implicit search you are you

00:34:07,110 --> 00:34:11,730
take the mixed types apart and find

00:34:09,179 --> 00:34:14,220
shapes for them which determine the

00:34:11,730 --> 00:34:15,899
unpacked and the pack types and they all

00:34:14,220 --> 00:34:18,590
flow back up in implicit search

00:34:15,899 --> 00:34:18,590
recursively

00:34:20,960 --> 00:34:25,820
okay that's for the types now what do we

00:34:24,150 --> 00:34:28,560
do about the implementation

00:34:25,820 --> 00:34:31,380
well since shapes are supposed to

00:34:28,560 --> 00:34:33,300
replace the requirement of having a rep

00:34:31,380 --> 00:34:36,540
of T they need to do kind of the same

00:34:33,300 --> 00:34:39,420
thing so a shape needs a to note and an

00:34:36,540 --> 00:34:43,050
encode ref implementation of course for

00:34:39,420 --> 00:34:45,450
a shape these two now take values two

00:34:43,050 --> 00:34:48,030
because a shape does not represent a

00:34:45,450 --> 00:34:50,430
specific value it only represents a type

00:34:48,030 --> 00:34:52,530
so we now need to combine it with the

00:34:50,430 --> 00:34:56,040
value which is an instance of the mixed

00:34:52,530 --> 00:35:00,180
type and then we have two methods pack

00:34:56,040 --> 00:35:02,370
and pack shape so pack takes an instance

00:35:00,180 --> 00:35:05,910
of the mixed type and produces the

00:35:02,370 --> 00:35:08,340
packed type and pack shape gives us the

00:35:05,910 --> 00:35:13,200
matching shape for that again we'll see

00:35:08,340 --> 00:35:14,820
why we need that a bit later here's the

00:35:13,200 --> 00:35:19,950
most straightforward shape

00:35:14,820 --> 00:35:22,140
implementation that's rep shape we use

00:35:19,950 --> 00:35:24,960
that for anything that used to be a rep

00:35:22,140 --> 00:35:27,420
of T and now needs a shape like the

00:35:24,960 --> 00:35:29,610
implicit column shape and the implicit

00:35:27,420 --> 00:35:33,840
table T they both just delegate to

00:35:29,610 --> 00:35:37,110
replicate now what rep shape requires is

00:35:33,840 --> 00:35:40,350
that we have a type which is both the

00:35:37,110 --> 00:35:44,790
mixed and the packed type and this must

00:35:40,350 --> 00:35:48,510
be a rep type and then we can get a

00:35:44,790 --> 00:35:50,640
shape of MP comma u comma MP and of

00:35:48,510 --> 00:35:53,040
course to note an encode ref just

00:35:50,640 --> 00:35:55,680
delegate to the matching methods in the

00:35:53,040 --> 00:35:58,020
wrap and pack and pack shape our

00:35:55,680 --> 00:36:01,110
identity operations because the shape is

00:35:58,020 --> 00:36:05,730
already packed the mix and packed type

00:36:01,110 --> 00:36:07,830
are the same for primitive shape we need

00:36:05,730 --> 00:36:10,500
a different implementation if we have a

00:36:07,830 --> 00:36:14,910
primitive value like 42 we need a shape

00:36:10,500 --> 00:36:19,950
for that so we want a shape with a mixed

00:36:14,910 --> 00:36:23,900
type T and if we pack that we get a

00:36:19,950 --> 00:36:26,400
literal rep because we need a rep of T

00:36:23,900 --> 00:36:28,230
so we use the literal rep and the pack

00:36:26,400 --> 00:36:29,630
shape is of course the rep shape for

00:36:28,230 --> 00:36:34,170
that because it's a wrap

00:36:29,630 --> 00:36:34,650
the to note we go the easy route thereby

00:36:34,170 --> 00:36:36,330
just

00:36:34,650 --> 00:36:39,980
children calling to note on the package

00:36:36,330 --> 00:36:43,440
version because that has to be the same

00:36:39,980 --> 00:36:46,160
but encode ref unfortunately is a bit of

00:36:43,440 --> 00:36:49,530
a problem we have to throw an exception

00:36:46,160 --> 00:36:53,040
because if you remember the invariant

00:36:49,530 --> 00:36:56,100
from rap of T if you encode a path with

00:36:53,040 --> 00:36:59,820
encode ref and then call to note it has

00:36:56,100 --> 00:37:03,420
to return that path but this value B

00:36:59,820 --> 00:37:05,370
here this could be an int or string you

00:37:03,420 --> 00:37:07,740
can encode anything into an int or a

00:37:05,370 --> 00:37:09,480
string there's just no way to implement

00:37:07,740 --> 00:37:12,570
encode rest so we have to throw an

00:37:09,480 --> 00:37:18,180
exception and this will probably create

00:37:12,570 --> 00:37:19,980
a problem later on so let's move on to

00:37:18,180 --> 00:37:21,900
queries we haven't looked at collection

00:37:19,980 --> 00:37:26,880
valued stuff at all we've only deal

00:37:21,900 --> 00:37:29,010
dealt with scalar computation so far for

00:37:26,880 --> 00:37:31,200
queries which should really be called

00:37:29,010 --> 00:37:33,630
views because anything can be a query

00:37:31,200 --> 00:37:37,860
but here's query specifically means a

00:37:33,630 --> 00:37:40,650
collection valued query so a query is a

00:37:37,860 --> 00:37:44,100
rep of seek of you it's collection

00:37:40,650 --> 00:37:47,280
valued and the query takes two type

00:37:44,100 --> 00:37:49,170
parameters e is the so-called mixed type

00:37:47,280 --> 00:37:52,190
from the shape and you is the unpacked

00:37:49,170 --> 00:37:56,550
time we encode both of them in the query

00:37:52,190 --> 00:37:58,470
to work around a limitation that Scala

00:37:56,550 --> 00:38:03,270
once had we could probably get rid of

00:37:58,470 --> 00:38:06,390
that in Scala 211 and higher so the to

00:38:03,270 --> 00:38:09,720
note is just a note that we pass in and

00:38:06,390 --> 00:38:13,230
we also have a shaped value that's just

00:38:09,720 --> 00:38:16,080
a shape plus its value combined for

00:38:13,230 --> 00:38:20,010
convenience and again you see the two

00:38:16,080 --> 00:38:22,230
types here it's the element type or

00:38:20,010 --> 00:38:25,410
mixed type and the unpacked type that

00:38:22,230 --> 00:38:29,790
you get when you run this query in code

00:38:25,410 --> 00:38:34,350
ref just returns a new query with the

00:38:29,790 --> 00:38:36,810
new path and the old shaped value and we

00:38:34,350 --> 00:38:40,020
want to create an initial query from a

00:38:36,810 --> 00:38:44,010
table so that's what table query does we

00:38:40,020 --> 00:38:47,010
give it a class that subclasses table

00:38:44,010 --> 00:38:48,080
and the constructor for that and it

00:38:47,010 --> 00:38:53,190
gives us a

00:38:48,080 --> 00:38:54,810
for this table which just calls to note

00:38:53,190 --> 00:38:56,580
so we get the table no doubt of it

00:38:54,810 --> 00:39:02,430
initially that's what we've seen in the

00:38:56,580 --> 00:39:04,590
ast so how do we implement some methods

00:39:02,430 --> 00:39:06,480
on this some operations we only have two

00:39:04,590 --> 00:39:09,110
operations in choice liquid or definer

00:39:06,480 --> 00:39:11,430
queries and that's map and filter

00:39:09,110 --> 00:39:13,410
otherwise there wouldn't be any

00:39:11,430 --> 00:39:15,750
interesting examples to ride without at

00:39:13,410 --> 00:39:18,300
least map and filter so the simple one

00:39:15,750 --> 00:39:22,050
is filter usually on a collection a

00:39:18,300 --> 00:39:24,750
filter method takes a function from E to

00:39:22,050 --> 00:39:26,820
boolean from the element type to boolean

00:39:24,750 --> 00:39:28,890
since we're in the lifted embedding here

00:39:26,820 --> 00:39:31,590
we take a function from E to F of

00:39:28,890 --> 00:39:33,390
boolean instead we don't need a shape

00:39:31,590 --> 00:39:36,300
here we can say web of boolean because

00:39:33,390 --> 00:39:38,550
for primitive values we can always

00:39:36,300 --> 00:39:40,260
assume a rep otherwise a literal can

00:39:38,550 --> 00:39:44,250
just be converted that's okay

00:39:40,260 --> 00:39:46,290
and from a query of e comma u this

00:39:44,250 --> 00:39:48,330
produces another query of eco menu it

00:39:46,290 --> 00:39:52,740
doesn't change the type so how do we

00:39:48,330 --> 00:39:58,070
implement it well we know that we want a

00:39:52,740 --> 00:40:01,170
type and that we want an expression that

00:39:58,070 --> 00:40:04,380
acts we want a symbol and expression

00:40:01,170 --> 00:40:07,110
that acts on this symbol so we create a

00:40:04,380 --> 00:40:11,670
fresh symbol that's the s9 in our

00:40:07,110 --> 00:40:15,270
example here and then we call we encode

00:40:11,670 --> 00:40:19,280
this symbol as a ref ref to the symbol

00:40:15,270 --> 00:40:22,280
we encode this into the shaped value

00:40:19,280 --> 00:40:28,860
call the user-supplied function on it

00:40:22,280 --> 00:40:34,040
and that gives us a new value that can

00:40:28,860 --> 00:40:34,040
produce the note for this rare condition

00:40:34,220 --> 00:40:42,800
the query gets a filter node so if we

00:40:39,870 --> 00:40:47,450
eventually get the filter out in the AST

00:40:42,800 --> 00:40:50,820
we see the symbol this is this one here

00:40:47,450 --> 00:40:55,740
the from clause is to note so that's the

00:40:50,820 --> 00:40:59,700
table query and then this is the where

00:40:55,740 --> 00:41:04,320
condition which references

00:40:59,700 --> 00:41:10,050
because we encoded that into the

00:41:04,320 --> 00:41:15,540
original value here so that's how filter

00:41:10,050 --> 00:41:18,180
works and if we look at map it's

00:41:15,540 --> 00:41:20,910
actually quite similar this is a naive

00:41:18,180 --> 00:41:24,300
implementation of map which still has

00:41:20,910 --> 00:41:27,030
one small problem but the basics are

00:41:24,300 --> 00:41:30,510
similar to filter so we take a function

00:41:27,030 --> 00:41:32,849
from E to F in this case the F could be

00:41:30,510 --> 00:41:37,290
anything so we really need a shape for

00:41:32,849 --> 00:41:40,950
that so we need a shape of F and we also

00:41:37,290 --> 00:41:45,390
need a new unpacked type T and we return

00:41:40,950 --> 00:41:52,050
a query of F and T again we create a

00:41:45,390 --> 00:41:54,930
first symbol which goes down here we put

00:41:52,050 --> 00:42:00,450
the original to note in here for the

00:41:54,930 --> 00:42:04,140
table users we encode the ref into the

00:42:00,450 --> 00:42:07,680
original shaped value we call the users

00:42:04,140 --> 00:42:09,630
applied function but now the return type

00:42:07,680 --> 00:42:11,400
that the return value of this user

00:42:09,630 --> 00:42:13,800
supplied function that's what we have to

00:42:11,400 --> 00:42:16,650
put into the new query this determines

00:42:13,800 --> 00:42:18,839
the new type and a new shaped value

00:42:16,650 --> 00:42:22,440
which is a prototype value that we need

00:42:18,839 --> 00:42:26,430
to keep around so we packed those up as

00:42:22,440 --> 00:42:30,900
a shaped value if we use the car a

00:42:26,430 --> 00:42:34,050
computed value and shape is the shape we

00:42:30,900 --> 00:42:37,410
got for it and we put that into the new

00:42:34,050 --> 00:42:40,680
query so far so good and our example

00:42:37,410 --> 00:42:44,520
works perfectly we can write a map that

00:42:40,680 --> 00:42:50,099
takes you and maps that to a tuple of U

00:42:44,520 --> 00:42:52,740
dot first and 42 so where's the problem

00:42:50,099 --> 00:42:56,210
of this well look at this slightly more

00:42:52,740 --> 00:42:57,690
complicated example we have one map call

00:42:56,210 --> 00:43:01,140
that map's

00:42:57,690 --> 00:43:04,800
the users row u to couple of u dot first

00:43:01,140 --> 00:43:07,880
comma 42 and another map call which just

00:43:04,800 --> 00:43:10,890
takes this tuple to that we produced and

00:43:07,880 --> 00:43:12,480
maps it to its first part and second

00:43:10,890 --> 00:43:13,029
part I could also have written map

00:43:12,480 --> 00:43:14,890
identity

00:43:13,029 --> 00:43:17,949
it's the same thing as far as slick as

00:43:14,890 --> 00:43:20,469
concerned because we only see the past

00:43:17,949 --> 00:43:25,179
individual elements but where's the

00:43:20,469 --> 00:43:28,419
problem here well this thing is an

00:43:25,179 --> 00:43:32,969
internet it's not a rap oven it's an int

00:43:28,419 --> 00:43:36,789
so this would also have to be an int and

00:43:32,969 --> 00:43:40,469
in order to run map we have to take our

00:43:36,789 --> 00:43:45,459
shaped value and encode the path into it

00:43:40,469 --> 00:43:47,380
so we call encode breath and we're back

00:43:45,459 --> 00:43:50,529
in primitive shape and it blows up

00:43:47,380 --> 00:43:55,059
because we cannot encode the ref into an

00:43:50,529 --> 00:43:58,869
int value and that's what we need the

00:43:55,059 --> 00:44:00,849
packed type for we could encode it into

00:43:58,869 --> 00:44:03,179
a wrap of int which is the packed type

00:44:00,849 --> 00:44:07,929
of int so that's what we're going to do

00:44:03,179 --> 00:44:11,469
in the real map implementation will also

00:44:07,929 --> 00:44:14,949
require will also collect the packed

00:44:11,469 --> 00:44:18,549
time we will call it G and instead of

00:44:14,949 --> 00:44:21,880
returning a query of F comma T where we

00:44:18,549 --> 00:44:25,299
turn a query of G comma T the packed

00:44:21,880 --> 00:44:29,429
type and we get the value by just

00:44:25,299 --> 00:44:34,630
calling packed value on the shape value

00:44:29,429 --> 00:44:37,509
so now if we run this we get a wrap-up

00:44:34,630 --> 00:44:40,150
end so every collection operation that

00:44:37,509 --> 00:44:44,289
that produces some new values inside

00:44:40,150 --> 00:44:46,809
like like map or flat map has to pack

00:44:44,289 --> 00:44:48,969
the result in the end so that you can

00:44:46,809 --> 00:44:51,819
use it to encode something else into

00:44:48,969 --> 00:44:53,769
this result this also gives us a more

00:44:51,819 --> 00:44:57,039
precise definition for what this packed

00:44:53,769 --> 00:44:59,769
type is previously I have called it a

00:44:57,039 --> 00:45:02,349
type that has reps everywhere what we

00:44:59,769 --> 00:45:05,169
actually mean by this it has to be a

00:45:02,349 --> 00:45:08,529
type that support whose shape in core

00:45:05,169 --> 00:45:11,369
supports encode ref so that we encode a

00:45:08,529 --> 00:45:11,369
path into it

00:45:13,319 --> 00:45:18,819
so I don't want to go into the details

00:45:16,150 --> 00:45:22,319
of the tupple of shape implementations

00:45:18,819 --> 00:45:24,520
there's a ton of super classes here like

00:45:22,319 --> 00:45:26,890
product note shape which make this

00:45:24,520 --> 00:45:29,109
easier and we have at Apple shape which

00:45:26,890 --> 00:45:31,410
extends that and so on I just want to

00:45:29,109 --> 00:45:34,030
show you the principle of how how the

00:45:31,410 --> 00:45:36,339
encoding works at the value level we're

00:45:34,030 --> 00:45:40,930
looking at this to note and encode ref

00:45:36,339 --> 00:45:44,440
so in the case of to note we take the

00:45:40,930 --> 00:45:49,170
shapes which are the shapes of the child

00:45:44,440 --> 00:45:54,970
elements and we sip it with the actual

00:45:49,170 --> 00:45:59,140
element values and then we call to note

00:45:54,970 --> 00:46:03,180
pairwise on those and put the result

00:45:59,140 --> 00:46:05,290
into a product note so it just zips the

00:46:03,180 --> 00:46:07,960
original implementations of the

00:46:05,290 --> 00:46:12,130
individual values and the same goes for

00:46:07,960 --> 00:46:15,130
encode ref we take the element shapes we

00:46:12,130 --> 00:46:18,099
take the element values and we take the

00:46:15,130 --> 00:46:21,520
index of them and zip all of them all of

00:46:18,099 --> 00:46:24,430
that up and then we call in code ref on

00:46:21,520 --> 00:46:29,950
these individual values and what we

00:46:24,430 --> 00:46:33,700
encode is a path a select that selects a

00:46:29,950 --> 00:46:37,180
simple underscore plus position plus one

00:46:33,700 --> 00:46:39,490
so when you say X dot underscore one on

00:46:37,180 --> 00:46:42,640
a topple X it will actually encode this

00:46:39,490 --> 00:46:47,589
as a symbol act as a select of X dot

00:46:42,640 --> 00:46:50,670
underscore one in the ast and then build

00:46:47,589 --> 00:46:53,079
value will build the tupple that's a

00:46:50,670 --> 00:46:56,290
generated utility function because we

00:46:53,079 --> 00:46:58,270
also need 22 of those again because we

00:46:56,290 --> 00:47:05,230
have to support the tuples for each

00:46:58,270 --> 00:47:07,810
charity separately so finally let's get

00:47:05,230 --> 00:47:09,609
to heterogeneous lists or h lists most

00:47:07,810 --> 00:47:12,040
of you have probably seen Daniel talks

00:47:09,609 --> 00:47:15,640
so you already know what h lists are

00:47:12,040 --> 00:47:17,680
I'll just keep it simple here we have an

00:47:15,640 --> 00:47:21,880
abstract class H list and we have an

00:47:17,680 --> 00:47:24,069
object H nil and a class H con so that's

00:47:21,880 --> 00:47:25,540
like a standard Scala list which has a

00:47:24,069 --> 00:47:29,410
nil object

00:47:25,540 --> 00:47:31,450
Kant's class to concatenate elements at

00:47:29,410 --> 00:47:33,910
the beginning of the list the difference

00:47:31,450 --> 00:47:36,190
is that in an H list you also do the

00:47:33,910 --> 00:47:38,890
concatenation in the types not just the

00:47:36,190 --> 00:47:42,190
values so you can have a type like H

00:47:38,890 --> 00:47:45,100
cons of int comma H cons of string comma

00:47:42,190 --> 00:47:47,320
H Nilda type and with some syntactic

00:47:45,100 --> 00:47:50,620
sugar on top we can write that type as

00:47:47,320 --> 00:47:53,950
into colon colon string : : h nila so

00:47:50,620 --> 00:47:56,770
the same as in the value domain but

00:47:53,950 --> 00:47:59,170
these are just like nested tuples they

00:47:56,770 --> 00:48:01,540
have a recursive definition here we have

00:47:59,170 --> 00:48:05,770
an H nil as the base case and we have an

00:48:01,540 --> 00:48:07,690
H cons as the recursive case so this

00:48:05,770 --> 00:48:10,980
means we should be able to do the same

00:48:07,690 --> 00:48:14,640
with the shapes right and in fact we can

00:48:10,980 --> 00:48:17,950
this is all you need I mean there's a

00:48:14,640 --> 00:48:19,930
there's a superclass here that we're

00:48:17,950 --> 00:48:23,200
using which does some of the magic but

00:48:19,930 --> 00:48:25,150
the actual ageless shape implementation

00:48:23,200 --> 00:48:30,010
is all that you see on this slide it's

00:48:25,150 --> 00:48:31,510
complete so the implementation appears

00:48:30,010 --> 00:48:34,150
not very interesting the interesting

00:48:31,510 --> 00:48:37,030
part happens in the implicit we have one

00:48:34,150 --> 00:48:41,220
implicit H nil shape for the base case

00:48:37,030 --> 00:48:44,220
this gives us an H list shape oops

00:48:41,220 --> 00:48:48,370
gives us an ageless shape for H know

00:48:44,220 --> 00:48:51,400
which unpacks to H nil and packs to H no

00:48:48,370 --> 00:48:54,220
of course and has no elements and then

00:48:51,400 --> 00:48:57,550
we have an H cone shape which gives us

00:48:54,220 --> 00:49:01,690
an ageless shape for M 1 concatenated to

00:48:57,550 --> 00:49:05,500
M 2 provided that we have a shape for M

00:49:01,690 --> 00:49:08,320
1 whatever it is and an ageless shape

00:49:05,500 --> 00:49:10,390
for M 2 we can narrow down a search

00:49:08,320 --> 00:49:13,150
space you were requiring an H list shape

00:49:10,390 --> 00:49:14,740
because it can't be anything else and so

00:49:13,150 --> 00:49:17,770
we don't need to have the compiler

00:49:14,740 --> 00:49:20,590
search for other shapes and that's it

00:49:17,770 --> 00:49:22,540
it's a recursive definition and the

00:49:20,590 --> 00:49:24,700
shapes are looked up recursively and the

00:49:22,540 --> 00:49:29,500
type inference flows recursively first

00:49:24,700 --> 00:49:31,600
down then up and voila you can use H

00:49:29,500 --> 00:49:35,380
less shapes you can use H lists

00:49:31,600 --> 00:49:38,050
everywhere and slick automatically so we

00:49:35,380 --> 00:49:41,500
have a class users for the table row

00:49:38,050 --> 00:49:45,270
which has this ageless type here we use

00:49:41,500 --> 00:49:48,250
H lists for the star projection and we

00:49:45,270 --> 00:49:54,600
write an expression here which also uses

00:49:48,250 --> 00:49:57,640
an H list well that's as much as I have

00:49:54,600 --> 00:50:00,040
we made it to the H list so here are

00:49:57,640 --> 00:50:03,220
some links of course for the regular

00:50:00,040 --> 00:50:05,020
slick slick dot light bank.com and also

00:50:03,220 --> 00:50:07,270
the link to the toy slick if you want to

00:50:05,020 --> 00:50:12,190
play with this you can just clone it

00:50:07,270 --> 00:50:14,350
from github and do SBT run and look at

00:50:12,190 --> 00:50:16,210
the source code it's just a few files

00:50:14,350 --> 00:50:18,370
left from the original slick and you can

00:50:16,210 --> 00:50:22,560
follow me on Twitter if you like or ask

00:50:18,370 --> 00:50:22,560
questions if you have any thanks

00:50:32,810 --> 00:50:37,180
no questions there's one

00:50:38,240 --> 00:50:44,390
what are the major sources of additional

00:50:40,910 --> 00:50:47,630
complication in the real slick the

00:50:44,390 --> 00:50:50,720
biggest one is options because I've

00:50:47,630 --> 00:50:52,880
simplified adhere to requiring a typed

00:50:50,720 --> 00:50:55,910
type for any primitive type we have to

00:50:52,880 --> 00:50:59,420
distinguish there between a base typed

00:50:55,910 --> 00:51:02,660
type and an option typed type and then

00:50:59,420 --> 00:51:05,000
we need to set up shapes for those and

00:51:02,660 --> 00:51:08,090
that was the simple part that's that's

00:51:05,000 --> 00:51:15,050
what we had before slick 3.1 I think or

00:51:08,090 --> 00:51:18,440
3.0 and then we added options of complex

00:51:15,050 --> 00:51:20,900
types like for outer joints when you

00:51:18,440 --> 00:51:23,750
have a left-hand side and a right-hand

00:51:20,900 --> 00:51:26,690
side and you do a regular join you get a

00:51:23,750 --> 00:51:28,490
seek of like t1 and t2 but if you have

00:51:26,690 --> 00:51:31,430
to a left outer join you get a seek of

00:51:28,490 --> 00:51:34,250
option of t1 and t2 that's the correct

00:51:31,430 --> 00:51:38,030
type even if t1 is a compound type and

00:51:34,250 --> 00:51:40,190
it turns out that the right type for for

00:51:38,030 --> 00:51:41,930
these option types is different from the

00:51:40,190 --> 00:51:44,869
type that we use for primitive options

00:51:41,930 --> 00:51:48,140
so essentially the correct type for

00:51:44,869 --> 00:51:50,450
option would be rep of option of rep of

00:51:48,140 --> 00:51:53,869
int but what we had for primitives is

00:51:50,450 --> 00:51:59,119
rep of option event and reconciling

00:51:53,869 --> 00:52:03,220
those was a big big amount of work

00:51:59,119 --> 00:52:03,220
actually and led to some complications

00:52:08,960 --> 00:52:14,020
well Creighton thank you for attending

00:52:11,630 --> 00:52:14,020

YouTube URL: https://www.youtube.com/watch?v=tS6N5AaZTLA


