Title: Metaprogramming 2.0 - by Eugene Burmako
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
The story of better metaprogramming in Scala has started in early 2013, after we released macros 1.0 and got initial feedback from early adopters. This talk will provide an illustrated guide through the history of the improvements that we did and are planning to do to metaprogramming. We will see what worked, what didn't, and what we're excited about for the future of macros in scala.meta and Dotty.
Captions: 
	00:00:02,300 --> 00:00:09,860
today we're gonna talk about our

00:00:05,890 --> 00:00:11,719
advances and metaprogramming and so

00:00:09,860 --> 00:00:15,980
without further ado let's see what we

00:00:11,719 --> 00:00:17,689
have in stock so what is Scala meta I've

00:00:15,980 --> 00:00:20,449
been given talks about Scala meta for

00:00:17,689 --> 00:00:23,480
two years already and every time when

00:00:20,449 --> 00:00:26,449
writing slides I feel kinda uneasy so on

00:00:23,480 --> 00:00:28,300
the one hand you know if you go to the

00:00:26,449 --> 00:00:32,810
website of Scala method says that it's

00:00:28,300 --> 00:00:35,330
you know convenient robust easy to use

00:00:32,810 --> 00:00:38,030
meta programming framework but that's

00:00:35,330 --> 00:00:40,430
that doesn't sound very exciting so now

00:00:38,030 --> 00:00:42,530
I'm just gonna give you know a few

00:00:40,430 --> 00:00:45,740
explanations of what's kilometer is and

00:00:42,530 --> 00:00:48,020
you pick the one that you like well

00:00:45,740 --> 00:00:49,940
first of all Scala meta is a dream it

00:00:48,020 --> 00:00:53,240
really started as a dream to make meta

00:00:49,940 --> 00:00:54,470
programming easy for everyone because by

00:00:53,240 --> 00:00:57,280
that time I've been working for a few

00:00:54,470 --> 00:01:00,380
years on macros and on Scala reflect and

00:00:57,280 --> 00:01:02,690
I've seen the pain and I've endured it

00:01:00,380 --> 00:01:03,860
but I didn't want to inflict it on

00:01:02,690 --> 00:01:07,240
anyone anymore

00:01:03,860 --> 00:01:09,230
so Scala meta was was born from our

00:01:07,240 --> 00:01:12,230
collaboration with Dennis Chaplin and

00:01:09,230 --> 00:01:16,010
our desire to make this thing easier so

00:01:12,230 --> 00:01:18,050
that no one has to suffer also Scala

00:01:16,010 --> 00:01:19,490
meta is something real so it's not just

00:01:18,050 --> 00:01:21,950
a dream it's not just an academic

00:01:19,490 --> 00:01:24,950
project it's really a very active

00:01:21,950 --> 00:01:28,610
project so as you can see the project is

00:01:24,950 --> 00:01:30,979
a bit more than two years old and we

00:01:28,610 --> 00:01:34,760
have several thousand thousand commits

00:01:30,979 --> 00:01:38,930
there so it's very very real I will see

00:01:34,760 --> 00:01:41,720
later on more examples on that also as

00:01:38,930 --> 00:01:44,479
Scala meta is a community so I typically

00:01:41,720 --> 00:01:46,580
do the credit slide in the beginning of

00:01:44,479 --> 00:01:49,430
my talk but today when I was preparing

00:01:46,580 --> 00:01:50,990
it well the list of people it just

00:01:49,430 --> 00:01:54,110
didn't fit into the slides even if I

00:01:50,990 --> 00:01:56,540
used two columns so I've been really

00:01:54,110 --> 00:01:59,000
really lucky to have a lot of people on

00:01:56,540 --> 00:02:02,360
board and with every person there and

00:01:59,000 --> 00:02:05,299
the list we have a story so there are

00:02:02,360 --> 00:02:07,880
people from epfl our master students our

00:02:05,299 --> 00:02:09,889
PhD students and their external

00:02:07,880 --> 00:02:12,950
contributors who just got interested in

00:02:09,889 --> 00:02:14,900
the project and decided to

00:02:12,950 --> 00:02:17,209
to do something for it so it's quite

00:02:14,900 --> 00:02:18,730
exciting and I invite you to join us if

00:02:17,209 --> 00:02:22,250
you like what you hear

00:02:18,730 --> 00:02:25,250
also as Kalamata is a product speaking

00:02:22,250 --> 00:02:27,470
of things being real so well it's it's

00:02:25,250 --> 00:02:29,239
something that you can execute so you

00:02:27,470 --> 00:02:32,180
take this jar you download it from maven

00:02:29,239 --> 00:02:35,360
and you get to do interesting and

00:02:32,180 --> 00:02:36,620
exciting stuff later we will see what

00:02:35,360 --> 00:02:40,459
exactly this is a monster

00:02:36,620 --> 00:02:42,620
and finally it's I'm really happy to say

00:02:40,459 --> 00:02:46,220
that now as Kalamata is officially

00:02:42,620 --> 00:02:48,950
endorsed so i'm really happy that i

00:02:46,220 --> 00:02:52,400
convinced martin that scala met is a

00:02:48,950 --> 00:02:54,980
good idea and it was very exciting to

00:02:52,400 --> 00:02:59,180
see this slice during his keynote at the

00:02:54,980 --> 00:03:02,120
day before yesterday all right so let's

00:02:59,180 --> 00:03:07,400
see what Scala meta is capable of

00:03:02,120 --> 00:03:10,400
so what's it good for a year ago at

00:03:07,400 --> 00:03:13,069
Scala days in Amsterdam I announced that

00:03:10,400 --> 00:03:15,380
well we've done a lot of experiments we

00:03:13,069 --> 00:03:17,150
solved almost all problems that scholar

00:03:15,380 --> 00:03:20,030
reflux had we have prototypes for

00:03:17,150 --> 00:03:21,889
everything and now we have to put this

00:03:20,030 --> 00:03:25,069
stuff on hold and the really pushed for

00:03:21,889 --> 00:03:28,579
the stable release so that everyone can

00:03:25,069 --> 00:03:32,720
enjoy the fruits for labour and now a

00:03:28,579 --> 00:03:35,329
year after 3k commits and the 19

00:03:32,720 --> 00:03:37,609
milestone builds afterwards we have

00:03:35,329 --> 00:03:41,680
published our first better release it's

00:03:37,609 --> 00:03:45,260
a very exciting day and we do plan that

00:03:41,680 --> 00:03:47,299
1.0 will for will follow shortly so

00:03:45,260 --> 00:03:50,150
what's in there what do we support in

00:03:47,299 --> 00:03:52,489
the 1.0 release so currently we're

00:03:50,150 --> 00:03:55,970
feature complete and I'm not going to

00:03:52,489 --> 00:04:00,079
implement more stuff and what study I

00:03:55,970 --> 00:04:03,079
was there in stock well if if I were to

00:04:00,079 --> 00:04:04,940
find a single word that defines was

00:04:03,079 --> 00:04:08,420
implemented there so it's basically

00:04:04,940 --> 00:04:11,209
syntactic api's with with the current

00:04:08,420 --> 00:04:14,180
release of Scala meta it's possible to

00:04:11,209 --> 00:04:16,940
parse code written in a various dialects

00:04:14,180 --> 00:04:19,099
of scholar Scala to ten scale to eleven

00:04:16,940 --> 00:04:21,560
dot he and well obviously it will be

00:04:19,099 --> 00:04:23,780
easy to support scouts as well and other

00:04:21,560 --> 00:04:25,520
evolutions of scholar we also have quasi

00:04:23,780 --> 00:04:27,740
quotes to be

00:04:25,520 --> 00:04:32,210
to have Fisher priority with scarlet

00:04:27,740 --> 00:04:34,099
flag and might I say that they're quite

00:04:32,210 --> 00:04:37,069
better than what we have currently in

00:04:34,099 --> 00:04:40,069
the production compiler and finally

00:04:37,069 --> 00:04:42,710
thanks to tokens later we will get to

00:04:40,069 --> 00:04:44,690
see what it is exactly we can finally

00:04:42,710 --> 00:04:47,150
have formats in preserving pretty

00:04:44,690 --> 00:04:49,129
printing so if you if you are working

00:04:47,150 --> 00:04:52,370
with the code it obviously is gonna

00:04:49,129 --> 00:04:55,550
contain some formatting it's obviously

00:04:52,370 --> 00:04:59,800
gonna contain comments so right right

00:04:55,550 --> 00:05:04,880
and we've got this handled

00:04:59,800 --> 00:05:07,729
okay so what's what's next after after

00:05:04,880 --> 00:05:09,590
we deliver version 1.0 I wish I hope is

00:05:07,729 --> 00:05:13,699
gonna happen soon

00:05:09,590 --> 00:05:15,590
for for the version 2.0 we plan to

00:05:13,699 --> 00:05:18,469
support semantic KPIs and they're super

00:05:15,590 --> 00:05:20,680
systems which means that it will not

00:05:18,469 --> 00:05:23,419
only be possible to parse code and

00:05:20,680 --> 00:05:25,039
analyze its structure but you will be

00:05:23,419 --> 00:05:27,590
you will also be able to seek types

00:05:25,039 --> 00:05:30,400
resolve names do implicit inference and

00:05:27,590 --> 00:05:33,469
save all that disk so that later on

00:05:30,400 --> 00:05:35,569
tools can take a look so that later on

00:05:33,469 --> 00:05:37,909
we can have integration with this

00:05:35,569 --> 00:05:39,909
amazing tasty technology this shipping

00:05:37,909 --> 00:05:43,750
into awesome

00:05:39,909 --> 00:05:48,680
ok now the time has come to take a look

00:05:43,750 --> 00:05:50,840
at the live demo so I just want to

00:05:48,680 --> 00:05:52,370
convince you that the things that I'm

00:05:50,840 --> 00:05:55,789
going to present they're real

00:05:52,370 --> 00:05:58,849
so I haven't predefined you know any

00:05:55,789 --> 00:06:00,710
aliases any special configuration of

00:05:58,849 --> 00:06:05,029
scalpel let's just go to the website a

00:06:00,710 --> 00:06:09,789
feminized download the new shell oh it's

00:06:05,029 --> 00:06:11,690
interesting and start hacking away

00:06:09,789 --> 00:06:14,449
it's nice when a project has

00:06:11,690 --> 00:06:18,130
documentation this definitely under is

00:06:14,449 --> 00:06:18,130
it alright

00:06:20,080 --> 00:06:26,510
well while we're waiting I would like to

00:06:23,960 --> 00:06:28,370
note that as calamity is quite easy to

00:06:26,510 --> 00:06:32,930
use because all that it takes is a

00:06:28,370 --> 00:06:35,780
reference to one library and then one

00:06:32,930 --> 00:06:39,830
wildcard import let's take a look

00:06:35,780 --> 00:06:46,730
it's gonna be load again well then you

00:06:39,830 --> 00:06:50,540
say pork Scala meta here's this artifact

00:06:46,730 --> 00:06:54,800
and here's the version that's currently

00:06:50,540 --> 00:06:57,500
available ok so see I haven't pre cached

00:06:54,800 --> 00:07:00,050
anything to my computer so don't worry

00:06:57,500 --> 00:07:05,450
from the internet now we're just one

00:07:00,050 --> 00:07:07,750
import away from having fun ok let's say

00:07:05,450 --> 00:07:11,480
LS let's start with something simple

00:07:07,750 --> 00:07:14,420
let's just you know parse some random

00:07:11,480 --> 00:07:16,460
code so in order to take a look what

00:07:14,420 --> 00:07:19,370
what are the core data structures of

00:07:16,460 --> 00:07:21,560
Scala Matt and what what our abstract

00:07:19,370 --> 00:07:24,260
syntax trees look like so let's say we

00:07:21,560 --> 00:07:27,410
want to perform this very fancy addition

00:07:24,260 --> 00:07:32,360
and now once we have the string we want

00:07:27,410 --> 00:07:34,010
to parse it into a term so here we go no

00:07:32,360 --> 00:07:37,070
other imports required no configuration

00:07:34,010 --> 00:07:39,860
no nothing so we were really strict

00:07:37,070 --> 00:07:42,020
about being convenient so if you want

00:07:39,860 --> 00:07:45,560
you can do much more and later on I'll

00:07:42,020 --> 00:07:48,620
elaborate on that but you know your

00:07:45,560 --> 00:07:52,460
first step should be very easy so now we

00:07:48,620 --> 00:07:55,310
get this parse model by the way is is

00:07:52,460 --> 00:07:59,890
everything can everyone see the font or

00:07:55,310 --> 00:08:02,350
I should increase it okay

00:07:59,890 --> 00:08:08,360
is this better

00:08:02,350 --> 00:08:10,430
good so after we parse the code we can

00:08:08,360 --> 00:08:14,840
see the result we can see that it's a

00:08:10,430 --> 00:08:18,980
success and afterwards we can just get

00:08:14,840 --> 00:08:20,900
to the abstract syntax tree so what is

00:08:18,980 --> 00:08:23,810
kilometer obviously supports as some

00:08:20,900 --> 00:08:27,500
debug printing so we can take a look at

00:08:23,810 --> 00:08:29,570
the structure it really contains the

00:08:27,500 --> 00:08:30,520
stuff that you typed and I would like to

00:08:29,570 --> 00:08:32,440
note

00:08:30,520 --> 00:08:34,450
reference with what's available right

00:08:32,440 --> 00:08:37,270
now is call reflect so here we have a

00:08:34,450 --> 00:08:39,640
special special st node called apply in

00:08:37,270 --> 00:08:44,020
fix which models in fix applications and

00:08:39,640 --> 00:08:48,029
lets us distinguish them from regular

00:08:44,020 --> 00:08:48,029
methods called method calls like this

00:08:51,410 --> 00:08:57,080
here we go and if we inspect structure

00:08:54,230 --> 00:08:58,850
of this guy we will see it's an apply so

00:08:57,080 --> 00:09:00,470
it may seem as a tree or fissure because

00:08:58,850 --> 00:09:03,200
well typically as a user you don't

00:09:00,470 --> 00:09:05,330
really care whether we write in fixed

00:09:03,200 --> 00:09:07,250
applications or not because the

00:09:05,330 --> 00:09:09,530
semantics is more or less the same if

00:09:07,250 --> 00:09:11,990
you don't take write associative

00:09:09,530 --> 00:09:15,140
operator into account but there's a tool

00:09:11,990 --> 00:09:18,110
author so here we have some two authors

00:09:15,140 --> 00:09:22,790
in the building you would definitely

00:09:18,110 --> 00:09:24,470
appreciate this functionality and later

00:09:22,790 --> 00:09:26,270
on we'll have a few examples of tools

00:09:24,470 --> 00:09:28,370
real-world tools which have been built

00:09:26,270 --> 00:09:31,060
on top of scala mehta and we shoot

00:09:28,370 --> 00:09:33,410
alized this capabilities and to the max

00:09:31,060 --> 00:09:36,530
so the next feature that I would like to

00:09:33,410 --> 00:09:39,070
demonstrate is format in a we're pretty

00:09:36,530 --> 00:09:41,510
printing so let's imagine that we have

00:09:39,070 --> 00:09:45,890
multi-line code we have some sort of

00:09:41,510 --> 00:09:50,690
formatting say the foo equals bar and

00:09:45,890 --> 00:09:52,760
then we write some comment some

00:09:50,690 --> 00:09:56,840
intentionally typing something really

00:09:52,760 --> 00:09:59,240
weird so that you cannot say that our PC

00:09:56,840 --> 00:10:01,910
printer is too smart to figure this out

00:09:59,240 --> 00:10:03,980
so here we have the input string so as

00:10:01,910 --> 00:10:10,160
you can see well indentation is quite up

00:10:03,980 --> 00:10:14,210
and now we parse it we parse it as as a

00:10:10,160 --> 00:10:18,260
term let see was what will happen so

00:10:14,210 --> 00:10:20,030
right what happens here is we get to

00:10:18,260 --> 00:10:23,450
observe how we do very reporting so as I

00:10:20,030 --> 00:10:27,500
mentioned we parse our parse result is a

00:10:23,450 --> 00:10:29,420
model and well it has two cases success

00:10:27,500 --> 00:10:31,850
case and a failure case so now we get to

00:10:29,420 --> 00:10:35,900
observe the latter so I think as you can

00:10:31,850 --> 00:10:39,500
see we be pretty much support the error

00:10:35,900 --> 00:10:41,270
formatting that Escala see does and what

00:10:39,500 --> 00:10:43,730
it tells us here is that well we cannot

00:10:41,270 --> 00:10:47,870
parse this as a term well sure because

00:10:43,730 --> 00:10:50,750
well here we have a definition now let's

00:10:47,870 --> 00:10:52,960
wrap the code that we have in curly

00:10:50,750 --> 00:10:52,960
braces

00:10:54,770 --> 00:11:03,620
and I think that now everything is gonna

00:10:58,040 --> 00:11:06,290
work just right so now we see that

00:11:03,620 --> 00:11:07,640
things cap are successfully and we see

00:11:06,290 --> 00:11:10,760
that all the formatting has been

00:11:07,640 --> 00:11:14,570
preserved so our weird indentation here

00:11:10,760 --> 00:11:16,339
our stray a comment here so how does it

00:11:14,570 --> 00:11:20,500
work if we take a look at the structure

00:11:16,339 --> 00:11:22,730
of the of the tree oops

00:11:20,500 --> 00:11:24,529
if we take a look at the structure of

00:11:22,730 --> 00:11:26,959
the ast we we don't we don't see any

00:11:24,529 --> 00:11:29,660
comments so what's going on here

00:11:26,959 --> 00:11:32,870
obviously there's some kind of a side

00:11:29,660 --> 00:11:34,640
channel through which our pretty printer

00:11:32,870 --> 00:11:38,209
figures out how the code was written

00:11:34,640 --> 00:11:40,970
originally and this is the time when we

00:11:38,209 --> 00:11:46,279
introduce the concept of tokens so

00:11:40,970 --> 00:11:49,990
tokens they are atomic units of Scala

00:11:46,279 --> 00:11:53,170
code essentially when when the Scala C

00:11:49,990 --> 00:11:56,230
parser when the Scala meta parser

00:11:53,170 --> 00:12:00,230
processes a Scala code it first

00:11:56,230 --> 00:12:02,270
tokenized it uses a dedicated part of

00:12:00,230 --> 00:12:05,990
the compiler called cold scanner which

00:12:02,270 --> 00:12:09,110
splits the the input apart into very

00:12:05,990 --> 00:12:10,910
very small very small parts like curly

00:12:09,110 --> 00:12:13,070
braces like white space where we have a

00:12:10,910 --> 00:12:15,520
lot of white space here the DEF keyword

00:12:13,070 --> 00:12:20,390
and so on and so forth

00:12:15,520 --> 00:12:22,220
so it turns out that if we don't so

00:12:20,390 --> 00:12:24,850
typically what happens afterwards with

00:12:22,220 --> 00:12:27,529
these tokens after the input has been

00:12:24,850 --> 00:12:30,320
asked and now the seconds they get

00:12:27,529 --> 00:12:32,390
thrown away after after the program is

00:12:30,320 --> 00:12:35,450
parsed but it turns out that if we do

00:12:32,390 --> 00:12:38,450
not throw them away if we verify it and

00:12:35,450 --> 00:12:40,790
let let the users inspect how they look

00:12:38,450 --> 00:12:43,279
like then we can preserve all the

00:12:40,790 --> 00:12:45,350
formatting that we need so as you can

00:12:43,279 --> 00:12:49,790
see if we print out the structure of

00:12:45,350 --> 00:12:53,029
this tokens collection then then we

00:12:49,790 --> 00:12:56,570
literally can explore the program apart

00:12:53,029 --> 00:12:58,670
by part including you know including all

00:12:56,570 --> 00:13:03,320
the white space including new lines and

00:12:58,670 --> 00:13:05,209
including the comment so this is quite

00:13:03,320 --> 00:13:07,770
interesting and that's one of the

00:13:05,209 --> 00:13:11,730
exclusive features of Scala meta that's

00:13:07,770 --> 00:13:15,120
well not always available in meta

00:13:11,730 --> 00:13:19,140
programming frameworks now to get not to

00:13:15,120 --> 00:13:20,970
get to something different let's let's

00:13:19,140 --> 00:13:26,400
try think something else so so far we've

00:13:20,970 --> 00:13:27,450
been parsing Scala and obviously when we

00:13:26,400 --> 00:13:30,240
are programming Scala

00:13:27,450 --> 00:13:31,740
we're not only using Scala I'm not

00:13:30,240 --> 00:13:33,480
talking about Java which is not

00:13:31,740 --> 00:13:37,260
supported by Scala matter yet I'm

00:13:33,480 --> 00:13:39,480
talking about SBT well even even though

00:13:37,260 --> 00:13:41,850
SBC files they look like Scala files

00:13:39,480 --> 00:13:46,230
actually they have different scene

00:13:41,850 --> 00:13:51,390
things so if we try to take a look and

00:13:46,230 --> 00:13:53,960
the project that they have here so I

00:13:51,390 --> 00:13:57,090
have a bunch of projects well let's

00:13:53,960 --> 00:14:00,150
let's see how these sim electrons build

00:13:57,090 --> 00:14:03,000
that SBT looks like so well it's a it is

00:14:00,150 --> 00:14:06,660
definitely all very familiar to you guys

00:14:03,000 --> 00:14:09,690
but I'd like to know that at some point

00:14:06,660 --> 00:14:12,240
it was mandatory for four lines and SBT

00:14:09,690 --> 00:14:14,940
to be split by empty lines so that

00:14:12,240 --> 00:14:19,920
different configuration parts could be

00:14:14,940 --> 00:14:21,540
parsed by the by the SBT engine and so

00:14:19,920 --> 00:14:24,540
let's that's one difference between how

00:14:21,540 --> 00:14:26,670
SBT and Scala code work another

00:14:24,540 --> 00:14:29,850
difference is that in SBT config files

00:14:26,670 --> 00:14:33,720
it's actually possible to write it's

00:14:29,850 --> 00:14:37,680
actually possible to write regular terms

00:14:33,720 --> 00:14:39,960
like vowels and deaths at the top level

00:14:37,680 --> 00:14:45,530
something that you cannot do in

00:14:39,960 --> 00:14:47,910
individual Scala files so Scala meta

00:14:45,530 --> 00:14:49,080
since accessibility files they're very

00:14:47,910 --> 00:14:52,140
important to the community

00:14:49,080 --> 00:14:57,060
Scala meta supports them natively so

00:14:52,140 --> 00:15:00,600
let's let's create this reference to the

00:14:57,060 --> 00:15:06,090
SBT file now that you are looking at so

00:15:00,600 --> 00:15:06,630
here it is and now if just just to check

00:15:06,090 --> 00:15:09,780
it out

00:15:06,630 --> 00:15:13,320
just do a sanity check if we try to

00:15:09,780 --> 00:15:16,260
parse it as a scholar source we will see

00:15:13,320 --> 00:15:18,060
that it's a parser so if we go here

00:15:16,260 --> 00:15:19,360
that's all natural you can you cannot

00:15:18,060 --> 00:15:22,990
write method definition

00:15:19,360 --> 00:15:26,589
at the top level not in the in the

00:15:22,990 --> 00:15:30,040
default version of scholar now let's do

00:15:26,589 --> 00:15:33,459
the following thing but let's say that

00:15:30,040 --> 00:15:41,140
we're going to use the SBT dialect but

00:15:33,459 --> 00:15:43,839
supported that supports sorry SBT 0 13 6

00:15:41,140 --> 00:15:47,620
and now once we imported it it's an

00:15:43,839 --> 00:15:49,290
implicit it will guide the parser to you

00:15:47,620 --> 00:15:53,040
to use different strategy for parsing

00:15:49,290 --> 00:15:53,040
and now

00:16:05,170 --> 00:16:08,550
you know that's a surprise

00:16:19,420 --> 00:16:27,910
okay here we go so probably this was

00:16:24,820 --> 00:16:31,660
this was must be t build written for

00:16:27,910 --> 00:16:33,610
zero thirteen seven when when they relax

00:16:31,660 --> 00:16:37,090
the restrictions on what you can right

00:16:33,610 --> 00:16:39,430
there so as you can see now we

00:16:37,090 --> 00:16:42,670
explicitly specified the electroscope

00:16:39,430 --> 00:16:47,080
program that we are looking at and we

00:16:42,670 --> 00:16:49,000
got we got an ST that we can use just as

00:16:47,080 --> 00:16:52,180
well as if we parse the normal scholar

00:16:49,000 --> 00:16:53,380
program so here we have a source we

00:16:52,180 --> 00:16:55,690
share up the sequence of statements

00:16:53,380 --> 00:16:57,280
including the import and well I'm

00:16:55,690 --> 00:16:59,560
definitely not going to go through this

00:16:57,280 --> 00:17:02,470
wall of text but I would just like to

00:16:59,560 --> 00:17:05,260
show you that this is T is regardless of

00:17:02,470 --> 00:17:07,449
how exactly we parse them they look the

00:17:05,260 --> 00:17:09,670
same and they provide the same

00:17:07,449 --> 00:17:13,350
functionality and finally I would like

00:17:09,670 --> 00:17:17,410
to finish the tour of scala mehta by

00:17:13,350 --> 00:17:20,829
showing quasi calls so just like in your

00:17:17,410 --> 00:17:22,420
favorite macros just just like in your

00:17:20,829 --> 00:17:25,829
compiler plugins you can use quasi

00:17:22,420 --> 00:17:28,150
closed so say you can you can define

00:17:25,829 --> 00:17:30,280
quasi quote which represent an

00:17:28,150 --> 00:17:34,000
identifier foo and then you can use

00:17:30,280 --> 00:17:36,940
another quasi quote to insert it into a

00:17:34,000 --> 00:17:38,410
bigger tree so nothing special and this

00:17:36,940 --> 00:17:41,770
is exactly the same result as if you

00:17:38,410 --> 00:17:45,720
have parsed the code so pick your own

00:17:41,770 --> 00:17:49,080
way to to work with scala meta and well

00:17:45,720 --> 00:17:51,580
just the last thing that I haven't shown

00:17:49,080 --> 00:17:54,820
you can use a quasi closed to

00:17:51,580 --> 00:17:57,610
deconstruct this T 0 so if we match this

00:17:54,820 --> 00:18:01,750
tree we we get the syntactic parts here

00:17:57,610 --> 00:18:03,640
and the the very last remark on the data

00:18:01,750 --> 00:18:05,980
structures that we are using as you've

00:18:03,640 --> 00:18:08,470
seen our data model is is more precise

00:18:05,980 --> 00:18:12,100
than what's typically expected of of

00:18:08,470 --> 00:18:16,180
macros so as you can see the the type of

00:18:12,100 --> 00:18:17,650
this why it's actually not a term which

00:18:16,180 --> 00:18:20,890
you would think it should be it's

00:18:17,650 --> 00:18:22,870
actually an argument which means that in

00:18:20,890 --> 00:18:25,000
in Scala meta we model really really

00:18:22,870 --> 00:18:26,920
small peculiar details of Scala syntax

00:18:25,000 --> 00:18:30,160
which are quite an obvious that at the

00:18:26,920 --> 00:18:31,870
first glance and are easy to overlook so

00:18:30,160 --> 00:18:33,450
so here we are actually accounting for

00:18:31,870 --> 00:18:35,640
the fact that

00:18:33,450 --> 00:18:37,650
why is an argument so it can be a by

00:18:35,640 --> 00:18:40,650
name argument or or for instance of our

00:18:37,650 --> 00:18:43,380
art so that's that's the kind of

00:18:40,650 --> 00:18:45,480
precision that Scala meta provides and I

00:18:43,380 --> 00:18:47,370
think it's a good thing because after

00:18:45,480 --> 00:18:49,950
making a lot of stupid mistakes with

00:18:47,370 --> 00:18:52,110
macros and helping people out with this

00:18:49,950 --> 00:18:55,590
stuff I really think it's going to be

00:18:52,110 --> 00:18:58,290
valuable all right so let's get back to

00:18:55,590 --> 00:19:00,690
the presentation and just sum up what

00:18:58,290 --> 00:19:02,730
we've seen now with Scala meta with the

00:19:00,690 --> 00:19:06,270
current stable version it's possible to

00:19:02,730 --> 00:19:06,720
parse Scala sources are both written in

00:19:06,270 --> 00:19:11,760
Scala

00:19:06,720 --> 00:19:17,250
and in various dialects so I can can

00:19:11,760 --> 00:19:18,720
probably show you this here so we have

00:19:17,250 --> 00:19:20,880
this concept of dialect which which

00:19:18,720 --> 00:19:23,429
captures differences between say Scala

00:19:20,880 --> 00:19:26,400
and dotty Scala to ten scale to eleven

00:19:23,429 --> 00:19:30,780
for instance in Scala to ten it's it's

00:19:26,400 --> 00:19:34,740
illegal to use dollar to write dollar

00:19:30,780 --> 00:19:37,020
splice in patterns but in Scout in Scala

00:19:34,740 --> 00:19:39,929
to eleven is possible so we're really

00:19:37,020 --> 00:19:41,880
looking into this very small details so

00:19:39,929 --> 00:19:46,290
that you don't have to bother yourself

00:19:41,880 --> 00:19:48,299
and below here you can see we will be

00:19:46,290 --> 00:19:51,179
playing a bunch of objects and capture

00:19:48,299 --> 00:19:53,280
information so for instance in Scala 210

00:19:51,179 --> 00:19:55,890
if you're right in there bar pattern

00:19:53,280 --> 00:19:59,100
passion user and that sign whereas in

00:19:55,890 --> 00:20:02,130
dot EU smaller and scholar ten doesn't

00:19:59,100 --> 00:20:05,340
allow us dollar underscore for this kind

00:20:02,130 --> 00:20:08,560
of stuff so we're modeling things

00:20:05,340 --> 00:20:11,320
all right so that's that's the person

00:20:08,560 --> 00:20:14,220
that we've seen will set of particles

00:20:11,320 --> 00:20:16,900
that provides state biosafety and

00:20:14,220 --> 00:20:18,790
finally our pretty Queens and it

00:20:16,900 --> 00:20:20,830
respects for misleading comments by

00:20:18,790 --> 00:20:23,140
using dolphins all right what about

00:20:20,830 --> 00:20:26,740
macros but now you might be thinking

00:20:23,140 --> 00:20:28,660
that well Eugene is a micro guy right

00:20:26,740 --> 00:20:30,190
and he gives a talk and that didn't

00:20:28,660 --> 00:20:32,170
didn't say macro in the first 20 minutes

00:20:30,190 --> 00:20:34,750
of the talk what's going on so is there

00:20:32,170 --> 00:20:38,650
some sort where no dark secrets here

00:20:34,750 --> 00:20:40,660
well as Martin can say macros are dead

00:20:38,650 --> 00:20:43,240
so nothing to talk about

00:20:40,660 --> 00:20:45,550
here's another screenshot from from the

00:20:43,240 --> 00:20:50,050
slides well markers are gonna be dropped

00:20:45,550 --> 00:20:52,630
from Scala all right because they're

00:20:50,050 --> 00:20:55,690
kinda hard to write they don't work well

00:20:52,630 --> 00:20:57,520
with dueling I think neither of the

00:20:55,690 --> 00:21:00,310
popular ideas can help handle them

00:20:57,520 --> 00:21:01,990
correctly 100% of the cases and they're

00:21:00,310 --> 00:21:03,910
very entangled with compiler into

00:21:01,990 --> 00:21:06,280
hospitals scholar effect the current

00:21:03,910 --> 00:21:11,410
idea for macros it's building compiler

00:21:06,280 --> 00:21:14,680
intervals oh that's that's sure but also

00:21:11,410 --> 00:21:17,140
macros are great well no that's with

00:21:14,680 --> 00:21:19,870
macros you can prove things that wasn't

00:21:17,140 --> 00:21:23,080
possible before take shape ways for

00:21:19,870 --> 00:21:26,740
instance it's it's it's a very very cool

00:21:23,080 --> 00:21:29,080
concept of of generics and that has been

00:21:26,740 --> 00:21:31,240
encapsulated in the macro and now people

00:21:29,080 --> 00:21:31,850
can reuse it even without knowing that

00:21:31,240 --> 00:21:35,970
it's been

00:21:31,850 --> 00:21:38,640
chuckles that's quite the quite a great

00:21:35,970 --> 00:21:42,030
example capturing some really really

00:21:38,640 --> 00:21:44,610
cool advanced features in in a goodman

00:21:42,030 --> 00:21:47,250
capsule as it was and I'm really glad

00:21:44,610 --> 00:21:49,290
that macros are capable of that but they

00:21:47,250 --> 00:21:53,850
helped the Scala community as well and

00:21:49,290 --> 00:21:55,440
also well you please don't believe me

00:21:53,850 --> 00:21:57,570
you can just check for yourself if you

00:21:55,440 --> 00:22:00,660
go to the website of wideband and see

00:21:57,570 --> 00:22:03,510
the offering of the reactive platform

00:22:00,660 --> 00:22:04,980
the libraries that are there well most

00:22:03,510 --> 00:22:07,530
it's not all of this libraries they I

00:22:04,980 --> 00:22:10,650
have tried or are currently using macros

00:22:07,530 --> 00:22:12,030
and well I think it's quite a good point

00:22:10,650 --> 00:22:15,810
that macros are valuable to the

00:22:12,030 --> 00:22:18,710
community and finally I think all the

00:22:15,810 --> 00:22:21,120
points that we covered here

00:22:18,710 --> 00:22:23,220
it's actually incidental complexity

00:22:21,120 --> 00:22:31,700
that's caused by how implemented macros

00:22:23,220 --> 00:22:35,040
not by macros are dead long live macros

00:22:31,700 --> 00:22:37,320
let's see what new future we actually

00:22:35,040 --> 00:22:41,790
envision for for them well actually

00:22:37,320 --> 00:22:43,790
today i wisht the zip that we've been

00:22:41,790 --> 00:22:48,180
working internally on for quite a while

00:22:43,790 --> 00:22:51,420
together with my colleagues from a pfl

00:22:48,180 --> 00:22:53,520
and well you're very much welcome to

00:22:51,420 --> 00:22:56,940
take a look at all later on I'll post

00:22:53,520 --> 00:22:59,550
out with a link about this so if you see

00:22:56,940 --> 00:23:01,710
what what's in there in the address bar

00:22:59,550 --> 00:23:04,740
of the browser then it's all cool but

00:23:01,710 --> 00:23:07,320
later on L I'll show the the obvious

00:23:04,740 --> 00:23:09,270
thing so we've been thinking really hard

00:23:07,320 --> 00:23:12,240
how to capture the essence of them of

00:23:09,270 --> 00:23:14,400
macros that made them really really

00:23:12,240 --> 00:23:16,980
popular and very useful to to all the

00:23:14,400 --> 00:23:19,740
people as we've seen and once we started

00:23:16,980 --> 00:23:22,140
getting to the bottom of it now actually

00:23:19,740 --> 00:23:24,390
discovered that macros they're not just

00:23:22,140 --> 00:23:27,030
one concept but there are two concepts

00:23:24,390 --> 00:23:27,620
hiding behind you know this one language

00:23:27,030 --> 00:23:30,810
Visser

00:23:27,620 --> 00:23:33,800
so actually Macker do two things if we

00:23:30,810 --> 00:23:37,020
take a look at well an example macro

00:23:33,800 --> 00:23:39,450
that begged and convinced us to add

00:23:37,020 --> 00:23:42,330
macros to the language the language

00:23:39,450 --> 00:23:44,150
integrated queries macro so let's a was

00:23:42,330 --> 00:23:45,680
just to give a bit more background

00:23:44,150 --> 00:23:49,520
so that we all understand what's going

00:23:45,680 --> 00:23:52,310
on here we have a tablecloth that

00:23:49,520 --> 00:23:54,440
represents a database table or well a

00:23:52,310 --> 00:23:58,070
table in in any data source for that

00:23:54,440 --> 00:24:00,860
matter and in the table class we have we

00:23:58,070 --> 00:24:02,720
can define usual collection methods like

00:24:00,860 --> 00:24:05,120
filter like flat map and so on so forth

00:24:02,720 --> 00:24:07,960
and then we can turn these methods into

00:24:05,120 --> 00:24:10,340
macros so that queries that people write

00:24:07,960 --> 00:24:13,610
they're captured by the macro and then

00:24:10,340 --> 00:24:17,060
can be converted to sequel queries or or

00:24:13,610 --> 00:24:20,360
to whatever you prefer so just to sum it

00:24:17,060 --> 00:24:23,570
up if the user writes a a call to this

00:24:20,360 --> 00:24:26,380
method like here above on the slide then

00:24:23,570 --> 00:24:31,100
actually macro expands the compiler

00:24:26,380 --> 00:24:32,360
calls the the meta program and that

00:24:31,100 --> 00:24:35,480
we've written on the previous slides

00:24:32,360 --> 00:24:37,880
slide it expands and in lines the

00:24:35,480 --> 00:24:40,130
resultant of the call side so we see

00:24:37,880 --> 00:24:43,100
that there are two distinct aspects to

00:24:40,130 --> 00:24:45,560
macros actually the first aspect is meta

00:24:43,100 --> 00:24:48,110
programming is execution of programs at

00:24:45,560 --> 00:24:51,350
compile time using compiler api's and

00:24:48,110 --> 00:24:53,200
the second concept is inlining our

00:24:51,350 --> 00:24:55,370
current proposal it actually

00:24:53,200 --> 00:24:58,820
distinguishes this feature these

00:24:55,370 --> 00:25:01,790
features and well this this gives more

00:24:58,820 --> 00:25:03,860
capabilities and this gives you know

00:25:01,790 --> 00:25:06,340
more more refined look to the language

00:25:03,860 --> 00:25:08,870
so I guess this goes along the lines of

00:25:06,340 --> 00:25:10,610
Martin's general idea for dot C to make

00:25:08,870 --> 00:25:14,810
the language more streamlined and

00:25:10,610 --> 00:25:16,940
simpler to use so this is this is a

00:25:14,810 --> 00:25:20,870
sketch of how new markers looked like so

00:25:16,940 --> 00:25:23,900
in our draft proposal we go over that in

00:25:20,870 --> 00:25:25,430
more details obviously but here let's

00:25:23,900 --> 00:25:28,400
just take a look at this at the small

00:25:25,430 --> 00:25:31,040
example so we see that the method that

00:25:28,400 --> 00:25:34,130
we've declared this macro previously is

00:25:31,040 --> 00:25:37,610
declared as inline so this captures the

00:25:34,130 --> 00:25:40,250
inlining part of of the current macros

00:25:37,610 --> 00:25:43,460
and then at the right-hand side you have

00:25:40,250 --> 00:25:45,890
the meta block which contains the meta

00:25:43,460 --> 00:25:48,170
programming that's going on so here's

00:25:45,890 --> 00:25:50,000
what happens when the compiler tries to

00:25:48,170 --> 00:25:54,500
process the program that has a call to

00:25:50,000 --> 00:25:56,550
map so at first we we do the first

00:25:54,500 --> 00:26:00,720
transformation

00:25:56,550 --> 00:26:02,640
when we call inline methods we just take

00:26:00,720 --> 00:26:05,220
the right-hand side of the inline method

00:26:02,640 --> 00:26:07,890
this block that was written here metal

00:26:05,220 --> 00:26:10,980
braces and some stuff and we just inline

00:26:07,890 --> 00:26:12,870
it into the call side and this is what

00:26:10,980 --> 00:26:15,150
we do with inline methods nothing else

00:26:12,870 --> 00:26:17,820
no no other magic no matter is involved

00:26:15,150 --> 00:26:22,890
at all and then and when the compiler

00:26:17,820 --> 00:26:25,080
sees a meta block then it then it calls

00:26:22,890 --> 00:26:27,330
into the meta programming world and well

00:26:25,080 --> 00:26:29,640
as you can guess from the name of the

00:26:27,330 --> 00:26:31,140
block the stuff that's going on there

00:26:29,640 --> 00:26:33,570
it's implemented in Scala matter of

00:26:31,140 --> 00:26:36,810
course and so when the evaluation

00:26:33,570 --> 00:26:39,420
completes when this quasi code gets

00:26:36,810 --> 00:26:42,270
computed then finally you inline the

00:26:39,420 --> 00:26:45,570
result into the call side so this is

00:26:42,270 --> 00:26:48,990
this is the refined view of macros that

00:26:45,570 --> 00:26:51,570
we that we've expressed in the public

00:26:48,990 --> 00:26:53,310
draft of our proposal and if you're

00:26:51,570 --> 00:26:55,710
interested in that if you find that it's

00:26:53,310 --> 00:26:58,410
useful or if you find that it's not

00:26:55,710 --> 00:27:03,270
quite there yet please take a look and

00:26:58,410 --> 00:27:05,040
leave comments all right so another demo

00:27:03,270 --> 00:27:09,780
actually I didn't plan to give that one

00:27:05,040 --> 00:27:11,610
but yesterday when we went with Martin

00:27:09,780 --> 00:27:13,590
in the morning so I told him please

00:27:11,610 --> 00:27:17,160
Martin come to my talk well how can I

00:27:13,590 --> 00:27:18,270
convince you to do this and well I had

00:27:17,160 --> 00:27:21,810
to bribe him somehow

00:27:18,270 --> 00:27:25,140
so I told all right I'm going to

00:27:21,810 --> 00:27:28,050
implement this new inline macros in line

00:27:25,140 --> 00:27:30,060
macro annotations so please Martin come

00:27:28,050 --> 00:27:33,060
on in and take a look whether it will be

00:27:30,060 --> 00:27:35,640
possible whether I manage that well as a

00:27:33,060 --> 00:27:38,310
matter of fact I did after 14 hours of

00:27:35,640 --> 00:27:39,510
hacking it wasn't that much even I even

00:27:38,310 --> 00:27:42,150
got some sleep actually

00:27:39,510 --> 00:27:44,760
and now now I'd like to present the

00:27:42,150 --> 00:27:46,470
results so I hope that this you know

00:27:44,760 --> 00:27:49,350
practical relation will convince you

00:27:46,470 --> 00:27:52,730
that this split between inlining and

00:27:49,350 --> 00:27:52,730
meta programming is actually a good idea

00:28:05,050 --> 00:28:11,670
all right so this is how this looks like

00:28:08,200 --> 00:28:15,130
as I promised there's a new line method

00:28:11,670 --> 00:28:18,400
with a meta block and now we're gonna

00:28:15,130 --> 00:28:21,190
use this concept to express macro

00:28:18,400 --> 00:28:24,370
notations so this is a this is the

00:28:21,190 --> 00:28:25,660
replacement for the apt rate that was

00:28:24,370 --> 00:28:27,700
removed from dodgy as Martin said

00:28:25,660 --> 00:28:29,740
because of all this fisher didn't it

00:28:27,700 --> 00:28:31,650
wasn't carrying its weight and now we're

00:28:29,740 --> 00:28:34,390
going to replace it with macro notations

00:28:31,650 --> 00:28:36,850
making language language simpler and

00:28:34,390 --> 00:28:39,570
more streamlined so what's going on here

00:28:36,850 --> 00:28:43,120
when when trying to think how to how to

00:28:39,570 --> 00:28:46,090
think about macro notations I took

00:28:43,120 --> 00:28:50,410
inspiration from pythons decorators so

00:28:46,090 --> 00:28:53,170
how we can treat this this notation that

00:28:50,410 --> 00:28:57,520
we're seeing here is as if we are

00:28:53,170 --> 00:29:00,490
calling the main method passing it no

00:28:57,520 --> 00:29:03,040
arguments so I don't know if we wanted

00:29:00,490 --> 00:29:05,440
to pass some argument here Maina 40 to

00:29:03,040 --> 00:29:10,060
do that but it just doesn't make sense

00:29:05,440 --> 00:29:14,020
and then we also pass it a block where

00:29:10,060 --> 00:29:16,810
this object test is defined so now if we

00:29:14,020 --> 00:29:19,960
do if we if we declare this method

00:29:16,810 --> 00:29:23,200
called main as inline then what's going

00:29:19,960 --> 00:29:25,210
to happen well this will be a call to

00:29:23,200 --> 00:29:28,450
this method it will be replaced to some

00:29:25,210 --> 00:29:30,610
sort of a metal with some sort of a meta

00:29:28,450 --> 00:29:35,980
block which will expand and produce the

00:29:30,610 --> 00:29:39,840
desired result which is well what do you

00:29:35,980 --> 00:29:39,840
expect it doesn't

00:29:40,830 --> 00:29:46,070
well this is pretty much there for it I

00:29:43,140 --> 00:29:48,480
don't think that was a surprise for you

00:29:46,070 --> 00:29:50,790
so that's what that's what we want to

00:29:48,480 --> 00:29:53,700
achieve and let's see how in line and

00:29:50,790 --> 00:29:55,470
schematic can help us do that the

00:29:53,700 --> 00:29:58,560
implementation is a is actually trivial

00:29:55,470 --> 00:30:01,560
so as I said we will model macro

00:29:58,560 --> 00:30:04,650
annotations as methods that may or may

00:30:01,560 --> 00:30:07,710
not take parameters and they also take

00:30:04,650 --> 00:30:09,750
the definition that they annotate so in

00:30:07,710 --> 00:30:11,340
the meta block code what happens with

00:30:09,750 --> 00:30:14,910
the structure this definition it is

00:30:11,340 --> 00:30:17,730
definite using the using pattern mention

00:30:14,910 --> 00:30:19,050
with with quasi codes and it's it's

00:30:17,730 --> 00:30:22,250
again a really interesting aspect of

00:30:19,050 --> 00:30:25,860
Scala math it forces us to be mindful of

00:30:22,250 --> 00:30:29,010
very very small language features like

00:30:25,860 --> 00:30:32,580
early initialization or self-type so do

00:30:29,010 --> 00:30:35,970
want to allow early initialization in in

00:30:32,580 --> 00:30:37,530
this in this new app in this new

00:30:35,970 --> 00:30:38,970
replacement for app that's a good

00:30:37,530 --> 00:30:41,490
question and I think it's good that

00:30:38,970 --> 00:30:43,890
Scala meta forces us to think about this

00:30:41,490 --> 00:30:46,560
so then we take the stats that we have

00:30:43,890 --> 00:30:49,020
extracted and we just you know put them

00:30:46,560 --> 00:30:51,060
into the main method and finally we

00:30:49,020 --> 00:30:52,800
replace the body of the object with this

00:30:51,060 --> 00:30:54,990
method so that's just one of the

00:30:52,800 --> 00:30:56,900
strategies of implementing the of

00:30:54,990 --> 00:30:59,490
implementing the new main annotation and

00:30:56,900 --> 00:31:02,070
of course with the Scala method will be

00:30:59,490 --> 00:31:04,410
possible to do whatever you want to just

00:31:02,070 --> 00:31:07,020
take this code apart and reassemble it

00:31:04,410 --> 00:31:09,270
how you see fit so it's very easy to

00:31:07,020 --> 00:31:11,220
experiment with language features and to

00:31:09,270 --> 00:31:13,260
see which which strategy you would like

00:31:11,220 --> 00:31:16,740
to pick before hard-coding it into the

00:31:13,260 --> 00:31:21,200
compiler so now the mandatory demo so

00:31:16,740 --> 00:31:23,880
that we get to take a look how it works

00:31:21,200 --> 00:31:30,210
just to make sure that we're compiling

00:31:23,880 --> 00:31:32,010
the right thing here's the so my Scala

00:31:30,210 --> 00:31:35,160
see a thing is it's actually an alias

00:31:32,010 --> 00:31:37,710
that calls into the macro paradise

00:31:35,160 --> 00:31:39,780
plugin and links to be Scala meta

00:31:37,710 --> 00:31:42,480
library so that we we can make use of

00:31:39,780 --> 00:31:45,750
this Scala meta import so once we

00:31:42,480 --> 00:31:48,930
compile this macro it will think for a

00:31:45,750 --> 00:31:52,200
while because because well we're running

00:31:48,930 --> 00:31:54,240
on the JVM would it be to you know have

00:31:52,200 --> 00:31:56,730
this color compiler compiled using

00:31:54,240 --> 00:31:58,830
all native so definitely the startup

00:31:56,730 --> 00:32:01,440
time and computation times for simple

00:31:58,830 --> 00:32:03,750
applications I hope that they will

00:32:01,440 --> 00:32:05,880
improve I know that Dennis is not going

00:32:03,750 --> 00:32:07,730
to promise anything but I'm just you

00:32:05,880 --> 00:32:10,260
know keeping my fingers crossed

00:32:07,730 --> 00:32:14,370
still very very exciting possibility I

00:32:10,260 --> 00:32:17,429
mean this guy he is very passionate

00:32:14,370 --> 00:32:21,170
about startup time so I know that my

00:32:17,429 --> 00:32:24,720
trust is placed placed rightly

00:32:21,170 --> 00:32:30,570
okay so we just compiled our macros and

00:32:24,720 --> 00:32:34,860
it's time for us to compile the test

00:32:30,570 --> 00:32:38,809
file so we'll provide well the classpath

00:32:34,860 --> 00:32:38,809
is handled by the alias

00:32:38,900 --> 00:32:43,530
well actually we can just you know get a

00:32:41,970 --> 00:32:46,290
sneak peek of the code that gets

00:32:43,530 --> 00:32:48,750
generated here's the secret option that

00:32:46,290 --> 00:32:50,850
allows us to do just that so insert

00:32:48,750 --> 00:32:53,460
ourselves after the after a certain

00:32:50,850 --> 00:32:54,770
phase in the compilation pipeline and we

00:32:53,460 --> 00:32:57,020
should get to see that the code is

00:32:54,770 --> 00:32:59,910
exactly what we needed

00:32:57,020 --> 00:33:02,550
finally and just to verify that I'm not

00:32:59,910 --> 00:33:04,820
cheating you we just run the compiled

00:33:02,550 --> 00:33:07,020
files and get the mandatory hello world

00:33:04,820 --> 00:33:12,420
so all right

00:33:07,020 --> 00:33:14,370
this this this shows that you can do

00:33:12,420 --> 00:33:15,990
quite a lot of stuff in 14 hours if you

00:33:14,370 --> 00:33:17,250
have skull a matter of course without

00:33:15,990 --> 00:33:23,870
skull meta it wouldn't have been

00:33:17,250 --> 00:33:27,320
possible right and in the meanwhile

00:33:23,870 --> 00:33:30,059
Martin wasn't also either

00:33:27,320 --> 00:33:32,809
and it turns out that he he submitted a

00:33:30,059 --> 00:33:36,330
pull request that enables the foundation

00:33:32,809 --> 00:33:37,440
for macro notations and does he and if

00:33:36,330 --> 00:33:41,400
we take a look at the pull request

00:33:37,440 --> 00:33:44,179
because it's quite particular I would

00:33:41,400 --> 00:33:44,179
like to tell you

00:33:48,340 --> 00:33:53,740
okay so we can see that one frog has

00:33:51,910 --> 00:33:57,390
been changed and just one line has been

00:33:53,740 --> 00:34:01,180
moved around so how cool is this right

00:33:57,390 --> 00:34:03,130
because well I can tell you it took me

00:34:01,180 --> 00:34:05,130
much more than 14 hours to implement

00:34:03,130 --> 00:34:07,990
macro annotations for Scala see and

00:34:05,130 --> 00:34:10,180
martin built in one line of code I think

00:34:07,990 --> 00:34:15,220
this is this is a testament of how cool

00:34:10,180 --> 00:34:17,800
those is and the commit message no

00:34:15,220 --> 00:34:22,870
that's just cheating you know oh there

00:34:17,800 --> 00:34:36,750
is a commit message you know this was

00:34:22,870 --> 00:34:40,780
surprisingly easy Congrats Martin okay

00:34:36,750 --> 00:34:42,850
what else do we have now that we've

00:34:40,780 --> 00:34:45,130
talked about the present let's briefly

00:34:42,850 --> 00:34:48,250
talk about the future what's there in

00:34:45,130 --> 00:34:52,270
the future of Scala meta and how this

00:34:48,250 --> 00:34:55,240
look like well I would like to talk

00:34:52,270 --> 00:34:57,520
about several of our users even even

00:34:55,240 --> 00:35:00,130
though our version number is currently

00:34:57,520 --> 00:35:03,160
starting with zero and the until today

00:35:00,130 --> 00:35:06,910
it was starting with 0.0 which is quite

00:35:03,160 --> 00:35:11,110
weird we already have users that's

00:35:06,910 --> 00:35:14,590
amazing so first I would like to talk

00:35:11,110 --> 00:35:17,710
about coda see a code analysis start-up

00:35:14,590 --> 00:35:22,920
they've changed the the you are let's

00:35:17,710 --> 00:35:22,920
knead and now we now we're gonna login

00:35:23,070 --> 00:35:27,180
it's great we have Internet

00:35:29,640 --> 00:35:41,670
and try to see what code patterns that

00:35:32,790 --> 00:35:44,130
they provide so actually so actually

00:35:41,670 --> 00:35:46,230
Kota see they do a number of code

00:35:44,130 --> 00:35:47,970
analysis on projects that they fetch

00:35:46,230 --> 00:35:49,680
from github and the among the languages

00:35:47,970 --> 00:35:51,780
that they support they support Scala

00:35:49,680 --> 00:35:57,510
so these code analysis they're

00:35:51,780 --> 00:35:59,460
implemented with the patterns and well

00:35:57,510 --> 00:36:01,020
there's a bunch of them some of these

00:35:59,460 --> 00:36:04,770
code analysis they're built on top of

00:36:01,020 --> 00:36:06,180
Scala meta and what is just gonna take a

00:36:04,770 --> 00:36:09,060
look at how this works

00:36:06,180 --> 00:36:12,120
so they've actually built together with

00:36:09,060 --> 00:36:14,100
module one of one of our master students

00:36:12,120 --> 00:36:16,140
they've built this great you are and

00:36:14,100 --> 00:36:20,310
this integration of Scala Matt into

00:36:16,140 --> 00:36:22,230
their platform so to the right know

00:36:20,310 --> 00:36:25,950
whether I'll be able to increase the

00:36:22,230 --> 00:36:26,640
font much so can you guys see that all

00:36:25,950 --> 00:36:29,220
right cool

00:36:26,640 --> 00:36:32,310
so to the right you can see code that

00:36:29,220 --> 00:36:35,190
uses Scala meta in order to find certain

00:36:32,310 --> 00:36:37,710
undesired patterns in the codebase so

00:36:35,190 --> 00:36:39,870
here we're looking for you know option

00:36:37,710 --> 00:36:42,420
to get writer don't get so if you think

00:36:39,870 --> 00:36:45,270
that this pattern is naive it is a

00:36:42,420 --> 00:36:47,880
little bit and I'll talk about it later

00:36:45,270 --> 00:36:51,000
but let's see what what's going on here

00:36:47,880 --> 00:36:54,300
so we see that these quasi quote queue

00:36:51,000 --> 00:36:57,480
of some or something get it detects

00:36:54,300 --> 00:36:59,730
calls to option get methods or either

00:36:57,480 --> 00:37:03,720
get methods and then on the left hand

00:36:59,730 --> 00:37:06,450
side you have your your test your test

00:37:03,720 --> 00:37:08,520
in it a snippet and then you you can

00:37:06,450 --> 00:37:10,680
take a look at the messages that are

00:37:08,520 --> 00:37:13,020
produced in the diagnostic so I think

00:37:10,680 --> 00:37:14,970
it's it's all quite neat and I'm

00:37:13,020 --> 00:37:20,820
definitely happy that Scala meta is used

00:37:14,970 --> 00:37:23,880
for this not one of the reasons was the

00:37:20,820 --> 00:37:26,760
comprehensive data model for a STS that

00:37:23,880 --> 00:37:29,220
that I've been showing off recently so

00:37:26,760 --> 00:37:31,790
it's not it's not some academic exercise

00:37:29,220 --> 00:37:35,130
some you know academic curiosity but

00:37:31,790 --> 00:37:38,910
actually it is the exclusive feature of

00:37:35,130 --> 00:37:40,770
Scala meta that this this rich model of

00:37:38,910 --> 00:37:41,430
the skull language is available right

00:37:40,770 --> 00:37:45,990
now

00:37:41,430 --> 00:37:48,750
it's so easy to use so that's that's one

00:37:45,990 --> 00:37:54,839
use case another use case is a is a more

00:37:48,750 --> 00:37:57,240
recent user of Scala meta all of one of

00:37:54,839 --> 00:37:59,220
our one of our master students so here

00:37:57,240 --> 00:38:02,790
all of his currently right in his master

00:37:59,220 --> 00:38:05,130
feels and for that he he did a very cool

00:38:02,790 --> 00:38:07,609
tool that's called Scala fmt so recently

00:38:05,130 --> 00:38:11,760
he gave a talk at flatmap about that and

00:38:07,609 --> 00:38:14,940
what this tool can do is take a source

00:38:11,760 --> 00:38:16,950
file parse it with Scala madam take a

00:38:14,940 --> 00:38:19,470
source file what looks like a mess here

00:38:16,950 --> 00:38:22,410
parse it and then reformat it

00:38:19,470 --> 00:38:25,710
automatically to conform to to some

00:38:22,410 --> 00:38:28,559
chosen style so I won't go into details

00:38:25,710 --> 00:38:30,930
because all of has given like a big talk

00:38:28,559 --> 00:38:33,180
about that and I think they've published

00:38:30,930 --> 00:38:36,000
videos yesterday so if you're interested

00:38:33,180 --> 00:38:38,190
just Google Scholar from T and flatmap

00:38:36,000 --> 00:38:41,550
I really really would recommend looking

00:38:38,190 --> 00:38:45,150
this looking at this so it's a it's a

00:38:41,550 --> 00:38:48,450
really cool project the shows that next

00:38:45,150 --> 00:38:50,369
generation tools they can they can

00:38:48,450 --> 00:38:52,349
appear if we have the right foundation

00:38:50,369 --> 00:38:56,549
for that which is call a matter of

00:38:52,349 --> 00:38:59,160
course all right so we have called the

00:38:56,549 --> 00:39:02,130
see we have Scala FM see we've seen how

00:38:59,160 --> 00:39:04,530
how you can build inline macros on top

00:39:02,130 --> 00:39:07,200
of Scala meta and finally this is

00:39:04,530 --> 00:39:09,480
something that's this should be familiar

00:39:07,200 --> 00:39:12,299
to you from yesterday if you attended

00:39:09,480 --> 00:39:14,280
the talk of my colleague me tree so

00:39:12,299 --> 00:39:16,589
there's this cool tool called dot e

00:39:14,280 --> 00:39:18,869
linker which does whole program

00:39:16,589 --> 00:39:22,740
optimizations for for the dot e compiler

00:39:18,869 --> 00:39:24,750
and recently the feature that meteor

00:39:22,740 --> 00:39:28,109
recently introduced is rewriting rules

00:39:24,750 --> 00:39:30,569
it's possible using the technologies

00:39:28,109 --> 00:39:31,980
that think that the linker provides to

00:39:30,569 --> 00:39:33,390
specify certain patterns and then

00:39:31,980 --> 00:39:37,260
rewrite them into something else

00:39:33,390 --> 00:39:40,140
so here the the mesh with the

00:39:37,260 --> 00:39:41,730
Scala meta was was pretty obvious so

00:39:40,140 --> 00:39:44,190
it's possible it's possible to take a

00:39:41,730 --> 00:39:46,319
pattern and then to run some custom code

00:39:44,190 --> 00:39:48,900
to do meta programming to produce the

00:39:46,319 --> 00:39:51,990
result so please take a look at the

00:39:48,900 --> 00:39:54,119
slides of dimitri stock the talk was

00:39:51,990 --> 00:39:54,750
called precise precise types bring

00:39:54,119 --> 00:39:56,700
performance

00:39:54,750 --> 00:39:59,220
Dimitri has already published the slides

00:39:56,700 --> 00:40:02,600
and please ask him if you have if you

00:39:59,220 --> 00:40:06,630
have other questions alright so now to

00:40:02,600 --> 00:40:10,590
not so fun stuff it's a it's a really

00:40:06,630 --> 00:40:15,360
great picture from PhD comics a website

00:40:10,590 --> 00:40:17,970
that I frequent well actually if someone

00:40:15,360 --> 00:40:19,770
has been around for the 5 years history

00:40:17,970 --> 00:40:22,290
of this Kalamata project they may

00:40:19,770 --> 00:40:25,380
remember that it is beginning it was my

00:40:22,290 --> 00:40:27,510
beginning of the PhD thesis at EPFL

00:40:25,380 --> 00:40:30,420
under under the supervision of Martin

00:40:27,510 --> 00:40:32,640
and well five years are almost over and

00:40:30,420 --> 00:40:35,550
I'm not ready 8 so I should write the

00:40:32,640 --> 00:40:37,830
thesis wrap up and then jump to industry

00:40:35,550 --> 00:40:40,290
right I don't know some applications in

00:40:37,830 --> 00:40:44,130
c-sharp and Java and now never syscall

00:40:40,290 --> 00:40:45,900
again so what's going to happen with all

00:40:44,130 --> 00:40:48,840
those things that I presented there you

00:40:45,900 --> 00:40:51,870
know it's Cal fmt going to be cancelled

00:40:48,840 --> 00:40:57,090
our macros really gonna go in a way so

00:40:51,870 --> 00:40:58,470
well actually not this this winter I was

00:40:57,090 --> 00:41:00,630
thinking what to do next

00:40:58,470 --> 00:41:03,260
and how to continue the projects that

00:41:00,630 --> 00:41:06,930
I'm really passionate about macros and

00:41:03,260 --> 00:41:11,580
Scala meta and I approach different

00:41:06,930 --> 00:41:13,200
companies and ultimately Twitter they

00:41:11,580 --> 00:41:16,430
made me an offer that I could not refuse

00:41:13,200 --> 00:41:19,320
so later on this fall I'll be continuing

00:41:16,430 --> 00:41:23,250
I'll be continuing the stuff that that I

00:41:19,320 --> 00:41:25,110
was doing doing my open source open

00:41:23,250 --> 00:41:28,050
source development a partially sponsored

00:41:25,110 --> 00:41:29,850
by Twitter it's it's a really a really

00:41:28,050 --> 00:41:31,800
cool arrangement that we arrived at so

00:41:29,850 --> 00:41:34,800
the towels still be able to do open

00:41:31,800 --> 00:41:38,880
source development during paid time and

00:41:34,800 --> 00:41:40,680
so as a result just to sum it up so the

00:41:38,880 --> 00:41:42,870
project is officially endorsed it's

00:41:40,680 --> 00:41:46,200
alive and thanks to Twitter it's also

00:41:42,870 --> 00:41:49,650
funded so I think it has a bright future

00:41:46,200 --> 00:41:51,710
and we have users and we have really

00:41:49,650 --> 00:41:53,570
cool features so please try it out and

00:41:51,710 --> 00:41:56,720
approach me if you have more questions

00:41:53,570 --> 00:41:56,720
thank you

00:42:01,799 --> 00:42:08,140
alright I think we've used most of our

00:42:04,419 --> 00:42:09,099
time if I'm not mistaken so I can take

00:42:08,140 --> 00:42:15,419
one question

00:42:09,099 --> 00:42:15,419
maksoon all right please

00:42:18,369 --> 00:42:22,989
so the the question is what are we gonna

00:42:20,890 --> 00:42:25,749
add in Scala meta to what kind of

00:42:22,989 --> 00:42:28,930
semantic API we have in mind well the

00:42:25,749 --> 00:42:31,509
moment it's things are still in flux so

00:42:28,930 --> 00:42:33,880
I wouldn't want to promise what will

00:42:31,509 --> 00:42:35,799
change and what we cannot deliver but

00:42:33,880 --> 00:42:37,749
the main idea to have Fisher parity with

00:42:35,799 --> 00:42:40,689
Scala reflect so with sky reflect you

00:42:37,749 --> 00:42:43,689
can resolve names you can list members

00:42:40,689 --> 00:42:46,420
of a given type you can see type

00:42:43,689 --> 00:42:48,910
signatures of methods so this is the

00:42:46,420 --> 00:42:52,390
basic stuff and all of that almost all

00:42:48,910 --> 00:42:54,939
of that is used by but by two authors by

00:42:52,390 --> 00:42:56,949
macro writers so I think it's it's

00:42:54,939 --> 00:42:59,979
imperative that we leave this in so I

00:42:56,949 --> 00:43:03,369
think we really another key feature of

00:42:59,979 --> 00:43:05,619
Scala meta is ste persistence that it'll

00:43:03,369 --> 00:43:07,209
be possible to take these trees with all

00:43:05,619 --> 00:43:08,739
the semantic information with all the

00:43:07,209 --> 00:43:10,900
types and all resolved names and then

00:43:08,739 --> 00:43:15,449
save them so that later your tools or

00:43:10,900 --> 00:43:18,189
what-have-you can inspect them so that's

00:43:15,449 --> 00:43:21,219
basically the short overview of Scala

00:43:18,189 --> 00:43:24,429
meta app version two okay on this

00:43:21,219 --> 00:43:27,779
optimistic notes let's finish our chat

00:43:24,429 --> 00:43:27,779

YouTube URL: https://www.youtube.com/watch?v=wii5UPtu1_g


