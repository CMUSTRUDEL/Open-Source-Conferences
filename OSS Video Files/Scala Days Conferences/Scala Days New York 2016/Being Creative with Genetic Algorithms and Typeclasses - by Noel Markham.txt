Title: Being Creative with Genetic Algorithms and Typeclasses - by Noel Markham
Publication date: 2016-06-17
Playlist: Scala Days New York 2016
Description: 
	This talk was recorded at Scala Days New York, 2016. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
Typeclasses are a hidden gem of the Scala language. They provide an immense power not seen in imperative languages, and so their approach might be unusual or alien to those approaching Scala from an imperative background. I will show how typeclasses allow developers to effectively attach their own interfaces to code written by others. In this talk, I describe what a genetic algorithm is and provide an example implementation in Scala. Using this implementation, I will demonstrate how to define a specific typeclass for our problem. I will then derive several different implementations, showing how to get rock solid confidence in testing our algorithm - with the help of ScalaCheck - and then provide a completely different typeclass to provide a fun, visual and creative solution, illustrating the iterations and improvements as the genetic algorithmâ€™s fitness function runs. The talk will be particularly hands-on, with plenty of examples run directly from the REPL.
Captions: 
	00:00:00,000 --> 00:00:06,450
I thanks thanks very much for coming my

00:00:03,929 --> 00:00:07,589
name is null I know and I'd have

00:00:06,450 --> 00:00:10,500
recognized a few people in the audience

00:00:07,589 --> 00:00:12,509
and spoke a few people here so thanks

00:00:10,500 --> 00:00:14,880
thanks very much for coming everyone

00:00:12,509 --> 00:00:16,440
having a good time yeah it's been it's

00:00:14,880 --> 00:00:20,460
been a great couple of days isn't it so

00:00:16,440 --> 00:00:23,369
um so I what I'm going to show today is

00:00:20,460 --> 00:00:25,830
is kind of something I tried to have a

00:00:23,369 --> 00:00:28,500
bit of fun with I've done a few I've

00:00:25,830 --> 00:00:30,000
done a few talks in the past and they've

00:00:28,500 --> 00:00:31,619
always been I wouldn't say they were dry

00:00:30,000 --> 00:00:34,500
but they've always been a bit like

00:00:31,619 --> 00:00:36,090
here's how you do something or you know

00:00:34,500 --> 00:00:38,280
these are the rules you need to do to

00:00:36,090 --> 00:00:39,719
make this work and this is how it's

00:00:38,280 --> 00:00:42,360
different in scarlet and stuff like that

00:00:39,719 --> 00:00:43,829
so I thought I thought I'd try something

00:00:42,360 --> 00:00:47,430
a bit different and have a bit of fun

00:00:43,829 --> 00:00:50,039
and i'll try and teach what type classes

00:00:47,430 --> 00:00:51,059
are along the way maybe maybe some

00:00:50,039 --> 00:00:53,370
people in the room already know what

00:00:51,059 --> 00:00:55,289
they are hopefully hopefully this will

00:00:53,370 --> 00:00:58,680
give a bit of give a bit of a grounding

00:00:55,289 --> 00:01:00,989
and as always you know if you're really

00:00:58,680 --> 00:01:02,190
stuck if you're really not sure what's

00:01:00,989 --> 00:01:04,260
going on you know please let me know

00:01:02,190 --> 00:01:06,060
like I'd rather I'd rather not get to

00:01:04,260 --> 00:01:07,890
the end of this talk and people

00:01:06,060 --> 00:01:09,299
understood it then I just whizzed

00:01:07,890 --> 00:01:12,479
through it and everyone has no idea what

00:01:09,299 --> 00:01:15,000
I'm talking about yes I work for a

00:01:12,479 --> 00:01:16,890
company called 47 degrees we've got

00:01:15,000 --> 00:01:18,810
these fetching fetching red sweaters

00:01:16,890 --> 00:01:22,110
we've got the booth out out in the front

00:01:18,810 --> 00:01:24,360
so we we concentrate on consulting and

00:01:22,110 --> 00:01:25,920
training and development and if that's

00:01:24,360 --> 00:01:28,110
something of interest you come and speak

00:01:25,920 --> 00:01:29,640
to me afterwards or or pop along to the

00:01:28,110 --> 00:01:33,479
booth where we're here for the rest of

00:01:29,640 --> 00:01:36,509
the day okay right so we're going to

00:01:33,479 --> 00:01:38,909
talk about so the the premise of this

00:01:36,509 --> 00:01:42,420
talk is trying to describe what type

00:01:38,909 --> 00:01:44,759
classes are and i want to i want to show

00:01:42,420 --> 00:01:46,380
this in an interesting way so i'm really

00:01:44,759 --> 00:01:47,490
i'm going to split the talk into three

00:01:46,380 --> 00:01:49,470
so we're going to spend a little bit of

00:01:47,490 --> 00:01:52,560
time trying to understand what a type

00:01:49,470 --> 00:01:55,079
classes and and how they work we'll then

00:01:52,560 --> 00:01:58,950
step aside and i have a look at what

00:01:55,079 --> 00:02:00,299
genetic algorithms are and then i'm

00:01:58,950 --> 00:02:03,659
going to try and match the two together

00:02:00,299 --> 00:02:04,649
somehow yeah can read that ok I'm going

00:02:03,659 --> 00:02:06,960
to try and match the two together

00:02:04,649 --> 00:02:09,360
somehow and we'll try and be a bit

00:02:06,960 --> 00:02:12,690
creative and show how they the to work

00:02:09,360 --> 00:02:13,830
quite well together okay so start what

00:02:12,690 --> 00:02:16,200
exactly is a type class

00:02:13,830 --> 00:02:18,180
if you if you google around if you ask

00:02:16,200 --> 00:02:21,420
the wrong people you get phrases like

00:02:18,180 --> 00:02:22,530
this it's like a polymorphism you know

00:02:21,420 --> 00:02:25,980
what else you need to know all right

00:02:22,530 --> 00:02:29,490
let's move on okay so all right so let's

00:02:25,980 --> 00:02:33,120
let's take a step back where where do we

00:02:29,490 --> 00:02:35,340
start with this so like myself and I

00:02:33,120 --> 00:02:37,710
imagine a lot of you are I'm primarily

00:02:35,340 --> 00:02:39,270
well I came from a Java background I've

00:02:37,710 --> 00:02:42,390
been doing Scala now for about three

00:02:39,270 --> 00:02:44,670
years and before that I was full-on in

00:02:42,390 --> 00:02:46,590
the in the enterprise Java world so I

00:02:44,670 --> 00:02:49,740
thought a nice place to start would

00:02:46,590 --> 00:02:53,280
actually be back back in Java land okay

00:02:49,740 --> 00:02:56,870
so let's see how how Java can can relate

00:02:53,280 --> 00:02:59,730
to what a type classes ok so if just a

00:02:56,870 --> 00:03:01,650
people here familiar with Java you come

00:02:59,730 --> 00:03:04,980
from a Java background yeah okay people

00:03:01,650 --> 00:03:06,290
not okay all right well hopefully this

00:03:04,980 --> 00:03:08,340
won't be this won't be too daunting

00:03:06,290 --> 00:03:10,620
there's nothing particularly Java

00:03:08,340 --> 00:03:12,930
specific here but i just want to show

00:03:10,620 --> 00:03:15,570
the relationship between the two so if

00:03:12,930 --> 00:03:18,560
we look at the the arrays class in Java

00:03:15,570 --> 00:03:21,239
it's got this static method on it here

00:03:18,560 --> 00:03:22,470
so those not familiar with this is that

00:03:21,239 --> 00:03:25,590
all we're saying here is we've got this

00:03:22,470 --> 00:03:28,560
method called sort it's its generic

00:03:25,590 --> 00:03:31,739
parameter eyes don t takes an array of

00:03:28,560 --> 00:03:34,890
teas and something called a comparator

00:03:31,739 --> 00:03:36,750
which is parameterize don t and and you

00:03:34,890 --> 00:03:40,530
can imagine what this does is this this

00:03:36,750 --> 00:03:42,269
sorts an array so the fact its generic

00:03:40,530 --> 00:03:44,040
means that we don't really know what's

00:03:42,269 --> 00:03:45,510
going to be in this array we don't know

00:03:44,040 --> 00:03:49,170
if we're going to be sorting strings or

00:03:45,510 --> 00:03:52,070
numbers or bananas or trains I you just

00:03:49,170 --> 00:03:55,320
don't know so this extra parameter here

00:03:52,070 --> 00:03:58,680
the this is this is basically a rule for

00:03:55,320 --> 00:04:01,170
how to how to compare two things of this

00:03:58,680 --> 00:04:02,459
type T and then and then that should

00:04:01,170 --> 00:04:03,780
hopefully be enough you know if you can

00:04:02,459 --> 00:04:06,450
compare two things you've got enough

00:04:03,780 --> 00:04:08,340
information there to sort them so the

00:04:06,450 --> 00:04:11,340
correct the comparator has this method

00:04:08,340 --> 00:04:14,040
here called compare returns an integer

00:04:11,340 --> 00:04:16,500
it takes two things of tea and returns

00:04:14,040 --> 00:04:19,410
an integer so it's probably not the best

00:04:16,500 --> 00:04:21,150
interface ever written but you can

00:04:19,410 --> 00:04:23,490
imagine if the two teas are the same

00:04:21,150 --> 00:04:26,520
then the the integer is going to be zero

00:04:23,490 --> 00:04:27,690
if one T is less than the other T

00:04:26,520 --> 00:04:29,280
whatever that means they

00:04:27,690 --> 00:04:34,230
and they'll probably be negative and

00:04:29,280 --> 00:04:36,480
vice versa will be positive and so we

00:04:34,230 --> 00:04:39,210
can use these with our own types and so

00:04:36,480 --> 00:04:42,330
I created what what we used to call

00:04:39,210 --> 00:04:44,940
pojos there's nothing there's nothing

00:04:42,330 --> 00:04:46,350
magical here all I wanted to do was just

00:04:44,940 --> 00:04:48,720
have something that's not in the

00:04:46,350 --> 00:04:50,730
standard library so it's my own type all

00:04:48,720 --> 00:04:52,640
it does is hold an integer and we know

00:04:50,730 --> 00:04:55,860
we know how to compare integers but

00:04:52,640 --> 00:04:58,320
clearly clearly nobody knows how to sort

00:04:55,860 --> 00:05:01,380
in told us apart from us because well

00:04:58,320 --> 00:05:02,700
apart from me because I wrote it but we

00:05:01,380 --> 00:05:06,420
want it we want to use this sort method

00:05:02,700 --> 00:05:08,040
to do this so we need to create our own

00:05:06,420 --> 00:05:11,640
comparator and that'll look something

00:05:08,040 --> 00:05:13,160
like this so we implement this we

00:05:11,640 --> 00:05:15,690
implement this comparator interface

00:05:13,160 --> 00:05:17,640
we've got compared look it takes to int

00:05:15,690 --> 00:05:19,620
older types so we're actually being

00:05:17,640 --> 00:05:22,530
typed safe here you know that we can't

00:05:19,620 --> 00:05:25,710
compare an int holder with string or a

00:05:22,530 --> 00:05:27,030
like set of banana but we know that when

00:05:25,710 --> 00:05:28,770
we want to compare these things we're

00:05:27,030 --> 00:05:31,170
only ever going to be using this given

00:05:28,770 --> 00:05:33,480
type here and then this code here is

00:05:31,170 --> 00:05:36,300
what we need to do in order to compare

00:05:33,480 --> 00:05:38,730
the two so now we can sort collections

00:05:36,300 --> 00:05:39,990
using our own type okay and this would

00:05:38,730 --> 00:05:42,900
look something like this and i'm back in

00:05:39,990 --> 00:05:45,810
the scholar Apple here so we take an

00:05:42,900 --> 00:05:48,960
array of these in holders and then we

00:05:45,810 --> 00:05:50,490
call sort and of course it's mutable but

00:05:48,960 --> 00:05:52,320
then when we go and inspect with the

00:05:50,490 --> 00:05:54,210
value we see that they've been sorted

00:05:52,320 --> 00:05:56,490
and you know if we had a larger array

00:05:54,210 --> 00:05:57,900
which would fit on the slide then you

00:05:56,490 --> 00:05:59,550
know it would show sure they sorted

00:05:57,900 --> 00:06:01,860
butter and the nice thing is here is

00:05:59,550 --> 00:06:05,490
that because we've got our own our own

00:06:01,860 --> 00:06:07,860
rule here is that we get when we sort

00:06:05,490 --> 00:06:10,290
this array we get to decide how it gets

00:06:07,860 --> 00:06:12,450
sorted so there's no there's no default

00:06:10,290 --> 00:06:14,160
or there's no magic here if we want this

00:06:12,450 --> 00:06:16,140
in Reverse we can create a new

00:06:14,160 --> 00:06:19,260
comparator here that sorts them in

00:06:16,140 --> 00:06:21,780
reverse if we want to separate odds and

00:06:19,260 --> 00:06:24,419
evens we might be able to do that that

00:06:21,780 --> 00:06:26,070
way you know we can sort things however

00:06:24,419 --> 00:06:28,350
we want you know if we are doing strings

00:06:26,070 --> 00:06:30,720
we might want to sort by length of

00:06:28,350 --> 00:06:32,970
string rather than alphabetical order or

00:06:30,720 --> 00:06:36,450
something like that so really the power

00:06:32,970 --> 00:06:38,280
is given back to the developer here and

00:06:36,450 --> 00:06:40,320
actually this this itself is actually

00:06:38,280 --> 00:06:42,120
what a type classes is that we've them

00:06:40,320 --> 00:06:45,180
we've separated out

00:06:42,120 --> 00:06:47,190
are our type definition from the

00:06:45,180 --> 00:06:49,229
behavior in which we we want and then

00:06:47,190 --> 00:06:51,300
we've got this method here that saying

00:06:49,229 --> 00:06:52,919
well if you want to sort something of

00:06:51,300 --> 00:06:56,040
your own type you need to tell me the

00:06:52,919 --> 00:06:58,320
rules of how to do it okay so let's

00:06:56,040 --> 00:07:01,380
let's go back to a maybe a slightly more

00:06:58,320 --> 00:07:05,070
familiar familiar scene and we'll look

00:07:01,380 --> 00:07:06,600
at how this works in Scala and I'm not

00:07:05,070 --> 00:07:08,699
actually going to provide any anything

00:07:06,600 --> 00:07:11,419
new here and this this example was

00:07:08,699 --> 00:07:14,520
lifted completely from Martins paper

00:07:11,419 --> 00:07:16,080
introducing type classes into scholar I

00:07:14,520 --> 00:07:19,229
put the link up there i'll send the

00:07:16,080 --> 00:07:21,419
slides around afterwards ok so we've got

00:07:19,229 --> 00:07:24,150
it we've got a trait here called odd

00:07:21,419 --> 00:07:25,650
it's parameterize don t it's very

00:07:24,150 --> 00:07:28,710
similar to what we just saw in Java

00:07:25,650 --> 00:07:30,060
we've got a couple of teas here instead

00:07:28,710 --> 00:07:33,690
of an integer this time we've got a

00:07:30,060 --> 00:07:35,280
boolean so again might not be the best

00:07:33,690 --> 00:07:37,260
interface ever written but you know we

00:07:35,280 --> 00:07:39,360
can work with it you know we know if

00:07:37,260 --> 00:07:42,539
those two teas are the same then it's

00:07:39,360 --> 00:07:44,490
going to return true and so what we want

00:07:42,539 --> 00:07:46,860
to do when we want to use a norden an

00:07:44,490 --> 00:07:50,039
odd we need to create an awed instance

00:07:46,860 --> 00:07:51,000
for our specific type so if we want to

00:07:50,039 --> 00:07:54,539
work with integers it would look

00:07:51,000 --> 00:07:58,139
something like this parameterised on int

00:07:54,539 --> 00:08:00,960
and then we've got our the parameters to

00:07:58,139 --> 00:08:03,060
our method take int and then we need to

00:08:00,960 --> 00:08:04,590
do whatever will we know because we're

00:08:03,060 --> 00:08:07,320
writing this instance we know how to

00:08:04,590 --> 00:08:10,919
work with int and we know what to do to

00:08:07,320 --> 00:08:12,240
see if they are the same and then once

00:08:10,919 --> 00:08:13,979
we've got this we can use this where

00:08:12,240 --> 00:08:16,800
necessary so we can write our own sort

00:08:13,979 --> 00:08:18,599
method here and so I've skipped the

00:08:16,800 --> 00:08:21,270
implementation because it's not really

00:08:18,599 --> 00:08:24,060
of interest here but so our sort method

00:08:21,270 --> 00:08:26,250
is parameterised again aunties and we

00:08:24,060 --> 00:08:27,660
take a list of anything but then we also

00:08:26,250 --> 00:08:29,970
have a second parameter list of

00:08:27,660 --> 00:08:31,770
orderings and what we're saying here is

00:08:29,970 --> 00:08:34,349
that when we sort this we've got a rule

00:08:31,770 --> 00:08:38,310
and this is the rule to use for when you

00:08:34,349 --> 00:08:40,409
want to to order lists and so we can

00:08:38,310 --> 00:08:43,050
just use this as so we give it a list

00:08:40,409 --> 00:08:47,400
like this we use our ordering and it

00:08:43,050 --> 00:08:49,650
works like like it should but a bit like

00:08:47,400 --> 00:08:51,630
the Java when I was showing a minute ago

00:08:49,650 --> 00:08:53,100
that it's a bit cumbersome you know

00:08:51,630 --> 00:08:54,520
we've got this kind of backpack we've

00:08:53,100 --> 00:08:57,100
got to carry around of

00:08:54,520 --> 00:08:58,420
if we want to order integers we need to

00:08:57,100 --> 00:09:00,370
have that if we want to order strings

00:08:58,420 --> 00:09:02,290
we've got to go and have we've got to go

00:09:00,370 --> 00:09:04,180
and find the ordering for strings and

00:09:02,290 --> 00:09:07,750
pass that into the sort method as well

00:09:04,180 --> 00:09:10,240
so Scarlett provides this nice mechanism

00:09:07,750 --> 00:09:12,640
foot fur and kind of removing a lot of

00:09:10,240 --> 00:09:15,010
the noise from this this method call and

00:09:12,640 --> 00:09:18,100
so will do exactly what we did is before

00:09:15,010 --> 00:09:21,970
but we're going to mark this this

00:09:18,100 --> 00:09:24,640
instance as implicit and then our

00:09:21,970 --> 00:09:26,980
implementation is the same except this

00:09:24,640 --> 00:09:30,310
second parameter list is also marked as

00:09:26,980 --> 00:09:33,310
implicit and then whenever whenever we

00:09:30,310 --> 00:09:35,980
want to call sort the compiler will try

00:09:33,310 --> 00:09:38,650
and find the ordering that's marked as

00:09:35,980 --> 00:09:40,300
implicit for our given type and if it

00:09:38,650 --> 00:09:42,910
can find it it will compile and run this

00:09:40,300 --> 00:09:44,730
method okay and we can see this is so

00:09:42,910 --> 00:09:47,220
and this seems to be a little bit more

00:09:44,730 --> 00:09:49,060
intuitive I've added this type I'm

00:09:47,220 --> 00:09:51,160
annotation here but it's not actually

00:09:49,060 --> 00:09:52,630
strictly necessary is that the compiler

00:09:51,160 --> 00:09:54,610
can work out that we're dealing with a

00:09:52,630 --> 00:09:56,770
list of integers and it will then go and

00:09:54,610 --> 00:10:00,880
find this in toward type type class

00:09:56,770 --> 00:10:02,740
instance we have and so if there's no

00:10:00,880 --> 00:10:04,600
implicit in scope here if we're dealing

00:10:02,740 --> 00:10:07,030
with the scenario I've just shown and

00:10:04,600 --> 00:10:09,040
we've not seen an in toward for four

00:10:07,030 --> 00:10:13,240
strings what what do you think is going

00:10:09,040 --> 00:10:14,800
to happen here any ideas yeah yeah we go

00:10:13,240 --> 00:10:16,900
we got a compiler error so that's really

00:10:14,800 --> 00:10:19,060
nice so again there's no magic here

00:10:16,900 --> 00:10:21,130
there's there's nothing going on behind

00:10:19,060 --> 00:10:23,320
the scenes there's no default it's not

00:10:21,130 --> 00:10:25,270
like it does nothing the compiler saying

00:10:23,320 --> 00:10:27,670
I don't know what to do here you've not

00:10:25,270 --> 00:10:30,370
told me how to sort strings you need to

00:10:27,670 --> 00:10:32,200
tell me and I can't carry on so that I

00:10:30,370 --> 00:10:34,360
think that's really quite nice and

00:10:32,200 --> 00:10:37,180
basically that's it that's what a type

00:10:34,360 --> 00:10:40,180
class is so if we try and make this a

00:10:37,180 --> 00:10:42,940
little bit more general it's it's an

00:10:40,180 --> 00:10:45,490
implicit parameter that itself is

00:10:42,940 --> 00:10:47,710
parameterised and this is the kind of

00:10:45,490 --> 00:10:50,080
pattern you often see so you have a

00:10:47,710 --> 00:10:52,330
function which takes a type parameter

00:10:50,080 --> 00:10:54,160
yeah it's going to take some parameters

00:10:52,330 --> 00:10:56,560
and then it's going to have some in

00:10:54,160 --> 00:10:59,410
implicit parameter on the list as well

00:10:56,560 --> 00:11:02,230
and then that that's our type class and

00:10:59,410 --> 00:11:04,990
then we know then that as long as we

00:11:02,230 --> 00:11:08,110
have an implicit of this type for this

00:11:04,990 --> 00:11:10,329
type in scope then this will work

00:11:08,110 --> 00:11:13,839
once you notice this you start to see

00:11:10,329 --> 00:11:16,480
this pattern everywhere and what what

00:11:13,839 --> 00:11:18,579
the way to think about this often is you

00:11:16,480 --> 00:11:21,550
can view this as like enhancing types is

00:11:18,579 --> 00:11:23,709
that we're effectively adding our own

00:11:21,550 --> 00:11:28,329
interface on to someone else's types

00:11:23,709 --> 00:11:30,790
when the integer class was written wait

00:11:28,329 --> 00:11:32,740
note the odd class may not have been

00:11:30,790 --> 00:11:34,899
written at the same time they are

00:11:32,740 --> 00:11:37,990
completely separate but we now have this

00:11:34,899 --> 00:11:39,970
mechanism for for any given type being

00:11:37,990 --> 00:11:42,640
able to provide functionality that works

00:11:39,970 --> 00:11:44,350
with it so like like I showed with the

00:11:42,640 --> 00:11:46,630
jug wine if we just create a type out of

00:11:44,350 --> 00:11:48,190
thin air is that it will still work with

00:11:46,630 --> 00:11:49,810
these library functions that have been

00:11:48,190 --> 00:11:52,029
written by someone else at another time

00:11:49,810 --> 00:11:54,190
just because we have the right mechanism

00:11:52,029 --> 00:11:56,470
and the right rules for doing so it

00:11:54,190 --> 00:11:57,700
really is just like adding an interface

00:11:56,470 --> 00:12:00,550
on to something that's already been

00:11:57,700 --> 00:12:03,310
written you know if you think back to to

00:12:00,550 --> 00:12:05,649
the Java days is that if apart from the

00:12:03,310 --> 00:12:08,560
example I've shown is that often you'd

00:12:05,649 --> 00:12:10,089
have to expect to type to maybe extend

00:12:08,560 --> 00:12:12,070
or implement an interface such as

00:12:10,089 --> 00:12:14,920
comparable in order to use it in a

00:12:12,070 --> 00:12:17,079
particular particular function for

00:12:14,920 --> 00:12:18,399
sorting or ordering but but we don't

00:12:17,079 --> 00:12:20,949
need to do that you know we've got this

00:12:18,399 --> 00:12:24,459
really nice mechanism here of separating

00:12:20,949 --> 00:12:28,230
out the type itself from the behavior we

00:12:24,459 --> 00:12:31,089
need okay so got a few other examples

00:12:28,230 --> 00:12:33,279
that you may be may be familiar with so

00:12:31,089 --> 00:12:35,730
we will play Jason reads and reads

00:12:33,279 --> 00:12:38,740
itself is actually a type class and so

00:12:35,730 --> 00:12:40,660
you start to see functions that are

00:12:38,740 --> 00:12:42,570
often written like this I actually

00:12:40,660 --> 00:12:45,070
pulled this straight off the

00:12:42,570 --> 00:12:47,860
documentation so we want to drill

00:12:45,070 --> 00:12:50,500
through some Jason to a field called

00:12:47,860 --> 00:12:52,300
name and then we can call read whether I

00:12:50,500 --> 00:12:55,480
don't know a person type I just made

00:12:52,300 --> 00:13:01,690
this one up and then as long as there's

00:12:55,480 --> 00:13:03,880
a reads type for person then play knows

00:13:01,690 --> 00:13:06,550
exactly what to do in order to convert

00:13:03,880 --> 00:13:08,350
jason into a person object so that's

00:13:06,550 --> 00:13:10,420
really quite nice and then if actually

00:13:08,350 --> 00:13:12,610
if you drill down and look at how this

00:13:10,420 --> 00:13:14,050
is implemented it's just a function like

00:13:12,610 --> 00:13:15,790
this and that you can see this is what

00:13:14,050 --> 00:13:18,459
we've already seen is that we've got

00:13:15,790 --> 00:13:21,590
this parameterised aunty it takes a

00:13:18,459 --> 00:13:24,440
Jason value but we need to tell the

00:13:21,590 --> 00:13:26,480
pilar how to go from jason to a reads

00:13:24,440 --> 00:13:28,430
and so we need to provide our

00:13:26,480 --> 00:13:30,320
implementation here and if we look in

00:13:28,430 --> 00:13:32,420
reads it says what to do for each of the

00:13:30,320 --> 00:13:34,190
types and things like that and free see

00:13:32,420 --> 00:13:37,280
each of the jason types and how to

00:13:34,190 --> 00:13:39,590
actually go about creating in this case

00:13:37,280 --> 00:13:42,620
maybe a person object and again this is

00:13:39,590 --> 00:13:44,300
this is similar for rights as well okay

00:13:42,620 --> 00:13:47,090
another one you might be familiar with

00:13:44,300 --> 00:13:49,580
if people have used type level cats or

00:13:47,090 --> 00:13:52,130
even scholars add this library itself is

00:13:49,580 --> 00:13:54,470
it's really quite rich and heavy usage

00:13:52,130 --> 00:13:56,030
of type classes so having a good

00:13:54,470 --> 00:13:58,520
understanding of that really does help

00:13:56,030 --> 00:14:00,650
kind of use the library so there's one I

00:13:58,520 --> 00:14:01,880
pulled out here and I think this

00:14:00,650 --> 00:14:08,630
probably all makes sense to you right

00:14:01,880 --> 00:14:10,610
now ya know so I I purposefully showed

00:14:08,630 --> 00:14:12,530
this because I even if you're not

00:14:10,610 --> 00:14:14,960
familiar with this is that really all we

00:14:12,530 --> 00:14:19,340
want to say here is that in order to use

00:14:14,960 --> 00:14:21,530
this method this l-type has to have a

00:14:19,340 --> 00:14:23,630
semigroup instance and it doesn't matter

00:14:21,530 --> 00:14:25,160
now if you know what a semigroup is or

00:14:23,630 --> 00:14:26,900
not that doesn't really matter but all

00:14:25,160 --> 00:14:29,450
we're saying here is that in order to

00:14:26,900 --> 00:14:32,180
use this l must be a semigroup and what

00:14:29,450 --> 00:14:34,670
you tend to find is the more you start

00:14:32,180 --> 00:14:36,470
to use mechanisms like this the more

00:14:34,670 --> 00:14:39,050
information you can pull out of type

00:14:36,470 --> 00:14:40,580
signatures here so maybe maybe you're

00:14:39,050 --> 00:14:43,160
familiar with semigroups but not

00:14:40,580 --> 00:14:46,370
familiar with what a writer t is but

00:14:43,160 --> 00:14:48,230
actually you start to realize that well

00:14:46,370 --> 00:14:51,020
if you know a semigroup is actually just

00:14:48,230 --> 00:14:53,300
appending things together and this is a

00:14:51,020 --> 00:14:54,770
writer is that well maybe this is

00:14:53,300 --> 00:14:56,810
something to do with what gets written

00:14:54,770 --> 00:14:59,000
is that we just keep writing or a

00:14:56,810 --> 00:15:01,340
pending to something and the nice thing

00:14:59,000 --> 00:15:03,860
is here is that we're not constrained to

00:15:01,340 --> 00:15:05,660
be writing to lists or strings or log

00:15:03,860 --> 00:15:07,760
files or whatever we can write to

00:15:05,660 --> 00:15:10,310
whatever we want and the library has

00:15:07,760 --> 00:15:12,350
been written so that this doesn't care

00:15:10,310 --> 00:15:14,600
and the actual semigroup can be written

00:15:12,350 --> 00:15:15,950
by something out someone else but we

00:15:14,600 --> 00:15:18,260
just have to have that semigroup

00:15:15,950 --> 00:15:22,400
instance there and this will then work

00:15:18,260 --> 00:15:27,010
is everyone with me so far or my my

00:15:22,400 --> 00:15:30,610
losing people yes no

00:15:27,010 --> 00:15:32,830
okay right so I'm gonna I'm going to

00:15:30,610 --> 00:15:35,860
make a proposal here is that I believe

00:15:32,830 --> 00:15:38,950
that implementing a genetic algorithm is

00:15:35,860 --> 00:15:42,490
actually a great opportunity to show how

00:15:38,950 --> 00:15:44,530
type classes work okay so let's let's

00:15:42,490 --> 00:15:46,840
talk a little bit about what a genetic

00:15:44,530 --> 00:15:49,750
algorithm is so if we look at what

00:15:46,840 --> 00:15:51,400
wikipedia says it's a search heuristic

00:15:49,750 --> 00:15:55,090
that mimics the process of natural

00:15:51,400 --> 00:15:57,610
selection so what does it what does this

00:15:55,090 --> 00:16:00,040
actually mean so what we're going to do

00:15:57,610 --> 00:16:02,140
here is we're going to we're going to do

00:16:00,040 --> 00:16:04,300
the monkeys with typewriters trick and

00:16:02,140 --> 00:16:05,770
we're going to write some Shakespeare so

00:16:04,300 --> 00:16:08,410
we're going to randomly generate some

00:16:05,770 --> 00:16:10,060
stuff we're going to look at the stuff

00:16:08,410 --> 00:16:12,700
and work out which of the stuff is the

00:16:10,060 --> 00:16:15,250
best and then we're going to use that

00:16:12,700 --> 00:16:17,200
best stuff to seed more generation of

00:16:15,250 --> 00:16:19,480
random stuff and then we'll just keep

00:16:17,200 --> 00:16:20,950
doing this and as long as we know what's

00:16:19,480 --> 00:16:23,260
the best we can always pull that out and

00:16:20,950 --> 00:16:25,690
use that to create more and more good

00:16:23,260 --> 00:16:27,760
things and to be honest I'm being and

00:16:25,690 --> 00:16:30,250
being a bit obtuse here and I'm trying

00:16:27,760 --> 00:16:32,860
just to kind of keep this very kind of

00:16:30,250 --> 00:16:33,880
high level but what you know we're we're

00:16:32,860 --> 00:16:35,710
all here we know what we know we're

00:16:33,880 --> 00:16:37,420
talking about genetic algorithm so I'm

00:16:35,710 --> 00:16:39,340
going to get into a bit more detail and

00:16:37,420 --> 00:16:42,310
then we just keep doing this we just do

00:16:39,340 --> 00:16:47,320
this over and over again okay so we need

00:16:42,310 --> 00:16:51,070
a way to represent stuff okay so I think

00:16:47,320 --> 00:16:53,890
a good way to do this is a binary string

00:16:51,070 --> 00:16:57,100
so we could use some kind of collection

00:16:53,890 --> 00:16:58,900
maybe a list or a vector I've just a

00:16:57,100 --> 00:17:01,000
list here to call it a chromosome

00:16:58,900 --> 00:17:04,150
because that's the terminology often

00:17:01,000 --> 00:17:07,620
used with genetic algorithms and then

00:17:04,150 --> 00:17:09,760
this in a bit more detail from that the

00:17:07,620 --> 00:17:11,560
algorithm i just showed is it is a

00:17:09,760 --> 00:17:13,449
little bit more detail so we're going to

00:17:11,560 --> 00:17:16,329
take some kind of population of these

00:17:13,449 --> 00:17:17,829
lists of boolean's and then we're going

00:17:16,329 --> 00:17:19,750
to inspect them all and we're going to

00:17:17,829 --> 00:17:22,060
apply some kind of fitness function

00:17:19,750 --> 00:17:25,329
we're going to look at all of these and

00:17:22,060 --> 00:17:27,550
say whatever we're trying to do this

00:17:25,329 --> 00:17:31,840
chromosome here is actually better than

00:17:27,550 --> 00:17:33,940
that chromosome there and then we're

00:17:31,840 --> 00:17:35,910
going to randomly select some of the

00:17:33,940 --> 00:17:38,650
inhabitants of this population

00:17:35,910 --> 00:17:41,380
respecting the waiting so a fitter

00:17:38,650 --> 00:17:45,010
chromosome has a higher chance of the

00:17:41,380 --> 00:17:46,480
selected then then are not so fit one so

00:17:45,010 --> 00:17:49,960
we're going to select this mutation pool

00:17:46,480 --> 00:17:51,460
and then we're going to mutate it in a

00:17:49,960 --> 00:17:54,340
couple of ways so the first thing we're

00:17:51,460 --> 00:17:56,530
going to do is make this with another

00:17:54,340 --> 00:17:59,830
chromosome and we call this crossover

00:17:56,530 --> 00:18:02,050
and then maybe we might take some of the

00:17:59,830 --> 00:18:04,030
bits from this new binary string and

00:18:02,050 --> 00:18:05,830
we'll just twiddle a few of the bits and

00:18:04,030 --> 00:18:07,690
we'll see why we want to do that in a

00:18:05,830 --> 00:18:09,640
bit and once we've done that that's our

00:18:07,690 --> 00:18:13,120
new population and then we can start

00:18:09,640 --> 00:18:14,530
again okay so i think the signature for

00:18:13,120 --> 00:18:17,470
what we are we're going to write might

00:18:14,530 --> 00:18:19,870
look something like this so a population

00:18:17,470 --> 00:18:23,050
here is just a list of chromosomes which

00:18:19,870 --> 00:18:24,460
itself is a list of bullion's so we need

00:18:23,050 --> 00:18:26,560
it we need a fitness function I've

00:18:24,460 --> 00:18:28,300
parameterised this because we don't know

00:18:26,560 --> 00:18:32,260
exactly what we're going to be talking

00:18:28,300 --> 00:18:34,300
about and then given a population we we

00:18:32,260 --> 00:18:37,570
we do the steps i just showed and that

00:18:34,300 --> 00:18:39,250
creates a new population so clearly the

00:18:37,570 --> 00:18:42,220
fitness depends on what we're actually

00:18:39,250 --> 00:18:43,900
going to have this algorithm do we want

00:18:42,220 --> 00:18:45,790
this to be generic we want this to work

00:18:43,900 --> 00:18:49,090
with anything which is why we've

00:18:45,790 --> 00:18:50,800
parameterised this but we need what we

00:18:49,090 --> 00:18:52,900
need to do first is we need to convert

00:18:50,800 --> 00:18:54,730
these chromosomes into real things you

00:18:52,900 --> 00:18:57,070
know we need to look at this in your

00:18:54,730 --> 00:18:59,200
well if we're if we're looking at I

00:18:57,070 --> 00:19:01,840
don't know some DNA sequence for some

00:18:59,200 --> 00:19:03,970
reason this one for what we're trying to

00:19:01,840 --> 00:19:07,110
inspect is better than that one and so

00:19:03,970 --> 00:19:09,460
we need to actually look at the binary

00:19:07,110 --> 00:19:11,620
encoding convert that to what we need to

00:19:09,460 --> 00:19:14,110
do and then that's going to make things

00:19:11,620 --> 00:19:15,610
a little bit easier to work with so in

00:19:14,110 --> 00:19:17,830
order to convert this I think we should

00:19:15,610 --> 00:19:20,620
have a trait I've called this jeannette

00:19:17,830 --> 00:19:23,230
genetic again it's parameterised and

00:19:20,620 --> 00:19:26,080
it's really just a single function given

00:19:23,230 --> 00:19:28,330
a chromosome it converts it to whatever

00:19:26,080 --> 00:19:31,330
we're talking about so when it comes to

00:19:28,330 --> 00:19:33,010
us using this iterate function we need

00:19:31,330 --> 00:19:35,440
to provide the way of actually

00:19:33,010 --> 00:19:37,990
converting from a chromosome to whatever

00:19:35,440 --> 00:19:39,310
we're trying to play with so I'm just

00:19:37,990 --> 00:19:42,880
going to make a slight update to our

00:19:39,310 --> 00:19:44,740
iterate signature here and so we've got

00:19:42,880 --> 00:19:47,770
our fitness function we've got our

00:19:44,740 --> 00:19:50,350
population and then we've got this this

00:19:47,770 --> 00:19:52,090
implicit parameter here and hopefully

00:19:50,350 --> 00:19:54,640
this looks quite familiar to what I've

00:19:52,090 --> 00:19:57,730
just shown is that actually genetic is

00:19:54,640 --> 00:19:59,230
class and that we're saying as long as

00:19:57,730 --> 00:20:01,960
that is when we have a fitness function

00:19:59,230 --> 00:20:04,090
from a certain type we need to make sure

00:20:01,960 --> 00:20:05,560
we're able to convert from a chromosome

00:20:04,090 --> 00:20:10,450
to that type in order to do the

00:20:05,560 --> 00:20:13,150
comparisons itself okay so the first

00:20:10,450 --> 00:20:16,030
step that was on that algorithm was to

00:20:13,150 --> 00:20:17,230
create the mutation pool if you remember

00:20:16,030 --> 00:20:20,050
what I said we're going to randomly

00:20:17,230 --> 00:20:22,000
select from this population giving a

00:20:20,050 --> 00:20:23,830
higher chance of selection to the fitter

00:20:22,000 --> 00:20:26,740
chromosomes so if we had a small

00:20:23,830 --> 00:20:29,680
population like this and this is

00:20:26,740 --> 00:20:31,960
completely arbitrary but here's some hit

00:20:29,680 --> 00:20:33,730
some binary strings here and for

00:20:31,960 --> 00:20:36,550
whatever reason we're looking at here

00:20:33,730 --> 00:20:38,980
this this orange one is much fitter than

00:20:36,550 --> 00:20:40,690
the rest of the population and so when

00:20:38,980 --> 00:20:42,250
it comes to selecting our mutation pool

00:20:40,690 --> 00:20:44,230
you can almost think of this like a dart

00:20:42,250 --> 00:20:46,840
board so we're going to throw darts and

00:20:44,230 --> 00:20:49,330
clearly there's a higher chance of a

00:20:46,840 --> 00:20:50,860
selecting the orange but the smaller

00:20:49,330 --> 00:20:54,190
ones also have a chance of being

00:20:50,860 --> 00:20:56,200
selected to and so what we'll do for the

00:20:54,190 --> 00:20:58,360
for the size of our population will grab

00:20:56,200 --> 00:20:59,950
that number of chromosomes out here so

00:20:58,360 --> 00:21:02,770
this is a small population we'd only

00:20:59,950 --> 00:21:04,030
grab five but we can imagine there's a

00:21:02,770 --> 00:21:05,500
high probability here that we're

00:21:04,030 --> 00:21:07,000
probably going to get two or three of

00:21:05,500 --> 00:21:09,580
the orange ones because they're the

00:21:07,000 --> 00:21:11,200
fitter ones but then for some reason

00:21:09,580 --> 00:21:12,730
that are at that the blue one might

00:21:11,200 --> 00:21:14,110
might come through as well just just

00:21:12,730 --> 00:21:18,250
because you know where we're dealing

00:21:14,110 --> 00:21:20,230
with something random here so here's his

00:21:18,250 --> 00:21:21,640
some here's some type signatures for may

00:21:20,230 --> 00:21:24,850
be thinking about how we'd create this

00:21:21,640 --> 00:21:29,410
mutation pool so it's often called a

00:21:24,850 --> 00:21:31,870
roulette wheel and so the parameter here

00:21:29,410 --> 00:21:33,990
is our is our population but we've

00:21:31,870 --> 00:21:37,540
paired it with the fitness function

00:21:33,990 --> 00:21:40,540
output and then this returns a function

00:21:37,540 --> 00:21:43,060
itself and what this function is it's

00:21:40,540 --> 00:21:45,430
normalized between zero and one and so

00:21:43,060 --> 00:21:47,830
we give it a number between zero and one

00:21:45,430 --> 00:21:52,300
it works out we're on the wheel that

00:21:47,830 --> 00:21:54,100
comes to and returns that value this is

00:21:52,300 --> 00:21:55,510
optional as well because you know we're

00:21:54,100 --> 00:21:56,980
dealing with vectors here we could we

00:21:55,510 --> 00:21:59,230
could have passed in an empty empty

00:21:56,980 --> 00:22:00,880
vector for some reason and clear that

00:21:59,230 --> 00:22:04,130
would be none you know we still want to

00:22:00,880 --> 00:22:06,410
remain type safe okay

00:22:04,130 --> 00:22:09,860
so we've got this we've got this new

00:22:06,410 --> 00:22:12,350
property now and we need to think of how

00:22:09,860 --> 00:22:14,360
we're going to test this of course the

00:22:12,350 --> 00:22:18,650
correct answer for for testing anything

00:22:14,360 --> 00:22:20,450
in Skyler's use scholar check and so one

00:22:18,650 --> 00:22:23,750
thing we need to do is it we need to

00:22:20,450 --> 00:22:26,240
think about a property of this roulette

00:22:23,750 --> 00:22:30,470
wheel that will will hold regardless of

00:22:26,240 --> 00:22:32,380
what data is there so scholar scholar

00:22:30,470 --> 00:22:35,090
check itself is inherently random and

00:22:32,380 --> 00:22:37,910
what we're doing here as well is also

00:22:35,090 --> 00:22:41,630
random so we need to kind of harness the

00:22:37,910 --> 00:22:44,120
control somewhere so we need to find out

00:22:41,630 --> 00:22:46,730
some property that will always hold

00:22:44,120 --> 00:22:49,790
whatever whatever the things are in the

00:22:46,730 --> 00:22:53,840
mutation pool and so those just our our

00:22:49,790 --> 00:22:55,610
our wheel again and so here's one here's

00:22:53,840 --> 00:22:58,310
what I thought of while i was when i was

00:22:55,610 --> 00:23:01,700
writing this is that if we if we create

00:22:58,310 --> 00:23:04,940
some pool and one of the chromosomes in

00:23:01,700 --> 00:23:07,040
the pool takes up half the wheel I it's

00:23:04,940 --> 00:23:10,610
really really fit compared to the rest

00:23:07,040 --> 00:23:13,160
of the population then when we look at

00:23:10,610 --> 00:23:15,590
the midpoint so not point five because I

00:23:13,160 --> 00:23:17,240
said it the the parameter was normalized

00:23:15,590 --> 00:23:19,310
between zero and one so when we look at

00:23:17,240 --> 00:23:21,710
the midway point that will always return

00:23:19,310 --> 00:23:24,290
that chromosome so if we imagine I don't

00:23:21,710 --> 00:23:27,290
know the 6p at six o'clock on this wheel

00:23:24,290 --> 00:23:29,180
is is halfway is that when we've got

00:23:27,290 --> 00:23:31,550
some kind of chromosome that takes over

00:23:29,180 --> 00:23:34,970
half the wheel like wherever we look at

00:23:31,550 --> 00:23:38,200
it it's always going to be that one and

00:23:34,970 --> 00:23:42,440
I think that's a fair property okay and

00:23:38,200 --> 00:23:45,770
so here's some scholar check code in

00:23:42,440 --> 00:23:47,480
order to make this work are people

00:23:45,770 --> 00:23:52,760
familiar with Skylar check our people

00:23:47,480 --> 00:23:54,710
not yep okay for those who are not it's

00:23:52,760 --> 00:23:57,650
a property by the property based testing

00:23:54,710 --> 00:24:00,230
tool we provide things that always hold

00:23:57,650 --> 00:24:02,420
true for our code and then Skylar chat

00:24:00,230 --> 00:24:05,030
will give random data to that property

00:24:02,420 --> 00:24:07,400
and make sure it always holds true so

00:24:05,030 --> 00:24:09,950
what we can see here is where we're

00:24:07,400 --> 00:24:12,620
taking three parameters and we're taking

00:24:09,950 --> 00:24:14,540
and we're taking an arbitrary list of

00:24:12,620 --> 00:24:17,180
measured chromosomes so that's with

00:24:14,540 --> 00:24:17,900
their fitness value I don't care what

00:24:17,180 --> 00:24:19,940
those numbers are

00:24:17,900 --> 00:24:22,220
I just care that they're produced and

00:24:19,940 --> 00:24:24,620
then provide and then asking for a

00:24:22,220 --> 00:24:29,000
single chromosome on its own and then

00:24:24,620 --> 00:24:31,640
another list of measured chromosomes and

00:24:29,000 --> 00:24:33,170
what I'm going to say is that for the

00:24:31,640 --> 00:24:36,260
what I've called the left's and the

00:24:33,170 --> 00:24:39,760
rights here if we take their fitness

00:24:36,260 --> 00:24:43,340
values add them together and add one

00:24:39,760 --> 00:24:45,230
then that that will become what's going

00:24:43,340 --> 00:24:48,200
to be the score for our middle

00:24:45,230 --> 00:24:51,050
chromosome and then when we put all this

00:24:48,200 --> 00:24:52,430
together in our wheel then that value is

00:24:51,050 --> 00:24:55,700
going to be greater than the sum of

00:24:52,430 --> 00:24:57,170
everything else combined and so then we

00:24:55,700 --> 00:24:59,330
can start to see that hopefully this

00:24:57,170 --> 00:25:02,690
will always return when we look at the

00:24:59,330 --> 00:25:04,820
midpoint here it will always return this

00:25:02,690 --> 00:25:06,350
midpoint that we looked for and then the

00:25:04,820 --> 00:25:09,950
nice thing with Skylar check as well is

00:25:06,350 --> 00:25:11,630
that this will test for an empty list on

00:25:09,950 --> 00:25:13,880
the left and empty empty list on the

00:25:11,630 --> 00:25:16,040
right you know a lot lots of different

00:25:13,880 --> 00:25:19,820
permutations so it's not always going to

00:25:16,040 --> 00:25:21,560
be the middle of a certain collection

00:25:19,820 --> 00:25:23,840
there will be times where it's the first

00:25:21,560 --> 00:25:25,610
in the element times whereas six or

00:25:23,840 --> 00:25:27,380
seven before it and things like that and

00:25:25,610 --> 00:25:29,180
you start to build up that this is

00:25:27,380 --> 00:25:31,430
actually doing quite a thorough test of

00:25:29,180 --> 00:25:35,050
our mutation pool and we just hold in a

00:25:31,430 --> 00:25:37,460
single rule that as long as one of the

00:25:35,050 --> 00:25:39,530
chromosomes is really really fit

00:25:37,460 --> 00:25:42,350
compared to everything else that will

00:25:39,530 --> 00:25:45,050
always return at the halfway point then

00:25:42,350 --> 00:25:46,430
when we run this it's great because

00:25:45,050 --> 00:25:49,580
scholar check runs it a hundred times

00:25:46,430 --> 00:25:51,560
for us and it always returns true and

00:25:49,580 --> 00:25:53,300
I'm sure I'm sure you know this is this

00:25:51,560 --> 00:25:55,070
is clearly not a comprehensive test this

00:25:53,300 --> 00:25:57,250
is not going to make sure that our

00:25:55,070 --> 00:26:00,590
mutation pull works for everything but

00:25:57,250 --> 00:26:02,750
it's more of a more of a I suppose an

00:26:00,590 --> 00:26:04,400
example to show you and maybe we can

00:26:02,750 --> 00:26:05,810
think of some more properties and maybe

00:26:04,400 --> 00:26:09,140
you could go away and think about how

00:26:05,810 --> 00:26:13,010
you'd best write these okay so just

00:26:09,140 --> 00:26:15,410
again as an aside what we did here is

00:26:13,010 --> 00:26:18,650
that we've we've now got this concrete

00:26:15,410 --> 00:26:21,620
double value that we need when we're

00:26:18,650 --> 00:26:23,240
when we're testing this and so we're

00:26:21,620 --> 00:26:25,850
going to change our iterate function

00:26:23,240 --> 00:26:27,710
ever so slightly because we want to pass

00:26:25,850 --> 00:26:31,820
a function in that gives us a double

00:26:27,710 --> 00:26:34,910
because then we can test that with maybe

00:26:31,820 --> 00:26:36,470
some kind of stream of doubles and then

00:26:34,910 --> 00:26:38,420
we can keep calling it with this double

00:26:36,470 --> 00:26:40,730
value to make sure that it's always

00:26:38,420 --> 00:26:42,580
getting the right result but then when

00:26:40,730 --> 00:26:45,770
it comes to our real full implementation

00:26:42,580 --> 00:26:48,800
we could provide an alternative way of

00:26:45,770 --> 00:26:50,210
providing a lot of doubles so maybe

00:26:48,800 --> 00:26:51,890
we'll just change our iterate function

00:26:50,210 --> 00:26:53,840
to look like this so we've got our

00:26:51,890 --> 00:26:56,510
Fitness here and now we've got this

00:26:53,840 --> 00:26:58,730
function unit to double so we can call

00:26:56,510 --> 00:27:00,830
this and it will just return doubles for

00:26:58,730 --> 00:27:02,930
us now I haven't shown all our tests

00:27:00,830 --> 00:27:05,060
that I've written here but if we want to

00:27:02,930 --> 00:27:07,190
test this iterate function in full we

00:27:05,060 --> 00:27:10,850
now have a way to really really nail

00:27:07,190 --> 00:27:13,610
down what are what values we're going to

00:27:10,850 --> 00:27:14,780
call the mutation function with and then

00:27:13,610 --> 00:27:17,360
of course when it comes to full

00:27:14,780 --> 00:27:18,860
implementation we can just put in the

00:27:17,360 --> 00:27:22,180
random for next double and that will

00:27:18,860 --> 00:27:24,500
just fit nicely into that implementation

00:27:22,180 --> 00:27:27,140
okay so now that we've got our mutation

00:27:24,500 --> 00:27:29,420
pool we need to do this step of what I

00:27:27,140 --> 00:27:31,700
call a crossover and what we're going to

00:27:29,420 --> 00:27:35,240
do we're going to iterate over this pool

00:27:31,700 --> 00:27:37,780
take each chromosome in turn will pick a

00:27:35,240 --> 00:27:41,930
random one from our original population

00:27:37,780 --> 00:27:43,370
on the string on the string of bits

00:27:41,930 --> 00:27:45,470
we're going to pick an arbitrary point

00:27:43,370 --> 00:27:48,140
and we're going to flip the bits around

00:27:45,470 --> 00:27:50,270
so the this is often what's called

00:27:48,140 --> 00:27:51,590
mating as well as crossover is that

00:27:50,270 --> 00:27:54,710
we're taking the two chromosomes

00:27:51,590 --> 00:27:56,870
together and producing a new one and so

00:27:54,710 --> 00:27:59,360
here is an example here we've got a

00:27:56,870 --> 00:28:02,720
couple of chromosomes we just pick some

00:27:59,360 --> 00:28:05,570
random point during the along the string

00:28:02,720 --> 00:28:08,870
and then we flip these bits around you

00:28:05,570 --> 00:28:10,040
can see we just flip it and then we

00:28:08,870 --> 00:28:11,990
don't care about the one from the

00:28:10,040 --> 00:28:13,760
original pool we're only now looking at

00:28:11,990 --> 00:28:16,790
the mutation pool this is what we

00:28:13,760 --> 00:28:19,070
selected for bait based on the weight

00:28:16,790 --> 00:28:20,120
and so the ones with a higher waiting

00:28:19,070 --> 00:28:22,070
should have had a higher chance of

00:28:20,120 --> 00:28:24,170
getting into this pool so we can just

00:28:22,070 --> 00:28:27,170
throw that one away and now we've got a

00:28:24,170 --> 00:28:28,880
new chromosome and now we need to think

00:28:27,170 --> 00:28:31,250
about how to test this as well and again

00:28:28,880 --> 00:28:34,520
we can do this with scarlet oak and this

00:28:31,250 --> 00:28:37,550
one's a bit more gritty so here is one

00:28:34,520 --> 00:28:41,900
thing I think is that if we provide two

00:28:37,550 --> 00:28:43,640
or three fragments of a chromosome we

00:28:41,900 --> 00:28:44,870
can then work out where that crossover

00:28:43,640 --> 00:28:48,470
point is

00:28:44,870 --> 00:28:51,680
we can provide that chromosome to our

00:28:48,470 --> 00:28:53,270
algorithm and then that should get

00:28:51,680 --> 00:28:55,700
swapped in the right place and we know

00:28:53,270 --> 00:28:57,110
what should come back and so our test

00:28:55,700 --> 00:28:59,480
it's a bit more involved it looks

00:28:57,110 --> 00:29:03,200
something like this so we have a number

00:28:59,480 --> 00:29:05,870
for the the point on the on the string

00:29:03,200 --> 00:29:07,520
where the crossover will happen and then

00:29:05,870 --> 00:29:09,800
this number here is just the length of

00:29:07,520 --> 00:29:12,160
the point the string after the crossover

00:29:09,800 --> 00:29:15,650
point we have a function here which

00:29:12,160 --> 00:29:20,090
generates some some pairs for us so it

00:29:15,650 --> 00:29:22,820
provides a it provides a chromosome for

00:29:20,090 --> 00:29:25,280
us into interest split parts so we know

00:29:22,820 --> 00:29:27,559
which part is before the crossover and

00:29:25,280 --> 00:29:30,190
which part is after and then our

00:29:27,559 --> 00:29:34,429
property here takes to split chromosomes

00:29:30,190 --> 00:29:36,980
it puts them straight together and calls

00:29:34,429 --> 00:29:38,900
this crossover method and we know this

00:29:36,980 --> 00:29:43,070
crossover point because it was generated

00:29:38,900 --> 00:29:44,780
from our original property and of course

00:29:43,070 --> 00:29:46,970
we know what the expectation should be

00:29:44,780 --> 00:29:48,620
because we broke it up and we know where

00:29:46,970 --> 00:29:51,620
the crossover should happen because we

00:29:48,620 --> 00:29:53,540
have this value here and then we can see

00:29:51,620 --> 00:29:56,059
that that pass does that make sense it's

00:29:53,540 --> 00:29:57,590
quite involved it's a bit it's a bit

00:29:56,059 --> 00:29:59,690
fiddly especially if you're not too

00:29:57,590 --> 00:30:01,190
familiar with scarlet check but

00:29:59,690 --> 00:30:03,740
basically we've got two chromosomes that

00:30:01,190 --> 00:30:06,200
are broken into we pass them in and we

00:30:03,740 --> 00:30:08,570
know where the flip will happen and this

00:30:06,200 --> 00:30:10,070
is really nice because this this shows

00:30:08,570 --> 00:30:11,990
that our crossover is working quite well

00:30:10,070 --> 00:30:14,570
and again notice here that this is not

00:30:11,990 --> 00:30:16,940
for a specific length of chromosome this

00:30:14,570 --> 00:30:19,429
is this will be testing it for any

00:30:16,940 --> 00:30:21,890
length and also the the crossover point

00:30:19,429 --> 00:30:23,360
will vary within that length so it's

00:30:21,890 --> 00:30:27,590
getting quite thorough test here and

00:30:23,360 --> 00:30:29,510
again likely aside I said before we need

00:30:27,590 --> 00:30:31,880
to add a new function on to our iterate

00:30:29,510 --> 00:30:34,309
method because now we need to have a

00:30:31,880 --> 00:30:36,650
little bit more control over where our

00:30:34,309 --> 00:30:38,929
crossover point is so when we're testing

00:30:36,650 --> 00:30:41,270
it we might want to find a string of

00:30:38,929 --> 00:30:43,790
integers to test whether that happens

00:30:41,270 --> 00:30:46,640
but then again when it comes to our full

00:30:43,790 --> 00:30:50,270
application code we can just put in the

00:30:46,640 --> 00:30:51,800
random next integer value and then

00:30:50,270 --> 00:30:54,110
finally there's one more thing we were

00:30:51,800 --> 00:30:56,030
to do and that's random mutations and

00:30:54,110 --> 00:30:58,669
what we want to do here is take our

00:30:56,030 --> 00:31:01,009
string and in a few places just flip

00:30:58,669 --> 00:31:03,259
the bits um the reason we want to do

00:31:01,009 --> 00:31:05,690
this is that we might find that our

00:31:03,259 --> 00:31:08,539
algorithm is actually homing in on

00:31:05,690 --> 00:31:10,429
what's called a local maximum and that

00:31:08,539 --> 00:31:12,799
we're getting quite close but because of

00:31:10,429 --> 00:31:14,779
the way the algorithm works there might

00:31:12,799 --> 00:31:18,320
be a much more optimal solution

00:31:14,779 --> 00:31:20,059
elsewhere that we can't see and so by

00:31:18,320 --> 00:31:22,159
flipping some bits we might jump to a

00:31:20,059 --> 00:31:24,320
different area of the solution space and

00:31:22,159 --> 00:31:26,840
then we might find that actually we're

00:31:24,320 --> 00:31:29,859
in a much richer environment and then we

00:31:26,840 --> 00:31:32,269
can start to home in on that instead and

00:31:29,859 --> 00:31:36,559
so we're just going to select a few bits

00:31:32,269 --> 00:31:37,669
to flip like so and i'm not going to

00:31:36,559 --> 00:31:39,049
show the test for that because i think

00:31:37,669 --> 00:31:41,059
that should be quite straightforward

00:31:39,049 --> 00:31:44,119
from what i've shown as well and we're

00:31:41,059 --> 00:31:46,580
done we can ship it and so our final

00:31:44,119 --> 00:31:48,769
iteration signature looks like this so

00:31:46,580 --> 00:31:50,989
we added those to those two functions i

00:31:48,769 --> 00:31:52,759
mentioned there's also an ex boolean as

00:31:50,989 --> 00:31:55,309
well because we don't maybe don't always

00:31:52,759 --> 00:31:58,100
want to do that mutation so we'll call

00:31:55,309 --> 00:32:00,559
this next bull if it's true let's do

00:31:58,100 --> 00:32:02,720
some mutations we can draw some integers

00:32:00,559 --> 00:32:06,019
from next dent otherwise we just won't

00:32:02,720 --> 00:32:09,379
do it and just coming back to thinking

00:32:06,019 --> 00:32:12,980
about type classes as long as there's a

00:32:09,379 --> 00:32:14,869
genetic type class for our type we can

00:32:12,980 --> 00:32:17,869
provide a fitness function for that type

00:32:14,869 --> 00:32:21,590
and this will run and that's really

00:32:17,869 --> 00:32:22,730
quite nice so you might be able to think

00:32:21,590 --> 00:32:24,710
of some algorithms that I haven't

00:32:22,730 --> 00:32:26,570
thought of and as long as you can

00:32:24,710 --> 00:32:30,769
provide a type class and a fitness

00:32:26,570 --> 00:32:34,330
function this thing will just work ok so

00:32:30,769 --> 00:32:36,559
I've spent half an hour defining things

00:32:34,330 --> 00:32:38,570
let's let's have a look at this in

00:32:36,559 --> 00:32:40,759
action so one thing we can do is we can

00:32:38,570 --> 00:32:42,769
find the optimal solution to a function

00:32:40,759 --> 00:32:47,149
and I'm going to provide a really really

00:32:42,769 --> 00:32:49,039
basic function to start so it's clear

00:32:47,149 --> 00:32:52,820
you know it's clear what the we could

00:32:49,039 --> 00:32:55,249
maybe use a genetic algorithm here to to

00:32:52,820 --> 00:32:58,039
pick maybe some random integers apply

00:32:55,249 --> 00:32:59,629
this function to those integers and the

00:32:58,039 --> 00:33:01,460
fitness function should you should be

00:32:59,629 --> 00:33:03,109
quite clear that we can just call it

00:33:01,460 --> 00:33:05,570
with that and the higher the number the

00:33:03,109 --> 00:33:07,909
more fit through it is ok and so this

00:33:05,570 --> 00:33:10,399
graph is our fitness function so all we

00:33:07,909 --> 00:33:12,320
really need to do is just provide a way

00:33:10,399 --> 00:33:16,070
to turn the binary strings into number

00:33:12,320 --> 00:33:19,519
and hopefully hopefully this isn't isn't

00:33:16,070 --> 00:33:23,360
too complicated we just spent spin over

00:33:19,519 --> 00:33:26,059
our vector and we we shift shift our our

00:33:23,360 --> 00:33:29,419
collection of sorry we shift our

00:33:26,059 --> 00:33:30,679
accumulated number each time and if it

00:33:29,419 --> 00:33:33,830
was a true at the time we had one

00:33:30,679 --> 00:33:36,409
otherwise not and so we see some results

00:33:33,830 --> 00:33:41,269
like this is that visible it's not great

00:33:36,409 --> 00:33:43,789
is it sorry and so the this I ran I ran

00:33:41,269 --> 00:33:46,190
the genetic algorithm looking to target

00:33:43,789 --> 00:33:49,490
this number here and you can see early

00:33:46,190 --> 00:33:51,889
on early on in the implementation the

00:33:49,490 --> 00:33:53,659
population is all over the place it has

00:33:51,889 --> 00:33:55,970
no idea and it's swinging down and up

00:33:53,659 --> 00:33:59,419
and there's quite a wide variation in

00:33:55,970 --> 00:34:01,879
the size of the population and then I

00:33:59,419 --> 00:34:04,879
don't know but something happened here

00:34:01,879 --> 00:34:07,309
and then we managed to home in quite

00:34:04,879 --> 00:34:10,129
close to this value and then the the red

00:34:07,309 --> 00:34:11,980
line here is the average so clear the

00:34:10,129 --> 00:34:14,419
average is all over the place here and I

00:34:11,980 --> 00:34:17,300
think we tend to get a little bit closer

00:34:14,419 --> 00:34:18,649
to the the target at the end maybe if

00:34:17,300 --> 00:34:21,409
I'd run this a little bit longer it'd be

00:34:18,649 --> 00:34:22,940
a bit clearer and if we just zoom in on

00:34:21,409 --> 00:34:25,310
that flat line we can actually see it's

00:34:22,940 --> 00:34:26,810
not so flat so even though we're getting

00:34:25,310 --> 00:34:31,310
closer there's still quite a bit of

00:34:26,810 --> 00:34:33,379
variation in noise and I did this again

00:34:31,310 --> 00:34:35,300
just with another another number got

00:34:33,379 --> 00:34:38,599
similar results and this is the

00:34:35,300 --> 00:34:42,889
population size of 34 a thousand

00:34:38,599 --> 00:34:45,200
iterations of this algorithm okay so

00:34:42,889 --> 00:34:48,770
let's have a look at maybe a slightly

00:34:45,200 --> 00:34:51,139
more interesting implementation maybe do

00:34:48,770 --> 00:34:54,879
something we do some modern art there's

00:34:51,139 --> 00:34:58,160
some computer generated pictures so

00:34:54,879 --> 00:35:01,880
remember what I said is that this this

00:34:58,160 --> 00:35:05,060
type class it's not restricted to any

00:35:01,880 --> 00:35:08,839
particular values like any type that is

00:35:05,060 --> 00:35:12,109
available in the JVM written by anyone

00:35:08,839 --> 00:35:14,119
at any time can as well as long as

00:35:12,109 --> 00:35:18,550
there's an implementation of genetic for

00:35:14,119 --> 00:35:25,200
that this will work so what about

00:35:18,550 --> 00:35:27,770
creating one for this a java image okay

00:35:25,200 --> 00:35:30,990
and so what we could do here is our

00:35:27,770 --> 00:35:34,290
genetic implementation will use this

00:35:30,990 --> 00:35:38,070
chromosome binary I'm willing code the

00:35:34,290 --> 00:35:40,260
data for say fifty triangles and we'll

00:35:38,070 --> 00:35:44,220
give them XY coordinates and we'll give

00:35:40,260 --> 00:35:49,050
them colors and then that should be

00:35:44,220 --> 00:35:51,180
enough maybe to create an image and so

00:35:49,050 --> 00:35:55,470
assuming that the image we're going to

00:35:51,180 --> 00:35:57,720
build is is is this size then we're

00:35:55,470 --> 00:36:01,260
going to need 60 bits per triangle just

00:35:57,720 --> 00:36:03,060
to mention to locate the coordinates for

00:36:01,260 --> 00:36:06,270
the three points on the triangle and

00:36:03,060 --> 00:36:09,109
we're going to need another 24 bits to

00:36:06,270 --> 00:36:11,820
represent the color of the triangle and

00:36:09,109 --> 00:36:15,270
then we'll take another 24 bits on its

00:36:11,820 --> 00:36:17,310
own just to have a background color for

00:36:15,270 --> 00:36:19,260
for our image so if we're doing this

00:36:17,310 --> 00:36:21,720
with 50 triangles that's just over four

00:36:19,260 --> 00:36:23,310
thousand bits it's like the the values

00:36:21,720 --> 00:36:25,380
we were looking at earlier for the for

00:36:23,310 --> 00:36:28,230
the numbers on the graph I think that

00:36:25,380 --> 00:36:29,760
was 16 bits so if we've kind of gone

00:36:28,230 --> 00:36:32,010
gone a little bit through the roof here

00:36:29,760 --> 00:36:33,859
with the number of bits so we need to

00:36:32,010 --> 00:36:36,420
think about this fitness function so

00:36:33,859 --> 00:36:39,780
well what does it mean for an image to

00:36:36,420 --> 00:36:41,369
be fitter than another one ah it's quite

00:36:39,780 --> 00:36:43,710
subjective thing really isn't it you

00:36:41,369 --> 00:36:47,099
know we look at two images what's the

00:36:43,710 --> 00:36:48,569
better one well what we could do is

00:36:47,099 --> 00:36:51,270
we'll just compare with an image that

00:36:48,569 --> 00:36:53,550
already exists and then if we if we take

00:36:51,270 --> 00:36:56,250
if we take an image we can maybe work

00:36:53,550 --> 00:37:00,390
out a value how close that is to a

00:36:56,250 --> 00:37:02,670
particular image and so I zoomed in on a

00:37:00,390 --> 00:37:04,680
particular famous piece of art and

00:37:02,670 --> 00:37:07,680
thought that might be quite a nice a

00:37:04,680 --> 00:37:10,819
nice one to use and so you need to think

00:37:07,680 --> 00:37:14,280
about the fitness function for for this

00:37:10,819 --> 00:37:17,670
so a poor man's image comparison and

00:37:14,280 --> 00:37:19,640
this this is a this is just a discipline

00:37:17,670 --> 00:37:22,200
in its own right comparing images so

00:37:19,640 --> 00:37:23,910
this is definitely not the the best or

00:37:22,200 --> 00:37:26,940
the most appropriate way to do this that

00:37:23,910 --> 00:37:29,700
given both images so the zoomed in mona

00:37:26,940 --> 00:37:34,230
lisa and our generated image for each

00:37:29,700 --> 00:37:35,079
pixel depth of RGB values some all these

00:37:34,230 --> 00:37:37,269
deaths

00:37:35,079 --> 00:37:39,489
the one with the smaller value is the

00:37:37,269 --> 00:37:41,619
fitter image clearly this is not the

00:37:39,489 --> 00:37:43,690
best you know clearly there's lots of

00:37:41,619 --> 00:37:45,609
ways to this and there's pages and pages

00:37:43,690 --> 00:37:48,160
on stack overflow of people who put a

00:37:45,609 --> 00:37:51,789
lot of effort into image comparisons and

00:37:48,160 --> 00:37:54,729
stuff like this but we still have it

00:37:51,789 --> 00:37:56,049
regardless of the efficiency of this we

00:37:54,729 --> 00:37:59,469
still have another problem as well is

00:37:56,049 --> 00:38:02,559
that the parameters of the parameters to

00:37:59,469 --> 00:38:05,200
our iterate function don't compare

00:38:02,559 --> 00:38:08,469
things to themselves it's literally a

00:38:05,200 --> 00:38:11,170
too long so in this case bufferedimage

00:38:08,469 --> 00:38:15,219
too long so there's a bit of a problem

00:38:11,170 --> 00:38:17,499
here is that we want to we need we need

00:38:15,219 --> 00:38:19,809
more information but of course this

00:38:17,499 --> 00:38:22,029
comes really easy and scholar because we

00:38:19,809 --> 00:38:25,239
can just carry this so if we have a

00:38:22,029 --> 00:38:27,219
function like this we can just provide

00:38:25,239 --> 00:38:29,380
the Mona Lisa as this first parameter

00:38:27,219 --> 00:38:31,390
and that gives us a function from

00:38:29,380 --> 00:38:33,249
bufferedimage too long and then we can

00:38:31,390 --> 00:38:35,410
just set this as a base image and put

00:38:33,249 --> 00:38:37,180
that into our iterate function and then

00:38:35,410 --> 00:38:40,029
when we're generating these images then

00:38:37,180 --> 00:38:44,499
is that we're really just comparing it

00:38:40,029 --> 00:38:46,900
to to this base image okay and so here's

00:38:44,499 --> 00:38:51,930
some results this is a this is something

00:38:46,900 --> 00:38:51,930
I did a couple of weeks ago so yeah

00:38:53,319 --> 00:38:59,799
so that's a thousand iterations on a

00:38:56,199 --> 00:39:05,289
population size of 30 okay so then

00:38:59,799 --> 00:39:07,839
that's 2000 Oh backgrounds changed it's

00:39:05,289 --> 00:39:10,660
getting a bit closer bit more yellow

00:39:07,839 --> 00:39:12,279
lady see like it gets a bit darker in

00:39:10,660 --> 00:39:15,880
the corners as well which is quite nice

00:39:12,279 --> 00:39:18,609
that's 5000 iterations it's five

00:39:15,880 --> 00:39:21,940
thousand seven hundred iterations and

00:39:18,609 --> 00:39:23,709
that's what we three days so yeah I mean

00:39:21,940 --> 00:39:26,829
clearly you know dealing with this

00:39:23,709 --> 00:39:29,949
number of bits and doing not the most

00:39:26,829 --> 00:39:33,160
efficient comparison of the images took

00:39:29,949 --> 00:39:35,349
a little bit too long and and my

00:39:33,160 --> 00:39:38,349
algorithm was never written to kind of

00:39:35,349 --> 00:39:39,969
consider doing things in parallel so one

00:39:38,349 --> 00:39:42,039
thing I'm considering doing it is kind

00:39:39,969 --> 00:39:44,289
of taking this away and tweaking it

00:39:42,039 --> 00:39:51,519
somewhere but I feel that's progress

00:39:44,289 --> 00:39:54,279
what do you think yeah yeah so yeah that

00:39:51,519 --> 00:39:56,410
was a lot of electricity to do that so

00:39:54,279 --> 00:39:59,079
so that's that's about all I really had

00:39:56,410 --> 00:40:00,369
time for here so just a few things to

00:39:59,079 --> 00:40:03,099
kind of wrap up yeah they're not

00:40:00,369 --> 00:40:05,589
efficient like it's not the best way to

00:40:03,099 --> 00:40:08,920
do things there are there are scenarios

00:40:05,589 --> 00:40:11,410
where genetic algorithms are great where

00:40:08,920 --> 00:40:15,930
maybe the domain of a search space

00:40:11,410 --> 00:40:18,459
search space isn't very well understood

00:40:15,930 --> 00:40:20,440
but I just thought it was going to be a

00:40:18,459 --> 00:40:22,359
bit of fun here but what I do like is

00:40:20,440 --> 00:40:25,509
that type classes here provided really

00:40:22,359 --> 00:40:28,089
neat interface to our algorithm like the

00:40:25,509 --> 00:40:30,640
algorithm for the two examples I showed

00:40:28,089 --> 00:40:33,160
was exactly the same the code did not

00:40:30,640 --> 00:40:34,719
change between them and all I had to do

00:40:33,160 --> 00:40:37,599
was provide the fitness function and

00:40:34,719 --> 00:40:39,640
provide a way to show what the encoding

00:40:37,599 --> 00:40:42,160
of the binary string meant and that was

00:40:39,640 --> 00:40:44,380
it and another thing that was really

00:40:42,160 --> 00:40:47,079
nice is that we got this inherently

00:40:44,380 --> 00:40:50,259
random tool of scarlet check and we've

00:40:47,079 --> 00:40:52,059
got this inherently random problem that

00:40:50,259 --> 00:40:55,239
we're trying to solve and we're able to

00:40:52,059 --> 00:40:56,699
use it in a in a deterministic way for

00:40:55,239 --> 00:41:01,059
what really is a non-deterministic

00:40:56,699 --> 00:41:05,140
problem so what else what else could we

00:41:01,059 --> 00:41:06,520
use genetic algorithms for so these are

00:41:05,140 --> 00:41:09,550
things I just thought up

00:41:06,520 --> 00:41:12,310
my head we could write code yeah if we

00:41:09,550 --> 00:41:14,980
wrote some unit tests things that pass

00:41:12,310 --> 00:41:17,800
them failed we could just just let it go

00:41:14,980 --> 00:41:20,710
and create maybe in abstract syntax tree

00:41:17,800 --> 00:41:22,570
and see see how it comes out and things

00:41:20,710 --> 00:41:25,120
like that I know maybe I'll do us out of

00:41:22,570 --> 00:41:28,210
a job or something I found this really

00:41:25,120 --> 00:41:30,510
cool thing on the internet racing cars

00:41:28,210 --> 00:41:33,490
here this is written in JavaScript

00:41:30,510 --> 00:41:36,160
basically and that is kind of the the

00:41:33,490 --> 00:41:37,330
algorithm here then show like is used to

00:41:36,160 --> 00:41:39,700
encode the cars and they're given

00:41:37,330 --> 00:41:42,010
weights and and shapes and stuff and

00:41:39,700 --> 00:41:44,310
that the road is random but for each

00:41:42,010 --> 00:41:46,300
iteration the road stays the same and

00:41:44,310 --> 00:41:48,730
hopefully this car will crash in a

00:41:46,300 --> 00:41:53,800
minute and then it starts again and then

00:41:48,730 --> 00:41:55,180
you start to see that the yeah and you

00:41:53,800 --> 00:41:56,740
can leave this room for hours and the

00:41:55,180 --> 00:41:58,300
cars get really good and they work out

00:41:56,740 --> 00:42:00,370
how to get over this kind of stuff and

00:41:58,300 --> 00:42:02,200
so you see this is quite a similar car

00:42:00,370 --> 00:42:04,210
to the one that just passed it and you

00:42:02,200 --> 00:42:06,040
can see look yeah I think that's the

00:42:04,210 --> 00:42:10,750
ghost in the backgrounds but anyway we

00:42:06,040 --> 00:42:13,720
get a get a bit sidetracked I think here

00:42:10,750 --> 00:42:16,170
and I mean I suppose the world's your

00:42:13,720 --> 00:42:18,370
oyster really a game playing bots maybe

00:42:16,170 --> 00:42:21,400
maybe sort of write something to play

00:42:18,370 --> 00:42:24,660
poker or something like that maybe you

00:42:21,400 --> 00:42:26,980
can think of yourself of your own so

00:42:24,660 --> 00:42:29,080
yeah that's that's all I had time to

00:42:26,980 --> 00:42:32,320
talk about really um I put a few links

00:42:29,080 --> 00:42:34,300
up here this talk was originally

00:42:32,320 --> 00:42:36,130
inspired by a blog post i saw of a guy

00:42:34,300 --> 00:42:38,890
who did the Mona Lisa he did it in

00:42:36,130 --> 00:42:40,720
c-sharp it technically wasn't a genetic

00:42:38,890 --> 00:42:43,060
algorithm because it was purely random

00:42:40,720 --> 00:42:45,070
and just flipping bits there was no

00:42:43,060 --> 00:42:49,000
concept of a mutation pool or things

00:42:45,070 --> 00:42:51,340
like that this book here is kind of the

00:42:49,000 --> 00:42:53,590
de facto Bible for genetic algorithms

00:42:51,340 --> 00:42:55,300
and it was written in the 80s and then

00:42:53,590 --> 00:42:57,160
I've put a link up here to all the code

00:42:55,300 --> 00:42:58,930
from my talk because I didn't even show

00:42:57,160 --> 00:42:59,860
the implementation of my algorithm I

00:42:58,930 --> 00:43:02,380
didn't think that was kind of the

00:42:59,860 --> 00:43:03,850
interesting stuff to talk about but it's

00:43:02,380 --> 00:43:06,220
all up there and i'll send the link

00:43:03,850 --> 00:43:07,960
round for these after the talk so yeah

00:43:06,220 --> 00:43:10,180
that's all i had time to talk about i

00:43:07,960 --> 00:43:14,850
hope you enjoyed it if you have any

00:43:10,180 --> 00:43:14,850
questions plz plz shoutout

00:43:20,769 --> 00:43:31,099
it's a microphone this type gases fill

00:43:27,950 --> 00:43:34,640
the role of something like a decorator

00:43:31,099 --> 00:43:37,009
pattern and if it does does have any

00:43:34,640 --> 00:43:40,549
disadvantages of our decorative error I

00:43:37,009 --> 00:43:42,710
think so the question was does type

00:43:40,549 --> 00:43:47,089
classes fill the role of a decorator

00:43:42,710 --> 00:43:48,170
pattern that's right that's not

00:43:47,089 --> 00:43:53,359
something I've thought about before

00:43:48,170 --> 00:43:56,180
really um I don't think so I see I

00:43:53,359 --> 00:43:59,059
suppose a kind of one liner for what

00:43:56,180 --> 00:44:01,819
type classes are in my head is is really

00:43:59,059 --> 00:44:05,359
a way to add your own interface on to

00:44:01,819 --> 00:44:07,670
someone else's class so I mean they

00:44:05,359 --> 00:44:10,730
decorate the type but it's clearly not

00:44:07,670 --> 00:44:15,230
the oo decorator pattern I think they're

00:44:10,730 --> 00:44:19,000
completely separate yeah got a question

00:44:15,230 --> 00:44:22,009
here you can shout it out I'll else

00:44:19,000 --> 00:44:23,809
really well much better than me much

00:44:22,009 --> 00:44:27,799
better than me but but it wasn't a real

00:44:23,809 --> 00:44:29,509
genetic algorithm yeah so joy now I

00:44:27,799 --> 00:44:33,319
won't show it because it's better than

00:44:29,509 --> 00:44:35,509
mine so but if it seriously I'll send

00:44:33,319 --> 00:44:39,160
this round or Google Mona Lisa genetic

00:44:35,509 --> 00:44:39,160
algorithm it's like the top hit so

00:44:39,190 --> 00:44:45,880
anyone else yeah it was a question at

00:44:43,400 --> 00:44:45,880
the back there

00:44:55,890 --> 00:45:01,000
it was more of a comment or a hug if you

00:44:59,290 --> 00:45:02,770
don't mind yeah I'm actually in the

00:45:01,000 --> 00:45:04,930
middle of writing a genetic algorithms

00:45:02,770 --> 00:45:08,290
framework okay in native Scala because

00:45:04,930 --> 00:45:10,150
there exists some for java and my first

00:45:08,290 --> 00:45:12,130
iteration was doing it with traditional

00:45:10,150 --> 00:45:13,900
inheritance but I've since moved on to

00:45:12,130 --> 00:45:16,000
the type last pattern so I totally agree

00:45:13,900 --> 00:45:17,860
with you that it's great uh that's a

00:45:16,000 --> 00:45:19,720
great a great hair i doing it right uh

00:45:17,860 --> 00:45:22,060
yeah so if anybody feels particularly

00:45:19,720 --> 00:45:23,590
inspired and wants to help you know come

00:45:22,060 --> 00:45:27,480
find me and we talk about genetic

00:45:23,590 --> 00:45:27,480
algorithms all day ha that's really cool

00:45:27,720 --> 00:45:35,110
ok I saw another hand somewhere i'm

00:45:30,160 --> 00:45:36,790
gonna go no no ok alright well thank

00:45:35,110 --> 00:45:39,540
thanks again for coming along and i hope

00:45:36,790 --> 00:45:39,540

YouTube URL: https://www.youtube.com/watch?v=lTd3Ep8jGrw


