Title: better files: Towards a safe, sane I O library in Scala by Pathikrit Bhowmick
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
Doing I/O in Scala (and Java) involves either invoking some magic "FileUtil" or browsing through StackOverflow. In this talk, we will introduce better-files (https://github.com/pathikrit/better-files) - a thin wrapper around Java NIO to enable simple, safe and sane I/O in Scala. We will also discuss problems with designing an I/O library that would make everyone happy and different schools of thoughts e.g. monadic vs non-blocking vs effect-based APIs
Captions: 
	00:00:00,000 --> 00:00:06,450
my name is patty quit bhowmik i'll be

00:00:03,389 --> 00:00:08,940
talking about doing io n scala or my

00:00:06,450 --> 00:00:12,480
experience doing iron scala things I

00:00:08,940 --> 00:00:14,549
learned and I wrote a little library to

00:00:12,480 --> 00:00:19,680
make my life easier and my experience

00:00:14,549 --> 00:00:23,939
and sharing it with you so yes so when I

00:00:19,680 --> 00:00:26,939
talk about IO in Scala I specifically

00:00:23,939 --> 00:00:29,730
mean file system I oh so this is things

00:00:26,939 --> 00:00:32,660
like reading of string from a file like

00:00:29,730 --> 00:00:36,540
our writing something to a directory or

00:00:32,660 --> 00:00:39,239
listing a directory maybe some of like

00:00:36,540 --> 00:00:45,510
the UNIX utils like changing the

00:00:39,239 --> 00:00:47,430
ownership jamar zip unzip md5 upper

00:00:45,510 --> 00:00:50,160
directory moving renaming all those

00:00:47,430 --> 00:00:52,379
kinds of operations like file system

00:00:50,160 --> 00:00:56,070
operations so I'm not going to talk

00:00:52,379 --> 00:00:57,809
about the network I or any other kind of

00:00:56,070 --> 00:01:01,829
i/o basically just file system

00:00:57,809 --> 00:01:05,640
operations let's talk so unfortunately

00:01:01,829 --> 00:01:09,090
in Scala or in Java doing our doubt

00:01:05,640 --> 00:01:11,159
everyone would anyone here would get

00:01:09,090 --> 00:01:14,159
this correct on the top of your head

00:01:11,159 --> 00:01:16,500
right now you'd and it's because it's

00:01:14,159 --> 00:01:18,299
just you have to write five six lines of

00:01:16,500 --> 00:01:23,520
code to do any of these in some cases

00:01:18,299 --> 00:01:25,799
maybe more and unlike in other languages

00:01:23,520 --> 00:01:27,479
if you come from Python or go a ruby

00:01:25,799 --> 00:01:30,780
like most of these operations are really

00:01:27,479 --> 00:01:34,170
simple and at least for me I can write a

00:01:30,780 --> 00:01:36,329
unix command line up to do any of this

00:01:34,170 --> 00:01:38,490
much faster than i can write Scala code

00:01:36,329 --> 00:01:40,979
to do this and that's not idea of like

00:01:38,490 --> 00:01:43,170
that should not be I am generally faster

00:01:40,979 --> 00:01:44,520
in coding is color than in yonex but

00:01:43,170 --> 00:01:46,320
except when it comes to doing file

00:01:44,520 --> 00:01:49,110
system operations where I know how to

00:01:46,320 --> 00:01:51,930
use the command line better so what do

00:01:49,110 --> 00:01:57,390
most people do like they go and google

00:01:51,930 --> 00:02:02,460
and find things copy paste from yes

00:01:57,390 --> 00:02:05,670
stack overflow okay yeah I mean this is

00:02:02,460 --> 00:02:07,380
my point like how to read a file in

00:02:05,670 --> 00:02:10,349
Scala I took the screenshot a long time

00:02:07,380 --> 00:02:13,230
back it has more and it has like 200

00:02:10,349 --> 00:02:16,650
people favorited it a lot more started

00:02:13,230 --> 00:02:19,640
and how to write a file in Scala again

00:02:16,650 --> 00:02:21,900
and the funny thing is the top to the

00:02:19,640 --> 00:02:23,819
accepted answer here and the accepted

00:02:21,900 --> 00:02:26,459
answer here don't really work this this

00:02:23,819 --> 00:02:28,890
one suggests a library that the last

00:02:26,459 --> 00:02:32,970
commit was in like seven years ago and

00:02:28,890 --> 00:02:35,340
this one the accepted answer is B on the

00:02:32,970 --> 00:02:38,879
screen shot is actually buggy it leaves

00:02:35,340 --> 00:02:41,610
a file handler open it never says how to

00:02:38,879 --> 00:02:45,360
close it so given copying pasting from

00:02:41,610 --> 00:02:48,989
Stack Overflow might by chick so right

00:02:45,360 --> 00:02:53,010
so let's look at something really simple

00:02:48,989 --> 00:02:55,440
you want to append a string to a file

00:02:53,010 --> 00:02:58,739
and how are you going to read that oh ok

00:02:55,440 --> 00:03:01,709
this is what it looks like using no

00:02:58,739 --> 00:03:05,580
other external library you create a file

00:03:01,709 --> 00:03:07,440
output stream and I don't know a job in

00:03:05,580 --> 00:03:09,180
Java you cannot name your parameter so I

00:03:07,440 --> 00:03:11,790
don't know what that true does you have

00:03:09,180 --> 00:03:13,860
to ask you ID and you create a

00:03:11,790 --> 00:03:15,720
bufferedwriter pass in an output stream

00:03:13,860 --> 00:03:17,190
writer from the file output stream you

00:03:15,720 --> 00:03:19,860
append the tax and you close all of

00:03:17,190 --> 00:03:23,459
these and this is the simplest code I

00:03:19,860 --> 00:03:28,080
could write it to pen the test to a file

00:03:23,459 --> 00:03:30,720
and ok I mean yes six lines of code ok

00:03:28,080 --> 00:03:33,569
but really like you shouldn't have to

00:03:30,720 --> 00:03:36,000
write all this to like and you probably

00:03:33,569 --> 00:03:38,629
got to it from Stack Overflow anyway so

00:03:36,000 --> 00:03:40,830
you shouldn't have to write all this so

00:03:38,629 --> 00:03:43,680
again and there are a lot of things that

00:03:40,830 --> 00:03:45,900
this doesn't even do like what if the

00:03:43,680 --> 00:03:48,209
file does not exist what you get like

00:03:45,900 --> 00:03:49,290
that would it create the file for you

00:03:48,209 --> 00:03:52,200
and append to it would you get an

00:03:49,290 --> 00:03:54,599
exception it's not obvious what if you

00:03:52,200 --> 00:03:55,860
are writing to a directory or you don't

00:03:54,599 --> 00:03:57,360
even have permissions to write to the

00:03:55,860 --> 00:04:00,120
file what kind of exceptions are you

00:03:57,360 --> 00:04:01,739
going to get again these are unknown

00:04:00,120 --> 00:04:04,049
things and something even basic like

00:04:01,739 --> 00:04:06,659
let's say you're writing to a file that

00:04:04,049 --> 00:04:08,939
file is a symlink to another file would

00:04:06,659 --> 00:04:10,650
you get an exception are are you going

00:04:08,939 --> 00:04:12,989
to follow the symlink and append to that

00:04:10,650 --> 00:04:14,310
file you don't know i mean this code

00:04:12,989 --> 00:04:17,340
it's not obvious from this chord it's

00:04:14,310 --> 00:04:20,820
not obvious from this API so yeah their

00:04:17,340 --> 00:04:23,280
problems too even doing basic io using

00:04:20,820 --> 00:04:27,520
what's available out there

00:04:23,280 --> 00:04:30,849
so okay that was easy to look down upon

00:04:27,520 --> 00:04:34,449
Java or something and this is java niño

00:04:30,849 --> 00:04:36,669
too so this is the new niño library that

00:04:34,449 --> 00:04:40,599
came out in Java 7 which is supposed to

00:04:36,669 --> 00:04:42,699
make your life I or life easier and this

00:04:40,599 --> 00:04:44,740
is an example so you're given soil in

00:04:42,699 --> 00:04:47,650
niño to they said okay java dot io dot

00:04:44,740 --> 00:04:51,400
file is the old one let's try a new one

00:04:47,650 --> 00:04:53,259
it's the Java ni o dot but which you

00:04:51,400 --> 00:04:57,340
should use all their api's are based on

00:04:53,259 --> 00:04:59,440
that okay fine so you want to copy from

00:04:57,340 --> 00:05:00,969
a source to a destination and this is

00:04:59,440 --> 00:05:03,190
what it looks like oh this is great I

00:05:00,969 --> 00:05:05,830
mean why do we need a library this this

00:05:03,190 --> 00:05:09,250
is one line of code until you read the

00:05:05,830 --> 00:05:12,400
documentation so since one of the files

00:05:09,250 --> 00:05:15,219
can be copied and only empty directories

00:05:12,400 --> 00:05:18,129
can be copied and it's in it's in the

00:05:15,219 --> 00:05:21,789
Oracle docsis it nowhere else so what

00:05:18,129 --> 00:05:24,729
happens when you actually try to copy a

00:05:21,789 --> 00:05:28,630
directory that has files in it you get

00:05:24,729 --> 00:05:34,750
java ni r dot file dot directory not

00:05:28,630 --> 00:05:37,719
empty exception and so you thought you

00:05:34,750 --> 00:05:40,569
you will be third niño save you you got

00:05:37,719 --> 00:05:43,300
this one line of code but no it didn't

00:05:40,569 --> 00:05:44,889
save you it actually you just are in a

00:05:43,300 --> 00:05:48,219
whole world of pain when you run the

00:05:44,889 --> 00:05:51,969
code so how do you actually copy

00:05:48,219 --> 00:05:53,949
directories in Java so I actually went

00:05:51,969 --> 00:05:56,139
to the Oracle website they have an

00:05:53,949 --> 00:05:57,849
example of how to actually do the copy

00:05:56,139 --> 00:05:59,379
if they had written it the way people

00:05:57,849 --> 00:06:03,190
would have expected them to write it and

00:05:59,379 --> 00:06:05,889
I did a most faithful idiomatic Scala

00:06:03,190 --> 00:06:09,009
translation of that code and this is how

00:06:05,889 --> 00:06:12,250
you do a recursive copy I'm not kidding

00:06:09,009 --> 00:06:14,340
you thought it you could just copy write

00:06:12,250 --> 00:06:17,229
a recursive method which would copy but

00:06:14,340 --> 00:06:19,509
it's not that efficient you have to use

00:06:17,229 --> 00:06:22,300
the walk file tree because your

00:06:19,509 --> 00:06:25,650
operating system might let you walk the

00:06:22,300 --> 00:06:30,039
file system faster than if you just do a

00:06:25,650 --> 00:06:32,560
naive recursive Scala copy so okay this

00:06:30,039 --> 00:06:34,960
is how you do it and obviously this is

00:06:32,560 --> 00:06:36,279
code that you wouldn't know on the top

00:06:34,960 --> 00:06:36,670
of your head unless you've been doing

00:06:36,279 --> 00:06:40,090
Java

00:06:36,670 --> 00:06:44,550
of programming for many years are you

00:06:40,090 --> 00:06:47,080
the guy who wrote this API so again this

00:06:44,550 --> 00:06:50,140
this Oracle's example you can actually

00:06:47,080 --> 00:06:52,240
go to this web page it doesn't even

00:06:50,140 --> 00:06:56,010
answer the questions I raised earlier

00:06:52,240 --> 00:07:01,600
like symlink handling follow the

00:06:56,010 --> 00:07:02,890
permission errors whatnot so let's so

00:07:01,600 --> 00:07:05,260
that's just to give you a taste of what

00:07:02,890 --> 00:07:07,030
the problems out there so what are the

00:07:05,260 --> 00:07:08,980
solutions available so let's just look

00:07:07,030 --> 00:07:12,130
at Java solutions being in Scala it's

00:07:08,980 --> 00:07:14,770
nice we can call any java api's so there

00:07:12,130 --> 00:07:16,660
are these two very good libraries I have

00:07:14,770 --> 00:07:20,710
nothing against them Google guava

00:07:16,660 --> 00:07:23,170
library and apache commons io library if

00:07:20,710 --> 00:07:25,060
you don't want to use better files or

00:07:23,170 --> 00:07:27,940
something this is you can go use it it

00:07:25,060 --> 00:07:32,620
works it's used in production in google

00:07:27,940 --> 00:07:36,340
so great they're minor inconsistencies

00:07:32,620 --> 00:07:38,500
that I as a scholar programmer that it's

00:07:36,340 --> 00:07:39,670
always that get a little bad taste in

00:07:38,500 --> 00:07:42,270
your mouth when you have to call some

00:07:39,670 --> 00:07:46,060
java library because it's not a dramatic

00:07:42,270 --> 00:07:47,710
for example all when you use Google

00:07:46,060 --> 00:07:50,080
Guevara Pesce comments you always have

00:07:47,710 --> 00:07:52,200
to do some kind of i/o util dot do

00:07:50,080 --> 00:07:54,520
something and you pass the file end and

00:07:52,200 --> 00:07:56,590
its color we can have implicit

00:07:54,520 --> 00:07:58,980
decorations and you could have done this

00:07:56,590 --> 00:08:01,690
of course you could write your own

00:07:58,980 --> 00:08:06,190
decorator on the file class to do this

00:08:01,690 --> 00:08:07,840
offer you and other stuff like Java has

00:08:06,190 --> 00:08:10,150
an eye scanner class I don't know how

00:08:07,840 --> 00:08:12,460
you know many of you may not know any so

00:08:10,150 --> 00:08:14,950
it has a little YouTube which can slurp

00:08:12,460 --> 00:08:17,980
inputs from different files screams what

00:08:14,950 --> 00:08:21,190
not and they have all this dot next int

00:08:17,980 --> 00:08:22,960
next boolean next string whatnot in

00:08:21,190 --> 00:08:24,430
Scala we could have used something

00:08:22,960 --> 00:08:26,020
better you could have put a next and

00:08:24,430 --> 00:08:28,690
passed it as a type parameter I didn't

00:08:26,020 --> 00:08:30,700
have to have 17 dot next methods like

00:08:28,690 --> 00:08:32,560
the Java one has but I have nothing

00:08:30,700 --> 00:08:35,500
canceling these are just minor stylistic

00:08:32,560 --> 00:08:38,620
idiomatic complaints that I have so they

00:08:35,500 --> 00:08:41,140
work ok plain Java niño as i showed

00:08:38,620 --> 00:08:43,450
before it's full of traps don't use it

00:08:41,140 --> 00:08:45,850
like if you want to count the number of

00:08:43,450 --> 00:08:48,400
lines in a file that should be easy this

00:08:45,850 --> 00:08:50,600
should this is what it looks like this

00:08:48,400 --> 00:08:53,990
does not work it has a bug in it

00:08:50,600 --> 00:08:57,019
it actually opens a file handler open

00:08:53,990 --> 00:08:59,209
and you you wouldn't know that because

00:08:57,019 --> 00:09:05,029
its return something that needs to be

00:08:59,209 --> 00:09:07,399
closed so this is one of my favorite

00:09:05,029 --> 00:09:09,110
example so not only the library can do

00:09:07,399 --> 00:09:10,940
something that you don't expect to do

00:09:09,110 --> 00:09:12,560
light can introduce bugs in your code

00:09:10,940 --> 00:09:14,480
like if you run this code enough times

00:09:12,560 --> 00:09:17,209
you would have too many file open

00:09:14,480 --> 00:09:19,819
exceptions down the line art and it's

00:09:17,209 --> 00:09:22,100
just way too verbose so something as

00:09:19,819 --> 00:09:25,579
simple as changing the ownership of a

00:09:22,100 --> 00:09:27,980
file given my string ownership is this

00:09:25,579 --> 00:09:30,110
you do file start set owner you get the

00:09:27,980 --> 00:09:32,660
file system you get the user principal

00:09:30,110 --> 00:09:34,639
lookup service and look a principal by

00:09:32,660 --> 00:09:36,519
name and that's how you do it I mean

00:09:34,639 --> 00:09:39,620
this is a lot of code and there's no way

00:09:36,519 --> 00:09:41,420
you would have guessed to do this and

00:09:39,620 --> 00:09:43,069
you just want an API which takes in a

00:09:41,420 --> 00:09:47,899
file and a string and you should be able

00:09:43,069 --> 00:09:49,730
to chamada shown it okay so enough about

00:09:47,899 --> 00:09:52,339
Java so what exists in Scala let's look

00:09:49,730 --> 00:09:54,410
at it so this is called a standard

00:09:52,339 --> 00:09:56,209
library scholar at IO dot source it

00:09:54,410 --> 00:09:58,279
doesn't solve most of the problems it

00:09:56,209 --> 00:10:00,649
can maybe do reads and write like

00:09:58,279 --> 00:10:07,480
anything else like moving directories

00:10:00,649 --> 00:10:10,160
recursively shimadzu unzip listing and

00:10:07,480 --> 00:10:13,100
merging directory splitting it doesn't

00:10:10,160 --> 00:10:15,980
do it all of that so there's Scala I oh

00:10:13,100 --> 00:10:20,029
that's the answer that was mentioned in

00:10:15,980 --> 00:10:22,160
Stack Overflow a lot but I've well one

00:10:20,029 --> 00:10:25,069
is the it seems it's abandoned the last

00:10:22,160 --> 00:10:27,529
commit was in 2012 there was updating

00:10:25,069 --> 00:10:30,529
the readme the actual comments were even

00:10:27,529 --> 00:10:32,829
further back than that and it tries to

00:10:30,529 --> 00:10:36,259
do a lot it tries to introduce

00:10:32,829 --> 00:10:37,850
abstractions that does not that exist in

00:10:36,259 --> 00:10:39,980
Java like all the print writers and

00:10:37,850 --> 00:10:42,620
buffered readers and tries to have a

00:10:39,980 --> 00:10:45,620
parallel Scala world so it's pretty

00:10:42,620 --> 00:10:47,569
ambitious and now we have to have to

00:10:45,620 --> 00:10:50,480
mental models you not only have to be

00:10:47,569 --> 00:10:52,279
aware of the Java I OAPs now you also

00:10:50,480 --> 00:10:56,839
have to be aware of the scholar I of

00:10:52,279 --> 00:11:01,510
api's so the third option is mo night

00:10:56,839 --> 00:11:04,600
ops this is a great library by how early

00:11:01,510 --> 00:11:07,660
have not much against it except is two

00:11:04,600 --> 00:11:09,660
things it is actually was intended to be

00:11:07,660 --> 00:11:14,320
used in the ammonite library which is a

00:11:09,660 --> 00:11:16,420
very awesome shell library where you can

00:11:14,320 --> 00:11:19,570
write scala in a shell like environment

00:11:16,420 --> 00:11:22,030
and for that reason it has a syntax

00:11:19,570 --> 00:11:23,500
that's reminiscent of the shell like if

00:11:22,030 --> 00:11:28,210
you want to remove a directory you do

00:11:23,500 --> 00:11:30,640
this this this is not scala that we're

00:11:28,210 --> 00:11:32,200
normally used to it fits great with the

00:11:30,640 --> 00:11:33,610
use case of this library which was it

00:11:32,200 --> 00:11:36,610
was originally intended for the

00:11:33,610 --> 00:11:38,440
ammonites shell it was great the other

00:11:36,610 --> 00:11:41,020
minor thing I played around with this

00:11:38,440 --> 00:11:44,020
library before I wrote this library was

00:11:41,020 --> 00:11:45,970
it doesn't do something let's say if I

00:11:44,020 --> 00:11:48,160
want to add a text to a file and I want

00:11:45,970 --> 00:11:51,220
to not use the default Kodak use my

00:11:48,160 --> 00:11:53,020
custom Scarborough codec or if I want to

00:11:51,220 --> 00:11:55,720
give a custom link option saying okay

00:11:53,020 --> 00:11:57,550
when i append to this file make sure if

00:11:55,720 --> 00:11:59,740
it's a symlink I don't want to append to

00:11:57,550 --> 00:12:01,840
it but or maybe I do want to follow the

00:11:59,740 --> 00:12:04,930
same line so Java lets you do that you

00:12:01,840 --> 00:12:07,870
can pass in all these options it was

00:12:04,930 --> 00:12:12,520
just not possible in a mo night at least

00:12:07,870 --> 00:12:14,650
when I looked at it and the last option

00:12:12,520 --> 00:12:16,300
is always roll your own so if you

00:12:14,650 --> 00:12:19,060
actually do a search for i/o util dot

00:12:16,300 --> 00:12:21,850
Scala you'd find so many libraries that

00:12:19,060 --> 00:12:24,310
use it player has its own I owe you two

00:12:21,850 --> 00:12:25,930
n-sided SBT has his own I or utility

00:12:24,310 --> 00:12:28,360
inside it even the Scala compiler has

00:12:25,930 --> 00:12:29,650
its own I owe you two inside out and

00:12:28,360 --> 00:12:33,490
they do the same thing over and over

00:12:29,650 --> 00:12:35,680
again and we are all familiar with dry

00:12:33,490 --> 00:12:38,320
do not repeat yourself but i think i'm

00:12:35,680 --> 00:12:39,970
more important takeaway would we do not

00:12:38,320 --> 00:12:42,160
repeat other people if someone already

00:12:39,970 --> 00:12:45,120
has it we shouldn't be like using the

00:12:42,160 --> 00:12:48,100
same you to class in all our libraries

00:12:45,120 --> 00:12:50,020
so and the last option is this is the

00:12:48,100 --> 00:12:52,300
one I'm talking about better files it's

00:12:50,020 --> 00:12:54,370
it's a really bad name for a library but

00:12:52,300 --> 00:12:56,730
I'm stuck with it so the reason I'm

00:12:54,370 --> 00:13:01,600
stuck with this name is I started adding

00:12:56,730 --> 00:13:03,400
implicit to this java file class and it

00:13:01,600 --> 00:13:06,660
was I call it the better file implicit

00:13:03,400 --> 00:13:09,910
class and that's how it the name started

00:13:06,660 --> 00:13:13,330
so before I go through a tour of the

00:13:09,910 --> 00:13:15,699
library I want to talk about like

00:13:13,330 --> 00:13:20,169
designing an i/o library

00:13:15,699 --> 00:13:22,119
in Scala like the Sioux scholar attracts

00:13:20,169 --> 00:13:24,040
a lot of different ideas a lot of

00:13:22,119 --> 00:13:25,899
different developers who come from

00:13:24,040 --> 00:13:27,639
different backgrounds and they all have

00:13:25,899 --> 00:13:32,859
different ideas of how about how to do

00:13:27,639 --> 00:13:35,939
things so let us talk about I oh so even

00:13:32,859 --> 00:13:39,129
in I oh this does the the people who

00:13:35,939 --> 00:13:42,100
come from the very strongly functional

00:13:39,129 --> 00:13:43,720
background they feel that okay I own has

00:13:42,100 --> 00:13:46,149
side effects it should be captured using

00:13:43,720 --> 00:13:49,600
the IO monad it should be completely

00:13:46,149 --> 00:13:51,639
exception free completely side effects

00:13:49,600 --> 00:13:56,049
should be isolated using monads so on

00:13:51,639 --> 00:13:59,199
and so forth and we also have other

00:13:56,049 --> 00:14:01,269
ideas like we have the aca's reactive

00:13:59,199 --> 00:14:03,489
screens philosophy where okay I 0 is

00:14:01,269 --> 00:14:06,639
just moving data around maybe we should

00:14:03,489 --> 00:14:08,679
model it as streams where you're using

00:14:06,639 --> 00:14:13,119
some flow mattresses sources and sinks

00:14:08,679 --> 00:14:14,889
you buy things around and we also have a

00:14:13,119 --> 00:14:18,399
scholar Jess which is coming up a lot of

00:14:14,889 --> 00:14:20,470
people are using it and IO is inherently

00:14:18,399 --> 00:14:21,850
it has some special things it is slow so

00:14:20,470 --> 00:14:23,589
people would like to do it

00:14:21,850 --> 00:14:25,869
asynchronously church should the library

00:14:23,589 --> 00:14:28,209
be asynchronous or you can always wrap

00:14:25,869 --> 00:14:30,519
it in a future and library buddy fala

00:14:28,209 --> 00:14:32,019
synchronous or what about exception I

00:14:30,519 --> 00:14:33,999
always inherently has a lot of

00:14:32,019 --> 00:14:35,470
exceptions that can happen like you may

00:14:33,999 --> 00:14:37,600
not have permissions the file might go

00:14:35,470 --> 00:14:38,859
away how do you capture that you put it

00:14:37,600 --> 00:14:43,299
in the type system do you throw

00:14:38,859 --> 00:14:45,160
exceptions happily like Java or expect

00:14:43,299 --> 00:14:48,009
your upstream users to wrap it in a try

00:14:45,160 --> 00:14:50,649
are you do some kind of things like what

00:14:48,009 --> 00:14:53,499
no Jess does where you do a callback

00:14:50,649 --> 00:14:57,189
which on success on error and you do

00:14:53,499 --> 00:14:59,319
stuff and not only that we also have a

00:14:57,189 --> 00:15:00,939
lot of Java baggage to deal with like

00:14:59,319 --> 00:15:02,559
there's a Java has a lot of these print

00:15:00,939 --> 00:15:03,850
writers and output stream writers and

00:15:02,559 --> 00:15:07,389
buffered readers and input stream

00:15:03,850 --> 00:15:09,720
readers and we I don't know when that

00:15:07,389 --> 00:15:12,100
out of my head which one does what and

00:15:09,720 --> 00:15:13,779
you have to win scholar you sometimes

00:15:12,100 --> 00:15:17,919
have to deal with them unfortunately and

00:15:13,779 --> 00:15:19,720
so how do you incorporate that and at

00:15:17,919 --> 00:15:21,399
the end of the day you just want to get

00:15:19,720 --> 00:15:24,999
things done one that you just want to

00:15:21,399 --> 00:15:26,470
write something and I mean it it's not

00:15:24,999 --> 00:15:28,620
here there's also a new things that's

00:15:26,470 --> 00:15:30,910
coming up in da T which is

00:15:28,620 --> 00:15:32,290
capturing using side effects in the type

00:15:30,910 --> 00:15:34,840
system so that's another way of looking

00:15:32,290 --> 00:15:37,060
at things so my point is writing a scud

00:15:34,840 --> 00:15:39,700
library and especially something like I

00:15:37,060 --> 00:15:42,580
owe in in Scala is interesting because

00:15:39,700 --> 00:15:45,790
you have all these ideas that flow in so

00:15:42,580 --> 00:15:49,270
better files is my very extremely

00:15:45,790 --> 00:15:51,310
opinionated way of doing things if you

00:15:49,270 --> 00:15:53,920
can see a manifestation of this

00:15:51,310 --> 00:15:56,290
discussion here where there was a slip

00:15:53,920 --> 00:15:58,060
open on scholar to write a better io

00:15:56,290 --> 00:15:59,800
library and the discussion went on and

00:15:58,060 --> 00:16:03,040
on and on and nothing happened because

00:15:59,800 --> 00:16:12,430
everyone thought their way of doing was

00:16:03,040 --> 00:16:14,740
the best way okay so so they said these

00:16:12,430 --> 00:16:19,000
are my completely opinionated design

00:16:14,740 --> 00:16:20,950
goals for the better files so one is you

00:16:19,000 --> 00:16:25,600
should not have to import any other

00:16:20,950 --> 00:16:28,390
library so when I wrote the initial API

00:16:25,600 --> 00:16:31,540
I looked at all the major I OU libraries

00:16:28,390 --> 00:16:33,280
which is google guava apache commons the

00:16:31,540 --> 00:16:36,010
java an iou tells itself and this is

00:16:33,280 --> 00:16:38,560
another java library called jawed it's

00:16:36,010 --> 00:16:40,660
very nice I looked at them made a list

00:16:38,560 --> 00:16:42,240
of okay all these are all the i/o utils

00:16:40,660 --> 00:16:45,280
that I've anyone would ever need that's

00:16:42,240 --> 00:16:49,690
super set of all these for libraries and

00:16:45,280 --> 00:16:52,110
put them in this one better files and it

00:16:49,690 --> 00:16:54,730
should not have external dependencies

00:16:52,110 --> 00:16:55,720
this is just for aesthetic reason I

00:16:54,730 --> 00:16:58,320
didn't want to depend on any other

00:16:55,720 --> 00:17:04,570
library and should just depend on its

00:16:58,320 --> 00:17:06,610
collar or Java JDK and it should it

00:17:04,570 --> 00:17:09,610
should not do something advanced like

00:17:06,610 --> 00:17:14,829
all it should do is wrap java and I oh

00:17:09,610 --> 00:17:17,890
and remove the idiosyncrasies and the

00:17:14,829 --> 00:17:19,360
weird corner cases and surprises that

00:17:17,890 --> 00:17:20,740
java and IO has and it should just

00:17:19,360 --> 00:17:26,530
smooth it out it shouldn't do anything

00:17:20,740 --> 00:17:28,270
advanced and again no I there is no new

00:17:26,530 --> 00:17:30,370
concepts like Scala I or try to

00:17:28,270 --> 00:17:33,520
introduce like you you just have the

00:17:30,370 --> 00:17:35,800
file class and this just adds helpers to

00:17:33,520 --> 00:17:38,379
the file class our implicit and you get

00:17:35,800 --> 00:17:40,789
a new and that's it there's no new

00:17:38,379 --> 00:17:45,200
scala equivalence of printwriter or

00:17:40,789 --> 00:17:48,139
anything like that and the api's should

00:17:45,200 --> 00:17:50,869
be obvious like as we saw the copy

00:17:48,139 --> 00:17:52,460
example it's not obvious like when you

00:17:50,869 --> 00:17:56,059
look at it you expect something and

00:17:52,460 --> 00:17:59,240
something else happens so it should the

00:17:56,059 --> 00:18:02,539
library should not surprise you this one

00:17:59,240 --> 00:18:04,700
is interesting Scala has a very advanced

00:18:02,539 --> 00:18:06,950
type system and we could prevent some

00:18:04,700 --> 00:18:08,179
operations at compile time like if you

00:18:06,950 --> 00:18:11,179
have a directory and you're right into

00:18:08,179 --> 00:18:12,860
it maybe we can prevent that at compile

00:18:11,179 --> 00:18:15,019
time and the opposite if you have a

00:18:12,860 --> 00:18:18,499
regular file and your listing it that

00:18:15,019 --> 00:18:20,809
should not be allowed and we can prevent

00:18:18,499 --> 00:18:25,220
that at compile time by using a class

00:18:20,809 --> 00:18:28,549
hierarchy and another thing that's

00:18:25,220 --> 00:18:32,029
painful in Java is like somebody it's so

00:18:28,549 --> 00:18:33,789
in Java a7 they introduce resource

00:18:32,029 --> 00:18:39,499
management you can do the width thing

00:18:33,789 --> 00:18:42,679
but many api's may you may forget to

00:18:39,499 --> 00:18:45,950
close some resource and in sky this

00:18:42,679 --> 00:18:47,330
library is the least surprised in this

00:18:45,950 --> 00:18:52,450
way like it will try to close the

00:18:47,330 --> 00:18:55,669
resource for you as much as possible and

00:18:52,450 --> 00:18:58,549
again you should be able to configure it

00:18:55,669 --> 00:19:00,860
to your wishes for example if you want

00:18:58,549 --> 00:19:02,480
to follow a link if you want to write in

00:19:00,860 --> 00:19:04,519
our custom codec you should be able to

00:19:02,480 --> 00:19:07,340
do that but to use that you shouldn't

00:19:04,519 --> 00:19:09,409
have to specify 7 API parameters so all

00:19:07,340 --> 00:19:11,179
of them have this system defaults are

00:19:09,409 --> 00:19:14,179
saying defaults but you should be able

00:19:11,179 --> 00:19:17,659
to configure them so the libraries well

00:19:14,179 --> 00:19:20,210
tested that has 100% test coverage I try

00:19:17,659 --> 00:19:23,899
to this this talk motivated me to

00:19:20,210 --> 00:19:27,200
improve the documentation so hopefully

00:19:23,899 --> 00:19:30,889
it has documentation that you'll be able

00:19:27,200 --> 00:19:34,340
to read next is performance this library

00:19:30,889 --> 00:19:35,269
is it's not slower than Java is as fast

00:19:34,340 --> 00:19:38,149
as Java there's a little asterisk

00:19:35,269 --> 00:19:39,909
because there are some places where this

00:19:38,149 --> 00:19:43,100
library is actually way faster than Java

00:19:39,909 --> 00:19:45,080
for example scanner in Java uses ridge

00:19:43,100 --> 00:19:47,570
axis this does not this uses a partial

00:19:45,080 --> 00:19:50,800
Combinator so it's way faster so yeah

00:19:47,570 --> 00:19:58,420
it's fast or faster than Java

00:19:50,800 --> 00:20:00,340
so oops yeah so the last is again how we

00:19:58,420 --> 00:20:02,980
lease article about the principle of

00:20:00,340 --> 00:20:06,160
least power so the core of the library

00:20:02,980 --> 00:20:08,650
is not reactive not monadic not affect

00:20:06,160 --> 00:20:11,680
base not pure it doesn't do anything it

00:20:08,650 --> 00:20:13,870
does the least powerful thing to get I

00:20:11,680 --> 00:20:16,660
or done for you if you want reactive you

00:20:13,870 --> 00:20:18,850
have to wrap it if you want pure you

00:20:16,660 --> 00:20:23,010
have to put it wrap around with a try if

00:20:18,850 --> 00:20:24,820
you want something effect based or

00:20:23,010 --> 00:20:28,630
asynchronous you just wrap it in a

00:20:24,820 --> 00:20:30,640
future it's up to you and that's not bad

00:20:28,630 --> 00:20:34,570
like many of you in this room might

00:20:30,640 --> 00:20:36,910
disagree with it but that has not been

00:20:34,570 --> 00:20:39,640
bad so if you want advanced things you

00:20:36,910 --> 00:20:43,450
can always build on top of the solid

00:20:39,640 --> 00:20:45,040
core but it's hard to build advanced

00:20:43,450 --> 00:20:46,960
things from ground up if you don't have

00:20:45,040 --> 00:20:48,340
a solid core so the goal of better files

00:20:46,960 --> 00:20:51,790
is to give you solid core so you can

00:20:48,340 --> 00:20:55,570
build higher order libraries with higher

00:20:51,790 --> 00:20:57,700
abstractions on top of it so for example

00:20:55,570 --> 00:21:00,580
there's a simplified watcher in the

00:20:57,700 --> 00:21:02,500
library and there's an alcohol-based

00:21:00,580 --> 00:21:04,840
accra-based file watcher built on top of

00:21:02,500 --> 00:21:06,840
it and same for the scanner class

00:21:04,840 --> 00:21:08,920
there's a simple scanner which can scan

00:21:06,840 --> 00:21:11,590
primitives and there's a shapeless

00:21:08,920 --> 00:21:17,320
scanner which can scan H lists built on

00:21:11,590 --> 00:21:21,130
top of it so I'll take a quick tour of

00:21:17,320 --> 00:21:23,140
the library and and for this talk I will

00:21:21,130 --> 00:21:26,230
just use the github documentation

00:21:23,140 --> 00:21:32,880
because I want to make sure the docs are

00:21:26,230 --> 00:21:32,880
up-to-date so can you guys see it no

00:21:33,960 --> 00:21:43,300
better okay so this is the github page

00:21:40,500 --> 00:21:45,160
let's look at the docks so there are

00:21:43,300 --> 00:21:47,860
various ways you can instantiate a file

00:21:45,160 --> 00:21:50,470
the most recommended waves just passing

00:21:47,860 --> 00:21:52,210
in the argument but there are other

00:21:50,470 --> 00:21:55,660
lasers little string interpolator

00:21:52,210 --> 00:21:58,300
there's a little string dsl you can

00:21:55,660 --> 00:22:00,790
convert a java one to the scholar or you

00:21:58,300 --> 00:22:02,290
can use this little front slash dsl if

00:22:00,790 --> 00:22:03,460
you want to do some pot manipulation

00:22:02,290 --> 00:22:06,460
whatnot

00:22:03,460 --> 00:22:10,659
and everything comes with in one import

00:22:06,460 --> 00:22:15,669
and you might notice that I use the word

00:22:10,659 --> 00:22:18,429
file so this might clash with if you're

00:22:15,669 --> 00:22:20,049
also importing the Java one so you could

00:22:18,429 --> 00:22:22,480
always do this you can always import

00:22:20,049 --> 00:22:25,330
Java one as the file and rename the

00:22:22,480 --> 00:22:27,340
better files want you personally do the

00:22:25,330 --> 00:22:29,620
other way where I rename the Java 12 J

00:22:27,340 --> 00:22:34,510
file and import the better files one but

00:22:29,620 --> 00:22:37,659
that's up to you anyway some again read

00:22:34,510 --> 00:22:44,860
right ap eyes are really simple you just

00:22:37,659 --> 00:22:47,380
app and read the work as expected so all

00:22:44,860 --> 00:22:49,270
the api's have a fluent interface which

00:22:47,380 --> 00:22:52,299
means you can chain them so they usually

00:22:49,270 --> 00:22:55,539
return the objects itself so you can

00:22:52,299 --> 00:22:58,210
write the nice code like this creative

00:22:55,539 --> 00:23:01,720
not exist append a new line app and move

00:22:58,210 --> 00:23:04,120
to and some operations return not the

00:23:01,720 --> 00:23:05,980
source for the destination so move two

00:23:04,120 --> 00:23:11,580
dozen return the source it returns this

00:23:05,980 --> 00:23:14,140
guy so you can proceed it also supports

00:23:11,580 --> 00:23:17,679
if you don't want to load a giant file

00:23:14,140 --> 00:23:20,010
into memory you can get back you can do

00:23:17,679 --> 00:23:24,279
this api's to get back in a traitor and

00:23:20,010 --> 00:23:26,380
it's it's not a document it's not in

00:23:24,279 --> 00:23:30,130
this documentation but these are self

00:23:26,380 --> 00:23:31,929
closing iterators so if you iterate to

00:23:30,130 --> 00:23:34,330
the end of the file it will close the

00:23:31,929 --> 00:23:35,890
stream for you but if you crash out in

00:23:34,330 --> 00:23:44,559
the middle then the stream would be left

00:23:35,890 --> 00:23:48,520
open and again they like the API is all

00:23:44,559 --> 00:23:51,399
taken bunch of it has a lot of default

00:23:48,520 --> 00:23:53,049
implicit parameters so you could just

00:23:51,399 --> 00:23:54,640
write file dot write hello world but if

00:23:53,049 --> 00:23:59,679
you want to use your own custom codec

00:23:54,640 --> 00:24:01,179
you can pass the codec around we'll go

00:23:59,679 --> 00:24:07,179
over the scholar doc where we'll see

00:24:01,179 --> 00:24:10,630
this and it has so if you might be

00:24:07,179 --> 00:24:13,380
interested in integrating with the java

00:24:10,630 --> 00:24:15,660
and i ah library so it returns

00:24:13,380 --> 00:24:20,370
you it gives you easy access to all of

00:24:15,660 --> 00:24:22,980
these can do file dot new and get the

00:24:20,370 --> 00:24:24,630
Java and I'll classes these all take

00:24:22,980 --> 00:24:26,910
parameters and they all have sent

00:24:24,630 --> 00:24:28,680
defaults so you could create like this

00:24:26,910 --> 00:24:34,050
is an example where you can pass in a

00:24:28,680 --> 00:24:38,100
pen true or not if you want to so

00:24:34,050 --> 00:24:40,500
similar for so the the library also adds

00:24:38,100 --> 00:24:43,230
some helpful in Fliss it's not only to

00:24:40,500 --> 00:24:45,630
the file class but to all the Java and I

00:24:43,230 --> 00:24:47,040
of classes so if you have a printer

00:24:45,630 --> 00:24:48,510
writer if you have an output stream

00:24:47,040 --> 00:24:49,740
writer and you're like how do i convert

00:24:48,510 --> 00:24:53,160
it into print rider because i need a

00:24:49,740 --> 00:24:56,160
print writer you don't have to google it

00:24:53,160 --> 00:24:59,400
it's almost every Java and I or

00:24:56,160 --> 00:25:02,310
conversions all possible combinations

00:24:59,400 --> 00:25:04,950
from A to B are encoded into the library

00:25:02,310 --> 00:25:07,170
as implicit helpers and they all take in

00:25:04,950 --> 00:25:12,630
parameters if the conversion needs a

00:25:07,170 --> 00:25:15,240
parameter so this is the thing that was

00:25:12,630 --> 00:25:17,010
alluding to before we could use the type

00:25:15,240 --> 00:25:19,410
system hierarchy to write set the

00:25:17,010 --> 00:25:25,260
scholar type system to write safer code

00:25:19,410 --> 00:25:27,090
so you can match the file against the

00:25:25,260 --> 00:25:29,430
three basic types of files we have which

00:25:27,090 --> 00:25:32,100
is either a symbolic link where you

00:25:29,430 --> 00:25:35,130
where you pattern match to get the

00:25:32,100 --> 00:25:37,410
destination or a directory and you

00:25:35,130 --> 00:25:39,810
better manage this gives you the

00:25:37,410 --> 00:25:42,090
children of the directory or you get

00:25:39,810 --> 00:25:44,460
back the regular file and there could be

00:25:42,090 --> 00:25:46,440
other kinds of file which are not not

00:25:44,460 --> 00:25:48,540
any of these three and depends on the

00:25:46,440 --> 00:25:50,340
operating system so like a device file

00:25:48,540 --> 00:25:51,930
or a proc file could be one of those and

00:25:50,340 --> 00:25:55,590
they're not captured in the type system

00:25:51,930 --> 00:25:58,490
but this this makes writing certain

00:25:55,590 --> 00:26:01,410
codes like deleting much easier because

00:25:58,490 --> 00:26:03,330
you can decide you can write this kind

00:26:01,410 --> 00:26:06,240
of code as opposed to like a if else if

00:26:03,330 --> 00:26:09,570
else this makes the library code a lot

00:26:06,240 --> 00:26:12,480
easier to read and again you can use the

00:26:09,570 --> 00:26:15,360
unapplied syntax on many of you probably

00:26:12,480 --> 00:26:17,880
know it like you can use the extractor

00:26:15,360 --> 00:26:19,740
on the left hand side too so this you

00:26:17,880 --> 00:26:22,040
get the all the documents inside this

00:26:19,740 --> 00:26:22,040
folder

00:26:22,440 --> 00:26:29,139
so if you're the python has AG lobbying

00:26:26,169 --> 00:26:30,669
API so this also comes with one and

00:26:29,139 --> 00:26:33,129
these are the all the file system

00:26:30,669 --> 00:26:37,090
operations you might want to do so in

00:26:33,129 --> 00:26:39,519
touch delete rename move copy link

00:26:37,090 --> 00:26:42,789
symbolic link all the checksums md5

00:26:39,519 --> 00:26:48,039
shall once again chess set on or set

00:26:42,789 --> 00:26:51,279
groups there's some helpers to check if

00:26:48,039 --> 00:26:55,509
a file it has a lock on it and there's

00:26:51,279 --> 00:26:59,889
some dsl's that you can use if you want

00:26:55,509 --> 00:27:06,129
to pipe a concat files from a bunch of

00:26:59,889 --> 00:27:09,580
sources to a destination so this is

00:27:06,129 --> 00:27:12,870
again kind of based on an inspired by mo

00:27:09,580 --> 00:27:16,029
night ops so if you like writing unix

00:27:12,870 --> 00:27:19,330
shell commands in scala you can import

00:27:16,029 --> 00:27:24,129
this another one commands and you get

00:27:19,330 --> 00:27:25,539
all these little unix see utils they do

00:27:24,129 --> 00:27:27,610
this they just do the same thing as

00:27:25,539 --> 00:27:32,710
things on the file class i just called

00:27:27,610 --> 00:27:35,110
the file classes some more OS specific

00:27:32,710 --> 00:27:38,559
API is to find out the extension of a

00:27:35,110 --> 00:27:40,299
file again these are safe api's they

00:27:38,559 --> 00:27:42,909
return like if the file doesn't have an

00:27:40,299 --> 00:27:46,659
extension it's written option string so

00:27:42,909 --> 00:27:50,940
you get none and check for definitely

00:27:46,659 --> 00:27:54,789
different attributes permissions a and

00:27:50,940 --> 00:27:58,000
like hidden and not hidden readable

00:27:54,789 --> 00:28:00,159
executable etc there's also some nice

00:27:58,000 --> 00:28:02,830
tree api's if you want to do tree

00:28:00,159 --> 00:28:06,789
traversal i go up go list the siblings

00:28:02,830 --> 00:28:09,240
go down ancestors so there's some nice

00:28:06,789 --> 00:28:15,539
sibling api's or parent and child api's

00:28:09,240 --> 00:28:18,220
and all again all these api's they

00:28:15,539 --> 00:28:21,879
accept optional parameters which are

00:28:18,220 --> 00:28:24,100
this is just a java class so this would

00:28:21,879 --> 00:28:26,730
be a good time to show the scholar doc

00:28:24,100 --> 00:28:26,730
so

00:28:29,420 --> 00:28:38,250
so yeah so this is the Scala doc let's

00:28:36,480 --> 00:28:40,830
go to the file class so this is the only

00:28:38,250 --> 00:28:43,560
thing that you would need so it has all

00:28:40,830 --> 00:28:47,730
the utils in it and you can see that

00:28:43,560 --> 00:28:50,040
something as simple again like a lot of

00:28:47,730 --> 00:28:53,250
the complexity and configurability of

00:28:50,040 --> 00:28:55,530
the library is hidden in the Scala doc

00:28:53,250 --> 00:28:56,430
not as a library user has saying

00:28:55,530 --> 00:28:57,690
defaults it's kind of like the

00:28:56,430 --> 00:28:59,100
collections library if you actually look

00:28:57,690 --> 00:29:03,420
at the signatures it looks scary but

00:28:59,100 --> 00:29:05,760
it's easy to use so here okay if you

00:29:03,420 --> 00:29:07,650
want to append a line to a file it takes

00:29:05,760 --> 00:29:10,520
in a line you don't even have to specify

00:29:07,650 --> 00:29:13,760
it will append an empty line okay

00:29:10,520 --> 00:29:17,040
besides that there this it takes in to

00:29:13,760 --> 00:29:20,190
implicit options the open options and a

00:29:17,040 --> 00:29:24,930
codec the codec is and these are nothing

00:29:20,190 --> 00:29:29,910
new that I invented this is a scholar I

00:29:24,930 --> 00:29:36,840
or dot codec and this open options let's

00:29:29,910 --> 00:29:38,970
click on it what is it so this is right

00:29:36,840 --> 00:29:41,940
this is Java ni or dot filed an open

00:29:38,970 --> 00:29:44,220
option so it you can pass in that I want

00:29:41,940 --> 00:29:47,520
to only open this file in append mode or

00:29:44,220 --> 00:29:54,600
read write mode or follow link mode so

00:29:47,520 --> 00:29:56,400
on and so forth so yeah so this is

00:29:54,600 --> 00:29:58,020
pretty much the only class here that's a

00:29:56,400 --> 00:30:01,170
file class these are all the implicit

00:29:58,020 --> 00:30:04,200
that were added to all to the java and

00:30:01,170 --> 00:30:05,730
IO classes and this is the scanner i'll

00:30:04,200 --> 00:30:06,930
talk about it and the file watcher so

00:30:05,730 --> 00:30:11,210
there's nothing else going on and

00:30:06,930 --> 00:30:17,090
commands is the little unix dsl you tell

00:30:11,210 --> 00:30:17,090
okay so back to this

00:30:28,010 --> 00:30:37,010
and yeah so there's also this jamar API

00:30:35,360 --> 00:30:38,450
as you can add remove permissions you

00:30:37,010 --> 00:30:41,000
can check for different permissions you

00:30:38,450 --> 00:30:42,140
can compare files using if they have the

00:30:41,000 --> 00:30:45,140
same path or if they have the same

00:30:42,140 --> 00:30:48,500
content so there's you can use is same

00:30:45,140 --> 00:30:50,390
path as or is same content as that's

00:30:48,500 --> 00:30:52,160
some helpful ordering so when you list

00:30:50,390 --> 00:30:54,140
files you can pass an optional orderings

00:30:52,160 --> 00:30:57,440
if you want to order by name by size by

00:30:54,140 --> 00:30:59,300
depth so on and so forth zipping

00:30:57,440 --> 00:31:00,980
unzipping again a popular question on

00:30:59,300 --> 00:31:04,450
Stack Overflow heart one zip zip in Java

00:31:00,980 --> 00:31:07,780
escala this library comes with

00:31:04,450 --> 00:31:11,690
dependency free zip and unzip libraries

00:31:07,780 --> 00:31:15,470
and again we have automatic resource

00:31:11,690 --> 00:31:19,880
management so it adds this implicit auto

00:31:15,470 --> 00:31:22,820
closed to any closeable class in Java so

00:31:19,880 --> 00:31:25,490
you can write so this if you use this

00:31:22,820 --> 00:31:28,940
for each so it returns basically a

00:31:25,490 --> 00:31:30,950
traversable and if you do this in this

00:31:28,940 --> 00:31:34,600
kind of for syntax or if you do map or

00:31:30,950 --> 00:31:39,140
flat map are over it it will close the

00:31:34,600 --> 00:31:41,600
stream for you so here's an example

00:31:39,140 --> 00:31:43,310
where I have a bufferedreader and I did

00:31:41,600 --> 00:31:45,680
something with it so if you can either

00:31:43,310 --> 00:31:48,050
write it in this syntax using a for

00:31:45,680 --> 00:31:49,370
comprehension or just do a map is the

00:31:48,050 --> 00:31:51,340
same thing it will close the

00:31:49,370 --> 00:31:57,020
bufferedreader for you when it's done

00:31:51,340 --> 00:31:59,960
and I mentioned before most of the time

00:31:57,020 --> 00:32:01,250
when it returns an iterator for if when

00:31:59,960 --> 00:32:02,990
you're reading a file you want a trader

00:32:01,250 --> 00:32:04,880
of string of it right or by it's a trade

00:32:02,990 --> 00:32:07,460
of characters it written self-closing

00:32:04,880 --> 00:32:09,140
iterator so when you're finished when

00:32:07,460 --> 00:32:11,450
the iterator has a next is false it will

00:32:09,140 --> 00:32:13,280
close the stream for you but the caviar

00:32:11,450 --> 00:32:15,680
days if you don't actually finish it

00:32:13,280 --> 00:32:18,520
raiding the string will be left open so

00:32:15,680 --> 00:32:20,690
in that case I would recommend using the

00:32:18,520 --> 00:32:24,560
the traversable they ought a closed

00:32:20,690 --> 00:32:26,960
version instead of the odd a traitor so

00:32:24,560 --> 00:32:30,169
Java has a little java.util.scanner

00:32:26,960 --> 00:32:32,090
class so you can scan and

00:32:30,169 --> 00:32:34,369
and process process inputs from

00:32:32,090 --> 00:32:36,739
different sources from files input

00:32:34,369 --> 00:32:39,409
streams but not again it's not a

00:32:36,739 --> 00:32:40,879
dramatic scholar to use it this also

00:32:39,409 --> 00:32:42,679
it's extremely slow because it uses

00:32:40,879 --> 00:32:44,779
regex when you do next enter to the

00:32:42,679 --> 00:32:48,049
creates a Reggie Jackson teacher pattern

00:32:44,779 --> 00:32:51,080
and scans forward for it so the the

00:32:48,049 --> 00:32:53,029
better files one is much it's about five

00:32:51,080 --> 00:32:55,070
or six times faster than that one it

00:32:53,029 --> 00:32:57,669
uses a simple partial Combinator

00:32:55,070 --> 00:33:01,129
underneath so it doesn't use the regex

00:32:57,669 --> 00:33:04,220
and it uses type classes so you don't

00:33:01,129 --> 00:33:07,669
have to do next end you can pass next X

00:33:04,220 --> 00:33:12,230
where X has a readable interface for it

00:33:07,669 --> 00:33:13,639
so all there are readable defined for

00:33:12,230 --> 00:33:17,600
all the big primitives but you can

00:33:13,639 --> 00:33:19,399
define your own readable so sorry

00:33:17,600 --> 00:33:21,710
scannable so here you have like an

00:33:19,399 --> 00:33:24,230
animal class and you can define how to

00:33:21,710 --> 00:33:28,580
scan an animal so given a scanner you

00:33:24,230 --> 00:33:30,200
look at the next item next string if it

00:33:28,580 --> 00:33:32,809
is Garfield you say okay I have a CAD

00:33:30,200 --> 00:33:35,509
else it's a dog and now you can just do

00:33:32,809 --> 00:33:38,840
scanner dot next to animal and you can

00:33:35,509 --> 00:33:40,429
define your own scanner boss this way so

00:33:38,840 --> 00:33:42,350
the there's also a shapeless place

00:33:40,429 --> 00:33:43,609
scanner again this is not in the core

00:33:42,350 --> 00:33:46,549
library this is built on top of it

00:33:43,609 --> 00:33:48,940
because my philosophy was the core

00:33:46,549 --> 00:33:51,859
should not depend on any other library

00:33:48,940 --> 00:33:54,139
which let's just this lets you scan H

00:33:51,859 --> 00:33:56,570
list so you can differ so if you have

00:33:54,139 --> 00:33:59,600
this data you can define it as I have a

00:33:56,570 --> 00:34:01,519
H list of end string boolean and you can

00:33:59,600 --> 00:34:05,419
just scan this row and you would get

00:34:01,519 --> 00:34:07,220
back this I could do a whole another top

00:34:05,419 --> 00:34:09,799
and file monitoring how the java file

00:34:07,220 --> 00:34:11,780
monitoring is absolutely the worst and

00:34:09,799 --> 00:34:14,240
has so many bugs you can actually click

00:34:11,780 --> 00:34:18,679
on here to read about it in a separate

00:34:14,240 --> 00:34:20,149
article but this is a file monitor built

00:34:18,679 --> 00:34:24,470
into this library which is built on top

00:34:20,149 --> 00:34:27,139
of the java file monitor and it it I it

00:34:24,470 --> 00:34:28,609
amin you mean it saves you from all the

00:34:27,139 --> 00:34:30,470
troubles of the java library has like

00:34:28,609 --> 00:34:32,329
the java library cannot watch a single

00:34:30,470 --> 00:34:33,559
file it can only watch a directory the

00:34:32,329 --> 00:34:35,450
java library if you create a directory

00:34:33,559 --> 00:34:36,919
inside a directory it does not start

00:34:35,450 --> 00:34:38,149
watching it you have to manually add the

00:34:36,919 --> 00:34:42,020
watcher to it

00:34:38,149 --> 00:34:43,879
and the API is just hard to use in Java

00:34:42,020 --> 00:34:47,960
like you have to always do dot next else

00:34:43,879 --> 00:34:49,970
it will watch one thing and die in here

00:34:47,960 --> 00:34:52,700
you get a really nice interface so you

00:34:49,970 --> 00:34:55,159
click instantiate the monitor and you

00:34:52,700 --> 00:34:57,559
have five things you can override on

00:34:55,159 --> 00:35:00,109
create on modify on delete the two

00:34:57,559 --> 00:35:02,809
others are on exception and on unknown

00:35:00,109 --> 00:35:04,010
event so the OS can tell you that I

00:35:02,809 --> 00:35:06,079
don't know something happened to this

00:35:04,010 --> 00:35:08,390
file but it's not any of this three it's

00:35:06,079 --> 00:35:10,400
normal as a create modify delete never

00:35:08,390 --> 00:35:13,309
seen that happen but so there this this

00:35:10,400 --> 00:35:17,779
this this abstract classes five methods

00:35:13,309 --> 00:35:19,940
for you to in to right and that's it

00:35:17,779 --> 00:35:24,940
this is all you do and you can start the

00:35:19,940 --> 00:35:27,619
watcher and stop the watcher and again

00:35:24,940 --> 00:35:30,710
we build on top of this vanilla watcher

00:35:27,619 --> 00:35:32,299
that we build to build a an actor based

00:35:30,710 --> 00:35:33,859
one which is based on alki again this is

00:35:32,299 --> 00:35:36,369
not in the core this is a library built

00:35:33,859 --> 00:35:40,130
on top of Vera files and where you can

00:35:36,369 --> 00:35:42,770
model file system watching using actors

00:35:40,130 --> 00:35:47,740
instead of these overriding an abstract

00:35:42,770 --> 00:35:50,630
class so this lets you attach and detach

00:35:47,740 --> 00:35:56,900
callbacks and event handlers and do

00:35:50,630 --> 00:35:59,119
advanced off so that was just a quick

00:35:56,900 --> 00:36:03,529
tour of the library to get a flavor for

00:35:59,119 --> 00:36:05,150
it I didn't I don't want this talk to be

00:36:03,529 --> 00:36:07,970
just like okay go through the API so I

00:36:05,150 --> 00:36:11,630
want you to learn something take back

00:36:07,970 --> 00:36:14,869
from the talk so one thing that I came

00:36:11,630 --> 00:36:18,400
across while writing this when this

00:36:14,869 --> 00:36:21,650
library is I wanted a fluent api and

00:36:18,400 --> 00:36:24,170
fluent api is usually return the of the

00:36:21,650 --> 00:36:26,839
soft object that the at the end so you

00:36:24,170 --> 00:36:29,420
can chain api calls but what happens

00:36:26,839 --> 00:36:32,180
when you have so something like append

00:36:29,420 --> 00:36:35,480
would return the file itself but in this

00:36:32,180 --> 00:36:37,549
case it's not obvious when i'm moving a

00:36:35,480 --> 00:36:39,980
file should i return myself the source

00:36:37,549 --> 00:36:41,299
or should I return the destination it's

00:36:39,980 --> 00:36:46,130
not obvious you have to go look at the

00:36:41,299 --> 00:36:50,119
dock so better files uses this strategy

00:36:46,130 --> 00:36:52,320
it always uses literal types so in this

00:36:50,119 --> 00:36:54,090
case for a pen

00:36:52,320 --> 00:36:58,020
obvious it's going to return softer type

00:36:54,090 --> 00:36:59,850
but when I move the file its its it

00:36:58,020 --> 00:37:02,370
guarantees you it's going to return the

00:36:59,850 --> 00:37:04,200
destination so this has two benefits and

00:37:02,370 --> 00:37:06,260
this is a strategy i recommend you to

00:37:04,200 --> 00:37:09,720
use when you're writing fluent api is

00:37:06,260 --> 00:37:12,230
because it's obvious from the compiler

00:37:09,720 --> 00:37:15,600
from the code from the documentation and

00:37:12,230 --> 00:37:17,250
you're absolutely sure that when i move

00:37:15,600 --> 00:37:20,280
a file i get the destination back

00:37:17,250 --> 00:37:21,630
instead of some random file so this is a

00:37:20,280 --> 00:37:26,760
strategy that's used all over better

00:37:21,630 --> 00:37:28,860
files and this is just a caveat this is

00:37:26,760 --> 00:37:32,690
a very concise of the way the better

00:37:28,860 --> 00:37:34,440
files does automatic resource management

00:37:32,690 --> 00:37:37,050
interesting so I put it here as a

00:37:34,440 --> 00:37:39,480
takeaway so I define a structural type

00:37:37,050 --> 00:37:41,130
as something which has a close which is

00:37:39,480 --> 00:37:43,020
unit so this captures almost all the

00:37:41,130 --> 00:37:45,600
Java print writers and input stream

00:37:43,020 --> 00:37:48,540
readers so they all become closeable so

00:37:45,600 --> 00:37:50,160
Java 7 forward this Oracle started

00:37:48,540 --> 00:37:52,170
adding an order closable interface to

00:37:50,160 --> 00:37:53,970
some of them but for some reason not all

00:37:52,170 --> 00:37:57,690
closeable have the auto closeable

00:37:53,970 --> 00:38:00,090
interface on them and then I can this is

00:37:57,690 --> 00:38:02,670
the simplest way since i don't have the

00:38:00,090 --> 00:38:05,100
i don't want to depend on scholars add

00:38:02,670 --> 00:38:06,960
or cats this is the simplest way i could

00:38:05,100 --> 00:38:10,770
define something one addict which is i

00:38:06,960 --> 00:38:12,870
say some managed resource of a which is

00:38:10,770 --> 00:38:15,090
closable is just a traversable so the

00:38:12,870 --> 00:38:17,220
only reason I want this is so I can have

00:38:15,090 --> 00:38:21,450
access to the for each of the

00:38:17,220 --> 00:38:26,520
traversable and then given a clue given

00:38:21,450 --> 00:38:28,470
a given a closeable I can define a I can

00:38:26,520 --> 00:38:30,660
implicitly add a method to it called

00:38:28,470 --> 00:38:33,750
Auto closed which would return a managed

00:38:30,660 --> 00:38:35,550
resource so what does it do it does a

00:38:33,750 --> 00:38:39,150
new traversable and just overrides the

00:38:35,550 --> 00:38:40,890
4-h so given this F it applies it on the

00:38:39,150 --> 00:38:43,500
resource and finally closes the resource

00:38:40,890 --> 00:38:46,380
so this lets you write code which looks

00:38:43,500 --> 00:38:47,790
like this so you have input stream and

00:38:46,380 --> 00:38:50,490
you do order closed you get back at

00:38:47,790 --> 00:38:52,020
reversible and again you have output

00:38:50,490 --> 00:38:54,330
stream you get back and traversable and

00:38:52,020 --> 00:38:57,150
when this is when it goes out of the

00:38:54,330 --> 00:38:59,430
scope it finally when it finally applies

00:38:57,150 --> 00:39:01,860
when it applies the function it finally

00:38:59,430 --> 00:39:03,570
closes the underlying resources and you

00:39:01,860 --> 00:39:05,140
don't have to use for comprehension you

00:39:03,570 --> 00:39:10,599
can do math black map and

00:39:05,140 --> 00:39:13,720
just work we don't have time to go over

00:39:10,599 --> 00:39:19,299
this but the future of the library like

00:39:13,720 --> 00:39:21,220
I think Martin talked about it like of

00:39:19,299 --> 00:39:24,039
breaking the Scala ecosystem into to

00:39:21,220 --> 00:39:29,470
like the cord and the core API is versus

00:39:24,039 --> 00:39:31,119
the surrounding platform api is the

00:39:29,470 --> 00:39:33,130
problem with the stand is the standard

00:39:31,119 --> 00:39:34,359
library is that for backward

00:39:33,130 --> 00:39:36,010
compatibility reasons is very

00:39:34,359 --> 00:39:37,990
slow-moving and this was one of the

00:39:36,010 --> 00:39:40,480
reasons that was brought up in the scala

00:39:37,990 --> 00:39:42,160
slip 19 where some people didn't even

00:39:40,480 --> 00:39:43,779
want an i/o library because it said okay

00:39:42,160 --> 00:39:45,519
if it goes into the mainstream it will

00:39:43,779 --> 00:39:47,829
just get frozen in time no one's going

00:39:45,519 --> 00:39:49,779
to do anything about it so on and so

00:39:47,829 --> 00:39:52,240
forth but this is going over stuff that

00:39:49,779 --> 00:39:55,660
martin talked about already but yeah

00:39:52,240 --> 00:39:57,849
this is it this is the github page we

00:39:55,660 --> 00:40:00,700
have active gated channel this color

00:39:57,849 --> 00:40:05,079
dogs always updated the library is

00:40:00,700 --> 00:40:06,760
really just this bunch of feature open

00:40:05,079 --> 00:40:10,539
feature requests feel free to send a PR

00:40:06,760 --> 00:40:12,130
on it the library is tiny it's only 450

00:40:10,539 --> 00:40:13,750
lines of code there are more people who

00:40:12,130 --> 00:40:16,839
start this project on github then there

00:40:13,750 --> 00:40:19,059
are lines of code most of the code

00:40:16,839 --> 00:40:21,400
that's more than it's actually three

00:40:19,059 --> 00:40:23,859
thousand lines of test score benchmarks

00:40:21,400 --> 00:40:26,319
to make sure the library works it's

00:40:23,859 --> 00:40:28,990
fairly popular and see thousand may even

00:40:26,319 --> 00:40:33,299
downloads per month and yeah feel free

00:40:28,990 --> 00:40:33,299
to contribute right that's it

00:40:38,410 --> 00:40:50,860
any questions Kingdom Mike hi first of

00:40:48,680 --> 00:40:53,450
all thank you very much it looks awesome

00:40:50,860 --> 00:40:57,080
my question is around exceptions so you

00:40:53,450 --> 00:40:59,420
mentioned how the Java libraries can

00:40:57,080 --> 00:41:01,760
throw like various exceptions and you

00:40:59,420 --> 00:41:03,500
have to look out for those and yeah i'm

00:41:01,760 --> 00:41:05,720
not sure what happens here if I try to

00:41:03,500 --> 00:41:09,320
write something right right so

00:41:05,720 --> 00:41:11,690
permission sir this library is exception

00:41:09,320 --> 00:41:13,250
friendly as then it will throw the

00:41:11,690 --> 00:41:16,250
exceptions in most cases but there are

00:41:13,250 --> 00:41:18,140
other times when Java in my opinion

00:41:16,250 --> 00:41:19,460
throws us a really stupid exempt

00:41:18,140 --> 00:41:24,950
exception like they're actually not

00:41:19,460 --> 00:41:27,500
found exception the library has ap is to

00:41:24,950 --> 00:41:29,000
not let those things happen but again

00:41:27,500 --> 00:41:31,190
this is something that I as a scholar

00:41:29,000 --> 00:41:33,380
programmer cannot guarantee to you maybe

00:41:31,190 --> 00:41:36,080
in da TI can have these SP or functions

00:41:33,380 --> 00:41:37,850
or something but and scholar it's almost

00:41:36,080 --> 00:41:39,800
empanada guarantee to you that I can

00:41:37,850 --> 00:41:47,090
just only verbally promise you that say

00:41:39,800 --> 00:41:49,310
this is hey I have a question you said

00:41:47,090 --> 00:41:51,560
you kind of constrained yourself to file

00:41:49,310 --> 00:41:54,590
IO yeah and I think this kind of the

00:41:51,560 --> 00:41:57,170
beauty of Io that you unify a lot of

00:41:54,590 --> 00:42:00,230
different kind of Io in unity of the

00:41:57,170 --> 00:42:02,330
parts and the tcp/ip we a little bit

00:42:00,230 --> 00:42:05,810
complicated by any way you can unify it

00:42:02,330 --> 00:42:08,330
at some level yeah and did you drop this

00:42:05,810 --> 00:42:10,430
for good or is no kind of the first step

00:42:08,330 --> 00:42:11,990
and you want to first start of my

00:42:10,430 --> 00:42:14,420
personal need to have a good file i/o

00:42:11,990 --> 00:42:16,690
library so it started at that but I

00:42:14,420 --> 00:42:26,710
don't see any reason to go to other I oh

00:42:16,690 --> 00:42:26,710
and yeah thanks a question here

00:42:30,870 --> 00:42:38,950
you show that the scanner class now uses

00:42:35,500 --> 00:42:40,480
a type parameter instead of specialized

00:42:38,950 --> 00:42:43,120
mental methods does that actually work

00:42:40,480 --> 00:42:44,590
with scala specialization or do you need

00:42:43,120 --> 00:42:48,190
to go through boxing for all the

00:42:44,590 --> 00:42:50,650
primitive types it does not use color

00:42:48,190 --> 00:42:52,810
specialization but that's something

00:42:50,650 --> 00:42:56,140
that's a feature that I would like to

00:42:52,810 --> 00:42:57,790
have to to make it fast area it's

00:42:56,140 --> 00:42:59,050
amazing that it's already faster than

00:42:57,790 --> 00:43:01,330
Java there must be something pretty

00:42:59,050 --> 00:43:05,100
wrong in this case yeah the Java one

00:43:01,330 --> 00:43:08,340
uses regex it's absolutely slow yeah

00:43:05,100 --> 00:43:08,340
back there

00:43:15,630 --> 00:43:21,480
I and he plans to support java 6 or 7

00:43:19,590 --> 00:43:25,620
for basic stuff like reading and writing

00:43:21,480 --> 00:43:26,910
files it's supported there is a older

00:43:25,620 --> 00:43:29,940
version of the library that does support

00:43:26,910 --> 00:43:32,460
java 7 but not java 6 because it depends

00:43:29,940 --> 00:43:34,530
on java and i/o which was not in java 6

00:43:32,460 --> 00:43:44,420
so no plans for java 6 but Java 7 is

00:43:34,530 --> 00:43:44,420
supported there is a it's in maven hey

00:43:48,140 --> 00:43:53,460
so I really admire your design to keep

00:43:51,300 --> 00:43:55,020
it very simple and not introduce moments

00:43:53,460 --> 00:43:57,870
and that's kind of things but say I want

00:43:55,020 --> 00:44:00,000
a free moment to separate the effects

00:43:57,870 --> 00:44:02,910
and a running right and do you want to

00:44:00,000 --> 00:44:06,300
keep that holy out of the library or are

00:44:02,910 --> 00:44:09,090
you open to like a small atom there

00:44:06,300 --> 00:44:11,070
that's a good question and I think so

00:44:09,090 --> 00:44:12,570
let's say unless you want to write your

00:44:11,070 --> 00:44:13,920
own free mon at class you may be

00:44:12,570 --> 00:44:16,050
probably want to use this color z are

00:44:13,920 --> 00:44:17,250
the cats won so there are i know i

00:44:16,050 --> 00:44:20,340
talked to a couple of people they're

00:44:17,250 --> 00:44:21,570
working on better files cats which which

00:44:20,340 --> 00:44:24,450
does not which uses better files

00:44:21,570 --> 00:44:28,800
underneath but exposes api's which are

00:44:24,450 --> 00:44:30,150
using the cats structures so I would

00:44:28,800 --> 00:44:31,170
yeah they would not be part of better

00:44:30,150 --> 00:44:34,610
fast they'll be built on top of

00:44:31,170 --> 00:44:34,610
libraries that depend on better files

00:44:34,670 --> 00:44:40,550
all right that's it thank you thank you

00:44:38,160 --> 00:44:40,550

YouTube URL: https://www.youtube.com/watch?v=m2YsD5cgnzI


