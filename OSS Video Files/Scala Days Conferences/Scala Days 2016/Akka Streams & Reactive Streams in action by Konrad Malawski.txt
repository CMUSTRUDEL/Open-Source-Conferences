Title: Akka Streams & Reactive Streams in action by Konrad Malawski
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
In this talk we'll have a deeper look into Akka Streams (the implementation) and Reactive Streams (the standard). The term streams has been recently pretty overloaded, so we'll disambiguate what streams are and what they aren't. We'll dive into a number of real life scenarios where applying back-pressure helps to keep your systems fast and healthy at the same time. We'll mostly focus on the Akka Streams implementation, but the general principles apply to any kind of asynchronous programming.
Captions: 
	00:00:05,990 --> 00:00:10,830
welcome to the accursed dreams an action

00:00:08,840 --> 00:00:15,410
talk and force also

00:00:10,830 --> 00:00:18,930
severe but it's smaller font and also

00:00:15,410 --> 00:00:20,880
not smaller meaning but smaller the

00:00:18,930 --> 00:00:22,529
thing that you will actually see right

00:00:20,880 --> 00:00:24,630
because we'll actually be looking at

00:00:22,529 --> 00:00:26,520
ARCA streams which is a implementation

00:00:24,630 --> 00:00:28,949
of reactive streams so many things that

00:00:26,520 --> 00:00:30,990
it does originate from reactive streams

00:00:28,949 --> 00:00:35,010
initiative but we'll be looking at ARCA

00:00:30,990 --> 00:00:36,650
streams today so conrad to-- so if you

00:00:35,010 --> 00:00:38,879
ever want to talk to pronounce that and

00:00:36,650 --> 00:00:41,699
I'm on the akka team at Lightman's

00:00:38,879 --> 00:00:44,460
currently so other community things I

00:00:41,699 --> 00:00:47,580
run in Krakow notably geeking conference

00:00:44,460 --> 00:00:50,430
if you ever wanted visit Krakow and yeah

00:00:47,580 --> 00:00:52,589
just a slide about akka but today will

00:00:50,430 --> 00:00:56,129
actually build stuff there will be a

00:00:52,589 --> 00:00:57,540
bunch of examples which is finally some

00:00:56,129 --> 00:00:59,220
code in my talks because my previous

00:00:57,540 --> 00:01:03,540
talks were on mostly slides and

00:00:59,220 --> 00:01:05,700
explaining concepts but today we'll use

00:01:03,540 --> 00:01:09,330
an unreleased stuff pickled at Scala

00:01:05,700 --> 00:01:11,670
days so why not a few of the features

00:01:09,330 --> 00:01:14,310
that we'll be talking about are either

00:01:11,670 --> 00:01:16,860
released as a milestone and may still

00:01:14,310 --> 00:01:19,110
change a bit or are an utmost per

00:01:16,860 --> 00:01:21,420
request but I'll specifically highlight

00:01:19,110 --> 00:01:23,490
that and the reason I'm talking about

00:01:21,420 --> 00:01:25,560
these things because kind of a road

00:01:23,490 --> 00:01:28,620
ahead is really exciting for our customs

00:01:25,560 --> 00:01:33,630
so why not show exactly what we're up

00:01:28,620 --> 00:01:37,050
about in the near future so um stream

00:01:33,630 --> 00:01:39,300
the word stream is the most abused word

00:01:37,050 --> 00:01:40,800
like in all the libraries recently like

00:01:39,300 --> 00:01:43,800
everything is a stream and everyone

00:01:40,800 --> 00:01:46,500
defines stream as a different thing what

00:01:43,800 --> 00:01:48,630
is actually a stream so let's look at

00:01:46,500 --> 00:01:52,470
what we mean and arca streams when we

00:01:48,630 --> 00:01:54,930
talk about streams and people keep using

00:01:52,470 --> 00:01:56,880
water force when we talk about streams

00:01:54,930 --> 00:01:59,700
because it's lots of nice pictures of

00:01:56,880 --> 00:02:02,430
waterfalls but actually I thought that

00:01:59,700 --> 00:02:03,600
it's not really just a random waterfall

00:02:02,430 --> 00:02:07,170
where I want to talk about it

00:02:03,600 --> 00:02:09,780
a dam because it's a controlled flow of

00:02:07,170 --> 00:02:11,760
data it's not just random amounts of

00:02:09,780 --> 00:02:15,060
data coming in and through we actually

00:02:11,760 --> 00:02:17,459
do control the rate to be exactly the

00:02:15,060 --> 00:02:19,260
rate that we want to have of flow of

00:02:17,459 --> 00:02:21,810
data so that's pretty much for reactive

00:02:19,260 --> 00:02:24,030
streams movement it's about processing

00:02:21,810 --> 00:02:26,340
data at exactly the right

00:02:24,030 --> 00:02:28,650
we want to and not faster because we

00:02:26,340 --> 00:02:30,570
might blow up so before we dive into

00:02:28,650 --> 00:02:33,870
actual code I promise you there will be

00:02:30,570 --> 00:02:36,720
plenty I do want to give a super short

00:02:33,870 --> 00:02:37,440
story so we actually know where this all

00:02:36,720 --> 00:02:41,280
came from

00:02:37,440 --> 00:02:45,110
so yeah reactive extensions 2009 ish and

00:02:41,280 --> 00:02:48,660
dotnet right they did introduce them for

00:02:45,110 --> 00:02:52,230
the.net platform back then but fast

00:02:48,660 --> 00:02:54,240
forward to 2013 and when kind of

00:02:52,230 --> 00:02:56,910
reactive programming is a thing already

00:02:54,240 --> 00:02:58,620
right it's widely known and we have a

00:02:56,910 --> 00:03:00,780
bunch of implementation a bunch of

00:02:58,620 --> 00:03:03,720
libraries which solve mmm

00:03:00,780 --> 00:03:06,780
different problems but things start to

00:03:03,720 --> 00:03:08,489
slowly converge so play heard a treatise

00:03:06,780 --> 00:03:10,680
because they wanted to have his back

00:03:08,489 --> 00:03:11,520
pressured way of exposing this lazy

00:03:10,680 --> 00:03:16,410
stream of data

00:03:11,520 --> 00:03:18,900
I got sourced and at that time just the

00:03:16,410 --> 00:03:20,100
the IO bit and it also had back pressure

00:03:18,900 --> 00:03:23,940
but it was a negative acknowledgement

00:03:20,100 --> 00:03:26,250
placed and then then started working on

00:03:23,940 --> 00:03:27,930
our extrav oh his reason for working on

00:03:26,250 --> 00:03:31,080
our X Java which is basically a part of

00:03:27,930 --> 00:03:33,510
the concepts from dotnet was that we

00:03:31,080 --> 00:03:36,660
wanted to build some asynchronous

00:03:33,510 --> 00:03:39,060
processing and kind of you needed a nice

00:03:36,660 --> 00:03:42,720
API to actually convince the rest of the

00:03:39,060 --> 00:03:44,250
teams to actually use that so we had

00:03:42,720 --> 00:03:47,280
this a situation that

00:03:44,250 --> 00:03:50,400
okay everybody solved parts of the

00:03:47,280 --> 00:03:52,320
problem so in play had a poor base back

00:03:50,400 --> 00:03:54,840
pressure with a treatise which came from

00:03:52,320 --> 00:03:58,500
Haskell a bit difficult to use I would

00:03:54,840 --> 00:04:00,900
say akka had a low-level bits right fits

00:03:58,500 --> 00:04:04,019
what we were doing and still have in our

00:04:00,900 --> 00:04:06,420
i/o and our java focused more on the

00:04:04,019 --> 00:04:08,250
nice API side of things right it's the

00:04:06,420 --> 00:04:10,860
nice fluent API so we know and love

00:04:08,250 --> 00:04:14,640
similar to the scholar collections but

00:04:10,860 --> 00:04:16,350
not forcing here is an iterative if you

00:04:14,640 --> 00:04:18,630
never wrote one and the biggest problem

00:04:16,350 --> 00:04:20,729
about it is just by glancing at it

00:04:18,630 --> 00:04:23,729
you're not quite sure how would I use it

00:04:20,729 --> 00:04:26,940
but I don't mean to bash it just saying

00:04:23,729 --> 00:04:30,720
that that's the reason I do think it's

00:04:26,940 --> 00:04:34,710
release are going you know out so people

00:04:30,720 --> 00:04:37,139
need so Roland me smart Eric victims

00:04:34,710 --> 00:04:39,479
Marius and silent

00:04:37,139 --> 00:04:42,770
things start to converge which we all

00:04:39,479 --> 00:04:46,860
seem to kind of be looking for a similar

00:04:42,770 --> 00:04:48,599
concept which van gets termed as coined

00:04:46,860 --> 00:04:50,610
as reactive non-blocking a synchronous

00:04:48,599 --> 00:04:54,749
back pressure which is a mouthful but

00:04:50,610 --> 00:04:56,729
actually is very scarce so it has to be

00:04:54,749 --> 00:04:59,729
a synchronous right we wanna do reactive

00:04:56,729 --> 00:05:01,080
programming has to be a synchronous we

00:04:59,729 --> 00:05:03,599
don't have obviously don't want to be

00:05:01,080 --> 00:05:06,289
forced by the api's to block obvious and

00:05:03,599 --> 00:05:09,629
it has to be safe which is a key feature

00:05:06,289 --> 00:05:12,029
so it never should allow library to

00:05:09,629 --> 00:05:15,629
overflow the subscribers of your data

00:05:12,029 --> 00:05:19,379
like that's the goal of flag office and

00:05:15,629 --> 00:05:20,460
directive streams movement and then yes

00:05:19,379 --> 00:05:22,199
it should allow synchronous

00:05:20,460 --> 00:05:25,409
implementations if you want to be really

00:05:22,199 --> 00:05:27,870
fast and go through an array right so

00:05:25,409 --> 00:05:29,729
and whenever joins other people general

00:05:27,870 --> 00:05:32,189
projects of a reactor project appears at

00:05:29,729 --> 00:05:34,139
that point and then many many more

00:05:32,189 --> 00:05:36,210
people including Doug Lee and more

00:05:34,139 --> 00:05:39,449
people from the akka and spray team and

00:05:36,210 --> 00:05:44,219
joined the discussions and I appeared

00:05:39,449 --> 00:05:47,729
and did Fatih CK verso so we have a TCK

00:05:44,219 --> 00:05:51,750
and finally 2015 gets proposed and

00:05:47,729 --> 00:05:55,139
merged into a jab to six six which is a

00:05:51,750 --> 00:05:57,629
concurrency update of JDK nine so we'll

00:05:55,139 --> 00:06:01,800
see hopefully we will have it as a

00:05:57,629 --> 00:06:03,509
standard Java thing so this is how the

00:06:01,800 --> 00:06:05,310
interfaces look like and this is the

00:06:03,509 --> 00:06:09,180
last moments during this talk when we

00:06:05,310 --> 00:06:10,860
look at reactive streams because kind of

00:06:09,180 --> 00:06:13,229
misleading and I've committed visits in

00:06:10,860 --> 00:06:16,020
myself of showing this slide and then

00:06:13,229 --> 00:06:19,199
people think oh my god it's so simple it

00:06:16,020 --> 00:06:21,899
both is and isn't at the same time so

00:06:19,199 --> 00:06:23,669
the concept and the kind of division of

00:06:21,899 --> 00:06:25,050
responsibilities is pretty simple and

00:06:23,669 --> 00:06:29,180
the number of methods is also pretty

00:06:25,050 --> 00:06:29,180
simple but she is just an unnecessary

00:06:29,990 --> 00:06:35,520
risk or von next and you call the

00:06:33,449 --> 00:06:37,310
requests if you're ready to consume more

00:06:35,520 --> 00:06:41,339
elements from the other side right

00:06:37,310 --> 00:06:45,930
simple now the problem is at some point

00:06:41,339 --> 00:06:47,610
people forgot the second point about

00:06:45,930 --> 00:06:49,560
reactive streams which is where it's

00:06:47,610 --> 00:06:50,639
interrupt interfaces it's not really

00:06:49,560 --> 00:06:52,409
meant for

00:06:50,639 --> 00:06:54,030
if I'm doing my day job I shouldn't be

00:06:52,409 --> 00:06:56,159
really implementing reactive streams

00:06:54,030 --> 00:06:59,219
directly and why shouldn't you be doing

00:06:56,159 --> 00:07:01,110
that because this is the slide that

00:06:59,219 --> 00:07:03,180
never appeared in all of his talks which

00:07:01,110 --> 00:07:05,129
is all the actual rules that these

00:07:03,180 --> 00:07:08,150
interactions and reactive streams have

00:07:05,129 --> 00:07:11,009
to follow because it is a concurrency

00:07:08,150 --> 00:07:13,020
protocol basically so the interfaces are

00:07:11,009 --> 00:07:14,939
very simple but you really don't want to

00:07:13,020 --> 00:07:17,250
spend your day implementing the entire

00:07:14,939 --> 00:07:21,060
thing again and again so this is why

00:07:17,250 --> 00:07:23,669
akka streams is fair to help you because

00:07:21,060 --> 00:07:25,590
yeah it's actually kind of hard to

00:07:23,669 --> 00:07:29,069
implement the correct publisher and a

00:07:25,590 --> 00:07:31,289
correct processor is even harder so this

00:07:29,069 --> 00:07:32,879
is why akka streams so we have reactive

00:07:31,289 --> 00:07:34,710
streams we all talk about reactive

00:07:32,879 --> 00:07:36,659
streams they do this thing but you're

00:07:34,710 --> 00:07:38,879
shaking really shouldn't be directly

00:07:36,659 --> 00:07:41,310
using them you could be exposing them if

00:07:38,879 --> 00:07:43,229
you were library because then everybody

00:07:41,310 --> 00:07:47,069
can consume them independently of which

00:07:43,229 --> 00:07:49,500
library they like so another question

00:07:47,069 --> 00:07:51,389
that often appears is should we like

00:07:49,500 --> 00:07:54,120
deprecated all our actor code and go to

00:07:51,389 --> 00:07:56,610
streams people ask me that and Nova

00:07:54,120 --> 00:07:58,919
answer is no absolutely not because we

00:07:56,610 --> 00:08:00,900
solve different problems right so

00:07:58,919 --> 00:08:04,770
streams complement actors and the very

00:08:00,900 --> 00:08:07,979
our situations were like Martin's in

00:08:04,770 --> 00:08:09,449
principle of least power and Runa was

00:08:07,979 --> 00:08:11,789
talking about it as well on a other

00:08:09,449 --> 00:08:13,830
conference so you want to pick the tool

00:08:11,789 --> 00:08:16,440
that is least powerful from a job but

00:08:13,830 --> 00:08:20,039
allows you to get the job done so oh

00:08:16,440 --> 00:08:22,020
okay we have futures so futures are okay

00:08:20,039 --> 00:08:23,939
work for your very single element a

00:08:22,020 --> 00:08:27,029
synchronous processing but we didn't

00:08:23,939 --> 00:08:29,819
have a abstraction for a locro you know

00:08:27,029 --> 00:08:32,640
a synchronous we produce lazy stream of

00:08:29,819 --> 00:08:35,370
data now we have which is our streams so

00:08:32,640 --> 00:08:38,789
if you look about it this way so we have

00:08:35,370 --> 00:08:41,399
local abstractions single value also has

00:08:38,789 --> 00:08:43,500
some transformation capabilities but not

00:08:41,399 --> 00:08:45,810
that much then you have streams which

00:08:43,500 --> 00:08:48,540
allow for streaming data and a back

00:08:45,810 --> 00:08:51,120
pressured fashion but we don't solve the

00:08:48,540 --> 00:08:52,649
distribution part right and when we have

00:08:51,120 --> 00:08:55,649
actors which actually do solve

00:08:52,649 --> 00:08:57,449
distribution and here on this spectrum I

00:08:55,649 --> 00:08:59,490
kind of did want to mention archetypes

00:08:57,449 --> 00:09:02,610
because it's still going rolling this

00:08:59,490 --> 00:09:03,780
hacking on it and it kind of adds more

00:09:02,610 --> 00:09:05,190
limitations

00:09:03,780 --> 00:09:06,960
so if you think about it it adds more

00:09:05,190 --> 00:09:08,340
constraint and the constraints are

00:09:06,960 --> 00:09:10,050
actually good for you because you can't

00:09:08,340 --> 00:09:12,450
do the wrong thing right so it's this

00:09:10,050 --> 00:09:14,910
trade-off of power versus constraints

00:09:12,450 --> 00:09:19,230
and when our characters which are very

00:09:14,910 --> 00:09:21,360
unconstrained and very powerful ok so

00:09:19,230 --> 00:09:23,310
finally going into some code and the

00:09:21,360 --> 00:09:25,710
rest will be a bit topic jumping boats

00:09:23,310 --> 00:09:28,470
all connected to streams so I do want to

00:09:25,710 --> 00:09:31,200
show actually the problem

00:09:28,470 --> 00:09:34,830
the directive stream source so let's

00:09:31,200 --> 00:09:37,680
dive into some code yeah basically I'm

00:09:34,830 --> 00:09:41,100
trying to show you guys the overflowing

00:09:37,680 --> 00:09:42,570
a downstream processor of data right so

00:09:41,100 --> 00:09:44,940
let's see how you could actually see

00:09:42,570 --> 00:09:47,610
that in your application because just

00:09:44,940 --> 00:09:55,440
talking about it is one thing and

00:09:47,610 --> 00:10:00,470
actually seeing is nope that's for

00:09:55,440 --> 00:10:07,380
encoding it's just for a couple days

00:10:00,470 --> 00:10:11,670
that's good ok so let's say you have

00:10:07,380 --> 00:10:12,930
this really bad thing so don't don't

00:10:11,670 --> 00:10:15,860
ever do this ok

00:10:12,930 --> 00:10:17,130
please but let's say you have this slow

00:10:15,860 --> 00:10:19,050
slow

00:10:17,130 --> 00:10:21,600
echo actor and it's just replying to

00:10:19,050 --> 00:10:23,370
messages and when you have a fast sender

00:10:21,600 --> 00:10:27,390
and it's basically just sending a lot of

00:10:23,370 --> 00:10:30,360
messages to this other guy as simple as

00:10:27,390 --> 00:10:32,150
that and this slow guy is called slow of

00:10:30,360 --> 00:10:35,970
the fast guy is called a sender and

00:10:32,150 --> 00:10:38,100
let's see how we could actually see that

00:10:35,970 --> 00:10:39,750
yes we're overwhelming the downstream

00:10:38,100 --> 00:10:44,610
guy because he's really slow at

00:10:39,750 --> 00:10:48,390
processing the hello messages and and

00:10:44,610 --> 00:10:57,040
which is it slow X rap so step one

00:10:48,390 --> 00:11:05,620
number five so the font big enough okay

00:10:57,040 --> 00:11:07,450
so okay so I'm using direct monitoring

00:11:05,620 --> 00:11:09,190
here with a console.log or you can use

00:11:07,450 --> 00:11:11,560
them any kind of logging you want for it

00:11:09,190 --> 00:11:14,440
including stats D and other things but I

00:11:11,560 --> 00:11:18,430
just want to show that here's the

00:11:14,440 --> 00:11:21,580
mailbox size of this slow guy and this

00:11:18,430 --> 00:11:26,770
will be printed every other every five

00:11:21,580 --> 00:11:28,930
seconds or so and you will see that the

00:11:26,770 --> 00:11:30,940
sender or it doesn't have anything

00:11:28,930 --> 00:11:34,240
invariant box it's just pushing out for

00:11:30,940 --> 00:11:37,090
data right and the down stream is

00:11:34,240 --> 00:11:39,040
completely overwhelmed and it will take

00:11:37,090 --> 00:11:40,720
quite some time until it gets through

00:11:39,040 --> 00:11:44,170
all of these messages because it's so

00:11:40,720 --> 00:11:45,730
slow so what we would like to do is not

00:11:44,170 --> 00:11:52,930
allow for sister situation to even

00:11:45,730 --> 00:11:55,060
happen yeah yes a spoiler will loop back

00:11:52,930 --> 00:11:56,950
to that okay so I've shown the problem

00:11:55,060 --> 00:11:59,800
now let's talk about streams and then

00:11:56,950 --> 00:12:03,240
we'll see how this actually source the

00:11:59,800 --> 00:12:03,240
problem that I've demonstrated

00:12:03,870 --> 00:12:12,040
okay so let's finally talk about streams

00:12:08,040 --> 00:12:14,440
so another difference from Vaca streams

00:12:12,040 --> 00:12:16,840
implementation and other libraries of

00:12:14,440 --> 00:12:19,920
similar style is that we have this

00:12:16,840 --> 00:12:22,120
materialization phase which comes from

00:12:19,920 --> 00:12:25,240
fact that we have his lifted

00:12:22,120 --> 00:12:27,310
representation right so when you write

00:12:25,240 --> 00:12:30,910
anything in our streams so let's say you

00:12:27,310 --> 00:12:33,280
write a source a single Knab Knab Knab

00:12:30,910 --> 00:12:35,590
it's actually just constructing this

00:12:33,280 --> 00:12:38,560
blueprint alright so all the flow saying

00:12:35,590 --> 00:12:40,000
sources and etc they just construct how

00:12:38,560 --> 00:12:43,450
everything looks like and what is

00:12:40,000 --> 00:12:45,520
connected to what and then once you

00:12:43,450 --> 00:12:48,040
actually materialize it it gets

00:12:45,520 --> 00:12:52,660
converted to a actual engine that can

00:12:48,040 --> 00:12:55,930
run the thing and hear something that

00:12:52,660 --> 00:12:59,320
may have slipped your when reading the

00:12:55,930 --> 00:13:01,570
docs we do actually fusing so operators

00:12:59,320 --> 00:13:03,970
fit for example at five five map steps

00:13:01,570 --> 00:13:05,680
they will be actually currently

00:13:03,970 --> 00:13:07,600
synchronously executed because you know

00:13:05,680 --> 00:13:09,270
five map steps doesn't make much sense

00:13:07,600 --> 00:13:11,700
to make film passing

00:13:09,270 --> 00:13:14,160
unless you actually no but one of the

00:13:11,700 --> 00:13:16,350
steps is for example very intensive in

00:13:14,160 --> 00:13:19,620
some way and then you can just slap a

00:13:16,350 --> 00:13:21,420
asynchronous boundary there so we have

00:13:19,620 --> 00:13:23,820
this materialization step so it takes a

00:13:21,420 --> 00:13:26,070
blueprint into the actual engine let's

00:13:23,820 --> 00:13:27,660
put it this way it does fusing and we

00:13:26,070 --> 00:13:30,210
can do other optimizations because we

00:13:27,660 --> 00:13:32,490
have the entire layout where we can look

00:13:30,210 --> 00:13:34,740
at it and then we actually run it and

00:13:32,490 --> 00:13:36,540
all via synchronous communication of

00:13:34,740 --> 00:13:39,300
course is actor based as you would

00:13:36,540 --> 00:13:41,580
expect and world as being synchronous

00:13:39,300 --> 00:13:44,970
boundary actually comes from it comes

00:13:41,580 --> 00:13:47,130
from IVA if a stage has defined that it

00:13:44,970 --> 00:13:49,380
needs eight separate dispatcher for

00:13:47,130 --> 00:13:52,080
example if you're using a file IO to

00:13:49,380 --> 00:13:54,180
just three my CSV and ARCA streams it by

00:13:52,080 --> 00:13:56,070
default has a dedicated IO dispatcher

00:13:54,180 --> 00:13:57,960
and it will be running on that

00:13:56,070 --> 00:13:59,700
dispatcher so you know it's file access

00:13:57,960 --> 00:14:02,280
so you wanted separated from the rest of

00:13:59,700 --> 00:14:04,110
the stream and so that's one way you can

00:14:02,280 --> 00:14:06,960
get a synchronous boundary somewhere

00:14:04,110 --> 00:14:08,940
another way is to explicitly say dot

00:14:06,960 --> 00:14:11,610
sync and when that part of the pipeline

00:14:08,940 --> 00:14:15,870
is basically put into a separate actor

00:14:11,610 --> 00:14:17,850
and when you run it the the key feature

00:14:15,870 --> 00:14:21,150
here is that this is really transparent

00:14:17,850 --> 00:14:23,070
you don't need to design upfront word

00:14:21,150 --> 00:14:24,660
boundary will be you just write your

00:14:23,070 --> 00:14:26,340
thing and when you think about oh yeah

00:14:24,660 --> 00:14:28,500
this should be isolated of it should be

00:14:26,340 --> 00:14:33,210
a thing and then you can put in the

00:14:28,500 --> 00:14:35,910
boundary boundary so like I said a bit

00:14:33,210 --> 00:14:38,310
of topic jumping but also I think topics

00:14:35,910 --> 00:14:40,530
that are a bit misunderstood in the

00:14:38,310 --> 00:14:43,380
community right now so let's continue

00:14:40,530 --> 00:14:46,290
with the custom stages thing because

00:14:43,380 --> 00:14:49,010
it's also a key feature that isn't that

00:14:46,290 --> 00:14:52,320
noticeable unless you know where to look

00:14:49,010 --> 00:14:55,260
that is it is a feature so we have this

00:14:52,320 --> 00:14:58,710
concept of flow so flow is a thing comes

00:14:55,260 --> 00:15:00,630
in thing comes out easy right and it's

00:14:58,710 --> 00:15:02,040
basically a black box when if you look

00:15:00,630 --> 00:15:04,590
at it from the outside it could be a

00:15:02,040 --> 00:15:10,380
IMAP stage it could be a filter stage

00:15:04,590 --> 00:15:12,720
easy so we have a lot of pre implemented

00:15:10,380 --> 00:15:15,360
very generic operations all of them are

00:15:12,720 --> 00:15:16,920
defined on flow ops so that's the first

00:15:15,360 --> 00:15:19,730
place you cannot should be looking for

00:15:16,920 --> 00:15:22,370
operations if you're looking for any but

00:15:19,730 --> 00:15:24,290
let's look at what it actually is

00:15:22,370 --> 00:15:26,900
so we have this thing called the flow

00:15:24,290 --> 00:15:28,339
shape and now let's look into a black

00:15:26,900 --> 00:15:30,380
box okay

00:15:28,339 --> 00:15:32,770
this is not something you need to do

00:15:30,380 --> 00:15:35,170
very often but I would like you to

00:15:32,770 --> 00:15:37,490
explain to you guys how it actually

00:15:35,170 --> 00:15:41,300
differs from all of the other libraries

00:15:37,490 --> 00:15:43,700
because this kind of sets us apart so we

00:15:41,300 --> 00:15:49,760
have a flow shape and a shape basically

00:15:43,700 --> 00:15:51,350
means that you have kind of okay so you

00:15:49,760 --> 00:15:54,080
have an inlet and you have an outlet

00:15:51,350 --> 00:15:56,690
right which is a flow one thing in one

00:15:54,080 --> 00:15:58,370
thing out so it's still a flow and it's

00:15:56,690 --> 00:16:01,339
got the logic inside right it could be

00:15:58,370 --> 00:16:05,240
this mapping function however the

00:16:01,339 --> 00:16:07,370
general concept of shapes is arbitrary

00:16:05,240 --> 00:16:09,410
shapes you can do anything so if you

00:16:07,370 --> 00:16:11,270
would add another Inlet when you

00:16:09,410 --> 00:16:13,220
suddenly have a merge like structure

00:16:11,270 --> 00:16:17,089
right and it's still oh everything is

00:16:13,220 --> 00:16:20,180
expressed in the same shape concept so

00:16:17,089 --> 00:16:22,910
and then if you look at for api's its

00:16:20,180 --> 00:16:24,950
surfaces so this is why I'm saying that

00:16:22,910 --> 00:16:28,040
you probably didn't notice this but it's

00:16:24,950 --> 00:16:30,200
actually surfacing in here so we have

00:16:28,040 --> 00:16:32,839
for example source from rough and you

00:16:30,200 --> 00:16:36,560
can go via anything that has a flow

00:16:32,839 --> 00:16:38,360
shape usually it's a flow but maybe you

00:16:36,560 --> 00:16:40,190
wrote your own thing or someone provided

00:16:38,360 --> 00:16:42,500
the library that is a flow and you can

00:16:40,190 --> 00:16:47,029
just go through that and it just works

00:16:42,500 --> 00:16:50,209
so and the key feature here is that any

00:16:47,029 --> 00:16:52,610
kind of extending our Karim's feels

00:16:50,209 --> 00:16:54,470
native because everything has the same

00:16:52,610 --> 00:16:58,339
concepts and it's very easily composable

00:16:54,470 --> 00:17:00,440
and extendable in that sense so before I

00:16:58,339 --> 00:17:03,410
show how to write a custom stage I do

00:17:00,440 --> 00:17:05,630
want to usually you don't have to write

00:17:03,410 --> 00:17:07,640
a custom stage usually you can just get

00:17:05,630 --> 00:17:09,949
away with normal operators and if you

00:17:07,640 --> 00:17:11,900
want to go really powerful the most

00:17:09,949 --> 00:17:14,420
powerful operator we have half of these

00:17:11,900 --> 00:17:16,910
things is probably a stateful napkin cut

00:17:14,420 --> 00:17:19,699
so it can have state like a accumulator

00:17:16,910 --> 00:17:23,980
for example if it's counting things but

00:17:19,699 --> 00:17:23,980
let's see a very simple hundred if I

00:17:25,000 --> 00:17:30,890
okay so let's say I have this very

00:17:28,250 --> 00:17:34,700
simple akka stream actually did anyone

00:17:30,890 --> 00:17:36,170
not see our customs before today okay if

00:17:34,700 --> 00:17:39,140
you so vitarka streams

00:17:36,170 --> 00:17:41,570
very simple to read of I would think so

00:17:39,140 --> 00:17:44,630
you start from a source it has a single

00:17:41,570 --> 00:17:47,510
random tweet value then I just extract

00:17:44,630 --> 00:17:50,290
the name for it from it and map

00:17:47,510 --> 00:17:54,230
conquered is like flat map so we emit a

00:17:50,290 --> 00:17:56,390
iterator here iterable and then it

00:17:54,230 --> 00:17:59,530
flattens it out into the stream all

00:17:56,390 --> 00:18:04,040
right but let's say but I want to

00:17:59,530 --> 00:18:06,200
implement such a operation so as as

00:18:04,040 --> 00:18:12,230
simple as via and something that has

00:18:06,200 --> 00:18:14,570
this shape and like I said it's just a

00:18:12,230 --> 00:18:16,850
graph stage with extents with shape and

00:18:14,570 --> 00:18:19,580
because with Inlet and outlet and now

00:18:16,850 --> 00:18:21,590
maybe you'll notice Oh even in the

00:18:19,580 --> 00:18:24,470
internals these things are typed right

00:18:21,590 --> 00:18:26,690
so another difference from our

00:18:24,470 --> 00:18:29,810
correctors is that we are actually very

00:18:26,690 --> 00:18:32,600
very typed in our streams and then you

00:18:29,810 --> 00:18:34,910
said how the input should be handled and

00:18:32,600 --> 00:18:37,970
it's as simple as okay someone pushes

00:18:34,910 --> 00:18:40,970
data if someone pushes data here

00:18:37,970 --> 00:18:45,140
I grab the element and when it decide

00:18:40,970 --> 00:18:46,880
what to do right the thing I'm trying to

00:18:45,140 --> 00:18:48,620
highlight here is you're not

00:18:46,880 --> 00:18:49,760
implementing the reactive streams

00:18:48,620 --> 00:18:52,070
interfaces here

00:18:49,760 --> 00:18:54,020
because they have these many many rules

00:18:52,070 --> 00:18:56,060
for we should behave about cancellation

00:18:54,020 --> 00:18:58,280
error handling and all the fuzzy things

00:18:56,060 --> 00:19:01,640
so the fuzzy things are hand handled for

00:18:58,280 --> 00:19:03,320
you and even if you go low level because

00:19:01,640 --> 00:19:04,910
that's like Velo lowest of the low

00:19:03,320 --> 00:19:06,940
levels if you want to implement custom

00:19:04,910 --> 00:19:13,010
things you're still guarded from

00:19:06,940 --> 00:19:15,200
complexity and but also let's survey

00:19:13,010 --> 00:19:17,330
usual way how you would implement custom

00:19:15,200 --> 00:19:19,370
things custom things can be very easily

00:19:17,330 --> 00:19:22,370
implemented by composing existing things

00:19:19,370 --> 00:19:24,380
right so rather than going graph stage

00:19:22,370 --> 00:19:27,680
like right away into the lowest low

00:19:24,380 --> 00:19:29,960
level as you can see here many of our

00:19:27,680 --> 00:19:33,710
stages are just implemented in terms of

00:19:29,960 --> 00:19:37,870
our operations from state from map

00:19:33,710 --> 00:19:37,870
contact and conquered is a popular one

00:19:37,960 --> 00:19:43,750
and here we have some custom on section

00:19:40,820 --> 00:19:43,750
okay

00:19:46,310 --> 00:19:53,420
let's talk about our HTTP right so okay

00:19:49,400 --> 00:19:55,760
HTTP it was developed as you well know

00:19:53,420 --> 00:19:57,800
kind of together with akka streams it

00:19:55,760 --> 00:20:00,020
had the same release cycle and was also

00:19:57,800 --> 00:20:03,710
one of her driving users of akka streams

00:20:00,020 --> 00:20:07,220
at least for us so where did we end up

00:20:03,710 --> 00:20:09,470
with that so obviously an HTTP server is

00:20:07,220 --> 00:20:11,600
phase flow of HTTP requests to responses

00:20:09,470 --> 00:20:14,000
but let's not worry dance because that's

00:20:11,600 --> 00:20:16,970
still easily representable as a function

00:20:14,000 --> 00:20:18,710
like an exam finagle does but where it

00:20:16,970 --> 00:20:21,320
really starts shining is that it's

00:20:18,710 --> 00:20:24,950
actually through all the layers it's the

00:20:21,320 --> 00:20:27,560
same concept of this streaming data so

00:20:24,950 --> 00:20:30,320
for example an HTTP entity is a source

00:20:27,560 --> 00:20:32,030
of byte strings right so you're you're

00:20:30,320 --> 00:20:34,970
reading in the byte strings as we come

00:20:32,030 --> 00:20:38,330
in from from the client for example and

00:20:34,970 --> 00:20:40,220
also WebSockets again everything is a

00:20:38,330 --> 00:20:43,100
flow and everything composes as nicely

00:20:40,220 --> 00:20:46,280
so let's see how that works in action

00:20:43,100 --> 00:20:49,580
and this is that part that hasn't been

00:20:46,280 --> 00:20:52,580
merged yet because still polishing the

00:20:49,580 --> 00:20:56,570
pro requests a bit and also exactly

00:20:52,580 --> 00:20:58,900
which part isn't once intelligent

00:20:56,570 --> 00:20:58,900
freezes

00:21:09,590 --> 00:21:12,820
I was silly

00:21:16,500 --> 00:21:18,500
Oh

00:21:19,669 --> 00:21:27,980
sorry about that do we have ontology

00:21:22,110 --> 00:21:27,980
people in the room please fix that

00:21:37,240 --> 00:21:55,600
and they need for presentation mode yes

00:21:43,440 --> 00:21:59,350
okay back to our doors occur HTTP okay

00:21:55,600 --> 00:22:01,990
so the one part that isn't merge right

00:21:59,350 --> 00:22:03,850
now is basically this right so it's

00:22:01,990 --> 00:22:06,789
called the framed entity streaming and

00:22:03,850 --> 00:22:08,710
it's a feature that allows you for

00:22:06,789 --> 00:22:10,600
example someone is uploading a CSV file

00:22:08,710 --> 00:22:12,730
and you want to consume it line by line

00:22:10,600 --> 00:22:14,830
or adjacent thing and you want to

00:22:12,730 --> 00:22:17,520
consume it object by object then you can

00:22:14,830 --> 00:22:22,360
just use the uh national infrastructure

00:22:17,520 --> 00:22:24,039
which works like that so before we go

00:22:22,360 --> 00:22:26,350
into that feature that isn't bad

00:22:24,039 --> 00:22:30,580
let's talk about the basics which is

00:22:26,350 --> 00:22:32,860
extract data bytes which is a directive

00:22:30,580 --> 00:22:34,720
that helps you to extract from an

00:22:32,860 --> 00:22:36,520
incoming request you can get for raw

00:22:34,720 --> 00:22:39,730
data bytes that someone is uploading

00:22:36,520 --> 00:22:44,470
maybe in a post request right and in

00:22:39,730 --> 00:22:46,720
this in this part I'm just summing how

00:22:44,470 --> 00:22:51,580
much data were was right so because this

00:22:46,720 --> 00:22:54,520
data bytes is a source of byte string I

00:22:51,580 --> 00:22:58,390
can just run a fold operation on it and

00:22:54,520 --> 00:23:00,820
add all the sizes of the chunks and then

00:22:58,390 --> 00:23:04,659
once it completes I complete with total

00:23:00,820 --> 00:23:06,510
length and bytes very simple and that's

00:23:04,659 --> 00:23:13,320
gonna be marshaled as a plaintext

00:23:06,510 --> 00:23:13,320
response and maybe just to show another

00:23:13,409 --> 00:23:21,070
lower level where this all comes from

00:23:16,320 --> 00:23:22,659
extract so extract is the

00:23:21,070 --> 00:23:24,730
general-purpose you can get things out

00:23:22,659 --> 00:23:27,190
of context and when I extract the

00:23:24,730 --> 00:23:29,950
request and what is a very quest it's a

00:23:27,190 --> 00:23:32,770
HTTP request what does it have it has an

00:23:29,950 --> 00:23:34,659
entity okay what does the entity have or

00:23:32,770 --> 00:23:37,210
it has the data bytes so if you think

00:23:34,659 --> 00:23:39,659
about how it's a matches with HTTP

00:23:37,210 --> 00:23:42,370
concepts it's a very directly

00:23:39,659 --> 00:23:45,399
represented in that sense so let's run

00:23:42,370 --> 00:23:47,789
this for now and then we run the more

00:23:45,399 --> 00:23:47,789
fun bit

00:23:49,040 --> 00:23:55,260
you're below I have a I'm just posting

00:23:53,010 --> 00:24:05,370
some tweets I can show you the tweets

00:23:55,260 --> 00:24:07,800
maybe it's just a line-by-line JSON

00:24:05,370 --> 00:24:11,520
object and we'll get to why that's

00:24:07,800 --> 00:24:16,190
actually maybe sometimes useful but for

00:24:11,520 --> 00:24:16,190
now let's run the thing and we post to

00:24:16,250 --> 00:24:25,200
step free raw endpoint okay it counted

00:24:23,220 --> 00:24:30,230
for thing mm-hmm maybe exciting maybe

00:24:25,200 --> 00:24:33,690
not that much here we can see it better

00:24:30,230 --> 00:24:36,120
but the next one is already the exciting

00:24:33,690 --> 00:24:38,400
feature so let's say I have entity and

00:24:36,120 --> 00:24:40,230
usually you could say I want for entity

00:24:38,400 --> 00:24:42,900
as a tweet and when we unmarshal the

00:24:40,230 --> 00:24:46,500
entire entity as a tweet but what if

00:24:42,900 --> 00:24:48,510
it's a incoming like stream of metrics

00:24:46,500 --> 00:24:50,280
from some IOT devices or something like

00:24:48,510 --> 00:24:52,440
that imaginary scenarios so you want

00:24:50,280 --> 00:24:54,870
with source so you can say a source

00:24:52,440 --> 00:24:57,830
invest one more thing and when you get

00:24:54,870 --> 00:25:02,040
back note the raw data bytes but

00:24:57,830 --> 00:25:05,880
actually a source of tweet and how do we

00:25:02,040 --> 00:25:09,180
handle that or basically in my JSON

00:25:05,880 --> 00:25:10,890
protocol we need to detect the framing

00:25:09,180 --> 00:25:12,360
somehow right you need to know which

00:25:10,890 --> 00:25:15,840
part of the byte string should i

00:25:12,360 --> 00:25:18,420
unmarshal as the actual object right so

00:25:15,840 --> 00:25:20,790
for jason has multiple ways to do it but

00:25:18,420 --> 00:25:22,890
basically the safest one is bracket

00:25:20,790 --> 00:25:24,750
counting and that he recently also did

00:25:22,890 --> 00:25:27,240
the same thing which I found funny

00:25:24,750 --> 00:25:29,700
because I was really hoping for a better

00:25:27,240 --> 00:25:32,880
way but now so basically you have a

00:25:29,700 --> 00:25:35,280
bracket counting framing and framing is

00:25:32,880 --> 00:25:42,270
also a concept available just in our

00:25:35,280 --> 00:25:43,860
streams yeah I framing and the default

00:25:42,270 --> 00:25:46,470
ones that we provide in our streams are

00:25:43,860 --> 00:25:49,320
very generic so it's delimiter based or

00:25:46,470 --> 00:25:52,020
length based right and when we provided

00:25:49,320 --> 00:25:55,260
this specific one in our HTTP that's for

00:25:52,020 --> 00:25:58,860
Jason and CSV is very simple because you

00:25:55,260 --> 00:26:00,570
just on the new line is split right so I

00:25:58,860 --> 00:26:03,780
have a source of tweets

00:26:00,570 --> 00:26:06,540
and these tweets have a sentiment score

00:26:03,780 --> 00:26:08,400
inside something like that so instead of

00:26:06,540 --> 00:26:11,130
summing the bytes I'm summing the

00:26:08,400 --> 00:26:13,500
sentiment and let's see if it actually

00:26:11,130 --> 00:26:21,360
works

00:26:13,500 --> 00:26:24,450
end point is framed and it's summed and

00:26:21,360 --> 00:26:26,490
unmarshal to the stream pulling in as

00:26:24,450 --> 00:26:30,360
fast as the server can consume it not

00:26:26,490 --> 00:26:32,820
faster and then again we have other way

00:26:30,360 --> 00:26:36,810
so you can just expose the Orca stream

00:26:32,820 --> 00:26:40,500
to http so here we have just a source of

00:26:36,810 --> 00:26:44,850
random tweet and we just complete with

00:26:40,500 --> 00:26:49,470
it which was something I saw yesterday I

00:26:44,850 --> 00:26:51,960
do have to show this to you guys I don't

00:26:49,470 --> 00:26:53,550
have them so of intelligent guys were

00:26:51,960 --> 00:26:55,410
showing me yesterday a feature called

00:26:53,550 --> 00:26:57,540
explain SCARA you should check it out

00:26:55,410 --> 00:26:59,670
because here we have some implicit

00:26:57,540 --> 00:27:01,500
conversions right it's handles for

00:26:59,670 --> 00:27:04,170
conversion from the akka stream to an

00:27:01,500 --> 00:27:06,000
actual HTTP response right so with some

00:27:04,170 --> 00:27:09,030
implicit involved people were always

00:27:06,000 --> 00:27:11,160
complaining about marshalling logic and

00:27:09,030 --> 00:27:13,110
spray in our HTTP being very very fuzzy

00:27:11,160 --> 00:27:14,850
and the feature of advocacy showed me

00:27:13,110 --> 00:27:17,280
yesterday basically explains exactly

00:27:14,850 --> 00:27:20,910
what is happening here so but it's

00:27:17,280 --> 00:27:23,160
cinnamon on in a nightly build so pretty

00:27:20,910 --> 00:27:24,770
simple but instead of showing this one

00:27:23,160 --> 00:27:27,240
I'm going to solve a WebSockets one

00:27:24,770 --> 00:27:29,370
because now we're going into the

00:27:27,240 --> 00:27:30,780
integration land how if everything is a

00:27:29,370 --> 00:27:35,100
stream we can easily connect them

00:27:30,780 --> 00:27:36,690
together so if a WebSocket is a flow we

00:27:35,100 --> 00:27:38,850
have some incoming side and we have some

00:27:36,690 --> 00:27:41,100
outgoing side so the incoming side and

00:27:38,850 --> 00:27:43,980
this one I don't really care about that

00:27:41,100 --> 00:27:46,170
much so I'm just ignoring the incoming

00:27:43,980 --> 00:27:47,370
data so the client is sending me a

00:27:46,170 --> 00:27:49,680
WebSocket request

00:27:47,370 --> 00:27:51,840
I mean ignoring it because this endpoint

00:27:49,680 --> 00:27:54,980
is basically just streaming data from

00:27:51,840 --> 00:27:58,440
Kafka well so that's a Kafka topic and

00:27:54,980 --> 00:28:00,980
how is it implemented and we'll see in a

00:27:58,440 --> 00:28:03,780
second but basically it's a source and

00:28:00,980 --> 00:28:06,210
as you know in Kafka you need to commit

00:28:03,780 --> 00:28:09,720
if you read the thing or outer commit

00:28:06,210 --> 00:28:12,100
but um that's the next slide so we'll

00:28:09,720 --> 00:28:17,230
talk about it in a second

00:28:12,100 --> 00:28:20,350
now let's serve oh good and here at the

00:28:17,230 --> 00:28:22,690
bottom maybe you'll see I'm just

00:28:20,350 --> 00:28:24,760
connecting like Kafka console producer

00:28:22,690 --> 00:28:26,830
so whatever I write here goes into the

00:28:24,760 --> 00:28:28,780
topic then through akka streams that

00:28:26,830 --> 00:28:30,970
pulls things from the topic force it and

00:28:28,780 --> 00:28:33,340
pushes it into a web socket and the web

00:28:30,970 --> 00:28:36,000
socket gets consumed by a client

00:28:33,340 --> 00:28:39,430
application that also occur streams

00:28:36,000 --> 00:28:43,120
here's for clients and we're basically

00:28:39,430 --> 00:28:46,660
sending a single HT WebSockets text

00:28:43,120 --> 00:28:49,570
message bear write single a WebSocket

00:28:46,660 --> 00:28:51,910
request with the client flow and the

00:28:49,570 --> 00:28:55,060
client flow prints all the incoming data

00:28:51,910 --> 00:28:57,520
and it emits only one single request

00:28:55,060 --> 00:29:02,770
which in this example is ignored by the

00:28:57,520 --> 00:29:15,340
server anyway so now we want to run the

00:29:02,770 --> 00:29:18,330
client for and then I went to what else

00:29:15,340 --> 00:29:18,330
not found what

00:29:23,039 --> 00:29:26,279
try go

00:29:34,620 --> 00:29:41,809
yep you have a client point

00:29:49,090 --> 00:29:55,210
as you see one typed in some data into a

00:29:52,810 --> 00:29:56,980
cough cough producer went through a

00:29:55,210 --> 00:29:59,050
topic and just connected all the way

00:29:56,980 --> 00:30:04,780
through to the WebSocket here so I got

00:29:59,050 --> 00:30:07,210
back text messages now the kind of

00:30:04,780 --> 00:30:08,800
feature here is that it's really easy to

00:30:07,210 --> 00:30:16,360
take together all these streaming

00:30:08,800 --> 00:30:18,850
libraries and they just fit okay so

00:30:16,360 --> 00:30:22,000
words does it fit because we were kind

00:30:18,850 --> 00:30:24,370
of and going into this area of more and

00:30:22,000 --> 00:30:26,860
more things want to integrate right and

00:30:24,370 --> 00:30:28,930
of course we should also integrate

00:30:26,860 --> 00:30:31,840
streams with existing are like parts of

00:30:28,930 --> 00:30:34,720
akka here of a query site long requested

00:30:31,840 --> 00:30:37,570
feature for our capacitance which is

00:30:34,720 --> 00:30:39,070
basically more like a data pump still

00:30:37,570 --> 00:30:42,160
experimental we're working on perfecting

00:30:39,070 --> 00:30:44,710
the API still but the key here is that

00:30:42,160 --> 00:30:46,900
it's also a stream alright so the query

00:30:44,710 --> 00:30:48,940
side is you have a persistent actors we

00:30:46,900 --> 00:30:51,040
are writing some data and on the query

00:30:48,940 --> 00:30:53,560
side you want to get out this exact data

00:30:51,040 --> 00:30:57,220
and maybe put it into a other format or

00:30:53,560 --> 00:30:59,410
query optimized store so it's not

00:30:57,220 --> 00:31:01,780
precisely the thing you would be

00:30:59,410 --> 00:31:03,190
directly using to query the thing but

00:31:01,780 --> 00:31:05,910
it's more like a data pump that you put

00:31:03,190 --> 00:31:08,740
would put into a optimized storage

00:31:05,910 --> 00:31:11,050
important to remember about in general

00:31:08,740 --> 00:31:14,770
secures architectures so who supports

00:31:11,050 --> 00:31:16,960
fast already well the Cassandra plugin

00:31:14,770 --> 00:31:20,080
which we maintain nowadays does

00:31:16,960 --> 00:31:21,820
supported the level DB which is a bit

00:31:20,080 --> 00:31:23,650
toyish but if you want to just try it

00:31:21,820 --> 00:31:26,110
out and don't be trying it out here with

00:31:23,650 --> 00:31:28,510
every D be also supports it and then two

00:31:26,110 --> 00:31:30,370
of the community plugins I know v3 is

00:31:28,510 --> 00:31:33,690
supported which is veg ad PC and

00:31:30,370 --> 00:31:36,430
plugins were supported by polling and

00:31:33,690 --> 00:31:38,710
likely more but I forgot about so if

00:31:36,430 --> 00:31:43,150
your plugin isn't here just tell me you

00:31:38,710 --> 00:31:46,680
need to update the list so how does that

00:31:43,150 --> 00:31:50,110
look like let's say you have a

00:31:46,680 --> 00:31:53,050
persistent actor anyone not seen a cop

00:31:50,110 --> 00:31:55,060
assistance before yep okay

00:31:53,050 --> 00:31:57,430
many people have many didn't a few

00:31:55,060 --> 00:31:59,500
didn't so a capacitance is basically a

00:31:57,430 --> 00:32:02,310
way of building even sourced

00:31:59,500 --> 00:32:04,980
applications so it adds persistent

00:32:02,310 --> 00:32:07,320
to your actors in the sense of you can

00:32:04,980 --> 00:32:10,920
you have incoming commands and when you

00:32:07,320 --> 00:32:13,110
can store a event and when this actor

00:32:10,920 --> 00:32:14,970
restarts it can replay all the events

00:32:13,110 --> 00:32:17,730
from the past so it can recover the same

00:32:14,970 --> 00:32:20,100
state so here we are just telling it who

00:32:17,730 --> 00:32:22,410
it should greet it persists a greeting

00:32:20,100 --> 00:32:25,620
and once it has successfully resisted

00:32:22,410 --> 00:32:28,140
the greeting it's both prints a logline

00:32:25,620 --> 00:32:31,080
and replies with a greeting to whoever

00:32:28,140 --> 00:32:32,460
asks for a greeting right here if you

00:32:31,080 --> 00:32:34,440
haven't seen our cup resistance before

00:32:32,460 --> 00:32:36,330
you may be scared that mmm this looks

00:32:34,440 --> 00:32:38,160
like an asynchronous operation it

00:32:36,330 --> 00:32:39,780
actually is and then most usually

00:32:38,160 --> 00:32:41,940
accessing the sender isn't safe like

00:32:39,780 --> 00:32:43,380
like in futures right but in a cup

00:32:41,940 --> 00:32:45,360
assistance we take care of that and the

00:32:43,380 --> 00:32:47,700
center here is actually very correct

00:32:45,360 --> 00:32:50,640
sender even though this is a

00:32:47,700 --> 00:32:53,870
asynchronous callback so just a nice

00:32:50,640 --> 00:32:53,870
more thing we added there

00:33:01,630 --> 00:33:09,760
erase my position squaring so what I'm

00:33:06,370 --> 00:33:11,559
doing is periodically I'm omitting some

00:33:09,760 --> 00:33:15,130
names that should be persisted and

00:33:11,559 --> 00:33:17,260
greeted and here's the query side so the

00:33:15,130 --> 00:33:19,870
right side is basically just an actor

00:33:17,260 --> 00:33:21,610
the outside world it doesn't know that

00:33:19,870 --> 00:33:24,100
it's a persistent actor it's just the

00:33:21,610 --> 00:33:25,990
normal actor right that's a good thing

00:33:24,100 --> 00:33:30,070
that you don't have to care about how

00:33:25,990 --> 00:33:32,500
the actor is implemented and here the

00:33:30,070 --> 00:33:34,270
query size is as simple as you get a

00:33:32,500 --> 00:33:36,820
query journal for whatever journal

00:33:34,270 --> 00:33:40,900
you're using and here we have this

00:33:36,820 --> 00:33:43,659
journal which exposes api's like give me

00:33:40,900 --> 00:33:46,809
your persistence IDs and the type is

00:33:43,659 --> 00:33:55,630
over IDs are strings right and here the

00:33:46,809 --> 00:33:57,580
difference between two api's that

00:33:55,630 --> 00:34:00,669
literally doesn't like me today so just

00:33:57,580 --> 00:34:03,460
always two styles of visa API course one

00:34:00,669 --> 00:34:05,470
is current persistence IDs which is the

00:34:03,460 --> 00:34:07,330
stream will actually complete once it

00:34:05,470 --> 00:34:09,129
gets to the okay I've seen all of

00:34:07,330 --> 00:34:11,320
positions IDs I will complete the stream

00:34:09,129 --> 00:34:14,169
and the other one is all persistence IDs

00:34:11,320 --> 00:34:16,359
which will keep the stream alive and it

00:34:14,169 --> 00:34:18,159
will depending on database it may have

00:34:16,359 --> 00:34:20,379
to do polling or it can subscribe to

00:34:18,159 --> 00:34:22,720
something and that will keep the stream

00:34:20,379 --> 00:34:25,060
alive and if new persistent actors come

00:34:22,720 --> 00:34:26,770
into a system the persistence IDs would

00:34:25,060 --> 00:34:30,899
be picked up here and you can basically

00:34:26,770 --> 00:34:34,119
react to more live events in that sense

00:34:30,899 --> 00:34:37,950
so here let's doesn't matter that much

00:34:34,119 --> 00:34:40,899
let's use all and then we have ID and

00:34:37,950 --> 00:34:44,619
then for ID I can query all the events

00:34:40,899 --> 00:34:47,580
and so here I can just extract the

00:34:44,619 --> 00:34:51,010
events fattest actor has persisted

00:34:47,580 --> 00:34:53,950
usually this would be on a probably

00:34:51,010 --> 00:35:01,650
different application not right next to

00:34:53,950 --> 00:35:01,650
each other right so Francis fing

00:35:02,670 --> 00:35:11,900
what's her name here step before before

00:35:13,400 --> 00:35:18,180
okay

00:35:14,610 --> 00:35:21,410
and as you can see it's stirring the

00:35:18,180 --> 00:35:25,940
greetings and then we should also see

00:35:21,410 --> 00:35:25,940
yes even equals

00:35:32,830 --> 00:35:35,820
and we're not

00:35:45,850 --> 00:35:55,260
I will not maybe dwell on it should have

00:35:50,800 --> 00:35:59,500
printed with ink what

00:35:55,260 --> 00:36:01,870
so the Kafka sources and sinks that I

00:35:59,500 --> 00:36:04,480
showed a while ago are actually a

00:36:01,870 --> 00:36:06,610
cooperation and have been started as

00:36:04,480 --> 00:36:08,950
reactive Kafka by Khrushchev ski and on

00:36:06,610 --> 00:36:10,000
on the skis from software mill and it's

00:36:08,950 --> 00:36:12,520
a project that we're currently

00:36:10,000 --> 00:36:15,880
cooperating together and polishing it so

00:36:12,520 --> 00:36:18,130
it really is nailing the thing and an

00:36:15,880 --> 00:36:21,040
interesting thing from Verta is that

00:36:18,130 --> 00:36:23,710
yeah of acknowledgments right and you

00:36:21,040 --> 00:36:25,990
will notice that in many situations you

00:36:23,710 --> 00:36:27,910
will need some kind of acknowledgment in

00:36:25,990 --> 00:36:31,210
Envy stream processing situations and

00:36:27,910 --> 00:36:33,970
the idea here is that we are

00:36:31,210 --> 00:36:37,660
experimenting with api's specifically on

00:36:33,970 --> 00:36:40,150
the Kafka case but it's a general thing

00:36:37,660 --> 00:36:43,240
and once we have api's nailed we can for

00:36:40,150 --> 00:36:45,460
example as extract a equable type but

00:36:43,240 --> 00:36:48,010
maybe has some support or it's just a

00:36:45,460 --> 00:36:51,160
common type but if you need this thing

00:36:48,010 --> 00:36:53,470
when libraries can require you to give

00:36:51,160 --> 00:36:55,660
them an equable and if there's a shared

00:36:53,470 --> 00:36:58,660
type and everybody agrees on using that

00:36:55,660 --> 00:37:01,210
type again we have composability across

00:36:58,660 --> 00:37:03,640
libraries if we can agree how we want to

00:37:01,210 --> 00:37:07,810
do acknowledgement so that's the way

00:37:03,640 --> 00:37:10,540
forward with that part and of course the

00:37:07,810 --> 00:37:12,730
question comes up okay so Kafka akka is

00:37:10,540 --> 00:37:16,720
it directly competing yes no especially

00:37:12,730 --> 00:37:19,180
that algis Kafka streams again another

00:37:16,720 --> 00:37:20,770
library of stream in the name the answer

00:37:19,180 --> 00:37:23,310
is I don't think so I think we

00:37:20,770 --> 00:37:26,440
complement each other very very well and

00:37:23,310 --> 00:37:30,670
usual architectures that we see are

00:37:26,440 --> 00:37:34,570
mostly structured as akka being actually

00:37:30,670 --> 00:37:36,970
take traffic on take on the traffic do

00:37:34,570 --> 00:37:39,640
some transformations fair do some actual

00:37:36,970 --> 00:37:42,670
logic fair Kafka being more like the

00:37:39,640 --> 00:37:45,640
buffer that you want to upload further

00:37:42,670 --> 00:37:48,010
maybe pre-processed data for later

00:37:45,640 --> 00:37:50,530
processing and then you both consume it

00:37:48,010 --> 00:37:52,690
in our streams if you want to maybe do

00:37:50,530 --> 00:37:54,850
some more side affecting things like I'm

00:37:52,690 --> 00:37:58,000
send for customer an email that hey now

00:37:54,850 --> 00:37:59,580
you have reached a quote and you can get

00:37:58,000 --> 00:38:01,740
a promotion or something like

00:37:59,580 --> 00:38:03,720
so it's more further for these things

00:38:01,740 --> 00:38:06,600
and it's arbitrary whatever you need to

00:38:03,720 --> 00:38:09,300
do you can do an an an Aqaba app and

00:38:06,600 --> 00:38:11,790
then of course for more data science

00:38:09,300 --> 00:38:13,980
heavy applications we do think that

00:38:11,790 --> 00:38:16,200
spark is really great for that and just

00:38:13,980 --> 00:38:18,300
fits so it's not that we're competing

00:38:16,200 --> 00:38:21,450
with these technologies were integrating

00:38:18,300 --> 00:38:25,140
with them right and of course the

00:38:21,450 --> 00:38:27,480
backpressure is over we feel so here's

00:38:25,140 --> 00:38:30,900
for like looping back to the first

00:38:27,480 --> 00:38:32,970
example I had today which is okay we had

00:38:30,900 --> 00:38:36,360
this actor case but we're overwhelming

00:38:32,970 --> 00:38:38,100
this actor and this wasn't too bad I

00:38:36,360 --> 00:38:40,470
mean nothing blew up but if you have

00:38:38,100 --> 00:38:44,520
many many actors and you don't control

00:38:40,470 --> 00:38:47,040
the rights of how you're processing when

00:38:44,520 --> 00:38:49,440
you sometimes can go into and just too

00:38:47,040 --> 00:38:52,920
much GC and problems like that so let's

00:38:49,440 --> 00:38:57,810
see how we can solve that with just

00:38:52,920 --> 00:39:00,690
using a stream for that maybe this is

00:38:57,810 --> 00:39:02,160
right more so let's say I have actors on

00:39:00,690 --> 00:39:03,960
both ends of the stream because I'm

00:39:02,160 --> 00:39:06,150
integrating with something is existing

00:39:03,960 --> 00:39:08,880
and invest stream processing and doing

00:39:06,150 --> 00:39:11,340
some transformations right use one then

00:39:08,880 --> 00:39:15,270
we have for both sides two ways to

00:39:11,340 --> 00:39:18,630
integrate fair so because the reason is

00:39:15,270 --> 00:39:22,050
in a synchronous message sent you don't

00:39:18,630 --> 00:39:23,820
have a blocking way to directly tell a

00:39:22,050 --> 00:39:26,040
please stop sending it would be a

00:39:23,820 --> 00:39:28,710
synchronous and anyway right so it would

00:39:26,040 --> 00:39:31,470
be an ACK so there's two api's one of

00:39:28,710 --> 00:39:33,600
them is a queue but has a bounded limit

00:39:31,470 --> 00:39:36,330
and if you can try to insert into it and

00:39:33,600 --> 00:39:39,330
it's overflowing it will tell you when

00:39:36,330 --> 00:39:42,060
and for actor F which will for example

00:39:39,330 --> 00:39:46,380
start dropping on the other side we have

00:39:42,060 --> 00:39:48,570
actor FF ACK which is basically pulling

00:39:46,380 --> 00:39:50,310
in in a sense because if it doesn't

00:39:48,570 --> 00:39:52,950
acknowledge a message we don't send more

00:39:50,310 --> 00:39:56,010
messages to it and then we have actor F

00:39:52,950 --> 00:40:00,320
sync which we just keep pushing as fast

00:39:56,010 --> 00:40:00,320
as we can data to the downstream actor

00:40:02,240 --> 00:40:05,970
okay

00:40:03,480 --> 00:40:07,890
actors and streams actually we can look

00:40:05,970 --> 00:40:14,710
back to the step 1

00:40:07,890 --> 00:40:16,420
all right so here we said loopback okay

00:40:14,710 --> 00:40:19,960
we have a source we were repeating the

00:40:16,420 --> 00:40:24,190
hello message and we're using this

00:40:19,960 --> 00:40:29,430
active F with AK and let me explain the

00:40:24,190 --> 00:40:32,830
types here because if you want to

00:40:29,430 --> 00:40:35,140
integrate safely so we don't overwhelm

00:40:32,830 --> 00:40:36,850
for downstream actor we want to know if

00:40:35,140 --> 00:40:39,310
it's ready to consume more elements or

00:40:36,850 --> 00:40:41,680
not right so it's a very very simplified

00:40:39,310 --> 00:40:42,190
version of a work pooling it's just a

00:40:41,680 --> 00:40:45,430
key

00:40:42,190 --> 00:40:47,350
so here the message types are because we

00:40:45,430 --> 00:40:49,660
want to tell factor that okay now we're

00:40:47,350 --> 00:40:51,940
starting you will be getting messages

00:40:49,660 --> 00:40:53,620
here's FAQ message so the message that

00:40:51,940 --> 00:40:56,230
we expect that we get back from the

00:40:53,620 --> 00:40:57,940
actor and when we see okay it has

00:40:56,230 --> 00:40:59,740
acknowledged we can send more data and

00:40:57,940 --> 00:41:02,470
we also have another message that we

00:40:59,740 --> 00:41:05,770
send from the stream to vector once the

00:41:02,470 --> 00:41:08,980
stream has completed and vector here is

00:41:05,770 --> 00:41:10,870
very simple it's a being slow remember

00:41:08,980 --> 00:41:16,330
don't do that and then it replies with

00:41:10,870 --> 00:41:17,920
okay so that's for acknowledgement now

00:41:16,330 --> 00:41:21,160
let's run the same thing as previously

00:41:17,920 --> 00:41:23,890
but now with stream feeding the data

00:41:21,160 --> 00:41:25,990
into it you could imagine this being may

00:41:23,890 --> 00:41:28,030
be exactly consuming from Kafka and you

00:41:25,990 --> 00:41:30,730
want to feed from Kafka into your actor

00:41:28,030 --> 00:41:34,660
application but not as fast as fast as

00:41:30,730 --> 00:41:41,820
possible but not faster and then number

00:41:34,660 --> 00:41:41,820
five and we'll see some metrics

00:41:45,160 --> 00:41:53,349
okay mailbox size we see if it was 92

00:41:50,980 --> 00:41:55,450
times we measured the thing and from

00:41:53,349 --> 00:41:57,849
that we see the distribution of the

00:41:55,450 --> 00:42:00,339
mailbox size yeah it's basically always

00:41:57,849 --> 00:42:01,809
1 because here we are acknowledging when

00:42:00,339 --> 00:42:04,960
we get a message acknowledging when we

00:42:01,809 --> 00:42:11,740
get a message it's lower but not

00:42:04,960 --> 00:42:13,690
overwhelming factor right good so in

00:42:11,740 --> 00:42:16,180
general I think it's exciting times in

00:42:13,690 --> 00:42:18,700
terms of actually putting ARCA streams

00:42:16,180 --> 00:42:21,280
to use and integrating it with various

00:42:18,700 --> 00:42:24,309
other libraries and concepts and

00:42:21,280 --> 00:42:27,010
building on top of it because now API is

00:42:24,309 --> 00:42:30,039
are stable and we're confident and this

00:42:27,010 --> 00:42:32,289
is the thing we wanted to build and yeah

00:42:30,039 --> 00:42:34,000
many of the next steps for us are really

00:42:32,289 --> 00:42:35,950
related to occur streams for example

00:42:34,000 --> 00:42:38,500
many of you noticed maybe that we're

00:42:35,950 --> 00:42:41,260
rewriting remoting currently the goal

00:42:38,500 --> 00:42:42,640
being this mostly to speed it up have it

00:42:41,260 --> 00:42:45,069
also more maintainable and more

00:42:42,640 --> 00:42:47,260
introspective and well of course it's

00:42:45,069 --> 00:42:49,720
based on our streams because we found

00:42:47,260 --> 00:42:52,029
for the work fair is just much more

00:42:49,720 --> 00:42:55,450
pleasant this way then we'll do some

00:42:52,029 --> 00:42:58,420
other work like here I mentioned very

00:42:55,450 --> 00:43:00,730
active Kafka work with software now it's

00:42:58,420 --> 00:43:02,619
currently in milestone phase so don't

00:43:00,730 --> 00:43:04,210
treat this as a an announcement because

00:43:02,619 --> 00:43:06,789
we're still working on the API sphere

00:43:04,210 --> 00:43:08,529
but there will be a nice announcement

00:43:06,789 --> 00:43:10,799
and thank you to the software guys

00:43:08,529 --> 00:43:14,589
who've really helped us with that one

00:43:10,799 --> 00:43:16,299
and we see and here's a announcement

00:43:14,589 --> 00:43:17,890
that there will be an announcement and

00:43:16,299 --> 00:43:20,829
I'm sorry because I wanted to announce

00:43:17,890 --> 00:43:22,960
the actual thing but we really want more

00:43:20,829 --> 00:43:25,839
contributors kind of to join the efforts

00:43:22,960 --> 00:43:28,390
because why not and we thought that

00:43:25,839 --> 00:43:30,910
maybe a mini competition or something

00:43:28,390 --> 00:43:33,609
like that will be fun and we also want

00:43:30,910 --> 00:43:36,279
to spend some more time and resources on

00:43:33,609 --> 00:43:39,059
helping people to contribute to occur to

00:43:36,279 --> 00:43:43,329
be even more inclusive as as previously

00:43:39,059 --> 00:43:44,920
so have your eyes peeled for that and if

00:43:43,329 --> 00:43:46,809
you want to just start hacking right

00:43:44,920 --> 00:43:48,520
away here's how it was easy to

00:43:46,809 --> 00:43:51,010
contribute and nice to have tags on

00:43:48,520 --> 00:43:54,910
github those are nice tickets to start

00:43:51,010 --> 00:43:57,990
out with verse if you want to hack

00:43:54,910 --> 00:44:00,600
around with crazy stages you can come

00:43:57,990 --> 00:44:04,290
to vaca streamcon reply berry which is

00:44:00,600 --> 00:44:07,050
more accepting in various crazy stages

00:44:04,290 --> 00:44:09,240
than the Karaka because you know it's a

00:44:07,050 --> 00:44:11,820
con trick thing it can move faster and

00:44:09,240 --> 00:44:15,780
when we're on set and mailing lists so

00:44:11,820 --> 00:44:19,880
find us very so thank you I hope it was

00:44:15,780 --> 00:44:19,880
ok and if you have any questions

00:44:26,980 --> 00:44:31,240
we have maybe a minute or two for

00:44:29,540 --> 00:44:41,900
questions very in the middle maybe

00:44:31,240 --> 00:44:44,480
person in blue shirt okay how to be able

00:44:41,900 --> 00:44:46,670
to gracefully shut down as streaming

00:44:44,480 --> 00:44:49,640
applications so that for example you can

00:44:46,670 --> 00:44:51,770
call out a new version of it but you

00:44:49,640 --> 00:44:54,380
don't you but you want to only up great

00:44:51,770 --> 00:44:56,900
when you know that at least everything

00:44:54,380 --> 00:45:00,050
it started picking up you know it's

00:44:56,900 --> 00:45:01,820
being handled before you shut it down

00:45:00,050 --> 00:45:09,020
right I'm having trouble hearing you

00:45:01,820 --> 00:45:11,660
actually how to how to gracefully

00:45:09,020 --> 00:45:15,140
down a streaming application so you can

00:45:11,660 --> 00:45:18,800
roll out a new version a gracefully shut

00:45:15,140 --> 00:45:21,650
down streaming applications yes so I

00:45:18,800 --> 00:45:24,620
kind of played at the point of extremes

00:45:21,650 --> 00:45:27,500
being it's like a super powerful

00:45:24,620 --> 00:45:32,150
iterator right so yes streaming

00:45:27,500 --> 00:45:34,040
applications but all kinds of it's not

00:45:32,150 --> 00:45:35,450
that for stream kind of changes where

00:45:34,040 --> 00:45:38,480
where you've been building applications

00:45:35,450 --> 00:45:40,850
really because if you had a message

00:45:38,480 --> 00:45:42,770
based application with actors the the

00:45:40,850 --> 00:45:44,990
same concepts apply to versioning the

00:45:42,770 --> 00:45:47,840
messages and having them compatible as

00:45:44,990 --> 00:45:49,310
with a for example streaming app so I

00:45:47,840 --> 00:45:51,800
don't think it changes much in that

00:45:49,310 --> 00:45:53,410
sense you need to care about message

00:45:51,800 --> 00:45:55,790
versioning here you need to care about

00:45:53,410 --> 00:45:58,520
element which actually is a message

00:45:55,790 --> 00:46:05,510
anyway versioning I don't know if that

00:45:58,520 --> 00:46:10,520
helps but that's my answer here we have

00:46:05,510 --> 00:46:13,990
a lost question or are we happy okay so

00:46:10,520 --> 00:46:13,990
let's have lunch thank you very much

00:46:15,440 --> 00:46:17,500

YouTube URL: https://www.youtube.com/watch?v=x62K4ObBtw4


