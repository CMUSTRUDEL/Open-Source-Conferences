Title: Don't Fear the Implicits: Everything You Need to Know About Typeclasses   by Daniel Westheide
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
Developers who are new to Scala often shy away from coming into contact with implicits, and by extension, understanding typeclasses. In big organizations that have been adopting Scala at scale, you sometimes even come across hard rules that put a ban on the use of implicits because that language feature is considered to be too advanced and not understood by a lot of developers. On the other hand, implicits and typeclasses are used heavily not only by a lot of the most important Scala frameworks and libraries, but also in the standard library. Given the fact that it is so hard to evade them when writing real world Scala code, I would like to encourage developers adopting Scala to overcome their fear of implicits and instead embrace the typeclass pattern. In this talk, as an intermediate Scala developer, you will learn everything you really need to know about typeclasses: What they are good for and how they compare to what you are familiar with from object-oriented languages, when you should and should not use them, how the pattern can be encoded in Scala and how to write your own typeclasses, how to provide instances of typeclasses for your own or existing types, and how to do all of this with minimal boilerplate. Throughout the talk, you will see numerous examples of typeclasses used in the Scala ecosystem and the standard library, and you'll see that you don't need to know anything about category theory to benefit from embracing typeclasses.
Captions: 
	00:00:03,200 --> 00:00:11,160
okay before I start here are a few fun

00:00:07,200 --> 00:00:14,219
facts about me I'm a consultant at in EQ

00:00:11,160 --> 00:00:18,420
Germany we are a Lightman's training and

00:00:14,219 --> 00:00:20,640
consulting partner and if you know me

00:00:18,420 --> 00:00:24,750
you probably know me from the neophytes

00:00:20,640 --> 00:00:28,220
kind to Scala and yeah I am on Twitter I

00:00:24,750 --> 00:00:32,480
have a website so feel free to connect

00:00:28,220 --> 00:00:35,940
okay so today I want to talk about

00:00:32,480 --> 00:00:39,899
implicit and there are many different

00:00:35,940 --> 00:00:42,719
use cases in Scala for implicit and you

00:00:39,899 --> 00:00:45,899
can see a few here they are used for

00:00:42,719 --> 00:00:47,670
dependencies configuration for different

00:00:45,899 --> 00:00:52,019
kinds of contexts or passing these

00:00:47,670 --> 00:00:53,909
things around but all of these are not

00:00:52,019 --> 00:00:57,269
what I want to talk about today but I

00:00:53,909 --> 00:01:00,059
want to talk about one usage that I find

00:00:57,269 --> 00:01:05,190
particularly interesting which is the

00:01:00,059 --> 00:01:07,830
type class pattern so I hope there's not

00:01:05,190 --> 00:01:10,110
too much in here that overlaps with what

00:01:07,830 --> 00:01:12,840
you might have already heard in Noel's

00:01:10,110 --> 00:01:14,760
talk or Tim stock who has been in any of

00:01:12,840 --> 00:01:20,720
those ok

00:01:14,760 --> 00:01:23,550
not too many lucky me but if there is I

00:01:20,720 --> 00:01:27,840
think that repetition is also a great

00:01:23,550 --> 00:01:30,000
technique for memorizing stuff ok so the

00:01:27,840 --> 00:01:32,190
reason I am doing this talk is that I

00:01:30,000 --> 00:01:36,120
have made a few interesting observations

00:01:32,190 --> 00:01:38,340
recently and one of them is when I was

00:01:36,120 --> 00:01:41,550
talking at meetups and I was explaining

00:01:38,340 --> 00:01:43,890
something that involved type classes ask

00:01:41,550 --> 00:01:47,790
people whether they actually were

00:01:43,890 --> 00:01:49,530
familiar with this concept and most of

00:01:47,790 --> 00:01:53,100
the people said I had never heard of it

00:01:49,530 --> 00:01:55,410
at all and also I've seen organizations

00:01:53,100 --> 00:01:58,830
in which you're discouraged from using

00:01:55,410 --> 00:02:03,390
implicit and by extension from using

00:01:58,830 --> 00:02:06,720
type classes and often the argument is

00:02:03,390 --> 00:02:08,849
that it's too complicated for developers

00:02:06,720 --> 00:02:11,550
who are not very experienced with Scala

00:02:08,849 --> 00:02:14,190
to work with implicit and type classes

00:02:11,550 --> 00:02:15,130
or simply that there is too much magic

00:02:14,190 --> 00:02:19,150
going on

00:02:15,130 --> 00:02:20,770
and at the same time developers like

00:02:19,150 --> 00:02:23,050
that often happily clutter their code

00:02:20,770 --> 00:02:26,050
with annotations that will be

00:02:23,050 --> 00:02:29,070
interpreted and runtime to do all kinds

00:02:26,050 --> 00:02:31,660
of magic things from persistence to

00:02:29,070 --> 00:02:38,890
starting an OAuth to authorization

00:02:31,660 --> 00:02:42,400
server okay so one kind of magic is good

00:02:38,890 --> 00:02:46,600
the other is bad now the runtime magic

00:02:42,400 --> 00:02:49,300
is good obviously okay but it's a Scala

00:02:46,600 --> 00:02:51,100
developer sooner or later you will be

00:02:49,300 --> 00:02:53,230
confronted with implicit Sandra type

00:02:51,100 --> 00:02:56,350
classes if you are doing anything

00:02:53,230 --> 00:02:58,210
non-trivial and you can only Klaus close

00:02:56,350 --> 00:03:03,700
your eyes and pretend that these things

00:02:58,210 --> 00:03:05,860
don't exist for so long the reason is

00:03:03,700 --> 00:03:08,650
that while some people shy away from

00:03:05,860 --> 00:03:11,650
these concepts they are actually used in

00:03:08,650 --> 00:03:13,780
a lot of libraries and frameworks for

00:03:11,650 --> 00:03:17,200
example the whole Lichtman stack is

00:03:13,780 --> 00:03:21,760
using them heavily and so does the

00:03:17,200 --> 00:03:24,730
scholar standard library so even if you

00:03:21,760 --> 00:03:26,980
write something as trivial as this you

00:03:24,730 --> 00:03:27,610
are using type classes whether you know

00:03:26,980 --> 00:03:31,120
it or not

00:03:27,610 --> 00:03:33,700
so here the can built from type class is

00:03:31,120 --> 00:03:36,010
used to make sure we return the most

00:03:33,700 --> 00:03:39,070
appropriate type by mapping over this

00:03:36,010 --> 00:03:43,360
vector so we get a vector back and not

00:03:39,070 --> 00:03:46,090
something more generic here we have the

00:03:43,360 --> 00:03:50,410
numeric type class so if you have a

00:03:46,090 --> 00:03:53,530
collection of some type for which there

00:03:50,410 --> 00:03:55,360
is the numeric type class instance then

00:03:53,530 --> 00:03:58,120
the sum method is available on that

00:03:55,360 --> 00:04:00,790
collection and only for those types and

00:03:58,120 --> 00:04:05,860
these are both defined in the standard

00:04:00,790 --> 00:04:07,630
library now in a recent treat Jessica

00:04:05,860 --> 00:04:10,150
Kerr complained that Scala library

00:04:07,630 --> 00:04:13,240
offers with implicit sand type classes

00:04:10,150 --> 00:04:15,100
integrated into their sole don't see how

00:04:13,240 --> 00:04:19,210
hard this code is for mortals to work

00:04:15,100 --> 00:04:21,760
with I think that the street confirms my

00:04:19,210 --> 00:04:24,160
experience that there is a big gap or

00:04:21,760 --> 00:04:27,960
disconnect between some library authors

00:04:24,160 --> 00:04:27,960
and a lot of application developers

00:04:27,990 --> 00:04:34,800
and I believe that this gap is not very

00:04:30,640 --> 00:04:37,900
healthy and we need to try to close it

00:04:34,800 --> 00:04:41,890
from both sides so this can mean that

00:04:37,900 --> 00:04:45,580
maybe library authors have to rethink

00:04:41,890 --> 00:04:49,840
that design choices maybe we have used

00:04:45,580 --> 00:04:51,160
too many type classes sometimes and not

00:04:49,840 --> 00:04:53,770
everything needs to be done with

00:04:51,160 --> 00:04:56,650
implicit but on the other side maybe

00:04:53,770 --> 00:05:01,090
developers need to overcome their fear

00:04:56,650 --> 00:05:04,660
of the implicit and suggesting that you

00:05:01,090 --> 00:05:06,400
need some kind of super power to

00:05:04,660 --> 00:05:10,450
understand them does not really help

00:05:06,400 --> 00:05:12,820
either so it's my goal that after this

00:05:10,450 --> 00:05:14,530
talk you have lost your fear and see

00:05:12,820 --> 00:05:16,510
that mere mortals can mask the type

00:05:14,530 --> 00:05:19,930
classes and put them to good use just

00:05:16,510 --> 00:05:21,460
fine and I hope you'll see that there

00:05:19,930 --> 00:05:24,360
isn't really anything I can about them

00:05:21,460 --> 00:05:27,070
and that you don't have to study

00:05:24,360 --> 00:05:32,800
category theory to benefit from type

00:05:27,070 --> 00:05:34,600
classes okay so instead of boring you

00:05:32,800 --> 00:05:37,270
with some abstract definition of what

00:05:34,600 --> 00:05:39,330
type classes are I want to start with an

00:05:37,270 --> 00:05:41,920
example problem that needs to be solved

00:05:39,330 --> 00:05:43,900
and first I'm going to try out an

00:05:41,920 --> 00:05:46,330
approach that you might use in an

00:05:43,900 --> 00:05:48,850
object-oriented language and from there

00:05:46,330 --> 00:05:51,270
on we'll gently move towards the

00:05:48,850 --> 00:05:53,920
solution that is based on type classes

00:05:51,270 --> 00:05:56,410
and after that we'll delve into a few

00:05:53,920 --> 00:05:59,620
more advanced aspects of type classes

00:05:56,410 --> 00:06:04,180
type class design and how to make use of

00:05:59,620 --> 00:06:05,950
type classes in a good way so let's say

00:06:04,180 --> 00:06:07,690
we're working on a project that needs to

00:06:05,950 --> 00:06:11,800
deal with various kinds of quantities

00:06:07,690 --> 00:06:14,320
and has to do so using some fancy big

00:06:11,800 --> 00:06:17,760
data framework that exposes a data

00:06:14,320 --> 00:06:22,450
structure called distributed dataset and

00:06:17,760 --> 00:06:24,070
for simplicity simplicity sake this data

00:06:22,450 --> 00:06:27,420
structure only has two functions defined

00:06:24,070 --> 00:06:30,370
on it fold left and count

00:06:27,420 --> 00:06:34,180
they look virtually the same as Scala

00:06:30,370 --> 00:06:36,900
collection fold left and SPARC sorry D

00:06:34,180 --> 00:06:43,270
methods so

00:06:36,900 --> 00:06:45,010
we can fold over our data set here now

00:06:43,270 --> 00:06:49,840
the first quantity type we need to work

00:06:45,010 --> 00:06:52,510
with as kilograms and here it is it's

00:06:49,840 --> 00:06:54,760
nothing really special here maybe one

00:06:52,510 --> 00:06:58,440
thing that needs to be mentioned is that

00:06:54,760 --> 00:06:58,440
of course we can't multiply or divide

00:06:58,500 --> 00:07:03,160
kilograms by themselves

00:07:00,730 --> 00:07:05,230
we'll only by some number and in the

00:07:03,160 --> 00:07:09,010
companion object we have the 0 value for

00:07:05,230 --> 00:07:10,900
kilograms and some functions that make

00:07:09,010 --> 00:07:14,140
use of these operators we have defined

00:07:10,900 --> 00:07:19,020
here but some function and the mean

00:07:14,140 --> 00:07:24,840
function which calculates the average

00:07:19,020 --> 00:07:24,840
weight of the whole distributed data set

00:07:25,320 --> 00:07:32,590
now we have kilometers and it looks

00:07:27,760 --> 00:07:34,150
exactly the same of course if you have

00:07:32,590 --> 00:07:39,250
an object-oriented background you may

00:07:34,150 --> 00:07:41,020
feel the urge to use inheritance so we

00:07:39,250 --> 00:07:43,840
could define an abstract class or trait

00:07:41,020 --> 00:07:48,090
that these two types inherit from and if

00:07:43,840 --> 00:07:51,190
we do that it could look like this so

00:07:48,090 --> 00:07:53,860
the quantity trait has a few implemented

00:07:51,190 --> 00:07:56,560
operators and to abstract functions

00:07:53,860 --> 00:07:58,150
which is the value function to get the

00:07:56,560 --> 00:08:01,870
actual value of the quantity out of it

00:07:58,150 --> 00:08:04,240
and the unit function for wrapping a

00:08:01,870 --> 00:08:09,970
value a number value again in this

00:08:04,240 --> 00:08:14,010
quantity type and the sum and the mean

00:08:09,970 --> 00:08:17,920
functions they can use these operators

00:08:14,010 --> 00:08:20,530
and then we can extend that trade and

00:08:17,920 --> 00:08:24,750
here we have our kilograms and our

00:08:20,530 --> 00:08:27,610
kilometers classes that's not too bad

00:08:24,750 --> 00:08:29,920
but what happens if you want to reuse

00:08:27,610 --> 00:08:33,390
our sum and mean functions or whatever

00:08:29,920 --> 00:08:38,290
else we might implement on some type

00:08:33,390 --> 00:08:42,460
that can't extend from quantity for

00:08:38,290 --> 00:08:45,070
example for joda-time duration obviously

00:08:42,460 --> 00:08:48,480
we can't make it a subclass but we can

00:08:45,070 --> 00:08:48,480
use the adapter pattern hooray

00:08:48,650 --> 00:08:54,830
so here's an adapter milliseconds which

00:08:51,589 --> 00:08:58,960
has an underlying duration that it has

00:08:54,830 --> 00:09:02,360
to wrap and then just like the other

00:08:58,960 --> 00:09:07,839
quantity subtypes it overrides or

00:09:02,360 --> 00:09:07,839
implements the value and the unit method

00:09:08,170 --> 00:09:13,910
so this allows us to reuse the existing

00:09:11,029 --> 00:09:19,100
sum and mean functions for the other

00:09:13,910 --> 00:09:21,200
times duration time this works but

00:09:19,100 --> 00:09:24,500
wrapping all of our durations in an

00:09:21,200 --> 00:09:28,910
adapter is kind of annoying we have a

00:09:24,500 --> 00:09:33,620
lot of new objects here and a bit of

00:09:28,910 --> 00:09:35,060
boilerplate is involved as well and of

00:09:33,620 --> 00:09:37,339
course we're losing the original type

00:09:35,060 --> 00:09:39,589
that Eurasian because of milliseconds is

00:09:37,339 --> 00:09:40,250
not a duration it's just containing a

00:09:39,589 --> 00:09:42,529
new agent

00:09:40,250 --> 00:09:46,970
and if we need to work on duration again

00:09:42,529 --> 00:09:50,120
we have first need to unwrap it again so

00:09:46,970 --> 00:09:52,540
let's do what the doc says and try a

00:09:50,120 --> 00:09:52,540
different approach

00:09:52,839 --> 00:09:58,600
now kilograms and kilometers do not

00:09:55,880 --> 00:10:01,760
inherit from a common supertype anymore

00:09:58,600 --> 00:10:05,270
quantity is the trade some simple type

00:10:01,760 --> 00:10:07,640
parameter a and a few functions for

00:10:05,270 --> 00:10:11,480
example instead of the plus operator we

00:10:07,640 --> 00:10:15,800
now have the plus function that gets two

00:10:11,480 --> 00:10:19,760
arguments X and y of a and it will sum

00:10:15,800 --> 00:10:21,740
these we also have this zero function

00:10:19,760 --> 00:10:27,620
which is now defined in the quantity

00:10:21,740 --> 00:10:29,900
trade and that's it basically

00:10:27,620 --> 00:10:33,410
so quantity is meant to be stateless and

00:10:29,900 --> 00:10:35,330
it just contains these functions which

00:10:33,410 --> 00:10:40,390
we always have to implement for every

00:10:35,330 --> 00:10:43,370
type that can behave like a quantity and

00:10:40,390 --> 00:10:46,700
in the quantity companion object we can

00:10:43,370 --> 00:10:49,270
now create instances for each type that

00:10:46,700 --> 00:10:53,060
we want to treat as a quantity and

00:10:49,270 --> 00:10:58,190
that's done by creating and creating an

00:10:53,060 --> 00:11:00,890
anonymous class new quantity kilograms

00:10:58,190 --> 00:11:01,889
new quantity kilometers and implementing

00:11:00,890 --> 00:11:05,779
these

00:11:01,889 --> 00:11:09,540
two methods doesn't look like something

00:11:05,779 --> 00:11:15,749
arcane but it's almost the type class

00:11:09,540 --> 00:11:18,509
pattern and for duration we can do the

00:11:15,749 --> 00:11:20,429
same but here we are actually overriding

00:11:18,509 --> 00:11:22,919
some of the already implemented methods

00:11:20,429 --> 00:11:24,449
from quantity because there is already

00:11:22,919 --> 00:11:29,549
something in duration we can use

00:11:24,449 --> 00:11:35,100
directly so we don't need to use those

00:11:29,549 --> 00:11:38,730
default implementations and now our sum

00:11:35,100 --> 00:11:40,410
and mean functions look like this they

00:11:38,730 --> 00:11:42,720
don't only take this distributed data

00:11:40,410 --> 00:11:47,549
set but an additional argument which is

00:11:42,720 --> 00:11:51,869
the quantity of a and sum and mean also

00:11:47,549 --> 00:11:54,119
have the type parameter a so they can

00:11:51,869 --> 00:11:59,009
operate on any type a for which we can

00:11:54,119 --> 00:12:01,489
provide a corresponding quantity of a as

00:11:59,009 --> 00:12:04,319
an example if we do that with duration

00:12:01,489 --> 00:12:06,929
we can just create this data set and

00:12:04,319 --> 00:12:09,089
then we pass this duration quantity that

00:12:06,929 --> 00:12:14,759
we have defined in our quantity

00:12:09,089 --> 00:12:17,459
companion object into our min fund now

00:12:14,759 --> 00:12:21,360
let's change the signatures of our two

00:12:17,459 --> 00:12:22,439
functions a bit because Karla allows you

00:12:21,360 --> 00:12:26,910
to define functions with multiple

00:12:22,439 --> 00:12:29,009
parameter lists so instead of having the

00:12:26,910 --> 00:12:32,249
quantity a and the same parameter list

00:12:29,009 --> 00:12:34,439
as our distributed data set we can have

00:12:32,249 --> 00:12:38,279
it in a separate parameter list which

00:12:34,439 --> 00:12:40,759
looks like this so this is not a huge

00:12:38,279 --> 00:12:40,759
difference

00:12:42,330 --> 00:12:47,070
and if we do that that's also only a

00:12:45,300 --> 00:12:50,840
very small change in how we would call

00:12:47,070 --> 00:12:53,610
the mean function just like this okay

00:12:50,840 --> 00:12:55,380
now the interesting thing comes because

00:12:53,610 --> 00:13:01,800
you can declare the last parameter list

00:12:55,380 --> 00:13:04,260
as implicit which we do here and we can

00:13:01,800 --> 00:13:08,930
also declare any values that we define

00:13:04,260 --> 00:13:10,740
as implicit so now our three quantity

00:13:08,930 --> 00:13:13,350
instances for kilograms

00:13:10,740 --> 00:13:19,890
kilometers duration they are now all

00:13:13,350 --> 00:13:22,650
implicit vows now if we have an implicit

00:13:19,890 --> 00:13:24,930
parameter list we can still pass in any

00:13:22,650 --> 00:13:27,330
values explicitly like we have done

00:13:24,930 --> 00:13:31,250
before so this looks exactly like what

00:13:27,330 --> 00:13:33,450
we had before but if we don't do that

00:13:31,250 --> 00:13:36,570
the Scala compiler will look for

00:13:33,450 --> 00:13:38,700
matching implicit values and since we

00:13:36,570 --> 00:13:41,790
marked our quantity implementations as

00:13:38,700 --> 00:13:45,270
implicit in the companion object they

00:13:41,790 --> 00:13:47,370
will be picked up by the compiler and

00:13:45,270 --> 00:13:51,060
this is how we slowly approach the type

00:13:47,370 --> 00:13:53,670
class pattern so this allows us to write

00:13:51,060 --> 00:13:55,440
completely generic functions for any

00:13:53,670 --> 00:13:59,610
type a for which there is a quantity

00:13:55,440 --> 00:14:01,880
instance and we can provide new quantity

00:13:59,610 --> 00:14:05,040
implementations for arbitrary types and

00:14:01,880 --> 00:14:08,670
even for types that we cannot change

00:14:05,040 --> 00:14:10,830
like solar time duration and we can do

00:14:08,670 --> 00:14:14,130
that without having to recompile those

00:14:10,830 --> 00:14:17,100
types or our generic functions and we

00:14:14,130 --> 00:14:20,850
don't lose any precision about our types

00:14:17,100 --> 00:14:27,450
because we don't have to use traditional

00:14:20,850 --> 00:14:30,870
adapters anymore okay

00:14:27,450 --> 00:14:35,100
unfortunately implicit parameter lists

00:14:30,870 --> 00:14:37,170
can sometimes be a bit hard to read and

00:14:35,100 --> 00:14:39,810
can lead to very bloated function

00:14:37,170 --> 00:14:43,950
signatures so there's an alternative

00:14:39,810 --> 00:14:45,090
syntax which is called context bounds so

00:14:43,950 --> 00:14:48,870
now we don't have this implicit

00:14:45,090 --> 00:14:52,740
parameter list anymore but we say that

00:14:48,870 --> 00:14:54,730
some or mean expect an a for which there

00:14:52,740 --> 00:14:57,010
is a quantity context bound

00:14:54,730 --> 00:15:00,399
but semantically this is exactly the

00:14:57,010 --> 00:15:03,699
same the difference is that now inside

00:15:00,399 --> 00:15:06,490
of our mean our sum function we can't

00:15:03,699 --> 00:15:11,170
access this implicit parameter anymore

00:15:06,490 --> 00:15:12,730
by name because it's not there so we

00:15:11,170 --> 00:15:15,940
have to summon it from the netherworld

00:15:12,730 --> 00:15:18,850
that's what the Scarlet source code says

00:15:15,940 --> 00:15:23,050
about the implicitly method so by

00:15:18,850 --> 00:15:25,420
calling implicitly quantity a we get the

00:15:23,050 --> 00:15:27,430
implicit value for which we have proof

00:15:25,420 --> 00:15:31,899
that it exists because of this context

00:15:27,430 --> 00:15:34,690
bound so in a way we are buying less

00:15:31,899 --> 00:15:40,360
clutter in our function signatures with

00:15:34,690 --> 00:15:43,120
a bit more and their implementations you

00:15:40,360 --> 00:15:47,910
may wonder how the Scala compiler finds

00:15:43,120 --> 00:15:50,199
the implicit values that it needs I'm

00:15:47,910 --> 00:15:52,449
going to keep this short because I was

00:15:50,199 --> 00:15:56,339
an entire talk about implicit and

00:15:52,449 --> 00:15:59,079
implicit resolution in the previous slot

00:15:56,339 --> 00:16:01,000
so the first thing that you can do of

00:15:59,079 --> 00:16:03,579
course is pass in values explicitly

00:16:01,000 --> 00:16:06,760
which we have already seen but if you

00:16:03,579 --> 00:16:09,010
don't do that the first thing the Scala

00:16:06,760 --> 00:16:11,980
compiler will do we look for locally

00:16:09,010 --> 00:16:14,769
defined implicit values if there's none

00:16:11,980 --> 00:16:17,949
and we'll search for important implicit

00:16:14,769 --> 00:16:21,160
values that match the type then inherit

00:16:17,949 --> 00:16:23,940
it once and then in the package object

00:16:21,160 --> 00:16:26,470
and if there's still nothing to be found

00:16:23,940 --> 00:16:30,459
it will look into the implicit scope

00:16:26,470 --> 00:16:33,339
which means into the companion object of

00:16:30,459 --> 00:16:36,459
the type class in our case let's say

00:16:33,339 --> 00:16:38,230
we're looking for a quantity of

00:16:36,459 --> 00:16:40,990
kilograms so it would look in the

00:16:38,230 --> 00:16:46,230
quantity type class and it will also

00:16:40,990 --> 00:16:50,260
look in kilograms companion object and

00:16:46,230 --> 00:16:53,170
if kilograms or quantity have some super

00:16:50,260 --> 00:16:56,829
types the companion objects of those

00:16:53,170 --> 00:17:00,490
will also be considered in code and

00:16:56,829 --> 00:17:02,769
looks like this a local implicit we've

00:17:00,490 --> 00:17:06,800
defined it here so this is the first

00:17:02,769 --> 00:17:09,439
thing the Scala compiler would use so

00:17:06,800 --> 00:17:14,780
the implicit that we have defined here

00:17:09,439 --> 00:17:17,900
is a one that's used down there if we

00:17:14,780 --> 00:17:20,959
don't do that let's say we want to do

00:17:17,900 --> 00:17:23,300
imported implicit first we define a

00:17:20,959 --> 00:17:26,329
trade here which contains our implicit

00:17:23,300 --> 00:17:32,300
and then we have an object that extends

00:17:26,329 --> 00:17:34,010
our trade and now we are imported making

00:17:32,300 --> 00:17:36,890
a wild card import of this implicit

00:17:34,010 --> 00:17:40,160
object so this implicit value that's

00:17:36,890 --> 00:17:46,790
defined in there will be used down there

00:17:40,160 --> 00:17:49,040
in the call to the mean function if

00:17:46,790 --> 00:17:53,120
nothing imported can be found that

00:17:49,040 --> 00:17:56,929
matches our types then inherited

00:17:53,120 --> 00:17:59,410
emphasis will be searched so we are

00:17:56,929 --> 00:18:02,870
extending this trade that we already saw

00:17:59,410 --> 00:18:09,530
and by doing so that implicit value will

00:18:02,870 --> 00:18:12,650
be used down there okay we have this

00:18:09,530 --> 00:18:15,800
order in which implicit get searched by

00:18:12,650 --> 00:18:18,260
the compiler and this means that you can

00:18:15,800 --> 00:18:22,940
also override an implicit value that is

00:18:18,260 --> 00:18:26,360
already defined further down the line so

00:18:22,940 --> 00:18:29,000
let's say here we are extending this

00:18:26,360 --> 00:18:32,690
trade that has an implicit quantity of

00:18:29,000 --> 00:18:36,530
duration but we also have an locally

00:18:32,690 --> 00:18:37,010
defined quantity of duration that's not

00:18:36,530 --> 00:18:40,160
a problem

00:18:37,010 --> 00:18:42,890
so the locally defined one will be used

00:18:40,160 --> 00:18:47,300
because this one will be searched before

00:18:42,890 --> 00:18:49,730
the other one of course it can also

00:18:47,300 --> 00:18:52,490
happen that the compiler will not find

00:18:49,730 --> 00:18:54,679
any matching implicit value of the type

00:18:52,490 --> 00:18:58,550
that is needed and then you will get a

00:18:54,679 --> 00:19:02,030
compile time error the same will happen

00:18:58,550 --> 00:19:05,300
if it finds to emphases of the same type

00:19:02,030 --> 00:19:09,050
that have the same specificity so if I

00:19:05,300 --> 00:19:11,600
have to locally defined values of the

00:19:09,050 --> 00:19:14,390
same type to implicit that would be a

00:19:11,600 --> 00:19:18,410
compile time error complaining about

00:19:14,390 --> 00:19:21,470
ambiguous implicit and the same would

00:19:18,410 --> 00:19:25,550
happen if you have an instant if

00:19:21,470 --> 00:19:27,440
in the quantity companion object let's

00:19:25,550 --> 00:19:30,530
say we're talking about quantity of

00:19:27,440 --> 00:19:34,190
kilograms now and also in the kilograms

00:19:30,530 --> 00:19:40,220
companion object so then these cannot be

00:19:34,190 --> 00:19:43,340
resolved now if you are a library author

00:19:40,220 --> 00:19:45,140
and write your own type class you can

00:19:43,340 --> 00:19:47,480
provide default instances of your type

00:19:45,140 --> 00:19:49,280
class for certain types and the best way

00:19:47,480 --> 00:19:51,950
of doing that is in your companion

00:19:49,280 --> 00:19:54,230
object of your type class because this

00:19:51,950 --> 00:19:55,580
way they are in the implicit scope and

00:19:54,230 --> 00:20:02,440
we don't have to do any additional

00:19:55,580 --> 00:20:04,430
imports to get those defaults sometimes

00:20:02,440 --> 00:20:06,020
calling the functions that we have to

00:20:04,430 --> 00:20:08,810
find on a type class can be a bit

00:20:06,020 --> 00:20:11,510
cumbersome and that's the case in our

00:20:08,810 --> 00:20:13,100
quantity example because in when we were

00:20:11,510 --> 00:20:17,090
still using inheritance we have these

00:20:13,100 --> 00:20:21,230
nice operators plus minus and so on or

00:20:17,090 --> 00:20:24,110
we can still get those using an implicit

00:20:21,230 --> 00:20:26,920
class which we have defined here in the

00:20:24,110 --> 00:20:31,780
package object and this implicit class

00:20:26,920 --> 00:20:35,000
takes in first parameter list and a and

00:20:31,780 --> 00:20:36,830
then there's a second parameter list so

00:20:35,000 --> 00:20:39,260
we expect that to be an implicit

00:20:36,830 --> 00:20:42,530
quantity of a and only if that is

00:20:39,260 --> 00:20:47,090
available then this implicit class will

00:20:42,530 --> 00:20:51,230
provide us these nice operators so by

00:20:47,090 --> 00:20:54,440
importing this thing we can make use of

00:20:51,230 --> 00:20:56,180
these nice operators so this is a common

00:20:54,440 --> 00:20:58,640
pattern for type classes that you

00:20:56,180 --> 00:21:01,310
additionally want to provide some

00:20:58,640 --> 00:21:07,370
operators on the types of which the type

00:21:01,310 --> 00:21:09,470
class is available ok so now we've

00:21:07,370 --> 00:21:13,100
covered the basics about type classes

00:21:09,470 --> 00:21:15,940
and I would like to address topics that

00:21:13,100 --> 00:21:18,830
I find rather important that this

00:21:15,940 --> 00:21:25,070
program my usability with regard to type

00:21:18,830 --> 00:21:27,830
classes I think most of you will not

00:21:25,070 --> 00:21:31,880
actually write any new type classes most

00:21:27,830 --> 00:21:33,200
of the time but the aspects I'm talking

00:21:31,880 --> 00:21:34,909
about there will not only help you

00:21:33,200 --> 00:21:37,849
design better type class

00:21:34,909 --> 00:21:40,269
but they should also help implementing

00:21:37,849 --> 00:21:42,470
instances of of existing type classes

00:21:40,269 --> 00:21:44,359
because you will know what to look for

00:21:42,470 --> 00:21:46,609
in those existing type classes that can

00:21:44,359 --> 00:21:48,559
make your life easier and you'll gain a

00:21:46,609 --> 00:21:51,950
better understanding for why things

00:21:48,559 --> 00:21:55,070
often work magically out of the box or

00:21:51,950 --> 00:21:59,359
why they work but not as you expect or

00:21:55,070 --> 00:22:03,679
why they why they don't okay error

00:21:59,359 --> 00:22:07,190
messages so the default error message

00:22:03,679 --> 00:22:09,859
have no implicit value can be found can

00:22:07,190 --> 00:22:13,429
be a bit confusing sometimes or at least

00:22:09,859 --> 00:22:17,570
not very helpful and if you can provide

00:22:13,429 --> 00:22:20,119
a more helpful error message you can do

00:22:17,570 --> 00:22:24,109
so by using this implicit not found

00:22:20,119 --> 00:22:26,570
annotation on your type class trade a

00:22:24,109 --> 00:22:29,899
good use case for that is if you know

00:22:26,570 --> 00:22:32,840
about some common error cases and can

00:22:29,899 --> 00:22:36,889
provide hints to the developer for why

00:22:32,840 --> 00:22:38,359
the simplest it might be missing in

00:22:36,889 --> 00:22:40,159
scala 2.12

00:22:38,359 --> 00:22:42,979
there will also be an implicit ambiguous

00:22:40,159 --> 00:22:47,080
annotation so that you can customize the

00:22:42,979 --> 00:22:54,970
error message if the Scala compiler

00:22:47,080 --> 00:23:00,169
cannot decide which implicit to use okay

00:22:54,970 --> 00:23:03,169
another usability aspect is that if we

00:23:00,169 --> 00:23:04,729
use the context bound syntax I already

00:23:03,169 --> 00:23:06,700
said that we are increasing the clutter

00:23:04,729 --> 00:23:08,690
in the implementations of our functions

00:23:06,700 --> 00:23:15,169
because we always have to call

00:23:08,690 --> 00:23:17,359
implicitly of quantity of a and let's of

00:23:15,169 --> 00:23:19,940
course far too much to write for any

00:23:17,359 --> 00:23:22,759
development so it's common practice to

00:23:19,940 --> 00:23:26,019
provide an apply method in the cone and

00:23:22,759 --> 00:23:30,080
the companion object of your type class

00:23:26,019 --> 00:23:33,349
and this apply method would expect an

00:23:30,080 --> 00:23:38,179
implicit quantity in this case and just

00:23:33,349 --> 00:23:40,450
return that quantity it looks a bit

00:23:38,179 --> 00:23:43,330
weird but this allows us to just write

00:23:40,450 --> 00:23:46,789
instead of implicitly quantity a

00:23:43,330 --> 00:23:52,190
quantity a here

00:23:46,789 --> 00:23:55,639
and there so we can get rid of some of

00:23:52,190 --> 00:24:00,139
the boilerplate of context bounds in our

00:23:55,639 --> 00:24:02,119
function implementations so if you are

00:24:00,139 --> 00:24:06,320
using context bonds with some existing

00:24:02,119 --> 00:24:08,719
type class I would suggest you find out

00:24:06,320 --> 00:24:10,909
if this apply and the companion object

00:24:08,719 --> 00:24:13,539
is defined and if you write your own

00:24:10,909 --> 00:24:21,759
type classes it's definitely a good idea

00:24:13,539 --> 00:24:24,769
to add this to the companion object okay

00:24:21,759 --> 00:24:28,639
now the quantity implementations for

00:24:24,769 --> 00:24:32,269
kilograms and kilometers and uation

00:24:28,639 --> 00:24:36,289
they were actually a lot of code to

00:24:32,269 --> 00:24:39,259
write which looked very similar most of

00:24:36,289 --> 00:24:40,579
the time and it's hard to see the

00:24:39,259 --> 00:24:45,559
important things when there's so much

00:24:40,579 --> 00:24:48,940
noise so that's why many type classes

00:24:45,559 --> 00:24:52,459
provide one or more constructors which

00:24:48,940 --> 00:24:55,609
allow you to implement instances of

00:24:52,459 --> 00:24:59,299
these type classes with hardly any

00:24:55,609 --> 00:25:02,299
boilerplate and here's an example of

00:24:59,299 --> 00:25:05,449
that for our quantity type class we have

00:25:02,299 --> 00:25:09,289
this function called simple in our

00:25:05,449 --> 00:25:13,699
companion object and this has two

00:25:09,289 --> 00:25:16,579
parameter lists in the first one we

00:25:13,699 --> 00:25:20,209
expect a function which we will use to

00:25:16,579 --> 00:25:22,759
implement the unit's method of quantity

00:25:20,209 --> 00:25:26,059
and in the second we expect another

00:25:22,759 --> 00:25:30,440
function which we will use to implement

00:25:26,059 --> 00:25:32,359
the value method and we are using two

00:25:30,440 --> 00:25:34,729
parameter lists here to help with type

00:25:32,359 --> 00:25:36,319
inference well that's a detail which is

00:25:34,729 --> 00:25:39,649
not very important to understand type

00:25:36,319 --> 00:25:43,159
classes what's important is that we can

00:25:39,649 --> 00:25:48,249
now implement our kilogram and kilometer

00:25:43,159 --> 00:25:48,249
quantity in a single line of code

00:25:49,869 --> 00:25:55,459
another example that makes use of this

00:25:52,669 --> 00:25:58,459
mechanism of providing constructors is

00:25:55,459 --> 00:26:01,409
the ordering type class which you can

00:25:58,459 --> 00:26:04,419
find in the Scala standard library

00:26:01,409 --> 00:26:08,019
it's used for shorting collections or

00:26:04,419 --> 00:26:10,769
finding their minimum or maximum and as

00:26:08,019 --> 00:26:13,349
you can see here there are some nice

00:26:10,769 --> 00:26:17,469
constructors like by or from less than

00:26:13,349 --> 00:26:20,769
which also help you to implement this

00:26:17,469 --> 00:26:23,729
thing in a single line instead of having

00:26:20,769 --> 00:26:27,039
to write new ordering blahblahblah and

00:26:23,729 --> 00:26:31,179
you will find constructors like these in

00:26:27,039 --> 00:26:33,069
many well designed type classes and

00:26:31,179 --> 00:26:36,309
typically they expect a single function

00:26:33,069 --> 00:26:40,239
or two which they use to implement their

00:26:36,309 --> 00:26:42,039
abstract methods and so I recommend that

00:26:40,239 --> 00:26:44,619
if you have to implement some type class

00:26:42,039 --> 00:26:46,479
instance you first look at there are

00:26:44,619 --> 00:26:49,959
some nice constructors available in the

00:26:46,479 --> 00:26:53,559
companion object instead of writing them

00:26:49,959 --> 00:26:55,089
from scratch and of course the same

00:26:53,559 --> 00:26:57,309
applies if you implement a new type

00:26:55,089 --> 00:27:00,279
class yourself it's always very helpful

00:26:57,309 --> 00:27:09,279
for others to have these constructors

00:27:00,279 --> 00:27:15,399
available the question was if it's

00:27:09,279 --> 00:27:19,599
crucial to make them lazy I would say

00:27:15,399 --> 00:27:23,199
that depends on the use case there are

00:27:19,599 --> 00:27:26,469
some dependencies between type classes

00:27:23,199 --> 00:27:35,799
that might be necessary but in this case

00:27:26,469 --> 00:27:38,919
actually that's not the case okay that

00:27:35,799 --> 00:27:42,939
was constructors and another thing that

00:27:38,919 --> 00:27:45,639
can help make people's life a lot easier

00:27:42,939 --> 00:27:48,669
it's Combinator's so apart from simple

00:27:45,639 --> 00:27:50,769
constructors a lot of well-designed type

00:27:48,669 --> 00:27:54,119
classes often provide some Combinator's

00:27:50,769 --> 00:27:56,799
or transformation operations that means

00:27:54,119 --> 00:27:59,049
that you again you don't have to write

00:27:56,799 --> 00:28:01,869
your type class instance from scratch

00:27:59,049 --> 00:28:06,309
anymore but you can reuse and already

00:28:01,869 --> 00:28:11,079
existing instance and derive another

00:28:06,309 --> 00:28:13,479
instance from that so again you would

00:28:11,079 --> 00:28:14,980
use boilerplate and at the same time you

00:28:13,479 --> 00:28:16,679
also can rely on the

00:28:14,980 --> 00:28:23,559
correctness of the already existing

00:28:16,679 --> 00:28:27,010
instances as an example now I'm moving

00:28:23,559 --> 00:28:29,679
away from the quantity type class I'm

00:28:27,010 --> 00:28:34,000
using the Searcy library by Travis Brown

00:28:29,679 --> 00:28:36,760
which has a type class encoder which can

00:28:34,000 --> 00:28:44,049
transform from any arbitrary type to

00:28:36,760 --> 00:28:46,029
Circe's Jason ast and the idea of the

00:28:44,049 --> 00:28:52,149
Contra map Combinator that you are

00:28:46,029 --> 00:28:55,179
seeing here is that in our example if I

00:28:52,149 --> 00:28:57,610
know how to encode an into Jason which

00:28:55,179 --> 00:29:00,250
is pretty clear how to do that then I

00:28:57,610 --> 00:29:02,679
can also encode something for which I

00:29:00,250 --> 00:29:08,409
know how to incur a transform it to an

00:29:02,679 --> 00:29:11,049
end and in this case first we're

00:29:08,409 --> 00:29:13,600
actually using this nice apply method of

00:29:11,049 --> 00:29:16,720
the companion object to get the implicit

00:29:13,600 --> 00:29:19,620
encoder for end and then contra map

00:29:16,720 --> 00:29:23,409
expects and function from book ID to end

00:29:19,620 --> 00:29:27,070
which is implemented by just calling dot

00:29:23,409 --> 00:29:29,850
value on our book ID so we can do this

00:29:27,070 --> 00:29:34,389
instead of writing our whole book ID

00:29:29,850 --> 00:29:37,480
encoder instance from scratch and again

00:29:34,389 --> 00:29:44,440
you will find that most other type

00:29:37,480 --> 00:29:49,000
classes have Combinator's like these ok

00:29:44,440 --> 00:29:53,139
so now that we know how to derive a type

00:29:49,000 --> 00:29:58,350
class from another one let's move to

00:29:53,139 --> 00:30:01,260
generic type class instances so

00:29:58,350 --> 00:30:04,600
providing this whole machinery of

00:30:01,260 --> 00:30:07,659
instances for generic types like list or

00:30:04,600 --> 00:30:10,539
option is actually an important factor

00:30:07,659 --> 00:30:13,149
in minimizing a boilerplate when using

00:30:10,539 --> 00:30:15,190
type classes and to illustrate this

00:30:13,149 --> 00:30:19,240
let's look at the saucy encoder type

00:30:15,190 --> 00:30:22,169
class again so now the idea is that if

00:30:19,240 --> 00:30:24,929
you know how to encode an A to Jason

00:30:22,169 --> 00:30:27,920
because we have an implicit encoder of a

00:30:24,929 --> 00:30:34,840
then we can also know how to encode an

00:30:27,920 --> 00:30:37,280
son of a or a list of a to Jason and now

00:30:34,840 --> 00:30:39,340
providing something like that can't be

00:30:37,280 --> 00:30:42,050
done with an implicit Val anymore

00:30:39,340 --> 00:30:45,500
because we depend on the fact that there

00:30:42,050 --> 00:30:48,190
is already an implicit encoder of a so

00:30:45,500 --> 00:30:50,720
now we have to use an implicit death

00:30:48,190 --> 00:30:53,690
which has this implicit parameter list

00:30:50,720 --> 00:30:58,640
and the result is an encoder of option

00:30:53,690 --> 00:31:00,680
of a an implicit encoder so if we have

00:30:58,640 --> 00:31:02,570
an implicit encoder of int we can have

00:31:00,680 --> 00:31:04,460
an implicit encode of option of int for

00:31:02,570 --> 00:31:08,480
free you don't have to do anything for

00:31:04,460 --> 00:31:10,760
that and if that option is none it will

00:31:08,480 --> 00:31:13,220
just use the jason no value and

00:31:10,760 --> 00:31:20,240
otherwise it will delegate to this

00:31:13,220 --> 00:31:23,570
implicit encoder of a so this technique

00:31:20,240 --> 00:31:26,200
is used in many type classes let's do

00:31:23,570 --> 00:31:28,580
something with serialization or encoding

00:31:26,200 --> 00:31:31,190
but actually you will also find that in

00:31:28,580 --> 00:31:34,610
the ordering type class has also an

00:31:31,190 --> 00:31:39,110
implicit ordering for option of a define

00:31:34,610 --> 00:31:42,050
in a similar way and in that case and

00:31:39,110 --> 00:31:48,200
none is always considered to be smaller

00:31:42,050 --> 00:31:52,610
than some value some people actually

00:31:48,200 --> 00:31:56,540
want to go even further so instead of

00:31:52,610 --> 00:32:01,640
just deriving generic instances of our

00:31:56,540 --> 00:32:04,310
type class they want to derive an

00:32:01,640 --> 00:32:08,300
instance of true of a provided that

00:32:04,310 --> 00:32:12,230
there is already a bar of a type class

00:32:08,300 --> 00:32:14,870
instance an example of that can be found

00:32:12,230 --> 00:32:19,100
in high cosy beggars library acha HTTP

00:32:14,870 --> 00:32:21,500
Jason which makes it quite easy to plug

00:32:19,100 --> 00:32:25,610
in any type class-based jason library

00:32:21,500 --> 00:32:28,280
into ArcheAge TTP and the way that this

00:32:25,610 --> 00:32:30,920
works is that if you're not with

00:32:28,280 --> 00:32:33,520
familiar with akka HTTP it defines a

00:32:30,920 --> 00:32:36,290
type class called to entity mashallah

00:32:33,520 --> 00:32:40,100
which can convert from arbitrary scala

00:32:36,290 --> 00:32:41,960
types to HTTP request or response bodies

00:32:40,100 --> 00:32:44,600
and there's also a

00:32:41,960 --> 00:32:48,649
- response masla that can convert from

00:32:44,600 --> 00:32:53,149
some arbitrary type to a complete HTTP

00:32:48,649 --> 00:32:56,210
response and HTTP comes with tons of

00:32:53,149 --> 00:33:00,559
default instances for these type classes

00:32:56,210 --> 00:33:04,789
and one of them is for Strings and this

00:33:00,559 --> 00:33:08,090
allows us to have an automatically

00:33:04,789 --> 00:33:09,830
derived two entity modular for any type

00:33:08,090 --> 00:33:16,159
for which we already have a cersei

00:33:09,830 --> 00:33:18,549
encoder it's implemented like this the

00:33:16,159 --> 00:33:22,159
technique is really the same as deriving

00:33:18,549 --> 00:33:24,860
generic type class instances we have to

00:33:22,159 --> 00:33:26,210
use this implicit death again and we

00:33:24,860 --> 00:33:30,649
require that there is an implicit

00:33:26,210 --> 00:33:34,249
encoder of a and then we can

00:33:30,649 --> 00:33:37,610
automatically derive a two entity masla

00:33:34,249 --> 00:33:41,389
of a by reusing the existing string

00:33:37,610 --> 00:33:42,279
Marshall and composing that with this

00:33:41,389 --> 00:33:45,049
encoder

00:33:42,279 --> 00:33:46,690
so here you can also see that acha HTTP

00:33:45,049 --> 00:33:50,389
has a lot of

00:33:46,690 --> 00:33:55,159
combinators on the two modular type

00:33:50,389 --> 00:33:59,139
class so now that we have this trade we

00:33:55,159 --> 00:34:02,929
can just mix it in into our routes and

00:33:59,139 --> 00:34:06,490
then we don't have to deal with any kind

00:34:02,929 --> 00:34:10,520
of wiring code at all to be able to

00:34:06,490 --> 00:34:15,530
serialize our domain objects to jason or

00:34:10,520 --> 00:34:18,319
to HTTP responses so we can just return

00:34:15,530 --> 00:34:20,839
the result of this lookup in the

00:34:18,319 --> 00:34:24,770
repository and it will magically create

00:34:20,839 --> 00:34:27,710
an HTTP response with a serialize jason

00:34:24,770 --> 00:34:31,429
using this cersei encoder that we have

00:34:27,710 --> 00:34:34,940
defined this technique is very powerful

00:34:31,429 --> 00:34:37,960
but I find that it also sometimes can

00:34:34,940 --> 00:34:37,960
confuse people a lot

00:34:39,099 --> 00:34:49,119
another topping is default instances so

00:34:45,139 --> 00:34:51,319
if there is the case that you have

00:34:49,119 --> 00:34:55,220
default instances that you can provide

00:34:51,319 --> 00:34:55,909
for certain types then and they make

00:34:55,220 --> 00:34:58,280
sense most

00:34:55,909 --> 00:35:02,140
the time then by all means do that for

00:34:58,280 --> 00:35:05,839
example in searcy there are defaults

00:35:02,140 --> 00:35:09,740
that automatically know how to convert

00:35:05,839 --> 00:35:10,160
string to adjacent string or in Scala

00:35:09,740 --> 00:35:14,150
IND

00:35:10,160 --> 00:35:17,660
or long to adjacent number and of course

00:35:14,150 --> 00:35:21,950
also these generic things like option of

00:35:17,660 --> 00:35:25,760
a to Jason now if it's none and stuff

00:35:21,950 --> 00:35:27,859
like that so this works because this

00:35:25,760 --> 00:35:30,589
mapping from Scala types to jason types

00:35:27,859 --> 00:35:36,440
is well specified and there's not much

00:35:30,589 --> 00:35:39,049
room for interpretation sometimes you

00:35:36,440 --> 00:35:40,880
actually want to be able to opt out of

00:35:39,049 --> 00:35:45,520
default instances because you don't like

00:35:40,880 --> 00:35:47,839
them so to make that easier for people

00:35:45,520 --> 00:35:50,990
it's really important to define your

00:35:47,839 --> 00:35:54,200
defaults in the companion object of your

00:35:50,990 --> 00:35:56,510
type class and that you don't force them

00:35:54,200 --> 00:36:01,910
to import something because the import

00:35:56,510 --> 00:36:03,920
is actually pretty high in this in this

00:36:01,910 --> 00:36:07,160
list where the Scala compiler first

00:36:03,920 --> 00:36:09,880
looks locally than it imports so if you

00:36:07,160 --> 00:36:12,559
have it in a companion object then

00:36:09,880 --> 00:36:21,140
people can always override your defaults

00:36:12,559 --> 00:36:24,319
with something else okay but it's just

00:36:21,140 --> 00:36:26,539
as important that you don't provide

00:36:24,319 --> 00:36:30,250
default instances whose behavior might

00:36:26,539 --> 00:36:34,970
often be undesired an example of that is

00:36:30,250 --> 00:36:37,279
P type H of any ref I don't know if

00:36:34,970 --> 00:36:41,299
anyone has seen that I will not mention

00:36:37,279 --> 00:36:43,579
the library but the fact is that this p

00:36:41,299 --> 00:36:47,029
type age of any ref is defined in the

00:36:43,579 --> 00:36:50,140
companion object of P type and it may

00:36:47,029 --> 00:36:52,940
fail or it may not fail at runtime and

00:36:50,140 --> 00:36:55,849
of course that's not a good idea as a

00:36:52,940 --> 00:36:57,319
user of this library you will simply not

00:36:55,849 --> 00:36:59,809
notice that compile time that you should

00:36:57,319 --> 00:37:02,569
have provided your own more specific

00:36:59,809 --> 00:37:05,089
instance of P type age Peter page is

00:37:02,569 --> 00:37:07,510
about serialization by the way so it

00:37:05,089 --> 00:37:09,349
knows how to serialize and deserialize

00:37:07,510 --> 00:37:12,190
this thing

00:37:09,349 --> 00:37:14,479
and if you have this default for any

00:37:12,190 --> 00:37:18,650
relatives be picked up if you don't have

00:37:14,479 --> 00:37:24,559
anything more specific another example

00:37:18,650 --> 00:37:26,599
of that is a chi chi teepee again so

00:37:24,559 --> 00:37:28,969
here we have a lot of type classes with

00:37:26,599 --> 00:37:30,799
default instances for example you have a

00:37:28,969 --> 00:37:35,329
default value of a type class called

00:37:30,799 --> 00:37:38,650
empty value for HTTP response and then

00:37:35,329 --> 00:37:43,069
we have this generic default modular for

00:37:38,650 --> 00:37:48,380
option of A to B and the result of this

00:37:43,069 --> 00:37:52,279
whole combination of defaults is that if

00:37:48,380 --> 00:37:56,239
you return an option a book and this

00:37:52,279 --> 00:38:00,619
thing here you will get an HTTP response

00:37:56,239 --> 00:38:02,989
with a status code ok and an empty

00:38:00,619 --> 00:38:07,190
response body and I think that's often

00:38:02,989 --> 00:38:09,140
not what people expect and if there's no

00:38:07,190 --> 00:38:12,589
reasonable default that you can provide

00:38:09,140 --> 00:38:16,880
I think it's much better to not have any

00:38:12,589 --> 00:38:19,699
default for this type at all and somehow

00:38:16,880 --> 00:38:22,489
magically inferring the HTTP response

00:38:19,699 --> 00:38:29,930
code from some generic type might not be

00:38:22,489 --> 00:38:33,849
a great idea in general maybe ok one

00:38:29,930 --> 00:38:37,160
final usability aspect of type classes

00:38:33,849 --> 00:38:41,559
with distributed data processing tools

00:38:37,160 --> 00:38:43,729
like spark crunch or fling whatever

00:38:41,559 --> 00:38:46,099
you'll find that it becomes very

00:38:43,729 --> 00:38:47,989
important that your type classes are

00:38:46,099 --> 00:38:52,279
serializable because they have to be

00:38:47,989 --> 00:38:54,469
sent over the wire all the time and it's

00:38:52,279 --> 00:38:56,930
surprising how many type classes are not

00:38:54,469 --> 00:38:59,749
serializable and then you can't do

00:38:56,930 --> 00:39:04,160
anything about it except filing a pull

00:38:59,749 --> 00:39:08,539
request so unless you have a very good

00:39:04,160 --> 00:39:13,309
reason not to please if you implement a

00:39:08,539 --> 00:39:18,229
new type class make it serializable so

00:39:13,309 --> 00:39:20,269
implicit for the win well all the use

00:39:18,229 --> 00:39:22,110
cases for implicit I think the type

00:39:20,269 --> 00:39:25,650
classes are probably one

00:39:22,110 --> 00:39:29,430
of the most useful ones but nevertheless

00:39:25,650 --> 00:39:33,120
they come with a cost as another treat

00:39:29,430 --> 00:39:34,830
by Jessica points out so even if you

00:39:33,120 --> 00:39:37,590
understand how type classes work in

00:39:34,830 --> 00:39:41,490
general understanding a specific type

00:39:37,590 --> 00:39:42,810
class requires some mental effort and if

00:39:41,490 --> 00:39:45,320
there were a lot of type classes with

00:39:42,810 --> 00:39:49,710
complex interactions between each other

00:39:45,320 --> 00:39:51,450
that cost can be especially high so when

00:39:49,710 --> 00:39:55,200
you think about using type classes to

00:39:51,450 --> 00:40:00,410
solve a problem I would invite you to

00:39:55,200 --> 00:40:03,990
ask a few questions first first of all

00:40:00,410 --> 00:40:08,160
so we saw that type lasses enable us to

00:40:03,990 --> 00:40:10,680
do retroactive extension of types that

00:40:08,160 --> 00:40:14,430
we can't change what types that we don't

00:40:10,680 --> 00:40:17,280
even know about so ask yourself is that

00:40:14,430 --> 00:40:19,560
really an important use case for you and

00:40:17,280 --> 00:40:22,680
if it is then by all means use type

00:40:19,560 --> 00:40:25,520
classes but if it's not maybe

00:40:22,680 --> 00:40:28,110
inheritance will work just fine for you

00:40:25,520 --> 00:40:30,720
and the other question is can you

00:40:28,110 --> 00:40:34,260
provide good defaults we just saw that

00:40:30,720 --> 00:40:36,530
sometimes some libraries provide

00:40:34,260 --> 00:40:39,510
defaults that don't make a lot of sense

00:40:36,530 --> 00:40:42,090
sometimes or actually very often and

00:40:39,510 --> 00:40:44,490
then the benefit of type class is not

00:40:42,090 --> 00:40:49,650
that big anymore because people have to

00:40:44,490 --> 00:40:51,990
override these default instances and

00:40:49,650 --> 00:40:56,520
then again how much boilerplate can you

00:40:51,990 --> 00:40:59,670
avoid by using type classes and ask

00:40:56,520 --> 00:41:03,360
yourself how does that weigh against the

00:40:59,670 --> 00:41:08,790
loss of clarity that results from using

00:41:03,360 --> 00:41:10,500
these type classes we saw that often you

00:41:08,790 --> 00:41:13,500
gain the most from type classes by

00:41:10,500 --> 00:41:16,110
having this machinery of automatically

00:41:13,500 --> 00:41:19,850
derived implicit for generic types of

00:41:16,110 --> 00:41:23,790
deriving one type class from another and

00:41:19,850 --> 00:41:27,240
that machinery is also it can be very

00:41:23,790 --> 00:41:30,030
confusing to people so this arc IH DDP

00:41:27,240 --> 00:41:31,560
example that I mentioned on if you want

00:41:30,030 --> 00:41:33,450
to overwrite that strange default

00:41:31,560 --> 00:41:35,010
behavior you first need to find out what

00:41:33,450 --> 00:41:36,660
is actually going on

00:41:35,010 --> 00:41:39,480
their interactions been three or four

00:41:36,660 --> 00:41:42,030
different type classes and all of their

00:41:39,480 --> 00:41:43,770
default instances and I think most

00:41:42,030 --> 00:41:45,210
people who use our CAI HTTP have never

00:41:43,770 --> 00:41:52,260
seen that there is something like an

00:41:45,210 --> 00:41:54,900
empty value type class at all so another

00:41:52,260 --> 00:41:59,400
thing is if you decide you want to use

00:41:54,900 --> 00:42:01,980
type classes can you think of supporting

00:41:59,400 --> 00:42:04,920
another alternative usage model for your

00:42:01,980 --> 00:42:06,380
library that does not make use of type

00:42:04,920 --> 00:42:09,420
classes and implements

00:42:06,380 --> 00:42:12,120
there's actually a very good example of

00:42:09,420 --> 00:42:15,240
that which is the Skotak library which

00:42:12,120 --> 00:42:17,760
really has this statement in there dogs

00:42:15,240 --> 00:42:21,000
that they use implicit but they

00:42:17,760 --> 00:42:23,220
explicitly support I use it smaller

00:42:21,000 --> 00:42:25,700
without implicit and I find that very

00:42:23,220 --> 00:42:25,700
appealing

00:42:26,840 --> 00:42:32,400
so to summarize type classes enable

00:42:30,210 --> 00:42:34,590
which reactive extension there are an

00:42:32,400 --> 00:42:38,010
alternative to inheritance and adapters

00:42:34,590 --> 00:42:40,740
and good type classes provide simple

00:42:38,010 --> 00:42:42,690
constructors and Combinator's that allow

00:42:40,740 --> 00:42:45,900
you to create new instances with minimal

00:42:42,690 --> 00:42:48,360
boilerplate they are powerful due to

00:42:45,900 --> 00:42:50,280
automatic derivation but this is also

00:42:48,360 --> 00:42:53,040
what can confuse people a lot especially

00:42:50,280 --> 00:42:56,670
if a lot of type classes interact with

00:42:53,040 --> 00:43:00,240
each other so please put them into your

00:42:56,670 --> 00:43:04,170
toolbox and don't fear them anymore but

00:43:00,240 --> 00:43:06,410
don't throw them at every problem thanks

00:43:04,170 --> 00:43:06,410

YouTube URL: https://www.youtube.com/watch?v=1e9tcymPl7w


