Title: Build a Recommender System in Apache Spark and Integrate it Using Akka by Willem Meints
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
Machine Learning to some is still very magical. The truth however is that this magic is actually much easier to use than you'd expect. Come and learn how you can use Apache Spark and Akka together to build a service that recommends items to users. In this session, I'm going to show you some of the bits that go into building a recommender system, how to actually implement one in Spark and finally how to integrate the recommender system into your application using Akka HTTP.
Captions: 
	00:00:04,880 --> 00:00:10,259
good morning everyone welcome to my talk

00:00:08,460 --> 00:00:14,010
on machine learning I see the room is

00:00:10,259 --> 00:00:15,269
full even more full than expected people

00:00:14,010 --> 00:00:19,919
are sitting on the ground I hope you're

00:00:15,269 --> 00:00:22,019
comfortable for the next 45 minutes it

00:00:19,919 --> 00:00:24,509
doesn't happen too often so I'm actually

00:00:22,019 --> 00:00:26,279
excited about this so I will do a talk

00:00:24,509 --> 00:00:28,589
on building a recommender system using

00:00:26,279 --> 00:00:30,479
Apache spark and a little bit of a car

00:00:28,589 --> 00:00:33,870
to show you how you can integrate this

00:00:30,479 --> 00:00:35,790
into your existing software using what

00:00:33,870 --> 00:00:37,350
other people would call micro services

00:00:35,790 --> 00:00:39,390
I'm going to call them services

00:00:37,350 --> 00:00:43,980
Microsoft I did this because that will

00:00:39,390 --> 00:00:46,830
get me into the conference please if you

00:00:43,980 --> 00:00:48,810
like my session leave a rating if you

00:00:46,830 --> 00:00:50,880
don't leave a rating as well and tell me

00:00:48,810 --> 00:00:52,860
why I need this information because I

00:00:50,880 --> 00:00:54,390
want to get better at this I want to

00:00:52,860 --> 00:00:56,940
learn from you what you liked what you

00:00:54,390 --> 00:00:58,200
didn't like if you like to talk to me

00:00:56,940 --> 00:01:00,990
personally I will be around the

00:00:58,200 --> 00:01:04,530
conference this afternoon still so you

00:01:00,990 --> 00:01:09,600
can find me behind this laptop with a

00:01:04,530 --> 00:01:11,240
large amount of stickers on it so let's

00:01:09,600 --> 00:01:13,859
talk about a little bit about

00:01:11,240 --> 00:01:16,799
recommendation systems and and what they

00:01:13,859 --> 00:01:20,039
do today for us who here is using

00:01:16,799 --> 00:01:20,969
Netflix at the moment who has a

00:01:20,039 --> 00:01:24,270
subscription

00:01:20,969 --> 00:01:26,460
well not it yeah typical at the moment

00:01:24,270 --> 00:01:29,340
watching a movie instead of watching me

00:01:26,460 --> 00:01:33,240
talk okay who has a subscription and

00:01:29,340 --> 00:01:35,759
Spotify cool what do we think of the

00:01:33,240 --> 00:01:38,789
recommendations of Netflix how do how

00:01:35,759 --> 00:01:43,109
are they doing on the home page you

00:01:38,789 --> 00:01:47,159
saying that it's ok they suck basically

00:01:43,109 --> 00:01:51,299
yeah I'm going to show you today why

00:01:47,159 --> 00:01:54,170
they suck and and why I'm not doing any

00:01:51,299 --> 00:01:54,170
better by the way

00:01:54,950 --> 00:02:01,049
so recommendations is if you've used

00:01:59,459 --> 00:02:03,029
Google before we all have done undone

00:02:01,049 --> 00:02:05,490
that you're basically searching for

00:02:03,029 --> 00:02:07,409
stuff you know is there if you search

00:02:05,490 --> 00:02:08,910
for Scala you will find stuff with Scala

00:02:07,409 --> 00:02:11,069
because you know there should be

00:02:08,910 --> 00:02:13,980
something there and it's a one-on-one

00:02:11,069 --> 00:02:15,680
match with your search query so what do

00:02:13,980 --> 00:02:16,950
recommendations do for you then

00:02:15,680 --> 00:02:20,489
recommendations

00:02:16,950 --> 00:02:23,010
are items that you don't know exist for

00:02:20,489 --> 00:02:25,800
the computer knows and he the computer

00:02:23,010 --> 00:02:28,140
knows you and so he's capable of showing

00:02:25,800 --> 00:02:30,540
you those items and you may or may not

00:02:28,140 --> 00:02:33,120
like them because Netflix does this as

00:02:30,540 --> 00:02:34,860
well with movies and some people will

00:02:33,120 --> 00:02:38,430
say it sucks some people will say it's

00:02:34,860 --> 00:02:42,200
okay other people are more or less

00:02:38,430 --> 00:02:44,580
convinced that it absolutely sucks so

00:02:42,200 --> 00:02:46,709
there's and that's also one of the

00:02:44,580 --> 00:02:48,170
things I'd like to tell you up front

00:02:46,709 --> 00:02:50,280
about machine learning in general

00:02:48,170 --> 00:02:53,310
machine learning will get it wrong every

00:02:50,280 --> 00:02:55,260
time so don't expect me to get better at

00:02:53,310 --> 00:02:57,840
this than Netflix does and don't expect

00:02:55,260 --> 00:03:00,810
me to get better at this than Spotify

00:02:57,840 --> 00:03:02,610
does and you will get it wrong too if

00:03:00,810 --> 00:03:05,489
you start to implement this but it

00:03:02,610 --> 00:03:06,599
doesn't matter very much because machine

00:03:05,489 --> 00:03:08,099
learning is about the art of

00:03:06,599 --> 00:03:11,099
approximation we're going to make a

00:03:08,099 --> 00:03:13,829
model of reality and we're going to use

00:03:11,099 --> 00:03:16,560
a model to recommend items in this case

00:03:13,829 --> 00:03:18,959
and in other times if you want to detect

00:03:16,560 --> 00:03:21,510
spam email they're going to make a model

00:03:18,959 --> 00:03:24,060
of a spam email and try to match that

00:03:21,510 --> 00:03:25,920
against incoming messages and see if

00:03:24,060 --> 00:03:28,530
that matches your model and if it does

00:03:25,920 --> 00:03:32,030
it's a spam email but it will be wrong

00:03:28,530 --> 00:03:36,150
at some point I will get back to this

00:03:32,030 --> 00:03:38,489
first let me show you what

00:03:36,150 --> 00:03:43,200
recommendations actually do what how it

00:03:38,489 --> 00:03:46,549
works so if you build a system like

00:03:43,200 --> 00:03:49,319
Netflix you can see the five stars after

00:03:46,549 --> 00:03:52,920
the title of every movie that's a rating

00:03:49,319 --> 00:03:55,350
you're giving right this is how much you

00:03:52,920 --> 00:03:58,200
like the movie and based on that fact I

00:03:55,350 --> 00:03:59,940
can learn the computer to show other

00:03:58,200 --> 00:04:02,609
movies that are similar to the one you

00:03:59,940 --> 00:04:04,349
watched and you liked it's basically the

00:04:02,609 --> 00:04:08,970
idea what what we're going to implement

00:04:04,349 --> 00:04:11,819
today so if you look at a system that

00:04:08,970 --> 00:04:14,220
that serves movies or songs for the

00:04:11,819 --> 00:04:15,599
metal or maybe newspaper articles I

00:04:14,220 --> 00:04:17,430
talked to a few guys this morning that

00:04:15,599 --> 00:04:19,789
we're working on a newspaper website

00:04:17,430 --> 00:04:22,320
it's interesting for them as well and

00:04:19,789 --> 00:04:26,430
what you end up is is a large database

00:04:22,320 --> 00:04:29,729
that contains users on one end and items

00:04:26,430 --> 00:04:30,750
on the other end and they get linked by

00:04:29,729 --> 00:04:32,400
ratings

00:04:30,750 --> 00:04:36,210
as you can see on my slide it's very

00:04:32,400 --> 00:04:39,180
empty right because you haven't watched

00:04:36,210 --> 00:04:41,970
every movie on Netflix 35,000 movies

00:04:39,180 --> 00:04:44,700
who here has watched them nobody right

00:04:41,970 --> 00:04:46,410
and that's a problem for us because if

00:04:44,700 --> 00:04:48,540
you want to recommend a movie to someone

00:04:46,410 --> 00:04:51,270
you want to show them the movies that

00:04:48,540 --> 00:04:54,440
they like best and the only way to know

00:04:51,270 --> 00:04:56,930
for sure is to ask them to rate every

00:04:54,440 --> 00:04:59,310
freakin movie on the planet

00:04:56,930 --> 00:05:01,740
that's the hundred percent solution and

00:04:59,310 --> 00:05:05,640
that's why we can't solve this problem

00:05:01,740 --> 00:05:07,050
it's unsolvable basically let's be

00:05:05,640 --> 00:05:11,070
honest so I'm not going to rate every

00:05:07,050 --> 00:05:14,010
every freakin movie on the planet so the

00:05:11,070 --> 00:05:17,030
only other way to fix this is to predict

00:05:14,010 --> 00:05:20,670
what the other movies will be like and

00:05:17,030 --> 00:05:22,980
some movies will be easy if I

00:05:20,670 --> 00:05:26,340
consistently rate movies in the action

00:05:22,980 --> 00:05:28,980
gel shanwa with a 5 and romantic movies

00:05:26,340 --> 00:05:31,320
with a 1 should be easy right but that's

00:05:28,980 --> 00:05:33,960
not always the case there tend to be

00:05:31,320 --> 00:05:36,510
movies where there's portly romantic

00:05:33,960 --> 00:05:40,320
stuff going on and the risks of the

00:05:36,510 --> 00:05:45,210
movie 80% is pure action people shooting

00:05:40,320 --> 00:05:47,340
other people and I still like that my

00:05:45,210 --> 00:05:49,730
wife likes the more romantic movies so

00:05:47,340 --> 00:05:52,350
that's also the reason why Netflix fails

00:05:49,730 --> 00:05:54,720
if you use one account and two people

00:05:52,350 --> 00:05:57,480
you get two profiles mixed together oh

00:05:54,720 --> 00:05:59,460
that's weird because I like action

00:05:57,480 --> 00:06:01,950
movies better than I like romantic

00:05:59,460 --> 00:06:03,960
movies but my wife isn't at home at the

00:06:01,950 --> 00:06:05,640
moment and I heard this morning she

00:06:03,960 --> 00:06:11,040
watched a romantic movie last night so

00:06:05,640 --> 00:06:12,720
my recommendations are messed up so so

00:06:11,040 --> 00:06:14,670
this gives you a sense of what is going

00:06:12,720 --> 00:06:16,920
on with machine-learning actually we

00:06:14,670 --> 00:06:18,500
have to predict in certain situations

00:06:16,920 --> 00:06:22,170
what the answer will be because we

00:06:18,500 --> 00:06:23,820
impossibly can't know what's going on so

00:06:22,170 --> 00:06:25,680
what we're going to try to do today is

00:06:23,820 --> 00:06:28,410
we're going to fill in the blanks with

00:06:25,680 --> 00:06:33,150
predictive values that's basically it

00:06:28,410 --> 00:06:36,840
and here's a cool trick I'm going to say

00:06:33,150 --> 00:06:42,030
I have three properties that describe me

00:06:36,840 --> 00:06:44,190
and this is a random number because it

00:06:42,030 --> 00:06:44,310
could be done it could be 15 I don't

00:06:44,190 --> 00:06:45,990
know

00:06:44,310 --> 00:06:49,410
up front but I'm going to choose one

00:06:45,990 --> 00:06:53,700
number and that's 3/4 because I have

00:06:49,410 --> 00:06:57,060
three properties on my screen also the

00:06:53,700 --> 00:07:00,480
next matrix in the middle is going to

00:06:57,060 --> 00:07:02,550
describe what the movies looked like and

00:07:00,480 --> 00:07:05,210
they also have three properties that

00:07:02,550 --> 00:07:09,630
describe them and which properties are

00:07:05,210 --> 00:07:13,770
this I don't know it's also very weird

00:07:09,630 --> 00:07:17,310
right because that's the second problem

00:07:13,770 --> 00:07:19,470
first I couldn't ask you to rate every

00:07:17,310 --> 00:07:22,320
movie on the planet and the other thing

00:07:19,470 --> 00:07:24,360
I couldn't ask every person that puts

00:07:22,320 --> 00:07:27,480
the movies on Netflix or puts the moves

00:07:24,360 --> 00:07:30,630
on more than the songs on on Spotify to

00:07:27,480 --> 00:07:32,070
tag them how what's the percentage of

00:07:30,630 --> 00:07:33,780
action in this movie what's your

00:07:32,070 --> 00:07:34,700
percentage of romantic stuff in this

00:07:33,780 --> 00:07:39,780
movie

00:07:34,700 --> 00:07:42,240
what's the accent in movie because I

00:07:39,780 --> 00:07:45,720
absolutely hates some accents maybe I

00:07:42,240 --> 00:07:47,490
don't know I I don't know why I'm giving

00:07:45,720 --> 00:07:49,260
a certain rate into rating through a

00:07:47,490 --> 00:07:52,770
movie so we're going to predict that as

00:07:49,260 --> 00:07:55,560
well and this gap is getting tricky

00:07:52,770 --> 00:07:59,700
right first I'm going to predict the

00:07:55,560 --> 00:08:01,440
ratings then on top of that I'm like

00:07:59,700 --> 00:08:06,030
okay how am I going to predict this oh

00:08:01,440 --> 00:08:07,620
maybe I can describe a movie in certain

00:08:06,030 --> 00:08:09,210
properties but I don't know which

00:08:07,620 --> 00:08:09,890
property so I'm going to choose a random

00:08:09,210 --> 00:08:12,720
number

00:08:09,890 --> 00:08:14,160
I'm going to say this is the amount of

00:08:12,720 --> 00:08:19,620
properties that describes a movie and

00:08:14,160 --> 00:08:22,170
same thing for a user so and then if I

00:08:19,620 --> 00:08:25,200
have I got that then it's a simple

00:08:22,170 --> 00:08:27,840
multiplication of two matrices together

00:08:25,200 --> 00:08:30,600
and people who've done mouths will find

00:08:27,840 --> 00:08:34,170
this easier than people that don't have

00:08:30,600 --> 00:08:36,330
this knowledge but in the end what we'll

00:08:34,170 --> 00:08:38,700
do is we'll say a rating of five is a

00:08:36,330 --> 00:08:40,500
multiplication of those three properties

00:08:38,700 --> 00:08:43,980
times three other properties from the

00:08:40,500 --> 00:08:45,480
user and that's that's it and we're

00:08:43,980 --> 00:08:46,740
going to ask the computer to come up

00:08:45,480 --> 00:08:49,140
with the numbers in the other two

00:08:46,740 --> 00:08:52,260
matrices this is what we're doing when

00:08:49,140 --> 00:08:54,650
we're building recommendations and it

00:08:52,260 --> 00:08:56,680
works like this and that's a firt

00:08:54,650 --> 00:09:00,910
randomize trick and this

00:08:56,680 --> 00:09:07,990
I'm going to choose random numbers for

00:09:00,910 --> 00:09:10,089
the first matrix why because I can this

00:09:07,990 --> 00:09:10,839
is really true scientists have come up

00:09:10,089 --> 00:09:12,730
with this model

00:09:10,839 --> 00:09:15,220
it's matrix factorization for people who

00:09:12,730 --> 00:09:16,899
like to Google and spend a whole three

00:09:15,220 --> 00:09:19,300
weeks reading a scientific paper that

00:09:16,899 --> 00:09:22,000
they definitely don't understand

00:09:19,300 --> 00:09:23,670
I've tried trust me it took me it took

00:09:22,000 --> 00:09:26,200
me quite a long time to learn this and

00:09:23,670 --> 00:09:30,760
they come up with this idea okay let's

00:09:26,200 --> 00:09:32,320
pick random numbers and the next step

00:09:30,760 --> 00:09:33,790
what I'm going to do is I'm going to ask

00:09:32,320 --> 00:09:36,520
the computer to execute a linear

00:09:33,790 --> 00:09:39,250
regression algorithm and this is a sort

00:09:36,520 --> 00:09:41,980
of technical thing to come up with the

00:09:39,250 --> 00:09:45,010
other numbers so what I'm going to do is

00:09:41,980 --> 00:09:47,529
I'm going to use the first matrix with

00:09:45,010 --> 00:09:50,170
random numbers and I'm going to choose a

00:09:47,529 --> 00:09:52,870
random number for the other values and

00:09:50,170 --> 00:09:55,120
I'm going to try to minimize the

00:09:52,870 --> 00:09:57,339
difference between the predicted rating

00:09:55,120 --> 00:10:00,399
and the actual rating I have in my

00:09:57,339 --> 00:10:02,680
matrix and the computer will take about

00:10:00,399 --> 00:10:05,740
a hundred thousand times to do this per

00:10:02,680 --> 00:10:11,500
rating and then it will have filled in

00:10:05,740 --> 00:10:12,970
the other matrix and that's about it

00:10:11,500 --> 00:10:16,330
doesn't done we have a predicted rating

00:10:12,970 --> 00:10:20,140
but it's very very wrong because it's

00:10:16,330 --> 00:10:23,140
random the next step I'm going to make

00:10:20,140 --> 00:10:25,900
this better so what we're going to do is

00:10:23,140 --> 00:10:27,220
we're going back to the first maybe we

00:10:25,900 --> 00:10:29,170
calculate the first one

00:10:27,220 --> 00:10:33,070
totally random then the next one be

00:10:29,170 --> 00:10:34,630
optimized using machine learning and

00:10:33,070 --> 00:10:38,170
then we're going back we're going to

00:10:34,630 --> 00:10:40,329
wipe this matrix again and we're going

00:10:38,170 --> 00:10:42,850
to ask the computer to run another round

00:10:40,329 --> 00:10:47,200
of linear regression and come up with

00:10:42,850 --> 00:10:48,520
better numbers for the first matrix so

00:10:47,200 --> 00:10:51,670
in the end what will happen is we will

00:10:48,520 --> 00:10:53,050
first optimize the first factor then the

00:10:51,670 --> 00:10:55,810
second one we go back to the first

00:10:53,050 --> 00:10:57,370
second first second first and this is

00:10:55,810 --> 00:11:00,220
called alternating least squares

00:10:57,370 --> 00:11:02,380
algorithm because the the error rate

00:11:00,220 --> 00:11:05,079
between the predicted rating and the

00:11:02,380 --> 00:11:07,110
actual rating we can calculate using a

00:11:05,079 --> 00:11:09,370
formula called least squares and

00:11:07,110 --> 00:11:10,570
alternating comes back to the

00:11:09,370 --> 00:11:13,600
alternating between the two

00:11:10,570 --> 00:11:16,650
matrices that were optimizing in the end

00:11:13,600 --> 00:11:22,230
of the 20th ms we should be they're

00:11:16,650 --> 00:11:24,540
somewhat weird huh

00:11:22,230 --> 00:11:27,040
how much kind of surprised by this

00:11:24,540 --> 00:11:30,490
people picked random numbers random

00:11:27,040 --> 00:11:33,100
number of factors and they run 20 times

00:11:30,490 --> 00:11:35,560
and then there are it works and trust me

00:11:33,100 --> 00:11:37,900
this works this really works you can try

00:11:35,560 --> 00:11:40,120
this out yourself I I have the code on

00:11:37,900 --> 00:11:41,650
github you can download it and run your

00:11:40,120 --> 00:11:44,320
own ratings through it and it will work

00:11:41,650 --> 00:11:48,370
you will be surprised at how well this

00:11:44,320 --> 00:11:51,340
actually performs it will get about 80%

00:11:48,370 --> 00:11:53,350
of the recommendations right pretty good

00:11:51,340 --> 00:11:57,520
for the fact that we're using random

00:11:53,350 --> 00:12:00,940
numbers apparently it's true in this

00:11:57,520 --> 00:12:02,860
world that we can use chaos randomness

00:12:00,940 --> 00:12:09,600
to come up with a proper model for the

00:12:02,860 --> 00:12:09,600
reality I find this very very very fun

00:12:09,930 --> 00:12:14,710
so not if you now that you've seen a

00:12:13,060 --> 00:12:16,780
little bit of the theory behind machine

00:12:14,710 --> 00:12:19,660
learning and you're all probably all

00:12:16,780 --> 00:12:25,450
confused anybody have a clue what's

00:12:19,660 --> 00:12:28,210
going on how to do this no right but do

00:12:25,450 --> 00:12:30,720
you need to know all this let's keep it

00:12:28,210 --> 00:12:33,340
at this let's keep in your mind that

00:12:30,720 --> 00:12:35,230
we're going to model a user we're going

00:12:33,340 --> 00:12:37,120
to model an item and we're going to

00:12:35,230 --> 00:12:38,560
match the two together that's the idea

00:12:37,120 --> 00:12:41,830
behind this that's basically what

00:12:38,560 --> 00:12:46,810
recommendations do and you can build

00:12:41,830 --> 00:12:49,750
this algorithm using one line of code in

00:12:46,810 --> 00:12:53,800
Apache spark Apache spark I say

00:12:49,750 --> 00:12:56,590
distributed computation engine it does a

00:12:53,800 --> 00:12:59,230
number of things but the most basic

00:12:56,590 --> 00:13:02,290
stuff is MapReduce algorithms is there

00:12:59,230 --> 00:13:03,870
anybody who has been to the session this

00:13:02,290 --> 00:13:07,660
morning on Apache spark

00:13:03,870 --> 00:13:11,860
what's one no this is completely new to

00:13:07,660 --> 00:13:14,350
you then so what it does is it's capable

00:13:11,860 --> 00:13:18,300
of running an algorithm across multiple

00:13:14,350 --> 00:13:22,120
machines which provides scalability and

00:13:18,300 --> 00:13:24,329
on top of that it provides a wide range

00:13:22,120 --> 00:13:28,379
of standard libraries that you

00:13:24,329 --> 00:13:30,089
use to execute common algorithms across

00:13:28,379 --> 00:13:31,739
those machines and one of them is

00:13:30,089 --> 00:13:33,629
machine learning and there's a quite a

00:13:31,739 --> 00:13:35,879
few algorithms in there I'm not going to

00:13:33,629 --> 00:13:37,559
list them and the most important bit to

00:13:35,879 --> 00:13:40,769
keep in mind is that it's everything is

00:13:37,559 --> 00:13:41,279
in memory so it's very fast that's a

00:13:40,769 --> 00:13:45,209
good thing

00:13:41,279 --> 00:13:48,119
I guess so this is how it works an

00:13:45,209 --> 00:13:51,149
apache spark program is a regular old

00:13:48,119 --> 00:13:53,100
scholar program but with a small

00:13:51,149 --> 00:13:54,480
difference what we're going to do in the

00:13:53,100 --> 00:13:56,279
program is we're going to set up a

00:13:54,480 --> 00:13:59,100
configuration for spark and we're going

00:13:56,279 --> 00:14:04,499
to say dear spark I want to use the

00:13:59,100 --> 00:14:06,449
local master this is my main thing where

00:14:04,499 --> 00:14:08,970
I'm going to set my program code to and

00:14:06,449 --> 00:14:12,629
he will split it up across several

00:14:08,970 --> 00:14:14,759
machines and between the square brackets

00:14:12,629 --> 00:14:17,009
there's a star and and this is where it

00:14:14,759 --> 00:14:18,809
gets cool if you put in a star it will

00:14:17,009 --> 00:14:20,879
use every single core in your machine

00:14:18,809 --> 00:14:24,509
and your laptop battery will drain in

00:14:20,879 --> 00:14:27,660
half an hour it's a good battery test

00:14:24,509 --> 00:14:29,129
and on top of that is very fast the

00:14:27,660 --> 00:14:31,799
other thing I like to do is I like to

00:14:29,129 --> 00:14:33,899
send a a app name for my spark

00:14:31,799 --> 00:14:37,559
application because if you run on your

00:14:33,899 --> 00:14:39,540
local machine it will work it's no

00:14:37,559 --> 00:14:41,009
problem you can do this you can start

00:14:39,540 --> 00:14:43,259
with a single development machine you

00:14:41,009 --> 00:14:47,879
will you can do everything it will be

00:14:43,259 --> 00:14:49,919
slow but ok but once you submit this

00:14:47,879 --> 00:14:51,749
application to a spark master on a

00:14:49,919 --> 00:14:54,629
different machine in a spark cluster in

00:14:51,749 --> 00:14:56,669
your company and 30 other developers are

00:14:54,629 --> 00:14:58,439
using the same machine you will notice

00:14:56,669 --> 00:15:00,660
that each of these developers when they

00:14:58,439 --> 00:15:03,149
forget this line of code will get a goo

00:15:00,660 --> 00:15:06,179
it as an application name good luck

00:15:03,149 --> 00:15:07,860
finding your code if it breaks so I'd

00:15:06,179 --> 00:15:10,379
like to set this even on my development

00:15:07,860 --> 00:15:12,929
machine and it will it will save you

00:15:10,379 --> 00:15:15,629
from a lot of trouble the last line and

00:15:12,929 --> 00:15:17,249
this is this is also something I learned

00:15:15,629 --> 00:15:20,569
from Scala developers I'm normally a

00:15:17,249 --> 00:15:23,429
c-sharp developer so I like to use long

00:15:20,569 --> 00:15:26,639
variable names Scala developers don't do

00:15:23,429 --> 00:15:29,160
such a thing they do short names spark

00:15:26,639 --> 00:15:32,029
contacts SC is a new spark context based

00:15:29,160 --> 00:15:32,029
on my configuration

00:15:33,660 --> 00:15:38,980
now that I have a spark context I can

00:15:36,610 --> 00:15:41,889
write a program and I don't have to

00:15:38,980 --> 00:15:44,319
think about the fact that it has to be

00:15:41,889 --> 00:15:47,439
split up across multiple notes if I have

00:15:44,319 --> 00:15:50,110
multiple notes that is all I need to do

00:15:47,439 --> 00:15:52,600
is I need to say okay dear spark context

00:15:50,110 --> 00:15:55,720
I want to use a text file my comma

00:15:52,600 --> 00:15:57,129
separated file and I'd like to perform

00:15:55,720 --> 00:15:59,279
several mapping so I'm going to split

00:15:57,129 --> 00:16:02,019
each line of text on a comma and then

00:15:59,279 --> 00:16:04,959
convert it into a record type and then

00:16:02,019 --> 00:16:08,170
count them and here's a cool trick it's

00:16:04,959 --> 00:16:11,860
Park the first three lines of code on

00:16:08,170 --> 00:16:13,149
this slide will do absolutely nothing if

00:16:11,860 --> 00:16:13,540
you run the program without the last

00:16:13,149 --> 00:16:15,910
line

00:16:13,540 --> 00:16:20,439
nothing happens is very fast it won't

00:16:15,910 --> 00:16:22,839
read the file even and here's why the

00:16:20,439 --> 00:16:24,490
mapping part is just the definition of

00:16:22,839 --> 00:16:27,699
what's going to happen on a spark

00:16:24,490 --> 00:16:30,369
cluster the count in this case is a

00:16:27,699 --> 00:16:32,529
reduce operation which will fire off the

00:16:30,369 --> 00:16:35,050
mapping which will split the data into

00:16:32,529 --> 00:16:37,290
several partitions several sections of

00:16:35,050 --> 00:16:40,749
data and send it off to reserve for

00:16:37,290 --> 00:16:42,519
processing so if you write your first

00:16:40,749 --> 00:16:45,309
spark program and you're thinking oh

00:16:42,519 --> 00:16:48,030
that's fast then it's probably not

00:16:45,309 --> 00:16:53,010
working

00:16:48,030 --> 00:16:55,080
and the other thing I noticed the text

00:16:53,010 --> 00:16:56,670
file in this case could not exist but it

00:16:55,080 --> 00:16:58,830
won't tell you until you run the count

00:16:56,670 --> 00:17:01,020
operation that's also because it's not

00:16:58,830 --> 00:17:03,570
executing and here's another cool thing

00:17:01,020 --> 00:17:06,329
if you run on a cluster then where is

00:17:03,570 --> 00:17:10,530
this file coming from anybody have any

00:17:06,329 --> 00:17:13,290
clue if you're lucky

00:17:10,530 --> 00:17:15,480
it comes from the master yeah you don't

00:17:13,290 --> 00:17:16,920
know basically it specify a relative

00:17:15,480 --> 00:17:19,980
path in it and that's it

00:17:16,920 --> 00:17:23,160
so if you start to do this please please

00:17:19,980 --> 00:17:25,319
please use HDFS or a sequel database or

00:17:23,160 --> 00:17:26,730
something that's network accessible for

00:17:25,319 --> 00:17:29,340
all your notes in your clock in your

00:17:26,730 --> 00:17:31,920
apache spark blister otherwise you get

00:17:29,340 --> 00:17:33,870
all sorts of weird errors this code is

00:17:31,920 --> 00:17:36,240
sent off to several nodes and those

00:17:33,870 --> 00:17:38,160
nodes need to file on disk in the same

00:17:36,240 --> 00:17:41,760
folder as their working folder for the

00:17:38,160 --> 00:17:44,910
spark installation that probably won't

00:17:41,760 --> 00:17:47,430
happen it's very very bad if you do such

00:17:44,910 --> 00:17:50,820
thing but yeah that's what I learned

00:17:47,430 --> 00:17:53,520
from using spark so to get back to the

00:17:50,820 --> 00:17:55,350
to the whole master/slave thing actually

00:17:53,520 --> 00:17:57,840
what will happen your Scala code will be

00:17:55,350 --> 00:17:59,520
submitted to a spark master and that

00:17:57,840 --> 00:18:01,380
sparked massive will be responsible for

00:17:59,520 --> 00:18:04,560
distributing the code across all the

00:18:01,380 --> 00:18:07,830
slaves and once you start up races like

00:18:04,560 --> 00:18:09,840
count it will automatically split up all

00:18:07,830 --> 00:18:12,180
your data in the most optimal version he

00:18:09,840 --> 00:18:13,650
can cannot come up with and it will send

00:18:12,180 --> 00:18:16,410
it off to the slaves for calculation and

00:18:13,650 --> 00:18:20,250
the end result will get back counting

00:18:16,410 --> 00:18:24,000
lines of code is very simple in spark

00:18:20,250 --> 00:18:25,950
you wouldn't use it for that and it will

00:18:24,000 --> 00:18:28,200
probably send it off to one or two nodes

00:18:25,950 --> 00:18:29,400
and then be done if we're talking

00:18:28,200 --> 00:18:30,750
machine learning it will be a lot more

00:18:29,400 --> 00:18:32,790
complex and you will see very

00:18:30,750 --> 00:18:35,850
interesting timeline graphs on the

00:18:32,790 --> 00:18:40,470
master telling you what's happening so

00:18:35,850 --> 00:18:44,100
this is how spark basically works not

00:18:40,470 --> 00:18:46,260
too much first going about I think that

00:18:44,100 --> 00:18:51,900
if you know Scala spark should be doable

00:18:46,260 --> 00:18:54,750
for most of you then let's go back to my

00:18:51,900 --> 00:18:56,730
recommender system so I have a running

00:18:54,750 --> 00:18:59,070
system thats collecting ratings from

00:18:56,730 --> 00:19:01,290
users and I'll store them in Cassandra

00:18:59,070 --> 00:19:02,179
obviously you can use sequel server if

00:19:01,290 --> 00:19:04,830
you like

00:19:02,179 --> 00:19:09,119
and if you're running Netflix and you

00:19:04,830 --> 00:19:10,739
have five million plus users you will

00:19:09,119 --> 00:19:13,799
end up with a broken sequel server

00:19:10,739 --> 00:19:16,409
database but if you're going to try this

00:19:13,799 --> 00:19:16,980
at home use a sequel server in your own

00:19:16,409 --> 00:19:20,489
company

00:19:16,980 --> 00:19:21,809
start small Cassandra is a nightmare to

00:19:20,489 --> 00:19:24,330
maintain if you don't know what you're

00:19:21,809 --> 00:19:25,799
doing and it's not worth the hassle in

00:19:24,330 --> 00:19:28,379
the beginning if you start just starting

00:19:25,799 --> 00:19:30,629
out with machine learning so in this

00:19:28,379 --> 00:19:33,899
code I'm asking the sport context for a

00:19:30,629 --> 00:19:36,659
Cassandra table which is in the

00:19:33,899 --> 00:19:40,350
recommendation database in the ratings

00:19:36,659 --> 00:19:43,950
table and I'm going to load a rating

00:19:40,350 --> 00:19:45,779
object containing a user ID and the item

00:19:43,950 --> 00:19:48,869
ID in a rating which is my first matrix

00:19:45,779 --> 00:19:51,629
and it's very empty it doesn't contain a

00:19:48,869 --> 00:19:52,889
whole lot of data and then next I'm

00:19:51,629 --> 00:19:54,749
going to define a couple of variables

00:19:52,889 --> 00:19:57,929
which I'm going to use for training and

00:19:54,749 --> 00:20:01,109
what will happen is alternating least

00:19:57,929 --> 00:20:03,600
squares LS for short for Scala

00:20:01,109 --> 00:20:05,580
developers and I'm going to say train

00:20:03,600 --> 00:20:08,609
this model and I'm going to put in all

00:20:05,580 --> 00:20:11,820
the ratings I have and I'm going to say

00:20:08,609 --> 00:20:14,759
okay rank in this case is I have 10

00:20:11,820 --> 00:20:17,669
properties this is what I explained

00:20:14,759 --> 00:20:19,889
before with the two matrix I'm going to

00:20:17,669 --> 00:20:21,779
train for ten properties and I'm going

00:20:19,889 --> 00:20:25,049
to alternate ten times this is the

00:20:21,779 --> 00:20:26,700
iteration parameters and the last

00:20:25,049 --> 00:20:29,519
parameter I'm going to put in the London

00:20:26,700 --> 00:20:31,109
that's this is a learning rate for my

00:20:29,519 --> 00:20:33,470
machine learning model and this has to

00:20:31,109 --> 00:20:36,899
do with linear regression it's going to

00:20:33,470 --> 00:20:40,919
decrease the error rate try at least by

00:20:36,899 --> 00:20:42,840
a factor of zero zero one if your

00:20:40,919 --> 00:20:45,389
interests interested in in more details

00:20:42,840 --> 00:20:47,039
I suggest you either google it or

00:20:45,389 --> 00:20:49,259
there's an excellent course of course

00:20:47,039 --> 00:20:50,970
here are free machine learning course

00:20:49,259 --> 00:20:54,149
that explains all of the linear

00:20:50,970 --> 00:20:55,320
regression stuff and is actually quite

00:20:54,149 --> 00:20:58,470
good I think

00:20:55,320 --> 00:21:00,450
and the end result will be a model which

00:20:58,470 --> 00:21:03,210
is basically my my first matrix has

00:21:00,450 --> 00:21:05,820
showed you all my slides but then all

00:21:03,210 --> 00:21:08,820
the blank spots are filled in and from

00:21:05,820 --> 00:21:11,700
this point on it's basically order it by

00:21:08,820 --> 00:21:14,730
rating for each user and ask for the top

00:21:11,700 --> 00:21:16,830
ten and that's it

00:21:14,730 --> 00:21:18,660
so first I spend a lot of time

00:21:16,830 --> 00:21:21,000
explaining to you that I'm using random

00:21:18,660 --> 00:21:24,090
numbers I'm using a lot of computing

00:21:21,000 --> 00:21:27,450
powers 100,000 iterations per rating and

00:21:24,090 --> 00:21:30,030
and then I'm okay this is all sorting

00:21:27,450 --> 00:21:31,500
and then selecting that's it and this is

00:21:30,030 --> 00:21:33,180
also one of those things that happens in

00:21:31,500 --> 00:21:34,800
machine learning training a model is

00:21:33,180 --> 00:21:38,070
very very hard for the computer it takes

00:21:34,800 --> 00:21:41,700
a long time but using it is very very

00:21:38,070 --> 00:21:43,050
fast because the model is so simple so

00:21:41,700 --> 00:21:44,640
if you're trying to build a machine

00:21:43,050 --> 00:21:47,220
learning solution yourself and you're

00:21:44,640 --> 00:21:50,250
going to attempt this be prepared to

00:21:47,220 --> 00:21:52,920
scale up for large amounts of data but

00:21:50,250 --> 00:22:00,030
don't worry about too much about using

00:21:52,920 --> 00:22:02,100
the model because it's fast so now that

00:22:00,030 --> 00:22:06,000
I have a trained model I'd like to use

00:22:02,100 --> 00:22:09,690
it in my application and in good fashion

00:22:06,000 --> 00:22:11,940
I like to make this reactive for maybe

00:22:09,690 --> 00:22:13,440
not so obvious reasons the reason I'd

00:22:11,940 --> 00:22:15,120
like to make it reactive is because

00:22:13,440 --> 00:22:16,830
training the model is taking a long time

00:22:15,120 --> 00:22:21,600
I'd like to run this on the back of

00:22:16,830 --> 00:22:23,280
background truth better yet maybe on a

00:22:21,600 --> 00:22:26,760
different machine so that that my

00:22:23,280 --> 00:22:29,250
microservice can keep on running so

00:22:26,760 --> 00:22:31,650
here's what I did I made a central actor

00:22:29,250 --> 00:22:34,350
in my application that I can ask for

00:22:31,650 --> 00:22:37,980
recommendations and that I can tell go

00:22:34,350 --> 00:22:40,080
train yourself and the go train yourself

00:22:37,980 --> 00:22:41,580
commands will fire often the second

00:22:40,080 --> 00:22:43,650
actor which will run in the background

00:22:41,580 --> 00:22:45,630
and he will keep track of the training

00:22:43,650 --> 00:22:48,450
process he will talk to a patchy spark

00:22:45,630 --> 00:22:50,190
and there's a number of ways in which

00:22:48,450 --> 00:22:52,140
you can do this is so if people have

00:22:50,190 --> 00:22:54,750
used spark before and know about spark

00:22:52,140 --> 00:22:57,600
streaming and an actor streams and all

00:22:54,750 --> 00:22:59,910
that sort of stuff I've choosen the most

00:22:57,600 --> 00:23:03,990
simple way to do this and sorry if you

00:22:59,910 --> 00:23:06,030
feel feel different about it then when

00:23:03,990 --> 00:23:07,620
the training is done the recommender

00:23:06,030 --> 00:23:12,720
system will get a message back I'm done

00:23:07,620 --> 00:23:16,350
here's your new model so this way my

00:23:12,720 --> 00:23:19,350
main model will will stay available for

00:23:16,350 --> 00:23:22,020
users while I'm training a new one it's

00:23:19,350 --> 00:23:24,120
a good trick and everything is exposed

00:23:22,020 --> 00:23:25,920
using akka HTTP because that combines

00:23:24,120 --> 00:23:27,450
very well with with akka you could use

00:23:25,920 --> 00:23:30,390
other stuff but

00:23:27,450 --> 00:23:32,280
yeah our point is very useful so this is

00:23:30,390 --> 00:23:34,710
basically the structure of my micro

00:23:32,280 --> 00:23:37,320
cells that I'm using let's zoom in zoom

00:23:34,710 --> 00:23:39,990
in a little bit so this is why I

00:23:37,320 --> 00:23:41,610
recommend the system actor it has a

00:23:39,990 --> 00:23:43,650
optional model which could be empty

00:23:41,610 --> 00:23:45,120
because if you start the surface the

00:23:43,650 --> 00:23:48,120
first time the model is empty it's not

00:23:45,120 --> 00:23:52,470
trained and I like to express it in an

00:23:48,120 --> 00:23:55,679
option next it accepts a few messages so

00:23:52,470 --> 00:23:58,610
first it's a train message not the one

00:23:55,679 --> 00:24:00,660
on the table but training exercising and

00:23:58,610 --> 00:24:03,650
the second one is generates

00:24:00,660 --> 00:24:05,370
recommendations and I can generate

00:24:03,650 --> 00:24:08,160
recommendations specifically for a

00:24:05,370 --> 00:24:09,690
single user and finally accepts a

00:24:08,160 --> 00:24:17,820
training result which is the reply from

00:24:09,690 --> 00:24:20,070
my training actor so I've shown you

00:24:17,820 --> 00:24:22,500
already how to train a model which

00:24:20,070 --> 00:24:24,990
basically goes like this it it fires up

00:24:22,500 --> 00:24:27,450
the training actor the training actor

00:24:24,990 --> 00:24:29,280
will call the ALS the train function and

00:24:27,450 --> 00:24:30,900
will send a reply black back to the

00:24:29,280 --> 00:24:33,330
recommender system so that's not very

00:24:30,900 --> 00:24:35,490
interesting to show you this one is the

00:24:33,330 --> 00:24:38,610
missing piece in actually using my model

00:24:35,490 --> 00:24:40,919
so I tweet my model before and when I

00:24:38,610 --> 00:24:45,980
ask for recommendations will go like

00:24:40,919 --> 00:24:49,020
this if the model matches some model

00:24:45,980 --> 00:24:50,880
which means I have a train model I will

00:24:49,020 --> 00:24:53,370
ask it to recommend products for a

00:24:50,880 --> 00:24:55,620
certain user ID and number of items I

00:24:53,370 --> 00:24:58,650
specify the my code earlier that it's

00:24:55,620 --> 00:25:01,559
ten items and what will happen is I will

00:24:58,650 --> 00:25:04,799
get back a set of items from the matrix

00:25:01,559 --> 00:25:07,049
I've strained and I can map that to my

00:25:04,799 --> 00:25:08,880
own or format so they like a rid of

00:25:07,049 --> 00:25:13,020
certain properties I don't need and

00:25:08,880 --> 00:25:15,030
that's what I give back to the user if

00:25:13,020 --> 00:25:19,080
it's one line to Train it as a one line

00:25:15,030 --> 00:25:24,540
to use it I think personally that this

00:25:19,080 --> 00:25:26,970
is very basic actually if you want to

00:25:24,540 --> 00:25:28,650
start using recommendations today you

00:25:26,970 --> 00:25:30,690
don't need to learn everything about

00:25:28,650 --> 00:25:33,090
statistics you don't need to learn about

00:25:30,690 --> 00:25:35,160
linear regression you just need to know

00:25:33,090 --> 00:25:36,660
how to apply this and trust me

00:25:35,160 --> 00:25:38,880
everything is in the documentation of

00:25:36,660 --> 00:25:41,130
Apache spark and it's well explained how

00:25:38,880 --> 00:25:44,510
it works and if you're unsure

00:25:41,130 --> 00:25:47,780
about things like lambdas and iterations

00:25:44,510 --> 00:25:50,760
experimentation is your best friend oh

00:25:47,780 --> 00:25:53,100
and in case my model isn't trained I

00:25:50,760 --> 00:25:55,560
give back a nil which is in Scala the

00:25:53,100 --> 00:25:57,540
thing for an empty list so no model

00:25:55,560 --> 00:26:04,410
means no exception

00:25:57,540 --> 00:26:06,120
it just means you don't get anything so

00:26:04,410 --> 00:26:09,120
ok I've trained a model I've integrated

00:26:06,120 --> 00:26:13,200
it but how can you know for sure that it

00:26:09,120 --> 00:26:17,060
works anybody have any clue as to what I

00:26:13,200 --> 00:26:26,120
can do next to check this if this works

00:26:17,060 --> 00:26:29,280
unit test perhaps yeah that's a good one

00:26:26,120 --> 00:26:31,020
you can compare the new matrix with the

00:26:29,280 --> 00:26:33,990
with the original one that's one method

00:26:31,020 --> 00:26:36,750
to do it it's a very mathematical way to

00:26:33,990 --> 00:26:39,750
do it yeah and it works so the normal

00:26:36,750 --> 00:26:42,030
way to to validate this sort of thing is

00:26:39,750 --> 00:26:44,310
to come up with a confusion matrix they

00:26:42,030 --> 00:26:46,080
call this in which you keep track of

00:26:44,310 --> 00:26:49,440
false positives and false negatives and

00:26:46,080 --> 00:26:52,890
you calculate an accuracy in a thing

00:26:49,440 --> 00:26:55,860
called recall it's all very scientific

00:26:52,890 --> 00:27:01,140
and I've come up with a non scientific

00:26:55,860 --> 00:27:04,500
way to solve this so what I'd like to do

00:27:01,140 --> 00:27:08,640
in my system is is this when a user

00:27:04,500 --> 00:27:12,270
clicks an item sorry let's step to

00:27:08,640 --> 00:27:14,550
actually step one is once you generate

00:27:12,270 --> 00:27:15,870
recommendations on your homepage store

00:27:14,550 --> 00:27:17,940
the list of recommendations you

00:27:15,870 --> 00:27:21,990
generated together with the timestamp

00:27:17,940 --> 00:27:24,810
the next step when a user clicks on an

00:27:21,990 --> 00:27:27,690
item in your system keep track of the

00:27:24,810 --> 00:27:30,690
fact that it clicked it and and here's

00:27:27,690 --> 00:27:33,480
why if you user clicks on item I'm going

00:27:30,690 --> 00:27:36,930
to assume that he likes item better

00:27:33,480 --> 00:27:38,970
that's true I don't know I can't see but

00:27:36,930 --> 00:27:40,920
I'm going to be very binary about this

00:27:38,970 --> 00:27:42,470
you know if you click that you like that

00:27:40,920 --> 00:27:45,990
if you don't like it you don't like it

00:27:42,470 --> 00:27:48,390
it's it's a representation of the

00:27:45,990 --> 00:27:52,560
reality is also machine learning but

00:27:48,390 --> 00:27:54,150
very hands written so to speak and the

00:27:52,560 --> 00:27:55,539
first step I'm going to crunch a few

00:27:54,150 --> 00:28:01,730
numbers

00:27:55,539 --> 00:28:04,940
what is and here's how that works so if

00:28:01,730 --> 00:28:06,710
I clicked an item interesting and I

00:28:04,940 --> 00:28:09,620
showed it in the recommendations this is

00:28:06,710 --> 00:28:14,659
a true positive right this makes sense I

00:28:09,620 --> 00:28:16,490
think at least the second if I didn't

00:28:14,659 --> 00:28:18,080
click it at all and it was shown in the

00:28:16,490 --> 00:28:20,450
recommendations this is false positive

00:28:18,080 --> 00:28:26,299
this is not not the stuff that I want to

00:28:20,450 --> 00:28:27,919
see the other one is obviously if I

00:28:26,299 --> 00:28:31,070
didn't show it to the user and he

00:28:27,919 --> 00:28:33,260
clicked it it's a false negative I I

00:28:31,070 --> 00:28:37,190
actually should have shown it to the

00:28:33,260 --> 00:28:39,980
user and the last one is I didn't click

00:28:37,190 --> 00:28:45,110
it and didn't show it good stuff I don't

00:28:39,980 --> 00:28:47,690
want that so here's what happens for me

00:28:45,110 --> 00:28:50,419
I've got four items recommended to me

00:28:47,690 --> 00:28:52,640
and this is a sort of simple scenario

00:28:50,419 --> 00:28:55,720
the first one alike

00:28:52,640 --> 00:28:58,190
a car with a car with Scala for dummies

00:28:55,720 --> 00:29:00,289
yeah it's interesting stuff I read that

00:28:58,190 --> 00:29:02,840
one I don't know if it's an existing

00:29:00,289 --> 00:29:04,789
book but the second one cooking with

00:29:02,840 --> 00:29:07,820
your grandmother as fun as it sounds

00:29:04,789 --> 00:29:09,590
I don't want to see it and the third one

00:29:07,820 --> 00:29:13,220
something about bears I'm not a

00:29:09,590 --> 00:29:15,440
biologist so I don't know why why why

00:29:13,220 --> 00:29:18,830
don't you remove this from the list and

00:29:15,440 --> 00:29:21,289
the first and the last one a 1001 things

00:29:18,830 --> 00:29:27,100
you don't want to know about yeah I want

00:29:21,289 --> 00:29:29,419
to I want to know that but sadly

00:29:27,100 --> 00:29:32,120
although I did get four recommendations

00:29:29,419 --> 00:29:35,149
there's one missing advanced especially

00:29:32,120 --> 00:29:36,470
part of spark I'm just I use a pet you

00:29:35,149 --> 00:29:39,070
spark a lot but I would like to learn

00:29:36,470 --> 00:29:40,370
more but it didn't show it to me sad

00:29:39,070 --> 00:29:43,130
bummer

00:29:40,370 --> 00:29:46,539
well nonetheless let's let's see what

00:29:43,130 --> 00:29:48,679
happens okay so I've got two interesting

00:29:46,539 --> 00:29:52,700
recommendations this is my first number

00:29:48,679 --> 00:29:56,360
on the right the second one is 5 which

00:29:52,700 --> 00:30:00,950
is the items that are actually remaining

00:29:56,360 --> 00:30:02,899
in a database for me and in tough life

00:30:00,950 --> 00:30:06,250
10 items so that gives me a precision of

00:30:02,899 --> 00:30:07,860
zero zero point seven seventy percent

00:30:06,250 --> 00:30:11,940
accurate

00:30:07,860 --> 00:30:17,390
is this okay for you anybody

00:30:11,940 --> 00:30:25,559
I think 70% is a bit on the low side but

00:30:17,390 --> 00:30:29,610
yeah well it happens and the next one is

00:30:25,559 --> 00:30:31,470
recall this measure is it's about how

00:30:29,610 --> 00:30:33,240
many items from the set that is

00:30:31,470 --> 00:30:37,530
interesting for me are actually shown to

00:30:33,240 --> 00:30:40,650
me recall is sort of it gets out of your

00:30:37,530 --> 00:30:43,950
memory into you can you can use it and

00:30:40,650 --> 00:30:45,720
in this case only two items of the three

00:30:43,950 --> 00:30:48,690
that were interesting to me were

00:30:45,720 --> 00:30:53,610
actually shown which is 66 percent which

00:30:48,690 --> 00:30:58,440
is even worse but here's the thing this

00:30:53,610 --> 00:31:02,370
sounds yeah well okay it works but yeah

00:30:58,440 --> 00:31:04,410
not very well and this is because

00:31:02,370 --> 00:31:06,390
there's a problem with this but this

00:31:04,410 --> 00:31:10,049
recommender system and one of the

00:31:06,390 --> 00:31:12,840
problems is if I if I want to increase

00:31:10,049 --> 00:31:15,240
the position of my recommender system I

00:31:12,840 --> 00:31:17,460
want to show more good recommendations I

00:31:15,240 --> 00:31:21,330
have to reduce the number of items that

00:31:17,460 --> 00:31:23,010
I'm giving back and why is that because

00:31:21,330 --> 00:31:24,929
if I show more items there's a bigger

00:31:23,010 --> 00:31:29,610
chance that there are items that are not

00:31:24,929 --> 00:31:32,610
interesting to me right but if I show

00:31:29,610 --> 00:31:34,440
less items I can't reach a position of

00:31:32,610 --> 00:31:36,900
hundred percent I'm mighty easy to reach

00:31:34,440 --> 00:31:40,230
it but I probably don't because I've I'd

00:31:36,900 --> 00:31:42,330
show only one item it could be right it

00:31:40,230 --> 00:31:44,070
could be wrong so I could reach 100

00:31:42,330 --> 00:31:46,820
percent or could reach zero percent

00:31:44,070 --> 00:31:49,590
that's not something you want right so

00:31:46,820 --> 00:31:53,750
what do I do I increase the number of

00:31:49,590 --> 00:31:57,720
items I'm going to show to the user and

00:31:53,750 --> 00:31:59,730
yeah more items means lower position but

00:31:57,720 --> 00:32:02,460
it also means there are more interesting

00:31:59,730 --> 00:32:04,460
items coming back I get a mix of

00:32:02,460 --> 00:32:07,710
uninteresting and interesting items

00:32:04,460 --> 00:32:12,360
which might give the user more choice in

00:32:07,710 --> 00:32:15,929
in what he can see so when you're trying

00:32:12,360 --> 00:32:18,330
to build this yourself then there's only

00:32:15,929 --> 00:32:20,610
one way to know for sure if your system

00:32:18,330 --> 00:32:21,420
works use this technique to record in

00:32:20,610 --> 00:32:24,120
the numbers

00:32:21,420 --> 00:32:25,140
and monitor them you can you can't write

00:32:24,120 --> 00:32:27,120
unit tests for machine learning

00:32:25,140 --> 00:32:32,000
solutions because it's an approximation

00:32:27,120 --> 00:32:34,890
and the minute I train a model is wrong

00:32:32,000 --> 00:32:36,660
because the world changes as soon as you

00:32:34,890 --> 00:32:38,190
save the model in a variable someone

00:32:36,660 --> 00:32:39,960
will come along and give a new rating in

00:32:38,190 --> 00:32:44,130
your system and then it's wrong again

00:32:39,960 --> 00:32:45,930
because who knows what could happen so

00:32:44,130 --> 00:32:49,230
the only way to optimize this properly

00:32:45,930 --> 00:32:51,000
is to first crunch numbers send it off

00:32:49,230 --> 00:32:53,460
to a dashboard and watch it on a

00:32:51,000 --> 00:32:57,480
development room and see if it suddenly

00:32:53,460 --> 00:32:58,860
drops or increases and that's the moment

00:32:57,480 --> 00:33:00,930
where you want to start to debug this

00:32:58,860 --> 00:33:03,840
system where you want to take a closer

00:33:00,930 --> 00:33:05,910
look and see ok why is this happening

00:33:03,840 --> 00:33:07,380
do I need to increase the number of

00:33:05,910 --> 00:33:09,030
properties maybe do I need to increase

00:33:07,380 --> 00:33:10,820
the number of iterations or do I need to

00:33:09,030 --> 00:33:14,820
decrease the number of iterations and

00:33:10,820 --> 00:33:16,500
this is all experimentation I'd love to

00:33:14,820 --> 00:33:18,630
say with all the scientists in the world

00:33:16,500 --> 00:33:21,390
that machine learning is awesome and it

00:33:18,630 --> 00:33:26,130
rules and it is really really simple

00:33:21,390 --> 00:33:28,230
it's not at all and frankly nobody knows

00:33:26,130 --> 00:33:30,150
how how it works exactly and that's not

00:33:28,230 --> 00:33:33,120
a problem as long as you take proper

00:33:30,150 --> 00:33:35,100
measures to use this make sure that you

00:33:33,120 --> 00:33:38,220
check it with the user make sure that

00:33:35,100 --> 00:33:40,350
you monitor your system so that you know

00:33:38,220 --> 00:33:49,260
when accuracy is going to drop when it

00:33:40,350 --> 00:33:50,790
gets get gets worse so yeah what is I'd

00:33:49,260 --> 00:33:53,070
like to invite you to try this out

00:33:50,790 --> 00:33:54,900
yourself you can download every bit of

00:33:53,070 --> 00:33:59,370
code I've written for my github account

00:33:54,900 --> 00:34:04,500
and if you have questions tweet me I'm

00:33:59,370 --> 00:34:07,160
happy to help and yeah then I have time

00:34:04,500 --> 00:34:07,160
left for questions

00:34:09,600 --> 00:34:19,310
yeah it's easier can you show the

00:34:15,870 --> 00:34:23,310
implementation of the recommend products

00:34:19,310 --> 00:34:27,320
method because I noticed that you're not

00:34:23,310 --> 00:34:30,660
ordering by rating no I don't do that

00:34:27,320 --> 00:34:32,640
that's a good question so can you show

00:34:30,660 --> 00:34:39,360
me the recommendation implementation and

00:34:32,640 --> 00:34:41,280
why is it not ordering yeah its order it

00:34:39,360 --> 00:34:44,010
inside so a patch is part takes care of

00:34:41,280 --> 00:34:46,200
that actually the the recommends

00:34:44,010 --> 00:34:48,210
products methods that I'm calling is on

00:34:46,200 --> 00:34:50,610
the on the model from spark and double

00:34:48,210 --> 00:34:52,170
order everything for me it's actually

00:34:50,610 --> 00:34:52,800
not order to serve it will do that on

00:34:52,170 --> 00:34:55,590
the fly

00:34:52,800 --> 00:34:58,320
so that's that's also important thing to

00:34:55,590 --> 00:35:01,500
keep in mind but it's very fast so it's

00:34:58,320 --> 00:35:03,920
not a big problem yeah any other

00:35:01,500 --> 00:35:03,920
questions

00:35:09,339 --> 00:35:15,039
in your use case would you always train

00:35:13,450 --> 00:35:17,349
the model on all the users in the system

00:35:15,039 --> 00:35:21,450
what would you ever sort of pick out one

00:35:17,349 --> 00:35:24,849
user and then train for that user only

00:35:21,450 --> 00:35:28,089
you could incrementally train your model

00:35:24,849 --> 00:35:32,039
but once once in a while you have to

00:35:28,089 --> 00:35:35,200
train for everybody and that's because

00:35:32,039 --> 00:35:37,660
one change and one movie could mean that

00:35:35,200 --> 00:35:41,170
it changes for everyone and one change

00:35:37,660 --> 00:35:44,500
for ever for a rating for a single user

00:35:41,170 --> 00:35:48,549
could mean that everyone else is touched

00:35:44,500 --> 00:35:51,250
by it and this is because we have a very

00:35:48,549 --> 00:35:53,500
general concept of the number of

00:35:51,250 --> 00:35:56,799
properties that he used that describes a

00:35:53,500 --> 00:35:58,720
user and that describes an item so yeah

00:35:56,799 --> 00:36:01,480
you could do it incrementally but I

00:35:58,720 --> 00:36:03,220
would suggest that once every week or so

00:36:01,480 --> 00:36:05,829
I would train the full set again yeah

00:36:03,220 --> 00:36:07,720
and that's also also a general tip on on

00:36:05,829 --> 00:36:10,359
working with the sort of stuff you have

00:36:07,720 --> 00:36:12,549
to retrain the model every once in a

00:36:10,359 --> 00:36:14,680
while and how often that is depends on

00:36:12,549 --> 00:36:16,869
what you're doing and and how well it

00:36:14,680 --> 00:36:18,609
goes that's why I suggest you monitor it

00:36:16,869 --> 00:36:25,569
and then decide what you're going to do

00:36:18,609 --> 00:36:27,640
yeah I'm personally interested in the

00:36:25,569 --> 00:36:29,980
way the spark actually communicates with

00:36:27,640 --> 00:36:31,930
the actor park I mean you compute this

00:36:29,980 --> 00:36:34,269
model and then you somehow store each

00:36:31,930 --> 00:36:37,390
persistently or it stays somewhere else

00:36:34,269 --> 00:36:40,329
park yeah I made a sort of a shortcut

00:36:37,390 --> 00:36:43,029
there I store it in memory at the moment

00:36:40,329 --> 00:36:47,849
but what you could do is save the model

00:36:43,029 --> 00:36:51,009
on HDFS or on disk you can do that so

00:36:47,849 --> 00:36:57,450
yeah it's a one line of code extra to do

00:36:51,009 --> 00:36:57,450
that yeah any more questions

00:36:59,530 --> 00:37:05,490

YouTube URL: https://www.youtube.com/watch?v=9mK90ddfkUI


