Title: The Structure of Programming Revolutions by Noel Welsh
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
What does it mean to think like a functional programmer? Why is it so hard to adopt functional programming if you are steeped in OO? In this talk I'll address these questions, using ideas from the philosophy of science. The talk will give new insight into the process of becoming productive in Scala, and the mindset needed to aid this process. 

Using the framework of ""The Structure of Scientific Revolutions"" we can see programming as undergoing three revolutions: structured programming, object-oriented programming, and now, functional programming. Each revolution brings with a new paradigm---basic assumptions and values that make moving across paradigms difficult to achieve. 

In this talk I'll describe the paradigm of the functional programmer: what is valued and, what is considered good code. I will contrast this to the paradigm of the object-oriented programmer, and finally consider if it is possible to reconcile these two approaches to programming.
Captions: 
	00:00:01,489 --> 00:00:05,850
so let's get started so thank you all

00:00:04,230 --> 00:00:07,969
for coming over to my talk my name is

00:00:05,850 --> 00:00:11,459
Noah Welsh and i'll be talking about the

00:00:07,969 --> 00:00:13,559
structure of programming revolutions so

00:00:11,459 --> 00:00:15,150
at the keynote today which is about post

00:00:13,559 --> 00:00:18,420
capitalist society i want to continue

00:00:15,150 --> 00:00:20,070
talking about big weighty important

00:00:18,420 --> 00:00:23,730
topics this is a very serious talk I

00:00:20,070 --> 00:00:26,789
don't expect any laughing I want to

00:00:23,730 --> 00:00:28,560
discuss virtue and truth and in

00:00:26,789 --> 00:00:32,340
particular the question that really

00:00:28,560 --> 00:00:38,100
motivated this talk which was is Python

00:00:32,340 --> 00:00:40,380
a good language and now this is yeah

00:00:38,100 --> 00:00:42,720
this is a kind of a it's a difficult

00:00:40,380 --> 00:00:45,090
question what do we mean what do we mean

00:00:42,720 --> 00:00:47,430
by good what it means back to be a good

00:00:45,090 --> 00:00:49,590
programming language and one way you can

00:00:47,430 --> 00:00:51,540
answer this is we can use a core

00:00:49,590 --> 00:00:53,730
framework known as utilitarianism and

00:00:51,540 --> 00:00:56,370
what utilitarian does is it equates

00:00:53,730 --> 00:00:59,190
morality with economics and essentially

00:00:56,370 --> 00:01:02,219
what it means is the the rule of the

00:00:59,190 --> 00:01:05,819
masses so let's turn it over to you and

00:01:02,219 --> 00:01:07,109
say is Python a good language put your

00:01:05,819 --> 00:01:10,740
hand everything python is a good

00:01:07,109 --> 00:01:11,999
language okay few hands going up a sort

00:01:10,740 --> 00:01:15,569
of fill but your hand if you think

00:01:11,999 --> 00:01:17,909
python is not a good language and have a

00:01:15,569 --> 00:01:19,979
few hands going up I think in this case

00:01:17,909 --> 00:01:21,990
in mob rule or utilitarianism to give it

00:01:19,979 --> 00:01:24,840
its fancy name we would argue that

00:01:21,990 --> 00:01:25,950
python is a good language we had a few

00:01:24,840 --> 00:01:28,170
more votes and we had a lot of people

00:01:25,950 --> 00:01:35,189
abstaining as well but the problem of

00:01:28,170 --> 00:01:37,740
democracy right so what I what I thought

00:01:35,189 --> 00:01:40,829
when I saw this question was really from

00:01:37,740 --> 00:01:43,399
an hour perspective python is a good

00:01:40,829 --> 00:01:47,340
exemplar of object-oriented programming

00:01:43,399 --> 00:01:49,289
but from an FP perspective python is not

00:01:47,340 --> 00:01:51,119
a very good language from that

00:01:49,289 --> 00:01:54,599
perspective it's not a very good FP

00:01:51,119 --> 00:01:56,999
language and and this got me thinking

00:01:54,599 --> 00:01:59,639
some more about the difference between

00:01:56,999 --> 00:02:02,310
our and FP i do a lot of training and

00:01:59,639 --> 00:02:03,659
one of the biggest problems we have is

00:02:02,310 --> 00:02:05,810
when we teach Skyler's we're not

00:02:03,659 --> 00:02:07,679
teaching syntax and things like that

00:02:05,810 --> 00:02:09,030
language features we're teaching a

00:02:07,679 --> 00:02:12,390
different mindset a different way of

00:02:09,030 --> 00:02:14,400
thinking about code thinking about FP

00:02:12,390 --> 00:02:15,780
the FP we're thinking about code versus

00:02:14,400 --> 00:02:21,000
we're thinking about Curt and getting

00:02:15,780 --> 00:02:23,819
people to make that jump so really what

00:02:21,000 --> 00:02:26,099
it means to be an FP programmer is the

00:02:23,819 --> 00:02:30,209
main topic I want to just explore in my

00:02:26,099 --> 00:02:32,040
talk so hopefully give some insight if

00:02:30,209 --> 00:02:35,879
you are learning Skyler yourself on how

00:02:32,040 --> 00:02:37,140
to think like an FB programmer or if you

00:02:35,879 --> 00:02:39,030
are teaching Skyler people if you're

00:02:37,140 --> 00:02:41,310
more senior person in the company then

00:02:39,030 --> 00:02:43,859
you often end up teaching people scholar

00:02:41,310 --> 00:02:45,989
this might give you some ideas on how to

00:02:43,859 --> 00:02:49,680
make easier to get people to transition

00:02:45,989 --> 00:02:51,780
from over to FK before we get into that

00:02:49,680 --> 00:02:54,480
good stuff I want to discuss some other

00:02:51,780 --> 00:02:58,340
ideas to give some context so I want to

00:02:54,480 --> 00:03:00,120
discuss some wild ideas from the 60s

00:02:58,340 --> 00:03:03,530
looking around the audience I don't

00:03:00,120 --> 00:03:06,090
think anyone remembers the 60s here but

00:03:03,530 --> 00:03:07,290
you know one person yeah so you're

00:03:06,090 --> 00:03:11,040
probably down in San Francisco in the

00:03:07,290 --> 00:03:12,629
summer of lava right so that when people

00:03:11,040 --> 00:03:14,340
think the 6th ed probably think of like

00:03:12,629 --> 00:03:15,989
the summer lab San Francisco maybe the

00:03:14,340 --> 00:03:20,010
Beatles you know maybe Woodstock that

00:03:15,989 --> 00:03:22,139
sort of thing I won't discuss some other

00:03:20,010 --> 00:03:25,650
kind of crazy ideas these ideas coming

00:03:22,139 --> 00:03:30,269
out of Paris in the 60s so firstly in

00:03:25,650 --> 00:03:31,199
the taxonomy of angels right you've

00:03:30,269 --> 00:03:35,120
probably given some thought at some

00:03:31,199 --> 00:03:37,530
point time to the kind of how you would

00:03:35,120 --> 00:03:40,049
structure angels in two species and is

00:03:37,530 --> 00:03:42,510
argument that coming out of Paris was

00:03:40,049 --> 00:03:44,459
that each angels is a species unto

00:03:42,510 --> 00:03:47,909
itself because angels do not have

00:03:44,459 --> 00:03:49,500
material being and I've been in material

00:03:47,909 --> 00:03:51,900
objects we can't distinguish them an

00:03:49,500 --> 00:03:53,489
essay of different species so the

00:03:51,900 --> 00:03:57,379
argument is that every angel is of a

00:03:53,489 --> 00:03:59,370
unique species that's interesting one

00:03:57,379 --> 00:04:03,900
like know how that jibe with your

00:03:59,370 --> 00:04:06,389
thoughts about angels another thought on

00:04:03,900 --> 00:04:08,489
the nature of intellect by a similar

00:04:06,389 --> 00:04:10,379
argument we can say that humans share

00:04:08,489 --> 00:04:11,459
one intellect so I don't actually need

00:04:10,379 --> 00:04:13,500
to give you this thought because you

00:04:11,459 --> 00:04:15,150
know it already so the human intellect

00:04:13,500 --> 00:04:17,849
has no material substance as we all know

00:04:15,150 --> 00:04:20,159
and since there is no material substance

00:04:17,849 --> 00:04:22,529
there can only be one internet because

00:04:20,159 --> 00:04:24,599
we cannot distinguish these immaterial

00:04:22,529 --> 00:04:27,930
things otherwise so is only one human

00:04:24,599 --> 00:04:28,350
intellect and possibly one of the most

00:04:27,930 --> 00:04:31,500
in

00:04:28,350 --> 00:04:34,470
testing ideas on the immovable T of the

00:04:31,500 --> 00:04:36,060
universe have you ever laid awake at

00:04:34,470 --> 00:04:39,060
night wondering if God can move the

00:04:36,060 --> 00:04:40,650
universe in a straight line again you're

00:04:39,060 --> 00:04:42,660
all educated people so I'm sure as you

00:04:40,650 --> 00:04:45,060
know following Aristotle that vacuum is

00:04:42,660 --> 00:04:46,500
impossible so if God were to move the

00:04:45,060 --> 00:04:48,890
universe there would be a vacuum where

00:04:46,500 --> 00:04:53,880
the universe was and therefore this

00:04:48,890 --> 00:04:56,790
would be an impossible thing to do okay

00:04:53,880 --> 00:04:57,960
at this point I probably ought to fess

00:04:56,790 --> 00:05:00,240
up and tell you that when I'm talking

00:04:57,960 --> 00:05:03,840
about the 60s I'm talking about the 12

00:05:00,240 --> 00:05:05,880
60s here not the 1960s and so the idea

00:05:03,840 --> 00:05:08,520
is I've been put up in the board where

00:05:05,880 --> 00:05:10,170
some of the ideas that came from Thomas

00:05:08,520 --> 00:05:12,500
Aquinas st. thomas aquinas who I've

00:05:10,170 --> 00:05:14,370
learned that's a different name in

00:05:12,500 --> 00:05:16,140
probably your native language you may

00:05:14,370 --> 00:05:18,570
not only know who I'm talking about and

00:05:16,140 --> 00:05:21,870
other people known as the Latin a very

00:05:18,570 --> 00:05:25,290
West who at the University of Paris in

00:05:21,870 --> 00:05:28,170
the 13th century and so one thing you

00:05:25,290 --> 00:05:30,510
could be pretty certain of in the middle

00:05:28,170 --> 00:05:32,970
ages if you had crazy ideas you ought to

00:05:30,510 --> 00:05:36,930
expect the Inquisition and that is

00:05:32,970 --> 00:05:39,630
exactly what happened in 1270 the bishop

00:05:36,930 --> 00:05:41,430
of paris rotis condom nations saying you

00:05:39,630 --> 00:05:42,870
were not allowed to think some of the

00:05:41,430 --> 00:05:46,470
ideas the ideas I've shown previously

00:05:42,870 --> 00:05:49,350
and some additional ideas here just a

00:05:46,470 --> 00:05:50,760
few set examples the soul separated from

00:05:49,350 --> 00:05:53,040
the body by death cannot suffer from

00:05:50,760 --> 00:05:55,500
bodily fire and we're never given much

00:05:53,040 --> 00:05:57,270
thought to that one God cannot grant

00:05:55,500 --> 00:05:59,010
immortality in incorruption to a mortal

00:05:57,270 --> 00:06:00,600
incredible thing God does not know

00:05:59,010 --> 00:06:02,850
singulars individual objects of

00:06:00,600 --> 00:06:07,200
creatures then God doesn't know things

00:06:02,850 --> 00:06:09,240
other than himself right so this was one

00:06:07,200 --> 00:06:11,610
of I think three condemnation that were

00:06:09,240 --> 00:06:13,650
made in Paris in 13th century and you

00:06:11,610 --> 00:06:15,600
want more insight into the crazy source

00:06:13,650 --> 00:06:20,220
of Middle Ages go have a really them

00:06:15,600 --> 00:06:21,810
they're quite interesting but there is

00:06:20,220 --> 00:06:23,580
serious point to all this and I think

00:06:21,810 --> 00:06:27,300
what is interesting about these ideas is

00:06:23,580 --> 00:06:30,510
they're not ideas where we look at one

00:06:27,300 --> 00:06:32,610
wassup we go Mego that that's wrong or

00:06:30,510 --> 00:06:34,980
that's right there are a bunch of ideas

00:06:32,610 --> 00:06:37,910
I don't ask don't even make sense to be

00:06:34,980 --> 00:06:40,770
talking about so that lets of go back

00:06:37,910 --> 00:06:42,709
the immutability of the universe that if

00:06:40,770 --> 00:06:45,979
you

00:06:42,709 --> 00:06:49,949
first in modern physics of postern Stein

00:06:45,979 --> 00:06:52,289
physics we would talk about you know

00:06:49,949 --> 00:06:55,860
corner systems relativity i would say

00:06:52,289 --> 00:06:58,079
that there is no way you could observe

00:06:55,860 --> 00:06:59,849
the universe moving there's no frame of

00:06:58,079 --> 00:07:00,839
reference outside of the universe of

00:06:59,849 --> 00:07:03,539
which you could observe the universe

00:07:00,839 --> 00:07:06,479
moving the universe creates space as it

00:07:03,539 --> 00:07:08,339
expands it doesn't make sense to talk

00:07:06,479 --> 00:07:11,279
about moving universe within space

00:07:08,339 --> 00:07:13,110
because the universe is space so there's

00:07:11,279 --> 00:07:16,319
no external frame of reference which you

00:07:13,110 --> 00:07:18,929
could see if the universe was moving all

00:07:16,319 --> 00:07:22,469
right great and similarly when we talk

00:07:18,929 --> 00:07:23,819
about the taxonomy of angels species for

00:07:22,469 --> 00:07:28,189
us is something that only makes sense

00:07:23,819 --> 00:07:30,479
when you have DNA and breeding and so on

00:07:28,189 --> 00:07:32,639
and if you say that angels are

00:07:30,479 --> 00:07:34,469
supernatural creatures then there's even

00:07:32,639 --> 00:07:36,419
if you whether you believe in angels are

00:07:34,469 --> 00:07:38,399
not if you so accept that angels were to

00:07:36,419 --> 00:07:40,049
be supernatural creatures then there's

00:07:38,399 --> 00:07:42,360
no reason that they should have any kind

00:07:40,049 --> 00:07:43,860
of species similar to biological

00:07:42,360 --> 00:07:45,839
creatures because if their supernatural

00:07:43,860 --> 00:07:47,669
then they are not constrained by the

00:07:45,839 --> 00:07:49,949
rules of biology so talking about

00:07:47,669 --> 00:07:51,959
species of angels as a concept doesn't

00:07:49,949 --> 00:07:56,159
even make sense from our modern biology

00:07:51,959 --> 00:08:00,179
point of view all right what anyone

00:07:56,159 --> 00:08:03,389
disagree with others okay okay for a one

00:08:00,179 --> 00:08:06,029
people here so you know this is kind of

00:08:03,389 --> 00:08:08,819
an interesting interesting way of is

00:08:06,029 --> 00:08:09,599
looking at these ideas as not even ideas

00:08:08,819 --> 00:08:12,659
that are wrong they just don't make

00:08:09,599 --> 00:08:15,179
sense to talk about and to get a feel

00:08:12,659 --> 00:08:18,419
for what this means I think we need to

00:08:15,179 --> 00:08:20,819
turn to some more wild ideas from the

00:08:18,419 --> 00:08:21,749
six days but in this case I'm talking

00:08:20,819 --> 00:08:23,729
about the 60s that might be more

00:08:21,749 --> 00:08:27,119
familiar to some of us I'm talked about

00:08:23,729 --> 00:08:29,369
in 1962 specifically and this book the

00:08:27,119 --> 00:08:31,499
structure of scientific revolutions by a

00:08:29,369 --> 00:08:34,169
guy called Thomas cone I'll just picture

00:08:31,499 --> 00:08:36,149
of hands who has heard of Thomas Colonel

00:08:34,169 --> 00:08:41,059
structure of scientific revolutions okay

00:08:36,149 --> 00:08:41,059
few hands going up not so many all right

00:08:41,719 --> 00:08:47,269
so this was quite a landmark in the

00:08:43,959 --> 00:08:49,430
philosophy of science up until then

00:08:47,269 --> 00:08:52,879
people have viewed science is a very

00:08:49,430 --> 00:08:54,410
kind of feminist express s where

00:08:52,879 --> 00:08:59,829
knowledge just increased increased

00:08:54,410 --> 00:09:04,819
without end kind of you that popper was

00:08:59,829 --> 00:09:06,379
associated with and in Thomas comes view

00:09:04,819 --> 00:09:08,870
signs was a little bit more complicated

00:09:06,379 --> 00:09:10,810
than this and he said that signs

00:09:08,870 --> 00:09:13,639
basically went through two main phases

00:09:10,810 --> 00:09:15,529
the first main phase called normal

00:09:13,639 --> 00:09:16,970
science that's the good times when

00:09:15,529 --> 00:09:19,399
you're running around your lab coats and

00:09:16,970 --> 00:09:21,709
you're doing experiments and all of your

00:09:19,399 --> 00:09:23,149
experiments building on some existing

00:09:21,709 --> 00:09:27,079
theory and adding new knowledge and

00:09:23,149 --> 00:09:28,550
everything's good that's great and then

00:09:27,079 --> 00:09:31,819
there's when things got a little bit

00:09:28,550 --> 00:09:33,649
awry and we have what's called a

00:09:31,819 --> 00:09:37,040
revolution which seems to be a theme of

00:09:33,649 --> 00:09:39,139
this conference and this is where you're

00:09:37,040 --> 00:09:42,740
producing was also don't really jibe

00:09:39,139 --> 00:09:44,899
with your existing theories so we had

00:09:42,740 --> 00:09:47,089
example of that at the turn of the 20th

00:09:44,899 --> 00:09:48,470
century with relativity in quantum

00:09:47,089 --> 00:09:50,569
physics where people with discovering

00:09:48,470 --> 00:09:52,370
results I didn't ready coincide with

00:09:50,569 --> 00:09:54,759
Newtonian physics earlier than that we

00:09:52,370 --> 00:09:57,410
had no Newtonian physics and the

00:09:54,759 --> 00:10:01,040
Ptolemaic astronomy is everything

00:09:57,410 --> 00:10:03,230
revolves around the Sun and basically

00:10:01,040 --> 00:10:05,120
you had a situation where your

00:10:03,230 --> 00:10:07,009
experimental results cannot be explained

00:10:05,120 --> 00:10:09,829
by existing theory and you need to come

00:10:07,009 --> 00:10:11,809
up with a new theory now this is not a

00:10:09,829 --> 00:10:14,329
silent process like I sort of

00:10:11,809 --> 00:10:18,110
Illustrated here it only takes quite a

00:10:14,329 --> 00:10:19,759
period of time but you do have this time

00:10:18,110 --> 00:10:23,930
we're basically a new theory is

00:10:19,759 --> 00:10:27,069
established and Thomas can coin the word

00:10:23,930 --> 00:10:29,360
phrase for this which is paradigm shift

00:10:27,069 --> 00:10:31,819
beloved of manages everywhere these days

00:10:29,360 --> 00:10:34,100
so next time you're in a meeting and

00:10:31,819 --> 00:10:36,680
some senior manager says we need to

00:10:34,100 --> 00:10:38,329
complete paradigm shift if you're happy

00:10:36,680 --> 00:10:43,250
in your soul that you have a philosopher

00:10:38,329 --> 00:10:46,250
guiding your company and one of the

00:10:43,250 --> 00:10:48,410
things about these paradigm shifts and

00:10:46,250 --> 00:10:50,839
these different paradigms again a

00:10:48,410 --> 00:10:54,139
technical term here in Thomas Kuhns

00:10:50,839 --> 00:10:55,209
writing is said to be incommensurate and

00:10:54,139 --> 00:10:58,089
what this means is

00:10:55,209 --> 00:11:00,069
from one paradigm you can't really

00:10:58,089 --> 00:11:02,619
understand people operating it another

00:11:00,069 --> 00:11:05,079
another paradigm so a paradigm is a way

00:11:02,619 --> 00:11:07,329
of viewing the world a sort of a

00:11:05,079 --> 00:11:10,119
fundament Center fundamental assumptions

00:11:07,329 --> 00:11:11,679
you make about the world and trying to

00:11:10,119 --> 00:11:14,160
communicate across paradigms is very

00:11:11,679 --> 00:11:16,240
different like we saw with those

00:11:14,160 --> 00:11:18,040
statements from the Middle Ages they

00:11:16,240 --> 00:11:19,269
just don't make sense device it doesn't

00:11:18,040 --> 00:11:21,040
make sense to talk about moving the

00:11:19,269 --> 00:11:24,339
universe because in our paradigm of

00:11:21,040 --> 00:11:28,179
physics where there's no reference point

00:11:24,339 --> 00:11:30,879
outside of the universe and similarly

00:11:28,179 --> 00:11:32,319
from our modern biology talking about

00:11:30,879 --> 00:11:35,800
species of angels is that there's a

00:11:32,319 --> 00:11:37,629
nonsensical thing so this is this idea

00:11:35,800 --> 00:11:42,639
of incommensurate you can't communicate

00:11:37,629 --> 00:11:44,679
across these paradigms very easily and I

00:11:42,639 --> 00:11:48,429
see a similar thing when we look at our

00:11:44,679 --> 00:11:51,100
and FP languages so let's just take a

00:11:48,429 --> 00:11:57,369
little detour to look at the structure

00:11:51,100 --> 00:11:58,959
of programming revolutions right so do

00:11:57,369 --> 00:12:02,049
my mind have been three main programming

00:11:58,959 --> 00:12:03,639
revolutions the first was the structured

00:12:02,049 --> 00:12:06,339
programming revelation which started in

00:12:03,639 --> 00:12:08,879
the 50s you might say is landmark

00:12:06,339 --> 00:12:11,970
statement was go to consider harmful

00:12:08,879 --> 00:12:14,649
1968 anyone read that side of interest

00:12:11,970 --> 00:12:17,949
okay more hands-on I spector going on

00:12:14,649 --> 00:12:20,379
that's cool and by the 98th is the

00:12:17,949 --> 00:12:22,809
dominated industry so you see in pasco

00:12:20,379 --> 00:12:24,399
turbo pascal all that kind of stuff so

00:12:22,809 --> 00:12:27,699
structure programmers basically taking

00:12:24,399 --> 00:12:28,990
the wild and crazy days of assembler and

00:12:27,699 --> 00:12:30,670
trying to put some structure under the

00:12:28,990 --> 00:12:32,160
control flow they gave us for loops and

00:12:30,670 --> 00:12:38,170
while loops and all this kind of stuff

00:12:32,160 --> 00:12:40,149
as a main innovation there and the next

00:12:38,170 --> 00:12:43,509
main the paradigm shift object-oriented

00:12:40,149 --> 00:12:47,459
programming started in 60s I think 1967

00:12:43,509 --> 00:12:50,709
was the first over language similar 67

00:12:47,459 --> 00:12:52,420
reached possibly its landmark in 83

00:12:50,709 --> 00:12:55,929
small talk 83 which might have been sort

00:12:52,420 --> 00:12:59,170
of the only true although the first true

00:12:55,929 --> 00:13:02,319
oo system and by certainly the late 90s

00:12:59,170 --> 00:13:05,699
it dominated industry C++ and Java type

00:13:02,319 --> 00:13:09,749
of thing the first Internet boom

00:13:05,699 --> 00:13:12,480
and the third main paradigm shift I give

00:13:09,749 --> 00:13:15,480
you is functional programming now we

00:13:12,480 --> 00:13:17,459
might say that FP started in the 50s

00:13:15,480 --> 00:13:19,139
with less but i think the ideas were

00:13:17,459 --> 00:13:22,199
really first articulated in the

00:13:19,139 --> 00:13:26,600
mid-seventies scheme over in boston MIT

00:13:22,199 --> 00:13:29,879
ml in edinburgh and here are some of the

00:13:26,600 --> 00:13:32,879
points along the journey 1991 Haskell

00:13:29,879 --> 00:13:34,169
was created 95 was when monads were

00:13:32,879 --> 00:13:37,739
first introduced to the programming

00:13:34,169 --> 00:13:40,829
world in Phil Wilders paper 2007 a

00:13:37,739 --> 00:13:42,299
picutre functors came along and one

00:13:40,829 --> 00:13:45,209
thing to note about this is that these

00:13:42,299 --> 00:13:48,239
dates are much more recent then we saw

00:13:45,209 --> 00:13:50,850
for the previous ones right I could put

00:13:48,239 --> 00:13:52,589
fremont ads on there and sort of 2008 i

00:13:50,850 --> 00:13:55,709
think so a lot this stuff is actually

00:13:52,589 --> 00:13:59,339
very very new being developed right now

00:13:55,709 --> 00:14:01,889
you could say and I believe that this

00:13:59,339 --> 00:14:04,699
functional programming is a revolution

00:14:01,889 --> 00:14:08,369
that is sweeping our industry right now

00:14:04,699 --> 00:14:10,769
and if you look across the industry

00:14:08,369 --> 00:14:14,999
everywhere is turning FP so obviously

00:14:10,769 --> 00:14:17,639
scala JVM javascript local systems

00:14:14,999 --> 00:14:18,929
programming rusts they're bringing

00:14:17,639 --> 00:14:23,970
functional programming concepts into

00:14:18,929 --> 00:14:25,589
their Swift on iOS javascript as usual

00:14:23,970 --> 00:14:27,660
has a thousand ideas springing up we've

00:14:25,589 --> 00:14:30,239
got elm and pure script a few languages

00:14:27,660 --> 00:14:31,829
targeting javascript but also things

00:14:30,239 --> 00:14:34,470
like flow and react coming out of

00:14:31,829 --> 00:14:36,799
facebook which are bringing FP ideas

00:14:34,470 --> 00:14:39,149
into a more mainstream javascript world

00:14:36,799 --> 00:14:41,879
distributed systems allows been there

00:14:39,149 --> 00:14:43,499
for a while and pony a very interesting

00:14:41,879 --> 00:14:45,749
new language showing that you can put

00:14:43,499 --> 00:14:50,309
types on actors and needs a very

00:14:45,749 --> 00:14:53,039
interesting stuff there so to argue that

00:14:50,309 --> 00:14:54,660
really AFP is the change happening right

00:14:53,039 --> 00:14:56,989
now we're leaving through this paradigm

00:14:54,660 --> 00:14:59,369
shift our industry going from 0 to FP

00:14:56,989 --> 00:15:02,399
and a natural question to ask from that

00:14:59,369 --> 00:15:04,199
then is what is the FP paradigm what are

00:15:02,399 --> 00:15:09,239
the basic assumptions and FP programmer

00:15:04,199 --> 00:15:11,009
makes how do they view code and it's

00:15:09,239 --> 00:15:13,289
importantly for a lot of us if you've

00:15:11,009 --> 00:15:14,459
come from an oo background how do you

00:15:13,289 --> 00:15:18,390
make the change how do you make that

00:15:14,459 --> 00:15:21,690
jump across the paradigms from LA to FB

00:15:18,390 --> 00:15:25,980
all right that's what I want to look at

00:15:21,690 --> 00:15:28,440
now spend most of my time so I said that

00:15:25,980 --> 00:15:31,620
paradigm with the fundamental

00:15:28,440 --> 00:15:32,670
assumptions that you make we talked

00:15:31,620 --> 00:15:35,450
about like a little bit about the

00:15:32,670 --> 00:15:38,760
physics paradigm in relativity and so on

00:15:35,450 --> 00:15:40,170
biology but what are the kind of

00:15:38,760 --> 00:15:43,970
fundamental assumptions we make in

00:15:40,170 --> 00:15:48,090
programming and I think for a programmer

00:15:43,970 --> 00:15:50,190
these come down to what we think of the

00:15:48,090 --> 00:15:54,300
the kind of basic atomic units of

00:15:50,190 --> 00:15:56,100
programs they are and also an aesthetic

00:15:54,300 --> 00:15:57,930
which guides us when we have many

00:15:56,100 --> 00:15:59,310
possible design decisions which ones do

00:15:57,930 --> 00:16:02,460
we choose what are the kind of

00:15:59,310 --> 00:16:04,020
principles at good code holds this sort

00:16:02,460 --> 00:16:05,430
of comes back to talking about python is

00:16:04,020 --> 00:16:06,960
it a good language you know it's good

00:16:05,430 --> 00:16:12,090
for my own perspective but it's not good

00:16:06,960 --> 00:16:13,920
from an FP perspective so i may be able

00:16:12,090 --> 00:16:16,860
to think about these that anyone like to

00:16:13,920 --> 00:16:20,370
suggest what you think oo programmer

00:16:16,860 --> 00:16:22,320
thinks of code consisting of or programs

00:16:20,370 --> 00:16:24,510
consisting of what are the sort of units

00:16:22,320 --> 00:16:28,430
or the most important features to think

00:16:24,510 --> 00:16:36,020
about code any suggestions in the crowd

00:16:28,430 --> 00:16:36,020
sorry constructors yeah anything else

00:16:36,560 --> 00:16:42,120
tough crowd here okay objects maybe

00:16:40,050 --> 00:16:45,720
they're kind of important I wheless

00:16:42,120 --> 00:16:50,220
programming yeah what else had had

00:16:45,720 --> 00:16:53,550
objects interact right yeah it's a

00:16:50,220 --> 00:16:56,190
message passing and I would say the

00:16:53,550 --> 00:16:58,350
other main thing is polymorphism so we

00:16:56,190 --> 00:17:00,060
have objects objects interact by passing

00:16:58,350 --> 00:17:02,280
messages to each other and polymorphism

00:17:00,060 --> 00:17:04,620
means that many different types of

00:17:02,280 --> 00:17:07,440
objects can handle the same message I

00:17:04,620 --> 00:17:08,699
think I sir you know it's something that

00:17:07,440 --> 00:17:09,990
it's not precisely defined and you

00:17:08,699 --> 00:17:12,480
sometimes get into these kind of like

00:17:09,990 --> 00:17:14,070
biblical scholars tracing through the

00:17:12,480 --> 00:17:15,810
writings of Alan Kay to discern the true

00:17:14,070 --> 00:17:18,839
nature of the object oriented

00:17:15,810 --> 00:17:21,810
programming it's I'd like to avoid that

00:17:18,839 --> 00:17:24,690
already just focus on how people talk

00:17:21,810 --> 00:17:25,709
about over in in practice and I tell you

00:17:24,690 --> 00:17:28,320
these are pretty than make the main

00:17:25,709 --> 00:17:29,539
features and then how do we decide if

00:17:28,320 --> 00:17:31,820
like a

00:17:29,539 --> 00:17:34,509
our program is good what guides us

00:17:31,820 --> 00:17:39,710
towards good code anyone have

00:17:34,509 --> 00:17:41,090
suggestions there right okay I mean I

00:17:39,710 --> 00:17:42,379
there's some sort of principles that you

00:17:41,090 --> 00:17:46,879
can boil it down to what does it mean

00:17:42,379 --> 00:17:49,999
for code to be maintainable all or okay

00:17:46,879 --> 00:17:57,139
yeah that's I pants cool capsulation

00:17:49,999 --> 00:17:58,850
yeah anything else yeah all right so

00:17:57,139 --> 00:18:00,679
there are few things liskov substitution

00:17:58,850 --> 00:18:02,570
principle might be something at people

00:18:00,679 --> 00:18:05,509
heard of single responsibly principles

00:18:02,570 --> 00:18:07,159
solid principles design patterns and

00:18:05,509 --> 00:18:08,479
capitation mentioned right here in some

00:18:07,159 --> 00:18:10,820
coupling these type of things so they're

00:18:08,479 --> 00:18:14,179
these kind of principles that can guide

00:18:10,820 --> 00:18:16,159
us now what I think is interesting about

00:18:14,179 --> 00:18:18,529
these and this is a bit of a parent

00:18:16,159 --> 00:18:21,830
tentacle note but still interesting is

00:18:18,529 --> 00:18:23,749
that these descriptions are informal so

00:18:21,830 --> 00:18:25,549
what does it mean for code to be well

00:18:23,749 --> 00:18:27,700
encapsulated or code to have a single

00:18:25,549 --> 00:18:31,879
responsibility it's kind of it

00:18:27,700 --> 00:18:34,789
informally defined and also the the

00:18:31,879 --> 00:18:36,590
model of the way the people think about

00:18:34,789 --> 00:18:38,330
code is kind of anthropomorphic people

00:18:36,590 --> 00:18:40,940
talk about objects they talk about in

00:18:38,330 --> 00:18:43,519
this area sort of Allied active entities

00:18:40,940 --> 00:18:45,710
passing messages to each other which i

00:18:43,519 --> 00:18:47,869
think is interesting and the other thing

00:18:45,710 --> 00:18:52,220
is that the the meaning of programs is

00:18:47,869 --> 00:18:53,389
often determined at runtime so it's very

00:18:52,220 --> 00:18:55,879
much a dynamic model because a

00:18:53,389 --> 00:18:57,859
polymorphism what an object does was a

00:18:55,879 --> 00:18:59,720
method very message when you pass that

00:18:57,859 --> 00:19:03,019
message is up to the objects no it's not

00:18:59,720 --> 00:19:05,679
something you necessarily know at by

00:19:03,019 --> 00:19:09,200
statically looking at your code and this

00:19:05,679 --> 00:19:10,669
motivates things like the small talk

00:19:09,200 --> 00:19:11,989
debugging experience where you can jump

00:19:10,669 --> 00:19:13,580
right into running code and make

00:19:11,989 --> 00:19:15,200
alterations to the code and immediately

00:19:13,580 --> 00:19:19,570
get it running again so it's a very

00:19:15,200 --> 00:19:22,609
dynamic view of the meaning of programs

00:19:19,570 --> 00:19:25,369
when we look at a functional program

00:19:22,609 --> 00:19:29,269
programming I think is quite a different

00:19:25,369 --> 00:19:32,090
way of looking at code so the main thing

00:19:29,269 --> 00:19:34,249
that you look at doing in functional

00:19:32,090 --> 00:19:35,720
programming is transforming data so the

00:19:34,249 --> 00:19:40,759
main thing is just about the only thing

00:19:35,720 --> 00:19:42,499
you do so rather than viewing code is

00:19:40,759 --> 00:19:43,010
made out of objects and active entities

00:19:42,499 --> 00:19:46,670
talk

00:19:43,010 --> 00:19:48,170
to one another it's a transformation

00:19:46,670 --> 00:19:49,670
from some input to some output that's

00:19:48,170 --> 00:19:54,670
what a function basically is you give an

00:19:49,670 --> 00:19:57,410
input you get an output and if I had to

00:19:54,670 --> 00:19:59,690
boil down functional programming into

00:19:57,410 --> 00:20:01,520
the key principles because of key

00:19:59,690 --> 00:20:05,150
aesthetically tells you what it what is

00:20:01,520 --> 00:20:07,820
good or key things we believe in I would

00:20:05,150 --> 00:20:09,920
come up with simplicity and static

00:20:07,820 --> 00:20:12,740
reasoning and these these deserve some

00:20:09,920 --> 00:20:16,430
more explanation so let's let's talk

00:20:12,740 --> 00:20:19,580
about simplicity first many languages

00:20:16,430 --> 00:20:21,170
claim to be simple haskell may be simple

00:20:19,580 --> 00:20:23,570
go claims to be simple but they're very

00:20:21,170 --> 00:20:25,460
different languages and simplicity is

00:20:23,570 --> 00:20:28,130
often something people use as a weapon

00:20:25,460 --> 00:20:31,970
to say my code is simple your code is

00:20:28,130 --> 00:20:34,160
not and usually what people mean when

00:20:31,970 --> 00:20:38,390
they say the type of thing is my code

00:20:34,160 --> 00:20:39,620
uses concepts I'm familiar with and I am

00:20:38,390 --> 00:20:41,810
not familiar with the way you've written

00:20:39,620 --> 00:20:43,340
your code so if we can have a meaningful

00:20:41,810 --> 00:20:45,350
discussion about simplicity we need to

00:20:43,340 --> 00:20:48,530
have a definition that's reasonably

00:20:45,350 --> 00:20:51,410
precise in goes beyond just familiarity

00:20:48,530 --> 00:20:54,800
and as a distinguished between sager in

00:20:51,410 --> 00:20:57,950
haskell so the definition of simplicity

00:20:54,800 --> 00:21:01,250
I want to use is we have as few concepts

00:20:57,950 --> 00:21:03,920
as possible and are all scales so is

00:21:01,250 --> 00:21:07,010
this scalability argument which

00:21:03,920 --> 00:21:10,190
distinguishes go and haskell so go has

00:21:07,010 --> 00:21:11,900
few concepts of the low level but at the

00:21:10,190 --> 00:21:16,340
high level let's say say does write more

00:21:11,900 --> 00:21:20,360
code repeat yourself probably approach

00:21:16,340 --> 00:21:24,830
the Haskell takes example so let's look

00:21:20,360 --> 00:21:29,570
at how that plays out in in Scala say

00:21:24,830 --> 00:21:30,980
and look at some both a low-level encode

00:21:29,570 --> 00:21:34,700
a know you have a high level and

00:21:30,980 --> 00:21:37,700
structuring code so one place we can see

00:21:34,700 --> 00:21:40,730
this at the low level is in control

00:21:37,700 --> 00:21:45,230
structures so in your typical over

00:21:40,730 --> 00:21:46,820
language you following structure program

00:21:45,230 --> 00:21:48,800
and you probably have 4 loops while

00:21:46,820 --> 00:21:54,590
loops you wire loops and you have the

00:21:48,800 --> 00:21:56,990
kurjan and in a typical FP language you

00:21:54,590 --> 00:21:58,490
have a cosian because recursion

00:21:56,990 --> 00:22:00,500
you can do everything you can do with a

00:21:58,490 --> 00:22:02,870
for loop and a while loop or do loop so

00:22:00,500 --> 00:22:05,360
why introduce additional concepts when

00:22:02,870 --> 00:22:07,370
you don't have to do so that's one way

00:22:05,360 --> 00:22:12,980
that this desire to minimize concepts

00:22:07,370 --> 00:22:15,440
plays out on the small level of code at

00:22:12,980 --> 00:22:18,679
the higher level we look at abstraction

00:22:15,440 --> 00:22:22,670
so for example if we have types lists

00:22:18,679 --> 00:22:25,490
option future we say what can we say

00:22:22,670 --> 00:22:28,280
about all of these types what can we say

00:22:25,490 --> 00:22:30,500
they have a comment in your typical our

00:22:28,280 --> 00:22:32,000
language the answer is nothing you don't

00:22:30,500 --> 00:22:35,840
say anything about them they have in

00:22:32,000 --> 00:22:39,730
common and in a language like Scala you

00:22:35,840 --> 00:22:41,780
may say they're all monads for example

00:22:39,730 --> 00:22:44,020
you need some language features to make

00:22:41,780 --> 00:22:50,320
us work in high kind of types in there

00:22:44,020 --> 00:22:52,190
but it's the main the main thing here is

00:22:50,320 --> 00:22:53,600
abstractions allow us to make things

00:22:52,190 --> 00:22:56,150
different things that are different the

00:22:53,600 --> 00:22:59,360
same so we can say these all these

00:22:56,150 --> 00:23:00,800
different concepts are all monads and I

00:22:59,360 --> 00:23:03,170
think in functional programming there is

00:23:00,800 --> 00:23:05,210
that kind of bias towards finding

00:23:03,170 --> 00:23:07,340
abstractions functional programmers love

00:23:05,210 --> 00:23:09,080
abstractions because it allows them to

00:23:07,340 --> 00:23:10,970
reduce the number of concepts I deal

00:23:09,080 --> 00:23:12,170
with instead of having list an option

00:23:10,970 --> 00:23:13,670
than futures you can just say they're

00:23:12,170 --> 00:23:15,820
just a Mon out they have this interface

00:23:13,670 --> 00:23:22,370
you can interact with them in this way

00:23:15,820 --> 00:23:27,140
which is nice ok let's look at something

00:23:22,370 --> 00:23:29,929
else let's look at how people understand

00:23:27,140 --> 00:23:31,580
their programs so something called the

00:23:29,929 --> 00:23:33,470
substitution model of evaluation in

00:23:31,580 --> 00:23:35,750
functional programming I'm going to ask

00:23:33,470 --> 00:23:38,059
you some questions now and before we get

00:23:35,750 --> 00:23:40,100
those questions I wanna say they're not

00:23:38,059 --> 00:23:41,300
trick questions okay I have an obvious

00:23:40,100 --> 00:23:45,170
answer the obvious answer the correct

00:23:41,300 --> 00:23:46,640
one and also when I ask these questions

00:23:45,170 --> 00:23:48,830
in New York they had a very difficult

00:23:46,640 --> 00:23:52,160
time answering which reflects poorly on

00:23:48,830 --> 00:23:53,720
the US education system I want you to

00:23:52,160 --> 00:23:56,030
show me that the European education

00:23:53,720 --> 00:24:00,170
system is far superior to the u.s.

00:23:56,030 --> 00:24:03,350
education system all right so let's look

00:24:00,170 --> 00:24:06,400
at this program one plus one can anyone

00:24:03,350 --> 00:24:08,870
tell me what this program evaluates to

00:24:06,400 --> 00:24:10,270
am i hearing that the death of European

00:24:08,870 --> 00:24:15,070
the European education

00:24:10,270 --> 00:24:18,230
anyone with an answer to thank you okay

00:24:15,070 --> 00:24:21,500
you're absolutely correct one plus one

00:24:18,230 --> 00:24:23,030
evaluates to two right okay now I'm

00:24:21,500 --> 00:24:24,860
gonna get little bit harder now but I'm

00:24:23,030 --> 00:24:28,870
think you guys can do this what about

00:24:24,860 --> 00:24:32,870
one plus one plus one plus one right

00:24:28,870 --> 00:24:38,030
okay we got it two plus two yeah all

00:24:32,870 --> 00:24:40,340
right two plus two or four now the point

00:24:38,030 --> 00:24:42,919
about this is within the substitution

00:24:40,340 --> 00:24:45,169
model of evaluation when you see an

00:24:42,919 --> 00:24:46,700
expression you can substitute in its

00:24:45,169 --> 00:24:48,950
value and you don't change the meaning

00:24:46,700 --> 00:24:50,780
of the program so whenever you see 1

00:24:48,950 --> 00:24:53,419
plus 1 which is equal to 2 you can

00:24:50,780 --> 00:24:56,059
substitute into so here we have one plus

00:24:53,419 --> 00:24:57,590
one plus one plus one and if

00:24:56,059 --> 00:25:00,919
substitution holds we know that one plus

00:24:57,590 --> 00:25:02,870
one is two we can substitute into and we

00:25:00,919 --> 00:25:06,860
get two plus two and as you correctly

00:25:02,870 --> 00:25:08,870
told me two plus two is four and that is

00:25:06,860 --> 00:25:10,340
how a functional program thinks about

00:25:08,870 --> 00:25:13,610
the meaning of their programs you can

00:25:10,340 --> 00:25:19,400
substitute in the value of an expression

00:25:13,610 --> 00:25:21,110
for the expression now substitution is

00:25:19,400 --> 00:25:23,570
simple using the definition I gave

00:25:21,110 --> 00:25:24,799
earlier because we try very hard as

00:25:23,570 --> 00:25:26,720
functional programs to maintain

00:25:24,799 --> 00:25:29,450
substitution one rule for thinking about

00:25:26,720 --> 00:25:30,860
how the meaning of our programs and this

00:25:29,450 --> 00:25:33,110
is why we have things like more ads in

00:25:30,860 --> 00:25:37,390
that so we can delay effects so we can

00:25:33,110 --> 00:25:39,530
maintain substitution the other thing i

00:25:37,390 --> 00:25:41,330
believe that i'm not sure the evidence

00:25:39,530 --> 00:25:43,429
supports is that substitution it's easy

00:25:41,330 --> 00:25:45,590
for people i hope you will learn this in

00:25:43,429 --> 00:25:47,720
primary school though the delay in the

00:25:45,590 --> 00:25:50,900
answer makes me a little bit worried you

00:25:47,720 --> 00:25:52,700
got there in the end so in theory and

00:25:50,900 --> 00:25:54,380
the point i put these really simple

00:25:52,700 --> 00:25:57,440
trivial examples up is to show you that

00:25:54,380 --> 00:25:59,090
this stuff is very easy substitution is

00:25:57,440 --> 00:26:01,429
no more complicated than doing that

00:25:59,090 --> 00:26:03,260
primary school level math and that is

00:26:01,429 --> 00:26:06,039
the point the point is it's trivial

00:26:03,260 --> 00:26:07,940
that's why we strive to maintain

00:26:06,039 --> 00:26:09,470
substitution because it makes our life

00:26:07,940 --> 00:26:12,820
really very easy to work out what our

00:26:09,470 --> 00:26:12,820
program is doing

00:26:14,669 --> 00:26:21,659
you did do better than New York I say

00:26:17,159 --> 00:26:23,850
that okay another important point about

00:26:21,659 --> 00:26:26,309
substitution is that it's compositional

00:26:23,850 --> 00:26:28,559
or what I mean about conversational

00:26:26,309 --> 00:26:31,470
Michael compositional means that the

00:26:28,559 --> 00:26:33,809
meaning of an expression is determined

00:26:31,470 --> 00:26:36,179
by the meaning of Z sub expressions and

00:26:33,809 --> 00:26:38,309
the way that they are to combine their

00:26:36,179 --> 00:26:40,409
the way that they are combined so we saw

00:26:38,309 --> 00:26:42,029
it here right I had one plus one plus

00:26:40,409 --> 00:26:44,190
one plus one with the two sub

00:26:42,029 --> 00:26:47,399
expressions we can substitute we get two

00:26:44,190 --> 00:26:50,600
plus two we can compose that together to

00:26:47,399 --> 00:26:55,649
get four as compositionality in practice

00:26:50,600 --> 00:26:57,480
fancy word easy concept and this is one

00:26:55,649 --> 00:26:59,070
of the reasons we avoid stating as in

00:26:57,480 --> 00:27:02,820
our programs as function of programmers

00:26:59,070 --> 00:27:04,529
is because avoiding state allows us to

00:27:02,820 --> 00:27:06,119
be competition or when you have state

00:27:04,529 --> 00:27:11,009
things don't compose because the order

00:27:06,119 --> 00:27:13,070
in which you do things matters so let's

00:27:11,009 --> 00:27:15,299
have a look at how that plays out in

00:27:13,070 --> 00:27:17,489
programming so again look at the low

00:27:15,299 --> 00:27:22,259
level we have expression oriented

00:27:17,489 --> 00:27:25,950
programs so in in Java you might write

00:27:22,259 --> 00:27:28,109
well it's kind of Java rich scala as we

00:27:25,950 --> 00:27:29,340
call it javis out semicolons you might

00:27:28,109 --> 00:27:33,019
write this type of thing if you're doing

00:27:29,340 --> 00:27:37,320
a comparison make us a kind of ordering

00:27:33,019 --> 00:27:39,509
so we have a mutable variables X and

00:27:37,320 --> 00:27:42,570
we're changing the value of x so this is

00:27:39,509 --> 00:27:43,919
breaking substitution because the order

00:27:42,570 --> 00:27:45,149
in which you do things matters you can't

00:27:43,919 --> 00:27:49,409
just substituting the value of x

00:27:45,149 --> 00:27:50,850
whatever is 0 i guess that initial value

00:27:49,409 --> 00:27:52,739
of x you can substitute there in

00:27:50,850 --> 00:27:56,789
throughout your program to understand

00:27:52,739 --> 00:27:58,499
what the meaning of X is it changes so

00:27:56,789 --> 00:28:01,590
what we would do in scholars will make

00:27:58,499 --> 00:28:02,850
if an expression so it evaluates to

00:28:01,590 --> 00:28:05,369
value and then we can just do this

00:28:02,850 --> 00:28:08,509
directly we don't introduce any state

00:28:05,369 --> 00:28:13,230
into our program and substitution hold

00:28:08,509 --> 00:28:14,429
that's a very small low level example we

00:28:13,230 --> 00:28:15,629
see that pervasively in functional

00:28:14,429 --> 00:28:19,320
programming languages there so

00:28:15,629 --> 00:28:21,629
expression or injured if you like at the

00:28:19,320 --> 00:28:23,759
high level we have a very very common

00:28:21,629 --> 00:28:26,519
pattern separating describing and

00:28:23,759 --> 00:28:28,500
running computation such a lovely fancy

00:28:26,519 --> 00:28:31,740
word but what it basically means

00:28:28,500 --> 00:28:33,420
is your thin your program into two you

00:28:31,740 --> 00:28:35,490
have a bit a bit of the program where

00:28:33,420 --> 00:28:36,960
you tell the computer what you want to

00:28:35,490 --> 00:28:39,870
do but you don't actually do anything

00:28:36,960 --> 00:28:42,570
and then you have you to have the plan

00:28:39,870 --> 00:28:44,220
when you tell the computer okay I've got

00:28:42,570 --> 00:28:45,330
all the most factors ready now go and do

00:28:44,220 --> 00:28:47,330
them and that's when you have your

00:28:45,330 --> 00:28:50,370
effects i think that break substitution

00:28:47,330 --> 00:28:53,910
so a kind of typical example of this is

00:28:50,370 --> 00:28:55,260
something involving am honored and you

00:28:53,910 --> 00:28:57,630
don't have to necessarily understand

00:28:55,260 --> 00:28:59,910
what the all of the code the main point

00:28:57,630 --> 00:29:02,220
here is that we have up top we're

00:28:59,910 --> 00:29:05,070
describing what we want the computer to

00:29:02,220 --> 00:29:06,990
do we're saying open a file read all the

00:29:05,070 --> 00:29:09,090
lines printer all the lines then close

00:29:06,990 --> 00:29:11,370
the file and give me the number of lines

00:29:09,090 --> 00:29:14,370
that you processed but we're not

00:29:11,370 --> 00:29:18,360
actually doing that until we go and call

00:29:14,370 --> 00:29:19,920
run here and then stuff happens the file

00:29:18,360 --> 00:29:23,340
is opened the file is closed and so on

00:29:19,920 --> 00:29:26,610
the effects happen and we get an integer

00:29:23,340 --> 00:29:29,340
out ok so this separation between

00:29:26,610 --> 00:29:31,650
describing programs and running them

00:29:29,340 --> 00:29:33,030
very very common in functional program

00:29:31,650 --> 00:29:36,300
is the way that we handle effects

00:29:33,030 --> 00:29:37,410
without breaking substitution and you'll

00:29:36,300 --> 00:29:40,430
see it everywhere you see it into a

00:29:37,410 --> 00:29:42,890
monadic IO example we have an image

00:29:40,430 --> 00:29:47,190
library or doodle which has the same

00:29:42,890 --> 00:29:48,480
setup seen by people handle random

00:29:47,190 --> 00:29:52,350
numbers of generating random data

00:29:48,480 --> 00:29:59,250
probabilistic programming so on a very

00:29:52,350 --> 00:30:01,170
common pattern another difference I'll

00:29:59,250 --> 00:30:04,260
draw into programming types are often

00:30:01,170 --> 00:30:06,480
seen as busy work some things you do to

00:30:04,260 --> 00:30:08,040
make your code run fast and I think ice

00:30:06,480 --> 00:30:11,520
experience a lot of people had with a

00:30:08,040 --> 00:30:13,620
language like Java part of this is down

00:30:11,520 --> 00:30:17,700
to the technology missing type inference

00:30:13,620 --> 00:30:19,320
and so on makes much more of a hassle to

00:30:17,700 --> 00:30:21,780
use their things is also a cultural

00:30:19,320 --> 00:30:24,210
factor if you read the writing of our

00:30:21,780 --> 00:30:27,830
people like some Uncle Bob and so on

00:30:24,210 --> 00:30:32,610
they're very strongly against types

00:30:27,830 --> 00:30:33,960
culturally for the FP programmer and I

00:30:32,610 --> 00:30:36,870
guess I'm talking about the static you

00:30:33,960 --> 00:30:40,140
type FP programming here types or

00:30:36,870 --> 00:30:41,400
something different yes they allow the

00:30:40,140 --> 00:30:43,119
compiler to warn us when we've done

00:30:41,400 --> 00:30:45,499
something wrong

00:30:43,119 --> 00:30:48,289
yes I allow the compiled optimize our

00:30:45,499 --> 00:30:50,029
code but is not their only function and

00:30:48,289 --> 00:30:53,659
one of them the main functions is to

00:30:50,029 --> 00:30:55,580
help us to understand our own code and

00:30:53,659 --> 00:30:59,480
help us to write our code and I want to

00:30:55,580 --> 00:31:01,629
give you some examples now okay so

00:30:59,480 --> 00:31:04,940
another audience participation time

00:31:01,629 --> 00:31:06,830
ganesan trick question we have here the

00:31:04,940 --> 00:31:08,779
method foo not a very good name but we

00:31:06,830 --> 00:31:11,269
have some types here it takes something

00:31:08,779 --> 00:31:13,309
in otay Bay and it returns something's

00:31:11,269 --> 00:31:16,580
at the same time can anyone tell me what

00:31:13,309 --> 00:31:20,960
the implementation of foo is the type to

00:31:16,580 --> 00:31:23,869
constrain implementation I identity

00:31:20,960 --> 00:31:25,129
function yeah exactly right so you have

00:31:23,869 --> 00:31:26,419
to return the input there in fact there

00:31:25,129 --> 00:31:28,539
are two possible implementations here

00:31:26,419 --> 00:31:31,669
you could throw an exception I'm sorry

00:31:28,539 --> 00:31:33,379
not to terminate if you like or you have

00:31:31,669 --> 00:31:35,840
to return the input and this you can

00:31:33,379 --> 00:31:37,429
tell entirely from the types so the

00:31:35,840 --> 00:31:41,239
types of constrained the implementation

00:31:37,429 --> 00:31:42,379
such that these are any possibilities so

00:31:41,239 --> 00:31:46,220
here the types are helping us to

00:31:42,379 --> 00:31:47,840
understand the code the name despite

00:31:46,220 --> 00:31:49,809
doesn't matter what the name is this has

00:31:47,840 --> 00:31:52,129
to basically be the identity function

00:31:49,809 --> 00:31:57,049
and then we can tell that from the types

00:31:52,129 --> 00:32:00,379
and the reason being that your a is any

00:31:57,049 --> 00:32:02,210
any type there's nothing you can do with

00:32:00,379 --> 00:32:03,769
this sort of a when it's no specific

00:32:02,210 --> 00:32:05,539
type there no methods you can call on it

00:32:03,769 --> 00:32:12,070
so basically there anything you can do

00:32:05,539 --> 00:32:15,859
is return it or throw an exception okay

00:32:12,070 --> 00:32:17,119
now let's look at another example and

00:32:15,859 --> 00:32:21,369
here we will show how we can use the

00:32:17,119 --> 00:32:24,230
types to guide us in writing a program

00:32:21,369 --> 00:32:26,779
so we want to implement the map method

00:32:24,230 --> 00:32:29,809
on option this is something we often do

00:32:26,779 --> 00:32:31,009
in our training courses with beginners

00:32:29,809 --> 00:32:33,080
and it's something that I kind of

00:32:31,009 --> 00:32:35,299
freaked out a little bit by what I want

00:32:33,080 --> 00:32:37,549
to show you is that there's a very

00:32:35,299 --> 00:32:40,429
mechanical process for implementing math

00:32:37,549 --> 00:32:42,259
and you are very much constrained by the

00:32:40,429 --> 00:32:45,980
types to guide you towards the correct

00:32:42,259 --> 00:32:47,419
solution so if we start here we've been

00:32:45,980 --> 00:32:50,690
given the signature from artists what

00:32:47,419 --> 00:32:53,419
map is going implement it the first step

00:32:50,690 --> 00:32:54,590
is to say well option is an algebraic

00:32:53,419 --> 00:32:56,900
data type

00:32:54,590 --> 00:32:59,090
our debate data typed you can always

00:32:56,900 --> 00:33:01,640
process using structural Persian so you

00:32:59,090 --> 00:33:03,740
can go and write down this skeleton

00:33:01,640 --> 00:33:05,419
straight away now the term to algebraic

00:33:03,740 --> 00:33:08,029
data type and structural closure may not

00:33:05,419 --> 00:33:09,559
be familiar to you but probably seen

00:33:08,029 --> 00:33:11,450
this kind of pattern matching before she

00:33:09,559 --> 00:33:14,539
programs Carla so you can see what we're

00:33:11,450 --> 00:33:16,340
doing here so you know option is a

00:33:14,539 --> 00:33:17,929
summary none so you have to handle the

00:33:16,340 --> 00:33:21,230
nun case you can't handle the some case

00:33:17,929 --> 00:33:22,730
that's what we're doing here so this

00:33:21,230 --> 00:33:25,190
follows straight away from the

00:33:22,730 --> 00:33:28,100
definition of option no thinking

00:33:25,190 --> 00:33:30,500
required so now we have two cases we

00:33:28,100 --> 00:33:33,649
have none and we have some so let's look

00:33:30,500 --> 00:33:34,820
at the nun case first what can we write

00:33:33,649 --> 00:33:38,210
on the right-hand side to make this

00:33:34,820 --> 00:33:41,299
compile we have to return something of

00:33:38,210 --> 00:33:43,880
type option B we don't have anything of

00:33:41,299 --> 00:33:45,740
type be around we have a function that

00:33:43,880 --> 00:33:48,380
will convert something of type a to type

00:33:45,740 --> 00:33:51,200
B but we don't have anything of type a

00:33:48,380 --> 00:33:53,149
that we can pass to that function so

00:33:51,200 --> 00:33:54,500
there's only one possible thing we can

00:33:53,149 --> 00:34:00,500
put in here to make this compile in

00:33:54,500 --> 00:34:02,899
return what it is yes exactly ok so the

00:34:00,500 --> 00:34:05,899
type C have guided us to the correct

00:34:02,899 --> 00:34:07,460
solution again no thinking require this

00:34:05,899 --> 00:34:10,940
is just a straightforward consequence of

00:34:07,460 --> 00:34:13,730
the types we get to the next case here

00:34:10,940 --> 00:34:17,330
now we have two possibilities we could

00:34:13,730 --> 00:34:20,540
write none again that worked or we could

00:34:17,330 --> 00:34:25,520
write what it could be right here farm

00:34:20,540 --> 00:34:26,780
and some fa yeah exactly ok and the

00:34:25,520 --> 00:34:28,879
reasoning of course is we have something

00:34:26,780 --> 00:34:31,099
a type-a we have a function from A to B

00:34:28,879 --> 00:34:32,570
is to create something of type B to

00:34:31,099 --> 00:34:35,480
create the optional type be wrapped up

00:34:32,570 --> 00:34:37,639
in some so you get the types guide us

00:34:35,480 --> 00:34:39,139
towards that implementation but we did

00:34:37,639 --> 00:34:41,599
have to do a tiny amount of thinking

00:34:39,139 --> 00:34:44,119
they're too not just write down none so

00:34:41,599 --> 00:34:48,040
we can see that by having the types here

00:34:44,119 --> 00:34:49,879
and a very small amount of thinking we

00:34:48,040 --> 00:34:52,820
managed to drive the correct

00:34:49,879 --> 00:34:54,830
implementation of map which is something

00:34:52,820 --> 00:34:57,050
that for beginners often seems very very

00:34:54,830 --> 00:35:00,950
difficult because it is actually very

00:34:57,050 --> 00:35:03,430
easy if you know the reasoning process

00:35:00,950 --> 00:35:03,430
to get there

00:35:04,070 --> 00:35:09,590
I sir course it all down to the times

00:35:06,940 --> 00:35:11,960
and the kind of logical extension of

00:35:09,590 --> 00:35:14,750
this is to then use the types to

00:35:11,960 --> 00:35:16,790
generate this boilerplate code for us

00:35:14,750 --> 00:35:20,990
this is something that you shapeless

00:35:16,790 --> 00:35:22,910
does in various ways if you use JSON

00:35:20,990 --> 00:35:25,040
library there's a good chance that your

00:35:22,910 --> 00:35:26,720
library will generate the civilization

00:35:25,040 --> 00:35:28,760
and deceleration code for you

00:35:26,720 --> 00:35:34,210
automatically quite possibly using

00:35:28,760 --> 00:35:37,430
shapeless is labeled generic feature and

00:35:34,210 --> 00:35:39,620
there's similar things for called type

00:35:37,430 --> 00:35:41,240
class derivation for implementing these

00:35:39,620 --> 00:35:44,150
methods like map and flat map based on

00:35:41,240 --> 00:35:46,370
the types and you know automatically so

00:35:44,150 --> 00:35:49,250
as a great example of how we can do less

00:35:46,370 --> 00:35:50,690
work by using the types to represent the

00:35:49,250 --> 00:35:53,120
structure of our carried in a way that

00:35:50,690 --> 00:35:59,030
the compiler and then macros can can

00:35:53,120 --> 00:36:02,300
chew over and do work for us right so to

00:35:59,030 --> 00:36:04,340
sum up my argument is that the the

00:36:02,300 --> 00:36:06,410
fundamental paradigm for the functional

00:36:04,340 --> 00:36:08,510
program it is based on these two ideas

00:36:06,410 --> 00:36:11,150
of simplicity and static reasoning

00:36:08,510 --> 00:36:13,820
simplicity meaning as few concepts as

00:36:11,150 --> 00:36:16,790
possible static reasoning being

00:36:13,820 --> 00:36:18,170
understanding code before you run it

00:36:16,790 --> 00:36:20,540
understanding it in terms of its types

00:36:18,170 --> 00:36:25,940
understanding in terms of substitution

00:36:20,540 --> 00:36:27,230
and the sounds a smaller points we saw

00:36:25,940 --> 00:36:29,450
sort of sub points that come from this

00:36:27,230 --> 00:36:32,120
are the substitution model of evaluation

00:36:29,450 --> 00:36:33,800
composition understanding big things in

00:36:32,120 --> 00:36:36,380
terms of small things and how they are

00:36:33,800 --> 00:36:38,170
combined using types to guide

00:36:36,380 --> 00:36:40,940
implementation to understand code and

00:36:38,170 --> 00:36:42,320
all of this is very precise compared to

00:36:40,940 --> 00:36:43,730
the overworld which is kind of an

00:36:42,320 --> 00:36:45,590
informal definition here we can write

00:36:43,730 --> 00:36:47,720
down like a mathematical definition if

00:36:45,590 --> 00:36:49,340
you like so we can say precisely does

00:36:47,720 --> 00:36:50,840
this code maintain substitution or not

00:36:49,340 --> 00:36:55,190
you can prove something that's what does

00:36:50,840 --> 00:36:58,460
not feel so inclined so the next thing

00:36:55,190 --> 00:37:02,150
to then look at is to say okay so this

00:36:58,460 --> 00:37:04,880
is the FP paradigm how do we go from 0

00:37:02,150 --> 00:37:06,800
to FP because most people have been

00:37:04,880 --> 00:37:08,570
taught our programming you're

00:37:06,800 --> 00:37:10,840
experienced programmer you don't you

00:37:08,570 --> 00:37:14,330
sort of growing up doing our programming

00:37:10,840 --> 00:37:20,900
so can you go can you go from 0 to FP

00:37:14,330 --> 00:37:24,080
and these on this differ so we have max

00:37:20,900 --> 00:37:25,760
planck a cheery fellow i imagine if this

00:37:24,080 --> 00:37:31,190
was what all this summer's were like he

00:37:25,760 --> 00:37:34,160
would be kind of upset as well I'm bit

00:37:31,190 --> 00:37:36,830
more optimistic than max so I believe

00:37:34,160 --> 00:37:38,930
that you can go from an oo program to FP

00:37:36,830 --> 00:37:41,060
program and I'll hold myself up as an

00:37:38,930 --> 00:37:43,370
existence proof I did start off as an

00:37:41,060 --> 00:37:45,290
arrow programmer I think one of the ways

00:37:43,370 --> 00:37:48,530
they we can ease that transition is to

00:37:45,290 --> 00:37:50,420
look at the oo design patterns so when

00:37:48,530 --> 00:37:55,460
you look at our design patterns what you

00:37:50,420 --> 00:37:57,740
see there are often a lot of basically

00:37:55,460 --> 00:38:00,410
FP idea is dressed up in a kind of

00:37:57,740 --> 00:38:03,500
different terminology so here are some

00:38:00,410 --> 00:38:05,440
examples chain of responsibility the

00:38:03,500 --> 00:38:08,110
command pattern the strategy pattern

00:38:05,440 --> 00:38:10,300
these things are all basically

00:38:08,110 --> 00:38:12,500
variations in the first class functions

00:38:10,300 --> 00:38:15,500
closures Landers what if you want to

00:38:12,500 --> 00:38:17,330
call them so chain of responsibilities

00:38:15,500 --> 00:38:18,800
essentially when you have this

00:38:17,330 --> 00:38:21,950
essentially function composition you

00:38:18,800 --> 00:38:23,870
have an object which is responsible for

00:38:21,950 --> 00:38:26,120
doing something and it then passes on

00:38:23,870 --> 00:38:29,780
its result to the next object in the

00:38:26,120 --> 00:38:31,070
kind of queue of objects you like and

00:38:29,780 --> 00:38:32,420
these objects are essentially functions

00:38:31,070 --> 00:38:34,520
and you essentially composing them

00:38:32,420 --> 00:38:36,140
together the output from one becomes the

00:38:34,520 --> 00:38:39,650
input to the other it's essentially a

00:38:36,140 --> 00:38:43,100
function composition the command pattern

00:38:39,650 --> 00:38:47,180
is basically representing a command if

00:38:43,100 --> 00:38:50,660
you like an action as a noun and object

00:38:47,180 --> 00:38:52,280
as basically as a function in object

00:38:50,660 --> 00:38:53,930
terms and the strategy one is doing the

00:38:52,280 --> 00:38:55,850
same sort of thing it's a way of doing

00:38:53,930 --> 00:38:57,050
something if you like as an object so

00:38:55,850 --> 00:39:00,500
those are kind of different ways of

00:38:57,050 --> 00:39:02,540
where our people were kind of grasping

00:39:00,500 --> 00:39:05,810
around trying to understand the elephant

00:39:02,540 --> 00:39:09,050
if you like of first class functions but

00:39:05,810 --> 00:39:11,990
not quite able to express it in the

00:39:09,050 --> 00:39:14,390
languages of the time and you'll see

00:39:11,990 --> 00:39:15,800
similar things when you look at things

00:39:14,390 --> 00:39:19,280
like the visitor pattern which is very

00:39:15,800 --> 00:39:22,310
similar to a fold and so

00:39:19,280 --> 00:39:27,750
now this will help you to understand how

00:39:22,310 --> 00:39:29,250
to use some of the FP features but it's

00:39:27,750 --> 00:39:31,380
not going to give you this pervasive way

00:39:29,250 --> 00:39:33,000
of thinking about programming this

00:39:31,380 --> 00:39:35,010
different way of thinking about program

00:39:33,000 --> 00:39:37,290
that the FP programmer has so the

00:39:35,010 --> 00:39:38,760
paradigm is still different when I was a

00:39:37,290 --> 00:39:39,930
no programmer patterns were normally

00:39:38,760 --> 00:39:42,180
something you should have brought out on

00:39:39,930 --> 00:39:43,980
special occasions weddings and birthdays

00:39:42,180 --> 00:39:46,710
or something that's something that you

00:39:43,980 --> 00:39:49,200
kind of used all throughout your code so

00:39:46,710 --> 00:39:51,060
yeah the paradigm is different and you

00:39:49,200 --> 00:39:54,470
do have to change that paradigm that is

00:39:51,060 --> 00:39:56,460
hard I think what I hope I pretend to

00:39:54,470 --> 00:40:02,150
explain to some extent what that

00:39:56,460 --> 00:40:04,860
paradigm is right so conclusions

00:40:02,150 --> 00:40:06,480
multi-paradigm development doesn't make

00:40:04,860 --> 00:40:08,760
sense so it doesn't make sense by

00:40:06,480 --> 00:40:10,980
definition but I don't think it makes

00:40:08,760 --> 00:40:13,350
sense practically either like I don't

00:40:10,980 --> 00:40:16,950
believe in I don't believe object

00:40:13,350 --> 00:40:18,390
functional code is a reality because you

00:40:16,950 --> 00:40:20,430
have fundamentally different ways of

00:40:18,390 --> 00:40:24,000
approaching how you structure your code

00:40:20,430 --> 00:40:25,530
how you decompose a problem so the

00:40:24,000 --> 00:40:26,850
combination of modular programming and

00:40:25,530 --> 00:40:28,410
funk referring to me makes a lot of

00:40:26,850 --> 00:40:29,670
sense the combination object-oriented

00:40:28,410 --> 00:40:32,010
programming at functional programming

00:40:29,670 --> 00:40:37,710
doesn't possibly a controversial

00:40:32,010 --> 00:40:40,530
statement I believe olo patterns will

00:40:37,710 --> 00:40:43,020
help you get to FP concept help you

00:40:40,530 --> 00:40:48,090
understand how to use language features

00:40:43,020 --> 00:40:49,440
in the FP world but they're not going to

00:40:48,090 --> 00:40:52,760
give you that paradigm that way of

00:40:49,440 --> 00:40:54,930
thinking I hope I've been able to

00:40:52,760 --> 00:40:57,960
explain that paradigm to some extent

00:40:54,930 --> 00:40:59,910
show that is not so difficult but like

00:40:57,960 --> 00:41:01,530
all things it does take time to return

00:40:59,910 --> 00:41:03,000
lies you can't learn instantly it will

00:41:01,530 --> 00:41:07,440
take you have to beat your head against

00:41:03,000 --> 00:41:08,580
this for a bit for sinks in all right so

00:41:07,440 --> 00:41:10,740
that's on everything I've got to say

00:41:08,580 --> 00:41:12,390
thank you for your attention and there

00:41:10,740 --> 00:41:18,290
any questions to put up the nonsense

00:41:12,390 --> 00:41:20,850
well thanks okay

00:41:18,290 --> 00:41:32,100
lots of questions surely someone's got a

00:41:20,850 --> 00:41:37,710
question yeah in in Scala you have also

00:41:32,100 --> 00:41:47,970
the object-oriented the part so but this

00:41:37,710 --> 00:41:49,560
is less important I guess so if I going

00:41:47,970 --> 00:41:52,830
to kind of expand that out into great

00:41:49,560 --> 00:41:54,870
question i would say how do i reconcile

00:41:52,830 --> 00:41:57,180
what i said with the fact that Scala has

00:41:54,870 --> 00:41:59,340
our features it was that a reasonable

00:41:57,180 --> 00:42:02,640
kind of summary of what you're getting

00:41:59,340 --> 00:42:07,560
at yeah ok so I think this is very

00:42:02,640 --> 00:42:09,810
interesting so if you're ready the paper

00:42:07,560 --> 00:42:15,420
worst is better it makes a suggestion

00:42:09,810 --> 00:42:17,250
that sometimes is not the the kind of

00:42:15,420 --> 00:42:18,180
pure expressional idea that wins out but

00:42:17,250 --> 00:42:20,310
it sort of thing something that works

00:42:18,180 --> 00:42:21,810
with where we currently are today I

00:42:20,310 --> 00:42:24,840
think that's an example of what Skyler

00:42:21,810 --> 00:42:26,340
does scholar the reason people use

00:42:24,840 --> 00:42:29,940
scarlet is because they can start out

00:42:26,340 --> 00:42:31,860
using our ways of programming that can

00:42:29,940 --> 00:42:34,530
do the job or without semicolons as we

00:42:31,860 --> 00:42:36,300
jokingly call it and still they can

00:42:34,530 --> 00:42:39,390
write that in Schuyler whereas making

00:42:36,300 --> 00:42:43,500
the jump straight to pasco or whatever

00:42:39,390 --> 00:42:44,940
is too much so scala works because you

00:42:43,500 --> 00:42:47,490
can keep them doing things the old way

00:42:44,940 --> 00:42:54,860
but that is at some point becomes

00:42:47,490 --> 00:42:59,010
baggage and it slows you down I don't I

00:42:54,860 --> 00:43:02,940
haven't seen anyone who combines over an

00:42:59,010 --> 00:43:14,300
FP in a sort of a successful way without

00:43:02,940 --> 00:43:14,300
Abby not attention okay that's fine the

00:43:14,870 --> 00:43:20,320
so yeah I I don't know how much of

00:43:18,460 --> 00:43:22,750
how much is that it's kind of legacy and

00:43:20,320 --> 00:43:25,180
how much it is just it's kind of needed

00:43:22,750 --> 00:43:27,609
to be done maybe you can comment on how

00:43:25,180 --> 00:43:29,800
you so the issue I always have with 0

00:43:27,609 --> 00:43:32,200
and FP is how do you make the decision

00:43:29,800 --> 00:43:46,480
of how to break down your code and I

00:43:32,200 --> 00:43:48,550
think there's right so if so I would

00:43:46,480 --> 00:43:50,440
definitely agree with using objects as

00:43:48,550 --> 00:43:54,480
modules that for me works very well what

00:43:50,440 --> 00:43:57,099
doesn't work for me is using things like

00:43:54,480 --> 00:43:59,020
very deep nested hierarchies of classes

00:43:57,099 --> 00:44:01,089
so I would very rarely have an unsealed

00:43:59,020 --> 00:44:02,980
I would have if I have a trade is either

00:44:01,089 --> 00:44:05,320
sealed with defining algebraic data type

00:44:02,980 --> 00:44:09,240
or a type class basically for having

00:44:05,320 --> 00:44:09,240
like open extension open classes

00:44:43,700 --> 00:44:53,520
well I could agree that thank you any

00:44:49,620 --> 00:44:59,490
other questions direct into myself will

00:44:53,520 --> 00:45:02,850
Martin ok so i guess the only question

00:44:59,490 --> 00:45:03,900
is is it time for lunch and I guess it

00:45:02,850 --> 00:45:06,860
is so thank you all for your attention

00:45:03,900 --> 00:45:06,860

YouTube URL: https://www.youtube.com/watch?v=bL-CcjKW1lw


