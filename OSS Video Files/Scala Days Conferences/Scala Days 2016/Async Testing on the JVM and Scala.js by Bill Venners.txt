Title: Async Testing on the JVM and Scala.js by Bill Venners
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
In ScalaTest 3.0's new async testing styles, tests have a result type of Future[Assertion]. Instead of blocking until a future completes, then performing assertions on the result, you map assertions onto the future and return the resulting Future[Assertion] to ScalaTest. The test will complete asynchronously when the Future[Assertion] completes. This non-blocking way of testing requires a very different mindset and different API. In this talk Bill Venners will show you how async testing was integrated into ScalaTest, and explain what motivated the design decisions. He'll show you how to use the new features, and suggest best practices for async testing on both the JVM and Scala.js.
Captions: 
	00:00:01,860 --> 00:00:05,500
alright thank you for coming to my talk

00:00:03,669 --> 00:00:12,990
bill venner's today I want to talk about

00:00:05,500 --> 00:00:16,150
a sink testing in Scala test 30 and what

00:00:12,990 --> 00:00:17,650
what I wanted to start out with was give

00:00:16,150 --> 00:00:22,330
you a little bit of something to compare

00:00:17,650 --> 00:00:25,570
it to and this is the servlet API from

00:00:22,330 --> 00:00:29,350
Java from back in the 90s there's a do

00:00:25,570 --> 00:00:30,970
get method and the way you write a code

00:00:29,350 --> 00:00:34,930
that handles web request is you

00:00:30,970 --> 00:00:38,020
implement this method and what you do is

00:00:34,930 --> 00:00:40,780
you get two things you get a HTTP server

00:00:38,020 --> 00:00:43,510
request that is a bundle of information

00:00:40,780 --> 00:00:45,520
about the request what came up to the in

00:00:43,510 --> 00:00:49,890
a gutter a post for example and then you

00:00:45,520 --> 00:00:52,870
have an HTTP server response which is a

00:00:49,890 --> 00:00:54,640
basically it's a wrapper for a socket

00:00:52,870 --> 00:00:56,230
that's directly connected to the client

00:00:54,640 --> 00:00:57,160
and what you do in your method is you do

00:00:56,230 --> 00:00:58,720
whatever you need to do to figure out

00:00:57,160 --> 00:00:59,770
what to send to the client and then you

00:00:58,720 --> 00:01:02,620
send it and then when you're finished

00:00:59,770 --> 00:01:04,239
you close the socket and you return so

00:01:02,620 --> 00:01:05,620
essentially if you need to do something

00:01:04,239 --> 00:01:07,810
like talk to a database that may take

00:01:05,620 --> 00:01:10,600
some time you have to block so this

00:01:07,810 --> 00:01:14,140
thread is blocked and can't be used for

00:01:10,600 --> 00:01:16,450
any other work while that's going on and

00:01:14,140 --> 00:01:17,770
that in the old days may have made sense

00:01:16,450 --> 00:01:20,830
but these days there's a lot more

00:01:17,770 --> 00:01:23,920
requests coming in so that's where

00:01:20,830 --> 00:01:26,440
reactive style comes sort of is is

00:01:23,920 --> 00:01:28,570
supposed to help with so play for

00:01:26,440 --> 00:01:32,200
example doesn't recommend you do it that

00:01:28,570 --> 00:01:33,310
way you can do it that way but it isn't

00:01:32,200 --> 00:01:35,890
idea matic so here's what it would look

00:01:33,310 --> 00:01:37,960
like if you did if you actually did

00:01:35,890 --> 00:01:40,380
something that took a while and you got

00:01:37,960 --> 00:01:43,479
a future back so you have a future

00:01:40,380 --> 00:01:46,450
integer in this case what you can do is

00:01:43,479 --> 00:01:47,950
call a weight and block the current

00:01:46,450 --> 00:01:49,780
thread until that feature finishes and

00:01:47,950 --> 00:01:53,920
then return a response so basically when

00:01:49,780 --> 00:01:59,380
that method returns an okay to the

00:01:53,920 --> 00:02:00,670
client and and you know it it the

00:01:59,380 --> 00:02:01,990
response is finished the request

00:02:00,670 --> 00:02:04,270
response cycle is finished when the

00:02:01,990 --> 00:02:07,180
method returns but what you're what if

00:02:04,270 --> 00:02:08,950
you do that if people will quickly

00:02:07,180 --> 00:02:13,840
complain and tell you to do it this way

00:02:08,950 --> 00:02:17,170
right what you can do instead is

00:02:13,840 --> 00:02:19,209
map code that knows how to make a

00:02:17,170 --> 00:02:21,940
response given the result of the future

00:02:19,209 --> 00:02:24,760
on to that future and get a new future

00:02:21,940 --> 00:02:26,290
back that's a future response so just

00:02:24,760 --> 00:02:28,030
very quickly you get a future response

00:02:26,290 --> 00:02:31,000
back and then you can return that back

00:02:28,030 --> 00:02:33,250
to play and then play we'll put it on a

00:02:31,000 --> 00:02:41,500
shelf and in that thread can go do

00:02:33,250 --> 00:02:44,349
something else and when that future does

00:02:41,500 --> 00:02:45,730
finally complete then it will talk to

00:02:44,349 --> 00:02:46,989
the client right so what it does is it

00:02:45,730 --> 00:02:49,060
makes more efficient use of threads

00:02:46,989 --> 00:02:50,140
because Fred's our threads are a finite

00:02:49,060 --> 00:02:51,880
resource and you can have a lot more

00:02:50,140 --> 00:02:55,510
clients request that way than the old

00:02:51,880 --> 00:02:58,569
servlet way so the one place that that

00:02:55,510 --> 00:03:00,400
you hear is ok to block is tests right

00:02:58,569 --> 00:03:02,980
that will always be the next thing if

00:03:00,400 --> 00:03:04,150
this is ok to block in a test and so

00:03:02,980 --> 00:03:05,739
here's an example what that might look

00:03:04,150 --> 00:03:07,269
like if I want to test that code I might

00:03:05,739 --> 00:03:09,610
you know call that same method get the

00:03:07,269 --> 00:03:11,950
same future back and I'll block on it

00:03:09,610 --> 00:03:14,170
and then once the integer comes back so

00:03:11,950 --> 00:03:18,819
I block the test thread once you nurture

00:03:14,170 --> 00:03:20,139
comes back I do an assertion on it so

00:03:18,819 --> 00:03:21,670
that was that just done over and over

00:03:20,139 --> 00:03:23,769
and over and that sort of the mantra

00:03:21,670 --> 00:03:26,049
Vesta the idiomatic way to do things and

00:03:23,769 --> 00:03:28,359
I was teaching play a couple years ago

00:03:26,049 --> 00:03:30,910
like two years ago and sort of repeating

00:03:28,359 --> 00:03:32,920
this mantra and I started wondering you

00:03:30,910 --> 00:03:34,930
know why why is it ok to block in your

00:03:32,920 --> 00:03:39,280
tests and I got the warning if that's my

00:03:34,930 --> 00:03:41,380
fault right it's as if the the three

00:03:39,280 --> 00:03:45,669
rules of reactive programming our rule

00:03:41,380 --> 00:03:49,569
number one never ever block rule number

00:03:45,669 --> 00:03:52,150
two never ever block and rule number

00:03:49,569 --> 00:03:54,639
three is well alright maybe it's okay

00:03:52,150 --> 00:03:59,410
sometimes a block in your tests right so

00:03:54,639 --> 00:04:01,690
it's it's wishy-washy and what what i

00:03:59,410 --> 00:04:05,049
thought was like if you can return a

00:04:01,690 --> 00:04:06,579
future response to a web framework why

00:04:05,049 --> 00:04:08,500
can't you return a future assertion to a

00:04:06,579 --> 00:04:11,950
test framework right so it looked like

00:04:08,500 --> 00:04:14,109
kind of like the Play code I in my test

00:04:11,950 --> 00:04:16,630
call a method that gives me back a

00:04:14,109 --> 00:04:18,039
future hint and instead of blocking on

00:04:16,630 --> 00:04:19,840
it and then you know doing an assertion

00:04:18,039 --> 00:04:21,760
I just map an assertion on to that

00:04:19,840 --> 00:04:23,800
future end and get a future assertion

00:04:21,760 --> 00:04:26,770
that I returned to the test framework

00:04:23,800 --> 00:04:27,639
right so that was my idea I thought well

00:04:26,770 --> 00:04:28,840
that's that's

00:04:27,639 --> 00:04:30,159
oddly interesting I wonder if they would

00:04:28,840 --> 00:04:33,729
be interesting to other people so I

00:04:30,159 --> 00:04:35,800
talked to some reactive folks the aqha

00:04:33,729 --> 00:04:40,629
team heiko say burger I think was in

00:04:35,800 --> 00:04:43,419
that that email a series of emails to

00:04:40,629 --> 00:04:46,629
get their react well their reaction to

00:04:43,419 --> 00:04:47,889
this idea and they all kind of liked it

00:04:46,629 --> 00:04:49,270
they kind of said yes it's got

00:04:47,889 --> 00:04:51,550
interesting I think that'd be useful you

00:04:49,270 --> 00:04:53,199
know but I didn't get this oh my god

00:04:51,550 --> 00:04:56,199
that's fantastic i need that right i

00:04:53,199 --> 00:04:58,419
didn't get the vibe that this was really

00:04:56,199 --> 00:05:00,430
a burning need and I try very hard not

00:04:58,419 --> 00:05:01,870
to put just toss stuff that pops into my

00:05:00,430 --> 00:05:04,120
head into the library because it's

00:05:01,870 --> 00:05:05,500
already big and it's just if I don't be

00:05:04,120 --> 00:05:07,599
very very careful about what I put in

00:05:05,500 --> 00:05:09,909
then it'll just you know explode in size

00:05:07,599 --> 00:05:13,889
right so I wasn't planning to put it in

00:05:09,909 --> 00:05:16,629
until this happened sorry Sebastian

00:05:13,889 --> 00:05:19,180
essentially we decided yes that guy we

00:05:16,629 --> 00:05:20,860
decided to ports collett estes college

00:05:19,180 --> 00:05:23,229
is because a lot of users wanted it and

00:05:20,860 --> 00:05:25,779
we thought it would be pretty easy we it

00:05:23,229 --> 00:05:29,589
took over a year and it was turned into

00:05:25,779 --> 00:05:31,180
a really huge yak shave so one aspect of

00:05:29,589 --> 00:05:33,759
that yes shave a pretty significant one

00:05:31,180 --> 00:05:36,400
involved a sink testing and what I

00:05:33,759 --> 00:05:37,719
learned we were Java people so we

00:05:36,400 --> 00:05:40,210
weren't so sophisticated about

00:05:37,719 --> 00:05:41,620
JavaScript but it turns out in

00:05:40,210 --> 00:05:43,659
JavaScript you can't block because

00:05:41,620 --> 00:05:45,909
there's there's one thread essentially

00:05:43,659 --> 00:05:49,180
going around in a circle inside the

00:05:45,909 --> 00:05:51,159
JavaScript BM and it just each time

00:05:49,180 --> 00:05:52,599
comes around this part it picks up a job

00:05:51,159 --> 00:05:54,399
to do out of a job queue and then does

00:05:52,599 --> 00:05:56,050
that job and then it picks another job

00:05:54,399 --> 00:05:57,339
and does that job that's what it does

00:05:56,050 --> 00:05:59,069
that's what javascript does it doesn't

00:05:57,339 --> 00:06:01,389
ever get bored it just keeps doing that

00:05:59,069 --> 00:06:05,080
but because there's only one thread you

00:06:01,389 --> 00:06:07,810
can't block so I didn't quite understand

00:06:05,080 --> 00:06:10,599
what that meant until this user

00:06:07,810 --> 00:06:13,529
submitted this bug this issue on github

00:06:10,599 --> 00:06:18,129
his name is Chandra SAT kar code and

00:06:13,529 --> 00:06:20,020
what he wrote was this test that calls

00:06:18,129 --> 00:06:22,899
into sample service get data which gets

00:06:20,020 --> 00:06:27,039
an X is what is a future of I forget

00:06:22,899 --> 00:06:29,949
future something so future value and

00:06:27,039 --> 00:06:32,259
Scala test is is kind of a DSL for a

00:06:29,949 --> 00:06:35,979
wait but it throws basically it will

00:06:32,259 --> 00:06:38,860
block that future on for a period of

00:06:35,979 --> 00:06:40,089
time and if it times out then you get a

00:06:38,860 --> 00:06:41,080
test failed exception with a nice

00:06:40,089 --> 00:06:43,300
stacked up to you know where

00:06:41,080 --> 00:06:47,620
why code field was right and a nice

00:06:43,300 --> 00:06:49,360
error message but if it does complete

00:06:47,620 --> 00:06:51,009
before the timeout it just returns it

00:06:49,360 --> 00:06:54,639
and then you can do further assertions

00:06:51,009 --> 00:06:55,900
on it right so on jvm that worked fine

00:06:54,639 --> 00:06:57,189
but on JavaScript basically you're

00:06:55,900 --> 00:07:00,189
trying to block in javascript in the way

00:06:57,189 --> 00:07:02,680
we ported that to JavaScript was we just

00:07:00,189 --> 00:07:04,599
didn't block and there's there is

00:07:02,680 --> 00:07:07,180
certain execution context in JavaScript

00:07:04,599 --> 00:07:09,400
for it it works fine but the one he was

00:07:07,180 --> 00:07:11,710
using it none of them worked for him

00:07:09,400 --> 00:07:12,909
because it turned out that you can't

00:07:11,710 --> 00:07:14,319
actually with multiple thread things

00:07:12,909 --> 00:07:16,270
with multiple threads in JavaScript and

00:07:14,319 --> 00:07:18,400
what his sample service thought getdata

00:07:16,270 --> 00:07:21,789
method does it calls outside of the vm

00:07:18,400 --> 00:07:23,889
so it's a method inside JavaScript that

00:07:21,789 --> 00:07:25,419
goes outside of JavaScript and now

00:07:23,889 --> 00:07:27,009
you're in and like you're on node it's a

00:07:25,419 --> 00:07:28,960
see code which has access to other

00:07:27,009 --> 00:07:30,430
threads and it can kick off a thread

00:07:28,960 --> 00:07:31,539
over here and see you now you got two

00:07:30,430 --> 00:07:33,310
threads got the JavaScript's rather than

00:07:31,539 --> 00:07:36,159
the sea thread going and meanwhile the

00:07:33,310 --> 00:07:37,360
JavaScript Fed says okay I've got back a

00:07:36,159 --> 00:07:38,590
future I'm going to go do my next thing

00:07:37,360 --> 00:07:42,759
and this thing's over here doing its

00:07:38,590 --> 00:07:46,240
thing and that's not easy to do but and

00:07:42,759 --> 00:07:47,500
then eventually this finishes in it

00:07:46,240 --> 00:07:48,909
sticks a job on the queue that the

00:07:47,500 --> 00:07:51,490
JavaScript guy will come and complete

00:07:48,909 --> 00:07:55,150
the future right and when I saw that

00:07:51,490 --> 00:07:57,550
that's when I realized oh the only way I

00:07:55,150 --> 00:07:59,680
can get that to work is a sink tests

00:07:57,550 --> 00:08:02,349
right so this was the burning need

00:07:59,680 --> 00:08:04,539
either we didn't port skullet estes

00:08:02,349 --> 00:08:06,460
college is or we added a sink testing

00:08:04,539 --> 00:08:13,139
support to scala test it was one of

00:08:06,460 --> 00:08:15,009
those two choices so basically what I

00:08:13,139 --> 00:08:16,539
wanted to do was kind of give you a

00:08:15,009 --> 00:08:18,520
little bit of background and talk about

00:08:16,539 --> 00:08:22,330
like what we had to work with to get a

00:08:18,520 --> 00:08:24,310
sink testing in in Scala test to do we

00:08:22,330 --> 00:08:25,779
added this adt called outcome that

00:08:24,310 --> 00:08:27,279
represents the outcome of a test and

00:08:25,779 --> 00:08:29,710
there's four possibilities a test can

00:08:27,279 --> 00:08:32,050
either succeed fail be cancelled or be

00:08:29,710 --> 00:08:33,909
pending right and succeeded in pending

00:08:32,050 --> 00:08:35,829
our Singleton's there singleton objects

00:08:33,909 --> 00:08:39,039
they're just that's it either succeeded

00:08:35,829 --> 00:08:41,229
or at spending and failed and canceled

00:08:39,039 --> 00:08:43,959
wrap an exception canceled always wraps

00:08:41,229 --> 00:08:45,699
test canceled exception and failed can

00:08:43,959 --> 00:08:47,500
wrap test failed exception or any other

00:08:45,699 --> 00:08:51,819
exception because any other exception

00:08:47,500 --> 00:08:53,740
will cause the test to fail and so that

00:08:51,819 --> 00:08:54,720
existed and then we had a method called

00:08:53,740 --> 00:08:56,879
with fixture in

00:08:54,720 --> 00:08:59,699
sweet from one dot 0 button to dot 0 we

00:08:56,879 --> 00:09:03,259
adjusted it's it's a signature to have a

00:08:59,699 --> 00:09:05,339
test function that returns an outcome so

00:09:03,259 --> 00:09:07,139
what's past two with fixture is a

00:09:05,339 --> 00:09:10,620
function that represents the body of

00:09:07,139 --> 00:09:11,699
code of the test and when you execute it

00:09:10,620 --> 00:09:13,290
you don't have to pass anything into it

00:09:11,699 --> 00:09:14,550
it will give you back at this test

00:09:13,290 --> 00:09:16,379
either succeeded it failed with an

00:09:14,550 --> 00:09:19,560
exception it was test canceled exception

00:09:16,379 --> 00:09:22,709
or it cancelled or was pending right and

00:09:19,560 --> 00:09:24,149
then a fixture itself returns an outcome

00:09:22,709 --> 00:09:26,879
and what you can do with is things like

00:09:24,149 --> 00:09:28,319
Shoni on the second example you can

00:09:26,879 --> 00:09:30,899
override with fix here in your test to

00:09:28,319 --> 00:09:33,029
do setup and teardown in one method you

00:09:30,899 --> 00:09:36,060
do some setup and then you in a try

00:09:33,029 --> 00:09:38,939
block execute the test function and then

00:09:36,060 --> 00:09:40,500
in a finally Clause you do the cleanup

00:09:38,939 --> 00:09:41,459
so with the test function apps that

00:09:40,500 --> 00:09:42,720
happen happens to blow up with an

00:09:41,459 --> 00:09:45,199
exception which it shouldn't but if it

00:09:42,720 --> 00:09:47,610
does it will still do the cleanup right

00:09:45,199 --> 00:09:49,680
otherwise when the test function returns

00:09:47,610 --> 00:09:51,029
you've got an outcome you do your clean

00:09:49,680 --> 00:09:53,579
up and then you return the same outcome

00:09:51,029 --> 00:09:55,370
so the default implementation of with

00:09:53,579 --> 00:09:58,139
fixture is just invoke the test function

00:09:55,370 --> 00:09:59,730
right so what to make these stackable

00:09:58,139 --> 00:10:01,740
what I recommend people do is actually

00:09:59,730 --> 00:10:03,899
not invoke the test function directly

00:10:01,740 --> 00:10:05,579
like that but to do this which is to

00:10:03,899 --> 00:10:08,189
delegate invoking the test function to a

00:10:05,579 --> 00:10:09,509
super trait with fixture and eventually

00:10:08,189 --> 00:10:11,009
will you can stack them and eventually

00:10:09,509 --> 00:10:13,800
you'll bubble back up to the one and

00:10:11,009 --> 00:10:17,189
sweet and it will execute it right so

00:10:13,800 --> 00:10:20,250
that's that was 20 so there's a lot of a

00:10:17,189 --> 00:10:22,339
lotta co doing that and then most most

00:10:20,250 --> 00:10:24,480
people just do that in their test class

00:10:22,339 --> 00:10:25,860
but if you have several test classes

00:10:24,480 --> 00:10:27,180
that are you know you're repeating the

00:10:25,860 --> 00:10:29,459
same with fixture code over and over

00:10:27,180 --> 00:10:32,189
then you can factor it out into a trait

00:10:29,459 --> 00:10:34,769
that you mix into those test classes so

00:10:32,189 --> 00:10:36,240
sometimes people will make a mix in

00:10:34,769 --> 00:10:39,899
trade like this this is how i

00:10:36,240 --> 00:10:42,930
recommended people do it which is you

00:10:39,899 --> 00:10:45,329
extend sweet mix in which is a trait

00:10:42,930 --> 00:10:46,740
that just has abstract lifecycle methods

00:10:45,329 --> 00:10:49,019
what has an abstract with fixed you're

00:10:46,740 --> 00:10:50,670
just the signature no body and then you

00:10:49,019 --> 00:10:52,379
say myself type is sweet so i can only

00:10:50,670 --> 00:10:54,720
be mixed into a sweet which you know

00:10:52,379 --> 00:10:56,970
we'll have that one that its default

00:10:54,720 --> 00:10:58,949
implementation is just invoke the test

00:10:56,970 --> 00:11:00,569
function and then you just abstract

00:10:58,949 --> 00:11:02,819
override wave fixture and mess you can

00:11:00,569 --> 00:11:03,870
mix that into to any test and you have

00:11:02,819 --> 00:11:06,700
several ease you can mix them together

00:11:03,870 --> 00:11:09,040
right so that

00:11:06,700 --> 00:11:11,230
didn't happen that as often as people

00:11:09,040 --> 00:11:13,390
just doing it together but these are the

00:11:11,230 --> 00:11:14,920
things that we we have basically use

00:11:13,390 --> 00:11:16,870
extent defined with fixture methods and

00:11:14,920 --> 00:11:19,230
did and they can compose them by

00:11:16,870 --> 00:11:21,760
stacking traits which sometimes they did

00:11:19,230 --> 00:11:23,410
but what was the problem or the missed

00:11:21,760 --> 00:11:25,510
the impedance mismatch for a sink is

00:11:23,410 --> 00:11:29,470
that just like that do get method and

00:11:25,510 --> 00:11:32,620
servlet the type the signature of the

00:11:29,470 --> 00:11:34,390
test function and of with fixture means

00:11:32,620 --> 00:11:36,130
that the test has already completed once

00:11:34,390 --> 00:11:37,930
the test function returns and once wants

00:11:36,130 --> 00:11:39,550
the cure returns because it's already

00:11:37,930 --> 00:11:41,080
returning an outcome so you have to know

00:11:39,550 --> 00:11:43,000
it succeeded canceled pending or failed

00:11:41,080 --> 00:11:45,130
but if you're doing an async test

00:11:43,000 --> 00:11:48,550
returning a future assertion we don't

00:11:45,130 --> 00:11:52,090
know what the outcome is yet right so

00:11:48,550 --> 00:11:57,910
one of the first things I had to figure

00:11:52,090 --> 00:12:00,280
out was future of what right when you're

00:11:57,910 --> 00:12:03,120
mapping us you know an assert onto a

00:12:00,280 --> 00:12:06,670
future end you get a future of any

00:12:03,120 --> 00:12:09,760
future of unit so I wanted to be able to

00:12:06,670 --> 00:12:12,250
save just like you can say you map a

00:12:09,760 --> 00:12:13,660
response on to a you know a future and

00:12:12,250 --> 00:12:14,860
you get a future response you can pass

00:12:13,660 --> 00:12:17,320
back the web tracker I wanted to say you

00:12:14,860 --> 00:12:18,580
get a future assertion that you pass

00:12:17,320 --> 00:12:21,040
back to the test framework so when it's

00:12:18,580 --> 00:12:22,390
something named assertion and it took me

00:12:21,040 --> 00:12:24,760
a few iterations to figure out what it

00:12:22,390 --> 00:12:27,010
was but it's actually Java a Java

00:12:24,760 --> 00:12:29,320
interface unless it's on JavaScript but

00:12:27,010 --> 00:12:33,730
in which a case it's just a trait with

00:12:29,320 --> 00:12:36,490
nothing in it but it's just a marker

00:12:33,730 --> 00:12:37,570
trade and then I did make a type alias

00:12:36,490 --> 00:12:40,270
because I wanted something called org

00:12:37,570 --> 00:12:41,890
Scala test assertion so that is just a

00:12:40,270 --> 00:12:44,860
type alias for the more longer name or

00:12:41,890 --> 00:12:46,960
expelled as compatible assertion and the

00:12:44,860 --> 00:12:49,450
idea there is that now that this needs

00:12:46,960 --> 00:12:53,140
to show up at the end of a test if

00:12:49,450 --> 00:12:56,110
third-party libraries can't easily be or

00:12:53,140 --> 00:12:58,300
give an assertion then it's clunky right

00:12:56,110 --> 00:13:00,490
so what what we're planning to do we

00:12:58,300 --> 00:13:02,200
haven't done it yet actually is take the

00:13:00,490 --> 00:13:04,510
Java interface assertion it really said

00:13:02,200 --> 00:13:06,640
as a java jar that doesn't have the

00:13:04,510 --> 00:13:08,290
underscore spell a version number it

00:13:06,640 --> 00:13:11,080
just has that in it and that's that's

00:13:08,290 --> 00:13:12,850
easy to make a dependency to third-party

00:13:11,080 --> 00:13:14,170
libraries that want to add things right

00:13:12,850 --> 00:13:15,970
so they can be a skeleton assertion

00:13:14,170 --> 00:13:20,200
without actually depending on a version

00:13:15,970 --> 00:13:20,860
of scala test and then we took and added

00:13:20,200 --> 00:13:22,450
a super

00:13:20,860 --> 00:13:24,960
torito succeeded which was already

00:13:22,450 --> 00:13:29,790
existing and made succeeded in assertion

00:13:24,960 --> 00:13:35,770
so then what what we did with all of our

00:13:29,790 --> 00:13:43,590
mattress and assertions is we made them

00:13:35,770 --> 00:13:48,550
into basically in 20 this head type unit

00:13:43,590 --> 00:13:50,310
and return of the unit value so we

00:13:48,550 --> 00:13:53,020
change it to have type assertion and

00:13:50,310 --> 00:13:55,150
return succeeded so in the old days of

00:13:53,020 --> 00:13:58,120
return the unit singleton now returns to

00:13:55,150 --> 00:14:01,120
succeeded singleton but no code should

00:13:58,120 --> 00:14:02,950
really be affected by that and if it

00:14:01,120 --> 00:14:04,570
fails it does the same thing it did

00:14:02,950 --> 00:14:06,640
before it throws the same exception as

00:14:04,570 --> 00:14:08,890
before so all the old behavior is the

00:14:06,640 --> 00:14:11,530
same but the singleton that's returned

00:14:08,890 --> 00:14:14,860
when it succeeds is now succeeded and

00:14:11,530 --> 00:14:20,130
instead of unit okay and then we did the

00:14:14,860 --> 00:14:23,200
same thing for matters X should equal 1

00:14:20,130 --> 00:14:26,020
gives you the type of the expression is

00:14:23,200 --> 00:14:27,670
assertion the value is succeeded and if

00:14:26,020 --> 00:14:32,770
I change to I get the same exception I

00:14:27,670 --> 00:14:35,260
did before right okay so so now that's

00:14:32,770 --> 00:14:36,640
what the type of assert is so if you map

00:14:35,260 --> 00:14:42,240
that on you actually will get a future

00:14:36,640 --> 00:14:42,240
square brackets assertion okay and then

00:14:42,300 --> 00:14:47,410
what you can therefore do is this so

00:14:45,760 --> 00:14:49,240
this is how coat you know mr. code who

00:14:47,410 --> 00:14:52,660
submitted that issue could rewrite his

00:14:49,240 --> 00:14:54,790
his code to get it to work is instead of

00:14:52,660 --> 00:14:56,320
extending fun sweet he extends acing fun

00:14:54,790 --> 00:14:58,270
sweet and because of the whiff fixture

00:14:56,320 --> 00:15:00,640
impedance mismatch and because you got

00:14:58,270 --> 00:15:01,930
all this old code partly because of all

00:15:00,640 --> 00:15:05,080
the old code it made it impossible to do

00:15:01,930 --> 00:15:06,580
something bring it together but it's

00:15:05,080 --> 00:15:07,720
also just simpler I think if you don't

00:15:06,580 --> 00:15:09,370
need to work in future space it's

00:15:07,720 --> 00:15:11,620
simpler to have something like fun sweet

00:15:09,370 --> 00:15:14,440
and you know test function returns an

00:15:11,620 --> 00:15:16,240
outcome we made a sink variance of all

00:15:14,440 --> 00:15:17,860
the existing South rates so off to the

00:15:16,240 --> 00:15:20,350
side there's new ones so there's an

00:15:17,860 --> 00:15:22,540
async fun sweet now and in there what

00:15:20,350 --> 00:15:23,980
the type of the test is future assertion

00:15:22,540 --> 00:15:27,130
you need to give it a future assertion

00:15:23,980 --> 00:15:30,580
so given his future int that was truly

00:15:27,130 --> 00:15:32,290
async on JavaScript he can now just map

00:15:30,580 --> 00:15:33,760
his assertion onto it and get a future

00:15:32,290 --> 00:15:34,660
assertion back he passes that back to

00:15:33,760 --> 00:15:36,730
skeleton skull

00:15:34,660 --> 00:15:38,310
just puts it on the shelf basically it

00:15:36,730 --> 00:15:40,029
doesn't put on the shelf it registers

00:15:38,310 --> 00:15:42,370
callbacks right so that when that

00:15:40,029 --> 00:15:46,500
completes the events go to the reporter

00:15:42,370 --> 00:15:48,790
test succeeded test failed etc right and

00:15:46,500 --> 00:15:52,149
then we add in an implicit conversion

00:15:48,790 --> 00:15:59,019
from assertion to future assertion so

00:15:52,149 --> 00:16:01,990
that you could have tests that end in

00:15:59,019 --> 00:16:05,259
assertion so they're actually not a sink

00:16:01,990 --> 00:16:06,790
mixed in with tests that end in a future

00:16:05,259 --> 00:16:08,230
assertion because sometimes you'll have

00:16:06,790 --> 00:16:10,240
like half your test you want to have

00:16:08,230 --> 00:16:12,970
mapping futures and the other half were

00:16:10,240 --> 00:16:15,490
just normal right so that's that's where

00:16:12,970 --> 00:16:17,560
how we put it in and I wanted to show

00:16:15,490 --> 00:16:21,970
you a couple just to give you an idea of

00:16:17,560 --> 00:16:24,370
like how much of a change this was for

00:16:21,970 --> 00:16:25,949
us I mean for your code it should all it

00:16:24,370 --> 00:16:29,250
should be pretty easy to upgrade but

00:16:25,949 --> 00:16:31,990
there's something called inspectors in

00:16:29,250 --> 00:16:36,040
scale tests and give you an example X is

00:16:31,990 --> 00:16:40,779
equals list one two three if you import

00:16:36,040 --> 00:16:46,389
inspectors that underscore I can say for

00:16:40,779 --> 00:16:49,600
all X's given an X X should be greater

00:16:46,389 --> 00:16:53,199
than 1 i'm sorry great 0 I would have

00:16:49,600 --> 00:16:56,139
failed that test so this these are

00:16:53,199 --> 00:16:58,120
returns succeeded too because that could

00:16:56,139 --> 00:17:00,850
like you know it's an assertion really

00:16:58,120 --> 00:17:02,319
so it kind of you would make sense the

00:17:00,850 --> 00:17:05,530
problem is is if you had done something

00:17:02,319 --> 00:17:07,480
like this in existing code it would

00:17:05,530 --> 00:17:09,699
break and it's be very actually annoying

00:17:07,480 --> 00:17:11,919
to have all that broken code I wouldn't

00:17:09,699 --> 00:17:15,520
be easy to upgrade so we had to add

00:17:11,919 --> 00:17:16,990
complexity to the signature by adding

00:17:15,520 --> 00:17:19,480
more implicit there's another type class

00:17:16,990 --> 00:17:22,510
that looks at that infers the type here

00:17:19,480 --> 00:17:25,270
inside this function and if its type

00:17:22,510 --> 00:17:28,209
assertion then then the the for all

00:17:25,270 --> 00:17:29,440
results in type assertion otherwise if

00:17:28,209 --> 00:17:30,880
it's something else doesn't have to be

00:17:29,440 --> 00:17:33,669
unit it could be anything could be an

00:17:30,880 --> 00:17:36,250
int now that the type of 4 l's is is

00:17:33,669 --> 00:17:37,990
unit which is what it was before right

00:17:36,250 --> 00:17:41,860
so the difference here's what it was in

00:17:37,990 --> 00:17:43,780
20 this signature and the collecting is

00:17:41,860 --> 00:17:45,970
like ad hoc polymorphisms its type class

00:17:43,780 --> 00:17:47,740
that makes allows this to work on things

00:17:45,970 --> 00:17:48,430
for which it makes sense and no and not

00:17:47,740 --> 00:17:49,810
compile for

00:17:48,430 --> 00:17:52,750
on things for which it does not make

00:17:49,810 --> 00:17:54,760
sense but in three look at what happened

00:17:52,750 --> 00:17:57,400
to it it's got another thing called

00:17:54,760 --> 00:17:58,990
inspector asserting that is another type

00:17:57,400 --> 00:18:00,670
class it says you know actually work for

00:17:58,990 --> 00:18:03,460
anything because all that means all the

00:18:00,670 --> 00:18:05,920
old code works but if the type of that

00:18:03,460 --> 00:18:07,930
thing is assertion the result which is a

00:18:05,920 --> 00:18:10,390
dependent type is going to be assertion

00:18:07,930 --> 00:18:12,910
alright so that was forced on us by this

00:18:10,390 --> 00:18:14,140
it was really a big change and there's

00:18:12,910 --> 00:18:16,840
two everything's just parenthetically I

00:18:14,140 --> 00:18:20,620
want to mention we had to add position

00:18:16,840 --> 00:18:23,290
to a lot of things so a lot of of the

00:18:20,620 --> 00:18:25,690
the difficulty of supporting Scala jayus

00:18:23,290 --> 00:18:26,710
had nothing to do with Sebastian wasn't

00:18:25,690 --> 00:18:29,020
his fault ahead than having to do with

00:18:26,710 --> 00:18:30,790
JavaScript it had to do with I didn't

00:18:29,020 --> 00:18:33,040
see this coming so I did a lot of things

00:18:30,790 --> 00:18:35,320
that made sense on the JVM that don't

00:18:33,040 --> 00:18:38,620
work on JavaScript so i had to untie a

00:18:35,320 --> 00:18:40,660
scala test from the JVM so an example

00:18:38,620 --> 00:18:42,100
was the way like if you get a test

00:18:40,660 --> 00:18:44,380
failure there's this little link it says

00:18:42,100 --> 00:18:46,630
the file name and the line number where

00:18:44,380 --> 00:18:48,670
the exact assertion was that failed we

00:18:46,630 --> 00:18:51,100
did that historically by looking on the

00:18:48,670 --> 00:18:52,480
stack and just saying oh oh there it is

00:18:51,100 --> 00:18:55,930
it's that one so we put it in the

00:18:52,480 --> 00:18:58,600
information that the ID can use and that

00:18:55,930 --> 00:19:00,730
works fine on Java but it just isn't

00:18:58,600 --> 00:19:02,230
practical on JavaScript it just doesn't

00:19:00,730 --> 00:19:04,180
work so what we had to replace it with

00:19:02,230 --> 00:19:07,210
was this thing called a position which

00:19:04,180 --> 00:19:10,000
is passing implicitly and if there isn't

00:19:07,210 --> 00:19:11,830
one in scope be there's a default one in

00:19:10,000 --> 00:19:13,210
the companion object that uses a macro

00:19:11,830 --> 00:19:15,220
to ask the compiler hey where is this

00:19:13,210 --> 00:19:17,470
line of code and that actually worked

00:19:15,220 --> 00:19:20,320
great but it was an enormous amount of

00:19:17,470 --> 00:19:21,910
work now so that's that's in a lot of

00:19:20,320 --> 00:19:23,740
places anywhere where we needed to say

00:19:21,910 --> 00:19:26,140
this is where the failure was we had to

00:19:23,740 --> 00:19:27,640
add that and then we also since we added

00:19:26,140 --> 00:19:29,530
another implicit we went ahead and

00:19:27,640 --> 00:19:31,990
passed in a pretty fire pretty fire is

00:19:29,530 --> 00:19:34,840
just a way to change the to string of a

00:19:31,990 --> 00:19:36,460
type so that's also being passed in

00:19:34,840 --> 00:19:38,650
there but you can see how I mean really

00:19:36,460 --> 00:19:41,980
this whole exercise was a real struggle

00:19:38,650 --> 00:19:43,750
to add this feature people wanted which

00:19:41,980 --> 00:19:45,280
was a you know they wanted but they

00:19:43,750 --> 00:19:46,870
wanted is a full-featured test framework

00:19:45,280 --> 00:19:50,980
that worked both on the JVM on and on

00:19:46,870 --> 00:19:53,650
JavaScript without exploding complexity

00:19:50,980 --> 00:19:58,180
that was a real that was really hard

00:19:53,650 --> 00:19:59,650
okay so that's inspectors um so now this

00:19:58,180 --> 00:20:01,610
problem still I haven't shown you what

00:19:59,650 --> 00:20:04,730
we did with so this just doesn't work

00:20:01,610 --> 00:20:08,000
for a sink because you know the type of

00:20:04,730 --> 00:20:11,000
this function and the type of the whiff

00:20:08,000 --> 00:20:13,010
fixture method just like do get it just

00:20:11,000 --> 00:20:15,770
it says that the test is finished when

00:20:13,010 --> 00:20:17,510
these things return so what we ended up

00:20:15,770 --> 00:20:19,910
doing was this is there's very few

00:20:17,510 --> 00:20:21,440
breaking changes in 30 but there's five

00:20:19,910 --> 00:20:24,740
and I'll just go over and quickly at the

00:20:21,440 --> 00:20:27,080
end this one what I did is I took the

00:20:24,740 --> 00:20:28,429
width fix your method out of sweet and I

00:20:27,080 --> 00:20:31,730
moved it down into something new called

00:20:28,429 --> 00:20:34,549
test suite so what test suite represents

00:20:31,730 --> 00:20:38,809
is the the level of abstraction of sweet

00:20:34,549 --> 00:20:40,160
where the test function is defined where

00:20:38,809 --> 00:20:44,000
the type of the test function is defined

00:20:40,160 --> 00:20:45,830
so for the traditional styles that's

00:20:44,000 --> 00:20:47,210
test suite and it looked like it did

00:20:45,830 --> 00:20:49,010
before it's just the same as was in

00:20:47,210 --> 00:20:50,450
suite before but then we created this

00:20:49,010 --> 00:20:52,640
one called a sink test suite which is

00:20:50,450 --> 00:20:55,429
you know all the async styles are below

00:20:52,640 --> 00:20:57,710
that and instead of that typing outcome

00:20:55,429 --> 00:21:00,470
it's called future outcome and a future

00:20:57,710 --> 00:21:02,150
outcome all one word is just a wrapper

00:21:00,470 --> 00:21:04,040
object for future square brackets

00:21:02,150 --> 00:21:07,100
outcome so it is inside of future square

00:21:04,040 --> 00:21:08,630
brackets outcome but the problem with it

00:21:07,100 --> 00:21:11,600
was let me just show you in Scala doc

00:21:08,630 --> 00:21:13,070
here the problem with just I mean ever

00:21:11,600 --> 00:21:17,630
initially it was future outcome with

00:21:13,070 --> 00:21:19,730
square brackets but in futures like the

00:21:17,630 --> 00:21:21,290
result of a futures model with a try and

00:21:19,730 --> 00:21:24,200
a try is either a success or a failure

00:21:21,290 --> 00:21:27,770
right so it means a future outcome could

00:21:24,200 --> 00:21:30,620
be a success failed or a success

00:21:27,770 --> 00:21:32,660
succeeded or if but it can't be a failed

00:21:30,620 --> 00:21:34,040
failed right it's just very can be very

00:21:32,660 --> 00:21:37,669
confusing for users that was one problem

00:21:34,040 --> 00:21:38,840
and the other problem is in production

00:21:37,669 --> 00:21:40,940
code you actually want something

00:21:38,840 --> 00:21:43,790
different than in test code and to make

00:21:40,940 --> 00:21:45,200
things consistent they're worth um some

00:21:43,790 --> 00:21:47,240
things that were quite clunky with

00:21:45,200 --> 00:21:50,150
future and I'll show you an example

00:21:47,240 --> 00:21:52,090
insect but what future alikum gives you

00:21:50,150 --> 00:21:54,799
is just the methods that makes sense for

00:21:52,090 --> 00:21:57,650
you know transforming future outcomes

00:21:54,799 --> 00:22:01,160
with consistent naming that matches

00:21:57,650 --> 00:22:03,950
testing a lot of it is registering

00:22:01,160 --> 00:22:07,970
callbacks right and you can use these in

00:22:03,950 --> 00:22:09,260
your within your with fixture method it

00:22:07,970 --> 00:22:11,510
takes future outcome because you will

00:22:09,260 --> 00:22:14,059
transform them that way and the the

00:22:11,510 --> 00:22:15,100
breaking change is that though that old

00:22:14,059 --> 00:22:18,140
though

00:22:15,100 --> 00:22:20,900
old traits that you factored out common

00:22:18,140 --> 00:22:23,180
with fixture methods will break because

00:22:20,900 --> 00:22:24,890
they say they extend sweet mix in and

00:22:23,180 --> 00:22:26,990
their accor writing with fixture it's

00:22:24,890 --> 00:22:29,570
not there anymore right I've moved it

00:22:26,990 --> 00:22:31,130
down to test suite and test we mix in so

00:22:29,570 --> 00:22:32,570
what you all you have to do to fix it is

00:22:31,130 --> 00:22:34,160
that will just not compile and you go

00:22:32,570 --> 00:22:35,660
and you put the word you know the bold

00:22:34,160 --> 00:22:37,610
test that you just put that in from

00:22:35,660 --> 00:22:39,380
those two places and it's the same so I

00:22:37,610 --> 00:22:41,240
think that should be you know that'll

00:22:39,380 --> 00:22:45,530
affect some people but it would should

00:22:41,240 --> 00:22:47,780
be pretty quick pretty quick and then

00:22:45,530 --> 00:22:51,710
another problem was like coming back to

00:22:47,780 --> 00:22:56,210
this is uh may go back to that one the

00:22:51,710 --> 00:22:58,520
one where I had a they try fine light

00:22:56,210 --> 00:23:01,760
this one's easier to see so try test

00:22:58,520 --> 00:23:04,760
finally clean up if you do that in a a

00:23:01,760 --> 00:23:07,130
sink with fixture when you say try test

00:23:04,760 --> 00:23:09,020
it returns a future outcome so the test

00:23:07,130 --> 00:23:10,250
has can actually finished yet so now

00:23:09,020 --> 00:23:12,140
you're finally block is going to be

00:23:10,250 --> 00:23:14,420
executed and it will do the cleanup too

00:23:12,140 --> 00:23:18,380
soon alright so you can't use try

00:23:14,420 --> 00:23:19,700
finally with an async well with a future

00:23:18,380 --> 00:23:21,800
it doesn't work it does the cleanup too

00:23:19,700 --> 00:23:23,660
soon so we had I came up with a new

00:23:21,800 --> 00:23:26,510
syntax build complete lastly which is

00:23:23,660 --> 00:23:30,860
like try finally for futures futuristic

00:23:26,510 --> 00:23:33,320
things so that looks like this so you

00:23:30,860 --> 00:23:34,760
just say complete and then in there you

00:23:33,320 --> 00:23:36,500
have to have some code that produces

00:23:34,760 --> 00:23:38,000
something that's futuristic so there's a

00:23:36,500 --> 00:23:41,840
new type class called futuristic which I

00:23:38,000 --> 00:23:43,370
thought was cool because you need it I

00:23:41,840 --> 00:23:46,190
wanted it to work for future of any type

00:23:43,370 --> 00:23:47,480
T or future outcome so that I needed to

00:23:46,190 --> 00:23:50,990
be you know I had to create a type class

00:23:47,480 --> 00:23:53,420
for it and what it will do is if that

00:23:50,990 --> 00:23:55,130
blows up with an exception lastly works

00:23:53,420 --> 00:23:56,690
just like finally it just excuse the

00:23:55,130 --> 00:23:59,780
clean up right then and there before the

00:23:56,690 --> 00:24:01,370
thing is propagated the exception but if

00:23:59,780 --> 00:24:03,110
it doesn't throw an exception that you

00:24:01,370 --> 00:24:05,900
get means you got some futuristic thing

00:24:03,110 --> 00:24:07,580
back it just registers that clean up

00:24:05,900 --> 00:24:12,970
code to be executed after the future

00:24:07,580 --> 00:24:12,970
completes and returns a new future that

00:24:14,710 --> 00:24:18,650
doesn't complete until both the original

00:24:16,850 --> 00:24:21,260
feature complete and the cleanup has

00:24:18,650 --> 00:24:22,730
finished and if the cleanup blows up

00:24:21,260 --> 00:24:24,110
with an exception it actually feels with

00:24:22,730 --> 00:24:25,310
that exception so that's that's an

00:24:24,110 --> 00:24:27,260
example of something that you can do

00:24:25,310 --> 00:24:28,250
with future square brackets outcome but

00:24:27,260 --> 00:24:32,240
it will actually take two meth

00:24:28,250 --> 00:24:35,960
calls so it's actually quite clunky but

00:24:32,240 --> 00:24:37,460
in in future outcome the new type that

00:24:35,960 --> 00:24:39,980
we created it's just one method achill

00:24:37,460 --> 00:24:41,360
so that's complete lastly and then

00:24:39,980 --> 00:24:43,130
another thing that was kind of an

00:24:41,360 --> 00:24:44,900
impedance mismatch now that we need a

00:24:43,130 --> 00:24:47,750
type at the end of a test called

00:24:44,900 --> 00:24:49,400
assertion was intercept is used a lot by

00:24:47,750 --> 00:24:51,770
people and what intercept does is ensure

00:24:49,400 --> 00:24:53,900
that a bit of code goes an expected

00:24:51,770 --> 00:24:55,640
exception and then it returns that

00:24:53,900 --> 00:24:57,920
exception so that in case you want to

00:24:55,640 --> 00:24:59,900
inspect it further saying this exception

00:24:57,920 --> 00:25:01,610
now money is it a string index out of

00:24:59,900 --> 00:25:06,080
bounds exception but it's error message

00:25:01,610 --> 00:25:07,820
starts with this word or something that

00:25:06,080 --> 00:25:11,540
worked fine except it doesn't have type

00:25:07,820 --> 00:25:13,010
assertion it actually has type I can't

00:25:11,540 --> 00:25:14,540
change that to be type assertion because

00:25:13,010 --> 00:25:15,800
it has the type of the exception you put

00:25:14,540 --> 00:25:17,660
in square brackets the expected

00:25:15,800 --> 00:25:19,610
exception so I added a new thing called

00:25:17,660 --> 00:25:21,140
exert throws which does the same thing

00:25:19,610 --> 00:25:23,870
as intercept except it returns type

00:25:21,140 --> 00:25:25,760
assertion so the going forward the the

00:25:23,870 --> 00:25:27,980
recommended style is always use the

00:25:25,760 --> 00:25:30,290
third throws unless you actually need to

00:25:27,980 --> 00:25:33,020
do an assertion on the exception that is

00:25:30,290 --> 00:25:34,190
caught and then use intercept because

00:25:33,020 --> 00:25:35,990
you do the intercept you grab these

00:25:34,190 --> 00:25:37,100
except affected exception then you do in

00:25:35,990 --> 00:25:40,640
a search and now you have an assertion

00:25:37,100 --> 00:25:44,030
right okay but that doesn't work in a

00:25:40,640 --> 00:25:47,630
sink so imagine this first line of code

00:25:44,030 --> 00:25:49,490
I can't say future map and then this

00:25:47,630 --> 00:25:51,710
value coming in somehow assert throws

00:25:49,490 --> 00:25:54,200
because first of all if the future fails

00:25:51,710 --> 00:25:56,480
the function pass the map doesn't get

00:25:54,200 --> 00:25:59,570
executed it just passed you know the

00:25:56,480 --> 00:26:01,970
result of the future that is comes back

00:25:59,570 --> 00:26:05,510
from the map call just it just gets the

00:26:01,970 --> 00:26:06,980
same failure as the original future so

00:26:05,510 --> 00:26:07,880
that wouldn't work and then the second

00:26:06,980 --> 00:26:09,410
one doesn't make any sense either

00:26:07,880 --> 00:26:10,640
because the future inside the cert

00:26:09,410 --> 00:26:12,890
throws doesn't actually throw anything

00:26:10,640 --> 00:26:16,790
it just fails with an exception doesn't

00:26:12,890 --> 00:26:19,400
throw it right so in the future API that

00:26:16,790 --> 00:26:21,200
is called the concept of like expecting

00:26:19,400 --> 00:26:23,870
an exception and recovering from it is

00:26:21,200 --> 00:26:26,720
called recover so I named these these

00:26:23,870 --> 00:26:29,120
two methods recover two and they're like

00:26:26,720 --> 00:26:32,720
the first one is like intercept for a

00:26:29,120 --> 00:26:34,490
sink intercept for futures recover two

00:26:32,720 --> 00:26:37,190
exception if illegalstateexception this

00:26:34,490 --> 00:26:40,270
thing takes a future futuristic thing

00:26:37,190 --> 00:26:41,990
inside if that fails with

00:26:40,270 --> 00:26:44,510
illegalstateexception that

00:26:41,990 --> 00:26:45,380
expected it will actually transform that

00:26:44,510 --> 00:26:47,150
future into a future

00:26:45,380 --> 00:26:48,980
illegalstateexception it'll actually be

00:26:47,150 --> 00:26:50,270
in there because then you can do an

00:26:48,980 --> 00:26:51,559
assertion on that you can map an

00:26:50,270 --> 00:26:53,000
assertion on that saying oh and that

00:26:51,559 --> 00:26:54,020
illegal state exceptions error message

00:26:53,000 --> 00:26:56,150
should start with something and now

00:26:54,020 --> 00:26:57,650
you've got a future assertion right so

00:26:56,150 --> 00:26:59,870
that's like intercept but in future

00:26:57,650 --> 00:27:03,020
space and the one down here recover to

00:26:59,870 --> 00:27:04,160
succeed it if is just saying all i care

00:27:03,020 --> 00:27:05,990
about is that it throws that I don't

00:27:04,160 --> 00:27:07,760
want to look at anymore so that's that

00:27:05,990 --> 00:27:09,410
could be an assertion that ends a test

00:27:07,760 --> 00:27:12,830
because what it changes the future of

00:27:09,410 --> 00:27:14,330
whatever to is a future assertion okay

00:27:12,830 --> 00:27:20,000
so that's two two more things we had to

00:27:14,330 --> 00:27:24,320
invent and then lastly what I would like

00:27:20,000 --> 00:27:27,800
to kind of give you as a puzzler there's

00:27:24,320 --> 00:27:30,260
another this one like a design question

00:27:27,800 --> 00:27:33,770
that was really hard and I'll show I'm

00:27:30,260 --> 00:27:34,880
not sure I got it right but um well I'm

00:27:33,770 --> 00:27:36,290
gonna give you a hint which is that

00:27:34,880 --> 00:27:37,880
scale test video has something called

00:27:36,290 --> 00:27:40,880
the serial execution context but I won't

00:27:37,880 --> 00:27:46,730
say what that is so the puzzler is

00:27:40,880 --> 00:27:49,970
actually this person's it was submitted

00:27:46,730 --> 00:27:51,230
as an issue for a skull test 30 RC one

00:27:49,970 --> 00:27:55,220
or two I mean it's a very recent issue

00:27:51,230 --> 00:27:56,570
and in I did change something for this

00:27:55,220 --> 00:28:00,020
but I don't actually think it's a bug

00:27:56,570 --> 00:28:04,130
its intended behavior so his code is a

00:28:00,020 --> 00:28:06,860
little bit I think I'll be easier to it

00:28:04,130 --> 00:28:09,140
less a hard to be a less of a puzzler if

00:28:06,860 --> 00:28:12,710
I show you in a different way so I did

00:28:09,140 --> 00:28:14,600
change one thing but this this code

00:28:12,710 --> 00:28:16,460
actually works fine on the JVM but it

00:28:14,600 --> 00:28:17,390
doesn't work on JavaScript if throws it

00:28:16,460 --> 00:28:18,860
through that index out of bounds

00:28:17,390 --> 00:28:20,300
exception and now what it'll throw is

00:28:18,860 --> 00:28:23,830
I'm not allowed exception with with a

00:28:20,300 --> 00:28:27,350
better hint as to what the problem is

00:28:23,830 --> 00:28:31,040
but what he did is he he has this gettin

00:28:27,350 --> 00:28:34,610
a method that has a hard-coded execution

00:28:31,040 --> 00:28:38,620
context which is called global so on the

00:28:34,610 --> 00:28:42,950
JVM global means a thread pool on

00:28:38,620 --> 00:28:44,720
JavaScript it's the q1 it means put it

00:28:42,950 --> 00:28:46,580
in the queue and I'm just looking at

00:28:44,720 --> 00:28:49,600
Sebastian make sure I'm not lying okay

00:28:46,580 --> 00:28:53,090
okay I don't think I'm lying so and

00:28:49,600 --> 00:28:55,820
inside Scala test

00:28:53,090 --> 00:28:57,020
in an earlier version I thought jeez you

00:28:55,820 --> 00:28:58,220
know I have no idea what execution

00:28:57,020 --> 00:29:00,050
context people going to want to use so

00:28:58,220 --> 00:29:01,520
I'm just going to make them say one all

00:29:00,050 --> 00:29:03,260
right so I just it wouldn't compile it

00:29:01,520 --> 00:29:05,060
and this used to not compile the lower

00:29:03,260 --> 00:29:07,250
code there because it doesn't have an

00:29:05,060 --> 00:29:09,880
execution context but I added a default

00:29:07,250 --> 00:29:17,120
one it's called serial execution context

00:29:09,880 --> 00:29:19,640
so I'll explain it in a bit but it it if

00:29:17,120 --> 00:29:21,260
so there's a default one just to get rid

00:29:19,640 --> 00:29:26,120
of boilerplate code and if you want to

00:29:21,260 --> 00:29:28,640
change it what you do is this you just

00:29:26,120 --> 00:29:30,110
say override app yeah basically it's

00:29:28,640 --> 00:29:31,850
called execution context this is you

00:29:30,110 --> 00:29:33,890
know something inherited by any async

00:29:31,850 --> 00:29:35,120
style trait you have this and you can

00:29:33,890 --> 00:29:36,500
override it and change it so on

00:29:35,120 --> 00:29:39,440
JavaScript maybe i'll make it to run now

00:29:36,500 --> 00:29:42,380
execution context on on the JVM maybe I

00:29:39,440 --> 00:29:46,910
make global whatever right so so the

00:29:42,380 --> 00:29:48,860
puzzler is you know what I told him is

00:29:46,910 --> 00:29:51,980
you know I think it's your bug not my

00:29:48,860 --> 00:29:56,120
book kind of I mean maybe it isn't but

00:29:51,980 --> 00:30:02,390
there's like a code style questionable

00:29:56,120 --> 00:30:04,550
style here ah so I I noticed last talk

00:30:02,390 --> 00:30:06,830
Holden said he'd give away free book so

00:30:04,550 --> 00:30:08,390
I'm gonna give away this free book to

00:30:06,830 --> 00:30:10,640
whoever answers first but the I know I

00:30:08,390 --> 00:30:12,050
actually can't be first no I hate us

00:30:10,640 --> 00:30:14,600
first you don't have to even be correct

00:30:12,050 --> 00:30:16,450
just have to be brave anybody uh

00:30:14,600 --> 00:30:24,770
basically the question of the puzzler is

00:30:16,450 --> 00:30:27,590
yeah you can I should be future that's

00:30:24,770 --> 00:30:30,160
successful you know I I think in life

00:30:27,590 --> 00:30:37,250
that's true but i'm not sure about

00:30:30,160 --> 00:30:39,950
future 'don't 00 actually you not only

00:30:37,250 --> 00:30:41,300
that's actually a that's that is true

00:30:39,950 --> 00:30:43,610
that's a I never thought of saying it

00:30:41,300 --> 00:30:47,270
that way I'm going to you get the free

00:30:43,610 --> 00:30:48,860
book awesome but you can come up and get

00:30:47,270 --> 00:30:50,120
a house I might you might look like

00:30:48,860 --> 00:30:54,520
every other red shirt around here I'll

00:30:50,120 --> 00:30:56,630
come hey I can walk around um what uh

00:30:54,520 --> 00:31:01,460
why did you say that it should be

00:30:56,630 --> 00:31:03,990
featured a successful yeah me you can

00:31:01,460 --> 00:31:08,350
tell ya

00:31:03,990 --> 00:31:12,039
successful doesn't need an execution

00:31:08,350 --> 00:31:13,179
contact yep so I thought well that's

00:31:12,039 --> 00:31:15,549
problem yeah that would have solved the

00:31:13,179 --> 00:31:18,070
problem actually but but this was kind

00:31:15,549 --> 00:31:20,470
of I think what he had shown here yeah

00:31:18,070 --> 00:31:23,710
thanks what he has shown here was a kind

00:31:20,470 --> 00:31:25,330
of contrived code to demo the problem

00:31:23,710 --> 00:31:28,029
and since cultists what he thought in

00:31:25,330 --> 00:31:30,220
the release candidate and in his real

00:31:28,029 --> 00:31:31,720
Kody probably maybe let's assume he does

00:31:30,220 --> 00:31:38,710
need an execution context so what would

00:31:31,720 --> 00:31:41,139
he do differently yes Sebastian exactly

00:31:38,710 --> 00:31:42,549
that's what I think so I so it means the

00:31:41,139 --> 00:31:43,779
same it's the same problem right but

00:31:42,549 --> 00:31:46,480
where the way you solved it is just said

00:31:43,779 --> 00:31:48,340
don't use in it don't take an execution

00:31:46,480 --> 00:31:50,889
context here so what isn't seen here is

00:31:48,340 --> 00:31:52,360
behind the scenes they're the future dot

00:31:50,889 --> 00:31:54,610
apply factory method does take an

00:31:52,360 --> 00:31:57,999
execution context and so it's going to

00:31:54,610 --> 00:32:01,929
bring in that implicit global one which

00:31:57,999 --> 00:32:04,179
on javascript is the q1 but getting them

00:32:01,929 --> 00:32:05,860
doesn't pass one in so when you call get

00:32:04,179 --> 00:32:08,590
numb it's basically hard code it's like

00:32:05,860 --> 00:32:10,330
static cling right it's hard coded to

00:32:08,590 --> 00:32:12,279
one execution context which is usually a

00:32:10,330 --> 00:32:13,450
bad idea because you can't i'll give you

00:32:12,279 --> 00:32:14,499
that all over the place and you need to

00:32:13,450 --> 00:32:16,539
change it you'd have to go all over the

00:32:14,499 --> 00:32:18,340
place and change the hard-coded things

00:32:16,539 --> 00:32:21,309
you normally want to pass it down then

00:32:18,340 --> 00:32:23,619
you can configure it so i think it's and

00:32:21,309 --> 00:32:25,240
if he did that then down here where he

00:32:23,619 --> 00:32:29,740
called getting them it would pick up

00:32:25,240 --> 00:32:31,690
scala tests a serial execution context

00:32:29,740 --> 00:32:34,419
and everything would work fine right so

00:32:31,690 --> 00:32:35,830
i think it did find a bug but I'm the

00:32:34,419 --> 00:32:37,419
jvm it doesn't find a book cousin jeigh

00:32:35,830 --> 00:32:39,820
via works and the way it works is kind

00:32:37,419 --> 00:32:43,450
of weird because of like that mantra

00:32:39,820 --> 00:32:46,299
never ever block on a web server I think

00:32:43,450 --> 00:32:48,789
that makes sense to make maximum use of

00:32:46,299 --> 00:32:50,350
threads but on when you're running a

00:32:48,789 --> 00:32:53,019
test if you have like a million tests

00:32:50,350 --> 00:32:54,039
running it once that may not be aiming

00:32:53,019 --> 00:32:55,960
your mail you're making maximum use of

00:32:54,039 --> 00:32:58,179
threads but all your tests will timeout

00:32:55,960 --> 00:33:00,700
because nobody can get anything done so

00:32:58,179 --> 00:33:03,249
what we do is that what this the way the

00:33:00,700 --> 00:33:05,889
serial execution context works is when

00:33:03,249 --> 00:33:07,419
you do a map and the execution context

00:33:05,889 --> 00:33:09,909
is used it doesn't actually execute it

00:33:07,419 --> 00:33:12,700
it just remembers it just as okay I some

00:33:09,909 --> 00:33:14,259
point later I have to do this task and

00:33:12,700 --> 00:33:16,929
it just keeps track all those and you

00:33:14,259 --> 00:33:17,400
get this this job queue and then when

00:33:16,929 --> 00:33:20,340
the

00:33:17,400 --> 00:33:23,010
the test body exits you've got a future

00:33:20,340 --> 00:33:24,690
assertion and what's kalfus will do

00:33:23,010 --> 00:33:27,120
internally say was this execution

00:33:24,690 --> 00:33:29,430
context used was our internal serial

00:33:27,120 --> 00:33:31,650
action context use and if so uses the

00:33:29,430 --> 00:33:34,700
same thread to execute those things and

00:33:31,650 --> 00:33:37,500
then if there are other threads involved

00:33:34,700 --> 00:33:41,520
on the JVM what we do internally is

00:33:37,500 --> 00:33:43,650
block which is kind of you never do that

00:33:41,520 --> 00:33:44,730
in a web server but in the test actually

00:33:43,650 --> 00:33:46,290
it makes sense because that's how you

00:33:44,730 --> 00:33:47,610
can throttle how many tests are running

00:33:46,290 --> 00:33:50,550
is by how many threads you have going

00:33:47,610 --> 00:33:54,750
right so anyway that was just another

00:33:50,550 --> 00:34:05,160
example of how you know some of the

00:33:54,750 --> 00:34:07,470
challenges and then I just before I was

00:34:05,160 --> 00:34:17,909
a little foreshadowing unintentional but

00:34:07,470 --> 00:34:19,050
uh before before I should go to Q&A I

00:34:17,909 --> 00:34:22,110
just wanted to quickly go through the

00:34:19,050 --> 00:34:24,540
breaking changes one of them is that

00:34:22,110 --> 00:34:26,790
good and bad in scholastic so Scala test

00:34:24,540 --> 00:34:29,100
galactic is a smaller library that are

00:34:26,790 --> 00:34:29,909
things people ask for in Scala tests but

00:34:29,100 --> 00:34:33,510
they also want to use in the production

00:34:29,909 --> 00:34:34,530
code and and so they're always released

00:34:33,510 --> 00:34:35,850
together and they have the same version

00:34:34,530 --> 00:34:38,220
number so there can that's how you know

00:34:35,850 --> 00:34:39,570
what's compatible and so good and bad

00:34:38,220 --> 00:34:41,399
had to type parameters and one of them

00:34:39,570 --> 00:34:43,500
was unnecessary so I just removed it so

00:34:41,399 --> 00:34:44,640
that that will break little or no code I

00:34:43,500 --> 00:34:46,590
think because most times people don't

00:34:44,640 --> 00:34:47,970
say those type parameters it works the

00:34:46,590 --> 00:34:51,390
same it's just the one that wasn't

00:34:47,970 --> 00:34:53,550
needed is gone because we started using

00:34:51,390 --> 00:34:56,370
pretty far passing prettified did exist

00:34:53,550 --> 00:35:00,630
before but now we're passing it in as an

00:34:56,370 --> 00:35:02,160
implicit and in the old days this is you

00:35:00,630 --> 00:35:04,230
think you'll be thankful I did this in

00:35:02,160 --> 00:35:05,520
the old days it extended any to string

00:35:04,230 --> 00:35:07,230
it was like a function one handy to

00:35:05,520 --> 00:35:08,430
string so by making it using it

00:35:07,230 --> 00:35:11,430
implicitly now you've got an implicit

00:35:08,430 --> 00:35:13,230
any to string which is like the most one

00:35:11,430 --> 00:35:15,000
of the most evil things I could do so I

00:35:13,230 --> 00:35:16,470
I suffered that but that will likely

00:35:15,000 --> 00:35:19,020
break no code because no one was using

00:35:16,470 --> 00:35:20,610
it as a function pretty methods we also

00:35:19,020 --> 00:35:21,570
changed is taken a plus a parada fire

00:35:20,610 --> 00:35:22,950
that should break very little code

00:35:21,570 --> 00:35:25,980
because most people didn't use it and

00:35:22,950 --> 00:35:27,270
it's very easy to fix this time lighted

00:35:25,980 --> 00:35:28,710
test though basically there's something

00:35:27,270 --> 00:35:29,790
called timeouts that was very JVM

00:35:28,710 --> 00:35:30,720
specific it used something called

00:35:29,790 --> 00:35:32,550
interrupter

00:35:30,720 --> 00:35:33,720
which the fulton mo implementations was

00:35:32,550 --> 00:35:36,119
to interrupt a thread that doesn't work

00:35:33,720 --> 00:35:37,920
on JavaScript so we changed something to

00:35:36,119 --> 00:35:40,170
time we made something called new called

00:35:37,920 --> 00:35:42,720
time limits and it has something called

00:35:40,170 --> 00:35:44,010
signaler and its default is to not do

00:35:42,720 --> 00:35:45,990
anything the other thing that's hard to

00:35:44,010 --> 00:35:48,210
interrupt is futures you just can't

00:35:45,990 --> 00:35:51,920
there's no api and features to to change

00:35:48,210 --> 00:35:54,119
like say stop doing which doing so

00:35:51,920 --> 00:35:55,920
timeout still works the same but now

00:35:54,119 --> 00:35:57,270
timeouts and interrupters are deprecated

00:35:55,920 --> 00:35:59,240
so you'll have a year or two to like

00:35:57,270 --> 00:36:01,320
transform it over to time limits and

00:35:59,240 --> 00:36:02,220
that's pretty straightforward but it's

00:36:01,320 --> 00:36:05,340
not you don't have to do it right away

00:36:02,220 --> 00:36:07,890
to upgrade but time limited tests it was

00:36:05,340 --> 00:36:09,570
just I I kind of needed to change that

00:36:07,890 --> 00:36:11,040
to use time limit so that when people

00:36:09,570 --> 00:36:13,380
using time of the tests will have to

00:36:11,040 --> 00:36:15,030
change before they upgrade from timeouts

00:36:13,380 --> 00:36:19,050
to time limits you know from inner

00:36:15,030 --> 00:36:19,859
interrupter 22 signaler so and then

00:36:19,050 --> 00:36:21,090
there's this one that I already

00:36:19,859 --> 00:36:22,680
mentioned where you have to put the word

00:36:21,090 --> 00:36:24,480
test in front of sweet mix it in and

00:36:22,680 --> 00:36:25,500
sweet that should be pretty

00:36:24,480 --> 00:36:27,450
straightforward and the last one is

00:36:25,500 --> 00:36:30,210
mostly a skull test itself and tools

00:36:27,450 --> 00:36:32,190
vendors there's something called when

00:36:30,210 --> 00:36:34,410
completed on status which users don't

00:36:32,190 --> 00:36:38,070
usually use and it used to take a

00:36:34,410 --> 00:36:40,140
boolean to unit and status was a sink

00:36:38,070 --> 00:36:43,260
before but it was just used for making

00:36:40,140 --> 00:36:45,980
sure after code and after all happened

00:36:43,260 --> 00:36:48,660
after a parallel test finished right and

00:36:45,980 --> 00:36:52,230
it just we had it turned out we had to

00:36:48,660 --> 00:36:54,690
add make out a try because there were

00:36:52,230 --> 00:36:56,280
now situations where you could end up

00:36:54,690 --> 00:36:58,200
with a an exception that could should

00:36:56,280 --> 00:37:00,270
call this the run to fail but in a

00:36:58,200 --> 00:37:01,800
different thread right so that shouldn't

00:37:00,270 --> 00:37:06,930
really affect anybody and that's it so I

00:37:01,800 --> 00:37:10,020
think upgrading should be easy and I'm

00:37:06,930 --> 00:37:12,330
back baby what's been happening I I just

00:37:10,020 --> 00:37:14,070
last night got I was ahead maybe too

00:37:12,330 --> 00:37:15,570
many lines and I was tricked into

00:37:14,070 --> 00:37:18,960
promising that I would show table hassle

00:37:15,570 --> 00:37:21,660
off so that's that's my own explanation

00:37:18,960 --> 00:37:23,190
but I do keep my promises I don't think

00:37:21,660 --> 00:37:25,500
that's his real twitter account because

00:37:23,190 --> 00:37:26,910
a is he's not that young anymore and I

00:37:25,500 --> 00:37:29,820
don't I think it's like making fun of

00:37:26,910 --> 00:37:31,980
him but I thought that was funny and I

00:37:29,820 --> 00:37:33,839
think did if those chichis got passed

00:37:31,980 --> 00:37:35,250
out I just had 50 leftovers from New

00:37:33,839 --> 00:37:36,570
York and I thought I'd given you guys

00:37:35,250 --> 00:37:37,830
they just have like all some of the new

00:37:36,570 --> 00:37:38,790
things on there those of you they got

00:37:37,830 --> 00:37:40,560
the cheat sheets I hope you like them

00:37:38,790 --> 00:37:43,890
and then I will take questions I

00:37:40,560 --> 00:37:45,180
probably five minutes or so yeah

00:37:43,890 --> 00:37:50,970
I have seven minutes for questions

00:37:45,180 --> 00:37:55,049
please come up to the mic yep I am so

00:37:50,970 --> 00:37:58,230
for the ok so the for the futures for

00:37:55,049 --> 00:38:00,180
the before and before a test for the

00:37:58,230 --> 00:38:06,869
with fixture is there any way to get a

00:38:00,180 --> 00:38:08,099
the set up into a future as well I'm not

00:38:06,869 --> 00:38:10,410
sure I understood the question that 40

00:38:08,099 --> 00:38:12,329
may go back to thee can you repeat the

00:38:10,410 --> 00:38:14,579
question so is there a slide with fixed

00:38:12,329 --> 00:38:16,769
you in the second part there ok yeah the

00:38:14,579 --> 00:38:18,720
complete and the lastly are are

00:38:16,769 --> 00:38:21,990
implicitly futures board about the setup

00:38:18,720 --> 00:38:24,390
as well oh maybe I'm talking to the mic

00:38:21,990 --> 00:38:26,180
it might be directional yeah sorry there

00:38:24,390 --> 00:38:29,220
you go that's better alright okay sorry

00:38:26,180 --> 00:38:32,519
for the width fixture yeah we're Clint

00:38:29,220 --> 00:38:36,029
and the lastly return the future outcome

00:38:32,519 --> 00:38:37,460
wreck but the setup what what happens

00:38:36,029 --> 00:38:40,619
with the setup is there any way of

00:38:37,460 --> 00:38:47,269
forcing a setup to be in a future as

00:38:40,619 --> 00:38:47,269
well um if you will step in the future

00:38:48,049 --> 00:38:53,640
uh-huh I've never no one ever asked for

00:38:51,869 --> 00:38:59,009
that so you'd have to do that yourself

00:38:53,640 --> 00:39:01,859
basically what yeah I'll have to think

00:38:59,009 --> 00:39:04,619
about that well let's let's talk after

00:39:01,859 --> 00:39:09,029
but no one ever had never occurred to me

00:39:04,619 --> 00:39:13,230
in the past any other question yes Hey

00:39:09,029 --> 00:39:14,369
oh yeah complete lessees is let's not

00:39:13,230 --> 00:39:17,730
miss wrecking that you never mind please

00:39:14,369 --> 00:39:19,829
please go ahead so one related problem

00:39:17,730 --> 00:39:22,619
an ocean to the synchronous testing is a

00:39:19,829 --> 00:39:24,059
idea of virtual time so imagine if you

00:39:22,619 --> 00:39:25,950
test something that you know code with

00:39:24,059 --> 00:39:28,920
delays or read tries you know like route

00:39:25,950 --> 00:39:31,529
right after you know you know or try ten

00:39:28,920 --> 00:39:34,109
times after one second waiting so if you

00:39:31,529 --> 00:39:37,259
test this like with real time the test

00:39:34,109 --> 00:39:39,029
will take 10 seconds but you know some

00:39:37,259 --> 00:39:42,329
systems they introduce this virtual time

00:39:39,029 --> 00:39:45,660
and do you have any plans for skeletons

00:39:42,329 --> 00:39:47,700
to have something like this I haven't

00:39:45,660 --> 00:39:49,380
heard that request either so that's the

00:39:47,700 --> 00:39:50,670
question was about virtual time which is

00:39:49,380 --> 00:39:51,990
interesting but we don't we don't have

00:39:50,670 --> 00:39:54,089
anything currently and I don't have any

00:39:51,990 --> 00:39:55,920
plans either but not I'm curious we may

00:39:54,089 --> 00:39:58,550
come talk to me after be interested in

00:39:55,920 --> 00:40:03,150
that hearing about what that is

00:39:58,550 --> 00:40:04,859
anybody else boy I need more I need more

00:40:03,150 --> 00:40:07,500
free books it tell you what if you

00:40:04,859 --> 00:40:08,820
answer ask a question you can get a copy

00:40:07,500 --> 00:40:14,130
of that down at the code centric both

00:40:08,820 --> 00:40:19,950
for free I tricked you but it's a nice

00:40:14,130 --> 00:40:21,570
magazine anyone it's all good I think

00:40:19,950 --> 00:40:24,660
you said that complete lastly that the

00:40:21,570 --> 00:40:28,230
complete block accepts a return type of

00:40:24,660 --> 00:40:30,510
any futuristic but the with fixture is

00:40:28,230 --> 00:40:32,310
set to return a future outcome how do

00:40:30,510 --> 00:40:40,380
you turn the futuristic into a future

00:40:32,310 --> 00:40:43,520
outcome oh it's so I can show you

00:40:40,380 --> 00:40:45,960
futuristic but basically you usually

00:40:43,520 --> 00:40:48,330
well let's go look at it I'll show you

00:40:45,960 --> 00:40:58,170
futuristic oh no that's not it that's

00:40:48,330 --> 00:41:00,150
this guy um there's futuristic it's just

00:40:58,170 --> 00:41:03,270
a type class it says few search of tea

00:41:00,150 --> 00:41:06,210
and I pass in basically I'd pass in the

00:41:03,270 --> 00:41:07,560
futuristic I pass in the cleanup method

00:41:06,210 --> 00:41:09,930
and I give back the same thing so if

00:41:07,560 --> 00:41:11,849
it's a future int I get back a future

00:41:09,930 --> 00:41:13,200
aunt if it's a future outcome you know

00:41:11,849 --> 00:41:16,619
one of these things I get back a future

00:41:13,200 --> 00:41:18,960
outcome so okay so how does the complete

00:41:16,619 --> 00:41:21,720
lastly block inside with fixture know

00:41:18,960 --> 00:41:23,670
what future outcome to return is because

00:41:21,720 --> 00:41:25,770
I've introduced the future instead of

00:41:23,670 --> 00:41:27,300
here outcome then it would be a

00:41:25,770 --> 00:41:30,330
futuristic and complete lastly would

00:41:27,300 --> 00:41:34,200
work but yeah so what basically complete

00:41:30,330 --> 00:41:37,260
lastly does is there's there's

00:41:34,200 --> 00:41:39,359
implementations of futuristic forced

00:41:37,260 --> 00:41:43,020
square brackets future of anything and

00:41:39,359 --> 00:41:47,119
for future outcome and the with cleanup

00:41:43,020 --> 00:41:50,609
method of that instance of futuristic

00:41:47,119 --> 00:41:52,619
will take the futuristic thing so let's

00:41:50,609 --> 00:41:55,890
say it's a future outcome it takes it it

00:41:52,619 --> 00:41:59,310
attaches the cleanup code which was

00:41:55,890 --> 00:42:00,869
passed lastly I I got that I don't think

00:41:59,310 --> 00:42:03,180
I'm making my question clear I'll come

00:42:00,869 --> 00:42:05,470
talk to you later okay sure you tuck me

00:42:03,180 --> 00:42:08,710
in the future

00:42:05,470 --> 00:42:14,410
all right I have a few more minutes if I

00:42:08,710 --> 00:42:16,300
was another question anybody all right I

00:42:14,410 --> 00:42:20,770
don't see any hands oh yes there's one

00:42:16,300 --> 00:42:23,320
hello how do you deal with a timeout sir

00:42:20,770 --> 00:42:26,410
oh yeah timeouts is a good that's a

00:42:23,320 --> 00:42:28,750
funny question so I thought I was done

00:42:26,410 --> 00:42:30,720
several different periods like okay we

00:42:28,750 --> 00:42:33,220
finally finished this yak shave and

00:42:30,720 --> 00:42:36,849
heiko say burger asked that question I

00:42:33,220 --> 00:42:40,240
was like oh so there wasn't one but now

00:42:36,849 --> 00:42:42,970
that's what time limited time limits

00:42:40,240 --> 00:42:45,000
does there was a way before to do it

00:42:42,970 --> 00:42:48,609
called timeouts and it's the same syntax

00:42:45,000 --> 00:42:50,980
syntax so time limits is the new one but

00:42:48,609 --> 00:42:53,170
what's different about it it was fail

00:42:50,980 --> 00:42:55,300
after and canceled after so that the

00:42:53,170 --> 00:42:57,310
methods are the same but now with time

00:42:55,300 --> 00:42:59,460
limits it depends it does something

00:42:57,310 --> 00:43:02,290
different if thats future of future or

00:42:59,460 --> 00:43:05,560
futuristic probably right it does you

00:43:02,290 --> 00:43:06,910
know if it's anything not a future it

00:43:05,560 --> 00:43:08,770
just does the old behavior which that

00:43:06,910 --> 00:43:11,080
code has to finish with in that amount

00:43:08,770 --> 00:43:13,450
of time yeah and it works on JavaScript

00:43:11,080 --> 00:43:15,250
or Java JVM but if it's a future it's

00:43:13,450 --> 00:43:17,280
it's the future has to complete in that

00:43:15,250 --> 00:43:19,930
amount of time and it returns a future

00:43:17,280 --> 00:43:22,839
but that's time limits timeouts was just

00:43:19,930 --> 00:43:24,730
the first thing yeah and then you're

00:43:22,839 --> 00:43:26,020
welcome and then time limited tests if

00:43:24,730 --> 00:43:27,670
you just want your tests to have a

00:43:26,020 --> 00:43:33,220
timeout then you mix in time limit test

00:43:27,670 --> 00:43:38,470
and it uses this fail after so anyone

00:43:33,220 --> 00:43:42,520
else okay I think I'm competing with

00:43:38,470 --> 00:43:43,839
potential beer probably so alright if

00:43:42,520 --> 00:43:45,550
there's no other questions I would like

00:43:43,839 --> 00:43:48,810
to say thank you very much for for

00:43:45,550 --> 00:43:48,810
coming and thanks for

00:43:49,420 --> 00:43:51,480

YouTube URL: https://www.youtube.com/watch?v=JRfQnXqj4YI


