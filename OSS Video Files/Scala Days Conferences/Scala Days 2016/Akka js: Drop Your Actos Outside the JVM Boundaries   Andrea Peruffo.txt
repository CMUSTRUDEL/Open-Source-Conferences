Title: Akka js: Drop Your Actos Outside the JVM Boundaries   Andrea Peruffo
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
I will present the ongoing effort to port and cross-compile (most of) Akka, one of the biggest frameworks in the Scala land, against the alternative compiler of Scala.js.
We dig into various use cases from taming UI complexity to server side concurrent code made easy on Node.Js server side and more over!
Properly handling distributed and concurrent runtimes with the very same abstraction layer will turn your world upside-down breaking the frontiers between client and server development.
Captions: 
	00:00:04,600 --> 00:00:11,680
so I think is time to start and today we

00:00:08,710 --> 00:00:15,610
talk about ACTA jes drop your act

00:00:11,680 --> 00:00:18,910
outside the jvm boundaries and yes

00:00:15,610 --> 00:00:21,789
please remember to rate this session and

00:00:18,910 --> 00:00:24,480
first of all the boring thing Who am I

00:00:21,789 --> 00:00:27,880
I'm Andrea Pirlo I'm a developer I

00:00:24,480 --> 00:00:31,150
usually write software from embedded

00:00:27,880 --> 00:00:34,240
devices to PLC's at VG's whatever

00:00:31,150 --> 00:00:36,490
cluster micro-services whatever I just

00:00:34,240 --> 00:00:39,850
like to write software and I enjoy that

00:00:36,490 --> 00:00:42,340
and right now I'm working in a unicredit

00:00:39,850 --> 00:00:44,739
research and development team UniCredit

00:00:42,340 --> 00:00:46,989
is a bank and we try to push new

00:00:44,739 --> 00:00:49,300
technologies into the legacy system of

00:00:46,989 --> 00:00:52,809
the bank to improve our system and to

00:00:49,300 --> 00:00:55,660
have better systems for tomorrow

00:00:52,809 --> 00:00:58,930
and these are my handles on github and

00:00:55,660 --> 00:01:01,059
Twitter so first of all we start to be

00:00:58,930 --> 00:01:04,510
back everybody of you know Zaka it's an

00:01:01,059 --> 00:01:07,630
actress's it enable you to use vector

00:01:04,510 --> 00:01:10,390
model within your applications and it is

00:01:07,630 --> 00:01:11,470
one of the two most popular and

00:01:10,390 --> 00:01:15,640
production-ready

00:01:11,470 --> 00:01:19,229
actor model present right now in the in

00:01:15,640 --> 00:01:22,000
the industry of computer of computer and

00:01:19,229 --> 00:01:25,240
the other one is all and obviously and

00:01:22,000 --> 00:01:28,420
it is great is a great library and I

00:01:25,240 --> 00:01:30,310
really want to use it everywhere and on

00:01:28,420 --> 00:01:35,340
the other side we have Scala gee yes

00:01:30,310 --> 00:01:39,399
that is the second compiler of Scala and

00:01:35,340 --> 00:01:42,430
is really stable and it is a great

00:01:39,399 --> 00:01:45,490
project and enabled you to write Scala

00:01:42,430 --> 00:01:48,040
code that can run and can be translated

00:01:45,490 --> 00:01:51,040
to JavaScript to run on any JavaScript

00:01:48,040 --> 00:01:54,280
virtual machine from that two parts we

00:01:51,040 --> 00:01:57,090
try we want to use a conductor model

00:01:54,280 --> 00:02:01,960
within our scholar genius applications

00:01:57,090 --> 00:02:04,630
so why why should I care this project

00:02:01,960 --> 00:02:05,200
there are many reasons first of all code

00:02:04,630 --> 00:02:07,930
reuse

00:02:05,200 --> 00:02:11,110
I wanted to reuse all my all my code

00:02:07,930 --> 00:02:15,040
wherever I were ever in my application

00:02:11,110 --> 00:02:16,450
so if I write some behaviors are usually

00:02:15,040 --> 00:02:18,910
right

00:02:16,450 --> 00:02:22,000
my application based on vector model and

00:02:18,910 --> 00:02:25,120
I want to reuse them and the libraries

00:02:22,000 --> 00:02:28,390
everywhere code portability I don't want

00:02:25,120 --> 00:02:31,770
I don't like to get stucked on the JVM

00:02:28,390 --> 00:02:35,020
for everything I'd like to to have

00:02:31,770 --> 00:02:36,940
separate vehicle machine where I can

00:02:35,020 --> 00:02:40,260
deploy my application there are many

00:02:36,940 --> 00:02:44,110
cases where a JVM is not available or

00:02:40,260 --> 00:02:46,090
and I I'd like to have an alternative

00:02:44,110 --> 00:02:48,730
I'd like to port my application to

00:02:46,090 --> 00:02:51,400
different platforms such as v8 or

00:02:48,730 --> 00:02:56,130
phantom or whatever high modularization

00:02:51,400 --> 00:03:01,540
I want to refactor my code and I want to

00:02:56,130 --> 00:03:04,030
modularize it between the barrier from

00:03:01,540 --> 00:03:08,050
front end to back and even if I describe

00:03:04,030 --> 00:03:10,510
behaviors who have actors and I want to

00:03:08,050 --> 00:03:13,570
you I'd I'd really like to use the same

00:03:10,510 --> 00:03:16,120
programming model everywhere I program

00:03:13,570 --> 00:03:19,360
if I if I use the program vector

00:03:16,120 --> 00:03:22,540
programming model I have one mindset and

00:03:19,360 --> 00:03:24,900
I write very fast and I'm a very

00:03:22,540 --> 00:03:28,810
proficient in my code in my code and I

00:03:24,900 --> 00:03:31,690
like to reuse the same model even in

00:03:28,810 --> 00:03:34,330
front end I don't want I don't like to

00:03:31,690 --> 00:03:36,760
change and I've in front-end to use a

00:03:34,330 --> 00:03:39,310
react or whatever different models of

00:03:36,760 --> 00:03:41,430
programming I just wanted to use my

00:03:39,310 --> 00:03:43,660
concept everywhere that are great and

00:03:41,430 --> 00:03:45,430
I'd like to have transparent

00:03:43,660 --> 00:03:47,920
communication between different

00:03:45,430 --> 00:03:50,650
platforms between because because

00:03:47,920 --> 00:03:53,940
serialization is still today a problem

00:03:50,650 --> 00:03:56,170
and I don't want to get stuck with it

00:03:53,940 --> 00:03:58,540
concurrency management even if the

00:03:56,170 --> 00:04:01,720
JavaScript virtual machines are a single

00:03:58,540 --> 00:04:03,970
threaded varies concurrency and right

00:04:01,720 --> 00:04:07,120
now it is managed by using callbacks

00:04:03,970 --> 00:04:11,530
that are bad you you easily go into

00:04:07,120 --> 00:04:14,110
inner deepen nest the callbacks and and

00:04:11,530 --> 00:04:18,359
you you will like to use an actor/model

00:04:14,110 --> 00:04:21,760
to really simplify your code and and

00:04:18,359 --> 00:04:24,400
shape it in a better manner and the

00:04:21,760 --> 00:04:26,129
parallel is management also in

00:04:24,400 --> 00:04:28,770
JavaScript there are

00:04:26,129 --> 00:04:33,330
new things that are coming up like such

00:04:28,770 --> 00:04:35,610
as web workers and so also parallelism

00:04:33,330 --> 00:04:37,560
through parallelism in JavaScript word

00:04:35,610 --> 00:04:40,680
is possible and tomorrow I want to take

00:04:37,560 --> 00:04:44,789
meet with with a good model such as the

00:04:40,680 --> 00:04:48,389
after one so what is my goal for this

00:04:44,789 --> 00:04:51,930
project my goal is to be lazy I don't

00:04:48,389 --> 00:04:54,870
want the previous approaches to port

00:04:51,930 --> 00:04:57,419
akka on different platforms like like

00:04:54,870 --> 00:05:01,229
akka dot net or several other attempts

00:04:57,419 --> 00:05:05,039
to port on ecology yes starts from the

00:05:01,229 --> 00:05:07,889
akka code and take it copying passed on

00:05:05,039 --> 00:05:12,240
the forever target and modify the things

00:05:07,889 --> 00:05:13,080
and and have to rebase icky rewrite the

00:05:12,240 --> 00:05:16,729
akka

00:05:13,080 --> 00:05:19,469
framework for the new target platform I

00:05:16,729 --> 00:05:23,009
don't I don't really want to do that

00:05:19,469 --> 00:05:25,919
virile guys that makes a really great

00:05:23,009 --> 00:05:29,940
work and the thanks guys for rocof it is

00:05:25,919 --> 00:05:32,490
a great library and it is maintained and

00:05:29,940 --> 00:05:35,099
there are a lot of bug fixes everywhere

00:05:32,490 --> 00:05:39,719
and improvement even in the core right

00:05:35,099 --> 00:05:42,300
now and I'd like to not overcome very

00:05:39,719 --> 00:05:45,259
work and do not have to repeat their

00:05:42,300 --> 00:05:50,340
work twice I just wanted to write a

00:05:45,259 --> 00:05:54,060
little bit of blue code a little little

00:05:50,340 --> 00:05:57,419
bit of blue code better makes the akka

00:05:54,060 --> 00:06:00,539
original sources compile and run and

00:05:57,419 --> 00:06:03,479
make them run the akka model on the

00:06:00,539 --> 00:06:06,629
JavaScript platform so I just write a

00:06:03,479 --> 00:06:13,560
thin layer of glue code and I can reuse

00:06:06,629 --> 00:06:15,990
much of the arc of that core code so the

00:06:13,560 --> 00:06:20,909
question is this is crazy does it work

00:06:15,990 --> 00:06:23,940
and the answer is yes ah I can

00:06:20,909 --> 00:06:27,000
demonstrate it right now so we start

00:06:23,940 --> 00:06:30,210
with the same as example to show you

00:06:27,000 --> 00:06:32,430
what happens we start with a pin punk

00:06:30,210 --> 00:06:35,190
that is an L word in the actor model and

00:06:32,430 --> 00:06:37,409
so this is pretty easy if you write a

00:06:35,190 --> 00:06:40,949
character application

00:06:37,409 --> 00:06:42,509
and so we spawn an actor system called

00:06:40,949 --> 00:06:47,639
beam punk with a specific configuration

00:06:42,509 --> 00:06:51,689
on on JVM and J aside and we define a

00:06:47,639 --> 00:06:54,419
method that retrieves as a probes for an

00:06:51,689 --> 00:06:58,289
actor better just matches on amateur

00:06:54,419 --> 00:07:01,050
string and when your receivers receives

00:06:58,289 --> 00:07:03,509
better that string answer to the sender

00:07:01,050 --> 00:07:07,979
as first to the sender we advance were

00:07:03,509 --> 00:07:10,259
stream and and he print the water what

00:07:07,979 --> 00:07:13,379
is what is happening on we start

00:07:10,259 --> 00:07:16,679
obviously we spawn two actors a punker

00:07:13,379 --> 00:07:19,529
that when receives being answers with a

00:07:16,679 --> 00:07:22,739
pump and a finger that well received

00:07:19,529 --> 00:07:24,629
upon grants with a pink this is pretty

00:07:22,739 --> 00:07:26,339
trivial after one second

00:07:24,629 --> 00:07:28,709
we sent to the pinger a punk message

00:07:26,339 --> 00:07:31,379
pretending to be the panga and after two

00:07:28,709 --> 00:07:35,329
seconds we just hear the actors and

00:07:31,379 --> 00:07:41,089
terminate the system so this behaves

00:07:35,329 --> 00:07:45,629
exactly like expected on the JVM side

00:07:41,089 --> 00:07:50,429
and as you can see there are ping pong

00:07:45,629 --> 00:07:53,029
going good going from the two actors but

00:07:50,429 --> 00:07:57,509
what happens is that we can compile it

00:07:53,029 --> 00:08:05,369
thanks to Scala GS and we compile it in

00:07:57,509 --> 00:08:08,909
JavaScript and okay I go we have note

00:08:05,369 --> 00:08:16,099
just to show you that but it is not not

00:08:08,909 --> 00:08:19,759
a joke and I can start node and then

00:08:16,099 --> 00:08:19,759
require modules

00:08:25,830 --> 00:08:29,840
and then we can

00:08:33,090 --> 00:08:37,560
start our application and it ranks and

00:08:35,820 --> 00:08:41,550
this is note and this is exactly the

00:08:37,560 --> 00:08:43,470
same behavior that we have on JVM and

00:08:41,550 --> 00:08:45,980
this is great we are using vector model

00:08:43,470 --> 00:08:51,210
and this is completely concurrent and

00:08:45,980 --> 00:08:53,580
this is great and so something more

00:08:51,210 --> 00:08:58,110
difficult to write now for example we

00:08:53,580 --> 00:09:00,390
are going to inherently inherently

00:08:58,110 --> 00:09:02,850
concurrent such as raft that is a

00:09:00,390 --> 00:09:04,740
consensus algorithm we just take an

00:09:02,850 --> 00:09:06,990
implementation a trivial implementation

00:09:04,740 --> 00:09:09,150
which is not food to a full-fledged but

00:09:06,990 --> 00:09:14,070
this is an algorithm and they try to

00:09:09,150 --> 00:09:18,000
elect a leader a leader over over with a

00:09:14,070 --> 00:09:24,570
consensus consensus algorithm it can run

00:09:18,000 --> 00:09:28,290
on our JVM side as you expect this is

00:09:24,570 --> 00:09:30,900
pretty unstable so it will elect

00:09:28,290 --> 00:09:33,470
different leaders from time to time I

00:09:30,900 --> 00:09:36,930
hope so

00:09:33,470 --> 00:09:40,470
and yes the leader is changed and

00:09:36,930 --> 00:09:43,170
everything is working and yes I want I'd

00:09:40,470 --> 00:09:51,840
like to run it also on the jes side i

00:09:43,170 --> 00:09:53,790
stay in must be tv's time and yes it's

00:09:51,840 --> 00:09:55,740
fast optimizing we have a javascript

00:09:53,790 --> 00:09:58,500
file that is executed and we have

00:09:55,740 --> 00:10:02,630
exactly the same behavior so what

00:09:58,500 --> 00:10:06,750
happens is that even known not trivial

00:10:02,630 --> 00:10:09,390
akka application can run even on

00:10:06,750 --> 00:10:13,920
javascript and maya greens works also

00:10:09,390 --> 00:10:19,260
there and this is great so we try to go

00:10:13,920 --> 00:10:21,090
now into a more JavaScript friendly

00:10:19,260 --> 00:10:23,610
environment with this verb browser and

00:10:21,090 --> 00:10:27,330
in the browser we have we have the Dom

00:10:23,610 --> 00:10:31,020
and with Dom if you think I've done you

00:10:27,330 --> 00:10:32,730
you know that there is a hierarchy but

00:10:31,020 --> 00:10:35,970
yes ok

00:10:32,730 --> 00:10:38,100
actors are modeled has a hierarchy so

00:10:35,970 --> 00:10:41,130
there is a similarity and the risk and

00:10:38,100 --> 00:10:45,480
Maps very well one on each other so I

00:10:41,130 --> 00:10:46,100
can map the DAV lifecycles of my actors

00:10:45,480 --> 00:10:49,459
to the right

00:10:46,100 --> 00:10:52,690
the age of no the elements so I can

00:10:49,459 --> 00:10:56,930
easily with less than 100 line of code

00:10:52,690 --> 00:10:59,660
map this two things to each other

00:10:56,930 --> 00:11:03,319
and they can write a dumb actor that do

00:10:59,660 --> 00:11:07,310
that and at this point I can spawn an

00:11:03,319 --> 00:11:10,240
actor system open my page and do the

00:11:07,310 --> 00:11:14,120
very first tutorial of JavaScript to you

00:11:10,240 --> 00:11:16,910
you can you can do a to-do list and so

00:11:14,120 --> 00:11:19,250
first of all thanks to scale attacks I

00:11:16,910 --> 00:11:23,389
can write in all of this in Scala and I

00:11:19,250 --> 00:11:26,209
have a to do element that has an input

00:11:23,389 --> 00:11:29,509
box and every time you press the button

00:11:26,209 --> 00:11:33,470
near it you just spawn another element

00:11:29,509 --> 00:11:36,470
of the to-do list and we to do with the

00:11:33,470 --> 00:11:38,709
to do element is done with is obviously

00:11:36,470 --> 00:11:44,170
an element that takes a string and

00:11:38,709 --> 00:11:55,130
display it and this is what happens and

00:11:44,170 --> 00:11:57,709
I can say arrange whatever I just

00:11:55,130 --> 00:12:02,120
spawning actors and the you notice that

00:11:57,709 --> 00:12:05,329
there is a button remove and how does it

00:12:02,120 --> 00:12:07,880
works it is pretty easy because I will

00:12:05,329 --> 00:12:11,870
remove just send a poison pill to

00:12:07,880 --> 00:12:13,819
himself so just killing the actor I can

00:12:11,870 --> 00:12:17,540
remove my elements and everybody and

00:12:13,819 --> 00:12:20,149
every finger remain within a context

00:12:17,540 --> 00:12:25,550
with the actor model and play very well

00:12:20,149 --> 00:12:28,069
with it so let's go for an example a

00:12:25,550 --> 00:12:28,819
little bit more complicated now we go

00:12:28,069 --> 00:12:31,279
for a chat

00:12:28,819 --> 00:12:34,880
the second example in JavaScript but you

00:12:31,279 --> 00:12:38,899
can try so we define from first of all

00:12:34,880 --> 00:12:42,110
the front end of our application and our

00:12:38,899 --> 00:12:46,009
application with a chat UI and our

00:12:42,110 --> 00:12:46,639
strategy I will be pretty similar to the

00:12:46,009 --> 00:12:51,290
to-do list

00:12:46,639 --> 00:12:56,170
and want to add today to our interface a

00:12:51,290 --> 00:12:59,779
new chat box every every time we rewrite

00:12:56,170 --> 00:13:03,529
when we click a button just the next

00:12:59,779 --> 00:13:09,259
an input an input element that where we

00:13:03,529 --> 00:13:11,509
can write a URL first thing that the

00:13:09,259 --> 00:13:16,430
chat box will do is open a new web

00:13:11,509 --> 00:13:21,259
socket to that URL and after that we

00:13:16,430 --> 00:13:25,160
bite the action of the callbacks on all

00:13:21,259 --> 00:13:29,110
of our message to action to send to

00:13:25,160 --> 00:13:32,930
himself to myself a new message and

00:13:29,110 --> 00:13:35,870
after that we have just a single simple

00:13:32,930 --> 00:13:39,139
template that has a message box where we

00:13:35,870 --> 00:13:42,439
can put new messages inside and just

00:13:39,139 --> 00:13:48,769
send them over the WebSocket and we have

00:13:42,439 --> 00:13:51,500
the list of the last four last strings

00:13:48,769 --> 00:13:53,899
that are sent over the WebSocket and

00:13:51,500 --> 00:13:57,560
when we receive a message we just update

00:13:53,899 --> 00:14:00,829
our template to have renewed the new

00:13:57,560 --> 00:14:04,370
text and we take just the right five so

00:14:00,829 --> 00:14:08,809
we have this and yes we can add a new

00:14:04,370 --> 00:14:12,529
server WebSocket but what happened in

00:14:08,809 --> 00:14:15,110
the back end and the back end we can we

00:14:12,529 --> 00:14:19,699
can we can we can we can easily write

00:14:15,110 --> 00:14:23,149
some really trivial code to manage the

00:14:19,699 --> 00:14:26,269
WebSocket connections and that will

00:14:23,149 --> 00:14:28,370
manage all the clients and we have just

00:14:26,269 --> 00:14:31,370
three messages at client remove client

00:14:28,370 --> 00:14:33,589
and message obviously we spawn a system

00:14:31,370 --> 00:14:36,290
and we spawn in one single actor that

00:14:33,589 --> 00:14:38,660
will care about all the connection over

00:14:36,290 --> 00:14:42,879
WebSockets this is just an example

00:14:38,660 --> 00:14:47,269
obviously and the behavior of this of

00:14:42,879 --> 00:14:52,189
this manager will be just to keep track

00:14:47,269 --> 00:14:54,829
of his clients of a lifecycle of this

00:14:52,189 --> 00:14:58,399
client and when he received a message he

00:14:54,829 --> 00:15:02,600
just broadcast to all the clients at the

00:14:58,399 --> 00:15:04,459
moment attached that message on this

00:15:02,600 --> 00:15:07,839
short code that is the business logic

00:15:04,459 --> 00:15:11,220
that can be communicated how you like

00:15:07,839 --> 00:15:14,910
you can write a JVM implement a

00:15:11,220 --> 00:15:20,009
for example so in this case we write not

00:15:14,910 --> 00:15:21,930
HTTP implementation we just reuse the

00:15:20,009 --> 00:15:29,699
system that we created in the shared

00:15:21,930 --> 00:15:33,449
code and we just bind the root path that

00:15:29,699 --> 00:15:36,629
we expose we were with our webserver to

00:15:33,449 --> 00:15:39,629
an end of WebSocket that is a flow from

00:15:36,629 --> 00:15:44,550
sink to source and our sink answers are

00:15:39,629 --> 00:15:49,230
already actors and simply when we

00:15:44,550 --> 00:15:53,730
receive a message from the WebSocket we

00:15:49,230 --> 00:15:58,709
just send it to the manager we seen

00:15:53,730 --> 00:16:02,279
before and on the other side where we

00:15:58,709 --> 00:16:05,459
produce messages every time when when

00:16:02,279 --> 00:16:08,430
the connection is is up this actor

00:16:05,459 --> 00:16:12,060
respond so we bind the life cycle of

00:16:08,430 --> 00:16:15,180
this actor to the registration to the

00:16:12,060 --> 00:16:17,730
manager and every time we receive a chat

00:16:15,180 --> 00:16:22,139
message message object we just the pub

00:16:17,730 --> 00:16:25,019
we just produce it on the on our on our

00:16:22,139 --> 00:16:30,420
web socket and so what happens is that

00:16:25,019 --> 00:16:37,439
it runs on 9001 and we can start testing

00:16:30,420 --> 00:16:46,439
it we open a couple of application a

00:16:37,439 --> 00:16:50,339
couple of connection and we can say yes

00:16:46,439 --> 00:16:52,470
this works and yes obviously you can

00:16:50,339 --> 00:16:58,410
have any as many connections as you like

00:16:52,470 --> 00:17:02,160
and this is done by a cage ttp ok this

00:16:58,410 --> 00:17:07,140
is great but normal but what we can do

00:17:02,160 --> 00:17:09,870
more we know that servers are done even

00:17:07,140 --> 00:17:13,620
on node so we can have an implementation

00:17:09,870 --> 00:17:17,069
of our server-side application that runs

00:17:13,620 --> 00:17:20,309
on node using using the modules of HTTP

00:17:17,069 --> 00:17:23,350
and the WebSocket that are available on

00:17:20,309 --> 00:17:27,760
node and so we create the server

00:17:23,350 --> 00:17:30,520
as we did before we bind the requests to

00:17:27,760 --> 00:17:33,940
the spawn of a new actors every time

00:17:30,520 --> 00:17:36,309
with a connection and as soon as the the

00:17:33,940 --> 00:17:39,610
connection endler WebSocket handler

00:17:36,309 --> 00:17:42,220
starts it binds that the code back to

00:17:39,610 --> 00:17:46,210
the direction of sending messages to

00:17:42,220 --> 00:17:47,799
insert to somewhere and in this case we

00:17:46,210 --> 00:17:50,799
bind the direction of receiving a

00:17:47,799 --> 00:17:54,580
message to send to the manager and we

00:17:50,799 --> 00:17:57,159
bind the clothes to self poison peel

00:17:54,580 --> 00:17:59,020
that we to kill himself and then we add

00:17:57,159 --> 00:18:01,600
the client and remove the client on

00:17:59,020 --> 00:18:04,299
first attempt post-op and win when we

00:18:01,600 --> 00:18:07,659
receive a message from the manager we

00:18:04,299 --> 00:18:17,409
send it over the WebSocket and this is

00:18:07,659 --> 00:18:20,679
on 9002 and we can reuse our before

00:18:17,409 --> 00:18:26,520
created interface and yes this is not

00:18:20,679 --> 00:18:26,520
Jes and this is isomorphic Scala yeah

00:18:30,809 --> 00:18:38,710
yes but next step next step will be to

00:18:35,520 --> 00:18:40,600
leave out the server I don't want to

00:18:38,710 --> 00:18:43,059
have a server way I should have a server

00:18:40,600 --> 00:18:45,669
there are new exciting technologies that

00:18:43,059 --> 00:18:50,470
help us make point-to-point connection

00:18:45,669 --> 00:18:54,490
such as WebRTC and right now I will use

00:18:50,470 --> 00:18:57,250
it within this interface these three

00:18:54,490 --> 00:18:59,620
boxes you can you can see our three

00:18:57,250 --> 00:19:03,039
different iframes so basically three

00:18:59,620 --> 00:19:06,220
different browsers that can that can run

00:19:03,039 --> 00:19:08,650
in parallel and this is a key exchange

00:19:06,220 --> 00:19:11,830
that is just a technical detail for

00:19:08,650 --> 00:19:15,070
having a connection over the WebSocket

00:19:11,830 --> 00:19:19,120
and the vacuum connection is totally

00:19:15,070 --> 00:19:23,650
peer-to-peer and so this this very page

00:19:19,120 --> 00:19:28,270
is now connected with the B page and so

00:19:23,650 --> 00:19:32,429
we can add even receive one at this

00:19:28,270 --> 00:19:32,429
point C is still alone

00:19:34,350 --> 00:19:37,350
okay

00:19:47,110 --> 00:19:54,880
okay at this point we have a connection

00:19:50,289 --> 00:19:57,760
from from A to B and from A to C and

00:19:54,880 --> 00:20:01,059
this is a little tree that we created

00:19:57,760 --> 00:20:03,340
and every message is just sent from a

00:20:01,059 --> 00:20:06,519
one end point to the other without

00:20:03,340 --> 00:20:10,179
passing through a server so we are

00:20:06,519 --> 00:20:12,370
completely serverless and obviously we

00:20:10,179 --> 00:20:16,330
have a data channel between a and B and

00:20:12,370 --> 00:20:23,830
we can we can we can chat with b and b

00:20:16,330 --> 00:20:28,210
can answer to a and implementing a

00:20:23,830 --> 00:20:31,659
trivial routing protocol from C to B you

00:20:28,210 --> 00:20:38,039
can you can also communicate through the

00:20:31,659 --> 00:20:38,039
word tree so you can chat from C to B

00:20:39,179 --> 00:20:48,370
yeah and also from from B to C going

00:20:45,029 --> 00:20:52,809
making the message go through a and back

00:20:48,370 --> 00:20:54,610
down to the other node yes and this is

00:20:52,809 --> 00:20:57,909
completely serverless and this is a chat

00:20:54,610 --> 00:21:01,360
so the limits are really higher now and

00:20:57,909 --> 00:21:06,100
we have a lot of new things that we can

00:21:01,360 --> 00:21:13,779
do with this rising technologies even in

00:21:06,100 --> 00:21:16,600
the JavaScript world so given that which

00:21:13,779 --> 00:21:19,899
are the challenges that we faced during

00:21:16,600 --> 00:21:23,080
this process and the challenges are

00:21:19,899 --> 00:21:25,960
related to the fact that basically akka

00:21:23,080 --> 00:21:29,130
is written on the JVM runs on the JVM

00:21:25,960 --> 00:21:33,639
and they are related to the JVM

00:21:29,130 --> 00:21:36,460
injecting real challenges of better or

00:21:33,639 --> 00:21:38,740
related to the JVM but that are the

00:21:36,460 --> 00:21:42,279
compatibility with Java standard library

00:21:38,740 --> 00:21:45,090
first of all the reflection that is used

00:21:42,279 --> 00:21:48,669
all around into the article code

00:21:45,090 --> 00:21:52,240
serialization as a self and the typesafe

00:21:48,669 --> 00:21:55,600
config these are just for among the

00:21:52,240 --> 00:21:58,389
others but we can see them one by one

00:21:55,600 --> 00:21:59,860
and Java standard for example Java

00:21:58,389 --> 00:22:02,580
standard Lib

00:21:59,860 --> 00:22:06,510
we face them and the Java standard lib

00:22:02,580 --> 00:22:10,860
looks like this is a screenshot of

00:22:06,510 --> 00:22:14,500
github page of Scala genius Java util

00:22:10,860 --> 00:22:18,809
compatibility package at version zero

00:22:14,500 --> 00:22:23,530
six two when we start with project and

00:22:18,809 --> 00:22:26,650
this is how it looks like now you can

00:22:23,530 --> 00:22:30,549
see the difference this is pretty

00:22:26,650 --> 00:22:32,679
exciting it is not all of all of us but

00:22:30,549 --> 00:22:36,549
also this colleges team work hard on

00:22:32,679 --> 00:22:39,760
this and right now in zero 6 10 we have

00:22:36,549 --> 00:22:42,280
much larger compatibility with Java util

00:22:39,760 --> 00:22:44,860
collection and with Java standard

00:22:42,280 --> 00:22:46,990
library which is the that is developed

00:22:44,860 --> 00:22:49,950
by us and the Nicolas to key for j-unit

00:22:46,990 --> 00:22:53,460
and other things but right now we have a

00:22:49,950 --> 00:22:58,360
larger compatibility so instead of

00:22:53,460 --> 00:23:02,530
tweaking akka we a large the environment

00:22:58,360 --> 00:23:06,100
and we work on things that enable akka

00:23:02,530 --> 00:23:10,200
to be ported to Scala G yes so second

00:23:06,100 --> 00:23:14,440
point will be about field used within

00:23:10,200 --> 00:23:16,870
actors so if you read Scala code you can

00:23:14,440 --> 00:23:18,880
say things like like this but are nice

00:23:16,870 --> 00:23:20,919
you have a trait with this actor and

00:23:18,880 --> 00:23:24,850
that has an implicit valve that is

00:23:20,919 --> 00:23:28,059
context and is an actor context but in a

00:23:24,850 --> 00:23:31,770
few lines you can say you can see set

00:23:28,059 --> 00:23:36,460
actor fields what does this mean

00:23:31,770 --> 00:23:40,179
reflect look up and set fin can you do

00:23:36,460 --> 00:23:42,130
you know what this can do you can

00:23:40,179 --> 00:23:44,830
imagine on context

00:23:42,130 --> 00:23:47,559
yeah they are using reflection all

00:23:44,830 --> 00:23:50,490
around and they are modifying under

00:23:47,559 --> 00:23:53,830
beneath your values that are pretty

00:23:50,490 --> 00:23:57,220
immutable as long as you know this is

00:23:53,830 --> 00:24:00,070
for having a clean API so you can import

00:23:57,220 --> 00:24:03,220
context if it is a while you cannot

00:24:00,070 --> 00:24:06,700
import that in API in in your code but

00:24:03,220 --> 00:24:09,700
this is bad to be ported on the scanner

00:24:06,700 --> 00:24:10,750
on on the JavaScript side because we

00:24:09,700 --> 00:24:16,990
don't have

00:24:10,750 --> 00:24:19,990
less stable 0.2 to change variables

00:24:16,990 --> 00:24:23,410
between because we don't know the naming

00:24:19,990 --> 00:24:26,980
that is produced by the compiler so what

00:24:23,410 --> 00:24:29,790
happens is that we patch after the

00:24:26,980 --> 00:24:32,890
compilation of our code so we basically

00:24:29,790 --> 00:24:35,920
you have to know that Scala G yes ships

00:24:32,890 --> 00:24:39,880
is is a library with an intermediate

00:24:35,920 --> 00:24:42,250
representation and we touch that after

00:24:39,880 --> 00:24:44,110
the computation so we write another

00:24:42,250 --> 00:24:47,680
piece of code that looks like the

00:24:44,110 --> 00:24:50,620
previous one we produce the compiled

00:24:47,680 --> 00:24:54,870
version and we patch with the new

00:24:50,620 --> 00:24:59,200
compiled version where they produce it

00:24:54,870 --> 00:25:03,160
the ER produced by our library and

00:24:59,200 --> 00:25:05,590
that's that at run times works as expect

00:25:03,160 --> 00:25:09,490
in a way and we can emulate reflection

00:25:05,590 --> 00:25:13,140
at run time with structural types there

00:25:09,490 --> 00:25:17,350
are other problems with runtime that are

00:25:13,140 --> 00:25:20,040
but they are fixable with some

00:25:17,350 --> 00:25:23,740
annotations that are already available

00:25:20,040 --> 00:25:28,870
within within astrology yes better verge

00:25:23,740 --> 00:25:31,660
is export and this are a notation that

00:25:28,870 --> 00:25:34,870
has to be added to the source code and

00:25:31,660 --> 00:25:38,250
we don't have emitted to do that so we

00:25:34,870 --> 00:25:41,170
write a compiler plug-in that add the

00:25:38,250 --> 00:25:44,350
annotations to the to via code at

00:25:41,170 --> 00:25:47,640
compile time to be safe and to be sure

00:25:44,350 --> 00:25:51,760
that we are added at the right points

00:25:47,640 --> 00:25:56,610
semantically and not using simple string

00:25:51,760 --> 00:26:00,820
interpolation on places like this so

00:25:56,610 --> 00:26:03,490
what next serialization here we have a

00:26:00,820 --> 00:26:08,710
big problem and we are we are working on

00:26:03,490 --> 00:26:11,410
it and yes this is not still working we

00:26:08,710 --> 00:26:14,470
are working on scallop evening we start

00:26:11,410 --> 00:26:18,550
with very polar and now we are we we

00:26:14,470 --> 00:26:22,270
hope to have it ported down on this

00:26:18,550 --> 00:26:25,260
colleges side soon and to

00:26:22,270 --> 00:26:28,150
we can continue working on it and

00:26:25,260 --> 00:26:30,880
typesafe config typesafe config is a

00:26:28,150 --> 00:26:35,170
great library for having configurations

00:26:30,880 --> 00:26:39,070
and it is used all around in a lot of in

00:26:35,170 --> 00:26:43,420
a lot of scar aplicar application of

00:26:39,070 --> 00:26:47,830
course and what happens is that it is

00:26:43,420 --> 00:26:51,250
entirely written in Java well once more

00:26:47,830 --> 00:26:55,600
and so it is not portable to Scala yes

00:26:51,250 --> 00:26:59,200
so I asked to a colleague of mine Devaki

00:26:55,600 --> 00:27:01,929
to write a parser for a cone and writes

00:26:59,200 --> 00:27:02,410
it it is not complete but it parses

00:27:01,929 --> 00:27:06,660
maths

00:27:02,410 --> 00:27:12,250
all the akka config configurations and

00:27:06,660 --> 00:27:15,880
the good news the good news is that we

00:27:12,250 --> 00:27:18,870
can use it to have real interoperability

00:27:15,880 --> 00:27:24,820
with for configuration between

00:27:18,870 --> 00:27:28,900
JavaScript code and JVM code so we can

00:27:24,820 --> 00:27:32,920
see some line of code statistics that we

00:27:28,900 --> 00:27:36,670
have in our code base and in a kadai s

00:27:32,920 --> 00:27:40,390
we have a total of about twenty thousand

00:27:36,670 --> 00:27:46,120
of line of code that runs in the code

00:27:40,390 --> 00:27:50,860
library and of them seventy thousand are

00:27:46,120 --> 00:27:54,550
just shared with the akka master today

00:27:50,860 --> 00:27:57,220
and what happens is that we add vodka as

00:27:54,550 --> 00:28:00,640
a good sub module and we just seem link

00:27:57,220 --> 00:28:03,490
the files that we wanted to reuse in in

00:28:00,640 --> 00:28:08,590
Akagi yes and so we have just three

00:28:03,490 --> 00:28:13,120
thousand line of code that make the glue

00:28:08,590 --> 00:28:16,660
code to mix back run on the Java in the

00:28:13,120 --> 00:28:19,150
JavaScript virtual machines and this is

00:28:16,660 --> 00:28:25,840
great because a really high percentage

00:28:19,150 --> 00:28:28,480
and what are our plans for the future so

00:28:25,840 --> 00:28:30,910
first of all increase by shared code in

00:28:28,480 --> 00:28:36,130
that 3000 line of code we still have

00:28:30,910 --> 00:28:38,920
some files that differ just for one key

00:28:36,130 --> 00:28:43,720
the private public private or protected

00:28:38,920 --> 00:28:47,800
or and we have we can do much better

00:28:43,720 --> 00:28:51,940
right now we want proper testing we

00:28:47,800 --> 00:28:55,090
start to port to port a test kit and to

00:28:51,940 --> 00:28:57,430
make it run even in the JavaScript

00:28:55,090 --> 00:29:02,110
environment on that side we have a big

00:28:57,430 --> 00:29:05,200
problem with the weight function that we

00:29:02,110 --> 00:29:08,320
have in a scale of course and that it's

00:29:05,200 --> 00:29:10,210
a bit harder to be reproduced in the

00:29:08,320 --> 00:29:12,430
JavaScript environment because of

00:29:10,210 --> 00:29:14,890
deadlocks and because we have obviously

00:29:12,430 --> 00:29:18,970
just one thread there but we are working

00:29:14,890 --> 00:29:20,740
on it and we have some solution we have

00:29:18,970 --> 00:29:24,670
a solution that is pretty much working

00:29:20,740 --> 00:29:26,920
right now and so we can go on to try to

00:29:24,670 --> 00:29:30,820
pour too much of the test of the test of

00:29:26,920 --> 00:29:32,740
vodka into a kadai yes - we want a

00:29:30,820 --> 00:29:35,290
portable serialization of course we

00:29:32,740 --> 00:29:37,630
really need that because we want to port

00:29:35,290 --> 00:29:40,630
at a remote I can remote with big Aquila

00:29:37,630 --> 00:29:42,700
feature for Akagi yes you can imagine

00:29:40,630 --> 00:29:44,980
you can you can write Scala code that

00:29:42,700 --> 00:29:47,140
that can communicate transparently

00:29:44,980 --> 00:29:49,740
between the browser to the server

00:29:47,140 --> 00:29:55,210
without having to care about

00:29:49,740 --> 00:29:58,320
serialization finally in 2017 maybe we

00:29:55,210 --> 00:30:01,660
can do that and that will be great and

00:29:58,320 --> 00:30:04,420
another good feature selling feature

00:30:01,660 --> 00:30:06,880
that we can we can have is the

00:30:04,420 --> 00:30:11,440
JavaScript Interop area interoperability

00:30:06,880 --> 00:30:13,740
if we write a proper interface for a DSL

00:30:11,440 --> 00:30:17,490
that is usable from the JavaScript world

00:30:13,740 --> 00:30:22,060
also JavaScript work and benefits from

00:30:17,490 --> 00:30:25,480
the akka library because right now there

00:30:22,060 --> 00:30:28,870
are no this kind of frameworks available

00:30:25,480 --> 00:30:31,530
in the JavaScript land and something

00:30:28,870 --> 00:30:34,270
like akka could benefit also website and

00:30:31,530 --> 00:30:38,860
yes at some point I have to think also

00:30:34,270 --> 00:30:43,570
at performance is bad we haven't done it

00:30:38,860 --> 00:30:46,470
yet and yes doing that move this process

00:30:43,570 --> 00:30:48,450
have everybody when probably when

00:30:46,470 --> 00:30:53,130
your programming you use methodologies

00:30:48,450 --> 00:30:56,640
such as cram agile and whatever and for

00:30:53,130 --> 00:31:00,570
this project we use Bo P that is

00:30:56,640 --> 00:31:02,580
bothering oriented program because

00:31:00,570 --> 00:31:05,669
basically we bother

00:31:02,580 --> 00:31:07,890
Sebastiaan Darin Force College a yes to

00:31:05,669 --> 00:31:11,010
have our pro request we bother vaca team

00:31:07,890 --> 00:31:14,340
to have our poor request to make a

00:31:11,010 --> 00:31:17,669
compatible and very and very answer as

00:31:14,340 --> 00:31:19,530
and they are getting them and I bother

00:31:17,669 --> 00:31:23,309
my colleague to write the parser for

00:31:19,530 --> 00:31:26,039
cone I've over my the interval DeLuca

00:31:23,309 --> 00:31:29,280
starts with that project to go on and

00:31:26,039 --> 00:31:31,919
write desk it and so a lot of people get

00:31:29,280 --> 00:31:34,169
bothered into his project for many

00:31:31,919 --> 00:31:37,320
reasons and thanks to anybody is

00:31:34,169 --> 00:31:40,460
involved in any side of this thing

00:31:37,320 --> 00:31:40,460
because this is great

00:31:44,550 --> 00:31:53,380
yes I think this is all and just today

00:31:49,360 --> 00:31:56,860
we publish we publish to mavin the first

00:31:53,380 --> 00:32:00,010
version of haka Jes and I have to change

00:31:56,860 --> 00:32:02,920
some references all around but it will

00:32:00,010 --> 00:32:05,350
be available soon and you can test you

00:32:02,920 --> 00:32:11,160
can compile you can run it on on your

00:32:05,350 --> 00:32:11,160
own and it will work and thank you guys

00:32:17,489 --> 00:32:22,229
so I think we have time for questions

00:32:28,700 --> 00:32:36,040
Oh

00:32:30,490 --> 00:32:39,880
dress that or so did you try to do that

00:32:36,040 --> 00:32:41,470
thing also with the FSM actors so did

00:32:39,880 --> 00:32:43,929
you try the finish 10 machine actors

00:32:41,470 --> 00:32:47,920
also on the app ideas or it's just with

00:32:43,929 --> 00:32:49,450
the normal become actors is just the

00:32:47,920 --> 00:32:52,980
normal become actors

00:32:49,450 --> 00:32:57,070
so you didn't try with the FSM you know

00:32:52,980 --> 00:33:00,960
yes right now with the compiled even on

00:32:57,070 --> 00:33:04,270
occasion yes and I haven't tested

00:33:00,960 --> 00:33:06,820
because I don't use it much but yes it

00:33:04,270 --> 00:33:09,760
will work because it complies and is

00:33:06,820 --> 00:33:13,390
just a DSL on these concepts so it will

00:33:09,760 --> 00:33:16,450
work for sure hi hi I have a question

00:33:13,390 --> 00:33:18,070
about remoting so right now what I saw

00:33:16,450 --> 00:33:20,100
in the examples well I'm not sure maybe

00:33:18,070 --> 00:33:21,360
I missed something but you need to have

00:33:20,100 --> 00:33:25,780
either

00:33:21,360 --> 00:33:28,210
acha acha HTTP service which will catch

00:33:25,780 --> 00:33:29,920
the HTTP message and it will translate

00:33:28,210 --> 00:33:33,309
it into a chrome message and send to

00:33:29,920 --> 00:33:35,290
some actor right and do you have any

00:33:33,309 --> 00:33:37,929
plans to actually make it part of the

00:33:35,290 --> 00:33:41,170
actress system like like with aquas real

00:33:37,929 --> 00:33:43,840
actor remoting that you don't need to do

00:33:41,170 --> 00:33:45,670
any HTTP server interactions you

00:33:43,840 --> 00:33:48,010
basically it's a responsibility of the

00:33:45,670 --> 00:33:51,429
actress system to catch this message and

00:33:48,010 --> 00:33:54,790
delegate it to the special actor sure I

00:33:51,429 --> 00:33:56,559
mentioned about a career mode without a

00:33:54,790 --> 00:33:58,870
remote oh you can talk between actor

00:33:56,559 --> 00:34:01,330
system that are on different platforms

00:33:58,870 --> 00:34:04,030
or over the network and with this

00:34:01,330 --> 00:34:07,570
technology having a pluggable transport

00:34:04,030 --> 00:34:10,840
in that you can talk not only over UDP

00:34:07,570 --> 00:34:13,119
like you do like you do today or with

00:34:10,840 --> 00:34:17,260
Iran with the new version but you will

00:34:13,119 --> 00:34:19,919
talk also over WebSockets and if you

00:34:17,260 --> 00:34:22,810
have a pluggable transport and is a

00:34:19,919 --> 00:34:25,470
compatible serialization between the two

00:34:22,810 --> 00:34:27,159
platforms you have a transparent

00:34:25,470 --> 00:34:30,970
intercommunication between different

00:34:27,159 --> 00:34:32,950
platforms from Java to JavaScript and

00:34:30,970 --> 00:34:37,169
you do not need any more

00:34:32,950 --> 00:34:39,520
HTTP if you don't really want to use it

00:34:37,169 --> 00:34:40,960
another question how many people at

00:34:39,520 --> 00:34:42,639
unicredit are currently

00:34:40,960 --> 00:34:45,849
working in this framework how many

00:34:42,639 --> 00:34:52,179
people outside of UniCredit yes

00:34:45,849 --> 00:34:54,909
basically this is me and sometimes

00:34:52,179 --> 00:34:57,730
Savile's but no there are few people

00:34:54,909 --> 00:35:00,910
right now and we have few time to work

00:34:57,730 --> 00:35:02,290
on it and to be honest and so help is

00:35:00,910 --> 00:35:05,140
really appreciated

00:35:02,290 --> 00:35:09,070
we have opened also visit our channel so

00:35:05,140 --> 00:35:14,250
please come in and help us ok great

00:35:09,070 --> 00:35:16,720
thank you thank you I have question here

00:35:14,250 --> 00:35:20,650
other side

00:35:16,720 --> 00:35:24,970
any plans for multi-threading using

00:35:20,650 --> 00:35:28,920
something like web workers the fact

00:35:24,970 --> 00:35:33,190
about the web workers is that they are

00:35:28,920 --> 00:35:36,540
more close to separate JavaScript

00:35:33,190 --> 00:35:40,060
machines virtual machines than

00:35:36,540 --> 00:35:43,839
multi-threading so basically what we

00:35:40,060 --> 00:35:46,599
need really also for web workers is a

00:35:43,839 --> 00:35:48,580
career mode to add transparent

00:35:46,599 --> 00:35:51,630
communication between different systems

00:35:48,580 --> 00:35:56,550
because with web workers everything will

00:35:51,630 --> 00:35:59,380
looks like being on two separate

00:35:56,550 --> 00:36:01,810
JavaScript virtual machines so as soon

00:35:59,380 --> 00:36:04,630
as we have I can remote everything will

00:36:01,810 --> 00:36:06,940
go transparently also with web workers

00:36:04,630 --> 00:36:11,680
and the to manage paralyzed moments

00:36:06,940 --> 00:36:13,390
thank you you mentioned for the remote

00:36:11,680 --> 00:36:15,130
thing that you were looking into scholar

00:36:13,390 --> 00:36:16,810
pickling I was wondering why I wouldn't

00:36:15,130 --> 00:36:18,400
look at protobuf first since I believe

00:36:16,810 --> 00:36:21,040
that's what occurred remoting uses

00:36:18,400 --> 00:36:24,339
internally as a smaller format for the

00:36:21,040 --> 00:36:28,810
system messages versus area Jason right

00:36:24,339 --> 00:36:33,010
now innaka rely on a lot on reflection

00:36:28,810 --> 00:36:35,589
and we cannot really reuse it so and on

00:36:33,010 --> 00:36:38,109
Java on the JVM of course you have

00:36:35,589 --> 00:36:39,760
reflection available everywhere and the

00:36:38,109 --> 00:36:43,510
serialization is not a problem because

00:36:39,760 --> 00:36:46,660
Java itself as a strong civilization as

00:36:43,510 --> 00:36:50,260
a strong serialization inside that works

00:36:46,660 --> 00:36:52,569
really well everywhere and so we have to

00:36:50,260 --> 00:36:57,339
find an alternative to that

00:36:52,569 --> 00:36:59,229
for having different platforms the

00:36:57,339 --> 00:37:00,669
civilization's is used for custom

00:36:59,229 --> 00:37:02,640
messages that's true that's where javis

00:37:00,669 --> 00:37:05,259
relation is used but the the internal

00:37:02,640 --> 00:37:07,089
messages to make up a distributed actor

00:37:05,259 --> 00:37:09,369
system are using protobuf like google

00:37:07,089 --> 00:37:11,559
protobuf definitions for for their stuff

00:37:09,369 --> 00:37:13,419
so something since that probably there's

00:37:11,559 --> 00:37:16,119
some JavaScript library around that can

00:37:13,419 --> 00:37:18,039
do that it might make sense to to take

00:37:16,119 --> 00:37:21,029
that at first to create a distributed

00:37:18,039 --> 00:37:21,029
actor system to the web browser

00:37:21,839 --> 00:37:28,390
once again please think I don't get

00:37:24,849 --> 00:37:31,919
share so using Google protobuf as the

00:37:28,390 --> 00:37:36,089
serialization format instead of chasing

00:37:31,919 --> 00:37:39,369
yes with actually what we are trying to

00:37:36,089 --> 00:37:42,579
do it whether is to have a serialization

00:37:39,369 --> 00:37:46,539
with innovative it is based on macros

00:37:42,579 --> 00:37:50,109
I've made that compile time and protobuf

00:37:46,539 --> 00:37:55,599
generates interfaces and probably yes in

00:37:50,109 --> 00:37:58,799
some way can can be integrated even in a

00:37:55,599 --> 00:38:01,749
kadai yes but I haven't really taken and

00:37:58,799 --> 00:38:04,539
it's because probably you need to

00:38:01,749 --> 00:38:09,939
integrate another compiler if it is the

00:38:04,539 --> 00:38:12,489
protesta compiler and then I haven't

00:38:09,939 --> 00:38:15,279
figured out how to manage that right now

00:38:12,489 --> 00:38:17,339
but I haven't tried so thank you thank

00:38:15,279 --> 00:38:17,339
you

00:38:21,190 --> 00:38:28,470
okay if you okay thank you very much and

00:38:25,839 --> 00:38:28,470

YouTube URL: https://www.youtube.com/watch?v=OCbuOc1GRP8


