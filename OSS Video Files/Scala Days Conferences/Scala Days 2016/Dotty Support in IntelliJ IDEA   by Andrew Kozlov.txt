Title: Dotty Support in IntelliJ IDEA   by Andrew Kozlov
Publication date: 2017-01-19
Playlist: Scala Days 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
The purpose of this talk is to introduce one to differences between Scala and Dotty, as well as to support for Dotty in Scala plugin for IntelliJ IDEA. First of all we will look at the differences between the type systems. Besides that one will learn which aspects of language support in IntelliJ IDEA have already been implemented or will be implemented in the near future. Among other things the talk will cover the build process of the project, the incremental compilation.
Captions: 
	00:00:06,580 --> 00:00:12,170
my name is andrey kozlov and i'm injured

00:00:10,269 --> 00:00:14,780
brain simply and I'm

00:00:12,170 --> 00:00:17,690
working on to support for intelligence

00:00:14,780 --> 00:00:20,689
carla thank you for joining us and also

00:00:17,690 --> 00:00:23,029
i'd like to thank skala days committee

00:00:20,689 --> 00:00:25,869
for giving me an opportunity to give a

00:00:23,029 --> 00:00:32,020
talk two days such a big honor for me to

00:00:25,869 --> 00:00:36,920
be to dance this stage so first of all

00:00:32,020 --> 00:00:42,230
remember to vote it's very important for

00:00:36,920 --> 00:00:44,360
us to have some feedback so let's get it

00:00:42,230 --> 00:00:47,540
started here is some basic information

00:00:44,360 --> 00:00:51,440
about me my name is Anne repeal of as i

00:00:47,540 --> 00:00:53,960
mentioned i'm an ab source x developer

00:00:51,440 --> 00:00:58,190
injured brain so if you don't know what

00:00:53,960 --> 00:01:02,780
up source is it's a code review to that

00:00:58,190 --> 00:01:05,030
was released about a year ago so but

00:01:02,780 --> 00:01:10,190
then I found enough with Scala and so

00:01:05,030 --> 00:01:14,780
here I am and my email and my twitter

00:01:10,190 --> 00:01:17,689
handle let's get started with a little

00:01:14,780 --> 00:01:20,899
warmup so I've got some questions for

00:01:17,689 --> 00:01:28,539
you first of all who uses intelligence

00:01:20,899 --> 00:01:33,799
and every day I de o gave good Clips

00:01:28,539 --> 00:01:39,890
anybody yeah ok veeam or emacs oh yeah

00:01:33,799 --> 00:01:42,950
yeah so well who has any experience with

00:01:39,890 --> 00:01:48,380
dodgy i'm very curious hello world is

00:01:42,950 --> 00:01:50,299
included something like that who ok have

00:01:48,380 --> 00:01:57,319
you used IntelliJ for dirty when you

00:01:50,299 --> 00:01:59,630
tried it ok yeah that's good and the

00:01:57,319 --> 00:02:02,390
point of my today talk is that we'd like

00:01:59,630 --> 00:02:04,069
to give they would like to make an

00:02:02,390 --> 00:02:07,479
official announcement that we are going

00:02:04,069 --> 00:02:12,200
to give da ta full support in IntelliJ

00:02:07,479 --> 00:02:16,370
the decision was made shortly after then

00:02:12,200 --> 00:02:20,510
use that Dottie compiler bootstraps on

00:02:16,370 --> 00:02:25,489
october 23rd so and the announcement

00:02:20,510 --> 00:02:28,730
contains a list of problems and next

00:02:25,489 --> 00:02:35,200
steps and ide support was one of them so

00:02:28,730 --> 00:02:38,780
we decided to give that a try so i

00:02:35,200 --> 00:02:43,900
decided to use this tweet as an eye /

00:02:38,780 --> 00:02:49,430
girl for my speech i have seen this

00:02:43,900 --> 00:02:52,720
tweet to two hours later than several

00:02:49,430 --> 00:02:57,069
dirty related commits have been pushed

00:02:52,720 --> 00:03:00,680
it was very funny for me because

00:02:57,069 --> 00:03:03,260
obviously it doesn't have billions of

00:03:00,680 --> 00:03:06,260
favorites on their tweets please from

00:03:03,260 --> 00:03:08,840
this one but why do fat but why do we

00:03:06,260 --> 00:03:11,390
find this tweet important because it

00:03:08,840 --> 00:03:14,269
first of all it shows interest to our

00:03:11,390 --> 00:03:17,060
walk thank you your interest is

00:03:14,269 --> 00:03:23,209
appreciated but moreover it indicates

00:03:17,060 --> 00:03:26,799
the community interest in dot T so ah ok

00:03:23,209 --> 00:03:26,799
I would like to

00:03:47,180 --> 00:04:00,719
again here we go so let's create a dirty

00:03:52,109 --> 00:04:06,180
project I cannot extend the size of the

00:04:00,719 --> 00:04:09,989
window but here you can hear you can put

00:04:06,180 --> 00:04:13,889
the dirty SDK and you can create it and

00:04:09,989 --> 00:04:16,259
download it automatically so I i have

00:04:13,889 --> 00:04:19,979
already downloaded on load it in oil on

00:04:16,259 --> 00:04:29,520
my laptop so i don't need it and click

00:04:19,979 --> 00:04:35,180
finish and here we go so there are two

00:04:29,520 --> 00:04:38,639
options to try to the first one is

00:04:35,180 --> 00:04:42,300
skyler worksheet it's not very famous

00:04:38,639 --> 00:04:50,610
feature but let's give it a try testin

00:04:42,300 --> 00:04:55,130
we can just write code right here yeah

00:04:50,610 --> 00:04:55,130
okay so something like

00:05:02,660 --> 00:05:05,290
and

00:05:17,310 --> 00:05:20,060
ok

00:05:20,870 --> 00:05:29,060
so we can see that it works but you can

00:05:25,970 --> 00:05:34,880
maybe see summer at coding dotty it's

00:05:29,060 --> 00:05:41,570
quite usual so done don't think about it

00:05:34,880 --> 00:05:45,190
so let me show ya the type that dot the

00:05:41,570 --> 00:05:51,080
type system is under construction so

00:05:45,190 --> 00:05:59,030
sometimes what one day you we will show

00:05:51,080 --> 00:06:03,920
you the good stuff so but let's give it

00:05:59,030 --> 00:06:09,310
a try just now so this is a you submit

00:06:03,920 --> 00:06:19,700
something usual more usual mean we can

00:06:09,310 --> 00:06:21,880
for example build our project 42 and run

00:06:19,700 --> 00:06:21,880
it

00:06:28,020 --> 00:06:36,419
okay here shorty to everything so let me

00:06:33,720 --> 00:06:40,979
show you some dirty specific stuff we

00:06:36,419 --> 00:06:45,199
have shown we have seen it here the time

00:06:40,979 --> 00:06:49,949
type Union but there are some other

00:06:45,199 --> 00:06:52,349
features that were released in New in at

00:06:49,949 --> 00:06:58,530
scala days in New York City so we

00:06:52,349 --> 00:07:05,039
decided to support them before building

00:06:58,530 --> 00:07:08,120
and here we go the first feature is

00:07:05,039 --> 00:07:18,770
trade parameter so you can write

00:07:08,120 --> 00:07:18,770
something like something like this and

00:07:27,360 --> 00:07:45,110
and something like this so we will have

00:07:38,099 --> 00:07:45,110
our already resolution of names so oh

00:07:47,150 --> 00:07:58,789
let me write this method with something

00:07:56,370 --> 00:07:58,789
like this

00:08:09,569 --> 00:08:11,629
ah

00:08:22,800 --> 00:08:26,690
and run it

00:08:28,930 --> 00:08:37,779
so everything is okay you cannot write

00:08:35,000 --> 00:08:41,899
this code in scholar as far as you know

00:08:37,779 --> 00:08:47,089
for example we can build it and we run

00:08:41,899 --> 00:08:53,120
it and everything is a key a given

00:08:47,089 --> 00:08:55,940
feature before Berlin was a incremental

00:08:53,120 --> 00:08:59,200
compilation but now or dirty supports

00:08:55,940 --> 00:09:05,720
incremental compilation with SBT so now

00:08:59,200 --> 00:09:09,020
you can use that our project module the

00:09:05,720 --> 00:09:12,560
ideal one and the SBT one so as far as

00:09:09,020 --> 00:09:16,430
you can see everything works fine that

00:09:12,560 --> 00:09:21,770
the straight has implementation this one

00:09:16,430 --> 00:09:29,170
you can find usages you can find usages

00:09:21,770 --> 00:09:42,529
of these trade extends implement so

00:09:29,170 --> 00:09:46,820
sound like this and I think back to back

00:09:42,529 --> 00:09:48,890
to presentation yeah most of the

00:09:46,820 --> 00:09:51,500
features that i have shown are in

00:09:48,890 --> 00:09:54,200
nineteen and nightly builds their only

00:09:51,500 --> 00:09:58,220
one feature that is not included yet is

00:09:54,200 --> 00:10:01,100
trade parameters and predictably became

00:09:58,220 --> 00:10:06,800
quite complicated to adapt our plugin

00:10:01,100 --> 00:10:11,810
but i think we release it in a week or

00:10:06,800 --> 00:10:16,149
two weeks in a good condition so and the

00:10:11,810 --> 00:10:19,670
next light is a new language you plug in

00:10:16,149 --> 00:10:22,279
the basic approach is to support a new

00:10:19,670 --> 00:10:25,640
language in intellij idea is to create a

00:10:22,279 --> 00:10:34,060
new plugin it's quite straightforward

00:10:25,640 --> 00:10:37,190
and very simple but oh but why we do

00:10:34,060 --> 00:10:40,399
like this in general it seems obvious

00:10:37,190 --> 00:10:42,200
ever every language has its own grammar

00:10:40,399 --> 00:10:44,600
type system set

00:10:42,200 --> 00:10:47,030
features concepts and some flags that

00:10:44,600 --> 00:10:50,510
sounds like that so the reasons for a

00:10:47,030 --> 00:10:55,550
new plugin are on this slide but what we

00:10:50,510 --> 00:10:57,710
well what we're going to do if if the

00:10:55,550 --> 00:11:01,970
languages are similar something like

00:10:57,710 --> 00:11:05,930
dialects Oh are there any languages the

00:11:01,970 --> 00:11:10,570
dialects yeah the first one is there

00:11:05,930 --> 00:11:14,480
there is one and it's called SQL but

00:11:10,570 --> 00:11:19,010
it's well known that SQL has dialect

00:11:14,480 --> 00:11:24,650
many talents so when a SQL plugin have

00:11:19,010 --> 00:11:27,710
been created to eat the developers no

00:11:24,650 --> 00:11:32,750
have known that fact and the

00:11:27,710 --> 00:11:35,870
architecture or was that that it should

00:11:32,750 --> 00:11:40,580
be simple to use the dialects in that

00:11:35,870 --> 00:11:44,930
blogging and support them so and the SQL

00:11:40,580 --> 00:11:48,040
plugin became into a data creepers as

00:11:44,930 --> 00:11:52,370
maybe you know and the data grip is a

00:11:48,040 --> 00:11:55,490
ide for or databases and it was released

00:11:52,370 --> 00:11:59,660
a few months ago but the problem was

00:11:55,490 --> 00:12:06,830
that nobody have known that Scala would

00:11:59,660 --> 00:12:10,610
have some toilets so what we were first

00:12:06,830 --> 00:12:14,780
to do here's a list of comparative

00:12:10,610 --> 00:12:19,070
compiler phases that we should implement

00:12:14,780 --> 00:12:23,080
in our plugin the first the main problem

00:12:19,070 --> 00:12:28,880
is that we can not use the compiler

00:12:23,080 --> 00:12:32,720
inside elect plugging so are the first

00:12:28,880 --> 00:12:35,060
and lexical analysis but the group we

00:12:32,720 --> 00:12:37,700
can use the lexical analysis from

00:12:35,060 --> 00:12:41,870
scholar the next one is syntax analysis

00:12:37,700 --> 00:12:47,510
and as as you know there are new types

00:12:41,870 --> 00:12:51,380
new features so we need to extend our

00:12:47,510 --> 00:12:53,990
syntax and a loser at our parser the

00:12:51,380 --> 00:12:55,050
next one is the securitization it is

00:12:53,990 --> 00:12:59,399
very funny

00:12:55,050 --> 00:13:01,980
because who knows that Scott Scala

00:12:59,399 --> 00:13:06,240
doesn't support something like

00:13:01,980 --> 00:13:10,500
functional types natively so that it

00:13:06,240 --> 00:13:17,160
uses generic types to work with them who

00:13:10,500 --> 00:13:21,630
knows it not so many of you okay in

00:13:17,160 --> 00:13:24,209
don't see there are 0 there are a lots

00:13:21,630 --> 00:13:31,920
of disorganization and first of all in

00:13:24,209 --> 00:13:34,890
the type system and we we shall

00:13:31,920 --> 00:13:40,680
implement them in our plugin so the next

00:13:34,890 --> 00:13:43,230
one is type inference oh it's we need to

00:13:40,680 --> 00:13:46,500
implement the conformance algorithm

00:13:43,230 --> 00:13:50,310
their equivalents algorithm and bounce

00:13:46,500 --> 00:13:52,620
of founding algorithm and something like

00:13:50,310 --> 00:13:59,700
that and the next one is implicit

00:13:52,620 --> 00:14:03,329
resolution but two in but in general it

00:13:59,700 --> 00:14:08,160
seems that we don't need to implement it

00:14:03,329 --> 00:14:13,740
but after we will be done with the type

00:14:08,160 --> 00:14:16,380
system will see in the context of don t

00:14:13,740 --> 00:14:19,500
the main problem and most interesting

00:14:16,380 --> 00:14:26,459
thing is tightly type inference the type

00:14:19,500 --> 00:14:32,040
system in general so let's talk about

00:14:26,459 --> 00:14:38,730
our goals so we extracted a lot of

00:14:32,040 --> 00:14:42,329
interfaces for compiler phases and we

00:14:38,730 --> 00:14:45,420
now now we can read register

00:14:42,329 --> 00:14:49,949
implementations for them and it gives us

00:14:45,420 --> 00:14:52,170
an opportunity to implement some some

00:14:49,949 --> 00:14:57,390
features very quickly for example pop

00:14:52,170 --> 00:15:04,350
but parser for new features and to adapt

00:14:57,390 --> 00:15:06,660
it to that our plugin of 4 430 the first

00:15:04,350 --> 00:15:07,699
idea is to give you an opportunity to

00:15:06,660 --> 00:15:11,220
even

00:15:07,699 --> 00:15:16,230
to even compile your code with noting

00:15:11,220 --> 00:15:20,699
because if I idea will complain about

00:15:16,230 --> 00:15:28,339
some syntax stuff you will be not able

00:15:20,699 --> 00:15:31,490
to do it and the next goal was to

00:15:28,339 --> 00:15:36,749
reimplement the type system we are

00:15:31,490 --> 00:15:43,110
working on it right now so oh we have

00:15:36,749 --> 00:15:48,300
some funny results but what we have

00:15:43,110 --> 00:15:51,059
found I've found out that we created a

00:15:48,300 --> 00:15:55,910
plugin for our plugin and we need to go

00:15:51,059 --> 00:15:59,930
deeper we now we have some base features

00:15:55,910 --> 00:16:03,990
for some core features in our plugin and

00:15:59,930 --> 00:16:07,620
two or maybe even three plugins for

00:16:03,990 --> 00:16:11,519
scholar for SBT info dirty and it is

00:16:07,620 --> 00:16:17,160
very interesting I think this this

00:16:11,519 --> 00:16:21,259
approach so about type system maybe not

00:16:17,160 --> 00:16:24,389
of you know something like this

00:16:21,259 --> 00:16:27,540
intersection and union types were added

00:16:24,389 --> 00:16:31,019
to to type system the example I have

00:16:27,540 --> 00:16:33,420
already given and there are a lot of

00:16:31,019 --> 00:16:37,850
features that were removed from the type

00:16:33,420 --> 00:16:42,180
system the main idea was was like that

00:16:37,850 --> 00:16:46,970
the linear increment of number of

00:16:42,180 --> 00:16:51,149
features it implies the exponential

00:16:46,970 --> 00:16:56,339
complexity growth of the type system in

00:16:51,149 --> 00:17:00,540
general so generic type parameters were

00:16:56,339 --> 00:17:05,990
removed or they are now only a syntax

00:17:00,540 --> 00:17:08,789
sugar for abstract type members and

00:17:05,990 --> 00:17:11,789
existential types were removed hi

00:17:08,789 --> 00:17:13,829
content types were removed and all of

00:17:11,789 --> 00:17:18,230
these concepts were replaced it with

00:17:13,829 --> 00:17:24,829
just one and it is very very very cool

00:17:18,230 --> 00:17:30,970
and our not only the compiler developers

00:17:24,829 --> 00:17:35,419
have less work but we also because the

00:17:30,970 --> 00:17:39,890
there are not so many features in type

00:17:35,419 --> 00:17:45,410
system so it's quite it's much more

00:17:39,890 --> 00:17:49,130
simpler to implement it in our plugin so

00:17:45,410 --> 00:17:51,980
and now I'd like to say something about

00:17:49,130 --> 00:17:55,790
the roadmap and our future plans and

00:17:51,980 --> 00:17:59,179
about dirty the first question is what

00:17:55,790 --> 00:18:04,280
is dirty for us the answer is that that

00:17:59,179 --> 00:18:06,559
is an opportunity for language

00:18:04,280 --> 00:18:09,770
developers dotty is an opportunity to

00:18:06,559 --> 00:18:13,549
develop and to improve the language make

00:18:09,770 --> 00:18:18,650
it more simple make it faster make the

00:18:13,549 --> 00:18:20,929
compilation process faster this is the

00:18:18,650 --> 00:18:22,520
dirty general in general is a platform

00:18:20,929 --> 00:18:24,770
that gives you an opportunity to

00:18:22,520 --> 00:18:29,660
experiment with some language features

00:18:24,770 --> 00:18:34,010
same rules apply for us that is an

00:18:29,660 --> 00:18:37,309
opportunity to review our code base of

00:18:34,010 --> 00:18:41,390
our plugin to re-implement some features

00:18:37,309 --> 00:18:45,530
not even in dodgy but in Scala some

00:18:41,390 --> 00:18:49,240
processors make it more extendable or

00:18:45,530 --> 00:18:53,030
and even to get rid of some legacy code

00:18:49,240 --> 00:18:55,400
also dotty is a motivation to be honest

00:18:53,030 --> 00:19:01,100
we have a lack of motivation to change

00:18:55,400 --> 00:19:03,830
some plugin models because syntax what

00:19:01,100 --> 00:19:07,070
well the good example is syntax analysis

00:19:03,830 --> 00:19:13,220
it works fine nobody wants to even touch

00:19:07,070 --> 00:19:18,760
it why but when we decided to support

00:19:13,220 --> 00:19:18,760
dirty there was an idea that

00:19:19,190 --> 00:19:33,120
to to update our parser in such a sad

00:19:29,220 --> 00:19:37,620
mistake in this way historically skala

00:19:33,120 --> 00:19:41,460
plugin has has a man-made parser the

00:19:37,620 --> 00:19:45,570
first vision was implemented in 2008 and

00:19:41,460 --> 00:19:48,900
a it was 80 years ago and the number of

00:19:45,570 --> 00:19:52,320
features that were added to scala

00:19:48,900 --> 00:19:54,870
doesn't make it better and now but

00:19:52,320 --> 00:19:59,310
nowadays it's much more useful to you

00:19:54,870 --> 00:20:04,020
much more much more common to use par

00:19:59,310 --> 00:20:06,420
signal generators something like NTR in

00:20:04,020 --> 00:20:13,290
Java world something like gramma kid in

00:20:06,420 --> 00:20:18,960
ideal world and I decided to give until

00:20:13,290 --> 00:20:23,250
our a try and this is that this approach

00:20:18,960 --> 00:20:28,410
has several advantages well greater

00:20:23,250 --> 00:20:33,290
performance errorless in some of some

00:20:28,410 --> 00:20:39,230
kind and the uniformity oh now we have

00:20:33,290 --> 00:20:44,130
now we have have no opportunity to

00:20:39,230 --> 00:20:47,280
generate code of syntax analysis of just

00:20:44,130 --> 00:20:51,930
from the grammar but with Angela there

00:20:47,280 --> 00:20:56,330
is such an opportunity and the parser

00:20:51,930 --> 00:20:59,930
for dotty will be generated and dirty

00:20:56,330 --> 00:21:05,070
Parsifal scholar will be generated

00:20:59,930 --> 00:21:09,180
straightforward but the disadvantages of

00:21:05,070 --> 00:21:12,540
this approach is that why miss why mess

00:21:09,180 --> 00:21:16,650
with success we we have already a very

00:21:12,540 --> 00:21:22,430
good person and it's quite arguable

00:21:16,650 --> 00:21:28,230
about so should we do this or not but

00:21:22,430 --> 00:21:30,720
now we have an an extended version of

00:21:28,230 --> 00:21:31,200
our man-made Parsa that gives an

00:21:30,720 --> 00:21:33,750
opportune

00:21:31,200 --> 00:21:37,799
to support dialects for example Dottie

00:21:33,750 --> 00:21:41,510
or even subscript so maybe if you would

00:21:37,799 --> 00:21:45,419
like to create your Santha your some

00:21:41,510 --> 00:21:48,630
scholar like Earl language you can give

00:21:45,419 --> 00:21:55,200
it you can give a supporter for for it

00:21:48,630 --> 00:21:58,799
in IntelliJ so and about our future

00:21:55,200 --> 00:22:02,309
plans what is coming soon the first

00:21:58,799 --> 00:22:05,100
feature is droid parameters is under the

00:22:02,309 --> 00:22:14,549
construction right now so we'll release

00:22:05,100 --> 00:22:17,279
it as I said a few weeks from now so the

00:22:14,549 --> 00:22:20,480
next feature is multiversal equality

00:22:17,279 --> 00:22:24,269
that is very interesting that we have

00:22:20,480 --> 00:22:29,519
this feature already in our plugin but

00:22:24,269 --> 00:22:34,380
so we can but we can include it in

00:22:29,519 --> 00:22:38,100
builds only after we would be done with

00:22:34,380 --> 00:22:42,960
that type system so inspections and

00:22:38,100 --> 00:22:45,809
quick fixes oh okay i'll show you one

00:22:42,960 --> 00:22:49,760
inspection and quick fix that we have

00:22:45,809 --> 00:22:54,510
already implemented and we'd like to

00:22:49,760 --> 00:22:59,490
create a skeletal data migration to I

00:22:54,510 --> 00:23:02,639
think it would be available or only

00:22:59,490 --> 00:23:10,010
after the official release of duty to

00:23:02,639 --> 00:23:14,010
give developers an opportunity to

00:23:10,010 --> 00:23:17,279
migrate their code because they're there

00:23:14,010 --> 00:23:20,940
is a problem of backwards compatibility

00:23:17,279 --> 00:23:25,529
between Scylla and dot T there is no

00:23:20,940 --> 00:23:30,720
backwards compatibility so you know the

00:23:25,529 --> 00:23:34,679
first so you can know right it you can

00:23:30,720 --> 00:23:38,460
implement your code with photo G with

00:23:34,679 --> 00:23:41,120
your hands but would like to give you an

00:23:38,460 --> 00:23:43,070
opportunity to do it automatically so

00:23:41,120 --> 00:23:55,120
excuse me

00:23:43,070 --> 00:24:06,009
like doosh yeah Val quick I forgot to

00:23:55,120 --> 00:24:15,250
show you a quick fix so when you write

00:24:06,009 --> 00:24:15,250
in in in Scala something like this

00:24:23,740 --> 00:24:35,630
again so you can replace it with an

00:24:32,690 --> 00:24:40,660
person because a compound type was

00:24:35,630 --> 00:24:43,660
duplicated in dot T and you need to

00:24:40,660 --> 00:24:50,480
write something like this that

00:24:43,660 --> 00:24:59,870
intersection type and back to our

00:24:50,480 --> 00:25:03,520
presentation okay so and that's all I

00:24:59,870 --> 00:25:07,400
wanted to tell you about today you I

00:25:03,520 --> 00:25:10,280
think we've got some quit I think you've

00:25:07,400 --> 00:25:18,260
got some questions and we've got plenty

00:25:10,280 --> 00:25:20,300
of time for him so if you are one if you

00:25:18,260 --> 00:25:21,980
don't want to ask questions right here

00:25:20,300 --> 00:25:25,040
you can reach me of course on the dead

00:25:21,980 --> 00:25:31,420
brains desk so but do you have any

00:25:25,040 --> 00:25:31,420
questions any my name yeah

00:25:32,540 --> 00:25:40,280
like official data release will be like

00:25:34,940 --> 00:25:43,580
yeah yeah yeah what why you started to

00:25:40,280 --> 00:25:47,450
so early and even like plans for

00:25:43,580 --> 00:25:50,180
migration tool right now yeah thank you

00:25:47,450 --> 00:25:58,250
for question the answer is something

00:25:50,180 --> 00:26:02,270
like that don t has a dirty type system

00:25:58,250 --> 00:26:07,880
has a lot of differences with scholarone

00:26:02,270 --> 00:26:10,520
I mean a lot of them so it would to take

00:26:07,880 --> 00:26:14,240
it all hate have already taken a lot of

00:26:10,520 --> 00:26:18,620
time to adapt our plug-in it would take

00:26:14,240 --> 00:26:22,880
a lot of time to continue with it and so

00:26:18,620 --> 00:26:27,110
we need a lot of time to implement the

00:26:22,880 --> 00:26:30,230
type system because the main one of them

00:26:27,110 --> 00:26:33,440
greatest things in scholar in general is

00:26:30,230 --> 00:26:36,020
the type system so we spend we have

00:26:33,440 --> 00:26:38,900
spent a lot of time to implement this

00:26:36,020 --> 00:26:42,800
color one in our plug-in to make it

00:26:38,900 --> 00:26:48,440
grates and most of the features that you

00:26:42,800 --> 00:26:50,210
can use in our plugin refactorings code

00:26:48,440 --> 00:26:53,810
completion sounds like that it

00:26:50,210 --> 00:26:55,580
everything is everything uses type

00:26:53,810 --> 00:27:01,940
system because there is a lot of

00:26:55,580 --> 00:27:05,270
information about types and two we need

00:27:01,940 --> 00:27:14,320
to implement it for dotty to make it to

00:27:05,270 --> 00:27:18,020
make this feature spot so ok ok yeah so

00:27:14,320 --> 00:27:21,170
why or maybe you are using it are you

00:27:18,020 --> 00:27:25,280
using some parts of the Dottie compiler

00:27:21,170 --> 00:27:28,820
to help you with types type inference

00:27:25,280 --> 00:27:32,750
and type conformance analysis yeah yeah

00:27:28,820 --> 00:27:36,740
ok thank you for a question no as I

00:27:32,750 --> 00:27:40,790
mentioned you got no opportunity to use

00:27:36,740 --> 00:27:43,880
the compiler there isn't old internal

00:27:40,790 --> 00:27:45,639
joke engine brains that we've got

00:27:43,880 --> 00:27:48,849
something like seven product

00:27:45,639 --> 00:27:52,029
and every project has half of the

00:27:48,849 --> 00:27:54,009
compiler inside it so we have written

00:27:52,029 --> 00:28:02,499
something like three and a half of

00:27:54,009 --> 00:28:10,469
compilers the why don't we use the

00:28:02,499 --> 00:28:16,179
compiler because IntelliJ is is there

00:28:10,469 --> 00:28:21,119
ide so an IDE uses much more information

00:28:16,179 --> 00:28:26,049
about Cove than the compiler you have

00:28:21,119 --> 00:28:30,519
you need much more links between

00:28:26,049 --> 00:28:33,309
elements and the compiler doesn't have

00:28:30,519 --> 00:28:37,649
these links because because of the

00:28:33,309 --> 00:28:42,940
performance and the example of this Oh

00:28:37,649 --> 00:28:48,209
for example maybe you maybe know cotton

00:28:42,940 --> 00:28:53,049
and cotton is developed with with one

00:28:48,209 --> 00:28:58,359
team or the compiler and plugin for it

00:28:53,049 --> 00:29:01,359
so they had this problem that they have

00:28:58,359 --> 00:29:04,839
compiled in their project but they

00:29:01,359 --> 00:29:09,179
cannot use it straight forward because

00:29:04,839 --> 00:29:13,509
and because of the performance compiler

00:29:09,179 --> 00:29:16,989
doesn't need all of this information so

00:29:13,509 --> 00:29:21,459
is it clear yes that's that's clear

00:29:16,989 --> 00:29:24,009
however I wonder maybe do you do get at

00:29:21,459 --> 00:29:25,899
least some support from the doctor

00:29:24,009 --> 00:29:29,529
compiler team or from the Scala compiler

00:29:25,899 --> 00:29:32,889
team to help you with getting things

00:29:29,529 --> 00:29:36,009
right I'm the heavy user a heavy user of

00:29:32,889 --> 00:29:37,719
your current Scala plugin I must say

00:29:36,009 --> 00:29:40,089
there are still some differences between

00:29:37,719 --> 00:29:43,539
how the plug-in in first types for

00:29:40,089 --> 00:29:46,599
example or how it there are still a few

00:29:43,539 --> 00:29:48,280
cases where it gets it wrong yeah I

00:29:46,599 --> 00:29:50,080
wonder why don't you

00:29:48,280 --> 00:29:55,900
cooperate more closely with the compiler

00:29:50,080 --> 00:30:01,180
team alright we we have some kind of

00:29:55,900 --> 00:30:05,950
cooperation but I cannot say that we

00:30:01,180 --> 00:30:09,310
work together but there is some kind of

00:30:05,950 --> 00:30:15,970
cooperation sometimes sometimes so we

00:30:09,310 --> 00:30:18,780
have a better support of off Scala well

00:30:15,970 --> 00:30:21,880
the problem is that a scholar has a

00:30:18,780 --> 00:30:28,960
specialist to tell is a documentation an

00:30:21,880 --> 00:30:32,650
official documentation and sometimes we

00:30:28,960 --> 00:30:37,630
have back sometimes compiler have back

00:30:32,650 --> 00:30:40,660
so and there are examples where know our

00:30:37,630 --> 00:30:43,840
plugin works better than the compiler so

00:30:40,660 --> 00:30:50,760
and something like that applies to

00:30:43,840 --> 00:30:59,650
Dottie may-maybe with the implementation

00:30:50,760 --> 00:31:03,450
the the actual result would be better on

00:30:59,650 --> 00:31:08,490
for our plugin handful compiler itself I

00:31:03,450 --> 00:31:08,490
think times like that ok thank you ok

00:31:10,710 --> 00:31:17,620
thank you so well known issues it

00:31:13,810 --> 00:31:20,170
currently you don't support scallop

00:31:17,620 --> 00:31:22,780
login and dotty plug in at the same time

00:31:20,170 --> 00:31:25,120
in the same system is it coming in new

00:31:22,780 --> 00:31:29,350
release or it's in your backlog to

00:31:25,120 --> 00:31:32,580
support was of them excuse my to install

00:31:29,350 --> 00:31:36,120
dr. plugin into my intelligence idea

00:31:32,580 --> 00:31:38,890
system I had to uninstall Scala plugin

00:31:36,120 --> 00:31:43,800
cause a kind of conflicting with each

00:31:38,890 --> 00:31:43,800
other as it's in your back walk at least

00:31:44,280 --> 00:31:53,530
there is in general there is no dodgy

00:31:49,630 --> 00:31:55,420
plugin because there is only one playing

00:31:53,530 --> 00:32:00,490
in the scallop lying in that now

00:31:55,420 --> 00:32:04,470
supports two languages so huge to use

00:32:00,490 --> 00:32:08,470
the dirty inside of it you need to

00:32:04,470 --> 00:32:13,450
install the nightly build yeah but it's

00:32:08,470 --> 00:32:30,570
not the new plugins it's a new version

00:32:13,450 --> 00:32:30,570
of this all plugin yeah

00:32:36,260 --> 00:32:44,900
let me add some more information about

00:32:39,050 --> 00:32:47,400
why we don't use Scala compiler as

00:32:44,900 --> 00:32:49,380
presentation compiler the differences

00:32:47,400 --> 00:32:55,620
between the first important difference

00:32:49,380 --> 00:32:59,640
is that we we ni de so we need to check

00:32:55,620 --> 00:33:02,100
local changes and the compiler has to to

00:32:59,640 --> 00:33:04,290
compile all hold the project to all

00:33:02,100 --> 00:33:07,050
together so for performance reasons ID

00:33:04,290 --> 00:33:10,110
and compiler is different things and we

00:33:07,050 --> 00:33:13,950
are doing resolving reference completely

00:33:10,110 --> 00:33:15,990
dif differently so we we do it from from

00:33:13,950 --> 00:33:18,179
reference to the declaration and

00:33:15,990 --> 00:33:21,150
compilers always do it from the

00:33:18,179 --> 00:33:25,350
declaration to the reference so that's

00:33:21,150 --> 00:33:28,920
the main difference and it's really

00:33:25,350 --> 00:33:34,020
important so and to be more efficient

00:33:28,920 --> 00:33:36,179
and more adapted to adduce different

00:33:34,020 --> 00:33:40,080
refactorings and different things we

00:33:36,179 --> 00:33:42,270
need to do things also differently so

00:33:40,080 --> 00:33:44,850
it's very important that's the reason

00:33:42,270 --> 00:33:48,690
why we do our own implicate

00:33:44,850 --> 00:33:50,610
implementation of analyzer and we we

00:33:48,690 --> 00:33:54,240
don't work together on the same code

00:33:50,610 --> 00:33:57,420
base with Scala compiler team because

00:33:54,240 --> 00:34:00,450
it's due to different projects and it's

00:33:57,420 --> 00:34:03,150
hard to work on two projects too

00:34:00,450 --> 00:34:07,260
complicated project actually so our

00:34:03,150 --> 00:34:09,950
cooperation is is in such way that if

00:34:07,260 --> 00:34:14,000
they do new features they

00:34:09,950 --> 00:34:17,389
will inform us before they release these

00:34:14,000 --> 00:34:20,570
new features and we will be we will have

00:34:17,389 --> 00:34:24,310
plenty of time to reimplement the same

00:34:20,570 --> 00:34:27,889
feature in our ID so and also we can

00:34:24,310 --> 00:34:31,550
share some bugs in compiler so we have a

00:34:27,889 --> 00:34:36,349
lot of cooperations on more high level

00:34:31,550 --> 00:34:42,980
and it's it's very good so really thanks

00:34:36,349 --> 00:34:44,419
to Scala compiler t yes thank you so

00:34:42,980 --> 00:34:47,419
just to follow up on the question before

00:34:44,419 --> 00:34:51,050
in this discussion are you guys change

00:34:47,419 --> 00:34:54,020
em what are your strategies to actually

00:34:51,050 --> 00:34:55,730
make sure that they're on par or you are

00:34:54,020 --> 00:34:57,050
you going to keep the same strategy that

00:34:55,730 --> 00:34:59,570
you're using for the scholar plugin or

00:34:57,050 --> 00:35:04,339
do you have any ideas of of doing some

00:34:59,570 --> 00:35:08,829
more being making better sure that they

00:35:04,339 --> 00:35:11,570
are the doing producing the same results

00:35:08,829 --> 00:35:14,660
do you I just curious if you're trying

00:35:11,570 --> 00:35:18,530
new strategies to make them stay the

00:35:14,660 --> 00:35:24,859
same with dotty maybe the plugin or am i

00:35:18,530 --> 00:35:26,930
unclear mmm excuse me could food your

00:35:24,859 --> 00:35:28,400
are you going to try any new strategies

00:35:26,930 --> 00:35:31,369
to make sure that the Dudley plug-in

00:35:28,400 --> 00:35:34,579
stays on par with the the dotty compiler

00:35:31,369 --> 00:35:35,869
or is the plan to use the same

00:35:34,579 --> 00:35:38,869
strategies that you've been doing with

00:35:35,869 --> 00:35:44,660
this color plugin yeah we've got no

00:35:38,869 --> 00:35:47,180
opportunity to use compiler at all there

00:35:44,660 --> 00:35:51,400
is we know that there is no other

00:35:47,180 --> 00:35:54,400
strategy that that the fact if I

00:35:51,400 --> 00:35:54,400
understood

00:36:02,980 --> 00:36:26,340
ah okay and the strategy is to this is

00:36:20,850 --> 00:36:26,340
the slide about strategy in general

00:36:27,300 --> 00:36:41,590
intellij idea has its own open API so

00:36:33,780 --> 00:36:46,000
because the architecture of the IntelliJ

00:36:41,590 --> 00:36:54,460
gives us an opportunity to support a lot

00:36:46,000 --> 00:36:59,280
of languages so we decided to to extract

00:36:54,460 --> 00:37:03,430
some API in our own plugin and that year

00:36:59,280 --> 00:37:08,670
there is we extracted some interfaces

00:37:03,430 --> 00:37:11,830
for some compiler faces and now we have

00:37:08,670 --> 00:37:19,320
implementation for scholar and for dot

00:37:11,830 --> 00:37:19,320
you ok clear ok

00:37:26,749 --> 00:37:34,259
mmm okay will well think about yeah so

00:37:32,549 --> 00:37:35,579
following this discussion because I

00:37:34,259 --> 00:37:38,939
think that that's a very good question

00:37:35,579 --> 00:37:42,180
so how are you making sure how are you

00:37:38,939 --> 00:37:45,349
testing your scar scar plugging and then

00:37:42,180 --> 00:37:48,150
Dottie plug-in that it conforms to the

00:37:45,349 --> 00:37:50,369
specification I think that the Scala

00:37:48,150 --> 00:37:55,019
compiler and the DOTA compiler has a

00:37:50,369 --> 00:37:56,939
very big very huge set of tests they own

00:37:55,019 --> 00:38:00,689
from unit tests and also functional

00:37:56,939 --> 00:38:02,910
tests so it seems this to me it looks

00:38:00,689 --> 00:38:06,599
like it should be fairly straightforward

00:38:02,910 --> 00:38:12,289
to run the Scala compiler of dr.

00:38:06,599 --> 00:38:17,309
compiler tests on your code on on the

00:38:12,289 --> 00:38:20,099
IDE scalp Lac in internals a particular

00:38:17,309 --> 00:38:24,029
because you have the api api extracted

00:38:20,099 --> 00:38:26,309
so like taking all the scholar or dotty

00:38:24,029 --> 00:38:29,009
examples and trying to compile it with

00:38:26,309 --> 00:38:32,219
your plugin code and to see if it

00:38:29,009 --> 00:38:35,130
compiles properly without any warnings

00:38:32,219 --> 00:38:36,749
or red underlines yeah are you planning

00:38:35,130 --> 00:38:42,920
to do that right maybe doing this

00:38:36,749 --> 00:38:48,599
already yeah the only test for dotty now

00:38:42,920 --> 00:38:54,749
the moment our compiler test so but for

00:38:48,599 --> 00:38:58,019
scholar there are a lot of the very much

00:38:54,749 --> 00:39:01,019
more tests and not only that were

00:38:58,019 --> 00:39:06,119
influenced by the competitive but from

00:39:01,019 --> 00:39:10,309
our own box and something that I can add

00:39:06,119 --> 00:39:17,249
more about it that we have and know

00:39:10,309 --> 00:39:21,359
plenty of things what to do so so we

00:39:17,249 --> 00:39:26,670
know a lot of errors and problems to fix

00:39:21,359 --> 00:39:30,959
them so and of course the next step

00:39:26,670 --> 00:39:32,180
would be to to reuse lots of community

00:39:30,959 --> 00:39:34,550
projects so we can

00:39:32,180 --> 00:39:37,369
just check community project that it's

00:39:34,550 --> 00:39:39,140
okay with compiler and then check the

00:39:37,369 --> 00:39:42,470
community project that it's okay with

00:39:39,140 --> 00:39:45,650
our analyzer so it will be the next step

00:39:42,470 --> 00:39:48,640
and of course we will have the it's

00:39:45,650 --> 00:39:53,210
quite simple and straightforward ideas

00:39:48,640 --> 00:39:56,660
definitely one that and we we are more

00:39:53,210 --> 00:40:00,559
close to this step because we are

00:39:56,660 --> 00:40:04,040
reducing number of errors from every

00:40:00,559 --> 00:40:08,780
years and I hope that it really became

00:40:04,040 --> 00:40:13,309
better and better every month I hope for

00:40:08,780 --> 00:40:15,980
that so yeah and there is another

00:40:13,309 --> 00:40:18,800
problem that there is only one project

00:40:15,980 --> 00:40:24,260
in da ta at the moment it's dodgy

00:40:18,800 --> 00:40:27,010
compiler its health but they don't use a

00:40:24,260 --> 00:40:31,280
lot of OT feature so it's basically

00:40:27,010 --> 00:40:34,130
scholar project but so there is no

00:40:31,280 --> 00:40:36,980
example of real dodgy project that has

00:40:34,130 --> 00:40:41,059
has a lot of feature inside of it that

00:40:36,980 --> 00:40:49,420
we can see try it and some find some

00:40:41,059 --> 00:40:56,690
bags because dot G should is not the

00:40:49,420 --> 00:40:59,630
doctor compiler is not is not yet or

00:40:56,690 --> 00:41:03,799
implemented with dotty in general there

00:40:59,630 --> 00:41:13,450
are some feature that that they use but

00:41:03,799 --> 00:41:17,540
not a lot of them ok any other questions

00:41:13,450 --> 00:41:19,910
yeah ok so one more about but a

00:41:17,540 --> 00:41:23,540
different topic so I said that the type

00:41:19,910 --> 00:41:25,510
system in the dot a is simpler and some

00:41:23,540 --> 00:41:29,990
features of the type system has been

00:41:25,510 --> 00:41:35,350
unified in how do you perceive that is

00:41:29,990 --> 00:41:38,840
it going to make it easier for you to

00:41:35,350 --> 00:41:41,990
make the performance of the dotty plugin

00:41:38,840 --> 00:41:46,960
better than the performance of scala

00:41:41,990 --> 00:41:46,960
analysis or would it be mostly the same

00:41:47,770 --> 00:41:59,420
I've I think and I hope that the

00:41:55,520 --> 00:42:04,070
performance of the Duchy plugin would be

00:41:59,420 --> 00:42:18,140
better because of that the simplified

00:42:04,070 --> 00:42:21,770
tax system yes there are a lot the typer

00:42:18,140 --> 00:42:24,980
in in compiler itself and are now

00:42:21,770 --> 00:42:27,940
plugging it takes a lot of it takes a

00:42:24,980 --> 00:42:31,610
lot of time during the work of the

00:42:27,940 --> 00:42:39,880
platte plugin for example the person of

00:42:31,610 --> 00:42:39,880
that type inference is very high so II

00:42:42,550 --> 00:42:50,480
because of the simpler type system the

00:42:46,730 --> 00:42:57,310
this this face of the compilation type

00:42:50,480 --> 00:43:02,590
inference should be actually should have

00:42:57,310 --> 00:43:08,270
better performance in some way but I

00:43:02,590 --> 00:43:13,900
cannot say yet that would be something

00:43:08,270 --> 00:43:17,030
on the new level I don't think so but

00:43:13,900 --> 00:43:22,810
maybe the performance would be better

00:43:17,030 --> 00:43:22,810
you improved yet okay

00:43:24,010 --> 00:43:33,849
anything else so okay I think that

00:43:29,050 --> 00:43:33,849

YouTube URL: https://www.youtube.com/watch?v=MPyY5spl2Gg


