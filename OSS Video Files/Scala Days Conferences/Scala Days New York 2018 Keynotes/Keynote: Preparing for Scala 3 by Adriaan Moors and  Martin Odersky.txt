Title: Keynote: Preparing for Scala 3 by Adriaan Moors and  Martin Odersky
Publication date: 2018-09-22
Playlist: Scala Days New York 2018 Keynotes
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/preparing-for-scala-3
Captions: 
	00:00:03,719 --> 00:00:08,730
very excited to meet you all happy to

00:00:06,149 --> 00:00:13,170
see so many faces kind of in the dark a

00:00:08,730 --> 00:00:15,779
little bit so I'm the the scala team

00:00:13,170 --> 00:00:19,109
lead at light Bend I have been for the

00:00:15,779 --> 00:00:20,640
last six years or something like that as

00:00:19,109 --> 00:00:25,200
we'll see in the roadmap slides time

00:00:20,640 --> 00:00:26,760
flies yeah

00:00:25,200 --> 00:00:30,090
so let's talk a little bit about the

00:00:26,760 --> 00:00:32,520
roadmap I'm basically we are in charge

00:00:30,090 --> 00:00:36,600
of the boring part like everything that

00:00:32,520 --> 00:00:38,640
has like Scala - something on it and you

00:00:36,600 --> 00:00:41,699
know together with all of you in the

00:00:38,640 --> 00:00:46,409
community we've been we've been working

00:00:41,699 --> 00:00:49,679
very hard to to realize this and and I'm

00:00:46,409 --> 00:00:52,109
really proud of the first one the first

00:00:49,679 --> 00:00:54,389
release here on the roadmap Scala 212

00:00:52,109 --> 00:00:57,989
can we get a quick show of hands who's

00:00:54,389 --> 00:01:02,579
using it already I'm gonna go with like

00:00:57,989 --> 00:01:05,519
that's roughly 100% the lights I

00:01:02,579 --> 00:01:06,840
couldn't see so thanks for upgrading I

00:01:05,519 --> 00:01:08,700
know that there's some spark users out

00:01:06,840 --> 00:01:11,789
there that are still on 211 we're

00:01:08,700 --> 00:01:18,320
working with with those guys on helping

00:01:11,789 --> 00:01:23,460
them upgrade yeah it's a big project but

00:01:18,320 --> 00:01:25,890
well we'll get there I'm very hopeful so

00:01:23,460 --> 00:01:28,829
you know around the time that I started

00:01:25,890 --> 00:01:31,020
leading the team light Bend and 2012

00:01:28,829 --> 00:01:35,670
Dottie Dottie start at Dottie

00:01:31,020 --> 00:01:37,500
development started and around to 12 I

00:01:35,670 --> 00:01:39,990
guess we there was the first crossover

00:01:37,500 --> 00:01:42,030
point where the backend between the two

00:01:39,990 --> 00:01:44,640
compilers is shared already so two part

00:01:42,030 --> 00:01:45,950
that does a bytecode emission and the

00:01:44,640 --> 00:01:48,450
rest of the roadmap is basically

00:01:45,950 --> 00:01:50,700
continuing that story where we see how

00:01:48,450 --> 00:01:54,899
we can align those two roadmaps and get

00:01:50,700 --> 00:01:57,990
to you know scale three Scout to 13

00:01:54,899 --> 00:02:01,890
which will be out in a few months who

00:01:57,990 --> 00:02:04,740
has taken a look at the m4 milestone and

00:02:01,890 --> 00:02:07,259
the new collections already also about a

00:02:04,740 --> 00:02:09,880
hundred percent great

00:02:07,259 --> 00:02:11,440
so thank you very much

00:02:09,880 --> 00:02:12,760
there was a few people at the spree I

00:02:11,440 --> 00:02:16,780
think who were also looking into this

00:02:12,760 --> 00:02:19,360
and we have one more milestone ahead of

00:02:16,780 --> 00:02:20,680
us so this is really a great time to

00:02:19,360 --> 00:02:22,239
take a look at a project that you're

00:02:20,680 --> 00:02:23,739
using maybe your favorite project or

00:02:22,239 --> 00:02:27,370
maybe you know one that's really key to

00:02:23,739 --> 00:02:28,840
your project and see how you can help

00:02:27,370 --> 00:02:31,720
them upgrade to the new collections if

00:02:28,840 --> 00:02:33,580
you're just you know using them it

00:02:31,720 --> 00:02:35,200
should be quick and we have a lot of

00:02:33,580 --> 00:02:36,190
success stories already there's a lot of

00:02:35,200 --> 00:02:37,540
people from the community they're

00:02:36,190 --> 00:02:41,080
helping out with that and it's really

00:02:37,540 --> 00:02:44,709
really great to see we really hope to

00:02:41,080 --> 00:02:46,870
have a good showing for m5 and I think

00:02:44,709 --> 00:02:48,519
we're very close to to feeling confident

00:02:46,870 --> 00:02:51,310
that the upgrade will be you know as a

00:02:48,519 --> 00:02:55,080
usual Scala to a to upgrade very

00:02:51,310 --> 00:02:57,730
painless and only exciting in good ways

00:02:55,080 --> 00:02:59,739
so that's that's the first big thing

00:02:57,730 --> 00:03:02,290
that we wanted to do for Scala 3 was to

00:02:59,739 --> 00:03:03,640
to rework the collection and there will

00:03:02,290 --> 00:03:05,620
be there will be a whole talk about that

00:03:03,640 --> 00:03:10,390
by Stephan and Julia later in a

00:03:05,620 --> 00:03:12,370
conference the the second part that word

00:03:10,390 --> 00:03:14,320
that we're aligning between Scala 2 and

00:03:12,370 --> 00:03:16,780
3 and that's what we're excited to start

00:03:14,320 --> 00:03:19,450
work on as soon as 213 is out is as

00:03:16,780 --> 00:03:21,370
tasty and kind of you know pulling the

00:03:19,450 --> 00:03:22,720
zipper further down between the two

00:03:21,370 --> 00:03:24,700
compiler so really have a shared

00:03:22,720 --> 00:03:26,319
back-end for byte code emission now we

00:03:24,700 --> 00:03:28,810
want to see how much more code we can

00:03:26,319 --> 00:03:31,299
share up to type checking and that's

00:03:28,810 --> 00:03:32,980
what tasty is basically it's an

00:03:31,299 --> 00:03:36,310
interchange format for a fully type

00:03:32,980 --> 00:03:40,120
check Scala code and so we hope to have

00:03:36,310 --> 00:03:44,319
one front end that is shared between the

00:03:40,120 --> 00:03:47,109
two compilers and then you know in 215

00:03:44,319 --> 00:03:51,310
oh wait no just just kidding we actually

00:03:47,109 --> 00:03:53,170
decided that there won't be a 215 very

00:03:51,310 --> 00:03:56,440
happy to see how this plan has held up

00:03:53,170 --> 00:04:00,760
except then for poor 215 who you know

00:03:56,440 --> 00:04:02,739
isn't gonna see the light of day but you

00:04:00,760 --> 00:04:04,870
know the dates that we predicted a while

00:04:02,739 --> 00:04:07,950
ago now and I don't remember which Scala

00:04:04,870 --> 00:04:07,950
days it was it could've been in New York

00:04:08,730 --> 00:04:14,409
you know have held up really well and

00:04:11,019 --> 00:04:17,320
we're excited to have 2 to 14 out in

00:04:14,409 --> 00:04:18,700
2020 and Scala 3-0 soon after that and

00:04:17,320 --> 00:04:20,180
so like I was starting to say on the

00:04:18,700 --> 00:04:22,460
previous slide

00:04:20,180 --> 00:04:25,340
they will share a lot of code already so

00:04:22,460 --> 00:04:26,780
that's my job description basically is

00:04:25,340 --> 00:04:31,420
to make all these things as boring as

00:04:26,780 --> 00:04:34,010
possible you know the upgrades are are

00:04:31,420 --> 00:04:35,360
going to be very interesting to 3-0 in

00:04:34,010 --> 00:04:36,800
terms of all the exciting stuff on the

00:04:35,360 --> 00:04:39,590
type system and you'll see all about

00:04:36,800 --> 00:04:41,120
that and the rest of the keynote but

00:04:39,590 --> 00:04:48,620
everything else will get out of the way

00:04:41,120 --> 00:04:49,910
in the two series and I really like how

00:04:48,620 --> 00:04:52,490
the collections have come together and

00:04:49,910 --> 00:04:53,930
I'm really excited about you know tasty

00:04:52,490 --> 00:04:55,400
as a mechanism to bring the two

00:04:53,930 --> 00:04:58,090
compilers together and to build a lot of

00:04:55,400 --> 00:05:02,810
share tool in between the Scala 2:14

00:04:58,090 --> 00:05:04,250
compiler and 3:0 but for that I I did

00:05:02,810 --> 00:05:07,490
promise that Martin was gonna speak as

00:05:04,250 --> 00:05:09,230
well so I won't take any more of his

00:05:07,490 --> 00:05:10,760
precious keynote time because I know

00:05:09,230 --> 00:05:14,660
there was a few slides at it so it's

00:05:10,760 --> 00:05:18,050
Berlin so please join me welcoming

00:05:14,660 --> 00:05:21,410
Martin utters dr3 is indeed a big step

00:05:18,050 --> 00:05:23,240
from SCARA - it won't be fully source

00:05:21,410 --> 00:05:26,540
backwards compatible there will have to

00:05:23,240 --> 00:05:28,580
be some code rewrites to be done so this

00:05:26,540 --> 00:05:31,700
whole thing is scary so the main

00:05:28,580 --> 00:05:34,100
question is well why do it why not stay

00:05:31,700 --> 00:05:37,550
and essentially the safe training of

00:05:34,100 --> 00:05:39,890
SCARA - so in order to give you a

00:05:37,550 --> 00:05:42,770
justification why we're working on Scala

00:05:39,890 --> 00:05:44,960
3 I think it's I wanted to go back to

00:05:42,770 --> 00:05:47,480
essentially the original reason why I

00:05:44,960 --> 00:05:49,490
did Scala in the first place and that

00:05:47,480 --> 00:05:51,380
was that to show that a fusion of

00:05:49,490 --> 00:05:54,350
functional and object-oriented

00:05:51,380 --> 00:05:57,290
programming could be practical and

00:05:54,350 --> 00:05:59,060
powerful and the particular could be

00:05:57,290 --> 00:06:00,800
practically powerful in a typesetting

00:05:59,060 --> 00:06:03,380
because before you could argue that

00:06:00,800 --> 00:06:05,690
other languages did that already common

00:06:03,380 --> 00:06:07,640
list comes to mind or maybe even small

00:06:05,690 --> 00:06:10,280
talk but in a statically type setting

00:06:07,640 --> 00:06:12,800
SCADA was basically the first mainstream

00:06:10,280 --> 00:06:14,720
language that tried that and I still

00:06:12,800 --> 00:06:17,600
believe that this is an excellent way to

00:06:14,720 --> 00:06:19,580
combine the two because it's a nice

00:06:17,600 --> 00:06:22,550
separation of concerns where we use

00:06:19,580 --> 00:06:25,910
functions for the logic and objects for

00:06:22,550 --> 00:06:28,220
the more modularity and if you look back

00:06:25,910 --> 00:06:31,460
then I guess we can declare success

00:06:28,220 --> 00:06:32,650
because starting from a statically typed

00:06:31,460 --> 00:06:35,770
object oriented

00:06:32,650 --> 00:06:39,310
or scalloped Ionia closures function

00:06:35,770 --> 00:06:41,680
types expression orientation tuples

00:06:39,310 --> 00:06:46,270
local type inference pattern matching

00:06:41,680 --> 00:06:49,870
traits lazy values by name parameters x

00:06:46,270 --> 00:06:52,810
: t syntax instead of TX dependent types

00:06:49,870 --> 00:06:54,699
implicit parameters and more and if you

00:06:52,810 --> 00:06:57,340
look at this thing that you say well

00:06:54,699 --> 00:06:59,889
yeah sure that seems to be pretty

00:06:57,340 --> 00:07:01,660
standard nowadays and the answer is yes

00:06:59,889 --> 00:07:02,919
and that's the success because SCADA

00:07:01,660 --> 00:07:05,050
really was the first one to have

00:07:02,919 --> 00:07:08,050
pioneered that and a lot of that is

00:07:05,050 --> 00:07:10,030
pretty much industry standard in and has

00:07:08,050 --> 00:07:12,639
been adopted by quite a few other

00:07:10,030 --> 00:07:15,729
languages so c-sharp comes to mind

00:07:12,639 --> 00:07:16,900
Courtland swift Java so you see more and

00:07:15,729 --> 00:07:19,210
more of these features in other

00:07:16,900 --> 00:07:23,020
languages so in that sense it is success

00:07:19,210 --> 00:07:24,940
Scala definitely has advanced the state

00:07:23,020 --> 00:07:27,130
of the industry but there's still

00:07:24,940 --> 00:07:31,030
possibilities of derailing the whole

00:07:27,130 --> 00:07:33,370
project and I think the railing could

00:07:31,030 --> 00:07:35,889
happen because you don't see Scala as

00:07:33,370 --> 00:07:39,520
the whole of what it is P but because

00:07:35,889 --> 00:07:42,610
you see it only as one part of it so one

00:07:39,520 --> 00:07:45,789
way to see Scala is to say well it's

00:07:42,610 --> 00:07:49,150
actually just a verse Haskell on the JVM

00:07:45,789 --> 00:07:51,880
and another way to see Scala is to say

00:07:49,150 --> 00:07:53,860
well it's a better Java and if you have

00:07:51,880 --> 00:07:56,169
engineers that from both sides in the

00:07:53,860 --> 00:08:00,220
same team then you are going to live

00:07:56,169 --> 00:08:01,659
some interesting times so I think that's

00:08:00,220 --> 00:08:04,539
the challenge that we're facing right

00:08:01,659 --> 00:08:06,940
now because both of these have use take

00:08:04,539 --> 00:08:10,930
1/2 of Scala features and ignore the

00:08:06,940 --> 00:08:12,639
synthesis so do you escalator I said the

00:08:10,930 --> 00:08:15,520
Haskell part of Scala is something that

00:08:12,639 --> 00:08:18,699
sometimes called means SCADA the worst

00:08:15,520 --> 00:08:20,860
Haskell of the JVM my take on it is I

00:08:18,699 --> 00:08:23,590
really like Haskell Haskell is a great

00:08:20,860 --> 00:08:25,479
language as but it is a language for

00:08:23,590 --> 00:08:28,030
pure functional programming with

00:08:25,479 --> 00:08:30,550
laziness but Scala is actually not that

00:08:28,030 --> 00:08:32,589
great a basis for emulating all of

00:08:30,550 --> 00:08:34,990
Haskell's patterns for instance it's

00:08:32,589 --> 00:08:37,570
strict rather than lazy and yes you can

00:08:34,990 --> 00:08:39,159
get laziness with trampolining and stuff

00:08:37,570 --> 00:08:42,159
like that but it's inefficient it's

00:08:39,159 --> 00:08:44,529
awkward and furthermore if you choose to

00:08:42,159 --> 00:08:46,470
ignore scholars object-oriented parts

00:08:44,529 --> 00:08:48,960
then what's the point of using

00:08:46,470 --> 00:08:51,870
at all why don't you just use Haskell or

00:08:48,960 --> 00:08:54,780
a Haskell clone on the JVM Haskell is a

00:08:51,870 --> 00:08:57,480
great language why not do that better

00:08:54,780 --> 00:08:59,400
Java without SCARA steep parts also has

00:08:57,480 --> 00:09:02,480
been pursued by quite a few languages

00:08:59,400 --> 00:09:05,550
Kotlin for instance or swift or also

00:09:02,480 --> 00:09:07,680
other languages that have is that you

00:09:05,550 --> 00:09:11,580
started out elsewhere moving into that

00:09:07,680 --> 00:09:13,500
same space c-sharp or Java so compared

00:09:11,580 --> 00:09:16,380
to SCADA all of these languages trade

00:09:13,500 --> 00:09:19,710
abstraction and Composition power for

00:09:16,380 --> 00:09:22,680
basically more ad hoc features so where

00:09:19,710 --> 00:09:25,200
Scala has a few but very powerful base

00:09:22,680 --> 00:09:27,990
to abstract people things that means to

00:09:25,200 --> 00:09:30,750
give library designers the power to

00:09:27,990 --> 00:09:33,600
design these abstractions in the library

00:09:30,750 --> 00:09:35,730
compared to that these other languages

00:09:33,600 --> 00:09:37,860
give you more primitive features and

00:09:35,730 --> 00:09:41,700
that can avoid some of the more esoteric

00:09:37,860 --> 00:09:43,860
parts by just making it less pleasant to

00:09:41,700 --> 00:09:46,290
express them since there are no powerful

00:09:43,860 --> 00:09:48,270
abstraction mechanisms you can't get to

00:09:46,290 --> 00:09:51,510
really a good job and this some people

00:09:48,270 --> 00:09:53,820
might argue is a feature and not not a

00:09:51,510 --> 00:09:56,550
default I'm saying some people not me

00:09:53,820 --> 00:09:58,590
necessarily so the other thing

00:09:56,550 --> 00:10:00,600
interesting thing there is that Scala

00:09:58,590 --> 00:10:02,820
has often been criticized too for being

00:10:00,600 --> 00:10:05,160
a huge language so one of the biggest

00:10:02,820 --> 00:10:07,080
languages and that's actually not true

00:10:05,160 --> 00:10:09,510
that's that's the thing that is not

00:10:07,080 --> 00:10:12,600
borne out by the data in books being in

00:10:09,510 --> 00:10:14,850
quite to the contrary these other

00:10:12,600 --> 00:10:17,400
languages they tend to be much larger

00:10:14,850 --> 00:10:19,950
languages but the larger language often

00:10:17,400 --> 00:10:22,830
leads to simpler in the perception

00:10:19,950 --> 00:10:24,930
programs so I actually did some data

00:10:22,830 --> 00:10:27,840
collection and I just counted number of

00:10:24,930 --> 00:10:29,250
lines of syntax so they said gee how

00:10:27,840 --> 00:10:30,900
many features are there a good way to

00:10:29,250 --> 00:10:34,170
measure if you just look at the grammar

00:10:30,900 --> 00:10:38,250
and count lines and then you see

00:10:34,170 --> 00:10:40,050
essentially this graph here where you

00:10:38,250 --> 00:10:42,750
have essentially the middle ground is

00:10:40,050 --> 00:10:46,290
sort of standard industry languages

00:10:42,750 --> 00:10:49,320
Scotland Swift Java 8 when we have C++

00:10:46,290 --> 00:10:51,360
is much larger and c-sharp interestingly

00:10:49,320 --> 00:10:54,660
enough is still larger so in terms of

00:10:51,360 --> 00:10:56,580
features xht sharp takes the crown and

00:10:54,660 --> 00:10:57,820
scala is actually down there sort of

00:10:56,580 --> 00:11:01,390
between Haskell

00:10:57,820 --> 00:11:02,740
and Cortland and Swift and Hasker being

00:11:01,390 --> 00:11:04,780
smaller smaller language since Carla is

00:11:02,740 --> 00:11:08,470
actually also not true in a sense

00:11:04,780 --> 00:11:10,690
because Haskell is what I measured here

00:11:08,470 --> 00:11:13,090
is the Haskell 98 standard which nobody

00:11:10,690 --> 00:11:16,300
ever uses in addition to the Haskell 98

00:11:13,090 --> 00:11:18,300
standards they are literally 85 language

00:11:16,300 --> 00:11:20,890
extensions that each have to be enabled

00:11:18,300 --> 00:11:23,350
by a commandlineoptions and that people

00:11:20,890 --> 00:11:25,120
use regularly so I didn't count these 85

00:11:23,350 --> 00:11:28,150
language extensions in the Haskell bar

00:11:25,120 --> 00:11:30,430
the Python of course is by far the

00:11:28,150 --> 00:11:32,470
smallest Python is a beautifully minimal

00:11:30,430 --> 00:11:34,180
language and of course is also helped by

00:11:32,470 --> 00:11:35,890
the lack of static types because then

00:11:34,180 --> 00:11:38,200
one half of the things you talked about

00:11:35,890 --> 00:11:40,240
has vanished and you don't you don't

00:11:38,200 --> 00:11:42,100
need to spend lines of that and I should

00:11:40,240 --> 00:11:43,930
say that that's Grammer sizing lines but

00:11:42,100 --> 00:11:46,090
if you count key words or by many other

00:11:43,930 --> 00:11:50,370
language measures that it gets held up

00:11:46,090 --> 00:11:53,590
so that's sort of where we are so I

00:11:50,370 --> 00:11:55,930
believe that this approach to fuse

00:11:53,590 --> 00:11:57,790
function programming and object in our

00:11:55,930 --> 00:12:00,370
programming in a modestly large language

00:11:57,790 --> 00:12:02,530
is still the most promising way forward

00:12:00,370 --> 00:12:07,450
for general-purpose software development

00:12:02,530 --> 00:12:09,730
however I think there are over the times

00:12:07,450 --> 00:12:12,580
where we essentially did Scala that

00:12:09,730 --> 00:12:15,640
Sigma came out in 2004 so that makes 14

00:12:12,580 --> 00:12:18,490
years now we've learned quite a bit of

00:12:15,640 --> 00:12:21,520
things that we didn't know when it came

00:12:18,490 --> 00:12:24,310
out including I think we know now how to

00:12:21,520 --> 00:12:27,370
be pure without sacrificing simplicity

00:12:24,310 --> 00:12:29,500
and performance we know we have a much

00:12:27,370 --> 00:12:33,220
better idea how to do safe meta

00:12:29,500 --> 00:12:35,710
programming and also what happened over

00:12:33,220 --> 00:12:38,620
the years was Scala was a language that

00:12:35,710 --> 00:12:40,840
he said she came out to reduce the

00:12:38,620 --> 00:12:43,030
boilerplate in typically Java programs

00:12:40,840 --> 00:12:46,270
so a good example is the case class a

00:12:43,030 --> 00:12:48,760
case class essentially captures in one

00:12:46,270 --> 00:12:50,770
line what you would typically write 20

00:12:48,760 --> 00:12:52,420
or 30 lines with getters and setters and

00:12:50,770 --> 00:12:55,660
equality methods and hashcode and

00:12:52,420 --> 00:12:57,910
whatnot but because of the way

00:12:55,660 --> 00:13:00,730
essentially new programming patterns

00:12:57,910 --> 00:13:03,640
have evolved it's also true that some of

00:13:00,730 --> 00:13:06,580
these patterns have it in codings have

00:13:03,640 --> 00:13:09,070
ways to express them in Scala but they

00:13:06,580 --> 00:13:11,140
are now quite boilerplate these patterns

00:13:09,070 --> 00:13:14,470
didn't even exist 15 years ago but now

00:13:11,140 --> 00:13:16,210
they do exist so we should constantly

00:13:14,470 --> 00:13:17,980
essentially take a step back and say

00:13:16,210 --> 00:13:20,830
well are there better ways to express

00:13:17,980 --> 00:13:24,400
certain common programming patterns now

00:13:20,830 --> 00:13:26,170
so we want to do that as well so the way

00:13:24,400 --> 00:13:28,000
forward then is to incorporate these new

00:13:26,170 --> 00:13:30,370
techniques in the language to make it

00:13:28,000 --> 00:13:34,089
simpler more focused and more pleasant

00:13:30,370 --> 00:13:36,490
to use so what we want to do in

00:13:34,089 --> 00:13:38,020
particular is we want to now that we

00:13:36,490 --> 00:13:41,020
have learned much much better

00:13:38,020 --> 00:13:43,420
essentially what works great and what

00:13:41,020 --> 00:13:45,970
works less great we want to become

00:13:43,420 --> 00:13:47,920
overall more opinionated Scala was one

00:13:45,970 --> 00:13:50,410
of the least opinionated languages out

00:13:47,920 --> 00:13:52,180
there it let you do everything I think

00:13:50,410 --> 00:13:53,950
we were we will not change radically but

00:13:52,180 --> 00:13:57,280
we want to essentially focus more on

00:13:53,950 --> 00:13:59,730
becoming opinionated we want to simplify

00:13:57,280 --> 00:14:02,800
where we can we want to eliminate

00:13:59,730 --> 00:14:05,140
inconsistencies and puzzlers puzzles are

00:14:02,800 --> 00:14:08,680
fun but not if you encounter them in

00:14:05,140 --> 00:14:10,630
your codebase we want to build on strong

00:14:08,680 --> 00:14:12,310
foundations that we have now with

00:14:10,630 --> 00:14:14,740
essentially all the work we did on

00:14:12,310 --> 00:14:16,240
dependent object types and the calculus

00:14:14,740 --> 00:14:19,000
and the soundness proofs and these

00:14:16,240 --> 00:14:21,120
things and we want to consolidate the

00:14:19,000 --> 00:14:23,580
languages constructs to improve

00:14:21,120 --> 00:14:26,530
consistency safety

00:14:23,580 --> 00:14:29,290
ergonomics and performance so let me

00:14:26,530 --> 00:14:32,980
talk about each of them in in one slide

00:14:29,290 --> 00:14:37,240
yourself so consistency what we want to

00:14:32,980 --> 00:14:41,730
do oops that I skipped ahead what did I

00:14:37,240 --> 00:14:41,730
do now sorry

00:14:45,220 --> 00:14:50,680
No okay that's good

00:14:52,089 --> 00:15:03,760
you seem to be in a funny mode here yeah

00:14:58,670 --> 00:15:08,079
now we're back good sorry so consistency

00:15:03,760 --> 00:15:10,519
what we want to do is we want to have

00:15:08,079 --> 00:15:13,760
composable abstractions without bad

00:15:10,519 --> 00:15:16,699
surprises so one particular to start

00:15:13,760 --> 00:15:19,940
with intersection types so Scala has the

00:15:16,699 --> 00:15:23,060
compound type a with B and that is

00:15:19,940 --> 00:15:25,730
pretty good until you learn that a with

00:15:23,060 --> 00:15:29,029
B is actually not the same type as B

00:15:25,730 --> 00:15:31,279
with a as I what intersection should be

00:15:29,029 --> 00:15:33,050
commutative right a B a and B should be

00:15:31,279 --> 00:15:35,360
B and a well now with the intersection

00:15:33,050 --> 00:15:37,339
types it is we still let you write with

00:15:35,360 --> 00:15:39,740
for backwards compatibility but it

00:15:37,339 --> 00:15:41,240
actually means this new thing which in

00:15:39,740 --> 00:15:43,519
the future will be written with this

00:15:41,240 --> 00:15:47,440
ampersand so intersection types are

00:15:43,519 --> 00:15:50,269
essentially something that cleans up a

00:15:47,440 --> 00:15:52,970
problem of compound types that we had

00:15:50,269 --> 00:15:56,540
before you could ask well why why do it

00:15:52,970 --> 00:15:59,240
initially why I have a type which is not

00:15:56,540 --> 00:16:01,820
commutative well the answer was that we

00:15:59,240 --> 00:16:04,010
essentially used with the same base for

00:16:01,820 --> 00:16:06,980
inheritance when we explain a class

00:16:04,010 --> 00:16:08,810
extends things and for the type that

00:16:06,980 --> 00:16:10,790
seemed to be very logical at the time I

00:16:08,810 --> 00:16:13,070
mean why I have two different concepts

00:16:10,790 --> 00:16:15,740
but for inheritance it actually does

00:16:13,070 --> 00:16:18,649
matter in what order you inherit your

00:16:15,740 --> 00:16:21,199
base classes because that that matters

00:16:18,649 --> 00:16:23,329
for essentially who overrides whom so

00:16:21,199 --> 00:16:25,970
the last one in your chain of

00:16:23,329 --> 00:16:28,130
inheritance is the one that's the actual

00:16:25,970 --> 00:16:31,279
member definition in your type so for

00:16:28,130 --> 00:16:33,199
inheritance yes you can't swap the base

00:16:31,279 --> 00:16:35,360
classes when you inherit but for the

00:16:33,199 --> 00:16:36,709
types it has turned out that we need we

00:16:35,360 --> 00:16:37,519
won't really want these algebraic

00:16:36,709 --> 00:16:40,220
properties

00:16:37,519 --> 00:16:41,930
so therefore intersection types now if

00:16:40,220 --> 00:16:44,630
you go from intersection types and you

00:16:41,930 --> 00:16:46,430
take the dual then you arrive at union

00:16:44,630 --> 00:16:49,850
types so that's the other thing that

00:16:46,430 --> 00:16:51,500
we're adding another thing I'm going to

00:16:49,850 --> 00:16:54,290
talk more about that is implicit

00:16:51,500 --> 00:16:55,510
function types but you can argue for

00:16:54,290 --> 00:16:57,730
them in the

00:16:55,510 --> 00:16:59,980
in the context of consistency because

00:16:57,730 --> 00:17:02,889
you say well we have methods that take

00:16:59,980 --> 00:17:04,540
implicit parameters of course so why

00:17:02,889 --> 00:17:07,089
shouldn't we be able to lift that to

00:17:04,540 --> 00:17:08,860
functions so functions should have

00:17:07,089 --> 00:17:10,240
implicit parameters and the type should

00:17:08,860 --> 00:17:11,919
be able to express that

00:17:10,240 --> 00:17:13,720
so that's implicit function types

00:17:11,919 --> 00:17:16,059
dependent function types is the same

00:17:13,720 --> 00:17:18,400
thing we can have methods where the

00:17:16,059 --> 00:17:20,709
result type depends on the parameter

00:17:18,400 --> 00:17:23,260
type so why shouldn't be able to lift

00:17:20,709 --> 00:17:27,490
that two functions and in Scala three

00:17:23,260 --> 00:17:29,679
you can try parameters finally that is

00:17:27,490 --> 00:17:35,320
essentially classes can have parameters

00:17:29,679 --> 00:17:38,530
in parents so why not trades and indeed

00:17:35,320 --> 00:17:40,210
that's what we can do in Scala three the

00:17:38,530 --> 00:17:42,460
answer why we didn't do that initially

00:17:40,210 --> 00:17:44,679
was again a problem that is actually one

00:17:42,460 --> 00:17:46,720
had to find rules for what happens in

00:17:44,679 --> 00:17:48,190
dynamic time and inheritance so

00:17:46,720 --> 00:17:50,260
essentially there's more to it than just

00:17:48,190 --> 00:17:52,090
slapping on a feature and say yeah well

00:17:50,260 --> 00:17:54,309
now you have it you have to do some

00:17:52,090 --> 00:17:57,190
groundwork to make it work but that has

00:17:54,309 --> 00:17:59,020
been done I'm happy to say and as a

00:17:57,190 --> 00:18:01,990
result we can actually drop other

00:17:59,020 --> 00:18:04,000
features like early definitions and

00:18:01,990 --> 00:18:07,000
finally generic tuples

00:18:04,000 --> 00:18:09,850
so we tuples are great the problem is

00:18:07,000 --> 00:18:11,919
they end up end at 22 right so you can't

00:18:09,850 --> 00:18:14,679
have trouble 22 and then you fall off a

00:18:11,919 --> 00:18:17,890
cliff table of 23 is no longer possible

00:18:14,679 --> 00:18:19,570
and of course we could extend that 222

00:18:17,890 --> 00:18:20,830
or whatever but I'm sure there would be

00:18:19,570 --> 00:18:24,220
a program that needs hundred

00:18:20,830 --> 00:18:29,049
twenty-three so isn't it much better to

00:18:24,220 --> 00:18:32,260
say well actually we only have the empty

00:18:29,049 --> 00:18:34,990
typo unit and pair so instead of having

00:18:32,260 --> 00:18:37,000
22 we give you two unit and pair and the

00:18:34,990 --> 00:18:38,350
rest you built from them so here you see

00:18:37,000 --> 00:18:40,900
at the bottom of the slide you see a

00:18:38,350 --> 00:18:44,740
triple so that's just a pair of a pair

00:18:40,900 --> 00:18:47,919
of a pair of C and unit so that's all

00:18:44,740 --> 00:18:49,720
you need to do here and what the other

00:18:47,919 --> 00:18:52,450
advantage of doing it this way is that

00:18:49,720 --> 00:18:54,130
them you can write generic code over it

00:18:52,450 --> 00:18:56,320
you can actually write a concat function

00:18:54,130 --> 00:18:58,600
that it actually takes two tuples and

00:18:56,320 --> 00:19:01,210
con cats them the way you would do in

00:18:58,600 --> 00:19:03,429
today's scala with h lists so that's

00:19:01,210 --> 00:19:05,309
another nice feature that we will have

00:19:03,429 --> 00:19:07,840
in Scala 3

00:19:05,309 --> 00:19:10,029
ergonomics so there I said well there's

00:19:07,840 --> 00:19:11,889
some patterns that he said she have come

00:19:10,029 --> 00:19:14,139
up and you do them all over and over

00:19:11,889 --> 00:19:15,909
again and they would have would married

00:19:14,139 --> 00:19:20,080
essentially a shorter way to express it

00:19:15,909 --> 00:19:23,169
so one of these I guess is algebraic

00:19:20,080 --> 00:19:25,179
data types and case classes so you write

00:19:23,169 --> 00:19:26,830
a base straight and then you write case

00:19:25,179 --> 00:19:29,139
class class class class class and you

00:19:26,830 --> 00:19:31,480
have all these cases and yes I mean it's

00:19:29,139 --> 00:19:33,130
its pleasant it's better than you would

00:19:31,480 --> 00:19:34,710
do with normal classes where you have to

00:19:33,130 --> 00:19:39,159
write all the members but it's still

00:19:34,710 --> 00:19:42,480
longer than let's say an ADT definition

00:19:39,159 --> 00:19:45,129
in a functional language like Haskell or

00:19:42,480 --> 00:19:47,799
quite nowadays quite a lot of other

00:19:45,129 --> 00:19:49,899
languages have acquired these things the

00:19:47,799 --> 00:19:51,309
other problem was the lack of Imams in

00:19:49,899 --> 00:19:53,259
Java in Scala

00:19:51,309 --> 00:19:55,330
where essentially people want to do

00:19:53,259 --> 00:19:57,759
something that can emulate Java enums

00:19:55,330 --> 00:19:59,740
and while you nothing was really ideal

00:19:57,759 --> 00:20:02,700
there was an abstract type and there

00:19:59,740 --> 00:20:05,799
were you could just use them as numbers

00:20:02,700 --> 00:20:07,870
so Imams in it's got a three so of all

00:20:05,799 --> 00:20:10,269
of these so here you have a simple one

00:20:07,870 --> 00:20:13,330
which corresponds to a Java in a color

00:20:10,269 --> 00:20:15,159
with red green blue as cases but you can

00:20:13,330 --> 00:20:16,899
extend that you can give it parameters

00:20:15,159 --> 00:20:20,049
and you can express things like options

00:20:16,899 --> 00:20:23,200
or lists or any other att's there so

00:20:20,049 --> 00:20:27,100
that's a nicer way to put it the second

00:20:23,200 --> 00:20:29,350
one where is type lambdas so you want

00:20:27,100 --> 00:20:30,730
sometimes you know you have higher kind

00:20:29,350 --> 00:20:32,950
of types that take type parameter

00:20:30,730 --> 00:20:35,289
sometimes you want to express the type

00:20:32,950 --> 00:20:38,259
function that takes a type X and gives

00:20:35,289 --> 00:20:40,840
you back some expression where the X

00:20:38,259 --> 00:20:44,860
occurs just you want to express that as

00:20:40,840 --> 00:20:47,259
an unnamed type and so far scarlet

00:20:44,860 --> 00:20:49,990
didn't give it to you except people

00:20:47,259 --> 00:20:51,970
became incredibly ingenious and actually

00:20:49,990 --> 00:20:54,399
used essentially structural types with

00:20:51,970 --> 00:20:56,500
type members and then they added fancy

00:20:54,399 --> 00:20:59,230
unicode's with lambdas to it and then it

00:20:56,500 --> 00:21:01,629
it looked like simple ASCII soup or

00:20:59,230 --> 00:21:02,799
Unicode soup I should say but it did the

00:21:01,629 --> 00:21:05,679
trick

00:21:02,799 --> 00:21:07,750
only in a pretty horrible way so we came

00:21:05,679 --> 00:21:09,580
to dance as well okay if you want them

00:21:07,750 --> 00:21:12,100
so much we should give you proper

00:21:09,580 --> 00:21:13,179
surface syntax and that's what it's

00:21:12,100 --> 00:21:15,460
gonna be

00:21:13,179 --> 00:21:21,190
it's it's a type lambda from extra

00:21:15,460 --> 00:21:25,179
suffix safety so some important

00:21:21,190 --> 00:21:28,739
improvement in safety are multiversal

00:21:25,179 --> 00:21:31,659
equality so that's who here has ever

00:21:28,739 --> 00:21:33,599
refactored a large scholar code page by

00:21:31,659 --> 00:21:37,659
changing one type to another

00:21:33,599 --> 00:21:40,629
not so many ok quite a few yeah so one

00:21:37,659 --> 00:21:42,549
of the issues that I noted is I can

00:21:40,629 --> 00:21:44,499
usually do that in full confidence

00:21:42,549 --> 00:21:46,359
because well I have stronger strongly

00:21:44,499 --> 00:21:48,279
type system I don't use any or things

00:21:46,359 --> 00:21:50,169
like that right and so I just change the

00:21:48,279 --> 00:21:52,089
type and then I look at all the compile

00:21:50,169 --> 00:21:54,219
errors and I just fix them all and at

00:21:52,089 --> 00:21:56,830
the end the program should run except

00:21:54,219 --> 00:21:59,950
for equality because if I write equals

00:21:56,830 --> 00:22:02,229
equals like list of a equals equals B

00:21:59,950 --> 00:22:04,330
then the compiler will not tell me

00:22:02,229 --> 00:22:07,119
that's an error it will just say well I

00:22:04,330 --> 00:22:08,859
conveniently always give you to false so

00:22:07,119 --> 00:22:10,899
if you change the type of something and

00:22:08,859 --> 00:22:13,389
B previously there was an equality that

00:22:10,899 --> 00:22:15,460
makes sense then it could be that that

00:22:13,389 --> 00:22:17,889
program will tell just type check but it

00:22:15,460 --> 00:22:19,719
will just give you something basically

00:22:17,889 --> 00:22:21,940
always Falls are always true or whatever

00:22:19,719 --> 00:22:25,719
which is not what you want so that for

00:22:21,940 --> 00:22:28,479
me was really the in the last big

00:22:25,719 --> 00:22:30,519
refactoring that I did that for me was

00:22:28,479 --> 00:22:32,259
actually a reason for a long time not to

00:22:30,519 --> 00:22:33,639
do it because I said I'm just too scared

00:22:32,259 --> 00:22:35,349
of these things I don't want to touch it

00:22:33,639 --> 00:22:38,589
there could be too many things where

00:22:35,349 --> 00:22:40,690
these equalities kick em until I had

00:22:38,589 --> 00:22:43,659
multiversal equality because multiversal

00:22:40,690 --> 00:22:46,210
equality actually let gives you a opt in

00:22:43,659 --> 00:22:48,999
way to actually disallow these things so

00:22:46,210 --> 00:22:50,769
it's actually you can define a type

00:22:48,999 --> 00:22:53,440
class sort of type class where you say

00:22:50,769 --> 00:22:55,210
you still have the normal equals equal

00:22:53,440 --> 00:22:58,059
so you don't need a fancy new operator

00:22:55,210 --> 00:23:00,190
but you say you should this should type

00:22:58,059 --> 00:23:03,369
check only if you have some evidence

00:23:00,190 --> 00:23:05,769
that checking these types that comparing

00:23:03,369 --> 00:23:08,139
these types make sense

00:23:05,769 --> 00:23:10,269
the second big safety improvement I

00:23:08,139 --> 00:23:12,190
believe is that we're going to severely

00:23:10,269 --> 00:23:14,229
restrict implicit conversions I'm going

00:23:12,190 --> 00:23:14,909
to talk about more about that in a

00:23:14,229 --> 00:23:17,529
second

00:23:14,909 --> 00:23:21,009
finally not yet done but also planned

00:23:17,529 --> 00:23:22,960
our null safety so that's essentially a

00:23:21,009 --> 00:23:25,599
great application of these union types I

00:23:22,960 --> 00:23:26,350
was talking about because once you have

00:23:25,599 --> 00:23:29,260
the Union tie

00:23:26,350 --> 00:23:31,809
you can actually define that let's say

00:23:29,260 --> 00:23:33,820
the type string should be just the type

00:23:31,809 --> 00:23:36,850
string and not now which is as we all

00:23:33,820 --> 00:23:38,830
know is the right thing to do it's is

00:23:36,850 --> 00:23:40,570
what's called this billion dollar

00:23:38,830 --> 00:23:42,730
mistake that is actually every type

00:23:40,570 --> 00:23:45,120
comes with an analyzer as a value of the

00:23:42,730 --> 00:23:47,289
type so we want to stop doing that and

00:23:45,120 --> 00:23:50,010
union types give you a great way of

00:23:47,289 --> 00:23:52,210
saying well if you want string and

00:23:50,010 --> 00:23:53,980
possibly now then you just write the

00:23:52,210 --> 00:23:56,799
Union type do you say well this is a

00:23:53,980 --> 00:23:58,990
string or it is not how much clearer can

00:23:56,799 --> 00:24:01,409
it get and finally we have a thing

00:23:58,990 --> 00:24:04,059
called effect capabilities which is

00:24:01,409 --> 00:24:07,179
planned but probably not on the roadmap

00:24:04,059 --> 00:24:08,080
four-30 i think that that's that train

00:24:07,179 --> 00:24:10,630
has already left

00:24:08,080 --> 00:24:13,030
that would give will will give us a

00:24:10,630 --> 00:24:15,370
really nice way to express purity

00:24:13,030 --> 00:24:17,710
without having to go to monads seminars

00:24:15,370 --> 00:24:19,659
transformers so essentially you can say

00:24:17,710 --> 00:24:22,720
you can talk about the effects that your

00:24:19,659 --> 00:24:24,700
program has as essentially by talking

00:24:22,720 --> 00:24:26,890
about capabilities that you say well

00:24:24,700 --> 00:24:29,289
actually instead of saying my program

00:24:26,890 --> 00:24:31,570
can throw an exception I need I need the

00:24:29,289 --> 00:24:33,780
capability to throw an exception and I

00:24:31,570 --> 00:24:37,120
get that as an implicit parameter

00:24:33,780 --> 00:24:39,400
typically an implicit function type so I

00:24:37,120 --> 00:24:42,340
can only give you a very very quick run

00:24:39,400 --> 00:24:44,799
around really of these things but you

00:24:42,340 --> 00:24:46,870
can read them up on the dottie website

00:24:44,799 --> 00:24:48,610
each one of these has a page and there's

00:24:46,870 --> 00:24:53,080
also some rational how they hang

00:24:48,610 --> 00:24:54,789
together finally performance so two

00:24:53,080 --> 00:24:58,539
things that I believe matter for

00:24:54,789 --> 00:25:02,429
performance are opaque types and erase

00:24:58,539 --> 00:25:05,169
parameters so opaque types the

00:25:02,429 --> 00:25:07,000
motivation behind your paid types is we

00:25:05,169 --> 00:25:09,820
want to be able to express type

00:25:07,000 --> 00:25:12,309
abstraction so basically create a new

00:25:09,820 --> 00:25:16,150
type that is the same as this other type

00:25:12,309 --> 00:25:18,309
but it is implemented sorry as here we

00:25:16,150 --> 00:25:21,789
have a Type A and it's implemented as a

00:25:18,309 --> 00:25:24,669
type B but you want to treat them as

00:25:21,789 --> 00:25:27,130
completely distinct types in the type

00:25:24,669 --> 00:25:29,320
check program for safety for instance

00:25:27,130 --> 00:25:32,679
you might have currencies you might have

00:25:29,320 --> 00:25:35,559
this thing a dollar is a big big decimal

00:25:32,679 --> 00:25:38,530
and a euro is a big decimal but never

00:25:35,559 --> 00:25:39,760
ever try to essentially add euros to

00:25:38,530 --> 00:25:41,410
dollars or things like that

00:25:39,760 --> 00:25:43,980
so they should be completely completely

00:25:41,410 --> 00:25:46,300
separate and opaque types give you that

00:25:43,980 --> 00:25:48,550
previously we had value classes where

00:25:46,300 --> 00:25:51,100
you could do that also but there was a

00:25:48,550 --> 00:25:52,540
little glitch with value classes well

00:25:51,100 --> 00:25:54,670
I'm not saying glitch it's more a

00:25:52,540 --> 00:25:56,920
feature that's built in in the way valid

00:25:54,670 --> 00:25:59,140
classes are built and that is that we

00:25:56,920 --> 00:26:02,140
couldn't guarantee you that there will

00:25:59,140 --> 00:26:04,720
never ever be boxing so with value class

00:26:02,140 --> 00:26:06,880
in most cases when you have a value

00:26:04,720 --> 00:26:09,370
class it will just be represented as the

00:26:06,880 --> 00:26:13,000
underlying type so if I write value

00:26:09,370 --> 00:26:15,640
class dollar wraps big big decimal then

00:26:13,000 --> 00:26:18,940
a dollar would be represented as a big

00:26:15,640 --> 00:26:20,920
decimal but sometimes we've basically

00:26:18,940 --> 00:26:23,200
always when you push to put that into

00:26:20,920 --> 00:26:24,850
generic context that wouldn't be the

00:26:23,200 --> 00:26:26,590
case anymore and would be boxed so you

00:26:24,850 --> 00:26:29,170
would create an additional object and

00:26:26,590 --> 00:26:30,910
for I mean if your underlying type is

00:26:29,170 --> 00:26:32,830
big decimal probably that doesn't really

00:26:30,910 --> 00:26:34,690
matter that's in the noise but for

00:26:32,830 --> 00:26:36,310
high-performance applications where you

00:26:34,690 --> 00:26:38,680
essentially want to wrap just a small

00:26:36,310 --> 00:26:41,260
primitive type it can matter so value

00:26:38,680 --> 00:26:43,060
classes have a have an opaque boxing

00:26:41,260 --> 00:26:43,450
model it's very difficult to understand

00:26:43,060 --> 00:26:45,760
that

00:26:43,450 --> 00:26:48,460
whereas opaque tights have a very clear

00:26:45,760 --> 00:26:50,800
boxing model the answer is simply there

00:26:48,460 --> 00:26:53,530
is no boxing ever so there will never be

00:26:50,800 --> 00:26:56,020
any boxing and for that in order to get

00:26:53,530 --> 00:26:58,270
at some restrictions compared to valid

00:26:56,020 --> 00:27:00,820
classes in particular that you cannot

00:26:58,270 --> 00:27:03,400
really fine object types so to string on

00:27:00,820 --> 00:27:08,970
a opaque type cannot be redefined nor

00:27:03,400 --> 00:27:11,830
can equality the second new abstraction

00:27:08,970 --> 00:27:15,100
performance improvement are erased

00:27:11,830 --> 00:27:18,400
parameters so people probably have seen

00:27:15,100 --> 00:27:20,590
already implicit types like a equals :

00:27:18,400 --> 00:27:22,510
equals B MIT for instance in there in

00:27:20,590 --> 00:27:24,790
the flatten method in the collections

00:27:22,510 --> 00:27:27,550
library they use these things so these

00:27:24,790 --> 00:27:30,880
are essentially tricks to convince the

00:27:27,550 --> 00:27:32,980
type inference that certain constraints

00:27:30,880 --> 00:27:36,010
are true so essentially the a equals

00:27:32,980 --> 00:27:38,350
currently equals big thing says well and

00:27:36,010 --> 00:27:41,290
by the way I know or I need to get

00:27:38,350 --> 00:27:43,690
evidence that a equals column B is true

00:27:41,290 --> 00:27:45,580
so the compiler will do that by doing an

00:27:43,690 --> 00:27:48,610
implicit search and finding essentially

00:27:45,580 --> 00:27:50,680
an instance of a or a column equal B

00:27:48,610 --> 00:27:52,270
that that makes that that makes them the

00:27:50,680 --> 00:27:54,840
same

00:27:52,270 --> 00:27:58,480
the problem of the thing with these

00:27:54,840 --> 00:28:00,430
parameters is once for a lot of them

00:27:58,480 --> 00:28:02,230
once you have convinced that the type

00:28:00,430 --> 00:28:03,670
checker that all is in order

00:28:02,230 --> 00:28:06,520
you don't really meet them at runtime

00:28:03,670 --> 00:28:09,190
anymore so these are a cheat way we're

00:28:06,520 --> 00:28:10,810
just ways to essentially communicate

00:28:09,190 --> 00:28:12,520
types to the type checker so there

00:28:10,810 --> 00:28:14,800
should be a way to tell the same

00:28:12,520 --> 00:28:16,540
compiler to say and by the way don't

00:28:14,800 --> 00:28:18,820
bother generating code for these things

00:28:16,540 --> 00:28:20,290
and that's what he raised us so I

00:28:18,820 --> 00:28:25,330
believe with the arrays we can

00:28:20,290 --> 00:28:28,350
essentially get a lot more performance

00:28:25,330 --> 00:28:30,850
for essentially these essentially heavy

00:28:28,350 --> 00:28:34,630
implicit on the type level the other

00:28:30,850 --> 00:28:36,610
advantage is that the erased term that

00:28:34,630 --> 00:28:38,620
gets generated will be actually thrown

00:28:36,610 --> 00:28:41,590
out very quickly in the compiler

00:28:38,620 --> 00:28:43,930
pipeline without having been needing to

00:28:41,590 --> 00:28:46,660
be transformed and retype checked and so

00:28:43,930 --> 00:28:49,930
on so that also should gain you a an

00:28:46,660 --> 00:28:51,250
increase in compiler performance so

00:28:49,930 --> 00:28:54,550
these are some of the things that got

00:28:51,250 --> 00:28:58,150
added what got removed it's quite a long

00:28:54,550 --> 00:29:01,180
list so first thing that got removed was

00:28:58,150 --> 00:29:03,160
existential types using for some so for

00:29:01,180 --> 00:29:05,170
some is gun wildcard types so

00:29:03,160 --> 00:29:07,630
essentially if you have an underscore in

00:29:05,170 --> 00:29:12,100
a parameter list that's still there and

00:29:07,630 --> 00:29:14,110
will remain there some syntactic thing

00:29:12,100 --> 00:29:15,460
like procedure syntax is gone I think

00:29:14,110 --> 00:29:19,000
it's already DEP is it already

00:29:15,460 --> 00:29:21,010
deprecated yeah already deprecated early

00:29:19,000 --> 00:29:25,690
initializes who knows what an early

00:29:21,010 --> 00:29:27,460
initializer is okay not not enough

00:29:25,690 --> 00:29:31,320
people to actually who likes in the

00:29:27,460 --> 00:29:35,050
early initializes okay good yeah so tag

00:29:31,320 --> 00:29:36,820
good leg are so so early initializes

00:29:35,050 --> 00:29:38,620
will be eliminated and we can because

00:29:36,820 --> 00:29:41,260
essentially the use case of early

00:29:38,620 --> 00:29:43,990
initializers was passing some sort of

00:29:41,260 --> 00:29:46,780
parameters to traits and that's we have

00:29:43,990 --> 00:29:50,470
that now directly xml literals are

00:29:46,780 --> 00:29:53,260
pushed in a library limit 22 as i told

00:29:50,470 --> 00:29:55,060
you for the tuples we can remove them

00:29:53,260 --> 00:29:57,610
and we don't need them for their

00:29:55,060 --> 00:29:59,679
functions and products either so there

00:29:57,610 --> 00:30:04,999
will be no no longer anything that has a

00:29:59,679 --> 00:30:07,329
limit 22 automatic parents insertion

00:30:04,999 --> 00:30:10,549
that means that essentially you have a

00:30:07,329 --> 00:30:12,499
function that takes a parameter open

00:30:10,549 --> 00:30:14,569
parens closed parens and you just call

00:30:12,499 --> 00:30:16,699
it without passing the parameter so far

00:30:14,569 --> 00:30:19,759
that was allowed in the future it won't

00:30:16,699 --> 00:30:22,249
be anymore the reason for inserting this

00:30:19,759 --> 00:30:24,679
thing in the first place was there are

00:30:22,249 --> 00:30:27,319
certain things that come from Java where

00:30:24,679 --> 00:30:29,869
it would just be too awkward to pass

00:30:27,319 --> 00:30:32,329
these things so think of lengths of a

00:30:29,869 --> 00:30:34,909
string string dot length would be just

00:30:32,329 --> 00:30:36,919
really ugly to pass open parens closed

00:30:34,909 --> 00:30:38,719
parens because in Scala of course we

00:30:36,919 --> 00:30:40,789
have a choice for it we would never put

00:30:38,719 --> 00:30:43,759
lengths make lengths a function that

00:30:40,789 --> 00:30:45,799
takes takes parameters so we now

00:30:43,759 --> 00:30:48,289
restrict the thing that essentially we

00:30:45,799 --> 00:30:49,999
still insert the open parens closed

00:30:48,289 --> 00:30:51,889
parens but only for Java functions

00:30:49,999 --> 00:30:54,379
because in Java you can't express them

00:30:51,889 --> 00:30:58,579
in any other way but if on the scholar

00:30:54,379 --> 00:31:00,919
side we we demand that it is it you're

00:30:58,579 --> 00:31:05,299
consistent between definitions and texts

00:31:00,919 --> 00:31:10,909
and calls syntax we big conformance that

00:31:05,299 --> 00:31:13,369
was essentially of a thing with incent

00:31:10,909 --> 00:31:15,979
floats and and n numbers it's not

00:31:13,369 --> 00:31:18,679
doesn't matter mat much auto toppling

00:31:15,979 --> 00:31:20,149
and multi parameter in fixed operations

00:31:18,679 --> 00:31:24,649
so they essentially there are a lot of

00:31:20,149 --> 00:31:26,929
things that sort of are okay but you can

00:31:24,649 --> 00:31:29,029
work around them and give you it and she

00:31:26,929 --> 00:31:33,799
too often surprises for what they are

00:31:29,029 --> 00:31:37,509
with okay so the biggest improvements I

00:31:33,799 --> 00:31:40,099
think we can expect in the implicit so

00:31:37,509 --> 00:31:45,049
implicit turned out where Scala

00:31:40,099 --> 00:31:47,509
innovated most and I believe in if you

00:31:45,049 --> 00:31:49,159
if we look at the actual use cases and

00:31:47,509 --> 00:31:51,349
they are both a blessing and a curse

00:31:49,159 --> 00:31:53,329
they are blessing or they're definitely

00:31:51,349 --> 00:31:55,309
very important in the sense that it's

00:31:53,329 --> 00:31:57,909
hard to find a code base that doesn't

00:31:55,309 --> 00:32:01,969
use implicit in one way or another so

00:31:57,909 --> 00:32:04,359
obviously used a lot but also I mean

00:32:01,969 --> 00:32:07,789
some it's fair to say that they are also

00:32:04,359 --> 00:32:09,529
usages of them that are doubtful so the

00:32:07,789 --> 00:32:12,679
goal for scaler three is to have fewer

00:32:09,529 --> 00:32:16,099
curses good code has fewer fewer curses

00:32:12,679 --> 00:32:17,460
than bad code and we have made good

00:32:16,099 --> 00:32:19,980
progress on that

00:32:17,460 --> 00:32:21,960
on post the compiler site and also

00:32:19,980 --> 00:32:24,529
understanding the theory of that so

00:32:21,960 --> 00:32:27,090
there's a paper and a talk at poplar

00:32:24,529 --> 00:32:29,460
2018 that's sort of the programming

00:32:27,090 --> 00:32:32,309
language researchers conference where I

00:32:29,460 --> 00:32:34,110
talk about simplicity which is

00:32:32,309 --> 00:32:36,360
essentially that a new approach to

00:32:34,110 --> 00:32:38,820
implicit both from a programmers

00:32:36,360 --> 00:32:44,100
perspective and theoreticians

00:32:38,820 --> 00:32:48,179
perspective and one big change that we

00:32:44,100 --> 00:32:50,610
want to introduce is that so far if you

00:32:48,179 --> 00:32:52,649
look at common use cases then implicit

00:32:50,610 --> 00:32:55,110
are used as conversions and there's

00:32:52,649 --> 00:32:57,450
parameters and you find a lot of uses of

00:32:55,110 --> 00:33:00,330
conversions and also a lot of uses of

00:32:57,450 --> 00:33:02,700
parameters and it turns out that I guess

00:33:00,330 --> 00:33:05,309
more uses of conversions are dubious

00:33:02,700 --> 00:33:07,770
than parameters so conversions or when

00:33:05,309 --> 00:33:10,200
overviews overused are almost always

00:33:07,770 --> 00:33:12,630
dubious so what we want to get to in the

00:33:10,200 --> 00:33:15,720
future that we will have many way fewer

00:33:12,630 --> 00:33:18,870
conversions and implicit parameters will

00:33:15,720 --> 00:33:22,289
be as important as they are now and more

00:33:18,870 --> 00:33:24,270
pleasant to use to boot so how are we

00:33:22,289 --> 00:33:26,880
going to try to cut down and implicit

00:33:24,270 --> 00:33:29,580
conversions well the first one is that

00:33:26,880 --> 00:33:32,520
some of the good uses of implicit

00:33:29,580 --> 00:33:34,710
conversions will have their own special

00:33:32,520 --> 00:33:35,010
syntax so the most important one you see

00:33:34,710 --> 00:33:39,510
here

00:33:35,010 --> 00:33:41,549
that's extension classes so one use use

00:33:39,510 --> 00:33:43,500
case of implicit conversions was to do

00:33:41,549 --> 00:33:45,029
something called extension methods that

00:33:43,500 --> 00:33:46,740
I said well let's say I have a class

00:33:45,029 --> 00:33:49,169
circle and I want to define a

00:33:46,740 --> 00:33:50,850
circumference method on circles but I

00:33:49,169 --> 00:33:52,620
don't want to put it in the class maybe

00:33:50,850 --> 00:33:54,929
I haven't defined the class I got that

00:33:52,620 --> 00:33:57,270
from somebody else but I still want to

00:33:54,929 --> 00:34:00,210
write circle dot circumference so it

00:33:57,270 --> 00:34:02,399
should be a method and the way we do

00:34:00,210 --> 00:34:04,950
this now is at the bottom of the slide

00:34:02,399 --> 00:34:06,450
so you would do an implicit class circle

00:34:04,950 --> 00:34:08,849
ops and it takes a circle and for

00:34:06,450 --> 00:34:11,070
performance it extends an eval and there

00:34:08,849 --> 00:34:13,109
you have the circumference thing it's

00:34:11,070 --> 00:34:16,020
okay but I

00:34:13,109 --> 00:34:18,450
I guess even if you write these things a

00:34:16,020 --> 00:34:20,520
lot then it doesn't look pretty

00:34:18,450 --> 00:34:22,919
if you don't get used to it it feels

00:34:20,520 --> 00:34:24,990
like clunky to do to do it that way and

00:34:22,919 --> 00:34:26,639
if you don't write these things a lot

00:34:24,990 --> 00:34:28,800
and I'm sure that a lot of people are

00:34:26,639 --> 00:34:30,560
mystified what this implicit class is

00:34:28,800 --> 00:34:32,240
and the other thing

00:34:30,560 --> 00:34:34,310
the class of course is itself an

00:34:32,240 --> 00:34:36,679
abbreviation because it's a normal class

00:34:34,310 --> 00:34:40,610
and an implicit conversion that map's

00:34:36,679 --> 00:34:43,909
circles into circle ups so the pipe i

00:34:40,610 --> 00:34:45,679
contrast the the top operation is I

00:34:43,909 --> 00:34:48,200
believe much clearer we say we have an

00:34:45,679 --> 00:34:50,659
extension circle ops it's for circles or

00:34:48,200 --> 00:34:53,630
circle it's a extended thing and then we

00:34:50,659 --> 00:34:56,060
just write the circumference directly so

00:34:53,630 --> 00:34:58,220
that cuts down on a lot of sort of the

00:34:56,060 --> 00:35:00,140
good use cases of implicit conversions

00:34:58,220 --> 00:35:02,930
what about the others

00:35:00,140 --> 00:35:05,740
so the others for the others we are

00:35:02,930 --> 00:35:08,780
going to be quite a bit stricter in

00:35:05,740 --> 00:35:11,810
essentially when you get a warning about

00:35:08,780 --> 00:35:14,480
them so here you have a particularly

00:35:11,810 --> 00:35:16,220
dubious implicit conversion somebody had

00:35:14,480 --> 00:35:17,750
the bright idea to say well we can

00:35:16,220 --> 00:35:20,060
convert every string to an end by

00:35:17,750 --> 00:35:22,630
parsing the string right maybe who wrote

00:35:20,060 --> 00:35:25,580
this a thing like that from you admit I

00:35:22,630 --> 00:35:28,520
guess it a lot of people did it for fun

00:35:25,580 --> 00:35:30,410
but I guess it most of us know better

00:35:28,520 --> 00:35:33,380
than to put things like that in

00:35:30,410 --> 00:35:35,720
production still it happens so what the

00:35:33,380 --> 00:35:37,790
language currently does to sort of warn

00:35:35,720 --> 00:35:39,500
you about this is if you define an

00:35:37,790 --> 00:35:41,960
implicit conversion like that you have

00:35:39,500 --> 00:35:44,720
to import the feature import language

00:35:41,960 --> 00:35:46,400
dot implicit conversions except if you

00:35:44,720 --> 00:35:48,260
use IntelliJ then intelligent that's it

00:35:46,400 --> 00:35:50,180
for you which i think is terrible so

00:35:48,260 --> 00:35:53,120
future imports should now should never

00:35:50,180 --> 00:35:55,550
be Auto imported but whatever so you

00:35:53,120 --> 00:35:57,320
have to write this only that's not good

00:35:55,550 --> 00:35:59,210
enough because it doesn't protect you

00:35:57,320 --> 00:36:01,160
from a bright colleague who says well I

00:35:59,210 --> 00:36:03,410
found this wonderful thing and I put it

00:36:01,160 --> 00:36:06,470
in a module and sure I import this

00:36:03,410 --> 00:36:08,860
language import or whatever but then I

00:36:06,470 --> 00:36:11,300
present this implicit conversion to you

00:36:08,860 --> 00:36:12,920
maybe in some hidden way it could be

00:36:11,300 --> 00:36:14,510
hidden somewhere and suddenly you get

00:36:12,920 --> 00:36:17,330
this and your thing it the next thing

00:36:14,510 --> 00:36:19,880
you notice is that what should be a type

00:36:17,330 --> 00:36:22,250
error actually the conversion kicks in

00:36:19,880 --> 00:36:24,680
and it's happy to take one to string one

00:36:22,250 --> 00:36:26,780
two three to be in it so what will

00:36:24,680 --> 00:36:29,210
happen in the future is that if the

00:36:26,780 --> 00:36:31,310
compiler actually inserts an implicit

00:36:29,210 --> 00:36:33,110
conversion like that it will also

00:36:31,310 --> 00:36:34,790
require from you that you have the

00:36:33,110 --> 00:36:36,440
language import so it will warn you and

00:36:34,790 --> 00:36:38,600
say well I'm inserting an implicit

00:36:36,440 --> 00:36:41,540
conversion here are you sure about that

00:36:38,600 --> 00:36:43,260
and the way you tell the compiler to -

00:36:41,540 --> 00:36:45,960
to be sure about that you import

00:36:43,260 --> 00:36:50,190
language import the language feature

00:36:45,960 --> 00:36:53,760
which is basically a way of stating that

00:36:50,190 --> 00:36:55,710
look I'm gonna I'm accepting in my

00:36:53,760 --> 00:36:57,870
program I'm gonna do some things which

00:36:55,710 --> 00:36:59,790
would could be very very hard to track

00:36:57,870 --> 00:37:02,690
so that you have at least this marker at

00:36:59,790 --> 00:37:06,210
the top of the file that tells you that

00:37:02,690 --> 00:37:07,980
okay so there's one exemption which is

00:37:06,210 --> 00:37:10,260
basically the implicit conversions that

00:37:07,980 --> 00:37:12,330
I used like these implicit classes or in

00:37:10,260 --> 00:37:14,430
the future extension methods so that are

00:37:12,330 --> 00:37:16,470
codified with their target type they

00:37:14,430 --> 00:37:18,330
turn out to be just too common and too

00:37:16,470 --> 00:37:20,580
useful so they exempted from these

00:37:18,330 --> 00:37:24,990
things but all others for all others you

00:37:20,580 --> 00:37:26,880
have to use the language import okay

00:37:24,990 --> 00:37:28,380
so that was cutting down and replaceable

00:37:26,880 --> 00:37:30,570
conversions what about the implicit

00:37:28,380 --> 00:37:32,730
parameters can we make them more useful

00:37:30,570 --> 00:37:35,760
and I believe yes there are certain

00:37:32,730 --> 00:37:40,320
things that it definitely can do the

00:37:35,760 --> 00:37:42,600
first thing is so far we could only have

00:37:40,320 --> 00:37:45,240
an implicit parameter class at the end

00:37:42,600 --> 00:37:47,700
you should have B should must be the

00:37:45,240 --> 00:37:50,100
last one and that's kind of a limitation

00:37:47,700 --> 00:37:52,410
so you want to maybe have several of

00:37:50,100 --> 00:37:54,600
them and maybe you want to have one

00:37:52,410 --> 00:37:56,490
implicit clause at the start and then

00:37:54,600 --> 00:37:58,830
something else and then another one at

00:37:56,490 --> 00:38:00,960
the end you could say why what's what's

00:37:58,830 --> 00:38:03,770
the point of that why can't I put

00:38:00,960 --> 00:38:06,660
parameters at the end well the answer is

00:38:03,770 --> 00:38:08,850
for if you want to have dependencies so

00:38:06,660 --> 00:38:13,200
the X at the start here could actually

00:38:08,850 --> 00:38:15,720
be a prefix of a type like X dot type

00:38:13,200 --> 00:38:18,330
element for a second parameter type and

00:38:15,720 --> 00:38:20,460
that works of course with parameter with

00:38:18,330 --> 00:38:21,990
dependent functions in Scala but it

00:38:20,460 --> 00:38:23,670
doesn't work with implicit because you

00:38:21,990 --> 00:38:25,830
can't write make the first one and

00:38:23,670 --> 00:38:30,030
implicit so it turned out that for more

00:38:25,830 --> 00:38:31,680
advanced uses this was awkward so the it

00:38:30,030 --> 00:38:33,030
would be nice if we could generalize

00:38:31,680 --> 00:38:35,010
that and say you could have several

00:38:33,030 --> 00:38:38,400
implicit parameter classes so that's

00:38:35,010 --> 00:38:40,460
number one but if you do that then

00:38:38,400 --> 00:38:44,130
actually you will introduce an ambiguity

00:38:40,460 --> 00:38:48,810
by saying well okay we have this this

00:38:44,130 --> 00:38:51,930
thing here so if we cut if we now call F

00:38:48,810 --> 00:38:54,980
and we call Givet let's say an explicit

00:38:51,930 --> 00:38:57,079
a do we mean that one here

00:38:54,980 --> 00:38:59,329
or do we mean the second one here the

00:38:57,079 --> 00:39:01,430
compiler cannot really know right so it

00:38:59,329 --> 00:39:04,339
could be the implicit parameter clause

00:39:01,430 --> 00:39:06,800
or the one following it and to

00:39:04,339 --> 00:39:09,829
essentially make up for that there will

00:39:06,800 --> 00:39:12,740
be a syntax to essentially explicitly

00:39:09,829 --> 00:39:14,750
now demand the implicit parameter clause

00:39:12,740 --> 00:39:17,300
so you have this explicitly thing here

00:39:14,750 --> 00:39:19,430
which says yes don't skip B ie don't

00:39:17,300 --> 00:39:24,530
invent an implicit parameter for the a

00:39:19,430 --> 00:39:26,510
the a is coming right here and that

00:39:24,530 --> 00:39:28,940
actually helps in a lot of cases even

00:39:26,510 --> 00:39:30,140
now because even though you can't write

00:39:28,940 --> 00:39:32,660
in please several implicit parameter

00:39:30,140 --> 00:39:34,820
lists you can sort of do that with apply

00:39:32,660 --> 00:39:36,980
methods and things like that and yes the

00:39:34,820 --> 00:39:39,950
compiler sort of gets confused the same

00:39:36,980 --> 00:39:42,320
way so that sometimes you have to write

00:39:39,950 --> 00:39:44,060
it late let's say an explicit dot apply

00:39:42,320 --> 00:39:45,650
because otherwise your parameter gets

00:39:44,060 --> 00:39:50,420
matched with the wrong thing and so on

00:39:45,650 --> 00:39:51,770
okay and the last one and I for me

00:39:50,420 --> 00:39:54,589
actually the biggest one even though it

00:39:51,770 --> 00:39:56,869
looks very very simple is implicit

00:39:54,589 --> 00:39:58,490
function types so implicit function

00:39:56,869 --> 00:40:01,220
types just say well now this implicit

00:39:58,490 --> 00:40:03,140
parameter idea we can lift it into the

00:40:01,220 --> 00:40:05,300
type level and I have already talked

00:40:03,140 --> 00:40:07,819
about that at last year's Garrity's at

00:40:05,300 --> 00:40:10,250
length about that and also at Popple so

00:40:07,819 --> 00:40:12,710
I won't do this here anymore so look at

00:40:10,250 --> 00:40:14,480
the talks to see what about the

00:40:12,710 --> 00:40:18,619
wonderful things you can do with them

00:40:14,480 --> 00:40:21,440
but in to put it in a nutshell implicit

00:40:18,619 --> 00:40:23,930
function types essentially give you in

00:40:21,440 --> 00:40:26,510
in the end there I think the key to get

00:40:23,930 --> 00:40:29,329
purity without sacrificing implicit

00:40:26,510 --> 00:40:31,849
simplicity and performance they give you

00:40:29,329 --> 00:40:34,220
essentially what you would have now with

00:40:31,849 --> 00:40:37,040
complicated in cumbersome monad stacks

00:40:34,220 --> 00:40:39,230
and mono transformers and all all the

00:40:37,040 --> 00:40:40,849
baggage that comes with it you can get

00:40:39,230 --> 00:40:42,560
with implicit function types and not

00:40:40,849 --> 00:40:44,089
have to do anything because they

00:40:42,560 --> 00:40:46,730
essentially compose

00:40:44,089 --> 00:40:48,800
naturally and unlike monads which is

00:40:46,730 --> 00:40:53,240
actually you have to do these manual

00:40:48,800 --> 00:40:55,579
transformations okay so that's the

00:40:53,240 --> 00:41:00,099
language part what about the tooling so

00:40:55,579 --> 00:41:02,450
so far we have a new compiler dot see

00:41:00,099 --> 00:41:04,400
that the name comes essentially from

00:41:02,450 --> 00:41:06,020
this dot calculus which was so

00:41:04,400 --> 00:41:08,310
essentially the theoretical foundation

00:41:06,020 --> 00:41:11,190
of what we've done we have

00:41:08,310 --> 00:41:13,980
pretty good IDE support using the

00:41:11,190 --> 00:41:16,320
language server protocol and in the

00:41:13,980 --> 00:41:19,200
future also the recently announced build

00:41:16,320 --> 00:41:21,270
server protocol and that has direct

00:41:19,200 --> 00:41:24,000
support for vs code so there will be a

00:41:21,270 --> 00:41:25,560
talk by Google matters later in the

00:41:24,000 --> 00:41:28,050
conference where he will essentially

00:41:25,560 --> 00:41:29,520
tell you what the latest status and show

00:41:28,050 --> 00:41:32,040
you essentially what what we currently

00:41:29,520 --> 00:41:35,520
have and what's in in there for the

00:41:32,040 --> 00:41:39,360
future there's a wrapper and there's a

00:41:35,520 --> 00:41:41,910
duct tool and the doc information is

00:41:39,360 --> 00:41:45,690
actually integrated in our intermediate

00:41:41,910 --> 00:41:48,690
format so this format is called tasty so

00:41:45,690 --> 00:41:51,690
most of the tooling is is built around

00:41:48,690 --> 00:41:53,970
this new thing tasty so that's really

00:41:51,690 --> 00:41:56,670
they're essentially the new development

00:41:53,970 --> 00:42:01,350
that took the tooling takes so what is

00:41:56,670 --> 00:42:03,420
tasty so tasty is type abstract syntax

00:42:01,350 --> 00:42:06,690
trees that that's where the name comes

00:42:03,420 --> 00:42:09,930
from it's in a way a serialization

00:42:06,690 --> 00:42:12,570
format for Scala so what the compiler

00:42:09,930 --> 00:42:14,250
does is it takes your program it infers

00:42:12,570 --> 00:42:16,980
all the types of universally implicit

00:42:14,250 --> 00:42:20,340
and then it takes the tree that it has

00:42:16,980 --> 00:42:22,410
and puts that tree in a file so that

00:42:20,340 --> 00:42:24,720
means you essentially have all the all

00:42:22,410 --> 00:42:27,690
informations about the program including

00:42:24,720 --> 00:42:30,810
even the positions you could say well

00:42:27,690 --> 00:42:32,310
isn't that huge and if you don't do if

00:42:30,810 --> 00:42:33,990
you're not very clever about it the

00:42:32,310 --> 00:42:35,640
answer would be yes typically these

00:42:33,990 --> 00:42:37,530
things are at least ten times the size

00:42:35,640 --> 00:42:39,540
of source or something like that but we

00:42:37,530 --> 00:42:41,760
got it down to about the same size of

00:42:39,540 --> 00:42:44,760
source so you could say yeah actually

00:42:41,760 --> 00:42:46,350
that's quite reasonably compact so it's

00:42:44,760 --> 00:42:48,360
compact enough that the compiler can

00:42:46,350 --> 00:42:49,800
actually generate this fully type tree

00:42:48,360 --> 00:42:51,510
which gives you essentially everything

00:42:49,800 --> 00:42:54,360
there is to know about a program every

00:42:51,510 --> 00:42:56,550
time it compiles that program and that

00:42:54,360 --> 00:42:59,010
way this tasty now sits sort of in the

00:42:56,550 --> 00:43:01,830
middle of essentially a lot of the

00:42:59,010 --> 00:43:04,440
tooling landscape so the first thing is

00:43:01,830 --> 00:43:07,170
it can actually be used as a bridge

00:43:04,440 --> 00:43:10,560
between Scylla two and Scala three so

00:43:07,170 --> 00:43:12,660
currently Scala 330 generates tasty the

00:43:10,560 --> 00:43:15,270
plan is that in the future the scanner 2

00:43:12,660 --> 00:43:17,220
to 14 compiler will also generate tasty

00:43:15,270 --> 00:43:20,490
and that means they will actually be

00:43:17,220 --> 00:43:24,090
able to talk together so it's like now

00:43:20,490 --> 00:43:26,730
that lets say a 210 module could be used

00:43:24,090 --> 00:43:30,600
from a 211 library which could be used

00:43:26,730 --> 00:43:32,880
from a 212 program now I did today we

00:43:30,600 --> 00:43:35,040
say dream on right so that's that's just

00:43:32,880 --> 00:43:36,990
not in the cards but with tasty it's

00:43:35,040 --> 00:43:39,000
perfectly reasonable so you can do that

00:43:36,990 --> 00:43:40,890
perfectly well because if they are map

00:43:39,000 --> 00:43:44,190
into exactly the same intermediate

00:43:40,890 --> 00:43:46,710
format it is the same format essentially

00:43:44,190 --> 00:43:49,340
is backs our iid ease it does

00:43:46,710 --> 00:43:52,230
essentially everything from hyperlinking

00:43:49,340 --> 00:43:53,880
completion find references and things

00:43:52,230 --> 00:43:56,100
like that essentially tasty is the thing

00:43:53,880 --> 00:43:58,500
that you can use for that it will in the

00:43:56,100 --> 00:43:59,880
future integrate with semantic DB for

00:43:58,500 --> 00:44:03,330
essentially larger multi-language

00:43:59,880 --> 00:44:06,330
multi-project projects as well and

00:44:03,330 --> 00:44:09,630
furthermore it can be used for compiling

00:44:06,330 --> 00:44:12,660
to a number of different platforms so

00:44:09,630 --> 00:44:14,670
from this tasty thing we can compile to

00:44:12,660 --> 00:44:17,369
class files that's just the standard

00:44:14,670 --> 00:44:18,900
compiler back-end that we have and of

00:44:17,369 --> 00:44:21,780
course the compiler back-end will evolve

00:44:18,900 --> 00:44:24,869
the current one targets Java 8 a future

00:44:21,780 --> 00:44:27,270
one will target target Java 11 but where

00:44:24,869 --> 00:44:29,580
previously you had to choose to say I

00:44:27,270 --> 00:44:31,590
can use only one or only the the other

00:44:29,580 --> 00:44:33,990
here now in the future you will be able

00:44:31,590 --> 00:44:35,970
to mix them and mix them all so with

00:44:33,990 --> 00:44:38,250
backends that generate Java Script or

00:44:35,970 --> 00:44:40,500
that generate native so tasty is really

00:44:38,250 --> 00:44:42,570
essentially the could say tasty is the

00:44:40,500 --> 00:44:44,940
platform of the future it's the thing

00:44:42,570 --> 00:44:47,760
that everything compiles into and that

00:44:44,940 --> 00:44:50,970
especially is used to compile into all

00:44:47,760 --> 00:44:53,340
possible formats and because it's

00:44:50,970 --> 00:44:55,290
essentially in so central it makes a lot

00:44:53,340 --> 00:44:56,730
of sense to use that then for

00:44:55,290 --> 00:45:01,200
essentially all the other tooling we

00:44:56,730 --> 00:45:04,680
have for the macros the analyzers the

00:45:01,200 --> 00:45:07,109
optimizers and so on so the use cases

00:45:04,680 --> 00:45:09,810
for tasty are now a separate compilation

00:45:07,109 --> 00:45:11,369
it means that you compile a module you

00:45:09,810 --> 00:45:13,470
need to find out what are the scalar

00:45:11,369 --> 00:45:15,330
functions the other module offers you

00:45:13,470 --> 00:45:16,920
look at the trees actually you just look

00:45:15,330 --> 00:45:18,780
at the top level of the trees you don't

00:45:16,920 --> 00:45:20,850
need to look inside the methods for for

00:45:18,780 --> 00:45:24,359
doing this but essentially the methods

00:45:20,850 --> 00:45:25,859
are there if you need them so that in

00:45:24,359 --> 00:45:28,350
the in that sense taste you support

00:45:25,859 --> 00:45:30,180
separate compilation just like Scala -

00:45:28,350 --> 00:45:32,250
as a different picker format that does

00:45:30,180 --> 00:45:34,150
the same thing where we'd be but for

00:45:32,250 --> 00:45:39,550
Scala 3 is just tasty

00:45:34,150 --> 00:45:44,200
i des macros and cross building so one

00:45:39,550 --> 00:45:46,660
of the issues here that we have

00:45:44,200 --> 00:45:49,300
mentioned macros is probably the one

00:45:46,660 --> 00:45:51,940
that is essentially the most contentious

00:45:49,300 --> 00:45:54,190
point of this movement from Scala to to

00:45:51,940 --> 00:45:55,780
Scala three so I want to spend the rest

00:45:54,190 --> 00:46:00,550
of the time to talk a little bit about

00:45:55,780 --> 00:46:03,100
that so far our meta programming was

00:46:00,550 --> 00:46:06,640
essentially the death macros Scott I

00:46:03,100 --> 00:46:08,830
reflect macros which still has

00:46:06,640 --> 00:46:12,040
experimental status although everybody's

00:46:08,830 --> 00:46:16,540
using them right now and macro paradise

00:46:12,040 --> 00:46:18,610
which was a plugin but both of them are

00:46:16,540 --> 00:46:20,770
really just essentially thin veneers

00:46:18,610 --> 00:46:24,300
around the compiler so both of them

00:46:20,770 --> 00:46:27,370
really export in various ways of

00:46:24,300 --> 00:46:31,090
precision and generality what's in the

00:46:27,370 --> 00:46:32,800
current Scala compiler NSC the problem

00:46:31,090 --> 00:46:35,050
is that the current compiler will go

00:46:32,800 --> 00:46:36,850
away will be replaced by dot C and that

00:46:35,050 --> 00:46:39,010
means with a new compiler we can't we

00:46:36,850 --> 00:46:40,780
cannot even if we wanted support the

00:46:39,010 --> 00:46:42,940
same API so anymore so that's

00:46:40,780 --> 00:46:45,400
essentially the existential problem

00:46:42,940 --> 00:46:47,020
we're facing I should say there's

00:46:45,400 --> 00:46:49,390
another big thing which is not affected

00:46:47,020 --> 00:46:51,520
by that and that's kilometer these are

00:46:49,390 --> 00:46:53,290
external tools that analyze and

00:46:51,520 --> 00:46:55,030
transform programs and essentially they

00:46:53,290 --> 00:46:56,770
have their own way to deal with programs

00:46:55,030 --> 00:46:59,800
that those things are not affected and

00:46:56,770 --> 00:47:03,160
will continue to be very useful in Scala

00:46:59,800 --> 00:47:06,090
- and Scala 3 so about the meta

00:47:03,160 --> 00:47:09,910
programming what are we gonna do so

00:47:06,090 --> 00:47:13,120
we've tried to rethink things from

00:47:09,910 --> 00:47:15,010
essentially the ground up to say well so

00:47:13,120 --> 00:47:17,560
far we had I believe in meta programming

00:47:15,010 --> 00:47:19,630
our problem was too much power and too

00:47:17,560 --> 00:47:21,040
much for agility at the same time there

00:47:19,630 --> 00:47:24,130
were too many different ways you could

00:47:21,040 --> 00:47:25,960
shoot yourself in the foot so can we

00:47:24,130 --> 00:47:30,160
restrict that and can we make that more

00:47:25,960 --> 00:47:32,140
systematic and so we come up with some

00:47:30,160 --> 00:47:34,690
things which actually are all very very

00:47:32,140 --> 00:47:37,000
known in the literature and some other

00:47:34,690 --> 00:47:40,090
languages are using them already

00:47:37,000 --> 00:47:41,740
the first one is principles meta

00:47:40,090 --> 00:47:43,530
programming that we said well what is

00:47:41,740 --> 00:47:46,920
programming problem muck

00:47:43,530 --> 00:47:49,290
programming about well it takes program

00:47:46,920 --> 00:47:51,480
pieces treats them as data and then puts

00:47:49,290 --> 00:47:53,940
them together in some ways and the

00:47:51,480 --> 00:47:54,780
resulted resulting trees then part of

00:47:53,940 --> 00:47:56,400
your program

00:47:54,780 --> 00:47:58,860
right that's what micro programming is

00:47:56,400 --> 00:48:01,770
about so the simplest way to express

00:47:58,860 --> 00:48:05,430
them is a way to treat your code as data

00:48:01,770 --> 00:48:08,520
so that's quote that's this one here and

00:48:05,430 --> 00:48:10,500
a way then if you have a quoted thing

00:48:08,520 --> 00:48:12,240
you want to splice something else in it

00:48:10,500 --> 00:48:14,400
you want to say well here's a hole and I

00:48:12,240 --> 00:48:17,810
put some other piece of data and my

00:48:14,400 --> 00:48:20,910
piece of data and if you do that then

00:48:17,810 --> 00:48:22,860
you just need one more thing and that's

00:48:20,910 --> 00:48:24,810
in line that you can say well I need to

00:48:22,860 --> 00:48:28,230
be able to move code from one place to

00:48:24,810 --> 00:48:29,970
the other and you have a macro system or

00:48:28,230 --> 00:48:32,070
if you want to replace in line with

00:48:29,970 --> 00:48:34,950
another primitive called run then you

00:48:32,070 --> 00:48:36,930
have something called staging so staging

00:48:34,950 --> 00:48:38,910
is essentially a way to compile code at

00:48:36,930 --> 00:48:41,330
runtime based on information at runtime

00:48:38,910 --> 00:48:43,710
so essentially quotients price and

00:48:41,330 --> 00:48:51,080
inline gives you macros and quotients

00:48:43,710 --> 00:48:51,080
price and run gives you staging so the

00:48:51,380 --> 00:48:57,570
the operations are typed so for any type

00:48:55,080 --> 00:48:59,220
T there's a type expression of T which

00:48:57,570 --> 00:49:01,560
is essentially the data

00:48:59,220 --> 00:49:04,410
the code is data that gives you an

00:49:01,560 --> 00:49:06,570
expression that returns a type T and as

00:49:04,410 --> 00:49:09,240
I said quote goes from a T to an

00:49:06,570 --> 00:49:13,640
expression of T in this direction and

00:49:09,240 --> 00:49:16,980
price goes from expression of T to t so

00:49:13,640 --> 00:49:18,720
in all this it's compared to what we're

00:49:16,980 --> 00:49:20,520
currently used to is really quite

00:49:18,720 --> 00:49:22,770
minimal and there's one major

00:49:20,520 --> 00:49:24,630
restriction you can't look inside these

00:49:22,770 --> 00:49:26,370
expressions expressions they're just

00:49:24,630 --> 00:49:26,820
these black boxes you can splice into

00:49:26,370 --> 00:49:28,950
them

00:49:26,820 --> 00:49:31,260
Sanchi you can take a piece of data

00:49:28,950 --> 00:49:32,760
quoted and you get the expression you

00:49:31,260 --> 00:49:35,910
can splice holes but you can't look

00:49:32,760 --> 00:49:38,460
inside what it is and sometimes you need

00:49:35,910 --> 00:49:39,690
that sometimes you want more not always

00:49:38,460 --> 00:49:42,380
but sometimes

00:49:39,690 --> 00:49:45,870
so for these times there's essentially a

00:49:42,380 --> 00:49:48,990
second layer that says well if you have

00:49:45,870 --> 00:49:51,240
an expression of T then you can reflect

00:49:48,990 --> 00:49:53,640
that into a tasty tree and you can rave

00:49:51,240 --> 00:49:57,150
I the ecstasy tree back to expression T

00:49:53,640 --> 00:49:58,950
so the tricky bit with that

00:49:57,150 --> 00:50:01,380
to say well why shouldn't we give you

00:49:58,950 --> 00:50:04,799
the power to look inside expressions

00:50:01,380 --> 00:50:07,319
it's all very good and the the crucial

00:50:04,799 --> 00:50:08,970
thing is well yeah but how there are a

00:50:07,319 --> 00:50:11,430
million ways to do that what is an

00:50:08,970 --> 00:50:13,140
expression is it just the IAS T's in

00:50:11,430 --> 00:50:14,250
your compiler but if you change the

00:50:13,140 --> 00:50:17,430
compiler and their representation

00:50:14,250 --> 00:50:18,990
changes is it just classic quotes yeah

00:50:17,430 --> 00:50:21,150
but with classic quotes you never know

00:50:18,990 --> 00:50:23,130
what what what cases you have covered

00:50:21,150 --> 00:50:26,750
and what simplifications you have

00:50:23,130 --> 00:50:30,119
overlooked and things like that so the

00:50:26,750 --> 00:50:32,819
answer here and I hope it's going to

00:50:30,119 --> 00:50:36,539
work out is to say well we are going to

00:50:32,819 --> 00:50:38,430
give you the tree the ast but not the SD

00:50:36,539 --> 00:50:40,770
of the compiler but the ast as its

00:50:38,430 --> 00:50:42,930
defined in this tasty format why is that

00:50:40,770 --> 00:50:45,359
better than a compiler well because

00:50:42,930 --> 00:50:47,849
tasty is a serialization format it's a

00:50:45,359 --> 00:50:50,339
platform we can't change that on a whim

00:50:47,849 --> 00:50:52,980
in the next version so that would

00:50:50,339 --> 00:50:56,130
essentially precisely because tasty is

00:50:52,980 --> 00:50:58,140
around to make programs of multiple

00:50:56,130 --> 00:51:00,059
versions compiled together and run

00:50:58,140 --> 00:51:02,520
together is precisely the reasons why

00:51:00,059 --> 00:51:05,160
it's also a good format to actually look

00:51:02,520 --> 00:51:07,710
at into a ast s namely it has to be very

00:51:05,160 --> 00:51:09,660
very stable or where it evolves it had

00:51:07,710 --> 00:51:14,369
the evolution has to be careful in the

00:51:09,660 --> 00:51:16,980
version control okay so the taste

00:51:14,369 --> 00:51:19,079
division then is this that we tasty we

00:51:16,980 --> 00:51:23,660
essentially have the macro code that

00:51:19,079 --> 00:51:27,660
uses the tasty and and generates it so

00:51:23,660 --> 00:51:30,000
that all works but there's one

00:51:27,660 --> 00:51:32,160
restriction crucial restriction and

00:51:30,000 --> 00:51:35,220
that's these new macros they are black

00:51:32,160 --> 00:51:37,470
box so what do I mean by that so it

00:51:35,220 --> 00:51:40,770
means that these new macros are expanded

00:51:37,470 --> 00:51:42,869
after type checking so the type checker

00:51:40,770 --> 00:51:44,789
checks your program gives you the full

00:51:42,869 --> 00:51:47,250
tree then you are at the level of tasty

00:51:44,789 --> 00:51:49,380
then the macro stuff happens but that

00:51:47,250 --> 00:51:51,510
means that those macros can't generate

00:51:49,380 --> 00:51:53,609
things that you need to see at the same

00:51:51,510 --> 00:51:55,950
compiler run because well they're not

00:51:53,609 --> 00:52:00,210
generated yet and everything has to be

00:51:55,950 --> 00:52:05,010
visible to the type of so it has on the

00:52:00,210 --> 00:52:08,640
other hand it has a lot of positive

00:52:05,010 --> 00:52:11,400
it's aspects as well one is that these

00:52:08,640 --> 00:52:13,950
macros always work on type trees so

00:52:11,400 --> 00:52:16,260
there's not this sort of races where you

00:52:13,950 --> 00:52:18,089
say well sometimes in some situations I

00:52:16,260 --> 00:52:19,890
don't see this yet and it's untyped or

00:52:18,089 --> 00:52:21,570
things like that at the time the macros

00:52:19,890 --> 00:52:24,599
expand everything is very well known

00:52:21,570 --> 00:52:26,520
these trees are all typed for the same

00:52:24,599 --> 00:52:28,770
reason macros are always high genic by

00:52:26,520 --> 00:52:32,339
definition it's it's not even possible

00:52:28,770 --> 00:52:35,130
to write an and hygienic macro and

00:52:32,339 --> 00:52:38,550
generally it drastically reduces the

00:52:35,130 --> 00:52:39,480
number of things that can go wrong okay

00:52:38,550 --> 00:52:42,869
so that's the good news

00:52:39,480 --> 00:52:45,180
so essentially solids macros black box

00:52:42,869 --> 00:52:47,070
but what about the white box things I

00:52:45,180 --> 00:52:49,079
don't there a lot of libraries out there

00:52:47,070 --> 00:52:51,359
that use white box macros and what what

00:52:49,079 --> 00:52:54,780
are we going to about them to do about

00:52:51,359 --> 00:52:58,020
them so one thing we're going to do is

00:52:54,780 --> 00:53:00,570
that we are going to work on language

00:52:58,020 --> 00:53:02,849
level solutions for the most crucial

00:53:00,570 --> 00:53:05,670
ones of these and the none of them is

00:53:02,849 --> 00:53:08,820
actually already done so macros have

00:53:05,670 --> 00:53:12,480
been used for lazy implicit so the lazy

00:53:08,820 --> 00:53:15,810
macro and shapeless type lambdas kind

00:53:12,480 --> 00:53:18,150
kind project to be mentioned context

00:53:15,810 --> 00:53:20,790
injection and all these things they are

00:53:18,150 --> 00:53:23,010
already inherently in the language for

00:53:20,790 --> 00:53:25,410
context injections for instance it would

00:53:23,010 --> 00:53:27,480
be implicit function types type class

00:53:25,410 --> 00:53:30,000
derivation that's a very important topic

00:53:27,480 --> 00:53:31,589
that we are currently looking at and I

00:53:30,000 --> 00:53:34,530
we hope to have essentially a good

00:53:31,589 --> 00:53:37,170
solution very soon and we are also

00:53:34,530 --> 00:53:39,510
working on the last part type level of

00:53:37,170 --> 00:53:41,430
functions right which essentially things

00:53:39,510 --> 00:53:44,760
like shapeless which have used the gem

00:53:41,430 --> 00:53:47,010
macro and then a lot of implicit so I

00:53:44,760 --> 00:53:48,450
just want to show you give you a quick

00:53:47,010 --> 00:53:51,990
glimpse what we are currently doing

00:53:48,450 --> 00:53:55,050
there so for type level programming

00:53:51,990 --> 00:53:59,250
here's sort of the current state so you

00:53:55,050 --> 00:54:01,680
use a lot of implicit to essentially do

00:53:59,250 --> 00:54:03,960
things so what this does here is it

00:54:01,680 --> 00:54:07,050
takes two age lists heterogeneous lists

00:54:03,960 --> 00:54:09,060
and then it that that thing is actually

00:54:07,050 --> 00:54:11,609
defines a concat function that takes

00:54:09,060 --> 00:54:13,589
essentially one tupple heterogeneous

00:54:11,609 --> 00:54:16,150
list it's same estoppel and another

00:54:13,589 --> 00:54:20,260
Taplin test this concatenation that i'm

00:54:16,150 --> 00:54:23,230
initially okay it's quite a lot of code

00:54:20,260 --> 00:54:25,510
and if you look at it then it actually

00:54:23,230 --> 00:54:27,279
looks like logic programming with your

00:54:25,510 --> 00:54:30,130
hands tied behind your back

00:54:27,279 --> 00:54:33,369
it is logic programming it's essentially

00:54:30,130 --> 00:54:35,680
implicit search has in essence power

00:54:33,369 --> 00:54:38,410
similar to Prolog so this feels like

00:54:35,680 --> 00:54:40,390
Prolog only with a lot of the amenities

00:54:38,410 --> 00:54:42,910
of Prolog starting with well the syntax

00:54:40,390 --> 00:54:44,890
looks nothing like logic programming -

00:54:42,910 --> 00:54:46,630
there's not really a good way to control

00:54:44,890 --> 00:54:50,920
the search and so on

00:54:46,630 --> 00:54:52,809
so why in a functional language why do

00:54:50,920 --> 00:54:54,839
we do type level programming using

00:54:52,809 --> 00:54:59,789
Prolog that's a good question

00:54:54,839 --> 00:55:02,260
why well from I believe the answer is

00:54:59,789 --> 00:55:04,599
the same as in quite a few other

00:55:02,260 --> 00:55:06,730
languages so type level programming is

00:55:04,599 --> 00:55:09,549
something that people need for some

00:55:06,730 --> 00:55:11,589
applications but it's often actually not

00:55:09,549 --> 00:55:13,809
in the language proper in the in the

00:55:11,589 --> 00:55:15,730
built-in in the language and what then

00:55:13,809 --> 00:55:17,710
happens is that essentially people take

00:55:15,730 --> 00:55:21,279
the most powerful thing in a language

00:55:17,710 --> 00:55:23,319
and just bend it and form it until it

00:55:21,279 --> 00:55:24,940
can do that so the most powerful thing

00:55:23,319 --> 00:55:27,250
in Scala is implicit search it's

00:55:24,940 --> 00:55:29,410
essentially if you turn off the

00:55:27,250 --> 00:55:32,020
divergence check its turing-complete so

00:55:29,410 --> 00:55:34,119
so you can use it to achieve what you

00:55:32,020 --> 00:55:36,190
want to do and in fact type level

00:55:34,119 --> 00:55:39,010
programming libraries have done that in

00:55:36,190 --> 00:55:41,380
very ingenious ways by the same token

00:55:39,010 --> 00:55:44,619
essentially template expansion is the

00:55:41,380 --> 00:55:46,480
thing is the the in C++ is the way to do

00:55:44,619 --> 00:55:48,099
type level programming there and again

00:55:46,480 --> 00:55:51,130
it's just because it's the most powerful

00:55:48,099 --> 00:55:52,180
feature that people use that but just

00:55:51,130 --> 00:55:54,819
because something is the most powerful

00:55:52,180 --> 00:55:56,890
feature doesn't actually mean that it's

00:55:54,819 --> 00:55:59,289
the ideal feature to express what you

00:55:56,890 --> 00:56:00,609
want to express so I believe what we

00:55:59,289 --> 00:56:03,579
want to do tomorrow

00:56:00,609 --> 00:56:06,520
is avoid essentially the logic

00:56:03,579 --> 00:56:09,010
programming exploration of implicit

00:56:06,520 --> 00:56:12,279
search for this purpose and be

00:56:09,010 --> 00:56:14,349
functional so what what's the fun if

00:56:12,279 --> 00:56:17,410
logic programming is essentially so

00:56:14,349 --> 00:56:19,569
exploring queries and building search

00:56:17,410 --> 00:56:21,760
trees what is functional programming the

00:56:19,569 --> 00:56:24,130
functional programming is you reduce

00:56:21,760 --> 00:56:26,260
things you rewrite programs right you

00:56:24,130 --> 00:56:27,830
simplify them using beta a beta

00:56:26,260 --> 00:56:30,020
reduction and

00:56:27,830 --> 00:56:32,600
and and other things and that's

00:56:30,020 --> 00:56:36,440
precisely what we want to do that so I

00:56:32,600 --> 00:56:40,910
just want to do a quick demo now we see

00:56:36,440 --> 00:56:44,090
the thing okay good so here's our new

00:56:40,910 --> 00:56:46,700
concat so what the concat says okay i

00:56:44,090 --> 00:56:47,990
have an age list which is the same thing

00:56:46,700 --> 00:56:51,260
as before

00:56:47,990 --> 00:56:53,540
and another age list and i give you an

00:56:51,260 --> 00:56:56,060
edge list and here's the essentially the

00:56:53,540 --> 00:56:57,650
most simple code you could write here

00:56:56,060 --> 00:56:59,540
well if the first one is emptied in the

00:56:57,650 --> 00:57:01,490
second and otherwise a cons of the head

00:56:59,540 --> 00:57:02,870
of the first Atkin cat tail of the

00:57:01,490 --> 00:57:05,780
second wire so that's how you would

00:57:02,870 --> 00:57:07,700
write append okay only that of course it

00:57:05,780 --> 00:57:10,370
would never give you that the result

00:57:07,700 --> 00:57:13,220
type of concat normally would be age

00:57:10,370 --> 00:57:14,780
list and that's sort of not good enough

00:57:13,220 --> 00:57:17,030
that's just essentially a list of any

00:57:14,780 --> 00:57:19,460
sort of this sort of thing so the

00:57:17,030 --> 00:57:23,540
question is well then how can we make

00:57:19,460 --> 00:57:25,250
this work for us so let me just hover

00:57:23,540 --> 00:57:28,850
over this and show you some of the types

00:57:25,250 --> 00:57:33,890
so here we have the cons so that's a

00:57:28,850 --> 00:57:35,750
list of int string and nil oh that also

00:57:33,890 --> 00:57:38,660
doesn't show i should have tested this

00:57:35,750 --> 00:57:40,790
thing okay so that thing is a list of

00:57:38,660 --> 00:57:43,790
boolean double of nil and that thing

00:57:40,790 --> 00:57:45,260
should be the answer is ageless but no

00:57:43,790 --> 00:57:48,710
actually if we look at this control

00:57:45,260 --> 00:57:51,770
thing then actually it's the full list

00:57:48,710 --> 00:57:53,930
here oh it does show what I just I it's

00:57:51,770 --> 00:57:57,890
just not in sync with these things right

00:57:53,930 --> 00:58:02,660
so actually it's the full age list in

00:57:57,890 --> 00:58:04,520
string boolean double new what I mean

00:58:02,660 --> 00:58:09,160
the declare type was H list how can i

00:58:04,520 --> 00:58:09,160
how can it be this this this type here

00:58:09,340 --> 00:58:15,650
so the answer is that the key is this

00:58:13,880 --> 00:58:17,990
word transparent here so what

00:58:15,650 --> 00:58:19,850
transparent means is you tell the

00:58:17,990 --> 00:58:22,760
compiler well here's the definition of

00:58:19,850 --> 00:58:25,610
the concat but it's a definition that

00:58:22,760 --> 00:58:28,220
you know you know what it is so when i

00:58:25,610 --> 00:58:30,470
have a call to concat like this call

00:58:28,220 --> 00:58:31,940
here and then the compiler will actually

00:58:30,470 --> 00:58:33,770
take the definition and simplify

00:58:31,940 --> 00:58:36,320
according to it so it will do the

00:58:33,770 --> 00:58:38,210
rewriting and once it's done with the

00:58:36,320 --> 00:58:39,740
rewriting it will take the resulting

00:58:38,210 --> 00:58:40,940
list which in this case would be the

00:58:39,740 --> 00:58:43,790
list 1a

00:58:40,940 --> 00:58:46,190
true 1.0 and we say well the type of

00:58:43,790 --> 00:58:48,950
that the type of my con cat is the type

00:58:46,190 --> 00:58:51,410
of my result of the list and that's what

00:58:48,950 --> 00:58:53,990
we what you see here this type here so

00:58:51,410 --> 00:58:57,680
we use what some people call partial

00:58:53,990 --> 00:58:59,810
evaluation a simplification of programs

00:58:57,680 --> 00:59:01,940
in order to get better type as we

00:58:59,810 --> 00:59:03,950
simplify and rewrite the program we get

00:59:01,940 --> 00:59:06,140
better types and that's a very

00:59:03,950 --> 00:59:08,690
functional way of doing the same things

00:59:06,140 --> 00:59:12,890
so let's do another thing I have this

00:59:08,690 --> 00:59:15,319
function index here which is it just

00:59:12,890 --> 00:59:17,270
selects it takes an index and an H list

00:59:15,319 --> 00:59:19,280
and says well if the index is zero then

00:59:17,270 --> 00:59:21,710
it's the head and otherwise it's the

00:59:19,280 --> 00:59:27,170
recursive call here okay so what would

00:59:21,710 --> 00:59:28,940
be the index of zetas and zero well what

00:59:27,170 --> 00:59:31,730
that will be an int because thats

00:59:28,940 --> 00:59:33,589
starts with an end okay I have an

00:59:31,730 --> 00:59:36,500
abbreviation which is in this decorator

00:59:33,589 --> 00:59:39,859
here this one here so that defines apply

00:59:36,500 --> 00:59:42,260
as an alias of index so I can just use

00:59:39,859 --> 00:59:46,190
normal function applications so the type

00:59:42,260 --> 00:59:48,950
of set is one is string and the type of

00:59:46,190 --> 00:59:51,349
there is two is boolean and the type of

00:59:48,950 --> 00:59:53,060
set is three is double and the type of

00:59:51,349 --> 00:59:56,900
set is four which is out of range

00:59:53,060 --> 00:59:59,060
there's nothing so the compiler has

00:59:56,900 --> 01:00:01,130
actually known all these types and it

00:59:59,060 --> 01:00:06,260
did that just by just by rewriting the

01:00:01,130 --> 01:00:08,869
program the program that you wrote and

01:00:06,260 --> 01:00:13,339
and simplifying it so that's the nice

01:00:08,869 --> 01:00:15,520
part of it here good let's go back to

01:00:13,339 --> 01:00:15,520
them

01:00:22,180 --> 01:00:26,510
so there's still a lot of work to do but

01:00:25,130 --> 01:00:29,600
I believe that the metaprogramming

01:00:26,510 --> 01:00:31,730
landscape is starting to form so in the

01:00:29,600 --> 01:00:33,370
end we gonna end up I guess with three

01:00:31,730 --> 01:00:35,240
levels the first one is these

01:00:33,370 --> 01:00:37,970
transparent functions for type

01:00:35,240 --> 01:00:40,370
specialization the second one is

01:00:37,970 --> 01:00:43,630
essentially the note the macros so

01:00:40,370 --> 01:00:45,770
macros means you run user-defined code

01:00:43,630 --> 01:00:47,720
repress the transparent functions you

01:00:45,770 --> 01:00:50,270
don't run anything the compiler rewrites

01:00:47,720 --> 01:00:52,850
your rewrites your three write macros

01:00:50,270 --> 01:00:55,130
you run user-defined code and that's

01:00:52,850 --> 01:00:57,770
essentially gonna be safe

01:00:55,130 --> 01:01:00,230
using just quotes and splices and if you

01:00:57,770 --> 01:01:03,050
want more than you have tasty reflection

01:01:00,230 --> 01:01:06,020
and so that's essentially a trade-off of

01:01:03,050 --> 01:01:08,690
safety versus power where I should say

01:01:06,020 --> 01:01:10,880
we the current system def macros is

01:01:08,690 --> 01:01:12,500
essentially down here so it's even more

01:01:10,880 --> 01:01:15,110
powerful than tasty reflection because

01:01:12,500 --> 01:01:17,330
essentially you can do much more but

01:01:15,110 --> 01:01:19,520
it's a lot less safe so we can't kind of

01:01:17,330 --> 01:01:21,080
shift the whole thing towards safety and

01:01:19,520 --> 01:01:24,710
then be quite selective about

01:01:21,080 --> 01:01:27,020
essentially these three levels good so

01:01:24,710 --> 01:01:31,150
that's all I had to say about the

01:01:27,020 --> 01:01:33,680
language what about getting there so

01:01:31,150 --> 01:01:36,530
migration looks like a huge talk task

01:01:33,680 --> 01:01:39,050
and and indeed it is however despite

01:01:36,530 --> 01:01:40,910
many differences scholar two and three

01:01:39,050 --> 01:01:42,800
are still fundamentally the same

01:01:40,910 --> 01:01:45,230
language that means if I for instance

01:01:42,800 --> 01:01:47,450
look at the textbook programming in

01:01:45,230 --> 01:01:49,820
Scala that I've written and I believe

01:01:47,450 --> 01:01:51,830
actually it's less affected by what I've

01:01:49,820 --> 01:01:54,620
shown you here except that it would make

01:01:51,830 --> 01:01:56,270
for a lot of nice new chapters then the

01:01:54,620 --> 01:01:57,980
change from two to about twelve to two

01:01:56,270 --> 01:01:59,540
thirteen because that means we have to

01:01:57,980 --> 01:02:02,000
change some of the collections and these

01:01:59,540 --> 01:02:05,270
are essentially part of the book

01:02:02,000 --> 01:02:07,760
we do have source compatibility for a

01:02:05,270 --> 01:02:09,830
common subset so that means it is

01:02:07,760 --> 01:02:11,510
possible to write programs such that

01:02:09,830 --> 01:02:15,740
they compiled under Scala two and

01:02:11,510 --> 01:02:17,570
scholar three and the rewrite tools

01:02:15,740 --> 01:02:18,080
should be able to handle much of the

01:02:17,570 --> 01:02:20,210
rest

01:02:18,080 --> 01:02:22,250
except for macros so macros is the thing

01:02:20,210 --> 01:02:24,680
where we have to appeal to the macro

01:02:22,250 --> 01:02:27,200
library writers to say look there are

01:02:24,680 --> 01:02:29,240
lots of shiny new tools it's a better

01:02:27,200 --> 01:02:31,100
world please rewrite give it give it a

01:02:29,240 --> 01:02:33,110
try rewrite your macro library in the

01:02:31,100 --> 01:02:35,210
new in the new system be that but that

01:02:33,110 --> 01:02:38,930
one we can't do automatically

01:02:35,210 --> 01:02:41,359
so Scala - in Scala three I guess

01:02:38,930 --> 01:02:44,990
because of the after of the numbering

01:02:41,359 --> 01:02:48,230
also has often been compared to Scala -

01:02:44,990 --> 01:02:50,540
and Scala 3 so people are asking is this

01:02:48,230 --> 01:02:53,960
gon going to be a disaster like between

01:02:50,540 --> 01:02:56,450
Scala to Python - in Python 3 but I

01:02:53,960 --> 01:03:00,309
believe we have reasons to hope that

01:02:56,450 --> 01:03:03,559
it's not and I think the main the main

01:03:00,309 --> 01:03:06,260
two arguments for the first aesthetic

01:03:03,559 --> 01:03:09,770
typing that essentially most of the

01:03:06,260 --> 01:03:12,980
changes that we that we that effect

01:03:09,770 --> 01:03:15,230
programs will take the form of the types

01:03:12,980 --> 01:03:16,819
are slightly different and that means

01:03:15,230 --> 01:03:18,290
your type checker will come and say well

01:03:16,819 --> 01:03:20,300
this there's no longer works you have to

01:03:18,290 --> 01:03:22,430
rewrite and hopefully it will give you a

01:03:20,300 --> 01:03:24,920
good tip how to rewrite and again

01:03:22,430 --> 01:03:26,690
hopefully and in I mean more and more

01:03:24,920 --> 01:03:28,220
they're rewriting will be automatic it

01:03:26,690 --> 01:03:29,990
will actually offer you to rewrite

01:03:28,220 --> 01:03:32,480
should I rewrite this like this and it

01:03:29,990 --> 01:03:34,970
will do that so that's the one thing

01:03:32,480 --> 01:03:36,619
static typing we don't we won't have

01:03:34,970 --> 01:03:39,589
this situation where you have a huge

01:03:36,619 --> 01:03:41,150
code base and then you bring it to the

01:03:39,589 --> 01:03:42,799
new language and then suddenly things

01:03:41,150 --> 01:03:45,020
don't work anymore and you have to go

01:03:42,799 --> 01:03:47,569
into the debugger and ask why why don't

01:03:45,020 --> 01:03:50,299
they work anymore and then the other big

01:03:47,569 --> 01:03:53,690
thing in the favor of smooth migration

01:03:50,299 --> 01:03:56,119
is binary compatibility so today dot e

01:03:53,690 --> 01:03:59,660
can link with SCARA 212 class files so

01:03:56,119 --> 01:04:01,700
we already mix study and scanner - but

01:03:59,660 --> 01:04:03,619
it's one way so a dot e thing can use a

01:04:01,700 --> 01:04:04,549
SCARA - artifact not the other way

01:04:03,619 --> 01:04:06,770
around

01:04:04,549 --> 01:04:09,890
but in the future if both dotty and

01:04:06,770 --> 01:04:12,319
scholar to produce tasty then you can do

01:04:09,890 --> 01:04:14,720
these things so dot e will be scala 3 by

01:04:12,319 --> 01:04:17,450
then so you could have a scholar to a

01:04:14,720 --> 01:04:19,309
foundation some scholar three layers on

01:04:17,450 --> 01:04:22,460
it on that some scholar two layers on

01:04:19,309 --> 01:04:25,040
that and so on so that means that you

01:04:22,460 --> 01:04:27,260
can migrate bit by bit you can move a

01:04:25,040 --> 01:04:30,380
thing from scholar to two scholar three

01:04:27,260 --> 01:04:32,450
and we still link the same program it's

01:04:30,380 --> 01:04:34,220
not essentially a global decision that

01:04:32,450 --> 01:04:39,440
you have to rewrite all your code base

01:04:34,220 --> 01:04:42,380
at once so what's the road map so the

01:04:39,440 --> 01:04:44,750
plan is to essentially flesh out the

01:04:42,380 --> 01:04:45,980
design so most of the type level changes

01:04:44,750 --> 01:04:48,570
that I've shown you for instance we're

01:04:45,980 --> 01:04:50,910
done between sky des Berlin and May

01:04:48,570 --> 01:04:53,610
and now so we're currently in a period

01:04:50,910 --> 01:04:56,610
where a lot of this happens get feedback

01:04:53,610 --> 01:04:58,920
going to a loop with refinements and

01:04:56,610 --> 01:05:01,170
that's all done in the dot e zero

01:04:58,920 --> 01:05:03,090
directs releases so we have every six

01:05:01,170 --> 01:05:05,790
weeks we have a new release of that and

01:05:03,090 --> 01:05:07,200
a lot of poor requests and there's a lot

01:05:05,790 --> 01:05:09,900
of essentially design work and

01:05:07,200 --> 01:05:12,630
implementation work going on and we have

01:05:09,900 --> 01:05:15,270
set ourselves the goal to say by SCARA

01:05:12,630 --> 01:05:16,140
days next year we want to go into

01:05:15,270 --> 01:05:19,830
feature freeze

01:05:16,140 --> 01:05:22,920
so 2019 first half we want to go we want

01:05:19,830 --> 01:05:24,720
to say well it was fun but that's it no

01:05:22,920 --> 01:05:26,790
more language design no more language

01:05:24,720 --> 01:05:28,950
experimentation we are going to ship

01:05:26,790 --> 01:05:31,440
what we have and then we plan to take

01:05:28,950 --> 01:05:34,200
essentially another year for

01:05:31,440 --> 01:05:36,510
stabilization so what that means is we

01:05:34,200 --> 01:05:39,560
have to essentially get more and more

01:05:36,510 --> 01:05:41,940
libraries across working on SCADA three

01:05:39,560 --> 01:05:45,390
essentially discover things that don't

01:05:41,940 --> 01:05:48,750
work fix them so that we are ready to

01:05:45,390 --> 01:05:52,170
ship in again the first half of 2020

01:05:48,750 --> 01:05:55,140
where that's a target date for Scylla

01:05:52,170 --> 01:05:58,110
3-0 from the future freeze on so that

01:05:55,140 --> 01:06:00,210
means 2019 our first half we planned to

01:05:58,110 --> 01:06:02,160
have Scala three developer previews

01:06:00,210 --> 01:06:05,370
where we say ok so this is basically

01:06:02,160 --> 01:06:07,620
what we want to ship we might have to

01:06:05,370 --> 01:06:09,450
fix some things we are interested in

01:06:07,620 --> 01:06:12,180
your reactions and see what we have to

01:06:09,450 --> 01:06:14,730
do but if you want to essentially get

01:06:12,180 --> 01:06:17,700
involved you can get involved now when

01:06:14,730 --> 01:06:21,290
the dot aside or then after the feature

01:06:17,700 --> 01:06:24,300
freeze when it's less experimental

01:06:21,290 --> 01:06:27,360
stability so we have so far our test

01:06:24,300 --> 01:06:29,400
suite Scala 3 test suite incorporates

01:06:27,360 --> 01:06:31,740
most of the SCARA to regression test so

01:06:29,400 --> 01:06:35,370
we have we have that to find out that we

01:06:31,740 --> 01:06:37,410
don't stray there's we are working on a

01:06:35,370 --> 01:06:41,010
community build for core libraries and

01:06:37,410 --> 01:06:42,690
tools that has been held back so far to

01:06:41,010 --> 01:06:44,490
a large degree because there are

01:06:42,690 --> 01:06:46,950
actually very few libraries out there

01:06:44,490 --> 01:06:49,980
that don't rely transitively on macros

01:06:46,950 --> 01:06:51,750
so essentially macros is actually the

01:06:49,980 --> 01:06:53,700
key to get the whole system over and

01:06:51,750 --> 01:06:55,500
that's why we also prioritize

01:06:53,700 --> 01:06:56,630
essentially the the work of meta

01:06:55,500 --> 01:07:00,470
programming to have

01:06:56,630 --> 01:07:04,100
help the macros move over to scatter

01:07:00,470 --> 01:07:08,060
three all tools that we currently have

01:07:04,100 --> 01:07:11,090
as built using scholar to first and then

01:07:08,060 --> 01:07:12,620
again with with the new compiler so the

01:07:11,090 --> 01:07:14,270
new compiler already compiles

01:07:12,620 --> 01:07:17,090
essentially everything that we have as

01:07:14,270 --> 01:07:20,350
tools so in that sense we already have a

01:07:17,090 --> 01:07:23,870
fairly large code base for testing it

01:07:20,350 --> 01:07:25,880
what we plan to do is once essentially

01:07:23,870 --> 01:07:29,330
we have developer previews we would like

01:07:25,880 --> 01:07:31,490
to have essentially core projects in the

01:07:29,330 --> 01:07:34,430
library ecosystems be published for

01:07:31,490 --> 01:07:36,350
scholar 3 and also even before that we

01:07:34,430 --> 01:07:38,650
will use our own compiler as the

01:07:36,350 --> 01:07:41,990
bootstrapping route so that means that

01:07:38,650 --> 01:07:44,330
right now because we built everything

01:07:41,990 --> 01:07:46,310
with Scala - we have to write programs

01:07:44,330 --> 01:07:48,770
in this common subset between Scala - in

01:07:46,310 --> 01:07:50,780
Scala 3 once we don't do that anymore

01:07:48,770 --> 01:07:53,360
and we start with a scholar 3 compiler

01:07:50,780 --> 01:07:55,250
we can actually extensively use all the

01:07:53,360 --> 01:07:57,080
new scholar 3 features and that I think

01:07:55,250 --> 01:07:59,540
is a good good idea because that also

01:07:57,080 --> 01:08:01,760
means we fact we are the first to find

01:07:59,540 --> 01:08:03,410
out if something is not as usable as we

01:08:01,760 --> 01:08:06,590
have had hoped so

01:08:03,410 --> 01:08:09,560
you can try it out today it's at ot EPFL

01:08:06,590 --> 01:08:13,280
dot CH new versions like I said are

01:08:09,560 --> 01:08:15,230
released every six weeks and it's the

01:08:13,280 --> 01:08:17,720
start of the conference so if you have

01:08:15,230 --> 01:08:18,590
questions suggestions or concerns we are

01:08:17,720 --> 01:08:21,140
here

01:08:18,590 --> 01:08:22,820
talk to us any time and we would be very

01:08:21,140 --> 01:08:25,010
interested in essentially what your

01:08:22,820 --> 01:08:27,140
reactions is what you have to say also

01:08:25,010 --> 01:08:29,090
there's a panel to wrap up at the end of

01:08:27,140 --> 01:08:31,400
the conference and there's a book

01:08:29,090 --> 01:08:34,220
signing bill asked me to squeeze this

01:08:31,400 --> 01:08:37,020
thing in so that's tomorrow at lunch

01:08:34,220 --> 01:08:46,689
1:15 2:15 thank you

01:08:37,020 --> 01:08:46,689

YouTube URL: https://www.youtube.com/watch?v=nKZsHZIcReA


