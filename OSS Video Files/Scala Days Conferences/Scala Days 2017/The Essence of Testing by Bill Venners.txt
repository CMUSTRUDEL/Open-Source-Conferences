Title: The Essence of Testing by Bill Venners
Publication date: 2017-06-23
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
After almost ten years of working on ScalaTest, there is still lots of potential for improvement of the library. In this talk, Bill Venners will describe what he has come to believe is the essence of testing, and how he wants to evolve ScalaTest as a result. He will dive into propositional and predicate logic and show how they relate to testing. He'll explain where he thinks property-based testing fits in the big picture, and give demos of some new and exciting features currently being developed for ScalaTest and Scalactic.
Captions: 
	00:00:04,330 --> 00:00:09,469
welcome my name is Bill vinners I'm

00:00:06,890 --> 00:00:14,049
going to start 30 seconds early to give

00:00:09,469 --> 00:00:16,759
you 30 seconds more to ask questions I

00:00:14,049 --> 00:00:19,160
have been I looked it up just this

00:00:16,759 --> 00:00:21,140
morning I've been working on Scala tests

00:00:19,160 --> 00:00:23,840
for over nine years

00:00:21,140 --> 00:00:25,640
the first release which was called 0.9.0

00:00:23,840 --> 00:00:32,260
so it sound like it was already almost

00:00:25,640 --> 00:00:34,580
wonder was January 12 2008

00:00:32,260 --> 00:00:37,610
so next January it'll be 10 year

00:00:34,580 --> 00:00:40,089
anniversary and is used by a lot of

00:00:37,610 --> 00:00:43,930
people and what this talk is about is

00:00:40,089 --> 00:00:48,739
things I've learned over the years as of

00:00:43,930 --> 00:00:49,820
this is June March there was a first

00:00:48,739 --> 00:00:53,720
month where we had a million downloads

00:00:49,820 --> 00:00:55,309
in one month so I was able to tell my

00:00:53,720 --> 00:00:59,210
wife that she had married a million a

00:00:55,309 --> 00:01:02,589
million download air and she didn't seem

00:00:59,210 --> 00:01:07,850
too impressed by that but that's a

00:01:02,589 --> 00:01:09,200
essentially big burden on evolving the

00:01:07,850 --> 00:01:10,730
library because there's there's so much

00:01:09,200 --> 00:01:12,980
code out there you can't just do what

00:01:10,730 --> 00:01:15,140
you want right so what what I wanted to

00:01:12,980 --> 00:01:17,630
do in his talk was talk about an insight

00:01:15,140 --> 00:01:20,150
that I had recently that took many years

00:01:17,630 --> 00:01:21,590
to sort of achieve and then some changes

00:01:20,150 --> 00:01:24,740
we're planning for the library

00:01:21,590 --> 00:01:26,930
that fit in with that insight so it all

00:01:24,740 --> 00:01:27,560
goes back so this guy does anybody know

00:01:26,930 --> 00:01:31,360
who this is

00:01:27,560 --> 00:01:37,040
you recognize this face now he's a

00:01:31,360 --> 00:01:39,620
computer scientist who's probably not

00:01:37,040 --> 00:01:43,520
famous for his faith but for his name is

00:01:39,620 --> 00:01:45,530
Tony Hoare so Tony Hoare wrote a paper

00:01:43,520 --> 00:01:48,080
in 1969 among the other things he did

00:01:45,530 --> 00:01:51,110
called an axiomatic basis for computer

00:01:48,080 --> 00:01:54,200
programming and I think a lot of what

00:01:51,110 --> 00:01:56,630
actually we do goes back to this some of

00:01:54,200 --> 00:01:58,370
the things first came into our discourse

00:01:56,630 --> 00:02:01,810
in computer science from this paper and

00:01:58,370 --> 00:02:04,040
I wanted to point out a few things and

00:02:01,810 --> 00:02:05,840
the reason is I kind of want to go back

00:02:04,040 --> 00:02:07,400
historically to sort of talk about how

00:02:05,840 --> 00:02:11,000
we got to doing testing the way we're

00:02:07,400 --> 00:02:13,810
doing it and to sort of show how I got

00:02:11,000 --> 00:02:16,770
to where I ended up with with my insight

00:02:13,810 --> 00:02:18,810
so what's this paper

00:02:16,770 --> 00:02:20,940
purpose of this paper he said is to

00:02:18,810 --> 00:02:23,550
provide a logical basis for proofs of

00:02:20,940 --> 00:02:25,200
properties of a program and one of the

00:02:23,550 --> 00:02:26,580
most important properties of a program

00:02:25,200 --> 00:02:28,740
is whether or not it carries out its

00:02:26,580 --> 00:02:30,980
intended function so really he was

00:02:28,740 --> 00:02:33,750
trying to get out a way to prove that

00:02:30,980 --> 00:02:35,310
programs are correct essentially that

00:02:33,750 --> 00:02:39,510
they do implement their intended

00:02:35,310 --> 00:02:41,160
function correctly with proof and he

00:02:39,510 --> 00:02:45,920
said the intended function of a program

00:02:41,160 --> 00:02:48,950
or part of a program can be specified by

00:02:45,920 --> 00:02:51,540
making general assertions about the

00:02:48,950 --> 00:02:53,280
values which the relevant variables will

00:02:51,540 --> 00:02:55,500
take after execution of the program

00:02:53,280 --> 00:02:57,060
there's a couple words there that he

00:02:55,500 --> 00:03:00,450
that show up called one of them is

00:02:57,060 --> 00:03:02,100
specify another is assertion so when he

00:03:00,450 --> 00:03:03,900
says assertion he's really there was no

00:03:02,100 --> 00:03:05,220
thing called an assertion in those days

00:03:03,900 --> 00:03:08,100
that through an something called an

00:03:05,220 --> 00:03:12,590
exception so this is really the English

00:03:08,100 --> 00:03:15,120
or human language sense of assertion and

00:03:12,590 --> 00:03:16,740
he says these assertions will not

00:03:15,120 --> 00:03:17,910
usually ascribe particular values to

00:03:16,740 --> 00:03:20,220
each variable so you're not saying

00:03:17,910 --> 00:03:23,270
you're not asserting that you know at

00:03:20,220 --> 00:03:28,320
the end of my execution X will be 12

00:03:23,270 --> 00:03:31,070
what they do rather is specify certain

00:03:28,320 --> 00:03:32,910
general properties about the values and

00:03:31,070 --> 00:03:34,290
relationships between the variables

00:03:32,910 --> 00:03:36,720
holding those properties so you might

00:03:34,290 --> 00:03:38,520
say at the end of executing my program

00:03:36,720 --> 00:03:41,910
or my function which is a part of a

00:03:38,520 --> 00:03:44,100
program X is positive or maybe if

00:03:41,910 --> 00:03:46,380
there's an X and a Y then Y will be

00:03:44,100 --> 00:03:47,340
twice X or something like that you can

00:03:46,380 --> 00:03:48,780
say things like that

00:03:47,340 --> 00:03:50,250
that are more general than it's saying

00:03:48,780 --> 00:03:55,980
exactly X will be this and Y will be

00:03:50,250 --> 00:03:58,020
that and what he said then was he in

00:03:55,980 --> 00:04:00,990
this paper will use the normal notations

00:03:58,020 --> 00:04:03,240
of mathematical logic to express the

00:04:00,990 --> 00:04:04,860
assertion so what he was talking about

00:04:03,240 --> 00:04:06,780
the english-language sense of assertion

00:04:04,860 --> 00:04:11,070
but then what he did is formalized how

00:04:06,780 --> 00:04:16,970
to express an assertion which is using

00:04:11,070 --> 00:04:16,970
logic okay so that was the first piece

00:04:17,000 --> 00:04:21,989
the second piece is he said that it's

00:04:19,350 --> 00:04:26,669
not just at the end of this bit of code

00:04:21,989 --> 00:04:29,790
that you would make an assertion about

00:04:26,669 --> 00:04:30,129
variables but also at the beginning he

00:04:29,790 --> 00:04:32,020
said

00:04:30,129 --> 00:04:33,639
in many cases the validity of the

00:04:32,020 --> 00:04:36,279
results of a program or part of a

00:04:33,639 --> 00:04:38,020
program will depend on the values taken

00:04:36,279 --> 00:04:41,169
by the variables before the program is

00:04:38,020 --> 00:04:42,369
initiated and he called these

00:04:41,169 --> 00:04:46,619
preconditions so that's where that word

00:04:42,369 --> 00:04:50,349
came from these initial preconditions of

00:04:46,619 --> 00:04:52,509
successful use can be specified by the

00:04:50,349 --> 00:04:55,119
same type of general assertion as used

00:04:52,509 --> 00:04:56,469
to describe the results obtained on

00:04:55,119 --> 00:04:58,119
termination so a whole bunch of words

00:04:56,469 --> 00:04:59,830
that show up in Scala tests today are

00:04:58,119 --> 00:05:03,580
show up in this paper right like

00:04:59,830 --> 00:05:07,809
described and specify and assertion so

00:05:03,580 --> 00:05:09,789
what he said is then essentially to

00:05:07,809 --> 00:05:12,729
state the required connection between

00:05:09,789 --> 00:05:13,959
precondition P program Q and a

00:05:12,729 --> 00:05:16,809
description of the result of its

00:05:13,959 --> 00:05:19,869
execution which he called R he has this

00:05:16,809 --> 00:05:21,369
new notation P Q R see that that little

00:05:19,869 --> 00:05:24,129
thing there is his notation and that's

00:05:21,369 --> 00:05:26,919
called a horde triple and what the P is

00:05:24,129 --> 00:05:29,800
is the precondition assertion which he

00:05:26,919 --> 00:05:33,550
uses logic to describe and the R is the

00:05:29,800 --> 00:05:35,229
pose be what he calls the description of

00:05:33,550 --> 00:05:38,229
the result of execution which is also an

00:05:35,229 --> 00:05:39,969
assertion expressed in logic and in Q is

00:05:38,229 --> 00:05:41,919
the action that the program takes so he

00:05:39,969 --> 00:05:43,929
says the way you can interpret this is

00:05:41,919 --> 00:05:45,999
if the assertion P is true before the

00:05:43,929 --> 00:05:48,579
initiation of a program Q or some piece

00:05:45,999 --> 00:05:50,199
of a program like a function then the

00:05:48,579 --> 00:05:53,169
assertion R will be true on its

00:05:50,199 --> 00:05:55,419
completion and if there are no

00:05:53,169 --> 00:05:59,050
preconditions then you just say true Q R

00:05:55,419 --> 00:06:00,929
because true will always be true so that

00:05:59,050 --> 00:06:03,909
always will be met so and no matter what

00:06:00,929 --> 00:06:06,099
what the situation of the planet is when

00:06:03,909 --> 00:06:08,649
you start you can actually execute Q and

00:06:06,099 --> 00:06:10,149
you should see R so anyway that was what

00:06:08,649 --> 00:06:12,669
his paper was about and what he was

00:06:10,149 --> 00:06:16,240
really after was proofs which turned out

00:06:12,669 --> 00:06:22,119
to be quite difficult to do so if you

00:06:16,240 --> 00:06:23,169
fast forward 20 years about maybe 30 I

00:06:22,119 --> 00:06:24,819
don't know quite a few years later

00:06:23,169 --> 00:06:27,069
there's this guy shows up and writes a

00:06:24,819 --> 00:06:30,300
book and a programming language anybody

00:06:27,069 --> 00:06:33,429
know who this is recognize that face

00:06:30,300 --> 00:06:36,129
that guy actually is the guy that taught

00:06:33,429 --> 00:06:38,529
me object into programming when I was a

00:06:36,129 --> 00:06:41,289
youngster I was at a company where they

00:06:38,529 --> 00:06:43,419
were using C and they were had decided

00:06:41,289 --> 00:06:43,630
to use C++ which was object-oriented and

00:06:43,419 --> 00:06:45,430
no

00:06:43,630 --> 00:06:47,050
knew what that meant so they hired this

00:06:45,430 --> 00:06:51,760
guy to come in and give a workshop and

00:06:47,050 --> 00:06:53,350
with this guy that is Bertrand Meyer who

00:06:51,760 --> 00:06:56,770
designed the eiffel programming language

00:06:53,350 --> 00:06:58,900
and he wrote this book so his I took a

00:06:56,770 --> 00:07:01,030
C++ workshop by this guy and he plus

00:06:58,900 --> 00:07:01,800
plus sort of beat Eiffel in the

00:07:01,030 --> 00:07:04,780
marketplace

00:07:01,800 --> 00:07:07,120
so the his workshop was he would show

00:07:04,780 --> 00:07:09,370
examples in Eiffel and then he talked

00:07:07,120 --> 00:07:11,760
about how C++ is like not as good but

00:07:09,370 --> 00:07:15,070
you know because it was a C++ workshop

00:07:11,760 --> 00:07:17,050
and so one of the things that that he

00:07:15,070 --> 00:07:20,470
did and he talks about in his book that

00:07:17,050 --> 00:07:23,830
did not get into C++ was this he goes

00:07:20,470 --> 00:07:26,500
back to that paper from Tony Hoare and

00:07:23,830 --> 00:07:29,770
he talked about paq but he he actually

00:07:26,500 --> 00:07:31,680
changed the name of Q he was now D what

00:07:29,770 --> 00:07:33,820
he called a post condition he named that

00:07:31,680 --> 00:07:35,410
precondition it was a called P and then

00:07:33,820 --> 00:07:37,330
a is the action you take in the middle

00:07:35,410 --> 00:07:41,110
like calling a function or executing a

00:07:37,330 --> 00:07:42,430
program and you move the curly braces to

00:07:41,110 --> 00:07:44,320
so I don't know why all that change but

00:07:42,430 --> 00:07:46,690
in many you know couple decades later it

00:07:44,320 --> 00:07:49,930
looked like that so the idea was and it

00:07:46,690 --> 00:07:51,850
is if X is greater than nine greater

00:07:49,930 --> 00:07:53,980
than equal to nine and that's your

00:07:51,850 --> 00:07:55,360
precondition if you add five to X as

00:07:53,980 --> 00:07:57,010
your action then you can have a post

00:07:55,360 --> 00:08:00,690
condition X is greater than equal to 15

00:07:57,010 --> 00:08:06,370
of 14 it's also greater than equal to 15

00:08:00,690 --> 00:08:08,110
so no it may not be X is greater than

00:08:06,370 --> 00:08:10,470
equal to 14 or its greater than equal to

00:08:08,110 --> 00:08:14,340
13 but anyway this is um

00:08:10,470 --> 00:08:17,080
you know an example of this PAQ idea and

00:08:14,340 --> 00:08:19,450
P and Q are called assertions and what

00:08:17,080 --> 00:08:21,780
he did in Eiffel is said well I'm not

00:08:19,450 --> 00:08:25,090
going to try to prove anything

00:08:21,780 --> 00:08:27,340
what I'm going to do is just test it and

00:08:25,090 --> 00:08:29,670
the way I'm going to test it is is put

00:08:27,340 --> 00:08:34,270
these preconditions and postconditions

00:08:29,670 --> 00:08:37,360
around the body of a function so what he

00:08:34,270 --> 00:08:40,210
has in eiffel is when you create a a

00:08:37,360 --> 00:08:42,490
method or a function you don't just say

00:08:40,210 --> 00:08:44,320
how what the function does you have to

00:08:42,490 --> 00:08:47,020
specify a precondition clause in the

00:08:44,320 --> 00:08:48,520
post condition clause and what he says

00:08:47,020 --> 00:08:49,780
is that that's a specification of

00:08:48,520 --> 00:08:51,580
correctness so it's the same thing 20

00:08:49,780 --> 00:08:53,260
horse said but what Tony Hart was really

00:08:51,580 --> 00:08:56,339
trying to get at was setting up a way to

00:08:53,260 --> 00:08:58,000
prove that code is correct and what

00:08:56,339 --> 00:08:59,290
really

00:08:58,000 --> 00:09:01,210
Meyer was sort of saying as well let's

00:08:59,290 --> 00:09:05,200
forget about proof let's just test it

00:09:01,210 --> 00:09:07,980
for a certain few examples right so this

00:09:05,200 --> 00:09:11,290
is a snapshot of what Eiffel looks like

00:09:07,980 --> 00:09:13,210
and what the do block in the middle

00:09:11,290 --> 00:09:14,950
there that's where you do something

00:09:13,210 --> 00:09:17,140
that's sort of the body of your method

00:09:14,950 --> 00:09:19,600
but you can't just say do you have to

00:09:17,140 --> 00:09:21,310
say require and then that's where you

00:09:19,600 --> 00:09:23,710
put your preconditions so there's a

00:09:21,310 --> 00:09:25,900
square root method so its precondition

00:09:23,710 --> 00:09:28,540
is that the real number X is greater

00:09:25,900 --> 00:09:31,780
than or equal to zero right because you

00:09:28,540 --> 00:09:35,890
can't actually compute a square root on

00:09:31,780 --> 00:09:39,130
a negative number and then there's an

00:09:35,890 --> 00:09:40,840
insurer clause afterwards where he's put

00:09:39,130 --> 00:09:42,610
a post condition and so what in the

00:09:40,840 --> 00:09:44,650
ideal world the post condition for

00:09:42,610 --> 00:09:46,360
square root would be is that you take

00:09:44,650 --> 00:09:48,100
the result and you just you just say

00:09:46,360 --> 00:09:50,380
result in eiffel and it means what is

00:09:48,100 --> 00:09:53,290
going to be returned if this post

00:09:50,380 --> 00:09:55,600
condition succeeds Square it you should

00:09:53,290 --> 00:09:57,280
get back the original write on result is

00:09:55,600 --> 00:09:59,860
the square root of x when I square

00:09:57,280 --> 00:10:04,150
result I should get X but because it's a

00:09:59,860 --> 00:10:06,280
real number in the real world you may

00:10:04,150 --> 00:10:08,680
have a little bit of rounding error

00:10:06,280 --> 00:10:10,950
difference right so what the post

00:10:08,680 --> 00:10:13,330
condition here is you subtract X from

00:10:10,950 --> 00:10:16,960
the square of the results which should

00:10:13,330 --> 00:10:18,430
be zero in an ideal world so then you

00:10:16,960 --> 00:10:19,720
just take the apps' about absolute value

00:10:18,430 --> 00:10:22,210
of s and make it positive it should be a

00:10:19,720 --> 00:10:23,680
positive tiny number and then you just

00:10:22,210 --> 00:10:25,660
see that that's less than or equal to a

00:10:23,680 --> 00:10:27,580
tolerance and that's your post condition

00:10:25,660 --> 00:10:28,270
so Eiffel made you actually every time

00:10:27,580 --> 00:10:31,600
you write a method

00:10:28,270 --> 00:10:33,660
think about preconditions and

00:10:31,600 --> 00:10:40,420
postconditions that sort of specify your

00:10:33,660 --> 00:10:45,180
your dewclaws right next to it and so

00:10:40,420 --> 00:10:49,000
that's that's what he did in eiffel and

00:10:45,180 --> 00:10:50,770
you can actually do that in scala most

00:10:49,000 --> 00:10:53,920
people don't know this but there's a an

00:10:50,770 --> 00:10:55,420
assumed and an ensuring method that you

00:10:53,920 --> 00:10:57,700
can use anywhere in your code

00:10:55,420 --> 00:11:02,380
it's from pre dip and I'll give you a

00:10:57,700 --> 00:11:06,130
quick demo this is just scholars assert

00:11:02,380 --> 00:11:09,730
if I say Val X equals one and I say

00:11:06,130 --> 00:11:11,230
assert X is greater than zero that's

00:11:09,730 --> 00:11:11,810
going to succeed I just get the unit

00:11:11,230 --> 00:11:14,449
value back

00:11:11,810 --> 00:11:17,149
if I say X or X is less than zero this

00:11:14,449 --> 00:11:19,009
is again this is the assert in pre def

00:11:17,149 --> 00:11:22,509
that's just sort of there by default in

00:11:19,009 --> 00:11:26,480
Scala if there was assertion error right

00:11:22,509 --> 00:11:30,470
so what you can say instead is assume

00:11:26,480 --> 00:11:32,059
and assume and you get the same behavior

00:11:30,470 --> 00:11:33,559
that mean exactly the same thing it's

00:11:32,059 --> 00:11:36,230
just assumed was intended for

00:11:33,559 --> 00:11:38,990
precondition checks an assert was more

00:11:36,230 --> 00:11:41,240
general use it anywhere so kind of at

00:11:38,990 --> 00:11:43,009
the beginning of the method here that's

00:11:41,240 --> 00:11:44,540
very rude I'm saying I'm assuming X is

00:11:43,009 --> 00:11:48,259
greater than equal to zero and I'm suing

00:11:44,540 --> 00:11:49,999
it's not infinite and so that's that's

00:11:48,259 --> 00:11:52,009
assumed and then there's one called

00:11:49,999 --> 00:11:56,240
insuring which you can call on anything

00:11:52,009 --> 00:11:59,509
so I'm going to call it on 42 which is

00:11:56,240 --> 00:12:01,699
my favorite number so dot insuring

00:11:59,509 --> 00:12:05,300
that's added with an implicit conversion

00:12:01,699 --> 00:12:09,709
to any type and then one insuring takes

00:12:05,300 --> 00:12:12,319
is an assertion function it's going to

00:12:09,709 --> 00:12:15,529
be passed the value you called insuring

00:12:12,319 --> 00:12:17,389
on so this is going to pass 42 into the

00:12:15,529 --> 00:12:21,439
function and then I can say whoops I

00:12:17,389 --> 00:12:23,449
greater than zero which is true so when

00:12:21,439 --> 00:12:25,579
that assertion succeeds it actually

00:12:23,449 --> 00:12:28,490
returns 42 it returns what you called

00:12:25,579 --> 00:12:31,759
insuring on if it fails then it throws

00:12:28,490 --> 00:12:37,339
assertion error and one of the idea is

00:12:31,759 --> 00:12:39,920
that that ISIL had was that you could

00:12:37,339 --> 00:12:41,899
turn these off if you want so what he

00:12:39,920 --> 00:12:46,519
was doing is he's mixing test code sort

00:12:41,899 --> 00:12:48,740
of in the production code so his idea

00:12:46,519 --> 00:12:52,009
was that you would have these assertions

00:12:48,740 --> 00:12:54,559
enabled during development and during

00:12:52,009 --> 00:12:57,259
sqa but you would turn them off at

00:12:54,559 --> 00:12:59,949
runtime because they can be slow and or

00:12:57,259 --> 00:13:01,970
turn some of them off and he has very

00:12:59,949 --> 00:13:03,290
fine-grain ways of turning these things

00:13:01,970 --> 00:13:05,929
on and off you can show them off by

00:13:03,290 --> 00:13:07,490
class you can turn off just post

00:13:05,929 --> 00:13:09,860
conditions and leave on preconditions

00:13:07,490 --> 00:13:12,290
and that's the default so the default in

00:13:09,860 --> 00:13:14,959
Eiffel was that you leave the

00:13:12,290 --> 00:13:16,339
preconditions in there but you turn off

00:13:14,959 --> 00:13:19,309
the post conditions that's that was a

00:13:16,339 --> 00:13:21,679
default and that turns out to be what

00:13:19,309 --> 00:13:23,889
people did in in the marketplace of

00:13:21,679 --> 00:13:23,889
ideas

00:13:24,060 --> 00:13:28,680
we tend to not do this and by the way

00:13:26,310 --> 00:13:31,340
that the example of ensuring here I do

00:13:28,680 --> 00:13:33,750
my body which is math a square with X

00:13:31,340 --> 00:13:34,980
and so with this I mean map that square

00:13:33,750 --> 00:13:37,140
root already computes the square root

00:13:34,980 --> 00:13:39,660
but if you pass in a negative number you

00:13:37,140 --> 00:13:41,670
get not a number right so what this

00:13:39,660 --> 00:13:43,290
method does different is if you pass in

00:13:41,670 --> 00:13:46,260
a negative number it throws assertion

00:13:43,290 --> 00:13:48,230
error so anyway I call the math that

00:13:46,260 --> 00:13:51,900
square root and then I say ensuring and

00:13:48,230 --> 00:13:53,310
now whatever that was computed is going

00:13:51,900 --> 00:13:56,100
to be passed into this function it

00:13:53,310 --> 00:13:59,160
calculates the tolerance which is ULP

00:13:56,100 --> 00:14:00,690
method like if the double numbers this

00:13:59,160 --> 00:14:02,040
long in decimal points there will be a

00:14:00,690 --> 00:14:05,040
one out here that's unit in the last

00:14:02,040 --> 00:14:06,690
place that's my tolerance check and then

00:14:05,040 --> 00:14:08,730
you just square the result subtract the

00:14:06,690 --> 00:14:11,040
X that should be zero or close to zero

00:14:08,730 --> 00:14:11,760
you take the absolute value and compare

00:14:11,040 --> 00:14:13,380
with tolerance

00:14:11,760 --> 00:14:15,390
all right that's that's it Bertrand MA

00:14:13,380 --> 00:14:16,830
rifle way of doing designed by contract

00:14:15,390 --> 00:14:18,990
testing essentially you put in your

00:14:16,830 --> 00:14:20,640
production code and in Scala you can

00:14:18,990 --> 00:14:23,460
turn these off as assumed can be turned

00:14:20,640 --> 00:14:24,960
off ensuring can be turned off it can be

00:14:23,460 --> 00:14:27,240
alighted in your production code if you

00:14:24,960 --> 00:14:29,400
want but not many people do that

00:14:27,240 --> 00:14:33,210
what we do instead is this and this is

00:14:29,400 --> 00:14:35,640
from the Java community what what they

00:14:33,210 --> 00:14:37,800
did was they didn't do designed by

00:14:35,640 --> 00:14:40,950
contract either so C++ didn't do it and

00:14:37,800 --> 00:14:42,390
Java didn't do it what Java did is they

00:14:40,950 --> 00:14:44,490
checked preconditions but there was no

00:14:42,390 --> 00:14:46,530
way to turn them off and we didn't throw

00:14:44,490 --> 00:14:47,970
assertion error we would throw things

00:14:46,530 --> 00:14:49,470
like illegal argument exception or

00:14:47,970 --> 00:14:51,060
illegal state exception or string index

00:14:49,470 --> 00:14:55,230
out of bounds exception some subtype of

00:14:51,060 --> 00:14:57,390
one of those and never turn it off so

00:14:55,230 --> 00:14:59,070
that's where require came actually into

00:14:57,390 --> 00:15:00,620
Scala when we were writing the chapter

00:14:59,070 --> 00:15:05,130
in the book about all this stuff about

00:15:00,620 --> 00:15:06,690
assertions and tests and you know what

00:15:05,130 --> 00:15:08,850
was in Scala at the time was assume

00:15:06,690 --> 00:15:11,220
which was sort of the Eiffel Way and

00:15:08,850 --> 00:15:13,200
what we thought made sense to put into

00:15:11,220 --> 00:15:14,760
Scala was something that was the java

00:15:13,200 --> 00:15:17,790
way which is required that's where we're

00:15:14,760 --> 00:15:19,170
car came from and then we just don't

00:15:17,790 --> 00:15:22,890
check the post condition anything goes

00:15:19,170 --> 00:15:25,380
right except we check it in tests so we

00:15:22,890 --> 00:15:27,330
have this thing off to the side that

00:15:25,380 --> 00:15:28,920
checks the post condition so this one

00:15:27,330 --> 00:15:30,900
and it's using some kind of example so

00:15:28,920 --> 00:15:33,780
should compute it should compute the

00:15:30,900 --> 00:15:36,980
square root is like a specification of

00:15:33,780 --> 00:15:39,770
the expected behavior in human language

00:15:36,980 --> 00:15:41,030
and then we just try various examples so

00:15:39,770 --> 00:15:43,880
here I'm just computing the square root

00:15:41,030 --> 00:15:45,080
of 42 and that does pass the

00:15:43,880 --> 00:15:48,230
precondition check which is in the

00:15:45,080 --> 00:15:50,660
method and there require and then I do

00:15:48,230 --> 00:15:52,220
the tolerance and I do that post

00:15:50,660 --> 00:15:55,700
condition check so that's what actually

00:15:52,220 --> 00:15:57,170
one that's what everybody does very few

00:15:55,700 --> 00:15:58,520
people do the design by contract thing

00:15:57,170 --> 00:16:05,270
or even know those methods are there in

00:15:58,520 --> 00:16:06,920
Scala so what what I think happened is

00:16:05,270 --> 00:16:09,250
that designed by contract loss of

00:16:06,920 --> 00:16:12,140
test-driven development

00:16:09,250 --> 00:16:15,440
Javad took you know really had this huge

00:16:12,140 --> 00:16:18,140
uptake and it didn't have designed a

00:16:15,440 --> 00:16:19,700
contract in it and Kent Beck and Erich

00:16:18,140 --> 00:16:22,100
gamma made J unit and went around to

00:16:19,700 --> 00:16:23,540
accomplices and really promoted it and

00:16:22,100 --> 00:16:25,730
promoted the idea test and development

00:16:23,540 --> 00:16:27,710
they made books and so that's actually

00:16:25,730 --> 00:16:32,410
kind of what one on the marketplace of

00:16:27,710 --> 00:16:36,080
ideas so instead of this now this is

00:16:32,410 --> 00:16:40,790
this is going back to Bertrand Meijer

00:16:36,080 --> 00:16:42,410
take on Tony horse idea of paq and what

00:16:40,790 --> 00:16:43,580
Bertrand Mar did differently was he said

00:16:42,410 --> 00:16:46,760
well let's not try to prove anything

00:16:43,580 --> 00:16:50,180
let's just tested but he still was going

00:16:46,760 --> 00:16:51,800
after that you know you you uh you know

00:16:50,180 --> 00:16:54,350
in the method body you can see the

00:16:51,800 --> 00:16:56,630
method body is just a PA and a Q the P

00:16:54,350 --> 00:16:58,490
is the assumed the a is the math about

00:16:56,630 --> 00:17:02,810
square root and then the insuring is the

00:16:58,490 --> 00:17:06,020
Q part right so what we do is we do PA

00:17:02,810 --> 00:17:07,370
true which we do actually have the

00:17:06,020 --> 00:17:10,459
preconditions we put those require

00:17:07,370 --> 00:17:13,030
clauses in there and then we of course

00:17:10,459 --> 00:17:16,520
have the a that's our body of our method

00:17:13,030 --> 00:17:18,589
and then we just let anything goes we

00:17:16,520 --> 00:17:21,170
don't do any post condition check here

00:17:18,589 --> 00:17:23,540
and then what we do is over in this

00:17:21,170 --> 00:17:29,290
other place called the tests we check

00:17:23,540 --> 00:17:32,540
the post conditions on some examples so

00:17:29,290 --> 00:17:36,080
what I did in this case is I said for

00:17:32,540 --> 00:17:40,250
all so this one says for all X column it

00:17:36,080 --> 00:17:44,300
doubles X whenever X is greater than

00:17:40,250 --> 00:17:47,650
equal 0 and is non positive it's not

00:17:44,300 --> 00:17:49,850
positive infinity I mean then that

00:17:47,650 --> 00:17:51,280
matches the precondition right that's

00:17:49,850 --> 00:17:53,780
the P

00:17:51,280 --> 00:17:55,520
then I have the a right there square

00:17:53,780 --> 00:17:57,020
root of x and then I have the Q which is

00:17:55,520 --> 00:18:02,030
the post condition check so that's

00:17:57,020 --> 00:18:06,440
that's what we do so what the for all

00:18:02,030 --> 00:18:08,660
does is it it actually makes it a spec

00:18:06,440 --> 00:18:11,540
and I'm going to show you what I'm going

00:18:08,660 --> 00:18:18,500
to go back up the Eiffel here a sec boom

00:18:11,540 --> 00:18:21,260
so when you just say PA Q here no matter

00:18:18,500 --> 00:18:23,360
what X is passed in you know if X is

00:18:21,260 --> 00:18:24,770
greater than or equal 0 then if the

00:18:23,360 --> 00:18:28,040
ensure Clause should be true right so

00:18:24,770 --> 00:18:31,400
it's for any X that's passed in that's a

00:18:28,040 --> 00:18:35,120
double so that when you move it if it's

00:18:31,400 --> 00:18:39,020
inside the method like this then then PA

00:18:35,120 --> 00:18:40,670
Q makes sense right but inside a test to

00:18:39,020 --> 00:18:43,220
actually make that a specification of

00:18:40,670 --> 00:18:46,700
behavior you need to say for all doubles

00:18:43,220 --> 00:18:48,860
X you know if I just say for 42 what

00:18:46,700 --> 00:18:50,090
I've specified here is that when X is 42

00:18:48,860 --> 00:18:51,770
this should be true which isn't really

00:18:50,090 --> 00:18:53,210
specifying the full behavior of the

00:18:51,770 --> 00:18:57,620
square root method right so you need it

00:18:53,210 --> 00:18:58,880
for all to get a specification of

00:18:57,620 --> 00:19:00,260
correctness once you're doing this other

00:18:58,880 --> 00:19:01,760
way which is you know not designed by

00:19:00,260 --> 00:19:09,320
contract but writing tests off the

00:19:01,760 --> 00:19:11,330
outside okay so what the thing is is

00:19:09,320 --> 00:19:13,700
that for all sound queueing a little bit

00:19:11,330 --> 00:19:15,500
like predicate logic also so I wanted to

00:19:13,700 --> 00:19:20,300
talk a little bit about logic so this is

00:19:15,500 --> 00:19:23,990
um just a mathematical way to prove

00:19:20,300 --> 00:19:25,760
things and it has a very few moving

00:19:23,990 --> 00:19:28,760
parts here and you're familiar with most

00:19:25,760 --> 00:19:30,590
of them the thing that looks like an a

00:19:28,760 --> 00:19:33,200
without the line through it is is the

00:19:30,590 --> 00:19:35,300
conjunction that means and if you turn

00:19:33,200 --> 00:19:39,410
it upside down that's disjunction that

00:19:35,300 --> 00:19:43,580
means or and then the sideways L is a

00:19:39,410 --> 00:19:45,890
knot so right there that bit is boolean

00:19:43,580 --> 00:19:49,790
logic so bluey logic is a subset of

00:19:45,890 --> 00:19:52,100
predicate logic and then in predicate

00:19:49,790 --> 00:19:54,260
logic you can also have variables so X Y

00:19:52,100 --> 00:19:57,890
Z and you can have something called a

00:19:54,260 --> 00:19:59,360
predicate so this one ppq whatever you

00:19:57,890 --> 00:20:01,850
want to call them that is like a

00:19:59,360 --> 00:20:03,740
function that takes some variables and

00:20:01,850 --> 00:20:04,300
returns either true or false

00:20:03,740 --> 00:20:07,120
so in

00:20:04,300 --> 00:20:09,640
Scala we call mentions that do that

00:20:07,120 --> 00:20:11,080
predicates like filter take the

00:20:09,640 --> 00:20:13,690
predicate right it's a function that

00:20:11,080 --> 00:20:16,120
takes X Y whatever and returns true or

00:20:13,690 --> 00:20:18,580
false and then there's also just plain

00:20:16,120 --> 00:20:20,140
old functions like F and G H whatever

00:20:18,580 --> 00:20:22,870
you want to call them that take

00:20:20,140 --> 00:20:24,730
variables and return a value so it's

00:20:22,870 --> 00:20:26,380
just like a regular function in Scala so

00:20:24,730 --> 00:20:28,480
you can say that in predicate logic and

00:20:26,380 --> 00:20:31,390
then there's two quantifiers the

00:20:28,480 --> 00:20:35,620
universal quantifier means for all so

00:20:31,390 --> 00:20:37,510
there's it's an upside-down a and the

00:20:35,620 --> 00:20:40,510
existential quantifier means there

00:20:37,510 --> 00:20:42,550
exists right is a backwards e so the

00:20:40,510 --> 00:20:44,890
mathematicians love to do like turn

00:20:42,550 --> 00:20:47,110
letters around and whatnot so if you say

00:20:44,890 --> 00:20:52,060
like this one right here the second from

00:20:47,110 --> 00:20:54,790
the bottom for all x and y the predicate

00:20:52,060 --> 00:20:57,160
P will be true for x and y that's that's

00:20:54,790 --> 00:20:58,960
a statement you can make in predicate

00:20:57,160 --> 00:21:01,300
logic and then the second one is for all

00:20:58,960 --> 00:21:04,480
X there exists a Y such that the

00:21:01,300 --> 00:21:06,370
predicate P holter x and y okay so you

00:21:04,480 --> 00:21:08,980
can make things statements like that and

00:21:06,370 --> 00:21:11,200
then what you do that usually is so that

00:21:08,980 --> 00:21:14,170
you can prove things so you relate like

00:21:11,200 --> 00:21:16,120
some English statements to a formula and

00:21:14,170 --> 00:21:17,560
present logic and then you do some

00:21:16,120 --> 00:21:19,510
mathematical transformation then you

00:21:17,560 --> 00:21:23,140
prove another statement that you can

00:21:19,510 --> 00:21:24,700
then say in English so that's everything

00:21:23,140 --> 00:21:26,620
if predicate logic there are two other

00:21:24,700 --> 00:21:29,740
symbols you often see that are you can

00:21:26,620 --> 00:21:32,430
derive from these one is called

00:21:29,740 --> 00:21:35,140
conditional which is a right arrow and

00:21:32,430 --> 00:21:37,420
or implicit implication the other way to

00:21:35,140 --> 00:21:41,050
say that and that's really if-then so if

00:21:37,420 --> 00:21:42,070
F is true then G is true and then if you

00:21:41,050 --> 00:21:44,080
have the arrow going in both directions

00:21:42,070 --> 00:21:45,400
that's the by conditional or means

00:21:44,080 --> 00:21:49,060
equivalent

00:21:45,400 --> 00:21:50,860
that's if and only if so if F is true

00:21:49,060 --> 00:21:52,390
then G is true if G is true then F is

00:21:50,860 --> 00:21:55,360
true otherwise they're both false

00:21:52,390 --> 00:21:57,990
right they have to be the same as each

00:21:55,360 --> 00:22:04,210
other and that's everything

00:21:57,990 --> 00:22:09,760
so what going back to this I noticed was

00:22:04,210 --> 00:22:11,860
that for all I mean if you starts to

00:22:09,760 --> 00:22:15,490
smell like a statement of logic like

00:22:11,860 --> 00:22:16,720
this is a test and it has a for all on

00:22:15,490 --> 00:22:17,660
the outside so it kind of looks like

00:22:16,720 --> 00:22:19,130
this

00:22:17,660 --> 00:22:20,450
one down here where there's a fir all on

00:22:19,130 --> 00:22:23,210
the outside but what's on the inside

00:22:20,450 --> 00:22:26,210
isn't logic if it's PAQ because like

00:22:23,210 --> 00:22:28,820
this whenever is one statement of credit

00:22:26,210 --> 00:22:31,220
logic then when I call square root it's

00:22:28,820 --> 00:22:32,720
the a which isn't predicate logic and

00:22:31,220 --> 00:22:36,440
then the Q part is another statement of

00:22:32,720 --> 00:22:38,360
predicate logic so what the inside I had

00:22:36,440 --> 00:22:40,810
was was that if you go back to Tony

00:22:38,360 --> 00:22:43,280
horse paper from 1969 he has this little

00:22:40,810 --> 00:22:44,990
bit in it when he introduces this

00:22:43,280 --> 00:22:47,900
notation he says this may be interpreted

00:22:44,990 --> 00:22:50,300
if the assertion P is true before the

00:22:47,900 --> 00:22:51,800
initiation of a program Q then the

00:22:50,300 --> 00:22:52,220
assertion R will be true on its

00:22:51,800 --> 00:22:57,410
completion

00:22:52,220 --> 00:22:59,240
so that says if then basically the way

00:22:57,410 --> 00:23:02,810
you can read it a triple is it's been

00:22:59,240 --> 00:23:06,020
which is implication

00:23:02,810 --> 00:23:10,970
so that is predicate logic so what

00:23:06,020 --> 00:23:12,920
basically I realize is once you sort of

00:23:10,970 --> 00:23:16,640
like designed by contract had PA Q in it

00:23:12,920 --> 00:23:20,060
which was a way to specify behavior but

00:23:16,640 --> 00:23:23,240
then not prove but test when you move

00:23:20,060 --> 00:23:26,150
things off the side it was kind of a

00:23:23,240 --> 00:23:28,550
hybrid of predicate logic unless you

00:23:26,150 --> 00:23:31,540
think of that if then as part of it and

00:23:28,550 --> 00:23:33,260
then you can have each test be

00:23:31,540 --> 00:23:36,440
represented or thought of as one

00:23:33,260 --> 00:23:40,480
statement of logic so it's like for all

00:23:36,440 --> 00:23:42,620
X px implies Q X that's sort of the a

00:23:40,480 --> 00:23:45,320
single logical statement that would

00:23:42,620 --> 00:23:47,510
represent that one test so it's kind of

00:23:45,320 --> 00:23:51,020
like a formal formalizing what a

00:23:47,510 --> 00:23:53,450
specification means so in the case of

00:23:51,020 --> 00:23:55,760
the square root function I might say X

00:23:53,450 --> 00:23:59,750
is an element of the double set the set

00:23:55,760 --> 00:24:02,030
of all possible doubles px when you sort

00:23:59,750 --> 00:24:05,840
of what that means in English is that X

00:24:02,030 --> 00:24:07,430
is positive and non infinite and then Q

00:24:05,840 --> 00:24:09,830
X here's the trick what you have to do

00:24:07,430 --> 00:24:13,340
to get like one statement of logic out

00:24:09,830 --> 00:24:16,070
of this is take the a and make it part

00:24:13,340 --> 00:24:19,760
of the Q essentially so my Q actually

00:24:16,070 --> 00:24:22,310
mentions calling square root of x so I

00:24:19,760 --> 00:24:28,340
say Q means whenever I call the square

00:24:22,310 --> 00:24:30,370
root of x when you square it that's

00:24:28,340 --> 00:24:31,670
going to be equal to the original value

00:24:30,370 --> 00:24:34,550
passed into

00:24:31,670 --> 00:24:37,910
we're rude plus or minus a tolerance so

00:24:34,550 --> 00:24:41,840
so anyway I think that's what a test is

00:24:37,910 --> 00:24:44,570
and what it kind of does is it we call a

00:24:41,840 --> 00:24:47,090
lot of things spec in Scala test like

00:24:44,570 --> 00:24:49,670
funds back or flat spec and when you

00:24:47,090 --> 00:24:51,050
write the the name of the test you might

00:24:49,670 --> 00:24:53,180
say it should compute the square root

00:24:51,050 --> 00:24:57,770
that's a specification but at the level

00:24:53,180 --> 00:25:00,140
of human language then in the body if

00:24:57,770 --> 00:25:08,390
you use a for all then what you get is

00:25:00,140 --> 00:25:11,660
actually a specification in logic so so

00:25:08,390 --> 00:25:13,490
that's it so then what Bertrand Meyer

00:25:11,660 --> 00:25:14,870
said in his book when he was talking

00:25:13,490 --> 00:25:20,420
about how he implemented this stuff in

00:25:14,870 --> 00:25:23,540
Eiffel is that the assertion language in

00:25:20,420 --> 00:25:24,980
Eiffel is only part of the power of the

00:25:23,540 --> 00:25:26,480
full predicate calculus and I showed you

00:25:24,980 --> 00:25:29,180
all the full predicate calculus there's

00:25:26,480 --> 00:25:33,980
not that many pieces to it right so what

00:25:29,180 --> 00:25:36,350
he has for example is and so there's a

00:25:33,980 --> 00:25:39,290
there's a conjunction in predicate logic

00:25:36,350 --> 00:25:42,350
and you actually get that when you're

00:25:39,290 --> 00:25:48,080
using these assertions that that kind of

00:25:42,350 --> 00:25:53,090
came in at this time where they throw an

00:25:48,080 --> 00:25:55,910
exception right because since we're not

00:25:53,090 --> 00:25:57,590
trying to prove anything what we're

00:25:55,910 --> 00:26:00,380
really doing is looking for bugs we're

00:25:57,590 --> 00:26:03,440
kind of doing science we're trying it

00:26:00,380 --> 00:26:06,230
and if we find a place where the

00:26:03,440 --> 00:26:08,120
specification is not met that is finding

00:26:06,230 --> 00:26:09,380
a bug and the program can't really

00:26:08,120 --> 00:26:12,080
proceed when you find a bug because

00:26:09,380 --> 00:26:14,720
until we can tell programs can rewrite

00:26:12,080 --> 00:26:16,400
themselves and fix their own bugs some

00:26:14,720 --> 00:26:17,540
human has come in later and fix that bug

00:26:16,400 --> 00:26:19,130
right so the best thing you do is just

00:26:17,540 --> 00:26:21,190
get out whether you're actually running

00:26:19,130 --> 00:26:24,500
in production or like executing a test

00:26:21,190 --> 00:26:26,750
get out and give people a nice stack

00:26:24,500 --> 00:26:30,440
trace that shows them how they got there

00:26:26,750 --> 00:26:34,360
and maybe it has a error message that

00:26:30,440 --> 00:26:36,680
gives a hint at what went wrong so when

00:26:34,360 --> 00:26:37,280
when I say D count should be greater

00:26:36,680 --> 00:26:39,470
than zero

00:26:37,280 --> 00:26:42,230
and then in the next line I say D value

00:26:39,470 --> 00:26:43,940
should not be empty there's an implied

00:26:42,230 --> 00:26:45,250
semicolon between those two and that

00:26:43,940 --> 00:26:47,440
semicolon is like an

00:26:45,250 --> 00:26:49,570
just like a conjunction because both of

00:26:47,440 --> 00:26:52,510
these have to be true for them to pass

00:26:49,570 --> 00:26:53,770
and if the first one is full it actually

00:26:52,510 --> 00:26:55,960
throws an exception there and never

00:26:53,770 --> 00:26:57,730
excuse the second one which is like a

00:26:55,960 --> 00:26:59,050
boolean expression that short-circuits

00:26:57,730 --> 00:27:00,310
right it does the first one if that's

00:26:59,050 --> 00:27:04,990
already false it doesn't even execute

00:27:00,310 --> 00:27:07,210
the second one right so if the first one

00:27:04,990 --> 00:27:10,180
is true then it's going to try the

00:27:07,210 --> 00:27:11,980
second one and if that's false then the

00:27:10,180 --> 00:27:15,130
whole thing is false the whole thing is

00:27:11,980 --> 00:27:18,190
an error otherwise it's okay so that's

00:27:15,130 --> 00:27:20,620
that's you get and but you don't get or

00:27:18,190 --> 00:27:22,150
and in Eiffel you don't have for all or

00:27:20,620 --> 00:27:25,620
exist right those pieces are not there

00:27:22,150 --> 00:27:27,910
so one of the things that had been

00:27:25,620 --> 00:27:29,410
noticed in Scala tests and that people

00:27:27,910 --> 00:27:32,770
have requested over over time

00:27:29,410 --> 00:27:37,270
occasionally is a way to or mashers so

00:27:32,770 --> 00:27:39,100
if this this person was saying would be

00:27:37,270 --> 00:27:41,320
really nice if you could say d dot count

00:27:39,100 --> 00:27:44,110
should be greater than 0 or D that value

00:27:41,320 --> 00:27:46,930
should not be empty right so you can't

00:27:44,110 --> 00:27:48,430
say that currently in Scala test and you

00:27:46,930 --> 00:27:51,580
could implement that in Scala you could

00:27:48,430 --> 00:27:53,200
make something like an or that catches

00:27:51,580 --> 00:27:55,570
the exception on the left and retries

00:27:53,200 --> 00:27:58,810
out on the right but I just thought that

00:27:55,570 --> 00:28:02,260
was a abuse exception abuse I really

00:27:58,810 --> 00:28:04,300
thought that was going too far so I

00:28:02,260 --> 00:28:07,270
never did that I closed that one said

00:28:04,300 --> 00:28:09,760
sorry no but it is I mean he has a point

00:28:07,270 --> 00:28:11,740
it is useful to say that sometimes right

00:28:09,760 --> 00:28:13,090
I mean what he's saying is very valid

00:28:11,740 --> 00:28:15,250
this should be true or that should be

00:28:13,090 --> 00:28:18,790
true and I don't care which one and you

00:28:15,250 --> 00:28:24,430
can't say that it matters so what I did

00:28:18,790 --> 00:28:26,140
do kind of over many years was add

00:28:24,430 --> 00:28:29,500
something called expectations or fact

00:28:26,140 --> 00:28:31,360
which is a kind of assertion that

00:28:29,500 --> 00:28:37,630
returns a result rather than throwing an

00:28:31,360 --> 00:28:39,520
exception and what the name of the type

00:28:37,630 --> 00:28:43,990
is fact so it's kind of like boolean

00:28:39,520 --> 00:28:45,820
plus plus and then there's a type alias

00:28:43,990 --> 00:28:48,430
from expectation to fact so expectation

00:28:45,820 --> 00:28:51,340
effects mean the same thing so what

00:28:48,430 --> 00:28:53,860
when you say assert in Scala test that

00:28:51,340 --> 00:28:55,840
has type assertion and if it succeeds it

00:28:53,860 --> 00:28:57,430
returns succeeded if it fails it throws

00:28:55,840 --> 00:29:02,050
test failed exception so let me show

00:28:57,430 --> 00:29:04,420
that so this is this is a version of

00:29:02,050 --> 00:29:07,750
celsus it's in a branch that is like

00:29:04,420 --> 00:29:11,140
will probably be 4.0 I think so if I say

00:29:07,750 --> 00:29:14,620
assert while I need to make an ex Val

00:29:11,140 --> 00:29:16,150
one assert X is greater than zero so

00:29:14,620 --> 00:29:17,440
this is Scala set assert so you don't

00:29:16,150 --> 00:29:20,890
get the unit value back you get a

00:29:17,440 --> 00:29:22,510
succeeded singleton back and that has

00:29:20,890 --> 00:29:25,900
type of certian and that's a type alias

00:29:22,510 --> 00:29:28,030
the assertion is actually just not a

00:29:25,900 --> 00:29:28,720
Bailey's that's a trait but anyway they

00:29:28,030 --> 00:29:30,760
mean the same thing

00:29:28,720 --> 00:29:33,610
the only kind of assertion you can have

00:29:30,760 --> 00:29:36,010
is succeeded it's sealed if I say

00:29:33,610 --> 00:29:38,140
something that doesn't work out I get a

00:29:36,010 --> 00:29:40,360
test failed exception not assertion

00:29:38,140 --> 00:29:42,190
error and and I get an error message so

00:29:40,360 --> 00:29:46,660
the macro will look in there and say one

00:29:42,190 --> 00:29:51,160
was not less than zero so that has the

00:29:46,660 --> 00:29:52,060
same features as assertions ins Eiffel

00:29:51,160 --> 00:29:53,320
they're the same thing they draw an

00:29:52,060 --> 00:29:56,230
exception so you get an B's you don't

00:29:53,320 --> 00:29:58,270
get or so if you say expect that doesn't

00:29:56,230 --> 00:30:00,810
mean anything in Scala test unless you

00:29:58,270 --> 00:30:00,810
import it

00:30:02,340 --> 00:30:08,340
so I long ago deprecated expect there

00:30:06,400 --> 00:30:10,870
used to be an expectant Scala test

00:30:08,340 --> 00:30:12,280
because I thought you know it'd be

00:30:10,870 --> 00:30:13,660
should look different if one of them

00:30:12,280 --> 00:30:16,750
returns a result and one of them throws

00:30:13,660 --> 00:30:18,880
an exception they shouldn't be a mode of

00:30:16,750 --> 00:30:20,620
assert that should like a search should

00:30:18,880 --> 00:30:22,990
always throw an exception and then this

00:30:20,620 --> 00:30:29,650
other thing would always return a result

00:30:22,990 --> 00:30:31,900
so what it does return is basically a

00:30:29,650 --> 00:30:33,430
fact is either a yes or a no with an

00:30:31,900 --> 00:30:36,130
it's like a boolean with an error

00:30:33,430 --> 00:30:38,920
message in it that remembers a fact that

00:30:36,130 --> 00:30:39,940
was observed about the universe so it's

00:30:38,920 --> 00:30:45,120
either a yes or a No

00:30:39,940 --> 00:30:48,310
so in this case I got a yes back because

00:30:45,120 --> 00:30:50,470
it turns out my expectation was that X

00:30:48,310 --> 00:30:52,060
is greater than equal to was greater

00:30:50,470 --> 00:30:55,420
than zero and yes one was greater than

00:30:52,060 --> 00:30:58,300
zero if I do a negative one I don't get

00:30:55,420 --> 00:30:59,740
an assertion I get a no so it's either a

00:30:58,300 --> 00:31:04,270
yes or no so it's like two or false

00:30:59,740 --> 00:31:06,130
right but with an error message so this

00:31:04,270 --> 00:31:08,440
one says well the fact which I observed

00:31:06,130 --> 00:31:10,390
was that one was not less than zero the

00:31:08,440 --> 00:31:10,990
yes and no means whether it was what I

00:31:10,390 --> 00:31:14,530
expected

00:31:10,990 --> 00:31:18,730
not and then the fact is actually a

00:31:14,530 --> 00:31:22,570
statement of fact so I can basically

00:31:18,730 --> 00:31:24,910
negate the yes and no means whether or

00:31:22,570 --> 00:31:29,350
not my expectation was met the English

00:31:24,910 --> 00:31:33,790
statement says what we observed okay so

00:31:29,350 --> 00:31:37,679
that's expectations so what it does is

00:31:33,790 --> 00:31:37,679
it just implements full predicate logic

00:31:38,580 --> 00:31:44,650
so there's a the first five convincers

00:31:42,940 --> 00:31:46,390
are just like boolean they workings out

00:31:44,650 --> 00:31:48,370
the same way because bullying is a

00:31:46,390 --> 00:31:50,890
subset boolean logic is a subset of

00:31:48,370 --> 00:31:53,890
predicate logic double ampersand is

00:31:50,890 --> 00:31:55,360
conjunction that short-circuits single

00:31:53,890 --> 00:31:57,070
ampersand is conjunction that doesn't

00:31:55,360 --> 00:31:58,570
which just is just like boolean most

00:31:57,070 --> 00:32:02,200
people don't know that's there and going

00:31:58,570 --> 00:32:03,940
it's there in Java when I came to Skylab

00:32:02,200 --> 00:32:05,290
and I saw this I was like why did Scala

00:32:03,940 --> 00:32:08,500
add that and it turns out it was in Java

00:32:05,290 --> 00:32:10,540
I didn't even know about it so so that's

00:32:08,500 --> 00:32:13,960
in there and then double pipe is the

00:32:10,540 --> 00:32:15,550
disjunction that short circuits and

00:32:13,960 --> 00:32:18,490
single pipe is is the disjunction it

00:32:15,550 --> 00:32:20,860
doesn't and then not is the sideways L

00:32:18,490 --> 00:32:23,320
right that means not and then there's

00:32:20,860 --> 00:32:24,990
four other things there's implies and is

00:32:23,320 --> 00:32:27,309
equivalent to so that's the one that is

00:32:24,990 --> 00:32:29,200
you can actually make these out of these

00:32:27,309 --> 00:32:31,510
other ones but it's still kind of nice

00:32:29,200 --> 00:32:33,970
to have them because people usually have

00:32:31,510 --> 00:32:37,809
them in predicate logic formulas so

00:32:33,970 --> 00:32:40,270
implies is if-then and it's clothing to

00:32:37,809 --> 00:32:42,160
is if and only if right that's the arrow

00:32:40,270 --> 00:32:44,650
with to direct to to arrow heads and

00:32:42,160 --> 00:32:46,960
then there's for all and exists not in

00:32:44,650 --> 00:32:50,710
fact but in other places in Scala tests

00:32:46,960 --> 00:32:54,190
already so there's a generator different

00:32:50,710 --> 00:32:56,290
property checks which has for all that

00:32:54,190 --> 00:32:57,760
takes generator there's inspectors that

00:32:56,290 --> 00:33:00,040
you look at collections and you can say

00:32:57,760 --> 00:33:01,420
for all elements of the collection and

00:33:00,040 --> 00:33:03,670
then there's table different property

00:33:01,420 --> 00:33:06,790
checks where you have a for all for all

00:33:03,670 --> 00:33:08,559
the arrows of the table and then we

00:33:06,790 --> 00:33:11,110
added exists also just for completeness

00:33:08,559 --> 00:33:12,460
to tables and inspectors but not

00:33:11,110 --> 00:33:15,400
generators because it'll make sense to

00:33:12,460 --> 00:33:16,900
have them on generators but essentially

00:33:15,400 --> 00:33:20,770
you have the full power predicate logic

00:33:16,900 --> 00:33:23,380
using this and there is also a form of

00:33:20,770 --> 00:33:24,430
matchers that does this so if you use

00:33:23,380 --> 00:33:27,190
muster should

00:33:24,430 --> 00:33:29,920
that is what does what normally does it

00:33:27,190 --> 00:33:32,440
returns the succeeded singleton or

00:33:29,920 --> 00:33:33,730
throws an exception if you use will that

00:33:32,440 --> 00:33:36,430
one looks different that one will always

00:33:33,730 --> 00:33:41,220
return a yes or no so I can show you

00:33:36,430 --> 00:33:44,260
that real quick so I can say X should be

00:33:41,220 --> 00:33:46,380
less than zero gives me the seek well

00:33:44,260 --> 00:33:48,790
that one is actually the exception I

00:33:46,380 --> 00:33:50,200
meant to do that so the one that

00:33:48,790 --> 00:33:52,210
succeeds you get two succeeded inkling

00:33:50,200 --> 00:33:53,760
just like assert otherwise you get two

00:33:52,210 --> 00:33:57,490
failed exception with an error message

00:33:53,760 --> 00:33:59,200
but if you say will here I'm going to

00:33:57,490 --> 00:34:03,430
give a yes oops I'm not gonna get

00:33:59,200 --> 00:34:06,400
anything because I didn't import it okay

00:34:03,430 --> 00:34:10,120
I get a yes with an error message and if

00:34:06,400 --> 00:34:16,360
it's false I get a No okay so that's a

00:34:10,120 --> 00:34:19,330
little matchers and then what what I

00:34:16,360 --> 00:34:21,149
think it it solves a few problems I mean

00:34:19,330 --> 00:34:24,490
I for many years I kind of had this

00:34:21,149 --> 00:34:26,169
brewing but I haven't decided to add it

00:34:24,490 --> 00:34:28,960
because I try not to add anything unless

00:34:26,169 --> 00:34:30,429
there's a real strong justification for

00:34:28,960 --> 00:34:35,250
it so one of the problems it solves is

00:34:30,429 --> 00:34:35,250
boring master expressions together and

00:34:35,760 --> 00:34:41,740
another one is is this thing of labels

00:34:38,919 --> 00:34:46,120
with it's kind of nice to be able to

00:34:41,740 --> 00:34:47,740
build expressions assertion expressions

00:34:46,120 --> 00:34:49,030
that compose and when you as soon as you

00:34:47,740 --> 00:34:52,000
throw an exception you're not really

00:34:49,030 --> 00:34:53,710
composable so in politic which is

00:34:52,000 --> 00:34:56,620
modeled after quick check in Haskell it

00:34:53,710 --> 00:34:59,830
he uses boolean to define his properties

00:34:56,620 --> 00:35:01,330
because boolean composes the trouble is

00:34:59,830 --> 00:35:04,600
if you get a kind of a big boolean

00:35:01,330 --> 00:35:06,760
expression and it fails there's no hint

00:35:04,600 --> 00:35:07,360
as to what part of the expression caused

00:35:06,760 --> 00:35:11,740
the failure

00:35:07,360 --> 00:35:16,000
so what Ricard put in Scala check is

00:35:11,740 --> 00:35:17,710
something they had in Crick check which

00:35:16,000 --> 00:35:19,990
is a label you can label parts of the

00:35:17,710 --> 00:35:22,000
boolean expression so I can say well

00:35:19,990 --> 00:35:24,490
this first part if that is the part that

00:35:22,000 --> 00:35:25,750
causes this expression to fail after you

00:35:24,490 --> 00:35:27,670
and it's with the next one that that's

00:35:25,750 --> 00:35:30,310
already false then there will be a error

00:35:27,670 --> 00:35:32,950
message result greater than number one

00:35:30,310 --> 00:35:34,840
right he's just kind of labeling the

00:35:32,950 --> 00:35:37,420
pieces and which part causes the thing

00:35:34,840 --> 00:35:38,349
to fail will show up in the output and I

00:35:37,420 --> 00:35:40,599
always felt that was

00:35:38,349 --> 00:35:43,630
cluttery like by putting those in there

00:35:40,599 --> 00:35:45,910
it's hard to see the exploiting

00:35:43,630 --> 00:35:47,470
expression so if you know what you're

00:35:45,910 --> 00:35:49,390
using a fact you'll get a nice error

00:35:47,470 --> 00:35:51,339
message without having labels so that's

00:35:49,390 --> 00:35:52,799
one of the things I think it it allows

00:35:51,339 --> 00:35:55,720
it sort of gives you a composable

00:35:52,799 --> 00:35:57,940
assertion language but without having to

00:35:55,720 --> 00:36:00,039
do labels because you get the error

00:35:57,940 --> 00:36:03,220
messages for free and another problem

00:36:00,039 --> 00:36:05,470
that Scouts has has had for ever is that

00:36:03,220 --> 00:36:07,299
the error messages were nice but they

00:36:05,470 --> 00:36:09,609
weren't really scalable when you made

00:36:07,299 --> 00:36:12,640
bigger assertions and most the time you

00:36:09,609 --> 00:36:14,259
don't but if I just say assert that X is

00:36:12,640 --> 00:36:16,720
greater than zero and X does not equal

00:36:14,259 --> 00:36:21,880
one that's actually not too bad I mean

00:36:16,720 --> 00:36:25,359
like this one is if I say assert X is

00:36:21,880 --> 00:36:28,269
less than zero I get a nice error

00:36:25,359 --> 00:36:30,880
message one was not less than zero if I

00:36:28,269 --> 00:36:34,960
say X is what did I say here greater

00:36:30,880 --> 00:36:37,479
than zero which is true and X does not

00:36:34,960 --> 00:36:38,650
equal one then you still get a pretty

00:36:37,479 --> 00:36:40,450
nice error message if you get your

00:36:38,650 --> 00:36:43,359
parentheses right one was greater than

00:36:40,450 --> 00:36:44,769
zero but one equal to one so I can I can

00:36:43,359 --> 00:36:46,569
reason about that but as soon as you

00:36:44,769 --> 00:36:48,880
have a third piece in here like an or

00:36:46,569 --> 00:36:51,759
next is greater than ten which is also

00:36:48,880 --> 00:36:53,979
false then what I get is one was greater

00:36:51,759 --> 00:36:56,049
than zero but one equals one and one was

00:36:53,979 --> 00:36:58,180
not greater than ten and what is kind of

00:36:56,049 --> 00:37:00,009
lost is like what happened first because

00:36:58,180 --> 00:37:05,109
really there's parentheses around this

00:37:00,009 --> 00:37:07,210
one because of the you know precedence

00:37:05,109 --> 00:37:08,890
but I don't get that in my error message

00:37:07,210 --> 00:37:11,499
so that's that doesn't scale that well

00:37:08,890 --> 00:37:13,930
if I get any bigger than three pieces

00:37:11,499 --> 00:37:15,369
then the error message is not obvious

00:37:13,930 --> 00:37:17,229
you have to like compare the message to

00:37:15,369 --> 00:37:21,640
the original thing so there's something

00:37:17,229 --> 00:37:24,660
in Scala test called diagram assertions

00:37:21,640 --> 00:37:27,940
which came from was inspired by Spock

00:37:24,660 --> 00:37:30,849
which instead of trying to make English

00:37:27,940 --> 00:37:34,269
out of it it draws a little diagram so

00:37:30,849 --> 00:37:36,759
this you know I just points each thing

00:37:34,269 --> 00:37:39,910
and says well X greater than zero was

00:37:36,759 --> 00:37:41,259
true but I have an an here with X not

00:37:39,910 --> 00:37:43,809
equal one which is false so that means

00:37:41,259 --> 00:37:45,039
that's all fraggin or this thing was

00:37:43,809 --> 00:37:47,200
also there for the hope so you can

00:37:45,039 --> 00:37:49,479
actually kind of figure that out but

00:37:47,200 --> 00:37:51,640
that only scales until you hit sort of

00:37:49,479 --> 00:37:54,970
the edge here because

00:37:51,640 --> 00:37:57,640
I'm pointing to the things vertically

00:37:54,970 --> 00:38:00,880
right so if I say X greater than ten so

00:37:57,640 --> 00:38:02,560
as we go to two lines in diagrammed

00:38:00,880 --> 00:38:04,480
assertions it falls back to the English

00:38:02,560 --> 00:38:06,850
because you couldn't really draw this

00:38:04,480 --> 00:38:09,250
diagram and point to things on multiple

00:38:06,850 --> 00:38:12,420
lines it just is not reasonable so even

00:38:09,250 --> 00:38:15,970
this has a scalability problem so what

00:38:12,420 --> 00:38:17,920
what happens is if you the error message

00:38:15,970 --> 00:38:21,670
in expectations I'm gonna go back to

00:38:17,920 --> 00:38:24,550
this guy and make it an expect well not

00:38:21,670 --> 00:38:32,380
bad let's do it with mashers so I'll say

00:38:24,550 --> 00:38:38,260
X will be greater than zero and X will

00:38:32,380 --> 00:38:41,920
not equal one or let's give a piece X

00:38:38,260 --> 00:38:44,920
greater X text will will be greater than

00:38:41,920 --> 00:38:49,420
ten what you get is kind of a combo of

00:38:44,920 --> 00:38:53,250
the diagrams and the English so each

00:38:49,420 --> 00:38:55,810
node there's an English error message

00:38:53,250 --> 00:38:59,830
but then you can kind of see how the

00:38:55,810 --> 00:39:02,200
structure is in the logic statement so I

00:38:59,830 --> 00:39:04,060
could look at yes one was greater than

00:39:02,200 --> 00:39:05,620
zero but then that was ANDed with a No

00:39:04,060 --> 00:39:08,260
so that's why this whole thing was a no

00:39:05,620 --> 00:39:10,750
so I can see you know this guy I can

00:39:08,260 --> 00:39:12,760
find my mouse is a no that makes sense

00:39:10,750 --> 00:39:15,310
but then I ordered with this other thing

00:39:12,760 --> 00:39:17,410
that turned out to be an O therefore the

00:39:15,310 --> 00:39:20,710
whole thing was an element Megan this

00:39:17,410 --> 00:39:25,690
should scale up very large right so I

00:39:20,710 --> 00:39:30,960
think it addresses that issue and that

00:39:25,690 --> 00:39:35,370
is what's coming so what essentially the

00:39:30,960 --> 00:39:35,370
insight was simply that you can you know

00:39:36,150 --> 00:39:47,260
kind of have one statement of logic that

00:39:43,050 --> 00:39:51,970
describes a test that that's what a test

00:39:47,260 --> 00:39:53,950
is and it is a specification of behavior

00:39:51,970 --> 00:39:55,630
encode that goes along with the

00:39:53,950 --> 00:39:58,210
specification and human language that's

00:39:55,630 --> 00:40:03,780
the test name right if you use it for

00:39:58,210 --> 00:40:03,780
all so that that's what if F is and then

00:40:04,110 --> 00:40:07,680
instead of trying to do what Tony Hoare

00:40:05,670 --> 00:40:09,390
wanted to do that was his goal is we are

00:40:07,680 --> 00:40:12,260
proving the correctness of software what

00:40:09,390 --> 00:40:14,730
we're doing is more like science we're

00:40:12,260 --> 00:40:16,890
trying it and observing we're just

00:40:14,730 --> 00:40:20,910
performing experiments our hypothesis is

00:40:16,890 --> 00:40:22,050
that the code behaves as we expect with

00:40:20,910 --> 00:40:24,120
that's what we think is going to be true

00:40:22,050 --> 00:40:27,510
but we try it we don't just believe it

00:40:24,120 --> 00:40:32,880
on without looking at the facts we

00:40:27,510 --> 00:40:35,370
actually try it and then what you're

00:40:32,880 --> 00:40:38,250
going to get is an observation that's

00:40:35,370 --> 00:40:41,190
going to either confirm or show you

00:40:38,250 --> 00:40:43,440
it'll either basically it doesn't prove

00:40:41,190 --> 00:40:45,030
it is true it's just the only thing you

00:40:43,440 --> 00:40:47,610
can prove essentially is that it's not

00:40:45,030 --> 00:40:50,280
work true so just like science you can't

00:40:47,610 --> 00:40:51,840
really prove a theory true an experiment

00:40:50,280 --> 00:40:54,600
but what an experiment can do is so you

00:40:51,840 --> 00:40:57,420
actually know here's one that where it

00:40:54,600 --> 00:40:59,970
doesn't work right so I think it's kind

00:40:57,420 --> 00:41:03,120
of interesting because what predicate

00:40:59,970 --> 00:41:06,810
logic is usually mapped to in English is

00:41:03,120 --> 00:41:09,600
like an assertion like X is greater than

00:41:06,810 --> 00:41:12,000
10 so it's just an assertion and then

00:41:09,600 --> 00:41:14,400
you you say well that's that's this

00:41:12,000 --> 00:41:19,830
formula and then you simmer it down and

00:41:14,400 --> 00:41:23,400
you prove something what this is using

00:41:19,830 --> 00:41:27,260
logic for is for expressing expectations

00:41:23,400 --> 00:41:30,360
and observations so when I say for all X

00:41:27,260 --> 00:41:32,940
integers X X greater than 0 implies X

00:41:30,360 --> 00:41:36,750
plus 1 will be greater than 0 that

00:41:32,940 --> 00:41:39,540
statement of logic is can be mapped to

00:41:36,750 --> 00:41:41,100
this expectation in English for all X if

00:41:39,540 --> 00:41:43,680
X is greater than 0 then X plus 1 will

00:41:41,100 --> 00:41:46,080
be greater than 0 which is different

00:41:43,680 --> 00:41:47,640
than saying that it's true it's saying

00:41:46,080 --> 00:41:50,040
I'm kind of expecting that's going to be

00:41:47,640 --> 00:41:52,440
true and then when we actually execute

00:41:50,040 --> 00:41:54,900
this code there is a case where it won't

00:41:52,440 --> 00:41:56,100
work which is if X is MaxEnt you add 1

00:41:54,900 --> 00:41:59,670
to it it's going to loop back and be

00:41:56,100 --> 00:42:01,410
minutes right so the observation is int

00:41:59,670 --> 00:42:03,030
that max value was greater than 0 but

00:42:01,410 --> 00:42:04,500
ends up min value was not greater than 0

00:42:03,030 --> 00:42:09,080
so that also kind of maps to the logic

00:42:04,500 --> 00:42:13,650
statement the only way that's what I

00:42:09,080 --> 00:42:15,690
wanted to talk about and before I go to

00:42:13,650 --> 00:42:17,340
QA I just wanted to mention that what

00:42:15,690 --> 00:42:17,999
what I've been doing at RT miles lately

00:42:17,340 --> 00:42:20,279
is

00:42:17,999 --> 00:42:22,589
going as a consulting company so we do

00:42:20,279 --> 00:42:24,839
hire programmers if you're interested

00:42:22,589 --> 00:42:28,409
you come talk to me or email that email

00:42:24,839 --> 00:42:29,789
address and also I'm the community one

00:42:28,409 --> 00:42:33,209
of the community reps on the skeleton

00:42:29,789 --> 00:42:36,689
advisory board so if you have a concern

00:42:33,209 --> 00:42:39,809
or a wish or desire for Scala in general

00:42:36,689 --> 00:42:42,329
please come talk to me or email me and

00:42:39,809 --> 00:42:43,739
that's my question does anybody have any

00:42:42,329 --> 00:42:47,429
question we have like four minutes I

00:42:43,739 --> 00:42:49,859
think a few minutes yes hi this thing on

00:42:47,429 --> 00:42:52,109
yeah it is cool I can't find it now but

00:42:49,859 --> 00:42:53,399
I remember reading somebody's blog post

00:42:52,109 --> 00:42:54,539
where they're comparing they were

00:42:53,399 --> 00:42:58,349
basically taking a look back and

00:42:54,539 --> 00:43:02,699
comparing TDD with design by contract

00:42:58,349 --> 00:43:05,579
which kind of came first and there are a

00:43:02,699 --> 00:43:08,249
couple of advantages of the contact

00:43:05,579 --> 00:43:10,139
approach in that because that was

00:43:08,249 --> 00:43:12,209
associated with the production code it

00:43:10,139 --> 00:43:14,789
would associate not only with the object

00:43:12,209 --> 00:43:16,589
hierarchy so you could have test our

00:43:14,789 --> 00:43:18,299
assertions associated with the

00:43:16,589 --> 00:43:20,819
superclass or with the interface rather

00:43:18,299 --> 00:43:23,489
than with the implementation yes we used

00:43:20,819 --> 00:43:26,699
them yep but also that means whatever is

00:43:23,489 --> 00:43:28,319
actually running the code could be a

00:43:26,699 --> 00:43:30,449
property-based sent could be anything

00:43:28,319 --> 00:43:33,239
else it could be a user you'd still be

00:43:30,449 --> 00:43:35,159
able to exercise those yeah it's that

00:43:33,239 --> 00:43:36,629
something that you've looked into or

00:43:35,159 --> 00:43:38,459
something that's being taught about in

00:43:36,629 --> 00:43:40,109
scholar at the moment it's not being

00:43:38,459 --> 00:43:42,179
taught about in scholar just because

00:43:40,109 --> 00:43:43,889
people don't tend to seem to want that I

00:43:42,179 --> 00:43:46,469
mean what was put into scholar was just

00:43:43,889 --> 00:43:48,299
a very poor man's you know if you want

00:43:46,469 --> 00:43:50,369
to do it you can do it ensuring and

00:43:48,299 --> 00:43:51,389
assume those can be turned off but

00:43:50,369 --> 00:43:52,829
there's nothing to do with like

00:43:51,389 --> 00:43:54,539
generalizing or making things more

00:43:52,829 --> 00:43:58,259
specific with sub-sites supertype like

00:43:54,539 --> 00:44:01,709
there is an eyeful okay take it so yes

00:43:58,259 --> 00:44:04,679
so I was a little bit curious I noticed

00:44:01,709 --> 00:44:09,239
that well you showed us that assert

00:44:04,679 --> 00:44:11,309
Returns succeeded so why not simply have

00:44:09,239 --> 00:44:15,659
it returned unit the reason I didn't

00:44:11,309 --> 00:44:17,699
have a return unit was so that we could

00:44:15,659 --> 00:44:20,039
have a type at the end of the test

00:44:17,699 --> 00:44:21,929
because anything can be converted into

00:44:20,039 --> 00:44:24,629
unit in Scala this value discarding

00:44:21,929 --> 00:44:28,289
unless you set a flag in the compiler so

00:44:24,629 --> 00:44:30,389
in async tests in Scala tests I just

00:44:28,289 --> 00:44:31,020
felt like future Annie or future unit

00:44:30,389 --> 00:44:33,090
was

00:44:31,020 --> 00:44:35,700
very error-prone so I want it to be

00:44:33,090 --> 00:44:37,710
future assertion well what's that and

00:44:35,700 --> 00:44:40,020
what an assertion is is is a thing that

00:44:37,710 --> 00:44:41,940
either returns a singleton or throws an

00:44:40,020 --> 00:44:45,030
exception so I thought we needed a

00:44:41,940 --> 00:44:47,460
single than other than unit two so that

00:44:45,030 --> 00:44:48,840
you get more type checking so in in this

00:44:47,460 --> 00:44:51,450
new version of Scala test there's

00:44:48,840 --> 00:44:55,050
there's a a style trait set of cell

00:44:51,450 --> 00:44:57,300
traits that where that result type of

00:44:55,050 --> 00:45:03,119
the test has to be assertion so you get

00:44:57,300 --> 00:45:07,440
you get more type checking that way yes

00:45:03,119 --> 00:45:12,030
in your examples assume and require

00:45:07,440 --> 00:45:15,420
seems to just be synonyms so I'm not

00:45:12,030 --> 00:45:19,290
clear on why both of those words exist

00:45:15,420 --> 00:45:21,090
in in this yeah assume is different in

00:45:19,290 --> 00:45:22,710
that let's say I think X is one

00:45:21,090 --> 00:45:25,170
it throws assertion error and require

00:45:22,710 --> 00:45:28,140
throws illegal argument exception so

00:45:25,170 --> 00:45:31,290
assume was the Eifel way required was

00:45:28,140 --> 00:45:35,670
the java way assume can be turned off at

00:45:31,290 --> 00:45:37,650
runtime require cannot okay and that's

00:45:35,670 --> 00:45:39,600
why why I mean assume was there

00:45:37,650 --> 00:45:42,440
originally and require was added

00:45:39,600 --> 00:45:45,780
actually when we were writing the book

00:45:42,440 --> 00:45:46,890
so but they're both used for pre can

00:45:45,780 --> 00:45:48,119
they're both can be used for

00:45:46,890 --> 00:45:50,820
precondition checks if you want to do

00:45:48,119 --> 00:45:53,270
things the design by contract way sort

00:45:50,820 --> 00:45:55,410
of the Eiffel way then assume might be

00:45:53,270 --> 00:45:57,540
more appropriate but most people use

00:45:55,410 --> 00:45:58,950
require and in fact in the book we just

00:45:57,540 --> 00:46:02,400
put it as sort of an ax there's a

00:45:58,950 --> 00:46:05,270
footnote it says assume exists in brace

00:46:02,400 --> 00:46:09,510
mole print so anyway I think is that the

00:46:05,270 --> 00:46:10,450
time I think it's time anyway thank you

00:46:09,510 --> 00:46:15,040
very much

00:46:10,450 --> 00:46:15,040

YouTube URL: https://www.youtube.com/watch?v=RqDvTnp9xR8


