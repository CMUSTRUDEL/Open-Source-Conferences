Title: Vert.x 3 goes Scala by Jochen Mader
Publication date: 2017-06-19
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
Vert.x is a polyglott toolkit to build reactive applications on the JVM. It is based on a simple yet powerful threading concept and provides very easy cluster managed. 
I will introduce the brand new Scala-stack that has just been added to the core framework and opens all its capabilities to the Scala-world. The main topics of this talk will be:
- a walkthrough for the current stack and available modules
- bootstrapping an SBT-Vert.x-project with the provided project blueprint
- running, testing and deploying of Vert.x-microservices
- how Scala enhances the Vert.x programming experience
- a full demo of an elastic Vert.x-cluster 

Expect a lot of code and room for discussions.
Captions: 
	00:00:00,000 --> 00:00:04,890
thanks for showing up here my name is

00:00:02,730 --> 00:00:05,609
Johan I'm working for concentric in

00:00:04,890 --> 00:00:07,560
Germany

00:00:05,609 --> 00:00:09,090
we're spent the past few years working

00:00:07,560 --> 00:00:12,929
mostly with reactive application

00:00:09,090 --> 00:00:15,000
frameworks out of one vertex this one

00:00:12,929 --> 00:00:17,100
which has spent a lot of time with and

00:00:15,000 --> 00:00:19,560
somewhat ended up becoming the

00:00:17,100 --> 00:00:21,060
maintainer of the new scale aesthetic

00:00:19,560 --> 00:00:22,350
and being our project member there and

00:00:21,060 --> 00:00:25,590
that's the stuff I want to introduce you

00:00:22,350 --> 00:00:28,140
today with what we did there what you

00:00:25,590 --> 00:00:29,880
can do with vertex and a guess because I

00:00:28,140 --> 00:00:32,009
don't think that vertex is rightly known

00:00:29,880 --> 00:00:36,050
as a scholar work with vertex in general

00:00:32,009 --> 00:00:39,629
is first the required slide please rate

00:00:36,050 --> 00:00:42,180
using your using the app and now I'd

00:00:39,629 --> 00:00:45,329
like to get started from here on just

00:00:42,180 --> 00:00:47,640
give like a quick breeze unlike what I

00:00:45,329 --> 00:00:49,829
actually expect from a reactive system

00:00:47,640 --> 00:00:51,690
just to get you a little kickstart for

00:00:49,829 --> 00:00:53,969
what I'm going to do so the first thing

00:00:51,690 --> 00:00:57,510
is let's assume a little service that we

00:00:53,969 --> 00:01:01,770
want to provide what okay I will jump

00:00:57,510 --> 00:01:04,350
this one like the Cora thing I'm talking

00:01:01,770 --> 00:01:06,060
about is reactive so what does reactive

00:01:04,350 --> 00:01:07,470
actually mean what are the properties

00:01:06,060 --> 00:01:12,020
that we want to get out of a system that

00:01:07,470 --> 00:01:15,060
is reactive so here's a little example

00:01:12,020 --> 00:01:16,799
let's do a little service that we call

00:01:15,060 --> 00:01:18,840
installed as a service so we want this

00:01:16,799 --> 00:01:20,189
guy to keep insulting us for as long as

00:01:18,840 --> 00:01:22,880
possible maybe some of you know it

00:01:20,189 --> 00:01:25,200
another thing is this guy is actually

00:01:22,880 --> 00:01:28,650
fulfills a nice property which we call

00:01:25,200 --> 00:01:31,079
responsive which means even if we take

00:01:28,650 --> 00:01:32,960
away part of its system is still going

00:01:31,079 --> 00:01:37,439
to be able to insult us to the very end

00:01:32,960 --> 00:01:39,210
now this is already pretty nice but like

00:01:37,439 --> 00:01:40,500
an additional property that I expect

00:01:39,210 --> 00:01:44,700
from the system if it came to that

00:01:40,500 --> 00:01:46,170
status to come back and now the next

00:01:44,700 --> 00:01:47,790
property is that now that we know

00:01:46,170 --> 00:01:51,030
situation in which our system is going

00:01:47,790 --> 00:01:53,280
to degrade we want to be able to adapt

00:01:51,030 --> 00:01:55,829
to future situations to deal with those

00:01:53,280 --> 00:01:57,990
better so that's like one of the coil

00:01:55,829 --> 00:02:00,930
like this basically combines the essence

00:01:57,990 --> 00:02:02,670
of reactive now I was a little late with

00:02:00,930 --> 00:02:04,560
this funny painting so other people's

00:02:02,670 --> 00:02:06,719
already come but came up with a way

00:02:04,560 --> 00:02:08,700
better image of that and that's the

00:02:06,719 --> 00:02:11,129
reactive manifesto I hope like most of

00:02:08,700 --> 00:02:13,140
you in here heard about it so the core

00:02:11,129 --> 00:02:13,920
thing is staying responsive just as I'll

00:02:13,140 --> 00:02:15,660
say like if we want to

00:02:13,920 --> 00:02:17,550
keep on insulting as long as possible

00:02:15,660 --> 00:02:18,900
without anyone noticing that this or

00:02:17,550 --> 00:02:20,430
that thought is missing from our system

00:02:18,900 --> 00:02:22,830
how do we achieve that

00:02:20,430 --> 00:02:25,590
part of this is being resilient which

00:02:22,830 --> 00:02:28,620
means I can handle things going wrong in

00:02:25,590 --> 00:02:30,239
my system partial more than partial

00:02:28,620 --> 00:02:32,280
failures in the system should not cause

00:02:30,239 --> 00:02:35,760
the customer wants them getting

00:02:32,280 --> 00:02:37,500
assaulted missing out on insults so the

00:02:35,760 --> 00:02:40,700
next thing is we want to be elastic

00:02:37,500 --> 00:02:42,750
which means I want to scale out

00:02:40,700 --> 00:02:44,370
according to the demands if there's

00:02:42,750 --> 00:02:46,440
suddenly five or ten people showing up

00:02:44,370 --> 00:02:48,600
on my bridge I want to deal out equally

00:02:46,440 --> 00:02:50,130
to every one of those also if there's

00:02:48,600 --> 00:02:52,049
only one person or no person showing I

00:02:50,130 --> 00:02:53,549
want to be able to scale down which is

00:02:52,049 --> 00:02:56,250
an important property for reactive

00:02:53,549 --> 00:02:57,750
systems as we are deploying a lot of the

00:02:56,250 --> 00:02:59,430
stubble most of the stuff actually in

00:02:57,750 --> 00:03:02,670
the cloud and every machine we have

00:02:59,430 --> 00:03:04,680
deploy additionally is money on that we

00:03:02,670 --> 00:03:06,720
spent so we want to be elastic and we

00:03:04,680 --> 00:03:10,140
want to adjust to the demand that we are

00:03:06,720 --> 00:03:11,930
actually facing now the solution like so

00:03:10,140 --> 00:03:15,269
like the basis of this whole idea is

00:03:11,930 --> 00:03:17,370
maybe all you is building systems on the

00:03:15,269 --> 00:03:19,260
message driven approach that means

00:03:17,370 --> 00:03:21,180
instead of having a tight coupling with

00:03:19,260 --> 00:03:24,090
synchronous calls we decouple all

00:03:21,180 --> 00:03:27,630
involve parts of the system and make

00:03:24,090 --> 00:03:31,230
them message driven so this all together

00:03:27,630 --> 00:03:33,900
forms the ole ole Holy Cross of the

00:03:31,230 --> 00:03:36,090
reactive systems and we're all sick or

00:03:33,900 --> 00:03:37,260
everything is good for now so this is

00:03:36,090 --> 00:03:38,790
like the one thing that we want to

00:03:37,260 --> 00:03:40,470
achieve and I have to say like after

00:03:38,790 --> 00:03:42,690
working for several years research

00:03:40,470 --> 00:03:45,690
systems we get pretty close using them

00:03:42,690 --> 00:03:49,320
correctly so now is the one I want to

00:03:45,690 --> 00:03:50,609
introduce you today vertex so verdict

00:03:49,320 --> 00:03:52,560
has been around for a pretty long time

00:03:50,609 --> 00:03:54,630
but now I started working with around

00:03:52,560 --> 00:03:55,950
four or five years ago before that I

00:03:54,630 --> 00:03:59,430
think it's been around that for six

00:03:55,950 --> 00:04:02,220
years it is mainly focused on the Java

00:03:59,430 --> 00:04:05,310
world but like from my perspective we

00:04:02,220 --> 00:04:06,959
mostly use Java in there as the C I gets

00:04:05,310 --> 00:04:08,609
the low-level code to use and we then

00:04:06,959 --> 00:04:11,549
try to abstract into other languages and

00:04:08,609 --> 00:04:13,350
provide decent API so what is vertex in

00:04:11,549 --> 00:04:15,510
its core first of all it's completely

00:04:13,350 --> 00:04:17,370
messaging based that means like every

00:04:15,510 --> 00:04:19,139
interaction that we have in vertex is

00:04:17,370 --> 00:04:21,389
based on the exchange of messages

00:04:19,139 --> 00:04:24,120
between the individual parts what parts

00:04:21,389 --> 00:04:25,530
do these are I will explain later the

00:04:24,120 --> 00:04:27,460
next thing is and this is like one of

00:04:25,530 --> 00:04:29,710
the nicest feature of project is that it

00:04:27,460 --> 00:04:31,960
as probably one of the simplest way of

00:04:29,710 --> 00:04:34,360
creating resilient clusters that have

00:04:31,960 --> 00:04:36,880
have seen so far we would later see a

00:04:34,360 --> 00:04:39,750
lot of code on that we have a very

00:04:36,880 --> 00:04:42,759
simple threading model which means that

00:04:39,750 --> 00:04:44,289
there's really just a few core rules you

00:04:42,759 --> 00:04:46,569
have to learn to actually start working

00:04:44,289 --> 00:04:48,819
with vertex there's actually a part that

00:04:46,569 --> 00:04:50,770
we derivative say we don't want to give

00:04:48,819 --> 00:04:52,599
too much flexibility to the user well if

00:04:50,770 --> 00:04:54,460
there's one thing that is easy to get

00:04:52,599 --> 00:04:55,960
wrong its threading so we have a very

00:04:54,460 --> 00:04:58,330
tightly regulated threading model on

00:04:55,960 --> 00:05:01,599
there and the other part is that we try

00:04:58,330 --> 00:05:03,639
to keep the core very small so you have

00:05:01,599 --> 00:05:05,770
like a base set of API so that you can

00:05:03,639 --> 00:05:10,060
build on and we have a lot of a pretty

00:05:05,770 --> 00:05:11,770
big module ecosystem built around it so

00:05:10,060 --> 00:05:14,320
and this is like the greatness of vertex

00:05:11,770 --> 00:05:16,479
that have been using involve fast data

00:05:14,320 --> 00:05:19,960
system microscopes applications a lot in

00:05:16,479 --> 00:05:21,880
the IOT environment this is just like a

00:05:19,960 --> 00:05:23,470
little excerpt so you know that I'm not

00:05:21,880 --> 00:05:26,319
talking about your favorite it's used by

00:05:23,470 --> 00:05:28,389
no one's just a little excerpt from the

00:05:26,319 --> 00:05:30,789
companies that are currently using and

00:05:28,389 --> 00:05:35,020
boasting using vertex right now there's

00:05:30,789 --> 00:05:36,610
a lot of no names in there so it's time

00:05:35,020 --> 00:05:37,870
for that actually pretty widely used and

00:05:36,610 --> 00:05:40,180
if you don't know it vertex is

00:05:37,870 --> 00:05:41,860
completely founded by Red Hat so like

00:05:40,180 --> 00:05:43,240
I'm not a record employee like I'm like

00:05:41,860 --> 00:05:44,860
one of the commenter's not part of

00:05:43,240 --> 00:05:46,509
Reddit but I think there's right now

00:05:44,860 --> 00:05:49,870
five or six people who are employed for

00:05:46,509 --> 00:05:55,240
Reta to just focus on evolving red

00:05:49,870 --> 00:05:56,919
vertex so first thing before I start

00:05:55,240 --> 00:05:59,110
digging into the code it's like just to

00:05:56,919 --> 00:06:01,719
show you like what is offered by vertex

00:05:59,110 --> 00:06:03,190
I sell vertex is highly modular it means

00:06:01,719 --> 00:06:06,759
like we have a lot of stuff that you can

00:06:03,190 --> 00:06:07,870
flatten just slap on and use so there's

00:06:06,759 --> 00:06:09,940
the first thing at least like the

00:06:07,870 --> 00:06:12,789
database client there's a lot of them

00:06:09,940 --> 00:06:15,099
why do we have specific database kinds

00:06:12,789 --> 00:06:17,080
the thing is vertex is completely

00:06:15,099 --> 00:06:19,180
non-blocking we don't allow any blocking

00:06:17,080 --> 00:06:20,680
code inside vertex that means that we

00:06:19,180 --> 00:06:23,110
have to abstract away some of those

00:06:20,680 --> 00:06:26,590
drivers so we have a better handling

00:06:23,110 --> 00:06:29,110
inside the event loops next part is

00:06:26,590 --> 00:06:32,080
authentication we have a rich set of

00:06:29,110 --> 00:06:34,240
things to pick from configuration which

00:06:32,080 --> 00:06:37,270
is a pretty recent addition so we can

00:06:34,240 --> 00:06:38,469
update run update run time like change

00:06:37,270 --> 00:06:40,690
we can adapt to changes in the

00:06:38,469 --> 00:06:41,350
configuration during run time we can go

00:06:40,690 --> 00:06:42,670
like this

00:06:41,350 --> 00:06:44,410
it is comforting maybe we can go to a

00:06:42,670 --> 00:06:48,190
spring config server and we can update

00:06:44,410 --> 00:06:50,110
during runtime integration so this is

00:06:48,190 --> 00:06:51,520
like this is like my catch-all thing

00:06:50,110 --> 00:06:53,320
like this it says everything that just

00:06:51,520 --> 00:06:55,870
connects to somewhere else so we have

00:06:53,320 --> 00:06:57,580
ways of integrating with the je legacy

00:06:55,870 --> 00:06:58,900
worlds where we can just hook into the

00:06:57,580 --> 00:07:01,120
event path of projects and start

00:06:58,900 --> 00:07:03,730
receiving events from there we have

00:07:01,120 --> 00:07:06,010
camera integration and 2p integration

00:07:03,730 --> 00:07:09,700
and most recent additions are Kafka and

00:07:06,010 --> 00:07:12,340
gr PC so as you just saw the talk by

00:07:09,700 --> 00:07:15,010
Pietra there is gr PC is a pretty recent

00:07:12,340 --> 00:07:16,570
thing by Google and vertex is capable of

00:07:15,010 --> 00:07:20,710
being both a client and a server for

00:07:16,570 --> 00:07:22,090
geography then we have DevOps support

00:07:20,710 --> 00:07:25,410
that means like we have rich set of

00:07:22,090 --> 00:07:28,000
providing metrics we have ways of

00:07:25,410 --> 00:07:30,010
logging into the system by providing a

00:07:28,000 --> 00:07:34,030
shell login based on telnet or a secure

00:07:30,010 --> 00:07:36,970
shell we have specific docker images and

00:07:34,030 --> 00:07:38,830
all that stuff discovery that means that

00:07:36,970 --> 00:07:40,330
you can hook up into like other systems

00:07:38,830 --> 00:07:42,280
to discover services you want to use

00:07:40,330 --> 00:07:44,230
pretty important if you're in the cloud

00:07:42,280 --> 00:07:46,870
and you don't want to hard-code any IPS

00:07:44,230 --> 00:07:49,390
or something like that and then the

00:07:46,870 --> 00:07:51,910
important part to me cluster manager

00:07:49,390 --> 00:07:52,870
that means like the ways nodes can

00:07:51,910 --> 00:07:55,870
discover each other

00:07:52,870 --> 00:07:58,480
hazel house has been by sorry the most

00:07:55,870 --> 00:08:00,130
used one and the most flexible one but

00:07:58,480 --> 00:08:01,870
we also have J groups integration Apache

00:08:00,130 --> 00:08:05,680
ignite and zookeeper so you can pick

00:08:01,870 --> 00:08:08,410
whatever you want there and then the

00:08:05,680 --> 00:08:11,470
mist can also okay I don't pronounce

00:08:08,410 --> 00:08:13,030
this right now the most reason and

00:08:11,470 --> 00:08:15,370
biggest addition has been a full-fledged

00:08:13,030 --> 00:08:19,180
MQTT server in vertex which allows us

00:08:15,370 --> 00:08:21,490
now to interact with IOT devices it's

00:08:19,180 --> 00:08:24,490
only already used by the unmask product

00:08:21,490 --> 00:08:26,440
from red head it's to my knowledge also

00:08:24,490 --> 00:08:28,180
used by Bosch for many of the

00:08:26,440 --> 00:08:31,690
high-throughput applications in the IOT

00:08:28,180 --> 00:08:34,360
scenario now for the one thing all of

00:08:31,690 --> 00:08:37,180
these modules are to the work I did

00:08:34,360 --> 00:08:39,160
available in a scholar flavor so there's

00:08:37,180 --> 00:08:41,260
no part of the API where we have right

00:08:39,160 --> 00:08:43,840
now Java linking to to you so you won't

00:08:41,260 --> 00:08:46,630
be able to use all of these modules with

00:08:43,840 --> 00:08:49,420
a Scala native API and it brings me to

00:08:46,630 --> 00:08:52,060
the next point vertex is by choice a

00:08:49,420 --> 00:08:53,620
polyglot framework so now polyglot on

00:08:52,060 --> 00:08:55,060
the JVM many people think yeah that's a

00:08:53,620 --> 00:08:56,710
pretty easy thing

00:08:55,060 --> 00:08:58,360
because like every language on the JVM

00:08:56,710 --> 00:09:00,280
can buy Siri interact with any other

00:08:58,360 --> 00:09:02,380
language or libraries generated by it

00:09:00,280 --> 00:09:06,370
the key thing is that we take a lot of

00:09:02,380 --> 00:09:09,070
work to support languages natively which

00:09:06,370 --> 00:09:12,790
means all modules are available in a

00:09:09,070 --> 00:09:14,560
flavor for their appropriate language we

00:09:12,790 --> 00:09:17,590
added a lot of type information in our

00:09:14,560 --> 00:09:19,990
Java core to support this so that we can

00:09:17,590 --> 00:09:22,150
then generate appropriate api's for the

00:09:19,990 --> 00:09:25,030
different languages currently supported

00:09:22,150 --> 00:09:28,660
are obviously Java 8 as the core Java

00:09:25,030 --> 00:09:30,340
Script we get groovy we got Salem we got

00:09:28,660 --> 00:09:31,660
Cortland co-op on the sprayer like the

00:09:30,340 --> 00:09:34,800
most recent edition which just came up

00:09:31,660 --> 00:09:37,090
with three for one I think and Scala

00:09:34,800 --> 00:09:38,800
which I thought would be like a

00:09:37,090 --> 00:09:41,050
four-week test to implement and I ended

00:09:38,800 --> 00:09:43,570
up spending five or six months until it

00:09:41,050 --> 00:09:45,880
was completed so those are the languages

00:09:43,570 --> 00:09:48,970
you can use currently use vertex with at

00:09:45,880 --> 00:09:51,970
all by obviously there's many uses in

00:09:48,970 --> 00:09:53,770
the Java area but we have I think an

00:09:51,970 --> 00:09:56,260
equal amount of people using Java Script

00:09:53,770 --> 00:09:57,460
groovy Coughlin's Scala I have no idea

00:09:56,260 --> 00:09:59,890
how many people are using the salient

00:09:57,460 --> 00:10:02,140
stuff but like we see in the community

00:09:59,890 --> 00:10:05,770
that the actual native adapters are used

00:10:02,140 --> 00:10:07,600
pretty widely so first of all like the

00:10:05,770 --> 00:10:10,270
basics of vertex like what is vertex in

00:10:07,600 --> 00:10:11,589
its core the most important thing we

00:10:10,270 --> 00:10:13,540
always talk about is a so-called handler

00:10:11,589 --> 00:10:15,610
this is like a thing that you will see

00:10:13,540 --> 00:10:17,430
in my calculator passed around a lot a

00:10:15,610 --> 00:10:19,960
handler has a few unique features

00:10:17,430 --> 00:10:23,200
Prejean number one is each handler has

00:10:19,960 --> 00:10:25,270
an inbox you might somewhat see a

00:10:23,200 --> 00:10:27,460
relation to other concepts from other

00:10:25,270 --> 00:10:30,400
reactive framework here and it's clearly

00:10:27,460 --> 00:10:33,070
that we were inspired by that one too so

00:10:30,400 --> 00:10:36,100
each handler has an inbox why do we have

00:10:33,070 --> 00:10:37,960
an inbox well because a handler will

00:10:36,100 --> 00:10:40,510
never be executed by more than one

00:10:37,960 --> 00:10:43,270
thread the concept behind is a so-called

00:10:40,510 --> 00:10:45,070
event loop that means like we have this

00:10:43,270 --> 00:10:46,390
event loop and all our handlers are by

00:10:45,070 --> 00:10:49,480
some magic way that our share server

00:10:46,390 --> 00:10:51,910
later on associated with one thread for

00:10:49,480 --> 00:10:53,440
the full lifetime so that means if I

00:10:51,910 --> 00:10:55,440
have tons of handler registered they

00:10:53,440 --> 00:10:58,540
will have to be executed in sequence

00:10:55,440 --> 00:11:00,490
that's why we have this inbox there this

00:10:58,540 --> 00:11:02,410
also gives us another unique property by

00:11:00,490 --> 00:11:04,510
giving this guarantee that each handle

00:11:02,410 --> 00:11:08,019
is always executed by the same thread

00:11:04,510 --> 00:11:10,480
and never executed concurrently this

00:11:08,019 --> 00:11:12,389
means we're effectively there there's

00:11:10,480 --> 00:11:13,509
you don't won't need any synchronization

00:11:12,389 --> 00:11:14,709
Atomics

00:11:13,509 --> 00:11:18,309
or whatever else you know from a

00:11:14,709 --> 00:11:20,410
constructive threat sighting there so

00:11:18,309 --> 00:11:23,199
now a handler can reduce you to the

00:11:20,410 --> 00:11:25,689
event pass the event does is the nervous

00:11:23,199 --> 00:11:27,610
system of vertex every part of vertex

00:11:25,689 --> 00:11:31,389
exchanges information using this event

00:11:27,610 --> 00:11:33,189
does the naming is a little wrong I

00:11:31,389 --> 00:11:34,989
would say renowned because like there

00:11:33,189 --> 00:11:36,459
has been a long discussion about events

00:11:34,989 --> 00:11:39,129
and messages over the past few years

00:11:36,459 --> 00:11:41,170
thankfully Roland Kuhn clarifies the

00:11:39,129 --> 00:11:43,449
whole thing in his we have a reactive

00:11:41,170 --> 00:11:45,369
messaging patterns book very recommended

00:11:43,449 --> 00:11:47,230
read so actually we should call this

00:11:45,369 --> 00:11:49,329
message pass but for historic reason

00:11:47,230 --> 00:11:52,149
it's an event bus so a handler can

00:11:49,329 --> 00:11:54,459
register itself to the event paths under

00:11:52,149 --> 00:11:55,959
a given address you decide what address

00:11:54,459 --> 00:12:00,639
you want to pick this can be influenced

00:11:55,959 --> 00:12:03,009
by technical aspects by business aspects

00:12:00,639 --> 00:12:06,189
whatever you want there so handler can

00:12:03,009 --> 00:12:08,279
receive messages next part is handlers

00:12:06,189 --> 00:12:10,389
are responsible for handling i/o

00:12:08,279 --> 00:12:13,540
whatever we do if you interact with a

00:12:10,389 --> 00:12:15,490
file socket whatever else handlers will

00:12:13,540 --> 00:12:18,670
the ones who receive the working

00:12:15,490 --> 00:12:20,499
packages under the hood just as a little

00:12:18,670 --> 00:12:23,259
side remark vertex is complete

00:12:20,499 --> 00:12:25,179
completely based on Eddy 94.1 right now

00:12:23,259 --> 00:12:27,160
so that also that we get a pretty

00:12:25,179 --> 00:12:30,759
amazing performance with i/o operations

00:12:27,160 --> 00:12:32,769
there so this is basically it these are

00:12:30,759 --> 00:12:35,649
the building blocks the handler and the

00:12:32,769 --> 00:12:38,679
event loop now the nice thing is as I

00:12:35,649 --> 00:12:40,119
already said before these handles can

00:12:38,679 --> 00:12:42,850
retail register now through the event

00:12:40,119 --> 00:12:45,490
dose we have multiple handlers can I can

00:12:42,850 --> 00:12:47,170
register there we even allow handless to

00:12:45,490 --> 00:12:49,360
register under the same name which

00:12:47,170 --> 00:12:51,549
allows us to do instant round-robin

00:12:49,360 --> 00:12:52,779
there that is a property I show later on

00:12:51,549 --> 00:12:56,169
though if you go in the clustered mode

00:12:52,779 --> 00:12:58,629
and the other part is that the event bus

00:12:56,169 --> 00:13:00,329
works equally well distributed and this

00:12:58,629 --> 00:13:03,339
is like I think one of the core features

00:13:00,329 --> 00:13:06,369
the program programming model does not

00:13:03,339 --> 00:13:08,769
differ between local and distributed

00:13:06,369 --> 00:13:10,540
node you never know you don't care if

00:13:08,769 --> 00:13:12,339
the messages processed locally you have

00:13:10,540 --> 00:13:14,259
control if you really want to enforce

00:13:12,339 --> 00:13:16,449
local processing but in most cases you

00:13:14,259 --> 00:13:18,970
will just send out a message it may be

00:13:16,449 --> 00:13:20,319
expect an answer but what machine in

00:13:18,970 --> 00:13:21,610
your cluster is actually hailing it you

00:13:20,319 --> 00:13:23,440
don't care that some

00:13:21,610 --> 00:13:25,029
it has taken over and handled by the

00:13:23,440 --> 00:13:25,839
cluster manager which has just showed

00:13:25,029 --> 00:13:31,510
you that there are a couple of

00:13:25,839 --> 00:13:33,370
implementation there so now before we

00:13:31,510 --> 00:13:35,860
continue like on the topic of exactly

00:13:33,370 --> 00:13:40,540
once delivery well we have the same

00:13:35,860 --> 00:13:43,029
problem as akka there is none we have at

00:13:40,540 --> 00:13:45,760
most once delivery so means best effort

00:13:43,029 --> 00:13:47,589
you have solve like we have all the like

00:13:45,760 --> 00:13:49,660
something like yes pattern and occur so

00:13:47,589 --> 00:13:51,160
you have to ensure if you really want

00:13:49,660 --> 00:13:52,570
but if it's not fire and forget if you

00:13:51,160 --> 00:13:53,740
recast that somebody process two

00:13:52,570 --> 00:13:57,010
measures you will have to take care of

00:13:53,740 --> 00:13:59,620
that so and right now we arrived at the

00:13:57,010 --> 00:14:02,019
coding part I recently created a

00:13:59,620 --> 00:14:04,510
Gatorade template for it so this is all

00:14:02,019 --> 00:14:06,610
you need to type into your machine with

00:14:04,510 --> 00:14:09,579
a reason I think Oh point thirteen point

00:14:06,610 --> 00:14:12,269
fifteen version of SPT supports it

00:14:09,579 --> 00:14:15,250
correctly to get started with a full

00:14:12,269 --> 00:14:16,660
vertex project and this is what I'm

00:14:15,250 --> 00:14:20,560
going to show you right now what you get

00:14:16,660 --> 00:14:23,740
if you execute this command so thing

00:14:20,560 --> 00:14:25,570
number one is I fear it's a little over

00:14:23,740 --> 00:14:27,130
there but like the general light doesn't

00:14:25,570 --> 00:14:29,620
interest let's take a look first at the

00:14:27,130 --> 00:14:31,120
build a spec heat there's everything in

00:14:29,620 --> 00:14:32,920
there that you need to create fat

00:14:31,120 --> 00:14:34,959
Charles and dr. images so you can

00:14:32,920 --> 00:14:36,610
instantly just code your pentalobe micro

00:14:34,959 --> 00:14:38,890
servers and generate the parameter or

00:14:36,610 --> 00:14:40,930
fetch are out of this the most

00:14:38,890 --> 00:14:42,550
interesting part is is that I manage the

00:14:40,930 --> 00:14:44,079
dependency so yeah just showed you that

00:14:42,550 --> 00:14:46,110
we have a tremendous amount of modules

00:14:44,079 --> 00:14:48,910
available and if you just jump in here

00:14:46,110 --> 00:14:50,500
all available modules are there for you

00:14:48,910 --> 00:14:52,570
the only thing you have to do is add the

00:14:50,500 --> 00:14:54,640
dependency in your built SPG and you can

00:14:52,570 --> 00:14:56,829
start moving in there in here the only

00:14:54,640 --> 00:14:59,010
modules I include this vortex lines gala

00:14:56,829 --> 00:15:03,550
which is the actual language adapter I

00:14:59,010 --> 00:15:05,290
include vertex lab and Scala test this

00:15:03,550 --> 00:15:07,720
down here is a nasty little at over

00:15:05,290 --> 00:15:10,149
because like the Scala compiler will

00:15:07,720 --> 00:15:12,130
emit warnings if I have annotations that

00:15:10,149 --> 00:15:13,890
it doesn't find in the classpath so

00:15:12,130 --> 00:15:16,060
that's the reason why this one is there

00:15:13,890 --> 00:15:18,730
so let's take a look what we got in here

00:15:16,060 --> 00:15:21,250
the first interesting part in here is

00:15:18,730 --> 00:15:23,980
this it's the HTTP protocol which are

00:15:21,250 --> 00:15:25,899
going to elaborate a little more on and

00:15:23,980 --> 00:15:27,760
it shows like how vortex Excel works I

00:15:25,899 --> 00:15:29,290
told you that handlers and everything

00:15:27,760 --> 00:15:31,720
else is associated with the event loop

00:15:29,290 --> 00:15:34,800
so the question is like where does this

00:15:31,720 --> 00:15:36,209
event loop reside in here

00:15:34,800 --> 00:15:37,620
that's the vertical that's the thing

00:15:36,209 --> 00:15:40,350
that works got it it's name actually

00:15:37,620 --> 00:15:42,240
from each time I create a vertical this

00:15:40,350 --> 00:15:45,120
vertical is associated with one thread

00:15:42,240 --> 00:15:46,769
for its full lifetime in there okay I

00:15:45,120 --> 00:15:48,810
have now multiple options you see first

00:15:46,769 --> 00:15:50,430
of all to start huge a message you see

00:15:48,810 --> 00:15:53,490
it returned the future because

00:15:50,430 --> 00:15:55,260
everything we do in vertex is async also

00:15:53,490 --> 00:15:57,839
before we are not allowed to block so if

00:15:55,260 --> 00:16:00,959
I create a a server and that server for

00:15:57,839 --> 00:16:03,450
example that takes some time but vertex

00:16:00,959 --> 00:16:04,769
which are tell me go on here you got a

00:16:03,450 --> 00:16:06,810
future if you want to know if it

00:16:04,769 --> 00:16:08,700
succeeded take a look at the future and

00:16:06,810 --> 00:16:11,839
that's what I doing here I create a

00:16:08,700 --> 00:16:15,089
router which is coming from vertex lab

00:16:11,839 --> 00:16:19,140
I'll tell it for a get with a request to

00:16:15,089 --> 00:16:21,870
hello I want you to send world and down

00:16:19,140 --> 00:16:24,329
here um the actual part happens I have

00:16:21,870 --> 00:16:26,430
create a CH TTP server that directly

00:16:24,329 --> 00:16:29,250
spawns an Eddie instance under the hood

00:16:26,430 --> 00:16:30,959
I reduce them I request handler that

00:16:29,250 --> 00:16:32,790
means like this router I defined up here

00:16:30,959 --> 00:16:35,940
is now responsible for handling all

00:16:32,790 --> 00:16:37,410
incoming requests and then I call the

00:16:35,940 --> 00:16:38,790
massive losing future there's also a

00:16:37,410 --> 00:16:41,220
listen method that just say like I don't

00:16:38,790 --> 00:16:43,470
care like ignore the future listen

00:16:41,220 --> 00:16:45,959
future returns a future and a till it

00:16:43,470 --> 00:16:47,459
bind to this port and these are P

00:16:45,959 --> 00:16:50,550
addresses I want to find your every API

00:16:47,459 --> 00:16:52,200
pairs on my machine that's it and with

00:16:50,550 --> 00:16:55,680
that I already got a web server up and

00:16:52,200 --> 00:16:57,990
going the second part that you're

00:16:55,680 --> 00:16:59,730
getting here it's for the event bus that

00:16:57,990 --> 00:17:03,779
we're going to see in action in a few

00:16:59,730 --> 00:17:04,709
moments here I exact access again the

00:17:03,779 --> 00:17:07,110
vertex object

00:17:04,709 --> 00:17:09,329
I get the actual event bus I reduced a

00:17:07,110 --> 00:17:10,709
consumer under this address it is from

00:17:09,329 --> 00:17:13,319
this moment from this moment on I'm

00:17:10,709 --> 00:17:14,760
reachable under this address in all I do

00:17:13,319 --> 00:17:17,250
is just like each time a message is

00:17:14,760 --> 00:17:19,980
coming in I reply to the message which

00:17:17,250 --> 00:17:22,020
might be look familiar if you know the

00:17:19,980 --> 00:17:24,630
ask pattern from akka with hello world

00:17:22,020 --> 00:17:27,720
and this completion futures actually the

00:17:24,630 --> 00:17:30,030
interesting part because again we're

00:17:27,720 --> 00:17:31,770
running in a mostly distributed system

00:17:30,030 --> 00:17:34,350
that means this future will complete

00:17:31,770 --> 00:17:36,570
with when the cluster manager tells me

00:17:34,350 --> 00:17:38,550
registered it means like if it's

00:17:36,570 --> 00:17:40,020
propagated in the cluster that the

00:17:38,550 --> 00:17:43,590
cluster knows this instance is now

00:17:40,020 --> 00:17:46,110
reachable under test address further

00:17:43,590 --> 00:17:48,799
down here are a few tests that's for you

00:17:46,110 --> 00:17:51,179
to take a look at later on

00:17:48,799 --> 00:17:54,179
there's full test integration already

00:17:51,179 --> 00:17:56,790
variable it's based on plain vanilla

00:17:54,179 --> 00:17:59,669
Scala test there's a little helper class

00:17:56,790 --> 00:18:00,780
here and that's it so now further cause

00:17:59,669 --> 00:18:04,080
like I don't want to spend too much time

00:18:00,780 --> 00:18:07,980
on this simple example I will move

00:18:04,080 --> 00:18:13,110
forward to get actually something

00:18:07,980 --> 00:18:15,470
running so that takes a moment please

00:18:13,110 --> 00:18:18,540
don't start downloading yes thank you

00:18:15,470 --> 00:18:19,950
okay now we get some more classes down

00:18:18,540 --> 00:18:22,380
here and this is like the first thing

00:18:19,950 --> 00:18:24,270
we're going to take a look at this is

00:18:22,380 --> 00:18:25,830
basically one way to use vertex vertex

00:18:24,270 --> 00:18:28,380
can be completely embedded in your

00:18:25,830 --> 00:18:30,480
application you can run it at cetera and

00:18:28,380 --> 00:18:32,040
you can run it on the command line so

00:18:30,480 --> 00:18:33,780
there's all kinds of ways of using this

00:18:32,040 --> 00:18:35,580
for testing and for demos I prefer this

00:18:33,780 --> 00:18:37,049
way of doing it because I can show what

00:18:35,580 --> 00:18:39,059
I'm actually doing the first thing I do

00:18:37,049 --> 00:18:40,860
is I launch clustered vertex classic

00:18:39,059 --> 00:18:44,280
vertex mean please bring up the cluster

00:18:40,860 --> 00:18:48,799
manager in this case take a look at the

00:18:44,280 --> 00:18:52,919
building SPT it will be hazel cos so

00:18:48,799 --> 00:18:54,870
next thing is now this method will as

00:18:52,919 --> 00:18:57,360
soon as the instance of instances up and

00:18:54,870 --> 00:18:59,370
connected to the actual cluster I can

00:18:57,360 --> 00:19:02,130
return and then I can do start deploying

00:18:59,370 --> 00:19:06,630
my verticals in this case I will deploy

00:19:02,130 --> 00:19:08,400
the HTTP vertical another thing you will

00:19:06,630 --> 00:19:11,070
never have access to the instance of a

00:19:08,400 --> 00:19:13,770
protocol directly this is done do

00:19:11,070 --> 00:19:16,470
basically just tell vertex to spawn this

00:19:13,770 --> 00:19:18,540
thing we really really want to keep you

00:19:16,470 --> 00:19:20,580
cradled and safe by not allowing you to

00:19:18,540 --> 00:19:24,090
do any nasty things by having the actual

00:19:20,580 --> 00:19:25,919
instance in your hand so back into the

00:19:24,090 --> 00:19:28,620
HTTP vertical and that has grown a

00:19:25,919 --> 00:19:31,590
little first thing we see up here I

00:19:28,620 --> 00:19:33,360
create a sender sender is basically an

00:19:31,590 --> 00:19:35,760
abstraction that allows me now to send

00:19:33,360 --> 00:19:39,330
messages to the event bus always to the

00:19:35,760 --> 00:19:42,240
same address still have my router here

00:19:39,330 --> 00:19:43,799
to see to hello world but I also added

00:19:42,240 --> 00:19:46,620
another get requester and let's make

00:19:43,799 --> 00:19:50,280
this much visible another gets requested

00:19:46,620 --> 00:19:52,410
roll onto two hello again and if you

00:19:50,280 --> 00:19:55,559
look in here that's where I use the

00:19:52,410 --> 00:19:59,010
sender this sender will now each time

00:19:55,559 --> 00:20:01,230
when a call send futures or send the

00:19:59,010 --> 00:20:04,799
world the work will

00:20:01,230 --> 00:20:06,360
to test address and wait for a reply

00:20:04,799 --> 00:20:08,280
that's implied by the future that's

00:20:06,360 --> 00:20:09,750
coming back so I really I want to see

00:20:08,280 --> 00:20:10,830
this thing I like that and I like a

00:20:09,750 --> 00:20:13,200
knocker you have the syntactic sugar

00:20:10,830 --> 00:20:17,880
with the question mark we don't have to

00:20:13,200 --> 00:20:22,020
start now so let's take a look how this

00:20:17,880 --> 00:20:29,880
thing looks if I run it so let's get

00:20:22,020 --> 00:20:32,370
started we see a lot going on down here

00:20:29,880 --> 00:20:34,950
this is basically hazel cars coming up

00:20:32,370 --> 00:20:38,520
and registering the first cluster member

00:20:34,950 --> 00:20:42,450
as we see here and now let's state that

00:20:38,520 --> 00:20:44,700
let's take a look at the hello URL and

00:20:42,450 --> 00:20:46,980
as expected we get worlds back so that's

00:20:44,700 --> 00:20:48,390
the easiest case now if you'll take a

00:20:46,980 --> 00:20:52,620
look again at the character that just

00:20:48,390 --> 00:20:54,059
wrote you see here we wait for a message

00:20:52,620 --> 00:20:56,790
to come back and if you don't get any

00:20:54,059 --> 00:20:58,919
message back the failure says no one is

00:20:56,790 --> 00:21:01,919
here so means like nobody is answering

00:20:58,919 --> 00:21:04,320
on this address right now let's tie off

00:21:01,919 --> 00:21:08,520
let's play around with this with this

00:21:04,320 --> 00:21:10,080
case on hello again and we are now say

00:21:08,520 --> 00:21:12,210
at service is not receiving any answers

00:21:10,080 --> 00:21:14,760
so how do we get these answers going out

00:21:12,210 --> 00:21:18,090
and I'll use to instantly start this by

00:21:14,760 --> 00:21:20,010
actually spawning a separate VM here's a

00:21:18,090 --> 00:21:22,049
separate runner so that means like if I

00:21:20,010 --> 00:21:27,480
run this this will actually spawn a new

00:21:22,049 --> 00:21:30,059
JVM so I bring up this JVM you see now

00:21:27,480 --> 00:21:32,429
again a lot of stuff going on down here

00:21:30,059 --> 00:21:34,590
and we see a nice little thing here we

00:21:32,429 --> 00:21:37,950
see now to cluster members if we look at

00:21:34,590 --> 00:21:41,490
the other JVM we also see another JVM

00:21:37,950 --> 00:21:47,100
has joined and if I go now in here and

00:21:41,490 --> 00:21:49,320
hit reload we get a hello world with

00:21:47,100 --> 00:21:51,929
this hash code so I didn't show you I

00:21:49,320 --> 00:21:54,030
actually modified this radical so this

00:21:51,929 --> 00:21:59,190
is basically taking the incoming message

00:21:54,030 --> 00:22:04,350
appending prepending hello and getting

00:21:59,190 --> 00:22:06,179
the hash code into a header so let me

00:22:04,350 --> 00:22:08,820
try same again

00:22:06,179 --> 00:22:10,409
and same again now this is already

00:22:08,820 --> 00:22:12,990
pretty nice so this means I can just

00:22:10,409 --> 00:22:14,970
bring up as many JVMs as I want and they

00:22:12,990 --> 00:22:16,860
will join each other and this is

00:22:14,970 --> 00:22:19,860
also chew in a distributed system in the

00:22:16,860 --> 00:22:21,510
default mode hazel caste will use UDP

00:22:19,860 --> 00:22:23,789
multi casting to find it I'll find other

00:22:21,510 --> 00:22:25,830
instances that you can use TCP we

00:22:23,789 --> 00:22:27,330
already embedded in to Vanitas where you

00:22:25,830 --> 00:22:30,450
can use the community service discovery

00:22:27,330 --> 00:22:32,669
no they have that spi which is based on

00:22:30,450 --> 00:22:35,039
the queue bonitas taking facility so

00:22:32,669 --> 00:22:37,980
that every node that you have that has

00:22:35,039 --> 00:22:40,620
running a vertex instance can join this

00:22:37,980 --> 00:22:42,620
whole cluster so and just to prove that

00:22:40,620 --> 00:22:46,679
this is actually working

00:22:42,620 --> 00:22:49,799
I'll launch the next one so now I will

00:22:46,679 --> 00:22:52,590
have two instances running off my bus

00:22:49,799 --> 00:22:59,909
protocol we see down here it joins the

00:22:52,590 --> 00:23:01,919
cluster instantly I never go up here you

00:22:59,909 --> 00:23:03,570
see the hash code change and this is the

00:23:01,919 --> 00:23:06,030
other unique property I launched the

00:23:03,570 --> 00:23:09,480
same vertical twice in different VMs

00:23:06,030 --> 00:23:12,750
each of the VMS registers the test

00:23:09,480 --> 00:23:13,860
address we figure out like the cluster

00:23:12,750 --> 00:23:16,770
manager sees okay there are now two

00:23:13,860 --> 00:23:18,059
instances in each time we want to send

00:23:16,770 --> 00:23:20,669
to an insert it does an automatic

00:23:18,059 --> 00:23:21,990
round-robin it's currently an unweighted

00:23:20,669 --> 00:23:23,010
route roaming that's something I want to

00:23:21,990 --> 00:23:25,919
work on in the future

00:23:23,010 --> 00:23:27,510
to get other algorithms there but our

00:23:25,919 --> 00:23:28,740
community is pretty happy with what they

00:23:27,510 --> 00:23:30,809
have right now so I can't just add

00:23:28,740 --> 00:23:32,940
machines and machines and machines and

00:23:30,809 --> 00:23:39,270
the system will take care to spread out

00:23:32,940 --> 00:23:42,030
the load of all of these machines so

00:23:39,270 --> 00:23:44,669
that's it for showing you how the

00:23:42,030 --> 00:23:47,039
cluster actually works so this is this

00:23:44,669 --> 00:23:48,650
is already pretty easy but there's other

00:23:47,039 --> 00:23:55,919
things that are really off about this

00:23:48,650 --> 00:23:57,929
let's go to the next example and another

00:23:55,919 --> 00:24:00,120
set of kudos to hi Casa Vega for the

00:23:57,929 --> 00:24:04,140
zero plug-in SPG's is like the best

00:24:00,120 --> 00:24:06,960
thing I've seen in a while so this time

00:24:04,140 --> 00:24:11,390
I edit a new vertical which is the chat

00:24:06,960 --> 00:24:13,740
vertical let's take a look at this I

00:24:11,390 --> 00:24:15,480
just told you that the event bus is

00:24:13,740 --> 00:24:17,299
actually spreading across the whole

00:24:15,480 --> 00:24:20,159
cluster connecting each of the nodes

00:24:17,299 --> 00:24:22,830
what we also did is the event Buster can

00:24:20,159 --> 00:24:26,010
stretch into your browser using

00:24:22,830 --> 00:24:27,480
WebSockets so what we can do is just

00:24:26,010 --> 00:24:31,100
that we can connect a brow

00:24:27,480 --> 00:24:33,300
so directly to our to our running system

00:24:31,100 --> 00:24:35,490
so let's take a look how we achieve this

00:24:33,300 --> 00:24:38,240
so there's a few more things now here

00:24:35,490 --> 00:24:42,690
but let's focus on this here

00:24:38,240 --> 00:24:44,220
you see I add a new handler from the

00:24:42,690 --> 00:24:46,140
init struct chess method and you see

00:24:44,220 --> 00:24:48,050
down here so this is the core of this

00:24:46,140 --> 00:24:50,670
like to use sake is in the background to

00:24:48,050 --> 00:24:52,380
allow the browser to communicate with us

00:24:50,670 --> 00:24:54,720
what kind of interaction it actually

00:24:52,380 --> 00:24:56,310
prefers so like the default is WebSocket

00:24:54,720 --> 00:24:58,050
it can fall back on long polling and

00:24:56,310 --> 00:25:01,230
other other mechanisms to mimic the

00:24:58,050 --> 00:25:02,910
behavior of WebSocket then we establish

00:25:01,230 --> 00:25:04,620
the bridge and that's the key thing so

00:25:02,910 --> 00:25:06,030
we won't simply allow the browser to

00:25:04,620 --> 00:25:06,960
connect to our internal system that

00:25:06,030 --> 00:25:08,670
would be suicide

00:25:06,960 --> 00:25:10,770
what we can doing here is this is just

00:25:08,670 --> 00:25:12,930
like the most basic thing I can do in

00:25:10,770 --> 00:25:14,310
default mode it won't allow any message

00:25:12,930 --> 00:25:15,810
to pass back and forth between the

00:25:14,310 --> 00:25:19,200
system and the browser so I have to

00:25:15,810 --> 00:25:22,890
explicitly allow what can go out of my

00:25:19,200 --> 00:25:24,960
system and I can specifically allow for

00:25:22,890 --> 00:25:26,970
can go into my system I can use all kind

00:25:24,960 --> 00:25:28,650
of Y cards in there too especially very

00:25:26,970 --> 00:25:30,780
closely and it can even have content

00:25:28,650 --> 00:25:32,430
batches that will take care that only

00:25:30,780 --> 00:25:34,380
well-formed messages actually enter the

00:25:32,430 --> 00:25:35,910
system so this is a pretty tough defense

00:25:34,380 --> 00:25:39,360
it's like more quality to a firewall

00:25:35,910 --> 00:25:42,750
that we have in place in there so this

00:25:39,360 --> 00:25:44,790
is part 1 part 2 us and that's the chat

00:25:42,750 --> 00:25:46,260
UI appear so like I went fancy and did

00:25:44,790 --> 00:25:48,240
react and then along that react is

00:25:46,260 --> 00:25:50,250
already dead like everything in this guy

00:25:48,240 --> 00:25:50,640
in the JavaScript dies within like 24

00:25:50,250 --> 00:25:53,520
hours

00:25:50,640 --> 00:25:58,110
so the key thing we have in here is just

00:25:53,520 --> 00:25:59,640
like there is distributed via NPM so you

00:25:58,110 --> 00:26:01,920
get it with your standard JavaScript

00:25:59,640 --> 00:26:03,990
dependency management there is the whole

00:26:01,920 --> 00:26:06,570
event of client is available in the

00:26:03,990 --> 00:26:12,410
regular JavaScript repositories that's

00:26:06,570 --> 00:26:12,410
one thing we can we put in here and then

00:26:13,250 --> 00:26:19,440
what we do is the only thing we have to

00:26:15,540 --> 00:26:21,090
do is we instantiate our event bus so

00:26:19,440 --> 00:26:22,710
this is like basically like as soon as

00:26:21,090 --> 00:26:26,510
the application opens it will do a

00:26:22,710 --> 00:26:29,820
connect pack and then we have the

00:26:26,510 --> 00:26:31,230
descending part down here which

00:26:29,820 --> 00:26:33,390
basically just just takes back

00:26:31,230 --> 00:26:38,490
information and then send the message on

00:26:33,390 --> 00:26:40,870
the event bus we also reduced a listener

00:26:38,490 --> 00:26:43,640
[Music]

00:26:40,870 --> 00:26:48,200
that's in the list

00:26:43,640 --> 00:26:51,530
exactly so up here is the interesting

00:26:48,200 --> 00:26:56,660
code what are doing there I resist a

00:26:51,530 --> 00:26:58,190
handle for the address browser and first

00:26:56,660 --> 00:27:02,600
of all I lock everything that's coming

00:26:58,190 --> 00:27:04,430
in on the console and I append the

00:27:02,600 --> 00:27:06,740
message to my existing list of messages

00:27:04,430 --> 00:27:09,020
so what you now may be realizing is that

00:27:06,740 --> 00:27:12,800
this is a chat application that I just

00:27:09,020 --> 00:27:15,770
came up here with so how does this

00:27:12,800 --> 00:27:27,080
actually work I'll fire after the whole

00:27:15,770 --> 00:27:29,600
thing wrong put so as you see here I do

00:27:27,080 --> 00:27:31,970
I have an example another example like I

00:27:29,600 --> 00:27:34,250
deploy the chat protocol I give it some

00:27:31,970 --> 00:27:35,900
options with it in this case I specify

00:27:34,250 --> 00:27:37,790
the port so that is how you provide

00:27:35,900 --> 00:27:39,290
configuration aesthetic way we also have

00:27:37,790 --> 00:27:42,050
the dynamic way with the configuration

00:27:39,290 --> 00:27:44,660
managers so now I just fire up this

00:27:42,050 --> 00:27:47,710
whole thing I hope I didn't have

00:27:44,660 --> 00:27:52,460
anything else running oh crap I have

00:27:47,710 --> 00:27:59,270
wait oh no I killed it on one I will

00:27:52,460 --> 00:28:06,050
start so the application is up and

00:27:59,270 --> 00:28:07,270
running so now open much yet so I write

00:28:06,050 --> 00:28:10,580
a message down here

00:28:07,270 --> 00:28:12,200
ok great s email message we already see

00:28:10,580 --> 00:28:13,910
that it has been a ritual the server

00:28:12,200 --> 00:28:16,340
cycles I appended some information about

00:28:13,910 --> 00:28:18,640
the date but now let's open a second

00:28:16,340 --> 00:28:18,640
processor

00:28:25,200 --> 00:28:30,760
so the messages over here so you see

00:28:29,020 --> 00:28:33,760
this is a pretty powerful constructed

00:28:30,760 --> 00:28:37,060
we've already be using this for online

00:28:33,760 --> 00:28:38,980
gaming and IOT application because this

00:28:37,060 --> 00:28:40,540
really means like we can based on a

00:28:38,980 --> 00:28:42,190
WebSocket connections we can just

00:28:40,540 --> 00:28:44,050
exchange information over the sockets

00:28:42,190 --> 00:28:46,060
with allowing someone to register a

00:28:44,050 --> 00:28:48,130
handler for that it also makes it

00:28:46,060 --> 00:28:50,230
tremendously easy to get interactions

00:28:48,130 --> 00:28:51,910
with the system going just is if you

00:28:50,230 --> 00:28:53,950
look I mean like this is it's not the

00:28:51,910 --> 00:28:57,220
nicest like it won't be a competition to

00:28:53,950 --> 00:28:58,990
slack or any other but take a look at

00:28:57,220 --> 00:29:04,630
the amount of code we just needed to set

00:28:58,990 --> 00:29:06,700
up a full chat server this is basically

00:29:04,630 --> 00:29:08,620
the word of me just spending ten to

00:29:06,700 --> 00:29:12,340
fifteen minutes on coding this whole

00:29:08,620 --> 00:29:14,200
example the other interesting part that

00:29:12,340 --> 00:29:16,870
I just want to point out is like just

00:29:14,200 --> 00:29:18,700
serving static content this was also

00:29:16,870 --> 00:29:20,050
like a just a small addition that we

00:29:18,700 --> 00:29:22,920
have to do about adding the static

00:29:20,050 --> 00:29:25,660
handler which will automatically resolve

00:29:22,920 --> 00:29:28,000
everything that's here in Webroot on the

00:29:25,660 --> 00:29:29,830
class map I can specify the file system

00:29:28,000 --> 00:29:31,570
I can allow it to reload from the file

00:29:29,830 --> 00:29:33,640
system if I want to edit around in there

00:29:31,570 --> 00:29:37,410
so I have all kind of possibilities for

00:29:33,640 --> 00:29:37,410
interacting with stuff in here so

00:29:37,620 --> 00:29:47,170
clients move on to the next part next

00:29:45,100 --> 00:29:48,610
part is going to show you how you can

00:29:47,170 --> 00:29:50,200
integrate a proof let's shell in your

00:29:48,610 --> 00:29:52,690
application this is like a very useful

00:29:50,200 --> 00:29:54,610
thing that I learned when working for

00:29:52,690 --> 00:29:56,950
certain big companies it won't allow me

00:29:54,610 --> 00:30:00,490
to look on the machine but forget to

00:29:56,950 --> 00:30:01,930
close the telnet port so there are other

00:30:00,490 --> 00:30:04,090
situation where you want to debug your

00:30:01,930 --> 00:30:05,560
application I'll just you want to

00:30:04,090 --> 00:30:07,540
interview to do some quick checking on a

00:30:05,560 --> 00:30:09,550
running application one way is you can

00:30:07,540 --> 00:30:11,200
just get out the metrics for metrics we

00:30:09,550 --> 00:30:12,720
have popular support drop wizard and all

00:30:11,200 --> 00:30:14,710
kind of other we're currently

00:30:12,720 --> 00:30:16,810
abstracting it more way so we can

00:30:14,710 --> 00:30:18,610
directly write to things like influx to

00:30:16,810 --> 00:30:20,950
be I'm dosing this is currently being

00:30:18,610 --> 00:30:23,830
thought of how we can achieve that but

00:30:20,950 --> 00:30:26,530
right now what's again interesting is

00:30:23,830 --> 00:30:29,890
let's take a look at this launcher for

00:30:26,530 --> 00:30:31,210
now as you've seen before I just had the

00:30:29,890 --> 00:30:35,190
chat world it will be plugged in here in

00:30:31,210 --> 00:30:35,190
here but now I added another one

00:30:35,530 --> 00:30:40,390
this is basically a way of deploying of

00:30:37,750 --> 00:30:42,340
servers in vertex so all I do is in my

00:30:40,390 --> 00:30:45,430
build SPT I add a dependency to the

00:30:42,340 --> 00:30:46,870
shell servers and then I tell the system

00:30:45,430 --> 00:30:49,150
please deploy a service that is

00:30:46,870 --> 00:30:51,640
registered under this name which is

00:30:49,150 --> 00:30:53,800
available in the class path all I do is

00:30:51,640 --> 00:30:55,570
I give it the town adoption so I specify

00:30:53,800 --> 00:30:56,860
I want to bring up talent when I like it

00:30:55,570 --> 00:30:58,810
didn't I really didn't want to mess

00:30:56,860 --> 00:31:00,250
around now with key storage so like so

00:30:58,810 --> 00:31:02,110
you would normally pick as secure shell

00:31:00,250 --> 00:31:05,170
hope nobody thinks that color is a nice

00:31:02,110 --> 00:31:09,850
option so but it specifies please find a

00:31:05,170 --> 00:31:19,810
local host on port 4000 so and we start

00:31:09,850 --> 00:31:28,210
this again so the server is up and going

00:31:19,810 --> 00:31:31,060
I again open my local chat get rid of

00:31:28,210 --> 00:31:35,680
those open another one so we see the

00:31:31,060 --> 00:31:43,390
interactions at there so this should be

00:31:35,680 --> 00:31:47,950
you yes it is and now let's go let's

00:31:43,390 --> 00:31:50,440
login vile telnet and here we are so we

00:31:47,950 --> 00:31:52,930
right now I walked into the the vortex

00:31:50,440 --> 00:31:54,760
runtime the support options we have in

00:31:52,930 --> 00:31:56,110
here there is a couple of commands that

00:31:54,760 --> 00:31:58,360
are just you can add your custom

00:31:56,110 --> 00:32:01,270
commands to this and I think the most

00:31:58,360 --> 00:32:04,360
interesting one is now bus tail so we

00:32:01,270 --> 00:32:07,360
want to see what's going on on the

00:32:04,360 --> 00:32:10,060
browser address so now this is like like

00:32:07,360 --> 00:32:14,760
a standard command line tail I'll go in

00:32:10,060 --> 00:32:19,840
here now in the browser type hello world

00:32:14,760 --> 00:32:21,790
and looking in here we now see the exact

00:32:19,840 --> 00:32:25,240
JSON message I am sending to the browser

00:32:21,790 --> 00:32:26,680
from the inside of vortex so this is

00:32:25,240 --> 00:32:28,990
like also like a pretty nice and

00:32:26,680 --> 00:32:31,240
powerful feature to debug to debug your

00:32:28,990 --> 00:32:33,070
application or you can have like other

00:32:31,240 --> 00:32:35,950
control options in there because you can

00:32:33,070 --> 00:32:40,780
just add your custom commands and extend

00:32:35,950 --> 00:32:44,190
this thing a lot more now this is

00:32:40,780 --> 00:32:47,620
already pretty nice but one thing that

00:32:44,190 --> 00:32:48,389
is currently missing that I'm working on

00:32:47,620 --> 00:32:50,909
for

00:32:48,389 --> 00:32:52,440
vortex collars but I don't really have a

00:32:50,909 --> 00:32:54,929
nice streaming idea right now

00:32:52,440 --> 00:32:56,849
it may be like I can reduce a lot of

00:32:54,929 --> 00:32:58,559
things by using the scale of huges so we

00:32:56,849 --> 00:33:00,629
don't have like the callback hell that

00:32:58,559 --> 00:33:03,089
you might know from nodejs and all the

00:33:00,629 --> 00:33:05,820
systems so we can reduce this but having

00:33:03,089 --> 00:33:07,739
something like akka streams or like RX

00:33:05,820 --> 00:33:10,409
Java or X kala in there would be pretty

00:33:07,739 --> 00:33:12,509
nice now the situation is that rx kala 2

00:33:10,409 --> 00:33:15,450
is not yet there like they are working

00:33:12,509 --> 00:33:17,159
on it and I didn't want to get our x :

00:33:15,450 --> 00:33:19,229
there and I had like a little side

00:33:17,159 --> 00:33:21,179
project I was working on like get a

00:33:19,229 --> 00:33:24,059
deeper understanding of reactive streams

00:33:21,179 --> 00:33:28,229
so a new thing that I'm currently adding

00:33:24,059 --> 00:33:31,200
and which is something I hope that maybe

00:33:28,229 --> 00:33:33,419
some people are interested in taking a

00:33:31,200 --> 00:33:35,489
look at for the future is vertex streams

00:33:33,419 --> 00:33:39,209
which is a pretty recent thing I started

00:33:35,489 --> 00:33:40,739
working on which provides like I won't

00:33:39,209 --> 00:33:42,029
even come I don't even want to compare

00:33:40,739 --> 00:33:43,169
myself to like what our customers

00:33:42,029 --> 00:33:45,329
currently provide cause it's way way

00:33:43,169 --> 00:33:47,909
bigger but it basically provides back

00:33:45,329 --> 00:33:49,769
pressured streams I haven't mentioned

00:33:47,909 --> 00:33:51,479
before all parts of cortex or back

00:33:49,769 --> 00:33:54,029
pressures or back pressure capable that

00:33:51,479 --> 00:33:55,589
means like we already used the whole

00:33:54,029 --> 00:33:57,209
like the high-water marks feature for

00:33:55,589 --> 00:33:59,219
Neddie for all I or interactions it

00:33:57,209 --> 00:34:01,019
means like everything you do like with

00:33:59,219 --> 00:34:03,269
files and sockets is already back

00:34:01,019 --> 00:34:06,119
pressured on the event paths we edit

00:34:03,269 --> 00:34:08,010
this I think with 3.3 or 3.4 that means

00:34:06,119 --> 00:34:08,490
like since then if you interact over the

00:34:08,010 --> 00:34:10,409
eventbus

00:34:08,490 --> 00:34:12,809
you can you don't have to but you can

00:34:10,409 --> 00:34:15,899
rely on back pressure information which

00:34:12,809 --> 00:34:17,369
means I get tokens from what from the

00:34:15,899 --> 00:34:19,349
other side from the receiving end to

00:34:17,369 --> 00:34:21,389
tell me that I can continue sending like

00:34:19,349 --> 00:34:23,309
it's like a very basic form that we have

00:34:21,389 --> 00:34:25,349
in there so but like making this

00:34:23,309 --> 00:34:27,659
actually more usable and more flexible

00:34:25,349 --> 00:34:30,329
because right now we can just pump like

00:34:27,659 --> 00:34:32,369
the construct we use like messages of

00:34:30,329 --> 00:34:34,559
type Jason to another receive of type

00:34:32,369 --> 00:34:36,629
Jason but so we need at least a little

00:34:34,559 --> 00:34:38,569
map operation in between I started

00:34:36,629 --> 00:34:43,109
actually working on work experience

00:34:38,569 --> 00:34:45,480
which is the it's currently only

00:34:43,109 --> 00:34:48,179
available on my personal repository and

00:34:45,480 --> 00:34:50,700
just to show you like what I'm actually

00:34:48,179 --> 00:34:54,299
going for is like I simply integrated

00:34:50,700 --> 00:34:57,359
acha into vortex so I committed some

00:34:54,299 --> 00:34:59,130
heresy so I just took like one reactive

00:34:57,359 --> 00:35:01,259
application framework and crammed it

00:34:59,130 --> 00:35:02,050
into another a reactive application

00:35:01,259 --> 00:35:04,510
framework and connect

00:35:02,050 --> 00:35:06,760
those two using reactive streams and

00:35:04,510 --> 00:35:09,220
this is a part that actually work come

00:35:06,760 --> 00:35:12,820
on surprise pretty nicely so what we

00:35:09,220 --> 00:35:16,330
have I have over here is again I defined

00:35:12,820 --> 00:35:19,210
a producer the producer is already what

00:35:16,330 --> 00:35:21,970
we call in vertex a right stream so it's

00:35:19,210 --> 00:35:23,590
like something I just can write to the

00:35:21,970 --> 00:35:25,060
producer itself has all the back

00:35:23,590 --> 00:35:27,670
pressure information required I just

00:35:25,060 --> 00:35:29,560
have to use it so in this case I tell it

00:35:27,670 --> 00:35:31,660
I want to send everything to the

00:35:29,560 --> 00:35:35,830
receiver address which is called the

00:35:31,660 --> 00:35:39,340
sink address then I start by creating an

00:35:35,830 --> 00:35:41,110
aqua flow so as you can see here before

00:35:39,340 --> 00:35:44,560
we can read this this is really just a

00:35:41,110 --> 00:35:45,940
reactive streams publisher the reactive

00:35:44,560 --> 00:35:48,490
streams park brochure is if you have

00:35:45,940 --> 00:35:51,370
seen the talk from haiku I create my

00:35:48,490 --> 00:35:52,350
archive system my active system I create

00:35:51,370 --> 00:35:55,270
the materializer

00:35:52,350 --> 00:35:56,890
then I create a source in this case the

00:35:55,270 --> 00:36:00,630
only thing I want is the source that

00:35:56,890 --> 00:36:04,630
emits the values from 0 to 100 and one I

00:36:00,630 --> 00:36:10,060
map the whole thing and then a dry run

00:36:04,630 --> 00:36:11,470
with so in this case I tell it to take

00:36:10,060 --> 00:36:12,040
this whole thing we convert it into a

00:36:11,470 --> 00:36:15,420
publisher

00:36:12,040 --> 00:36:18,670
which means now I have like an open

00:36:15,420 --> 00:36:22,150
water pipe that's going to pump out my

00:36:18,670 --> 00:36:24,490
values and I've up here I use my stream

00:36:22,150 --> 00:36:26,940
method like I used to put my library

00:36:24,490 --> 00:36:30,490
pattern here to get this in place here I

00:36:26,940 --> 00:36:32,170
connect my sink my sink is my producer

00:36:30,490 --> 00:36:34,780
in this case so basically what this

00:36:32,170 --> 00:36:36,520
means is akka is producing the values

00:36:34,780 --> 00:36:41,260
and I'm just pumping them out to the

00:36:36,520 --> 00:36:44,770
event bus and down here I start the

00:36:41,260 --> 00:36:48,970
whole thing we now take a little look at

00:36:44,770 --> 00:36:51,040
the actual runner what you run actually

00:36:48,970 --> 00:36:52,600
does right now it's just I do a little

00:36:51,040 --> 00:36:55,600
more than I'm normally doing here I

00:36:52,600 --> 00:36:57,250
create a vertex instance this time I

00:36:55,600 --> 00:36:58,990
didn't create a clustered one this is

00:36:57,250 --> 00:37:00,190
Regis when you want to run locally

00:36:58,990 --> 00:37:01,060
because we just want to taste those

00:37:00,190 --> 00:37:03,640
functionality

00:37:01,060 --> 00:37:06,550
I create my vertex execution complex

00:37:03,640 --> 00:37:07,960
this is normally taking a care of by the

00:37:06,550 --> 00:37:09,580
vertical but I don't have a vertical

00:37:07,960 --> 00:37:12,520
here so I have to actually provide the

00:37:09,580 --> 00:37:15,100
execution context to run on and then I'm

00:37:12,520 --> 00:37:16,049
able to reduce the consumer to the

00:37:15,100 --> 00:37:18,269
address that

00:37:16,049 --> 00:37:21,900
my flow without that my stream is going

00:37:18,269 --> 00:37:24,660
to send every every value - I know I do

00:37:21,900 --> 00:37:27,869
is I make a print line and print out all

00:37:24,660 --> 00:37:33,150
the values that are coming in so and

00:37:27,869 --> 00:37:38,939
let's run this whole thing so I'm down

00:37:33,150 --> 00:37:42,410
here again so here we go so this is

00:37:38,939 --> 00:37:48,029
basically the part that I hope to add to

00:37:42,410 --> 00:37:50,069
vertex with version 3 5 there's still

00:37:48,029 --> 00:37:52,589
going to be a lot work going on in this

00:37:50,069 --> 00:37:54,150
area this is definitely not done yet but

00:37:52,589 --> 00:37:56,069
I'm already pretty satisfied like how

00:37:54,150 --> 00:37:57,900
things interact and for me like the

00:37:56,069 --> 00:37:59,849
extra proof of constables read to get

00:37:57,900 --> 00:38:02,670
something out of that space and reactive

00:37:59,849 --> 00:38:07,859
seems to connect to my stream and use it

00:38:02,670 --> 00:38:09,239
in there so this was actually a lot

00:38:07,859 --> 00:38:12,989
faster than I expected the first time I

00:38:09,239 --> 00:38:14,609
get to start this way so the streams are

00:38:12,989 --> 00:38:17,369
like the next kinda thing coming up

00:38:14,609 --> 00:38:20,609
version 342 of logics is going to be

00:38:17,369 --> 00:38:23,160
released in the next two weeks it's

00:38:20,609 --> 00:38:24,660
going it's for me it's going to be a

00:38:23,160 --> 00:38:26,549
pretty significant release because right

00:38:24,660 --> 00:38:28,979
now that's the relief that I consider

00:38:26,549 --> 00:38:30,420
the Scala support to be stable there's a

00:38:28,979 --> 00:38:31,920
lot of input from the community from

00:38:30,420 --> 00:38:33,599
people trying it out and playing around

00:38:31,920 --> 00:38:35,759
with it we solve several problems

00:38:33,599 --> 00:38:37,319
there's a mostly based around the idea

00:38:35,759 --> 00:38:41,160
like how we actually generate the whole

00:38:37,319 --> 00:38:43,319
API so with 3/4 - this thing is actually

00:38:41,160 --> 00:38:45,599
in a stable state so there's no more API

00:38:43,319 --> 00:38:47,999
changes to be expected and that's the

00:38:45,599 --> 00:38:50,069
part where I start like with some deeper

00:38:47,999 --> 00:38:52,349
benchmarking right now we just did like

00:38:50,069 --> 00:38:54,150
some basic benchmarking to see like that

00:38:52,349 --> 00:38:55,829
the performances at least somewhere in

00:38:54,150 --> 00:38:58,619
their area where we expected it to be I

00:38:55,829 --> 00:39:00,299
hope at some point you get some time to

00:38:58,619 --> 00:39:02,369
get also in the tech and power benchmark

00:39:00,299 --> 00:39:04,170
which protects is already part of and

00:39:02,369 --> 00:39:07,559
we're always like in the top 10 or 20 of

00:39:04,170 --> 00:39:12,630
those frameworks tested in there and for

00:39:07,559 --> 00:39:14,699
today I would say I showed you what I

00:39:12,630 --> 00:39:16,469
wanted to show I was a lot faster than I

00:39:14,699 --> 00:39:17,849
expected I'm sorry but I guess like

00:39:16,469 --> 00:39:24,439
everyone is also waiting for the party

00:39:17,849 --> 00:39:24,439
so questions yes

00:39:26,460 --> 00:39:36,760
oh I have I have so many questions I'm

00:39:31,840 --> 00:39:39,840
here for tomorrow's you so about

00:39:36,760 --> 00:39:42,640
resilience yes

00:39:39,840 --> 00:39:45,070
so for resilience and clustering then

00:39:42,640 --> 00:39:46,570
you would register one or more handlers

00:39:45,070 --> 00:39:51,220
on each node because you don't know

00:39:46,570 --> 00:39:53,320
which nose they go to exactly but that

00:39:51,220 --> 00:39:56,140
it is in a cluster is abstracted away

00:39:53,320 --> 00:39:57,700
right so there is no guarantee that

00:39:56,140 --> 00:40:01,180
there is any handlers for a name at any

00:39:57,700 --> 00:40:03,670
given point in time so there's there's a

00:40:01,180 --> 00:40:04,930
few things I do like it really depends

00:40:03,670 --> 00:40:06,190
on how we design there's like what I

00:40:04,930 --> 00:40:07,420
didn't show you because like there's so

00:40:06,190 --> 00:40:09,220
many features I could show you is

00:40:07,420 --> 00:40:11,290
there's a high availability mode in

00:40:09,220 --> 00:40:13,990
vortex where you can reduce the bare

00:40:11,290 --> 00:40:15,400
instances which will look like they see

00:40:13,990 --> 00:40:17,410
in the class so for instance goes away

00:40:15,400 --> 00:40:19,540
so you mark an instance okay this is

00:40:17,410 --> 00:40:21,400
important that it keeps running and if

00:40:19,540 --> 00:40:22,750
it registers while the cluster manager

00:40:21,400 --> 00:40:24,760
that the instance is calling so it

00:40:22,750 --> 00:40:27,460
reached the heartbeat timeout it will

00:40:24,760 --> 00:40:29,590
replace the instant instantly deploy the

00:40:27,460 --> 00:40:31,540
missing part the other thing I normally

00:40:29,590 --> 00:40:33,700
do is just like I normally rely heavily

00:40:31,540 --> 00:40:35,290
on monitoring like it's like I don't

00:40:33,700 --> 00:40:37,060
think it's the property of a framework

00:40:35,290 --> 00:40:38,109
to handle every type of occurring

00:40:37,060 --> 00:40:40,180
failure like that's what we have

00:40:38,109 --> 00:40:41,859
monitoring for the key thing is that we

00:40:40,180 --> 00:40:43,930
can recover from failure as fast as

00:40:41,859 --> 00:40:45,520
possible that means if it starts

00:40:43,930 --> 00:40:47,460
throwing new instances so I like my

00:40:45,520 --> 00:40:50,590
monitoring which is a sudden peak in

00:40:47,460 --> 00:40:52,300
usage I need to be able to just throw

00:40:50,590 --> 00:40:54,840
new instances in there and to instantly

00:40:52,300 --> 00:40:57,310
take over work and start consuming if

00:40:54,840 --> 00:41:00,550
instances break away that's something

00:40:57,310 --> 00:41:02,320
that I normally see with systems like in

00:41:00,550 --> 00:41:03,580
Stannah eff dynamics or wherever like

00:41:02,320 --> 00:41:06,070
they see that like something got

00:41:03,580 --> 00:41:08,080
corrupted and it's gone so and they will

00:41:06,070 --> 00:41:10,510
then tell Cuba need it or whatever just

00:41:08,080 --> 00:41:12,460
like gone do something and then they

00:41:10,510 --> 00:41:14,410
rejoin let's know like how I design it

00:41:12,460 --> 00:41:17,320
on the applications for resilience so I

00:41:14,410 --> 00:41:19,920
take care like so that I have a way to

00:41:17,320 --> 00:41:23,260
realize like when a machine is gone I

00:41:19,920 --> 00:41:27,010
can deploy additional things to a load

00:41:23,260 --> 00:41:28,869
of like if you have reach wearing load I

00:41:27,010 --> 00:41:30,160
normally rely completely on the

00:41:28,869 --> 00:41:31,900
monitoring system because that has

00:41:30,160 --> 00:41:33,760
mostly more accurate information than

00:41:31,900 --> 00:41:35,500
vertex will ever have because in that

00:41:33,760 --> 00:41:35,840
case like the whole working class would

00:41:35,500 --> 00:41:37,610
have to

00:41:35,840 --> 00:41:39,080
aware of how like the load behaves and

00:41:37,610 --> 00:41:42,500
that's something that I'll delegate to

00:41:39,080 --> 00:41:46,910
the monitoring system okay thank you I

00:41:42,500 --> 00:41:48,950
ask one more when I anyway I just need

00:41:46,910 --> 00:41:58,450
to choose carefully

00:41:48,950 --> 00:41:58,450
any more questions over there listen yes

00:42:05,140 --> 00:42:09,170
so the question was like what is like

00:42:07,190 --> 00:42:11,300
the the difference between this and the

00:42:09,170 --> 00:42:14,300
ESP simply isn't that ESP it's a

00:42:11,300 --> 00:42:16,100
messaging buff like an ESP is like it's

00:42:14,300 --> 00:42:17,930
a lot more like with ESP you have ETL

00:42:16,100 --> 00:42:20,450
operations you have the management of

00:42:17,930 --> 00:42:22,580
like authentication authorization of the

00:42:20,450 --> 00:42:24,380
different receivers you can control like

00:42:22,580 --> 00:42:26,270
who act like like that's the lies they

00:42:24,380 --> 00:42:28,220
told us that like you can decide for

00:42:26,270 --> 00:42:30,320
each data item like which data item is

00:42:28,220 --> 00:42:33,410
going to reach which service and so on

00:42:30,320 --> 00:42:34,970
it simply isn't an ESP like this this is

00:42:33,410 --> 00:42:36,560
like we can integrate with a lot of

00:42:34,970 --> 00:42:38,240
different frameworks but if you want to

00:42:36,560 --> 00:42:40,880
go like the ESP way that's like where

00:42:38,240 --> 00:42:43,130
you take mule or camel or alpaca or one

00:42:40,880 --> 00:42:45,590
of those we can connect to these four

00:42:43,130 --> 00:42:47,210
assets really this is a distributed

00:42:45,590 --> 00:42:48,380
system that relies on a distributed

00:42:47,210 --> 00:42:50,240
event bus that's it

00:42:48,380 --> 00:42:52,340
I don't wouldn't I wouldn't call this on

00:42:50,240 --> 00:42:54,410
ESP it's just like the event process the

00:42:52,340 --> 00:42:57,860
way the whole class to communicate with

00:42:54,410 --> 00:42:59,480
each other so I don't see a relation to

00:42:57,860 --> 00:43:01,550
your need to be you could definitely

00:42:59,480 --> 00:43:04,790
build an ESP but I think you can pull

00:43:01,550 --> 00:43:06,530
the newspapers purl so judging for the

00:43:04,790 --> 00:43:10,070
performance of services that most of

00:43:06,530 --> 00:43:15,940
them are probably does this program is

00:43:10,070 --> 00:43:20,030
oh sorry one was array over just yeah

00:43:15,940 --> 00:43:23,390
when you put those access rights to two

00:43:20,030 --> 00:43:28,340
inbound outbound messages where is that

00:43:23,390 --> 00:43:31,040
kit is that also a distributed thing no

00:43:28,340 --> 00:43:32,930
because that's the point where we

00:43:31,040 --> 00:43:34,430
actually create a socket that's

00:43:32,930 --> 00:43:35,900
basically where no not a socket you

00:43:34,430 --> 00:43:37,400
create a handlers that means I could

00:43:35,900 --> 00:43:39,950
delegate down to Nettie and tell Nettie

00:43:37,400 --> 00:43:41,630
for incoming connections be please call

00:43:39,950 --> 00:43:44,600
this handler so each time when you're

00:43:41,630 --> 00:43:46,280
WebSocket connection is brought up we

00:43:44,600 --> 00:43:47,840
will execute like the limits like you

00:43:46,280 --> 00:43:49,560
would pull the limits on this connection

00:43:47,840 --> 00:43:51,870
so this handled on the preneur base

00:43:49,560 --> 00:43:59,370
right so I was welcome to that ethical

00:43:51,870 --> 00:44:01,560
okay yes I'm gonna wear okay so you

00:43:59,370 --> 00:44:03,780
shall justice charging functionality of

00:44:01,560 --> 00:44:05,970
vertex it can't be is it like similar to

00:44:03,780 --> 00:44:09,960
akka and does it have likely shouting

00:44:05,970 --> 00:44:12,120
rebalancing is something I started

00:44:09,960 --> 00:44:13,410
implementing actual actual charting so

00:44:12,120 --> 00:44:14,880
like we don't really have charting right

00:44:13,410 --> 00:44:17,280
now like charting means like I can split

00:44:14,880 --> 00:44:19,680
like on certain addresses and things and

00:44:17,280 --> 00:44:20,940
the event is extremely low-level on that

00:44:19,680 --> 00:44:22,950
it allows you to implement your own

00:44:20,940 --> 00:44:25,320
charting logic which I already did for

00:44:22,950 --> 00:44:27,180
for some other project so this is like

00:44:25,320 --> 00:44:30,230
basically you build it on top of the

00:44:27,180 --> 00:44:33,900
event bus there are other ways of

00:44:30,230 --> 00:44:35,700
managing traffic so like I just gave you

00:44:33,900 --> 00:44:37,260
a short glimpse like you can add headers

00:44:35,700 --> 00:44:38,850
to messages and all that so you have the

00:44:37,260 --> 00:44:40,440
payload and you can have errors which

00:44:38,850 --> 00:44:43,230
can then be used for advanced routing

00:44:40,440 --> 00:44:46,170
interactions that's what I mostly do but

00:44:43,230 --> 00:44:47,250
charting is not built-in so like that's

00:44:46,170 --> 00:44:52,380
something that you will have to come up

00:44:47,250 --> 00:44:54,390
on your own cool thank you yes question

00:44:52,380 --> 00:44:55,920
about to when you show the shell when

00:44:54,390 --> 00:45:00,000
you tell message enter step there's a

00:44:55,920 --> 00:45:03,540
few mail programs for handling local

00:45:00,000 --> 00:45:06,270
Maps or what kind of data stored in the

00:45:03,540 --> 00:45:07,950
local night can repeat this please when

00:45:06,270 --> 00:45:10,830
you show the shell there is commands for

00:45:07,950 --> 00:45:14,070
lo handling local maps yeah what kind of

00:45:10,830 --> 00:45:16,560
stuff is stored and so like the

00:45:14,070 --> 00:45:18,630
reporting is we don't have we don't have

00:45:16,560 --> 00:45:20,580
shared state like we don't allow shared

00:45:18,630 --> 00:45:21,960
state in in vertex so even like if you

00:45:20,580 --> 00:45:23,640
pass a message the message goes through

00:45:21,960 --> 00:45:25,530
a copy operation so you don't have hold

00:45:23,640 --> 00:45:27,300
a reference now there are situation in

00:45:25,530 --> 00:45:29,730
which you kind of want to share some

00:45:27,300 --> 00:45:32,700
information the local maps are like

00:45:29,730 --> 00:45:34,530
there to share immutable instances of

00:45:32,700 --> 00:45:36,180
things in a local way there are also

00:45:34,530 --> 00:45:38,040
distributed maps which are then holed up

00:45:36,180 --> 00:45:39,750
in the cluster manager but like the

00:45:38,040 --> 00:45:41,430
local maps allow you to share certain

00:45:39,750 --> 00:45:44,400
immutable information between the

00:45:41,430 --> 00:45:46,920
verticals so a configuration information

00:45:44,400 --> 00:45:49,110
or like some some other meta information

00:45:46,920 --> 00:45:50,640
that you got can be put in there and can

00:45:49,110 --> 00:45:56,220
be read for other verticals in a thread

00:45:50,640 --> 00:45:57,410
safe way without blocking any more

00:45:56,220 --> 00:45:59,630
questions

00:45:57,410 --> 00:46:01,220
I'm like if they are lucky all that

00:45:59,630 --> 00:46:03,080
people want to talk like I'm around here

00:46:01,220 --> 00:46:05,030
I even got speakers for those who work I

00:46:03,080 --> 00:46:08,990
really excited now about vortex so I

00:46:05,030 --> 00:46:11,120
guess thanks everyone for attending I'm

00:46:08,990 --> 00:46:13,250
looking forward to the party and maybe

00:46:11,120 --> 00:46:15,890
talk with some of you about vortex and

00:46:13,250 --> 00:46:22,670
other reactive issues thank you

00:46:15,890 --> 00:46:22,670

YouTube URL: https://www.youtube.com/watch?v=6D-CS4f68JI


