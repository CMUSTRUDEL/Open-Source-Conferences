Title: Building Safe, More Testable Scala Production Systems at x.ai   by A. Phillips & V. Vijayaraghavan
Publication date: 2017-06-07
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Scala is a very powerful language, with lots of features supporting many different development paradigms. But there’s still quite a way from there to running, real-world production applications that are easy to test and safe to work on for many developers, especially ones that may be new to Scala.

Varun and Andrew will talk about x.ai’s experience of using Scala to build an advanced production system that magically schedules meetings. Specifically, they’ll focus on some of the key coding and architecture lessons that their team learned on the way to safely building a testable application.

Andrew and Varun will introduce a number of important coding and testing patterns, and libraries that the team adopted (and open-sourced ;-)). They’ll also describe the team’s transition to a functional “I/O vs. pure” architecture, discuss how and why this approach has improved application testability at multiple levels, and share tips on how you can evolve your applications’ architecture in a similar way.
Captions: 
	00:00:00,000 --> 00:00:02,639
thanks very very much for coming I hope

00:00:01,439 --> 00:00:04,170
you are obviously enjoying the

00:00:02,639 --> 00:00:06,390
conference had a good keynote yesterday

00:00:04,170 --> 00:00:08,340
enjoying Chicago what we're going to

00:00:06,390 --> 00:00:11,490
talk about today is how we attacks today

00:00:08,340 --> 00:00:14,070
I build safe or safer and more testable

00:00:11,490 --> 00:00:16,020
scholar production systems in a pretty

00:00:14,070 --> 00:00:17,850
interesting environment so yeah hello

00:00:16,020 --> 00:00:20,160
for me I'm Andrew it's rule my colleague

00:00:17,850 --> 00:00:22,020
don't forget the voting thing obviously

00:00:20,160 --> 00:00:23,449
that's a mandatory there's only one

00:00:22,020 --> 00:00:26,699
button on the boat so great

00:00:23,449 --> 00:00:28,519
that's that our version so the short one

00:00:26,699 --> 00:00:31,260
like I'm the head of duck tape I mean

00:00:28,519 --> 00:00:32,850
basically I do infrastructure stuff and

00:00:31,260 --> 00:00:34,860
stuff throughout the stack because we're

00:00:32,850 --> 00:00:36,360
a small team relatively and there's

00:00:34,860 --> 00:00:38,460
always more problems than there are

00:00:36,360 --> 00:00:40,050
people to throw at them so that's kind

00:00:38,460 --> 00:00:42,719
of my role and Varun is our back-end

00:00:40,050 --> 00:00:43,530
wizard hey I'm back in guys so I didn't

00:00:42,719 --> 00:00:45,059
need to come and talk to me about

00:00:43,530 --> 00:00:46,680
servers I start getting excited and I

00:00:45,059 --> 00:00:48,960
talk a lot so that's what I do a

00:00:46,680 --> 00:00:50,700
textured AI I do sort of scale up like

00:00:48,960 --> 00:00:53,399
that--no GS and stuff so the toilet a

00:00:50,700 --> 00:00:55,800
quick note about what we do actually so

00:00:53,399 --> 00:00:57,750
what we are at X Rai we are building

00:00:55,800 --> 00:00:59,820
artificial intelligence assistant which

00:00:57,750 --> 00:01:01,050
does one thing and just one thing which

00:00:59,820 --> 00:01:03,000
is to schedule meetings for you

00:01:01,050 --> 00:01:04,530
magically and we are very focused on

00:01:03,000 --> 00:01:06,570
this idea that we want to do only that

00:01:04,530 --> 00:01:08,729
so any feature that we build any bug fix

00:01:06,570 --> 00:01:10,950
that we do is all towards the idea of

00:01:08,729 --> 00:01:13,350
scheduling meetings so how it works is

00:01:10,950 --> 00:01:15,150
you simply send an email saying hey can

00:01:13,350 --> 00:01:17,460
you schedule a meeting for between me

00:01:15,150 --> 00:01:18,600
and Andrew and Amy takes care of the

00:01:17,460 --> 00:01:20,400
rest of the ping-pong she understands

00:01:18,600 --> 00:01:21,780
the email she sends out an email to

00:01:20,400 --> 00:01:23,159
Andrew and figures out what time works

00:01:21,780 --> 00:01:24,689
for them and understand sir and this

00:01:23,159 --> 00:01:27,240
reply and then finally sends out an

00:01:24,689 --> 00:01:29,549
invite so that's what we do we have been

00:01:27,240 --> 00:01:31,890
doing this for about three years or so

00:01:29,549 --> 00:01:33,479
and one thing you've learnt is that it's

00:01:31,890 --> 00:01:34,619
very very very challenging it's more

00:01:33,479 --> 00:01:38,869
challenging than we thought it would be

00:01:34,619 --> 00:01:41,369
initially and yeah so there are a lot of

00:01:38,869 --> 00:01:43,560
interesting properties of our team

00:01:41,369 --> 00:01:47,070
actually so for example we have a lot of

00:01:43,560 --> 00:01:48,360
diverse systems you can take so some

00:01:47,070 --> 00:01:49,920
other systems are machine learning some

00:01:48,360 --> 00:01:51,869
of the systems are deterministic and

00:01:49,920 --> 00:01:54,329
very complex deterministic logic and

00:01:51,869 --> 00:01:55,740
within a team we have a diverse set of

00:01:54,329 --> 00:01:57,240
skill set so some people have Scala

00:01:55,740 --> 00:01:57,840
wizards other people are extremely good

00:01:57,240 --> 00:01:59,820
at nodejs

00:01:57,840 --> 00:02:01,590
some people are extremely good at

00:01:59,820 --> 00:02:03,750
testing others in deep learning and

00:02:01,590 --> 00:02:06,390
machine learning and so on and finally

00:02:03,750 --> 00:02:08,580
like the diverse experience levels where

00:02:06,390 --> 00:02:10,459
we have people with like 14 years of

00:02:08,580 --> 00:02:13,440
experience and we have some people with

00:02:10,459 --> 00:02:13,870
just code just out of college so one of

00:02:13,440 --> 00:02:16,629
the things

00:02:13,870 --> 00:02:18,150
is that so given that there is a diverse

00:02:16,629 --> 00:02:21,400
level of experience we do want to

00:02:18,150 --> 00:02:22,810
implement the minimum set of or just

00:02:21,400 --> 00:02:24,010
propose the minimum set of things that

00:02:22,810 --> 00:02:26,379
you want to do like the safety nets that

00:02:24,010 --> 00:02:28,810
you want to introduce into the into our

00:02:26,379 --> 00:02:31,450
systems you know specifically a Scala

00:02:28,810 --> 00:02:33,549
systems so that we can get a the basic

00:02:31,450 --> 00:02:36,280
amount of safety for very little cost

00:02:33,549 --> 00:02:37,989
yeah I think that I was joking earlier

00:02:36,280 --> 00:02:39,489
about the meeting scheduling and and

00:02:37,989 --> 00:02:41,769
well about sorry about the video

00:02:39,489 --> 00:02:43,000
conferencing and the and the projectors

00:02:41,769 --> 00:02:44,440
meeting scheduling is the third thing

00:02:43,000 --> 00:02:46,720
that we're still not going to get

00:02:44,440 --> 00:02:49,239
totally right by by the year 3000 but

00:02:46,720 --> 00:02:50,769
we're trying and what I think is

00:02:49,239 --> 00:02:53,290
important about our environment is it's

00:02:50,769 --> 00:02:55,060
quite representative of a lot of people

00:02:53,290 --> 00:02:56,590
I've spoken to in what they're doing

00:02:55,060 --> 00:02:58,810
whether you're trying to onboard new

00:02:56,590 --> 00:03:00,730
teams whether those teams come from

00:02:58,810 --> 00:03:02,739
different language paradigms or now you

00:03:00,730 --> 00:03:03,849
know in our situation we have a bunch of

00:03:02,739 --> 00:03:06,970
people you know have a heavily

00:03:03,849 --> 00:03:08,319
functional influence very very advanced

00:03:06,970 --> 00:03:10,239
if you like from a sort of computer

00:03:08,319 --> 00:03:13,060
science perspective but a lot of people

00:03:10,239 --> 00:03:16,420
who know Scala essentially is a DSL into

00:03:13,060 --> 00:03:18,180
SPARC and Scala as a language that is

00:03:16,420 --> 00:03:20,799
very flexible and not very opinionated

00:03:18,180 --> 00:03:22,450
had this enormous space of possible

00:03:20,799 --> 00:03:24,400
things you can do with it and so I think

00:03:22,450 --> 00:03:26,260
this is a challenge for this language

00:03:24,400 --> 00:03:28,329
that is maybe more prevalent than in

00:03:26,260 --> 00:03:29,940
other environments that you really have

00:03:28,329 --> 00:03:32,079
to figure out how to take this enormous

00:03:29,940 --> 00:03:33,579
spectrum of possibilities and kind of

00:03:32,079 --> 00:03:35,109
boil it down that's the kind of thing I

00:03:33,579 --> 00:03:36,250
was taking too long to say all right so

00:03:35,109 --> 00:03:39,099
the agenda what are we going to talk

00:03:36,250 --> 00:03:42,780
about what we've done in terms of coding

00:03:39,099 --> 00:03:46,239
patterns and guidelines and then tools

00:03:42,780 --> 00:03:48,010
architecture and to try to achieve this

00:03:46,239 --> 00:03:49,810
goal of having a system where as many

00:03:48,010 --> 00:03:52,060
people as possible in our limited team

00:03:49,810 --> 00:03:54,130
can work on all parts of our code base

00:03:52,060 --> 00:03:55,959
and do so safely without blowing things

00:03:54,130 --> 00:03:57,940
up and waking us all up at 3:00 in the

00:03:55,959 --> 00:03:59,500
morning because we all get the pager and

00:03:57,940 --> 00:04:02,169
then if we manage to get through this in

00:03:59,500 --> 00:04:04,329
time we'll have a little bit of a Q&A so

00:04:02,169 --> 00:04:05,410
coding patterns there's no let's just go

00:04:04,329 --> 00:04:07,599
on to the next slide what do we got

00:04:05,410 --> 00:04:09,430
there's the three main things I want to

00:04:07,599 --> 00:04:10,630
touch on with a big credit to Chris

00:04:09,430 --> 00:04:12,130
who's sitting back in the room because

00:04:10,630 --> 00:04:15,280
he was responsible for a lot of this

00:04:12,130 --> 00:04:17,650
stuff this is not going to be rocket

00:04:15,280 --> 00:04:19,329
science I think one of the main TL DR is

00:04:17,650 --> 00:04:21,659
from me and we'll come back and touch on

00:04:19,329 --> 00:04:23,800
that a little bit later is that the

00:04:21,659 --> 00:04:25,780
these are parts of the language that you

00:04:23,800 --> 00:04:26,910
will use all the time like relatively

00:04:25,780 --> 00:04:29,250
simple things I call

00:04:26,910 --> 00:04:32,040
ludie and so on string operations you

00:04:29,250 --> 00:04:33,360
might think yeah but why would we invest

00:04:32,040 --> 00:04:34,890
in trying to make those safer I think

00:04:33,360 --> 00:04:39,360
the key lesson is because you do them

00:04:34,890 --> 00:04:41,280
all the time right and almost every

00:04:39,360 --> 00:04:43,590
piece of code you write will do checking

00:04:41,280 --> 00:04:46,440
is a equals B somewhere in some shape or

00:04:43,590 --> 00:04:48,810
form and yes the language has operations

00:04:46,440 --> 00:04:50,100
for that but if they're not as ideal as

00:04:48,810 --> 00:04:53,370
you need them to be in your situation

00:04:50,100 --> 00:04:56,010
don't be afraid to specifically tune

00:04:53,370 --> 00:04:58,410
even those parts of the language because

00:04:56,010 --> 00:05:00,810
yes they're very common in the language

00:04:58,410 --> 00:05:02,100
they they seem very basic but if they

00:05:00,810 --> 00:05:03,900
happen everywhere that's where you will

00:05:02,100 --> 00:05:05,820
get a lot of mistakes so I think that's

00:05:03,900 --> 00:05:07,920
if you the sort of meta level lesson is

00:05:05,820 --> 00:05:08,850
that don't just look at the weird funky

00:05:07,920 --> 00:05:10,670
parts where you have to do something

00:05:08,850 --> 00:05:12,750
very specific for your business problem

00:05:10,670 --> 00:05:14,190
look at parts of your code base that you

00:05:12,750 --> 00:05:16,830
use a lot and figure out how you can

00:05:14,190 --> 00:05:20,100
make those better and easier to use for

00:05:16,830 --> 00:05:22,410
your team okay so the first one is a

00:05:20,100 --> 00:05:23,760
kind of obvious one that we all know

00:05:22,410 --> 00:05:25,470
about it's a sort of Apple equals

00:05:23,760 --> 00:05:28,530
oranges problem right you can write this

00:05:25,470 --> 00:05:30,060
in Scala and well you'll get false back

00:05:28,530 --> 00:05:30,930
and if you're comparing fruits that's

00:05:30,060 --> 00:05:32,790
fine so it's sort of more

00:05:30,930 --> 00:05:35,700
domain-specific version of our problem

00:05:32,790 --> 00:05:37,230
we deal in meetings so what are the kind

00:05:35,700 --> 00:05:38,940
of things that exist in our domain you

00:05:37,230 --> 00:05:41,090
have emails you have people you have

00:05:38,940 --> 00:05:43,740
meetings you have locations and so on

00:05:41,090 --> 00:05:45,570
and you get lots of code that looks a

00:05:43,740 --> 00:05:47,640
little bit like this very simple stuff

00:05:45,570 --> 00:05:50,460
nothing fancy here and you can write

00:05:47,640 --> 00:05:52,680
this and it returns false and probably

00:05:50,460 --> 00:05:56,070
when you wrote it you didn't expect it

00:05:52,680 --> 00:05:58,110
to return false and the reason is well

00:05:56,070 --> 00:06:00,330
it's not actually what you were trying

00:05:58,110 --> 00:06:01,620
to write but it's possible to write it

00:06:00,330 --> 00:06:03,210
and that's exactly where the problem

00:06:01,620 --> 00:06:05,040
comes from this is the problem it's not

00:06:03,210 --> 00:06:07,260
meant to be puzzling like I see heads

00:06:05,040 --> 00:06:10,770
nodding nothing really special about

00:06:07,260 --> 00:06:11,910
this but clearly and you know why is

00:06:10,770 --> 00:06:13,530
this even possible

00:06:11,910 --> 00:06:14,820
like why does this work why does the

00:06:13,530 --> 00:06:16,470
language allow you to do this well

00:06:14,820 --> 00:06:18,020
because in a sort of general sense this

00:06:16,470 --> 00:06:20,430
is not types of in a general sense

00:06:18,020 --> 00:06:22,860
you're supposed to be able to compare

00:06:20,430 --> 00:06:25,350
anything with anything else it's a it

00:06:22,860 --> 00:06:26,760
type system based on inheritance if you

00:06:25,350 --> 00:06:28,560
were if you were marching back in the

00:06:26,760 --> 00:06:31,050
day or anyone else if you were to design

00:06:28,560 --> 00:06:33,900
an equality operator for a language that

00:06:31,050 --> 00:06:36,330
has over aidable equality definitions of

00:06:33,900 --> 00:06:38,280
course you have to define the built in

00:06:36,330 --> 00:06:39,500
equals operator like this because you

00:06:38,280 --> 00:06:41,480
don't know

00:06:39,500 --> 00:06:44,330
a priori what's going to be equal but in

00:06:41,480 --> 00:06:45,830
a domain-specific context you know much

00:06:44,330 --> 00:06:47,270
more about what things you really want

00:06:45,830 --> 00:06:48,680
to compare or you you should be

00:06:47,270 --> 00:06:51,590
comparing with each other so what you

00:06:48,680 --> 00:06:53,720
would really like is you would like a

00:06:51,590 --> 00:06:56,450
statement such as andrew equals equals

00:06:53,720 --> 00:06:58,190
guest-star find and not to compile

00:06:56,450 --> 00:06:59,840
because you're trying to do something

00:06:58,190 --> 00:07:03,290
that is really not what you intended to

00:06:59,840 --> 00:07:04,970
do this is not a mam not making some

00:07:03,290 --> 00:07:06,320
kind of revolutionary claim here this is

00:07:04,970 --> 00:07:08,870
something that a lot of languages

00:07:06,320 --> 00:07:10,220
already have and support natively out of

00:07:08,870 --> 00:07:12,080
the box and even Scala has a few

00:07:10,220 --> 00:07:14,570
variants of this but the solution we

00:07:12,080 --> 00:07:16,730
came up with for this is now I'm making

00:07:14,570 --> 00:07:17,990
you up operator triple equals scholars

00:07:16,730 --> 00:07:20,419
that one of the things it's very nice

00:07:17,990 --> 00:07:23,570
about it it makes it very easy to define

00:07:20,419 --> 00:07:25,430
new syntax that looks natural like Java

00:07:23,570 --> 00:07:27,620
where you end up with these weird dot

00:07:25,430 --> 00:07:29,450
equals my equal something like that

00:07:27,620 --> 00:07:31,190
patterns but you can really quite easily

00:07:29,450 --> 00:07:32,810
make these new operators in the language

00:07:31,190 --> 00:07:35,090
and so here you'll get what I think you

00:07:32,810 --> 00:07:37,100
want or at least what we want in this

00:07:35,090 --> 00:07:38,840
particular case that you actually the

00:07:37,100 --> 00:07:41,419
compiler tells you you're probably not

00:07:38,840 --> 00:07:43,100
doing what you wanted to do and how we

00:07:41,419 --> 00:07:45,200
did this over one one way you can do

00:07:43,100 --> 00:07:48,650
this if you're if you're opening up the

00:07:45,200 --> 00:07:50,330
Pandora's box at this gala Z you can do

00:07:48,650 --> 00:07:51,470
this already you can use type classes

00:07:50,330 --> 00:07:53,240
there's a type class based approach to

00:07:51,470 --> 00:07:55,820
define equality like this that'll give

00:07:53,240 --> 00:07:57,290
you a triple equals and Chris can tell

00:07:55,820 --> 00:07:59,180
you I think more about exactly why we

00:07:57,290 --> 00:08:00,620
didn't do this all over the place but

00:07:59,180 --> 00:08:02,390
this is typesafe but it requires some

00:08:00,620 --> 00:08:03,950
boilerplate in general like few

00:08:02,390 --> 00:08:05,330
shapeless some of that boilerplate goes

00:08:03,950 --> 00:08:07,700
away but you have to write this stuff

00:08:05,330 --> 00:08:09,260
you have to sort of be more explicit

00:08:07,700 --> 00:08:11,240
about which things you want to be equal

00:08:09,260 --> 00:08:12,860
in our case we're quite happy with the

00:08:11,240 --> 00:08:15,200
basic equals we just want to have some

00:08:12,860 --> 00:08:17,120
more type safety around it so one thing

00:08:15,200 --> 00:08:18,680
you can do nothing nothing too fancy

00:08:17,120 --> 00:08:22,280
nothing complicated usually clear

00:08:18,680 --> 00:08:23,660
something safe equals and then you wrap

00:08:22,280 --> 00:08:25,040
it in any values and stuff like that or

00:08:23,660 --> 00:08:26,330
if necessary to me to make it so

00:08:25,040 --> 00:08:28,520
performance we'll talk about that a bit

00:08:26,330 --> 00:08:29,960
later but you just define this operator

00:08:28,520 --> 00:08:31,729
on there and that's where you link the

00:08:29,960 --> 00:08:34,940
type so you have the type T at the top

00:08:31,729 --> 00:08:36,469
and then the type T in the definition of

00:08:34,940 --> 00:08:39,260
the right-hand side argument and that is

00:08:36,469 --> 00:08:41,900
what means that when you try to write

00:08:39,260 --> 00:08:45,080
andrew equals equals equals blah blah

00:08:41,900 --> 00:08:47,930
blah that you'll get this type error so

00:08:45,080 --> 00:08:49,550
it's not totally foolproof in the sense

00:08:47,930 --> 00:08:50,670
that you can still do this right I mean

00:08:49,550 --> 00:08:54,600
you can

00:08:50,670 --> 00:08:57,030
force the type T to be any and then you

00:08:54,600 --> 00:08:58,440
still get the the basic ability to

00:08:57,030 --> 00:09:01,890
compare any two types with each other

00:08:58,440 --> 00:09:03,180
but this looks smelling like and I think

00:09:01,890 --> 00:09:04,860
that's probably the best that you can

00:09:03,180 --> 00:09:06,180
hope for like if you see if it's a line

00:09:04,860 --> 00:09:08,370
in your code that looks a little bit

00:09:06,180 --> 00:09:10,890
like the bottom line we're not making it

00:09:08,370 --> 00:09:12,630
impossible but you're it's much clearer

00:09:10,890 --> 00:09:14,280
from looking at this line of code that

00:09:12,630 --> 00:09:17,190
this is probably not what you want to be

00:09:14,280 --> 00:09:18,900
doing and as I said going back to how a

00:09:17,190 --> 00:09:21,180
common equality is this is a really big

00:09:18,900 --> 00:09:22,740
game you know its inference safe I guess

00:09:21,180 --> 00:09:24,240
if you would put it that way it's not

00:09:22,740 --> 00:09:26,430
necessarily fully typesafe because you

00:09:24,240 --> 00:09:27,630
can still do stuff similar problem I'm

00:09:26,430 --> 00:09:29,130
going to go through this one a little

00:09:27,630 --> 00:09:30,570
bit quicker because I can see I'm kind

00:09:29,130 --> 00:09:33,060
of getting a little late on the time

00:09:30,570 --> 00:09:33,810
containment equality something you do

00:09:33,060 --> 00:09:35,550
all the time

00:09:33,810 --> 00:09:37,880
containment also something you do all

00:09:35,550 --> 00:09:41,370
the time you get something like this

00:09:37,880 --> 00:09:43,650
make a list of guests and you try to

00:09:41,370 --> 00:09:46,620
check whether the ID of a particular

00:09:43,650 --> 00:09:49,230
user is in there and yeah it not in

00:09:46,620 --> 00:09:51,450
there but here you're fundamentally

00:09:49,230 --> 00:09:52,950
expressing there's not really what you

00:09:51,450 --> 00:09:54,150
were trying to check for you know when

00:09:52,950 --> 00:09:57,590
you were writing this you probably

00:09:54,150 --> 00:09:59,940
thought that this was going to work

00:09:57,590 --> 00:10:01,620
there's just some confusion about what

00:09:59,940 --> 00:10:04,470
the type of the list actually is what

00:10:01,620 --> 00:10:07,230
kind of elements are in the list and

00:10:04,470 --> 00:10:09,180
again if you're in a domain-specific

00:10:07,230 --> 00:10:10,830
world like we are we're a guest and a

00:10:09,180 --> 00:10:12,540
guest ID obviously are not the same

00:10:10,830 --> 00:10:15,150
things then you don't want this to

00:10:12,540 --> 00:10:16,830
compile like you want to be told you

00:10:15,150 --> 00:10:18,840
know why are you trying to check for a

00:10:16,830 --> 00:10:22,530
guest ID in a list that doesn't contain

00:10:18,840 --> 00:10:23,820
guest IDs and as I said in our case when

00:10:22,530 --> 00:10:25,200
you have people working on your code who

00:10:23,820 --> 00:10:26,370
it's not like they've written all that

00:10:25,200 --> 00:10:28,860
code they're coming at a particular

00:10:26,370 --> 00:10:30,240
method to fix a particular problem and

00:10:28,860 --> 00:10:31,890
they may not have seen that method very

00:10:30,240 --> 00:10:34,050
much then then this is the kind of thing

00:10:31,890 --> 00:10:35,730
you want them not to be able to write so

00:10:34,050 --> 00:10:37,590
and I just want to add another noted

00:10:35,730 --> 00:10:39,600
there so this is not like a theoretical

00:10:37,590 --> 00:10:41,970
problem this was a real problem that

00:10:39,600 --> 00:10:43,980
he's faced and like one or two years one

00:10:41,970 --> 00:10:45,780
and a half years ago we had this thing

00:10:43,980 --> 00:10:47,490
and they've actually compiled it got

00:10:45,780 --> 00:10:49,500
shipped to production and we just

00:10:47,490 --> 00:10:51,060
started spamming people's emails of

00:10:49,500 --> 00:10:53,070
emails after emails like we spanned like

00:10:51,060 --> 00:10:54,990
300 emails in the span of one hours and

00:10:53,070 --> 00:10:56,130
something really crazy and when

00:10:54,990 --> 00:10:57,960
visualize and only when somebody

00:10:56,130 --> 00:10:59,700
complained to us and said why are you

00:10:57,960 --> 00:11:01,440
selling me so many emails and that's

00:10:59,700 --> 00:11:03,110
when we decided okay fine we need to do

00:11:01,440 --> 00:11:04,760
make it safer

00:11:03,110 --> 00:11:06,590
yes in general none of this is

00:11:04,760 --> 00:11:09,920
theoretical right this is all stuff that

00:11:06,590 --> 00:11:11,450
it's all like the result of wounds if

00:11:09,920 --> 00:11:13,280
you like put it that way and so the

00:11:11,450 --> 00:11:15,320
whole purpose of this talk is like how

00:11:13,280 --> 00:11:16,490
to avoid you having to suffer through

00:11:15,320 --> 00:11:19,730
the same kind of thing so why does this

00:11:16,490 --> 00:11:22,520
work well because you have a covariance

00:11:19,730 --> 00:11:25,280
earlier in this case and you know a

00:11:22,520 --> 00:11:26,690
sequence of tiger is also a sequence of

00:11:25,280 --> 00:11:28,610
animal you want to be able to do that

00:11:26,690 --> 00:11:30,620
make sense as a design decision in a

00:11:28,610 --> 00:11:33,100
language that allows inheritance of

00:11:30,620 --> 00:11:37,340
types but what it also means is that

00:11:33,100 --> 00:11:42,170
since you can assign a list of guests to

00:11:37,340 --> 00:11:44,470
a list of any I can write valve g2 list

00:11:42,170 --> 00:11:47,390
of any equals that list of guests

00:11:44,470 --> 00:11:50,210
contains also has to be able to accept

00:11:47,390 --> 00:11:52,340
any particular type of arguments because

00:11:50,210 --> 00:11:54,140
I can treat it as a list of any so again

00:11:52,340 --> 00:11:56,150
makes total sense from the basic design

00:11:54,140 --> 00:11:59,150
decision there's no other way to do this

00:11:56,150 --> 00:12:01,370
if you want to support kind of

00:11:59,150 --> 00:12:03,770
inheritance of inheritance hierarchies

00:12:01,370 --> 00:12:06,200
of compound structures like lists but

00:12:03,770 --> 00:12:08,090
not what we want in our particular case

00:12:06,200 --> 00:12:09,770
what we really want is to be the

00:12:08,090 --> 00:12:11,930
composite saying ah you know you're

00:12:09,770 --> 00:12:13,250
trying to look for a guest ID in a list

00:12:11,930 --> 00:12:15,500
of guests that totally know what you

00:12:13,250 --> 00:12:18,050
want to do this doesn't compile and so

00:12:15,500 --> 00:12:19,940
enter safe contains similar kinds of

00:12:18,050 --> 00:12:22,100
implementation it does what you expect

00:12:19,940 --> 00:12:25,010
has the same kind of caveat in the sense

00:12:22,100 --> 00:12:26,690
that you can still force it to do the

00:12:25,010 --> 00:12:30,230
kind of weird type comparison but again

00:12:26,690 --> 00:12:31,820
it looks weird and I think that's that's

00:12:30,230 --> 00:12:33,080
something that this was the best we can

00:12:31,820 --> 00:12:35,090
hope for I mean looks weird is a big

00:12:33,080 --> 00:12:36,530
statement you can make it more precise

00:12:35,090 --> 00:12:38,240
by having linting rules that prevent

00:12:36,530 --> 00:12:41,810
this kind of stuff or at least flag it

00:12:38,240 --> 00:12:44,840
right so you get what you want here okay

00:12:41,810 --> 00:12:47,150
moving on and say primitives like how

00:12:44,840 --> 00:12:49,520
would you in for time a little more time

00:12:47,150 --> 00:12:51,290
so another one so this touches a little

00:12:49,520 --> 00:12:52,100
bit fortuitously on what martin was

00:12:51,290 --> 00:12:54,890
talking about yesterday

00:12:52,100 --> 00:12:57,890
in terms of implicit and the danger of

00:12:54,890 --> 00:13:00,920
adding implicit to base types base types

00:12:57,890 --> 00:13:03,470
are risky right if you if everything is

00:13:00,920 --> 00:13:05,120
a string then you know strings can

00:13:03,470 --> 00:13:07,250
magically turn into other things strings

00:13:05,120 --> 00:13:09,020
can be added to each other and if your

00:13:07,250 --> 00:13:11,630
email ID is a string and your guests ID

00:13:09,020 --> 00:13:13,850
is a string then you can look for email

00:13:11,630 --> 00:13:16,990
ids in a list of guests and so on or

00:13:13,850 --> 00:13:18,820
guest IDs and so on long story short

00:13:16,990 --> 00:13:22,240
one of the lessons we've learned don't

00:13:18,820 --> 00:13:23,320
do that even if the thing is underlying

00:13:22,240 --> 00:13:25,029
you know you're not actually trying to

00:13:23,320 --> 00:13:26,620
restrict the string type you're not like

00:13:25,029 --> 00:13:27,880
trying to have pause int or something

00:13:26,620 --> 00:13:28,899
like that I think bill will have a talk

00:13:27,880 --> 00:13:31,149
that will touch on some of that stuff

00:13:28,899 --> 00:13:33,490
even if it's really you want the whole

00:13:31,149 --> 00:13:37,779
space of a string don't just use a type

00:13:33,490 --> 00:13:39,580
alias actually wrap it in a type because

00:13:37,779 --> 00:13:42,010
then you can get some kind of

00:13:39,580 --> 00:13:45,160
interesting properties of safety safety

00:13:42,010 --> 00:13:47,860
type safety you can't write guests find

00:13:45,160 --> 00:13:50,980
buy ID of an email ID you can't do the

00:13:47,860 --> 00:13:52,450
second kind of thing and you can do it

00:13:50,980 --> 00:13:53,920
in a way that actually isn't very

00:13:52,450 --> 00:13:55,240
impactful on performance and there's a

00:13:53,920 --> 00:13:57,190
few things that we'll talk about a

00:13:55,240 --> 00:13:59,140
little bit later that you should add to

00:13:57,190 --> 00:14:02,380
make this easier so when to use type

00:13:59,140 --> 00:14:04,750
wrappers you know when you the possible

00:14:02,380 --> 00:14:07,660
values it's not an enum like there's too

00:14:04,750 --> 00:14:10,120
many to usefully use in an enum or

00:14:07,660 --> 00:14:12,310
there's too many or it's really a

00:14:10,120 --> 00:14:15,190
genuinely infinite unknowable set and

00:14:12,310 --> 00:14:17,320
also when you want to make sure that you

00:14:15,190 --> 00:14:19,149
use this new type information to prevent

00:14:17,320 --> 00:14:21,010
things like comparisons from happening

00:14:19,149 --> 00:14:23,110
like two strings can always be compared

00:14:21,010 --> 00:14:25,420
difficult to tell them apart a guest ID

00:14:23,110 --> 00:14:28,300
and the email ID gets the compiler to

00:14:25,420 --> 00:14:30,580
help you prevent mixing those up and

00:14:28,300 --> 00:14:33,880
then maybe a bullet point that I guess I

00:14:30,580 --> 00:14:35,860
could have added this also makes the

00:14:33,880 --> 00:14:37,959
scope or applicability of any implicit

00:14:35,860 --> 00:14:40,000
that you define much more narrow because

00:14:37,959 --> 00:14:41,770
suddenly when you convert like I don't

00:14:40,000 --> 00:14:44,920
know if you if you were to convert a

00:14:41,770 --> 00:14:47,770
guest ID to an email whatever as an

00:14:44,920 --> 00:14:50,560
implicit if that's string to email as a

00:14:47,770 --> 00:14:53,650
type much much much bigger problem than

00:14:50,560 --> 00:14:56,020
if it's guest ID to email so this this

00:14:53,650 --> 00:14:57,760
magically helps you avoid the danger of

00:14:56,020 --> 00:15:01,180
having very broadly applicable implicit

00:14:57,760 --> 00:15:02,200
as well so I think I'll skip this safe

00:15:01,180 --> 00:15:03,700
matching on sealed structures

00:15:02,200 --> 00:15:06,279
interesting come talk to me later but

00:15:03,700 --> 00:15:08,410
stay another one very very common this

00:15:06,279 --> 00:15:11,440
is the kind of yeah we work with emails

00:15:08,410 --> 00:15:13,060
like it's all text right so at some

00:15:11,440 --> 00:15:14,740
point or another we have to do this kind

00:15:13,060 --> 00:15:15,700
of stuff and yes this is the kind of

00:15:14,740 --> 00:15:16,870
stuff that happens the ruin would you

00:15:15,700 --> 00:15:18,700
have a nice anecdote I don't know where

00:15:16,870 --> 00:15:20,709
that is exactly what happened where we

00:15:18,700 --> 00:15:22,810
send out hey - with Andrew there was

00:15:20,709 --> 00:15:25,839
actually one case where we sent hi none

00:15:22,810 --> 00:15:27,610
how are you doing so as about as I say

00:15:25,839 --> 00:15:29,200
that's when you feel really bad like if

00:15:27,610 --> 00:15:30,330
you're at your some of me that's okay

00:15:29,200 --> 00:15:33,780
but it's you're none

00:15:30,330 --> 00:15:35,640
yeah does not feel does not feel very

00:15:33,780 --> 00:15:40,500
good right so what's the problem

00:15:35,640 --> 00:15:41,850
the problem again is that because well

00:15:40,500 --> 00:15:43,590
the problem is that you can write this

00:15:41,850 --> 00:15:45,360
kind of stuff but if you put option

00:15:43,590 --> 00:15:47,520
string in there as opposed to a string

00:15:45,360 --> 00:15:48,870
you don't get any hint that you're doing

00:15:47,520 --> 00:15:50,700
something you don't want to do because

00:15:48,870 --> 00:15:53,400
you know anything can be treated as a

00:15:50,700 --> 00:15:55,650
string and s allows any arguments like

00:15:53,400 --> 00:15:57,630
string context or something maybe is not

00:15:55,650 --> 00:15:59,280
quite a well-known fact s is the most

00:15:57,630 --> 00:16:01,980
common string context but there are

00:15:59,280 --> 00:16:05,190
actually others even native ones raw for

00:16:01,980 --> 00:16:07,290
instance and they're actually very easy

00:16:05,190 --> 00:16:08,520
to define yourself so you can do some

00:16:07,290 --> 00:16:09,930
pretty interesting things with

00:16:08,520 --> 00:16:11,910
additional string context it's not too

00:16:09,930 --> 00:16:13,320
complicated but the problem is that the

00:16:11,910 --> 00:16:14,970
basic one that we like using all the

00:16:13,320 --> 00:16:18,660
time just accepts anything because you

00:16:14,970 --> 00:16:19,890
can turn anything into a string what we

00:16:18,660 --> 00:16:22,560
want is something different so we

00:16:19,890 --> 00:16:24,720
created our own called safe and you can

00:16:22,560 --> 00:16:26,390
choose whatever you want and he will

00:16:24,720 --> 00:16:29,400
give you this kind of compilation error

00:16:26,390 --> 00:16:32,310
and the way to do that obviously is you

00:16:29,400 --> 00:16:34,590
instead of saying I will accept anything

00:16:32,310 --> 00:16:38,190
and then call to string on it I will

00:16:34,590 --> 00:16:42,360
accept a more limited set of types that

00:16:38,190 --> 00:16:45,060
I consider safe to turn into a string so

00:16:42,360 --> 00:16:47,940
you know you do something like this and

00:16:45,060 --> 00:16:49,590
then you expect strings here and if

00:16:47,940 --> 00:16:50,820
they're not already string then you have

00:16:49,590 --> 00:16:52,110
to figure out how you can turn them into

00:16:50,820 --> 00:16:54,840
strings there's a similar problem with

00:16:52,110 --> 00:16:56,250
plus you can look at the code by the way

00:16:54,840 --> 00:16:58,500
for the implementation details it's not

00:16:56,250 --> 00:17:00,000
secret there's a similar problem with

00:16:58,500 --> 00:17:02,400
plus obviously you can do this kind of

00:17:00,000 --> 00:17:04,650
stuff there's a very funky version of

00:17:02,400 --> 00:17:07,620
this like you can try I skip one slide

00:17:04,650 --> 00:17:10,440
here you can try plus plus as in set or

00:17:07,620 --> 00:17:12,060
rather seek kind of concatenation that

00:17:10,440 --> 00:17:14,370
works for some cases but still is

00:17:12,060 --> 00:17:16,500
interestingly quirky long story short

00:17:14,370 --> 00:17:19,140
there's an easy way to make this safe as

00:17:16,500 --> 00:17:21,960
well so you start to get you write this

00:17:19,140 --> 00:17:23,820
kind of stuff and you get an error

00:17:21,960 --> 00:17:25,710
because it's not one of the ones that

00:17:23,820 --> 00:17:28,740
you've defined as being safe to

00:17:25,710 --> 00:17:30,630
concatenate together and there you go

00:17:28,740 --> 00:17:33,390
safety for that kind of stuff all right

00:17:30,630 --> 00:17:36,000
let me just check yes so all this

00:17:33,390 --> 00:17:39,840
wonderful code is in a highly versioned

00:17:36,000 --> 00:17:42,960
library that's out there on the web go

00:17:39,840 --> 00:17:44,160
check it out it's you know take some of

00:17:42,960 --> 00:17:46,880
the implementation take the live

00:17:44,160 --> 00:17:49,890
we contribute to it suggest new things

00:17:46,880 --> 00:17:51,420
very useful stuff helps us a lot over

00:17:49,890 --> 00:17:54,990
the verbals thanks Andrew

00:17:51,420 --> 00:17:57,060
so how do we deploy safely so on a high

00:17:54,990 --> 00:17:59,070
level this is what our architecture

00:17:57,060 --> 00:18:00,870
looks like we are basically an email in

00:17:59,070 --> 00:18:02,910
an email out system we take an emails

00:18:00,870 --> 00:18:04,110
and we have a portion of the system

00:18:02,910 --> 00:18:06,120
which does all the machine learning

00:18:04,110 --> 00:18:07,260
tries to understand what are the times

00:18:06,120 --> 00:18:09,300
or the locations

00:18:07,260 --> 00:18:10,410
what is the intense present that meeting

00:18:09,300 --> 00:18:12,210
this is we are also machine learning the

00:18:10,410 --> 00:18:13,800
deep learning stuff happens and then

00:18:12,210 --> 00:18:15,450
once we figure out the deep learning and

00:18:13,800 --> 00:18:17,010
the machine learning stuff in extracted

00:18:15,450 --> 00:18:19,080
times locations and intense

00:18:17,010 --> 00:18:20,910
we then pass it to the decision making

00:18:19,080 --> 00:18:22,560
system which basically still goes out

00:18:20,910 --> 00:18:24,720
okay fine now that I know what has been

00:18:22,560 --> 00:18:26,280
said what should what should we send

00:18:24,720 --> 00:18:28,170
what time should be proposed to this

00:18:26,280 --> 00:18:29,640
other person or what LO what is the

00:18:28,170 --> 00:18:30,870
location for this meeting or should we

00:18:29,640 --> 00:18:32,400
send the invite who should we send the

00:18:30,870 --> 00:18:33,870
invite to so that is the decision making

00:18:32,400 --> 00:18:35,940
system for the rest of this presentation

00:18:33,870 --> 00:18:37,350
we are going to be assuming and on the

00:18:35,940 --> 00:18:39,210
decision making system although the

00:18:37,350 --> 00:18:40,530
machine learning system has its own set

00:18:39,210 --> 00:18:44,970
of challenges but that's not what I'm

00:18:40,530 --> 00:18:46,830
going to be talking about here so how do

00:18:44,970 --> 00:18:48,320
we test this decision-making system

00:18:46,830 --> 00:18:51,450
right so what does it mean to be

00:18:48,320 --> 00:18:53,340
testable of like to be easy test easily

00:18:51,450 --> 00:18:55,770
testable it so test should be easy to

00:18:53,340 --> 00:18:57,930
write it needs to be fast and when I say

00:18:55,770 --> 00:18:59,430
fast it needs to be fast to execute but

00:18:57,930 --> 00:19:01,260
also it leaks be fast to add another

00:18:59,430 --> 00:19:03,540
test and of course it should be

00:19:01,260 --> 00:19:05,520
reproducible so in a particular domain

00:19:03,540 --> 00:19:08,010
model right it's the input can be very

00:19:05,520 --> 00:19:09,480
very complex so you're not just writing

00:19:08,010 --> 00:19:11,040
tests on a single email by you're

00:19:09,480 --> 00:19:13,320
writing tests on us or the whole set of

00:19:11,040 --> 00:19:15,450
email and the single emails within this

00:19:13,320 --> 00:19:18,180
whole thread can contain hat actually

00:19:15,450 --> 00:19:20,880
specifically has 36 fields so if you

00:19:18,180 --> 00:19:23,610
have a set of say 10 emails and if you

00:19:20,880 --> 00:19:25,980
have to set the parameters of 36 emails

00:19:23,610 --> 00:19:28,800
or a subset or a huge number of those 36

00:19:25,980 --> 00:19:30,960
36 feels in those emails you can imagine

00:19:28,800 --> 00:19:32,220
that your tests can easily a single test

00:19:30,960 --> 00:19:33,660
can easily be like hundreds of lines

00:19:32,220 --> 00:19:36,930
long and that's kind of where we start

00:19:33,660 --> 00:19:39,480
off with but over time we have improved

00:19:36,930 --> 00:19:41,970
the testing the test data generation the

00:19:39,480 --> 00:19:44,700
test library that we have so our take on

00:19:41,970 --> 00:19:47,490
this is we use default values in our

00:19:44,700 --> 00:19:49,640
test data and our test fixtures but in

00:19:47,490 --> 00:19:53,310
production we don't use default values

00:19:49,640 --> 00:19:55,590
because yeah you don't want to actually

00:19:53,310 --> 00:19:57,419
initialize incorrect default values in

00:19:55,590 --> 00:19:59,820
production but they are very very useful

00:19:57,419 --> 00:20:02,339
or tests and on top of this we have

00:19:59,820 --> 00:20:04,409
built some small dsls and vsi used

00:20:02,339 --> 00:20:06,329
vehicles in quotes but small

00:20:04,409 --> 00:20:09,419
functionality to make it very very easy

00:20:06,329 --> 00:20:10,859
to write tests so practically speaking

00:20:09,419 --> 00:20:13,200
this is what it looks like see on the

00:20:10,859 --> 00:20:16,139
left side you have the case class which

00:20:13,200 --> 00:20:18,749
is used in production which has lots of

00:20:16,139 --> 00:20:21,899
fields no default values and the right

00:20:18,749 --> 00:20:23,969
side you have this object email which is

00:20:21,899 --> 00:20:26,969
sort of a companion object which looks

00:20:23,969 --> 00:20:28,889
exactly like the email case classing

00:20:26,969 --> 00:20:31,469
production when you actually use it but

00:20:28,889 --> 00:20:33,329
it has default values and within the

00:20:31,469 --> 00:20:35,159
apply method you can choose to sort of

00:20:33,329 --> 00:20:36,869
convert the default values of these

00:20:35,159 --> 00:20:39,570
functions into something that fits into

00:20:36,869 --> 00:20:41,159
the case class of the senior so when you

00:20:39,570 --> 00:20:43,379
actually use this and write tests and

00:20:41,159 --> 00:20:45,779
write a thread which is this is what I

00:20:43,379 --> 00:20:48,119
said looks like in our test fixtures you

00:20:45,779 --> 00:20:51,209
get this really really concise but also

00:20:48,119 --> 00:20:53,159
easily understandable sort of test

00:20:51,209 --> 00:20:56,399
fixtures that you can just write so with

00:20:53,159 --> 00:20:59,279
this you have sort of scales from a few

00:20:56,399 --> 00:21:01,379
hundreds of tests to several thousands

00:20:59,279 --> 00:21:04,499
or a span of like 1 1/2 years so this is

00:21:01,379 --> 00:21:07,529
being very very useful to just write

00:21:04,499 --> 00:21:09,809
test anything so that that that kind of

00:21:07,529 --> 00:21:13,049
sort of comes down to the foundations

00:21:09,809 --> 00:21:15,719
right so when you write a feature right

00:21:13,049 --> 00:21:18,149
and you look at the test and you say hey

00:21:15,719 --> 00:21:19,859
it's so boring to write a test or it's

00:21:18,149 --> 00:21:21,299
so painful to write a test you'd

00:21:19,859 --> 00:21:23,609
probably like probably one or two tests

00:21:21,299 --> 00:21:25,919
just to tell everybody hey I wrote these

00:21:23,609 --> 00:21:28,200
tests and it just whether the test

00:21:25,919 --> 00:21:29,759
posnick in deploy it but if you make

00:21:28,200 --> 00:21:31,709
your DSL and the test data generation

00:21:29,759 --> 00:21:33,479
very simple right then you're going to

00:21:31,709 --> 00:21:34,829
write actually many many more tests for

00:21:33,479 --> 00:21:36,479
every single feature that you write so

00:21:34,829 --> 00:21:39,779
this is something they found very useful

00:21:36,479 --> 00:21:42,179
over the last one I have here just one

00:21:39,779 --> 00:21:45,019
thing to quickly say this goes down into

00:21:42,179 --> 00:21:47,940
specifics like investing in in in slight

00:21:45,019 --> 00:21:49,709
usability things that you might think

00:21:47,940 --> 00:21:51,089
are not really worth it like if you look

00:21:49,709 --> 00:21:53,759
at the example here the second email

00:21:51,089 --> 00:21:55,679
it's a 2 equals guests if you remember

00:21:53,759 --> 00:21:57,509
the case class the actual production

00:21:55,679 --> 00:21:59,429
case plus 2 is a list because you can

00:21:57,509 --> 00:22:01,139
send an email to many people so you

00:21:59,429 --> 00:22:02,459
might have said yeah why I'm going to

00:22:01,139 --> 00:22:04,919
bother with this convenience thing I'll

00:22:02,459 --> 00:22:06,329
just make people pass a list I can tell

00:22:04,919 --> 00:22:09,209
you once you've written a thousand tests

00:22:06,329 --> 00:22:11,040
where you write a singleton list it

00:22:09,209 --> 00:22:13,080
starts to get annoying it starts to

00:22:11,040 --> 00:22:15,180
less readable so yes invest the effort

00:22:13,080 --> 00:22:18,690
in allowing people to pass a single

00:22:15,180 --> 00:22:21,300
value or a list in whichever case they

00:22:18,690 --> 00:22:23,370
need and so yeah you might think a

00:22:21,300 --> 00:22:25,500
wasted effort but given that you are

00:22:23,370 --> 00:22:27,990
going to use your test fixture

00:22:25,500 --> 00:22:30,330
constructors all the time all over the

00:22:27,990 --> 00:22:31,920
place it's worth investing effort into

00:22:30,330 --> 00:22:32,760
making them as clean and readable as

00:22:31,920 --> 00:22:36,000
they possibly can be

00:22:32,760 --> 00:22:38,490
and another note you always have to make

00:22:36,000 --> 00:22:40,140
an escape patch available because while

00:22:38,490 --> 00:22:42,120
this is beautiful this is concise it

00:22:40,140 --> 00:22:44,580
will not account for all the tests so

00:22:42,120 --> 00:22:46,440
all but in this case with this pattern

00:22:44,580 --> 00:22:48,390
all you have to do is just import the

00:22:46,440 --> 00:22:51,120
models case class and just use that

00:22:48,390 --> 00:22:54,390
directly it really happens but when you

00:22:51,120 --> 00:22:56,190
need it it's there sort of a bigger

00:22:54,390 --> 00:22:58,440
picture on like testing like feature

00:22:56,190 --> 00:23:01,170
implementations right so on one side you

00:22:58,440 --> 00:23:01,890
have like the changes that you do make

00:23:01,170 --> 00:23:03,330
no change

00:23:01,890 --> 00:23:04,710
you know that this change should have

00:23:03,330 --> 00:23:06,510
this behavior and you know that this

00:23:04,710 --> 00:23:09,110
change should not have this behavior and

00:23:06,510 --> 00:23:11,670
this is sort of easy testable with the

00:23:09,110 --> 00:23:14,160
unit test integration test or anything

00:23:11,670 --> 00:23:16,440
in between right but on the other side

00:23:14,160 --> 00:23:17,820
like you make a change but it has all

00:23:16,440 --> 00:23:19,620
these other effects that you could not

00:23:17,820 --> 00:23:20,820
have thought of like especially and this

00:23:19,620 --> 00:23:23,430
is a speedy proof you have written like

00:23:20,820 --> 00:23:24,930
big software write all the dumb scene

00:23:23,430 --> 00:23:26,460
changes where you cannot have thought up

00:23:24,930 --> 00:23:28,770
and only when you deploy it realize oh

00:23:26,460 --> 00:23:31,230
 I should have thought of that but

00:23:28,770 --> 00:23:32,760
that's hindsight I don't think there's a

00:23:31,230 --> 00:23:35,010
general solution or a widely accepted

00:23:32,760 --> 00:23:37,380
solution for this in general in the

00:23:35,010 --> 00:23:38,820
software development but I'm going to be

00:23:37,380 --> 00:23:42,180
talking shortly about what we have done

00:23:38,820 --> 00:23:45,120
to make this a little better that's it

00:23:42,180 --> 00:23:47,910
taking the sliced Rd curve of debugging

00:23:45,120 --> 00:23:50,460
right so sometimes we make mistakes like

00:23:47,910 --> 00:23:51,960
for example we get the complaints from

00:23:50,460 --> 00:23:54,210
our customer success team by saying that

00:23:51,960 --> 00:23:55,440
so why did Amy send an invite for 1:00

00:23:54,210 --> 00:23:57,360
in the morning that does not make any

00:23:55,440 --> 00:24:00,030
sense whatsoever and this happens

00:23:57,360 --> 00:24:02,670
sometimes and quite a lot actually but

00:24:00,030 --> 00:24:04,500
the thing is we what we should try and

00:24:02,670 --> 00:24:05,820
do is we should make it easy to fix it

00:24:04,500 --> 00:24:07,350
right we need to make it easy deep

00:24:05,820 --> 00:24:09,390
reduce and fix it so that we get rid of

00:24:07,350 --> 00:24:11,370
problems as soon as possible just to be

00:24:09,390 --> 00:24:12,690
clear not the 1 a.m. invites but there's

00:24:11,370 --> 00:24:16,890
a lot in places where I want to

00:24:12,690 --> 00:24:19,050
understand what's going on yeah so honor

00:24:16,890 --> 00:24:21,270
from the architecture right business of

00:24:19,050 --> 00:24:22,680
the decision-making system this is a

00:24:21,270 --> 00:24:24,039
high level architecture where you have

00:24:22,680 --> 00:24:26,799
an HTTP request

00:24:24,039 --> 00:24:28,509
and I'll call this this I'll call is

00:24:26,799 --> 00:24:30,039
basically it's the pitch patches all

00:24:28,509 --> 00:24:31,600
kinds of data this may make calls to

00:24:30,039 --> 00:24:34,239
micro services this make me a call to

00:24:31,600 --> 00:24:36,489
databases and other things others I or

00:24:34,239 --> 00:24:38,830
it may make also Google Maps API and the

00:24:36,489 --> 00:24:40,809
Google calendars API and so on then you

00:24:38,830 --> 00:24:42,999
have a level a set of pure logic and

00:24:40,809 --> 00:24:44,409
this is fairly complex for your logic

00:24:42,999 --> 00:24:46,600
that figures out the best times in the

00:24:44,409 --> 00:24:48,460
best locations and so on and then you

00:24:46,600 --> 00:24:50,619
have the HTTP response to the client

00:24:48,460 --> 00:24:52,450
whoever calls to service and all the

00:24:50,619 --> 00:24:53,919
database updates related to this like

00:24:52,450 --> 00:24:55,869
updating the emails and updating the

00:24:53,919 --> 00:24:59,190
meeting etc are done on the client side

00:24:55,869 --> 00:25:02,409
and not on this specific service right

00:24:59,190 --> 00:25:04,090
so this is slightly different from a

00:25:02,409 --> 00:25:05,349
typical web service that you see and

00:25:04,090 --> 00:25:07,419
it's likely depicted they're different

00:25:05,349 --> 00:25:09,070
from how we initially started off so

00:25:07,419 --> 00:25:10,419
when you initially started off we did a

00:25:09,070 --> 00:25:12,309
lot of intermingling between the

00:25:10,419 --> 00:25:14,289
business logic and the micro service

00:25:12,309 --> 00:25:16,179
calls but we found it very very

00:25:14,289 --> 00:25:17,859
difficult to test respect please begin

00:25:16,179 --> 00:25:19,989
it is the test and very slowly it was

00:25:17,859 --> 00:25:22,059
difficult to define tests and so on so

00:25:19,989 --> 00:25:26,169
we didn't made a conscious effort

00:25:22,059 --> 00:25:27,519
autoloader span a few months but it has

00:25:26,169 --> 00:25:29,710
been consistent over the last two years

00:25:27,519 --> 00:25:33,249
where we kept the pure business logic

00:25:29,710 --> 00:25:35,799
separate and the IO call circuit so in

00:25:33,249 --> 00:25:38,019
code this is what it looks like you have

00:25:35,799 --> 00:25:40,029
a function decides which is the actual

00:25:38,019 --> 00:25:42,070
decision-making system which takes in an

00:25:40,029 --> 00:25:44,830
email press which can contain emails

00:25:42,070 --> 00:25:47,080
from humans but also contains outgoing

00:25:44,830 --> 00:25:48,820
responses from Amy and Android and the

00:25:47,080 --> 00:25:50,289
output of this decide is basically the

00:25:48,820 --> 00:25:54,759
outgoing emails what are the emails we

00:25:50,289 --> 00:25:57,159
send out people then we have a tiny

00:25:54,759 --> 00:25:58,749
function tiny i/o function which has

00:25:57,159 --> 00:26:00,789
limited business logic which does all

00:25:58,749 --> 00:26:03,129
the queries and then we have this

00:26:00,789 --> 00:26:04,389
desired pure which is a pure functions

00:26:03,129 --> 00:26:06,460
there are no side effects there is no

00:26:04,389 --> 00:26:11,259
mutation there is no IO calls whatsoever

00:26:06,460 --> 00:26:13,509
and this is easily testable and we can

00:26:11,259 --> 00:26:16,109
reuse logging and views M&I for

00:26:13,509 --> 00:26:18,460
debugging to make it easy debugger and

00:26:16,109 --> 00:26:20,259
then we have this meeting context which

00:26:18,460 --> 00:26:22,659
is basically the output of the fetch

00:26:20,259 --> 00:26:26,739
data and the input to this design pure

00:26:22,659 --> 00:26:27,999
thing and the design pure itself returns

00:26:26,739 --> 00:26:29,679
an updated version of the beading

00:26:27,999 --> 00:26:31,570
context which can be the updated emails

00:26:29,679 --> 00:26:33,700
or the updated meeting the updated

00:26:31,570 --> 00:26:35,300
profile for example they may have set up

00:26:33,700 --> 00:26:38,360
specific preference

00:26:35,300 --> 00:26:40,670
this is what the meeting context is so

00:26:38,360 --> 00:26:44,930
what we do here is we take a snapshot of

00:26:40,670 --> 00:26:46,880
this meeting context so what this means

00:26:44,930 --> 00:26:49,100
is like whatever the output of the

00:26:46,880 --> 00:26:51,410
sketch thing we converted the JSON we

00:26:49,100 --> 00:26:55,310
assign a unique ID and we just order in

00:26:51,410 --> 00:26:57,530
the database so if any of you use like a

00:26:55,310 --> 00:26:59,690
PM tools or something like that like New

00:26:57,530 --> 00:27:01,640
Relic in production you'll get a sort of

00:26:59,690 --> 00:27:03,830
vague version of this you'll drill 8

00:27:01,640 --> 00:27:06,590
million lines down into some crazy UI

00:27:03,830 --> 00:27:08,450
and there'll be method call and then

00:27:06,590 --> 00:27:11,150
you'll click on something and it'll show

00:27:08,450 --> 00:27:13,580
you some enormous whatever it was able

00:27:11,150 --> 00:27:14,630
to capture but the nice thing is like if

00:27:13,580 --> 00:27:16,280
you write code like this you don't have

00:27:14,630 --> 00:27:19,340
to rely on some incredibly complicated

00:27:16,280 --> 00:27:22,310
tool with an impenetrable UI and no API

00:27:19,340 --> 00:27:24,800
to find this kind of information like

00:27:22,310 --> 00:27:26,120
you just you get it you save it you do

00:27:24,800 --> 00:27:28,910
whatever what you want with it Varun

00:27:26,120 --> 00:27:30,890
will tell us what we do with it yeah yes

00:27:28,910 --> 00:27:33,110
so just think about it so we have this

00:27:30,890 --> 00:27:34,880
exact thing that went into this very

00:27:33,110 --> 00:27:37,070
complex decide pure function right and

00:27:34,880 --> 00:27:40,400
that they found to be fairly powerful

00:27:37,070 --> 00:27:43,550
for debugging and various other things

00:27:40,400 --> 00:27:45,650
some specifics of it this has been very

00:27:43,550 --> 00:27:47,510
useful for technical teams as well as

00:27:45,650 --> 00:27:49,460
our customer success teams so whenever

00:27:47,510 --> 00:27:51,050
they see a bug for example the 1 a.m.

00:27:49,460 --> 00:27:53,030
bug all you have to do is you have to

00:27:51,050 --> 00:27:54,740
click a button they get a snapshot that

00:27:53,030 --> 00:27:56,060
is stored in a database and we have they

00:27:54,740 --> 00:27:57,470
give us an ID so in the bug report

00:27:56,060 --> 00:27:59,810
you'll give a description of what went

00:27:57,470 --> 00:28:01,640
wrong and the snapshot ID and for us

00:27:59,810 --> 00:28:03,770
like our developers all you have to do

00:28:01,640 --> 00:28:06,140
is take the snapshot ID and hit the

00:28:03,770 --> 00:28:08,600
command like design snapshot ID and we

00:28:06,140 --> 00:28:11,150
can trivially reproduce it so our

00:28:08,600 --> 00:28:13,790
situation cycle for at least reproducing

00:28:11,150 --> 00:28:15,410
bugs has been very very fast because of

00:28:13,790 --> 00:28:17,360
this I want to give a special shout-out

00:28:15,410 --> 00:28:18,980
to ammonite which have been using quite

00:28:17,360 --> 00:28:21,260
a lot and specifically the debug thing

00:28:18,980 --> 00:28:22,520
where you can pause the execution and

00:28:21,260 --> 00:28:24,950
you can analyze the variables and

00:28:22,520 --> 00:28:26,780
perform functions on these variables and

00:28:24,950 --> 00:28:28,520
again I mean this idea of storing

00:28:26,780 --> 00:28:30,020
context is obviously not unique and new

00:28:28,520 --> 00:28:32,990
like there's a bunch of languages that

00:28:30,020 --> 00:28:34,970
support small talk or something but you

00:28:32,990 --> 00:28:37,220
can you can actually freeze the entire

00:28:34,970 --> 00:28:38,780
execution context of a given thread when

00:28:37,220 --> 00:28:40,420
it crashes and you get the whole stack

00:28:38,780 --> 00:28:43,220
frame and all this kind of stuff and

00:28:40,420 --> 00:28:46,250
point is that's very hard to do also

00:28:43,220 --> 00:28:48,380
very hard to reload to warm up again to

00:28:46,250 --> 00:28:49,040
then work on with this kind of approach

00:28:48,380 --> 00:28:51,110
you don't

00:28:49,040 --> 00:28:52,550
- do any of that I think that's the kind

00:28:51,110 --> 00:28:55,760
of nice thing you're back to working

00:28:52,550 --> 00:28:57,260
with yeah it's a scala object and it's a

00:28:55,760 --> 00:28:59,480
bunch of JSON I can look at it in the

00:28:57,260 --> 00:29:01,700
database just a the tooling to manage

00:28:59,480 --> 00:29:04,550
this stuff is so much more powerful than

00:29:01,700 --> 00:29:06,200
the very specific kind of debugger you

00:29:04,550 --> 00:29:08,720
know low-level stuff that you would need

00:29:06,200 --> 00:29:11,060
if you wanted to resurrect a particular

00:29:08,720 --> 00:29:15,560
function call in an arbitrary

00:29:11,060 --> 00:29:17,810
environment getting back to the thing

00:29:15,560 --> 00:29:19,790
where you have tests for the things that

00:29:17,810 --> 00:29:20,930
you know that you shouldn't change you

00:29:19,790 --> 00:29:22,460
know you should change or should not

00:29:20,930 --> 00:29:25,280
change but for the other side you

00:29:22,460 --> 00:29:26,780
unknown stuff right are the approach

00:29:25,280 --> 00:29:29,630
reviews from many of our systems is

00:29:26,780 --> 00:29:32,470
basically replace which builds upon the

00:29:29,630 --> 00:29:34,760
idea of snapshots so over time you have

00:29:32,470 --> 00:29:36,140
you store snapshots for every single

00:29:34,760 --> 00:29:38,900
request that goes into the system right

00:29:36,140 --> 00:29:41,180
and over time you get a huge huge

00:29:38,900 --> 00:29:42,530
database of snapshot it's finally enough

00:29:41,180 --> 00:29:45,920
it's actually one of our biggest

00:29:42,530 --> 00:29:47,600
datasets in our system right now but

00:29:45,920 --> 00:29:50,690
once you have this used set of data the

00:29:47,600 --> 00:29:54,500
set of snapshots whenever you make a

00:29:50,690 --> 00:29:57,080
change you reach Hades so you take a

00:29:54,500 --> 00:29:59,750
subset of them you pass it against what

00:29:57,080 --> 00:30:00,830
you are developing on the branch that

00:29:59,750 --> 00:30:02,900
you're developing on and what is

00:30:00,830 --> 00:30:05,210
currently running on production and just

00:30:02,900 --> 00:30:07,130
compare the two results you perform it

00:30:05,210 --> 00:30:08,480
differs the two results if they are both

00:30:07,130 --> 00:30:10,130
exactly the same that means this

00:30:08,480 --> 00:30:12,350
particular snapshot was not affected and

00:30:10,130 --> 00:30:14,600
if there was a difference you can

00:30:12,350 --> 00:30:16,060
analyze the difference and see okay has

00:30:14,600 --> 00:30:18,830
something changed is this changing

00:30:16,060 --> 00:30:20,750
expected it's so kind if this change is

00:30:18,830 --> 00:30:23,420
not expected and that happens quite a

00:30:20,750 --> 00:30:25,670
bit when you're developing then you

00:30:23,420 --> 00:30:27,980
analyze it you see if you have to make a

00:30:25,670 --> 00:30:29,270
change in your code or not and I think

00:30:27,980 --> 00:30:30,860
there's two important things yeah I mean

00:30:29,270 --> 00:30:33,260
this again this is like shadow mode if

00:30:30,860 --> 00:30:35,780
any of you done like a B kind of testing

00:30:33,260 --> 00:30:37,370
this is like running in shadow mode but

00:30:35,780 --> 00:30:39,110
shadow mode is actually very hard to

00:30:37,370 --> 00:30:40,640
operationalize to actually make happen

00:30:39,110 --> 00:30:42,680
and the architecture that the room is

00:30:40,640 --> 00:30:45,410
showing is critical to this because a

00:30:42,680 --> 00:30:47,030
shadow mode requires inputs like you

00:30:45,410 --> 00:30:48,800
have to actually get the inputs to the

00:30:47,030 --> 00:30:51,470
system then you do things like queue

00:30:48,800 --> 00:30:53,480
splitting and HTTP traffic splitting and

00:30:51,470 --> 00:30:55,640
weirdness around you're doubling your

00:30:53,480 --> 00:30:57,080
database like capacity so you can handle

00:30:55,640 --> 00:30:59,420
two systems calling it at the same time

00:30:57,080 --> 00:31:01,640
that all goes away largely with this

00:30:59,420 --> 00:31:02,940
because you just make the same call load

00:31:01,640 --> 00:31:05,620
the same snapshot a little bit

00:31:02,940 --> 00:31:07,840
and the other bit is you have to make

00:31:05,620 --> 00:31:10,240
sure that the one shadow system is not

00:31:07,840 --> 00:31:11,860
you know sending out every email twice

00:31:10,240 --> 00:31:14,260
and so you have to make it to the

00:31:11,860 --> 00:31:16,240
idempotent or at least not damaging and

00:31:14,260 --> 00:31:18,490
if you remember back to the architecture

00:31:16,240 --> 00:31:20,290
that the room was showing because the

00:31:18,490 --> 00:31:22,270
output of this is just a response object

00:31:20,290 --> 00:31:23,799
it's up to the client to decide to

00:31:22,270 --> 00:31:26,470
persist it or do something like that you

00:31:23,799 --> 00:31:29,679
get the kind of no side affecting part

00:31:26,470 --> 00:31:31,420
for free so basically all you end up

00:31:29,679 --> 00:31:33,700
having to do quote-unquote all is

00:31:31,420 --> 00:31:38,380
compare the responses from two different

00:31:33,700 --> 00:31:40,660
services factors this is what it looks

00:31:38,380 --> 00:31:42,850
like so we have built a fair amount of

00:31:40,660 --> 00:31:44,049
tooling in this simply because we tried

00:31:42,850 --> 00:31:46,990
it out and Chris what actually

00:31:44,049 --> 00:31:48,700
instrumental in all of this but we've

00:31:46,990 --> 00:31:51,250
built a lot of tooling around making it

00:31:48,700 --> 00:31:52,870
easy to go to the snapshot and see if

00:31:51,250 --> 00:31:54,400
something went wrong and so for every

00:31:52,870 --> 00:31:56,770
commit or every pull request that you

00:31:54,400 --> 00:31:58,929
have we get a summary saying hey there

00:31:56,770 --> 00:32:01,870
was there were so many matches there

00:31:58,929 --> 00:32:04,360
were so many discs and service report

00:32:01,870 --> 00:32:06,160
for you to analyze and if there's a disk

00:32:04,360 --> 00:32:08,320
we have built again we are built tooling

00:32:06,160 --> 00:32:09,940
to make it easy to analyze this instead

00:32:08,320 --> 00:32:11,860
of just seeing show showing at the left

00:32:09,940 --> 00:32:13,809
hand side right hand side and huge JSON

00:32:11,860 --> 00:32:15,790
blobs which is like probably thousand

00:32:13,809 --> 00:32:19,990
lines long we just show the specific

00:32:15,790 --> 00:32:21,910
fields that have changed again this is

00:32:19,990 --> 00:32:24,280
makes it very very fast so if you think

00:32:21,910 --> 00:32:26,650
about it so if the 200 things that have

00:32:24,280 --> 00:32:28,630
changed chances are that hundred of them

00:32:26,650 --> 00:32:31,030
will have like look very very similar so

00:32:28,630 --> 00:32:33,010
you after looking at say ten specific

00:32:31,030 --> 00:32:36,130
instances of that disk you can just skip

00:32:33,010 --> 00:32:37,990
over most of them the dot dot dots in

00:32:36,130 --> 00:32:39,790
that screen show they're not for the

00:32:37,990 --> 00:32:43,840
benefit of the slide that actually what

00:32:39,790 --> 00:32:45,760
it looks like yeah so here's the library

00:32:43,840 --> 00:32:47,890
associated with it you can take a look

00:32:45,760 --> 00:32:51,390
at it and it's contribute to it that's

00:32:47,890 --> 00:32:54,669
great or use it that's even better

00:32:51,390 --> 00:32:56,980
so it's this doable in this practice or

00:32:54,669 --> 00:32:59,290
is this very very exciting I

00:32:56,980 --> 00:33:01,030
specifically so it's being very useful

00:32:59,290 --> 00:33:03,220
for us at least for this part of the

00:33:01,030 --> 00:33:05,260
system can be expanded to other systems

00:33:03,220 --> 00:33:07,540
in extra day I can probably some of you

00:33:05,260 --> 00:33:11,230
use this and I think that's a good

00:33:07,540 --> 00:33:13,030
question to be asked so I think from the

00:33:11,230 --> 00:33:16,240
the coding pattern perspective I think

00:33:13,030 --> 00:33:16,690
yes absolutely I mean we we use this

00:33:16,240 --> 00:33:17,830
stuff in for

00:33:16,690 --> 00:33:20,340
action what are the questions that

00:33:17,830 --> 00:33:22,960
normally come up right is this going to

00:33:20,340 --> 00:33:25,930
hinder us some how are we going to lose

00:33:22,960 --> 00:33:28,390
some kind of expressivity that we might

00:33:25,930 --> 00:33:30,130
need I think that's where the the lesson

00:33:28,390 --> 00:33:31,570
about trapdoors comes in like the

00:33:30,130 --> 00:33:33,640
example of the room was giving in the

00:33:31,570 --> 00:33:35,980
test data specifically if you then go

00:33:33,640 --> 00:33:37,660
and make your actual domain object

00:33:35,980 --> 00:33:40,000
constructor private or something like

00:33:37,660 --> 00:33:42,100
that or not importa belen you are tying

00:33:40,000 --> 00:33:43,990
yourself like we found that you do still

00:33:42,100 --> 00:33:45,640
need to have that trapdoor if you want

00:33:43,990 --> 00:33:47,650
to get the string out of a type wrapper

00:33:45,640 --> 00:33:48,910
you need to make that easy like you

00:33:47,650 --> 00:33:51,220
don't want to have to go through all

00:33:48,910 --> 00:33:52,630
kinds of Hoops and say no no thou shalt

00:33:51,220 --> 00:33:55,810
never use the string inside the type

00:33:52,630 --> 00:33:57,400
wrapper kind of thing you there you know

00:33:55,810 --> 00:33:59,050
for performance reasons you don't want

00:33:57,400 --> 00:34:00,520
to be creating millions and millions of

00:33:59,050 --> 00:34:02,050
objects like the garbage collector

00:34:00,520 --> 00:34:03,430
doesn't love that if you're basically

00:34:02,050 --> 00:34:05,590
wrapping a string in an object every

00:34:03,430 --> 00:34:07,690
time and if you're familiar with them

00:34:05,590 --> 00:34:09,130
you probably know the obvious things to

00:34:07,690 --> 00:34:11,350
try for this are things like inline in

00:34:09,130 --> 00:34:13,570
any valve if not I highly recommend you

00:34:11,350 --> 00:34:16,540
have a look at the SI P for value

00:34:13,570 --> 00:34:18,340
classes that's what what the any vowel

00:34:16,540 --> 00:34:19,720
thing is if you extend any vowel it's a

00:34:18,340 --> 00:34:21,580
bit of magic that tells the compiler

00:34:19,720 --> 00:34:23,110
that it should actually not bother

00:34:21,580 --> 00:34:25,680
creating new objects for the thing it's

00:34:23,110 --> 00:34:28,630
just duct-taping methods on to stuff and

00:34:25,680 --> 00:34:32,140
sorry i did say the easy breakout when

00:34:28,630 --> 00:34:35,410
necessary from the architecture side I

00:34:32,140 --> 00:34:36,880
think it's it's our sort of Defense so

00:34:35,410 --> 00:34:38,680
there are many applications which are

00:34:36,880 --> 00:34:40,300
all about I or I have welcome

00:34:38,680 --> 00:34:42,370
applications where there was very very

00:34:40,300 --> 00:34:43,690
little business logic the difficult part

00:34:42,370 --> 00:34:45,580
was all about making the database

00:34:43,690 --> 00:34:48,910
queries fast and optimizing the index

00:34:45,580 --> 00:34:50,590
and stuff like that and so it may not be

00:34:48,910 --> 00:34:51,760
applicable the architecture we just

00:34:50,590 --> 00:34:55,240
spoke about may not be applicable for

00:34:51,760 --> 00:34:56,920
those kind of systems and here obviously

00:34:55,240 --> 00:35:01,960
you need to query more data than you

00:34:56,920 --> 00:35:03,760
need so so by separating IO and the

00:35:01,960 --> 00:35:05,770
booth logic completely you're not going

00:35:03,760 --> 00:35:06,910
to explore all the code parts in the

00:35:05,770 --> 00:35:09,010
business logic which means you don't

00:35:06,910 --> 00:35:11,740
need all the data that you just queried

00:35:09,010 --> 00:35:13,480
right but so you need to make a decision

00:35:11,740 --> 00:35:16,180
whether it's okay to query more data

00:35:13,480 --> 00:35:17,860
than you need then then you actually

00:35:16,180 --> 00:35:19,540
need and in some applications that's

00:35:17,860 --> 00:35:22,090
fine for example in our application it's

00:35:19,540 --> 00:35:25,750
still not to be not a problem so far but

00:35:22,090 --> 00:35:28,210
it may be a problem in many cases and

00:35:25,750 --> 00:35:29,650
then then you may have some systems

00:35:28,210 --> 00:35:30,490
where you perform a significant business

00:35:29,650 --> 00:35:32,170
logic

00:35:30,490 --> 00:35:33,550
you do i/o based on the results of the

00:35:32,170 --> 00:35:36,460
business logic then you have another

00:35:33,550 --> 00:35:38,470
significant difference logic obviously

00:35:36,460 --> 00:35:40,420
this does not work in such a case but it

00:35:38,470 --> 00:35:42,040
might work with such a modification and

00:35:40,420 --> 00:35:43,780
this is something we have the Simpson

00:35:42,040 --> 00:35:45,730
are in our company where it's like that

00:35:43,780 --> 00:35:48,130
and I am currently exploring how we can

00:35:45,730 --> 00:35:49,510
modify it to make it work so the way I'm

00:35:48,130 --> 00:35:51,940
thinking about it is split up into pairs

00:35:49,510 --> 00:35:53,830
of i/o and then business logic i/o

00:35:51,940 --> 00:35:56,470
business logic and you perform snapshots

00:35:53,830 --> 00:35:58,060
on these independent parts again I'm not

00:35:56,470 --> 00:35:59,740
tied at yet and I don't know how well

00:35:58,060 --> 00:36:03,060
it'll work in practice but that's how

00:35:59,740 --> 00:36:05,140
that's what I'm thinking of implementing

00:36:03,060 --> 00:36:06,790
practically speaking we have a hundred

00:36:05,140 --> 00:36:08,050
key lines of code where we have

00:36:06,790 --> 00:36:10,930
implemented this architecture with the

00:36:08,050 --> 00:36:12,970
snapshot and so on so it has worked for

00:36:10,930 --> 00:36:14,980
us for a significant amount of time for

00:36:12,970 --> 00:36:16,960
a significantly large code base or the

00:36:14,980 --> 00:36:19,300
obvious caveat is like what is lines of

00:36:16,960 --> 00:36:23,950
code even mean but it's kind of work for

00:36:19,300 --> 00:36:25,270
us on a higher level I think the lesson

00:36:23,950 --> 00:36:28,839
to be learned is that the separation of

00:36:25,270 --> 00:36:30,670
i/o and business logic it's we all know

00:36:28,839 --> 00:36:32,200
that it's pretty good software practice

00:36:30,670 --> 00:36:34,060
is a pretty good design decision to make

00:36:32,200 --> 00:36:36,010
but it does lead to it is a very

00:36:34,060 --> 00:36:37,750
fundamental thing that can lead to very

00:36:36,010 --> 00:36:39,609
interesting testability practices and

00:36:37,750 --> 00:36:42,339
testability properties and like

00:36:39,609 --> 00:36:43,089
snapshots debugging just easy test data

00:36:42,339 --> 00:36:45,369
and so on

00:36:43,089 --> 00:36:48,250
so I think these are good reasons where

00:36:45,369 --> 00:36:49,869
why you should do this and extra di it's

00:36:48,250 --> 00:36:51,609
definitely worth it and we have

00:36:49,869 --> 00:36:56,890
regressions over here have become quite

00:36:51,609 --> 00:36:58,599
rare so yeah that's about them these are

00:36:56,890 --> 00:37:00,250
some of the libraries under the summary

00:36:58,599 --> 00:37:03,160
of the libraries that you use we spoke

00:37:00,250 --> 00:37:04,869
about over here and we have a bunch of

00:37:03,160 --> 00:37:06,790
other open source stuff other open

00:37:04,869 --> 00:37:08,859
source libraries do things we just check

00:37:06,790 --> 00:37:10,150
them out and use them just because it's

00:37:08,859 --> 00:37:12,130
like incredibly cool and your

00:37:10,150 --> 00:37:13,750
dependencies that I have AI dot X it's

00:37:12,130 --> 00:37:16,210
like it's a great way that sounded like

00:37:13,750 --> 00:37:18,849
it makes it look awesome I can tell you

00:37:16,210 --> 00:37:21,369
that yeah we get a bit now so contact

00:37:18,849 --> 00:37:23,470
details that we we amazingly managed to

00:37:21,369 --> 00:37:25,150
get through it in exactly the time we

00:37:23,470 --> 00:37:27,460
had planned that's like unbelievable

00:37:25,150 --> 00:37:30,130
no regressions on that front if you have

00:37:27,460 --> 00:37:31,990
any questions for us after the session

00:37:30,130 --> 00:37:33,910
here's our contact details the slides

00:37:31,990 --> 00:37:35,710
will be up you can tweet a Varun or X to

00:37:33,910 --> 00:37:38,530
the I and if you're interested in what

00:37:35,710 --> 00:37:41,050
we're doing we always have positions for

00:37:38,530 --> 00:37:42,070
developers come see us come speak to

00:37:41,050 --> 00:37:44,049
Chris anyone else

00:37:42,070 --> 00:37:45,880
quick shout out on that front

00:37:44,049 --> 00:37:47,859
EXO dyads gala days we kind of been

00:37:45,880 --> 00:37:49,619
given our own track that's pretty cool

00:37:47,859 --> 00:37:53,019
chris is going to be talking twice today

00:37:49,619 --> 00:37:56,739
at 4:50 and at 6:00

00:37:53,019 --> 00:37:58,630
so go catches talks and yes remember to

00:37:56,739 --> 00:38:09,729
rate the session question time thank you

00:37:58,630 --> 00:38:13,679
very much how do we enforce usage of the

00:38:09,729 --> 00:38:16,650
type rapper's safe rappers well I think

00:38:13,679 --> 00:38:20,079
part of it is we can do some linting

00:38:16,650 --> 00:38:21,939
part of it is education I think I mean

00:38:20,079 --> 00:38:24,789
it's one of those trade offs where we

00:38:21,939 --> 00:38:26,769
hope we are still at the level of size

00:38:24,789 --> 00:38:29,619
and scale of a company where just

00:38:26,769 --> 00:38:31,420
knowing that these things exist means

00:38:29,619 --> 00:38:33,459
that people will do the right thing I

00:38:31,420 --> 00:38:34,920
mean yeah we're it's not the sort of

00:38:33,459 --> 00:38:37,059
defense-in-depth problem where we're

00:38:34,920 --> 00:38:38,439
actively trying to prevent against

00:38:37,059 --> 00:38:40,269
people being sloppy like we're very

00:38:38,439 --> 00:38:42,969
lucky we work with a bunch of very smart

00:38:40,269 --> 00:38:44,559
and motivated people so it's once you

00:38:42,969 --> 00:38:45,969
tell them that they have these tools and

00:38:44,559 --> 00:38:47,199
and of course also what happens I mean

00:38:45,969 --> 00:38:48,880
we've learned especially when you get

00:38:47,199 --> 00:38:50,709
people working on a code base who are

00:38:48,880 --> 00:38:52,660
not familiar with it what they tend to

00:38:50,709 --> 00:38:54,099
do is they try to as best they can

00:38:52,660 --> 00:38:56,439
imitate the style of the code they

00:38:54,099 --> 00:38:58,689
already see so if you see a triple

00:38:56,439 --> 00:39:00,880
equals in the the cop line of code that

00:38:58,689 --> 00:39:02,019
you've just copy pasted more likely than

00:39:00,880 --> 00:39:03,849
not that's what you're going to use as

00:39:02,019 --> 00:39:05,859
opposed to thing I've mechanisms I'm

00:39:03,849 --> 00:39:07,299
going to use something else no that's

00:39:05,859 --> 00:39:08,709
exactly what happened at over here

00:39:07,299 --> 00:39:11,140
actually it's it's a combination of

00:39:08,709 --> 00:39:12,819
looking at pull requests and just if the

00:39:11,140 --> 00:39:13,779
some of the most sort of senior scholar

00:39:12,819 --> 00:39:15,549
engineers a knowledge of the scholar

00:39:13,779 --> 00:39:17,679
engineer to do this people who are just

00:39:15,549 --> 00:39:19,509
getting into color and to ask hey why do

00:39:17,679 --> 00:39:20,979
you do this ah that's a good idea

00:39:19,509 --> 00:39:24,459
let me also do this in my code so that's

00:39:20,979 --> 00:39:27,489
what tends to happen if yeah so question

00:39:24,459 --> 00:39:29,079
was have we had any seen any resistance

00:39:27,489 --> 00:39:30,579
to the use of type wrappers and then

00:39:29,079 --> 00:39:32,920
have we had any performance impact from

00:39:30,579 --> 00:39:34,689
that Chris can probably talk potentially

00:39:32,920 --> 00:39:36,670
about performance it like it's not the

00:39:34,689 --> 00:39:41,079
bottleneck of our system right now so I

00:39:36,670 --> 00:39:43,119
mean to that extent it may once we

00:39:41,079 --> 00:39:44,769
magically optimize everything else it

00:39:43,119 --> 00:39:48,279
may turn out that that's where we were

00:39:44,769 --> 00:39:50,019
we have an issue but at the moment it's

00:39:48,279 --> 00:39:51,670
not the part where we're struggling or

00:39:50,019 --> 00:39:53,559
if we are struggling that's not the

00:39:51,670 --> 00:39:56,739
bottleneck that we're looking at and

00:39:53,559 --> 00:39:57,920
yeah I think resistance I think it's

00:39:56,739 --> 00:39:59,510
similar answer to the

00:39:57,920 --> 00:40:02,089
this question we're in the lucky

00:39:59,510 --> 00:40:04,790
position where it's not we're not trying

00:40:02,089 --> 00:40:06,230
to fight entrenched like mentalities of

00:40:04,790 --> 00:40:07,940
the kind of why should I bother doing

00:40:06,230 --> 00:40:11,329
this doesn't make any sense like it's a

00:40:07,940 --> 00:40:12,680
stupid idea where we were lucky that we

00:40:11,329 --> 00:40:15,559
work with a bunch of people who are very

00:40:12,680 --> 00:40:16,910
receptive to ideas as long as we can

00:40:15,559 --> 00:40:19,400
make them available and present them and

00:40:16,910 --> 00:40:20,750
then obviously justify them no you can't

00:40:19,400 --> 00:40:23,960
do that I'll shout it has to be thou

00:40:20,750 --> 00:40:26,240
shalt because and as Varun said most of

00:40:23,960 --> 00:40:27,619
this wasn't like upfront design it's not

00:40:26,240 --> 00:40:29,420
as though we sort of went into a room

00:40:27,619 --> 00:40:30,980
and sat down and went like how do we as

00:40:29,420 --> 00:40:34,670
I design the perfectly safe no it's like

00:40:30,980 --> 00:40:37,099
after a production incident or after

00:40:34,670 --> 00:40:38,660
some lessons some sort of post mortems

00:40:37,099 --> 00:40:41,180
is that you say okay we've had too many

00:40:38,660 --> 00:40:43,220
issues with this kind of stuff like how

00:40:41,180 --> 00:40:44,299
do we go about it this is sort of three

00:40:43,220 --> 00:40:46,609
I don't have anybody knows that the

00:40:44,299 --> 00:40:49,069
three the three arm sweater mean like

00:40:46,609 --> 00:40:50,359
celebrate failure once once you can do

00:40:49,069 --> 00:40:51,890
that once you stop trying to assign

00:40:50,359 --> 00:40:53,780
blame you can come up with ideas like

00:40:51,890 --> 00:40:54,799
this and we get good buying but we're

00:40:53,780 --> 00:40:59,240
lucky in that sense I don't know

00:40:54,799 --> 00:41:00,950
resistance no no I mean as long as you

00:40:59,240 --> 00:41:02,990
are able to justify it and explain it

00:41:00,950 --> 00:41:08,230
and educate people and actually make it

00:41:02,990 --> 00:41:08,230
easy right to do it it's candy accepted

00:41:08,710 --> 00:41:14,890
all right Oh over there great question

00:41:17,049 --> 00:41:25,609
and speaking to the mic cuz otherwise it

00:41:19,339 --> 00:41:28,280
won't appear on the recording hey so one

00:41:25,609 --> 00:41:30,579
thing I mean for performance the value

00:41:28,280 --> 00:41:32,930
classes give you some benefit they're

00:41:30,579 --> 00:41:35,829
not completely without complication but

00:41:32,930 --> 00:41:38,059
but it solves a lot of problems but for

00:41:35,829 --> 00:41:40,819
that then another thing with type

00:41:38,059 --> 00:41:43,160
wrappers is that the different areas

00:41:40,819 --> 00:41:44,809
where you can use them for identifies

00:41:43,160 --> 00:41:46,339
for example it's fairly painless because

00:41:44,809 --> 00:41:48,049
you're only doing equality comparison

00:41:46,339 --> 00:41:49,609
and that's something you can just make

00:41:48,049 --> 00:41:51,980
work on your wrappers equally and then

00:41:49,609 --> 00:41:53,990
it's fine it's much harder when you have

00:41:51,980 --> 00:41:55,400
types where you like when you wrap a

00:41:53,990 --> 00:41:57,440
string that you actually want to modify

00:41:55,400 --> 00:41:59,089
and then you would have to have the like

00:41:57,440 --> 00:42:00,920
interoperate with the thing inside of it

00:41:59,089 --> 00:42:02,480
inside of it so we're actually not doing

00:42:00,920 --> 00:42:03,740
that we're using it for identifiers and

00:42:02,480 --> 00:42:06,799
we're using it for Strings which we

00:42:03,740 --> 00:42:08,540
don't modify and when we do which at

00:42:06,799 --> 00:42:09,799
least we don't transform but sometimes

00:42:08,540 --> 00:42:10,960
we need them somewhere else and we get

00:42:09,799 --> 00:42:13,570
the string out and use

00:42:10,960 --> 00:42:15,760
bring and embedded to something else we

00:42:13,570 --> 00:42:19,330
don't like do operations on them that

00:42:15,760 --> 00:42:21,250
makes it painless which would a broader

00:42:19,330 --> 00:42:22,990
theme is like immutability of certain

00:42:21,250 --> 00:42:24,460
types of data bla bla bla that kind of

00:42:22,990 --> 00:42:27,640
plays into that there was another

00:42:24,460 --> 00:42:29,980
question yes the question was were we

00:42:27,640 --> 00:42:32,980
concerned by the redundant IO that we

00:42:29,980 --> 00:42:36,280
were doing I think it sort of comes down

00:42:32,980 --> 00:42:39,640
to what the trade-offs are right so in

00:42:36,280 --> 00:42:41,050
our particular system there are a couple

00:42:39,640 --> 00:42:43,240
of interesting things we are not we're

00:42:41,050 --> 00:42:45,609
doing a real-time system where you're

00:42:43,240 --> 00:42:46,839
you have to have like sub 10 millisecond

00:42:45,609 --> 00:42:49,420
response or 700 millisecond response

00:42:46,839 --> 00:42:51,490
it's sort of expected that Amy's going

00:42:49,420 --> 00:42:52,480
to take a few minutes to respond then

00:42:51,490 --> 00:42:55,599
that's I think so

00:42:52,480 --> 00:42:58,270
performance is not a concern up and in

00:42:55,599 --> 00:43:01,109
general like with sort of the AWS and

00:42:58,270 --> 00:43:03,040
things like that and we don't have

00:43:01,109 --> 00:43:04,359
hundreds of thousands of requests or

00:43:03,040 --> 00:43:06,820
tens of thousands of requests going to

00:43:04,359 --> 00:43:08,320
the system yet to the point where we'll

00:43:06,820 --> 00:43:09,880
have we are getting bottleneck on the

00:43:08,320 --> 00:43:13,210
system resources on the memory resource

00:43:09,880 --> 00:43:15,760
in particular towards B the trade-off of

00:43:13,210 --> 00:43:17,320
that trade-off versus the idea of having

00:43:15,760 --> 00:43:19,930
this one thing where you can just easily

00:43:17,320 --> 00:43:22,089
like test against it's just too good

00:43:19,930 --> 00:43:24,849
it's just too good hinder and so it's

00:43:22,089 --> 00:43:27,160
not good for everybody but I think it is

00:43:24,849 --> 00:43:29,200
very very important useful for us to do

00:43:27,160 --> 00:43:31,210
this now I think everyone tried to touch

00:43:29,200 --> 00:43:33,190
on a little bit in the slides it's is

00:43:31,210 --> 00:43:34,839
that question of whether you can do this

00:43:33,190 --> 00:43:36,280
is heavily dependent on the type of i/o

00:43:34,839 --> 00:43:38,650
you do like we were discussing over

00:43:36,280 --> 00:43:41,260
breakfast the magic example where I

00:43:38,650 --> 00:43:43,089
imagine like for some crazy part of your

00:43:41,260 --> 00:43:44,380
business object you need to get all the

00:43:43,089 --> 00:43:45,520
friends in your network and then the

00:43:44,380 --> 00:43:46,720
Friends of those friends and then the

00:43:45,520 --> 00:43:48,010
friends of those friends and then for

00:43:46,720 --> 00:43:49,599
every call you're loading the entire

00:43:48,010 --> 00:43:51,550
database at the memory like that's

00:43:49,599 --> 00:43:53,619
clearly not a situation that that

00:43:51,550 --> 00:43:54,910
supports there's an interesting angle in

00:43:53,619 --> 00:43:57,940
the sense that that's also a bit of a

00:43:54,910 --> 00:43:59,859
smell right to some extent the amount of

00:43:57,940 --> 00:44:01,660
i/o you have to do here also tells you a

00:43:59,859 --> 00:44:03,790
bit about what craziness is happening in

00:44:01,660 --> 00:44:05,109
your code paths so it's sort of surfaces

00:44:03,790 --> 00:44:07,570
potentially a problem with your

00:44:05,109 --> 00:44:09,820
application in general but yeah it's

00:44:07,570 --> 00:44:12,430
it's not I mean it and I think that's

00:44:09,820 --> 00:44:14,560
what Varun was also talking about if you

00:44:12,430 --> 00:44:16,540
see that you have a specific point where

00:44:14,560 --> 00:44:18,790
one code path might go off and have to

00:44:16,540 --> 00:44:22,150
do a huge amount of stuff then you might

00:44:18,790 --> 00:44:23,859
consider wrapping you know the bit above

00:44:22,150 --> 00:44:24,410
that in one of these constructs I mean

00:44:23,859 --> 00:44:26,210
for me that they

00:44:24,410 --> 00:44:27,620
less'n was like I've grown up like

00:44:26,210 --> 00:44:31,610
writing lots of code which is you know

00:44:27,620 --> 00:44:34,610
get input in and then you know person

00:44:31,610 --> 00:44:36,890
Dao dot save blah somewhere in the

00:44:34,610 --> 00:44:38,870
middle of my function and and the idea

00:44:36,890 --> 00:44:40,400
that instead of doing person Dao dots a

00:44:38,870 --> 00:44:41,750
blind my function and have to mock it

00:44:40,400 --> 00:44:44,120
out and do all that kind of stuff to say

00:44:41,750 --> 00:44:46,160
well the output object of this function

00:44:44,120 --> 00:44:48,260
will be a list of people to save and

00:44:46,160 --> 00:44:51,410
then you can delegate that problem to

00:44:48,260 --> 00:44:53,540
somebody else is a huge benefit in terms

00:44:51,410 --> 00:44:54,860
of keeping your business logic pure and

00:44:53,540 --> 00:44:56,840
making it more testable because then

00:44:54,860 --> 00:44:59,450
instead of having to say like oh did I

00:44:56,840 --> 00:45:01,790
did my mark get cold or the expected

00:44:59,450 --> 00:45:04,130
things Bly just inspect an output value

00:45:01,790 --> 00:45:06,890
it's similar to some sort of CQRS style

00:45:04,130 --> 00:45:08,600
ideas in terms of making commands

00:45:06,890 --> 00:45:10,130
visible and those of you who've been

00:45:08,600 --> 00:45:11,900
fortunate or unfortunate enough to

00:45:10,130 --> 00:45:14,210
listen to a free monad talked something

00:45:11,900 --> 00:45:16,460
like that we'll we'll see similar kind

00:45:14,210 --> 00:45:17,870
of ideas in that in that once once the

00:45:16,460 --> 00:45:20,450
commands that you're trying to do the

00:45:17,870 --> 00:45:21,800
output that you expect becomes just

00:45:20,450 --> 00:45:23,630
objects that you return from your

00:45:21,800 --> 00:45:24,740
function you can do all kinds of

00:45:23,630 --> 00:45:26,420
interesting things with those and don't

00:45:24,740 --> 00:45:33,170
have like peel them out of the back end

00:45:26,420 --> 00:45:38,920
of a database to do something people

00:45:33,170 --> 00:45:38,920
named by fisher was just like warning

00:45:41,299 --> 00:45:47,089
what made you choose to let build your

00:45:43,730 --> 00:45:50,690
own wrapper that produced by errors and

00:45:47,089 --> 00:45:52,249
said this kind of warning excellent

00:45:50,690 --> 00:45:53,869
question so yes there's a couple of

00:45:52,249 --> 00:45:57,049
answers here one is you need to use

00:45:53,869 --> 00:46:00,019
those IDs and we have a very broad range

00:45:57,049 --> 00:46:02,539
of usage of systems I think at least

00:46:00,019 --> 00:46:05,450
half of our Schuyler developers use some

00:46:02,539 --> 00:46:07,579
combination of a text editor and and the

00:46:05,450 --> 00:46:09,920
repple or on the compiler directly so

00:46:07,579 --> 00:46:13,460
difference in that yes

00:46:09,920 --> 00:46:15,650
warnings so you know I always say in my

00:46:13,460 --> 00:46:17,390
in this order we all have of course we

00:46:15,650 --> 00:46:19,819
all have those guidelines you have try

00:46:17,390 --> 00:46:21,109
to use fatal warnings try to avoid any

00:46:19,819 --> 00:46:22,369
warnings from ever appearing in your

00:46:21,109 --> 00:46:25,460
codebase I think by and large we're

00:46:22,369 --> 00:46:27,859
pretty good about that but um yeah I

00:46:25,460 --> 00:46:29,900
think the the the disap mean warnings

00:46:27,859 --> 00:46:32,210
are very blunt instrument usually

00:46:29,900 --> 00:46:34,819
ignored on the one hand if you make them

00:46:32,210 --> 00:46:36,710
all fatal like it can impede your your

00:46:34,819 --> 00:46:38,480
speed quite a lot I think there's

00:46:36,710 --> 00:46:43,910
definitely stuff you can do in terms of

00:46:38,480 --> 00:46:45,339
tuning I think that I'm going run well I

00:46:43,910 --> 00:46:47,390
want to add something to that so

00:46:45,339 --> 00:46:49,849
fundamental warning you're not gonna be

00:46:47,390 --> 00:46:52,069
caught by a bill system right so we do

00:46:49,849 --> 00:46:54,529
one cases like this to fail compilation

00:46:52,069 --> 00:46:56,299
as much as possible but on the other

00:46:54,529 --> 00:46:57,680
hand like as Andrew spoke about it you

00:46:56,299 --> 00:46:59,329
don't want to make it too TSM simen and

00:46:57,680 --> 00:47:00,470
he said actually not too tedious to

00:46:59,329 --> 00:47:02,720
implement you can implement it and you

00:47:00,470 --> 00:47:04,160
can just try and educate people to use

00:47:02,720 --> 00:47:06,680
it everywhere but once you do that is

00:47:04,160 --> 00:47:08,210
you just free place safe this is V paste

00:47:06,680 --> 00:47:10,849
contains with safe contains right and

00:47:08,210 --> 00:47:13,190
that's very easy to do for a potentially

00:47:10,849 --> 00:47:14,930
big benefit that you get and is that it

00:47:13,190 --> 00:47:16,009
is caused by the system it's called by

00:47:14,930 --> 00:47:17,660
the build system and it's not push to

00:47:16,009 --> 00:47:19,880
production and I think another point is

00:47:17,660 --> 00:47:23,119
the warning you actually get is it

00:47:19,880 --> 00:47:25,730
inferred any write the compiler doesn't

00:47:23,119 --> 00:47:27,440
actually doesn't make and like it's

00:47:25,730 --> 00:47:28,970
supposed totally legitimate for you to

00:47:27,440 --> 00:47:30,609
try to do all these operations there's

00:47:28,970 --> 00:47:34,339
nothing wrong with them intrinsically

00:47:30,609 --> 00:47:36,170
the the warning sign is that in order to

00:47:34,339 --> 00:47:38,059
make those operations possible the

00:47:36,170 --> 00:47:40,460
compiler typically has to infer a very

00:47:38,059 --> 00:47:42,200
very basic type and that's the kind of

00:47:40,460 --> 00:47:43,670
thing that you can get warned on but

00:47:42,200 --> 00:47:44,930
depending on how your type hierarchy is

00:47:43,670 --> 00:47:47,680
structured you might not have to go all

00:47:44,930 --> 00:47:49,579
the way to any to make a bad comparison

00:47:47,680 --> 00:47:51,410
like you know you've got the you've got

00:47:49,579 --> 00:47:52,839
the list of tigers and you want to check

00:47:51,410 --> 00:47:55,359
whether penguin is in there

00:47:52,839 --> 00:47:57,969
and if they're both animals then you're

00:47:55,359 --> 00:47:59,440
going to get a warning because it's a

00:47:57,969 --> 00:48:00,910
totally legitimate thing to do in that

00:47:59,440 --> 00:48:03,339
particular business context I mean I

00:48:00,910 --> 00:48:05,829
think the thing the thing that we've

00:48:03,339 --> 00:48:07,900
leveraged this for is also to encode

00:48:05,829 --> 00:48:09,700
what we mean in terms of legitimate

00:48:07,900 --> 00:48:12,069
equalities within the context of our

00:48:09,700 --> 00:48:13,390
domain which a compiler warning will

00:48:12,069 --> 00:48:14,829
never be able to give you because it

00:48:13,390 --> 00:48:17,229
doesn't know anything about your domain

00:48:14,829 --> 00:48:23,229
so I don't think it's fair to expect it

00:48:17,229 --> 00:48:24,640
to do that all right I think we're done

00:48:23,229 --> 00:48:31,120
thank you very much

00:48:24,640 --> 00:48:31,120

YouTube URL: https://www.youtube.com/watch?v=YL0EKxx1Fd0


