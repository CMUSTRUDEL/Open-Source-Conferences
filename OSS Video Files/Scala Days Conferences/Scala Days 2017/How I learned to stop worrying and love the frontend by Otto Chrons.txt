Title: How I learned to stop worrying and love the frontend by Otto Chrons
Publication date: 2017-06-06
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Scala.js brought Scala to web frontend development, relieving developers from many of the idiosyncrasies of JavaScript. As library support for Scala.js keeps maturing, it is becoming a very solid environment for real full-stack web development.

In this talk, you will discover the practices of frontend development in Scala and the benefits it brings. You will also explore the intriguing future of true cross-platform frontend development with Scala.js, Scala for Android and Scala Native for iOS. Scala - the one language to rule them all!
Captions: 
	00:00:01,120 --> 00:00:07,910
so hello everyone my name is Otto and

00:00:04,759 --> 00:00:12,560
I'm here today talking about front-end

00:00:07,910 --> 00:00:17,140
development in in Scala remember to rate

00:00:12,560 --> 00:00:17,140
the sessions with appropriate smiley

00:00:17,560 --> 00:00:24,980
before we begin I'll just do a quick

00:00:21,410 --> 00:00:27,230
introduction Who I am Who I am so during

00:00:24,980 --> 00:00:32,750
the day I work company called Umbra

00:00:27,230 --> 00:00:35,060
where I design and develop our scalable

00:00:32,750 --> 00:00:38,329
cloud computing platform for optimizing

00:00:35,060 --> 00:00:40,820
3d content now you may have not really

00:00:38,329 --> 00:00:44,570
heard of Umbra before but you have

00:00:40,820 --> 00:00:47,690
probably seen other product using our

00:00:44,570 --> 00:00:51,079
technology like the game rime by tequila

00:00:47,690 --> 00:00:54,649
works coming out next month or World of

00:00:51,079 --> 00:00:56,630
Tanks a multiplayer online game or some

00:00:54,649 --> 00:00:59,690
blockbusters like Call of Duty advanced

00:00:56,630 --> 00:01:02,570
warfare infinity warfare and some games

00:00:59,690 --> 00:01:04,670
using really large 3d worlds like The

00:01:02,570 --> 00:01:09,350
Witcher 3 and some of the games like

00:01:04,670 --> 00:01:14,060
doom fallout 4 Final Fantasy 15 disorder

00:01:09,350 --> 00:01:16,609
2 are all using technology reasonably we

00:01:14,060 --> 00:01:18,159
be moving our focus more into the

00:01:16,609 --> 00:01:20,899
virtual reality and augmented reality

00:01:18,159 --> 00:01:23,569
where you have to cram these huge models

00:01:20,899 --> 00:01:26,329
in the small devices that basically are

00:01:23,569 --> 00:01:29,299
powered like a mobile device such as the

00:01:26,329 --> 00:01:31,279
hololens which is now displaying this

00:01:29,299 --> 00:01:34,549
kind of a big castle model that has been

00:01:31,279 --> 00:01:36,590
optimized to the emperor technology the

00:01:34,549 --> 00:01:38,719
umbrella company is growing rapidly and

00:01:36,590 --> 00:01:41,179
we are of course hiring both Scala and

00:01:38,719 --> 00:01:42,369
graphics programmers in our offices in

00:01:41,179 --> 00:01:45,139
Finland

00:01:42,369 --> 00:01:48,349
now during the night I also work in

00:01:45,139 --> 00:01:50,659
Scala but on more like open source

00:01:48,349 --> 00:01:53,229
projects so last year I published

00:01:50,659 --> 00:01:55,969
scholar piddle which is an online

00:01:53,229 --> 00:01:58,189
service where you can just write Scala

00:01:55,969 --> 00:02:00,829
code in the browser which then gets

00:01:58,189 --> 00:02:02,989
compiled to JavaScript and then run

00:02:00,829 --> 00:02:05,630
sprints in your browser so this gives

00:02:02,989 --> 00:02:06,190
you a quick way to try and share and

00:02:05,630 --> 00:02:07,990
even

00:02:06,190 --> 00:02:10,900
that your scholar code without

00:02:07,990 --> 00:02:13,210
installing anything and basically it

00:02:10,900 --> 00:02:15,640
even compiled faster than SBT so for

00:02:13,210 --> 00:02:18,220
some simple stuff it's very good

00:02:15,640 --> 00:02:20,800
I've also authored couple of Scotland's

00:02:18,220 --> 00:02:22,900
colleges libraries such as diode for

00:02:20,800 --> 00:02:25,750
functional application state management

00:02:22,900 --> 00:02:29,140
and Blue Bottle for Supercross binary

00:02:25,750 --> 00:02:31,120
serialization in my tests it's being

00:02:29,140 --> 00:02:35,440
even faster than Google per the box on

00:02:31,120 --> 00:02:37,300
Scala but let's get get back to the

00:02:35,440 --> 00:02:40,810
topic of developing for the front end

00:02:37,300 --> 00:02:42,490
and how scholar fits in that world as we

00:02:40,810 --> 00:02:44,710
all know web front-end is developed

00:02:42,490 --> 00:02:48,700
using javascript so let's talk about

00:02:44,710 --> 00:02:51,190
javascript javascript is like chocolate

00:02:48,700 --> 00:02:52,840
the initial taste is very sweet and you

00:02:51,190 --> 00:02:55,030
get the immediate satisfaction of

00:02:52,840 --> 00:02:58,990
getting things done just by writing

00:02:55,030 --> 00:03:00,850
small blocks of code it's a simple

00:02:58,990 --> 00:03:03,430
language to learn even kids can

00:03:00,850 --> 00:03:05,830
programming JavaScript the tool chain is

00:03:03,430 --> 00:03:07,660
also super simple you - all you need is

00:03:05,830 --> 00:03:10,540
a text editor and the browser to get

00:03:07,660 --> 00:03:12,250
started so when you start developing in

00:03:10,540 --> 00:03:15,190
JavaScript you feel very productive

00:03:12,250 --> 00:03:18,430
right from the start you get to enjoy

00:03:15,190 --> 00:03:20,739
the dynamic typing and all those things

00:03:18,430 --> 00:03:22,390
and you get your first front-end

00:03:20,739 --> 00:03:26,530
application up and running in no time

00:03:22,390 --> 00:03:29,200
yummy then you see that first error in

00:03:26,530 --> 00:03:31,959
your browser console undefined is not a

00:03:29,200 --> 00:03:34,180
function as javascript is not compiled

00:03:31,959 --> 00:03:36,489
in any way all programming errors become

00:03:34,180 --> 00:03:38,170
runtime errors but that's of course

00:03:36,489 --> 00:03:40,269
quick to fix on deploying a new version

00:03:38,170 --> 00:03:43,540
takes almost no time thanks to the

00:03:40,269 --> 00:03:46,239
trivial development pipeline so once

00:03:43,540 --> 00:03:48,730
your application starts growing you want

00:03:46,239 --> 00:03:51,250
to add more features more libraries so

00:03:48,730 --> 00:03:53,010
you can go to the npn register where you

00:03:51,250 --> 00:03:55,630
have access to a quarter million

00:03:53,010 --> 00:03:57,269
JavaScript libraries like left pad and

00:03:55,630 --> 00:04:00,100
so on

00:03:57,269 --> 00:04:03,340
so you don't have to write all your code

00:04:00,100 --> 00:04:04,870
just by yourself it does complicate your

00:04:03,340 --> 00:04:06,850
build process a bit because you have to

00:04:04,870 --> 00:04:08,800
introduce stuff like web pack or babel

00:04:06,850 --> 00:04:12,250
and some other tools but it's it's

00:04:08,800 --> 00:04:14,380
definitely worth it now building large

00:04:12,250 --> 00:04:16,690
JavaScript apps is like building a house

00:04:14,380 --> 00:04:19,190
of cards everything sort of seemingly

00:04:16,690 --> 00:04:21,530
fits together very nicely due to the

00:04:19,190 --> 00:04:23,960
typing we have to be extra careful not

00:04:21,530 --> 00:04:26,720
to make any mistakes that might crash

00:04:23,960 --> 00:04:28,550
your app at runtime especially when you

00:04:26,720 --> 00:04:29,990
come back to your code let's say one

00:04:28,550 --> 00:04:31,880
year later and you want to make some

00:04:29,990 --> 00:04:34,570
changes you notice you have to update

00:04:31,880 --> 00:04:39,260
some libraries because what was hot in

00:04:34,570 --> 00:04:42,560
2016 is obsolete in 2017 and you need to

00:04:39,260 --> 00:04:44,510
swap in a new library but replacing a

00:04:42,560 --> 00:04:46,420
library in JavaScript is not not so easy

00:04:44,510 --> 00:04:49,160
or code base is large enough that

00:04:46,420 --> 00:04:50,930
refactoring because difficult and making

00:04:49,160 --> 00:04:54,080
the wrong change might actually bring

00:04:50,930 --> 00:04:57,020
your codebase crashing down so

00:04:54,080 --> 00:04:59,540
javascript is definitely not safe even

00:04:57,020 --> 00:05:02,330
in the hands of a very experienced

00:04:59,540 --> 00:05:08,930
developer now imagine giving it to

00:05:02,330 --> 00:05:09,500
someone not so experienced it's not not

00:05:08,930 --> 00:05:13,370
so pretty

00:05:09,500 --> 00:05:17,030
I mean enthusiastic maybe but it's not

00:05:13,370 --> 00:05:18,650
enough but you're not there's a lot of

00:05:17,030 --> 00:05:21,230
smart people who have worked around this

00:05:18,650 --> 00:05:23,630
on this problem and they have come to

00:05:21,230 --> 00:05:25,430
the conclusion that while dynamic typing

00:05:23,630 --> 00:05:27,800
is definitely the best thing since like

00:05:25,430 --> 00:05:29,510
bread there are places where static

00:05:27,800 --> 00:05:31,640
typing would actually make sense even in

00:05:29,510 --> 00:05:34,190
JavaScript to catch those errors at

00:05:31,640 --> 00:05:36,440
compile time so enter things like

00:05:34,190 --> 00:05:38,930
typescript from Microsoft or flow from

00:05:36,440 --> 00:05:41,240
Facebook so both of the technologies

00:05:38,930 --> 00:05:44,150
enhanced javascript by introducing an

00:05:41,240 --> 00:05:46,190
optional static typing system on top of

00:05:44,150 --> 00:05:48,290
it so they operate a bit differently

00:05:46,190 --> 00:05:50,240
from each other but in the end your code

00:05:48,290 --> 00:05:53,510
is more pipe safe it's easier to

00:05:50,240 --> 00:05:57,290
understand and to refactor it's much

00:05:53,510 --> 00:05:59,419
more IDE friendly and you can catch most

00:05:57,290 --> 00:06:01,370
of the errors at compile time so

00:05:59,419 --> 00:06:03,410
definitely if you are writing JavaScript

00:06:01,370 --> 00:06:06,470
you definitely consider using typescript

00:06:03,410 --> 00:06:08,900
or flow in your application so

00:06:06,470 --> 00:06:10,580
JavaScript gives a very sweet deal in

00:06:08,900 --> 00:06:14,000
the beginning but for more complex

00:06:10,580 --> 00:06:15,890
applications it doesn't really scale now

00:06:14,000 --> 00:06:18,890
speaking of scaling let's talk about

00:06:15,890 --> 00:06:20,990
scholar so Scala is also programming

00:06:18,890 --> 00:06:23,660
language but it's not like chocolate in

00:06:20,990 --> 00:06:25,790
fact your first encounter with Scala may

00:06:23,660 --> 00:06:27,260
be maybe either slightly bitter and

00:06:25,790 --> 00:06:30,080
complicated taste in your mouth because

00:06:27,260 --> 00:06:32,310
Java because Scala is an acquired taste

00:06:30,080 --> 00:06:36,480
much like a full body

00:06:32,310 --> 00:06:38,220
complex red wine now we all know what

00:06:36,480 --> 00:06:40,530
Scala is but for the benefit of those

00:06:38,220 --> 00:06:42,540
watching this later on video Scala is a

00:06:40,530 --> 00:06:44,070
modern multi partner and language with

00:06:42,540 --> 00:06:45,930
strong driving that lets you write

00:06:44,070 --> 00:06:48,120
programs in the style you want whether

00:06:45,930 --> 00:06:49,590
it's functional programming with its

00:06:48,120 --> 00:06:51,680
object-oriented or functional

00:06:49,590 --> 00:06:54,330
programming or a mixture of these things

00:06:51,680 --> 00:06:56,670
this means that you can get started with

00:06:54,330 --> 00:06:58,710
Scala very easily by utilizing the

00:06:56,670 --> 00:07:01,230
familiar features you already know

00:06:58,710 --> 00:07:08,970
whether you come from JavaScript Java or

00:07:01,230 --> 00:07:10,590
even PHP so it's also expected that in

00:07:08,970 --> 00:07:13,590
the beginning your code is not going to

00:07:10,590 --> 00:07:15,660
be easy idiomatic Scala right away and

00:07:13,590 --> 00:07:18,030
you will be only using like a fraction

00:07:15,660 --> 00:07:20,600
of the features it's probably some

00:07:18,030 --> 00:07:23,640
resembles the code you use to write

00:07:20,600 --> 00:07:25,440
previously and it is fine it gets things

00:07:23,640 --> 00:07:27,180
done and over time you will learn to

00:07:25,440 --> 00:07:29,400
appreciate things like functional

00:07:27,180 --> 00:07:32,910
programming immutability and the

00:07:29,400 --> 00:07:34,980
benefits of strong typing now some

00:07:32,910 --> 00:07:36,900
people criticize Scala for not not being

00:07:34,980 --> 00:07:39,540
pure enough allowing you to write

00:07:36,900 --> 00:07:41,280
imperative code and so on but I think

00:07:39,540 --> 00:07:44,010
that Scala is great for pragmatic

00:07:41,280 --> 00:07:47,280
programmers who want to get the job done

00:07:44,010 --> 00:07:48,560
efficiently and neatly for the purist

00:07:47,280 --> 00:07:55,680
there are other languages out there

00:07:48,560 --> 00:07:57,930
issue their needs so in a sense Gallivan

00:07:55,680 --> 00:08:00,030
incredibly versatile scalable and so the

00:07:57,930 --> 00:08:02,220
language that powers banking systems

00:08:00,030 --> 00:08:04,410
online services like Twitter zalando

00:08:02,220 --> 00:08:06,660
Airbnb and many more but that's all

00:08:04,410 --> 00:08:09,330
back-end stuff and we are interested in

00:08:06,660 --> 00:08:13,310
front-end so what can Scala do in the

00:08:09,330 --> 00:08:17,310
browser as it turns out quite a lot so

00:08:13,310 --> 00:08:19,260
let's talk about Scala Jes so when you

00:08:17,310 --> 00:08:21,510
use college is you are actually writing

00:08:19,260 --> 00:08:23,340
just normal scalar code all the great

00:08:21,510 --> 00:08:25,410
features of Scala

00:08:23,340 --> 00:08:27,360
are there from strong typing the

00:08:25,410 --> 00:08:30,720
extensive standard library and the

00:08:27,360 --> 00:08:33,150
scarlove jes compiler protein basically

00:08:30,720 --> 00:08:34,050
handles all over transformation to

00:08:33,150 --> 00:08:36,540
JavaScript

00:08:34,050 --> 00:08:38,520
it actually takes all your application

00:08:36,540 --> 00:08:40,950
code and library code and performs full

00:08:38,520 --> 00:08:43,050
program optimization and this is very

00:08:40,950 --> 00:08:44,680
crucial because it allows you to write

00:08:43,050 --> 00:08:46,029
idiomatic Scala code

00:08:44,680 --> 00:08:47,770
using all the standard library

00:08:46,029 --> 00:08:49,839
collections and things like that and in

00:08:47,770 --> 00:08:53,140
the end you still get very highly

00:08:49,839 --> 00:08:54,970
optimized code that is right practically

00:08:53,140 --> 00:08:59,260
at the same level as writing native

00:08:54,970 --> 00:09:01,120
JavaScript but these great things don't

00:08:59,260 --> 00:09:03,670
happen without great minds and it also

00:09:01,120 --> 00:09:05,260
holds true with Scala bas so Scala

00:09:03,670 --> 00:09:08,920
jeaious was conceived by this young

00:09:05,260 --> 00:09:11,260
children compare tracker sebastian about

00:09:08,920 --> 00:09:13,209
four years ago he laid the foundations

00:09:11,260 --> 00:09:15,190
for the compiler and started building

00:09:13,209 --> 00:09:16,180
the infrastructure and has been working

00:09:15,190 --> 00:09:18,610
on the project

00:09:16,180 --> 00:09:22,029
ever since he didn't have to work on the

00:09:18,610 --> 00:09:24,970
project alone for that long as in 2014

00:09:22,029 --> 00:09:27,160
Tobias also joined in on the airport so

00:09:24,970 --> 00:09:30,550
these guys are basically the two guys

00:09:27,160 --> 00:09:34,149
who are the core core contributors to

00:09:30,550 --> 00:09:35,470
Scala Jas to this date but to create

00:09:34,149 --> 00:09:37,120
something like you can really use for

00:09:35,470 --> 00:09:39,790
production work you need more than just

00:09:37,120 --> 00:09:41,830
a compiler you need libraries and that's

00:09:39,790 --> 00:09:44,260
basically what how he did and sort of

00:09:41,830 --> 00:09:48,130
single-handedly bootstrapping the whole

00:09:44,260 --> 00:09:50,220
scale of GIS ecosystem and the combined

00:09:48,130 --> 00:09:53,650
efforts of these three guys basically

00:09:50,220 --> 00:09:56,080
made Scala J is what it is today is the

00:09:53,650 --> 00:09:58,810
best platform for developing complex and

00:09:56,080 --> 00:10:00,520
robust front-end applications by no

00:09:58,810 --> 00:10:02,980
scholar jeaious has been stable and

00:10:00,520 --> 00:10:05,470
production ready for over two years and

00:10:02,980 --> 00:10:08,110
it's used by a lot of companies from

00:10:05,470 --> 00:10:10,860
small startups to large enterprises

00:10:08,110 --> 00:10:13,959
powering their complex web front-ends

00:10:10,860 --> 00:10:16,540
so in short college is a stable its

00:10:13,959 --> 00:10:18,850
production ready the compiler and

00:10:16,540 --> 00:10:22,450
libraries are very mature and we'll

00:10:18,850 --> 00:10:24,550
tested it provides extremely good

00:10:22,450 --> 00:10:26,800
developer experience especially if you

00:10:24,550 --> 00:10:29,230
compare it to javascript for creating

00:10:26,800 --> 00:10:31,060
these scalable front-end applications it

00:10:29,230 --> 00:10:32,800
provides an isomorphic development

00:10:31,060 --> 00:10:35,650
environment where you can use the same

00:10:32,800 --> 00:10:37,000
code base both on the server side and in

00:10:35,650 --> 00:10:39,220
the client side as we saw in the

00:10:37,000 --> 00:10:42,100
previous presentation by Holly if you

00:10:39,220 --> 00:10:45,040
happen to see that you can share a lot

00:10:42,100 --> 00:10:47,410
of code structures and even code between

00:10:45,040 --> 00:10:49,630
the front end them in the back end but

00:10:47,410 --> 00:10:51,880
it also has a very good interoperability

00:10:49,630 --> 00:10:53,440
with JavaScript so if you want to use

00:10:51,880 --> 00:10:53,860
JavaScript libraries or you need to use

00:10:53,440 --> 00:10:56,290
them

00:10:53,860 --> 00:10:56,860
then those are easy to be used from from

00:10:56,290 --> 00:10:59,950
the Oscar

00:10:56,860 --> 00:11:03,310
is code and there's a lot of libraries

00:10:59,950 --> 00:11:05,530
out there that already support Scala Jas

00:11:03,310 --> 00:11:08,380
I mean Scala libraries and the ecosystem

00:11:05,530 --> 00:11:10,180
is really great documentation is very

00:11:08,380 --> 00:11:12,340
good and you can get a lot of help from

00:11:10,180 --> 00:11:13,560
different chat channels or Stack

00:11:12,340 --> 00:11:17,440
Overflow

00:11:13,560 --> 00:11:19,330
so really highly recommend it but on the

00:11:17,440 --> 00:11:20,890
front end it's not all about code you

00:11:19,330 --> 00:11:25,240
also have to deal with things like HTML

00:11:20,890 --> 00:11:27,250
and CSS these are traditionally like

00:11:25,240 --> 00:11:30,430
text only things that you have writing

00:11:27,250 --> 00:11:33,370
CSS as a text file HTML as a text file

00:11:30,430 --> 00:11:36,190
or embedded template and so on but with

00:11:33,370 --> 00:11:40,380
Scala JSU actually have libraries that

00:11:36,190 --> 00:11:44,200
offer you like strong strongly typed

00:11:40,380 --> 00:11:46,990
libraries that for for handling HTML and

00:11:44,200 --> 00:11:50,650
CSS such as Scala tags and Scala J's

00:11:46,990 --> 00:11:54,510
dumb and Scala CSS so it sort of makes

00:11:50,650 --> 00:11:57,310
sure that your HTML is probably formed

00:11:54,510 --> 00:11:59,410
for example all of this is just regular

00:11:57,310 --> 00:12:02,080
Scala code you don't need to use any

00:11:59,410 --> 00:12:04,660
separate templating language or work

00:12:02,080 --> 00:12:06,220
with nine text files at all you just get

00:12:04,660 --> 00:12:08,860
to enjoy the full power of the scholar

00:12:06,220 --> 00:12:10,540
language you get the great IDE support

00:12:08,860 --> 00:12:13,570
with all the old completion and error

00:12:10,540 --> 00:12:15,910
checking and and the result is either

00:12:13,570 --> 00:12:18,160
like a tree of Dom objects that you can

00:12:15,910 --> 00:12:21,580
insert into the browser or you can

00:12:18,160 --> 00:12:24,820
render as text as we've done here and

00:12:21,580 --> 00:12:26,590
it's the same for CSS you can use you

00:12:24,820 --> 00:12:28,540
can use scholar variables and all the

00:12:26,590 --> 00:12:31,840
constructs to build the CSS we don't

00:12:28,540 --> 00:12:34,240
need to worry about using less or a CSS

00:12:31,840 --> 00:12:37,240
or these other things that make sort of

00:12:34,240 --> 00:12:39,790
CF is manageable and you can see that

00:12:37,240 --> 00:12:41,740
it's you can use it just like you would

00:12:39,790 --> 00:12:44,650
use CSS you don't even have to invent

00:12:41,740 --> 00:12:47,320
the class names that in CSS are in the

00:12:44,650 --> 00:12:48,970
global scope and can be a source of

00:12:47,320 --> 00:12:53,440
problems but the system will basically

00:12:48,970 --> 00:12:56,560
generate all of these for you now in

00:12:53,440 --> 00:12:58,800
practice however you usually want to

00:12:56,560 --> 00:13:01,180
work with some of some some web

00:12:58,800 --> 00:13:03,550
application framework that works with

00:13:01,180 --> 00:13:05,440
Scala Jas so there are three main

00:13:03,550 --> 00:13:07,780
categories first there are these

00:13:05,440 --> 00:13:09,939
different wrappers around existing

00:13:07,780 --> 00:13:12,669
JavaScript libraries so

00:13:09,939 --> 00:13:15,339
scholar Jes react which is probably one

00:13:12,669 --> 00:13:20,669
of the most popular ones the second

00:13:15,339 --> 00:13:23,289
group is these reactive frameworks that

00:13:20,669 --> 00:13:25,419
propagate changes wire binding

00:13:23,289 --> 00:13:27,970
properties and in the third category you

00:13:25,419 --> 00:13:30,489
have is more complete with application

00:13:27,970 --> 00:13:33,369
frameworks that provide more things than

00:13:30,489 --> 00:13:38,379
just the UI for example RPC and rest

00:13:33,369 --> 00:13:42,519
communication so if we look at scalloped

00:13:38,379 --> 00:13:46,449
J's react a bit closer it's just a sort

00:13:42,519 --> 00:13:48,249
of simple breath while it's not simply

00:13:46,449 --> 00:13:52,869
simple but it's a sort of thin wrap

00:13:48,249 --> 00:13:55,809
around react Jas and it provides type

00:13:52,869 --> 00:13:58,749
safety and supports ap kind of

00:13:55,809 --> 00:14:01,149
programming using using react it also

00:13:58,749 --> 00:14:04,599
comes with a custom router and a lot of

00:14:01,149 --> 00:14:09,220
purely utilities that make help you

00:14:04,599 --> 00:14:12,159
write efficient front-end code what the

00:14:09,220 --> 00:14:14,739
HTML generation is called is react looks

00:14:12,159 --> 00:14:18,459
like looks like is like this basically

00:14:14,739 --> 00:14:21,129
it's pretty similar to Scala tags or JSX

00:14:18,459 --> 00:14:23,739
that you would use in react the angle

00:14:21,129 --> 00:14:25,479
bracket namespace prefixes are optional

00:14:23,739 --> 00:14:29,379
by the way you don't have to use them

00:14:25,479 --> 00:14:32,309
but it gets the benefits of using type

00:14:29,379 --> 00:14:34,899
checking and all those other things

00:14:32,309 --> 00:14:37,419
now binding that Scala and this other

00:14:34,899 --> 00:14:40,229
reactive data binding frameworks work a

00:14:37,419 --> 00:14:43,929
bit differently from react because you

00:14:40,229 --> 00:14:45,729
define properties and variables that are

00:14:43,929 --> 00:14:47,199
sort of lined that when you make a

00:14:45,729 --> 00:14:50,529
change to the property it gets

00:14:47,199 --> 00:14:54,279
automatically distributed to wherever

00:14:50,529 --> 00:14:56,649
you are using that property so it works

00:14:54,279 --> 00:14:59,799
in a sort of similar way that like

00:14:56,649 --> 00:15:03,239
frameworks like angular works it's also

00:14:59,799 --> 00:15:05,949
type safe but it's so much smaller than

00:15:03,239 --> 00:15:07,509
let's say using react because it's all

00:15:05,949 --> 00:15:10,509
all scala and you don't need any

00:15:07,509 --> 00:15:11,970
additional JavaScript libraries for

00:15:10,509 --> 00:15:15,009
example in binding of Scala

00:15:11,970 --> 00:15:18,279
it's using the XML feeds of Scala

00:15:15,009 --> 00:15:21,660
compiler so you can define your HTML by

00:15:18,279 --> 00:15:25,370
writing almost exactly HTML

00:15:21,660 --> 00:15:28,200
you would do in let's say react JSX

00:15:25,370 --> 00:15:32,160
like in this example if something is

00:15:28,200 --> 00:15:34,470
changing changing in a to do object

00:15:32,160 --> 00:15:37,170
let's say the completed then the Dom is

00:15:34,470 --> 00:15:39,300
automatically updated by library just

00:15:37,170 --> 00:15:41,970
the part that needs to be touched so

00:15:39,300 --> 00:15:44,760
it's very efficient as well

00:15:41,970 --> 00:15:47,970
now the frameworks the big frameworks

00:15:44,760 --> 00:15:51,060
like new - provide a more more full web

00:15:47,970 --> 00:15:53,610
application framework than the previous

00:15:51,060 --> 00:15:55,500
ones and it's again like typesafe and

00:15:53,610 --> 00:15:58,500
their data bindings are there so it's

00:15:55,500 --> 00:16:00,810
like a combination of some of the other

00:15:58,500 --> 00:16:03,810
libraries but also has such more

00:16:00,810 --> 00:16:06,660
expensive features like routing and RPC

00:16:03,810 --> 00:16:10,740
and even some UI components on top of

00:16:06,660 --> 00:16:12,720
the basic stuff so internally it's using

00:16:10,740 --> 00:16:15,380
Scala tugs skull italic so it looks

00:16:12,720 --> 00:16:18,150
pretty similar as as we've seen before

00:16:15,380 --> 00:16:20,940
now even with all these great view out

00:16:18,150 --> 00:16:23,400
frameworks available for Scala JSI I

00:16:20,940 --> 00:16:25,500
told them they were not not quite taking

00:16:23,400 --> 00:16:26,280
things far enough so I started this

00:16:25,500 --> 00:16:30,750
project

00:16:26,280 --> 00:16:32,730
suzaku suzaku is is a mobile first web

00:16:30,750 --> 00:16:34,890
application framework within present

00:16:32,730 --> 00:16:36,240
entirely Scala so the goal is that you

00:16:34,890 --> 00:16:38,040
can do everything in scala you don't

00:16:36,240 --> 00:16:39,750
have to worry about the javascript you

00:16:38,040 --> 00:16:42,420
don't even have to know that there's

00:16:39,750 --> 00:16:44,490
javascript underneath and it has a very

00:16:42,420 --> 00:16:46,770
straightforward value proposition so

00:16:44,490 --> 00:16:48,750
that suzaku helps developers great

00:16:46,770 --> 00:16:51,510
beautiful functional efficient

00:16:48,750 --> 00:16:54,690
applications for mobile and desktop web

00:16:51,510 --> 00:16:58,020
it's easy and fun and safe to use and

00:16:54,690 --> 00:17:00,630
lets developer work purely in scala now

00:16:58,020 --> 00:17:03,900
one of the rationales behind Suzaku is

00:17:00,630 --> 00:17:06,030
is mobile performance as we know mobile

00:17:03,900 --> 00:17:09,000
devices are becoming more and more

00:17:06,030 --> 00:17:11,340
common everybody has one and a lot of

00:17:09,000 --> 00:17:13,290
lot of the web usage is moving to the

00:17:11,340 --> 00:17:15,300
mobile so you have to make sure that

00:17:13,290 --> 00:17:17,010
things work nicely there it's a very

00:17:15,300 --> 00:17:20,220
constructive environment compared to

00:17:17,010 --> 00:17:23,580
desktop you have poor connectivity the

00:17:20,220 --> 00:17:25,590
screen size is small the CPUs are not as

00:17:23,580 --> 00:17:28,890
powerful we have to be careful about

00:17:25,590 --> 00:17:31,140
saving battery life and so on so

00:17:28,890 --> 00:17:33,100
although mobile CPUs have limited

00:17:31,140 --> 00:17:36,520
horsepower they do have to

00:17:33,100 --> 00:17:38,530
or for course but most web apps don't

00:17:36,520 --> 00:17:40,740
really take advantage of this because

00:17:38,530 --> 00:17:43,510
JavaScript of course is inherently

00:17:40,740 --> 00:17:46,150
single-threaded so just this week

00:17:43,510 --> 00:17:49,419
Facebook launched a total rewrite of

00:17:46,150 --> 00:17:52,360
their react library called react fibre

00:17:49,419 --> 00:17:54,400
nowadays to address these performance

00:17:52,360 --> 00:17:56,890
issues especially on mobile that they

00:17:54,400 --> 00:17:59,950
have with react and you know why it's

00:17:56,890 --> 00:18:01,900
called fibre because they heard a doc to

00:17:59,950 --> 00:18:06,070
say that fiber is good if your UI is

00:18:01,900 --> 00:18:08,730
constipated but since I could take a bit

00:18:06,070 --> 00:18:11,320
different approach in its architecture

00:18:08,730 --> 00:18:14,020
because it's designed for multiple cores

00:18:11,320 --> 00:18:15,940
what it means in practice is that the UI

00:18:14,020 --> 00:18:18,490
and the application are running on

00:18:15,940 --> 00:18:21,610
different cores using technology called

00:18:18,490 --> 00:18:23,950
web web worker and the immediate benefit

00:18:21,610 --> 00:18:26,880
of this design is that the UI stays

00:18:23,950 --> 00:18:28,990
responsive and this is basically what

00:18:26,880 --> 00:18:30,700
Facebook means that react has a

00:18:28,990 --> 00:18:32,740
performance problem is that the

00:18:30,700 --> 00:18:34,960
responsiveness of the UI is suffering

00:18:32,740 --> 00:18:37,659
because whatever you are doing the UI is

00:18:34,960 --> 00:18:39,400
running the same thread and it's bits

00:18:37,659 --> 00:18:41,679
blocking animations and things like I

00:18:39,400 --> 00:18:43,990
think things like that so with suzaku

00:18:41,679 --> 00:18:45,669
that problem goes away because the UI is

00:18:43,990 --> 00:18:47,679
is running independently of your

00:18:45,669 --> 00:18:49,570
application so no matter what you are

00:18:47,679 --> 00:18:53,110
doing in the application the UI always

00:18:49,570 --> 00:18:56,080
feels responsive and suzaku also makes

00:18:53,110 --> 00:18:58,120
it easy to use even more force if you

00:18:56,080 --> 00:19:06,309
have to do let's say more heavy

00:18:58,120 --> 00:19:07,960
background tasks so in the browser you

00:19:06,309 --> 00:19:10,870
don't really have threads you have these

00:19:07,960 --> 00:19:14,320
things called web workers they are more

00:19:10,870 --> 00:19:17,169
like sort of independent processes

00:19:14,320 --> 00:19:18,640
because they don't share memory so the

00:19:17,169 --> 00:19:20,650
only way to communicate between web

00:19:18,640 --> 00:19:23,230
workers is to post messages back and

00:19:20,650 --> 00:19:26,169
forth and these messages can be

00:19:23,230 --> 00:19:29,770
JavaScript objects strings for binary

00:19:26,169 --> 00:19:32,020
data of which the last option the binary

00:19:29,770 --> 00:19:34,630
data works best with Scala GS because we

00:19:32,020 --> 00:19:37,659
can use a sort of utilized efficient

00:19:34,630 --> 00:19:40,480
binary serialization provided by

00:19:37,659 --> 00:19:42,160
libraries like Google of course the use

00:19:40,480 --> 00:19:44,710
of serialization and

00:19:42,160 --> 00:19:47,170
these messages back and forth introduces

00:19:44,710 --> 00:19:48,550
some overhead but the benefit of

00:19:47,170 --> 00:19:51,990
utilizing these multiple course

00:19:48,550 --> 00:19:54,010
definitely outweighs my wide margin

00:19:51,990 --> 00:19:58,600
especially from the user experience

00:19:54,010 --> 00:20:01,510
point of view to make the communication

00:19:58,600 --> 00:20:04,330
easier and typesafe Seussical utilizes

00:20:01,510 --> 00:20:07,330
this virtual channel system provided by

00:20:04,330 --> 00:20:09,910
the arteria library and other library I

00:20:07,330 --> 00:20:12,100
created basically for this project so

00:20:09,910 --> 00:20:13,810
our theoria hides the underlining plum

00:20:12,100 --> 00:20:17,200
plumbing and clear gives you a clear

00:20:13,810 --> 00:20:20,290
types a protocol for sending messages

00:20:17,200 --> 00:20:22,570
between the UI and the application for

00:20:20,290 --> 00:20:25,690
example it's visible widget in the UI

00:20:22,570 --> 00:20:29,290
has its own channel to do this to do

00:20:25,690 --> 00:20:31,450
this communication over now in suzaku

00:20:29,290 --> 00:20:33,970
there's a very strict division of labor

00:20:31,450 --> 00:20:36,550
between what what happens in the UI and

00:20:33,970 --> 00:20:38,980
in the application in the UI you of

00:20:36,550 --> 00:20:41,410
course handle all the interaction when

00:20:38,980 --> 00:20:44,410
the user is clicking something or typing

00:20:41,410 --> 00:20:46,770
something or selecting something all the

00:20:44,410 --> 00:20:49,390
rendering happens there naturally

00:20:46,770 --> 00:20:50,890
animations so your application doesn't

00:20:49,390 --> 00:20:53,310
have to worry about the animations they

00:20:50,890 --> 00:20:56,070
are all handled by the UI thread

00:20:53,310 --> 00:20:58,300
transitions from one view to another an

00:20:56,070 --> 00:21:01,690
expansion of components let's say you

00:20:58,300 --> 00:21:03,880
have a drop-down or time picker and all

00:21:01,690 --> 00:21:07,780
these things that happen only on the UI

00:21:03,880 --> 00:21:10,630
side are kept in the UI side and as you

00:21:07,780 --> 00:21:13,450
can see this first letters letters spell

00:21:10,630 --> 00:21:15,670
irate which is a description of how you

00:21:13,450 --> 00:21:17,890
feel when you have to deal deal with all

00:21:15,670 --> 00:21:21,160
this so the point of suzaku is trying to

00:21:17,890 --> 00:21:23,140
isolate all that so for example if you

00:21:21,160 --> 00:21:25,150
have to deal with JavaScript this is the

00:21:23,140 --> 00:21:28,120
place you have to deal with on the

00:21:25,150 --> 00:21:29,830
application side you don't on the

00:21:28,120 --> 00:21:33,310
application side it's of course the data

00:21:29,830 --> 00:21:36,430
model where where everything the state

00:21:33,310 --> 00:21:38,970
of application lives the presentation

00:21:36,430 --> 00:21:41,920
you describe that what you want to show

00:21:38,970 --> 00:21:43,720
in the application you handle the

00:21:41,920 --> 00:21:45,910
navigation that ok you want to switch

00:21:43,720 --> 00:21:47,770
gears you want to go to some other other

00:21:45,910 --> 00:21:50,380
part of the application you do

00:21:47,770 --> 00:21:52,120
validation form input those kind of

00:21:50,380 --> 00:21:54,580
things and of course communication

00:21:52,120 --> 00:21:57,100
between the backend

00:21:54,580 --> 00:22:01,030
and here the first letters spell

00:21:57,100 --> 00:22:08,650
different which is which is like polish

00:22:01,030 --> 00:22:11,110
for lovely well not not really so the

00:22:08,650 --> 00:22:13,630
prodigal message channel based approach

00:22:11,110 --> 00:22:16,780
opens like more avenues than just doing

00:22:13,630 --> 00:22:18,850
web web development so what if your

00:22:16,780 --> 00:22:21,960
mobile web application could also be

00:22:18,850 --> 00:22:24,490
compiled to native Android or iOS

00:22:21,960 --> 00:22:29,500
application instead or as a desktop

00:22:24,490 --> 00:22:31,960
application much like electron makes

00:22:29,500 --> 00:22:33,730
possible for poor JavaScript because

00:22:31,960 --> 00:22:35,620
suzer go has been designed to work in a

00:22:33,730 --> 00:22:38,200
cross-platform environment from the

00:22:35,620 --> 00:22:39,910
get-go so separating the application

00:22:38,200 --> 00:22:42,120
vote from the platform specific

00:22:39,910 --> 00:22:44,860
implementation makes it possible that

00:22:42,120 --> 00:22:48,700
you can do things like in react native

00:22:44,860 --> 00:22:50,740
it is that except that instead of having

00:22:48,700 --> 00:22:53,830
JavaScript around there you can actually

00:22:50,740 --> 00:22:57,640
have like fully native Scala JBM base

00:22:53,830 --> 00:23:00,760
android client and if once one scala

00:22:57,640 --> 00:23:02,650
native scholar GB and JVM based android

00:23:00,760 --> 00:23:04,840
client so once Scala native gets there

00:23:02,650 --> 00:23:07,240
with iOS support then it's also possible

00:23:04,840 --> 00:23:09,250
to build native iOS applications that

00:23:07,240 --> 00:23:11,440
are truly native not something that's

00:23:09,250 --> 00:23:15,100
running JavaScript inside the

00:23:11,440 --> 00:23:17,140
application initially of course we are

00:23:15,100 --> 00:23:19,450
just targeting web that's easiest one

00:23:17,140 --> 00:23:21,760
but Android is probably following quite

00:23:19,450 --> 00:23:24,400
soon because this this it's already

00:23:21,760 --> 00:23:30,370
possible to do Scala applications on on

00:23:24,400 --> 00:23:32,980
Android so testing becomes also a lot

00:23:30,370 --> 00:23:34,450
easier because when you have the UI and

00:23:32,980 --> 00:23:36,880
application separated by this

00:23:34,450 --> 00:23:39,880
well-defined protocol then you can sort

00:23:36,880 --> 00:23:44,170
of throw away the UI and just take it

00:23:39,880 --> 00:23:46,600
with a like a headless test test UI

00:23:44,170 --> 00:23:49,420
that you can then control from your

00:23:46,600 --> 00:23:52,210
application so you don't have to do that

00:23:49,420 --> 00:23:54,160
kind of real UI testing and one

00:23:52,210 --> 00:23:56,110
interesting part of this protocol is

00:23:54,160 --> 00:23:57,910
also that you can really separate the

00:23:56,110 --> 00:24:00,640
application like of course this whole

00:23:57,910 --> 00:24:03,400
idea is old like X Window System has

00:24:00,640 --> 00:24:06,100
been using this from 1984 or something

00:24:03,400 --> 00:24:08,160
so it's not like a new thing to separate

00:24:06,100 --> 00:24:10,680
application and the UI that's

00:24:08,160 --> 00:24:12,540
that's rendering it but it also enables

00:24:10,680 --> 00:24:15,150
things like you can actually run the

00:24:12,540 --> 00:24:17,250
application on your server and have the

00:24:15,150 --> 00:24:19,830
UI only on the client so this kind of

00:24:17,250 --> 00:24:21,690
very thin client approach if that's

00:24:19,830 --> 00:24:26,220
something you want might be great for

00:24:21,690 --> 00:24:29,460
debugging some things so the UI is

00:24:26,220 --> 00:24:31,440
defined pretty similar as in react or

00:24:29,460 --> 00:24:34,290
react native you have this descriptive

00:24:31,440 --> 00:24:36,090
render method where you just describe it

00:24:34,290 --> 00:24:38,400
okay this is this is the kind of UI I

00:24:36,090 --> 00:24:40,170
want these are the components these are

00:24:38,400 --> 00:24:44,850
the widgets that should be there and

00:24:40,170 --> 00:24:47,180
then it's it's basically the job of the

00:24:44,850 --> 00:24:49,830
suzaku framework to figure out that okay

00:24:47,180 --> 00:24:52,530
what's what's in there right now and

00:24:49,830 --> 00:24:55,620
what was there before and then do the

00:24:52,530 --> 00:24:57,810
calculations and the complex sort of

00:24:55,620 --> 00:25:00,180
figuring out that okay what has actually

00:24:57,810 --> 00:25:02,820
changed that what what should what what

00:25:00,180 --> 00:25:05,910
should we do with the Dom to actually

00:25:02,820 --> 00:25:08,100
get get get the result that that the

00:25:05,910 --> 00:25:13,020
user is is currently one currently

00:25:08,100 --> 00:25:15,570
wanting and this piece of sort of diff

00:25:13,020 --> 00:25:17,790
diffing engine is sort of similar to

00:25:15,570 --> 00:25:20,310
what you have in react except in react

00:25:17,790 --> 00:25:22,380
you have to deal with a virtual Dom so

00:25:20,310 --> 00:25:24,690
you have to deal with individual Dom

00:25:22,380 --> 00:25:27,330
elements and the whole Dom tree but

00:25:24,690 --> 00:25:29,430
because in suzaku you don't need you

00:25:27,330 --> 00:25:31,800
don't have anything to do with HTML and

00:25:29,430 --> 00:25:34,050
CSS in your application it's all hidden

00:25:31,800 --> 00:25:36,300
in the UI so it's much higher level

00:25:34,050 --> 00:25:38,400
components higher level widgets that the

00:25:36,300 --> 00:25:40,200
diffing algorithm has to deal with so

00:25:38,400 --> 00:25:45,570
it's it's much more efficient in that

00:25:40,200 --> 00:25:49,380
sense now suzaku is also using diode

00:25:45,570 --> 00:25:51,330
well it's not exactly using there's no

00:25:49,380 --> 00:25:53,370
strict dependency but but the

00:25:51,330 --> 00:25:55,140
application model is sort of built

00:25:53,370 --> 00:25:57,390
around the same kind of idea that you

00:25:55,140 --> 00:26:00,570
have this application state somewhere

00:25:57,390 --> 00:26:02,250
that that you're more modifying and then

00:26:00,570 --> 00:26:05,640
creating new application state which

00:26:02,250 --> 00:26:07,530
then reflects the UI and so on so having

00:26:05,640 --> 00:26:10,650
your audio application state in this

00:26:07,530 --> 00:26:12,480
single immutable model promotes clarity

00:26:10,650 --> 00:26:15,960
in your code and makes it a lot easier

00:26:12,480 --> 00:26:17,640
to reason about in diode the application

00:26:15,960 --> 00:26:19,480
sort of revolves around this circuit

00:26:17,640 --> 00:26:23,380
which is handling the

00:26:19,480 --> 00:26:26,020
coming actions and then actions through

00:26:23,380 --> 00:26:28,060
the surrogate modify the model and then

00:26:26,020 --> 00:26:30,700
the views are reading model and then

00:26:28,060 --> 00:26:33,280
when there's user interaction the views

00:26:30,700 --> 00:26:35,230
create these actions that again modify

00:26:33,280 --> 00:26:37,060
the model and so on there is also a

00:26:35,230 --> 00:26:39,700
simple effect system for things like

00:26:37,060 --> 00:26:42,880
Network communication that you can start

00:26:39,700 --> 00:26:44,950
loading something and when when when the

00:26:42,880 --> 00:26:46,960
loading is done then again inaction is

00:26:44,950 --> 00:26:49,510
dispatched and that then updates the

00:26:46,960 --> 00:26:52,800
model and so on and it helps in testing

00:26:49,510 --> 00:26:55,570
because with with the effect sort of

00:26:52,800 --> 00:27:01,870
separated then you can just go ahead and

00:26:55,570 --> 00:27:03,820
ignore them in your tests if you want so

00:27:01,870 --> 00:27:07,360
the long-term goals for Sousa who are

00:27:03,820 --> 00:27:09,190
many contributors it's easy to double

00:27:07,360 --> 00:27:12,070
the size of contributors by just

00:27:09,190 --> 00:27:14,530
introducing another contributor at this

00:27:12,070 --> 00:27:16,360
point of time but I think this is quite

00:27:14,530 --> 00:27:18,100
crucial for a lot of these libraries

00:27:16,360 --> 00:27:21,010
because typically all these libraries

00:27:18,100 --> 00:27:23,650
have like one person doing all the work

00:27:21,010 --> 00:27:25,360
and that's true not just for Scala J's

00:27:23,650 --> 00:27:27,730
you are libraries but for like most

00:27:25,360 --> 00:27:29,290
libraries but it's it's difficult to get

00:27:27,730 --> 00:27:31,810
like real contributors who are

00:27:29,290 --> 00:27:34,510
understand the underlying mechanisms are

00:27:31,810 --> 00:27:37,030
able to really contribute on all things

00:27:34,510 --> 00:27:39,240
but because suzaku is is having like

00:27:37,030 --> 00:27:41,890
very high modularity there's a lot of

00:27:39,240 --> 00:27:44,830
interface area where you can do these

00:27:41,890 --> 00:27:46,800
contributions and it's easier to get get

00:27:44,830 --> 00:27:51,070
started let's say somebody wants to do

00:27:46,800 --> 00:27:53,110
the Android from the end for Suzaku it's

00:27:51,070 --> 00:27:54,970
it's totally super thing it does nothing

00:27:53,110 --> 00:27:57,340
to do with the core and so on so it's

00:27:54,970 --> 00:27:59,380
it's easier to get started

00:27:57,340 --> 00:28:00,760
one thing that's quite crucial is also

00:27:59,380 --> 00:28:02,350
the internationalization and

00:28:00,760 --> 00:28:04,750
localization because we are dealing with

00:28:02,350 --> 00:28:06,390
with the user interface and these again

00:28:04,750 --> 00:28:09,100
something that most libraries just

00:28:06,390 --> 00:28:12,130
sidestepped that ok it's all led to the

00:28:09,100 --> 00:28:15,070
user all left to the developers handle

00:28:12,130 --> 00:28:18,250
these kind of things but Suzaku aims to

00:28:15,070 --> 00:28:20,260
have good support for for these as well

00:28:18,250 --> 00:28:23,440
and of course having great documentation

00:28:20,260 --> 00:28:25,750
with examples it is again very crucial

00:28:23,440 --> 00:28:28,570
thing for for sex success of any library

00:28:25,750 --> 00:28:31,870
that you want want people to be able to

00:28:28,570 --> 00:28:32,770
get get going very quickly and in the

00:28:31,870 --> 00:28:35,560
end

00:28:32,770 --> 00:28:39,010
it to be just the best cross-platform UI

00:28:35,560 --> 00:28:40,690
very more regardless of what Facebook

00:28:39,010 --> 00:28:44,170
and these are the small players might be

00:28:40,690 --> 00:28:46,510
doing in the same space because we know

00:28:44,170 --> 00:28:48,310
that we are using scholar language they

00:28:46,510 --> 00:28:52,210
are using javascript so we already have

00:28:48,310 --> 00:28:55,120
great edge on our on our side in that

00:28:52,210 --> 00:28:57,820
sense but of course currently if that is

00:28:55,120 --> 00:29:00,670
status still very experimental you can

00:28:57,820 --> 00:29:02,860
go to github download the source code

00:29:00,670 --> 00:29:04,210
there is not very much documentation yet

00:29:02,860 --> 00:29:07,870
because a lot of things are still

00:29:04,210 --> 00:29:11,380
changing quite rapidly hopefully we can

00:29:07,870 --> 00:29:13,630
get like a beta release out and you know

00:29:11,380 --> 00:29:16,390
in during during this summer let's see

00:29:13,630 --> 00:29:18,220
how that goes but definitely it's it's

00:29:16,390 --> 00:29:20,770
in that sense ready that you can already

00:29:18,220 --> 00:29:23,410
do simple simple things and it will

00:29:20,770 --> 00:29:25,960
update the UI and you can have you can

00:29:23,410 --> 00:29:27,310
have interact interaction there and so

00:29:25,960 --> 00:29:28,960
the sort of basic basic core

00:29:27,310 --> 00:29:33,670
functionality is there but there's still

00:29:28,960 --> 00:29:35,920
a lot of lot of features missing but

00:29:33,670 --> 00:29:38,410
yeah I think it's almost time to get

00:29:35,920 --> 00:29:40,180
started on the important things which is

00:29:38,410 --> 00:29:42,630
drinking and so I'm just going to say

00:29:40,180 --> 00:29:42,630
thank you

00:29:47,300 --> 00:29:54,540
so any questions hey so uh when you talk

00:29:52,080 --> 00:29:58,620
about isomorphism between the server

00:29:54,540 --> 00:30:02,550
side and the front end the focus seems

00:29:58,620 --> 00:30:05,430
to have been on the code various

00:30:02,550 --> 00:30:09,630
presentations I've seen so uh is there

00:30:05,430 --> 00:30:12,920
any consideration to isomorphism on the

00:30:09,630 --> 00:30:15,210
data side like you would have in a full

00:30:12,920 --> 00:30:17,970
JavaScript based stack you know where

00:30:15,210 --> 00:30:23,070
actually the data exchange format is

00:30:17,970 --> 00:30:26,100
JSON and taking this one step further so

00:30:23,070 --> 00:30:28,320
was you know Scala supports embedded XML

00:30:26,100 --> 00:30:30,390
wouldn't it be cool if Scala supported

00:30:28,320 --> 00:30:33,150
embedded JSON then this would be like a

00:30:30,390 --> 00:30:34,830
des at another level I think they

00:30:33,150 --> 00:30:37,710
typically when you are dealing with JSON

00:30:34,830 --> 00:30:40,860
you use serialization from case classes

00:30:37,710 --> 00:30:42,810
back and forth to JSON so the question I

00:30:40,860 --> 00:30:46,440
think this is really that do you need to

00:30:42,810 --> 00:30:49,290
expose a JSON API that is being used by

00:30:46,440 --> 00:30:51,060
someone else than your own scholar

00:30:49,290 --> 00:30:52,980
front-end because if you are just

00:30:51,060 --> 00:30:55,290
dealing with your own code base that you

00:30:52,980 --> 00:30:58,290
have Scala on both sides then you can

00:30:55,290 --> 00:31:00,450
use binary binary protocols or whatever

00:30:58,290 --> 00:31:03,570
but I think that JSON thing comes to

00:31:00,450 --> 00:31:05,550
play when you need to deal with like

00:31:03,570 --> 00:31:09,570
exposing a public API or things like

00:31:05,550 --> 00:31:13,490
that but yeah so both both things work

00:31:09,570 --> 00:31:13,490
any other questions

00:31:13,670 --> 00:31:19,470
it was clear as day presentation now you

00:31:17,460 --> 00:31:22,670
just go and download the source code and

00:31:19,470 --> 00:31:27,910
start hacking okay thank you

00:31:22,670 --> 00:31:27,910

YouTube URL: https://www.youtube.com/watch?v=nfCGdbfiJGU


