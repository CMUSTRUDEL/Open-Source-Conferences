Title: Keynote - What's Different In Dotty by Martin Odersky
Publication date: 2017-06-02
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Dotty is the project name for the next iteration of the Scala language. As we are nearing a first developer preview, this talk will give a summary of the major changes and innovations as they are currently implemented. I will show with many examples how you can increase the legibility and safety of your Scala programs using the new features.
Captions: 
	00:00:00,030 --> 00:00:08,429
okay good so well I'm here to talk about

00:00:06,330 --> 00:00:12,719
what's different in ducky

00:00:08,429 --> 00:00:17,970
so they today actually we have our first

00:00:12,719 --> 00:00:20,760
release of Dottie out that's 0 1 2 RC 1

00:00:17,970 --> 00:00:22,740
and that's a technology preview that

00:00:20,760 --> 00:00:24,960
demonstrates the new language features

00:00:22,740 --> 00:00:27,170
and a new compiler infrastructure

00:00:24,960 --> 00:00:29,910
supporting them so Dottie is essentially

00:00:27,170 --> 00:00:33,950
Scala reloaded the next iteration of

00:00:29,910 --> 00:00:38,190
Scala and what you have there in this

00:00:33,950 --> 00:00:40,110
preview is a new compiler called dot C

00:00:38,190 --> 00:00:42,809
on which I I and my team have been

00:00:40,110 --> 00:00:46,590
working on for more than four years now

00:00:42,809 --> 00:00:49,770
a repo which is still somewhat proof of

00:00:46,590 --> 00:00:52,860
concept called I doc tool a plug-in to

00:00:49,770 --> 00:00:55,770
use the tool to change from SBT and also

00:00:52,860 --> 00:01:09,330
an IDE so let's just have a quick look

00:00:55,770 --> 00:01:12,890
at what this gives just well and ok ok

00:01:09,330 --> 00:01:12,890
so if we look at

00:01:17,400 --> 00:01:25,660
yeah well I guess I I wanted to have

00:01:22,900 --> 00:01:28,960
them maybe I we have to do without the

00:01:25,660 --> 00:01:32,110
internet thing yeah okay let me just get

00:01:28,960 --> 00:01:36,310
back to the presentation skip that sorry

00:01:32,110 --> 00:01:41,350
about that okay so but one thing I can

00:01:36,310 --> 00:01:45,390
show you is the IDE integration let me

00:01:41,350 --> 00:01:48,610
do that I know it's done now so

00:01:45,390 --> 00:01:51,630
everything is crashed now of course yeah

00:01:48,610 --> 00:01:55,000
okay so let me see what we can do here

00:01:51,630 --> 00:01:55,990
now okay I'll go back to the talk and

00:01:55,000 --> 00:01:58,840
we'll do it without it

00:01:55,990 --> 00:02:01,660
sorry about that it's I never had a

00:01:58,840 --> 00:02:05,050
disaster like this for a talk complete

00:02:01,660 --> 00:02:07,060
and utter disaster before okay so we do

00:02:05,050 --> 00:02:12,459
only from there from the slides so it

00:02:07,060 --> 00:02:14,800
has an IDE the IDE is in vs code it

00:02:12,459 --> 00:02:18,850
implements the microsoft language server

00:02:14,800 --> 00:02:21,400
protocol it has the usual things command

00:02:18,850 --> 00:02:23,340
completion hyper linking error reporting

00:02:21,400 --> 00:02:26,500
life error reporting and so on and

00:02:23,340 --> 00:02:29,019
what's notable about that idea is that

00:02:26,500 --> 00:02:30,970
the compiler the regular compilers also

00:02:29,019 --> 00:02:32,680
the presentation compiler backing the

00:02:30,970 --> 00:02:35,530
protocol so there's not not a separate

00:02:32,680 --> 00:02:37,900
compiler in that sense it's similar to

00:02:35,530 --> 00:02:40,360
what you see in enzyme and in Eclipse

00:02:37,900 --> 00:02:42,580
for the current Scala C IDE and the

00:02:40,360 --> 00:02:45,100
difference is that there's really a very

00:02:42,580 --> 00:02:47,410
well defined protocol within JSON

00:02:45,100 --> 00:02:49,330
between essentially an arbitrary

00:02:47,410 --> 00:02:52,000
front-end and now this presentation

00:02:49,330 --> 00:02:54,190
compiler that does all the services that

00:02:52,000 --> 00:02:56,470
you have to do to explore what your

00:02:54,190 --> 00:02:59,769
program is and that means that besides

00:02:56,470 --> 00:03:02,650
vs code there's also already something

00:02:59,769 --> 00:03:05,049
existing for Emacs and there will be

00:03:02,650 --> 00:03:07,299
soon hopefully things for eclipse and

00:03:05,049 --> 00:03:09,549
enzyme and potentially for many more

00:03:07,299 --> 00:03:11,620
front ends also that's not the only

00:03:09,549 --> 00:03:14,410
effort for i des I should also mention

00:03:11,620 --> 00:03:17,829
the dirty mount mode in IntelliJ that's

00:03:14,410 --> 00:03:19,600
also being worked on and so you will

00:03:17,829 --> 00:03:21,940
have a choice than to use either

00:03:19,600 --> 00:03:26,060
IntelliJ or vs code or one of these

00:03:21,940 --> 00:03:28,520
other front ends so what's the

00:03:26,060 --> 00:03:31,069
roadmap for this whole thing's how does

00:03:28,520 --> 00:03:38,980
Dottie fit in the grand scheme of things

00:03:31,069 --> 00:03:43,700
so we are now here in 2017 and the so

00:03:38,980 --> 00:03:47,300
you have here it's got a two 12.01 just

00:03:43,700 --> 00:03:49,160
got released what we will do in the next

00:03:47,300 --> 00:03:51,980
years is essentially a parallel

00:03:49,160 --> 00:03:54,640
development of both the Scala two branch

00:03:51,980 --> 00:03:56,090
that you see here and the Dottie branch

00:03:54,640 --> 00:03:59,600
to branch

00:03:56,090 --> 00:04:00,739
the next version should be out in early

00:03:59,600 --> 00:04:05,120
00:04:00,739 --> 00:04:07,580
at Saqqara 2:13 and Dottie will be much

00:04:05,120 --> 00:04:11,030
more rapid iteration continuous

00:04:07,580 --> 00:04:13,849
development but they will share one

00:04:11,030 --> 00:04:15,560
thing and that's the rework on

00:04:13,849 --> 00:04:18,680
collections that we are currently doing

00:04:15,560 --> 00:04:20,870
the standard library collections so that

00:04:18,680 --> 00:04:23,750
if that is successful will be part of

00:04:20,870 --> 00:04:27,680
2:13 and it will also be essentially the

00:04:23,750 --> 00:04:31,160
standard library of Dottie then on the

00:04:27,680 --> 00:04:34,400
scanner side what we plan is a version

00:04:31,160 --> 00:04:36,940
214 which maybe if things are still a

00:04:34,400 --> 00:04:39,050
little bit wait will have the Tastee

00:04:36,940 --> 00:04:41,600
interchange format that's the type

00:04:39,050 --> 00:04:43,789
abstract syntax trees on which Dottie is

00:04:41,600 --> 00:04:46,940
built and on which also for instance the

00:04:43,789 --> 00:04:49,250
IDE is built and so essentially that's

00:04:46,940 --> 00:04:53,600
going forward essentially our standard

00:04:49,250 --> 00:04:56,539
way to ship scholar programs not just as

00:04:53,600 --> 00:05:00,440
API definitions but as whole trees

00:04:56,539 --> 00:05:02,690
highly compactify tall trees and if

00:05:00,440 --> 00:05:04,780
tasty gets integrated there's also a

00:05:02,690 --> 00:05:08,210
chance to actually get the middle end

00:05:04,780 --> 00:05:11,210
that means the whole bunch of compiler

00:05:08,210 --> 00:05:14,270
transformation phases that we have

00:05:11,210 --> 00:05:17,479
essentially redone from scratch in a

00:05:14,270 --> 00:05:18,950
much more Intel intelligible way in a

00:05:17,479 --> 00:05:21,320
much more understandable way in Dottie

00:05:18,950 --> 00:05:23,870
because what used to be a couple of

00:05:21,320 --> 00:05:27,500
humongous phases that did many things at

00:05:23,870 --> 00:05:29,900
once are now split into more than 60

00:05:27,500 --> 00:05:31,639
mini phases that essentially do one

00:05:29,900 --> 00:05:36,320
thing and do one thing in a very

00:05:31,639 --> 00:05:38,840
controlled manner over the years with

00:05:36,320 --> 00:05:40,120
the Dottie releases we foresee that at

00:05:38,840 --> 00:05:42,430
some point in the

00:05:40,120 --> 00:05:46,510
next year's not next year but at some

00:05:42,430 --> 00:05:48,820
point later that will be scholar 3.0 so

00:05:46,510 --> 00:05:52,060
how we gonna iterate dirty until it

00:05:48,820 --> 00:05:55,419
becomes scholar 3.0 well what we want to

00:05:52,060 --> 00:05:58,240
do is essentially take a inspiration

00:05:55,419 --> 00:06:01,300
from the way rust currently works and

00:05:58,240 --> 00:06:04,479
that's using a time-based releases with

00:06:01,300 --> 00:06:07,830
the Train model so the idea is that we

00:06:04,479 --> 00:06:11,229
will iterate very quickly the current

00:06:07,830 --> 00:06:15,070
the current plan is to do it every six

00:06:11,229 --> 00:06:17,050
weeks have a new unstable release and RC

00:06:15,070 --> 00:06:20,050
release out there which is essentially

00:06:17,050 --> 00:06:22,660
cut from master and over those six weeks

00:06:20,050 --> 00:06:24,520
we will fix regressions and hopefully we

00:06:22,660 --> 00:06:26,440
will get a growing set of libraries that

00:06:24,520 --> 00:06:28,270
essentially will be on the unstable

00:06:26,440 --> 00:06:31,270
branch and that will test the unstable

00:06:28,270 --> 00:06:33,780
branch and after six weeks the unstable

00:06:31,270 --> 00:06:36,760
branch becomes the new sever release and

00:06:33,780 --> 00:06:40,830
the next version of Master is cut into

00:06:36,760 --> 00:06:44,800
the next unstable one and so on until we

00:06:40,830 --> 00:06:47,229
stabilize in and jump to essentially a

00:06:44,800 --> 00:06:52,180
bigger scalar version number okay so

00:06:47,229 --> 00:06:54,940
that's the plan of what we have and what

00:06:52,180 --> 00:06:56,349
we will release going forward but I

00:06:54,940 --> 00:06:59,800
think I should spend a little bit

00:06:56,349 --> 00:07:01,750
talking about the why I mean why do that

00:06:59,800 --> 00:07:04,300
why develop essentially a new scalar

00:07:01,750 --> 00:07:06,760
compiler a new version of the language

00:07:04,300 --> 00:07:13,139
what's the point of doing all of that

00:07:06,760 --> 00:07:16,300
so why Dottie well to explain I try to

00:07:13,139 --> 00:07:19,030
get to the basics and says well how do I

00:07:16,300 --> 00:07:21,880
explain why I did that because after all

00:07:19,030 --> 00:07:23,410
it's also a large part of my life for

00:07:21,880 --> 00:07:26,979
most more than four years basically

00:07:23,410 --> 00:07:29,020
working on that and only that so I think

00:07:26,979 --> 00:07:32,229
the best way to explain it is we need to

00:07:29,020 --> 00:07:35,860
go to principles what Scala is about and

00:07:32,229 --> 00:07:39,310
I believe Scala is about this triangle

00:07:35,860 --> 00:07:40,990
of functions objects and types to say

00:07:39,310 --> 00:07:45,400
well we want to have a language that

00:07:40,990 --> 00:07:48,010
provides a synthesis of those three

00:07:45,400 --> 00:07:50,169
elements functions and objects and types

00:07:48,010 --> 00:07:52,150
there are other languages that did some

00:07:50,169 --> 00:07:53,620
parts of the triangle for instance

00:07:52,150 --> 00:07:55,810
Common Lisp object

00:07:53,620 --> 00:07:57,850
model sealers did functions and objects

00:07:55,810 --> 00:08:00,340
a different design and functions and

00:07:57,850 --> 00:08:02,260
objects types and objects of course

00:08:00,340 --> 00:08:05,650
that's all the mainstream languages Java

00:08:02,260 --> 00:08:07,840
C sharp and so on functions and types we

00:08:05,650 --> 00:08:12,150
have very strong contenders as Haskell

00:08:07,840 --> 00:08:15,160
and ml but all three well not really

00:08:12,150 --> 00:08:17,199
there was a camel but oak Amal you could

00:08:15,160 --> 00:08:19,870
say was probably functions and types and

00:08:17,199 --> 00:08:22,240
objects I would actually have dotted

00:08:19,870 --> 00:08:24,010
lines here because they really felt not

00:08:22,240 --> 00:08:25,360
really that well integrated in the

00:08:24,010 --> 00:08:27,340
language that was sort of an add-on

00:08:25,360 --> 00:08:30,160
nothing scholar was the first one that

00:08:27,340 --> 00:08:31,860
really tries to have a fusion a

00:08:30,160 --> 00:08:35,140
synthesis between the two where

00:08:31,860 --> 00:08:37,599
functions really are objects and types

00:08:35,140 --> 00:08:39,400
are essentially drive everything so to

00:08:37,599 --> 00:08:41,200
really say well we don't want one to

00:08:39,400 --> 00:08:43,300
have separate sub languages we want to

00:08:41,200 --> 00:08:49,390
have one language which is all three of

00:08:43,300 --> 00:08:52,240
these things okay so one sorry since I'm

00:08:49,390 --> 00:08:55,330
talking about synthesis synthesis

00:08:52,240 --> 00:08:57,400
actually has two meanings one meaning is

00:08:55,330 --> 00:08:59,620
of course what I presented to say well

00:08:57,400 --> 00:09:01,209
bringing these things together but the

00:08:59,620 --> 00:09:03,790
other meaning for synthesis is

00:09:01,209 --> 00:09:06,400
essentially to synthesize things and

00:09:03,790 --> 00:09:08,320
that in our world means to generate new

00:09:06,400 --> 00:09:10,779
code and it actually turns out that

00:09:08,320 --> 00:09:12,490
scarlet is a synthesis language in the

00:09:10,779 --> 00:09:14,920
second sense of the meaning as well

00:09:12,490 --> 00:09:17,550
because Scala is one of the languages

00:09:14,920 --> 00:09:19,570
where a lot of code gets generated

00:09:17,550 --> 00:09:21,640
another language like that would be

00:09:19,570 --> 00:09:23,890
maybe C++ if we look at the main

00:09:21,640 --> 00:09:26,080
mainstream languages so how is a lot of

00:09:23,890 --> 00:09:28,270
code generated in Scala well through

00:09:26,080 --> 00:09:30,600
implicit of course we have implicit and

00:09:28,270 --> 00:09:33,459
essentially in with implicit parameters

00:09:30,600 --> 00:09:35,320
code gets generated and sometimes this

00:09:33,459 --> 00:09:37,600
code is actually very very large

00:09:35,320 --> 00:09:39,339
sometimes this code is much larger than

00:09:37,600 --> 00:09:44,230
your program depending on what library

00:09:39,339 --> 00:09:45,730
you use so implicit are a form of

00:09:44,230 --> 00:09:48,400
synthesis and I would say they are

00:09:45,730 --> 00:09:50,860
actually there the one thing that I mean

00:09:48,400 --> 00:09:53,050
implicit have existed before in some

00:09:50,860 --> 00:09:55,630
sense but I believe Scala is the first

00:09:53,050 --> 00:09:58,360
language that really puts them in the

00:09:55,630 --> 00:10:01,660
center it puts them in the center in the

00:09:58,360 --> 00:10:03,970
sense that they really are pervasive in

00:10:01,660 --> 00:10:06,310
the ecosystem and also that they are a

00:10:03,970 --> 00:10:07,059
nice version to actually use these three

00:10:06,310 --> 00:10:09,429
things so

00:10:07,059 --> 00:10:11,079
implicit that's essentially functions of

00:10:09,429 --> 00:10:13,389
implicit functions that take implicit

00:10:11,079 --> 00:10:16,449
parameters what gets passed are

00:10:13,389 --> 00:10:19,149
dictionaries dictionaries of essentially

00:10:16,449 --> 00:10:20,619
things that's essentially objects and of

00:10:19,149 --> 00:10:22,419
course the whole thing is driven by the

00:10:20,619 --> 00:10:24,579
types without types there would be no

00:10:22,419 --> 00:10:27,039
implicit because the way you find an

00:10:24,579 --> 00:10:29,439
implicit is by its type in a direct and

00:10:27,039 --> 00:10:32,289
a dynamically typed languages can't have

00:10:29,439 --> 00:10:33,909
implicit so implicit are centers to

00:10:32,289 --> 00:10:38,499
agent that's also why I have this

00:10:33,909 --> 00:10:40,629
t-shirt here the implicit why I implicit

00:10:38,499 --> 00:10:42,879
so important not just that essentially

00:10:40,629 --> 00:10:44,289
the nice feature to have and they pull

00:10:42,879 --> 00:10:46,839
everything together no they are

00:10:44,289 --> 00:10:49,149
important because there have been papers

00:10:46,839 --> 00:10:51,159
out that essentially looked at the thing

00:10:49,149 --> 00:10:54,489
is that implicit is essentially the

00:10:51,159 --> 00:10:56,679
canonical way to represent contexts so a

00:10:54,489 --> 00:10:58,509
context is something that essentially is

00:10:56,679 --> 00:11:01,209
outside of your program but that's

00:10:58,509 --> 00:11:03,999
implicitly understood by your program

00:11:01,209 --> 00:11:06,639
could be a configuration or some set of

00:11:03,999 --> 00:11:08,709
access rights or whatever something some

00:11:06,639 --> 00:11:12,039
type class implementations so all these

00:11:08,709 --> 00:11:15,939
things are contexts and so far we have

00:11:12,039 --> 00:11:18,639
had essentially a series of fairly itok

00:11:15,939 --> 00:11:20,559
ways to deal with contexts the cake

00:11:18,639 --> 00:11:23,349
pattern was one of them so John

00:11:20,559 --> 00:11:28,119
mentioned that other ways our dependency

00:11:23,349 --> 00:11:30,999
injection or xml's or annotations or

00:11:28,119 --> 00:11:32,949
lots of lots of different things and I

00:11:30,999 --> 00:11:37,359
believe implicit sort of the canonical

00:11:32,949 --> 00:11:39,729
way to represent context so that's the

00:11:37,359 --> 00:11:41,709
thing that essentially Scala is about I

00:11:39,729 --> 00:11:45,419
think this sort of triangle with the

00:11:41,709 --> 00:11:48,009
with the synthesis in the middle and in

00:11:45,419 --> 00:11:50,679
many of these respects it really was a

00:11:48,009 --> 00:11:53,049
pioneer so it did follow some of the

00:11:50,679 --> 00:11:55,049
earlier language is not most notably

00:11:53,049 --> 00:11:57,399
okama because essentially it's

00:11:55,049 --> 00:11:59,739
predominantly functional it's typed it's

00:11:57,399 --> 00:12:01,689
strict so all of these things are true

00:11:59,739 --> 00:12:04,539
for SML and or camel as well and it's

00:12:01,689 --> 00:12:06,819
modular in the sense that we care about

00:12:04,539 --> 00:12:08,289
modularity in our object system and

00:12:06,819 --> 00:12:10,119
that's where we debit it from our camera

00:12:08,289 --> 00:12:12,219
because our camera has a very strong

00:12:10,119 --> 00:12:14,709
module system and another object system

00:12:12,219 --> 00:12:16,809
sort of on the side and we essentially

00:12:14,709 --> 00:12:19,569
Skype scholars innovation was to combine

00:12:16,809 --> 00:12:20,890
the two it's of course details were also

00:12:19,569 --> 00:12:24,190
influenced by Java

00:12:20,890 --> 00:12:26,830
Pascal ml Eiffel Ellen modular two and

00:12:24,190 --> 00:12:29,260
three and so on and it turns out that

00:12:26,830 --> 00:12:31,210
lots of other languages are now moving

00:12:29,260 --> 00:12:33,550
into that space like if you followed

00:12:31,210 --> 00:12:35,290
languages a little bit the language

00:12:33,550 --> 00:12:37,210
announcement and what came out over the

00:12:35,290 --> 00:12:40,960
last 5-10 years and you will see they

00:12:37,210 --> 00:12:42,850
all look more and more like Scala no

00:12:40,960 --> 00:12:46,360
matter whether you talk about C sharp F

00:12:42,850 --> 00:12:48,370
sharp Swiss Kotlin rust all of these are

00:12:46,360 --> 00:12:51,550
pretty much there that means the genes

00:12:48,370 --> 00:12:53,290
in the language pool of which Scala took

00:12:51,550 --> 00:12:56,290
quite a lot from other languages are now

00:12:53,290 --> 00:12:57,880
essentially given in turn to a lot of

00:12:56,290 --> 00:12:59,650
languages that are moving into that

00:12:57,880 --> 00:13:01,390
space but the fact that a lot of

00:12:59,650 --> 00:13:03,700
languages are moving into that space

00:13:01,390 --> 00:13:05,860
shows that there is something that we

00:13:03,700 --> 00:13:08,590
there is something there that really

00:13:05,860 --> 00:13:10,690
seems to be very successful that seems

00:13:08,590 --> 00:13:13,000
to make people very productive that

00:13:10,690 --> 00:13:14,860
seems to be I dare to say the future of

00:13:13,000 --> 00:13:19,120
programming I think that's essentially

00:13:14,860 --> 00:13:23,200
where we are and I believe that Scala

00:13:19,120 --> 00:13:25,390
has a very unique chance here in that we

00:13:23,200 --> 00:13:27,040
were first so we I have 15 years

00:13:25,390 --> 00:13:29,530
experience with that and a lot of you

00:13:27,040 --> 00:13:32,560
have a lot of experience with that

00:13:29,530 --> 00:13:35,410
kokom codata core of the user community

00:13:32,560 --> 00:13:38,460
has a lot of experience with essentially

00:13:35,410 --> 00:13:41,170
this space so I think now is the time to

00:13:38,460 --> 00:13:44,020
take a step back and says okay with that

00:13:41,170 --> 00:13:48,190
experience what can we do to crystallize

00:13:44,020 --> 00:13:52,720
this better to make this more solid more

00:13:48,190 --> 00:13:55,270
to bring out the essence of things ok so

00:13:52,720 --> 00:13:57,430
there's another principle and that's no

00:13:55,270 --> 00:14:00,670
sorry principles or you could say

00:13:57,430 --> 00:14:03,280
pragmatics of what Scala is so we saw

00:14:00,670 --> 00:14:05,650
essentially the space functions objects

00:14:03,280 --> 00:14:08,230
types but I think the pragmatic Bragman

00:14:05,650 --> 00:14:11,770
ism is to say we want to find a balance

00:14:08,230 --> 00:14:14,350
between simplicity usability that means

00:14:11,770 --> 00:14:18,820
particular newcomers should feel at home

00:14:14,350 --> 00:14:20,740
right away and power and if you see that

00:14:18,820 --> 00:14:23,020
triangle then maybe some of you raise a

00:14:20,740 --> 00:14:25,300
hand and says skeptic and are skeptical

00:14:23,020 --> 00:14:28,030
as as scholars simple can you really

00:14:25,300 --> 00:14:30,160
mention simple and Scala in the same on

00:14:28,030 --> 00:14:32,690
the same slide and I would say yes in

00:14:30,160 --> 00:14:35,029
fact that it is simple

00:14:32,690 --> 00:14:36,610
depends how you define simplicity there

00:14:35,029 --> 00:14:40,250
are many different ways to define that

00:14:36,610 --> 00:14:42,589
there was a nice talk by Ricci about why

00:14:40,250 --> 00:14:44,899
simple is not exactly easy it's not the

00:14:42,589 --> 00:14:46,520
same thing so simplicity is not that

00:14:44,899 --> 00:14:50,890
you're familiar with it that you're

00:14:46,520 --> 00:14:55,550
immediately productive necessarily and

00:14:50,890 --> 00:14:59,600
simplicity in one sense is to say the

00:14:55,550 --> 00:15:02,180
language itself has is small its

00:14:59,600 --> 00:15:05,240
orthogonal some people call it elegant

00:15:02,180 --> 00:15:08,959
that means it has a small syntax it has

00:15:05,240 --> 00:15:12,410
few concepts few rules that can be

00:15:08,959 --> 00:15:15,200
combined in orthogonal ways and it has a

00:15:12,410 --> 00:15:17,870
reasonably sized spec and compiler and

00:15:15,200 --> 00:15:19,670
in that sense Scala is on the simpler

00:15:17,870 --> 00:15:21,440
side I know that there are many

00:15:19,670 --> 00:15:23,029
languages in particular in the academic

00:15:21,440 --> 00:15:25,760
domain that are simpler than that

00:15:23,029 --> 00:15:27,980
because academics try to essentially

00:15:25,760 --> 00:15:33,200
bring out the essence at the expense of

00:15:27,980 --> 00:15:35,870
usability often and but if you take sort

00:15:33,200 --> 00:15:38,420
of the triangle of sight simplicity

00:15:35,870 --> 00:15:40,880
usability power then I believe that at

00:15:38,420 --> 00:15:43,459
least for my motivation always was to

00:15:40,880 --> 00:15:46,250
make it as simple as I could simplicity

00:15:43,459 --> 00:15:48,080
was really very very important and in

00:15:46,250 --> 00:15:49,970
that sense to have a smaller syntax

00:15:48,080 --> 00:15:52,220
region resides back in compiler I think

00:15:49,970 --> 00:15:54,200
we have succeeded if you look at let's

00:15:52,220 --> 00:15:56,390
say Scala in some of these previous

00:15:54,200 --> 00:15:58,520
languages here that I noted and you

00:15:56,390 --> 00:15:59,870
compare them in any dimension whatsoever

00:15:58,520 --> 00:16:01,550
you will find out that all of these

00:15:59,870 --> 00:16:04,040
languages are quite a bit more

00:16:01,550 --> 00:16:06,589
complicated than Scala Scala is far

00:16:04,040 --> 00:16:09,410
smaller in terms of grammar size spec

00:16:06,589 --> 00:16:12,260
size number of keywords if you wanted to

00:16:09,410 --> 00:16:14,330
count them and things like that so okay

00:16:12,260 --> 00:16:16,400
so it is reasonably simple

00:16:14,330 --> 00:16:20,000
but that doesn't mean we can't make it

00:16:16,400 --> 00:16:24,440
simpler right and that's what the aims

00:16:20,000 --> 00:16:27,529
of totty are so Dottie then the goal

00:16:24,440 --> 00:16:29,660
here is we know we have something going

00:16:27,529 --> 00:16:32,089
in that space we really want to bring

00:16:29,660 --> 00:16:34,730
out the essence of what we have here and

00:16:32,089 --> 00:16:37,760
bring out the essence also means to drop

00:16:34,730 --> 00:16:40,579
peripheral constructs stuff that just

00:16:37,760 --> 00:16:42,440
was cute just we did but well it was

00:16:40,579 --> 00:16:45,139
able to be complicated and it's sort of

00:16:42,440 --> 00:16:47,480
keep tracks of what we really want to do

00:16:45,139 --> 00:16:49,160
if we can we should drop it backwards

00:16:47,480 --> 00:16:51,410
compatibility is of course a big

00:16:49,160 --> 00:16:54,290
constraint here but we do it as as much

00:16:51,410 --> 00:16:56,689
as we can and finally strengthen the

00:16:54,290 --> 00:16:59,629
core so the principles that if we agree

00:16:56,689 --> 00:17:02,089
what principle we are based on then we

00:16:59,629 --> 00:17:05,959
want to essentially get get the maximum

00:17:02,089 --> 00:17:09,289
out of them okay so what's essential for

00:17:05,959 --> 00:17:11,510
that because otherwise you get lost in

00:17:09,289 --> 00:17:13,789
details and you are completely unsure

00:17:11,510 --> 00:17:15,740
what's the right way to do or not these

00:17:13,789 --> 00:17:18,799
foundations I think we can make progress

00:17:15,740 --> 00:17:21,019
only with strong formal foundations and

00:17:18,799 --> 00:17:23,539
the first time we did SCARA we didn't

00:17:21,019 --> 00:17:26,240
have those foundations and that was a

00:17:23,539 --> 00:17:28,189
handicap because essentially they didn't

00:17:26,240 --> 00:17:29,149
exist and if you would have picked

00:17:28,189 --> 00:17:31,399
what's out there

00:17:29,149 --> 00:17:33,049
lambda calculus or the classical type

00:17:31,399 --> 00:17:35,389
systems and we would have done a

00:17:33,049 --> 00:17:37,760
language that is similar to those out

00:17:35,389 --> 00:17:39,889
there because foundations are formative

00:17:37,760 --> 00:17:42,559
you can't really escape your foundations

00:17:39,889 --> 00:17:45,679
so since we didn't want to do that we

00:17:42,559 --> 00:17:47,899
had to sort of make do and just wing it

00:17:45,679 --> 00:17:51,019
and say well hopefully these things are

00:17:47,899 --> 00:17:53,330
correct and mostly I think overall our

00:17:51,019 --> 00:17:55,100
record is not bad but it's not perfect

00:17:53,330 --> 00:17:58,580
either so some of the things we're not

00:17:55,100 --> 00:18:00,169
correct and we by developing the

00:17:58,580 --> 00:18:02,299
foundations what we did over the last

00:18:00,169 --> 00:18:05,360
year we now have a much much better

00:18:02,299 --> 00:18:07,669
basis to go forward so those foundations

00:18:05,360 --> 00:18:09,710
they're called duck the duck calculus

00:18:07,669 --> 00:18:12,340
that it's the one that captures the

00:18:09,710 --> 00:18:16,549
essence of scholar dot is an acronym for

00:18:12,340 --> 00:18:18,080
dependent object types and there has

00:18:16,549 --> 00:18:20,299
been a number of publications and a

00:18:18,080 --> 00:18:22,639
number of conferences so the original

00:18:20,299 --> 00:18:26,240
paper was this one here that appeared in

00:18:22,639 --> 00:18:29,210
a fist trip for fill water to a 60th

00:18:26,240 --> 00:18:31,429
birthday that's the title that's the

00:18:29,210 --> 00:18:33,409
cover of the book that you see here so I

00:18:31,429 --> 00:18:36,100
won't talk about the foundations here I

00:18:33,409 --> 00:18:39,139
talked a little bit in previous talks so

00:18:36,100 --> 00:18:41,360
look at the videos but I just

00:18:39,139 --> 00:18:44,210
nevertheless wanted to mention them as

00:18:41,360 --> 00:18:46,789
an inspiration what I want to want to

00:18:44,210 --> 00:18:50,539
talk about is well what concretely has

00:18:46,789 --> 00:18:53,149
changed now and it actually was quite a

00:18:50,539 --> 00:18:55,639
bit that has changed and if you look at

00:18:53,149 --> 00:18:57,059
the dotty website you'll find a section

00:18:55,639 --> 00:18:59,370
on reference and

00:18:57,059 --> 00:19:01,950
reference thing you find essentially a

00:18:59,370 --> 00:19:03,749
list of all the things that we added all

00:19:01,950 --> 00:19:05,879
the things that we removed and all the

00:19:03,749 --> 00:19:07,169
things that we changed so far so that's

00:19:05,879 --> 00:19:10,169
essentially the current the current

00:19:07,169 --> 00:19:11,850
status but what I want to do is here I

00:19:10,169 --> 00:19:15,059
don't have time to go into everything I

00:19:11,850 --> 00:19:17,399
just wanted to come up with essentially

00:19:15,059 --> 00:19:20,850
the things that I find most important

00:19:17,399 --> 00:19:23,269
and I'm going to mention four of them

00:19:20,850 --> 00:19:25,080
that's what has changed with the types

00:19:23,269 --> 00:19:28,830
what has changed

00:19:25,080 --> 00:19:31,470
the addition of enums the addition of

00:19:28,830 --> 00:19:33,389
trade parameters and finally what has

00:19:31,470 --> 00:19:36,360
changed with implicit since we were

00:19:33,389 --> 00:19:39,629
talking about implicit that can't we

00:19:36,360 --> 00:19:43,470
can't do without that okay so let's talk

00:19:39,629 --> 00:19:45,779
about the types first so what's the

00:19:43,470 --> 00:19:50,249
problem with types the problem with the

00:19:45,779 --> 00:19:52,830
types was well it it actually was quite

00:19:50,249 --> 00:19:56,999
complicated to understand type checking

00:19:52,830 --> 00:20:00,509
rules to understand type inference rules

00:19:56,999 --> 00:20:01,919
and if you dig deeper then you find that

00:20:00,509 --> 00:20:04,710
some of the things I actually very

00:20:01,919 --> 00:20:07,289
unsatisfactory but in some of the core

00:20:04,710 --> 00:20:09,659
things nobody understands them including

00:20:07,289 --> 00:20:13,559
me so we don't really know where this

00:20:09,659 --> 00:20:15,629
core function is correct or not because

00:20:13,559 --> 00:20:17,779
we don't know what the spec should be

00:20:15,629 --> 00:20:21,389
because we don't have a good foundation

00:20:17,779 --> 00:20:23,549
so that's deeply deeply unsatisfactory

00:20:21,389 --> 00:20:27,149
because the types are the cornerstone

00:20:23,549 --> 00:20:29,039
they're the center of it all and so the

00:20:27,149 --> 00:20:31,259
first step was to say well let's remove

00:20:29,039 --> 00:20:33,720
what we don't understand and in fact

00:20:31,259 --> 00:20:36,899
what what what we know won't work by now

00:20:33,720 --> 00:20:37,980
so what what don't we understand so the

00:20:36,899 --> 00:20:40,590
first thing that we remove is

00:20:37,980 --> 00:20:44,940
existential types so something like tea

00:20:40,590 --> 00:20:46,710
for some type X is gone you still have

00:20:44,940 --> 00:20:50,039
wild cards because we understand them

00:20:46,710 --> 00:20:53,159
but full and full existential types we

00:20:50,039 --> 00:20:54,690
do not understand what I understand what

00:20:53,159 --> 00:20:56,850
they are but I don't understand all the

00:20:54,690 --> 00:21:00,649
interaction all the feature interactions

00:20:56,850 --> 00:21:04,590
with with what's out there and in fact

00:21:00,649 --> 00:21:07,019
it turns out that if we take the

00:21:04,590 --> 00:21:10,470
soundness model developed in dot then

00:21:07,019 --> 00:21:12,960
the answer is no existential types are

00:21:10,470 --> 00:21:14,370
the way we have them down sound and then

00:21:12,960 --> 00:21:16,529
you could say well can I sort of fix

00:21:14,370 --> 00:21:18,929
them to make them sound and the answer

00:21:16,529 --> 00:21:21,480
would be unlikely it's unlikely because

00:21:18,929 --> 00:21:24,179
they just don't fit into our approach of

00:21:21,480 --> 00:21:26,399
soundness okay so it's essential types

00:21:24,179 --> 00:21:29,179
first thing that's gone second thing

00:21:26,399 --> 00:21:31,559
that's gone is type projections T hash a

00:21:29,179 --> 00:21:33,750
I should say there's a there's a

00:21:31,559 --> 00:21:36,750
essentially we have restricted them so

00:21:33,750 --> 00:21:38,580
the type projections as far as they are

00:21:36,750 --> 00:21:40,889
essentially the same thing as java's

00:21:38,580 --> 00:21:42,870
inner classes so you project on

00:21:40,889 --> 00:21:46,200
something that's concrete so you know

00:21:42,870 --> 00:21:48,509
what it is that still is legal because

00:21:46,200 --> 00:21:51,480
there's no other way to model Chavez

00:21:48,509 --> 00:21:54,210
inner classes otherwise but the the

00:21:51,480 --> 00:21:57,120
thing where T was an abstract type of in

00:21:54,210 --> 00:22:00,179
some other way abstract that's no longer

00:21:57,120 --> 00:22:04,649
possible and in fact that also was shown

00:22:00,179 --> 00:22:07,799
to be unsound so therefore we can't we

00:22:04,649 --> 00:22:11,340
can't include that okay so that was the

00:22:07,799 --> 00:22:15,779
first thing that's gone the next thing

00:22:11,340 --> 00:22:18,559
is we want to be one to replace compound

00:22:15,779 --> 00:22:21,659
types with intersection and union types

00:22:18,559 --> 00:22:23,879
so instead of key with you you have T

00:22:21,659 --> 00:22:25,529
and U and T or you for the moment you

00:22:23,879 --> 00:22:28,700
still have tea with you but it's

00:22:25,529 --> 00:22:31,710
silently interpreted to be a T and u

00:22:28,700 --> 00:22:33,690
well is that more than just a change in

00:22:31,710 --> 00:22:35,669
syntax that we now like the ampersand

00:22:33,690 --> 00:22:37,409
better than the with no not exactly

00:22:35,669 --> 00:22:40,129
there's actually something very

00:22:37,409 --> 00:22:43,860
fundamental here and that is that

00:22:40,129 --> 00:22:48,179
subtyping forms a lattice with and and

00:22:43,860 --> 00:22:50,580
or so what does that mean a lattice so

00:22:48,179 --> 00:22:54,720
let us means that if you have two types

00:22:50,580 --> 00:22:56,820
T and u then you will always find the

00:22:54,720 --> 00:22:59,370
least upper bound with respect to

00:22:56,820 --> 00:23:02,250
subtyping and that you write T or you

00:22:59,370 --> 00:23:05,309
and you find a greatest lower bound and

00:23:02,250 --> 00:23:07,409
that's T and U and lettuces have very

00:23:05,309 --> 00:23:08,970
nice algebraic properties and such

00:23:07,409 --> 00:23:10,409
properties they are important in

00:23:08,970 --> 00:23:14,340
software construction so it's really

00:23:10,409 --> 00:23:17,220
great that we have them okay so lettuces

00:23:14,340 --> 00:23:19,350
are good but wouldn't with do or what

00:23:17,220 --> 00:23:21,690
was the situation before while actually

00:23:19,350 --> 00:23:24,210
the situation before was not at all that

00:23:21,690 --> 00:23:27,930
nice so in the same situation where you

00:23:24,210 --> 00:23:32,640
had tea and you the least upper bound of

00:23:27,930 --> 00:23:34,200
tea and you could be infinite but the

00:23:32,640 --> 00:23:36,570
compiler wouldn't give you an infinite

00:23:34,200 --> 00:23:38,550
least upper bound it can't do that but

00:23:36,570 --> 00:23:40,620
you probably remember that sometimes it

00:23:38,550 --> 00:23:43,440
gave you a very very large upper bound

00:23:40,620 --> 00:23:45,240
so like they like the typical error

00:23:43,440 --> 00:23:47,340
messages where you have pages and pages

00:23:45,240 --> 00:23:49,770
and pages of a single error of a single

00:23:47,340 --> 00:23:51,960
type generally that came because of that

00:23:49,770 --> 00:23:53,640
because least upper bounds they just got

00:23:51,960 --> 00:23:55,500
out of hands they got very very large

00:23:53,640 --> 00:23:57,210
and of course there were breaks in the

00:23:55,500 --> 00:23:59,370
compiler to truncate them but they were

00:23:57,210 --> 00:24:01,050
not perfect and some of them slipped

00:23:59,370 --> 00:24:04,380
through and that's what you got so

00:24:01,050 --> 00:24:06,480
deeply unsatisfactory you could say well

00:24:04,380 --> 00:24:09,210
at least well what about lower bounds

00:24:06,480 --> 00:24:11,460
isn't he with you at least a lower bound

00:24:09,210 --> 00:24:13,650
of them and the answer again is

00:24:11,460 --> 00:24:16,230
unfortunately not because here you have

00:24:13,650 --> 00:24:19,520
two lower bounds of T and u one is T

00:24:16,230 --> 00:24:22,230
with you and the other is U with T and

00:24:19,520 --> 00:24:24,390
unfortunately with this not commutative

00:24:22,230 --> 00:24:27,150
because depending on how you write them

00:24:24,390 --> 00:24:29,490
you will resolve members to essentially

00:24:27,150 --> 00:24:32,400
always look at the right type first and

00:24:29,490 --> 00:24:34,230
at the left type second so if you swap

00:24:32,400 --> 00:24:35,910
them around and you look up the types in

00:24:34,230 --> 00:24:38,040
a different order so that means the

00:24:35,910 --> 00:24:40,170
types can't be identified they can't be

00:24:38,040 --> 00:24:42,450
the same so that's the second violation

00:24:40,170 --> 00:24:46,070
of the lattice principle whereas with

00:24:42,450 --> 00:24:48,330
and and is commutative there's only one

00:24:46,070 --> 00:24:50,190
greatest lower bound and that's

00:24:48,330 --> 00:24:54,030
essentially the intersection of those

00:24:50,190 --> 00:24:57,480
two types so much nicer in in the

00:24:54,030 --> 00:25:00,000
properties Department and therefore I

00:24:57,480 --> 00:25:04,290
believe a definite advance over what we

00:25:00,000 --> 00:25:06,630
had before okay the third change in

00:25:04,290 --> 00:25:09,990
types that we did was we added type

00:25:06,630 --> 00:25:13,050
lambdas so type lambda is written like

00:25:09,990 --> 00:25:16,290
that so it's a it's a higher kind of

00:25:13,050 --> 00:25:18,000
type that takes a type parameter X you

00:25:16,290 --> 00:25:19,650
could have several there several X's

00:25:18,000 --> 00:25:23,250
there and this essentially gives you

00:25:19,650 --> 00:25:27,810
back a type T which typically will refer

00:25:23,250 --> 00:25:30,990
to this variable X so type lambdas of

00:25:27,810 --> 00:25:32,880
course we have in Scala they were

00:25:30,990 --> 00:25:34,830
actually some of the things that sort of

00:25:32,880 --> 00:25:36,180
got invented by the community there was

00:25:34,830 --> 00:25:38,370
never an intention to actually

00:25:36,180 --> 00:25:40,020
essentially have typed lambdas

00:25:38,370 --> 00:25:42,300
using structural types and type

00:25:40,020 --> 00:25:44,550
projections the way is usually done I

00:25:42,300 --> 00:25:47,040
guess you all agree with me that that's

00:25:44,550 --> 00:25:49,470
a truly awful way of doing things but it

00:25:47,040 --> 00:25:52,140
was the only one available until now so

00:25:49,470 --> 00:25:53,880
that thing is is also gone it has to go

00:25:52,140 --> 00:25:57,410
because we don't have projection anymore

00:25:53,880 --> 00:26:00,240
so this previous type lambdas using this

00:25:57,410 --> 00:26:01,950
unwieldy structural types you couldn't

00:26:00,240 --> 00:26:03,930
apply them anymore because application

00:26:01,950 --> 00:26:06,030
meant projection and projection is out

00:26:03,930 --> 00:26:10,320
so type lambdas are now primitive and

00:26:06,030 --> 00:26:13,500
much nicer so that's good the second

00:26:10,320 --> 00:26:17,460
change that we I want to talk about

00:26:13,500 --> 00:26:19,740
after types is traits and that's a minor

00:26:17,460 --> 00:26:23,309
one but I think nevertheless important

00:26:19,740 --> 00:26:25,920
one so what's the problem with traits so

00:26:23,309 --> 00:26:28,110
the problem is that so far we didn't

00:26:25,920 --> 00:26:32,340
really have a way to pass parameters to

00:26:28,110 --> 00:26:34,679
at right okay you could say well no big

00:26:32,340 --> 00:26:37,530
deal just it where you had a parameter

00:26:34,679 --> 00:26:39,809
make it an abstract method to avow and

00:26:37,530 --> 00:26:42,150
then just fill them in in the subclass

00:26:39,809 --> 00:26:45,300
and that you could say well that works

00:26:42,150 --> 00:26:47,340
as far as you don't run into problems

00:26:45,300 --> 00:26:48,750
with initialization because the nice

00:26:47,340 --> 00:26:51,300
thing with parameters is there

00:26:48,750 --> 00:26:53,220
essentially initialized before the

00:26:51,300 --> 00:26:54,780
constructor of the thing is run you have

00:26:53,220 --> 00:26:58,350
two parameters and you can use them in

00:26:54,780 --> 00:27:00,480
the constructor with abstract values

00:26:58,350 --> 00:27:04,980
that's not the case they are initialized

00:27:00,480 --> 00:27:06,720
after you run and I guess you if we take

00:27:04,980 --> 00:27:08,309
the whole audience together and you say

00:27:06,720 --> 00:27:11,220
how many null pointer exceptions you

00:27:08,309 --> 00:27:13,350
already had because of that we could get

00:27:11,220 --> 00:27:15,630
quite a quite a good number together get

00:27:13,350 --> 00:27:18,300
IP I guess everyone already had had that

00:27:15,630 --> 00:27:21,240
problem in one form or another so there

00:27:18,300 --> 00:27:23,280
was one thing before which was very

00:27:21,240 --> 00:27:25,740
sophisticated very tricky which was

00:27:23,280 --> 00:27:28,140
called early definitions who here has

00:27:25,740 --> 00:27:29,940
used that already this thing here so in

00:27:28,140 --> 00:27:32,550
early definition is Class C and then you

00:27:29,940 --> 00:27:34,650
write extends and then comes a block and

00:27:32,550 --> 00:27:36,390
there you define your abstract wells in

00:27:34,650 --> 00:27:39,870
the trait and then comes the trait and

00:27:36,390 --> 00:27:41,610
the idea was you're the VP the abstract

00:27:39,870 --> 00:27:43,620
Wells they are then initialized before

00:27:41,610 --> 00:27:47,760
the trait is run so problem solved so

00:27:43,620 --> 00:27:49,679
who is already used that oh wow yes so

00:27:47,760 --> 00:27:51,070
quite a sophisticated audience usually I

00:27:49,679 --> 00:27:54,789
get much less

00:27:51,070 --> 00:27:58,539
hands hands and death yeah so you'll

00:27:54,789 --> 00:28:00,600
have to rewrite your code now but I

00:27:58,539 --> 00:28:03,250
guess you'll thank me for it

00:28:00,600 --> 00:28:06,850
so because now we do the obvious thing

00:28:03,250 --> 00:28:09,639
da we have trade parameters so we have

00:28:06,850 --> 00:28:11,649
instead of that we have 20 and it can

00:28:09,639 --> 00:28:15,309
take a parameter X and then you just say

00:28:11,649 --> 00:28:17,409
Class C extends T 22 now you might ask

00:28:15,309 --> 00:28:19,539
of course well why didn't they do this

00:28:17,409 --> 00:28:21,370
from the start I mean this seems such an

00:28:19,539 --> 00:28:23,799
obvious thing to do why jump through

00:28:21,370 --> 00:28:25,269
hoops with these early initializers well

00:28:23,799 --> 00:28:28,960
we didn't do it from the start because

00:28:25,269 --> 00:28:31,090
there's a tricky problem and before we

00:28:28,960 --> 00:28:33,039
hadn't didn't have a good solution for

00:28:31,090 --> 00:28:37,840
that and that tricky problem with trade

00:28:33,039 --> 00:28:39,909
parameters is inheritance diamonds so if

00:28:37,840 --> 00:28:41,710
you have a situation like this where you

00:28:39,909 --> 00:28:43,600
have a trait and it's parameterised and

00:28:41,710 --> 00:28:45,190
then you have a class and then you have

00:28:43,600 --> 00:28:47,529
maybe another trait and then you have

00:28:45,190 --> 00:28:50,230
another class and they all extend this

00:28:47,529 --> 00:28:52,389
trait then if they're all pass

00:28:50,230 --> 00:28:54,549
parameters to the traits how do you know

00:28:52,389 --> 00:28:56,139
which parameters are the ones in effect

00:28:54,549 --> 00:28:58,299
in the trait they would conflict with

00:28:56,139 --> 00:28:59,919
each other right and people didn't

00:28:58,299 --> 00:29:01,929
really have a good a good solution for

00:28:59,919 --> 00:29:04,179
that or the published solutions are very

00:29:01,929 --> 00:29:07,059
complicated so that's why we didn't do

00:29:04,179 --> 00:29:08,950
it that way but we actually hit on a

00:29:07,059 --> 00:29:12,220
very nice solution now which essentially

00:29:08,950 --> 00:29:14,019
here you says well si is the first class

00:29:12,220 --> 00:29:15,639
implementing that trait none of its

00:29:14,019 --> 00:29:19,210
super classes implements that right so

00:29:15,639 --> 00:29:21,580
it has to parameterize it P already gets

00:29:19,210 --> 00:29:24,419
the trade through C so it's not allowed

00:29:21,580 --> 00:29:26,740
to parameterize it so even if it

00:29:24,419 --> 00:29:29,710
inherited P directly it wouldn't

00:29:26,740 --> 00:29:31,750
parameterize it and try to never pass

00:29:29,710 --> 00:29:34,600
parameters to other traits only classes

00:29:31,750 --> 00:29:36,519
- so these rules are quite restrictive

00:29:34,600 --> 00:29:39,129
but they're completely workable I think

00:29:36,519 --> 00:29:40,929
they essentially I think all the actual

00:29:39,129 --> 00:29:42,519
designs out there that used early

00:29:40,929 --> 00:29:45,129
definitions are perfectly well

00:29:42,519 --> 00:29:47,279
translatable into that and it's much

00:29:45,129 --> 00:29:53,789
much simpler than what we had before so

00:29:47,279 --> 00:29:56,710
that was traits my third topic is enums

00:29:53,789 --> 00:30:00,340
so enums that's another long-standing

00:29:56,710 --> 00:30:03,669
problem in Scala because I think for a

00:30:00,340 --> 00:30:04,220
long time we had essentially a number of

00:30:03,669 --> 00:30:08,330
issue

00:30:04,220 --> 00:30:12,049
whose requests proposals how to model or

00:30:08,330 --> 00:30:14,120
add enumerations to Scala because that

00:30:12,049 --> 00:30:16,970
was sort of the last big thing that you

00:30:14,120 --> 00:30:18,980
could do very conveniently in Java and

00:30:16,970 --> 00:30:21,530
really basically all other languages

00:30:18,980 --> 00:30:24,260
most other languages definitely they had

00:30:21,530 --> 00:30:26,419
some form of enum construct that just

00:30:24,260 --> 00:30:29,120
let you essentially define a type

00:30:26,419 --> 00:30:32,690
consisting of a fixed number of named

00:30:29,120 --> 00:30:34,640
values right color red green blue and

00:30:32,690 --> 00:30:37,880
you're done and color I didn't have it

00:30:34,640 --> 00:30:41,059
and so so that was a problem in the

00:30:37,880 --> 00:30:43,549
sense that there was a lack of

00:30:41,059 --> 00:30:46,130
expressiveness there was a related

00:30:43,549 --> 00:30:47,570
problem and that's no it's not actually

00:30:46,130 --> 00:30:49,730
not related but it turns out the

00:30:47,570 --> 00:30:53,140
solution is the same and that has to do

00:30:49,730 --> 00:30:56,120
with a DPS or algebraic data types

00:30:53,140 --> 00:30:59,570
Haskell has a nicer way to write edit

00:30:56,120 --> 00:31:02,510
ease with data right just data list

00:30:59,570 --> 00:31:04,370
equals cons or nil and you're done and

00:31:02,510 --> 00:31:06,679
in Scala of course you can write that as

00:31:04,370 --> 00:31:09,020
well but you have to write a lot more

00:31:06,679 --> 00:31:11,120
code you have to essentially define a

00:31:09,020 --> 00:31:14,480
sealed paste right and then essentially

00:31:11,120 --> 00:31:17,140
two case classes and that all those

00:31:14,480 --> 00:31:19,669
things altogether give you your ADT

00:31:17,140 --> 00:31:22,039
except that there was a there was a

00:31:19,669 --> 00:31:24,919
related problem that there was really no

00:31:22,039 --> 00:31:27,559
robust way to find all the subclasses of

00:31:24,919 --> 00:31:30,080
a sealed class and some of the tight

00:31:27,559 --> 00:31:32,120
level programming needs that so it needs

00:31:30,080 --> 00:31:34,820
to know it's some of these subclasses

00:31:32,120 --> 00:31:39,500
and essentially there's no good way to

00:31:34,820 --> 00:31:42,260
do it because with a field base trait

00:31:39,500 --> 00:31:44,480
and children they can be defined in any

00:31:42,260 --> 00:31:47,360
order and it's very hard to sort of

00:31:44,480 --> 00:31:49,940
figure all these things out to bring

00:31:47,360 --> 00:31:52,280
come up with the right subclasses and do

00:31:49,940 --> 00:31:54,289
this at the right time so that was

00:31:52,280 --> 00:31:56,990
another problem so the solution to all

00:31:54,289 --> 00:31:58,730
of these which sort of finally made me

00:31:56,990 --> 00:32:01,789
jump over the fence to say well we can

00:31:58,730 --> 00:32:03,799
catch free flies with one stone so it

00:32:01,789 --> 00:32:05,960
might be worth you see I'm really

00:32:03,799 --> 00:32:07,370
normally I'm always the one now we don't

00:32:05,960 --> 00:32:09,080
want to spend a new feature on the

00:32:07,370 --> 00:32:10,820
language we scholar should have as

00:32:09,080 --> 00:32:13,149
useful features as possible and here

00:32:10,820 --> 00:32:16,039
sort of I jumped over my own shadow and

00:32:13,149 --> 00:32:17,539
said well ok let's do it because we have

00:32:16,039 --> 00:32:21,499
so many flies to catch here

00:32:17,539 --> 00:32:23,899
that it might be with with it and so

00:32:21,499 --> 00:32:26,059
what we did is we added an enum

00:32:23,899 --> 00:32:28,999
construct which supports both

00:32:26,059 --> 00:32:30,769
enumerations and additives and the other

00:32:28,999 --> 00:32:33,440
thing it has going for it in my opinion

00:32:30,769 --> 00:32:35,659
is that it Maps transparently to classes

00:32:33,440 --> 00:32:37,729
object levels so the type checker

00:32:35,659 --> 00:32:39,710
actually doesn't even isn't even

00:32:37,729 --> 00:32:41,779
concerned with enums anymore it's all

00:32:39,710 --> 00:32:44,029
done in the D sugaring between the

00:32:41,779 --> 00:32:45,379
parser and the types typer and since the

00:32:44,029 --> 00:32:46,789
type checker is the most complicated

00:32:45,379 --> 00:32:49,759
part of scala

00:32:46,789 --> 00:32:51,619
if we can essentially unload take off

00:32:49,759 --> 00:32:54,109
the load of the type checker that's a

00:32:51,619 --> 00:32:57,499
net win so what does an enum look like

00:32:54,109 --> 00:33:00,169
so here's a simple one in am color just

00:32:57,499 --> 00:33:04,279
three cases red green blue so it's what

00:33:00,169 --> 00:33:06,950
you imagined it would be well what does

00:33:04,279 --> 00:33:10,580
that expand to is there a way to write

00:33:06,950 --> 00:33:13,070
that in a bit more detail factor is so

00:33:10,580 --> 00:33:16,729
another way to write this thing is to

00:33:13,070 --> 00:33:19,519
say okay we have an enum class so that's

00:33:16,729 --> 00:33:21,649
the type and that's color and then we

00:33:19,519 --> 00:33:23,830
have an object color and the object

00:33:21,649 --> 00:33:27,909
defines the cases so when you write here

00:33:23,830 --> 00:33:31,129
this enum here is intentionally

00:33:27,909 --> 00:33:33,349
ambiguous it's both a class and an

00:33:31,129 --> 00:33:36,649
object right an enum defines both a

00:33:33,349 --> 00:33:38,179
class and an object and the cases go in

00:33:36,649 --> 00:33:40,159
the object because they can't call in

00:33:38,179 --> 00:33:42,619
the class because then in that case

00:33:40,159 --> 00:33:45,019
essentially they would need a dynamic

00:33:42,619 --> 00:33:47,659
this as a prefix and in scala we take

00:33:45,019 --> 00:33:49,840
scoping very seriously so they have to

00:33:47,659 --> 00:33:54,409
go in the object so it looks like this

00:33:49,840 --> 00:33:56,330
okay you can say good so that's what is

00:33:54,409 --> 00:33:58,639
the compiler doing with that what the

00:33:56,330 --> 00:34:01,340
compiler doing to expand this so now I

00:33:58,639 --> 00:34:04,239
show you an even more detailed version

00:34:01,340 --> 00:34:09,889
of the same enum oops sorry

00:34:04,239 --> 00:34:11,480
so it's expanded into a sorry here

00:34:09,889 --> 00:34:15,109
should have set it's a sealed class

00:34:11,480 --> 00:34:17,599
color extends enum and it's companion

00:34:15,109 --> 00:34:21,129
object then defines three values red

00:34:17,599 --> 00:34:23,540
green and blue and those values are

00:34:21,129 --> 00:34:25,970
essentially use a common Creator called

00:34:23,540 --> 00:34:29,149
dollar new and they pass through it a

00:34:25,970 --> 00:34:30,300
tag so every enum has its own unique tag

00:34:29,149 --> 00:34:32,700
starting from zero

00:34:30,300 --> 00:34:34,640
and a name so if you print these things

00:34:32,700 --> 00:34:38,940
they will print out nicely and you can

00:34:34,640 --> 00:34:43,020
essentially get obtain an enum value by

00:34:38,940 --> 00:34:46,140
its name and so on okay so that's the

00:34:43,020 --> 00:34:48,630
most basic things but then they could be

00:34:46,140 --> 00:34:50,370
the true test of that was well can we do

00:34:48,630 --> 00:34:51,750
more complicated things with it because

00:34:50,370 --> 00:34:54,060
one thing we don't want to do is

00:34:51,750 --> 00:34:57,210
essentially give you a construct which

00:34:54,060 --> 00:34:59,310
sort of works in the in the easy cases

00:34:57,210 --> 00:35:01,290
and when it's complicated you have to

00:34:59,310 --> 00:35:05,010
fall back to something else so the next

00:35:01,290 --> 00:35:08,190
complication is parameters oops

00:35:05,010 --> 00:35:09,990
so enums can have parameters and here I

00:35:08,190 --> 00:35:13,490
actually did a mistake it should be in

00:35:09,990 --> 00:35:19,380
am color and here you should test X

00:35:13,490 --> 00:35:22,110
parameter X : X : or a color value : int

00:35:19,380 --> 00:35:24,450
after color but you can pass parameters

00:35:22,110 --> 00:35:26,940
from the cases by just essentially

00:35:24,450 --> 00:35:29,430
writing an explicit extends class and

00:35:26,940 --> 00:35:33,570
then you pass the parameter that you

00:35:29,430 --> 00:35:36,240
want to use supertype okay so so far in

00:35:33,570 --> 00:35:38,820
a mess what about a DPS well ADT's

00:35:36,240 --> 00:35:41,910
actually look a lot like enums so here's

00:35:38,820 --> 00:35:47,430
a simple ADT that's option that so one

00:35:41,910 --> 00:35:50,220
we know so we say it optional has a type

00:35:47,430 --> 00:35:52,380
parameter it's covariant and then it has

00:35:50,220 --> 00:35:55,080
two cases some and none

00:35:52,380 --> 00:35:57,420
so none looks like an enum value and it

00:35:55,080 --> 00:35:59,970
really is it's essentially the single

00:35:57,420 --> 00:36:01,950
enum value that implements option but

00:35:59,970 --> 00:36:03,900
some is different because some itself

00:36:01,950 --> 00:36:05,670
has parameters so it has a type

00:36:03,900 --> 00:36:07,950
parameter which is the same as option

00:36:05,670 --> 00:36:11,850
and it has a value parameter of course

00:36:07,950 --> 00:36:14,820
which is the the value that is captured

00:36:11,850 --> 00:36:17,460
by the sender so how would we translate

00:36:14,820 --> 00:36:20,400
that to understand what that is so

00:36:17,460 --> 00:36:22,110
that's what it would be so would again

00:36:20,400 --> 00:36:25,230
that would be a sealed class option

00:36:22,110 --> 00:36:27,570
extends enum and the object object

00:36:25,230 --> 00:36:30,210
option now has our familiar tight case

00:36:27,570 --> 00:36:32,130
classes so it has the case class some

00:36:30,210 --> 00:36:34,890
and the extends class is synthesized

00:36:32,130 --> 00:36:36,570
just from this parameter here and we

00:36:34,890 --> 00:36:38,640
have the case object none and that's

00:36:36,570 --> 00:36:40,710
also synthesized so what the compiler

00:36:38,640 --> 00:36:44,430
you figured out is that

00:36:40,710 --> 00:36:46,319
none here doesn't have a parameter so

00:36:44,430 --> 00:36:48,569
that means to extend the object we have

00:36:46,319 --> 00:36:52,559
to figure out what the actual parameters

00:36:48,569 --> 00:36:54,869
here are and they get interpolated if

00:36:52,559 --> 00:36:56,700
the parameter is covariant we put the

00:36:54,869 --> 00:36:58,530
lower bound nothing in there and if it's

00:36:56,700 --> 00:37:01,440
contravariant the upper bound so that's

00:36:58,530 --> 00:37:03,599
the rules that we have here and here's

00:37:01,440 --> 00:37:06,030
the relic of our inner things to really

00:37:03,599 --> 00:37:07,800
show that a DTS are enums so they still

00:37:06,030 --> 00:37:09,750
have an enum tag and the compiler will

00:37:07,800 --> 00:37:12,780
give it to you and punkin could use this

00:37:09,750 --> 00:37:15,420
in untucked or potentially later on to

00:37:12,780 --> 00:37:17,720
get potentially more efficient matching

00:37:15,420 --> 00:37:22,710
with a switch or something like that

00:37:17,720 --> 00:37:23,609
anyway it's there so that was option and

00:37:22,710 --> 00:37:26,520
enums

00:37:23,609 --> 00:37:30,630
the fourth area i wanted to cover is

00:37:26,520 --> 00:37:33,450
implicit so what are the problems with

00:37:30,630 --> 00:37:35,970
implicit I would say there are mainly

00:37:33,450 --> 00:37:38,910
two the first problem is too many

00:37:35,970 --> 00:37:42,150
puzzlers implicit there's too much head

00:37:38,910 --> 00:37:44,010
scratching and some of that is

00:37:42,150 --> 00:37:45,630
unavoidable because it is a very

00:37:44,010 --> 00:37:48,030
advanced subject I mean program

00:37:45,630 --> 00:37:51,119
synthesis is advanced and some of it is

00:37:48,030 --> 00:37:54,299
avoidable and just plain annoying and we

00:37:51,119 --> 00:37:56,640
should try to get rid of those and the

00:37:54,299 --> 00:37:58,950
second problem is there's also too much

00:37:56,640 --> 00:38:02,400
repetition sometimes your implicit

00:37:58,950 --> 00:38:04,440
programs read like a lot of times you

00:38:02,400 --> 00:38:06,900
pass the same implicit parameters again

00:38:04,440 --> 00:38:09,960
and again and again so let's see what we

00:38:06,900 --> 00:38:11,880
can do about those passwords first so

00:38:09,960 --> 00:38:15,599
here's a puzzler it's not exactly the

00:38:11,880 --> 00:38:18,869
puzzler that is number 54 in in the book

00:38:15,599 --> 00:38:23,180
by scholar puzzlers book but it's close

00:38:18,869 --> 00:38:26,910
to that so question what does this print

00:38:23,180 --> 00:38:29,520
it's simplified from 54 so suits is a

00:38:26,910 --> 00:38:32,280
list Club spades hearts diamonds print

00:38:29,520 --> 00:38:38,819
injustice control console printing of an

00:38:32,280 --> 00:38:39,390
int and we print 42 out of bounds

00:38:38,819 --> 00:38:42,960
exception

00:38:39,390 --> 00:38:44,579
well hint list of string is functioning

00:38:42,960 --> 00:38:47,750
is an index out of bounds exception

00:38:44,579 --> 00:38:47,750
excellent yes

00:38:50,190 --> 00:38:54,660
I'm sorry this sir I've ruined my

00:38:53,040 --> 00:38:56,370
example they should probably be string

00:38:54,660 --> 00:38:58,580
yeah this should be string here

00:38:56,370 --> 00:39:02,670
otherwise it doesn't make sense yeah

00:38:58,580 --> 00:39:08,190
okay sorry this should be string so what

00:39:02,670 --> 00:39:10,800
happens here is that it says okay I have

00:39:08,190 --> 00:39:13,170
a 42 and I need a string because that's

00:39:10,800 --> 00:39:14,940
about what my print on the it resolves

00:39:13,170 --> 00:39:17,430
to this one because it first finds that

00:39:14,940 --> 00:39:19,170
doesn't find the other one in system and

00:39:17,430 --> 00:39:21,420
console and things like that first first

00:39:19,170 --> 00:39:23,340
fit is let's print them so it says well

00:39:21,420 --> 00:39:25,350
I want this print all and let's now just

00:39:23,340 --> 00:39:28,950
all assume this print on has type string

00:39:25,350 --> 00:39:31,830
here then it says well 42 is not a

00:39:28,950 --> 00:39:34,320
string can I make it to a string and I

00:39:31,830 --> 00:39:38,430
says oh yeah I found an implicit value

00:39:34,320 --> 00:39:40,650
suits and it so happens list of string

00:39:38,430 --> 00:39:43,440
is actually a subtype of int to string

00:39:40,650 --> 00:39:46,290
the function and so this thing can be

00:39:43,440 --> 00:39:48,690
used as an implicit conversion now this

00:39:46,290 --> 00:39:50,910
is of course terrible in particular

00:39:48,690 --> 00:39:53,070
because we tell everyone implicit

00:39:50,910 --> 00:39:55,440
conversions be really careful with those

00:39:53,070 --> 00:39:57,360
right there most of the time implicit

00:39:55,440 --> 00:39:58,800
conversions you should think three times

00:39:57,360 --> 00:40:00,600
before you use them you should think

00:39:58,800 --> 00:40:04,500
thank ten times before you use them and

00:40:00,600 --> 00:40:07,850
here we silently surreptitiously give

00:40:04,500 --> 00:40:10,200
you an implicit conversion just by how

00:40:07,850 --> 00:40:12,480
since it's just by essentially you

00:40:10,200 --> 00:40:14,130
having harmlessly written an implicit

00:40:12,480 --> 00:40:16,740
value that you wanted to use as a

00:40:14,130 --> 00:40:18,930
parameter so these these values they

00:40:16,740 --> 00:40:21,660
essentially just sneaky lis give you

00:40:18,930 --> 00:40:24,690
these conversions and in your code a

00:40:21,660 --> 00:40:27,420
true puzzler so in dot e we don't have

00:40:24,690 --> 00:40:29,250
there anymore so what we have is that we

00:40:27,420 --> 00:40:31,380
say well now if you want to convert you

00:40:29,250 --> 00:40:34,380
have to really write a conversion method

00:40:31,380 --> 00:40:36,720
a value just doesn't work and if it's a

00:40:34,380 --> 00:40:39,720
subtype of function even if it's a if

00:40:36,720 --> 00:40:42,030
it's type is really function one then no

00:40:39,720 --> 00:40:44,340
we won't convert with that and some

00:40:42,030 --> 00:40:46,470
people said well ok no but now you left

00:40:44,340 --> 00:40:48,360
me high and dry because I actually pass

00:40:46,470 --> 00:40:50,370
around function ones and I want to use

00:40:48,360 --> 00:40:52,260
them as conversions so what can I do and

00:40:50,370 --> 00:40:54,510
there we have a fallback that we have a

00:40:52,260 --> 00:40:57,360
new class called subs or sorry implicit

00:40:54,510 --> 00:40:59,280
converter and that implicit converter if

00:40:57,360 --> 00:41:01,460
you pass that instead of your function

00:40:59,280 --> 00:41:04,079
so that sort of makes you intent

00:41:01,460 --> 00:41:06,329
explicit that you want to convert

00:41:04,079 --> 00:41:09,900
implicitly with this thing and then the

00:41:06,329 --> 00:41:12,239
compiler will honor your request okay so

00:41:09,900 --> 00:41:14,369
that was the number one puzzler and we

00:41:12,239 --> 00:41:17,219
have another couple of puzzlers under

00:41:14,369 --> 00:41:20,179
discussion the most contentious one is

00:41:17,219 --> 00:41:23,130
that I would really like to disallow

00:41:20,179 --> 00:41:23,579
implicit conversions between unrelated

00:41:23,130 --> 00:41:26,160
types

00:41:23,579 --> 00:41:28,469
unless that conversion is defined in one

00:41:26,160 --> 00:41:30,449
type or with together with one type or

00:41:28,469 --> 00:41:32,429
the other so this sort of I mean the

00:41:30,449 --> 00:41:34,259
worst thing is you have a type in one

00:41:32,429 --> 00:41:35,999
package here and the type in one package

00:41:34,259 --> 00:41:38,489
there and there's a third package that

00:41:35,999 --> 00:41:40,739
somehow gives you a conversion from this

00:41:38,489 --> 00:41:42,900
type to that type and just by bringing

00:41:40,739 --> 00:41:44,429
this package into scope with an import

00:41:42,900 --> 00:41:46,650
or whatever gives you this

00:41:44,429 --> 00:41:50,939
convertibility because these things they

00:41:46,650 --> 00:41:54,569
are way too powerful and way too

00:41:50,939 --> 00:41:56,609
surprising in a lot of sensor cases when

00:41:54,569 --> 00:41:58,890
I proposed that I got a lot of

00:41:56,609 --> 00:42:00,569
resistance that people said no I need

00:41:58,890 --> 00:42:03,029
that don't take it away from me so

00:42:00,569 --> 00:42:04,829
that's still under discussion and it's

00:42:03,029 --> 00:42:08,039
sort of the more contentious one because

00:42:04,829 --> 00:42:10,349
here we really sort of with restricting

00:42:08,039 --> 00:42:12,359
things you could do where we restricting

00:42:10,349 --> 00:42:13,679
power whereas with this with these

00:42:12,359 --> 00:42:14,309
conversions you could say well that's

00:42:13,679 --> 00:42:16,469
just silly

00:42:14,309 --> 00:42:17,789
that's just essentially accidental

00:42:16,469 --> 00:42:19,109
things whereas with the other we do

00:42:17,789 --> 00:42:21,239
restrict power and the question is

00:42:19,109 --> 00:42:23,219
should we do that or not there's still

00:42:21,239 --> 00:42:27,390
an active discussion on on the dirty

00:42:23,219 --> 00:42:32,880
issue tracker okay now the next thing is

00:42:27,390 --> 00:42:36,029
reduce repetition so as I said implicit

00:42:32,880 --> 00:42:38,849
parameters are the canonical way to

00:42:36,029 --> 00:42:41,880
represent context and as such they're

00:42:38,849 --> 00:42:43,829
really important because the idea is

00:42:41,880 --> 00:42:46,079
that context abstraction is just

00:42:43,829 --> 00:42:48,150
parameter passing so it's the most

00:42:46,079 --> 00:42:50,670
natural thing you could have to say well

00:42:48,150 --> 00:42:52,439
if I need something then well lambda

00:42:50,670 --> 00:42:54,150
abstract make it a function pass the

00:42:52,439 --> 00:42:56,729
thing that you need is a parameter what

00:42:54,150 --> 00:42:58,829
could be more obvious and more natural

00:42:56,729 --> 00:43:01,559
than that and the only problem with that

00:42:58,829 --> 00:43:03,119
is that if you do that a lot and you end

00:43:01,559 --> 00:43:04,619
up with functions taking a lot of

00:43:03,119 --> 00:43:07,349
parameters and that gets very very

00:43:04,619 --> 00:43:09,299
tedious and so hence the idea to say

00:43:07,349 --> 00:43:11,429
well let's just not pass these

00:43:09,299 --> 00:43:13,469
parameters that's boilerplate anyways

00:43:11,429 --> 00:43:15,689
let's not pass them explicitly in the

00:43:13,469 --> 00:43:17,970
program implicit parameters will take

00:43:15,689 --> 00:43:20,609
care of that and that's essentially our

00:43:17,970 --> 00:43:24,270
solution to all of these problems okay

00:43:20,609 --> 00:43:27,450
so and that's really really successful

00:43:24,270 --> 00:43:29,690
so here's an example for instance what

00:43:27,450 --> 00:43:31,740
you could use implicit parameters for

00:43:29,690 --> 00:43:34,859
let's say we have a conference

00:43:31,740 --> 00:43:40,260
management system so like Scala days you

00:43:34,859 --> 00:43:42,210
submit your talk abstract and B to have

00:43:40,260 --> 00:43:44,280
a proper system you have certain

00:43:42,210 --> 00:43:46,319
conflicts of interest so certain

00:43:44,280 --> 00:43:48,480
reviewers should not see the scores of

00:43:46,319 --> 00:43:50,520
papers they have a conflict of interest

00:43:48,480 --> 00:43:52,109
with let's say you're an author and

00:43:50,520 --> 00:43:53,310
you're a reviewer maybe you don't want

00:43:52,109 --> 00:43:55,619
to see that you shouldn't see the

00:43:53,310 --> 00:43:57,569
reviews of all the other members that

00:43:55,619 --> 00:43:59,700
say your paper that's really crap we

00:43:57,569 --> 00:44:01,530
don't want to accept that because you

00:43:59,700 --> 00:44:03,450
might be offended so there there are

00:44:01,530 --> 00:44:05,369
certain rules in there and in big

00:44:03,450 --> 00:44:09,119
academic conferences they get very

00:44:05,369 --> 00:44:12,000
elaborate so one good way to do it is to

00:44:09,119 --> 00:44:14,730
say well let's abstract that into

00:44:12,000 --> 00:44:16,950
essentially an implicit parameter where

00:44:14,730 --> 00:44:19,020
we say with everything what we do like

00:44:16,950 --> 00:44:21,420
getting the score of a paper getting a

00:44:19,020 --> 00:44:24,599
ranking of a paper we essentially pass

00:44:21,420 --> 00:44:28,260
it the people that essentially currently

00:44:24,599 --> 00:44:30,720
view that want you that results you know

00:44:28,260 --> 00:44:32,730
about that result because you know the

00:44:30,720 --> 00:44:34,980
problem is it's not just as simple as

00:44:32,730 --> 00:44:37,319
looking up scores let's say you have a

00:44:34,980 --> 00:44:39,630
function like view rankings or the

00:44:37,319 --> 00:44:41,700
rankings like a list and you probably

00:44:39,630 --> 00:44:43,730
shouldn't see those either if you have a

00:44:41,700 --> 00:44:46,440
conflict so it's not just these speak

00:44:43,730 --> 00:44:49,500
not just the basic score but everything

00:44:46,440 --> 00:44:51,630
you derive from that really so the idea

00:44:49,500 --> 00:44:53,310
then is well everything takes viewers as

00:44:51,630 --> 00:44:55,319
implicit parameters and then this

00:44:53,310 --> 00:44:57,690
fundamental score function would say

00:44:55,319 --> 00:44:59,819
well if the viewers have a conflict with

00:44:57,690 --> 00:45:01,710
the authors then just make up a score

00:44:59,819 --> 00:45:03,900
minus 100 it would be in the bottom of

00:45:01,710 --> 00:45:05,970
the list but that conveys no information

00:45:03,900 --> 00:45:08,339
about this paper and otherwise you give

00:45:05,970 --> 00:45:11,369
the real score of the paper and then for

00:45:08,339 --> 00:45:13,530
instance rankings it's easy to get that

00:45:11,369 --> 00:45:15,720
wrong to say well just give it out and

00:45:13,530 --> 00:45:17,670
you leak information but with implicit

00:45:15,720 --> 00:45:20,609
parameters essentially the types tell

00:45:17,670 --> 00:45:23,760
you because you rankings essentially

00:45:20,609 --> 00:45:26,520
called score so it needs a viewers so

00:45:23,760 --> 00:45:28,800
the only way to get that is it that view

00:45:26,520 --> 00:45:30,109
rankings itself gets an implicit viewers

00:45:28,800 --> 00:45:32,930
and so on

00:45:30,109 --> 00:45:35,299
to the source of these things so why you

00:45:32,930 --> 00:45:37,249
might say well why haven't I - I have

00:45:35,299 --> 00:45:39,200
this additional abstraction viewers not

00:45:37,249 --> 00:45:41,539
just set of persons because it comes

00:45:39,200 --> 00:45:44,119
down to a set of persons in the end well

00:45:41,539 --> 00:45:46,099
the answer is that if you have want to

00:45:44,119 --> 00:45:48,099
make an implicit parameter you should

00:45:46,099 --> 00:45:50,690
make the type as specific as possible

00:45:48,099 --> 00:45:52,819
precisely in order to get no false

00:45:50,690 --> 00:45:55,249
positives that you essentially you can

00:45:52,819 --> 00:45:57,769
use this in some other situation where

00:45:55,249 --> 00:46:00,170
somebody wanted a set and suddenly get

00:45:57,769 --> 00:46:02,690
something implicitly so that's why I

00:46:00,170 --> 00:46:05,119
have essentially wrapped this in another

00:46:02,690 --> 00:46:08,630
very specific type called viewers that's

00:46:05,119 --> 00:46:10,670
used only for this application okay and

00:46:08,630 --> 00:46:13,579
that's a very nice way to handle it

00:46:10,670 --> 00:46:16,670
let's say dependency injection or

00:46:13,579 --> 00:46:18,109
configuration management or essentially

00:46:16,670 --> 00:46:20,089
you could treat that as some sort of

00:46:18,109 --> 00:46:22,190
capabilities a lot of these essentially

00:46:20,089 --> 00:46:24,319
covers a very large area what's nice

00:46:22,190 --> 00:46:26,839
about is because these things are

00:46:24,319 --> 00:46:29,690
parameters I can change them at any time

00:46:26,839 --> 00:46:32,869
so I'm not essentially forced to have

00:46:29,690 --> 00:46:35,089
always the same viewers so one thing I

00:46:32,869 --> 00:46:37,970
could for instance do is I could have a

00:46:35,089 --> 00:46:42,380
delegate method that says well I have a

00:46:37,970 --> 00:46:44,779
query and I want to delegate some tasks

00:46:42,380 --> 00:46:46,579
to this other persons and then

00:46:44,779 --> 00:46:49,369
essentially I run this query with the

00:46:46,579 --> 00:46:51,680
viewers of whatever it had before and

00:46:49,369 --> 00:46:53,660
the person I delegate to so if that

00:46:51,680 --> 00:46:55,579
person is a conflict and of course that

00:46:53,660 --> 00:46:56,989
person shouldn't see a paper so

00:46:55,579 --> 00:47:01,119
essentially the nice thing about is

00:46:56,989 --> 00:47:02,329
implicit is I say I get them for free

00:47:01,119 --> 00:47:04,789
everywhere

00:47:02,329 --> 00:47:06,710
except when I want to overwrite and then

00:47:04,789 --> 00:47:08,180
it's very easy because I just have to

00:47:06,710 --> 00:47:11,210
essentially give one parameter

00:47:08,180 --> 00:47:12,710
explicitly like it's done here this

00:47:11,210 --> 00:47:16,849
query thing that's the implicit

00:47:12,710 --> 00:47:20,779
parameter sorry yet the the viewers here

00:47:16,849 --> 00:47:25,130
that's given explicitly here okay so

00:47:20,779 --> 00:47:27,499
what's wrong with that well what's wrong

00:47:25,130 --> 00:47:29,839
is in a large system it gets very

00:47:27,499 --> 00:47:32,749
tedious to declare all these implicit

00:47:29,839 --> 00:47:36,499
viewers parameters you saw three on this

00:47:32,749 --> 00:47:40,369
slide that's maybe not so bad but if you

00:47:36,499 --> 00:47:42,140
continue then having to write implicit v

00:47:40,369 --> 00:47:43,320
as viewers a couple of time doesn't look

00:47:42,140 --> 00:47:45,650
so bad but

00:47:43,320 --> 00:47:48,810
the Dottie compiler there are more than

00:47:45,650 --> 00:47:51,720
2600 occurrences of the parameter in

00:47:48,810 --> 00:47:59,370
after of that very same parameter so it

00:47:51,720 --> 00:48:04,890
does get out of hands okay just note it

00:47:59,370 --> 00:48:08,990
that's actually not let me just try

00:48:04,890 --> 00:48:08,990
something about that

00:48:24,420 --> 00:48:28,039
Anana produced

00:48:29,150 --> 00:48:35,430
you

00:48:31,150 --> 00:48:35,430
right actually deleted the thing

00:48:46,060 --> 00:48:59,110
Diana Diana here because okay I okay

00:48:55,960 --> 00:49:01,000
sorry and this is getting worse and

00:48:59,110 --> 00:49:06,040
worse because I don't even have the

00:49:01,000 --> 00:49:08,760
latest one on this one okay I'll make do

00:49:06,040 --> 00:49:08,760
with what I have

00:49:21,230 --> 00:49:26,660
okay so in a large system it gets

00:49:25,040 --> 00:49:30,670
tedious to declare these viewers

00:49:26,660 --> 00:49:33,500
parameters and that gets worse as things

00:49:30,670 --> 00:49:36,650
grow bigger so in the dotty compiler

00:49:33,500 --> 00:49:38,780
itself we use this implicit pattern a

00:49:36,650 --> 00:49:40,880
lot because there's a thing called

00:49:38,780 --> 00:49:42,680
context which essentially contains

00:49:40,880 --> 00:49:45,740
everything the compiler has to know and

00:49:42,680 --> 00:49:48,470
we pass that everywhere so if you count

00:49:45,740 --> 00:49:51,470
them all up we have more than 2600

00:49:48,470 --> 00:49:53,840
occurrences of that parameter would be

00:49:51,470 --> 00:49:57,680
nice to get rid of them right so how

00:49:53,840 --> 00:50:01,130
could we do that so if we want to look

00:49:57,680 --> 00:50:03,290
for a solution then the first step to do

00:50:01,130 --> 00:50:08,140
is we can massage the definitions of

00:50:03,290 --> 00:50:10,550
view rankings a bit so you rankings

00:50:08,140 --> 00:50:12,620
essentially could be written instead of

00:50:10,550 --> 00:50:15,920
taking an implicit parameter it could be

00:50:12,620 --> 00:50:17,780
an implicit closure like this one so we

00:50:15,920 --> 00:50:20,960
just move the parameter from the left

00:50:17,780 --> 00:50:24,020
hand side to the right hand side okay

00:50:20,960 --> 00:50:25,850
and the body is exactly the same and you

00:50:24,020 --> 00:50:30,050
could say well what's the type of view

00:50:25,850 --> 00:50:33,440
rankings well so far that was a viewers

00:50:30,050 --> 00:50:35,630
- list of paper the result type of the

00:50:33,440 --> 00:50:38,390
body you could say well that's a shame

00:50:35,630 --> 00:50:40,430
the type doesn't express something

00:50:38,390 --> 00:50:42,350
that's fundamental here namely that

00:50:40,430 --> 00:50:45,500
implicit here whereas the implicit gun

00:50:42,350 --> 00:50:47,570
but it's no longer present in the type

00:50:45,500 --> 00:50:50,540
that the type is just a normal function

00:50:47,570 --> 00:50:53,360
so let's change that let's say from now

00:50:50,540 --> 00:50:55,550
on the type will be implicit viewers -

00:50:53,360 --> 00:50:58,430
list of paper so all we did was just to

00:50:55,550 --> 00:51:01,880
say well this thing is implicit or the

00:50:58,430 --> 00:51:04,730
sugar it would be since functions map to

00:51:01,880 --> 00:51:06,440
function one if you have an implicit

00:51:04,730 --> 00:51:09,790
here in front it would be implicit

00:51:06,440 --> 00:51:12,800
function one viewers list of paper okay

00:51:09,790 --> 00:51:15,080
so what is this implicit function one

00:51:12,800 --> 00:51:17,780
well that's just a version of function

00:51:15,080 --> 00:51:20,720
one you can think of it as a subtype and

00:51:17,780 --> 00:51:23,570
it has an apply method like function one

00:51:20,720 --> 00:51:25,910
is an apply method and the apply method

00:51:23,570 --> 00:51:29,240
takes an implicit parameter and that's

00:51:25,910 --> 00:51:32,450
it so it's really the same as function

00:51:29,240 --> 00:51:34,760
one so what rules do we have for typing

00:51:32,450 --> 00:51:38,530
the rules for typing again

00:51:34,760 --> 00:51:40,700
quite obvious so the first one says

00:51:38,530 --> 00:51:42,940
implicit functions get implicit

00:51:40,700 --> 00:51:46,550
arguments just like implicit methods do

00:51:42,940 --> 00:51:49,430
so that means if we have an implicit

00:51:46,550 --> 00:51:51,410
function value like this and we have an

00:51:49,430 --> 00:51:54,320
implicit Val that matches the type then

00:51:51,410 --> 00:51:57,530
if you write F it just expands to F of a

00:51:54,320 --> 00:52:00,260
that's basically just by analogy to what

00:51:57,530 --> 00:52:02,480
implicit methods are and the only new

00:52:00,260 --> 00:52:06,380
rule is really the second rule which

00:52:02,480 --> 00:52:12,260
says well if we we can create implicit

00:52:06,380 --> 00:52:15,710
functions on demand so if we have a body

00:52:12,260 --> 00:52:18,560
like B and the expected type of the body

00:52:15,710 --> 00:52:21,320
is implicit a of B and B is not yet an

00:52:18,560 --> 00:52:23,780
implicit closure then B expands to

00:52:21,320 --> 00:52:26,119
essentially this thing here so we say

00:52:23,780 --> 00:52:29,150
well the expected type is implicit a to

00:52:26,119 --> 00:52:31,400
B so let's give it a value of the type

00:52:29,150 --> 00:52:33,710
and the value would give if the way we

00:52:31,400 --> 00:52:36,680
construct this value is by saying well

00:52:33,710 --> 00:52:39,260
it's an implicit and then some parameter

00:52:36,680 --> 00:52:42,050
doesn't matter what the name is and give

00:52:39,260 --> 00:52:43,609
you give us back to B how do you get at

00:52:42,050 --> 00:52:46,550
the parameter if you don't know what the

00:52:43,609 --> 00:52:48,560
name is with implicitly of course so you

00:52:46,550 --> 00:52:51,740
have implicitly than an d function that

00:52:48,560 --> 00:52:53,450
just lets you pull out the the value

00:52:51,740 --> 00:52:56,720
here without actually having a concrete

00:52:53,450 --> 00:52:58,100
name for it okay so let's see what that

00:52:56,720 --> 00:53:01,880
could do to our conference management

00:52:58,100 --> 00:53:04,369
system so what I do what I'm going to do

00:53:01,880 --> 00:53:08,000
is I'm going to do a type definition

00:53:04,369 --> 00:53:10,730
called viewed of P which is implicit

00:53:08,000 --> 00:53:12,500
viewers - T so I just that's the nice

00:53:10,730 --> 00:53:15,020
thing about types I can abstract over

00:53:12,500 --> 00:53:19,430
them I can give them a name use only the

00:53:15,020 --> 00:53:22,580
name afterwards okay and then what I can

00:53:19,430 --> 00:53:24,560
do is I can essentially have my score

00:53:22,580 --> 00:53:27,500
function it doesn't need the implicit

00:53:24,560 --> 00:53:30,230
parameter anymore I just have instead a

00:53:27,500 --> 00:53:32,660
declared return type to say well it's a

00:53:30,230 --> 00:53:34,730
viewed of T of int so it's an intended

00:53:32,660 --> 00:53:37,460
viewed by some people and the people

00:53:34,730 --> 00:53:39,890
that view it are essentially the viewers

00:53:37,460 --> 00:53:42,350
in the implicit parameter and the rest

00:53:39,890 --> 00:53:44,359
of the code is exactly the same as

00:53:42,350 --> 00:53:46,580
before so what the compiler would do

00:53:44,359 --> 00:53:49,040
with that is to say viewed of int a hat

00:53:46,580 --> 00:53:51,230
that's an implicit function type so

00:53:49,040 --> 00:53:52,640
I have to turn this whole thing into an

00:53:51,230 --> 00:53:55,250
implicit closure and essentially

00:53:52,640 --> 00:53:58,010
implicitly declare the implicit

00:53:55,250 --> 00:54:01,870
parameter that gets passed into the body

00:53:58,010 --> 00:54:04,160
and the same thing for your rankings and

00:54:01,870 --> 00:54:06,650
delegate it's the same thing everywhere

00:54:04,160 --> 00:54:08,780
over there so what I would get for your

00:54:06,650 --> 00:54:13,160
rankings then is essentially that's what

00:54:08,780 --> 00:54:16,220
I write and that's where is it that's

00:54:13,160 --> 00:54:18,950
what the compiler would make out of it

00:54:16,220 --> 00:54:23,960
it would essentially pass this thing it

00:54:18,950 --> 00:54:26,480
create this thing implicitly okay

00:54:23,960 --> 00:54:29,840
so that turns out that this thing is

00:54:26,480 --> 00:54:31,550
actually very very efficient you could

00:54:29,840 --> 00:54:33,560
say well isn't there a problem with

00:54:31,550 --> 00:54:35,420
creating all these closures and indeed

00:54:33,560 --> 00:54:38,200
there would be but the compiler can

00:54:35,420 --> 00:54:40,990
actually detect that case and instead of

00:54:38,200 --> 00:54:44,360
essentially generating this code

00:54:40,990 --> 00:54:46,640
immediately give generating the implicit

00:54:44,360 --> 00:54:51,470
method directly so it can detect these

00:54:46,640 --> 00:54:53,420
things and rewrite to the method code so

00:54:51,470 --> 00:54:56,000
that means the code the cost of implicit

00:54:53,420 --> 00:54:58,490
functions is essentially exactly the

00:54:56,000 --> 00:55:01,550
same as the cost of implicit parameters

00:54:58,490 --> 00:55:04,600
which makes this implicit function type

00:55:01,550 --> 00:55:08,600
concept very competitive if you look at

00:55:04,600 --> 00:55:11,110
what current approaches are to this

00:55:08,600 --> 00:55:14,360
essentially injecting implicit

00:55:11,110 --> 00:55:16,760
parameters problem so the current

00:55:14,360 --> 00:55:18,860
probably most popular way to do it is

00:55:16,760 --> 00:55:20,270
essentially to get to become monadic to

00:55:18,860 --> 00:55:21,800
essentially say well we make them own

00:55:20,270 --> 00:55:23,600
out so you have to be in a monad and

00:55:21,800 --> 00:55:25,430
there's a simple model called the reader

00:55:23,600 --> 00:55:27,110
model that does basically what the

00:55:25,430 --> 00:55:29,600
implicit parameters do

00:55:27,110 --> 00:55:33,200
so it's essentially the implicit reading

00:55:29,600 --> 00:55:35,270
that I've shown you but in a monad so it

00:55:33,200 --> 00:55:37,730
has like the implicit function type the

00:55:35,270 --> 00:55:39,740
advantage that the reading is abstracted

00:55:37,730 --> 00:55:41,380
in a type that's why people used it so

00:55:39,740 --> 00:55:44,420
far I think that's the biggest advantage

00:55:41,380 --> 00:55:47,000
but I think it's shooting sparrows with

00:55:44,420 --> 00:55:49,970
cannons because monads in the end

00:55:47,000 --> 00:55:52,910
they're about sequencing and reading is

00:55:49,970 --> 00:55:54,410
not really so it doesn't you everybody

00:55:52,910 --> 00:55:56,780
reads the same thing it doesn't matter

00:55:54,410 --> 00:55:58,850
in what order people read the same thing

00:55:56,780 --> 00:56:01,520
so that means that we don't really need

00:55:58,850 --> 00:56:02,510
to go to the straightjacket of one thing

00:56:01,520 --> 00:56:05,270
after another

00:56:02,510 --> 00:56:07,370
the four or whatever monadic flatmap we

00:56:05,270 --> 00:56:09,920
can use direct style which is much nicer

00:56:07,370 --> 00:56:12,470
we can use for power of essentially all

00:56:09,920 --> 00:56:15,320
our expressions in Scala and still get

00:56:12,470 --> 00:56:16,970
the reader injection very nice so

00:56:15,320 --> 00:56:19,220
implicit function types give you the

00:56:16,970 --> 00:56:20,570
conciseness of the reader monad but they

00:56:19,220 --> 00:56:23,240
don't force you in the inter monadic

00:56:20,570 --> 00:56:26,240
style they're fully composable which

00:56:23,240 --> 00:56:27,710
monitors are not and they are according

00:56:26,240 --> 00:56:30,050
to measurements more than seven times

00:56:27,710 --> 00:56:32,780
faster than the rhythm oh not so big

00:56:30,050 --> 00:56:37,190
wind eh okay so I just want to finish

00:56:32,780 --> 00:56:39,530
with one last thing and just to show

00:56:37,190 --> 00:56:41,000
that if essentially I tried to argument

00:56:39,530 --> 00:56:43,670
that implicit Saar fundamental

00:56:41,000 --> 00:56:45,550
abstracting over implicit is something

00:56:43,670 --> 00:56:49,640
that essentially gives you very

00:56:45,550 --> 00:56:52,190
principled power and as always this

00:56:49,640 --> 00:56:54,950
power can be used in interesting and fun

00:56:52,190 --> 00:56:57,950
and surprising applications so one

00:56:54,950 --> 00:57:00,140
application is stumbled across was the

00:56:57,950 --> 00:57:02,000
so-called Builder pattern builder

00:57:00,140 --> 00:57:04,430
pattern is I think it's been popularized

00:57:02,000 --> 00:57:07,070
by groovy maybe Ruby I'm not sure

00:57:04,430 --> 00:57:09,560
Catalan as well and essentially they

00:57:07,070 --> 00:57:10,700
have these certainly groovy and Kotlin

00:57:09,560 --> 00:57:12,320
they have specialized language

00:57:10,700 --> 00:57:14,480
constructs in coddling it's called

00:57:12,320 --> 00:57:16,940
receiver function that handles this

00:57:14,480 --> 00:57:18,920
thing so bill have happen is that we can

00:57:16,940 --> 00:57:20,810
write a table like this so you have a

00:57:18,920 --> 00:57:23,930
table and the row and then you have

00:57:20,810 --> 00:57:25,910
cells and in these rows and you get what

00:57:23,930 --> 00:57:28,160
you would expect a two-dimensional table

00:57:25,910 --> 00:57:33,200
so it's a nice way to have a DSL to

00:57:28,160 --> 00:57:34,910
construct things so once I saw that I

00:57:33,200 --> 00:57:36,740
said well implicit function types can

00:57:34,910 --> 00:57:39,260
they solve this problem and in defects

00:57:36,740 --> 00:57:40,850
can solve it in a very nice way so

00:57:39,260 --> 00:57:43,160
here's how we would solve this put thing

00:57:40,850 --> 00:57:46,160
with implicit function types so we would

00:57:43,160 --> 00:57:50,300
say okay let's maybe look at cell first

00:57:46,160 --> 00:57:53,510
so a cell thing what this does is if we

00:57:50,300 --> 00:57:56,840
look back obviously I mean these are all

00:57:53,510 --> 00:58:00,920
blocks so these things all in a sense

00:57:56,840 --> 00:58:03,440
add themselves to essentially their that

00:58:00,920 --> 00:58:06,950
the thing in their environment so you

00:58:03,440 --> 00:58:11,870
would have here a row let's start with a

00:58:06,950 --> 00:58:13,370
row and you would say okay we know let

00:58:11,870 --> 00:58:15,470
this start with a cell the cell would

00:58:13,370 --> 00:58:16,340
say okay let's define a cell and once

00:58:15,470 --> 00:58:19,460
it's defined

00:58:16,340 --> 00:58:21,590
add the cells to the row in which the

00:58:19,460 --> 00:58:23,540
cell is defined and this row is an

00:58:21,590 --> 00:58:26,360
implicit parameter so that's the trick

00:58:23,540 --> 00:58:27,800
here so what does a row then do so a

00:58:26,360 --> 00:58:30,740
roses okay

00:58:27,800 --> 00:58:34,280
let's define a new row and then call the

00:58:30,740 --> 00:58:38,630
init method and the init method it takes

00:58:34,280 --> 00:58:41,000
an implicit function from row to unit so

00:58:38,630 --> 00:58:44,300
essentially the thing I pass it in the

00:58:41,000 --> 00:58:46,700
init knows how to expect the row and

00:58:44,300 --> 00:58:48,590
will essentially add itself to the role

00:58:46,700 --> 00:58:51,290
so it calls the init function and then

00:58:48,590 --> 00:58:52,880
we add the row in turn to the table and

00:58:51,290 --> 00:58:55,040
the table does essentially the same

00:58:52,880 --> 00:58:57,380
thing it expects an init which is again

00:58:55,040 --> 00:59:00,770
it's an implicit function create a new

00:58:57,380 --> 00:59:05,470
table runs in it which adds the rows and

00:59:00,770 --> 00:59:08,120
then finally returns the table so here

00:59:05,470 --> 00:59:10,310
what I have here that essentially every

00:59:08,120 --> 00:59:12,650
cell gets the enclosing row as an

00:59:10,310 --> 00:59:14,750
implicit parameter and every row gets

00:59:12,650 --> 00:59:18,710
the enclosing table as an implicit

00:59:14,750 --> 00:59:22,340
parameter okay so that brings me to the

00:59:18,710 --> 00:59:24,080
end of the presentation I have here on

00:59:22,340 --> 00:59:27,140
the slides unfortunately read the rest

00:59:24,080 --> 00:59:28,520
this has been taken down at at the

00:59:27,140 --> 00:59:33,610
beginning of the talk so I just

00:59:28,520 --> 00:59:38,300
essentially wrap up speaking freely so

00:59:33,610 --> 00:59:41,150
the so that's what we have I gave you a

00:59:38,300 --> 00:59:45,910
quick run down to what dot e currently

00:59:41,150 --> 00:59:47,780
is I promise that we will break things

00:59:45,910 --> 00:59:51,400
at a fast pace

00:59:47,780 --> 00:59:53,930
in the future so that that means that

00:59:51,400 --> 00:59:55,850
dot e currently is definitely not

00:59:53,930 --> 00:59:58,430
production-ready it's there for

00:59:55,850 --> 01:00:00,830
experimentation it's there to

00:59:58,430 --> 01:00:03,470
essentially be there are several other

01:00:00,830 --> 01:00:06,260
features we wanted to add and to develop

01:00:03,470 --> 01:00:09,260
but if you are in for essentially a

01:00:06,260 --> 01:00:11,870
cutting edge thing to say I want to try

01:00:09,260 --> 01:00:12,680
it out I want to maybe contribute to the

01:00:11,870 --> 01:00:15,350
development

01:00:12,680 --> 01:00:18,710
I want to shape the future of what Scala

01:00:15,350 --> 01:00:21,950
is I think now is a great moment to to

01:00:18,710 --> 01:00:25,630
jump in I should like to thank all our

01:00:21,950 --> 01:00:27,450
contributors that first the EPFL team

01:00:25,630 --> 01:00:31,110
most

01:00:27,450 --> 01:00:33,750
Dimitri Payet Ashcombe mattress and many

01:00:31,110 --> 01:00:35,790
many others and it's also the light

01:00:33,750 --> 01:00:37,920
pants gala team that with whom we have

01:00:35,790 --> 01:00:41,100
been in regular contact about

01:00:37,920 --> 01:00:44,310
essentially advice how to do things and

01:00:41,100 --> 01:00:47,280
I expect that as we shape up things

01:00:44,310 --> 01:00:49,770
towards Scala 3 we will work closer and

01:00:47,280 --> 01:00:53,490
closer together to make that happen

01:00:49,770 --> 01:00:55,380
thank you very much and I'm sorry that

01:00:53,490 --> 01:00:57,420
we had all these breakages in this talk

01:00:55,380 --> 01:00:58,230
and thanks for staying with me through

01:00:57,420 --> 01:01:05,940
them

01:00:58,230 --> 01:01:05,940

YouTube URL: https://www.youtube.com/watch?v=9lWrt6H6UdE


