Title: Herding types with Scala macros   by Marina Sigaeva
Publication date: 2017-06-07
Playlist: Scala Days 2017
Description: 
	This talk was recorded at Scala Days Chicago, 2017. Follow along on Twitter @scaladays and on the website for more information http://scaladays.org/.

Abstract:
In Scala we use the term "type safety", but what it really means? In short, most applications model data types in a form suitable for storage, change, transmission, and use. During the life cycle of the data, we expect to always use the declared type. But reality is a bit more complicated. One of the main practical problems with the use of types occurs when our application interacts with outside world - in requests to external services, different databases or simply with getting data from file. In most cases, an attempt to support type safety leads to writing a lot of code that we always try to avoid. Fortunately we have macros to do all routine job for us! In this talk we will discuss how to use compile-time reflection in library for schemaless key-value database and the benefits of use of macros in production systems.
Captions: 
	00:00:00,030 --> 00:00:08,639
okay hi everyone thanks for coming and

00:00:04,290 --> 00:00:10,800
welcome to heaven Texas kalamarez I'm

00:00:08,639 --> 00:00:13,349
marina and I'm a culture engineer

00:00:10,800 --> 00:00:16,590
working on scallops for a couple of

00:00:13,349 --> 00:00:19,020
years before that I was a student and

00:00:16,590 --> 00:00:22,650
didn't know about collateral so I

00:00:19,020 --> 00:00:24,630
basically started my career scholar but

00:00:22,650 --> 00:00:27,269
the end of the stroke you have an

00:00:24,630 --> 00:00:30,269
understanding of how to use color macros

00:00:27,269 --> 00:00:34,290
to work with stimulus given your data

00:00:30,269 --> 00:00:37,440
storage you will know how I came up with

00:00:34,290 --> 00:00:39,800
that idea and how I can help you to

00:00:37,440 --> 00:00:44,850
reduce random errors in your

00:00:39,800 --> 00:00:48,149
applications now to the topic of the

00:00:44,850 --> 00:00:50,690
talk we can use Kimmel is giving me

00:00:48,149 --> 00:00:53,850
storages to build distributed cache or

00:00:50,690 --> 00:00:57,449
for the test when we need fast response

00:00:53,850 --> 00:01:01,170
from the database it's also often you

00:00:57,449 --> 00:01:04,100
can be data at some times there is no

00:01:01,170 --> 00:01:07,080
scholar library available for us and

00:01:04,100 --> 00:01:09,299
when all you need to do is add a couple

00:01:07,080 --> 00:01:12,090
of operations with particular database

00:01:09,299 --> 00:01:14,520
you will not spend the time readiness to

00:01:12,090 --> 00:01:17,520
driver you will just take what's out

00:01:14,520 --> 00:01:20,900
there and usually we end up with the

00:01:17,520 --> 00:01:23,340
most popular versions written in Java

00:01:20,900 --> 00:01:25,920
but we can work with a stress being

00:01:23,340 --> 00:01:28,979
completed with everything like to use

00:01:25,920 --> 00:01:31,560
change color and today we will try to

00:01:28,979 --> 00:01:33,420
solve that problem and the tentative

00:01:31,560 --> 00:01:34,350
Boojum others strongly typed language

00:01:33,420 --> 00:01:36,570
right

00:01:34,350 --> 00:01:41,939
Retin a small library on scholar

00:01:36,570 --> 00:01:44,100
Mockridge as a test at your spike but

00:01:41,939 --> 00:01:47,899
this approach can be used for others

00:01:44,100 --> 00:01:50,340
accumulates curative storages I

00:01:47,899 --> 00:01:51,950
undertook some research look through

00:01:50,340 --> 00:01:54,869
different libraries

00:01:51,950 --> 00:01:57,950
tried different implementations and

00:01:54,869 --> 00:02:04,140
today I'm going to show you my solution

00:01:57,950 --> 00:02:06,600
so roadmap birthday skirt I would like

00:02:04,140 --> 00:02:09,360
to tell you about earth bike and how we

00:02:06,600 --> 00:02:13,210
start stating it

00:02:09,360 --> 00:02:15,190
after I will explain what I think Emily

00:02:13,210 --> 00:02:17,800
is cute that the third each other has to

00:02:15,190 --> 00:02:21,850
do and why's it so important to operate

00:02:17,800 --> 00:02:25,480
with types in Scala and finally I will

00:02:21,850 --> 00:02:28,870
show you my solution for this interest

00:02:25,480 --> 00:02:31,120
implemented ways kalamarez my chart will

00:02:28,870 --> 00:02:35,890
take about 30 minutes and I will leave

00:02:31,120 --> 00:02:39,550
time at the end for the question so

00:02:35,890 --> 00:02:42,700
every spike isn't skinny storage it is

00:02:39,550 --> 00:02:45,840
when you need to change type of the data

00:02:42,700 --> 00:02:49,300
you don't have to modify schema

00:02:45,840 --> 00:02:51,940
namespace set and bin are three

00:02:49,300 --> 00:02:56,920
essential contests here related to data

00:02:51,940 --> 00:03:00,280
storage whether the record data can be

00:02:56,920 --> 00:03:04,750
stored in one or main event they all can

00:03:00,280 --> 00:03:07,900
have same type or different types for

00:03:04,750 --> 00:03:11,440
example for the record ID with a string

00:03:07,900 --> 00:03:12,850
value Bob the value of this unit can

00:03:11,440 --> 00:03:16,870
always change to a different string

00:03:12,850 --> 00:03:23,140
value by cha or even two different data

00:03:16,870 --> 00:03:27,160
types like integers all fans can see any

00:03:23,140 --> 00:03:33,190
native data support types like string in

00:03:27,160 --> 00:03:36,010
map and so on working with a gorgeous

00:03:33,190 --> 00:03:39,780
like this one could be tricky because it

00:03:36,010 --> 00:03:43,500
has no schemes it means when you create

00:03:39,780 --> 00:03:47,560
go to model and here it's a bunny and

00:03:43,500 --> 00:03:50,650
when you store it and when the next step

00:03:47,560 --> 00:03:53,980
is to get that you have stored years gem

00:03:50,650 --> 00:03:55,570
hell and dark recently unexpected this

00:03:53,980 --> 00:03:58,810
happens because you don't know what

00:03:55,570 --> 00:04:00,970
exactly you will get because in case the

00:03:58,810 --> 00:04:03,550
doors bite the treasure it doesn't

00:04:00,970 --> 00:04:06,160
provide you such information it gives

00:04:03,550 --> 00:04:08,980
your record with some object and you

00:04:06,160 --> 00:04:13,690
have to get whatever user and try to

00:04:08,980 --> 00:04:17,140
cast its into expected type like we get

00:04:13,690 --> 00:04:19,060
what all possible problems here but we

00:04:17,140 --> 00:04:21,609
can reduce the probability of obtaining

00:04:19,060 --> 00:04:27,729
them by generating partial to the

00:04:21,609 --> 00:04:30,849
I'll time the only thing we have to

00:04:27,729 --> 00:04:34,270
connect to a respite from Scala is the

00:04:30,849 --> 00:04:36,370
driver written in Java to get bunnies

00:04:34,270 --> 00:04:39,520
instead of the on kids who have to write

00:04:36,370 --> 00:04:41,319
a lot of code with it and let's take a

00:04:39,520 --> 00:04:45,699
look at the shows shows you'll

00:04:41,319 --> 00:04:48,099
understand what I mean you know I love

00:04:45,699 --> 00:04:50,469
to read all of my free time as

00:04:48,099 --> 00:04:53,530
friendless classics like Oscar Wilde in

00:04:50,469 --> 00:04:56,289
charge taken but I don't like to read

00:04:53,530 --> 00:04:59,319
war and peace in Scala when I'm a Taurus

00:04:56,289 --> 00:05:01,659
you won't believe it but all these hell

00:04:59,319 --> 00:05:03,699
does is just writing a couple different

00:05:01,659 --> 00:05:06,759
values with you in case into storage and

00:05:03,699 --> 00:05:10,210
unbreathing it I think it's too much for

00:05:06,759 --> 00:05:13,150
such a simple operations statically it

00:05:10,210 --> 00:05:17,529
does everything but if you presented

00:05:13,150 --> 00:05:20,340
other ways like more Scala wait I want

00:05:17,529 --> 00:05:23,259
something more simple for like that

00:05:20,340 --> 00:05:26,050
these show does exactly as the previous

00:05:23,259 --> 00:05:30,039
one but it looks better and doesn't take

00:05:26,050 --> 00:05:33,490
a lifetime to read it this all is quite

00:05:30,039 --> 00:05:36,159
safe now shaking snow sterilizers no

00:05:33,490 --> 00:05:38,889
other of your flakes just a simple

00:05:36,159 --> 00:05:41,770
application and you can see what exactly

00:05:38,889 --> 00:05:44,520
is going on but you have stored into

00:05:41,770 --> 00:05:47,169
storage and like you will get in return

00:05:44,520 --> 00:05:50,319
if someone gains in such a library six

00:05:47,169 --> 00:05:52,150
months ago the Great Hall and probably

00:05:50,319 --> 00:05:58,229
wouldn't be here today so I guess I'm

00:05:52,150 --> 00:06:02,860
like it so let's start with storing data

00:05:58,229 --> 00:06:04,449
this doors doesn't have skin so to start

00:06:02,860 --> 00:06:07,110
a couple different ways with different

00:06:04,449 --> 00:06:11,949
keys will have to create a client and

00:06:07,110 --> 00:06:14,650
prepare key and B inverse gel acquired

00:06:11,949 --> 00:06:18,219
provides several constructors for keys

00:06:14,650 --> 00:06:22,509
and bands seven types of keys and 12

00:06:18,219 --> 00:06:26,319
types of fence so as you can see more

00:06:22,509 --> 00:06:31,000
attachment Marko's but we're in Fela and

00:06:26,319 --> 00:06:32,650
we have we can use any type of one we

00:06:31,000 --> 00:06:35,710
have plenty of choices from

00:06:32,650 --> 00:06:38,110
just like in stream and so on Temari

00:06:35,710 --> 00:06:40,600
complicated ones like collections of

00:06:38,110 --> 00:06:43,150
students to attract her forever but it's

00:06:40,600 --> 00:06:48,130
worth there is actually no limit and we

00:06:43,150 --> 00:06:52,060
want to write less code so imagine we

00:06:48,130 --> 00:06:54,280
wrote all data into storage and all

00:06:52,060 --> 00:06:57,940
values were converted into the internal

00:06:54,280 --> 00:06:59,949
directed format but if storage along

00:06:57,940 --> 00:07:04,030
with its dark lines has lot less types

00:06:59,949 --> 00:07:07,360
and scholars occurs for example in chars

00:07:04,030 --> 00:07:11,740
Boleyn and bytes will be stored as long

00:07:07,360 --> 00:07:13,750
value for a double and so on but we

00:07:11,740 --> 00:07:17,410
still have to return the exact type is

00:07:13,750 --> 00:07:19,270
restored not the one in the game the

00:07:17,410 --> 00:07:22,050
thing is with a lot to choose how to

00:07:19,270 --> 00:07:24,669
store information which is applied Fred

00:07:22,050 --> 00:07:28,030
take a look at the small bug here an

00:07:24,669 --> 00:07:30,430
ageless is very traditional class which

00:07:28,030 --> 00:07:32,139
is a magical lamp couple it's basically

00:07:30,430 --> 00:07:35,650
a collection of values of different

00:07:32,139 --> 00:07:38,680
types in case with this storage where

00:07:35,650 --> 00:07:40,599
then can help different values with

00:07:38,680 --> 00:07:43,510
different types I think in each layers

00:07:40,599 --> 00:07:46,270
to the perfect pet and I decided to

00:07:43,510 --> 00:07:49,419
start this magic map value in the

00:07:46,270 --> 00:07:50,310
storage I also did the same for the key

00:07:49,419 --> 00:07:52,870
squatches

00:07:50,310 --> 00:07:55,330
for example case cost cash will be

00:07:52,870 --> 00:07:58,440
stored as a native map as well where

00:07:55,330 --> 00:08:01,560
keys will be the name of this self and

00:07:58,440 --> 00:08:05,530
values the values of the self

00:08:01,560 --> 00:08:09,729
so we start everything and now we know

00:08:05,530 --> 00:08:12,930
how to apply inside the storage so all

00:08:09,729 --> 00:08:15,970
of our you will just get the information

00:08:12,930 --> 00:08:19,680
which is a simple operation and what can

00:08:15,970 --> 00:08:22,360
be easier a well not this one

00:08:19,680 --> 00:08:26,409
now I have to spend time choosing the

00:08:22,360 --> 00:08:28,090
right get function it doesn't have

00:08:26,409 --> 00:08:30,639
enough problems with speaking of address

00:08:28,090 --> 00:08:31,360
I mean phalluses listener something

00:08:30,639 --> 00:08:34,270
unreadable

00:08:31,360 --> 00:08:37,209
nobody has to suffer this much here

00:08:34,270 --> 00:08:40,150
enjoy engineers all I want to do is get

00:08:37,209 --> 00:08:43,270
one straight from the storage is that

00:08:40,150 --> 00:08:46,800
your rights dragged certain methods and

00:08:43,270 --> 00:08:49,300
that's not all of my problems

00:08:46,800 --> 00:08:51,820
these matters will return me an object

00:08:49,300 --> 00:08:55,060
and I will have to write button

00:08:51,820 --> 00:08:59,070
functions for every possible type which

00:08:55,060 --> 00:09:02,590
is a lot of work okay

00:08:59,070 --> 00:09:06,790
we know that our spikes store data in

00:09:02,590 --> 00:09:09,310
records and this is the record that gate

00:09:06,790 --> 00:09:11,950
function will return I take a look at

00:09:09,310 --> 00:09:14,890
this model you remember the gunky that

00:09:11,950 --> 00:09:17,110
we got from the cylinder that map of

00:09:14,890 --> 00:09:20,100
string object is neither ranked in albon

00:09:17,110 --> 00:09:23,260
yet it's some strange animals with years

00:09:20,100 --> 00:09:25,470
but I think once I find a bag and I will

00:09:23,260 --> 00:09:27,700
have to work for it

00:09:25,470 --> 00:09:31,570
imagine we've done we have done

00:09:27,700 --> 00:09:34,540
everything and still after all we're on

00:09:31,570 --> 00:09:36,430
all flesh and great functions we still

00:09:34,540 --> 00:09:39,850
have to write a lot of code with it to

00:09:36,430 --> 00:09:42,520
get data of the expected type but when

00:09:39,850 --> 00:09:44,500
we provide type space interface it means

00:09:42,520 --> 00:09:48,880
that application of functions should be

00:09:44,500 --> 00:09:51,750
short and simple should be like this it

00:09:48,880 --> 00:09:55,270
works this is how I say it

00:09:51,750 --> 00:09:58,480
so right exactly schema-less kilowatts

00:09:55,270 --> 00:10:01,990
towards each other has to do first I

00:09:58,480 --> 00:10:05,020
think the idea of the client itself has

00:10:01,990 --> 00:10:07,930
to be more concise and have a

00:10:05,020 --> 00:10:09,940
user-friendly interface in my opinion

00:10:07,930 --> 00:10:14,170
the let's use our things before actually

00:10:09,940 --> 00:10:17,080
using the better secondly I think it has

00:10:14,170 --> 00:10:18,460
to take care of civilization internet

00:10:17,080 --> 00:10:20,710
the screen is with hundred different

00:10:18,460 --> 00:10:22,750
libraries and ways to sterilize objects

00:10:20,710 --> 00:10:24,520
I mean there has been brother and

00:10:22,750 --> 00:10:27,310
library to transfer key squads in

00:10:24,520 --> 00:10:29,470
saturation and vice versa not to mention

00:10:27,310 --> 00:10:32,920
operating the data inside applications

00:10:29,470 --> 00:10:35,230
code base every day we have to face that

00:10:32,920 --> 00:10:38,350
translation problem especially when it

00:10:35,230 --> 00:10:42,160
comes to chat a library and finally I

00:10:38,350 --> 00:10:46,000
think it has to work out of the box ok

00:10:42,160 --> 00:10:49,780
and now we can try to move in that

00:10:46,000 --> 00:10:53,170
direction and see what we can do to

00:10:49,780 --> 00:10:57,060
build the dream driver so for

00:10:53,170 --> 00:10:59,230
implementation take a look at the slide

00:10:57,060 --> 00:11:01,750
we have here function

00:10:59,230 --> 00:11:05,700
that knows what to do with keys and

00:11:01,750 --> 00:11:09,130
Vince in types s Manas keep in mind that

00:11:05,700 --> 00:11:12,220
there is a number of actions that we can

00:11:09,130 --> 00:11:14,440
do with the storage like add delete and

00:11:12,220 --> 00:11:18,670
so on and we have the first parameter

00:11:14,440 --> 00:11:21,280
for that I want to call key and then

00:11:18,670 --> 00:11:23,770
creation functions every time so I

00:11:21,280 --> 00:11:27,520
decided to delegate that Jocelyn places

00:11:23,770 --> 00:11:29,500
and key and bin brothers so I could just

00:11:27,520 --> 00:11:31,780
pass particular values of any type of

00:11:29,500 --> 00:11:35,170
one and let those implicit to all

00:11:31,780 --> 00:11:38,020
transformations for me so where exactly

00:11:35,170 --> 00:11:40,510
is happens of the skills and places

00:11:38,020 --> 00:11:43,330
let's call the function that will put

00:11:40,510 --> 00:11:46,570
one string value with a string key into

00:11:43,330 --> 00:11:49,600
storage but it actually happens here is

00:11:46,570 --> 00:11:53,260
that values of brevis of type string or

00:11:49,600 --> 00:11:56,080
during the in their places it means that

00:11:53,260 --> 00:11:58,090
they happen to be in this code otherwise

00:11:56,080 --> 00:12:02,170
you will have an exception which says

00:11:58,090 --> 00:12:04,090
that simpliciter missing and now we can

00:12:02,170 --> 00:12:07,210
define hood and get functions with that

00:12:04,090 --> 00:12:13,750
smart function to make our API more

00:12:07,210 --> 00:12:16,570
concise so to avoid all recent implicit

00:12:13,750 --> 00:12:19,120
exceptions we will have to define

00:12:16,570 --> 00:12:22,570
breakfast a little start with the key

00:12:19,120 --> 00:12:25,150
brother to type key an instance of this

00:12:22,570 --> 00:12:28,060
helper has to appear everywhere where

00:12:25,150 --> 00:12:29,770
you communicate with the storage so the

00:12:28,060 --> 00:12:33,850
address you will have to write down more

00:12:29,770 --> 00:12:35,860
to rather with different types but I

00:12:33,850 --> 00:12:39,820
don't know what I will use in the future

00:12:35,860 --> 00:12:43,980
like dreams teens or collection of cats

00:12:39,820 --> 00:12:47,740
and I want to write more code every time

00:12:43,980 --> 00:12:49,330
so this is one of those moments when you

00:12:47,740 --> 00:12:51,970
really want to leave them Center or

00:12:49,330 --> 00:12:54,700
someone else we can use all that job for

00:12:51,970 --> 00:12:57,670
you and like you for me there is some

00:12:54,700 --> 00:13:01,750
magic that can help there are markers

00:12:57,670 --> 00:13:04,390
heads so what is it Roberts and Scala

00:13:01,750 --> 00:13:06,730
allowed to create sections of code the

00:13:04,390 --> 00:13:09,400
compile time they're based in the

00:13:06,730 --> 00:13:11,800
contacts clause an instance of the class

00:13:09,400 --> 00:13:12,789
is always fast to the macro to an

00:13:11,800 --> 00:13:15,679
expansion

00:13:12,789 --> 00:13:18,079
then you can invert the universe object

00:13:15,679 --> 00:13:19,999
and request descriptive search types in

00:13:18,079 --> 00:13:23,779
methods and so on it's like layers in

00:13:19,999 --> 00:13:26,179
runtime reflection so basically macro

00:13:23,779 --> 00:13:29,899
just a function that accepts Center

00:13:26,179 --> 00:13:32,209
Street and returns to change one I'm a

00:13:29,899 --> 00:13:34,159
big fan of the cold chain if you have

00:13:32,209 --> 00:13:36,439
worked with scholars viewers calipers

00:13:34,159 --> 00:13:39,439
web plugins those are my favorite and

00:13:36,439 --> 00:13:42,969
the idea of Mars planet exciting for me

00:13:39,439 --> 00:13:45,979
but every magic trick has a break and

00:13:42,969 --> 00:13:49,129
after Center streams should contain

00:13:45,979 --> 00:13:51,949
every feature of Scala and one of the

00:13:49,129 --> 00:13:55,479
drawback of Margaret is that description

00:13:51,949 --> 00:13:59,029
of the tree can be not too easy to read

00:13:55,479 --> 00:14:01,209
for example code fragments 1+1

00:13:59,029 --> 00:14:03,769
generation should look like this and

00:14:01,209 --> 00:14:05,419
things get worse when we need to present

00:14:03,769 --> 00:14:08,899
logic pieces of code with the

00:14:05,419 --> 00:14:11,809
substitution of complete but like it for

00:14:08,899 --> 00:14:15,919
us in Scala 211 visual read is solved

00:14:11,809 --> 00:14:18,619
and we have quite a close and our 1+1

00:14:15,919 --> 00:14:21,079
will look a lot more simple in general

00:14:18,619 --> 00:14:23,119
quite equal to just a set of strengths

00:14:21,079 --> 00:14:26,389
interpolators that are obligated in

00:14:23,119 --> 00:14:28,519
numerous objects once union vertex goes

00:14:26,389 --> 00:14:30,529
into the current scope and then you can

00:14:28,519 --> 00:14:32,629
use the series of characters fourth

00:14:30,529 --> 00:14:35,839
string constants which will determine

00:14:32,629 --> 00:14:39,169
how the compiler will handle it so it's

00:14:35,839 --> 00:14:41,359
basically relates to the tree and now

00:14:39,169 --> 00:14:46,579
identifying key wrapper with quite a

00:14:41,359 --> 00:14:48,949
close macro materialize the reception

00:14:46,579 --> 00:14:50,959
here is the way to get description of

00:14:48,949 --> 00:14:54,009
the type key for the method from

00:14:50,959 --> 00:14:54,009
universe object

00:14:54,309 --> 00:15:01,579
marker here is an implicit which we also

00:14:57,919 --> 00:15:03,439
know means that an instance of any type

00:15:01,579 --> 00:15:08,659
of key rather will appear in the right

00:15:03,439 --> 00:15:11,119
place when it's necessary by itself one

00:15:08,659 --> 00:15:14,629
more thing if you need some extra

00:15:11,119 --> 00:15:16,879
packages to make sure your work it will

00:15:14,629 --> 00:15:18,709
have to provide those in the scope when

00:15:16,879 --> 00:15:23,179
you do the instance that's very

00:15:18,709 --> 00:15:25,360
important so what will happen when we

00:15:23,179 --> 00:15:29,170
try to call

00:15:25,360 --> 00:15:33,940
matera lies port type strain so we will

00:15:29,170 --> 00:15:36,579
have to to create the wrapper of the

00:15:33,940 --> 00:15:40,290
type strain this is a piece of the

00:15:36,579 --> 00:15:43,560
compiler code and compile time an

00:15:40,290 --> 00:15:47,320
instance of key brother of type string

00:15:43,560 --> 00:15:51,250
both we created exactly as we wanted

00:15:47,320 --> 00:15:54,040
with all inverse methods and values so

00:15:51,250 --> 00:15:57,370
that instance will be ready to use it in

00:15:54,040 --> 00:15:59,950
the curse cope and what is actually

00:15:57,370 --> 00:16:03,550
happens when we call materialize for

00:15:59,950 --> 00:16:05,529
different types instances of key

00:16:03,550 --> 00:16:08,620
brother's of different types like string

00:16:05,529 --> 00:16:11,380
in edgelits and so on will be generated

00:16:08,620 --> 00:16:14,019
at the compile time so it's not exactly

00:16:11,380 --> 00:16:19,540
a magic but the code is there and

00:16:14,019 --> 00:16:22,810
compiler wrote it for you and now is the

00:16:19,540 --> 00:16:26,709
most interesting part revenge and this

00:16:22,810 --> 00:16:29,019
is a simple trade it's very similar to

00:16:26,709 --> 00:16:31,300
your key brothers but there is also a

00:16:29,019 --> 00:16:34,060
mouth type because we have to get

00:16:31,300 --> 00:16:36,490
information from the storage for that we

00:16:34,060 --> 00:16:39,160
have an apply function that accepts the

00:16:36,490 --> 00:16:40,600
records and returns the value of the

00:16:39,160 --> 00:16:44,050
expected types with some meta

00:16:40,600 --> 00:16:46,449
information the difference between type

00:16:44,050 --> 00:16:49,690
here will be in this very important

00:16:46,449 --> 00:16:51,670
function search where we check the type

00:16:49,690 --> 00:16:56,019
and getting the value of the expected

00:16:51,670 --> 00:16:59,230
type and this is the bin browser macro

00:16:56,019 --> 00:17:02,110
it's also implicit also very similar to

00:16:59,230 --> 00:17:04,419
to brother since the difference between

00:17:02,110 --> 00:17:08,500
type here will be in this one function

00:17:04,419 --> 00:17:12,549
we can insert particles with type taking

00:17:08,500 --> 00:17:14,980
into karate quote and one more thing you

00:17:12,549 --> 00:17:17,319
can use everything of with my process

00:17:14,980 --> 00:17:20,980
even from other packages all you need to

00:17:17,319 --> 00:17:23,709
do is just import those into the macro

00:17:20,980 --> 00:17:29,590
creation or directly in a file or you

00:17:23,709 --> 00:17:33,250
use that instance so in a fetch function

00:17:29,590 --> 00:17:35,559
will compare a there is also risk of all

00:17:33,250 --> 00:17:38,770
function with a function from scholars

00:17:35,559 --> 00:17:41,830
recipe I choose to compare type

00:17:38,770 --> 00:17:44,919
Bunnell that strain is started as a

00:17:41,830 --> 00:17:48,159
stream and a search but for example an

00:17:44,919 --> 00:17:50,770
ageless start as a mess is a mess and we

00:17:48,159 --> 00:17:54,130
also know that this search has a lot

00:17:50,770 --> 00:17:57,580
less types and colleges so that map is

00:17:54,130 --> 00:17:59,440
definitely not what we ordered and we

00:17:57,580 --> 00:18:04,600
will have to get the values of this map

00:17:59,440 --> 00:18:06,789
and customs into your expected types to

00:18:04,600 --> 00:18:09,880
do that it will write some function

00:18:06,789 --> 00:18:13,390
function that will get values of the

00:18:09,880 --> 00:18:16,659
snap and returns as the collection of

00:18:13,390 --> 00:18:18,850
type any and then we can call the search

00:18:16,659 --> 00:18:21,820
list function from an X shape with its

00:18:18,850 --> 00:18:25,360
package to get the exact age place that

00:18:21,820 --> 00:18:29,350
we start and we also can do the same for

00:18:25,360 --> 00:18:33,899
other types of course just an example we

00:18:29,350 --> 00:18:37,539
can use it for case classes or whatever

00:18:33,899 --> 00:18:40,059
so what we are now when we call this

00:18:37,539 --> 00:18:45,970
function Tyrion brother for particular

00:18:40,059 --> 00:18:48,490
age list of interpolant instance of this

00:18:45,970 --> 00:18:53,649
particular case will be created with all

00:18:48,490 --> 00:18:56,049
inverts values and methods take a look

00:18:53,649 --> 00:19:01,809
at the stage function here it took the

00:18:56,049 --> 00:19:05,620
right piece of the fetch value with it

00:19:01,809 --> 00:19:09,039
for for the exact age list so this will

00:19:05,620 --> 00:19:13,690
be the full instance for the H list of

00:19:09,039 --> 00:19:16,899
int fallen but my first everything is

00:19:13,690 --> 00:19:21,820
under your control if you want to take a

00:19:16,899 --> 00:19:24,220
look at the result I there is a number

00:19:21,820 --> 00:19:26,710
of ways to do that and these each one is

00:19:24,220 --> 00:19:32,980
just to print printed which is x over

00:19:26,710 --> 00:19:35,230
IDs to get this example so we done

00:19:32,980 --> 00:19:38,590
everything and now we can relax because

00:19:35,230 --> 00:19:41,919
all converters will be generated or the

00:19:38,590 --> 00:19:45,010
compile times by themselves so you don't

00:19:41,919 --> 00:19:47,289
have to do anything more I spent a lot

00:19:45,010 --> 00:19:49,570
of time defining the correspondence of

00:19:47,289 --> 00:19:52,390
two types in the storage

00:19:49,570 --> 00:19:54,880
in Scala but in my opinion user always

00:19:52,390 --> 00:19:56,470
has to have choice so if you want to

00:19:54,880 --> 00:19:57,520
store your information some different

00:19:56,470 --> 00:20:00,640
way you can always do that

00:19:57,520 --> 00:20:02,980
all you have to do is just a specified

00:20:00,640 --> 00:20:07,060
custom browser for example if you have

00:20:02,980 --> 00:20:10,270
functioned that right values into

00:20:07,060 --> 00:20:12,510
storage and accepting Baccarin places

00:20:10,270 --> 00:20:15,280
all you have to do is just specify it to

00:20:12,510 --> 00:20:17,740
two braggers for example for the case

00:20:15,280 --> 00:20:20,440
class track we can use two options sorry

00:20:17,740 --> 00:20:24,660
is a map which is a default case and

00:20:20,440 --> 00:20:27,760
started adjacent you will have to pass

00:20:24,660 --> 00:20:30,010
explicitly those ruggers into the

00:20:27,760 --> 00:20:32,230
function call because when you have the

00:20:30,010 --> 00:20:34,900
jewel them in the scope of the same type

00:20:32,230 --> 00:20:39,010
compiler will be confused and you will

00:20:34,900 --> 00:20:42,220
have to help it to pick the right one so

00:20:39,010 --> 00:20:43,930
what else is out there now we have

00:20:42,220 --> 00:20:47,440
everything and we can define a service

00:20:43,930 --> 00:20:50,200
to communicate to the storage along with

00:20:47,440 --> 00:20:53,320
a link and the nice list I will start an

00:20:50,200 --> 00:20:55,630
interesting map rarities and are not

00:20:53,320 --> 00:21:00,340
straight but values of the simple case

00:20:55,630 --> 00:21:03,370
cause it Eris by provides different

00:21:00,340 --> 00:21:04,060
tools one of them is a console tool

00:21:03,370 --> 00:21:06,750
named

00:21:04,060 --> 00:21:09,220
RL which was you choose life information

00:21:06,750 --> 00:21:12,010
which is very useful during development

00:21:09,220 --> 00:21:15,790
and distant process so let's take a look

00:21:12,010 --> 00:21:20,890
at the result and then and initially are

00:21:15,790 --> 00:21:23,890
fine but the map bin is empty is it's

00:21:20,890 --> 00:21:27,280
not actually empty this too has matured

00:21:23,890 --> 00:21:29,980
it can show you complicated keys stored

00:21:27,280 --> 00:21:33,430
by complicated I mean any other in the

00:21:29,980 --> 00:21:35,740
string but with methods the switches

00:21:33,430 --> 00:21:38,230
froze we can collect information and be

00:21:35,740 --> 00:21:43,330
sure that this information can be stored

00:21:38,230 --> 00:21:45,520
properly and little successful get it to

00:21:43,330 --> 00:21:47,230
connect all information that we start

00:21:45,520 --> 00:21:50,680
during development investing process we

00:21:47,230 --> 00:21:52,870
can define the cleanup object and call

00:21:50,680 --> 00:21:57,290
the delete function on every key in the

00:21:52,870 --> 00:21:59,610
collection and now it is empty

00:21:57,290 --> 00:22:03,210
starships of this vessel are available

00:21:59,610 --> 00:22:06,360
and ETF shares going can dependent it to

00:22:03,210 --> 00:22:09,270
try it everything via that the progress

00:22:06,360 --> 00:22:13,140
realizations and there is in models with

00:22:09,270 --> 00:22:15,770
examples there you can find examples of

00:22:13,140 --> 00:22:19,650
usage and everything you needs there

00:22:15,770 --> 00:22:21,870
Charles to come up I've showed you about

00:22:19,650 --> 00:22:25,470
earth bike and how we store information

00:22:21,870 --> 00:22:28,050
in it what I think schema list released

00:22:25,470 --> 00:22:31,200
urges driver has to do and how to deal

00:22:28,050 --> 00:22:33,420
this type using Scala Makris I firmly

00:22:31,200 --> 00:22:35,520
believe that users have any application

00:22:33,420 --> 00:22:38,190
need to upgrade to types to reduce

00:22:35,520 --> 00:22:42,630
errors and first to spread more

00:22:38,190 --> 00:22:44,640
beautiful a readable code if you need to

00:22:42,630 --> 00:22:47,160
get in touch with me my can't observe

00:22:44,640 --> 00:22:57,410
star on the screen please feel free to

00:22:47,160 --> 00:22:57,410
email me thank you any questions

00:23:14,530 --> 00:23:52,900
I can use these actual examples you know

00:23:50,860 --> 00:23:53,890
it's part of all you do just have to

00:23:52,900 --> 00:23:59,280
write it down

00:23:53,890 --> 00:23:59,280
sure it is I was saying I will show you

00:24:02,790 --> 00:24:10,570
if it's fast about oh sorry I'm just

00:24:09,940 --> 00:24:16,300
wondering out loud

00:24:10,570 --> 00:24:19,810
the my question was if do we if as long

00:24:16,300 --> 00:24:23,650
as the H list contains elements that are

00:24:19,810 --> 00:24:26,490
that have key wrappers I believe it's

00:24:23,650 --> 00:24:30,090
possible to for the compiler to derive

00:24:26,490 --> 00:24:35,080
the key wrapper for an H list itself

00:24:30,090 --> 00:24:36,760
through tight cluster dimension so my

00:24:35,080 --> 00:24:39,190
question was is there a compelling

00:24:36,760 --> 00:24:44,050
reason to use macros here or was it just

00:24:39,190 --> 00:24:47,290
easier and no there is actually a reason

00:24:44,050 --> 00:24:50,590
it goes for the key classes I'm using

00:24:47,290 --> 00:24:54,070
the reflection full reflection and if

00:24:50,590 --> 00:24:57,120
you if you use it for like chance models

00:24:54,070 --> 00:24:59,740
it's very valuable if you're if you can

00:24:57,120 --> 00:25:04,110
detect the exceptions during compile

00:24:59,740 --> 00:25:04,110
time it's it's better of course

00:25:06,110 --> 00:25:13,799
thank you what about a class loading

00:25:11,220 --> 00:25:17,220
performance program I mean that we are

00:25:13,799 --> 00:25:19,190
generating a lot of garbage I mean a lot

00:25:17,220 --> 00:25:24,559
of classes which can be reusable

00:25:19,190 --> 00:25:27,299
sometimes so every materialising

00:25:24,559 --> 00:25:33,149
invocation generates additional classes

00:25:27,299 --> 00:25:38,450
I even fill their deal like some extra

00:25:33,149 --> 00:25:43,289
classes that you don't use in the scope

00:25:38,450 --> 00:25:46,710
can we want to invoke getting matters

00:25:43,289 --> 00:25:49,919
for the same age list the same types

00:25:46,710 --> 00:25:52,649
than in both cases we will generate the

00:25:49,919 --> 00:25:55,830
same code in different places

00:25:52,649 --> 00:25:58,500
so right it's okay for runtime

00:25:55,830 --> 00:26:00,750
performance but it's not good for class

00:25:58,500 --> 00:26:04,860
modeling performance is it possible to

00:26:00,750 --> 00:26:10,590
solve that somehow I honestly haven't

00:26:04,860 --> 00:26:13,919
tried yet so but yes there will be an

00:26:10,590 --> 00:26:18,929
extra classes and different files if you

00:26:13,919 --> 00:26:25,549
use the same classes yes that's true

00:26:18,929 --> 00:26:28,440
thank you I thank you for the talk you

00:26:25,549 --> 00:26:33,149
shown the cases when you're serializing

00:26:28,440 --> 00:26:37,500
case classes and apps and h lists as

00:26:33,149 --> 00:26:39,600
maps and I know that dot C now is coming

00:26:37,500 --> 00:26:41,669
with a new H list so is there a way to

00:26:39,600 --> 00:26:44,539
expand it with your own type so it's not

00:26:41,669 --> 00:26:46,860
just like wrong class exception but like

00:26:44,539 --> 00:26:49,020
ability to extend and add your own types

00:26:46,860 --> 00:26:54,000
they're looking like maps or like

00:26:49,020 --> 00:26:57,090
numbers can you please be more specific

00:26:54,000 --> 00:26:59,700
for instance if dot e adds new type of

00:26:57,090 --> 00:27:02,539
th list and we will want to sterilize it

00:26:59,700 --> 00:27:06,750
as map is their way to add it to your

00:27:02,539 --> 00:27:08,640
plugin to your driver I all I will have

00:27:06,750 --> 00:27:11,399
to do is just change this exact

00:27:08,640 --> 00:27:15,230
basically third that I use and it will

00:27:11,399 --> 00:27:15,230
not affect users

00:27:15,280 --> 00:27:35,090
okay that's it alright if I want to use

00:27:31,700 --> 00:27:37,400
your approach but I want to also verify

00:27:35,090 --> 00:27:39,500
every field before I save it to database

00:27:37,400 --> 00:27:42,050
don't need to write extra mattress or I

00:27:39,500 --> 00:27:44,930
can solve it easily with H list approach

00:27:42,050 --> 00:27:47,360
or some other approaches so do I need

00:27:44,930 --> 00:27:49,340
mattresses if I want to verify each

00:27:47,360 --> 00:27:53,570
field before I write it in the database

00:27:49,340 --> 00:27:55,910
if it's not verified successfully I want

00:27:53,570 --> 00:28:00,290
to get an exception so should I add more

00:27:55,910 --> 00:28:03,950
mattresses in this case yeah you don't

00:28:00,290 --> 00:28:07,640
need it actually you if you have like a

00:28:03,950 --> 00:28:10,970
couple of types that that you want to

00:28:07,640 --> 00:28:14,660
use there's no need to use this approach

00:28:10,970 --> 00:28:17,300
actually so see if I just want to verify

00:28:14,660 --> 00:28:20,110
every field and return result is at

00:28:17,300 --> 00:28:25,340
least I don't need this approach I just

00:28:20,110 --> 00:28:27,770
I just have similar problem but we also

00:28:25,340 --> 00:28:29,600
need to get very files for each field

00:28:27,770 --> 00:28:31,520
and I'm wondering do I need to add extra

00:28:29,600 --> 00:28:34,940
mattresses or I can just take this

00:28:31,520 --> 00:28:38,630
library and add some great fires which

00:28:34,940 --> 00:28:40,880
is clear friend database right this one

00:28:38,630 --> 00:28:44,270
is specific for it for the eros fight

00:28:40,880 --> 00:28:47,750
because it transfers the values of the

00:28:44,270 --> 00:28:52,520
scholar into the I respect your client

00:28:47,750 --> 00:28:55,820
values types and then it it gets to the

00:28:52,520 --> 00:28:58,429
storage so it's not hidden for other

00:28:55,820 --> 00:29:00,170
databases but I can help you if you'll

00:28:58,429 --> 00:29:02,630
show me thank you

00:29:00,170 --> 00:29:09,140
so for verifiers I didn't take some

00:29:02,630 --> 00:29:09,679
addresses maybe I'll try to help you go

00:29:09,140 --> 00:29:12,700
to school

00:29:09,679 --> 00:29:12,700
thank you Thanks

00:29:19,640 --> 00:29:24,650
I was wondering maybe this kind of goes

00:29:22,280 --> 00:29:27,309
along with the verification thing he was

00:29:24,650 --> 00:29:31,250
talking about but like so it sounds like

00:29:27,309 --> 00:29:35,210
for in sand shorts and bites or whatever

00:29:31,250 --> 00:29:37,340
that it gets like tested or maybe not

00:29:35,210 --> 00:29:39,710
cast it but it gets put into a long and

00:29:37,340 --> 00:29:42,530
it the long is like how it's like in the

00:29:39,710 --> 00:29:45,830
database right so when you're bringing

00:29:42,530 --> 00:29:47,120
something back out how do you because

00:29:45,830 --> 00:29:51,080
it's a long in the database how do you

00:29:47,120 --> 00:29:52,880
ensure like maybe you stored something

00:29:51,080 --> 00:29:55,190
as an int but you're trying to pull it

00:29:52,880 --> 00:29:58,669
out as by something that wouldn't really

00:29:55,190 --> 00:30:02,840
fit in how do you prevent like that

00:29:58,669 --> 00:30:06,040
error I yeah there's no errors because I

00:30:02,840 --> 00:30:09,020
did it for for quite some time so it

00:30:06,040 --> 00:30:11,860
sorry two years which type C starts

00:30:09,020 --> 00:30:16,970
right in which way and for examples for

00:30:11,860 --> 00:30:20,960
in a choice and I will have to get the

00:30:16,970 --> 00:30:23,210
names of the type alone will fit well

00:30:20,960 --> 00:30:26,179
with a collection of actual values and

00:30:23,210 --> 00:30:28,940
then I will in caps shares of these

00:30:26,179 --> 00:30:31,820
types and I have the collection of types

00:30:28,940 --> 00:30:36,110
that are you know complicated in this

00:30:31,820 --> 00:30:39,110
case except for those for example and I

00:30:36,110 --> 00:30:41,330
will have to catch it every time I can

00:30:39,110 --> 00:30:46,309
use actually for collections like

00:30:41,330 --> 00:30:50,510
something from shapeless but it's not it

00:30:46,309 --> 00:30:54,890
doesn't see it here very well alright so

00:30:50,510 --> 00:30:56,510
in so in that case then the the type of

00:30:54,890 --> 00:30:58,429
they like the original type also gets

00:30:56,510 --> 00:31:01,070
stored in the database along with the

00:30:58,429 --> 00:31:02,960
value being stored in the long I know

00:31:01,070 --> 00:31:04,190
what you're saying okay okay can you be

00:31:02,960 --> 00:31:07,240
more specific

00:31:04,190 --> 00:31:10,820
well like like say say I want to store

00:31:07,240 --> 00:31:13,010
an int into the database uh-huh and you

00:31:10,820 --> 00:31:16,850
know okay get stored that's fine later

00:31:13,010 --> 00:31:19,970
on like I accidentally think that I want

00:31:16,850 --> 00:31:21,500
to pull a byte from the database no it's

00:31:19,970 --> 00:31:23,650
like it's all starting along and I want

00:31:21,500 --> 00:31:27,890
to pull a byte from the database and

00:31:23,650 --> 00:31:28,850
because I messed up my types because

00:31:27,890 --> 00:31:31,760
it's supposed to be an into could be

00:31:28,850 --> 00:31:32,809
longer than what a bike can hold I guess

00:31:31,760 --> 00:31:34,279
how you prove and

00:31:32,809 --> 00:31:36,980
first I'd like built into the system

00:31:34,279 --> 00:31:41,059
that if you're putting out an ends

00:31:36,980 --> 00:31:45,470
you're always getting back an int or no

00:31:41,059 --> 00:31:49,009
in this case you can own the database so

00:31:45,470 --> 00:31:51,830
someone can always change your value of

00:31:49,009 --> 00:31:56,539
course and there's actually no insurance

00:31:51,830 --> 00:32:04,749
for that but I if you use in the right

00:31:56,539 --> 00:32:08,090
way the function call okay you will

00:32:04,749 --> 00:32:12,080
specify the type that you want to get

00:32:08,090 --> 00:32:15,169
and if you're trying to get like wrong

00:32:12,080 --> 00:32:16,490
value you won't get it no heaven so just

00:32:15,169 --> 00:32:21,590
feel like a regular exception in that

00:32:16,490 --> 00:32:27,440
case yes okay yes and more than that you

00:32:21,590 --> 00:32:31,610
will have exception in even even if it

00:32:27,440 --> 00:32:33,259
is failure to compile the raga so maybe

00:32:31,610 --> 00:32:36,919
it's not even possible what you're

00:32:33,259 --> 00:32:43,779
trying to do which is better of course

00:32:36,919 --> 00:32:43,779
and caching in runtime thank you so much

00:32:44,259 --> 00:32:52,530
anyone else okay thank you okay thank

00:32:51,860 --> 00:32:57,109
you so much

00:32:52,530 --> 00:32:57,109

YouTube URL: https://www.youtube.com/watch?v=6mKpSrEvDbk


