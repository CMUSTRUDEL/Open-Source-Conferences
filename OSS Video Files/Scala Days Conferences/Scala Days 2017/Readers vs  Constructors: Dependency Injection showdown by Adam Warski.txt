Title: Readers vs  Constructors: Dependency Injection showdown by Adam Warski
Publication date: 2017-06-06
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Like it or not, but how in-code dependencies are managed is one of the key decisions that we have to make when working on a project.

We've seen various approaches to Dependency Injection come and go. In Scala's early days, the Cake Pattern was quite fashionable; but there was just too much boilerplate. Instead, maybe we could just use plain constructors for wiring dependencies (MacWire)? Use a hybrid service locator (SubCut, Scaldi)? Or go fully functional, and use the Reader Monad; but is it really a replacement of Dependency Injection frameworks/libraries? Finally, maybe we should stick with proven Java-land solutions, like Guice (used e.g. by the Play Framework)?
Captions: 
	00:00:00,319 --> 00:00:08,189
we can stop okay right hello a great to

00:00:05,580 --> 00:00:11,610
see you here and my name is Anna Marquis

00:00:08,189 --> 00:00:13,799
I come from Warsaw Poland and I would

00:00:11,610 --> 00:00:16,410
like to talk about dependency injection

00:00:13,799 --> 00:00:18,600
in scala I think there's definitely a

00:00:16,410 --> 00:00:21,359
couple of approaches which can take and

00:00:18,600 --> 00:00:23,460
probably read around on the internet you

00:00:21,359 --> 00:00:25,949
can do you can use constructors you can

00:00:23,460 --> 00:00:28,980
some say that the reader monad is a

00:00:25,949 --> 00:00:31,349
replacement for all dependency injection

00:00:28,980 --> 00:00:35,550
frameworks on the other hand we have

00:00:31,349 --> 00:00:37,380
play which uses juice by default so

00:00:35,550 --> 00:00:39,870
maybe I would like to try to clear up

00:00:37,380 --> 00:00:43,079
some of the confusion which construction

00:00:39,870 --> 00:00:45,180
and which abstraction to use to use web

00:00:43,079 --> 00:00:47,899
and so there would be like four slides

00:00:45,180 --> 00:00:49,860
and then we will do some live coding and

00:00:47,899 --> 00:00:51,660
let me know if you would have any

00:00:49,860 --> 00:00:54,840
questions throughout the talk please let

00:00:51,660 --> 00:00:59,910
me know I will try to to clear things up

00:00:54,840 --> 00:01:01,710
and okay so so let's start and so first

00:00:59,910 --> 00:01:03,449
of all it may be a familiar with the

00:01:01,710 --> 00:01:05,700
whole dependency injection thing maybe

00:01:03,449 --> 00:01:07,590
not so just to set some common ground

00:01:05,700 --> 00:01:11,130
and probably if you come from Java you

00:01:07,590 --> 00:01:13,740
have heard the term and if but like not

00:01:11,130 --> 00:01:16,430
everyone comes from Java luckily so it

00:01:13,740 --> 00:01:18,780
may be that introduction would be useful

00:01:16,430 --> 00:01:21,659
so independency injection imagine you

00:01:18,780 --> 00:01:23,009
have two services and these services are

00:01:21,659 --> 00:01:25,229
usual classes but let's talk about

00:01:23,009 --> 00:01:26,580
services right now and one service

00:01:25,229 --> 00:01:29,400
called another service right that's

00:01:26,580 --> 00:01:32,840
quite a common scenario so one service

00:01:29,400 --> 00:01:36,659
is a dependency of another service or a

00:01:32,840 --> 00:01:38,460
client and so with dependency injection

00:01:36,659 --> 00:01:41,009
what we want to achieve if we want to

00:01:38,460 --> 00:01:43,380
decouple these two services right we

00:01:41,009 --> 00:01:44,790
don't want one service to be aware of

00:01:43,380 --> 00:01:47,460
how the other service is being

00:01:44,790 --> 00:01:50,009
constructed it just wants to use it it

00:01:47,460 --> 00:01:52,290
doesn't want to know how how to build

00:01:50,009 --> 00:01:54,750
the service how to create it right and

00:01:52,290 --> 00:01:57,719
that's a dependency injection also

00:01:54,750 --> 00:02:00,600
implements inversion of control right so

00:01:57,719 --> 00:02:02,909
the service doesn't know how to create

00:02:00,600 --> 00:02:05,430
its dependencies it just wants to use

00:02:02,909 --> 00:02:10,910
them and this has a number of benefits

00:02:05,430 --> 00:02:13,600
so the first being probably a hiding

00:02:10,910 --> 00:02:15,700
implementation details right so one

00:02:13,600 --> 00:02:19,260
service doesn't we know how the other

00:02:15,700 --> 00:02:21,520
services is implemented and what it

00:02:19,260 --> 00:02:24,730
should only know is how to use the

00:02:21,520 --> 00:02:28,660
interface and other benefits include a

00:02:24,730 --> 00:02:30,430
testing so you may want to swap and swap

00:02:28,660 --> 00:02:31,990
services for testing use and more

00:02:30,430 --> 00:02:35,830
complementation a stub or something like

00:02:31,990 --> 00:02:38,800
that and also the pending dependency

00:02:35,830 --> 00:02:41,560
injection helps with separating concerns

00:02:38,800 --> 00:02:43,690
so we're really creating a service

00:02:41,560 --> 00:02:46,150
creating a class is a separate concern

00:02:43,690 --> 00:02:47,650
than actually using it and it also helps

00:02:46,150 --> 00:02:49,980
you to organize code especially if you

00:02:47,650 --> 00:02:52,620
have like business like code let's say

00:02:49,980 --> 00:02:55,930
with some complicated business logic

00:02:52,620 --> 00:02:59,980
these these buttons help you to organize

00:02:55,930 --> 00:03:01,900
your code in a in a readable way and

00:02:59,980 --> 00:03:03,700
there's a couple of ways like especially

00:03:01,900 --> 00:03:07,450
if you are coming from Java again you

00:03:03,700 --> 00:03:11,620
probably know these and you can either

00:03:07,450 --> 00:03:14,440
pass as to how the dependent centers in

00:03:11,620 --> 00:03:16,390
section implemented at the code level so

00:03:14,440 --> 00:03:18,310
either use constructor parameters and

00:03:16,390 --> 00:03:20,460
all the time it's also with getters and

00:03:18,310 --> 00:03:24,070
setters but probably nobody does it and

00:03:20,460 --> 00:03:25,480
this way in the more likely or you can

00:03:24,070 --> 00:03:27,940
use the service locators it's also a

00:03:25,480 --> 00:03:29,650
possibility so we have like one global

00:03:27,940 --> 00:03:34,570
object they can register services and

00:03:29,650 --> 00:03:37,330
then ask ask for services back and so

00:03:34,570 --> 00:03:39,790
what I would like you to get out of this

00:03:37,330 --> 00:03:41,140
talk and hopefully I would succeed it's

00:03:39,790 --> 00:03:43,540
convincing you that you don't really

00:03:41,140 --> 00:03:45,190
need anything special to do dependency

00:03:43,540 --> 00:03:47,140
injection because in its essence

00:03:45,190 --> 00:03:51,220
dependency injection is just using

00:03:47,140 --> 00:03:53,770
parameters class parameters and method

00:03:51,220 --> 00:03:58,060
parameters so that's a construct like we

00:03:53,770 --> 00:04:02,410
all know so you don't need any libraries

00:03:58,060 --> 00:04:06,550
and frameworks and the libraries and

00:04:02,410 --> 00:04:09,640
frameworks can help you in some cases so

00:04:06,550 --> 00:04:12,610
they they certainly help you in avoiding

00:04:09,640 --> 00:04:16,450
to write new anywhere but they are like

00:04:12,610 --> 00:04:18,880
not mandatory to do that they bring on

00:04:16,450 --> 00:04:21,729
some additional features and you should

00:04:18,880 --> 00:04:24,160
really only use frameworks if you need

00:04:21,729 --> 00:04:26,200
those additional features and they

00:04:24,160 --> 00:04:26,590
aren't like if you are bootstrapping and

00:04:26,200 --> 00:04:28,870
you

00:04:26,590 --> 00:04:32,260
project probably you don't need any of

00:04:28,870 --> 00:04:35,139
them and so before we start coding it

00:04:32,260 --> 00:04:38,919
just so that you know who's talking to

00:04:35,139 --> 00:04:40,660
you as I said I'm I'm anniversary I'm a

00:04:38,919 --> 00:04:43,810
co-founder and software engineer

00:04:40,660 --> 00:04:45,729
software mode which is a software yet

00:04:43,810 --> 00:04:48,430
another software consultant is color

00:04:45,729 --> 00:04:52,810
consultancy based in Poland and we do

00:04:48,430 --> 00:04:54,490
custom software for clients and most of

00:04:52,810 --> 00:04:58,380
them from the US and from Western Europe

00:04:54,490 --> 00:05:02,889
and I have some open source projects and

00:04:58,380 --> 00:05:04,540
like my choir which kind of that's where

00:05:02,889 --> 00:05:06,490
my interest in dependency injection come

00:05:04,540 --> 00:05:08,229
from because the library for for the I

00:05:06,490 --> 00:05:12,639
last came to quick glance and a couple

00:05:08,229 --> 00:05:14,740
of others I write a blog and I write

00:05:12,639 --> 00:05:16,300
some blogs and I have a Twitter account

00:05:14,740 --> 00:05:22,720
which probably isn't it surprising

00:05:16,300 --> 00:05:27,669
nowadays okay so on to the coding part

00:05:22,720 --> 00:05:29,830
okay so we will be we will be dealing

00:05:27,669 --> 00:05:32,229
with cooking and on a very basic level

00:05:29,830 --> 00:05:34,479
and so we will build three abstractions

00:05:32,229 --> 00:05:36,970
one on top of another

00:05:34,479 --> 00:05:39,340
so first to have a key value store which

00:05:36,970 --> 00:05:42,039
is already written here a big value so

00:05:39,340 --> 00:05:44,080
it's quite simple it's a support basic

00:05:42,039 --> 00:05:48,610
crud operations so we have a create read

00:05:44,080 --> 00:05:51,639
update delete and like what you would

00:05:48,610 --> 00:05:54,729
expect right mostly this implementation

00:05:51,639 --> 00:05:56,470
is total is in memory but you could

00:05:54,729 --> 00:05:57,940
imagine that it could be another

00:05:56,470 --> 00:05:59,889
implementation which could write to

00:05:57,940 --> 00:06:02,919
something more fancy like a real

00:05:59,889 --> 00:06:04,870
database now we are we are we are ready

00:06:02,919 --> 00:06:07,240
for that because we return futures

00:06:04,870 --> 00:06:10,780
everywhere so we are ready to be reacted

00:06:07,240 --> 00:06:12,310
with like the first step and so yeah so

00:06:10,780 --> 00:06:14,919
this information is quite simple we just

00:06:12,310 --> 00:06:16,870
use a concurrent hash map as the

00:06:14,919 --> 00:06:19,479
background so that will be our first

00:06:16,870 --> 00:06:22,539
abstraction so the second thing that we

00:06:19,479 --> 00:06:26,110
the second level that we will build on

00:06:22,539 --> 00:06:28,450
top of this key value storage a will be

00:06:26,110 --> 00:06:31,630
food storage okay so we will we'll build

00:06:28,450 --> 00:06:35,080
a food storage and on top of of this

00:06:31,630 --> 00:06:36,610
food storage will then and build an

00:06:35,080 --> 00:06:39,390
abstraction to actually combine the

00:06:36,610 --> 00:06:43,320
various ingredients and

00:06:39,390 --> 00:06:45,000
some food okay and so the food storage

00:06:43,320 --> 00:06:49,290
will operate on some primitives I would

00:06:45,000 --> 00:06:51,420
just area areas I'm over here so that

00:06:49,290 --> 00:06:53,510
the code will be more readable later so

00:06:51,420 --> 00:06:59,130
we'll have food name which is a string

00:06:53,510 --> 00:07:04,260
food quantity will be an end and the

00:06:59,130 --> 00:07:08,670
food key value storage will be a key

00:07:04,260 --> 00:07:11,790
value storage from food name to quantity

00:07:08,670 --> 00:07:14,730
okay so our food storage will be a

00:07:11,790 --> 00:07:17,250
storing will be basically a kind of a

00:07:14,730 --> 00:07:19,920
map from from food name to quantity and

00:07:17,250 --> 00:07:22,380
we will have like two basic methods

00:07:19,920 --> 00:07:25,290
which operate on the food storage so we

00:07:22,380 --> 00:07:31,830
can add some food it read some food we

00:07:25,290 --> 00:07:35,510
need we need the food storage we need

00:07:31,830 --> 00:07:40,680
the name of the food and quantity

00:07:35,510 --> 00:07:43,310
quantity and this gives us a future unit

00:07:40,680 --> 00:07:46,800
so that's a purified affecting function

00:07:43,310 --> 00:07:49,380
okay so to add some foods our storage

00:07:46,800 --> 00:07:53,910
what we will do is we first read the

00:07:49,380 --> 00:07:57,690
current amount that we have so we read

00:07:53,910 --> 00:08:04,040
now we do calculations so the new amount

00:07:57,690 --> 00:08:06,510
is simply we add at the current and at

00:08:04,040 --> 00:08:10,980
the given quantity to the current one

00:08:06,510 --> 00:08:17,340
all of this man just add past the past

00:08:10,980 --> 00:08:23,460
quantity and finally we update update

00:08:17,340 --> 00:08:25,680
and update okay and we use a unit okay

00:08:23,460 --> 00:08:29,840
so that's a very simple method similarly

00:08:25,680 --> 00:08:33,870
we can add food we console remove food

00:08:29,840 --> 00:08:38,130
from the key value storage and given a

00:08:33,870 --> 00:08:40,440
name and the quantity now the result

00:08:38,130 --> 00:08:45,000
here won't be a unit it would be a

00:08:40,440 --> 00:08:47,760
actually quantity because we may remove

00:08:45,000 --> 00:08:50,490
a small amount and then the request is

00:08:47,760 --> 00:08:52,660
right if there's not enough so again we

00:08:50,490 --> 00:08:55,660
read the current

00:08:52,660 --> 00:08:57,610
an amount and now we do some very

00:08:55,660 --> 00:08:58,930
complicated calculations because we have

00:08:57,610 --> 00:09:03,540
to calculate how much we can actually

00:08:58,930 --> 00:09:06,850
get so in stock is the current or zero

00:09:03,540 --> 00:09:11,940
taken will be now that the complicated

00:09:06,850 --> 00:09:18,480
math math minimum and in spoken quantity

00:09:11,940 --> 00:09:24,610
right and left is in stock - taken and

00:09:18,480 --> 00:09:28,570
now we update if left is greater than 0

00:09:24,610 --> 00:09:31,090
and then we update it with what's left

00:09:28,570 --> 00:09:36,730
I will storage otherwise we will move it

00:09:31,090 --> 00:09:39,130
all together ok and we return the amount

00:09:36,730 --> 00:09:41,140
that we managed to take ok so now we

00:09:39,130 --> 00:09:42,370
have on top of the key value storage

00:09:41,140 --> 00:09:45,190
abstraction we have with another

00:09:42,370 --> 00:09:47,320
abstraction that food storage right we

00:09:45,190 --> 00:09:50,170
can add a given quantity of food and

00:09:47,320 --> 00:09:52,360
remove some food from it ok so far so

00:09:50,170 --> 00:09:56,530
good nothing very fancy I hope that

00:09:52,360 --> 00:09:58,000
that's not nothing complicated so now on

00:09:56,530 --> 00:10:00,780
top of that we will yet another

00:09:58,000 --> 00:10:03,640
abstraction and that will be used to

00:10:00,780 --> 00:10:05,680
combine ingredients and cook some cook

00:10:03,640 --> 00:10:09,010
some food ok so we will define a cook

00:10:05,680 --> 00:10:13,540
sauce method we will be cooking pasta

00:10:09,010 --> 00:10:16,090
sauce so let's say we want to cook a

00:10:13,540 --> 00:10:18,400
given amount of sauce so now what what

00:10:16,090 --> 00:10:21,310
we will need so what what do we need to

00:10:18,400 --> 00:10:26,050
cook sauce well to cook sauce we need a

00:10:21,310 --> 00:10:27,670
way to obtain ingredients right and in

00:10:26,050 --> 00:10:30,610
the end when the sauce is cooked we need

00:10:27,670 --> 00:10:34,510
a way to put put back the cooked result

00:10:30,610 --> 00:10:42,280
so what we need is a method 1 method

00:10:34,510 --> 00:10:46,440
take food witch witch witch witch witch

00:10:42,280 --> 00:10:49,750
witch takes a food name and quantity and

00:10:46,440 --> 00:10:52,450
returns a future quantity that's how

00:10:49,750 --> 00:10:54,790
much we managed to remove let's look

00:10:52,450 --> 00:10:56,710
similar but now it's not exactly what we

00:10:54,790 --> 00:10:58,470
have implanted before and we need

00:10:56,710 --> 00:11:02,230
another method add food which has a

00:10:58,470 --> 00:11:06,040
similar a signature so it takes food

00:11:02,230 --> 00:11:06,430
name quantity and returns a future net

00:11:06,040 --> 00:11:09,600
so

00:11:06,430 --> 00:11:12,700
purely side-effect in function okay and

00:11:09,600 --> 00:11:14,529
as a result again we returned the

00:11:12,700 --> 00:11:19,149
quantity of sauce that we have managed

00:11:14,529 --> 00:11:22,300
to cook and okay so how do we cook sauce

00:11:19,149 --> 00:11:27,670
where we take some Tomatoes right take

00:11:22,300 --> 00:11:32,640
food tomato quantity and we take some

00:11:27,670 --> 00:11:37,660
other of the vegetables non tomato

00:11:32,640 --> 00:11:40,750
vegetable same amount and we also take

00:11:37,660 --> 00:11:44,830
some garlic garlic is always good and

00:11:40,750 --> 00:11:48,430
garlic half we take twice the amount of

00:11:44,830 --> 00:11:50,230
garlic that we actually need and now we

00:11:48,430 --> 00:11:54,970
calculate how much sauce we have cooked

00:11:50,230 --> 00:11:59,080
and that tomato q divided by two because

00:11:54,970 --> 00:12:02,740
some of the evaporate and vegetable

00:11:59,080 --> 00:12:05,200
times 3/4 and finally now we have cooked

00:12:02,740 --> 00:12:07,330
this off so we can put it like we put

00:12:05,200 --> 00:12:11,200
back whatever we have cooked into the

00:12:07,330 --> 00:12:14,290
food storage and using our add food a

00:12:11,200 --> 00:12:19,150
function so we put put back the sauce

00:12:14,290 --> 00:12:21,610
and the quantity given okay and we

00:12:19,150 --> 00:12:23,290
dispose quantity okay so now we have

00:12:21,610 --> 00:12:25,690
built like this method it knows nothing

00:12:23,290 --> 00:12:27,850
about food storages it's not nothing

00:12:25,690 --> 00:12:31,180
about a key value stores and so on it

00:12:27,850 --> 00:12:35,580
just takes some methods as parameters

00:12:31,180 --> 00:12:38,500
right which allow it to operate so and

00:12:35,580 --> 00:12:41,680
so this method to actually be able to

00:12:38,500 --> 00:12:43,930
cook sauce to prepare the sauce it needs

00:12:41,680 --> 00:12:46,150
to take food methods to retrieve food

00:12:43,930 --> 00:12:48,930
end and the adven method to put it back

00:12:46,150 --> 00:12:52,290
in a mess in a similar way we can

00:12:48,930 --> 00:12:55,480
implement a cook pasta method right

00:12:52,290 --> 00:12:56,620
which works exactly the same its uses

00:12:55,480 --> 00:12:59,079
different ingredients

00:12:56,620 --> 00:13:00,700
and because it's parts are not sauce ok

00:12:59,079 --> 00:13:04,959
so now we have these two these two

00:13:00,700 --> 00:13:06,970
methods so and all looks good so now we

00:13:04,959 --> 00:13:10,959
have to actually use them in an

00:13:06,970 --> 00:13:13,690
application to be able to test that that

00:13:10,959 --> 00:13:15,130
things are working and so one thing that

00:13:13,690 --> 00:13:18,430
we really need for sure is we need an

00:13:15,130 --> 00:13:19,279
instance of our key value store right

00:13:18,430 --> 00:13:25,310
which will

00:13:19,279 --> 00:13:29,120
u.s. drought and you and we will use it

00:13:25,310 --> 00:13:35,170
throughout our example and so now I will

00:13:29,120 --> 00:13:38,029
just prepare to paste and a snippet so

00:13:35,170 --> 00:13:40,100
first we need to populate the the key

00:13:38,029 --> 00:13:42,230
value store with some ingredient so

00:13:40,100 --> 00:13:46,699
let's say we go shopping we buy some

00:13:42,230 --> 00:13:48,620
Tomatoes vegetable garlic and so on so

00:13:46,699 --> 00:13:51,860
let's we are calling the add food

00:13:48,620 --> 00:13:56,930
methods here which updates our key value

00:13:51,860 --> 00:13:58,759
store with ingredients right and let's

00:13:56,930 --> 00:14:02,660
shopping and now we can implement

00:13:58,759 --> 00:14:06,620
cooking so for cooking what we do is we

00:14:02,660 --> 00:14:09,680
first go shopping then we cook some

00:14:06,620 --> 00:14:11,329
sauce so to cook sauce what we need to

00:14:09,680 --> 00:14:13,759
do so let's say we need wants to cook

00:14:11,329 --> 00:14:18,019
five sources or five of sauce whatever

00:14:13,759 --> 00:14:19,370
the unit is now we need to pass in the

00:14:18,019 --> 00:14:21,800
take food method right

00:14:19,370 --> 00:14:23,809
the take food method and cook sauce if

00:14:21,800 --> 00:14:25,370
you look here it takes the full name and

00:14:23,809 --> 00:14:28,040
quantity right it doesn't know anything

00:14:25,370 --> 00:14:29,420
about the key value store and there's no

00:14:28,040 --> 00:14:32,509
reason why it should know anything about

00:14:29,420 --> 00:14:36,170
the key value store so what we do is we

00:14:32,509 --> 00:14:38,059
pass in the partially applied and take

00:14:36,170 --> 00:14:40,189
food method which we have a sorry not

00:14:38,059 --> 00:14:44,660
take add food method which we have

00:14:40,189 --> 00:14:47,300
implemented earlier okay and so we are

00:14:44,660 --> 00:14:53,029
passing the key value instance that we

00:14:47,300 --> 00:14:56,540
have defined here and similarly sorry

00:14:53,029 --> 00:14:59,920
that was remove food sir remove food and

00:14:56,540 --> 00:15:05,290
add food similarly partially applied

00:14:59,920 --> 00:15:09,290
okay and in a similar way we can cook

00:15:05,290 --> 00:15:11,959
pasta and we cook 10 pasta because we

00:15:09,290 --> 00:15:13,850
like pasta and we use some string just

00:15:11,959 --> 00:15:15,810
to see the results that it actually

00:15:13,850 --> 00:15:18,040
works

00:15:15,810 --> 00:15:23,689
[Music]

00:15:18,040 --> 00:15:25,910
pasta and to be able to run our program

00:15:23,689 --> 00:15:30,470
we will eat things so that way that

00:15:25,910 --> 00:15:33,460
result and results so cooking it's very

00:15:30,470 --> 00:15:36,220
fast cooking only one second

00:15:33,460 --> 00:15:42,580
okay hopefully this will compile and and

00:15:36,220 --> 00:15:45,880
run and so and yeah you can see that it

00:15:42,580 --> 00:15:48,399
compiles or not okay so so far what we

00:15:45,880 --> 00:15:50,350
have done we have implemented so we have

00:15:48,399 --> 00:15:54,010
one basic abstraction which is the key

00:15:50,350 --> 00:15:56,890
value store on top of that we have the

00:15:54,010 --> 00:15:59,800
food storage which for now takes the

00:15:56,890 --> 00:16:02,740
form of two methods but the methods take

00:15:59,800 --> 00:16:04,570
a quick value servant and operate on it

00:16:02,740 --> 00:16:07,000
and finally we have the third level

00:16:04,570 --> 00:16:10,480
which is the cooking level here we take

00:16:07,000 --> 00:16:13,930
as parameters the methods which operate

00:16:10,480 --> 00:16:17,620
which allow us to take food in some way

00:16:13,930 --> 00:16:19,750
right and finally when we actually wants

00:16:17,620 --> 00:16:23,580
to run our application we have to pass

00:16:19,750 --> 00:16:27,790
in the dependencies to the appropriate

00:16:23,580 --> 00:16:29,709
to the appropriate functions so so far

00:16:27,790 --> 00:16:33,160
we have used only functions nothing

00:16:29,709 --> 00:16:35,200
nothing very complicated okay so by the

00:16:33,160 --> 00:16:37,360
way like in a real application all of

00:16:35,200 --> 00:16:39,730
these sections would be in separate

00:16:37,360 --> 00:16:42,910
files here I'm having it all in one file

00:16:39,730 --> 00:16:45,279
just for just for demo okay

00:16:42,910 --> 00:16:47,770
so now well we are not happy with our

00:16:45,279 --> 00:16:49,570
code so far we want to improve it so we

00:16:47,770 --> 00:16:51,550
have spotted that there are some things

00:16:49,570 --> 00:16:53,529
that there's some repetition which we

00:16:51,550 --> 00:16:57,670
would like to eliminate so for example

00:16:53,529 --> 00:17:02,290
here the the key value parameter is a

00:16:57,670 --> 00:17:05,380
common for both for both methods and we

00:17:02,290 --> 00:17:07,949
actually decided to extract it a higher

00:17:05,380 --> 00:17:11,939
and we decides to create a class fridge

00:17:07,949 --> 00:17:16,199
which will take the key value parameter

00:17:11,939 --> 00:17:21,579
and they keep the key value storage and

00:17:16,199 --> 00:17:24,250
and so that we can use it in both of

00:17:21,579 --> 00:17:27,730
these methods okay so we have extracted

00:17:24,250 --> 00:17:31,090
some of these parameters into a 1:1

00:17:27,730 --> 00:17:34,840
level higher so now we have a class with

00:17:31,090 --> 00:17:36,850
with two methods and what justice is

00:17:34,840 --> 00:17:39,730
parameterized by a by our key value

00:17:36,850 --> 00:17:42,220
store so in a way you can think of these

00:17:39,730 --> 00:17:44,169
methods inside this these classes as

00:17:42,220 --> 00:17:45,850
being partially applied functions right

00:17:44,169 --> 00:17:46,190
because if we have an instance of fridge

00:17:45,850 --> 00:17:49,460
we

00:17:46,190 --> 00:17:52,090
have the first parameter here right so

00:17:49,460 --> 00:17:54,740
it's already like partially applied and

00:17:52,090 --> 00:17:58,100
so that we can use these methods over

00:17:54,740 --> 00:18:00,200
here so now why why did we extract only

00:17:58,100 --> 00:18:02,690
the key value store and not the food

00:18:00,200 --> 00:18:04,610
name and food quantity well the role of

00:18:02,690 --> 00:18:07,070
the parameter is a bit different right

00:18:04,610 --> 00:18:10,730
the key value store is kind of a service

00:18:07,070 --> 00:18:14,440
type parameter right and it's probably

00:18:10,730 --> 00:18:17,620
going to be fixed for the duration of

00:18:14,440 --> 00:18:20,360
the operation of our application and

00:18:17,620 --> 00:18:21,620
these are more data like parameters

00:18:20,360 --> 00:18:24,890
right so they are going to change from

00:18:21,620 --> 00:18:27,440
invocation to invocation so that's

00:18:24,890 --> 00:18:31,580
that's why we have decided to split the

00:18:27,440 --> 00:18:36,980
parameters this way okay in a similar

00:18:31,580 --> 00:18:40,850
way we can extract these two parameters

00:18:36,980 --> 00:18:42,890
here right and so we could create a

00:18:40,850 --> 00:18:44,990
class which had the to take food

00:18:42,890 --> 00:18:47,090
function and add food functions as

00:18:44,990 --> 00:18:50,060
parameters but we notice that these

00:18:47,090 --> 00:18:52,460
signatures are exactly they are exactly

00:18:50,060 --> 00:18:54,860
the same as the methyl as the methods

00:18:52,460 --> 00:18:59,690
over here which is a very lucky

00:18:54,860 --> 00:19:05,470
coincidence because we can now extract a

00:18:59,690 --> 00:19:08,900
class take a fridge as a parameter and

00:19:05,470 --> 00:19:12,890
remove those ugly functions of ugly

00:19:08,900 --> 00:19:16,490
dependencies all together okay and fix

00:19:12,890 --> 00:19:18,500
the code of course because now now we

00:19:16,490 --> 00:19:20,930
don't have like direct access we need to

00:19:18,500 --> 00:19:25,370
go to the fridge and enter and take the

00:19:20,930 --> 00:19:29,470
food or add food okay so we have

00:19:25,370 --> 00:19:32,060
extracted some parameters over here and

00:19:29,470 --> 00:19:34,580
so we have we have SES so we have moved

00:19:32,060 --> 00:19:36,500
the parameters to plus parameters right

00:19:34,580 --> 00:19:40,340
we have created like classes are like

00:19:36,500 --> 00:19:42,410
wrappers for for final four methods

00:19:40,340 --> 00:19:45,350
which have similar functionality and

00:19:42,410 --> 00:19:47,030
which have similar dependencies and so

00:19:45,350 --> 00:19:49,730
now what we ate what we need to do to

00:19:47,030 --> 00:19:51,680
actually and why doesn't this compile

00:19:49,730 --> 00:19:53,920
because this will take food its remove

00:19:51,680 --> 00:19:53,920
food

00:19:55,110 --> 00:20:02,470
and so now what we need to do is we need

00:20:00,220 --> 00:20:03,970
to update our end-of-the-world code

00:20:02,470 --> 00:20:07,110
right where we actually bootstrap and

00:20:03,970 --> 00:20:12,430
run things so we need to create a new

00:20:07,110 --> 00:20:14,860
fridge it takes the key value store as a

00:20:12,430 --> 00:20:20,200
parameter and we need to create a new

00:20:14,860 --> 00:20:24,640
cooker cooker and which takes a fridge

00:20:20,200 --> 00:20:30,240
and now we have to do some change more

00:20:24,640 --> 00:20:32,050
changes here so we add if we call this

00:20:30,240 --> 00:20:35,110
on the fridge

00:20:32,050 --> 00:20:36,880
right we have moved the parameter from

00:20:35,110 --> 00:20:38,800
the it's not law it's no longer the

00:20:36,880 --> 00:20:41,110
first parameter of the method but it's a

00:20:38,800 --> 00:20:44,650
method on the class so that's not a very

00:20:41,110 --> 00:20:46,570
big difference and here we call methods

00:20:44,650 --> 00:20:48,310
on the cooker and remove these

00:20:46,570 --> 00:20:50,100
dependencies over here because these

00:20:48,310 --> 00:20:55,750
dependencies already passed at

00:20:50,100 --> 00:20:58,950
construction time and over here ok so I

00:20:55,750 --> 00:20:58,950
called hopefully stir works

00:21:01,350 --> 00:21:07,240
yes still compile and work let's learn

00:21:04,450 --> 00:21:09,490
it ok so now what we have done is we

00:21:07,240 --> 00:21:12,250
have a notice that some of the

00:21:09,490 --> 00:21:15,310
dependencies are common for for the

00:21:12,250 --> 00:21:16,720
methods and for the fridge methods and

00:21:15,310 --> 00:21:20,260
for the cucumetto so we've extracted

00:21:16,720 --> 00:21:22,480
them as a class parameter right and and

00:21:20,260 --> 00:21:25,480
also like we've noted that they are like

00:21:22,480 --> 00:21:27,640
two kinds of parameters these are like

00:21:25,480 --> 00:21:30,030
the service type parameters and if I

00:21:27,640 --> 00:21:33,120
like more the data like parameters right

00:21:30,030 --> 00:21:37,510
similarly here the fridge doesn't change

00:21:33,120 --> 00:21:39,910
as it's always the same parameter like

00:21:37,510 --> 00:21:43,150
throughout the operation of our

00:21:39,910 --> 00:21:44,940
application but the parameters here do

00:21:43,150 --> 00:21:49,930
differ from invocation to invocation

00:21:44,940 --> 00:21:50,260
okay and so now to complicate things a

00:21:49,930 --> 00:21:54,940
bit

00:21:50,260 --> 00:21:57,910
we will create an IOT enabled fridge so

00:21:54,940 --> 00:22:01,370
let's say we have a new we have a new

00:21:57,910 --> 00:22:04,730
dependency and so we will have

00:22:01,370 --> 00:22:09,020
we'll have a Nike trade just to show you

00:22:04,730 --> 00:22:10,760
how we can add more dependencies the IOT

00:22:09,020 --> 00:22:16,850
is very simple it only allows you to

00:22:10,760 --> 00:22:22,040
notify users with a message we will have

00:22:16,850 --> 00:22:27,490
a default implementation cloud IOT

00:22:22,040 --> 00:22:37,490
gateway user name string password string

00:22:27,490 --> 00:22:42,050
and it implements IOT and we'll just do

00:22:37,490 --> 00:22:47,270
a future success for print line sending

00:22:42,050 --> 00:22:49,280
via cloud the given message ok so now

00:22:47,270 --> 00:22:52,520
our fridge so we have a very simple IOT

00:22:49,280 --> 00:22:54,590
and service right so now we want our

00:22:52,520 --> 00:22:56,210
fridge to be able to use this IOT

00:22:54,590 --> 00:22:58,610
service again it's an it's a service

00:22:56,210 --> 00:23:01,340
type parameter so we added and like to

00:22:58,610 --> 00:23:03,530
the common to the common parameters in

00:23:01,340 --> 00:23:08,290
the class and now we can use it anywhere

00:23:03,530 --> 00:23:13,280
we like like so here we can say IOT and

00:23:08,290 --> 00:23:17,420
the send not notify user and notify user

00:23:13,280 --> 00:23:24,800
and at a given quantity of a given thing

00:23:17,420 --> 00:23:28,900
was added to the fridge and here we say

00:23:24,800 --> 00:23:32,270
that it was removed from the fridge ok

00:23:28,900 --> 00:23:34,670
so now we are almost done if we try to

00:23:32,270 --> 00:23:36,620
compile we will actually get a compile

00:23:34,670 --> 00:23:40,300
time error so here we have an

00:23:36,620 --> 00:23:43,370
unsatisfied dependency right so that's

00:23:40,300 --> 00:23:45,350
that's a good thing of actually using

00:23:43,370 --> 00:23:48,200
Scala for these things because you get

00:23:45,350 --> 00:23:50,660
compile time errors you don't like if we

00:23:48,200 --> 00:23:52,370
loose for example right we only get a

00:23:50,660 --> 00:23:55,040
runtime error that the dependency is

00:23:52,370 --> 00:23:59,780
missing so we need to create the IOT

00:23:55,040 --> 00:24:03,410
dependency so we do that's bad cloud IOT

00:23:59,780 --> 00:24:05,990
gateway user name scott password tiger

00:24:03,410 --> 00:24:09,230
ok and now we can use it here

00:24:05,990 --> 00:24:13,440
it's an Oracle gateway so we can use it

00:24:09,230 --> 00:24:16,080
here and so this will almost work ex

00:24:13,440 --> 00:24:19,230
cept that at the moment when a fridge is

00:24:16,080 --> 00:24:21,990
constructed IOT will still be null right

00:24:19,230 --> 00:24:24,419
because this evolved and so there are

00:24:21,990 --> 00:24:26,129
two way to fix this one is to

00:24:24,419 --> 00:24:27,720
essentially drive well three ways once

00:24:26,129 --> 00:24:31,590
within 30 days you will get a warning

00:24:27,720 --> 00:24:33,690
the other way is to manually construct

00:24:31,590 --> 00:24:38,059
this in the right order and the third

00:24:33,690 --> 00:24:40,620
way is to let it evolve and that way the

00:24:38,059 --> 00:24:42,179
the right order will be figured out for

00:24:40,620 --> 00:24:45,029
you automatically so we don't have you

00:24:42,179 --> 00:24:46,980
don't have to use you but you don't have

00:24:45,029 --> 00:24:50,789
to worry about it and now we can try

00:24:46,980 --> 00:24:52,649
running it and you can see that we are

00:24:50,789 --> 00:24:54,509
getting some IOT notifications every

00:24:52,649 --> 00:24:57,179
time something has happened to the

00:24:54,509 --> 00:25:00,149
fridge okay so now what we have done

00:24:57,179 --> 00:25:02,039
here is from from like the new things we

00:25:00,149 --> 00:25:05,970
have added a new dependency so now our

00:25:02,039 --> 00:25:08,700
and our end of the world code is getting

00:25:05,970 --> 00:25:11,309
a bit bigger right

00:25:08,700 --> 00:25:12,929
we are when we actually want to run the

00:25:11,309 --> 00:25:15,450
application we have a section where we

00:25:12,929 --> 00:25:17,309
create the object graph right so here we

00:25:15,450 --> 00:25:18,990
create the object which is kind of more

00:25:17,309 --> 00:25:21,029
less static throughout our application

00:25:18,990 --> 00:25:22,950
right because these reasons we change

00:25:21,029 --> 00:25:26,250
you have the services which are wired

00:25:22,950 --> 00:25:32,370
together and they operate latest or like

00:25:26,250 --> 00:25:34,259
when your application works and so we

00:25:32,370 --> 00:25:36,210
have a section where we create object

00:25:34,259 --> 00:25:38,450
graph using Scala and lay the vault and

00:25:36,210 --> 00:25:43,679
then we can use it to the actual work

00:25:38,450 --> 00:25:46,019
okay so let's let's that's like so what

00:25:43,679 --> 00:25:48,570
we have here is the constructor Base

00:25:46,019 --> 00:25:50,519
dependency in the dependency injection

00:25:48,570 --> 00:25:55,559
as you can see it's quite simple right

00:25:50,519 --> 00:25:57,480
it's just using it's one step from using

00:25:55,559 --> 00:26:01,169
methods for everything and passing

00:25:57,480 --> 00:26:02,820
around functions but that's that's not

00:26:01,169 --> 00:26:05,279
very convenient because you get a lot of

00:26:02,820 --> 00:26:06,899
these function parameters so we can we

00:26:05,279 --> 00:26:08,970
can use the constructor by dependency

00:26:06,899 --> 00:26:12,960
injection actually make our life a bit

00:26:08,970 --> 00:26:17,279
easier so now and let's let's jump to

00:26:12,960 --> 00:26:23,340
the second part so let's say we have a

00:26:17,279 --> 00:26:25,970
change of heart and just needs to update

00:26:23,340 --> 00:26:27,650
my notes okay let's say we have a

00:26:25,970 --> 00:26:31,220
heart and we actually want to track

00:26:27,650 --> 00:26:35,390
exactly when we access the key value

00:26:31,220 --> 00:26:39,350
store so if you look up here at the add

00:26:35,390 --> 00:26:43,340
food method signature well it returns a

00:26:39,350 --> 00:26:45,770
u.s. future so we kind of suspect that

00:26:43,340 --> 00:26:47,870
there's some a synchronous things going

00:26:45,770 --> 00:26:51,110
on in the background but we don't really

00:26:47,870 --> 00:26:53,120
know what what what kind of a singles

00:26:51,110 --> 00:26:55,700
operations right the futures completely

00:26:53,120 --> 00:26:58,040
opaque and so let's say now we want to

00:26:55,700 --> 00:27:01,400
track exactly when we access the key

00:26:58,040 --> 00:27:03,800
value store so before this key value

00:27:01,400 --> 00:27:08,210
store was an implementation detail of

00:27:03,800 --> 00:27:10,760
the fridge right so if we look at

00:27:08,210 --> 00:27:13,580
clients of our fridge class like the

00:27:10,760 --> 00:27:15,670
cooker right it has no idea that fridge

00:27:13,580 --> 00:27:18,470
is implemented using a key value store

00:27:15,670 --> 00:27:21,710
okay so that it was an emblem in an

00:27:18,470 --> 00:27:24,350
implementation detail and we did we we

00:27:21,710 --> 00:27:26,540
achieved that using a constructor based

00:27:24,350 --> 00:27:28,100
dependency injection but now we have a

00:27:26,540 --> 00:27:30,920
change of heart and we actually wants to

00:27:28,100 --> 00:27:32,480
make it explicit that we want to make it

00:27:30,920 --> 00:27:36,050
visible in the method signature

00:27:32,480 --> 00:27:37,970
that whenever use a key value store you

00:27:36,050 --> 00:27:40,190
want to you want to have it in the in

00:27:37,970 --> 00:27:45,140
the signature so what we will do is

00:27:40,190 --> 00:27:47,660
remove the parameter from here and we

00:27:45,140 --> 00:27:49,850
will move it to the to the method

00:27:47,660 --> 00:27:51,560
signature so but we won't edit to the

00:27:49,850 --> 00:27:56,150
method parameters but instead will

00:27:51,560 --> 00:27:57,920
return a function which so the result of

00:27:56,150 --> 00:28:00,170
our method will be a function which

00:27:57,920 --> 00:28:03,890
needs a key value store to operate and

00:28:00,170 --> 00:28:06,530
returns a future okay so as we return a

00:28:03,890 --> 00:28:10,360
function here well we need to return the

00:28:06,530 --> 00:28:13,940
function right so what we do is we take

00:28:10,360 --> 00:28:16,460
we take a parameter called the C and

00:28:13,940 --> 00:28:17,270
then the rest of the implementation is

00:28:16,460 --> 00:28:19,640
unchanged

00:28:17,270 --> 00:28:22,220
right it's a function we take a

00:28:19,640 --> 00:28:24,920
parameter and return some results which

00:28:22,220 --> 00:28:27,440
use this which use this which uses this

00:28:24,920 --> 00:28:33,140
parameter and we do a similar thing over

00:28:27,440 --> 00:28:36,710
here okay and so again we have moved the

00:28:33,140 --> 00:28:39,030
dependency from the constructor to the

00:28:36,710 --> 00:28:43,470
results type of the

00:28:39,030 --> 00:28:46,530
of the method okay so far it's not a

00:28:43,470 --> 00:28:48,990
huge change however if you look at the

00:28:46,530 --> 00:28:56,250
signature of the ad food method you can

00:28:48,990 --> 00:29:01,170
now with a high degree of probability be

00:28:56,250 --> 00:29:03,000
sure that you have a future here because

00:29:01,170 --> 00:29:06,780
a food key value store is used right

00:29:03,000 --> 00:29:08,310
well most probably the key value store

00:29:06,780 --> 00:29:10,950
parameter is here because it's going to

00:29:08,310 --> 00:29:13,710
be used at some point so you have like

00:29:10,950 --> 00:29:16,770
you know that the side-effect in the

00:29:13,710 --> 00:29:21,840
Etzel method are due to the two using

00:29:16,770 --> 00:29:23,640
the key value at least in part okay so

00:29:21,840 --> 00:29:26,310
now let's make this called one compile

00:29:23,640 --> 00:29:29,730
because we have the clients of the

00:29:26,310 --> 00:29:32,670
fridge right right now the remove food

00:29:29,730 --> 00:29:34,830
method returns a function which needs a

00:29:32,670 --> 00:29:37,080
key value store so we need to take the

00:29:34,830 --> 00:29:39,540
key value store from somewhere but we

00:29:37,080 --> 00:29:44,640
don't have it so we will return and we

00:29:39,540 --> 00:29:50,340
will return a food key value a function

00:29:44,640 --> 00:29:54,150
here as well and we will do the same the

00:29:50,340 --> 00:29:57,150
same changes as we did before and now we

00:29:54,150 --> 00:29:59,550
need to change our code a bit so now in

00:29:57,150 --> 00:30:01,200
the cooker the key value store stopped

00:29:59,550 --> 00:30:03,900
being an implementation detail of the

00:30:01,200 --> 00:30:06,690
fridge instead some an explicit

00:30:03,900 --> 00:30:09,000
dependency right because we wants to

00:30:06,690 --> 00:30:12,030
track which method uses the key value

00:30:09,000 --> 00:30:13,740
store and indeed the cook sauce doesn't

00:30:12,030 --> 00:30:16,590
need a key value store to operate right

00:30:13,740 --> 00:30:19,500
it does have that effect because it uses

00:30:16,590 --> 00:30:21,510
the fridge and so we will return a

00:30:19,500 --> 00:30:23,880
function here so we take to implement

00:30:21,510 --> 00:30:27,930
the function we take a parameter and we

00:30:23,880 --> 00:30:30,480
pass it on to whatever the fridge method

00:30:27,930 --> 00:30:33,510
returned right so they remove food

00:30:30,480 --> 00:30:37,110
method that one now returns a function

00:30:33,510 --> 00:30:39,900
which takes a key value store and then

00:30:37,110 --> 00:30:42,600
only gives the result so to get the

00:30:39,900 --> 00:30:46,530
result we actually in how we actually

00:30:42,600 --> 00:30:50,400
use a we are we actually invoke that

00:30:46,530 --> 00:30:52,230
function here and the same happens over

00:30:50,400 --> 00:30:59,280
here for

00:30:52,230 --> 00:31:03,710
vanya and so FC and we have to pass them

00:30:59,280 --> 00:31:06,720
and the partner over here okay and

00:31:03,710 --> 00:31:12,150
finally we have to fix our graphic

00:31:06,720 --> 00:31:14,850
creation code so we remove it we remove

00:31:12,150 --> 00:31:16,559
the parameter and we have to add the

00:31:14,850 --> 00:31:18,990
method invocations everywhere over here

00:31:16,559 --> 00:31:24,480
so this isn't very nice but we'll fix it

00:31:18,990 --> 00:31:27,809
in a second and over here as well okay

00:31:24,480 --> 00:31:31,140
so now it compiles again okay

00:31:27,809 --> 00:31:37,140
so now what we have achieved and what we

00:31:31,140 --> 00:31:38,429
have changed we have moved the key value

00:31:37,140 --> 00:31:41,429
dependency it's no longer an

00:31:38,429 --> 00:31:43,799
implementation detail of the fridge but

00:31:41,429 --> 00:31:46,679
it's something hopefully opposite it's

00:31:43,799 --> 00:31:49,980
an explicit dependency which we for

00:31:46,679 --> 00:31:51,330
which we want to track usage right so we

00:31:49,980 --> 00:31:54,690
need we need to know exactly which

00:31:51,330 --> 00:31:57,059
method we possibly transitively touch

00:31:54,690 --> 00:31:59,340
the key value store and so now we know

00:31:57,059 --> 00:32:01,140
exactly which method and so we have kind

00:31:59,340 --> 00:32:04,740
of affected tracking right it's like an

00:32:01,140 --> 00:32:06,900
effect tracking system okay so this code

00:32:04,740 --> 00:32:09,990
isn't very pretty so we have all of

00:32:06,900 --> 00:32:11,309
these functional vacations over here so

00:32:09,990 --> 00:32:14,340
how can we make it nicer

00:32:11,309 --> 00:32:16,919
and here comes in the reader moment so

00:32:14,340 --> 00:32:22,260
the reader monad and it's just a fancy

00:32:16,919 --> 00:32:25,440
name for a for a function sorry okay

00:32:22,260 --> 00:32:30,919
okay so the reader monad is just a case

00:32:25,440 --> 00:32:30,919
cloud okay which encapsulate a function

00:32:31,910 --> 00:32:40,260
for a fixed first parameter okay

00:32:35,640 --> 00:32:43,320
and so the reader monad is a case plus

00:32:40,260 --> 00:32:45,600
which wraps a function and so just be

00:32:43,320 --> 00:32:49,260
precise we need to add the dye

00:32:45,600 --> 00:32:52,040
parameters here and so and if we fix the

00:32:49,260 --> 00:32:55,230
first type parameter so if we fix T and

00:32:52,040 --> 00:32:57,870
only vary the second type parameter

00:32:55,230 --> 00:32:59,700
let's will form a moment so what does it

00:32:57,870 --> 00:33:01,440
mean in practice in practice it means

00:32:59,700 --> 00:33:05,080
that you can use the for comprehension

00:33:01,440 --> 00:33:10,300
to combine a series of such

00:33:05,080 --> 00:33:12,340
in of that construct okay and in fact we

00:33:10,300 --> 00:33:15,390
will use a slightly more advanced

00:33:12,340 --> 00:33:21,400
variant so we have also the reader T

00:33:15,390 --> 00:33:29,320
which has three type parameters and tu

00:33:21,400 --> 00:33:32,260
and it wraps a very similar function so

00:33:29,320 --> 00:33:34,900
here is the original key it's also a Mon

00:33:32,260 --> 00:33:38,770
AB and it Trump's a function which takes

00:33:34,900 --> 00:33:41,170
a parameter and returns erupted erupted

00:33:38,770 --> 00:33:43,450
result okay so the wrapper for example

00:33:41,170 --> 00:33:47,020
can be future right that's that that

00:33:43,450 --> 00:33:49,960
will be the wrapper in our case and it

00:33:47,020 --> 00:33:52,000
also forms a monad if F is a moment okay

00:33:49,960 --> 00:33:56,650
so - so to combine the result it will

00:33:52,000 --> 00:33:58,510
use however F is combined later okay so

00:33:56,650 --> 00:34:00,550
that's if you if you look at this

00:33:58,510 --> 00:34:04,080
function right it's like it's exactly

00:34:00,550 --> 00:34:09,040
the same shape as the one over here

00:34:04,080 --> 00:34:11,500
right and so we will we will wrap we

00:34:09,040 --> 00:34:13,270
will wrap the functions that we returned

00:34:11,500 --> 00:34:15,340
from these methods into the reader

00:34:13,270 --> 00:34:18,070
monitor and this will allow to make our

00:34:15,340 --> 00:34:22,720
code a bit nicer so what we will do is

00:34:18,070 --> 00:34:31,540
we will return a reader T future food

00:34:22,720 --> 00:34:34,030
key value store unit and differ this

00:34:31,540 --> 00:34:36,370
means that it's what a function which

00:34:34,030 --> 00:34:40,090
takes a food key value store and return

00:34:36,370 --> 00:34:42,370
a unit wrapped in the future okay so

00:34:40,090 --> 00:34:46,450
maybe I will just write it in a comment

00:34:42,370 --> 00:34:50,050
over here that's so that it's clear is a

00:34:46,450 --> 00:34:54,490
method it's a function wrapped food key

00:34:50,050 --> 00:34:56,560
value store future unit okay and well to

00:34:54,490 --> 00:34:58,240
create the wrapping what we have to do

00:34:56,560 --> 00:35:00,100
is we have to create the paste that

00:34:58,240 --> 00:35:08,190
instance right so we simply write with

00:35:00,100 --> 00:35:10,570
dirty that's the constructor of the

00:35:08,190 --> 00:35:13,330
that's the constructor of the case class

00:35:10,570 --> 00:35:18,109
right and then we pass in the function

00:35:13,330 --> 00:35:22,609
okay as before so no no no no changes

00:35:18,109 --> 00:35:34,489
a very similar change over here on a

00:35:22,609 --> 00:35:37,039
wheel tank 1td reader t okay and just to

00:35:34,489 --> 00:35:41,630
get the braces right okay so they remove

00:35:37,039 --> 00:35:43,880
food let me up make it like this the

00:35:41,630 --> 00:35:46,489
remove food again it takes the case

00:35:43,880 --> 00:35:50,480
class constructor and drops a function

00:35:46,489 --> 00:35:53,150
okay so so far so good now let's proceed

00:35:50,480 --> 00:35:55,460
to the cooker so now the cooker well

00:35:53,150 --> 00:35:58,430
over here these methods

00:35:55,460 --> 00:36:01,489
now return and not functions they return

00:35:58,430 --> 00:36:05,319
the web function three dirty instances

00:36:01,489 --> 00:36:10,940
right so we would like to use them and

00:36:05,319 --> 00:36:13,430
so I would just copy that so we notice

00:36:10,940 --> 00:36:16,279
that the function that we return here

00:36:13,430 --> 00:36:18,380
and also the same like the same shape so

00:36:16,279 --> 00:36:22,609
we can also probably return the wrapped

00:36:18,380 --> 00:36:25,579
version that's what we will do and well

00:36:22,609 --> 00:36:28,730
we could wrap simply wrap the function

00:36:25,579 --> 00:36:31,549
and so we could simply write reader key

00:36:28,730 --> 00:36:34,039
over here right and wrap the function

00:36:31,549 --> 00:36:36,440
and then unwrap the results that we get

00:36:34,039 --> 00:36:39,289
here and and invoke them but that would

00:36:36,440 --> 00:36:40,789
be just more manual work instead what

00:36:39,289 --> 00:36:43,339
the reader monad allows us to those

00:36:40,789 --> 00:36:45,230
thanks to the power that it's a monad we

00:36:43,339 --> 00:36:47,779
can use it Anna for comprehension so we

00:36:45,230 --> 00:36:55,549
can remove that parameter and we can

00:36:47,779 --> 00:36:57,529
remove all these invocations so and so

00:36:55,549 --> 00:36:59,499
what the reader monads does for us right

00:36:57,529 --> 00:37:04,210
so that's what what the flat map

00:36:59,499 --> 00:37:08,630
implementation in the reader T does it a

00:37:04,210 --> 00:37:10,819
it invokes all the functions in as we

00:37:08,630 --> 00:37:12,739
combine them right so here like before

00:37:10,819 --> 00:37:15,049
you can see it below here we have

00:37:12,739 --> 00:37:17,720
manually created a function and then

00:37:15,049 --> 00:37:20,660
invoked all of the dependent functions

00:37:17,720 --> 00:37:23,839
with that parameter the reader Mona does

00:37:20,660 --> 00:37:26,329
it for us automatically right so we no

00:37:23,839 --> 00:37:28,430
longer need to return the functions we

00:37:26,329 --> 00:37:31,160
can just compose the reader Menard

00:37:28,430 --> 00:37:33,530
instances that we have

00:37:31,160 --> 00:37:35,750
stained here great so the code again

00:37:33,530 --> 00:37:37,580
looks much nice that we don't have all

00:37:35,750 --> 00:37:42,410
that noise with the functional vocations

00:37:37,580 --> 00:37:45,890
and so on but behind the scenes it's it

00:37:42,410 --> 00:37:49,850
works exactly the same it will be a

00:37:45,890 --> 00:37:53,000
function that once provided the key

00:37:49,850 --> 00:37:55,460
value parameter will invoke for this

00:37:53,000 --> 00:37:58,010
function then it will invoke this

00:37:55,460 --> 00:38:03,110
function with with the person parameter

00:37:58,010 --> 00:38:04,670
okay that's that's the Monad part which

00:38:03,110 --> 00:38:07,670
essentially means that we can use that

00:38:04,670 --> 00:38:13,220
in there for comprehension without that

00:38:07,670 --> 00:38:17,900
that noise okay and we also need to

00:38:13,220 --> 00:38:21,920
change some of things down here and so

00:38:17,900 --> 00:38:23,870
before we head again those function

00:38:21,920 --> 00:38:28,580
invocations which are just boilerplate

00:38:23,870 --> 00:38:31,640
so we can remove all of them because now

00:38:28,580 --> 00:38:33,890
we can combine all of these all of these

00:38:31,640 --> 00:38:37,850
methods the add food method they

00:38:33,890 --> 00:38:40,580
returned and they they returned with our

00:38:37,850 --> 00:38:42,980
instances so we can simply combine them

00:38:40,580 --> 00:38:46,280
into one big reader instance which when

00:38:42,980 --> 00:38:49,430
applied the parameter will apply all of

00:38:46,280 --> 00:38:53,720
these and in the sequence and similar

00:38:49,430 --> 00:38:56,030
over here although like one thing you

00:38:53,720 --> 00:39:01,280
don't really see behind the scenes right

00:38:56,030 --> 00:39:05,330
if we explicitly call the the functions

00:39:01,280 --> 00:39:10,910
here this has type future or quantity

00:39:05,330 --> 00:39:14,810
right and now if we remove these we get

00:39:10,910 --> 00:39:19,220
the reader T of like these these

00:39:14,810 --> 00:39:23,330
parameters right so we get a slightly

00:39:19,220 --> 00:39:28,190
different return type and so our cooking

00:39:23,330 --> 00:39:30,590
value is now a big reader reader

00:39:28,190 --> 00:39:32,720
instance right which wraps a function

00:39:30,590 --> 00:39:35,860
which when applied to a parameter will

00:39:32,720 --> 00:39:38,270
run all of our code in sequence so we

00:39:35,860 --> 00:39:40,430
can't reuse cooking and Evon arrow it

00:39:38,270 --> 00:39:42,260
result because it's a reader at the

00:39:40,430 --> 00:39:44,569
future so thing to do is we need to

00:39:42,260 --> 00:39:48,529
actually unwrap it

00:39:44,569 --> 00:39:51,109
so the we are not producing run and if

00:39:48,529 --> 00:39:53,029
you go to the source you can see it's

00:39:51,109 --> 00:39:54,559
the case class which is called place you

00:39:53,029 --> 00:39:57,229
not reader key but it's the same thing

00:39:54,559 --> 00:39:58,640
don't worry the case lat and it wraps it

00:39:57,229 --> 00:40:03,709
has a single parameter which is a

00:39:58,640 --> 00:40:06,559
function just as I told you so and so so

00:40:03,709 --> 00:40:09,919
that that's exactly what what what we

00:40:06,559 --> 00:40:13,189
have right and and that parameter is

00:40:09,919 --> 00:40:14,630
called run okay so to unwrap so to get

00:40:13,189 --> 00:40:18,709
the function from the reader Monett we

00:40:14,630 --> 00:40:25,179
just go run and we provide the parameter

00:40:18,709 --> 00:40:29,900
and it hopefully should work that's fine

00:40:25,179 --> 00:40:33,169
okay so five minutes that's not a lot

00:40:29,900 --> 00:40:35,900
but we are almost done okay so the

00:40:33,169 --> 00:40:37,669
crucial difference here with the with

00:40:35,900 --> 00:40:41,119
the reader monad we don't really do

00:40:37,669 --> 00:40:43,279
dependency injection right we because we

00:40:41,119 --> 00:40:45,499
don't less like there's no dependency

00:40:43,279 --> 00:40:47,559
hiding we don't hide the dependency

00:40:45,499 --> 00:40:51,919
quite the opposite to make it explicit

00:40:47,559 --> 00:40:54,890
okay and so that's like quite a crucial

00:40:51,919 --> 00:40:58,249
difference between these two dependency

00:40:54,890 --> 00:41:00,109
injection hides your dependencies the

00:40:58,249 --> 00:41:02,929
reader Monat makes them makes them

00:41:00,109 --> 00:41:04,130
explicit and they're both useful I guess

00:41:02,929 --> 00:41:06,439
that that's the good part

00:41:04,130 --> 00:41:08,269
you can use both constructor base or

00:41:06,439 --> 00:41:10,579
whatever based dependency injection and

00:41:08,269 --> 00:41:13,609
the reader Mona but for different things

00:41:10,579 --> 00:41:18,159
right so here in our example we still

00:41:13,609 --> 00:41:21,739
have the IOT dependency hidden right a

00:41:18,159 --> 00:41:27,109
client of fridge have no idea that the

00:41:21,739 --> 00:41:31,029
fridge uses the IOT dependency right but

00:41:27,109 --> 00:41:31,029
they're very well aware of the fact that

00:41:31,539 --> 00:41:36,949
that it needs a key value store to

00:41:34,400 --> 00:41:39,589
operate because we have decided to track

00:41:36,949 --> 00:41:43,130
a track as an effect okay

00:41:39,589 --> 00:41:45,019
so and you can use the reader monad to

00:41:43,130 --> 00:41:46,419
track effects in your to track effects

00:41:45,019 --> 00:41:49,099
in your code and you can use

00:41:46,419 --> 00:41:52,400
constructors also known as dependency

00:41:49,099 --> 00:41:55,669
injection for hiding dependencies well

00:41:52,400 --> 00:41:57,409
now probably I should also take a vinta

00:41:55,669 --> 00:41:58,250
Martin's keynote and here the whole

00:41:57,409 --> 00:42:01,130
slide

00:41:58,250 --> 00:42:05,000
of why on why the we on why the reader

00:42:01,130 --> 00:42:06,260
monad is bad and it's true that you

00:42:05,000 --> 00:42:09,470
could do the same with implicit

00:42:06,260 --> 00:42:11,630
functions and what you will be able to

00:42:09,470 --> 00:42:15,590
do it with in with implicit functions in

00:42:11,630 --> 00:42:17,210
dotty however the important thing is

00:42:15,590 --> 00:42:20,780
that this would be like in three years

00:42:17,210 --> 00:42:22,700
when Scala three throws out and so until

00:42:20,780 --> 00:42:27,140
that happens you can use the reader

00:42:22,700 --> 00:42:29,780
monad for the same tool to to implement

00:42:27,140 --> 00:42:32,540
this kind of effects tracking so I agree

00:42:29,780 --> 00:42:34,940
that the implicit functions is syntax is

00:42:32,540 --> 00:42:36,530
nicer and more lightweight and also

00:42:34,940 --> 00:42:39,349
faster because you don't have to create

00:42:36,530 --> 00:42:42,290
the reader wrapper but it's well it's

00:42:39,349 --> 00:42:44,060
not yet available so so for the time

00:42:42,290 --> 00:42:49,849
being we have to live with the reader

00:42:44,060 --> 00:42:52,520
moment okay so yes that's also the main

00:42:49,849 --> 00:42:55,070
point of what I wanted to show you is

00:42:52,520 --> 00:42:57,650
that you can have both constructor based

00:42:55,070 --> 00:43:01,160
dependency injection and use the reader

00:42:57,650 --> 00:43:05,630
monob in fact you can also combine the

00:43:01,160 --> 00:43:09,560
two if I will just jump to an ad to a a

00:43:05,630 --> 00:43:11,720
bit more developed example so here let's

00:43:09,560 --> 00:43:14,450
say that we have modified our example so

00:43:11,720 --> 00:43:18,560
that we have a key value store trait

00:43:14,450 --> 00:43:23,630
right and trim to implementations in

00:43:18,560 --> 00:43:25,730
memory and cloud right and so now when

00:43:23,630 --> 00:43:27,859
we want to track the effect that

00:43:25,730 --> 00:43:30,080
somebody uses a key value store we just

00:43:27,859 --> 00:43:31,970
wants to track the fact that a key value

00:43:30,080 --> 00:43:36,440
store reduced not which implementation

00:43:31,970 --> 00:43:40,339
okay so we can use as before we use the

00:43:36,440 --> 00:43:42,890
reader monad to track the effect of

00:43:40,339 --> 00:43:45,020
using a key value store but not any

00:43:42,890 --> 00:43:49,390
specific implementation just the trait

00:43:45,020 --> 00:43:52,730
right and if we go now scroll down and

00:43:49,390 --> 00:43:54,619
here's our end of the world a

00:43:52,730 --> 00:43:56,480
configuration where we create the object

00:43:54,619 --> 00:43:58,099
graph so when creating the object graph

00:43:56,480 --> 00:44:00,740
we can actually use constructor by

00:43:58,099 --> 00:44:04,550
dependent equation again to create the

00:44:00,740 --> 00:44:06,470
the dependencies like over here right

00:44:04,550 --> 00:44:11,360
which we then pass on to the reader Mona

00:44:06,470 --> 00:44:18,000
so this all like fits fits together

00:44:11,360 --> 00:44:20,210
okay so just to sum up you can use and

00:44:18,000 --> 00:44:22,350
you probably should use constructors and

00:44:20,210 --> 00:44:24,270
constructor base dependency injection or

00:44:22,350 --> 00:44:26,100
constructor parameters however you want

00:44:24,270 --> 00:44:28,710
to call it try them implementation

00:44:26,100 --> 00:44:30,930
details you can use the reader monad to

00:44:28,710 --> 00:44:32,550
make dependencies explicit and strike a

00:44:30,930 --> 00:44:34,140
fax and they are both useful and they

00:44:32,550 --> 00:44:36,120
can work together so what about

00:44:34,140 --> 00:44:39,800
frameworks right and what about

00:44:36,120 --> 00:44:43,080
libraries so frameworks give you a

00:44:39,800 --> 00:44:44,550
short-term profit because when you start

00:44:43,080 --> 00:44:47,490
your project you don't have to worry

00:44:44,550 --> 00:44:50,850
about writing this what wiring this

00:44:47,490 --> 00:44:53,340
object graph but you well and it is

00:44:50,850 --> 00:44:55,140
handy it is like nice to not have to

00:44:53,340 --> 00:44:57,180
write all these new invocations and so

00:44:55,140 --> 00:45:01,200
on however you give up a lot of control

00:44:57,180 --> 00:45:02,580
in exchange right and with the pure

00:45:01,200 --> 00:45:05,130
Scala approach you can create your

00:45:02,580 --> 00:45:07,620
objects as you like in any way betting

00:45:05,130 --> 00:45:10,860
on configuration based on the

00:45:07,620 --> 00:45:12,020
environment using new like well it's

00:45:10,860 --> 00:45:14,610
just code right

00:45:12,020 --> 00:45:18,270
when using a framework you like commit

00:45:14,610 --> 00:45:20,130
to doing it the frameworks way so that's

00:45:18,270 --> 00:45:22,470
why I would always start with a clear

00:45:20,130 --> 00:45:27,210
like with a pure Scala approach and only

00:45:22,470 --> 00:45:29,280
later maybe add and add add a framework

00:45:27,210 --> 00:45:32,550
which can have their benefits right if

00:45:29,280 --> 00:45:35,700
you need a opie if you need interceptors

00:45:32,550 --> 00:45:37,770
if you need like scoping that's when

00:45:35,700 --> 00:45:40,650
frameworks can be useful but that's

00:45:37,770 --> 00:45:43,830
usually only in a later stage of the

00:45:40,650 --> 00:45:46,200
project so some some libraries and

00:45:43,830 --> 00:45:48,380
frameworks to look at well that's my

00:45:46,200 --> 00:45:51,240
choir which is mine and of course best

00:45:48,380 --> 00:45:55,440
that's not a framework it's a library

00:45:51,240 --> 00:45:59,640
which helps you to to create the new

00:45:55,440 --> 00:46:01,590
took to create the object graph and so

00:45:59,640 --> 00:46:04,400
we don't have to enumerate all the

00:46:01,590 --> 00:46:07,950
dependencies it generates the new

00:46:04,400 --> 00:46:10,560
invocation for you that's grafter which

00:46:07,950 --> 00:46:12,720
also combines the reader monad and

00:46:10,560 --> 00:46:14,460
constructor by dependency injection in a

00:46:12,720 --> 00:46:15,570
slightly different way so I encourage

00:46:14,460 --> 00:46:20,190
you to take a look at that

00:46:15,570 --> 00:46:22,880
there's juice which is by default used

00:46:20,190 --> 00:46:25,560
in play however if you are using play

00:46:22,880 --> 00:46:28,520
it's very easy to switch to compile

00:46:25,560 --> 00:46:31,050
dependency injection using constructors

00:46:28,520 --> 00:46:32,880
there's a whole section in the

00:46:31,050 --> 00:46:34,770
documentation on how to do that it

00:46:32,880 --> 00:46:38,220
shouldn't take you more than like 5-10

00:46:34,770 --> 00:46:40,980
minutes to remove jews and and and use

00:46:38,220 --> 00:46:42,780
compile time independent dependency

00:46:40,980 --> 00:46:45,150
injection and there are some service

00:46:42,780 --> 00:46:47,760
locator implementations in scala as well

00:46:45,150 --> 00:46:53,640
for example is called the end and sub

00:46:47,760 --> 00:46:56,100
cup okay so one last slide with a thank

00:46:53,640 --> 00:47:00,350
you for your attention the code for the

00:46:56,100 --> 00:47:05,210
presentation is available on github and

00:47:00,350 --> 00:47:05,210
yeah that's it thank you very much i

00:47:08,780 --> 00:47:14,400
don't think we have made me have time

00:47:11,790 --> 00:47:16,860
for a couple of questions so I haven't

00:47:14,400 --> 00:47:20,550
seen Mac or I've seen graph here before

00:47:16,860 --> 00:47:22,740
does Mac work kind of like use macros to

00:47:20,550 --> 00:47:24,720
generate reader monads or is it more no

00:47:22,740 --> 00:47:29,280
no no so the only thing back where does

00:47:24,720 --> 00:47:31,290
is it generates this piece of code so

00:47:29,280 --> 00:47:32,460
you don't have so if you have like five

00:47:31,290 --> 00:47:34,260
dependencies here you don't have to

00:47:32,460 --> 00:47:35,720
enumerate them it just it's a macro

00:47:34,260 --> 00:47:38,700
which basing on the current environment

00:47:35,720 --> 00:47:40,680
generates this new invocation for you

00:47:38,700 --> 00:47:42,120
and that's useful like when you add

00:47:40,680 --> 00:47:44,700
dependencies more them around you don't

00:47:42,120 --> 00:47:47,010
have to update this wiring code so

00:47:44,700 --> 00:47:48,600
that's all it does how would the reader

00:47:47,010 --> 00:47:52,350
Bernard scale up to having multiple

00:47:48,600 --> 00:47:54,150
effects in a single function call and so

00:47:52,350 --> 00:47:55,830
if you have multiple effects where you

00:47:54,150 --> 00:48:00,630
would create for back case class which

00:47:55,830 --> 00:48:02,190
would combine them all right the tricky

00:48:00,630 --> 00:48:04,290
part is if you have one function which

00:48:02,190 --> 00:48:06,810
has effect a and another function static

00:48:04,290 --> 00:48:10,500
effect B so I have to kind of glue it by

00:48:06,810 --> 00:48:14,010
hand so and that also will be nice so

00:48:10,500 --> 00:48:16,530
with implicit functions because was yeah

00:48:14,010 --> 00:48:18,210
that's why they work okay so I'm here

00:48:16,530 --> 00:48:21,210
until the end of the day if you were to

00:48:18,210 --> 00:48:24,780
want to catch me or you can mail me or

00:48:21,210 --> 00:48:27,220
write on Twitter or however and so thank

00:48:24,780 --> 00:48:29,280
you very much again

00:48:27,220 --> 00:48:29,280

YouTube URL: https://www.youtube.com/watch?v=AkOFubm-9L8


