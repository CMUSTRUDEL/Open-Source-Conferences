Title: Disassembling and Decompiling Scala Code   by Ryan Brown
Publication date: 2017-06-07
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Adoption of enterprise Scala often requires educating Java developers. The runtime implications of many Scala features may not be clearly understood. We investigate Java bytecode produced by the Scala compiler to better understand how Scala creates runnable code. We examine Scala language fundamentals, composition and inheritance, scopes, annotations, and Java interoperability. This is achieved using the javap command to disassemble the .class file to look at its signature, a decompiler, and scalac options. Our goal is to demystify language features and produce better runnable code.
Captions: 
	00:00:01,120 --> 00:00:05,899
so thank you for coming to the talk this

00:00:03,770 --> 00:00:10,130
is about disassembling and decompiling

00:00:05,899 --> 00:00:13,580
scholar code about myself I work for IBM

00:00:10,130 --> 00:00:16,119
in the Watson and cloud analytics

00:00:13,580 --> 00:00:19,220
platform particularly focusing on

00:00:16,119 --> 00:00:21,890
weather based analytics so the data that

00:00:19,220 --> 00:00:25,039
we ingest is all weather based data and

00:00:21,890 --> 00:00:28,519
then we repackage our analytics as a b2b

00:00:25,039 --> 00:00:32,419
product and sometimes a b2c product I've

00:00:28,519 --> 00:00:35,090
been with IBM for about a year a little

00:00:32,419 --> 00:00:38,240
over a year now and prior to that I was

00:00:35,090 --> 00:00:41,360
in the life sciences and when I came to

00:00:38,240 --> 00:00:43,220
IBM it was a little bit it was

00:00:41,360 --> 00:00:46,160
definitely a different industry but it

00:00:43,220 --> 00:00:49,760
was a little bit different culture in

00:00:46,160 --> 00:00:53,300
terms of software development and part

00:00:49,760 --> 00:00:57,410
of that involved having legacy Java

00:00:53,300 --> 00:01:00,620
applications as well as working in an

00:00:57,410 --> 00:01:02,960
agile manner we follow scrum practices

00:01:00,620 --> 00:01:05,600
so we had particular technology

00:01:02,960 --> 00:01:08,749
challenges as well as business

00:01:05,600 --> 00:01:11,689
challenges when it came to introducing

00:01:08,749 --> 00:01:15,890
Scala code so the motivation for this

00:01:11,689 --> 00:01:19,429
talk is primarily how do we turn Java

00:01:15,890 --> 00:01:22,640
developers into Scala developers and how

00:01:19,429 --> 00:01:25,729
do we repackage our Scala applications

00:01:22,640 --> 00:01:28,939
in a team environment so that we can

00:01:25,729 --> 00:01:33,889
have a common set of infrastructure that

00:01:28,939 --> 00:01:37,189
runs multiple types of applications part

00:01:33,889 --> 00:01:40,189
of this means running modern scholar

00:01:37,189 --> 00:01:43,100
applications alongside legacy Java

00:01:40,189 --> 00:01:46,639
applications I think the the oldest java

00:01:43,100 --> 00:01:50,389
application I've seen is developed

00:01:46,639 --> 00:01:52,929
against 1.4 code so it's about a 10 year

00:01:50,389 --> 00:01:57,079
old java application running in Tomcat

00:01:52,929 --> 00:01:59,240
that needs to sit alongside a Scala 212

00:01:57,079 --> 00:02:02,600
application so there shared resources

00:01:59,240 --> 00:02:06,200
shared constraints sometimes we deploy

00:02:02,600 --> 00:02:10,310
these in ec2 so we have an

00:02:06,200 --> 00:02:12,620
infrastructure problem as well so in

00:02:10,310 --> 00:02:14,390
addition to teaching Java developers how

00:02:12,620 --> 00:02:16,100
to be good Scala developers

00:02:14,390 --> 00:02:20,750
we also need to establish like best

00:02:16,100 --> 00:02:23,510
practices how do we style our Scala code

00:02:20,750 --> 00:02:27,730
so that it's effective so that it's

00:02:23,510 --> 00:02:30,740
readable and then how do we do debugging

00:02:27,730 --> 00:02:33,770
so another way to say this is we want to

00:02:30,740 --> 00:02:37,760
turn Scala features and Java features

00:02:33,770 --> 00:02:39,620
into like compatible paradigms and we

00:02:37,760 --> 00:02:42,410
want to look at how the bytecode works

00:02:39,620 --> 00:02:46,209
in order to understand how Scala at

00:02:42,410 --> 00:02:50,150
runtime is Java right this is part of

00:02:46,209 --> 00:02:53,510
the Scala community that sometimes gets

00:02:50,150 --> 00:02:56,239
ignored or a little bit neglected that

00:02:53,510 --> 00:02:58,370
when we compile our Scala code it turns

00:02:56,239 --> 00:03:00,620
into a dot class file gets packaged into

00:02:58,370 --> 00:03:04,430
a jar and therefore at runtime it is

00:03:00,620 --> 00:03:10,250
Java code so how many people here are

00:03:04,430 --> 00:03:12,530
Java developers as well okay good so I'm

00:03:10,250 --> 00:03:16,040
going to talk a lot about Java as well

00:03:12,530 --> 00:03:19,070
so I'm going to stop a couple times and

00:03:16,040 --> 00:03:21,799
we can have questions and QA if you know

00:03:19,070 --> 00:03:23,330
if you guys need then we're going to go

00:03:21,799 --> 00:03:27,200
through just a bunch of examples so

00:03:23,330 --> 00:03:30,110
we'll go through as many as we can in

00:03:27,200 --> 00:03:32,660
order to understand how the Scala

00:03:30,110 --> 00:03:35,000
compiler works we can kind of reverse

00:03:32,660 --> 00:03:37,880
engineer the dot class files that come

00:03:35,000 --> 00:03:41,510
out and we can do that using the Scala P

00:03:37,880 --> 00:03:45,580
which is the Scala profiler the Java

00:03:41,510 --> 00:03:47,690
profiler and any decompiler so I picked

00:03:45,580 --> 00:03:50,570
JDC MD just because it has a nice

00:03:47,690 --> 00:03:52,810
command-line interface there's JD GUI

00:03:50,570 --> 00:03:57,590
which has a little browser you can use

00:03:52,810 --> 00:03:59,090
as well as all the Scala commands so I

00:03:57,590 --> 00:04:01,820
encourage you to read through the

00:03:59,090 --> 00:04:03,980
documentation about Scala and the

00:04:01,820 --> 00:04:06,280
different options for print and that

00:04:03,980 --> 00:04:10,220
will go through the entire list of

00:04:06,280 --> 00:04:13,060
compiler options so let's start with

00:04:10,220 --> 00:04:15,440
hello world right the simplest example

00:04:13,060 --> 00:04:18,079
in the first box is just source code

00:04:15,440 --> 00:04:19,690
right so I have object main and it's a

00:04:18,079 --> 00:04:23,750
print line statement right hello world

00:04:19,690 --> 00:04:25,410
when I look at the Scala P output it's

00:04:23,750 --> 00:04:27,810
exactly what I would expect

00:04:25,410 --> 00:04:31,590
I have object main it extends any rest

00:04:27,810 --> 00:04:34,170
there's the constructor for it and then

00:04:31,590 --> 00:04:36,930
the main the main method when I use the

00:04:34,170 --> 00:04:39,990
Java profiler it's also exactly what I

00:04:36,930 --> 00:04:43,160
would expect and now I can see oh okay

00:04:39,990 --> 00:04:45,210
the Scala profiler and the Java profiler

00:04:43,160 --> 00:04:47,070
how they work

00:04:45,210 --> 00:04:49,590
to decompile not decompile how to

00:04:47,070 --> 00:04:56,160
deconstruct that dot class file in terms

00:04:49,590 --> 00:05:00,470
of method signatures the next more

00:04:56,160 --> 00:05:03,330
complex example would be a beam right so

00:05:00,470 --> 00:05:08,400
if I need to make my Scala code

00:05:03,330 --> 00:05:11,100
compatible with jsr 303 and 349 you

00:05:08,400 --> 00:05:15,200
would commonly see the at beam property

00:05:11,100 --> 00:05:18,000
annotation put onto constructor

00:05:15,200 --> 00:05:20,010
parameters and in this case I have

00:05:18,000 --> 00:05:23,340
specified them as VARs in order to

00:05:20,010 --> 00:05:25,470
actually be being compliant so that I

00:05:23,340 --> 00:05:28,680
would get getters and setters named

00:05:25,470 --> 00:05:34,470
appropriately but you'll see it's not

00:05:28,680 --> 00:05:36,680
actually technically a POJO and that

00:05:34,470 --> 00:05:39,240
comes from the Scala compiler

00:05:36,680 --> 00:05:41,340
understanding that I've put the at beam

00:05:39,240 --> 00:05:45,320
property and so yes it does insert the

00:05:41,340 --> 00:05:52,020
get age and set age methods but it also

00:05:45,320 --> 00:05:53,910
retains the Scala age and the age getter

00:05:52,020 --> 00:05:56,130
and age setter so you'll notice there

00:05:53,910 --> 00:06:00,150
are two different setters for age and

00:05:56,130 --> 00:06:05,280
name as well so technically it's not jsr

00:06:00,150 --> 00:06:08,520
303 compatible but because it does

00:06:05,280 --> 00:06:16,740
adhere to like the basic beam spec you

00:06:08,520 --> 00:06:18,780
can run this like in tomcat or jetty so

00:06:16,740 --> 00:06:22,260
another scholar feature that I really

00:06:18,780 --> 00:06:25,890
like arc is case classes and if I take

00:06:22,260 --> 00:06:29,340
off the at beam property and I say well

00:06:25,890 --> 00:06:30,930
you know this is my beam person I really

00:06:29,340 --> 00:06:33,060
want different types of people I'm going

00:06:30,930 --> 00:06:36,300
to have users I'm going to have maybe

00:06:33,060 --> 00:06:37,860
students I'm going to have Scala days

00:06:36,300 --> 00:06:38,610
attendee I'm going to have different

00:06:37,860 --> 00:06:41,520
types of people

00:06:38,610 --> 00:06:46,889
that I want to be able to pattern match

00:06:41,520 --> 00:06:49,830
on okay I take off the a beam property I

00:06:46,889 --> 00:06:53,039
put on a case and then I can do I'll do

00:06:49,830 --> 00:06:55,409
my pattern matching well what what is

00:06:53,039 --> 00:06:56,340
all this other code that gets put out by

00:06:55,409 --> 00:06:59,550
the compiler

00:06:56,340 --> 00:07:03,719
I have product era TI product element

00:06:59,550 --> 00:07:08,580
I'm overriding product iterator there's

00:07:03,719 --> 00:07:12,509
all this extra code that I get just by

00:07:08,580 --> 00:07:15,560
having a case class and it's not just in

00:07:12,509 --> 00:07:18,960
one class it makes a companion object

00:07:15,560 --> 00:07:21,360
for overriding to string for having for

00:07:18,960 --> 00:07:25,139
making it functional with apply so I get

00:07:21,360 --> 00:07:28,139
all this extra stuff and that does

00:07:25,139 --> 00:07:30,360
enable pattern matching and some of

00:07:28,139 --> 00:07:33,900
these other features that Scala offers

00:07:30,360 --> 00:07:37,169
but there is an inherent downside which

00:07:33,900 --> 00:07:41,219
is that I'm potentially polluting my

00:07:37,169 --> 00:07:44,370
permian memory at runtime so does

00:07:41,219 --> 00:07:51,089
everybody know what perm gen is that

00:07:44,370 --> 00:07:54,589
anyone so from gen memory is a basically

00:07:51,089 --> 00:07:57,659
namespace allocated memory at runtime

00:07:54,589 --> 00:08:01,500
used by jetty or Tomcat or anything that

00:07:57,659 --> 00:08:06,479
needs to retain references to methods so

00:08:01,500 --> 00:08:09,569
by doing this yes it's nice for me as a

00:08:06,479 --> 00:08:12,870
developer to have really clean case

00:08:09,569 --> 00:08:15,300
classes and then be able to filter on

00:08:12,870 --> 00:08:18,029
them or map my case classes accordingly

00:08:15,300 --> 00:08:20,569
but I could potentially have a runtime

00:08:18,029 --> 00:08:20,569
problem

00:08:24,030 --> 00:08:28,410
so one of the other things that I love

00:08:26,280 --> 00:08:33,990
about Scala is that I can have default

00:08:28,410 --> 00:08:35,729
parameters so if this is an actual

00:08:33,990 --> 00:08:40,110
example from an application time aid

00:08:35,729 --> 00:08:42,690
worker PLI config it has a to date and

00:08:40,110 --> 00:08:47,760
from dates and then I want to lazy load

00:08:42,690 --> 00:08:51,030
those into an offset date time when I

00:08:47,760 --> 00:08:54,210
use the Scala profiler it does a pretty

00:08:51,030 --> 00:08:58,800
good job ok I it's exactly what I would

00:08:54,210 --> 00:09:01,050
expect I have my valve but how how do I

00:08:58,800 --> 00:09:04,020
do this in Java what's actually going to

00:09:01,050 --> 00:09:06,690
get run because Java does not have

00:09:04,020 --> 00:09:08,280
default values so this this is the first

00:09:06,690 --> 00:09:11,130
and simplest example I could think of

00:09:08,280 --> 00:09:16,230
where there's a scholar feature that

00:09:11,130 --> 00:09:19,590
doesn't naturally map over to Java so if

00:09:16,230 --> 00:09:23,490
I use the Java profiler on this what

00:09:19,590 --> 00:09:26,220
would I expect to get ok so some of it

00:09:23,490 --> 00:09:29,820
is is pretty straightforward I have a

00:09:26,220 --> 00:09:32,280
from and a to and a UUID method just for

00:09:29,820 --> 00:09:36,540
my input parameters but in red here I

00:09:32,280 --> 00:09:40,010
have public static and then a bunch of

00:09:36,540 --> 00:09:42,960
strings with this is just the output of

00:09:40,010 --> 00:09:47,730
the profiler less integrator

00:09:42,960 --> 00:09:51,030
but I have defaults 1 2 3 4 5 and the

00:09:47,730 --> 00:09:54,720
types match accordingly over to the

00:09:51,030 --> 00:09:58,620
Scala types for what's coming into the

00:09:54,720 --> 00:10:03,390
constructor there so that's interesting

00:09:58,620 --> 00:10:06,890
that's how the compiler handles default

00:10:03,390 --> 00:10:10,800
arguments it sets it as a public static

00:10:06,890 --> 00:10:16,200
notice it's not final so technically

00:10:10,800 --> 00:10:19,500
it's over aidable but I've found that to

00:10:16,200 --> 00:10:20,910
be an interesting example we'll come

00:10:19,500 --> 00:10:23,339
back to this in a little bit to talk

00:10:20,910 --> 00:10:29,070
about the lazy aspect of that

00:10:23,339 --> 00:10:30,960
how does lazy work so I guess the big

00:10:29,070 --> 00:10:34,230
lessons for just using the profiler

00:10:30,960 --> 00:10:37,790
would be that Scala code and Java code

00:10:34,230 --> 00:10:37,790
can be considerably different

00:10:38,170 --> 00:10:43,519
sometimes it can be jsr compliant

00:10:40,879 --> 00:10:46,610
sometimes not and it takes kind of a

00:10:43,519 --> 00:10:49,699
careful consideration for what kind of

00:10:46,610 --> 00:10:53,120
code you're writing are you going to be

00:10:49,699 --> 00:10:54,529
dropping this into a web server are you

00:10:53,120 --> 00:10:55,579
going to be running this as a standalone

00:10:54,529 --> 00:10:59,300
application

00:10:55,579 --> 00:11:02,120
so I guess my like lessons learned would

00:10:59,300 --> 00:11:05,029
be that you need to consider the runtime

00:11:02,120 --> 00:11:08,660
consequence of the code you're writing

00:11:05,029 --> 00:11:12,800
and not necessarily write Scala code for

00:11:08,660 --> 00:11:15,399
you the developer sometimes I want to

00:11:12,800 --> 00:11:18,949
mix and match my Java and Scala code

00:11:15,399 --> 00:11:23,449
which can be great at times but it can

00:11:18,949 --> 00:11:26,079
be terrible at times and knowing how

00:11:23,449 --> 00:11:29,860
each of the respective compilers makes

00:11:26,079 --> 00:11:33,170
compliant bytecode is kind of important

00:11:29,860 --> 00:11:36,740
a good example would be like enums and

00:11:33,170 --> 00:11:41,029
enum and Java is a lot different than an

00:11:36,740 --> 00:11:44,089
enum in Scala and sometimes I want a

00:11:41,029 --> 00:11:47,750
Java enum say I'm using like an ORM and

00:11:44,089 --> 00:11:49,850
I want to have an easy mapping I have

00:11:47,750 --> 00:11:52,879
legacy hibernate or something so I'm

00:11:49,850 --> 00:11:57,290
going to inherit this Java enum that's

00:11:52,879 --> 00:11:59,420
fine maybe that is what I want maybe I

00:11:57,290 --> 00:12:02,540
want to port that over to a Scala enum

00:11:59,420 --> 00:12:04,699
for different reasons so understanding

00:12:02,540 --> 00:12:06,529
the difference between not just language

00:12:04,699 --> 00:12:07,970
features but the compiler and then the

00:12:06,529 --> 00:12:11,089
runtime consequence I think is very

00:12:07,970 --> 00:12:15,439
important as well as making good

00:12:11,089 --> 00:12:16,819
readable shareable code are there any

00:12:15,439 --> 00:12:18,470
questions so far

00:12:16,819 --> 00:12:22,149
I think I said a lot of buzzwords like

00:12:18,470 --> 00:12:26,149
Java stuff any questions so far

00:12:22,149 --> 00:12:30,189
okay well the profiler is great but that

00:12:26,149 --> 00:12:32,809
only tells me the methods the public

00:12:30,189 --> 00:12:36,499
variables it doesn't actually show me

00:12:32,809 --> 00:12:40,699
what's in the code so let's go through a

00:12:36,499 --> 00:12:42,319
few examples about the D compiler and

00:12:40,699 --> 00:12:44,559
then we can actually see what's going on

00:12:42,319 --> 00:12:47,200
under the hood

00:12:44,559 --> 00:12:52,780
let's go back to my

00:12:47,200 --> 00:12:56,310
in person when I run the decompiler I I

00:12:52,780 --> 00:12:58,420
get this massive at Scala signature

00:12:56,310 --> 00:13:01,300
annotation on the top of that what like

00:12:58,420 --> 00:13:02,020
what is that so when I started

00:13:01,300 --> 00:13:03,700
decompiling

00:13:02,020 --> 00:13:05,380
Scala code this was the first thing that

00:13:03,700 --> 00:13:07,270
jumped at me I don't normally see this

00:13:05,380 --> 00:13:11,830
in Java code what what is going on here

00:13:07,270 --> 00:13:14,970
and the Scala compiler puts on this

00:13:11,830 --> 00:13:17,460
annotation which is a byte array

00:13:14,970 --> 00:13:21,160
representation of the class itself and

00:13:17,460 --> 00:13:25,180
it's a very slick way to do things like

00:13:21,160 --> 00:13:27,370
scholar reflection it's kind of 15 I

00:13:25,180 --> 00:13:29,740
think the statistic I read was 15 times

00:13:27,370 --> 00:13:32,500
more performant than actually scanning

00:13:29,740 --> 00:13:38,290
the class itself and because you can

00:13:32,500 --> 00:13:39,790
just stream a byte stream at runtime you

00:13:38,290 --> 00:13:42,190
don't have to do it like multiple times

00:13:39,790 --> 00:13:44,680
you can cache it you can do all sorts of

00:13:42,190 --> 00:13:46,930
cool stuff that I believe tools like

00:13:44,680 --> 00:13:51,910
spark do when they're serializing

00:13:46,930 --> 00:13:53,920
classes back and forth so the rest of

00:13:51,910 --> 00:13:57,360
the examples I basically just chop this

00:13:53,920 --> 00:14:05,560
off for this real estate sake

00:13:57,360 --> 00:14:09,250
how do companions work well as we can

00:14:05,560 --> 00:14:11,080
see the constant is represented in a

00:14:09,250 --> 00:14:14,350
companion class which gets annotated

00:14:11,080 --> 00:14:17,800
with the dollar sign symbol so all of

00:14:14,350 --> 00:14:20,800
the actual logic of this valve constant

00:14:17,800 --> 00:14:23,440
is represented in a secondary class that

00:14:20,800 --> 00:14:25,570
gets generated with the same name but

00:14:23,440 --> 00:14:30,730
then you get this dollar sign suffix

00:14:25,570 --> 00:14:34,390
attached to it in the class file called

00:14:30,730 --> 00:14:36,430
class with companion we basically just

00:14:34,390 --> 00:14:38,710
have our method signatures and that's it

00:14:36,430 --> 00:14:41,830
all the actual construction logic all

00:14:38,710 --> 00:14:47,740
the values are in the secondary class

00:14:41,830 --> 00:14:49,540
that gets generated so

00:14:47,740 --> 00:14:54,700
this is my favorite example of the whole

00:14:49,540 --> 00:14:57,580
presentation on the left upper left box

00:14:54,700 --> 00:15:00,760
is Scala code where I have a trait of

00:14:57,580 --> 00:15:02,560
type T NR and I'm going to have just a

00:15:00,760 --> 00:15:06,000
simple function say convert that

00:15:02,560 --> 00:15:09,430
consumes a T produces an R and then my

00:15:06,000 --> 00:15:12,610
simple little class is even consumes an

00:15:09,430 --> 00:15:15,640
INT produce a boolean if mod 2 equals 0

00:15:12,610 --> 00:15:18,040
that's true in Java I can add the exact

00:15:15,640 --> 00:15:22,840
same code I have an interface instead of

00:15:18,040 --> 00:15:25,750
a trait with one method converts and I

00:15:22,840 --> 00:15:31,120
have the same logic implemented in a

00:15:25,750 --> 00:15:32,980
simple little class but when I decompile

00:15:31,120 --> 00:15:37,150
the dot class file that gets put out

00:15:32,980 --> 00:15:39,340
it's considerably different so in the

00:15:37,150 --> 00:15:41,940
bottom left is the output of the Scala

00:15:39,340 --> 00:15:45,490
code the bottom right is the Java code

00:15:41,940 --> 00:15:47,910
but you'll notice the types of the

00:15:45,490 --> 00:15:51,700
implemented converter are different

00:15:47,910 --> 00:15:55,660
Scala generates object object and Java

00:15:51,700 --> 00:15:56,700
retains integer and boolean well that's

00:15:55,660 --> 00:16:00,430
very interesting

00:15:56,700 --> 00:16:04,870
so Scala actually had just decided to

00:16:00,430 --> 00:16:07,330
ignore my type which I did not expect

00:16:04,870 --> 00:16:10,030
but there is actually a good reason for

00:16:07,330 --> 00:16:15,010
this which is if you look at the input

00:16:10,030 --> 00:16:19,030
of convert it's a primitive int versus

00:16:15,010 --> 00:16:22,720
Java it's a capital integer now this is

00:16:19,030 --> 00:16:26,500
kind of expected because in int and

00:16:22,720 --> 00:16:30,400
Scala is close is actually a primitive

00:16:26,500 --> 00:16:33,250
in Java so that is somewhat expected and

00:16:30,400 --> 00:16:36,790
also in Java I can't have an interface

00:16:33,250 --> 00:16:41,230
of type int it has to be a capital

00:16:36,790 --> 00:16:44,460
object representation integer so that is

00:16:41,230 --> 00:16:47,380
somewhat expected but it means although

00:16:44,460 --> 00:16:49,540
semantically encode these are the same

00:16:47,380 --> 00:16:52,000
thing the actual runtime is going to be

00:16:49,540 --> 00:16:55,450
different and there's an inherent

00:16:52,000 --> 00:16:58,390
trade-off in this because if then I'm

00:16:55,450 --> 00:17:00,730
coding against a primitive int like in

00:16:58,390 --> 00:17:01,529
Scala I'm going to get a compile time

00:17:00,730 --> 00:17:06,150
error if

00:17:01,529 --> 00:17:07,620
try to pass him no but in Java that

00:17:06,150 --> 00:17:11,640
would pass just fine because it's an

00:17:07,620 --> 00:17:16,770
object so then I would hit a runtime

00:17:11,640 --> 00:17:18,780
exception when I do my input into so

00:17:16,770 --> 00:17:21,360
even though semantically this would be

00:17:18,780 --> 00:17:23,970
the same I as a developer should be

00:17:21,360 --> 00:17:25,799
aware that I'm making a trade-off - I

00:17:23,970 --> 00:17:30,090
want runtime exceptions or compiled time

00:17:25,799 --> 00:17:32,220
exceptions and for me usually I want

00:17:30,090 --> 00:17:35,789
compile time exceptions catch all those

00:17:32,220 --> 00:17:38,159
things upfront especially given that I

00:17:35,789 --> 00:17:42,120
may have implemented I may have written

00:17:38,159 --> 00:17:44,700
the converter interface but someone else

00:17:42,120 --> 00:17:49,289
is going to be implementing the is even

00:17:44,700 --> 00:17:50,789
function that I may be calling I may not

00:17:49,289 --> 00:17:53,669
know what's on the other side of that

00:17:50,789 --> 00:17:55,830
function call so I'll get a runtime

00:17:53,669 --> 00:17:58,409
exception I won't know why it happened

00:17:55,830 --> 00:18:03,210
so I prefer just catching everything at

00:17:58,409 --> 00:18:09,260
compile time so let's go back to that

00:18:03,210 --> 00:18:12,510
workers Feli config there were some lazy

00:18:09,260 --> 00:18:16,679
values in there how does lazy actually

00:18:12,510 --> 00:18:19,890
work which is one of the best features

00:18:16,679 --> 00:18:23,640
that enables a lot of really cool Scala

00:18:19,890 --> 00:18:26,309
frameworks to to function as they do if

00:18:23,640 --> 00:18:30,240
you decompile anything that has lazy in

00:18:26,309 --> 00:18:34,820
it you will find that there are three

00:18:30,240 --> 00:18:41,070
things generated one is a volatile bite

00:18:34,820 --> 00:18:43,470
that's basically just a boolean you'll

00:18:41,070 --> 00:18:46,049
also see that there's a in this case

00:18:43,470 --> 00:18:51,539
it's from because I had a lazy value

00:18:46,049 --> 00:18:54,000
called from and it's a daytime so that's

00:18:51,539 --> 00:18:57,210
my getter but then I also have a private

00:18:54,000 --> 00:19:01,409
function called from the lazy compute

00:18:57,210 --> 00:19:04,850
and in this generated function is where

00:19:01,409 --> 00:19:11,250
all of the lazy initialization happens

00:19:04,850 --> 00:19:13,950
so in the public getter first we have a

00:19:11,250 --> 00:19:15,420
ternary expression where it does a

00:19:13,950 --> 00:19:19,290
logical check

00:19:15,420 --> 00:19:24,540
for is that byte filled instantiate it

00:19:19,290 --> 00:19:26,640
or not if it is not then execute the

00:19:24,540 --> 00:19:28,350
lazy compute function so we jumped into

00:19:26,640 --> 00:19:30,810
that and then we hit a synchronized

00:19:28,350 --> 00:19:34,260
block so we're locking on this object

00:19:30,810 --> 00:19:36,180
and this is important because it is

00:19:34,260 --> 00:19:38,550
possible that multiple threads are

00:19:36,180 --> 00:19:40,350
trying to execute this piece of code and

00:19:38,550 --> 00:19:43,230
you don't you want to ensure that only

00:19:40,350 --> 00:19:46,020
one instance ever gets created so

00:19:43,230 --> 00:19:48,840
instead of implementing only a singleton

00:19:46,020 --> 00:19:51,420
check it does a double locking mechanism

00:19:48,840 --> 00:19:54,210
on the object so once the lock has been

00:19:51,420 --> 00:19:57,990
achieved you're in the synchronized

00:19:54,210 --> 00:20:00,540
block but then it does a another check

00:19:57,990 --> 00:20:04,740
against that volatile variable why would

00:20:00,540 --> 00:20:06,660
it do this it's because theoretically

00:20:04,740 --> 00:20:09,600
you could have multiple threads trying

00:20:06,660 --> 00:20:13,170
to instantiate this one has hit the lock

00:20:09,600 --> 00:20:16,740
but is not released it yet so you

00:20:13,170 --> 00:20:20,610
actually do get two threads competing

00:20:16,740 --> 00:20:22,470
for that volatile variable so you need

00:20:20,610 --> 00:20:24,930
to do a double check to make sure that

00:20:22,470 --> 00:20:30,380
two threads cannot instantiate the same

00:20:24,930 --> 00:20:34,440
object twice so this is a thread safe

00:20:30,380 --> 00:20:37,770
example of what the compiler can do for

00:20:34,440 --> 00:20:40,140
you so just by having something be lazy

00:20:37,770 --> 00:20:41,730
loaded you're automatically guaranteed

00:20:40,140 --> 00:20:48,990
that's thread safe I found that to be

00:20:41,730 --> 00:20:52,470
really cool yes so you want to check it

00:20:48,990 --> 00:20:55,400
first in order to know which should I

00:20:52,470 --> 00:21:05,900
just return it or should I lazy load it

00:20:55,400 --> 00:21:05,900
then that is a typo yep

00:21:11,120 --> 00:21:18,510
so tail recursion is probably the most

00:21:16,400 --> 00:21:21,720
advanced scholar feature that we'll talk

00:21:18,510 --> 00:21:26,280
about here so this is just an example of

00:21:21,720 --> 00:21:28,530
a simple tail recursion function that

00:21:26,280 --> 00:21:32,970
computes the sum of a bunch of numbers

00:21:28,530 --> 00:21:37,050
and when you decompile it you get very

00:21:32,970 --> 00:21:39,930
complex code here but the main point is

00:21:37,050 --> 00:21:43,770
that it's an infinite for loop with

00:21:39,930 --> 00:21:47,550
bright conditions so what does that tail

00:21:43,770 --> 00:21:50,550
recursion do like by why do I annotate

00:21:47,550 --> 00:21:53,610
my inner function here with that tail

00:21:50,550 --> 00:21:56,910
recursion it's basically a flag to the

00:21:53,610 --> 00:21:58,740
compiler to try to optimize that I don't

00:21:56,910 --> 00:22:04,050
actually have to use that tail recursion

00:21:58,740 --> 00:22:07,590
the compiler will produce a a reasonable

00:22:04,050 --> 00:22:12,240
piece of code unless I actually write

00:22:07,590 --> 00:22:15,020
bad code it can't always turn something

00:22:12,240 --> 00:22:19,700
that is seemingly recursive into

00:22:15,020 --> 00:22:23,160
runnable code so this is an example

00:22:19,700 --> 00:22:24,180
where I have annotated with that tail

00:22:23,160 --> 00:22:27,200
recursion so it's going to try to

00:22:24,180 --> 00:22:29,940
optimize it but because it's not

00:22:27,200 --> 00:22:31,760
effectively tail recursive I'm just

00:22:29,940 --> 00:22:34,500
calling the same thing multiple times

00:22:31,760 --> 00:22:36,410
the compiler is going to throw an

00:22:34,500 --> 00:22:40,640
exception say I can't do that

00:22:36,410 --> 00:22:43,830
so there are three different cases for

00:22:40,640 --> 00:22:46,410
recursive function calls one would be

00:22:43,830 --> 00:22:50,340
something that can be optimized one is

00:22:46,410 --> 00:22:52,410
something that is not compile able and

00:22:50,340 --> 00:22:55,370
the third is the classic example of

00:22:52,410 --> 00:22:55,370
you're going to get a stack overflow

00:23:01,930 --> 00:23:08,390
so the lessons I have from doing D

00:23:06,590 --> 00:23:11,090
compilation on that dot class files

00:23:08,390 --> 00:23:11,690
would be that that lazy eval is

00:23:11,090 --> 00:23:14,390
thread-safe

00:23:11,690 --> 00:23:18,890
it's a great feature and you should use

00:23:14,390 --> 00:23:21,380
it all the time I would say that knowing

00:23:18,890 --> 00:23:23,830
that run time versus compiled time

00:23:21,380 --> 00:23:26,360
exceptions are very important and

00:23:23,830 --> 00:23:30,340
personally I would advocate for compiled

00:23:26,360 --> 00:23:33,800
time checks more than runtime checks

00:23:30,340 --> 00:23:36,920
conversely I love Python as well so you

00:23:33,800 --> 00:23:39,470
know what do I know but I would also say

00:23:36,920 --> 00:23:41,840
pay attention to all the different

00:23:39,470 --> 00:23:45,970
output files so when you do companion

00:23:41,840 --> 00:23:48,590
objects when you do nested multiple

00:23:45,970 --> 00:23:50,810
multiple classes in the same file you're

00:23:48,590 --> 00:23:53,870
going to generate a lot of namespace and

00:23:50,810 --> 00:23:58,430
so knowing how that gets executed

00:23:53,870 --> 00:24:01,010
runtime is an important consideration so

00:23:58,430 --> 00:24:07,640
what does the compiler do in order to

00:24:01,010 --> 00:24:09,560
generate any of this code well here

00:24:07,640 --> 00:24:14,480
here's all the different phases that it

00:24:09,560 --> 00:24:19,760
goes through and I would say using the

00:24:14,480 --> 00:24:22,400
Scala dash X print function or command

00:24:19,760 --> 00:24:25,070
you can execute any one of these and it

00:24:22,400 --> 00:24:26,630
will give you very awesome output in

00:24:25,070 --> 00:24:30,920
terms of what the compiler is actually

00:24:26,630 --> 00:24:34,430
doing so it starts just by scanning the

00:24:30,920 --> 00:24:37,430
classes I'm also assuming here that any

00:24:34,430 --> 00:24:39,170
Java code has been compiled first it

00:24:37,430 --> 00:24:43,340
gets a little more complicated if you're

00:24:39,170 --> 00:24:49,310
trying to do mix compilation or Scala

00:24:43,340 --> 00:24:51,830
compilation in Java compilation but the

00:24:49,310 --> 00:24:54,770
ones that I pay attention to would be

00:24:51,830 --> 00:24:58,730
the initialization phase I look at the

00:24:54,770 --> 00:25:01,910
analyze phase the onion the lambda list

00:24:58,730 --> 00:25:05,090
the output is very verbose so unless

00:25:01,910 --> 00:25:07,400
you're a super awesome Scala developer I

00:25:05,090 --> 00:25:10,610
would kind of skip those but then look

00:25:07,400 --> 00:25:12,830
at the types values options because

00:25:10,610 --> 00:25:20,269
that's doing all the conversion

00:25:12,830 --> 00:25:22,190
Scala code into Java type so future

00:25:20,269 --> 00:25:23,210
examples that I would say I encourage

00:25:22,190 --> 00:25:26,510
you to go home and try for yourself

00:25:23,210 --> 00:25:29,510
would be traits with methods classes

00:25:26,510 --> 00:25:32,539
extending multiple treats and of course

00:25:29,510 --> 00:25:35,240
implicit and as Martin talked about in

00:25:32,539 --> 00:25:39,320
his keynote implicit SAR probably the

00:25:35,240 --> 00:25:43,100
defining feature of Scala but they are

00:25:39,320 --> 00:25:46,909
very deep and very cool and outside the

00:25:43,100 --> 00:25:49,909
scope of today as well as annotations

00:25:46,909 --> 00:25:52,880
because annotations can be retained at

00:25:49,909 --> 00:25:55,100
runtime they can be ignored so playing

00:25:52,880 --> 00:25:57,649
with those is also also worth doing and

00:25:55,100 --> 00:25:59,659
the one thing that I did not test that I

00:25:57,649 --> 00:26:03,649
probably should have would be using

00:25:59,659 --> 00:26:06,340
multiple Java and Scala compilers so I

00:26:03,649 --> 00:26:11,720
was using Java one eight for this and

00:26:06,340 --> 00:26:14,419
Scala two eleven it probably is a

00:26:11,720 --> 00:26:17,779
worthwhile exercise to try to target say

00:26:14,419 --> 00:26:21,350
Java 1.5 runtime and then D compile that

00:26:17,779 --> 00:26:24,980
and see what happens or if if you're

00:26:21,350 --> 00:26:28,399
brave go back to like 1.3 1.4 before

00:26:24,980 --> 00:26:32,600
generics existed before auto boxing

00:26:28,399 --> 00:26:34,130
existed and see what happens so the

00:26:32,600 --> 00:26:35,690
question really is how do I build a good

00:26:34,130 --> 00:26:39,470
application out of this that's the whole

00:26:35,690 --> 00:26:41,240
motivation for us talk at IBM we have

00:26:39,470 --> 00:26:43,279
legacy infrastructure we have new

00:26:41,240 --> 00:26:45,409
infrastructure and how do we try to

00:26:43,279 --> 00:26:47,539
marry them together so some of the

00:26:45,409 --> 00:26:50,870
things we have would be three Cassandra

00:26:47,539 --> 00:26:53,090
we have spring applications sometimes we

00:26:50,870 --> 00:26:58,549
deploy them into Tomcat sometimes we're

00:26:53,090 --> 00:27:00,649
running spark applications so my my goal

00:26:58,549 --> 00:27:03,649
would be to try to marry as many of

00:27:00,649 --> 00:27:06,740
these technologies as possible but in a

00:27:03,649 --> 00:27:08,990
reasonable way so the code that I write

00:27:06,740 --> 00:27:11,960
and that my team lights tries to be very

00:27:08,990 --> 00:27:15,260
flexible and extensible as well as

00:27:11,960 --> 00:27:17,990
encapsulate any specific logic or any

00:27:15,260 --> 00:27:20,690
specific syntax so that our API is are

00:27:17,990 --> 00:27:22,340
very straightforward but internally we

00:27:20,690 --> 00:27:24,169
can have all the cool functional

00:27:22,340 --> 00:27:26,309
programming that we want but to the

00:27:24,169 --> 00:27:29,340
outside Java developer

00:27:26,309 --> 00:27:36,419
it'll appear just like normal Java ish

00:27:29,340 --> 00:27:37,559
Scala code there any questions so here

00:27:36,419 --> 00:27:39,960
here my references

00:27:37,559 --> 00:27:42,900
I borrowed a lot of this from the

00:27:39,960 --> 00:27:47,429
Alexander book and website as well as a

00:27:42,900 --> 00:27:49,400
couple of online discussions and that's

00:27:47,429 --> 00:27:57,200
it

00:27:49,400 --> 00:28:01,049
[Applause]

00:27:57,200 --> 00:28:04,500
any questions overall yes I know this is

00:28:01,049 --> 00:28:06,240
the types and the converter example

00:28:04,500 --> 00:28:09,299
we're sort of erasing that a generative

00:28:06,240 --> 00:28:11,490
interface of object objects um when that

00:28:09,299 --> 00:28:13,320
file is loaded the libraries into some

00:28:11,490 --> 00:28:15,870
other project for compilations skeletal

00:28:13,320 --> 00:28:18,990
type checks on it so this do that with

00:28:15,870 --> 00:28:20,400
the annotation the bikes free yes it

00:28:18,990 --> 00:28:24,360
does it with the bikes strength that's

00:28:20,400 --> 00:28:27,539
where the information is retained a lot

00:28:24,360 --> 00:28:30,770
of the runtime of class files of

00:28:27,539 --> 00:28:35,159
effectively Java code ignores types

00:28:30,770 --> 00:28:37,140
altogether so you can do a lot of things

00:28:35,159 --> 00:28:39,179
with reflection that kind of cheat the

00:28:37,140 --> 00:28:41,789
typing system so it's nice that that

00:28:39,179 --> 00:28:43,860
byte stream retains that would anything

00:28:41,789 --> 00:28:47,880
have changed if the Java class had have

00:28:43,860 --> 00:28:52,200
extended the Scala trace instead of the

00:28:47,880 --> 00:28:52,980
Java interface um I don't I don't know I

00:28:52,200 --> 00:28:59,610
don't think so

00:28:52,980 --> 00:29:01,950
and what you have any advice for mixed

00:28:59,610 --> 00:29:03,990
code bases in general as like kind of

00:29:01,950 --> 00:29:06,390
best practices to follow if you're

00:29:03,990 --> 00:29:08,070
mixing a lot of Java and Scala yep so so

00:29:06,390 --> 00:29:13,110
I mix a lot of my Java and Scala

00:29:08,070 --> 00:29:14,880
together but it tends to be more Java

00:29:13,110 --> 00:29:17,850
code getting imported into the Scala

00:29:14,880 --> 00:29:19,909
code base I have found it to be a little

00:29:17,850 --> 00:29:22,620
bit dangerous to go the other route

00:29:19,909 --> 00:29:27,690
primarily because of packages and

00:29:22,620 --> 00:29:30,539
namespaces that being said you can

00:29:27,690 --> 00:29:32,429
definitely do it but my personal advice

00:29:30,539 --> 00:29:34,559
would be to use all the Java features

00:29:32,429 --> 00:29:37,340
that you want in your Scala code and not

00:29:34,559 --> 00:29:37,340
the other way around

00:29:37,999 --> 00:29:40,999
yeah

00:29:42,090 --> 00:29:46,799
does the erasure of the types in a

00:29:44,580 --> 00:29:49,080
generative interface for the trait imply

00:29:46,799 --> 00:29:50,669
that Java code which calls Scala code

00:29:49,080 --> 00:29:53,639
can't take advantage of that typing

00:29:50,669 --> 00:29:56,159
information it can take advantage of

00:29:53,639 --> 00:30:00,629
that depending on how you've structured

00:29:56,159 --> 00:30:04,529
your code but the type information can

00:30:00,629 --> 00:30:06,239
be retained depending on which which

00:30:04,529 --> 00:30:08,369
compiler you're using and how you kind

00:30:06,239 --> 00:30:11,639
of structured it but you can't you can

00:30:08,369 --> 00:30:13,080
take advantage of that notice the me

00:30:11,639 --> 00:30:16,049
tree is not here he would probably say

00:30:13,080 --> 00:30:18,659
about the lazy vowels so because they

00:30:16,049 --> 00:30:19,919
like if you have several and the first

00:30:18,659 --> 00:30:21,239
one like takes five minutes to

00:30:19,919 --> 00:30:23,399
initialize in the second one it takes

00:30:21,239 --> 00:30:25,619
like two seconds and the lock on the

00:30:23,399 --> 00:30:27,389
same mutex if you touch the first one

00:30:25,619 --> 00:30:29,249
the second one is going to wait for five

00:30:27,389 --> 00:30:31,320
minutes until the first one so in dot e

00:30:29,249 --> 00:30:35,249
they removed it and like if you want it

00:30:31,320 --> 00:30:37,169
to be thread size you have to tell it to

00:30:35,249 --> 00:30:40,889
this thread safe so by default it's not

00:30:37,169 --> 00:30:43,799
yeah which is goodness well it's thread

00:30:40,889 --> 00:30:47,009
safe on obtaining that particular lock

00:30:43,799 --> 00:30:48,960
right over all obtained initializing all

00:30:47,009 --> 00:30:52,919
the values it is not thread safe that's

00:30:48,960 --> 00:30:55,470
true um so in the example you showed

00:30:52,919 --> 00:30:57,629
with the default values and you

00:30:55,470 --> 00:31:02,340
mentioned that they were not final do

00:30:57,629 --> 00:31:04,499
you know why they're not I don't that is

00:31:02,340 --> 00:31:06,869
completely the output of the compiler I

00:31:04,499 --> 00:31:09,769
have not dug into the compiler source

00:31:06,869 --> 00:31:09,769
code to find out why

00:31:14,960 --> 00:31:18,230
okay thank you

00:31:18,350 --> 00:31:23,609

YouTube URL: https://www.youtube.com/watch?v=-BfbiGbUZEM


