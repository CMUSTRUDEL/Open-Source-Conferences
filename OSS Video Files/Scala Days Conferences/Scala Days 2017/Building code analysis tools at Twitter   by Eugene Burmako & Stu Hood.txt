Title: Building code analysis tools at Twitter   by Eugene Burmako & Stu Hood
Publication date: 2017-06-28
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
At Twitter, weâ€™re working with millions of lines of Scala code, and that makes intelligent developer tools especially important. Multiple aspects of our development workflow, including code browsing, code review and code evolution, can be significantly improved if we go beyond just grep and ctags. In this talk, we will present our vision and hands-on experience with a next-generation code analysis toolkit based on the newly introduced scala.meta semantic API.
Captions: 
	00:00:04,140 --> 00:00:11,260
cool welcome to our talk we are Eugene

00:00:09,160 --> 00:00:14,250
and soon after on Twitter while I was

00:00:11,260 --> 00:00:16,570
away you met stew that's really cool and

00:00:14,250 --> 00:00:18,730
today we'll be discussing our vision for

00:00:16,570 --> 00:00:21,039
semantic feeling that we're implemented

00:00:18,730 --> 00:00:22,660
on Twitter and that we're developing in

00:00:21,039 --> 00:00:25,779
the open what everyone in the community

00:00:22,660 --> 00:00:29,099
can use it ok

00:00:25,779 --> 00:00:31,419
just a really brief outline of the talk

00:00:29,099 --> 00:00:34,690
first of all we will go through the

00:00:31,419 --> 00:00:36,910
challenges that way Twitter face with

00:00:34,690 --> 00:00:39,180
our code base that spends millions of

00:00:36,910 --> 00:00:42,609
lines of code how we solve them and

00:00:39,180 --> 00:00:45,660
what's still to be done afterwards will

00:00:42,609 --> 00:00:48,160
present our thoughts of what kind of

00:00:45,660 --> 00:00:50,440
standards we should have for tooling

00:00:48,160 --> 00:00:52,809
what kind of you know bar we should have

00:00:50,440 --> 00:00:56,590
for the application that help us work

00:00:52,809 --> 00:00:58,629
with code and finally I will go through

00:00:56,590 --> 00:01:00,940
the details of the technology stack that

00:00:58,629 --> 00:01:03,940
we proposed to solve the problems and

00:01:00,940 --> 00:01:05,890
people improve upon state of the art or

00:01:03,940 --> 00:01:08,020
any and if you have any questions at any

00:01:05,890 --> 00:01:09,430
point let us know so we can have a

00:01:08,020 --> 00:01:15,490
little more interactive experience

00:01:09,430 --> 00:01:18,670
so my last holidays was in Amsterdam

00:01:15,490 --> 00:01:19,840
which was fantastic a few things have

00:01:18,670 --> 00:01:22,090
changed since then but a whole bunch of

00:01:19,840 --> 00:01:24,640
stuff has not Twitter's definitely still

00:01:22,090 --> 00:01:28,660
in a mono repo it's still called source

00:01:24,640 --> 00:01:32,050
with a capital S the build is massively

00:01:28,660 --> 00:01:33,790
more consistent and slightly faster all

00:01:32,050 --> 00:01:37,090
of the other nice properties of Monterey

00:01:33,790 --> 00:01:39,040
pose still exist there has been a

00:01:37,090 --> 00:01:41,050
persistent rumor that Twitter is writing

00:01:39,040 --> 00:01:44,980
less Scala but it's just utterly not

00:01:41,050 --> 00:01:47,980
true and even since JDK 8 landed in our

00:01:44,980 --> 00:01:50,140
Monterey Bay about a year ago the Scala

00:01:47,980 --> 00:01:54,760
code base career by 35% in the Java code

00:01:50,140 --> 00:01:59,980
base grew by 19% so yeah that's that's

00:01:54,760 --> 00:02:04,450
an excellent endorsement of Scala who

00:01:59,980 --> 00:02:06,370
here knows when a mono repo is cool

00:02:04,450 --> 00:02:11,140
who here is working in a Monterey though

00:02:06,370 --> 00:02:12,189
primarily pretty small oh yeah few folks

00:02:11,140 --> 00:02:15,459
ok

00:02:12,189 --> 00:02:16,720
Monterey pose I I I kind of lead them on

00:02:15,459 --> 00:02:21,400
a repo show

00:02:16,720 --> 00:02:24,040
of the benefits of Monterey pose can be

00:02:21,400 --> 00:02:25,930
summarized pretty quickly in not having

00:02:24,040 --> 00:02:29,080
dependancy diamonds being able to

00:02:25,930 --> 00:02:31,180
atomically commit across projects ie

00:02:29,080 --> 00:02:35,650
update a library and the consumer of

00:02:31,180 --> 00:02:37,690
that library at once have top-to-bottom

00:02:35,650 --> 00:02:40,660
continuous integration testing not just

00:02:37,690 --> 00:02:44,050
on you know snapshots of things but any

00:02:40,660 --> 00:02:45,520
any commit in any repo you can you can

00:02:44,050 --> 00:02:48,760
then test against all of its

00:02:45,520 --> 00:02:50,800
dependencies you also get a linear

00:02:48,760 --> 00:02:52,959
change history meaning that you can get

00:02:50,800 --> 00:02:56,680
bisect to exactly the change that broke

00:02:52,959 --> 00:02:58,570
you rather than essentially bisecting to

00:02:56,680 --> 00:03:00,720
the major version bump of one of your

00:02:58,570 --> 00:03:05,640
dependencies and then not knowing not

00:03:00,720 --> 00:03:05,640
knowing what portion of that change

00:03:08,490 --> 00:03:18,990
control you okay that's better I like

00:03:16,780 --> 00:03:18,990
this

00:03:23,819 --> 00:03:29,230
okay that's a unique experience yeah so

00:03:27,159 --> 00:03:31,060
I'll stand over here for a second

00:03:29,230 --> 00:03:33,299
and you have no binary incredible ities

00:03:31,060 --> 00:03:35,319
between depths except at the boundary

00:03:33,299 --> 00:03:36,790
that's really just an argument for

00:03:35,319 --> 00:03:40,390
source distributions and you can kind of

00:03:36,790 --> 00:03:41,799
see that in the rust and the rest and

00:03:40,390 --> 00:03:43,299
node communities that source

00:03:41,799 --> 00:03:45,670
distributions have kind of allowed for

00:03:43,299 --> 00:03:47,829
this really great library story but

00:03:45,670 --> 00:03:52,269
outside of source distributions binary

00:03:47,829 --> 00:03:54,400
distributions are a pain huge pain so

00:03:52,269 --> 00:03:57,670
but achieving the promise of a mono repo

00:03:54,400 --> 00:04:00,400
am I now on this achieving the promise

00:03:57,670 --> 00:04:02,950
of a monetary file requires a lot of

00:04:00,400 --> 00:04:05,530
tooling so I've given previous talks

00:04:02,950 --> 00:04:09,040
about pants multiple talks I've also

00:04:05,530 --> 00:04:11,459
talked about dependency hygiene which is

00:04:09,040 --> 00:04:14,109
kind of knowing your dependencies

00:04:11,459 --> 00:04:15,430
allowing for lots of dependencies not

00:04:14,109 --> 00:04:17,709
rewriting code that you don't need to

00:04:15,430 --> 00:04:19,660
rewrite but knowing the cost of

00:04:17,709 --> 00:04:21,190
dependencies and today we'll talk a

00:04:19,660 --> 00:04:23,800
little bit more about semantic tooling

00:04:21,190 --> 00:04:29,470
and the role that plays in a moderate

00:04:23,800 --> 00:04:32,590
though and outside of one as well so at

00:04:29,470 --> 00:04:37,090
Twitter the day a day in the life of the

00:04:32,590 --> 00:04:39,940
core Lib dev is good there's coffee and

00:04:37,090 --> 00:04:43,389
free lunch and a roof deck and all that

00:04:39,940 --> 00:04:46,150
good stuff but also when you commit

00:04:43,389 --> 00:04:47,470
something you I'm sorry pre merge you

00:04:46,150 --> 00:04:50,320
get pre merged unit and integration

00:04:47,470 --> 00:04:52,300
testing of all of your dependents so you

00:04:50,320 --> 00:04:53,800
make some change to a library it's kind

00:04:52,300 --> 00:04:56,110
of like everyone having the community

00:04:53,800 --> 00:04:58,210
the Scala community build at their

00:04:56,110 --> 00:05:01,300
fingertips of rebuild everything that

00:04:58,210 --> 00:05:03,160
depends on me I get all of the code

00:05:01,300 --> 00:05:05,410
coverage of all my dependencies and so

00:05:03,160 --> 00:05:07,810
if anyone has bothered to write a

00:05:05,410 --> 00:05:10,300
particular test you know I I don't end

00:05:07,810 --> 00:05:12,729
up committing broken code and I do that

00:05:10,300 --> 00:05:14,530
atomically which is great too there are

00:05:12,729 --> 00:05:19,360
thousands of examples of people using my

00:05:14,530 --> 00:05:22,389
API I can go in and sit with those if

00:05:19,360 --> 00:05:23,770
somebody's doing it wrong and users sit

00:05:22,389 --> 00:05:25,630
down right right down the hall it's all

00:05:23,770 --> 00:05:27,880
good but it's not perfect

00:05:25,630 --> 00:05:32,039
so given that there's tons of source

00:05:27,880 --> 00:05:32,039
code how do I remove an API

00:05:32,440 --> 00:05:36,400
Oh mon are--those in serie give you the

00:05:34,630 --> 00:05:38,980
ability to avoid deprecations in the

00:05:36,400 --> 00:05:40,720
common case because you can edit both

00:05:38,980 --> 00:05:41,830
the library and the thing that depends

00:05:40,720 --> 00:05:45,490
on it

00:05:41,830 --> 00:05:47,800
you can just straight up make method

00:05:45,490 --> 00:05:51,190
renames things like that without

00:05:47,800 --> 00:05:54,360
deprecating the old method and then m

00:05:51,190 --> 00:05:57,550
going through a deprecation cycle there

00:05:54,360 --> 00:06:00,640
also dead code in a mono repo is not

00:05:57,550 --> 00:06:03,250
like dead code in a poly repo setup so

00:06:00,640 --> 00:06:05,770
if some some dead repo out some I'm

00:06:03,250 --> 00:06:08,050
sorry if some repo out somewhere is

00:06:05,770 --> 00:06:09,640
depending on a library you don't ever

00:06:08,050 --> 00:06:11,020
really have to touch it you don't ever

00:06:09,640 --> 00:06:13,810
really have to integrate with that lot

00:06:11,020 --> 00:06:16,600
that that repo and so you don't ever

00:06:13,810 --> 00:06:18,730
have to really update that code in a

00:06:16,600 --> 00:06:22,120
monetary boat everything builds all the

00:06:18,730 --> 00:06:25,390
time and and can't fit rot unless it's

00:06:22,120 --> 00:06:27,460
been straight-up deleted so as an

00:06:25,390 --> 00:06:30,940
example internally we we wanted to

00:06:27,460 --> 00:06:33,580
rewrite future get to await results and

00:06:30,940 --> 00:06:35,320
this is Twitter's future but I think in

00:06:33,580 --> 00:06:36,820
in this particular case this was

00:06:35,320 --> 00:06:41,230
something to align more closely with the

00:06:36,820 --> 00:06:43,090
Scala futures and it required a custom

00:06:41,230 --> 00:06:46,000
compiler plugin and that's not the great

00:06:43,090 --> 00:06:48,250
the best situation they also

00:06:46,000 --> 00:06:51,010
accomplished it as multiple multiple

00:06:48,250 --> 00:06:54,970
commits although that was not strictly

00:06:51,010 --> 00:06:56,200
strictly necessary so let's talk about

00:06:54,970 --> 00:06:58,900
the state of semantic tooling we'd like

00:06:56,200 --> 00:07:02,200
that to be better first of all we have

00:06:58,900 --> 00:07:04,180
very coarse semantic information via

00:07:02,200 --> 00:07:06,850
target level dependencies there are a

00:07:04,180 --> 00:07:09,240
lot of targets and then there's a

00:07:06,850 --> 00:07:11,710
smaller number of routes so if you have

00:07:09,240 --> 00:07:14,110
targets sorry targets and pants

00:07:11,710 --> 00:07:15,460
terminology are modules as two key

00:07:14,110 --> 00:07:17,650
projects is another way to think about

00:07:15,460 --> 00:07:20,080
them but we focus on having a very very

00:07:17,650 --> 00:07:23,620
small amounts of configuration for every

00:07:20,080 --> 00:07:25,030
particular any particular target and in

00:07:23,620 --> 00:07:29,500
particular over the course of the last

00:07:25,030 --> 00:07:32,590
few years the amount of config required

00:07:29,500 --> 00:07:34,540
to define a target has dropped

00:07:32,590 --> 00:07:36,430
significantly and that you no longer

00:07:34,540 --> 00:07:37,990
have to name them if you want the name

00:07:36,430 --> 00:07:41,320
to just default to the directory therein

00:07:37,990 --> 00:07:44,110
and you no longer have to specify what

00:07:41,320 --> 00:07:46,150
sources they match if you want kind of

00:07:44,110 --> 00:07:47,230
the default set of sources and so you

00:07:46,150 --> 00:07:49,510
really just end up listing your

00:07:47,230 --> 00:07:52,480
dependencies and nothing else to define

00:07:49,510 --> 00:07:54,220
some new module and so given that it's

00:07:52,480 --> 00:07:56,980
now so easy there are lots of targets

00:07:54,220 --> 00:08:00,420
people split targets up and you have you

00:07:56,980 --> 00:08:02,860
know two files per target in some cases

00:08:00,420 --> 00:08:06,640
the routes then are things that test

00:08:02,860 --> 00:08:09,760
those targets or are binaries for those

00:08:06,640 --> 00:08:11,350
targets or are published so if you have

00:08:09,760 --> 00:08:15,610
if you if you've marked something as

00:08:11,350 --> 00:08:17,260
having cember that's also a route we

00:08:15,610 --> 00:08:18,700
also slightly finer like class level

00:08:17,260 --> 00:08:22,990
semantic information which we get from

00:08:18,700 --> 00:08:25,750
zinc and so there are a lot of class

00:08:22,990 --> 00:08:31,030
files I have a bit of inconsistency here

00:08:25,750 --> 00:08:35,050
that's a post post cogent number whereas

00:08:31,030 --> 00:08:37,480
pre-code gen lines of code we have very

00:08:35,050 --> 00:08:41,520
fast text and regex based indexes but

00:08:37,480 --> 00:08:43,660
it's not quite semantic information yet

00:08:41,520 --> 00:08:46,390
the only place where we have symbol

00:08:43,660 --> 00:08:48,960
level information unfortunately is where

00:08:46,390 --> 00:08:52,270
almost everyone has it which is an IDE s

00:08:48,960 --> 00:08:53,590
we had a very old source graphs install

00:08:52,270 --> 00:08:56,020
and unfortunately it was recently

00:08:53,590 --> 00:08:58,630
deprecated it was kind of legacy code

00:08:56,020 --> 00:09:01,570
for both companies it relied on a

00:08:58,630 --> 00:09:05,230
particular compiler version which will

00:09:01,570 --> 00:09:07,930
kind of become a theme here and also a

00:09:05,230 --> 00:09:09,940
specific to source graph they have a

00:09:07,930 --> 00:09:12,070
great new direction and I'm very

00:09:09,940 --> 00:09:14,440
optimistic that they will do well there

00:09:12,070 --> 00:09:16,930
I'm not ruling out continuing to

00:09:14,440 --> 00:09:19,090
collaborate with them so I think

00:09:16,930 --> 00:09:20,620
actually the LSPs extensions language

00:09:19,090 --> 00:09:23,230
server protocol microsoft language

00:09:20,620 --> 00:09:24,850
server protocol as martin mentioned is

00:09:23,230 --> 00:09:29,050
also being used in dot e so that's

00:09:24,850 --> 00:09:30,850
that's definitely promising pants also

00:09:29,050 --> 00:09:33,310
has recently gained support for scala

00:09:30,850 --> 00:09:36,100
fix and it has had support for Scala SMT

00:09:33,310 --> 00:09:38,380
for a while they're not widely used yet

00:09:36,100 --> 00:09:40,120
internally but we'll probably do you

00:09:38,380 --> 00:09:43,000
know as one commits a very large rewrite

00:09:40,120 --> 00:09:46,120
of the hull of the code fairly soon to

00:09:43,000 --> 00:09:47,800
get everything consistent so we'd like

00:09:46,120 --> 00:09:49,870
to be in a better place and we have some

00:09:47,800 --> 00:09:52,590
ideas about that which is what we'll

00:09:49,870 --> 00:09:52,590
talk about next

00:09:53,860 --> 00:10:02,440
okay so once we realize the problem that

00:09:59,740 --> 00:10:04,150
is that the semantic tooling is a bit

00:10:02,440 --> 00:10:06,520
like n' because we have something

00:10:04,150 --> 00:10:08,680
similar to grab it's more advanced it's

00:10:06,520 --> 00:10:10,390
faster but still is not enough for

00:10:08,680 --> 00:10:13,240
complete understanding of the code base

00:10:10,390 --> 00:10:15,220
and then we went to help them well

00:10:13,240 --> 00:10:17,800
together with the developers at our

00:10:15,220 --> 00:10:20,260
company we figured the what are the main

00:10:17,800 --> 00:10:23,680
requirements for them to be effective

00:10:20,260 --> 00:10:25,870
and well basically the first thing that

00:10:23,680 --> 00:10:28,240
I would like to do with the code is to

00:10:25,870 --> 00:10:31,480
understand it because while we read code

00:10:28,240 --> 00:10:33,550
my share more often than right and as a

00:10:31,480 --> 00:10:36,970
result it would be really cool if we

00:10:33,550 --> 00:10:39,910
could provide a system that resolves

00:10:36,970 --> 00:10:41,860
names in programs that people write so

00:10:39,910 --> 00:10:44,260
we can do the proverbial

00:10:41,860 --> 00:10:47,470
in a command click control click

00:10:44,260 --> 00:10:50,020
navigate to definition and then we could

00:10:47,470 --> 00:10:51,630
do even more for classes we could figure

00:10:50,020 --> 00:10:54,100
out the inheritance relationship

00:10:51,630 --> 00:10:56,170
relationships between them and we could

00:10:54,100 --> 00:10:56,650
fetch documentation and do a lot of cool

00:10:56,170 --> 00:10:58,720
stuff

00:10:56,650 --> 00:11:02,230
once we have the information that the

00:10:58,720 --> 00:11:04,540
compiler has about the code also code

00:11:02,230 --> 00:11:06,490
review is a very important part of our

00:11:04,540 --> 00:11:09,730
workflow and everyone's workflow

00:11:06,490 --> 00:11:12,160
basically and for a given change for a

00:11:09,730 --> 00:11:14,830
given path or request we would like to

00:11:12,160 --> 00:11:17,830
first of all have the Diagnostics from

00:11:14,830 --> 00:11:21,520
the compiler and also to also be able to

00:11:17,830 --> 00:11:23,470
go to use hyper linking so we can easily

00:11:21,520 --> 00:11:25,570
navigate the pull request and understand

00:11:23,470 --> 00:11:28,600
what it's about about its concept

00:11:25,570 --> 00:11:31,000
context another very important thing

00:11:28,600 --> 00:11:33,160
after we checked up the code we reviewed

00:11:31,000 --> 00:11:35,230
it and then we pushed it what do we do

00:11:33,160 --> 00:11:37,600
this next so this is something that Stu

00:11:35,230 --> 00:11:40,240
has alluded to in the previous part of

00:11:37,600 --> 00:11:42,480
the presentation in a model in a model

00:11:40,240 --> 00:11:45,280
repo that's especially important because

00:11:42,480 --> 00:11:47,620
if the dead code is there it's always

00:11:45,280 --> 00:11:49,600
compiling so for every change for every

00:11:47,620 --> 00:11:51,970
pull request that is submitted we

00:11:49,600 --> 00:11:54,220
compile it over and over again and it

00:11:51,970 --> 00:11:56,500
would be nice to have ways to deal with

00:11:54,220 --> 00:11:59,680
that because that will speed up our

00:11:56,500 --> 00:12:02,890
deals and well as you guys are very well

00:11:59,680 --> 00:12:06,490
know scholarly compilation times this is

00:12:02,890 --> 00:12:08,110
somewhat of an unsolved problem and also

00:12:06,490 --> 00:12:11,500
speaking of code evolution there's a

00:12:08,110 --> 00:12:13,030
very promising direction automated

00:12:11,500 --> 00:12:15,480
rewritings so Stu

00:12:13,030 --> 00:12:18,370
also mentioned Scala fix and that's

00:12:15,480 --> 00:12:19,920
English step in the right direction so

00:12:18,370 --> 00:12:22,360
how do we make sure that scholastics

00:12:19,920 --> 00:12:24,220
scales the huge code bases like ours

00:12:22,360 --> 00:12:27,760
that's another challenge and that's

00:12:24,220 --> 00:12:30,820
something that were tackling okay so how

00:12:27,760 --> 00:12:33,340
do we do that because it's great to do

00:12:30,820 --> 00:12:35,350
this kind of wishful thinking but what

00:12:33,340 --> 00:12:39,160
kind of technology can we use to pull

00:12:35,350 --> 00:12:42,160
this off and I think we need to do this

00:12:39,160 --> 00:12:44,890
three-step solution first of all we need

00:12:42,160 --> 00:12:46,870
a reliable way to extract a semantic

00:12:44,890 --> 00:12:48,280
information from the compiler so the

00:12:46,870 --> 00:12:50,560
compiler is the guy who knows everything

00:12:48,280 --> 00:12:54,490
about our code so let's just talk

00:12:50,560 --> 00:12:56,980
directly to Scala C and then well fish

00:12:54,490 --> 00:12:58,960
the information about resolved names for

00:12:56,980 --> 00:13:01,000
hyperlinking about inheritance

00:12:58,960 --> 00:13:03,010
relationships documentation and so on

00:13:01,000 --> 00:13:06,820
and so forth that's the first part and

00:13:03,010 --> 00:13:08,740
then both are huge code bases like ours

00:13:06,820 --> 00:13:11,200
I will also need some sort of

00:13:08,740 --> 00:13:13,360
distributed tooling that would take this

00:13:11,200 --> 00:13:15,580
information that we fished and then

00:13:13,360 --> 00:13:18,280
store it in a scalable manner so it can

00:13:15,580 --> 00:13:20,950
then be served to power the third step

00:13:18,280 --> 00:13:22,900
that is the ecosystem of tools for

00:13:20,950 --> 00:13:26,800
instance called rewritings like Scala

00:13:22,900 --> 00:13:28,630
fix code analysis code search and these

00:13:26,800 --> 00:13:32,230
tools would work with the schemas that

00:13:28,630 --> 00:13:35,280
we've extracted and well with this big

00:13:32,230 --> 00:13:38,500
distributed storage that we provide and

00:13:35,280 --> 00:13:40,120
the first step for extraction is better

00:13:38,500 --> 00:13:42,670
than the project that I started at EPFL

00:13:40,120 --> 00:13:44,620
while I still was a PhD student as

00:13:42,670 --> 00:13:46,930
several years ago now the project is

00:13:44,620 --> 00:13:50,790
called Scala meta I probably heard about

00:13:46,930 --> 00:13:53,770
it but in a bit of a different context

00:13:50,790 --> 00:13:55,780
so let's up go little bit through the

00:13:53,770 --> 00:13:58,300
functionality that Scala meta provides I

00:13:55,780 --> 00:14:01,120
like the group body functionality into

00:13:58,300 --> 00:14:03,730
two big categories the first one is what

00:14:01,120 --> 00:14:06,750
we call syntactic API basically allows

00:14:03,730 --> 00:14:08,920
you to parse the code to tokenize it Oh

00:14:06,750 --> 00:14:12,800
basically to see what the code is made

00:14:08,920 --> 00:14:14,660
of but not to understand its meaning

00:14:12,800 --> 00:14:16,910
something that has been pretty stable

00:14:14,660 --> 00:14:19,730
it's available for several years years

00:14:16,910 --> 00:14:21,800
already and it was part of our 1.0

00:14:19,730 --> 00:14:24,920
release that we did in Berlin it's

00:14:21,800 --> 00:14:26,779
called its last year and now for a newer

00:14:24,920 --> 00:14:30,130
addition something that we call a

00:14:26,779 --> 00:14:34,490
semantic API this is what I hacked after

00:14:30,130 --> 00:14:37,940
after I joined Twitter last year and the

00:14:34,490 --> 00:14:40,790
semantic API is exactly the solution for

00:14:37,940 --> 00:14:43,640
the problem with the outline before of

00:14:40,790 --> 00:14:45,920
talking to the Scala compiler and then

00:14:43,640 --> 00:14:49,190
fashion the semantic information about

00:14:45,920 --> 00:14:50,750
the code we intentionally built this as

00:14:49,190 --> 00:14:54,680
an open source project so this is

00:14:50,750 --> 00:14:56,959
nothing closer is going on at all and

00:14:54,680 --> 00:14:58,910
hope you can go to this column at the

00:14:56,959 --> 00:15:00,649
repository Scala meta slash collimated

00:14:58,910 --> 00:15:04,070
github and check out recent progress

00:15:00,649 --> 00:15:06,380
issues so on and so forth and why we're

00:15:04,070 --> 00:15:07,910
doing that because we're really sure

00:15:06,380 --> 00:15:10,160
that we need some sort of a

00:15:07,910 --> 00:15:12,350
community-wide standard here so that

00:15:10,160 --> 00:15:15,589
people don't need to reinvent the wheel

00:15:12,350 --> 00:15:17,570
over and over again so it's not just

00:15:15,589 --> 00:15:18,910
that you know some pipe dream it's

00:15:17,570 --> 00:15:22,220
actually a project that's used

00:15:18,910 --> 00:15:24,320
internally at Twitter and we also

00:15:22,220 --> 00:15:27,320
collaborate with the Scala center on the

00:15:24,320 --> 00:15:31,070
Scala fix tool that uses our newly

00:15:27,320 --> 00:15:34,190
introduced semantic API and also we have

00:15:31,070 --> 00:15:36,770
a stable release 1.8 that features a

00:15:34,190 --> 00:15:39,020
technology preview of the semantic API

00:15:36,770 --> 00:15:40,670
something that I will talk about a

00:15:39,020 --> 00:15:42,500
little bit later and that will show a

00:15:40,670 --> 00:15:45,980
couple of examples how exactly it works

00:15:42,500 --> 00:15:49,190
and so what it's all very good and

00:15:45,980 --> 00:15:50,810
interesting but I guess most of you

00:15:49,190 --> 00:15:52,700
heard of Scala methane in the context of

00:15:50,810 --> 00:15:56,449
macros and that's how the project

00:15:52,700 --> 00:15:58,220
started so back then in 2011 when I just

00:15:56,449 --> 00:16:00,709
joined the PFL and had this idea to

00:15:58,220 --> 00:16:05,209
implement macros for Scala we were using

00:16:00,709 --> 00:16:07,610
Scala reflect that is the thin API over

00:16:05,209 --> 00:16:09,589
compiler internals in order to compile

00:16:07,610 --> 00:16:12,260
that meta programming but over years we

00:16:09,589 --> 00:16:14,260
realize that that doesn't cut it because

00:16:12,260 --> 00:16:17,329
being tied to compiler internals

00:16:14,260 --> 00:16:20,000
it's not good for portability and then

00:16:17,329 --> 00:16:22,100
at that time we already knew internally

00:16:20,000 --> 00:16:23,560
in the lab that there will be a new

00:16:22,100 --> 00:16:26,230
Scala compiler and experi

00:16:23,560 --> 00:16:28,900
mental one maybe it would become Scala

00:16:26,230 --> 00:16:30,370
three and now indeed has the potential

00:16:28,900 --> 00:16:32,590
and it's been announced that dodgy will

00:16:30,370 --> 00:16:34,240
be Scala three so we needed to do

00:16:32,590 --> 00:16:36,730
something better something portable and

00:16:34,240 --> 00:16:39,760
this is House Kalamata was born and so

00:16:36,730 --> 00:16:41,650
as a matter of fact and the project that

00:16:39,760 --> 00:16:43,620
started with these simple origins it's

00:16:41,650 --> 00:16:46,660
now grown into something much bigger

00:16:43,620 --> 00:16:51,220
general generally the foundation for

00:16:46,660 --> 00:16:52,990
tools in Scala so as a result today in

00:16:51,220 --> 00:16:55,839
this very talk I will be covering only

00:16:52,990 --> 00:16:57,520
the tooling face of Scala meta we also

00:16:55,839 --> 00:17:00,820
have some really great exciting progress

00:16:57,520 --> 00:17:02,500
on the macro side so just yesterday I

00:17:00,820 --> 00:17:05,500
finished the prototype of death macros

00:17:02,500 --> 00:17:08,470
so we had macro notations long time ago

00:17:05,500 --> 00:17:11,020
a year ago in New York City at Scala

00:17:08,470 --> 00:17:13,170
days but now we also have def macros and

00:17:11,020 --> 00:17:15,910
that's a very very cool development I'm

00:17:13,170 --> 00:17:17,949
definitely happy about this been hiking

00:17:15,910 --> 00:17:21,280
notes though for quite a while and I

00:17:17,949 --> 00:17:23,860
will talk more about that at the at the

00:17:21,280 --> 00:17:27,010
upcoming table and just in just an hour

00:17:23,860 --> 00:17:30,090
or two the to be called Scala made the

00:17:27,010 --> 00:17:32,620
coding session soap a secret he can be

00:17:30,090 --> 00:17:34,480
agreed with the speaker he can agree

00:17:32,620 --> 00:17:37,270
that the hijack the session a little bit

00:17:34,480 --> 00:17:39,070
and show a recent progress anyway now

00:17:37,270 --> 00:17:41,980
without further ado let's see how Scala

00:17:39,070 --> 00:17:43,540
meta helps us with tooling helps us to

00:17:41,980 --> 00:17:46,720
do semantic tuning this vision that we

00:17:43,540 --> 00:17:48,700
mentioned before well first of all we

00:17:46,720 --> 00:17:50,830
need to understand the background how

00:17:48,700 --> 00:17:53,230
does the tooling story look right now so

00:17:50,830 --> 00:17:56,140
what's the state of the art and as a

00:17:53,230 --> 00:17:58,179
matter of fact it's not easy so in order

00:17:56,140 --> 00:17:59,800
to integrate with the Scala compiler in

00:17:58,179 --> 00:18:01,120
the in order to get full information

00:17:59,800 --> 00:18:03,640
about your code you need to write

00:18:01,120 --> 00:18:05,770
compiler plugins and then after after

00:18:03,640 --> 00:18:08,200
you write a compiler plugin inserted

00:18:05,770 --> 00:18:10,030
after this phase called diaper which is

00:18:08,200 --> 00:18:12,160
the type checker then you import

00:18:10,030 --> 00:18:15,610
something called the global basically

00:18:12,160 --> 00:18:17,830
the compiler which contains hundreds of

00:18:15,610 --> 00:18:19,330
methods you start fighting with it

00:18:17,830 --> 00:18:22,120
because you instantaneously get

00:18:19,330 --> 00:18:24,220
overwhelmed well what do you do what

00:18:22,120 --> 00:18:26,830
method do you big to achieve your

00:18:24,220 --> 00:18:29,710
particular goal and finally well the

00:18:26,830 --> 00:18:31,780
battle is over maybe you figured out

00:18:29,710 --> 00:18:33,880
some Stack Overflow answers by Travis

00:18:31,780 --> 00:18:34,370
brown who's been doing the same for you

00:18:33,880 --> 00:18:37,460
when

00:18:34,370 --> 00:18:39,470
just got introduced and finally you're

00:18:37,460 --> 00:18:41,900
done but actually you're not done

00:18:39,470 --> 00:18:44,390
because next time when a minor version

00:18:41,900 --> 00:18:46,130
of the compiler is you need light then

00:18:44,390 --> 00:18:47,630
guys maybe refactor something in order

00:18:46,130 --> 00:18:49,820
to make the compiler simpler and faster

00:18:47,630 --> 00:18:51,980
and then suddenly the API has gone to

00:18:49,820 --> 00:18:55,880
what they do and well that's the said

00:18:51,980 --> 00:18:57,740
life of a semantic tool developer why

00:18:55,880 --> 00:18:59,780
does this approach network well

00:18:57,740 --> 00:19:02,300
something that due to the reasons that I

00:18:59,780 --> 00:19:04,730
mentioned before first of all the

00:19:02,300 --> 00:19:07,040
sources of the compiler are huge it's

00:19:04,730 --> 00:19:08,600
tens of thousands lines of code maybe

00:19:07,040 --> 00:19:11,840
with with all the tests that would be

00:19:08,600 --> 00:19:15,020
over 100,000 and necessarily it contains

00:19:11,840 --> 00:19:17,059
a lot of modules and they call each

00:19:15,020 --> 00:19:19,730
other and they also work with the common

00:19:17,059 --> 00:19:22,120
API which is thousands of methods that's

00:19:19,730 --> 00:19:25,070
not fun and that's not easy to get into

00:19:22,120 --> 00:19:27,620
so back then in 2011 when we were

00:19:25,070 --> 00:19:29,720
designing an API for micros we actually

00:19:27,620 --> 00:19:31,309
figured well while we're doing compile

00:19:29,720 --> 00:19:33,590
time as a programming maybe we can reuse

00:19:31,309 --> 00:19:36,380
the same API for tooling so let's just

00:19:33,590 --> 00:19:39,440
reduce the API surface to several

00:19:36,380 --> 00:19:42,080
hundred most popular methods and then we

00:19:39,440 --> 00:19:44,510
will try to do with it maybe maybe

00:19:42,080 --> 00:19:46,910
they'll be enough so now I realize when

00:19:44,510 --> 00:19:49,190
I'm looking at the slides it says well

00:19:46,910 --> 00:19:52,250
several hundred methods in an API have

00:19:49,190 --> 00:19:55,220
my god this is insane right but at that

00:19:52,250 --> 00:19:56,929
time if we get one slide back which

00:19:55,220 --> 00:19:59,210
there's thousands of different methods

00:19:56,929 --> 00:20:01,429
that's definitely an improvement by you

00:19:59,210 --> 00:20:03,230
know one or two orders of magnitude so

00:20:01,429 --> 00:20:05,990
that was quite a breakthrough honestly

00:20:03,230 --> 00:20:07,940
because we not only simplified the API

00:20:05,990 --> 00:20:10,160
but also guaranteed stability of this

00:20:07,940 --> 00:20:13,309
API between minor versions a minor

00:20:10,160 --> 00:20:16,580
releases of Scala and even major ones so

00:20:13,309 --> 00:20:19,370
when we went from Scala to then to Scala

00:20:16,580 --> 00:20:21,559
to 11 we actually did a lot of work to

00:20:19,370 --> 00:20:24,110
provide source compatibility for the

00:20:21,559 --> 00:20:27,470
migration so actually some API has got

00:20:24,110 --> 00:20:30,080
renamed got moved but there were ways to

00:20:27,470 --> 00:20:31,790
cross compile so it wasn't maybe it

00:20:30,080 --> 00:20:34,100
wasn't pretty but it was still working

00:20:31,790 --> 00:20:36,170
which is which is I guess quite

00:20:34,100 --> 00:20:38,830
interesting in comparison with API that

00:20:36,170 --> 00:20:43,010
can break across minor versions and

00:20:38,830 --> 00:20:45,220
afterwards we did the second attempt in

00:20:43,010 --> 00:20:47,380
order to make better macros

00:20:45,220 --> 00:20:49,030
Kalamata was started but we're

00:20:47,380 --> 00:20:52,210
interested in further reducing the API

00:20:49,030 --> 00:20:54,270
surface and then we you know did another

00:20:52,210 --> 00:20:56,919
order of magnitude improvement and

00:20:54,270 --> 00:20:59,140
compressed the surface of API is using

00:20:56,919 --> 00:21:01,510
some technologies that you may have

00:20:59,140 --> 00:21:02,830
heard of quality quotes so then is the

00:21:01,510 --> 00:21:05,490
author of quasi codes is here in the

00:21:02,830 --> 00:21:09,250
audience and other locals who basically

00:21:05,490 --> 00:21:12,190
came up with ways to simplify things but

00:21:09,250 --> 00:21:14,650
one thing that was still in there we

00:21:12,190 --> 00:21:16,360
were talking to the compiler so we're

00:21:14,650 --> 00:21:18,820
using compilers underlying data

00:21:16,360 --> 00:21:21,130
structures by this approach we should

00:21:18,820 --> 00:21:25,590
call converters basically we had

00:21:21,130 --> 00:21:29,679
dedicated modules that convert from skÃ¥l

00:21:25,590 --> 00:21:32,260
skÃ¥l series just called meta trees back

00:21:29,679 --> 00:21:35,590
and forth that was quite an interesting

00:21:32,260 --> 00:21:38,260
experience and unfortunately we really

00:21:35,590 --> 00:21:40,570
didn't work long story short research is

00:21:38,260 --> 00:21:42,880
fun and well person they had most

00:21:40,570 --> 00:21:45,600
enjoyed the failed projects because we

00:21:42,880 --> 00:21:48,220
learned so much so why did this one fail

00:21:45,600 --> 00:21:51,730
well first of all we were still relying

00:21:48,220 --> 00:21:53,650
on Scala see internals and both they're

00:21:51,730 --> 00:21:56,159
quite complicated so compiler needs to

00:21:53,650 --> 00:21:59,500
be a lot of stuff not just you know

00:21:56,159 --> 00:22:01,120
equivalent of semantic tooling but also

00:21:59,500 --> 00:22:03,070
byte code generation also

00:22:01,120 --> 00:22:05,230
transformations that lower your

00:22:03,070 --> 00:22:08,590
high-level Scala code into low JVM

00:22:05,230 --> 00:22:10,289
bytecode and for that the data model is

00:22:08,590 --> 00:22:14,230
much more complicated that we needed and

00:22:10,289 --> 00:22:17,200
as a result the converters that I was

00:22:14,230 --> 00:22:20,289
mentioning before they were thousands

00:22:17,200 --> 00:22:23,409
lines of code and they were quite tricky

00:22:20,289 --> 00:22:25,539
to get right in the first place and you

00:22:23,409 --> 00:22:27,130
know when you need to be really smart to

00:22:25,539 --> 00:22:30,039
write some code you need to be twice as

00:22:27,130 --> 00:22:31,960
smart to debug it and putting well I'm

00:22:30,039 --> 00:22:34,510
not that smart so we essentially

00:22:31,960 --> 00:22:36,669
scrapped this approach and came up with

00:22:34,510 --> 00:22:39,760
something better in the beginning of

00:22:36,669 --> 00:22:41,320
this year so what we thought we thought

00:22:39,760 --> 00:22:45,370
that we would rethink the data

00:22:41,320 --> 00:22:47,500
structures completely from scratch so we

00:22:45,370 --> 00:22:50,260
went ahead figured out the use cases

00:22:47,500 --> 00:22:52,539
that we wanted to support and created a

00:22:50,260 --> 00:22:54,130
data schema that works just for that so

00:22:52,539 --> 00:22:56,289
since we don't need to compile it into

00:22:54,130 --> 00:22:57,250
byte code we just need to understand

00:22:56,289 --> 00:23:00,040
meanings of programs

00:22:57,250 --> 00:23:01,930
so that we can ride smarter tools we've

00:23:00,040 --> 00:23:05,320
come up with the thing that does only

00:23:01,930 --> 00:23:08,680
this instance for a given identifier we

00:23:05,320 --> 00:23:11,590
can now store unique IDs of definitions

00:23:08,680 --> 00:23:13,900
that it points to also if we need to

00:23:11,590 --> 00:23:15,670
remember a compiler message' compiler

00:23:13,900 --> 00:23:17,290
whirring well we have a compiler

00:23:15,670 --> 00:23:20,530
whirring data structure in the API

00:23:17,290 --> 00:23:22,690
something like this and as a result we

00:23:20,530 --> 00:23:26,670
didn't have to do any bi-directional

00:23:22,690 --> 00:23:29,860
interrupt with the compiler anymore so

00:23:26,670 --> 00:23:32,470
this has simplified the API even further

00:23:29,860 --> 00:23:36,430
I would say another order of magnitude

00:23:32,470 --> 00:23:38,830
improvement how does this look like well

00:23:36,430 --> 00:23:40,450
the data schema that we introduced we

00:23:38,830 --> 00:23:45,520
gave it a name a special name called

00:23:40,450 --> 00:23:47,140
semantic database and the simplicity can

00:23:45,520 --> 00:23:49,720
be proven by just in all lines of code

00:23:47,140 --> 00:23:52,540
so we include the data schema in the

00:23:49,720 --> 00:23:54,820
protocol definition and in just a little

00:23:52,540 --> 00:23:57,190
bit more than 50 lines of code in the

00:23:54,820 --> 00:23:58,540
current version of scala mehta and even

00:23:57,190 --> 00:24:00,460
though it's quite minimalistic it

00:23:58,540 --> 00:24:05,080
already supports a lot of functionality

00:24:00,460 --> 00:24:07,630
so it allows to resolve names to store

00:24:05,080 --> 00:24:09,370
compiler warnings to store something

00:24:07,630 --> 00:24:12,820
called denotations which is basically

00:24:09,370 --> 00:24:14,200
signatures and flags for definitions so

00:24:12,820 --> 00:24:16,420
for instance if a method is implicit

00:24:14,200 --> 00:24:17,200
than this denotation think it remembers

00:24:16,420 --> 00:24:19,690
that it's implicit

00:24:17,200 --> 00:24:22,900
and finally we store something called

00:24:19,690 --> 00:24:25,000
syntactic sugar she's basically whatever

00:24:22,900 --> 00:24:29,350
the type checker infers about their

00:24:25,000 --> 00:24:31,960
programs be type arguments term

00:24:29,350 --> 00:24:35,050
arguments such as implicit parameters

00:24:31,960 --> 00:24:36,580
and so on so forth and finally we went

00:24:35,050 --> 00:24:39,040
ahead and implemented the prototype of

00:24:36,580 --> 00:24:41,590
this as a compiler plugin actually we

00:24:39,040 --> 00:24:43,900
have a compiler plugin that can

00:24:41,590 --> 00:24:46,420
integrate into skull 211 and skeletal 12

00:24:43,900 --> 00:24:49,210
and then talk to the compiler and dump

00:24:46,420 --> 00:24:53,920
this information with data mines into

00:24:49,210 --> 00:24:55,420
the semantic DB protobuf schema now let

00:24:53,920 --> 00:24:58,060
the let me go through a quick example

00:24:55,420 --> 00:25:00,490
that will show the capabilities of

00:24:58,060 --> 00:25:03,600
what's in there already in the Scala

00:25:00,490 --> 00:25:07,060
meta 128 release we will go ahead and

00:25:03,600 --> 00:25:09,370
see a very simple Scala file it's not

00:25:07,060 --> 00:25:10,200
very meaningful but it demonstrates a

00:25:09,370 --> 00:25:12,509
lot of features

00:25:10,200 --> 00:25:15,799
and so we will see what kind of semantic

00:25:12,509 --> 00:25:18,629
database we can get for this problem

00:25:15,799 --> 00:25:22,679
let's do some live coding because this

00:25:18,629 --> 00:25:25,970
always works alright I'll start will be

00:25:22,679 --> 00:25:29,309
promised file let's just tune the font

00:25:25,970 --> 00:25:32,669
guides of the last rows is this legible

00:25:29,309 --> 00:25:35,629
or anything crease it further that's all

00:25:32,669 --> 00:25:37,889
right okay cool I can see definitely

00:25:35,629 --> 00:25:41,480
okay so this is the program that we've

00:25:37,889 --> 00:25:46,889
seen on the slide now I'm just gonna

00:25:41,480 --> 00:25:49,700
drop into the command line and compile

00:25:46,889 --> 00:25:51,960
this file alright

00:25:49,700 --> 00:25:54,149
as I mentioned that we have a custom

00:25:51,960 --> 00:25:56,070
compiler plugin and it's quite a new and

00:25:54,149 --> 00:25:57,840
will be to just say you know X plug-in

00:25:56,070 --> 00:25:59,759
blah blah blah provide the full path so

00:25:57,840 --> 00:26:01,559
for my skullossus script I actually have

00:25:59,759 --> 00:26:04,649
discussed and flag called semantic VB

00:26:01,559 --> 00:26:08,960
and if you compile this library the

00:26:04,649 --> 00:26:11,309
Scala file with this compiler invocation

00:26:08,960 --> 00:26:13,440
it's going to you know wait for a while

00:26:11,309 --> 00:26:15,779
maybe we need to call native to make it

00:26:13,440 --> 00:26:17,730
faster so that doesn't have to get

00:26:15,779 --> 00:26:21,269
everything from scratch and after the

00:26:17,730 --> 00:26:22,739
compilation finishes next to the class

00:26:21,269 --> 00:26:25,230
files which are there in the comm

00:26:22,739 --> 00:26:28,859
directory will also see the methane's

00:26:25,230 --> 00:26:30,359
directory so meta in scala meta Oh this

00:26:28,859 --> 00:26:33,179
made sense to me that's honestly so I

00:26:30,359 --> 00:26:34,950
just decided to go for it and afterwards

00:26:33,179 --> 00:26:37,499
in the meting directory we have

00:26:34,950 --> 00:26:40,559
something called semantic DP if we go

00:26:37,499 --> 00:26:43,230
there we will see that there's a file

00:26:40,559 --> 00:26:45,389
called library Datsun antic VB so for

00:26:43,230 --> 00:26:47,820
every file that we compile there's a

00:26:45,389 --> 00:26:52,019
corresponding semantic DB thing in this

00:26:47,820 --> 00:26:54,179
methane we generate one file per one

00:26:52,019 --> 00:26:56,789
input file in order to support SBT and

00:26:54,179 --> 00:26:59,730
incremental compilation just like in AA

00:26:56,789 --> 00:27:02,009
Scala GS or Scala native do that and if

00:26:59,730 --> 00:27:03,480
we take a look inside the semantic DD

00:27:02,009 --> 00:27:05,850
we're not going to see anything fun

00:27:03,480 --> 00:27:08,100
because it's wrote above but actually it

00:27:05,850 --> 00:27:09,539
will give some idea so some binary data

00:27:08,100 --> 00:27:12,509
plus strings

00:27:09,539 --> 00:27:16,109
well not very interesting let's go back

00:27:12,509 --> 00:27:18,419
and actually use a script a helper

00:27:16,109 --> 00:27:20,759
script that I wrote using this column at

00:27:18,419 --> 00:27:22,630
API so Scala meta provides an object

00:27:20,759 --> 00:27:25,419
model that allows you to load this

00:27:22,630 --> 00:27:32,320
binary schemas into well respectable

00:27:25,419 --> 00:27:34,450
objects and let's take a look I need

00:27:32,320 --> 00:27:36,580
some magic in vacations because it's a

00:27:34,450 --> 00:27:38,650
pretty rough script but you can actually

00:27:36,580 --> 00:27:40,350
write something like that yourself or we

00:27:38,650 --> 00:27:42,880
have SBT integration

00:27:40,350 --> 00:27:46,539
don't ask me why we need to provide two

00:27:42,880 --> 00:27:48,010
arguments that's just a weird what's

00:27:46,539 --> 00:27:51,160
interesting is the output of the script

00:27:48,010 --> 00:27:53,280
that will provide anyway let's go

00:27:51,160 --> 00:27:55,900
through the printout section by section

00:27:53,280 --> 00:27:58,870
well first of all we see that this

00:27:55,900 --> 00:28:00,429
particular file it was generated from

00:27:58,870 --> 00:28:03,580
libraries of Scala which is pretty

00:28:00,429 --> 00:28:06,070
expected and then it has something

00:28:03,580 --> 00:28:07,840
called the dialect so in scala meta we

00:28:06,070 --> 00:28:10,120
use dialects to signify compiler

00:28:07,840 --> 00:28:12,159
versions so that we know the difference

00:28:10,120 --> 00:28:13,630
well because different compiler versions

00:28:12,159 --> 00:28:15,850
have different semantics so this is

00:28:13,630 --> 00:28:18,490
definitely useful and here we compiled

00:28:15,850 --> 00:28:20,200
everything with Scala 211 because that's

00:28:18,490 --> 00:28:22,809
what my script in this particular

00:28:20,200 --> 00:28:24,669
directory is using and now we get to

00:28:22,809 --> 00:28:27,909
something more interesting to the first

00:28:24,669 --> 00:28:29,620
section our code names and in this

00:28:27,909 --> 00:28:33,039
section for every identifier in the file

00:28:29,620 --> 00:28:34,750
so you can see calm example printer so

00:28:33,039 --> 00:28:36,640
on and so forth we have a unique

00:28:34,750 --> 00:28:39,070
identifier of the definition that it

00:28:36,640 --> 00:28:43,330
points to so for instance we know that a

00:28:39,070 --> 00:28:45,640
string is actually comes from PDF and we

00:28:43,330 --> 00:28:48,159
also know that print line is also a PDF

00:28:45,640 --> 00:28:52,059
method and so on and so forth so you may

00:28:48,159 --> 00:28:54,940
notice that methods have JVM signatures

00:28:52,059 --> 00:28:57,100
here and that's because this is how the

00:28:54,940 --> 00:28:59,559
Scala compiler internally distinguishes

00:28:57,100 --> 00:29:01,419
between overloads because multiple

00:28:59,559 --> 00:29:03,700
methods can have the same name you also

00:29:01,419 --> 00:29:06,880
need to provide signatures as a part of

00:29:03,700 --> 00:29:08,500
this unique ID and the well at one of

00:29:06,880 --> 00:29:10,299
the presentations someone asked what do

00:29:08,500 --> 00:29:14,380
these numbers mean so these numbers

00:29:10,299 --> 00:29:16,630
basically specify a range for a

00:29:14,380 --> 00:29:19,659
particular identifier so this class

00:29:16,630 --> 00:29:23,710
printer the printer thing it starts at

00:29:19,659 --> 00:29:26,169
the 27th character and it ends at 34 now

00:29:23,710 --> 00:29:28,900
that's a best fit section and now let's

00:29:26,169 --> 00:29:32,200
go to the notations let's make it a bit

00:29:28,900 --> 00:29:34,420
higher as I mentioned before the

00:29:32,200 --> 00:29:37,330
notations they provide signatures

00:29:34,420 --> 00:29:39,880
and flags basically information about

00:29:37,330 --> 00:29:41,860
definitions here for instance we can see

00:29:39,880 --> 00:29:43,810
the companion object example that we

00:29:41,860 --> 00:29:45,760
define on the line line in library

00:29:43,810 --> 00:29:48,850
that's color and since objects are

00:29:45,760 --> 00:29:51,160
implicitly final we see that well

00:29:48,850 --> 00:29:53,980
there's the final flag in the data

00:29:51,160 --> 00:29:56,350
schema and well what's cool about these

00:29:53,980 --> 00:29:58,480
annotations is that they know everything

00:29:56,350 --> 00:30:01,900
about the information that the scholar C

00:29:58,480 --> 00:30:03,610
itself has so for instance we even have

00:30:01,900 --> 00:30:05,350
been info about the primary constructor

00:30:03,610 --> 00:30:07,360
that has been generated for the class

00:30:05,350 --> 00:30:09,520
printer even though you don't write it

00:30:07,360 --> 00:30:11,170
explicitly Scala compiler still

00:30:09,520 --> 00:30:15,010
generates it and so it's useful to know

00:30:11,170 --> 00:30:18,430
about that all right now on to more

00:30:15,010 --> 00:30:19,840
features as I mentioned before semantic

00:30:18,430 --> 00:30:22,090
databases they can actually store

00:30:19,840 --> 00:30:26,950
compiler warnings and let's demonstrate

00:30:22,090 --> 00:30:30,780
this let's introduce an unused import in

00:30:26,950 --> 00:30:33,430
our program and then we will recompile

00:30:30,780 --> 00:30:40,180
recompile regenerate the semantic d-beam

00:30:33,430 --> 00:30:43,060
using the warn unused import flag it

00:30:40,180 --> 00:30:45,580
will take a little bit again and we will

00:30:43,060 --> 00:30:48,010
see the warning now if we inspect the

00:30:45,580 --> 00:30:50,080
semantic database is in this magic

00:30:48,010 --> 00:30:52,270
invocation that i provided before we

00:30:50,080 --> 00:30:56,050
will see that we have the messages

00:30:52,270 --> 00:30:59,200
section now which again provides a range

00:30:56,050 --> 00:31:02,320
position that is a start and an end for

00:30:59,200 --> 00:31:04,960
this particular warning and so warnings

00:31:02,320 --> 00:31:07,180
like so in this case and the arranged

00:31:04,960 --> 00:31:10,390
position will be pointing to this it

00:31:07,180 --> 00:31:12,130
goes from 34 to 38 and that quite neat

00:31:10,390 --> 00:31:14,110
because later we can exploit this

00:31:12,130 --> 00:31:16,420
information and different tools I'll

00:31:14,110 --> 00:31:16,840
talk I'll talk about this just a little

00:31:16,420 --> 00:31:18,490
later

00:31:16,840 --> 00:31:20,770
and finally it's something that I

00:31:18,490 --> 00:31:23,050
mentioned before as well so semantic DB

00:31:20,770 --> 00:31:28,200
support syntactic sugars that is

00:31:23,050 --> 00:31:31,510
implicit arguments for instance recently

00:31:28,200 --> 00:31:33,730
we had a great post blog post from the

00:31:31,510 --> 00:31:35,380
Scala Center on the scale Lang the

00:31:33,730 --> 00:31:37,840
torque which talked about the collection

00:31:35,380 --> 00:31:40,300
redesign and one of the points that was

00:31:37,840 --> 00:31:42,490
discussed there as we have this can

00:31:40,300 --> 00:31:44,740
build from thing in the current

00:31:42,490 --> 00:31:46,490
collections so some people consider it

00:31:44,740 --> 00:31:48,559
to be well critic

00:31:46,490 --> 00:31:50,420
and while there are ways to simplify the

00:31:48,559 --> 00:31:52,880
collection API in order to deal with

00:31:50,420 --> 00:31:56,030
this somehow so let's see how the

00:31:52,880 --> 00:31:58,370
semantics we can illustrate this let's

00:31:56,030 --> 00:32:01,360
start with a simple list just know one

00:31:58,370 --> 00:32:05,150
two three that map's the elements and

00:32:01,360 --> 00:32:09,559
basically adds a 1 to them again let's

00:32:05,150 --> 00:32:11,300
recompile the semantic database and both

00:32:09,559 --> 00:32:14,270
spoiler alert will get a new section

00:32:11,300 --> 00:32:17,000
that will show off this can build from

00:32:14,270 --> 00:32:19,340
thing we're going to read this magic dB

00:32:17,000 --> 00:32:20,240
and here we go this is the section

00:32:19,340 --> 00:32:23,420
called sugars

00:32:20,240 --> 00:32:25,390
syntactic sugars that actually sells

00:32:23,420 --> 00:32:29,780
quite a lot about the original problem

00:32:25,390 --> 00:32:32,179
let me try to put let me try to show you

00:32:29,780 --> 00:32:34,250
the original code as well ok here we go

00:32:32,179 --> 00:32:36,770
so we have this list 1 2 3 that does the

00:32:34,250 --> 00:32:38,690
map and we see the bunch of information

00:32:36,770 --> 00:32:41,559
that has has been inferred about the

00:32:38,690 --> 00:32:44,480
program well first of all as an offset

00:32:41,559 --> 00:32:46,700
105 which is basically after they

00:32:44,480 --> 00:32:48,679
identified list we see that the Scala

00:32:46,700 --> 00:32:51,470
compiler has entered in as a type

00:32:48,679 --> 00:32:53,720
argument I will also see that that one

00:32:51,470 --> 00:32:55,880
one eight which is after map scholar

00:32:53,720 --> 00:33:00,200
compiler has inferred two type arguments

00:32:55,880 --> 00:33:02,120
int and any whatever that is and finally

00:33:00,200 --> 00:33:05,090
there is an implicit argument in play

00:33:02,120 --> 00:33:08,240
called can build from so what's that

00:33:05,090 --> 00:33:12,679
let's just take a really quick look at

00:33:08,240 --> 00:33:16,240
the definition of list of Scala and we

00:33:12,679 --> 00:33:19,070
will see about this you know famous

00:33:16,240 --> 00:33:21,679
signature for map which actually not

00:33:19,070 --> 00:33:24,080
only takes the e function but it also

00:33:21,679 --> 00:33:26,120
takes an implicit parameter that does

00:33:24,080 --> 00:33:29,480
something so I won't be going into

00:33:26,120 --> 00:33:31,490
details of how this mechanism works you

00:33:29,480 --> 00:33:33,860
can take a look at the blog post at Sky

00:33:31,490 --> 00:33:35,929
Lang the tour but basically what's cool

00:33:33,860 --> 00:33:38,480
about the semantic TB is that it knows

00:33:35,929 --> 00:33:40,190
all these things about your code base

00:33:38,480 --> 00:33:43,250
because that's what color she knows and

00:33:40,190 --> 00:33:46,610
then it exposes this information in a

00:33:43,250 --> 00:33:49,910
way that's accessible to tools ok now

00:33:46,610 --> 00:33:51,350
back to the slides even though these

00:33:49,910 --> 00:33:52,850
matic the big technology that only

00:33:51,350 --> 00:33:53,660
exists for a couple months it already

00:33:52,850 --> 00:33:57,230
has

00:33:53,660 --> 00:33:58,370
and what we found out is that the really

00:33:57,230 --> 00:34:01,940
stupid data schema

00:33:58,370 --> 00:34:03,680
it makes things hackable so previously

00:34:01,940 --> 00:34:05,840
when we just started this car reflect I

00:34:03,680 --> 00:34:07,280
remember people needed a lot of guidance

00:34:05,840 --> 00:34:08,899
well because scholar reflect was

00:34:07,280 --> 00:34:11,540
basically an API into kind of compiler

00:34:08,899 --> 00:34:14,419
internals but now with semantic dbe's

00:34:11,540 --> 00:34:16,550
it's much easier I saw people who hacked

00:34:14,419 --> 00:34:19,490
up some stuff by themselves just you

00:34:16,550 --> 00:34:21,620
know partially semantic VB files when

00:34:19,490 --> 00:34:23,990
there still were text and then coming

00:34:21,620 --> 00:34:27,169
together and Talon as well look we did

00:34:23,990 --> 00:34:28,940
some stuff and people did some really

00:34:27,169 --> 00:34:31,100
really creative things but that didn't

00:34:28,940 --> 00:34:33,290
matter because they they could get their

00:34:31,100 --> 00:34:35,990
job done which I find to be pretty

00:34:33,290 --> 00:34:38,149
impressive so I think we will start the

00:34:35,990 --> 00:34:39,800
very good balance between simplicity and

00:34:38,149 --> 00:34:41,620
comprehensiveness and we're really

00:34:39,800 --> 00:34:44,629
looking forward to explore this further

00:34:41,620 --> 00:34:47,450
one super quick example they still want

00:34:44,629 --> 00:34:51,500
to show before given the stage back to

00:34:47,450 --> 00:34:53,780
stew is Scala 6 so Scot fix of the tool

00:34:51,500 --> 00:34:56,600
was developed by Olaf from the Scala

00:34:53,780 --> 00:35:00,080
Center in order to do code migrations

00:34:56,600 --> 00:35:06,080
and this is this has been a very

00:35:00,080 --> 00:35:10,280
prolific collaboration oh actually thank

00:35:06,080 --> 00:35:11,690
you all let's do that and so what what

00:35:10,280 --> 00:35:14,390
all efficient needed just several days

00:35:11,690 --> 00:35:17,030
ago at escala six is the capability to

00:35:14,390 --> 00:35:18,290
remove unused imports so actually if you

00:35:17,030 --> 00:35:21,620
compile your code base would be

00:35:18,290 --> 00:35:23,870
semantically be enabled then you can go

00:35:21,620 --> 00:35:25,340
ahead and launch Scala 6 which within a

00:35:23,870 --> 00:35:26,930
couple of seconds because it doesn't

00:35:25,340 --> 00:35:28,370
have to be compiler code base it just

00:35:26,930 --> 00:35:31,280
has to read the influence semantic

00:35:28,370 --> 00:35:32,940
databases it can produce this like this

00:35:31,280 --> 00:35:36,140
so the system works

00:35:32,940 --> 00:35:38,839
as opposed to yesterday so it does and

00:35:36,140 --> 00:35:46,530
actually you can see super super light

00:35:38,839 --> 00:35:48,980
automatically maybe like quite awesome

00:35:46,530 --> 00:35:51,720
and you have loads of lots of stuff

00:35:48,980 --> 00:35:54,210
basically for every import the disk our

00:35:51,720 --> 00:35:55,890
compiler reports as unused and the Scala

00:35:54,210 --> 00:35:57,270
compiler has the ultimate knowledge here

00:35:55,890 --> 00:35:59,819
because it knows everything about their

00:35:57,270 --> 00:36:02,280
programs we then store this information

00:35:59,819 --> 00:36:04,589
in semantically B's and then Scala fix

00:36:02,280 --> 00:36:07,260
can use it to remove the imported around

00:36:04,589 --> 00:36:09,599
you that's pretty neat and what I find

00:36:07,260 --> 00:36:12,240
personally very impressive about this

00:36:09,599 --> 00:36:14,369
transformation is that it looks like as

00:36:12,240 --> 00:36:17,250
if the human did that so we don't

00:36:14,369 --> 00:36:19,200
reformat anything we don't introduce you

00:36:17,250 --> 00:36:22,349
know extraneous indentation or stuff

00:36:19,200 --> 00:36:25,260
like this looks very good and I can use

00:36:22,349 --> 00:36:26,670
it from them yes and Su can use it from

00:36:25,260 --> 00:36:36,660
view how cool is this

00:36:26,670 --> 00:36:40,339
well thanks oh ok it's too please ok

00:36:36,660 --> 00:36:43,740
yeah so the next set of this vision is

00:36:40,339 --> 00:36:45,839
being able to do this at scale outside

00:36:43,740 --> 00:36:47,280
of an IDE in particular

00:36:45,839 --> 00:36:50,790
we would like this to be language

00:36:47,280 --> 00:36:53,400
agnostic and as Eugene mentioned like

00:36:50,790 --> 00:36:56,190
the Scala meta is a very very powerful

00:36:53,400 --> 00:36:58,440
API for for Scala and has a very simple

00:36:56,190 --> 00:36:59,430
schema and that's very beneficial I'm

00:36:58,440 --> 00:37:02,839
going to talk about something that has a

00:36:59,430 --> 00:37:06,440
much more complicated schema for reasons

00:37:02,839 --> 00:37:09,569
tights' tights' is a Google project

00:37:06,440 --> 00:37:13,579
google open source project it came out

00:37:09,569 --> 00:37:13,579
of their internal code search tool grok

00:37:13,609 --> 00:37:19,050
what is it it's a common interchange and

00:37:17,190 --> 00:37:21,270
schema for semantic information about

00:37:19,050 --> 00:37:24,450
code in particular it's a schema for a

00:37:21,270 --> 00:37:26,160
semantic graph it contains all kinds of

00:37:24,450 --> 00:37:28,470
things like symbol definitions and

00:37:26,160 --> 00:37:31,890
references call graph it can represent a

00:37:28,470 --> 00:37:34,050
call graph it can represent inheritance

00:37:31,890 --> 00:37:37,609
relationships generic templated type

00:37:34,050 --> 00:37:39,990
information for multiple languages and

00:37:37,609 --> 00:37:42,990
in particular it's a scalable semantic

00:37:39,990 --> 00:37:44,490
index graph how many different types of

00:37:42,990 --> 00:37:46,730
relationships like how different is it

00:37:44,490 --> 00:37:49,220
some scala meta schema wise it's pretty

00:37:46,730 --> 00:37:52,160
different it has a lot of different so

00:37:49,220 --> 00:37:54,580
this is the concatenation of edge types

00:37:52,160 --> 00:37:59,090
and node types in this semantic graph

00:37:54,580 --> 00:38:00,890
and it continues so yeah it's a schema

00:37:59,090 --> 00:38:04,400
for de Graaff and then that graph is

00:38:00,890 --> 00:38:07,130
going to store information about code it

00:38:04,400 --> 00:38:08,810
is and then the graphs is also there for

00:38:07,130 --> 00:38:10,180
an index by a whole bunch of different

00:38:08,810 --> 00:38:13,369
properties that you might want to

00:38:10,180 --> 00:38:15,290
examine about your code these

00:38:13,369 --> 00:38:18,770
visualizations were dumped out of the

00:38:15,290 --> 00:38:21,200
open source case schema format by a

00:38:18,770 --> 00:38:23,150
visualization that send you rough

00:38:21,200 --> 00:38:25,730
Weinberger I worked on and I'll talk

00:38:23,150 --> 00:38:27,410
about that later so the value

00:38:25,730 --> 00:38:28,730
proposition of kite in particular is

00:38:27,410 --> 00:38:34,369
that you get this hub-and-spoke model

00:38:28,730 --> 00:38:37,750
where you write a tool once that can

00:38:34,369 --> 00:38:40,520
then work across multiple languages

00:38:37,750 --> 00:38:43,490
additionally you write a compiler

00:38:40,520 --> 00:38:48,220
integration or in our case a scala meta

00:38:43,490 --> 00:38:50,710
integration to to analyze code and

00:38:48,220 --> 00:38:53,900
import it to a kite schema

00:38:50,710 --> 00:38:56,240
multi-language multi-platform part of

00:38:53,900 --> 00:38:59,720
that hub they're there in progress

00:38:56,240 --> 00:39:01,280
implementations for for Scala in fact

00:38:59,720 --> 00:39:05,330
we'll talk about that in a second

00:39:01,280 --> 00:39:06,950
supports very large graphs the index for

00:39:05,330 --> 00:39:08,750
the chromium repo is stood about 50

00:39:06,950 --> 00:39:12,260
gigabytes which is totally totally

00:39:08,750 --> 00:39:13,670
manageable on one machine even and from

00:39:12,260 --> 00:39:15,369
Twitter's perspective we immediately

00:39:13,670 --> 00:39:17,840
have multi-language support as a goal

00:39:15,369 --> 00:39:18,950
because Java and Scala run this the same

00:39:17,840 --> 00:39:23,090
platform

00:39:18,950 --> 00:39:24,859
moreover 15 protobuf are sort of on that

00:39:23,090 --> 00:39:26,630
same platform right you'd want you'd

00:39:24,859 --> 00:39:29,140
want to be able to not look at the

00:39:26,630 --> 00:39:33,640
generated code

00:39:29,140 --> 00:39:35,690
when when you jump to a definition right

00:39:33,640 --> 00:39:38,359
the generated code is not that

00:39:35,690 --> 00:39:40,700
interesting there's plenty of it and it

00:39:38,359 --> 00:39:43,580
all looks the thing so the language

00:39:40,700 --> 00:39:45,200
agnostic tooling question mark can we

00:39:43,580 --> 00:39:49,700
actually achieve language agnostic

00:39:45,200 --> 00:39:51,770
tooling do things like like the the

00:39:49,700 --> 00:39:53,570
types of rewrites that Olaf is mentioned

00:39:51,770 --> 00:39:56,540
across all the languages that you

00:39:53,570 --> 00:39:58,369
support who knows but to start with

00:39:56,540 --> 00:40:00,260
there are some things included out of

00:39:58,369 --> 00:40:02,390
the box there is

00:40:00,260 --> 00:40:06,080
there's a simple server to host all this

00:40:02,390 --> 00:40:09,050
information and an API you can execute

00:40:06,080 --> 00:40:12,440
complex graph queries with various graph

00:40:09,050 --> 00:40:14,210
databases it has a pretty simple but

00:40:12,440 --> 00:40:16,640
powerful CLI tool

00:40:14,210 --> 00:40:20,510
it supports import and export as triples

00:40:16,640 --> 00:40:23,750
quads and C tags so export FC tags it's

00:40:20,510 --> 00:40:25,970
definitely useful immediately they have

00:40:23,750 --> 00:40:29,390
out-of-the-box call graph analyses so

00:40:25,970 --> 00:40:31,370
you can kind of see which which code

00:40:29,390 --> 00:40:35,630
pads are entering into a particular

00:40:31,370 --> 00:40:37,040
method and has a toy code browser UI so

00:40:35,630 --> 00:40:38,990
things that might be possible maybe you

00:40:37,040 --> 00:40:40,580
could do a generic documentation browser

00:40:38,990 --> 00:40:41,900
and then you don't need both Java doc

00:40:40,580 --> 00:40:45,320
and Scala doc you have a generic

00:40:41,900 --> 00:40:47,270
documentation browser cool you could do

00:40:45,320 --> 00:40:50,090
coded analytics to determine how many

00:40:47,270 --> 00:40:53,720
many different call pads reach a

00:40:50,090 --> 00:40:56,480
particular call site or sorry particular

00:40:53,720 --> 00:40:58,040
method in theory you could maybe do

00:40:56,480 --> 00:40:59,710
completely generic incremental

00:40:58,040 --> 00:41:03,800
compilation that would be amazing

00:40:59,710 --> 00:41:05,720
and you also in theory could do dead

00:41:03,800 --> 00:41:07,280
code elimination so something's

00:41:05,720 --> 00:41:08,800
completely not reachable from any of

00:41:07,280 --> 00:41:11,080
those routes I mentioned before and

00:41:08,800 --> 00:41:14,570
therefore it's dead we would love that

00:41:11,080 --> 00:41:16,970
so we've been working on adding Scala

00:41:14,570 --> 00:41:19,780
support to kite it is the most

00:41:16,970 --> 00:41:22,520
functional of the supported languages

00:41:19,780 --> 00:41:25,490
but it's similarly abstraction rich to

00:41:22,520 --> 00:41:28,730
C++ which was their first language which

00:41:25,490 --> 00:41:30,440
also supports higher kinda types one

00:41:28,730 --> 00:41:35,300
difference though this will be the first

00:41:30,440 --> 00:41:37,550
the first multi multiple languages on

00:41:35,300 --> 00:41:39,620
the same platform example within within

00:41:37,550 --> 00:41:41,750
pipe because they haven't actually done

00:41:39,620 --> 00:41:43,220
things like although they support go and

00:41:41,750 --> 00:41:46,910
they support C++ they haven't supported

00:41:43,220 --> 00:41:52,220
cross referencing from go to C++ for

00:41:46,910 --> 00:41:55,190
example we've started this then use that

00:41:52,220 --> 00:41:58,220
same example that Eugene had and I'm

00:41:55,190 --> 00:42:02,060
going to walk through what putting it in

00:41:58,220 --> 00:42:04,430
pike looks like using the scala host

00:42:02,060 --> 00:42:07,160
compiler plug-in which your build tool

00:42:04,430 --> 00:42:09,950
will definitely just plug in for you you

00:42:07,160 --> 00:42:13,820
will build some code you'll use our tool

00:42:09,950 --> 00:42:16,550
to emit type entries

00:42:13,820 --> 00:42:18,350
which are essentially those quads are

00:42:16,550 --> 00:42:22,880
there essentially quads edges in the

00:42:18,350 --> 00:42:24,860
graph the result is a graph again so

00:42:22,880 --> 00:42:28,670
let's walk through an example of what is

00:42:24,860 --> 00:42:31,970
in that graph we're saying we're going

00:42:28,670 --> 00:42:35,540
to be going counterclockwise from from

00:42:31,970 --> 00:42:39,290
the right hand side here so a function

00:42:35,540 --> 00:42:42,260
is a child of a class kite edge child of

00:42:39,290 --> 00:42:46,780
is the type of the edge and it points to

00:42:42,260 --> 00:42:51,140
a record sub x class okay that's a class

00:42:46,780 --> 00:42:54,230
and that class as a function the type of

00:42:51,140 --> 00:42:57,250
the function is kind function has this

00:42:54,230 --> 00:42:59,690
long signature that Eugene demonstrated

00:42:57,250 --> 00:43:03,110
something called that function okay so

00:42:59,690 --> 00:43:08,060
it's a kite edge rest call the color of

00:43:03,110 --> 00:43:10,580
the function is an anchor so it's a

00:43:08,060 --> 00:43:12,020
particular position in the code see this

00:43:10,580 --> 00:43:15,070
is enough to actually get at a call

00:43:12,020 --> 00:43:18,590
graph right by saying that this this

00:43:15,070 --> 00:43:22,490
this anchor is a child of some other

00:43:18,590 --> 00:43:24,590
function so it is possible for this this

00:43:22,490 --> 00:43:29,450
function to call that function at this

00:43:24,590 --> 00:43:31,490
position that function now taking

00:43:29,450 --> 00:43:32,900
walking off of that call graph and just

00:43:31,490 --> 00:43:36,080
down a different path in the semantic

00:43:32,900 --> 00:43:40,700
graph so a lot of serendipity in

00:43:36,080 --> 00:43:44,660
semantic graphs has a parameter named

00:43:40,700 --> 00:43:48,800
args it is the zeroth parameter of the

00:43:44,660 --> 00:43:52,400
function parameters are variables there

00:43:48,800 --> 00:43:55,310
they have a sub kind of local and it has

00:43:52,400 --> 00:43:58,850
a unique unique name again straight of

00:43:55,310 --> 00:44:02,750
the semantic DV the type of that

00:43:58,850 --> 00:44:08,780
parameter is a type application type

00:44:02,750 --> 00:44:12,140
edge type tap of two parameters array

00:44:08,780 --> 00:44:14,770
and strength built-ins cool and so you

00:44:12,140 --> 00:44:17,690
apply that and you get array string meat

00:44:14,770 --> 00:44:19,070
it's a lot of information this is really

00:44:17,690 --> 00:44:22,400
just the start of what's possible here

00:44:19,070 --> 00:44:25,370
so we we implemented Scala meta kites it

00:44:22,400 --> 00:44:26,480
uses the Scala meta API to emit type

00:44:25,370 --> 00:44:29,900
entries

00:44:26,480 --> 00:44:32,140
and it will be open-source soon but yeah

00:44:29,900 --> 00:44:35,599
it uses this column at a mirror API

00:44:32,140 --> 00:44:37,880
which is very easy to use walks through

00:44:35,599 --> 00:44:39,200
the Scala meta ast and consumes the

00:44:37,880 --> 00:44:43,480
symbols and denotations that you

00:44:39,200 --> 00:44:46,359
mentioned too in that Skype entries and

00:44:43,480 --> 00:44:48,740
there's a lot more work to do so

00:44:46,359 --> 00:44:51,020
obviously we're going to integrate types

00:44:48,740 --> 00:44:54,260
of pants there is already some direct

00:44:51,020 --> 00:44:56,900
support for for indexing Java code using

00:44:54,260 --> 00:44:59,300
pants into case thanks again to Benji

00:44:56,900 --> 00:45:00,349
Weinberger for that part but we imagine

00:44:59,300 --> 00:45:05,540
a whole bunch of other other

00:45:00,349 --> 00:45:08,570
integrations in particular well making

00:45:05,540 --> 00:45:11,089
indexing super trivial directly from the

00:45:08,570 --> 00:45:13,310
build tool so in your CI you could

00:45:11,089 --> 00:45:15,140
imagine running pants to hit a

00:45:13,310 --> 00:45:17,599
particular type API server populate

00:45:15,140 --> 00:45:20,359
populate that kite API server with some

00:45:17,599 --> 00:45:22,490
the latest build or send it to

00:45:20,359 --> 00:45:25,040
distributed file system to aggregate or

00:45:22,490 --> 00:45:27,800
who knows but also interesting is maybe

00:45:25,040 --> 00:45:30,520
you could run a chi-square e and then

00:45:27,800 --> 00:45:34,069
Scala fix anything that matched it

00:45:30,520 --> 00:45:36,740
because assess the Scala fixes even with

00:45:34,069 --> 00:45:38,390
native it would would take a non-trivial

00:45:36,740 --> 00:45:41,510
amount of time to run on the entire code

00:45:38,390 --> 00:45:46,040
base pour on the entire Scala community

00:45:41,510 --> 00:45:51,380
build so first filter out to what to the

00:45:46,040 --> 00:45:53,000
relevant bits and then execute so kite

00:45:51,380 --> 00:45:56,500
is going to be interesting just because

00:45:53,000 --> 00:46:01,460
it's this massively complicated thing

00:45:56,500 --> 00:46:03,109
and it's very general and so while a lot

00:46:01,460 --> 00:46:04,880
of tooling is going to be is just

00:46:03,109 --> 00:46:06,290
immediately possible I can I can tell

00:46:04,880 --> 00:46:08,780
you that the documentation browser will

00:46:06,290 --> 00:46:11,569
absolutely be possible call graph

00:46:08,780 --> 00:46:14,930
analysis should should just be possible

00:46:11,569 --> 00:46:17,089
things like rewrites are probably going

00:46:14,930 --> 00:46:20,270
to require all the knowledge that Scala

00:46:17,089 --> 00:46:24,230
Mehta has at any given point in time to

00:46:20,270 --> 00:46:26,359
to execute and and so there will always

00:46:24,230 --> 00:46:29,030
be room for more language specific tools

00:46:26,359 --> 00:46:30,740
but I think if we can push further in

00:46:29,030 --> 00:46:33,740
that direction of generic tooling it

00:46:30,740 --> 00:46:38,240
will be a very interesting frontier so

00:46:33,740 --> 00:46:39,740
you James okay I think soup that was

00:46:38,240 --> 00:46:42,680
very exciting

00:46:39,740 --> 00:46:45,590
now to sum it up what we heard and what

00:46:42,680 --> 00:46:47,570
we talked about today we think that it

00:46:45,590 --> 00:46:49,910
is possible to have a principle

00:46:47,570 --> 00:46:52,130
foundations for semantic dueling that

00:46:49,910 --> 00:46:54,260
everyone in the community could use we

00:46:52,130 --> 00:46:56,240
developed this in the open and we're

00:46:54,260 --> 00:46:58,460
confident that these formations will

00:46:56,240 --> 00:46:59,330
enable new things that haven't been

00:46:58,460 --> 00:47:02,570
possible before

00:46:59,330 --> 00:47:05,120
at least outside the IDE it would be

00:47:02,570 --> 00:47:07,190
able to understand code better to do

00:47:05,120 --> 00:47:11,060
better code reviews and to evolve your

00:47:07,190 --> 00:47:13,850
code bases we propose that we use a

00:47:11,060 --> 00:47:15,500
scalar meta and the semantics DB to

00:47:13,850 --> 00:47:18,260
extract information from the Scala

00:47:15,500 --> 00:47:20,780
compiler and then to index this

00:47:18,260 --> 00:47:23,600
information potentially using kite it

00:47:20,780 --> 00:47:26,480
shows really a lot of promise and then

00:47:23,600 --> 00:47:28,760
finally to integrate with tools that is

00:47:26,480 --> 00:47:32,390
on top of either schema in order to

00:47:28,760 --> 00:47:34,250
deliver scalable solutions at the moment

00:47:32,390 --> 00:47:36,440
we have a drugs back for semantically

00:47:34,250 --> 00:47:38,960
B's well I mentioned the protobuf schema

00:47:36,440 --> 00:47:41,000
right and we also have a technology

00:47:38,960 --> 00:47:42,920
preview of the compiler plugin as part

00:47:41,000 --> 00:47:45,770
of the Scala meta 1.8 release that

00:47:42,920 --> 00:47:47,390
produces semantic DBS and all the

00:47:45,770 --> 00:47:49,250
technology preview it's not just a

00:47:47,390 --> 00:47:51,920
prototype because it's been out there

00:47:49,250 --> 00:47:55,790
for a couple months and it's also used

00:47:51,920 --> 00:47:58,370
in Scala fix so it successfully compels

00:47:55,790 --> 00:47:59,990
the scala community build for one

00:47:58,370 --> 00:48:02,960
something that all of experimented with

00:47:59,990 --> 00:48:06,410
recently it supports the two major scale

00:48:02,960 --> 00:48:09,050
versions 211 and 212 and there is an

00:48:06,410 --> 00:48:13,300
ongoing support project to support Dali

00:48:09,050 --> 00:48:17,960
to convert tasty format into semantic DB

00:48:13,300 --> 00:48:19,870
also to hack the implementation

00:48:17,960 --> 00:48:23,210
integration for Scala Matt and pipe and

00:48:19,870 --> 00:48:25,700
as two mentioned this is hopefully going

00:48:23,210 --> 00:48:27,980
to be open source soon all right

00:48:25,700 --> 00:48:30,440
briefly going through this he should

00:48:27,980 --> 00:48:31,730
work first of all we have our own code

00:48:30,440 --> 00:48:32,260
search something that we mentioned

00:48:31,730 --> 00:48:34,940
before

00:48:32,260 --> 00:48:37,010
better than grab faster than grab and

00:48:34,940 --> 00:48:40,550
would be nice to enrich it with a

00:48:37,010 --> 00:48:42,170
semantic info also for code reviews we

00:48:40,550 --> 00:48:44,420
use fabricator internally it would be

00:48:42,170 --> 00:48:47,060
great to get this hooked up because the

00:48:44,420 --> 00:48:48,920
C tags are quite easy to produce also

00:48:47,060 --> 00:48:50,480
the collaboration with scar fix has been

00:48:48,920 --> 00:48:51,320
really promising and we definitely need

00:48:50,480 --> 00:48:53,420
the

00:48:51,320 --> 00:48:55,820
do more of that to support more rewrites

00:48:53,420 --> 00:48:58,310
because we can immediately see how this

00:48:55,820 --> 00:49:00,530
is useful for us and also for the entire

00:48:58,310 --> 00:49:02,810
community of course because Scala fix is

00:49:00,530 --> 00:49:05,990
also open source thanks to the work of

00:49:02,810 --> 00:49:09,200
Scala Center also v2 promising

00:49:05,990 --> 00:49:11,690
technologies tasty this is the

00:49:09,200 --> 00:49:14,180
interchange format in Dadi

00:49:11,690 --> 00:49:17,090
where they save the epileptic syntax

00:49:14,180 --> 00:49:20,510
trees to disk basically an improved

00:49:17,090 --> 00:49:22,730
version a more fat version of the

00:49:20,510 --> 00:49:25,070
semantic DB so at the moment tasty is

00:49:22,730 --> 00:49:27,290
not supported by Scala C so that there's

00:49:25,070 --> 00:49:30,230
going to be well there may be an ongoing

00:49:27,290 --> 00:49:32,570
project together with live band I

00:49:30,230 --> 00:49:35,600
presume the support tasting Scala see

00:49:32,570 --> 00:49:37,430
but until it's there we'll be able to

00:49:35,600 --> 00:49:40,370
use a semantic DB to achieve similar

00:49:37,430 --> 00:49:42,140
things and finally as to mentioned

00:49:40,370 --> 00:49:45,560
source graph and the language server

00:49:42,140 --> 00:49:47,360
protocol there's some promise there all

00:49:45,560 --> 00:49:50,690
right and I would like to wrap up our

00:49:47,360 --> 00:49:52,820
talk and I would like to thank all of we

00:49:50,690 --> 00:49:54,880
mentioned the human the his creation a

00:49:52,820 --> 00:49:57,680
couple of times so Scala fix is awesome

00:49:54,880 --> 00:50:00,050
it was really cool to battle Testament

00:49:57,680 --> 00:50:02,630
agree be to make sure it works well I

00:50:00,050 --> 00:50:06,290
would also like to thank thinking from

00:50:02,630 --> 00:50:08,990
the from epfl from Martin blood who

00:50:06,290 --> 00:50:12,680
works on integration between dodgy and

00:50:08,990 --> 00:50:15,920
Scala fix also as I mentioned Benjie

00:50:12,680 --> 00:50:18,070
Weinberger basically had talked about

00:50:15,920 --> 00:50:22,190
his pet project for going on two years

00:50:18,070 --> 00:50:25,220
which was essentially indexing all of

00:50:22,190 --> 00:50:28,070
Mahlon center with with kite so very

00:50:25,220 --> 00:50:30,710
interesting potential project knew a lot

00:50:28,070 --> 00:50:32,540
about it finally clicked for us we also

00:50:30,710 --> 00:50:33,950
like to thank everyone else who's worked

00:50:32,540 --> 00:50:38,390
on any of the open source projects that

00:50:33,950 --> 00:50:40,610
are involved here thank you thank you

00:50:38,390 --> 00:50:42,560
quick pitch Twitter is definitely hiring

00:50:40,610 --> 00:50:44,930
we are one of the largest scholarships

00:50:42,560 --> 00:50:47,330
in the world we're doing what we think

00:50:44,930 --> 00:50:48,830
is pretty exciting research here and

00:50:47,330 --> 00:50:51,320
implementation

00:50:48,830 --> 00:50:55,700
the build team in particular is where

00:50:51,320 --> 00:50:58,550
both of us reside I'm about 25% on this

00:50:55,700 --> 00:51:01,220
project I hope to be back on it fairly

00:50:58,550 --> 00:51:03,420
soon because we're currently working on

00:51:01,220 --> 00:51:06,540
distributed compilation and testing

00:51:03,420 --> 00:51:09,240
lots of code lots of code is flowing

00:51:06,540 --> 00:51:11,120
around a Twitter we are to do about the

00:51:09,240 --> 00:51:13,560
minimum amount of building that we can

00:51:11,120 --> 00:51:15,690
so now it's time to start distributing

00:51:13,560 --> 00:51:18,720
that and executing it in parallel on

00:51:15,690 --> 00:51:20,700
clusters semantic indexing IDE

00:51:18,720 --> 00:51:24,350
integration we do a lot more than just

00:51:20,700 --> 00:51:27,990
build wrangling so exciting stuff to do

00:51:24,350 --> 00:51:30,210
does anyone have any questions so I just

00:51:27,990 --> 00:51:31,650
wanted to go right back to the moderator

00:51:30,210 --> 00:51:32,790
stuff at the beginning one of these one

00:51:31,650 --> 00:51:36,170
of the exciting things about mana

00:51:32,790 --> 00:51:38,640
reposes obviously that you can update

00:51:36,170 --> 00:51:41,250
multiple maked logically independent

00:51:38,640 --> 00:51:44,550
projects atomically you can also branch

00:51:41,250 --> 00:51:47,220
things kind of atomically i guess my

00:51:44,550 --> 00:51:51,660
question is have you experimented with

00:51:47,220 --> 00:51:56,000
or have you considered including the

00:51:51,660 --> 00:52:00,240
Scala compiler and library in that mix

00:51:56,000 --> 00:52:04,410
have we considered building the Scala

00:52:00,240 --> 00:52:06,330
compiler in our repo so including giddy

00:52:04,410 --> 00:52:08,670
at the entire universe yes but you get

00:52:06,330 --> 00:52:10,320
you might fall come yeah I can say that

00:52:08,670 --> 00:52:14,550
there's prior art we have not considered

00:52:10,320 --> 00:52:17,040
that if we see a Jew CNF project that

00:52:14,550 --> 00:52:21,510
that could definitely be a good thing to

00:52:17,040 --> 00:52:24,090
do yeah there's prior art Google

00:52:21,510 --> 00:52:25,770
essentially import everything as source

00:52:24,090 --> 00:52:26,970
you know if they see an open source

00:52:25,770 --> 00:52:30,270
project they embroidered and then have

00:52:26,970 --> 00:52:32,990
some some sync process so not to do too

00:52:30,270 --> 00:52:35,040
much a Google that is bound to work

00:52:32,990 --> 00:52:39,570
because we have enough of that in the

00:52:35,040 --> 00:52:40,980
talk there is there's prior art and that

00:52:39,570 --> 00:52:45,170
would certainly allow you to iterate

00:52:40,980 --> 00:52:47,610
very quickly on on compiler updates and

00:52:45,170 --> 00:52:50,430
sandbox with against everything the unit

00:52:47,610 --> 00:52:52,260
tests past merge it so and while the mic

00:52:50,430 --> 00:52:55,170
is traveling I can just say you know

00:52:52,260 --> 00:52:57,270
we're still in a situation where we can

00:52:55,170 --> 00:53:00,360
pump the Scala version with you know one

00:52:57,270 --> 00:53:02,790
line change in our repo for going on

00:53:00,360 --> 00:53:06,570
going on 10 million lines of Scala code

00:53:02,790 --> 00:53:09,480
so it's we have the community build in

00:53:06,570 --> 00:53:12,059
terms of as well hello

00:53:09,480 --> 00:53:20,549
so question to Eugene

00:53:12,059 --> 00:53:22,890
90 DB yes so what about the thing that

00:53:20,549 --> 00:53:25,589
the recursive in places I think are like

00:53:22,890 --> 00:53:31,890
in an example you shown that as a part

00:53:25,589 --> 00:53:35,430
of kala C compilers by using the same 90

00:53:31,890 --> 00:53:39,239
DB flag you actually generate this as a

00:53:35,430 --> 00:53:42,299
multi PB that's a very file and here's

00:53:39,239 --> 00:53:45,239
like can do from implicit what is this

00:53:42,299 --> 00:53:48,420
implicit will be dependent on another

00:53:45,239 --> 00:53:52,469
implicit or recursive in places just

00:53:48,420 --> 00:53:53,729
like shapely love to do alright add it's

00:53:52,469 --> 00:53:55,920
a great question

00:53:53,729 --> 00:53:57,869
in particular support for sugar sets

00:53:55,920 --> 00:54:01,049
have been just added in the recent

00:53:57,869 --> 00:54:02,819
treaties and we're experimenting with

00:54:01,049 --> 00:54:04,979
the approaches but basically at the

00:54:02,819 --> 00:54:06,839
moment you will see the fully expanded

00:54:04,979 --> 00:54:09,539
code so if you have a multiple implicit

00:54:06,839 --> 00:54:11,069
lookup so if this can do from if it were

00:54:09,539 --> 00:54:13,499
to depend on other in places you would

00:54:11,069 --> 00:54:15,660
see everything in that line let's go to

00:54:13,499 --> 00:54:18,329
work and the second question what is the

00:54:15,660 --> 00:54:20,729
compilation fulfill would I still have

00:54:18,329 --> 00:54:22,380
this plane series though everything here

00:54:20,729 --> 00:54:25,739
all right

00:54:22,380 --> 00:54:28,559
also cool how do we deal with errors at

00:54:25,739 --> 00:54:30,569
the moment you will get some entity B's

00:54:28,559 --> 00:54:33,089
for all the files which have been

00:54:30,569 --> 00:54:35,369
compiled successfully at least that's

00:54:33,089 --> 00:54:37,410
the state of my prototype internally

00:54:35,369 --> 00:54:39,779
probably we shipped it in 180 so that

00:54:37,410 --> 00:54:41,939
doubles the idea but in principle we

00:54:39,779 --> 00:54:43,499
could do an even better job basically we

00:54:41,939 --> 00:54:45,660
really depend on Scala see and it's

00:54:43,499 --> 00:54:48,269
error hand in functionality so if for

00:54:45,660 --> 00:54:50,849
instance quality would be able to you

00:54:48,269 --> 00:54:52,349
know mark given trees well given code

00:54:50,849 --> 00:54:54,420
both fragments of your program that

00:54:52,349 --> 00:54:56,939
don't compile if it were to mark them

00:54:54,420 --> 00:54:59,579
somehow and then proceed compilation to

00:54:56,939 --> 00:55:01,109
so that it allows our compiler plugin to

00:54:59,579 --> 00:55:03,719
steal data - and complete information

00:55:01,109 --> 00:55:05,369
that would be awesome but at the moment

00:55:03,719 --> 00:55:07,289
to the best of my knowledge that's not

00:55:05,369 --> 00:55:09,719
possible it will be interesting to

00:55:07,289 --> 00:55:12,660
experiment thank you sir

00:55:09,719 --> 00:55:13,600
so you have like position numbers 1 & 5

00:55:12,660 --> 00:55:15,640
1 & 5

00:55:13,600 --> 00:55:19,540
like quite a number something like um

00:55:15,640 --> 00:55:21,910
multiple views alright so since it's a

00:55:19,540 --> 00:55:23,890
data schema we want to store as little

00:55:21,910 --> 00:55:26,710
information as possible in order to you

00:55:23,890 --> 00:55:28,440
know load it later on and these offsets

00:55:26,710 --> 00:55:31,120
they are necessary to unambiguously

00:55:28,440 --> 00:55:32,920
identify well given ranges in the

00:55:31,120 --> 00:55:34,540
program and then after we have them

00:55:32,920 --> 00:55:36,640
actually Scala method provides a richer

00:55:34,540 --> 00:55:38,620
API so after we load this thing into

00:55:36,640 --> 00:55:41,320
this column at the data model we can get

00:55:38,620 --> 00:55:45,880
lines line numbers columns and so on so

00:55:41,320 --> 00:55:49,330
forth whatever you really expect all

00:55:45,880 --> 00:55:52,060
right anything else you guys would like

00:55:49,330 --> 00:55:54,370
you know yeah I mean quickly as a

00:55:52,060 --> 00:55:57,580
consumer of the API I was consuming an

00:55:54,370 --> 00:56:00,340
AST walking through it and then able to

00:55:57,580 --> 00:56:02,980
refer to this information via methods on

00:56:00,340 --> 00:56:05,550
the ast that were implicitly added that

00:56:02,980 --> 00:56:07,900
kind of refer to additional information

00:56:05,550 --> 00:56:10,390
so the tree ends up annotated with a

00:56:07,900 --> 00:56:12,760
whole bunch of additional additional

00:56:10,390 --> 00:56:14,560
data on the parsed from this file you're

00:56:12,760 --> 00:56:16,090
not dealing you're generally not dealing

00:56:14,560 --> 00:56:18,160
with it in the flat format in fact it

00:56:16,090 --> 00:56:22,390
never really exists in the flat format

00:56:18,160 --> 00:56:24,970
aside from this demo app so quite simple

00:56:22,390 --> 00:56:27,970
question those lines are in the compiled

00:56:24,970 --> 00:56:30,880
file right it's like it doesn't refer to

00:56:27,970 --> 00:56:34,120
some source code file it's already Java

00:56:30,880 --> 00:56:35,440
C or like no this is in the source that

00:56:34,120 --> 00:56:37,510
those are so those are character

00:56:35,440 --> 00:56:40,600
positions in the input source file so if

00:56:37,510 --> 00:56:42,250
you take any one of those character

00:56:40,600 --> 00:56:45,460
ranges and just highlighted in the file

00:56:42,250 --> 00:56:46,690
you'll see that this is that that Siena

00:56:45,460 --> 00:56:48,550
vertex that's right so basically this

00:56:46,690 --> 00:56:51,220
refers to the original file text and

00:56:48,550 --> 00:56:53,320
this is something that the olefin I were

00:56:51,220 --> 00:56:55,570
going back and forth on whether to

00:56:53,320 --> 00:56:57,580
include the source code of the file into

00:56:55,570 --> 00:56:59,530
the semantic DP or not so we ended up

00:56:57,580 --> 00:57:01,540
including the sources so that you can

00:56:59,530 --> 00:57:03,700
unambiguously you know parse them and

00:57:01,540 --> 00:57:05,860
then apply the semantics intro so it's

00:57:03,700 --> 00:57:08,710
not a wine number but a simple position

00:57:05,860 --> 00:57:11,619
and yeah actually solve this 28 to 33

00:57:08,710 --> 00:57:15,160
here its 28th character too

00:57:11,619 --> 00:57:23,989
third not models Amaro

00:57:15,160 --> 00:57:23,989

YouTube URL: https://www.youtube.com/watch?v=4yqDFsdKciA


