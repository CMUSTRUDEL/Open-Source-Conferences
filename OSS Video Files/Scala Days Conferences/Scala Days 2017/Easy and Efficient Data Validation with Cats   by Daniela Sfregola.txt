Title: Easy and Efficient Data Validation with Cats   by Daniela Sfregola
Publication date: 2017-06-28
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Often when we create a client/server application, we need to validate the requests: can the user associated to the request perform this operation? Can they access or modify the data? Is the input well-formed?

When the data validation component in our application is not well designed, the code can quickly become not expressive enough and probably difficult to maintain. Business rules don't help, adding more and more requirements to add in our validation, making it more and more complex to clearly represent and maintain. At the same time when the validation fails, it should be fairly straight forward to understand why the request was rejected, so that actions can be taken accordingly.

This talk introduces Cats, a Scala library based on category theory, and some of its most interesting components for data validation. In particular we'll discuss some options to achieve efficient and expressive data validation. We will also argue that, compared to other options in the language, Cats is particularly suited for the task thanks to its easy-to-use data types and more approachable syntax. 

Throughout the talk, you will see numerous examples on how data validation can be achieved in a clean and robust way, and how we can easily integrate it in our code, without any specific knowledge of category theory.
Captions: 
	00:00:02,250 --> 00:00:07,980
are you enjoying the conference so far

00:00:04,380 --> 00:00:11,789
yes cool and now let's have fun even

00:00:07,980 --> 00:00:13,740
some more fun okay the thing is working

00:00:11,789 --> 00:00:18,350
let's hope the projector is not going

00:00:13,740 --> 00:00:21,390
value me so having just gonna be fine so

00:00:18,350 --> 00:00:24,120
today I'm going to talk you about take

00:00:21,390 --> 00:00:25,980
of edition with cats don't forget to

00:00:24,120 --> 00:00:30,650
rate these talk and say that it was

00:00:25,980 --> 00:00:34,739
awesome and now let's start with it so

00:00:30,650 --> 00:00:39,989
hi my name is Angela and I'm a next door

00:00:34,739 --> 00:00:42,510
developer I know we have been there so

00:00:39,989 --> 00:00:44,069
when I was a university they didn't

00:00:42,510 --> 00:00:46,859
taught me anything about functional

00:00:44,069 --> 00:00:50,429
programming all the time was objects

00:00:46,859 --> 00:00:54,420
objects Ganga for and then I started

00:00:50,429 --> 00:00:56,309
with Scala and suddenly I was a little

00:00:54,420 --> 00:00:58,530
bit embarrassed because everyone was

00:00:56,309 --> 00:01:01,079
saying now forget about all the things

00:00:58,530 --> 00:01:03,839
that you have learned so far now we

00:01:01,079 --> 00:01:07,050
start the game from scratch and for me

00:01:03,839 --> 00:01:10,860
with a little bit of a shock it's a

00:01:07,050 --> 00:01:13,260
great process to go through I really

00:01:10,860 --> 00:01:17,280
enjoyed myself but at the beginning was

00:01:13,260 --> 00:01:20,340
a little bit hard to do I'm not a

00:01:17,280 --> 00:01:25,140
mathematician so I have some basic

00:01:20,340 --> 00:01:27,540
mathematical knowledge but I'm not a

00:01:25,140 --> 00:01:30,000
mathematician so I don't know the

00:01:27,540 --> 00:01:32,130
advanced stuff most of the things are

00:01:30,000 --> 00:01:35,660
the backbone of functional programming I

00:01:32,130 --> 00:01:39,240
didn't know them I had to learn them so

00:01:35,660 --> 00:01:42,360
it was a little bit traumatic for me and

00:01:39,240 --> 00:01:46,680
because of that I've decided to create a

00:01:42,360 --> 00:01:49,730
talk it doesn't use any functional world

00:01:46,680 --> 00:01:52,590
work and you will still get the point

00:01:49,730 --> 00:01:55,650
all three terms are useful makes life

00:01:52,590 --> 00:01:58,740
easier but at the beginning forget about

00:01:55,650 --> 00:02:04,800
the words just try to understand the

00:01:58,740 --> 00:02:06,330
concept behind them okay so now I'm not

00:02:04,800 --> 00:02:08,420
gonna intentionally going to name things

00:02:06,330 --> 00:02:11,039
because I don't want to scare you off

00:02:08,420 --> 00:02:13,650
but obviously I'm going to be around so

00:02:11,039 --> 00:02:15,660
if you want discolouring find me and I

00:02:13,650 --> 00:02:19,070
will tell you all the scary names of all

00:02:15,660 --> 00:02:23,480
things that I've presented to you today

00:02:19,070 --> 00:02:27,480
so I'm going to do about data validation

00:02:23,480 --> 00:02:30,420
well why am I going to talk to you about

00:02:27,480 --> 00:02:32,760
data validation because everyone has to

00:02:30,420 --> 00:02:38,160
do it right as soon as your application

00:02:32,760 --> 00:02:40,440
accept some data you are basically sure

00:02:38,160 --> 00:02:43,410
that you will need somehow to validated

00:02:40,440 --> 00:02:46,980
and the regulation can become pretty

00:02:43,410 --> 00:02:49,920
messy pretty quickly so there are what I

00:02:46,980 --> 00:02:52,310
call two types of validation the

00:02:49,920 --> 00:02:54,830
technical validation business validation

00:02:52,310 --> 00:02:58,220
technical validation is something like

00:02:54,830 --> 00:03:00,570
that these records exist that the user

00:02:58,220 --> 00:03:03,360
have the permission to perform this

00:03:00,570 --> 00:03:07,260
operation and this business validations

00:03:03,360 --> 00:03:11,550
are something more on blind given his

00:03:07,260 --> 00:03:16,980
data can he ask these information can he

00:03:11,550 --> 00:03:18,750
do stuff like that any really are in

00:03:16,980 --> 00:03:21,390
particular business validation just

00:03:18,750 --> 00:03:24,090
change really quickly and it needs to be

00:03:21,390 --> 00:03:27,800
maintained and this is not what

00:03:24,090 --> 00:03:31,370
structure it will be a mess religion and

00:03:27,800 --> 00:03:32,670
as I said before everyone else to do it

00:03:31,370 --> 00:03:36,030
right

00:03:32,670 --> 00:03:37,770
everyone has to do it so we don't want

00:03:36,030 --> 00:03:40,260
to invent wheel over and over again I

00:03:37,770 --> 00:03:43,410
mean we could write but we want to focus

00:03:40,260 --> 00:03:44,940
on the new challenges of our project we

00:03:43,410 --> 00:03:49,830
don't want to solve the same problems

00:03:44,940 --> 00:03:54,180
over and over again so um this is the

00:03:49,830 --> 00:03:56,700
goal of our talk is how can I validate

00:03:54,180 --> 00:04:00,480
my data without going crazy reinventing

00:03:56,700 --> 00:04:03,930
everything from scratch every time so

00:04:00,480 --> 00:04:04,709
now really quickly a promise I know it

00:04:03,930 --> 00:04:07,110
can be boring

00:04:04,709 --> 00:04:11,100
I'm going to just super quickly review

00:04:07,110 --> 00:04:15,270
the key actors of our game so the first

00:04:11,100 --> 00:04:19,590
one is math what is mob you basically

00:04:15,270 --> 00:04:22,560
have a rapper and this map allows you to

00:04:19,590 --> 00:04:26,460
access the value inside this rapper and

00:04:22,560 --> 00:04:28,830
to modifier so for example we have some

00:04:26,460 --> 00:04:32,849
Daniela maps and then we have the gear

00:04:28,830 --> 00:04:35,580
we will return some yellow yellow if

00:04:32,849 --> 00:04:38,639
there is no value to access guess what

00:04:35,580 --> 00:04:40,860
nothing is going to happen right so this

00:04:38,639 --> 00:04:46,379
is the idea of map having a container

00:04:40,860 --> 00:04:50,430
and we accessed value inside what

00:04:46,379 --> 00:04:56,280
happens though if the value inside my

00:04:50,430 --> 00:04:59,460
map returns a container so you will have

00:04:56,280 --> 00:05:02,940
container container of value in this

00:04:59,460 --> 00:05:05,400
example you will have some of a sum of a

00:05:02,940 --> 00:05:07,680
value that's stupid right we just we

00:05:05,400 --> 00:05:08,460
don't want something that maybe maybe is

00:05:07,680 --> 00:05:11,580
going to be there

00:05:08,460 --> 00:05:13,380
we just want something that is maybe

00:05:11,580 --> 00:05:15,180
going to be there so there is this

00:05:13,380 --> 00:05:17,849
beautiful things that is called

00:05:15,180 --> 00:05:20,719
fractions they basically just get rid of

00:05:17,849 --> 00:05:24,030
one container and we are all happy and

00:05:20,719 --> 00:05:27,210
this button is so useful and so common

00:05:24,030 --> 00:05:28,979
that they decided to create a function

00:05:27,210 --> 00:05:32,969
there is just the combination of the two

00:05:28,979 --> 00:05:39,780
that is called sub map nothing else okay

00:05:32,969 --> 00:05:42,930
and last bit of our game is double

00:05:39,780 --> 00:05:46,219
function if you have a map and you have

00:05:42,930 --> 00:05:49,830
a flat map then you can write these nice

00:05:46,219 --> 00:05:51,389
syntactic sugar where basically it's

00:05:49,830 --> 00:05:55,020
going to sequentially going to compute

00:05:51,389 --> 00:05:57,029
the values and it will stop Chris as

00:05:55,020 --> 00:06:00,240
soon as one of the values in the chain

00:05:57,029 --> 00:06:04,529
is empty so for example here you have

00:06:00,240 --> 00:06:07,020
some of one a a will contain one some

00:06:04,529 --> 00:06:10,849
five B will contain five and we sum the

00:06:07,020 --> 00:06:13,229
two values in the second case if B

00:06:10,849 --> 00:06:14,669
cannot really contain any value because

00:06:13,229 --> 00:06:18,229
it emptied the whole thing is going to

00:06:14,669 --> 00:06:21,930
be none yeah everyone with me so far

00:06:18,229 --> 00:06:24,090
yeah we know this stuff right go and now

00:06:21,930 --> 00:06:25,680
let's start our game we are going to

00:06:24,090 --> 00:06:29,340
play a little game that is called

00:06:25,680 --> 00:06:31,710
what's wrong with my code so see

00:06:29,340 --> 00:06:34,050
beautiful HTML people that say that I

00:06:31,710 --> 00:06:36,449
come a different time they are lying it

00:06:34,050 --> 00:06:40,070
is beautiful there is going to be our

00:06:36,449 --> 00:06:43,100
case study so we will have a

00:06:40,070 --> 00:06:44,510
form with an email phone number and we

00:06:43,100 --> 00:06:46,760
want to write a function that represents

00:06:44,510 --> 00:06:49,310
the validation of these beautiful form

00:06:46,760 --> 00:06:52,070
of course this is a simplistic example

00:06:49,310 --> 00:06:54,380
of our problem but you will see you will

00:06:52,070 --> 00:06:57,950
be enough to alight all the problems of

00:06:54,380 --> 00:07:02,990
our solution so are you ready to serve

00:06:57,950 --> 00:07:05,330
them again yeah yeah but cool okay so we

00:07:02,990 --> 00:07:08,480
just started with Scala we come from

00:07:05,330 --> 00:07:10,820
Java and yes we're not cool yet so we

00:07:08,480 --> 00:07:15,260
didn't even know that color to 12 star

00:07:10,820 --> 00:07:17,600
to 11 is not the latest version so it's

00:07:15,260 --> 00:07:22,130
fine we will learn we will get there

00:07:17,600 --> 00:07:23,980
also let's start with color 211 and we

00:07:22,130 --> 00:07:27,440
again we come from a Java background

00:07:23,980 --> 00:07:29,360
when an options a little bit so we are

00:07:27,440 --> 00:07:33,020
familiar with this will we go for it

00:07:29,360 --> 00:07:36,200
so what are options really quickly they

00:07:33,020 --> 00:07:40,340
are in the sky package and you basically

00:07:36,200 --> 00:07:43,940
have two possible implementations some

00:07:40,340 --> 00:07:47,720
of the value and none and you have a map

00:07:43,940 --> 00:07:50,150
and you have a flat map what this means

00:07:47,720 --> 00:07:53,390
is having a map means that you can

00:07:50,150 --> 00:07:54,920
easily access value inside having the

00:07:53,390 --> 00:07:57,800
front map means that you can write for

00:07:54,920 --> 00:08:02,270
convention right and just to be crystal

00:07:57,800 --> 00:08:04,700
clear this is how you use an option it's

00:08:02,270 --> 00:08:06,560
the first an example of how you can

00:08:04,700 --> 00:08:08,440
create an option we all know about this

00:08:06,560 --> 00:08:09,560
so I'm not going to spend too much time

00:08:08,440 --> 00:08:13,420
okay

00:08:09,560 --> 00:08:16,640
ready for the first row yes okay

00:08:13,420 --> 00:08:19,760
come on clickin thank you clicker okay

00:08:16,640 --> 00:08:23,030
so this is our first implementations we

00:08:19,760 --> 00:08:24,650
have a case class data has Nemo and a

00:08:23,030 --> 00:08:27,620
phone that's just a representation of

00:08:24,650 --> 00:08:29,560
our form then we have a function that is

00:08:27,620 --> 00:08:33,190
called validate you know that takes on

00:08:29,560 --> 00:08:37,190
stranger returns an option of a string

00:08:33,190 --> 00:08:39,020
meaning if the bar a female is valid we

00:08:37,190 --> 00:08:41,300
will return the sum containing the email

00:08:39,020 --> 00:08:43,520
whether it's a month thanks for the

00:08:41,300 --> 00:08:46,190
phone and then we have this beautiful

00:08:43,520 --> 00:08:50,230
function while the data that takes the

00:08:46,190 --> 00:08:52,740
case class then validates the feel and

00:08:50,230 --> 00:08:56,790
then put

00:08:52,740 --> 00:08:59,220
everything back together so don't say

00:08:56,790 --> 00:09:01,230
everything please because this is just

00:08:59,220 --> 00:09:14,160
the beginning of our journey what's

00:09:01,230 --> 00:09:15,870
wrong with this code sorry second you

00:09:14,160 --> 00:09:17,670
can construct data there is no value

00:09:15,870 --> 00:09:20,250
from the start you might be right but

00:09:17,670 --> 00:09:25,370
that's not what I'm looking for other

00:09:20,250 --> 00:09:28,800
people are the guy on the red shirt

00:09:25,370 --> 00:09:31,279
exactly you can say what went wrong

00:09:28,800 --> 00:09:35,520
sorry too late

00:09:31,279 --> 00:09:38,339
so um what does this mean so let's

00:09:35,520 --> 00:09:40,620
assume that the email is correct so here

00:09:38,339 --> 00:09:43,740
I will have a value phone is two right

00:09:40,620 --> 00:09:46,200
here I will have value it's fine but

00:09:43,740 --> 00:09:48,930
what if the email is wrong the whole

00:09:46,200 --> 00:09:51,540
thing will return now what if the phone

00:09:48,930 --> 00:09:53,640
is wrong we will go here then it would

00:09:51,540 --> 00:09:54,980
break the whole thing is not what if

00:09:53,640 --> 00:09:59,040
they're both wrong

00:09:54,980 --> 00:10:01,950
see we will get none it is clear if we

00:09:59,040 --> 00:10:05,610
explicitly use the function so here if

00:10:01,950 --> 00:10:08,850
we say okay now okay phone we return the

00:10:05,610 --> 00:10:12,959
data in all the cases we just return

00:10:08,850 --> 00:10:13,529
none so can anyone tell me what wouldn't

00:10:12,959 --> 00:10:15,839
wrong

00:10:13,529 --> 00:10:19,880
not really you don't know is it even if

00:10:15,839 --> 00:10:21,270
the phone is it both so don't do it

00:10:19,880 --> 00:10:23,520
don't do it

00:10:21,270 --> 00:10:27,270
did this that's all you're looking

00:10:23,520 --> 00:10:32,490
forward this is boolean and we will like

00:10:27,270 --> 00:10:34,320
you anyway option is great but it's not

00:10:32,490 --> 00:10:36,390
great for validation what we are

00:10:34,320 --> 00:10:40,589
actually trying to do here is a little

00:10:36,390 --> 00:10:45,829
bit more we want to tell exactly why and

00:10:40,589 --> 00:10:50,610
what went wrong in our validation okay

00:10:45,829 --> 00:10:55,440
cool round number two we know about it

00:10:50,610 --> 00:10:57,990
right either is from scar the hotel and

00:10:55,440 --> 00:11:00,450
basically has to implementation last

00:10:57,990 --> 00:11:03,620
that contains the value and right that

00:11:00,450 --> 00:11:06,899
contains not value and the reasoning is

00:11:03,620 --> 00:11:08,999
is it there going to be a good phone you

00:11:06,899 --> 00:11:12,779
is going to be a bad value so it's one

00:11:08,999 --> 00:11:14,430
of the tip right we don't have a map we

00:11:12,779 --> 00:11:18,420
didn't have a plat map so we cannot

00:11:14,430 --> 00:11:21,509
access the the value easily and we

00:11:18,420 --> 00:11:23,910
cannot write a nice full contention

00:11:21,509 --> 00:11:29,429
remember this is Scala 211 is not

00:11:23,910 --> 00:11:31,679
scholar 212 what we have inside is what

00:11:29,429 --> 00:11:33,929
they call left-right projection you

00:11:31,679 --> 00:11:37,920
basically indicate which side you want

00:11:33,929 --> 00:11:39,899
to map on it's a little bit weird but it

00:11:37,920 --> 00:11:43,110
kind of works I mean you have a map and

00:11:39,899 --> 00:11:46,709
you have a flat map so it's cool and

00:11:43,110 --> 00:11:49,170
this is how we use it it's a fairly

00:11:46,709 --> 00:11:55,850
standard basically um this is the only

00:11:49,170 --> 00:12:00,660
beat that changed cool round number two

00:11:55,850 --> 00:12:03,600
okay this is our code so Kinkos data

00:12:00,660 --> 00:12:05,699
that has an email and a phone then we

00:12:03,600 --> 00:12:09,149
have a function by the Gmail that takes

00:12:05,699 --> 00:12:12,870
an emo that returns an either a list of

00:12:09,149 --> 00:12:15,300
strings or a string note this is a list

00:12:12,870 --> 00:12:18,329
because multiple things could be wrong

00:12:15,300 --> 00:12:21,199
in an email right since the phone and

00:12:18,329 --> 00:12:24,300
then we have our beautiful validate data

00:12:21,199 --> 00:12:28,920
we believe add a zero well date the

00:12:24,300 --> 00:12:31,559
phone and then we just try to put match

00:12:28,920 --> 00:12:34,499
so we just say valid email valid phone

00:12:31,559 --> 00:12:37,709
and then if they're both right written

00:12:34,499 --> 00:12:43,199
by the data if they're both from where

00:12:37,709 --> 00:12:46,079
it's gonna last we combine DDD less than

00:12:43,199 --> 00:12:48,779
if just one is wrong written by the

00:12:46,079 --> 00:12:51,559
other one is wrong written down what's

00:12:48,779 --> 00:12:51,559
wrong with my count

00:12:59,240 --> 00:13:04,350
exactly if you have 20 fields you will

00:13:01,620 --> 00:13:07,860
back you will get crazy not just want to

00:13:04,350 --> 00:13:09,930
feel free fulfill there enough right you

00:13:07,860 --> 00:13:12,810
how many cases you are gonna go there

00:13:09,930 --> 00:13:15,180
right it's it's code backwards but it's

00:13:12,810 --> 00:13:17,160
just not maintainable right we don't

00:13:15,180 --> 00:13:19,770
want to go crazy try to bathroom rats

00:13:17,160 --> 00:13:20,970
over all the possible cases is just now

00:13:19,770 --> 00:13:25,140
it doesn't work like that

00:13:20,970 --> 00:13:28,650
so the code works is the fact that when

00:13:25,140 --> 00:13:31,200
we use it it works when we pass both the

00:13:28,650 --> 00:13:34,650
values that are okay and return the case

00:13:31,200 --> 00:13:36,660
class and if we pass both values that

00:13:34,650 --> 00:13:40,470
are wrong you will return both the

00:13:36,660 --> 00:13:43,860
errors it works is just it's crazy code

00:13:40,470 --> 00:13:46,410
right we we don't want to be crazy we

00:13:43,860 --> 00:13:50,460
want to be able to scale our code

00:13:46,410 --> 00:13:53,839
together with our validation there is

00:13:50,460 --> 00:13:58,279
another little problem in this code that

00:13:53,839 --> 00:13:59,730
is who is saying that the right is the

00:13:58,279 --> 00:14:03,120
correct one

00:13:59,730 --> 00:14:06,260
and the last one is the wrong one no one

00:14:03,120 --> 00:14:08,400
right it's a convention that we assume

00:14:06,260 --> 00:14:10,589
obviously English helps a little bit

00:14:08,400 --> 00:14:15,839
here because right is right and left is

00:14:10,589 --> 00:14:17,640
wrong but you know I am in the UK I've

00:14:15,839 --> 00:14:20,490
been telling them that they are driving

00:14:17,640 --> 00:14:23,100
on the wrong side of the road and they

00:14:20,490 --> 00:14:26,070
still do it right so there are people

00:14:23,100 --> 00:14:29,160
that would argue that left should

00:14:26,070 --> 00:14:30,990
contain the correct value we don't want

00:14:29,160 --> 00:14:34,170
to have that discussion basically we

00:14:30,990 --> 00:14:40,350
just want to have one way of doing it we

00:14:34,170 --> 00:14:44,820
don't want to discuss it further so what

00:14:40,350 --> 00:14:48,330
we say because we don't choose where to

00:14:44,820 --> 00:14:51,089
wrap is that either is not biased we

00:14:48,330 --> 00:14:56,130
have to tell which side we want them

00:14:51,089 --> 00:14:59,130
upon and as I was saying that it's not

00:14:56,130 --> 00:15:01,589
really maintainable code so if you try

00:14:59,130 --> 00:15:05,670
to add a few distances then the pattern

00:15:01,589 --> 00:15:09,070
match will just explode okay so we stick

00:15:05,670 --> 00:15:11,920
with our more experienced

00:15:09,070 --> 00:15:15,220
eggs and they say come on then use color

00:15:11,920 --> 00:15:17,320
211 skirt to 12v south he should

00:15:15,220 --> 00:15:20,920
definitely going to try it out

00:15:17,320 --> 00:15:23,770
so we guys we try it out and we

00:15:20,920 --> 00:15:27,940
discovered that in Scala 211 first to 12

00:15:23,770 --> 00:15:30,190
we have either this is exactly as before

00:15:27,940 --> 00:15:33,040
with the only difference that we do have

00:15:30,190 --> 00:15:35,830
a map and we do have a farm up what that

00:15:33,040 --> 00:15:39,250
means is that you can access the value

00:15:35,830 --> 00:15:41,590
and you can write the folk intention you

00:15:39,250 --> 00:15:44,800
still have the opportunity to say

00:15:41,590 --> 00:15:47,140
actually map on another side but by

00:15:44,800 --> 00:15:50,830
default they will assume that you are

00:15:47,140 --> 00:15:53,140
mapping on the right side and this is

00:15:50,830 --> 00:15:58,210
all you building it's basically same as

00:15:53,140 --> 00:16:01,210
before nothing has changed okay cool

00:15:58,210 --> 00:16:04,750
year-round this is our code so case

00:16:01,210 --> 00:16:08,560
class data takes an email and that phone

00:16:04,750 --> 00:16:10,330
and we have a function by the email that

00:16:08,560 --> 00:16:13,350
takes the string and returns an ease

00:16:10,330 --> 00:16:17,080
either list of strengths or a strength

00:16:13,350 --> 00:16:20,890
same for phone and then we have this

00:16:17,080 --> 00:16:22,810
beautiful function validate data that

00:16:20,890 --> 00:16:26,700
takes the data and return an either a

00:16:22,810 --> 00:16:31,660
list of string or a data and because now

00:16:26,700 --> 00:16:34,720
we say that either is right bias we can

00:16:31,660 --> 00:16:36,700
write a beautiful full convention so we

00:16:34,720 --> 00:16:39,940
can validate the email then validate the

00:16:36,700 --> 00:16:47,380
phone and then put them together okay

00:16:39,940 --> 00:16:50,470
what's wrong with my code it will fail

00:16:47,380 --> 00:16:53,080
on the first lap that's correct so the

00:16:50,470 --> 00:16:58,900
cool kids call these is failing to fast

00:16:53,080 --> 00:17:00,550
what does it mean in that if I pass both

00:16:58,900 --> 00:17:03,490
the email and the phone that are wrong

00:17:00,550 --> 00:17:05,290
it will validate email it will see that

00:17:03,490 --> 00:17:08,650
is wrong and you will not even look at

00:17:05,290 --> 00:17:11,860
the phone it will just fail to foxy

00:17:08,650 --> 00:17:15,339
fails once and then it stops and it is

00:17:11,860 --> 00:17:19,780
really clear if we look at how we use

00:17:15,339 --> 00:17:22,449
the function so if we if we pass both

00:17:19,780 --> 00:17:25,959
the values to be correct it works

00:17:22,449 --> 00:17:28,209
if we pass through one that is wrong it

00:17:25,959 --> 00:17:30,940
kind of works but if we pass both the

00:17:28,209 --> 00:17:33,399
values are wrong it was just written the

00:17:30,940 --> 00:17:35,619
first one because we are using the full

00:17:33,399 --> 00:17:39,239
convention so it will run them

00:17:35,619 --> 00:17:41,950
sequentially so that is not quite cool

00:17:39,239 --> 00:17:45,330
let me be extremely clear what I mean

00:17:41,950 --> 00:17:48,700
imagine this beautiful designed website

00:17:45,330 --> 00:17:51,419
with pre fields right and we are fill

00:17:48,700 --> 00:17:55,169
them out intentionally to be bad values

00:17:51,419 --> 00:17:58,239
what our function is doing is that is

00:17:55,169 --> 00:18:01,629
validating the first value saying okay

00:17:58,239 --> 00:18:04,480
that's bad changes we change it

00:18:01,629 --> 00:18:07,119
and we submit it again they sang all

00:18:04,480 --> 00:18:10,090
know is the second boundaries from take

00:18:07,119 --> 00:18:12,389
it again and now we submitted again all

00:18:10,090 --> 00:18:15,669
now is the good value that is wrong

00:18:12,389 --> 00:18:21,009
submit it again right what we actually

00:18:15,669 --> 00:18:24,279
want to do is given a form we want to

00:18:21,009 --> 00:18:26,830
have the whole form I like it with all

00:18:24,279 --> 00:18:29,619
the errors just tell me everything that

00:18:26,830 --> 00:18:31,840
is wrong and let's move on with it I

00:18:29,619 --> 00:18:33,399
don't I would never use a website like

00:18:31,840 --> 00:18:34,659
this I don't understand why your

00:18:33,399 --> 00:18:37,090
function should do the same

00:18:34,659 --> 00:18:39,730
just tell me everything that is wrong so

00:18:37,090 --> 00:18:46,859
they can take actions once and then we

00:18:39,730 --> 00:18:49,389
can move on so either is cool but

00:18:46,859 --> 00:18:53,320
doesn't support what it's called error

00:18:49,389 --> 00:18:55,570
accumulation so if you are sure that you

00:18:53,320 --> 00:18:58,629
will always have only one thing that is

00:18:55,570 --> 00:19:00,999
wrong you could use it but as soon as

00:18:58,629 --> 00:19:02,220
you have multiple things that could go

00:19:00,999 --> 00:19:08,279
wrong

00:19:02,220 --> 00:19:11,999
listen is not that cool anymore okay so

00:19:08,279 --> 00:19:16,029
under star options

00:19:11,999 --> 00:19:18,549
well choices don't really work for us

00:19:16,029 --> 00:19:21,009
let's have a look around what we have

00:19:18,549 --> 00:19:25,389
out there and we discover that we have a

00:19:21,009 --> 00:19:27,279
library that is called cat okay but so

00:19:25,389 --> 00:19:31,330
that's going to have lots of stars in

00:19:27,279 --> 00:19:34,809
detail so it's promising so let's see

00:19:31,330 --> 00:19:35,559
what cats can do for us the first thing

00:19:34,809 --> 00:19:38,169
that cats can

00:19:35,559 --> 00:19:41,710
for us is that if we are talking to 11

00:19:38,169 --> 00:19:46,240
for some mysterious reason we can still

00:19:41,710 --> 00:19:49,539
have our either to be right biased all I

00:19:46,240 --> 00:19:52,419
have to do is to import these magic

00:19:49,539 --> 00:19:55,720
thingy and our leader is going to be

00:19:52,419 --> 00:19:58,350
magically right biased but we have seen

00:19:55,720 --> 00:20:03,539
that this doesn't really work either

00:19:58,350 --> 00:20:06,940
doesn't fit our problem if you guys know

00:20:03,539 --> 00:20:09,850
cats this is basically what it was

00:20:06,940 --> 00:20:14,799
called once soar is basically exactly

00:20:09,850 --> 00:20:20,320
same thing um okay not quite there yet

00:20:14,799 --> 00:20:22,600
so let's look more a cat and we

00:20:20,320 --> 00:20:23,559
discovered this new guy that is called

00:20:22,600 --> 00:20:27,759
validated

00:20:23,559 --> 00:20:32,519
okay so validating lives in cats the

00:20:27,759 --> 00:20:35,440
data and it has two possible values of

00:20:32,519 --> 00:20:39,639
valid that contains the value and the

00:20:35,440 --> 00:20:41,619
nymphalidae contains another value the

00:20:39,639 --> 00:20:43,990
name is a really promising it's clear

00:20:41,619 --> 00:20:45,460
what is correct and what it's not so

00:20:43,990 --> 00:20:50,080
there is no going to be any discussion

00:20:45,460 --> 00:20:52,960
around what's right and what's wrong we

00:20:50,080 --> 00:20:55,360
have a map it means that we can easily

00:20:52,960 --> 00:20:57,999
see what's inside the wrapper we're

00:20:55,360 --> 00:21:00,039
going to have a flat map and that's

00:20:57,999 --> 00:21:02,110
that's kind of cool because we have seen

00:21:00,039 --> 00:21:04,059
that we want to prevent people to write

00:21:02,110 --> 00:21:06,399
full comprehension because they don't

00:21:04,059 --> 00:21:08,909
work they fail too fast but we have

00:21:06,399 --> 00:21:13,179
something else there is really useful

00:21:08,909 --> 00:21:15,340
and did something else is call apply I'm

00:21:13,179 --> 00:21:17,110
not going to go into the details of what

00:21:15,340 --> 00:21:20,440
apply yes that was a good break my

00:21:17,110 --> 00:21:22,960
promise but if you are brave enough

00:21:20,440 --> 00:21:24,610
it's a beautiful links of the cuts

00:21:22,960 --> 00:21:26,200
documentation that will tell you

00:21:24,610 --> 00:21:30,190
everything that there is to know about

00:21:26,200 --> 00:21:33,970
apply and basically what it does is that

00:21:30,190 --> 00:21:37,809
there is this crazy symbol it's really

00:21:33,970 --> 00:21:41,350
crazy it basically does the same of the

00:21:37,809 --> 00:21:43,929
pattern matching so in will try all the

00:21:41,350 --> 00:21:47,230
combinations it will check if there are

00:21:43,929 --> 00:21:47,710
any invalid instances and combine them

00:21:47,230 --> 00:21:49,450
together

00:21:47,710 --> 00:21:51,070
if there are no

00:21:49,450 --> 00:21:53,049
invalid instances meaning that

00:21:51,070 --> 00:21:56,230
everything is valid it will apply a

00:21:53,049 --> 00:22:01,419
function to all the values inside the

00:21:56,230 --> 00:22:02,679
valid this friendly symbol has a crazy

00:22:01,419 --> 00:22:05,470
name that I'm not going to mention

00:22:02,679 --> 00:22:08,080
otherwise I'm going to scare you off so

00:22:05,470 --> 00:22:10,840
in the US someone told me that is called

00:22:08,080 --> 00:22:15,519
the Cinnabon symbol other people call

00:22:10,840 --> 00:22:17,980
the TIE fighter symbol I'm Italian so

00:22:15,519 --> 00:22:21,029
for the purposes of this presentation

00:22:17,980 --> 00:22:23,679
I'm going to call it the Pizza symbol

00:22:21,029 --> 00:22:24,549
please be aware is not actually called

00:22:23,679 --> 00:22:27,460
bits per symbol

00:22:24,549 --> 00:22:32,350
so don't google it you're creepy

00:22:27,460 --> 00:22:34,990
disappointed but let's see how we can

00:22:32,350 --> 00:22:37,360
build the validated we have two option

00:22:34,990 --> 00:22:40,510
basically the first one is basically the

00:22:37,360 --> 00:22:43,240
same of what we have before so we have a

00:22:40,510 --> 00:22:47,799
valid constructor and we have an invalid

00:22:43,240 --> 00:22:50,980
constructor and we have imported a

00:22:47,799 --> 00:22:52,690
little weirdo Wiggly with them otherwise

00:22:50,980 --> 00:22:57,809
if you want to have a little bit more

00:22:52,690 --> 00:23:00,429
clear implementation we can just use

00:22:57,809 --> 00:23:02,019
it's called smushed constructor it's

00:23:00,429 --> 00:23:05,460
basically exactly the same it's just

00:23:02,019 --> 00:23:11,010
more explicit on what we mean with that

00:23:05,460 --> 00:23:16,149
yes everyone with needs work cool um

00:23:11,010 --> 00:23:18,519
next round so um is our code so we have

00:23:16,149 --> 00:23:20,830
a case class data that contains an email

00:23:18,519 --> 00:23:22,899
and a phone then we have a function

00:23:20,830 --> 00:23:26,620
there is called validate email they take

00:23:22,899 --> 00:23:30,159
the strength and return the validated of

00:23:26,620 --> 00:23:32,200
list of string or strings thank for the

00:23:30,159 --> 00:23:37,409
phone and then we have this gif function

00:23:32,200 --> 00:23:40,690
by the data where we validate the evil

00:23:37,409 --> 00:23:43,570
five days the phone then the crazy

00:23:40,690 --> 00:23:46,299
symbol comes in and the greatest symbol

00:23:43,570 --> 00:23:49,090
wall tracked if there are any invalid

00:23:46,299 --> 00:23:51,909
instances if there are it will combine

00:23:49,090 --> 00:23:54,490
them and return them otherwise it will

00:23:51,909 --> 00:23:58,940
just extract all the values that are

00:23:54,490 --> 00:24:09,000
valid and apply a function on them yes

00:23:58,940 --> 00:24:11,160
cool what's wrong with my god okay I'm

00:24:09,000 --> 00:24:16,559
not gonna let you suffer it's fine my

00:24:11,160 --> 00:24:19,520
wife is really a basil and basically the

00:24:16,559 --> 00:24:23,670
reason why works is because instead of

00:24:19,520 --> 00:24:25,860
computing the values sequentially with a

00:24:23,670 --> 00:24:30,120
full compression we are computing them

00:24:25,860 --> 00:24:33,420
in parallel note this is written in one

00:24:30,120 --> 00:24:37,110
line how cool is that that is the

00:24:33,420 --> 00:24:39,390
indication that everything is computed

00:24:37,110 --> 00:24:42,480
in parallel rather than in sequence like

00:24:39,390 --> 00:24:47,850
super cool I love this and as I was

00:24:42,480 --> 00:24:51,740
saying it works in what right beautiful

00:24:47,850 --> 00:24:55,309
so if we pass both the values to be okay

00:24:51,740 --> 00:24:58,710
we'll just return the case because if we

00:24:55,309 --> 00:25:01,140
pass both the values that are wrong in

00:24:58,710 --> 00:25:02,150
we written both of them and so on it's

00:25:01,140 --> 00:25:08,040
cool

00:25:02,150 --> 00:25:12,800
okay can we go better can you guys see

00:25:08,040 --> 00:25:12,800
anything that is not exactly noted here

00:25:13,040 --> 00:25:22,830
yes sorry we free fields we will just

00:25:20,670 --> 00:25:25,770
add another crazy symbol and then thingy

00:25:22,830 --> 00:25:35,040
so it will be it's starting called

00:25:25,770 --> 00:25:47,100
Teresa can you do a sequence and them up

00:25:35,040 --> 00:25:48,630
over this symbol sorry so can you put

00:25:47,100 --> 00:25:51,090
all the values in a sequence I'd I think

00:25:48,630 --> 00:25:53,670
you can but that's not what I want to go

00:25:51,090 --> 00:25:58,920
so try again

00:25:53,670 --> 00:26:01,350
yes what about validation of multiple

00:25:58,920 --> 00:26:03,420
fields now I find it fine you will just

00:26:01,350 --> 00:26:05,610
add the validation that involves

00:26:03,420 --> 00:26:11,310
multiple fields yes last one and then

00:26:05,610 --> 00:26:14,940
I'll sell you the answer how does he

00:26:11,310 --> 00:26:17,550
know how to merge the errors I'm gonna

00:26:14,940 --> 00:26:21,240
say a magical word don't be scared

00:26:17,550 --> 00:26:24,030
sandy group I'll tell you later what

00:26:21,240 --> 00:26:25,910
they are it's fine there is a semi group

00:26:24,030 --> 00:26:30,390
defined so he knows how to combine them

00:26:25,910 --> 00:26:32,790
because we're using a list but we are

00:26:30,390 --> 00:26:33,420
diverging here so things that we can

00:26:32,790 --> 00:26:35,990
improve

00:26:33,420 --> 00:26:40,950
so can we return with this current

00:26:35,990 --> 00:26:46,470
implementation are invalid containing an

00:26:40,950 --> 00:26:48,990
empty list yes we can and what we are

00:26:46,470 --> 00:26:50,550
saying basically is sorry dude is

00:26:48,990 --> 00:26:55,140
invalid but I'm not going to tell you

00:26:50,550 --> 00:26:56,970
why but that's not cool we want to

00:26:55,140 --> 00:26:59,429
prevent people to do that we want to

00:26:56,970 --> 00:27:01,440
force people to say it is going to be

00:26:59,429 --> 00:27:03,510
invalid you need to guarantee you're

00:27:01,440 --> 00:27:09,030
gonna tell me at least one reason why

00:27:03,510 --> 00:27:12,030
it's not valid and my sort of everything

00:27:09,030 --> 00:27:16,350
is usual so we have this beautiful thing

00:27:12,030 --> 00:27:20,280
that is called validate nail that is

00:27:16,350 --> 00:27:24,440
composed by a not empty list that has

00:27:20,280 --> 00:27:28,650
this type and then we just have an alias

00:27:24,440 --> 00:27:33,690
where Nell stands for not empty list

00:27:28,650 --> 00:27:38,220
that is associated to validated okay

00:27:33,690 --> 00:27:42,120
and just as before how do we construct

00:27:38,220 --> 00:27:45,320
the type like this um same as before the

00:27:42,120 --> 00:27:48,330
invalid bit looks a little bit out here

00:27:45,320 --> 00:27:50,429
but thank God we have an alias that

00:27:48,330 --> 00:27:53,060
makes it really easy to construct the

00:27:50,429 --> 00:27:58,050
value from that okay

00:27:53,060 --> 00:28:02,580
um anything else that we don't like from

00:27:58,050 --> 00:28:06,450
a Thai point of view well something that

00:28:02,580 --> 00:28:10,080
is not too cool is the fact that the

00:28:06,450 --> 00:28:12,840
error is a strength there nothing wrong

00:28:10,080 --> 00:28:14,640
with having a string the problem is that

00:28:12,840 --> 00:28:17,340
probably you wanted something with

00:28:14,640 --> 00:28:20,310
desire and you want to have some kind of

00:28:17,340 --> 00:28:23,910
structure string is a little bit too

00:28:20,310 --> 00:28:28,170
flexible you know it's easy to change so

00:28:23,910 --> 00:28:30,780
maybe we'll be better to just choose

00:28:28,170 --> 00:28:33,900
something anything with a structure to

00:28:30,780 --> 00:28:37,560
represent our arrow this is just one

00:28:33,900 --> 00:28:39,930
possible solution obviously the point

00:28:37,560 --> 00:28:41,940
that I won't pass here just whatever it

00:28:39,930 --> 00:28:44,190
is just choose a representation with

00:28:41,940 --> 00:28:46,410
some structure so you can do things with

00:28:44,190 --> 00:28:48,360
it so for example you're going to have a

00:28:46,410 --> 00:28:48,840
case class with an error code an error

00:28:48,360 --> 00:28:53,550
message

00:28:48,840 --> 00:28:57,990
that's it so if we do that this is our

00:28:53,550 --> 00:29:00,540
final solution so some is big for case

00:28:57,990 --> 00:29:03,060
cost data we didn't even have phone we

00:29:00,540 --> 00:29:04,830
have function value HTML there isn't a

00:29:03,060 --> 00:29:08,900
string and returns like that nail of an

00:29:04,830 --> 00:29:12,000
error of strength same for by the phone

00:29:08,900 --> 00:29:12,780
body did he validate data is basically

00:29:12,000 --> 00:29:17,340
the same as before

00:29:12,780 --> 00:29:19,380
yeah I like the beautiful and the type

00:29:17,340 --> 00:29:27,510
will guarantee that we don't do stupid

00:29:19,380 --> 00:29:30,690
things go really regression to wanders

00:29:27,510 --> 00:29:33,840
off the pizza symbol the picture symbol

00:29:30,690 --> 00:29:38,970
is not specific to validated you can use

00:29:33,840 --> 00:29:40,500
it with everything well you can use it

00:29:38,970 --> 00:29:43,020
with most of the things that have a flat

00:29:40,500 --> 00:29:45,900
map so it means that for example we

00:29:43,020 --> 00:29:48,960
picture you can write this full

00:29:45,900 --> 00:29:51,990
convention there we'll just run the

00:29:48,960 --> 00:29:54,870
futures in sequential order meaning it

00:29:51,990 --> 00:29:58,920
will compute the one wait for the one to

00:29:54,870 --> 00:30:01,650
finish but it will compute the to wait

00:29:58,920 --> 00:30:04,440
for the two to finish then it will

00:30:01,650 --> 00:30:05,880
compute the free and wait for the free

00:30:04,440 --> 00:30:06,630
to finish and combine all of them

00:30:05,880 --> 00:30:10,020
together

00:30:06,630 --> 00:30:12,919
or with this nine expression you can

00:30:10,020 --> 00:30:16,200
just start them all of them together and

00:30:12,919 --> 00:30:18,360
just combine them all of them so this

00:30:16,200 --> 00:30:19,919
one is more performant obviously the

00:30:18,360 --> 00:30:21,919
futures needs to be completely

00:30:19,919 --> 00:30:26,460
independent otherwise you cannot do that

00:30:21,919 --> 00:30:30,419
okay so these can be used not just for

00:30:26,460 --> 00:30:34,620
validation so is this super cool it's a

00:30:30,419 --> 00:30:37,140
symbol for doing um code but we have

00:30:34,620 --> 00:30:40,669
done this video game we've understood

00:30:37,140 --> 00:30:44,760
they're obviously types are important

00:30:40,669 --> 00:30:47,640
the obviously we don't work with the

00:30:44,760 --> 00:30:49,500
forms they have just to feel right we do

00:30:47,640 --> 00:30:53,549
think that are pretty complex so how do

00:30:49,500 --> 00:30:55,380
we apply all these all these buttons

00:30:53,549 --> 00:30:57,870
that we have learned today in our

00:30:55,380 --> 00:31:02,220
application so these are my advice and

00:30:57,870 --> 00:31:04,830
how to import this into your code the

00:31:02,220 --> 00:31:07,799
first step is to pick an arrow

00:31:04,830 --> 00:31:09,900
represents a ssin and stick to it the

00:31:07,799 --> 00:31:13,740
whole obligation should use that error

00:31:09,900 --> 00:31:15,510
representation why because you are going

00:31:13,740 --> 00:31:18,480
to accumulate errors and if you

00:31:15,510 --> 00:31:20,880
communities are different it's going to

00:31:18,480 --> 00:31:22,559
be a mess I guarantee you if you

00:31:20,880 --> 00:31:24,720
accumulate things that are always the

00:31:22,559 --> 00:31:25,350
same they have a common trait or

00:31:24,720 --> 00:31:29,400
something

00:31:25,350 --> 00:31:31,530
it's syllable it's you can do it but if

00:31:29,400 --> 00:31:33,450
you start having 20 millions different

00:31:31,530 --> 00:31:36,120
representation of water an error is

00:31:33,450 --> 00:31:40,980
you're going to be in trouble

00:31:36,120 --> 00:31:44,809
second step is to enforce everyone to

00:31:40,980 --> 00:31:50,880
use the error representation using a

00:31:44,809 --> 00:31:54,600
alias so this could be one they don't if

00:31:50,880 --> 00:31:57,240
you use these areas you will basically

00:31:54,600 --> 00:32:01,950
force that the function will exactly

00:31:57,240 --> 00:32:03,960
return this error representation and the

00:32:01,950 --> 00:32:08,039
third step that I think is the more

00:32:03,960 --> 00:32:10,980
important one is make it simple for your

00:32:08,039 --> 00:32:14,460
team if you are enforcing some rules if

00:32:10,980 --> 00:32:16,370
these rules are all to follow guess what

00:32:14,460 --> 00:32:19,230
they are not going to follow them and

00:32:16,370 --> 00:32:20,280
one way of doing this is to create a

00:32:19,230 --> 00:32:22,920
companion object

00:32:20,280 --> 00:32:26,340
that makes the initialization of all

00:32:22,920 --> 00:32:29,070
these things extremely easy so this is

00:32:26,340 --> 00:32:30,780
an example of what we do what work it a

00:32:29,070 --> 00:32:34,290
little bit simplified but the logic is

00:32:30,780 --> 00:32:37,530
there so we have a representation of our

00:32:34,290 --> 00:32:40,380
error there is a silt right we decode

00:32:37,530 --> 00:32:43,110
the message and values where the code is

00:32:40,380 --> 00:32:46,170
just strength that the Sun turns or

00:32:43,110 --> 00:32:52,070
whoever is consuming our API can pattern

00:32:46,170 --> 00:32:55,200
matter and then we have case class that

00:32:52,070 --> 00:32:58,620
extends distrait and it's going to be

00:32:55,200 --> 00:33:03,180
the case class that decides the status

00:32:58,620 --> 00:33:06,870
code of our response so we know that if

00:33:03,180 --> 00:33:09,660
we have a list of errors and any of them

00:33:06,870 --> 00:33:12,300
is read request the whole response is

00:33:09,660 --> 00:33:15,150
going to be 100 otherwise it's going to

00:33:12,300 --> 00:33:18,860
be a 4/4 again this is just one way of

00:33:15,150 --> 00:33:22,380
doing it there are many ways of doing it

00:33:18,860 --> 00:33:25,410
these our beautiful areas and this is

00:33:22,380 --> 00:33:27,870
our companion object so to create a

00:33:25,410 --> 00:33:31,020
validation you just do validation dot

00:33:27,870 --> 00:33:32,880
success and you pass the value otherwise

00:33:31,020 --> 00:33:36,420
you do validation about failure and pass

00:33:32,880 --> 00:33:38,700
the arrow why we have done this because

00:33:36,420 --> 00:33:42,950
our team didn't really want to remember

00:33:38,700 --> 00:33:45,990
that we're using a not empty list they

00:33:42,950 --> 00:33:48,390
don't read to know all the

00:33:45,990 --> 00:33:50,870
implementation details to use these tool

00:33:48,390 --> 00:33:54,120
and that makes really easy for them

00:33:50,870 --> 00:33:57,330
another little thing that my team wasn't

00:33:54,120 --> 00:33:58,890
too happy about we are a team of really

00:33:57,330 --> 00:34:01,740
diverse people so I work with people

00:33:58,890 --> 00:34:04,380
with Ruby the ground bite on the ground

00:34:01,740 --> 00:34:08,820
and they just started with Scala they're

00:34:04,380 --> 00:34:10,200
not really used to the crazy symbol the

00:34:08,820 --> 00:34:13,710
pit system oh come on

00:34:10,200 --> 00:34:18,630
it can happen it can become the pizza

00:34:13,710 --> 00:34:19,950
symbol one day we just hide the symbol

00:34:18,630 --> 00:34:22,080
into a function that is called

00:34:19,950 --> 00:34:29,420
accumulate so they can do variations or

00:34:22,080 --> 00:34:33,150
Acula impossible bodies is enough so ah

00:34:29,420 --> 00:34:36,360
summarizing a little bit is what we have

00:34:33,150 --> 00:34:39,750
seen today it's a little exercise that

00:34:36,360 --> 00:34:41,460
can be useful to really play around and

00:34:39,750 --> 00:34:44,610
understand a little bit more about any

00:34:41,460 --> 00:34:48,390
language about any problem try to resign

00:34:44,610 --> 00:34:51,360
your problem in a simple way and try to

00:34:48,390 --> 00:34:53,310
ask yourself is it good enough what's

00:34:51,360 --> 00:34:58,050
wrong with this code what I don't like

00:34:53,310 --> 00:34:59,580
about this code don't remains real there

00:34:58,050 --> 00:35:01,470
are many libraries out there that

00:34:59,580 --> 00:35:04,320
probably already do what you want to do

00:35:01,470 --> 00:35:08,070
in particular is like me you work in a

00:35:04,320 --> 00:35:10,560
start-up and resources are limited we

00:35:08,070 --> 00:35:13,620
want to focus on the real challenges of

00:35:10,560 --> 00:35:19,620
our project we don't want to focus on

00:35:13,620 --> 00:35:22,290
these problems choosing the type is half

00:35:19,620 --> 00:35:25,830
of the battle so if you choose video

00:35:22,290 --> 00:35:29,280
types right you will see that your code

00:35:25,830 --> 00:35:33,270
will be really quickly a lot better to

00:35:29,280 --> 00:35:37,380
take your time do a few tries and try to

00:35:33,270 --> 00:35:42,480
pick the type that fits your problem

00:35:37,380 --> 00:35:45,390
most and also don't be scared of

00:35:42,480 --> 00:35:48,060
customizing your solutions writing

00:35:45,390 --> 00:35:55,230
yourself making your life and your

00:35:48,060 --> 00:35:56,840
team's life extremely easy so all the

00:35:55,230 --> 00:36:02,670
code that you have seen tonight is

00:35:56,840 --> 00:36:04,800
available on github on dicklick the best

00:36:02,670 --> 00:36:10,800
way of learning code is just to play

00:36:04,800 --> 00:36:13,020
around with it so my suggestion is check

00:36:10,800 --> 00:36:15,480
it out play with the code convince

00:36:13,020 --> 00:36:18,840
yourself that it works or it doesn't

00:36:15,480 --> 00:36:22,610
work and feel free to ask any questions

00:36:18,840 --> 00:36:26,730
about it just by opening an issue area I

00:36:22,610 --> 00:36:31,770
will solve these slides online that's my

00:36:26,730 --> 00:36:33,410
twitter angle so if you are a guy if you

00:36:31,770 --> 00:36:37,590
guys are interested in the slides just

00:36:33,410 --> 00:36:40,530
that's that's what to follow and if you

00:36:37,590 --> 00:36:44,240
want have a look at my blog

00:36:40,530 --> 00:36:48,780
and also remember to rate this session

00:36:44,240 --> 00:36:52,970
sadly was awesome so thank you very much

00:36:48,780 --> 00:36:57,720
guys I guess we have time for questions

00:36:52,970 --> 00:37:01,140
so are there any questions Thank You

00:36:57,720 --> 00:37:04,650
great oh and have you got any

00:37:01,140 --> 00:37:08,250
suggestions how to structure validation

00:37:04,650 --> 00:37:11,550
within the application to be montane

00:37:08,250 --> 00:37:15,210
able I mean when the application

00:37:11,550 --> 00:37:17,340
involves and the the model or the case

00:37:15,210 --> 00:37:21,390
classes that have to be invalidated a

00:37:17,340 --> 00:37:23,910
change in the data shape and the

00:37:21,390 --> 00:37:29,010
validation all always get messy and

00:37:23,910 --> 00:37:32,820
forgotten so the beans that I gave

00:37:29,010 --> 00:37:34,560
before valid but my suggestion that I

00:37:32,820 --> 00:37:36,770
believe is really important in

00:37:34,560 --> 00:37:40,230
particular in functional programming is

00:37:36,770 --> 00:37:42,740
function composition so try to have a

00:37:40,230 --> 00:37:46,770
lot of functions and try to compose them

00:37:42,740 --> 00:37:51,950
this way you can fairly easily and aloft

00:37:46,770 --> 00:37:56,130
a lot of validation so the crazy symbol

00:37:51,950 --> 00:38:04,230
sorry the picture symbol will work with

00:37:56,130 --> 00:38:08,190
lists or with any with any structure

00:38:04,230 --> 00:38:10,020
that is composable sorry combine able

00:38:08,190 --> 00:38:13,590
and trying not the same same agree but

00:38:10,020 --> 00:38:15,120
now i miserable if i Elsa yes okay we

00:38:13,590 --> 00:38:19,140
got it there is a semigroup I'll tell

00:38:15,120 --> 00:38:20,910
you later what it is so as long as you

00:38:19,140 --> 00:38:22,830
are consistent with the type that you

00:38:20,910 --> 00:38:25,470
returned it will be extremely easy to

00:38:22,830 --> 00:38:27,900
compose all these functions together so

00:38:25,470 --> 00:38:30,000
AB work I work in the retail business we

00:38:27,900 --> 00:38:32,310
have creative allocation you guys has no

00:38:30,000 --> 00:38:35,700
idea and that exactly what we have done

00:38:32,310 --> 00:38:38,670
we have done well functions that are

00:38:35,700 --> 00:38:42,450
dedicated to specific fields and we

00:38:38,670 --> 00:38:44,160
compose them there they are dedicated to

00:38:42,450 --> 00:38:46,500
specific case crafts and so on and so

00:38:44,160 --> 00:38:49,150
forth so function composition is the

00:38:46,500 --> 00:38:51,519
Kida so try that

00:38:49,150 --> 00:38:53,859
how will we handle the situation when

00:38:51,519 --> 00:38:56,619
some fields are dependent on one another

00:38:53,859 --> 00:38:58,690
like if you have for example start and

00:38:56,619 --> 00:39:02,319
end date and you want to validate that

00:38:58,690 --> 00:39:06,339
end date is like after start date ok

00:39:02,319 --> 00:39:09,130
I'll show you oh where is the what is it

00:39:06,339 --> 00:39:12,400
what is it this function will just take

00:39:09,130 --> 00:39:14,470
two parameters so if your validation is

00:39:12,400 --> 00:39:16,930
obviously depending the multiple PLC

00:39:14,470 --> 00:39:19,210
it's fun it's just this function there

00:39:16,930 --> 00:39:22,390
is going to be a little bit more

00:39:19,210 --> 00:39:24,759
interesting than this so at some point

00:39:22,390 --> 00:39:27,369
you will have a function that is

00:39:24,759 --> 00:39:28,869
building the validation and that's the

00:39:27,369 --> 00:39:30,549
one that is going to take instead of one

00:39:28,869 --> 00:39:32,950
parameter is going to take two parameter

00:39:30,549 --> 00:39:35,289
so that doesn't does not a problem you

00:39:32,950 --> 00:39:37,089
can have as many parameters well not

00:39:35,289 --> 00:39:40,539
quite but in theory you can have as many

00:39:37,089 --> 00:39:41,710
parameters as you want intervention so

00:39:40,539 --> 00:39:46,019
that bet should work

00:39:41,710 --> 00:39:46,019
any other question

00:39:47,910 --> 00:39:54,570
[Applause]

00:39:52,510 --> 00:39:54,570

YouTube URL: https://www.youtube.com/watch?v=P8nGAo3Jp-Q


