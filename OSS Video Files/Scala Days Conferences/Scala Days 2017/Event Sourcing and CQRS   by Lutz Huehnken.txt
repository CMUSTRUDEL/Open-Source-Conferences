Title: Event Sourcing and CQRS   by Lutz Huehnken
Publication date: 2017-06-23
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Event Sourcing and Command Query Responsibility Segregation (CQRS) have been around for a while, but only now it seems they are really becoming “mainstream”, as they are extremely useful patterns for dealing with your applications state in a scalable way. If you’ve never even heard of them, don’t worry: This talk will give an quick introduction to the concepts of Event Sourcing and CQRS from the ground up. 

Once the basics are clear, we are going to have a close look on a Scala framework for these patterns: The Lagom Persistence module that comes as part of the Lagom Microservices Framework. Not only will you see how Lagom makes it easy to use these patterns with Scala, you will also understand what happens under the hood.

Lastly, we’ll look at some challenges that you may face when applying these patterns, as well as have a quick overview of alternative implementations and what to look for when comparing the approaches.
Captions: 
	00:00:04,430 --> 00:00:09,870
event sourcing and cqs command clearly

00:00:07,799 --> 00:00:11,700
responsibility segregation in scholars I

00:00:09,870 --> 00:00:13,440
want to talk about the basics that the

00:00:11,700 --> 00:00:15,120
fundamental ideas behind event sourcing

00:00:13,440 --> 00:00:17,910
and then I want to show an example how

00:00:15,120 --> 00:00:19,439
to do it with in scala with the

00:00:17,910 --> 00:00:24,150
framework called legume legume

00:00:19,439 --> 00:00:25,650
persistence and I picked a very e all I

00:00:24,150 --> 00:00:27,359
really wanted to get down to the to the

00:00:25,650 --> 00:00:29,670
fundamentals and sort of fades out all

00:00:27,359 --> 00:00:31,740
noise isn't yeah so I picked a very

00:00:29,670 --> 00:00:33,269
simple example what I want to achieve is

00:00:31,740 --> 00:00:35,970
I want to create a table like this this

00:00:33,269 --> 00:00:38,549
is like a scoring table of a football

00:00:35,970 --> 00:00:39,750
league right so I want to see the teams

00:00:38,549 --> 00:00:42,199
and the league how many games they

00:00:39,750 --> 00:00:45,960
played and how many points they've

00:00:42,199 --> 00:00:48,210
accumulated through winning games on any

00:00:45,960 --> 00:00:49,680
relational model so that obviously

00:00:48,210 --> 00:00:50,909
that's pretty straightforward and I

00:00:49,680 --> 00:00:54,510
could just set up a table in the

00:00:50,909 --> 00:00:56,850
database and whenever a team wins I does

00:00:54,510 --> 00:00:58,650
add three to the number of points they

00:00:56,850 --> 00:01:00,150
have but I don't want to use a

00:00:58,650 --> 00:01:02,040
relational database and there are at

00:01:00,150 --> 00:01:05,510
least three reasons I can think of why I

00:01:02,040 --> 00:01:07,980
don't want to use a relational database

00:01:05,510 --> 00:01:10,650
the relational model and the models we

00:01:07,980 --> 00:01:12,810
use on our languages usually are not a

00:01:10,650 --> 00:01:14,910
perfect fit right there's there's always

00:01:12,810 --> 00:01:18,630
a mismatch the structures we use a

00:01:14,910 --> 00:01:22,860
memory trees subclasses hash tables they

00:01:18,630 --> 00:01:24,360
don't have a a clear representation in

00:01:22,860 --> 00:01:26,730
the database there's always some some

00:01:24,360 --> 00:01:28,350
weird mapping going on so what we do or

00:01:26,730 --> 00:01:32,040
what people usually do is use object

00:01:28,350 --> 00:01:33,690
relational mapper z-- but they are leaky

00:01:32,040 --> 00:01:35,070
write this term leaky abstractions

00:01:33,690 --> 00:01:37,340
you've probably heard that I was coined

00:01:35,070 --> 00:01:39,300
I think by Joel Spolsky and it's about

00:01:37,340 --> 00:01:42,270
abstractions that abstract something

00:01:39,300 --> 00:01:43,770
away but to use it properly you still

00:01:42,270 --> 00:01:46,080
have to know what's going on underneath

00:01:43,770 --> 00:01:47,190
if you use you probably or if you've

00:01:46,080 --> 00:01:48,720
done that if you use hibernate for

00:01:47,190 --> 00:01:50,880
example you set it up you set up your

00:01:48,720 --> 00:01:52,380
model it's all very nice and abstract if

00:01:50,880 --> 00:01:54,150
you don't have to care about the mapping

00:01:52,380 --> 00:01:55,710
in the database at all then you run your

00:01:54,150 --> 00:01:59,370
application and you have a lazy

00:01:55,710 --> 00:02:01,260
initialization exception right um so at

00:01:59,370 --> 00:02:02,640
this point you have to think about what

00:02:01,260 --> 00:02:05,010
happens underneath where are the things

00:02:02,640 --> 00:02:06,810
actually loaded and this can get complex

00:02:05,010 --> 00:02:09,119
very quickly and actually be a lot of

00:02:06,810 --> 00:02:11,670
noise in your project this guy by the

00:02:09,119 --> 00:02:14,400
way if you google oh I am you might find

00:02:11,670 --> 00:02:16,590
this guy this is all Mario's it's the

00:02:14,400 --> 00:02:19,390
evil brother of Akram

00:02:16,590 --> 00:02:21,580
and he has very nice description on the

00:02:19,390 --> 00:02:23,769
Wikipedia page it says he started off as

00:02:21,580 --> 00:02:25,989
a pirate attacking ships but then he

00:02:23,769 --> 00:02:27,970
went on to creating natural disasters

00:02:25,989 --> 00:02:29,739
and this is the feeling I have when they

00:02:27,970 --> 00:02:32,080
use object-relational members and the

00:02:29,739 --> 00:02:35,680
beginnings just mapping some classes but

00:02:32,080 --> 00:02:37,810
it ends in natural disaster scaling

00:02:35,680 --> 00:02:39,549
scaling we all love we all want to write

00:02:37,810 --> 00:02:43,530
scalable applications we're going to be

00:02:39,549 --> 00:02:45,610
reactive we're on a scale infinitely

00:02:43,530 --> 00:02:48,220
relational databases are usually about

00:02:45,610 --> 00:02:49,569
scaling up if you need more power you

00:02:48,220 --> 00:02:53,349
buy a bigger server from the sky

00:02:49,569 --> 00:02:54,670
possibly scaling the reach so the weeds

00:02:53,349 --> 00:02:57,160
of the database it's not even that

00:02:54,670 --> 00:02:59,200
difficult you can just run followers or

00:02:57,160 --> 00:03:01,540
replicas and distribute reads over them

00:02:59,200 --> 00:03:03,430
but because of the transactional nature

00:03:01,540 --> 00:03:05,170
and the consistency guarantees of the

00:03:03,430 --> 00:03:06,940
relational database you need some

00:03:05,170 --> 00:03:09,069
central coordination for the rights so

00:03:06,940 --> 00:03:11,200
usually have a central master that needs

00:03:09,069 --> 00:03:13,840
for the right side if you overload if

00:03:11,200 --> 00:03:16,120
your master becomes too weak for it if

00:03:13,840 --> 00:03:17,620
you have to scale the right side that

00:03:16,120 --> 00:03:20,139
becomes very difficult you have to do

00:03:17,620 --> 00:03:22,209
sharding so you have to divide your de

00:03:20,139 --> 00:03:23,739
town on different masters and that's

00:03:22,209 --> 00:03:25,569
usually difficult with the relational

00:03:23,739 --> 00:03:27,010
model because you probably have some

00:03:25,569 --> 00:03:29,049
joins and then you have to deal with

00:03:27,010 --> 00:03:30,819
what you have to set it up in a way that

00:03:29,049 --> 00:03:33,370
the drawings don't span the farm and

00:03:30,819 --> 00:03:34,870
that's it and also you want to do this

00:03:33,370 --> 00:03:36,849
dynamically right you want to be able to

00:03:34,870 --> 00:03:38,470
add service and remove service at one

00:03:36,849 --> 00:03:40,209
time that's what we want to do like we

00:03:38,470 --> 00:03:42,180
can do with a car cluster we want to be

00:03:40,209 --> 00:03:45,370
able to breathe and according to load

00:03:42,180 --> 00:03:47,410
scale out or scale in the better world

00:03:45,370 --> 00:03:50,200
so that's difficult on the read side

00:03:47,410 --> 00:03:51,970
with relational databases and then often

00:03:50,200 --> 00:03:54,130
we have business requirements that

00:03:51,970 --> 00:03:56,200
really don't match the some of the

00:03:54,130 --> 00:03:58,000
essence of the relational model well in

00:03:56,200 --> 00:03:59,889
relational databases we have destructive

00:03:58,000 --> 00:04:01,329
operations like you can update stuff

00:03:59,889 --> 00:04:03,310
with waiting means over bite something

00:04:01,329 --> 00:04:06,910
forget the old stuff take the new data

00:04:03,310 --> 00:04:08,769
or you can delete stuff now often people

00:04:06,910 --> 00:04:10,419
start with a very simple model say ok

00:04:08,769 --> 00:04:12,579
alright this is our we have this nice

00:04:10,419 --> 00:04:14,349
relational model and then so we've in

00:04:12,579 --> 00:04:16,450
the cost of the project project they

00:04:14,349 --> 00:04:18,579
discover oh actually we don't want to

00:04:16,450 --> 00:04:21,370
delete stuff we just want them so mark

00:04:18,579 --> 00:04:23,320
it delete it so you subtract the

00:04:21,370 --> 00:04:24,880
lifecycle and say no we don't really

00:04:23,320 --> 00:04:26,289
believe you just introduced a marker and

00:04:24,880 --> 00:04:28,539
they figure out oh no I think I also

00:04:26,289 --> 00:04:29,650
want to see who changed this so and and

00:04:28,539 --> 00:04:33,610
when it was changed

00:04:29,650 --> 00:04:35,290
you create like lifecycle columns what

00:04:33,610 --> 00:04:37,509
was it created who created it when was

00:04:35,290 --> 00:04:39,699
the change and so on and you might end

00:04:37,509 --> 00:04:42,729
up having a complete audit table just

00:04:39,699 --> 00:04:44,650
tracking all the changes to to one table

00:04:42,729 --> 00:04:47,080
maybe using something like happiness and

00:04:44,650 --> 00:04:48,580
hibernate envers which is all all in

00:04:47,080 --> 00:04:52,660
good faith and it's great work that

00:04:48,580 --> 00:04:54,280
people do but it's it shouldn't be all

00:04:52,660 --> 00:04:56,590
this extra work right it should come

00:04:54,280 --> 00:04:58,840
more naturally so if you want to keep

00:04:56,590 --> 00:05:00,639
the history of your data then it should

00:04:58,840 --> 00:05:02,830
you shouldn't go through all these loops

00:05:00,639 --> 00:05:05,110
and loops and have to do all this extra

00:05:02,830 --> 00:05:06,970
X work to keep it and they're actually

00:05:05,110 --> 00:05:09,550
quite a lot of use cases where we have

00:05:06,970 --> 00:05:11,560
this or like in real life on programming

00:05:09,550 --> 00:05:14,169
we have a lot of scenario where we want

00:05:11,560 --> 00:05:15,729
to keep all the story cos data maybe we

00:05:14,169 --> 00:05:17,850
can make this a bit interactive maybe

00:05:15,729 --> 00:05:20,050
somebody can think of an example

00:05:17,850 --> 00:05:22,720
something where we want to keep these

00:05:20,050 --> 00:05:25,470
sort of the all changes historically and

00:05:22,720 --> 00:05:25,470
never throw anything away

00:05:26,759 --> 00:05:32,380
so we account balance in in a bank

00:05:31,000 --> 00:05:34,810
account the account balancing yeah I

00:05:32,380 --> 00:05:36,990
guess that with my bank would just tell

00:05:34,810 --> 00:05:39,789
me your account balances a thousand-euro

00:05:36,990 --> 00:05:41,800
that would be I would be curious like

00:05:39,789 --> 00:05:44,260
how I thought it was mm how did it come

00:05:41,800 --> 00:05:46,389
to be so the balance will always be the

00:05:44,260 --> 00:05:47,800
result of the transactions that happened

00:05:46,389 --> 00:05:50,080
right in my bank statement will always

00:05:47,800 --> 00:05:52,720
show what came in and came out and

00:05:50,080 --> 00:05:56,409
sexiness this flow of events that

00:05:52,720 --> 00:05:57,970
creates the balance another example so a

00:05:56,409 --> 00:05:59,139
very technical example would be version

00:05:57,970 --> 00:06:01,780
control and in software development

00:05:59,139 --> 00:06:03,849
right we don't just replace obviously a

00:06:01,780 --> 00:06:06,280
versions on the server or in our github

00:06:03,849 --> 00:06:09,940
repository we keep the history we can

00:06:06,280 --> 00:06:11,320
see all changes that we ever applied so

00:06:09,940 --> 00:06:15,190
bank statement was already mentioned as

00:06:11,320 --> 00:06:16,840
an example cargo tracking they were oh

00:06:15,190 --> 00:06:20,260
sorry that was too quick

00:06:16,840 --> 00:06:21,849
cargo tracking is something with their

00:06:20,260 --> 00:06:23,409
way sort of the events are much more

00:06:21,849 --> 00:06:25,419
interesting than the actual state like

00:06:23,409 --> 00:06:28,300
the state is true it's either either I

00:06:25,419 --> 00:06:30,580
already have it and I know the state is

00:06:28,300 --> 00:06:32,229
there or I don't and it's either in

00:06:30,580 --> 00:06:33,430
transit or its lost ok that is a bit

00:06:32,229 --> 00:06:35,680
interesting that's the difference

00:06:33,430 --> 00:06:37,270
between this but usually you want to see

00:06:35,680 --> 00:06:38,800
you get these tracking points they're

00:06:37,270 --> 00:06:42,650
scanned at certain HAP's and then you

00:06:38,800 --> 00:06:44,720
can you can see the the flow or

00:06:42,650 --> 00:06:47,240
Picaro and this that's what you're

00:06:44,720 --> 00:06:51,050
interested in or this is supposed to be

00:06:47,240 --> 00:06:52,639
like an accounting ledger in any firm do

00:06:51,050 --> 00:06:54,110
in in accounting

00:06:52,639 --> 00:06:55,580
there's the sing accountants never

00:06:54,110 --> 00:06:57,350
delete or they don't have a new a so I

00:06:55,580 --> 00:06:58,850
think the saying goes because they're

00:06:57,350 --> 00:07:00,919
not I think you're not even legally

00:06:58,850 --> 00:07:02,330
allowed to do that like if if I send it

00:07:00,919 --> 00:07:05,570
invoice to somebody and they book this

00:07:02,330 --> 00:07:07,910
invoice and it's in the books and then I

00:07:05,570 --> 00:07:10,100
realize I made a mistake and actually I

00:07:07,910 --> 00:07:12,289
get less money or whatever I cannot just

00:07:10,100 --> 00:07:14,479
say oh please undo this invoice and and

00:07:12,289 --> 00:07:16,699
let's change the amount there I have to

00:07:14,479 --> 00:07:18,350
write another sort of cancel invoice on

00:07:16,699 --> 00:07:20,000
invoice cancellation I have to write a

00:07:18,350 --> 00:07:22,310
new invoice because it all sort of you

00:07:20,000 --> 00:07:24,260
can only sort of do you can cancel

00:07:22,310 --> 00:07:25,880
bookings and you can have compensating

00:07:24,260 --> 00:07:27,800
bookings but you cannot just go back in

00:07:25,880 --> 00:07:29,930
time and pretend something didn't happen

00:07:27,800 --> 00:07:33,080
because that's also how life work that's

00:07:29,930 --> 00:07:36,080
how time works time goes on we cannot

00:07:33,080 --> 00:07:38,210
just go back in time and sometimes we

00:07:36,080 --> 00:07:42,560
wish we could probably just undo things

00:07:38,210 --> 00:07:45,259
but also in real life when something has

00:07:42,560 --> 00:07:47,539
happened it has happened and the the

00:07:45,259 --> 00:07:49,910
time goes on so this is all this exactly

00:07:47,539 --> 00:07:51,740
something I can talk about for hours so

00:07:49,910 --> 00:07:54,680
one of the issues if you're used to

00:07:51,740 --> 00:07:56,360
using the relational model then it can

00:07:54,680 --> 00:08:00,560
become a bit more difficult to go in

00:07:56,360 --> 00:08:02,360
towards a eventsource direction but I

00:08:00,560 --> 00:08:04,490
think that's for me that's part of the

00:08:02,360 --> 00:08:06,289
fascination of it when I think back so

00:08:04,490 --> 00:08:08,030
computer science was great programming

00:08:06,289 --> 00:08:10,039
suite because we always learn new stuff

00:08:08,030 --> 00:08:12,199
there's always something new to discover

00:08:10,039 --> 00:08:15,530
new libraries new frameworks like the

00:08:12,199 --> 00:08:17,840
ROM or new technologies but the most

00:08:15,530 --> 00:08:19,849
interesting bits for me are the ones

00:08:17,840 --> 00:08:21,800
that actually make you unlearn something

00:08:19,849 --> 00:08:23,030
it's not only about the learning when

00:08:21,800 --> 00:08:25,130
you learn something you sort of put it

00:08:23,030 --> 00:08:26,780
in place and your worldview and you say

00:08:25,130 --> 00:08:28,340
ok I'll read something you it fits in

00:08:26,780 --> 00:08:29,990
there this place sometimes you learn

00:08:28,340 --> 00:08:31,400
something that actually contradicts

00:08:29,990 --> 00:08:33,380
something you learned before and you

00:08:31,400 --> 00:08:35,060
have to unlearn maybe if you've done a

00:08:33,380 --> 00:08:37,640
lot of imperative programming you learn

00:08:35,060 --> 00:08:39,560
functional you feel like ok if I just

00:08:37,640 --> 00:08:41,029
apply the patterns that I'm used to in

00:08:39,560 --> 00:08:42,740
this new paradigm that doesn't really

00:08:41,029 --> 00:08:44,660
work I have to change my mindset I have

00:08:42,740 --> 00:08:46,910
to unlearn what I've learned if you go

00:08:44,660 --> 00:08:48,680
from some sequential programming to

00:08:46,910 --> 00:08:49,850
working with actors and messages you

00:08:48,680 --> 00:08:53,420
have to unlearn if you go from

00:08:49,850 --> 00:08:54,290
relational to to an event source

00:08:53,420 --> 00:08:56,720
approach

00:08:54,290 --> 00:08:58,790
it's the you're going to see that so the

00:08:56,720 --> 00:09:01,220
technical part is actually more or less

00:08:58,790 --> 00:09:02,840
trivial it's more than mind setting

00:09:01,220 --> 00:09:05,960
unlearning what we're used to

00:09:02,840 --> 00:09:10,310
so forget I forget the data mo is also

00:09:05,960 --> 00:09:12,740
something in I don't know if it's just

00:09:10,310 --> 00:09:14,630
me or if it happens everybody but often

00:09:12,740 --> 00:09:17,210
in when we're designing systems were

00:09:14,630 --> 00:09:19,460
discussing systems and system design

00:09:17,210 --> 00:09:21,260
system architecture we jump to the

00:09:19,460 --> 00:09:23,750
domain model and so the aesthetic

00:09:21,260 --> 00:09:25,640
representation of our domain and data

00:09:23,750 --> 00:09:28,910
structures so quickly we sort of we

00:09:25,640 --> 00:09:30,650
really very fast we start thinking about

00:09:28,910 --> 00:09:33,020
the entities we're going to have and so

00:09:30,650 --> 00:09:35,240
their structure rather than having this

00:09:33,020 --> 00:09:37,310
then focusing on the dynamic properties

00:09:35,240 --> 00:09:39,500
of the system what events actually

00:09:37,310 --> 00:09:41,510
occurring in the system I think this is

00:09:39,500 --> 00:09:43,910
a trend now that people change the way

00:09:41,510 --> 00:09:45,680
they design systems and in this whole

00:09:43,910 --> 00:09:46,790
domain driven design community and

00:09:45,680 --> 00:09:49,820
especially if you do something like

00:09:46,790 --> 00:09:51,620
event storming you don't think about if

00:09:49,820 --> 00:09:54,410
you try not to design your data

00:09:51,620 --> 00:09:56,420
structures at all almost it's more about

00:09:54,410 --> 00:09:58,880
following the events that happen in your

00:09:56,420 --> 00:10:01,760
system and then you hope or you you work

00:09:58,880 --> 00:10:03,760
towards the boundaries emerging when you

00:10:01,760 --> 00:10:06,200
figure out okay to process this event

00:10:03,760 --> 00:10:07,970
whoever receives this event also needs

00:10:06,200 --> 00:10:09,920
to know this and this and it has to have

00:10:07,970 --> 00:10:11,480
a certain knowledge to maybe to validate

00:10:09,920 --> 00:10:13,880
something that comes in so there is a

00:10:11,480 --> 00:10:15,710
boundary where I have a cohesion where I

00:10:13,880 --> 00:10:17,720
have to put things together but it's

00:10:15,710 --> 00:10:19,880
actually this event can be processed

00:10:17,720 --> 00:10:21,680
without knowing of anything else that

00:10:19,880 --> 00:10:24,110
happened in the system so there's a nice

00:10:21,680 --> 00:10:25,520
boundary there although if you start

00:10:24,110 --> 00:10:29,720
from static model maybe you would have

00:10:25,520 --> 00:10:32,750
put it into one so going to what event

00:10:29,720 --> 00:10:35,600
sourcing is a lot about or can influence

00:10:32,750 --> 00:10:37,100
your your style your design way beyond

00:10:35,600 --> 00:10:39,920
the actual coding like I can also

00:10:37,100 --> 00:10:41,570
influence cancel back propagate what's

00:10:39,920 --> 00:10:45,080
the design process and your approach

00:10:41,570 --> 00:10:47,450
towards thinking about the system so if

00:10:45,080 --> 00:10:48,710
you haven't I really would recommend

00:10:47,450 --> 00:10:51,230
that you check out that just google

00:10:48,710 --> 00:10:53,900
event storming and so read a bit about

00:10:51,230 --> 00:10:56,780
it and if you have the opportunity try

00:10:53,900 --> 00:11:00,800
it out so back to our little league

00:10:56,780 --> 00:11:02,510
application so I don't just want to sort

00:11:00,800 --> 00:11:05,150
of have this table and just set a number

00:11:02,510 --> 00:11:07,010
of points because I now realized that

00:11:05,150 --> 00:11:08,000
whatever is represented in the sneaked

00:11:07,010 --> 00:11:10,370
table whoever

00:11:08,000 --> 00:11:12,800
is the first or the last or on whichever

00:11:10,370 --> 00:11:15,140
position wherever they are is these

00:11:12,800 --> 00:11:17,240
sequence is a result of events that

00:11:15,140 --> 00:11:19,340
happened and what's the event that

00:11:17,240 --> 00:11:21,740
happened well a football game was played

00:11:19,340 --> 00:11:24,760
right in this case my favorite team had

00:11:21,740 --> 00:11:27,980
a great win it solely deserved victory

00:11:24,760 --> 00:11:31,430
but unfortunately it was one of you in

00:11:27,980 --> 00:11:33,200
that season but and this is what

00:11:31,430 --> 00:11:36,290
occurred this is also interesting what

00:11:33,200 --> 00:11:37,580
is the event so if we again if we think

00:11:36,290 --> 00:11:39,320
in hours with two different ways

00:11:37,580 --> 00:11:41,330
sometimes we have to find grains or two

00:11:39,320 --> 00:11:44,540
technical events like if you have events

00:11:41,330 --> 00:11:45,830
like change this property or so then

00:11:44,540 --> 00:11:47,990
that's probably not a good event the

00:11:45,830 --> 00:11:50,630
event should represent something that

00:11:47,990 --> 00:11:53,270
actually happened right like it could be

00:11:50,630 --> 00:11:55,970
a business event something like lots of

00:11:53,270 --> 00:11:58,130
an event change the address field but

00:11:55,970 --> 00:12:01,130
have an event the customer moved let's

00:11:58,130 --> 00:12:02,750
see event that actually occurred um what

00:12:01,130 --> 00:12:05,390
is an event an event is something that

00:12:02,750 --> 00:12:08,480
happened that's that's going to come

00:12:05,390 --> 00:12:10,370
come back to us later so it's it's kind

00:12:08,480 --> 00:12:12,680
of undisputable there's also it's like

00:12:10,370 --> 00:12:14,900
no point an event happen there's no

00:12:12,680 --> 00:12:16,820
point it's sort of validating it and see

00:12:14,900 --> 00:12:19,790
if it fits into your model because it

00:12:16,820 --> 00:12:20,480
happened an event is a fact at a certain

00:12:19,790 --> 00:12:22,700
point of time

00:12:20,480 --> 00:12:24,620
there's no no going back there's no

00:12:22,700 --> 00:12:26,960
telling that it's kind of undisputed

00:12:24,620 --> 00:12:32,870
that it happened just like in the real

00:12:26,960 --> 00:12:35,180
world yeah but how do we implement this

00:12:32,870 --> 00:12:36,710
so we have to break it down a bit

00:12:35,180 --> 00:12:38,900
further we're just that's a bit too

00:12:36,710 --> 00:12:40,610
magic we say okay these events happen in

00:12:38,900 --> 00:12:42,980
the real world and we're just going to

00:12:40,610 --> 00:12:44,690
sort of aggregate these events somehow

00:12:42,980 --> 00:12:46,760
and then we have some state of course we

00:12:44,690 --> 00:12:49,310
have a program where things come in and

00:12:46,760 --> 00:12:51,080
we have to capture the state somehow and

00:12:49,310 --> 00:12:54,200
and we're going to track these events so

00:12:51,080 --> 00:12:56,600
if we break this down a bit we're going

00:12:54,200 --> 00:12:59,210
to have some some commands coming in

00:12:56,600 --> 00:13:01,339
right so that would be a user

00:12:59,210 --> 00:13:03,740
interaction for example or a request to

00:13:01,339 --> 00:13:06,560
your web service and that would express

00:13:03,740 --> 00:13:08,570
some intention I would say in my case it

00:13:06,560 --> 00:13:11,089
would be maybe we caught this game this

00:13:08,570 --> 00:13:13,220
is the result of this game play please

00:13:11,089 --> 00:13:15,050
check the result of this game please at

00:13:13,220 --> 00:13:19,130
this game to the table and I'm going to

00:13:15,050 --> 00:13:21,150
send this event to something this could

00:13:19,130 --> 00:13:22,290
be let's well maybe aggregate

00:13:21,150 --> 00:13:23,850
maybe the best thing sort of the most

00:13:22,290 --> 00:13:25,560
neutral name for it so domain-driven

00:13:23,850 --> 00:13:28,860
design people would call it aggregate in

00:13:25,560 --> 00:13:31,040
legume it's called persistent entity in

00:13:28,860 --> 00:13:33,330
archive will be a persistent actor er um

00:13:31,040 --> 00:13:34,800
so let's not focus on the name so much

00:13:33,330 --> 00:13:38,360
but we have something that we siege the

00:13:34,800 --> 00:13:40,560
event um that we seize the command it

00:13:38,360 --> 00:13:43,590
can process the command if it's a better

00:13:40,560 --> 00:13:46,020
command it will accomplish or omit or

00:13:43,590 --> 00:13:47,910
whatever an event and this event will

00:13:46,020 --> 00:13:50,790
have will be recorded we're going to

00:13:47,910 --> 00:13:52,860
store this event so we can replay the

00:13:50,790 --> 00:13:54,510
events later and it will modify the

00:13:52,860 --> 00:13:58,140
state so this is going to be this is the

00:13:54,510 --> 00:14:00,750
same entity this yellow thing right it

00:13:58,140 --> 00:14:04,200
starts off in state a an event happens

00:14:00,750 --> 00:14:05,910
it's going to have a new state and so

00:14:04,200 --> 00:14:07,500
the nice thing about this and now I'm

00:14:05,910 --> 00:14:09,330
going to show how this is coded with

00:14:07,500 --> 00:14:11,670
logon persistence part of the DES gum

00:14:09,330 --> 00:14:13,290
framework and I change this as an

00:14:11,670 --> 00:14:15,720
example because if we have this picture

00:14:13,290 --> 00:14:18,630
in mind we can sort of we can literally

00:14:15,720 --> 00:14:20,610
just sort of form some automatically

00:14:18,630 --> 00:14:22,440
translate this in the gum constructs we

00:14:20,610 --> 00:14:25,500
have classes for commands for events for

00:14:22,440 --> 00:14:28,200
the state and the framework will keep

00:14:25,500 --> 00:14:30,000
take care of tracking those events so I

00:14:28,200 --> 00:14:33,570
think next we're going to look at some

00:14:30,000 --> 00:14:34,890
code yeah I I also I it's a really well

00:14:33,570 --> 00:14:36,510
obviously the simple example I don't

00:14:34,890 --> 00:14:38,250
know how interesting the code is but if

00:14:36,510 --> 00:14:41,640
you want to look at the code on your own

00:14:38,250 --> 00:14:46,800
machine that will be the github repo for

00:14:41,640 --> 00:14:48,690
the example for this talk let's see so

00:14:46,800 --> 00:14:50,550
remember this we have a command we have

00:14:48,690 --> 00:14:54,330
an aggregate it's going to image events

00:14:50,550 --> 00:14:56,010
and it has some state so let's look at

00:14:54,330 --> 00:14:57,780
the command first I don't know how

00:14:56,010 --> 00:14:59,550
familiar you guys are with with our

00:14:57,780 --> 00:15:01,650
persistence for example over the other

00:14:59,550 --> 00:15:02,730
with our correct our messaging and so on

00:15:01,650 --> 00:15:04,290
so I'm going to find out some

00:15:02,730 --> 00:15:05,790
differences to occur if you don't know

00:15:04,290 --> 00:15:08,130
like I don't worry about it it's not

00:15:05,790 --> 00:15:11,550
important if you know account you may or

00:15:08,130 --> 00:15:13,130
may not find it interesting so the

00:15:11,550 --> 00:15:15,420
commands are messages we send to our

00:15:13,130 --> 00:15:16,860
aggregates and you see here well they're

00:15:15,420 --> 00:15:21,450
just simply say paste classes right

00:15:16,860 --> 00:15:22,860
they're just just like echo messages or

00:15:21,450 --> 00:15:25,110
anything else you just use the case

00:15:22,860 --> 00:15:27,630
class to send your command it has to be

00:15:25,110 --> 00:15:29,100
serializable obviously we want to want

00:15:27,630 --> 00:15:30,390
to send it over the wire we also want to

00:15:29,100 --> 00:15:32,880
be but in this case we don't want to

00:15:30,390 --> 00:15:34,589
store it may be interesting here is that

00:15:32,880 --> 00:15:37,709
we have to extend this

00:15:34,589 --> 00:15:39,119
trade your reply type so when we define

00:15:37,709 --> 00:15:42,599
our planet so this is like a little

00:15:39,119 --> 00:15:44,879
legume thing when we define our command

00:15:42,599 --> 00:15:47,609
we also define what the type of the

00:15:44,879 --> 00:15:49,379
answer through this command will be this

00:15:47,609 --> 00:15:50,999
allows the compiler to do some

00:15:49,379 --> 00:15:52,739
additional type tracking so at the point

00:15:50,999 --> 00:15:54,869
where I sent the command through my

00:15:52,739 --> 00:15:57,599
aggregate I can I already know the type

00:15:54,869 --> 00:16:00,539
of the resultant so I can process it in

00:15:57,599 --> 00:16:04,019
a type safe fashion but that's raining

00:16:00,539 --> 00:16:08,039
so in my case here um these are just

00:16:04,019 --> 00:16:09,749
post the status just posted to the to

00:16:08,039 --> 00:16:12,649
the service so there's no payload that's

00:16:09,749 --> 00:16:15,209
going to be sent back we just

00:16:12,649 --> 00:16:21,899
acknowledge the command so we just say

00:16:15,209 --> 00:16:23,369
done when we posted this process it also

00:16:21,899 --> 00:16:25,769
we're going to define a couple of events

00:16:23,369 --> 00:16:29,159
again very straightforward just case

00:16:25,769 --> 00:16:31,439
classes right each event again you have

00:16:29,159 --> 00:16:35,099
to have a sort of a common super type

00:16:31,439 --> 00:16:36,779
and it was the one thing that we're also

00:16:35,099 --> 00:16:39,359
going to come back later is attack and

00:16:36,779 --> 00:16:41,159
we're going to tag these events because

00:16:39,359 --> 00:16:42,720
well they I will come back to this later

00:16:41,159 --> 00:16:45,659
let's get this reminder huh all these

00:16:42,720 --> 00:16:48,119
events they share a common tag what's

00:16:45,659 --> 00:16:49,889
next I don't know oh yeah and then the

00:16:48,119 --> 00:16:53,899
state in this case so what do you keep a

00:16:49,889 --> 00:16:57,179
state in your aggregates of at runtime

00:16:53,899 --> 00:16:59,039
whether you need to have the stuff that

00:16:57,179 --> 00:17:00,509
you need to validate the commands right

00:16:59,039 --> 00:17:02,339
so you here you can see the state is

00:17:00,509 --> 00:17:04,409
much simpler than the result we want to

00:17:02,339 --> 00:17:05,939
see in the end we want to see a slug is

00:17:04,409 --> 00:17:08,610
saw the table with the point and so on

00:17:05,939 --> 00:17:10,379
at this point we just keep a set of the

00:17:08,610 --> 00:17:13,079
games we already know so we just want to

00:17:10,379 --> 00:17:16,049
validate if there are duplicate entries

00:17:13,079 --> 00:17:17,939
if I'm told to recall the game and

00:17:16,049 --> 00:17:19,709
that's already been recorded or somebody

00:17:17,939 --> 00:17:21,990
wants to add a club to the Nick table

00:17:19,709 --> 00:17:24,720
but it's already I can only be 18 clubs

00:17:21,990 --> 00:17:25,949
in this or in this model that can so we

00:17:24,720 --> 00:17:27,299
have to keep track of the clubs we

00:17:25,949 --> 00:17:30,080
already know and of the games we've

00:17:27,299 --> 00:17:32,580
already recorded but in what sort of

00:17:30,080 --> 00:17:34,049
that doesn't have to be any structure to

00:17:32,580 --> 00:17:35,360
it we just need this to validate the

00:17:34,049 --> 00:17:38,290
commands and to check for these

00:17:35,360 --> 00:17:42,440
validations of that set so yeah maybe

00:17:38,290 --> 00:17:46,169
[Music]

00:17:42,440 --> 00:17:47,850
let's look at our aggregate or ours of

00:17:46,169 --> 00:17:50,340
persistent entity

00:17:47,850 --> 00:17:51,240
so in the gun it the gun prescribes a

00:17:50,340 --> 00:17:52,980
certain structure for this

00:17:51,240 --> 00:17:55,290
implementation that is what makes it so

00:17:52,980 --> 00:17:57,750
easy as well so because it guides you as

00:17:55,290 --> 00:18:00,150
I said if you look at this command my

00:17:57,750 --> 00:18:02,040
aggregate the events thing you have some

00:18:00,150 --> 00:18:03,750
immediate representations into the bomb

00:18:02,040 --> 00:18:05,760
framework and you actually have to

00:18:03,750 --> 00:18:07,530
configure your persistent entity to know

00:18:05,760 --> 00:18:09,240
about these so you have to define these

00:18:07,530 --> 00:18:10,710
types you have to tell it what your

00:18:09,240 --> 00:18:14,820
command type is what the event type is

00:18:10,710 --> 00:18:16,830
and what your status and everything is

00:18:14,820 --> 00:18:18,660
just sort of setting it up and then we

00:18:16,830 --> 00:18:22,470
define the behavior pretty much like a

00:18:18,660 --> 00:18:24,300
receive log in an actor but an esper

00:18:22,470 --> 00:18:27,480
okay that has uses slightly different

00:18:24,300 --> 00:18:30,660
mechanics and here we have we define

00:18:27,480 --> 00:18:33,660
command handlers right so whenever I get

00:18:30,660 --> 00:18:36,420
a act so I don't know if you if you read

00:18:33,660 --> 00:18:39,600
that carefully you've seen we have three

00:18:36,420 --> 00:18:41,370
commands at a club at a game and change

00:18:39,600 --> 00:18:43,380
the game so I can add a club to the

00:18:41,370 --> 00:18:45,150
league I can add game actually if I add

00:18:43,380 --> 00:18:46,770
a game and the club is unknown then it

00:18:45,150 --> 00:18:48,240
will just automatically oh that's what

00:18:46,770 --> 00:18:50,910
we're going to see in the code so I can

00:18:48,240 --> 00:18:51,570
add a club I will validate if this is if

00:18:50,910 --> 00:18:53,640
I'm going to scroll down

00:18:51,570 --> 00:18:55,680
very simple validation I'm just going to

00:18:53,640 --> 00:18:58,410
check if the club is already in my table

00:18:55,680 --> 00:19:00,060
then I say no this is invalid it's a

00:18:58,410 --> 00:19:01,830
duplicate entry and I'm going to admit

00:19:00,060 --> 00:19:05,280
an error otherwise something else just

00:19:01,830 --> 00:19:09,060
gonna add the club so validate the

00:19:05,280 --> 00:19:10,530
command if it's fine no if it's if it's

00:19:09,060 --> 00:19:18,270
an error if it's an invalid command just

00:19:10,530 --> 00:19:22,560
reject it and otherwise uh-huh I want to

00:19:18,270 --> 00:19:24,750
persist an event so my validation gives

00:19:22,560 --> 00:19:27,330
me back either an error well it gives me

00:19:24,750 --> 00:19:30,420
back either an error message or it gives

00:19:27,330 --> 00:19:32,730
me back an event or a number of events I

00:19:30,420 --> 00:19:34,560
want to store the events that that I'm

00:19:32,730 --> 00:19:36,720
going to let I accomplish so in this

00:19:34,560 --> 00:19:39,540
case if everything's fine I'm going to I

00:19:36,720 --> 00:19:41,070
want to emit this club edit event so I

00:19:39,540 --> 00:19:43,590
want to persist this event and then I

00:19:41,070 --> 00:19:45,420
can do some some other stuff once the

00:19:43,590 --> 00:19:48,770
event is persisted to for example

00:19:45,420 --> 00:19:48,770
replying back everything went fine

00:19:48,980 --> 00:19:53,130
that's basically what we're doing here

00:19:50,670 --> 00:19:55,050
so if I add a game you can see okay here

00:19:53,130 --> 00:19:57,180
in the validation they can one command

00:19:55,050 --> 00:20:00,960
can result in a number of events it's

00:19:57,180 --> 00:20:02,880
not a one-to-one relationship right so I

00:20:00,960 --> 00:20:04,529
can if I add a game in this okay these

00:20:02,880 --> 00:20:06,090
claps have not been added but for

00:20:04,529 --> 00:20:08,809
convenience I want to add the club's

00:20:06,090 --> 00:20:11,909
automatically I can just say okay to

00:20:08,809 --> 00:20:13,830
them check the game are the claps

00:20:11,909 --> 00:20:15,270
already know or is the game already in

00:20:13,830 --> 00:20:17,640
there then we just reject it otherwise

00:20:15,270 --> 00:20:21,120
see if the clubs are already in there

00:20:17,640 --> 00:20:23,190
otherwise create a sequence of events

00:20:21,120 --> 00:20:27,600
where we add the clubs that are new to

00:20:23,190 --> 00:20:30,809
the system and the game and I also have

00:20:27,600 --> 00:20:32,909
a change game thing if well I said we

00:20:30,809 --> 00:20:34,200
could just want to keep a log of events

00:20:32,909 --> 00:20:36,960
like we don't really want to change I

00:20:34,200 --> 00:20:41,190
said events are facts that happened and

00:20:36,960 --> 00:20:43,529
we can't go back and and undo them but

00:20:41,190 --> 00:20:46,320
maybe I recorded a wrong result and I

00:20:43,529 --> 00:20:48,299
need to change it so this business case

00:20:46,320 --> 00:20:49,919
of course can happen in an events or

00:20:48,299 --> 00:20:52,289
system but I would do is I would have a

00:20:49,919 --> 00:20:57,539
cancellation event I would say okay in

00:20:52,289 --> 00:20:59,429
this in this case I would just create an

00:20:57,539 --> 00:21:01,679
event result revoked I'm saying okay

00:20:59,429 --> 00:21:04,470
this this previous result sexually has

00:21:01,679 --> 00:21:07,770
become invalid and I will add a new game

00:21:04,470 --> 00:21:09,210
afterwards so yeah you see it's pretty

00:21:07,770 --> 00:21:10,919
straight forward so this is how the

00:21:09,210 --> 00:21:12,299
commands are handled and the command

00:21:10,919 --> 00:21:14,070
doesn't really change the command

00:21:12,299 --> 00:21:16,320
handler didn't change the state at all

00:21:14,070 --> 00:21:18,059
right it just validates the command

00:21:16,320 --> 00:21:21,179
maybe does some other stuff maybe it

00:21:18,059 --> 00:21:22,830
sends some message somewhere or I don't

00:21:21,179 --> 00:21:26,130
know there's some side effective things

00:21:22,830 --> 00:21:28,140
and then it will emit events but it

00:21:26,130 --> 00:21:30,840
doesn't touch the state for this we have

00:21:28,140 --> 00:21:33,690
the event handler so in my behavior I

00:21:30,840 --> 00:21:35,520
process the commands and I process I

00:21:33,690 --> 00:21:37,230
define an event handler to handle the

00:21:35,520 --> 00:21:39,809
events the command handler validates the

00:21:37,230 --> 00:21:42,029
command amidst events and the event

00:21:39,809 --> 00:21:44,130
handler changes to state you see again

00:21:42,029 --> 00:21:48,000
these are super trivial adjust they

00:21:44,130 --> 00:21:51,149
literally just create a new copy of the

00:21:48,000 --> 00:21:52,860
state with the change state this is on

00:21:51,149 --> 00:21:55,230
purpose you don't want to do much stuff

00:21:52,860 --> 00:21:57,179
in the in the event handler really the

00:21:55,230 --> 00:21:59,970
one things you want to do is create a

00:21:57,179 --> 00:22:02,490
new version of your state or things you

00:21:59,970 --> 00:22:04,350
certainly don't want to do is you don't

00:22:02,490 --> 00:22:07,020
want have any you don't want to have any

00:22:04,350 --> 00:22:10,799
side effect on or so user affecting

00:22:07,020 --> 00:22:12,779
operations there because when we when we

00:22:10,799 --> 00:22:14,850
restore an entity so the way we're going

00:22:12,779 --> 00:22:15,010
to look at that but the idea of events

00:22:14,850 --> 00:22:18,010
are

00:22:15,010 --> 00:22:19,630
of course it's when we when our entity

00:22:18,010 --> 00:22:21,760
memory craftsman has to be restored

00:22:19,630 --> 00:22:24,400
we're going to replay the events to

00:22:21,760 --> 00:22:26,290
recreate the state we had before and

00:22:24,400 --> 00:22:28,930
this event handler is going to be

00:22:26,290 --> 00:22:31,930
executed on the recreation of events so

00:22:28,930 --> 00:22:34,630
this will all be executed every time we

00:22:31,930 --> 00:22:36,700
basically we create our entity from

00:22:34,630 --> 00:22:38,920
persistent storage so you don't want to

00:22:36,700 --> 00:22:41,410
do these side affecting things every

00:22:38,920 --> 00:22:43,150
time also what you don't want to do is

00:22:41,410 --> 00:22:45,070
any kind of validation there as I said

00:22:43,150 --> 00:22:47,230
there's no point in validating an event

00:22:45,070 --> 00:22:49,660
it happened there's no point it's

00:22:47,230 --> 00:22:51,250
disputing it and saying no this event is

00:22:49,660 --> 00:22:53,500
invalid now there's one other thing

00:22:51,250 --> 00:22:56,050
there's one other thing you could do or

00:22:53,500 --> 00:22:58,480
that that's meaningful to do in the

00:22:56,050 --> 00:22:59,980
event handler that would be but it's not

00:22:58,480 --> 00:23:02,650
in this example that would be changing

00:22:59,980 --> 00:23:04,630
the behavior an entity like this can

00:23:02,650 --> 00:23:06,480
also be like a like a finite state

00:23:04,630 --> 00:23:08,830
machine right you get a certain event

00:23:06,480 --> 00:23:11,380
you change your state but you will also

00:23:08,830 --> 00:23:14,260
change the way you react to subsequent

00:23:11,380 --> 00:23:16,980
events but maybe at some point maybe

00:23:14,260 --> 00:23:19,210
it's a process like a contract that

00:23:16,980 --> 00:23:20,980
starts with an offer then it has to be

00:23:19,210 --> 00:23:23,110
confirmed or accepted or anything maybe

00:23:20,980 --> 00:23:24,820
at some point it's closed and events may

00:23:23,110 --> 00:23:26,610
have different you may have different

00:23:24,820 --> 00:23:28,750
transitions and different events

00:23:26,610 --> 00:23:30,610
initiating these transitions in

00:23:28,750 --> 00:23:32,170
different states but as I said it's not

00:23:30,610 --> 00:23:37,800
at this example so please treat

00:23:32,170 --> 00:23:40,360
forwarding um yeah just for sort of for

00:23:37,800 --> 00:23:43,330
not to leave anything out we need some

00:23:40,360 --> 00:23:45,040
sort of service to set the commands

00:23:43,330 --> 00:23:48,790
through our fermentation there again

00:23:45,040 --> 00:23:52,420
very straightforward its I have a

00:23:48,790 --> 00:23:54,400
registry of all my League entities in

00:23:52,420 --> 00:23:56,620
this case just one I just created one

00:23:54,400 --> 00:23:58,990
for the bundesliga so I'm going to take

00:23:56,620 --> 00:24:05,350
the key for it get this get this entity

00:23:58,990 --> 00:24:07,170
and then I use the ask pattern to send a

00:24:05,350 --> 00:24:09,670
message to it and get the reply back

00:24:07,170 --> 00:24:12,520
little site now this is not the usual

00:24:09,670 --> 00:24:17,020
akka ask this is légumes ask which

00:24:12,520 --> 00:24:19,240
actually automatically casts the result

00:24:17,020 --> 00:24:21,100
to the expected type and this is what I

00:24:19,240 --> 00:24:22,990
think there can be this is one of the

00:24:21,100 --> 00:24:25,270
points where it comes in that we defined

00:24:22,990 --> 00:24:27,520
the reply type on the command because at

00:24:25,270 --> 00:24:28,960
this point of the compiler can check

00:24:27,520 --> 00:24:30,640
that the result of the

00:24:28,960 --> 00:24:34,390
well in this case it's just and again

00:24:30,640 --> 00:24:35,770
but the compiler can check that the

00:24:34,390 --> 00:24:38,620
result that I returned from this

00:24:35,770 --> 00:24:41,020
actually or that I expect you actually

00:24:38,620 --> 00:24:43,420
matches the type that I declared in my

00:24:41,020 --> 00:24:44,680
command so you get some additional type

00:24:43,420 --> 00:24:48,120
tracking there with legoman you could

00:24:44,680 --> 00:24:50,530
say it's poor man's a cut typed um and

00:24:48,120 --> 00:24:52,720
lastly because I have to define some URL

00:24:50,530 --> 00:24:54,940
so I can post some data that's the the

00:24:52,720 --> 00:24:56,800
service descriptor or it's a telegram

00:24:54,940 --> 00:24:58,330
thing we have separate the service

00:24:56,800 --> 00:24:59,830
implementation at the service descriptor

00:24:58,330 --> 00:25:02,110
you see it's a very simple adds

00:24:59,830 --> 00:25:04,930
definition to say okay I can post this I

00:25:02,110 --> 00:25:08,350
can post a clapper game or I can use a

00:25:04,930 --> 00:25:09,910
put operation to change a game and then

00:25:08,350 --> 00:25:16,930
the appropriate server is going to be

00:25:09,910 --> 00:25:22,450
invoked mmm okay let's see if we can

00:25:16,930 --> 00:25:23,860
start this up starting a logo medication

00:25:22,450 --> 00:25:27,180
sucking is always very simple you can

00:25:23,860 --> 00:25:27,180
restart this between save one or

00:25:33,080 --> 00:25:37,830
ding-ding-ding-ding oh I use Cassandra

00:25:35,519 --> 00:25:39,509
to store the events oh yeah we can talk

00:25:37,830 --> 00:25:40,950
about that later it's also the default

00:25:39,509 --> 00:25:44,340
in the gum so it starts of Cassandra

00:25:40,950 --> 00:25:47,479
automatically Oh should be compiling I

00:25:44,340 --> 00:25:52,859
don't know what change that was there so

00:25:47,479 --> 00:25:58,320
now it's running let's connect to the

00:25:52,859 --> 00:25:59,820
Cassandra we go it already created so

00:25:58,320 --> 00:26:02,159
the gum will also dislike a cure

00:25:59,820 --> 00:26:05,879
persistence will automatically create so

00:26:02,159 --> 00:26:08,999
the structures we need in in our

00:26:05,879 --> 00:26:11,700
Cassandra database right now we can see

00:26:08,999 --> 00:26:13,399
the empty or well almost empty there's

00:26:11,700 --> 00:26:15,539
also some state of some of the

00:26:13,399 --> 00:26:17,099
coordinators that the gum uses the state

00:26:15,539 --> 00:26:21,269
of those sorts of persisted in the

00:26:17,099 --> 00:26:26,639
database now I can put some have some

00:26:21,269 --> 00:26:28,440
JSON data here a very simple team it's

00:26:26,639 --> 00:26:30,869
the I just took the first two the

00:26:28,440 --> 00:26:34,200
results of the first game day of that

00:26:30,869 --> 00:26:36,539
league and oh yeah somebody won six no

00:26:34,200 --> 00:26:39,059
and I can just post this to the service

00:26:36,539 --> 00:26:40,590
as I said the payload is just these are

00:26:39,059 --> 00:26:41,789
disposed to quest we just get an

00:26:40,590 --> 00:26:50,009
acknowledgement so there's no

00:26:41,789 --> 00:26:52,080
interesting result but now we can see

00:26:50,009 --> 00:26:55,289
that our system sort of process these

00:26:52,080 --> 00:26:56,999
commands and and recorded these events

00:26:55,289 --> 00:26:58,649
so this is what what's going to end up

00:26:56,999 --> 00:27:02,450
in the Cassandra database these are the

00:26:58,649 --> 00:27:04,859
events that we omit it right you can see

00:27:02,450 --> 00:27:09,299
that there's the payload here this is

00:27:04,859 --> 00:27:12,450
the finis doesn't fall so nicely there's

00:27:09,299 --> 00:27:14,159
the clap edit event um this was the echo

00:27:12,450 --> 00:27:15,450
name of the club and then so we added

00:27:14,159 --> 00:27:20,159
the game there between these two clubs

00:27:15,450 --> 00:27:23,159
and yeah that's basically it so now we

00:27:20,159 --> 00:27:25,320
have rather than having this table with

00:27:23,159 --> 00:27:27,779
the scores and the end of teams we have

00:27:25,320 --> 00:27:31,190
the sequence of the events of the games

00:27:27,779 --> 00:27:33,509
that have actually been saved um

00:27:31,190 --> 00:27:35,340
let's go back quickly and then compare

00:27:33,509 --> 00:27:37,440
this with the previous approach or with

00:27:35,340 --> 00:27:39,779
the so with the relation approach their

00:27:37,440 --> 00:27:40,200
own let's quickly talk about how this

00:27:39,779 --> 00:27:43,679
works

00:27:40,200 --> 00:27:44,820
you saw this maybe you saw this line get

00:27:43,679 --> 00:27:45,740
the reference I'm going to quickly go

00:27:44,820 --> 00:27:48,950
back to that

00:27:45,740 --> 00:27:48,950
[Music]

00:27:51,220 --> 00:27:54,980
what happened to you so we have a

00:27:53,119 --> 00:27:56,840
registry for entities and we get a

00:27:54,980 --> 00:27:58,580
reference for one so what it uses

00:27:56,840 --> 00:28:01,519
underneath is a car cluster sharding

00:27:58,580 --> 00:28:06,169
right in the a the idea is that rather

00:28:01,519 --> 00:28:08,749
than using system actor or more this

00:28:06,169 --> 00:28:11,779
sort of my using actor of to get a new

00:28:08,749 --> 00:28:14,450
actor I I go to a registry I go to a

00:28:11,779 --> 00:28:17,179
repository and I think give me an actor

00:28:14,450 --> 00:28:21,409
for this key right and I always get back

00:28:17,179 --> 00:28:22,759
an actor um and the the actors so I can

00:28:21,409 --> 00:28:24,769
I can create millions of those I can

00:28:22,759 --> 00:28:27,440
just ask for more actors and in a

00:28:24,769 --> 00:28:30,019
cluster a cluster a cluster carding will

00:28:27,440 --> 00:28:32,779
take care of distributing these actors

00:28:30,019 --> 00:28:35,960
in the cluster wide its cluster shouting

00:28:32,779 --> 00:28:37,399
so it creates a number of buckets and

00:28:35,960 --> 00:28:38,840
then put selectors in there and then

00:28:37,399 --> 00:28:43,940
then condition abused these buckets in

00:28:38,840 --> 00:28:46,999
the cluster an interesting point of this

00:28:43,940 --> 00:28:49,639
is so the I will always there will

00:28:46,999 --> 00:28:50,539
always be only one of a certain of an

00:28:49,639 --> 00:28:52,100
actor with a given key

00:28:50,539 --> 00:28:54,679
alright so although it's a distributed

00:28:52,100 --> 00:28:56,330
system if I'm a node a and I get a

00:28:54,679 --> 00:28:57,529
reference or I go for note B and get a

00:28:56,330 --> 00:28:59,389
reference for the Bundys near a table

00:28:57,529 --> 00:29:02,690
for example I would just get the active

00:28:59,389 --> 00:29:04,850
F to the one entity in whichever hard it

00:29:02,690 --> 00:29:06,559
is alright this is a this is very

00:29:04,850 --> 00:29:08,059
interesting from a consistency point of

00:29:06,559 --> 00:29:10,519
view so I cannot have

00:29:08,059 --> 00:29:12,860
I kind of have diverging instances of my

00:29:10,519 --> 00:29:14,749
league I cannot have two instances that

00:29:12,860 --> 00:29:16,700
pressman process commands or maybe

00:29:14,749 --> 00:29:19,399
divert from this state it will always go

00:29:16,700 --> 00:29:21,080
to the very same entity all right so

00:29:19,399 --> 00:29:23,809
that's how our card cluster carding

00:29:21,080 --> 00:29:25,580
works it guarantees the uniqueness it

00:29:23,809 --> 00:29:28,909
gives me dynamically distribution I can

00:29:25,580 --> 00:29:30,080
add nodes I can remove nodes one thing

00:29:28,909 --> 00:29:32,600
that you if you haven't used a cur

00:29:30,080 --> 00:29:34,129
persistence one thing that's that that I

00:29:32,600 --> 00:29:36,889
found remarkable and I started using it

00:29:34,129 --> 00:29:38,330
is that you don't have this idea of like

00:29:36,889 --> 00:29:39,980
in a relational database where you do is

00:29:38,330 --> 00:29:41,809
select and either you have a row with

00:29:39,980 --> 00:29:43,850
this key or not and you either get a

00:29:41,809 --> 00:29:45,559
result bag or not but like a persistence

00:29:43,850 --> 00:29:48,799
you give it a key you can get back an

00:29:45,559 --> 00:29:50,749
actor for this key then when when the

00:29:48,799 --> 00:29:53,659
second instance is created it's going to

00:29:50,749 --> 00:29:56,330
track other events related to this

00:29:53,659 --> 00:29:58,039
entity if there are they're going to be

00:29:56,330 --> 00:30:00,350
replayed and the stage is going to be

00:29:58,039 --> 00:30:03,440
restored that but whatever stated have

00:30:00,350 --> 00:30:05,300
before it was passivated before sort of

00:30:03,440 --> 00:30:08,120
all before the note craft or whatever so

00:30:05,300 --> 00:30:11,420
the stage kept in memory its persistent

00:30:08,120 --> 00:30:14,840
it can be restored but you will always

00:30:11,420 --> 00:30:16,190
get an instance so in another cigarette

00:30:14,840 --> 00:30:18,620
framework we actually have a method to

00:30:16,190 --> 00:30:20,270
check if the instance is new so

00:30:18,620 --> 00:30:22,550
uninitialized or it already has

00:30:20,270 --> 00:30:24,110
associated events so that's something

00:30:22,550 --> 00:30:27,110
that will might affect your programming

00:30:24,110 --> 00:30:29,680
style so it uses a couple assistance

00:30:27,110 --> 00:30:32,150
underneath it's going to be the trance

00:30:29,680 --> 00:30:34,610
it always will always give you an

00:30:32,150 --> 00:30:36,260
instance and will always also manage the

00:30:34,610 --> 00:30:38,630
lifecycle of your instance right so it

00:30:36,260 --> 00:30:40,400
will will keep the state in memory but

00:30:38,630 --> 00:30:42,020
only as long as you use it if you don't

00:30:40,400 --> 00:30:44,510
use it for a certain amount of time will

00:30:42,020 --> 00:30:47,480
s abate this instance basically

00:30:44,510 --> 00:30:49,210
passivation basic meaning expunging it

00:30:47,480 --> 00:30:52,280
for memory like evicting it from memory

00:30:49,210 --> 00:30:54,110
if you use it again ever we created it

00:30:52,280 --> 00:30:55,850
will activate it so it will just the

00:30:54,110 --> 00:30:57,830
process I just described we create a new

00:30:55,850 --> 00:30:59,390
instance of it it will look for any

00:30:57,830 --> 00:31:01,370
events associated with this instance

00:30:59,390 --> 00:31:04,910
we'll replay these events to restore the

00:31:01,370 --> 00:31:06,320
state and well if you have a large

00:31:04,910 --> 00:31:07,640
number of events of course it can take

00:31:06,320 --> 00:31:09,320
some time to restore the state if you

00:31:07,640 --> 00:31:11,570
have thousands and thousands of events

00:31:09,320 --> 00:31:13,970
those would all have to be replayed so

00:31:11,570 --> 00:31:16,280
to optimize this activation it will also

00:31:13,970 --> 00:31:18,440
take snapshots every hundred or so I

00:31:16,280 --> 00:31:20,120
think events it will take a snapshot of

00:31:18,440 --> 00:31:23,270
the state if you remember our state

00:31:20,120 --> 00:31:25,550
class was also serializable the state

00:31:23,270 --> 00:31:29,210
will be serialized and in another tape

00:31:25,550 --> 00:31:31,820
in the snapshot table comparing this

00:31:29,210 --> 00:31:33,020
with relational approach so in the

00:31:31,820 --> 00:31:36,890
relational approach we have this

00:31:33,020 --> 00:31:38,570
impedance or impedance mismatch here if

00:31:36,890 --> 00:31:40,160
you remember this image with the blue

00:31:38,570 --> 00:31:42,560
arrow and the yellow thing is this is a

00:31:40,160 --> 00:31:45,020
one-to-one mapping to the constructs you

00:31:42,560 --> 00:31:46,760
have in Scala or in in the legume

00:31:45,020 --> 00:31:48,950
framework right the commands are

00:31:46,760 --> 00:31:51,170
commands the events are event or the

00:31:48,950 --> 00:31:54,530
commands of Arts or echo messages events

00:31:51,170 --> 00:31:56,870
are events the stage is the state there

00:31:54,530 --> 00:31:57,500
is no mismatch there that's totally

00:31:56,870 --> 00:32:00,740
straightforward

00:31:57,500 --> 00:32:03,380
great alignment in terms of scalability

00:32:00,740 --> 00:32:07,040
as a cluster goes you can scale it

00:32:03,380 --> 00:32:09,290
basically I go infinitely it's that's a

00:32:07,040 --> 00:32:11,300
big word but I think Conrad recently

00:32:09,290 --> 00:32:12,440
talked about in a class of two thousand

00:32:11,300 --> 00:32:14,600
four hundred nodes

00:32:12,440 --> 00:32:16,940
somebody ransomware so you can literally

00:32:14,600 --> 00:32:18,380
scale it to thousands of notes so you

00:32:16,940 --> 00:32:20,240
can scale your right side you can track

00:32:18,380 --> 00:32:22,040
the right side basically with no limits

00:32:20,240 --> 00:32:26,060
there's no single point of failure

00:32:22,040 --> 00:32:28,460
there's no masterful coordination it's

00:32:26,060 --> 00:32:31,400
so tiny elastics think on the tiny

00:32:28,460 --> 00:32:32,810
zillion things can crash instances on a

00:32:31,400 --> 00:32:35,420
note that crashes can just be recreated

00:32:32,810 --> 00:32:39,140
on some other note notes can be added

00:32:35,420 --> 00:32:41,480
notes can be removed and and as we saw

00:32:39,140 --> 00:32:43,370
all the events are always kept so we

00:32:41,480 --> 00:32:46,640
will always have the complete just read

00:32:43,370 --> 00:32:48,230
the complete log of events so it's it's

00:32:46,640 --> 00:32:50,270
a pen only so it's actually also very

00:32:48,230 --> 00:32:53,140
efficient right you don't you don't have

00:32:50,270 --> 00:32:53,140
these destructor

00:32:53,240 --> 00:32:56,330
you don't have these destructive

00:32:54,740 --> 00:32:59,060
operations and you don't have to modify

00:32:56,330 --> 00:33:00,860
on it in place you could basically use a

00:32:59,060 --> 00:33:02,780
file to log all these events because

00:33:00,860 --> 00:33:04,700
you're always only going to append there

00:33:02,780 --> 00:33:07,700
are immutable loads factors operations

00:33:04,700 --> 00:33:09,410
cool so that's all very fine but

00:33:07,700 --> 00:33:12,140
actually we didn't get to actually

00:33:09,410 --> 00:33:14,360
seeing this league table yet right so we

00:33:12,140 --> 00:33:16,010
just just have this log of events but

00:33:14,360 --> 00:33:17,870
this is not how what I want to present

00:33:16,010 --> 00:33:20,930
to my user or this is not what I want to

00:33:17,870 --> 00:33:22,430
see myself I need to have some view of

00:33:20,930 --> 00:33:25,700
the data tree that actually shows me the

00:33:22,430 --> 00:33:27,260
table so with the event sourcing it's

00:33:25,700 --> 00:33:29,360
usually a good idea exactly the only

00:33:27,260 --> 00:33:32,180
possibility the idea there is to just

00:33:29,360 --> 00:33:34,220
keep it separated completely you have

00:33:32,180 --> 00:33:35,720
this one like like the German motorway

00:33:34,220 --> 00:33:37,250
or maybe in Denmark it's the same you

00:33:35,720 --> 00:33:38,690
have the sort of two lanes going in the

00:33:37,250 --> 00:33:40,730
one direction the right side end you

00:33:38,690 --> 00:33:42,770
have a completely different separated

00:33:40,730 --> 00:33:44,360
direction different lanes for the

00:33:42,770 --> 00:33:45,710
different direction so we're just going

00:33:44,360 --> 00:33:47,480
to keep this completely separate in my

00:33:45,710 --> 00:33:50,530
example here you're going to use a

00:33:47,480 --> 00:33:53,690
completely different databases um so and

00:33:50,530 --> 00:33:55,100
this concept you can use this also

00:33:53,690 --> 00:33:58,520
without event sorting is called command

00:33:55,100 --> 00:34:03,020
queries responsibility segregation to

00:33:58,520 --> 00:34:04,520
build this in the bomb or we consume the

00:34:03,020 --> 00:34:06,380
stream of events so we're going to read

00:34:04,520 --> 00:34:08,140
from the database and consume the events

00:34:06,380 --> 00:34:10,880
as a stream so we're going to catch on a

00:34:08,140 --> 00:34:12,970
continuous read process the stream and

00:34:10,880 --> 00:34:16,540
use the stream to build the read side

00:34:12,970 --> 00:34:20,870
the gum has built in retied processors a

00:34:16,540 --> 00:34:22,990
Cassandra retie processor and a a JDBC

00:34:20,870 --> 00:34:25,809
read side processor

00:34:22,990 --> 00:34:28,329
unfortunately as far as I understand

00:34:25,809 --> 00:34:29,859
they don't really support this use case

00:34:28,329 --> 00:34:31,569
quite yet so you can't really they are

00:34:29,859 --> 00:34:33,629
great or they make it really simple if

00:34:31,569 --> 00:34:38,889
you use the same database for events and

00:34:33,629 --> 00:34:40,210
um and your your read side but in our

00:34:38,889 --> 00:34:42,460
case we want to use a separate database

00:34:40,210 --> 00:34:45,220
so I believe this is all the read side

00:34:42,460 --> 00:34:47,980
here now I built this little projection

00:34:45,220 --> 00:34:49,419
here sort of basically an actor well

00:34:47,980 --> 00:34:51,429
it's still simple right it's not it's

00:34:49,419 --> 00:34:54,250
not completely built in into the Gham

00:34:51,429 --> 00:34:56,050
but with all the things the framework

00:34:54,250 --> 00:34:57,970
gives you it's still super simple you

00:34:56,050 --> 00:35:00,730
just get the sort of the section for the

00:34:57,970 --> 00:35:03,160
we journal and so you can get your

00:35:00,730 --> 00:35:09,550
Cassandra section from the gum and then

00:35:03,160 --> 00:35:11,559
you just use the event by tag this is a

00:35:09,550 --> 00:35:13,290
sack of persistence career anything

00:35:11,559 --> 00:35:16,960
right you get this persistence query and

00:35:13,290 --> 00:35:18,400
it has an event by tag method this is

00:35:16,960 --> 00:35:20,170
where the texts come in if you remember

00:35:18,400 --> 00:35:22,630
when we define the events we tacked them

00:35:20,170 --> 00:35:24,130
so this is how we can get all the events

00:35:22,630 --> 00:35:26,800
that are associated with a certain type

00:35:24,130 --> 00:35:28,420
of entity like because these can be

00:35:26,800 --> 00:35:31,059
different types of you kind of just use

00:35:28,420 --> 00:35:33,190
the event type so this is our way to

00:35:31,059 --> 00:35:35,109
find out which events were interested in

00:35:33,190 --> 00:35:37,809
this is why we tagged them so I'm just

00:35:35,109 --> 00:35:40,059
going to use those and then I'm just

00:35:37,809 --> 00:35:42,940
going to map it to some method that some

00:35:40,059 --> 00:35:44,589
ugly secret stuff in here so that will

00:35:42,940 --> 00:35:48,339
basically update my my sequel database

00:35:44,589 --> 00:35:49,569
um to them anything is interested oh

00:35:48,339 --> 00:35:54,490
yeah of course

00:35:49,569 --> 00:35:55,869
um I have to sort of if I stop the

00:35:54,490 --> 00:35:57,670
application and start it again I don't

00:35:55,869 --> 00:36:00,430
want to reprocess all the events like I

00:35:57,670 --> 00:36:02,079
only want to process any events that I

00:36:00,430 --> 00:36:04,059
haven't processed yet so I have to

00:36:02,079 --> 00:36:06,430
remember what was the last event I

00:36:04,059 --> 00:36:08,079
processed so I I stole an offset as well

00:36:06,430 --> 00:36:09,520
all right so I have to eat this offset

00:36:08,079 --> 00:36:13,540
first I have to see what was the last

00:36:09,520 --> 00:36:15,490
event I got and then I start from the

00:36:13,540 --> 00:36:16,990
soft set so I'm going to write to my

00:36:15,490 --> 00:36:19,569
secret database as I said I created this

00:36:16,990 --> 00:36:23,319
little database schema so I have a table

00:36:19,569 --> 00:36:24,790
for the league pretty straightforward

00:36:23,319 --> 00:36:27,579
the team the games played and the points

00:36:24,790 --> 00:36:30,910
and for sort of this offset

00:36:27,579 --> 00:36:33,069
functionality there is a table to store

00:36:30,910 --> 00:36:35,319
this offset with this I would say okay

00:36:33,069 --> 00:36:36,670
this is for my league projection that

00:36:35,319 --> 00:36:39,010
the event tag I'm using is

00:36:36,670 --> 00:36:40,180
Oh on them because the events are

00:36:39,010 --> 00:36:42,250
starting to Sandra are going to be

00:36:40,180 --> 00:36:43,960
stopped with a time UUID offset so I

00:36:42,250 --> 00:36:45,880
have a column to store this time you the

00:36:43,960 --> 00:36:50,609
last offset I haven't processed any

00:36:45,880 --> 00:36:54,250
events yet so there's nothing in there

00:36:50,609 --> 00:36:58,030
and then I just said I create an actor

00:36:54,250 --> 00:37:07,150
that Thursday's so I'm just going to

00:36:58,030 --> 00:37:11,710
restart my application now what to do

00:37:07,150 --> 00:37:13,630
hey Thank You Sandra okay so we compile

00:37:11,710 --> 00:37:15,700
this one time I made this is a change so

00:37:13,630 --> 00:37:19,440
what we have hope to see now is that it

00:37:15,700 --> 00:37:19,440
somehow populates the my secret database

00:37:20,490 --> 00:37:26,530
ok there's always some off sign in there

00:37:22,780 --> 00:37:28,930
I've set in there oh yeah this manic

00:37:26,530 --> 00:37:30,540
right so now this is the viewer I wanted

00:37:28,930 --> 00:37:33,700
to get right this is the use of the 18

00:37:30,540 --> 00:37:35,910
team table the number of games they

00:37:33,700 --> 00:37:37,990
played and the points that they've

00:37:35,910 --> 00:37:40,000
accumulated so this doesn't look like

00:37:37,990 --> 00:37:41,230
much but if you one think there's some

00:37:40,000 --> 00:37:45,809
nice things about this so we have this

00:37:41,230 --> 00:37:48,339
completely separated for example and I

00:37:45,809 --> 00:37:50,829
only edit this reach outside processor

00:37:48,339 --> 00:37:53,920
so after we record a lot of events like

00:37:50,829 --> 00:37:55,900
sort of I kind of went back in time and

00:37:53,920 --> 00:37:57,609
we play some consumed these events

00:37:55,900 --> 00:37:59,650
although the sweet side projection

00:37:57,609 --> 00:38:01,270
wasn't even there at the time so I could

00:37:59,650 --> 00:38:04,109
create another projection for example in

00:38:01,270 --> 00:38:06,579
Germany in the 90s they change the rules

00:38:04,109 --> 00:38:08,890
of the scoring you used to get only two

00:38:06,579 --> 00:38:11,020
points for win now you get three points

00:38:08,890 --> 00:38:12,579
so maybe I wonder if I want to do

00:38:11,020 --> 00:38:14,920
historic comparisons I want to say okay

00:38:12,579 --> 00:38:16,900
if the Oval would still apply would it

00:38:14,920 --> 00:38:18,280
end up with the same over the same

00:38:16,900 --> 00:38:20,290
ranking in the league so I could write

00:38:18,280 --> 00:38:22,299
another projection now where only gives

00:38:20,290 --> 00:38:24,640
two points for win and we possess these

00:38:22,299 --> 00:38:26,049
old events even even though I might not

00:38:24,640 --> 00:38:27,549
even have thought of this use case when

00:38:26,049 --> 00:38:29,650
I started recording these events so I

00:38:27,549 --> 00:38:31,390
can go back and create new projections

00:38:29,650 --> 00:38:33,190
and obviously there's totally unrelated

00:38:31,390 --> 00:38:35,020
to the or the structure of this and

00:38:33,190 --> 00:38:36,970
everything is totally unrelated to my

00:38:35,020 --> 00:38:38,740
event store so I can I can create all

00:38:36,970 --> 00:38:42,369
sort of different sorts of projections

00:38:38,740 --> 00:38:44,589
for my use cases I can I can create a

00:38:42,369 --> 00:38:46,690
table only representing the home games

00:38:44,589 --> 00:38:48,460
on the arrange aims or whatever get all

00:38:46,690 --> 00:38:49,990
these views without having to touch my

00:38:48,460 --> 00:38:50,240
event locks because the events haven't

00:38:49,990 --> 00:38:51,980
ran

00:38:50,240 --> 00:38:54,040
the game was played that was the result

00:38:51,980 --> 00:38:56,240
but now I can create all these different

00:38:54,040 --> 00:38:57,920
projections and I can of course I can

00:38:56,240 --> 00:39:00,200
also completely scale this obviously

00:38:57,920 --> 00:39:02,030
these are completely separate databases

00:39:00,200 --> 00:39:03,680
right as the Cassandra in this case for

00:39:02,030 --> 00:39:05,660
the journal for the event journal and

00:39:03,680 --> 00:39:08,119
there's the view side in this case my

00:39:05,660 --> 00:39:09,230
sequel so I can scale this I can because

00:39:08,119 --> 00:39:12,619
this is only going to be used for

00:39:09,230 --> 00:39:15,109
reading I can just add as many replicas

00:39:12,619 --> 00:39:17,480
as I once gave the sound yeah that's I

00:39:15,109 --> 00:39:24,440
think how how the gum works and securest

00:39:17,480 --> 00:39:26,180
terms stream events so the government as

00:39:24,440 --> 00:39:27,619
I hope you got the impression it's

00:39:26,180 --> 00:39:30,380
really simple to do this with Logan

00:39:27,619 --> 00:39:32,540
becomes great but event sourcing and

00:39:30,380 --> 00:39:34,040
cigarettes is even greater than the gum

00:39:32,540 --> 00:39:36,440
so even if you don't want to use or

00:39:34,040 --> 00:39:38,080
can't use the gum um there are other

00:39:36,440 --> 00:39:41,960
things you might want to look into oh

00:39:38,080 --> 00:39:48,680
this is a sorry we aren't running kind

00:39:41,960 --> 00:39:51,890
of this time in the listener I showed

00:39:48,680 --> 00:39:54,260
you the code so there are other or

00:39:51,890 --> 00:39:56,960
seacrest frameworks for or event

00:39:54,260 --> 00:39:59,960
sourcing frameworks for Scala so there's

00:39:56,960 --> 00:40:02,000
a couple systems a legume actually uses

00:39:59,960 --> 00:40:03,830
occur persistence it's the engine

00:40:02,000 --> 00:40:07,040
underneath the gum but you can also use

00:40:03,830 --> 00:40:10,460
a cough assistance directly it's a bit

00:40:07,040 --> 00:40:13,070
so it's a bit less structure it's a bit

00:40:10,460 --> 00:40:15,500
celeste type checking in it you have a

00:40:13,070 --> 00:40:17,480
slightly different terminology you don't

00:40:15,500 --> 00:40:20,300
define command handlers and vendors but

00:40:17,480 --> 00:40:23,300
you have your receive whatever and you

00:40:20,300 --> 00:40:25,160
have to receive restore and you don't

00:40:23,300 --> 00:40:27,020
have these sort of predefined retie

00:40:25,160 --> 00:40:28,849
processes as I said if you just use one

00:40:27,020 --> 00:40:30,740
data store you just stick with Cassandra

00:40:28,849 --> 00:40:32,390
or relating the database for storing

00:40:30,740 --> 00:40:35,750
then you can just use the pre-built

00:40:32,390 --> 00:40:37,339
retied processors in the gum um innaka

00:40:35,750 --> 00:40:38,540
persistence you basically have to do it

00:40:37,339 --> 00:40:40,640
like are showing here with the

00:40:38,540 --> 00:40:43,700
persistence query and mapping these

00:40:40,640 --> 00:40:45,560
events yourself but in terms of

00:40:43,700 --> 00:40:46,940
scalability of course it's all the same

00:40:45,560 --> 00:40:47,810
as looking because it's the engine

00:40:46,940 --> 00:40:49,250
underneath agon

00:40:47,810 --> 00:40:53,150
there's this other framework called

00:40:49,250 --> 00:40:55,010
fancy QRS that has a similar approach in

00:40:53,150 --> 00:40:57,260
terms of its adsl on top of our

00:40:55,010 --> 00:40:59,420
persistence it's an abstraction layer on

00:40:57,260 --> 00:41:01,369
on top of this you can also attach

00:40:59,420 --> 00:41:03,290
different backends you can also use this

00:41:01,369 --> 00:41:05,540
within if you're not even interested

00:41:03,290 --> 00:41:07,010
long-term storage I don't know that's

00:41:05,540 --> 00:41:08,180
really events sourcing student but you

00:41:07,010 --> 00:41:10,850
can also use it with an in-memory

00:41:08,180 --> 00:41:13,850
back-end but theoretically you could use

00:41:10,850 --> 00:41:15,200
any sort of back-end there well because

00:41:13,850 --> 00:41:16,850
it uses a cup resistance you can also

00:41:15,200 --> 00:41:17,960
use different backends with a cup

00:41:16,850 --> 00:41:20,390
resistance so there's a lot of

00:41:17,960 --> 00:41:22,490
flexibility there its gala only and the

00:41:20,390 --> 00:41:25,340
gum some things sometimes the government

00:41:22,490 --> 00:41:28,520
seems a bit the noisy API wise I think a

00:41:25,340 --> 00:41:30,260
bit of that is is caused by it being

00:41:28,520 --> 00:41:32,480
cross-platform because it's a Java and

00:41:30,260 --> 00:41:35,450
Scala framework well this is pure Scala

00:41:32,480 --> 00:41:38,330
and tries to sort of be more a bit more

00:41:35,450 --> 00:41:40,460
idiomatic scanner wise as a nice website

00:41:38,330 --> 00:41:42,710
and the creator of this framework is

00:41:40,460 --> 00:41:44,720
going to talk about type safety and

00:41:42,710 --> 00:41:47,870
messaging and event sourcing in the next

00:41:44,720 --> 00:41:51,110
slot in rooms a-two a-three so I can

00:41:47,870 --> 00:41:54,740
highly recommend going to the talk and

00:41:51,110 --> 00:41:56,300
lastly there's eventuate which does not

00:41:54,740 --> 00:41:58,100
use a cover system it has a slightly

00:41:56,300 --> 00:41:59,990
different approach has the same

00:41:58,100 --> 00:42:03,590
capabilities in terms of event sourcing

00:41:59,990 --> 00:42:05,090
but it has a has an interesting I have

00:42:03,590 --> 00:42:07,190
to actually use that use that sort of

00:42:05,090 --> 00:42:08,510
value I looked at it but I know about

00:42:07,190 --> 00:42:10,550
one thing that is an interesting

00:42:08,510 --> 00:42:12,380
difference to a cup assistance I told

00:42:10,550 --> 00:42:15,290
you that a lack of persistence if you

00:42:12,380 --> 00:42:16,760
have your key and you get this sector F

00:42:15,290 --> 00:42:19,010
or you get this persistent entity or

00:42:16,760 --> 00:42:20,420
whatever you only there's always only

00:42:19,010 --> 00:42:24,620
going to be one instance in the cluster

00:42:20,420 --> 00:42:26,960
right so it's going to be in terms of of

00:42:24,620 --> 00:42:30,320
boundaries you have this this is always

00:42:26,960 --> 00:42:33,520
going to be consistent in eventuate you

00:42:30,320 --> 00:42:38,420
can actually have multiple instances of

00:42:33,520 --> 00:42:40,790
an entity in your cluster there's why

00:42:38,420 --> 00:42:42,350
would that be a good idea well this can

00:42:40,790 --> 00:42:44,660
be is can actually be interesting if

00:42:42,350 --> 00:42:46,070
your cluster spans say multiple

00:42:44,660 --> 00:42:49,610
datacenters for example and you have a

00:42:46,070 --> 00:42:52,670
slow connection that's a car a car a

00:42:49,610 --> 00:42:54,140
cluster filing is in it's currently not

00:42:52,670 --> 00:42:55,580
a great solution for this you could have

00:42:54,140 --> 00:42:57,080
if you have a cluster that spans

00:42:55,580 --> 00:42:59,540
multiple data centers with a slow

00:42:57,080 --> 00:43:01,460
connection that doesn't really fit into

00:42:59,540 --> 00:43:03,680
this philosophy that you sort of have

00:43:01,460 --> 00:43:06,770
this homogeneous

00:43:03,680 --> 00:43:09,740
cluster where you can just freely look

00:43:06,770 --> 00:43:11,360
so put your exes wherever you want so it

00:43:09,740 --> 00:43:13,280
can be very interesting for this and if

00:43:11,360 --> 00:43:15,680
you but then of course you need to

00:43:13,280 --> 00:43:16,829
define convergent rules as well they can

00:43:15,680 --> 00:43:18,329
divert

00:43:16,829 --> 00:43:19,950
they have to convert again in terms of

00:43:18,329 --> 00:43:21,420
state so you cannot just do anything

00:43:19,950 --> 00:43:23,130
there with any actor but it's definitely

00:43:21,420 --> 00:43:27,029
interesting so you might wanna have a

00:43:23,130 --> 00:43:27,959
look at that doing doing or doing the do

00:43:27,029 --> 00:43:30,329
I mention that I mentioned that I

00:43:27,959 --> 00:43:32,039
mentioned that so ah yeah of course

00:43:30,329 --> 00:43:36,089
everything comes at a price

00:43:32,039 --> 00:43:38,130
or well I don't know but it's it's

00:43:36,089 --> 00:43:39,509
really in some ways that's really

00:43:38,130 --> 00:43:41,969
straightforward the whole event sourcing

00:43:39,509 --> 00:43:44,099
thing but of course the whole rethinking

00:43:41,969 --> 00:43:45,900
thing also means not only unlearning

00:43:44,099 --> 00:43:47,369
things we learned but also think about

00:43:45,900 --> 00:43:51,420
things we maybe didn't have to think

00:43:47,369 --> 00:43:54,329
about that much before for example if I

00:43:51,420 --> 00:43:56,910
saying the events are immutable and live

00:43:54,329 --> 00:43:58,709
eternally I've never done delete them

00:43:56,910 --> 00:44:01,920
that me time so I kind of carry them

00:43:58,709 --> 00:44:04,529
around forever alright maybe in maybe my

00:44:01,920 --> 00:44:07,229
events change and my application changes

00:44:04,529 --> 00:44:10,289
and and I expand my events and I've new

00:44:07,229 --> 00:44:12,119
events but I still have to be able to

00:44:10,289 --> 00:44:13,589
process the events from whenever I

00:44:12,119 --> 00:44:14,609
started with this and created the first

00:44:13,589 --> 00:44:16,140
because they're still going to be there

00:44:14,609 --> 00:44:18,119
of course technically there's always

00:44:16,140 --> 00:44:19,979
ways around and then and so on but but

00:44:18,119 --> 00:44:23,670
it's a kind of a long-term commitment

00:44:19,979 --> 00:44:25,170
thing consistency sort of we looked at

00:44:23,670 --> 00:44:26,759
the you looked at the aggregate that's

00:44:25,170 --> 00:44:27,989
fine it's sort of you always know the

00:44:26,759 --> 00:44:30,269
latest date of the aggregate that's

00:44:27,989 --> 00:44:32,009
completely consistent the reach side is

00:44:30,269 --> 00:44:34,859
or the reach site is updated with the

00:44:32,009 --> 00:44:36,599
stream thing so at the read side is

00:44:34,859 --> 00:44:38,400
going to be delayed but you cannot

00:44:36,599 --> 00:44:40,739
really make validation decisions based

00:44:38,400 --> 00:44:42,809
on the read side because the state might

00:44:40,739 --> 00:44:45,180
have changed already doesn't make sense

00:44:42,809 --> 00:44:46,949
right so there's a delayed consistency

00:44:45,180 --> 00:44:49,949
there or eventual consistency as people

00:44:46,949 --> 00:44:52,140
say and with all this messaging message

00:44:49,949 --> 00:44:55,410
processing and things that might get

00:44:52,140 --> 00:44:57,449
lost and might so there's no in any

00:44:55,410 --> 00:45:00,269
distributed system but you don't really

00:44:57,449 --> 00:45:04,529
have it exactly ones delivery guarantee

00:45:00,269 --> 00:45:06,180
and that's the same with the in the gum

00:45:04,529 --> 00:45:08,940
of I didn't really show this but when I

00:45:06,180 --> 00:45:10,259
stored the data and the offset I did it

00:45:08,940 --> 00:45:12,299
in one transaction so with the

00:45:10,259 --> 00:45:13,859
relational database okay I can I will

00:45:12,299 --> 00:45:16,469
only update the offset when the data was

00:45:13,859 --> 00:45:17,999
written successfully so I will just if

00:45:16,469 --> 00:45:20,459
it crashes I can just repossess that

00:45:17,999 --> 00:45:21,959
event depending on what store you use

00:45:20,459 --> 00:45:23,459
you might not have these guarantees and

00:45:21,959 --> 00:45:25,529
you might end up in a situation where

00:45:23,459 --> 00:45:26,880
you have to where you have to process or

00:45:25,529 --> 00:45:28,910
you can get into a situation where

00:45:26,880 --> 00:45:30,440
events are published multiple times

00:45:28,910 --> 00:45:32,180
you have to be able to deal with that

00:45:30,440 --> 00:45:33,920
it's always good to have some

00:45:32,180 --> 00:45:36,590
idempotency they have an item photon

00:45:33,920 --> 00:45:37,610
receiver that can can handle this so but

00:45:36,590 --> 00:45:39,770
these are things you need to start

00:45:37,610 --> 00:45:41,240
thinking about not only with the event

00:45:39,770 --> 00:45:45,050
sourcing but with distributed systems in

00:45:41,240 --> 00:45:48,200
general obviously summary oh man there's

00:45:45,050 --> 00:45:50,960
another side so unlearn unlearn forget

00:45:48,200 --> 00:45:52,790
about this whole relational model thing

00:45:50,960 --> 00:45:54,800
don't focus on the static structure of

00:45:52,790 --> 00:45:56,660
the education think of events of the

00:45:54,800 --> 00:45:59,840
dynamic capabilities of the application

00:45:56,660 --> 00:46:01,250
of the flow of events use event sourcing

00:45:59,840 --> 00:46:03,650
it's great with the ekor model it's a

00:46:01,250 --> 00:46:06,530
great alignment no mismatch there it's K

00:46:03,650 --> 00:46:08,630
is great it preserves all information

00:46:06,530 --> 00:46:10,400
and super flexible and legume is really

00:46:08,630 --> 00:46:12,650
a great framework to get started with it

00:46:10,400 --> 00:46:14,690
because it gives you this structure as

00:46:12,650 --> 00:46:17,450
you saw here it's a very clear mapping

00:46:14,690 --> 00:46:19,760
command command event event state stage

00:46:17,450 --> 00:46:22,880
actor for aggregators persistent entity

00:46:19,760 --> 00:46:24,590
so it's it's like doing this you can

00:46:22,880 --> 00:46:26,030
just sort of you can focus on the actual

00:46:24,590 --> 00:46:27,980
business logic and what you want to do

00:46:26,030 --> 00:46:31,160
with your events don't have to focus on

00:46:27,980 --> 00:46:32,660
the mechanics of it yeah that's it so we

00:46:31,160 --> 00:46:35,120
have a couple of minutes for questions

00:46:32,660 --> 00:46:36,500
oh that was good yeah there's somebody

00:46:35,120 --> 00:46:39,940
who's going to give you a microphone so

00:46:36,500 --> 00:46:39,940
the question can be recorded as well

00:46:43,480 --> 00:46:47,720
thanks for your talk I have two

00:46:45,620 --> 00:46:49,820
following question and I dare December

00:46:47,720 --> 00:46:53,270
season the arc of persistence developers

00:46:49,820 --> 00:46:56,360
so I've seen all the corners of it but I

00:46:53,270 --> 00:46:58,040
found particularly difficult is when

00:46:56,360 --> 00:47:00,290
your business problem is inherently

00:46:58,040 --> 00:47:03,710
relational meaning that you have

00:47:00,290 --> 00:47:06,650
relations between aggregates so if you

00:47:03,710 --> 00:47:10,310
change state in mana good can cause

00:47:06,650 --> 00:47:14,360
changes of n other aggregates and to

00:47:10,310 --> 00:47:16,460
keep consistency there yeah I find hard

00:47:14,360 --> 00:47:18,530
yeah what would be advice to deal with

00:47:16,460 --> 00:47:20,690
quick process as far as I know there's

00:47:18,530 --> 00:47:22,190
really nothing in the framework that

00:47:20,690 --> 00:47:24,620
helps you with that right there's no so

00:47:22,190 --> 00:47:27,170
in design terms you you're enter the

00:47:24,620 --> 00:47:29,780
area of sort of process managers and and

00:47:27,170 --> 00:47:30,980
maybe sagas and then things like that so

00:47:29,780 --> 00:47:34,040
you're you need some sort of

00:47:30,980 --> 00:47:36,110
coordination for this process some sort

00:47:34,040 --> 00:47:37,430
of some entity that knows what the steps

00:47:36,110 --> 00:47:39,440
of this process are or what you call

00:47:37,430 --> 00:47:41,990
this relational nature what the relation

00:47:39,440 --> 00:47:42,789
is between different aggregates so yeah

00:47:41,990 --> 00:47:43,809
you add some

00:47:42,789 --> 00:47:46,929
there are four the well-established

00:47:43,809 --> 00:47:48,519
design patterns for that somebody said I

00:47:46,929 --> 00:47:53,469
think their oppa said there's no point

00:47:48,519 --> 00:47:54,849
in creating like a a a base process

00:47:53,469 --> 00:47:56,380
manager in the framework because it's

00:47:54,849 --> 00:47:57,999
always so use case specific there's sort

00:47:56,380 --> 00:47:59,679
of in terms of mechanics there's not

00:47:57,999 --> 00:48:01,509
Maps you can give to the user to do it

00:47:59,679 --> 00:48:02,709
automatically but these are I think

00:48:01,509 --> 00:48:03,219
these will be the patterns you would

00:48:02,709 --> 00:48:05,469
look into

00:48:03,219 --> 00:48:07,749
it's definitely solvable people end up

00:48:05,469 --> 00:48:08,799
with these problems but there's you're

00:48:07,749 --> 00:48:11,259
right there's nothing in the framework

00:48:08,799 --> 00:48:13,299
oh sorry not also not in the gum some

00:48:11,259 --> 00:48:20,890
nothing goes in for sort of in terms of

00:48:13,299 --> 00:48:22,449
process managers or things like hi thank

00:48:20,890 --> 00:48:24,789
you for the talk are there strategies

00:48:22,449 --> 00:48:28,029
for dealing with particularly large logs

00:48:24,789 --> 00:48:30,130
where the replay time may just end up

00:48:28,029 --> 00:48:33,009
dominating or is this business pattern

00:48:30,130 --> 00:48:35,559
primarily for smaller data sets no the

00:48:33,009 --> 00:48:38,049
data plan can be so the the restoration

00:48:35,559 --> 00:48:39,900
can is so sped up for the snapshots

00:48:38,049 --> 00:48:42,069
right so you don't even if you have a

00:48:39,900 --> 00:48:44,589
million of events

00:48:42,069 --> 00:48:45,910
once you snapshot at it you will you

00:48:44,589 --> 00:48:47,919
will always start from the latest

00:48:45,910 --> 00:48:49,150
snapshot and if you step for every

00:48:47,919 --> 00:48:50,380
hundred events so it's never going to be

00:48:49,150 --> 00:48:53,769
more than hundreds of enter of course

00:48:50,380 --> 00:48:56,709
you can configure that um yeah so that

00:48:53,769 --> 00:48:58,539
that should really be a problem if you

00:48:56,709 --> 00:48:59,859
have a vast amount of data like this

00:48:58,539 --> 00:49:01,659
sort of you use event sourcing for

00:48:59,859 --> 00:49:03,849
something that would create thousands of

00:49:01,659 --> 00:49:06,369
events per second or whatever well I

00:49:03,849 --> 00:49:08,679
don't yeah well there are use cases or

00:49:06,369 --> 00:49:11,469
rare diseases where it makes sense to

00:49:08,679 --> 00:49:14,199
use event sourcing maybe in some maybe

00:49:11,469 --> 00:49:16,839
in some sort of traffic sort of scenario

00:49:14,199 --> 00:49:19,839
where you want to keep you have a lot of

00:49:16,839 --> 00:49:20,919
moving parts literally moving cars like

00:49:19,839 --> 00:49:23,319
cars and trains and so on you want to

00:49:20,919 --> 00:49:25,169
keep track of them but only over periods

00:49:23,319 --> 00:49:27,429
of times that they are kind of stateful

00:49:25,169 --> 00:49:28,809
but but at some point when the train

00:49:27,429 --> 00:49:30,400
arrives you can also turn state away

00:49:28,809 --> 00:49:32,589
again so there can be sort of corner

00:49:30,400 --> 00:49:34,630
cases where you say this whole keeping

00:49:32,589 --> 00:49:36,579
the history for for all time doesn't

00:49:34,630 --> 00:49:38,229
really make sense to me because the data

00:49:36,579 --> 00:49:40,719
is only valid for a certain amount of

00:49:38,229 --> 00:49:42,339
time of course then yeah technically you

00:49:40,719 --> 00:49:45,130
can always also delete things so I'd

00:49:42,339 --> 00:49:46,809
it's not it's not magic there it doesn't

00:49:45,130 --> 00:49:48,309
say if you do the delete command it

00:49:46,809 --> 00:49:51,640
doesn't say oh no I'm an event I'm

00:49:48,309 --> 00:49:54,980
eternal but the idea of event sourcing

00:49:51,640 --> 00:49:57,960
of course is to keep this lock forever

00:49:54,980 --> 00:49:59,880
okay yeah up there maybe if something

00:49:57,960 --> 00:50:00,690
can get them like they're all right or

00:49:59,880 --> 00:50:02,880
maybe just one more

00:50:00,690 --> 00:50:29,760
maybe it's an intersection I can just

00:50:02,880 --> 00:50:30,210
shout it to me and I'll repeat it all

00:50:29,760 --> 00:50:33,300
the time

00:50:30,210 --> 00:50:34,770
yeah sorry Reza yeah that's okay yeah

00:50:33,300 --> 00:50:37,320
but that's a big question right so also

00:50:34,770 --> 00:50:39,600
rest rest it's sort of a well it's a

00:50:37,320 --> 00:50:41,190
well defined term but but people use it

00:50:39,600 --> 00:50:44,640
in a very vague brain but but it's

00:50:41,190 --> 00:50:47,280
definitely this yeah it's not I think

00:50:44,640 --> 00:50:48,720
it's not a huge not a huge mismatch all

00:50:47,280 --> 00:50:50,100
right the sort of of course you can

00:50:48,720 --> 00:50:52,980
still do the things you can do I mean

00:50:50,100 --> 00:50:55,080
this is this was very simplest if you

00:50:52,980 --> 00:50:56,850
are with post on the protein you can you

00:50:55,080 --> 00:50:59,250
can put things and tanks data sort of

00:50:56,850 --> 00:51:02,370
MVA in terms of what the user perceives

00:50:59,250 --> 00:51:04,290
but in terms of what happens to your

00:51:02,370 --> 00:51:06,240
three entity you have to sort of map

00:51:04,290 --> 00:51:07,560
this to events but it's there's

00:51:06,240 --> 00:51:10,980
absolutely no contradiction there

00:51:07,560 --> 00:51:12,600
because I would think that I don't know

00:51:10,980 --> 00:51:15,570
how westphall they all are but sort of

00:51:12,600 --> 00:51:16,920
90 percent of you of the systems that

00:51:15,570 --> 00:51:20,180
are built with event sourcing and use

00:51:16,920 --> 00:51:22,920
this will expose some some HTTP

00:51:20,180 --> 00:51:27,330
something API so of course that's

00:51:22,920 --> 00:51:30,200
possible here yeah that I'm going to be

00:51:27,330 --> 00:51:30,200
around tectonic

00:51:30,510 --> 00:51:32,570

YouTube URL: https://www.youtube.com/watch?v=Z6_Nd7lu2PI


