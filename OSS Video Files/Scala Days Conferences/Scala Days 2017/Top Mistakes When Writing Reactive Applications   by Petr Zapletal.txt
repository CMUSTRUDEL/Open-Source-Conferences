Title: Top Mistakes When Writing Reactive Applications   by Petr Zapletal
Publication date: 2017-06-06
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Reactive applications are becoming a de-facto industry standard and, if employed correctly, toolkits like Lightbend Reactive Platform make the implementation easier than ever. But design of these systems might be challenging as it requires particular mindset shift to tackle problems we might not be used to. In this talk we’re going to discuss the most common things I’ve seen in the field that prevented applications to work as expected. I’d like to talk about typical pitfalls that might cause troubles, about trade-offs that might not be fully understood or important choices that might be overlooked including persistent actors pitfalls, tackling of network partitions, proper implementations of graceful shutdown or distributed transactions, trade-offs of micro-services or actors and more. 

This talk should be interesting for anyone who is thinking about, implementing, or have already deployed reactive application. My goal is to provide a comprehensive explanation of common problems to be sure they won’t be repeated by fellow developers. The talk is a little bit more focused on Lightbend platform but understanding of the concepts we are going to talk about should be beneficial for everyone interested in this field.
Captions: 
	00:00:00,060 --> 00:00:06,270
so good afternoon everybody my name is

00:00:03,540 --> 00:00:08,340
Peter and I work for cake solutions we

00:00:06,270 --> 00:00:11,070
are at canto Dante Company from focusing

00:00:08,340 --> 00:00:14,460
on building reactive and data processing

00:00:11,070 --> 00:00:19,350
applications using technologies so just

00:00:14,460 --> 00:00:21,210
like a spark and many others I have a

00:00:19,350 --> 00:00:23,699
pleasure to work with a number of

00:00:21,210 --> 00:00:26,630
companies and quite often I have been

00:00:23,699 --> 00:00:29,039
asked to tackle programs they faced and

00:00:26,630 --> 00:00:32,309
some of these programs were quite

00:00:29,039 --> 00:00:36,480
repetitive so I picked a couple of them

00:00:32,309 --> 00:00:38,879
and made a talk about it I'm going to

00:00:36,480 --> 00:00:41,940
talk about topics like exercise the

00:00:38,879 --> 00:00:44,610
futures cessation supervision graceful

00:00:41,940 --> 00:00:49,649
shutdown distribute the transactions

00:00:44,610 --> 00:00:52,559
home to latency and that's it after that

00:00:49,649 --> 00:00:55,260
I've got a short section switch quick

00:00:52,559 --> 00:00:57,989
tips which are basically topics I'd like

00:00:55,260 --> 00:00:59,300
to talk about but I do not have enough

00:00:57,989 --> 00:01:01,920
time for that

00:00:59,300 --> 00:01:04,619
lastly I'll go from the most basic

00:01:01,920 --> 00:01:07,820
topics to the more advanced so I hope

00:01:04,619 --> 00:01:10,860
everyone will find something interesting

00:01:07,820 --> 00:01:13,820
and also in the end there is a definite

00:01:10,860 --> 00:01:19,560
space to share problems you guys sighs

00:01:13,820 --> 00:01:22,380
so let's move on constraints liberate

00:01:19,560 --> 00:01:25,110
liberties constraint is the name of an

00:01:22,380 --> 00:01:27,780
exam talk by you know the end zone he

00:01:25,110 --> 00:01:30,780
gave like a year ago at scholars

00:01:27,780 --> 00:01:33,180
conference apart from many things he

00:01:30,780 --> 00:01:35,880
talks about how constraints the breakers

00:01:33,180 --> 00:01:38,549
and how we should use to these others

00:01:35,880 --> 00:01:39,810
and the most precise abstraction which

00:01:38,549 --> 00:01:43,380
are the job for us

00:01:39,810 --> 00:01:48,060
and this makes perfect sense and the

00:01:43,380 --> 00:01:51,240
context of actors versus futures so this

00:01:48,060 --> 00:01:53,729
is what our tool box looks like on one

00:01:51,240 --> 00:01:58,320
side we have a future and on the other

00:01:53,729 --> 00:02:00,869
side we have a cactus futures is the

00:01:58,320 --> 00:02:04,619
strongest it--look abstraction for for

00:02:00,869 --> 00:02:07,170
concurrency editin just one value by

00:02:04,619 --> 00:02:10,319
definition all the contrary

00:02:07,170 --> 00:02:12,800
actors are very dynamic they are not

00:02:10,319 --> 00:02:16,400
useful types and they receive deferred

00:02:12,800 --> 00:02:19,010
is a partial function from any two unit

00:02:16,400 --> 00:02:22,280
so basically give me whatever and I

00:02:19,010 --> 00:02:26,000
maybe do some side effect therefore

00:02:22,280 --> 00:02:27,560
actors are not function or composable on

00:02:26,000 --> 00:02:29,240
the other hand the allocation

00:02:27,560 --> 00:02:31,580
transparent and there has nice

00:02:29,240 --> 00:02:35,170
presidents and mechanisms like watching

00:02:31,580 --> 00:02:38,000
recovery supervision and so on

00:02:35,170 --> 00:02:40,430
additionally we now have occupied which

00:02:38,000 --> 00:02:43,550
tries to tackle shortcomings of the

00:02:40,430 --> 00:02:46,130
vanilla actors but right now it's still

00:02:43,550 --> 00:02:49,250
very experimental and definitely not an

00:02:46,130 --> 00:02:51,200
option for production systems but it is

00:02:49,250 --> 00:02:54,320
an interesting library you might take a

00:02:51,200 --> 00:02:56,000
look and by the way don't don't confuse

00:02:54,320 --> 00:03:00,620
this with tight actors which are

00:02:56,000 --> 00:03:03,560
duplicated while ago nice middle ground

00:03:00,620 --> 00:03:06,380
are extremes which are static say how to

00:03:03,560 --> 00:03:10,730
define processing they are work type and

00:03:06,380 --> 00:03:12,740
they also offer back pressure so as you

00:03:10,730 --> 00:03:15,050
can see akka gives us a couple of

00:03:12,740 --> 00:03:17,870
options some of them are less power flow

00:03:15,050 --> 00:03:19,670
constraint and easy to use and some of

00:03:17,870 --> 00:03:22,220
them are very powerful and we feel the

00:03:19,670 --> 00:03:24,200
constraint but as I sat in the beginning

00:03:22,220 --> 00:03:28,600
we should always try to use the least

00:03:24,200 --> 00:03:32,000
out of abstraction which does the job

00:03:28,600 --> 00:03:34,730
here we can see some common active use

00:03:32,000 --> 00:03:37,580
cases first one is the state management

00:03:34,730 --> 00:03:41,780
which is obviously a very good reason to

00:03:37,580 --> 00:03:43,940
use actors other good reasons why you'd

00:03:41,780 --> 00:03:45,770
like to use them are another core like a

00:03:43,940 --> 00:03:49,370
features like location transparency

00:03:45,770 --> 00:03:52,940
resilience and so on and actors are also

00:03:49,370 --> 00:03:55,430
by the nature great if you want to take

00:03:52,940 --> 00:03:58,700
advantage of single vital principle and

00:03:55,430 --> 00:04:01,520
they can be used as a memorial quick

00:03:58,700 --> 00:04:05,350
cash as well another very common usage

00:04:01,520 --> 00:04:08,180
of actors is obviously sharding and

00:04:05,350 --> 00:04:11,060
futures should be used in cases when we

00:04:08,180 --> 00:04:13,820
need just local concurrency surely this

00:04:11,060 --> 00:04:17,840
is achieved by actors easily but futures

00:04:13,820 --> 00:04:19,640
are much easier to use futures require

00:04:17,840 --> 00:04:21,680
sparse right thing and we can take

00:04:19,640 --> 00:04:24,020
advantage of functional approach so we

00:04:21,680 --> 00:04:24,800
can enjoy a type safety or future

00:04:24,020 --> 00:04:28,030
composition

00:04:24,800 --> 00:04:34,909
and you know all these things we love so

00:04:28,030 --> 00:04:37,629
do not overuse the actors as you

00:04:34,909 --> 00:04:40,610
probably know generalization a slow

00:04:37,629 --> 00:04:43,490
footprint heavy and has scarred version

00:04:40,610 --> 00:04:44,389
binary compatibility issues and as you

00:04:43,490 --> 00:04:46,639
may know as well

00:04:44,389 --> 00:04:51,560
Java salvation is the default in Agra

00:04:46,639 --> 00:04:53,930
and that's pretty bad there are two main

00:04:51,560 --> 00:04:57,139
reasons why we want to sterilize data

00:04:53,930 --> 00:05:00,199
when using akka first one is sanic data

00:04:57,139 --> 00:05:01,610
through the network obviously a car

00:05:00,199 --> 00:05:04,940
doesn't sterilize messages which are

00:05:01,610 --> 00:05:07,400
sent locally why would it so we have an

00:05:04,940 --> 00:05:09,590
actor with Sarai's message and send it

00:05:07,400 --> 00:05:11,870
to another actor the second actor

00:05:09,590 --> 00:05:15,080
displays message greater response leaded

00:05:11,870 --> 00:05:17,000
and send it back this wrong trip is

00:05:15,080 --> 00:05:19,699
called ping pong test and it's often

00:05:17,000 --> 00:05:25,129
used for the evaluation of validation

00:05:19,699 --> 00:05:28,490
libraries the second use case is passing

00:05:25,129 --> 00:05:31,400
data into local storage I had a client

00:05:28,490 --> 00:05:33,110
last year maybe here before and they had

00:05:31,400 --> 00:05:35,419
their format issues regarding occupies

00:05:33,110 --> 00:05:37,880
distance they told me it took more than

00:05:35,419 --> 00:05:41,120
a minute to create that resistant actors

00:05:37,880 --> 00:05:42,139
and then it's Raceway but yet it is

00:05:41,120 --> 00:05:44,659
certainly possible

00:05:42,139 --> 00:05:48,229
just imagine the actor has a quite

00:05:44,659 --> 00:05:51,319
complex state and I do civilization then

00:05:48,229 --> 00:05:55,520
you know using snapshots at all and here

00:05:51,319 --> 00:05:58,190
we are so let's have a quick look at

00:05:55,520 --> 00:06:00,710
graph it compares round-trip of values

00:05:58,190 --> 00:06:03,620
realization libraries I am pretty sure

00:06:00,710 --> 00:06:05,539
it is very hard to read but so I edit

00:06:03,620 --> 00:06:09,010
the arrow which shows us where digital

00:06:05,539 --> 00:06:11,980
implementation stands

00:06:09,010 --> 00:06:15,520
and this graph shows the footprint size

00:06:11,980 --> 00:06:17,680
as you can see the last port and by the

00:06:15,520 --> 00:06:19,810
way if you would like to see the sources

00:06:17,680 --> 00:06:24,970
of this data in the any references slide

00:06:19,810 --> 00:06:28,180
in the end and this is how select data

00:06:24,970 --> 00:06:29,860
looks like for a very simple class the

00:06:28,180 --> 00:06:31,900
food ring of your association is far

00:06:29,860 --> 00:06:36,390
bigger even than the footprint of not

00:06:31,900 --> 00:06:39,250
very action format like XML or JSON and

00:06:36,390 --> 00:06:42,220
the good question is why it is like that

00:06:39,250 --> 00:06:44,530
and the reason is it does not storage of

00:06:42,220 --> 00:06:46,960
data but it also survives the anti-claus

00:06:44,530 --> 00:06:50,290
definition and all definition of all

00:06:46,960 --> 00:06:52,090
reference classes it was designed to to

00:06:50,290 --> 00:06:55,240
be simple to use to set us almost

00:06:52,090 --> 00:06:57,190
everything and and also it was supposed

00:06:55,240 --> 00:07:00,490
to work with different JVM

00:06:57,190 --> 00:07:02,680
but apparently performance was not email

00:07:00,490 --> 00:07:05,530
requirements but you know honestly after

00:07:02,680 --> 00:07:10,930
eight major Java versions it could be a

00:07:05,530 --> 00:07:13,120
little bit better when choosing among

00:07:10,930 --> 00:07:15,610
various libraries there are a couple of

00:07:13,120 --> 00:07:17,560
points we should have in mind two main

00:07:15,610 --> 00:07:19,600
reasons why you want to avoid

00:07:17,560 --> 00:07:22,390
rasterization are its performance and

00:07:19,600 --> 00:07:24,550
its footprint but we should also have in

00:07:22,390 --> 00:07:26,560
mind like schema evolution support which

00:07:24,550 --> 00:07:29,110
is really important for real-world

00:07:26,560 --> 00:07:30,730
systems and by the way this is another

00:07:29,110 --> 00:07:34,030
thing which is very complicated

00:07:30,730 --> 00:07:39,880
using your authorization we should also

00:07:34,030 --> 00:07:42,520
consider the the expected implementation

00:07:39,880 --> 00:07:45,760
effort of course this is the rice a lot

00:07:42,520 --> 00:07:48,520
for different libraries but in general

00:07:45,760 --> 00:07:51,220
it is pretty hard to beat generalization

00:07:48,520 --> 00:07:53,770
the decisive point might be the

00:07:51,220 --> 00:07:57,520
requirement for human readability it is

00:07:53,770 --> 00:07:59,530
size if we can use JSON or XML or if we

00:07:57,520 --> 00:08:03,550
can go for one of the binary formats and

00:07:59,530 --> 00:08:05,550
with all their advantages transport are

00:08:03,550 --> 00:08:08,050
included here other language bindings

00:08:05,550 --> 00:08:10,210
this very depends on a particular use

00:08:08,050 --> 00:08:13,330
case but obviously as we are in today's

00:08:10,210 --> 00:08:15,720
all libraries I want to mention have the

00:08:13,330 --> 00:08:15,720
API

00:08:17,020 --> 00:08:22,100
JSON is the most use human readable

00:08:19,760 --> 00:08:25,250
format daliyah days surely there are

00:08:22,100 --> 00:08:28,520
some others like XML or CSV or whatever

00:08:25,250 --> 00:08:30,590
which set only habitus cases but I would

00:08:28,520 --> 00:08:33,020
go mainstream surely it has

00:08:30,590 --> 00:08:35,690
disadvantages it's not a reflow and

00:08:33,020 --> 00:08:37,430
boating but if you need to have a human

00:08:35,690 --> 00:08:40,669
readable format it is a good way to go

00:08:37,430 --> 00:08:45,470
and the good thing is that there are so

00:08:40,669 --> 00:08:47,660
many great libraries available full

00:08:45,470 --> 00:08:51,260
binary formats we have two options

00:08:47,660 --> 00:08:54,440
firstly hematomas meaning data are sent

00:08:51,260 --> 00:08:56,390
together with corresponding metadata the

00:08:54,440 --> 00:08:58,910
main advantage is we do not have to

00:08:56,390 --> 00:09:01,730
define schema so it is almost like using

00:08:58,910 --> 00:09:04,750
the reservation but performance wise

00:09:01,730 --> 00:09:07,550
these formats are a very different story

00:09:04,750 --> 00:09:09,830
as an example we can have cryo and it's

00:09:07,550 --> 00:09:12,320
Culebra name chill and by the way

00:09:09,830 --> 00:09:16,280
setting up this and in akka is a matter

00:09:12,320 --> 00:09:18,980
of minutes we can also consider binary

00:09:16,280 --> 00:09:22,100
JSON format like message back orbison

00:09:18,980 --> 00:09:28,340
which basically trade readability for

00:09:22,100 --> 00:09:30,940
performance binary binary formats has

00:09:28,340 --> 00:09:33,410
the schema defined by some kind of dsl

00:09:30,940 --> 00:09:36,980
so they offer great performance and

00:09:33,410 --> 00:09:38,690
minimal footprint and they usually

00:09:36,980 --> 00:09:42,140
provide building support for schema

00:09:38,690 --> 00:09:44,260
evolution a popular choice exporter buff

00:09:42,140 --> 00:09:48,470
and a couple of related projects like

00:09:44,260 --> 00:09:50,420
sled buffers or captain proto another

00:09:48,470 --> 00:09:52,700
representative might be apache forest

00:09:50,420 --> 00:09:55,640
which was available by Facebook or

00:09:52,700 --> 00:09:58,240
Apache Avro which is primarily used in

00:09:55,640 --> 00:09:58,240
Hadoop ecosystem

00:09:58,570 --> 00:10:04,820
so what's wrap this up I like to say you

00:10:02,510 --> 00:10:06,860
should always or if you plan to go to

00:10:04,820 --> 00:10:09,710
production at least replace Java

00:10:06,860 --> 00:10:11,990
salvation with something else this very

00:10:09,710 --> 00:10:14,720
depends on your particular use case so I

00:10:11,990 --> 00:10:17,870
leave it up to you but if you want to

00:10:14,720 --> 00:10:18,680
have like a fake buy recommendation go

00:10:17,870 --> 00:10:22,940
for one of these

00:10:18,680 --> 00:10:25,280
Jason 4's cry or protobuf all of them

00:10:22,940 --> 00:10:27,610
are great and proof libraries and dish

00:10:25,280 --> 00:10:27,610
work

00:10:30,140 --> 00:10:35,760
this topic is not about what people do

00:10:33,240 --> 00:10:39,300
it is not more about what they don't do

00:10:35,760 --> 00:10:41,540
but I think they should I like to make a

00:10:39,300 --> 00:10:43,680
brief motivation about supervision

00:10:41,540 --> 00:10:46,290
honestly I have a feeling that

00:10:43,680 --> 00:10:48,750
supervision is one of the ACA's

00:10:46,290 --> 00:10:54,630
fundamental ideas which is not used as

00:10:48,750 --> 00:10:57,510
it should so let's have a very quick

00:10:54,630 --> 00:11:00,060
recap these are true to the actors we

00:10:57,510 --> 00:11:03,180
create them like calling actors system

00:11:00,060 --> 00:11:04,830
built actor of we call them top level

00:11:03,180 --> 00:11:08,400
because they are created by the system

00:11:04,830 --> 00:11:10,290
not by another actor one of the key

00:11:08,400 --> 00:11:12,900
points of access supervision is that

00:11:10,290 --> 00:11:16,770
every actor or almost every actor as

00:11:12,900 --> 00:11:21,029
your cinema has a supervisor so who

00:11:16,770 --> 00:11:23,430
supply this as you guys probably know

00:11:21,029 --> 00:11:25,560
these actors are implicitly supervised

00:11:23,430 --> 00:11:28,260
by the Guardian or sometimes our friends

00:11:25,560 --> 00:11:30,750
and the route actor and the second key

00:11:28,260 --> 00:11:33,060
point of supervision is that every actor

00:11:30,750 --> 00:11:37,680
can also be a supervisor and every

00:11:33,060 --> 00:11:39,570
active supervises is children so when we

00:11:37,680 --> 00:11:42,600
start creating actors but by using

00:11:39,570 --> 00:11:45,350
anchor system but by using active

00:11:42,600 --> 00:11:48,330
context we can get something like this

00:11:45,350 --> 00:11:51,120
so for example C 1 and C 2 are

00:11:48,330 --> 00:11:54,810
supervised by B 1 and B 1 is supervised

00:11:51,120 --> 00:11:57,900
by a 2 and so on so that will be higher

00:11:54,810 --> 00:12:01,050
here and now let's talk about what is it

00:11:57,900 --> 00:12:03,570
good for the point is that every time

00:12:01,050 --> 00:12:06,420
active probes and analytic ception

00:12:03,570 --> 00:12:09,300
his supervisor may decide what to do

00:12:06,420 --> 00:12:11,310
with that he can tell the actors to

00:12:09,300 --> 00:12:13,589
ignore it he can also stop the actor

00:12:11,310 --> 00:12:16,260
restarted or s credits up to his own

00:12:13,589 --> 00:12:18,750
supervisor and he can also apply this

00:12:16,260 --> 00:12:21,900
know just to the problematic actor but

00:12:18,750 --> 00:12:25,560
all its siblings and it's pretty much it

00:12:21,900 --> 00:12:29,550
so there were these directors but we

00:12:25,560 --> 00:12:31,620
also have system actors their job is

00:12:29,550 --> 00:12:33,959
basically to take care of active system

00:12:31,620 --> 00:12:37,320
features like actor logging for example

00:12:33,959 --> 00:12:39,420
or they are also responsible for actor

00:12:37,320 --> 00:12:41,880
system shutdown and all these in

00:12:39,420 --> 00:12:43,440
lecture thanks but this is not that

00:12:41,880 --> 00:12:44,820
important for us you know I think it's

00:12:43,440 --> 00:12:48,540
just good to know that it's something

00:12:44,820 --> 00:12:51,030
like that and also if you're wondering

00:12:48,540 --> 00:12:54,840
what is this / actor on the top this guy

00:12:51,030 --> 00:12:58,280
is called good guardian and it's it's

00:12:54,840 --> 00:13:01,740
the only actor which is not supervised

00:12:58,280 --> 00:13:04,170
so there was the quick wake up with the

00:13:01,740 --> 00:13:06,960
supervision s but why do we want that

00:13:04,170 --> 00:13:10,440
basically there are two battles we want

00:13:06,960 --> 00:13:13,020
to win firstly we want to separate our

00:13:10,440 --> 00:13:16,770
business logic and our handling for

00:13:13,020 --> 00:13:18,870
having less complex code and secondly we

00:13:16,770 --> 00:13:20,940
want our application to be able to get

00:13:18,870 --> 00:13:25,020
back to life or after something bad

00:13:20,940 --> 00:13:27,140
happened supervision gives us a fella

00:13:25,020 --> 00:13:30,590
isolation and a system recovering and

00:13:27,140 --> 00:13:37,320
therefore no more midnight calls for us

00:13:30,590 --> 00:13:39,840
hopefully obviously I don't want you to

00:13:37,320 --> 00:13:42,360
push you into using supervision wherever

00:13:39,840 --> 00:13:42,840
possible and it's probably not a good

00:13:42,360 --> 00:13:45,240
idea

00:13:42,840 --> 00:13:47,720
you guys should already decided makes

00:13:45,240 --> 00:13:52,380
more sense in your particular use case I

00:13:47,720 --> 00:13:55,260
think a nice guideline how to decide is

00:13:52,380 --> 00:13:58,350
to split your exceptions into arrows and

00:13:55,260 --> 00:14:00,900
sailors error and common events like

00:13:58,350 --> 00:14:03,960
inquiry class problems during validation

00:14:00,900 --> 00:14:05,970
and so on and they are communicated with

00:14:03,960 --> 00:14:08,400
the clients which color on the other

00:14:05,970 --> 00:14:11,160
hand the failure is an unexpected event

00:14:08,400 --> 00:14:13,460
within a service that prevents it from

00:14:11,160 --> 00:14:16,020
continuing to function normally

00:14:13,460 --> 00:14:18,300
stellar were generally present responses

00:14:16,020 --> 00:14:21,870
to current and possibly or following

00:14:18,300 --> 00:14:23,430
requests fellow should be reported to

00:14:21,870 --> 00:14:27,900
the supervisor you know the client

00:14:23,430 --> 00:14:29,550
cannot do anything about it anyway as an

00:14:27,900 --> 00:14:31,530
example we can have you know database

00:14:29,550 --> 00:14:34,950
fillers Network partitions Hardware

00:14:31,530 --> 00:14:36,300
malfunctions and so on and by the way

00:14:34,950 --> 00:14:38,550
this is not something I just made up

00:14:36,300 --> 00:14:43,520
yesterday this is taken from the erector

00:14:38,550 --> 00:14:43,520
manifesto so the core idea is railroad

00:14:44,150 --> 00:14:49,380
regarding supervision we may have a

00:14:46,770 --> 00:14:52,200
problem what to do with an active state

00:14:49,380 --> 00:14:54,930
during your start there is this pattern

00:14:52,200 --> 00:14:56,280
for it basically it is just a simple

00:14:54,930 --> 00:14:59,250
guideline you should try to follow

00:14:56,280 --> 00:15:01,800
stating that if an active carrier's

00:14:59,250 --> 00:15:03,930
important internal state then it should

00:15:01,800 --> 00:15:06,780
delegate dangerous tasks to its children

00:15:03,930 --> 00:15:10,710
to prevent the state carrying actor from

00:15:06,780 --> 00:15:13,020
cashing sometimes it might make sense to

00:15:10,710 --> 00:15:18,770
create a new character Forge for each

00:15:13,020 --> 00:15:18,770
such task but there's usually not needed

00:15:20,300 --> 00:15:25,110
another thing regarding supervision

00:15:23,010 --> 00:15:26,180
which is often forgotten is the back of

00:15:25,110 --> 00:15:28,830
supervisor

00:15:26,180 --> 00:15:30,990
usually when we want to restart an actor

00:15:28,830 --> 00:15:33,330
we want to do it as soon as possible and

00:15:30,990 --> 00:15:36,300
not surprisingly this will be the

00:15:33,330 --> 00:15:38,400
default occurs behavior but there are

00:15:36,300 --> 00:15:40,470
certain use cases when we want to play

00:15:38,400 --> 00:15:44,160
it a little bit let's say some external

00:15:40,470 --> 00:15:46,920
resource is not available and we need to

00:15:44,160 --> 00:15:49,170
give it some time to start up again the

00:15:46,920 --> 00:15:52,100
third example is when a person active

00:15:49,170 --> 00:15:55,320
fails because of the storage failure

00:15:52,100 --> 00:15:58,560
Romanian restart would lead to other

00:15:55,320 --> 00:16:00,720
failure and another restart and so on so

00:15:58,560 --> 00:16:04,290
we would effectively don't think our

00:16:00,720 --> 00:16:07,830
system like of supervisor all just to

00:16:04,290 --> 00:16:10,790
restart electors each time with growing

00:16:07,830 --> 00:16:14,160
time delay between due to start and

00:16:10,790 --> 00:16:18,300
tries to avoid that as you guys probably

00:16:14,160 --> 00:16:20,850
notice I put a simple example in the

00:16:18,300 --> 00:16:23,490
slide it definitely has other config

00:16:20,850 --> 00:16:27,440
options but let's keep it simple

00:16:23,490 --> 00:16:27,440
so let me go through that

00:16:30,230 --> 00:16:35,600
the API gives us two ways how to

00:16:33,450 --> 00:16:38,760
identify a failure the first option is

00:16:35,600 --> 00:16:42,209
what do you see in the slide but an

00:16:38,760 --> 00:16:44,040
active crash but it can also react to an

00:16:42,209 --> 00:16:47,339
access stop if it works you know better

00:16:44,040 --> 00:16:50,730
for your needs then we have to define

00:16:47,339 --> 00:16:53,700
the actor you are supervised I finish

00:16:50,730 --> 00:16:57,360
parameters are aspect are quite clear to

00:16:53,700 --> 00:16:59,880
all of us but maybe one thing worth

00:16:57,360 --> 00:17:01,560
mentioning as you can see we are

00:16:59,880 --> 00:17:04,110
creating a supervised actor by the

00:17:01,560 --> 00:17:06,420
supervisor so it might look like that

00:17:04,110 --> 00:17:09,120
this supervisor gets messages intended

00:17:06,420 --> 00:17:10,860
for the actor but obviously it isn't

00:17:09,120 --> 00:17:13,319
like that it is designed to be as

00:17:10,860 --> 00:17:16,199
transparent as possible so the user

00:17:13,319 --> 00:17:21,750
messages are forwarded to the child

00:17:16,199 --> 00:17:24,720
actor and this is how does the actual

00:17:21,750 --> 00:17:26,550
back of config looks like we can define

00:17:24,720 --> 00:17:29,490
the initial duration which is set to 3

00:17:26,550 --> 00:17:32,850
seconds here also we have to bound it

00:17:29,490 --> 00:17:37,080
somehow so in this bit by the cup is for

00:17:32,850 --> 00:17:39,390
the seconds as I mentioned felt extra be

00:17:37,080 --> 00:17:43,580
restarted and increasing interval in

00:17:39,390 --> 00:17:49,710
this case it will be after 3 6 12 24 and

00:17:43,580 --> 00:17:51,809
finally after 40 seconds and this is the

00:17:49,710 --> 00:17:54,900
last bit I want to show you here it's

00:17:51,809 --> 00:17:56,460
random factor parameter imagine that we

00:17:54,900 --> 00:17:59,910
have a couple of hundreds of actors

00:17:56,460 --> 00:18:02,179
lying on external resource and it goes

00:17:59,910 --> 00:18:05,640
down but after some time and it covers

00:18:02,179 --> 00:18:07,980
so what happens now after the next stick

00:18:05,640 --> 00:18:11,520
these hundreds of actors simultaneously

00:18:07,980 --> 00:18:12,470
hit the resource and this might break it

00:18:11,520 --> 00:18:14,910
again

00:18:12,470 --> 00:18:17,760
so we have an option to add additional

00:18:14,910 --> 00:18:20,370
random delay or or noise if you well to

00:18:17,760 --> 00:18:23,250
it you know this may help in some cases

00:18:20,370 --> 00:18:29,010
this order to value means that it adds

00:18:23,250 --> 00:18:30,660
up to 20 percent delay so yeah and it's

00:18:29,010 --> 00:18:35,300
pretty much all I wanted to say about

00:18:30,660 --> 00:18:35,300
the back of supervisor so let's smile it

00:18:36,300 --> 00:18:40,710
I can provide supervision which offers

00:18:39,000 --> 00:18:42,420
us to create rich hierarchies to

00:18:40,710 --> 00:18:43,020
separate business logic and fellow

00:18:42,420 --> 00:18:45,360
handlink

00:18:43,020 --> 00:18:47,309
and also try to have in mind that

00:18:45,360 --> 00:18:54,720
something like the back of supervisor

00:18:47,309 --> 00:18:57,890
exists another topic I like to discuss a

00:18:54,720 --> 00:19:00,390
greater shutdown so let's say we have

00:18:57,890 --> 00:19:02,910
thousands of Shalott actors on tens of

00:19:00,390 --> 00:19:05,610
nodes and we want to shut one of them

00:19:02,910 --> 00:19:10,170
down because of maintenance or hardware

00:19:05,610 --> 00:19:12,210
issues or whatever essentially we want

00:19:10,170 --> 00:19:14,130
to do something like this but we don't

00:19:12,210 --> 00:19:16,890
want to put data which are already in

00:19:14,130 --> 00:19:22,470
the note this operation of the totally

00:19:16,890 --> 00:19:23,910
transparent to our users so let's talk

00:19:22,470 --> 00:19:27,540
about how the procedure should look like

00:19:23,910 --> 00:19:29,820
from a higher the point of view I'd only

00:19:27,540 --> 00:19:32,070
wanted to show you examples here but was

00:19:29,820 --> 00:19:33,780
unable to squeeze it but if anyone is

00:19:32,070 --> 00:19:40,410
interested there in the backup slide

00:19:33,780 --> 00:19:42,030
section in the end firstly JVM gets the

00:19:40,410 --> 00:19:45,000
shutdown signal which triggers this

00:19:42,030 --> 00:19:47,570
whole exercise when it happens we tell

00:19:45,000 --> 00:19:50,910
coordinator the procedure has started

00:19:47,570 --> 00:19:53,100
the coordinator is stateful entity which

00:19:50,910 --> 00:19:53,850
manages values dates of graceful

00:19:53,100 --> 00:19:57,929
shutdown

00:19:53,850 --> 00:20:01,650
I like icon in my case coordinator is

00:19:57,929 --> 00:20:07,470
implemented as an actor but of course

00:20:01,650 --> 00:20:10,320
you can do it differently now the

00:20:07,470 --> 00:20:12,500
coordinator has to tell local regions

00:20:10,320 --> 00:20:15,450
they have to leave the cluster and wait

00:20:12,500 --> 00:20:17,429
under it down so it has to send a card

00:20:15,450 --> 00:20:22,080
graceful shadow message and watch their

00:20:17,429 --> 00:20:25,230
lifecycle updates when it is done

00:20:22,080 --> 00:20:28,890
according to ask the node to lead the

00:20:25,230 --> 00:20:31,110
cluster and give Singleton's a grace

00:20:28,890 --> 00:20:34,260
period to migrate unfortunately there is

00:20:31,110 --> 00:20:39,179
no callback for this so it has to evade

00:20:34,260 --> 00:20:41,400
specified amount of time finally we can

00:20:39,179 --> 00:20:46,139
kill the coordinator shut down the actor

00:20:41,400 --> 00:20:49,120
system and let JVM to be terminated

00:20:46,139 --> 00:20:51,309
at some point you'll have to add

00:20:49,120 --> 00:20:54,460
messages for interaction with shouted

00:20:51,309 --> 00:20:56,019
actors or just a quick note if you want

00:20:54,460 --> 00:20:58,389
to stop the actor gracefully you

00:20:56,019 --> 00:21:02,559
specified if you need to stop it

00:20:58,389 --> 00:21:04,510
immediately use contacted stop and last

00:21:02,559 --> 00:21:05,169
thing I wanna mention here is the parity

00:21:04,510 --> 00:21:08,620
mailbox

00:21:05,169 --> 00:21:11,500
it is good to have it because it's also

00:21:08,620 --> 00:21:13,899
graceful shutdown such con messages to

00:21:11,500 --> 00:21:16,389
be handed in priority basically it

00:21:13,899 --> 00:21:19,299
maintains two queues one for normal and

00:21:16,389 --> 00:21:21,370
one for parity messages it also may

00:21:19,299 --> 00:21:24,669
response the nagas shutting down so the

00:21:21,370 --> 00:21:29,919
message can be sent to another node if

00:21:24,669 --> 00:21:31,330
needed so it was the idea how it could

00:21:29,919 --> 00:21:35,289
be implemented you know if anyone is

00:21:31,330 --> 00:21:39,210
interested some code samples are in the

00:21:35,289 --> 00:21:42,580
end now let's briefly talk about

00:21:39,210 --> 00:21:44,889
coordinated shutdown extension which

00:21:42,580 --> 00:21:48,399
were edit which was added to a

00:21:44,889 --> 00:21:51,519
conversion to the v and it was raised

00:21:48,399 --> 00:21:53,289
like a week ago I don't think you'll be

00:21:51,519 --> 00:21:55,779
surprised but I have to admit I don't

00:21:53,289 --> 00:21:58,929
have and it will really experiences it

00:21:55,779 --> 00:22:04,769
but I think in mine it might be useful

00:21:58,929 --> 00:22:04,769
in our case so basically what it does

00:22:06,330 --> 00:22:13,899
basically it defines a bench of faces

00:22:10,450 --> 00:22:16,630
like service stop cluster exit tank or

00:22:13,899 --> 00:22:19,809
actor system terminate and we can reduce

00:22:16,630 --> 00:22:21,909
the task to each face and these stars

00:22:19,809 --> 00:22:25,299
will be executed at various points

00:22:21,909 --> 00:22:27,429
during the shutdown the task is pretty

00:22:25,299 --> 00:22:29,559
much a function returning the future of

00:22:27,429 --> 00:22:34,299
done which is used just for signaling

00:22:29,559 --> 00:22:37,630
completion so we can add pretty much

00:22:34,299 --> 00:22:40,690
anything into it for our case it's

00:22:37,630 --> 00:22:43,750
important that it also has phases like

00:22:40,690 --> 00:22:46,389
no shouting shutdown leaf cluster or

00:22:43,750 --> 00:22:48,820
actor system terminate which we can use

00:22:46,389 --> 00:22:53,399
for full graceful shutdown in a similar

00:22:48,820 --> 00:22:56,320
way I describe like a minute ago so if

00:22:53,399 --> 00:22:58,630
this really works as I hope it does

00:22:56,320 --> 00:23:04,450
thank you Island

00:22:58,630 --> 00:23:07,200
was really needed so let's have a quick

00:23:04,450 --> 00:23:09,669
summary we usually don't want to data

00:23:07,200 --> 00:23:13,809
sometime it's fine but most of the time

00:23:09,669 --> 00:23:16,030
we do care about it we discussed two

00:23:13,809 --> 00:23:18,280
approaches how to implement this the

00:23:16,030 --> 00:23:21,070
first one is the menu one its

00:23:18,280 --> 00:23:24,190
implementation it is not that hard but

00:23:21,070 --> 00:23:26,440
some knowledge is necessary we need to

00:23:24,190 --> 00:23:28,240
implement a note return coordinator to

00:23:26,440 --> 00:23:30,640
handle BIOS states of the shutdown

00:23:28,240 --> 00:23:34,539
procedure and also we need to do some

00:23:30,640 --> 00:23:37,510
integration with our chatot actors or we

00:23:34,539 --> 00:23:42,130
can try to use the Supra nuoc extension

00:23:37,510 --> 00:23:44,200
and corriente shutdown so that said full

00:23:42,130 --> 00:23:51,820
grace or shutdown and now the

00:23:44,200 --> 00:23:54,520
distributed transactions so distributed

00:23:51,820 --> 00:23:56,919
transactions or any situation were a

00:23:54,520 --> 00:23:59,409
single event results in the changes of

00:23:56,919 --> 00:24:02,770
two or more separate data sources which

00:23:59,409 --> 00:24:05,260
cannot be committed atomically of course

00:24:02,770 --> 00:24:11,620
this definition is very informal but I

00:24:05,260 --> 00:24:13,690
think it suits our purpose real well the

00:24:11,620 --> 00:24:16,679
problem is especially for knife

00:24:13,690 --> 00:24:20,049
implementation it works most of the time

00:24:16,679 --> 00:24:22,780
but there is something named policies of

00:24:20,049 --> 00:24:24,520
distributed programming in case if any

00:24:22,780 --> 00:24:27,370
one of you hasn't heard about it yet

00:24:24,520 --> 00:24:30,400
please take a look at it it is really

00:24:27,370 --> 00:24:32,020
crucial if this would be the only thing

00:24:30,400 --> 00:24:36,280
you got from this plantation it was

00:24:32,020 --> 00:24:38,860
totally worth it so just a quick few

00:24:36,280 --> 00:24:41,919
inside we are talking about a set of

00:24:38,860 --> 00:24:45,429
assumptions people tend to have above

00:24:41,919 --> 00:24:48,220
distributed systems like the network is

00:24:45,429 --> 00:24:50,890
reliable latency is zero bandwidth is

00:24:48,220 --> 00:24:54,010
infinite topology doesn't change and so

00:24:50,890 --> 00:24:58,320
on and this makes distributed

00:24:54,010 --> 00:24:58,320
transactions fight joinging

00:25:00,300 --> 00:25:04,550
a classic approach how to tackle

00:25:02,400 --> 00:25:09,090
distributed transactions is the

00:25:04,550 --> 00:25:11,400
two-phase commit the point of 2pc is it

00:25:09,090 --> 00:25:13,740
performs and the bit operations first

00:25:11,400 --> 00:25:16,770
and if all succeed the comments are

00:25:13,740 --> 00:25:19,140
confirmed so basically it prepares the

00:25:16,770 --> 00:25:22,309
operation which is valid for certain

00:25:19,140 --> 00:25:24,990
amount of time or until acknowledged and

00:25:22,309 --> 00:25:27,809
it is possible to implement in a

00:25:24,990 --> 00:25:31,230
reactive async a singles messages of

00:25:27,809 --> 00:25:33,270
course we need to have additional driver

00:25:31,230 --> 00:25:35,250
grantee and therefore we need to have

00:25:33,270 --> 00:25:36,809
some kind of very system storage and

00:25:35,250 --> 00:25:39,809
also we have to take care of it

00:25:36,809 --> 00:25:42,750
application or we have to use idempotent

00:25:39,809 --> 00:25:46,230
messages and so on but the main problems

00:25:42,750 --> 00:25:50,520
are it doesn't scale well it's so a

00:25:46,230 --> 00:25:52,620
certain deadlock is as I said in the

00:25:50,520 --> 00:25:55,410
beginning a it was possible to implement

00:25:52,620 --> 00:26:03,720
this in akka but there is a better way

00:25:55,410 --> 00:26:05,790
and the saiga pattern saga is a real

00:26:03,720 --> 00:26:08,910
word solution how to take distributed

00:26:05,790 --> 00:26:11,970
transactions the point of saga is that

00:26:08,910 --> 00:26:15,300
each of the local comets also contains a

00:26:11,970 --> 00:26:17,520
counterpart the counterpart is a

00:26:15,300 --> 00:26:20,220
competitive action of the corresponding

00:26:17,520 --> 00:26:23,130
transaction the textbook example is that

00:26:20,220 --> 00:26:26,010
we have comments or sub transactions if

00:26:23,130 --> 00:26:28,770
you will like Google Code for buy

00:26:26,010 --> 00:26:31,650
tickets when the car with compensating

00:26:28,770 --> 00:26:35,280
actions like cancel hopeful or the car

00:26:31,650 --> 00:26:37,320
and so on and if something goes wrong we

00:26:35,280 --> 00:26:41,070
apply all these competitive action and

00:26:37,320 --> 00:26:42,720
reverse the transaction again we have to

00:26:41,070 --> 00:26:45,390
take care of the quirements like at

00:26:42,720 --> 00:26:45,860
least one very very duplication and so

00:26:45,390 --> 00:26:52,860
on

00:26:45,860 --> 00:26:55,980
but is the way you should go but there

00:26:52,860 --> 00:26:58,220
is an alternative option try to avoid

00:26:55,980 --> 00:27:01,140
distributed transactions by possible

00:26:58,220 --> 00:27:03,330
meaning that every business event needs

00:27:01,140 --> 00:27:07,260
to result in single synchronous commit

00:27:03,330 --> 00:27:10,919
and the other data sources could be

00:27:07,260 --> 00:27:12,660
updated a synchronously so basically we

00:27:10,919 --> 00:27:13,680
are going to give up or nothing approach

00:27:12,660 --> 00:27:15,300
and we are

00:27:13,680 --> 00:27:19,680
going to introduce eventual consistency

00:27:15,300 --> 00:27:21,560
in our system and this is often the best

00:27:19,680 --> 00:27:26,270
thing we can do

00:27:21,560 --> 00:27:28,250
so the outcome of this section should be

00:27:26,270 --> 00:27:31,410
distributed transactions are hard

00:27:28,250 --> 00:27:34,290
expensive fragile and not okay well and

00:27:31,410 --> 00:27:36,780
it should be avoided by possible if you

00:27:34,290 --> 00:27:43,950
cannot avoid them go for the Saiga

00:27:36,780 --> 00:27:47,040
button based implementation and our

00:27:43,950 --> 00:27:50,070
entree latencies so consider a system

00:27:47,040 --> 00:27:54,450
where eight service typical response and

00:27:50,070 --> 00:27:59,190
10 MLS but with 99% a latency of one

00:27:54,450 --> 00:28:02,010
second the distribution could look like

00:27:59,190 --> 00:28:06,080
this the latencies we will expect our

00:28:02,010 --> 00:28:08,760
grain long tails are arranged so 99th

00:28:06,080 --> 00:28:12,930
percentile responses could be like 40

00:28:08,760 --> 00:28:13,320
times slower and in case of 99.9 percent

00:28:12,930 --> 00:28:16,290
pal

00:28:13,320 --> 00:28:18,530
it could be like 50 times slower and by

00:28:16,290 --> 00:28:21,450
the way this graph also show us how

00:28:18,530 --> 00:28:23,880
important is to study hole latency

00:28:21,450 --> 00:28:25,890
distributions no just means you know

00:28:23,880 --> 00:28:32,550
using needs only this problem could be

00:28:25,890 --> 00:28:34,650
overlooked is the way the 99th

00:28:32,550 --> 00:28:37,800
percentile of 30 Millions

00:28:34,650 --> 00:28:39,840
that one request in 100 experience for

00:28:37,800 --> 00:28:43,500
Tamila site and say instead of expected

00:28:39,840 --> 00:28:45,000
let's say one millisecond mover most of

00:28:43,500 --> 00:28:48,420
our systems are distributed

00:28:45,000 --> 00:28:50,610
microservices so one request can create

00:28:48,420 --> 00:28:54,450
a bunch of other requests in our system

00:28:50,610 --> 00:28:57,000
for example let's say one client request

00:28:54,450 --> 00:29:00,030
generates 10 sub requests and assume

00:28:57,000 --> 00:29:03,840
there is a 1% probability of hitting a

00:29:00,030 --> 00:29:07,550
slow service so we got 95% chance the

00:29:03,840 --> 00:29:10,230
request is affected by the slow response

00:29:07,550 --> 00:29:13,110
long tails can be caused by various

00:29:10,230 --> 00:29:14,750
reasons like harder or network issues

00:29:13,110 --> 00:29:17,460
group

00:29:14,750 --> 00:29:20,550
architecture implementation problems and

00:29:17,460 --> 00:29:23,130
so on but it's important to realize it

00:29:20,550 --> 00:29:27,680
is not just a noise or some Peaks caused

00:29:23,130 --> 00:29:27,680
by power users it is a real problem

00:29:34,010 --> 00:29:40,280
sorry usually when we are facing a

00:29:36,860 --> 00:29:42,260
problem we try to sort it out doing so a

00:29:40,280 --> 00:29:45,049
general approach to take along tails is

00:29:42,260 --> 00:29:47,570
following firstly try to narrow the

00:29:45,049 --> 00:29:49,190
problem as much as possible and we

00:29:47,570 --> 00:29:52,040
distributed systems are usually quite

00:29:49,190 --> 00:29:55,100
complex so every bit comes when we

00:29:52,040 --> 00:29:57,020
should yeah then we should isolated in

00:29:55,100 --> 00:30:01,190
at this environment and start measure

00:29:57,020 --> 00:30:02,750
and want to everything if if everything

00:30:01,190 --> 00:30:05,780
goes fine we should be able to identify

00:30:02,750 --> 00:30:08,150
and fix the problem but it is usually

00:30:05,780 --> 00:30:10,400
not that easy actually it is usually

00:30:08,150 --> 00:30:12,400
very hard it could take weeks or

00:30:10,400 --> 00:30:15,049
investigation with an uncertain result

00:30:12,400 --> 00:30:19,780
so if you're struggling to tackle a

00:30:15,049 --> 00:30:19,780
problem there might be a better way and

00:30:20,320 --> 00:30:25,990
that's all anything long details in a

00:30:22,970 --> 00:30:29,179
similar way how we tolerate failures

00:30:25,990 --> 00:30:34,400
that is a bunch of approaches so let me

00:30:29,179 --> 00:30:36,890
go through that a generic quests meaning

00:30:34,400 --> 00:30:39,440
sending the same requests to multiple

00:30:36,890 --> 00:30:43,250
servers and use whatever comes back

00:30:39,440 --> 00:30:45,290
first just a very important note to ever

00:30:43,250 --> 00:30:48,350
doubling or tripling the load do not

00:30:45,290 --> 00:30:50,110
send the hedging request immediately but

00:30:48,350 --> 00:30:53,470
try to wait until the original request

00:30:50,110 --> 00:30:57,200
has been outstanding for more than like

00:30:53,470 --> 00:31:00,080
95th percentile so additional load

00:30:57,200 --> 00:31:04,030
should be our 5% but the long tail

00:31:00,080 --> 00:31:04,030
should be shortened at significant play

00:31:04,390 --> 00:31:09,770
then we have tie requests it means

00:31:07,340 --> 00:31:12,049
instead of delaying before sending out a

00:31:09,770 --> 00:31:13,910
hedge request we anchor requests

00:31:12,049 --> 00:31:16,330
simultaneously on multiple servers and

00:31:13,910 --> 00:31:19,309
we also tie them together with

00:31:16,330 --> 00:31:21,380
information about the others when the

00:31:19,309 --> 00:31:24,530
first set of process the requests it can

00:31:21,380 --> 00:31:27,679
tell the others to cancel it from that

00:31:24,530 --> 00:31:31,270
queues in a real Google system this

00:31:27,679 --> 00:31:36,429
ready use median latency by 16% and the

00:31:31,270 --> 00:31:36,429
99.9 percent tiles reduced by 40%

00:31:37,530 --> 00:31:43,920
and sites of the increased application

00:31:40,650 --> 00:31:46,320
factors this one is the do best try to

00:31:43,920 --> 00:31:51,960
have more copies of things which you

00:31:46,320 --> 00:31:54,330
find more important we can also try to

00:31:51,960 --> 00:31:56,280
temporarily exclude to slow machine from

00:31:54,330 --> 00:31:58,680
our operations since the source of

00:31:56,280 --> 00:32:00,450
problems might be temporary we can

00:31:58,680 --> 00:32:02,280
continue to sense your access to the

00:32:00,450 --> 00:32:04,770
machine and monitor it

00:32:02,280 --> 00:32:10,200
if the problem is appears we can put it

00:32:04,770 --> 00:32:12,390
back considered good and our responses

00:32:10,200 --> 00:32:14,220
meaning responding with incomplete

00:32:12,390 --> 00:32:21,210
results in exchange for better

00:32:14,220 --> 00:32:24,300
end-to-end latency and the last 100

00:32:21,210 --> 00:32:26,400
update can be the fastest and a

00:32:24,300 --> 00:32:32,970
reasonably cheap way to peg the problem

00:32:26,400 --> 00:32:35,160
so come to the disc as well so it was

00:32:32,970 --> 00:32:37,320
last topic I wanted to talk about but

00:32:35,160 --> 00:32:40,590
before we finish I got a couple of

00:32:37,320 --> 00:32:46,680
points I'd like to mention at least aka

00:32:40,590 --> 00:32:49,710
heaven enough time topics the first one

00:32:46,680 --> 00:32:52,050
is monitoring I don't want to stress

00:32:49,710 --> 00:32:54,390
here how important monitoring is because

00:32:52,050 --> 00:32:56,250
we all know it provides a crucial view

00:32:54,390 --> 00:32:59,340
what's really happening inside our

00:32:56,250 --> 00:33:02,360
applications if any one of you guys

00:32:59,340 --> 00:33:05,970
doesn't agree let's catch up in a minute

00:33:02,360 --> 00:33:08,370
so what options do we have here if you

00:33:05,970 --> 00:33:11,280
have the live band subscription the

00:33:08,370 --> 00:33:14,700
simplest half is to use it in build

00:33:11,280 --> 00:33:16,800
monitoring component called Sam on which

00:33:14,700 --> 00:33:20,160
is super easy to use and provides quite

00:33:16,800 --> 00:33:22,800
a lot of features and it is also tightly

00:33:20,160 --> 00:33:23,370
coupled with active systems if it is

00:33:22,800 --> 00:33:26,670
good or bad

00:33:23,370 --> 00:33:29,190
I leave it up to you from the third

00:33:26,670 --> 00:33:31,560
party options my personal favorite is

00:33:29,190 --> 00:33:33,780
come on which offers very rich

00:33:31,560 --> 00:33:37,800
functionalities and by the way it is

00:33:33,780 --> 00:33:40,440
based on for kaká and now the point I

00:33:37,800 --> 00:33:42,570
want to stress about try to implement

00:33:40,440 --> 00:33:45,420
and study sync monitoring as soon as

00:33:42,570 --> 00:33:47,429
possible not on performance tests you

00:33:45,420 --> 00:33:49,610
know two weeks before production went

00:33:47,429 --> 00:33:49,610
wrong

00:33:51,409 --> 00:33:56,450
the next thing I'll mention here and

00:33:53,570 --> 00:33:59,029
middle partition a fundamental problem

00:33:56,450 --> 00:34:01,419
and distributed system is the mental

00:33:59,029 --> 00:34:03,200
partitions machine gracious or just

00:34:01,419 --> 00:34:06,740
unresponsive services are

00:34:03,200 --> 00:34:09,079
indistinguishable for the observer so

00:34:06,740 --> 00:34:11,230
when there is a crash you want to remove

00:34:09,079 --> 00:34:14,119
the node from the cluster mediately and

00:34:11,230 --> 00:34:16,159
when we have a transient problem we want

00:34:14,119 --> 00:34:20,179
to wait for a while as it may heal

00:34:16,159 --> 00:34:23,750
itself apparently these two cases are in

00:34:20,179 --> 00:34:26,980
conflict with each other you know this

00:34:23,750 --> 00:34:30,379
program is notoriously hot and it's

00:34:26,980 --> 00:34:33,050
causing all the headaches and a really

00:34:30,379 --> 00:34:35,629
bad thing is that these things happen

00:34:33,050 --> 00:34:39,349
surprisingly common in real world

00:34:35,629 --> 00:34:41,839
systems the a capacitor has a fella

00:34:39,349 --> 00:34:44,419
detector that will notice and work

00:34:41,839 --> 00:34:46,720
partitions or machine gratias what if I

00:34:44,419 --> 00:34:49,879
said it cannot distinguish between them

00:34:46,720 --> 00:34:53,740
it just used security hobbies to check

00:34:49,879 --> 00:34:56,839
if other nodes are available and healthy

00:34:53,740 --> 00:34:59,000
and also the tech thing a problem is is

00:34:56,839 --> 00:35:02,390
just the first step it has to take rate

00:34:59,000 --> 00:35:04,579
somehow denied approach is to remove an

00:35:02,390 --> 00:35:08,869
unreachable node from the cluster after

00:35:04,579 --> 00:35:11,290
a timeout this works fine for let's say

00:35:08,869 --> 00:35:15,319
failures and shown in word partitions

00:35:11,290 --> 00:35:17,540
but not for long the partitions because

00:35:15,319 --> 00:35:20,540
both sides of the cluster will see the

00:35:17,540 --> 00:35:22,490
other side of unreachable and after a

00:35:20,540 --> 00:35:27,140
while it may remove it from their

00:35:22,490 --> 00:35:29,420
clusters so if it happens the

00:35:27,140 --> 00:35:31,160
application and applications is things

00:35:29,420 --> 00:35:34,369
like you know cluster Singleton's

00:35:31,160 --> 00:35:41,270
shelving or pedestal actors then we get

00:35:34,369 --> 00:35:43,970
a huge problem there is a concept called

00:35:41,270 --> 00:35:47,810
split brains or straight line resolver

00:35:43,970 --> 00:35:50,119
or FB are if you will which tries to

00:35:47,810 --> 00:35:52,339
tackle this you know just to be clear

00:35:50,119 --> 00:35:53,510
this is not a sort of bullet which makes

00:35:52,339 --> 00:35:57,530
the dogs liable

00:35:53,510 --> 00:35:59,430
it is pretty much risk mitigation so

00:35:57,530 --> 00:36:01,920
basically what it does

00:35:59,430 --> 00:36:04,970
and attempts to sort out spread grain by

00:36:01,920 --> 00:36:07,140
shutting down one of the partitions I

00:36:04,970 --> 00:36:10,260
don't want to talk about implementation

00:36:07,140 --> 00:36:14,190
detail here but it provides a bunch of

00:36:10,260 --> 00:36:16,350
strategies how to tackle that like kill

00:36:14,190 --> 00:36:19,260
the smaller partition or the younger

00:36:16,350 --> 00:36:22,710
partition or keep the partition with a

00:36:19,260 --> 00:36:24,390
particle node and so on and if

00:36:22,710 --> 00:36:27,950
configured correctly we can limit the

00:36:24,390 --> 00:36:31,680
consequences of splitting scenarios I'm

00:36:27,950 --> 00:36:34,170
convinced that having SBR on on board is

00:36:31,680 --> 00:36:39,030
a must when implementing a distributed

00:36:34,170 --> 00:36:41,100
systems akka provides its own SBR but

00:36:39,030 --> 00:36:44,430
you can use it only if you have this

00:36:41,100 --> 00:36:47,610
subscription and I'm not at that of any

00:36:44,430 --> 00:36:51,020
production ready open source solution so

00:36:47,610 --> 00:36:54,720
you can either write your own which is

00:36:51,020 --> 00:37:01,110
definitely interesting exercise or you

00:36:54,720 --> 00:37:04,200
may go for a subscription looking risk

00:37:01,110 --> 00:37:07,350
one is quite DDS but I wanted to mention

00:37:04,200 --> 00:37:09,330
at least try to avoid by possible if you

00:37:07,350 --> 00:37:13,350
need to book is dedicated dispatcher

00:37:09,330 --> 00:37:15,840
slash read pool for that also you can

00:37:13,350 --> 00:37:18,750
try to take advantage of Scott's booking

00:37:15,840 --> 00:37:21,690
hint which may improve performance and

00:37:18,750 --> 00:37:27,480
help to avoid potential deadlock in some

00:37:21,690 --> 00:37:30,270
cases I have seen a couple of times that

00:37:27,480 --> 00:37:31,980
people try to have achieve isolation

00:37:30,270 --> 00:37:35,460
within a micro service by creating

00:37:31,980 --> 00:37:38,070
multiple actor systems and I don't think

00:37:35,460 --> 00:37:40,920
it's a good idea I cap provides next

00:37:38,070 --> 00:37:44,520
blog heading features so use them

00:37:40,920 --> 00:37:46,620
instead of course it's absolutely ok

00:37:44,520 --> 00:37:49,800
when you introduce another actor system

00:37:46,620 --> 00:37:53,180
through various libraries like calf:cow

00:37:49,800 --> 00:37:56,250
cassandra drivers monitoring and so on

00:37:53,180 --> 00:37:58,910
their creators just wanted to hide their

00:37:56,250 --> 00:38:02,220
actors from you and that's absolutely ok

00:37:58,910 --> 00:38:04,620
you know but now the number of system

00:38:02,220 --> 00:38:06,690
systems you marry create in your

00:38:04,620 --> 00:38:09,830
particular microservice should be very

00:38:06,690 --> 00:38:09,830
close to one

00:38:09,840 --> 00:38:18,800
I know the questions and also feel free

00:38:14,190 --> 00:38:18,800
to share common problems you guys sighs

00:38:20,090 --> 00:38:36,750
yeah in the last and favorite slides we

00:38:23,160 --> 00:38:38,280
are also I think okay hello thank you

00:38:36,750 --> 00:38:42,290
for your talk

00:38:38,280 --> 00:38:47,720
my question is do you know is there any

00:38:42,290 --> 00:38:51,960
we visualized monitoring activity coming

00:38:47,720 --> 00:38:54,390
to monitor cluster yeah there's

00:38:51,960 --> 00:38:57,780
definitely batch of tools for monitoring

00:38:54,390 --> 00:39:03,570
and visualization of that my favorite is

00:38:57,780 --> 00:39:05,520
data look if it helps excuse me my

00:39:03,570 --> 00:39:07,310
favorite one is is beta doc which is

00:39:05,520 --> 00:39:10,850
which we're using quite common

00:39:07,310 --> 00:39:10,850
okay thank you

00:39:20,200 --> 00:39:23,200
okay

00:39:28,800 --> 00:39:40,510
okay so thank you very much

00:39:33,340 --> 00:39:40,510

YouTube URL: https://www.youtube.com/watch?v=bXdcX3fH_5g


