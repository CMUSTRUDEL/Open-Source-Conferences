Title: Keynote: Tools for Verified Scala by Viktor Kuncak
Publication date: 2017-06-02
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
I will speak about tools for code verification, synthesis, and repair that my research group at EPFL developed over the past years.
Captions: 
	00:00:00,540 --> 00:00:06,180
[Applause]

00:00:02,600 --> 00:00:08,370
hi everyone it's a great pleasure to be

00:00:06,180 --> 00:00:13,580
speaking in front of such distinguished

00:00:08,370 --> 00:00:15,870
and enlarged audience I'm going to be

00:00:13,580 --> 00:00:17,850
talking about what I've been doing

00:00:15,870 --> 00:00:19,680
essentially for the past 10 years or

00:00:17,850 --> 00:00:23,070
more precisely what my group has been

00:00:19,680 --> 00:00:25,320
doing for the past 10 years distracted

00:00:23,070 --> 00:00:27,990
by some of my advice but I wanted to

00:00:25,320 --> 00:00:30,000
tell you a little bit about where I sort

00:00:27,990 --> 00:00:32,189
of come from in terms of languages

00:00:30,000 --> 00:00:35,190
particularly programming languages so I

00:00:32,189 --> 00:00:36,989
studied for my undergraduate degree at

00:00:35,190 --> 00:00:38,940
the University of Novi Sad in Serbia and

00:00:36,989 --> 00:00:41,399
there I was exposed to wonderful

00:00:38,940 --> 00:00:45,750
languages such as modular 2 and Haskell

00:00:41,399 --> 00:00:48,140
and then when I moved to MIT I started

00:00:45,750 --> 00:00:51,420
with program analysis in particular

00:00:48,140 --> 00:00:55,610
program analysis of a emerge

00:00:51,420 --> 00:00:57,930
increasingly important platform java and

00:00:55,610 --> 00:01:00,960
eventually this evolved into a

00:00:57,930 --> 00:01:04,019
verification effort for java programs

00:01:00,960 --> 00:01:07,170
and one interesting aspect of that is

00:01:04,019 --> 00:01:08,880
that we concluded that we actually don't

00:01:07,170 --> 00:01:09,390
want to implement the verifier in java

00:01:08,880 --> 00:01:11,250
itself

00:01:09,390 --> 00:01:14,040
oh camel was much better programming

00:01:11,250 --> 00:01:17,820
language to implement the verifier and

00:01:14,040 --> 00:01:20,159
as a specification language we concluded

00:01:17,820 --> 00:01:23,400
that an expressive framework such as

00:01:20,159 --> 00:01:27,299
interactive fear improver for example

00:01:23,400 --> 00:01:29,490
isabel is an excellent way to have

00:01:27,299 --> 00:01:32,970
expressive specifications and a fallback

00:01:29,490 --> 00:01:35,579
to interactive proof so we had a very

00:01:32,970 --> 00:01:39,060
interesting hybrid system that was in

00:01:35,579 --> 00:01:40,409
some sense inconsistent in that we

00:01:39,060 --> 00:01:42,780
claimed that Java is an important

00:01:40,409 --> 00:01:45,570
platform but we really ride the verifier

00:01:42,780 --> 00:01:47,220
in no camel and the programs that we

00:01:45,570 --> 00:01:48,780
write are in a very different length

00:01:47,220 --> 00:01:53,310
specified using a very different

00:01:48,780 --> 00:01:56,909
formalism of isabel so when i graduated

00:01:53,310 --> 00:01:59,340
and came to EPFL in 2007 i was delighted

00:01:56,909 --> 00:02:01,590
to discover that scala is in fact not

00:01:59,340 --> 00:02:04,860
only very expressive but also very well

00:02:01,590 --> 00:02:08,069
performing and it became clear this is

00:02:04,860 --> 00:02:10,110
something that can be used to unify

00:02:08,069 --> 00:02:11,310
verification efforts and also it's a

00:02:10,110 --> 00:02:12,830
very pleasant language to write

00:02:11,310 --> 00:02:16,580
compilers and verify

00:02:12,830 --> 00:02:20,910
and so the first very fire that we

00:02:16,580 --> 00:02:23,550
developed is called Leon and Leon later

00:02:20,910 --> 00:02:26,430
became a much broader tool and I'll tell

00:02:23,550 --> 00:02:28,740
you more about it but I decided to focus

00:02:26,430 --> 00:02:30,630
more on verification here and the the

00:02:28,740 --> 00:02:33,300
newest version of our verification tool

00:02:30,630 --> 00:02:35,700
is called stainless you can see a

00:02:33,300 --> 00:02:39,320
minimalistic webpage for stainless at

00:02:35,700 --> 00:02:42,600
this URL and this is really a recent

00:02:39,320 --> 00:02:48,120
outcome of refactoring an outgrowth of a

00:02:42,600 --> 00:02:50,360
verification layer of Leon so as I

00:02:48,120 --> 00:02:53,520
mentioned this is the work of a lot of

00:02:50,360 --> 00:02:56,760
staff in the group particularly PhD

00:02:53,520 --> 00:02:59,130
students Nikolov what role is a current

00:02:56,760 --> 00:03:02,790
PhD student who has actually who is

00:02:59,130 --> 00:03:05,460
leading the stainless effort but he has

00:03:02,790 --> 00:03:09,990
built on his own and a development of

00:03:05,460 --> 00:03:11,790
many others in in the land system so you

00:03:09,990 --> 00:03:13,710
can read about the documentation of the

00:03:11,790 --> 00:03:15,960
level six in this URL and I'll try to

00:03:13,710 --> 00:03:20,340
give you some demos and flavor of how it

00:03:15,960 --> 00:03:22,200
works there are several aspects of the

00:03:20,340 --> 00:03:24,690
work that I will not be able to cover

00:03:22,200 --> 00:03:30,480
but I am happy to talk about it in more

00:03:24,690 --> 00:03:32,250
detail afterwards so stainless analyzes

00:03:30,480 --> 00:03:36,600
programs in a subset of Sakawa

00:03:32,250 --> 00:03:40,050
and it can do to do all things

00:03:36,600 --> 00:03:42,360
it can find errors in these programs in

00:03:40,050 --> 00:03:46,080
what way does it find errors well you're

00:03:42,360 --> 00:03:48,270
all familiar with types errors so the

00:03:46,080 --> 00:03:52,190
errors that stainless reports are in

00:03:48,270 --> 00:03:55,200
fact inputs for functions for which the

00:03:52,190 --> 00:03:58,410
function actually violates either some

00:03:55,200 --> 00:04:00,209
explicitly given specification or some

00:03:58,410 --> 00:04:04,470
implicit specifications such as array

00:04:00,209 --> 00:04:06,780
bounds check okay so if the verifier

00:04:04,470 --> 00:04:08,520
manages to find an error it is actually

00:04:06,780 --> 00:04:11,130
a true error that you can replay by

00:04:08,520 --> 00:04:13,020
feeding these inputs into into a program

00:04:11,130 --> 00:04:15,330
I'm going to be assuming deterministic

00:04:13,020 --> 00:04:18,420
programs here the non-determinism can be

00:04:15,330 --> 00:04:20,299
modeled using extra arguments but the

00:04:18,420 --> 00:04:25,379
you will see that we are focusing on

00:04:20,299 --> 00:04:27,580
functional programs now too

00:04:25,379 --> 00:04:30,460
what makes it all so interesting in

00:04:27,580 --> 00:04:32,979
contrast to tools such as scarlet check

00:04:30,460 --> 00:04:36,430
and some bounded model checkers that it

00:04:32,979 --> 00:04:38,740
can also prove correctness of functions

00:04:36,430 --> 00:04:41,680
and that means for me proving them

00:04:38,740 --> 00:04:43,389
correct for all possible inputs if some

00:04:41,680 --> 00:04:45,069
inputs are unbounded if you have values

00:04:43,389 --> 00:04:47,409
of algebraic data types or unbounded

00:04:45,069 --> 00:04:50,919
integer some are bounded but still very

00:04:47,409 --> 00:04:53,680
large okay and in case you're wondering

00:04:50,919 --> 00:04:56,849
about the name I think stainless fits

00:04:53,680 --> 00:05:00,490
very well with a tool that can verify

00:04:56,849 --> 00:05:03,669
correctness for all inputs and that that

00:05:00,490 --> 00:05:06,610
ensures that there are no no holes left

00:05:03,669 --> 00:05:10,000
in your your code I think it also fits

00:05:06,610 --> 00:05:12,430
better than let's say Scala + rust this

00:05:10,000 --> 00:05:14,979
is a picture of my my stairwell in the

00:05:12,430 --> 00:05:17,409
buildings where I live just to be from

00:05:14,979 --> 00:05:19,569
stainless steel so how do you use

00:05:17,409 --> 00:05:22,240
stainless well you can use it like a

00:05:19,569 --> 00:05:24,039
Scala C or dotty but it's going to run

00:05:22,240 --> 00:05:26,919
some more checks in fact it's going to

00:05:24,039 --> 00:05:28,659
invoke Scala C or dot e and then it's

00:05:26,919 --> 00:05:31,800
going to extract the trees map them to

00:05:28,659 --> 00:05:33,789
its own trees and then eventually start

00:05:31,800 --> 00:05:35,289
generating so called verification

00:05:33,789 --> 00:05:38,919
conditions which are mathematical

00:05:35,289 --> 00:05:41,169
formulas and by solving for values of

00:05:38,919 --> 00:05:43,300
variables in these formulas it's going

00:05:41,169 --> 00:05:46,289
to detect errors or conclude that there

00:05:43,300 --> 00:05:49,750
can be no errors and as I mentioned

00:05:46,289 --> 00:05:51,629
these the errors and correctness

00:05:49,750 --> 00:05:56,139
conditions that it generates fall into

00:05:51,629 --> 00:05:58,150
two classes one class which we get sort

00:05:56,139 --> 00:06:01,389
of for free if we have the second one

00:05:58,150 --> 00:06:03,339
are these runtime errors that you never

00:06:01,389 --> 00:06:04,900
want in your program you don't want your

00:06:03,339 --> 00:06:08,529
program to crash with array bounds or

00:06:04,900 --> 00:06:12,099
division by zero or incompleteness of

00:06:08,529 --> 00:06:14,050
pattern matching or for example if you

00:06:12,099 --> 00:06:16,569
have a map and you you don't have a

00:06:14,050 --> 00:06:18,370
defined value for for that for this map

00:06:16,569 --> 00:06:20,319
and of course you also don't want mouth

00:06:18,370 --> 00:06:22,719
but we turns out it because we have a

00:06:20,319 --> 00:06:25,060
subset we chose to rule out completely

00:06:22,719 --> 00:06:27,610
the ability to construct mouth now

00:06:25,060 --> 00:06:30,339
values okay so the more interesting case

00:06:27,610 --> 00:06:33,639
is number two here which are checks for

00:06:30,339 --> 00:06:35,919
user specified properties and the the

00:06:33,639 --> 00:06:37,680
most important construct for that is the

00:06:35,919 --> 00:06:41,910
ensuring construct

00:06:37,680 --> 00:06:44,620
and how many of you have used insuring

00:06:41,910 --> 00:06:47,560
get marked in his youth entering okay

00:06:44,620 --> 00:06:51,090
so I've decided to repeat some part of

00:06:47,560 --> 00:06:54,639
the documentation for for ensuring and

00:06:51,090 --> 00:06:56,949
another assertion like contact and so

00:06:54,639 --> 00:06:58,720
you can read the full documentation in

00:06:56,949 --> 00:07:00,400
the scallop read if so it already exists

00:06:58,720 --> 00:07:05,110
and it is existed for a very long time

00:07:00,400 --> 00:07:06,130
in Scala now it the default

00:07:05,110 --> 00:07:07,539
implementation the runtime

00:07:06,130 --> 00:07:10,180
implementation if you don't disable

00:07:07,539 --> 00:07:12,729
checks is it these are certain

00:07:10,180 --> 00:07:14,979
predicates certain boolean expressions

00:07:12,729 --> 00:07:17,770
that are going to be evaluated and run

00:07:14,979 --> 00:07:19,990
at runtime and usually a crash will

00:07:17,770 --> 00:07:25,120
happen or exception will be thrown if

00:07:19,990 --> 00:07:27,910
this condition is not hold okay so and

00:07:25,120 --> 00:07:31,389
but the real value of these kinds of

00:07:27,910 --> 00:07:34,090
constructs is that you can you can do

00:07:31,389 --> 00:07:36,460
tricks you can do static checks that

00:07:34,090 --> 00:07:38,830
extend the power or that you have with

00:07:36,460 --> 00:07:41,349
your type system and so the

00:07:38,830 --> 00:07:44,139
documentation here goes on and mentions

00:07:41,349 --> 00:07:47,470
that an example function that you may

00:07:44,139 --> 00:07:50,650
want to specify you using ensuring and

00:07:47,470 --> 00:07:53,680
it's do all require is ad natural so

00:07:50,650 --> 00:07:57,190
suppose you have a a list of int okay

00:07:53,680 --> 00:07:58,930
and then you you would like in fact to

00:07:57,190 --> 00:08:01,210
define a function that adds these

00:07:58,930 --> 00:08:03,490
elements but you in fact are only

00:08:01,210 --> 00:08:05,740
interested in adding lists of

00:08:03,490 --> 00:08:07,659
non-negative numbers so then you would

00:08:05,740 --> 00:08:09,669
write this require Clause which is a

00:08:07,659 --> 00:08:12,280
so-called precondition that says that

00:08:09,669 --> 00:08:15,219
the part that constraints the parameters

00:08:12,280 --> 00:08:17,289
gives more precise information about the

00:08:15,219 --> 00:08:19,030
input beyond the fact that it's a list

00:08:17,289 --> 00:08:23,349
of integers what does it say it says

00:08:19,030 --> 00:08:25,210
that all elements of this list satisfy

00:08:23,349 --> 00:08:28,090
the predicate crazier than equal to zero

00:08:25,210 --> 00:08:31,300
so they're all non-negative okay so this

00:08:28,090 --> 00:08:33,610
simple function then invokes a fold fold

00:08:31,300 --> 00:08:36,159
left with initial element zero and

00:08:33,610 --> 00:08:37,930
pluses the operation and then if you

00:08:36,159 --> 00:08:39,940
would like to ensure that means that

00:08:37,930 --> 00:08:41,399
guarantee at the end that the result is

00:08:39,940 --> 00:08:45,130
non-negative

00:08:41,399 --> 00:08:46,540
okay so this ensuring in fact what is

00:08:45,130 --> 00:08:48,130
going to do is take the result of the

00:08:46,540 --> 00:08:49,779
function then feed it to this predicate

00:08:48,130 --> 00:08:51,209
and check whether the predicate holds

00:08:49,779 --> 00:08:55,410
it's in a way a function

00:08:51,209 --> 00:08:56,759
a generalization of assertion because in

00:08:55,410 --> 00:08:59,429
functional world you always work with

00:08:56,759 --> 00:09:02,910
values so entering gets a value that it

00:08:59,429 --> 00:09:04,679
then binds to to this predicate and so

00:09:02,910 --> 00:09:10,470
this underscore is anonymous function

00:09:04,679 --> 00:09:12,809
it's not special a syntax okay so so we

00:09:10,470 --> 00:09:16,369
have this example from the documentation

00:09:12,809 --> 00:09:18,959
so let's try to run a stainless on it

00:09:16,369 --> 00:09:22,290
stainless is a tool I have it hopefully

00:09:18,959 --> 00:09:23,459
running here so I've just pasted it in

00:09:22,290 --> 00:09:25,199
case you're wondering about this funny

00:09:23,459 --> 00:09:28,730
symbol this is just fire code in which

00:09:25,199 --> 00:09:32,670
we use code a font that the ligatures

00:09:28,730 --> 00:09:34,740
and now I'm just going to invoke

00:09:32,670 --> 00:09:37,230
stainless it's just a shorthand to

00:09:34,740 --> 00:09:39,569
invoking stainless with calluses so I'll

00:09:37,230 --> 00:09:44,040
be using this callus e front-end in this

00:09:39,569 --> 00:09:46,470
talk okay I apologize if output is not

00:09:44,040 --> 00:09:49,499
perfectly legible it seems to some very

00:09:46,470 --> 00:09:53,220
large very wide screen but so it

00:09:49,499 --> 00:09:55,019
finished in half a second but it looks

00:09:53,220 --> 00:09:57,959
like on this example from the

00:09:55,019 --> 00:10:00,869
documentation it reported a counter

00:09:57,959 --> 00:10:04,470
example so it looks like there is a

00:10:00,869 --> 00:10:05,720
counter example for this for this

00:10:04,470 --> 00:10:08,970
specification

00:10:05,720 --> 00:10:17,759
can anyone see why this counter example

00:10:08,970 --> 00:10:21,089
is happening yes overflow okay so is

00:10:17,759 --> 00:10:24,059
that it is overflow of that behavior or

00:10:21,089 --> 00:10:28,619
is the fact that we are failing to

00:10:24,059 --> 00:10:31,470
satisfy post condition a bad behavior so

00:10:28,619 --> 00:10:35,129
in internal in in Java I would say that

00:10:31,470 --> 00:10:37,759
in Scala inherits the semantics plus is

00:10:35,129 --> 00:10:40,920
a modular operation and it can return

00:10:37,759 --> 00:10:42,569
possibly negative values when given to

00:10:40,920 --> 00:10:46,199
large positive values and this is what

00:10:42,569 --> 00:10:48,689
happens and it I finalized it the system

00:10:46,199 --> 00:10:50,579
not only found the two values but also

00:10:48,689 --> 00:10:54,360
managed to construct the list that

00:10:50,579 --> 00:10:56,160
contains these two values so that really

00:10:54,360 --> 00:10:58,259
if you feed this list back into it

00:10:56,160 --> 00:11:02,999
Naturals you will get a runtime

00:10:58,259 --> 00:11:04,889
assertion violation okay so so this is

00:11:02,999 --> 00:11:09,790
what happens

00:11:04,889 --> 00:11:11,110
now you let's see how we would fix this

00:11:09,790 --> 00:11:12,160
problem how do we would differently

00:11:11,110 --> 00:11:14,470
write the code I

00:11:12,160 --> 00:11:16,630
he wrote a simpler version of the of

00:11:14,470 --> 00:11:20,740
this function he did I'm adding just two

00:11:16,630 --> 00:11:22,930
naturals and so just to summarize this

00:11:20,740 --> 00:11:25,000
is the return value right require has

00:11:22,930 --> 00:11:27,579
specified the precondition we are

00:11:25,000 --> 00:11:29,800
returning the class and here I wrote

00:11:27,579 --> 00:11:31,480
just underscore it is in a shorthand for

00:11:29,800 --> 00:11:33,339
anonymous function but the ear is

00:11:31,480 --> 00:11:35,560
spelling it out so the result is again

00:11:33,339 --> 00:11:37,420
int and I would like to be a great T

00:11:35,560 --> 00:11:40,149
equal to zero so this X plus y becomes

00:11:37,420 --> 00:11:43,750
bound to res and I get X plus y greater

00:11:40,149 --> 00:11:45,430
than equal to zero okay so when we run a

00:11:43,750 --> 00:11:48,399
stainless then we get this counter

00:11:45,430 --> 00:11:50,050
example and this is just analogous

00:11:48,399 --> 00:11:52,449
accepted we didn't have to search for a

00:11:50,050 --> 00:11:53,949
list we already had two values and so in

00:11:52,449 --> 00:11:55,899
for these two particular counter

00:11:53,949 --> 00:11:57,760
examples depending on the program that

00:11:55,899 --> 00:12:00,579
you run a similar problems might have

00:11:57,760 --> 00:12:02,529
filed the different counter examples of

00:12:00,579 --> 00:12:07,449
course we are we are running into

00:12:02,529 --> 00:12:09,880
overflow okay so how would you how do I

00:12:07,449 --> 00:12:11,980
write a program that has the same spirit

00:12:09,880 --> 00:12:18,690
but but it satisfies the specifications

00:12:11,980 --> 00:12:20,980
what would you do begin so I like vegans

00:12:18,690 --> 00:12:22,690
because they map to mathematical

00:12:20,980 --> 00:12:24,699
integers they're not they seem to be

00:12:22,690 --> 00:12:28,149
about hundred times slower on the JVM on

00:12:24,699 --> 00:12:30,010
our micro benchmarks but there would be

00:12:28,149 --> 00:12:32,949
ways to implement them faster as well

00:12:30,010 --> 00:12:35,920
and this is this is fine for some

00:12:32,949 --> 00:12:37,510
applications and it it satisfies all

00:12:35,920 --> 00:12:39,100
sort of the expected mathematical

00:12:37,510 --> 00:12:41,079
properties of integers in fact there

00:12:39,100 --> 00:12:43,750
appear to be perfect model for integers

00:12:41,079 --> 00:12:47,440
and this this indeed verifies okay and

00:12:43,750 --> 00:12:50,470
if we an alternative way would be to

00:12:47,440 --> 00:12:52,860
realize that I mean it's unlikely we'll

00:12:50,470 --> 00:12:56,170
be working with arbitrary large

00:12:52,860 --> 00:12:57,760
numerical integral quantities and limit

00:12:56,170 --> 00:12:59,890
them in some way for example x and y

00:12:57,760 --> 00:13:01,480
could be less than 1 million and then

00:12:59,890 --> 00:13:06,370
when you are adding them then you don't

00:13:01,480 --> 00:13:09,279
get the don't get negative values okay

00:13:06,370 --> 00:13:11,920
so it's useful to have in obviously

00:13:09,279 --> 00:13:13,600
they're efficient they sometimes do

00:13:11,920 --> 00:13:16,060
exactly what you want if you want to do

00:13:13,600 --> 00:13:18,160
some modular arithmetic is useful to

00:13:16,060 --> 00:13:20,440
have begins because we can reason about

00:13:18,160 --> 00:13:23,230
in the way we we are used to and

00:13:20,440 --> 00:13:27,060
stainless maps them correctly to

00:13:23,230 --> 00:13:30,519
appropriate constraints and then checks

00:13:27,060 --> 00:13:33,100
now we do have an option to do warnings

00:13:30,519 --> 00:13:35,829
on int but this is not undisciplined

00:13:33,100 --> 00:13:37,029
behavior on JVM this is a valid behavior

00:13:35,829 --> 00:13:38,709
except that it may not have been

00:13:37,029 --> 00:13:41,379
programmers intention so this is sort of

00:13:38,709 --> 00:13:43,509
an optional warning that we have that is

00:13:41,379 --> 00:13:46,870
are talking to sounds okay so let me try

00:13:43,509 --> 00:13:53,819
to to open this other one or just or to

00:13:46,870 --> 00:13:53,819
run it so I have had two Naturals

00:13:54,509 --> 00:14:03,670
opening two naturals so I have these two

00:14:01,000 --> 00:14:10,600
and you can see here that all of these

00:14:03,670 --> 00:14:13,870
are in fact this was so we had that post

00:14:10,600 --> 00:14:17,800
condition of adwin atrocities invalid

00:14:13,870 --> 00:14:24,579
this is for arbitrary means sorry

00:14:17,800 --> 00:14:29,370
interesting had two naturals okay so

00:14:24,579 --> 00:14:33,670
this one is with arbitrary int and now I

00:14:29,370 --> 00:14:36,160
have had two natural three where I have

00:14:33,670 --> 00:14:41,050
this one which begins and I also have

00:14:36,160 --> 00:14:42,910
one with bounded int you see sort of the

00:14:41,050 --> 00:14:44,649
most of the running time is in the in

00:14:42,910 --> 00:14:46,329
the startup time what is measured here

00:14:44,649 --> 00:14:51,040
is a fraction of a second this is actual

00:14:46,329 --> 00:14:53,439
verification time and there's another

00:14:51,040 --> 00:14:55,839
increment ality so if you are adding two

00:14:53,439 --> 00:14:58,360
small naturals this is one with things

00:14:55,839 --> 00:15:00,459
less than million then you get valid if

00:14:58,360 --> 00:15:03,399
you are adding two big naturals with

00:15:00,459 --> 00:15:06,610
begins then also you get validity okay

00:15:03,399 --> 00:15:07,990
so so this is how it works it's a I'm

00:15:06,610 --> 00:15:10,300
showing you command-line tool because

00:15:07,990 --> 00:15:13,059
it's a bit more robust but I'll try to

00:15:10,300 --> 00:15:16,089
get to the to a demo okay so you might

00:15:13,059 --> 00:15:18,459
wonder whether this is these are tiny

00:15:16,089 --> 00:15:20,110
examples are other good use cases for

00:15:18,459 --> 00:15:23,470
that I would argue that the arm

00:15:20,110 --> 00:15:27,459
in fact many a well-known example is

00:15:23,470 --> 00:15:29,920
binary search so let's try to to give

00:15:27,459 --> 00:15:31,900
just one possible implementation of

00:15:29,920 --> 00:15:33,700
binary search in an array

00:15:31,900 --> 00:15:35,020
stainless NC see what happens so I'm

00:15:33,700 --> 00:15:36,880
going to avoid running every time

00:15:35,020 --> 00:15:40,150
stainless and just showing you the

00:15:36,880 --> 00:15:44,170
results on slide so if I don't specify

00:15:40,150 --> 00:15:48,220
any precondition what happens well I

00:15:44,170 --> 00:15:51,730
could get for example a counter example

00:15:48,220 --> 00:15:53,470
for which this I index here that I'm

00:15:51,730 --> 00:15:55,840
using to access array is in fact

00:15:53,470 --> 00:15:59,050
negative and it's never a good idea to

00:15:55,840 --> 00:16:01,300
access negative indices of an array and

00:15:59,050 --> 00:16:03,940
so so I'll get a counter example so

00:16:01,300 --> 00:16:06,400
obviously we need to give some require

00:16:03,940 --> 00:16:10,000
clause here to say that we we want these

00:16:06,400 --> 00:16:12,490
low and high to be in fact non-negative

00:16:10,000 --> 00:16:14,350
and when we are at that of course we

00:16:12,490 --> 00:16:18,430
don't want them to be too large we want

00:16:14,350 --> 00:16:22,210
to compare them to array length or how

00:16:18,430 --> 00:16:25,600
we could arise it arrived at an

00:16:22,210 --> 00:16:28,120
implementation such as this one so now I

00:16:25,600 --> 00:16:30,280
run this again by stainless and what do

00:16:28,120 --> 00:16:32,050
I get back well I get unfortunately

00:16:30,280 --> 00:16:34,030
another counter example so two people

00:16:32,050 --> 00:16:40,840
see what is the nature of this counter

00:16:34,030 --> 00:16:43,390
example so it tells me something the

00:16:40,840 --> 00:16:46,180
system tells me a little bit on what I

00:16:43,390 --> 00:16:48,400
should be concerned with so now that we

00:16:46,180 --> 00:16:50,050
have a precondition for search this

00:16:48,400 --> 00:16:52,390
precondition has to be checked whenever

00:16:50,050 --> 00:16:55,600
we invoke search including the recursive

00:16:52,390 --> 00:16:57,250
calls to search and here we get

00:16:55,600 --> 00:17:00,130
information that in fact precondition

00:16:57,250 --> 00:17:03,190
check fail fail for the second recursive

00:17:00,130 --> 00:17:05,440
call to search and indeed you can see

00:17:03,190 --> 00:17:07,690
here that high and low are equal which

00:17:05,440 --> 00:17:10,830
is something that we permit both in the

00:17:07,690 --> 00:17:14,200
if condition and in the precondition

00:17:10,830 --> 00:17:18,220
even though maybe we want to need here

00:17:14,200 --> 00:17:22,680
but because we do check but then if they

00:17:18,220 --> 00:17:29,130
are equal I is in fact computed to be

00:17:22,680 --> 00:17:32,020
sorry I computed to be equal to to this

00:17:29,130 --> 00:17:34,030
middle value and then you get a counter

00:17:32,020 --> 00:17:37,420
example so the the specification that

00:17:34,030 --> 00:17:40,150
you really want is this one module

00:17:37,420 --> 00:17:43,360
correct version here where you allow low

00:17:40,150 --> 00:17:45,910
to be equal to high plus one okay and

00:17:43,360 --> 00:17:49,780
then if I compute here

00:17:45,910 --> 00:17:52,120
i as lo+ hi / - then I would get again

00:17:49,780 --> 00:17:53,740
an overflow error and this is the the

00:17:52,120 --> 00:17:55,809
well-known overflow error so first you

00:17:53,740 --> 00:17:57,910
need to convince the system that search

00:17:55,809 --> 00:18:01,270
is going to be invoked in the right

00:17:57,910 --> 00:18:03,640
environment and the this includes here

00:18:01,270 --> 00:18:05,610
the fact that low and high are inbounds

00:18:03,640 --> 00:18:08,350
and they are related to each other

00:18:05,610 --> 00:18:11,799
including low being potentially equal to

00:18:08,350 --> 00:18:15,460
high plus 1 but not bigger and then you

00:18:11,799 --> 00:18:17,320
can look at the code and here the

00:18:15,460 --> 00:18:20,350
problem is of course that these are very

00:18:17,320 --> 00:18:24,010
large numbers and then when I compute

00:18:20,350 --> 00:18:26,230
the average in this way I get I get an

00:18:24,010 --> 00:18:26,830
error because I becomes again negative

00:18:26,230 --> 00:18:28,419
okay

00:18:26,830 --> 00:18:30,580
despite the values being positive and

00:18:28,419 --> 00:18:33,520
then we know that this is this is the

00:18:30,580 --> 00:18:35,470
right implementation here so now we have

00:18:33,520 --> 00:18:37,059
correct preconditions and we have the

00:18:35,470 --> 00:18:39,910
correct computation here that takes a

00:18:37,059 --> 00:18:42,580
low plus high minus low / - and if you

00:18:39,910 --> 00:18:48,669
run this everything passes so I can try

00:18:42,580 --> 00:18:52,750
again to binary search fixed ok so this

00:18:48,669 --> 00:18:55,360
is the version I'm sorry I just let me

00:18:52,750 --> 00:18:56,950
just leave it leave it - on the slide

00:18:55,360 --> 00:19:00,490
you see basically everything everything

00:18:56,950 --> 00:19:02,710
is valid if you are on the tool okay so

00:19:00,490 --> 00:19:05,919
that's an example of how it works for

00:19:02,710 --> 00:19:07,780
search all conditions pass here so let

00:19:05,919 --> 00:19:09,760
me now try to move to somewhat more

00:19:07,780 --> 00:19:12,600
interesting examples maybe namely

00:19:09,760 --> 00:19:15,220
examples that deal with data structures

00:19:12,600 --> 00:19:17,940
so the data structure that I'm going to

00:19:15,220 --> 00:19:21,250
look at comes from an excellent

00:19:17,940 --> 00:19:26,580
functional programming program design of

00:19:21,250 --> 00:19:30,160
course let's start by by marking and

00:19:26,580 --> 00:19:33,250
it's a the part that I'm going to look

00:19:30,160 --> 00:19:36,760
at is lecture 2.1 that illustrates

00:19:33,250 --> 00:19:40,600
structural induction on trees and really

00:19:36,760 --> 00:19:42,520
what this is all about is a correctness

00:19:40,600 --> 00:19:44,799
of a simple binary search tree data

00:19:42,520 --> 00:19:46,210
structure I've shown here just the

00:19:44,799 --> 00:19:47,980
statistics but this is for the first

00:19:46,210 --> 00:19:51,400
functional programming principles in

00:19:47,980 --> 00:19:54,220
scala course and the next programming

00:19:51,400 --> 00:19:56,409
course is in fact the one that I'm going

00:19:54,220 --> 00:19:58,870
to examine and that has come up more

00:19:56,409 --> 00:20:02,800
slightly more advanced material

00:19:58,870 --> 00:20:04,990
so this is the complete inset example

00:20:02,800 --> 00:20:06,610
from that lecture I may have just

00:20:04,990 --> 00:20:08,890
slightly rewritten it to use more

00:20:06,610 --> 00:20:15,240
pattern matching as opposed to methods

00:20:08,890 --> 00:20:19,120
for individual subclasses so at binary

00:20:15,240 --> 00:20:21,820
tree it can be empty or it can be a note

00:20:19,120 --> 00:20:23,530
it has left and right subtree and an

00:20:21,820 --> 00:20:26,380
element in the middle it's storing

00:20:23,530 --> 00:20:29,370
integers and for now we are going to

00:20:26,380 --> 00:20:32,320
examine two operations contains and

00:20:29,370 --> 00:20:34,810
include contain simply checks whether

00:20:32,320 --> 00:20:35,560
given element is inside the tree how

00:20:34,810 --> 00:20:37,540
does it do that

00:20:35,560 --> 00:20:40,840
well it follows a particular path

00:20:37,540 --> 00:20:42,460
comparing the element two to the one

00:20:40,840 --> 00:20:44,980
that's in the tree and either going left

00:20:42,460 --> 00:20:47,320
or right okay so this is less dot

00:20:44,980 --> 00:20:49,660
contains of X or right dot contains of X

00:20:47,320 --> 00:20:51,820
depending on how X compares to this

00:20:49,660 --> 00:20:53,980
element here that we have okay any

00:20:51,820 --> 00:20:55,330
include does something very similar but

00:20:53,980 --> 00:20:58,030
instead of returning boolean of course

00:20:55,330 --> 00:21:00,820
it turns and a new inset it performs a

00:20:58,030 --> 00:21:02,800
functional update of this tree so if

00:21:00,820 --> 00:21:05,020
it's an empty tree then it inserts the X

00:21:02,800 --> 00:21:07,180
otherwise it inserts it either in the

00:21:05,020 --> 00:21:10,330
left subtree or in the right subtree and

00:21:07,180 --> 00:21:12,970
preserve the other parts okay so there

00:21:10,330 --> 00:21:16,360
contains an include are quite analogous

00:21:12,970 --> 00:21:17,980
and what is it we would like to know

00:21:16,360 --> 00:21:19,660
about this maybe we made some type of

00:21:17,980 --> 00:21:23,590
maybe there should be somewhere less

00:21:19,660 --> 00:21:26,680
than equal or greater than equal so here

00:21:23,590 --> 00:21:29,770
the the axioms that marking describes so

00:21:26,680 --> 00:21:32,020
we would like to actually state certain

00:21:29,770 --> 00:21:35,410
algebraic properties that characterize

00:21:32,020 --> 00:21:38,290
this data structure and we have three of

00:21:35,410 --> 00:21:40,840
them one says that there's nothing

00:21:38,290 --> 00:21:43,390
inside an empty tree it contains nothing

00:21:40,840 --> 00:21:46,290
then if we add something into the tree

00:21:43,390 --> 00:21:48,280
then it's contained and if we add

00:21:46,290 --> 00:21:50,020
something to the tree and check for

00:21:48,280 --> 00:21:51,910
something else that is different from

00:21:50,020 --> 00:21:54,370
that that it's the same as checking in

00:21:51,910 --> 00:21:58,330
this old data structure as here okay so

00:21:54,370 --> 00:22:00,750
these are properties p1 p2 p3 and so how

00:21:58,330 --> 00:22:03,700
does one go about proving these

00:22:00,750 --> 00:22:05,140
properties well the key idea is

00:22:03,700 --> 00:22:07,360
induction on the structure of the trees

00:22:05,140 --> 00:22:08,980
but then also what you end up doing is

00:22:07,360 --> 00:22:10,360
equational reasoning this is why it's

00:22:08,980 --> 00:22:11,770
great to have a functional language so

00:22:10,360 --> 00:22:12,679
then don't have to worry about side

00:22:11,770 --> 00:22:14,600
effects on

00:22:12,679 --> 00:22:16,039
non-determinism and there is quite a bit

00:22:14,600 --> 00:22:18,610
of case analysis for example which

00:22:16,039 --> 00:22:20,749
element is less than which other one

00:22:18,610 --> 00:22:22,519
okay so let's try to state these

00:22:20,749 --> 00:22:24,159
properties and this is how I decided to

00:22:22,519 --> 00:22:27,230
state them for the purpose of

00:22:24,159 --> 00:22:28,940
verification in stainless you can see

00:22:27,230 --> 00:22:30,889
here the property is it was written

00:22:28,940 --> 00:22:32,240
there it was a scholar expression so I'm

00:22:30,889 --> 00:22:33,619
just going to put this scholar

00:22:32,240 --> 00:22:35,779
expression in the post condition of a

00:22:33,619 --> 00:22:37,429
function and what this function is going

00:22:35,779 --> 00:22:39,769
to take is simply three variables of

00:22:37,429 --> 00:22:41,659
that statement the idea being that we

00:22:39,769 --> 00:22:43,580
want to check functions in general for

00:22:41,659 --> 00:22:46,129
all values of arguments so we are going

00:22:43,580 --> 00:22:47,929
to put if we want to prove something for

00:22:46,129 --> 00:22:50,029
all values we put them as arguments of

00:22:47,929 --> 00:22:51,649
functions and the body of the function

00:22:50,029 --> 00:22:53,090
appear it doesn't have to be anything

00:22:51,649 --> 00:22:55,970
interesting so I'm going to find out put

00:22:53,090 --> 00:22:58,820
it to have a unit type and put a unit

00:22:55,970 --> 00:23:00,110
values inside and you can see this is

00:22:58,820 --> 00:23:02,330
entirely straightforward it's just

00:23:00,110 --> 00:23:04,669
restating maybe just to mention that we

00:23:02,330 --> 00:23:06,740
had a conditional algebraic

00:23:04,669 --> 00:23:08,659
specifications here specification here

00:23:06,740 --> 00:23:10,129
that said X needs to be distinct from Y

00:23:08,659 --> 00:23:12,220
and we just use precondition for that

00:23:10,129 --> 00:23:15,619
it's just convenient to do it like that

00:23:12,220 --> 00:23:18,830
so now we would like to give it to

00:23:15,619 --> 00:23:20,419
stainless well if we give it as such to

00:23:18,830 --> 00:23:23,299
stainless P one actually proves

00:23:20,419 --> 00:23:25,789
automatically turns out P 2 and P 3 in

00:23:23,299 --> 00:23:28,159
this form don't prove and sell you

00:23:25,789 --> 00:23:31,700
automatically so what we need to tell

00:23:28,159 --> 00:23:34,119
stainless is to use induction okay

00:23:31,700 --> 00:23:37,820
and so here's how we have a completely

00:23:34,119 --> 00:23:40,840
complete control over using induction in

00:23:37,820 --> 00:23:43,090
stainless so we basically take this

00:23:40,840 --> 00:23:45,019
parameter then we pattern match it

00:23:43,090 --> 00:23:46,369
according to the condition that we're

00:23:45,019 --> 00:23:48,110
interested in and then we call our

00:23:46,369 --> 00:23:50,210
property recursively on smaller

00:23:48,110 --> 00:23:53,840
structures so as long as this recursion

00:23:50,210 --> 00:23:56,440
here terminates we get a reasoning bind

00:23:53,840 --> 00:23:58,700
action because whenever we invoke this

00:23:56,440 --> 00:24:00,409
property recursively we get to assume

00:23:58,700 --> 00:24:04,879
the post condition on the smaller

00:24:00,409 --> 00:24:06,679
parameters okay and so I kept the post

00:24:04,879 --> 00:24:11,509
condition as it was before and as well

00:24:06,679 --> 00:24:13,970
as pre condition and so this is all that

00:24:11,509 --> 00:24:15,830
that we need to do if we give this to

00:24:13,970 --> 00:24:19,970
stainless it's actually going to prove

00:24:15,830 --> 00:24:21,799
all these three properties okay so the

00:24:19,970 --> 00:24:23,690
implementation is around 24 lines of

00:24:21,799 --> 00:24:26,480
code for for that that you have seen

00:24:23,690 --> 00:24:29,299
well it was on one slide then

00:24:26,480 --> 00:24:30,590
maybe it states 20 lines to to write

00:24:29,299 --> 00:24:33,140
down those properties with each

00:24:30,590 --> 00:24:35,419
induction which by the way in this p2 I

00:24:33,140 --> 00:24:37,760
emitted here it's entirely analogous in

00:24:35,419 --> 00:24:39,710
fact it's almost verbatim code except

00:24:37,760 --> 00:24:43,030
that I'm calling p2 here instead of p3

00:24:39,710 --> 00:24:49,130
so it really is no no thinking involved

00:24:43,030 --> 00:24:51,470
and for verification time it takes

00:24:49,130 --> 00:24:54,169
around one second to finish the

00:24:51,470 --> 00:24:57,380
verification itself ok so how long was

00:24:54,169 --> 00:24:59,240
the original lecture segment this is a

00:24:57,380 --> 00:25:01,640
subtle material so it was explained very

00:24:59,240 --> 00:25:05,240
carefully does around 15 minutes ok so I

00:25:01,640 --> 00:25:07,840
think it's sort of interesting to this

00:25:05,240 --> 00:25:10,370
sounds practical for such small examples

00:25:07,840 --> 00:25:12,350
now why did actually take 15 minutes

00:25:10,370 --> 00:25:14,299
well one of the reasons is that there

00:25:12,350 --> 00:25:15,530
was quite a bit of case analysis

00:25:14,299 --> 00:25:17,000
somewhere in the middle of the slides

00:25:15,530 --> 00:25:19,280
there were five cases to consider and

00:25:17,000 --> 00:25:23,710
each one of these or some of these cases

00:25:19,280 --> 00:25:26,510
or consisting of several steps okay so

00:25:23,710 --> 00:25:28,340
these were 15 minutes that require some

00:25:26,510 --> 00:25:31,130
concentration whereas here what we need

00:25:28,340 --> 00:25:35,059
to do is just write down the inductive

00:25:31,130 --> 00:25:38,450
schema basically and the property okay

00:25:35,059 --> 00:25:41,059
so the this lecture segment in fact ends

00:25:38,450 --> 00:25:44,000
with the suggestion for an exercise with

00:25:41,059 --> 00:25:47,630
a warning that it might be hard and the

00:25:44,000 --> 00:25:51,110
suggested exercise is to add Union to

00:25:47,630 --> 00:25:52,370
two trees and the specification of Union

00:25:51,110 --> 00:25:55,490
the property that we would like to

00:25:52,370 --> 00:25:57,740
satisfy that it behaves like set Union

00:25:55,490 --> 00:26:00,890
so checking whether X is contained in X

00:25:57,740 --> 00:26:03,890
s Union wise is the junction of it being

00:26:00,890 --> 00:26:06,290
containing the first XS or the second

00:26:03,890 --> 00:26:08,260
one YS okay a suggestion is to use a

00:26:06,290 --> 00:26:12,080
structural induction on XS

00:26:08,260 --> 00:26:13,340
okay so let's try to do that this is the

00:26:12,080 --> 00:26:17,540
definition of Union that was in fact

00:26:13,340 --> 00:26:19,250
given and it makes sense if you think

00:26:17,540 --> 00:26:21,679
about it it preserves the order of

00:26:19,250 --> 00:26:23,480
elements and then we can state this

00:26:21,679 --> 00:26:26,720
property P for now we can write all

00:26:23,480 --> 00:26:28,900
kinds of hints that we want here in fact

00:26:26,720 --> 00:26:31,460
doesn't matter because if we run

00:26:28,900 --> 00:26:35,230
stainless in fact we get a counter

00:26:31,460 --> 00:26:37,580
example ok so here's again we have a

00:26:35,230 --> 00:26:39,650
something that's supposed to be true and

00:26:37,580 --> 00:26:40,500
we get a counter example so is there

00:26:39,650 --> 00:26:43,710
something wrong

00:26:40,500 --> 00:26:46,470
is the union implementation wrong you

00:26:43,710 --> 00:26:46,919
have it written you or is the property

00:26:46,470 --> 00:26:55,679
wrong

00:26:46,919 --> 00:26:57,899
what would you say so admittedly these

00:26:55,679 --> 00:27:00,809
counter examples with huge numbers are

00:26:57,899 --> 00:27:03,269
not so easy to work with maybe I can try

00:27:00,809 --> 00:27:05,610
to to convince the system to give me a

00:27:03,269 --> 00:27:07,470
nice account for example so instead of

00:27:05,610 --> 00:27:10,679
just stating this property as it is I'm

00:27:07,470 --> 00:27:13,169
going to tell it to do something more

00:27:10,679 --> 00:27:15,450
I'm going to ask you to find values of

00:27:13,169 --> 00:27:17,070
these parameters and also find values

00:27:15,450 --> 00:27:19,470
for some things that are defined in

00:27:17,070 --> 00:27:22,350
terms of them so let's you'll be in fact

00:27:19,470 --> 00:27:25,380
the union of these two trees that we

00:27:22,350 --> 00:27:28,740
want to consider then let x1 and x2 be

00:27:25,380 --> 00:27:30,450
conditions whether the element X is

00:27:28,740 --> 00:27:32,850
contained inside each of these three and

00:27:30,450 --> 00:27:35,190
let's check then whether X is containing

00:27:32,850 --> 00:27:37,350
their union you okay you is just Union

00:27:35,190 --> 00:27:39,450
and just so that we don't get stupid a

00:27:37,350 --> 00:27:40,860
large constant we're going to ask X to

00:27:39,450 --> 00:27:42,929
be between 0 and 10 because it's

00:27:40,860 --> 00:27:45,809
unlikely that we really need some huge

00:27:42,929 --> 00:27:48,570
numbers and if I try that in fact I get

00:27:45,809 --> 00:27:49,919
a much nicer counter example moreover I

00:27:48,570 --> 00:27:52,080
get some more information so what has

00:27:49,919 --> 00:27:54,990
happened here can someone tell me now so

00:27:52,080 --> 00:27:58,620
t1 and t2 are trees we have computed t1

00:27:54,990 --> 00:28:00,179
Union t2 if you remember the definition

00:27:58,620 --> 00:28:02,360
of Union it was doing structural

00:28:00,179 --> 00:28:06,029
recursion on the first argument on T 1

00:28:02,360 --> 00:28:09,750
and so this computes somehow u which is

00:28:06,029 --> 00:28:13,350
in this case this set this tree here and

00:28:09,750 --> 00:28:17,190
then if we pick X 1 then we conclude

00:28:13,350 --> 00:28:19,409
that X 1 is somehow not that X is not

00:28:17,190 --> 00:28:21,539
contained in t1 that's what X 1 Falls

00:28:19,409 --> 00:28:26,880
means it's not contained in t2 but it

00:28:21,539 --> 00:28:29,360
somehow contained in in there Union so

00:28:26,880 --> 00:28:29,360
what happened

00:28:32,470 --> 00:28:37,220
the first three is not ordered that's

00:28:36,410 --> 00:28:39,050
interesting right

00:28:37,220 --> 00:28:41,180
we have never in fact talked about

00:28:39,050 --> 00:28:42,830
ordering so far we have seen less-than

00:28:41,180 --> 00:28:46,670
and greater-than but actually the proofs

00:28:42,830 --> 00:28:50,330
did not require ordering at all so in

00:28:46,670 --> 00:28:52,520
fact it's in fact maybe more remarkable

00:28:50,330 --> 00:28:54,770
that properties p1 p2 and p3 do hold

00:28:52,520 --> 00:28:56,630
even if we don't assume the ordering

00:28:54,770 --> 00:28:59,600
that seems to be the case it's because

00:28:56,630 --> 00:29:02,000
the search and the insertion are

00:28:59,600 --> 00:29:03,860
performed using exact same sequence of

00:29:02,000 --> 00:29:06,200
tests so they could be in fact much more

00:29:03,860 --> 00:29:08,000
general predicates than ordering but it

00:29:06,200 --> 00:29:09,980
it seems that as soon as we step into

00:29:08,000 --> 00:29:13,520
something slightly more general like

00:29:09,980 --> 00:29:15,740
Union like removal or balancing in order

00:29:13,520 --> 00:29:17,000
to obtain a balanced search trees we

00:29:15,740 --> 00:29:18,620
actually need something called

00:29:17,000 --> 00:29:20,210
representation invariant and this

00:29:18,620 --> 00:29:22,400
representation invariant in the case of

00:29:20,210 --> 00:29:25,940
search trees would mean that the tree is

00:29:22,400 --> 00:29:28,790
sorted so likely we do have a

00:29:25,940 --> 00:29:30,710
representation invariant in in variants

00:29:28,790 --> 00:29:33,680
in stainless and they're convenient to

00:29:30,710 --> 00:29:36,110
write they actually are written using

00:29:33,680 --> 00:29:38,360
the require on the constructor of that

00:29:36,110 --> 00:29:40,100
an algebraic data type and because we

00:29:38,360 --> 00:29:44,150
are going to assume that the fields are

00:29:40,100 --> 00:29:45,470
immutable in fact an for set then once

00:29:44,150 --> 00:29:47,300
you check the precondition of a

00:29:45,470 --> 00:29:49,580
constructor this is going to remain true

00:29:47,300 --> 00:29:53,270
for forever once you construct this

00:29:49,580 --> 00:29:55,730
value okay so that means that when we we

00:29:53,270 --> 00:29:59,660
pattern match on on a value then we can

00:29:55,730 --> 00:30:01,160
assume these conditions and moreover I'm

00:29:59,660 --> 00:30:02,420
going to also mention here that it's

00:30:01,160 --> 00:30:04,700
useful to introduce abstraction

00:30:02,420 --> 00:30:07,010
functions here because they allow us to

00:30:04,700 --> 00:30:09,200
more easily specify the representation

00:30:07,010 --> 00:30:11,680
invariant and in fact also allow us to

00:30:09,200 --> 00:30:15,110
describe the contracts in a way that is

00:30:11,680 --> 00:30:17,210
perhaps more conventional or possibly

00:30:15,110 --> 00:30:22,580
closer to object-oriented model-based

00:30:17,210 --> 00:30:26,200
approach to to describing systems and

00:30:22,580 --> 00:30:28,340
data types ok so here's a what we can do

00:30:26,200 --> 00:30:31,310
we are going to introduce this function

00:30:28,340 --> 00:30:32,960
content here content computer set you

00:30:31,310 --> 00:30:35,810
might be now saying that I'm treating

00:30:32,960 --> 00:30:37,310
you I'm verifying us I said but I pulled

00:30:35,810 --> 00:30:40,700
out the sleeve some kind of set data

00:30:37,310 --> 00:30:43,250
structure but it's true we have built in

00:30:40,700 --> 00:30:45,200
sets we also have built in maps but

00:30:43,250 --> 00:30:47,179
we don't have so many building things

00:30:45,200 --> 00:30:49,340
okay so sets and maps are something that

00:30:47,179 --> 00:30:50,690
has been widely acknowledged to be

00:30:49,340 --> 00:30:52,760
extremely useful in math in

00:30:50,690 --> 00:30:54,860
specification languages BDM and many

00:30:52,760 --> 00:30:56,690
others so it makes sense to support them

00:30:54,860 --> 00:30:59,120
and in fact many data structures

00:30:56,690 --> 00:31:00,350
extremely complicated data structures it

00:30:59,120 --> 00:31:03,650
can be taught is efficient

00:31:00,350 --> 00:31:05,870
implementations of sets and maps so we

00:31:03,650 --> 00:31:07,700
are now going to specify the content of

00:31:05,870 --> 00:31:09,559
our data structure as a set and this is

00:31:07,700 --> 00:31:11,360
very easy to compute we have operations

00:31:09,559 --> 00:31:13,520
of Union on set so we are going to

00:31:11,360 --> 00:31:16,400
recursively compute Union of left and

00:31:13,520 --> 00:31:19,000
right and add this middle element this

00:31:16,400 --> 00:31:23,539
is what the this recursive member

00:31:19,000 --> 00:31:25,250
contents does okay and now for example

00:31:23,539 --> 00:31:28,130
what we can do with this content is

00:31:25,250 --> 00:31:30,289
write nice post conditions on include

00:31:28,130 --> 00:31:31,820
and contains which previously we didn't

00:31:30,289 --> 00:31:34,970
have we decided to write everything

00:31:31,820 --> 00:31:37,309
using these algebraic specifications now

00:31:34,970 --> 00:31:38,870
we can write this because it's a handy

00:31:37,309 --> 00:31:42,049
to just add these ensuring clause and

00:31:38,870 --> 00:31:46,400
then we can say that the result dot

00:31:42,049 --> 00:31:48,770
content or one returned from include is

00:31:46,400 --> 00:31:50,450
in fact the current content extended

00:31:48,770 --> 00:31:52,730
standard with this given element and

00:31:50,450 --> 00:31:56,270
similarly similarly contains simply

00:31:52,730 --> 00:31:58,789
checks whether a given value X is

00:31:56,270 --> 00:32:01,159
contained in the content okay so this

00:31:58,789 --> 00:32:05,780
makes it obvious that contains really is

00:32:01,159 --> 00:32:08,809
something that represents the tests for

00:32:05,780 --> 00:32:10,940
membership in s underlying set okay so

00:32:08,809 --> 00:32:12,650
now let me go back to the to the

00:32:10,940 --> 00:32:15,909
invariant representation invariant that

00:32:12,650 --> 00:32:19,820
we decided we need we're going to say as

00:32:15,909 --> 00:32:24,580
is fitting a binary search tree that for

00:32:19,820 --> 00:32:28,070
every element X that is in the content

00:32:24,580 --> 00:32:29,960
that if we look at it in the left

00:32:28,070 --> 00:32:32,539
subtree for every element that is in the

00:32:29,960 --> 00:32:35,809
left subtree sorry it is less than the

00:32:32,539 --> 00:32:38,840
element so the element that we at the

00:32:35,809 --> 00:32:41,720
current node and every X in the right

00:32:38,840 --> 00:32:43,460
subtree is greater than the element in

00:32:41,720 --> 00:32:45,559
the current node okay so that's what it

00:32:43,460 --> 00:32:47,960
means to be a binary search tree okay so

00:32:45,559 --> 00:32:50,750
now when we when we write this

00:32:47,960 --> 00:32:53,110
invariance and specification then what

00:32:50,750 --> 00:32:53,110
happens

00:32:53,669 --> 00:32:59,849
okay so actually everything improves

00:32:57,450 --> 00:33:04,200
automatically and this time also the

00:32:59,849 --> 00:33:06,899
property p4 okay do people want who

00:33:04,200 --> 00:33:08,820
wants me to try to run stainless it's

00:33:06,899 --> 00:33:12,299
again going to generate some reports and

00:33:08,820 --> 00:33:13,559
after some relatively small amount of

00:33:12,299 --> 00:33:15,359
time it's going to say everything is

00:33:13,559 --> 00:33:18,599
okay in this case okay

00:33:15,359 --> 00:33:21,299
so simple binary search trees can be

00:33:18,599 --> 00:33:24,179
specified and verified quite naturally I

00:33:21,299 --> 00:33:25,889
would say but others have done more

00:33:24,179 --> 00:33:28,289
sophisticated data structures in

00:33:25,889 --> 00:33:30,629
particular marketing Alex Brock of it's

00:33:28,289 --> 00:33:33,149
up here was a PhD student of Madison

00:33:30,629 --> 00:33:36,059
Turkey and designed a data structure

00:33:33,149 --> 00:33:38,070
called conk trees and conk rope and

00:33:36,059 --> 00:33:40,109
these are efficient data structures that

00:33:38,070 --> 00:33:43,619
form the building blocks of parallel

00:33:40,109 --> 00:33:45,779
collections so concrete support log and

00:33:43,619 --> 00:33:48,829
lookup update splitting concat and then

00:33:45,779 --> 00:33:51,529
conquer up on top of that at amortized

00:33:48,829 --> 00:33:53,789
constant time prepend and append that

00:33:51,529 --> 00:33:57,329
means that you can do divide and conquer

00:33:53,789 --> 00:33:59,129
parallel algorithms using these data

00:33:57,329 --> 00:34:02,369
structures in a in fact purely

00:33:59,129 --> 00:34:04,619
functional way and so the properties of

00:34:02,369 --> 00:34:06,539
these including of course the complexity

00:34:04,619 --> 00:34:10,460
properties were proven manually in the

00:34:06,539 --> 00:34:13,500
in the paper and then PhD students of my

00:34:10,460 --> 00:34:15,720
ravi candidate Madeleine has in fact

00:34:13,500 --> 00:34:17,369
verify the correctness of these

00:34:15,720 --> 00:34:21,029
operations by showing that they

00:34:17,369 --> 00:34:24,569
implement a list with concatenation

00:34:21,029 --> 00:34:27,059
which is much less efficient operation

00:34:24,569 --> 00:34:29,069
but much more familiar easier to to

00:34:27,059 --> 00:34:30,539
reason about in terms of correctness so

00:34:29,069 --> 00:34:33,929
it showed correspondence between the

00:34:30,539 --> 00:34:37,619
countries and and the simple algebraic

00:34:33,929 --> 00:34:39,119
data type lists and the interest of

00:34:37,619 --> 00:34:41,309
Robbie's work is in fact reasoning about

00:34:39,119 --> 00:34:43,859
the running time bounds and so it turns

00:34:41,309 --> 00:34:46,200
out that once you have a system that can

00:34:43,859 --> 00:34:49,250
reason about functional correctness

00:34:46,200 --> 00:34:53,220
properties such as what the result

00:34:49,250 --> 00:34:55,079
returned is or whether some precondition

00:34:53,220 --> 00:34:57,149
or post condition holds then it's a

00:34:55,079 --> 00:34:59,190
matter of adding some instrumentation

00:34:57,149 --> 00:35:01,079
and you can automate that to reason also

00:34:59,190 --> 00:35:04,410
about execution time or memory

00:35:01,079 --> 00:35:06,089
consumption now if you do that you

00:35:04,410 --> 00:35:07,200
discover that your preconditions and

00:35:06,089 --> 00:35:09,000
postconditions become

00:35:07,200 --> 00:35:11,310
a bit less pleasant than what you would

00:35:09,000 --> 00:35:15,540
write like to write in all detail

00:35:11,310 --> 00:35:17,660
yourself and so main work here was in in

00:35:15,540 --> 00:35:20,820
actually automating some part of this

00:35:17,660 --> 00:35:22,020
precondition post condition inference so

00:35:20,820 --> 00:35:23,430
that you don't have to write all the

00:35:22,020 --> 00:35:27,030
constants that are involved in

00:35:23,430 --> 00:35:29,490
asymptotic complexity and so this work

00:35:27,030 --> 00:35:33,540
was done in the paper side the theories

00:35:29,490 --> 00:35:36,829
for verification of lazy and

00:35:33,540 --> 00:35:36,829
higher-order functions with memorization

00:35:36,890 --> 00:35:42,119
okay so there are some other examples

00:35:39,060 --> 00:35:44,010
that we have a verified we have focused

00:35:42,119 --> 00:35:46,050
on those that we think we can handle

00:35:44,010 --> 00:35:47,790
mostly automatically and by

00:35:46,050 --> 00:35:50,310
automatically I mean by writing this it

00:35:47,790 --> 00:35:52,440
is contract so these includes some

00:35:50,310 --> 00:35:54,359
dynamic programming algorithms a simple

00:35:52,440 --> 00:35:57,240
image compression and transformation

00:35:54,359 --> 00:35:59,670
algorithm and then we did some work with

00:35:57,240 --> 00:36:01,349
modeling more complex system systems

00:35:59,670 --> 00:36:05,220
with more complex semantics by extra

00:36:01,349 --> 00:36:07,589
adding extra arguments so these these

00:36:05,220 --> 00:36:10,050
are maybe programs that did their

00:36:07,589 --> 00:36:12,359
mathematical models of more complex

00:36:10,050 --> 00:36:14,160
underlying systems one of them is a

00:36:12,359 --> 00:36:16,339
distributed system another one is an

00:36:14,160 --> 00:36:18,810
ethereal smart contract but in case of

00:36:16,339 --> 00:36:23,210
smart contracts we could actually have a

00:36:18,810 --> 00:36:25,589
code generator in a quite direct way and

00:36:23,210 --> 00:36:27,480
so some of the classical examples such

00:36:25,589 --> 00:36:29,910
as compilation to postfix form or two

00:36:27,480 --> 00:36:32,730
simple stack machine and if you like

00:36:29,910 --> 00:36:35,339
monads I I mean one as are wonderful but

00:36:32,730 --> 00:36:36,780
it me ever since I learned Haskell it

00:36:35,339 --> 00:36:39,450
was always bothering me that we can't

00:36:36,780 --> 00:36:40,800
automatically check those laws and with

00:36:39,450 --> 00:36:43,050
the system like ours which support

00:36:40,800 --> 00:36:44,460
higher order functions and these data

00:36:43,050 --> 00:36:45,780
type invariants you can actually check

00:36:44,460 --> 00:36:51,150
monads laws and this seems to work

00:36:45,780 --> 00:36:52,710
reasonably well okay so let me try to

00:36:51,150 --> 00:36:55,079
tell you a little bit about how this

00:36:52,710 --> 00:36:59,280
works underneath we don't have much time

00:36:55,079 --> 00:37:02,160
but the idea is that you do reasoning by

00:36:59,280 --> 00:37:05,240
by induction and the induction that you

00:37:02,160 --> 00:37:08,069
are considering is execution that the

00:37:05,240 --> 00:37:12,240
the recursion schema gives you basically

00:37:08,069 --> 00:37:14,640
an induction scheme okay so here is your

00:37:12,240 --> 00:37:17,369
pattern match on the on a list whose

00:37:14,640 --> 00:37:20,339
size you're computing this gives you

00:37:17,369 --> 00:37:21,029
basically an induction that assumes post

00:37:20,339 --> 00:37:23,279
condition on

00:37:21,029 --> 00:37:25,140
the size of the list so this is

00:37:23,279 --> 00:37:27,689
reflected in certain verification

00:37:25,140 --> 00:37:29,459
conditions that you generate and and in

00:37:27,689 --> 00:37:31,229
that way you can eliminate the recursion

00:37:29,459 --> 00:37:34,169
so if you write strong enough contract

00:37:31,229 --> 00:37:36,449
then you get non-recursive properties in

00:37:34,169 --> 00:37:39,900
principle and how do you then solve

00:37:36,449 --> 00:37:44,130
these resulting contracts you use a very

00:37:39,900 --> 00:37:45,779
exciting set of tools that emerge in the

00:37:44,130 --> 00:37:50,179
field of satisfiability modular theories

00:37:45,779 --> 00:37:52,909
so these are tools that can reason about

00:37:50,179 --> 00:37:56,189
integer linear constraints about

00:37:52,909 --> 00:37:57,900
algebraic data types are about an

00:37:56,189 --> 00:38:01,769
interpreted function symbols or symbols

00:37:57,900 --> 00:38:03,719
that for which all you know is that if X

00:38:01,769 --> 00:38:07,469
is equal to Y then f of X is equal to f

00:38:03,719 --> 00:38:10,079
of Y and many other theories that have

00:38:07,469 --> 00:38:12,390
been shown to be decidable for which

00:38:10,079 --> 00:38:15,599
algorithms exist so we are using

00:38:12,390 --> 00:38:16,919
off-the-shelf solvers for for that but

00:38:15,599 --> 00:38:19,439
then we are also doing something

00:38:16,919 --> 00:38:22,019
ourselves it turns out that if you write

00:38:19,439 --> 00:38:25,380
contracts in the form that I have shown

00:38:22,019 --> 00:38:27,839
you for the for the inset with Union

00:38:25,380 --> 00:38:30,599
using these content functions then if

00:38:27,839 --> 00:38:32,579
you do eliminate the recursion of the

00:38:30,599 --> 00:38:34,039
operation on data structure itself in

00:38:32,579 --> 00:38:37,819
this case I'm just using a simpler

00:38:34,039 --> 00:38:40,859
example of insertion into a sorted list

00:38:37,819 --> 00:38:43,019
so I can generate verification condition

00:38:40,859 --> 00:38:44,819
here that's trying to prove that the

00:38:43,019 --> 00:38:47,609
content of the list increases by the

00:38:44,819 --> 00:38:49,650
element I'm inserting if I generate that

00:38:47,609 --> 00:38:51,719
unfortunately the functions that are

00:38:49,650 --> 00:38:53,999
used in post-conditions themselves they

00:38:51,719 --> 00:38:56,489
still appear I have gotten rid of insert

00:38:53,999 --> 00:38:58,259
but content is itself a recursive

00:38:56,489 --> 00:39:00,029
function okay so then the question is

00:38:58,259 --> 00:39:02,249
what do we do with those recursive

00:39:00,029 --> 00:39:04,650
functions and so our solution has been

00:39:02,249 --> 00:39:07,259
to implement a fair and systematic

00:39:04,650 --> 00:39:11,459
unrolling procedure that does search for

00:39:07,259 --> 00:39:15,449
counter examples and search for studies

00:39:11,459 --> 00:39:17,849
for unsatisfiability proof at the same

00:39:15,449 --> 00:39:20,309
time so basically the system is going to

00:39:17,849 --> 00:39:22,109
to a neural functions gradually and in

00:39:20,309 --> 00:39:24,599
each step is going to check do i have

00:39:22,109 --> 00:39:27,390
counter examples up to this step or can

00:39:24,599 --> 00:39:29,309
i use k induction by assuming these many

00:39:27,390 --> 00:39:31,619
unrolling post conditions for these many

00:39:29,309 --> 00:39:33,689
underlings to conclude that in fact the

00:39:31,619 --> 00:39:35,030
my property of interest is valid and

00:39:33,689 --> 00:39:37,730
this is what this algorithm try

00:39:35,030 --> 00:39:39,680
to do here basically phi is your formula

00:39:37,730 --> 00:39:42,410
that you are checking it expresses some

00:39:39,680 --> 00:39:44,180
verification condition and then when you

00:39:42,410 --> 00:39:46,940
control it with B you're checking for

00:39:44,180 --> 00:39:50,840
counter examples and when you don't

00:39:46,940 --> 00:39:53,810
conjoining you just check without this

00:39:50,840 --> 00:39:55,340
extra guard condition then you're

00:39:53,810 --> 00:39:58,820
assuming that your recursive functions

00:39:55,340 --> 00:40:00,320
can return anything okay and if you find

00:39:58,820 --> 00:40:02,690
no counter examples no matter what

00:40:00,320 --> 00:40:04,310
recursive functions return then you can

00:40:02,690 --> 00:40:06,710
conclude that your property holds and

00:40:04,310 --> 00:40:08,690
here again we are actually crucially

00:40:06,710 --> 00:40:11,180
relying on the fact that we have a

00:40:08,690 --> 00:40:14,900
functional language because in the

00:40:11,180 --> 00:40:17,000
absence of this assumption the functions

00:40:14,900 --> 00:40:19,960
could do arbitrarily bad things to your

00:40:17,000 --> 00:40:23,150
state and you would not get any useful

00:40:19,960 --> 00:40:24,830
conclusion from such recursive calls but

00:40:23,150 --> 00:40:27,080
here we just know that it's some value

00:40:24,830 --> 00:40:30,020
and if we know enough about what we do

00:40:27,080 --> 00:40:34,370
with this value we can also improve that

00:40:30,020 --> 00:40:37,220
the properties is valid okay so let me

00:40:34,370 --> 00:40:40,100
move towards wrapping up one exciting

00:40:37,220 --> 00:40:44,150
development that we have started doing

00:40:40,100 --> 00:40:47,320
and now Geragos is joining forces with

00:40:44,150 --> 00:40:50,780
martin's group is to do in fact a

00:40:47,320 --> 00:40:55,070
checking of a contract that are encoded

00:40:50,780 --> 00:40:57,080
inside predicate qualified types and if

00:40:55,070 --> 00:40:59,840
we manage to pull this off I think it's

00:40:57,080 --> 00:41:01,160
going to be really exciting and it's

00:40:59,840 --> 00:41:03,110
going to offer better integration with

00:41:01,160 --> 00:41:05,780
full Scala because right now stainless

00:41:03,110 --> 00:41:08,300
is a bit non-permissive in the sense

00:41:05,780 --> 00:41:12,470
that it doesn't like a certain construct

00:41:08,300 --> 00:41:14,150
and also more interestingly we will get

00:41:12,470 --> 00:41:16,670
benefits of the type checker which knows

00:41:14,150 --> 00:41:18,740
how to handle polymorphic types and that

00:41:16,670 --> 00:41:21,200
means also more more power in terms of

00:41:18,740 --> 00:41:25,640
propagating properties and throughout

00:41:21,200 --> 00:41:27,440
your your your code okay so there are

00:41:25,640 --> 00:41:32,630
other activities that I would be happy

00:41:27,440 --> 00:41:34,220
to tell you more about and this includes

00:41:32,630 --> 00:41:36,380
not only this verification fragment

00:41:34,220 --> 00:41:39,950
which which I talked about here but also

00:41:36,380 --> 00:41:41,570
what happens if you completely get rid

00:41:39,950 --> 00:41:43,520
of your code and try to just work with

00:41:41,570 --> 00:41:45,890
properties so in verification you have

00:41:43,520 --> 00:41:47,720
seen these post conditions what if post

00:41:45,890 --> 00:41:48,620
condition was your code what would you

00:41:47,720 --> 00:41:50,840
do then

00:41:48,620 --> 00:41:56,030
so in that case you could try to search

00:41:50,840 --> 00:41:57,350
for values such that the constraint is

00:41:56,030 --> 00:42:00,050
satisfied and say that this is the

00:41:57,350 --> 00:42:03,130
result of your function and this is what

00:42:00,050 --> 00:42:06,140
I would call constraint programming and

00:42:03,130 --> 00:42:08,720
finally you might want to do a compiled

00:42:06,140 --> 00:42:10,760
form of constraint programming which is

00:42:08,720 --> 00:42:12,770
called synthesis which means that you

00:42:10,760 --> 00:42:14,870
wanted a compile time to optimize this

00:42:12,770 --> 00:42:16,820
constraint solving process and generate

00:42:14,870 --> 00:42:20,930
one program that is guaranteed to

00:42:16,820 --> 00:42:25,460
satisfy the specification and I would

00:42:20,930 --> 00:42:33,080
maybe just try to to see if if there is

00:42:25,460 --> 00:42:36,860
any chance that I do that but so if you

00:42:33,080 --> 00:42:41,510
go to the layin PFL dot CH and then type

00:42:36,860 --> 00:42:43,940
demos then normally when there is

00:42:41,510 --> 00:42:47,000
internet connection you should be able

00:42:43,940 --> 00:42:49,340
to see examples and take a tour I think

00:42:47,000 --> 00:42:53,030
my internet connection is now and not

00:42:49,340 --> 00:42:56,870
not good enough to do that so I'm just

00:42:53,030 --> 00:42:58,700
going to summarize and and maybe mention

00:42:56,870 --> 00:43:01,370
one point that is between verification

00:42:58,700 --> 00:43:03,820
and synthesis that I think is very

00:43:01,370 --> 00:43:07,520
promising for the future and this is the

00:43:03,820 --> 00:43:09,410
idea of repair you have seen that the

00:43:07,520 --> 00:43:11,060
tools report counter-examples

00:43:09,410 --> 00:43:14,510
these are inputs that make your program

00:43:11,060 --> 00:43:16,640
let's say crash so if you know that your

00:43:14,510 --> 00:43:18,620
program has an error wouldn't be nice if

00:43:16,640 --> 00:43:20,360
the system actually suggested a possible

00:43:18,620 --> 00:43:22,400
repair there are two reasons for that

00:43:20,360 --> 00:43:24,440
first the system would do everything for

00:43:22,400 --> 00:43:27,170
us that's one reason the other thing is

00:43:24,440 --> 00:43:29,480
that it may be actually better a way to

00:43:27,170 --> 00:43:31,340
explain what the error is sometimes it

00:43:29,480 --> 00:43:32,870
is difficult to understand the error

00:43:31,340 --> 00:43:34,400
from the counter example but it's

00:43:32,870 --> 00:43:37,010
someone told you you made this mistake

00:43:34,400 --> 00:43:37,700
you should have done this something else

00:43:37,010 --> 00:43:40,250
instead

00:43:37,700 --> 00:43:42,080
that could be easier to us to understand

00:43:40,250 --> 00:43:47,900
whether it's something that the

00:43:42,080 --> 00:43:49,910
developer wants to accept or not ok so I

00:43:47,900 --> 00:43:52,550
will not be running the example of

00:43:49,910 --> 00:43:54,830
synthesis but to just get the flavor of

00:43:52,550 --> 00:43:57,530
the kinds of constraints that we can sit

00:43:54,830 --> 00:43:59,470
aside from if you give me an insertion

00:43:57,530 --> 00:44:01,880
into a sorted list and you say that

00:43:59,470 --> 00:44:02,390
sorting means producing a list that is

00:44:01,880 --> 00:44:04,190
sorted

00:44:02,390 --> 00:44:05,960
has the same content it's going to

00:44:04,190 --> 00:44:08,750
relatively quickly come up with that

00:44:05,960 --> 00:44:11,359
with a simple recursion that employs

00:44:08,750 --> 00:44:12,920
repeatedly insertion sort moreover if

00:44:11,359 --> 00:44:14,450
you want to synthesize this sorted

00:44:12,920 --> 00:44:16,250
insert which is insertion into our

00:44:14,450 --> 00:44:19,609
sorted list you could give it just this

00:44:16,250 --> 00:44:21,529
post condition here saying that given a

00:44:19,609 --> 00:44:23,180
sorted list I want back again a sorted

00:44:21,529 --> 00:44:25,010
list but with this bigger content and

00:44:23,180 --> 00:44:26,510
the system is going to generate all this

00:44:25,010 --> 00:44:30,500
pattern match and the recursion and the

00:44:26,510 --> 00:44:35,299
case plate okay so so this is sort of

00:44:30,500 --> 00:44:39,010
the power of the system and on that note

00:44:35,299 --> 00:44:41,809
I would like to to conclude and try to

00:44:39,010 --> 00:44:44,720
to send a message that automated

00:44:41,809 --> 00:44:46,640
verification can be in fact in some

00:44:44,720 --> 00:44:50,029
cases easier and it's certainly more

00:44:46,640 --> 00:44:52,099
reliable than hand proofs and in terms

00:44:50,029 --> 00:44:54,650
of reflection on on the approaches we

00:44:52,099 --> 00:44:55,970
have been taking I think the key idea is

00:44:54,650 --> 00:44:57,950
to use a functional intermediate

00:44:55,970 --> 00:45:00,049
language so the languages we are

00:44:57,950 --> 00:45:02,660
focusing on the examples that I gave you

00:45:00,049 --> 00:45:04,250
were all curly functional by functional

00:45:02,660 --> 00:45:06,589
I meant purely functional I apologize

00:45:04,250 --> 00:45:09,559
and so what why do I think this is a

00:45:06,589 --> 00:45:11,960
good choice first because this these

00:45:09,559 --> 00:45:15,109
kinds of constraints can be mapped to

00:45:11,960 --> 00:45:16,160
the underlying solvers in a much more

00:45:15,109 --> 00:45:19,039
straightforward way than some

00:45:16,160 --> 00:45:20,869
non-deterministic programs they have a

00:45:19,039 --> 00:45:23,750
good property of enabling search for

00:45:20,869 --> 00:45:25,579
both counter examples and proofs they

00:45:23,750 --> 00:45:28,160
are convenient for developers and they

00:45:25,579 --> 00:45:29,859
are very expressive by expressive I mean

00:45:28,160 --> 00:45:32,509
that you can write very complex

00:45:29,859 --> 00:45:35,359
specifications including specifications

00:45:32,509 --> 00:45:37,309
with functions inside this contract but

00:45:35,359 --> 00:45:39,230
also you can encode other properties you

00:45:37,309 --> 00:45:42,920
can encode non-functional properties

00:45:39,230 --> 00:45:45,950
such as number of steps in execution or

00:45:42,920 --> 00:45:48,829
memory or you can encode imperative or

00:45:45,950 --> 00:45:50,180
concurrent programs and then so

00:45:48,829 --> 00:45:53,750
synthesis and verification is something

00:45:50,180 --> 00:45:55,609
that I have only mentioned but I think

00:45:53,750 --> 00:45:58,069
it's certainly very exciting area

00:45:55,609 --> 00:46:01,670
I think verification is sort of ready to

00:45:58,069 --> 00:46:12,540
be to be used thank

00:46:01,670 --> 00:46:12,540
[Applause]

00:46:13,660 --> 00:46:19,490
with we have time for two questions

00:46:16,390 --> 00:46:26,660
those awesome guys will give you

00:46:19,490 --> 00:46:29,900
microphones if you have questions um is

00:46:26,660 --> 00:46:31,190
a possible c4 in the with the slides

00:46:29,900 --> 00:46:35,540
Martin showed yesterday with the new

00:46:31,190 --> 00:46:38,510
type parameters or the constructor for

00:46:35,540 --> 00:46:41,180
the traits rather grammar ties traits to

00:46:38,510 --> 00:46:44,660
use that instead of using a type of in

00:46:41,180 --> 00:46:47,540
your example int have a type that's a

00:46:44,660 --> 00:46:49,040
constraint a constrained int and then

00:46:47,540 --> 00:46:51,590
have the constraints as part of the

00:46:49,040 --> 00:46:53,900
types paths of the trait and then hide

00:46:51,590 --> 00:46:57,800
that ensuring code within that would

00:46:53,900 --> 00:47:00,410
that is that in thought about so I think

00:46:57,800 --> 00:47:03,170
there are many directions that we could

00:47:00,410 --> 00:47:06,740
take in that relates to better

00:47:03,170 --> 00:47:09,080
integration with traits and working

00:47:06,740 --> 00:47:11,960
better with abstraction so I think I

00:47:09,080 --> 00:47:15,680
cannot accurately answer your specific

00:47:11,960 --> 00:47:17,420
question but as I mentioned that the

00:47:15,680 --> 00:47:19,250
language that we accept is relatively

00:47:17,420 --> 00:47:21,950
small at the moment and that's something

00:47:19,250 --> 00:47:25,910
that we are hoping to overcome as we

00:47:21,950 --> 00:47:27,650
integrate this better with with the type

00:47:25,910 --> 00:47:32,030
system a Tegrity actually into the type

00:47:27,650 --> 00:47:34,700
system hi thanks for the talk is there

00:47:32,030 --> 00:47:37,010
any reason why you're not including some

00:47:34,700 --> 00:47:40,340
popular functional features in the input

00:47:37,010 --> 00:47:44,660
language for stainless say the variance

00:47:40,340 --> 00:47:48,560
of type parameters it was mostly for

00:47:44,660 --> 00:47:53,480
simplicity this is something that we did

00:47:48,560 --> 00:47:57,860
Nikolas is working on it is also related

00:47:53,480 --> 00:48:01,040
to mapping from functional programs to

00:47:57,860 --> 00:48:04,130
underlying constraints these underlying

00:48:01,040 --> 00:48:07,070
constraints for maximum efficiency it's

00:48:04,130 --> 00:48:09,290
best if we reuse the algebraic data type

00:48:07,070 --> 00:48:14,350
implementations and those algebraic data

00:48:09,290 --> 00:48:18,470
types have been a very simple sort of ml

00:48:14,350 --> 00:48:22,070
like parametric data types so that was

00:48:18,470 --> 00:48:25,460
the easier thing to do for now

00:48:22,070 --> 00:48:31,040
but but it is possible to encode more

00:48:25,460 --> 00:48:32,870
complex things and I was just wondering

00:48:31,040 --> 00:48:35,200
when this is correct so there is an

00:48:32,870 --> 00:48:39,980
underlying assumption of mutability

00:48:35,200 --> 00:48:41,060
right so the focus is on the

00:48:39,980 --> 00:48:43,670
verification of purely functional

00:48:41,060 --> 00:48:47,420
constraints but we do have some support

00:48:43,670 --> 00:48:51,860
for local immutable state and for a

00:48:47,420 --> 00:48:54,950
linear fields inside case classes so of

00:48:51,860 --> 00:48:59,090
our parameters of algebraic data types

00:48:54,950 --> 00:49:00,920
and so that comes with the restrictions

00:48:59,090 --> 00:49:03,740
that you cannot have sharing so right

00:49:00,920 --> 00:49:06,710
now we do not support directly in the

00:49:03,740 --> 00:49:09,590
language sharing of mutable structures

00:49:06,710 --> 00:49:12,080
you would need to model it for example

00:49:09,590 --> 00:49:13,060
using some maps that you pass around or

00:49:12,080 --> 00:49:16,910
something similar

00:49:13,060 --> 00:49:19,790
Thanks thank you for the great talk and

00:49:16,910 --> 00:49:21,860
I have one a question in relationship of

00:49:19,790 --> 00:49:23,630
what you do and what let's say SCADA

00:49:21,860 --> 00:49:27,500
check does so essentially randomized

00:49:23,630 --> 00:49:30,050
checking so in theory of course you can

00:49:27,500 --> 00:49:32,480
prove programs correct and the testing

00:49:30,050 --> 00:49:33,890
ever only can prove counter examples but

00:49:32,480 --> 00:49:35,630
in practice what are some of the

00:49:33,890 --> 00:49:38,770
applications where you think that the

00:49:35,630 --> 00:49:43,820
lay on a stainless approach is

00:49:38,770 --> 00:49:45,980
essentially more usable and it gives you

00:49:43,820 --> 00:49:48,020
clearly more than let's say randomized

00:49:45,980 --> 00:49:50,270
checking what ad sort of applications

00:49:48,020 --> 00:49:52,100
areas where you're showing it thank you

00:49:50,270 --> 00:49:54,920
for the question I think it's a very

00:49:52,100 --> 00:49:58,550
very important question I would say that

00:49:54,920 --> 00:50:01,070
when you have complex preconditions and

00:49:58,550 --> 00:50:02,510
this happens when you want to when you

00:50:01,070 --> 00:50:04,280
have more complex code in the new split

00:50:02,510 --> 00:50:05,960
it into different pieces you want to

00:50:04,280 --> 00:50:09,710
analyze them modularly then you have

00:50:05,960 --> 00:50:11,750
complex preconditions and testing code

00:50:09,710 --> 00:50:14,770
with complex preconditions becomes

00:50:11,750 --> 00:50:18,410
difficult if you if you do a priori

00:50:14,770 --> 00:50:21,530
sampling of the space because the

00:50:18,410 --> 00:50:23,420
fraction of the spaces or of the inputs

00:50:21,530 --> 00:50:26,570
that will satisfy the precondition goes

00:50:23,420 --> 00:50:28,040
down right and so that means that most

00:50:26,570 --> 00:50:29,720
of the tests will be sort of useless

00:50:28,040 --> 00:50:31,670
because they will not be satisfying the

00:50:29,720 --> 00:50:33,860
precondition that's why you need to to

00:50:31,670 --> 00:50:34,750
write sort of more clever checks and

00:50:33,860 --> 00:50:36,370
then you

00:50:34,750 --> 00:50:37,540
can do that and you can also if you know

00:50:36,370 --> 00:50:39,550
what you are doing right the programs

00:50:37,540 --> 00:50:42,600
correct but it's sort of extra effort

00:50:39,550 --> 00:50:45,550
and it seems it forces you to to write

00:50:42,600 --> 00:50:46,840
generators for properties separately

00:50:45,550 --> 00:50:49,060
from invariance because you need

00:50:46,840 --> 00:50:50,890
generators in order to feed the inputs

00:50:49,060 --> 00:50:52,240
but then you want to check them and so

00:50:50,890 --> 00:50:53,950
you have to duplicate the code and make

00:50:52,240 --> 00:50:55,300
sure that the properties you are

00:50:53,950 --> 00:50:59,020
checking are really the properties you

00:50:55,300 --> 00:51:01,960
are using I would say the target

00:50:59,020 --> 00:51:04,750
applications are are similar and you

00:51:01,960 --> 00:51:06,520
could look at combining these two these

00:51:04,750 --> 00:51:09,100
two approaches but if you look at what's

00:51:06,520 --> 00:51:13,780
happening inside the constraint solving

00:51:09,100 --> 00:51:16,270
isn't this happening is taking clue from

00:51:13,780 --> 00:51:17,950
the paths in the program itself so it's

00:51:16,270 --> 00:51:20,290
analyzing the program in order to decide

00:51:17,950 --> 00:51:22,810
what to take is an input so it's sort of

00:51:20,290 --> 00:51:25,120
doing it in the other way it's first

00:51:22,810 --> 00:51:26,320
looking where the error is or it

00:51:25,120 --> 00:51:27,940
simultaneously looking from the

00:51:26,320 --> 00:51:30,640
beginning to the end and then saying

00:51:27,940 --> 00:51:33,280
what what does that mean I do there

00:51:30,640 --> 00:51:36,390
exist some inputs for which this is this

00:51:33,280 --> 00:51:46,020
withhold thank you

00:51:36,390 --> 00:51:46,020

YouTube URL: https://www.youtube.com/watch?v=d4VeFa0z_Lo


