Title: The Futures are Calling and I Must Choose by Chris Phelps
Publication date: 2017-06-06
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Scala has a Future type in the standard library, but when we use other libraries we have competing abstractions: Scala Futures, Twitter Futures, Java CompletableFutures, Guava ListenableFutures. Other libraries like Scalaz, Monix, and FS2 bring us Task abstractions, which are similar to Futures but lazily executed. How do all these variants relate to one another? When should we use one over another? How do we interoperate when we have to deal with code that uses a different variant?

Starting from the basics of how to use each variant, we'll build up an understanding of how to select the best one for a codebase, how to make them work together, and some of the pitfalls. Along the way we'll even see some other tricks for making these useful abstractions when combined with other effects.
Captions: 
	00:00:00,030 --> 00:00:06,000
okay welcome everyone let's get started

00:00:03,380 --> 00:00:07,859
so my name is Chris Phelps I'm from

00:00:06,000 --> 00:00:11,370
Boulder Colorado work at a company

00:00:07,859 --> 00:00:12,870
called tendril we do what we call energy

00:00:11,370 --> 00:00:15,030
intelligence it's using what we know

00:00:12,870 --> 00:00:17,369
about building science and behavioral

00:00:15,030 --> 00:00:19,920
science and things we know about people

00:00:17,369 --> 00:00:21,779
and their usage and things like that to

00:00:19,920 --> 00:00:25,140
help understand how people use energy

00:00:21,779 --> 00:00:27,150
and optimize how they use energy so when

00:00:25,140 --> 00:00:29,670
we started to build this platform four

00:00:27,150 --> 00:00:32,009
or so years ago we wanted to achieve the

00:00:29,670 --> 00:00:33,870
kinds of LEDs that we talked about in

00:00:32,009 --> 00:00:37,500
the reactive manifesto we wanted a

00:00:33,870 --> 00:00:39,329
system that was responsive to customer

00:00:37,500 --> 00:00:41,670
requests we wanted one that was elastic

00:00:39,329 --> 00:00:44,219
that we could scale out and not run into

00:00:41,670 --> 00:00:45,690
problems with the number of instances

00:00:44,219 --> 00:00:47,520
that we had to run in a data center or

00:00:45,690 --> 00:00:50,520
things like that we wanted to be

00:00:47,520 --> 00:00:53,340
resilient to failure and so all those

00:00:50,520 --> 00:00:55,620
things led us to asynchronous all the

00:00:53,340 --> 00:00:57,780
way down and the futures kind of

00:00:55,620 --> 00:01:00,210
approach to do things and as part of

00:00:57,780 --> 00:01:03,750
that we ended up standardizing on

00:01:00,210 --> 00:01:06,150
finagle we wrote finagle protobuf as a

00:01:03,750 --> 00:01:08,820
plugin to finagle to work with protocol

00:01:06,150 --> 00:01:11,250
buffers as our wire format so that

00:01:08,820 --> 00:01:13,049
brought us into twitter futures we

00:01:11,250 --> 00:01:15,600
wanted our engineers to be able to write

00:01:13,049 --> 00:01:17,640
in scott in java as well as scala

00:01:15,600 --> 00:01:20,280
so that caused us to look at how can we

00:01:17,640 --> 00:01:22,619
make these things easily available from

00:01:20,280 --> 00:01:25,680
java and that led us to guava listenable

00:01:22,619 --> 00:01:28,829
futures and now subsequently with java 8

00:01:25,680 --> 00:01:30,630
we have completed so I have my engineers

00:01:28,829 --> 00:01:32,340
always wondering which of these should I

00:01:30,630 --> 00:01:35,420
use how far should I use them when

00:01:32,340 --> 00:01:39,090
should I change from one type to another

00:01:35,420 --> 00:01:40,770
so what is the future really um so this

00:01:39,090 --> 00:01:44,250
was an interesting interchange on

00:01:40,770 --> 00:01:47,310
Twitter a year or so ago futures are

00:01:44,250 --> 00:01:48,840
values they may have a computation

00:01:47,310 --> 00:01:50,070
associated with them that's producing

00:01:48,840 --> 00:01:51,570
that value but you should really think

00:01:50,070 --> 00:01:53,310
about it as a value and the value is

00:01:51,570 --> 00:01:57,290
just not there yet it's an interesting

00:01:53,310 --> 00:01:59,790
different way to think about this so a

00:01:57,290 --> 00:02:03,290
little bit of a history lesson back in

00:01:59,790 --> 00:02:05,369
the the bad old days Java we only had

00:02:03,290 --> 00:02:07,079
basically two things that we could do

00:02:05,369 --> 00:02:09,330
with futures we could ask if they were

00:02:07,079 --> 00:02:12,150
done and we could block until they were

00:02:09,330 --> 00:02:13,850
done so if we wanted to kind of keep

00:02:12,150 --> 00:02:15,740
checking you know we'd have to pull

00:02:13,850 --> 00:02:17,150
we'd have to do weird things that way

00:02:15,740 --> 00:02:20,720
there was very little that we could do

00:02:17,150 --> 00:02:23,900
to observe and react Twitter and Annika

00:02:20,720 --> 00:02:26,420
both experimented with putting callbacks

00:02:23,900 --> 00:02:28,970
on to futures so both Twitter future and

00:02:26,420 --> 00:02:31,310
aquas future at the time allowed you to

00:02:28,970 --> 00:02:33,590
set up a callback when a future

00:02:31,310 --> 00:02:36,320
succeeded when the value is available

00:02:33,590 --> 00:02:37,010
when the future failed the value was a

00:02:36,320 --> 00:02:38,960
failure

00:02:37,010 --> 00:02:45,110
your callbacks would be called and

00:02:38,960 --> 00:02:48,590
executed in 2012 that was Scala

00:02:45,110 --> 00:02:50,780
improvement process back to Scala and

00:02:48,590 --> 00:02:53,210
from 2:10 on we have a nice future

00:02:50,780 --> 00:02:56,390
abstraction in the Scala standard

00:02:53,210 --> 00:02:57,560
library so quick outline of what we're

00:02:56,390 --> 00:02:59,510
going to do in this talk we'll talk

00:02:57,560 --> 00:03:01,730
about Scala futures and kind of some of

00:02:59,510 --> 00:03:04,370
the basics of how they work then we'll

00:03:01,730 --> 00:03:05,770
compare the Twitter future and a little

00:03:04,370 --> 00:03:07,850
less detail will go into guava

00:03:05,770 --> 00:03:10,430
listenable futures will talk about

00:03:07,850 --> 00:03:12,710
Java's completable futures from that we

00:03:10,430 --> 00:03:15,350
have in Java eight forward I'll really

00:03:12,710 --> 00:03:19,220
briefly talk about tasks and then I'll

00:03:15,350 --> 00:03:21,530
give you my overall recommendations so

00:03:19,220 --> 00:03:25,370
let's jump right in so what makes a

00:03:21,530 --> 00:03:26,960
future in Scala standard library this is

00:03:25,370 --> 00:03:29,270
the type that has three states it can

00:03:26,960 --> 00:03:31,370
either be unresolved can be resolved

00:03:29,270 --> 00:03:33,290
with this success and when it is

00:03:31,370 --> 00:03:35,450
resolved successfully it has a value of

00:03:33,290 --> 00:03:38,450
whatever type which incidentally may be

00:03:35,450 --> 00:03:40,490
unit but or it could be resolved with

00:03:38,450 --> 00:03:42,410
available and with a failure in which

00:03:40,490 --> 00:03:44,290
case we have a throwable for what the

00:03:42,410 --> 00:03:47,510
exception what the problem was

00:03:44,290 --> 00:03:49,610
we have helpers to set up immediately

00:03:47,510 --> 00:03:51,260
resolved instances that's useful when

00:03:49,610 --> 00:03:54,890
we're building tests that's useful when

00:03:51,260 --> 00:03:57,530
we're building on we might have a branch

00:03:54,890 --> 00:03:59,150
and in one case we're doing some more

00:03:57,530 --> 00:04:02,180
computation another case we just

00:03:59,150 --> 00:04:05,570
immediately supply an answer which may

00:04:02,180 --> 00:04:07,070
be a failure or a success promises I'll

00:04:05,570 --> 00:04:11,510
get into promises a little bit more but

00:04:07,070 --> 00:04:14,390
promises an ability to provide a value

00:04:11,510 --> 00:04:17,359
that somebody else can look at as a

00:04:14,390 --> 00:04:19,040
future and there's a bunch of nice

00:04:17,359 --> 00:04:22,130
combinators that help us do things with

00:04:19,040 --> 00:04:25,040
that and we'll look at some of those so

00:04:22,130 --> 00:04:26,180
how can we get an instance of a future

00:04:25,040 --> 00:04:27,440
first so let's talk about from the

00:04:26,180 --> 00:04:29,720
client perspective

00:04:27,440 --> 00:04:31,220
right first of all I can call some

00:04:29,720 --> 00:04:33,620
library function somewhere that returns

00:04:31,220 --> 00:04:35,960
the future pretty obvious but pretty

00:04:33,620 --> 00:04:39,020
boring right what's more interesting is

00:04:35,960 --> 00:04:41,750
when on a provider how can I get one how

00:04:39,020 --> 00:04:43,490
can I make one so future has an apply

00:04:41,750 --> 00:04:45,590
method that we can use to create a new

00:04:43,490 --> 00:04:47,740
future or we can make a promise and

00:04:45,590 --> 00:04:51,640
we'll look at both of those

00:04:47,740 --> 00:04:53,600
so with apply we need our implicit

00:04:51,640 --> 00:04:56,770
execution context I'll talk more about

00:04:53,600 --> 00:04:59,060
that in a couple slides we have future

00:04:56,770 --> 00:05:03,950
pass at a block so this is calling

00:04:59,060 --> 00:05:07,430
future apply and then the body of this

00:05:03,950 --> 00:05:12,980
will be executed we'll get back a future

00:05:07,430 --> 00:05:14,960
we can then do stuff with it alternately

00:05:12,980 --> 00:05:17,930
we can create a future as a promise so

00:05:14,960 --> 00:05:21,650
in this case we're going to create

00:05:17,930 --> 00:05:24,440
promise with its apply method return the

00:05:21,650 --> 00:05:26,330
future end from that on so this new my

00:05:24,440 --> 00:05:28,000
new future I can then pass around to a

00:05:26,330 --> 00:05:31,190
client that's going to consume this

00:05:28,000 --> 00:05:33,170
start my calculation somewhere and then

00:05:31,190 --> 00:05:35,000
when it's done I call success on the

00:05:33,170 --> 00:05:37,970
promise or failure on the promise to

00:05:35,000 --> 00:05:40,000
resolve it the way this works we have a

00:05:37,970 --> 00:05:42,440
pursue a producer and a consumer

00:05:40,000 --> 00:05:44,090
producer makes this promise and he gives

00:05:42,440 --> 00:05:46,580
the future into that back to this

00:05:44,090 --> 00:05:49,870
consumer the consumer can then register

00:05:46,580 --> 00:05:52,370
his callbacks at some point when the

00:05:49,870 --> 00:05:54,830
calculations done producer completes the

00:05:52,370 --> 00:06:00,340
promise and at that point callbacks are

00:05:54,830 --> 00:06:03,680
executed for the consumer so callbacks

00:06:00,340 --> 00:06:07,490
look something like this we set up our

00:06:03,680 --> 00:06:09,380
future with our calculate here we then

00:06:07,490 --> 00:06:11,690
have an on complete which takes a

00:06:09,380 --> 00:06:13,730
partial function we can match on the

00:06:11,690 --> 00:06:16,250
success case to do whatever our happy

00:06:13,730 --> 00:06:19,490
path is match on the failure case to do

00:06:16,250 --> 00:06:21,290
whatever our failure handling is we also

00:06:19,490 --> 00:06:23,120
have these individual on success and on

00:06:21,290 --> 00:06:25,750
failure those are technically deprecated

00:06:23,120 --> 00:06:30,230
in 212 but they're still available

00:06:25,750 --> 00:06:32,900
to set those up independently so

00:06:30,230 --> 00:06:34,760
combinators once we have a future we

00:06:32,900 --> 00:06:37,280
want to start composing it and doing

00:06:34,760 --> 00:06:40,039
more stuff with it so the two basics

00:06:37,280 --> 00:06:41,390
that we have are map and flatmap math

00:06:40,039 --> 00:06:43,790
lets us take an

00:06:41,390 --> 00:06:46,840
do an operation once the value is

00:06:43,790 --> 00:06:49,820
present and immediately return a value

00:06:46,840 --> 00:06:51,970
by immediately that may take some time

00:06:49,820 --> 00:06:54,620
but we're not doing something that is

00:06:51,970 --> 00:06:58,760
intrinsically Future II creating a new

00:06:54,620 --> 00:07:01,070
future a new asynchronous boundary if

00:06:58,760 --> 00:07:02,540
you will flat map on the other hand is

00:07:01,070 --> 00:07:04,220
one where we are going to introduce that

00:07:02,540 --> 00:07:05,600
extra layer of asynchronous we're going

00:07:04,220 --> 00:07:08,330
to make some other call and get another

00:07:05,600 --> 00:07:10,280
future back and we want to chain those

00:07:08,330 --> 00:07:14,480
futures together rather than having any

00:07:10,280 --> 00:07:20,030
sort of nesting of futures that's what

00:07:14,480 --> 00:07:22,640
map and flatmap would be for we get our

00:07:20,030 --> 00:07:25,190
future somewhere by calling some

00:07:22,640 --> 00:07:27,200
calculate in this case I have a scale

00:07:25,190 --> 00:07:28,790
method that takes an int and returns an

00:07:27,200 --> 00:07:33,650
int and I'm going to map it on to that

00:07:28,790 --> 00:07:37,370
future so when my future resolves this

00:07:33,650 --> 00:07:40,520
map body will fire I'll do the scale

00:07:37,370 --> 00:07:42,590
calculation this returns in other future

00:07:40,520 --> 00:07:44,090
so I have scaled now and I can do the

00:07:42,590 --> 00:07:47,210
same thing I can map on I can plat map

00:07:44,090 --> 00:07:49,430
on I can do other Combinator's so

00:07:47,210 --> 00:07:52,610
recalculate is another example here

00:07:49,430 --> 00:07:53,990
where now the recalculate method does

00:07:52,610 --> 00:07:55,730
some kind of futuristic maybe that's

00:07:53,990 --> 00:07:58,130
going off to a to a third-party service

00:07:55,730 --> 00:08:01,340
or something like that so I'm going to

00:07:58,130 --> 00:08:03,380
take um and I guess I should have said

00:08:01,340 --> 00:08:06,890
scaled dot flat map instead of mapped

00:08:03,380 --> 00:08:09,020
flat map but once I have the value from

00:08:06,890 --> 00:08:11,600
scaled then I can go off and do the

00:08:09,020 --> 00:08:13,400
recalculate get a future back from that

00:08:11,600 --> 00:08:17,840
those future contexts are combined

00:08:13,400 --> 00:08:19,910
together now map and flatmap are give us

00:08:17,840 --> 00:08:22,250
a nice piece of syntax sugar in Scala

00:08:19,910 --> 00:08:23,780
which is for comprehension so by having

00:08:22,250 --> 00:08:26,450
map and flatmap and a couple other

00:08:23,780 --> 00:08:29,900
things on we can do a for comprehension

00:08:26,450 --> 00:08:32,240
here we can say for a from calculate B

00:08:29,900 --> 00:08:36,260
from recalculate with the value from a

00:08:32,240 --> 00:08:37,850
yield scale of B and this all gets

00:08:36,260 --> 00:08:40,250
chained together produces a future

00:08:37,850 --> 00:08:41,870
change is going to be a future event we

00:08:40,250 --> 00:08:46,430
can set up callbacks on that or do other

00:08:41,870 --> 00:08:47,930
things from that as we want few other

00:08:46,430 --> 00:08:50,870
interesting Combinator's I wanted to

00:08:47,930 --> 00:08:52,610
point out fold left is for when we have

00:08:50,870 --> 00:08:54,460
an iterable of a bunch of them and we

00:08:52,610 --> 00:08:58,270
want to combine them all up to

00:08:54,460 --> 00:09:02,800
Pete one single value first completed of

00:08:58,270 --> 00:09:04,390
if we have multiple futures and we want

00:09:02,800 --> 00:09:06,970
to let them race each other maybe we're

00:09:04,390 --> 00:09:08,380
calling three different instances of my

00:09:06,970 --> 00:09:10,990
third-party service and I want to take

00:09:08,380 --> 00:09:13,120
whichever one finishes first maybe I

00:09:10,990 --> 00:09:16,360
want to play a game where I have a cache

00:09:13,120 --> 00:09:18,370
and an actual computation and whichever

00:09:16,360 --> 00:09:20,529
one comes back first is the one I want

00:09:18,370 --> 00:09:24,540
if we've got it cash that'll be fast if

00:09:20,529 --> 00:09:28,480
not that has to still prop um and

00:09:24,540 --> 00:09:32,080
sequence lets us go from a list of

00:09:28,480 --> 00:09:34,750
futures to a single future of list right

00:09:32,080 --> 00:09:36,970
so I have I go up and I make three

00:09:34,750 --> 00:09:38,320
different calls and I want to take those

00:09:36,970 --> 00:09:40,209
all together combine them up when

00:09:38,320 --> 00:09:41,529
they're all available I want to have all

00:09:40,209 --> 00:09:44,080
those values as a list that I can

00:09:41,529 --> 00:09:47,920
operate on now this takes traversable

00:09:44,080 --> 00:09:49,300
one I've put the dot dot dot in here one

00:09:47,920 --> 00:09:51,730
of the things that we're passing in here

00:09:49,300 --> 00:09:53,140
and the dot dot dot is can build from so

00:09:51,730 --> 00:09:55,270
this actually works for any of the

00:09:53,140 --> 00:09:56,740
collections kind of types and we'll get

00:09:55,270 --> 00:09:59,890
that in terms of the right collections

00:09:56,740 --> 00:10:02,200
type the other thing that happens in all

00:09:59,890 --> 00:10:08,260
these dot dot dots are the execution

00:10:02,200 --> 00:10:09,850
context so all these bodies all the work

00:10:08,260 --> 00:10:11,890
that's going on in these transforms get

00:10:09,850 --> 00:10:14,529
submitted to an execution context to run

00:10:11,890 --> 00:10:16,240
and it's up to that execution context to

00:10:14,529 --> 00:10:19,600
decide whether that creates a new thread

00:10:16,240 --> 00:10:21,670
or how it exactly it runs it in my

00:10:19,600 --> 00:10:24,670
examples you noticed I took the implicit

00:10:21,670 --> 00:10:27,130
global execution context that global

00:10:24,670 --> 00:10:29,740
execution context uses the fork/join

00:10:27,130 --> 00:10:32,080
pool is that by default configured based

00:10:29,740 --> 00:10:34,630
on the number of cores you have you can

00:10:32,080 --> 00:10:37,390
change that configuration but you can

00:10:34,630 --> 00:10:39,880
also provide any executor you want in

00:10:37,390 --> 00:10:41,890
order to instruct a on an execution

00:10:39,880 --> 00:10:43,450
contact that you're going to use so why

00:10:41,890 --> 00:10:45,730
might you do that why might you provide

00:10:43,450 --> 00:10:47,140
something other than the global one is

00:10:45,730 --> 00:10:48,640
that you want to control your pool you

00:10:47,140 --> 00:10:49,630
want to know how many threads are in it

00:10:48,640 --> 00:10:52,839
you want to configure it for different

00:10:49,630 --> 00:10:54,640
purposes you might want to segregate

00:10:52,839 --> 00:10:56,350
certain kinds of work into a different

00:10:54,640 --> 00:10:57,880
pool you've got one that's tuned for

00:10:56,350 --> 00:11:01,120
certain kinds of operations and other

00:10:57,880 --> 00:11:03,459
tuned for other kinds of operations and

00:11:01,120 --> 00:11:05,730
if you want to use this fork join pool

00:11:03,459 --> 00:11:07,360
you're going to do a lot of long-running

00:11:05,730 --> 00:11:09,519
operations that are going to

00:11:07,360 --> 00:11:11,529
block which we probably shouldn't do

00:11:09,519 --> 00:11:13,990
anyway we want to try to do this async

00:11:11,529 --> 00:11:15,310
non blocking level all the time but if

00:11:13,990 --> 00:11:16,810
we're going to block those threads and

00:11:15,310 --> 00:11:19,209
I've got to be long-running fork/join

00:11:16,810 --> 00:11:23,170
pool probably isn't the best for us the

00:11:19,209 --> 00:11:24,640
way that that guy works it you can get

00:11:23,170 --> 00:11:27,660
thread starvation and stuff like that if

00:11:24,640 --> 00:11:30,279
you don't have that configured correctly

00:11:27,660 --> 00:11:31,320
so now let's compare how Twitter future

00:11:30,279 --> 00:11:34,600
is different

00:11:31,320 --> 00:11:36,550
Twitter's future has some different

00:11:34,600 --> 00:11:40,050
Combinator's has a different execution

00:11:36,550 --> 00:11:43,300
model and it supports calculations so

00:11:40,050 --> 00:11:45,760
Twitter did some of this work right they

00:11:43,300 --> 00:11:48,070
were part of the proposal to get things

00:11:45,760 --> 00:11:49,870
back into Scala standard library but

00:11:48,070 --> 00:11:51,760
they haven't standardized on the stuff

00:11:49,870 --> 00:11:54,130
in the Scala standard library why is

00:11:51,760 --> 00:11:55,420
that cancellation is one of the big

00:11:54,130 --> 00:11:57,339
things that they don't want to give up

00:11:55,420 --> 00:11:59,050
that they want to continue using their

00:11:57,339 --> 00:12:01,990
future for and we'll talk about that a

00:11:59,050 --> 00:12:03,850
little more so a bunch of the standard

00:12:01,990 --> 00:12:06,640
Combinator's are still there and they

00:12:03,850 --> 00:12:09,670
look pretty much the same filters

00:12:06,640 --> 00:12:11,980
flattens maps fat flat maps with filters

00:12:09,670 --> 00:12:13,660
all that kind of stuff so we can still

00:12:11,980 --> 00:12:16,149
do for comprehension Zahl that kind of

00:12:13,660 --> 00:12:18,670
thing there's a little tiny difference

00:12:16,149 --> 00:12:22,180
in here that I'll talk about later but

00:12:18,670 --> 00:12:23,790
basically these um these signatures all

00:12:22,180 --> 00:12:26,649
look the same

00:12:23,790 --> 00:12:29,860
there's new combinators that Twitter ads

00:12:26,649 --> 00:12:32,320
so buying within are about timing

00:12:29,860 --> 00:12:36,190
so we'll get a new future that completes

00:12:32,320 --> 00:12:38,320
at a time or at a time out parallel is

00:12:36,190 --> 00:12:41,100
to let us do a bunch of things in

00:12:38,320 --> 00:12:45,160
parallel and get back a list of futures

00:12:41,100 --> 00:12:48,850
select lets us grab the first one of a

00:12:45,160 --> 00:12:50,140
bunch of futures that finishes the

00:12:48,850 --> 00:12:51,790
signature is kind of weird there it's

00:12:50,140 --> 00:12:55,199
giving us the first one that finishes

00:12:51,790 --> 00:12:58,600
and all the rest in another sequence

00:12:55,199 --> 00:13:00,579
when let's us say on if this condition

00:12:58,600 --> 00:13:02,800
is true execute the thing and while do

00:13:00,579 --> 00:13:05,019
says while this condition is true keep

00:13:02,800 --> 00:13:07,120
keep doing these things and you notice

00:13:05,019 --> 00:13:10,300
that when and weíll do our both

00:13:07,120 --> 00:13:12,220
returning future of unit so we just get

00:13:10,300 --> 00:13:13,600
a callback that fires that just tells us

00:13:12,220 --> 00:13:14,829
that these other things are complete it

00:13:13,600 --> 00:13:17,760
doesn't gives us a value for those

00:13:14,829 --> 00:13:20,300
things so the theme for a lot of these

00:13:17,760 --> 00:13:22,430
additional ones that Twitter provides

00:13:20,300 --> 00:13:25,430
are about observing or choreographing

00:13:22,430 --> 00:13:28,580
other futures to give you some

00:13:25,430 --> 00:13:30,650
indication a call a standard future

00:13:28,580 --> 00:13:33,550
including the companion object at

00:13:30,650 --> 00:13:36,110
somewhere around thirty-one functions

00:13:33,550 --> 00:13:37,820
Twitter and its companion Twitter future

00:13:36,110 --> 00:13:41,390
and its companion object have around 80

00:13:37,820 --> 00:13:44,180
so a bunch more variants and things like

00:13:41,390 --> 00:13:46,400
this some of the Combinator's that

00:13:44,180 --> 00:13:47,540
Twitter provides are the same as ones in

00:13:46,400 --> 00:13:49,670
the scallop standard library but they

00:13:47,540 --> 00:13:51,500
have different names so instead of is

00:13:49,670 --> 00:13:53,660
completed we have is done instead of

00:13:51,500 --> 00:13:56,990
value we have poll instead of recover we

00:13:53,660 --> 00:14:00,380
have handle recover with rescue zip join

00:13:56,990 --> 00:14:02,660
and zip with join with if you look at

00:14:00,380 --> 00:14:05,330
these the signatures between these two

00:14:02,660 --> 00:14:08,210
are pretty much exactly the same names

00:14:05,330 --> 00:14:10,640
obviously different but there's one

00:14:08,210 --> 00:14:14,030
thing one detail that I left out on the

00:14:10,640 --> 00:14:16,820
top which is execution context some of

00:14:14,030 --> 00:14:18,440
these the scala versions provide an

00:14:16,820 --> 00:14:21,800
execution context of twitter ones don't

00:14:18,440 --> 00:14:24,290
so what's up with that twitter execution

00:14:21,800 --> 00:14:25,610
models different from scholars so the

00:14:24,290 --> 00:14:29,510
transformed bodies are going to be

00:14:25,610 --> 00:14:34,540
executed in the thread that resolves the

00:14:29,510 --> 00:14:37,940
prior future so if we set up a pipeline

00:14:34,540 --> 00:14:39,440
and have a bunch of maps and flat maps

00:14:37,940 --> 00:14:43,160
and so on combining these things

00:14:39,440 --> 00:14:45,710
together once one thread resolves a

00:14:43,160 --> 00:14:49,040
future that same thread will execute the

00:14:45,710 --> 00:14:52,840
callbacks for the subsequent future the

00:14:49,040 --> 00:14:57,320
subsequent chained future and on and on

00:14:52,840 --> 00:15:01,640
I don't know if there's a guarantee of

00:14:57,320 --> 00:15:04,550
order if you have multiple callbacks on

00:15:01,640 --> 00:15:06,440
the same future but this should proceed

00:15:04,550 --> 00:15:10,550
in a more or less depth first sort of

00:15:06,440 --> 00:15:12,800
fashion now on one gotcha if any of you

00:15:10,550 --> 00:15:15,140
guys saw me on Twitter I said last week

00:15:12,800 --> 00:15:17,210
that something surprised me while I was

00:15:15,140 --> 00:15:20,480
preparing these turns out so this is a

00:15:17,210 --> 00:15:22,490
this is an easy bug to write if a future

00:15:20,480 --> 00:15:25,640
is already resolved when you add a

00:15:22,490 --> 00:15:28,370
callback to it that callback is going to

00:15:25,640 --> 00:15:32,740
immediately execute in your calling

00:15:28,370 --> 00:15:32,740
thread not in the thread of the future

00:15:34,120 --> 00:15:37,269
so because all these things are a little

00:15:35,769 --> 00:15:39,699
bit different we're not submitting to an

00:15:37,269 --> 00:15:42,339
egg to an execution context to get our

00:15:39,699 --> 00:15:46,569
pool all our future creation needs to be

00:15:42,339 --> 00:15:49,930
done explicitly in the future pool so we

00:15:46,569 --> 00:15:51,610
would take and get a future pool there's

00:15:49,930 --> 00:15:54,579
some default ones provided this

00:15:51,610 --> 00:15:57,759
unbounded pool is is kind of a standard

00:15:54,579 --> 00:16:00,129
one that we can grab this first one is a

00:15:57,759 --> 00:16:02,519
nice little bug that I wrote I assumed

00:16:00,129 --> 00:16:05,050
that this would be just like Scala and

00:16:02,519 --> 00:16:06,730
but it's not this is not happening in

00:16:05,050 --> 00:16:09,730
the pool this is happening immediately

00:16:06,730 --> 00:16:11,980
in my thread so it calculates expensive

00:16:09,730 --> 00:16:15,160
that's kind of ugly and this is an easy

00:16:11,980 --> 00:16:17,470
gotcha an easy bug to write instead I

00:16:15,160 --> 00:16:20,620
need to take that pool and now in pools

00:16:17,470 --> 00:16:22,480
apply I can perform that calculate and

00:16:20,620 --> 00:16:26,589
then that gets submitted as an execute

00:16:22,480 --> 00:16:28,209
or attack a callable into that pool all

00:16:26,589 --> 00:16:32,980
these guys I didn't put types on these

00:16:28,209 --> 00:16:35,709
on both not F when we called the future

00:16:32,980 --> 00:16:37,559
apply and F where we call the pools

00:16:35,709 --> 00:16:40,480
apply are both going to give us futures

00:16:37,559 --> 00:16:42,399
but in the first case the work is going

00:16:40,480 --> 00:16:44,439
to be happening in immediately in my

00:16:42,399 --> 00:16:49,059
thread and the future by the time its

00:16:44,439 --> 00:16:52,120
returns will already be resolved so

00:16:49,059 --> 00:16:53,949
cancellation so can't Twitter Twitter

00:16:52,120 --> 00:16:57,279
talks about cancellation and make a big

00:16:53,949 --> 00:16:59,170
deal about cancellation but this is

00:16:57,279 --> 00:17:00,779
really just a lightweight sort of

00:16:59,170 --> 00:17:04,240
cancellation this is a cooperative

00:17:00,779 --> 00:17:07,689
cancellation the producer has to have to

00:17:04,240 --> 00:17:11,079
cooperate in this end and play along so

00:17:07,689 --> 00:17:15,220
in a promise on the promise interface we

00:17:11,079 --> 00:17:18,130
have a method raised that marks the

00:17:15,220 --> 00:17:20,529
promise as interrupted the future does

00:17:18,130 --> 00:17:24,939
not resolve automatically the future

00:17:20,529 --> 00:17:26,919
keeps running also on the promise api we

00:17:24,939 --> 00:17:29,289
have is interrupted so the producer

00:17:26,919 --> 00:17:32,440
that's doing some work can call it

00:17:29,289 --> 00:17:34,690
interrupted and determine whether it's

00:17:32,440 --> 00:17:37,630
in an interrupted state and if it is

00:17:34,690 --> 00:17:39,450
resolved itself with a failure but he

00:17:37,630 --> 00:17:43,620
can easily just keep doing its thing

00:17:39,450 --> 00:17:43,620
future can resolve successfully

00:17:45,420 --> 00:17:49,260
the last one that I want to mention here

00:17:47,190 --> 00:17:51,840
is raised within raised within creates a

00:17:49,260 --> 00:17:54,330
new future that's going to fail after

00:17:51,840 --> 00:17:56,370
the timeout so that one does pay

00:17:54,330 --> 00:17:58,559
attention but again your underlying

00:17:56,370 --> 00:18:00,660
future is it's still running is still

00:17:58,559 --> 00:18:03,090
doing its thing unless it tries to pay

00:18:00,660 --> 00:18:06,929
attention to whether it's interrupted or

00:18:03,090 --> 00:18:12,420
not so an example of that I've got a

00:18:06,929 --> 00:18:17,400
promise I in the pool start to execute

00:18:12,420 --> 00:18:19,020
an expensive calculation if once that

00:18:17,400 --> 00:18:22,500
CalPERS part of the calculation is done

00:18:19,020 --> 00:18:24,750
if I'm interrupted I match on that and

00:18:22,500 --> 00:18:28,049
if I am I set my exception I fail out

00:18:24,750 --> 00:18:30,929
and if I'm not interrupted then I go

00:18:28,049 --> 00:18:34,410
ahead and I do next calculation to

00:18:30,929 --> 00:18:36,480
complete myself successfully from a

00:18:34,410 --> 00:18:38,990
client perspective then I would be

00:18:36,480 --> 00:18:41,490
taking that that future that I've got

00:18:38,990 --> 00:18:44,730
and calling raise on it in order to say

00:18:41,490 --> 00:18:48,900
I want you to stop illegal state

00:18:44,730 --> 00:18:52,350
exception I give up if you're working

00:18:48,900 --> 00:18:55,980
with um Twitter and Scala what's an easy

00:18:52,350 --> 00:18:57,960
way to get between these two types so

00:18:55,980 --> 00:19:00,210
Twitter by ejection is a nice library

00:18:57,960 --> 00:19:05,549
that lets us do this provides us some of

00:19:00,210 --> 00:19:07,770
these on conversion methods so we first

00:19:05,549 --> 00:19:10,830
of all have imported future and Twitter

00:19:07,770 --> 00:19:13,980
future and give them good names I import

00:19:10,830 --> 00:19:16,520
import as method and util by ejections

00:19:13,980 --> 00:19:19,140
then I can create a Twitter future and

00:19:16,520 --> 00:19:22,500
response that as Scala future to turn

00:19:19,140 --> 00:19:24,809
that into a Scala future and the same

00:19:22,500 --> 00:19:27,929
thing to go backwards and by ejection

00:19:24,809 --> 00:19:29,580
supports the nice property that if we go

00:19:27,929 --> 00:19:31,770
back and forth between these we're not

00:19:29,580 --> 00:19:34,020
going to be rapping more and more on to

00:19:31,770 --> 00:19:35,760
them so the first time that we do one

00:19:34,020 --> 00:19:38,280
it's going to be setting up something

00:19:35,760 --> 00:19:41,340
very like the promise with callbacks to

00:19:38,280 --> 00:19:43,110
resolve that promise but it's also going

00:19:41,340 --> 00:19:45,210
to be then storing that original

00:19:43,110 --> 00:19:46,830
contained future so then when I try to

00:19:45,210 --> 00:19:50,429
go back and round-trip that I get the

00:19:46,830 --> 00:19:52,620
original one back and it's memorizing

00:19:50,429 --> 00:19:54,660
that one that I just that I just made so

00:19:52,620 --> 00:19:56,820
if I go back a third time I get the same

00:19:54,660 --> 00:20:01,780
one

00:19:56,820 --> 00:20:06,480
so listenable future guava the guava

00:20:01,780 --> 00:20:06,480
library was really nice for Java back in

00:20:06,780 --> 00:20:14,680
late late 20 single-digits it brought

00:20:12,220 --> 00:20:16,120
some nice functional stuff to Java if

00:20:14,680 --> 00:20:18,700
you were stuck in Java was a nice thing

00:20:16,120 --> 00:20:20,790
to use you had the kinds of things that

00:20:18,700 --> 00:20:23,920
were used to in Scala for collections

00:20:20,790 --> 00:20:25,750
maps and unfolds and all that kind of

00:20:23,920 --> 00:20:28,930
good stuff and one of the things that

00:20:25,750 --> 00:20:31,420
they provided was this future capability

00:20:28,930 --> 00:20:34,720
that had callbacks on it so exactly the

00:20:31,420 --> 00:20:36,310
sort of thing would we'd won so again

00:20:34,720 --> 00:20:39,580
look at the timeline here this is circa

00:20:36,310 --> 00:20:41,800
2011 so it's before the Scala future

00:20:39,580 --> 00:20:43,780
it's before the completable future in

00:20:41,800 --> 00:20:47,200
Java so it was a nice thing to have at

00:20:43,780 --> 00:20:50,230
the time and it did provide for a Java

00:20:47,200 --> 00:20:52,750
kind of customer listenable future so

00:20:50,230 --> 00:20:55,120
let me digress super quickly on why are

00:20:52,750 --> 00:20:58,360
we talking about this right so again at

00:20:55,120 --> 00:21:01,420
tendril we wanted to allow our engineers

00:20:58,360 --> 00:21:04,150
to work in Java as well as in Scala so

00:21:01,420 --> 00:21:07,930
when we built our listenable farce are

00:21:04,150 --> 00:21:10,750
our finagle protobuf plugin we had that

00:21:07,930 --> 00:21:13,270
deal in listenable futures so that we

00:21:10,750 --> 00:21:15,670
could do a sync all the way in Java and

00:21:13,270 --> 00:21:17,460
not have to know anything about Twitter

00:21:15,670 --> 00:21:21,760
not have to know anything about Scala

00:21:17,460 --> 00:21:23,370
some of that was done for facade sort of

00:21:21,760 --> 00:21:25,510
reasons so we could potentially rip out

00:21:23,370 --> 00:21:28,300
finagle underneath if we decided we

00:21:25,510 --> 00:21:31,200
didn't like it and so some of those

00:21:28,300 --> 00:21:34,420
choices have still stayed with us

00:21:31,200 --> 00:21:36,550
so listenable futures made up of a few

00:21:34,420 --> 00:21:39,220
different pieces we have listenable

00:21:36,550 --> 00:21:42,280
future itself which is basically a Java

00:21:39,220 --> 00:21:43,960
future with an extra on add listener

00:21:42,280 --> 00:21:46,990
method for us to set up the callbacks on

00:21:43,960 --> 00:21:49,020
but then we've got this helper class

00:21:46,990 --> 00:21:51,640
futures that has all these nice things

00:21:49,020 --> 00:21:54,010
that we would use Combinator style so

00:21:51,640 --> 00:21:55,900
we've got transform there's a couple

00:21:54,010 --> 00:21:58,390
kinds of transform that correspond to

00:21:55,900 --> 00:22:00,040
map and flatmap we've got all his list

00:21:58,390 --> 00:22:02,020
and successful is list so we can deal

00:22:00,040 --> 00:22:05,560
with lists of these things and convert

00:22:02,020 --> 00:22:07,420
them to a listenable future of list

00:22:05,560 --> 00:22:07,940
after we started with a list of

00:22:07,420 --> 00:22:11,240
listenable

00:22:07,940 --> 00:22:14,539
future catching and catching a sink in

00:22:11,240 --> 00:22:18,019
order to on handle recovery from

00:22:14,539 --> 00:22:20,000
failures immediate future is immediate

00:22:18,019 --> 00:22:23,539
failed futures so again we can build up

00:22:20,000 --> 00:22:26,299
those building blocks either for testing

00:22:23,539 --> 00:22:29,990
purposes or in branches where we know a

00:22:26,299 --> 00:22:31,850
result immediately we have a listening

00:22:29,990 --> 00:22:33,950
executor service which is a decorator

00:22:31,850 --> 00:22:36,799
for regular executor service that lets

00:22:33,950 --> 00:22:38,570
us create listenable futures and we have

00:22:36,799 --> 00:22:42,940
settable future that's pretty analogous

00:22:38,570 --> 00:22:45,230
to promises so transforms and callbacks

00:22:42,940 --> 00:22:48,289
we start with a listening decorator

00:22:45,230 --> 00:22:50,059
wrapped around a fixed thread pool and

00:22:48,289 --> 00:22:53,629
so now anything that we submit to this

00:22:50,059 --> 00:22:56,299
like it's submitting to regular executor

00:22:53,629 --> 00:22:58,220
service instead of returning as a

00:22:56,299 --> 00:23:03,200
standard Java future will return us a

00:22:58,220 --> 00:23:06,919
listenable future so inducing I'm

00:23:03,200 --> 00:23:09,379
submitting a callable to that then we're

00:23:06,919 --> 00:23:12,080
using futures that transform and passing

00:23:09,379 --> 00:23:15,049
it a guava function that does the apply

00:23:12,080 --> 00:23:18,080
and returns a listenable future at the

00:23:15,049 --> 00:23:21,730
end we're doing futures at callback this

00:23:18,080 --> 00:23:24,019
is pretty ugly luckily in on 212

00:23:21,730 --> 00:23:26,000
it's a guava future and a couple of

00:23:24,019 --> 00:23:28,129
those other pieces or Sam types so in

00:23:26,000 --> 00:23:30,830
212 any of our lambdas and Scala

00:23:28,129 --> 00:23:35,350
automatically generates the Sam type

00:23:30,830 --> 00:23:38,029
interfaces so we can get this much nicer

00:23:35,350 --> 00:23:40,759
but it's still kind of not very pleasant

00:23:38,029 --> 00:23:42,799
to use from Scala it's not chainable all

00:23:40,759 --> 00:23:44,929
this transform steps they returned

00:23:42,799 --> 00:23:47,240
listenable futures but we can't just

00:23:44,929 --> 00:23:49,100
call dot transform transform transform

00:23:47,240 --> 00:23:51,289
we got to stick it in a vowel and call

00:23:49,100 --> 00:23:55,370
listen about futures that transform on

00:23:51,289 --> 00:23:58,460
it these don't work super great with the

00:23:55,370 --> 00:24:00,289
type inference so you have to have type

00:23:58,460 --> 00:24:03,289
hints on a lot of these things

00:24:00,289 --> 00:24:06,350
guava function and guava async function

00:24:03,289 --> 00:24:08,779
are you know in different places in the

00:24:06,350 --> 00:24:11,330
type hierarchy so you can't just use a

00:24:08,779 --> 00:24:15,169
regular Scala future and have it work

00:24:11,330 --> 00:24:17,600
with those um transform and transform

00:24:15,169 --> 00:24:19,490
async before guava

00:24:17,600 --> 00:24:22,070
two-twenty they were both called

00:24:19,490 --> 00:24:24,320
transform so it's

00:24:22,070 --> 00:24:27,860
this map and flatmap we're both called

00:24:24,320 --> 00:24:30,230
napa map which yeah it works it's an

00:24:27,860 --> 00:24:32,540
overloading it's perfectly valid Java or

00:24:30,230 --> 00:24:35,690
Scala but doesn't make it harder to work

00:24:32,540 --> 00:24:39,140
with now we have transform and transform

00:24:35,690 --> 00:24:40,730
async and now in the newest version you

00:24:39,140 --> 00:24:41,750
have to pass an execution context

00:24:40,730 --> 00:24:43,970
everywhere and you can't do that

00:24:41,750 --> 00:24:47,300
implicitly so that's kind of tricky to

00:24:43,970 --> 00:24:48,890
use from Scala as well but you can make

00:24:47,300 --> 00:24:51,110
this a little bit a little bit easier

00:24:48,890 --> 00:24:55,700
there's something called the guilt sound

00:24:51,110 --> 00:24:58,190
a guilt guilt industries or guilt Tech

00:24:55,700 --> 00:25:00,140
or something like that and they have

00:24:58,190 --> 00:25:03,920
provided some foundation classes and one

00:25:00,140 --> 00:25:07,310
of them is GFC guava provides us some

00:25:03,920 --> 00:25:10,700
nice things like implicit conversions

00:25:07,310 --> 00:25:12,260
and things we can call guava futures dot

00:25:10,700 --> 00:25:15,650
future and it's Apple I'll create a

00:25:12,260 --> 00:25:17,780
listenable future for us we can make a

00:25:15,650 --> 00:25:20,780
Scala future and say dot as listenable

00:25:17,780 --> 00:25:22,430
future on it and we can use map and

00:25:20,780 --> 00:25:25,160
flatmap and it'll take care of mapping

00:25:22,430 --> 00:25:27,800
these things doing the appropriate calls

00:25:25,160 --> 00:25:29,420
underneath incidentally you can write

00:25:27,800 --> 00:25:30,890
this kind of stuff yourself right it's

00:25:29,420 --> 00:25:33,620
just writing an implicit conversion that

00:25:30,890 --> 00:25:35,090
hooks up the arm creates a promise and

00:25:33,620 --> 00:25:37,340
hooks up the callbacks to resolve the

00:25:35,090 --> 00:25:40,700
promise but it's nice that you can grab

00:25:37,340 --> 00:25:43,190
something else that does this for you so

00:25:40,700 --> 00:25:44,570
in job eight we have complete abyss and

00:25:43,190 --> 00:25:47,360
finally we have a pretty reasonable

00:25:44,570 --> 00:25:51,290
interface for doing futures with

00:25:47,360 --> 00:25:52,430
callbacks in Java um but it's kind of a

00:25:51,290 --> 00:25:53,720
little bit interesting and different

00:25:52,430 --> 00:25:56,840
from the way that we're used to this in

00:25:53,720 --> 00:25:58,640
Scala so we have a single completable

00:25:56,840 --> 00:26:02,540
future which acts as both the promise

00:25:58,640 --> 00:26:05,270
and and the future end when we create it

00:26:02,540 --> 00:26:08,750
we can created a promise we can use the

00:26:05,270 --> 00:26:12,770
supply async or run async the supplier

00:26:08,750 --> 00:26:15,230
interface that supply async takes is

00:26:12,770 --> 00:26:18,410
basically just an interface with a

00:26:15,230 --> 00:26:20,240
single get method obviously when you

00:26:18,410 --> 00:26:21,440
implement that that can take you know

00:26:20,240 --> 00:26:24,050
that can be quick or that can take as

00:26:21,440 --> 00:26:25,700
long as it needs to take run async is

00:26:24,050 --> 00:26:29,150
just a regular runnable so all we get

00:26:25,700 --> 00:26:31,490
out of that is a completable future of

00:26:29,150 --> 00:26:34,160
void so we just know that it finished

00:26:31,490 --> 00:26:34,610
unless we do typical icky Java things

00:26:34,160 --> 00:26:37,010
and

00:26:34,610 --> 00:26:41,809
or shared state or something it's hard

00:26:37,010 --> 00:26:44,690
to get value out of that so an example

00:26:41,809 --> 00:26:47,410
for a completable future so I've started

00:26:44,690 --> 00:26:50,750
with a completable future promise style

00:26:47,410 --> 00:26:53,540
I'm going to then apply a sync then

00:26:50,750 --> 00:26:56,570
apply then apply and then apply async

00:26:53,540 --> 00:26:58,460
are equivalent to map I'll talk more

00:26:56,570 --> 00:27:00,980
about that in just a second this is not

00:26:58,460 --> 00:27:06,110
map and flatmap but it's two variants of

00:27:00,980 --> 00:27:10,520
map and we'll take take our eye and

00:27:06,110 --> 00:27:12,830
scale it our final stage we also have

00:27:10,520 --> 00:27:14,360
kind of a weird interface that's not

00:27:12,830 --> 00:27:18,470
quite what we would normally like in

00:27:14,360 --> 00:27:20,360
Scala we get handed on two arguments and

00:27:18,470 --> 00:27:21,559
the first argument represents the

00:27:20,360 --> 00:27:23,780
success case in the second argument

00:27:21,559 --> 00:27:25,429
represents the failure case and if this

00:27:23,780 --> 00:27:26,870
were a successful future the first one

00:27:25,429 --> 00:27:28,370
will be non null and the second one will

00:27:26,870 --> 00:27:29,600
be null and if this is a failure the

00:27:28,370 --> 00:27:31,370
second one will be non null and the

00:27:29,600 --> 00:27:34,070
first one will be no so you have this

00:27:31,370 --> 00:27:36,440
ugly kind of handle R and T if r's not

00:27:34,070 --> 00:27:38,870
null do the happy path ''tis not null to

00:27:36,440 --> 00:27:41,390
the exception path some point in the

00:27:38,870 --> 00:27:43,580
future we're done complete on the

00:27:41,390 --> 00:27:46,429
completable future and then all of our

00:27:43,580 --> 00:27:47,990
subsequent then then trans then applies

00:27:46,429 --> 00:27:51,950
then apply async all that kind of stuff

00:27:47,990 --> 00:27:54,740
will happen so the the different apply

00:27:51,950 --> 00:27:58,100
and apply async handle and handle async

00:27:54,740 --> 00:28:00,470
pretty much all of the methods have this

00:27:58,100 --> 00:28:02,750
regular version and async version and

00:28:00,470 --> 00:28:03,679
the difference for those is the

00:28:02,750 --> 00:28:06,350
execution model

00:28:03,679 --> 00:28:08,510
so when we call apply or when we call

00:28:06,350 --> 00:28:10,640
handle those are going to operate in the

00:28:08,510 --> 00:28:14,179
thread that resolved the prior

00:28:10,640 --> 00:28:16,370
completion stage if we call apply async

00:28:14,179 --> 00:28:20,600
or handle async then we're either going

00:28:16,370 --> 00:28:24,049
to provide an execution context or will

00:28:20,600 --> 00:28:26,840
use the default executor to run that

00:28:24,049 --> 00:28:30,530
that transform body so the default

00:28:26,840 --> 00:28:32,750
executor is a for killing pool depending

00:28:30,530 --> 00:28:38,840
how that's configured might get a new

00:28:32,750 --> 00:28:42,980
thread might not get a new thread all I

00:28:38,840 --> 00:28:44,840
want to do so we have a number of

00:28:42,980 --> 00:28:46,730
different for different kinds of

00:28:44,840 --> 00:28:48,140
Combinator's we have a number of

00:28:46,730 --> 00:28:51,440
different variants for whether

00:28:48,140 --> 00:28:53,990
runnable or a supplier whether you want

00:28:51,440 --> 00:28:58,100
to function to operate on it or a

00:28:53,990 --> 00:29:00,110
consumer that's like a sink for it we

00:28:58,100 --> 00:29:02,570
don't have this recover width and we

00:29:00,110 --> 00:29:05,870
only have one kind of recovery so in

00:29:02,570 --> 00:29:08,060
both Scala and Twitter futures we can

00:29:05,870 --> 00:29:11,650
recover a failed future by providing a

00:29:08,060 --> 00:29:15,950
new future so we can either have a

00:29:11,650 --> 00:29:17,780
process already going maybe I referred

00:29:15,950 --> 00:29:19,280
to earlier on maybe I'm talking to a

00:29:17,780 --> 00:29:21,650
cache and talking to an actual

00:29:19,280 --> 00:29:24,620
computation so maybe I've got a future

00:29:21,650 --> 00:29:26,180
already potentially being resolved and I

00:29:24,620 --> 00:29:28,190
want to slot that in there maybe I want

00:29:26,180 --> 00:29:30,440
to start some new work right when I'm

00:29:28,190 --> 00:29:32,450
recovering and plop the future in there

00:29:30,440 --> 00:29:34,460
so it's really replaced this failed

00:29:32,450 --> 00:29:38,300
future with this with this other

00:29:34,460 --> 00:29:39,950
potentially healthy future but in the

00:29:38,300 --> 00:29:43,580
completable future we don't have that we

00:29:39,950 --> 00:29:47,060
can just recover with of value not with

00:29:43,580 --> 00:29:49,940
a future value we have a couple which

00:29:47,060 --> 00:29:54,380
are kind of interesting because they're

00:29:49,940 --> 00:29:57,500
slightly more efficient in more

00:29:54,380 --> 00:30:00,890
efficient in coding not more efficient

00:29:57,500 --> 00:30:03,590
in performance so in Scala something

00:30:00,890 --> 00:30:05,930
like zip would return a future that is

00:30:03,590 --> 00:30:07,520
the future of tupple of the two

00:30:05,930 --> 00:30:09,260
different future types right so we've

00:30:07,520 --> 00:30:10,880
got say future event and future of

00:30:09,260 --> 00:30:14,110
string and we zip them together we're

00:30:10,880 --> 00:30:16,910
going to get future of tupple int string

00:30:14,110 --> 00:30:18,500
and then if we want to do something with

00:30:16,910 --> 00:30:21,160
that we're going to have to map it or

00:30:18,500 --> 00:30:24,530
flat map it to do that next operation

00:30:21,160 --> 00:30:27,230
whereas the dot-com then combined in

00:30:24,530 --> 00:30:28,400
completable future will immediately do

00:30:27,230 --> 00:30:30,200
that saying we'll never get that

00:30:28,400 --> 00:30:35,420
intermediate future of tupple of

00:30:30,200 --> 00:30:36,980
whatever um and then we've got that

00:30:35,420 --> 00:30:40,250
overall handle method which I talked

00:30:36,980 --> 00:30:43,490
about on the other slide with this

00:30:40,250 --> 00:30:48,830
despite function of the arm the result

00:30:43,490 --> 00:30:52,670
the T value and the throwable value so

00:30:48,830 --> 00:30:54,920
task I want to just briefly talk about

00:30:52,670 --> 00:30:57,130
tasks we're not using tasks yet we're

00:30:54,920 --> 00:31:00,440
just starting to kind of look at at them

00:30:57,130 --> 00:31:01,490
if you guys didn't get a chance to see

00:31:00,440 --> 00:31:03,980
Alexander's

00:31:01,490 --> 00:31:07,460
monix talked earlier today look for the

00:31:03,980 --> 00:31:10,580
recording of that there's task

00:31:07,460 --> 00:31:13,460
interfaces in Scala Z and monix and in

00:31:10,580 --> 00:31:16,730
FS too and for purposes of this talk we

00:31:13,460 --> 00:31:19,940
can think about those as lazy futures so

00:31:16,730 --> 00:31:23,960
they don't run their bodies until we

00:31:19,940 --> 00:31:26,000
explicitly ask them to be run so these

00:31:23,960 --> 00:31:29,030
are respected scholar Z attempt run

00:31:26,000 --> 00:31:32,150
monix call run async FS to call unsafe

00:31:29,030 --> 00:31:34,220
run async once we call that then it will

00:31:32,150 --> 00:31:36,230
run typically give us a future value

00:31:34,220 --> 00:31:39,110
back depending on what the API of the

00:31:36,230 --> 00:31:42,380
thing is so the nice thing when you're

00:31:39,110 --> 00:31:43,520
come writing software with these if

00:31:42,380 --> 00:31:45,740
you're not going to have unexpected

00:31:43,520 --> 00:31:47,780
computations or unwanted computations

00:31:45,740 --> 00:31:49,310
right you're building the pipeline up

00:31:47,780 --> 00:31:51,170
and then explicitly executing the

00:31:49,310 --> 00:31:53,270
pipeline at the end if there's any

00:31:51,170 --> 00:31:56,570
reason that you can as you build that

00:31:53,270 --> 00:31:58,820
thing up no this is a failure I'm done I

00:31:56,570 --> 00:32:00,770
just want to return you know a failure

00:31:58,820 --> 00:32:02,480
condition back to my caller I don't want

00:32:00,770 --> 00:32:05,240
to start executing that whole sequence

00:32:02,480 --> 00:32:09,110
of computations you don't have to do

00:32:05,240 --> 00:32:11,330
that and the nice thing for for trying

00:32:09,110 --> 00:32:12,290
not to write bugs is because of that

00:32:11,330 --> 00:32:14,030
you're not leaking any of those

00:32:12,290 --> 00:32:16,670
computations if you didn't do them until

00:32:14,030 --> 00:32:20,420
you really meant to do them they can't

00:32:16,670 --> 00:32:24,890
leak on you memoization is optional in

00:32:20,420 --> 00:32:26,360
these by default none of the three save

00:32:24,890 --> 00:32:28,010
the values so you can take that same

00:32:26,360 --> 00:32:31,370
task and run over and over and over

00:32:28,010 --> 00:32:34,250
again and it will typically redo the

00:32:31,370 --> 00:32:36,560
calculation but you can actually

00:32:34,250 --> 00:32:38,450
memorize it and basically cache that

00:32:36,560 --> 00:32:40,970
value so when you run it the second time

00:32:38,450 --> 00:32:42,620
you get the same one out these are

00:32:40,970 --> 00:32:44,000
usually based on trampolines I'm not

00:32:42,620 --> 00:32:46,280
going to say too much about that but

00:32:44,000 --> 00:32:50,410
that's a mechanism for using a loop and

00:32:46,280 --> 00:32:53,330
heap rather than space on your stack and

00:32:50,410 --> 00:32:56,600
there's cancellation support in all of

00:32:53,330 --> 00:32:58,190
these so a quick example for monix is

00:32:56,600 --> 00:33:02,420
basically from their from their

00:32:58,190 --> 00:33:04,040
documentation we have this task in this

00:33:02,420 --> 00:33:05,600
example we can't really observe whether

00:33:04,040 --> 00:33:09,710
it's running or not but this is not

00:33:05,600 --> 00:33:11,700
running until we call the run async and

00:33:09,710 --> 00:33:15,270
then at that point we can

00:33:11,700 --> 00:33:17,310
on the so we can either do that directly

00:33:15,270 --> 00:33:20,100
path or and they think a partial

00:33:17,310 --> 00:33:22,080
function that's going to operate and

00:33:20,100 --> 00:33:24,780
determine whether we're success or

00:33:22,080 --> 00:33:27,030
failure and do whatever with it or we

00:33:24,780 --> 00:33:29,040
can also future style say tasks

00:33:27,030 --> 00:33:33,540
renascent get a regular Scala few draft

00:33:29,040 --> 00:33:36,750
and do our things so comparison and

00:33:33,540 --> 00:33:38,970
recommendations I put this big this big

00:33:36,750 --> 00:33:42,000
chart together I am NOT going to cover

00:33:38,970 --> 00:33:44,880
this in complete detail slides will be

00:33:42,000 --> 00:33:50,240
available a couple of things I want to

00:33:44,880 --> 00:33:53,580
point out from this so the cancellations

00:33:50,240 --> 00:33:57,150
on Twitter does support cancellation but

00:33:53,580 --> 00:33:59,700
it's cooperative completable future does

00:33:57,150 --> 00:34:01,740
support cancellation and they have an

00:33:59,700 --> 00:34:02,820
argument that you pass in that says

00:34:01,740 --> 00:34:05,670
whether you want it to interrupt the

00:34:02,820 --> 00:34:07,470
thread or not but as of right now it

00:34:05,670 --> 00:34:10,050
ignores that argument does not cancel

00:34:07,470 --> 00:34:12,840
the underlying thread it just resolves

00:34:10,050 --> 00:34:15,510
that future with a cancelled status with

00:34:12,840 --> 00:34:19,830
whatever on exceptions that you've

00:34:15,510 --> 00:34:22,380
passed in and then in terms of for

00:34:19,830 --> 00:34:24,450
comprehension Scala and Twitter yeah you

00:34:22,380 --> 00:34:27,210
can write for comprehensions guava you

00:34:24,450 --> 00:34:29,280
can't unless you use GFC guava and

00:34:27,210 --> 00:34:31,440
completable future you cannot unless you

00:34:29,280 --> 00:34:34,200
play similar tricks and write implicit

00:34:31,440 --> 00:34:34,850
conversions and stuff or explicit

00:34:34,200 --> 00:34:38,970
conversion

00:34:34,850 --> 00:34:42,590
and then for interrupts so so using

00:34:38,970 --> 00:34:44,640
Scala's future from from java is so so

00:34:42,590 --> 00:34:46,890
you have to implement things like

00:34:44,640 --> 00:34:48,720
partial function there's an abstract

00:34:46,890 --> 00:34:51,600
partial function that you can build from

00:34:48,720 --> 00:34:53,340
and things like that to do that Twitter

00:34:51,600 --> 00:34:54,870
on the other hand provides some variants

00:34:53,340 --> 00:34:56,010
that are explicitly there for Java

00:34:54,870 --> 00:34:58,610
Interop they've really thought about

00:34:56,010 --> 00:35:01,080
Java interrupts that's that's not not -

00:34:58,610 --> 00:35:06,720
not too difficult to use from Java

00:35:01,080 --> 00:35:08,070
guava it's fair not great in Java for

00:35:06,720 --> 00:35:09,750
some of the same reasons that I talked

00:35:08,070 --> 00:35:12,660
about about not being able to chain and

00:35:09,750 --> 00:35:15,960
things like that but it's kind of a pain

00:35:12,660 --> 00:35:19,410
from from skål unless you use GSE guava

00:35:15,960 --> 00:35:21,900
or something and um job a completable

00:35:19,410 --> 00:35:24,960
future is pretty reasonable from both

00:35:21,900 --> 00:35:25,369
Java and Scala although I did have to

00:35:24,960 --> 00:35:27,410
give up

00:35:25,369 --> 00:35:33,160
you type in today type inference work

00:35:27,410 --> 00:35:35,900
well so my recommendations overall is

00:35:33,160 --> 00:35:38,749
use whatever your library's use like if

00:35:35,900 --> 00:35:41,150
you're staying in standard Scala the

00:35:38,749 --> 00:35:43,369
standard Scala futures pretty good

00:35:41,150 --> 00:35:45,950
there's not really a reason that you

00:35:43,369 --> 00:35:48,259
would hold twitter futures in just to

00:35:45,950 --> 00:35:50,359
pull twitter futures in but if you're

00:35:48,259 --> 00:35:52,069
using finagle or you're using something

00:35:50,359 --> 00:35:54,529
else from the twitter ecosystem that

00:35:52,069 --> 00:36:00,440
operates in twitter futures that'd be a

00:35:54,529 --> 00:36:02,089
good reason to pull them in unless you

00:36:00,440 --> 00:36:05,150
want to use some of those monitoring

00:36:02,089 --> 00:36:07,279
Combinator's or cancellation yeah give

00:36:05,150 --> 00:36:10,549
it a try see if see if that works well

00:36:07,279 --> 00:36:12,980
for you if you do have to mix Scala and

00:36:10,549 --> 00:36:14,960
Twitter by all means use it by Jackson

00:36:12,980 --> 00:36:18,230
don't rewrite that yourself odds pretty

00:36:14,960 --> 00:36:20,839
pretty lightweight and easy to use for

00:36:18,230 --> 00:36:22,970
Java Interop prefer completable future

00:36:20,839 --> 00:36:26,359
unless you're stuck within a library

00:36:22,970 --> 00:36:28,490
that needs to do guava which is not

00:36:26,359 --> 00:36:30,680
worth not worth it at this point it was

00:36:28,490 --> 00:36:34,160
really good when it came out but state

00:36:30,680 --> 00:36:35,630
of the art has moved on a few other

00:36:34,160 --> 00:36:38,630
things you might look at if you're

00:36:35,630 --> 00:36:41,839
trying to do async non-blocking reactive

00:36:38,630 --> 00:36:44,599
kind of stuff so reactive extensions

00:36:41,839 --> 00:36:46,190
we've got observables and streams and

00:36:44,599 --> 00:36:47,869
stuff like that that's all pretty good

00:36:46,190 --> 00:36:51,109
there's bindings for that from a bunch

00:36:47,869 --> 00:36:54,559
of different languages streams we have

00:36:51,109 --> 00:36:58,249
Scala ZFS too and akka check out the

00:36:54,559 --> 00:36:59,630
akka streams talk that Zack and I can't

00:36:58,249 --> 00:37:01,700
remember his last name gave earlier

00:36:59,630 --> 00:37:05,720
today that's a good recording to check

00:37:01,700 --> 00:37:07,160
out obviously we have actor model actor

00:37:05,720 --> 00:37:09,069
models a different sort of concurrency

00:37:07,160 --> 00:37:13,249
model that might be might fit your needs

00:37:09,069 --> 00:37:15,410
and there's a co-routine library that

00:37:13,249 --> 00:37:17,720
that is out that might be worth checking

00:37:15,410 --> 00:37:20,829
out it seems pretty early days but it's

00:37:17,720 --> 00:37:22,789
a different sort of cooperative

00:37:20,829 --> 00:37:26,989
concurrency model that might might be

00:37:22,789 --> 00:37:30,890
interesting to check out so I'm Chris

00:37:26,989 --> 00:37:32,450
Phelps I have examples of most of the

00:37:30,890 --> 00:37:35,900
stuff I talked about today on my github

00:37:32,450 --> 00:37:37,170
so you can check that out there and I

00:37:35,900 --> 00:37:42,150
think I have a few min

00:37:37,170 --> 00:37:44,609
for questions I was wondering about the

00:37:42,150 --> 00:37:47,930
Scala futures do you know if the absence

00:37:44,609 --> 00:37:50,579
of the ability to cancel them is a

00:37:47,930 --> 00:37:53,309
design decision that was made on purpose

00:37:50,579 --> 00:38:01,529
or is it more just something that they

00:37:53,309 --> 00:38:04,440
never got around to adding I do not know

00:38:01,529 --> 00:38:09,200
if there have been any any thoughts or

00:38:04,440 --> 00:38:09,200
discussions around trying to add those a

00:38:09,559 --> 00:38:17,549
not a question just a note when you're

00:38:14,160 --> 00:38:19,529
talking about tasks so you mentioned

00:38:17,549 --> 00:38:22,200
that all three implementations support

00:38:19,529 --> 00:38:24,690
cancellation and memorization that's not

00:38:22,200 --> 00:38:28,650
actually true only monix tasks supposed

00:38:24,690 --> 00:38:29,640
cancellation the scholars it is stuff is

00:38:28,650 --> 00:38:33,059
the workaround

00:38:29,640 --> 00:38:36,059
that doesn't work well and it doesn't

00:38:33,059 --> 00:38:39,150
have a good memorization story so you

00:38:36,059 --> 00:38:42,230
know just FYI okay excellent

00:38:39,150 --> 00:38:45,150
excellent to know all three of them have

00:38:42,230 --> 00:38:47,759
things for cancellation and memoization

00:38:45,150 --> 00:38:50,190
in their api's it's really good to know

00:38:47,759 --> 00:38:55,440
that there there might be gotchas

00:38:50,190 --> 00:38:58,460
underneath that thank you all right

00:38:55,440 --> 00:38:58,460
thanks guys

00:39:01,230 --> 00:39:03,290

YouTube URL: https://www.youtube.com/watch?v=-16deuOt7AA


