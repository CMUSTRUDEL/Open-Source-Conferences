Title: Learn you Akka Streams for great Good!   by Heiko Seeberger
Publication date: 2017-06-28
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Stream processing has become ubiquitous and Akka Streams, an implementation of the Reactive Streams specification, is one of the hottest kids on the block. In this talk we not only cover the essentials, but also introduce some advanced features like working with materialized values and cyclic graphs. As we strongly believe in writing code as the best way to learn coding, we show zero slides, but a lot of live code and live demos instead.
Captions: 
	00:00:04,420 --> 00:00:11,209
okay let's get started I'm Michael and

00:00:06,920 --> 00:00:14,599
I'm here to talk about acha streams but

00:00:11,209 --> 00:00:16,790
something terrible has happened if you

00:00:14,599 --> 00:00:20,060
go to Martin's keynote yesterday who

00:00:16,790 --> 00:00:24,169
went okay did you see what happened to

00:00:20,060 --> 00:00:29,239
his slides he lost a couple slides very

00:00:24,169 --> 00:00:32,290
bad total disaster something even worse

00:00:29,239 --> 00:00:36,320
happened to me I lost all my slide I

00:00:32,290 --> 00:00:40,610
don't have slides so let's do some live

00:00:36,320 --> 00:00:41,150
coding live demos maybe you can help me

00:00:40,610 --> 00:00:44,260
a little bit okay

00:00:41,150 --> 00:00:48,350
so sometimes when I'm out of ideas

00:00:44,260 --> 00:00:53,240
please jump in I'm so glad to have

00:00:48,350 --> 00:00:56,600
Victor here one of the inventor of this

00:00:53,240 --> 00:00:58,310
thing here reactive streams if you don't

00:00:56,600 --> 00:01:01,130
know what akka streams is make sure you

00:00:58,310 --> 00:01:07,130
understand reactive streams but let's

00:01:01,130 --> 00:01:11,440
what we that's code okay first a little

00:01:07,130 --> 00:01:14,090
bit of a story about the basics armed

00:01:11,440 --> 00:01:17,030
extremes of course is built on top of

00:01:14,090 --> 00:01:20,690
vodka so therefore in order to use the

00:01:17,030 --> 00:01:22,580
API we also need to create an active

00:01:20,690 --> 00:01:25,310
system and we need to create this

00:01:22,580 --> 00:01:29,960
strange materializer which we'll cover

00:01:25,310 --> 00:01:32,560
later in some detail and before we start

00:01:29,960 --> 00:01:43,190
hacking let's take a look at what we are

00:01:32,560 --> 00:01:50,470
would like to do so I did prepare

00:01:43,190 --> 00:01:53,750
something it's not shown here anyway and

00:01:50,470 --> 00:01:55,400
let me just run the application I'm

00:01:53,750 --> 00:01:59,979
going through we have your own to write

00:01:55,400 --> 00:02:05,119
for you guys so this very advanced

00:01:59,979 --> 00:02:06,740
example of strings as you can see it's

00:02:05,119 --> 00:02:07,100
printing this learn racket integrate

00:02:06,740 --> 00:02:09,619
good

00:02:07,100 --> 00:02:11,930
seven times seven lines always indented

00:02:09,619 --> 00:02:14,599
a little bit more and obviously pretty

00:02:11,930 --> 00:02:17,000
slowly character the character that's

00:02:14,599 --> 00:02:19,610
what we are going to implement now step

00:02:17,000 --> 00:02:22,880
step oh no that's the solution let me go

00:02:19,610 --> 00:02:26,900
back to the initial state I hope you can

00:02:22,880 --> 00:02:30,530
see that alright so here we go um so

00:02:26,900 --> 00:02:33,170
first in the thing about how a stream

00:02:30,530 --> 00:02:37,280
processing topology could look like that

00:02:33,170 --> 00:02:40,550
behaves like this in Arcis streams

00:02:37,280 --> 00:02:43,430
there's an API to express linear

00:02:40,550 --> 00:02:45,530
training topologies and this is

00:02:43,430 --> 00:02:47,690
comprised of mainly three building

00:02:45,530 --> 00:02:50,180
blocks called source flow and think a

00:02:47,690 --> 00:02:52,250
source can produce elements a sink can

00:02:50,180 --> 00:02:55,130
consume element and a flow is the thing

00:02:52,250 --> 00:02:59,360
in between armed let's start with a

00:02:55,130 --> 00:03:01,250
source we have to import the scallop is

00:02:59,360 --> 00:03:05,209
l1 because for some reason scholar also

00:03:01,250 --> 00:03:10,630
has a net so a Java API and we start

00:03:05,209 --> 00:03:10,630
with a single element let me copy that

00:03:10,810 --> 00:03:20,570
single element so if we look at the type

00:03:18,020 --> 00:03:23,330
of this expression we see that is a

00:03:20,570 --> 00:03:26,000
source string and let's just ignore

00:03:23,330 --> 00:03:27,769
they're not used for the time being so

00:03:26,000 --> 00:03:30,440
the source is producing strings so far

00:03:27,769 --> 00:03:34,790
so good what can we do with it

00:03:30,440 --> 00:03:39,530
in order to the minimal stream that can

00:03:34,790 --> 00:03:43,790
be run we need to feed the element into

00:03:39,530 --> 00:03:48,799
the sink so we use two Combinator and we

00:03:43,790 --> 00:03:56,769
create a sink dot for each it's okay let

00:03:48,799 --> 00:03:56,769
me import that okay for each print ln3

00:03:57,040 --> 00:04:07,480
format that's nicely and now we have a

00:04:01,519 --> 00:04:12,019
runnable graph so whenever you arm

00:04:07,480 --> 00:04:14,170
combine or connect all the inlets and

00:04:12,019 --> 00:04:16,820
outlets of the simpson source and flows

00:04:14,170 --> 00:04:18,979
you get a run of the graph

00:04:16,820 --> 00:04:22,490
nothing is unconnected and therefore it

00:04:18,979 --> 00:04:25,820
can be run and running means to invoke

00:04:22,490 --> 00:04:28,340
the run method so until here before

00:04:25,820 --> 00:04:29,480
invoking the run method this here is

00:04:28,340 --> 00:04:32,900
just a blueprint

00:04:29,480 --> 00:04:35,840
it's a cold stream nothing is flowing no

00:04:32,900 --> 00:04:39,980
element nothing has happened when we

00:04:35,840 --> 00:04:42,740
call run we actually run the stream it

00:04:39,980 --> 00:04:44,260
becomes hot the problem with this run

00:04:42,740 --> 00:04:47,360
method is it takes an implicit

00:04:44,260 --> 00:04:49,730
materializer and that's the reason why

00:04:47,360 --> 00:04:53,330
we had to define it up here

00:04:49,730 --> 00:04:56,240
the materializer take the blueprint and

00:04:53,330 --> 00:05:01,460
maps it in this case it's an active tool

00:04:56,240 --> 00:05:06,830
either on two actors okay um so what do

00:05:01,460 --> 00:05:09,980
we get as a return value not used all

00:05:06,830 --> 00:05:13,400
right let's give it a try and oh sorry

00:05:09,980 --> 00:05:16,580
no breaker and run it by the way look

00:05:13,400 --> 00:05:18,650
who is already using walker screams okay

00:05:16,580 --> 00:05:20,840
cool we will do some more of that stuff

00:05:18,650 --> 00:05:21,370
later no worries and you can see it's

00:05:20,840 --> 00:05:23,510
working

00:05:21,370 --> 00:05:25,730
unfortunately the program is still

00:05:23,510 --> 00:05:29,210
running it hasn't terminated although

00:05:25,730 --> 00:05:32,300
the stream has completed um and that's

00:05:29,210 --> 00:05:34,940
because the active system is still there

00:05:32,300 --> 00:05:37,100
it hasn't terminated we have in

00:05:34,940 --> 00:05:40,940
terminating it so let's try to do that

00:05:37,100 --> 00:05:45,620
next it would be nice to know when the

00:05:40,940 --> 00:05:49,670
stream has completed and this is when

00:05:45,620 --> 00:05:54,200
materials w's enter the state if we look

00:05:49,670 --> 00:05:58,910
at this I think for each R we get a sink

00:05:54,200 --> 00:06:00,620
of string and future of done so now

00:05:58,910 --> 00:06:04,250
let's talk about the second type

00:06:00,620 --> 00:06:10,610
parameter in extremes every stage sync

00:06:04,250 --> 00:06:13,790
flow source whatever custom stages has a

00:06:10,610 --> 00:06:16,670
materialized value or produces a

00:06:13,790 --> 00:06:19,940
materialized value when you run the

00:06:16,670 --> 00:06:24,490
screen and this value lets you interact

00:06:19,940 --> 00:06:27,050
with the hot with the running stream um

00:06:24,490 --> 00:06:28,820
some of the stages don't have

00:06:27,050 --> 00:06:32,210
interesting but us values like the

00:06:28,820 --> 00:06:35,470
source single it has this are just value

00:06:32,210 --> 00:06:38,690
had not used and that's like unit um

00:06:35,470 --> 00:06:41,120
nothing interesting but the thing for

00:06:38,690 --> 00:06:42,889
each tells us or gives us a future of

00:06:41,120 --> 00:06:47,870
done so that signal

00:06:42,889 --> 00:06:53,330
when it has completed so the question is

00:06:47,870 --> 00:06:55,189
why don't we see that if we report this

00:06:53,330 --> 00:06:56,569
it's a relative graph of not used and

00:06:55,189 --> 00:07:00,469
the not used comes from the source

00:06:56,569 --> 00:07:04,189
similar where have we lost our material

00:07:00,469 --> 00:07:05,719
value of the state for each well the

00:07:04,189 --> 00:07:06,439
reason why we lost it is this two

00:07:05,719 --> 00:07:10,750
Combinator

00:07:06,439 --> 00:07:15,199
the two Combinator just keeps the left

00:07:10,750 --> 00:07:19,279
materialized value so maybe we can just

00:07:15,199 --> 00:07:22,610
do a little trick and use two net of

00:07:19,279 --> 00:07:24,349
sorry - Matt is more like the same but

00:07:22,610 --> 00:07:27,349
we have to specify which materials

00:07:24,349 --> 00:07:33,590
values to keep now let's keep the right

00:07:27,349 --> 00:07:36,259
one if we look at the type now it's a

00:07:33,590 --> 00:07:38,599
render graph of putrid and gray

00:07:36,259 --> 00:07:40,819
we could also use keep both and we would

00:07:38,599 --> 00:07:43,330
get a tuple and that way we could keep

00:07:40,819 --> 00:07:47,930
or get all the material values of all

00:07:43,330 --> 00:07:51,199
the stages in a huge stream usually we

00:07:47,930 --> 00:07:53,150
are just interested in one or two so if

00:07:51,199 --> 00:07:57,710
we ran that we get this future and now

00:07:53,150 --> 00:08:00,169
we can do dot on complete regardless

00:07:57,710 --> 00:08:02,539
what it is failure or normal completion

00:08:00,169 --> 00:08:04,550
we go to the system when we terminate it

00:08:02,539 --> 00:08:10,580
hooray and we should not forget to

00:08:04,550 --> 00:08:13,909
import the almighty dispatcher we need

00:08:10,580 --> 00:08:20,810
that for the future here we go

00:08:13,909 --> 00:08:24,080
and if we run that again we will see the

00:08:20,810 --> 00:08:27,139
process has exited ray great by the way

00:08:24,080 --> 00:08:33,159
if you have questions you can ask a meta

00:08:27,139 --> 00:08:35,839
because we did the mic sorry for that so

00:08:33,159 --> 00:08:38,659
we are getting close to the solution

00:08:35,839 --> 00:08:41,959
right but so single is just creating a

00:08:38,659 --> 00:08:44,209
single element we need more than say we

00:08:41,959 --> 00:08:47,120
need seven so let's use source repeat

00:08:44,209 --> 00:08:48,800
but that creates a real stream an

00:08:47,120 --> 00:08:53,540
infinite stream okay

00:08:48,800 --> 00:08:55,120
so we have to limit that to seven could

00:08:53,540 --> 00:09:00,850
you help with that some such

00:08:55,120 --> 00:09:11,259
ah yeah thank you take of course hooray

00:09:00,850 --> 00:09:15,579
okay so try um next thing we have to do

00:09:11,259 --> 00:09:19,899
is take care of the indentation okay

00:09:15,579 --> 00:09:22,779
um any ideas how we could do that yeah

00:09:19,899 --> 00:09:27,240
we could slip with an index or something

00:09:22,779 --> 00:09:31,269
so sources or streams can be dipped

00:09:27,240 --> 00:09:33,730
um let's live it up here doesn't really

00:09:31,269 --> 00:09:37,360
matter but and that's even a liberal

00:09:33,730 --> 00:09:38,079
index but we can also sip it with

00:09:37,360 --> 00:09:42,249
another source

00:09:38,079 --> 00:09:49,959
um just to show you how we could create

00:09:42,249 --> 00:09:55,629
a source which produces deserve this

00:09:49,959 --> 00:09:59,920
okay arm and now if you look at that we

00:09:55,629 --> 00:10:06,009
have a source of string or sorry what

00:09:59,920 --> 00:10:07,290
what's wrong with a source of string in

00:10:06,009 --> 00:10:13,480
two tuples okay

00:10:07,290 --> 00:10:17,050
and we fail this we could we could not

00:10:13,480 --> 00:10:19,449
use map unfortunately this is not

00:10:17,050 --> 00:10:23,949
totally so we have to use case it's the

00:10:19,449 --> 00:10:27,389
string and that vdd be in and now we can

00:10:23,949 --> 00:10:31,059
do something wonderful say well i equals

00:10:27,389 --> 00:10:37,980
blank times and in scala we can multiply

00:10:31,059 --> 00:10:39,389
strings do that awesome and while we do

00:10:37,980 --> 00:10:43,029
s-sorry

00:10:39,389 --> 00:10:45,309
alright wonderful string interpolation

00:10:43,029 --> 00:10:53,290
almost like a boss John are you here no

00:10:45,309 --> 00:10:56,470
anyway and yeah that's it cool so

00:10:53,290 --> 00:10:59,529
there's only one piece missing which is

00:10:56,470 --> 00:11:03,600
we should print our character by

00:10:59,529 --> 00:11:05,759
character any idea how we could do that

00:11:03,600 --> 00:11:08,160
sorry

00:11:05,759 --> 00:11:12,370
totaling yeah we do that later

00:11:08,160 --> 00:11:15,519
all right yeah exactly so we have

00:11:12,370 --> 00:11:17,889
strings and we should probably map each

00:11:15,519 --> 00:11:19,930
string to all these chars the problem is

00:11:17,889 --> 00:11:22,899
strings a single element charge on

00:11:19,930 --> 00:11:25,180
multiple elements so let's see yeah

00:11:22,899 --> 00:11:29,829
exactly you know your API so there's a

00:11:25,180 --> 00:11:34,059
map concat map concat expects a let me

00:11:29,829 --> 00:11:37,540
just show it here expect function that

00:11:34,059 --> 00:11:40,860
takes string our case our to an iterable

00:11:37,540 --> 00:11:43,569
of some other type character in our case

00:11:40,860 --> 00:11:46,059
so that's perfect fit right the cool

00:11:43,569 --> 00:11:48,160
thing is scallop treats strings as

00:11:46,059 --> 00:11:50,529
sequences of characters implicitly if

00:11:48,160 --> 00:11:53,800
necessary so we even don't have to

00:11:50,529 --> 00:11:58,089
change anything well except for the fact

00:11:53,800 --> 00:12:01,509
that we lost the arm well no let me just

00:11:58,089 --> 00:12:04,959
do it like this we have a small problem

00:12:01,509 --> 00:12:07,749
which we will see here so we're printing

00:12:04,959 --> 00:12:10,209
each character so we don't do the

00:12:07,749 --> 00:12:12,579
println here but the print and now we

00:12:10,209 --> 00:12:16,689
don't have line break so we have to add

00:12:12,579 --> 00:12:20,559
a line break you're using string

00:12:16,689 --> 00:12:24,100
interpolation with the F string context

00:12:20,559 --> 00:12:26,290
and gray that well that was too fast

00:12:24,100 --> 00:12:28,779
right and you already mentioned we

00:12:26,290 --> 00:12:33,220
should throttle that thing so this is

00:12:28,779 --> 00:12:35,319
another nice feature or another nice API

00:12:33,220 --> 00:12:38,019
methods here we have the throttle we can

00:12:35,319 --> 00:12:44,740
say okay we want one element or not of

00:12:38,019 --> 00:12:47,970
course 42 per second I think I have to

00:12:44,740 --> 00:12:47,970
import duration and

00:12:54,370 --> 00:13:03,310
um and then we have to say all the

00:12:58,459 --> 00:13:06,560
maximum burst 1 and muttering mode

00:13:03,310 --> 00:13:10,130
shaping the other one is enforcing which

00:13:06,560 --> 00:13:13,730
would then fail the stream is upstream

00:13:10,130 --> 00:13:17,209
is too fast I think we are now getting

00:13:13,730 --> 00:13:21,850
there yeah cool it's just not printed at

00:13:17,209 --> 00:13:21,850
life easier in today but that's it

00:13:22,060 --> 00:13:30,139
thanks for your help guys um so um what

00:13:26,180 --> 00:13:33,680
we have a scene here is a simple example

00:13:30,139 --> 00:13:38,630
of a linear stream processing topology

00:13:33,680 --> 00:13:41,329
using sources sinks and using a couple

00:13:38,630 --> 00:13:44,990
of these built in stages like libtech

00:13:41,329 --> 00:13:47,620
map Concannon's on typically our marker

00:13:44,990 --> 00:13:50,839
streams would map each of those stages

00:13:47,620 --> 00:13:52,389
onto an actor when we are using this X

00:13:50,839 --> 00:13:56,959
materializer

00:13:52,389 --> 00:14:00,769
but by default there's an optimization

00:13:56,959 --> 00:14:04,310
turned on it's called Auto fusing so it

00:14:00,769 --> 00:14:06,230
will use all those operations into a

00:14:04,310 --> 00:14:08,810
single actor you could either turn off

00:14:06,230 --> 00:14:10,399
that in the configuration ah but I think

00:14:08,810 --> 00:14:12,010
it's a good default what you rather

00:14:10,399 --> 00:14:15,380
should do if you really want to have

00:14:12,010 --> 00:14:19,839
asynchronous boundaries in your stream

00:14:15,380 --> 00:14:23,560
are introduced those explicitly like

00:14:19,839 --> 00:14:27,860
this calling async this would now

00:14:23,560 --> 00:14:33,010
effectively map this blueprint onto

00:14:27,860 --> 00:14:37,000
actors one for those stages sorry and

00:14:33,010 --> 00:14:37,000
left ok

00:14:39,570 --> 00:14:48,470
one of the design principles of ARCA

00:14:42,540 --> 00:14:55,079
streams was to make it easy to create

00:14:48,470 --> 00:14:57,720
parts of stream processing topology they

00:14:55,079 --> 00:15:00,589
could be to for you to create sources or

00:14:57,720 --> 00:15:05,730
sings or flows and to reuse them and

00:15:00,589 --> 00:15:08,089
therefore each of those blueprints is

00:15:05,730 --> 00:15:10,259
immutable and can be freely shared

00:15:08,089 --> 00:15:13,709
because it's only the blueprint right I

00:15:10,259 --> 00:15:16,190
want to materialize it things start

00:15:13,709 --> 00:15:19,589
happening and I will start flowing and

00:15:16,190 --> 00:15:24,709
what we could also do but I don't do

00:15:19,589 --> 00:15:28,380
that live now I will just show you the

00:15:24,709 --> 00:15:32,430
final solution is that we could break

00:15:28,380 --> 00:15:37,620
the graph into reusable parts so I have

00:15:32,430 --> 00:15:40,230
split that into several random parts so

00:15:37,620 --> 00:15:42,839
this is seven lines but just the sauce

00:15:40,230 --> 00:15:45,000
repeat take seven so it has the type

00:15:42,839 --> 00:15:48,870
source of string I've used here I have

00:15:45,000 --> 00:15:51,990
defined a flow and I have taken seven

00:15:48,870 --> 00:15:52,880
lines via this flow so B is not a

00:15:51,990 --> 00:15:57,690
Combinator

00:15:52,880 --> 00:16:02,370
- well yet combined source and a flow so

00:15:57,690 --> 00:16:05,990
that has type string char not user flow

00:16:02,370 --> 00:16:09,209
that take strings and as an input and

00:16:05,990 --> 00:16:12,690
Whopper to have chars and finally print

00:16:09,209 --> 00:16:15,720
throttled is a sink um so it's flow

00:16:12,690 --> 00:16:19,279
throttle and then to Matt with this

00:16:15,720 --> 00:16:22,589
thing for each and yeah we can then

00:16:19,279 --> 00:16:24,839
reuse those components or you can use

00:16:22,589 --> 00:16:31,410
them like we did here but we could reuse

00:16:24,839 --> 00:16:34,980
it throughout our code base alright this

00:16:31,410 --> 00:16:37,589
is the flow API this is the API to

00:16:34,980 --> 00:16:39,420
define lunar stream processing

00:16:37,589 --> 00:16:42,209
topologies which is probably what you

00:16:39,420 --> 00:16:48,650
need in in most of the cases 80% I don't

00:16:42,209 --> 00:16:52,670
know but sometimes um you wanna write

00:16:48,650 --> 00:16:57,380
stream topology that is more complicated

00:16:52,670 --> 00:17:02,990
and rocket screams allows you to do that

00:16:57,380 --> 00:17:05,920
it has another API the graph API and

00:17:02,990 --> 00:17:09,650
when you use this graphic API you can

00:17:05,920 --> 00:17:12,950
build almost random graph even having

00:17:09,650 --> 00:17:16,940
cycles so I want to show you that but

00:17:12,950 --> 00:17:18,860
before that I would like to say that

00:17:16,940 --> 00:17:21,110
even if you use the flow API under the

00:17:18,860 --> 00:17:25,940
hood everything is represented as graph

00:17:21,110 --> 00:17:33,440
okay so this is like the one shop API

00:17:25,940 --> 00:17:42,590
for the linear stuff so the other use

00:17:33,440 --> 00:17:45,080
case I have for you guys is an access

00:17:42,590 --> 00:17:48,230
lock for HTTP server written without

00:17:45,080 --> 00:17:50,930
HTTP so last week I was that declined

00:17:48,230 --> 00:17:53,750
and they were asking me okay Aachen HTTP

00:17:50,930 --> 00:17:56,060
that the HCP so or why doesn't write an

00:17:53,750 --> 00:17:57,620
access look like Apache I said oh wait a

00:17:56,060 --> 00:17:59,450
moment actually peace just a library and

00:17:57,620 --> 00:18:01,910
you can use it to build an HTP server

00:17:59,450 --> 00:18:05,930
but because it's library doesn't have an

00:18:01,910 --> 00:18:07,310
axe log built in um and I started

00:18:05,930 --> 00:18:12,580
thinking and I said it should be

00:18:07,310 --> 00:18:12,580
probably pretty easy to implement um and

00:18:13,180 --> 00:18:21,200
who knows akka HTTP okay many almost

00:18:18,680 --> 00:18:22,520
most that's great so um for those who

00:18:21,200 --> 00:18:24,230
don't know I think it's not terribly

00:18:22,520 --> 00:18:26,300
complicated to understand what I'm going

00:18:24,230 --> 00:18:28,190
to show so I not gonna actually PU

00:18:26,300 --> 00:18:31,370
invoke this bind and handle method with

00:18:28,190 --> 00:18:34,220
an interface and port for the socket and

00:18:31,370 --> 00:18:38,120
a route which is the handler for

00:18:34,220 --> 00:18:42,470
handling requests it's a flow from

00:18:38,120 --> 00:18:45,140
request to response okay so it is

00:18:42,470 --> 00:18:49,160
defined in this method in this example

00:18:45,140 --> 00:18:53,590
here using directives yeah pretty into

00:18:49,160 --> 00:18:56,990
DSL to define those flows as a route and

00:18:53,590 --> 00:18:58,179
the bind and handle method as I said

00:18:56,990 --> 00:19:00,490
expect

00:18:58,179 --> 00:19:03,070
a handler which is a flow from request

00:19:00,490 --> 00:19:07,570
response so I started thinking it should

00:19:03,070 --> 00:19:13,119
be possible to wrap the handler in a

00:19:07,570 --> 00:19:15,429
larger flow which has a step before the

00:19:13,119 --> 00:19:18,820
request is moved into the handler and a

00:19:15,429 --> 00:19:22,629
step or a stage which is applied after

00:19:18,820 --> 00:19:25,749
to all the responses right so I came up

00:19:22,629 --> 00:19:33,309
with with that idea here now where is it

00:19:25,749 --> 00:19:39,340
that was not the demo sorry it's go I

00:19:33,309 --> 00:19:41,830
came up with that idea for a graph okay

00:19:39,340 --> 00:19:44,799
so if you look at that shape of the

00:19:41,830 --> 00:19:49,690
whole graph its flow because it has an

00:19:44,799 --> 00:19:52,869
inlet and an outlet and within that

00:19:49,690 --> 00:19:55,990
graph with a couple of stages so here we

00:19:52,869 --> 00:20:00,549
have a broadcast stage which takes

00:19:55,990 --> 00:20:04,929
requests and broadcasts the request to

00:20:00,549 --> 00:20:07,240
to our downstream stages so one goes to

00:20:04,929 --> 00:20:10,059
the handler of the requests and from the

00:20:07,240 --> 00:20:14,249
handler it goes to another broadcast the

00:20:10,059 --> 00:20:17,499
other broadcast for the responsive emits

00:20:14,249 --> 00:20:22,409
elements through the outlet of the

00:20:17,499 --> 00:20:25,600
overall flow but also to a zip state

00:20:22,409 --> 00:20:27,700
request goes to another flow which

00:20:25,600 --> 00:20:31,419
enriches it so we could add a timestamp

00:20:27,700 --> 00:20:33,490
or something here and feed it to the SIP

00:20:31,419 --> 00:20:37,299
stage too and then here we have our

00:20:33,490 --> 00:20:39,789
access log let's sink for in which

00:20:37,299 --> 00:20:42,429
requests and responses so in the

00:20:39,789 --> 00:20:48,279
simplest case you would just write stuff

00:20:42,429 --> 00:20:50,440
to a log like in this demo here we want

00:20:48,279 --> 00:20:52,749
to be able to do route with access log

00:20:50,440 --> 00:20:54,340
this is a function enriching the request

00:20:52,749 --> 00:20:57,279
so it's tooling up the request with

00:20:54,340 --> 00:20:59,259
timestamp and then we say access log and

00:20:57,279 --> 00:21:02,649
that's just a think it's a sink as you

00:20:59,259 --> 00:21:05,740
can see here R which takes the request

00:21:02,649 --> 00:21:10,450
and timestamp tuples plus the response

00:21:05,740 --> 00:21:11,380
in another out tuple and writes log the

00:21:10,450 --> 00:21:15,280
method

00:21:11,380 --> 00:21:18,429
the status and the time in micros but

00:21:15,280 --> 00:21:22,690
that makes sense so the only question is

00:21:18,429 --> 00:21:26,070
how can we write that nice graph because

00:21:22,690 --> 00:21:32,590
it's not yet written and let's try that

00:21:26,070 --> 00:21:35,620
so in order to do that we need to use

00:21:32,590 --> 00:21:39,280
the flow so it the graph API so we

00:21:35,620 --> 00:21:40,720
create a flow dot from graph that's the

00:21:39,280 --> 00:21:43,330
appear to do that because we want to

00:21:40,720 --> 00:21:46,929
have a flow at the end of the day here

00:21:43,330 --> 00:21:52,900
we have to use the graph DSL we have a

00:21:46,929 --> 00:21:57,940
create method on it and so we'll create

00:21:52,900 --> 00:22:00,250
method on it which so here we have an

00:21:57,940 --> 00:22:03,720
our axis lock the X log stock type alias

00:22:00,250 --> 00:22:12,880
for a sink which takes the imaged our

00:22:03,720 --> 00:22:15,159
request and the response so the first

00:22:12,880 --> 00:22:17,230
thing we need to provide as a one or

00:22:15,159 --> 00:22:22,030
argument to the create method is a

00:22:17,230 --> 00:22:25,150
function that takes a builder and in

00:22:22,030 --> 00:22:27,100
this case we also have to give it back

00:22:25,150 --> 00:22:29,500
the access log that's just a detail I

00:22:27,100 --> 00:22:31,240
don't want to dive into that and let's

00:22:29,500 --> 00:22:33,280
make the compiler happy by adding a

00:22:31,240 --> 00:22:36,370
couple of question marks it's always

00:22:33,280 --> 00:22:40,150
important thank you so what we should

00:22:36,370 --> 00:22:46,840
return from that method is the shape and

00:22:40,150 --> 00:22:50,049
ah we want to return a flow shape okay a

00:22:46,840 --> 00:22:54,850
flow shape has an inlet and an outlet we

00:22:50,049 --> 00:22:56,559
don't yet know what they are but from

00:22:54,850 --> 00:22:58,929
looking at this picture here we can

00:22:56,559 --> 00:23:01,840
already tell that we probably want to

00:22:58,929 --> 00:23:06,280
add broadcast our stage to that graph

00:23:01,840 --> 00:23:12,070
and if let's begin first we also have to

00:23:06,280 --> 00:23:17,590
import the graph DSL enclose it and then

00:23:12,070 --> 00:23:18,279
we can get started so ya see that

00:23:17,590 --> 00:23:23,099
so for

00:23:18,279 --> 00:23:26,799
let's add this broadcast request to our

00:23:23,099 --> 00:23:33,369
graph by using the Builder so the

00:23:26,799 --> 00:23:36,909
Builder is immutable builder and feed is

00:23:33,369 --> 00:23:38,710
only mutated as long so winner so we

00:23:36,909 --> 00:23:41,769
know the bill is immutable but it

00:23:38,710 --> 00:23:43,509
produces an immutable fill so produces a

00:23:41,769 --> 00:23:49,289
blueprint which can be freely shared

00:23:43,509 --> 00:23:59,619
again so we want to add a broadcast and

00:23:49,289 --> 00:24:00,909
the broadcast is if you look here define

00:23:59,619 --> 00:24:03,219
using the apply methods we have to

00:24:00,909 --> 00:24:06,700
provide the type of the elements it's a

00:24:03,219 --> 00:24:09,070
uniform fan-out shape it emits the same

00:24:06,700 --> 00:24:13,679
elements to all its outlets we have to

00:24:09,070 --> 00:24:18,159
define number so the type of element

00:24:13,679 --> 00:24:22,929
that is HTTP request right okay and we

00:24:18,159 --> 00:24:25,440
won't have two outlets good so we can

00:24:22,929 --> 00:24:30,339
then already use this broadcast request

00:24:25,440 --> 00:24:32,830
stage and use it in that to connect it

00:24:30,339 --> 00:24:37,619
so this is the first connection we are

00:24:32,830 --> 00:24:46,330
drawing okay um we also have another

00:24:37,619 --> 00:24:50,440
broadcast response that was easy we have

00:24:46,330 --> 00:24:55,659
our Handler and some other stuff so

00:24:50,440 --> 00:24:58,029
let's start drawing a graph oh sorry

00:24:55,659 --> 00:25:03,159
the block has weak response can also be

00:24:58,029 --> 00:25:06,460
used of course to connect it if it's all

00:25:03,159 --> 00:25:09,509
red so we have to say broadcast we like

00:25:06,460 --> 00:25:17,469
zero one doesn't really matter so to

00:25:09,509 --> 00:25:20,559
connect it to the flow shape arm in

00:25:17,469 --> 00:25:24,549
order to connect those various stages

00:25:20,559 --> 00:25:26,919
within the graph we could use normal

00:25:24,549 --> 00:25:29,080
methods like add edge I even don't know

00:25:26,919 --> 00:25:31,909
the exact names of those methods but we

00:25:29,080 --> 00:25:33,979
can use a very nice operator based

00:25:31,909 --> 00:25:36,769
syntax that's what I'm going to show you

00:25:33,979 --> 00:25:40,489
now so if you want to connect the

00:25:36,769 --> 00:25:43,309
broadcast request with the handler we

00:25:40,489 --> 00:25:50,089
can do it the following way broadcast

00:25:43,309 --> 00:25:56,199
request dot out zero arrow and or okay

00:25:50,089 --> 00:25:56,199
and think me an illicit builder here

00:25:56,529 --> 00:26:03,019
okay cool um so that at the edge that

00:26:01,279 --> 00:26:05,569
adds the connection between the

00:26:03,019 --> 00:26:10,339
broadcast across stage and the handler

00:26:05,569 --> 00:26:12,709
stage and as you can probably guess we

00:26:10,339 --> 00:26:17,440
can continue from the handler to

00:26:12,709 --> 00:26:22,159
broadcast response so we have already

00:26:17,440 --> 00:26:24,829
infant disappear cool um next thing you

00:26:22,159 --> 00:26:28,759
need to do is in which request so that

00:26:24,829 --> 00:26:32,749
is a flow that applies the given

00:26:28,759 --> 00:26:34,849
function here from a request to a so

00:26:32,749 --> 00:26:38,149
let's at that well in which across

00:26:34,849 --> 00:26:45,259
equals builder ad but we need to add a

00:26:38,149 --> 00:26:48,829
flow taking requests and we met a graph

00:26:45,259 --> 00:26:52,429
okay so the type of this thing is flow

00:26:48,829 --> 00:26:57,559
shape of a GPU crest to a so what we can

00:26:52,429 --> 00:27:02,389
do now is we can say okay we connect the

00:26:57,559 --> 00:27:09,739
other outlet of this thing here so our

00:27:02,389 --> 00:27:16,789
flow which requests great we finally

00:27:09,739 --> 00:27:20,479
need the SIP stage of filter that add we

00:27:16,789 --> 00:27:25,039
need to add a lip lip is not a uniform

00:27:20,479 --> 00:27:26,629
fan in our heed as to cut so I think in

00:27:25,039 --> 00:27:31,339
this case depending on how we want to

00:27:26,629 --> 00:27:34,099
zip it I think I forgot it damn on so

00:27:31,339 --> 00:27:37,219
let's say the first element is this one

00:27:34,099 --> 00:27:39,679
here the a which comes from the rich

00:27:37,219 --> 00:27:42,519
request flow and the other one is the

00:27:39,679 --> 00:27:42,519
HTTP response

00:27:44,029 --> 00:27:53,690
yeah great so once we do that we can say

00:27:48,049 --> 00:27:57,409
okay feed that into zip dot in zero

00:27:53,690 --> 00:27:59,899
that's the inlet for the a great and

00:27:57,409 --> 00:28:06,879
then we also need to feed something else

00:27:59,899 --> 00:28:12,109
into the lip then one mainly the our

00:28:06,879 --> 00:28:14,210
broadcast response dot out one okay

00:28:12,109 --> 00:28:17,119
because we have already used the out

00:28:14,210 --> 00:28:19,999
zero to stream elements to the outlet of

00:28:17,119 --> 00:28:25,309
the flow shape so therefore they

00:28:19,999 --> 00:28:26,809
connected with zip this way okay I mean

00:28:25,309 --> 00:28:28,339
this looks a little bit like like a

00:28:26,809 --> 00:28:30,409
cycle so you can see you can use

00:28:28,339 --> 00:28:32,089
operators in both directions that's

00:28:30,409 --> 00:28:34,190
pretty neat in this case I wouldn't even

00:28:32,089 --> 00:28:37,460
do it because it's not a cycle

00:28:34,190 --> 00:28:41,989
so it's maybe confusing so instead we

00:28:37,460 --> 00:28:45,169
can do that a block because grass is

00:28:41,989 --> 00:28:49,159
here so maybe to make it nice we can put

00:28:45,169 --> 00:28:50,989
it up there with like this I don't know

00:28:49,159 --> 00:28:53,690
I will later show this absolutely our

00:28:50,989 --> 00:28:55,549
sourcing is very nicely followed it so I

00:28:53,690 --> 00:28:58,369
think there's only one thing missing arm

00:28:55,549 --> 00:29:00,440
yeah and that is here the access log we

00:28:58,369 --> 00:29:05,599
need to connect connected to dip so

00:29:00,440 --> 00:29:08,989
let's say that dot out connected to the

00:29:05,599 --> 00:29:13,899
access log that is given up here at the

00:29:08,989 --> 00:29:19,369
program over a since we're great arm

00:29:13,899 --> 00:29:21,469
yeah that's a neat graph that does its

00:29:19,369 --> 00:29:25,700
job just let me show you that it's

00:29:21,469 --> 00:29:26,929
really working um I better undo my

00:29:25,700 --> 00:29:36,859
changes and show you the sample

00:29:26,929 --> 00:29:37,330
solutions as I just said okay so in the

00:29:36,859 --> 00:29:40,000
samples

00:29:37,330 --> 00:29:44,040
lucien i have tried to make it a live

00:29:40,000 --> 00:29:50,100
look a little nicer to really resemble

00:29:44,040 --> 00:29:52,540
this drawing it's not always possible

00:29:50,100 --> 00:29:55,600
perfect fashion but yeah hopefully I

00:29:52,540 --> 00:29:58,240
wasn't too bad at that so you can see

00:29:55,600 --> 00:30:00,340
from the broadcast request week let's

00:29:58,240 --> 00:30:02,020
flow to the handler and to in which

00:30:00,340 --> 00:30:06,070
request and from there to reserve and

00:30:02,020 --> 00:30:19,960
enter answer ok um so when we run that

00:30:06,070 --> 00:30:23,680
oh maybe I run it in the console that

00:30:19,960 --> 00:30:28,990
makes the most sense okay I'm running it

00:30:23,680 --> 00:30:36,490
here ok cool listening so if we send

00:30:28,990 --> 00:30:40,390
some HTP requests we should see the

00:30:36,490 --> 00:30:44,070
access log up here method path status

00:30:40,390 --> 00:30:44,070
code and so on

00:30:45,330 --> 00:30:47,100
great

00:30:46,510 --> 00:30:52,019
it's

00:30:47,100 --> 00:30:54,630
and interestingly I haven't found

00:30:52,019 --> 00:30:57,690
something like this mini library or

00:30:54,630 --> 00:30:59,490
Micro library in the interwebs so far so

00:30:57,690 --> 00:31:01,740
I have created an open-source project

00:30:59,490 --> 00:31:04,860
you can use it it's called accesses if

00:31:01,740 --> 00:31:07,529
you think that's useful it's a micro

00:31:04,860 --> 00:31:13,970
library micro all the things right but

00:31:07,529 --> 00:31:17,490
the whole that's really a whole code

00:31:13,970 --> 00:31:20,100
okay cool um so we still have ten

00:31:17,490 --> 00:31:22,169
minutes I would like to show you one

00:31:20,100 --> 00:31:24,269
more example of an even more powerful

00:31:22,169 --> 00:31:28,950
graphical initially I told you that

00:31:24,269 --> 00:31:30,690
grass could even have cycles um don't

00:31:28,950 --> 00:31:35,179
worry we don't have to code that

00:31:30,690 --> 00:31:40,320
ourselves that would be too hard

00:31:35,179 --> 00:31:46,409
um I will show you a neat little example

00:31:40,320 --> 00:31:48,539
um so in aachen HTP there is support for

00:31:46,409 --> 00:31:51,000
service and events you know service and

00:31:48,539 --> 00:31:52,620
event a couple of you it's almost like

00:31:51,000 --> 00:31:54,600
what WebSockets but only in one

00:31:52,620 --> 00:32:02,090
direction from the server to the client

00:31:54,600 --> 00:32:02,090
and let me stop that and

00:32:07,530 --> 00:32:26,540
Oh Stark sorry cool now we have a server

00:32:16,730 --> 00:32:29,490
which oh I don't know the URL sorry so

00:32:26,540 --> 00:32:31,740
with a server that produces the service

00:32:29,490 --> 00:32:34,080
and events ok and here we have another

00:32:31,740 --> 00:32:37,700
program which ones consume those service

00:32:34,080 --> 00:32:43,170
and events and in order to that

00:32:37,700 --> 00:32:48,810
acha no alpaca the candle Don right

00:32:43,170 --> 00:32:50,220
version of vodka has connector for

00:32:48,810 --> 00:32:53,040
source and event that's called event

00:32:50,220 --> 00:32:55,680
source and that has to be given at your

00:32:53,040 --> 00:32:58,440
eye to connect to the HP server to get

00:32:55,680 --> 00:33:03,060
the source of certain events a way to

00:32:58,440 --> 00:33:06,570
send requests it can start with a last

00:33:03,060 --> 00:33:08,040
event ID it's optional and here that's

00:33:06,570 --> 00:33:11,730
the most important one is a reconnect

00:33:08,040 --> 00:33:14,310
delay in case connections are are

00:33:11,730 --> 00:33:20,900
interrupted or just completed by the

00:33:14,310 --> 00:33:20,900
server so if we are if we run this here

00:33:23,270 --> 00:33:31,680
we will see the following hopefully oh

00:33:25,980 --> 00:33:35,400
yeah ok cool so you can see that for

00:33:31,680 --> 00:33:39,720
each println we get a service events

00:33:35,400 --> 00:33:43,770
these are case classes and we start with

00:33:39,720 --> 00:33:47,130
43 because the the last we told the

00:33:43,770 --> 00:33:51,390
server we had seen was 42 perfect number

00:33:47,130 --> 00:33:54,120
right and what you also notice here is

00:33:51,390 --> 00:33:58,020
that after 10 elements there's a delay

00:33:54,120 --> 00:34:01,670
like 82 here three second delay so this

00:33:58,020 --> 00:34:04,710
server is not really giving us a

00:34:01,670 --> 00:34:06,630
continuous source of events but it just

00:34:04,710 --> 00:34:09,870
gives us ten and then we have to

00:34:06,630 --> 00:34:16,649
reconnect um and this lovely does it and

00:34:09,870 --> 00:34:17,030
we can even stop the server and then no

00:34:16,649 --> 00:34:19,970
more

00:34:17,030 --> 00:34:24,770
meant to print it down here of course we

00:34:19,970 --> 00:34:27,470
started again and this event source

00:34:24,770 --> 00:34:29,810
Klein is retrying or every three seconds

00:34:27,470 --> 00:34:34,000
and you can see it continues as soon as

00:34:29,810 --> 00:34:38,360
the server's up again um so this is

00:34:34,000 --> 00:34:40,400
quite nice to integrate or integration

00:34:38,360 --> 00:34:42,230
of micro services for example and what I

00:34:40,400 --> 00:34:44,210
would like to show you is how one can

00:34:42,230 --> 00:34:47,690
implement such an event source which we

00:34:44,210 --> 00:34:51,740
tries to get stuff from the HCP server

00:34:47,690 --> 00:34:55,340
and that is a quote from the alpaca

00:34:51,740 --> 00:34:57,650
project so again we write something

00:34:55,340 --> 00:35:01,100
using the graph DSL in this case it's a

00:34:57,650 --> 00:35:03,040
source not a flow but yeah it looks very

00:35:01,100 --> 00:35:06,740
similar to what you have seen before and

00:35:03,040 --> 00:35:10,430
here this is like the essence we have a

00:35:06,740 --> 00:35:12,410
graph that that has a cycle so you can

00:35:10,430 --> 00:35:16,130
see that something flows from here to

00:35:12,410 --> 00:35:17,840
emerge to another flow to broadcast and

00:35:16,130 --> 00:35:21,830
from the broadcast it goes to that flow

00:35:17,840 --> 00:35:24,140
but also to back in a cycle via that

00:35:21,830 --> 00:35:27,500
flow via that flow to the merge or

00:35:24,140 --> 00:35:31,670
here's even a nice picture but that's

00:35:27,500 --> 00:35:35,600
too much anyway almost so I'm it if I

00:35:31,670 --> 00:35:37,640
close can see here and nothing special

00:35:35,600 --> 00:35:41,150
needs to be done as you can see down

00:35:37,640 --> 00:35:43,310
there to implement the graph our little

00:35:41,150 --> 00:35:47,240
cycle you just need to connect the

00:35:43,310 --> 00:35:49,490
various shapes in the way that is

00:35:47,240 --> 00:35:50,960
necessary of course you need to be pay

00:35:49,490 --> 00:35:53,360
attention to cycles because you can

00:35:50,960 --> 00:35:55,790
either use deadlocks or something which

00:35:53,360 --> 00:35:57,800
hopefully is not the case in this graph

00:35:55,790 --> 00:35:59,330
here I don't want to dive into the

00:35:57,800 --> 00:36:05,860
details if you're interested just check

00:35:59,330 --> 00:36:09,890
it out it's on alpaca SSD collector and

00:36:05,860 --> 00:36:11,900
that's it most ylides sorry for that

00:36:09,890 --> 00:36:13,430
thanks for your help with the coding and

00:36:11,900 --> 00:36:18,260
I think we still have a couple of

00:36:13,430 --> 00:36:20,660
minutes for questions so once once this

00:36:18,260 --> 00:36:24,530
is compiled and you have the nice little

00:36:20,660 --> 00:36:25,970
drawing up top from from the code do is

00:36:24,530 --> 00:36:28,730
there enough information in that

00:36:25,970 --> 00:36:30,920
bytecode to produce the drawing or some

00:36:28,730 --> 00:36:33,710
of that kind of loss at that point

00:36:30,920 --> 00:36:35,810
no I had to do that drawing manually but

00:36:33,710 --> 00:36:39,320
input but I know that you did that but

00:36:35,810 --> 00:36:41,240
it does the in-memory model contain

00:36:39,320 --> 00:36:42,020
enough detail that you could yeah

00:36:41,240 --> 00:36:45,920
probably

00:36:42,020 --> 00:36:50,270
okay thanks oh I have a question

00:36:45,920 --> 00:36:54,020
regarding the graph you showed regarding

00:36:50,270 --> 00:36:58,220
the access log so given the at most once

00:36:54,020 --> 00:37:03,340
delivery semantics in Hakka I think you

00:36:58,220 --> 00:37:05,900
might end up zipping wrong requests and

00:37:03,340 --> 00:37:09,110
like what wrong requests with wrong

00:37:05,900 --> 00:37:10,280
answers in the zip operator how would

00:37:09,110 --> 00:37:14,060
you go about that

00:37:10,280 --> 00:37:16,580
about very good question so I don't

00:37:14,060 --> 00:37:18,860
think it's you just mentioned at least

00:37:16,580 --> 00:37:20,710
okay at least once they deliver

00:37:18,860 --> 00:37:26,960
guarantee yeah that's a good point but

00:37:20,710 --> 00:37:29,630
looking at the actual API in question we

00:37:26,960 --> 00:37:32,560
are dealing with the bind and handle

00:37:29,630 --> 00:37:38,060
which expects a flow from request to

00:37:32,560 --> 00:37:46,250
response now when I haven't told you is

00:37:38,060 --> 00:37:49,000
that our HTTP materializes a sub flow

00:37:46,250 --> 00:37:52,370
for each connection so per connection

00:37:49,000 --> 00:37:57,410
subset handler is materialized or run

00:37:52,370 --> 00:38:01,190
and the HCP protocol demands or 5061 one

00:37:57,410 --> 00:38:06,500
demands that ah there's a strict

00:38:01,190 --> 00:38:09,140
ordering so what I did here is valid but

00:38:06,500 --> 00:38:15,050
this is not valid in general so if you

00:38:09,140 --> 00:38:16,580
have a flow elements which oh that's

00:38:15,050 --> 00:38:19,880
putting other way the sequence of

00:38:16,580 --> 00:38:22,190
elements that flow into that flow may

00:38:19,880 --> 00:38:24,500
not be the same sequence that flows all

00:38:22,190 --> 00:38:26,570
over flow in general so that could

00:38:24,500 --> 00:38:29,900
happen in general but not in the case of

00:38:26,570 --> 00:38:33,640
HTTP so if this would happen before a

00:38:29,900 --> 00:38:33,640
bug in our case DP

00:38:36,190 --> 00:38:46,390
okay up there two questions yes I have a

00:38:40,809 --> 00:38:47,859
question about the state in graphs so I

00:38:46,390 --> 00:38:51,640
had a problem where I wanted to

00:38:47,859 --> 00:38:53,980
implement a TCP protocol which started

00:38:51,640 --> 00:38:56,650
off with a marker what kind of message

00:38:53,980 --> 00:39:01,030
was in the payload was of a different

00:38:56,650 --> 00:39:04,089
size and I had a really hard time to get

00:39:01,030 --> 00:39:07,329
working in a graph so that the general

00:39:04,089 --> 00:39:10,809
question is how would you keep state to

00:39:07,329 --> 00:39:13,720
sort of and become different types of

00:39:10,809 --> 00:39:15,789
flows within the graph I ended up

00:39:13,720 --> 00:39:18,359
building a custom stage and then is

00:39:15,789 --> 00:39:22,660
curious if there's any a smart way to

00:39:18,359 --> 00:39:24,670
handle these problems um so using a

00:39:22,660 --> 00:39:26,710
custom state is certainly a smart way to

00:39:24,670 --> 00:39:29,410
handle that problem I have done that

00:39:26,710 --> 00:39:32,730
several times but of course preferable

00:39:29,410 --> 00:39:36,579
to use the building stages if that's

00:39:32,730 --> 00:39:39,670
enough for a phase well serve the

00:39:36,579 --> 00:39:41,829
purpose so maybe it all depends on how

00:39:39,670 --> 00:39:45,039
complicated your problem is so there's a

00:39:41,829 --> 00:39:48,849
stateful map contact for example it's a

00:39:45,039 --> 00:39:51,190
built in stage which well stateful can

00:39:48,849 --> 00:39:54,460
accumulate state or commutable state

00:39:51,190 --> 00:39:58,150
okay so maybe give that a try that's not

00:39:54,460 --> 00:40:00,430
enough write your own graph state which

00:39:58,150 --> 00:40:04,589
is not too hard in my opinion it's a

00:40:00,430 --> 00:40:04,589
good API Thanks

00:40:09,220 --> 00:40:14,470
just a question about how do you handle

00:40:11,319 --> 00:40:16,390
two things after broadcast where one

00:40:14,470 --> 00:40:18,430
thing is becoming significantly slower

00:40:16,390 --> 00:40:20,529
than the other and you basically want to

00:40:18,430 --> 00:40:22,180
make sure that the fasting is one that

00:40:20,529 --> 00:40:24,490
gets the data so that you start dropping

00:40:22,180 --> 00:40:26,410
when you're like going beyond 80 percent

00:40:24,490 --> 00:40:27,670
of the speed of the other thing you want

00:40:26,410 --> 00:40:29,200
to start dropping so you're not

00:40:27,670 --> 00:40:31,510
interested that's the second thing which

00:40:29,200 --> 00:40:33,039
is always the best effort that you

00:40:31,510 --> 00:40:34,990
really like you have to broadcast so

00:40:33,039 --> 00:40:37,960
normally I think it will result in

00:40:34,990 --> 00:40:40,150
slowing down the whole graph so but I

00:40:37,960 --> 00:40:42,279
want like one thing to be like a primary

00:40:40,150 --> 00:40:44,260
sync and the secondary sync to be a best

00:40:42,279 --> 00:40:47,289
effort and like at the moment when it's

00:40:44,260 --> 00:40:49,900
dropping down to 50% start ignoring okay

00:40:47,289 --> 00:40:51,640
I would do that okay so that's various

00:40:49,900 --> 00:40:54,820
building stages which you can use to

00:40:51,640 --> 00:40:57,820
decouple the speeds of upstream and

00:40:54,820 --> 00:41:00,520
downstream so in this case Wow how they

00:40:57,820 --> 00:41:02,140
call is it called conflate victor is

00:41:00,520 --> 00:41:03,430
called conflate oh he's not people to

00:41:02,140 --> 00:41:08,330
pay attention um

00:41:03,430 --> 00:41:08,330
[Laughter]

00:41:08,460 --> 00:41:14,080
okay let me just check that so there's a

00:41:11,290 --> 00:41:15,640
conflict state allow a faster upstream

00:41:14,080 --> 00:41:18,100
to progress independent evil oh yeah

00:41:15,640 --> 00:41:20,830
that would be one so we fix it with that

00:41:18,100 --> 00:41:25,780
stage that accumulates everything maybe

00:41:20,830 --> 00:41:28,840
calculates the bushmeat average average

00:41:25,780 --> 00:41:30,970
thank you or whatever and then the slow

00:41:28,840 --> 00:41:33,460
thing can consume the average once it is

00:41:30,970 --> 00:41:35,860
ready to do that okay and then it's a

00:41:33,460 --> 00:41:38,260
couple of others okay so I'm running out

00:41:35,860 --> 00:41:40,660
of time um I'll be around so if you're

00:41:38,260 --> 00:41:44,020
interested to talk about it just find me

00:41:40,660 --> 00:41:45,970
somewhere I don't want to stand between

00:41:44,020 --> 00:41:49,380
you and lunch so thanks for your

00:41:45,970 --> 00:41:49,380
attention until the service

00:41:50,570 --> 00:41:55,239

YouTube URL: https://www.youtube.com/watch?v=ryxrWVI3PMA


