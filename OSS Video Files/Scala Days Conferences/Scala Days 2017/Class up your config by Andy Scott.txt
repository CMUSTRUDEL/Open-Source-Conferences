Title: Class up your config by Andy Scott
Publication date: 2017-06-23
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Configuring production applications is a conceptually simple task that sometimes winds up being a lot of work. It shouldn't be this way.

Case classy is a small library that makes part of this process easier. Case classy makes loading and decoding configuration data—usually strings—much easier. It prevents all-or-nothing runtime errors and instead provides a rich and comprehensive error data type for when this process goes wrong.

In this talk we will introduce Case Classy, showing how to use it and its benefits over other configuration libraries. We will dive into the functional programming foundations and how this enables us to assemble and combine decoders so that errors accumulate. And we will look at how Shapeless and generic programming can automatically assemble decoders for us and save us from an abyss of boilerplate
Captions: 
	00:00:05,130 --> 00:00:10,900
so this is class up your config and I'm

00:00:08,260 --> 00:00:14,080
Andy Scott I'm a senior software

00:00:10,900 --> 00:00:17,830
engineer with 47 degrees we're a global

00:00:14,080 --> 00:00:20,169
consulting firm in the UK Spain as well

00:00:17,830 --> 00:00:23,890
as the United States and I'm from

00:00:20,169 --> 00:00:25,539
Seattle so with the u.s. office we're

00:00:23,890 --> 00:00:27,730
also the ones responsible for a lot of

00:00:25,539 --> 00:00:29,259
the conference t-shirts so if you

00:00:27,730 --> 00:00:31,689
haven't gotten one and you happen to be

00:00:29,259 --> 00:00:33,579
one of the smaller sizes I think we

00:00:31,689 --> 00:00:36,160
still have some left so you can head on

00:00:33,579 --> 00:00:39,489
over to our bread booth in the far area

00:00:36,160 --> 00:00:41,379
of the Commons so that was that out of

00:00:39,489 --> 00:00:43,539
the way again it's this class if your

00:00:41,379 --> 00:00:46,149
config we're going to discuss a open

00:00:43,539 --> 00:00:47,320
source project 47° project it's called

00:00:46,149 --> 00:00:49,269
case classy

00:00:47,320 --> 00:00:52,210
and it's a library centered around

00:00:49,269 --> 00:00:56,489
decoding data specifically configuration

00:00:52,210 --> 00:00:58,719
data so goals we're going to talk about

00:00:56,489 --> 00:01:00,999
the problem that we're trying to solve I

00:00:58,719 --> 00:01:03,309
just touched on it briefly the decoding

00:01:00,999 --> 00:01:06,070
data we're going to learn about arrows

00:01:03,309 --> 00:01:08,620
and some functional programming concepts

00:01:06,070 --> 00:01:10,120
we'll talk about them briefly I'm not

00:01:08,620 --> 00:01:12,580
going to go into too much detail and

00:01:10,120 --> 00:01:14,050
then you'll see these concepts show up

00:01:12,580 --> 00:01:18,280
throughout the talk or throughout the

00:01:14,050 --> 00:01:19,780
code that we kind of dive into we're

00:01:18,280 --> 00:01:21,850
going to derive or build a solution

00:01:19,780 --> 00:01:24,550
using case classes so we're going to go

00:01:21,850 --> 00:01:27,510
through what it takes to implement some

00:01:24,550 --> 00:01:30,130
functionality using this library and

00:01:27,510 --> 00:01:33,400
then at the very end there's a little

00:01:30,130 --> 00:01:34,860
bit of review in some final notes so

00:01:33,400 --> 00:01:39,730
what's the problem

00:01:34,860 --> 00:01:41,590
e we have configuration data or at least

00:01:39,730 --> 00:01:43,680
for production applications or services

00:01:41,590 --> 00:01:45,370
that we deploy there's frequently

00:01:43,680 --> 00:01:47,410
configuration data that you have to

00:01:45,370 --> 00:01:49,990
lower that we load at the beginning of

00:01:47,410 --> 00:01:51,520
our application startup frequently it

00:01:49,990 --> 00:01:55,060
looks something like this

00:01:51,520 --> 00:01:57,340
maybe it's usually text typically

00:01:55,060 --> 00:01:59,320
structured text but it comes in and

00:01:57,340 --> 00:02:02,650
string form or some kind of unstructured

00:01:59,320 --> 00:02:04,120
form and it can contain all different

00:02:02,650 --> 00:02:05,830
kinds of values that we want to

00:02:04,120 --> 00:02:08,920
different things we want to do stuff

00:02:05,830 --> 00:02:11,260
with those values here's another example

00:02:08,920 --> 00:02:13,420
this is actually from Scala exercises

00:02:11,260 --> 00:02:16,120
and in some cases our configuration may

00:02:13,420 --> 00:02:18,040
contain environment variables or

00:02:16,120 --> 00:02:20,890
sensitive information like the database

00:02:18,040 --> 00:02:23,620
information in that user and password

00:02:20,890 --> 00:02:25,980
victims were redacted and drop dropped

00:02:23,620 --> 00:02:28,630
in some dummy versions don't try that

00:02:25,980 --> 00:02:30,280
and then a case we will override

00:02:28,630 --> 00:02:31,990
configuration on the command line so

00:02:30,280 --> 00:02:38,170
configuration can come in many different

00:02:31,990 --> 00:02:39,370
ways and then we Louis and cross a lot

00:02:38,170 --> 00:02:41,410
of the different projects that I've

00:02:39,370 --> 00:02:43,810
worked on I frequently run into code

00:02:41,410 --> 00:02:46,210
that looks like this this is using type

00:02:43,810 --> 00:02:49,840
safe config extremely popular

00:02:46,210 --> 00:02:52,720
configuration library in scala who here

00:02:49,840 --> 00:02:54,640
i can go to show hand is anybody use or

00:02:52,720 --> 00:02:57,370
expecting most people have used or seen

00:02:54,640 --> 00:02:58,900
type safe config right and have you seen

00:02:57,370 --> 00:03:00,850
code like this where we're just pulling

00:02:58,900 --> 00:03:03,040
the values out directly anybody seen our

00:03:00,850 --> 00:03:06,130
encountering that so that definitely

00:03:03,040 --> 00:03:09,370
happens and the risk you run is that any

00:03:06,130 --> 00:03:11,770
of these values or these calls can

00:03:09,370 --> 00:03:13,239
potentially fail so this specific

00:03:11,770 --> 00:03:15,280
example every single one of those lines

00:03:13,239 --> 00:03:17,410
if that correspondent configuration is

00:03:15,280 --> 00:03:19,360
missing the application is going to fail

00:03:17,410 --> 00:03:21,190
to start which is fine the application

00:03:19,360 --> 00:03:22,660
didn't start but we're not going to get

00:03:21,190 --> 00:03:24,180
a very meaningful we don't get

00:03:22,660 --> 00:03:27,340
meaningful information out of that

00:03:24,180 --> 00:03:30,040
so what we end up seeing is something

00:03:27,340 --> 00:03:32,230
like this which isn't tremendously

00:03:30,040 --> 00:03:33,580
useful and this particular case is that

00:03:32,230 --> 00:03:36,060
if you're loading some

00:03:33,580 --> 00:03:38,680
configuration for I think reactive

00:03:36,060 --> 00:03:41,739
so not related to the previous snippet

00:03:38,680 --> 00:03:43,630
but still a configuration exception so

00:03:41,739 --> 00:03:47,050
that's what we want to solve or what I

00:03:43,630 --> 00:03:49,330
want to solve so fundamentally nobody

00:03:47,050 --> 00:03:51,220
really wants to read these stack traces

00:03:49,330 --> 00:03:53,590
or debug these configuration errors

00:03:51,220 --> 00:03:58,030
that's essentially really really

00:03:53,590 --> 00:04:00,910
irritating if a configuration error

00:03:58,030 --> 00:04:03,519
happens frequently because code somebody

00:04:00,910 --> 00:04:06,130
else wrote and you have to spend extra

00:04:03,519 --> 00:04:08,650
time trial error debugging that code or

00:04:06,130 --> 00:04:11,830
debugging the configuration and at the

00:04:08,650 --> 00:04:13,120
same time very few people or most people

00:04:11,830 --> 00:04:16,070
that want to spend a lot of time writing

00:04:13,120 --> 00:04:17,960
good configuration code in Scala

00:04:16,070 --> 00:04:19,420
you spend most of your time writing your

00:04:17,960 --> 00:04:21,740
application writing your business logic

00:04:19,420 --> 00:04:23,390
focusing on delivery features or

00:04:21,740 --> 00:04:26,510
delivering functionality and then

00:04:23,390 --> 00:04:28,430
quality configuration code may come at

00:04:26,510 --> 00:04:31,880
the end when you have some extra time

00:04:28,430 --> 00:04:35,240
it's usually not a focus so you kind of

00:04:31,880 --> 00:04:36,620
have this dual the situation where we

00:04:35,240 --> 00:04:38,560
want this but we don't want to spend the

00:04:36,620 --> 00:04:40,250
time to get it and so we end up with

00:04:38,560 --> 00:04:44,470
errors that we occasionally have to

00:04:40,250 --> 00:04:47,420
debug so we can build the solution and

00:04:44,470 --> 00:04:50,060
this is what we want to what I want I

00:04:47,420 --> 00:04:53,420
want it easy to you the API so beginners

00:04:50,060 --> 00:04:56,270
are able to use this library once skull

00:04:53,420 --> 00:04:57,650
as a first-class citizen I think fair

00:04:56,270 --> 00:05:00,740
number of people use typesafe config

00:04:57,650 --> 00:05:02,480
that's a Java library so it works well

00:05:00,740 --> 00:05:05,180
in Scala but it's not a Scala

00:05:02,480 --> 00:05:08,050
first-class citizen in my mind because

00:05:05,180 --> 00:05:10,610
we want to avoid throwing any exceptions

00:05:08,050 --> 00:05:12,230
with that in mind we'd also really like

00:05:10,610 --> 00:05:14,870
to have descriptive errors it tells

00:05:12,230 --> 00:05:16,460
exactly what's wrong and ideally tell us

00:05:14,870 --> 00:05:19,310
everything that's wrong or as much as we

00:05:16,460 --> 00:05:23,240
can know at any given point in time and

00:05:19,310 --> 00:05:25,010
then we would also like a minimal no or

00:05:23,240 --> 00:05:27,170
minimal additional dependencies to are

00:05:25,010 --> 00:05:29,870
built again configurations kind of

00:05:27,170 --> 00:05:31,640
tacked on at the end or an afterthought

00:05:29,870 --> 00:05:33,050
so we don't really want to bring in a

00:05:31,640 --> 00:05:35,210
whole bunch of extra libraries to do

00:05:33,050 --> 00:05:36,490
this we want it to be out of the way and

00:05:35,210 --> 00:05:39,770
not interfere with the rest of our work

00:05:36,490 --> 00:05:42,140
and then my goal is to have a purely

00:05:39,770 --> 00:05:42,980
functional implementation so even if

00:05:42,140 --> 00:05:44,690
you're a beginner and you go to a

00:05:42,980 --> 00:05:46,940
functional program you can still use the

00:05:44,690 --> 00:05:49,180
library but behind the scenes it's using

00:05:46,940 --> 00:05:54,230
functional programming principles and

00:05:49,180 --> 00:05:55,520
follow those follows those so a little

00:05:54,230 --> 00:05:57,710
spoiler alert we're going to look at

00:05:55,520 --> 00:05:59,750
some configuration and some examples

00:05:57,710 --> 00:06:02,480
using case class II before we actually

00:05:59,750 --> 00:06:04,040
dive into building a solution they're

00:06:02,480 --> 00:06:06,560
getting to see what you can do before we

00:06:04,040 --> 00:06:10,850
actually go through the motions of doing

00:06:06,560 --> 00:06:13,130
it so here's a sample config extreme is

00:06:10,850 --> 00:06:14,990
simple we have to service backends that

00:06:13,130 --> 00:06:17,570
we'd like to communicate with we have a

00:06:14,990 --> 00:06:19,820
user's service and then a database of

00:06:17,570 --> 00:06:20,760
need to communicate with and both have a

00:06:19,820 --> 00:06:26,150
host

00:06:20,760 --> 00:06:28,740
port and below that with case Classique

00:06:26,150 --> 00:06:30,210
follow me the named case classy we're

00:06:28,740 --> 00:06:32,400
going to define some keys classes that

00:06:30,210 --> 00:06:34,470
model our configuration and we're going

00:06:32,400 --> 00:06:36,630
to quickly load the configuration data

00:06:34,470 --> 00:06:39,660
that raw text directly into those case

00:06:36,630 --> 00:06:41,220
classes in this particular example it's

00:06:39,660 --> 00:06:43,410
using type states can take behind the

00:06:41,220 --> 00:06:46,230
scenes so you see that I import class e

00:06:43,410 --> 00:06:49,140
dot config that binds case class II to

00:06:46,230 --> 00:06:52,680
type state config and we're able to

00:06:49,140 --> 00:06:54,900
quickly generate a decoder for our

00:06:52,680 --> 00:06:57,210
configuration and load that config and

00:06:54,900 --> 00:06:58,380
if you notice I don't actually import

00:06:57,210 --> 00:07:01,230
combat sites

00:06:58,380 --> 00:07:03,060
typesafe that config that anything key

00:07:01,230 --> 00:07:04,800
speci has built it helpers so you can

00:07:03,060 --> 00:07:06,660
load those things directly frequently we

00:07:04,800 --> 00:07:08,760
load configuration from the class pass

00:07:06,660 --> 00:07:10,590
and the dot load command at the very end

00:07:08,760 --> 00:07:13,890
load the file directly off the class

00:07:10,590 --> 00:07:15,750
path now we're going to the same exact

00:07:13,890 --> 00:07:17,520
snippet of code and maybe we don't want

00:07:15,750 --> 00:07:20,130
to use type state config maybe we'd like

00:07:17,520 --> 00:07:21,810
to use a different back-end so almost

00:07:20,130 --> 00:07:23,700
the same exact piece of code but now

00:07:21,810 --> 00:07:25,680
we're loading Java properties directly

00:07:23,700 --> 00:07:28,020
so if you're running on the JVM you get

00:07:25,680 --> 00:07:29,610
this functionality automatically the

00:07:28,020 --> 00:07:31,770
only dependency that would be required

00:07:29,610 --> 00:07:33,480
is case class II and then if you want

00:07:31,770 --> 00:07:35,550
automatic derivation this pulls in

00:07:33,480 --> 00:07:38,160
shapeless so the same snippet of code

00:07:35,550 --> 00:07:41,610
changed slightly and we're loading Java

00:07:38,160 --> 00:07:43,680
util properties if the coding fails you

00:07:41,610 --> 00:07:46,440
can see that the result isn't either

00:07:43,680 --> 00:07:47,970
so on the left hand side an islet of the

00:07:46,440 --> 00:07:49,770
decode error and it's going to capture

00:07:47,970 --> 00:07:51,630
the failures that occurred when the

00:07:49,770 --> 00:07:53,600
configuration fails to love it and we'll

00:07:51,630 --> 00:07:56,220
see more about that in a minute

00:07:53,600 --> 00:07:59,760
in a final example this one you get to

00:07:56,220 --> 00:08:01,380
see a tiny air coming out foo bar we

00:07:59,760 --> 00:08:03,810
have a sealed trait and a couple

00:08:01,380 --> 00:08:06,660
distinct subtypes of that we load some

00:08:03,810 --> 00:08:08,490
data and the data is incorrect in this

00:08:06,660 --> 00:08:10,800
particular case it says that there's

00:08:08,490 --> 00:08:14,490
multiple errors it's missing a value at

00:08:10,800 --> 00:08:17,160
pass to bar and then at list foo bar at

00:08:14,490 --> 00:08:18,360
index 0 it's also missing some values so

00:08:17,160 --> 00:08:19,530
you can see that it collected all the

00:08:18,360 --> 00:08:21,660
different errors that occurred and

00:08:19,530 --> 00:08:23,190
presented them to you showing you

00:08:21,660 --> 00:08:25,950
specifically what happened at each

00:08:23,190 --> 00:08:28,940
different pass and I know this a little

00:08:25,950 --> 00:08:32,130
bit cut off but that's good enough so

00:08:28,940 --> 00:08:33,810
well we're going to go through and build

00:08:32,130 --> 00:08:35,700
the solution using case classy now

00:08:33,810 --> 00:08:37,650
so the first ran is a little bit of

00:08:35,700 --> 00:08:40,919
background information on the math key

00:08:37,650 --> 00:08:43,890
concepts first things first

00:08:40,919 --> 00:08:47,580
algebraic data types these are some or

00:08:43,890 --> 00:08:48,960
Co products and product types you may

00:08:47,580 --> 00:08:51,900
have heard the term I think most people

00:08:48,960 --> 00:08:53,940
have heard this term by now but you've

00:08:51,900 --> 00:08:55,440
definitely use case classes so you've

00:08:53,940 --> 00:08:59,250
used two pools and you've use case

00:08:55,440 --> 00:09:01,140
classes as your idiomatic or your common

00:08:59,250 --> 00:09:02,850
product types where you have multiple

00:09:01,140 --> 00:09:05,310
values and they all have to exist

00:09:02,850 --> 00:09:07,800
together and then we also have Co

00:09:05,310 --> 00:09:09,870
product types which typically are sealed

00:09:07,800 --> 00:09:13,200
case class hierarchies or disjunction

00:09:09,870 --> 00:09:14,970
like Scala either that may be skelet I

00:09:13,200 --> 00:09:17,250
can fill that either might be a typo

00:09:14,970 --> 00:09:18,900
either way Scala dialer is a disjunction

00:09:17,250 --> 00:09:19,410
of two different types you have one or

00:09:18,900 --> 00:09:22,890
the other

00:09:19,410 --> 00:09:25,020
so that's the co-product types and then

00:09:22,890 --> 00:09:30,000
case class hierarchies as you just saw

00:09:25,020 --> 00:09:32,730
earlier case classes in case class ii a

00:09:30,000 --> 00:09:35,160
DTS so for case class ii how do we use a

00:09:32,730 --> 00:09:37,710
DTS well we model our configuration as

00:09:35,160 --> 00:09:40,680
tape class hierarchies like we saw

00:09:37,710 --> 00:09:42,390
before we decode raw configuration into

00:09:40,680 --> 00:09:44,460
those a DTS and that can come from the

00:09:42,390 --> 00:09:47,460
Java properties the type system - or

00:09:44,460 --> 00:09:50,520
other data sources and we also capture

00:09:47,460 --> 00:09:52,500
our decoding errors as an ADT you saw a

00:09:50,520 --> 00:09:54,540
snippet where I had a decode error on

00:09:52,500 --> 00:09:57,330
the left hand side of our either that is

00:09:54,540 --> 00:09:59,550
an ATT that's built into case class II

00:09:57,330 --> 00:10:03,680
and it captures all the semantics of

00:09:59,550 --> 00:10:03,680
what happened with your decoding failure

00:10:03,920 --> 00:10:10,110
cool arrows so I ripped this from

00:10:08,160 --> 00:10:11,850
wikipedia says arrows provide a

00:10:10,110 --> 00:10:14,070
referentially transparent way of

00:10:11,850 --> 00:10:17,250
expressing relationships between logical

00:10:14,070 --> 00:10:19,800
steps in a computation arrows all are

00:10:17,250 --> 00:10:21,990
also morphisms you don't need to know

00:10:19,800 --> 00:10:24,270
any of that what you need to know is

00:10:21,990 --> 00:10:26,580
that arrows are structure preserving

00:10:24,270 --> 00:10:29,100
functions and you already know what

00:10:26,580 --> 00:10:30,870
functions look like in scala so here's a

00:10:29,100 --> 00:10:34,709
simple arrow from an option of a string

00:10:30,870 --> 00:10:35,880
to a list of a string and throughout the

00:10:34,709 --> 00:10:37,830
rest of the slides you're going to see

00:10:35,880 --> 00:10:40,000
this notation where I just use a single

00:10:37,830 --> 00:10:42,160
arrow instead of the the function

00:10:40,000 --> 00:10:43,720
arrow from Scala so this is an arrow

00:10:42,160 --> 00:10:45,880
from option of string to list the string

00:10:43,720 --> 00:10:49,240
and that's what it's gonna look like

00:10:45,880 --> 00:10:51,490
going forward arrow is just like

00:10:49,240 --> 00:10:52,840
functions can compose you can join them

00:10:51,490 --> 00:10:54,970
together and do a lot of different

00:10:52,840 --> 00:10:57,130
operations with arrows so if you have an

00:10:54,970 --> 00:10:58,990
arrow from an intent that multiplies an

00:10:57,130 --> 00:11:01,450
integer by two and if you have an arrow

00:10:58,990 --> 00:11:03,460
into string that does some kind of two

00:11:01,450 --> 00:11:06,700
string function on that arrow then you

00:11:03,460 --> 00:11:09,460
can compose those arrows together using

00:11:06,700 --> 00:11:11,740
basic Combinator's like and then so

00:11:09,460 --> 00:11:14,110
arrow 1 and then arrow 2 is going to

00:11:11,740 --> 00:11:16,360
give you an arrow that takes the input

00:11:14,110 --> 00:11:18,190
and passes it through both and it gives

00:11:16,360 --> 00:11:20,230
you the final output just like it would

00:11:18,190 --> 00:11:21,760
for a function and this is just a

00:11:20,230 --> 00:11:26,620
vanilla Scala functionality right here

00:11:21,760 --> 00:11:27,960
at the bottom alright I think we're

00:11:26,620 --> 00:11:32,410
ready

00:11:27,960 --> 00:11:34,650
so arrows and case glossy or the most

00:11:32,410 --> 00:11:37,810
fundamental part of case classiest

00:11:34,650 --> 00:11:41,380
decoder which is an arrow from some

00:11:37,810 --> 00:11:46,060
input type to either a decoding error or

00:11:41,380 --> 00:11:49,360
a result type a desired result type in

00:11:46,060 --> 00:11:52,750
arrow notation this would be a to decode

00:11:49,360 --> 00:11:54,520
arrow or B and as you can imagine if we

00:11:52,750 --> 00:11:56,290
try to join these together or take

00:11:54,520 --> 00:11:58,210
multiple arrows where the result is a

00:11:56,290 --> 00:12:00,730
decoy error that's going to be a bit

00:11:58,210 --> 00:12:04,450
tricky so there's this notion of a cly's

00:12:00,730 --> 00:12:06,130
lis arrow which allows us to pretty much

00:12:04,450 --> 00:12:08,080
treat this as an arrow directly from A

00:12:06,130 --> 00:12:10,180
to B so instead of having to worry about

00:12:08,080 --> 00:12:12,490
the error behind-the-scenes we could

00:12:10,180 --> 00:12:14,440
just simply compose these arrows arrows

00:12:12,490 --> 00:12:16,660
together and we're gonna get error and

00:12:14,440 --> 00:12:18,550
error handling semantics automatically

00:12:16,660 --> 00:12:19,570
so if something failed the whole

00:12:18,550 --> 00:12:22,300
computation is going to fail

00:12:19,570 --> 00:12:26,320
automatically and we get that by using

00:12:22,300 --> 00:12:28,450
player arrows or rather decoder from A

00:12:26,320 --> 00:12:30,400
to B is effectively a glorified Paislee

00:12:28,450 --> 00:12:34,089
arrow we don't actually reference quasi

00:12:30,400 --> 00:12:38,890
arrows in the project how do we create a

00:12:34,089 --> 00:12:40,600
decoder oh feeding on this you can see

00:12:38,890 --> 00:12:43,089
that the coder has a single apply method

00:12:40,600 --> 00:12:45,520
that is not implemented in case classy

00:12:43,089 --> 00:12:46,889
that's exactly how it is it is also a

00:12:45,520 --> 00:12:48,720
lot of final implemented

00:12:46,889 --> 00:12:51,389
that give you all the combinators to

00:12:48,720 --> 00:12:54,179
build up your decoder from your input

00:12:51,389 --> 00:12:56,730
sources so with that in mind to create a

00:12:54,179 --> 00:12:59,009
decoder we just need to pass in provide

00:12:56,730 --> 00:13:01,139
a function from a to from an input type

00:12:59,009 --> 00:13:03,059
to our results which is either the error

00:13:01,139 --> 00:13:05,699
or the result type and we're able to

00:13:03,059 --> 00:13:09,689
create the decoder using this instance

00:13:05,699 --> 00:13:12,379
helper method so we wanted to code a

00:13:09,689 --> 00:13:15,569
string to UID which is pretty common for

00:13:12,379 --> 00:13:18,660
applications we can rely on the Java or

00:13:15,569 --> 00:13:21,299
C's me the Scala try and be Java you ID

00:13:18,660 --> 00:13:23,579
to parse the UID and then catch any

00:13:21,299 --> 00:13:25,109
exceptions that may occur since our Java

00:13:23,579 --> 00:13:28,350
methods frequently throw exceptions when

00:13:25,109 --> 00:13:30,689
things go wrong so here we're decoding

00:13:28,350 --> 00:13:32,790
an input value of a converting that into

00:13:30,689 --> 00:13:34,230
an option because we don't care about

00:13:32,790 --> 00:13:36,209
the actual exception that are current we

00:13:34,230 --> 00:13:39,179
know that any exception for parsing a

00:13:36,209 --> 00:13:40,679
UID means that the parsing fail let's

00:13:39,179 --> 00:13:42,509
invert that to an option and then we

00:13:40,679 --> 00:13:44,999
convert that to a right hand side either

00:13:42,509 --> 00:13:47,759
with the left-hand side being a decode

00:13:44,999 --> 00:13:50,639
error saying that the UUID was an

00:13:47,759 --> 00:13:52,619
unexpected value and then quickly some

00:13:50,639 --> 00:13:55,549
examples you can imagine that hello and

00:13:52,619 --> 00:13:58,589
world don't bloat this third example

00:13:55,549 --> 00:14:00,989
turns out that that UID that's not into

00:13:58,589 --> 00:14:02,759
ideas a little bit short so you can see

00:14:00,989 --> 00:14:05,819
that we don't have any way to know

00:14:02,759 --> 00:14:07,559
exactly how short but that it reports

00:14:05,819 --> 00:14:10,230
that that was the wrong type and the

00:14:07,559 --> 00:14:13,199
input value was that underlying string

00:14:10,230 --> 00:14:17,429
and then finally we have a valid UID

00:14:13,199 --> 00:14:19,110
that you can you can load composing

00:14:17,429 --> 00:14:20,759
decoders so just like we did with the

00:14:19,110 --> 00:14:24,419
basic Scala functions we can compose

00:14:20,759 --> 00:14:27,419
these arrows so if we have the decoder

00:14:24,419 --> 00:14:30,269
from type safe config to string and then

00:14:27,419 --> 00:14:31,489
we use our decoder from string to UID we

00:14:30,269 --> 00:14:35,339
can then decode from

00:14:31,489 --> 00:14:37,679
config to UUID so we're going to read a

00:14:35,339 --> 00:14:40,769
value from our configuration that path

00:14:37,679 --> 00:14:42,720
ID and then we're going to decode that

00:14:40,769 --> 00:14:44,699
to UID and you can do that by just

00:14:42,720 --> 00:14:46,619
calling the and then method just like

00:14:44,699 --> 00:14:48,119
you would on chaining Scala methods

00:14:46,619 --> 00:14:51,689
together or functions together

00:14:48,119 --> 00:14:55,939
and then if we actually run that you can

00:14:51,689 --> 00:14:55,939
see that it reports things are wrong

00:14:56,520 --> 00:15:11,380
having worse continuing with composition

00:15:02,220 --> 00:15:13,720
oh so I mentioned earlier that built

00:15:11,380 --> 00:15:16,120
into case Class C there's a different

00:15:13,720 --> 00:15:19,990
Alpers four types they've config if you

00:15:16,120 --> 00:15:24,430
already have the decoder from a type

00:15:19,990 --> 00:15:26,890
safe config to a string you can also

00:15:24,430 --> 00:15:28,900
load type safe config directly from

00:15:26,890 --> 00:15:30,940
string and there's a helper dot from

00:15:28,900 --> 00:15:33,430
string which essentially takes an arrow

00:15:30,940 --> 00:15:34,990
from string to type safe config so it

00:15:33,430 --> 00:15:36,400
loads the type safe configuration for

00:15:34,990 --> 00:15:39,820
you catching any exceptions in the

00:15:36,400 --> 00:15:41,680
process and then composes that with your

00:15:39,820 --> 00:15:44,020
existing arrow so your existing

00:15:41,680 --> 00:15:46,330
configuration gets appended to the end

00:15:44,020 --> 00:15:48,520
of that computation with the decoding

00:15:46,330 --> 00:15:51,280
from the raw string to the configuration

00:15:48,520 --> 00:15:53,560
with types of config at the beginning of

00:15:51,280 --> 00:15:55,420
that computation so here we're calling

00:15:53,560 --> 00:15:58,450
decode string and just loading string

00:15:55,420 --> 00:16:00,520
directly using type C's consider so type

00:15:58,450 --> 00:16:02,290
6 can think of the dirty work of parsing

00:16:00,520 --> 00:16:04,750
that loading that it may throw an

00:16:02,290 --> 00:16:06,940
exception and then if it succeeds it

00:16:04,750 --> 00:16:12,240
eventually goes through our little arrow

00:16:06,940 --> 00:16:15,220
flow now decoding type stick config is

00:16:12,240 --> 00:16:18,220
it's been done before there's a number

00:16:15,220 --> 00:16:20,920
of libraries that do that already case

00:16:18,220 --> 00:16:22,780
class II is built around arrows and we

00:16:20,920 --> 00:16:24,520
can have alternative or different input

00:16:22,780 --> 00:16:27,040
sources so we're going to go through

00:16:24,520 --> 00:16:28,780
what it takes to decode a map of string

00:16:27,040 --> 00:16:30,010
string and this is already built into

00:16:28,780 --> 00:16:32,770
Kate's classy but we're going to derive

00:16:30,010 --> 00:16:36,310
it through this talk or draw parts of it

00:16:32,770 --> 00:16:38,440
through the talk so we're going to go to

00:16:36,310 --> 00:16:40,570
map string string decoding or where to

00:16:38,440 --> 00:16:45,580
build map string string decoding from

00:16:40,570 --> 00:16:47,920
scratch this is useful because system

00:16:45,580 --> 00:16:50,890
environment properties as well as W

00:16:47,920 --> 00:16:54,720
properties files all can be converted to

00:16:50,890 --> 00:16:57,450
or go directly to a subtype of map map

00:16:54,720 --> 00:16:59,560
so you're able to load those

00:16:57,450 --> 00:17:02,890
conveniently if you have a decoder for

00:16:59,560 --> 00:17:04,090
map string string first thing we're do

00:17:02,890 --> 00:17:05,860
is I'm going to write a quick helper

00:17:04,090 --> 00:17:07,439
function that lets us pull values out of

00:17:05,860 --> 00:17:10,379
the map and then

00:17:07,439 --> 00:17:14,569
a quick decoder for pulling values out

00:17:10,379 --> 00:17:18,600
of a map this helper function as a final

00:17:14,569 --> 00:17:23,459
parameter F of string to cut off this

00:17:18,600 --> 00:17:25,049
resolution no that's okay so we're

00:17:23,459 --> 00:17:26,309
pulling values out of a map and we're

00:17:25,049 --> 00:17:27,569
going to have an additional helper

00:17:26,309 --> 00:17:29,669
function that will do any final

00:17:27,569 --> 00:17:31,590
processing that on the values coming out

00:17:29,669 --> 00:17:33,059
of the map and we're going to handle any

00:17:31,590 --> 00:17:35,309
exceptions that occur in that final

00:17:33,059 --> 00:17:37,200
processing so if we want to decode a

00:17:35,309 --> 00:17:39,029
string out of the map we're just going

00:17:37,200 --> 00:17:43,500
to read values directly out of the maps

00:17:39,029 --> 00:17:45,779
map get to right and then we're wrapping

00:17:43,500 --> 00:17:48,809
the identity for using the identity

00:17:45,779 --> 00:17:51,240
function for any final processing but we

00:17:48,809 --> 00:17:52,440
wrap that and exception handling so if

00:17:51,240 --> 00:17:54,659
there's an exception that occurs when

00:17:52,440 --> 00:17:56,429
that value is decoded from string we're

00:17:54,659 --> 00:17:59,429
capturing that there and turning that

00:17:56,429 --> 00:18:01,440
into a decode error obviously decoding a

00:17:59,429 --> 00:18:03,059
string from a map string string is not

00:18:01,440 --> 00:18:04,710
going to throw any parsing exceptions

00:18:03,059 --> 00:18:07,200
it's just going to work or not work if

00:18:04,710 --> 00:18:09,149
the value is not there but for other

00:18:07,200 --> 00:18:12,029
cases like decoding along or boolean

00:18:09,149 --> 00:18:13,860
those values may parse or fail to parse

00:18:12,029 --> 00:18:16,309
in which case you want to capture those

00:18:13,860 --> 00:18:18,960
exceptions so our helper allows for that

00:18:16,309 --> 00:18:23,250
so here we just built up a bunch of

00:18:18,960 --> 00:18:25,889
arrows from a map string string too long

00:18:23,250 --> 00:18:29,190
to string to double and we're able to do

00:18:25,889 --> 00:18:33,990
that very very easily and then we can of

00:18:29,190 --> 00:18:36,120
course call that or build up yep-yep

00:18:33,990 --> 00:18:38,009
decode through long decode long from

00:18:36,120 --> 00:18:41,549
math we call those and get the different

00:18:38,009 --> 00:18:43,919
results so you could foo long we're

00:18:41,549 --> 00:18:45,840
going to pull the value through out of a

00:18:43,919 --> 00:18:48,750
Matt out of our math and decode it as

00:18:45,840 --> 00:18:52,049
long basically this first case it fails

00:18:48,750 --> 00:18:55,409
to that key isn't there and in the

00:18:52,049 --> 00:18:56,879
second one the foo value is there but

00:18:55,409 --> 00:18:59,009
was unable to actually parse the value

00:18:56,879 --> 00:19:00,289
so you can see that the exception that

00:18:59,009 --> 00:19:03,629
would have been thrown when the Java

00:19:00,289 --> 00:19:05,960
when we parse the string too along that

00:19:03,629 --> 00:19:09,960
exception was caught and turned into a

00:19:05,960 --> 00:19:14,029
an error type in our error ADT and then

00:19:09,960 --> 00:19:14,029
finally we have two values that worked

00:19:14,499 --> 00:19:20,029
so how do we get to a TPS how to get to

00:19:17,869 --> 00:19:22,369
our case classes we already have a

00:19:20,029 --> 00:19:24,829
decoder from string that too long that

00:19:22,369 --> 00:19:28,429
reads that passed too we also already

00:19:24,829 --> 00:19:30,769
have a decoder from string maps to

00:19:28,429 --> 00:19:33,019
string that reads that passed bar we

00:19:30,769 --> 00:19:35,709
want to join those together and do both

00:19:33,019 --> 00:19:39,949
at the same time and we can do that by

00:19:35,709 --> 00:19:42,259
fanning out those two arrows so if we

00:19:39,949 --> 00:19:44,419
take string max along and join it with

00:19:42,259 --> 00:19:47,059
string map to string we're going to get

00:19:44,419 --> 00:19:48,709
a string maps to a tuple of long and

00:19:47,059 --> 00:19:51,499
string and it's going to collect the

00:19:48,709 --> 00:19:54,319
errors and the errors in the process so

00:19:51,499 --> 00:19:56,569
here we use the help from at the join

00:19:54,319 --> 00:19:58,009
that joins those two arrows together or

00:19:56,569 --> 00:20:01,489
there's two decoders together and gives

00:19:58,009 --> 00:20:02,959
us a decoder for our tuple and then we

00:20:01,489 --> 00:20:05,119
can take advantage of the tuple

00:20:02,959 --> 00:20:07,849
constructor on case classes in Scala and

00:20:05,119 --> 00:20:12,049
it's map our result directly to that

00:20:07,849 --> 00:20:13,999
case class so now we have scenario from

00:20:12,049 --> 00:20:18,169
string map or decoder from string map to

00:20:13,999 --> 00:20:20,089
fubar continuing this we're just going

00:20:18,169 --> 00:20:22,339
to load some different values if you

00:20:20,089 --> 00:20:25,399
load an empty map here you can see that

00:20:22,339 --> 00:20:28,219
it knows that a nested path it's missing

00:20:25,399 --> 00:20:30,649
the value bar so it's expecting excuse

00:20:28,219 --> 00:20:32,809
me yep that path - it's missing a value

00:20:30,649 --> 00:20:34,369
and at pass bar it's also missing values

00:20:32,809 --> 00:20:37,339
its capture the fact that those things

00:20:34,369 --> 00:20:38,959
are missing if you provide one it's

00:20:37,339 --> 00:20:40,519
going to tell you or if you put read a

00:20:38,959 --> 00:20:44,539
wrong value for one it'll tell you the

00:20:40,519 --> 00:20:47,239
bad values wrong and then get wrong type

00:20:44,539 --> 00:20:48,889
and then finally if you provide two

00:20:47,239 --> 00:20:52,359
correct values or correct values in our

00:20:48,889 --> 00:20:55,909
consider is able to load that correctly

00:20:52,359 --> 00:20:57,709
what if we want to load nested paths I

00:20:55,909 --> 00:20:59,329
mean our goal would need to do to load

00:20:57,709 --> 00:21:01,339
into nested case class hierarchies or

00:20:59,329 --> 00:21:02,929
more complicated case class hierarchies

00:21:01,339 --> 00:21:06,139
that means we need to be able to load

00:21:02,929 --> 00:21:09,999
nested paths from our string map any

00:21:06,139 --> 00:21:09,999
ideas and how you what you do for this

00:21:10,869 --> 00:21:17,179
right so what we want essentially is to

00:21:14,659 --> 00:21:19,459
first decode from string map to another

00:21:17,179 --> 00:21:22,459
string map we're going to strip out the

00:21:19,459 --> 00:21:25,609
prefixes so let's say you want to decode

00:21:22,459 --> 00:21:27,409
something at pass-through bar you want

00:21:25,609 --> 00:21:30,169
to first filter that map stripping out

00:21:27,409 --> 00:21:32,269
the prefix and build a decoder that does

00:21:30,169 --> 00:21:34,159
that prefix stripping for you and that's

00:21:32,269 --> 00:21:35,539
exactly what we're going to do and we're

00:21:34,159 --> 00:21:37,969
going to be able to do things like this

00:21:35,539 --> 00:21:40,099
where we first decode maps for maps at

00:21:37,969 --> 00:21:43,939
pass through bar and then we actually

00:21:40,099 --> 00:21:45,769
load our case class from there and this

00:21:43,939 --> 00:21:47,209
is how that's implemented if you wanted

00:21:45,769 --> 00:21:49,039
actually implement that yourself you

00:21:47,209 --> 00:21:51,379
would load the value and convert the map

00:21:49,039 --> 00:21:53,239
to a list of string string filter all

00:21:51,379 --> 00:21:56,209
the keys and then go back to a new map

00:21:53,239 --> 00:21:58,009
and wrap it up as a decoder so here you

00:21:56,209 --> 00:22:00,259
have B code map for map takes an input

00:21:58,009 --> 00:22:02,629
string which would be the prefix for

00:22:00,259 --> 00:22:04,669
where you're trying to decode it's going

00:22:02,629 --> 00:22:06,889
to find all the keys with that prefix

00:22:04,669 --> 00:22:09,349
strip the prefix off and then give you

00:22:06,889 --> 00:22:12,379
an ich a new decoder that operates on

00:22:09,349 --> 00:22:13,849
those sub mathews and this is not the

00:22:12,379 --> 00:22:17,269
most efficient implementation of that

00:22:13,849 --> 00:22:19,339
it's just a implementation of that if

00:22:17,269 --> 00:22:20,929
the final map is empty different filters

00:22:19,339 --> 00:22:22,369
and finds and results it's going to tell

00:22:20,929 --> 00:22:24,349
you that the values are missing

00:22:22,369 --> 00:22:27,319
otherwise it gives you the filtered

00:22:24,349 --> 00:22:29,419
results so that any other errors can be

00:22:27,319 --> 00:22:33,919
handled by decoders that occur after

00:22:29,419 --> 00:22:35,389
that so we can use this and in the

00:22:33,919 --> 00:22:38,359
spirit of all the previous slides we

00:22:35,389 --> 00:22:39,889
have examples of using it first when you

00:22:38,359 --> 00:22:43,519
see missing values

00:22:39,889 --> 00:22:46,459
next one you see a successful loading so

00:22:43,519 --> 00:22:49,129
we've noted loaded nested values from

00:22:46,459 --> 00:22:51,409
our a nested map from overall map and

00:22:49,129 --> 00:22:57,109
then we pass that off to our decoder for

00:22:51,409 --> 00:22:59,539
a case class so we're doing some

00:22:57,109 --> 00:23:01,909
housekeeping if you look right here in

00:22:59,539 --> 00:23:05,029
the middle we do decode map for map at

00:23:01,909 --> 00:23:07,939
foo bar and then passing it off to our

00:23:05,029 --> 00:23:10,309
next decoder that's pretty clunky nobody

00:23:07,939 --> 00:23:12,469
really wants to write code like I don't

00:23:10,309 --> 00:23:14,389
expect people to build up their decoders

00:23:12,469 --> 00:23:16,249
that way it'd be really convenient if we

00:23:14,389 --> 00:23:17,839
could take our existing decoder and

00:23:16,249 --> 00:23:19,999
simply say that we want them to decode

00:23:17,839 --> 00:23:21,889
from a nested path and we can do that by

00:23:19,999 --> 00:23:22,839
leveraging type classes and some

00:23:21,889 --> 00:23:24,909
implicit

00:23:22,839 --> 00:23:28,099
we're not going to go through

00:23:24,909 --> 00:23:29,779
implementing those but if they were in

00:23:28,099 --> 00:23:31,050
place or if they are in place for the

00:23:29,779 --> 00:23:33,660
source that you're deep

00:23:31,050 --> 00:23:36,660
from you can simply say I want to take

00:23:33,660 --> 00:23:38,280
my decoder for my case class and decode

00:23:36,660 --> 00:23:41,730
at past fubar and it's just going to

00:23:38,280 --> 00:23:44,130
work and so behind the scenes there is

00:23:41,730 --> 00:23:46,910
an implicit instance of this read type

00:23:44,130 --> 00:23:49,470
class that expresses the ability to read

00:23:46,910 --> 00:23:51,690
from a structure and return another

00:23:49,470 --> 00:23:53,490
structure of that same type so here we

00:23:51,690 --> 00:23:57,690
can read a string map and I get another

00:23:53,490 --> 00:23:59,550
string map as a result that yep and that

00:23:57,690 --> 00:24:01,560
simply wraps around ruler underlying

00:23:59,550 --> 00:24:03,780
decoders shows a type class that

00:24:01,560 --> 00:24:07,800
captures the ability to read value that

00:24:03,780 --> 00:24:11,400
it passed we can continue to house keep

00:24:07,800 --> 00:24:13,890
we can use our type lines to summon

00:24:11,400 --> 00:24:15,570
instances for reading different values

00:24:13,890 --> 00:24:17,520
so instead something to build up all

00:24:15,570 --> 00:24:19,830
that stuff by hand if it's already in

00:24:17,520 --> 00:24:22,020
place with this say we want to read a

00:24:19,830 --> 00:24:25,020
value from our string map at path or

00:24:22,020 --> 00:24:27,000
read a value foo read a value bar want

00:24:25,020 --> 00:24:31,140
to join those together we're to map that

00:24:27,000 --> 00:24:33,960
to our case class and then we're going

00:24:31,140 --> 00:24:36,900
to decode at a nested path and on the

00:24:33,960 --> 00:24:39,000
right you see in arrows exactly what's

00:24:36,900 --> 00:24:40,650
happening we have a string map too long

00:24:39,000 --> 00:24:42,690
we're Fanning that out with string map

00:24:40,650 --> 00:24:46,320
to string which gives us string back to

00:24:42,690 --> 00:24:48,500
to full of string and long we're mapping

00:24:46,320 --> 00:24:51,030
that to our cape class and then we're

00:24:48,500 --> 00:24:54,170
decoding at a nested path which gives

00:24:51,030 --> 00:24:54,170
you an arrow of the same type

00:24:54,830 --> 00:24:57,830
yep

00:24:57,979 --> 00:25:04,109
great and this is still a lot of works

00:25:02,519 --> 00:25:06,719
you can go through that if you'd like

00:25:04,109 --> 00:25:08,729
but in many cases we just want it to

00:25:06,719 --> 00:25:11,489
work he saw in the very first few slides

00:25:08,729 --> 00:25:13,049
that we had some case classes and with

00:25:11,489 --> 00:25:15,899
one line we're able to load those case

00:25:13,049 --> 00:25:17,669
classes from different data sources and

00:25:15,899 --> 00:25:20,039
that's done with shapeless so if you

00:25:17,669 --> 00:25:22,829
import the generic package from case

00:25:20,039 --> 00:25:25,319
Class E which is a from a separate SBT

00:25:22,829 --> 00:25:28,049
project a separate dependency then you

00:25:25,319 --> 00:25:29,939
get shapeless driving all the decoders

00:25:28,049 --> 00:25:31,799
for you it's doing all the work of

00:25:29,939 --> 00:25:33,419
building up the decoders using all these

00:25:31,799 --> 00:25:36,029
different Combinator's that we just went

00:25:33,419 --> 00:25:38,369
through so instead of doing it by hand

00:25:36,029 --> 00:25:39,389
you just say derive decoder from string

00:25:38,369 --> 00:25:41,339
map to fubar

00:25:39,389 --> 00:25:43,079
it doesn't know that you want to decode

00:25:41,339 --> 00:25:44,999
a nested path so you still to tell it to

00:25:43,079 --> 00:25:52,739
do that but it's done most of the work

00:25:44,999 --> 00:25:56,129
for you cool so what have we done we've

00:25:52,739 --> 00:26:00,089
built decoders from a map and that he is

00:25:56,129 --> 00:26:02,759
arrows we've built the coders for

00:26:00,089 --> 00:26:05,789
reading nested data and we kind of drove

00:26:02,759 --> 00:26:08,639
into arrow composition there so standing

00:26:05,789 --> 00:26:11,369
out arrows as well as standing out

00:26:08,639 --> 00:26:14,479
arrows and then mapping the results we

00:26:11,369 --> 00:26:16,919
decoded a case class excuse me

00:26:14,479 --> 00:26:18,389
decoding a case class we did the fanning

00:26:16,919 --> 00:26:21,899
out of arrows and then mapping it to the

00:26:18,389 --> 00:26:23,489
case class and then we made decoding

00:26:21,899 --> 00:26:25,829
cleaner with implicit type classes of

00:26:23,489 --> 00:26:27,359
the read type class and then finally we

00:26:25,829 --> 00:26:29,729
use shapeless to derive the decoders for

00:26:27,359 --> 00:26:31,379
us so we put C plus behind the wheel and

00:26:29,729 --> 00:26:34,409
said do the work we don't want to do

00:26:31,379 --> 00:26:36,239
this and why would we want to do all

00:26:34,409 --> 00:26:37,559
this I've showed you some more simple

00:26:36,239 --> 00:26:40,709
examples this one's a little bit more

00:26:37,559 --> 00:26:44,069
complicated here we have sealed abstract

00:26:40,709 --> 00:26:45,959
class shape there's five different

00:26:44,069 --> 00:26:47,939
distinct kinds of shapes in this

00:26:45,959 --> 00:26:50,279
hierarchy they all have different values

00:26:47,939 --> 00:26:52,259
that they expect then we want to load a

00:26:50,279 --> 00:26:54,749
whole list of these shapes and we want

00:26:52,259 --> 00:26:57,869
to know exactly what goes wrong if

00:26:54,749 --> 00:27:01,559
something went wrong we and then we we

00:26:57,869 --> 00:27:03,809
want the results to appear to get the

00:27:01,559 --> 00:27:04,220
decoder for that using safe list using

00:27:03,809 --> 00:27:05,960
the

00:27:04,220 --> 00:27:08,330
the generic package you can just ask the

00:27:05,960 --> 00:27:10,280
derive a decoder from config to shapes

00:27:08,330 --> 00:27:13,159
and it's going to build that up for you

00:27:10,280 --> 00:27:14,570
that includes handling lists handling

00:27:13,159 --> 00:27:16,789
the errors from multiple items at the

00:27:14,570 --> 00:27:18,620
carring at the same time and all the

00:27:16,789 --> 00:27:20,929
different decoding for all the different

00:27:18,620 --> 00:27:24,350
subtypes of shapes so it derives all is

00:27:20,929 --> 00:27:26,210
up for you automatically and what does

00:27:24,350 --> 00:27:29,179
that look like in practice if you have

00:27:26,210 --> 00:27:31,159
passing some configuration here's a

00:27:29,179 --> 00:27:34,789
sample input configuration with some

00:27:31,159 --> 00:27:38,510
valid and some invalid entries so the

00:27:34,789 --> 00:27:39,710
first you can probably figure out which

00:27:38,510 --> 00:27:42,020
ones are valid or invalid

00:27:39,710 --> 00:27:44,450
the first one is valid second ones

00:27:42,020 --> 00:27:46,309
invalid I believe the third one is valid

00:27:44,450 --> 00:27:50,600
and then the fourth one is obviously

00:27:46,309 --> 00:27:53,059
invalid and it's index 0 so you can see

00:27:50,600 --> 00:27:55,220
on the left the ATT representation of

00:27:53,059 --> 00:27:58,190
the error and on the right is a human

00:27:55,220 --> 00:28:00,980
friendly version of that same error so

00:27:58,190 --> 00:28:03,169
you can see that at index 1 at index 0

00:28:00,980 --> 00:28:07,549
it succeeded it was able to load the

00:28:03,169 --> 00:28:09,590
circle with radius 2 but index 1 it

00:28:07,549 --> 00:28:12,320
noticed that we had rectangle it tried

00:28:09,590 --> 00:28:14,419
to load values at the past rectangle it

00:28:12,320 --> 00:28:15,740
could have figured out and it also tried

00:28:14,419 --> 00:28:17,929
all the other alternatives and it

00:28:15,740 --> 00:28:19,970
reports exactly what went wrong with all

00:28:17,929 --> 00:28:21,890
those alternatives so for circle

00:28:19,970 --> 00:28:24,289
rectangle regular polygon Square and

00:28:21,890 --> 00:28:25,549
triangle it didn't get very far for

00:28:24,289 --> 00:28:28,010
rectangle got a little bit further

00:28:25,549 --> 00:28:31,480
because you provided to keep the key for

00:28:28,010 --> 00:28:34,909
that and then also index 3 it fails but

00:28:31,480 --> 00:28:36,590
it's no value to showing extra air and

00:28:34,909 --> 00:28:42,679
again on the right same representation

00:28:36,590 --> 00:28:43,940
just a human friendly printout some

00:28:42,679 --> 00:28:48,230
feature is another miscellany

00:28:43,940 --> 00:28:50,720
this is Scala to 11 and to 12 at the

00:28:48,230 --> 00:28:52,850
moment it also supports Scala Jas and

00:28:50,720 --> 00:28:56,090
that includes supporting type save

00:28:52,850 --> 00:28:58,039
config or this library of show con which

00:28:56,090 --> 00:29:00,049
is class path compatible with types hit

00:28:58,039 --> 00:29:02,330
config so if you want to load hook on

00:29:00,049 --> 00:29:04,460
file on Scala Jas and on the day VM

00:29:02,330 --> 00:29:06,279
you're able to do that and be able to do

00:29:04,460 --> 00:29:09,519
it in a generic fashion you think

00:29:06,279 --> 00:29:10,960
classy the project is modular eyes so

00:29:09,519 --> 00:29:13,899
the core module will have no external

00:29:10,960 --> 00:29:15,879
dependencies all the FP concepts are

00:29:13,899 --> 00:29:18,519
built into the library kind of under the

00:29:15,879 --> 00:29:20,889
hood if when they're used and they're

00:29:18,519 --> 00:29:22,719
not exposed out of that if you want to

00:29:20,889 --> 00:29:25,029
use the typeset config library there's a

00:29:22,719 --> 00:29:27,070
module for that you want to use generic

00:29:25,029 --> 00:29:29,320
derivation there's a shapeless module

00:29:27,070 --> 00:29:31,719
for that as well so core module has no

00:29:29,320 --> 00:29:33,519
extra dependencies and finally this is

00:29:31,719 --> 00:29:35,710
also a type level incubator project

00:29:33,519 --> 00:29:37,419
which means there's some code of conduct

00:29:35,710 --> 00:29:40,089
and some standards regarding the

00:29:37,419 --> 00:29:42,009
documentation websites and maintenance

00:29:40,089 --> 00:29:46,619
of the project so we're maintaining this

00:29:42,009 --> 00:29:51,099
at 47 degrees and Thecla bowlegs Bator

00:29:46,619 --> 00:29:53,739
next steps so configuring derived

00:29:51,099 --> 00:29:55,690
decoders I showed automatic derivation

00:29:53,739 --> 00:29:57,249
it's possible to specify different

00:29:55,690 --> 00:29:59,320
options for how those decoders the Hays

00:29:57,249 --> 00:30:01,299
even when they're derived automatically

00:29:59,320 --> 00:30:05,320
and there's some options already built

00:30:01,299 --> 00:30:08,200
in to go on this slide you can see that

00:30:05,320 --> 00:30:11,279
it's looking at automatically looking at

00:30:08,200 --> 00:30:13,450
a nested field in your list of shapes

00:30:11,279 --> 00:30:15,519
maybe you want to discern the different

00:30:13,450 --> 00:30:17,379
types by passing in by having an

00:30:15,519 --> 00:30:19,479
additional field called pipe that says

00:30:17,379 --> 00:30:21,879
type equal shape or a type equal circle

00:30:19,479 --> 00:30:24,299
or type equals rectangle it's possible

00:30:21,879 --> 00:30:26,499
to have the generic derivation

00:30:24,299 --> 00:30:28,359
accommodate for that by passing in a

00:30:26,499 --> 00:30:30,219
different flag and so that's already

00:30:28,359 --> 00:30:33,249
built into the library it's just not

00:30:30,219 --> 00:30:35,859
covered in the examples here my goals

00:30:33,249 --> 00:30:37,570
add more options on add needed basis so

00:30:35,859 --> 00:30:41,460
that you can customize how your case

00:30:37,570 --> 00:30:43,719
classes are loaded as we please

00:30:41,460 --> 00:30:45,879
looking to support decoding more input

00:30:43,719 --> 00:30:48,429
types right now it supports Java

00:30:45,879 --> 00:30:50,919
properties files loading loading files

00:30:48,429 --> 00:30:53,259
that are property files sports type

00:30:50,919 --> 00:30:56,499
State config it supports show con type

00:30:53,259 --> 00:30:58,299
space configs but it can support any

00:30:56,499 --> 00:31:00,519
kind of data type it could support

00:30:58,299 --> 00:31:02,320
binary data types it's completely

00:31:00,519 --> 00:31:03,940
indifferent because it's built on the

00:31:02,320 --> 00:31:07,029
decoder which is essentially the quietly

00:31:03,940 --> 00:31:09,940
row from an input type to the decoded

00:31:07,029 --> 00:31:11,379
results and then finally we're hoping to

00:31:09,940 --> 00:31:13,599
integrate they're planning to integrate

00:31:11,379 --> 00:31:15,580
with freestyle which is a framework for

00:31:13,599 --> 00:31:19,739
doing functional programming in Scala

00:31:15,580 --> 00:31:19,739
and that's that free

00:31:20,380 --> 00:31:38,049
and that was it got that got to that

00:31:30,470 --> 00:31:38,049
fast it's not too bad any questions

00:31:39,220 --> 00:31:46,520
hello and I also really enjoy a

00:31:43,910 --> 00:31:49,940
confirmation library for my project back

00:31:46,520 --> 00:31:52,970
in the days and what we used in there

00:31:49,940 --> 00:31:57,650
heavily is conferring configuration

00:31:52,970 --> 00:32:00,260
reloading on run time and missus case

00:31:57,650 --> 00:32:02,480
class II also supporting configuration

00:32:00,260 --> 00:32:06,740
wrong time like for example when a found

00:32:02,480 --> 00:32:09,110
disk is the mode of modified reloaded so

00:32:06,740 --> 00:32:11,900
the question was a letter P questions

00:32:09,110 --> 00:32:13,490
that's oh yeah sorry listen notify the

00:32:11,900 --> 00:32:15,500
question was does support configuration

00:32:13,490 --> 00:32:16,790
reloading and there's nothing built-in

00:32:15,500 --> 00:32:18,890
incase classy right now for

00:32:16,790 --> 00:32:20,960
configuration reloading it's meant to be

00:32:18,890 --> 00:32:22,970
immutable so you're loading whatever

00:32:20,960 --> 00:32:26,809
your data source is to an immutable

00:32:22,970 --> 00:32:28,340
result or typically an immutable result

00:32:26,809 --> 00:32:30,919
there's nothing that would prevent you

00:32:28,340 --> 00:32:33,080
from running the decoding process again

00:32:30,919 --> 00:32:36,049
or all automating that whenever the

00:32:33,080 --> 00:32:37,490
files or configuration changes and what

00:32:36,049 --> 00:32:39,590
you're going to get a new case class

00:32:37,490 --> 00:32:42,200
representation of that data that you can

00:32:39,590 --> 00:32:45,290
hand off to your application so these

00:32:42,200 --> 00:32:48,020
are email facilities in the library as

00:32:45,290 --> 00:32:52,250
it stands but there would be some room

00:32:48,020 --> 00:32:55,370
for automating some of that now the goal

00:32:52,250 --> 00:32:58,100
isn't to handle any changes any media

00:32:55,370 --> 00:32:59,870
mutable value that the value level so

00:32:58,100 --> 00:33:02,330
imagine a whole hierarchy configuration

00:32:59,870 --> 00:33:04,309
if you want to handle reloading up

00:33:02,330 --> 00:33:06,710
specific values or notifications for

00:33:04,309 --> 00:33:09,620
changes of specific values that's out of

00:33:06,710 --> 00:33:10,480
the scope for this project so does that

00:33:09,620 --> 00:33:13,480
answer the question

00:33:10,480 --> 00:33:13,480
great

00:33:14,150 --> 00:33:20,780
a good question regarding the

00:33:17,330 --> 00:33:23,660
configuration in general so you have

00:33:20,780 --> 00:33:27,170
your KC what I want like why did you

00:33:23,660 --> 00:33:29,930
have to dig act and figured and then you

00:33:27,170 --> 00:33:32,000
want to think that it scale let's say

00:33:29,930 --> 00:33:33,950
you have like because we're in a machine

00:33:32,000 --> 00:33:37,700
said you want updated configuration on

00:33:33,950 --> 00:33:39,310
all this like what wouldn't you like how

00:33:37,700 --> 00:33:42,140
usually handle this kind of thing

00:33:39,310 --> 00:33:44,900
redeployed all your second three-point

00:33:42,140 --> 00:33:48,950
everything that I think it's like it so

00:33:44,900 --> 00:33:49,910
that's a you do that way and I mean

00:33:48,950 --> 00:33:52,240
that's some of the work I'm currently

00:33:49,910 --> 00:33:54,920
doing we're doing everything is

00:33:52,240 --> 00:33:56,570
immutable and so we are doing all

00:33:54,920 --> 00:33:58,430
container based deployments and we'll

00:33:56,570 --> 00:34:00,950
simply just redeploy the container right

00:33:58,430 --> 00:34:03,710
so that's not that's the pattern I

00:34:00,950 --> 00:34:07,880
usually see but then wouldn't be easier

00:34:03,710 --> 00:34:09,950
to just have case Colossus with values

00:34:07,880 --> 00:34:12,260
directive that couldn't have profiles if

00:34:09,950 --> 00:34:15,890
you is every time you pretty much we

00:34:12,260 --> 00:34:18,320
deploy you can update the code we build

00:34:15,890 --> 00:34:20,620
it pretty boy so what's the point of

00:34:18,320 --> 00:34:23,600
using like you know types of libraries

00:34:20,620 --> 00:34:25,940
with and then you have to do with the

00:34:23,600 --> 00:34:30,140
air somehow right but if you have like

00:34:25,940 --> 00:34:32,690
case class you have like service

00:34:30,140 --> 00:34:34,370
whatever how support and you have to

00:34:32,690 --> 00:34:38,750
provide that at compile time and it's

00:34:34,370 --> 00:34:43,850
verified by compiler so if you need to

00:34:38,750 --> 00:34:47,630
change you pretty boy again which is I

00:34:43,850 --> 00:34:49,070
think I follow I mean there's nothing

00:34:47,630 --> 00:34:54,130
they would prevent you from using us at

00:34:49,070 --> 00:34:54,130
compile time to validate configuration

00:34:54,940 --> 00:35:00,080
I'm normally currently I currently only

00:34:57,740 --> 00:35:02,720
use this at runtime at the root of

00:35:00,080 --> 00:35:04,310
applications so if an application is

00:35:02,720 --> 00:35:06,650
going to fail it just reports that it

00:35:04,310 --> 00:35:08,300
failed but you could validate

00:35:06,650 --> 00:35:11,420
configuration heda's on or load

00:35:08,300 --> 00:35:14,510
configuration ahead of time and maybe

00:35:11,420 --> 00:35:15,420
generate a static configuration from

00:35:14,510 --> 00:35:18,809
that that is

00:35:15,420 --> 00:35:21,539
to work but I haven't I don't have that

00:35:18,809 --> 00:35:24,240
use case in terms of reloading

00:35:21,539 --> 00:35:27,329
configuration or the one thing I'm

00:35:24,240 --> 00:35:29,640
looking at is from work I'm doing we

00:35:27,329 --> 00:35:32,190
have the need for reconfiguring logging

00:35:29,640 --> 00:35:35,940
levels for debugging on the fly or

00:35:32,190 --> 00:35:38,730
boosting trace levels and so I may look

00:35:35,940 --> 00:35:41,039
at adding some functionality that to

00:35:38,730 --> 00:35:44,760
make it easier to get notified when

00:35:41,039 --> 00:35:47,039
something changed again I won't no plans

00:35:44,760 --> 00:35:50,910
to support individual fields or values

00:35:47,039 --> 00:35:52,950
changing but if you want a whole

00:35:50,910 --> 00:35:55,289
configuration file a whole set of config

00:35:52,950 --> 00:35:57,750
to kind of reload or B or to change

00:35:55,289 --> 00:36:00,269
without redoing your whole environment

00:35:57,750 --> 00:36:02,099
then that's something that I personally

00:36:00,269 --> 00:36:04,289
need so at some point that will be

00:36:02,099 --> 00:36:07,849
addressed I don't know if I answered

00:36:04,289 --> 00:36:07,849
your question right thank you

00:36:13,740 --> 00:36:20,010
yeah so this is a what you described

00:36:17,010 --> 00:36:22,589
this all for a configuration that is

00:36:20,010 --> 00:36:26,400
required so what if you I want to fall

00:36:22,589 --> 00:36:28,170
back on a default value so option

00:36:26,400 --> 00:36:32,549
decoding in the case classes if you

00:36:28,170 --> 00:36:35,099
Marcus field is optional that it's it

00:36:32,549 --> 00:36:38,880
won't actually fail at that value of

00:36:35,099 --> 00:36:41,220
missing I mentioned that you there's the

00:36:38,880 --> 00:36:45,450
ability to specify options for the

00:36:41,220 --> 00:36:47,520
derive decoders and I think it did a

00:36:45,450 --> 00:36:50,490
port or a PR I'm not sure if I

00:36:47,520 --> 00:36:52,410
implemented it fully yet but it was

00:36:50,490 --> 00:36:54,510
safely possible to pull off the default

00:36:52,410 --> 00:36:56,819
values from case classes so if you

00:36:54,510 --> 00:36:59,250
wanted to specify your default values in

00:36:56,819 --> 00:37:01,579
the case class as default parameters or

00:36:59,250 --> 00:37:03,599
default parameter values then that is

00:37:01,579 --> 00:37:05,849
low-hanging fruit in terms of

00:37:03,599 --> 00:37:08,160
functionality for case classy if you

00:37:05,849 --> 00:37:12,029
wanted to specify your default values

00:37:08,160 --> 00:37:17,750
elsewhere go back it's not shown but I

00:37:12,029 --> 00:37:22,470
mentioned that there's tons of tons of

00:37:17,750 --> 00:37:24,180
methods implemented on encoder final

00:37:22,470 --> 00:37:26,190
implemented methods there's fallback

00:37:24,180 --> 00:37:27,990
methods where you can specify a fallback

00:37:26,190 --> 00:37:30,029
for your configuration so if the

00:37:27,990 --> 00:37:32,400
decoding fails it will just go to this

00:37:30,029 --> 00:37:34,650
other decoder or go to this hard-coded

00:37:32,400 --> 00:37:37,710
result and you can do that at any level

00:37:34,650 --> 00:37:40,079
of your configuration so what I think we

00:37:37,710 --> 00:37:41,670
do is that sure you can drive your

00:37:40,079 --> 00:37:44,460
decoder automatically for the whole

00:37:41,670 --> 00:37:46,589
configuration universe what I typically

00:37:44,460 --> 00:37:48,690
do is decode the parts that I know I

00:37:46,589 --> 00:37:50,910
want automatics and maybe specify a

00:37:48,690 --> 00:37:53,160
default value for that and then be good

00:37:50,910 --> 00:37:55,529
the rest so kind of drive the automatic

00:37:53,160 --> 00:37:57,680
derivation and insert my default values

00:37:55,529 --> 00:38:00,660
or guide it a little bit where I need to

00:37:57,680 --> 00:38:04,730
but the others support for defaults and

00:38:00,660 --> 00:38:04,730
fall backs okay thanks

00:38:05,560 --> 00:38:12,850
I got that

00:38:11,050 --> 00:38:19,750
thank you guys coming

00:38:12,850 --> 00:38:19,750

YouTube URL: https://www.youtube.com/watch?v=Tx53JekeFIU


