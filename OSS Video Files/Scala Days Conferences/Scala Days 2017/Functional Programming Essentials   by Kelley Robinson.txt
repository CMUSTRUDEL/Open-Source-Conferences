Title: Functional Programming Essentials   by Kelley Robinson
Publication date: 2017-06-23
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Scala is often touted as a tool for Functional Programming, but Functional Programming (FP) itself is left to differing and opinionated definitions by many of its practitioners. FP is a well defined approach to writing programs that we will uncover in this talk. It is a style that long predates Scala and many of the modern abstractions that are often referred to as "essential" tools.

We will walk through the origins of FP, providing historical context through Lisp and the research that brought us this paradigm. We'll define what FP is and what it is not, looking at how tools like purity and immutability enable the expressions at the heart of FP.

Finally we'll talk about practical approaches to Functional Programming in Scala, how you can and why you would use this style in your everyday work. This will _not_ be a talk about monads and type systems, but give you a pragmatic look at how to separate the syntactic sugar from the underlying principles.
Captions: 
	00:00:02,930 --> 00:00:08,130
cool first order of business the

00:00:07,020 --> 00:00:10,559
photographer and I were just chatting

00:00:08,130 --> 00:00:12,590
does anybody remember the sponsor that

00:00:10,559 --> 00:00:13,769
was giving away the fidgets thinners

00:00:12,590 --> 00:00:18,920
anyone

00:00:13,769 --> 00:00:21,810
no cake solutions are there any left no

00:00:18,920 --> 00:00:24,150
come on people if anybody finds me one

00:00:21,810 --> 00:00:25,199
you'll be my new best friend actually

00:00:24,150 --> 00:00:27,570
there's something that I'm going to get

00:00:25,199 --> 00:00:29,420
to at the end of the talk that I might

00:00:27,570 --> 00:00:32,250
come with a prize so keep that in mind

00:00:29,420 --> 00:00:34,680
all right we can get started

00:00:32,250 --> 00:00:36,420
so I renamed this talk recently and the

00:00:34,680 --> 00:00:38,339
talk title is a little bit unfair

00:00:36,420 --> 00:00:39,690
because redefining I'm basically just

00:00:38,339 --> 00:00:41,729
going to take things back to first

00:00:39,690 --> 00:00:43,049
principles these are hopefully things

00:00:41,729 --> 00:00:45,479
that you have heard before but I think

00:00:43,049 --> 00:00:48,120
the community has gotten to a point

00:00:45,479 --> 00:00:51,000
recently where we're disagreeing about

00:00:48,120 --> 00:00:52,440
how to define functional programming so

00:00:51,000 --> 00:00:54,720
I'm going to manage your expectations a

00:00:52,440 --> 00:00:56,070
little bit there the drama that I talked

00:00:54,720 --> 00:00:59,670
about we'll get to that later in the

00:00:56,070 --> 00:01:01,140
talk don't worry it'll be fun and like I

00:00:59,670 --> 00:01:02,580
mentioned redefining functional

00:01:01,140 --> 00:01:03,960
programming taking these back to first

00:01:02,580 --> 00:01:05,909
principles getting everybody on the same

00:01:03,960 --> 00:01:07,380
page to share some context and

00:01:05,909 --> 00:01:08,789
understanding about what we're talking

00:01:07,380 --> 00:01:11,640
about when we talk about functional

00:01:08,789 --> 00:01:13,560
programming in Scala and this is

00:01:11,640 --> 00:01:14,759
important because at conferences like

00:01:13,560 --> 00:01:15,869
this you're going to hear a lot of

00:01:14,759 --> 00:01:18,090
things you're going to hear a lot of

00:01:15,869 --> 00:01:20,880
buzzwords there are a lot of talks about

00:01:18,090 --> 00:01:23,130
syntactic sugar and a fancy abstractions

00:01:20,880 --> 00:01:24,600
out there so you reflect on the talks

00:01:23,130 --> 00:01:27,060
that you've already seen and the ones

00:01:24,600 --> 00:01:29,130
that you're going to go to today keep

00:01:27,060 --> 00:01:33,179
this in mind so that hopefully this

00:01:29,130 --> 00:01:35,369
doesn't happen by the way this is a real

00:01:33,179 --> 00:01:36,600
this is not a real book and I had to

00:01:35,369 --> 00:01:38,189
mention that because the last time I

00:01:36,600 --> 00:01:40,759
gave this talk somebody asked me where

00:01:38,189 --> 00:01:45,390
they could buy it so just for the record

00:01:40,759 --> 00:01:46,619
this is farce all right despite the fact

00:01:45,390 --> 00:01:48,929
that functional programming has been

00:01:46,619 --> 00:01:50,819
around for over 50 years we're still

00:01:48,929 --> 00:01:53,819
arguing about how to define it and this

00:01:50,819 --> 00:01:56,399
is especially relevant because last year

00:01:53,819 --> 00:01:58,799
this so-called standardized ladder of

00:01:56,399 --> 00:01:59,700
functional programming came out and I

00:01:58,799 --> 00:02:01,740
was talking about this with someone

00:01:59,700 --> 00:02:03,479
yesterday and if any of you were in the

00:02:01,740 --> 00:02:05,999
keynote this morning and woke up for it

00:02:03,479 --> 00:02:08,369
this is somebody that was trying to be

00:02:05,999 --> 00:02:11,090
provocative by creating this this ladder

00:02:08,369 --> 00:02:13,500
you can't read it but it goes from

00:02:11,090 --> 00:02:15,630
beginner skills at the top of skills

00:02:13,500 --> 00:02:17,370
like immutable data all the way down to

00:02:15,630 --> 00:02:21,600
expert with skills like graph reduction

00:02:17,370 --> 00:02:23,280
and pro functor optics that's cool but

00:02:21,600 --> 00:02:25,200
this is the state people were basically

00:02:23,280 --> 00:02:27,690
trolling and Here I am up here having

00:02:25,200 --> 00:02:30,000
the emotional reaction to it but this is

00:02:27,690 --> 00:02:33,840
all in sport of having a discussion

00:02:30,000 --> 00:02:36,180
around these topics so we'll come back

00:02:33,840 --> 00:02:38,040
to this don't worry but I introduced it

00:02:36,180 --> 00:02:39,810
now to frame our discussion around the

00:02:38,040 --> 00:02:42,900
idea that there are a lot of these

00:02:39,810 --> 00:02:44,910
so-called skills and topics that we use

00:02:42,900 --> 00:02:47,940
and talk about when we talk about

00:02:44,910 --> 00:02:49,680
functional programming and I think it's

00:02:47,940 --> 00:02:52,350
really easy to get caught up in the

00:02:49,680 --> 00:02:54,690
jargon and forget the core principles

00:02:52,350 --> 00:02:56,730
that the really make functional

00:02:54,690 --> 00:02:58,500
programming what it is and that's what

00:02:56,730 --> 00:03:00,330
I'm here to talk about the essentials of

00:02:58,500 --> 00:03:03,930
functional programming and why that

00:03:00,330 --> 00:03:05,580
matters to our community my name is

00:03:03,930 --> 00:03:07,140
Kelly Robinson I'm an engineering

00:03:05,580 --> 00:03:08,940
manager at share through in San

00:03:07,140 --> 00:03:12,260
Francisco we are an ADD tech company

00:03:08,940 --> 00:03:14,520
keeping the internet free you're welcome

00:03:12,260 --> 00:03:17,130
so I've been programming in Scala for

00:03:14,520 --> 00:03:19,050
about four years these days I work

00:03:17,130 --> 00:03:20,430
mostly with a team of Scala developers

00:03:19,050 --> 00:03:22,350
we're bringing data science into the

00:03:20,430 --> 00:03:23,820
organization so if anybody's in a

00:03:22,350 --> 00:03:26,430
similar role wants to talk about how you

00:03:23,820 --> 00:03:29,250
use Scala and spark for data science and

00:03:26,430 --> 00:03:30,810
also love to talk about that I also like

00:03:29,250 --> 00:03:34,020
complaining on the internet that's my

00:03:30,810 --> 00:03:37,080
Twitter handle be warned my Twitter

00:03:34,020 --> 00:03:40,680
right now is a mix of rants about tech

00:03:37,080 --> 00:03:43,950
US politics and the like you've been

00:03:40,680 --> 00:03:45,600
warned ok let's talk about what we're

00:03:43,950 --> 00:03:46,980
going to learn today so we're start with

00:03:45,600 --> 00:03:48,630
some origins look at a little bit of

00:03:46,980 --> 00:03:51,570
history for what functional programming

00:03:48,630 --> 00:03:54,360
is and how we got to this point define

00:03:51,570 --> 00:03:56,820
the essentials and then we'll talk about

00:03:54,360 --> 00:03:59,310
why this matters why this matters to you

00:03:56,820 --> 00:04:01,620
to our teams into the community and

00:03:59,310 --> 00:04:03,000
finally we'll talk about what we talk

00:04:01,620 --> 00:04:05,130
about or what we mean when we say

00:04:03,000 --> 00:04:07,800
functional programming in Scala and what

00:04:05,130 --> 00:04:09,390
that looks like I'll make these slides

00:04:07,800 --> 00:04:11,190
available after the talk so if any of

00:04:09,390 --> 00:04:12,660
the things that I link to are things

00:04:11,190 --> 00:04:14,910
that you want to look up after you will

00:04:12,660 --> 00:04:16,859
have links available to those after the

00:04:14,910 --> 00:04:20,220
talk I will tweet out the link to the

00:04:16,859 --> 00:04:23,490
slides alright let's start with some

00:04:20,220 --> 00:04:25,169
history excuse me so first of all when

00:04:23,490 --> 00:04:26,700
we talk about functional programming we

00:04:25,169 --> 00:04:29,220
call functional programming a paradigm

00:04:26,700 --> 00:04:32,190
and what do we mean when we say paradigm

00:04:29,220 --> 00:04:36,330
paradigm is a style or a way of doing

00:04:32,190 --> 00:04:39,180
something it is not a concrete thing

00:04:36,330 --> 00:04:40,980
like a language you can program this in

00:04:39,180 --> 00:04:43,200
the style like functional programming in

00:04:40,980 --> 00:04:45,810
any language but some languages make it

00:04:43,200 --> 00:04:47,730
easier to program in that style then

00:04:45,810 --> 00:04:50,370
others do and that's an important

00:04:47,730 --> 00:04:52,500
distinction to make right away like I

00:04:50,370 --> 00:04:53,790
mentioned it's just the style and you

00:04:52,500 --> 00:04:56,520
can do it in whatever language you

00:04:53,790 --> 00:04:58,140
choose Scala is an example of a language

00:04:56,520 --> 00:05:00,240
that makes it easy to program in the

00:04:58,140 --> 00:05:02,330
functional programming paradigm and

00:05:00,240 --> 00:05:04,500
we'll talk about reasons for that later

00:05:02,330 --> 00:05:06,480
how do we get here how do we get to the

00:05:04,500 --> 00:05:08,400
stereo so jose calderon

00:05:06,480 --> 00:05:10,770
who helped me a lot with this talk put

00:05:08,400 --> 00:05:13,410
it very well he said in the same way

00:05:10,770 --> 00:05:15,840
that music is not a set of instruments

00:05:13,410 --> 00:05:18,120
functional programming is not a set of

00:05:15,840 --> 00:05:21,510
abstractions that we need to learn and

00:05:18,120 --> 00:05:23,940
memorize and he goes on to say that

00:05:21,510 --> 00:05:25,919
functional programming is an approach to

00:05:23,940 --> 00:05:27,960
solving computational problems and

00:05:25,919 --> 00:05:30,200
approach let's look at some of the

00:05:27,960 --> 00:05:34,050
history that led us to this approach

00:05:30,200 --> 00:05:35,850
dating back to the 1930s we look at the

00:05:34,050 --> 00:05:39,120
lambda calculus this is when Alonzo

00:05:35,850 --> 00:05:41,100
Church pictured here introduced this

00:05:39,120 --> 00:05:43,919
idea of the lambda calculus and church

00:05:41,100 --> 00:05:45,320
was a mathematician and so what he

00:05:43,919 --> 00:05:47,880
figured out with a way to represent

00:05:45,320 --> 00:05:50,729
computation using what we now know as

00:05:47,880 --> 00:05:52,169
functions and the lambda calculus is one

00:05:50,729 --> 00:05:54,030
of those buzzword things that might

00:05:52,169 --> 00:05:55,320
sound a little intimidating to be honest

00:05:54,030 --> 00:05:57,150
I don't really know what it was until

00:05:55,320 --> 00:05:58,890
recently except that it was one of those

00:05:57,150 --> 00:06:00,600
things that we do actually know what it

00:05:58,890 --> 00:06:03,240
is we might just not know that it's

00:06:00,600 --> 00:06:06,720
called that or be able to define it off

00:06:03,240 --> 00:06:08,760
the fly for someone but this is the

00:06:06,720 --> 00:06:10,620
syntax to the lambda calculus and church

00:06:08,760 --> 00:06:12,630
created the syntax to represent his

00:06:10,620 --> 00:06:14,940
model of computation and the lambda

00:06:12,630 --> 00:06:17,580
calculus has three parts it uses the

00:06:14,940 --> 00:06:19,500
notion of variables it has a way of

00:06:17,580 --> 00:06:21,990
building functions that take in those

00:06:19,500 --> 00:06:25,680
variables in a way of applying the

00:06:21,990 --> 00:06:27,979
function to return a result in church's

00:06:25,680 --> 00:06:33,330
formal definition there are no types

00:06:27,979 --> 00:06:35,970
it's the simplest and most basic way to

00:06:33,330 --> 00:06:37,590
represent computation that there could

00:06:35,970 --> 00:06:39,750
be there's no internal state all

00:06:37,590 --> 00:06:40,750
functions are pure and have no side

00:06:39,750 --> 00:06:45,430
effects

00:06:40,750 --> 00:06:46,870
and here that is translated to Scala the

00:06:45,430 --> 00:06:48,190
Scala verse is a little bit of a red

00:06:46,870 --> 00:06:52,570
herring because like I said there's a

00:06:48,190 --> 00:06:54,700
type in the lambda calculus but it's the

00:06:52,570 --> 00:06:55,570
most simplest in general definition

00:06:54,700 --> 00:06:57,880
possible

00:06:55,570 --> 00:07:00,040
it also doesn't name its functions which

00:06:57,880 --> 00:07:04,630
is why we often associate lambdas with

00:07:00,040 --> 00:07:06,490
anonymous functions the lambda calculus

00:07:04,630 --> 00:07:08,710
could be considered one of the earliest

00:07:06,490 --> 00:07:10,720
functional programming languages except

00:07:08,710 --> 00:07:12,370
for it wasn't a programming language I

00:07:10,720 --> 00:07:14,740
guess because it didn't actually run on

00:07:12,370 --> 00:07:16,810
any computers but regardless it's a

00:07:14,740 --> 00:07:19,720
really big foundation for theoretical

00:07:16,810 --> 00:07:21,460
computer science and for the eventual

00:07:19,720 --> 00:07:24,700
paradigm that we know is functional

00:07:21,460 --> 00:07:27,220
programming and it's everywhere now so

00:07:24,700 --> 00:07:29,320
from things like AWS lambda which is

00:07:27,220 --> 00:07:32,320
basically Amazon's offering for

00:07:29,320 --> 00:07:33,970
functions as a service and then here is

00:07:32,320 --> 00:07:36,130
Philip wobbler who is a functional

00:07:33,970 --> 00:07:44,200
programming researcher and he is dressed

00:07:36,130 --> 00:07:46,690
as lambda man another computer science

00:07:44,200 --> 00:07:48,460
researcher later said that modern

00:07:46,690 --> 00:07:50,800
functional languages could all be

00:07:48,460 --> 00:07:53,440
thought of as non-trivial embellishments

00:07:50,800 --> 00:07:55,600
of the lambda calculus and he would be

00:07:53,440 --> 00:07:57,160
right because at the core of it when we

00:07:55,600 --> 00:07:59,380
think about the language as we use today

00:07:57,160 --> 00:08:00,940
whether they're languages that we think

00:07:59,380 --> 00:08:03,700
of as using for functional programming

00:08:00,940 --> 00:08:05,770
or not most of our modern languages have

00:08:03,700 --> 00:08:08,229
this idea of functions as a core

00:08:05,770 --> 00:08:10,510
abstraction to the language and that's

00:08:08,229 --> 00:08:13,600
why church's contribution of the lambda

00:08:10,510 --> 00:08:14,860
calculus matters so Church introduces

00:08:13,600 --> 00:08:16,750
this lambda calculus but he's a

00:08:14,860 --> 00:08:18,790
mathematician so it was kind of intense

00:08:16,750 --> 00:08:20,830
in his mind everything could be

00:08:18,790 --> 00:08:22,750
represented as a function so he was even

00:08:20,830 --> 00:08:27,070
representing things like boolean using

00:08:22,750 --> 00:08:29,260
functions and that's fine but again this

00:08:27,070 --> 00:08:30,610
wasn't a programming language so when we

00:08:29,260 --> 00:08:31,990
talk about introducing some of these

00:08:30,610 --> 00:08:33,729
concepts into actual programming

00:08:31,990 --> 00:08:35,469
languages it might surprise you to learn

00:08:33,729 --> 00:08:38,260
that some of the first programming

00:08:35,469 --> 00:08:41,320
language use of functional programming

00:08:38,260 --> 00:08:43,030
was written in Fortran so Fortran is

00:08:41,320 --> 00:08:45,190
also known as formula translator that's

00:08:43,030 --> 00:08:47,860
where the name comes from and this was

00:08:45,190 --> 00:08:50,080
invented by John Backus in the 1950s and

00:08:47,860 --> 00:08:52,270
there were a few important developments

00:08:50,080 --> 00:08:54,580
that came with Fortran so it was

00:08:52,270 --> 00:08:56,170
popularized as a higher-level language

00:08:54,580 --> 00:08:59,589
for that most people were writing in

00:08:56,170 --> 00:09:01,149
assembly so very procedural do this and

00:08:59,589 --> 00:09:02,769
then that there wasn't a lot of

00:09:01,149 --> 00:09:04,839
abstraction that was happening so

00:09:02,769 --> 00:09:07,600
Fortran became popular as that first

00:09:04,839 --> 00:09:08,950
higher order a higher-level language

00:09:07,600 --> 00:09:11,829
that provided some of these abstractions

00:09:08,950 --> 00:09:13,000
that we now take for granted it's really

00:09:11,829 --> 00:09:14,050
hard to think about things like

00:09:13,000 --> 00:09:16,149
functions when you're programming

00:09:14,050 --> 00:09:18,399
something like assembly you can't really

00:09:16,149 --> 00:09:21,459
do it and some of the other things that

00:09:18,399 --> 00:09:23,829
Fortran allowed us was were introduced

00:09:21,459 --> 00:09:26,950
to for this paradigm were things like it

00:09:23,829 --> 00:09:28,600
allowed mathematical operators inside of

00:09:26,950 --> 00:09:30,579
your syntax so things like plus and

00:09:28,600 --> 00:09:32,700
minus we're now possible and it also

00:09:30,579 --> 00:09:34,930
allowed the nesting of function calls

00:09:32,700 --> 00:09:38,760
something we take for granted now again

00:09:34,930 --> 00:09:38,760
but it was a big development at the time

00:09:39,690 --> 00:09:45,339
around the same time a couple of other

00:09:42,820 --> 00:09:48,010
researchers were trying to invent some

00:09:45,339 --> 00:09:49,930
of the first AI programs and so Alan

00:09:48,010 --> 00:09:52,180
Newell and Herbert Simon were trying to

00:09:49,930 --> 00:09:54,279
write a chess game and what they figured

00:09:52,180 --> 00:09:56,589
out was in order to represent something

00:09:54,279 --> 00:09:59,790
like a chess game they needed a new way

00:09:56,589 --> 00:10:03,339
to program and represent their logic and

00:09:59,790 --> 00:10:06,459
they invented something called the logic

00:10:03,339 --> 00:10:09,279
theory machine to do this and that works

00:10:06,459 --> 00:10:11,500
by writing and combining many small and

00:10:09,279 --> 00:10:15,459
simple subroutines into larger and more

00:10:11,500 --> 00:10:17,680
complicated problems before this point

00:10:15,459 --> 00:10:20,110
everyone else is saying that a program

00:10:17,680 --> 00:10:22,209
was a sequence of instructions and there

00:10:20,110 --> 00:10:24,250
weren't these kinds of abstractions this

00:10:22,209 --> 00:10:26,079
is a time that it wasn't previous as

00:10:24,250 --> 00:10:28,630
possible to just combine a bunch of

00:10:26,079 --> 00:10:30,760
simple subroutines combining subroutines

00:10:28,630 --> 00:10:32,620
takes a lot of processing power in the

00:10:30,760 --> 00:10:38,680
1950s the hardware was catching up to

00:10:32,620 --> 00:10:40,180
make this plausible and feasible so

00:10:38,680 --> 00:10:42,370
Newell and Simon gave us something else

00:10:40,180 --> 00:10:45,190
with their research what they realized

00:10:42,370 --> 00:10:46,750
was that in order to process data using

00:10:45,190 --> 00:10:48,790
those subroutines they had to find a way

00:10:46,750 --> 00:10:50,920
to store the data and so they

00:10:48,790 --> 00:10:52,720
essentially invented what we now know is

00:10:50,920 --> 00:10:54,459
linked lists and they brought us a list

00:10:52,720 --> 00:10:57,880
processing with this data structure

00:10:54,459 --> 00:11:00,310
invention so they invented the IPL the

00:10:57,880 --> 00:11:02,709
information processing language and the

00:11:00,310 --> 00:11:04,990
IPL was able to do this list processing

00:11:02,709 --> 00:11:06,850
that we now use so often in many of the

00:11:04,990 --> 00:11:08,290
functional programming languages that we

00:11:06,850 --> 00:11:10,270
think of today

00:11:08,290 --> 00:11:12,340
the data was stored like I said and what

00:11:10,270 --> 00:11:14,170
we think of as linked list and that

00:11:12,340 --> 00:11:16,450
allowed them to do list manipulation

00:11:14,170 --> 00:11:19,230
even in a very limited way but it was a

00:11:16,450 --> 00:11:22,630
really big innovation for the time

00:11:19,230 --> 00:11:24,820
IPL also introduced more general higher

00:11:22,630 --> 00:11:30,970
order functions which is something that

00:11:24,820 --> 00:11:33,460
enabled recursion what happened next was

00:11:30,970 --> 00:11:35,800
Newell and McCarthy went to this AI

00:11:33,460 --> 00:11:37,930
conference with their friend John or

00:11:35,800 --> 00:11:39,310
Newell and Simon sorry went to this AI

00:11:37,930 --> 00:11:41,590
conference with their friend John

00:11:39,310 --> 00:11:43,000
McCarthy and McCarthy was already doing

00:11:41,590 --> 00:11:45,670
some stuff in the functional programming

00:11:43,000 --> 00:11:47,680
space he had added some stuff to Fortran

00:11:45,670 --> 00:11:49,930
some conditional operators to Fortran

00:11:47,680 --> 00:11:51,340
and he was already actively involved in

00:11:49,930 --> 00:11:53,410
the development of this paradigm but

00:11:51,340 --> 00:11:55,030
McCarthy was listening to what Nuland

00:11:53,410 --> 00:11:56,980
Simon had been doing and said hey those

00:11:55,030 --> 00:11:58,630
really pretty good ideas I'm going to

00:11:56,980 --> 00:12:02,380
take those and build them into mining

00:11:58,630 --> 00:12:04,230
language that he named list and list is

00:12:02,380 --> 00:12:06,460
widely recognized as the first

00:12:04,230 --> 00:12:08,050
mainstream functional programming

00:12:06,460 --> 00:12:10,600
language the first general-purpose

00:12:08,050 --> 00:12:12,400
functional programming language and it

00:12:10,600 --> 00:12:14,560
took many of the ideas that we already

00:12:12,400 --> 00:12:16,630
discussed and put them into one package

00:12:14,560 --> 00:12:18,940
that made it easy to use as the

00:12:16,630 --> 00:12:21,400
programmer it enabled the program would

00:12:18,940 --> 00:12:24,040
write in this functional style in a way

00:12:21,400 --> 00:12:26,410
that made sense that was reusable that

00:12:24,040 --> 00:12:28,960
you were able to come back to and that's

00:12:26,410 --> 00:12:30,880
why Lisp is important because it was the

00:12:28,960 --> 00:12:32,890
first language that combined all of

00:12:30,880 --> 00:12:35,700
these styles and really encapsulated

00:12:32,890 --> 00:12:37,840
this functional programming paradigm

00:12:35,700 --> 00:12:39,580
bringing all together this history that

00:12:37,840 --> 00:12:41,920
we mentioned you can see how these

00:12:39,580 --> 00:12:44,950
concepts evolved into something that we

00:12:41,920 --> 00:12:47,440
recognize today and this history matters

00:12:44,950 --> 00:12:50,320
because it's shaped functional

00:12:47,440 --> 00:12:53,110
programming into what we now know these

00:12:50,320 --> 00:12:56,050
concepts so things obscures the logic

00:12:53,110 --> 00:12:59,170
theory machine maybe or as dated as

00:12:56,050 --> 00:13:01,960
Fortran may seem these concepts matter

00:12:59,170 --> 00:13:06,010
because they defined the paradigm as we

00:13:01,960 --> 00:13:08,220
know it now you have a pretty good idea

00:13:06,010 --> 00:13:10,450
of where some of this stuff came from

00:13:08,220 --> 00:13:12,940
one thing I wanted to highlight is that

00:13:10,450 --> 00:13:15,010
in doing this and inventing this new

00:13:12,940 --> 00:13:18,490
paradigm these researchers weren't

00:13:15,010 --> 00:13:20,800
trying to invent a paradigm they did

00:13:18,490 --> 00:13:21,640
this or they discovered this new style

00:13:20,800 --> 00:13:23,560
of programming

00:13:21,640 --> 00:13:25,960
they were trying to solve problems and

00:13:23,560 --> 00:13:28,840
they needed a new style a new way to do

00:13:25,960 --> 00:13:31,210
things in order to make their operations

00:13:28,840 --> 00:13:33,820
and their problem makes sense and work

00:13:31,210 --> 00:13:36,490
and much of that had to do with making

00:13:33,820 --> 00:13:38,920
programming easier and more

00:13:36,490 --> 00:13:40,720
understandable to the programmer and I

00:13:38,920 --> 00:13:42,460
think that's a huge tenant of what

00:13:40,720 --> 00:13:44,590
functional programming is from it's very

00:13:42,460 --> 00:13:46,180
beginning functional programming was

00:13:44,590 --> 00:13:50,740
about making programming more

00:13:46,180 --> 00:13:52,330
understandable to the user and that

00:13:50,740 --> 00:13:54,280
brings us to the essentials and this is

00:13:52,330 --> 00:13:55,990
where I'm going to define what I want to

00:13:54,280 --> 00:13:57,790
talk about as the definition of

00:13:55,990 --> 00:13:59,830
functional programming what are the

00:13:57,790 --> 00:14:02,320
essentials of functional programming and

00:13:59,830 --> 00:14:07,000
why that style that was formed plays

00:14:02,320 --> 00:14:09,610
into this don't want to bury the lead

00:14:07,000 --> 00:14:11,740
here if you can understand expressions

00:14:09,610 --> 00:14:14,110
and data structures you can understand

00:14:11,740 --> 00:14:16,300
functional programming these are the two

00:14:14,110 --> 00:14:20,620
key components of functional programming

00:14:16,300 --> 00:14:22,630
expressions and data structures and when

00:14:20,620 --> 00:14:23,980
we talk about this idea of contemporary

00:14:22,630 --> 00:14:26,380
functional programming I'm going to talk

00:14:23,980 --> 00:14:28,180
about it from the lens of 1975 and I'll

00:14:26,380 --> 00:14:30,220
mention why that dates important on the

00:14:28,180 --> 00:14:32,290
next slide but for those of you that

00:14:30,220 --> 00:14:34,030
don't know 1975 was also the year that's

00:14:32,290 --> 00:14:35,440
Saturday Night Live premiered so that

00:14:34,030 --> 00:14:38,740
was the best picture I could come up

00:14:35,440 --> 00:14:40,150
with from there but this is a bit of an

00:14:38,740 --> 00:14:42,190
arbitrary date but I wanted to bring

00:14:40,150 --> 00:14:44,680
things more into the modern era but also

00:14:42,190 --> 00:14:46,690
show you that functional programming

00:14:44,680 --> 00:14:48,820
it's not that different than it wasn't

00:14:46,690 --> 00:14:50,740
70s a lot of the core concepts these

00:14:48,820 --> 00:14:54,640
ideas of expressions and data structures

00:14:50,740 --> 00:14:57,790
haven't changed since then so Jose

00:14:54,640 --> 00:14:59,620
Calderon who I mentioned earlier he's

00:14:57,790 --> 00:15:01,660
writing a great series of blog post

00:14:59,620 --> 00:15:04,420
distilling the work of William H Burch

00:15:01,660 --> 00:15:08,140
and Burge published this book recursive

00:15:04,420 --> 00:15:09,580
programming techniques in 1975 and a lot

00:15:08,140 --> 00:15:11,740
of the concepts that he talks about

00:15:09,580 --> 00:15:14,280
about defining functional programming

00:15:11,740 --> 00:15:17,230
they haven't changed to this date

00:15:14,280 --> 00:15:19,390
especially because in 1975 we didn't

00:15:17,230 --> 00:15:20,890
have a lot of the fancy abstractions and

00:15:19,390 --> 00:15:23,800
things that we hear about from internet

00:15:20,890 --> 00:15:26,110
commentators so just for an example

00:15:23,800 --> 00:15:28,390
things we didn't have we didn't have

00:15:26,110 --> 00:15:31,000
polymorphic type inference we didn't

00:15:28,390 --> 00:15:32,920
have algebraic data types we didn't have

00:15:31,000 --> 00:15:34,780
lazy languages so those came soon after

00:15:32,920 --> 00:15:35,470
and we definitely didn't have a lot of

00:15:34,780 --> 00:15:37,570
this category

00:15:35,470 --> 00:15:39,970
theoretic terminology being applied to

00:15:37,570 --> 00:15:42,520
programming it's okay if you don't know

00:15:39,970 --> 00:15:44,500
what happens are I'll show you the

00:15:42,520 --> 00:15:46,450
essentials and how knowing the

00:15:44,500 --> 00:15:48,160
essentials will give you the tools and

00:15:46,450 --> 00:15:50,290
the power to be able to do what you need

00:15:48,160 --> 00:15:51,970
to do in your programs and now we'll

00:15:50,290 --> 00:15:54,880
talk about what we do have the

00:15:51,970 --> 00:15:59,070
fundamentals that that Burge mentioned

00:15:54,880 --> 00:16:01,660
in 1975 in order to define this paradigm

00:15:59,070 --> 00:16:03,760
first of all functional programming is

00:16:01,660 --> 00:16:05,620
stuff it doesn't care about your type

00:16:03,760 --> 00:16:07,060
system it doesn't care about monads this

00:16:05,620 --> 00:16:09,640
is not what functional programming is

00:16:07,060 --> 00:16:11,170
about the whole motivation for this talk

00:16:09,640 --> 00:16:13,000
was to clarify that you don't need to

00:16:11,170 --> 00:16:15,100
understand or know these things to be

00:16:13,000 --> 00:16:17,740
able to use this in your day-to-day

00:16:15,100 --> 00:16:19,840
programming in order to be a competent

00:16:17,740 --> 00:16:22,900
functional programmer you don't need to

00:16:19,840 --> 00:16:24,550
be able to define these and be the

00:16:22,900 --> 00:16:26,440
person that's talking about this all the

00:16:24,550 --> 00:16:29,200
time in order to be a competent

00:16:26,440 --> 00:16:30,910
functional programmer and you can

00:16:29,200 --> 00:16:32,620
replace monads in type systems here with

00:16:30,910 --> 00:16:33,880
whatever jargon you want I think what's

00:16:32,620 --> 00:16:37,240
what's the one I've been hearing about a

00:16:33,880 --> 00:16:40,950
lot this conference I what is it

00:16:37,240 --> 00:16:43,420
tagless final what is it

00:16:40,950 --> 00:16:45,820
tagos final interpreters I don't know

00:16:43,420 --> 00:16:47,760
what that is but it's you know it's not

00:16:45,820 --> 00:16:50,020
essential to functional programming

00:16:47,760 --> 00:16:52,030
functional program is about expressions

00:16:50,020 --> 00:16:55,090
and data structures start with

00:16:52,030 --> 00:16:56,970
expressions we talk about the essentials

00:16:55,090 --> 00:16:59,530
functional programming is all about

00:16:56,970 --> 00:17:02,920
representing your programs logic your

00:16:59,530 --> 00:17:05,770
programs using expressions instead of

00:17:02,920 --> 00:17:07,150
statements and the concepts and the

00:17:05,770 --> 00:17:09,310
skills that we think of as being

00:17:07,150 --> 00:17:13,750
functional programming abstractions

00:17:09,310 --> 00:17:16,720
those all have roots in expressions this

00:17:13,750 --> 00:17:18,760
idea of expressions expressions all the

00:17:16,720 --> 00:17:21,280
way down what do we mean when we talk

00:17:18,760 --> 00:17:23,140
about expressions well it helps to think

00:17:21,280 --> 00:17:26,170
about expressions in terms of their

00:17:23,140 --> 00:17:28,720
constituent parts and this allows you

00:17:26,170 --> 00:17:30,490
the programmer to isolate the different

00:17:28,720 --> 00:17:33,990
parts of your program and break things

00:17:30,490 --> 00:17:36,250
down so that they're more understandable

00:17:33,990 --> 00:17:38,380
here's a simple expression we can more

00:17:36,250 --> 00:17:42,580
easily break this down if we represent

00:17:38,380 --> 00:17:44,230
it using in fix notation a little bit of

00:17:42,580 --> 00:17:44,470
a middle school algebra for you here

00:17:44,230 --> 00:17:48,130
today

00:17:44,470 --> 00:17:49,270
so here the operators okay well backing

00:17:48,130 --> 00:17:51,730
up a little bit for

00:17:49,270 --> 00:17:53,740
urghhh emphasizes that you can break

00:17:51,730 --> 00:17:55,480
things down more easily by stressing the

00:17:53,740 --> 00:17:57,310
difference between the operator and the

00:17:55,480 --> 00:17:59,320
operand in your programs and those are

00:17:57,310 --> 00:18:01,330
part of the isolation that we do in

00:17:59,320 --> 00:18:04,990
order to represent the computation and

00:18:01,330 --> 00:18:07,120
here the operators are the plus x and

00:18:04,990 --> 00:18:09,220
the square all the operands are the

00:18:07,120 --> 00:18:13,150
things that we're operating on are the 3

00:18:09,220 --> 00:18:15,310
the X and the y if we give X and y

00:18:13,150 --> 00:18:17,350
values we can look at how this

00:18:15,310 --> 00:18:19,900
expression is broken down into smaller

00:18:17,350 --> 00:18:21,520
parts I hope your work isn't basic

00:18:19,900 --> 00:18:23,980
algebra but this is the example to

00:18:21,520 --> 00:18:26,320
illustrate how we use expressions in our

00:18:23,980 --> 00:18:28,530
programs to isolate and break our code

00:18:26,320 --> 00:18:31,090
into smaller and more manageable pieces

00:18:28,530 --> 00:18:33,460
this shows one of the tenants of

00:18:31,090 --> 00:18:36,360
functional programming it's essential to

00:18:33,460 --> 00:18:38,980
this idea of using expressions

00:18:36,360 --> 00:18:40,990
functional programming encourages us to

00:18:38,980 --> 00:18:45,430
build bigger programs out of smaller

00:18:40,990 --> 00:18:48,010
parts and those parts that we can

00:18:45,430 --> 00:18:50,410
understand in isolation and we do this

00:18:48,010 --> 00:18:53,920
in part by separating concerns and that

00:18:50,410 --> 00:18:56,170
helps us build understandings you can

00:18:53,920 --> 00:18:58,510
see how we evaluated everything piece by

00:18:56,170 --> 00:19:03,520
piece in order to achieve our final

00:18:58,510 --> 00:19:05,050
results I wanted to quickly talk about

00:19:03,520 --> 00:19:06,640
side effects because this is something

00:19:05,050 --> 00:19:09,760
that comes hand in hand when you talk

00:19:06,640 --> 00:19:11,380
about expressions a reminder that side

00:19:09,760 --> 00:19:12,880
effects are not inherently bad there are

00:19:11,380 --> 00:19:16,150
side effects that are necessary things

00:19:12,880 --> 00:19:18,430
like logging but they do have some

00:19:16,150 --> 00:19:20,230
downsides you want a program without

00:19:18,430 --> 00:19:21,730
side effects as much as possible in this

00:19:20,230 --> 00:19:24,090
style because side effects aren't is

00:19:21,730 --> 00:19:26,620
predictable and they they come with some

00:19:24,090 --> 00:19:29,470
they can complicate things in certain

00:19:26,620 --> 00:19:32,860
ways we say function aside affecting if

00:19:29,470 --> 00:19:34,380
it modifies stayed outside of a scope so

00:19:32,860 --> 00:19:36,820
things like changing a global variable

00:19:34,380 --> 00:19:38,530
every time you're doing a for loop and

00:19:36,820 --> 00:19:40,780
an imperative style language doing that

00:19:38,530 --> 00:19:43,180
I plus plus you're modifying state

00:19:40,780 --> 00:19:44,710
that's a side effect this is something

00:19:43,180 --> 00:19:47,470
that we see all the time in those types

00:19:44,710 --> 00:19:49,480
of languages side effects also occur

00:19:47,470 --> 00:19:51,490
when you're dealing with the world

00:19:49,480 --> 00:19:53,050
outside of your program so anytime you

00:19:51,490 --> 00:19:54,940
make an API request or print to the

00:19:53,050 --> 00:19:57,760
console that's also a side effect and

00:19:54,940 --> 00:19:59,710
this approach can be fragile it's not as

00:19:57,760 --> 00:20:01,180
predictable but again you need side

00:19:59,710 --> 00:20:02,610
effects to do anything useful in your

00:20:01,180 --> 00:20:04,049
programs you're going to have to enter

00:20:02,610 --> 00:20:05,340
after the user at some point or your

00:20:04,049 --> 00:20:10,410
programs not going to be very

00:20:05,340 --> 00:20:11,760
interesting or helpful to anyone so it's

00:20:10,410 --> 00:20:15,120
a little bit about what side-effects are

00:20:11,760 --> 00:20:16,710
and taking this back to expressions we

00:20:15,120 --> 00:20:18,660
want to use expressions instead of

00:20:16,710 --> 00:20:20,309
statements and some related properties

00:20:18,660 --> 00:20:22,650
of expressions that we think about are

00:20:20,309 --> 00:20:28,049
these ideas of pure functions and of

00:20:22,650 --> 00:20:30,960
immutable data and when expression has

00:20:28,049 --> 00:20:33,390
no side effects we call it pure and a

00:20:30,960 --> 00:20:36,120
pure function is also said to have this

00:20:33,390 --> 00:20:37,799
idea of referential transparency the

00:20:36,120 --> 00:20:39,990
referential transparency is the idea

00:20:37,799 --> 00:20:42,330
that you can place your expression bias

00:20:39,990 --> 00:20:44,280
value so in the expression that we

00:20:42,330 --> 00:20:45,990
showed we would replace 3x plus y with

00:20:44,280 --> 00:20:48,150
the values that we gave for X and y with

00:20:45,990 --> 00:20:50,190
13 and that's not going to change the

00:20:48,150 --> 00:20:51,780
result there's no side effects in there

00:20:50,190 --> 00:20:53,760
we weren't expecting that to print

00:20:51,780 --> 00:20:55,950
anything out to make any other calls to

00:20:53,760 --> 00:20:57,690
tell somebody to do something it's

00:20:55,950 --> 00:20:59,160
exactly the same as replacing the

00:20:57,690 --> 00:21:01,440
expression with the value that's what

00:20:59,160 --> 00:21:03,270
referential transparency means and this

00:21:01,440 --> 00:21:06,750
makes it easier to reason about the

00:21:03,270 --> 00:21:09,630
behavior of our programs immutable data

00:21:06,750 --> 00:21:12,150
is also a huge bonus for expressions if

00:21:09,630 --> 00:21:14,010
we were modifying state constantly we

00:21:12,150 --> 00:21:16,080
would lose a lot of the benefits that we

00:21:14,010 --> 00:21:18,540
talked about about isolating logic and

00:21:16,080 --> 00:21:20,400
breaking our problems down it wouldn't

00:21:18,540 --> 00:21:24,450
be as easy to reason about how things

00:21:20,400 --> 00:21:26,460
are working stateful programming is

00:21:24,450 --> 00:21:27,900
something that's inherently complex and

00:21:26,460 --> 00:21:29,940
this is something that rich Hickey talks

00:21:27,900 --> 00:21:31,710
about in his talk a simple made easy

00:21:29,940 --> 00:21:35,130
which Martin referenced in this keynote

00:21:31,710 --> 00:21:36,630
on Wednesday and I think it's a really

00:21:35,130 --> 00:21:39,860
great talk first of all if you haven't

00:21:36,630 --> 00:21:42,240
seen it but the idea that that

00:21:39,860 --> 00:21:43,950
programming with state is inherently

00:21:42,240 --> 00:21:46,679
complex comes from the idea that you're

00:21:43,950 --> 00:21:49,500
mixing data and time and those are two

00:21:46,679 --> 00:21:53,059
concepts that are hard to predictably

00:21:49,500 --> 00:21:55,620
interleave and that's why replacing

00:21:53,059 --> 00:21:57,870
state with values using your data

00:21:55,620 --> 00:22:00,059
representing it using values is really

00:21:57,870 --> 00:22:01,590
valuable to you the programmer in order

00:22:00,059 --> 00:22:04,380
to be able to understand how things are

00:22:01,590 --> 00:22:08,870
working so actually a lot simpler in the

00:22:04,380 --> 00:22:08,870
long run to think about data as values

00:22:09,380 --> 00:22:13,679
bringing us together most functional

00:22:11,610 --> 00:22:16,240
programming encourages the approach of

00:22:13,679 --> 00:22:18,520
using pure functions for as much as

00:22:16,240 --> 00:22:20,830
of your programming as possible of

00:22:18,520 --> 00:22:23,020
avoiding side-effects until you need

00:22:20,830 --> 00:22:25,600
them to minimize the amount of

00:22:23,020 --> 00:22:27,640
unpredictability that there is and pure

00:22:25,600 --> 00:22:29,830
functions are also infinitely easier to

00:22:27,640 --> 00:22:31,990
unit test and so you can think about

00:22:29,830 --> 00:22:33,400
this remember that this is a style of

00:22:31,990 --> 00:22:35,710
functional programming is a style you

00:22:33,400 --> 00:22:37,480
can use this in any language and so if

00:22:35,710 --> 00:22:38,890
you're doing any amount of testing in

00:22:37,480 --> 00:22:41,890
your codes which I really hope all of

00:22:38,890 --> 00:22:44,380
you are you can program in this style in

00:22:41,890 --> 00:22:46,690
your Scala code in your JavaScript code

00:22:44,380 --> 00:22:48,790
and your Python code in order to be able

00:22:46,690 --> 00:22:50,980
to better unit test these individual

00:22:48,790 --> 00:22:53,380
parts these isolated parts and be able

00:22:50,980 --> 00:22:55,720
to get the expected result back and know

00:22:53,380 --> 00:22:57,400
how your programs are behaving and this

00:22:55,720 --> 00:22:59,890
is a way that you can avoid using things

00:22:57,400 --> 00:23:01,660
like testing mocks as much if you're in

00:22:59,890 --> 00:23:03,070
a program and you have to write a lot of

00:23:01,660 --> 00:23:04,720
test feed mocks in order to be able to

00:23:03,070 --> 00:23:06,370
test the behavior of your code that

00:23:04,720 --> 00:23:09,270
might be a sign that you need to break

00:23:06,370 --> 00:23:09,270
things down more

00:23:10,350 --> 00:23:15,100
continuing with Burge and his insights

00:23:12,430 --> 00:23:17,080
from his book the next big insight that

00:23:15,100 --> 00:23:19,240
he had was in data structures and so

00:23:17,080 --> 00:23:21,550
what Burge said was instead of thinking

00:23:19,240 --> 00:23:24,400
about the location or the layout of data

00:23:21,550 --> 00:23:26,560
he wants to think of our us us to think

00:23:24,400 --> 00:23:28,960
of our data in a couple of ways so first

00:23:26,560 --> 00:23:31,060
how do you construct the data how do you

00:23:28,960 --> 00:23:33,040
put it together and then how do you

00:23:31,060 --> 00:23:37,030
deconstruct the data or take it apart

00:23:33,040 --> 00:23:38,770
and in order to represent this using

00:23:37,030 --> 00:23:41,890
Scala we're going to create a linked

00:23:38,770 --> 00:23:43,960
list data structure we can make this

00:23:41,890 --> 00:23:45,850
idea of constructing and deconstructing

00:23:43,960 --> 00:23:48,370
data more explicit by representing this

00:23:45,850 --> 00:23:50,860
in Scala and there's going to be some

00:23:48,370 --> 00:23:53,200
code in the next few slides there to

00:23:50,860 --> 00:23:56,050
illustrate some patterns don't get too

00:23:53,200 --> 00:23:58,230
hung up on the individual syntax of the

00:23:56,050 --> 00:24:00,250
slides but we can think about

00:23:58,230 --> 00:24:02,740
constructing or list in a couple of ways

00:24:00,250 --> 00:24:03,940
so if you're constructing a list you

00:24:02,740 --> 00:24:05,860
either going to have something you're

00:24:03,940 --> 00:24:07,180
going to have a constructor the cons or

00:24:05,860 --> 00:24:08,320
you're going to have nothing the null

00:24:07,180 --> 00:24:09,610
value and then you're going to have to

00:24:08,320 --> 00:24:12,370
know what to do when you don't have

00:24:09,610 --> 00:24:13,630
anything to put in your list in the same

00:24:12,370 --> 00:24:15,760
thing you can think about that when

00:24:13,630 --> 00:24:17,980
we're taking our list apart when we're

00:24:15,760 --> 00:24:19,930
doing any kind of operation on our list

00:24:17,980 --> 00:24:22,860
every function on that would be

00:24:19,930 --> 00:24:25,630
deconstructed using something like this

00:24:22,860 --> 00:24:27,550
every function is either going to have

00:24:25,630 --> 00:24:29,260
to decide what to do when it has an

00:24:27,550 --> 00:24:30,010
element in the list or have to provide

00:24:29,260 --> 00:24:32,080
some kind of

00:24:30,010 --> 00:24:34,810
fault action when it has nothing in the

00:24:32,080 --> 00:24:37,120
list and once you have this kind of

00:24:34,810 --> 00:24:39,400
function you can start to use this to

00:24:37,120 --> 00:24:42,250
define functions on our list so for

00:24:39,400 --> 00:24:43,840
example we can write a length function

00:24:42,250 --> 00:24:45,550
on our list and in the case where we

00:24:43,840 --> 00:24:48,130
have something in the list we have one

00:24:45,550 --> 00:24:52,030
we have nothing in the list we have zero

00:24:48,130 --> 00:24:53,920
that's the default value similarly the

00:24:52,030 --> 00:24:55,600
sum function our list if we want to sum

00:24:53,920 --> 00:24:57,100
all the elements in our list together we

00:24:55,600 --> 00:24:58,780
add the head of the list to the

00:24:57,100 --> 00:25:01,830
recursive some of the tail and again if

00:24:58,780 --> 00:25:04,600
there's nothing in the list we add zero

00:25:01,830 --> 00:25:06,970
very similar for taking the product of

00:25:04,600 --> 00:25:08,560
the elements in our list we can add or

00:25:06,970 --> 00:25:10,630
multiply the head of the list to the

00:25:08,560 --> 00:25:12,970
recursive sum and then the default value

00:25:10,630 --> 00:25:14,950
there becomes one and you start to see

00:25:12,970 --> 00:25:16,930
the pattern here the pattern of how

00:25:14,950 --> 00:25:18,550
we're deconstructing the data the

00:25:16,930 --> 00:25:21,580
similarities of how we're doing these

00:25:18,550 --> 00:25:23,380
operations on our list and what we can

00:25:21,580 --> 00:25:26,230
do is actually represent those

00:25:23,380 --> 00:25:27,670
operations in a more generic form and

00:25:26,230 --> 00:25:29,590
this is something that we can use to

00:25:27,670 --> 00:25:32,500
represent those other functions and

00:25:29,590 --> 00:25:36,040
abstract away that deconstruction in a

00:25:32,500 --> 00:25:38,530
more generic way that allows us to then

00:25:36,040 --> 00:25:41,680
rewrite our other lengths some product

00:25:38,530 --> 00:25:44,230
functions like something like this and

00:25:41,680 --> 00:25:46,780
so you take this helper function that we

00:25:44,230 --> 00:25:48,250
define and then the idea of functional

00:25:46,780 --> 00:25:50,230
programming that comes into this as

00:25:48,250 --> 00:25:52,360
we've isolated the parts of the program

00:25:50,230 --> 00:25:55,660
that are different we've thought about

00:25:52,360 --> 00:25:58,060
how to deconstruct our data and abstract

00:25:55,660 --> 00:26:00,430
things away so that the programmer you

00:25:58,060 --> 00:26:04,600
is less with the interesting parts the

00:26:00,430 --> 00:26:06,250
actual intelligent thing that you have

00:26:04,600 --> 00:26:07,750
to decide what to do with your program

00:26:06,250 --> 00:26:09,820
and this whole class of functions

00:26:07,750 --> 00:26:11,770
becomes apparent and you can think of

00:26:09,820 --> 00:26:15,340
how to define other functions using this

00:26:11,770 --> 00:26:17,020
kind of abstraction and that allows you

00:26:15,340 --> 00:26:19,150
to focus on the parts that are different

00:26:17,020 --> 00:26:21,190
focus on the logic that you want to add

00:26:19,150 --> 00:26:24,010
into these functions in order to make

00:26:21,190 --> 00:26:26,950
them work for what you need to do and

00:26:24,010 --> 00:26:28,600
this is a huge thesis of Burgess work if

00:26:26,950 --> 00:26:31,050
you can understand data structures and

00:26:28,600 --> 00:26:33,460
expressions you're good to go

00:26:31,050 --> 00:26:35,650
thinking about data structures even more

00:26:33,460 --> 00:26:37,510
the functional programming allows the

00:26:35,650 --> 00:26:39,640
structure of your programs to match the

00:26:37,510 --> 00:26:41,610
structure of your data and when you do

00:26:39,640 --> 00:26:43,450
this you're left with the idea of

00:26:41,610 --> 00:26:45,429
focusing on the

00:26:43,450 --> 00:26:47,259
and challenging parts for you your

00:26:45,429 --> 00:26:52,779
business logic that you actually need to

00:26:47,259 --> 00:26:54,190
spend time thinking about so I thought

00:26:52,779 --> 00:26:56,829
this was pretty interesting I saw this

00:26:54,190 --> 00:26:59,289
on Twitter just about a month ago I

00:26:56,829 --> 00:27:01,899
don't know if this person has ever met

00:26:59,289 --> 00:27:03,369
bird or read his work but Michael here

00:27:01,899 --> 00:27:05,289
observes that when he's stuck in a

00:27:03,369 --> 00:27:06,999
problem the answer is always think

00:27:05,289 --> 00:27:09,429
harder about my data structures or I'm

00:27:06,999 --> 00:27:12,070
doing too much in one step and so he's

00:27:09,429 --> 00:27:15,759
coming to the same conclusions in 2017

00:27:12,070 --> 00:27:17,769
that bird came to in 1975 I think this

00:27:15,759 --> 00:27:19,599
goes to show that a lot of things

00:27:17,769 --> 00:27:21,639
haven't materially changed since then

00:27:19,599 --> 00:27:23,200
there's been a lot of innovations

00:27:21,639 --> 00:27:25,239
there's a lot of stuff that we're doing

00:27:23,200 --> 00:27:27,669
now that's making it cool and more

00:27:25,239 --> 00:27:29,889
interesting and in some ways easier for

00:27:27,669 --> 00:27:32,139
us but the core principles of functional

00:27:29,889 --> 00:27:35,259
programming haven't changed in a long

00:27:32,139 --> 00:27:37,209
time they're not changing and we can be

00:27:35,259 --> 00:27:41,589
effective as functional programmers by

00:27:37,209 --> 00:27:43,029
keeping those core principles in mind so

00:27:41,589 --> 00:27:44,649
with a pretty intense distillation of

00:27:43,029 --> 00:27:46,299
functional programming now let's get

00:27:44,649 --> 00:27:50,950
into the fun part why does this matter

00:27:46,299 --> 00:27:53,099
for you back to this ladder so there are

00:27:50,950 --> 00:27:57,070
44 concepts listed here

00:27:53,099 --> 00:27:58,959
44 concepts last year I talked about the

00:27:57,070 --> 00:28:01,029
free mode out at Scala days and it took

00:27:58,959 --> 00:28:03,969
me three months to really get a mastery

00:28:01,029 --> 00:28:05,589
on that I did some math if every concept

00:28:03,969 --> 00:28:07,809
on here takes me three months to learn

00:28:05,589 --> 00:28:10,809
it's 11 years of learning functional

00:28:07,809 --> 00:28:12,729
programming concepts so maybe some of

00:28:10,809 --> 00:28:14,019
you have 11 years to do this maybe some

00:28:12,729 --> 00:28:15,429
of you are smarter than me and I it's

00:28:14,019 --> 00:28:17,019
not going to take you three years two or

00:28:15,429 --> 00:28:19,389
three months to learn each one of these

00:28:17,019 --> 00:28:21,519
concepts and maybe some of these things

00:28:19,389 --> 00:28:23,289
are the things that we don't think we

00:28:21,519 --> 00:28:25,209
know but we do already know we just

00:28:23,289 --> 00:28:26,619
don't know it that we know them or we

00:28:25,209 --> 00:28:28,719
don't know they're called those things

00:28:26,619 --> 00:28:33,249
that we know but even if that's the case

00:28:28,719 --> 00:28:35,469
that's still a problem because modern

00:28:33,249 --> 00:28:38,829
functional programming is littered with

00:28:35,469 --> 00:28:41,229
jargon after the Northeast Scala

00:28:38,829 --> 00:28:43,809
conference in March a software engineer

00:28:41,229 --> 00:28:46,659
at Twitter got all the jargon that she

00:28:43,809 --> 00:28:48,579
heard it was so complicated that so

00:28:46,659 --> 00:28:50,679
prevalent that they couldn't keep up

00:28:48,579 --> 00:28:52,749
this is a smart person this person

00:28:50,679 --> 00:28:54,489
literally broke the book on react native

00:28:52,749 --> 00:28:55,910
and they're a software engineer at

00:28:54,489 --> 00:28:57,830
twitter twitter has like

00:28:55,910 --> 00:28:59,570
hundreds of Scala engineers they

00:28:57,830 --> 00:29:01,610
acquired a skull a training company

00:28:59,570 --> 00:29:04,280
they've got a lot of good resources to

00:29:01,610 --> 00:29:06,980
be educating people internally and how

00:29:04,280 --> 00:29:10,010
do you Scala at their company but still

00:29:06,980 --> 00:29:17,540
it was overwhelming and this is what

00:29:10,010 --> 00:29:19,760
Bonnie observed so the cool thing about

00:29:17,540 --> 00:29:22,310
this is bonnie then took some of the

00:29:19,760 --> 00:29:23,720
concepts that she heard and looked them

00:29:22,310 --> 00:29:25,160
up figured out what they were wrote a

00:29:23,720 --> 00:29:28,010
blog post on it

00:29:25,160 --> 00:29:29,690
I spent heard Saturday reading reading

00:29:28,010 --> 00:29:30,860
other blog posts watching conference

00:29:29,690 --> 00:29:33,080
talks in order to get an understanding

00:29:30,860 --> 00:29:35,720
on a lot of this stuff and it's really

00:29:33,080 --> 00:29:37,370
great that she did that and I think that

00:29:35,720 --> 00:29:38,870
was really valuable especially the fact

00:29:37,370 --> 00:29:41,330
that she wrote up a blog post talking

00:29:38,870 --> 00:29:42,830
about her findings but not everyone is

00:29:41,330 --> 00:29:47,180
going to do that nor should they be

00:29:42,830 --> 00:29:49,610
expected to as Bonnie notes in the blog

00:29:47,180 --> 00:29:52,310
post that she wrote jargon comes with an

00:29:49,610 --> 00:29:55,550
inherent cost it needs to earn its place

00:29:52,310 --> 00:29:58,010
and she goes on to say that it does we

00:29:55,550 --> 00:30:00,350
use jargon all the time to share

00:29:58,010 --> 00:30:03,500
contacts and discuss domain specific

00:30:00,350 --> 00:30:06,290
ideas and that can be more efficient if

00:30:03,500 --> 00:30:07,880
everyone shares the same context so

00:30:06,290 --> 00:30:09,530
that's a pretty big assumption right

00:30:07,880 --> 00:30:11,020
there that everybody is on the same page

00:30:09,530 --> 00:30:14,860
and it's a hard assumption to make

00:30:11,020 --> 00:30:17,480
depending on the context that you're in

00:30:14,860 --> 00:30:20,510
this inherent cost that money talks

00:30:17,480 --> 00:30:22,700
about this has been well studied we can

00:30:20,510 --> 00:30:25,100
look at years of education research to

00:30:22,700 --> 00:30:26,840
back us up so in education if you're

00:30:25,100 --> 00:30:29,150
learning a new language either for the

00:30:26,840 --> 00:30:31,460
first time that you're learning to speak

00:30:29,150 --> 00:30:33,740
or read or if you're learning a new and

00:30:31,460 --> 00:30:37,040
foreign language the size of your

00:30:33,740 --> 00:30:38,870
vocabulary is directly correlated with

00:30:37,040 --> 00:30:40,430
your overall comprehension and

00:30:38,870 --> 00:30:45,680
understanding of anything that you're

00:30:40,430 --> 00:30:47,720
doing in a - oh and the interesting

00:30:45,680 --> 00:30:50,630
thing is that providing new definitions

00:30:47,720 --> 00:30:53,380
for words doesn't even cut it so in a

00:30:50,630 --> 00:30:57,770
2000 study a couple of researchers

00:30:53,380 --> 00:31:00,440
provided vocabulary definitions for

00:30:57,770 --> 00:31:02,690
under some familiar words to a group of

00:31:00,440 --> 00:31:05,140
people and asked them to construct a

00:31:02,690 --> 00:31:07,430
sentence using those unfamiliar words

00:31:05,140 --> 00:31:09,260
and when they got the sentences back

00:31:07,430 --> 00:31:11,240
they graded them and only about 20

00:31:09,260 --> 00:31:13,550
five percent of the returning sentences

00:31:11,240 --> 00:31:16,310
were deemed acceptable so the

00:31:13,550 --> 00:31:18,560
researchers tried again they rewrote the

00:31:16,310 --> 00:31:20,560
definitions more specifically for their

00:31:18,560 --> 00:31:22,430
audience specifically for the

00:31:20,560 --> 00:31:24,200
participants that they had in this study

00:31:22,430 --> 00:31:26,300
who I think we're like six year olds and

00:31:24,200 --> 00:31:28,550
they crafted these definitions

00:31:26,300 --> 00:31:30,950
specifically in a way that they thought

00:31:28,550 --> 00:31:33,020
would be useful for those participants

00:31:30,950 --> 00:31:35,210
they made them very good definitions and

00:31:33,020 --> 00:31:37,790
then they got the sentences back again

00:31:35,210 --> 00:31:41,060
and the number of acceptable sentences

00:31:37,790 --> 00:31:44,930
went up it went up to 50% and 50% a lot

00:31:41,060 --> 00:31:47,750
better than 25% but 50% is still

00:31:44,930 --> 00:31:55,550
probably to most people's minds failing

00:31:47,750 --> 00:31:57,050
it's not great and so the researchers

00:31:55,550 --> 00:31:59,060
observe the following they said it's a

00:31:57,050 --> 00:32:02,090
striking demonstration of the fact that

00:31:59,060 --> 00:32:05,480
even definitions very high quality are

00:32:02,090 --> 00:32:11,740
often inadequate as sources of

00:32:05,480 --> 00:32:15,080
information on usage people need context

00:32:11,740 --> 00:32:17,690
they need practice to really understand

00:32:15,080 --> 00:32:20,240
these things the more jargon that we

00:32:17,690 --> 00:32:22,790
start to introduce into whatever domain

00:32:20,240 --> 00:32:25,060
were in especially programming the

00:32:22,790 --> 00:32:28,550
harder it becomes for someone to learn

00:32:25,060 --> 00:32:31,490
and that's really scary because even if

00:32:28,550 --> 00:32:36,560
someone does understand the concept it

00:32:31,490 --> 00:32:39,020
doesn't mean they know how to use it so

00:32:36,560 --> 00:32:40,790
people were mad about this and the

00:32:39,020 --> 00:32:44,780
conference responded by updating the

00:32:40,790 --> 00:32:46,310
letter but they literally just

00:32:44,780 --> 00:32:47,480
introduced more jargon the only thing

00:32:46,310 --> 00:32:49,400
that's different now is I think they

00:32:47,480 --> 00:32:51,230
change the name of the section so now

00:32:49,400 --> 00:32:55,640
instead of being a beginner you're like

00:32:51,230 --> 00:32:57,140
an iced caramel or something I don't

00:32:55,640 --> 00:32:59,450
know I don't know if I should be

00:32:57,140 --> 00:33:01,850
offended by being called a fire love

00:32:59,450 --> 00:33:03,620
line or not I don't even know what that

00:33:01,850 --> 00:33:06,440
means I don't know if I'm pronouncing it

00:33:03,620 --> 00:33:08,780
right the problem with this is is not

00:33:06,440 --> 00:33:12,050
the names of this divisions it's that

00:33:08,780 --> 00:33:14,420
there's no context for any of this why

00:33:12,050 --> 00:33:17,240
does knowing advanced monads

00:33:14,420 --> 00:33:19,610
make you a better programmer in my

00:33:17,240 --> 00:33:21,950
opinion it doesn't when you present

00:33:19,610 --> 00:33:23,389
something like this as a ladder the

00:33:21,950 --> 00:33:24,709
connotation there is that

00:33:23,389 --> 00:33:26,479
are expected to climb that you're

00:33:24,709 --> 00:33:29,509
expected to grow and if you don't you're

00:33:26,479 --> 00:33:32,599
doing something wrong you're expected to

00:33:29,509 --> 00:33:34,879
become the ice squid or whatever that is

00:33:32,599 --> 00:33:36,259
but that's not necessary the essentials

00:33:34,879 --> 00:33:38,959
that we talked about those are all

00:33:36,259 --> 00:33:40,759
captured in the first rungs and so if

00:33:38,959 --> 00:33:42,979
you want to think about it as a pyramid

00:33:40,759 --> 00:33:44,690
you need these fundamentals the

00:33:42,979 --> 00:33:47,269
expressions and the data structures in

00:33:44,690 --> 00:33:49,609
order to understand the essentials of

00:33:47,269 --> 00:33:52,159
functional programming and everything on

00:33:49,609 --> 00:33:54,919
top of that the buzzer is a syntactic

00:33:52,159 --> 00:33:57,499
sugar those are trends they may have

00:33:54,919 --> 00:33:59,779
staying power they may not we don't

00:33:57,499 --> 00:34:01,579
really know but it's the flavor of the

00:33:59,779 --> 00:34:03,739
week buzzword that people are using a

00:34:01,579 --> 00:34:05,749
lot introducing into their projects and

00:34:03,739 --> 00:34:07,309
maybe they're doing it in a way that

00:34:05,749 --> 00:34:09,379
makes sense and maybe they're not but

00:34:07,309 --> 00:34:11,539
these things haven't been around enough

00:34:09,379 --> 00:34:13,760
nor do they have enough context and

00:34:11,539 --> 00:34:19,220
shared understanding in most cases to

00:34:13,760 --> 00:34:22,460
really be useful something that these

00:34:19,220 --> 00:34:24,139
lists do give you is a list and idea of

00:34:22,460 --> 00:34:25,700
concepts to go out and learn about if

00:34:24,139 --> 00:34:26,899
you're curious and wanting to do that

00:34:25,700 --> 00:34:29,210
and that's something like something that

00:34:26,899 --> 00:34:31,129
Bonnie did and sure I can see the value

00:34:29,210 --> 00:34:32,809
in that learning for learnings sake is

00:34:31,129 --> 00:34:36,460
great it's why we continue to fund

00:34:32,809 --> 00:34:40,399
research institutions thank you VP FL

00:34:36,460 --> 00:34:43,720
but where it becomes problematic is how

00:34:40,399 --> 00:34:45,559
many people in here industry programmers

00:34:43,720 --> 00:34:48,470
all right and how many people are

00:34:45,559 --> 00:34:50,240
academic programmers okay so there's a

00:34:48,470 --> 00:34:52,099
significant number more of Industry

00:34:50,240 --> 00:34:55,099
programmers and where things like this

00:34:52,099 --> 00:34:57,289
become problematic is when you decide to

00:34:55,099 --> 00:34:59,359
take something like Pro funks or optics

00:34:57,289 --> 00:35:01,519
and build that into your feature release

00:34:59,359 --> 00:35:03,079
because you heard me talk about it at

00:35:01,519 --> 00:35:05,390
this cool conference talk you went to

00:35:03,079 --> 00:35:08,269
and no one on your team knows what that

00:35:05,390 --> 00:35:10,369
does it's learning some new vocabulary

00:35:08,269 --> 00:35:11,930
without knowing how to use it in a

00:35:10,369 --> 00:35:15,440
sentence except for now that vocabulary

00:35:11,930 --> 00:35:18,470
is something like free monads or tagless

00:35:15,440 --> 00:35:20,240
final interpreters and these sentence is

00:35:18,470 --> 00:35:24,170
the production service that I have to be

00:35:20,240 --> 00:35:26,329
on call for and for once someone a

00:35:24,170 --> 00:35:28,609
hacker news agrees with me so this

00:35:26,329 --> 00:35:30,589
person said it may be fun to brag about

00:35:28,609 --> 00:35:32,420
knowing how to use embedded DSL

00:35:30,589 --> 00:35:35,089
combinators but is that really the best

00:35:32,420 --> 00:35:36,980
thing to help your startup succeed I'm a

00:35:35,089 --> 00:35:41,240
big proponent of using the right tool

00:35:36,980 --> 00:35:43,340
for the right job of finding of solving

00:35:41,240 --> 00:35:47,600
problems rather and not just building

00:35:43,340 --> 00:35:51,109
solutions not to mention the jargon is

00:35:47,600 --> 00:35:53,990
super alienating especially for new

00:35:51,109 --> 00:35:56,330
programmers a large amount of this

00:35:53,990 --> 00:36:00,080
category theoretic terminology that we

00:35:56,330 --> 00:36:01,750
hear hasn't earned its place at one of

00:36:00,080 --> 00:36:04,160
the first Scala minutes I ever went to

00:36:01,750 --> 00:36:06,170
there was a panel it was a panel

00:36:04,160 --> 00:36:08,030
discussion and someone on the panel said

00:36:06,170 --> 00:36:09,980
that it was good that Scala was hard to

00:36:08,030 --> 00:36:12,109
learn because that made sure that only

00:36:09,980 --> 00:36:17,000
people that were serious about it were

00:36:12,109 --> 00:36:19,190
the ones that stuck with it and that's

00:36:17,000 --> 00:36:20,330
really hard to hear it's really hard to

00:36:19,190 --> 00:36:22,070
hear when you're three months into

00:36:20,330 --> 00:36:25,520
learning a new language you gave up your

00:36:22,070 --> 00:36:27,590
Wednesday night to go meet people in the

00:36:25,520 --> 00:36:28,940
community learn some stuff and

00:36:27,590 --> 00:36:33,640
somebody's up there being like and

00:36:28,940 --> 00:36:36,260
you're probably not going to cut it if

00:36:33,640 --> 00:36:38,540
you're someone that's heard these things

00:36:36,260 --> 00:36:40,430
it's felt alienated like this I'm here

00:36:38,540 --> 00:36:41,840
to be a voice of reason I don't think

00:36:40,430 --> 00:36:44,600
that we should be saying things like

00:36:41,840 --> 00:36:46,430
this too many conference talks focus

00:36:44,600 --> 00:36:48,590
only on the syntactic sugar and all the

00:36:46,430 --> 00:36:51,680
reasons why you might use these things I

00:36:48,590 --> 00:36:54,800
think that we need to get more focus on

00:36:51,680 --> 00:37:00,920
the why of things and not just the how

00:36:54,800 --> 00:37:03,800
or the what so please stop saying things

00:37:00,920 --> 00:37:06,470
like this Scala is not too complex for

00:37:03,800 --> 00:37:08,150
any programmer this is funny because

00:37:06,470 --> 00:37:10,030
it's a widely held belief also is not a

00:37:08,150 --> 00:37:12,350
real book by the way

00:37:10,030 --> 00:37:14,300
please stop saying that you have to know

00:37:12,350 --> 00:37:16,550
things like advanced monads in order to

00:37:14,300 --> 00:37:18,200
be an advanced functional programmer if

00:37:16,550 --> 00:37:19,940
you understand the essentials that I

00:37:18,200 --> 00:37:22,400
mentioned the data structures and the

00:37:19,940 --> 00:37:25,070
expressions you can accomplish a whole

00:37:22,400 --> 00:37:27,290
hell of a lot and the rest comes down to

00:37:25,070 --> 00:37:29,300
the dynamics of your team and the

00:37:27,290 --> 00:37:30,230
culture that your individual team has

00:37:29,300 --> 00:37:32,060
figured out

00:37:30,230 --> 00:37:33,850
perhaps you're working on a team that

00:37:32,060 --> 00:37:36,650
has introduced certain abstractions

00:37:33,850 --> 00:37:39,050
introduce certain syntactic sugar that's

00:37:36,650 --> 00:37:40,910
great but make sure that you're keeping

00:37:39,050 --> 00:37:42,800
in mind the overhead there that you have

00:37:40,910 --> 00:37:44,660
a plan for bringing new people into your

00:37:42,800 --> 00:37:46,609
project and an understanding that these

00:37:44,660 --> 00:37:48,650
aren't concepts and jargon that people

00:37:46,609 --> 00:37:50,750
may not be familiar with they're going

00:37:48,650 --> 00:37:52,860
to increase your ramp up

00:37:50,750 --> 00:37:55,470
if you're someone that's ready more

00:37:52,860 --> 00:37:58,470
blueSky Scala as Jessica Kirk wind it

00:37:55,470 --> 00:38:01,920
you can still be an expert functional

00:37:58,470 --> 00:38:04,350
programmer without this stuff and that

00:38:01,920 --> 00:38:08,730
brings us to functional programming and

00:38:04,350 --> 00:38:10,410
Scala there are a lot of things that you

00:38:08,730 --> 00:38:12,930
can do when we talk about functional

00:38:10,410 --> 00:38:15,800
programming in Scala I'll give you a

00:38:12,930 --> 00:38:15,800
minute to take this in

00:38:34,820 --> 00:38:36,910
you

00:38:43,560 --> 00:38:51,520
so some of you probably figure it out

00:38:46,050 --> 00:38:54,010
about 75% of these aren't real but the

00:38:51,520 --> 00:38:57,880
challenge is figuring out which 75% that

00:38:54,010 --> 00:39:01,859
is it's hard we made some of these up

00:38:57,880 --> 00:39:01,859
and I accidentally invented real ones

00:39:04,109 --> 00:39:13,270
apparently lifted arrows exist but some

00:39:10,089 --> 00:39:17,190
of the stuff I so some of my favorites

00:39:13,270 --> 00:39:18,940
recursive constants that can't happen

00:39:17,190 --> 00:39:24,550
Transfiguration is a class that you take

00:39:18,940 --> 00:39:26,410
at Hogwarts a mutator czar not real so

00:39:24,550 --> 00:39:28,300
these are things you took jargon that we

00:39:26,410 --> 00:39:30,490
hear about is a Scala community a lot

00:39:28,300 --> 00:39:31,900
this is not what we're talking about

00:39:30,490 --> 00:39:34,930
when we're talking about functional

00:39:31,900 --> 00:39:37,930
programming in Scala what we're talking

00:39:34,930 --> 00:39:40,150
about is this a series of trade-offs

00:39:37,930 --> 00:39:43,150
that you have to make every day as

00:39:40,150 --> 00:39:44,920
you're writing your code Scala makes

00:39:43,150 --> 00:39:48,220
functional programming easy it also

00:39:44,920 --> 00:39:49,660
doesn't require it so when you're

00:39:48,220 --> 00:39:51,570
thinking about how to write your

00:39:49,660 --> 00:39:53,800
programs and how to be more functional

00:39:51,570 --> 00:39:56,680
think back to the essentials to

00:39:53,800 --> 00:39:58,780
expressions into data structures may be

00:39:56,680 --> 00:40:01,240
using some buzzword make sense in your

00:39:58,780 --> 00:40:03,099
domain and makes the thing that you're

00:40:01,240 --> 00:40:07,060
trying to solve possible but don't

00:40:03,099 --> 00:40:08,260
forget the overhead there you might be

00:40:07,060 --> 00:40:10,060
wondering what I think about the

00:40:08,260 --> 00:40:12,369
library's dedicated to functional

00:40:10,060 --> 00:40:13,780
programming abstractions these libraries

00:40:12,369 --> 00:40:16,290
exist and all I can say is that your

00:40:13,780 --> 00:40:18,339
mileage may vary libraries like cats

00:40:16,290 --> 00:40:20,050
promote themselves as functional

00:40:18,339 --> 00:40:22,570
programming extensions to the Scala

00:40:20,050 --> 00:40:23,920
language and there are completely

00:40:22,570 --> 00:40:26,050
practical reasons that you would pull

00:40:23,920 --> 00:40:28,359
these into your projects but they can

00:40:26,050 --> 00:40:30,070
get very complicated very quickly and

00:40:28,359 --> 00:40:32,410
one thing that I do appreciate is the

00:40:30,070 --> 00:40:34,390
folks at places like underscore and type

00:40:32,410 --> 00:40:36,280
levels that are doing a lot of stuff to

00:40:34,390 --> 00:40:37,839
contribute knowledge back to the

00:40:36,280 --> 00:40:39,670
community contributing more than just

00:40:37,839 --> 00:40:42,430
these libraries but also documentation

00:40:39,670 --> 00:40:45,220
and learning resources and how to master

00:40:42,430 --> 00:40:46,780
some of this stuff that stuff matters if

00:40:45,220 --> 00:40:48,400
you're interested in getting into open

00:40:46,780 --> 00:40:50,320
source the easiest intro in my

00:40:48,400 --> 00:40:53,130
experience is contributing to the

00:40:50,320 --> 00:40:53,130
documentation

00:40:53,490 --> 00:40:58,270
earlier I talked a lot about the history

00:40:55,810 --> 00:41:02,140
of functional programming that doesn't

00:40:58,270 --> 00:41:04,329
end in 1975 it doesn't end in 2017 at

00:41:02,140 --> 00:41:07,089
the risk of sounding cliche we're still

00:41:04,329 --> 00:41:09,430
building that history today we're still

00:41:07,089 --> 00:41:10,930
building the future and the past of the

00:41:09,430 --> 00:41:12,970
programming of the functional

00:41:10,930 --> 00:41:14,320
programming community we have a lot of

00:41:12,970 --> 00:41:18,640
work to do to make functional

00:41:14,320 --> 00:41:20,619
programming and Scala more welcoming but

00:41:18,640 --> 00:41:22,480
by focusing on the essentials and

00:41:20,619 --> 00:41:24,339
bringing the definition of functional

00:41:22,480 --> 00:41:25,839
programming back to expressions into

00:41:24,339 --> 00:41:28,510
data structures I think we can

00:41:25,839 --> 00:41:30,250
accomplish a lot functional programming

00:41:28,510 --> 00:41:30,910
isn't magic functional programming and

00:41:30,250 --> 00:41:33,579
Scala

00:41:30,910 --> 00:41:35,800
isn't magic this paradigm exists because

00:41:33,579 --> 00:41:37,960
thousands of people all of us in this

00:41:35,800 --> 00:41:40,410
room included decided that there was

00:41:37,960 --> 00:41:42,369
more than one way to write programs

00:41:40,410 --> 00:41:44,560
people like functional programming

00:41:42,369 --> 00:41:46,420
because it's elegant so have fun with

00:41:44,560 --> 00:41:48,820
that but think of the principles that we

00:41:46,420 --> 00:41:50,619
discussed in order to make your data

00:41:48,820 --> 00:41:52,680
match your programs and to break things

00:41:50,619 --> 00:41:55,300
down into more manageable pieces

00:41:52,680 --> 00:41:57,849
functional programming also exists

00:41:55,300 --> 00:42:00,849
because those long procedural programs

00:41:57,849 --> 00:42:02,230
are really hard to follow and so think

00:42:00,849 --> 00:42:04,060
back to this first principle that I

00:42:02,230 --> 00:42:07,599
mentioned from the very beginning the

00:42:04,060 --> 00:42:09,250
whole point of the Scala / Scala and the

00:42:07,599 --> 00:42:11,829
functional programming paradigm is the

00:42:09,250 --> 00:42:13,750
idea of writing small and reusable

00:42:11,829 --> 00:42:17,020
subroutines in order to make things more

00:42:13,750 --> 00:42:19,480
understandable to the user do your part

00:42:17,020 --> 00:42:22,089
to encourage that understanding and most

00:42:19,480 --> 00:42:23,980
of all be kind be kind to yourself be

00:42:22,089 --> 00:42:26,380
kind to your teams be kind of the

00:42:23,980 --> 00:42:28,390
community try to recognize when the

00:42:26,380 --> 00:42:29,109
abstraction or the syntactic sugar has

00:42:28,390 --> 00:42:31,000
gone too far

00:42:29,109 --> 00:42:34,180
or when you shouldn't introduce it at

00:42:31,000 --> 00:42:37,260
all you always have the essentials to

00:42:34,180 --> 00:42:37,260
help you achieve your goals

00:42:37,349 --> 00:42:45,190
speaking of jargon we made a quiz so you

00:42:44,050 --> 00:42:47,410
can thank Heather Miller for this you

00:42:45,190 --> 00:42:51,640
can test your knowledge Martin are you

00:42:47,410 --> 00:42:54,369
here Martin got four out of five he gots

00:42:51,640 --> 00:42:57,569
about 66% on this quiz so if you can

00:42:54,369 --> 00:42:57,569
beat that you beat Martin

00:42:57,770 --> 00:43:02,210
it's surprisingly hard and no cheating

00:43:00,660 --> 00:43:04,590
come on people

00:43:02,210 --> 00:43:06,330
once again my name is Kelly Robinson

00:43:04,590 --> 00:43:16,950
here's my contact information and thank

00:43:06,330 --> 00:43:21,359
you for listening I think that was

00:43:16,950 --> 00:43:23,090
really great one remark on the word

00:43:21,359 --> 00:43:27,060
functional programming I guess you

00:43:23,090 --> 00:43:29,820
showed its history really well so often

00:43:27,060 --> 00:43:32,040
in this industry which is hype driven we

00:43:29,820 --> 00:43:33,960
they're sort of a fight for words the

00:43:32,040 --> 00:43:36,450
last time that happened was with dynamic

00:43:33,960 --> 00:43:38,130
programming around 2000 which

00:43:36,450 --> 00:43:40,050
essentially was a brilliant way to

00:43:38,130 --> 00:43:42,869
essentially introduce a new term for

00:43:40,050 --> 00:43:45,930
dynamically typed programming because

00:43:42,869 --> 00:43:47,970
after all who wants not to be a dynamic

00:43:45,930 --> 00:43:49,800
program a static is boring right and I

00:43:47,970 --> 00:43:51,690
think that essentially influenced the

00:43:49,800 --> 00:43:53,250
industry for about ten years and I

00:43:51,690 --> 00:43:55,170
believe we'd see something like that is

00:43:53,250 --> 00:43:58,980
functional programming as well because

00:43:55,170 --> 00:44:00,540
I'm I'm in the WGP 2.88 the function

00:43:58,980 --> 00:44:02,790
programming working group essentially of

00:44:00,540 --> 00:44:04,440
all the academics fill what we're and

00:44:02,790 --> 00:44:06,990
everyone and I can assure you the

00:44:04,440 --> 00:44:08,940
essential programming is not Pro functor

00:44:06,990 --> 00:44:11,400
optics that's some part of functional

00:44:08,940 --> 00:44:13,800
programming but it's essentially a part

00:44:11,400 --> 00:44:15,810
that comes from category theories so I

00:44:13,800 --> 00:44:18,089
think a much more accurate name would be

00:44:15,810 --> 00:44:19,230
categorical programming because that's

00:44:18,089 --> 00:44:21,240
what it's really it's functional

00:44:19,230 --> 00:44:22,920
programming as you say is much much

00:44:21,240 --> 00:44:25,380
wider it's essentially everything every

00:44:22,920 --> 00:44:28,020
programming that uses functions and that

00:44:25,380 --> 00:44:30,450
essentially tracks effects it tries to

00:44:28,020 --> 00:44:32,520
be pure in a larger program footprint as

00:44:30,450 --> 00:44:34,380
possible and by whatever means that

00:44:32,520 --> 00:44:36,839
achieves that that's function program

00:44:34,380 --> 00:44:39,570
thank you for writing that point I just

00:44:36,839 --> 00:44:40,740
wanted to reinforce it thank you thanks

00:44:39,570 --> 00:44:43,140
fine yeah I think that's really

00:44:40,740 --> 00:44:44,940
important like this this idea I don't I

00:44:43,140 --> 00:44:48,000
don't think people disagree with this

00:44:44,940 --> 00:44:51,210
but there are people that are taking the

00:44:48,000 --> 00:44:52,680
categoric programming and trying to call

00:44:51,210 --> 00:44:54,300
it functional programming and I think

00:44:52,680 --> 00:44:55,859
that's problematic because then you get

00:44:54,300 --> 00:44:57,869
people that are interested in learning

00:44:55,859 --> 00:44:59,700
functional programming and on day two

00:44:57,869 --> 00:45:02,130
they're like well now I have to know

00:44:59,700 --> 00:45:04,020
what type classes and the reader monad

00:45:02,130 --> 00:45:06,210
is looks like no not you don't have to

00:45:04,020 --> 00:45:07,279
know that on day two maybe day 200 but

00:45:06,210 --> 00:45:11,119
like even then probably

00:45:07,279 --> 00:45:14,089
not from your experience how do you

00:45:11,119 --> 00:45:17,269
balance between using these tools which

00:45:14,089 --> 00:45:19,789
are category theory implementations and

00:45:17,269 --> 00:45:22,729
how do you implement what which are the

00:45:19,789 --> 00:45:26,959
borders that you define any teams and so

00:45:22,729 --> 00:45:29,569
what's the practical advice for usage of

00:45:26,959 --> 00:45:31,579
the libraries sure so I think it really

00:45:29,569 --> 00:45:33,049
depends on who your team is and the

00:45:31,579 --> 00:45:35,029
problems that you're trying to solve and

00:45:33,049 --> 00:45:37,579
so one of the things that I've said

00:45:35,029 --> 00:45:40,130
before is a lot of my team comes from a

00:45:37,579 --> 00:45:41,749
Java and a ruby background and so when

00:45:40,130 --> 00:45:44,239
we started writing things in Scala

00:45:41,749 --> 00:45:46,789
people were coming from the domain of an

00:45:44,239 --> 00:45:48,229
object-oriented language and so there

00:45:46,789 --> 00:45:50,239
weren't a lot of people that had a lot

00:45:48,229 --> 00:45:53,269
of the category theoretic knowledge and

00:45:50,239 --> 00:45:54,650
so we decided to to pick up Scala from

00:45:53,269 --> 00:45:56,749
from that domain and so there's there's

00:45:54,650 --> 00:45:58,640
not a lot of the super like Haskell e

00:45:56,749 --> 00:46:01,039
stuff that appears in our code and

00:45:58,640 --> 00:46:03,289
that's the agreement that we've we've

00:46:01,039 --> 00:46:05,419
come to as a team I'm actually going to

00:46:03,289 --> 00:46:07,400
pitch a talk that's today at like 3:40 I

00:46:05,419 --> 00:46:09,499
think the CTO of tap adds talking about

00:46:07,400 --> 00:46:12,169
how to build some of these principles

00:46:09,499 --> 00:46:13,489
around building teams in Scala and he

00:46:12,169 --> 00:46:16,489
has a lot of really great points around

00:46:13,489 --> 00:46:18,439
this how you can how you can kind of

00:46:16,489 --> 00:46:19,999
condition your teams and agree on a set

00:46:18,439 --> 00:46:21,739
of principles within your team in order

00:46:19,999 --> 00:46:23,119
to do that but I don't know anything

00:46:21,739 --> 00:46:24,619
about your team I don't know what the

00:46:23,119 --> 00:46:26,479
backgrounds of the people are if you

00:46:24,619 --> 00:46:27,919
were all coming from a math pH to use

00:46:26,479 --> 00:46:29,599
them yeah maybe it makes sense to like

00:46:27,919 --> 00:46:32,059
write everything in a very type level

00:46:29,599 --> 00:46:33,499
category exile but I find that a lot of

00:46:32,059 --> 00:46:36,199
the teams that I've worked on in Scala

00:46:33,499 --> 00:46:38,599
aren't like that first of all thanks was

00:46:36,199 --> 00:46:40,669
a great talk here is very interesting

00:46:38,599 --> 00:46:44,019
points and the function versus category

00:46:40,669 --> 00:46:47,380
of programming thing and I'm wondering

00:46:44,019 --> 00:46:50,390
when you think about minimizing jargon

00:46:47,380 --> 00:46:52,130
to me when the process of learning like

00:46:50,390 --> 00:46:55,130
concept even from category theory

00:46:52,130 --> 00:46:57,109
sometimes jargon or precise definitions

00:46:55,130 --> 00:46:59,029
we're actually very useful mmm because I

00:46:57,109 --> 00:47:01,429
know what I don't know and I know what I

00:46:59,029 --> 00:47:04,609
can Google and I can find material

00:47:01,429 --> 00:47:07,400
material that so when you say minimize

00:47:04,609 --> 00:47:10,880
jargon I'm wondering how does it fit in

00:47:07,400 --> 00:47:13,069
the process of learning like it seems

00:47:10,880 --> 00:47:15,229
like a cultural problem like especially

00:47:13,069 --> 00:47:17,179
from the Dirk and don't use those words

00:47:15,229 --> 00:47:20,620
out of context like provide context and

00:47:17,179 --> 00:47:22,120
words so I'm wondering whether you mean

00:47:20,620 --> 00:47:24,250
minimizing Jerrica like don't use it

00:47:22,120 --> 00:47:26,050
where you don't need it but when what

00:47:24,250 --> 00:47:28,570
you actually need it I don't know if you

00:47:26,050 --> 00:47:31,230
have any tips for helping learners and

00:47:28,570 --> 00:47:33,040
learning yes I think it comes back to

00:47:31,230 --> 00:47:35,410
focusing on the problem that you're

00:47:33,040 --> 00:47:37,720
trying to solve and solving that problem

00:47:35,410 --> 00:47:39,550
with the the pattern or the the style

00:47:37,720 --> 00:47:41,650
that you think makes sense and then if

00:47:39,550 --> 00:47:43,090
at a later point you recognize or

00:47:41,650 --> 00:47:45,100
someone on your team recognizes that

00:47:43,090 --> 00:47:46,780
pattern has a name then you can start to

00:47:45,100 --> 00:47:49,480
name things but I think the problem

00:47:46,780 --> 00:47:50,860
where jargon comes in is that if you're

00:47:49,480 --> 00:47:52,270
talking to someone and you're assuming

00:47:50,860 --> 00:47:56,350
knowledge you're not providing the

00:47:52,270 --> 00:47:58,180
context then it's hard to explain things

00:47:56,350 --> 00:47:59,710
and have people keep up people are just

00:47:58,180 --> 00:48:01,330
going to lose sight of what you said

00:47:59,710 --> 00:48:04,330
some of the other education research out

00:48:01,330 --> 00:48:06,280
there says it like if you use a sentence

00:48:04,330 --> 00:48:08,440
and there's more than like 15 or 20%

00:48:06,280 --> 00:48:09,790
unfamiliar words people just like lose

00:48:08,440 --> 00:48:11,530
understanding of everything that you

00:48:09,790 --> 00:48:13,090
said it doesn't matter how much also

00:48:11,530 --> 00:48:15,760
that they were able to handle people

00:48:13,090 --> 00:48:18,010
focus on the things that they don't know

00:48:15,760 --> 00:48:20,740
and then they get lost in the rest of it

00:48:18,010 --> 00:48:22,600
and so if you're introducing things and

00:48:20,740 --> 00:48:24,580
names then that's fine if there's a

00:48:22,600 --> 00:48:27,370
purpose for doing it but I think that

00:48:24,580 --> 00:48:29,650
the challenge here is to be very mindful

00:48:27,370 --> 00:48:31,270
of that and make sure that you know what

00:48:29,650 --> 00:48:34,030
you're doing and this is really hard

00:48:31,270 --> 00:48:36,640
also but try to be mindful of it in

00:48:34,030 --> 00:48:38,500
order to say okay like yeah now we're

00:48:36,640 --> 00:48:40,450
going to do this do you know what I mean

00:48:38,500 --> 00:48:42,610
when I say we're going to be using like

00:48:40,450 --> 00:48:44,200
a for comprehension do you know what I

00:48:42,610 --> 00:48:46,840
mean when I say we're going to be using

00:48:44,200 --> 00:48:49,090
type classes here especially if you're

00:48:46,840 --> 00:48:50,650
training new developers or things like

00:48:49,090 --> 00:48:52,510
that but to your point I agree like

00:48:50,650 --> 00:48:55,690
being able to Google things using a very

00:48:52,510 --> 00:48:57,900
specific name is also helpful thanks

00:48:55,690 --> 00:48:57,900
everyone

00:48:59,660 --> 00:49:01,720

YouTube URL: https://www.youtube.com/watch?v=Yc6nJZK39mU


