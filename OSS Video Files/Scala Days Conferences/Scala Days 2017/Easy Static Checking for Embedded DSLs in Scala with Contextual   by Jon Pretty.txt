Title: Easy Static Checking for Embedded DSLs in Scala with Contextual   by Jon Pretty
Publication date: 2017-06-14
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Interpolated strings, like the familiar `s""`, provide a convenient way to embed external DSLs in Scala source, allowing you to construct a new value at runtime from a string literal, with Scala expressions substituted within it.

But unless you are prepared to implement the interpolator using a macro, the compiler provides no checks on the correctness or well-formedness of the embedded DSL.

Contextual is a small open-source library which does the heavy lifting work to make it trivial to write interpolators which run at compile time, without requiring any macro code. A string interpolator which parses and checks a DSL at compile-time -- with its own custom error-messages -- can be written using contextual in just a few lines of ordinary "userspace" code, calling upon parsers, regular expressions or any other means to check the interpolated string.

This opens up a smorgasbord of possibilities for adding more compile-time safety to Scala code, not least the ability to introduce your own literal-like types, ranging from checked email addresses or URLs to compile-time-checked YAML, CSS or Haskell!
Captions: 
	00:00:04,330 --> 00:00:10,100
okay welcome welcome everyone I'm I'm

00:00:08,630 --> 00:00:12,500
John pretty I'm going to be talking

00:00:10,100 --> 00:00:15,219
today about a library I've been working

00:00:12,500 --> 00:00:19,970
on for the last few months called

00:00:15,219 --> 00:00:21,140
contextual I can't I can't really see

00:00:19,970 --> 00:00:22,700
there the lights up here is so bright

00:00:21,140 --> 00:00:24,890
but I'm going to ask you anyway how many

00:00:22,700 --> 00:00:27,350
how many people here have come because

00:00:24,890 --> 00:00:31,160
they've they they know a little bit

00:00:27,350 --> 00:00:36,520
about contextual already very few I

00:00:31,160 --> 00:00:42,440
think very hard to tell as well so the

00:00:36,520 --> 00:00:44,630
vistas library arose as a result of a an

00:00:42,440 --> 00:00:48,950
earlier talk I was giving about

00:00:44,630 --> 00:00:51,680
interpolating strings in Scala and how

00:00:48,950 --> 00:00:53,930
you can use the type system and macros

00:00:51,680 --> 00:00:56,300
and other complicated things inside the

00:00:53,930 --> 00:01:00,920
compiler to do some quite clever things

00:00:56,300 --> 00:01:02,510
and given a an interpolated string check

00:01:00,920 --> 00:01:06,049
its contents at compile time with a

00:01:02,510 --> 00:01:10,240
macro and I gave this talk at scholar IO

00:01:06,049 --> 00:01:13,490
in Paris at the end of last year and

00:01:10,240 --> 00:01:14,960
nobody understood it and this was a bit

00:01:13,490 --> 00:01:17,000
of a this is a bit of a problem and

00:01:14,960 --> 00:01:19,369
trying trying to I realized after that

00:01:17,000 --> 00:01:21,490
trying to fit all of these quite

00:01:19,369 --> 00:01:24,950
complicated and quite subtle ideas into

00:01:21,490 --> 00:01:26,570
what was the 45-minute talk was never

00:01:24,950 --> 00:01:28,010
going to succeed so instead I thought

00:01:26,570 --> 00:01:31,640
well okay I'll just take all these ideas

00:01:28,010 --> 00:01:33,710
I'll roll them into library and I'll

00:01:31,640 --> 00:01:39,140
make them easy to understand and that

00:01:33,710 --> 00:01:40,729
became contextual so I'll start at the

00:01:39,140 --> 00:01:41,960
beginning and tell you tell you what is

00:01:40,729 --> 00:01:45,200
I know I haven't I haven't explained

00:01:41,960 --> 00:01:47,740
what contextual is yet but hopefully

00:01:45,200 --> 00:01:49,670
you'll be familiar with code like this

00:01:47,740 --> 00:01:51,560
all were doing here is we're

00:01:49,670 --> 00:01:55,189
substituting a string into another

00:01:51,560 --> 00:01:57,470
string using the F interpolator so is

00:01:55,189 --> 00:02:03,250
anyone here at all confused by by this

00:01:57,470 --> 00:02:06,590
this should all be very familiar okay so

00:02:03,250 --> 00:02:08,269
what happens is whatever type name

00:02:06,590 --> 00:02:10,879
happens to be it gets substituted into

00:02:08,269 --> 00:02:12,590
that string in that position has two

00:02:10,879 --> 00:02:13,939
string calls on it and in this case it

00:02:12,590 --> 00:02:16,189
starts off the strings but nothing

00:02:13,939 --> 00:02:16,850
interesting happens there and we end up

00:02:16,189 --> 00:02:21,290
with

00:02:16,850 --> 00:02:25,570
string being returned hello John so far

00:02:21,290 --> 00:02:30,410
so good but not very exciting in fact

00:02:25,570 --> 00:02:32,750
very boring so the reasons why I don't

00:02:30,410 --> 00:02:35,140
find this particular example interesting

00:02:32,750 --> 00:02:37,430
even though it's the most most familiar

00:02:35,140 --> 00:02:41,810
occurrence of interpolated strings in

00:02:37,430 --> 00:02:44,210
Scala you can put any type you can

00:02:41,810 --> 00:02:46,160
substitute any type into that my example

00:02:44,210 --> 00:02:47,870
is a string but you can put whatever you

00:02:46,160 --> 00:02:50,180
like in there and it just have to string

00:02:47,870 --> 00:02:53,870
calls on it to them the embedding type

00:02:50,180 --> 00:02:56,960
is is any and the return type is always

00:02:53,870 --> 00:02:58,340
string nothing exciting about strings

00:02:56,960 --> 00:03:04,160
nothing in particular type safe about

00:02:58,340 --> 00:03:06,800
strings and this third point here is is

00:03:04,160 --> 00:03:08,600
maybe maybe you take this for granted

00:03:06,800 --> 00:03:11,810
maybe maybe it's just a little bit

00:03:08,600 --> 00:03:13,460
obvious but the literal parts so the

00:03:11,810 --> 00:03:14,540
parts of that interrupts extremes that

00:03:13,460 --> 00:03:17,080
aren't variables that aren't

00:03:14,540 --> 00:03:19,040
substitutions they can contain anything

00:03:17,080 --> 00:03:20,440
you're probably thinking well they're

00:03:19,040 --> 00:03:23,510
strings course they can contain anything

00:03:20,440 --> 00:03:25,250
well maybe there's an alternative maybe

00:03:23,510 --> 00:03:26,510
we can actually disallow certain things

00:03:25,250 --> 00:03:28,550
and maybe we can get some use out of

00:03:26,510 --> 00:03:35,150
that so that's so that's a hint as to

00:03:28,550 --> 00:03:38,360
where we can possibly go with this so

00:03:35,150 --> 00:03:41,710
when the compiler sees code like this s

00:03:38,360 --> 00:03:41,710
interpolate of the first line here

00:03:41,740 --> 00:03:48,500
before typing so the you probably know

00:03:46,340 --> 00:03:50,120
the compiler has several phases that

00:03:48,500 --> 00:03:52,400
starts off with source code and ends up

00:03:50,120 --> 00:03:54,830
with byte code and along the way it does

00:03:52,400 --> 00:03:58,780
various transformations of ASDs and and

00:03:54,830 --> 00:04:02,170
then so on to get to get that end goal

00:03:58,780 --> 00:04:05,510
it starts off early on with parsing and

00:04:02,170 --> 00:04:09,500
then a little bit later it does typing

00:04:05,510 --> 00:04:12,500
and doing this very early phase of

00:04:09,500 --> 00:04:15,350
parsing this first line here gets

00:04:12,500 --> 00:04:18,080
transformed into the second line so in

00:04:15,350 --> 00:04:19,609
the typer and type is where most of the

00:04:18,080 --> 00:04:21,950
time is spent in the compiler where most

00:04:19,609 --> 00:04:23,810
of the interesting work is done where

00:04:21,950 --> 00:04:27,350
most of the errors will occur compilers

00:04:23,810 --> 00:04:29,420
will occur if there are any the type r

00:04:27,350 --> 00:04:32,030
only sees that second line there

00:04:29,420 --> 00:04:36,440
it sees the creation of a new string

00:04:32,030 --> 00:04:38,690
context object with the parameters hello

00:04:36,440 --> 00:04:41,930
and exclamation mark and they come from

00:04:38,690 --> 00:04:43,220
the green parts on the top line if you

00:04:41,930 --> 00:04:48,830
had more substitutions there would be

00:04:43,220 --> 00:04:51,110
more parameters and it calls dot s and s

00:04:48,830 --> 00:04:52,910
is the name of the interpolator so

00:04:51,110 --> 00:04:54,920
whatever prefix you put in front of that

00:04:52,910 --> 00:04:59,750
string ends up with a method invocation

00:04:54,920 --> 00:05:01,700
on that string context and as a

00:04:59,750 --> 00:05:05,600
parameter or as multiple parameters to

00:05:01,700 --> 00:05:07,790
the this F method we have all the

00:05:05,600 --> 00:05:09,380
substitutions now this is very simple

00:05:07,790 --> 00:05:12,590
expression but it can be any any

00:05:09,380 --> 00:05:15,980
expression you choose to put inside the

00:05:12,590 --> 00:05:19,040
string after an exclamation as after a

00:05:15,980 --> 00:05:20,750
dollar sign so this transformation

00:05:19,040 --> 00:05:25,280
happens in the past that the parser is

00:05:20,750 --> 00:05:26,630
not very intelligent the transformation

00:05:25,280 --> 00:05:29,720
is very dumb it does the same thing

00:05:26,630 --> 00:05:32,600
every time if you wrote Z instead of s

00:05:29,720 --> 00:05:37,340
you get a Zed there and that is what the

00:05:32,600 --> 00:05:40,190
the typer will see so consequently can

00:05:37,340 --> 00:05:42,560
anybody tell me what this does if you

00:05:40,190 --> 00:05:44,030
type this into a raffle there's no

00:05:42,560 --> 00:05:46,700
there's no Prelude you just just type

00:05:44,030 --> 00:05:48,020
this straight into ref or shout out if

00:05:46,700 --> 00:05:51,430
you know the answer I'll give you a

00:05:48,020 --> 00:05:51,430
couple of couple of seconds

00:05:54,810 --> 00:06:00,820
shout loud and confidently if you

00:05:57,220 --> 00:06:08,530
through someone's are true correct why

00:06:00,820 --> 00:06:11,980
is it true well it gets the sugared that

00:06:08,530 --> 00:06:14,740
equals becomes the method invocation on

00:06:11,980 --> 00:06:17,500
a newly constructed string context

00:06:14,740 --> 00:06:22,240
objects sorry I having a later point you

00:06:17,500 --> 00:06:24,580
could have to follow my finger and we

00:06:22,240 --> 00:06:26,620
put a string context after the dollar in

00:06:24,580 --> 00:06:28,870
there so that gets moved over to the

00:06:26,620 --> 00:06:30,550
parameter to equals and I carefully

00:06:28,870 --> 00:06:33,670
constructed it to have exactly the same

00:06:30,550 --> 00:06:35,980
parameters as the literals either side

00:06:33,670 --> 00:06:38,080
of that so that they would be the same

00:06:35,980 --> 00:06:41,010
and because the gold string context as a

00:06:38,080 --> 00:06:45,430
case class its equals method is is

00:06:41,010 --> 00:06:49,020
defined to be based on the parameters so

00:06:45,430 --> 00:06:51,670
those two are equal and we get true

00:06:49,020 --> 00:06:53,050
maybe that's not what you would expect

00:06:51,670 --> 00:06:55,480
maybe it expect us to be some sort of

00:06:53,050 --> 00:06:58,450
failure but as I said the the

00:06:55,480 --> 00:07:02,170
disagreeing happens it happens in a very

00:06:58,450 --> 00:07:04,000
dumb way and we can therefore rely on it

00:07:02,170 --> 00:07:05,770
to happen in that same way every single

00:07:04,000 --> 00:07:07,720
time so all we need to do if we're

00:07:05,770 --> 00:07:09,760
writing our own interpolator is we need

00:07:07,720 --> 00:07:12,540
to make that discovered version of the

00:07:09,760 --> 00:07:19,120
code compile so this is this is what

00:07:12,540 --> 00:07:24,340
contextual takes advantage of so given

00:07:19,120 --> 00:07:26,890
that how would we make some some D

00:07:24,340 --> 00:07:27,940
sugared code compile well one thing to

00:07:26,890 --> 00:07:33,040
do would be to make sure that that

00:07:27,940 --> 00:07:35,350
method invocation will work and string

00:07:33,040 --> 00:07:38,620
context obviously has a fixed set of

00:07:35,350 --> 00:07:40,930
methods to find on it so in order to

00:07:38,620 --> 00:07:42,550
have that what appears to be a method

00:07:40,930 --> 00:07:45,760
invocation work on a newly constructed

00:07:42,550 --> 00:07:49,210
string context we need to use extension

00:07:45,760 --> 00:07:54,100
methods who is not familiar the

00:07:49,210 --> 00:07:55,360
extension methods in Scala I can't any

00:07:54,100 --> 00:07:59,860
hands up but I can't see anything at all

00:07:55,360 --> 00:08:01,150
with these lights I so I'm taking for

00:07:59,860 --> 00:08:03,460
that the most people are familiar with

00:08:01,150 --> 00:08:05,020
them so we use implicit classes to

00:08:03,460 --> 00:08:06,550
provide additional methods or to

00:08:05,020 --> 00:08:07,520
decorate a particular type with

00:08:06,550 --> 00:08:09,440
additional methods

00:08:07,520 --> 00:08:11,900
that type and we can use that to

00:08:09,440 --> 00:08:14,720
basically add methods to a string

00:08:11,900 --> 00:08:16,970
context the data method basically with

00:08:14,720 --> 00:08:20,419
with the same name as the prefix where

00:08:16,970 --> 00:08:22,280
we want to use and that method is

00:08:20,419 --> 00:08:25,340
literally just a method so we can change

00:08:22,280 --> 00:08:27,770
the return type if we wanted to we could

00:08:25,340 --> 00:08:30,740
change the number of parameters the

00:08:27,770 --> 00:08:32,330
types of those parameters so remember

00:08:30,740 --> 00:08:33,800
with the s and surf letters just any but

00:08:32,330 --> 00:08:35,779
we could we could have the first one

00:08:33,800 --> 00:08:37,250
being into the second one be a string

00:08:35,779 --> 00:08:39,829
and you will only be allowed to

00:08:37,250 --> 00:08:43,370
substitute an INT followed by a string

00:08:39,829 --> 00:08:47,959
in your interpolated string if that's

00:08:43,370 --> 00:08:53,170
the case or because it is it is

00:08:47,959 --> 00:08:56,180
basically an orthogonal feature to to

00:08:53,170 --> 00:08:58,940
the body sugaring we could implement

00:08:56,180 --> 00:09:01,089
that method with a macro and this is

00:08:58,940 --> 00:09:04,029
where it gets exciting now that that is

00:09:01,089 --> 00:09:06,200
all I'm really going to say about macros

00:09:04,029 --> 00:09:11,000
contextual is implemented with a macro

00:09:06,200 --> 00:09:12,290
but don't don't switch off because I'm

00:09:11,000 --> 00:09:14,959
not going to talk about anything that

00:09:12,290 --> 00:09:16,310
requires any knowledge of macros the

00:09:14,959 --> 00:09:18,050
beauty of this is that you don't need to

00:09:16,310 --> 00:09:20,180
work with macros in order to take

00:09:18,050 --> 00:09:25,070
advantage of the features that

00:09:20,180 --> 00:09:27,800
contextual gives you so let's say we

00:09:25,070 --> 00:09:32,870
wanted to let us revisit this this

00:09:27,800 --> 00:09:35,899
simple essence up later we create a

00:09:32,870 --> 00:09:39,860
decorator on string contact this is our

00:09:35,899 --> 00:09:41,630
extension method the death sub what we

00:09:39,860 --> 00:09:45,920
want to do is have this this bottom line

00:09:41,630 --> 00:09:51,079
here compile so we define sub decorating

00:09:45,920 --> 00:09:55,220
the string context and we implement that

00:09:51,079 --> 00:10:00,279
sub method with this the longest line

00:09:55,220 --> 00:10:02,540
here context dot parts this part method

00:10:00,279 --> 00:10:05,209
comes from the original string context

00:10:02,540 --> 00:10:06,800
and it gives us the literal parts now

00:10:05,209 --> 00:10:08,000
there's a very important distinction to

00:10:06,800 --> 00:10:11,240
make throughout the rest of this talk

00:10:08,000 --> 00:10:16,050
between the literal parts of a string

00:10:11,240 --> 00:10:17,640
context and the substitutions which

00:10:16,050 --> 00:10:19,050
as far as compile-time is concerned

00:10:17,640 --> 00:10:20,100
those substitutions are holes because we

00:10:19,050 --> 00:10:22,709
don't know what they are we don't all

00:10:20,100 --> 00:10:24,480
the content is a compile-time we know

00:10:22,709 --> 00:10:28,800
what the literals contain we know the

00:10:24,480 --> 00:10:31,560
exact string values of those and then

00:10:28,800 --> 00:10:32,970
here we're taking the parts is the

00:10:31,560 --> 00:10:35,459
little part that we're interspersing

00:10:32,970 --> 00:10:37,649
them using the little known interspersed

00:10:35,459 --> 00:10:39,089
method on the collections library little

00:10:37,649 --> 00:10:43,430
known that doesn't actually exist but it

00:10:39,089 --> 00:10:45,420
illustrates the point we induce

00:10:43,430 --> 00:10:48,300
the parameters these are the

00:10:45,420 --> 00:10:49,769
substitutions we're mapping to string on

00:10:48,300 --> 00:10:52,829
all of those there they're just typed as

00:10:49,769 --> 00:10:54,329
any so we can do that and then we make

00:10:52,829 --> 00:10:56,519
the whole thing into a into a single

00:10:54,329 --> 00:10:57,930
string so I didn't want to write it in

00:10:56,519 --> 00:11:00,480
the in the long form with it sort of

00:10:57,930 --> 00:11:02,250
distraction the what it's actually doing

00:11:00,480 --> 00:11:03,420
we are literally in dispersing them so

00:11:02,250 --> 00:11:07,019
let's pretend that exists for the

00:11:03,420 --> 00:11:12,589
purpose of this example so that's how we

00:11:07,019 --> 00:11:12,589
would do a simple runtime interpolator

00:11:14,180 --> 00:11:21,660
but what contextual does is it gives you

00:11:18,029 --> 00:11:25,829
the ability to take some arbitrary code

00:11:21,660 --> 00:11:27,990
that you write so any any code and it

00:11:25,829 --> 00:11:31,140
gives you access to the static little

00:11:27,990 --> 00:11:32,610
parts of the interpolator string so that

00:11:31,140 --> 00:11:34,170
you can look at them you can you can run

00:11:32,610 --> 00:11:36,240
you can pass them you can run a regular

00:11:34,170 --> 00:11:38,190
expression on them you could do anything

00:11:36,240 --> 00:11:40,440
you like anything that you can write in

00:11:38,190 --> 00:11:45,959
code you can do with those literal parts

00:11:40,440 --> 00:11:47,520
and that will be run at compile time and

00:11:45,959 --> 00:11:48,810
then for each hole then the holes are

00:11:47,520 --> 00:11:50,279
kind of a difficult bit because we

00:11:48,810 --> 00:11:52,079
really don't know what's in them at

00:11:50,279 --> 00:11:54,899
compile time when we're when we're doing

00:11:52,079 --> 00:11:57,690
this so we can assign a context to each

00:11:54,899 --> 00:11:59,670
hole I'll talk more about what a context

00:11:57,690 --> 00:12:02,100
is but think of it now as like the

00:11:59,670 --> 00:12:05,070
numerated value describing what sorts of

00:12:02,100 --> 00:12:08,540
things can go in that hole the idea

00:12:05,070 --> 00:12:08,540
being that we will later constrain them

00:12:08,839 --> 00:12:13,649
one way we constrain the constrain them

00:12:11,399 --> 00:12:16,560
is that we can restrict which types can

00:12:13,649 --> 00:12:21,600
be substituted in which holes which

00:12:16,560 --> 00:12:24,810
contexts and we also can give different

00:12:21,600 --> 00:12:26,610
ways of interpreting different different

00:12:24,810 --> 00:12:27,880
types being substituted in two different

00:12:26,610 --> 00:12:29,920
contexts

00:12:27,880 --> 00:12:31,630
so the useful usefulness of all these

00:12:29,920 --> 00:12:32,769
different combinations will become

00:12:31,630 --> 00:12:35,740
apparent when I give you a couple of

00:12:32,769 --> 00:12:38,319
examples but it turns out that it's it's

00:12:35,740 --> 00:12:39,699
both possible and for certain kinds of

00:12:38,319 --> 00:12:46,540
interpolators it's it's a necessary

00:12:39,699 --> 00:12:48,699
requirement and one thing which I

00:12:46,540 --> 00:12:51,190
thought was very important often when

00:12:48,699 --> 00:12:54,040
you're writing a library like this which

00:12:51,190 --> 00:12:55,509
which is inter placing strings you want

00:12:54,040 --> 00:12:57,940
to be able to support types which you

00:12:55,509 --> 00:12:59,259
haven't yet considered you want to help

00:12:57,940 --> 00:13:02,529
support types which your downstream

00:12:59,259 --> 00:13:03,279
users may want to substitute into into

00:13:02,529 --> 00:13:06,310
the interpolator

00:13:03,279 --> 00:13:10,569
so we use type classes to do this and it

00:13:06,310 --> 00:13:14,230
is fully extensible so there's a few

00:13:10,569 --> 00:13:16,870
examples here URLs your eyes file paths

00:13:14,230 --> 00:13:20,009
class paths these can all be these can

00:13:16,870 --> 00:13:26,550
all be included javascript liske lisp

00:13:20,009 --> 00:13:30,190
haskell j s so good they listed it twice

00:13:26,550 --> 00:13:32,410
I'll delete that for next time you can

00:13:30,190 --> 00:13:35,170
embed Scala inside inside Scala

00:13:32,410 --> 00:13:36,790
you could put a regular expression in an

00:13:35,170 --> 00:13:42,759
interpolator string and have it have it

00:13:36,790 --> 00:13:43,870
checked use the facing messages I've got

00:13:42,759 --> 00:13:46,509
some more specific examples of these

00:13:43,870 --> 00:13:56,949
blitzer how am i doing for time I'm

00:13:46,509 --> 00:13:58,089
early yeah I'm ahead of schedule so we

00:13:56,949 --> 00:14:00,579
just pause a bit

00:13:58,089 --> 00:14:02,500
so this slide becomes great we could we

00:14:00,579 --> 00:14:05,139
could have a we can embed a date at a

00:14:02,500 --> 00:14:08,620
time in a string and we could check that

00:14:05,139 --> 00:14:11,199
they are the right format we could check

00:14:08,620 --> 00:14:13,689
that that is a valid timezone we could

00:14:11,199 --> 00:14:19,529
check that the three letters in the

00:14:13,689 --> 00:14:23,110
middle are a valid month name we could

00:14:19,529 --> 00:14:24,430
include URL make sure that the scheme is

00:14:23,110 --> 00:14:25,540
in the correct format that adds the

00:14:24,430 --> 00:14:29,560
right number of flashes in the right

00:14:25,540 --> 00:14:31,360
places for a file you could if you

00:14:29,560 --> 00:14:33,189
wanted to writer and interpolator that

00:14:31,360 --> 00:14:35,439
checks whether the file actually exists

00:14:33,189 --> 00:14:37,149
on your current system now maybe the

00:14:35,439 --> 00:14:38,319
useful maybe that's not that useful if

00:14:37,149 --> 00:14:39,670
you want to distribute your code

00:14:38,319 --> 00:14:41,830
elsewhere but if you know it's only

00:14:39,670 --> 00:14:43,810
running locally you could write in

00:14:41,830 --> 00:14:46,240
later that adds that constraints that

00:14:43,810 --> 00:14:49,150
checks that file exists before compiling

00:14:46,240 --> 00:14:51,340
the code or conversely it refuses to

00:14:49,150 --> 00:14:52,300
compile unless it knows that file is is

00:14:51,340 --> 00:14:54,430
present

00:14:52,300 --> 00:14:57,040
maybe maybe more reliable would be the

00:14:54,430 --> 00:14:59,350
class pass so if a file or resource

00:14:57,040 --> 00:15:02,110
exists on the class path we're good to

00:14:59,350 --> 00:15:06,040
be good to compile that if not we we

00:15:02,110 --> 00:15:07,810
throw a compile error there's some

00:15:06,040 --> 00:15:09,910
Haskell

00:15:07,810 --> 00:15:14,740
we could we could compile this and end

00:15:09,910 --> 00:15:18,910
up with we could actually fork fork out

00:15:14,740 --> 00:15:22,180
to GHC passing this code checking it

00:15:18,910 --> 00:15:23,710
works if it returns any errors then we

00:15:22,180 --> 00:15:25,660
could report them back through scholars

00:15:23,710 --> 00:15:27,610
error message system a compile error

00:15:25,660 --> 00:15:30,070
message system so these are all

00:15:27,610 --> 00:15:31,540
possibilities I'm a lot of these haven't

00:15:30,070 --> 00:15:35,080
been implemented some of them some them

00:15:31,540 --> 00:15:38,080
have regular expressions these are

00:15:35,080 --> 00:15:39,580
giving two examples there the first one

00:15:38,080 --> 00:15:42,700
we should compile I think the second one

00:15:39,580 --> 00:15:44,350
maybe we we would like to fail during

00:15:42,700 --> 00:15:49,150
compilation because there's no closing

00:15:44,350 --> 00:15:51,430
parenthesis use of use of facing

00:15:49,150 --> 00:15:53,260
messages we could even check these we

00:15:51,430 --> 00:15:56,620
could provide the compiler with a a

00:15:53,260 --> 00:16:01,000
dictionary and we could identify that

00:15:56,620 --> 00:16:03,880
I've misspelled occurred and this could

00:16:01,000 --> 00:16:05,800
be an error we could actually say no

00:16:03,880 --> 00:16:08,110
spelling mistakes and our and I use the

00:16:05,800 --> 00:16:10,840
facing code provided there in strings

00:16:08,110 --> 00:16:16,240
that are prefixed with message for

00:16:10,840 --> 00:16:16,780
example Jason probably seen things like

00:16:16,240 --> 00:16:19,330
this before

00:16:16,780 --> 00:16:21,490
rapture jason always used to do this and

00:16:19,330 --> 00:16:23,650
this can now be generalized into a

00:16:21,490 --> 00:16:26,410
contextual interpolator same thing with

00:16:23,650 --> 00:16:29,350
XML or Y Amal obviously the second

00:16:26,410 --> 00:16:30,460
example there shouldn't compile note

00:16:29,350 --> 00:16:33,430
we've also got a substitution in there

00:16:30,460 --> 00:16:38,980
so we can place a value called foo in

00:16:33,430 --> 00:16:41,800
that position not that that's fine now

00:16:38,980 --> 00:16:45,550
this one this is actually something

00:16:41,800 --> 00:16:49,060
which came about when I was working on

00:16:45,550 --> 00:16:50,380
the Scala world website last year object

00:16:49,060 --> 00:16:52,889
that's not a plug for Scala well here

00:16:50,380 --> 00:16:56,910
you should all come but

00:16:52,889 --> 00:16:58,769
I was I was working I was working late

00:16:56,910 --> 00:17:01,709
at night I had a problem which I'll show

00:16:58,769 --> 00:17:05,639
you in second but we have several

00:17:01,709 --> 00:17:06,990
interpolators here we have an ID so

00:17:05,639 --> 00:17:08,970
maybe that one is checks to make sure it

00:17:06,990 --> 00:17:11,189
doesn't contain spaces or characters

00:17:08,970 --> 00:17:14,880
that aren't supported in IDs we have a

00:17:11,189 --> 00:17:16,649
CSS size so we could check that in the

00:17:14,880 --> 00:17:20,939
valid format it's a number with valid

00:17:16,649 --> 00:17:24,750
units and then we have some CSS fragment

00:17:20,939 --> 00:17:26,610
of CSS which refers to the ID so I've

00:17:24,750 --> 00:17:27,659
used a set dollar grid by the way how

00:17:26,610 --> 00:17:29,760
many people here have had the misfortune

00:17:27,659 --> 00:17:34,230
to use CSS at some point in their

00:17:29,760 --> 00:17:39,149
careers your you've all suffered so this

00:17:34,230 --> 00:17:41,669
will this will make it I mean if this if

00:17:39,149 --> 00:17:43,889
this gets some adoption then then then

00:17:41,669 --> 00:17:48,059
you could all remove this a lot of a

00:17:43,889 --> 00:17:50,760
pane of CSS so we can refer to the ID by

00:17:48,059 --> 00:17:53,159
a substitution so we're using dollar

00:17:50,760 --> 00:17:55,169
grid which means that it's difficult to

00:17:53,159 --> 00:17:56,340
misspell that the compiler will tell us

00:17:55,169 --> 00:17:59,970
if we're referring to something which

00:17:56,340 --> 00:18:02,399
doesn't exist and in the HTML example

00:17:59,970 --> 00:18:06,179
below as I haven't used it there but we

00:18:02,399 --> 00:18:09,690
could refer to we could refer to I be

00:18:06,179 --> 00:18:11,340
equals dollar grid down there and that

00:18:09,690 --> 00:18:13,440
would that would also make sure that we

00:18:11,340 --> 00:18:15,799
are cross-referencing these these two

00:18:13,440 --> 00:18:17,580
things and the compiler is checking them

00:18:15,799 --> 00:18:21,559
so there's also an opportunity for

00:18:17,580 --> 00:18:25,950
Interop between different interpolators

00:18:21,559 --> 00:18:28,649
we could also check that font - size is

00:18:25,950 --> 00:18:32,010
a valid property for CSS and that the

00:18:28,649 --> 00:18:36,809
parameter that's passed to that is a

00:18:32,010 --> 00:18:38,639
valid sighs I don't know why sighs

00:18:36,809 --> 00:18:40,740
shouldn't be a double actually ignore

00:18:38,639 --> 00:18:46,559
that double type description there that

00:18:40,740 --> 00:18:49,559
should be a a size does that all make

00:18:46,559 --> 00:18:51,510
some sense now if you think about how

00:18:49,559 --> 00:18:53,010
this would be implemented the CSS

00:18:51,510 --> 00:18:58,549
interpolator would be able to read the

00:18:53,010 --> 00:19:00,779
contents of this CSS string here and

00:18:58,549 --> 00:19:03,840
anything you can work out just by

00:19:00,779 --> 00:19:05,610
parsing and checking checking a list of

00:19:03,840 --> 00:19:06,630
valid properties and the types that are

00:19:05,610 --> 00:19:10,530
associated with those

00:19:06,630 --> 00:19:11,850
can be done with with contextual okay so

00:19:10,530 --> 00:19:14,340
this is what I didn't have when I was

00:19:11,850 --> 00:19:16,920
when I was working on the the old Scala

00:19:14,340 --> 00:19:19,020
world website and instead I was just

00:19:16,920 --> 00:19:22,170
using plain CSS and I accidentally I

00:19:19,020 --> 00:19:27,240
later discovered I accidentally deleted

00:19:22,170 --> 00:19:31,430
a closing brace from one of my style two

00:19:27,240 --> 00:19:34,350
definitions and what happened was this

00:19:31,430 --> 00:19:38,100
this abomination this is mile sevens dog

00:19:34,350 --> 00:19:40,860
this is John Durr goes freshly licked it

00:19:38,100 --> 00:19:42,000
seems there is a whole mess of text

00:19:40,860 --> 00:19:43,920
around that I mean this is the venue

00:19:42,000 --> 00:19:46,710
that we have service car although bit of

00:19:43,920 --> 00:19:48,300
it over there and a bit over there but

00:19:46,710 --> 00:19:50,760
bit of a topless okay I mean that was

00:19:48,300 --> 00:19:53,510
that was almost intentional but the

00:19:50,760 --> 00:19:56,460
whole thing is a horrible abomination

00:19:53,510 --> 00:19:58,770
just because I accidentally delete the

00:19:56,460 --> 00:20:02,010
closing brace and half of the style

00:19:58,770 --> 00:20:04,380
definitions on the page got deleted now

00:20:02,010 --> 00:20:07,520
if I if I embedded that in and played a

00:20:04,380 --> 00:20:10,620
string and check that with a CSS parser

00:20:07,520 --> 00:20:12,360
which I have all the information

00:20:10,620 --> 00:20:14,100
available at compile time to do that

00:20:12,360 --> 00:20:16,350
then this could have been avoided

00:20:14,100 --> 00:20:18,870
you could avoided having ever seen this

00:20:16,350 --> 00:20:23,460
and you would have been all the better

00:20:18,870 --> 00:20:25,170
for it so I'm going to look at an

00:20:23,460 --> 00:20:28,850
example in a little bit more detail on

00:20:25,170 --> 00:20:32,850
food quite quickly but XML I know

00:20:28,850 --> 00:20:35,310
probably many of you maybe maybe many of

00:20:32,850 --> 00:20:37,860
you are forced to use XML but and you've

00:20:35,310 --> 00:20:40,380
maybe use something like Jason instead

00:20:37,860 --> 00:20:42,390
if you could but I think everybody here

00:20:40,380 --> 00:20:47,370
is at least familiar with what XML looks

00:20:42,390 --> 00:20:53,700
like and some of the constraints you get

00:20:47,370 --> 00:20:56,070
on what is valid XML and what is not so

00:20:53,700 --> 00:20:58,710
here's his example we can better string

00:20:56,070 --> 00:21:01,350
inside some food tags in in XML that

00:20:58,710 --> 00:21:03,540
that works fine but no problem there we

00:21:01,350 --> 00:21:05,880
could maybe try and embed an exception

00:21:03,540 --> 00:21:09,260
but we don't want to allow that so

00:21:05,880 --> 00:21:11,040
contextual gives you a way to prevent a

00:21:09,260 --> 00:21:12,740
substitution of a type that we don't

00:21:11,040 --> 00:21:15,840
really have a good interpretation of

00:21:12,740 --> 00:21:18,090
inside XML we can prevent that from

00:21:15,840 --> 00:21:19,860
being embedded and by the way this this

00:21:18,090 --> 00:21:20,250
is in a library called xylophone which

00:21:19,860 --> 00:21:24,000
i've been

00:21:20,250 --> 00:21:25,560
working on as a I I guess it's my my

00:21:24,000 --> 00:21:28,830
sort of real-world implementation of a

00:21:25,560 --> 00:21:31,380
sort of more than a trivial contextual

00:21:28,830 --> 00:21:35,060
interpolator so this is an interpolator

00:21:31,380 --> 00:21:37,290
for XML which is given its own library

00:21:35,060 --> 00:21:40,950
it's open source and you can you can

00:21:37,290 --> 00:21:42,330
check it on my github account so this is

00:21:40,950 --> 00:21:45,470
the second line here where we are not

00:21:42,330 --> 00:21:48,420
going to accept this is a compile error

00:21:45,470 --> 00:21:50,760
compiling these two are both fine

00:21:48,420 --> 00:21:54,210
we checked they're well-formed we check

00:21:50,760 --> 00:21:55,950
the tags match up we check there's

00:21:54,210 --> 00:22:00,090
nothing inappropriate in the wrong

00:21:55,950 --> 00:22:04,020
places however if for example we missed

00:22:00,090 --> 00:22:05,790
the closing tag of bar we get an error

00:22:04,020 --> 00:22:08,070
here and the error would would point at

00:22:05,790 --> 00:22:11,790
the position where it first identifies

00:22:08,070 --> 00:22:15,840
so this is not valid in the second line

00:22:11,790 --> 00:22:18,780
as is not in in quotes so this is not

00:22:15,840 --> 00:22:21,000
it's not valid and this this last line

00:22:18,780 --> 00:22:25,320
looks kind of okay until you consider

00:22:21,000 --> 00:22:26,820
that less than symbol is starting to

00:22:25,320 --> 00:22:30,090
look like an opening tag at least to a

00:22:26,820 --> 00:22:32,400
parser so we we don't allow this now

00:22:30,090 --> 00:22:34,770
this you might accidentally copy/paste

00:22:32,400 --> 00:22:36,630
or at least the expression 1 is less

00:22:34,770 --> 00:22:39,750
than or equal to 2 you might

00:22:36,630 --> 00:22:42,210
accidentally copy paste this into the

00:22:39,750 --> 00:22:44,100
into the code and you maybe wouldn't

00:22:42,210 --> 00:22:46,110
notice until you come to pass it at

00:22:44,100 --> 00:22:50,390
runtime that this is a this is a problem

00:22:46,110 --> 00:22:50,390
so contextual will stop you

00:22:53,490 --> 00:23:00,600
what's wrong with this one if you did

00:22:56,910 --> 00:23:02,010
simple string substitution content put

00:23:00,600 --> 00:23:05,550
that in in place there this would

00:23:02,010 --> 00:23:07,290
actually work you might assume but

00:23:05,550 --> 00:23:10,920
remember a compile time we don't know

00:23:07,290 --> 00:23:13,560
that I mean in the general case we don't

00:23:10,920 --> 00:23:15,600
know that a variable this one happens to

00:23:13,560 --> 00:23:18,780
work but as a general variable we don't

00:23:15,600 --> 00:23:21,150
know that it contains code contains

00:23:18,780 --> 00:23:24,510
content which just happens to close that

00:23:21,150 --> 00:23:26,880
that's that opening tag so although this

00:23:24,510 --> 00:23:29,280
would work with simple string

00:23:26,880 --> 00:23:31,140
substitutions in the general case we

00:23:29,280 --> 00:23:33,620
don't know that so we we forbid that at

00:23:31,140 --> 00:23:33,620
compile time

00:23:34,499 --> 00:23:38,879
have you all seen enough XML yet nearly

00:23:37,570 --> 00:23:42,070
there

00:23:38,879 --> 00:23:45,129
conversely if you if you if you embedded

00:23:42,070 --> 00:23:48,190
that in a position where it would be

00:23:45,129 --> 00:23:51,580
invalid that is actually fine by

00:23:48,190 --> 00:23:54,399
contextual standards because it knows

00:23:51,580 --> 00:23:59,559
that it needs to escape the closing

00:23:54,399 --> 00:24:02,259
angle bracket so the interpretation of

00:23:59,559 --> 00:24:09,639
the substitution can differ depending on

00:24:02,259 --> 00:24:13,509
the context so here we're going to embed

00:24:09,639 --> 00:24:18,850
my name into several positions in in in

00:24:13,509 --> 00:24:21,700
some XML here the second line we can

00:24:18,850 --> 00:24:23,980
actually despite the lack of quotes we

00:24:21,700 --> 00:24:26,470
can unambiguously interpret that we know

00:24:23,980 --> 00:24:29,049
how we know the only possible way that

00:24:26,470 --> 00:24:30,700
could make sense which is to when we do

00:24:29,049 --> 00:24:34,119
the substitution because we know it's a

00:24:30,700 --> 00:24:38,970
string we just put quotes around it so

00:24:34,119 --> 00:24:41,409
that's fine but the very next line is

00:24:38,970 --> 00:24:45,279
basically the same except the quotes

00:24:41,409 --> 00:24:47,440
already there for us so we need a way to

00:24:45,279 --> 00:24:49,090
make both of these work because I mean

00:24:47,440 --> 00:24:55,240
we can both both of these can be

00:24:49,090 --> 00:24:58,929
unambiguously interpreted I think so

00:24:55,240 --> 00:25:01,059
the answer is that these two the first

00:24:58,929 --> 00:25:03,399
two substitutions there have different

00:25:01,059 --> 00:25:05,679
contexts because they're in different

00:25:03,399 --> 00:25:07,690
positions one is inside quotes one is

00:25:05,679 --> 00:25:10,629
immediately off the equal sign for an

00:25:07,690 --> 00:25:12,820
attribute both are both are valid but

00:25:10,629 --> 00:25:18,009
the interpretation of the substitution

00:25:12,820 --> 00:25:20,169
is different the last two are pretty

00:25:18,009 --> 00:25:23,440
straightforward in a general case we

00:25:20,169 --> 00:25:25,899
don't know that we can substitute a name

00:25:23,440 --> 00:25:28,210
in a closing in a self closing tag I

00:25:25,899 --> 00:25:29,980
mean string substitution would work

00:25:28,210 --> 00:25:34,840
again but in the general case we don't

00:25:29,980 --> 00:25:38,049
know that now if you wanted to extend

00:25:34,840 --> 00:25:40,740
this this is a bit of a preview as to

00:25:38,049 --> 00:25:43,389
what you could do as a user of xylophone

00:25:40,740 --> 00:25:45,909
so you had a record type I don't know

00:25:43,389 --> 00:25:46,490
what the record type is it's your own

00:25:45,909 --> 00:25:48,470
user

00:25:46,490 --> 00:25:49,850
sign type so maybe in the companion

00:25:48,470 --> 00:25:53,780
objects that record you would like to

00:25:49,850 --> 00:25:58,670
provide a type class instance which

00:25:53,780 --> 00:26:01,460
determines how that is embedded in in a

00:25:58,670 --> 00:26:03,320
substitution and the way you write this

00:26:01,460 --> 00:26:06,140
that there is there is some neat syntax

00:26:03,320 --> 00:26:09,110
which maybe looks a little bit alien

00:26:06,140 --> 00:26:12,530
it's meant to appear to be like a match

00:26:09,110 --> 00:26:14,990
blog instead of case we say on now body

00:26:12,530 --> 00:26:17,090
and actually both refer to context so if

00:26:14,990 --> 00:26:22,130
you're importing position so XML body

00:26:17,090 --> 00:26:25,970
not inside a tag then get the name value

00:26:22,130 --> 00:26:28,880
from this record type whereas if you are

00:26:25,970 --> 00:26:30,440
substituting a record type in attribute

00:26:28,880 --> 00:26:32,510
position we're going to interpret it

00:26:30,440 --> 00:26:35,450
differently we're going to just take the

00:26:32,510 --> 00:26:38,300
ID ideas ninja turtle call to string on

00:26:35,450 --> 00:26:41,390
that so we get a string now the types

00:26:38,300 --> 00:26:43,610
involves are quite complicated with this

00:26:41,390 --> 00:26:46,910
but the nice thing is that you don't

00:26:43,610 --> 00:26:50,690
need to see them at least not until not

00:26:46,910 --> 00:26:53,030
until that implicit type the implicit

00:26:50,690 --> 00:26:55,550
value a requires a type description

00:26:53,030 --> 00:26:56,809
which is going to be something in the

00:26:55,550 --> 00:26:58,220
later version of scarlet so we'll have

00:26:56,809 --> 00:27:00,950
to find a way to work around that but

00:26:58,220 --> 00:27:02,420
the embed method there produces

00:27:00,950 --> 00:27:04,220
something with a complicated type which

00:27:02,420 --> 00:27:06,860
gives context will exactly what it needs

00:27:04,220 --> 00:27:10,220
at compile time to know that this is a

00:27:06,860 --> 00:27:14,240
valid specification for how you embed a

00:27:10,220 --> 00:27:17,120
record in body position and in actually

00:27:14,240 --> 00:27:21,620
position okay so what I'm saying it here

00:27:17,120 --> 00:27:23,090
is don't don't look at the ugly details

00:27:21,620 --> 00:27:24,800
you don't you don't need to see the

00:27:23,090 --> 00:27:28,190
details this is this is what you write

00:27:24,800 --> 00:27:32,630
if you want to do the to do to do a

00:27:28,190 --> 00:27:35,450
substitution and in itself it's quite

00:27:32,630 --> 00:27:37,760
neat you can even do a type class-based

00:27:35,450 --> 00:27:40,250
embedding so you can embed anything that

00:27:37,760 --> 00:27:43,550
itself can be shown so anything we'd

00:27:40,250 --> 00:27:44,690
have a show type class so that's a

00:27:43,550 --> 00:27:47,740
little bit more complicated but

00:27:44,690 --> 00:27:50,510
basically we're calling we're sort of

00:27:47,740 --> 00:27:54,290
using the show clot show type class to

00:27:50,510 --> 00:27:56,270
get a string from some type T which

00:27:54,290 --> 00:27:58,100
would remain abstract for this

00:27:56,270 --> 00:28:00,170
definition and we can then embed

00:27:58,100 --> 00:28:04,760
anything sharable insider

00:28:00,170 --> 00:28:08,150
and it's a plaited string so I'm going

00:28:04,760 --> 00:28:11,000
to spend the rest of the talk going

00:28:08,150 --> 00:28:14,090
through creating your own interpolator

00:28:11,000 --> 00:28:15,440
and I did this at lambda comps I've

00:28:14,090 --> 00:28:21,140
gotten to change that URL at the bottom

00:28:15,440 --> 00:28:24,290
that that was my example but what I want

00:28:21,140 --> 00:28:27,620
to create and there's about seven set is

00:28:24,290 --> 00:28:29,900
a URL and serve later that will check

00:28:27,620 --> 00:28:34,220
the contents of this string and we'll

00:28:29,900 --> 00:28:39,440
check that the the substitution for page

00:28:34,220 --> 00:28:42,620
is is appropriate so step one I will

00:28:39,440 --> 00:28:44,420
just talk through each step in detail

00:28:42,620 --> 00:28:46,010
later but very quickly we're going to

00:28:44,420 --> 00:28:48,770
create the interpolator that's that's an

00:28:46,010 --> 00:28:52,160
object we want to bind that newly

00:28:48,770 --> 00:28:55,910
created in turf later to some prefix in

00:28:52,160 --> 00:28:57,200
this case it'll be URL we're then going

00:28:55,910 --> 00:29:01,730
to write some code which checks the

00:28:57,200 --> 00:29:03,530
content of that string or at least

00:29:01,730 --> 00:29:07,520
checks the literal parts the bits that

00:29:03,530 --> 00:29:09,260
we know at compile time let me going to

00:29:07,520 --> 00:29:10,880
define some context some possible

00:29:09,260 --> 00:29:13,400
contexts that you might make a

00:29:10,880 --> 00:29:14,780
substitution in some of them will be

00:29:13,400 --> 00:29:18,830
valid some of them will will not be

00:29:14,780 --> 00:29:21,080
valid and then to reach a hole now here

00:29:18,830 --> 00:29:25,790
there is only one hole it is where the

00:29:21,080 --> 00:29:29,030
word the expression page is for every

00:29:25,790 --> 00:29:30,560
hole we will assign a context to that so

00:29:29,030 --> 00:29:36,950
maybe the context we want here is going

00:29:30,560 --> 00:29:40,310
to be pass position and then we need to

00:29:36,950 --> 00:29:42,200
define how that evaluates at runtime so

00:29:40,310 --> 00:29:44,330
everything I've talked about so far is

00:29:42,200 --> 00:29:47,750
more focused on the compile time it

00:29:44,330 --> 00:29:49,820
focused on how we interpret this during

00:29:47,750 --> 00:29:51,710
compilation we don't talk about

00:29:49,820 --> 00:29:54,140
well actually getting we need to get an

00:29:51,710 --> 00:29:56,090
object out of this at the end of it so

00:29:54,140 --> 00:29:59,480
assuming it passes compilation we then

00:29:56,090 --> 00:30:00,680
we then need to evaluate it and then as

00:29:59,480 --> 00:30:03,320
you saw in the previous couple of slides

00:30:00,680 --> 00:30:07,180
we want to define how certain types can

00:30:03,320 --> 00:30:10,070
be embedded in that interpolator

00:30:07,180 --> 00:30:12,110
so this is really easy step one we just

00:30:10,070 --> 00:30:13,639
create an object and it extends

00:30:12,110 --> 00:30:19,999
interpolator which comes from

00:30:13,639 --> 00:30:23,529
contextual that's it so I will add some

00:30:19,999 --> 00:30:23,529
more contents this object in a second

00:30:23,649 --> 00:30:32,899
here we're going to use a an extension

00:30:28,249 --> 00:30:36,440
method on string context it's actually

00:30:32,899 --> 00:30:39,979
an extension field and this is actually

00:30:36,440 --> 00:30:41,479
where the macro gets expanded you don't

00:30:39,979 --> 00:30:43,009
need to see that this is all you need to

00:30:41,479 --> 00:30:44,179
write and there's there's two things you

00:30:43,009 --> 00:30:46,009
probably need to change you need to

00:30:44,179 --> 00:30:48,109
change the name of the vowel to the name

00:30:46,009 --> 00:30:50,599
the prefix you want and you need to

00:30:48,109 --> 00:30:53,119
change the name of the interpolator

00:30:50,599 --> 00:30:54,769
object that you bind it to otherwise

00:30:53,119 --> 00:31:03,009
just copy-paste this and change those

00:30:54,769 --> 00:31:05,179
two so that that's really easy and then

00:31:03,009 --> 00:31:07,849
we're going to write the code that

00:31:05,179 --> 00:31:10,789
actually checks what is in the

00:31:07,849 --> 00:31:12,829
interpolated string and we have we have

00:31:10,789 --> 00:31:14,269
access to all the literals here all the

00:31:12,829 --> 00:31:19,399
little parts all statically known

00:31:14,269 --> 00:31:26,269
literals we just call the literals

00:31:19,399 --> 00:31:27,649
method of the context CTX parameter - so

00:31:26,269 --> 00:31:28,940
I'm indeed sorry feed the mess we're

00:31:27,649 --> 00:31:31,219
implementing is called contextualise

00:31:28,940 --> 00:31:32,509
which is whether where the library gets

00:31:31,219 --> 00:31:34,639
its name from but we're going to

00:31:32,509 --> 00:31:36,169
implement implement that with code which

00:31:34,639 --> 00:31:41,019
checks that those string literals

00:31:36,169 --> 00:31:43,519
contain what if we want them to or

00:31:41,019 --> 00:31:47,570
report an error if they if they don't

00:31:43,519 --> 00:31:49,070
and this code has access to a list of

00:31:47,570 --> 00:31:53,269
strings so anything you can do with the

00:31:49,070 --> 00:31:55,429
list of strings you can you can do a

00:31:53,269 --> 00:31:58,369
compile time with just by putting into

00:31:55,429 --> 00:32:01,369
this contextualized method so this could

00:31:58,369 --> 00:32:03,499
be anything from I mean one possibility

00:32:01,369 --> 00:32:05,989
if you want to do is you could you could

00:32:03,499 --> 00:32:08,959
take the you could check whether the

00:32:05,989 --> 00:32:10,579
list contains just one value and that

00:32:08,959 --> 00:32:13,519
means there are no holes and the whole

00:32:10,579 --> 00:32:15,469
thing is a it's just a static URL and

00:32:13,519 --> 00:32:17,899
then you could actually say well I'm

00:32:15,469 --> 00:32:22,490
going to send a request to that URL at

00:32:17,899 --> 00:32:25,670
compile time bear with me on this

00:32:22,490 --> 00:32:26,630
and if you get a 404 back you could say

00:32:25,670 --> 00:32:31,040
well actually maybe you got a broken

00:32:26,630 --> 00:32:33,830
link in your code that is that is a

00:32:31,040 --> 00:32:35,660
possibility if you can if you can do it

00:32:33,830 --> 00:32:40,820
at run time you can do it a compile time

00:32:35,660 --> 00:32:44,179
with contextual and then we have to

00:32:40,820 --> 00:32:48,410
return nil while sorry in the case where

00:32:44,179 --> 00:32:50,179
we have we have no no holes we will

00:32:48,410 --> 00:32:53,000
return nil I'll show you the more

00:32:50,179 --> 00:32:54,740
interesting case in a second by the way

00:32:53,000 --> 00:32:57,950
it might be worth thinking well while

00:32:54,740 --> 00:33:00,890
I'm talking about this if there's some

00:32:57,950 --> 00:33:04,340
sort of dsl you will work with in your

00:33:00,890 --> 00:33:06,170
day jobs frequently especially if it's

00:33:04,340 --> 00:33:08,270
one that you often get runtime errors

00:33:06,170 --> 00:33:10,360
with when it's when that dsl gets past

00:33:08,270 --> 00:33:12,170
or it refers to things which don't exist

00:33:10,360 --> 00:33:13,880
have a think about how you might

00:33:12,170 --> 00:33:18,760
implement that or implement an

00:33:13,880 --> 00:33:18,760
interpolator for that with contextual

00:33:22,590 --> 00:33:27,240
so that was that last slide was sort of

00:33:24,990 --> 00:33:33,330
a happy path where we never have any any

00:33:27,240 --> 00:33:35,879
failures but what happens if we do we

00:33:33,330 --> 00:33:39,870
want to report back to the user some

00:33:35,879 --> 00:33:43,590
error message now I'm assuming the

00:33:39,870 --> 00:33:46,279
existence of a URL but pars method which

00:33:43,590 --> 00:33:48,899
I'm calling around the middle there

00:33:46,279 --> 00:33:50,940
let's assume for this this simplified

00:33:48,899 --> 00:33:55,350
example that there is only there is only

00:33:50,940 --> 00:33:57,690
one the list of literals contains only a

00:33:55,350 --> 00:33:59,700
single value ie there are no holes let's

00:33:57,690 --> 00:34:03,450
assume that and we just try and pass

00:33:59,700 --> 00:34:05,519
that URL to make sure it's valid and our

00:34:03,450 --> 00:34:10,139
passed method either returns none it

00:34:05,519 --> 00:34:13,200
says if it's a valid URL or it reports

00:34:10,139 --> 00:34:14,669
that there's a parsing error and we can

00:34:13,200 --> 00:34:16,589
look at that this is all it all looks

00:34:14,669 --> 00:34:18,300
like very runtime code but we're going

00:34:16,589 --> 00:34:20,310
to run it at the compile time which

00:34:18,300 --> 00:34:21,720
means we can abort we can abort the

00:34:20,310 --> 00:34:24,750
entire compilation just because this

00:34:21,720 --> 00:34:27,480
this URL is not valid and we passed it

00:34:24,750 --> 00:34:30,149
three parameters the literal where where

00:34:27,480 --> 00:34:35,119
the problem is occurring the offset into

00:34:30,149 --> 00:34:39,500
that so when you get a compile error

00:34:35,119 --> 00:34:43,530
you'd only get a little caret little

00:34:39,500 --> 00:34:47,220
Chinese hat symbol circumflex which

00:34:43,530 --> 00:34:49,079
points at the compilers best guess as to

00:34:47,220 --> 00:34:52,679
where the errors you can decide where

00:34:49,079 --> 00:34:55,200
that goes so you can you can pick the

00:34:52,679 --> 00:34:56,460
offset that's just an integer and you

00:34:55,200 --> 00:34:58,710
can report the message that the user

00:34:56,460 --> 00:35:01,050
sees that can be as long as short as you

00:34:58,710 --> 00:35:02,490
like so we've never done interface to

00:35:01,050 --> 00:35:05,329
reporting compile errors that that

00:35:02,490 --> 00:35:07,740
doesn't doesn't appear to have any real

00:35:05,329 --> 00:35:12,319
complicated interaction with compiler

00:35:07,740 --> 00:35:12,319
api's so that's that's nice

00:35:12,359 --> 00:35:18,470
then remembered none is the happy path

00:35:14,460 --> 00:35:18,470
which is going to return nil for now

00:35:20,890 --> 00:35:27,610
now let's dissect this URL in red there

00:35:25,090 --> 00:35:32,160
is the scheme so let's say that that is

00:35:27,610 --> 00:35:35,820
one context then there's a domain name

00:35:32,160 --> 00:35:38,620
then flash them there's a path in green

00:35:35,820 --> 00:35:41,170
and then maybe we have query parameters

00:35:38,620 --> 00:35:44,290
so maybe there's a series of keys and

00:35:41,170 --> 00:35:45,880
values there could be multiple keys I

00:35:44,290 --> 00:35:48,930
mean nobody got one example here queue

00:35:45,880 --> 00:35:51,820
but there could be many of those and

00:35:48,930 --> 00:35:55,380
three to those we can create a case

00:35:51,820 --> 00:35:58,210
object which extends the seal trait and

00:35:55,380 --> 00:36:01,510
we are just here defining all the

00:35:58,210 --> 00:36:04,510
possible contexts in in that string so

00:36:01,510 --> 00:36:06,520
any position you decide to make a

00:36:04,510 --> 00:36:10,990
substitution we can work out what the

00:36:06,520 --> 00:36:15,450
context would be and what we're going to

00:36:10,990 --> 00:36:18,550
do at compile time we're going to

00:36:15,450 --> 00:36:22,600
execute code like you saw two slides ago

00:36:18,550 --> 00:36:24,100
where we run URL path and we're going to

00:36:22,600 --> 00:36:25,420
have to somehow and I don't want to talk

00:36:24,100 --> 00:36:27,400
in any detail about how you might do

00:36:25,420 --> 00:36:29,290
this because whatever DSL you're using

00:36:27,400 --> 00:36:32,860
it'll have a different a different way

00:36:29,290 --> 00:36:35,620
of different way of doing the analysis

00:36:32,860 --> 00:36:38,320
to decide what what the context for each

00:36:35,620 --> 00:36:39,820
hole is but we're going to do that

00:36:38,320 --> 00:36:44,230
analysis at the end of it we will return

00:36:39,820 --> 00:36:45,850
a list in order with a one to one

00:36:44,230 --> 00:36:47,830
mapping free to the hole so we're going

00:36:45,850 --> 00:36:49,990
to say in this example the first hole

00:36:47,830 --> 00:36:53,290
has what we've got the path parameter

00:36:49,990 --> 00:36:55,740
here that has context path as to find on

00:36:53,290 --> 00:37:00,190
the previous slide and value has

00:36:55,740 --> 00:37:02,800
unsurprisingly value context so given

00:37:00,190 --> 00:37:05,020
given that we've we've given the

00:37:02,800 --> 00:37:07,210
compiler information about a little bit

00:37:05,020 --> 00:37:09,850
of information about how we expect it to

00:37:07,210 --> 00:37:14,830
interpret certain types and certain

00:37:09,850 --> 00:37:16,180
values in those positions and then like

00:37:14,830 --> 00:37:20,080
I said we need to have some way of

00:37:16,180 --> 00:37:23,530
actually creating this object we need to

00:37:20,080 --> 00:37:25,900
return something from the distant cell

00:37:23,530 --> 00:37:28,270
plate of string so when we would be

00:37:25,900 --> 00:37:31,540
write code like the very first line on

00:37:28,270 --> 00:37:33,569
the screen there what would we want to

00:37:31,540 --> 00:37:35,920
get back well

00:37:33,569 --> 00:37:38,160
there is there is part of standard

00:37:35,920 --> 00:37:43,260
library there is the java net URL

00:37:38,160 --> 00:37:45,280
factory so let's just use that because I

00:37:43,260 --> 00:37:49,810
can't leave a good reason actually well

00:37:45,280 --> 00:37:50,980
we're going to use that so we can as

00:37:49,810 --> 00:37:54,300
long as we can we can implement this

00:37:50,980 --> 00:37:58,270
method here we have access to all of the

00:37:54,300 --> 00:38:02,050
all of the parts of the interface of

00:37:58,270 --> 00:38:06,220
string now not just the static literal

00:38:02,050 --> 00:38:08,800
ones where we're now in runtime so the

00:38:06,220 --> 00:38:09,490
evaluate method is get it has runtime

00:38:08,800 --> 00:38:11,319
information

00:38:09,490 --> 00:38:15,250
it actually has access to the evaluated

00:38:11,319 --> 00:38:17,260
expressions that get substituted so we

00:38:15,250 --> 00:38:18,579
have access through everything now it's

00:38:17,260 --> 00:38:22,200
a superset of the information we had at

00:38:18,579 --> 00:38:26,560
compile time and we can just create a

00:38:22,200 --> 00:38:28,750
URL from that and therefore the return

00:38:26,560 --> 00:38:34,000
type of this this URL interpolator will

00:38:28,750 --> 00:38:37,329
be a java net URL this is very similar

00:38:34,000 --> 00:38:40,210
to what we saw before so depending on

00:38:37,329 --> 00:38:42,280
the context we want to we want to make

00:38:40,210 --> 00:38:44,980
the substitution of a type in a

00:38:42,280 --> 00:38:50,170
particular way now

00:38:44,980 --> 00:38:53,020
Parvez keys and values these all need to

00:38:50,170 --> 00:38:54,730
be URL encoded so we define these

00:38:53,020 --> 00:38:59,380
lambdas here that describe how that

00:38:54,730 --> 00:39:02,349
substitution will take place now this is

00:38:59,380 --> 00:39:06,040
defined in the library which is which is

00:39:02,349 --> 00:39:09,520
quite useful because it means users of

00:39:06,040 --> 00:39:12,730
that library they don't have a good way

00:39:09,520 --> 00:39:16,270
to make an injection attack if they

00:39:12,730 --> 00:39:20,230
wanted to if you try to substitute a

00:39:16,270 --> 00:39:24,310
string a bear string into a and

00:39:20,230 --> 00:39:26,079
interpolated URL for example the library

00:39:24,310 --> 00:39:27,339
is defining how you how you do the

00:39:26,079 --> 00:39:29,380
encodings how you how you do the

00:39:27,339 --> 00:39:33,700
embedding it doesn't let you it doesn't

00:39:29,380 --> 00:39:37,060
require you as the user to to define at

00:39:33,700 --> 00:39:38,650
the call site how the escaping works so

00:39:37,060 --> 00:39:41,980
that that's quite nice it makes it

00:39:38,650 --> 00:39:44,980
actually impossible to to do unless you

00:39:41,980 --> 00:39:46,830
try very hard to circumvent it for the

00:39:44,980 --> 00:39:49,050
domain I mean I've

00:39:46,830 --> 00:39:53,230
maybe we shouldn't really have the Maine

00:39:49,050 --> 00:39:54,490
listed there because in the general case

00:39:53,230 --> 00:39:56,260
I mean we can what I've done here is

00:39:54,490 --> 00:40:00,180
I've made the domain lowercase I've

00:39:56,260 --> 00:40:02,470
removed all the uninteresting characters

00:40:00,180 --> 00:40:05,470
it's all the interesting characters

00:40:02,470 --> 00:40:07,380
let's let the uninteresting ones but

00:40:05,470 --> 00:40:09,160
there's no real canonical way to

00:40:07,380 --> 00:40:11,980
substitute a string into a domain name

00:40:09,160 --> 00:40:14,620
so in this particular example maybe

00:40:11,980 --> 00:40:20,590
we're better if we just deleted that the

00:40:14,620 --> 00:40:22,360
main case there and then we would be

00:40:20,590 --> 00:40:24,610
then users would be prevented from

00:40:22,360 --> 00:40:34,210
making any substitution in the main

00:40:24,610 --> 00:40:39,580
position what this is this is more of a

00:40:34,210 --> 00:40:41,530
subtlety of a contextual we we've

00:40:39,580 --> 00:40:43,240
assumed generally input types to be

00:40:41,530 --> 00:40:46,270
strings I mean the whole thing is a

00:40:43,240 --> 00:40:49,470
string in all cases but there is the

00:40:46,270 --> 00:40:52,870
possibility of having different

00:40:49,470 --> 00:40:54,640
different sorts of inputs for different

00:40:52,870 --> 00:40:56,800
different types sometimes you may want

00:40:54,640 --> 00:41:00,490
to input structured data sometimes you

00:40:56,800 --> 00:41:04,870
may be you maybe want strings sometimes

00:41:00,490 --> 00:41:06,790
it'll be numerical given given that

00:41:04,870 --> 00:41:09,190
we're allowing extensions we have these

00:41:06,790 --> 00:41:12,550
type classes that you can implement for

00:41:09,190 --> 00:41:16,480
extending this we still need to program

00:41:12,550 --> 00:41:18,460
our library to an API that we know we

00:41:16,480 --> 00:41:21,870
understand fully so we have to require

00:41:18,460 --> 00:41:26,320
that our input data are substitutions

00:41:21,870 --> 00:41:28,600
arrived to us as the library as library

00:41:26,320 --> 00:41:31,270
writers in a type that we can understand

00:41:28,600 --> 00:41:33,790
so maybe it's string maybe it's a more

00:41:31,270 --> 00:41:36,400
complicated type this is something that

00:41:33,790 --> 00:41:39,580
that would become apparent after you'd

00:41:36,400 --> 00:41:41,200
probably worked with worked with trying

00:41:39,580 --> 00:41:43,060
to implement a DSL for a little while I

00:41:41,200 --> 00:41:49,680
will not talk about it for much longer

00:41:43,060 --> 00:41:53,160
because it's I wasn't going to do this

00:41:49,680 --> 00:41:53,160
let's skip that

00:41:53,950 --> 00:42:00,010
yeah the truth is you can't handle the

00:41:57,790 --> 00:42:02,200
truth it's there is a horrible macro

00:42:00,010 --> 00:42:06,400
behind behind

00:42:02,200 --> 00:42:11,680
contextual which I am trying my best to

00:42:06,400 --> 00:42:16,210
shield you from the macro itself uses

00:42:11,680 --> 00:42:21,010
runtime reflection at compile time if

00:42:16,210 --> 00:42:22,480
you can imagine that so yeah I've got

00:42:21,010 --> 00:42:24,430
I've got some speakers notes here I'm

00:42:22,480 --> 00:42:28,839
just not going to it's not what I said

00:42:24,430 --> 00:42:31,020
so I'm getting I'm getting close to the

00:42:28,839 --> 00:42:34,559
end anyway so just - this is summarized

00:42:31,020 --> 00:42:37,599
with contextual is possible to define

00:42:34,559 --> 00:42:41,740
interpolators for your own custom types

00:42:37,599 --> 00:42:44,650
in Scala and it provides a key word

00:42:41,740 --> 00:42:47,770
extensible API for defining where when

00:42:44,650 --> 00:42:53,410
and how types can be substituted into

00:42:47,770 --> 00:42:55,119
them it's really worth saying that most

00:42:53,410 --> 00:42:56,859
of the complexity I mean if you if

00:42:55,119 --> 00:43:00,010
you've seen that the last few slides you

00:42:56,859 --> 00:43:01,869
thought this is really complicated many

00:43:00,010 --> 00:43:05,589
many uses don't require substitutions

00:43:01,869 --> 00:43:07,630
and if you can avoid if you can avoid

00:43:05,589 --> 00:43:09,640
substitutions in your particular DSL

00:43:07,630 --> 00:43:12,359
then life is a whole lot easier

00:43:09,640 --> 00:43:16,450
you only need to about three of those

00:43:12,359 --> 00:43:18,119
three of those seven steps but the

00:43:16,450 --> 00:43:21,819
contextual does does allow you these

00:43:18,119 --> 00:43:25,319
leave these more complex cases or we can

00:43:21,819 --> 00:43:27,579
phrase that maybe in in the converse a

00:43:25,319 --> 00:43:30,819
library built with contextual can make

00:43:27,579 --> 00:43:33,849
it impossible to write instances of some

00:43:30,819 --> 00:43:35,890
types which should simply not exist now

00:43:33,849 --> 00:43:41,530
this is something I fundamentally

00:43:35,890 --> 00:43:42,880
believe pipes should not have content or

00:43:41,530 --> 00:43:46,210
we should not we should not have code

00:43:42,880 --> 00:43:50,579
which tries to create types which are

00:43:46,210 --> 00:43:54,190
not represented or we shouldn't have

00:43:50,579 --> 00:43:57,880
code which which gets compiled it says

00:43:54,190 --> 00:44:00,670
URL dot pars X where X is a string it's

00:43:57,880 --> 00:44:02,500
not a valid URL the compiler has all the

00:44:00,670 --> 00:44:05,109
information it note it needs to know

00:44:02,500 --> 00:44:07,720
that that is not valid so I want to go

00:44:05,109 --> 00:44:12,670
as far as I can to stop that compiling

00:44:07,720 --> 00:44:19,410
and contextual is the means or one means

00:44:12,670 --> 00:44:21,450
of helping towards that goal so that is

00:44:19,410 --> 00:44:25,900
basically the end of the presentation

00:44:21,450 --> 00:44:29,410
the latest release is one zero one but I

00:44:25,900 --> 00:44:33,490
am working on a braking relief which is

00:44:29,410 --> 00:44:35,560
version version 2.0 it's version two not

00:44:33,490 --> 00:44:40,050
because it's significantly different

00:44:35,560 --> 00:44:43,030
it's two because it just has some some

00:44:40,050 --> 00:44:45,880
breakages in the API and I'm not I'm not

00:44:43,030 --> 00:44:47,470
Precious about my version numbers so by

00:44:45,880 --> 00:44:52,420
the india it might be four eight or

00:44:47,470 --> 00:44:55,599
something so that is available for every

00:44:52,420 --> 00:44:57,670
combination of scala to ten to eleven to

00:44:55,599 --> 00:45:00,070
twelve for those three platforms there

00:44:57,670 --> 00:45:03,520
that actually works I mean that actually

00:45:00,070 --> 00:45:07,599
dice exists it works on the Scala native

00:45:03,520 --> 00:45:09,400
to eleven and skull Jess 211 and 212 the

00:45:07,599 --> 00:45:11,920
website is hopefully easy to remember

00:45:09,400 --> 00:45:14,170
it's just contextual with a dot two

00:45:11,920 --> 00:45:17,830
characters in and two characters from

00:45:14,170 --> 00:45:22,210
the end because we have dot al domain

00:45:17,830 --> 00:45:26,140
names and there's get eternal I'm I'm in

00:45:22,210 --> 00:45:28,390
there most of the time if I'm not you

00:45:26,140 --> 00:45:30,910
can ping me on Twitter at the address at

00:45:28,390 --> 00:45:33,460
the bottom and you loop a source code

00:45:30,910 --> 00:45:36,160
it's also open source it's all I'm quite

00:45:33,460 --> 00:45:37,210
proud of it it's it's actually all the

00:45:36,160 --> 00:45:40,630
projects I've worked on this the first

00:45:37,210 --> 00:45:43,180
one that's well documented and I'm yeah

00:45:40,630 --> 00:45:45,300
it's taken me ten years to do actually

00:45:43,180 --> 00:45:48,550
writes and documented code and

00:45:45,300 --> 00:45:52,750
contextual is is does have full Scala

00:45:48,550 --> 00:45:55,540
Docs which are on the website so that is

00:45:52,750 --> 00:45:57,280
that is all I've got I don't if I have

00:45:55,540 --> 00:46:01,210
time for questions we've got the panel

00:45:57,280 --> 00:46:03,730
in here starting in about 15 minutes I

00:46:01,210 --> 00:46:07,770
think so maybe I can take questions

00:46:03,730 --> 00:46:11,560
until half past so three minutes oh yeah

00:46:07,770 --> 00:46:14,530
one of the one of the more kind of hard

00:46:11,560 --> 00:46:17,800
to work around issues with specifically

00:46:14,530 --> 00:46:19,359
the URI interpolation and rapture has to

00:46:17,800 --> 00:46:21,340
do with the fact that it uses a wide box

00:46:19,359 --> 00:46:24,880
macro to actually determine

00:46:21,340 --> 00:46:27,700
result-type of the interpellation corner

00:46:24,880 --> 00:46:30,910
if you manage to find some unfathomable

00:46:27,700 --> 00:46:33,220
way to work around that and right now

00:46:30,910 --> 00:46:33,760
okay I'm home yeah so this is a good

00:46:33,220 --> 00:46:36,040
question

00:46:33,760 --> 00:46:38,440
so Tony who's my previous library

00:46:36,040 --> 00:46:40,780
rapture which contains many different

00:46:38,440 --> 00:46:43,450
things one of which is a and servlet for

00:46:40,780 --> 00:46:46,900
your eyes which looks at the content of

00:46:43,450 --> 00:46:49,330
the the interpolated string and

00:46:46,900 --> 00:46:51,940
determines the return type on the basis

00:46:49,330 --> 00:46:53,560
of the content so everything I've

00:46:51,940 --> 00:46:56,140
described to the talk so far assumes

00:46:53,560 --> 00:46:57,640
there is a fixed return type contextual

00:46:56,140 --> 00:47:00,670
does give you some additional methods

00:46:57,640 --> 00:47:04,180
which you can override to change the

00:47:00,670 --> 00:47:07,210
return type or make the make the return

00:47:04,180 --> 00:47:11,050
type variable dependent on the content

00:47:07,210 --> 00:47:12,900
but it also has a type member an

00:47:11,050 --> 00:47:15,400
abstract type member which was added

00:47:12,900 --> 00:47:19,930
mainly not lots not for my benefit but

00:47:15,400 --> 00:47:21,640
for uses of I des who want a sensible

00:47:19,930 --> 00:47:24,280
returns out to be inferred from a white

00:47:21,640 --> 00:47:30,520
box macro so you can you can include an

00:47:24,280 --> 00:47:33,640
upper bound on the type and your IDE

00:47:30,520 --> 00:47:35,980
will be able to interpret that where you

00:47:33,640 --> 00:47:37,840
we use were you asking a question partly

00:47:35,980 --> 00:47:40,840
because you've used that with an IDE in

00:47:37,840 --> 00:47:42,910
the IDE gets confused well I used that

00:47:40,840 --> 00:47:45,880
as an example of ideas being confused

00:47:42,910 --> 00:47:47,830
about markers right only family but yes

00:47:45,880 --> 00:47:49,000
in principle I I didn't I didn't answer

00:47:47,830 --> 00:47:52,090
question before it is it is actually a

00:47:49,000 --> 00:47:54,610
white box macro but it shouldn't have

00:47:52,090 --> 00:47:56,730
the it shouldn't have the problem of IDs

00:47:54,610 --> 00:48:00,940
struggling to work out the return type

00:47:56,730 --> 00:48:04,080
provided you provided all your return

00:48:00,940 --> 00:48:06,400
types are subtypes of some common type

00:48:04,080 --> 00:48:09,160
if they are completely distinct types

00:48:06,400 --> 00:48:11,440
then you're out of luck but contextual

00:48:09,160 --> 00:48:15,940
does give you the option of doing that a

00:48:11,440 --> 00:48:18,400
sec can you contrast xylophone to the

00:48:15,940 --> 00:48:21,550
XML interpolator work happening at EPFL

00:48:18,400 --> 00:48:24,460
I don't I don't know the I don't know

00:48:21,550 --> 00:48:27,430
much about what happened with the the

00:48:24,460 --> 00:48:28,570
interpolation of XML as developed at EPF

00:48:27,430 --> 00:48:32,590
I think with the google Summer of Code

00:48:28,570 --> 00:48:35,530
project um what I do know is that as

00:48:32,590 --> 00:48:39,540
much as possible has gone to make the

00:48:35,530 --> 00:48:40,690
the EPFL version bug compatible with

00:48:39,540 --> 00:48:47,430
Scala

00:48:40,690 --> 00:48:50,920
XML as has existed since 2004 2003 so

00:48:47,430 --> 00:48:53,260
assume you consider that a non gone so I

00:48:50,920 --> 00:48:55,599
have introduced my own bugs in xylophone

00:48:53,260 --> 00:48:58,990
then you there they're different from

00:48:55,599 --> 00:49:02,020
the ones in there they're different from

00:48:58,990 --> 00:49:04,359
the ones in scalar XML but they they can

00:49:02,020 --> 00:49:06,580
be fixed and I am NOT Precious about

00:49:04,359 --> 00:49:08,040
keeping them in long term in fact I

00:49:06,580 --> 00:49:12,160
would love to have many of them removed

00:49:08,040 --> 00:49:14,560
it's I think the EPFL one is is more

00:49:12,160 --> 00:49:16,240
advanced in its sorry development is

00:49:14,560 --> 00:49:17,410
more advanced it's more complete

00:49:16,240 --> 00:49:21,880
xylophone

00:49:17,410 --> 00:49:23,800
I intend later to be a lot more like

00:49:21,880 --> 00:49:27,580
many of the Jason libraries for for

00:49:23,800 --> 00:49:31,030
Scala but for XML I did actually do an

00:49:27,580 --> 00:49:34,240
experiment with with rapture rapture has

00:49:31,030 --> 00:49:37,740
an XML sorry as a had a JSON module and

00:49:34,240 --> 00:49:42,160
I thought back then maybe I could try to

00:49:37,740 --> 00:49:44,680
try to shoehorn XML into working with

00:49:42,160 --> 00:49:47,550
the same mechanisms of rapture Jason

00:49:44,680 --> 00:49:51,790
used and it was kind of a failure with

00:49:47,550 --> 00:49:54,160
with rapture so I decided that I would

00:49:51,790 --> 00:49:56,140
just reimburse all of that so what I

00:49:54,160 --> 00:49:59,470
want to have is some generic derivation

00:49:56,140 --> 00:50:02,680
for xylophone serializing case classes

00:49:59,470 --> 00:50:04,510
to XML or all the sorts of things you

00:50:02,680 --> 00:50:07,300
would like to do with with Jason but but

00:50:04,510 --> 00:50:11,530
instead for XML that is more of a long

00:50:07,300 --> 00:50:13,390
term goal it depends on my my time for

00:50:11,530 --> 00:50:15,490
for completing it but there is a lot

00:50:13,390 --> 00:50:16,869
there's a lot done already it's just

00:50:15,490 --> 00:50:20,530
there's a long way to go and it's

00:50:16,869 --> 00:50:23,170
probably more ambitious I'm probably out

00:50:20,530 --> 00:50:24,580
of time over time so I'll say thanks

00:50:23,170 --> 00:50:28,210
thank you for coming thank you for

00:50:24,580 --> 00:50:30,520
listening and stay here for the panel

00:50:28,210 --> 00:50:34,450
which is starting in probably about 10

00:50:30,520 --> 00:50:35,770
minutes I will be around as much as I

00:50:34,450 --> 00:50:38,800
can for the remainder of the conference

00:50:35,770 --> 00:50:39,730
not much left but but do come and talk

00:50:38,800 --> 00:50:43,300
to me and ask me anything about

00:50:39,730 --> 00:50:46,020
contextual or check up on the Gator

00:50:43,300 --> 00:50:48,080
channel so thank you very much

00:50:46,020 --> 00:50:48,080

YouTube URL: https://www.youtube.com/watch?v=9qNJUD3nIIE


