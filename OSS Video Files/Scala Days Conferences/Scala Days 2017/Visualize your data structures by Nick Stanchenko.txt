Title: Visualize your data structures by Nick Stanchenko
Publication date: 2017-06-07
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
Reftree is a Scala library for producing pretty diagrams and animations of data structures (http://stanch.github.io/reftree/demo). It can be used for documentation, live coding or as an interactive tool for understanding how stuff works.

This talk showcases Reftree and explores how functional programming techniques such as lenses and zippers can be used to implement visualizations of themselves.
Captions: 
	00:00:00,439 --> 00:00:09,179
let's run SBT so two things first there

00:00:07,440 --> 00:00:11,490
is a transcript of this talk that is

00:00:09,179 --> 00:00:13,650
already available online so you can just

00:00:11,490 --> 00:00:16,580
go there and read everything in case you

00:00:13,650 --> 00:00:19,289
want to refresh it in your mind and

00:00:16,580 --> 00:00:22,140
second thing you can do as I did you can

00:00:19,289 --> 00:00:23,789
clone the rebel you can say SBT demo and

00:00:22,140 --> 00:00:28,650
you can run all the same comments

00:00:23,789 --> 00:00:31,949
hopefully with the same results so let

00:00:28,650 --> 00:00:33,870
me give you a elevator picture of rf3

00:00:31,949 --> 00:00:36,180
which is a library for visualizing data

00:00:33,870 --> 00:00:40,320
structures let's say you have something

00:00:36,180 --> 00:00:43,579
like a case class person with first name

00:00:40,320 --> 00:00:46,160
which is a string and H which is a

00:00:43,579 --> 00:00:49,739
Kinane

00:00:46,160 --> 00:00:57,989
and let's say you have a person called

00:00:49,739 --> 00:01:01,410
Bob 42 years old so this is the page ref

00:00:57,989 --> 00:01:08,100
3 is a library and it allows you to do

00:01:01,410 --> 00:01:10,350
this ok so very straightforward no

00:01:08,100 --> 00:01:12,360
boilerplate you just create some case

00:01:10,350 --> 00:01:14,640
classes or other data structures as well

00:01:12,360 --> 00:01:17,040
see and you get this pretty

00:01:14,640 --> 00:01:19,110
visualization and there are a few ways

00:01:17,040 --> 00:01:22,170
you can configure this so for example if

00:01:19,110 --> 00:01:25,729
you don't like this noisy string with

00:01:22,170 --> 00:01:29,490
all the cells you can just say import

00:01:25,729 --> 00:01:32,579
simple string and it'll just show like

00:01:29,490 --> 00:01:36,509
this you can also configure the field

00:01:32,579 --> 00:01:39,650
names or whatever actually so it's just

00:01:36,509 --> 00:01:42,840
a matter of important and implicit and

00:01:39,650 --> 00:01:45,570
now it's called name and not first-name

00:01:42,840 --> 00:01:47,340
so very straightforward everything

00:01:45,570 --> 00:01:50,729
generated automatically the field names

00:01:47,340 --> 00:01:52,770
the caption and it's ready for for you

00:01:50,729 --> 00:01:55,110
to insert it in your documentation or

00:01:52,770 --> 00:01:58,409
free to do live demos which is something

00:01:55,110 --> 00:02:00,600
I'm doing right now and I think you can

00:01:58,409 --> 00:02:02,310
use it to explore the data structures

00:02:00,600 --> 00:02:06,590
and to kind of understand how things

00:02:02,310 --> 00:02:06,590
work so let's say we have a list here

00:02:08,759 --> 00:02:16,600
and if you look at this list nothing

00:02:12,820 --> 00:02:18,880
unusual here so you have several selves

00:02:16,600 --> 00:02:20,770
so with a number one cell with a number

00:02:18,880 --> 00:02:23,140
two so with a number three and then up

00:02:20,770 --> 00:02:28,660
to east and let's let's say I have

00:02:23,140 --> 00:02:33,280
something like please - which is please

00:02:28,660 --> 00:02:35,140
drop one so we just remove the head of

00:02:33,280 --> 00:02:40,000
list and we added some other element

00:02:35,140 --> 00:02:43,090
there and if you visualize this you'll

00:02:40,000 --> 00:02:45,610
actually see that they're sharing the

00:02:43,090 --> 00:02:48,190
tail of the list so this is very cool

00:02:45,610 --> 00:02:52,150
for you to understand the persistent

00:02:48,190 --> 00:02:56,830
data structures actually contact if we

00:02:52,150 --> 00:03:01,510
used instead of drop and cons if we did

00:02:56,830 --> 00:03:03,070
something like this so we use the

00:03:01,510 --> 00:03:06,040
updated method from the standard

00:03:03,070 --> 00:03:08,530
collections the result is actually quite

00:03:06,040 --> 00:03:10,630
different it creates an entirely new

00:03:08,530 --> 00:03:14,950
list so it doesn't share part it's

00:03:10,630 --> 00:03:17,320
always like you think so as I said you

00:03:14,950 --> 00:03:19,800
can use this for different purposes for

00:03:17,320 --> 00:03:23,019
documentation like coding exploration

00:03:19,800 --> 00:03:27,790
one of the features that I really like

00:03:23,019 --> 00:03:30,010
is the ability to generate animations so

00:03:27,790 --> 00:03:33,280
here's an animation of a queue that I

00:03:30,010 --> 00:03:36,130
made and it's just the queue with

00:03:33,280 --> 00:03:39,300
elements being offended on one side and

00:03:36,130 --> 00:03:39,300
removed on another side

00:03:40,770 --> 00:03:47,190
yep so actually the animation is

00:03:45,360 --> 00:03:49,800
something that I would like to talk

00:03:47,190 --> 00:03:51,990
about today since it's my favorite

00:03:49,800 --> 00:03:54,630
feature and last year I've been giving a

00:03:51,990 --> 00:03:57,570
talk on data structures and some

00:03:54,630 --> 00:03:59,520
functional concepts and I realized that

00:03:57,570 --> 00:04:01,470
while visualizing those things I

00:03:59,520 --> 00:04:03,840
actually use the same concepts to build

00:04:01,470 --> 00:04:06,060
visualizations so I thought we would

00:04:03,840 --> 00:04:08,550
explore these principles and how you can

00:04:06,060 --> 00:04:11,970
build this sort of animation using

00:04:08,550 --> 00:04:14,640
functional programming techniques so

00:04:11,970 --> 00:04:18,780
another for us for us to do that

00:04:14,640 --> 00:04:21,660
we should really know how ref three

00:04:18,780 --> 00:04:27,270
actually works so remember we have this

00:04:21,660 --> 00:04:30,870
guy Bob here it's a person with a name

00:04:27,270 --> 00:04:33,540
and age and in order to visualize this

00:04:30,870 --> 00:04:35,100
thing Raftery creates an internal data

00:04:33,540 --> 00:04:37,650
structure which is called surprisingly

00:04:35,100 --> 00:04:39,450
ref three and I know it's a bad name but

00:04:37,650 --> 00:04:42,930
actually the priest name for the library

00:04:39,450 --> 00:04:46,080
was diapers as diagrams of persistent

00:04:42,930 --> 00:04:50,580
data structures so it could have been

00:04:46,080 --> 00:04:53,610
worse anyway so the ref tree looks a bit

00:04:50,580 --> 00:04:57,480
like this actually we can do even better

00:04:53,610 --> 00:04:59,520
we can get a ref tree of a ref tree to

00:04:57,480 --> 00:05:04,890
visualize the referee so if you say

00:04:59,520 --> 00:05:08,390
render Bob for F 3 and Bob oops I need

00:05:04,890 --> 00:05:08,390
to do something ports here

00:05:11,680 --> 00:05:18,680
so the rf3 looks a bit like this and it

00:05:15,770 --> 00:05:21,620
has two main types of nodes it has a ref

00:05:18,680 --> 00:05:23,810
which is a pointer to an object and it

00:05:21,620 --> 00:05:27,770
has the name person which is displayed

00:05:23,810 --> 00:05:31,969
here it also has the ID which is used to

00:05:27,770 --> 00:05:35,060
track the same instance of the same

00:05:31,969 --> 00:05:37,430
interest of the same object and it has

00:05:35,060 --> 00:05:40,069
children which are filled with names

00:05:37,430 --> 00:05:42,500
like here is a field name and here's the

00:05:40,069 --> 00:05:44,689
age and then they point to where the

00:05:42,500 --> 00:05:46,699
revs or valves which are values that

00:05:44,689 --> 00:05:50,449
don't point to anything so 42 in these

00:05:46,699 --> 00:05:52,939
cases at all so this is rate but how do

00:05:50,449 --> 00:05:56,120
we actually get from here to something

00:05:52,939 --> 00:05:58,400
that we can draw like to a picture but

00:05:56,120 --> 00:06:01,310
what trap tree does it actually produce

00:05:58,400 --> 00:06:03,289
a definition of a graph in a dot

00:06:01,310 --> 00:06:10,479
language that can be used by two local

00:06:03,289 --> 00:06:14,690
grass feeds to display a graph so you

00:06:10,479 --> 00:06:17,150
can look at a graph of Bob it will be

00:06:14,690 --> 00:06:19,490
something like this so it says some

00:06:17,150 --> 00:06:22,539
properties and some nodes

00:06:19,490 --> 00:06:24,740
it's not really interesting to read it

00:06:22,539 --> 00:06:26,960
but just for you to have an idea and

00:06:24,740 --> 00:06:29,300
finally we can ask graph is to produce

00:06:26,960 --> 00:06:32,240
some sort of image from this like a PNG

00:06:29,300 --> 00:06:36,289
or even there we can create the vector

00:06:32,240 --> 00:06:37,240
image like SVG and it's just a bunch of

00:06:36,289 --> 00:06:41,120
Xcode

00:06:37,240 --> 00:06:45,080
so let's think again about our animation

00:06:41,120 --> 00:06:47,870
use case so imagine we have this queue

00:06:45,080 --> 00:06:49,939
with the number 1 and we want to

00:06:47,870 --> 00:06:56,900
animated transition to a queue with the

00:06:49,939 --> 00:06:58,280
numbers 1 & 2 sorry so this would look

00:06:56,900 --> 00:07:00,750
like this

00:06:58,280 --> 00:07:03,300
now what we could do is we could just

00:07:00,750 --> 00:07:05,790
take these separate images put them into

00:07:03,300 --> 00:07:07,530
an animated gif and it would be an

00:07:05,790 --> 00:07:11,610
animation but it'd be really crappy

00:07:07,530 --> 00:07:15,479
right because it just jumps if we go

00:07:11,610 --> 00:07:17,820
back to cue the number one I mean it's

00:07:15,479 --> 00:07:20,220
not really good enough so what we really

00:07:17,820 --> 00:07:22,229
want is we want to insert a lot of

00:07:20,220 --> 00:07:24,090
intermediate frames between these two

00:07:22,229 --> 00:07:26,160
frames that would kind of smoothing out

00:07:24,090 --> 00:07:28,650
the transition and it's really great

00:07:26,160 --> 00:07:30,690
that we have SVG because it's a vector

00:07:28,650 --> 00:07:32,910
format so we can just move things there

00:07:30,690 --> 00:07:35,400
by changing the numbers and changing

00:07:32,910 --> 00:07:37,760
other things and we basically just need

00:07:35,400 --> 00:07:40,260
to move all the nodes move all the edges

00:07:37,760 --> 00:07:42,720
change all the shapes of all the edges

00:07:40,260 --> 00:07:44,580
if they change shape we need to

00:07:42,720 --> 00:07:47,130
interpolate the colors the line

00:07:44,580 --> 00:07:49,250
thickness I think at this point you get

00:07:47,130 --> 00:07:51,840
that it's not really that simple and

00:07:49,250 --> 00:07:54,270
what you really need for this is some

00:07:51,840 --> 00:07:57,000
sort of principled approach that would

00:07:54,270 --> 00:07:59,669
be very clear for us to to build up this

00:07:57,000 --> 00:08:02,610
sort of interpolation and to understand

00:07:59,669 --> 00:08:04,289
how it works and so in the great

00:08:02,610 --> 00:08:09,210
tradition of functional programming

00:08:04,289 --> 00:08:10,680
let's start with a simple extraction so

00:08:09,210 --> 00:08:13,830
this is an abstraction that I called

00:08:10,680 --> 00:08:15,510
interpolation so interpolation of a is

00:08:13,830 --> 00:08:18,360
basically something that you can give

00:08:15,510 --> 00:08:20,430
left and the right values of type a and

00:08:18,360 --> 00:08:22,880
then you say I want this point between

00:08:20,430 --> 00:08:26,190
them and it just interpolates and

00:08:22,880 --> 00:08:28,409
obviously you can use the same thing to

00:08:26,190 --> 00:08:30,840
sample the interval between left and

00:08:28,409 --> 00:08:32,640
right so you can say I want five samples

00:08:30,840 --> 00:08:36,719
between these two values and it just

00:08:32,640 --> 00:08:39,599
produces you five samples but the most

00:08:36,719 --> 00:08:41,520
obvious thing to interpolate is a single

00:08:39,599 --> 00:08:46,580
number and I think we should start with

00:08:41,520 --> 00:08:46,580
that so let's say we render

00:08:46,790 --> 00:08:54,959
interpolation double sample from zero to

00:08:51,209 --> 00:08:57,240
ten and we want five samples so this

00:08:54,959 --> 00:09:00,750
basically gives you a sack with five

00:08:57,240 --> 00:09:02,670
numbers what we would expect with zero

00:09:00,750 --> 00:09:07,620
two point five five seven point five and

00:09:02,670 --> 00:09:09,570
ten now let's step it up so imagine we

00:09:07,620 --> 00:09:10,310
have another single number but at point

00:09:09,570 --> 00:09:12,260
in

00:09:10,310 --> 00:09:20,930
to displace so a point would be

00:09:12,260 --> 00:09:23,420
something like point of 10 and 20 all

00:09:20,930 --> 00:09:26,210
point is basically just two numbers

00:09:23,420 --> 00:09:28,520
right so if we could just get in there

00:09:26,210 --> 00:09:30,680
and interpolate the x-coordinate and

00:09:28,520 --> 00:09:32,270
getting their interpolated y-coordinate

00:09:30,680 --> 00:09:35,870
basically would have a way to

00:09:32,270 --> 00:09:37,490
interpolate the point and to do this

00:09:35,870 --> 00:09:39,830
again we are going to introduce even

00:09:37,490 --> 00:09:43,430
more extraction but it will pay off at

00:09:39,830 --> 00:09:45,470
the end so this there is this very cool

00:09:43,430 --> 00:09:47,720
thing that is called lense which is a

00:09:45,470 --> 00:09:50,450
particular case of optics and the lens

00:09:47,720 --> 00:09:53,510
from type A to type B is something that

00:09:50,450 --> 00:09:55,580
focuses on a part of a data structure of

00:09:53,510 --> 00:09:58,700
type a and it gives you a read/write

00:09:55,580 --> 00:10:01,130
access to that part so let's create some

00:09:58,700 --> 00:10:04,670
lattice and see how they work let's say

00:10:01,130 --> 00:10:07,190
for example X will be again plants and

00:10:04,670 --> 00:10:09,410
I'm here I'm using the monocle library

00:10:07,190 --> 00:10:11,390
which is very cool it has glasses and

00:10:09,410 --> 00:10:15,110
some other types of optics that we'll

00:10:11,390 --> 00:10:17,350
see later and the same for the y

00:10:15,110 --> 00:10:17,350
coordinate

00:10:19,839 --> 00:10:23,770
so we can render this

00:10:26,150 --> 00:10:31,410
so as you can see X focuses on the first

00:10:29,520 --> 00:10:37,940
coordinate of the point as we would

00:10:31,410 --> 00:10:41,130
expect and why focus on the second part

00:10:37,940 --> 00:10:43,680
so now we have written rights access to

00:10:41,130 --> 00:10:45,450
parts of the point which basically means

00:10:43,680 --> 00:10:47,730
that we can create a point interpolator

00:10:45,450 --> 00:10:51,290
by interpolating those parts in separate

00:10:47,730 --> 00:10:55,470
so what we can do is point interpolate

00:10:51,290 --> 00:11:04,010
these will interpolate X with our double

00:10:55,470 --> 00:11:12,510
interpolation and will interpolate Y

00:11:04,010 --> 00:11:19,170
with the same thing so now we can sample

00:11:12,510 --> 00:11:22,470
points so we can say point I sample from

00:11:19,170 --> 00:11:25,980
point plus a twenty ten and twenty two

00:11:22,470 --> 00:11:32,100
point twenty or thirty and we own five

00:11:25,980 --> 00:11:35,130
points I think I'm missing their

00:11:32,100 --> 00:11:38,339
appearances right so we had our initial

00:11:35,130 --> 00:11:43,440
point here we had our destination point

00:11:38,339 --> 00:11:46,140
here and we have five samples great well

00:11:43,440 --> 00:11:48,029
next step is a polyline polyline is

00:11:46,140 --> 00:11:51,589
basically a sequence of points and I

00:11:48,029 --> 00:11:51,589
have a couple of polar lines here

00:11:55,439 --> 00:12:01,449
so each of them have two points the

00:11:59,350 --> 00:12:02,949
intuition here is that if you have to

00:12:01,449 --> 00:12:05,170
poll alliance with the same number of

00:12:02,949 --> 00:12:08,439
points you can just interpolate them

00:12:05,170 --> 00:12:10,870
point by point and we can basically use

00:12:08,439 --> 00:12:19,930
the same approach so just say polyline

00:12:10,870 --> 00:12:22,420
interpolation is so we get access to the

00:12:19,930 --> 00:12:27,689
points filled with length and then we

00:12:22,420 --> 00:12:27,689
just say interpolate each of them with

00:12:28,800 --> 00:12:34,180
and then we already define point type

00:12:32,079 --> 00:12:37,449
but actually referee already provides it

00:12:34,180 --> 00:12:40,540
out the box so I'll just use that so in

00:12:37,449 --> 00:12:44,439
the same way we can just render those

00:12:40,540 --> 00:12:50,699
polylines so if we sample from polyline

00:12:44,439 --> 00:12:53,500
one to follow line two with two of them

00:12:50,699 --> 00:12:58,240
well actually two is boring it's just

00:12:53,500 --> 00:13:00,699
the same today so we started with two

00:12:58,240 --> 00:13:05,139
polylines and now we can interpolate and

00:13:00,699 --> 00:13:07,870
insert two pole lines in between so this

00:13:05,139 --> 00:13:09,730
is great but I think it's time for us to

00:13:07,870 --> 00:13:12,399
do actually some serious interpolator

00:13:09,730 --> 00:13:14,759
and what we are going to do is to

00:13:12,399 --> 00:13:18,899
interpolate a single edge in the graph

00:13:14,759 --> 00:13:22,240
so it should be something like this and

00:13:18,899 --> 00:13:24,339
the expected result is this so if we

00:13:22,240 --> 00:13:26,170
have an edge that moves from the left to

00:13:24,339 --> 00:13:30,339
right we want to smoothly interpolate

00:13:26,170 --> 00:13:32,589
that edge Oh for that actually we need

00:13:30,339 --> 00:13:33,970
to understand how those edges are

00:13:32,589 --> 00:13:38,290
actually represented right

00:13:33,970 --> 00:13:41,350
so I have an edge here which I took from

00:13:38,290 --> 00:13:48,100
a real graph and it's just a bunch of

00:13:41,350 --> 00:13:51,189
XML which we can render here so it's

00:13:48,100 --> 00:13:54,339
Matthew G element that has a path

00:13:51,189 --> 00:13:57,009
element here and the path element has it

00:13:54,339 --> 00:13:59,709
has a D attribute which is actually an

00:13:57,009 --> 00:14:02,769
SVG path description which is super

00:13:59,709 --> 00:14:05,140
obscure but it just has commands like

00:14:02,769 --> 00:14:09,579
move to or line two or

00:14:05,140 --> 00:14:12,519
curve two and with this it defines the

00:14:09,579 --> 00:14:16,440
path and if we want to animate this

00:14:12,519 --> 00:14:19,470
thing we want to animate this particular

00:14:16,440 --> 00:14:22,000
thing with the path specification right

00:14:19,470 --> 00:14:24,370
so the first step for us to get there

00:14:22,000 --> 00:14:27,279
would be to get to the path element and

00:14:24,370 --> 00:14:29,680
this is again one time we're optics

00:14:27,279 --> 00:14:33,010
really help us so I already have some

00:14:29,680 --> 00:14:36,940
objects defined for going inside XML and

00:14:33,010 --> 00:14:41,279
getting arbitrary notes there so let's

00:14:36,940 --> 00:14:45,390
start with the path which is an optics

00:14:41,279 --> 00:14:49,720
collect first and here I have this small

00:14:45,390 --> 00:14:52,360
CSS like selector syntax so we are just

00:14:49,720 --> 00:14:59,640
going to collect the first element of

00:14:52,360 --> 00:15:05,350
type path right so if we render this guy

00:14:59,640 --> 00:15:08,620
and point it to the edge it will focus

00:15:05,350 --> 00:15:11,430
on this path right so now we want to get

00:15:08,620 --> 00:15:14,620
from the path to this D attribute and

00:15:11,430 --> 00:15:16,570
one of the nice things about lenses or

00:15:14,620 --> 00:15:18,640
other types of optics is that they

00:15:16,570 --> 00:15:20,860
compose so if you have an object from A

00:15:18,640 --> 00:15:24,010
to B and an object from B to C you can

00:15:20,860 --> 00:15:26,019
actually get an object from A to C so if

00:15:24,010 --> 00:15:28,589
we had an object of girls from an

00:15:26,019 --> 00:15:28,589
excellent yeah

00:15:34,020 --> 00:15:41,140
and so optical optical at first is from

00:15:38,890 --> 00:15:43,630
rf3 actually everything here is from

00:15:41,140 --> 00:15:47,320
Raftery but that's a great question

00:15:43,630 --> 00:15:49,420
because it's not very clear how to write

00:15:47,320 --> 00:15:51,640
such an object that goes into XML and

00:15:49,420 --> 00:15:53,620
provides a read/write access to a part

00:15:51,640 --> 00:15:59,380
inside it right and we'll get back to it

00:15:53,620 --> 00:16:14,290
in the last part of the talk still other

00:15:59,380 --> 00:16:17,530
questions yeah yeah as much as I would

00:16:14,290 --> 00:16:19,500
like this to feel like magic to you I'm

00:16:17,530 --> 00:16:21,700
here to I'm going to explain so

00:16:19,500 --> 00:16:24,850
basically it translates to a file called

00:16:21,700 --> 00:16:26,350
diagram dot PNG and this is a simple

00:16:24,850 --> 00:16:27,820
image viewer that just points to that

00:16:26,350 --> 00:16:32,200
file so every time you override it

00:16:27,820 --> 00:16:34,330
displays anyone maybe for for the next

00:16:32,200 --> 00:16:36,640
version I would like to explore pouring

00:16:34,330 --> 00:16:38,170
this disk all GS so that you could just

00:16:36,640 --> 00:16:41,830
do everything in the browser and then

00:16:38,170 --> 00:16:47,260
you can even animate things but for now

00:16:41,830 --> 00:16:49,870
I'm just keeping it simple right so as I

00:16:47,260 --> 00:16:52,480
was saying if we had an optic that gold

00:16:49,870 --> 00:16:54,910
that month from an element to an

00:16:52,480 --> 00:16:57,520
attribute we could just use that and

00:16:54,910 --> 00:17:01,750
luckily that exists so we can just

00:16:57,520 --> 00:17:05,490
redefine our path as what it was and

00:17:01,750 --> 00:17:10,079
then we compose another optic which is

00:17:05,490 --> 00:17:10,079
XML utter of D

00:17:11,310 --> 00:17:18,240
so great now wait Fox is here but is

00:17:14,700 --> 00:17:20,100
still a string so we can't really do

00:17:18,240 --> 00:17:22,170
anything useful with it right and what

00:17:20,100 --> 00:17:24,930
we would really like to do is to parse

00:17:22,170 --> 00:17:28,080
it in some sort of case class which

00:17:24,930 --> 00:17:32,100
actually gives us access to the semantic

00:17:28,080 --> 00:17:35,730
meaning of this string and that also

00:17:32,100 --> 00:17:38,520
exists so we can compose it with yet

00:17:35,730 --> 00:17:41,760
another optic in these cases and

00:17:38,520 --> 00:17:43,740
isomorphism so it maps from strings to a

00:17:41,760 --> 00:17:47,940
case class that I defined that is called

00:17:43,740 --> 00:17:52,460
path which is just an ASP of this path

00:17:47,940 --> 00:18:01,070
so it's called path path string I assume

00:17:52,460 --> 00:18:04,680
and then if we render that option of h1

00:18:01,070 --> 00:18:06,270
we can actually see this case class so

00:18:04,680 --> 00:18:09,270
this is much easier to follow then a

00:18:06,270 --> 00:18:13,080
string it has this segments which is a

00:18:09,270 --> 00:18:16,560
sequence of segments of a path and the

00:18:13,080 --> 00:18:19,170
first segment is a move operation the

00:18:16,560 --> 00:18:21,470
second segment is a Bezier curve with

00:18:19,170 --> 00:18:24,840
two control points and you can see that

00:18:21,470 --> 00:18:28,290
the from element of the Bezier starts

00:18:24,840 --> 00:18:31,370
where we left off in the move too so

00:18:28,290 --> 00:18:35,970
that's how the SVG paths will work and

00:18:31,370 --> 00:18:38,580
the final piece of this if we have this

00:18:35,970 --> 00:18:40,170
path which is just a bunch of curves we

00:18:38,580 --> 00:18:42,630
can actually approximate it with a

00:18:40,170 --> 00:18:46,350
polyline right if we sample it with a

00:18:42,630 --> 00:18:49,010
huge number of points it'll will get a

00:18:46,350 --> 00:18:52,140
power line that 3d looks like that curve

00:18:49,010 --> 00:18:54,120
and I'm going to call it an isomorphism

00:18:52,140 --> 00:18:55,980
I know it's not an isomorphism in a

00:18:54,120 --> 00:18:58,950
strict sense because it's kind of a

00:18:55,980 --> 00:19:03,300
lossy conversion but if you put enough

00:18:58,950 --> 00:19:05,840
samples there it's it's almost there so

00:19:03,300 --> 00:19:12,720
we are going to call this polyline and

00:19:05,840 --> 00:19:16,320
Satchel a def and we are going to leave

00:19:12,720 --> 00:19:20,500
it configurable and it'll be fast

00:19:16,320 --> 00:19:26,799
compose I so that

00:19:20,500 --> 00:19:30,549
while the lion Tyson of points great so

00:19:26,799 --> 00:19:34,960
now we can use this to produce polylines

00:19:30,549 --> 00:19:39,900
from that SVG XML thing that we had so

00:19:34,960 --> 00:19:45,760
for example if we say render polyline of

00:19:39,900 --> 00:19:46,990
let's start with two of them actually I

00:19:45,760 --> 00:19:50,799
lied first we need to create an

00:19:46,990 --> 00:19:53,049
interpolation so interpolation is very

00:19:50,799 --> 00:19:55,690
simple we already have a length or some

00:19:53,049 --> 00:19:57,730
sort of optic that goes from XML to a

00:19:55,690 --> 00:20:01,030
polyline so now we just need to say

00:19:57,730 --> 00:20:04,320
interpolate with and put our polyline

00:20:01,030 --> 00:20:10,770
interpolation there so we just say that

00:20:04,320 --> 00:20:13,330
edge interpolation with a configurable

00:20:10,770 --> 00:20:16,090
configurable number of points and this

00:20:13,330 --> 00:20:24,900
will be polyline of that number of

00:20:16,090 --> 00:20:27,900
points interpolate with collie line

00:20:24,900 --> 00:20:27,900
interpolation

00:20:30,900 --> 00:20:36,760
points right

00:20:33,960 --> 00:20:38,920
so just to recap we went from

00:20:36,760 --> 00:20:40,870
interpolate in a single number to

00:20:38,920 --> 00:20:42,640
interpolate in a point that has two

00:20:40,870 --> 00:20:44,440
numbers inside to interpolate in a

00:20:42,640 --> 00:20:47,830
polyline that has a sequence of points

00:20:44,440 --> 00:20:51,430
inside and then we went from top to

00:20:47,830 --> 00:20:55,360
bottom so we run from XML to an element

00:20:51,430 --> 00:20:57,520
inside XML and then an attribute of that

00:20:55,360 --> 00:21:00,310
element inside XML and then to a case

00:20:57,520 --> 00:21:02,200
class and then to the polyline so now we

00:21:00,310 --> 00:21:05,230
finally can put all these pieces

00:21:02,200 --> 00:21:07,570
together and we are going to take this

00:21:05,230 --> 00:21:13,800
interpolation for a ride so you can say

00:21:07,570 --> 00:21:18,610
render frames from edge 1 to edge 2 and

00:21:13,800 --> 00:21:21,420
here we say edge interpolation let's

00:21:18,610 --> 00:21:29,110
start with four points and four frames

00:21:21,420 --> 00:21:31,800
oops that's a bit too many interpolation

00:21:29,110 --> 00:21:36,460
what do they call it thing its

00:21:31,800 --> 00:21:40,240
interpolation yeah that's not the

00:21:36,460 --> 00:21:44,560
easiest word to spell right so we get

00:21:40,240 --> 00:21:50,080
something like this and it's actually

00:21:44,560 --> 00:21:52,210
very crappy as you would expect so it

00:21:50,080 --> 00:21:56,200
just has four points and it just has

00:21:52,210 --> 00:22:00,460
four frames so we can improve that a bit

00:21:56,200 --> 00:22:04,650
we can start with ten points and ten

00:22:00,460 --> 00:22:13,060
frames and this is already something

00:22:04,650 --> 00:22:17,380
right it's not bad if we picked 100

00:22:13,060 --> 00:22:19,720
points and 100 frames it takes a bit of

00:22:17,380 --> 00:22:24,400
time to render and I think this is the

00:22:19,720 --> 00:22:27,490
sort of thing that we're looking for so

00:22:24,400 --> 00:22:31,000
an interested reader can extend this to

00:22:27,490 --> 00:22:32,830
support other aspects of the SVG so we

00:22:31,000 --> 00:22:35,440
need to do this for all the nodes to

00:22:32,830 --> 00:22:36,910
move them around we need to do this for

00:22:35,440 --> 00:22:39,400
the colors of the nodes for line

00:22:36,910 --> 00:22:41,470
thickness transparency and there's quite

00:22:39,400 --> 00:22:42,900
a bit of other things that need to be

00:22:41,470 --> 00:22:44,460
animated

00:22:42,900 --> 00:22:46,260
and riff tree already defines all of

00:22:44,460 --> 00:22:49,980
that so you can just go and look at the

00:22:46,260 --> 00:22:53,220
source code it's actually pretty

00:22:49,980 --> 00:22:58,440
readable so you can go there SVG graph

00:22:53,220 --> 00:23:00,990
animation so it just defines a bunch of

00:22:58,440 --> 00:23:04,050
interpolations like fade out and fade in

00:23:00,990 --> 00:23:06,090
and interpolation of color interpolation

00:23:04,050 --> 00:23:10,050
of thickness interpolation of note

00:23:06,090 --> 00:23:13,670
position edge position interpolation of

00:23:10,050 --> 00:23:17,970
sets of nodes and sets of edges and

00:23:13,670 --> 00:23:23,190
finally an interpolation of SVG which

00:23:17,970 --> 00:23:27,240
interpolates everything to think so one

00:23:23,190 --> 00:23:29,190
thing it's pretty generic it's somewhat

00:23:27,240 --> 00:23:32,670
tied to grass but it's very easy to

00:23:29,190 --> 00:23:35,220
redefine to just generally interpolate

00:23:32,670 --> 00:23:38,040
SVG's so by using a lot of abstraction

00:23:35,220 --> 00:23:40,760
we have something that we can use for

00:23:38,040 --> 00:23:44,040
other use cases or in other contexts and

00:23:40,760 --> 00:23:46,860
another thing is that we never actually

00:23:44,040 --> 00:23:50,280
touched XML directly which I'm sure for

00:23:46,860 --> 00:23:52,230
many people is a good thing in fact if

00:23:50,280 --> 00:23:54,030
we have the same set of lenses for some

00:23:52,230 --> 00:23:56,640
completely different format we would

00:23:54,030 --> 00:24:00,450
just be able to use that so again that

00:23:56,640 --> 00:24:02,730
the benefit of abstraction now to the

00:24:00,450 --> 00:24:05,970
question of how do you actually write

00:24:02,730 --> 00:24:09,390
lines that go inside XML and modify

00:24:05,970 --> 00:24:12,390
things there because the only way I know

00:24:09,390 --> 00:24:16,860
from this cost standard library to to

00:24:12,390 --> 00:24:18,930
modify XML XML is to use this XML

00:24:16,860 --> 00:24:26,790
transformer how many people have used

00:24:18,930 --> 00:24:28,350
those did you like it right so there is

00:24:26,790 --> 00:24:30,930
this data structure which is

00:24:28,350 --> 00:24:33,480
specifically made for modifying

00:24:30,930 --> 00:24:36,420
recursive data structures like XML or

00:24:33,480 --> 00:24:38,790
other types of trees and it was

00:24:36,420 --> 00:24:40,890
introduced in the paper in 97 and it's

00:24:38,790 --> 00:24:46,530
called zipper has anyone heard about

00:24:40,890 --> 00:24:50,030
zippers some people nice well I have to

00:24:46,530 --> 00:24:50,030
here's some simple XML

00:24:51,220 --> 00:24:56,799
which looks a bit like this so it's just

00:24:53,860 --> 00:24:58,299
a tree which starts with a value 1 and

00:24:56,799 --> 00:25:05,710
then it has some children that have

00:24:58,299 --> 00:25:07,870
values 2 3 4 5 6 and 7 I'm going to

00:25:05,710 --> 00:25:10,049
write some more Eakin tations question

00:25:07,870 --> 00:25:10,049
yes

00:25:20,110 --> 00:25:24,740
well it's it's kind of to make it more

00:25:22,820 --> 00:25:27,890
consistent with the with the other

00:25:24,740 --> 00:25:30,080
fields here which are also dots so in

00:25:27,890 --> 00:25:32,419
rapture you can define fields which have

00:25:30,080 --> 00:25:34,490
names or labels like this one and you

00:25:32,419 --> 00:25:36,559
can define fields without labels and

00:25:34,490 --> 00:25:40,039
they use kind of the similar print the

00:25:36,559 --> 00:25:41,840
same approach with this dot thing in the

00:25:40,039 --> 00:25:45,400
first version I didn't even have the

00:25:41,840 --> 00:25:48,559
captions it's actually a recent feature

00:25:45,400 --> 00:25:52,970
so I didn't think much about it but I

00:25:48,559 --> 00:25:55,820
think the uniformity makes sense and as

00:25:52,970 --> 00:25:57,740
I said you can configure for your case

00:25:55,820 --> 00:26:02,510
class if you want to display field names

00:25:57,740 --> 00:26:05,480
and if so which ones right so back to

00:26:02,510 --> 00:26:07,460
zippers zipper is something that

00:26:05,480 --> 00:26:09,770
provides you an access to a recursive

00:26:07,460 --> 00:26:11,630
data structure and it focuses on a

00:26:09,770 --> 00:26:13,400
certain part of the data structure and

00:26:11,630 --> 00:26:17,840
you can move the focus around so you can

00:26:13,400 --> 00:26:19,669
go left right or up or down and when

00:26:17,840 --> 00:26:22,429
you're focused on a certain part you can

00:26:19,669 --> 00:26:24,530
actually modify it or you can insert

00:26:22,429 --> 00:26:30,490
things on the left or insert things on

00:26:24,530 --> 00:26:30,490
the right so let's create the zipper

00:26:36,500 --> 00:26:42,660
so these deeper points to the top of our

00:26:39,780 --> 00:26:45,360
XML for now it's nothing special it's

00:26:42,660 --> 00:26:50,190
just created this object that has empty

00:26:45,360 --> 00:26:52,080
it has four fields so it's the focus the

00:26:50,190 --> 00:26:53,670
left siblings are the focus which is

00:26:52,080 --> 00:26:56,730
currently empty because it's the root of

00:26:53,670 --> 00:26:58,890
the tree it has the right siblings of

00:26:56,730 --> 00:27:00,840
the focus which is also empty and it has

00:26:58,890 --> 00:27:02,730
top which points to the parent sleeper

00:27:00,840 --> 00:27:05,700
which there is none because again we are

00:27:02,730 --> 00:27:08,850
at the root of the tree so now let's see

00:27:05,700 --> 00:27:14,309
it let's see what happens when we move

00:27:08,850 --> 00:27:17,700
down the zipper and it will be a fair

00:27:14,309 --> 00:27:21,720
bit of noise but bear with me so we have

00:27:17,700 --> 00:27:24,020
our first zipper which is in blue and it

00:27:21,720 --> 00:27:27,059
still points to the root of the tree and

00:27:24,020 --> 00:27:29,850
now we have our green zipper which is

00:27:27,059 --> 00:27:32,580
zippered that we move down left so it

00:27:29,850 --> 00:27:34,830
points to this element which has has

00:27:32,580 --> 00:27:37,440
number two so it's down left from the

00:27:34,830 --> 00:27:41,250
root of the tree and it points to the

00:27:37,440 --> 00:27:43,050
parent zipper I'm going to remove vapor

00:27:41,250 --> 00:27:46,670
because it just introduces a lot of

00:27:43,050 --> 00:27:49,670
noise so this should be a bit simpler

00:27:46,670 --> 00:27:49,670
yeah

00:27:56,390 --> 00:28:00,890
you can call render with several things

00:27:58,580 --> 00:28:02,300
and it will show all of them and each of

00:28:00,890 --> 00:28:05,660
the things will be in its own color

00:28:02,300 --> 00:28:08,000
which is also configurable and since rf3

00:28:05,660 --> 00:28:10,400
actually tracks the IDS of the objects

00:28:08,000 --> 00:28:12,380
it can identify which things point to

00:28:10,400 --> 00:28:22,630
the same instance so it can show which

00:28:12,380 --> 00:28:27,680
things are shirt so remember that

00:28:22,630 --> 00:28:30,110
referee uses this ref tree structure to

00:28:27,680 --> 00:28:32,360
visualize something and there is a type

00:28:30,110 --> 00:28:35,000
class that is called to ref tree which

00:28:32,360 --> 00:28:37,730
defines how to convert your structure to

00:28:35,000 --> 00:28:39,980
that referee structure and you can

00:28:37,730 --> 00:28:42,710
configure the instance of that Thai

00:28:39,980 --> 00:28:44,180
place and for zipper that instance says

00:28:42,710 --> 00:28:47,150
that you should highlight what the

00:28:44,180 --> 00:28:49,130
zipper focuses on so highlight is one of

00:28:47,150 --> 00:28:57,560
the fields of ref tree you can highlight

00:28:49,130 --> 00:29:00,260
any node of directory right so as I said

00:28:57,560 --> 00:29:02,990
you can use this to move around the XML

00:29:00,260 --> 00:29:11,810
I have here something that is called

00:29:02,990 --> 00:29:15,860
super control yeah so it just binds just

00:29:11,810 --> 00:29:19,100
binds keys WASD on movements on the

00:29:15,860 --> 00:29:21,860
paper so we can say move down and it

00:29:19,100 --> 00:29:25,670
moves down then if you move to the right

00:29:21,860 --> 00:29:30,890
the previous focus jumps to the left a

00:29:25,670 --> 00:29:32,180
blinks if you move right again again the

00:29:30,890 --> 00:29:33,950
previous focus jumps to the live

00:29:32,180 --> 00:29:36,590
siblings and it takes the next right

00:29:33,950 --> 00:29:42,230
sibling puts it at the focus so you can

00:29:36,590 --> 00:29:44,870
just go left right on this thing if you

00:29:42,230 --> 00:29:47,930
go to this last element which also has

00:29:44,870 --> 00:29:50,150
some children you can go down again

00:29:47,930 --> 00:29:55,370
and now we just focus on this number six

00:29:50,150 --> 00:29:56,540
and we have number seven on right so you

00:29:55,370 --> 00:29:59,390
can just go between them

00:29:56,540 --> 00:30:01,100
and as you remember top points to the

00:29:59,390 --> 00:30:03,560
parent zippers so that we can go back

00:30:01,100 --> 00:30:04,910
and now he's actually the crucial point

00:30:03,560 --> 00:30:07,580
because

00:30:04,910 --> 00:30:09,920
when we go up what is going to do is it

00:30:07,580 --> 00:30:12,500
going to save the current children on

00:30:09,920 --> 00:30:14,630
the current level that's why it's called

00:30:12,500 --> 00:30:16,040
the taper and it's going to return to

00:30:14,630 --> 00:30:20,690
the parent sleeper with the updated

00:30:16,040 --> 00:30:22,460
elements so when we go up but we didn't

00:30:20,690 --> 00:30:27,530
modify anything but I can show that as

00:30:22,460 --> 00:30:30,130
well so let's say is if we remove down

00:30:27,530 --> 00:30:30,130
left

00:30:36,810 --> 00:30:44,940
so as I said we can ensure things and we

00:30:39,990 --> 00:30:50,730
can say for example insert left some

00:30:44,940 --> 00:30:52,560
fruit and magically this rule appears on

00:30:50,730 --> 00:30:53,880
the left side links so it's a very

00:30:52,560 --> 00:30:56,190
straightforward data structure that

00:30:53,880 --> 00:30:58,800
allows you to go around and modify

00:30:56,190 --> 00:31:01,260
things and again an interested reader

00:30:58,800 --> 00:31:03,690
could implement all those at Optics

00:31:01,260 --> 00:31:06,180
using this so if you want to find an

00:31:03,690 --> 00:31:08,430
element inside XML and update it you

00:31:06,180 --> 00:31:10,950
just have to create a zipper go in some

00:31:08,430 --> 00:31:12,810
order when you see the element you get

00:31:10,950 --> 00:31:14,280
it or if you want to update when you see

00:31:12,810 --> 00:31:19,770
the element you put a new value there

00:31:14,280 --> 00:31:22,830
and once you are done with once you are

00:31:19,770 --> 00:31:26,010
done with updating the zipper you can

00:31:22,830 --> 00:31:31,160
just say commit and it goes all the way

00:31:26,010 --> 00:31:31,160
up applies all the modifications and oh

00:31:34,730 --> 00:31:45,170
it's a zipper control never mind down

00:31:40,950 --> 00:31:45,170
left sure

00:31:49,050 --> 00:31:59,380
commit so this way we can get the tree

00:31:53,500 --> 00:32:01,090
with our changes applied another thing

00:31:59,380 --> 00:32:03,520
that is very cool about the zipper is

00:32:01,090 --> 00:32:05,950
that if you're doing some sort of

00:32:03,520 --> 00:32:07,570
interactive editing you can keep track

00:32:05,950 --> 00:32:11,050
of a part of the tree that you're

00:32:07,570 --> 00:32:13,120
editing or you can store it in JSON or

00:32:11,050 --> 00:32:17,500
something like that can also be very

00:32:13,120 --> 00:32:19,270
useful so this pretty much concludes it

00:32:17,500 --> 00:32:21,910
I don't know if you guys have any

00:32:19,270 --> 00:32:27,060
questions if there are no questions I

00:32:21,910 --> 00:32:27,060
can also show some bonus materials yes

00:32:31,740 --> 00:32:36,910
yeah absolutely so the question was if I

00:32:34,810 --> 00:32:41,710
could tell more about the use cases of

00:32:36,910 --> 00:32:44,680
ref 3 so referee started as a project

00:32:41,710 --> 00:32:48,010
for supporting this sort of live demos

00:32:44,680 --> 00:32:51,940
so last year is giving a talk on data

00:32:48,010 --> 00:32:54,220
structures and exploring how immutable

00:32:51,940 --> 00:32:56,110
data structures work and how they share

00:32:54,220 --> 00:32:59,140
parts of the structures when you update

00:32:56,110 --> 00:33:01,990
them and that talk also included some

00:32:59,140 --> 00:33:04,000
explanations of lenses and zippers and I

00:33:01,990 --> 00:33:06,370
found that it was really helpful to have

00:33:04,000 --> 00:33:07,690
this sort of visualization to instead of

00:33:06,370 --> 00:33:11,800
just writing code people can actually

00:33:07,690 --> 00:33:15,490
see what is happening once I had that

00:33:11,800 --> 00:33:17,560
tool I started employing it in other

00:33:15,490 --> 00:33:20,050
things so for example if you have a

00:33:17,560 --> 00:33:23,590
library like the zipper library that I'm

00:33:20,050 --> 00:33:26,620
using here which I wrote anyone to

00:33:23,590 --> 00:33:28,150
explain what is it creates you can just

00:33:26,620 --> 00:33:31,480
generate some of these pictures and put

00:33:28,150 --> 00:33:33,370
in the readme of the library right

00:33:31,480 --> 00:33:35,590
another thing that actually someone

00:33:33,370 --> 00:33:39,490
suggested to me that's colored by the

00:33:35,590 --> 00:33:43,270
way this November is that you can use

00:33:39,490 --> 00:33:45,220
this for job interviews so if you have

00:33:43,270 --> 00:33:48,790
some sort of data structure question

00:33:45,220 --> 00:33:52,690
like what what is this data structure

00:33:48,790 --> 00:33:55,570
you can just render it and show a

00:33:52,690 --> 00:33:57,940
picture and see if the person knows what

00:33:55,570 --> 00:33:59,390
it is or not regarding this I actually

00:33:57,940 --> 00:34:04,600
have this

00:33:59,390 --> 00:34:09,560
bonus here I can just leave it drawing

00:34:04,600 --> 00:34:11,330
this is a certain data structure where I

00:34:09,560 --> 00:34:13,129
elided the actual name of the data

00:34:11,330 --> 00:34:15,320
structure so you can try to guess what

00:34:13,129 --> 00:34:17,359
it is and while it's rolling I can take

00:34:15,320 --> 00:34:20,149
more questions so I'm not sure if if

00:34:17,359 --> 00:34:22,220
there's fully answers but I think there

00:34:20,149 --> 00:34:41,540
are quite a few things you can use this

00:34:22,220 --> 00:34:43,609
for yep absolutely

00:34:41,540 --> 00:34:45,800
so both dippers and lenses are

00:34:43,609 --> 00:34:49,280
functional concepts which allow you to

00:34:45,800 --> 00:34:50,899
edit something in the immutable way so

00:34:49,280 --> 00:34:53,030
when you do all these operations on the

00:34:50,899 --> 00:34:54,740
zipper it just returns a newspaper so

00:34:53,030 --> 00:34:56,869
you're not really modifying anything

00:34:54,740 --> 00:34:59,450
you're just applying modifications and

00:34:56,869 --> 00:35:03,170
getting a new thing back and in the same

00:34:59,450 --> 00:35:06,560
way lenses are things that allow you to

00:35:03,170 --> 00:35:08,390
modify nested immutable structures like

00:35:06,560 --> 00:35:11,869
case classes for example so I don't know

00:35:08,390 --> 00:35:13,580
if you ever tried to use a copy method

00:35:11,869 --> 00:35:15,890
this code provides you and you have like

00:35:13,580 --> 00:35:18,109
I don't know a startup and you have an

00:35:15,890 --> 00:35:20,119
employee inside and if you want to

00:35:18,109 --> 00:35:23,900
modify something inside the employees a

00:35:20,119 --> 00:35:29,869
start-up copy employee calls started

00:35:23,900 --> 00:35:32,720
employee it gets it gets very bad very

00:35:29,869 --> 00:35:35,960
fast so by using lenses you can actually

00:35:32,720 --> 00:35:38,090
do this very quickly and Adam is here he

00:35:35,960 --> 00:35:40,640
actually implemented a library called

00:35:38,090 --> 00:35:41,840
quick ones which allows you to do that

00:35:40,640 --> 00:35:44,660
sort of thing

00:35:41,840 --> 00:35:49,340
without creating lenses so I can show

00:35:44,660 --> 00:35:53,270
that lets say you have this well I can

00:35:49,340 --> 00:35:56,210
close this so let's let's say you have

00:35:53,270 --> 00:36:02,710
this employee which is a guy with the

00:35:56,210 --> 00:36:02,710
name and the salary and you have startup

00:36:04,140 --> 00:36:09,329
so startup has a founder and it has a

00:36:06,779 --> 00:36:11,279
team of employees and the use cage is

00:36:09,329 --> 00:36:16,619
basically you want to give everyone the

00:36:11,279 --> 00:36:18,240
raise right well in the mutable world

00:36:16,619 --> 00:36:20,160
what you would do even write some sort

00:36:18,240 --> 00:36:23,369
of loop and you just go there and mutate

00:36:20,160 --> 00:36:25,289
things right with lantus you can

00:36:23,369 --> 00:36:26,940
construct the lenses to focus in all

00:36:25,289 --> 00:36:28,710
different parts and be stirred up and

00:36:26,940 --> 00:36:29,940
but it's it's very boring because what

00:36:28,710 --> 00:36:31,079
you actually want to do is to give a

00:36:29,940 --> 00:36:34,079
raise

00:36:31,079 --> 00:36:35,700
you need to to dispatch this to the

00:36:34,079 --> 00:36:37,680
finance department and want to spend

00:36:35,700 --> 00:36:41,400
time creating Rises so what you can do

00:36:37,680 --> 00:36:44,299
is you can say startup I think I need to

00:36:41,400 --> 00:36:44,299
import quick ones

00:36:45,109 --> 00:36:53,700
maybe I don't let's see so startup you

00:36:50,339 --> 00:37:01,410
can say modify all and you can say

00:36:53,700 --> 00:37:05,630
founder and team peach using actually

00:37:01,410 --> 00:37:05,630
you want to modify the celery right

00:37:07,670 --> 00:37:16,559
using whatever was there plus 100 yeah

00:37:12,569 --> 00:37:18,749
that's it so this was very

00:37:16,559 --> 00:37:21,630
straightforward I think so

00:37:18,749 --> 00:37:22,920
lenses are really suited well for this

00:37:21,630 --> 00:37:25,769
sort of thing where you have case

00:37:22,920 --> 00:37:27,269
classes and they were probably different

00:37:25,769 --> 00:37:28,950
so it's not a recursive data structure

00:37:27,269 --> 00:37:31,160
you have startup inside you have an

00:37:28,950 --> 00:37:33,509
employee which is a different type

00:37:31,160 --> 00:37:35,700
deeper doesn't really work with that it

00:37:33,509 --> 00:37:37,230
needs something there are generic papers

00:37:35,700 --> 00:37:40,279
that work with that but the normal ones

00:37:37,230 --> 00:37:42,869
expect something the uniform so in XML

00:37:40,279 --> 00:37:45,450
children often note are also XML nodes

00:37:42,869 --> 00:37:46,829
so this kind of supports this sort of

00:37:45,450 --> 00:37:49,680
navigation because it's all uniform

00:37:46,829 --> 00:37:52,230
right so you can you can go back and

00:37:49,680 --> 00:37:55,529
forth on that so zippers are more for

00:37:52,230 --> 00:37:58,410
recursive data structures and lenses are

00:37:55,529 --> 00:38:00,239
for arbitrary things and they can also

00:37:58,410 --> 00:38:02,549
be used as a nice abstraction like we

00:38:00,239 --> 00:38:05,069
did in animation of just having a

00:38:02,549 --> 00:38:06,630
modified readwrite access to a part of

00:38:05,069 --> 00:38:08,880
the data structure it doesn't even have

00:38:06,630 --> 00:38:12,900
to be a field in the data structure so

00:38:08,880 --> 00:38:15,390
for example we have this XML edge and we

00:38:12,900 --> 00:38:18,210
have the lens or some sort of optic from

00:38:15,390 --> 00:38:19,920
xml2 a case class which is not really a

00:38:18,210 --> 00:38:22,530
part of that xml but we can still focus

00:38:19,920 --> 00:38:24,360
on it modify it and it modifies the

00:38:22,530 --> 00:38:28,140
original thing

00:38:24,360 --> 00:38:31,260
so the just sum up lenses how to say use

00:38:28,140 --> 00:38:34,290
for abstraction and use for nested case

00:38:31,260 --> 00:38:36,420
classes zipper is used for trees and for

00:38:34,290 --> 00:38:38,670
things that are uniform and when you

00:38:36,420 --> 00:38:40,470
really want to to do some recursive

00:38:38,670 --> 00:38:41,040
thing because zipper can also support

00:38:40,470 --> 00:38:43,650
oops

00:38:41,040 --> 00:38:45,330
so you can say go down until you meet

00:38:43,650 --> 00:38:47,940
some conditions with light as it is kind

00:38:45,330 --> 00:38:49,950
of more complicated and of course you

00:38:47,940 --> 00:38:52,260
can use zippers to implement lenses

00:38:49,950 --> 00:38:55,620
which apparently people are doing I know

00:38:52,260 --> 00:38:57,420
that people do that for jason'll yep is

00:38:55,620 --> 00:39:00,350
there been any interest in using this

00:38:57,420 --> 00:39:02,520
nad bugger like an IntelliJ or Eclipse

00:39:00,350 --> 00:39:04,200
should actually be stepping through code

00:39:02,520 --> 00:39:07,920
and seeing the al-qaida structure

00:39:04,200 --> 00:39:09,870
changed but sorry if I sneeze have

00:39:07,920 --> 00:39:13,920
hazard been any interest in implementing

00:39:09,870 --> 00:39:19,010
this made debugger and I haven't thought

00:39:13,920 --> 00:39:19,010
about it but I think it's a good idea

00:39:23,470 --> 00:39:26,460
for questions

00:39:43,230 --> 00:39:49,870
very little the bare basics that are

00:39:47,590 --> 00:39:56,980
needed to do what I need needed to do so

00:39:49,870 --> 00:40:00,040
I can show you I have GE optics so I

00:39:56,980 --> 00:40:02,890
have a bunch of SVG optics here a thing

00:40:00,040 --> 00:40:05,050
that gets a few box a thing that gets a

00:40:02,890 --> 00:40:11,620
translation which allows you to move

00:40:05,050 --> 00:40:14,620
things around opacity color path of a

00:40:11,620 --> 00:40:17,200
path element points of a polygon element

00:40:14,620 --> 00:40:18,940
and the position of text and some other

00:40:17,200 --> 00:40:22,870
stuff and that's basically it

00:40:18,940 --> 00:40:26,200
so it's surprisingly minimal it was not

00:40:22,870 --> 00:40:28,570
really able to cover all SVG the goal is

00:40:26,200 --> 00:40:32,170
to sort of get a principled approach

00:40:28,570 --> 00:40:35,440
that allows me to to try to interpolate

00:40:32,170 --> 00:40:37,330
it with some sanity because just go into

00:40:35,440 --> 00:40:42,040
XML and changing things there is not

00:40:37,330 --> 00:40:44,680
very simple to do but actually I at some

00:40:42,040 --> 00:40:47,860
point move to Scala GS and I have actual

00:40:44,680 --> 00:40:49,630
ascii for SVG there it would be easy to

00:40:47,860 --> 00:40:51,160
migrate because i already have all the

00:40:49,630 --> 00:40:55,770
lenses i would just need to parameterize

00:40:51,160 --> 00:40:55,770
the types yep

00:41:05,720 --> 00:41:11,160
absolutely so the question is if there

00:41:08,040 --> 00:41:13,140
are performance constraints and if you

00:41:11,160 --> 00:41:15,780
tried to render a collection with 1000

00:41:13,140 --> 00:41:19,050
items especially if it's a fairly

00:41:15,780 --> 00:41:21,869
complicated one like vector

00:41:19,050 --> 00:41:24,780
well 1000 probably is okay but 10,000

00:41:21,869 --> 00:41:29,069
let's say the resulting image is

00:41:24,780 --> 00:41:31,710
gigantic and you actually need a good

00:41:29,069 --> 00:41:34,560
image viewer to browse that because many

00:41:31,710 --> 00:41:37,200
image viewer is crash if you have that

00:41:34,560 --> 00:41:39,210
huge thing for animations it's even

00:41:37,200 --> 00:41:42,660
worse because it has several frames and

00:41:39,210 --> 00:41:45,240
if you have a lot of interpolation

00:41:42,660 --> 00:41:47,910
frames like let's say 100 frames is

00:41:45,240 --> 00:41:50,460
between each two key frames and you have

00:41:47,910 --> 00:41:53,940
something fairly complex happening in

00:41:50,460 --> 00:41:56,609
the frame it takes a bit of time to to

00:41:53,940 --> 00:41:58,829
actually render so I have some examples

00:41:56,609 --> 00:42:01,680
here that take maybe 5 minutes to render

00:41:58,829 --> 00:42:04,530
on my machine and it consumes about 6

00:42:01,680 --> 00:42:05,010
gigabytes of RAM just to give you an

00:42:04,530 --> 00:42:09,480
idea

00:42:05,010 --> 00:42:13,500
so obviously it's probably not a good

00:42:09,480 --> 00:42:15,240
idea to visualize something very huge

00:42:13,500 --> 00:42:18,680
but at the same time you probably don't

00:42:15,240 --> 00:42:18,680
want to be looking at something huge

00:42:34,910 --> 00:42:40,830
well I suppose if you render into SVG

00:42:38,340 --> 00:42:43,220
and then you have some sort of common

00:42:40,830 --> 00:42:46,500
mind tool that or some sort of tool that

00:42:43,220 --> 00:42:49,080
allows you to just render a part of SVG

00:42:46,500 --> 00:42:50,610
that would be possible or you can rent

00:42:49,080 --> 00:42:52,500
it through PNG I'm not sure if there is

00:42:50,610 --> 00:42:55,170
something that allows to render just a

00:42:52,500 --> 00:43:06,590
part of PNG but that should also be

00:42:55,170 --> 00:43:06,590
possible yeah

00:43:15,640 --> 00:43:30,920
yeah yeah yeah yeah I know it is the

00:43:28,550 --> 00:43:39,710
next step to translate it to Scala GS

00:43:30,920 --> 00:43:50,960
volunteers are welcome right

00:43:39,710 --> 00:43:52,940
no one yeah yeah well actually I could

00:43:50,960 --> 00:43:56,890
probably use the existing level like

00:43:52,940 --> 00:44:01,910
Scala ste I think something like that

00:43:56,890 --> 00:44:03,200
and also insert instead of just jumping

00:44:01,910 --> 00:44:05,420
when you switch from one thing to

00:44:03,200 --> 00:44:08,240
another from one picture to another I

00:44:05,420 --> 00:44:11,180
can use the same animation concept so it

00:44:08,240 --> 00:44:13,760
just smoothly animate I'm not sure how

00:44:11,180 --> 00:44:20,710
long it would take to render that in the

00:44:13,760 --> 00:44:20,710
browser but hopefully fast enough yeah

00:44:20,870 --> 00:44:27,870
it does not support circa references no

00:44:23,850 --> 00:44:31,770
so this is targeted towards immutable

00:44:27,870 --> 00:44:34,910
data structures where a circle reference

00:44:31,770 --> 00:44:34,910
is very unlikely

00:44:43,800 --> 00:44:54,069
anyone wants to guess what this is sorry

00:44:48,480 --> 00:44:56,700
nope this is actually a pretty cool data

00:44:54,069 --> 00:44:59,140
structure that is called finger tree

00:44:56,700 --> 00:45:05,079
there is a paper in it which is very

00:44:59,140 --> 00:45:07,630
enlightening in the discard a schedule

00:45:05,079 --> 00:45:09,700
you have to link to the demo page it has

00:45:07,630 --> 00:45:11,800
a full transcript of this talk and also

00:45:09,700 --> 00:45:14,950
of the previous talk which I really

00:45:11,800 --> 00:45:17,890
recommend and the previous talk halsey

00:45:14,950 --> 00:45:19,569
has some bonus materials and links to

00:45:17,890 --> 00:45:21,280
papers and stuff if you want to read

00:45:19,569 --> 00:45:23,440
about this sort of data structures like

00:45:21,280 --> 00:45:30,569
the zipper or the finger tree or lenses

00:45:23,440 --> 00:45:30,569

YouTube URL: https://www.youtube.com/watch?v=6mWaqGHeg3g


