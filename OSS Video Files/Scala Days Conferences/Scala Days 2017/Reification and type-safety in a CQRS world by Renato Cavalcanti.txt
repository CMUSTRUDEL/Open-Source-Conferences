Title: Reification and type-safety in a CQRS world by Renato Cavalcanti
Publication date: 2017-06-23
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
CQRS applications brings some new challenges for statically typed language lovers since a considerable amount of the modeling effort goes to the definition of Commands and Events as separated entities without direct connection with the main domain model classes. 

The biggest challenge is how to model a domain as an Algebraic Data Type where its operations are modeled as Commands and Events (themselves also ADTs) and have everything defined as a cohesive, well-typed domain.

This can be achieved in different ways: using type parameters, type projection or path dependent types. Each solution has its Pros and Cons that we will visit and discuss in detail.
Captions: 
	00:00:03,660 --> 00:00:11,340
I present a talk in skull exchange last

00:00:08,189 --> 00:00:13,620
year and when I was telling a colleague

00:00:11,340 --> 00:00:15,450
of mine at the time that I would present

00:00:13,620 --> 00:00:17,670
to talk about reification sand type

00:00:15,450 --> 00:00:19,650
saved and he said well you really want

00:00:17,670 --> 00:00:22,890
people going to go to your talk what

00:00:19,650 --> 00:00:27,000
worried what what's that like kind of

00:00:22,890 --> 00:00:31,949
scary name and so I hope it will not

00:00:27,000 --> 00:00:34,020
sound that scary later on so I have the

00:00:31,949 --> 00:00:37,350
agenda is I will explain my motivation

00:00:34,020 --> 00:00:41,969
of giving that talk and and then show

00:00:37,350 --> 00:00:46,289
how this how that problem can be solved

00:00:41,969 --> 00:00:48,690
using three ways type parameters type

00:00:46,289 --> 00:00:54,449
members using type projections and type

00:00:48,690 --> 00:00:56,910
members using path dependent types one

00:00:54,449 --> 00:00:59,910
of the thing that happens when I gave

00:00:56,910 --> 00:01:02,910
that talk there is I got someone a

00:00:59,910 --> 00:01:05,580
friend of mine that came to me and said

00:01:02,910 --> 00:01:08,520
well I'm not using secure as but I

00:01:05,580 --> 00:01:10,470
learned one nice trick is about how to

00:01:08,520 --> 00:01:12,740
use type members and why they are useful

00:01:10,470 --> 00:01:16,410
so even if you're not interesting in

00:01:12,740 --> 00:01:19,200
interested in secure as event sourcing

00:01:16,410 --> 00:01:22,290
well it can be a nice nice way to learn

00:01:19,200 --> 00:01:27,090
about how when it's nice when you should

00:01:22,290 --> 00:01:28,860
use that members or not so how I get

00:01:27,090 --> 00:01:31,440
into this problem well what is the

00:01:28,860 --> 00:01:34,950
problem of type safety and race

00:01:31,440 --> 00:01:36,600
occasions in secure as well the security

00:01:34,950 --> 00:01:39,980
community says that you should not write

00:01:36,600 --> 00:01:44,840
a framework but since I'm still born I

00:01:39,980 --> 00:01:48,060
wrote it and it's called from secures

00:01:44,840 --> 00:01:50,970
and it's written in Scala and then

00:01:48,060 --> 00:01:54,810
things they start to become interesting

00:01:50,970 --> 00:01:58,140
because if it's written in Scala well

00:01:54,810 --> 00:02:01,080
the first target was me was to use on a

00:01:58,140 --> 00:02:02,790
project I was working well many many

00:02:01,080 --> 00:02:07,640
different applications we are planning

00:02:02,790 --> 00:02:11,039
to uses and we were the first users and

00:02:07,640 --> 00:02:14,550
but also the community and since this is

00:02:11,039 --> 00:02:18,690
color and we like it to be type safe

00:02:14,550 --> 00:02:21,210
and but the verifications as I've

00:02:18,690 --> 00:02:24,210
explained in a while it introduced a

00:02:21,210 --> 00:02:30,570
problem for related to type safety so I

00:02:24,210 --> 00:02:33,900
need to solve it so basically I got into

00:02:30,570 --> 00:02:35,700
that problem because of you guys because

00:02:33,900 --> 00:02:38,730
of the scale community because of the

00:02:35,700 --> 00:02:41,100
way this car we Skylar develops one two

00:02:38,730 --> 00:02:47,580
code we want to have as much as much as

00:02:41,100 --> 00:02:51,420
we can type safe system so but this talk

00:02:47,580 --> 00:02:55,230
I I also use that talk to talk a little

00:02:51,420 --> 00:02:57,990
bit about my journey in building a

00:02:55,230 --> 00:03:00,390
secure as framework so those problems

00:02:57,990 --> 00:03:03,860
but also think about the API that I I

00:03:00,390 --> 00:03:07,740
would like to use when coding secure as

00:03:03,860 --> 00:03:09,870
applications and it's all about finding

00:03:07,740 --> 00:03:12,810
the right abstraction that I need

00:03:09,870 --> 00:03:18,500
putting away all the accidental

00:03:12,810 --> 00:03:21,000
complexity and back to what I said about

00:03:18,500 --> 00:03:24,630
writing or not write and secure as

00:03:21,000 --> 00:03:26,910
framework I I don't believe and that we

00:03:24,630 --> 00:03:28,680
should not write it because their

00:03:26,910 --> 00:03:32,220
operations of secure as they are dead

00:03:28,680 --> 00:03:34,230
simple and exactly because of that there

00:03:32,220 --> 00:03:37,110
are those operations that are simple and

00:03:34,230 --> 00:03:39,510
easy to group to a grasp and but there

00:03:37,110 --> 00:03:41,820
are lots of infrastructure around so if

00:03:39,510 --> 00:03:43,980
I can isolate those operations I can

00:03:41,820 --> 00:03:47,370
build something and leave those blanks

00:03:43,980 --> 00:03:50,070
and that's that is where the user will

00:03:47,370 --> 00:03:51,780
come and put their codes so when you

00:03:50,070 --> 00:03:54,060
code your domain you just have to fill

00:03:51,780 --> 00:03:56,610
those blanks all the rest around it I

00:03:54,060 --> 00:03:58,890
can offer for free in the framework so

00:03:56,610 --> 00:04:01,080
that's I think it's a good opportunity

00:03:58,890 --> 00:04:05,070
to write a library or a framework so

00:04:01,080 --> 00:04:08,610
that's why I disagree with that so and

00:04:05,070 --> 00:04:12,750
why why we do that is to abstract away

00:04:08,610 --> 00:04:15,660
the complexity to the users to yourself

00:04:12,750 --> 00:04:17,760
and and I think that function

00:04:15,660 --> 00:04:20,190
programming has some very nice paradigms

00:04:17,760 --> 00:04:22,019
for that and if you think about well

00:04:20,190 --> 00:04:22,919
when I talk about infrastructure I'm

00:04:22,019 --> 00:04:26,640
talking about IO

00:04:22,919 --> 00:04:28,410
and persistency and many of the dirty

00:04:26,640 --> 00:04:31,880
world of programming

00:04:28,410 --> 00:04:35,400
and function programming teachers how to

00:04:31,880 --> 00:04:37,410
put the side effects on the side really

00:04:35,400 --> 00:04:40,620
on the border of your system and we have

00:04:37,410 --> 00:04:44,940
many constructs to do that so why not do

00:04:40,620 --> 00:04:47,760
the library to do that and the other

00:04:44,940 --> 00:04:49,980
thing is I will explain how it happens

00:04:47,760 --> 00:04:51,960
and whenever I give a talk I learn a lot

00:04:49,980 --> 00:04:53,760
because I have to rethink things that I

00:04:51,960 --> 00:04:55,980
have been doing and be able to explain

00:04:53,760 --> 00:04:58,560
and in that particular case when I

00:04:55,980 --> 00:05:00,600
submit that talk at scull exchange I

00:04:58,560 --> 00:05:03,510
didn't have a solution for the path

00:05:00,600 --> 00:05:05,700
dependent types so I showed that I had

00:05:03,510 --> 00:05:07,140
three there are three ways of doing that

00:05:05,700 --> 00:05:10,290
and I didn't have a solution for the

00:05:07,140 --> 00:05:11,910
third one and I need I want to have that

00:05:10,290 --> 00:05:14,400
solution because I want to move out of

00:05:11,910 --> 00:05:16,830
type projections because of many reasons

00:05:14,400 --> 00:05:19,920
that's of being every announced that it

00:05:16,830 --> 00:05:23,850
will disappear from Scala so I want to

00:05:19,920 --> 00:05:27,450
try to type the path dependent types and

00:05:23,850 --> 00:05:30,270
it happened that at some point I thought

00:05:27,450 --> 00:05:33,240
oh that will be a failure I am NOT being

00:05:30,270 --> 00:05:36,540
able to to find nice API to do that I

00:05:33,240 --> 00:05:40,860
had the solution but was there were some

00:05:36,540 --> 00:05:42,690
friction that I didn't like and but at

00:05:40,860 --> 00:05:44,520
the last moment I found a solution and I

00:05:42,690 --> 00:05:46,800
was very happy just before the talk that

00:05:44,520 --> 00:05:49,740
the head solutions okay well if I

00:05:46,800 --> 00:05:52,140
couldn't find it I would make it give a

00:05:49,740 --> 00:05:55,169
talk about a fader which is also okay

00:05:52,140 --> 00:05:58,350
but of course I prefer to to give a talk

00:05:55,169 --> 00:06:03,050
about something that I am Anna stir to

00:05:58,350 --> 00:06:06,120
build so okay so what I mean about

00:06:03,050 --> 00:06:07,980
education so we have we know we use the

00:06:06,120 --> 00:06:10,800
term reification when we talk about

00:06:07,980 --> 00:06:16,290
types the type later a sure there is no

00:06:10,800 --> 00:06:18,390
rarefied types after at runtime we can

00:06:16,290 --> 00:06:21,419
talk about reification so when you have

00:06:18,390 --> 00:06:24,240
a methods and you refight the function

00:06:21,419 --> 00:06:26,460
so it becomes I don't want to use the

00:06:24,240 --> 00:06:28,880
term entity because it's a it's not the

00:06:26,460 --> 00:06:31,320
right term for that but it becomes one

00:06:28,880 --> 00:06:33,000
thing that you can manipulate that's not

00:06:31,320 --> 00:06:37,470
a member of another type but it's

00:06:33,000 --> 00:06:40,350
something that it's a class or no in

00:06:37,470 --> 00:06:42,660
case of a function you verify a method

00:06:40,350 --> 00:06:45,400
to a function so you get an object

00:06:42,660 --> 00:06:47,380
an instance of that matter that you can

00:06:45,400 --> 00:06:53,200
pass around that's a kind of reification

00:06:47,380 --> 00:06:56,380
so what happens insecure s is that when

00:06:53,200 --> 00:06:58,180
you're modeling commands and advance the

00:06:56,380 --> 00:07:03,310
first thing that you realize is that

00:06:58,180 --> 00:07:06,450
your model that before in a way of doing

00:07:03,310 --> 00:07:09,550
things have let's say I have an order

00:07:06,450 --> 00:07:13,690
kind of shopping carts application very

00:07:09,550 --> 00:07:16,870
simple and I have an ADD item remove

00:07:13,690 --> 00:07:20,110
items and remove item which gives me

00:07:16,870 --> 00:07:24,100
back a new order that's the old way of

00:07:20,110 --> 00:07:26,140
doing so the first way the first

00:07:24,100 --> 00:07:29,170
verifications that we're education that

00:07:26,140 --> 00:07:33,820
we have here is that those methods will

00:07:29,170 --> 00:07:35,920
become Ches class model commands and I'm

00:07:33,820 --> 00:07:38,290
modeling one more here that was not

00:07:35,920 --> 00:07:41,250
present on the previous slides I have

00:07:38,290 --> 00:07:43,900
three methods and I end up with four

00:07:41,250 --> 00:07:46,210
commands because there is one command

00:07:43,900 --> 00:07:48,940
that is the equivalent of my constructor

00:07:46,210 --> 00:07:51,990
the one that we initialize my class my

00:07:48,940 --> 00:07:56,590
model and all my my model here has

00:07:51,990 --> 00:07:58,390
nothing inside but we don't stop there

00:07:56,590 --> 00:08:01,270
there is another reification that is

00:07:58,390 --> 00:08:04,060
even not here express it is how I

00:08:01,270 --> 00:08:06,640
express change and the changes are

00:08:04,060 --> 00:08:12,630
expressed in terms of events in the past

00:08:06,640 --> 00:08:15,310
tense and this is also rare occasion and

00:08:12,630 --> 00:08:17,950
the problem that I have now is that I

00:08:15,310 --> 00:08:20,260
have three kinds of objects I have my

00:08:17,950 --> 00:08:23,710
model I have commands and I have events

00:08:20,260 --> 00:08:27,910
and they are unrelated how can I prove

00:08:23,710 --> 00:08:31,120
that create order of add item is a

00:08:27,910 --> 00:08:34,000
comment for order they are just

00:08:31,120 --> 00:08:37,120
unrelated types so that's the first

00:08:34,000 --> 00:08:40,600
problem of that I want to solve is I

00:08:37,120 --> 00:08:44,230
create I separate my model I refi my

00:08:40,600 --> 00:08:46,120
commands array I refine the events I

00:08:44,230 --> 00:08:47,530
even cannot say if every fight because

00:08:46,120 --> 00:08:50,350
defense were not there but I create

00:08:47,530 --> 00:08:52,780
something that is unrelated not

00:08:50,350 --> 00:08:55,650
connected to my original model and now I

00:08:52,780 --> 00:09:03,940
have to glue them together

00:08:55,650 --> 00:09:08,650
so one other thing that that will happen

00:09:03,940 --> 00:09:12,130
is that I need to code my behavior if

00:09:08,650 --> 00:09:14,650
you think about if you see how people

00:09:12,130 --> 00:09:20,200
have been doing security applications in

00:09:14,650 --> 00:09:22,600
Java I have seen some coding blog posts

00:09:20,200 --> 00:09:25,570
of mailing lists and people are really

00:09:22,600 --> 00:09:30,130
creating methods like add item item

00:09:25,570 --> 00:09:32,560
added and on the object itself of course

00:09:30,130 --> 00:09:34,900
when you do that that's not abstract

00:09:32,560 --> 00:09:37,000
enough because I cannot build a

00:09:34,900 --> 00:09:38,620
framework unless I start to put

00:09:37,000 --> 00:09:40,570
annotations on those methods to say oh

00:09:38,620 --> 00:09:42,760
that's the command handler that's an

00:09:40,570 --> 00:09:45,430
advantage handler I have to teach the

00:09:42,760 --> 00:09:49,480
framework where there are the methods

00:09:45,430 --> 00:09:53,680
unless I do that or I create some their

00:09:49,480 --> 00:09:56,440
obstruction so and the other thing that

00:09:53,680 --> 00:09:59,410
we will see is that people have like

00:09:56,440 --> 00:10:01,840
something add item and then it receive

00:09:59,410 --> 00:10:05,800
an e d item commands and it give me back

00:10:01,840 --> 00:10:09,610
an order and he emitted the new version

00:10:05,800 --> 00:10:12,640
of that order and added event the the

00:10:09,610 --> 00:10:14,890
new event and of course we are talking

00:10:12,640 --> 00:10:19,120
also about event sourcing so I have to

00:10:14,890 --> 00:10:22,420
save that event and what happens in Java

00:10:19,120 --> 00:10:25,420
word is that people inject in your

00:10:22,420 --> 00:10:28,390
domain kind of event store of event

00:10:25,420 --> 00:10:31,330
publisher and they publish that event

00:10:28,390 --> 00:10:32,920
from there inside of course scalloped

00:10:31,330 --> 00:10:36,160
words we don't want to work like that

00:10:32,920 --> 00:10:37,360
so and of course also in the Java or

00:10:36,160 --> 00:10:41,290
other language there are other

00:10:37,360 --> 00:10:44,620
opportunities is to just do that outside

00:10:41,290 --> 00:10:47,410
your model which is a bad thing to do of

00:10:44,620 --> 00:10:49,900
course but it's very repetitive I'm now

00:10:47,410 --> 00:10:52,990
epsilon that I send something I have to

00:10:49,900 --> 00:10:59,050
save my event and I want to get rid of

00:10:52,990 --> 00:11:02,320
that as well so that's that's the thing

00:10:59,050 --> 00:11:03,820
about having abstraction defined the

00:11:02,320 --> 00:11:05,920
operations have a clear definitive

00:11:03,820 --> 00:11:08,860
define and operations and then cut out

00:11:05,920 --> 00:11:10,930
some blanks that people can feel that

00:11:08,860 --> 00:11:12,400
one of them I don't have to save the

00:11:10,930 --> 00:11:15,550
framework should do that for me

00:11:12,400 --> 00:11:17,860
but I should be able to offer the way

00:11:15,550 --> 00:11:20,110
the the means to the framework to work

00:11:17,860 --> 00:11:23,770
to do that for me

00:11:20,110 --> 00:11:26,470
so what I'm looking for is a way to

00:11:23,770 --> 00:11:30,160
define my commands and events how do we

00:11:26,470 --> 00:11:32,140
initialize my model how to define my

00:11:30,160 --> 00:11:33,850
behavior because I was talking about

00:11:32,140 --> 00:11:38,470
race vacations and the commands and

00:11:33,850 --> 00:11:42,070
events but we didn't yet see how how can

00:11:38,470 --> 00:11:48,460
i model my my business rules how can I

00:11:42,070 --> 00:11:50,080
write it so oops yeah and I want

00:11:48,460 --> 00:11:53,410
something that frees my hands from

00:11:50,080 --> 00:11:56,160
dealing with infrastructure and of

00:11:53,410 --> 00:11:58,810
course and that's very much inspired by

00:11:56,160 --> 00:12:01,450
previous talk from viewable vendors

00:11:58,810 --> 00:12:04,330
where he talked about build an API that

00:12:01,450 --> 00:12:07,510
is easy to understand and frictionless

00:12:04,330 --> 00:12:10,930
and only offer what has to be done and

00:12:07,510 --> 00:12:14,130
not nothing else and so that was one of

00:12:10,930 --> 00:12:16,960
my motivations as well so just to

00:12:14,130 --> 00:12:19,990
illustrate very shortly because when I

00:12:16,960 --> 00:12:23,050
you show the code later on I like you

00:12:19,990 --> 00:12:26,980
guys to understand why why so much cold

00:12:23,050 --> 00:12:28,900
and and then I will have a look on the

00:12:26,980 --> 00:12:31,750
the problem of reification how can we

00:12:28,900 --> 00:12:35,050
solve that but imagine that we have to

00:12:31,750 --> 00:12:37,930
now now to code a domain where with

00:12:35,050 --> 00:12:40,390
commands and events obviously that first

00:12:37,930 --> 00:12:42,670
code fragment is not the same it's not

00:12:40,390 --> 00:12:44,560
other I need because if I call like that

00:12:42,670 --> 00:12:47,020
I cannot have a library that helps me

00:12:44,560 --> 00:12:50,710
what I need are those two other

00:12:47,020 --> 00:12:54,010
functions here at some point I may not

00:12:50,710 --> 00:12:57,130
have yet a model I still have to create

00:12:54,010 --> 00:13:01,240
it I have a model I get a command and I

00:12:57,130 --> 00:13:02,890
may send back a list of events in my

00:13:01,240 --> 00:13:04,870
library that's not the signature okay

00:13:02,890 --> 00:13:07,930
because you can choose to return a try

00:13:04,870 --> 00:13:10,750
because a command can fail it can be a

00:13:07,930 --> 00:13:13,630
future depend on what you are doing but

00:13:10,750 --> 00:13:17,260
I by the way the code that I will show

00:13:13,630 --> 00:13:19,120
is not the codes that I have add in some

00:13:17,260 --> 00:13:21,880
cigarettes is very similar but it's much

00:13:19,120 --> 00:13:22,630
more simpler that I prepared it's just

00:13:21,880 --> 00:13:24,730
for the good for

00:13:22,630 --> 00:13:26,230
for the presentation so here that least

00:13:24,730 --> 00:13:28,779
it would be another type okay

00:13:26,230 --> 00:13:32,230
but the event model it's pretty much the

00:13:28,779 --> 00:13:34,240
same the Devon handler I may have

00:13:32,230 --> 00:13:36,880
nothing and I get my first event that

00:13:34,240 --> 00:13:41,350
will give me back a sum of my models or

00:13:36,880 --> 00:13:44,170
I may have a red model I apply an event

00:13:41,350 --> 00:13:47,470
and I get a new updated version and if

00:13:44,170 --> 00:13:49,930
you look to this signature it's a very

00:13:47,470 --> 00:13:54,430
good one to use on a folder left so when

00:13:49,930 --> 00:13:57,240
you replay your events that that that

00:13:54,430 --> 00:14:00,339
function can be used on on a fault list

00:13:57,240 --> 00:14:02,470
having the option M the option of your

00:14:00,339 --> 00:14:08,139
model being the seeds and the

00:14:02,470 --> 00:14:11,589
accumulator of your events so I I want

00:14:08,139 --> 00:14:14,500
to have something that is type safe that

00:14:11,589 --> 00:14:16,779
I bring to get my aggregate on my model

00:14:14,500 --> 00:14:19,420
my command my events and where I can

00:14:16,779 --> 00:14:21,009
declare my commands and events so let's

00:14:19,420 --> 00:14:25,149
say that I need this thing called

00:14:21,009 --> 00:14:29,350
behavior with those two methods but if I

00:14:25,149 --> 00:14:32,199
implement that myself that's extremely

00:14:29,350 --> 00:14:36,279
annoying code like that I have to put a

00:14:32,199 --> 00:14:38,459
magic on my option of order and the

00:14:36,279 --> 00:14:42,040
command and if I don't have an order

00:14:38,459 --> 00:14:46,540
then the comment that I receive must be

00:14:42,040 --> 00:14:49,870
a create order if I do have an order or

00:14:46,540 --> 00:14:52,240
those three the next three here then I

00:14:49,870 --> 00:14:56,380
can only receive one of those commands

00:14:52,240 --> 00:14:59,889
and to make the scholar compiler happy I

00:14:56,380 --> 00:15:03,819
have to put another case say well and if

00:14:59,889 --> 00:15:06,610
I do have an order and I receive a

00:15:03,819 --> 00:15:09,130
create order command that's a league of

00:15:06,610 --> 00:15:11,410
things so in that case it's a stupid

00:15:09,130 --> 00:15:15,850
example but you should return an error

00:15:11,410 --> 00:15:20,139
and return empty list because for demo

00:15:15,850 --> 00:15:23,259
purpose I keep it very simple there's

00:15:20,139 --> 00:15:26,050
another kind of friction here is Here I

00:15:23,259 --> 00:15:28,209
am eating only one events but I have to

00:15:26,050 --> 00:15:30,939
wrap it each time on a list because my

00:15:28,209 --> 00:15:34,860
signature is saying this thing is soft

00:15:30,939 --> 00:15:34,860
in front secures but

00:15:35,840 --> 00:15:43,920
here I decided to make it much simpler

00:15:39,140 --> 00:15:47,700
so then you what we can do is having DSL

00:15:43,920 --> 00:15:50,250
to define your domain and you see later

00:15:47,700 --> 00:15:52,020
that this actions thing here it's

00:15:50,250 --> 00:15:54,900
something that brings my types that I

00:15:52,020 --> 00:15:57,600
will glue together later and this type

00:15:54,900 --> 00:16:01,380
safe I cannot have a command handler

00:15:57,600 --> 00:16:04,410
that is not handling a command that does

00:16:01,380 --> 00:16:06,750
not belong to order and I cannot have an

00:16:04,410 --> 00:16:10,250
event handler that is not handling an

00:16:06,750 --> 00:16:14,400
event that does not belong to order and

00:16:10,250 --> 00:16:16,620
this DSL will help me to solve the fact

00:16:14,400 --> 00:16:19,590
that I have here an option because at

00:16:16,620 --> 00:16:22,110
first I have to create so at first I

00:16:19,590 --> 00:16:24,690
have a nun so I don't I only need to

00:16:22,110 --> 00:16:28,730
have a function from command to the list

00:16:24,690 --> 00:16:30,170
of events or a function from events and

00:16:28,730 --> 00:16:33,090
multi-model

00:16:30,170 --> 00:16:37,230
that's when I'm constructing my my

00:16:33,090 --> 00:16:41,430
domain the other once I have something

00:16:37,230 --> 00:16:44,100
then I have some model I don't need to

00:16:41,430 --> 00:16:46,740
remove the option here I can have such a

00:16:44,100 --> 00:16:50,820
function that receive my order and then

00:16:46,740 --> 00:16:52,920
I can define what I do as command the

00:16:50,820 --> 00:16:56,250
hammers okay why I'm showing that is

00:16:52,920 --> 00:16:59,190
because I when I show the code you'll

00:16:56,250 --> 00:17:01,560
have to understand how all those things

00:16:59,190 --> 00:17:03,990
are glued together so I have the

00:17:01,560 --> 00:17:05,790
reification a problem that we see how to

00:17:03,990 --> 00:17:09,900
solve it there are three ways of solving

00:17:05,790 --> 00:17:13,020
that we have the need to define our

00:17:09,900 --> 00:17:18,209
functions and everyone to have that all

00:17:13,020 --> 00:17:23,420
well type it and and as much as we can

00:17:18,209 --> 00:17:23,420
have a lot of idea Mattox color code so

00:17:23,810 --> 00:17:31,740
the first example that I will show of

00:17:26,640 --> 00:17:35,880
course is the most simple form which is

00:17:31,740 --> 00:17:39,000
the type parameter variation and here

00:17:35,880 --> 00:17:42,450
have disorder as you see just a caged

00:17:39,000 --> 00:17:44,700
class okay here inside I have some

00:17:42,450 --> 00:17:46,860
actions which are the actions when I

00:17:44,700 --> 00:17:48,210
have a rather order that's my model it's

00:17:46,860 --> 00:17:51,929
there ready and I have

00:17:48,210 --> 00:17:55,470
their possible actions and but one then

00:17:51,929 --> 00:17:57,720
I don't have yet an action I have sorry

00:17:55,470 --> 00:17:59,909
when I don't have you at my model I need

00:17:57,720 --> 00:18:02,549
to create it so in the companion object

00:17:59,909 --> 00:18:04,649
I have to glue that together that's the

00:18:02,549 --> 00:18:07,049
first thing we know how to do that I

00:18:04,649 --> 00:18:12,000
want to have now the actions for those

00:18:07,049 --> 00:18:15,809
three types I glue them together and and

00:18:12,000 --> 00:18:19,620
then I define my my my behavior first

00:18:15,809 --> 00:18:21,450
create using those actions and then once

00:18:19,620 --> 00:18:23,429
you have something you can update in

00:18:21,450 --> 00:18:26,640
using those other actions okay that's

00:18:23,429 --> 00:18:31,890
that simple the thing is starting to get

00:18:26,640 --> 00:18:35,070
interesting later type parameters but

00:18:31,890 --> 00:18:40,909
now I need to tell my framework that I

00:18:35,070 --> 00:18:47,490
have that order behavior so who is

00:18:40,909 --> 00:18:50,970
familiar with Lagaan yeah no need to

00:18:47,490 --> 00:18:54,059
have more people need to promote that

00:18:50,970 --> 00:18:59,250
more maybe well it's very similar to

00:18:54,059 --> 00:19:01,950
what logon is doing and so you define

00:18:59,250 --> 00:19:04,140
your behavior and you give it the Telugu

00:19:01,950 --> 00:19:06,809
net that exists phone Sakura is very

00:19:04,140 --> 00:19:09,380
similar it does the same actually and at

00:19:06,809 --> 00:19:12,059
some point if you ask a reference to it

00:19:09,380 --> 00:19:15,419
but because I'm using type parameters I

00:19:12,059 --> 00:19:18,210
have to over and over again tell okay

00:19:15,419 --> 00:19:20,779
give me now other graphs aggregate rafts

00:19:18,210 --> 00:19:23,760
of order or a command and other events

00:19:20,779 --> 00:19:30,990
but at that point here there is nothing

00:19:23,760 --> 00:19:33,809
to me that will blocks me to do that

00:19:30,990 --> 00:19:36,419
that will compile of course this code

00:19:33,809 --> 00:19:38,220
here is type safe it's it I'm passing

00:19:36,419 --> 00:19:40,220
here other commands so it's not compiled

00:19:38,220 --> 00:19:42,659
anymore but I would be able to do that

00:19:40,220 --> 00:19:45,840
because I'm using type parameters they

00:19:42,659 --> 00:19:51,149
are not in itself blue glued together

00:19:45,840 --> 00:19:54,600
yet and for some people that may be

00:19:51,149 --> 00:19:58,200
silly but if I'm building on API I don't

00:19:54,600 --> 00:20:00,630
want to offer that API because the other

00:19:58,200 --> 00:20:01,960
part we can argue that okay we do that

00:20:00,630 --> 00:20:10,330
once and that's okay

00:20:01,960 --> 00:20:13,389
like when we did here the here that's

00:20:10,330 --> 00:20:15,009
okay to do that you do that once and you

00:20:13,389 --> 00:20:18,220
don't touch that code anymore

00:20:15,009 --> 00:20:20,679
however but every time that I will use

00:20:18,220 --> 00:20:23,619
my order I have to pass three parameters

00:20:20,679 --> 00:20:27,249
so I don't want to do that that's the

00:20:23,619 --> 00:20:28,779
the most users API when you go like that

00:20:27,249 --> 00:20:33,490
because whenever you need an instance

00:20:28,779 --> 00:20:35,559
you have to call that code and I didn't

00:20:33,490 --> 00:20:39,580
like it so I need to find another way of

00:20:35,559 --> 00:20:41,649
doing that so the other possible way of

00:20:39,580 --> 00:20:43,419
doing that is using type projections or

00:20:41,649 --> 00:20:46,720
typing typing members with type

00:20:43,419 --> 00:20:49,330
projections so in that example I force

00:20:46,720 --> 00:20:51,909
the user to implement a given trait

00:20:49,330 --> 00:20:55,299
which is the aggregate that has a

00:20:51,909 --> 00:20:56,970
command and an advanced type defining

00:20:55,299 --> 00:21:00,070
inside of them so that's the way of

00:20:56,970 --> 00:21:03,490
gluing things together because now my

00:21:00,070 --> 00:21:06,720
other type will carry along with him the

00:21:03,490 --> 00:21:09,610
command and events that that it needs

00:21:06,720 --> 00:21:12,399
the rest here is pretty much the same

00:21:09,610 --> 00:21:14,110
I'm using the same behavior DSL the same

00:21:12,399 --> 00:21:18,429
actions command hands and that's that

00:21:14,110 --> 00:21:22,960
the same but when I do my main press

00:21:18,429 --> 00:21:25,240
projections then when I do that now I

00:21:22,960 --> 00:21:28,690
don't need to pass the commands and the

00:21:25,240 --> 00:21:32,019
vents for order anymore because they

00:21:28,690 --> 00:21:34,419
live inside the order so by doing that I

00:21:32,019 --> 00:21:38,740
believe I am offering much better API

00:21:34,419 --> 00:21:40,480
now so I just say I have an order and go

00:21:38,740 --> 00:21:43,889
there and you find there other types of

00:21:40,480 --> 00:21:46,809
air inside but what happens here is that

00:21:43,889 --> 00:21:48,669
there is sight on that matters so

00:21:46,809 --> 00:21:52,299
disregard this one here because it's

00:21:48,669 --> 00:21:56,379
just for demo purpose and is not so much

00:21:52,299 --> 00:21:58,960
important but they're inside I have to

00:21:56,379 --> 00:22:01,960
navigate to my other types so the

00:21:58,960 --> 00:22:05,169
commands and the events and I do that by

00:22:01,960 --> 00:22:07,629
using type projection and that's the the

00:22:05,169 --> 00:22:10,809
first reason why you'd use type members

00:22:07,629 --> 00:22:13,899
not because it's fancy is because the or

00:22:10,809 --> 00:22:15,730
some types that belong together so they

00:22:13,899 --> 00:22:17,560
can put you can put them you can

00:22:15,730 --> 00:22:19,750
find them inside another one and I

00:22:17,560 --> 00:22:23,200
search don't have to declare them over

00:22:19,750 --> 00:22:25,990
and over again the main type carries on

00:22:23,200 --> 00:22:28,180
the other ones and there are ways of

00:22:25,990 --> 00:22:29,860
navigate to that and the first one is

00:22:28,180 --> 00:22:34,210
the type rejection and the thing is well

00:22:29,860 --> 00:22:35,920
I don't even understand the the real

00:22:34,210 --> 00:22:37,270
reasons why they are removing type

00:22:35,920 --> 00:22:40,360
projects they say that there are not

00:22:37,270 --> 00:22:44,350
sounds I don't have enough computer

00:22:40,360 --> 00:22:47,800
science or programming programming a

00:22:44,350 --> 00:22:49,810
compiler knowledge to understand what

00:22:47,800 --> 00:22:52,060
they the reasons for that

00:22:49,810 --> 00:22:55,120
but what I have experienced in France

00:22:52,060 --> 00:22:57,370
occur as while doing that is that in

00:22:55,120 --> 00:23:00,520
some situations the type of theory would

00:22:57,370 --> 00:23:03,490
not work in the way I want and it was

00:23:00,520 --> 00:23:05,770
painful and I was also the phone

00:23:03,490 --> 00:23:07,780
cigarettes API is much more well the API

00:23:05,770 --> 00:23:09,940
is very similar to what I'm showing here

00:23:07,780 --> 00:23:12,280
but the things that happens behind are

00:23:09,940 --> 00:23:15,910
much more complex than this demo thing

00:23:12,280 --> 00:23:18,190
and the type projects was beating me

00:23:15,910 --> 00:23:19,660
from time to time like I say I did

00:23:18,190 --> 00:23:24,240
something say right that's why that's

00:23:19,660 --> 00:23:24,240
not recognized the right type here and

00:23:24,660 --> 00:23:29,680
well and I solve that by trying try and

00:23:27,700 --> 00:23:31,440
try and try until that compiles I don't

00:23:29,680 --> 00:23:34,030
know if that's the same for you guys but

00:23:31,440 --> 00:23:36,190
when I do this kind of stuff it's not

00:23:34,030 --> 00:23:37,870
that I can see if I well I know why it's

00:23:36,190 --> 00:23:40,180
not compiled no I don't know why we'll

00:23:37,870 --> 00:23:44,350
try to I'd say okay I find I find how I

00:23:40,180 --> 00:23:47,920
can encode that I could drop a made two

00:23:44,350 --> 00:23:52,240
miles and ask some assistance but I

00:23:47,920 --> 00:23:52,600
don't think his selling subscription for

00:23:52,240 --> 00:23:56,170
that

00:23:52,600 --> 00:23:59,410
so anyway by the way the solution I have

00:23:56,170 --> 00:24:01,360
for type projections was after talking

00:23:59,410 --> 00:24:04,470
with miles about that problem and he

00:24:01,360 --> 00:24:07,930
gave me a very simple clever solution is

00:24:04,470 --> 00:24:13,210
why don't you put those types inside an

00:24:07,930 --> 00:24:19,390
object and say well obvious and so I

00:24:13,210 --> 00:24:22,840
went for that for the next one and and

00:24:19,390 --> 00:24:25,450
it changed a lot the API and other

00:24:22,840 --> 00:24:28,990
things that I can do so first my order

00:24:25,450 --> 00:24:29,750
here it's not implemented whatever okay

00:24:28,990 --> 00:24:34,430
it's

00:24:29,750 --> 00:24:41,840
an order however I can

00:24:34,430 --> 00:24:45,310
oh it's not this one this one okay again

00:24:41,840 --> 00:24:47,720
my order here is not implement whatever

00:24:45,310 --> 00:24:50,870
because the types will not be defined

00:24:47,720 --> 00:24:54,680
inside a class but they will be defined

00:24:50,870 --> 00:24:56,990
inside my other companion object I still

00:24:54,680 --> 00:24:59,530
have to let my companion object

00:24:56,990 --> 00:25:03,670
implement something I call it types

00:24:59,530 --> 00:25:08,000
maybe not the best name for that word a

00:25:03,670 --> 00:25:09,710
name for this trait but it's where I

00:25:08,000 --> 00:25:11,390
will glue them together it's like the

00:25:09,710 --> 00:25:13,820
aggregate on the previous one but now

00:25:11,390 --> 00:25:16,820
it's something that I targeting the it's

00:25:13,820 --> 00:25:21,380
that goal here is to use that in the in

00:25:16,820 --> 00:25:26,000
the implemented by the the companion

00:25:21,380 --> 00:25:29,120
objects then what happens next

00:25:26,000 --> 00:25:31,040
is that they're inside how you remove

00:25:29,120 --> 00:25:32,960
this one I don't want you guys to see

00:25:31,040 --> 00:25:36,050
what it was because that's that's the

00:25:32,960 --> 00:25:39,800
interesting part for later well inside

00:25:36,050 --> 00:25:42,440
that items types I can let you define

00:25:39,800 --> 00:25:44,870
the commanded event and I can also now

00:25:42,440 --> 00:25:46,550
because it's there in the companion

00:25:44,870 --> 00:25:48,740
object off in this object that you

00:25:46,550 --> 00:25:51,470
implement types now I can also define

00:25:48,740 --> 00:25:53,180
that actions for you so you give me you

00:25:51,470 --> 00:25:54,680
define the two type members that you

00:25:53,180 --> 00:26:02,390
have to define and you can already

00:25:54,680 --> 00:26:05,750
access the actions there don't read and

00:26:02,390 --> 00:26:08,420
now I can use the actions to build my

00:26:05,750 --> 00:26:11,410
own command handles and event handlers

00:26:08,420 --> 00:26:16,880
and the types are all there for me and

00:26:11,410 --> 00:26:21,290
again here on my class I can access via

00:26:16,880 --> 00:26:26,300
my companion objects the action so it's

00:26:21,290 --> 00:26:30,170
a better API I believe and what's next

00:26:26,300 --> 00:26:32,630
is that a type of the Tenno types here

00:26:30,170 --> 00:26:35,140
is exactly the same as the type

00:26:32,630 --> 00:26:40,700
projection version exactly the same code

00:26:35,140 --> 00:26:42,809
but this back end here this back end has

00:26:40,700 --> 00:26:46,879
another implementation from this

00:26:42,809 --> 00:26:50,009
crafts and this one is using the types

00:26:46,879 --> 00:26:52,889
so it's required and that that's what I

00:26:50,009 --> 00:26:55,889
was not happy with I said okay I put

00:26:52,889 --> 00:27:03,090
those types inside an object how much

00:26:55,889 --> 00:27:08,399
time I do have a low I don't know 20

00:27:03,090 --> 00:27:11,399
minutes ah that's great I talk a lot so

00:27:08,399 --> 00:27:14,090
when I when I was looking to that

00:27:11,399 --> 00:27:18,450
solution okay now I can have this object

00:27:14,090 --> 00:27:20,700
that carry on my types but I had two

00:27:18,450 --> 00:27:22,499
options whether I put when you ask for

00:27:20,700 --> 00:27:27,840
aggregate you have to give me the types

00:27:22,499 --> 00:27:30,629
as an explicit argument or I put it as

00:27:27,840 --> 00:27:34,649
in priest and the thing is and that's

00:27:30,629 --> 00:27:37,649
why I was not happy because as I said I

00:27:34,649 --> 00:27:40,289
want to offer an API that is as much as

00:27:37,649 --> 00:27:42,779
possible frictionless as much as

00:27:40,289 --> 00:27:45,029
possible so if I have to remind people

00:27:42,779 --> 00:27:46,710
and don't forget to give me that object

00:27:45,029 --> 00:27:51,769
as well because I need to know the type

00:27:46,710 --> 00:27:56,580
or don't forget to put that the types in

00:27:51,769 --> 00:27:58,619
in in an implicit scope then then I

00:27:56,580 --> 00:28:04,009
think it's not a good a guy yes donors

00:27:58,619 --> 00:28:04,009
say yeah I repeat the question

00:28:21,020 --> 00:28:31,770
well okay so the question is why I have

00:28:27,140 --> 00:28:35,400
why I don't have all of them as type

00:28:31,770 --> 00:28:38,280
members in my behavior but I start with

00:28:35,400 --> 00:28:41,730
one type the aggregates my model with

00:28:38,280 --> 00:28:44,160
the other types inside well if you look

00:28:41,730 --> 00:28:46,740
how that was achieved achieved in in

00:28:44,160 --> 00:28:49,140
legume is that they they have this

00:28:46,740 --> 00:28:50,820
entity that has to code and inside the

00:28:49,140 --> 00:28:53,220
entity you put three things this state

00:28:50,820 --> 00:28:56,760
which is the equivalent of your model

00:28:53,220 --> 00:28:58,230
the command and events it's one solution

00:28:56,760 --> 00:29:00,090
so you create a pipeline and have

00:28:58,230 --> 00:29:04,830
everything inside and you keep using

00:29:00,090 --> 00:29:08,580
that the the reason is that when I was

00:29:04,830 --> 00:29:10,740
building that I just found that was more

00:29:08,580 --> 00:29:12,780
I didn't thought about that solution

00:29:10,740 --> 00:29:14,880
actually to create a kind of entity and

00:29:12,780 --> 00:29:17,790
let people define the type members

00:29:14,880 --> 00:29:20,130
inside I did like well that's my model

00:29:17,790 --> 00:29:22,470
and I need to bring back the commands

00:29:20,130 --> 00:29:25,740
and events inside it somehow that's just

00:29:22,470 --> 00:29:28,830
the path that I took and actually that's

00:29:25,740 --> 00:29:31,530
that's basically historical and but I do

00:29:28,830 --> 00:29:33,840
like this because at the end I don't

00:29:31,530 --> 00:29:36,360
need to have another kind of concept

00:29:33,840 --> 00:29:37,950
it's just I have an order the commands

00:29:36,360 --> 00:29:40,050
and the event that goes to the order

00:29:37,950 --> 00:29:41,760
with the others what I need to have is

00:29:40,050 --> 00:29:44,160
the types that I have to implement to

00:29:41,760 --> 00:29:50,250
glue them together is that it had

00:29:44,160 --> 00:29:53,250
another question okay okay so the thing

00:29:50,250 --> 00:29:56,340
now is that I have these types in my

00:29:53,250 --> 00:29:59,040
companion object and I from the API

00:29:56,340 --> 00:30:02,720
point of view I have to ask users to all

00:29:59,040 --> 00:30:07,920
don't forget to put it in scope because

00:30:02,720 --> 00:30:10,170
to offer that same kind of look and feel

00:30:07,920 --> 00:30:13,770
let's say I don't want you to say oh I

00:30:10,170 --> 00:30:16,440
can now give me the order here give me

00:30:13,770 --> 00:30:18,960
the types I don't like it so I want

00:30:16,440 --> 00:30:22,500
people to use the API without having to

00:30:18,960 --> 00:30:24,330
think about it and and but I also don't

00:30:22,500 --> 00:30:27,600
want to force you to put something in

00:30:24,330 --> 00:30:29,730
the blister scope and the thing is just

00:30:27,600 --> 00:30:32,790
to explain what's the path dependent

00:30:29,730 --> 00:30:34,380
types does before I go to the to the

00:30:32,790 --> 00:30:37,910
trick that solves that problem

00:30:34,380 --> 00:30:41,160
of the increased scope is that now I'm

00:30:37,910 --> 00:30:45,299
accepting the pronouns and events but

00:30:41,160 --> 00:30:46,590
using the instance of my types now

00:30:45,299 --> 00:30:49,110
that's the difference by path-dependent

00:30:46,590 --> 00:30:51,179
types because type projects you go from

00:30:49,110 --> 00:30:53,820
one type and it navigates to another one

00:30:51,179 --> 00:30:56,429
and path dependent types you go from one

00:30:53,820 --> 00:30:58,890
value something that you have a value

00:30:56,429 --> 00:31:01,230
and you go to a type so it's like a

00:30:58,890 --> 00:31:02,880
bridge between value level programming

00:31:01,230 --> 00:31:05,820
to type level programming you go from

00:31:02,880 --> 00:31:09,000
value to type and so you need to have an

00:31:05,820 --> 00:31:11,280
instance and in our case here that's not

00:31:09,000 --> 00:31:14,039
something that I need to initialize when

00:31:11,280 --> 00:31:15,870
I need I just put it on a companion

00:31:14,039 --> 00:31:18,750
object and it's a single tone and it

00:31:15,870 --> 00:31:20,940
will always be there so I navigate from

00:31:18,750 --> 00:31:23,640
my companion objects to the types from

00:31:20,940 --> 00:31:27,960
the instance to the types that's what we

00:31:23,640 --> 00:31:33,000
do here and then I get all everything

00:31:27,960 --> 00:31:35,280
well well type it now how I solve the

00:31:33,000 --> 00:31:39,870
fact that I need something my implicitly

00:31:35,280 --> 00:31:44,130
scope and I was very happy to was that

00:31:39,870 --> 00:31:48,690
little trick here you can define in the

00:31:44,130 --> 00:31:52,020
trade a met a death that put itself in

00:31:48,690 --> 00:31:54,120
the in place the scope and the fact that

00:31:52,020 --> 00:31:59,010
we are putting that on the you don't

00:31:54,120 --> 00:32:00,840
have to put it on your companion object

00:31:59,010 --> 00:32:03,419
but it's the best place to put it

00:32:00,840 --> 00:32:04,710
because when I have to resolve when the

00:32:03,419 --> 00:32:07,020
compiler will try to resolve the

00:32:04,710 --> 00:32:09,330
implicit scope the the scope for that in

00:32:07,020 --> 00:32:10,799
place to first look on the I don't know

00:32:09,330 --> 00:32:13,260
if it be the first place but it will

00:32:10,799 --> 00:32:15,179
look on the companion object of the type

00:32:13,260 --> 00:32:16,980
that we are giving so we to find it

00:32:15,179 --> 00:32:20,010
there and there are two tricks in the

00:32:16,980 --> 00:32:22,860
beginning was not working the first one

00:32:20,010 --> 00:32:25,770
I knew and well I didn't make that

00:32:22,860 --> 00:32:28,260
mistake but if I got some someone asked

00:32:25,770 --> 00:32:30,570
me why you did that adapt not a vowel is

00:32:28,260 --> 00:32:31,860
because if I do a vowel here and because

00:32:30,570 --> 00:32:35,120
it's returning itself

00:32:31,860 --> 00:32:39,230
I have initialization errors it will

00:32:35,120 --> 00:32:45,080
slam you in the face the other one is

00:32:39,230 --> 00:32:47,570
that one here oops we need

00:32:45,080 --> 00:32:51,070
if I say that's the one that I put in

00:32:47,570 --> 00:32:54,350
the places scope that won't work so

00:32:51,070 --> 00:32:58,220
types okay that won't work

00:32:54,350 --> 00:33:00,289
so what we need is to put the type that

00:32:58,220 --> 00:33:03,830
I don't know yet but will be the type of

00:33:00,289 --> 00:33:06,080
ones that trade is implemented so is

00:33:03,830 --> 00:33:08,149
this type that I have to put on the

00:33:06,080 --> 00:33:11,980
implicit is code and that little trick

00:33:08,149 --> 00:33:14,419
and I hope that it's not one of those

00:33:11,980 --> 00:33:15,799
unknown future in scale that one day

00:33:14,419 --> 00:33:19,570
there's a rule that should not happen

00:33:15,799 --> 00:33:19,570
because of that debt and they remove it

00:33:19,720 --> 00:33:25,129
so but now it's releasing a conference

00:33:22,789 --> 00:33:27,080
so they cannot remove it okay even if

00:33:25,129 --> 00:33:29,059
it's only my lighter well I don't think

00:33:27,080 --> 00:33:31,429
it's like that but I was surprised that

00:33:29,059 --> 00:33:35,179
was really happy as well I got the

00:33:31,429 --> 00:33:38,269
solution because now I can go for path

00:33:35,179 --> 00:33:41,029
dependent types and and as long as you

00:33:38,269 --> 00:33:44,980
implement types in your companion object

00:33:41,029 --> 00:33:44,980
you get that increased for free and

00:33:45,249 --> 00:33:52,759
there we go we got it and just to give

00:33:50,720 --> 00:33:57,619
more or less the idea of how it looks

00:33:52,759 --> 00:34:00,859
like at the end is so I I could I glue

00:33:57,619 --> 00:34:05,809
my types using the types using tablet

00:34:00,859 --> 00:34:10,040
pen types I bring them together when I

00:34:05,809 --> 00:34:14,089
define my behavior and I try to have a

00:34:10,040 --> 00:34:17,299
DSL kind of stuff that is very clear

00:34:14,089 --> 00:34:25,250
first I create using those actions and

00:34:17,299 --> 00:34:29,299
then I I update and very much like in

00:34:25,250 --> 00:34:33,589
akka any resemblance with arc is mere

00:34:29,299 --> 00:34:36,710
coincidence okay I can send commands to

00:34:33,589 --> 00:34:39,169
it well why why it's like that why why

00:34:36,710 --> 00:34:40,599
it looks like occurred well because my

00:34:39,169 --> 00:34:43,819
first implementation was akka

00:34:40,599 --> 00:34:45,589
when we start doing secure else I was

00:34:43,819 --> 00:34:48,500
working the Flemish government in

00:34:45,589 --> 00:34:52,609
Belgium and the first thing that we had

00:34:48,500 --> 00:34:56,240
in mind it was we don't want to code our

00:34:52,609 --> 00:34:58,550
aggregate inside as an actor we found

00:34:56,240 --> 00:35:01,640
that was the too powerful distraction

00:34:58,550 --> 00:35:04,970
for what we were doing and and we said

00:35:01,640 --> 00:35:07,790
if we define the functions that we need

00:35:04,970 --> 00:35:10,940
then we can have something that we can

00:35:07,790 --> 00:35:13,340
code in code and say now I take that and

00:35:10,940 --> 00:35:15,740
I make it work inside an actor if I want

00:35:13,340 --> 00:35:18,440
because the semantics are very similar

00:35:15,740 --> 00:35:22,910
send message the upper sissies persisted

00:35:18,440 --> 00:35:26,140
using akka persisted and I and I get

00:35:22,910 --> 00:35:29,060
back if I want if I do I ask I get back

00:35:26,140 --> 00:36:07,190
defense so that's why it's so similar

00:35:29,060 --> 00:36:14,270
and yes don't know yeah here wait you

00:36:07,190 --> 00:36:20,290
mean here like that I try that and I

00:36:14,270 --> 00:36:20,290
didn't like that solution because I

00:36:20,620 --> 00:36:25,760
think it's not natural if I ask a

00:36:23,510 --> 00:36:28,670
reference of something for a given type

00:36:25,760 --> 00:36:32,000
to pass an instance of something I think

00:36:28,670 --> 00:36:33,860
from more the perspective of the

00:36:32,000 --> 00:36:36,020
language is color language have

00:36:33,860 --> 00:36:37,820
something where I give a type I express

00:36:36,020 --> 00:36:40,610
it as a type I want a rain first

00:36:37,820 --> 00:36:44,900
reference for order the type origin

00:36:40,610 --> 00:36:48,590
that's more a style thing I tried and I

00:36:44,900 --> 00:36:50,990
thought I don't want parenthesis I want

00:36:48,590 --> 00:36:53,360
brackets because now I'm telling give me

00:36:50,990 --> 00:36:57,890
a reference for this type that that's

00:36:53,360 --> 00:37:00,680
that's the reason and so it's very

00:36:57,890 --> 00:37:02,480
similar to to akka because my goal was

00:37:00,680 --> 00:37:05,450
to build a table structure I could put

00:37:02,480 --> 00:37:07,310
it inside Arkin and but the outcome of

00:37:05,450 --> 00:37:10,400
that and many other things that I have

00:37:07,310 --> 00:37:12,010
been doing from cigarettes and make make

00:37:10,400 --> 00:37:17,020
sure that I have this

00:37:12,010 --> 00:37:19,960
as API was that I could abstract away

00:37:17,020 --> 00:37:22,330
the idea of annum back end and the akka

00:37:19,960 --> 00:37:23,800
back ends I have to back into the Aqua

00:37:22,330 --> 00:37:25,810
beckoned and in memory back end for

00:37:23,800 --> 00:37:29,380
testing but you could implement others

00:37:25,810 --> 00:37:33,340
they can't who was on the loot loot talk

00:37:29,380 --> 00:37:35,619
about secure s okay lots of guys I think

00:37:33,340 --> 00:37:37,990
Lutz for the real advertisement because

00:37:35,619 --> 00:37:42,030
lots of people here are coming from your

00:37:37,990 --> 00:37:46,060
talk so he mentioned event wait and

00:37:42,030 --> 00:37:47,980
actually I never tried but I'm pretty

00:37:46,060 --> 00:37:52,810
much sure that who could build an event

00:37:47,980 --> 00:37:55,150
wait backend for fun seekers and I I had

00:37:52,810 --> 00:37:58,570
plans to build a sleek back-end for fun

00:37:55,150 --> 00:38:00,700
seekers but I then I'm I I quit that

00:37:58,570 --> 00:38:02,020
project from the at the Flemish

00:38:00,700 --> 00:38:03,640
government something that today will be

00:38:02,020 --> 00:38:06,430
out there probably because they need it

00:38:03,640 --> 00:38:08,350
and and the nice thing about that is

00:38:06,430 --> 00:38:10,960
that the in-memory back-end I take the

00:38:08,350 --> 00:38:13,990
same behavior and say now I just want to

00:38:10,960 --> 00:38:16,270
test my commands a command common hands

00:38:13,990 --> 00:38:21,280
and event handlers but the complication

00:38:16,270 --> 00:38:27,430
there is that when you do that what is

00:38:21,280 --> 00:38:30,280
the return type if I do here I ask if I

00:38:27,430 --> 00:38:32,890
do here ask what is the return type of

00:38:30,280 --> 00:38:34,450
my here is not work because the simple

00:38:32,890 --> 00:38:36,790
simple application okay but in front

00:38:34,450 --> 00:38:39,609
secure is what will happen is if I got

00:38:36,790 --> 00:38:42,100
that ref from my architect hand the

00:38:39,609 --> 00:38:44,590
return time will be a future but if it's

00:38:42,100 --> 00:38:48,520
from my memory back end doesn't make any

00:38:44,590 --> 00:38:51,430
sense to have a future I don't want to

00:38:48,520 --> 00:38:53,890
force myself to deal with future for

00:38:51,430 --> 00:38:57,310
something that I'm testing running pure

00:38:53,890 --> 00:39:02,470
unit tests so I have some mechanism that

00:38:57,310 --> 00:39:04,660
will using interpreters and will instead

00:39:02,470 --> 00:39:08,410
of giving me a future will give me just

00:39:04,660 --> 00:39:11,109
the events but the thing is and that's

00:39:08,410 --> 00:39:12,970
why I believe we should write frameworks

00:39:11,109 --> 00:39:15,430
for secure as an event sourcing is

00:39:12,970 --> 00:39:18,220
because the set of operations are well

00:39:15,430 --> 00:39:21,670
define it and if you have that and think

00:39:18,220 --> 00:39:24,070
about HTTP HTTP and akka streams they

00:39:21,670 --> 00:39:25,720
are bases on top they are built on top

00:39:24,070 --> 00:39:27,910
of arca but because the set of

00:39:25,720 --> 00:39:30,310
operations are well define it well maybe

00:39:27,910 --> 00:39:32,830
not the streams are still to be well

00:39:30,310 --> 00:39:34,540
defined but HTTP is well define so you

00:39:32,830 --> 00:39:37,900
can build an abstraction that is less

00:39:34,540 --> 00:39:40,420
powerful on top of ARCA and then you

00:39:37,900 --> 00:39:42,970
offer an API to your users into yourself

00:39:40,420 --> 00:39:49,780
that only allow you to do what you need

00:39:42,970 --> 00:39:52,780
to do so I have another talk so to wrap

00:39:49,780 --> 00:39:55,510
it so in some cigarettes is available on

00:39:52,780 --> 00:39:57,190
github so if you take that talk and you

00:39:55,510 --> 00:39:59,770
want to understand how it was built you

00:39:57,190 --> 00:40:02,500
can have a look and use it the talk and

00:39:59,770 --> 00:40:04,800
slides are on reification insecure s on

00:40:02,500 --> 00:40:08,080
my strong type is the name of my company

00:40:04,800 --> 00:40:10,720
I will be talking scullers forum in

00:40:08,080 --> 00:40:12,310
Porto about the function foundations of

00:40:10,720 --> 00:40:15,460
event source applications which are

00:40:12,310 --> 00:40:19,210
actually the basis of of fun secure s

00:40:15,460 --> 00:40:22,900
and I recently blogged about that so I

00:40:19,210 --> 00:40:26,020
started a series of blog post

00:40:22,900 --> 00:40:29,890
don't don't expect to have one a week

00:40:26,020 --> 00:40:32,589
I'm much slower than that in writing

00:40:29,890 --> 00:40:37,030
blogs but the first one is about the

00:40:32,589 --> 00:40:39,520
function foundations of secure s and and

00:40:37,030 --> 00:40:41,680
also its colors form we are running a

00:40:39,520 --> 00:40:43,990
fun secure as a workshop it's only one

00:40:41,680 --> 00:40:49,330
day and it's very affordable it's 99

00:40:43,990 --> 00:40:52,660
euros and well if you have a colleague

00:40:49,330 --> 00:40:55,180
that could make Scala days or if after

00:40:52,660 --> 00:40:57,250
Scala days you're still in hungry for a

00:40:55,180 --> 00:40:58,540
nice conference I really recommend ask

00:40:57,250 --> 00:41:01,410
Alice Wong not because I'm speaking

00:40:58,540 --> 00:41:03,520
there because I know the guy that is

00:41:01,410 --> 00:41:07,750
organized that and I'm sure it'd be a

00:41:03,520 --> 00:41:09,670
wonderful conference so I think I'm done

00:41:07,750 --> 00:41:10,530
if you have questions if you have time

00:41:09,670 --> 00:41:19,480
five minutes

00:41:10,530 --> 00:41:20,020
perfect like I plan it any questions no

00:41:19,480 --> 00:41:31,510
questions

00:41:20,020 --> 00:41:35,470
tumblr hello yeah okay

00:41:31,510 --> 00:41:37,680
the question was can I have something

00:41:35,470 --> 00:41:41,740
fun secure s where I can change my

00:41:37,680 --> 00:41:45,130
behavior and to go from one state to

00:41:41,740 --> 00:41:51,450
another yes I can and actually it's not

00:41:45,130 --> 00:41:54,369
done here but I just show here back that

00:41:51,450 --> 00:41:57,250
that function here is a portion function

00:41:54,369 --> 00:42:02,220
and what I have done in other demos is

00:41:57,250 --> 00:42:05,680
that my my model is an ADT I have a demo

00:42:02,220 --> 00:42:06,250
it's a funny one that I use many times

00:42:05,680 --> 00:42:08,530
already

00:42:06,250 --> 00:42:10,960
it's a raffle so you start with a raffle

00:42:08,530 --> 00:42:13,420
and it's an empty raffle as soon as you

00:42:10,960 --> 00:42:15,700
put an apart a participant it becomes a

00:42:13,420 --> 00:42:18,970
non empty raffle and you add

00:42:15,700 --> 00:42:21,790
participants and and when you select a

00:42:18,970 --> 00:42:25,030
winner it becomes a finish raffle and a

00:42:21,790 --> 00:42:27,339
finish raffle cannot accept comments

00:42:25,030 --> 00:42:28,869
anymore you cannot remove a participant

00:42:27,339 --> 00:42:32,650
you cannot run it again and select

00:42:28,869 --> 00:42:35,290
another winner so what happens is and on

00:42:32,650 --> 00:42:37,300
that piece here you say okay if it's

00:42:35,290 --> 00:42:42,280
older let's say that we have something

00:42:37,300 --> 00:42:44,740
like if it's order empty order I can do

00:42:42,280 --> 00:42:50,560
the actions like add an item and so on

00:42:44,740 --> 00:42:55,930
if is that an order pay it something

00:42:50,560 --> 00:42:58,330
like that then I can not add items I

00:42:55,930 --> 00:43:01,960
cannot cancel because it's its end of

00:42:58,330 --> 00:43:05,740
life so that's that that that part here

00:43:01,960 --> 00:43:10,290
we allow you to of I didn't sorry it's

00:43:05,740 --> 00:43:10,290
not but I figure you guys got

00:43:26,370 --> 00:43:32,370
it disturbed me if it's not compare I

00:43:28,260 --> 00:43:35,940
cannot continue to talk if it's red yeah

00:43:32,370 --> 00:43:39,810
like you know you guys are developers no

00:43:35,940 --> 00:43:43,980
well you understand us now so what you

00:43:39,810 --> 00:43:45,660
pass here that very much simpler example

00:43:43,980 --> 00:43:49,320
but it's a partial function so you can

00:43:45,660 --> 00:43:51,450
you can switch from behavior because the

00:43:49,320 --> 00:43:53,900
actions are actually what will be use it

00:43:51,450 --> 00:43:56,700
in the receive method of your actor or

00:43:53,900 --> 00:44:00,210
to whatever that can you have yes so

00:43:56,700 --> 00:44:02,250
that's how we don't it's done I know the

00:44:00,210 --> 00:44:04,410
question yeah over here I'm right okay

00:44:02,250 --> 00:44:06,660
I noticed you have a one-to-one

00:44:04,410 --> 00:44:09,450
relationship between command and events

00:44:06,660 --> 00:44:12,390
is the reason for that because one

00:44:09,450 --> 00:44:14,400
command could potentially generate five

00:44:12,390 --> 00:44:15,180
events and five commands could generate

00:44:14,400 --> 00:44:16,920
one events

00:44:15,180 --> 00:44:23,010
yeah I'm tracking something over time

00:44:16,920 --> 00:44:25,770
yeah yeah I I tried that so I before

00:44:23,010 --> 00:44:28,260
reaching that API try many others if you

00:44:25,770 --> 00:44:30,680
go to the github infront cigarettes

00:44:28,260 --> 00:44:33,270
withdraw you see all these experimenting

00:44:30,680 --> 00:44:37,680
experimentations IDs and one that I that

00:44:33,270 --> 00:44:39,570
I have done is once you add a commands

00:44:37,680 --> 00:44:42,720
and I say that command gives me back

00:44:39,570 --> 00:44:46,050
that event you had you head to the

00:44:42,720 --> 00:44:48,780
declare event handler for that so I was

00:44:46,050 --> 00:44:51,420
trying to force you if you tell me that

00:44:48,780 --> 00:44:56,760
you omit that event you have to teach me

00:44:51,420 --> 00:44:58,470
how to handle that and of course there

00:44:56,760 --> 00:45:01,520
are situations where two different

00:44:58,470 --> 00:45:03,810
commands may emit the same event and

00:45:01,520 --> 00:45:06,630
that's why I give up from that idea

00:45:03,810 --> 00:45:11,520
because then you create a common handler

00:45:06,630 --> 00:45:13,800
and say I will send you a item added so

00:45:11,520 --> 00:45:15,720
I force you to put a dead handle for

00:45:13,800 --> 00:45:18,630
that and then you give me another kind

00:45:15,720 --> 00:45:21,210
of command that will also emit that

00:45:18,630 --> 00:45:23,310
event and it happens depending on the

00:45:21,210 --> 00:45:26,070
your model and now I have to force you

00:45:23,310 --> 00:45:29,790
again to implement the event handler I

00:45:26,070 --> 00:45:32,550
said that's not a good API so but to

00:45:29,790 --> 00:45:35,820
answer your question yes a command same

00:45:32,550 --> 00:45:38,790
the same as a given event can be emitted

00:45:35,820 --> 00:45:39,750
by different commands and a command can

00:45:38,790 --> 00:45:42,930
meet

00:45:39,750 --> 00:45:46,500
more than one event and one of those

00:45:42,930 --> 00:45:50,160
events can be emitted by if you have a

00:45:46,500 --> 00:45:53,880
list of events for instance I don't have

00:45:50,160 --> 00:46:05,160
that here but imagine if I create here

00:45:53,880 --> 00:46:12,480
command handle that does that but he is

00:46:05,160 --> 00:46:15,180
on the creation part of it but it's

00:46:12,480 --> 00:46:18,330
possible at creation time to send a

00:46:15,180 --> 00:46:20,640
command that is creating your library

00:46:18,330 --> 00:46:25,260
your model for the first time but what I

00:46:20,640 --> 00:46:34,470
have to do here is I have to omit a list

00:46:25,260 --> 00:46:37,610
of events oops my first event has to be

00:46:34,470 --> 00:46:41,340
create and the other one item was added

00:46:37,610 --> 00:46:42,750
and the thing is the API all those

00:46:41,340 --> 00:46:44,640
things when you start to think oh no

00:46:42,750 --> 00:46:46,380
that will never happen and I did like

00:46:44,640 --> 00:46:48,630
that it was impossible to do such a

00:46:46,380 --> 00:46:49,830
thing in the beginning but then as soon

00:46:48,630 --> 00:46:52,110
as you start to develop many

00:46:49,830 --> 00:46:54,900
applications as well now I need that so

00:46:52,110 --> 00:46:58,620
I was changed my my API to be able to

00:46:54,900 --> 00:47:03,600
provide that does it answer your

00:46:58,620 --> 00:47:07,100
question yeah okay thank you another

00:47:03,600 --> 00:47:07,100
question here's a

00:47:11,140 --> 00:47:17,680
hi thanks for the thought I was

00:47:14,230 --> 00:47:24,190
wondering how you handle transitions

00:47:17,680 --> 00:47:29,349
between or between states or like the

00:47:24,190 --> 00:47:33,009
sequence of valid events like I'm what

00:47:29,349 --> 00:47:35,710
I'm thinking because you have partial

00:47:33,009 --> 00:47:37,450
functions like how do you how do you

00:47:35,710 --> 00:47:40,299
know that someone doesn't try to apply

00:47:37,450 --> 00:47:44,440
an event yeah where you camp

00:47:40,299 --> 00:47:47,289
yeah well the the back end to take care

00:47:44,440 --> 00:47:49,960
of that what it does is okay you send a

00:47:47,289 --> 00:47:54,099
command you give me a common hand that

00:47:49,960 --> 00:47:57,009
we were meet an event I think you're

00:47:54,099 --> 00:47:59,859
finished okay you answer this and maybe

00:47:57,009 --> 00:48:04,749
it's the last one so what what I have

00:47:59,859 --> 00:48:07,329
done is I because I've controlled the

00:48:04,749 --> 00:48:10,269
state in my back end what I do is I

00:48:07,329 --> 00:48:12,670
apply a command I take your events and I

00:48:10,269 --> 00:48:15,789
try to apply the events already before I

00:48:12,670 --> 00:48:18,460
persist and if I cannot find an event

00:48:15,789 --> 00:48:20,829
handler for it then I will reject your

00:48:18,460 --> 00:48:22,960
event before it your command before you

00:48:20,829 --> 00:48:26,200
I persist your events and then you get

00:48:22,960 --> 00:48:27,849
at run time the notifications as well

00:48:26,200 --> 00:48:32,019
that didn't have because I cannot apply

00:48:27,849 --> 00:48:33,940
that in those events so I avoid you to

00:48:32,019 --> 00:48:35,680
persist events that you cannot handle

00:48:33,940 --> 00:48:39,009
because if you do that you'll break your

00:48:35,680 --> 00:48:41,109
actor completely so have you considered

00:48:39,009 --> 00:48:46,119
doing this on the type level and so no

00:48:41,109 --> 00:48:49,450
no I didn't I fault I I well I well I

00:48:46,119 --> 00:48:53,249
thought about that but I got the feeling

00:48:49,450 --> 00:48:56,230
that I would add a lot lots of API and

00:48:53,249 --> 00:48:59,920
friction and lots of things that I had

00:48:56,230 --> 00:49:03,160
to to achieve to add up in order to do

00:48:59,920 --> 00:49:05,499
that and I thought that that's I didn't

00:49:03,160 --> 00:49:08,829
want to do that I thought it was a case

00:49:05,499 --> 00:49:12,849
that was okay to have in that case run

00:49:08,829 --> 00:49:16,119
times it errors and the thing is also if

00:49:12,849 --> 00:49:18,849
you if you send a commands that you

00:49:16,119 --> 00:49:21,789
forgot to add the computer the commander

00:49:18,849 --> 00:49:23,890
handle for each or I say I show that you

00:49:21,789 --> 00:49:24,700
have you can do a state machine and go

00:49:23,890 --> 00:49:27,099
to a state that

00:49:24,700 --> 00:49:28,930
maybe cannot handle that command I have

00:49:27,099 --> 00:49:31,540
the means to detect that assay or that

00:49:28,930 --> 00:49:35,619
command for that current behavior state

00:49:31,540 --> 00:49:38,950
is not possible but it should be posed

00:49:35,619 --> 00:49:41,380
to do that a type level but I thought it

00:49:38,950 --> 00:49:45,280
was not something that would be that

00:49:41,380 --> 00:49:48,849
useful for fun CQRS okay I'm open for

00:49:45,280 --> 00:49:52,230
experiments and pull requests guys I

00:49:48,849 --> 00:49:52,230
think I would have to thank you

00:49:52,540 --> 00:49:55,739

YouTube URL: https://www.youtube.com/watch?v=qwYs0J7xp78


