Title: The best is yet to come - State of Akka in 2017 by Konrad Malawski
Publication date: 2017-06-14
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
The last years have brought Akka the largest changes since the initial 2.x rewrite yet it remained fully compatible across the last years. With the new exciting modules like Akka Streams, Akka HTTP (including the most recent HTTP/2 work) and the new remoting reimplementation codenamed Artery, we've stepped into the era of Akka 2.5 already. Which again, remains backwards compatible as previous releases. What's in there, and what's next for Akka in general?

In this talk we'll take a brief look back at the newest stable modules of Akka itself, as well as new projects such as Alpakka. Next, we'll continue with the (then present) 2.5 version and the stable Persistence Query, high-availability CRDT support in Distributed Data and continued work on the Artery remoting. Finally we'll have a sneak peek at what's coming in the next releases, which among other things include Akka Typed and more!
Captions: 
	00:00:00,030 --> 00:00:06,150
so the talk is not a super strict

00:00:03,929 --> 00:00:11,840
roadmap so don't believe anything I say

00:00:06,150 --> 00:00:13,980
basically it is however a rough idea and

00:00:11,840 --> 00:00:15,929
explanation how all the things fit

00:00:13,980 --> 00:00:18,660
together so we will actually start in

00:00:15,929 --> 00:00:21,539
the past before we go to okay what the

00:00:18,660 --> 00:00:24,990
future holds so I just wanted to

00:00:21,539 --> 00:00:27,900
underline not strict outline for future

00:00:24,990 --> 00:00:29,039
development so my name is Connor

00:00:27,900 --> 00:00:32,850
malarkey

00:00:29,039 --> 00:00:35,370
ah so also online and the vet nickname I

00:00:32,850 --> 00:00:37,430
do a bunch of community stuff in Poland

00:00:35,370 --> 00:00:40,559
but actually moved to talk to you now

00:00:37,430 --> 00:00:42,510
enough about me akka obviously used in

00:00:40,559 --> 00:00:46,289
many places and here's the question to

00:00:42,510 --> 00:00:49,940
you guys and people who is using akka

00:00:46,289 --> 00:00:52,770
and Jesus everyone so you came here to

00:00:49,940 --> 00:00:55,530
to see what's what's next up right I

00:00:52,770 --> 00:00:57,899
hope is going to be the right talk for

00:00:55,530 --> 00:01:01,350
you this also means that I'm going to

00:00:57,899 --> 00:01:03,570
skip over some of like basics if

00:01:01,350 --> 00:01:05,519
everyone almost everyone raised her hand

00:01:03,570 --> 00:01:08,909
but they actually use our car let's just

00:01:05,519 --> 00:01:11,250
skip over it so the underlying motto of

00:01:08,909 --> 00:01:13,110
it's not like an official motto of a

00:01:11,250 --> 00:01:15,780
team or anything but really it's

00:01:13,110 --> 00:01:19,920
something I at least have in the back of

00:01:15,780 --> 00:01:22,049
my head when we design new stuff it's ok

00:01:19,920 --> 00:01:22,950
versum status quo and how can we do

00:01:22,049 --> 00:01:25,200
better than that

00:01:22,950 --> 00:01:28,140
whatever the status quo already is and

00:01:25,200 --> 00:01:30,420
another one that's very recently popping

00:01:28,140 --> 00:01:32,430
a lot into my mind at least when we see

00:01:30,420 --> 00:01:35,310
like over tours of frameworks or

00:01:32,430 --> 00:01:38,369
libraries do some stuff it's yeah we've

00:01:35,310 --> 00:01:40,590
been third we done that doesn't work so

00:01:38,369 --> 00:01:43,229
there's a lot of things that we learned

00:01:40,590 --> 00:01:45,360
the hard way and but also a lot of

00:01:43,229 --> 00:01:48,270
things with we probably will learn the

00:01:45,360 --> 00:01:50,909
hard way in the future so it's it's a

00:01:48,270 --> 00:01:53,130
talk about a mini journey like work I've

00:01:50,909 --> 00:01:55,740
came from and where it's heading like I

00:01:53,130 --> 00:01:57,930
said the past let's cover kind of

00:01:55,740 --> 00:02:01,100
quickly because we want to focus on the

00:01:57,930 --> 00:02:03,780
new stuff but it's important for context

00:02:01,100 --> 00:02:07,020
so we start out at the mountain of occur

00:02:03,780 --> 00:02:09,030
as you know first release around 2009

00:02:07,020 --> 00:02:10,090
was mostly owners working on the

00:02:09,030 --> 00:02:14,020
background

00:02:10,090 --> 00:02:15,700
his akka actor colonel back then and you

00:02:14,020 --> 00:02:17,520
can see all the buzz words in the like

00:02:15,700 --> 00:02:19,810
subtitle like rest for distributed

00:02:17,520 --> 00:02:22,510
persistent transactional actors all of

00:02:19,810 --> 00:02:25,510
the buzz words right obviously to get

00:02:22,510 --> 00:02:27,730
some attraction gotta heifers but the

00:02:25,510 --> 00:02:32,050
core of alka was always and still is

00:02:27,730 --> 00:02:33,940
actor model and actors who of here

00:02:32,050 --> 00:02:35,200
present people was in Rowland's talk

00:02:33,940 --> 00:02:37,660
just before this one

00:02:35,200 --> 00:02:40,000
some of you okay so I'm not going to

00:02:37,660 --> 00:02:43,000
have much overlap because this is more

00:02:40,000 --> 00:02:44,970
like we will mention typed but it's not

00:02:43,000 --> 00:02:47,980
like we will learn typed in this talk so

00:02:44,970 --> 00:02:50,860
the core of actors is always useful

00:02:47,980 --> 00:02:53,049
operation bacon send messages they can

00:02:50,860 --> 00:02:55,180
change your state so not got hyped with

00:02:53,049 --> 00:02:57,160
basically becoming a new behavior it's a

00:02:55,180 --> 00:02:59,530
very nicely modeled here I think in

00:02:57,160 --> 00:03:01,390
archetypes were actually much closer to

00:02:59,530 --> 00:03:04,420
original to be original definition when

00:03:01,390 --> 00:03:07,150
we are in untyped actors because an

00:03:04,420 --> 00:03:08,650
untyped actors becoming is like an extra

00:03:07,150 --> 00:03:10,690
feature right you have this method on

00:03:08,650 --> 00:03:14,980
context and you can sometimes maybe do

00:03:10,690 --> 00:03:16,780
it in typed it's really a native feeling

00:03:14,980 --> 00:03:19,180
thing that you over time become a new

00:03:16,780 --> 00:03:21,910
behavior so we're a bit closer to the

00:03:19,180 --> 00:03:25,269
origin in the new API actually and

00:03:21,910 --> 00:03:27,280
obviously you can create over actors so

00:03:25,269 --> 00:03:30,459
a concurrency in the distribution and

00:03:27,280 --> 00:03:32,170
construct but most importantly it's a

00:03:30,459 --> 00:03:34,690
distribution abstraction right it's

00:03:32,170 --> 00:03:37,150
mothers distribution sometimes people

00:03:34,690 --> 00:03:37,569
use actors only for a concurrency aspect

00:03:37,150 --> 00:03:40,299
of it

00:03:37,569 --> 00:03:42,910
what's perfectly fine but it's important

00:03:40,299 --> 00:03:45,220
to remember that they do a bit more than

00:03:42,910 --> 00:03:47,680
that right if you use actors you can go

00:03:45,220 --> 00:03:48,910
distribute it with them very easily and

00:03:47,680 --> 00:03:52,060
it feels right

00:03:48,910 --> 00:03:54,609
whereas with you and try to use some RPC

00:03:52,060 --> 00:03:56,709
systems they go the other way right they

00:03:54,609 --> 00:03:59,019
try to make the distributed thing look

00:03:56,709 --> 00:04:01,329
like a local thing and it doesn't always

00:03:59,019 --> 00:04:03,519
match right because the network and then

00:04:01,329 --> 00:04:05,650
the core index latency it can fail in

00:04:03,519 --> 00:04:08,170
different ways what we have is we always

00:04:05,650 --> 00:04:11,319
have messaging and making that

00:04:08,170 --> 00:04:13,209
distributed feels more correct in that

00:04:11,319 --> 00:04:16,209
sense and the only failure mode in

00:04:13,209 --> 00:04:19,980
actress is really not getting a message

00:04:16,209 --> 00:04:21,870
in that sense okay

00:04:19,980 --> 00:04:24,900
if anyone has not ever seen an actor

00:04:21,870 --> 00:04:28,380
here's an actor if anyone has not seen

00:04:24,900 --> 00:04:31,050
the new Java DSL anyone cares about a

00:04:28,380 --> 00:04:33,090
java deus in this audience some people I

00:04:31,050 --> 00:04:35,460
would like to actually underline that we

00:04:33,090 --> 00:04:37,800
do spend a lot of time on it sometimes

00:04:35,460 --> 00:04:39,690
people think that yeah it's just they

00:04:37,800 --> 00:04:41,700
did it in one day and they don't care

00:04:39,690 --> 00:04:44,430
about it we spent a lot of time on

00:04:41,700 --> 00:04:46,800
making all of apos make a Java dear sir

00:04:44,430 --> 00:04:48,720
all of the contributions also has to

00:04:46,800 --> 00:04:52,140
have a java DSL which fico here is not

00:04:48,720 --> 00:04:56,330
happy about but everything in our car

00:04:52,140 --> 00:04:58,530
has a properly nice feeling Java DSN so

00:04:56,330 --> 00:05:01,410
totally first-class citizen in that

00:04:58,530 --> 00:05:03,600
sense so okay obviously you can do like

00:05:01,410 --> 00:05:07,230
a request reply thing but that's not the

00:05:03,600 --> 00:05:09,060
interesting thing and that's just when I

00:05:07,230 --> 00:05:11,100
was doing the slides inter announced for

00:05:09,060 --> 00:05:14,640
many course processors I was really

00:05:11,100 --> 00:05:17,790
excited but the more exciting things

00:05:14,640 --> 00:05:19,830
that we are not bound to over time doing

00:05:17,790 --> 00:05:21,840
request reply we can do like requests

00:05:19,830 --> 00:05:23,370
and please tell the other guy about

00:05:21,840 --> 00:05:25,590
something all right so we have more

00:05:23,370 --> 00:05:28,370
interesting into communication patterns

00:05:25,590 --> 00:05:34,200
than just requests to reply all the time

00:05:28,370 --> 00:05:35,520
and another thing that I did want to put

00:05:34,200 --> 00:05:39,270
it in the talk because people sometimes

00:05:35,520 --> 00:05:42,900
forget is that one of the reasons and

00:05:39,270 --> 00:05:45,240
also differences between what I call the

00:05:42,900 --> 00:05:47,400
outside world and the inside word is if

00:05:45,240 --> 00:05:49,890
you control your environment as you in

00:05:47,400 --> 00:05:51,840
an echo trustor do you can do some kind

00:05:49,890 --> 00:05:55,410
of different trade-offs and such a trade

00:05:51,840 --> 00:05:58,260
of it for example when you have a Web

00:05:55,410 --> 00:06:01,800
API it's usually going to be HTTP with

00:05:58,260 --> 00:06:04,140
JSON or XML right if you internally like

00:06:01,800 --> 00:06:06,780
use Ector messaging and you're in a more

00:06:04,140 --> 00:06:10,550
confined and controlled environment and

00:06:06,780 --> 00:06:13,080
you don't have to do the JSON over HTTP

00:06:10,550 --> 00:06:17,490
why do I talk about that because

00:06:13,080 --> 00:06:19,920
performance wise these are big

00:06:17,490 --> 00:06:22,290
nanoseconds nanoseconds fat how fast you

00:06:19,920 --> 00:06:25,620
can serialize a message using proto

00:06:22,290 --> 00:06:27,480
stuff or protobuf okay just get a rough

00:06:25,620 --> 00:06:29,280
idea you don't see all of these slides

00:06:27,480 --> 00:06:31,410
we have a lot of them don't attempt to

00:06:29,280 --> 00:06:33,139
read all of it but rough idea okay few

00:06:31,410 --> 00:06:35,840
thousand 100

00:06:33,139 --> 00:06:38,419
seconds then a few other serialization

00:06:35,840 --> 00:06:41,719
engines now comparable a bit bigger in

00:06:38,419 --> 00:06:44,529
size but still comparable and this is

00:06:41,719 --> 00:06:48,229
the default what people use right Jason

00:06:44,529 --> 00:06:50,599
bad facilitation times with the size and

00:06:48,229 --> 00:06:51,409
that's the Java serialization which is

00:06:50,599 --> 00:06:54,229
the default on

00:06:51,409 --> 00:06:56,539
so you notice and that's again something

00:06:54,229 --> 00:06:58,909
in the future that we have started

00:06:56,539 --> 00:07:01,009
issuing warnings if you use Java

00:06:58,909 --> 00:07:03,110
civilization so that's like a current

00:07:01,009 --> 00:07:05,960
thing and in the future we'd really like

00:07:03,110 --> 00:07:09,229
to move towards actually not having it

00:07:05,960 --> 00:07:11,479
because what people do is they see okay

00:07:09,229 --> 00:07:13,340
it works because by default service

00:07:11,479 --> 00:07:15,949
civilization is on you can pass your

00:07:13,340 --> 00:07:18,169
messages on to the network and it works

00:07:15,949 --> 00:07:20,419
and when it goes to production and then

00:07:18,169 --> 00:07:26,750
at some point where is a complaint oh my

00:07:20,419 --> 00:07:31,099
god but it's slow I wonder why I don't

00:07:26,750 --> 00:07:33,889
mean to be not nice it's just the truth

00:07:31,099 --> 00:07:36,560
so here's how the serialized akka

00:07:33,889 --> 00:07:38,629
message could look like an order at

00:07:36,560 --> 00:07:41,719
order message Java series in Java

00:07:38,629 --> 00:07:43,389
serialized dashes are just some binary

00:07:41,719 --> 00:07:47,599
that's not printable

00:07:43,389 --> 00:07:52,310
so even XML is smaller than that second

00:07:47,599 --> 00:07:53,960
think about that XML is smaller than

00:07:52,310 --> 00:07:55,520
Java civilization obviously because

00:07:53,960 --> 00:07:58,189
excimer doesn't carry the typing

00:07:55,520 --> 00:08:00,469
information etc but yeah that's one of

00:07:58,189 --> 00:08:01,729
the reasons the Java one is no Jason a

00:08:00,469 --> 00:08:04,460
bit smaller doesn't really matter that

00:08:01,729 --> 00:08:06,560
much and with binary format you can get

00:08:04,460 --> 00:08:09,080
way smaller an interesting thing to

00:08:06,560 --> 00:08:11,330
remember some formats actually do carry

00:08:09,080 --> 00:08:13,580
along for extra type information like

00:08:11,330 --> 00:08:15,589
triode us here and some formats

00:08:13,580 --> 00:08:17,089
completely don't like Prada buff doesn't

00:08:15,589 --> 00:08:19,909
carry any type information it just

00:08:17,089 --> 00:08:25,279
carries around a number this feared is

00:08:19,909 --> 00:08:26,930
this numbered co2 in the message so we

00:08:25,279 --> 00:08:29,839
internally use protocol buffers and

00:08:26,930 --> 00:08:33,409
that's again in the future we'd like to

00:08:29,839 --> 00:08:36,310
enable this by default that we would

00:08:33,409 --> 00:08:41,539
like to not allow Java civilization

00:08:36,310 --> 00:08:44,420
currently most of akka doesn't use Java

00:08:41,539 --> 00:08:46,699
civilization sadly we had a few things

00:08:44,420 --> 00:08:49,790
that still do mostly remote deployment

00:08:46,699 --> 00:08:52,490
which we would like to remove anyway so

00:08:49,790 --> 00:08:54,470
if you for example you're in your system

00:08:52,490 --> 00:08:56,690
you know you're using try or something

00:08:54,470 --> 00:09:00,440
when you can enable this flag which will

00:08:56,690 --> 00:09:02,000
make the akka things that still use

00:09:00,440 --> 00:09:04,250
Javas utilization for compatibility

00:09:02,000 --> 00:09:06,230
reasons with old versions if you set

00:09:04,250 --> 00:09:08,269
this flag we switch to everything to

00:09:06,230 --> 00:09:10,250
protocol buffers so also good for

00:09:08,269 --> 00:09:12,769
security at first a lot of attacks on

00:09:10,250 --> 00:09:14,300
Java civilization it's also a security

00:09:12,769 --> 00:09:18,410
thing how much configuration is that

00:09:14,300 --> 00:09:20,930
just that so not much as I said slides

00:09:18,410 --> 00:09:24,260
are north not for reading because we

00:09:20,930 --> 00:09:27,410
have a lot of them looks like literally

00:09:24,260 --> 00:09:30,079
a lot so side note binary compatibility

00:09:27,410 --> 00:09:32,120
anyone not know about the new important

00:09:30,079 --> 00:09:37,100
binary compatibility rules we have a

00:09:32,120 --> 00:09:40,459
knocko it's it's relatively new right so

00:09:37,100 --> 00:09:42,890
quick quick like explanation it used to

00:09:40,459 --> 00:09:44,810
be that two two two two three would be

00:09:42,890 --> 00:09:46,490
breaking changes right that's kind of

00:09:44,810 --> 00:09:49,010
what's called us right the two is like

00:09:46,490 --> 00:09:51,890
forever its epoch and then major so

00:09:49,010 --> 00:09:55,430
since two three we actually do the

00:09:51,890 --> 00:09:58,250
normal major minor patch versioning

00:09:55,430 --> 00:10:00,290
right so that means that two free was

00:09:58,250 --> 00:10:02,149
actually binary compatibility binary

00:10:00,290 --> 00:10:04,790
compatible with four to four line and

00:10:02,149 --> 00:10:07,189
all of a purge versions and all of two

00:10:04,790 --> 00:10:09,649
for all over to four releases are active

00:10:07,189 --> 00:10:11,420
compatible with four to five release so

00:10:09,649 --> 00:10:13,189
for example if you're using our HTTP

00:10:11,420 --> 00:10:15,199
right now it still depends on to four

00:10:13,189 --> 00:10:18,560
and that's because we don't want to use

00:10:15,199 --> 00:10:20,630
features from to five accidentally but

00:10:18,560 --> 00:10:23,089
you can just set for version 2 to 5 and

00:10:20,630 --> 00:10:24,529
it will just work right so some things

00:10:23,089 --> 00:10:28,970
to remember about the version

00:10:24,529 --> 00:10:31,519
compatibility verb and eventually there

00:10:28,970 --> 00:10:35,750
will be a freedo but so far we don't

00:10:31,519 --> 00:10:37,610
really see a reason to call one it would

00:10:35,750 --> 00:10:39,709
be like big changes when for example we

00:10:37,610 --> 00:10:41,930
make everything archetypes and untyped

00:10:39,709 --> 00:10:44,870
is not a thing anymore like a read a big

00:10:41,930 --> 00:10:46,970
thing but for that to happen you know

00:10:44,870 --> 00:10:50,480
many years and everybody would have to

00:10:46,970 --> 00:10:52,640
have adopted archetypes for example so

00:10:50,480 --> 00:10:55,250
so far no plans for a Caffery because we

00:10:52,640 --> 00:10:56,440
can just continue with actual compatible

00:10:55,250 --> 00:10:59,480
time

00:10:56,440 --> 00:11:01,310
and it's not binary company it's not

00:10:59,480 --> 00:11:06,050
wire compatibility and we'll get to that

00:11:01,310 --> 00:11:07,730
soon so quick sidestep so for those of

00:11:06,050 --> 00:11:09,170
you who remember there was a time where

00:11:07,730 --> 00:11:11,510
everyone had their own future

00:11:09,170 --> 00:11:14,540
implementation including acha of course

00:11:11,510 --> 00:11:17,690
and the most notable ones were I guess

00:11:14,540 --> 00:11:21,050
in lived at Gallaudet and finagle and

00:11:17,690 --> 00:11:23,920
akka and there was a sip and now Scala

00:11:21,050 --> 00:11:27,140
has the futures we know and love and

00:11:23,920 --> 00:11:29,750
only calling this out to talk about the

00:11:27,140 --> 00:11:31,820
next point so okay we had futures and

00:11:29,750 --> 00:11:35,810
what people do with futures is for

00:11:31,820 --> 00:11:37,610
example they have a loop like from 0 mm

00:11:35,810 --> 00:11:40,280
and they want to do some operation

00:11:37,610 --> 00:11:41,900
thousand times so they would do that in

00:11:40,280 --> 00:11:44,180
blocking codes by just doing the

00:11:41,900 --> 00:11:46,370
blocking code inside of a loop and when

00:11:44,180 --> 00:11:48,200
you give them futures and they just call

00:11:46,370 --> 00:11:49,880
it thousand times at the same time

00:11:48,200 --> 00:11:52,970
because the futures are synchronous

00:11:49,880 --> 00:11:54,290
those for processing in the back and a

00:11:52,970 --> 00:11:56,840
thing like that could happen

00:11:54,290 --> 00:12:00,890
so you're just firing requested its own

00:11:56,840 --> 00:12:03,140
service and the service is here John is

00:12:00,890 --> 00:12:04,900
overwhelmed by all the requests you

00:12:03,140 --> 00:12:08,090
sends to it because you didn't really

00:12:04,900 --> 00:12:09,850
wait for the actual response to get back

00:12:08,090 --> 00:12:12,650
you just fired a thousand requests and

00:12:09,850 --> 00:12:14,900
then maybe it gets back with a written

00:12:12,650 --> 00:12:20,240
response but actually it starts breaking

00:12:14,900 --> 00:12:23,180
up right so we know that we we can solve

00:12:20,240 --> 00:12:25,490
that in many ways but people nowadays

00:12:23,180 --> 00:12:28,220
and back then already solve it by

00:12:25,490 --> 00:12:31,520
circuit breakers right alko has god

00:12:28,220 --> 00:12:33,170
circuit breakers basically for futures

00:12:31,520 --> 00:12:38,030
and all of her API is interacting with

00:12:33,170 --> 00:12:40,040
futures and now adapted by histories and

00:12:38,030 --> 00:12:43,820
many other API is not really new thing

00:12:40,040 --> 00:12:45,500
but what does it really do so we back

00:12:43,820 --> 00:12:47,990
off for a few seconds and then we try

00:12:45,500 --> 00:12:49,910
again right so I call it the slamming

00:12:47,990 --> 00:12:52,100
the brakes pattern where you have the

00:12:49,910 --> 00:12:53,450
car and you actually didn't slam the

00:12:52,100 --> 00:12:55,850
brakes but you actually crash the car

00:12:53,450 --> 00:12:58,070
this is the circuit breaker triggering

00:12:55,850 --> 00:13:00,860
and it says okay we gotta wait five

00:12:58,070 --> 00:13:03,450
seconds okay now it works and when you

00:13:00,860 --> 00:13:05,280
like boom again right but

00:13:03,450 --> 00:13:07,110
and when you like okay now it was narcs

00:13:05,280 --> 00:13:10,470
again that's basically circuit breaker

00:13:07,110 --> 00:13:12,570
circuit breakers get to the point of the

00:13:10,470 --> 00:13:17,820
thing failing and then they back off

00:13:12,570 --> 00:13:20,850
okay remember that and can we do how can

00:13:17,820 --> 00:13:22,620
we do better than right right but let's

00:13:20,850 --> 00:13:24,600
let's way back then because you're kind

00:13:22,620 --> 00:13:27,630
of guessing okay how much can this

00:13:24,600 --> 00:13:29,970
service or this API handle until it

00:13:27,630 --> 00:13:30,630
blows up it's not very it's not flow

00:13:29,970 --> 00:13:33,360
control

00:13:30,630 --> 00:13:36,420
it's like failure compartmentalization

00:13:33,360 --> 00:13:38,580
and we can do better the answer is

00:13:36,420 --> 00:13:41,820
basically reacted streams but it took us

00:13:38,580 --> 00:13:44,070
a few years to actually realize that for

00:13:41,820 --> 00:13:47,700
a while everybody was kind of content

00:13:44,070 --> 00:13:51,060
with circuit breakers so the next stop

00:13:47,700 --> 00:13:55,560
in a invest trip is a cluster or eases

00:13:51,060 --> 00:13:57,870
in which we discover a wonderful world

00:13:55,560 --> 00:14:01,890
of distributive computing so far we were

00:13:57,870 --> 00:14:04,050
only multi-threaded basically so what is

00:14:01,890 --> 00:14:05,550
the cluster really and even the first

00:14:04,050 --> 00:14:08,430
sentence on this slide is actually

00:14:05,550 --> 00:14:11,010
something not many people realize the

00:14:08,430 --> 00:14:13,740
arca cluster is strictly about

00:14:11,010 --> 00:14:15,540
membership and your failure handling but

00:14:13,740 --> 00:14:17,940
but it's a membership thing right it's

00:14:15,540 --> 00:14:20,250
you have a bunch of nodes and you want

00:14:17,940 --> 00:14:23,010
them to form a group that's what it does

00:14:20,250 --> 00:14:25,470
it's not sometimes people compare it

00:14:23,010 --> 00:14:27,930
with something I don't know like a

00:14:25,470 --> 00:14:30,330
clustered database that's not a rocker

00:14:27,930 --> 00:14:32,250
cluster we'll get to actually storing

00:14:30,330 --> 00:14:34,470
data okay so it's only a building block

00:14:32,250 --> 00:14:36,990
that actually puts notes together and

00:14:34,470 --> 00:14:39,740
they monitor each other and then they

00:14:36,990 --> 00:14:44,190
can decide oh this one is down or not

00:14:39,740 --> 00:14:46,050
okay on top of that cluster tours like

00:14:44,190 --> 00:14:49,560
just a sharding and cluster singlet and

00:14:46,050 --> 00:14:53,250
such one our actual thing that helps you

00:14:49,560 --> 00:14:55,560
to build distributed systems by making

00:14:53,250 --> 00:14:57,990
it a bit simpler again the entire idea

00:14:55,560 --> 00:15:00,900
is innaka is to make things a bit

00:14:57,990 --> 00:15:03,390
simpler but not too simple so you don't

00:15:00,900 --> 00:15:07,020
have control over stuff so if sharding

00:15:03,390 --> 00:15:09,000
anyone not used shouting okay so quick

00:15:07,020 --> 00:15:11,280
overview shouting basically works like

00:15:09,000 --> 00:15:13,740
like you get a message here k5 it

00:15:11,280 --> 00:15:15,630
extracts where of its message should be

00:15:13,740 --> 00:15:16,529
routed to like with data based routing

00:15:15,630 --> 00:15:19,739
for example

00:15:16,529 --> 00:15:22,949
and it routes okay so k5 messages should

00:15:19,739 --> 00:15:25,889
go to this actor file because for

00:15:22,949 --> 00:15:28,159
example reroute by what are the message

00:15:25,889 --> 00:15:32,429
cast at five in it we go to active file

00:15:28,159 --> 00:15:34,349
can be anything and then you'll notice

00:15:32,429 --> 00:15:36,509
if a node fails cluster shouting

00:15:34,349 --> 00:15:41,099
internally notices that and it can

00:15:36,509 --> 00:15:43,799
migrate these actors like this forty

00:15:41,099 --> 00:15:46,679
actor to a still alive note right

00:15:43,799 --> 00:15:48,839
so if our messages that would have gone

00:15:46,679 --> 00:15:51,539
to this note that is dead now we are

00:15:48,839 --> 00:15:53,819
going to venue note and I say migrate

00:15:51,539 --> 00:15:56,069
the actor right but that's kind of funny

00:15:53,819 --> 00:15:58,709
we don't magically migrate the state or

00:15:56,069 --> 00:16:02,579
anything and this will be the reason why

00:15:58,709 --> 00:16:05,129
we then go into a cop assistance so what

00:16:02,579 --> 00:16:07,769
does it do our heartbeats and failure

00:16:05,129 --> 00:16:10,229
monitoring on top of which we then can

00:16:07,769 --> 00:16:15,419
provide features like okay failover and

00:16:10,229 --> 00:16:18,509
things like that so this was all kind of

00:16:15,419 --> 00:16:21,299
the inside so our car talking to akka

00:16:18,509 --> 00:16:24,299
basically or the futures which could be

00:16:21,299 --> 00:16:27,209
anything so we kind of have to build a

00:16:24,299 --> 00:16:32,879
port to kind of welcome the traders from

00:16:27,209 --> 00:16:36,479
abroad and or to talk to them so I call

00:16:32,879 --> 00:16:40,229
this kind of a like interaction with

00:16:36,479 --> 00:16:42,029
outside and inside sometimes people

00:16:40,229 --> 00:16:44,729
think about it data on the inside on the

00:16:42,029 --> 00:16:46,259
outside from Pat Collins paper I think

00:16:44,729 --> 00:16:48,899
it's basically the same trade of

00:16:46,259 --> 00:16:50,549
internally it's you can do a bit

00:16:48,899 --> 00:16:51,659
different a bit faster a bit more

00:16:50,549 --> 00:16:54,149
efficient because you actually control

00:16:51,659 --> 00:16:56,099
your environment and externally people

00:16:54,149 --> 00:16:57,929
want sex a man from so you're going to

00:16:56,099 --> 00:16:59,849
get a maximum it's not what you would

00:16:57,929 --> 00:17:04,740
like to give them for example but that's

00:16:59,849 --> 00:17:08,639
what they want Oh Jason so we got a have

00:17:04,740 --> 00:17:11,669
some HTTP interrupt this was way back

00:17:08,639 --> 00:17:14,009
van and I known as spray which was super

00:17:11,669 --> 00:17:16,919
popular I was a huge fan already back

00:17:14,009 --> 00:17:19,589
then so Matias in Johanna speed spray

00:17:16,919 --> 00:17:21,449
and when we invoke a teen talks with

00:17:19,589 --> 00:17:25,379
them but hey maybe we can like join

00:17:21,449 --> 00:17:28,250
forces and make this a part of Aachen so

00:17:25,379 --> 00:17:31,340
this is how our HTTP came to be

00:17:28,250 --> 00:17:33,200
the fully typed HTTP model isn't really

00:17:31,340 --> 00:17:35,510
new from spray this was kind of what

00:17:33,200 --> 00:17:39,140
spray had from the beginning but if we

00:17:35,510 --> 00:17:46,130
did it for like revamp of the API and I

00:17:39,140 --> 00:17:47,660
think it goes without me it it doesn't

00:17:46,130 --> 00:17:50,930
it doesn't actually go without saying

00:17:47,660 --> 00:17:53,240
but it's like a strong point that that

00:17:50,930 --> 00:17:55,550
proves that it's a pretty good model if

00:17:53,240 --> 00:17:57,920
X were other libraries instead of

00:17:55,550 --> 00:17:59,990
reinventing their own HTTP model just

00:17:57,920 --> 00:18:01,940
use this one because we spent a lot of

00:17:59,990 --> 00:18:02,510
time making sure it's very correct and

00:18:01,940 --> 00:18:04,760
very thorough

00:18:02,510 --> 00:18:08,900
so HTTP for us basically uses a spring

00:18:04,760 --> 00:18:12,170
on a bit adjusted I guess and again a

00:18:08,900 --> 00:18:13,570
hint from the future because in this

00:18:12,170 --> 00:18:15,590
talk I have a bunch of like these

00:18:13,570 --> 00:18:19,430
interconnected things so it was hard to

00:18:15,590 --> 00:18:21,440
do ordering right so our cache TDP is

00:18:19,430 --> 00:18:23,270
actually becoming the default back in

00:18:21,440 --> 00:18:24,980
foreplay right there's going to be a

00:18:23,270 --> 00:18:27,410
slide about that a section about that

00:18:24,980 --> 00:18:31,040
but that also means because we're

00:18:27,410 --> 00:18:33,470
actually parsing into the typed HTTP

00:18:31,040 --> 00:18:36,860
model and play always wanted to have a

00:18:33,470 --> 00:18:38,480
typed HTTP model so we have fit now so

00:18:36,860 --> 00:18:40,250
the next logical step will be to

00:18:38,480 --> 00:18:43,730
actually expose the typed model in

00:18:40,250 --> 00:18:45,740
players were to both kind of safe on the

00:18:43,730 --> 00:18:48,470
parsing and converting between them to

00:18:45,740 --> 00:18:50,500
models and also because a type of model

00:18:48,470 --> 00:18:53,420
is a really nice thing to happen and

00:18:50,500 --> 00:18:55,550
it's focused on and built on our streams

00:18:53,420 --> 00:18:58,160
so we're looping back to our streams and

00:18:55,550 --> 00:19:01,430
reactive strings again and so we

00:18:58,160 --> 00:19:03,920
represent an HTTP server a bit longhand

00:19:01,430 --> 00:19:06,170
similar to finagle so in Senegal it's a

00:19:03,920 --> 00:19:08,570
function from request to response in

00:19:06,170 --> 00:19:12,500
akka it's a flow from request to

00:19:08,570 --> 00:19:15,290
response and a flow is basically a

00:19:12,500 --> 00:19:17,870
concept from arca streams who has seen

00:19:15,290 --> 00:19:20,830
akka streams in action many people have

00:19:17,870 --> 00:19:23,870
so you know what a flow is so flow is

00:19:20,830 --> 00:19:27,380
interesting in an HTTP server because it

00:19:23,870 --> 00:19:29,390
exactly models what HTTP 2 can do right

00:19:27,380 --> 00:19:30,650
because an HTTP 1 you get a request you

00:19:29,390 --> 00:19:32,810
could do a response you get a request

00:19:30,650 --> 00:19:36,080
you do a response but you can do an HTTP

00:19:32,810 --> 00:19:37,250
to is server push which I don't like the

00:19:36,080 --> 00:19:39,100
name that it's post because it's

00:19:37,250 --> 00:19:40,950
actually still normal request response

00:19:39,100 --> 00:19:43,320
but you

00:19:40,950 --> 00:19:45,930
can respond with more responses to a

00:19:43,320 --> 00:19:47,640
single request right because you get a

00:19:45,930 --> 00:19:49,740
request for the main page of your

00:19:47,640 --> 00:19:51,510
website and the server decides to

00:19:49,740 --> 00:19:53,910
already start pushing all of the images

00:19:51,510 --> 00:19:56,070
or all of the CSS files and this is

00:19:53,910 --> 00:19:57,960
exactly what a flow can do a function

00:19:56,070 --> 00:20:00,660
well it would have to maybe start

00:19:57,960 --> 00:20:02,850
sending a list of recruitment responses

00:20:00,660 --> 00:20:06,110
or something fuzzy we have that here and

00:20:02,850 --> 00:20:08,310
capsulated invert flow type already

00:20:06,110 --> 00:20:10,440
entity basically a source of byte

00:20:08,310 --> 00:20:12,600
strings WebSocket is exactly the same

00:20:10,440 --> 00:20:15,630
like a request response but the type is

00:20:12,600 --> 00:20:18,210
the same here message in message out and

00:20:15,630 --> 00:20:21,630
the routing DSL is nothing new if you've

00:20:18,210 --> 00:20:24,840
seen spray or well arc HTTP in the

00:20:21,630 --> 00:20:27,210
recent years it basically says ok here's

00:20:24,840 --> 00:20:31,380
a traffic hello if it's a get request

00:20:27,210 --> 00:20:34,410
complete with this response and we have

00:20:31,380 --> 00:20:38,310
a low-level API which is interesting for

00:20:34,410 --> 00:20:41,040
those who I don't like too many implicit

00:20:38,310 --> 00:20:43,380
I think the only part of archive ads

00:20:41,040 --> 00:20:46,590
like actually heavy on implicit is

00:20:43,380 --> 00:20:52,080
routing DSL of Arc HTTP the rest of it

00:20:46,590 --> 00:20:53,790
doesn't have almost almost any and if

00:20:52,080 --> 00:20:55,560
you decide yeah I just want to get

00:20:53,790 --> 00:20:57,840
requests and do responses you can use

00:20:55,560 --> 00:20:59,250
for low-level API and that's also the

00:20:57,840 --> 00:21:01,350
integration layer with other frameworks

00:20:59,250 --> 00:21:03,480
like play right so play obviously

00:21:01,350 --> 00:21:05,310
doesn't go through the high level DSL to

00:21:03,480 --> 00:21:06,840
then route again things because it's

00:21:05,310 --> 00:21:13,740
already routed things because it has a

00:21:06,840 --> 00:21:17,220
root side ok so from the port of HTTP we

00:21:13,740 --> 00:21:20,160
go to mount persistence which is even

00:21:17,220 --> 00:21:22,170
sourcing for actors before when we

00:21:20,160 --> 00:21:25,050
talked about the cluster I said and we

00:21:22,170 --> 00:21:26,520
magically migrated for actor obviously

00:21:25,050 --> 00:21:29,960
there's nothing magic about it

00:21:26,520 --> 00:21:33,030
and with just cluster and just sharding

00:21:29,960 --> 00:21:36,750
saying migrate would probably be the

00:21:33,030 --> 00:21:39,090
wrong word it's more like restart the

00:21:36,750 --> 00:21:41,280
same behavior in a different place but

00:21:39,090 --> 00:21:44,460
it's not the same person anymore what we

00:21:41,280 --> 00:21:46,380
can do with persistence is store you

00:21:44,460 --> 00:21:49,500
know you get incoming commands you

00:21:46,380 --> 00:21:53,070
persist events and then

00:21:49,500 --> 00:21:54,750
this given note dice you move with xor

00:21:53,070 --> 00:21:57,059
to a different note and then recover the

00:21:54,750 --> 00:22:00,120
events which effectively means it's

00:21:57,059 --> 00:22:01,830
kinda like the same actor right because

00:22:00,120 --> 00:22:03,780
it behaves the same way because it's

00:22:01,830 --> 00:22:06,990
acting upon the history of all of its

00:22:03,780 --> 00:22:10,169
events now the feature here is that it

00:22:06,990 --> 00:22:13,409
keeps buffering incoming messages while

00:22:10,169 --> 00:22:18,299
it's recovering so we handle again a bit

00:22:13,409 --> 00:22:20,549
of complexities for you here API if

00:22:18,299 --> 00:22:23,640
someone hasn't seen a cop assistance

00:22:20,549 --> 00:22:26,490
very similar to occur just normal actors

00:22:23,640 --> 00:22:28,289
but we did separate the two api's and

00:22:26,490 --> 00:22:29,760
that's something I want to explain why

00:22:28,289 --> 00:22:31,940
we did that because sometimes people

00:22:29,760 --> 00:22:35,460
just assume yeah that's how it is and

00:22:31,940 --> 00:22:38,010
it's really important to separate the

00:22:35,460 --> 00:22:40,559
two cases of a yellow case of okay

00:22:38,010 --> 00:22:43,679
here's the incoming stuff from okay this

00:22:40,559 --> 00:22:45,419
is the recovery because you most likely

00:22:43,679 --> 00:22:47,850
don't want to do side affecting things

00:22:45,419 --> 00:22:50,010
while we're covering right you don't

00:22:47,850 --> 00:22:51,510
want to redo all of the transactions you

00:22:50,010 --> 00:22:55,200
would it to some bank account or

00:22:51,510 --> 00:22:56,730
something right and you may want to do

00:22:55,200 --> 00:22:58,860
that if you see that some of them are

00:22:56,730 --> 00:23:02,580
uncommitted and then you do it after

00:22:58,860 --> 00:23:05,070
recovery but having it really explicit

00:23:02,580 --> 00:23:08,039
that it's like in your face think about

00:23:05,070 --> 00:23:10,710
recovery now or think about actual life

00:23:08,039 --> 00:23:14,100
system now and we thought was very

00:23:10,710 --> 00:23:16,260
important previously if anyone remembers

00:23:14,100 --> 00:23:20,100
the old API service was experimental in

00:23:16,260 --> 00:23:22,559
we toyed around with it we had a normal

00:23:20,100 --> 00:23:26,280
receive and there was a flag you could

00:23:22,559 --> 00:23:28,440
check if you're recovering or not which

00:23:26,280 --> 00:23:30,539
people didn't really think about that

00:23:28,440 --> 00:23:32,610
much they would it would feel and write

00:23:30,539 --> 00:23:34,590
like a normal actor so people would feel

00:23:32,610 --> 00:23:38,400
and write like a normal actor and then

00:23:34,590 --> 00:23:41,159
forget about recovery so this is why we

00:23:38,400 --> 00:23:45,480
have like in your face two methods for

00:23:41,159 --> 00:23:47,669
it so finally to the future I did sound

00:23:45,480 --> 00:23:50,340
like interconnections like what what's

00:23:47,669 --> 00:23:54,570
going to happen in the soon future but

00:23:50,340 --> 00:23:57,559
let's look at relatively new stuff also

00:23:54,570 --> 00:24:00,809
about like current but not future future

00:23:57,559 --> 00:24:03,140
but here I'd like to ask who has used of

00:24:00,809 --> 00:24:06,350
a distributed data module Orvis

00:24:03,140 --> 00:24:08,480
a DTS weightless people and that's

00:24:06,350 --> 00:24:11,900
probably okay because they have a very

00:24:08,480 --> 00:24:16,160
specific use case so conflict-free data

00:24:11,900 --> 00:24:18,200
types and see a DTS for short are kind

00:24:16,160 --> 00:24:21,130
of a complementary to occur persistence

00:24:18,200 --> 00:24:23,450
so we had our capacitance it tries to be

00:24:21,130 --> 00:24:25,850
consistent and partition tolerant and

00:24:23,450 --> 00:24:28,400
then we were like yeah but we always

00:24:25,850 --> 00:24:30,620
don't always really need to be that

00:24:28,400 --> 00:24:33,560
consistent like eventual consistency as

00:24:30,620 --> 00:24:35,990
a concept we like and have internally

00:24:33,560 --> 00:24:39,820
under cluster actually basically if a

00:24:35,990 --> 00:24:42,740
cluster membership is CADD based without

00:24:39,820 --> 00:24:44,420
having been aware that it's CDT based

00:24:42,740 --> 00:24:47,360
while it was being implemented because

00:24:44,420 --> 00:24:51,350
that was before Visio ADT paper but the

00:24:47,360 --> 00:24:54,680
same concepts apply and we wanted to

00:24:51,350 --> 00:24:58,640
provide this very useful abstraction to

00:24:54,680 --> 00:25:00,710
to users so it's available so it can be

00:24:58,640 --> 00:25:03,590
a little bit out of date but it will

00:25:00,710 --> 00:25:06,020
keep giving you answers whereas a cop

00:25:03,590 --> 00:25:08,360
assistants favors not giving you any

00:25:06,020 --> 00:25:10,370
answers if it's aspects it could be

00:25:08,360 --> 00:25:14,630
wrong right that's kind of an intuitive

00:25:10,370 --> 00:25:18,290
explanation so with the Aditi's what we

00:25:14,630 --> 00:25:20,300
do under jump right to the image is you

00:25:18,290 --> 00:25:22,940
have some node it does some local right

00:25:20,300 --> 00:25:24,560
and this is a counter so if I counter

00:25:22,940 --> 00:25:26,690
works like where that every node has its

00:25:24,560 --> 00:25:28,670
own slot and the total count is with

00:25:26,690 --> 00:25:30,560
some of these slots this is how its

00:25:28,670 --> 00:25:33,380
conflict free right because everyone

00:25:30,560 --> 00:25:36,050
just writes the vert single slot in the

00:25:33,380 --> 00:25:36,560
counter and then using the cluster

00:25:36,050 --> 00:25:38,750
gossip

00:25:36,560 --> 00:25:41,120
this information is being spread in the

00:25:38,750 --> 00:25:43,040
cluster and deterministically merged

00:25:41,120 --> 00:25:47,710
until all of the nodes in the cluster

00:25:43,040 --> 00:25:50,510
have this information this gossip is

00:25:47,710 --> 00:25:52,010
basically same like for a cluster gossip

00:25:50,510 --> 00:25:56,390
so it's a bit random

00:25:52,010 --> 00:25:58,730
so replicated sometimes decides yeah now

00:25:56,390 --> 00:26:00,740
I'll send data to node one and now our

00:25:58,730 --> 00:26:03,260
send data to know to do and eventually

00:26:00,740 --> 00:26:04,730
all of it all over nodes have all the

00:26:03,260 --> 00:26:07,970
information so it's eventually

00:26:04,730 --> 00:26:10,460
consistent another thing that you may

00:26:07,970 --> 00:26:12,080
have not noticed and a person here in

00:26:10,460 --> 00:26:13,610
the audience has contributed a lot to

00:26:12,080 --> 00:26:17,030
which is young

00:26:13,610 --> 00:26:19,520
is dirty oddities because here INSEAD it

00:26:17,030 --> 00:26:22,670
is we sent the entire state all the time

00:26:19,520 --> 00:26:24,980
and the state can get big because it

00:26:22,670 --> 00:26:34,010
gets bigger the more notes you have in

00:26:24,980 --> 00:26:36,020
the cluster do you have a question I'll

00:26:34,010 --> 00:26:39,260
repeat for recording and do we provide

00:26:36,020 --> 00:26:44,179
any guarantees for the convergence

00:26:39,260 --> 00:26:54,100
protocol of these the oddities no it's

00:26:44,179 --> 00:26:57,260
like this room

00:26:54,100 --> 00:27:08,990
okay I'm curious go on you did Delta's

00:26:57,260 --> 00:27:12,020
so well yeah I mean obviously all of the

00:27:08,990 --> 00:27:14,630
co DTS or convergence but I think he's

00:27:12,020 --> 00:27:18,710
asking about timing or anything like

00:27:14,630 --> 00:27:22,340
that like yeah so timing is not

00:27:18,710 --> 00:27:24,710
deterministic and obviously all of them

00:27:22,340 --> 00:27:26,390
are convergent both the deltas and the

00:27:24,710 --> 00:27:30,919
normal ones but so it's kind of built-in

00:27:26,390 --> 00:27:33,080
and no timing guarantees we do want to

00:27:30,919 --> 00:27:35,030
benchmark this and like a real big

00:27:33,080 --> 00:27:38,990
cluster like hundreds of nodes and see

00:27:35,030 --> 00:27:41,840
how it performs like in reality but I

00:27:38,990 --> 00:27:44,540
don't have good numbers to share it hope

00:27:41,840 --> 00:27:46,669
that answers a question so the Delta

00:27:44,540 --> 00:27:49,040
gossip is nice because it only sends the

00:27:46,669 --> 00:27:50,870
actual changed states instead of sending

00:27:49,040 --> 00:27:53,720
the entire thing we send for example

00:27:50,870 --> 00:27:57,440
note 2 has 5 now and which saves us a

00:27:53,720 --> 00:28:00,530
bit of traffic what supports Delta C

00:27:57,440 --> 00:28:03,290
oddity is currently basically almost all

00:28:00,530 --> 00:28:04,850
of them accepts registers for them it

00:28:03,290 --> 00:28:08,000
doesn't make that much sense because a

00:28:04,850 --> 00:28:12,320
flag is like a boolean so yeah not want

00:28:08,000 --> 00:28:13,790
to save there so we finally looped back

00:28:12,320 --> 00:28:17,059
to the streaming dooms

00:28:13,790 --> 00:28:18,799
and verse vo Oracle as worse it's like

00:28:17,059 --> 00:28:21,590
hidden in the dunes and you have to go

00:28:18,799 --> 00:28:25,010
over for a while searching for some kind

00:28:21,590 --> 00:28:26,870
of stream so streams is the probably

00:28:25,010 --> 00:28:30,770
most overloaded word in

00:28:26,870 --> 00:28:32,680
the history of computer science I think

00:28:30,770 --> 00:28:37,160
maybe it isn't

00:28:32,680 --> 00:28:39,080
maybe addition would be worse so this is

00:28:37,160 --> 00:28:40,850
the number of other projects that I

00:28:39,080 --> 00:28:42,980
found on at Patrick's Park that use the

00:28:40,850 --> 00:28:44,930
word stream in the name or at least

00:28:42,980 --> 00:28:47,540
Corbin serves any kind of streaming

00:28:44,930 --> 00:28:50,780
thingie and that's an incomplete list

00:28:47,540 --> 00:28:53,630
obviously because I think each month for

00:28:50,780 --> 00:28:57,050
like five new streaming things and the

00:28:53,630 --> 00:29:00,590
problem is each of those has your own

00:28:57,050 --> 00:29:02,809
definition what streaming is and people

00:29:00,590 --> 00:29:05,300
would like to compare them right like

00:29:02,809 --> 00:29:09,500
should I use I don't know gear pump or

00:29:05,300 --> 00:29:12,950
acha streams or beam or scarlet stream

00:29:09,500 --> 00:29:14,510
right you guys know scholar stream you

00:29:12,950 --> 00:29:16,309
guys know that it memorizes so you're

00:29:14,510 --> 00:29:17,809
going to get a lot of memory out of out

00:29:16,309 --> 00:29:20,750
of memory errors if you use it in

00:29:17,809 --> 00:29:22,940
properly remember that checks and check

00:29:20,750 --> 00:29:24,679
for documentation because I actually had

00:29:22,940 --> 00:29:26,480
people who were like yeah I don't want

00:29:24,679 --> 00:29:29,540
to use our stream I'll use Scala stream

00:29:26,480 --> 00:29:32,600
which is completely different and then

00:29:29,540 --> 00:29:34,309
it blows up so what is a stream in the

00:29:32,600 --> 00:29:36,650
sense we talk about in our streams and

00:29:34,309 --> 00:29:37,790
reactive streams it for potentially

00:29:36,650 --> 00:29:40,850
infinite datasets

00:29:37,790 --> 00:29:43,640
it's element by element so it's not

00:29:40,850 --> 00:29:46,280
chunks of bytes like TCP talks about

00:29:43,640 --> 00:29:50,240
streaming but it's element by element so

00:29:46,280 --> 00:29:52,940
dog dog dog cat doc doc

00:29:50,240 --> 00:29:54,440
for example and it's a geared towards a

00:29:52,940 --> 00:29:58,820
synchronous processing as everything in

00:29:54,440 --> 00:30:01,370
a con so I will actually that's the

00:29:58,820 --> 00:30:03,710
slides I wanted to do this action so if

00:30:01,370 --> 00:30:05,570
you forgive me on jumper hat if you want

00:30:03,710 --> 00:30:07,340
to refer to these slides first comparing

00:30:05,570 --> 00:30:09,830
like which of the swimming things does

00:30:07,340 --> 00:30:12,650
what kind of streaming like Africa spark

00:30:09,830 --> 00:30:15,280
and in Java stream which is obviously

00:30:12,650 --> 00:30:19,070
more like collections and not streams

00:30:15,280 --> 00:30:21,830
but record rings so rector streams is

00:30:19,070 --> 00:30:23,780
more of an SPI which when we were

00:30:21,830 --> 00:30:27,260
developing that together with other

00:30:23,780 --> 00:30:31,220
people on that group we really wanted to

00:30:27,260 --> 00:30:33,860
have SPI in the package name but somehow

00:30:31,220 --> 00:30:37,760
it didn't stick maybe it's not as a

00:30:33,860 --> 00:30:38,720
popular acronym to use but what it means

00:30:37,760 --> 00:30:41,809
is it's by

00:30:38,720 --> 00:30:46,640
for people implementing api's on top of

00:30:41,809 --> 00:30:49,190
it let me try to explain so direct

00:30:46,640 --> 00:30:51,830
extremes interfaces after a bunch of a

00:30:49,190 --> 00:30:56,000
year of work or so maybe longer like one

00:30:51,830 --> 00:30:59,210
and a half of us some spring peeper

00:30:56,000 --> 00:31:01,429
some redhead paper obviously involvement

00:30:59,210 --> 00:31:05,929
of Doug Lee from Orem it eventually

00:31:01,429 --> 00:31:09,020
landed in the open JDK under JEP 266 so

00:31:05,929 --> 00:31:11,630
once JDK 9 is finally out this will be

00:31:09,020 --> 00:31:14,929
in the data game so what will actually

00:31:11,630 --> 00:31:16,580
be in vidal kang it's a thing to solve

00:31:14,929 --> 00:31:19,220
flow control right so if you have a

00:31:16,580 --> 00:31:22,250
slower subscriber faster publisher and

00:31:19,220 --> 00:31:24,289
again a naming thing we didn't want to

00:31:22,250 --> 00:31:26,240
carve and publish a subscriber because

00:31:24,289 --> 00:31:28,640
that kind of invokes the image of top

00:31:26,240 --> 00:31:32,240
sub son really pops up its point to

00:31:28,640 --> 00:31:36,830
point but these names were over voted

00:31:32,240 --> 00:31:39,230
and the entire spec is about what to do

00:31:36,830 --> 00:31:41,539
to not allow this situation of buffer

00:31:39,230 --> 00:31:43,880
overflow to happen one of the solutions

00:31:41,539 --> 00:31:47,270
is to drop all things on the floor but

00:31:43,880 --> 00:31:49,280
when i say that people panic so it's a

00:31:47,270 --> 00:31:51,409
valid solution I mean lots of protocols

00:31:49,280 --> 00:31:52,700
divert and require redelivery but

00:31:51,409 --> 00:31:55,340
somehow in userland

00:31:52,700 --> 00:31:58,309
in like application development it's not

00:31:55,340 --> 00:32:01,669
a very welcome solution so what can we

00:31:58,309 --> 00:32:03,559
do in one slide basically the permit

00:32:01,669 --> 00:32:05,929
systems of a downstream signore's

00:32:03,559 --> 00:32:08,570
looking at its buffer okay i can receive

00:32:05,929 --> 00:32:10,340
three things so return my upstream i can

00:32:08,570 --> 00:32:12,549
receive free things and the upstream is

00:32:10,340 --> 00:32:16,870
not allowed to send more elements and it

00:32:12,549 --> 00:32:20,570
was given permit for pretty simple and

00:32:16,870 --> 00:32:23,240
what is invent jdk is actually only for

00:32:20,570 --> 00:32:24,890
interfaces it's only that no

00:32:23,240 --> 00:32:26,179
implementation like one single

00:32:24,890 --> 00:32:29,179
implementation for this more like an

00:32:26,179 --> 00:32:32,179
example okay so why the hell do we want

00:32:29,179 --> 00:32:34,309
only interfaces invert ATK but that are

00:32:32,179 --> 00:32:37,700
not even implemented so the entire idea

00:32:34,309 --> 00:32:40,010
is interrupt if something's in the jdk

00:32:37,700 --> 00:32:42,650
you can assume that everybody will be

00:32:40,010 --> 00:32:45,890
implementing that specific thing would

00:32:42,650 --> 00:32:48,440
it have to be in the jdk debatable but

00:32:45,890 --> 00:32:50,330
for bigger organizations or bigger

00:32:48,440 --> 00:32:52,350
projects that's kind of an guarantee

00:32:50,330 --> 00:32:56,850
that ok this api will not go

00:32:52,350 --> 00:32:58,169
why we can bet on it so it's not that

00:32:56,850 --> 00:33:00,720
easy to actually implement this

00:32:58,169 --> 00:33:02,549
correctly so you looked at the

00:33:00,720 --> 00:33:06,600
interfaces it's look it looks very

00:33:02,549 --> 00:33:10,440
simple like for for interfaces seven

00:33:06,600 --> 00:33:12,660
methods in total fulfilled and here's

00:33:10,440 --> 00:33:15,390
the rules of the spec you no need to

00:33:12,660 --> 00:33:17,400
read them obviously but on general point

00:33:15,390 --> 00:33:19,710
I'm trying to get across it's actually

00:33:17,400 --> 00:33:21,600
very tricky to implement it properly we

00:33:19,710 --> 00:33:24,659
did a lot of mistakes other people did a

00:33:21,600 --> 00:33:26,429
lot of mistakes and we have a properly

00:33:24,659 --> 00:33:28,380
working solution where you can just use

00:33:26,429 --> 00:33:30,179
and vertical strips so if anyone's

00:33:28,380 --> 00:33:32,250
confused about what is reactive streams

00:33:30,179 --> 00:33:34,799
what is arca streams like the stream

00:33:32,250 --> 00:33:37,110
suspect and many people can implement it

00:33:34,799 --> 00:33:40,110
like rx can implement it or anyone else

00:33:37,110 --> 00:33:42,780
and we implemented as well which gives

00:33:40,110 --> 00:33:45,059
us the interrupt because for the back

00:33:42,780 --> 00:33:47,490
pressure to work everybody needs to

00:33:45,059 --> 00:33:49,520
implement the same protocol which with

00:33:47,490 --> 00:33:51,990
interrupt interface guarantees to us

00:33:49,520 --> 00:33:55,440
here's a gas streams the most boring

00:33:51,990 --> 00:33:57,830
example on the planet and the most

00:33:55,440 --> 00:34:00,900
useless probably but that's how people

00:33:57,830 --> 00:34:04,320
nowadays talk about oh my god reacted

00:34:00,900 --> 00:34:06,840
programming sake so very habit type wise

00:34:04,320 --> 00:34:10,440
it's basically a source of things and

00:34:06,840 --> 00:34:12,990
flows via line they can be connected if

00:34:10,440 --> 00:34:15,540
ports match right so flow is something

00:34:12,990 --> 00:34:20,580
that has an input has an output etc etc

00:34:15,540 --> 00:34:21,750
so now what curve we built with our

00:34:20,580 --> 00:34:24,450
constraints obviously you know that

00:34:21,750 --> 00:34:25,740
already we build our HTTP but that's in

00:34:24,450 --> 00:34:28,200
the past

00:34:25,740 --> 00:34:30,690
and it's also the answer to the slides I

00:34:28,200 --> 00:34:33,690
skipped right you can think to yourself

00:34:30,690 --> 00:34:36,240
okay can I build an HTTP server using

00:34:33,690 --> 00:34:36,629
spark screaming no doesn't make any

00:34:36,240 --> 00:34:39,149
sense

00:34:36,629 --> 00:34:41,280
can I use an ST can I build an HTTP

00:34:39,149 --> 00:34:43,139
server using ARCA streams yes absolutely

00:34:41,280 --> 00:34:44,700
that's for use case all right so if

00:34:43,139 --> 00:34:47,369
you're confused about all of these

00:34:44,700 --> 00:34:49,530
streaming services and streaming data

00:34:47,369 --> 00:34:52,590
processing thingy sources are streams

00:34:49,530 --> 00:34:57,239
that's a good intuition so what's next

00:34:52,590 --> 00:35:01,900
we build another port which says HTTP to

00:34:57,239 --> 00:35:04,690
so here's a simple HTTP to API where

00:35:01,900 --> 00:35:06,759
doesn't actually change at all from a

00:35:04,690 --> 00:35:09,069
normal HTTP API unlock streams because

00:35:06,759 --> 00:35:12,190
it's exactly the same because it's only

00:35:09,069 --> 00:35:14,589
a transport difference and what we have

00:35:12,190 --> 00:35:18,430
here is we will be serving some kind of

00:35:14,589 --> 00:35:20,469
image for recon see I can actually okay

00:35:18,430 --> 00:35:23,680
so we will be serving some kind of image

00:35:20,469 --> 00:35:28,779
but here we use the slowdown operation

00:35:23,680 --> 00:35:33,039
just to make it load a bit longer so um

00:35:28,779 --> 00:35:36,160
this is the typical like demo for HTTP -

00:35:33,039 --> 00:35:38,739
why it's carping and this is the same

00:35:36,160 --> 00:35:41,440
page I'm about to show in HDB - this is

00:35:38,739 --> 00:35:44,950
on HTTP one with HTTPS so it's

00:35:41,440 --> 00:35:46,180
comparable because HTTP 2 is kind of

00:35:44,950 --> 00:35:51,160
assumed you're going to be running on

00:35:46,180 --> 00:35:53,979
HTTPS so we compare HTTP to HTTPS can i

00:35:51,160 --> 00:35:56,950
zoom in can zoom ok so this is my

00:35:53,979 --> 00:36:02,109
wonderful pictures from my vacation but

00:35:56,950 --> 00:36:04,180
yeah you can see here verse a lot of

00:36:02,109 --> 00:36:06,430
being stored right great basically means

00:36:04,180 --> 00:36:11,249
you're waiting and then blue actually

00:36:06,430 --> 00:36:11,249
means you're actually sending stuff and

00:36:12,029 --> 00:36:19,749
another thing to notice is this violet

00:36:15,940 --> 00:36:21,699
thing that's basically SSL handshake new

00:36:19,749 --> 00:36:23,619
connection opening and when doing the

00:36:21,699 --> 00:36:27,369
dance liquor what protocol do you speak

00:36:23,619 --> 00:36:29,160
I speak this and when you can actually

00:36:27,369 --> 00:36:32,289
send data once you do for dance

00:36:29,160 --> 00:36:34,089
so what browsers do is they open a lot

00:36:32,289 --> 00:36:36,459
of connections and obviously you know

00:36:34,089 --> 00:36:40,059
the tricks about having more domains in

00:36:36,459 --> 00:36:43,839
your web service website so the browser

00:36:40,059 --> 00:36:47,619
would open more connections it's limited

00:36:43,839 --> 00:36:50,339
to like four six or eight and we load in

00:36:47,619 --> 00:36:53,619
around five seconds or so here I show

00:36:50,339 --> 00:36:58,690
SSL overhead and this is how it looks on

00:36:53,619 --> 00:37:00,849
HTTP - um the interesting bit is there's

00:36:58,690 --> 00:37:02,319
one connection and we can multiplex all

00:37:00,849 --> 00:37:05,019
of the data on that onto that singer

00:37:02,319 --> 00:37:07,420
connection does that necessarily make

00:37:05,019 --> 00:37:08,790
sense to put all of the data out at the

00:37:07,420 --> 00:37:13,290
same time

00:37:08,790 --> 00:37:15,360
not really it could be and is the area

00:37:13,290 --> 00:37:17,900
of active research how to properly do

00:37:15,360 --> 00:37:20,750
scheduling of putting data out in http/2

00:37:17,900 --> 00:37:22,710
but basically everybody is on the same

00:37:20,750 --> 00:37:24,420
position right now we're trying to

00:37:22,710 --> 00:37:27,450
figure out how to do the optimal push

00:37:24,420 --> 00:37:30,240
where but even with that we are way

00:37:27,450 --> 00:37:33,360
faster so it's it's nicer because it's

00:37:30,240 --> 00:37:35,610
not not text encoding but it's binary

00:37:33,360 --> 00:37:38,610
encoding we skip a lot of things we

00:37:35,610 --> 00:37:41,610
would have to do an HTTP so even without

00:37:38,610 --> 00:37:44,700
doing anything smart it does some gains

00:37:41,610 --> 00:37:47,580
and the same would apply for just to

00:37:44,700 --> 00:37:49,800
micro services talking to each other you

00:37:47,580 --> 00:37:54,030
can save on a lot of connection opening

00:37:49,800 --> 00:37:56,670
maintenance so as I said our HTTP is

00:37:54,030 --> 00:38:00,570
becoming the default backing for play

00:37:56,670 --> 00:38:03,750
and 2.6 which is now in release

00:38:00,570 --> 00:38:05,160
candidate phase I believe and if it

00:38:03,750 --> 00:38:07,800
isn't yet it's going to be like any

00:38:05,160 --> 00:38:09,780
moment now and this is how you use it

00:38:07,800 --> 00:38:12,090
you just include a plug-in about our

00:38:09,780 --> 00:38:13,890
HTTP to support and you do have to

00:38:12,090 --> 00:38:16,260
configure that here as things right I

00:38:13,890 --> 00:38:19,830
give a certificate because now you're

00:38:16,260 --> 00:38:26,510
running TLS and wait for the pictures to

00:38:19,830 --> 00:38:30,450
be taken to bird it's not of me but I

00:38:26,510 --> 00:38:33,840
can live with that so and people kind of

00:38:30,450 --> 00:38:36,000
assume that if we did this change of

00:38:33,840 --> 00:38:40,080
backend but it was only for performance

00:38:36,000 --> 00:38:42,960
it's not for performance I mean the goal

00:38:40,080 --> 00:38:46,380
with performance was to be not be worse

00:38:42,960 --> 00:38:48,540
than the 94 back-end which is a tough

00:38:46,380 --> 00:38:51,510
opponent because it's really really good

00:38:48,540 --> 00:38:52,290
so it's not it's also not that we don't

00:38:51,510 --> 00:38:55,410
like netting

00:38:52,290 --> 00:38:57,810
I think it's also but what it does give

00:38:55,410 --> 00:38:59,940
us to switch the backend is if we build

00:38:57,810 --> 00:39:02,040
any kind of monitoring infrastructure if

00:38:59,940 --> 00:39:05,580
we do any kind of optimizations in our

00:39:02,040 --> 00:39:07,830
HTTP if player has some bug or we have

00:39:05,580 --> 00:39:10,080
some bug we can actually collaborate way

00:39:07,830 --> 00:39:13,200
more closely and I also mentioned the

00:39:10,080 --> 00:39:15,960
things about typed headers and typed

00:39:13,200 --> 00:39:19,020
model right so we can share the work we

00:39:15,960 --> 00:39:20,610
did in the in the model there so if

00:39:19,020 --> 00:39:21,940
you're curious about performance and

00:39:20,610 --> 00:39:24,520
things like that

00:39:21,940 --> 00:39:27,010
players of like attesting to that

00:39:24,520 --> 00:39:30,369
continuously benchmarking play and you

00:39:27,010 --> 00:39:33,640
can go to play prune invert the current

00:39:30,369 --> 00:39:36,540
benchmarks and basically we are on par

00:39:33,640 --> 00:39:39,369
with 94 which is I think really good

00:39:36,540 --> 00:39:43,980
we'll still be using energy for some

00:39:39,369 --> 00:39:49,300
things but that's like details so and

00:39:43,980 --> 00:39:52,839
the journey to the typed woods is a long

00:39:49,300 --> 00:39:54,790
and painful one and like this entire

00:39:52,839 --> 00:39:56,619
talk is a journey but we need to speed

00:39:54,790 --> 00:39:58,750
up a bit and what I want to talk about

00:39:56,619 --> 00:40:01,660
is not what Roland's talked about which

00:39:58,750 --> 00:40:04,089
is ok this is the API and this is what

00:40:01,660 --> 00:40:06,819
we were exploring with Optio so I want

00:40:04,089 --> 00:40:09,369
to talk about were it kind of started

00:40:06,819 --> 00:40:11,950
which was for example what you may know

00:40:09,369 --> 00:40:16,599
as a typed actor if anyone uses it

00:40:11,950 --> 00:40:18,460
please don't that don't there's no good

00:40:16,599 --> 00:40:21,010
reason to do so the reason it was

00:40:18,460 --> 00:40:24,180
introduced again funny history lesson

00:40:21,010 --> 00:40:26,829
was when you're honest and Victor were

00:40:24,180 --> 00:40:30,040
building I can't remember which version

00:40:26,829 --> 00:40:31,869
of ARCA it it looked good to Java people

00:40:30,040 --> 00:40:32,920
right it looks like an interface I can

00:40:31,869 --> 00:40:35,859
understand that

00:40:32,920 --> 00:40:38,140
and maybe ok isn't that scary right so

00:40:35,859 --> 00:40:41,440
it was a nice way to kind of show people

00:40:38,140 --> 00:40:44,050
hey we're not that scary but it comes at

00:40:41,440 --> 00:40:46,480
a cost that uses reflection to basically

00:40:44,050 --> 00:40:48,339
we've messages out of these methods it

00:40:46,480 --> 00:40:54,010
encourages blocking actually which is

00:40:48,339 --> 00:40:55,540
for - in you can do a knock on and it's

00:40:54,010 --> 00:40:57,609
not really it doesn't look like

00:40:55,540 --> 00:41:01,780
messaging it's like we'd evolved to our

00:40:57,609 --> 00:41:04,359
PC so you know don't use that Denver was

00:41:01,780 --> 00:41:07,839
a brief expedition to the typed channels

00:41:04,359 --> 00:41:11,319
which Roland who was presenting here was

00:41:07,839 --> 00:41:14,290
exploring a lot back then and that was

00:41:11,319 --> 00:41:16,599
sadly well sadly we get and we got a way

00:41:14,290 --> 00:41:19,270
better API now but that was removed into

00:41:16,599 --> 00:41:21,400
free already the downside was it

00:41:19,270 --> 00:41:23,920
actually would have to use macros was

00:41:21,400 --> 00:41:25,869
very heavy on the type level things so

00:41:23,920 --> 00:41:28,040
even for simple stuff you would get

00:41:25,869 --> 00:41:31,190
really nasty in compiler errors

00:41:28,040 --> 00:41:32,870
Russ with a new typed API the simpler

00:41:31,190 --> 00:41:35,240
stuff is simple if you want to go crazy

00:41:32,870 --> 00:41:39,110
with op DSL you can go crazy with Rob

00:41:35,240 --> 00:41:41,120
DSL so so then after years of going

00:41:39,110 --> 00:41:43,370
around and wiggling around and exploring

00:41:41,120 --> 00:41:46,670
things we arrived at the current

00:41:43,370 --> 00:41:52,540
archetype which I need to fix this one

00:41:46,670 --> 00:41:56,540
on something I keep updating ok so

00:41:52,540 --> 00:41:58,070
innaka to fight - and that was a funny

00:41:56,540 --> 00:42:00,290
snapshot version that we wanted for

00:41:58,070 --> 00:42:03,890
early feedback and you guys you have two

00:42:00,290 --> 00:42:06,740
stars mutable immutable and because this

00:42:03,890 --> 00:42:09,320
was explained in depth by roland i will

00:42:06,740 --> 00:42:11,600
not get much into it but a very quick

00:42:09,320 --> 00:42:13,640
one okay here picked a time while I

00:42:11,600 --> 00:42:15,290
explained so now it's mostly about

00:42:13,640 --> 00:42:17,360
behaviors we always talked about

00:42:15,290 --> 00:42:19,700
behaviors but it wasn't the type so now

00:42:17,360 --> 00:42:22,130
it's a behavior of type T or T is the

00:42:19,700 --> 00:42:25,670
type you can receive a message on and

00:42:22,130 --> 00:42:28,640
Center is gone so all of nasty errors

00:42:25,670 --> 00:42:30,650
with handling futures inside the vectors

00:42:28,640 --> 00:42:32,900
and closing over the sender accidentally

00:42:30,650 --> 00:42:35,390
that's gone because sender is gone and

00:42:32,900 --> 00:42:37,460
actually removing sender is a good thing

00:42:35,390 --> 00:42:39,620
to begin with because it allows you to

00:42:37,460 --> 00:42:42,650
do a nicer design where each message

00:42:39,620 --> 00:42:45,350
kind of contains and can name the actor

00:42:42,650 --> 00:42:49,520
F and can type vector F that you're

00:42:45,350 --> 00:42:50,930
going to be replying to so quick side

00:42:49,520 --> 00:42:52,850
story why do we have two stars

00:42:50,930 --> 00:42:57,650
we have untyped on the left so that's

00:42:52,850 --> 00:43:02,030
how we call it a classic have a good

00:42:57,650 --> 00:43:05,990
ring to it like classical music but no

00:43:02,030 --> 00:43:07,700
no it's classic so a number right via

00:43:05,990 --> 00:43:09,770
mutable style so the mutable style

00:43:07,700 --> 00:43:12,290
basically looks very similar to in to

00:43:09,770 --> 00:43:15,320
the old one why do we want red star for

00:43:12,290 --> 00:43:17,720
one thing it can be a bit faster I don't

00:43:15,320 --> 00:43:20,390
think many people will actually care but

00:43:17,720 --> 00:43:22,580
it's easy to migrate to right because

00:43:20,390 --> 00:43:25,280
and and you already get the benefits

00:43:22,580 --> 00:43:28,820
right it can only handle commands of a

00:43:25,280 --> 00:43:31,370
certain type right here greet a command

00:43:28,820 --> 00:43:33,020
so without a lot of rewriting to the new

00:43:31,370 --> 00:43:34,970
style you can already can get the

00:43:33,020 --> 00:43:36,750
benefits very easily so that's one of

00:43:34,970 --> 00:43:39,359
the reasons where you have that

00:43:36,750 --> 00:43:42,650
and the recommended style is more

00:43:39,359 --> 00:43:46,290
immutable more functional in a way and

00:43:42,650 --> 00:43:48,990
it basically fears and learns a lot from

00:43:46,290 --> 00:43:51,390
what we did in archive SM and so if you

00:43:48,990 --> 00:43:53,040
like like finite state machines that's

00:43:51,390 --> 00:43:57,060
basically it because at the end of each

00:43:53,040 --> 00:43:59,099
method each where behavior you say which

00:43:57,060 --> 00:44:00,960
other behavior it shouldn't become right

00:43:59,099 --> 00:44:03,630
an extra sign basically means

00:44:00,960 --> 00:44:05,369
yeah I'm still the same behavior we have

00:44:03,630 --> 00:44:07,680
some dogs we have some great blog post

00:44:05,369 --> 00:44:08,520
about it and we're out of time so I need

00:44:07,680 --> 00:44:12,570
to go quickly

00:44:08,520 --> 00:44:15,320
so voltage over DSR I feel Java person

00:44:12,570 --> 00:44:18,450
we made a do serve it looks pretty ok

00:44:15,320 --> 00:44:20,580
uses lambdas so it's the best we could

00:44:18,450 --> 00:44:23,730
find and if you want to learn these

00:44:20,580 --> 00:44:25,349
stuff we currently do not have super

00:44:23,730 --> 00:44:27,630
comprehensive documentation it's like

00:44:25,349 --> 00:44:30,510
basic documentation for it however we

00:44:27,630 --> 00:44:31,710
did a nice blog post series about all of

00:44:30,510 --> 00:44:36,030
the different features that it has

00:44:31,710 --> 00:44:37,890
so go to the blog okay we're over time

00:44:36,030 --> 00:44:40,590
so I need to go quickly over var

00:44:37,890 --> 00:44:43,740
farm what is our Parker collection of

00:44:40,590 --> 00:44:47,130
connectors and vasana anymore and if

00:44:43,740 --> 00:44:49,440
you're curious about like helping us and

00:44:47,130 --> 00:44:51,990
the community this would be an awesome

00:44:49,440 --> 00:44:54,089
place to start because it's pretty easy

00:44:51,990 --> 00:44:57,119
to contribute like connector to your

00:44:54,089 --> 00:45:00,599
favorite technology and it's also a very

00:44:57,119 --> 00:45:03,270
very inclusive and easy to get started

00:45:00,599 --> 00:45:05,400
with it's you know easier to get started

00:45:03,270 --> 00:45:08,310
with alpaca van fix crazy raise

00:45:05,400 --> 00:45:10,260
conditions in extra dungeon right so I

00:45:08,310 --> 00:45:13,020
would recommend that if you have the

00:45:10,260 --> 00:45:17,550
time okay

00:45:13,020 --> 00:45:19,950
and the pretty much last big feature is

00:45:17,550 --> 00:45:22,589
which is already shipped you can use it

00:45:19,950 --> 00:45:25,650
already which is the new remoting quick

00:45:22,589 --> 00:45:28,710
note never ever use removing directly

00:45:25,650 --> 00:45:31,010
use the cluster for reasons I can go

00:45:28,710 --> 00:45:33,660
in-depth later if you want basically

00:45:31,010 --> 00:45:35,520
cluster of course Birds on top of

00:45:33,660 --> 00:45:37,230
remoting so all of the features I talked

00:45:35,520 --> 00:45:39,540
about here are used by the cluster but

00:45:37,230 --> 00:45:41,040
cluster has more smarter failure

00:45:39,540 --> 00:45:43,230
handling and actually will do the thing

00:45:41,040 --> 00:45:45,750
you would want it to do whereas remoting

00:45:43,230 --> 00:45:48,180
is very simple if a connection breaks

00:45:45,750 --> 00:45:49,740
breaks forever and you would have to

00:45:48,180 --> 00:45:53,010
reinvent for cluster basically

00:45:49,740 --> 00:45:54,990
to have some kind of resonance so what's

00:45:53,010 --> 00:45:57,660
the new generation of remoting it's

00:45:54,990 --> 00:45:59,520
udp-based it has actor of compression

00:45:57,660 --> 00:46:02,340
manifest compression it has dedicated

00:45:59,520 --> 00:46:03,900
lines for big messages which many people

00:46:02,340 --> 00:46:06,300
often do they send like a really big

00:46:03,900 --> 00:46:08,610
message which would lead in the old room

00:46:06,300 --> 00:46:11,430
looking to just clogging the pipe how I

00:46:08,610 --> 00:46:13,619
refer to it in the new one you can have

00:46:11,430 --> 00:46:15,660
a specific line that can have the big

00:46:13,619 --> 00:46:18,390
nasty net messages without hurting the

00:46:15,660 --> 00:46:22,110
rest of the system how difficult is it

00:46:18,390 --> 00:46:25,440
to use you just say on and and you get a

00:46:22,110 --> 00:46:29,940
10x improvement in performance pretty

00:46:25,440 --> 00:46:32,070
good the address would change it a bit

00:46:29,940 --> 00:46:33,450
and now it's UDP and not TCP so if

00:46:32,070 --> 00:46:36,300
you're behind firewalls you would have

00:46:33,450 --> 00:46:38,130
to adjust fat right but for the rest it

00:46:36,300 --> 00:46:40,760
there's no API influence everything

00:46:38,130 --> 00:46:43,740
works as if you would like it to and

00:46:40,760 --> 00:46:46,260
that's for like performance geeks in

00:46:43,740 --> 00:46:48,600
stable state almost allocation free

00:46:46,260 --> 00:46:50,970
almost because obviously if you

00:46:48,600 --> 00:46:55,020
deserialize an object that has to become

00:46:50,970 --> 00:46:57,869
the object right and compression if no

00:46:55,020 --> 00:47:00,510
one has ever looked at how a message

00:46:57,869 --> 00:47:04,320
looks in icon this is how a message

00:47:00,510 --> 00:47:08,310
works and you may wonder okay which part

00:47:04,320 --> 00:47:12,330
of that is the payload so the last five

00:47:08,310 --> 00:47:15,090
characters the messages hello and the

00:47:12,330 --> 00:47:16,770
rest is who sent the message worth as in

00:47:15,090 --> 00:47:20,160
work who's the receiver of the message

00:47:16,770 --> 00:47:22,950
and also like information about the

00:47:20,160 --> 00:47:26,790
manifest of the payload with compression

00:47:22,950 --> 00:47:30,060
we can get it down to like seven like

00:47:26,790 --> 00:47:31,880
thirty percent of that so pretty good

00:47:30,060 --> 00:47:35,700
and it's also dynamic and scares

00:47:31,880 --> 00:47:38,520
automatically new stuff we're looking at

00:47:35,700 --> 00:47:41,730
multi data center stuff about which I

00:47:38,520 --> 00:47:44,790
don't have not specifics but I do want

00:47:41,730 --> 00:47:47,310
to get your feedback but what would that

00:47:44,790 --> 00:47:50,010
mean because people say I want body data

00:47:47,310 --> 00:47:55,100
center stuff and when we ask what would

00:47:50,010 --> 00:47:59,790
you do with it I don't know it's so cool

00:47:55,100 --> 00:48:01,560
so if you have multiple data centers we

00:47:59,790 --> 00:48:03,470
would like to hear your actual story

00:48:01,560 --> 00:48:05,300
okay it could be like we have

00:48:03,470 --> 00:48:07,970
wallet filling and the wallet conveyor

00:48:05,300 --> 00:48:12,140
so we have to go to India to our data

00:48:07,970 --> 00:48:14,450
center to you know an actual story not a

00:48:12,140 --> 00:48:18,950
story like because I have multiple data

00:48:14,450 --> 00:48:20,720
centers it's not a story and five

00:48:18,950 --> 00:48:24,020
million things I couldn't fit on the map

00:48:20,720 --> 00:48:25,760
or in the time so new docks engine with

00:48:24,020 --> 00:48:27,740
scholar fiddle supports who can execute

00:48:25,760 --> 00:48:30,349
our code in the browser inside of your

00:48:27,740 --> 00:48:33,109
documentation its marked down so you

00:48:30,349 --> 00:48:35,410
don't have to attempt understanding

00:48:33,109 --> 00:48:38,420
restructure text which no one ever did

00:48:35,410 --> 00:48:40,640
including us

00:48:38,420 --> 00:48:43,310
we have a Titan kickstart so you can go

00:48:40,640 --> 00:48:45,109
to a webpage developed light burn to

00:48:43,310 --> 00:48:46,760
click five times I want a cluster

00:48:45,109 --> 00:48:50,270
project to get a cluster project in a

00:48:46,760 --> 00:48:54,980
zip file we have monitoring coming on so

00:48:50,270 --> 00:48:56,720
we monitored distributed the cluster

00:48:54,980 --> 00:48:59,510
sharding were of a shorter being

00:48:56,720 --> 00:49:03,349
allocated we monitor HTTP we even have

00:48:59,510 --> 00:49:05,599
tracing so we can actually you get a

00:49:03,349 --> 00:49:07,910
request right and then it's being routed

00:49:05,599 --> 00:49:10,339
for our HTTP to some route and then you

00:49:07,910 --> 00:49:13,520
send it to a extra we can actually track

00:49:10,339 --> 00:49:14,900
which HTTP route it hit and inside

00:49:13,520 --> 00:49:17,180
factor we can tell you where this

00:49:14,900 --> 00:49:20,000
request came from and what the latency

00:49:17,180 --> 00:49:25,430
was etc etc how difficult is it to use

00:49:20,000 --> 00:49:29,089
you basically say on versa pattern so

00:49:25,430 --> 00:49:30,589
distributed tracing works a bit it's

00:49:29,089 --> 00:49:32,119
gone it's going to be way better like

00:49:30,589 --> 00:49:35,380
with the thing with the routes I just

00:49:32,119 --> 00:49:40,430
said and that is a commercial thing so

00:49:35,380 --> 00:49:44,109
yeah we gotta eat somehow verse also ops

00:49:40,430 --> 00:49:46,280
clarity if you have multiple systems so

00:49:44,109 --> 00:49:48,859
last things and I know I'm the only

00:49:46,280 --> 00:49:51,230
thing like between you and a lot of beer

00:49:48,859 --> 00:49:53,230
so I respect you not leaving the room

00:49:51,230 --> 00:49:56,410
thank you very much

00:49:53,230 --> 00:49:56,410
IntelliJ guys

00:49:59,540 --> 00:50:05,580
laughs like literal go to ventilatory

00:50:03,330 --> 00:50:08,280
boof they have started working on akka

00:50:05,580 --> 00:50:09,720
features which basically whenever we

00:50:08,280 --> 00:50:12,240
find something that we think they could

00:50:09,720 --> 00:50:14,670
maybe do like a feature we open them a

00:50:12,240 --> 00:50:16,920
ticket I urge you to do the same because

00:50:14,670 --> 00:50:19,200
when we see a verse in a community that

00:50:16,920 --> 00:50:22,200
wants features when the one thing they

00:50:19,200 --> 00:50:23,820
see verse like demand and when your

00:50:22,200 --> 00:50:25,680
favorite feature you always want it

00:50:23,820 --> 00:50:29,310
could be implemented so that's a really

00:50:25,680 --> 00:50:32,130
cool thing to do verse a cognate anakata

00:50:29,310 --> 00:50:35,340
yes we're obviously part of the scala

00:50:32,130 --> 00:50:37,260
index and summing up I think that's like

00:50:35,340 --> 00:50:41,850
only the beginning and there's way more

00:50:37,260 --> 00:50:44,220
cool stuff coming very soon and special

00:50:41,850 --> 00:50:46,500
thank you to all the contributors which

00:50:44,220 --> 00:50:48,360
we recently started just giving out

00:50:46,500 --> 00:50:50,760
committing rights and actual ownership

00:50:48,360 --> 00:50:53,430
to any of the other projects some of

00:50:50,760 --> 00:50:56,700
them are here so that my thanks to them

00:50:53,430 --> 00:50:58,170
and if you see if you can try to

00:50:56,700 --> 00:51:00,060
remember some of the names and if you

00:50:58,170 --> 00:51:06,480
see the guy just grab him and give him a

00:51:00,060 --> 00:51:09,570
hug the woman so far in this group but

00:51:06,480 --> 00:51:12,480
maybe some so we love contributors

00:51:09,570 --> 00:51:15,350
that's my free ebook and if you have

00:51:12,480 --> 00:51:17,820
questions I propose to do vows over beer

00:51:15,350 --> 00:51:20,640
it's easier to talk over beer I think

00:51:17,820 --> 00:51:22,450
like especially for nerds so thank you

00:51:20,640 --> 00:51:32,380
very much and thank

00:51:22,450 --> 00:51:32,380

YouTube URL: https://www.youtube.com/watch?v=CGyIPVGB2-4


