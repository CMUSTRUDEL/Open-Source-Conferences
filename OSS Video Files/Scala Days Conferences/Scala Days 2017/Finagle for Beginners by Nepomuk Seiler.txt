Title: Finagle for Beginners by Nepomuk Seiler
Publication date: 2017-06-23
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Copenhagen 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
"Finagle is an extensible RPC system for the JVM, used to construct high-concurrency servers. Finagle implements uniform client and server APIs for several protocols, and is designed for high performance and concurrency." - Finagle docs

This talk gives an introduction to some Finagle core concepts and how to apply them. You will learn the basic idea behind "your server as function", how to use it, how to implement dynamic request routing with Dtabs and how to implement generic request contexts.
Captions: 
	00:00:03,870 --> 00:00:11,019
so welcome to my Finnegan for beginners

00:00:08,320 --> 00:00:12,610
talk the quick reminder please rate the

00:00:11,019 --> 00:00:16,539
app I'm happy for constructive feedback

00:00:12,610 --> 00:00:19,120
to improve this talk even more so um

00:00:16,539 --> 00:00:22,050
what I want to talk you to talk about

00:00:19,120 --> 00:00:26,470
today is how to build a distributed

00:00:22,050 --> 00:00:28,869
system with Finnegan first about me I'm

00:00:26,470 --> 00:00:30,730
Mookie I'm a scholar developer Kuta

00:00:28,869 --> 00:00:32,680
fogger and may some of you may know me

00:00:30,730 --> 00:00:34,420
as the one of the native packager

00:00:32,680 --> 00:00:37,120
maintain us

00:00:34,420 --> 00:00:41,229
so first of all who have you have heard

00:00:37,120 --> 00:00:43,809
about finagle before ah that's cool so a

00:00:41,229 --> 00:00:45,909
very brief introduction Finnegan is an

00:00:43,809 --> 00:00:48,850
extensible RPC remote procedure call

00:00:45,909 --> 00:00:50,679
system for the JVM used to construct a

00:00:48,850 --> 00:00:53,199
concurrency service so yesterday there

00:00:50,679 --> 00:00:55,510
was a nice talk from Petra about gee RPC

00:00:53,199 --> 00:00:57,999
and today we had something about the gum

00:00:55,510 --> 00:01:02,049
and finagle is just another alternative

00:00:57,999 --> 00:01:04,330
for constructing micro services and the

00:01:02,049 --> 00:01:06,100
special thing about finagle it's most of

00:01:04,330 --> 00:01:08,530
the vinegar code is protocol agnostic

00:01:06,100 --> 00:01:10,960
simplifying the implementation of new

00:01:08,530 --> 00:01:14,110
protocols so for instance when Aguilar

00:01:10,960 --> 00:01:18,579
ships with protocol HTTP thrift thrift

00:01:14,110 --> 00:01:20,219
books memcache the MySQL and Redis so

00:01:18,579 --> 00:01:24,340
you can build with the same abstraction

00:01:20,219 --> 00:01:26,500
you can use different protocols the

00:01:24,340 --> 00:01:28,630
reason why I'm standing here today I

00:01:26,500 --> 00:01:30,549
could apply we're using Finnegan's not

00:01:28,630 --> 00:01:33,310
for more than four years but many of the

00:01:30,549 --> 00:01:34,630
early developers aren't here anymore so

00:01:33,310 --> 00:01:38,500
we're trying to rebuild some of the

00:01:34,630 --> 00:01:40,960
knowledge and the prenatal documentation

00:01:38,500 --> 00:01:42,909
is in a lot of places incomplete and

00:01:40,960 --> 00:01:44,619
this is where we try to give back

00:01:42,909 --> 00:01:46,479
something to the community by writing

00:01:44,619 --> 00:01:49,079
documentation writing blog posts and

00:01:46,479 --> 00:01:51,820
giving this talk so sharing information

00:01:49,079 --> 00:01:53,740
about finagle and how to get started

00:01:51,820 --> 00:01:57,450
because that's really hard if you need

00:01:53,740 --> 00:02:00,490
to finagle and simply want to try it out

00:01:57,450 --> 00:02:03,359
so the best day a better thing to learn

00:02:00,490 --> 00:02:05,950
something is to build something I

00:02:03,359 --> 00:02:08,259
apologize that I won't show any live

00:02:05,950 --> 00:02:10,569
coding or running the system because it

00:02:08,259 --> 00:02:12,640
would take too much time switching all

00:02:10,569 --> 00:02:14,920
over again and I want to show you some

00:02:12,640 --> 00:02:16,870
of the more deeper concepts of finagle

00:02:14,920 --> 00:02:18,459
that really improve

00:02:16,870 --> 00:02:21,610
the users are finagler and your

00:02:18,459 --> 00:02:22,930
day-to-day life so the weather system

00:02:21,610 --> 00:02:24,819
we're building today consists of a

00:02:22,930 --> 00:02:27,879
server that source temperature data

00:02:24,819 --> 00:02:30,849
there's a sensor that will generate this

00:02:27,879 --> 00:02:34,239
data and center to the server we will

00:02:30,849 --> 00:02:36,069
also provide an HTTP API that reads the

00:02:34,239 --> 00:02:39,400
aggregated data from the server and

00:02:36,069 --> 00:02:41,799
provides an HTTP endpoint and we will

00:02:39,400 --> 00:02:43,239
use zookeeper for service discovery so

00:02:41,799 --> 00:02:45,069
we will talk about zookeeper and how

00:02:43,239 --> 00:02:48,640
these things work together in more

00:02:45,069 --> 00:02:53,290
detail but this is a big picture of what

00:02:48,640 --> 00:02:56,200
this talk will build today so before

00:02:53,290 --> 00:02:58,329
going into the the finagle service

00:02:56,200 --> 00:03:01,030
details I want to talk about vinegar

00:02:58,329 --> 00:03:03,879
util because there's not much

00:03:01,030 --> 00:03:06,370
documentation of the UTS but it's highly

00:03:03,879 --> 00:03:09,310
recommended to use a lot of the features

00:03:06,370 --> 00:03:12,340
provided by YouTube and the two concepts

00:03:09,310 --> 00:03:14,470
or the two features maybe YouTube

00:03:12,340 --> 00:03:19,000
provides I want to show you our apt

00:03:14,470 --> 00:03:21,940
right and flags so vinegar comes with

00:03:19,000 --> 00:03:25,900
its own app trait its income Twitter app

00:03:21,940 --> 00:03:29,560
app it's more or less like the scalloped

00:03:25,900 --> 00:03:31,359
right but it provides a lot of helper

00:03:29,560 --> 00:03:34,209
functions for instance you have life

00:03:31,359 --> 00:03:36,129
cycle methods like romaine this case we

00:03:34,209 --> 00:03:39,250
initialize some details we will talk

00:03:36,129 --> 00:03:41,859
about that later you have a none exit

00:03:39,250 --> 00:03:44,650
and you implement an actual main method

00:03:41,859 --> 00:03:47,169
in this case we start somewhere restore

00:03:44,650 --> 00:03:49,690
a server and we say when the service got

00:03:47,169 --> 00:03:54,370
shut down no matter how we want to close

00:03:49,690 --> 00:03:56,470
it and so you get some nice header

00:03:54,370 --> 00:03:58,959
functions and there's also Twitter

00:03:56,470 --> 00:04:01,599
server which is which builds up on the

00:03:58,959 --> 00:04:03,579
apt right which provides your nice admin

00:04:01,599 --> 00:04:07,750
interface so make sure to check that out

00:04:03,579 --> 00:04:10,480
as well the other thing are flags and

00:04:07,750 --> 00:04:13,810
they are the abstraction from finagle to

00:04:10,480 --> 00:04:16,419
provide command-line parsing you define

00:04:13,810 --> 00:04:19,690
flags like this if you use ab trait you

00:04:16,419 --> 00:04:24,550
have a flag method in scope that you can

00:04:19,690 --> 00:04:26,740
simply call a first parameter is the

00:04:24,550 --> 00:04:29,740
name then you specify default parameter

00:04:26,740 --> 00:04:31,979
and the description and as you can see

00:04:29,740 --> 00:04:36,430
like take the type parameter so which

00:04:31,979 --> 00:04:38,050
type has the flag we are parsing and as

00:04:36,430 --> 00:04:40,630
you can see the second one ends which

00:04:38,050 --> 00:04:42,789
looks like a custom type and how to

00:04:40,630 --> 00:04:43,660
provide the pausing for these kind of

00:04:42,789 --> 00:04:45,880
sealife legs

00:04:43,660 --> 00:04:48,100
well finagle provides the type class for

00:04:45,880 --> 00:04:50,139
it it's called flexible you implement

00:04:48,100 --> 00:04:52,419
the type class for a specific type how

00:04:50,139 --> 00:04:52,979
to parse a string into an end and you're

00:04:52,419 --> 00:04:56,770
good to go

00:04:52,979 --> 00:04:59,139
so these two basic concepts are used

00:04:56,770 --> 00:05:01,210
everywhere in finagle but they are not

00:04:59,139 --> 00:05:07,360
mentioned anywhere as far as I'm

00:05:01,210 --> 00:05:10,180
concerned so you should know them the

00:05:07,360 --> 00:05:12,310
second thing is thrift so I mentioned it

00:05:10,180 --> 00:05:14,199
in the beginning enablers protocol

00:05:12,310 --> 00:05:17,110
agnostic and provides several protocols

00:05:14,199 --> 00:05:20,500
we will use thrift as a protocol for

00:05:17,110 --> 00:05:23,280
inter-service communication and Finnigan

00:05:20,500 --> 00:05:25,539
provides a lot of tooling around thrift

00:05:23,280 --> 00:05:27,220
first of all a small introduction to

00:05:25,539 --> 00:05:28,840
thrift it's a cross language service

00:05:27,220 --> 00:05:33,550
development framework I think it was

00:05:28,840 --> 00:05:36,909
initially started by Facebook it's

00:05:33,550 --> 00:05:40,000
similar to protobuf I prepared it

00:05:36,909 --> 00:05:43,060
provides a lot of code generation for

00:05:40,000 --> 00:05:45,130
various languages and su- provides a

00:05:43,060 --> 00:05:47,320
very good integration with it we will

00:05:45,130 --> 00:05:51,460
see a lot of the implementation details

00:05:47,320 --> 00:05:53,919
later on and you can describe your API

00:05:51,460 --> 00:05:57,669
in a language agnostic way and I can't

00:05:53,919 --> 00:05:59,710
stress this enough petrol a get the best

00:05:57,669 --> 00:06:01,780
practice to share API definitions in a

00:05:59,710 --> 00:06:03,880
compiled package we're good to fire you

00:06:01,780 --> 00:06:07,680
do this as well but we also ship the

00:06:03,880 --> 00:06:11,409
thrift files as well so we can inspect

00:06:07,680 --> 00:06:15,639
the thrift definitions afterwards as

00:06:11,409 --> 00:06:18,849
well and the API was contained in a

00:06:15,639 --> 00:06:22,090
single package so what are the thrift

00:06:18,849 --> 00:06:25,030
plan look like for service definition we

00:06:22,090 --> 00:06:27,550
start with a the namespace the wild-card

00:06:25,030 --> 00:06:29,590
you could specify different languages

00:06:27,550 --> 00:06:30,250
for different languages different

00:06:29,590 --> 00:06:33,789
namespaces

00:06:30,250 --> 00:06:36,669
for instance Java Scala but as we don't

00:06:33,789 --> 00:06:38,440
care we simply use a wild-card and then

00:06:36,669 --> 00:06:40,360
you give it's like a package name like

00:06:38,440 --> 00:06:43,310
it's net with the target temperature so

00:06:40,360 --> 00:06:45,350
thrift so every quote that the

00:06:43,310 --> 00:06:48,830
that gets generated will be put in this

00:06:45,350 --> 00:06:53,060
package then you have a basic construct

00:06:48,830 --> 00:06:54,650
it's called struct basically it maps to

00:06:53,060 --> 00:06:57,290
case classes in the end right what you

00:06:54,650 --> 00:06:59,960
get out so we define temperature datum

00:06:57,290 --> 00:07:02,780
here single data point which contains of

00:06:59,960 --> 00:07:05,510
an integer Celsius and a long which is a

00:07:02,780 --> 00:07:08,200
UTC time stamp and for service

00:07:05,510 --> 00:07:11,720
definitions you use the service keyword

00:07:08,200 --> 00:07:14,000
temperature server and then it's almost

00:07:11,720 --> 00:07:16,040
reached like Java like abstract Java

00:07:14,000 --> 00:07:17,930
definitions so you have the return type

00:07:16,040 --> 00:07:19,910
which is for the add method it's void

00:07:17,930 --> 00:07:22,370
then you have a name and then you have a

00:07:19,910 --> 00:07:25,460
parameter list optionally you can

00:07:22,370 --> 00:07:28,910
specify throws declarations if your

00:07:25,460 --> 00:07:30,860
service throws any exceptions and that's

00:07:28,910 --> 00:07:33,110
basically it so this is how we define

00:07:30,860 --> 00:07:35,750
all our thrift definitions you can also

00:07:33,110 --> 00:07:37,550
import other definitions so if you have

00:07:35,750 --> 00:07:40,250
a shared model in your service you can

00:07:37,550 --> 00:07:44,680
import other definitions but besides

00:07:40,250 --> 00:07:44,680
that the language is pretty simple so

00:07:46,120 --> 00:07:54,230
Scrooge is the thrift compiler provided

00:07:50,360 --> 00:07:56,390
by finagle or the separate library but

00:07:54,230 --> 00:08:00,140
it's kind of spilled up to to work with

00:07:56,390 --> 00:08:02,570
finagle and it's generates the Scala

00:08:00,140 --> 00:08:06,170
code eggs for thrift so you can decode

00:08:02,570 --> 00:08:08,090
and encode your messages it generates

00:08:06,170 --> 00:08:11,330
that line with server adapters so you

00:08:08,090 --> 00:08:15,500
can implement a server service you

00:08:11,330 --> 00:08:18,410
specified and you can spawn clients from

00:08:15,500 --> 00:08:20,150
the generated stuff and it provides a

00:08:18,410 --> 00:08:21,970
nice SBT plugin so you can just

00:08:20,150 --> 00:08:25,280
integrate it in your build plugin and

00:08:21,970 --> 00:08:28,190
since the recent versions you simply add

00:08:25,280 --> 00:08:31,190
the plug-in to your build SP plugins SBT

00:08:28,190 --> 00:08:33,860
and the auto plug-in will automatically

00:08:31,190 --> 00:08:34,400
enabled and everything you put in source

00:08:33,860 --> 00:08:37,970
mains

00:08:34,400 --> 00:08:42,550
thrift will be used to generate source

00:08:37,970 --> 00:08:42,550
code x gala the Scala code

00:08:42,670 --> 00:08:46,700
okay

00:08:43,850 --> 00:08:48,800
so now we get into the more conceptual

00:08:46,700 --> 00:08:51,740
details of finagle and it's based on a

00:08:48,800 --> 00:08:54,500
paper called serve as a function and it

00:08:51,740 --> 00:08:57,560
explains three concepts so first

00:08:54,500 --> 00:09:01,330
concepts of futures I guess you're off

00:08:57,560 --> 00:09:04,270
with that they are wave four as in

00:09:01,330 --> 00:09:06,890
container for effing Cronus computation

00:09:04,270 --> 00:09:09,110
finna grows its own implementation of

00:09:06,890 --> 00:09:10,880
futures there are some reasons one of

00:09:09,110 --> 00:09:14,660
them was they need cancellation of

00:09:10,880 --> 00:09:16,279
futures and another thing you should be

00:09:14,660 --> 00:09:18,470
aware they behave quite differently from

00:09:16,279 --> 00:09:21,650
scalar futures so when you have a scan

00:09:18,470 --> 00:09:24,320
of future and you create it it will

00:09:21,650 --> 00:09:26,480
always run under specified execution

00:09:24,320 --> 00:09:29,510
context while cynical teachers simply

00:09:26,480 --> 00:09:31,850
containers for values and you have to

00:09:29,510 --> 00:09:34,910
specifically run them on an execution

00:09:31,850 --> 00:09:36,890
pool to really make them as introns then

00:09:34,910 --> 00:09:38,510
we have filters unfortunately I won't

00:09:36,890 --> 00:09:44,600
have time to talk about filters a lot

00:09:38,510 --> 00:09:47,000
today but they are way to put general

00:09:44,600 --> 00:09:49,790
logic in your request response chain for

00:09:47,000 --> 00:09:51,560
instance excessive logging and then we

00:09:49,790 --> 00:09:55,700
have services and this is one of the

00:09:51,560 --> 00:09:58,460
main abstractions for Frankie Nagar and

00:09:55,700 --> 00:09:59,720
they describe system boundaries system

00:09:58,460 --> 00:10:01,880
boundaries are represented by adding

00:09:59,720 --> 00:10:04,610
current functions called services they

00:10:01,880 --> 00:10:06,410
provide a symmetric and uniform API the

00:10:04,610 --> 00:10:09,170
famous abstraction represents both

00:10:06,410 --> 00:10:11,810
clients and service and this extraction

00:10:09,170 --> 00:10:14,720
is pretty pretty straightforward so we

00:10:11,810 --> 00:10:16,820
have a two types requesting response and

00:10:14,720 --> 00:10:19,100
it implements the simple function that

00:10:16,820 --> 00:10:21,170
map's a request to a future

00:10:19,100 --> 00:10:24,920
so an admin Cronus results of response

00:10:21,170 --> 00:10:27,470
and you can use this to implement your

00:10:24,920 --> 00:10:30,920
server and to spawn a client to make

00:10:27,470 --> 00:10:34,730
requests so how does this look like the

00:10:30,920 --> 00:10:36,230
the most basic example um that well

00:10:34,730 --> 00:10:40,360
comes to mind for everybody

00:10:36,230 --> 00:10:43,370
it's HTTP so first we have some imports

00:10:40,360 --> 00:10:46,130
we import the HTTP protocol and the

00:10:43,370 --> 00:10:48,530
service definition and then some help us

00:10:46,130 --> 00:10:51,950
to well start up the server and spawn

00:10:48,530 --> 00:10:54,350
the features and this is what a very

00:10:51,950 --> 00:10:56,690
very basic service implementation looks

00:10:54,350 --> 00:10:58,730
like so we have say we want a new

00:10:56,690 --> 00:11:00,650
service which is nothing else than a

00:10:58,730 --> 00:11:03,110
function so we implement the apply

00:11:00,650 --> 00:11:07,400
method which takes in HTTP requests and

00:11:03,110 --> 00:11:09,709
we return simply a future value with

00:11:07,400 --> 00:11:11,329
HTTP response and as you can see right

00:11:09,709 --> 00:11:13,579
here um

00:11:11,329 --> 00:11:17,480
eggless by design very low level because

00:11:13,579 --> 00:11:20,540
it's built - it makes it should make it

00:11:17,480 --> 00:11:23,269
easy to build new protocols so it's well

00:11:20,540 --> 00:11:25,999
it's based on this layer and then you

00:11:23,269 --> 00:11:28,399
start the server by simply calling HTTP

00:11:25,999 --> 00:11:31,129
so your protocol to surf bind it to a

00:11:28,399 --> 00:11:32,980
specific port give it the extra service

00:11:31,129 --> 00:11:35,600
implementation and it returns back

00:11:32,980 --> 00:11:38,569
future that you can wait for until the

00:11:35,600 --> 00:11:42,679
server is finished and that's it so

00:11:38,569 --> 00:11:46,189
that's the smallest version that you can

00:11:42,679 --> 00:11:48,709
build a phonetic servicing and decline

00:11:46,189 --> 00:11:53,149
on the other side it uses the same

00:11:48,709 --> 00:11:55,209
construction so you simply spawn HTTP

00:11:53,149 --> 00:11:58,399
client by calling HTTP new service and

00:11:55,209 --> 00:12:00,259
then you bind it to some host where you

00:11:58,399 --> 00:12:01,759
might want to make a request so in this

00:12:00,259 --> 00:12:05,689
case we golilong

00:12:01,759 --> 00:12:08,569
on port 80 and then we send a request

00:12:05,689 --> 00:12:10,339
and get a future back and we can call

00:12:08,569 --> 00:12:12,499
the onsuccess method and when the

00:12:10,339 --> 00:12:15,799
response returns we just print it and

00:12:12,499 --> 00:12:19,009
this is the very core concept of finagle

00:12:15,799 --> 00:12:21,709
you always work with these services that

00:12:19,009 --> 00:12:26,779
take a some kind of a request and you

00:12:21,709 --> 00:12:30,610
get an as a crona's response so let's

00:12:26,779 --> 00:12:34,489
implement the first step of our

00:12:30,610 --> 00:12:36,889
temperature service so first we call the

00:12:34,489 --> 00:12:39,319
service definition we thought earlier so

00:12:36,889 --> 00:12:40,699
this is a package and this is the

00:12:39,319 --> 00:12:43,040
definition so we have an ADD method

00:12:40,699 --> 00:12:45,379
where we can add a single data point and

00:12:43,040 --> 00:12:49,209
a method where we can get the mean of

00:12:45,379 --> 00:12:49,209
the temperature we have seen so far

00:12:49,869 --> 00:12:57,230
so we first import the thrift

00:12:55,669 --> 00:12:59,949
definitions that were generated by

00:12:57,230 --> 00:13:02,389
Scrooge they are all in this package and

00:12:59,949 --> 00:13:05,540
then we implement the temperature

00:13:02,389 --> 00:13:07,279
service dot future I face and this is

00:13:05,540 --> 00:13:09,379
some of the parts where I really

00:13:07,279 --> 00:13:11,540
struggled a lot how do i implement which

00:13:09,379 --> 00:13:13,519
stuff because the negative doesn't tell

00:13:11,540 --> 00:13:17,059
you what to do but in the end is pretty

00:13:13,519 --> 00:13:19,160
straightforward so you have you just

00:13:17,059 --> 00:13:20,869
implement the method we saw before the

00:13:19,160 --> 00:13:25,029
service we saw before in the definition

00:13:20,869 --> 00:13:25,029
which almost looks the same

00:13:25,100 --> 00:13:31,100
the implementation well it's up to you

00:13:29,179 --> 00:13:32,989
how you implement that I mean and the

00:13:31,100 --> 00:13:37,730
example repository it's Justin in memory

00:13:32,989 --> 00:13:40,009
storage right and this has the type

00:13:37,730 --> 00:13:41,839
temperature service of future so there

00:13:40,009 --> 00:13:45,379
is a more generic version of temperature

00:13:41,839 --> 00:13:48,919
service where you can plug in any ethnic

00:13:45,379 --> 00:13:53,899
Cronus container if you like but for the

00:13:48,919 --> 00:13:57,559
thrift thrift support it expects the

00:13:53,899 --> 00:14:00,799
future I face definition not a generic

00:13:57,559 --> 00:14:02,660
temperature service so this hasn't the

00:14:00,799 --> 00:14:07,489
the right shape to be a service because

00:14:02,660 --> 00:14:10,160
service is a function from request to

00:14:07,489 --> 00:14:15,379
some response and thrift is a binary

00:14:10,160 --> 00:14:17,480
protocol so we generated with this I

00:14:15,379 --> 00:14:20,269
have a method also generated by Scrooge

00:14:17,480 --> 00:14:24,049
and we create a vinegared service which

00:14:20,269 --> 00:14:26,149
has a shape of array byte to the

00:14:24,049 --> 00:14:29,329
responses again binary an array of bytes

00:14:26,149 --> 00:14:32,299
and we plug in the service and we

00:14:29,329 --> 00:14:35,509
specify the protocol that Richard used

00:14:32,299 --> 00:14:37,639
to do to encode and decode the messages

00:14:35,509 --> 00:14:39,139
over the wire and we use a simple binary

00:14:37,639 --> 00:14:41,989
protocol I think there's a compact

00:14:39,139 --> 00:14:44,569
protocol and plain text protocol as well

00:14:41,989 --> 00:14:48,799
which is nice for debugging if you need

00:14:44,569 --> 00:14:51,709
that and then almost like the HTTP

00:14:48,799 --> 00:14:53,899
server we choose our protocol which in

00:14:51,709 --> 00:14:54,379
this case we use not drift but through

00:14:53,899 --> 00:14:56,749
smokes

00:14:54,379 --> 00:15:00,439
which is an optimized implementation of

00:14:56,749 --> 00:15:03,339
the soot protocol by Twitter because it

00:15:00,439 --> 00:15:06,709
allows multiplexing on on a connection

00:15:03,339 --> 00:15:10,220
which is well takes less resources and

00:15:06,709 --> 00:15:12,889
less connections so I recommend using

00:15:10,220 --> 00:15:15,949
that and we want to implement a server

00:15:12,889 --> 00:15:18,410
we give it a label this is life for

00:15:15,949 --> 00:15:20,839
debugging later and for monitoring to

00:15:18,410 --> 00:15:22,879
give it a proper name and then we surf

00:15:20,839 --> 00:15:25,730
and announce it so serving in starting

00:15:22,879 --> 00:15:27,829
and announcing means it I make it

00:15:25,730 --> 00:15:31,039
publicly available that I've started a

00:15:27,829 --> 00:15:34,519
server somewhere and you do this by

00:15:31,039 --> 00:15:37,550
giving the service a name and name has a

00:15:34,519 --> 00:15:39,500
very specific syntax

00:15:37,550 --> 00:15:41,630
and documented in the comment as well so

00:15:39,500 --> 00:15:44,570
first you have a schema where do I want

00:15:41,630 --> 00:15:46,490
to announce my service CK stands for

00:15:44,570 --> 00:15:49,910
zookeeper so I say I want to announce

00:15:46,490 --> 00:15:52,700
myself at some simply keep instance then

00:15:49,910 --> 00:15:55,790
I second parameter is a host so there's

00:15:52,700 --> 00:15:58,640
my to keep instance running at fort 2181

00:15:55,790 --> 00:16:01,220
and then I give it a path this is where

00:15:58,640 --> 00:16:04,850
the zookeeper schema knows well I will

00:16:01,220 --> 00:16:07,400
put the information where the server is

00:16:04,850 --> 00:16:10,670
running a little pass and then there's

00:16:07,400 --> 00:16:13,250
in the end there's a shot ID and for me

00:16:10,670 --> 00:16:15,260
students I don't know what is for the

00:16:13,250 --> 00:16:18,080
documentation just said it's used

00:16:15,260 --> 00:16:20,050
internally by very few services in our

00:16:18,080 --> 00:16:22,310
infrastructure so I think the the one

00:16:20,050 --> 00:16:23,000
the person who wrote the documentation

00:16:22,310 --> 00:16:25,040
doesn't know either

00:16:23,000 --> 00:16:29,330
because well it's just an artifact

00:16:25,040 --> 00:16:31,880
somebody edit it so at some point so

00:16:29,330 --> 00:16:34,460
yeah when I figure out what this is for

00:16:31,880 --> 00:16:36,200
I will let you know and then you give it

00:16:34,460 --> 00:16:37,940
an address where you want to bind it on

00:16:36,200 --> 00:16:40,250
your machine and you give it the service

00:16:37,940 --> 00:16:43,540
implementation and this is everything

00:16:40,250 --> 00:16:47,150
you have to do to implement basic

00:16:43,540 --> 00:16:51,100
Finnigan service and run it and it's

00:16:47,150 --> 00:16:54,290
actually not that much code but it's

00:16:51,100 --> 00:16:55,880
it's not clear from the documentation

00:16:54,290 --> 00:16:59,570
that it's that easy

00:16:55,880 --> 00:17:02,540
and so we announced it but now we have

00:16:59,570 --> 00:17:06,680
to discover it and this is also an

00:17:02,540 --> 00:17:09,050
interesting part because finagle

00:17:06,680 --> 00:17:10,550
provides a lot of strategies to resolve

00:17:09,050 --> 00:17:13,280
your services and we will talk about

00:17:10,550 --> 00:17:16,250
some keeper today but there also you can

00:17:13,280 --> 00:17:17,810
use DNS or DNS broadcasting I think

00:17:16,250 --> 00:17:19,700
there are two or three more but they are

00:17:17,810 --> 00:17:21,650
not documented anywhere but you if you

00:17:19,700 --> 00:17:27,500
read the tests of the resulting stuff

00:17:21,650 --> 00:17:29,930
you can see what is already provided so

00:17:27,500 --> 00:17:33,500
how does connect are resolved services

00:17:29,930 --> 00:17:36,440
um the the main concept is our names so

00:17:33,500 --> 00:17:39,710
every service must have a name and we've

00:17:36,440 --> 00:17:43,300
specified the name for listening server

00:17:39,710 --> 00:17:45,710
before in the name parameter and

00:17:43,300 --> 00:17:48,050
connected uses these to identify network

00:17:45,710 --> 00:17:49,700
locations and there are two type two

00:17:48,050 --> 00:17:51,160
types of names so there's names of

00:17:49,700 --> 00:17:55,310
bounds

00:17:51,160 --> 00:17:57,950
which is a bind the name to a specific

00:17:55,310 --> 00:17:59,720
address and as you can see it's not only

00:17:57,950 --> 00:18:02,720
an address but it's a variable address

00:17:59,720 --> 00:18:05,750
because finagle takes care for you if

00:18:02,720 --> 00:18:08,840
the address changes so if your service

00:18:05,750 --> 00:18:12,290
starts in a new place and announcer the

00:18:08,840 --> 00:18:15,530
circle zookeeper Nicoise will make sure

00:18:12,290 --> 00:18:18,650
that it gets updated accordingly and use

00:18:15,530 --> 00:18:22,880
the unit dress the other arm type is

00:18:18,650 --> 00:18:25,550
named at path which is I reckon the path

00:18:22,880 --> 00:18:29,690
that needs to be resolved to an address

00:18:25,550 --> 00:18:32,780
and there's a simple resolve it pauses

00:18:29,690 --> 00:18:34,970
these strengths into names so how does

00:18:32,780 --> 00:18:37,550
this resolve work well the first

00:18:34,970 --> 00:18:39,620
implementation we already saw give you

00:18:37,550 --> 00:18:44,420
the schema bang and some arguments and

00:18:39,620 --> 00:18:47,810
it always resolves to a bounce there are

00:18:44,420 --> 00:18:50,510
two the main to resolve us you probably

00:18:47,810 --> 00:18:52,340
uses zookeeper that we already saw and

00:18:50,510 --> 00:18:56,180
the parameters are the host and the path

00:18:52,340 --> 00:18:57,920
and there's the I net resolver and we

00:18:56,180 --> 00:19:00,140
already used that in the first HTTP

00:18:57,920 --> 00:19:03,320
example where we just put in as gala

00:19:00,140 --> 00:19:05,420
longer talk port 80 and finagle is by

00:19:03,320 --> 00:19:07,670
default uses the inode resolve which

00:19:05,420 --> 00:19:09,980
simply opens the sockets on the given

00:19:07,670 --> 00:19:11,930
address but you can and I would

00:19:09,980 --> 00:19:15,260
recommend specified explicitly if you

00:19:11,930 --> 00:19:17,780
want to resolve within it so people know

00:19:15,260 --> 00:19:20,750
what you're actually using and the other

00:19:17,780 --> 00:19:24,800
strategy are these hierarchical paths

00:19:20,750 --> 00:19:26,570
which is first resolve to a path which

00:19:24,800 --> 00:19:30,170
eventually after resolving by a

00:19:26,570 --> 00:19:33,170
delegation tables to a bound and we'll

00:19:30,170 --> 00:19:35,060
see details and action later on but for

00:19:33,170 --> 00:19:38,990
now we start with the single schema

00:19:35,060 --> 00:19:41,420
version which is aesthetic but easy to

00:19:38,990 --> 00:19:44,030
get started with so you create a client

00:19:41,420 --> 00:19:45,560
again by using specifying the protocol

00:19:44,030 --> 00:19:47,600
you want to use in this case through

00:19:45,560 --> 00:19:49,550
smokes but now we don't want to spawn

00:19:47,600 --> 00:19:52,160
the server but the client so we say dot

00:19:49,550 --> 00:19:54,880
client and then we want to specify the

00:19:52,160 --> 00:19:57,380
interface so the the remote procedure

00:19:54,880 --> 00:19:59,720
interface we want to call and this is

00:19:57,380 --> 00:20:02,630
our temperature service or future

00:19:59,720 --> 00:20:04,370
interface and we don't specify a name

00:20:02,630 --> 00:20:07,700
this time but

00:20:04,370 --> 00:20:11,420
destination where the client should look

00:20:07,700 --> 00:20:13,809
for to resolve this service and as you

00:20:11,420 --> 00:20:17,390
can see it's almost the same as before

00:20:13,809 --> 00:20:19,010
it's this time but this time it's not

00:20:17,390 --> 00:20:20,750
zookeeper but zookeeper two and this is

00:20:19,010 --> 00:20:22,550
the second mystery for me two

00:20:20,750 --> 00:20:24,650
implementations and the vinegars

00:20:22,550 --> 00:20:27,440
documentation states use zookeeper two

00:20:24,650 --> 00:20:29,860
resolver for clients and zookeeper for

00:20:27,440 --> 00:20:32,840
service but there's no explanation why

00:20:29,860 --> 00:20:34,760
they both work I tried out both using

00:20:32,840 --> 00:20:37,490
zookeeper to resolve us for serve a

00:20:34,760 --> 00:20:43,550
client and the other way around but they

00:20:37,490 --> 00:20:45,530
state this so it works and so it's the

00:20:43,550 --> 00:20:48,290
same again you get the schema bang and

00:20:45,530 --> 00:20:50,990
then your address for su keeper and we

00:20:48,290 --> 00:20:55,309
put in a label for monitoring and then

00:20:50,990 --> 00:20:57,350
you have a simple function from then you

00:20:55,309 --> 00:20:59,420
have an instance of your client which

00:20:57,350 --> 00:21:02,540
implements this feature and you can just

00:20:59,420 --> 00:21:04,370
call the functions so on the client we

00:21:02,540 --> 00:21:05,330
just call at and at the temperature data

00:21:04,370 --> 00:21:08,230
and that's it

00:21:05,330 --> 00:21:11,179
so this is how you connect services and

00:21:08,230 --> 00:21:14,000
another hood finagle manages most of the

00:21:11,179 --> 00:21:15,950
complexity for you we're using it for

00:21:14,000 --> 00:21:17,660
almost four years and we were really

00:21:15,950 --> 00:21:19,520
surprised about the maturity of

00:21:17,660 --> 00:21:22,520
teenagers so we never had really any

00:21:19,520 --> 00:21:24,740
issues with these kind of resolving and

00:21:22,520 --> 00:21:27,290
problem even when our ops to shut down

00:21:24,740 --> 00:21:29,300
our DNS server and all the database

00:21:27,290 --> 00:21:31,130
resolving didn't work anymore Finnegan

00:21:29,300 --> 00:21:33,320
just kept working because it's cached

00:21:31,130 --> 00:21:37,190
other addresses and just kept quiet

00:21:33,320 --> 00:21:39,260
until the DNS was there again and they

00:21:37,190 --> 00:21:42,080
have circuit breakers and a lot of

00:21:39,260 --> 00:21:43,520
strategies to handle failure and no

00:21:42,080 --> 00:21:45,530
matter how how much refreshed our

00:21:43,520 --> 00:21:49,250
infrastructure finagle was pretty happy

00:21:45,530 --> 00:21:54,800
and running so and this is all hidden

00:21:49,250 --> 00:21:57,200
behind this few lines of code so we've

00:21:54,800 --> 00:22:00,520
we've come so far and we pulled a server

00:21:57,200 --> 00:22:04,400
and a sensor talking to zookeeper and

00:22:00,520 --> 00:22:08,270
now we go to the HTTP API and who have

00:22:04,400 --> 00:22:11,570
you knows Finch okay some of you yeah

00:22:08,270 --> 00:22:15,050
Finch is a crooked on the block it's

00:22:11,570 --> 00:22:17,929
built on top of finagle and as a very

00:22:15,050 --> 00:22:22,070
thin layer few functional basic blocks

00:22:17,929 --> 00:22:25,009
to compose oblate HTTP api as assumed

00:22:22,070 --> 00:22:26,809
the first example of the finagle api is

00:22:25,009 --> 00:22:30,590
pretty low level because it's very close

00:22:26,809 --> 00:22:33,470
to the protocol so finagle gives you

00:22:30,590 --> 00:22:35,960
some nice API to do that and it gives

00:22:33,470 --> 00:22:38,749
you some simple and robust HTTP

00:22:35,960 --> 00:22:40,549
primitives and but they try to be as

00:22:38,749 --> 00:22:43,369
close to finagle as possible to make the

00:22:40,549 --> 00:22:48,259
integration easy but make the HTTP

00:22:43,369 --> 00:22:51,470
interface more usable so to Oba so that

00:22:48,259 --> 00:22:54,259
Finch can work its magic you need some

00:22:51,470 --> 00:22:56,809
some imports so first we import

00:22:54,259 --> 00:22:59,570
everything from finagle then we import

00:22:56,809 --> 00:23:02,629
an HTTP response classifier we will see

00:22:59,570 --> 00:23:04,869
in a second how useless and we import

00:23:02,629 --> 00:23:08,389
Finch Finch thirsty and prefer the other

00:23:04,869 --> 00:23:12,730
generation and then everything just

00:23:08,389 --> 00:23:15,320
happens magically so we define our

00:23:12,730 --> 00:23:17,269
endpoint first of all we define our data

00:23:15,320 --> 00:23:20,899
model that we want to return on our HTTP

00:23:17,269 --> 00:23:24,740
API so simple case class mean which only

00:23:20,899 --> 00:23:26,960
contains the mean value then we define

00:23:24,740 --> 00:23:33,049
an endpoint an endpoint is finished

00:23:26,960 --> 00:23:34,549
abstraction for an HTTP endpoint so we

00:23:33,049 --> 00:23:36,980
can send requests and get response to

00:23:34,549 --> 00:23:38,809
and it gives you some so nice help us to

00:23:36,980 --> 00:23:41,990
define those so in this case we define

00:23:38,809 --> 00:23:44,619
an HTTP endpoint which responds to gets

00:23:41,990 --> 00:23:48,019
responses on the URL whether slash mean

00:23:44,619 --> 00:23:51,259
and then you in the block you specify

00:23:48,019 --> 00:23:54,619
the actual implementation so here we

00:23:51,259 --> 00:23:57,470
have response the the temperature client

00:23:54,619 --> 00:23:59,389
as before and now we are calling the

00:23:57,470 --> 00:24:02,960
mean methods to get the mean temperature

00:23:59,389 --> 00:24:06,980
and as a response we get a future of

00:24:02,960 --> 00:24:09,289
thermal map over this double and return

00:24:06,980 --> 00:24:12,649
an OK response with the new model and

00:24:09,289 --> 00:24:15,830
this already compiles and ask the the

00:24:12,649 --> 00:24:18,649
correct thing so Finch handles future

00:24:15,830 --> 00:24:22,869
responses correctly like ok to the GP or

00:24:18,649 --> 00:24:26,029
any other more modern framework does and

00:24:22,869 --> 00:24:28,279
with this API definition we can spawn a

00:24:26,029 --> 00:24:30,080
server again choose the protocol say we

00:24:28,279 --> 00:24:31,650
want to spawn a server give it a label

00:24:30,080 --> 00:24:33,930
and

00:24:31,650 --> 00:24:35,970
now you can see the wood response

00:24:33,930 --> 00:24:38,430
classifier and this is a nice example of

00:24:35,970 --> 00:24:39,809
finagling trying to be a protocol

00:24:38,430 --> 00:24:42,480
agnostic as possible in every way

00:24:39,809 --> 00:24:44,700
because finagle doesn't know what

00:24:42,480 --> 00:24:47,250
protocols you're using or what is in

00:24:44,700 --> 00:24:50,460
failure in your protocol mean so for

00:24:47,250 --> 00:24:51,809
HTTP you probably want responses with

00:24:50,460 --> 00:24:53,880
five hundred or five hundred something

00:24:51,809 --> 00:24:56,309
to be marked as a failure

00:24:53,880 --> 00:24:59,240
so finagle can take actions if the

00:24:56,309 --> 00:25:02,070
server sends too many 500 responses and

00:24:59,240 --> 00:25:06,270
maybe it takes takes it out of the load

00:25:02,070 --> 00:25:07,770
balancing or throttles requests but it

00:25:06,270 --> 00:25:09,330
doesn't know what a failure is so you

00:25:07,770 --> 00:25:14,040
can give us respond specifiers

00:25:09,330 --> 00:25:16,110
which tells which enhances the server

00:25:14,040 --> 00:25:18,630
with information what is a failure and

00:25:16,110 --> 00:25:21,690
what not and then again we just

00:25:18,630 --> 00:25:24,059
announced it this time under flash

00:25:21,690 --> 00:25:28,890
servers flash weather so we can find it

00:25:24,059 --> 00:25:30,570
and bind it to an address and if you

00:25:28,890 --> 00:25:32,580
remember the the thrift service we had

00:25:30,570 --> 00:25:34,770
to create a new class with the new

00:25:32,580 --> 00:25:36,630
temperature service in a good service

00:25:34,770 --> 00:25:38,000
and given a protocol API and stuff like

00:25:36,630 --> 00:25:41,280
this

00:25:38,000 --> 00:25:45,210
finch goes another way if you have a

00:25:41,280 --> 00:25:48,270
type class that can make letting create

00:25:45,210 --> 00:25:51,179
a service from HTTP request through HTTP

00:25:48,270 --> 00:25:53,429
response you can simply call on your end

00:25:51,179 --> 00:25:56,610
point so it's called API the variable

00:25:53,429 --> 00:25:58,020
you can call to service and that's it so

00:25:56,610 --> 00:26:00,720
you don't have to create a new class and

00:25:58,020 --> 00:26:04,260
wrap that again so it's pretty

00:26:00,720 --> 00:26:07,650
straightforward so a short recap this

00:26:04,260 --> 00:26:10,290
was already a lot of information so we

00:26:07,650 --> 00:26:11,970
wrote already three services that are

00:26:10,290 --> 00:26:15,090
distributed that you can spawn on

00:26:11,970 --> 00:26:19,800
different machines that talk to each

00:26:15,090 --> 00:26:21,270
other that reactive if something changes

00:26:19,800 --> 00:26:24,630
if a new machine comes up with a new

00:26:21,270 --> 00:26:26,850
machine comes down we have a generic and

00:26:24,630 --> 00:26:29,520
shareable API definition with our first

00:26:26,850 --> 00:26:31,710
service so we can simply share either a

00:26:29,520 --> 00:26:35,220
jar with a compiler sources or the

00:26:31,710 --> 00:26:38,670
thrift files that we like to and simply

00:26:35,220 --> 00:26:43,440
use the service but we have hard-coded

00:26:38,670 --> 00:26:46,260
service path so if I want to use or not

00:26:43,440 --> 00:26:48,900
if the service location changes

00:26:46,260 --> 00:26:50,610
I want to put it in another part and

00:26:48,900 --> 00:26:54,299
it's hard to do I have to change all my

00:26:50,610 --> 00:26:56,190
services and restart all of them and at

00:26:54,299 --> 00:26:59,400
the moment we have no way of sending

00:26:56,190 --> 00:27:01,500
requests metadata Sophia everything we

00:26:59,400 --> 00:27:05,130
want to send via thrift we have to put

00:27:01,500 --> 00:27:08,070
it in the methods definition so let's

00:27:05,130 --> 00:27:12,240
tackle the first problem that's request

00:27:08,070 --> 00:27:15,720
routing and we have already seen D taps

00:27:12,240 --> 00:27:16,980
on a few slides and now I will give you

00:27:15,720 --> 00:27:19,010
some more information on what that

00:27:16,980 --> 00:27:24,260
actually is

00:27:19,010 --> 00:27:28,080
delegation tables are a way to resolve

00:27:24,260 --> 00:27:29,790
these paths so as before for negative

00:27:28,080 --> 00:27:33,120
names to identify the network locations

00:27:29,790 --> 00:27:36,540
and a path is simply well it starts with

00:27:33,120 --> 00:27:39,720
a slash and you have to interpret it so

00:27:36,540 --> 00:27:41,460
that it's in the end it's our results

00:27:39,720 --> 00:27:46,020
address that you can open the -

00:27:41,460 --> 00:27:47,250
and the the way delegation teams work

00:27:46,020 --> 00:27:50,280
it's pretty straightforward

00:27:47,250 --> 00:27:52,679
it's basically prefix substitution so if

00:27:50,280 --> 00:27:54,720
you have a source prefix then this

00:27:52,679 --> 00:27:57,750
prefix is replaced with a destination

00:27:54,720 --> 00:27:59,820
and this is exactly what in a delegation

00:27:57,750 --> 00:28:03,270
table entry looks like so in this case

00:27:59,820 --> 00:28:05,120
if we find source a slash source source

00:28:03,270 --> 00:28:07,740
will be replaced with destination

00:28:05,120 --> 00:28:10,740
otherwise so the rule skipped and it

00:28:07,740 --> 00:28:14,400
goes to the next rule and delegating

00:28:10,740 --> 00:28:17,460
tables have some important properties so

00:28:14,400 --> 00:28:19,260
for instance revolving with D tips must

00:28:17,460 --> 00:28:21,150
always terminate so you have to make

00:28:19,260 --> 00:28:22,650
sure that in your delegation tables when

00:28:21,150 --> 00:28:28,559
you define them you don't put any

00:28:22,650 --> 00:28:31,080
recursion in to zero but two rules call

00:28:28,559 --> 00:28:35,400
each other and the resolving won't

00:28:31,080 --> 00:28:38,250
finish and then nothing works the other

00:28:35,400 --> 00:28:40,169
property is details apply from bottom to

00:28:38,250 --> 00:28:42,570
top so if you want to override entries

00:28:40,169 --> 00:28:46,260
you simply append something to the list

00:28:42,570 --> 00:28:49,200
of delegation tables entries and then

00:28:46,260 --> 00:28:52,320
you can override a more generic one at

00:28:49,200 --> 00:28:55,169
the top and the other very the most

00:28:52,320 --> 00:28:57,360
important property is that delegation

00:28:55,169 --> 00:28:59,320
tables are applied for each request and

00:28:57,360 --> 00:29:01,810
this request

00:28:59,320 --> 00:29:03,850
and the delegation table is used for the

00:29:01,810 --> 00:29:06,010
anti request tree afterwards so if you

00:29:03,850 --> 00:29:07,570
overwrite something then it will be

00:29:06,010 --> 00:29:10,930
applied to every following other

00:29:07,570 --> 00:29:13,060
requests and this is very useful for

00:29:10,930 --> 00:29:15,820
instance if you have canary instances

00:29:13,060 --> 00:29:18,970
start up one instance of a new service

00:29:15,820 --> 00:29:20,920
and to delegate and your start your

00:29:18,970 --> 00:29:24,220
request that you want to go to the

00:29:20,920 --> 00:29:26,050
cannery system now all your requests

00:29:24,220 --> 00:29:29,250
don't hit your life system plus it's a

00:29:26,050 --> 00:29:32,140
special cannery system and so you can

00:29:29,250 --> 00:29:35,440
run the same instances of different

00:29:32,140 --> 00:29:37,440
services in multiple environments and

00:29:35,440 --> 00:29:40,270
with a delegation tables you can route

00:29:37,440 --> 00:29:42,820
specifically to there once you want to

00:29:40,270 --> 00:29:45,190
you can do it's bugging very easily you

00:29:42,820 --> 00:29:49,480
can spawn local instances of a service

00:29:45,190 --> 00:29:52,660
and just be part of another whole system

00:29:49,480 --> 00:29:56,580
and just route one request to your local

00:29:52,660 --> 00:29:59,560
service that's important for you so I

00:29:56,580 --> 00:30:01,990
develop on a single service and I can

00:29:59,560 --> 00:30:05,980
reuse the whole test infrastructure with

00:30:01,990 --> 00:30:07,330
details so that's resolving work this is

00:30:05,980 --> 00:30:09,850
a very small example on the right you

00:30:07,330 --> 00:30:13,210
see a fit a kind of bigger delegation

00:30:09,850 --> 00:30:15,730
table and then we start with this path

00:30:13,210 --> 00:30:17,860
so we start from from bottom to top

00:30:15,730 --> 00:30:23,620
it's the first rule we can apply we

00:30:17,860 --> 00:30:26,080
replace this s with hash we again go

00:30:23,620 --> 00:30:27,910
from bottom to top and so on so you

00:30:26,080 --> 00:30:32,890
apply always one rule up to another

00:30:27,910 --> 00:30:36,640
until we end up with this kind of

00:30:32,890 --> 00:30:41,290
structure so the dollar marks the ending

00:30:36,640 --> 00:30:42,610
of resolving a path and the second this

00:30:41,290 --> 00:30:44,080
after the dollar

00:30:42,610 --> 00:30:46,720
there's the implementation of your

00:30:44,080 --> 00:30:49,900
resolver and this is actually what's

00:30:46,720 --> 00:30:51,850
used as well for the zookeeper schema so

00:30:49,900 --> 00:30:54,400
Twitter has a server set implementation

00:30:51,850 --> 00:30:56,110
this takes care of writing stuff to

00:30:54,400 --> 00:30:59,530
zookeeper these service sets and

00:30:56,110 --> 00:31:02,470
resolving and getting them and resolving

00:30:59,530 --> 00:31:04,570
services so service that basically kind

00:31:02,470 --> 00:31:06,490
of looks I think it's Jason and there's

00:31:04,570 --> 00:31:09,940
a host in an address image so it's

00:31:06,490 --> 00:31:12,210
pretty simple but it works along with

00:31:09,940 --> 00:31:15,809
food keeper and

00:31:12,210 --> 00:31:21,059
with this you can resolve your path into

00:31:15,809 --> 00:31:22,649
a name bond which has an address so what

00:31:21,059 --> 00:31:24,029
what's the difference for clients how do

00:31:22,649 --> 00:31:24,509
I create clients now if I can't use the

00:31:24,029 --> 00:31:27,480
schema

00:31:24,509 --> 00:31:30,240
well it's only first of all you have to

00:31:27,480 --> 00:31:32,580
give some delegation tables and there

00:31:30,240 --> 00:31:34,950
are two kinds you can set there is a

00:31:32,580 --> 00:31:38,190
base table this is kind of awkward

00:31:34,950 --> 00:31:40,860
because details or basis is somewhere a

00:31:38,190 --> 00:31:42,419
global variable and you should set it at

00:31:40,860 --> 00:31:44,039
the beginning in your application but

00:31:42,419 --> 00:31:46,110
nobody forbids you to set it anywhere

00:31:44,039 --> 00:31:48,389
else and so you have to be very

00:31:46,110 --> 00:31:50,850
disciplined in this case but this

00:31:48,389 --> 00:31:55,190
delegation table base is used for all

00:31:50,850 --> 00:31:58,679
the requests and then there are local

00:31:55,190 --> 00:32:01,230
delegation table that you can set you

00:31:58,679 --> 00:32:03,929
can specify a delegation table and then

00:32:01,230 --> 00:32:06,059
you specify a code block where this

00:32:03,929 --> 00:32:11,249
delegation table is applied so this is

00:32:06,059 --> 00:32:13,230
for senior request overrides and now the

00:32:11,249 --> 00:32:18,509
client if everything is the same as

00:32:13,230 --> 00:32:22,649
expected but the destination it's now a

00:32:18,509 --> 00:32:26,429
simple path that's /s slash temperature

00:32:22,649 --> 00:32:28,799
and with delegation tables the resolve

00:32:26,429 --> 00:32:31,580
will figure out how to look for for the

00:32:28,799 --> 00:32:34,789
service now so you have your resolving

00:32:31,580 --> 00:32:37,379
decoupled from your actual service

00:32:34,789 --> 00:32:39,990
Association and you have this in a

00:32:37,379 --> 00:32:42,840
special place and that's what delegation

00:32:39,990 --> 00:32:45,869
takes are good for so how to override

00:32:42,840 --> 00:32:49,980
and deep attend and practice so the most

00:32:45,869 --> 00:32:53,659
common way is probably using HTTP and I

00:32:49,980 --> 00:32:56,759
found this just by reading the tests

00:32:53,659 --> 00:32:59,820
yeah it can give a special header which

00:32:56,759 --> 00:33:02,970
is called details of - local and you can

00:32:59,820 --> 00:33:06,029
specify a deeper tea type if you like so

00:33:02,970 --> 00:33:09,200
for our API in the example there's a

00:33:06,029 --> 00:33:13,080
fenetre app as well and we can switch

00:33:09,200 --> 00:33:15,240
the headers and route your request

00:33:13,080 --> 00:33:17,159
depending on what button you clicked to

00:33:15,240 --> 00:33:21,509
different systems are just applying the

00:33:17,159 --> 00:33:23,669
teller so the second thing I want to

00:33:21,509 --> 00:33:24,359
talk about which is very important and

00:33:23,669 --> 00:33:26,370
very useful

00:33:24,359 --> 00:33:29,640
I request contact

00:33:26,370 --> 00:33:33,940
when you define your your services

00:33:29,640 --> 00:33:35,920
through il you don't want to put all

00:33:33,940 --> 00:33:38,080
these meta information into your

00:33:35,920 --> 00:33:40,270
business logic for instance you don't

00:33:38,080 --> 00:33:43,660
want to specify the the request timeout

00:33:40,270 --> 00:33:46,840
or the user authentication requests and

00:33:43,660 --> 00:33:49,059
in every one of your methods that might

00:33:46,840 --> 00:33:53,140
or may use it and this is what requests

00:33:49,059 --> 00:33:55,360
context are for so it's a request scope

00:33:53,140 --> 00:33:58,900
state such as authentication information

00:33:55,360 --> 00:34:03,820
or request deadlines and finagle takes

00:33:58,900 --> 00:34:06,100
care of persisting this and managing the

00:34:03,820 --> 00:34:08,109
state across threads executing trance

00:34:06,100 --> 00:34:11,139
contexts future pools and even between

00:34:08,109 --> 00:34:14,830
client-server boundaries so you have two

00:34:11,139 --> 00:34:17,020
implementations for this a local one

00:34:14,830 --> 00:34:21,550
which is first service

00:34:17,020 --> 00:34:23,109
so it's inter process context in process

00:34:21,550 --> 00:34:25,419
context and you have a broadcast context

00:34:23,109 --> 00:34:26,710
which will be sent over the wire so you

00:34:25,419 --> 00:34:31,480
have to make sure that you don't send

00:34:26,710 --> 00:34:33,990
too many unrelated data but you can

00:34:31,480 --> 00:34:36,730
choose between bills and it's part

00:34:33,990 --> 00:34:39,100
physically so you have to you can access

00:34:36,730 --> 00:34:42,639
it anywhere in your connected service

00:34:39,100 --> 00:34:44,919
this is available to give you a small

00:34:42,639 --> 00:34:49,000
example we will implement a user

00:34:44,919 --> 00:34:50,379
authentication context and we will

00:34:49,000 --> 00:34:52,840
define it as our broadcast

00:34:50,379 --> 00:34:55,800
um context looks pretty straightforward

00:34:52,840 --> 00:34:59,109
so it's just a case class with a user ID

00:34:55,800 --> 00:35:00,609
currently beautifier we haven't seen

00:34:59,109 --> 00:35:02,830
this feature when we started four years

00:35:00,609 --> 00:35:04,540
ago so we implemented our own request

00:35:02,830 --> 00:35:08,109
context which we had actually put in

00:35:04,540 --> 00:35:11,740
every method and check it so which is

00:35:08,109 --> 00:35:14,320
kind of tedious but I think the new

00:35:11,740 --> 00:35:15,730
services got rid of that and we're

00:35:14,320 --> 00:35:20,710
moving to more and more of these

00:35:15,730 --> 00:35:23,410
broadcast contexts how does finagle know

00:35:20,710 --> 00:35:27,700
where to look in your request for this

00:35:23,410 --> 00:35:30,490
context you have to specify a key but

00:35:27,700 --> 00:35:34,210
key take first it takes a type parameter

00:35:30,490 --> 00:35:35,770
which is the actual context so this this

00:35:34,210 --> 00:35:37,840
case is the user context and then you

00:35:35,770 --> 00:35:39,070
give it a string as an identifier and

00:35:37,840 --> 00:35:41,860
best practice you

00:35:39,070 --> 00:35:44,410
to the fully qualified class name so you

00:35:41,860 --> 00:35:47,890
don't get any naming conditions and this

00:35:44,410 --> 00:35:52,690
is used by Finnegan to look up your

00:35:47,890 --> 00:35:55,180
request context in the request then you

00:35:52,690 --> 00:35:57,310
have to implement marshaling and again

00:35:55,180 --> 00:36:00,130
tsunami here is very very low level so

00:35:57,310 --> 00:36:03,100
you have a buffer I think the special

00:36:00,130 --> 00:36:06,490
implementation from finagle but

00:36:03,100 --> 00:36:08,830
basically the array of whites and you

00:36:06,490 --> 00:36:11,070
have to specify how to create this array

00:36:08,830 --> 00:36:15,250
of white from your user context and

00:36:11,070 --> 00:36:20,350
unmarshal is well try to get out I use a

00:36:15,250 --> 00:36:24,010
context from some bytes but again you

00:36:20,350 --> 00:36:25,840
can I think thrift has a good support

00:36:24,010 --> 00:36:28,480
for buffering so if you like you can

00:36:25,840 --> 00:36:30,460
specify thrift months and use the

00:36:28,480 --> 00:36:32,500
encoders and decoders for unn

00:36:30,460 --> 00:36:35,200
marshalling and marshalling so if you

00:36:32,500 --> 00:36:37,930
are not so happy about implementing

00:36:35,200 --> 00:36:40,900
lemon bite stuff you can use an encoder

00:36:37,930 --> 00:36:43,480
or decoder of your choice so how do you

00:36:40,900 --> 00:36:46,480
use it first of all we have to provide

00:36:43,480 --> 00:36:49,720
the context so in this case we create an

00:36:46,480 --> 00:36:52,510
user context and this is again a pattern

00:36:49,720 --> 00:36:56,410
you see a lot more often your context

00:36:52,510 --> 00:36:58,090
broadcast outlet and let's specify in

00:36:56,410 --> 00:37:02,200
this case the the key you want to

00:36:58,090 --> 00:37:06,280
broadcast and the actual context and

00:37:02,200 --> 00:37:08,140
then you have a block where this context

00:37:06,280 --> 00:37:10,510
is applied to other requests to make so

00:37:08,140 --> 00:37:12,940
you can make 10 requests all these 10

00:37:10,510 --> 00:37:15,370
requests will contain this broadcast

00:37:12,940 --> 00:37:18,610
context and this is also the same way

00:37:15,370 --> 00:37:22,360
the details local API works so EFT tips

00:37:18,610 --> 00:37:25,120
dot local got let me give you detail and

00:37:22,360 --> 00:37:27,730
then this block afterwards the t-type

00:37:25,120 --> 00:37:30,730
will be applied and on the server side

00:37:27,730 --> 00:37:32,650
where you want to reach on the server

00:37:30,730 --> 00:37:36,840
side where you want to access others

00:37:32,650 --> 00:37:39,520
again use the user context key and

00:37:36,840 --> 00:37:41,500
current what you have and this gives you

00:37:39,520 --> 00:37:43,600
an option of user context so if you have

00:37:41,500 --> 00:37:47,970
a user context available you can access

00:37:43,600 --> 00:37:47,970
it otherwise you don't have any

00:37:49,880 --> 00:37:58,370
so we kept - so now we know how to to

00:37:54,980 --> 00:38:00,920
root different requests with relegation

00:37:58,370 --> 00:38:03,380
tables which is a very powerful feature

00:38:00,920 --> 00:38:06,980
and we couples a lot of your service

00:38:03,380 --> 00:38:08,480
discovery into single delegation tables

00:38:06,980 --> 00:38:10,940
and not spread it into different

00:38:08,480 --> 00:38:14,570
services and if you may all do things

00:38:10,940 --> 00:38:16,760
differently we can now separate request

00:38:14,570 --> 00:38:20,930
metadata from the business logic with

00:38:16,760 --> 00:38:24,110
request context and implement some

00:38:20,930 --> 00:38:26,750
cross-cutting functionality with that so

00:38:24,110 --> 00:38:28,970
what are the next steps for us we

00:38:26,750 --> 00:38:33,230
started when I started doing this a year

00:38:28,970 --> 00:38:35,390
ago we started in utero we started more

00:38:33,230 --> 00:38:37,670
low-level documentation the finicky dogs

00:38:35,390 --> 00:38:40,730
after admit I hadn't had time to work on

00:38:37,670 --> 00:38:44,090
these last few months but it doesn't

00:38:40,730 --> 00:38:45,770
focus on the technical details and

00:38:44,090 --> 00:38:48,080
implementation details of finagle which

00:38:45,770 --> 00:38:50,510
the finagling documentation remove as

00:38:48,080 --> 00:38:51,110
well it's if you're interested in all

00:38:50,510 --> 00:38:53,390
the details

00:38:51,110 --> 00:38:56,090
you can read it but it's not like okay

00:38:53,390 --> 00:38:57,860
how do I in the small system and plug

00:38:56,090 --> 00:39:01,340
things together what choice do I have

00:38:57,860 --> 00:39:03,920
so we started that that covers these

00:39:01,340 --> 00:39:06,170
issues on how to get us do I get started

00:39:03,920 --> 00:39:08,810
and all the example code I showed today

00:39:06,170 --> 00:39:10,700
is in the repository as well so there

00:39:08,810 --> 00:39:12,890
are very small patterns on how to

00:39:10,700 --> 00:39:14,870
implement the service how to plug them

00:39:12,890 --> 00:39:18,970
together what choices do you have and

00:39:14,870 --> 00:39:22,460
also what what reaches the Finnegan F

00:39:18,970 --> 00:39:24,290
and we try to extend these and write

00:39:22,460 --> 00:39:26,000
even more documentation of that because

00:39:24,290 --> 00:39:28,640
it's also very important for us and for

00:39:26,000 --> 00:39:30,380
other companies SoundCloud in Berlin

00:39:28,640 --> 00:39:34,100
they're also doing a great job on

00:39:30,380 --> 00:39:35,480
writing blog posts on finagle but really

00:39:34,100 --> 00:39:37,730
try to give back something to the

00:39:35,480 --> 00:39:39,290
community and of course we want to

00:39:37,730 --> 00:39:42,710
leverage more of these native features

00:39:39,290 --> 00:39:45,140
in our own codebase discover more and

00:39:42,710 --> 00:39:48,050
more and it's realized a lot of the

00:39:45,140 --> 00:39:50,000
issues we had in our own codebase they

00:39:48,050 --> 00:39:51,710
were already solved by finagle and we

00:39:50,000 --> 00:39:53,900
can just remove our own crappy custom

00:39:51,710 --> 00:39:57,220
code with federal chancellor infinity

00:39:53,900 --> 00:40:00,620
code so these are some resources I

00:39:57,220 --> 00:40:02,900
really recommend checking these out if

00:40:00,620 --> 00:40:03,740
you're interested in too so the last one

00:40:02,900 --> 00:40:06,830
I just edited

00:40:03,740 --> 00:40:08,780
because I also got I wrote exactly this

00:40:06,830 --> 00:40:11,660
talk I wrote as a medium blog post so

00:40:08,780 --> 00:40:15,470
you can read the slides or you can read

00:40:11,660 --> 00:40:18,280
the blog post and yeah there's really

00:40:15,470 --> 00:40:21,740
some nice information the pinnacle 101

00:40:18,280 --> 00:40:26,000
it's pretty good as also one of the main

00:40:21,740 --> 00:40:31,339
tenets of Finch and you really give some

00:40:26,000 --> 00:40:33,920
great insights so don't forget to rate

00:40:31,339 --> 00:40:38,619
what I just told you and then thank you

00:40:33,920 --> 00:40:38,619
for your attention for being here

00:40:39,770 --> 00:40:42,909
[Applause]

00:40:48,190 --> 00:40:56,210
well I have something to ask you about

00:40:51,500 --> 00:40:59,540
some teenagers risk and I I know that

00:40:56,210 --> 00:41:01,490
finagle is enabled risk is different

00:40:59,540 --> 00:41:04,730
from little different from thrift right

00:41:01,490 --> 00:41:07,220
and I want to know why if they'd happen

00:41:04,730 --> 00:41:09,470
like this as the user Apache thrift

00:41:07,220 --> 00:41:11,330
library and at the moment we are

00:41:09,470 --> 00:41:13,250
upgrading our finagle versions to a new

00:41:11,330 --> 00:41:15,410
one and we are starting again with the

00:41:13,250 --> 00:41:17,480
documentation because they're using a

00:41:15,410 --> 00:41:20,330
very old version of thrift for the

00:41:17,480 --> 00:41:22,940
open-source version and but there's a

00:41:20,330 --> 00:41:24,200
quite new version out for Philippa

00:41:22,940 --> 00:41:26,570
thrift and the Scrooge compiler

00:41:24,200 --> 00:41:28,160
recommends using the new version while

00:41:26,570 --> 00:41:30,260
the finagle documentation says you have

00:41:28,160 --> 00:41:31,790
to stay on the old version but so far we

00:41:30,260 --> 00:41:34,339
have migrated to the newest version of

00:41:31,790 --> 00:41:36,680
grift which is the one public available

00:41:34,339 --> 00:41:40,160
answered on maven and everything works

00:41:36,680 --> 00:41:43,220
so far so I'm not sure I think they're

00:41:40,160 --> 00:41:47,780
in some kind of transition for these

00:41:43,220 --> 00:41:49,400
calculus protocols okay see the beanie

00:41:47,780 --> 00:41:53,420
go through these different from this

00:41:49,400 --> 00:41:55,609
thrift right it's a public available

00:41:53,420 --> 00:41:58,820
Java libraries so I think it says the

00:41:55,609 --> 00:42:01,250
normal one there they have a special

00:41:58,820 --> 00:42:02,950
protocol thrift MUX so where they

00:42:01,250 --> 00:42:07,070
implement muxing on the standard

00:42:02,950 --> 00:42:09,589
protocol but I'm not so keen on the very

00:42:07,070 --> 00:42:11,720
details of grift it's just one of the

00:42:09,589 --> 00:42:14,869
protocols we are using so we also use

00:42:11,720 --> 00:42:16,560
the rest client and I think that we try

00:42:14,869 --> 00:42:20,130
to my scale clients

00:42:16,560 --> 00:42:23,370
but we are not so into the technique

00:42:20,130 --> 00:42:25,020
teasers of it because we use t- our of

00:42:23,370 --> 00:42:29,000
our services and they work pretty well

00:42:25,020 --> 00:42:29,000
together and that's what's available

00:42:37,280 --> 00:42:45,689
lamb thanks and enjoy your lunch

00:42:40,780 --> 00:42:45,689

YouTube URL: https://www.youtube.com/watch?v=zcoE-wq7RF8


