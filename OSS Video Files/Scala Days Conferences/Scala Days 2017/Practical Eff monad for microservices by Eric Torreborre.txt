Title: Practical Eff monad for microservices by Eric Torreborre
Publication date: 2017-06-06
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
"These crazy FP concepts are very interesting but how do I apply them to my job at XYZ?" Indeed, it is one thing to learn what a "catamorphism" or a "natural transformation" is, and another one to use it in our daily programming. 

In this talk you will learn how to decompose a REST microservice into several components: authentication, request to other services and database access. Then we will use the Eff monad to precisely define the interface of these components and support additional concerns like logging or asynchronous execution. 

Once you get the basic idea, the possibilities are endless! Rate limiting is just another component and another set of effects involving time and state. And testing is so much easier: no execution context or mocks!
Captions: 
	00:00:00,030 --> 00:00:05,759
okay let's start hi everyone so my name

00:00:03,330 --> 00:00:09,030
is Eric and today I want to talk to you

00:00:05,759 --> 00:00:12,960
about the F monads but for real not in

00:00:09,030 --> 00:00:14,700
theory for real so last year I did a

00:00:12,960 --> 00:00:17,070
presentation on the esplanade Express

00:00:14,700 --> 00:00:19,880
showing how it compared to mana

00:00:17,070 --> 00:00:22,949
transformers well I think it's better

00:00:19,880 --> 00:00:26,039
explaining that it's an can implement

00:00:22,949 --> 00:00:28,230
extensible effects that it uses the type

00:00:26,039 --> 00:00:30,510
system to run with the interpreters and

00:00:28,230 --> 00:00:32,070
so on so and if you came out of that

00:00:30,510 --> 00:00:34,860
talk you might think oh that's that's

00:00:32,070 --> 00:00:37,620
interesting that's one that's quite

00:00:34,860 --> 00:00:39,570
interesting but I mean how can that how

00:00:37,620 --> 00:00:42,480
can I use this concretely when I'm back

00:00:39,570 --> 00:00:44,700
at work how can I use that to structure

00:00:42,480 --> 00:00:47,430
my program where do I start what do I do

00:00:44,700 --> 00:00:49,350
so I thought that it would be

00:00:47,430 --> 00:00:52,050
interesting to show how we are using it

00:00:49,350 --> 00:00:55,440
at the nando which is my company so that

00:00:52,050 --> 00:00:57,750
under is an online fashion store serving

00:00:55,440 --> 00:01:00,210
lots and lots of customers in Europe we

00:00:57,750 --> 00:01:03,570
have an incredible number of employees

00:01:00,210 --> 00:01:07,320
but on that number of employees we have

00:01:03,570 --> 00:01:09,420
more than 1,200 engineers so we do lots

00:01:07,320 --> 00:01:11,430
and lots of software internally for the

00:01:09,420 --> 00:01:14,580
warehouse for the backend systems and so

00:01:11,430 --> 00:01:16,200
on and more precisely and parts of this

00:01:14,580 --> 00:01:18,330
department burn solutions where we

00:01:16,200 --> 00:01:21,210
helped merchants and both their own

00:01:18,330 --> 00:01:23,369
articles on the platform so adidas can

00:01:21,210 --> 00:01:26,340
sell their own stuff even the small

00:01:23,369 --> 00:01:29,070
retailer retailer can hop on the

00:01:26,340 --> 00:01:32,520
platform and sell a pair of shoes for

00:01:29,070 --> 00:01:35,369
example and last year we had to build a

00:01:32,520 --> 00:01:38,189
very small service called the optical

00:01:35,369 --> 00:01:40,890
service because we recently started the

00:01:38,189 --> 00:01:43,500
full I mean recently two years ago a

00:01:40,890 --> 00:01:45,860
full change of the full platform which

00:01:43,500 --> 00:01:49,680
was a big monolith and it started to be

00:01:45,860 --> 00:01:52,829
cut out into small smaller services

00:01:49,680 --> 00:01:55,259
using micro services and even buses and

00:01:52,829 --> 00:01:58,560
all of that and article services is one

00:01:55,259 --> 00:02:00,990
of those services and it is kind of

00:01:58,560 --> 00:02:03,719
simple so if you are merchants and you

00:02:00,990 --> 00:02:07,380
say I have 10 pair of shoes I can sell

00:02:03,719 --> 00:02:08,910
with that price already registered we

00:02:07,380 --> 00:02:10,860
know what shoes we're talking about

00:02:08,910 --> 00:02:14,080
I'm just declaring this a half 10 choose

00:02:10,860 --> 00:02:16,390
and they are like 60 euros

00:02:14,080 --> 00:02:18,610
so the article surveys take this

00:02:16,390 --> 00:02:20,200
information and informs the backend

00:02:18,610 --> 00:02:23,290
systems and then you can sell the shoes

00:02:20,200 --> 00:02:25,210
on the on the platform that's nice but

00:02:23,290 --> 00:02:27,250
it's actually bit more tricky than this

00:02:25,210 --> 00:02:30,160
because as I said the the backend

00:02:27,250 --> 00:02:30,730
systems used to be one huge Postgres

00:02:30,160 --> 00:02:33,310
Java

00:02:30,730 --> 00:02:36,040
Manolis and now it's a bunch of small

00:02:33,310 --> 00:02:38,110
systems one for the catalog one for the

00:02:36,040 --> 00:02:39,910
business partners want to handle the

00:02:38,110 --> 00:02:42,850
stocks one for the prices and so on and

00:02:39,910 --> 00:02:46,480
so forth so this service that we are

00:02:42,850 --> 00:02:48,910
about to build is built on not so firm

00:02:46,480 --> 00:02:50,440
foundation because everything in the

00:02:48,910 --> 00:02:53,950
backend is going to change throughout

00:02:50,440 --> 00:02:55,810
the year so not only we have all the

00:02:53,950 --> 00:02:57,490
complexity of building in microservice

00:02:55,810 --> 00:02:59,950
with what that means in terms of

00:02:57,490 --> 00:03:03,130
security reliability performance

00:02:59,950 --> 00:03:05,490
scalability you name it but also on a

00:03:03,130 --> 00:03:08,590
platform that's constantly moving behind

00:03:05,490 --> 00:03:10,540
so oh yes and we have one additional

00:03:08,590 --> 00:03:13,000
constraint we need to build this for

00:03:10,540 --> 00:03:14,800
yesterday so it needs to come fast

00:03:13,000 --> 00:03:16,420
because that's like the first step of

00:03:14,800 --> 00:03:18,700
the integration of merchants on the

00:03:16,420 --> 00:03:20,530
platform so what do you do when you have

00:03:18,700 --> 00:03:23,709
all of those constraints all at once

00:03:20,530 --> 00:03:25,270
well we panic yeah what am I going to do

00:03:23,709 --> 00:03:27,820
what can I do what can I use what kind

00:03:25,270 --> 00:03:30,489
of magical technique and I used to write

00:03:27,820 --> 00:03:32,739
my service and actually there is one

00:03:30,489 --> 00:03:35,590
magical technique one thing that has

00:03:32,739 --> 00:03:38,980
been proven to be very very useful just

00:03:35,590 --> 00:03:41,530
use components and maybe you turn to

00:03:38,980 --> 00:03:43,209
some good old paper describing what

00:03:41,530 --> 00:03:46,030
components should be and how you can

00:03:43,209 --> 00:03:47,770
take your system apart into components

00:03:46,030 --> 00:03:50,110
which make sense and if you read that

00:03:47,770 --> 00:03:51,820
paper you realize that it's not only

00:03:50,110 --> 00:03:54,750
what the component does but it's also

00:03:51,820 --> 00:03:57,430
what it's hiding what kind of change it

00:03:54,750 --> 00:03:59,320
protects you from and this is how you

00:03:57,430 --> 00:04:01,780
should structure your system so I

00:03:59,320 --> 00:04:03,820
suspect that if you hear all eric is

00:04:01,780 --> 00:04:06,610
building a system with components you're

00:04:03,820 --> 00:04:09,000
honoring Oh what should we use what was

00:04:06,610 --> 00:04:11,620
he using for the I dependency injection

00:04:09,000 --> 00:04:13,269
if you're already using dotty and all

00:04:11,620 --> 00:04:16,359
the implicit stuff that marking showed

00:04:13,269 --> 00:04:18,180
at the keynotes well maybe is using an

00:04:16,359 --> 00:04:23,740
elaborate version of the cake pattern

00:04:18,180 --> 00:04:26,650
maybe maybe not or juice or just just

00:04:23,740 --> 00:04:29,020
gave up and gave went back to spring and

00:04:26,650 --> 00:04:31,960
okay let's do it in Java at least we

00:04:29,020 --> 00:04:34,330
know how to do this so we decided for

00:04:31,960 --> 00:04:37,570
that project to do something very very

00:04:34,330 --> 00:04:40,060
radical something new constructor

00:04:37,570 --> 00:04:41,949
injection something never done before so

00:04:40,060 --> 00:04:43,720
the question is what is wrong with

00:04:41,949 --> 00:04:46,479
constructor injection to build our

00:04:43,720 --> 00:04:48,460
components after all what is why is it's

00:04:46,479 --> 00:04:51,190
not the right thing to do so we try to

00:04:48,460 --> 00:04:54,040
revisit this question for this service

00:04:51,190 --> 00:04:56,320
because after all constructor injection

00:04:54,040 --> 00:04:59,050
especially in skylight is very simple to

00:04:56,320 --> 00:05:01,560
create you can easily create case

00:04:59,050 --> 00:05:05,550
classes representing your configuration

00:05:01,560 --> 00:05:08,070
you can have configuration based

00:05:05,550 --> 00:05:11,430
containing all sorts of data inside and

00:05:08,070 --> 00:05:13,300
say you have a production configuration

00:05:11,430 --> 00:05:15,580
containing your thread pool for

00:05:13,300 --> 00:05:18,250
configuration then you have an HTTP

00:05:15,580 --> 00:05:20,800
client with one thread pool that's one

00:05:18,250 --> 00:05:23,590
of your components okay just a case

00:05:20,800 --> 00:05:26,110
class and you say how do i build an HDD

00:05:23,590 --> 00:05:28,240
client well it's easy give me the big

00:05:26,110 --> 00:05:30,250
config I know how to extract a thread

00:05:28,240 --> 00:05:33,370
pool configuration from it then I have

00:05:30,250 --> 00:05:38,440
my HTTP client that's actually pretty

00:05:33,370 --> 00:05:39,820
easy so starting from this idea we said

00:05:38,440 --> 00:05:42,039
okay let's change a little bit the

00:05:39,820 --> 00:05:44,800
signature of this and let's use a reader

00:05:42,039 --> 00:05:47,889
which is basically wizards just just a

00:05:44,800 --> 00:05:50,020
function so reader of config - HTTP

00:05:47,889 --> 00:05:51,880
client is just a function taking

00:05:50,020 --> 00:05:55,660
accounting and returning an HTTP client

00:05:51,880 --> 00:05:58,320
so if you write things like that and if

00:05:55,660 --> 00:06:02,050
we write our configuration like that

00:05:58,320 --> 00:06:04,810
then we can use library that we created

00:06:02,050 --> 00:06:06,789
to remove basically all the boilerplate

00:06:04,810 --> 00:06:11,289
that you would have by just using

00:06:06,789 --> 00:06:13,780
readers and we can use shapeless in this

00:06:11,289 --> 00:06:16,330
library called raster to create those

00:06:13,780 --> 00:06:18,039
with your influences so if you have a

00:06:16,330 --> 00:06:19,360
case class which represents the

00:06:18,039 --> 00:06:22,419
components having all sorts of

00:06:19,360 --> 00:06:24,760
dependencies shapeless is going to

00:06:22,419 --> 00:06:27,220
analyze this case class fetch all the

00:06:24,760 --> 00:06:28,900
dependencies and create a reader for

00:06:27,220 --> 00:06:30,550
your case class provided that there are

00:06:28,900 --> 00:06:32,050
readers for all the dependencies and

00:06:30,550 --> 00:06:32,400
it's going to go through the graph like

00:06:32,050 --> 00:06:35,289
this

00:06:32,400 --> 00:06:37,599
recursively and with just one call to

00:06:35,289 --> 00:06:39,950
generic reader you have your generic

00:06:37,599 --> 00:06:42,980
reader you have your reader for the

00:06:39,950 --> 00:06:45,320
to the client and it's one nice thing

00:06:42,980 --> 00:06:46,340
about this is that this line of code is

00:06:45,320 --> 00:06:48,110
never going to change

00:06:46,340 --> 00:06:50,720
so if you change your application later

00:06:48,110 --> 00:06:53,470
on add more dependencies or remove less

00:06:50,720 --> 00:06:56,750
this line is always going to be the same

00:06:53,470 --> 00:06:59,360
so you have let's go to to modify so

00:06:56,750 --> 00:07:01,430
once you have a reader for this o and we

00:06:59,360 --> 00:07:03,710
created an annotation for this because

00:07:01,430 --> 00:07:05,240
it was also too much boilerplate for us

00:07:03,710 --> 00:07:07,160
so this annotation is basically with

00:07:05,240 --> 00:07:10,700
doing exactly the same thing just

00:07:07,160 --> 00:07:13,220
shorter and then we can have a component

00:07:10,700 --> 00:07:16,190
using another component so server using

00:07:13,220 --> 00:07:20,840
a client again using the same annotation

00:07:16,190 --> 00:07:23,480
which is basically saying oh if I have a

00:07:20,840 --> 00:07:25,310
way to build my client from a config

00:07:23,480 --> 00:07:27,290
then I have a way to build my server

00:07:25,310 --> 00:07:30,500
from the country that's basically what

00:07:27,290 --> 00:07:32,660
it's saying and at the top level of your

00:07:30,500 --> 00:07:35,960
application you create a configuration

00:07:32,660 --> 00:07:37,910
for production for example you take your

00:07:35,960 --> 00:07:39,740
reader you pass it the reader and then

00:07:37,910 --> 00:07:43,460
you have your HTTP server which you can

00:07:39,740 --> 00:07:46,990
start right so it's actually fairly easy

00:07:43,460 --> 00:07:49,520
just using functions with a bit of

00:07:46,990 --> 00:07:53,720
syntactic sugar using shapeless to

00:07:49,520 --> 00:07:55,850
remove all the boilerplate but that's

00:07:53,720 --> 00:07:57,950
just two level and our application is

00:07:55,850 --> 00:08:00,530
slightly more complex it's like it's a

00:07:57,950 --> 00:08:02,960
REST API so it has an HTTP server it has

00:08:00,530 --> 00:08:04,760
different routes which route is doing

00:08:02,960 --> 00:08:07,100
something different so it uses some

00:08:04,760 --> 00:08:09,820
services implementing the business logic

00:08:07,100 --> 00:08:12,740
and then we have different clients

00:08:09,820 --> 00:08:14,780
talking to the backend and this is where

00:08:12,740 --> 00:08:17,540
having a nice decomposition in terms of

00:08:14,780 --> 00:08:19,880
independent components starts to pay off

00:08:17,540 --> 00:08:22,580
because if the back-end systems are

00:08:19,880 --> 00:08:25,370
evolving we can change the clients with

00:08:22,580 --> 00:08:27,500
other clients and then the rest of the

00:08:25,370 --> 00:08:29,720
architecture is left and changed because

00:08:27,500 --> 00:08:32,930
then has I don't have to change my route

00:08:29,720 --> 00:08:34,760
if an underlying client talks to another

00:08:32,930 --> 00:08:38,120
service and not to the same service as

00:08:34,760 --> 00:08:40,640
before so let's see the route

00:08:38,120 --> 00:08:44,630
implementation so the the right is just

00:08:40,640 --> 00:08:47,000
another component using the price HTTP

00:08:44,630 --> 00:08:48,560
service as a dependency and the job of

00:08:47,000 --> 00:08:51,920
these components is just to take the

00:08:48,560 --> 00:08:53,370
incoming HTTP requests parties extract

00:08:51,920 --> 00:08:56,640
the relevant parameter

00:08:53,370 --> 00:09:00,540
and and then pass the parameters to the

00:08:56,640 --> 00:09:02,760
HTTP service that it's only job but if

00:09:00,540 --> 00:09:05,190
you want to test this you don't really

00:09:02,760 --> 00:09:07,470
need to have a full-blown priced HTTP

00:09:05,190 --> 00:09:10,110
service right you just need to have an

00:09:07,470 --> 00:09:12,690
interface containing the method get

00:09:10,110 --> 00:09:14,000
price that's the only thing you need so

00:09:12,690 --> 00:09:17,130
this is where you can start introducing

00:09:14,000 --> 00:09:18,930
interfaces in your components so you

00:09:17,130 --> 00:09:20,610
have a price HTTP service that's an

00:09:18,930 --> 00:09:23,100
interface and then there's an

00:09:20,610 --> 00:09:25,980
implementation for it using HTTP for us

00:09:23,100 --> 00:09:29,040
for example here is the implementation

00:09:25,980 --> 00:09:31,920
so again the implementation has other

00:09:29,040 --> 00:09:35,460
dependencies to do its job so it's again

00:09:31,920 --> 00:09:38,550
a case class extending an interface we

00:09:35,460 --> 00:09:40,740
are not using mixing composition we are

00:09:38,550 --> 00:09:42,630
never implementing anything in trades

00:09:40,740 --> 00:09:44,670
all the implementation stays at the

00:09:42,630 --> 00:09:47,910
level of the case class so again it's

00:09:44,670 --> 00:09:51,150
using some simple basic scalar

00:09:47,910 --> 00:09:52,020
constructs and we can get a reader from

00:09:51,150 --> 00:09:54,800
it again

00:09:52,020 --> 00:09:56,640
that's being computed via the annotation

00:09:54,800 --> 00:09:59,730
there's one problem though

00:09:56,640 --> 00:10:01,590
we still need to in order to create all

00:09:59,730 --> 00:10:04,200
route component we still need to get an

00:10:01,590 --> 00:10:06,900
instance of the price HTTP service at

00:10:04,200 --> 00:10:09,990
some stage which is just an interface so

00:10:06,900 --> 00:10:11,640
in all this reader configuration at some

00:10:09,990 --> 00:10:14,760
stage we still need to be able to tell

00:10:11,640 --> 00:10:17,970
all for this interface use this default

00:10:14,760 --> 00:10:21,270
implementation and this is kind of hard

00:10:17,970 --> 00:10:23,400
coded in in our reader declaration so

00:10:21,270 --> 00:10:26,010
here we say every time you need a price

00:10:23,400 --> 00:10:27,660
SGP service please use the one from HTTP

00:10:26,010 --> 00:10:30,390
for us so this is a style of

00:10:27,660 --> 00:10:32,880
configuration where by default for any

00:10:30,390 --> 00:10:36,150
interface you should always specify at

00:10:32,880 --> 00:10:38,640
least one one implementation but it

00:10:36,150 --> 00:10:40,530
cannot make sense that in the systems we

00:10:38,640 --> 00:10:42,510
are building many times there are

00:10:40,530 --> 00:10:43,740
something which is like the production

00:10:42,510 --> 00:10:46,260
implementation or the default

00:10:43,740 --> 00:10:48,380
implementation for something and then

00:10:46,260 --> 00:10:52,080
we'll see how we can replace it later on

00:10:48,380 --> 00:10:54,060
so there is always one default another

00:10:52,080 --> 00:10:56,490
question so using readers again

00:10:54,060 --> 00:10:58,440
interesting but you might have some

00:10:56,490 --> 00:11:00,180
questions what happens if I want to put

00:10:58,440 --> 00:11:03,060
my steepy client now in a library

00:11:00,180 --> 00:11:05,410
because we've seen that with the

00:11:03,060 --> 00:11:08,379
annotation or with shell plus we have

00:11:05,410 --> 00:11:10,329
reader of config to httpclient but if I

00:11:08,379 --> 00:11:12,250
put my CP client in a library I don't

00:11:10,329 --> 00:11:15,069
know what my configuration type is

00:11:12,250 --> 00:11:18,069
because this is in the client code this

00:11:15,069 --> 00:11:21,160
I don't know what it is so does this

00:11:18,069 --> 00:11:23,860
approach kill work actually does because

00:11:21,160 --> 00:11:28,199
you can create a reader where you just

00:11:23,860 --> 00:11:31,269
say I know how to build an HTTP client

00:11:28,199 --> 00:11:32,050
provided I have an a I don't know what

00:11:31,269 --> 00:11:34,839
that is yet

00:11:32,050 --> 00:11:37,509
and if from that a I'm able to extract

00:11:34,839 --> 00:11:39,160
the thread pool configuration I will

00:11:37,509 --> 00:11:41,310
know how to build the HTTP client and

00:11:39,160 --> 00:11:43,540
again you just choose the generic reader

00:11:41,310 --> 00:11:45,939
implementation and shapeless is going to

00:11:43,540 --> 00:11:48,459
build that reader from you using the one

00:11:45,939 --> 00:11:50,680
that's passed implicitly so this is in

00:11:48,459 --> 00:11:53,160
your library and in your client code

00:11:50,680 --> 00:11:56,379
using the library provided that you

00:11:53,160 --> 00:11:58,449
provide this reader knowing how to

00:11:56,379 --> 00:12:00,790
extract the thread pool from the large

00:11:58,449 --> 00:12:02,860
configuration thanks to implicit

00:12:00,790 --> 00:12:05,589
resolution everything will be found and

00:12:02,860 --> 00:12:08,649
you will be able to build your CDP

00:12:05,589 --> 00:12:11,380
server even if one component comes from

00:12:08,649 --> 00:12:14,680
a library this will still work so that's

00:12:11,380 --> 00:12:16,689
quite nice and this means that the only

00:12:14,680 --> 00:12:18,430
thing we need to build our initial graph

00:12:16,689 --> 00:12:21,910
representing the application is just

00:12:18,430 --> 00:12:24,819
readers and this works readers all the

00:12:21,910 --> 00:12:26,589
way down but are we done yet

00:12:24,819 --> 00:12:29,500
when I heard Martin talk about

00:12:26,589 --> 00:12:31,360
configuration yesterday using implicit I

00:12:29,500 --> 00:12:33,850
thought oh that's nice it's a nice idea

00:12:31,360 --> 00:12:35,589
but that's not all there is to say about

00:12:33,850 --> 00:12:38,350
dependency injection because we have

00:12:35,589 --> 00:12:40,089
other issues to solve actually one of

00:12:38,350 --> 00:12:42,730
them is already so for us it's unit

00:12:40,089 --> 00:12:45,250
testing how do i unit test my components

00:12:42,730 --> 00:12:47,769
my case classes maybe extending mr.

00:12:45,250 --> 00:12:49,689
interfaces representing a component well

00:12:47,769 --> 00:12:52,660
that one is easy because constructor

00:12:49,689 --> 00:12:56,019
injection is exactly the easiest thing

00:12:52,660 --> 00:12:57,939
to have for unit testing just in the

00:12:56,019 --> 00:13:00,399
case of the route I just provide a mock

00:12:57,939 --> 00:13:03,779
implementation from for my service and

00:13:00,399 --> 00:13:07,089
I'm done so unit testing is releasing

00:13:03,779 --> 00:13:09,160
more difficulties integration testing so

00:13:07,089 --> 00:13:12,309
in that case when you want to test

00:13:09,160 --> 00:13:14,199
several components together and you want

00:13:12,309 --> 00:13:16,809
to replace some of them but they are

00:13:14,199 --> 00:13:18,220
very very low in the tree you actually

00:13:16,809 --> 00:13:20,350
you don't want to

00:13:18,220 --> 00:13:22,180
use normal clients talking to the

00:13:20,350 --> 00:13:23,920
authentication system or to the price

00:13:22,180 --> 00:13:25,810
system just want to use mocks for that

00:13:23,920 --> 00:13:28,090
marks that are going to behave nicely

00:13:25,810 --> 00:13:30,490
for example almost up that are going to

00:13:28,090 --> 00:13:33,160
to behave to introduce failures because

00:13:30,490 --> 00:13:34,990
you want to taste to test that - how did

00:13:33,160 --> 00:13:36,880
you replace that if you normally if you

00:13:34,990 --> 00:13:38,590
just have constructor injection it's

00:13:36,880 --> 00:13:40,240
very tedious that's why people they

00:13:38,590 --> 00:13:41,830
don't like consort injection because you

00:13:40,240 --> 00:13:44,230
have to manually rebuild the full tree

00:13:41,830 --> 00:13:47,680
just saying what you want and here your

00:13:44,230 --> 00:13:49,920
readers they won't help you at all so it

00:13:47,680 --> 00:13:52,420
looks like you're back to square one so

00:13:49,920 --> 00:13:54,520
fortunately in Scala we can do something

00:13:52,420 --> 00:13:57,490
else because this is a tree we can do

00:13:54,520 --> 00:13:59,980
tree rewriting after all or application

00:13:57,490 --> 00:14:01,990
this tree this is just a data structure

00:13:59,980 --> 00:14:04,270
like any other data structure so let's

00:14:01,990 --> 00:14:06,160
do something with it and it turns out

00:14:04,270 --> 00:14:08,260
that there is a very very nice library

00:14:06,160 --> 00:14:10,450
in Scala called qiyamah doing exactly

00:14:08,260 --> 00:14:12,940
this so there are many tools in the

00:14:10,450 --> 00:14:16,390
Kiama library but one of them is all

00:14:12,940 --> 00:14:17,290
sorts of things for rewriting trees so

00:14:16,390 --> 00:14:18,610
what can we do

00:14:17,290 --> 00:14:22,540
so in qiyamah you can describe

00:14:18,610 --> 00:14:25,330
strategies to rewrite trees and one

00:14:22,540 --> 00:14:26,950
strategy that we can write is replace

00:14:25,330 --> 00:14:28,720
strategy so let's say you want to

00:14:26,950 --> 00:14:30,610
replace a node with something else

00:14:28,720 --> 00:14:32,890
you use this strategy and basically this

00:14:30,610 --> 00:14:35,050
strategy says ok walk down the tree

00:14:32,890 --> 00:14:37,510
every time you find a node with that

00:14:35,050 --> 00:14:39,760
type replace it with this value that I

00:14:37,510 --> 00:14:42,640
gave you a knock for example and

00:14:39,760 --> 00:14:44,950
otherwise you don't do anything and then

00:14:42,640 --> 00:14:46,450
you call rewrite and rewrite is going to

00:14:44,950 --> 00:14:48,670
write the full tree doing all the

00:14:46,450 --> 00:14:51,730
replacements where you want and with a

00:14:48,670 --> 00:14:54,790
bit of syntactic sugar it comes it

00:14:51,730 --> 00:14:56,860
becomes very easy to to create a full

00:14:54,790 --> 00:14:58,840
instance of the application with just a

00:14:56,860 --> 00:15:01,300
few nodes being replaced for integration

00:14:58,840 --> 00:15:03,040
testing and you say oh here I want to

00:15:01,300 --> 00:15:06,160
mock my price service I don't need the

00:15:03,040 --> 00:15:08,440
real thing and it's just one line and I

00:15:06,160 --> 00:15:11,140
mean the good effect of this is that the

00:15:08,440 --> 00:15:12,850
easier the tests are to write the more

00:15:11,140 --> 00:15:14,560
likely you have that they will be

00:15:12,850 --> 00:15:16,720
written but someone will want to write

00:15:14,560 --> 00:15:19,180
them because it's easy so that's

00:15:16,720 --> 00:15:21,520
something that's very desirable so

00:15:19,180 --> 00:15:23,500
that's good but it's not the only

00:15:21,520 --> 00:15:26,860
problem that we want to solve because

00:15:23,500 --> 00:15:29,260
with the readers it looks nice we have a

00:15:26,860 --> 00:15:30,430
nice tree of things but most of the time

00:15:29,260 --> 00:15:31,690
actually you don't want the tree for

00:15:30,430 --> 00:15:34,300
your application the

00:15:31,690 --> 00:15:36,910
some of the things you don't want them

00:15:34,300 --> 00:15:38,740
to be several times in your graph like

00:15:36,910 --> 00:15:40,540
an execution context you don't want to

00:15:38,740 --> 00:15:42,400
have 100 execution context in your graph

00:15:40,540 --> 00:15:44,710
you don't want to have 10 databases

00:15:42,400 --> 00:15:47,140
components in your graph you want just

00:15:44,710 --> 00:15:49,210
one because the whole resources most of

00:15:47,140 --> 00:15:52,120
the time so you want to be able to make

00:15:49,210 --> 00:15:55,000
single items so how do you do that well

00:15:52,120 --> 00:15:57,640
not so different you just use rewriting

00:15:55,000 --> 00:15:59,650
again and another strategy and this one

00:15:57,640 --> 00:16:02,500
is saying okay now you walk down the

00:15:59,650 --> 00:16:04,870
tree the first time you found you find a

00:16:02,500 --> 00:16:07,540
component of that type you just keep it

00:16:04,870 --> 00:16:09,010
on the side in a variable and then you

00:16:07,540 --> 00:16:10,900
go on walking the tree if you find

00:16:09,010 --> 00:16:12,550
another component of that type you

00:16:10,900 --> 00:16:15,190
replace it with the first one you found

00:16:12,550 --> 00:16:17,050
and the effect of doing this on the full

00:16:15,190 --> 00:16:19,870
tree will be to make Singleton's

00:16:17,050 --> 00:16:21,850
everywhere you want and again because

00:16:19,870 --> 00:16:24,160
this is something that's very useful and

00:16:21,850 --> 00:16:26,590
you want probably to do for many major

00:16:24,160 --> 00:16:28,210
components in your graph there is one

00:16:26,590 --> 00:16:29,950
shortcut method called single items

00:16:28,210 --> 00:16:32,020
that's going to do exactly this and

00:16:29,950 --> 00:16:34,090
that's going to be smart enough to stop

00:16:32,020 --> 00:16:36,130
where you don't want it to make single

00:16:34,090 --> 00:16:38,500
items like for example you don't want

00:16:36,130 --> 00:16:40,210
all the URLs to become one because it

00:16:38,500 --> 00:16:43,480
will point everything to the same

00:16:40,210 --> 00:16:45,130
service that's really bad so it's there

00:16:43,480 --> 00:16:49,660
there are ways to specify exactly what

00:16:45,130 --> 00:16:51,610
you want to do here and also after

00:16:49,660 --> 00:16:53,830
you've made Singleton's you realize that

00:16:51,610 --> 00:16:55,810
sometimes you also want something some

00:16:53,830 --> 00:16:57,640
other things to be different you might

00:16:55,810 --> 00:16:59,350
not want to have all the components

00:16:57,640 --> 00:17:01,660
configured with the same thread pool

00:16:59,350 --> 00:17:03,460
because it's kind of useful to have

00:17:01,660 --> 00:17:06,280
separate distinct thread post depending

00:17:03,460 --> 00:17:09,880
on if they are like doing operations

00:17:06,280 --> 00:17:11,830
that are more completed intensive in

00:17:09,880 --> 00:17:14,350
terms of computations or doing more IO

00:17:11,830 --> 00:17:16,450
and so on so in that case you can use

00:17:14,350 --> 00:17:19,720
the modify operation to walk down the

00:17:16,450 --> 00:17:22,630
three and say oh here I have an HTTP

00:17:19,720 --> 00:17:25,000
server component please set this thread

00:17:22,630 --> 00:17:26,800
pool for my clients I want to set

00:17:25,000 --> 00:17:29,920
another thread pool for the database yet

00:17:26,800 --> 00:17:32,830
another so in a very small amount of

00:17:29,920 --> 00:17:34,570
lines you can rewrite all the tree to

00:17:32,830 --> 00:17:36,880
make the number of things lessons you

00:17:34,570 --> 00:17:38,710
want to modify the parts you want to

00:17:36,880 --> 00:17:40,990
modify in your tree and then you have

00:17:38,710 --> 00:17:41,920
your fully configured application which

00:17:40,990 --> 00:17:44,530
is quite nice

00:17:41,920 --> 00:17:45,070
but also quite dangerous because it is

00:17:44,530 --> 00:17:47,350
all

00:17:45,070 --> 00:17:49,270
of kind of dynamic so you still need to

00:17:47,350 --> 00:17:50,770
test what you've been doing so for

00:17:49,270 --> 00:17:53,260
testing we have different things there

00:17:50,770 --> 00:17:56,020
are ways to query the tree and you can

00:17:53,260 --> 00:17:58,360
also represent your application as a

00:17:56,020 --> 00:18:01,090
graph so this is one example from

00:17:58,360 --> 00:18:03,430
another another service and you can

00:18:01,090 --> 00:18:05,530
inspect the tree and see if it's exactly

00:18:03,430 --> 00:18:07,450
what you want if it has the kind of

00:18:05,530 --> 00:18:10,450
structure you think it should be it

00:18:07,450 --> 00:18:12,550
should have and if for example all the

00:18:10,450 --> 00:18:14,800
the arrows are really pointing to one

00:18:12,550 --> 00:18:17,440
database component and not too many so

00:18:14,800 --> 00:18:22,360
that's something you can do with with

00:18:17,440 --> 00:18:24,580
this library again and one very

00:18:22,360 --> 00:18:27,370
important component of doing all of this

00:18:24,580 --> 00:18:29,710
is that everything should be lazy you

00:18:27,370 --> 00:18:31,960
should never never start any resource

00:18:29,710 --> 00:18:33,550
any kind of action any kind of

00:18:31,960 --> 00:18:35,560
computation when you create your

00:18:33,550 --> 00:18:38,110
components that's that's very good

00:18:35,560 --> 00:18:39,790
practice and the reason is that the

00:18:38,110 --> 00:18:42,100
first time you Institute your tree if

00:18:39,790 --> 00:18:44,620
you rewrite it every time you might just

00:18:42,100 --> 00:18:46,510
start sending events consuming events or

00:18:44,620 --> 00:18:50,380
whatever so you want all your components

00:18:46,510 --> 00:18:51,850
to be completely side-effect free when

00:18:50,380 --> 00:18:53,830
they are associated they don't do

00:18:51,850 --> 00:18:55,570
anything and then you can rewrite as

00:18:53,830 --> 00:18:57,370
much as you want so for things like

00:18:55,570 --> 00:18:59,890
addiction context you need to

00:18:57,370 --> 00:19:03,100
encapsulate them so that everything is

00:18:59,890 --> 00:19:05,680
lazy using a cat that evil or lazy

00:19:03,100 --> 00:19:09,730
valves whatever everything needs to be

00:19:05,680 --> 00:19:12,580
lazy and it's only once you've created

00:19:09,730 --> 00:19:14,530
Oriol 3-methyl items we wrote what you

00:19:12,580 --> 00:19:16,570
wanted to rewrote rewrite in terms of

00:19:14,530 --> 00:19:19,990
configuration that you can decide to

00:19:16,570 --> 00:19:21,670
start your application and again how do

00:19:19,990 --> 00:19:24,760
you start the application it's another

00:19:21,670 --> 00:19:27,190
strategy so if you implement the start

00:19:24,760 --> 00:19:29,680
interface provide the start methods

00:19:27,190 --> 00:19:32,170
there is a start strategy that's going

00:19:29,680 --> 00:19:34,030
to work down the tree and say oh every

00:19:32,170 --> 00:19:35,890
time I find a note that's implementing

00:19:34,030 --> 00:19:37,930
that interface I'm just calling the

00:19:35,890 --> 00:19:40,300
start method and I'm calling this

00:19:37,930 --> 00:19:42,310
strategy top to bottom and I'm also

00:19:40,300 --> 00:19:44,530
collecting the results of starting the

00:19:42,310 --> 00:19:46,480
application that means that at the end I

00:19:44,530 --> 00:19:49,540
can do not reporting ok now the

00:19:46,480 --> 00:19:54,940
application started properly you can you

00:19:49,540 --> 00:19:56,330
can go and you can work with it so in

00:19:54,940 --> 00:19:58,999
summary

00:19:56,330 --> 00:20:00,649
we can configure an application using

00:19:58,999 --> 00:20:03,709
some very simple

00:20:00,649 --> 00:20:08,479
I mean Scala constructs we don't need to

00:20:03,709 --> 00:20:10,279
have elaborate type members mixing of

00:20:08,479 --> 00:20:12,259
traits where you don't know in which

00:20:10,279 --> 00:20:15,070
order it is relevant and what's the

00:20:12,259 --> 00:20:17,899
effect of mixing in a with B or D with a

00:20:15,070 --> 00:20:20,659
just case classes interfaces and readers

00:20:17,899 --> 00:20:24,289
which are just functions in a way is

00:20:20,659 --> 00:20:27,049
enough to do the job but you need to do

00:20:24,289 --> 00:20:29,690
some rewriting and with this library you

00:20:27,049 --> 00:20:31,789
have nice ways to do this writing in a

00:20:29,690 --> 00:20:35,089
very few lines of code you can do this

00:20:31,789 --> 00:20:37,129
it only works because it's lazy you need

00:20:35,089 --> 00:20:39,619
to make sure that your components don't

00:20:37,129 --> 00:20:42,799
do anything before they are started and

00:20:39,619 --> 00:20:44,869
then it works so that's what we did so

00:20:42,799 --> 00:20:46,909
we really decompose this application

00:20:44,869 --> 00:20:50,509
into several components having

00:20:46,909 --> 00:20:52,639
well-defined interfaces and and doing

00:20:50,509 --> 00:20:55,339
their job and isolating from changes

00:20:52,639 --> 00:20:58,129
which was an important objective that we

00:20:55,339 --> 00:21:00,589
had but well what I need to talk about

00:20:58,129 --> 00:21:03,829
by the way so I should talk about it

00:21:00,589 --> 00:21:06,829
right so how is it even useful to have F

00:21:03,829 --> 00:21:09,679
in this situation which is some kind of

00:21:06,829 --> 00:21:11,929
monads so possibly you've heard that

00:21:09,679 --> 00:21:14,149
using functional programming everyone

00:21:11,929 --> 00:21:16,279
should be using readers everywhere so

00:21:14,149 --> 00:21:18,139
every time you need a dependency just

00:21:16,279 --> 00:21:20,959
call a reader with a dependency and so

00:21:18,139 --> 00:21:22,820
on so what we've seen here is that for

00:21:20,959 --> 00:21:24,889
dependency management don't use

00:21:22,820 --> 00:21:28,070
functional programming use just good ol

00:21:24,889 --> 00:21:30,889
components and that's enough so where do

00:21:28,070 --> 00:21:33,259
we use more elaborate things well we

00:21:30,889 --> 00:21:35,029
need to be more specific now we have

00:21:33,259 --> 00:21:38,059
components it's nice because they burn a

00:21:35,029 --> 00:21:40,219
lot functionalities but what what is the

00:21:38,059 --> 00:21:43,309
precise interface of the components so

00:21:40,219 --> 00:21:46,039
if you have a method like that get an

00:21:43,309 --> 00:21:48,079
article get a price given a merchant ID

00:21:46,039 --> 00:21:50,839
for example what does it return

00:21:48,079 --> 00:21:54,440
well you're tempted to say a price or

00:21:50,839 --> 00:21:57,139
maybe a throwable or a price because it

00:21:54,440 --> 00:21:59,029
can fail or maybe a future or throw a

00:21:57,139 --> 00:22:04,219
ball or price because you're talking to

00:21:59,029 --> 00:22:06,200
an external service service well with DF

00:22:04,219 --> 00:22:08,750
monad you can say something like that

00:22:06,200 --> 00:22:12,140
you can say I'm returning a price

00:22:08,750 --> 00:22:15,590
some effects and I'm going to use a type

00:22:12,140 --> 00:22:17,929
parameter or in that case which is going

00:22:15,590 --> 00:22:20,720
to describe those effects so the more

00:22:17,929 --> 00:22:24,679
precise Ignat signature is get price

00:22:20,720 --> 00:22:27,049
where R has the task effects because

00:22:24,679 --> 00:22:28,760
it's going to be asynchronous has the

00:22:27,049 --> 00:22:30,590
log defect because it's going to log

00:22:28,760 --> 00:22:33,110
some tough because that's very useful

00:22:30,590 --> 00:22:35,150
for services to log things and it's

00:22:33,110 --> 00:22:38,200
going to use the flow ID effects which

00:22:35,150 --> 00:22:41,299
is a reader effects we'll see about that

00:22:38,200 --> 00:22:43,190
so I just put on this slide the small

00:22:41,299 --> 00:22:46,840
comment of what the definition of this

00:22:43,190 --> 00:22:50,480
underscore task which is just type down

00:22:46,840 --> 00:22:53,120
describing that in this stack are there

00:22:50,480 --> 00:22:57,110
is a task effect that's basically what

00:22:53,120 --> 00:22:59,720
that means and then when you call this

00:22:57,110 --> 00:23:02,419
method provided by given components you

00:22:59,720 --> 00:23:05,330
call it for precise tack so you say now

00:23:02,419 --> 00:23:08,090
I know all the effects I need to deal

00:23:05,330 --> 00:23:11,150
with I need to deal with tasks I need to

00:23:08,090 --> 00:23:13,580
deal with logs and reader and then you

00:23:11,150 --> 00:23:16,370
insulate this method with this precise

00:23:13,580 --> 00:23:20,330
tack and because of the type system and

00:23:16,370 --> 00:23:23,120
the way interpreters are being coded if

00:23:20,330 --> 00:23:25,130
you want to get a price you have to

00:23:23,120 --> 00:23:27,590
write to call the right interpreters in

00:23:25,130 --> 00:23:29,270
the right order and to get your value so

00:23:27,590 --> 00:23:31,390
you need to call the run log interpreter

00:23:29,270 --> 00:23:36,799
to get the log effect being interpreted

00:23:31,390 --> 00:23:38,450
flow ID and I think and so on so inside

00:23:36,799 --> 00:23:42,950
the F library you have many effects

00:23:38,450 --> 00:23:45,409
provided out-of-the-box okay here they

00:23:42,950 --> 00:23:47,419
are let me take one of them and it's

00:23:45,409 --> 00:23:49,400
kind of useful to think about effects in

00:23:47,419 --> 00:23:52,490
terms of what does that do for

00:23:49,400 --> 00:23:54,679
computation so for example the option

00:23:52,490 --> 00:23:56,870
effect is for computations which can

00:23:54,679 --> 00:23:59,299
stop for some reason because there's no

00:23:56,870 --> 00:24:01,610
more value to continue computing maybe I

00:23:59,299 --> 00:24:04,580
have zero and I'm doing a division by

00:24:01,610 --> 00:24:06,890
zero so it's bad I should stop the

00:24:04,580 --> 00:24:08,330
either effect is like an improvement on

00:24:06,890 --> 00:24:10,970
the option effect it's also for

00:24:08,330 --> 00:24:13,669
computation which can stop but you want

00:24:10,970 --> 00:24:16,190
to given an error message explaining

00:24:13,669 --> 00:24:19,399
what went wrong so you say oh given by

00:24:16,190 --> 00:24:21,110
zero stop right away and you have other

00:24:19,399 --> 00:24:22,759
effects like that so we are going to see

00:24:21,110 --> 00:24:24,709
which one some

00:24:22,759 --> 00:24:27,559
of them that we used for implementation

00:24:24,709 --> 00:24:29,979
we used all of them here but I'm just

00:24:27,559 --> 00:24:32,449
going to talk about five of them so

00:24:29,979 --> 00:24:34,999
coming back to the article service so

00:24:32,449 --> 00:24:37,039
what is the flow idea effects so this

00:24:34,999 --> 00:24:39,320
one is an example of the reader effect

00:24:37,039 --> 00:24:41,869
which is one of the simplest effect you

00:24:39,320 --> 00:24:44,089
can think of it is just used to pass the

00:24:41,869 --> 00:24:47,149
value from component to component from

00:24:44,089 --> 00:24:50,169
method call to method call so a customer

00:24:47,149 --> 00:24:53,329
can call or service and provide his own

00:24:50,169 --> 00:24:55,579
request ID to be able to track many

00:24:53,329 --> 00:24:57,529
requests across services that's also

00:24:55,579 --> 00:25:00,169
useful for us because when we read all

00:24:57,529 --> 00:25:02,269
logs we can also trace a given request

00:25:00,169 --> 00:25:05,089
and we can phrase this request in all

00:25:02,269 --> 00:25:07,549
service and in other services as well so

00:25:05,089 --> 00:25:10,849
we need to take this flow ID provided by

00:25:07,549 --> 00:25:13,789
the customer and and transmit it all the

00:25:10,849 --> 00:25:17,179
way down to the lowest component so for

00:25:13,789 --> 00:25:20,719
this we use a reader effect with the

00:25:17,179 --> 00:25:23,449
flow ID and we have methods like that

00:25:20,719 --> 00:25:25,819
where we say okay if you want to get the

00:25:23,449 --> 00:25:28,940
price at some stage I need to talk to a

00:25:25,819 --> 00:25:30,949
client system and I need to ask so

00:25:28,940 --> 00:25:33,709
that's a method provided by DF library

00:25:30,949 --> 00:25:36,979
give me the current flow ID so now I

00:25:33,709 --> 00:25:39,549
have a real fluid value I can pass to my

00:25:36,979 --> 00:25:42,349
downstream system that's basically it

00:25:39,549 --> 00:25:45,349
you could say it's not very different

00:25:42,349 --> 00:25:47,209
from passing in each method a parameter

00:25:45,349 --> 00:25:49,969
called flow ID of that flow ID

00:25:47,209 --> 00:25:51,619
everywhere it's slightly more concise

00:25:49,969 --> 00:25:53,239
but it's not very different and you

00:25:51,619 --> 00:25:56,299
would be right it's not very different

00:25:53,239 --> 00:25:58,279
so then when you go get price you have

00:25:56,299 --> 00:26:00,259
an interpreter for that called run

00:25:58,279 --> 00:26:03,499
reader and you run with her and run

00:26:00,259 --> 00:26:05,869
reader asks for the current flow ID you

00:26:03,499 --> 00:26:08,029
need to provide one at this stage even

00:26:05,869 --> 00:26:10,009
if before no one was really requiring an

00:26:08,029 --> 00:26:13,279
exact Friday here you need to provide

00:26:10,009 --> 00:26:16,009
one so this one was a very simple one

00:26:13,279 --> 00:26:17,209
and more complex and more interesting

00:26:16,009 --> 00:26:20,119
one is the log defect

00:26:17,209 --> 00:26:21,649
so the log defect is a simple variant on

00:26:20,119 --> 00:26:23,719
the writer effect so if you know

00:26:21,649 --> 00:26:25,309
functional programming many people will

00:26:23,719 --> 00:26:27,829
tell you oh use writer if you want to

00:26:25,309 --> 00:26:30,919
log stuff so this is kind of what we are

00:26:27,829 --> 00:26:34,009
doing but instead of just writing a

00:26:30,919 --> 00:26:36,519
value of one type we have several types

00:26:34,009 --> 00:26:38,559
because some things we log are just info

00:26:36,519 --> 00:26:40,989
some of them are errors and so on and so

00:26:38,559 --> 00:26:43,779
forth so this is what we model with this

00:26:40,989 --> 00:26:48,549
ADT and you can think about this as as

00:26:43,779 --> 00:26:50,709
requests if I create something of type

00:26:48,549 --> 00:26:53,229
info it's like a request for logging and

00:26:50,709 --> 00:26:55,059
info somewhere and the interpreter will

00:26:53,229 --> 00:26:57,190
know what to do with that request so

00:26:55,059 --> 00:27:01,059
this is how you think about effects and

00:26:57,190 --> 00:27:04,839
interpreters then you need a method to

00:27:01,059 --> 00:27:09,399
create an F value with an info message

00:27:04,839 --> 00:27:11,709
and this info method which is in your

00:27:09,399 --> 00:27:14,079
client code is using a method from the F

00:27:11,709 --> 00:27:18,489
library called send to send a given

00:27:14,079 --> 00:27:20,979
effect into a larger stack of effects so

00:27:18,489 --> 00:27:23,649
please read the user guide to understand

00:27:20,979 --> 00:27:25,839
more about this and then everywhere in

00:27:23,649 --> 00:27:29,529
your codes then you can call info

00:27:25,839 --> 00:27:31,509
exception error debug warning and you

00:27:29,529 --> 00:27:34,029
you will have s values containing that

00:27:31,509 --> 00:27:37,119
effect when you need to interpret that

00:27:34,029 --> 00:27:38,799
effects one way to interpret it is to

00:27:37,119 --> 00:27:42,309
grab a real logger something like a

00:27:38,799 --> 00:27:44,049
typesafe logger and do some side effects

00:27:42,309 --> 00:27:48,159
somewhere write to a file write to the

00:27:44,049 --> 00:27:49,749
disk with an info message and because we

00:27:48,159 --> 00:27:51,849
are not savages we don't like

00:27:49,749 --> 00:27:54,429
side-effects so we actually transform

00:27:51,849 --> 00:27:57,009
this load effect into a lower level

00:27:54,429 --> 00:27:58,959
effect which is the evil effects we just

00:27:57,009 --> 00:28:01,479
delay the evaluation of this because

00:27:58,959 --> 00:28:04,059
this is side effect this is bad so we

00:28:01,479 --> 00:28:08,289
use it with translate effects from high

00:28:04,059 --> 00:28:10,659
level like domain level if you want to

00:28:08,289 --> 00:28:13,450
some lower level effects so in this case

00:28:10,659 --> 00:28:16,719
from log to evil but at this stage you

00:28:13,450 --> 00:28:20,200
could think well you this is just it's a

00:28:16,719 --> 00:28:23,979
bit of a convoluted way of just avoiding

00:28:20,200 --> 00:28:25,359
side-effects isn't it and yes it seems

00:28:23,979 --> 00:28:27,669
like so but it's actually more

00:28:25,359 --> 00:28:29,200
interesting because you are not forced

00:28:27,669 --> 00:28:31,779
to have only one interpreter you can

00:28:29,200 --> 00:28:33,940
have several so the first one was using

00:28:31,779 --> 00:28:35,469
a real logger to lock somewhere but you

00:28:33,940 --> 00:28:37,389
can write another interpreter that's

00:28:35,469 --> 00:28:39,759
just going to discard the logs say oh

00:28:37,389 --> 00:28:41,619
actually I'm doing I'm testing I don't

00:28:39,759 --> 00:28:43,839
want to see all the logs in my console I

00:28:41,619 --> 00:28:46,149
don't want to have to modify a file

00:28:43,839 --> 00:28:47,200
somewhere saying that I want to use

00:28:46,149 --> 00:28:49,809
another append

00:28:47,200 --> 00:28:52,090
- not to console or I want to use

00:28:49,809 --> 00:28:55,480
something else to run my test and then

00:28:52,090 --> 00:28:58,179
have to modify that file again I just

00:28:55,480 --> 00:29:00,010
say discard the logs run that edge

00:28:58,179 --> 00:29:02,710
computation and justyou don't care about

00:29:00,010 --> 00:29:04,389
the logs just remove them or you could

00:29:02,710 --> 00:29:05,769
say actually I'm very interested in the

00:29:04,389 --> 00:29:08,169
logs because that's something I want to

00:29:05,769 --> 00:29:10,149
test I want to test if my application is

00:29:08,169 --> 00:29:12,010
logging properly because if the logs are

00:29:10,149 --> 00:29:14,169
not correct in production how can I

00:29:12,010 --> 00:29:16,299
diagnose what's wrong so maybe you are

00:29:14,169 --> 00:29:19,269
interested in collecting all the logs so

00:29:16,299 --> 00:29:21,639
you can write different interpreters and

00:29:19,269 --> 00:29:25,330
it's very useful to be able to do so

00:29:21,639 --> 00:29:30,269
even after a given component has already

00:29:25,330 --> 00:29:32,590
done the logging for you another very

00:29:30,269 --> 00:29:34,870
useful thing that we are doing with the

00:29:32,590 --> 00:29:38,440
F monad is actually using the F monolith

00:29:34,870 --> 00:29:43,330
and F applicative and so when the the

00:29:38,440 --> 00:29:45,669
first F paper came out two years ago it

00:29:43,330 --> 00:29:47,139
was only describing F at the Monad but

00:29:45,669 --> 00:29:49,539
actually it can be made applicative

00:29:47,139 --> 00:29:53,649
which is super useful because we can

00:29:49,539 --> 00:29:55,809
have concurrent execution so if we want

00:29:53,649 --> 00:29:58,409
to ping two different services to build

00:29:55,809 --> 00:30:02,799
something we don't want things to be

00:29:58,409 --> 00:30:04,570
done in sequence so if I want to get the

00:30:02,799 --> 00:30:06,789
brand and a price of an article I can

00:30:04,570 --> 00:30:10,539
just use the epic active notation to

00:30:06,789 --> 00:30:12,340
build my F value with this article I can

00:30:10,539 --> 00:30:15,639
make out of the brand and out of the

00:30:12,340 --> 00:30:18,549
price I can also take a bunch of article

00:30:15,639 --> 00:30:21,610
IDs and traverse that list and create

00:30:18,549 --> 00:30:23,080
articles for each article ID and because

00:30:21,610 --> 00:30:25,210
I'm using a special method called

00:30:23,080 --> 00:30:27,190
Traverse a is going to use the

00:30:25,210 --> 00:30:31,690
applicative version of the FMO not to do

00:30:27,190 --> 00:30:32,710
this and then with the task effect that

00:30:31,690 --> 00:30:35,769
means is going to run things

00:30:32,710 --> 00:30:37,990
concurrently which means that we can

00:30:35,769 --> 00:30:42,000
have nice asynchronous applications

00:30:37,990 --> 00:30:45,899
using the esplanade and more precisely

00:30:42,000 --> 00:30:48,970
out of the box you have a future effect

00:30:45,899 --> 00:30:50,799
which is actually not very different in

00:30:48,970 --> 00:30:53,260
a way that what you would write if you

00:30:50,799 --> 00:30:55,929
just have futures and implicit addiction

00:30:53,260 --> 00:30:59,450
context in this case we have a future

00:30:55,929 --> 00:31:02,630
implicit effect if you want

00:30:59,450 --> 00:31:06,950
but you have other effects because we

00:31:02,630 --> 00:31:10,970
have to Twitter future scholar that task

00:31:06,950 --> 00:31:14,060
monix tasks and SS - tasks as effects

00:31:10,970 --> 00:31:16,370
so whatever library you're already using

00:31:14,060 --> 00:31:19,190
that has those kinds of constructs

00:31:16,370 --> 00:31:22,640
scholar the task for example or monix

00:31:19,190 --> 00:31:29,180
task you can still integrate that as an

00:31:22,640 --> 00:31:31,990
S computation so we've seen four effects

00:31:29,180 --> 00:31:34,460
that we are using in this library and

00:31:31,990 --> 00:31:38,600
again we haven't seen any reader of

00:31:34,460 --> 00:31:40,790
config any reader of thread pool or

00:31:38,600 --> 00:31:43,160
whatever because this is all done using

00:31:40,790 --> 00:31:45,800
raster we don't need that as an effect

00:31:43,160 --> 00:31:48,170
to build our application and I think

00:31:45,800 --> 00:31:50,090
I've seen people trying to use that it

00:31:48,170 --> 00:31:52,310
makes the application a lot more complex

00:31:50,090 --> 00:31:57,350
I think rather than using good old

00:31:52,310 --> 00:31:59,360
components but ok it was not all so easy

00:31:57,350 --> 00:32:01,160
so using the Earthmen art was also

00:31:59,360 --> 00:32:02,510
process of discovering what was working

00:32:01,160 --> 00:32:05,750
and what was not working

00:32:02,510 --> 00:32:08,330
so one very common mistake or I think

00:32:05,750 --> 00:32:11,330
it's a mistake is trying to define what

00:32:08,330 --> 00:32:14,360
the stack should be too early and having

00:32:11,330 --> 00:32:17,840
some computations returning an F of s

00:32:14,360 --> 00:32:20,500
and price where F is already set to be

00:32:17,840 --> 00:32:23,030
those three effects nothing more and

00:32:20,500 --> 00:32:26,210
this makes it difficult to integrate

00:32:23,030 --> 00:32:28,610
that code with some other codes which we

00:32:26,210 --> 00:32:31,580
possibly have other effects so there are

00:32:28,610 --> 00:32:34,490
ways to do this in the F library but it

00:32:31,580 --> 00:32:37,730
makes integration more difficult so my

00:32:34,490 --> 00:32:40,370
first advice would be delay that to the

00:32:37,730 --> 00:32:42,160
latest possible moments right things

00:32:40,370 --> 00:32:46,190
like that where you just say I'm

00:32:42,160 --> 00:32:48,680
creating an F computation for some kind

00:32:46,190 --> 00:32:50,870
of tag or I just want R to have tasks

00:32:48,680 --> 00:32:53,660
logged and flow ID that's it it could

00:32:50,870 --> 00:32:57,770
have more but that's that's my

00:32:53,660 --> 00:32:59,090
requirement if you want for all the

00:32:57,770 --> 00:33:02,690
other thing where we had lots of issues

00:32:59,090 --> 00:33:04,880
with is errors because now you have at

00:33:02,690 --> 00:33:09,290
least three strategies to deal with

00:33:04,880 --> 00:33:13,040
errors so you could return a value that

00:33:09,290 --> 00:33:16,350
has a three ball or a for example

00:33:13,040 --> 00:33:19,560
you could return a data type that's more

00:33:16,350 --> 00:33:22,170
complex that contains either success

00:33:19,560 --> 00:33:24,570
case or partially fails or completely

00:33:22,170 --> 00:33:27,600
failed so this could be encoded in more

00:33:24,570 --> 00:33:30,960
complex data type or you could have used

00:33:27,600 --> 00:33:32,910
the either effect which has also which

00:33:30,960 --> 00:33:36,540
is also a way to encode the possibility

00:33:32,910 --> 00:33:38,300
of having errors and at first we went a

00:33:36,540 --> 00:33:42,180
bit overboard with all that and we had

00:33:38,300 --> 00:33:44,280
one error style per layer and that made

00:33:42,180 --> 00:33:46,020
things a bit difficult because we had to

00:33:44,280 --> 00:33:47,520
kind of translate between all those

00:33:46,020 --> 00:33:49,410
tiles every time we are calling a

00:33:47,520 --> 00:33:53,010
different method and that was a bit

00:33:49,410 --> 00:33:56,670
cumbersome so my advice would be try to

00:33:53,010 --> 00:33:59,640
not to use too much at once and try not

00:33:56,670 --> 00:34:04,020
to use too many different error types if

00:33:59,640 --> 00:34:06,660
you can and stick to one error type that

00:34:04,020 --> 00:34:10,620
you use in many places that will that

00:34:06,660 --> 00:34:12,480
that will help but doing so we

00:34:10,620 --> 00:34:15,540
discovered one thing that was really

00:34:12,480 --> 00:34:17,880
useful with that for some computations

00:34:15,540 --> 00:34:20,880
it's very useful to be able to locally

00:34:17,880 --> 00:34:23,490
or temporarily add an effect to the

00:34:20,880 --> 00:34:25,230
stack to the existing stack let me give

00:34:23,490 --> 00:34:27,540
you an example so you have two methods

00:34:25,230 --> 00:34:30,840
and they are both returning through

00:34:27,540 --> 00:34:33,120
tribal or int and you want to compose

00:34:30,840 --> 00:34:36,420
them you want to use them in a file

00:34:33,120 --> 00:34:39,030
compression and this is not easy because

00:34:36,420 --> 00:34:42,000
a and B are going to be either values

00:34:39,030 --> 00:34:44,760
right and you don't really want that so

00:34:42,000 --> 00:34:47,040
if you use scale ahead of cuts you would

00:34:44,760 --> 00:34:52,470
use an either T transformer at this

00:34:47,040 --> 00:34:56,220
stage to to remove to to get above this

00:34:52,470 --> 00:34:58,860
difficulty but what you can do is say oh

00:34:56,220 --> 00:35:02,670
actually I'm going to temporarily add

00:34:58,860 --> 00:35:06,090
one more effect to my stack and I'm

00:35:02,670 --> 00:35:09,180
going to take the first call and the

00:35:06,090 --> 00:35:10,530
error value that I get I collapse it

00:35:09,180 --> 00:35:13,110
into the stack

00:35:10,530 --> 00:35:13,650
I like this being handled by the

00:35:13,110 --> 00:35:16,410
Esmeraude

00:35:13,650 --> 00:35:21,240
I use the class method the other one

00:35:16,410 --> 00:35:22,290
same thing if it's left I left the earth

00:35:21,240 --> 00:35:24,600
mode I'll deal with it

00:35:22,290 --> 00:35:26,390
and then eventually when I have done

00:35:24,600 --> 00:35:29,839
everything I wanted to do with

00:35:26,390 --> 00:35:33,230
happy path I add April as be I run my

00:35:29,839 --> 00:35:36,470
either effect and I might have less

00:35:33,230 --> 00:35:39,890
value eventually but I'm left with the

00:35:36,470 --> 00:35:43,430
our stock and and I've written the code

00:35:39,890 --> 00:35:44,930
in the simplest way I could so the

00:35:43,430 --> 00:35:48,650
collapse method is something like that

00:35:44,930 --> 00:35:51,829
you take an F that has as a value some

00:35:48,650 --> 00:35:56,510
effect m and you say now please inline

00:35:51,829 --> 00:35:59,029
that thing please put this in the rest

00:35:56,510 --> 00:36:02,930
of the stack so that's that's very

00:35:59,029 --> 00:36:05,420
useful another error that we made I

00:36:02,930 --> 00:36:07,670
think was to and that's what inspired by

00:36:05,420 --> 00:36:10,369
many of the tutorials you can read on on

00:36:07,670 --> 00:36:14,420
the on on using the free monads is that

00:36:10,369 --> 00:36:18,410
everything is a DSL a key value store

00:36:14,420 --> 00:36:20,990
the DSL services DSL create an ADT for

00:36:18,410 --> 00:36:23,900
this interpret it and then life is super

00:36:20,990 --> 00:36:27,200
good and it wasn't for us really it was

00:36:23,900 --> 00:36:28,760
it made our life more complicated so we

00:36:27,200 --> 00:36:32,089
started doing things like that said oh

00:36:28,760 --> 00:36:34,670
our price soap clients actually we're

00:36:32,089 --> 00:36:36,710
making price requests so that that

00:36:34,670 --> 00:36:40,579
should be an effect right so we create a

00:36:36,710 --> 00:36:42,619
small ADT for it just one method okay we

00:36:40,579 --> 00:36:45,500
create some helper methods some type

00:36:42,619 --> 00:36:48,470
alias and then we can create s values

00:36:45,500 --> 00:36:50,900
with price requests but we also need an

00:36:48,470 --> 00:36:53,329
interpreter for that effect so we create

00:36:50,900 --> 00:36:56,869
an interpreter that's in a component

00:36:53,329 --> 00:36:58,789
somewhere with not such a nice type

00:36:56,869 --> 00:37:01,400
signature right because there are all

00:36:58,789 --> 00:37:04,430
sorts of type level machinery you need

00:37:01,400 --> 00:37:07,460
to do with effects but then what do you

00:37:04,430 --> 00:37:09,819
do actually you make a price request and

00:37:07,460 --> 00:37:12,319
you get back an F value with that effect

00:37:09,819 --> 00:37:14,059
well then at some stage you need to

00:37:12,319 --> 00:37:17,599
interpret that so you go back to this

00:37:14,059 --> 00:37:19,430
component sorry or another component and

00:37:17,599 --> 00:37:21,319
you say oh can you please now interpret

00:37:19,430 --> 00:37:23,329
that request for me and get me a price

00:37:21,319 --> 00:37:25,039
because after all I came for the price I

00:37:23,329 --> 00:37:28,490
didn't come for an effect representing

00:37:25,039 --> 00:37:32,089
the price so there was no real added

00:37:28,490 --> 00:37:35,210
value in doing so in having the GSL for

00:37:32,089 --> 00:37:39,630
price request and the other side effect

00:37:35,210 --> 00:37:41,460
of this was that those DSL effects they

00:37:39,630 --> 00:37:44,549
you have the effect of bubbling up to

00:37:41,460 --> 00:37:46,430
the surface and we had I think this was

00:37:44,549 --> 00:37:49,380
kind of breaking encapsulation as well

00:37:46,430 --> 00:37:52,079
not only this but putting some serious

00:37:49,380 --> 00:37:56,670
pressure on the Scala compiler I can

00:37:52,079 --> 00:37:58,529
tell you so eventually what was more

00:37:56,670 --> 00:38:01,019
useful is just to say okay can you get

00:37:58,529 --> 00:38:02,910
me a price and you're going to get it

00:38:01,019 --> 00:38:04,829
asynchronously that's actually the only

00:38:02,910 --> 00:38:06,630
thing I need to know about it and that's

00:38:04,829 --> 00:38:08,940
good that's good for me

00:38:06,630 --> 00:38:10,769
I cannot interpret that effect maybe

00:38:08,940 --> 00:38:12,930
you're doing requests in some special

00:38:10,769 --> 00:38:16,170
way I cannot do anything about it but I

00:38:12,930 --> 00:38:18,869
just want my price so and eventually the

00:38:16,170 --> 00:38:21,720
signature of the price client is is a

00:38:18,869 --> 00:38:23,190
lot simpler it just says I want to price

00:38:21,720 --> 00:38:24,989
and it's going to be returned

00:38:23,190 --> 00:38:29,339
asynchronously that's the only only

00:38:24,989 --> 00:38:33,390
thing I need to know so to end this

00:38:29,339 --> 00:38:36,180
discussion about about effects and about

00:38:33,390 --> 00:38:38,999
when to use them or not to use them I

00:38:36,180 --> 00:38:42,299
want to take time as an example of that

00:38:38,999 --> 00:38:44,309
so time should it be an effect or a

00:38:42,299 --> 00:38:47,130
component and how would you approach

00:38:44,309 --> 00:38:51,059
that so first of all it is very useful

00:38:47,130 --> 00:38:54,210
to model time in our systems explicitly

00:38:51,059 --> 00:38:56,849
you never want to have close to system

00:38:54,210 --> 00:38:59,700
dot now in your code as a static call

00:38:56,849 --> 00:39:01,710
because then you have code that that you

00:38:59,700 --> 00:39:04,170
cannot replay that is not deterministic

00:39:01,710 --> 00:39:05,969
that creates all sorts of issues so it's

00:39:04,170 --> 00:39:07,769
very useful to have some place where you

00:39:05,969 --> 00:39:09,960
control you can control the time and

00:39:07,769 --> 00:39:11,729
what's going on with the time but how do

00:39:09,960 --> 00:39:13,710
you do it can you use the effects for

00:39:11,729 --> 00:39:16,410
that so let's say you're just using a

00:39:13,710 --> 00:39:18,960
component that returns you the moment it

00:39:16,410 --> 00:39:21,059
is now okay what time is it now and

00:39:18,960 --> 00:39:23,960
let's say you have like a component

00:39:21,059 --> 00:39:26,489
doing some rate limiting for example and

00:39:23,960 --> 00:39:29,160
so you can say okay can you give me the

00:39:26,489 --> 00:39:31,680
status right now for rate limiting

00:39:29,160 --> 00:39:32,460
because I've made 100 calls in the past

00:39:31,680 --> 00:39:35,640
10 minutes

00:39:32,460 --> 00:39:37,499
how many more calls can I do now so if

00:39:35,640 --> 00:39:39,299
you have a time component you can call

00:39:37,499 --> 00:39:41,609
that components going to give you the

00:39:39,299 --> 00:39:44,430
time returned you you can do your status

00:39:41,609 --> 00:39:47,009
computation and get back a status that's

00:39:44,430 --> 00:39:49,109
fine and if you want to test this you

00:39:47,009 --> 00:39:51,630
can use something like raster or just

00:39:49,109 --> 00:39:52,500
inject another component with a free

00:39:51,630 --> 00:39:54,240
time

00:39:52,500 --> 00:39:56,400
a component that's going to return

00:39:54,240 --> 00:39:58,080
always the same time or you can have a

00:39:56,400 --> 00:40:00,990
component that's going to do rolling

00:39:58,080 --> 00:40:03,330
time just have a bunch of successive

00:40:00,990 --> 00:40:05,700
times which you create for your test and

00:40:03,330 --> 00:40:08,430
then you can assert specific things

00:40:05,700 --> 00:40:11,280
about those times so that's quite useful

00:40:08,430 --> 00:40:13,099
for testing now what happens if you have

00:40:11,280 --> 00:40:16,470
an effect representing the time

00:40:13,099 --> 00:40:18,150
representing this request from now so

00:40:16,470 --> 00:40:19,680
you can do also the same thing so you

00:40:18,150 --> 00:40:21,390
can implement it's actually an

00:40:19,680 --> 00:40:23,820
interesting exercise if you come first

00:40:21,390 --> 00:40:26,099
to the F monad and you want our cake I

00:40:23,820 --> 00:40:27,990
need to use something and try to

00:40:26,099 --> 00:40:30,900
implement a new effect by myself just

00:40:27,990 --> 00:40:33,000
use time for example so you can

00:40:30,900 --> 00:40:35,520
implement the time effect create an S

00:40:33,000 --> 00:40:37,260
value with that time effect and then you

00:40:35,520 --> 00:40:38,760
need an interpreter for that time effect

00:40:37,260 --> 00:40:42,300
so the default interpreter is going

00:40:38,760 --> 00:40:45,869
probably to go cm but now right and then

00:40:42,300 --> 00:40:49,590
you can have another interpreter which

00:40:45,869 --> 00:40:50,880
only always the same time freeze time so

00:40:49,590 --> 00:40:53,220
what is the difference between the two

00:40:50,880 --> 00:40:55,920
approaches so I think the difference

00:40:53,220 --> 00:40:58,050
between the two approaches is that the

00:40:55,920 --> 00:40:59,820
first one makes the component completely

00:40:58,050 --> 00:41:02,910
opaque to you you don't know what's

00:40:59,820 --> 00:41:07,470
going on you have no way to change the

00:41:02,910 --> 00:41:09,510
behavior of that component the second

00:41:07,470 --> 00:41:11,760
one gives you a lot more opportunity to

00:41:09,510 --> 00:41:13,740
change the behavior of that component

00:41:11,760 --> 00:41:16,560
it's it's the same example with logging

00:41:13,740 --> 00:41:19,290
so with logging we have the component is

00:41:16,560 --> 00:41:21,810
doing some stuff but it's also exposing

00:41:19,290 --> 00:41:24,540
a bit of its behavior to you with that

00:41:21,810 --> 00:41:26,970
effect and it's telling you ok I've done

00:41:24,540 --> 00:41:29,310
I've called some services but I've also

00:41:26,970 --> 00:41:31,440
done some logging and maybe if you want

00:41:29,310 --> 00:41:34,530
to interpret that differently you can do

00:41:31,440 --> 00:41:37,109
it so it's kind of using effect in that

00:41:34,530 --> 00:41:40,680
sense it's kind of opening up a bit the

00:41:37,109 --> 00:41:43,200
behavior of a component so you have now

00:41:40,680 --> 00:41:44,910
a designer a design choice to make

00:41:43,200 --> 00:41:46,890
do you want your components to be

00:41:44,910 --> 00:41:49,320
completely sealed in terms of behavior

00:41:46,890 --> 00:41:50,700
or do you want to have a way to change

00:41:49,320 --> 00:41:51,060
slightly some of the things they are

00:41:50,700 --> 00:41:53,640
doing

00:41:51,060 --> 00:41:55,560
for example the acing behavior you could

00:41:53,640 --> 00:41:58,920
say oh I just want to test everything

00:41:55,560 --> 00:42:00,810
synchronously and you can interpret code

00:41:58,920 --> 00:42:02,880
everything synchronously for that

00:42:00,810 --> 00:42:06,070
component so this is really a design

00:42:02,880 --> 00:42:08,230
choice because this opportunity comes

00:42:06,070 --> 00:42:10,030
the cost now it's the burden is on the

00:42:08,230 --> 00:42:12,730
client to provide the right interpreter

00:42:10,030 --> 00:42:18,360
and to do the right thing so it's your

00:42:12,730 --> 00:42:21,550
choice so as a recap on all of this I

00:42:18,360 --> 00:42:24,130
think that components are still very

00:42:21,550 --> 00:42:25,690
useful I said it several times can I say

00:42:24,130 --> 00:42:28,030
it one more time they are super useful

00:42:25,690 --> 00:42:32,050
they don't have to be very complex in

00:42:28,030 --> 00:42:35,320
Scala using using the type system with

00:42:32,050 --> 00:42:37,540
cell types and using subtyping I think

00:42:35,320 --> 00:42:41,320
we can just use case classes interfaces

00:42:37,540 --> 00:42:43,990
and a bit of magic with tree writing to

00:42:41,320 --> 00:42:47,710
get the job done so I really encourage

00:42:43,990 --> 00:42:49,780
you to have a look at a grafter and then

00:42:47,710 --> 00:42:52,480
you can use effect to be a lot more

00:42:49,780 --> 00:42:57,400
precise about what your methods are

00:42:52,480 --> 00:42:59,620
doing and in a very composable way in a

00:42:57,400 --> 00:43:02,190
very extensible way because it's easy to

00:42:59,620 --> 00:43:05,590
add new effects is easy to compose them

00:43:02,190 --> 00:43:08,410
and then we see that this comes as new

00:43:05,590 --> 00:43:10,060
opportunities in terms of design that

00:43:08,410 --> 00:43:14,800
you can exploit to have more flexible

00:43:10,060 --> 00:43:17,710
software so now it's your turn to use it

00:43:14,800 --> 00:43:21,100
try it come back with questions and new

00:43:17,710 --> 00:43:24,130
ideas have any more questions or maybe

00:43:21,100 --> 00:43:28,720
bits understand so I can add one more

00:43:24,130 --> 00:43:31,510
thing to know okay I don't know what can

00:43:28,720 --> 00:43:33,250
we do yeah we can do batching as well so

00:43:31,510 --> 00:43:35,740
one cool thing I've been experimenting

00:43:33,250 --> 00:43:40,060
with is the fact that because F is an

00:43:35,740 --> 00:43:44,890
applicative we can actually one moment

00:43:40,060 --> 00:43:47,230
where it's useful to to keep some effect

00:43:44,890 --> 00:43:49,480
not being interpreted quite yet is that

00:43:47,230 --> 00:43:51,550
you can batch them so for example we had

00:43:49,480 --> 00:43:53,880
a service doing translations so every

00:43:51,550 --> 00:43:57,880
time you want to translate something

00:43:53,880 --> 00:44:00,970
it's very wasteful to in translate I

00:43:57,880 --> 00:44:03,160
don't know 100 colors one by one it's

00:44:00,970 --> 00:44:05,500
more useful to collect them and send

00:44:03,160 --> 00:44:07,570
them all at once because this interface

00:44:05,500 --> 00:44:10,710
of that service has the two methods one

00:44:07,570 --> 00:44:13,000
by one or in a batch so there's a

00:44:10,710 --> 00:44:14,980
experimental support for for batching

00:44:13,000 --> 00:44:17,770
using the S&L where you can do exactly

00:44:14,980 --> 00:44:19,850
this you get an F value and you say now

00:44:17,770 --> 00:44:21,710
please batch all the calls

00:44:19,850 --> 00:44:24,320
or that given effect and there's a way

00:44:21,710 --> 00:44:29,780
to describe this so yeah this is my

00:44:24,320 --> 00:44:31,400
example okay I won't stay too much on

00:44:29,780 --> 00:44:35,660
the codes and you need to implement this

00:44:31,400 --> 00:44:39,430
interface which is I'm not sure that the

00:44:35,660 --> 00:44:41,780
right way to do it but it kind of works

00:44:39,430 --> 00:44:43,400
yeah I'm going to skip that I just

00:44:41,780 --> 00:44:46,870
wanted to talk to you about something

00:44:43,400 --> 00:44:50,990
else let me see if I can find it about

00:44:46,870 --> 00:44:54,890
no that's recommitting so we was we can

00:44:50,990 --> 00:44:57,140
do right limiting no no that's it sorry

00:44:54,890 --> 00:44:59,180
I thought I had a slide on memorization

00:44:57,140 --> 00:45:01,310
so one useful thing that we've been

00:44:59,180 --> 00:45:05,150
doing also recently with the eff monads

00:45:01,310 --> 00:45:07,130
was to memorize effects so you start up

00:45:05,150 --> 00:45:10,270
your services and then you have a 100

00:45:07,130 --> 00:45:12,680
threads asking for the same authorizes

00:45:10,270 --> 00:45:14,330
authentication token all at once they

00:45:12,680 --> 00:45:16,940
are going to take to get back the same

00:45:14,330 --> 00:45:20,000
answer which you might cache for some

00:45:16,940 --> 00:45:21,650
reason but having all those calls being

00:45:20,000 --> 00:45:24,680
emitted all at once is not very useful

00:45:21,650 --> 00:45:27,440
so there is a way to memorize all those

00:45:24,680 --> 00:45:30,200
goals so that only the first future with

00:45:27,440 --> 00:45:33,710
that request will be will be executed so

00:45:30,200 --> 00:45:36,230
that's one thing and I might use the

00:45:33,710 --> 00:45:38,810
last minute I have to say that there's

00:45:36,230 --> 00:45:40,820
also some very nice and important

00:45:38,810 --> 00:45:43,280
effects in this library which is the

00:45:40,820 --> 00:45:46,700
safe effect and the safe effect is

00:45:43,280 --> 00:45:49,400
guaranteeing some freeing of resources

00:45:46,700 --> 00:45:52,160
and that's something which you generally

00:45:49,400 --> 00:45:55,640
don't find in other monad libraries so

00:45:52,160 --> 00:45:57,590
you can say this is my computation and I

00:45:55,640 --> 00:46:01,550
want to make sure that whatever whatever

00:45:57,590 --> 00:46:02,420
happens this action will be called at

00:46:01,550 --> 00:46:04,970
the end of the world

00:46:02,420 --> 00:46:07,250
whatever if there's an exception if

00:46:04,970 --> 00:46:09,230
something goes wrong if there's an

00:46:07,250 --> 00:46:12,110
either effect thing that I should stop

00:46:09,230 --> 00:46:14,600
my computations I should still do my

00:46:12,110 --> 00:46:17,300
cleanup eventually so this is provided

00:46:14,600 --> 00:46:19,340
by a side effect and I really encourage

00:46:17,300 --> 00:46:22,420
you to have a look at it so now I think

00:46:19,340 --> 00:46:22,420
it's time for question

00:46:23,960 --> 00:46:32,889
[Applause]

00:46:36,530 --> 00:46:41,480
are you excited about Union types and

00:46:39,020 --> 00:46:43,700
daddy to represent the effect type sorry

00:46:41,480 --> 00:46:47,770
boss are you excited about union types

00:46:43,700 --> 00:46:52,130
in daddy to represent the effect type I

00:46:47,770 --> 00:46:56,420
haven't I don't know yet if I can use it

00:46:52,130 --> 00:46:58,130
but it it's possible yes yeah

00:46:56,420 --> 00:47:11,870
but no I haven't explored that yet at

00:46:58,130 --> 00:47:13,670
all I'm actually interesting in a

00:47:11,870 --> 00:47:18,590
compiler that doesn't crush on some

00:47:13,670 --> 00:47:21,230
expressions because I know way to to

00:47:18,590 --> 00:47:24,940
explode the compiler with some carefully

00:47:21,230 --> 00:47:27,440
crafted interpreters for example yeah I

00:47:24,940 --> 00:47:28,900
was very fortunate because in all of

00:47:27,440 --> 00:47:31,640
those case there's always a workaround

00:47:28,900 --> 00:47:36,880
but I'm always during the time where

00:47:31,640 --> 00:47:36,880
there will be no work around and yeah

00:47:37,120 --> 00:47:44,110
okay no more questions yes yes

00:47:46,770 --> 00:47:51,910
so being relatively unfamiliar with the

00:47:49,300 --> 00:47:56,020
effect monad and having you know kind of

00:47:51,910 --> 00:47:58,330
glossed over the github page what's

00:47:56,020 --> 00:48:01,210
intimidating to me about this is is the

00:47:58,330 --> 00:48:04,210
sheer number of types that that appear

00:48:01,210 --> 00:48:07,300
then in the signatures have you found

00:48:04,210 --> 00:48:10,650
that that things like the kind projector

00:48:07,300 --> 00:48:13,510
become you know necessary in terms of

00:48:10,650 --> 00:48:14,770
building out code that is readable

00:48:13,510 --> 00:48:19,570
without a lot of you know additional

00:48:14,770 --> 00:48:21,730
syntax or or do you find despite the

00:48:19,570 --> 00:48:25,660
number of types that we don't run into

00:48:21,730 --> 00:48:27,520
those same problems okay so so can

00:48:25,660 --> 00:48:30,400
projector is not only necessary but

00:48:27,520 --> 00:48:32,620
indispensable you need it I mean every

00:48:30,400 --> 00:48:35,020
time you have a type having more than

00:48:32,620 --> 00:48:37,420
one type parameter you need the can

00:48:35,020 --> 00:48:39,940
projector so that was really relief the

00:48:37,420 --> 00:48:46,350
second relief was the fix of the famous

00:48:39,940 --> 00:48:48,820
site 27:12 bug because I mean I spent

00:48:46,350 --> 00:48:50,470
something like a night trying to find

00:48:48,820 --> 00:48:53,110
out how to get some in pieces to work

00:48:50,470 --> 00:48:55,420
just because of that bug and it was

00:48:53,110 --> 00:48:59,230
really really difficult solving that bug

00:48:55,420 --> 00:49:05,130
opened completely lots of possibilities

00:48:59,230 --> 00:49:05,130
for for the library yeah

00:49:11,880 --> 00:49:24,010
okay more questions thank you then

00:49:16,850 --> 00:49:24,010

YouTube URL: https://www.youtube.com/watch?v=5iV-x8CFmtU


