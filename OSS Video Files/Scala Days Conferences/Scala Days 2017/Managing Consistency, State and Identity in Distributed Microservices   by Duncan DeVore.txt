Title: Managing Consistency, State and Identity in Distributed Microservices   by Duncan DeVore
Publication date: 2017-06-06
Playlist: Scala Days 2017
Description: 
	This video was recorded at Scala Days Chicago 2017
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
In the world of distributed microservices, we face many challenges: parallelism, asynchronous boundaries, state management, identity management and consistency deficiencies, to name a few. Of all these problems, consistency, state management, and identity management can be particularly challenging.

In this session, we will discuss the ins and outs of dealing with microservice consistency and distributed state, and identity coherency with techniques like idempotency, eventual and casual consistency, dealing with CAP theorem, single source of truth and distributed domain design.
Captions: 
	00:00:00,350 --> 00:00:04,560
all right good late after morning

00:00:03,350 --> 00:00:07,290
everyone

00:00:04,560 --> 00:00:11,010
my name is Duncan Devore and I'm going

00:00:07,290 --> 00:00:14,700
to talk today about the idea of managing

00:00:11,010 --> 00:00:17,760
state in a consistent manner and dealing

00:00:14,700 --> 00:00:21,869
with identity that needs to be composed

00:00:17,760 --> 00:00:24,510
in the terms of microservices I'm not a

00:00:21,869 --> 00:00:27,060
huge fan of the word microcircuits

00:00:24,510 --> 00:00:28,460
but as we get through the slides you

00:00:27,060 --> 00:00:30,300
understand what I'm saying

00:00:28,460 --> 00:00:33,360
ultimately it's going to come down to

00:00:30,300 --> 00:00:36,719
distributed computing as always with all

00:00:33,360 --> 00:00:38,160
the presentations please rate the

00:00:36,719 --> 00:00:41,280
session when you're done obviously give

00:00:38,160 --> 00:00:43,320
this one 5 stars so just kidding I'd

00:00:41,280 --> 00:00:44,430
give it what you actually think and if

00:00:43,320 --> 00:00:48,120
you have any comments or feedback

00:00:44,430 --> 00:00:51,750
afterwards please please come talk to me

00:00:48,120 --> 00:00:54,239
so I work for like then many of you many

00:00:51,750 --> 00:00:57,390
of you know us for those that don't we

00:00:54,239 --> 00:01:04,080
have a variety of open source offerings

00:00:57,390 --> 00:01:05,519
toolkits akka play lagoon etc aside from

00:01:04,080 --> 00:01:07,650
giving away those things for free we

00:01:05,519 --> 00:01:09,990
also did some consulting and we have

00:01:07,650 --> 00:01:12,630
some commercial aspects to our stack

00:01:09,990 --> 00:01:14,220
under our enterprise suite or here you

00:01:12,630 --> 00:01:17,840
see it called the production suite and

00:01:14,220 --> 00:01:20,759
in there we offer things like telemetry

00:01:17,840 --> 00:01:23,790
monitoring type stuff we also offer

00:01:20,759 --> 00:01:26,130
split brain resolver for clustering we

00:01:23,790 --> 00:01:28,460
also have a new area that we're real

00:01:26,130 --> 00:01:32,869
excited about and that's our fast data

00:01:28,460 --> 00:01:35,909
architecture with AI and so forth so

00:01:32,869 --> 00:01:38,759
this all comes with a subscription to

00:01:35,909 --> 00:01:41,100
our services and there are doing you

00:01:38,759 --> 00:01:44,040
know levels of price and so forth but

00:01:41,100 --> 00:01:45,479
some really good stuff you know go to

00:01:44,040 --> 00:01:48,600
our website check it out when you get a

00:01:45,479 --> 00:01:51,299
chance for myself I've been an engineer

00:01:48,600 --> 00:01:53,240
for a long time I've been with life and

00:01:51,299 --> 00:01:56,340
formerly typesafe for about three years

00:01:53,240 --> 00:01:58,079
the bulk of that time has been as an

00:01:56,340 --> 00:02:01,530
engineer working on telemetry and

00:01:58,079 --> 00:02:02,790
monitoring recently I'm working a little

00:02:01,530 --> 00:02:07,229
bit more with the customer side of

00:02:02,790 --> 00:02:09,420
things as an architect I have a book out

00:02:07,229 --> 00:02:12,840
there with two other work to other

00:02:09,420 --> 00:02:13,650
authors Sean Walsh and Brian Hanafy it's

00:02:12,840 --> 00:02:15,930
reactive apple

00:02:13,650 --> 00:02:17,610
and design and it's all kind of the same

00:02:15,930 --> 00:02:18,959
thing talks about this that's my twitter

00:02:17,610 --> 00:02:21,150
and my github account if you're

00:02:18,959 --> 00:02:23,670
interested for some stuff out there and

00:02:21,150 --> 00:02:26,730
this wall being the slide so you have

00:02:23,670 --> 00:02:28,349
access to it so I want to talk about

00:02:26,730 --> 00:02:30,360
micro services only because that's the

00:02:28,349 --> 00:02:32,250
hot term that's a term people are

00:02:30,360 --> 00:02:33,750
talking about for me it doesn't really

00:02:32,250 --> 00:02:35,280
matter what you can quote what you call

00:02:33,750 --> 00:02:37,230
it you can call it modules you can call

00:02:35,280 --> 00:02:43,110
a balloon so it doesn't really matter to

00:02:37,230 --> 00:02:45,269
me it's basically a concept and over the

00:02:43,110 --> 00:02:47,489
last twenty years or so we've been

00:02:45,269 --> 00:02:50,099
building applications of what has been

00:02:47,489 --> 00:02:52,829
coined or termed as a monolith and in

00:02:50,099 --> 00:02:55,530
that environment we've been able to rely

00:02:52,829 --> 00:02:59,310
on things like strong consistency we've

00:02:55,530 --> 00:03:02,129
been able to rely on a pseudo global

00:02:59,310 --> 00:03:05,150
state of now in that environment and

00:03:02,129 --> 00:03:07,409
we've been able to rely on you know

00:03:05,150 --> 00:03:10,319
transactional rollbacks and things like

00:03:07,409 --> 00:03:13,290
this and the reality of it is as our

00:03:10,319 --> 00:03:14,909
landscape has changed that model is

00:03:13,290 --> 00:03:17,430
beginning to crumble it's beginning to

00:03:14,909 --> 00:03:19,859
fail it's no longer working yes it does

00:03:17,430 --> 00:03:21,419
work in some circumstances but as we

00:03:19,859 --> 00:03:23,280
talk about this and we see we're going

00:03:21,419 --> 00:03:24,840
to take a deep look at some of the

00:03:23,280 --> 00:03:26,910
different things that are going on and

00:03:24,840 --> 00:03:29,220
why we need to embrace a new way to

00:03:26,910 --> 00:03:30,690
think about things specifically when it

00:03:29,220 --> 00:03:34,280
comes to the important things of our

00:03:30,690 --> 00:03:38,579
application a consistent state and

00:03:34,280 --> 00:03:41,160
composable identity Gardner put out this

00:03:38,579 --> 00:03:43,560
statement and referring to essentially

00:03:41,160 --> 00:03:44,970
monolithic type applications and they

00:03:43,560 --> 00:03:49,440
said the traditional architectures that

00:03:44,970 --> 00:03:50,940
were used for or are used to or obsolete

00:03:49,440 --> 00:03:53,790
what's interesting about this statement

00:03:50,940 --> 00:03:55,799
is that when they put it out they were

00:03:53,790 --> 00:03:57,919
stating as of the time that they put the

00:03:55,799 --> 00:04:01,530
statement out which I think was 2016

00:03:57,919 --> 00:04:04,379
those platforms are already obsolete we

00:04:01,530 --> 00:04:06,120
have new challenges today Mobile he's

00:04:04,379 --> 00:04:08,160
not called Expensify use it on mobile

00:04:06,120 --> 00:04:09,750
when I use it on the web and all this

00:04:08,160 --> 00:04:11,370
stuff and I want the same stuff to show

00:04:09,750 --> 00:04:13,319
up in my web version as I do on my

00:04:11,370 --> 00:04:15,660
mobile version we have the Internet of

00:04:13,319 --> 00:04:18,690
Things we have deployments that are

00:04:15,660 --> 00:04:21,000
using thousands of cores right kind of

00:04:18,690 --> 00:04:22,979
stuff that we never dreamed of 10-15

00:04:21,000 --> 00:04:25,229
years ago users what's really

00:04:22,979 --> 00:04:26,690
interesting are expecting the same type

00:04:25,229 --> 00:04:28,870
of response time

00:04:26,690 --> 00:04:31,190
that mission-critical applications

00:04:28,870 --> 00:04:32,750
expected 10 or 15 years ago when you

00:04:31,190 --> 00:04:35,300
take a look at NASA and you take a look

00:04:32,750 --> 00:04:37,370
at energy and how the grid works we add

00:04:35,300 --> 00:04:39,440
something that we call near real-time or

00:04:37,370 --> 00:04:41,480
real-time data processing extremely

00:04:39,440 --> 00:04:43,670
important that's now becoming standard

00:04:41,480 --> 00:04:45,640
for your average application as an

00:04:43,670 --> 00:04:48,110
expectation from the user

00:04:45,640 --> 00:04:50,810
uptime they're expecting on two percent

00:04:48,110 --> 00:04:52,190
uptime it's just it's like your TV

00:04:50,810 --> 00:04:54,740
remote right what would you do without

00:04:52,190 --> 00:04:56,240
it and even that right people aren't

00:04:54,740 --> 00:04:57,950
even using TV and anymore they're using

00:04:56,240 --> 00:05:00,110
Netflix and Hulu and all these different

00:04:57,950 --> 00:05:01,310
kinds of things so the idea is the

00:05:00,110 --> 00:05:03,800
traditional methods for building

00:05:01,310 --> 00:05:08,360
applications are starting to fall apart

00:05:03,800 --> 00:05:11,420
at various levels a good analogy is if

00:05:08,360 --> 00:05:13,130
you are a transportation company or

00:05:11,420 --> 00:05:15,050
moving company and you built your

00:05:13,130 --> 00:05:17,510
business on horse and wagon when the

00:05:15,050 --> 00:05:19,580
automobile was invented obviously your

00:05:17,510 --> 00:05:21,380
first reaction is the horse and wagon is

00:05:19,580 --> 00:05:23,180
a tried and true way to do things my

00:05:21,380 --> 00:05:25,790
whole establishment is set up to handle

00:05:23,180 --> 00:05:27,110
that my deployment mechanisms my supply

00:05:25,790 --> 00:05:28,910
chain all of it right

00:05:27,110 --> 00:05:31,070
this new automobile thing it's too much

00:05:28,910 --> 00:05:32,720
of a change right or I don't need it but

00:05:31,070 --> 00:05:34,550
as time goes on and your competitors

00:05:32,720 --> 00:05:36,800
start to embrace it they begin to

00:05:34,550 --> 00:05:38,330
outpace you and you get to be put into a

00:05:36,800 --> 00:05:38,900
position where you're like okay I'm in

00:05:38,330 --> 00:05:41,270
trouble here

00:05:38,900 --> 00:05:43,700
you know I've added 16 extra horses and

00:05:41,270 --> 00:05:45,110
wagons to my moving company but it's

00:05:43,700 --> 00:05:46,640
just not cutting it these trucks can

00:05:45,110 --> 00:05:49,250
hold more they can move faster they can

00:05:46,640 --> 00:05:51,800
go longer and so we have to think about

00:05:49,250 --> 00:05:53,690
how we're going to handle that and what

00:05:51,800 --> 00:05:55,430
we're going to do you know my horses get

00:05:53,690 --> 00:05:57,800
sick I got a shoe then there's all kinds

00:05:55,430 --> 00:06:00,260
of problems with an expanded fleet of

00:05:57,800 --> 00:06:01,610
horses that you are beginning to incur

00:06:00,260 --> 00:06:03,860
that perhaps you didn't when you were a

00:06:01,610 --> 00:06:05,300
smaller company and so the idea here is

00:06:03,860 --> 00:06:07,970
we don't need more horses or better

00:06:05,300 --> 00:06:11,169
wagons we need an entirely different way

00:06:07,970 --> 00:06:13,669
to do things we need an automobile and

00:06:11,169 --> 00:06:15,410
analogizing that to the monolith so I

00:06:13,669 --> 00:06:17,000
will tell you it's time to retire that

00:06:15,410 --> 00:06:19,400
way of thinking and embrace a new way of

00:06:17,000 --> 00:06:21,700
thinking embrace a new way to address

00:06:19,400 --> 00:06:24,950
these these challenges that we're facing

00:06:21,700 --> 00:06:27,290
so using the word microservice because

00:06:24,950 --> 00:06:28,970
we aren't any better word to use one

00:06:27,290 --> 00:06:29,900
definition and I think many of us are

00:06:28,970 --> 00:06:31,460
familiar with this some of the

00:06:29,900 --> 00:06:33,830
advantages of it is it supports a

00:06:31,460 --> 00:06:35,660
multiple team or a multiple autonomous

00:06:33,830 --> 00:06:38,320
teams it gives you the ability to scale

00:06:35,660 --> 00:06:39,780
development deploy independently and

00:06:38,320 --> 00:06:42,250
so forth those are all great things

00:06:39,780 --> 00:06:45,700
they're powerful you have one theme they

00:06:42,250 --> 00:06:46,750
can work in some degree isolation and be

00:06:45,700 --> 00:06:48,850
able to work on their thing without

00:06:46,750 --> 00:06:51,160
affecting another team and that's very

00:06:48,850 --> 00:06:53,250
powerful however that's more from an

00:06:51,160 --> 00:06:55,830
organizational or a developmental

00:06:53,250 --> 00:06:59,200
structure what I want to talk to you

00:06:55,830 --> 00:07:01,480
today is the idea of microservices and

00:06:59,200 --> 00:07:03,730
what I believe to be their their true

00:07:01,480 --> 00:07:07,240
context and that's distributed computing

00:07:03,730 --> 00:07:09,640
or distributed systems and how the idea

00:07:07,240 --> 00:07:14,980
of microservices gives you the ability

00:07:09,640 --> 00:07:17,440
to embrace and understand that model so

00:07:14,980 --> 00:07:21,400
a definition that I prefer is a system

00:07:17,440 --> 00:07:24,240
of autonomous collaborative distributed

00:07:21,400 --> 00:07:28,750
services a system of autonomous

00:07:24,240 --> 00:07:31,600
collaborative distributed services the

00:07:28,750 --> 00:07:34,270
idea is is you'll see two words that are

00:07:31,600 --> 00:07:35,770
highlighted their system and autonomous

00:07:34,270 --> 00:07:40,120
and their key aspects of understanding

00:07:35,770 --> 00:07:42,490
this the first part is autonomy and it

00:07:40,120 --> 00:07:44,860
comes from a Greek word autonomous right

00:07:42,490 --> 00:07:46,930
Auto meaning self and no Mis meaning

00:07:44,860 --> 00:07:49,750
role so you can kind of see where this

00:07:46,930 --> 00:07:52,480
is going an entity within a particular

00:07:49,750 --> 00:07:55,570
micro system or micro service gives

00:07:52,480 --> 00:07:58,860
oneself its own laws its self-governing

00:07:55,570 --> 00:08:01,900
this is important right it gives the

00:07:58,860 --> 00:08:05,620
entity the ability to be free from the

00:08:01,900 --> 00:08:08,080
bÃ¡b boundaries or free from the content

00:08:05,620 --> 00:08:10,390
of external influences in other words

00:08:08,080 --> 00:08:12,930
external influence is no longer have a

00:08:10,390 --> 00:08:15,550
Thor have authority over those

00:08:12,930 --> 00:08:17,980
individual services so you can make

00:08:15,550 --> 00:08:20,560
decisions independently you can act

00:08:17,980 --> 00:08:23,140
independently you can coordinate and

00:08:20,560 --> 00:08:26,910
cooperate and work together

00:08:23,140 --> 00:08:29,320
collaboratively to solve other problems

00:08:26,910 --> 00:08:31,360
this brings us to this idea of something

00:08:29,320 --> 00:08:33,040
called promise theory which i think is

00:08:31,360 --> 00:08:35,200
really neat it's a real fascinating

00:08:33,040 --> 00:08:38,979
thing and it's the way the world works

00:08:35,200 --> 00:08:41,169
except in computer science and the idea

00:08:38,979 --> 00:08:43,270
this gentleman mark Burgas he wrote

00:08:41,169 --> 00:08:45,220
about this and it's basically the

00:08:43,270 --> 00:08:47,740
understanding of an autonomous system

00:08:45,220 --> 00:08:49,050
and how it works in a collaborative

00:08:47,740 --> 00:08:51,820
environment

00:08:49,050 --> 00:08:53,680
so in DevOps this is

00:08:51,820 --> 00:08:55,270
has become relatively popular but

00:08:53,680 --> 00:08:56,800
there's a lot of great things here that

00:08:55,270 --> 00:08:59,290
I think can help us in computer science

00:08:56,800 --> 00:09:01,600
especially in the area building just

00:08:59,290 --> 00:09:03,550
distributed systems so when you're

00:09:01,600 --> 00:09:05,440
thinking about and this all ties into

00:09:03,550 --> 00:09:07,990
state management which we'll see shortly

00:09:05,440 --> 00:09:09,220
and ultimately composable identity but

00:09:07,990 --> 00:09:12,160
when you're thinking about building a

00:09:09,220 --> 00:09:13,600
system of particular micro service you

00:09:12,160 --> 00:09:16,000
want to begin to think and the idea of

00:09:13,600 --> 00:09:20,260
or in the realm of promises rather than

00:09:16,000 --> 00:09:22,660
obligations you want to think hey there

00:09:20,260 --> 00:09:24,610
is a way I'm going to present myself and

00:09:22,660 --> 00:09:26,050
I'm going to say hey I'm capable of

00:09:24,610 --> 00:09:27,790
doing certain things this is what I

00:09:26,050 --> 00:09:30,490
promise - this collaborative

00:09:27,790 --> 00:09:32,020
organization what I'm going to do this

00:09:30,490 --> 00:09:34,510
is my role this is how I'm going to

00:09:32,020 --> 00:09:37,320
approach it the opposite obviously is

00:09:34,510 --> 00:09:39,940
obligations where someone external

00:09:37,320 --> 00:09:42,280
obligates you or imposes their will upon

00:09:39,940 --> 00:09:45,160
you and that will in a distributed

00:09:42,280 --> 00:09:47,170
system is poe imposed across distributed

00:09:45,160 --> 00:09:51,420
boundaries and that begins to cause all

00:09:47,170 --> 00:09:53,410
kinds of problems it causes problems

00:09:51,420 --> 00:09:57,610
majority around performance

00:09:53,410 --> 00:10:01,330
it also bases your ability to perform or

00:09:57,610 --> 00:10:03,670
your behavior on someone else's ability

00:10:01,330 --> 00:10:06,120
to deliver and that is not good just

00:10:03,670 --> 00:10:08,650
like we know concrete contractual

00:10:06,120 --> 00:10:11,380
agreements and distributed systems are

00:10:08,650 --> 00:10:13,870
not good the the fact that your service

00:10:11,380 --> 00:10:16,390
is relying on another service to deliver

00:10:13,870 --> 00:10:19,780
and if it doesn't deliver your service

00:10:16,390 --> 00:10:22,060
fails is not a good thing so in the idea

00:10:19,780 --> 00:10:24,160
of autonomy you take control you have

00:10:22,060 --> 00:10:25,720
control the information that you need is

00:10:24,160 --> 00:10:28,360
local you have control over that

00:10:25,720 --> 00:10:31,060
information obligations like I said on

00:10:28,360 --> 00:10:34,570
the flip side is the inverse of that and

00:10:31,060 --> 00:10:39,220
we lose control and we base our ability

00:10:34,570 --> 00:10:42,820
to to do our job on the performance of

00:10:39,220 --> 00:10:45,310
someone else promises they start out by

00:10:42,820 --> 00:10:48,490
expressing an intent about where I want

00:10:45,310 --> 00:10:50,680
to go right an endpoint what you want to

00:10:48,490 --> 00:10:53,080
happen what the ultimate outcome should

00:10:50,680 --> 00:10:55,930
be and that is independent of your

00:10:53,080 --> 00:10:57,880
current status okay so if I say if I

00:10:55,930 --> 00:10:59,620
promise to somebody I'm going to meet

00:10:57,880 --> 00:11:00,940
them for lunch in an hour that's

00:10:59,620 --> 00:11:03,700
independent of what I'm doing right now

00:11:00,940 --> 00:11:04,930
that's my ultimate outcome obligations

00:11:03,700 --> 00:11:08,110
on the other hand

00:11:04,930 --> 00:11:11,199
are someone dictating to me what I'm

00:11:08,110 --> 00:11:12,699
going to do they define a starting point

00:11:11,199 --> 00:11:15,610
and the problem with that is because

00:11:12,699 --> 00:11:18,839
they're not within my my boundaries are

00:11:15,610 --> 00:11:22,119
not within my world my reality their

00:11:18,839 --> 00:11:23,679
obligation is specific to where they

00:11:22,119 --> 00:11:26,769
happen to be at the moment that they

00:11:23,679 --> 00:11:28,949
obligate me to do that and when they

00:11:26,769 --> 00:11:31,929
impose it on me so there's both time and

00:11:28,949 --> 00:11:33,939
geography constrictions that get applied

00:11:31,929 --> 00:11:36,309
when you're obligating things right so

00:11:33,939 --> 00:11:37,720
things change relative things are

00:11:36,309 --> 00:11:39,939
relative depending on where you're

00:11:37,720 --> 00:11:42,429
standing we know that from physics so

00:11:39,939 --> 00:11:45,850
that's the challenges and what happens

00:11:42,429 --> 00:11:47,730
is is promises have a tendency to lead

00:11:45,850 --> 00:11:50,050
you towards convergence we're

00:11:47,730 --> 00:11:52,360
obligations end up leading you towards

00:11:50,050 --> 00:11:54,730
divergence right convergence out of

00:11:52,360 --> 00:11:56,519
physics it leads us to a fixed point a

00:11:54,730 --> 00:11:59,319
stable system is what we're going after

00:11:56,519 --> 00:12:01,379
right we're divergence does the opposite

00:11:59,319 --> 00:12:04,869
that leads us to end stability

00:12:01,379 --> 00:12:07,269
obligations diverge because they diverge

00:12:04,869 --> 00:12:09,600
into unpredictable incomes while they

00:12:07,269 --> 00:12:12,519
start out with a definitive beginning I

00:12:09,600 --> 00:12:14,790
personai expect person B to be at lunch

00:12:12,519 --> 00:12:17,110
at 12:30 that's pretty definitive

00:12:14,790 --> 00:12:18,550
because you can't control the

00:12:17,110 --> 00:12:19,809
environment you can barely control the

00:12:18,550 --> 00:12:22,269
environment you're in let alone in

00:12:19,809 --> 00:12:24,490
someone else's environment right and as

00:12:22,269 --> 00:12:27,129
a result things begin to happen

00:12:24,490 --> 00:12:28,870
maybe the person gets sick or they get

00:12:27,129 --> 00:12:31,839
an important call or things begin to

00:12:28,870 --> 00:12:33,639
change so going from a certain state to

00:12:31,839 --> 00:12:36,009
an uncertain state is what occurs when

00:12:33,639 --> 00:12:39,579
you have obligations and your system

00:12:36,009 --> 00:12:42,309
begins to diverge leading to instability

00:12:39,579 --> 00:12:44,110
in the system whereas with a promise if

00:12:42,309 --> 00:12:46,959
I say I'm going to be at lunch unless

00:12:44,110 --> 00:12:48,730
it's a catastrophic emergency that I

00:12:46,959 --> 00:12:51,850
have to cancel I'm going to be at lunch

00:12:48,730 --> 00:12:54,129
right that's the promise I made while

00:12:51,850 --> 00:12:55,990
where I'm at when I make the promise is

00:12:54,129 --> 00:12:58,809
not necessarily definitive currently I'm

00:12:55,990 --> 00:13:01,480
giving a presentation the fact that I

00:12:58,809 --> 00:13:04,329
will be at lunch at 1:30 or whatever is

00:13:01,480 --> 00:13:06,939
is pretty solid so it leads the system

00:13:04,329 --> 00:13:08,649
from an undefined outcome to a more

00:13:06,939 --> 00:13:12,339
defined outcome and the result of this

00:13:08,649 --> 00:13:15,549
has improved stability and certainty of

00:13:12,339 --> 00:13:18,580
how your system works in layman's terms

00:13:15,549 --> 00:13:22,209
we call item Potence we have two system

00:13:18,580 --> 00:13:24,399
that are separated and one system needs

00:13:22,209 --> 00:13:26,589
to communicate with another system the

00:13:24,399 --> 00:13:28,600
idea is if I've already received that

00:13:26,589 --> 00:13:30,550
communication and I've procced it

00:13:28,600 --> 00:13:32,709
processed it and I'm satisfied with my

00:13:30,550 --> 00:13:34,899
processing then I can do nothing and

00:13:32,709 --> 00:13:36,630
this gets into a discussion which I'm

00:13:34,899 --> 00:13:39,579
not going to go into detail in this

00:13:36,630 --> 00:13:41,140
presentation but the idea of guaranteed

00:13:39,579 --> 00:13:44,850
message delivery and things like that

00:13:41,140 --> 00:13:48,240
and message based systems I like this 3

00:13:44,850 --> 00:13:51,279
by Mary promises are not guarantees

00:13:48,240 --> 00:13:53,620
guarantees are not possible and this is

00:13:51,279 --> 00:13:59,709
especially true when we get into complex

00:13:53,620 --> 00:14:02,829
systems like distributed systems so an

00:13:59,709 --> 00:14:05,620
autonomous service can promise its own

00:14:02,829 --> 00:14:07,720
behavior but that's all it can do right

00:14:05,620 --> 00:14:09,640
it can only promise its own behavior and

00:14:07,720 --> 00:14:11,740
when you begin to think about this idea

00:14:09,640 --> 00:14:14,079
and you begin to read about it this it's

00:14:11,740 --> 00:14:15,730
a fundamental yet simple concept it's

00:14:14,079 --> 00:14:18,250
the way you live your life for the most

00:14:15,730 --> 00:14:20,230
part yes many of us make promises we

00:14:18,250 --> 00:14:22,329
can't keep we overwork we take on too

00:14:20,230 --> 00:14:25,240
much responsibility but we all recognize

00:14:22,329 --> 00:14:27,820
that as an error and as we mature and we

00:14:25,240 --> 00:14:29,380
begin to identify our boundaries and set

00:14:27,820 --> 00:14:31,300
constraints on what we're willing to do

00:14:29,380 --> 00:14:33,339
and what we're not willing to do we move

00:14:31,300 --> 00:14:35,079
towards a position of more certainty and

00:14:33,339 --> 00:14:38,290
more stability in our life it's the same

00:14:35,079 --> 00:14:42,190
thing with a computer science same type

00:14:38,290 --> 00:14:44,170
of system it has a profound impact on

00:14:42,190 --> 00:14:45,700
how you build these systems what ends up

00:14:44,170 --> 00:14:47,620
happening is it gives you all the

00:14:45,700 --> 00:14:50,589
information that you need locally to

00:14:47,620 --> 00:14:52,540
resolve conflict to repair under failure

00:14:50,589 --> 00:14:55,029
what we call self-healing to be

00:14:52,540 --> 00:14:58,209
available be consistent within yourself

00:14:55,029 --> 00:15:00,730
right it removes the need for extraneous

00:14:58,209 --> 00:15:02,110
communication and coordination because

00:15:00,730 --> 00:15:03,880
it's just not realistic across

00:15:02,110 --> 00:15:05,709
distributed boundaries there's no

00:15:03,880 --> 00:15:07,570
guarantee we have latency we have all

00:15:05,709 --> 00:15:12,399
kinds of issues that we need to think

00:15:07,570 --> 00:15:13,990
about and this this idea behind all of

00:15:12,399 --> 00:15:15,519
this leads us to this notion of state

00:15:13,990 --> 00:15:17,649
management and consistent state

00:15:15,519 --> 00:15:19,060
management right what is it what is it

00:15:17,649 --> 00:15:22,449
it sounds like a problem and it is a

00:15:19,060 --> 00:15:23,800
problem right and monoliths were spoiled

00:15:22,449 --> 00:15:26,709
a little bit because we kind of have

00:15:23,800 --> 00:15:28,540
this like Fantasyland where we can have

00:15:26,709 --> 00:15:31,680
you know transactions that we can

00:15:28,540 --> 00:15:33,899
rollback and sequential processing and

00:15:31,680 --> 00:15:36,360
and you know a single database that

00:15:33,899 --> 00:15:38,279
everyone uses and so forth and the

00:15:36,360 --> 00:15:40,529
reality of it is is as we move into this

00:15:38,279 --> 00:15:43,320
new landscape the ability for that

00:15:40,529 --> 00:15:45,120
solution to solve our problems is is

00:15:43,320 --> 00:15:46,710
going by the wayside it ends up becoming

00:15:45,120 --> 00:15:49,470
a fairy tale

00:15:46,710 --> 00:15:50,880
the idea of strong consistency and and

00:15:49,470 --> 00:15:53,520
think about it a second we talk about

00:15:50,880 --> 00:15:54,029
strong consistency lightest banks rate

00:15:53,520 --> 00:15:57,510
Thanks

00:15:54,029 --> 00:16:00,570
financial institutions if thumb is

00:15:57,510 --> 00:16:02,130
strong consistency is like a commandment

00:16:00,570 --> 00:16:04,680
I have to have it then what do we have

00:16:02,130 --> 00:16:07,680
overdraft fees that should never happen

00:16:04,680 --> 00:16:10,010
if I'm strongly consistent right why do

00:16:07,680 --> 00:16:12,480
we have back water on inventory

00:16:10,010 --> 00:16:15,589
she's never happened we're strongly

00:16:12,480 --> 00:16:17,850
consistent we use the super database and

00:16:15,589 --> 00:16:20,279
but the writes how the real world works

00:16:17,850 --> 00:16:23,670
so why do we try to enforce our systems

00:16:20,279 --> 00:16:25,860
to to act in a way that the real world

00:16:23,670 --> 00:16:28,440
doesn't work I like to slide as the

00:16:25,860 --> 00:16:30,270
elephant in the room consistent state we

00:16:28,440 --> 00:16:32,070
talk about mutable state and how it's

00:16:30,270 --> 00:16:34,560
can be dangerous in distributed systems

00:16:32,070 --> 00:16:37,080
it's are we ignoring something that's

00:16:34,560 --> 00:16:39,060
important state management right in a

00:16:37,080 --> 00:16:40,529
distributed system it has to be managed

00:16:39,060 --> 00:16:43,410
differently than you do it in a model

00:16:40,529 --> 00:16:45,270
life and not only that are we not only

00:16:43,410 --> 00:16:49,140
ignoring the elephant but do we see the

00:16:45,270 --> 00:16:51,300
same elephant becomes the question so

00:16:49,140 --> 00:16:53,520
state management what what what is it

00:16:51,300 --> 00:16:55,170
one definition is a stateful means

00:16:53,520 --> 00:16:56,820
computer or a program that keeps track

00:16:55,170 --> 00:16:58,250
of State and interaction usually by

00:16:56,820 --> 00:17:00,720
setting a value in a storage feel

00:16:58,250 --> 00:17:02,700
designated by that per for that purpose

00:17:00,720 --> 00:17:05,910
and I think that's a reasonable

00:17:02,700 --> 00:17:07,559
definition kind of like in conjunction

00:17:05,910 --> 00:17:09,660
with that we have different mediums in

00:17:07,559 --> 00:17:11,910
which we can store state it can be hot

00:17:09,660 --> 00:17:14,010
warm cold these can be broken down even

00:17:11,910 --> 00:17:16,740
further you know basically your hot is

00:17:14,010 --> 00:17:19,050
in memory your warm is disc and cold is

00:17:16,740 --> 00:17:20,819
archiving or off-site a lot of times

00:17:19,050 --> 00:17:24,839
what's interesting is the volume of data

00:17:20,819 --> 00:17:27,929
that's processable increases or the

00:17:24,839 --> 00:17:29,960
volume of data that is stored decreases

00:17:27,929 --> 00:17:32,610
as you go up but the performance

00:17:29,960 --> 00:17:36,540
increases as you go up so it's much

00:17:32,610 --> 00:17:37,950
faster to store state and hot memory but

00:17:36,540 --> 00:17:39,780
the volume of data you can store in hot

00:17:37,950 --> 00:17:41,380
memory is generally less than what you

00:17:39,780 --> 00:17:45,890
would store in cold

00:17:41,380 --> 00:17:48,470
just to decide now but regardless of

00:17:45,890 --> 00:17:50,059
what storage medium you use the thing

00:17:48,470 --> 00:17:51,860
that you have to realize especially when

00:17:50,059 --> 00:17:54,169
you're looking across distributed

00:17:51,860 --> 00:17:56,840
boundaries is you are always looking at

00:17:54,169 --> 00:17:59,270
something from the past the state that

00:17:56,840 --> 00:18:00,919
you're reviewing you're always listening

00:17:59,270 --> 00:18:03,200
or you're always reviewing something

00:18:00,919 --> 00:18:05,630
from the past and that's why it's

00:18:03,200 --> 00:18:07,429
dangerous to be a Bob legate it because

00:18:05,630 --> 00:18:09,919
the state information that an external

00:18:07,429 --> 00:18:12,049
system gives you may be erroneous by the

00:18:09,919 --> 00:18:15,110
time that you process it and you are

00:18:12,049 --> 00:18:18,200
going to respond to an obligation of

00:18:15,110 --> 00:18:20,600
which the obligation has changed

00:18:18,200 --> 00:18:23,360
unbeknownst to you and do latency or due

00:18:20,600 --> 00:18:26,590
to whatever reason you have not been

00:18:23,360 --> 00:18:29,870
updated for that new new obligation so

00:18:26,590 --> 00:18:32,150
this becomes an issue understanding this

00:18:29,870 --> 00:18:35,510
can be both terrifying and liberating

00:18:32,150 --> 00:18:37,220
right the fact that we can be in a

00:18:35,510 --> 00:18:39,380
position where the data that we received

00:18:37,220 --> 00:18:42,289
is somewhat unreliable because it's

00:18:39,380 --> 00:18:44,390
historical in the sense if we're trying

00:18:42,289 --> 00:18:46,520
to make a decision about now that can be

00:18:44,390 --> 00:18:50,960
a little scary but it's also an

00:18:46,520 --> 00:18:52,610
environment that tells us that there's

00:18:50,960 --> 00:18:53,990
some exciting things that can happen in

00:18:52,610 --> 00:18:56,659
this environment this environment of

00:18:53,990 --> 00:18:59,390
distributed computing it shatters the

00:18:56,659 --> 00:19:01,940
solution that we strive for this global

00:18:59,390 --> 00:19:03,710
state of now that despite I'm where

00:19:01,940 --> 00:19:06,530
anyone comes into our application

00:19:03,710 --> 00:19:09,970
they're all going to see the same result

00:19:06,530 --> 00:19:12,169
which simply is it's it's not a reality

00:19:09,970 --> 00:19:16,010
there's a great cost of trying to

00:19:12,169 --> 00:19:19,159
maintain that with both anvil and Gunter

00:19:16,010 --> 00:19:21,140
right anvil basically said the effect on

00:19:19,159 --> 00:19:23,990
trying to maintain this type of illusion

00:19:21,140 --> 00:19:25,970
especially in parallel systems is the

00:19:23,990 --> 00:19:27,919
contention for resources gives us the

00:19:25,970 --> 00:19:31,570
menacing returns regardless of how many

00:19:27,919 --> 00:19:34,460
additional processors or concurrent met

00:19:31,570 --> 00:19:36,080
concurrent processes you add in going

00:19:34,460 --> 00:19:37,909
through took a step further and he said

00:19:36,080 --> 00:19:40,370
it also adds coherency in other words

00:19:37,909 --> 00:19:42,980
the value of the response or the data

00:19:40,370 --> 00:19:45,409
you're getting back is also depreciated

00:19:42,980 --> 00:19:48,860
as well and can have negative effects so

00:19:45,409 --> 00:19:50,570
by trying to enforce that idea in our

00:19:48,860 --> 00:19:53,940
design of our applications in our

00:19:50,570 --> 00:19:57,120
systems we had this this idea where

00:19:53,940 --> 00:19:59,519
as latency gets greater within a

00:19:57,120 --> 00:20:01,620
distributed system that illusion of a

00:19:59,519 --> 00:20:07,049
global state of now begins to crack more

00:20:01,620 --> 00:20:10,200
and more and more so Pat Helen if you've

00:20:07,049 --> 00:20:12,299
heard of them great guy he made a

00:20:10,200 --> 00:20:14,580
statement in a distributed system you

00:20:12,299 --> 00:20:16,620
can know where work is done or you can

00:20:14,580 --> 00:20:19,289
know when work is done but you can't

00:20:16,620 --> 00:20:21,210
know both you can know where it's done

00:20:19,289 --> 00:20:22,860
you can know when it's done but you

00:20:21,210 --> 00:20:24,529
can't know both these are certain

00:20:22,860 --> 00:20:27,620
realities that we just have to deal with

00:20:24,529 --> 00:20:30,179
we have to accept we want to change them

00:20:27,620 --> 00:20:32,190
we want to as a programmer it's my

00:20:30,179 --> 00:20:34,259
environment I will make it work but yeah

00:20:32,190 --> 00:20:36,779
you can make it work in isolation but

00:20:34,259 --> 00:20:39,779
once you do composability that that

00:20:36,779 --> 00:20:43,080
ability breaks down and so that leads us

00:20:39,779 --> 00:20:44,700
to you know a storm and building these

00:20:43,080 --> 00:20:47,129
types of applications in a distributed

00:20:44,700 --> 00:20:50,610
environment once you begin to exit that

00:20:47,129 --> 00:20:52,169
safety or that that little bounded area

00:20:50,610 --> 00:20:54,960
of your micro service you enter this

00:20:52,169 --> 00:20:56,039
wild wild west this wild ocean of

00:20:54,960 --> 00:20:58,409
non-determinism

00:20:56,039 --> 00:21:01,220
and what we call distributed systems the

00:20:58,409 --> 00:21:03,929
in-between area where things can fail

00:21:01,220 --> 00:21:07,259
fantastically and you don't understand

00:21:03,929 --> 00:21:08,700
or necessarily know why in intricate

00:21:07,259 --> 00:21:10,559
ways all kinds of crazy things

00:21:08,700 --> 00:21:12,899
information can get lost it can get

00:21:10,559 --> 00:21:14,730
garbled it could get restructured

00:21:12,899 --> 00:21:16,740
because things are happening outside of

00:21:14,730 --> 00:21:19,470
your control and while that all sounds

00:21:16,740 --> 00:21:21,690
very scary and terrifying the reality of

00:21:19,470 --> 00:21:25,230
it is it's also the same world that

00:21:21,690 --> 00:21:27,720
gives us the ability to be resilient it

00:21:25,230 --> 00:21:29,070
gives us the ability to be elastic it

00:21:27,720 --> 00:21:31,320
gives us the ability to scale

00:21:29,070 --> 00:21:34,320
independently it gives us the ability

00:21:31,320 --> 00:21:38,120
for us to do our job even though someone

00:21:34,320 --> 00:21:40,590
else may not be able to do their job and

00:21:38,120 --> 00:21:42,179
gives us the ability to isolate and so

00:21:40,590 --> 00:21:45,120
forth so there's positives and there's

00:21:42,179 --> 00:21:46,889
negatives and a lot of times we try to

00:21:45,120 --> 00:21:48,690
push the far the negatives away but we

00:21:46,889 --> 00:21:51,450
need to embrace them and understand them

00:21:48,690 --> 00:21:54,600
so as we apply the flaws of self-healing

00:21:51,450 --> 00:21:58,950
resiliency elasticity and so forth we do

00:21:54,600 --> 00:22:00,600
it correctly and confidently what a

00:21:58,950 --> 00:22:02,220
micro service ends up doing in this type

00:22:00,600 --> 00:22:04,529
of environment for us is it gives us

00:22:02,220 --> 00:22:07,350
like island we can work in in our micro

00:22:04,529 --> 00:22:07,660
service itself we can simulate some of

00:22:07,350 --> 00:22:09,580
them

00:22:07,660 --> 00:22:11,920
ethic behavior if there are aspects that

00:22:09,580 --> 00:22:15,520
need strong consistency we can implement

00:22:11,920 --> 00:22:18,340
that if need be we can kind of create an

00:22:15,520 --> 00:22:22,380
illusion where things are working

00:22:18,340 --> 00:22:25,360
properly and our view of now is current

00:22:22,380 --> 00:22:28,060
and and have that safety and that works

00:22:25,360 --> 00:22:29,950
great with testing very fantastic way of

00:22:28,060 --> 00:22:32,770
testing but we need to accept the

00:22:29,950 --> 00:22:34,450
responsibility of our own data we need

00:22:32,770 --> 00:22:37,060
to take responsibility for it and

00:22:34,450 --> 00:22:39,760
control it again another thing Pat says

00:22:37,060 --> 00:22:41,410
outside data or inside data is our

00:22:39,760 --> 00:22:45,520
current present that's our view of

00:22:41,410 --> 00:22:46,540
reality right outside data is a blast

00:22:45,520 --> 00:22:48,220
from the past

00:22:46,540 --> 00:22:49,900
because it's like looking at stars right

00:22:48,220 --> 00:22:50,950
you look at a store and that's ten

00:22:49,900 --> 00:22:53,380
thousand light years ago or whatever

00:22:50,950 --> 00:22:56,440
right we accept that normally but when

00:22:53,380 --> 00:22:58,900
we get into Kansai we try to change that

00:22:56,440 --> 00:23:01,240
and then in between right the in between

00:22:58,900 --> 00:23:03,000
services is hope for the future it's

00:23:01,240 --> 00:23:05,590
just like when I'm talking to a person

00:23:03,000 --> 00:23:07,690
they promised me they're going to meet

00:23:05,590 --> 00:23:09,760
me at launch it next time and that's my

00:23:07,690 --> 00:23:13,680
hope right I cross that distributed

00:23:09,760 --> 00:23:16,690
boundary phone call email what have you

00:23:13,680 --> 00:23:19,930
and so as a result what we propose is

00:23:16,690 --> 00:23:21,990
that you in a micro service in this this

00:23:19,930 --> 00:23:24,310
new design that you own your state

00:23:21,990 --> 00:23:26,410
exclusively right the left you see a

00:23:24,310 --> 00:23:27,880
monolith using a shared database on the

00:23:26,410 --> 00:23:29,950
right you see each individual micro

00:23:27,880 --> 00:23:31,450
service having their own database that

00:23:29,950 --> 00:23:34,540
breaks some principles that we grew up

00:23:31,450 --> 00:23:37,480
on right normalization data is not

00:23:34,540 --> 00:23:39,400
redundant if you're a CTRs fan on the

00:23:37,480 --> 00:23:42,190
query side there's literally tons of

00:23:39,400 --> 00:23:44,350
duplicated data right and that's okay

00:23:42,190 --> 00:23:46,330
that's okay some of the things that we

00:23:44,350 --> 00:23:48,820
learn that have been drilled indoor

00:23:46,330 --> 00:23:51,130
ahead as horrible things are actually

00:23:48,820 --> 00:23:53,350
not horrible at all in a distributed

00:23:51,130 --> 00:23:56,020
environment your micro service should

00:23:53,350 --> 00:23:57,700
own its own data the other fallacy like

00:23:56,020 --> 00:23:59,860
I'd like to put out is there's no such

00:23:57,700 --> 00:24:01,240
thing as a stateless architecture and I

00:23:59,860 --> 00:24:02,350
see it as quite a bit low this is going

00:24:01,240 --> 00:24:04,720
to be stateless is going to be stateless

00:24:02,350 --> 00:24:06,700
linguistic Casca in between where I'm

00:24:04,720 --> 00:24:08,920
gonna have a database you know keep my

00:24:06,700 --> 00:24:11,140
state management or whatever the reality

00:24:08,920 --> 00:24:13,510
of it is is it's still not stateless

00:24:11,140 --> 00:24:15,400
you're just pushing the state management

00:24:13,510 --> 00:24:17,380
off to somebody else you're pushing it

00:24:15,400 --> 00:24:19,420
off to a queue you're pushing it off to

00:24:17,380 --> 00:24:21,520
a database you're pushing it off to a

00:24:19,420 --> 00:24:23,140
shared resource who knows what

00:24:21,520 --> 00:24:25,360
somebody else is still managing that

00:24:23,140 --> 00:24:27,640
state and you have to pay the penalty to

00:24:25,360 --> 00:24:31,780
hydrate it and dehydrate it when you're

00:24:27,640 --> 00:24:35,050
exiting and entering your system it

00:24:31,780 --> 00:24:36,790
makes it harder to control right and the

00:24:35,050 --> 00:24:38,680
integrity it makes the harder for you to

00:24:36,790 --> 00:24:40,990
have integrity guarantees that make

00:24:38,680 --> 00:24:44,710
scalability difficult are more difficult

00:24:40,990 --> 00:24:46,210
it makes available ability difficult so

00:24:44,710 --> 00:24:47,710
I would argue that you should take

00:24:46,210 --> 00:24:48,820
control of your own state and managing

00:24:47,710 --> 00:24:51,280
yourself does that mean you shouldn't

00:24:48,820 --> 00:24:52,690
use a database or q no not at all but

00:24:51,280 --> 00:24:55,150
there's a lot of places where you can

00:24:52,690 --> 00:24:56,950
manage hot state in memory and give

00:24:55,150 --> 00:24:59,230
wonderful answers you can manage

00:24:56,950 --> 00:25:02,050
duplicate data on the query side for

00:24:59,230 --> 00:25:06,550
secure s and give instant answers etc

00:25:02,050 --> 00:25:07,990
and to achieve this again we'll talk a

00:25:06,550 --> 00:25:09,880
little bit about the manger in design

00:25:07,990 --> 00:25:11,560
but you have this idea of consistent

00:25:09,880 --> 00:25:14,020
boundaries you want to identify what

00:25:11,560 --> 00:25:15,580
your behavior is what your data is one

00:25:14,020 --> 00:25:17,860
of the best ways to look at this is take

00:25:15,580 --> 00:25:19,480
a look at your data first how the data

00:25:17,860 --> 00:25:22,270
interacts try to understand the data

00:25:19,480 --> 00:25:24,520
structures figure out what the SLA s are

00:25:22,270 --> 00:25:27,460
the integrity guarantees of the data and

00:25:24,520 --> 00:25:29,170
what the business needs begin to try to

00:25:27,460 --> 00:25:31,180
minimize your data sets and then you can

00:25:29,170 --> 00:25:32,890
take a look at what needs to be strongly

00:25:31,180 --> 00:25:34,600
consistent what doesn't need to be

00:25:32,890 --> 00:25:37,060
strongly consistent and then you can

00:25:34,600 --> 00:25:39,430
kind of begin to layer behavior over top

00:25:37,060 --> 00:25:42,040
of this process and all of a sudden you

00:25:39,430 --> 00:25:46,930
begin to materialize of what a potential

00:25:42,040 --> 00:25:48,880
micro service might be again as I had

00:25:46,930 --> 00:25:51,580
mentioned earlier bounded context from

00:25:48,880 --> 00:25:53,200
the main driven design it's really kind

00:25:51,580 --> 00:25:55,600
of like distributed domain driven design

00:25:53,200 --> 00:25:57,850
but you're going to define a specific

00:25:55,600 --> 00:25:59,710
domain within a bounded context I think

00:25:57,850 --> 00:26:01,240
the example that Eric you one of the

00:25:59,710 --> 00:26:02,350
examples that Eric's uses in this book

00:26:01,240 --> 00:26:05,020
that I think is really good as an

00:26:02,350 --> 00:26:07,150
invoice to one bound of context is not

00:26:05,020 --> 00:26:08,680
necessarily the same thing to another

00:26:07,150 --> 00:26:10,780
bound of context so you can have an

00:26:08,680 --> 00:26:13,450
invoice object and accounts receivable

00:26:10,780 --> 00:26:15,130
and an invoice object and sales or

00:26:13,450 --> 00:26:16,840
something they can be two separate

00:26:15,130 --> 00:26:19,600
objects they may share a lot of the same

00:26:16,840 --> 00:26:22,420
kind of data but that's okay you need to

00:26:19,600 --> 00:26:24,520
protect yourself against the other

00:26:22,420 --> 00:26:29,170
services and the problems that they can

00:26:24,520 --> 00:26:33,280
cause so how do we manage this stuff

00:26:29,170 --> 00:26:35,410
well eventual consistency don't be

00:26:33,280 --> 00:26:36,930
surprised it's how the world works

00:26:35,410 --> 00:26:39,850
everything is eventually consistent

00:26:36,930 --> 00:26:41,650
overdress backorder there are some

00:26:39,850 --> 00:26:44,530
stronger guarantees and consistency

00:26:41,650 --> 00:26:46,390
models such as causal consistency and so

00:26:44,530 --> 00:26:48,640
forth and there are other ways that you

00:26:46,390 --> 00:26:49,780
can explore to tighten things up a

00:26:48,640 --> 00:26:52,360
little bit

00:26:49,780 --> 00:26:55,960
we have a caddis tributed data which is

00:26:52,360 --> 00:26:58,480
essentially a hot memory model that

00:26:55,960 --> 00:27:00,880
allows you to very quickly with an

00:26:58,480 --> 00:27:03,040
algebraic structure replicate data

00:27:00,880 --> 00:27:05,920
across nodes so whatever nodes you come

00:27:03,040 --> 00:27:07,900
in you see the same thing but ultimately

00:27:05,920 --> 00:27:10,540
eventual consistency is the under stay

00:27:07,900 --> 00:27:12,970
of all this rather than rejecting it

00:27:10,540 --> 00:27:16,480
embrace it accept it it's how you live

00:27:12,970 --> 00:27:19,510
your life right understand it understand

00:27:16,480 --> 00:27:21,490
how it works in computer science in the

00:27:19,510 --> 00:27:23,260
perfect world I'd love to have strong

00:27:21,490 --> 00:27:25,240
consistency everywhere like

00:27:23,260 --> 00:27:30,010
instantaneous great but it just is not

00:27:25,240 --> 00:27:32,440
reality right by embracing a term like

00:27:30,010 --> 00:27:34,420
or embracing eventual consistency you're

00:27:32,440 --> 00:27:36,880
able to do things like raise the ceiling

00:27:34,420 --> 00:27:38,890
of the performance of your application

00:27:36,880 --> 00:27:41,050
you're able to loosely couple things

00:27:38,890 --> 00:27:42,790
you're able to scale things now you've

00:27:41,050 --> 00:27:44,440
broken those dependencies on other

00:27:42,790 --> 00:27:46,450
systems you've pulled your versioning

00:27:44,440 --> 00:27:48,910
down into your micro services and you're

00:27:46,450 --> 00:27:51,610
now able to do things and when you say

00:27:48,910 --> 00:27:53,650
your test runs and it passes you know

00:27:51,610 --> 00:27:56,080
for a fact that your service is working

00:27:53,650 --> 00:27:58,720
if the node.js front-end is having some

00:27:56,080 --> 00:28:00,220
strange problems and not projecting the

00:27:58,720 --> 00:28:01,600
correct information you know it's not

00:28:00,220 --> 00:28:03,820
your service it's somewhere in between

00:28:01,600 --> 00:28:04,840
because your test says that your service

00:28:03,820 --> 00:28:07,450
is working properly

00:28:04,840 --> 00:28:09,400
right you wrote your test as a headless

00:28:07,450 --> 00:28:12,700
service this whole idea about cap

00:28:09,400 --> 00:28:14,770
theorem consistency availability and

00:28:12,700 --> 00:28:17,380
partition tolerance and distribute the

00:28:14,770 --> 00:28:20,530
system's eventual consistency is a key

00:28:17,380 --> 00:28:22,650
tenant which helps us do this now this

00:28:20,530 --> 00:28:25,750
all leads us to this idea of identity

00:28:22,650 --> 00:28:27,520
composing composable identity the

00:28:25,750 --> 00:28:29,590
meaning of life at the end of the day we

00:28:27,520 --> 00:28:31,240
have a system that represen is

00:28:29,590 --> 00:28:32,940
represented a distributed system that is

00:28:31,240 --> 00:28:35,920
represented by a whole bunch of

00:28:32,940 --> 00:28:38,020
different micro services that are an

00:28:35,920 --> 00:28:40,740
identity and that identity is composable

00:28:38,020 --> 00:28:42,700
and tiered at multiple multiple levels

00:28:40,740 --> 00:28:44,590
gmail has an identity

00:28:42,700 --> 00:28:46,690
it's called Gmail it's an email service

00:28:44,590 --> 00:28:48,250
but there's also many different

00:28:46,690 --> 00:28:49,389
identities within Gmail there's

00:28:48,250 --> 00:28:52,719
advertisement identity

00:28:49,389 --> 00:28:55,149
there's user identities people uge gmail

00:28:52,719 --> 00:28:57,070
in a sense or their own identity and so

00:28:55,149 --> 00:28:59,320
forth and these things are important

00:28:57,070 --> 00:29:02,200
because that's the projection that the

00:28:59,320 --> 00:29:06,940
customer sees at some form at some level

00:29:02,200 --> 00:29:08,889
the customer sees identity so how do we

00:29:06,940 --> 00:29:10,959
achieve things like this composable

00:29:08,889 --> 00:29:13,749
identity well one of the things is it's

00:29:10,959 --> 00:29:15,700
just like polyglot programming polyglot

00:29:13,749 --> 00:29:17,979
consistence the idea again a micro

00:29:15,700 --> 00:29:20,259
service use whatever storage medium

00:29:17,979 --> 00:29:22,359
works best for your service one service

00:29:20,259 --> 00:29:24,339
it might be concentra another service it

00:29:22,359 --> 00:29:26,379
might be another service it might

00:29:24,339 --> 00:29:28,719
be careful whatever another service that

00:29:26,379 --> 00:29:29,859
may be just hot memory it all depends on

00:29:28,719 --> 00:29:32,769
the business it depends on what the

00:29:29,859 --> 00:29:35,379
business needs are in determining how

00:29:32,769 --> 00:29:38,200
that service should operate so use what

00:29:35,379 --> 00:29:41,979
fits your basically decentralizing data

00:29:38,200 --> 00:29:45,639
management and you're using this idea of

00:29:41,979 --> 00:29:48,190
polyglot persistence again Pat Helen

00:29:45,639 --> 00:29:52,869
says the truth is the log the database

00:29:48,190 --> 00:29:55,389
is a cache of a subset of the log and so

00:29:52,869 --> 00:29:57,729
his thing is is why are we using

00:29:55,389 --> 00:30:00,129
databases where we do normalization and

00:29:57,729 --> 00:30:01,629
abstract all this data over multiple

00:30:00,129 --> 00:30:03,969
levels when we can just get access to

00:30:01,629 --> 00:30:05,859
the real data itself right so what does

00:30:03,969 --> 00:30:08,859
he mean by that you know he says the log

00:30:05,859 --> 00:30:11,409
is the truth to me this is the easiest

00:30:08,859 --> 00:30:14,229
example Plamen by all means this is a

00:30:11,409 --> 00:30:16,419
canonical example of an event log it's a

00:30:14,229 --> 00:30:18,369
ledger it's how your bank does your

00:30:16,419 --> 00:30:19,779
checkbook hopefully your checking

00:30:18,369 --> 00:30:22,479
account or your savings account you have

00:30:19,779 --> 00:30:24,700
debits near credits they don't update

00:30:22,479 --> 00:30:27,609
current state when you make a deposit

00:30:24,700 --> 00:30:30,759
they don't change your balance and in

00:30:27,609 --> 00:30:32,799
the classical sense and overwrite what

00:30:30,759 --> 00:30:35,289
it is right they add a new line entry

00:30:32,799 --> 00:30:36,729
and then they derive the balance now

00:30:35,289 --> 00:30:38,229
they may have an algorithm that drives

00:30:36,729 --> 00:30:40,809
the balance every time a new entry is

00:30:38,229 --> 00:30:42,820
mages for optimization but ultimately

00:30:40,809 --> 00:30:45,339
they have this event store that's append

00:30:42,820 --> 00:30:49,419
only the debit or the credit is added on

00:30:45,339 --> 00:30:53,320
so to explain this I like their use this

00:30:49,419 --> 00:30:56,499
example of a crud versus a reactive

00:30:53,320 --> 00:30:58,119
shopping court I call it event sourcing

00:30:56,499 --> 00:30:59,559
everybody the Christ shopping this is a

00:30:58,119 --> 00:31:02,500
Christ shopping court create read update

00:30:59,559 --> 00:31:04,120
and delete just

00:31:02,500 --> 00:31:05,500
due to the lack of time I'm going to go

00:31:04,120 --> 00:31:07,780
through this relatively quickly but you

00:31:05,500 --> 00:31:10,120
can see what's going on here eight

00:31:07,780 --> 00:31:13,840
things occur we have four items added

00:31:10,120 --> 00:31:16,560
shipping a totals generated inserted

00:31:13,840 --> 00:31:19,630
into the order and the order line and

00:31:16,560 --> 00:31:23,380
then at some point in future before that

00:31:19,630 --> 00:31:25,060
order is actually begun to be fulfilled

00:31:23,380 --> 00:31:26,560
the customer logs back in and says you

00:31:25,060 --> 00:31:28,270
know what that that fourth item of that

00:31:26,560 --> 00:31:30,190
second item I don't want it so I'm going

00:31:28,270 --> 00:31:31,570
to pull it out and update my order so

00:31:30,190 --> 00:31:34,180
whenever happening as the order line

00:31:31,570 --> 00:31:35,800
deletes that row it's no longer part of

00:31:34,180 --> 00:31:37,480
the part of the order and everything

00:31:35,800 --> 00:31:40,330
gets readjusted the balance is now

00:31:37,480 --> 00:31:42,310
forty-seven dollars and so this is kind

00:31:40,330 --> 00:31:44,980
of what we have at the end we have the

00:31:42,310 --> 00:31:47,170
order we have the total and in our order

00:31:44,980 --> 00:31:49,090
item order item or order line we have

00:31:47,170 --> 00:31:51,910
three rows which represent the orders

00:31:49,090 --> 00:31:55,300
and we have shipping information stored

00:31:51,910 --> 00:31:56,950
in another table now your manager comes

00:31:55,300 --> 00:31:58,660
along he says look there's a particular

00:31:56,950 --> 00:31:59,650
item that's not selling very well we're

00:31:58,660 --> 00:32:01,930
not really sure

00:31:59,650 --> 00:32:04,240
it could be customers or removing it

00:32:01,930 --> 00:32:06,370
from the carts or whatever I want you to

00:32:04,240 --> 00:32:08,020
generate a report for me and I want that

00:32:06,370 --> 00:32:10,240
report to show me every time a customer

00:32:08,020 --> 00:32:12,130
deletes this particular type of item

00:32:10,240 --> 00:32:16,000
from the cart and so what's your answer

00:32:12,130 --> 00:32:17,530
tell me I can't do that but here's what

00:32:16,000 --> 00:32:20,590
I can do for you we'll start a new

00:32:17,530 --> 00:32:23,260
sprint will add audit logging we'll use

00:32:20,590 --> 00:32:24,400
hibernate and Tver will track that items

00:32:23,260 --> 00:32:26,230
that are deleted from shopping carts

00:32:24,400 --> 00:32:28,030
will push that out in the next

00:32:26,230 --> 00:32:28,540
appointment and you'll have what you

00:32:28,030 --> 00:32:30,550
want

00:32:28,540 --> 00:32:32,440
sounds great right well first of all

00:32:30,550 --> 00:32:34,270
you've got to vote is probably a sprint

00:32:32,440 --> 00:32:36,220
to it hibernating bears or whatever

00:32:34,270 --> 00:32:38,560
you're using for audit logging and the

00:32:36,220 --> 00:32:40,540
reality of it is is only from that point

00:32:38,560 --> 00:32:42,670
forward that it's deployed that you're

00:32:40,540 --> 00:32:44,740
able to provide that information all

00:32:42,670 --> 00:32:46,870
that other historical data you have is

00:32:44,740 --> 00:32:48,540
lost there's no way for you to derive

00:32:46,870 --> 00:32:52,030
that information and that's a

00:32:48,540 --> 00:32:54,100
substantial impact on business that's

00:32:52,030 --> 00:32:56,680
how static state models and lrms work

00:32:54,100 --> 00:32:58,540
right they're good they work but they

00:32:56,680 --> 00:33:00,580
come in a large cost they maintain

00:32:58,540 --> 00:33:02,380
current state your domains tightly

00:33:00,580 --> 00:33:04,480
coupled to the model you have to deal

00:33:02,380 --> 00:33:08,110
with leaky abstractions you have to deal

00:33:04,480 --> 00:33:10,150
with anemic domain models and ultimately

00:33:08,110 --> 00:33:11,500
the intent of the user the purpose of

00:33:10,150 --> 00:33:13,720
how they're using the system is lost

00:33:11,500 --> 00:33:16,020
because you're only capturing current

00:33:13,720 --> 00:33:16,020
state

00:33:16,109 --> 00:33:19,409
essentially the way they work is they

00:33:17,369 --> 00:33:20,700
represent there's a good thing about and

00:33:19,409 --> 00:33:23,369
they represent a change between two

00:33:20,700 --> 00:33:25,229
points which we call a delta and the

00:33:23,369 --> 00:33:27,989
back end manages this the deltas are

00:33:25,229 --> 00:33:30,450
implicit and the ORM updates the backing

00:33:27,989 --> 00:33:33,029
model by calculating discs and working

00:33:30,450 --> 00:33:34,619
through the the convergence problems and

00:33:33,029 --> 00:33:38,099
then ultimately it ends up getting

00:33:34,619 --> 00:33:41,239
stored into the database auditing is

00:33:38,099 --> 00:33:45,629
always has to be explicit in most cases

00:33:41,239 --> 00:33:48,239
now this is a reactive shopping card all

00:33:45,629 --> 00:33:49,529
right a little bit more beefy and we're

00:33:48,239 --> 00:33:52,320
going to go back to our example here

00:33:49,529 --> 00:33:53,729
real quickly what are events I'm sure

00:33:52,320 --> 00:33:55,619
many you're familiar they're basically

00:33:53,729 --> 00:33:57,869
notifications that something has

00:33:55,619 --> 00:34:01,259
occurred they cannot be rejected because

00:33:57,869 --> 00:34:03,119
they're historical recording an example

00:34:01,259 --> 00:34:06,690
would be client registered client locale

00:34:03,119 --> 00:34:08,639
changed we go back to our example it's

00:34:06,690 --> 00:34:11,490
the same thing except for the very last

00:34:08,639 --> 00:34:14,099
bullet or item number number eight where

00:34:11,490 --> 00:34:15,720
it says 123 the event stream is inserted

00:34:14,099 --> 00:34:17,460
now you can insert these as a stream you

00:34:15,720 --> 00:34:18,059
can do it as an individual event one

00:34:17,460 --> 00:34:20,609
after another

00:34:18,059 --> 00:34:22,980
however but ultimately what we come up

00:34:20,609 --> 00:34:26,849
with is this we have a sequence of

00:34:22,980 --> 00:34:31,500
Rights append-only x' one after another

00:34:26,849 --> 00:34:33,329
that identify behavior in the form of

00:34:31,500 --> 00:34:36,750
events which get persisted to the

00:34:33,329 --> 00:34:41,700
database now your manager comes back and

00:34:36,750 --> 00:34:43,770
asks you the same problem our leading up

00:34:41,700 --> 00:34:45,210
to that the customer comes in and

00:34:43,770 --> 00:34:47,879
deletes the item and this is what

00:34:45,210 --> 00:34:49,440
happens it now gets added or appended to

00:34:47,879 --> 00:34:52,559
the log as a new event nothing is

00:34:49,440 --> 00:34:55,409
deleted just a new event is stored in

00:34:52,559 --> 00:34:57,089
the log that says the customer the Lea

00:34:55,409 --> 00:34:59,520
did this item out of the shopping cart

00:34:57,089 --> 00:35:01,980
so what you can begin to see is if you

00:34:59,520 --> 00:35:04,859
begin to play this back you can compose

00:35:01,980 --> 00:35:07,770
current state at various parts through

00:35:04,859 --> 00:35:10,529
the historical stream of events that are

00:35:07,770 --> 00:35:11,970
persisted at any point you can begin to

00:35:10,529 --> 00:35:12,660
observe behavior oh wow that's

00:35:11,970 --> 00:35:14,730
interesting

00:35:12,660 --> 00:35:16,650
this person deleted it after it was in

00:35:14,730 --> 00:35:18,059
the shopping cart for 30 seconds but

00:35:16,650 --> 00:35:20,940
this person deleted in the shopping cart

00:35:18,059 --> 00:35:23,190
after was there for five minutes who

00:35:20,940 --> 00:35:27,930
knows what that means right but it could

00:35:23,190 --> 00:35:29,720
mean something and you're able to derive

00:35:27,930 --> 00:35:32,300
current state by replaying these

00:35:29,720 --> 00:35:35,000
vents were for optimization purposes you

00:35:32,300 --> 00:35:36,830
can snapshot current state you have a

00:35:35,000 --> 00:35:37,970
hot memory and so forth we can talk

00:35:36,830 --> 00:35:42,490
about that afterwards if you have

00:35:37,970 --> 00:35:45,080
questions the data is not persisted

00:35:42,490 --> 00:35:46,910
structurally its persisted as a series

00:35:45,080 --> 00:35:51,190
of events and there's no coupling

00:35:46,910 --> 00:35:54,109
between the domain model and the

00:35:51,190 --> 00:35:56,810
database model so the technology

00:35:54,109 --> 00:35:59,599
implications it's additive architecture

00:35:56,810 --> 00:36:01,430
right and it's beautiful for

00:35:59,599 --> 00:36:03,770
distributing it's an append-only key

00:36:01,430 --> 00:36:06,580
some kind of hash there's no complicated

00:36:03,770 --> 00:36:09,109
key there's no locks or fewer locks

00:36:06,580 --> 00:36:10,790
whorls or horizontal partitioning and

00:36:09,109 --> 00:36:12,859
relational databases can be difficult

00:36:10,790 --> 00:36:16,790
because of complexity of keys and this

00:36:12,859 --> 00:36:18,260
model is very very simple and with an

00:36:16,790 --> 00:36:20,780
event store you know you basically have

00:36:18,260 --> 00:36:23,720
one hash key which makes it real easy to

00:36:20,780 --> 00:36:27,020
sure'd business implications you're

00:36:23,720 --> 00:36:29,720
tracking from inception depending on the

00:36:27,020 --> 00:36:31,280
granularity of your event model what's

00:36:29,720 --> 00:36:33,500
happening in streams so you're capturing

00:36:31,280 --> 00:36:35,540
behavior you're able to answer questions

00:36:33,500 --> 00:36:36,859
from the origin of the system and you're

00:36:35,540 --> 00:36:39,290
able to answer questions that are

00:36:36,859 --> 00:36:41,030
potentially not yet been asked because

00:36:39,290 --> 00:36:43,490
you have this extra data that you can

00:36:41,030 --> 00:36:47,720
analyze and take a look at and it also

00:36:43,490 --> 00:36:50,599
gives you a natural audit log that Helen

00:36:47,720 --> 00:36:52,910
has a great paper life beyond

00:36:50,599 --> 00:36:57,800
distributed trends actions and apostate

00:36:52,910 --> 00:36:59,990
opinion I highly recommend reading it we

00:36:57,800 --> 00:37:02,660
can talk offline but I'm not a big fan

00:36:59,990 --> 00:37:05,119
of transactions to a certain degree yes

00:37:02,660 --> 00:37:08,300
but the notion of you know these

00:37:05,119 --> 00:37:11,150
distributed transactions and stuff and

00:37:08,300 --> 00:37:14,060
all the challenges and issues so but

00:37:11,150 --> 00:37:16,790
anyways great paper I would read it and

00:37:14,060 --> 00:37:18,619
so this is what we end up with this is

00:37:16,790 --> 00:37:21,170
the reality that we deal with we deal

00:37:18,619 --> 00:37:24,230
with in life and this is the system that

00:37:21,170 --> 00:37:29,000
we ultimately will strive to build in

00:37:24,230 --> 00:37:30,500
life State yields identity right the

00:37:29,000 --> 00:37:33,140
example I like to say is let's say I'm a

00:37:30,500 --> 00:37:35,599
rugby player and at the current time my

00:37:33,140 --> 00:37:37,220
state is healthy and I'm going to go

00:37:35,599 --> 00:37:39,619
play a rub I'm going to go play rugby

00:37:37,220 --> 00:37:41,990
I'm going to be a rugby player but on

00:37:39,619 --> 00:37:43,099
the way to the rugby game I get into a

00:37:41,990 --> 00:37:46,549
car accident

00:37:43,099 --> 00:37:49,789
and I get damaged right what happens is

00:37:46,549 --> 00:37:53,539
my my state has been changed I broke my

00:37:49,789 --> 00:37:56,449
arm okay as a result of that state

00:37:53,539 --> 00:37:59,150
change my identity has now also changed

00:37:56,449 --> 00:38:01,849
I have become a patient I am no longer a

00:37:59,150 --> 00:38:04,219
rugby player these are the realities of

00:38:01,849 --> 00:38:07,039
life these are the realities of building

00:38:04,219 --> 00:38:10,219
systems I have to be able to within my

00:38:07,039 --> 00:38:13,489
own bounded context and my own isolated

00:38:10,219 --> 00:38:15,589
instance call my coach and say I broke

00:38:13,489 --> 00:38:18,259
my arm you need to stick Johnny in as a

00:38:15,589 --> 00:38:20,749
replacement we have just now self healed

00:38:18,259 --> 00:38:23,449
the team and I'm able to with my new to

00:38:20,749 --> 00:38:26,089
identity go to the hospital and get my

00:38:23,449 --> 00:38:27,799
arm fixed and continue to work and maybe

00:38:26,089 --> 00:38:31,670
come back and help coach into my arm

00:38:27,799 --> 00:38:33,799
heals that's life that's reality that's

00:38:31,670 --> 00:38:36,529
how we need to build systems today and

00:38:33,799 --> 00:38:38,390
then the big box system composable

00:38:36,529 --> 00:38:41,180
identity it's all those little micro

00:38:38,390 --> 00:38:43,789
services that represent that those

00:38:41,180 --> 00:38:49,549
concepts and that can be aggregated into

00:38:43,789 --> 00:38:52,400
one global view of what identity is and

00:38:49,549 --> 00:38:54,259
it can also be decomposed down into the

00:38:52,400 --> 00:38:55,880
individual states so if you're one of

00:38:54,259 --> 00:38:58,160
those guys that loves composable futures

00:38:55,880 --> 00:38:59,959
this is right up your alley you can do

00:38:58,160 --> 00:39:03,739
this with actors and all that kind of

00:38:59,959 --> 00:39:05,900
stuff as well so sorry for the rush

00:39:03,739 --> 00:39:09,019
there's a lot to go through there I hope

00:39:05,900 --> 00:39:10,339
at some level this was useful for you I

00:39:09,019 --> 00:39:13,099
don't know if we have any time for

00:39:10,339 --> 00:39:15,289
questions if we don't feel free to come

00:39:13,099 --> 00:39:16,900
up and ask questions and we can go from

00:39:15,289 --> 00:39:23,840
there

00:39:16,900 --> 00:39:23,840

YouTube URL: https://www.youtube.com/watch?v=5qrk-WcTEEk


