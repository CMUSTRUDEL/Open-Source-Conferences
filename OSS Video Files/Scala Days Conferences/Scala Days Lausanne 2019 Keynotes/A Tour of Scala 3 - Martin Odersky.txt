Title: A Tour of Scala 3 - Martin Odersky
Publication date: 2019-07-11
Playlist: Scala Days Lausanne 2019 Keynotes
Description: 
	This video was recorded at Scala Days Lausanne 2019
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://scaladays.org/schedule/a-tour-of-scala-3
Captions: 
	00:00:00,030 --> 00:00:07,140
cool so I'm gonna be here to give the

00:00:05,279 --> 00:00:09,330
welcome address for this 10th

00:00:07,140 --> 00:00:11,670
anniversary edition of Scala days and

00:00:09,330 --> 00:00:14,580
I'm gonna talk mostly about a tour of

00:00:11,670 --> 00:00:17,460
Scala 3 but before I do that I also want

00:00:14,580 --> 00:00:19,859
to show some of the photos of Scala 3 so

00:00:17,460 --> 00:00:23,369
it was in a much smaller building this

00:00:19,859 --> 00:00:26,189
building doesn't exist yet 155 people it

00:00:23,369 --> 00:00:28,650
was packed with that actually it was

00:00:26,189 --> 00:00:31,380
really dangerous because here you see me

00:00:28,650 --> 00:00:33,899
very close to actually the border of

00:00:31,380 --> 00:00:36,600
this podium and in fact probably a

00:00:33,899 --> 00:00:39,030
second later so I fell off fell off it

00:00:36,600 --> 00:00:41,700
between this thing and and the screen

00:00:39,030 --> 00:00:45,300
and then resurfaced so here I already

00:00:41,700 --> 00:00:48,660
looked and it looks solid so I hope it

00:00:45,300 --> 00:00:51,570
won't happen we were all quite a lot

00:00:48,660 --> 00:00:53,910
younger than you can see and you can

00:00:51,570 --> 00:00:57,000
already see some of the germs of the

00:00:53,910 --> 00:00:59,340
software that we that you is sort of our

00:00:57,000 --> 00:01:01,399
daily life now so here I think that was

00:00:59,340 --> 00:01:05,970
probably the first presentation of akka

00:01:01,399 --> 00:01:08,549
Yanis and Victor here we have Mahara no

00:01:05,970 --> 00:01:11,549
doubt thinking about all the grandiose

00:01:08,549 --> 00:01:14,040
designs of SBT that he had in mind here

00:01:11,549 --> 00:01:16,710
we have miles and miles was not yet

00:01:14,040 --> 00:01:20,960
working on shapeless and I will keep

00:01:16,710 --> 00:01:20,960
silence on what he what he did then

00:01:21,470 --> 00:01:27,720
there were some curious parallels

00:01:23,729 --> 00:01:30,270
between then and now so in 2010 what was

00:01:27,720 --> 00:01:33,210
new for the old-timers in Scala what can

00:01:30,270 --> 00:01:35,880
you remember what was what was the hot

00:01:33,210 --> 00:01:39,329
new thing in 2010 where it was actually

00:01:35,880 --> 00:01:41,909
collections Scala 2.8 came out at that

00:01:39,329 --> 00:01:44,100
conference and the big new thing was

00:01:41,909 --> 00:01:46,310
essentially a complete collections

00:01:44,100 --> 00:01:48,450
framework which had functional and

00:01:46,310 --> 00:01:50,149
mutable collections in the same

00:01:48,450 --> 00:01:52,560
framework before we had sort of

00:01:50,149 --> 00:01:55,229
odds-and-ends some specific collections

00:01:52,560 --> 00:01:58,740
but not nothing completely generalized

00:01:55,229 --> 00:02:01,380
and today well today we released

00:01:58,740 --> 00:02:05,939
yesterday 213 and what's the highlight

00:02:01,380 --> 00:02:07,049
of 213 even better collections so this

00:02:05,939 --> 00:02:09,060
might give the impression that

00:02:07,049 --> 00:02:11,220
collections have been a constant topic

00:02:09,060 --> 00:02:12,690
but actually no that was the first

00:02:11,220 --> 00:02:16,290
redesign since

00:02:12,690 --> 00:02:21,450
2010 and I can attest that it's 100% can

00:02:16,290 --> 00:02:23,280
build from free so Scylla 213 came out

00:02:21,450 --> 00:02:25,560
yesterday the big thing was new

00:02:23,280 --> 00:02:28,320
collections even better than before

00:02:25,560 --> 00:02:30,510
I think nicer cleaner know the

00:02:28,320 --> 00:02:32,280
signatures don't need can build from and

00:02:30,510 --> 00:02:36,690
there will be the talk about that by

00:02:32,280 --> 00:02:38,850
Stefan Tiger on Wednesday 1745 another

00:02:36,690 --> 00:02:41,250
thing that God updated was the futures

00:02:38,850 --> 00:02:43,020
implementation and there will be a talk

00:02:41,250 --> 00:02:46,950
by that as well by Victor clang on

00:02:43,020 --> 00:02:50,400
Wednesday 14 32 13 was meant to be

00:02:46,950 --> 00:02:52,500
mostly a release a library release where

00:02:50,400 --> 00:02:54,300
we update the libraries but actually

00:02:52,500 --> 00:02:57,690
they managed to sneak in quite a few

00:02:54,300 --> 00:03:00,150
language changes including literal types

00:02:57,690 --> 00:03:03,300
you can see some of them on my slides

00:03:00,150 --> 00:03:04,380
later partial unification the famous si

00:03:03,300 --> 00:03:07,050
00:03:04,380 --> 00:03:09,600
is are now on by default by name

00:03:07,050 --> 00:03:13,200
implicit s-- macro annotations and many

00:03:09,600 --> 00:03:17,220
many polishing in details overall we

00:03:13,200 --> 00:03:20,100
merged over 1500 pull requests from 162

00:03:17,220 --> 00:03:23,060
contributors and a huge thank you at

00:03:20,100 --> 00:03:23,060
everyone who

00:03:26,510 --> 00:03:31,620
thank you everyone who was involved in

00:03:29,040 --> 00:03:35,630
that and made it happen there's another

00:03:31,620 --> 00:03:38,550
curious parallel between now and then in

00:03:35,630 --> 00:03:42,510
2010 when we came out with with Scala

00:03:38,550 --> 00:03:44,670
2.8 the people criticized it and says

00:03:42,510 --> 00:03:47,940
well it really should have been Scala 3

00:03:44,670 --> 00:03:50,030
because there were some breaking changes

00:03:47,940 --> 00:03:53,489
in the language for instance the way we

00:03:50,030 --> 00:03:55,680
resolved package scopes changed so that

00:03:53,489 --> 00:03:57,390
was technically a breaking language

00:03:55,680 --> 00:04:00,330
change so we should have bumped a major

00:03:57,390 --> 00:04:02,640
version we didn't at the time because we

00:04:00,330 --> 00:04:05,010
had announced got a 2.8 already a year

00:04:02,640 --> 00:04:06,870
ahead and this was a late change so we

00:04:05,010 --> 00:04:08,910
didn't really want to change the brand

00:04:06,870 --> 00:04:11,220
the brand of the language everybody was

00:04:08,910 --> 00:04:14,880
talking about 2.8 so now nine years

00:04:11,220 --> 00:04:19,380
later we are almost ready so Scala 3.0

00:04:14,880 --> 00:04:20,940
has almost arrived finally and in the

00:04:19,380 --> 00:04:23,460
tenth years anniversary it will be

00:04:20,940 --> 00:04:26,760
really really trust so that's the big

00:04:23,460 --> 00:04:29,130
news you could say well over over ten

00:04:26,760 --> 00:04:30,960
years the cycle closes itself at the

00:04:29,130 --> 00:04:32,430
time it was something that should have

00:04:30,960 --> 00:04:35,550
been three zero and now we present

00:04:32,430 --> 00:04:38,190
something that will be three zero so the

00:04:35,550 --> 00:04:42,210
road map that we're looking ahead until

00:04:38,190 --> 00:04:45,300
we finished 3-0 is we have we currently

00:04:42,210 --> 00:04:48,180
here June 2019 all features have been

00:04:45,300 --> 00:04:50,250
fleshed out with implementations in the

00:04:48,180 --> 00:04:52,710
current 30 released we have essentially

00:04:50,250 --> 00:04:57,300
a rolling release train right now we are

00:04:52,710 --> 00:05:00,419
at 0 16 we plan to go into feature

00:04:57,300 --> 00:05:02,340
freeze later this year in fall the

00:05:00,419 --> 00:05:05,430
reason why we're not yet in feature

00:05:02,340 --> 00:05:08,370
freeze is that we want to really play

00:05:05,430 --> 00:05:10,740
with it ourselves before we freeze it

00:05:08,370 --> 00:05:14,880
and say it won't change any more and

00:05:10,740 --> 00:05:17,370
from basically today on our internal set

00:05:14,880 --> 00:05:20,850
up is such that we will not build with

00:05:17,370 --> 00:05:22,110
Scala 2 anymore so that means finally we

00:05:20,850 --> 00:05:24,300
have a bootstrap that will only

00:05:22,110 --> 00:05:26,639
bootstrap from ourselves and we won't

00:05:24,300 --> 00:05:28,680
even run Scala 2 in the tests and that

00:05:26,639 --> 00:05:30,630
means we can finally refactor the

00:05:28,680 --> 00:05:33,990
compiler and the library and the other

00:05:30,630 --> 00:05:36,060
code bases to use scholar 3 exclusively

00:05:33,990 --> 00:05:39,180
and that means we get we actually get to

00:05:36,060 --> 00:05:41,370
try out all the nice features that we

00:05:39,180 --> 00:05:43,680
have dreamt off and designed and

00:05:41,370 --> 00:05:45,630
implemented in our code base and before

00:05:43,680 --> 00:05:48,000
we have done that we don't really want

00:05:45,630 --> 00:05:49,860
to freeze it and ship something that we

00:05:48,000 --> 00:05:52,410
might regret later on so it will take a

00:05:49,860 --> 00:05:54,449
little bit longer until fall this year

00:05:52,410 --> 00:05:56,430
and then we will be in actual future

00:05:54,449 --> 00:05:59,090
freeze and that will coincide with the

00:05:56,430 --> 00:06:02,400
release of Scylla three milestone one

00:05:59,090 --> 00:06:06,360
then we want to give us ourselves a year

00:06:02,400 --> 00:06:08,400
about to talk to get the stabilization

00:06:06,360 --> 00:06:11,810
right essentially pass all the tests

00:06:08,400 --> 00:06:15,870
flush out any remaining bugs that we see

00:06:11,810 --> 00:06:19,080
we the whole thing is standardized in

00:06:15,870 --> 00:06:21,539
this color improvement process that we

00:06:19,080 --> 00:06:24,690
have to complete so the subcommittee

00:06:21,539 --> 00:06:27,389
that essentially initial sweep over all

00:06:24,690 --> 00:06:30,199
the features in there and approve most

00:06:27,389 --> 00:06:35,340
of them some of them on probation

00:06:30,199 --> 00:06:37,800
essentially waiting for further for

00:06:35,340 --> 00:06:40,410
further confirmation in actual use but

00:06:37,800 --> 00:06:43,349
we have to go through all the proposals

00:06:40,410 --> 00:06:46,289
bit by bit come up with a spec vote on

00:06:43,349 --> 00:06:48,930
it and that way make it part of the

00:06:46,289 --> 00:06:51,570
language we have to migrate the open

00:06:48,930 --> 00:06:55,260
source ecosystem there's already some

00:06:51,570 --> 00:06:57,630
some very encouraging start some of the

00:06:55,260 --> 00:06:58,620
packages have already started to have

00:06:57,630 --> 00:07:00,960
versions for Tati

00:06:58,620 --> 00:07:03,030
we need to flesh out the tests the

00:07:00,960 --> 00:07:05,430
community build and we have to work on

00:07:03,030 --> 00:07:07,380
compatibility and migration tools so

00:07:05,430 --> 00:07:08,970
that all together should take about a

00:07:07,380 --> 00:07:12,539
year we think so that means we're

00:07:08,970 --> 00:07:15,900
looking at a scan a 3.0 final in ed

00:07:12,539 --> 00:07:18,539
towards the the end for 2020 I would say

00:07:15,900 --> 00:07:21,419
and parallel to that there's ongoing

00:07:18,539 --> 00:07:24,509
development in the Scala two branch so

00:07:21,419 --> 00:07:28,220
but at about this time we also hope to

00:07:24,509 --> 00:07:31,080
have a 2-14 which whose purpose will be

00:07:28,220 --> 00:07:35,340
essentially to ease the migration to

00:07:31,080 --> 00:07:38,009
this new language Scala 3 so what's in

00:07:35,340 --> 00:07:40,710
it so what's in it for you for the

00:07:38,009 --> 00:07:44,099
developers what's in the language it's

00:07:40,710 --> 00:07:47,760
actually a rather big big envelope it's

00:07:44,099 --> 00:07:50,159
just full with features so to structure

00:07:47,760 --> 00:07:52,490
it a little bit I thought I do a best-of

00:07:50,159 --> 00:07:56,060
tour so I want to send

00:07:52,490 --> 00:07:58,639
do a best-of scada 3 asking one of us

00:07:56,060 --> 00:08:01,220
what in my opinion are the nicest

00:07:58,639 --> 00:08:03,620
features of SCARA 3 the nicest new

00:08:01,220 --> 00:08:06,229
features and there of course it depends

00:08:03,620 --> 00:08:08,930
who you are a beginner might appreciate

00:08:06,229 --> 00:08:12,229
something which an expert 5 9 5 boring

00:08:08,930 --> 00:08:14,090
and an expert might be might be blown

00:08:12,229 --> 00:08:16,370
away by a thing which is completely

00:08:14,090 --> 00:08:20,449
incomprehensible to a beginner so I have

00:08:16,370 --> 00:08:22,699
graded it to say one feature for

00:08:20,449 --> 00:08:24,889
beginners one for everyday coding one

00:08:22,699 --> 00:08:26,449
for experts so I'll give you for my

00:08:24,889 --> 00:08:29,539
personal ranking of the top three in

00:08:26,449 --> 00:08:33,770
each category and I also did a Twitter

00:08:29,539 --> 00:08:37,580
survey last weekend a way of overall I

00:08:33,770 --> 00:08:39,880
think I got 1500 or more responses so I

00:08:37,580 --> 00:08:42,370
respond on that what the public thought

00:08:39,880 --> 00:08:45,110
so nicest features for beginners

00:08:42,370 --> 00:08:47,029
actually at at that level most of the

00:08:45,110 --> 00:08:49,250
language stays the same so there's not

00:08:47,029 --> 00:08:52,370
that much but they're never less a few

00:08:49,250 --> 00:08:55,760
improvements worth mentioning so number

00:08:52,370 --> 00:08:58,190
three my opinion is that we are going to

00:08:55,760 --> 00:09:01,490
drop new so here you have a class

00:08:58,190 --> 00:09:03,829
stringbuilder just a boring class it's

00:09:01,490 --> 00:09:05,120
not a case class or anything and in the

00:09:03,829 --> 00:09:07,579
future you'll be able to write a

00:09:05,120 --> 00:09:10,010
stringbuilder ABC or stringbuilder

00:09:07,579 --> 00:09:12,110
open parents closed parents and that's

00:09:10,010 --> 00:09:15,980
the same as if you had written the thing

00:09:12,110 --> 00:09:19,190
with you so you still have new around

00:09:15,980 --> 00:09:22,070
the main reason is that it's you needed

00:09:19,190 --> 00:09:24,200
to disambiguate notably if you what you

00:09:22,070 --> 00:09:26,240
write is the apply method let's say you

00:09:24,200 --> 00:09:28,760
have you want to do some checking

00:09:26,240 --> 00:09:30,829
additional checking or hash Consing or

00:09:28,760 --> 00:09:32,690
whatever in the apply method of your

00:09:30,829 --> 00:09:34,640
string builder class then if you just

00:09:32,690 --> 00:09:36,709
call string builder without any

00:09:34,640 --> 00:09:38,360
arguments then you risk calling yourself

00:09:36,709 --> 00:09:40,070
which of course wouldn't do that

00:09:38,360 --> 00:09:42,050
wouldn't give you a string builder so

00:09:40,070 --> 00:09:44,600
there you have sort of the new ways of

00:09:42,050 --> 00:09:46,760
fallback to say we can still use this to

00:09:44,600 --> 00:09:49,430
create one but we anticipate that

00:09:46,760 --> 00:09:51,770
generally new will be gone because it's

00:09:49,430 --> 00:09:56,779
just nicer to not do it and it doesn't

00:09:51,770 --> 00:09:58,579
add anything in the future okay the one

00:09:56,779 --> 00:10:00,079
advantage of that is of course is that

00:09:58,579 --> 00:10:02,810
you don't need to define a case class

00:10:00,079 --> 00:10:04,190
anymore just to get nice constructor

00:10:02,810 --> 00:10:05,980
cause and there were quite a few people

00:10:04,190 --> 00:10:08,870
who did that

00:10:05,980 --> 00:10:10,940
what's number two so for me number two

00:10:08,870 --> 00:10:13,250
is top-level definitions

00:10:10,940 --> 00:10:17,000
top-level definitions is essentially

00:10:13,250 --> 00:10:19,100
dropping a restriction previously your

00:10:17,000 --> 00:10:21,230
top level definitions had to be objects

00:10:19,100 --> 00:10:24,200
or classes and now there can be anything

00:10:21,230 --> 00:10:26,450
so you can inside a package or you can

00:10:24,200 --> 00:10:29,630
also leave out the package and not do

00:10:26,450 --> 00:10:33,710
anything you can have type definitions

00:10:29,630 --> 00:10:35,840
while definitions method definitions all

00:10:33,710 --> 00:10:38,270
of these things so it means that package

00:10:35,840 --> 00:10:41,570
objects are no longer needed and they

00:10:38,270 --> 00:10:43,970
will be faced out deprecated in in

00:10:41,570 --> 00:10:47,210
future versions and afterwards finally

00:10:43,970 --> 00:10:48,580
faced out that was number two so what's

00:10:47,210 --> 00:10:53,360
number one

00:10:48,580 --> 00:10:55,880
clearly for me number one is enums enums

00:10:53,360 --> 00:10:58,850
it's just such a nice and simple way to

00:10:55,880 --> 00:11:01,310
define a new type with a finite number

00:10:58,850 --> 00:11:04,280
of values of constructor so enum color

00:11:01,310 --> 00:11:08,480
case red green blue finish that's all

00:11:04,280 --> 00:11:11,030
you need and right now in in in Scala it

00:11:08,480 --> 00:11:14,690
wasn't actually that simple to set up

00:11:11,030 --> 00:11:16,730
something like that now where libraries

00:11:14,690 --> 00:11:18,770
there was an enumeration type in the

00:11:16,730 --> 00:11:21,440
standard library that worked sort of

00:11:18,770 --> 00:11:23,180
there was a package called anymore at

00:11:21,440 --> 00:11:25,160
home that also worked sort of but it's

00:11:23,180 --> 00:11:27,650
just much much more straightforward to

00:11:25,160 --> 00:11:30,830
have this in the language furthermore

00:11:27,650 --> 00:11:32,510
what you have is not just the the simple

00:11:30,830 --> 00:11:35,180
thing so that was the simplest example

00:11:32,510 --> 00:11:38,150
but you can actually add everything to

00:11:35,180 --> 00:11:39,740
it that a Java enum would do so you

00:11:38,150 --> 00:11:42,470
could can have enums that have

00:11:39,740 --> 00:11:45,080
parameters like this one here you can

00:11:42,470 --> 00:11:46,910
have cases that pass parameters or here

00:11:45,080 --> 00:11:49,700
the planets give you the mass and the

00:11:46,910 --> 00:11:52,070
radius you can have fields you can have

00:11:49,700 --> 00:11:54,800
methods in these enums and in fact you

00:11:52,070 --> 00:11:56,930
can be fully Java compatible so that's

00:11:54,800 --> 00:11:59,060
done here by just extending java.lang

00:11:56,930 --> 00:12:00,890
enum so that's essentially assigned to

00:11:59,060 --> 00:12:05,090
the compiler that compiler should

00:12:00,890 --> 00:12:09,020
generate code so that this enum is a for

00:12:05,090 --> 00:12:12,380
Java honest enum that it can you can be

00:12:09,020 --> 00:12:14,780
used like any other in amps okay so this

00:12:12,380 --> 00:12:18,580
is again cool now we have parity with

00:12:14,780 --> 00:12:20,680
Java but we can actually go way further

00:12:18,580 --> 00:12:22,720
in arms cannot only have value

00:12:20,680 --> 00:12:25,450
parameters they also can have type

00:12:22,720 --> 00:12:27,760
parameters like this so you can have an

00:12:25,450 --> 00:12:30,339
enum option with a covariant type

00:12:27,760 --> 00:12:33,220
parameter T and then two cases some and

00:12:30,339 --> 00:12:35,589
none so that of course gives you what

00:12:33,220 --> 00:12:39,610
people call an algebraic data type or

00:12:35,589 --> 00:12:42,339
ADT SCADA so far was lacking a simple

00:12:39,610 --> 00:12:44,740
way to write an algebraic data type what

00:12:42,339 --> 00:12:47,470
you had to do is essentially what the

00:12:44,740 --> 00:12:49,360
compiler would translate this to so the

00:12:47,470 --> 00:12:51,640
compiler will take this as a DT that

00:12:49,360 --> 00:12:54,940
you've seen here and translate it into

00:12:51,640 --> 00:12:56,350
essentially this and so far if you

00:12:54,940 --> 00:12:58,870
wanted something like that you would

00:12:56,350 --> 00:13:01,329
have written essentially the same thing

00:12:58,870 --> 00:13:04,500
so a sealed abstract class or seal trade

00:13:01,329 --> 00:13:06,730
option with a case class as one case and

00:13:04,500 --> 00:13:08,860
here it's a vowel but otherwise you

00:13:06,730 --> 00:13:12,430
could also use a case up to object as

00:13:08,860 --> 00:13:15,010
the other case and that of course is

00:13:12,430 --> 00:13:19,990
completely workable but it's kind of

00:13:15,010 --> 00:13:22,540
tedious when Scala started the main or

00:13:19,990 --> 00:13:25,450
one of the main motivations was to avoid

00:13:22,540 --> 00:13:27,370
pointless boilerplate so that's why case

00:13:25,450 --> 00:13:30,370
classes were invented and a lot of other

00:13:27,370 --> 00:13:32,350
innovations it just made code more

00:13:30,370 --> 00:13:35,100
pleasant to write and more compact than

00:13:32,350 --> 00:13:39,339
Java code the standard at the time and

00:13:35,100 --> 00:13:41,529
it one has to recognize that during all

00:13:39,339 --> 00:13:44,230
these years the software world has

00:13:41,529 --> 00:13:46,839
shifted also a little bit and it's now

00:13:44,230 --> 00:13:48,670
much more functional than before so an

00:13:46,839 --> 00:13:51,640
algebraic data type would have been

00:13:48,670 --> 00:13:53,829
something very foreign at the time 2003

00:13:51,640 --> 00:13:55,779
2004 when Skylar came out but now it's

00:13:53,829 --> 00:13:57,370
pretty pretty common and people write

00:13:55,779 --> 00:13:59,829
them and write more and more of them

00:13:57,370 --> 00:14:01,810
because also with essentially more

00:13:59,829 --> 00:14:03,910
static typing you have you want to write

00:14:01,810 --> 00:14:06,370
more and more types more and more class

00:14:03,910 --> 00:14:08,890
hierarchy at the case hierarchies and a

00:14:06,370 --> 00:14:11,740
DTS are just a lovely simple way to do

00:14:08,890 --> 00:14:14,640
that so in the spirit of reducing

00:14:11,740 --> 00:14:18,339
boilerplate it seemed it did it was

00:14:14,640 --> 00:14:21,279
about time to have something that makes

00:14:18,339 --> 00:14:23,580
this case simple and straightforward to

00:14:21,279 --> 00:14:25,769
express but

00:14:23,580 --> 00:14:28,890
that's that's not even the end of it we

00:14:25,769 --> 00:14:31,470
can do more so we can also do J IDT's

00:14:28,890 --> 00:14:33,779
realities are generalized algebraic data

00:14:31,470 --> 00:14:36,660
types and are different from normal ADA

00:14:33,779 --> 00:14:39,810
ADA T's in that the cases can inherit

00:14:36,660 --> 00:14:41,850
the base class at different types so

00:14:39,810 --> 00:14:44,670
here you would have an enum tree of T

00:14:41,850 --> 00:14:47,550
and three cases true/false and it's 0

00:14:44,670 --> 00:14:49,860
that extended a type boolean and two

00:14:47,550 --> 00:14:53,160
more cases that extended a type int and

00:14:49,860 --> 00:14:55,380
a final case if that takes a tree of

00:14:53,160 --> 00:14:57,990
boolean and to tree of T with the

00:14:55,380 --> 00:15:00,750
arbitrary and that just extends a tree

00:14:57,990 --> 00:15:04,019
at the type where the then part and the

00:15:00,750 --> 00:15:07,200
else part extended so this sort of thing

00:15:04,019 --> 00:15:09,420
is actually relatively advanced not that

00:15:07,200 --> 00:15:11,010
many languages have it and I believe

00:15:09,420 --> 00:15:12,480
there's not a single at least not a

00:15:11,010 --> 00:15:15,720
single widespread language out there

00:15:12,480 --> 00:15:17,240
that has in arms ADT's and GL it is all

00:15:15,720 --> 00:15:20,370
in the same language feature I think

00:15:17,240 --> 00:15:22,260
Haskell has of course G Aditi's but the

00:15:20,370 --> 00:15:24,480
GE T is written completely differently

00:15:22,260 --> 00:15:27,620
from an ADT it's a different construct

00:15:24,480 --> 00:15:30,360
whereas here it's a natural progression

00:15:27,620 --> 00:15:32,910
okay so that was my personal favorites

00:15:30,360 --> 00:15:36,480
what about the public so the public

00:15:32,910 --> 00:15:40,740
actually agrees by and large so public

00:15:36,480 --> 00:15:42,959
like enum bests by a large margin drop

00:15:40,740 --> 00:15:46,649
new was second and top level definitions

00:15:42,959 --> 00:15:48,779
we're third so why in arms why do we all

00:15:46,649 --> 00:15:50,610
agree on in a mess well lots of use

00:15:48,779 --> 00:15:53,610
cases and they're becoming more common

00:15:50,610 --> 00:15:56,640
it avoids boring repetitive boilerplate

00:15:53,610 --> 00:15:59,910
and it can grow from very very simple

00:15:56,640 --> 00:16:03,209
color red green blue to actually very

00:15:59,910 --> 00:16:05,700
very powerful a full-blown AG ADT's that

00:16:03,209 --> 00:16:08,520
it can can extend the base types at

00:16:05,700 --> 00:16:10,260
different types and if you take it that

00:16:08,520 --> 00:16:12,480
far then of course you would say well

00:16:10,260 --> 00:16:14,220
that's way beyond a feature for

00:16:12,480 --> 00:16:16,890
beginners so it's a feature so that

00:16:14,220 --> 00:16:19,430
essentially takes a beginner until the

00:16:16,890 --> 00:16:22,649
beginner is no longer a beginner but

00:16:19,430 --> 00:16:24,360
experienced or even an expert so enums

00:16:22,649 --> 00:16:26,970
are a future not just for beginners but

00:16:24,360 --> 00:16:28,890
definitely also for everyday coding but

00:16:26,970 --> 00:16:30,420
now I've already used my number one so

00:16:28,890 --> 00:16:32,910
I'll have other features signed to us

00:16:30,420 --> 00:16:34,800
find other features for everyday coding

00:16:32,910 --> 00:16:36,920
they're actually lots and lots of

00:16:34,800 --> 00:16:38,959
candidates for this level and

00:16:36,920 --> 00:16:41,990
hard to even come up with a short list

00:16:38,959 --> 00:16:44,420
so even that was somewhat arbitrary but

00:16:41,990 --> 00:16:47,440
I tried nevertheless to say well

00:16:44,420 --> 00:16:51,470
whatever is three top innovations there

00:16:47,440 --> 00:16:53,089
for me number three is union types so

00:16:51,470 --> 00:16:56,269
here you have an example of a union type

00:16:53,089 --> 00:16:58,820
first you have two case classes username

00:16:56,269 --> 00:17:01,670
and password here and here and then you

00:16:58,820 --> 00:17:03,860
have a help function that essentially

00:17:01,670 --> 00:17:06,130
can get some identification which is

00:17:03,860 --> 00:17:09,140
either a username or a password and

00:17:06,130 --> 00:17:11,870
essentially depending on what it is you

00:17:09,140 --> 00:17:14,720
look at the name or you look up the

00:17:11,870 --> 00:17:17,660
password and so this gives you

00:17:14,720 --> 00:17:20,540
essentially an ad-hoc combination of two

00:17:17,660 --> 00:17:21,949
types username and password didn't have

00:17:20,540 --> 00:17:23,839
a common superclass they weren't

00:17:21,949 --> 00:17:25,549
designed that way but it doesn't matter

00:17:23,839 --> 00:17:29,090
you can just write the Union type

00:17:25,549 --> 00:17:30,980
username or password right here where do

00:17:29,090 --> 00:17:33,130
we have it here so that's the vertical

00:17:30,980 --> 00:17:36,320
bar right here

00:17:33,130 --> 00:17:38,990
so it gives you a very flexible way to

00:17:36,320 --> 00:17:41,500
model types because sub settings or

00:17:38,990 --> 00:17:44,299
having fewer choices is subtyping and

00:17:41,500 --> 00:17:46,850
that means you can always essentially go

00:17:44,299 --> 00:17:50,049
from one to the other very flexibly the

00:17:46,850 --> 00:17:52,400
current alternative is so in a sense

00:17:50,049 --> 00:17:54,830
heavier and bulkier that's the

00:17:52,400 --> 00:17:56,000
alternative would be to use an either so

00:17:54,830 --> 00:17:58,220
you could of course write either

00:17:56,000 --> 00:18:00,140
username and password but then you would

00:17:58,220 --> 00:18:02,750
have to inject with left and right and

00:18:00,140 --> 00:18:05,690
you would have to extract and it's in a

00:18:02,750 --> 00:18:08,330
sense here not necessary because you

00:18:05,690 --> 00:18:10,610
don't need a left and or right as an

00:18:08,330 --> 00:18:13,460
injection or extraction because the

00:18:10,610 --> 00:18:15,470
class the classes are perfectly good to

00:18:13,460 --> 00:18:17,960
distinguish between the two you can in

00:18:15,470 --> 00:18:19,880
since it's object-oriented they're just

00:18:17,960 --> 00:18:22,040
normal classes you can ask is it a

00:18:19,880 --> 00:18:23,540
username or is it a password of course

00:18:22,040 --> 00:18:26,330
there are some situations where you need

00:18:23,540 --> 00:18:28,610
an either be it because you you need it

00:18:26,330 --> 00:18:30,260
in a generic setting or maybe sometimes

00:18:28,610 --> 00:18:31,730
you actually ask the same type on the

00:18:30,260 --> 00:18:33,559
left and on the right and then of course

00:18:31,730 --> 00:18:36,200
you need an additional attack a union

00:18:33,559 --> 00:18:39,679
type wouldn't work but in 99% of the

00:18:36,200 --> 00:18:42,500
situations I imagine an Union type would

00:18:39,679 --> 00:18:43,490
fit the bill quite well and I should say

00:18:42,500 --> 00:18:45,890
there's no boxing

00:18:43,490 --> 00:18:47,510
overhead like with either essentially

00:18:45,890 --> 00:18:49,030
the username or password the

00:18:47,510 --> 00:18:51,820
representation is literal

00:18:49,030 --> 00:18:53,470
what the underlying representation is so

00:18:51,820 --> 00:18:55,540
you don't need another object that

00:18:53,470 --> 00:18:58,900
essentially represents the alternative

00:18:55,540 --> 00:19:02,650
between one or the other another nice

00:18:58,900 --> 00:19:05,080
aspect of union types is that they work

00:19:02,650 --> 00:19:07,540
with singles and types so you can now

00:19:05,080 --> 00:19:09,610
define a command we say the command is

00:19:07,540 --> 00:19:11,770
either the string click that is an

00:19:09,610 --> 00:19:13,990
example of a literal type that I've

00:19:11,770 --> 00:19:16,180
shown you in 213 so a literal type we

00:19:13,990 --> 00:19:18,190
can just use literals like that and say

00:19:16,180 --> 00:19:20,320
well that's that's it's the type that

00:19:18,190 --> 00:19:23,470
just consists of the single string click

00:19:20,320 --> 00:19:26,020
and here to continue the example the

00:19:23,470 --> 00:19:27,910
command would be click or drag or key

00:19:26,020 --> 00:19:30,550
pressed and then you could have an event

00:19:27,910 --> 00:19:32,680
handler that takes a command so we know

00:19:30,550 --> 00:19:34,270
it's one of these three and just has

00:19:32,680 --> 00:19:36,010
essentially a pattern match on those

00:19:34,270 --> 00:19:38,380
three things and we know that pattern

00:19:36,010 --> 00:19:40,630
match is exhaustive so this is nice if

00:19:38,380 --> 00:19:42,850
the handle event had taken a more

00:19:40,630 --> 00:19:45,340
general type like string you couldn't

00:19:42,850 --> 00:19:47,320
verify that the Paramesh was actually

00:19:45,340 --> 00:19:50,110
exhaustive somebody could come up with a

00:19:47,320 --> 00:19:52,390
different name of missmiss type a string

00:19:50,110 --> 00:19:54,970
and the result would be a runtime

00:19:52,390 --> 00:19:57,850
failure whereas here everything is kept

00:19:54,970 --> 00:20:00,910
safely so that was number three for me

00:19:57,850 --> 00:20:04,480
so what's better than Union types well

00:20:00,910 --> 00:20:06,250
for me it's it's a tough it's a very

00:20:04,480 --> 00:20:08,560
close race but for me I would put at

00:20:06,250 --> 00:20:12,810
number two extension methods so

00:20:08,560 --> 00:20:16,990
extension methods are a very neat way to

00:20:12,810 --> 00:20:21,070
just define methods that can then be

00:20:16,990 --> 00:20:24,070
used in fix without any big boiler plate

00:20:21,070 --> 00:20:26,820
or contortions so you say hey I mean

00:20:24,070 --> 00:20:29,290
this method actually exists and it's

00:20:26,820 --> 00:20:31,780
implemented with an implicit class which

00:20:29,290 --> 00:20:35,170
are replaced by this feature but if I

00:20:31,780 --> 00:20:37,000
wanted to redefine it myself so I want

00:20:35,170 --> 00:20:40,000
to have a thing which says well take a

00:20:37,000 --> 00:20:41,770
string and concatenated string with

00:20:40,000 --> 00:20:42,040
itself the number of times that I give

00:20:41,770 --> 00:20:44,650
you

00:20:42,040 --> 00:20:46,990
so I star operator for Strings so the

00:20:44,650 --> 00:20:49,690
most obvious way to write it would be to

00:20:46,990 --> 00:20:51,970
say well I want to define a star but it

00:20:49,690 --> 00:20:54,070
should come after a string so I put an

00:20:51,970 --> 00:20:56,260
argument to the left and the right

00:20:54,070 --> 00:20:58,120
argument is an int so that's the number

00:20:56,260 --> 00:21:01,090
of times I wanted that string to repeat

00:20:58,120 --> 00:21:02,180
and it gives me back a string and here's

00:21:01,090 --> 00:21:04,730
the implementation

00:21:02,180 --> 00:21:06,620
if X is less than was equal zero then

00:21:04,730 --> 00:21:09,470
it's the empty string otherwise it's s

00:21:06,620 --> 00:21:11,930
times X minus one plus plus s so I can

00:21:09,470 --> 00:21:15,440
use this star immediately as an infix

00:21:11,930 --> 00:21:20,240
operator here in hopes that I jumped

00:21:15,440 --> 00:21:23,870
ahead and gave it away so that makes it

00:21:20,240 --> 00:21:25,580
a lot easier to add method strings to

00:21:23,870 --> 00:21:26,720
existing classes and for that reason

00:21:25,580 --> 00:21:30,980
it's for me

00:21:26,720 --> 00:21:33,830
number two the other nice thing about

00:21:30,980 --> 00:21:36,080
extension methods is it that it plays

00:21:33,830 --> 00:21:37,880
really well with the number one feature

00:21:36,080 --> 00:21:41,840
in my list and the number one feature in

00:21:37,880 --> 00:21:45,290
my list is delegates so delegates are a

00:21:41,840 --> 00:21:47,150
new way to think about implicit implicit

00:21:45,290 --> 00:21:51,890
so of course are everywhere in scala

00:21:47,150 --> 00:21:54,050
ninety five point something percent of

00:21:51,890 --> 00:21:56,900
all projects use some form of implicit

00:21:54,050 --> 00:22:01,220
according to a survey so they are sort

00:21:56,900 --> 00:22:03,470
of me bedrock of programming in Scala

00:22:01,220 --> 00:22:06,530
nevertheless implicit have a lot of

00:22:03,470 --> 00:22:09,500
challenges people get confused people do

00:22:06,530 --> 00:22:11,510
it the wrong way people curse that if

00:22:09,500 --> 00:22:14,780
they have to use other people's systems

00:22:11,510 --> 00:22:16,970
where implicit swear setup wrongly so we

00:22:14,780 --> 00:22:19,760
thought that it there should be a

00:22:16,970 --> 00:22:22,820
concerted effort to get out the good

00:22:19,760 --> 00:22:25,160
parts of implicit and remove the the

00:22:22,820 --> 00:22:27,950
traps and the pitfalls as much as

00:22:25,160 --> 00:22:30,230
possible and part of the answer for that

00:22:27,950 --> 00:22:30,590
not all of it but part of the answer for

00:22:30,230 --> 00:22:33,590
that

00:22:30,590 --> 00:22:36,650
is syntax so the new way to define an

00:22:33,590 --> 00:22:38,390
implicit is here called a delegate so

00:22:36,650 --> 00:22:41,000
what you have here is the standard set

00:22:38,390 --> 00:22:43,310
up of implicit you have a trait or it

00:22:41,000 --> 00:22:45,380
has an extension method compared to with

00:22:43,310 --> 00:22:47,630
two things it has another extension

00:22:45,380 --> 00:22:50,240
method less than that uses compared to

00:22:47,630 --> 00:22:51,710
like this one so that's my trade art and

00:22:50,240 --> 00:22:54,200
now I want to essentially have various

00:22:51,710 --> 00:22:56,150
implementations of this trait and I here

00:22:54,200 --> 00:22:58,760
I just show you a single one that

00:22:56,150 --> 00:23:01,250
integers are ordered so I have this and

00:22:58,760 --> 00:23:04,340
here's what I write I write delegate in

00:23:01,250 --> 00:23:06,560
two or four order of int and then I give

00:23:04,340 --> 00:23:09,140
you the implementation of the compareto

00:23:06,560 --> 00:23:12,110
method implementation of the less-than

00:23:09,140 --> 00:23:15,920
method of course is then inherited as

00:23:12,110 --> 00:23:18,650
usual and the last bit of the slide is

00:23:15,920 --> 00:23:21,590
have a maximum method it says well I

00:23:18,650 --> 00:23:24,530
want to get a list of T's for arbitrary

00:23:21,590 --> 00:23:27,800
element type T but there must be an

00:23:24,530 --> 00:23:30,230
order of T so the order of T must be

00:23:27,800 --> 00:23:32,030
implemented so for instance list of int

00:23:30,230 --> 00:23:33,680
would qualify because here I have an

00:23:32,030 --> 00:23:36,920
introvert and here's the implementation

00:23:33,680 --> 00:23:39,350
of maximum so it's a usual reduce

00:23:36,920 --> 00:23:42,080
operator that uses the less than

00:23:39,350 --> 00:23:45,020
operator that it gets from the ort

00:23:42,080 --> 00:23:47,030
instance if you want to do the same

00:23:45,020 --> 00:23:48,770
thing with current implicit I challenge

00:23:47,030 --> 00:23:51,770
you I don't think you will fit this on

00:23:48,770 --> 00:23:55,010
one slide it's possible but it's really

00:23:51,770 --> 00:23:56,690
hard in particular with infix operators

00:23:55,010 --> 00:23:59,060
because you will have need one implicit

00:23:56,690 --> 00:24:01,370
to essentially set the bed set up the

00:23:59,060 --> 00:24:06,370
basic type classes and then another to

00:24:01,370 --> 00:24:09,500
pull in the the in fixed operators as as

00:24:06,370 --> 00:24:12,920
decorators and things like that so this

00:24:09,500 --> 00:24:15,650
is a much simpler way to talk about

00:24:12,920 --> 00:24:18,110
these things and it actually turns out

00:24:15,650 --> 00:24:20,900
it works really well with type classes

00:24:18,110 --> 00:24:22,760
so here you see another example a

00:24:20,900 --> 00:24:24,920
typical type class thing where we have

00:24:22,760 --> 00:24:26,900
semi groups let's a try it with a

00:24:24,920 --> 00:24:30,800
combined method you have mono reads

00:24:26,900 --> 00:24:32,660
which add a unit method so again this is

00:24:30,800 --> 00:24:34,970
an extension method this is a normal

00:24:32,660 --> 00:24:37,610
method and now we have a delegate for

00:24:34,970 --> 00:24:39,740
mono rate of string so the delicate can

00:24:37,610 --> 00:24:41,960
actually be anonymous I can leave out

00:24:39,740 --> 00:24:44,450
the name and it gives you

00:24:41,960 --> 00:24:46,670
implementations of both the extension

00:24:44,450 --> 00:24:51,350
method here that's the combined method

00:24:46,670 --> 00:24:54,680
and the unit method over there and then

00:24:51,350 --> 00:24:57,920
I can define a sum method that takes an

00:24:54,680 --> 00:25:00,560
arbitrary type it must have mono it as a

00:24:57,920 --> 00:25:02,960
context bound so that some just is usual

00:25:00,560 --> 00:25:06,290
another way to say that there must be a

00:25:02,960 --> 00:25:09,140
mono rate of T a delegate of type mono

00:25:06,290 --> 00:25:11,210
rate of T and it takes a list of T's and

00:25:09,140 --> 00:25:14,510
it gives you back a T and it uses a fold

00:25:11,210 --> 00:25:16,970
left where it starts with the mono rate

00:25:14,510 --> 00:25:19,760
of T dot unit so these basically the

00:25:16,970 --> 00:25:21,980
same thing as implicitly slightly better

00:25:19,760 --> 00:25:25,040
it has a has a gives you a more precise

00:25:21,980 --> 00:25:26,840
type so you say the mono rate of T dot

00:25:25,040 --> 00:25:29,200
unit so that gives you the unit thing

00:25:26,840 --> 00:25:31,570
and then you call the combined function

00:25:29,200 --> 00:25:33,160
so the reason why this works is actually

00:25:31,570 --> 00:25:34,960
I mean here it all looks completely

00:25:33,160 --> 00:25:39,070
natural and simple but the reason why

00:25:34,960 --> 00:25:43,150
this works is is actually quite subtle

00:25:39,070 --> 00:25:45,280
so the reason why this works is that the

00:25:43,150 --> 00:25:48,010
fact that I can use an extension method

00:25:45,280 --> 00:25:50,530
hangs together with the fact that I have

00:25:48,010 --> 00:25:52,180
a mono eight instance in scope so

00:25:50,530 --> 00:25:56,350
there's a rule for extension methods

00:25:52,180 --> 00:25:58,660
that say you if they are defined in

00:25:56,350 --> 00:26:00,910
something for which you have a delegate

00:25:58,660 --> 00:26:03,460
instance in scope then you can apply it

00:26:00,910 --> 00:26:05,980
not you don't need to just import it or

00:26:03,460 --> 00:26:09,750
bring it into scope otherwise so that's

00:26:05,980 --> 00:26:12,250
essentially a very well thought-out

00:26:09,750 --> 00:26:18,100
combination of extension methods and

00:26:12,250 --> 00:26:20,140
these delegates another nice aspect of

00:26:18,100 --> 00:26:22,390
delegates is that they tame implicit

00:26:20,140 --> 00:26:24,550
conversions so here you have an implicit

00:26:22,390 --> 00:26:27,010
conversion if you read an implicit

00:26:24,550 --> 00:26:29,080
tutorial for Scala then often it will

00:26:27,010 --> 00:26:31,480
start off with something like that into

00:26:29,080 --> 00:26:33,580
string or something like that so you

00:26:31,480 --> 00:26:36,010
have you just write implicit and then

00:26:33,580 --> 00:26:38,140
add F in a string and it gives you here

00:26:36,010 --> 00:26:43,050
a token and that's a key word string

00:26:38,140 --> 00:26:43,050
whatever what's wrong with this picture

00:26:43,110 --> 00:26:49,690
nothing really this is a perfectly good

00:26:45,370 --> 00:26:52,990
good good method but it's too easy

00:26:49,690 --> 00:26:55,900
actually because we have learned all

00:26:52,990 --> 00:26:57,640
that writing a lot of these conversions

00:26:55,900 --> 00:27:00,100
is probably a recipe for disaster

00:26:57,640 --> 00:27:02,830
because they intend to interact very

00:27:00,100 --> 00:27:04,870
badly one with each other and I just add

00:27:02,830 --> 00:27:06,010
too much implicitness so it's too easy

00:27:04,870 --> 00:27:09,250
to write

00:27:06,010 --> 00:27:11,860
compared to how dangerous it is implicit

00:27:09,250 --> 00:27:14,020
as a modifier will go away and with it

00:27:11,860 --> 00:27:15,910
this kind of conversion so in the future

00:27:14,020 --> 00:27:18,640
these things will be first deprecated

00:27:15,910 --> 00:27:20,470
and then phased out so if these things

00:27:18,640 --> 00:27:22,750
are no longer no longer available what

00:27:20,470 --> 00:27:26,530
do you do then to write a conversion

00:27:22,750 --> 00:27:28,510
well a the answer is probably think hard

00:27:26,530 --> 00:27:30,310
whether you really need one because like

00:27:28,510 --> 00:27:32,440
I said implicit conversions in ninety

00:27:30,310 --> 00:27:34,090
five of percent of the cases in my

00:27:32,440 --> 00:27:36,340
experience are really the wrong

00:27:34,090 --> 00:27:38,770
solutions but if you after this

00:27:36,340 --> 00:27:41,050
deliberation you decide that yes I do

00:27:38,770 --> 00:27:42,850
need an implicit conversion then you can

00:27:41,050 --> 00:27:46,330
define it as a delegate

00:27:42,850 --> 00:27:48,730
so again the idea is that now the only

00:27:46,330 --> 00:27:50,740
way to express interested conversions is

00:27:48,730 --> 00:27:53,920
as a delegate for a standard class

00:27:50,740 --> 00:27:56,170
called scarlet or conversion so here you

00:27:53,920 --> 00:27:58,570
have a conversion of string to token and

00:27:56,170 --> 00:28:01,810
you can define a delegate for it which

00:27:58,570 --> 00:28:04,510
means that if implicit search tries to

00:28:01,810 --> 00:28:06,670
find the term of this type conversion

00:28:04,510 --> 00:28:08,800
string to token then the delegate would

00:28:06,670 --> 00:28:10,780
essentially qualify and would be chosen

00:28:08,800 --> 00:28:12,730
and the delegate would then have an

00:28:10,780 --> 00:28:16,180
apply method because conversions are

00:28:12,730 --> 00:28:18,310
essentially functions that essentially

00:28:16,180 --> 00:28:20,860
that's what you need to do what you can

00:28:18,310 --> 00:28:23,860
also do is you can make it a little bit

00:28:20,860 --> 00:28:25,900
shorter you can use an alias delegate we

00:28:23,860 --> 00:28:27,910
can say here delegate for conversion

00:28:25,900 --> 00:28:30,310
string token equals new keyword

00:28:27,910 --> 00:28:31,720
underscore so that would also work that

00:28:30,310 --> 00:28:35,680
would give you the same thing

00:28:31,720 --> 00:28:39,760
using same types as a mechanism okay so

00:28:35,680 --> 00:28:42,490
that was the the my personal ranking

00:28:39,760 --> 00:28:46,090
delegates extension methods Union types

00:28:42,490 --> 00:28:48,670
let's see what the public said so we

00:28:46,090 --> 00:28:51,120
actually picked Union types first so it

00:28:48,670 --> 00:28:53,920
was the my ranking was reversed

00:28:51,120 --> 00:28:55,960
extension method second and revised

00:28:53,920 --> 00:29:01,480
implicit so that's what I called them in

00:28:55,960 --> 00:29:04,470
the in the in there on the pole third so

00:29:01,480 --> 00:29:06,820
why do I believe the delegates are

00:29:04,470 --> 00:29:10,030
nevertheless number one in this list

00:29:06,820 --> 00:29:13,330
well like I said implicit saw scara's

00:29:10,030 --> 00:29:14,950
most distinguished feature but they are

00:29:13,330 --> 00:29:17,230
also the most controversial feature

00:29:14,950 --> 00:29:20,200
really and delegates give you a much

00:29:17,230 --> 00:29:22,150
simpler and safer alternative the main

00:29:20,200 --> 00:29:23,980
difference if you think about delegates

00:29:22,150 --> 00:29:26,770
or the traditional implicit is that

00:29:23,980 --> 00:29:29,260
delegates emphasize intent of a

00:29:26,770 --> 00:29:30,790
mechanism with the current implicit you

00:29:29,260 --> 00:29:34,120
said well you can slap it on everything

00:29:30,790 --> 00:29:37,390
on a vowel on a var Navarro and eval on

00:29:34,120 --> 00:29:39,370
a def on an object on a class and it

00:29:37,390 --> 00:29:43,390
sort of subtly changes the meaning of

00:29:39,370 --> 00:29:46,120
things in ways which are quite logical I

00:29:43,390 --> 00:29:49,180
mean it's not it's not mystical the

00:29:46,120 --> 00:29:52,470
specification is quite precise about it

00:29:49,180 --> 00:29:54,760
but it was sort of a mechanistic

00:29:52,470 --> 00:29:56,320
mechanistic thing that people had to say

00:29:54,760 --> 00:29:59,500
well I want to construct now

00:29:56,320 --> 00:30:01,809
thing and here's how I do it it wasn't

00:29:59,500 --> 00:30:04,090
so much that I expressed the intent to

00:30:01,809 --> 00:30:06,190
say well I have a type class and I want

00:30:04,090 --> 00:30:08,259
to have an instance or delegate for this

00:30:06,190 --> 00:30:09,880
type class at this type you could

00:30:08,259 --> 00:30:12,519
achieve that but there were many many

00:30:09,880 --> 00:30:15,130
steps sometimes to get there to arrive

00:30:12,519 --> 00:30:16,870
there and having many steps to arrive

00:30:15,130 --> 00:30:19,120
there also means having many steps to

00:30:16,870 --> 00:30:23,259
get it wrong so net that's essentially

00:30:19,120 --> 00:30:24,880
now gone then they therefore make the

00:30:23,259 --> 00:30:27,309
idea of term inference much more

00:30:24,880 --> 00:30:29,950
accessible instead of saying basically

00:30:27,309 --> 00:30:31,750
you have five different meanings of the

00:30:29,950 --> 00:30:33,340
word implicit there's a single one for

00:30:31,750 --> 00:30:36,399
delegate so we only have to teach a

00:30:33,340 --> 00:30:38,230
single thing and finally they discourage

00:30:36,399 --> 00:30:40,179
abuses I've already shown you that

00:30:38,230 --> 00:30:42,460
essentially the easy way to write

00:30:40,179 --> 00:30:45,039
implicit conversions is gone they will

00:30:42,460 --> 00:30:46,269
also tighten the belt for in imports

00:30:45,039 --> 00:30:48,519
which is sort of the other big

00:30:46,269 --> 00:30:50,080
problematic feature with implicit where

00:30:48,519 --> 00:30:52,029
you say I don't know where my implicit

00:30:50,080 --> 00:30:54,279
czar coming from so delegates have an

00:30:52,029 --> 00:30:56,350
answer for that as well so there are

00:30:54,279 --> 00:30:59,289
actually many improvements it's not just

00:30:56,350 --> 00:31:01,870
syntax over the current implicit which I

00:30:59,289 --> 00:31:04,330
can't really go into details including

00:31:01,870 --> 00:31:07,210
names don't matter in fact everything

00:31:04,330 --> 00:31:09,009
can be anonymous for implicit because

00:31:07,210 --> 00:31:11,590
you want to essentially trade a term for

00:31:09,009 --> 00:31:14,320
a type you never want to know what the

00:31:11,590 --> 00:31:16,899
term is precisely called nesting is

00:31:14,320 --> 00:31:19,059
significant which means that you can

00:31:16,899 --> 00:31:21,789
actually have a simple way to achieve

00:31:19,059 --> 00:31:25,899
local coherence there no shadowing

00:31:21,789 --> 00:31:28,419
problems be restricted the implicit

00:31:25,899 --> 00:31:30,940
scope where implicit are searched which

00:31:28,419 --> 00:31:34,029
avoids some nasty surprises there's a

00:31:30,940 --> 00:31:36,190
more robust prioritization there are no

00:31:34,029 --> 00:31:39,330
accidental conversions that you can get

00:31:36,190 --> 00:31:42,309
and we have better rare error messages

00:31:39,330 --> 00:31:44,860
the hardest thing for that was really

00:31:42,309 --> 00:31:47,320
not coming up with a design the design

00:31:44,860 --> 00:31:50,590
has been stable for about six months now

00:31:47,320 --> 00:31:53,320
but naming them what are these things

00:31:50,590 --> 00:31:56,139
called these terms that I say well the

00:31:53,320 --> 00:31:58,120
compiler says I need an implicit of a

00:31:56,139 --> 00:32:00,340
type so then it comes up with a term

00:31:58,120 --> 00:32:02,500
what do you call the term well you can't

00:32:00,340 --> 00:32:04,779
say implicit instance or implicit object

00:32:02,500 --> 00:32:06,340
or visit value that's what we said but

00:32:04,779 --> 00:32:08,200
that's a compound thing that's not

00:32:06,340 --> 00:32:09,210
that's not a simple thing that you say

00:32:08,200 --> 00:32:11,730
well it

00:32:09,210 --> 00:32:13,830
this and we went actually through a long

00:32:11,730 --> 00:32:16,320
list of names my original proposal was

00:32:13,830 --> 00:32:18,000
witness that got shot down and then

00:32:16,320 --> 00:32:20,730
there was evidence and implement

00:32:18,000 --> 00:32:22,890
instance and implied and assumed and so

00:32:20,730 --> 00:32:24,780
on and in the end we settled on delegate

00:32:22,890 --> 00:32:27,990
in the end I believe it won't matter

00:32:24,780 --> 00:32:28,800
much if we just need a noun that's easy

00:32:27,990 --> 00:32:31,380
to remember

00:32:28,800 --> 00:32:34,530
we need a noun and because we want to

00:32:31,380 --> 00:32:38,430
talk about these things as a class as a

00:32:34,530 --> 00:32:40,470
categorization great so that was the my

00:32:38,430 --> 00:32:43,980
number one for the everyday coding

00:32:40,470 --> 00:32:45,780
what about experts advanced features so

00:32:43,980 --> 00:32:48,630
since got a three puts meta programming

00:32:45,780 --> 00:32:50,610
on a new basis there's actually lots of

00:32:48,630 --> 00:32:53,220
advanced features to choose from and

00:32:50,610 --> 00:32:55,650
it's very difficult to pick a winner so

00:32:53,220 --> 00:32:59,270
I give you again my my personal list and

00:32:55,650 --> 00:33:01,860
at number three I would put match types

00:32:59,270 --> 00:33:04,320
so here's what you can do with match

00:33:01,860 --> 00:33:07,200
types I've simplified things a little

00:33:04,320 --> 00:33:12,000
bit so let's say we have a double enum

00:33:07,200 --> 00:33:13,410
with two cases empty and pair so a pair

00:33:12,000 --> 00:33:15,870
couple or an empty tapo

00:33:13,410 --> 00:33:18,030
now wouldn't it be nice if we could

00:33:15,870 --> 00:33:21,360
write a concat function that

00:33:18,030 --> 00:33:22,980
concatenates arbitrary tuples

00:33:21,360 --> 00:33:25,560
before we write such a concat function

00:33:22,980 --> 00:33:27,330
we have to say well what should what

00:33:25,560 --> 00:33:30,750
would the type of that concat function

00:33:27,330 --> 00:33:32,460
be of course it could return couple but

00:33:30,750 --> 00:33:34,620
that wouldn't be very specific what we

00:33:32,460 --> 00:33:36,480
really would want to is that if it is

00:33:34,620 --> 00:33:38,370
let's say if I have a pair of intent

00:33:36,480 --> 00:33:40,890
string and I want to concatenate that

00:33:38,370 --> 00:33:43,110
with a pair of boolean and float then I

00:33:40,890 --> 00:33:47,040
would get in string boolean float a for

00:33:43,110 --> 00:33:50,190
trouble so I want to compute types at

00:33:47,040 --> 00:33:52,410
compile time by the compiler so here's

00:33:50,190 --> 00:33:54,690
how I would do this now with using match

00:33:52,410 --> 00:33:57,420
types so I can actually define a type

00:33:54,690 --> 00:33:59,970
concat that takes essentially two

00:33:57,420 --> 00:34:02,910
subtypes of tuples so that would be my

00:33:59,970 --> 00:34:05,370
pair types or whatever and then it I can

00:34:02,910 --> 00:34:08,820
have a match in the type which says well

00:34:05,370 --> 00:34:11,280
if the first of this type is the empty

00:34:08,820 --> 00:34:15,750
tupple then the result of concatenation

00:34:11,280 --> 00:34:19,250
is the second second parameter and if

00:34:15,750 --> 00:34:22,159
it's a pair with an element type

00:34:19,250 --> 00:34:25,399
X and the second element type X s then

00:34:22,159 --> 00:34:27,020
the result is again a pair with the

00:34:25,399 --> 00:34:30,320
first element type here and a

00:34:27,020 --> 00:34:32,899
concatenation of the rest xs and ys as a

00:34:30,320 --> 00:34:35,990
secondary element so this is just like

00:34:32,899 --> 00:34:37,970
computing with functions like you would

00:34:35,990 --> 00:34:40,310
probably write the concat function but

00:34:37,970 --> 00:34:45,440
on types so the whole thing works on

00:34:40,310 --> 00:34:47,510
types it's you could say well in

00:34:45,440 --> 00:34:50,300
principle that's not new we know how to

00:34:47,510 --> 00:34:52,429
do that it's called ageless right so in

00:34:50,300 --> 00:34:53,929
current Scala this is ageless so what's

00:34:52,429 --> 00:34:56,870
the difference between this and ageless

00:34:53,929 --> 00:35:00,890
by an ageless ageless are a way to

00:34:56,870 --> 00:35:03,650
define implicit so you can essentially

00:35:00,890 --> 00:35:05,480
you can never talk about a type being

00:35:03,650 --> 00:35:08,330
the concatenation of two other types

00:35:05,480 --> 00:35:11,210
what you can say is it's a type variable

00:35:08,330 --> 00:35:13,490
result and there's an ageless implicit

00:35:11,210 --> 00:35:16,160
that takes essentially to the two input

00:35:13,490 --> 00:35:18,530
types and the result type and puts them

00:35:16,160 --> 00:35:20,390
in relation to each other so it's like

00:35:18,530 --> 00:35:22,700
the difference between logic programming

00:35:20,390 --> 00:35:25,430
which is what H lists is really you only

00:35:22,700 --> 00:35:27,590
have classes that put things in relation

00:35:25,430 --> 00:35:29,690
and functional programming what this is

00:35:27,590 --> 00:35:33,110
so because you have you have a function

00:35:29,690 --> 00:35:35,540
that defines the result directly and the

00:35:33,110 --> 00:35:38,180
the effect can be quite quite profound

00:35:35,540 --> 00:35:40,790
which we will see when we apply match

00:35:38,180 --> 00:35:44,660
types in the other things on my rank on

00:35:40,790 --> 00:35:47,410
my ranking so what's number two so for

00:35:44,660 --> 00:35:50,720
me number two is type class derivation

00:35:47,410 --> 00:35:52,610
so we've seen type classes will be very

00:35:50,720 --> 00:35:55,640
important there's a much nicer syntax

00:35:52,610 --> 00:35:58,430
for them there's one problem though

00:35:55,640 --> 00:36:01,670
with type classes and that is that while

00:35:58,430 --> 00:36:05,720
it's very easy for an enum or a class to

00:36:01,670 --> 00:36:09,910
extend an interface it's a lot more

00:36:05,720 --> 00:36:13,070
boilerplate and cumbersome to have it

00:36:09,910 --> 00:36:15,380
arrive a type class to have it implement

00:36:13,070 --> 00:36:17,330
a type class and it doesn't really have

00:36:15,380 --> 00:36:20,120
to do that way because a lot of these

00:36:17,330 --> 00:36:23,480
type class implementations be it for

00:36:20,120 --> 00:36:25,430
equality or ordering or serialization

00:36:23,480 --> 00:36:27,440
they're actually pretty boring they're

00:36:25,430 --> 00:36:29,660
very repetitive they do the same thing

00:36:27,440 --> 00:36:32,170
over and over again for every case class

00:36:29,660 --> 00:36:34,150
that you define so in

00:36:32,170 --> 00:36:37,330
it's kind of three what you can do here

00:36:34,150 --> 00:36:38,890
is you can define an enum or a class you

00:36:37,330 --> 00:36:40,870
don't matter you can't just say it

00:36:38,890 --> 00:36:43,540
derives equal and ordering and picking

00:36:40,870 --> 00:36:45,720
and it can derive any type class

00:36:43,540 --> 00:36:49,600
including type classes that you define

00:36:45,720 --> 00:36:52,960
so what does this derive to did your

00:36:49,600 --> 00:36:55,030
eyes expand to well it's actually quite

00:36:52,960 --> 00:36:57,850
simple just to generate simply three

00:36:55,030 --> 00:37:01,900
delegates which all have the form that

00:36:57,850 --> 00:37:04,570
we say well the type T type parameter T

00:37:01,900 --> 00:37:07,240
must be recursively have the same type

00:37:04,570 --> 00:37:09,040
class and then it's essentially it would

00:37:07,240 --> 00:37:11,170
give you an instance of the type class

00:37:09,040 --> 00:37:14,110
equal ordering and pickling and the

00:37:11,170 --> 00:37:17,200
right hand side is always a method dot

00:37:14,110 --> 00:37:20,140
derived that must exist in the type

00:37:17,200 --> 00:37:21,910
class so dot derived is where you as a

00:37:20,140 --> 00:37:24,220
library designer come in that's the

00:37:21,910 --> 00:37:25,780
function that you have to define to make

00:37:24,220 --> 00:37:27,760
this all work so so far this is

00:37:25,780 --> 00:37:30,550
essentially just very nice surface

00:37:27,760 --> 00:37:32,320
syntax for the user of your library so

00:37:30,550 --> 00:37:35,170
that the user of your library can mix in

00:37:32,320 --> 00:37:38,440
the type classes without any contortions

00:37:35,170 --> 00:37:41,200
so I should say how you do that the

00:37:38,440 --> 00:37:43,720
equal dot derived there will be a talk

00:37:41,200 --> 00:37:45,640
about this by my seven who will has

00:37:43,720 --> 00:37:48,340
essentially just finished shapeless

00:37:45,640 --> 00:37:50,980
three four scalar three that will

00:37:48,340 --> 00:37:53,230
essentially use this mechanism to derive

00:37:50,980 --> 00:37:55,870
type classes but I'd wanted to give you

00:37:53,230 --> 00:37:58,270
a little glimpse sort of on the on the

00:37:55,870 --> 00:38:01,090
techniques used for that anyway so

00:37:58,270 --> 00:38:03,280
here's sort of a thing or the start of a

00:38:01,090 --> 00:38:05,650
thing to roll it yourself if you use my

00:38:03,280 --> 00:38:07,180
shapeless you can essentially condense

00:38:05,650 --> 00:38:10,810
that a lot and you don't need to write

00:38:07,180 --> 00:38:15,430
all this but it's actually quite just

00:38:10,810 --> 00:38:17,200
just to give you a a an inkling of what

00:38:15,430 --> 00:38:20,740
this would look like so here's the

00:38:17,200 --> 00:38:21,970
derived method for the EQ class so it

00:38:20,740 --> 00:38:24,220
gives you a new instance of the type

00:38:21,970 --> 00:38:26,320
class it has to be fine the equal method

00:38:24,220 --> 00:38:28,750
which takes two elements of the type and

00:38:26,320 --> 00:38:32,560
gives you a boolean and what it also

00:38:28,750 --> 00:38:34,510
gets as a given class a parameter is

00:38:32,560 --> 00:38:36,340
essentially a mirror and the mirror is

00:38:34,510 --> 00:38:40,180
something that essentially represents

00:38:36,340 --> 00:38:43,270
the type structure of the T here mirror

00:38:40,180 --> 00:38:44,850
of T so what I do would then we would

00:38:43,270 --> 00:38:47,850
then say well what kind of mirror

00:38:44,850 --> 00:38:50,430
I have is it as sum or is it a product a

00:38:47,850 --> 00:38:56,370
sum is essentially a turnit if a product

00:38:50,430 --> 00:38:58,290
is is a case class typically and then it

00:38:56,370 --> 00:39:00,480
would essentially do something which is

00:38:58,290 --> 00:39:02,970
adapted to this kind of mirror so for

00:39:00,480 --> 00:39:05,070
the sum of it would call a method in the

00:39:02,970 --> 00:39:08,220
mirror which is called ordinal so that

00:39:05,070 --> 00:39:10,470
gives you basically the case of the

00:39:08,220 --> 00:39:12,660
instance that X s so it would say well

00:39:10,470 --> 00:39:15,930
what's the case number starting from

00:39:12,660 --> 00:39:17,730
zero of what X's and I would say well

00:39:15,930 --> 00:39:19,770
that must be actually be the same as the

00:39:17,730 --> 00:39:21,750
ordinal of Y because otherwise they

00:39:19,770 --> 00:39:24,210
couldn't be equal and then we have to go

00:39:21,750 --> 00:39:26,280
into equal cases which essentially will

00:39:24,210 --> 00:39:29,700
know again statically what are the

00:39:26,280 --> 00:39:31,560
element types of this type and it would

00:39:29,700 --> 00:39:33,240
go through that and if it's a product it

00:39:31,560 --> 00:39:35,580
will essentially go to through equal

00:39:33,240 --> 00:39:38,760
elements and again it will know the

00:39:35,580 --> 00:39:41,010
element types of the product so then to

00:39:38,760 --> 00:39:43,680
actually make work you have to dissect

00:39:41,010 --> 00:39:46,020
these types and the way you do that is

00:39:43,680 --> 00:39:49,170
typically with match types and what

00:39:46,020 --> 00:39:52,200
you've seen here with inline methods so

00:39:49,170 --> 00:39:55,140
this whole essentially construction

00:39:52,200 --> 00:39:58,290
which works with match types inline

00:39:55,140 --> 00:39:59,760
methods and macros is essentially the

00:39:58,290 --> 00:40:01,650
thing that makes it all tick and

00:39:59,760 --> 00:40:04,380
shapeless three gives you essentially

00:40:01,650 --> 00:40:06,990
just a very very nice cover on top of it

00:40:04,380 --> 00:40:10,250
so about the basics there will be a talk

00:40:06,990 --> 00:40:13,170
by Nicolas rookie on Thursday 11:15 so

00:40:10,250 --> 00:40:15,810
what's number one actually number one is

00:40:13,170 --> 00:40:19,320
a suggestion for miles

00:40:15,810 --> 00:40:21,570
number one I think a good way to wrap a

00:40:19,320 --> 00:40:24,630
number one up is to say functions

00:40:21,570 --> 00:40:26,850
everywhere so what does that mean well

00:40:24,630 --> 00:40:28,740
in Scala as you know we have methods

00:40:26,850 --> 00:40:30,990
which are just essentially members of

00:40:28,740 --> 00:40:32,820
classes and objects and we have

00:40:30,990 --> 00:40:35,070
functions which are objects themselves

00:40:32,820 --> 00:40:36,540
and there are two different things and

00:40:35,070 --> 00:40:38,190
there's a reason for that because

00:40:36,540 --> 00:40:40,350
otherwise essentially you would get

00:40:38,190 --> 00:40:42,570
you'd get an infinite recursion so

00:40:40,350 --> 00:40:46,440
functions are values are objects and

00:40:42,570 --> 00:40:49,230
methods are members of objects and so

00:40:46,440 --> 00:40:51,930
far methods were quite a bit more

00:40:49,230 --> 00:40:54,360
powerful than functions methods could be

00:40:51,930 --> 00:40:55,980
dependent so the result type could

00:40:54,360 --> 00:40:58,050
depend on the parameter types

00:40:55,980 --> 00:41:00,030
there could be polymorphic so

00:40:58,050 --> 00:41:01,350
they could have typed parameters and of

00:41:00,030 --> 00:41:03,390
course there could be implicit they

00:41:01,350 --> 00:41:04,920
could take implicit parameters but

00:41:03,390 --> 00:41:07,620
functions could be none of these things

00:41:04,920 --> 00:41:09,600
why not well because there were no types

00:41:07,620 --> 00:41:11,580
that could express these things as

00:41:09,600 --> 00:41:14,460
function types you got only the normal

00:41:11,580 --> 00:41:17,460
function type A to B or a and B to C or

00:41:14,460 --> 00:41:19,560
whatever and you couldn't express these

00:41:17,460 --> 00:41:22,950
dependencies polymorphism or implicit

00:41:19,560 --> 00:41:25,140
and now in scalar 3 you can so here's an

00:41:22,950 --> 00:41:27,480
example of a dependent function so here

00:41:25,140 --> 00:41:30,270
you you start up let's say you have a

00:41:27,480 --> 00:41:32,310
graph and it has two member types node

00:41:30,270 --> 00:41:34,260
and edge and then you want to write a

00:41:32,310 --> 00:41:36,540
node extractor which is a function that

00:41:34,260 --> 00:41:40,290
takes a graph and it gives you as a

00:41:36,540 --> 00:41:44,820
result a result of a value of type G dot

00:41:40,290 --> 00:41:46,590
node so the G here refers to the actual

00:41:44,820 --> 00:41:49,740
parameter so that we call a dependent

00:41:46,590 --> 00:41:52,050
method if it's a method or here it's a

00:41:49,740 --> 00:41:54,660
function type dependent function type so

00:41:52,050 --> 00:41:56,780
in Scala 3 you have dependent function

00:41:54,660 --> 00:42:00,210
types that mirror dependent methods

00:41:56,780 --> 00:42:01,770
about polymorphic methods let's say you

00:42:00,210 --> 00:42:04,620
want to give you the type of the

00:42:01,770 --> 00:42:07,890
identity function in pre-death I would

00:42:04,620 --> 00:42:10,080
say well it's T 2 T for any T and I

00:42:07,890 --> 00:42:12,540
would respond yes but what is the type

00:42:10,080 --> 00:42:14,550
how do you make that into a type so now

00:42:12,540 --> 00:42:17,040
you can what you need is essentially a

00:42:14,550 --> 00:42:20,220
function type that says well for any

00:42:17,040 --> 00:42:21,840
type T gives you it gives me T 2 T so

00:42:20,220 --> 00:42:24,930
you have functions that can have not

00:42:21,840 --> 00:42:27,720
only values as arguments but that can

00:42:24,930 --> 00:42:30,000
have types as arguments and finally for

00:42:27,720 --> 00:42:33,180
implicit so methods can be implicit and

00:42:30,000 --> 00:42:37,770
functions can be the same so here you

00:42:33,180 --> 00:42:39,900
would have a type executable that is a

00:42:37,770 --> 00:42:43,130
function type that says it goes from

00:42:39,900 --> 00:42:46,590
execution context to T but the execution

00:42:43,130 --> 00:42:48,180
context is given or implicit which means

00:42:46,590 --> 00:42:51,750
that whenever have a value of that

00:42:48,180 --> 00:42:53,670
function as for a given parameter the

00:42:51,750 --> 00:42:57,870
argument will be synthesized

00:42:53,670 --> 00:43:00,240
automatically by the compiler cool so

00:42:57,870 --> 00:43:03,150
that was the the my top three for the

00:43:00,240 --> 00:43:05,520
experts what about the public vote so

00:43:03,150 --> 00:43:08,670
public vote actually by a large margin

00:43:05,520 --> 00:43:11,080
put type class derivation first but

00:43:08,670 --> 00:43:13,440
maybe it was because I only had

00:43:11,080 --> 00:43:15,580
implicit function types so one third of

00:43:13,440 --> 00:43:17,650
essentially the functions everywhere

00:43:15,580 --> 00:43:19,510
mantras if you add the other ones maybe

00:43:17,650 --> 00:43:23,080
that would have gotten more supports and

00:43:19,510 --> 00:43:27,250
match types were tied with implicit

00:43:23,080 --> 00:43:29,590
function types on second place okay so

00:43:27,250 --> 00:43:33,790
one I want to conclude with one nice way

00:43:29,590 --> 00:43:36,370
that points to some of the synergies

00:43:33,790 --> 00:43:39,790
that these features could have so here

00:43:36,370 --> 00:43:42,550
the task is we want to enable that

00:43:39,790 --> 00:43:45,850
syntax here so we want to be able to

00:43:42,550 --> 00:43:47,980
write lists of one two three dots um of

00:43:45,850 --> 00:43:50,410
course we can do that and then we want

00:43:47,980 --> 00:43:52,740
to use ensuring so that's a post

00:43:50,410 --> 00:43:56,470
condition result equals six

00:43:52,740 --> 00:44:00,400
ensuring is a method in pre deaf who is

00:43:56,470 --> 00:44:02,110
used in during already not that many

00:44:00,400 --> 00:44:03,820
more of you should it's a very very

00:44:02,110 --> 00:44:07,470
useful method because it essentially

00:44:03,820 --> 00:44:09,850
lets you program with contracts the

00:44:07,470 --> 00:44:12,040
problem so far was that ensuring

00:44:09,850 --> 00:44:15,670
couldn't really talk about the result

00:44:12,040 --> 00:44:17,880
that the function added without put in

00:44:15,670 --> 00:44:21,040
making a lambda here so it had to say

00:44:17,880 --> 00:44:23,740
basically result arrow result equals x

00:44:21,040 --> 00:44:25,740
and was kind of clunky so I would it

00:44:23,740 --> 00:44:28,360
feels much nicer to just have

00:44:25,740 --> 00:44:30,940
essentially a name for it to say the

00:44:28,360 --> 00:44:33,310
result should be six so how can we

00:44:30,940 --> 00:44:37,090
achieve that by just essentially clever

00:44:33,310 --> 00:44:38,380
coding so here's what we would do we

00:44:37,090 --> 00:44:39,670
have to define this object post

00:44:38,380 --> 00:44:42,370
conditions

00:44:39,670 --> 00:44:44,860
so here's ensuring it's an infinite is

00:44:42,370 --> 00:44:46,870
it's an extension method as because it's

00:44:44,860 --> 00:44:50,830
used to essentially on arbitrary

00:44:46,870 --> 00:44:52,930
elements of type T it only takes a

00:44:50,830 --> 00:44:55,660
condition and the condition is one of

00:44:52,930 --> 00:44:58,870
these implicit function types so it

00:44:55,660 --> 00:45:02,050
takes a wrap T's or that basically will

00:44:58,870 --> 00:45:05,200
in the end be there your result to

00:45:02,050 --> 00:45:09,160
boolean and what it says it says is well

00:45:05,200 --> 00:45:11,110
just assert this condition given X so

00:45:09,160 --> 00:45:14,350
the X is essentially the result that

00:45:11,110 --> 00:45:16,630
would slot into the the argument of this

00:45:14,350 --> 00:45:20,380
condition so we passed the result to the

00:45:16,630 --> 00:45:22,540
condition and the condition then we'll

00:45:20,380 --> 00:45:23,910
essentially return true or false and it

00:45:22,540 --> 00:45:26,549
must return true or

00:45:23,910 --> 00:45:28,470
get an assertion violation so what then

00:45:26,549 --> 00:45:31,770
is result this result that we called

00:45:28,470 --> 00:45:34,260
well the result is simply a function

00:45:31,770 --> 00:45:37,589
that takes an implicit parameter R of

00:45:34,260 --> 00:45:40,049
type rap of T and gives you back a T and

00:45:37,589 --> 00:45:42,210
what is rap well rap is essentially a

00:45:40,049 --> 00:45:44,640
thing that makes the whole thing safe

00:45:42,210 --> 00:45:46,740
because we're for arbitrary T's we don't

00:45:44,640 --> 00:45:48,240
want to carry around implicit so it's a

00:45:46,740 --> 00:45:50,880
thing where we say well that's

00:45:48,240 --> 00:45:53,430
essentially a wrapper for the type key

00:45:50,880 --> 00:45:57,780
that is only used here in this context

00:45:53,430 --> 00:46:00,000
and in fact this wrapper T it doesn't do

00:45:57,780 --> 00:46:02,549
anything it is equal to T it's a type

00:46:00,000 --> 00:46:06,089
alias but it's an opaque type alias that

00:46:02,549 --> 00:46:08,880
I could know only in this setting cool

00:46:06,089 --> 00:46:11,510
so now probably your head or some some

00:46:08,880 --> 00:46:14,460
of your head spin I can't see very well

00:46:11,510 --> 00:46:17,430
because of the lighting so and you ask

00:46:14,460 --> 00:46:20,010
yourself is scary a new language this

00:46:17,430 --> 00:46:24,809
all looks pretty wild and foreign to me

00:46:20,010 --> 00:46:27,450
and the answer is yes so many language

00:46:24,809 --> 00:46:29,220
changes there will be future removals

00:46:27,450 --> 00:46:31,829
there are already many featuring rules

00:46:29,220 --> 00:46:34,859
there will be more in the future the new

00:46:31,829 --> 00:46:37,890
construct improve user experience and

00:46:34,859 --> 00:46:40,470
onboarding quite dramatically in some

00:46:37,890 --> 00:46:42,990
cases and the books of Scala will have

00:46:40,470 --> 00:46:44,760
to be rewritten so a current book on

00:46:42,990 --> 00:46:47,250
Scala will feel dated for this new

00:46:44,760 --> 00:46:51,089
language but on the other hand you could

00:46:47,250 --> 00:46:53,460
also answer no because it still skaara

00:46:51,089 --> 00:46:56,160
it still looks and feels like Scala all

00:46:53,460 --> 00:46:58,589
of the core constructs remain in place

00:46:56,160 --> 00:47:00,900
and a large and very practical common

00:46:58,589 --> 00:47:04,049
subset between Scala and scholars color

00:47:00,900 --> 00:47:05,970
- in Scala 3 exists I know because our

00:47:04,049 --> 00:47:09,630
compiler code base is written in this

00:47:05,970 --> 00:47:11,130
subset by tomorrow probably will diverge

00:47:09,630 --> 00:47:11,819
because now we don't have to do it

00:47:11,130 --> 00:47:13,770
anymore

00:47:11,819 --> 00:47:16,319
but until now it was written in the

00:47:13,770 --> 00:47:17,839
subject it wasn't in this subset it

00:47:16,319 --> 00:47:20,400
wasn't painful at all basically

00:47:17,839 --> 00:47:23,880
everything you have in Scala - you can

00:47:20,400 --> 00:47:25,710
still use another large software package

00:47:23,880 --> 00:47:27,930
actually larger much larger than Scala

00:47:25,710 --> 00:47:32,369
compiler that compiles in both already

00:47:27,930 --> 00:47:34,740
is Scala tests so between yes and no I

00:47:32,369 --> 00:47:37,600
think the fairest answer is to say it's

00:47:34,740 --> 00:47:40,000
really a process Scala 3 keeps

00:47:37,600 --> 00:47:43,180
most constructive scholar of 213

00:47:40,000 --> 00:47:45,670
alongside the new ones and some

00:47:43,180 --> 00:47:47,980
constructs like old implicit and so on

00:47:45,670 --> 00:47:50,410
will be deprecated and phased out in the

00:47:47,980 --> 00:47:52,780
three dot ex release train so that

00:47:50,410 --> 00:47:54,580
requires some temporary duplication in

00:47:52,780 --> 00:47:57,400
the language but the end result should

00:47:54,580 --> 00:47:59,500
be a more compact and regular language

00:47:57,400 --> 00:48:01,660
so here's a list of some of the

00:47:59,500 --> 00:48:03,700
replacements that are in stores and some

00:48:01,660 --> 00:48:05,890
of the most of the things you've seen so

00:48:03,700 --> 00:48:08,410
exports exports we haven't seen

00:48:05,890 --> 00:48:11,650
top-level definitions would replace

00:48:08,410 --> 00:48:13,510
packaged objects the delegates replace

00:48:11,650 --> 00:48:16,780
implicit deaths welds objects

00:48:13,510 --> 00:48:19,990
conversions extension methods replace

00:48:16,780 --> 00:48:23,730
implicit classes and inline staging and

00:48:19,990 --> 00:48:28,140
match types replaces the current macros

00:48:23,730 --> 00:48:30,910
when I present that I hear sometimes

00:48:28,140 --> 00:48:33,400
complains which says well why so many

00:48:30,910 --> 00:48:36,310
new features at once can't you do it bit

00:48:33,400 --> 00:48:39,870
by bit over many many releases wouldn't

00:48:36,310 --> 00:48:43,180
that be a sign a way to do it well the

00:48:39,870 --> 00:48:45,310
one problematic point here the one

00:48:43,180 --> 00:48:47,260
constraint here is really that scanner

00:48:45,310 --> 00:48:49,990
three is when the books will be

00:48:47,260 --> 00:48:53,500
rewritten so essentially now all my

00:48:49,990 --> 00:48:55,630
books all my tutorials on Coursera will

00:48:53,500 --> 00:48:57,970
have to be rewritten or re-recorded

00:48:55,630 --> 00:49:01,210
because things I mean you wouldn't want

00:48:57,970 --> 00:49:04,090
to start a tutorial without enums

00:49:01,210 --> 00:49:05,620
or without extension methods and these

00:49:04,090 --> 00:49:07,810
things these are things that are basic

00:49:05,620 --> 00:49:11,440
enough that you want to do them even in

00:49:07,810 --> 00:49:14,050
beginners courses so that means that the

00:49:11,440 --> 00:49:16,870
features we need to get in now in 3-0

00:49:14,050 --> 00:49:17,740
are features that affect the foundations

00:49:16,870 --> 00:49:21,040
of scala

00:49:17,740 --> 00:49:23,830
that simplify life in particular for

00:49:21,040 --> 00:49:25,930
learners because you don't want to teach

00:49:23,830 --> 00:49:28,750
a more complicated version when in scala

00:49:25,930 --> 00:49:31,150
3.1 a simpler replacement will come out

00:49:28,750 --> 00:49:33,040
and that will replace existing features

00:49:31,150 --> 00:49:34,630
you don't want to write a book or a new

00:49:33,040 --> 00:49:37,090
version of the book with a feature that

00:49:34,630 --> 00:49:39,880
will be replaced in the next version of

00:49:37,090 --> 00:49:42,280
Scala afterwards so that also was for us

00:49:39,880 --> 00:49:44,740
a very strong guidance what to put in

00:49:42,280 --> 00:49:47,140
this language release we prioritized

00:49:44,740 --> 00:49:48,830
foundations simplifications and

00:49:47,140 --> 00:49:51,620
restrictions

00:49:48,830 --> 00:49:54,980
we did not prioritize how we be second

00:49:51,620 --> 00:49:57,440
fiddle we're features that give added

00:49:54,980 --> 00:49:59,480
power to expert developers and there

00:49:57,440 --> 00:50:01,760
were a lot of propositions about those

00:49:59,480 --> 00:50:03,770
of course so I essentially new forms of

00:50:01,760 --> 00:50:05,690
four expressions or things like that new

00:50:03,770 --> 00:50:08,450
forms of pattern matching that make

00:50:05,690 --> 00:50:10,820
certain specialized idioms easier to

00:50:08,450 --> 00:50:13,370
express nothing is wrong with them but

00:50:10,820 --> 00:50:17,780
we felt that if we don't need to put

00:50:13,370 --> 00:50:20,210
them into Scala at 3.0 we have enough to

00:50:17,780 --> 00:50:22,190
do already with all the simplifications

00:50:20,210 --> 00:50:25,760
and restrictions and foundational

00:50:22,190 --> 00:50:27,800
additions that we want to do so how do

00:50:25,760 --> 00:50:31,880
you how do we get there how do we get to

00:50:27,800 --> 00:50:34,580
3-0 we have a source compatibility for a

00:50:31,880 --> 00:50:37,430
very large command subset we will rely

00:50:34,580 --> 00:50:40,070
to some degree on rewrite tools tools

00:50:37,430 --> 00:50:42,200
that can handle much of the rest I'm

00:50:40,070 --> 00:50:44,300
quite confident that the situation it's

00:50:42,200 --> 00:50:47,540
a lot better than Python with which

00:50:44,300 --> 00:50:50,290
often this is often compared also

00:50:47,540 --> 00:50:53,060
because it's a transition from 2 to 3

00:50:50,290 --> 00:50:56,600
mostly because we have static typing and

00:50:53,060 --> 00:51:00,320
in fact we have taken great pains not to

00:50:56,600 --> 00:51:02,750
change the runtime behavior at all but

00:51:00,320 --> 00:51:04,700
really any changes we there would be

00:51:02,750 --> 00:51:06,800
would affect the types so it would be

00:51:04,700 --> 00:51:09,290
things you grapple with at compile time

00:51:06,800 --> 00:51:11,420
rather than while you debug your program

00:51:09,290 --> 00:51:15,440
or while your software is in production

00:51:11,420 --> 00:51:18,950
and because of binary compatibility so

00:51:15,440 --> 00:51:21,830
by binary compatibility well already

00:51:18,950 --> 00:51:26,030
today we can mix dotty so the precursor

00:51:21,830 --> 00:51:29,030
of Scala 3 and Scala 212 or Cara 213

00:51:26,030 --> 00:51:30,860
soon as soon as that as essentially a

00:51:29,030 --> 00:51:32,900
significant adoption we'll switch to

00:51:30,860 --> 00:51:33,590
that so it means we can have a dotty

00:51:32,900 --> 00:51:36,380
Escarra

00:51:33,590 --> 00:51:39,590
3 module that sits on top of Scala to

00:51:36,380 --> 00:51:41,600
library and can consume it no problem so

00:51:39,590 --> 00:51:43,820
we're not we don't need to essentially

00:51:41,600 --> 00:51:46,820
bring everything up to three one can

00:51:43,820 --> 00:51:50,600
switch in the future this will actually

00:51:46,820 --> 00:51:53,270
go both ways so we it will also be

00:51:50,600 --> 00:51:55,880
possible to have a dotty library module

00:51:53,270 --> 00:51:58,400
that can then be consumed by it's got a

00:51:55,880 --> 00:51:59,990
two module or a scalar 3 module so that

00:51:58,400 --> 00:52:02,599
means you can really mix and match

00:51:59,990 --> 00:52:04,940
things on the binary level

00:52:02,599 --> 00:52:06,979
as you want and that means you don't

00:52:04,940 --> 00:52:10,369
need to bring the whole ecosystem over

00:52:06,979 --> 00:52:12,920
2/3 as was the case in in Python 3 of

00:52:10,369 --> 00:52:15,470
course so the reason why it all works is

00:52:12,920 --> 00:52:17,359
called tasty typed abstract syntax trees

00:52:15,470 --> 00:52:19,999
I've already talked at length about them

00:52:17,359 --> 00:52:23,029
at previous conferences essentially what

00:52:19,999 --> 00:52:25,970
it is is it's a way to serialize your

00:52:23,029 --> 00:52:27,859
whole program in a form which is which

00:52:25,970 --> 00:52:29,720
has all the types and all the implicit

00:52:27,859 --> 00:52:31,849
and everything is in there everything is

00:52:29,720 --> 00:52:34,670
very very explicit in these things and

00:52:31,849 --> 00:52:37,579
but on the other hand it doesn't have

00:52:34,670 --> 00:52:39,410
any of the encoding problems that we

00:52:37,579 --> 00:52:43,339
need them to map this on other platforms

00:52:39,410 --> 00:52:45,140
like the JVM or Jas or or native or

00:52:43,339 --> 00:52:48,829
things like that so it's basically a

00:52:45,140 --> 00:52:51,140
high the maximally explicit high-level

00:52:48,829 --> 00:52:53,359
format of your program the amazing thing

00:52:51,140 --> 00:52:56,029
is also very compact it's about as

00:52:53,359 --> 00:52:58,400
compact as source and the idea is that

00:52:56,029 --> 00:53:00,979
then this would be the standard format

00:52:58,400 --> 00:53:03,890
that people could essentially map to and

00:53:00,979 --> 00:53:07,069
consume and that would make it possible

00:53:03,890 --> 00:53:08,869
this set of interoperability where we

00:53:07,069 --> 00:53:11,869
have two and three modules talking to

00:53:08,869 --> 00:53:13,849
each other the other promise of this

00:53:11,869 --> 00:53:16,160
session and I should say there's a talk

00:53:13,849 --> 00:53:19,239
about this by GU young mattress on

00:53:16,160 --> 00:53:23,420
Wednesday 10:15 if you're interested in

00:53:19,239 --> 00:53:26,239
hearing more about this the other cool

00:53:23,420 --> 00:53:29,150
thing about tasty is that it promises a

00:53:26,239 --> 00:53:31,729
solution at least a partial solution to

00:53:29,150 --> 00:53:34,160
the binary compatibility problem so the

00:53:31,729 --> 00:53:36,380
plan is to keep the tasty format stable

00:53:34,160 --> 00:53:39,650
binary compatible over the whole

00:53:36,380 --> 00:53:42,739
phreatic series unlike currently where

00:53:39,650 --> 00:53:46,039
we unfortunately we have to break that

00:53:42,739 --> 00:53:47,839
format with every major version because

00:53:46,039 --> 00:53:51,079
essentially there's always a little

00:53:47,839 --> 00:53:54,559
tweak or another that doesn't work on

00:53:51,079 --> 00:53:57,529
the pile with the baby we we compiled to

00:53:54,559 --> 00:53:59,690
bytecode so that means that compile from

00:53:57,529 --> 00:54:01,910
tasty then allows code to migrate

00:53:59,690 --> 00:54:05,779
without the current problems of binary

00:54:01,910 --> 00:54:07,130
compatibility so I between three zero

00:54:05,779 --> 00:54:09,319
and three one there will probably be

00:54:07,130 --> 00:54:10,640
still some some some shake outs and

00:54:09,319 --> 00:54:12,950
things like that but the hope is that

00:54:10,640 --> 00:54:15,510
afterwards we will have a completely

00:54:12,950 --> 00:54:18,450
different binary compatibility story

00:54:15,510 --> 00:54:21,270
so you can try it out today it's a te p

00:54:18,450 --> 00:54:25,290
FL dot CH and thank you all for

00:54:21,270 --> 00:54:27,830
listening and I think we are already

00:54:25,290 --> 00:54:33,890
over time sorry

00:54:27,830 --> 00:54:51,710
okay cool okay thank you

00:54:33,890 --> 00:54:53,370
[Applause]

00:54:51,710 --> 00:54:57,300
exciting times ahead

00:54:53,370 --> 00:55:01,140
thank you very much Martin and thanks

00:54:57,300 --> 00:55:05,010
everyone I just want to say that thanks

00:55:01,140 --> 00:55:06,870
again for coming thanks to signify we

00:55:05,010 --> 00:55:09,990
have drinks and food outside please

00:55:06,870 --> 00:55:12,210
enjoy yourself until 9:00 p.m. and for

00:55:09,990 --> 00:55:15,090
speakers and Families we meet in front

00:55:12,210 --> 00:55:18,990
of the registration add a quarter to

00:55:15,090 --> 00:55:22,350
seven a quarter to seven please it's a

00:55:18,990 --> 00:55:24,270
dinner it's not only food and drinks

00:55:22,350 --> 00:55:32,010
it's a dinner it's a real dinner

00:55:24,270 --> 00:55:34,020
oh my god okay now you heard it's Swiss

00:55:32,010 --> 00:55:36,660
it's a real dinner it's not just finger

00:55:34,020 --> 00:55:38,250
food so enjoy yourself thank you very

00:55:36,660 --> 00:55:40,470
much you tomorrow morning

00:55:38,250 --> 00:55:44,060
thank you

00:55:40,470 --> 00:55:44,060
[Applause]

00:55:44,550 --> 00:55:47,599

YouTube URL: https://www.youtube.com/watch?v=_Rnrx2lo9cw


