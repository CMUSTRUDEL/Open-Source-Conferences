Title: The Promise of Event Driven Programming with Fast Data by Duncan DeVore
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/the-promise-of-event-driven-programming-with-fast-data---
Captions: 
	00:00:04,759 --> 00:00:09,500
I used to be a VP of engineering for an

00:00:07,729 --> 00:00:13,029
energy company where we had lots of fun

00:00:09,500 --> 00:00:15,680
and then I went to typesafe and became a

00:00:13,029 --> 00:00:18,500
senior software engineer and now I'm a

00:00:15,680 --> 00:00:20,180
principal systems engineer at light Bend

00:00:18,500 --> 00:00:22,789
we changed their name so you get a new

00:00:20,180 --> 00:00:24,470
title too that's kind of nice and been

00:00:22,789 --> 00:00:28,640
building distributed systems for a long

00:00:24,470 --> 00:00:30,260
time we have a book out that is Manning

00:00:28,640 --> 00:00:32,750
is the publisher it's called reactive

00:00:30,260 --> 00:00:35,690
application design there's three of us

00:00:32,750 --> 00:00:38,089
authors Sean Walsh and Brian Hanafy from

00:00:35,690 --> 00:00:39,920
Wells Fargo so if you're looking for I

00:00:38,089 --> 00:00:41,210
actually have some discount codes if

00:00:39,920 --> 00:00:44,530
you're interested let me know and I can

00:00:41,210 --> 00:00:49,069
give them to you and my Twitter account

00:00:44,530 --> 00:00:50,960
of course you know about us and like

00:00:49,069 --> 00:00:53,239
been probably one of the things that

00:00:50,960 --> 00:00:55,519
were most famous for is the reactive

00:00:53,239 --> 00:00:58,870
manifesto and it's kind of a

00:00:55,519 --> 00:01:03,229
philosophical way to design these

00:00:58,870 --> 00:01:06,820
distributed systems and so at the top of

00:01:03,229 --> 00:01:10,340
this puzzle is this idea of being

00:01:06,820 --> 00:01:14,630
responsive ready to respond to stimulus

00:01:10,340 --> 00:01:18,980
and there's I think over 20,000 signers

00:01:14,630 --> 00:01:21,740
now or 21,000 and you know it started by

00:01:18,980 --> 00:01:24,050
some pretty smart guys Jonas and Roland

00:01:21,740 --> 00:01:27,680
and Dave and so forth and Martin

00:01:24,050 --> 00:01:32,710
Thompson so if you haven't read it go

00:01:27,680 --> 00:01:36,380
out and check it out so I like this this

00:01:32,710 --> 00:01:38,450
picture of how to describe a reactive

00:01:36,380 --> 00:01:40,490
system the idea is at the top it's

00:01:38,450 --> 00:01:42,800
responsive that's the most important

00:01:40,490 --> 00:01:44,360
thing people don't care in life they

00:01:42,800 --> 00:01:45,920
don't care in software they don't care

00:01:44,360 --> 00:01:48,560
in relationships if you're not

00:01:45,920 --> 00:01:50,990
responsive then they sense a problem

00:01:48,560 --> 00:01:54,350
either you're being disrespectful or you

00:01:50,990 --> 00:01:57,620
don't care or whatever so generally

00:01:54,350 --> 00:01:59,510
people accept if you respond even if you

00:01:57,620 --> 00:02:01,820
don't necessarily give them the answer

00:01:59,510 --> 00:02:03,150
they want at that time both in software

00:02:01,820 --> 00:02:05,760
or in

00:02:03,150 --> 00:02:08,100
in relationships with people so how do

00:02:05,760 --> 00:02:10,380
we become responsive well their life has

00:02:08,100 --> 00:02:13,920
issues right things happen you get sick

00:02:10,380 --> 00:02:16,140
or your software system the load becomes

00:02:13,920 --> 00:02:17,280
too high or whatever so you have to be

00:02:16,140 --> 00:02:18,990
able to deal with that so it's at the

00:02:17,280 --> 00:02:21,480
left and the right we have these two

00:02:18,990 --> 00:02:23,460
things resilience and elasticity for us

00:02:21,480 --> 00:02:26,310
resilience is not fault tolerance it's

00:02:23,460 --> 00:02:28,380
self-healing so built in the DNA of your

00:02:26,310 --> 00:02:30,810
application it needs to recognize it's

00:02:28,380 --> 00:02:33,230
having a problem and then take the steps

00:02:30,810 --> 00:02:36,390
to correct it without human intervention

00:02:33,230 --> 00:02:39,090
and then elastic means it needs the

00:02:36,390 --> 00:02:41,250
sense that the requirements or the load

00:02:39,090 --> 00:02:43,700
that's put upon it or is increasing or

00:02:41,250 --> 00:02:46,410
decreasing and it needs to scale

00:02:43,700 --> 00:02:47,880
appropriately so if it's decreasing you

00:02:46,410 --> 00:02:50,160
want to scale down so you don't spend as

00:02:47,880 --> 00:02:51,990
much money or use as much CPU time and

00:02:50,160 --> 00:02:53,970
if it's increasing obviously you want to

00:02:51,990 --> 00:02:55,890
scale up and at the bottom is this

00:02:53,970 --> 00:02:59,010
message driven architecture which we

00:02:55,890 --> 00:03:01,620
could call you know response driven

00:02:59,010 --> 00:03:03,180
event-driven whatever at the ideas you

00:03:01,620 --> 00:03:05,610
have a basic message that's being passed

00:03:03,180 --> 00:03:08,280
back and forth so you can see that the

00:03:05,610 --> 00:03:11,400
arrows from elasticity and resilience

00:03:08,280 --> 00:03:13,230
point up to responsiveness and they also

00:03:11,400 --> 00:03:15,600
point to each other so they kind of have

00:03:13,230 --> 00:03:18,350
this symbiotic relationship sometimes in

00:03:15,600 --> 00:03:21,320
order to be resilient you have to employ

00:03:18,350 --> 00:03:23,700
elasticity right so the loads becoming a

00:03:21,320 --> 00:03:25,260
significantly greater and you don't want

00:03:23,700 --> 00:03:28,140
your application to crash so you're

00:03:25,260 --> 00:03:30,540
going to spin up more servers and at the

00:03:28,140 --> 00:03:32,100
bottom is this message driven concept

00:03:30,540 --> 00:03:36,090
where everybody's going to communicate

00:03:32,100 --> 00:03:37,650
back and forth with messages and rely on

00:03:36,090 --> 00:03:40,940
this evil thing called eventual

00:03:37,650 --> 00:03:43,920
consistency which we'll talk about so

00:03:40,940 --> 00:03:46,019
one of the things I'm sure you guys are

00:03:43,920 --> 00:03:50,190
familiar with is some of our products is

00:03:46,019 --> 00:03:53,070
akka and play and legume and so forth

00:03:50,190 --> 00:03:55,110
like that akka is kind of like the

00:03:53,070 --> 00:03:57,090
substrate for all of our products it is

00:03:55,110 --> 00:04:00,660
underneath the play it is underneath of

00:03:57,090 --> 00:04:03,660
legume it's an actor model and it

00:04:00,660 --> 00:04:07,230
provides all the features of reactive

00:04:03,660 --> 00:04:10,080
style design that we're looking for in

00:04:07,230 --> 00:04:12,420
these types of applications we also have

00:04:10,080 --> 00:04:13,799
all of our open source offerings and

00:04:12,420 --> 00:04:15,630
then we have some commercial offerings

00:04:13,799 --> 00:04:17,060
with a subscription the things like

00:04:15,630 --> 00:04:19,630
split brain resolver

00:04:17,060 --> 00:04:24,980
and cinnamon which is our telemetry

00:04:19,630 --> 00:04:27,560
gathering software and so forth so the

00:04:24,980 --> 00:04:29,419
last thing is we have this new thing

00:04:27,560 --> 00:04:31,580
which is becoming more and more

00:04:29,419 --> 00:04:35,450
important called our fast data platform

00:04:31,580 --> 00:04:37,880
and it's the recognization that data is

00:04:35,450 --> 00:04:41,389
a very important thing but it's also

00:04:37,880 --> 00:04:43,610
time-sensitive so if you're going to be

00:04:41,389 --> 00:04:45,560
competitive you need to begin to

00:04:43,610 --> 00:04:48,680
understand how to digest your data in

00:04:45,560 --> 00:04:50,750
ways of real-time or near real-time and

00:04:48,680 --> 00:04:52,190
be able to make decisions based on that

00:04:50,750 --> 00:04:54,950
and we're going to talk about something

00:04:52,190 --> 00:04:57,020
called feedback control which is pretty

00:04:54,950 --> 00:04:59,600
popular and mechanical and electrical

00:04:57,020 --> 00:05:01,940
engineering buttons in computer science

00:04:59,600 --> 00:05:03,650
software engineering it's kind of new

00:05:01,940 --> 00:05:05,930
right we're starting to explore how to

00:05:03,650 --> 00:05:07,940
do it because of the way software works

00:05:05,930 --> 00:05:12,800
as opposed to a physical piece of

00:05:07,940 --> 00:05:17,300
hardware so for the talk we're going to

00:05:12,800 --> 00:05:20,060
talk basically about these ideas excuse

00:05:17,300 --> 00:05:22,040
me we'll talk about micro surfaces so we

00:05:20,060 --> 00:05:23,180
can get into an agreement of what they

00:05:22,040 --> 00:05:25,340
are because they mean different things

00:05:23,180 --> 00:05:27,520
to different people we'll talk about

00:05:25,340 --> 00:05:30,020
something called promise theory which is

00:05:27,520 --> 00:05:32,660
it doesn't come from computer science

00:05:30,020 --> 00:05:34,970
but I think applies to it very very well

00:05:32,660 --> 00:05:38,600
and is foundational on how you think

00:05:34,970 --> 00:05:40,490
about designing an application event

00:05:38,600 --> 00:05:42,289
sourcing you know crud create read

00:05:40,490 --> 00:05:44,419
update and delete fast data and then

00:05:42,289 --> 00:05:46,789
we'll talk about feedback control which

00:05:44,419 --> 00:05:49,940
I think ends up being the culmination of

00:05:46,789 --> 00:05:53,990
all this type of stuff so first

00:05:49,940 --> 00:05:55,640
microservices so what are they one of

00:05:53,990 --> 00:05:57,740
the definitions that most people use

00:05:55,640 --> 00:06:00,860
which i think is a great definition is

00:05:57,740 --> 00:06:02,840
this idea of you have these autonomous

00:06:00,860 --> 00:06:04,940
systems that are created by a group of

00:06:02,840 --> 00:06:07,039
people they can work independent of

00:06:04,940 --> 00:06:08,450
other groups they can develop they can

00:06:07,039 --> 00:06:11,479
deploy and they can push it out into

00:06:08,450 --> 00:06:13,010
production and so forth and they can

00:06:11,479 --> 00:06:15,620
manage them independently so that's kind

00:06:13,010 --> 00:06:18,380
of like the operations side of a micro

00:06:15,620 --> 00:06:21,590
service and and maybe your development

00:06:18,380 --> 00:06:23,570
philosophy but in reality a micro

00:06:21,590 --> 00:06:25,820
service I think is much more than that

00:06:23,570 --> 00:06:28,130
the way that we like to look at them is

00:06:25,820 --> 00:06:30,620
there a system of autonomous

00:06:28,130 --> 00:06:32,470
collaborative distributed services

00:06:30,620 --> 00:06:35,449
and that's a mouthful mouthful but

00:06:32,470 --> 00:06:37,880
autonomous autonomous from the Greek

00:06:35,449 --> 00:06:39,770
which means self-governing so your micro

00:06:37,880 --> 00:06:42,560
service regardless of what happens in

00:06:39,770 --> 00:06:43,430
the rest of the world it still stands it

00:06:42,560 --> 00:06:45,229
still works

00:06:43,430 --> 00:06:47,540
so if your micro service needs weather

00:06:45,229 --> 00:06:50,540
data and you're pulling it from NOAA or

00:06:47,540 --> 00:06:52,490
somewhere and that interface goes down

00:06:50,540 --> 00:06:56,240
if your micro Service doesn't have

00:06:52,490 --> 00:06:59,120
weather data cached for the significant

00:06:56,240 --> 00:06:59,960
whatever your SLA says then it's not

00:06:59,120 --> 00:07:01,520
successful

00:06:59,960 --> 00:07:05,380
right it's not going to be able to

00:07:01,520 --> 00:07:10,070
deliver the information it needs so as a

00:07:05,380 --> 00:07:11,900
Microsoft or

00:07:10,070 --> 00:07:13,550
now of course not you're gonna learn

00:07:11,900 --> 00:07:15,650
what you need to learn you're gonna do

00:07:13,550 --> 00:07:16,789
what you need to do in order to get

00:07:15,650 --> 00:07:18,949
there and it's the same thing with your

00:07:16,789 --> 00:07:21,470
micro service collaborative obviously

00:07:18,949 --> 00:07:23,150
it's a community right a village right

00:07:21,470 --> 00:07:26,330
everyone works together to achieve a

00:07:23,150 --> 00:07:28,190
greater goal so those two pieces of a

00:07:26,330 --> 00:07:30,710
micro service are very very important

00:07:28,190 --> 00:07:32,930
and so the question ends up becoming how

00:07:30,710 --> 00:07:34,910
do you become autonomous truly

00:07:32,930 --> 00:07:38,060
autonomous self-governing being up being

00:07:34,910 --> 00:07:42,080
able to stand on your own so as we look

00:07:38,060 --> 00:07:43,520
at some of the the key concepts is the

00:07:42,080 --> 00:07:45,500
first thing I would say is you're gonna

00:07:43,520 --> 00:07:47,990
take a look at something called promise

00:07:45,500 --> 00:07:52,160
Theory and it's a way to think about how

00:07:47,990 --> 00:07:55,039
you operate with other people and then

00:07:52,160 --> 00:07:57,320
obviously you're gonna there's some

00:07:55,039 --> 00:07:59,690
argument here about whether micro means

00:07:57,320 --> 00:08:01,460
small or not I like to keep them as

00:07:59,690 --> 00:08:03,349
small as possible because then they're

00:08:01,460 --> 00:08:07,430
easier to reason about and they're

00:08:03,349 --> 00:08:09,500
easier to test but I think the boundary

00:08:07,430 --> 00:08:12,650
of a micro service is determined by the

00:08:09,500 --> 00:08:14,389
business not by the developer and that's

00:08:12,650 --> 00:08:16,639
something that you have to think through

00:08:14,389 --> 00:08:17,960
and talk through the business folks and

00:08:16,639 --> 00:08:20,539
things like that you know it's like

00:08:17,960 --> 00:08:22,099
eventual consistency I'll get asked well

00:08:20,539 --> 00:08:23,750
how long is it going to take and my

00:08:22,099 --> 00:08:25,940
answer is always I don't know you tell

00:08:23,750 --> 00:08:27,590
me how long do you want it to take how

00:08:25,940 --> 00:08:29,630
long do you need it in this particular

00:08:27,590 --> 00:08:31,910
use case to take don't tell me ten

00:08:29,630 --> 00:08:33,440
microseconds because you just like it to

00:08:31,910 --> 00:08:35,839
be fast literally seriously how

00:08:33,440 --> 00:08:37,880
important it is if it's if it's 500

00:08:35,839 --> 00:08:39,469
milliseconds or 100 milliseconds then

00:08:37,880 --> 00:08:41,599
we'll do everything we can to make it

00:08:39,469 --> 00:08:43,760
that fast otherwise you know it might be

00:08:41,599 --> 00:08:45,020
a minute or you know five seconds or

00:08:43,760 --> 00:08:47,270
whatever

00:08:45,020 --> 00:08:49,070
and so forth so as you push the

00:08:47,270 --> 00:08:52,040
boundaries of things like eventual

00:08:49,070 --> 00:08:55,339
consistency and require you know a

00:08:52,040 --> 00:08:57,920
stronger consistency model or real-time

00:08:55,339 --> 00:08:58,940
updates it's going to cost more right so

00:08:57,920 --> 00:09:05,089
those are the things that you have to

00:08:58,940 --> 00:09:08,980
balance out cost versus value cluster

00:09:05,089 --> 00:09:11,240
your your services so each micro service

00:09:08,980 --> 00:09:13,339
you know I feel should be clustered

00:09:11,240 --> 00:09:15,050
unless you know if if it's you know

00:09:13,339 --> 00:09:17,330
maybe your kids soccer site or something

00:09:15,050 --> 00:09:18,740
that may not make sense but for business

00:09:17,330 --> 00:09:21,940
applications for the most part

00:09:18,740 --> 00:09:24,070
clustering is a great way to infuse

00:09:21,940 --> 00:09:26,899
elasticity and resilience into your

00:09:24,070 --> 00:09:31,670
application and as I had mentioned your

00:09:26,899 --> 00:09:33,980
consistency is based on your SLA at the

00:09:31,670 --> 00:09:35,510
end of the day so your consistency model

00:09:33,980 --> 00:09:37,820
the speed at which your data is

00:09:35,510 --> 00:09:41,779
processed all of that really is tied to

00:09:37,820 --> 00:09:43,880
a business decision as to how important

00:09:41,779 --> 00:09:45,440
is this particular transformation of

00:09:43,880 --> 00:09:47,870
data or whatever to the business that's

00:09:45,440 --> 00:09:50,240
going to define those boundaries and the

00:09:47,870 --> 00:09:52,880
last thing we like to say with this is

00:09:50,240 --> 00:09:56,120
because the system is going to be

00:09:52,880 --> 00:09:58,730
autonomous and self-governing it needs

00:09:56,120 --> 00:10:01,880
to have its own data right it can't rely

00:09:58,730 --> 00:10:04,430
on a federated you know Cassandra

00:10:01,880 --> 00:10:06,079
database to pull its data from each

00:10:04,430 --> 00:10:08,839
micro service should have its own unique

00:10:06,079 --> 00:10:12,070
distinct data store whatever that means

00:10:08,839 --> 00:10:15,680
it could be a cache it could be a full

00:10:12,070 --> 00:10:18,320
clustered instance of Cassandra or it

00:10:15,680 --> 00:10:20,390
could be you know my secret whatever it

00:10:18,320 --> 00:10:22,430
should have access to its its own data

00:10:20,390 --> 00:10:25,370
so when the rest of the world collapses

00:10:22,430 --> 00:10:27,410
its can still stand for whatever time

00:10:25,370 --> 00:10:30,920
the SLA says it needs to so polyglot

00:10:27,410 --> 00:10:36,079
persistence is a good way to take a look

00:10:30,920 --> 00:10:38,060
at that so some of the things as we move

00:10:36,079 --> 00:10:39,470
into this world of Micra services we

00:10:38,060 --> 00:10:41,209
need to recognize as what we're really

00:10:39,470 --> 00:10:43,490
talking about is distributed computing

00:10:41,209 --> 00:10:45,890
and that's a totally different beast

00:10:43,490 --> 00:10:47,870
than what we're usually used to in a

00:10:45,890 --> 00:10:49,760
monolithic style application so in

00:10:47,870 --> 00:10:52,279
distributed computing you have these

00:10:49,760 --> 00:10:54,140
boundaries inside your micro service

00:10:52,279 --> 00:10:56,270
that's a safe area and between is just

00:10:54,140 --> 00:10:58,459
the Wunderland the intern

00:10:56,270 --> 00:11:00,770
the network and and all kinds of

00:10:58,459 --> 00:11:02,510
craziness can happen in that area so you

00:11:00,770 --> 00:11:05,510
need to accept that and understand it

00:11:02,510 --> 00:11:07,880
and in doing so in regards to data it

00:11:05,510 --> 00:11:11,000
presents some interesting things to you

00:11:07,880 --> 00:11:12,980
when you take a look at data across your

00:11:11,000 --> 00:11:15,560
entire application which could be 10 20

00:11:12,980 --> 00:11:18,020
micro-services or more the data that is

00:11:15,560 --> 00:11:20,330
stored locally that you process in your

00:11:18,020 --> 00:11:23,120
storage is your inside data and it's it

00:11:20,330 --> 00:11:25,520
is your current reality it isn't it is

00:11:23,120 --> 00:11:28,100
present it is now right that's the only

00:11:25,520 --> 00:11:30,170
real true data that you can say I know

00:11:28,100 --> 00:11:33,320
what that value is and that value is

00:11:30,170 --> 00:11:35,870
valid any data you receive from the

00:11:33,320 --> 00:11:37,730
outside is always historical even if you

00:11:35,870 --> 00:11:39,709
just received it a millisecond ago it

00:11:37,730 --> 00:11:42,290
has always past data there is no

00:11:39,709 --> 00:11:44,779
guarantee that if I pull data from my

00:11:42,290 --> 00:11:46,010
cursor me that when I pull that value

00:11:44,779 --> 00:11:47,630
that the value is still that in

00:11:46,010 --> 00:11:50,450
microservice B there's no way to

00:11:47,630 --> 00:11:51,980
guarantee that okay and in distributed

00:11:50,450 --> 00:11:54,080
computing so you need to recognize that

00:11:51,980 --> 00:11:59,110
and understand what that means to the

00:11:54,080 --> 00:12:01,420
business and then asking right or

00:11:59,110 --> 00:12:03,770
requesting is a hope for the future

00:12:01,420 --> 00:12:05,660
right we always have that discussion and

00:12:03,770 --> 00:12:07,670
akka about guaranteed message delivery

00:12:05,660 --> 00:12:09,560
and do you need it and all these kinds

00:12:07,670 --> 00:12:11,270
of things so and those two in these

00:12:09,560 --> 00:12:14,120
types of systems the things that we need

00:12:11,270 --> 00:12:17,149
to recognize are these three states of

00:12:14,120 --> 00:12:19,220
data and how and how does that affect my

00:12:17,149 --> 00:12:23,300
particular service that I'm designing

00:12:19,220 --> 00:12:26,990
and ultimately we say own your own data

00:12:23,300 --> 00:12:29,240
as I had mentioned before I think the

00:12:26,990 --> 00:12:33,290
real shocking thing that really takes a

00:12:29,240 --> 00:12:35,540
while to accept is it doesn't matter

00:12:33,290 --> 00:12:39,079
what storage medium you have whether

00:12:35,540 --> 00:12:41,029
it's hot warm or cold you're always

00:12:39,079 --> 00:12:46,610
looking at data from the past except

00:12:41,029 --> 00:12:48,890
when it's local to you so as a design

00:12:46,610 --> 00:12:51,459
you know this is the style that we would

00:12:48,890 --> 00:12:56,720
recommend you see on the the left side

00:12:51,459 --> 00:12:59,000
it is basically separate services and so

00:12:56,720 --> 00:13:00,860
you could build this really nice micro

00:12:59,000 --> 00:13:03,079
service distributed system and then use

00:13:00,860 --> 00:13:06,110
a single database that's clustered and

00:13:03,079 --> 00:13:08,930
you kind of broke all the rules so we

00:13:06,110 --> 00:13:10,879
would tell you to do it the other way

00:13:08,930 --> 00:13:12,079
on the right-hand side and the thing

00:13:10,879 --> 00:13:13,550
that's funny about this is a lot of

00:13:12,079 --> 00:13:15,920
people will say well I got to

00:13:13,550 --> 00:13:17,810
synchronize my data and what it and and

00:13:15,920 --> 00:13:19,970
what I like to say is just stop for a

00:13:17,810 --> 00:13:22,189
second and think about your life your

00:13:19,970 --> 00:13:25,430
entire life is based on messaging it's

00:13:22,189 --> 00:13:27,769
in based on eventual consistency

00:13:25,430 --> 00:13:29,449
you'd think financial institutions right

00:13:27,769 --> 00:13:32,120
they're kind of important they've wanted

00:13:29,449 --> 00:13:34,639
her money if if they had guaranteed

00:13:32,120 --> 00:13:37,730
message delivery then we wouldn't have

00:13:34,639 --> 00:13:39,920
overdrafts right in inventory we

00:13:37,730 --> 00:13:42,170
wouldn't have backorder because you just

00:13:39,920 --> 00:13:44,329
simply wouldn't be able to do it but the

00:13:42,170 --> 00:13:46,189
reality of it is is we have both of

00:13:44,329 --> 00:13:47,689
those in those industries and the

00:13:46,189 --> 00:13:52,100
financial industry is a very mature

00:13:47,689 --> 00:13:53,959
industry in many ways so as we embark on

00:13:52,100 --> 00:13:56,689
this adventure and distributed computing

00:13:53,959 --> 00:13:59,870
through Microsoft's there's I think a

00:13:56,689 --> 00:14:02,810
different way of thinking that we can

00:13:59,870 --> 00:14:04,339
either learn the not I wouldn't say the

00:14:02,810 --> 00:14:06,560
easy way but we can also learn it the

00:14:04,339 --> 00:14:08,899
hard way by feeling that all the pain of

00:14:06,560 --> 00:14:11,180
trying to apply our old principles so

00:14:08,899 --> 00:14:14,180
one of the things that I think is really

00:14:11,180 --> 00:14:17,000
neat and very helpful is this this idea

00:14:14,180 --> 00:14:18,319
of promise theory by Mark Burgess if you

00:14:17,000 --> 00:14:19,759
haven't heard of him or you haven't

00:14:18,319 --> 00:14:23,720
heard that I highly recommend you get

00:14:19,759 --> 00:14:26,660
his book and you read it and I think he

00:14:23,720 --> 00:14:28,490
has a really powerful metaphor of how to

00:14:26,660 --> 00:14:31,399
reason about these types of things so a

00:14:28,490 --> 00:14:33,709
promise is a declaration of intent whose

00:14:31,399 --> 00:14:36,439
purpose is to increase the recipient and

00:14:33,709 --> 00:14:39,230
certainty about about a claim of past

00:14:36,439 --> 00:14:41,509
present or future behavior right so if I

00:14:39,230 --> 00:14:44,949
promise somebody something the purpose

00:14:41,509 --> 00:14:48,170
of that is to increase that person's

00:14:44,949 --> 00:14:49,699
reliability on me or the fact that

00:14:48,170 --> 00:14:51,339
they're gonna say okay he said he was

00:14:49,699 --> 00:14:54,769
going to do that and he did do it and

00:14:51,339 --> 00:14:58,509
the reason that this becomes important

00:14:54,769 --> 00:15:01,699
is that when we build systems especially

00:14:58,509 --> 00:15:04,160
distributed systems a lot of times we

00:15:01,699 --> 00:15:06,170
make a mistake of making two systems

00:15:04,160 --> 00:15:08,990
coupled together and what ends up

00:15:06,170 --> 00:15:11,600
happening is in order for my system to

00:15:08,990 --> 00:15:13,459
be successful I'm going to obliged the

00:15:11,600 --> 00:15:15,350
other system right I'm going to place an

00:15:13,459 --> 00:15:17,929
obligation on that other system to give

00:15:15,350 --> 00:15:21,980
me their data and so what I've just done

00:15:17,929 --> 00:15:25,790
is I've tied my success my ability to

00:15:21,980 --> 00:15:28,190
form to someone else's behavior of which

00:15:25,790 --> 00:15:30,200
I have no control over I can't make that

00:15:28,190 --> 00:15:32,750
system do anything so if you just stop

00:15:30,200 --> 00:15:35,570
and think about that and how you apply

00:15:32,750 --> 00:15:37,190
that to system design it becomes a very

00:15:35,570 --> 00:15:38,930
important concept so we would say

00:15:37,190 --> 00:15:44,780
thinking the idea of promises not

00:15:38,930 --> 00:15:46,970
obligations so when we talked about

00:15:44,780 --> 00:15:49,760
these autonomous systems it leads to

00:15:46,970 --> 00:15:52,220
this idea of where your information in

00:15:49,760 --> 00:15:54,860
order for you to be successful is is is

00:15:52,220 --> 00:15:59,360
local so when you're making a promise

00:15:54,860 --> 00:16:02,210
you kind of start out in a vague kind of

00:15:59,360 --> 00:16:04,640
area and you move towards a more stable

00:16:02,210 --> 00:16:06,260
environment whereas with an obligation

00:16:04,640 --> 00:16:08,720
it's the exact opposite it's very

00:16:06,260 --> 00:16:11,240
defined you know what you have obligated

00:16:08,720 --> 00:16:13,400
somebody to do but there's no guarantee

00:16:11,240 --> 00:16:15,830
it's going to occur so you diverge and

00:16:13,400 --> 00:16:18,020
with the promise you converge it comes

00:16:15,830 --> 00:16:20,390
from physics but the idea here is is

00:16:18,020 --> 00:16:22,130
that you need to set yourself up in an

00:16:20,390 --> 00:16:23,900
environment where you will be successful

00:16:22,130 --> 00:16:29,120
and so you have to figure out what that

00:16:23,900 --> 00:16:32,720
is so what we say is a microcircuits

00:16:29,120 --> 00:16:38,330
can only promise its own behavior okay

00:16:32,720 --> 00:16:40,970
if for example I say I promise Jeff I

00:16:38,330 --> 00:16:43,580
will pick you up at six o'clock okay and

00:16:40,970 --> 00:16:47,150
in order for me to do that I have to

00:16:43,580 --> 00:16:49,190
rely on uber or a taxi or maybe Zipcar

00:16:47,150 --> 00:16:54,140
or something like this as I start to go

00:16:49,190 --> 00:16:56,510
through that process okay no taxis

00:16:54,140 --> 00:16:58,190
thirty taxis go by you know I I do my

00:16:56,510 --> 00:17:00,800
uber app this is hey this has happened

00:16:58,190 --> 00:17:03,140
last night thirty taxis go by I start up

00:17:00,800 --> 00:17:05,390
the uber app it just doesn't work right

00:17:03,140 --> 00:17:06,710
so I had to reboot the phone and do all

00:17:05,390 --> 00:17:09,650
this other stuff if I did not give

00:17:06,710 --> 00:17:11,810
myself enough time to manage those

00:17:09,650 --> 00:17:13,850
circumstances then my promise would fail

00:17:11,810 --> 00:17:15,770
and I would not be able to be there on

00:17:13,850 --> 00:17:17,840
time so that's what I got it I can't

00:17:15,770 --> 00:17:19,940
rely on yellow cab or uber or any of

00:17:17,840 --> 00:17:21,620
these things I got to figure out what I

00:17:19,940 --> 00:17:23,960
need to do to make sure I'm there at six

00:17:21,620 --> 00:17:26,270
so that's my promise the more my promise

00:17:23,960 --> 00:17:31,310
comes true the more reliable I am as as

00:17:26,270 --> 00:17:33,200
a service and you can think of it this

00:17:31,310 --> 00:17:34,700
way I'll go back to weather data you

00:17:33,200 --> 00:17:35,490
could have multiple sources of weather

00:17:34,700 --> 00:17:37,800
day

00:17:35,490 --> 00:17:39,960
and some will be more reliable than the

00:17:37,800 --> 00:17:42,420
others and as you begin to track that

00:17:39,960 --> 00:17:45,210
information and and review that Salemi

00:17:42,420 --> 00:17:47,400
tree you can hit the service that's most

00:17:45,210 --> 00:17:49,800
reliable more often and then only roll

00:17:47,400 --> 00:17:52,020
over to the other services when the

00:17:49,800 --> 00:17:53,370
primary service fails and you can you

00:17:52,020 --> 00:17:55,890
can track all that stuff and make

00:17:53,370 --> 00:17:58,290
decisions computationally as how to do

00:17:55,890 --> 00:18:01,530
that so that's the the basic idea so

00:17:58,290 --> 00:18:04,200
promise your own behavior as I had

00:18:01,530 --> 00:18:06,410
mentioned obligations diverge and become

00:18:04,200 --> 00:18:09,750
problematic

00:18:06,410 --> 00:18:13,559
alright so anybody in here not familiar

00:18:09,750 --> 00:18:14,760
with event sourcing good ok good so we

00:18:13,559 --> 00:18:16,350
can kind of go through this I want to

00:18:14,760 --> 00:18:19,470
make sure we get in to the later stuff

00:18:16,350 --> 00:18:23,700
so as we all know event sourcing is the

00:18:19,470 --> 00:18:25,710
idea of capturing events and one of the

00:18:23,700 --> 00:18:28,410
great things about event sourcing is

00:18:25,710 --> 00:18:32,070
that it's an additive structure so it's

00:18:28,410 --> 00:18:34,350
very easy to shard ok and it's very fast

00:18:32,070 --> 00:18:36,570
so you're doing append-only so you

00:18:34,350 --> 00:18:38,160
create a hash for the key you insert it

00:18:36,570 --> 00:18:40,679
into the database whatever whatever

00:18:38,160 --> 00:18:43,290
storage that you're using however you're

00:18:40,679 --> 00:18:45,660
persisting it and it becomes very very

00:18:43,290 --> 00:18:49,320
powerful it also gives you the ability

00:18:45,660 --> 00:18:50,970
to take a look at the behavior of your

00:18:49,320 --> 00:18:53,309
system and play with it you can go back

00:18:50,970 --> 00:18:54,809
in time and you can cut a sandbox some

00:18:53,309 --> 00:18:56,429
of the data and change some of the

00:18:54,809 --> 00:18:58,080
values and see what would have happened

00:18:56,429 --> 00:19:01,260
and you can kind of run through these

00:18:58,080 --> 00:19:04,470
what-if scenarios you can also begin to

00:19:01,260 --> 00:19:06,170
observe behavior about things that

00:19:04,470 --> 00:19:09,420
perhaps you may not even have thought of

00:19:06,170 --> 00:19:12,390
and so forth so event sourcing becomes a

00:19:09,420 --> 00:19:15,750
really powerful way to reason about data

00:19:12,390 --> 00:19:17,190
more mature systems you know if you've

00:19:15,750 --> 00:19:22,020
ever watched Greg Young's video he

00:19:17,190 --> 00:19:24,030
points out more mature systems use event

00:19:22,020 --> 00:19:26,010
sourcing by nature it's like your bank

00:19:24,030 --> 00:19:27,929
can you imagine if your bank used a crud

00:19:26,010 --> 00:19:29,640
current state model they never stored

00:19:27,929 --> 00:19:31,620
transactions they just updated your

00:19:29,640 --> 00:19:33,200
current balance then you go to reconcile

00:19:31,620 --> 00:19:35,880
your account and you're off by 10 grand

00:19:33,200 --> 00:19:37,940
they say you have 10 grand less and you

00:19:35,880 --> 00:19:40,530
call them up and they say well sorry

00:19:37,940 --> 00:19:42,480
we're gonna have to you know implement

00:19:40,530 --> 00:19:44,010
event sourcing in the next sprint so we

00:19:42,480 --> 00:19:46,320
can begin to track that for you I mean

00:19:44,010 --> 00:19:48,540
that's ridiculous but we build systems

00:19:46,320 --> 00:19:49,140
like that and we actually use those same

00:19:48,540 --> 00:19:52,950
excuse

00:19:49,140 --> 00:19:57,450
is when we get a request that you know

00:19:52,950 --> 00:19:59,850
we never even dreamed of crud we know

00:19:57,450 --> 00:20:02,460
what crud is it's we're very familiar

00:19:59,850 --> 00:20:04,860
with it and I'm a big event sourcing guy

00:20:02,460 --> 00:20:06,750
but I will also say that there is I

00:20:04,860 --> 00:20:07,410
think time when crud makes a lot of

00:20:06,750 --> 00:20:10,140
sense too

00:20:07,410 --> 00:20:11,850
there are systems where historical data

00:20:10,140 --> 00:20:13,650
really doesn't matter all they care

00:20:11,850 --> 00:20:16,560
about is the current state of something

00:20:13,650 --> 00:20:18,210
so as data gets fed in then they don't

00:20:16,560 --> 00:20:19,920
care what it said five minutes ago or 10

00:20:18,210 --> 00:20:23,240
minutes ago so why go through the hassle

00:20:19,920 --> 00:20:25,710
of storing all that data and so forth

00:20:23,240 --> 00:20:31,050
and I think those are reasonable

00:20:25,710 --> 00:20:32,310
arguments but as we know with crud we

00:20:31,050 --> 00:20:33,630
have this relational model and a

00:20:32,310 --> 00:20:38,730
relational model is very very powerful

00:20:33,630 --> 00:20:42,120
and especially for querying and also the

00:20:38,730 --> 00:20:43,860
idea of there's no duplicated data in an

00:20:42,120 --> 00:20:46,200
advanced source based system especially

00:20:43,860 --> 00:20:47,880
if you're using CQRS you're gonna have

00:20:46,200 --> 00:20:50,520
tons and tons of duplicate data and

00:20:47,880 --> 00:20:53,330
that's okay right that's okay but you

00:20:50,520 --> 00:20:59,280
have to recognize that and deal with it

00:20:53,330 --> 00:21:01,320
in crud you have generally some type of

00:20:59,280 --> 00:21:04,050
backing model with an you know object

00:21:01,320 --> 00:21:05,850
relational manager and it's going to

00:21:04,050 --> 00:21:08,310
basically do a Venn sourcing under the

00:21:05,850 --> 00:21:10,080
covers temporarily and cache it and

00:21:08,310 --> 00:21:11,670
figure out the differences between your

00:21:10,080 --> 00:21:13,170
updates and your deletes and so forth

00:21:11,670 --> 00:21:14,790
and then flush it into the database

00:21:13,170 --> 00:21:16,890
which is going to do the same thing and

00:21:14,790 --> 00:21:19,200
then finally commit it and keep a

00:21:16,890 --> 00:21:22,680
transaction so it can roll back if

00:21:19,200 --> 00:21:24,450
you've wrapped it in a transaction so so

00:21:22,680 --> 00:21:29,010
you end up getting this type of model

00:21:24,450 --> 00:21:32,010
where you have an order line table and

00:21:29,010 --> 00:21:33,660
and an order table etc and so we have

00:21:32,010 --> 00:21:35,400
these two different models event

00:21:33,660 --> 00:21:36,810
sourcing one of the challenges with

00:21:35,400 --> 00:21:38,910
event sourcing is the number of events

00:21:36,810 --> 00:21:40,530
you have so you snapshot your data so

00:21:38,910 --> 00:21:43,740
all these problems have been worked

00:21:40,530 --> 00:21:46,950
through and figured out but they're both

00:21:43,740 --> 00:21:48,900
components of Micra services you have to

00:21:46,950 --> 00:21:51,570
make the decision again from a business

00:21:48,900 --> 00:21:53,370
perspective which persistence model

00:21:51,570 --> 00:21:54,410
makes more sense for me in this

00:21:53,370 --> 00:21:58,169
situation

00:21:54,410 --> 00:22:02,279
all right so fast data what is it

00:21:58,169 --> 00:22:04,320
fast data is an up-and-coming concept

00:22:02,279 --> 00:22:06,330
actually it's funny a lot of these

00:22:04,320 --> 00:22:09,299
concepts are much older than we might

00:22:06,330 --> 00:22:10,980
think they are in the energy industry we

00:22:09,299 --> 00:22:13,289
have something called a SCADA system and

00:22:10,980 --> 00:22:15,989
the SCADA system is basically event

00:22:13,289 --> 00:22:18,539
sourced based and processes real-time

00:22:15,989 --> 00:22:20,940
data it's been doing it for 40 years or

00:22:18,539 --> 00:22:22,289
more so that these ideas aren't new it's

00:22:20,940 --> 00:22:25,649
just they're coming into more of the

00:22:22,289 --> 00:22:27,539
business realm and fast data is the idea

00:22:25,649 --> 00:22:30,149
that we're gonna process data as it

00:22:27,539 --> 00:22:32,909
arrives and that will lead to a better

00:22:30,149 --> 00:22:36,679
understanding of what's going on what's

00:22:32,909 --> 00:22:38,549
interesting though in fast data is that

00:22:36,679 --> 00:22:40,859
because you're only getting a little

00:22:38,549 --> 00:22:42,659
piece of the picture over some temporal

00:22:40,859 --> 00:22:44,039
boundary you have to be careful that you

00:22:42,659 --> 00:22:46,409
don't make an assumption which is not

00:22:44,039 --> 00:22:49,739
true right if you ever like watch the

00:22:46,409 --> 00:22:51,960
news and the news has a tendency to kind

00:22:49,739 --> 00:22:53,759
of conflate what's going on

00:22:51,960 --> 00:22:55,169
so you're thinking oh I'll come to New

00:22:53,759 --> 00:22:56,580
York City it's one of the most dangerous

00:22:55,169 --> 00:22:57,899
cities in the world I'm gonna get mugged

00:22:56,580 --> 00:22:59,190
and all this other stuff if you know if

00:22:57,899 --> 00:23:01,440
you don't live here you're not used to

00:22:59,190 --> 00:23:03,059
it or whatever and that's because you

00:23:01,440 --> 00:23:06,499
get just a little piece of real-time

00:23:03,059 --> 00:23:10,320
data you don't have the full picture of

00:23:06,499 --> 00:23:12,869
the it's it's interesting in Midtown

00:23:10,320 --> 00:23:14,940
right Chelsea that area that's actually

00:23:12,869 --> 00:23:17,609
the highest crime rate in the city and

00:23:14,940 --> 00:23:19,109
it's basically pickpocketing and stuff

00:23:17,609 --> 00:23:20,249
like that so keep your wallets in your

00:23:19,109 --> 00:23:21,960
front pocket when you're walking around

00:23:20,249 --> 00:23:24,600
but there's no real violent crime or

00:23:21,960 --> 00:23:27,179
anything like that so fast data is this

00:23:24,600 --> 00:23:29,249
thing that's coming in and one of the

00:23:27,179 --> 00:23:32,789
interesting things is we get it from a

00:23:29,249 --> 00:23:34,799
whole host of different locations right

00:23:32,789 --> 00:23:37,289
we can get it from IOT we can get it

00:23:34,799 --> 00:23:41,820
from mobile apps we can get it from

00:23:37,289 --> 00:23:43,950
other servers via headless and all kinds

00:23:41,820 --> 00:23:45,899
of stuff we can pull it from legacy

00:23:43,950 --> 00:23:47,879
systems we can pull it from data lakes

00:23:45,899 --> 00:23:51,480
all this kinds of thing so it's this

00:23:47,879 --> 00:23:53,279
idea of data coming in from everywhere

00:23:51,480 --> 00:23:56,820
the thing that we have to recognize

00:23:53,279 --> 00:23:59,009
about fast data is the the temporal

00:23:56,820 --> 00:24:00,960
boundaries that we create there is no

00:23:59,009 --> 00:24:03,840
beginning and end that's one of the

00:24:00,960 --> 00:24:06,059
first challenges whereas in a regular

00:24:03,840 --> 00:24:08,549
system there is generally a start and

00:24:06,059 --> 00:24:11,009
origin and a destination and fast data

00:24:08,549 --> 00:24:11,970
they're synthetic right those boundaries

00:24:11,009 --> 00:24:14,070
are synthetics

00:24:11,970 --> 00:24:15,990
I use our energy example we had

00:24:14,070 --> 00:24:18,750
synthetic boundaries that were 14 days

00:24:15,990 --> 00:24:22,230
with now being the center point and that

00:24:18,750 --> 00:24:24,030
scale always slid so if it was older

00:24:22,230 --> 00:24:26,700
than 14 days it would drop off we would

00:24:24,030 --> 00:24:28,230
do things like time series data and by

00:24:26,700 --> 00:24:30,840
temporal time series data where you

00:24:28,230 --> 00:24:33,030
would have multiple values for the same

00:24:30,840 --> 00:24:35,160
time slot and they would come in so the

00:24:33,030 --> 00:24:37,980
seven days ahead would be predicted the

00:24:35,160 --> 00:24:40,590
seven days behind would be real data and

00:24:37,980 --> 00:24:42,630
as that thing slid they would update and

00:24:40,590 --> 00:24:44,760
then you would make decisions based on

00:24:42,630 --> 00:24:46,650
the updated data that came in and you

00:24:44,760 --> 00:24:48,060
would continually and this is what we're

00:24:46,650 --> 00:24:50,370
altima getting to here is you would have

00:24:48,060 --> 00:24:56,540
a feedback control loop to make

00:24:50,370 --> 00:24:59,490
decisions on so fast data we have these

00:24:56,540 --> 00:25:03,720
really the the biggest thing I think is

00:24:59,490 --> 00:25:06,450
we have these notions of this temporal

00:25:03,720 --> 00:25:10,380
boundary and the other thing that fast

00:25:06,450 --> 00:25:13,290
data does too is we can get a horizontal

00:25:10,380 --> 00:25:15,690
slice or a horizontal view across our

00:25:13,290 --> 00:25:18,030
microservices where we really weren't

00:25:15,690 --> 00:25:20,100
able to get that before so how do we do

00:25:18,030 --> 00:25:21,720
that right one of the difficult ways is

00:25:20,100 --> 00:25:23,910
figuring out how to do that if every

00:25:21,720 --> 00:25:26,700
microservice has their own persistence

00:25:23,910 --> 00:25:28,680
rate has their own data and one of the

00:25:26,700 --> 00:25:32,040
ways to do that is through something

00:25:28,680 --> 00:25:34,470
like a queue or whatever you're using a

00:25:32,040 --> 00:25:37,490
data backplane as we call it right and

00:25:34,470 --> 00:25:40,710
that data backplane is kind of like a

00:25:37,490 --> 00:25:42,030
river right and all the micro services

00:25:40,710 --> 00:25:43,490
are little villages sitting around the

00:25:42,030 --> 00:25:47,640
river and they all have their own

00:25:43,490 --> 00:25:49,830
purpose and everything generally people

00:25:47,640 --> 00:25:51,660
don't go down to the river every day to

00:25:49,830 --> 00:25:55,230
get something to drink right they dig a

00:25:51,660 --> 00:25:56,790
well and a local well or they go they go

00:25:55,230 --> 00:25:59,730
down to the river and they fill up on

00:25:56,790 --> 00:26:02,640
water for days and weeks and and so

00:25:59,730 --> 00:26:04,470
forth or they cut estuary from the river

00:26:02,640 --> 00:26:07,590
back to the village so they're creating

00:26:04,470 --> 00:26:09,960
their own local persistence by doing

00:26:07,590 --> 00:26:14,940
that as opposed to having to go down to

00:26:09,960 --> 00:26:16,680
the river every day so that I think is

00:26:14,940 --> 00:26:19,590
one of the really cool things about fast

00:26:16,680 --> 00:26:22,140
data but the danger becomes is how do I

00:26:19,590 --> 00:26:24,270
recognize those temporal boundaries so

00:26:22,140 --> 00:26:25,020
when you're doing like machine learning

00:26:24,270 --> 00:26:26,400
or you

00:26:25,020 --> 00:26:28,110
doing statistical regression or

00:26:26,400 --> 00:26:31,020
something like this you have to take

00:26:28,110 --> 00:26:32,850
that data in and then kind of take in

00:26:31,020 --> 00:26:35,250
historical data and train whatever your

00:26:32,850 --> 00:26:38,250
model is and go through this process of

00:26:35,250 --> 00:26:40,670
looking at is this data acceptable and

00:26:38,250 --> 00:26:42,630
ultimately what you come down to is

00:26:40,670 --> 00:26:44,580
determining and again this is determined

00:26:42,630 --> 00:26:46,530
by the business what is the acceptable

00:26:44,580 --> 00:26:50,940
Delta of error for this particular

00:26:46,530 --> 00:26:53,130
process okay so if it's between 3% and

00:26:50,940 --> 00:26:54,870
8% as long as I'm in there I'm good

00:26:53,130 --> 00:26:58,560
there's always going to be errors right

00:26:54,870 --> 00:27:01,500
it's never going to be perfect so how do

00:26:58,560 --> 00:27:03,990
we do that well we have this thing you

00:27:01,500 --> 00:27:06,900
guys anybody here not have a thermostat

00:27:03,990 --> 00:27:08,520
in their house that's good so

00:27:06,900 --> 00:27:10,550
thermostats are kind of like the

00:27:08,520 --> 00:27:12,900
canonical example of feedback control

00:27:10,550 --> 00:27:15,690
every depending on the type of

00:27:12,900 --> 00:27:18,120
thermostat every minute every couple of

00:27:15,690 --> 00:27:19,170
minutes every couple seconds they're

00:27:18,120 --> 00:27:21,540
going to take a temperature reading

00:27:19,170 --> 00:27:23,310
they're going to compare that to the

00:27:21,540 --> 00:27:26,760
current temperature that they have are

00:27:23,310 --> 00:27:28,140
sensing and if it's high then they're

00:27:26,760 --> 00:27:30,510
gonna turn up the air-conditioning if

00:27:28,140 --> 00:27:32,070
it's too low then they're gonna turn off

00:27:30,510 --> 00:27:33,480
the air-conditioning they may even you

00:27:32,070 --> 00:27:35,070
know if you have an Auto sensing it may

00:27:33,480 --> 00:27:37,280
even turn the heat on for a little bit

00:27:35,070 --> 00:27:40,020
and it's gonna keep doing this non-stop

00:27:37,280 --> 00:27:42,240
continuously until it gets the right

00:27:40,020 --> 00:27:43,620
temperature and then of course based on

00:27:42,240 --> 00:27:45,360
your insulation of your house and all

00:27:43,620 --> 00:27:45,990
this other stuff it's going to just do

00:27:45,360 --> 00:27:48,510
this forever

00:27:45,990 --> 00:27:51,270
and that's the idea that we're coming to

00:27:48,510 --> 00:27:53,370
in microservice design is how can we

00:27:51,270 --> 00:27:56,100
implement this it's going to take more

00:27:53,370 --> 00:27:59,880
than just using something like akka and

00:27:56,100 --> 00:28:01,560
building a you know some type of

00:27:59,880 --> 00:28:04,650
federated system it's going to take more

00:28:01,560 --> 00:28:06,120
intelligence we got to think about how

00:28:04,650 --> 00:28:08,610
we can handle this and there's different

00:28:06,120 --> 00:28:10,850
ways you can use machine learning and

00:28:08,610 --> 00:28:13,340
different types of optimizations and

00:28:10,850 --> 00:28:15,720
depending on your return on investment

00:28:13,340 --> 00:28:17,750
you can determine whether that's success

00:28:15,720 --> 00:28:20,130
or not the other thing you can use is

00:28:17,750 --> 00:28:21,750
statistical regression and you can

00:28:20,130 --> 00:28:23,820
that's why I was talking about a delta

00:28:21,750 --> 00:28:27,150
of error so if you run your model

00:28:23,820 --> 00:28:29,970
through MATLAB or something like that

00:28:27,150 --> 00:28:32,550
and then you run it through just a Excel

00:28:29,970 --> 00:28:33,810
and a statistical regression the MATLAB

00:28:32,550 --> 00:28:35,940
model is probably going to be more

00:28:33,810 --> 00:28:38,640
accurate however what you have to

00:28:35,940 --> 00:28:42,630
determine is that is the cost

00:28:38,640 --> 00:28:45,960
of implementing that process worth the

00:28:42,630 --> 00:28:50,700
difference in its the preciseness of the

00:28:45,960 --> 00:28:52,500
model so the idea here is feedback works

00:28:50,700 --> 00:28:54,960
by constantly comparing the actual

00:28:52,500 --> 00:28:57,060
behavior of the system to its desired

00:28:54,960 --> 00:29:00,300
behavior if the actual behavior differs

00:28:57,060 --> 00:29:03,720
from the desired behavior a corrective

00:29:00,300 --> 00:29:05,610
action is applied to counteract the

00:29:03,720 --> 00:29:09,120
deviation and drive the system back to

00:29:05,610 --> 00:29:11,460
its target right straight out of the the

00:29:09,120 --> 00:29:15,680
dictionary or our favorite one Wikipedia

00:29:11,460 --> 00:29:18,390
so things about feedback work hole

00:29:15,680 --> 00:29:20,460
control is it's very isolated it's it's

00:29:18,390 --> 00:29:22,290
very functional for those of you who

00:29:20,460 --> 00:29:26,160
love functional programming right it's

00:29:22,290 --> 00:29:27,870
very set to a particular idea I'm going

00:29:26,160 --> 00:29:30,210
to observe this particular behavior

00:29:27,870 --> 00:29:31,650
that's all I care about I don't care

00:29:30,210 --> 00:29:33,570
about anything else and I want to take

00:29:31,650 --> 00:29:35,790
whatever corrective action I need to

00:29:33,570 --> 00:29:38,630
drive that the result of that behavior

00:29:35,790 --> 00:29:40,980
back to the target or the desired target

00:29:38,630 --> 00:29:44,820
so you're kind of nudging it self

00:29:40,980 --> 00:29:46,260
correcting it and as I had mentioned is

00:29:44,820 --> 00:29:49,350
you've got to be careful here that that

00:29:46,260 --> 00:29:50,850
not the final bullet but the second to

00:29:49,350 --> 00:29:54,300
last bullet you got to be careful not to

00:29:50,850 --> 00:29:58,860
over correct so what you have to

00:29:54,300 --> 00:30:02,340
understand is what's the I took a

00:29:58,860 --> 00:30:04,650
scuba-diving course in college and the

00:30:02,340 --> 00:30:06,570
instructor said to us she said you think

00:30:04,650 --> 00:30:08,250
you're here to learn scuba diving and

00:30:06,570 --> 00:30:11,480
we're like yeah that's why we took the

00:30:08,250 --> 00:30:13,290
course he says now you're here to learn

00:30:11,480 --> 00:30:16,590
basically what I'm going to call

00:30:13,290 --> 00:30:19,320
controlled panic right he says I'm going

00:30:16,590 --> 00:30:22,530
to teach you how to control yourself in

00:30:19,320 --> 00:30:24,420
a panic situation and one of the things

00:30:22,530 --> 00:30:27,210
he did was is he would not let us pass

00:30:24,420 --> 00:30:28,860
the class until we jumped into the deep

00:30:27,210 --> 00:30:31,260
end of the pool with the 20 pound weight

00:30:28,860 --> 00:30:34,590
belt on and he wanted you to feel like

00:30:31,260 --> 00:30:36,060
it was drowning and you had to release

00:30:34,590 --> 00:30:37,530
the weight belt and you would go through

00:30:36,060 --> 00:30:38,880
this exercise because people would start

00:30:37,530 --> 00:30:41,250
to sink and he'd jump in and pull him

00:30:38,880 --> 00:30:43,380
out and so they could learn to release

00:30:41,250 --> 00:30:45,690
their weight belt and the reason was is

00:30:43,380 --> 00:30:47,580
one of his students two years ago or

00:30:45,690 --> 00:30:50,130
this was many many years ago but two

00:30:47,580 --> 00:30:51,660
years prior had gone scuba diving and

00:30:50,130 --> 00:30:54,180
she panicked and

00:30:51,660 --> 00:30:57,300
her regulator fell out and she couldn't

00:30:54,180 --> 00:30:59,340
find it and she didn't release her wheat

00:30:57,300 --> 00:31:02,250
belt and her partner just shot to the

00:30:59,340 --> 00:31:05,250
top so she ended up dying and so he's

00:31:02,250 --> 00:31:06,870
like that's not happening ever again so

00:31:05,250 --> 00:31:09,740
you people need to understand how to do

00:31:06,870 --> 00:31:12,420
it and so the idea with feedback is is

00:31:09,740 --> 00:31:14,280
control that panic you're observing a

00:31:12,420 --> 00:31:16,400
situation you have a very small amount

00:31:14,280 --> 00:31:18,240
of information you're very focused and

00:31:16,400 --> 00:31:20,670
understand that you want to make sure

00:31:18,240 --> 00:31:23,160
that you don't overcorrect this is

00:31:20,670 --> 00:31:25,950
common in monitoring right we call it

00:31:23,160 --> 00:31:27,660
alert fatigue if I have a threshold set

00:31:25,950 --> 00:31:29,880
and that threshold gets violated and

00:31:27,660 --> 00:31:31,680
then I send out an alert after it's like

00:31:29,880 --> 00:31:33,030
a car alarm right how many people rush

00:31:31,680 --> 00:31:35,040
to see if someone's breaking into your

00:31:33,030 --> 00:31:37,290
car when your alarm goes off right

00:31:35,040 --> 00:31:38,910
nobody does it's the same thing in in

00:31:37,290 --> 00:31:40,830
monitoring and this type of stuff so you

00:31:38,910 --> 00:31:43,620
have to be careful not to overcorrect

00:31:40,830 --> 00:31:45,570
and that requires you to have in-depth

00:31:43,620 --> 00:31:52,620
knowledge of the use case that you're

00:31:45,570 --> 00:31:56,310
implementing this in so ending up here

00:31:52,620 --> 00:31:58,880
we have the difference that one of the

00:31:56,310 --> 00:32:01,590
problems in Computer Sciences is the

00:31:58,880 --> 00:32:04,410
behavior is less constrained right it's

00:32:01,590 --> 00:32:06,300
it's it's not the same as building a

00:32:04,410 --> 00:32:07,920
bridge or whatever right and in the

00:32:06,300 --> 00:32:10,710
physical sciences and mechanical

00:32:07,920 --> 00:32:12,150
engineering and civil engineering yeah

00:32:10,710 --> 00:32:15,000
they're they're really amazing but

00:32:12,150 --> 00:32:16,830
there's set factors you know you know

00:32:15,000 --> 00:32:18,240
the basic weather conditions you know

00:32:16,830 --> 00:32:21,870
the current of the river or whatever in

00:32:18,240 --> 00:32:23,970
software I mean how many times has a

00:32:21,870 --> 00:32:26,790
sales rep right or a manager came to you

00:32:23,970 --> 00:32:28,590
and they have sold a new feature that

00:32:26,790 --> 00:32:29,940
doesn't exist and they're like well

00:32:28,590 --> 00:32:30,930
you're smart you can just implement that

00:32:29,940 --> 00:32:33,480
what do you think you need a couple days

00:32:30,930 --> 00:32:38,580
is that good all right anybody not

00:32:33,480 --> 00:32:41,580
experience that okay so you know the

00:32:38,580 --> 00:32:45,000
idea is in software it's it's it's it's

00:32:41,580 --> 00:32:46,230
much more of a moving target so the

00:32:45,000 --> 00:32:49,410
other thing in feedback control is

00:32:46,230 --> 00:32:51,990
thresholds versus anomalies thresholds

00:32:49,410 --> 00:32:55,140
can be very misleading one of the things

00:32:51,990 --> 00:32:57,450
is like actor mailbox size if it is over

00:32:55,140 --> 00:32:59,880
a certain number of messages in that

00:32:57,450 --> 00:33:02,070
case that may be bad for this system but

00:32:59,880 --> 00:33:04,170
it may not be bad for this system so if

00:33:02,070 --> 00:33:05,309
I flag that if that's kind of like my

00:33:04,170 --> 00:33:07,649
default and I

00:33:05,309 --> 00:33:09,509
 it yeah it's good for system a

00:33:07,649 --> 00:33:11,580
but for system B its alert fatigue so

00:33:09,509 --> 00:33:12,960
it's better to do anomaly detection

00:33:11,580 --> 00:33:15,029
where you're gonna capture several

00:33:12,960 --> 00:33:17,340
readings you're gonna know basically

00:33:15,029 --> 00:33:19,590
what the reading should be and then

00:33:17,340 --> 00:33:21,179
you'll smooth the data so if your

00:33:19,590 --> 00:33:23,159
readings are thirty thirty thirty and

00:33:21,179 --> 00:33:25,379
then you get two hundred and then 30 30

00:33:23,159 --> 00:33:27,600
30 are you gonna alert on that two

00:33:25,379 --> 00:33:29,940
hundred maybe right you have to

00:33:27,600 --> 00:33:31,379
understand your system if you get and

00:33:29,940 --> 00:33:32,909
then you get another two hundred and

00:33:31,379 --> 00:33:35,249
another two hundred then you might say

00:33:32,909 --> 00:33:37,980
okay there is a problem it could be that

00:33:35,249 --> 00:33:40,139
one is just an outlier right so these

00:33:37,980 --> 00:33:41,940
types of things has become very

00:33:40,139 --> 00:33:44,159
important than these these types of

00:33:41,940 --> 00:33:45,840
systems so ultimately this is what we

00:33:44,159 --> 00:33:48,119
end up having we have a disturbance that

00:33:45,840 --> 00:33:52,049
comes in we have input into the system

00:33:48,119 --> 00:33:53,730
we have a status we measure it we check

00:33:52,049 --> 00:33:56,669
that value against whatever our set

00:33:53,730 --> 00:33:58,700
point is if there's an error then we go

00:33:56,669 --> 00:34:01,619
down to the controller we go back

00:33:58,700 --> 00:34:04,259
through the effector and then go back up

00:34:01,619 --> 00:34:06,240
to the where the disturbance had and we

00:34:04,259 --> 00:34:11,040
just continue to do that loop until we

00:34:06,240 --> 00:34:16,290
have the set point that we want so just

00:34:11,040 --> 00:34:18,300
to recap these concepts and the purpose

00:34:16,290 --> 00:34:22,440
of my presentation is that when you're

00:34:18,300 --> 00:34:25,349
building micro service systems micro

00:34:22,440 --> 00:34:27,629
service based design systems you know

00:34:25,349 --> 00:34:29,940
it's it's a catch word microservices the

00:34:27,629 --> 00:34:32,190
cloud you know it's what are they your

00:34:29,940 --> 00:34:33,690
building distributed systems when you're

00:34:32,190 --> 00:34:35,369
building distributed systems there's

00:34:33,690 --> 00:34:38,270
some very important concepts that you

00:34:35,369 --> 00:34:42,329
need to understand and I would say I

00:34:38,270 --> 00:34:45,409
would say that promise Theory obviously

00:34:42,329 --> 00:34:47,760
events sourcing and feedback control or

00:34:45,409 --> 00:34:49,589
maybe feedback control the most when

00:34:47,760 --> 00:34:52,589
promise theory are new concepts to most

00:34:49,589 --> 00:34:54,899
of us and it's very much worth taking

00:34:52,589 --> 00:35:00,089
the time to investigate them and apply

00:34:54,899 --> 00:35:02,609
them to your system design so that

00:35:00,089 --> 00:35:03,930
brings us to the the the last section of

00:35:02,609 --> 00:35:05,450
our discussion and that's building

00:35:03,930 --> 00:35:08,040
systems now that we have an

00:35:05,450 --> 00:35:09,839
understanding of what these various

00:35:08,040 --> 00:35:11,760
components are building these types of

00:35:09,839 --> 00:35:13,619
systems you know where do we implement

00:35:11,760 --> 00:35:19,890
them how do we decide how how and when

00:35:13,619 --> 00:35:21,930
to use them so we go back to

00:35:19,890 --> 00:35:25,499
the same thing we have a set of

00:35:21,930 --> 00:35:27,690
guidelines which are suggested right

00:35:25,499 --> 00:35:32,029
using promise Theory owning your own

00:35:27,690 --> 00:35:34,640
data keeping your systems small

00:35:32,029 --> 00:35:37,349
reasonably small so they're easy to test

00:35:34,640 --> 00:35:39,839
clustering for resilience you know using

00:35:37,349 --> 00:35:44,039
a toolkit or a framework that provides

00:35:39,839 --> 00:35:48,180
these features understanding that things

00:35:44,039 --> 00:35:50,160
like consistency and availability and

00:35:48,180 --> 00:35:54,869
all these types of things are defined by

00:35:50,160 --> 00:35:57,390
your SLA not some toolkit or some

00:35:54,869 --> 00:36:02,729
document that you read using polyglot

00:35:57,390 --> 00:36:05,069
persistence and then what you end up is

00:36:02,729 --> 00:36:07,829
is this style of diagram so where you

00:36:05,069 --> 00:36:10,319
have your different microservices and on

00:36:07,829 --> 00:36:13,739
the left there happens to be four in

00:36:10,319 --> 00:36:16,499
this cluster and they're using some type

00:36:13,739 --> 00:36:18,749
of no sequel database to say perhaps in

00:36:16,499 --> 00:36:22,289
the center we have some search mechanism

00:36:18,749 --> 00:36:24,749
and that's not using any warm storage

00:36:22,289 --> 00:36:26,849
it's it's a hot in memory cache say

00:36:24,749 --> 00:36:30,029
something like that and you will decide

00:36:26,849 --> 00:36:31,920
with your business folks and and what

00:36:30,029 --> 00:36:37,950
the SLA says is as to what is the best

00:36:31,920 --> 00:36:40,229
way to lay this out for each system when

00:36:37,950 --> 00:36:42,269
deciding between crud and event sourcing

00:36:40,229 --> 00:36:44,999
if you care about history historical

00:36:42,269 --> 00:36:47,190
auditing use event sourcing auditing use

00:36:44,999 --> 00:36:49,859
of n sourcing if you need to charge your

00:36:47,190 --> 00:36:52,950
data in a significant way use event

00:36:49,859 --> 00:36:56,069
sourcing if you want strong consistency

00:36:52,950 --> 00:36:58,380
and historical strong consistency then

00:36:56,069 --> 00:37:01,319
use crud and understand that you are

00:36:58,380 --> 00:37:02,759
most likely you can still do event

00:37:01,319 --> 00:37:05,069
sourcing obviously in a relational

00:37:02,759 --> 00:37:06,930
database right and you can still use the

00:37:05,069 --> 00:37:08,910
relational database semantics with

00:37:06,930 --> 00:37:11,460
transaction management it's just when

00:37:08,910 --> 00:37:14,039
you go to cluster and replicate the data

00:37:11,460 --> 00:37:15,839
that's where it's not as easy if you're

00:37:14,039 --> 00:37:18,690
using traditional with outsourcing but

00:37:15,839 --> 00:37:21,809
you need to take a look at that and make

00:37:18,690 --> 00:37:23,640
that decision and again if you are if

00:37:21,809 --> 00:37:24,779
you only care about current state then I

00:37:23,640 --> 00:37:29,729
would definitely use crud in that

00:37:24,779 --> 00:37:32,310
situation so now we have our system

00:37:29,729 --> 00:37:33,750
we've layered onto it the decision of

00:37:32,310 --> 00:37:35,760
we're gonna use crud and where we're

00:37:33,750 --> 00:37:38,040
going to use event sourcing and so now

00:37:35,760 --> 00:37:40,770
we have in this particular one we've

00:37:38,040 --> 00:37:43,800
changed the the search cache or the

00:37:40,770 --> 00:37:45,720
search cache is not historically

00:37:43,800 --> 00:37:47,190
capturing the data it's just replacing

00:37:45,720 --> 00:37:49,140
the data in memory whatever that data

00:37:47,190 --> 00:37:51,570
structure is and the other two ones are

00:37:49,140 --> 00:37:53,010
using event sourcing now we want to take

00:37:51,570 --> 00:37:58,050
a look at fast state and how we're going

00:37:53,010 --> 00:37:59,520
to implement that in our system remember

00:37:58,050 --> 00:38:01,980
the fact that fast data is based on

00:37:59,520 --> 00:38:04,710
streaming streaming has this the

00:38:01,980 --> 00:38:06,570
synthetic boundaries for time temporal

00:38:04,710 --> 00:38:09,150
boundaries and they're understanding

00:38:06,570 --> 00:38:11,580
that understanding that in many cases

00:38:09,150 --> 00:38:14,850
fast data is you know orthogonal to your

00:38:11,580 --> 00:38:17,130
microservice architecture and so forth

00:38:14,850 --> 00:38:20,340
and then as I had mentioned earlier

00:38:17,130 --> 00:38:23,460
think about it as a backplane one of the

00:38:20,340 --> 00:38:26,310
mistakes that I believe is being made

00:38:23,460 --> 00:38:28,290
today is a lot of folks that are

00:38:26,310 --> 00:38:31,050
starting to take that data backplane and

00:38:28,290 --> 00:38:32,790
use it as their persistence source of

00:38:31,050 --> 00:38:34,230
truth and I don't think that's a good

00:38:32,790 --> 00:38:35,880
design even though they can do that I

00:38:34,230 --> 00:38:38,160
don't think it's a good design because I

00:38:35,880 --> 00:38:40,500
think you should own your your source of

00:38:38,160 --> 00:38:43,560
truth nobody else the data backplane

00:38:40,500 --> 00:38:45,210
just feeds right it's another place that

00:38:43,560 --> 00:38:48,390
you can grab some data from so now we

00:38:45,210 --> 00:38:50,820
take a look at our our system and this

00:38:48,390 --> 00:38:52,980
is what we end up having in the center

00:38:50,820 --> 00:38:55,170
there's our a river our data backplane

00:38:52,980 --> 00:38:58,050
and we have all these different micro

00:38:55,170 --> 00:39:02,580
services around it that feed into it and

00:38:58,050 --> 00:39:03,720
pull out from it and so forth and these

00:39:02,580 --> 00:39:06,180
systems work pretty well

00:39:03,720 --> 00:39:09,300
they really do they're very robust and

00:39:06,180 --> 00:39:11,010
they give you they give each micro

00:39:09,300 --> 00:39:13,290
service insight that they may not have

00:39:11,010 --> 00:39:15,930
previously had or that they would have

00:39:13,290 --> 00:39:18,230
had to request as opposed to being able

00:39:15,930 --> 00:39:22,260
to subscribe to or something like that

00:39:18,230 --> 00:39:25,590
so we we do that and in this particular

00:39:22,260 --> 00:39:28,140
example for fast data we're going to use

00:39:25,590 --> 00:39:29,880
Katka so that's a great it's a great

00:39:28,140 --> 00:39:32,130
dunk you to use that works very very

00:39:29,880 --> 00:39:34,560
well and the last thing we're going to

00:39:32,130 --> 00:39:40,260
add to our system is this feedback

00:39:34,560 --> 00:39:41,970
control and the different aspects we've

00:39:40,260 --> 00:39:43,230
already talked through and and I got to

00:39:41,970 --> 00:39:46,170
be sensitive of time but we're just

00:39:43,230 --> 00:39:48,420
about at the end here and

00:39:46,170 --> 00:39:50,820
now if we take a look at feedback

00:39:48,420 --> 00:39:52,890
control in akka we have it built in

00:39:50,820 --> 00:39:56,400
through supervisory control which gives

00:39:52,890 --> 00:39:58,290
us our ability to be self-healing but

00:39:56,400 --> 00:40:00,360
it's also feedback the supervisor

00:39:58,290 --> 00:40:03,350
receives data from the child and makes a

00:40:00,360 --> 00:40:07,620
decision and it can do that in a loop

00:40:03,350 --> 00:40:10,440
and so now we have our system and we've

00:40:07,620 --> 00:40:12,900
implemented tools such as spark and and

00:40:10,440 --> 00:40:15,510
so forth to provide us the ability to do

00:40:12,900 --> 00:40:18,210
some of these regression analysis and

00:40:15,510 --> 00:40:20,540
feedback control let's type things so

00:40:18,210 --> 00:40:23,430
we're almost there what are we missing

00:40:20,540 --> 00:40:26,460
we're gonna add insight an insight is

00:40:23,430 --> 00:40:28,710
monitoring of the system and that's the

00:40:26,460 --> 00:40:31,170
ability to not only monitor the system

00:40:28,710 --> 00:40:33,450
but also monitor the monitor who watches

00:40:31,170 --> 00:40:34,710
the watcher so any monitoring tool you

00:40:33,450 --> 00:40:37,440
have should also be able to monitor

00:40:34,710 --> 00:40:40,410
itself and say hey I'm having a problem

00:40:37,440 --> 00:40:42,330
or whatever so at the end of the day we

00:40:40,410 --> 00:40:45,120
have this the system that provides all

00:40:42,330 --> 00:40:47,850
the features we're looking for an

00:40:45,120 --> 00:40:50,160
insight you know you can do events and

00:40:47,850 --> 00:40:52,920
metrics and all kinds of stuff you can

00:40:50,160 --> 00:40:54,390
use collect these stats D there's a lot

00:40:52,920 --> 00:41:00,900
of tools out there that provide that we

00:40:54,390 --> 00:41:03,210
have it for akka and so forth so I want

00:41:00,900 --> 00:41:04,770
to take the rest and just leave the last

00:41:03,210 --> 00:41:07,070
couple of minutes for any questions if

00:41:04,770 --> 00:41:07,070
there are

00:41:14,520 --> 00:41:20,050
if not thank you for coming out and I'll

00:41:18,610 --> 00:41:21,370
be here for a couple minutes if you have

00:41:20,050 --> 00:41:24,810
any questions if you just want to come

00:41:21,370 --> 00:41:24,810

YouTube URL: https://www.youtube.com/watch?v=tWDoYWRcvNQ


