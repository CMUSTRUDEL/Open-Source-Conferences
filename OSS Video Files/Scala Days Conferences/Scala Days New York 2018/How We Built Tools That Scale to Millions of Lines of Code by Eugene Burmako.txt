Title: How We Built Tools That Scale to Millions of Lines of Code by Eugene Burmako
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/how-we-built-tools-that-scale-to-millions-of-lines-of-code
Captions: 
	00:00:04,760 --> 00:00:10,040
hey everyone my name is Eugene and today

00:00:08,480 --> 00:00:13,129
I'm here to talk about tooling at

00:00:10,040 --> 00:00:16,010
Twitter you may know me from my previous

00:00:13,129 --> 00:00:19,670
work and scowl reflect skull of macros

00:00:16,010 --> 00:00:21,230
skull meta and most recently RSC in you

00:00:19,670 --> 00:00:21,800
Scala compiler that were developed in a

00:00:21,230 --> 00:00:24,230
Twitter

00:00:21,800 --> 00:00:26,900
the underlying theme behind all these

00:00:24,230 --> 00:00:28,669
projects is meta programming and tooling

00:00:26,900 --> 00:00:31,730
so first I started doing meta

00:00:28,669 --> 00:00:34,340
programming for Scala at EPFL as part of

00:00:31,730 --> 00:00:36,949
my PhD thesis in Martin and there's keys

00:00:34,340 --> 00:00:38,750
lab and now I'm representing Twitter as

00:00:36,949 --> 00:00:42,440
the tech lead of the advanced controls

00:00:38,750 --> 00:00:45,140
team typically I begin my slides with

00:00:42,440 --> 00:00:45,649
credits and this talk is definitely no

00:00:45,140 --> 00:00:47,390
exception

00:00:45,649 --> 00:00:49,940
because this whole internal initiative

00:00:47,390 --> 00:00:51,890
to build next-generation

00:00:49,940 --> 00:00:54,649
tooling it Twitter was a huge

00:00:51,890 --> 00:00:57,530
collaborative effort core contributors

00:00:54,649 --> 00:01:01,309
to that effort were my team in

00:00:57,530 --> 00:01:04,430
alphabetical order myself Shane and uma

00:01:01,309 --> 00:01:06,680
as well as our early adopters within

00:01:04,430 --> 00:01:10,190
Twitter I get enough of ethical order

00:01:06,680 --> 00:01:13,430
build CII code review the guys from our

00:01:10,190 --> 00:01:16,130
department as well as library teams CDL

00:01:13,430 --> 00:01:17,890
and CSL and other folks at Twitter

00:01:16,130 --> 00:01:20,360
lots of people contributed to that

00:01:17,890 --> 00:01:22,310
slides are too small to fit every one

00:01:20,360 --> 00:01:25,670
but I'm really really grateful to you

00:01:22,310 --> 00:01:27,050
guys the last but not the least I would

00:01:25,670 --> 00:01:29,570
like to highlight our open source

00:01:27,050 --> 00:01:31,880
collaboration within scala meta a meta

00:01:29,570 --> 00:01:34,700
programming library for scala which is

00:01:31,880 --> 00:01:35,540
cornerstone to the entire effort so for

00:01:34,700 --> 00:01:37,940
the last two years

00:01:35,540 --> 00:01:42,200
Scala meta has been basically a two-man

00:01:37,940 --> 00:01:43,430
show it's been myself and all of gearson

00:01:42,200 --> 00:01:47,420
from the Scala Center who've been

00:01:43,430 --> 00:01:49,010
writing the thing and all of if you

00:01:47,420 --> 00:01:51,500
don't know the guy he's the author of

00:01:49,010 --> 00:01:54,470
sky life MT Scala fix a bunch of other

00:01:51,500 --> 00:01:56,510
tools including metals and I would say

00:01:54,470 --> 00:01:58,100
our joint collaboration on Scala meta

00:01:56,510 --> 00:02:00,680
it's been super successful it's a great

00:01:58,100 --> 00:02:03,200
open source success story so despite

00:02:00,680 --> 00:02:04,610
working for different employers having

00:02:03,200 --> 00:02:06,950
different internal roadmaps and

00:02:04,610 --> 00:02:10,250
oftentimes different opinions we've

00:02:06,950 --> 00:02:12,319
always been able to come to come up with

00:02:10,250 --> 00:02:15,200
a joint roadmap that allows us to

00:02:12,319 --> 00:02:16,879
achieve our internal goals plus further

00:02:15,200 --> 00:02:17,600
the state of the art of tooling for the

00:02:16,879 --> 00:02:20,120
benefit of the

00:02:17,600 --> 00:02:26,780
community so EA open-source and thanks

00:02:20,120 --> 00:02:29,090
to everyone who supports open source all

00:02:26,780 --> 00:02:31,310
right on that note I would like to

00:02:29,090 --> 00:02:33,350
proceed with the talk and in general I'd

00:02:31,310 --> 00:02:35,390
like to keep the stock really grounded

00:02:33,350 --> 00:02:37,190
in practice so we will start with the

00:02:35,390 --> 00:02:39,680
problem looking for a solution not the

00:02:37,190 --> 00:02:41,480
other way around and speaking of the

00:02:39,680 --> 00:02:44,630
problems here's one we have a huge

00:02:41,480 --> 00:02:47,030
codebase so pulling up the numbers from

00:02:44,630 --> 00:02:48,650
our last year's called a stack will

00:02:47,030 --> 00:02:51,310
literally have tens of millions of lines

00:02:48,650 --> 00:02:53,960
of code and that that's not counting

00:02:51,310 --> 00:02:55,550
auto-generated stuff this code is

00:02:53,960 --> 00:02:57,770
organized in tens of thousands of

00:02:55,550 --> 00:02:59,960
so-called targets which is like

00:02:57,770 --> 00:03:02,120
lightweight projects units of

00:02:59,960 --> 00:03:03,880
compilation in the terminology of pans

00:03:02,120 --> 00:03:06,560
the build tool that were using and

00:03:03,880 --> 00:03:08,600
clearly to be productive within a code

00:03:06,560 --> 00:03:11,540
base like this we need smarter tools

00:03:08,600 --> 00:03:14,630
something that we call semantic tools so

00:03:11,540 --> 00:03:16,340
these tools they need not only to look

00:03:14,630 --> 00:03:19,190
at the syntactic structure of the

00:03:16,340 --> 00:03:20,720
program and the text but also be able to

00:03:19,190 --> 00:03:22,880
answer questions like well what does

00:03:20,720 --> 00:03:23,690
this identifier resolve to or you know

00:03:22,880 --> 00:03:25,580
what's the type of the expression

00:03:23,690 --> 00:03:28,850
something that you typically expect from

00:03:25,580 --> 00:03:30,380
an ID but you know on a larger scale I

00:03:28,850 --> 00:03:32,120
promise you a problem statement and

00:03:30,380 --> 00:03:34,700
definitely this thing is not crisp

00:03:32,120 --> 00:03:36,920
enough so we went ahead we prioritized

00:03:34,700 --> 00:03:39,530
user asks and we ended up with the

00:03:36,920 --> 00:03:41,600
following list it's somewhat arbitrary

00:03:39,530 --> 00:03:43,580
but hey we're doing tools for our users

00:03:41,600 --> 00:03:46,040
so we have to take this stuff into

00:03:43,580 --> 00:03:49,490
account well first of all we wouldn't

00:03:46,040 --> 00:03:51,320
want code browsing to understand the

00:03:49,490 --> 00:03:53,360
structure of the programs that is it

00:03:51,320 --> 00:03:56,060
would be desirable that we'll be able to

00:03:53,360 --> 00:03:58,370
open our source code in any tool really

00:03:56,060 --> 00:04:00,470
we have a lot of flexibility and then at

00:03:58,370 --> 00:04:02,390
least be able to follow hyperlinks make

00:04:00,470 --> 00:04:04,070
you know command click control click on

00:04:02,390 --> 00:04:06,590
your ID something like that

00:04:04,070 --> 00:04:07,970
of course the more smart functionality

00:04:06,590 --> 00:04:11,270
the better but this is like you know the

00:04:07,970 --> 00:04:14,870
basics we also want similar things for

00:04:11,270 --> 00:04:17,090
code review so if we are doing a code

00:04:14,870 --> 00:04:20,450
review it will be desirable to be able

00:04:17,090 --> 00:04:22,340
to go to definitions and finally it

00:04:20,450 --> 00:04:24,740
would be great to run code rewrites

00:04:22,340 --> 00:04:26,630
against our entire code base one of the

00:04:24,740 --> 00:04:28,790
benefits of the mono repo this huge

00:04:26,630 --> 00:04:30,749
repository of code that we have is that

00:04:28,790 --> 00:04:32,639
we can involve everything simultaneous

00:04:30,749 --> 00:04:35,129
so it would be great to take advantage

00:04:32,639 --> 00:04:37,020
of that and you know clearly for

00:04:35,129 --> 00:04:38,729
languages like Scala just reg xbase

00:04:37,020 --> 00:04:41,729
rewrites they're not enough otherwise

00:04:38,729 --> 00:04:43,860
how do you figure out that something

00:04:41,729 --> 00:04:45,990
that gets actually the first option

00:04:43,860 --> 00:04:51,960
don't get for instance and other method

00:04:45,990 --> 00:04:54,599
call get well anyway as I said I'd like

00:04:51,960 --> 00:04:57,509
to keep this talk grounded in practice

00:04:54,599 --> 00:04:59,639
which means that well let's see whether

00:04:57,509 --> 00:05:01,349
we have solutions that work out of the

00:04:59,639 --> 00:05:03,659
box that would definitely be the most

00:05:01,349 --> 00:05:05,909
economical way to deliver what our users

00:05:03,659 --> 00:05:07,770
want but you know it turns out that

00:05:05,909 --> 00:05:11,099
since this is Scala it's basically

00:05:07,770 --> 00:05:13,050
nightmare mode not even hard mode just

00:05:11,099 --> 00:05:16,800
to go back to the times when we were

00:05:13,050 --> 00:05:19,229
considering this this effort code

00:05:16,800 --> 00:05:22,020
browsin was for Scala was limited to IDs

00:05:19,229 --> 00:05:24,960
but unfortunately given the humongous

00:05:22,020 --> 00:05:27,539
size of our code base no IDs could load

00:05:24,960 --> 00:05:29,580
it in its entirety so that's that's

00:05:27,539 --> 00:05:31,680
definitely workable because you can you

00:05:29,580 --> 00:05:35,039
know export part of the projects and

00:05:31,680 --> 00:05:36,330
then load that part into IntelliJ but

00:05:35,039 --> 00:05:38,009
clearly this is suboptimal for

00:05:36,330 --> 00:05:39,050
navigation purposes something that I

00:05:38,009 --> 00:05:41,699
mentioned before

00:05:39,050 --> 00:05:44,490
speaking of code review at Twitter were

00:05:41,699 --> 00:05:47,249
using fabricator and even though

00:05:44,490 --> 00:05:50,069
fabricator has some support for semantic

00:05:47,249 --> 00:05:51,959
features for Python and PHP there's

00:05:50,069 --> 00:05:53,580
something out of the box it does not

00:05:51,959 --> 00:05:56,849
have skull integration remember

00:05:53,580 --> 00:05:59,729
nightmare mode right and for code

00:05:56,849 --> 00:06:01,979
evolution there was this thing still is

00:05:59,729 --> 00:06:04,379
called skull refactoring which was used

00:06:01,979 --> 00:06:07,439
for code rewrites in enzyme and Scala

00:06:04,379 --> 00:06:10,259
IDE but unfortunately at that point it

00:06:07,439 --> 00:06:13,860
had a backlog of fundamental issues and

00:06:10,259 --> 00:06:16,589
no maintainer which was which was kind

00:06:13,860 --> 00:06:19,110
of sad and finally there were some

00:06:16,589 --> 00:06:22,139
proprietary solutions with different

00:06:19,110 --> 00:06:24,509
levels of Scala support but internally

00:06:22,139 --> 00:06:26,459
we've been burned by unsuccessful

00:06:24,509 --> 00:06:28,219
experience with one of them which is why

00:06:26,459 --> 00:06:30,749
we decided to go with something else

00:06:28,219 --> 00:06:33,089
now all the stuff all this background is

00:06:30,749 --> 00:06:35,300
increasingly pointed to the fact that we

00:06:33,089 --> 00:06:37,919
would need custom development and

00:06:35,300 --> 00:06:40,319
therefore some folks myself included

00:06:37,919 --> 00:06:43,019
argued for creating a dedicated team for

00:06:40,319 --> 00:06:43,830
that purpose and ultimately that

00:06:43,019 --> 00:06:47,220
happened

00:06:43,830 --> 00:06:49,080
last year and we found in the team with

00:06:47,220 --> 00:06:49,980
the mission to go boldly where no man

00:06:49,080 --> 00:06:51,870
has gone before

00:06:49,980 --> 00:06:54,060
meaning to improve the state of the art

00:06:51,870 --> 00:06:58,290
of Scala tooling both internally and

00:06:54,060 --> 00:06:59,970
then also to open source the most

00:06:58,290 --> 00:07:02,730
important of our efforts had to benefit

00:06:59,970 --> 00:07:04,110
the community and the roadmap it

00:07:02,730 --> 00:07:06,270
basically mirrors the problem statement

00:07:04,110 --> 00:07:07,980
that we've seen in previous slides to

00:07:06,270 --> 00:07:13,260
improve code browsing code review and

00:07:07,980 --> 00:07:15,720
code evolution okay so how do you go

00:07:13,260 --> 00:07:17,250
about building semantic tools well a

00:07:15,720 --> 00:07:20,670
good idea would be to take existing

00:07:17,250 --> 00:07:23,040
semantic ap is something that compilers

00:07:20,670 --> 00:07:25,800
are good at and just use them out of the

00:07:23,040 --> 00:07:28,370
box so back then we were considering

00:07:25,800 --> 00:07:30,870
this project of improving our tools

00:07:28,370 --> 00:07:33,410
there's arrows but there were basically

00:07:30,870 --> 00:07:36,510
three choices compiler internals

00:07:33,410 --> 00:07:38,760
compiler internals light aka scale

00:07:36,510 --> 00:07:41,580
reflect and compiler internals extra

00:07:38,760 --> 00:07:43,920
light make a scholar signatures so

00:07:41,580 --> 00:07:45,360
that's definitely lots of code which has

00:07:43,920 --> 00:07:48,860
been battle tested for over a decade

00:07:45,360 --> 00:07:51,600
that's pretty solid but unfortunately

00:07:48,860 --> 00:07:53,550
when we considered it we decided to go

00:07:51,600 --> 00:07:55,290
with something else because of the

00:07:53,550 --> 00:07:56,850
following reasons

00:07:55,290 --> 00:07:59,460
the first bro the first problem that we

00:07:56,850 --> 00:08:01,860
found with Scala see internals is the

00:07:59,460 --> 00:08:04,020
learning curve so as I mentioned before

00:08:01,860 --> 00:08:06,720
the compiler is more than ten years old

00:08:04,020 --> 00:08:09,720
and it accumulated lots of lots of stuff

00:08:06,720 --> 00:08:12,420
basically dozens of modules thousands of

00:08:09,720 --> 00:08:15,750
methods and the data model to tell the

00:08:12,420 --> 00:08:18,030
truth it's quite complicated so just to

00:08:15,750 --> 00:08:19,710
give you guys a mind bender right so we

00:08:18,030 --> 00:08:22,140
have objects and Scala right object

00:08:19,710 --> 00:08:24,270
definitions and so in the Scala compiler

00:08:22,140 --> 00:08:27,150
objects are modeled modules by one

00:08:24,270 --> 00:08:29,670
entity but but by two entities and what

00:08:27,150 --> 00:08:33,060
you'll symbol so module is a Scala see

00:08:29,670 --> 00:08:35,370
lingo for object and a module class so

00:08:33,060 --> 00:08:37,460
that's fun and as a result we have two

00:08:35,370 --> 00:08:40,410
ways to refer to a type of an object

00:08:37,460 --> 00:08:43,680
something called this type for a module

00:08:40,410 --> 00:08:46,320
class symbol or a singleton type for a

00:08:43,680 --> 00:08:49,050
module symbol and be the most amazing

00:08:46,320 --> 00:08:50,730
thing is that only one of those ways to

00:08:49,050 --> 00:08:53,520
refer to the type of the object is valid

00:08:50,730 --> 00:08:55,890
in in one context and another way is

00:08:53,520 --> 00:08:57,210
valid in another context so this is

00:08:55,890 --> 00:08:57,540
pretty mind-blowing and

00:08:57,210 --> 00:08:58,949
you

00:08:57,540 --> 00:09:01,290
I mentioned that they did be in this

00:08:58,949 --> 00:09:03,329
area but believe it or not I had to

00:09:01,290 --> 00:09:06,120
rehearse this part before the stock

00:09:03,329 --> 00:09:08,810
yesterday so that to make sure I get

00:09:06,120 --> 00:09:12,149
this right so yeah it's it's that hard

00:09:08,810 --> 00:09:15,449
anyway the second blocker that we found

00:09:12,149 --> 00:09:17,639
is insufficient documentation so Scala

00:09:15,449 --> 00:09:20,699
is a pretty involved language there are

00:09:17,639 --> 00:09:22,949
lots of ways to define things lots of

00:09:20,699 --> 00:09:25,500
different types and syntactic variation

00:09:22,949 --> 00:09:26,940
is also pretty impressive to make sense

00:09:25,500 --> 00:09:29,250
of all of that to see how it all plays

00:09:26,940 --> 00:09:32,190
together we definitely need more than

00:09:29,250 --> 00:09:34,259
just Scala Docs so even though in Scala

00:09:32,190 --> 00:09:36,269
reflect which became the foundation of

00:09:34,259 --> 00:09:38,069
the current Scala macros we did lots of

00:09:36,269 --> 00:09:41,160
work and documentation it still wasn't

00:09:38,069 --> 00:09:43,860
enough and so if we were to use a

00:09:41,160 --> 00:09:47,850
compiler internals I would be exposing

00:09:43,860 --> 00:09:49,399
the team myself included to this kind of

00:09:47,850 --> 00:09:52,709
Mindbenders that i mentioned before

00:09:49,399 --> 00:09:54,209
which is kind of suboptimal well if

00:09:52,709 --> 00:09:56,970
we're talking like you know really

00:09:54,209 --> 00:09:57,569
really practice oriented stuff these

00:09:56,970 --> 00:10:00,839
problems

00:09:57,569 --> 00:10:03,000
number one the learning curve and number

00:10:00,839 --> 00:10:05,550
two documentation if we squint at them

00:10:03,000 --> 00:10:07,940
there are success stories here right so

00:10:05,550 --> 00:10:10,079
clearly people in martin's lab at EPFL

00:10:07,940 --> 00:10:12,240
people at light band who are maintaining

00:10:10,079 --> 00:10:13,440
the Scala compiler they have figured

00:10:12,240 --> 00:10:15,149
everything out and they've been

00:10:13,440 --> 00:10:17,250
productive delivering new functionality

00:10:15,149 --> 00:10:20,579
so this is a you could say this is a

00:10:17,250 --> 00:10:22,769
social problem right but anyway we found

00:10:20,579 --> 00:10:24,990
out a really hard technical blocker here

00:10:22,769 --> 00:10:27,569
and this is why we couldn't use compiler

00:10:24,990 --> 00:10:29,339
internals at all unfortunately so the

00:10:27,569 --> 00:10:32,190
thing is that compiler internals require

00:10:29,339 --> 00:10:34,620
a compiler instance well duh right but

00:10:32,190 --> 00:10:38,430
the thing is the compiler has been

00:10:34,620 --> 00:10:41,819
optimized over more than a decade or I

00:10:38,430 --> 00:10:43,860
would say overtrained towards the best

00:10:41,819 --> 00:10:45,240
compilation use case the speaking of

00:10:43,860 --> 00:10:47,250
batch compilation how does this work

00:10:45,240 --> 00:10:49,350
right you give the compiler lots of

00:10:47,250 --> 00:10:51,720
sources and you don't expect it to

00:10:49,350 --> 00:10:53,550
finish very quickly because well it's

00:10:51,720 --> 00:10:55,740
Scala does a lot of work what's the

00:10:53,550 --> 00:10:58,069
features so you wait until it's done and

00:10:55,740 --> 00:11:00,839
then you inspect the results but

00:10:58,069 --> 00:11:03,029
unfortunately this means that many of

00:11:00,839 --> 00:11:06,180
the use cases that we were targeting for

00:11:03,029 --> 00:11:08,310
instance file final references they were

00:11:06,180 --> 00:11:09,960
basically prohibitively slow so let's

00:11:08,310 --> 00:11:12,440
say we want to find

00:11:09,960 --> 00:11:14,370
a certain definition in our code base

00:11:12,440 --> 00:11:16,410
how do we do that with the Scala

00:11:14,370 --> 00:11:18,360
compiler well we give it the entire

00:11:16,410 --> 00:11:21,060
Twitter source which is millions of

00:11:18,360 --> 00:11:23,750
lines of code we wait until it type

00:11:21,060 --> 00:11:26,970
checks stuff if it has enough RAM and

00:11:23,750 --> 00:11:30,600
you know if it has enough CPU time which

00:11:26,970 --> 00:11:33,300
is you know days guys and afterwards we

00:11:30,600 --> 00:11:36,209
traverse the result so clearly this is

00:11:33,300 --> 00:11:37,830
unacceptable which is why you know we

00:11:36,209 --> 00:11:39,690
had to give this up and unfortunately

00:11:37,830 --> 00:11:42,000
the tools that use compiler the Scala

00:11:39,690 --> 00:11:44,149
compiler internals like say enzyme or

00:11:42,000 --> 00:11:46,800
Scala D they have the same problems and

00:11:44,149 --> 00:11:48,480
they either have a roll their own

00:11:46,800 --> 00:11:50,940
infrastructure for example for indexing

00:11:48,480 --> 00:11:54,000
or they just give up and accept the

00:11:50,940 --> 00:11:58,260
limitations so that's that's the story

00:11:54,000 --> 00:12:00,149
with the Scala C API and to be complete

00:11:58,260 --> 00:12:00,990
to make sure that we're not reinventing

00:12:00,149 --> 00:12:02,730
the wheel

00:12:00,990 --> 00:12:04,980
we definitely looked into the

00:12:02,730 --> 00:12:08,490
developments in the re so even though

00:12:04,980 --> 00:12:10,170
daddy hasn't been released yet still we

00:12:08,490 --> 00:12:11,610
needed to try everything to avoid custom

00:12:10,170 --> 00:12:14,220
development because well custom

00:12:11,610 --> 00:12:16,279
development super expensive right so

00:12:14,220 --> 00:12:18,779
let's let's go through a brief overview

00:12:16,279 --> 00:12:21,360
since you guys are sitting here you

00:12:18,779 --> 00:12:24,240
probably attended the keynote that

00:12:21,360 --> 00:12:26,190
Martin gave yesterday and you know that

00:12:24,240 --> 00:12:29,760
Daddy is going to become the new Scala

00:12:26,190 --> 00:12:33,150
compiler sometimes in about two years if

00:12:29,760 --> 00:12:34,560
I recall the slides correctly and there

00:12:33,150 --> 00:12:36,360
is a dedicated the metaprogramming API

00:12:34,560 --> 00:12:39,029
in dot is something's shaping up and

00:12:36,360 --> 00:12:41,339
since Scala reflect this based on Scala

00:12:39,029 --> 00:12:42,959
compiler internals it was discarded

00:12:41,339 --> 00:12:46,230
because it's incompatible with Daddy

00:12:42,959 --> 00:12:48,150
compiler internals so you know long

00:12:46,230 --> 00:12:49,860
story short me tasty which is a

00:12:48,150 --> 00:12:52,770
serialization format for data compiler

00:12:49,860 --> 00:12:55,410
internals and currently it's used in the

00:12:52,770 --> 00:12:57,690
re ID as well as the upcoming macro

00:12:55,410 --> 00:12:59,790
system there was an awesome demo that

00:12:57,690 --> 00:13:01,440
Martin gave yesterday so guys if you are

00:12:59,790 --> 00:13:04,920
watching this and video please take a

00:13:01,440 --> 00:13:07,589
look that was really impressive and yeah

00:13:04,920 --> 00:13:09,209
so let's take a look again as I

00:13:07,589 --> 00:13:11,250
mentioned before we're willing to use

00:13:09,209 --> 00:13:14,070
really bleeding edge software as long as

00:13:11,250 --> 00:13:16,410
it's all our problems so before doing

00:13:14,070 --> 00:13:17,279
this talk yesterday when I was preparing

00:13:16,410 --> 00:13:19,890
I went ahead

00:13:17,279 --> 00:13:21,140
cloned the master of lamp EPFL daddy and

00:13:19,890 --> 00:13:23,800
just took a look

00:13:21,140 --> 00:13:25,959
it looks like the API for taste

00:13:23,800 --> 00:13:28,330
he lives in the Dahlia library in the

00:13:25,959 --> 00:13:31,330
file called tasty does color but it's

00:13:28,330 --> 00:13:34,089
arranged in a bit a bit unusual way so

00:13:31,330 --> 00:13:38,320
let me comment so instead of having case

00:13:34,089 --> 00:13:40,089
classes to model the language the API

00:13:38,320 --> 00:13:43,029
lives in an enclosing class called AC

00:13:40,089 --> 00:13:46,000
and those data structures they are

00:13:43,029 --> 00:13:47,980
encoded in abstract types extractors as

00:13:46,000 --> 00:13:49,600
well as you know this class tags so

00:13:47,980 --> 00:13:53,079
something that we extensively explored

00:13:49,600 --> 00:13:54,970
in Scala flag days so back then in Scala

00:13:53,079 --> 00:13:56,620
reflect why we did that because we

00:13:54,970 --> 00:13:58,300
needed basically one-to-one

00:13:56,620 --> 00:14:00,279
correspondence with compiler internals

00:13:58,300 --> 00:14:02,470
so thanks to that we can provide we

00:14:00,279 --> 00:14:05,200
don't need to define any data structures

00:14:02,470 --> 00:14:07,839
we just piggyback using the cake pattern

00:14:05,200 --> 00:14:09,579
on what the compiler has however in the

00:14:07,839 --> 00:14:11,680
implementation of tasty in value there

00:14:09,579 --> 00:14:14,470
is an abstraction layer behind between

00:14:11,680 --> 00:14:16,930
compiler internals and the API this is a

00:14:14,470 --> 00:14:19,329
really great improvement unfortunately

00:14:16,930 --> 00:14:21,579
some details of compiler internals they

00:14:19,329 --> 00:14:23,470
still leak so for instance these module

00:14:21,579 --> 00:14:26,860
classes that I mentioned before some

00:14:23,470 --> 00:14:28,660
other stuff they're still there but you

00:14:26,860 --> 00:14:32,130
know never mind that let's take a look

00:14:28,660 --> 00:14:35,649
how to use TST so what I did that I just

00:14:32,130 --> 00:14:38,260
did a text search over the data library

00:14:35,649 --> 00:14:39,910
and looked for methods or something that

00:14:38,260 --> 00:14:42,760
returns tasty so it looks like there's

00:14:39,910 --> 00:14:45,399
just one occurrence like that in the

00:14:42,760 --> 00:14:47,020
trade called universe so universe looks

00:14:45,399 --> 00:14:49,270
like it's a wrapper for something called

00:14:47,020 --> 00:14:51,490
tasty in the context I won't go into

00:14:49,270 --> 00:14:53,230
details but the thing is that again

00:14:51,490 --> 00:14:55,990
let's let's see what instantiate this

00:14:53,230 --> 00:14:58,079
universe and in the data library again

00:14:55,990 --> 00:15:02,050
there's just one usage which is a stub

00:14:58,079 --> 00:15:04,200
so that's curious now if we expand the

00:15:02,050 --> 00:15:07,120
search scope to the entire dota codebase

00:15:04,200 --> 00:15:08,740
we finally find an implementation which

00:15:07,120 --> 00:15:10,899
is called compilation universe and it

00:15:08,740 --> 00:15:12,399
leaves in the compiler source code so

00:15:10,899 --> 00:15:15,040
basically this is the only thing that

00:15:12,399 --> 00:15:16,690
implements tasty right now and in a way

00:15:15,040 --> 00:15:18,910
it's similar to the situation with Scala

00:15:16,690 --> 00:15:20,589
reflect where the compiler was basically

00:15:18,910 --> 00:15:23,980
the only implementation of its

00:15:20,589 --> 00:15:28,060
metaprogramming API so just to sum it up

00:15:23,980 --> 00:15:30,640
what we've gleaned from dally master it

00:15:28,060 --> 00:15:32,860
looks like taystee is similar to score

00:15:30,640 --> 00:15:36,130
effect at this point but we implemented

00:15:32,860 --> 00:15:37,810
for lolly so remember these these

00:15:36,130 --> 00:15:40,060
blockers that

00:15:37,810 --> 00:15:41,940
but were rising for our project when we

00:15:40,060 --> 00:15:46,000
tried to use the Scala reflect and

00:15:41,940 --> 00:15:48,010
they're still they still apply so the

00:15:46,000 --> 00:15:50,260
Tastee is still based on compiler

00:15:48,010 --> 00:15:52,240
internals it's a bit under documented

00:15:50,260 --> 00:15:54,100
but you know the main technical blocker

00:15:52,240 --> 00:15:56,950
really is that it requires a compiler

00:15:54,100 --> 00:15:58,180
instance we definitely need to keep in

00:15:56,950 --> 00:16:00,370
mind that this is pre-release software

00:15:58,180 --> 00:16:01,870
as I said before the release date is

00:16:00,370 --> 00:16:04,240
like today two years in the future

00:16:01,870 --> 00:16:07,990
roughly according to the official talks

00:16:04,240 --> 00:16:09,760
lots of things may change however for

00:16:07,990 --> 00:16:11,860
our project what was relevant is that

00:16:09,760 --> 00:16:15,520
our customers need semantic tools right

00:16:11,860 --> 00:16:18,100
now or even better yesterday so we had

00:16:15,520 --> 00:16:21,280
to do something so we had to roll our

00:16:18,100 --> 00:16:23,650
own semantic api's as I mentioned at the

00:16:21,280 --> 00:16:26,530
beginning of the talk we did this work

00:16:23,650 --> 00:16:27,880
as part of Scala meta which is an open

00:16:26,530 --> 00:16:29,860
source meta programming library for

00:16:27,880 --> 00:16:32,590
Scala that we started like five years

00:16:29,860 --> 00:16:35,830
ago during my time at EPFL back then it

00:16:32,590 --> 00:16:38,650
was just syntactic api's just a parser

00:16:35,830 --> 00:16:40,570
and some other stuff but the

00:16:38,650 --> 00:16:42,190
characteristic thing about scala matt is

00:16:40,570 --> 00:16:45,100
that it's focused on two writers as

00:16:42,190 --> 00:16:47,380
opposed on what the compiler exposes and

00:16:45,100 --> 00:16:50,860
it turns out that this niche was quite

00:16:47,380 --> 00:16:52,180
useful and five years later scala meta

00:16:50,860 --> 00:16:55,060
is like an umbrella project an

00:16:52,180 --> 00:16:57,160
organization that accumulates more than

00:16:55,060 --> 00:17:00,310
ten projects that add up to more than

00:16:57,160 --> 00:17:02,950
ten thousand commits by more than 200

00:17:00,310 --> 00:17:05,199
open-source contributors and thank

00:17:02,950 --> 00:17:07,240
because of the strategic importance of

00:17:05,199 --> 00:17:09,579
this initiative both twitter and Scala

00:17:07,240 --> 00:17:11,339
center fund full-time developers who

00:17:09,579 --> 00:17:15,370
work in Scala met and related projects

00:17:11,339 --> 00:17:18,480
so now how we solve this particular

00:17:15,370 --> 00:17:20,650
problem at hand semantic tools right

00:17:18,480 --> 00:17:23,050
towards that end we design something

00:17:20,650 --> 00:17:24,939
called semantic DB which is a data model

00:17:23,050 --> 00:17:26,770
for semantic information about programs

00:17:24,939 --> 00:17:29,800
in Scala and other languages for

00:17:26,770 --> 00:17:32,610
instance we support Java the data model

00:17:29,800 --> 00:17:35,680
does and our code generators do

00:17:32,610 --> 00:17:36,510
partially and the key thing is just

00:17:35,680 --> 00:17:39,550
about

00:17:36,510 --> 00:17:41,440
just like Scala meta semantics DB is

00:17:39,550 --> 00:17:44,290
focused on what two writers need from

00:17:41,440 --> 00:17:46,720
the compiler not what's convenient to

00:17:44,290 --> 00:17:49,600
expose like it was in scala reflex for

00:17:46,720 --> 00:17:50,770
instance and this is a super tricky

00:17:49,600 --> 00:17:52,090
business right because

00:17:50,770 --> 00:17:53,650
what do right there's need how do we

00:17:52,090 --> 00:17:55,240
figure this out because once we have a

00:17:53,650 --> 00:17:57,430
compiler we can just expose its stuff

00:17:55,240 --> 00:17:59,560
and it's easy but here it's it's a bit

00:17:57,430 --> 00:18:01,780
of a different problem statement and as

00:17:59,560 --> 00:18:04,840
a result this required collaboration

00:18:01,780 --> 00:18:07,300
between a compiler expert myself I did

00:18:04,840 --> 00:18:10,000
the PhD on that stuff and a tool expert

00:18:07,300 --> 00:18:12,940
all of the guy who I mentioned before

00:18:10,000 --> 00:18:16,390
who works at the Scala Center so let's

00:18:12,940 --> 00:18:19,060
see what we've come up with here on the

00:18:16,390 --> 00:18:21,520
slide you see a brought above

00:18:19,060 --> 00:18:24,520
instantiation of central data structure

00:18:21,520 --> 00:18:25,930
in our model called text document text

00:18:24,520 --> 00:18:28,660
document contains semantic information

00:18:25,930 --> 00:18:30,790
about the source file so to speak so

00:18:28,660 --> 00:18:34,300
source file I can be specified by either

00:18:30,790 --> 00:18:36,640
a URI or its text just you know embedded

00:18:34,300 --> 00:18:39,430
the source code in addition to those

00:18:36,640 --> 00:18:41,260
attributes text document contains some

00:18:39,430 --> 00:18:42,910
more like the version of the schema for

00:18:41,260 --> 00:18:45,490
instance semantic DB v3 which is the

00:18:42,910 --> 00:18:48,910
current version and the language we

00:18:45,490 --> 00:18:51,010
should be Scala or Java and the most

00:18:48,910 --> 00:18:52,690
important the most interesting thing for

00:18:51,010 --> 00:18:54,760
two writers definitely happened in

00:18:52,690 --> 00:18:58,060
something called sections symbols

00:18:54,760 --> 00:19:00,670
occurrences which hosts the parts of the

00:18:58,060 --> 00:19:01,350
symbol table compiler messages and so on

00:19:00,670 --> 00:19:04,330
and so forth

00:19:01,350 --> 00:19:06,310
let's take a quick example and try to

00:19:04,330 --> 00:19:08,620
obtain a semantic DB payload for a hello

00:19:06,310 --> 00:19:10,810
world program so here we have an object

00:19:08,620 --> 00:19:15,730
with the usual main method in the print

00:19:10,810 --> 00:19:18,850
way and nothing else to get to semantic

00:19:15,730 --> 00:19:21,760
DBS we need to use our compiler plugin

00:19:18,850 --> 00:19:23,710
for Scala C and so we just you know

00:19:21,760 --> 00:19:27,070
invoke Scala C as usual but passing the

00:19:23,710 --> 00:19:28,660
compiler plug-in as well and in addition

00:19:27,070 --> 00:19:31,030
to that in addition to that way we also

00:19:28,660 --> 00:19:33,850
expose a CLI tool which ships together

00:19:31,030 --> 00:19:36,310
with Scala meta that wraps this process

00:19:33,850 --> 00:19:38,830
so that you can say meta c tested Scala

00:19:36,310 --> 00:19:40,800
you know it says the same as Scala see

00:19:38,830 --> 00:19:43,870
there's the scholar but for Scala meta

00:19:40,800 --> 00:19:46,810
after either of those invitations have

00:19:43,870 --> 00:19:50,050
been completed we see additional files

00:19:46,810 --> 00:19:51,850
in addition to class files right and so

00:19:50,050 --> 00:19:54,310
for every Scala file that was in the

00:19:51,850 --> 00:19:57,190
project you will have a semantic DB file

00:19:54,310 --> 00:20:00,220
testdisk all the semantics DB here and a

00:19:57,190 --> 00:20:02,740
special meta in folder if we try to just

00:20:00,220 --> 00:20:04,540
you know cat the file or xxd we will see

00:20:02,740 --> 00:20:08,980
that it's kind of a mixed

00:20:04,540 --> 00:20:11,170
binary stuff and symbols it's weird but

00:20:08,980 --> 00:20:13,240
you know that's all right because it's

00:20:11,170 --> 00:20:15,700
encoded in protobuf and protobuf is a

00:20:13,240 --> 00:20:19,420
binary format so as I mentioned before

00:20:15,700 --> 00:20:21,580
we we provide CLI tools in in our

00:20:19,420 --> 00:20:23,830
distribution and there is a tool to take

00:20:21,580 --> 00:20:26,110
a look at those semantic GB payloads

00:20:23,830 --> 00:20:29,260
called meta beam it's like Java P or

00:20:26,110 --> 00:20:31,300
Scala P P stands for printer if we

00:20:29,260 --> 00:20:32,950
inspect this particular file or this

00:20:31,300 --> 00:20:35,880
particular directory which is why I said

00:20:32,950 --> 00:20:38,530
meta P dot then it traverses everything

00:20:35,880 --> 00:20:41,200
we see the attributes so as I mentioned

00:20:38,530 --> 00:20:43,720
semantic DB v3 the URI is just test dot

00:20:41,200 --> 00:20:45,520
scala as well as the section so let's

00:20:43,720 --> 00:20:49,150
take a look it's where the most

00:20:45,520 --> 00:20:51,790
interesting stuff happens so the symbols

00:20:49,150 --> 00:20:55,270
section it's like a symbol table in the

00:20:51,790 --> 00:20:58,060
compiler what it does for every

00:20:55,270 --> 00:21:00,100
definition in the file that we've been

00:20:58,060 --> 00:21:02,740
compiling it stores its signature

00:21:00,100 --> 00:21:04,270
various metadata about it like flags for

00:21:02,740 --> 00:21:07,150
instance final for object so the

00:21:04,270 --> 00:21:09,280
signature it includes base classes and

00:21:07,150 --> 00:21:13,120
declarations we can see that for object

00:21:09,280 --> 00:21:15,310
test for methods it's the entire

00:21:13,120 --> 00:21:18,400
parameters parameter types and return

00:21:15,310 --> 00:21:20,350
type thing and so on so forth so that's

00:21:18,400 --> 00:21:23,260
symbols now let's take a look at the

00:21:20,350 --> 00:21:25,120
currencies what the currencies do for

00:21:23,260 --> 00:21:26,890
every identifier in the problem that

00:21:25,120 --> 00:21:30,430
we've been compiling like you know

00:21:26,890 --> 00:21:34,090
object tests def Maine rx on so forth we

00:21:30,430 --> 00:21:36,490
have its range 0 based which is why you

00:21:34,090 --> 00:21:39,190
know test is on line zero as well as a

00:21:36,490 --> 00:21:40,690
symbol which you can treat as a unique

00:21:39,190 --> 00:21:44,170
identifier of the definition that

00:21:40,690 --> 00:21:46,600
identifier refers to so we can see for

00:21:44,170 --> 00:21:47,920
instance that an array of string that's

00:21:46,600 --> 00:21:50,620
part of the standard signature for a

00:21:47,920 --> 00:21:53,530
main method it points to a skull array

00:21:50,620 --> 00:21:55,570
and scallop read of string and print

00:21:53,530 --> 00:21:58,630
line it's basically the first overload

00:21:55,570 --> 00:22:00,640
of print line in the pre def object so

00:21:58,630 --> 00:22:02,740
stuff like that you can probably already

00:22:00,640 --> 00:22:07,210
see how it's useful for go to definition

00:22:02,740 --> 00:22:08,890
or find all references now this was just

00:22:07,210 --> 00:22:11,050
a glimpse so we definitely don't have

00:22:08,890 --> 00:22:14,440
time to go into details in this talk but

00:22:11,050 --> 00:22:16,780
luckily all of the co-author of this

00:22:14,440 --> 00:22:19,209
entire thing he gave a talk earlier this

00:22:16,780 --> 00:22:22,089
year at Scala sphere in crime

00:22:19,209 --> 00:22:24,909
so just check out the the thing for

00:22:22,089 --> 00:22:27,759
details it has many more and much better

00:22:24,909 --> 00:22:29,259
examples for semantic DB payloads as

00:22:27,759 --> 00:22:31,809
well as the introduction to the CLI

00:22:29,259 --> 00:22:35,079
utilities so just medicean metope it's

00:22:31,809 --> 00:22:36,969
not everything also an overview of tools

00:22:35,079 --> 00:22:39,489
which are based on semantic DB so quite

00:22:36,969 --> 00:22:41,619
quite a good talk please take a look if

00:22:39,489 --> 00:22:44,589
you want you know an introduction to

00:22:41,619 --> 00:22:47,489
this entire API but now we will move on

00:22:44,589 --> 00:22:51,309
since our problem statement was about

00:22:47,489 --> 00:22:54,309
improving the developer workflow with

00:22:51,309 --> 00:22:57,519
semantic tools let's see how semantic DB

00:22:54,309 --> 00:22:59,499
helps with that to begin the discussion

00:22:57,519 --> 00:23:01,209
to see some examples I'd like to

00:22:59,499 --> 00:23:02,829
piggyback on open source tools that all

00:23:01,209 --> 00:23:04,739
have hacked-up together with the

00:23:02,829 --> 00:23:09,069
community of open source contributors so

00:23:04,739 --> 00:23:11,829
there is a meta doc metals and Scala fix

00:23:09,069 --> 00:23:17,199
and it looks like I have enough time to

00:23:11,829 --> 00:23:19,029
just show you guys some live demos let's

00:23:17,199 --> 00:23:20,739
hope the internet works and we will

00:23:19,029 --> 00:23:23,859
start with meta doc which is something

00:23:20,739 --> 00:23:26,019
that was created by Olaf and also Yanis

00:23:23,859 --> 00:23:28,359
Fonseca and some other open source

00:23:26,019 --> 00:23:31,269
contributors on this column at a website

00:23:28,359 --> 00:23:34,809
we have this sneaky URL just Scala meta

00:23:31,269 --> 00:23:36,789
dot org slash meta doc which shows the

00:23:34,809 --> 00:23:38,529
web application so as you can see this

00:23:36,789 --> 00:23:40,659
is some sort of an editor will well it's

00:23:38,529 --> 00:23:42,639
not really an editor it's read-only but

00:23:40,659 --> 00:23:46,389
you know it's it's kind of a pretty

00:23:42,639 --> 00:23:49,149
thing so what's that how do we get to

00:23:46,389 --> 00:23:51,039
that method doc is a CLI tool which

00:23:49,149 --> 00:23:53,739
takes semantic dps on source code and

00:23:51,039 --> 00:23:55,059
then produces the static website so this

00:23:53,739 --> 00:23:57,489
website is powered by something called

00:23:55,059 --> 00:24:01,059
Monaco which is a crucial component of

00:23:57,489 --> 00:24:02,949
BS code which is basically something

00:24:01,059 --> 00:24:05,859
that supports LSP language server

00:24:02,949 --> 00:24:07,509
protocol but in the browser so long

00:24:05,859 --> 00:24:10,389
story short without getting into too

00:24:07,509 --> 00:24:12,219
many technical details we can see that

00:24:10,389 --> 00:24:14,649
there's some functionality available

00:24:12,219 --> 00:24:16,119
here that you expect from IDs and that

00:24:14,649 --> 00:24:18,579
we wanted to achieve so for instance

00:24:16,119 --> 00:24:20,619
final references you do that and see how

00:24:18,579 --> 00:24:23,409
fast it is basically instantaneous

00:24:20,619 --> 00:24:25,509
that's because there are indices in

00:24:23,409 --> 00:24:27,879
memory and you know it's not because

00:24:25,509 --> 00:24:29,469
it's reg access so really if you have

00:24:27,879 --> 00:24:31,470
chunk stream in your comments something

00:24:29,469 --> 00:24:36,270
like this it wouldn't be

00:24:31,470 --> 00:24:39,780
here now how has a semantic DB been able

00:24:36,270 --> 00:24:41,730
to help us build this tool there's no

00:24:39,780 --> 00:24:43,559
there are multiple answers well first of

00:24:41,730 --> 00:24:46,740
all semantic DB is really independent of

00:24:43,559 --> 00:24:48,960
compilers which means that this method

00:24:46,740 --> 00:24:50,159
doc thing it only needs semantic DB

00:24:48,960 --> 00:24:52,110
files it does not need a running

00:24:50,159 --> 00:24:54,390
compiler as a result you just produce

00:24:52,110 --> 00:24:56,460
those files you store them somewhere we

00:24:54,390 --> 00:24:59,760
don't care just give us give us to them

00:24:56,460 --> 00:25:01,760
give this files to us and secondly an

00:24:59,760 --> 00:25:04,710
interesting thing about Scala meta and

00:25:01,760 --> 00:25:06,120
it's it's kind of a good thing about

00:25:04,710 --> 00:25:09,600
having a simple data model

00:25:06,120 --> 00:25:11,159
no cake patterns no nothing is that this

00:25:09,600 --> 00:25:14,090
thing trivially crossed compiles to

00:25:11,159 --> 00:25:17,640
Scala GS or Scala native so in this case

00:25:14,090 --> 00:25:20,760
this thing is running in a browser and a

00:25:17,640 --> 00:25:23,340
scholar J's program it can use semantics

00:25:20,760 --> 00:25:25,280
DB bindings brought about by an ins to

00:25:23,340 --> 00:25:28,020
load semantics to be payloads right here

00:25:25,280 --> 00:25:29,760
which i think is pretty amazing when i

00:25:28,020 --> 00:25:32,340
first showed it to me I was like whoa

00:25:29,760 --> 00:25:35,309
all of what did you do oh my god so

00:25:32,340 --> 00:25:37,860
that's quite neat and you can see this

00:25:35,309 --> 00:25:39,860
this is a great experiment that

00:25:37,860 --> 00:25:42,960
partially solves the cold Rosen problem

00:25:39,860 --> 00:25:45,870
awesome now on to the next cool thing

00:25:42,960 --> 00:25:49,799
which is called metals for Scala meta

00:25:45,870 --> 00:25:51,539
language server metals is another

00:25:49,799 --> 00:25:55,950
project that's part of the Scala meta

00:25:51,539 --> 00:25:57,870
organization it's it's an effort again

00:25:55,950 --> 00:25:59,750
an open-source effort and major

00:25:57,870 --> 00:26:03,380
contributions were done by Olaf

00:25:59,750 --> 00:26:06,630
Gabriella petronella and Alexia lurkin

00:26:03,380 --> 00:26:08,130
very interesting work guys and now I'm

00:26:06,630 --> 00:26:10,260
just going to show some slides that Olaf

00:26:08,130 --> 00:26:11,730
prepared for one of his talks you should

00:26:10,260 --> 00:26:13,940
really watch share all the stocks it's

00:26:11,730 --> 00:26:18,380
it's quite amazing what he pulls off

00:26:13,940 --> 00:26:18,380
let's see whether I can remember the URL

00:26:24,289 --> 00:26:30,480
yes yes that was good you know I cleaned

00:26:28,409 --> 00:26:31,830
the browser history in order to not be

00:26:30,480 --> 00:26:33,990
embarrassed by everything that would

00:26:31,830 --> 00:26:35,669
show up and now I had to remember this

00:26:33,990 --> 00:26:38,700
URL oh my god is just Wow

00:26:35,669 --> 00:26:40,259
so anyway metals is is the foundation

00:26:38,700 --> 00:26:41,429
for an IDE it's an implementation of

00:26:40,259 --> 00:26:43,409
something that's called the language

00:26:41,429 --> 00:26:44,789
server protocol and it's based on

00:26:43,409 --> 00:26:47,730
semantic GD as well as other

00:26:44,789 --> 00:26:51,119
technologies to achieve id experience

00:26:47,730 --> 00:26:52,830
it's a work in progress so basically you

00:26:51,119 --> 00:26:57,149
should not be using it right now but

00:26:52,830 --> 00:26:58,289
it's growing steadily right now I'm just

00:26:57,149 --> 00:27:01,470
going to show some of the features that

00:26:58,289 --> 00:27:03,269
are available in metals so first of all

00:27:01,470 --> 00:27:05,070
metals is integrated with Scala fix

00:27:03,269 --> 00:27:07,769
another tool that I'll be covering

00:27:05,070 --> 00:27:10,200
before Scala fix uses semantics DB to

00:27:07,769 --> 00:27:12,690
power semantics refactorings so in Scala

00:27:10,200 --> 00:27:14,999
fix you can write custom rules where you

00:27:12,690 --> 00:27:16,590
ask hey semantics DB what's the symbol

00:27:14,999 --> 00:27:18,869
for this gap thing

00:27:16,590 --> 00:27:20,009
so is this an option that get something

00:27:18,869 --> 00:27:22,139
that I mentioned before or it's

00:27:20,009 --> 00:27:24,629
something else and thanks to the

00:27:22,139 --> 00:27:26,190
integration because metals is based on

00:27:24,629 --> 00:27:28,289
semantics DB is car fix is based on

00:27:26,190 --> 00:27:29,659
semantic DB these guys are able to pass

00:27:28,289 --> 00:27:31,590
these payloads around

00:27:29,659 --> 00:27:36,629
achieving smooth integration between

00:27:31,590 --> 00:27:38,940
tools another thing is also something

00:27:36,629 --> 00:27:42,029
powered by Scala fix you can have

00:27:38,940 --> 00:27:43,710
something called code actions in LSP so

00:27:42,029 --> 00:27:49,499
basically here we communicate with Scala

00:27:43,710 --> 00:27:53,220
fix and it it goes back to to the editor

00:27:49,499 --> 00:27:56,490
and returns the diff so that you can do

00:27:53,220 --> 00:27:59,429
things like remove unused imports also

00:27:56,490 --> 00:28:00,960
powered by semantic DB there's lots of

00:27:59,429 --> 00:28:03,539
lots of stuff for instance integration

00:28:00,960 --> 00:28:06,080
with Scala fmt and I invite you guys to

00:28:03,539 --> 00:28:09,450
take a closer look later after the talk

00:28:06,080 --> 00:28:11,369
but just to sum it up how semantics DB

00:28:09,450 --> 00:28:13,769
has been useful in this particular case

00:28:11,369 --> 00:28:15,179
thanks to semantics DB is possible to

00:28:13,769 --> 00:28:17,159
accumulate multiple sources of

00:28:15,179 --> 00:28:18,539
information about programs the

00:28:17,159 --> 00:28:20,309
incomplete information that the compiler

00:28:18,539 --> 00:28:22,980
has about what you're typing about you

00:28:20,309 --> 00:28:24,690
know half broken code the the stuff from

00:28:22,980 --> 00:28:29,190
the classpath you know something that's

00:28:24,690 --> 00:28:32,460
it's called indexing and IntelliJ and it

00:28:29,190 --> 00:28:35,309
all goes into the same data schema which

00:28:32,460 --> 00:28:38,100
allows for really easy in Dickson

00:28:35,309 --> 00:28:42,480
regardless of wherever this amount

00:28:38,100 --> 00:28:46,110
information comes from okay so back to

00:28:42,480 --> 00:28:49,140
the slides now I just need to have this

00:28:46,110 --> 00:28:55,770
thing disappear please do please do oh

00:28:49,140 --> 00:28:58,980
no this is discard okay I think now this

00:28:55,770 --> 00:29:01,380
thing should go away forever yes anyway

00:28:58,980 --> 00:29:02,910
finally Scala fix something that I

00:29:01,380 --> 00:29:05,510
mentioned before this is a little and

00:29:02,910 --> 00:29:07,559
refactoring tool developed by Olaf and

00:29:05,510 --> 00:29:10,950
open-source contributors this is all

00:29:07,559 --> 00:29:14,220
project with the Scala Center and thanks

00:29:10,950 --> 00:29:16,890
to Symantec DB here we can write custom

00:29:14,220 --> 00:29:19,380
rewrites that use information about code

00:29:16,890 --> 00:29:22,650
for instance members types of

00:29:19,380 --> 00:29:24,510
expressions to do well whatever you want

00:29:22,650 --> 00:29:27,510
whatever code devotion you would like to

00:29:24,510 --> 00:29:29,820
implement now this was a good showcase

00:29:27,510 --> 00:29:31,559
of the power of semantic d-beam thanks

00:29:29,820 --> 00:29:34,710
to the fact that semantic DB has a

00:29:31,559 --> 00:29:36,419
simple schema it can be immediately

00:29:34,710 --> 00:29:38,940
useful you don't need a running compiler

00:29:36,419 --> 00:29:41,039
we just need protobuf bindings and this

00:29:38,940 --> 00:29:43,260
is it and thanks to the fact that you

00:29:41,039 --> 00:29:45,870
don't need a running compiler Buechel

00:29:43,260 --> 00:29:47,730
you can also index stuff and make

00:29:45,870 --> 00:29:49,679
semantic information available very very

00:29:47,730 --> 00:29:51,630
quickly which is critical not just for

00:29:49,679 --> 00:29:54,630
projects that have millions of lines of

00:29:51,630 --> 00:29:56,130
code like our code base but also for

00:29:54,630 --> 00:29:58,049
medium-sized projects even if you have

00:29:56,130 --> 00:29:59,360
ten key lines of code how do you do find

00:29:58,049 --> 00:30:03,120
all references with the Scala compiler

00:29:59,360 --> 00:30:04,350
this is an unclear problem so some of

00:30:03,120 --> 00:30:10,830
these tools some of these open source

00:30:04,350 --> 00:30:13,980
tools were using internally and also we

00:30:10,830 --> 00:30:15,750
built a little bit more I wouldn't be

00:30:13,980 --> 00:30:19,860
able to do demos because you know how do

00:30:15,750 --> 00:30:23,220
probably show call source code in a talk

00:30:19,860 --> 00:30:25,650
but I'll definitely explain how we how

00:30:23,220 --> 00:30:26,970
we built infrastructure for that so

00:30:25,650 --> 00:30:30,720
first of all one of the good things

00:30:26,970 --> 00:30:32,280
about having a closed codebase having a

00:30:30,720 --> 00:30:35,400
mono repo is that we can have

00:30:32,280 --> 00:30:36,360
company-wide things so one thing that I

00:30:35,400 --> 00:30:39,270
would like to talk about is a

00:30:36,360 --> 00:30:41,549
company-wide semantic index so we can

00:30:39,270 --> 00:30:44,700
take all semantic DB payloads we should

00:30:41,549 --> 00:30:46,890
just you know case classes in the IMP

00:30:44,700 --> 00:30:48,419
wrote above bindings and then we can

00:30:46,890 --> 00:30:52,050
index them so that's that's one

00:30:48,419 --> 00:30:53,400
experiment that we did last year we took

00:30:52,050 --> 00:30:55,350
all the information about our source

00:30:53,400 --> 00:30:57,440
code all those millions of lines of code

00:30:55,350 --> 00:31:00,750
and then put it into an SQLite database

00:30:57,440 --> 00:31:02,310
so no fancy you know distributed

00:31:00,750 --> 00:31:06,210
key-value stores or anything just you

00:31:02,310 --> 00:31:08,280
know an SQLite database and surprisingly

00:31:06,210 --> 00:31:10,530
it was just a few gigabytes I was like

00:31:08,280 --> 00:31:12,150
well this cannot be what do you mean you

00:31:10,530 --> 00:31:14,370
take ten millions of lines of code and

00:31:12,150 --> 00:31:16,590
it's just a couple of gigabytes and then

00:31:14,370 --> 00:31:19,170
you can query this with single or double

00:31:16,590 --> 00:31:22,110
digit response times wow this cannot be

00:31:19,170 --> 00:31:23,340
but well apparently it is so just just

00:31:22,110 --> 00:31:25,500
to normalize the results of the

00:31:23,340 --> 00:31:28,590
experiments that we did on open source

00:31:25,500 --> 00:31:30,570
code bases like the community build so

00:31:28,590 --> 00:31:31,890
for every million lines of code we need

00:31:30,570 --> 00:31:35,100
approximately you know five hundred

00:31:31,890 --> 00:31:38,010
megabytes in this SQL SQL format and

00:31:35,100 --> 00:31:39,720
then this includes the indexes which

00:31:38,010 --> 00:31:41,850
means that queries like final references

00:31:39,720 --> 00:31:44,580
go to definition they become

00:31:41,850 --> 00:31:46,380
instantaneous basically well when I'm

00:31:44,580 --> 00:31:48,750
talking SQLite this is these are our

00:31:46,380 --> 00:31:49,830
open source experiments internally at

00:31:48,750 --> 00:31:51,900
Twitter we were using a different

00:31:49,830 --> 00:31:52,910
storage technology but you know similar

00:31:51,900 --> 00:31:56,370
characteristics

00:31:52,910 --> 00:31:57,930
now there's another cool thing that

00:31:56,370 --> 00:31:59,070
we've been able to build on top of this

00:31:57,930 --> 00:32:00,980
company-wide stuff

00:31:59,070 --> 00:32:03,510
it's called company-wide language server

00:32:00,980 --> 00:32:07,530
so basically you take the semantic index

00:32:03,510 --> 00:32:09,780
and then you expose its data via LSB

00:32:07,530 --> 00:32:11,310
so LSP is a great initiative in the

00:32:09,780 --> 00:32:15,000
sense that lots of editors supported

00:32:11,310 --> 00:32:16,620
it's well understood and so how about we

00:32:15,000 --> 00:32:19,280
just expose LSP as opposed to you know a

00:32:16,620 --> 00:32:23,070
custom relational or whatever database

00:32:19,280 --> 00:32:25,920
our experimental implementation it just

00:32:23,070 --> 00:32:28,260
goes to that database and implements

00:32:25,920 --> 00:32:31,230
just the basic functionality necessary

00:32:28,260 --> 00:32:33,570
for you know the the basic deliverable

00:32:31,230 --> 00:32:35,820
there is text document definition this

00:32:33,570 --> 00:32:37,500
is a method in the OSP protocol like go

00:32:35,820 --> 00:32:41,970
to definition and text document

00:32:37,500 --> 00:32:44,670
references I find all usages so that's

00:32:41,970 --> 00:32:47,670
quite neat to be able at anytime to

00:32:44,670 --> 00:32:49,770
reference semantic information about the

00:32:47,670 --> 00:32:51,660
entire code base in the company so I

00:32:49,770 --> 00:32:53,670
mean it was a great research problem it

00:32:51,660 --> 00:32:56,760
was a great to work on it and what's

00:32:53,670 --> 00:33:00,600
even better is that it's useful for for

00:32:56,760 --> 00:33:03,960
our customers but these users of scholar

00:33:00,600 --> 00:33:05,980
programmers at Twitter now let's see how

00:33:03,960 --> 00:33:09,520
these infrastructural pieces

00:33:05,980 --> 00:33:11,290
together and how they help us achieve

00:33:09,520 --> 00:33:13,809
experimental solutions to the original

00:33:11,290 --> 00:33:16,179
goals why our team was funded in the

00:33:13,809 --> 00:33:19,660
first place so first of all for code

00:33:16,179 --> 00:33:22,600
brausen we have an experimental IntelliJ

00:33:19,660 --> 00:33:25,480
plugin so it uses this company-wide

00:33:22,600 --> 00:33:27,400
language server implement custom go to

00:33:25,480 --> 00:33:30,720
definition and find the find references

00:33:27,400 --> 00:33:33,010
menu items you you really open IntelliJ

00:33:30,720 --> 00:33:35,799
you don't have to open the entire source

00:33:33,010 --> 00:33:37,990
code doesn't matter and then you do a

00:33:35,799 --> 00:33:40,390
right click and here we go you just have

00:33:37,990 --> 00:33:42,820
a list of references and it works across

00:33:40,390 --> 00:33:46,809
the entire code base granted of course

00:33:42,820 --> 00:33:49,660
it has been indexed so definitely there

00:33:46,809 --> 00:33:52,030
is a research question for future work

00:33:49,660 --> 00:33:54,040
how do you make sure that indexes are

00:33:52,030 --> 00:33:55,510
generated fast enough how do you make

00:33:54,040 --> 00:33:57,280
sure that they're synchronized with your

00:33:55,510 --> 00:33:58,660
local state for instance if you're

00:33:57,280 --> 00:34:00,850
developing you know locally in a branch

00:33:58,660 --> 00:34:02,650
but the current results they are already

00:34:00,850 --> 00:34:04,270
much better than the state of the art

00:34:02,650 --> 00:34:08,409
and the state of the art is basically

00:34:04,270 --> 00:34:09,909
textual search so that's quite neat now

00:34:08,409 --> 00:34:11,889
on to the next thing code review I

00:34:09,909 --> 00:34:13,780
mentioned before that were using

00:34:11,889 --> 00:34:15,810
fabricator and fabricator has something

00:34:13,780 --> 00:34:18,690
called diffusion external symbols source

00:34:15,810 --> 00:34:21,340
which is a long-winded way of saying

00:34:18,690 --> 00:34:25,649
well something that can reply to go to

00:34:21,340 --> 00:34:28,440
definition so we upgraded this thing

00:34:25,649 --> 00:34:32,379
which was supported in PHP and Python

00:34:28,440 --> 00:34:34,270
we asked upstream to integrate this into

00:34:32,379 --> 00:34:36,820
into the main product so now it takes

00:34:34,270 --> 00:34:38,530
into account source positions and now

00:34:36,820 --> 00:34:40,960
that we have source positions and file

00:34:38,530 --> 00:34:44,730
names we can just go to our LSB server

00:34:40,960 --> 00:34:48,190
and basket for information about symbols

00:34:44,730 --> 00:34:50,619
so as a result in code reviews if

00:34:48,190 --> 00:34:53,379
something has been indexed by our index

00:34:50,619 --> 00:34:57,510
and exposed by a language server we can

00:34:53,379 --> 00:35:01,980
just use hyperlinks to navigate there

00:34:57,510 --> 00:35:04,960
finally the final bit called evolution I

00:35:01,980 --> 00:35:07,390
refactorings internally we have

00:35:04,960 --> 00:35:09,960
integrated scoff isn't our workflow it's

00:35:07,390 --> 00:35:12,160
integrated into pants our build tool and

00:35:09,960 --> 00:35:13,780
were basically closely following the

00:35:12,160 --> 00:35:15,640
cutting edge milestone builds

00:35:13,780 --> 00:35:17,380
whenever all off pushes a new release

00:35:15,640 --> 00:35:19,589
were just you know we need to jump in on

00:35:17,380 --> 00:35:21,749
it which is quite neat

00:35:19,589 --> 00:35:24,420
pace of development and useful features

00:35:21,749 --> 00:35:27,390
that they're coming up recently they've

00:35:24,420 --> 00:35:29,009
been amazing one adjustment that we had

00:35:27,390 --> 00:35:32,069
to make to scholar fix which were using

00:35:29,009 --> 00:35:34,289
as is otherwise is integrating it with

00:35:32,069 --> 00:35:36,539
our build cluster as I mentioned before

00:35:34,289 --> 00:35:39,509
lots of code if you were to just build

00:35:36,539 --> 00:35:41,640
this code with our compiler plugin on on

00:35:39,509 --> 00:35:44,189
our laptops it just wouldn't finish in

00:35:41,640 --> 00:35:47,039
reasonable time so we have integrated

00:35:44,189 --> 00:35:50,089
the Scala fix into our infrastructure so

00:35:47,039 --> 00:35:51,989
that you can spawn distributed jobs

00:35:50,089 --> 00:35:54,869
multiple hundreds of thousands of

00:35:51,989 --> 00:35:57,329
workers and then obtain a git diff at

00:35:54,869 --> 00:36:00,089
the very end I won't be going into

00:35:57,329 --> 00:36:02,219
details here to the time for questions

00:36:00,089 --> 00:36:03,509
but there's been a talk by a member of

00:36:02,219 --> 00:36:05,880
our team uma

00:36:03,509 --> 00:36:08,039
she's been presenting that tableau

00:36:05,880 --> 00:36:10,380
summit in Boston earlier is here called

00:36:08,039 --> 00:36:12,420
Scala fix a Twitter scale that provides

00:36:10,380 --> 00:36:17,430
more information about Scala fix in

00:36:12,420 --> 00:36:20,819
general and how our isn't at Twitter all

00:36:17,430 --> 00:36:24,329
right time to wrap up what we've seen

00:36:20,819 --> 00:36:27,449
today is that a year ago we founded the

00:36:24,329 --> 00:36:29,969
advance scout tools team short for a s

00:36:27,449 --> 00:36:32,640
team with a concrete goal to improve

00:36:29,969 --> 00:36:34,949
code browsing code review and code

00:36:32,640 --> 00:36:36,449
evolution in our workflow and also

00:36:34,949 --> 00:36:38,819
potentially contribute our improvements

00:36:36,449 --> 00:36:41,999
to the open source if they end up being

00:36:38,819 --> 00:36:44,640
useful so as a result we I believe we do

00:36:41,999 --> 00:36:46,859
have a useful artifact semantic DB which

00:36:44,640 --> 00:36:48,900
is a data format for semantic

00:36:46,859 --> 00:36:50,549
information at all of at night developed

00:36:48,900 --> 00:36:52,979
together thanks to the funding from

00:36:50,549 --> 00:36:55,890
Twitter and Scala Center and on top of

00:36:52,979 --> 00:36:57,569
this infrastructure internal a Twitter

00:36:55,890 --> 00:36:59,929
we have implemented experimental

00:36:57,569 --> 00:37:02,670
improvements to the areas of interest

00:36:59,929 --> 00:37:05,279
which were on our roadmap initially and

00:37:02,670 --> 00:37:07,739
these improvements they use both open

00:37:05,279 --> 00:37:09,660
source software like Scala fix and

00:37:07,739 --> 00:37:11,130
closed source stuff for something that

00:37:09,660 --> 00:37:15,839
we cannot open source but you know our

00:37:11,130 --> 00:37:17,849
build cluster finally good news if if

00:37:15,839 --> 00:37:20,219
you're interested by this talk if you're

00:37:17,849 --> 00:37:21,869
interested in compilers and just willing

00:37:20,219 --> 00:37:24,269
to get this done you can drop me an

00:37:21,869 --> 00:37:25,380
email we're hiring and really looking

00:37:24,269 --> 00:37:27,830
forward to hearing from you

00:37:25,380 --> 00:37:36,320
thanks guys

00:37:27,830 --> 00:37:36,320
[Applause]

00:37:37,170 --> 00:37:46,770
so I guess you'll need to go for the

00:37:39,270 --> 00:37:48,480
micro okay thank you so I'm guessing

00:37:46,770 --> 00:37:50,250
that since you're not running an

00:37:48,480 --> 00:37:53,700
instance compiler you're not running the

00:37:50,250 --> 00:37:55,620
typer either right do you find the lack

00:37:53,700 --> 00:37:59,610
of typing to be a problem

00:37:55,620 --> 00:38:00,990
great question okay so speaking of the

00:37:59,610 --> 00:38:03,300
type checker so indeed we don't have a

00:38:00,990 --> 00:38:07,830
live type checker so we cannot type

00:38:03,300 --> 00:38:09,240
check things on the fly however a type

00:38:07,830 --> 00:38:10,770
checker is involved in this whole

00:38:09,240 --> 00:38:13,170
process because in order to obtain

00:38:10,770 --> 00:38:16,650
semantically payloads we compile stuff

00:38:13,170 --> 00:38:19,350
with the semantic DB compiler plugin so

00:38:16,650 --> 00:38:21,840
as a result the type checker happens

00:38:19,350 --> 00:38:23,280
then we traverse the results and we

00:38:21,840 --> 00:38:25,140
fetch all the information that we can

00:38:23,280 --> 00:38:27,540
find there and then we stuff it into

00:38:25,140 --> 00:38:29,430
semantic DB obtain information like this

00:38:27,540 --> 00:38:31,500
so this info comes from the type checker

00:38:29,430 --> 00:38:33,930
and this so because type checker

00:38:31,500 --> 00:38:35,730
resolves references and afterwards after

00:38:33,930 --> 00:38:39,000
this information is obtained we store it

00:38:35,730 --> 00:38:42,180
and it's available anywhere so we

00:38:39,000 --> 00:38:44,790
decouple production and usage of

00:38:42,180 --> 00:38:48,840
semantic info and as a result we gain

00:38:44,790 --> 00:38:51,360
the ability to scale out that's an

00:38:48,840 --> 00:38:54,300
explanation and a nutshell Copeland's

00:38:51,360 --> 00:38:58,260
answers the question thanks all right

00:38:54,300 --> 00:39:01,350
anything else guys Thank You Barton yeah

00:38:58,260 --> 00:39:03,450
first awesome work I really think this

00:39:01,350 --> 00:39:05,010
is amazing what you did for the

00:39:03,450 --> 00:39:08,910
developers here

00:39:05,010 --> 00:39:12,030
the other thing is regarding tasty it's

00:39:08,910 --> 00:39:14,340
true it's very very very early days so

00:39:12,030 --> 00:39:17,160
there's one slight difference between

00:39:14,340 --> 00:39:20,040
what we did in reflect and what we do in

00:39:17,160 --> 00:39:22,110
tasty which i think is significant that

00:39:20,040 --> 00:39:24,630
in this format here there's no

00:39:22,110 --> 00:39:26,250
connection between the compiler and this

00:39:24,630 --> 00:39:28,110
format whereas since kind of reflect the

00:39:26,250 --> 00:39:30,750
compiler essentially inherits these

00:39:28,110 --> 00:39:32,310
colors reflect api's so what that means

00:39:30,750 --> 00:39:34,710
is that in the future we can evolve

00:39:32,310 --> 00:39:36,570
tasty and the compiler completely

00:39:34,710 --> 00:39:37,329
independently so there's because there

00:39:36,570 --> 00:39:39,519
is no link so

00:39:37,329 --> 00:39:41,469
I think that's important the other thing

00:39:39,519 --> 00:39:43,059
is yes it needs a compiler instance but

00:39:41,469 --> 00:39:45,729
the compiler is structured differently

00:39:43,059 --> 00:39:47,739
it doesn't need a global anymore so it

00:39:45,729 --> 00:39:49,630
needs just the bits of the compiler that

00:39:47,739 --> 00:39:51,880
depend on the tasty which should be less

00:39:49,630 --> 00:39:53,589
but I agree it's it's still something

00:39:51,880 --> 00:39:56,229
that this entry you have to roll in the

00:39:53,589 --> 00:39:58,029
in your class path yeah thank you thanks

00:39:56,229 --> 00:40:00,579
a lot for clarifications definitely

00:39:58,029 --> 00:40:02,259
tasty is an improvement of upon state of

00:40:00,579 --> 00:40:06,059
the art and so once that is released

00:40:02,259 --> 00:40:10,680
we're looking forward to playing with it

00:40:06,059 --> 00:40:10,680
all right please approach the mic

00:40:11,519 --> 00:40:17,650
speaking of you know this slide actually

00:40:14,380 --> 00:40:20,019
in particular why was the word universe

00:40:17,650 --> 00:40:21,670
brought into the codebase where this

00:40:20,019 --> 00:40:25,180
word universe come from I've always been

00:40:21,670 --> 00:40:28,410
curious if Martin doesn't mind maybe he

00:40:25,180 --> 00:40:32,680
can answer that so okay fine

00:40:28,410 --> 00:40:35,529
well so when I came to pfl it was summer

00:40:32,680 --> 00:40:40,089
of 2011 there was a already discovery

00:40:35,529 --> 00:40:43,599
flag project underway it was it was

00:40:40,089 --> 00:40:45,789
based it was based on Jews do Bush's

00:40:43,599 --> 00:40:48,219
thesis as well as his collaborations

00:40:45,789 --> 00:40:50,529
with other guys martin other guys in the

00:40:48,219 --> 00:40:52,319
lab and so universe as far as I

00:40:50,529 --> 00:40:55,359
understand it was inherited from there

00:40:52,319 --> 00:40:57,279
but then in the times when we were using

00:40:55,359 --> 00:40:59,709
Scala C or where we have you know cake

00:40:57,279 --> 00:41:01,390
button and like a huge thing a global

00:40:59,709 --> 00:41:04,959
something Martin said that encapsulates

00:41:01,390 --> 00:41:07,479
everything I guess this Mugello many it

00:41:04,959 --> 00:41:09,459
was inherited and reflected in this name

00:41:07,479 --> 00:41:12,489
like universe everything that you can

00:41:09,459 --> 00:41:15,099
think of but to be completely precise we

00:41:12,489 --> 00:41:24,369
should probably ask Israel he's not at

00:41:15,099 --> 00:41:26,319
the conference but I can speculate I'm

00:41:24,369 --> 00:41:29,670
actually I forgot what it was exactly

00:41:26,319 --> 00:41:32,589
but I think it was because at the time a

00:41:29,670 --> 00:41:34,599
Java class law that was define the

00:41:32,589 --> 00:41:36,910
universe so basically all the classes in

00:41:34,599 --> 00:41:39,309
the world exist in different instances

00:41:36,910 --> 00:41:41,920
once once per class loader so that was

00:41:39,309 --> 00:41:43,809
sort of alternate universes to define

00:41:41,920 --> 00:41:45,609
the same object class and they basically

00:41:43,809 --> 00:41:47,289
have separate versions of all the

00:41:45,609 --> 00:41:48,080
classes I think that's where it came

00:41:47,289 --> 00:41:50,240
from

00:41:48,080 --> 00:41:52,220
but I am not hundred percent sure

00:41:50,240 --> 00:41:59,540
anymore great to know it's good that you

00:41:52,220 --> 00:42:05,300
didn't ask me that at my PhD defense all

00:41:59,540 --> 00:42:06,620
right anything else guys okay well

00:42:05,300 --> 00:42:08,610
apparently that was the last question

00:42:06,620 --> 00:42:13,360
thanks everyone

00:42:08,610 --> 00:42:13,360

YouTube URL: https://www.youtube.com/watch?v=C770WpI_odM


