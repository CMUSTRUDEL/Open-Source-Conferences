Title: Type Parameter Power-Up! Variance, Bounds, and Inference by Chris Phelps
Publication date: 2018-09-21
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/type-parameter-power-up-variance-bounds-and-inference
Captions: 
	00:00:04,950 --> 00:00:10,570
okay good morning everyone welcome to

00:00:07,630 --> 00:00:12,130
day two my name is Chris Phelps I'm from

00:00:10,570 --> 00:00:13,840
Boulder Colorado and I'm going to talk

00:00:12,130 --> 00:00:18,760
today about tight parameters and

00:00:13,840 --> 00:00:21,820
variance so why this talk my company

00:00:18,760 --> 00:00:23,739
tendril we're in smart energy we do

00:00:21,820 --> 00:00:25,360
things about understanding how people

00:00:23,739 --> 00:00:27,579
use energy in their home and trying to

00:00:25,360 --> 00:00:30,730
help them automate that sorry optimize

00:00:27,579 --> 00:00:32,470
that and one of the main products that

00:00:30,730 --> 00:00:36,190
we use for doing that is a home energy

00:00:32,470 --> 00:00:39,220
report we're building a new system to

00:00:36,190 --> 00:00:41,020
build our home energy reports was based

00:00:39,220 --> 00:00:43,570
on a free monad kind of pattern which

00:00:41,020 --> 00:00:45,970
I'm not going to describe but suffice to

00:00:43,570 --> 00:00:48,970
say you end up with workflow stages that

00:00:45,970 --> 00:00:51,580
are all extensions of a common base

00:00:48,970 --> 00:00:54,610
class they're parameterised with

00:00:51,580 --> 00:00:57,460
whatever type of report that you have in

00:00:54,610 --> 00:01:00,010
our case we had many different reports

00:00:57,460 --> 00:01:02,230
so we have different reports that extend

00:01:00,010 --> 00:01:04,689
a base class so now we've got workflow

00:01:02,230 --> 00:01:06,280
stages with different reports there's

00:01:04,689 --> 00:01:09,219
single reports optional reports lists of

00:01:06,280 --> 00:01:12,609
reports so lots and lots of nested type

00:01:09,219 --> 00:01:13,929
parameters and the Scala compiler is

00:01:12,609 --> 00:01:15,149
usually pretty good at helping us

00:01:13,929 --> 00:01:18,490
through this

00:01:15,149 --> 00:01:20,139
we sometimes though end up with some of

00:01:18,490 --> 00:01:23,859
these interesting kind of cases where we

00:01:20,139 --> 00:01:25,509
try to swap this a wrapper and the

00:01:23,859 --> 00:01:28,090
compiler tries to be helpful and tells

00:01:25,509 --> 00:01:31,030
us covariant type a occurs in

00:01:28,090 --> 00:01:33,280
contravariant position and my engineers

00:01:31,030 --> 00:01:34,749
were quite confused it came to me and

00:01:33,280 --> 00:01:36,880
asked you know what what the heck does

00:01:34,749 --> 00:01:40,420
this mean and at first I couldn't give a

00:01:36,880 --> 00:01:42,490
good succinct answer so once I was able

00:01:40,420 --> 00:01:44,229
to give them a good 6 inked answer this

00:01:42,490 --> 00:01:48,189
was a good idea for it

00:01:44,229 --> 00:01:52,689
I talked to proposal so the motivations

00:01:48,189 --> 00:01:54,219
for this talk for users of api's you

00:01:52,689 --> 00:01:56,020
want to be able to understand signatures

00:01:54,219 --> 00:01:57,939
when you look at Scala Docs and and so

00:01:56,020 --> 00:02:00,670
on you want to understand what is that

00:01:57,939 --> 00:02:02,829
API accept so what can I pass to it how

00:02:00,670 --> 00:02:05,560
do I make it interact with this stuff

00:02:02,829 --> 00:02:07,329
that I've got in my codebase and how do

00:02:05,560 --> 00:02:10,030
I make sense of all those kinds of weird

00:02:07,329 --> 00:02:12,069
error messages and as an API designer

00:02:10,030 --> 00:02:14,380
you want to think about what you're

00:02:12,069 --> 00:02:16,780
going to allow your users to to pass to

00:02:14,380 --> 00:02:18,160
you what sort of flexibility do you want

00:02:16,780 --> 00:02:20,080
to offer to them

00:02:18,160 --> 00:02:21,730
and occasionally you to run into these

00:02:20,080 --> 00:02:26,920
weird error messages need to make sense

00:02:21,730 --> 00:02:30,160
of them so Adrienne Moors is on record

00:02:26,920 --> 00:02:32,350
saying just add plus minus till it

00:02:30,160 --> 00:02:35,770
compiles he will probably say that again

00:02:32,350 --> 00:02:38,170
this afternoon in his talk and his point

00:02:35,770 --> 00:02:41,770
here is that the Scala compiler has your

00:02:38,170 --> 00:02:43,180
back it does a lot to make sure that

00:02:41,770 --> 00:02:45,460
things are working right and most of the

00:02:43,180 --> 00:02:47,640
time this is just fine

00:02:45,460 --> 00:02:50,470
but I think it's useful to understand

00:02:47,640 --> 00:02:53,440
the deeper parts of your languages and

00:02:50,470 --> 00:02:55,480
your tools but don't don't worry if you

00:02:53,440 --> 00:02:57,640
don't get this at first or you don't

00:02:55,480 --> 00:02:59,620
understand all of it the compiler does

00:02:57,640 --> 00:03:01,600
have your back-end most of the time just

00:02:59,620 --> 00:03:05,350
adding plus minus till it compiles is is

00:03:01,600 --> 00:03:06,730
ok too to make things work so the

00:03:05,350 --> 00:03:09,340
overall structure I'm going to talk

00:03:06,730 --> 00:03:11,890
about variants first we'll move from

00:03:09,340 --> 00:03:14,170
there into constraints we'll see how

00:03:11,890 --> 00:03:16,570
constraints then get us to type classes

00:03:14,170 --> 00:03:18,640
and then at the end we'll discuss really

00:03:16,570 --> 00:03:22,150
briefly how these things change in dotty

00:03:18,640 --> 00:03:25,150
and Scala 3 so let's get started with

00:03:22,150 --> 00:03:28,480
variants and we'll start from the basics

00:03:25,150 --> 00:03:31,210
so inheritance and substitution through

00:03:28,480 --> 00:03:35,380
inheritance so as we know in Scala all

00:03:31,210 --> 00:03:39,280
values have a type types have superclass

00:03:35,380 --> 00:03:42,130
relationships that go up to a top class

00:03:39,280 --> 00:03:44,020
Annie they also have a subtype

00:03:42,130 --> 00:03:48,070
relationship that go down to a bottom

00:03:44,020 --> 00:03:50,950
type nothing and a reference can store a

00:03:48,070 --> 00:03:53,050
reference with a given type can store

00:03:50,950 --> 00:03:56,560
instances of that type or instances of

00:03:53,050 --> 00:03:58,840
subclasses of that type functions can be

00:03:56,560 --> 00:04:01,450
passed instances of the type they expect

00:03:58,840 --> 00:04:05,320
or subclasses of the type they expect

00:04:01,450 --> 00:04:07,720
and functions can return super types of

00:04:05,320 --> 00:04:13,330
the type it expects if I tell you I'm

00:04:07,720 --> 00:04:15,640
going to return you an in an int I can

00:04:13,330 --> 00:04:16,239
return you in any Val am I saying that

00:04:15,640 --> 00:04:19,660
right

00:04:16,239 --> 00:04:21,100
I don't think I am but sorry I'm totally

00:04:19,660 --> 00:04:22,810
saying that wrong functions return

00:04:21,100 --> 00:04:25,090
subclass instances so if the function

00:04:22,810 --> 00:04:26,560
tells you that it can return and any Val

00:04:25,090 --> 00:04:28,150
it can really return you an int because

00:04:26,560 --> 00:04:29,710
event can still be treated as in any

00:04:28,150 --> 00:04:34,280
file

00:04:29,710 --> 00:04:37,599
so Liskov and wing in 1994 formalized

00:04:34,280 --> 00:04:41,360
this with Liskov substitution principle

00:04:37,599 --> 00:04:45,080
let Phi of X be a property provable bla

00:04:41,360 --> 00:04:47,060
bla bla easy to understand if you think

00:04:45,080 --> 00:04:49,940
about it a lot but not so much on the

00:04:47,060 --> 00:04:52,759
first read so maybe Wikipedia's

00:04:49,940 --> 00:04:55,789
descriptions a little bit easier if s is

00:04:52,759 --> 00:04:58,129
a subtype of T then objects of T may be

00:04:55,789 --> 00:05:00,110
replaced with objects of s without

00:04:58,129 --> 00:05:03,050
altering the desirable properties of the

00:05:00,110 --> 00:05:04,669
program okay so we can put subclasses

00:05:03,050 --> 00:05:07,370
where we expect the super classes

00:05:04,669 --> 00:05:10,849
without altering the properties of the

00:05:07,370 --> 00:05:13,880
program so let's talk about higher kind

00:05:10,849 --> 00:05:16,580
of types these are also sometimes called

00:05:13,880 --> 00:05:20,060
generic classes you can think of them as

00:05:16,580 --> 00:05:22,190
types that have a parameter and so they

00:05:20,060 --> 00:05:23,810
usually contain or they're implemented

00:05:22,190 --> 00:05:25,729
in terms of some other types so we've

00:05:23,810 --> 00:05:28,009
got things like list of int more

00:05:25,729 --> 00:05:30,229
generally a list of T also more

00:05:28,009 --> 00:05:33,560
generally we could do X essentials in

00:05:30,229 --> 00:05:36,680
their list of anything and so what this

00:05:33,560 --> 00:05:39,380
gives us is two different axes of sub

00:05:36,680 --> 00:05:41,289
classing so we have the super class

00:05:39,380 --> 00:05:43,490
subclass relationship of that container

00:05:41,289 --> 00:05:45,770
but then we've also got this subclass

00:05:43,490 --> 00:05:47,360
superclass relationship of the parameter

00:05:45,770 --> 00:05:49,880
of the thing that's that's inside of

00:05:47,360 --> 00:05:51,409
there and this is where where we're

00:05:49,880 --> 00:05:53,539
going to get to variance we need to

00:05:51,409 --> 00:05:56,090
understand when are we concerned about

00:05:53,539 --> 00:05:57,199
the superclass subclass relationship of

00:05:56,090 --> 00:05:58,400
the container when are we concerned

00:05:57,199 --> 00:06:04,460
about the subclass superclass

00:05:58,400 --> 00:06:06,169
relationship of the contents so the tour

00:06:04,460 --> 00:06:09,139
of Scala that you'll find on the Scala

00:06:06,169 --> 00:06:11,599
lying org says variance is the

00:06:09,139 --> 00:06:14,840
correlation of subtyping relationships

00:06:11,599 --> 00:06:16,810
of complex types and the subtyping

00:06:14,840 --> 00:06:20,330
relationships of their component types

00:06:16,810 --> 00:06:22,669
so complex types means the containers

00:06:20,330 --> 00:06:26,360
and component types means the contents

00:06:22,669 --> 00:06:28,729
and Twitter Scala school which I've been

00:06:26,360 --> 00:06:30,430
told is is pretty out of date and not

00:06:28,729 --> 00:06:32,960
used within Twitter anymore

00:06:30,430 --> 00:06:35,000
but but I think this this still applies

00:06:32,960 --> 00:06:37,130
in is a good way of describing this a

00:06:35,000 --> 00:06:39,949
central question that comes up when

00:06:37,130 --> 00:06:41,139
mixing Noah with polymorphism if you is

00:06:39,949 --> 00:06:43,780
a subclass of T

00:06:41,139 --> 00:06:48,370
is container you consider it a subclass

00:06:43,780 --> 00:06:50,610
of container T but but I think this

00:06:48,370 --> 00:06:55,120
thinking about subclass and superclass

00:06:50,610 --> 00:06:56,740
is is an extra layer of thing to think

00:06:55,120 --> 00:06:58,919
about here and what you're really

00:06:56,740 --> 00:07:03,189
interested in is when can I substitute

00:06:58,919 --> 00:07:05,349
things in to other places so we can look

00:07:03,189 --> 00:07:06,759
at these definitions instead variance is

00:07:05,349 --> 00:07:09,969
the correlation of when we can

00:07:06,759 --> 00:07:13,719
substitute complex types and when we can

00:07:09,969 --> 00:07:16,000
substitute their component types and the

00:07:13,719 --> 00:07:18,449
Twitter version applied that question

00:07:16,000 --> 00:07:22,000
that comes up if you as a subclass of T

00:07:18,449 --> 00:07:26,319
can a container of use be substituted in

00:07:22,000 --> 00:07:28,569
where you expect a container of t's so

00:07:26,319 --> 00:07:31,060
think about this like substituting in

00:07:28,569 --> 00:07:33,839
different machines right Hobbes once a

00:07:31,060 --> 00:07:37,240
machine that he can push to do a thing

00:07:33,839 --> 00:07:39,550
and he doesn't care if Calvin suddenly

00:07:37,240 --> 00:07:41,919
gives him a new-and-improved duplicator

00:07:39,550 --> 00:07:43,599
that only makes good Calvin's

00:07:41,919 --> 00:07:47,680
or that makes some noise other than

00:07:43,599 --> 00:07:49,210
boink when he pushes the button so when

00:07:47,680 --> 00:07:53,500
can we substitute which kinds of

00:07:49,210 --> 00:07:55,479
machines a lot of the documentation blog

00:07:53,500 --> 00:07:57,789
posts etc you're gonna see are going to

00:07:55,479 --> 00:07:59,379
use pets and animals and things like

00:07:57,789 --> 00:08:01,210
that in there examples I don't think

00:07:59,379 --> 00:08:05,409
this is a particularly compelling thing

00:08:01,210 --> 00:08:07,930
but it's very naturally very natural to

00:08:05,409 --> 00:08:09,669
understand so I'm going to continue to

00:08:07,930 --> 00:08:11,860
use that pattern that way you don't have

00:08:09,669 --> 00:08:14,680
to remember anything about my special

00:08:11,860 --> 00:08:18,039
domain that I'm gonna use so we've got

00:08:14,680 --> 00:08:20,409
an animal base class pets are types of

00:08:18,039 --> 00:08:23,500
animals cats and dogs are types of pets

00:08:20,409 --> 00:08:26,830
a little class diagram looks something

00:08:23,500 --> 00:08:29,379
like that man so let's start with the

00:08:26,830 --> 00:08:31,599
different types of variants so the

00:08:29,379 --> 00:08:33,310
default case is in variants and this

00:08:31,599 --> 00:08:36,099
means there's no subclass relationship

00:08:33,310 --> 00:08:38,620
which means that we can't substitute any

00:08:36,099 --> 00:08:42,240
containers of T with containers of you

00:08:38,620 --> 00:08:44,649
unless you and T are the same type so

00:08:42,240 --> 00:08:48,459
anything that's a var has to be

00:08:44,649 --> 00:08:50,290
invariant and this seems not so

00:08:48,459 --> 00:08:52,149
interesting or not so useful at first

00:08:50,290 --> 00:08:55,120
glance but actually there's a there's

00:08:52,149 --> 00:08:55,570
more deeper usage of this because this

00:08:55,120 --> 00:08:59,020
in flu

00:08:55,570 --> 00:09:02,260
type inference so this will allow the

00:08:59,020 --> 00:09:04,800
compiler to bind types that it doesn't

00:09:02,260 --> 00:09:08,290
know because it can't be anything but

00:09:04,800 --> 00:09:13,570
the the T type that that it understands

00:09:08,290 --> 00:09:15,790
in some context so examples of that so

00:09:13,570 --> 00:09:17,560
here I've got an invariant wrapper we

00:09:15,790 --> 00:09:22,030
mark that it's invariant because we have

00:09:17,560 --> 00:09:24,640
no sort of + - annotation on the a in

00:09:22,030 --> 00:09:26,380
this case we've just got a wrapped value

00:09:24,640 --> 00:09:30,100
that gets stored and there's a def to

00:09:26,380 --> 00:09:32,560
pull it back out so I can then have an

00:09:30,100 --> 00:09:35,770
instance of that with with a particular

00:09:32,560 --> 00:09:39,970
type so an invariant wrapper of cat with

00:09:35,770 --> 00:09:41,920
a with Morris the cat stored in it so

00:09:39,970 --> 00:09:44,560
now we've got one axis of inheritance

00:09:41,920 --> 00:09:47,470
which is our container subclass and

00:09:44,560 --> 00:09:50,380
superclass so if I make a sub wrapper

00:09:47,470 --> 00:09:54,340
that extends invariant wrapper I'm still

00:09:50,380 --> 00:09:56,620
in the same A's so when I create a sub

00:09:54,340 --> 00:10:01,840
wrapper with Milo in it I can still put

00:09:56,620 --> 00:10:04,210
it inside my invariant wrapper Val but

00:10:01,840 --> 00:10:07,390
if I have an invariant wrapper of some

00:10:04,210 --> 00:10:10,750
animal I cannot put an invariant wrapper

00:10:07,390 --> 00:10:13,810
of some subclass of animal cat into

00:10:10,750 --> 00:10:15,400
there so I can't put bills an invariant

00:10:13,810 --> 00:10:17,920
wrapper of bill

00:10:15,400 --> 00:10:19,330
sorry containing bill into an invariant

00:10:17,920 --> 00:10:24,220
wrapper of animal I could only put that

00:10:19,330 --> 00:10:26,230
into an invariant wrapper of cat and if

00:10:24,220 --> 00:10:27,790
I try to do that last line then I'm

00:10:26,230 --> 00:10:31,510
going to see an error something like

00:10:27,790 --> 00:10:34,540
this expected invariant wrapper of

00:10:31,510 --> 00:10:36,520
animal found an invariant wrapper of cat

00:10:34,540 --> 00:10:40,420
in this case the compiler is pretty

00:10:36,520 --> 00:10:42,430
helpful note example cat is a subtype of

00:10:40,420 --> 00:10:47,880
animal but class invariant wrapper is

00:10:42,430 --> 00:10:47,880
invariant in a ok that's that's useful

00:10:48,000 --> 00:10:54,640
so covariance is the first of the other

00:10:51,460 --> 00:10:57,490
two that we'll talk about so this has a

00:10:54,640 --> 00:11:00,520
subclass relationship when the contents

00:10:57,490 --> 00:11:03,070
have a subclass relationships so if you

00:11:00,520 --> 00:11:05,260
is a subclass of T then we can

00:11:03,070 --> 00:11:06,960
substitute containers of U where we

00:11:05,260 --> 00:11:09,520
expect containers of T

00:11:06,960 --> 00:11:12,250
so this is useful for extracting

00:11:09,520 --> 00:11:14,140
contents of the container because

00:11:12,250 --> 00:11:18,250
instances of you can be used wherever

00:11:14,140 --> 00:11:21,370
instances of T's are so whenever I have

00:11:18,250 --> 00:11:24,400
a container of you it will produce tea

00:11:21,370 --> 00:11:27,910
instances because use are teas and so

00:11:24,400 --> 00:11:29,290
all my types are sound I can still use

00:11:27,910 --> 00:11:31,000
that container of you anywhere I

00:11:29,290 --> 00:11:32,200
expected a container of tea take things

00:11:31,000 --> 00:11:36,010
out of it and they're still going to be

00:11:32,200 --> 00:11:38,620
teas but this is problematic when adding

00:11:36,010 --> 00:11:42,870
or changing values and we'll see that in

00:11:38,620 --> 00:11:46,210
a few slides so an example of that of

00:11:42,870 --> 00:11:49,300
covariant wrapper plus a means it's

00:11:46,210 --> 00:11:51,970
covariant in a again I have the same

00:11:49,300 --> 00:11:55,510
just it contains a wrapped it has a def

00:11:51,970 --> 00:11:58,720
to get it back out if I have some do-it

00:11:55,510 --> 00:12:01,240
method that now expects a covariant

00:11:58,720 --> 00:12:03,040
wrapper of animal I can pass in

00:12:01,240 --> 00:12:05,620
covariant wrappers of cats I can pass in

00:12:03,040 --> 00:12:08,200
covariant wrappers of dogs do it can get

00:12:05,620 --> 00:12:11,920
the thing out as an animal and do

00:12:08,200 --> 00:12:15,630
something with it because again cats and

00:12:11,920 --> 00:12:15,630
dogs are both pets or gerbils animals

00:12:16,140 --> 00:12:23,620
but if I try to take a coherent wrapper

00:12:20,290 --> 00:12:26,380
of any pass it a covariant wrapper of

00:12:23,620 --> 00:12:28,870
any with a cat in it

00:12:26,380 --> 00:12:30,460
then it will tell me I found a covariant

00:12:28,870 --> 00:12:32,740
wrapper of any but I expected a

00:12:30,460 --> 00:12:36,190
covariant wrapper of animal so animal

00:12:32,740 --> 00:12:39,660
goes up to any but any does any is a

00:12:36,190 --> 00:12:39,660
super type of animal

00:12:40,960 --> 00:12:46,410
so contravariance goes the opposite way

00:12:43,680 --> 00:12:49,300
this is where it starts to get confusing

00:12:46,410 --> 00:12:52,089
subclass relationship when contents have

00:12:49,300 --> 00:12:53,200
a superclass relationship but think

00:12:52,089 --> 00:12:56,040
about that again in terms of

00:12:53,200 --> 00:12:59,680
substitution I can substitute a

00:12:56,040 --> 00:13:01,180
container of you into a place where I

00:12:59,680 --> 00:13:03,459
expect a container of tea if yous are

00:13:01,180 --> 00:13:04,589
going to give me something above T's and

00:13:03,459 --> 00:13:06,700
why would we do this

00:13:04,589 --> 00:13:10,029
this is useful for when we have

00:13:06,700 --> 00:13:14,140
processors or consumers of the values so

00:13:10,029 --> 00:13:17,560
I can use au anywhere where I expect to

00:13:14,140 --> 00:13:21,660
tea so if I have something that can

00:13:17,560 --> 00:13:24,730
process a tea it can also process au

00:13:21,660 --> 00:13:29,920
only looking at the the tea parts of the

00:13:24,730 --> 00:13:31,930
U so so that consumer of and I think I'm

00:13:29,920 --> 00:13:34,810
saying this in a different order than my

00:13:31,930 --> 00:13:36,580
slide is saying it so instances of you

00:13:34,810 --> 00:13:40,089
can be used where instances of teas are

00:13:36,580 --> 00:13:42,480
expected so a consumer of this should

00:13:40,089 --> 00:13:45,310
say consumer of tea can consume you

00:13:42,480 --> 00:13:47,860
instances so the types are sound when I

00:13:45,310 --> 00:13:49,510
pass this to the consumer he can still

00:13:47,860 --> 00:13:53,230
get my things out even though they're

00:13:49,510 --> 00:13:55,209
subtypes and deal with them but in this

00:13:53,230 --> 00:14:01,120
case is problematic when we return or

00:13:55,209 --> 00:14:04,810
produce values so so here we have we

00:14:01,120 --> 00:14:07,480
have a keeper who keeps pets where

00:14:04,810 --> 00:14:11,470
contravariant in a so that's the - a

00:14:07,480 --> 00:14:15,310
annotation a dog-sitter is a keeper of

00:14:11,470 --> 00:14:17,110
dogs zookeeper is a keeper of all

00:14:15,310 --> 00:14:24,160
animals and a pet sitter is a keeper of

00:14:17,110 --> 00:14:27,610
pets I've got this tend method that for

00:14:24,160 --> 00:14:30,130
dog sitter that takes a dog does

00:14:27,610 --> 00:14:34,779
something returns a unit so all those

00:14:30,130 --> 00:14:36,600
fpp RS would be unhappy with me you can

00:14:34,779 --> 00:14:39,550
you can imagine that this same ten

00:14:36,600 --> 00:14:42,579
exists in in all of these with the

00:14:39,550 --> 00:14:46,029
appropriate types i just limited them

00:14:42,579 --> 00:14:49,180
from the slide so so I have a keeper of

00:14:46,029 --> 00:14:54,420
dog who's going to dog sit for a dog

00:14:49,180 --> 00:14:54,420
Tintin I have a

00:14:54,550 --> 00:14:59,940
keeper of dogs and I can replace him

00:14:58,900 --> 00:15:03,040
with a zookeeper

00:14:59,940 --> 00:15:05,670
because zookeepers can keep any animal

00:15:03,040 --> 00:15:09,550
so they can also keep dogs so that's

00:15:05,670 --> 00:15:12,310
that's easy that works if on the other

00:15:09,550 --> 00:15:14,050
hand I have a keeper of pets and I

00:15:12,310 --> 00:15:15,910
replace it with a key with a dog sitter

00:15:14,050 --> 00:15:17,850
dog sitters are just keepers of dogs

00:15:15,910 --> 00:15:20,890
they're not keepers of all types of pets

00:15:17,850 --> 00:15:23,140
so I'm going to have a problem there and

00:15:20,890 --> 00:15:25,150
the compiler will tell me I found a dog

00:15:23,140 --> 00:15:31,740
sitter I required a keeper of example

00:15:25,150 --> 00:15:35,020
that pet and incidentally if I hadn't

00:15:31,740 --> 00:15:37,180
hidden the parameterisation away in the

00:15:35,020 --> 00:15:40,390
dog sitter this would have said like

00:15:37,180 --> 00:15:44,560
found keeper of dog expected required a

00:15:40,390 --> 00:15:47,430
keeper of pet now so this gets us a

00:15:44,560 --> 00:15:49,780
little closer back to Jackies problem

00:15:47,430 --> 00:15:51,520
we've got covariant positions

00:15:49,780 --> 00:15:54,970
contravariant positions in variant

00:15:51,520 --> 00:15:57,460
positions but his positions mean so

00:15:54,970 --> 00:15:59,890
there's there's a whole sequence in the

00:15:57,460 --> 00:16:02,260
the Scala language spec that talks about

00:15:59,890 --> 00:16:04,360
positions and how they change as you

00:16:02,260 --> 00:16:06,640
pass things from one to another as you

00:16:04,360 --> 00:16:08,040
nest functions and one to another but

00:16:06,640 --> 00:16:11,100
you can start simply by thinking

00:16:08,040 --> 00:16:12,940
covariant position as method returns

00:16:11,100 --> 00:16:15,760
contravariant position is method

00:16:12,940 --> 00:16:20,590
arguments and invariant positions or

00:16:15,760 --> 00:16:22,780
mutable exposed variables so anything

00:16:20,590 --> 00:16:25,030
that's contravariant as marked in the

00:16:22,780 --> 00:16:27,130
annotations can't appear in the

00:16:25,030 --> 00:16:30,310
contravariant position so can't appear

00:16:27,130 --> 00:16:32,440
in a method argument anything that's

00:16:30,310 --> 00:16:34,780
marked contravariant in the method args

00:16:32,440 --> 00:16:36,400
can appear in a covariant positions who

00:16:34,780 --> 00:16:40,390
can't appear in return

00:16:36,400 --> 00:16:42,850
and neither covariant or contravariant

00:16:40,390 --> 00:16:46,210
parameters appear in invariant positions

00:16:42,850 --> 00:16:52,180
so you can't have your plus a show up as

00:16:46,210 --> 00:16:53,860
a var Scala 212 6 in IntelliJ give a

00:16:52,180 --> 00:16:56,110
little bit different error messages on

00:16:53,860 --> 00:16:58,060
these that that are not as clear in the

00:16:56,110 --> 00:16:59,800
invariant case they still end up saying

00:16:58,060 --> 00:17:02,430
can't appear and contravariant position

00:16:59,800 --> 00:17:02,430
or something like that

00:17:02,700 --> 00:17:06,260
so what's the problem with that why is

00:17:04,870 --> 00:17:11,809
this even a thing

00:17:06,260 --> 00:17:15,290
so so now I have a box of pets and that

00:17:11,809 --> 00:17:18,230
box can hold any any subtype of pet so I

00:17:15,290 --> 00:17:22,100
want to be able to give you a box of

00:17:18,230 --> 00:17:24,740
cats if you ask for a box of pets it has

00:17:22,100 --> 00:17:26,480
a swap method and that swap method wants

00:17:24,740 --> 00:17:29,390
to take the pet that's inside and put

00:17:26,480 --> 00:17:30,919
another pet inside so that's what I want

00:17:29,390 --> 00:17:35,350
to do but I'm going to end up with with

00:17:30,919 --> 00:17:39,350
this error contravariant pet plus pet

00:17:35,350 --> 00:17:42,500
occurs in contra covariant pet plus pet

00:17:39,350 --> 00:17:45,710
appears in contravariant position in the

00:17:42,500 --> 00:17:47,419
method argument so why is that a problem

00:17:45,710 --> 00:17:51,380
so let's imagine now I've got a box of

00:17:47,419 --> 00:17:54,200
cats that's got Morris the cat in it and

00:17:51,380 --> 00:17:56,000
I swap that with another cat okay no

00:17:54,200 --> 00:18:01,059
problem it's it's a box of cats I can

00:17:56,000 --> 00:18:04,549
still hold a cat but not every cat or

00:18:01,059 --> 00:18:07,309
cats aren't the only kinds of pets right

00:18:04,549 --> 00:18:09,320
so you thought you had a box of pets you

00:18:07,309 --> 00:18:11,780
try to put Cesar the dog into that box

00:18:09,320 --> 00:18:14,390
of pets now we've got problems because

00:18:11,780 --> 00:18:17,510
my box of cats can't hold a box of pets

00:18:14,390 --> 00:18:22,160
so that's why contravariant positions is

00:18:17,510 --> 00:18:25,309
problem now what about the other side

00:18:22,160 --> 00:18:29,870
covariant positions so here we've got a

00:18:25,309 --> 00:18:33,770
pet sitter a something that is a sitter

00:18:29,870 --> 00:18:39,710
so this is a contravariant pet because a

00:18:33,770 --> 00:18:42,669
sitter of a sitter of pets can sit any

00:18:39,710 --> 00:18:46,910
pet a sitter of cats can only sit cats

00:18:42,669 --> 00:18:48,770
so a cat sitter could be replaced by a

00:18:46,910 --> 00:18:51,440
pet sitter so that pets that are still

00:18:48,770 --> 00:18:55,429
perfectly capable of keeping my cat

00:18:51,440 --> 00:18:59,929
Dorai moment which is tough he's a hard

00:18:55,429 --> 00:19:01,880
cat to keep keep track of and the sitter

00:18:59,929 --> 00:19:03,770
now has this walk method that's going to

00:19:01,880 --> 00:19:08,030
do something with that pet and return

00:19:03,770 --> 00:19:10,250
return a new a new state of pet so if I

00:19:08,030 --> 00:19:12,080
now have my cat sitter and I send him

00:19:10,250 --> 00:19:16,270
off to walk tour I'm on okay everything

00:19:12,080 --> 00:19:19,760
seems okay but now the problem is if I

00:19:16,270 --> 00:19:20,210
have a sitter of pet we've only said

00:19:19,760 --> 00:19:23,960
that that's

00:19:20,210 --> 00:19:26,240
pet is going to return new pets so so

00:19:23,960 --> 00:19:28,610
I've got the sitter of cats I've stored

00:19:26,240 --> 00:19:31,279
the sitter of pets in it now what

00:19:28,610 --> 00:19:33,080
happens if it returns a cat no problem

00:19:31,279 --> 00:19:37,490
got a sitter of cats I expect cats as a

00:19:33,080 --> 00:19:39,289
whole it's all good if I have a sitter

00:19:37,490 --> 00:19:42,619
that returns a different kind of pet I

00:19:39,289 --> 00:19:46,809
expected a cat it's not a cat now we've

00:19:42,619 --> 00:19:48,889
got a problem so this is why

00:19:46,809 --> 00:19:54,289
contravariant positions are problems

00:19:48,889 --> 00:19:56,679
with contravariant parameters so let's

00:19:54,289 --> 00:20:00,320
move on and talk about functions and

00:19:56,679 --> 00:20:01,970
their types and see how this kind of

00:20:00,320 --> 00:20:05,149
expands out into a few more parameters

00:20:01,970 --> 00:20:06,649
than that so again remember we're

00:20:05,149 --> 00:20:11,629
thinking about what can substitute in

00:20:06,649 --> 00:20:14,029
and where so I have a pet eval p1 as a

00:20:11,629 --> 00:20:18,110
pet eval p2 as a pet and I'm going to

00:20:14,029 --> 00:20:21,230
call some function f with two pets so

00:20:18,110 --> 00:20:25,330
what are the signatures that F could

00:20:21,230 --> 00:20:29,210
take what would make this valid so if F

00:20:25,330 --> 00:20:33,289
took two pets and I pass it to pets is

00:20:29,210 --> 00:20:35,450
that a valid signature for F sure if F

00:20:33,289 --> 00:20:37,940
takes an animal in a pet and I pass it

00:20:35,450 --> 00:20:43,940
to pets is that a valid signature for F

00:20:37,940 --> 00:20:47,600
sure if F takes an any and a pet is that

00:20:43,940 --> 00:20:51,710
a valid signature for F yeah if it takes

00:20:47,600 --> 00:20:53,629
any any if it takes cats and dogs sorry

00:20:51,710 --> 00:20:55,070
if it takes any any that's that's still

00:20:53,629 --> 00:20:57,769
valid right we can still pass that to

00:20:55,070 --> 00:21:00,200
pets but if it takes if F takes a cat

00:20:57,769 --> 00:21:02,360
with a dog and I pass it to pets that's

00:21:00,200 --> 00:21:05,029
that's problematic so that's not a

00:21:02,360 --> 00:21:06,980
signature that F could take so what does

00:21:05,029 --> 00:21:10,879
this relationship look like that looks

00:21:06,980 --> 00:21:17,090
like contravariance so our function

00:21:10,879 --> 00:21:21,499
parameters are contravariant and what

00:21:17,090 --> 00:21:23,690
about the outputs so if I have an F and

00:21:21,499 --> 00:21:27,080
I pass it to pets and it gives me back

00:21:23,690 --> 00:21:30,320
an animal I expect an animal back what

00:21:27,080 --> 00:21:32,929
are the valid signatures that F could

00:21:30,320 --> 00:21:34,040
have so if F took two pets and returned

00:21:32,929 --> 00:21:37,670
an animal yeah that's

00:21:34,040 --> 00:21:40,310
valid that's that's what I expect out if

00:21:37,670 --> 00:21:42,110
F took two pets and returned to pet yeah

00:21:40,310 --> 00:21:45,500
that would be a valid signature of an F

00:21:42,110 --> 00:21:47,810
that I could call if it took two pets

00:21:45,500 --> 00:21:49,220
and return a cat cats are still pets so

00:21:47,810 --> 00:21:51,830
yeah that's still a valid signature I

00:21:49,220 --> 00:21:53,780
could call if it took two pets and

00:21:51,830 --> 00:21:55,640
returning any now that's not going to be

00:21:53,780 --> 00:21:59,540
a valid signature for the thing that I'm

00:21:55,640 --> 00:22:02,980
trying to call for P one and P two and

00:21:59,540 --> 00:22:06,410
get back in any so that looks like

00:22:02,980 --> 00:22:09,590
covariance so our function returns our

00:22:06,410 --> 00:22:12,290
covariant our function returns our

00:22:09,590 --> 00:22:14,420
covariant and this function to

00:22:12,290 --> 00:22:17,630
definition is exactly what we see in

00:22:14,420 --> 00:22:22,480
Scala doc this is true for all of the

00:22:17,630 --> 00:22:24,500
the 2223 variants of function they are

00:22:22,480 --> 00:22:30,440
contravariant and arguments and

00:22:24,500 --> 00:22:34,130
covariant and returns so when do you

00:22:30,440 --> 00:22:36,800
want to use which of these so covariance

00:22:34,130 --> 00:22:39,020
is really good for containers whenever

00:22:36,800 --> 00:22:43,220
or producers whenever we want to get the

00:22:39,020 --> 00:22:45,650
thing out and so therefore it's really

00:22:43,220 --> 00:22:47,450
good for representing inputs as a

00:22:45,650 --> 00:22:50,090
consumer of the thing I'm going to take

00:22:47,450 --> 00:22:51,980
whatever that input is and use it so our

00:22:50,090 --> 00:22:54,920
function woman is going to do something

00:22:51,980 --> 00:22:58,520
with those expects that it knows there

00:22:54,920 --> 00:23:01,340
are subtypes of of that type I'm

00:22:58,520 --> 00:23:03,830
expecting contravariance on the other

00:23:01,340 --> 00:23:07,210
hand is good for consumers processors

00:23:03,830 --> 00:23:10,940
visitors things like that things where I

00:23:07,210 --> 00:23:14,720
want to be able to do some sort of

00:23:10,940 --> 00:23:18,310
processing and it's okay that I only

00:23:14,720 --> 00:23:23,960
process parts of the sub thing right so

00:23:18,310 --> 00:23:28,640
something that consumes pets yeah

00:23:23,960 --> 00:23:31,670
sits pets can sit any sort of subtype of

00:23:28,640 --> 00:23:33,760
pet and so it's really good for

00:23:31,670 --> 00:23:37,640
representing outputs right anything that

00:23:33,760 --> 00:23:40,850
here's a thing that I am going to give

00:23:37,640 --> 00:23:44,120
to some follow-on processing

00:23:40,850 --> 00:23:45,590
and invariance as we said it's a little

00:23:44,120 --> 00:23:48,590
more interesting that looks on flourish

00:23:45,590 --> 00:23:51,080
blush this is good for representing

00:23:48,590 --> 00:23:53,419
distinct types so it's really good for

00:23:51,080 --> 00:23:56,720
markers and labels kind of types dick

00:23:53,419 --> 00:24:00,919
wall yesterday in his talk showed how he

00:23:56,720 --> 00:24:02,889
used the how he used invariants to give

00:24:00,919 --> 00:24:05,799
marker types so that he could keep

00:24:02,889 --> 00:24:10,009
coordinate systems together with

00:24:05,799 --> 00:24:12,620
coordinates in that system and because

00:24:10,009 --> 00:24:17,629
there's no relationship between the

00:24:12,620 --> 00:24:19,399
different types of coordinate systems he

00:24:17,629 --> 00:24:21,200
can mark that and know that he's got

00:24:19,399 --> 00:24:24,379
coordinates in the wrong system whenever

00:24:21,200 --> 00:24:25,940
he tries to process them and these are

00:24:24,379 --> 00:24:28,820
useful because then they influence the

00:24:25,940 --> 00:24:35,659
inheritance sorry influence the

00:24:28,820 --> 00:24:40,399
inference algorithm so I kind of glossed

00:24:35,659 --> 00:24:42,320
over what we do when we get to Jackies

00:24:40,399 --> 00:24:44,110
problem right what do we how do we how

00:24:42,320 --> 00:24:49,519
do we get out of that situation

00:24:44,110 --> 00:24:51,860
so that'll lead us into constraints so

00:24:49,519 --> 00:24:54,470
we have the first type of constraint we

00:24:51,860 --> 00:24:58,309
have is an upper or lower bound so we're

00:24:54,470 --> 00:25:00,049
going to use the less : or the greater :

00:24:58,309 --> 00:25:02,990
to indicate that there is some

00:25:00,049 --> 00:25:07,100
relationship between our P and another

00:25:02,990 --> 00:25:09,799
type so an upper bound says that P is

00:25:07,100 --> 00:25:13,340
the same type or a subtype to whatever

00:25:09,799 --> 00:25:17,210
so on the other side of that so a pet of

00:25:13,340 --> 00:25:19,960
P which is a subtype of pet could be a

00:25:17,210 --> 00:25:24,529
pet could be a cat could be a dog and

00:25:19,960 --> 00:25:27,710
lower bounds say that it's the same type

00:25:24,529 --> 00:25:32,200
or a super type so B is either the same

00:25:27,710 --> 00:25:32,200
as a or it is some super type of a

00:25:36,020 --> 00:25:42,600
so how does that in interact with

00:25:38,280 --> 00:25:45,470
variants so I've got a covariant list it

00:25:42,600 --> 00:25:48,840
has it's an abstract class it's got two

00:25:45,470 --> 00:25:51,360
extensions a case object nil which

00:25:48,840 --> 00:25:57,590
extends list of nothing and a case class

00:25:51,360 --> 00:26:00,410
cons which is of hazard B this is

00:25:57,590 --> 00:26:04,110
essentially what these look like in the

00:26:00,410 --> 00:26:06,600
212 collections there's a little bit of

00:26:04,110 --> 00:26:08,850
simplification here but not much it's

00:26:06,600 --> 00:26:16,200
slightly simplified a tiny bit

00:26:08,850 --> 00:26:19,770
differently for the 213 ones and so now

00:26:16,200 --> 00:26:21,780
if I want to add a prepend method to

00:26:19,770 --> 00:26:25,860
that list okay

00:26:21,780 --> 00:26:28,410
think cons this gets us right back into

00:26:25,860 --> 00:26:31,470
the problem that we saw before right so

00:26:28,410 --> 00:26:36,679
so I'm trying to pass as a method

00:26:31,470 --> 00:26:41,370
argument so contravariant position a

00:26:36,679 --> 00:26:46,440
covariant a and so I get Jackie's

00:26:41,370 --> 00:26:48,720
Jackie's error so what could I do about

00:26:46,440 --> 00:26:51,390
this well maybe I could introduce a

00:26:48,720 --> 00:26:54,030
different type B and we'll say that

00:26:51,390 --> 00:26:57,360
prepend is parameterized in B you tell

00:26:54,030 --> 00:27:00,570
me when you call it what that B is and

00:26:57,360 --> 00:27:01,919
we'll make a new list of B's but the

00:27:00,570 --> 00:27:04,470
problem here is now there's no

00:27:01,919 --> 00:27:05,880
relationship between a and B so the

00:27:04,470 --> 00:27:10,620
compiler says I don't know what to do

00:27:05,880 --> 00:27:12,419
with your existing list this and and how

00:27:10,620 --> 00:27:15,890
to turn those A's in to B's we need some

00:27:12,419 --> 00:27:18,179
sort of relationship between the two and

00:27:15,890 --> 00:27:21,720
so that's a place where we can start to

00:27:18,179 --> 00:27:24,030
know introduced about so we can say that

00:27:21,720 --> 00:27:28,110
B has to be the same type or a

00:27:24,030 --> 00:27:30,210
super-tight and now we're going to take

00:27:28,110 --> 00:27:31,679
a newbie so the same type or a super

00:27:30,210 --> 00:27:34,950
type and we're going to return a list of

00:27:31,679 --> 00:27:38,309
the new super type and so what this is

00:27:34,950 --> 00:27:40,740
doing is changing from the same type to

00:27:38,309 --> 00:27:43,679
potentially a wider type and this is

00:27:40,740 --> 00:27:47,350
exactly how things work so if I have a

00:27:43,679 --> 00:27:50,919
list of NC R and I try to put a 0 on

00:27:47,350 --> 00:27:53,350
the front of it inte is still the same

00:27:50,919 --> 00:27:56,220
type so I get a new list events all the

00:27:53,350 --> 00:28:01,030
existing things are in say we're happy

00:27:56,220 --> 00:28:03,100
if I try to put 1.5 in 1.5 is not an int

00:28:01,030 --> 00:28:05,370
so we're gonna find the compiler is

00:28:03,100 --> 00:28:07,870
going to find the lowest upper bound and

00:28:05,370 --> 00:28:10,210
widen that list so it's now gonna become

00:28:07,870 --> 00:28:12,130
a list of any vowels although since are

00:28:10,210 --> 00:28:15,490
still any vowels the new things still in

00:28:12,130 --> 00:28:16,720
any vows we end up with a wider list but

00:28:15,490 --> 00:28:18,610
the problem now is when we try to get

00:28:16,720 --> 00:28:19,960
things out of it we've lost that some of

00:28:18,610 --> 00:28:22,210
those are in sand some of those are

00:28:19,960 --> 00:28:23,890
doubles we've just got there any vowels

00:28:22,210 --> 00:28:26,080
and everything we take out sin any vowel

00:28:23,890 --> 00:28:29,500
and if we want to do better than that we

00:28:26,080 --> 00:28:31,150
would have to do a key typecasting and

00:28:29,500 --> 00:28:38,350
things like that we don't like those

00:28:31,150 --> 00:28:40,900
things so view bounds about all I want

00:28:38,350 --> 00:28:43,390
to say about them is they're deprecated

00:28:40,900 --> 00:28:45,429
they are still in the spec you may see

00:28:43,390 --> 00:28:47,100
them in some code but I don't think they

00:28:45,429 --> 00:28:49,630
show up anywhere in the community build

00:28:47,100 --> 00:28:54,070
and they basically just say a is

00:28:49,630 --> 00:28:55,539
convertible to be by some process but

00:28:54,070 --> 00:28:59,130
context bounds now start to get

00:28:55,539 --> 00:29:04,000
interesting context bounds says that a

00:28:59,130 --> 00:29:09,730
has some context which means that there

00:29:04,000 --> 00:29:11,710
exists some type context of a somewhere

00:29:09,730 --> 00:29:16,960
in implicit scope the compiler can find

00:29:11,710 --> 00:29:18,460
an instance of context for a and so what

00:29:16,960 --> 00:29:22,210
this does then is introduced as an

00:29:18,460 --> 00:29:26,080
evidence parameter so our method would

00:29:22,210 --> 00:29:30,250
look something like CTX bound of X which

00:29:26,080 --> 00:29:32,350
has the content context M takes an X and

00:29:30,250 --> 00:29:35,220
the compiler is going to take that call

00:29:32,350 --> 00:29:39,429
in M and add this implicit evidence

00:29:35,220 --> 00:29:42,429
parameter that's going to find that

00:29:39,429 --> 00:29:46,539
instance in implicit scope and and

00:29:42,429 --> 00:29:48,010
supply it to me and maybe that's good

00:29:46,539 --> 00:29:51,480
enough maybe I don't need to do anything

00:29:48,010 --> 00:29:55,059
with with that evidence once it exists

00:29:51,480 --> 00:29:56,400
this is a case of one of the things that

00:29:55,059 --> 00:29:58,270
Martin mentioned the other day about

00:29:56,400 --> 00:30:02,500
erasing

00:29:58,270 --> 00:30:04,750
at cogeneration time but if I wanted to

00:30:02,500 --> 00:30:07,690
I could access the context with the

00:30:04,750 --> 00:30:11,620
implicitly keyword from my code so I

00:30:07,690 --> 00:30:17,440
could fetch it by saying implicitly M of

00:30:11,620 --> 00:30:19,809
X and then call some method on it so

00:30:17,440 --> 00:30:22,929
what's that useful for well that that

00:30:19,809 --> 00:30:26,320
gets us to the type class pattern as as

00:30:22,929 --> 00:30:28,990
it exists in Scotland so type classes

00:30:26,320 --> 00:30:32,170
are some external implementation of an

00:30:28,990 --> 00:30:34,570
interface so you can implement an

00:30:32,170 --> 00:30:38,080
interface without needing to go alter

00:30:34,570 --> 00:30:40,000
the existing source code you don't

00:30:38,080 --> 00:30:41,470
necessarily even have to have access to

00:30:40,000 --> 00:30:42,970
the source code you find some new

00:30:41,470 --> 00:30:47,230
interface that you want to implement and

00:30:42,970 --> 00:30:50,950
you implement a context that implements

00:30:47,230 --> 00:30:53,220
that interface for your type and you can

00:30:50,950 --> 00:30:56,710
introduce that into places that want to

00:30:53,220 --> 00:30:59,590
consume them with content about context

00:30:56,710 --> 00:31:02,260
bound and this is really useful because

00:30:59,590 --> 00:31:04,030
then we can implement instances in terms

00:31:02,260 --> 00:31:05,320
of other instances and the compiler will

00:31:04,030 --> 00:31:09,429
give us the ones that we need

00:31:05,320 --> 00:31:12,100
so if we have adders for intz we can

00:31:09,429 --> 00:31:14,350
make an adder for pair events relying on

00:31:12,100 --> 00:31:16,809
the adder events that's given to us by

00:31:14,350 --> 00:31:19,150
the compiler and that becomes really

00:31:16,809 --> 00:31:21,429
powerful because we don't even have to

00:31:19,150 --> 00:31:23,020
know what that T type is I can make an

00:31:21,429 --> 00:31:25,320
adder of pairs of T's as long as the

00:31:23,020 --> 00:31:27,550
compiler can supply me an adder of T's

00:31:25,320 --> 00:31:28,809
and the compiler figures out what it is

00:31:27,550 --> 00:31:31,150
so I don't need to know all the

00:31:28,809 --> 00:31:35,380
possibilities that T could be in

00:31:31,150 --> 00:31:38,050
somebody else's program so the mechanics

00:31:35,380 --> 00:31:40,480
of this we define some interface or

00:31:38,050 --> 00:31:43,570
maybe they exist in cats or scholars e

00:31:40,480 --> 00:31:45,850
or you know some other library we

00:31:43,570 --> 00:31:49,240
implement an instance of that for our

00:31:45,850 --> 00:31:52,830
class we put that somewhere in implicit

00:31:49,240 --> 00:31:55,590
scope so that the compiler can find it

00:31:52,830 --> 00:31:57,340
either as a type constraint or

00:31:55,590 --> 00:32:00,400
explicitly writing our evidence

00:31:57,340 --> 00:32:01,900
parameter ourselves we pass it to the

00:32:00,400 --> 00:32:04,900
function that we want to we want to use

00:32:01,900 --> 00:32:07,700
that thing from and we can call methods

00:32:04,900 --> 00:32:12,620
on that interface

00:32:07,700 --> 00:32:16,460
so here's a Nadder phrase I make an int

00:32:12,620 --> 00:32:18,380
adder for intz okay so I have an adder

00:32:16,460 --> 00:32:21,650
for a's and it's going to add two a's

00:32:18,380 --> 00:32:23,960
and return an A and so I can make an

00:32:21,650 --> 00:32:26,300
instance of that for intz that's gonna

00:32:23,960 --> 00:32:29,840
add two int and return an int just by

00:32:26,300 --> 00:32:33,830
delegating to regular plus I'm gonna put

00:32:29,840 --> 00:32:36,200
it in implicit scope as a vowel so then

00:32:33,830 --> 00:32:39,050
in some other place where I want to add

00:32:36,200 --> 00:32:43,630
things together I can say I want to add

00:32:39,050 --> 00:32:46,430
any T which has an adder context

00:32:43,630 --> 00:32:49,430
compiler will supply that adder of T

00:32:46,430 --> 00:32:52,760
when I call this with int with the adder

00:32:49,430 --> 00:32:55,060
for intz I can summon it with implicitly

00:32:52,760 --> 00:33:01,520
key word and then call add nothing on it

00:32:55,060 --> 00:33:02,990
so cool now if I have a pair pair case

00:33:01,520 --> 00:33:07,340
class that got two T's and I want to

00:33:02,990 --> 00:33:10,940
make an adder for pairs I want to say

00:33:07,340 --> 00:33:18,320
now that this is an adder four pairs of

00:33:10,940 --> 00:33:19,610
things which have adders okay so the way

00:33:18,320 --> 00:33:23,810
I'm going to implement that is I'm going

00:33:19,610 --> 00:33:25,520
to grab the adder of T's that the

00:33:23,810 --> 00:33:26,960
compiler supplied to me I'm going to

00:33:25,520 --> 00:33:28,400
delegate that to add the first two

00:33:26,960 --> 00:33:30,080
things together add the second two

00:33:28,400 --> 00:33:31,940
things together return the pair of the

00:33:30,080 --> 00:33:34,040
two things and I don't need to have

00:33:31,940 --> 00:33:37,030
known what this T was this could have

00:33:34,040 --> 00:33:42,140
been an adder of in sanad or a pair of

00:33:37,030 --> 00:33:44,650
of doubles an adder of lists an adder of

00:33:42,140 --> 00:33:48,200
some crazy domain type that you have

00:33:44,650 --> 00:33:52,160
where add means who the heck knows in

00:33:48,200 --> 00:33:54,980
your domain and now I can add pairs of

00:33:52,160 --> 00:33:59,200
those things together by delegating to

00:33:54,980 --> 00:33:59,200
the the adder for that T

00:33:59,860 --> 00:34:04,690
so let's let's talk briefly about what's

00:34:02,260 --> 00:34:08,740
going to change with this in dotty and

00:34:04,690 --> 00:34:12,700
Scala three short answer here is little

00:34:08,740 --> 00:34:14,379
or none so Martin said and I'm not sure

00:34:12,700 --> 00:34:17,020
if he used quite these words he use

00:34:14,379 --> 00:34:19,629
these words in in Berlin Scala 3 is

00:34:17,020 --> 00:34:23,800
fundamentally the same language as Scala

00:34:19,629 --> 00:34:26,580
2 so variance and tight bounds still

00:34:23,800 --> 00:34:28,179
exist they're essentially the same

00:34:26,580 --> 00:34:29,889
everything that you just learned about

00:34:28,179 --> 00:34:32,889
covariance contravariance and invariance

00:34:29,889 --> 00:34:35,290
is going to be the same everything that

00:34:32,889 --> 00:34:37,270
we just saw about upper bounds lower

00:34:35,290 --> 00:34:40,389
bounds and context bounds are going to

00:34:37,270 --> 00:34:43,119
be the same the current version of dot e

00:34:40,389 --> 00:34:45,129
of dot c gives slightly different error

00:34:43,119 --> 00:34:47,679
messages of these we may see the error

00:34:45,129 --> 00:34:51,369
messages continue to evolve as those

00:34:47,679 --> 00:34:53,919
come closer to scala three existential

00:34:51,369 --> 00:34:57,129
types go away but there will be other

00:34:53,919 --> 00:35:01,599
type lambda stuff to get that same kind

00:34:57,129 --> 00:35:03,780
of thing so structural types which I

00:35:01,599 --> 00:35:07,570
didn't really talk about but that's a

00:35:03,780 --> 00:35:10,690
essentially duck typing sort of thing

00:35:07,570 --> 00:35:13,470
you say give me anything that has this

00:35:10,690 --> 00:35:15,670
method or that has this this shape

00:35:13,470 --> 00:35:17,200
they're still going to exist the

00:35:15,670 --> 00:35:19,240
implementation details are going to be

00:35:17,200 --> 00:35:21,599
different it's going to be interesting

00:35:19,240 --> 00:35:24,790
to see how usage of those evolves

00:35:21,599 --> 00:35:27,700
because in the two 12's sorry you know

00:35:24,790 --> 00:35:31,320
in the 2x line those are implemented

00:35:27,700 --> 00:35:33,609
with run time in run time introspection

00:35:31,320 --> 00:35:36,580
so they incurred definitely a

00:35:33,609 --> 00:35:40,570
performance hit and so they haven't been

00:35:36,580 --> 00:35:42,700
used too extensively but we'll see with

00:35:40,570 --> 00:35:45,900
with type lambdas and so on if those are

00:35:42,700 --> 00:35:45,900
become more useful

00:35:46,530 --> 00:35:52,300
so a couple of things I'd like you to

00:35:48,910 --> 00:35:55,030
take away from this so remember when

00:35:52,300 --> 00:35:56,980
you're coming to variance you're reading

00:35:55,030 --> 00:35:58,780
anything about variance they're gonna

00:35:56,980 --> 00:36:00,010
talk about subtyping and super typing

00:35:58,780 --> 00:36:01,750
but think about it in terms of

00:36:00,010 --> 00:36:06,550
substitution when can I substitute a

00:36:01,750 --> 00:36:08,890
thing into some other place it's really

00:36:06,550 --> 00:36:11,830
important that this isn't just a concept

00:36:08,890 --> 00:36:15,340
that somebody made up that Martin made

00:36:11,830 --> 00:36:18,270
up or that somebody made up in the Java

00:36:15,340 --> 00:36:20,890
space or anything this arises naturally

00:36:18,270 --> 00:36:23,230
you know I showed how Liskov

00:36:20,890 --> 00:36:24,910
substitution tells us when we can

00:36:23,230 --> 00:36:27,940
substitute a thing for another thing and

00:36:24,910 --> 00:36:31,570
that led us to places where it was

00:36:27,940 --> 00:36:33,940
natural to pass in a subtype or pass in

00:36:31,570 --> 00:36:36,730
a supertype and I think this is part of

00:36:33,940 --> 00:36:38,410
the reason that people get mixed up with

00:36:36,730 --> 00:36:40,120
this when they run into Jackie's problem

00:36:38,410 --> 00:36:42,270
they're trying to do something that

00:36:40,120 --> 00:36:44,410
seems really natural that seems

00:36:42,270 --> 00:36:47,490
intuitive to them and they don't

00:36:44,410 --> 00:36:50,860
understand why I had to mark this as

00:36:47,490 --> 00:36:52,570
covariant in order for this to to work

00:36:50,860 --> 00:36:53,400
the way that my intuition says it should

00:36:52,570 --> 00:36:55,570
work

00:36:53,400 --> 00:36:58,600
so skl has really given us the

00:36:55,570 --> 00:37:01,630
opportunity there to be really clear in

00:36:58,600 --> 00:37:03,850
our intent even though in a lot of cases

00:37:01,630 --> 00:37:05,860
we expect it to work with a certain a

00:37:03,850 --> 00:37:07,780
certain intuition Scala expects us to

00:37:05,860 --> 00:37:10,780
tell us that it's going to use that

00:37:07,780 --> 00:37:13,000
intuition and so this this concept is

00:37:10,780 --> 00:37:17,560
really deeply entwined with subclassing

00:37:13,000 --> 00:37:22,270
as as a concept right as a theoretical

00:37:17,560 --> 00:37:24,130
concept so with bounds we can use bounds

00:37:22,270 --> 00:37:27,040
to help us get around some of our

00:37:24,130 --> 00:37:31,330
variance problems by widening or

00:37:27,040 --> 00:37:33,430
narrowing and bounds interact with

00:37:31,330 --> 00:37:35,110
implicit Svea context bounds and give

00:37:33,430 --> 00:37:39,910
rise to patterns like the type class

00:37:35,110 --> 00:37:43,420
pattern so so all these things are deep

00:37:39,910 --> 00:37:46,750
and useful features that operate with

00:37:43,420 --> 00:37:50,820
one another in a subtle way and they're

00:37:46,750 --> 00:37:50,820
much more I think than just esoterica

00:37:51,400 --> 00:37:57,490
so you can find my Twitter I will be

00:37:54,940 --> 00:38:00,309
posting the slides somewhere and we'll

00:37:57,490 --> 00:38:03,599
announce them on there there are some

00:38:00,309 --> 00:38:06,599
examples from this talk in my github

00:38:03,599 --> 00:38:06,599

YouTube URL: https://www.youtube.com/watch?v=3tOMW2DkeS8


