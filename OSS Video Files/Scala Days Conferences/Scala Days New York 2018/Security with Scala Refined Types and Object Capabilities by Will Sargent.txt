Title: Security with Scala Refined Types and Object Capabilities by Will Sargent
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/security-with-scala-refined-types-and-object-capabilities
Captions: 
	00:00:04,910 --> 00:00:11,420
so my name is will Sargent I'm giving a

00:00:07,759 --> 00:00:13,570
talk on security and Scala specifically

00:00:11,420 --> 00:00:17,390
I'm giving a talk on how you implement

00:00:13,570 --> 00:00:20,810
security features in Scala using Scala

00:00:17,390 --> 00:00:23,600
specific types and using data structures

00:00:20,810 --> 00:00:27,200
so this is very much a talk about what

00:00:23,600 --> 00:00:29,900
sort of things you can do in Scala that

00:00:27,200 --> 00:00:32,469
make your application far more secure in

00:00:29,900 --> 00:00:35,090
general even if you're not necessarily

00:00:32,469 --> 00:00:38,510
looking to you know protect against an

00:00:35,090 --> 00:00:40,999
XSS attack or be able to render an HTML

00:00:38,510 --> 00:00:44,739
you know website or worried about Kafka

00:00:40,999 --> 00:00:47,539
etc these are still useful techniques so

00:00:44,739 --> 00:00:49,909
there are many new things here I will

00:00:47,539 --> 00:00:53,179
leave some time open for questions at

00:00:49,909 --> 00:00:55,999
the end but don't be worried if a lot of

00:00:53,179 --> 00:01:00,589
this is completely new to you I do have

00:00:55,999 --> 00:01:02,600
a guide up and I also have manuals and

00:01:00,589 --> 00:01:04,309
examples and things that actually go

00:01:02,600 --> 00:01:06,549
into much more detail about all of this

00:01:04,309 --> 00:01:09,070
so this is going to be high-level

00:01:06,549 --> 00:01:13,460
however this is going to be a fun ride

00:01:09,070 --> 00:01:15,590
so what is security in Scala and the way

00:01:13,460 --> 00:01:17,689
I'm defining security for now is just at

00:01:15,590 --> 00:01:20,600
a very high level we are going to

00:01:17,689 --> 00:01:23,299
validate untrusted input we are going to

00:01:20,600 --> 00:01:25,729
hide internal state and behavior we're

00:01:23,299 --> 00:01:28,969
going to deny functionality to attack us

00:01:25,729 --> 00:01:30,680
so what all that means is for any

00:01:28,969 --> 00:01:33,439
application that you're going to use

00:01:30,680 --> 00:01:35,719
you're going to be using these basic

00:01:33,439 --> 00:01:37,159
techniques you want basically you want

00:01:35,719 --> 00:01:39,469
to make sure that whatever you're doing

00:01:37,159 --> 00:01:41,479
nobody else can do it unless they're

00:01:39,469 --> 00:01:43,640
supposed to be able to do it and you

00:01:41,479 --> 00:01:46,189
want to make sure that no matter what

00:01:43,640 --> 00:01:48,049
you're not taking something that

00:01:46,189 --> 00:01:49,700
somebody gives you for granted you're

00:01:48,049 --> 00:01:51,109
checking everything on the way in you're

00:01:49,700 --> 00:01:53,960
checking things on the way out and

00:01:51,109 --> 00:01:58,640
you're denying functionality to people

00:01:53,960 --> 00:02:01,670
who you think look suspicious so this

00:01:58,640 --> 00:02:03,859
the sort of decisions that we make and

00:02:01,670 --> 00:02:06,829
the sort of design that we do in

00:02:03,859 --> 00:02:09,140
object-oriented programming a lot of

00:02:06,829 --> 00:02:11,230
this is actually inherently security

00:02:09,140 --> 00:02:14,260
decisions from the point of view of

00:02:11,230 --> 00:02:17,270
saying what it is that we want to expose

00:02:14,260 --> 00:02:18,230
what it is that we want to hide so we

00:02:17,270 --> 00:02:21,379
talked about how were they

00:02:18,230 --> 00:02:24,409
well that that is an essential part of

00:02:21,379 --> 00:02:26,900
programming we talked about deciding

00:02:24,409 --> 00:02:28,489
what is visible that's abstraction we

00:02:26,900 --> 00:02:30,920
talked about deciding what's hidden and

00:02:28,489 --> 00:02:33,440
that's encapsulation and then we talked

00:02:30,920 --> 00:02:35,420
about access control that is all about

00:02:33,440 --> 00:02:40,519
taking something that was working and

00:02:35,420 --> 00:02:42,170
turning it off and then the security

00:02:40,519 --> 00:02:45,410
tools that we have for doing a lot of

00:02:42,170 --> 00:02:49,400
this stuff we actually have more than

00:02:45,410 --> 00:02:50,989
are commonly used so one of the things

00:02:49,400 --> 00:02:53,170
I'm going to show you here is refinement

00:02:50,989 --> 00:02:56,410
types those are used for validation

00:02:53,170 --> 00:02:59,060
capabilities are used for abstraction

00:02:56,410 --> 00:03:01,790
because they show you how to do one

00:02:59,060 --> 00:03:03,049
specific thing encapsulation because

00:03:01,790 --> 00:03:06,319
they hide everything that they're not

00:03:03,049 --> 00:03:08,290
showing you and revocable access in that

00:03:06,319 --> 00:03:11,000
you can actually turn off the spigot

00:03:08,290 --> 00:03:13,910
there's another feature called dynamic

00:03:11,000 --> 00:03:17,420
sealing which allows you to encapsulate

00:03:13,910 --> 00:03:18,859
and hide information and data that you

00:03:17,420 --> 00:03:20,840
don't want to be passed around to

00:03:18,859 --> 00:03:23,090
anybody else while still being able to

00:03:20,840 --> 00:03:26,870
work with the reference and then we have

00:03:23,090 --> 00:03:29,209
membranes which are a fun feature which

00:03:26,870 --> 00:03:32,389
allow you to have operational isolations

00:03:29,209 --> 00:03:35,739
so they allow you to apply a policy over

00:03:32,389 --> 00:03:39,459
multiple objects and multiple references

00:03:35,739 --> 00:03:43,370
so starting off with refinement types

00:03:39,459 --> 00:03:45,769
what our refinement types well they are

00:03:43,370 --> 00:03:49,040
literally raw types that obey a

00:03:45,769 --> 00:03:50,480
predicate that is they will obey rules

00:03:49,040 --> 00:03:52,489
you know that when you're looking at

00:03:50,480 --> 00:03:54,889
this kind of thing when you're looking

00:03:52,489 --> 00:03:57,169
at something that's a refinement type

00:03:54,889 --> 00:04:00,380
that it already jumped through the

00:03:57,169 --> 00:04:02,889
appropriate hoops so you've got examples

00:04:00,380 --> 00:04:05,780
for all type you have a laser pointer I

00:04:02,889 --> 00:04:07,910
think that's just up okay so an example

00:04:05,780 --> 00:04:10,720
of a row type is string boolean

00:04:07,910 --> 00:04:13,310
character int and the collection API

00:04:10,720 --> 00:04:16,789
these things are unconstrained they

00:04:13,310 --> 00:04:18,380
could contain anything so you know

00:04:16,789 --> 00:04:20,539
obviously a boolean contains true or

00:04:18,380 --> 00:04:22,099
false but what does an integer contain

00:04:20,539 --> 00:04:24,500
if you're asking for an age it could be

00:04:22,099 --> 00:04:27,300
0 to 100 so you could be handled like

00:04:24,500 --> 00:04:29,730
minus 17 what does that mean

00:04:27,300 --> 00:04:33,390
string in particular is evil enough that

00:04:29,730 --> 00:04:36,060
we have string Li typed api's entering

00:04:33,390 --> 00:04:38,280
the lexicon because you can pass

00:04:36,060 --> 00:04:41,340
anything into a string and it's still a

00:04:38,280 --> 00:04:42,930
string it's still valid so if somebody

00:04:41,340 --> 00:04:43,850
decides to pass in the first chapter of

00:04:42,930 --> 00:04:49,680
Moby Dick

00:04:43,850 --> 00:04:51,600
well that's that's really on you so

00:04:49,680 --> 00:04:53,460
there is a library that's already in

00:04:51,600 --> 00:04:57,150
Scala for dealing with this

00:04:53,460 --> 00:04:58,710
it's called refined and I encourage

00:04:57,150 --> 00:05:02,040
everyone to download and check it out

00:04:58,710 --> 00:05:06,090
and in it implements refined types in

00:05:02,040 --> 00:05:08,370
Scala before you actually have a request

00:05:06,090 --> 00:05:10,740
parameter come in here and you want to

00:05:08,370 --> 00:05:12,720
say I think this is a zip code but I'm

00:05:10,740 --> 00:05:14,910
not really sure because you've got a

00:05:12,720 --> 00:05:16,560
string here not really doing any

00:05:14,910 --> 00:05:18,390
validation on it or even if you do you

00:05:16,560 --> 00:05:20,190
still get a string at the end what you

00:05:18,390 --> 00:05:22,860
want to do is turn string lis type code

00:05:20,190 --> 00:05:25,080
into strongly typed code and so what you

00:05:22,860 --> 00:05:27,570
can do here is you can specify I've got

00:05:25,080 --> 00:05:29,700
a string and I'm going to refine it by

00:05:27,570 --> 00:05:31,050
applying this predicate I'm going to

00:05:29,700 --> 00:05:34,320
make it match this regular expression

00:05:31,050 --> 00:05:37,530
here which consists of five integers and

00:05:34,320 --> 00:05:39,870
then once you have the zip code then you

00:05:37,530 --> 00:05:42,330
can say refine V and it passed it to you

00:05:39,870 --> 00:05:44,310
back in either with either string or zip

00:05:42,330 --> 00:05:45,780
code so you can see here we're running

00:05:44,310 --> 00:05:48,210
it through top we've got something

00:05:45,780 --> 00:05:50,520
that's a string we run it through and we

00:05:48,210 --> 00:05:53,280
get a zip code out here you only get

00:05:50,520 --> 00:05:56,700
access to this type if it validated

00:05:53,280 --> 00:05:58,440
correctly so you can't really get it

00:05:56,700 --> 00:06:01,650
wrong if you pass it through for a fine

00:05:58,440 --> 00:06:03,060
fee here and it didn't actually validate

00:06:01,650 --> 00:06:06,200
a zip code you get back a string

00:06:03,060 --> 00:06:09,540
containing the error message okay

00:06:06,200 --> 00:06:11,490
so that's the first step is we can

00:06:09,540 --> 00:06:15,330
validate our input such that we can

00:06:11,490 --> 00:06:18,030
constrain and narrow and ensure that

00:06:15,330 --> 00:06:19,500
input follow some checks now this isn't

00:06:18,030 --> 00:06:21,300
going to cover everything because it

00:06:19,500 --> 00:06:23,010
isn't going to cover things like you

00:06:21,300 --> 00:06:25,710
know is there a duplicate of this email

00:06:23,010 --> 00:06:27,630
or does this bit you know does this

00:06:25,710 --> 00:06:30,000
implement this kind of behavior which is

00:06:27,630 --> 00:06:31,740
time specific so you know after this

00:06:30,000 --> 00:06:34,050
date we actually changed this policy and

00:06:31,740 --> 00:06:36,360
it's no move out it won't handle the big

00:06:34,050 --> 00:06:37,790
cases but it'll certainly handle the

00:06:36,360 --> 00:06:40,440
small ones

00:06:37,790 --> 00:06:41,820
so you can't get a refine code you can't

00:06:40,440 --> 00:06:43,590
get a zip code without going for refined

00:06:41,820 --> 00:06:46,080
you can pass a zip code or anywhere

00:06:43,590 --> 00:06:49,530
around you can bust a string and you can

00:06:46,080 --> 00:06:52,970
nail it down so next we come to

00:06:49,530 --> 00:06:56,070
capabilities and capabilities are a

00:06:52,970 --> 00:06:59,670
security primitive that confers

00:06:56,070 --> 00:07:01,200
Authority by reference and we'll go into

00:06:59,670 --> 00:07:03,960
this in more detail and I'll show you

00:07:01,200 --> 00:07:05,990
some examples here but for now you just

00:07:03,960 --> 00:07:09,210
have to know if you have a capability

00:07:05,990 --> 00:07:11,670
then by definition it gives you

00:07:09,210 --> 00:07:16,170
authority to affect a resource in a

00:07:11,670 --> 00:07:17,760
specific way and what do we mean by

00:07:16,170 --> 00:07:20,990
capability what do you mean by Authority

00:07:17,760 --> 00:07:24,930
what I mean by resource well in Scala a

00:07:20,990 --> 00:07:27,900
resource is an object that has sensitive

00:07:24,930 --> 00:07:30,450
fields or methods we know that it has

00:07:27,900 --> 00:07:34,460
the goodies we know that we want to get

00:07:30,450 --> 00:07:37,350
to the goodies and with the capability a

00:07:34,460 --> 00:07:40,140
capability is the only way to get to

00:07:37,350 --> 00:07:42,870
those goodies so a capability is a

00:07:40,140 --> 00:07:46,500
reference to an object it doesn't have

00:07:42,870 --> 00:07:48,810
to be the resource specifically that can

00:07:46,500 --> 00:07:52,020
affect a resource that can affect that

00:07:48,810 --> 00:07:53,310
resource in a particular way so that's

00:07:52,020 --> 00:07:55,500
different from object-oriented

00:07:53,310 --> 00:07:57,960
programming because when we're talking

00:07:55,500 --> 00:08:00,600
about object-oriented programming it's

00:07:57,960 --> 00:08:03,240
really fundamentally about abstraction

00:08:00,600 --> 00:08:06,000
it's all about saying we've got a cake

00:08:03,240 --> 00:08:08,550
here's an eat method you can eat this

00:08:06,000 --> 00:08:10,920
and then finding out different ways that

00:08:08,550 --> 00:08:12,540
you can hook things together capability

00:08:10,920 --> 00:08:16,710
is actually kind of the inverse of that

00:08:12,540 --> 00:08:18,480
it says there is a cake absolutely but

00:08:16,710 --> 00:08:20,400
you don't have access to it we're not

00:08:18,480 --> 00:08:21,870
giving you a reference to this cake so

00:08:20,400 --> 00:08:23,820
you can't eat it there's no way you can

00:08:21,870 --> 00:08:25,560
call and that the eat method on this

00:08:23,820 --> 00:08:29,280
cake if you don't actually have a

00:08:25,560 --> 00:08:31,380
reference to it and to begin with so

00:08:29,280 --> 00:08:33,390
just to give you an example here we've

00:08:31,380 --> 00:08:35,430
got a capability we've got a document

00:08:33,390 --> 00:08:37,950
object that has a field that anyone can

00:08:35,430 --> 00:08:40,050
change so it's a bar that we just stuck

00:08:37,950 --> 00:08:41,669
in a class class and we want to expose

00:08:40,050 --> 00:08:46,050
the ability to change the name as a

00:08:41,669 --> 00:08:48,570
capability so we have a document here we

00:08:46,050 --> 00:08:49,100
have the VAR we have called Steve and

00:08:48,570 --> 00:08:51,259
we're just

00:08:49,100 --> 00:08:54,680
call it well and that's just as simple

00:08:51,259 --> 00:08:58,190
as it gets so what we do here is we take

00:08:54,680 --> 00:09:00,319
the document we make this private we

00:08:58,190 --> 00:09:03,500
create a private object capabilities

00:09:00,319 --> 00:09:06,199
internally here and we say we're gonna

00:09:03,500 --> 00:09:08,899
expose this changed name such that we

00:09:06,199 --> 00:09:11,839
can actually change this guy through

00:09:08,899 --> 00:09:16,699
this guy so because this is a private

00:09:11,839 --> 00:09:18,970
object nothing external to this class or

00:09:16,699 --> 00:09:22,430
to the singleton object the companion

00:09:18,970 --> 00:09:24,110
can actually touch this guy so if you

00:09:22,430 --> 00:09:26,089
try to look at a document by itself

00:09:24,110 --> 00:09:27,199
there's nothing you can touch you can't

00:09:26,089 --> 00:09:28,910
change the name because you don't have

00:09:27,199 --> 00:09:33,069
the access modifier won't allow you to

00:09:28,910 --> 00:09:37,550
do it and the definition of change name

00:09:33,069 --> 00:09:40,009
the name change is it's an abstract it's

00:09:37,550 --> 00:09:41,779
just a trace it calls change name we

00:09:40,009 --> 00:09:44,560
have taken string we taken the class ate

00:09:41,779 --> 00:09:47,600
a unit and we see here that we've got a

00:09:44,560 --> 00:09:49,940
companion object now we've got a name

00:09:47,600 --> 00:09:51,889
change which gives us access to it so

00:09:49,940 --> 00:09:53,660
what this does is because this isn't in

00:09:51,889 --> 00:09:56,569
a class because as a companion object

00:09:53,660 --> 00:09:59,240
this has access to the private field it

00:09:56,569 --> 00:10:02,300
has actually the private field object

00:09:59,240 --> 00:10:05,120
other capabilities and it can then get

00:10:02,300 --> 00:10:09,500
to the name changer so this provides you

00:10:05,120 --> 00:10:13,000
with access to expose a capability but

00:10:09,500 --> 00:10:15,170
this access itself is typically sealed

00:10:13,000 --> 00:10:19,509
so what this means is you have a

00:10:15,170 --> 00:10:23,269
document and then you set up access and

00:10:19,509 --> 00:10:25,399
if you call access name changer then

00:10:23,269 --> 00:10:28,699
that gives you a name changer for that

00:10:25,399 --> 00:10:30,350
document then you can call change name

00:10:28,699 --> 00:10:32,810
and that changes the name to will and

00:10:30,350 --> 00:10:34,850
then when she prints it out then you've

00:10:32,810 --> 00:10:37,639
got it and notice here we've got name

00:10:34,850 --> 00:10:39,589
changer but we don't know that this is

00:10:37,639 --> 00:10:43,399
necessarily connected to this resource

00:10:39,589 --> 00:10:45,740
so this is you know functional

00:10:43,399 --> 00:10:47,540
programming in and of itself in that

00:10:45,740 --> 00:10:50,180
you've this functionality can be

00:10:47,540 --> 00:10:52,790
completely abstracted from the resource

00:10:50,180 --> 00:10:55,009
and from the access itself you can take

00:10:52,790 --> 00:10:56,510
this and you can send it wherever you

00:10:55,009 --> 00:10:58,339
need to to get the work done

00:10:56,510 --> 00:11:00,560
and the only thing that will ever be

00:10:58,339 --> 00:11:06,019
able to do is change the name it can't

00:11:00,560 --> 00:11:09,500
do anything else so the name changer can

00:11:06,019 --> 00:11:11,839
affect the resource access to the

00:11:09,500 --> 00:11:13,760
resource itself doesn't mean you have

00:11:11,839 --> 00:11:16,190
capability I mean technically you could

00:11:13,760 --> 00:11:18,139
implement it as a trait the only way to

00:11:16,190 --> 00:11:20,839
get access to the name changer is

00:11:18,139 --> 00:11:23,500
through access which is sealed and note

00:11:20,839 --> 00:11:26,750
that this is a root root level

00:11:23,500 --> 00:11:28,940
capability we can't actually revoke this

00:11:26,750 --> 00:11:30,050
so if you're passing this out to

00:11:28,940 --> 00:11:32,000
something and you want to be able to

00:11:30,050 --> 00:11:34,130
take it back that is you want to turn

00:11:32,000 --> 00:11:36,860
something off then you'd usually is

00:11:34,130 --> 00:11:38,899
revocable so sealed and revocable are

00:11:36,860 --> 00:11:40,730
concepts that we all get to coming up in

00:11:38,899 --> 00:11:44,810
the next couple of slides we'll go into

00:11:40,730 --> 00:11:48,230
a bit more detail alright so that's a

00:11:44,810 --> 00:11:49,699
general case now practically speaking

00:11:48,230 --> 00:11:51,170
you're going to be looking at a crud

00:11:49,699 --> 00:11:53,240
repository you're gonna be looking at

00:11:51,170 --> 00:11:56,660
something which has a whole bunch of

00:11:53,240 --> 00:11:59,990
available methods so looking at the item

00:11:56,660 --> 00:12:04,310
repository I don't repository we allow

00:11:59,990 --> 00:12:10,910
anybody to create read update and delete

00:12:04,310 --> 00:12:13,010
any item and there's no real benefit for

00:12:10,910 --> 00:12:16,250
us to be able to allow anybody to do

00:12:13,010 --> 00:12:19,000
that in fact we'd rather be able to know

00:12:16,250 --> 00:12:21,620
exactly who has ability to delete things

00:12:19,000 --> 00:12:24,709
what's happening to read things and we

00:12:21,620 --> 00:12:26,959
may want to actually have logging and

00:12:24,709 --> 00:12:29,060
auditing and what-have-you attached to

00:12:26,959 --> 00:12:31,190
various different capabilities so we

00:12:29,060 --> 00:12:35,690
want to split this up so that this is

00:12:31,190 --> 00:12:37,100
actually far more fine-grained so if an

00:12:35,690 --> 00:12:39,440
operation is no need of delete

00:12:37,100 --> 00:12:42,500
functionality we're not going to give it

00:12:39,440 --> 00:12:44,000
it so while we're doing that

00:12:42,500 --> 00:12:46,730
let's make functional effects part of

00:12:44,000 --> 00:12:47,149
the API because we're try out okay sorry

00:12:46,730 --> 00:12:51,260
not sorry

00:12:47,149 --> 00:12:54,350
and so I can repository here I'm just

00:12:51,260 --> 00:12:56,269
doing the finder and updating methods so

00:12:54,350 --> 00:12:58,639
instead of having a kurd repository we

00:12:56,269 --> 00:13:01,170
are doing find and update we're not

00:12:58,639 --> 00:13:05,940
doing deletes and

00:13:01,170 --> 00:13:07,680
everyone so we've got this simple thing

00:13:05,940 --> 00:13:08,930
here we've got tagless final on the

00:13:07,680 --> 00:13:11,820
other end so we can turn this into

00:13:08,930 --> 00:13:14,040
either the thing itself or a try or a

00:13:11,820 --> 00:13:17,699
future if we need to we've got the same

00:13:14,040 --> 00:13:20,579
kind of pattern and we've got an item

00:13:17,699 --> 00:13:22,980
repository implementation here which

00:13:20,579 --> 00:13:25,589
goes through these methods a private

00:13:22,980 --> 00:13:29,370
I've just cut this into a seat Asik

00:13:25,589 --> 00:13:31,380
where it finds it for now and then we

00:13:29,370 --> 00:13:33,440
have a finder with ID which actually

00:13:31,380 --> 00:13:35,850
just returns the wrong thing itself so

00:13:33,440 --> 00:13:37,410
technically this could still throw an

00:13:35,850 --> 00:13:39,029
exception and cause side-effects and

00:13:37,410 --> 00:13:44,250
what-have-you but there are ways around

00:13:39,029 --> 00:13:47,160
this so when we actually invoke item

00:13:44,250 --> 00:13:48,990
repository here invoking the item

00:13:47,160 --> 00:13:52,290
repository we do the same thing we

00:13:48,990 --> 00:13:54,899
create the resource we set up access we

00:13:52,290 --> 00:13:58,199
ask for the capability that we want and

00:13:54,899 --> 00:14:00,540
then using the capability we get the

00:13:58,199 --> 00:14:02,070
thing that we actually wanted so here

00:14:00,540 --> 00:14:04,649
we're returning the item but we're not

00:14:02,070 --> 00:14:10,170
actually going through the resource okay

00:14:04,649 --> 00:14:13,529
make sense so far oh good all right so

00:14:10,170 --> 00:14:17,070
now we've got item repository with

00:14:13,529 --> 00:14:18,810
effects so what we can do is we've

00:14:17,070 --> 00:14:20,370
instead its instead of throwing an

00:14:18,810 --> 00:14:22,019
exception because we're calling a

00:14:20,370 --> 00:14:24,089
repository and that talks to a database

00:14:22,019 --> 00:14:25,800
and databases no exceptions and we lose

00:14:24,089 --> 00:14:27,930
the connection and things like that we

00:14:25,800 --> 00:14:30,660
want to actually wrap some behavior

00:14:27,930 --> 00:14:33,360
around that so what we can do is we can

00:14:30,660 --> 00:14:35,600
say we've got a try a try access here

00:14:33,360 --> 00:14:39,120
that's going to take the original access

00:14:35,600 --> 00:14:39,630
we're going to say this finder takes a

00:14:39,120 --> 00:14:42,089
try

00:14:39,630 --> 00:14:44,279
and then we're just going to wrap this

00:14:42,089 --> 00:14:46,260
functionality around try block in here

00:14:44,279 --> 00:14:48,569
and then we just have the same kind of

00:14:46,260 --> 00:14:51,209
thing we instead of doing an access we

00:14:48,569 --> 00:14:53,370
do a try access and instead of doing

00:14:51,209 --> 00:14:59,089
when we do a finder here we get back a

00:14:53,370 --> 00:15:03,209
try option item okay so finders sorry

00:14:59,089 --> 00:15:06,269
capabilities because they are very small

00:15:03,209 --> 00:15:09,140
units of functionality and because we

00:15:06,269 --> 00:15:12,390
can control the effects of capabilities

00:15:09,140 --> 00:15:14,610
extremely well they actually are an

00:15:12,390 --> 00:15:17,610
extremely good matchup for functional

00:15:14,610 --> 00:15:19,320
techniques precisely because you know

00:15:17,610 --> 00:15:21,390
exactly what's coming in and what's

00:15:19,320 --> 00:15:23,670
coming out you're not simply passing

00:15:21,390 --> 00:15:26,810
around this big bowl of behaviors you're

00:15:23,670 --> 00:15:29,910
very carefully targeting what you want

00:15:26,810 --> 00:15:31,860
now earlier I mentioned if you're

00:15:29,910 --> 00:15:33,360
handing something out and you're passing

00:15:31,860 --> 00:15:36,269
it out from an access it's a root-level

00:15:33,360 --> 00:15:39,209
capability usually when you are

00:15:36,269 --> 00:15:42,390
delegating something to somebody you are

00:15:39,209 --> 00:15:45,390
doing it in the context of a lifetime

00:15:42,390 --> 00:15:47,100
that is if somebody logs in then that

00:15:45,390 --> 00:15:51,180
person obviously has the right to

00:15:47,100 --> 00:15:53,760
changes his or her own password and you

00:15:51,180 --> 00:15:56,310
want them to be able to do that only as

00:15:53,760 --> 00:16:00,329
long as the users session is actually

00:15:56,310 --> 00:16:02,339
active so a capability you know you're

00:16:00,329 --> 00:16:03,779
looking at that yourself like it doesn't

00:16:02,339 --> 00:16:08,240
actually tell you when somebody's logged

00:16:03,779 --> 00:16:12,450
out so what we can do rather than simply

00:16:08,240 --> 00:16:15,540
hand them a raw capability is we can

00:16:12,450 --> 00:16:18,300
invoke we can call something called a

00:16:15,540 --> 00:16:21,529
revoke our app it in something called a

00:16:18,300 --> 00:16:25,440
revocable and we can get back a proxy

00:16:21,529 --> 00:16:28,440
which as long as a revoke method has not

00:16:25,440 --> 00:16:31,399
been called we'll Ford the original

00:16:28,440 --> 00:16:34,589
argument on to the original capability

00:16:31,399 --> 00:16:36,959
but if that exception if it's actually

00:16:34,589 --> 00:16:38,610
been revoked then every time you call it

00:16:36,959 --> 00:16:40,709
and you try to do something it will

00:16:38,610 --> 00:16:42,540
throw in a revoked exception that that

00:16:40,709 --> 00:16:46,170
pathway through to the original

00:16:42,540 --> 00:16:49,620
capability is no longer good and this is

00:16:46,170 --> 00:16:52,829
where we come to the library that I just

00:16:49,620 --> 00:16:55,290
made public like about an hour ago so

00:16:52,829 --> 00:16:58,860
I've got a folk apps library that

00:16:55,290 --> 00:17:01,860
implements revocable and revoke and

00:16:58,860 --> 00:17:04,140
whole bunch of utility methods which do

00:17:01,860 --> 00:17:07,380
all of this for you and set up a bunch

00:17:04,140 --> 00:17:09,150
of macros and the boilerplate so

00:17:07,380 --> 00:17:12,929
revocable example here we're importing

00:17:09,150 --> 00:17:16,140
the library we say we've got an ice item

00:17:12,929 --> 00:17:18,089
repository finder and we're going to say

00:17:16,140 --> 00:17:20,100
we want to be able to revoke this at

00:17:18,089 --> 00:17:22,740
some future point we get back a

00:17:20,100 --> 00:17:24,050
revocable which hands us back the proxy

00:17:22,740 --> 00:17:26,600
and our

00:17:24,050 --> 00:17:29,090
and we can then call revoke down here

00:17:26,600 --> 00:17:31,610
and then once we call revoke down here

00:17:29,090 --> 00:17:35,090
once we call find everything after that

00:17:31,610 --> 00:17:36,920
we'll throw an exception so the

00:17:35,090 --> 00:17:38,450
interesting thing about capabilities is

00:17:36,920 --> 00:17:41,090
that they're essentially functions with

00:17:38,450 --> 00:17:42,680
life cycle attached and it's one of

00:17:41,090 --> 00:17:44,660
those fuse cases where you actually do

00:17:42,680 --> 00:17:47,060
want the side-effect and you do want to

00:17:44,660 --> 00:17:49,700
be able to have things blow up and at

00:17:47,060 --> 00:17:52,940
any moment's notice because failure can

00:17:49,700 --> 00:17:54,590
happen and when that happens you go out

00:17:52,940 --> 00:17:59,530
and you ask for another capability again

00:17:54,590 --> 00:18:02,900
because you looked out so that is one

00:17:59,530 --> 00:18:06,620
revocable is by far the most commonly

00:18:02,900 --> 00:18:08,930
used way of working with abilities but

00:18:06,620 --> 00:18:11,630
it's not the only one there's a lot to

00:18:08,930 --> 00:18:14,090
go through and each of these has their

00:18:11,630 --> 00:18:15,910
own means and uses and background to it

00:18:14,090 --> 00:18:19,070
and all of that is set up in the manual

00:18:15,910 --> 00:18:22,820
in the capability guide we've got

00:18:19,070 --> 00:18:24,980
composition we take two capabilities and

00:18:22,820 --> 00:18:27,800
we squish them together so that they're

00:18:24,980 --> 00:18:30,140
actually returns a compound type we can

00:18:27,800 --> 00:18:32,750
do a tenure we can do attenuation here

00:18:30,140 --> 00:18:35,150
where we actually take something that

00:18:32,750 --> 00:18:37,690
has been squished already and we say we

00:18:35,150 --> 00:18:41,120
want to pull out one single capability

00:18:37,690 --> 00:18:43,640
we can do modulation where we say we've

00:18:41,120 --> 00:18:46,190
got something that's a Dewar here and we

00:18:43,640 --> 00:18:48,800
want a before and after method to be

00:18:46,190 --> 00:18:50,480
called through it and it looks the same

00:18:48,800 --> 00:18:56,060
to us and then finally we've got

00:18:50,480 --> 00:18:58,190
expiration which says this is a this is

00:18:56,060 --> 00:19:01,370
a capability which we are handing out

00:18:58,190 --> 00:19:03,950
which has some policy which after it

00:19:01,370 --> 00:19:06,890
after it happens the capability is

00:19:03,950 --> 00:19:10,070
revoked so that could be count based it

00:19:06,890 --> 00:19:13,220
could be timer based it could be you

00:19:10,070 --> 00:19:16,330
look suspicious based so here we've got

00:19:13,220 --> 00:19:19,970
an example saying we've got a revocable

00:19:16,330 --> 00:19:23,360
we are saying that this is Dewar

00:19:19,970 --> 00:19:26,210
and if this before we call any

00:19:23,360 --> 00:19:27,920
particular method on this Dewar we check

00:19:26,210 --> 00:19:31,850
to see if the deadlines over to you and

00:19:27,920 --> 00:19:33,680
if it is then we just revoke it so when

00:19:31,850 --> 00:19:34,310
you're handed this guy this expiring

00:19:33,680 --> 00:19:36,620
doer

00:19:34,310 --> 00:19:37,380
there's no way around it if you're

00:19:36,620 --> 00:19:39,870
handed this

00:19:37,380 --> 00:19:41,160
and it's past the deadline you're done

00:19:39,870 --> 00:19:43,640
you have to ask for another one

00:19:41,160 --> 00:19:48,480
and this is particularly useful in

00:19:43,640 --> 00:19:51,090
situations such as a co-worker's where

00:19:48,480 --> 00:19:53,190
you're passing around messages or things

00:19:51,090 --> 00:19:55,380
that might have a time of check time of

00:19:53,190 --> 00:19:58,380
use attack where somebody actually gets

00:19:55,380 --> 00:19:59,940
the credentials but then you know

00:19:58,380 --> 00:20:02,010
somebody else was actually recording

00:19:59,940 --> 00:20:05,550
those credentials at the same time like

00:20:02,010 --> 00:20:07,770
that there is a there is a wireless

00:20:05,550 --> 00:20:09,360
garage door opener attack where like you

00:20:07,770 --> 00:20:11,460
push the button and somebody is actually

00:20:09,360 --> 00:20:12,930
listening in they can record it and they

00:20:11,460 --> 00:20:15,240
can actually play back the same thing

00:20:12,930 --> 00:20:18,720
like several days after you've actually

00:20:15,240 --> 00:20:21,150
gone through and left the building so

00:20:18,720 --> 00:20:23,310
this this actually limits that because

00:20:21,150 --> 00:20:25,560
you can say you have the credentials for

00:20:23,310 --> 00:20:27,570
the next 30 seconds if you didn't do the

00:20:25,560 --> 00:20:29,040
next 30 seconds you're probably an

00:20:27,570 --> 00:20:34,860
attacker because we want that thing to

00:20:29,040 --> 00:20:36,210
go so that's capabilities but we still

00:20:34,860 --> 00:20:37,920
have to talk about how we're going to

00:20:36,210 --> 00:20:39,960
get capabilities working through with

00:20:37,920 --> 00:20:42,510
everything else that isn't a capability

00:20:39,960 --> 00:20:44,160
because once you've got a capability you

00:20:42,510 --> 00:20:46,260
have to be really careful about how

00:20:44,160 --> 00:20:48,060
you're handing it around and we've got

00:20:46,260 --> 00:20:50,310
these things you know like we've got

00:20:48,060 --> 00:20:51,390
actor messages we're just passing them

00:20:50,310 --> 00:20:52,440
through and then think and look at the

00:20:51,390 --> 00:20:54,120
event stream

00:20:52,440 --> 00:20:56,700
we've got dependency injection

00:20:54,120 --> 00:20:58,230
frameworks where we you know stick

00:20:56,700 --> 00:21:02,250
everything in a bind and you can pull it

00:20:58,230 --> 00:21:04,470
out by the type by the class and so what

00:21:02,250 --> 00:21:08,010
we want to do is do dynamic sealing

00:21:04,470 --> 00:21:11,100
where dynamic sealing wraps an object in

00:21:08,010 --> 00:21:12,750
another class or any another object such

00:21:11,100 --> 00:21:16,530
that it can't be seen or tampered with

00:21:12,750 --> 00:21:19,560
until it's unsealed again so what this

00:21:16,530 --> 00:21:23,550
means is it's sort of like having

00:21:19,560 --> 00:21:25,290
private but you don't have to say I'm in

00:21:23,550 --> 00:21:27,000
a containing class in order to be able

00:21:25,290 --> 00:21:30,300
to get it you can actually choose your

00:21:27,000 --> 00:21:34,140
siblings so you have a sealer and you

00:21:30,300 --> 00:21:36,570
have a nun sealer and the sealer wraps

00:21:34,140 --> 00:21:38,760
something and returns you a box so

00:21:36,570 --> 00:21:41,040
returns you a sealed box or string and

00:21:38,760 --> 00:21:43,140
then you have an unsealer which takes a

00:21:41,040 --> 00:21:46,050
box or string and returns you the value

00:21:43,140 --> 00:21:47,760
and depending on how you arrange the

00:21:46,050 --> 00:21:51,930
Cielo and unsealer you

00:21:47,760 --> 00:21:55,320
get various different effects but you

00:21:51,930 --> 00:22:00,120
know them vastly most fun thing out of

00:21:55,320 --> 00:22:03,090
it is that you can get you you can

00:22:00,120 --> 00:22:05,940
ensure a lot of behavior that you would

00:22:03,090 --> 00:22:08,360
otherwise have to do with a PKI so you

00:22:05,940 --> 00:22:11,370
can do encryption signing and so forth

00:22:08,360 --> 00:22:14,820
so it's a very old idea it's actually

00:22:11,370 --> 00:22:16,590
like from 1973 but it's it is something

00:22:14,820 --> 00:22:17,450
which sort of takes a little bit of

00:22:16,590 --> 00:22:19,650
getting used to

00:22:17,450 --> 00:22:23,100
because when you're actually creating a

00:22:19,650 --> 00:22:24,900
brand here so you've got a brand we've

00:22:23,100 --> 00:22:27,150
got us drinking it here this is actually

00:22:24,900 --> 00:22:30,510
used for like reading the box we've got

00:22:27,150 --> 00:22:31,770
a sealer and unsealer we seal foo and we

00:22:30,510 --> 00:22:32,370
have a seal box and then we call

00:22:31,770 --> 00:22:36,540
unsealer

00:22:32,370 --> 00:22:38,430
and we get string as fuel again so this

00:22:36,540 --> 00:22:40,920
allows us to do things like rapid

00:22:38,430 --> 00:22:42,630
database connection because nobody needs

00:22:40,920 --> 00:22:43,740
to be able to get root level access to a

00:22:42,630 --> 00:22:46,770
database connection because it just

00:22:43,740 --> 00:22:49,440
makes a mess or everything we can use it

00:22:46,770 --> 00:22:51,030
to wrap access objects so that if you

00:22:49,440 --> 00:22:53,430
have something which returns a

00:22:51,030 --> 00:22:55,980
capability or gives you access through

00:22:53,430 --> 00:22:58,800
all the capabilities all of that can be

00:22:55,980 --> 00:23:00,840
wrapped in something that is sealed and

00:22:58,800 --> 00:23:02,430
then you keep the sickness the unsealer

00:23:00,840 --> 00:23:05,310
in a very safe place where only one

00:23:02,430 --> 00:23:07,770
thing can get to it you can do signing

00:23:05,310 --> 00:23:10,560
if you make the Selah publicly available

00:23:07,770 --> 00:23:12,870
so you can say this is you know a result

00:23:10,560 --> 00:23:14,280
and if I want to check this I can see

00:23:12,870 --> 00:23:16,950
that this particular object over here

00:23:14,280 --> 00:23:18,300
was the one that produced it and you can

00:23:16,950 --> 00:23:21,510
also do encryption where you can say

00:23:18,300 --> 00:23:24,420
anybody can send me anything and do so

00:23:21,510 --> 00:23:29,430
securely here is the sealer go ahead and

00:23:24,420 --> 00:23:31,560
seal this and sent it to me so just to

00:23:29,430 --> 00:23:33,440
give you an example here we've got a

00:23:31,560 --> 00:23:36,990
slightly more advanced case we've got

00:23:33,440 --> 00:23:39,990
food and we've got kin and we've got a

00:23:36,990 --> 00:23:42,990
can opener and so the sealer here is

00:23:39,990 --> 00:23:44,430
something which is implicit in a lot of

00:23:42,990 --> 00:23:47,940
this because we don't see it during

00:23:44,430 --> 00:23:50,280
normal access we create the the sealer

00:23:47,940 --> 00:23:53,370
and unsealer to say we're going to

00:23:50,280 --> 00:23:56,100
create a box of food now we're going to

00:23:53,370 --> 00:23:58,860
create a can opener here we create a can

00:23:56,100 --> 00:24:00,410
of spam which then see we can see is

00:23:58,860 --> 00:24:03,590
actually sealed here

00:24:00,410 --> 00:24:06,140
and then when we even when we opened the

00:24:03,590 --> 00:24:08,360
can using the can opener we can see that

00:24:06,140 --> 00:24:10,780
the food is spam that just gives you an

00:24:08,360 --> 00:24:13,570
idea of how you have passed around

00:24:10,780 --> 00:24:16,340
sensitive information say credentials

00:24:13,570 --> 00:24:20,930
that you would only want to particular

00:24:16,340 --> 00:24:24,830
objects to be available with - so that

00:24:20,930 --> 00:24:27,730
brings us to the last one which is

00:24:24,830 --> 00:24:33,530
membranes and membranes are a

00:24:27,730 --> 00:24:37,010
fascinating concept they are something

00:24:33,530 --> 00:24:38,540
which initially used to look at and

00:24:37,010 --> 00:24:41,030
you're like I'm not sure I understand

00:24:38,540 --> 00:24:42,320
this because the definition is and it's

00:24:41,030 --> 00:24:45,170
an extension of a forwarder that

00:24:42,320 --> 00:24:47,980
transitively imposes this policy on all

00:24:45,170 --> 00:24:53,150
references exchanged to the membrane and

00:24:47,980 --> 00:24:55,790
you might be thinking wait what so the

00:24:53,150 --> 00:24:58,610
best way to explain this is imagine that

00:24:55,790 --> 00:25:01,010
you've got a future of a and a future of

00:24:58,610 --> 00:25:02,060
B and then you know what you do if you

00:25:01,010 --> 00:25:05,600
want to get from one for the other

00:25:02,060 --> 00:25:08,390
you call flatmap a membrane is something

00:25:05,600 --> 00:25:11,120
which wraps everything such that you

00:25:08,390 --> 00:25:14,120
think that you're actually called you

00:25:11,120 --> 00:25:16,190
know you're working with a and B but

00:25:14,120 --> 00:25:19,010
what it actually does is it calls

00:25:16,190 --> 00:25:20,480
flatmap for you so every time you think

00:25:19,010 --> 00:25:24,380
you're working with the objects you're

00:25:20,480 --> 00:25:26,770
actually working through this thing okay

00:25:24,380 --> 00:25:30,530
and it's not it's not precisely that

00:25:26,770 --> 00:25:35,750
because it has actually based on message

00:25:30,530 --> 00:25:37,520
passing and dynamic languages and so

00:25:35,750 --> 00:25:40,330
it's not necessarily something that's

00:25:37,520 --> 00:25:42,680
easy to work into the JVM

00:25:40,330 --> 00:25:44,930
so all methods are wrapped in a membrane

00:25:42,680 --> 00:25:46,340
they can't escape it's commonly used in

00:25:44,930 --> 00:25:48,530
sound boxes like you see this in

00:25:46,340 --> 00:25:52,010
paralysis a lot where they basically

00:25:48,530 --> 00:25:54,170
have JavaScript that can run and then

00:25:52,010 --> 00:25:56,660
they have the browser internals but

00:25:54,170 --> 00:25:59,570
because the membrane and the

00:25:56,660 --> 00:26:02,240
capabilities that are exposed to the

00:25:59,570 --> 00:26:04,880
browser and the JavaScript are also very

00:26:02,240 --> 00:26:07,280
carefully separated that is the

00:26:04,880 --> 00:26:09,590
mechanism by which you have managed to

00:26:07,280 --> 00:26:11,570
avoid having javascript dig into your

00:26:09,590 --> 00:26:12,269
browser guts and display a calculator on

00:26:11,570 --> 00:26:15,690
it

00:26:12,269 --> 00:26:18,779
screen so it's used for uncooperative

00:26:15,690 --> 00:26:20,580
revocation the best way I can think of

00:26:18,779 --> 00:26:23,549
to actually do it in the JVM is using a

00:26:20,580 --> 00:26:26,159
bite body interceptor which allows you

00:26:23,549 --> 00:26:29,299
to modify the byte code under the hood

00:26:26,159 --> 00:26:31,799
so that's if your uncooperative but

00:26:29,299 --> 00:26:33,559
fundamentally type safety doesn't really

00:26:31,799 --> 00:26:35,849
mix well with message passing because

00:26:33,559 --> 00:26:38,009
they don't they're not the same they

00:26:35,849 --> 00:26:39,749
don't look the same you could probably

00:26:38,009 --> 00:26:41,339
do it in our practice if you got rid of

00:26:39,749 --> 00:26:45,119
act a selection or willing to you read

00:26:41,339 --> 00:26:47,820
it and not use it this is again

00:26:45,119 --> 00:26:50,489
something which you you if you're

00:26:47,820 --> 00:26:51,989
running somebody else's code and you're

00:26:50,489 --> 00:26:53,879
doing it in the sandbox I'm not sure I'd

00:26:51,989 --> 00:26:55,769
necessarily recommend this if you're

00:26:53,879 --> 00:26:58,139
running your own code and you're just

00:26:55,769 --> 00:27:00,479
basically saying I know that the actor

00:26:58,139 --> 00:27:02,429
will do this that and so forth then

00:27:00,479 --> 00:27:04,049
having something basically angels send

00:27:02,429 --> 00:27:08,539
messages backwards and forwards even to

00:27:04,049 --> 00:27:13,229
unknown actor peers is probably okay

00:27:08,539 --> 00:27:14,909
however because we actually talked about

00:27:13,229 --> 00:27:17,789
future a and future B and we talked

00:27:14,909 --> 00:27:20,549
about flat map and all that stuff you

00:27:17,789 --> 00:27:23,940
know I'm not saying that a membrane is

00:27:20,549 --> 00:27:26,609
dependently type monad but a membranes

00:27:23,940 --> 00:27:28,829
independently type monad so if you're

00:27:26,609 --> 00:27:30,719
willing to deal with working with an

00:27:28,829 --> 00:27:32,309
effect upfront and you're willing to

00:27:30,719 --> 00:27:34,079
wrap everything in that yourself

00:27:32,309 --> 00:27:36,779
basically you're doing cooperative

00:27:34,079 --> 00:27:40,309
replication then oh caps as a permeable

00:27:36,779 --> 00:27:42,539
membrane that has the same effect so

00:27:40,309 --> 00:27:45,509
just to give you an idea of how this

00:27:42,539 --> 00:27:47,639
works say that we've got a capable to

00:27:45,509 --> 00:27:49,219
capabilities here you've got a locale

00:27:47,639 --> 00:27:51,859
reader and we've got a time zone reader

00:27:49,219 --> 00:27:54,659
both of these using tagless final and

00:27:51,859 --> 00:27:56,339
then we've got a location we're just

00:27:54,659 --> 00:27:58,349
going to implement these by pulling out

00:27:56,339 --> 00:28:02,070
the thing which so we've got a look at

00:27:58,349 --> 00:28:05,339
all that go to time zone and we've got a

00:28:02,070 --> 00:28:06,899
permeable membrane so permeable membrane

00:28:05,339 --> 00:28:10,499
works exactly the same way that we're

00:28:06,899 --> 00:28:12,329
talking about the Tri access before only

00:28:10,499 --> 00:28:14,249
instead of working with the Tri access

00:28:12,329 --> 00:28:16,070
we're now working with a membrane access

00:28:14,249 --> 00:28:18,959
because we want the membrane effective

00:28:16,070 --> 00:28:22,119
so we've got a wrapper that wrapper is

00:28:18,959 --> 00:28:25,479
actually a dependently typed

00:28:22,119 --> 00:28:29,109
a dependent type of the membrane itself

00:28:25,479 --> 00:28:31,119
and it has map and flatmap internally

00:28:29,109 --> 00:28:33,099
and so anytime that we're actually

00:28:31,119 --> 00:28:34,689
calling the locale we just want to say

00:28:33,099 --> 00:28:36,399
we're going to wrap this and then we're

00:28:34,689 --> 00:28:39,519
going to return a wrapper of locale and

00:28:36,399 --> 00:28:42,959
a wrapper of timezone and so a wrapper

00:28:39,519 --> 00:28:47,199
of foo et cetera and what this means is

00:28:42,959 --> 00:28:48,939
we have a location here and we say we

00:28:47,199 --> 00:28:53,289
want to say that this has membrane

00:28:48,939 --> 00:28:55,419
access in here and then once we've

00:28:53,289 --> 00:28:57,009
actually got the membrane access this is

00:28:55,419 --> 00:28:59,589
a revoke of membrane so we know that we

00:28:57,009 --> 00:29:02,199
can call revoke on this then we can run

00:28:59,589 --> 00:29:03,819
through all of this stuff we can say

00:29:02,199 --> 00:29:06,629
that we have a time zone formatter and

00:29:03,819 --> 00:29:11,199
we can stick that into a wrapper and

00:29:06,629 --> 00:29:13,059
then we can say we want to get we want

00:29:11,199 --> 00:29:14,709
to pierce the membrane and then it

00:29:13,059 --> 00:29:19,449
returns as a formatted string in that

00:29:14,709 --> 00:29:21,879
particular time zone so alternatively if

00:29:19,449 --> 00:29:24,609
we want to revoke it we do exactly the

00:29:21,879 --> 00:29:26,799
same thing but we call revoke and then

00:29:24,609 --> 00:29:29,889
we can see that piercing that membrane

00:29:26,799 --> 00:29:32,229
causes of revocation immediately so this

00:29:29,889 --> 00:29:36,119
allows us to be able to do functional

00:29:32,229 --> 00:29:40,019
composition and capability replication

00:29:36,119 --> 00:29:45,159
through through black map Monette things

00:29:40,019 --> 00:29:47,019
so the question is if you have yeah if

00:29:45,159 --> 00:29:49,599
you have a million capabilities to grab

00:29:47,019 --> 00:29:53,709
or revoke how do you manage that that is

00:29:49,599 --> 00:29:57,519
a very good question the answer is that

00:29:53,709 --> 00:29:58,929
you don't deal with the raw so going

00:29:57,519 --> 00:30:02,679
back to the very first slide a

00:29:58,929 --> 00:30:05,169
capability is a security primitive and

00:30:02,679 --> 00:30:07,479
because it is a security primitive you

00:30:05,169 --> 00:30:09,459
have to build from the ground up so

00:30:07,479 --> 00:30:11,619
typically what you do is you're not

00:30:09,459 --> 00:30:14,829
working with the lowest based level of

00:30:11,619 --> 00:30:16,239
reader and writer so you have a finder

00:30:14,829 --> 00:30:18,609
and you have enough data on the item

00:30:16,239 --> 00:30:21,159
repository for example instead of

00:30:18,609 --> 00:30:23,709
actually handing out a finder and an up

00:30:21,159 --> 00:30:25,749
data to everything that wants it you

00:30:23,709 --> 00:30:28,329
would have things like a password up

00:30:25,749 --> 00:30:30,129
data which goes out finds the user and

00:30:28,329 --> 00:30:32,949
then you know if it's found the right

00:30:30,129 --> 00:30:34,930
user updates that user so that password

00:30:32,949 --> 00:30:39,070
updater takes a finder and update

00:30:34,930 --> 00:30:41,740
but you don't that isn't exposed so you

00:30:39,070 --> 00:30:44,230
work up the domain to your domain

00:30:41,740 --> 00:30:47,080
operations and then the domain

00:30:44,230 --> 00:30:50,170
operations that require finer grained

00:30:47,080 --> 00:30:53,110
capabilities downstream in turn have

00:30:50,170 --> 00:30:56,290
those so you yeah you you have to expose

00:30:53,110 --> 00:30:58,270
like your your fine-grained capabilities

00:30:56,290 --> 00:31:00,820
but then after that you wrap them up in

00:30:58,270 --> 00:31:02,680
a domain and then you expose them at the

00:31:00,820 --> 00:31:05,500
granularity that is convenient for you

00:31:02,680 --> 00:31:09,100
so a rest application for example has

00:31:05,500 --> 00:31:10,810
like can you call this rest method you

00:31:09,100 --> 00:31:11,920
can't call it you know like if you don't

00:31:10,810 --> 00:31:14,650
have this capability if you can't

00:31:11,920 --> 00:31:16,870
execute on it it doesn't matter exactly

00:31:14,650 --> 00:31:19,060
why you know like it doesn't matter

00:31:16,870 --> 00:31:21,520
which capability failed which cable here

00:31:19,060 --> 00:31:24,250
was revoked all you care about is I

00:31:21,520 --> 00:31:27,530
couldn't change my password great I hope

00:31:24,250 --> 00:31:30,030
you enjoyed the talk thank you

00:31:27,530 --> 00:31:30,030

YouTube URL: https://www.youtube.com/watch?v=wfbF5jQiAhQ


