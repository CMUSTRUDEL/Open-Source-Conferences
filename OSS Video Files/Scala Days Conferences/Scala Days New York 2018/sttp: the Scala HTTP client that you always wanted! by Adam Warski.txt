Title: sttp: the Scala HTTP client that you always wanted! by Adam Warski
Publication date: 2018-09-14
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/sttp-the-scala-http-client-that-you-always-wanted
Captions: 
	00:00:05,049 --> 00:00:11,120
everybody my name is Alan Adam Barsky

00:00:08,450 --> 00:00:13,129
thank you very much for coming I come

00:00:11,120 --> 00:00:14,599
from Warsaw Poland and I would like to

00:00:13,129 --> 00:00:17,720
talk a bit about the library I've been

00:00:14,599 --> 00:00:21,050
working on called HTTP which is a Scala

00:00:17,720 --> 00:00:23,180
HTTP client so there will be a couple of

00:00:21,050 --> 00:00:25,309
slides but most of the talk will be live

00:00:23,180 --> 00:00:26,860
coding if you would have any questions I

00:00:25,309 --> 00:00:30,230
would like to see any particular aspect

00:00:26,860 --> 00:00:34,550
does let me know during the talk and we

00:00:30,230 --> 00:00:36,980
can always try it out live ok so if you

00:00:34,550 --> 00:00:39,290
hear about a Scholastic plant especially

00:00:36,980 --> 00:00:41,510
any one you may start wonder why would

00:00:39,290 --> 00:00:46,070
anybody actually do that there's quite a

00:00:41,510 --> 00:00:48,230
lot of those out there and so if example

00:00:46,070 --> 00:00:52,010
this dispatch which was historically the

00:00:48,230 --> 00:00:55,520
first one out there it was the original

00:00:52,010 --> 00:00:58,340
version was using a number of symbolic

00:00:55,520 --> 00:01:02,329
methods so people kind of made fun of it

00:00:58,340 --> 00:01:05,269
a bit now it's changed the play WS which

00:01:02,329 --> 00:01:05,750
is now a standalone library also an HTTP

00:01:05,269 --> 00:01:08,360
client

00:01:05,750 --> 00:01:10,969
there's archives TP which also has a

00:01:08,360 --> 00:01:13,520
client component there's ecology and a

00:01:10,969 --> 00:01:15,649
number of other libraries and however

00:01:13,520 --> 00:01:18,139
all of the cyber-snack they take

00:01:15,649 --> 00:01:20,119
different approaches to what api they

00:01:18,139 --> 00:01:23,509
offer what execution models they offer

00:01:20,119 --> 00:01:25,549
and so on and so every time I was using

00:01:23,509 --> 00:01:28,009
one of those I was lacking in some

00:01:25,549 --> 00:01:31,369
respect especially on the API side so I

00:01:28,009 --> 00:01:32,509
always thought that the API and the the

00:01:31,369 --> 00:01:35,240
way you actually interact with the

00:01:32,509 --> 00:01:38,380
library could be better so here's my

00:01:35,240 --> 00:01:41,990
take on how we can actually try to make

00:01:38,380 --> 00:01:46,189
to make the API better so there's a

00:01:41,990 --> 00:01:50,450
couple of like main assumptions behind

00:01:46,189 --> 00:01:55,579
the project and and how the API is is

00:01:50,450 --> 00:01:57,490
designed so the way we describe requests

00:01:55,579 --> 00:02:00,079
or that will be like the main part of

00:01:57,490 --> 00:02:01,729
how we work with the library so they

00:02:00,079 --> 00:02:03,979
request this description should be

00:02:01,729 --> 00:02:07,579
immutable and so that you can actually

00:02:03,979 --> 00:02:10,130
share them in your code but it also

00:02:07,579 --> 00:02:11,660
means that once you have a request

00:02:10,130 --> 00:02:13,400
description you can treat it as a

00:02:11,660 --> 00:02:16,010
template and then customize it in

00:02:13,400 --> 00:02:17,360
multiple ways right and reuse the same

00:02:16,010 --> 00:02:19,970
template in

00:02:17,360 --> 00:02:21,140
multiple instances and so we would like

00:02:19,970 --> 00:02:23,150
to support both synchronous and

00:02:21,140 --> 00:02:24,800
asynchronous execution models so

00:02:23,150 --> 00:02:26,780
sometimes the synchronous way of

00:02:24,800 --> 00:02:30,170
executing requests you know the blocking

00:02:26,780 --> 00:02:32,030
way is the most convenient one like if

00:02:30,170 --> 00:02:34,160
you are trying to explore some API right

00:02:32,030 --> 00:02:36,410
you just wants to fire a request and get

00:02:34,160 --> 00:02:38,120
a response and that's it sometimes you

00:02:36,410 --> 00:02:39,860
are working like in a future base

00:02:38,120 --> 00:02:43,910
environment so we actually wanted to

00:02:39,860 --> 00:02:45,470
have a synchronous execution but first

00:02:43,910 --> 00:02:48,050
of all the API should be program as

00:02:45,470 --> 00:02:50,840
programmer friendly meaning that it

00:02:48,050 --> 00:02:53,180
should be easy to use simple to use it

00:02:50,840 --> 00:02:56,989
should be discoverable like using you

00:02:53,180 --> 00:02:58,790
know autocomplete pressing dot and then

00:02:56,989 --> 00:03:00,080
and getting and then getting lists

00:02:58,790 --> 00:03:01,820
should give you the methods that you

00:03:00,080 --> 00:03:04,400
would expect and the methods should

00:03:01,820 --> 00:03:07,610
actually do what you expect them and to

00:03:04,400 --> 00:03:09,230
do and finally they request depth

00:03:07,610 --> 00:03:11,090
description the definition of the

00:03:09,230 --> 00:03:12,950
request should be separate from the way

00:03:11,090 --> 00:03:15,620
the requests are executed that's also

00:03:12,950 --> 00:03:21,470
connected with the various execution

00:03:15,620 --> 00:03:24,260
models and okay so that's these are the

00:03:21,470 --> 00:03:26,049
goals hopefully we'll be able to see at

00:03:24,260 --> 00:03:28,760
the end of the of the presentation if

00:03:26,049 --> 00:03:32,900
there are in any way successfully

00:03:28,760 --> 00:03:35,480
realized or not so Before we jump into

00:03:32,900 --> 00:03:37,519
code just a brief introduction of who's

00:03:35,480 --> 00:03:40,400
talking to you so as I said my name is

00:03:37,519 --> 00:03:42,440
Adam Barsky I'm and co-founded the

00:03:40,400 --> 00:03:44,330
software engineer at software MO which

00:03:42,440 --> 00:03:46,430
is a custom software development company

00:03:44,330 --> 00:03:49,220
in Poland we work with a lot of us

00:03:46,430 --> 00:03:52,370
clients also with knives from Europe and

00:03:49,220 --> 00:03:54,400
we use quite a lot of Scala in ng Java

00:03:52,370 --> 00:03:56,650
and other languages in various domains

00:03:54,400 --> 00:03:59,209
recently quite often it's a blockchain

00:03:56,650 --> 00:04:02,330
blockchain projects or machine learning

00:03:59,209 --> 00:04:04,040
projects we also send out a scalar times

00:04:02,330 --> 00:04:06,650
which is a scalar

00:04:04,040 --> 00:04:09,830
yeah we click on a newsletter if you

00:04:06,650 --> 00:04:12,049
don't know about it yet check it out I'm

00:04:09,830 --> 00:04:15,260
working on some open source protein

00:04:12,049 --> 00:04:18,109
source projects HTTP is one of them and

00:04:15,260 --> 00:04:20,660
sometimes I'm writing things on our

00:04:18,109 --> 00:04:22,750
company blog which is over here so also

00:04:20,660 --> 00:04:25,340
if you're invited to visit it

00:04:22,750 --> 00:04:28,520
ok so let's that's it for the

00:04:25,340 --> 00:04:31,729
introduction now let's let's actually

00:04:28,520 --> 00:04:35,930
start coding so we will create a scholar

00:04:31,729 --> 00:04:40,970
class with a very and magic name New

00:04:35,930 --> 00:04:42,889
York it will be an application so the

00:04:40,970 --> 00:04:44,780
first thing that you need to do when you

00:04:42,889 --> 00:04:48,259
want to work with HTTP is actually

00:04:44,780 --> 00:04:50,240
import the package so your import comes

00:04:48,259 --> 00:04:52,970
software a state repeated underscore and

00:04:50,240 --> 00:04:54,530
this gives you access to the a basic

00:04:52,970 --> 00:04:56,060
request definition and all the build the

00:04:54,530 --> 00:04:57,979
methods which we will use to actually

00:04:56,060 --> 00:05:00,500
describe the requests that you want to

00:04:57,979 --> 00:05:05,240
send okay so let's let's describe a very

00:05:00,500 --> 00:05:08,210
simple request so the starting the empty

00:05:05,240 --> 00:05:11,750
request that we will always be using is

00:05:08,210 --> 00:05:13,430
called HTTP so that's an empty request

00:05:11,750 --> 00:05:15,169
description okay so it's like a very

00:05:13,430 --> 00:05:17,870
basic request template which we can

00:05:15,169 --> 00:05:21,020
customize further so we start with HTTP

00:05:17,870 --> 00:05:23,990
and now we specify that we want to get

00:05:21,020 --> 00:05:26,860
we want to send a get a request to the

00:05:23,990 --> 00:05:30,349
given address the address will be HTTP I

00:05:26,860 --> 00:05:31,909
will be using a local server does in

00:05:30,349 --> 00:05:34,550
case internet doesn't work and the

00:05:31,909 --> 00:05:36,620
Sirocco server is running on port 80 to

00:05:34,550 --> 00:05:37,880
3 it has a couple of endpoints and which

00:05:36,620 --> 00:05:40,669
are just a mirroring

00:05:37,880 --> 00:05:42,710
and the the the input so that we can see

00:05:40,669 --> 00:05:45,830
that it's actually working so we will be

00:05:42,710 --> 00:05:47,419
hitting the echo get endpoint we can

00:05:45,830 --> 00:05:49,699
actually see how the server is

00:05:47,419 --> 00:05:51,229
implemented it's over here it's an ACK I

00:05:49,699 --> 00:05:53,840
should it be but that doesn't matter so

00:05:51,229 --> 00:05:57,590
you can see that here's the handler for

00:05:53,840 --> 00:06:00,020
the echo echo path rights if you get an

00:05:57,590 --> 00:06:03,830
echo request we should get a response

00:06:00,020 --> 00:06:06,710
containing all the parameters and end

00:06:03,830 --> 00:06:09,860
the path so we will see if that works ok

00:06:06,710 --> 00:06:12,620
so going back to our request description

00:06:09,860 --> 00:06:14,389
we want to get the following address and

00:06:12,620 --> 00:06:16,130
that's emitted right that's all that we

00:06:14,389 --> 00:06:20,800
actually need to do in the simplest form

00:06:16,130 --> 00:06:23,919
so that's a request write a request so

00:06:20,800 --> 00:06:26,330
so far we have only so when we actually

00:06:23,919 --> 00:06:27,349
invoke the get method over here we just

00:06:26,330 --> 00:06:30,229
create a description

00:06:27,349 --> 00:06:33,409
nothing happens yet right so to actually

00:06:30,229 --> 00:06:36,860
send the request we need a way we need

00:06:33,409 --> 00:06:40,040
some objective to actually specify how

00:06:36,860 --> 00:06:43,250
do we how the requests are sent

00:06:40,040 --> 00:06:47,060
and that's implemented in a back-end so

00:06:43,250 --> 00:06:49,880
here we'll be using a very simple

00:06:47,060 --> 00:06:52,280
synchronous back-end HTTP URL connection

00:06:49,880 --> 00:06:55,820
back-end okay that's built in it uses

00:06:52,280 --> 00:06:57,590
the HTTP URL connection class from which

00:06:55,820 --> 00:06:59,960
is which comes from average in every

00:06:57,590 --> 00:07:02,150
Java and it's a it's a synchronous

00:06:59,960 --> 00:07:05,150
back-end meaning that it's sending

00:07:02,150 --> 00:07:07,580
requests in a blocking way so now that

00:07:05,150 --> 00:07:10,100
we have both the request description and

00:07:07,580 --> 00:07:12,800
a back-end so which tells you how you

00:07:10,100 --> 00:07:16,220
can execute requests we can actually

00:07:12,800 --> 00:07:20,330
send it so we can do will print line the

00:07:16,220 --> 00:07:21,770
results request dot standard ok the send

00:07:20,330 --> 00:07:23,990
method over here takes an implicit

00:07:21,770 --> 00:07:28,460
parameter which is the back-end to use

00:07:23,990 --> 00:07:30,950
so we will be using the backend and as a

00:07:28,460 --> 00:07:32,390
result we will get a synchronous we will

00:07:30,950 --> 00:07:34,850
synchronously get the response

00:07:32,390 --> 00:07:37,880
so let's print out the body and let's

00:07:34,850 --> 00:07:42,890
try running it and hopefully it will it

00:07:37,880 --> 00:07:44,270
will work you will see later you will

00:07:42,890 --> 00:07:47,300
see later that's not a good question you

00:07:44,270 --> 00:07:49,850
wasted SAS and yes it did work as you

00:07:47,300 --> 00:07:52,160
can see over here ok so that's only one

00:07:49,850 --> 00:07:54,680
example of a back-end of a synchronous

00:07:52,160 --> 00:07:56,600
one so it's not very exciting let's now

00:07:54,680 --> 00:08:02,150
try using a different back-end so let's

00:07:56,600 --> 00:08:04,520
comment this out we can now use and use

00:08:02,150 --> 00:08:09,140
another back-end so now let's use the

00:08:04,520 --> 00:08:10,880
ocka ocka ocka HTTP back-end ok so now

00:08:09,140 --> 00:08:13,610
this back-end is different you can see

00:08:10,880 --> 00:08:17,180
that the code here stopped combining net

00:08:13,610 --> 00:08:19,460
because the akka back end actually sends

00:08:17,180 --> 00:08:21,410
the request in an asynchronous way so

00:08:19,460 --> 00:08:23,570
before we had the synchronous backend

00:08:21,410 --> 00:08:24,970
which was doing blocking calls now we

00:08:23,570 --> 00:08:27,470
have the awesome cleanest back-end and

00:08:24,970 --> 00:08:29,750
with that back-end the result of the

00:08:27,470 --> 00:08:31,850
send method will actually be a future

00:08:29,750 --> 00:08:33,410
right we will get the response sometime

00:08:31,850 --> 00:08:36,530
in the future when the asynchronous

00:08:33,410 --> 00:08:39,380
request completes so to actually do that

00:08:36,530 --> 00:08:43,540
we need to have create a for

00:08:39,380 --> 00:08:46,730
comprehension so to get the result and

00:08:43,540 --> 00:08:48,440
we will map over the future requests and

00:08:46,730 --> 00:08:52,160
and

00:08:48,440 --> 00:08:56,330
here we were simply print line unsafe

00:08:52,160 --> 00:08:58,460
body okay and once we are done we will

00:08:56,330 --> 00:08:59,690
close the back end because there's a

00:08:58,460 --> 00:09:02,450
thread pole over there which means

00:08:59,690 --> 00:09:06,350
closing otherwise our program will never

00:09:02,450 --> 00:09:08,000
terminate so let's try running that mm

00:09:06,350 --> 00:09:13,250
there's an implicit error because I

00:09:08,000 --> 00:09:17,900
forgot I forgot Scala concurrent

00:09:13,250 --> 00:09:21,070
execution context in places global or

00:09:17,900 --> 00:09:23,450
any other another execution context and

00:09:21,070 --> 00:09:25,490
and and it starts a bit longer because

00:09:23,450 --> 00:09:31,360
the thread point needs to be started but

00:09:25,490 --> 00:09:35,930
the result is is the same right sorry

00:09:31,360 --> 00:09:37,550
so if you use that form of creating the

00:09:35,930 --> 00:09:39,470
back end it will create an actor system

00:09:37,550 --> 00:09:41,480
for you if you have your own actor

00:09:39,470 --> 00:09:47,150
system you can pass it here as a

00:09:41,480 --> 00:09:51,290
parameter so there's a number of

00:09:47,150 --> 00:09:52,910
backends the the core library doesn't

00:09:51,290 --> 00:09:56,630
depend on anything it only depends on

00:09:52,910 --> 00:09:58,280
Java but it only provides the HTTP URL

00:09:56,630 --> 00:10:00,920
connection back-end right there's a

00:09:58,280 --> 00:10:02,870
module which depends on our car and it

00:10:00,920 --> 00:10:04,880
has the HTTP back-end but also other

00:10:02,870 --> 00:10:06,980
backends which I will show show later

00:10:04,880 --> 00:10:08,780
but yes well obviously if you want to

00:10:06,980 --> 00:10:12,440
use that cash to a back-end it uses it

00:10:08,780 --> 00:10:16,730
uses and I can look at an important

00:10:12,440 --> 00:10:19,460
thing about HTTP is that it's not really

00:10:16,730 --> 00:10:22,160
an HTTP client okay it's a wrapper

00:10:19,460 --> 00:10:25,220
around a number of other HTTP clients

00:10:22,160 --> 00:10:28,310
such as our HTTP basic HTTP client okay

00:10:25,220 --> 00:10:30,800
each HTTP right so all the hard all the

00:10:28,310 --> 00:10:32,950
hard work is delegated to the existing

00:10:30,800 --> 00:10:36,290
backends which you know differ in

00:10:32,950 --> 00:10:38,630
implementation details what STP provides

00:10:36,290 --> 00:10:44,060
is a unified API and a way to describe

00:10:38,630 --> 00:10:45,800
the requests okay and we also can send a

00:10:44,060 --> 00:10:48,320
more complicated request so for example

00:10:45,800 --> 00:10:51,920
let's say we want to send a post request

00:10:48,320 --> 00:10:54,410
so we will use the post method and here

00:10:51,920 --> 00:10:57,080
we then which can change the endpoints

00:10:54,410 --> 00:10:59,900
to post which will accept a post request

00:10:57,080 --> 00:11:01,230
and we can set the body to hello

00:10:59,900 --> 00:11:04,350
holidays

00:11:01,230 --> 00:11:06,750
and you can try running it so you can

00:11:04,350 --> 00:11:08,970
see that like sending a post with a body

00:11:06,750 --> 00:11:10,590
is exactly how you would expect it to be

00:11:08,970 --> 00:11:12,150
done right you use the post method then

00:11:10,590 --> 00:11:14,490
you specify the body with the body

00:11:12,150 --> 00:11:18,180
method so nothing nothing very

00:11:14,490 --> 00:11:21,060
complicated okay so let's once we have

00:11:18,180 --> 00:11:24,570
the basics done let's let's jump for a

00:11:21,060 --> 00:11:27,150
bit to another topic how the address is

00:11:24,570 --> 00:11:30,930
over here are created so you might have

00:11:27,150 --> 00:11:31,710
noticed that I'm using the URI prefix

00:11:30,930 --> 00:11:34,560
over here

00:11:31,710 --> 00:11:37,140
right so what does it really what does

00:11:34,560 --> 00:11:39,750
it redo so let's let's comment it out

00:11:37,140 --> 00:11:42,030
for now so you probably know string

00:11:39,750 --> 00:11:45,230
interpreters right so you can write s

00:11:42,030 --> 00:11:49,200
and then if you have Val X equal ten

00:11:45,230 --> 00:11:52,440
this is done right and it will so the

00:11:49,200 --> 00:11:55,530
string interpreter will embed will will

00:11:52,440 --> 00:11:57,720
enable embedding of values into into

00:11:55,530 --> 00:12:00,720
strings right and you can write your own

00:11:57,720 --> 00:12:04,200
interpreters and in this case there's

00:12:00,720 --> 00:12:06,170
your inter operator which has some

00:12:04,200 --> 00:12:10,110
features specific to constructing

00:12:06,170 --> 00:12:13,860
endpoint addresses so the simplest form

00:12:10,110 --> 00:12:16,710
if you just write an address right there

00:12:13,860 --> 00:12:19,200
so what this will actually give you is

00:12:16,710 --> 00:12:22,350
an instance of the URI class okay

00:12:19,200 --> 00:12:25,290
because we are using the interpreter the

00:12:22,350 --> 00:12:27,740
result is the an instance of the URI

00:12:25,290 --> 00:12:30,540
class we can see what the Euro class is

00:12:27,740 --> 00:12:31,650
it's actually a case class containing

00:12:30,540 --> 00:12:35,070
all the things that you would expect

00:12:31,650 --> 00:12:36,810
from the description of an address right

00:12:35,070 --> 00:12:39,240
so we have the scheme the host the port

00:12:36,810 --> 00:12:43,110
and so on so we can of course if you

00:12:39,240 --> 00:12:46,320
want to to specify the address over here

00:12:43,110 --> 00:12:49,080
right you can create the URI instance by

00:12:46,320 --> 00:12:50,730
hand or you can use the interpreter over

00:12:49,080 --> 00:12:53,370
here which will give you the an instance

00:12:50,730 --> 00:12:54,930
of that object okay but so far that's

00:12:53,370 --> 00:12:58,710
not it's not very interesting right it

00:12:54,930 --> 00:13:01,590
can only pass or it can parse a little

00:12:58,710 --> 00:13:03,090
string so that's not very exciting so

00:13:01,590 --> 00:13:05,880
let's try actually embedding some

00:13:03,090 --> 00:13:07,410
parameters right so of course you

00:13:05,880 --> 00:13:10,830
probably expect that we can actually

00:13:07,410 --> 00:13:11,920
embed parameters we can embed values as

00:13:10,830 --> 00:13:13,570
before

00:13:11,920 --> 00:13:16,180
right now when this gets more

00:13:13,570 --> 00:13:19,839
interesting if the values contain some

00:13:16,180 --> 00:13:24,579
special characters right such as hello

00:13:19,839 --> 00:13:26,529
world right so of course the space the

00:13:24,579 --> 00:13:28,570
white space isn't allowed and then

00:13:26,529 --> 00:13:30,519
you're right it needs to be escaped and

00:13:28,570 --> 00:13:35,980
that's exactly what you know what

00:13:30,519 --> 00:13:39,430
happens so we can see that the result

00:13:35,980 --> 00:13:41,490
actually uses the the plus right which

00:13:39,430 --> 00:13:44,050
is the proper way of encoding a space

00:13:41,490 --> 00:13:47,860
it's also a context sensitive so if we

00:13:44,050 --> 00:13:49,930
use the same the same value as a path

00:13:47,860 --> 00:13:52,269
component this space will be encoded

00:13:49,930 --> 00:13:54,970
using the percent an encoding because

00:13:52,269 --> 00:13:57,070
that's what the specification says that

00:13:54,970 --> 00:13:59,589
the white space needs to be differently

00:13:57,070 --> 00:14:03,389
encoded depending even if it's in the

00:13:59,589 --> 00:14:05,680
query or in the past okay so far so

00:14:03,389 --> 00:14:08,079
that's like the very basic functionality

00:14:05,680 --> 00:14:11,279
but it doesn't end over there so quite

00:14:08,079 --> 00:14:16,149
often we have multiple parameters and

00:14:11,279 --> 00:14:20,920
let's say we have two over here and some

00:14:16,149 --> 00:14:23,050
of them might be optional right so we we

00:14:20,920 --> 00:14:27,130
might end up you know gluing together

00:14:23,050 --> 00:14:29,470
the the addresses and adding the

00:14:27,130 --> 00:14:31,060
question marks and the UM persons

00:14:29,470 --> 00:14:32,740
depending of the parameters they are not

00:14:31,060 --> 00:14:33,459
it's the first parameter the second and

00:14:32,740 --> 00:14:36,100
so on and so on

00:14:33,459 --> 00:14:37,990
here you can have it automatically so if

00:14:36,100 --> 00:14:40,779
we have an optional parameter let's say

00:14:37,990 --> 00:14:44,410
this would be an option that's right and

00:14:40,779 --> 00:14:46,060
how are we an option of int so here we

00:14:44,410 --> 00:14:48,070
have an optional parameter here the

00:14:46,060 --> 00:14:50,680
parameter is defined so if the parameter

00:14:48,070 --> 00:14:54,370
is is defined if it's a sum it will be

00:14:50,680 --> 00:14:57,130
simply used in the address as is however

00:14:54,370 --> 00:15:00,880
if the parameter is none the parameter

00:14:57,130 --> 00:15:03,550
will be removed and as you can see here

00:15:00,880 --> 00:15:07,690
the euro is properly formatted right so

00:15:03,550 --> 00:15:12,040
the the dangling ampersand is is removed

00:15:07,690 --> 00:15:14,740
and it works also nicely for multiple

00:15:12,040 --> 00:15:18,279
parameters right it will well it will

00:15:14,740 --> 00:15:19,130
work as expected right same thing if you

00:15:18,279 --> 00:15:24,560
have

00:15:19,130 --> 00:15:27,230
map of parameters let's say p1 is 10 and

00:15:24,560 --> 00:15:31,490
parameter 2 is 20 right so we can simply

00:15:27,230 --> 00:15:33,260
embed the whole map over here and it

00:15:31,490 --> 00:15:38,330
will do the right thing meaning it will

00:15:33,260 --> 00:15:42,050
actually expand the parameters into a

00:15:38,330 --> 00:15:44,390
proper query and this works in a many

00:15:42,050 --> 00:15:50,840
other context so we can have a list of

00:15:44,390 --> 00:15:55,400
path would be a list of X Y Z and we can

00:15:50,840 --> 00:15:58,750
use this as as the path over here again

00:15:55,400 --> 00:16:02,600
it will be unrolled into into the path

00:15:58,750 --> 00:16:05,470
as you would expect right so that's

00:16:02,600 --> 00:16:08,210
that's the that's the way you can create

00:16:05,470 --> 00:16:10,220
addresses I think quite conveniently

00:16:08,210 --> 00:16:12,710
using the your interpreter you can

00:16:10,220 --> 00:16:15,250
interpolate every so you can embed

00:16:12,710 --> 00:16:18,140
values in any part of the URL the scheme

00:16:15,250 --> 00:16:21,260
the subdomains the subdomains can also

00:16:18,140 --> 00:16:23,240
form a list the pass the query and the

00:16:21,260 --> 00:16:25,880
fragment so all of the all of that is

00:16:23,240 --> 00:16:29,000
supported ok so now we know how to how

00:16:25,880 --> 00:16:32,420
to create addresses let's let's go back

00:16:29,000 --> 00:16:38,450
to let's go back to actually sending

00:16:32,420 --> 00:16:42,950
some some requests so let's comment that

00:16:38,450 --> 00:16:44,930
back in so we have seen a couple of we

00:16:42,950 --> 00:16:48,260
have seen a couple of methods for

00:16:44,930 --> 00:16:49,520
building requests but but usually of

00:16:48,260 --> 00:16:50,420
course the requests are much more

00:16:49,520 --> 00:16:53,120
complicated

00:16:50,420 --> 00:16:55,460
right so there's of course a number of

00:16:53,120 --> 00:16:58,640
atom e of other methods which actually

00:16:55,460 --> 00:17:01,580
allow you to and to build where they

00:16:58,640 --> 00:17:02,990
have money not okay there's a number of

00:17:01,580 --> 00:17:05,209
other methods which allow you to specify

00:17:02,990 --> 00:17:07,910
how the requests should should look like

00:17:05,209 --> 00:17:14,060
so for example we can have we can

00:17:07,910 --> 00:17:17,240
specify a header X my header and the

00:17:14,060 --> 00:17:21,410
value will be like anything right we can

00:17:17,240 --> 00:17:23,930
specify also so you can see that there's

00:17:21,410 --> 00:17:26,720
a number of these methods anything like

00:17:23,930 --> 00:17:30,470
content playing content type and so on

00:17:26,720 --> 00:17:32,910
and so on but what's quite specific to a

00:17:30,470 --> 00:17:34,770
CTP is it that you also specify how the

00:17:32,910 --> 00:17:37,800
response will be handled right so by

00:17:34,770 --> 00:17:40,800
default the response is always read into

00:17:37,800 --> 00:17:43,350
a string and that means that there's no

00:17:40,800 --> 00:17:47,010
danger of if you don't forget to consume

00:17:43,350 --> 00:17:49,710
like the the output of the Ray of the

00:17:47,010 --> 00:17:52,560
request there's no danger that it you

00:17:49,710 --> 00:17:54,240
will wreak some some resources so the

00:17:52,560 --> 00:17:56,760
way the response will be handled is part

00:17:54,240 --> 00:17:59,130
of the request of the request desk

00:17:56,760 --> 00:18:00,840
description but it can be customized as

00:17:59,130 --> 00:18:03,930
well so we can say that the response for

00:18:00,840 --> 00:18:06,480
example should be ignored so this will

00:18:03,930 --> 00:18:08,700
discard the response we can say that it

00:18:06,480 --> 00:18:11,790
should be saved into a string which is

00:18:08,700 --> 00:18:13,530
the default we can say that it should be

00:18:11,790 --> 00:18:16,710
saved to the file and there's a number

00:18:13,530 --> 00:18:19,170
of other other ways to do it so let's

00:18:16,710 --> 00:18:22,020
say we can never exam to say that we

00:18:19,170 --> 00:18:23,280
wants to get the byte array right and so

00:18:22,020 --> 00:18:24,900
there's a number of this method that you

00:18:23,280 --> 00:18:28,050
can use to customize the request and

00:18:24,900 --> 00:18:30,090
another nice thing is that you can use

00:18:28,050 --> 00:18:32,610
these methods in an order so it doesn't

00:18:30,090 --> 00:18:34,800
matter what what what the ordering here

00:18:32,610 --> 00:18:39,120
is meaning that you can create a request

00:18:34,800 --> 00:18:41,310
template with any characteristics of the

00:18:39,120 --> 00:18:42,720
request specified and specify the rest

00:18:41,310 --> 00:18:48,870
in the rest later

00:18:42,720 --> 00:18:53,400
ok so that's how you create templates ok

00:18:48,870 --> 00:18:58,350
once since we are at the handling of the

00:18:53,400 --> 00:19:01,950
responses and sending by setting bodies

00:18:58,350 --> 00:19:03,780
and and getting responses so if you want

00:19:01,950 --> 00:19:05,670
to set a body you also have quite a lot

00:19:03,780 --> 00:19:08,940
of options so you can for example send a

00:19:05,670 --> 00:19:11,940
file you can set a byte of array an

00:19:08,940 --> 00:19:14,370
input stream a string and so on but also

00:19:11,940 --> 00:19:16,890
quite often nowadays you we are you are

00:19:14,370 --> 00:19:19,470
working with various streaming libraries

00:19:16,890 --> 00:19:21,720
right so you maybe have an input stream

00:19:19,470 --> 00:19:24,600
that you actually would like as reactive

00:19:21,720 --> 00:19:26,570
stream of strings bite or well or

00:19:24,600 --> 00:19:29,700
whatever which actually wants to send

00:19:26,570 --> 00:19:31,860
today to the server so how do you do

00:19:29,700 --> 00:19:33,420
that well there's no variant which will

00:19:31,860 --> 00:19:35,730
actually allow you to then stream over

00:19:33,420 --> 00:19:37,620
here because there is no standard way of

00:19:35,730 --> 00:19:39,900
sending our active stream in Java right

00:19:37,620 --> 00:19:41,790
you always need to so there's there's a

00:19:39,900 --> 00:19:44,640
customs which is one way about the

00:19:41,790 --> 00:19:45,630
Emmonak streams are also reactive but

00:19:44,640 --> 00:19:47,580
they they

00:19:45,630 --> 00:19:49,620
completely different interfaces so

00:19:47,580 --> 00:19:52,710
there's no like way to do it in a

00:19:49,620 --> 00:19:54,630
generic way so you have to actually

00:19:52,710 --> 00:19:55,590
specialize for each each of the backends

00:19:54,630 --> 00:19:59,280
so how do you do that

00:19:55,590 --> 00:20:02,430
so let's say we have we have an arc a

00:19:59,280 --> 00:20:04,410
stream we're using a curve here this the

00:20:02,430 --> 00:20:07,860
arc a stream will be a very simple one

00:20:04,410 --> 00:20:13,470
but you know just as an example it will

00:20:07,860 --> 00:20:15,150
be an arc a source using white string

00:20:13,470 --> 00:20:18,750
which is the byte array which is better

00:20:15,150 --> 00:20:23,570
than a normal battery now hello it will

00:20:18,750 --> 00:20:28,530
consist of two segments and byte string

00:20:23,570 --> 00:20:30,930
okay mm okay so that's a here we have

00:20:28,530 --> 00:20:35,330
defined an example stream that we want

00:20:30,930 --> 00:20:38,310
to send as the body of the request okay

00:20:35,330 --> 00:20:40,710
so to actually send that stream

00:20:38,310 --> 00:20:44,060
we now have let's remove those because

00:20:40,710 --> 00:20:47,400
these are not important for the example

00:20:44,060 --> 00:20:49,290
we'll be using eco-post that's fine okay

00:20:47,400 --> 00:20:51,120
so now instead of the body method we

00:20:49,290 --> 00:20:52,680
have to specify that it's a streaming

00:20:51,120 --> 00:20:54,990
body so we will use the stream body

00:20:52,680 --> 00:20:58,290
method and we will get a new request

00:20:54,990 --> 00:21:01,860
description and I said I think if we

00:20:58,290 --> 00:21:10,640
actually try to run it if we try to run

00:21:01,860 --> 00:21:10,640
it why is it red there's the back end

00:21:11,390 --> 00:21:19,040
oh yeah right thank you yeah

00:21:15,530 --> 00:21:23,480
now it works so it's good that didn't

00:21:19,040 --> 00:21:26,240
compile because the type was wrong so so

00:21:23,480 --> 00:21:28,160
we can see that it it actually received

00:21:26,240 --> 00:21:31,460
the whole stream as we have as we have

00:21:28,160 --> 00:21:33,290
specified right okay so since we are at

00:21:31,460 --> 00:21:35,420
it since we add the types you may be

00:21:33,290 --> 00:21:37,840
wondering how how does it know like

00:21:35,420 --> 00:21:41,630
which types of stream are supported and

00:21:37,840 --> 00:21:43,940
what are the response like why why are

00:21:41,630 --> 00:21:45,679
we getting a future if we send using

00:21:43,940 --> 00:21:47,240
that Quebec and and I why are we getting

00:21:45,679 --> 00:21:50,210
a synchronous response if you are using

00:21:47,240 --> 00:21:53,059
the euro connection mekin right so this

00:21:50,210 --> 00:21:56,630
is all part of the backend type if we

00:21:53,059 --> 00:21:59,690
take a look at the at the Akash TV

00:21:56,630 --> 00:22:02,330
back-end for example and let's look at

00:21:59,690 --> 00:22:05,240
the definition at the top over here you

00:22:02,330 --> 00:22:07,490
can see that that's the best beckon

00:22:05,240 --> 00:22:09,799
implementation and some over here it

00:22:07,490 --> 00:22:11,540
extends the HTTP back-end which is like

00:22:09,799 --> 00:22:15,970
the base tray that every back-end has to

00:22:11,540 --> 00:22:15,970
extend and that the back end has yes

00:22:17,320 --> 00:22:20,320
sure

00:22:26,050 --> 00:22:35,870
the question is how does it know that I

00:22:33,310 --> 00:22:39,410
will that's what I was going to show if

00:22:35,870 --> 00:22:41,690
we try to use the HTTP URL connection

00:22:39,410 --> 00:22:47,060
back-end and we've tried to send the

00:22:41,690 --> 00:22:49,100
request over here okay just point it

00:22:47,060 --> 00:22:51,410
will it actually won't compile because

00:22:49,100 --> 00:22:53,690
the your connection back-end it doesn't

00:22:51,410 --> 00:22:56,030
support any kind of streaming and so

00:22:53,690 --> 00:22:58,730
this will only work if we actually use

00:22:56,030 --> 00:23:01,400
the the akka back-end and I will explain

00:22:58,730 --> 00:23:02,900
exactly how that works right now so now

00:23:01,400 --> 00:23:04,280
we can see that it complies because we

00:23:02,900 --> 00:23:06,740
are using a back-end which supports

00:23:04,280 --> 00:23:08,060
these kind of strings okay so so how do

00:23:06,740 --> 00:23:10,610
you know which kind of streams are

00:23:08,060 --> 00:23:13,640
supported if we go if we go to the

00:23:10,610 --> 00:23:15,650
backend definition over here right you

00:23:13,640 --> 00:23:17,900
can see that the type of the back-end it

00:23:15,650 --> 00:23:20,810
extends at the back end with two typed

00:23:17,900 --> 00:23:23,060
parameters the first type parameter is

00:23:20,810 --> 00:23:26,060
the wrapper in which the responses are

00:23:23,060 --> 00:23:27,560
wrapped okay so here it's a future right

00:23:26,060 --> 00:23:30,020
because every response will be wrapped

00:23:27,560 --> 00:23:32,330
in a future and the second type

00:23:30,020 --> 00:23:35,870
parameter is the type of streams that

00:23:32,330 --> 00:23:39,500
are supported right so this means that

00:23:35,870 --> 00:23:43,370
this back-end will accept a request now

00:23:39,500 --> 00:23:46,970
well can send requests a who might here

00:23:43,370 --> 00:23:50,270
which might use this type of streams

00:23:46,970 --> 00:23:52,340
either as to send the body or to receive

00:23:50,270 --> 00:23:54,260
the auto receive the response body right

00:23:52,340 --> 00:23:56,990
so that's the streaming type it's it's

00:23:54,260 --> 00:24:00,730
support and that's how the responses

00:23:56,990 --> 00:24:05,780
from erupt if we take a look at the HTTP

00:24:00,730 --> 00:24:08,210
HTTP URL connection back-end okay it's a

00:24:05,780 --> 00:24:10,730
bit simpler it doesn't support any kind

00:24:08,210 --> 00:24:12,830
of any kind of streaming so the second

00:24:10,730 --> 00:24:15,440
time parameter is nothing and the

00:24:12,830 --> 00:24:17,540
wrapper is identity so it's like no

00:24:15,440 --> 00:24:19,160
wrapper at all right the identity

00:24:17,540 --> 00:24:24,040
wrapper is again a very simple

00:24:19,160 --> 00:24:24,040
definition just the type arias

00:24:25,270 --> 00:24:33,040
okay is it clear how that works okay

00:24:28,550 --> 00:24:36,500
good now also other as I've mentioned

00:24:33,040 --> 00:24:39,679
for example this the acing httpclient

00:24:36,500 --> 00:24:42,650
monix back end so this back end and

00:24:39,679 --> 00:24:45,280
we'll wrap responses in monix tasks

00:24:42,650 --> 00:24:48,590
right if you are you if you have a

00:24:45,280 --> 00:24:52,130
programming stack which uses monix and

00:24:48,590 --> 00:24:55,610
not akka right you can use the same api

00:24:52,130 --> 00:24:57,350
to define the request and whenever you

00:24:55,610 --> 00:25:01,790
send a request the response will be

00:24:57,350 --> 00:25:03,620
wrapped in a task and the streaming it

00:25:01,790 --> 00:25:07,220
supports over here at the monix

00:25:03,620 --> 00:25:09,950
observables right so you can set the

00:25:07,220 --> 00:25:11,390
body which is an monix observable and

00:25:09,950 --> 00:25:13,850
you can receive the response money as a

00:25:11,390 --> 00:25:15,830
monic observable as well but you have to

00:25:13,850 --> 00:25:20,600
use that back end to make this actually

00:25:15,830 --> 00:25:25,820
work okay so that's that's the typing of

00:25:20,600 --> 00:25:32,480
the of the backends and now let's let's

00:25:25,820 --> 00:25:34,730
move on right another once it's so nice

00:25:32,480 --> 00:25:36,980
so now we know how how the types on the

00:25:34,730 --> 00:25:39,740
backend side work what about the types

00:25:36,980 --> 00:25:41,480
of the of the requests right so so far

00:25:39,740 --> 00:25:43,550
we have defined a request but we didn't

00:25:41,480 --> 00:25:45,470
see the type of the request and the type

00:25:43,550 --> 00:25:50,330
of the request is the one slightly

00:25:45,470 --> 00:25:52,070
complicated thing in in SCTP so this

00:25:50,330 --> 00:25:53,870
comprised fine right we are trying to

00:25:52,070 --> 00:25:56,480
send a request we have specified the

00:25:53,870 --> 00:26:01,970
endpoint and so on however if we try to

00:25:56,480 --> 00:26:04,520
comment out the the a method which

00:26:01,970 --> 00:26:06,230
specifies at the endpoint so which we

00:26:04,520 --> 00:26:09,230
comment that out the code will actually

00:26:06,230 --> 00:26:11,540
stop compiling right because you can't

00:26:09,230 --> 00:26:13,100
really send a request which has you know

00:26:11,540 --> 00:26:15,350
maybe it has some headers specified

00:26:13,100 --> 00:26:19,390
maybe it has the body specified but we

00:26:15,350 --> 00:26:21,380
don't but it it doesn't have the the

00:26:19,390 --> 00:26:23,780
endpoint specified right so that's

00:26:21,380 --> 00:26:26,660
clearly an error and you will get an

00:26:23,780 --> 00:26:27,980
compiler error and the error actually

00:26:26,660 --> 00:26:29,690
says it's probably too small for you to

00:26:27,980 --> 00:26:31,820
see but there are actually says that

00:26:29,690 --> 00:26:35,059
this is a partial request the method an

00:26:31,820 --> 00:26:37,669
URL are not specified so there is even

00:26:35,059 --> 00:26:38,520
some user friendliness over here so how

00:26:37,669 --> 00:26:41,730
does that work

00:26:38,520 --> 00:26:45,930
why what does the post method do that it

00:26:41,730 --> 00:26:48,630
stops code from compiling so let's try

00:26:45,930 --> 00:26:52,790
writing down some typed type request

00:26:48,630 --> 00:26:56,130
definitions so a very so the simplest

00:26:52,790 --> 00:26:58,970
requests are one which is the empty

00:26:56,130 --> 00:27:03,090
empty request will have type request

00:26:58,970 --> 00:27:07,200
well if we have type partial request

00:27:03,090 --> 00:27:10,560
which is the type ideas string nothing

00:27:07,200 --> 00:27:14,340
okay so we have two type parameters here

00:27:10,560 --> 00:27:16,650
again going from the end that's the type

00:27:14,340 --> 00:27:19,770
of the streams that the request requires

00:27:16,650 --> 00:27:21,420
from the back end right so here we don't

00:27:19,770 --> 00:27:23,310
really what we don't have any

00:27:21,420 --> 00:27:25,140
requirements on the back end as far as

00:27:23,310 --> 00:27:28,470
streaming is concerned right so it's

00:27:25,140 --> 00:27:30,390
it's nothing this this type parameter

00:27:28,470 --> 00:27:32,310
specifies how the response will be

00:27:30,390 --> 00:27:35,100
handled so that's the type to which the

00:27:32,310 --> 00:27:41,910
response will be read right if we now

00:27:35,100 --> 00:27:45,390
try to use response as byte array this

00:27:41,910 --> 00:27:46,830
will change this type parameter right so

00:27:45,390 --> 00:27:49,650
now we have to change the separator two

00:27:46,830 --> 00:27:54,630
byte array if we try to use a streaming

00:27:49,650 --> 00:27:59,280
body like this now we have to change

00:27:54,630 --> 00:28:05,190
this to a source of byte string not used

00:27:59,280 --> 00:28:08,750
if I'm not if I'm not mistaken let's

00:28:05,190 --> 00:28:10,740
let's see I never remember the accra

00:28:08,750 --> 00:28:12,980
archetypes Akane

00:28:10,740 --> 00:28:15,880
okay

00:28:12,980 --> 00:28:18,830
and okay so this complies as well so

00:28:15,880 --> 00:28:20,510
these are the two these are the two type

00:28:18,830 --> 00:28:23,779
parameters of a partial request right

00:28:20,510 --> 00:28:25,909
now if we let's actually remove that

00:28:23,779 --> 00:28:28,220
let's use the starting request so this

00:28:25,909 --> 00:28:33,409
will be a partial request of a string

00:28:28,220 --> 00:28:37,460
nothing now if if we actually specify

00:28:33,409 --> 00:28:38,870
the end point like over here right this

00:28:37,460 --> 00:28:40,820
will stop being a partial request

00:28:38,870 --> 00:28:43,010
because now the end point is specified

00:28:40,820 --> 00:28:45,409
and it's a request which we which we can

00:28:43,010 --> 00:28:48,320
actually send so it will now become a

00:28:45,409 --> 00:28:50,630
full a full request again with the same

00:28:48,320 --> 00:28:52,340
the type parameter specifying the how

00:28:50,630 --> 00:28:54,950
the response will be read and end this

00:28:52,340 --> 00:28:56,510
trimming requirements right and now the

00:28:54,950 --> 00:29:00,380
send method over here

00:28:56,510 --> 00:29:02,360
it has a restriction that the self type

00:29:00,380 --> 00:29:06,620
needs to be a request not a partial

00:29:02,360 --> 00:29:08,750
request okay how does that work when

00:29:06,620 --> 00:29:11,389
they the request type is actually type

00:29:08,750 --> 00:29:16,100
ideas so there's a type finals for a

00:29:11,389 --> 00:29:19,370
request tid so one does one more type

00:29:16,100 --> 00:29:21,740
parameter so the the full full request

00:29:19,370 --> 00:29:25,070
is a request T where the first type

00:29:21,740 --> 00:29:29,960
parameter is identity okay now a partial

00:29:25,070 --> 00:29:32,870
request it's called our zero and it will

00:29:29,960 --> 00:29:35,240
be empty string nothing okay

00:29:32,870 --> 00:29:36,950
a partial request will be a request T

00:29:35,240 --> 00:29:40,159
where the first type parameter is empty

00:29:36,950 --> 00:29:45,350
okay and this type parameter specifies

00:29:40,159 --> 00:29:49,549
how if if the URL is specified if we go

00:29:45,350 --> 00:29:51,139
to the request t case class again it's a

00:29:49,549 --> 00:29:52,880
very simple case class so once you

00:29:51,139 --> 00:29:54,919
actually create the request description

00:29:52,880 --> 00:29:57,169
you can inspect everything and that you

00:29:54,919 --> 00:30:00,139
have over there so we have the methods

00:29:57,169 --> 00:30:02,059
the body the headers some Lucas options

00:30:00,139 --> 00:30:04,130
how the response should be spaced how

00:30:02,059 --> 00:30:06,590
the response should be handled so all of

00:30:04,130 --> 00:30:08,539
that is part of a simple case that's

00:30:06,590 --> 00:30:10,700
what you can inspect and you can see the

00:30:08,539 --> 00:30:13,090
three type parameters over here right so

00:30:10,700 --> 00:30:15,289
going from then that's the streaming

00:30:13,090 --> 00:30:18,080
requirements and that's the type to

00:30:15,289 --> 00:30:19,639
which the response will be read and this

00:30:18,080 --> 00:30:22,190
type parameter specifies if the you are

00:30:19,639 --> 00:30:24,889
already specified right so if this this

00:30:22,190 --> 00:30:26,200
you over here is an identity so if we

00:30:24,889 --> 00:30:28,419
substitute identity

00:30:26,200 --> 00:30:30,609
for example over here right we will

00:30:28,419 --> 00:30:33,850
simply get a URI okay

00:30:30,609 --> 00:30:39,009
if the you over here is an empty and

00:30:33,850 --> 00:30:42,009
empty is a empty is an area's is a

00:30:39,009 --> 00:30:45,879
container which is always none right so

00:30:42,009 --> 00:30:49,029
if if that you will be that he will be

00:30:45,879 --> 00:30:51,399
empty that will resolve to non meaning

00:30:49,029 --> 00:30:53,529
that the URI is not specified okay

00:30:51,399 --> 00:30:56,139
so let's that's that's that's the whole

00:30:53,529 --> 00:31:00,039
trick and finally here in the same

00:30:56,139 --> 00:31:03,460
method we have we have a restriction

00:31:00,039 --> 00:31:07,600
which is an implicit witness specifying

00:31:03,460 --> 00:31:10,059
that that the you type parameter must be

00:31:07,600 --> 00:31:13,029
identity and not for example empty okay

00:31:10,059 --> 00:31:15,039
so that's you know just you don't really

00:31:13,029 --> 00:31:16,749
need to know exactly how this works to

00:31:15,039 --> 00:31:30,779
use the library is just so that you have

00:31:16,749 --> 00:31:30,779
the default picture okay editor yeah

00:31:32,860 --> 00:31:35,159
she

00:31:35,660 --> 00:31:46,970
oh the streaming t.t is the type of the

00:31:44,510 --> 00:31:48,950
response how do the type to which the

00:31:46,970 --> 00:31:51,830
response will be read okay

00:31:48,950 --> 00:31:54,170
this thing here needs the plus so that

00:31:51,830 --> 00:31:55,670
even if you have a back-end which

00:31:54,170 --> 00:31:57,350
support streaming you can still send the

00:31:55,670 --> 00:32:01,100
request which doesn't require any kind

00:31:57,350 --> 00:32:04,010
of streaming okay so let's that's the

00:32:01,100 --> 00:32:05,840
types of the ripest so if you need to

00:32:04,010 --> 00:32:08,300
you can always write down the types of

00:32:05,840 --> 00:32:10,040
the requests of course as well it I

00:32:08,300 --> 00:32:14,450
think it's slightly complicated but if

00:32:10,040 --> 00:32:16,150
you know it's so hopefully possible to

00:32:14,450 --> 00:32:19,700
to understand how that how that works

00:32:16,150 --> 00:32:23,420
all right so let's see we don't have

00:32:19,700 --> 00:32:25,370
that much time left so let me maybe show

00:32:23,420 --> 00:32:28,000
you how you can actually how and the

00:32:25,370 --> 00:32:31,010
errors that john was asking about so

00:32:28,000 --> 00:32:33,560
errors are quite common in HTTP right we

00:32:31,010 --> 00:32:36,140
when we when you make a request it's

00:32:33,560 --> 00:32:39,410
there's quite huge chances that the

00:32:36,140 --> 00:32:41,750
server will be down or something like

00:32:39,410 --> 00:32:45,650
that so let's see what happens if we try

00:32:41,750 --> 00:32:48,890
to actually hit an endpoint which isn't

00:32:45,650 --> 00:32:54,070
found let's let's use the synchronous

00:32:48,890 --> 00:32:59,030
back-end just for simplicity okay so

00:32:54,070 --> 00:33:02,990
request sent dot unsafe body print line

00:32:59,030 --> 00:33:06,320
and without a streaming body just a

00:33:02,990 --> 00:33:09,650
normal body not without anybody at all

00:33:06,320 --> 00:33:11,780
and it would be agate okay that's what

00:33:09,650 --> 00:33:13,190
our endpoint supports so now we are

00:33:11,780 --> 00:33:15,770
trying to hit an endpoint which will

00:33:13,190 --> 00:33:20,720
return a 404 right and you can see that

00:33:15,770 --> 00:33:21,860
we get an exception right because status

00:33:20,720 --> 00:33:23,600
code for a folder of course that

00:33:21,860 --> 00:33:27,380
resource could not be found right and

00:33:23,600 --> 00:33:31,720
why is that well we have if we if you

00:33:27,380 --> 00:33:34,160
try to to get a resource and you have

00:33:31,720 --> 00:33:34,940
specified how the response should be

00:33:34,160 --> 00:33:37,310
handled right

00:33:34,940 --> 00:33:39,260
you have only specifies how they respond

00:33:37,310 --> 00:33:41,180
should how the correct response should

00:33:39,260 --> 00:33:43,040
be handled right the error is usually a

00:33:41,180 --> 00:33:45,110
string like in most cases right so even

00:33:43,040 --> 00:33:46,669
if you know you want to get the save the

00:33:45,110 --> 00:33:50,179
response to fire

00:33:46,669 --> 00:33:51,679
it's f404 or and like a server error you

00:33:50,179 --> 00:33:52,940
probably don't want to do this right you

00:33:51,679 --> 00:33:55,789
don't want to handle this

00:33:52,940 --> 00:33:58,340
this 404 message as a file content right

00:33:55,789 --> 00:34:01,609
so this that's why the exception is and

00:33:58,340 --> 00:34:03,230
it's a that's why they and the method is

00:34:01,609 --> 00:34:04,909
called unsafe right because it might

00:34:03,230 --> 00:34:07,549
throw an exception if the server

00:34:04,909 --> 00:34:10,010
responded with an error they a safe way

00:34:07,549 --> 00:34:11,480
to do it is to use the dot body the

00:34:10,010 --> 00:34:12,020
third body will actually return an

00:34:11,480 --> 00:34:15,589
either

00:34:12,020 --> 00:34:18,559
okay so you can see that here the either

00:34:15,589 --> 00:34:21,290
is a left right because the in the

00:34:18,559 --> 00:34:24,799
response was unsuccessful we got an

00:34:21,290 --> 00:34:27,770
error so it doesn't matter how the body

00:34:24,799 --> 00:34:30,290
is is is deserialized so we can say that

00:34:27,770 --> 00:34:32,510
we want the response as a byte array for

00:34:30,290 --> 00:34:35,389
example this will actually always be a

00:34:32,510 --> 00:34:38,629
string right because it's usually the

00:34:35,389 --> 00:34:42,319
error message if we now try to hit an

00:34:38,629 --> 00:34:45,349
endpoint which will be a proper one echo

00:34:42,319 --> 00:34:48,020
get we will actually get a right value

00:34:45,349 --> 00:34:49,579
over here well with the byte array

00:34:48,020 --> 00:34:52,369
because that's how we wanted the request

00:34:49,579 --> 00:34:56,299
to be read okay so this is that's how

00:34:52,369 --> 00:34:58,880
you handle errors okay another a point

00:34:56,299 --> 00:35:03,650
important thing is testing right so

00:34:58,880 --> 00:35:05,359
where we can send the request nicely if

00:35:03,650 --> 00:35:06,740
we have the network but then in the test

00:35:05,359 --> 00:35:08,119
you probably don't want actually send

00:35:06,740 --> 00:35:09,829
the request over the network grass you

00:35:08,119 --> 00:35:11,890
want you you you need to have some way

00:35:09,829 --> 00:35:14,059
of actually testing that the

00:35:11,890 --> 00:35:17,480
descriptions of the requests that you

00:35:14,059 --> 00:35:19,849
have defined are correct okay and that's

00:35:17,480 --> 00:35:27,619
where there's a special back-end it's

00:35:19,849 --> 00:35:30,530
called the HTTP back-end stub and this

00:35:27,619 --> 00:35:33,920
allows you to create stop backends which

00:35:30,530 --> 00:35:37,280
will mock some some responses so we can

00:35:33,920 --> 00:35:39,230
create a stop back end for any kind of

00:35:37,280 --> 00:35:41,000
wrapper so if you are using a future it

00:35:39,230 --> 00:35:43,280
will be a future base back-end using

00:35:41,000 --> 00:35:45,049
test bit us miss back-end here will be

00:35:43,280 --> 00:35:46,670
just using a synchronous back-end and

00:35:45,049 --> 00:35:49,760
now we can specify the behavior of the

00:35:46,670 --> 00:35:52,579
stub so we can say that when the request

00:35:49,760 --> 00:35:55,030
matches so if we make a request where

00:35:52,579 --> 00:35:55,030
the pass

00:35:55,500 --> 00:36:06,940
docpath start with a list of XY right

00:36:02,819 --> 00:36:12,780
then we want to respond with okay and

00:36:06,940 --> 00:36:15,339
when the request matches then the header

00:36:12,780 --> 00:36:21,730
another specified header let's say that

00:36:15,339 --> 00:36:24,190
URI path starts with let's say Z then we

00:36:21,730 --> 00:36:26,260
want to respond then respond not found

00:36:24,190 --> 00:36:27,670
okay so this is our stop

00:36:26,260 --> 00:36:31,270
sorry back and stab and we can use it

00:36:27,670 --> 00:36:34,300
instead of the normal back end so we can

00:36:31,270 --> 00:36:40,359
now actually a print line requests dots

00:36:34,300 --> 00:36:43,030
and okay let's now send a request to XY

00:36:40,359 --> 00:36:47,470
right so this should respond with a 200

00:36:43,030 --> 00:36:49,510
okay and and it did right we can see the

00:36:47,470 --> 00:36:51,849
200 over here oh by the way I didn't

00:36:49,510 --> 00:36:54,550
show you the response class yet so the

00:36:51,849 --> 00:36:57,309
result of the send method is a response

00:36:54,550 --> 00:36:59,380
which is wrapped in the appropriate

00:36:57,309 --> 00:37:01,540
wrapper so the response again is a

00:36:59,380 --> 00:37:04,359
simple case class quite easy to work

00:37:01,540 --> 00:37:06,579
with it has the status code it has the

00:37:04,359 --> 00:37:09,369
status text it has the headers if you

00:37:06,579 --> 00:37:15,339
wants to access the response headers and

00:37:09,369 --> 00:37:19,359
the the body of the of the response to

00:37:15,339 --> 00:37:23,890
whatever it's DC deserialized if we now

00:37:19,359 --> 00:37:28,119
try to send a request to a an endpoint

00:37:23,890 --> 00:37:31,540
which which is specified here in the

00:37:28,119 --> 00:37:35,109
second and in the second stop definition

00:37:31,540 --> 00:37:37,240
you can see that we got a 404 right so I

00:37:35,109 --> 00:37:39,970
that's a quite useful thing for testing

00:37:37,240 --> 00:37:43,540
if you have the request description you

00:37:39,970 --> 00:37:45,579
know you can as always you know it's an

00:37:43,540 --> 00:37:46,869
immutable definition of how the record

00:37:45,579 --> 00:37:49,000
should be done and then we can use

00:37:46,869 --> 00:37:51,609
various back end so we can use an normal

00:37:49,000 --> 00:37:53,829
like an ID quebec and unix back-end

00:37:51,609 --> 00:37:55,390
whatever for your normal work and you

00:37:53,829 --> 00:37:57,190
can use to stop back end in tests to

00:37:55,390 --> 00:38:01,359
actually test that the request

00:37:57,190 --> 00:38:03,150
definition is is correct okay and one

00:38:01,359 --> 00:38:05,800
last thing which maybe I showed before

00:38:03,150 --> 00:38:09,910
before summing up

00:38:05,800 --> 00:38:12,220
is how to specify custom so how to

00:38:09,910 --> 00:38:15,790
disable eyes to custom types and to

00:38:12,220 --> 00:38:18,700
custom and how to send custom custom

00:38:15,790 --> 00:38:22,390
bodies so we can actually let's let's

00:38:18,700 --> 00:38:24,760
remove that so we can actually customize

00:38:22,390 --> 00:38:26,980
how the responses are this utilized for

00:38:24,760 --> 00:38:29,080
example let's say that we want to deter

00:38:26,980 --> 00:38:31,570
eyes response into a list of strings

00:38:29,080 --> 00:38:34,180
which will be in the words from the

00:38:31,570 --> 00:38:35,980
response so we can create a new

00:38:34,180 --> 00:38:38,550
specification of how responses should be

00:38:35,980 --> 00:38:42,610
handled so we can call it as words and

00:38:38,550 --> 00:38:44,410
the s words will take in the SS string a

00:38:42,610 --> 00:38:46,300
response which you know reads the

00:38:44,410 --> 00:38:50,110
response into a string and then we will

00:38:46,300 --> 00:38:52,950
map over it and splitting it by spaces

00:38:50,110 --> 00:38:55,290
right and now this this new

00:38:52,950 --> 00:38:59,410
specification it has a type which is a

00:38:55,290 --> 00:39:02,560
response as of nest of string and again

00:38:59,410 --> 00:39:04,750
the the streaming parameter is always

00:39:02,560 --> 00:39:08,230
the OS over there the second one and we

00:39:04,750 --> 00:39:11,140
have to convert that to a list right and

00:39:08,230 --> 00:39:13,300
now we can use our new specification of

00:39:11,140 --> 00:39:18,850
how responses should be handled in our

00:39:13,300 --> 00:39:22,750
request definition so let's echo get and

00:39:18,850 --> 00:39:24,370
we can actually now run it and it will

00:39:22,750 --> 00:39:30,580
actually give us a list of words right

00:39:24,370 --> 00:39:34,390
so the the response the response why is

00:39:30,580 --> 00:39:35,890
it oh because I send it twice okay but

00:39:34,390 --> 00:39:38,080
you can see that over here you actually

00:39:35,890 --> 00:39:41,400
have a list and just as we have

00:39:38,080 --> 00:39:44,890
specified in the in the in the request

00:39:41,400 --> 00:39:46,660
the the type of the request will also

00:39:44,890 --> 00:39:48,730
include the fact that the response will

00:39:46,660 --> 00:39:51,100
be read into a list of into a list of

00:39:48,730 --> 00:39:53,560
strings and in a similar way you can

00:39:51,100 --> 00:39:55,180
create body civilizer so you can create

00:39:53,560 --> 00:39:57,040
a civilised which will accept a case

00:39:55,180 --> 00:39:59,440
class and stress it to Jason for example

00:39:57,040 --> 00:40:02,310
there are integrations integrations for

00:39:59,440 --> 00:40:04,900
it so just to give you an overview of

00:40:02,310 --> 00:40:09,520
what are they available available

00:40:04,900 --> 00:40:11,140
backends so there's quite a lot of

00:40:09,520 --> 00:40:13,540
documentation on how to actually use it

00:40:11,140 --> 00:40:15,790
here's this of all the backends you can

00:40:13,540 --> 00:40:18,220
see that we have used the HTTP URL

00:40:15,790 --> 00:40:21,280
connection back-end

00:40:18,220 --> 00:40:22,900
and we have used HTTP back-end but

00:40:21,280 --> 00:40:24,849
there's a number of others so if you are

00:40:22,900 --> 00:40:26,500
using if you are working in escolhas

00:40:24,849 --> 00:40:29,619
East AG a kite stake

00:40:26,500 --> 00:40:31,660
monix tag you can choose a back-end this

00:40:29,619 --> 00:40:34,720
probably matches whatever whatever you

00:40:31,660 --> 00:40:37,450
are doing so that's quite a lot of quite

00:40:34,720 --> 00:40:39,220
a lot of possibilities over here it's

00:40:37,450 --> 00:40:41,740
also quite easy to create your own

00:40:39,220 --> 00:40:45,520
backends so for example if you want to

00:40:41,740 --> 00:40:47,560
add some logging or some metrics you can

00:40:45,520 --> 00:40:49,240
actually create a custom mechons wrapper

00:40:47,560 --> 00:40:51,010
which will actually you know before each

00:40:49,240 --> 00:40:53,050
request starts a timer and then after

00:40:51,010 --> 00:40:55,960
the request completes stop the timer

00:40:53,050 --> 00:40:59,920
reporters to geometric server there are

00:40:55,960 --> 00:41:04,599
some built-in integrations with with

00:40:59,920 --> 00:41:08,940
primitives and with brave so so you can

00:41:04,599 --> 00:41:17,940
just use just use that okay so I guess

00:41:08,940 --> 00:41:21,750
going to the summary right now so with a

00:41:17,940 --> 00:41:25,089
SCTP the the basic thing you get is a

00:41:21,750 --> 00:41:27,070
hopefully program a fan api to describe

00:41:25,089 --> 00:41:29,560
requests and to define how the request

00:41:27,070 --> 00:41:33,010
should be sent it supports everything

00:41:29,560 --> 00:41:36,040
you would actually expect from an from

00:41:33,010 --> 00:41:38,560
an HTTP client you have the yeren

00:41:36,040 --> 00:41:41,200
interpreter for easily creating the your

00:41:38,560 --> 00:41:44,109
eyes with optional query parameters

00:41:41,200 --> 00:41:45,970
passed and so on suppose compression

00:41:44,109 --> 00:41:47,710
cookies sending form data uploading

00:41:45,970 --> 00:41:50,770
downloading files sending multiple

00:41:47,710 --> 00:41:51,369
uploads doing authentication redirects

00:41:50,770 --> 00:41:53,859
and so on

00:41:51,369 --> 00:41:58,080
so it's all over there the way you would

00:41:53,859 --> 00:41:58,080
expect you can yeah

00:42:00,470 --> 00:42:07,560
Jesus yeah so far if actually we go to

00:42:04,980 --> 00:42:10,650
the definition of the empty request it's

00:42:07,560 --> 00:42:13,500
not only an empty request there but it's

00:42:10,650 --> 00:42:16,800
an request which always accepts the

00:42:13,500 --> 00:42:19,520
discipline energy the zip and encoding

00:42:16,800 --> 00:42:23,520
and the responses are decoded

00:42:19,520 --> 00:42:30,930
automatically yes yeah sure sure yeah

00:42:23,520 --> 00:42:32,250
yeah of course of course yeah so the

00:42:30,930 --> 00:42:34,200
question is does it support WebSockets

00:42:32,250 --> 00:42:35,490
now WebSockets are not supported it's

00:42:34,200 --> 00:42:38,040
actually quite a common question but

00:42:35,490 --> 00:42:39,660
it's would be probably a separate

00:42:38,040 --> 00:42:42,420
project and I'm not sure if it would be

00:42:39,660 --> 00:42:45,060
at all possible to abstract WebSockets

00:42:42,420 --> 00:42:46,440
in a way that you know would be it would

00:42:45,060 --> 00:42:49,770
be possible to implement them using

00:42:46,440 --> 00:42:51,750
either a car or some other back-end so

00:42:49,770 --> 00:42:54,600
say for WebSockets you have to stick

00:42:51,750 --> 00:43:02,010
with with the name native clients and

00:42:54,600 --> 00:43:03,960
what they offer yeah this does it have a

00:43:02,010 --> 00:43:07,530
retry mechanism not yet there's an issue

00:43:03,960 --> 00:43:08,790
to actually do that and you can but the

00:43:07,530 --> 00:43:10,710
way you would do it is to create a

00:43:08,790 --> 00:43:14,990
back-end wrapper which actually tries

00:43:10,710 --> 00:43:17,370
the request I think that's an example of

00:43:14,990 --> 00:43:18,420
oh yeah you can see that in the

00:43:17,370 --> 00:43:20,190
documentation there's actually an

00:43:18,420 --> 00:43:21,990
example of a very simple retrying

00:43:20,190 --> 00:43:24,840
back-end so how you can do that

00:43:21,990 --> 00:43:26,400
am i advanced example like it probably

00:43:24,840 --> 00:43:28,860
could get into the main code base but

00:43:26,400 --> 00:43:35,570
you know if somebody would like to try

00:43:28,860 --> 00:43:38,400
of course for requests always welcome ok

00:43:35,570 --> 00:43:39,810
so yes and we have the various execution

00:43:38,400 --> 00:43:41,370
modes right so we can either do

00:43:39,810 --> 00:43:45,050
synchronous or asynchronous requests

00:43:41,370 --> 00:43:47,100
depending on which back-end news and

00:43:45,050 --> 00:43:48,750
remember that all the hard work is

00:43:47,100 --> 00:43:50,220
actually done by libraries which are

00:43:48,750 --> 00:43:53,070
there for a long time such as archives

00:43:50,220 --> 00:43:55,260
DDP or a single TP client so I don't

00:43:53,070 --> 00:43:58,110
think that's necessary implementing that

00:43:55,260 --> 00:44:04,080
however the API is hopefully hopefully

00:43:58,110 --> 00:44:06,300
quite nicer and STP is like yeah I think

00:44:04,080 --> 00:44:09,900
this I've created a couple of libraries

00:44:06,300 --> 00:44:12,180
which have a common theme is and the

00:44:09,900 --> 00:44:15,270
theme is to use simple code to use

00:44:12,180 --> 00:44:16,530
simple problems so I think sending HTTP

00:44:15,270 --> 00:44:18,660
requests is actually quite a simple

00:44:16,530 --> 00:44:20,250
thing you might do in your code and the

00:44:18,660 --> 00:44:23,550
code should be quite simple as well and

00:44:20,250 --> 00:44:25,560
hopefully HTTP fits fits in in that

00:44:23,550 --> 00:44:28,650
description I've also written a blog

00:44:25,560 --> 00:44:29,600
about that trying to motivate how that

00:44:28,650 --> 00:44:33,920
could work

00:44:29,600 --> 00:44:36,300
another example of a library which would

00:44:33,920 --> 00:44:38,150
which would hopefully provide simple

00:44:36,300 --> 00:44:41,160
code for a simple problem is quickly on

00:44:38,150 --> 00:44:43,260
that one which allows you to modify

00:44:41,160 --> 00:44:45,930
deeply nested case classes in an easy

00:44:43,260 --> 00:44:48,150
way without needing we worried without

00:44:45,930 --> 00:44:52,050
having to write multiple copy copy

00:44:48,150 --> 00:44:53,790
statements and that's all I had the

00:44:52,050 --> 00:44:56,430
library is open source so of course

00:44:53,790 --> 00:44:57,960
please check it out on github if you

00:44:56,430 --> 00:45:00,690
have any suggestions great issues

00:44:57,960 --> 00:45:04,920
there's a gator channel the presentation

00:45:00,690 --> 00:45:07,260
is online here as well and yeah I don't

00:45:04,920 --> 00:45:09,090
think I have any time for questions but

00:45:07,260 --> 00:45:11,400
I'll be here until the end of the

00:45:09,090 --> 00:45:13,290
conference so feel free to ask me either

00:45:11,400 --> 00:45:14,100
here or online

00:45:13,290 --> 00:45:19,580
you

00:45:14,100 --> 00:45:19,580

YouTube URL: https://www.youtube.com/watch?v=psilxDphK9Q


