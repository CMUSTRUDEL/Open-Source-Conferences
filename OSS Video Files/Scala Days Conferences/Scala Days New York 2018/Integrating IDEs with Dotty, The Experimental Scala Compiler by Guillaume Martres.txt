Title: Integrating IDEs with Dotty, The Experimental Scala Compiler by Guillaume Martres
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/integrating-ides-with-dotty-the-experimental-scala-compiler
Captions: 
	00:00:03,970 --> 00:00:08,680
so my name is Guillaume I'm a PhD

00:00:05,800 --> 00:00:11,019
student at the PFL working on Dottie

00:00:08,680 --> 00:00:13,450
when you score a compiler and today I'd

00:00:11,019 --> 00:00:15,940
like to talk to you about how we are

00:00:13,450 --> 00:00:18,460
dealing with ideas and how we are trying

00:00:15,940 --> 00:00:22,269
to get a good developer experience for

00:00:18,460 --> 00:00:24,699
people in preparation for scale-free so

00:00:22,269 --> 00:00:25,960
I guess I can cue I can skip a try

00:00:24,699 --> 00:00:29,080
because everyone has seen the keynote

00:00:25,960 --> 00:00:31,300
right but just to recap so that is this

00:00:29,080 --> 00:00:35,620
new research compiler but will

00:00:31,300 --> 00:00:40,059
eventually become scale-free it has a

00:00:35,620 --> 00:00:41,950
completely redesigned internals but from

00:00:40,059 --> 00:00:44,590
the user experience point of view it's

00:00:41,950 --> 00:00:47,739
pretty similar and of course check out

00:00:44,590 --> 00:00:52,000
the website and the blog post and

00:00:47,739 --> 00:00:54,640
scrolling on a scale-free roadmap but

00:00:52,000 --> 00:00:58,000
Dottie to me is also a chance to

00:00:54,640 --> 00:01:01,300
redesign some components of language for

00:00:58,000 --> 00:01:03,519
example we managed to improve how

00:01:01,300 --> 00:01:05,880
increment a completion works by just

00:01:03,519 --> 00:01:08,410
redesigning the thing from scratch and

00:01:05,880 --> 00:01:11,980
finding issues and some of those fixes

00:01:08,410 --> 00:01:15,070
got back into Scylla - afterwards we

00:01:11,980 --> 00:01:17,980
also managed to improve pattern matching

00:01:15,070 --> 00:01:20,680
exhaustively checks and the algorithm

00:01:17,980 --> 00:01:25,900
has even now been reused in Swift

00:01:20,680 --> 00:01:28,060
for their pattern matching and of course

00:01:25,900 --> 00:01:29,410
there's a bunch of other areas like that

00:01:28,060 --> 00:01:31,990
and today I'm going to talk about

00:01:29,410 --> 00:01:35,070
tooling because a good developer

00:01:31,990 --> 00:01:38,050
experience of course requires good tools

00:01:35,070 --> 00:01:40,060
so we have a repel it even has syntax

00:01:38,050 --> 00:01:42,070
highlighting like ammonite in fact we

00:01:40,060 --> 00:01:46,060
store some codes from ammolite to do

00:01:42,070 --> 00:01:47,890
that we have a documentation generation

00:01:46,060 --> 00:01:51,640
tool but we use to generate order for

00:01:47,890 --> 00:01:52,360
documentation and of course we have IDE

00:01:51,640 --> 00:01:56,740
support

00:01:52,360 --> 00:02:00,550
so just a brief recap of say let's say

00:01:56,740 --> 00:02:03,850
the state of the art of ideas reports in

00:02:00,550 --> 00:02:05,590
Scotland so there's two kinds of ideas

00:02:03,850 --> 00:02:07,870
really it's kind of a the one which are

00:02:05,590 --> 00:02:09,940
based on the scalar presentation

00:02:07,870 --> 00:02:15,240
compiler which is just a special mode of

00:02:09,940 --> 00:02:20,190
scale see this our last color ID

00:02:15,240 --> 00:02:22,470
Eclipse protein and enzyme and there are

00:02:20,190 --> 00:02:23,820
implementations of a sky type sugar or

00:02:22,470 --> 00:02:25,320
more exactly that's exactly one or

00:02:23,820 --> 00:02:27,390
implementation because who would be

00:02:25,320 --> 00:02:32,580
crazy enough to do that right which is

00:02:27,390 --> 00:02:36,090
scallop plugin for IntelliJ IDEA so all

00:02:32,580 --> 00:02:37,440
those things solve kind of the same

00:02:36,090 --> 00:02:42,330
problem but they're all kind of

00:02:37,440 --> 00:02:45,510
difficult to reuse for our purpose for a

00:02:42,330 --> 00:02:48,510
new compiler because they kind of

00:02:45,510 --> 00:02:51,510
depends on details of previous language

00:02:48,510 --> 00:02:54,390
and they are kind of big

00:02:51,510 --> 00:02:56,640
except enzyme really which is quite nice

00:02:54,390 --> 00:02:58,320
and simple and also has this nice server

00:02:56,640 --> 00:03:02,580
client design but I'm going to talk

00:02:58,320 --> 00:03:05,040
about later so anyway so let's let's

00:03:02,580 --> 00:03:06,570
imagine we we can't reuse any of that

00:03:05,040 --> 00:03:08,970
stuff so we want to start from scratch

00:03:06,570 --> 00:03:13,620
so what do we do first we start with

00:03:08,970 --> 00:03:15,930
some set of design principles and the

00:03:13,620 --> 00:03:18,630
design principles I want to invest our

00:03:15,930 --> 00:03:22,080
code reuse as much as possible the

00:03:18,630 --> 00:03:24,810
compiler and the ID should share code so

00:03:22,080 --> 00:03:27,530
that you don't have bugs which are ID

00:03:24,810 --> 00:03:32,550
only and impossible to reproduce and

00:03:27,530 --> 00:03:35,070
very hard to debug we want edit organize

00:03:32,550 --> 00:03:36,930
DCT because somebody tells up but we are

00:03:35,070 --> 00:03:40,290
some days and not popular the next day

00:03:36,930 --> 00:03:43,530
so you can force everyone to use some

00:03:40,290 --> 00:03:46,290
editor and we want it to be easy to use

00:03:43,530 --> 00:03:49,140
and to install like it should be as

00:03:46,290 --> 00:03:51,780
simple as possible so let's glue in

00:03:49,140 --> 00:03:55,010
details through all these principles and

00:03:51,780 --> 00:03:55,010
see how we can implement them

00:04:06,580 --> 00:04:10,600
so to talk about cutter use I'm going to

00:04:09,010 --> 00:04:13,660
talk a bit about how the compiler works

00:04:10,600 --> 00:04:17,340
so the compiler is with giant pipeline

00:04:13,660 --> 00:04:21,040
of phases basically it starts with your

00:04:17,340 --> 00:04:23,740
source program each process that into an

00:04:21,040 --> 00:04:26,230
untyped abstract syntax tree then type

00:04:23,740 --> 00:04:27,880
checked that abstract syntax tree that's

00:04:26,230 --> 00:04:30,370
when you get most of your error messages

00:04:27,880 --> 00:04:33,220
and then pretty much everything after

00:04:30,370 --> 00:04:37,350
that is just a bunch of simplification

00:04:33,220 --> 00:04:40,300
and transformation phases for trees that

00:04:37,350 --> 00:04:50,940
make them easier at the end to be

00:04:40,300 --> 00:04:53,020
emitted as JVM bytecode or jes LLVM so

00:04:50,940 --> 00:04:55,690
type error is the one we're interested

00:04:53,020 --> 00:04:58,030
in to do growing of a compiler and I'll

00:04:55,690 --> 00:05:00,010
explain why so imagine you have some

00:04:58,030 --> 00:05:03,160
source code you have a final value

00:05:00,010 --> 00:05:05,050
called RM whose value is 1 and some

00:05:03,160 --> 00:05:08,290
other value called foo which references

00:05:05,050 --> 00:05:11,410
11 and this little flag here is your

00:05:08,290 --> 00:05:13,870
cursor position in your ID and at that

00:05:11,410 --> 00:05:16,030
point the user makes a query he wants to

00:05:13,870 --> 00:05:18,790
do a jump to definition so he wants to

00:05:16,030 --> 00:05:20,710
go to the definition of alone so if we

00:05:18,790 --> 00:05:23,710
look at the tree after type checking and

00:05:20,710 --> 00:05:26,050
if we press print it to make it nicer to

00:05:23,710 --> 00:05:28,450
read it's pretty similar to what we had

00:05:26,050 --> 00:05:32,500
before we just have types inserted

00:05:28,450 --> 00:05:34,930
everywhere we also and this isn't shown

00:05:32,500 --> 00:05:37,150
pretty printing you have a position for

00:05:34,930 --> 00:05:40,570
all the nodes that means that we can

00:05:37,150 --> 00:05:44,919
answer a query because we can just look

00:05:40,570 --> 00:05:48,100
at the type of elam and it has a very

00:05:44,919 --> 00:05:52,030
precise types from which we can find its

00:05:48,100 --> 00:05:55,210
symbol and from that we can query it for

00:05:52,030 --> 00:05:57,130
us the tree to find its definition and

00:05:55,210 --> 00:05:59,500
that is definition we have its position

00:05:57,130 --> 00:06:04,230
and then we can send that back to the ID

00:05:59,500 --> 00:06:06,910
so the ID can execute go to definition

00:06:04,230 --> 00:06:10,840
but if we go a little bit later and the

00:06:06,910 --> 00:06:13,210
computation phases now in trouble after

00:06:10,840 --> 00:06:16,840
constant folding LM trust 1 has been

00:06:13,210 --> 00:06:18,820
replaced by 2 so some information has

00:06:16,840 --> 00:06:20,380
been lost and that means but at that

00:06:18,820 --> 00:06:24,820
point we cannot in serve the query and

00:06:20,380 --> 00:06:28,570
more because of information that we need

00:06:24,820 --> 00:06:31,480
the what's the element at the position

00:06:28,570 --> 00:06:32,050
where user cursor is is not present

00:06:31,480 --> 00:06:37,270
anymore

00:06:32,050 --> 00:06:38,590
so to recap to query compiler we need to

00:06:37,270 --> 00:06:42,010
start trees right after type checking

00:06:38,590 --> 00:06:44,620
and not at any later point because at

00:06:42,010 --> 00:06:48,040
any later point we already start using

00:06:44,620 --> 00:06:51,460
information and we can respond to idea

00:06:48,040 --> 00:06:54,280
queries by traversing these trees that

00:06:51,460 --> 00:06:55,570
leaves one big question and answered is

00:06:54,280 --> 00:06:57,520
what do you do about code that has

00:06:55,570 --> 00:07:00,430
already been compiled so all of this

00:06:57,520 --> 00:07:03,880
works if you're in an IDE in a file that

00:07:00,430 --> 00:07:05,650
is open and as you type the idea is

00:07:03,880 --> 00:07:07,180
going to type check that fire but

00:07:05,650 --> 00:07:09,070
usually in a project you have many files

00:07:07,180 --> 00:07:13,030
and most of them are not open in your ID

00:07:09,070 --> 00:07:14,710
they're sitting in your disk already

00:07:13,030 --> 00:07:17,980
compiled so you have class files for

00:07:14,710 --> 00:07:19,630
them so to understand that we need to go

00:07:17,980 --> 00:07:22,680
a little bit later and we compare our

00:07:19,630 --> 00:07:26,020
pipeline and talk about picking so

00:07:22,680 --> 00:07:27,970
pickling is used to add some extra

00:07:26,020 --> 00:07:30,940
information that will be present in the

00:07:27,970 --> 00:07:33,610
byte code but he is can be used for

00:07:30,940 --> 00:07:36,190
various purposes in Scala too

00:07:33,610 --> 00:07:38,980
we stopped the method signatures in the

00:07:36,190 --> 00:07:43,150
pickling information this is necessary

00:07:38,980 --> 00:07:46,270
because the byte code we emit is JVM

00:07:43,150 --> 00:07:48,220
bytecode which does have information

00:07:46,270 --> 00:07:50,020
about method signatures but it's already

00:07:48,220 --> 00:07:52,710
arrays information because the JVM

00:07:50,020 --> 00:07:54,430
doesn't know about type parameters

00:07:52,710 --> 00:07:56,230
certainly doesn't know about higher

00:07:54,430 --> 00:07:58,770
kinetic parameters or any complicated

00:07:56,230 --> 00:08:01,600
type features so all of those are

00:07:58,770 --> 00:08:03,790
disappear from the bytecode but we still

00:08:01,600 --> 00:08:05,860
need to store them somewhere so that we

00:08:03,790 --> 00:08:07,930
can reuse them when we do separate

00:08:05,860 --> 00:08:11,410
compilation when we read some classifier

00:08:07,930 --> 00:08:13,000
of a library you're using dot e does the

00:08:11,410 --> 00:08:15,550
same thing but it goes further instead

00:08:13,000 --> 00:08:18,250
of just drawing the method signatures it

00:08:15,550 --> 00:08:21,370
store full trees and that's what we call

00:08:18,250 --> 00:08:24,910
tasty which you've also heard about in

00:08:21,370 --> 00:08:26,770
the keynote so to recap the original

00:08:24,910 --> 00:08:31,600
motivation of testing was to solve the

00:08:26,770 --> 00:08:33,970
binary compatible if you always depend

00:08:31,600 --> 00:08:36,789
always recompile using

00:08:33,970 --> 00:08:39,490
binary JVM bytecode as usual

00:08:36,789 --> 00:08:42,370
dependencies then when the comparator

00:08:39,490 --> 00:08:44,710
changes its encoding say when in 212 the

00:08:42,370 --> 00:08:47,350
trait encoding was changed you couldn't

00:08:44,710 --> 00:08:49,180
use 211 classes in your 212 project

00:08:47,350 --> 00:08:53,050
because we are just completely different

00:08:49,180 --> 00:08:55,210
encodings so instead you could always be

00:08:53,050 --> 00:08:58,390
compiled from source codes but if you do

00:08:55,210 --> 00:09:01,450
that evil types check your changes if

00:08:58,390 --> 00:09:03,640
say increase its search changes are some

00:09:01,450 --> 00:09:05,730
details of type inference changes then

00:09:03,640 --> 00:09:08,950
your code might stop to stop companion

00:09:05,730 --> 00:09:13,230
so tasty is kind of an intermediate

00:09:08,950 --> 00:09:15,430
between the two things where we starve

00:09:13,230 --> 00:09:17,830
abstract syntax tree just after type

00:09:15,430 --> 00:09:20,470
checking so we've already done implicit

00:09:17,830 --> 00:09:23,200
search of eroding resolution type

00:09:20,470 --> 00:09:25,990
inference but all the details of

00:09:23,200 --> 00:09:28,450
implementation like how our traits

00:09:25,990 --> 00:09:30,430
encoded are not present in this abstract

00:09:28,450 --> 00:09:33,430
syntax tree so you can recompile

00:09:30,430 --> 00:09:36,610
everything from that assuming that this

00:09:33,430 --> 00:09:38,800
easter is binary compatible which is the

00:09:36,610 --> 00:09:40,990
trees we store in teste exactly the type

00:09:38,800 --> 00:09:43,900
trees we were using previously to answer

00:09:40,990 --> 00:09:45,820
queries so what we can do for everything

00:09:43,900 --> 00:09:50,020
that is compiled in your class path is

00:09:45,820 --> 00:09:51,460
just visualize the tasty and query these

00:09:50,020 --> 00:09:53,050
trees and that's very interesting

00:09:51,460 --> 00:09:55,720
because it means that we have one

00:09:53,050 --> 00:09:58,390
uniform way of dealing with everything

00:09:55,720 --> 00:10:00,250
from things open in your IDE to things

00:09:58,390 --> 00:10:02,680
in your classifiers to things in your

00:10:00,250 --> 00:10:05,170
dependencies it just all trees and we

00:10:02,680 --> 00:10:07,270
can you reuse the same code to prevent

00:10:05,170 --> 00:10:11,740
which means less code which means yes

00:10:07,270 --> 00:10:13,750
bugs so to do this we have a very small

00:10:11,740 --> 00:10:17,110
set of interactive api's which are part

00:10:13,750 --> 00:10:19,060
of the compilers that deal with treat

00:10:17,110 --> 00:10:21,730
reversers with the lifecycle management

00:10:19,060 --> 00:10:23,740
of a compiler and we already use them

00:10:21,730 --> 00:10:26,500
some of them both in the ID and the

00:10:23,740 --> 00:10:28,330
wrapper for example for completions

00:10:26,500 --> 00:10:30,640
we want the same mechanism to be used

00:10:28,330 --> 00:10:32,050
and that reinvention of the mechanism

00:10:30,640 --> 00:10:34,060
when you're doing completion in the IDE

00:10:32,050 --> 00:10:35,800
and in the river

00:10:34,060 --> 00:10:38,760
and there's more thing we could do in

00:10:35,800 --> 00:10:40,900
this IPS like interruption handling say

00:10:38,760 --> 00:10:44,110
every time you press a key stroke in

00:10:40,900 --> 00:10:44,910
your IDE currently is going to recompile

00:10:44,110 --> 00:10:48,570
the

00:10:44,910 --> 00:10:50,160
better and it won't stop until it's done

00:10:48,570 --> 00:10:51,660
compounding the foot buffer I'll just

00:10:50,160 --> 00:10:54,450
type shaking it not wheel confining it

00:10:51,660 --> 00:10:58,470
which means that you might have some

00:10:54,450 --> 00:11:00,450
delay when you're typing very fast so we

00:10:58,470 --> 00:11:04,170
should be able to interrupt previous

00:11:00,450 --> 00:11:05,730
type checking to avoid that we haven't

00:11:04,170 --> 00:11:07,830
done that yet because surprisingly this

00:11:05,730 --> 00:11:11,550
delay is not a big deal must have a time

00:11:07,830 --> 00:11:13,890
because at least when using yes codes

00:11:11,550 --> 00:11:16,320
all the UI is completely asynchronous so

00:11:13,890 --> 00:11:17,700
even if the backend is like busy type

00:11:16,320 --> 00:11:19,980
checking that doesn't affect your

00:11:17,700 --> 00:11:23,640
editing experience much it's mostly

00:11:19,980 --> 00:11:36,540
transparent and all that is less than a

00:11:23,640 --> 00:11:39,090
thousand lines of code so far so the

00:11:36,540 --> 00:11:40,950
next big goal we have is to make this

00:11:39,090 --> 00:11:44,460
work with any ID right now we are

00:11:40,950 --> 00:11:46,830
focusing on vs cut because of reasons

00:11:44,460 --> 00:11:49,110
are extra nature but we really want

00:11:46,830 --> 00:11:51,780
everyone whatever idea are using to be

00:11:49,110 --> 00:11:58,490
able to use this even if you are using

00:11:51,780 --> 00:12:01,200
vim Emacs or add if that's your thing so

00:11:58,490 --> 00:12:03,650
there's the problem we're trying to

00:12:01,200 --> 00:12:06,900
solve here is the ID portability problem

00:12:03,650 --> 00:12:09,690
if you have M IDs and you want to

00:12:06,900 --> 00:12:13,380
support and program edges in it M times

00:12:09,690 --> 00:12:15,240
and ID presence that's a lot and that's

00:12:13,380 --> 00:12:17,280
also problematic because to write these

00:12:15,240 --> 00:12:21,150
plugins you need to be both a language

00:12:17,280 --> 00:12:22,770
expert and an IDE expert for every

00:12:21,150 --> 00:12:25,230
combination of language and ID and

00:12:22,770 --> 00:12:27,600
usually ID experts are different people

00:12:25,230 --> 00:12:32,280
from the language experts so we'd like

00:12:27,600 --> 00:12:34,140
to have like some division of work so

00:12:32,280 --> 00:12:36,480
the language server protocol is the

00:12:34,140 --> 00:12:39,720
formalization about kind of things it's

00:12:36,480 --> 00:12:41,460
a protocol that Microsoft first created

00:12:39,720 --> 00:12:44,910
for Visual Studio code but has now been

00:12:41,460 --> 00:12:50,730
implemented by a bunch of other editors

00:12:44,910 --> 00:12:54,290
and other languages the wait works is it

00:12:50,730 --> 00:12:57,360
it's based on JSON RPC which is just a

00:12:54,290 --> 00:12:59,820
thin layer of how do you send messages

00:12:57,360 --> 00:13:03,060
back and forth in

00:12:59,820 --> 00:13:06,990
so the IDE is going to notify village

00:13:03,060 --> 00:13:11,310
server about user actions say the user

00:13:06,990 --> 00:13:12,840
press go to definition button on inside

00:13:11,310 --> 00:13:14,910
the language server is going to maintain

00:13:12,840 --> 00:13:17,640
some internal representation of the code

00:13:14,910 --> 00:13:21,210
probably type site representation so

00:13:17,640 --> 00:13:23,640
that it can answer queries and it can

00:13:21,210 --> 00:13:27,080
also notify the IDS about things like

00:13:23,640 --> 00:13:31,310
warnings and errors that it finds out

00:13:27,080 --> 00:13:34,860
and when the IDE can send requests

00:13:31,310 --> 00:13:40,140
trigger the user actions say the user I

00:13:34,860 --> 00:13:41,520
want to rename something and it's

00:13:40,140 --> 00:13:45,360
completely a synchronous and

00:13:41,520 --> 00:13:47,250
considerable so you don't you should

00:13:45,360 --> 00:13:49,590
never have to be like wait for your

00:13:47,250 --> 00:13:50,850
compiler to stop comparing to be able to

00:13:49,590 --> 00:13:54,780
type your code because that's like

00:13:50,850 --> 00:13:57,060
different things really so how do we

00:13:54,780 --> 00:14:00,120
implement along a semaphore dodgy so

00:13:57,060 --> 00:14:03,540
first all the low-level message handling

00:14:00,120 --> 00:14:06,210
we just use Eclipse SP for J which is a

00:14:03,540 --> 00:14:08,430
library Java library because we can't

00:14:06,210 --> 00:14:13,650
really use scalar libraries in a scalar

00:14:08,430 --> 00:14:16,470
compiler or we run into loops but SPF

00:14:13,650 --> 00:14:18,090
already is very nice because it's a it

00:14:16,470 --> 00:14:20,160
does all other stuff for us and

00:14:18,090 --> 00:14:22,950
basically I have to override methods to

00:14:20,160 --> 00:14:25,080
increment messages we rely on the

00:14:22,950 --> 00:14:26,790
interactive apiaries I presented in a

00:14:25,080 --> 00:14:28,860
previous section and that means that in

00:14:26,790 --> 00:14:30,540
the end it's only like a few hundred

00:14:28,860 --> 00:14:32,850
lines of code to implement to know where

00:14:30,540 --> 00:14:34,320
Sarah just to show that well physically

00:14:32,850 --> 00:14:37,530
no magic I can show you the

00:14:34,320 --> 00:14:40,950
implementation of go to definition so we

00:14:37,530 --> 00:14:44,310
override a method you know interface

00:14:40,950 --> 00:14:50,400
that is before J provide for us we take

00:14:44,310 --> 00:14:51,839
parameters which are for go to

00:14:50,400 --> 00:14:54,960
definition the parameters are going to

00:14:51,839 --> 00:14:57,030
be the URI which represent which five we

00:14:54,960 --> 00:14:59,730
are in and the position in the file and

00:14:57,030 --> 00:15:03,690
that's it that's all the information you

00:14:59,730 --> 00:15:07,830
get from the protocol and using that

00:15:03,690 --> 00:15:09,839
information you have to figure out - how

00:15:07,830 --> 00:15:11,480
to get a position of the definition that

00:15:09,839 --> 00:15:13,910
you can get to the user

00:15:11,480 --> 00:15:17,120
so to get to do that we need of course

00:15:13,910 --> 00:15:19,970
from the URI to find out which project

00:15:17,120 --> 00:15:22,610
it belongs to because usually in a

00:15:19,970 --> 00:15:24,950
typical SBT project you're going to have

00:15:22,610 --> 00:15:27,710
many sub projects each with their own

00:15:24,950 --> 00:15:29,780
compiler flags maybe even their own

00:15:27,710 --> 00:15:33,470
compiler version so you need to figure

00:15:29,780 --> 00:15:37,310
out which projects beyond your Uruguayan

00:15:33,470 --> 00:15:40,940
zoo then we get a context switch is

00:15:37,310 --> 00:15:44,900
represents the international buyers then

00:15:40,940 --> 00:15:47,120
we just do some some boilerplate to

00:15:44,900 --> 00:15:49,550
translate from positions as represented

00:15:47,120 --> 00:15:54,200
by H P for J to positions as represented

00:15:49,550 --> 00:15:58,010
by Dottie then we look at all the type

00:15:54,200 --> 00:15:59,930
trees we have for the current uri and

00:15:58,010 --> 00:16:05,570
then we can use for our interactive api

00:15:59,930 --> 00:16:09,050
to fight find out where the symbols that

00:16:05,570 --> 00:16:12,380
match this position symbols reference at

00:16:09,050 --> 00:16:15,530
this position in the trees and from that

00:16:12,380 --> 00:16:17,930
we can find where that symbol is defined

00:16:15,530 --> 00:16:20,480
in what class is defined and from that

00:16:17,930 --> 00:16:23,150
class we can find the tree of vodcast

00:16:20,480 --> 00:16:25,130
and again what we might ever be open in

00:16:23,150 --> 00:16:28,760
your IDE you it might come from some CAD

00:16:25,130 --> 00:16:31,160
file and from that we can then traverse

00:16:28,760 --> 00:16:33,110
that tree and find the position of the

00:16:31,160 --> 00:16:39,250
definition and then we just return that

00:16:33,110 --> 00:16:43,520
position so last at least we also want

00:16:39,250 --> 00:16:45,350
or ideally to be like an amazing user

00:16:43,520 --> 00:16:47,530
experience like people should be so

00:16:45,350 --> 00:16:49,880
happy that you can use this without

00:16:47,530 --> 00:16:52,610
twiddling with configuration files and

00:16:49,880 --> 00:16:54,440
stuff and that's and from them what this

00:16:52,610 --> 00:16:58,610
means is just means we need two ways

00:16:54,440 --> 00:17:01,310
between the equation so the way this

00:16:58,610 --> 00:17:03,530
works is we analyze we build to find out

00:17:01,310 --> 00:17:05,810
your projects using an SBT plug-in we

00:17:03,530 --> 00:17:08,150
compile these projects which in right

00:17:05,810 --> 00:17:10,490
configuration files we install with the

00:17:08,150 --> 00:17:12,920
TVA's cut extension and when we watch me

00:17:10,490 --> 00:17:15,860
is cut and we do all of that if you type

00:17:12,920 --> 00:17:19,240
the ID comment in a dirty project and

00:17:15,860 --> 00:17:21,770
that works in any dirty project because

00:17:19,240 --> 00:17:23,089
plug-in for IDs support is just part of

00:17:21,770 --> 00:17:26,650
the protein you need to use for any

00:17:23,089 --> 00:17:30,049
dirty project so it's already built in

00:17:26,650 --> 00:17:33,190
so briefly the configurations far as we

00:17:30,049 --> 00:17:35,510
generate because one which there is the

00:17:33,190 --> 00:17:37,010
artifact to use to ensure that language

00:17:35,510 --> 00:17:40,250
server so that's just going to be like

00:17:37,010 --> 00:17:42,799
we need to run this version when we are

00:17:40,250 --> 00:17:46,250
going to fetch this using Cosi Cosi is

00:17:42,799 --> 00:17:48,409
awesome and we have an another

00:17:46,250 --> 00:17:54,500
configuration file which basically is a

00:17:48,409 --> 00:17:56,960
JSON representation of your SBT build so

00:17:54,500 --> 00:17:59,480
audio sub projects and for every sub

00:17:56,960 --> 00:18:04,789
project source directory is the class

00:17:59,480 --> 00:18:07,220
behalf of a compare version so all that

00:18:04,789 --> 00:18:09,620
is very annoying to maintain of course

00:18:07,220 --> 00:18:12,980
because it's if you want to support

00:18:09,620 --> 00:18:15,140
multiple bit words you need to make a

00:18:12,980 --> 00:18:18,580
bunch of plugins and you need to make

00:18:15,140 --> 00:18:21,370
sure that they all do same thing and

00:18:18,580 --> 00:18:24,110
then you still have the issue with like

00:18:21,370 --> 00:18:25,820
synchronization because between the time

00:18:24,110 --> 00:18:27,590
that you generated that file and the

00:18:25,820 --> 00:18:31,720
time that the user opened the ID maybe

00:18:27,590 --> 00:18:35,179
something changed so what if instead of

00:18:31,720 --> 00:18:36,890
querying requiring the compile using

00:18:35,179 --> 00:18:39,289
plugins generate fires and then reading

00:18:36,890 --> 00:18:42,919
this files later on we could just have

00:18:39,289 --> 00:18:46,850
some kind of protocol to interactively

00:18:42,919 --> 00:18:49,490
ask the brittle hey can you give me all

00:18:46,850 --> 00:18:51,289
your projects which are dirty projects

00:18:49,490 --> 00:18:54,500
which correspond to visit source

00:18:51,289 --> 00:18:57,740
directories and that's what the build

00:18:54,500 --> 00:19:01,370
server protocol is about and Jorge and

00:18:57,740 --> 00:19:04,850
Martin have a talk on exactly that that

00:19:01,370 --> 00:19:07,850
you should definitely see so it's like

00:19:04,850 --> 00:19:11,299
not there's 1.0 version was released

00:19:07,850 --> 00:19:16,490
recently I think for now it's only

00:19:11,299 --> 00:19:18,289
implemented in group and IntelliJ but my

00:19:16,490 --> 00:19:20,419
hope is that everyone will use this

00:19:18,289 --> 00:19:22,610
thing even surely and then I don't have

00:19:20,419 --> 00:19:29,240
to maintain SBT plugins because that's

00:19:22,610 --> 00:19:31,820
not what I consider fun but to get to

00:19:29,240 --> 00:19:33,980
the like seamless fantastic user

00:19:31,820 --> 00:19:36,730
experience we also need a discovery

00:19:33,980 --> 00:19:39,100
protocol which is like

00:19:36,730 --> 00:19:41,080
on sort of a question how do I start to

00:19:39,100 --> 00:19:43,059
build server for these projects because

00:19:41,080 --> 00:19:45,280
each built will might have its own way

00:19:43,059 --> 00:19:47,350
to start a bid server and when to

00:19:45,280 --> 00:19:49,660
communicate with it so I really think we

00:19:47,350 --> 00:19:51,940
need some very simple way to say this is

00:19:49,660 --> 00:19:54,070
the command line you need to run and we

00:19:51,940 --> 00:19:56,860
publish command line in a file which is

00:19:54,070 --> 00:19:59,490
in a central location that is the same

00:19:56,860 --> 00:20:04,150
for all kind of projects for all peoples

00:19:59,490 --> 00:20:06,910
server that doesn't exist yet alright so

00:20:04,150 --> 00:20:10,900
just to recap our design principles for

00:20:06,910 --> 00:20:12,549
code reuse we implemented some API is

00:20:10,900 --> 00:20:15,040
for interact if you use edge that we use

00:20:12,549 --> 00:20:17,320
in different scenarios and recipe is are

00:20:15,040 --> 00:20:19,960
just reusing internal compiler stuff

00:20:17,320 --> 00:20:24,820
that we know should be correct because

00:20:19,960 --> 00:20:27,220
we test it heavily for editor elasticity

00:20:24,820 --> 00:20:29,860
to be implemented we all speak and for

00:20:27,220 --> 00:20:31,330
ease of use we have one comment but we

00:20:29,860 --> 00:20:37,840
can do better we should be able to do Co

00:20:31,330 --> 00:20:41,610
comments so I can do a quick demo maybe

00:20:37,840 --> 00:20:41,610
I can try

00:20:53,160 --> 00:20:57,810
so if you want to follow along you can

00:20:55,650 --> 00:21:02,280
go to you on poppy FL github young ppl

00:20:57,810 --> 00:21:07,320
do the example project and you can

00:21:02,280 --> 00:21:10,260
convert thing and you can go to the cut

00:21:07,320 --> 00:21:12,450
of your visual visual yo cut thing and

00:21:10,260 --> 00:21:23,300
download it and if you do both of those

00:21:12,450 --> 00:21:23,300
things and then you just type

00:21:30,220 --> 00:21:37,480
so this is an example project which

00:21:32,900 --> 00:21:41,510
demos a bunch of features of language

00:21:37,480 --> 00:21:44,720
and if it's working yes I can say to go

00:21:41,510 --> 00:21:52,580
to definition he goes to the definition

00:21:44,720 --> 00:21:55,210
I can this is a YouTube right I can do

00:21:52,580 --> 00:21:59,660
find our references

00:21:55,210 --> 00:22:03,260
times our references if I'm very daring

00:21:59,660 --> 00:22:06,980
I can even do renamed but that one is

00:22:03,260 --> 00:22:08,710
less well tested so far let's see is

00:22:06,980 --> 00:22:10,929
what he used

00:22:08,710 --> 00:22:13,850
[Music]

00:22:10,929 --> 00:22:16,090
yes so I can try to rename it and see

00:22:13,850 --> 00:22:16,090
what happens

00:22:22,050 --> 00:22:29,100
yeah it really works with multiple files

00:22:26,220 --> 00:22:31,110
if you have references in over files is

00:22:29,100 --> 00:22:36,090
going to open this file in your ID and

00:22:31,110 --> 00:22:37,470
over rename so we have two definition

00:22:36,090 --> 00:22:43,160
working we have find our references we

00:22:37,470 --> 00:22:46,610
have completion so if I do on that

00:22:43,160 --> 00:22:46,610
that's awesome buddy

00:22:47,690 --> 00:22:55,740
so all that most rewards we don't yet

00:22:52,440 --> 00:22:57,570
have documentation suppose so if I over

00:22:55,740 --> 00:22:58,980
over visiting I don't see the

00:22:57,570 --> 00:23:02,100
documentation which this is coming very

00:22:58,980 --> 00:23:04,140
soon we have an open PR by Martin Jol

00:23:02,100 --> 00:23:08,880
that intruments wets and that's going to

00:23:04,140 --> 00:23:11,300
be awesome all right I'm going to keep

00:23:08,880 --> 00:23:11,300
going with

00:23:22,389 --> 00:23:28,599
so this is cool but no there's a dress

00:23:26,379 --> 00:23:31,840
like standard stuff now people want more

00:23:28,599 --> 00:23:34,269
people want deep eldership words and

00:23:31,840 --> 00:23:35,979
which one is interesting because when I

00:23:34,269 --> 00:23:39,429
first tried to look into this it sounded

00:23:35,979 --> 00:23:41,409
very hard but it turns out that I think

00:23:39,429 --> 00:23:45,279
we can get it working without too much

00:23:41,409 --> 00:23:48,159
work so turns out that Microsoft

00:23:45,279 --> 00:23:50,169
hopefully made a Java debug server based

00:23:48,159 --> 00:23:53,289
on another protocol which is called the

00:23:50,169 --> 00:23:56,019
debug adapter protocol which suffer I

00:23:53,289 --> 00:23:58,839
think is an implemented by vs card maybe

00:23:56,019 --> 00:24:05,349
at home too but I hope is also

00:23:58,839 --> 00:24:07,119
implemented by over ideas and so fact

00:24:05,349 --> 00:24:09,129
that we traveled beyond several exists

00:24:07,119 --> 00:24:11,589
is very interesting for us because the

00:24:09,129 --> 00:24:15,729
way this rock is just it's an interface

00:24:11,589 --> 00:24:21,039
between the Java debugging interface API

00:24:15,729 --> 00:24:24,129
is and the debug protocol and the same

00:24:21,039 --> 00:24:25,719
debug API is for Java uses of course can

00:24:24,129 --> 00:24:28,299
work with scale if you compile your

00:24:25,719 --> 00:24:31,359
scale code to Java so most things just

00:24:28,299 --> 00:24:35,979
work but not enough that I can merge it

00:24:31,359 --> 00:24:39,399
in that yet so when but one big

00:24:35,979 --> 00:24:41,440
challenge is expression evaluation so

00:24:39,399 --> 00:24:43,529
I'm going to explain what this is so

00:24:41,440 --> 00:24:49,149
imagine you have some cut

00:24:43,529 --> 00:24:51,009
you're a class with two methods and now

00:24:49,149 --> 00:24:52,809
this is your break point this isn't the

00:24:51,009 --> 00:24:57,339
crosser anymore and we're using emojis

00:24:52,809 --> 00:24:59,619
and at this break point your program is

00:24:57,339 --> 00:25:03,509
stopped and you want to do evaluative

00:24:59,619 --> 00:25:06,879
expression so how do you do that because

00:25:03,509 --> 00:25:09,940
remember there's running JVM somewhere

00:25:06,879 --> 00:25:12,099
with your program and then you have your

00:25:09,940 --> 00:25:16,419
debug server that is communicating with

00:25:12,099 --> 00:25:18,399
a JVM but you can't really send scale

00:25:16,419 --> 00:25:21,190
comments to the JVM because with JVM

00:25:18,399 --> 00:25:24,489
doesn't speak Scala natively the best

00:25:21,190 --> 00:25:27,359
you can do is use Java debugging API is

00:25:24,489 --> 00:25:30,820
to send its very low level comments and

00:25:27,359 --> 00:25:32,229
here we want to to run foo which means

00:25:30,820 --> 00:25:34,620
we need to do type checking because we

00:25:32,229 --> 00:25:38,190
need to do implicit search so

00:25:34,620 --> 00:25:40,290
we do that so first we're going to run

00:25:38,190 --> 00:25:43,040
the normal compiler pipeline so we're

00:25:40,290 --> 00:25:45,630
going to introduce foo and put it like

00:25:43,040 --> 00:25:47,790
we're not going to actually identify but

00:25:45,630 --> 00:25:50,670
we're going to present we've edited the

00:25:47,790 --> 00:25:52,590
file and some that will compile with who

00:25:50,670 --> 00:25:54,960
introduced at the right point position

00:25:52,590 --> 00:25:56,940
when we are going to run the compiler

00:25:54,960 --> 00:25:58,980
pipeline I showed you before but we're

00:25:56,940 --> 00:26:01,470
going to stop just before we get to

00:25:58,980 --> 00:26:03,840
emitting JVM bytecode so at this point

00:26:01,470 --> 00:26:06,450
all the emphases have been erased and

00:26:03,840 --> 00:26:10,620
resolved and some of our changes have

00:26:06,450 --> 00:26:12,660
happened to be cut so we know now that

00:26:10,620 --> 00:26:18,120
the expression we want to send to the

00:26:12,660 --> 00:26:20,130
JVM is visited foo of Y we still don't

00:26:18,120 --> 00:26:22,770
know how to send back to the JVM because

00:26:20,130 --> 00:26:26,670
this is like some cut somewhere deep in

00:26:22,770 --> 00:26:29,070
a method and the JVM doesn't know about

00:26:26,670 --> 00:26:30,990
the methods which was compiled so we

00:26:29,070 --> 00:26:34,380
need to extract this to a static method

00:26:30,990 --> 00:26:36,420
so we can do this using a special

00:26:34,380 --> 00:26:40,050
compiler phase just for all the debugger

00:26:36,420 --> 00:26:42,570
so we're going to lift or expression2 a

00:26:40,050 --> 00:26:45,660
static method so that takes us

00:26:42,570 --> 00:26:51,440
parameters all the things it references

00:26:45,660 --> 00:26:53,970
so here was just this and white and then

00:26:51,440 --> 00:26:56,940
because the JVM doesn't know about our

00:26:53,970 --> 00:26:59,850
list of parameters either we need to go

00:26:56,940 --> 00:27:03,600
a bit more abstract still and make an

00:26:59,850 --> 00:27:05,130
exact method that takes a self and the

00:27:03,600 --> 00:27:08,700
list of local variables in your stack

00:27:05,130 --> 00:27:12,179
frames and from that if we can send that

00:27:08,700 --> 00:27:15,450
to the JVM value a good but again this

00:27:12,179 --> 00:27:19,920
is just code in our local VM which is

00:27:15,450 --> 00:27:23,370
talking to remote VM so how do we do

00:27:19,920 --> 00:27:26,460
this so we're going to do this in very

00:27:23,370 --> 00:27:29,309
quickly way but the simplest way I could

00:27:26,460 --> 00:27:30,630
find think of is we're going to compile

00:27:29,309 --> 00:27:33,650
this

00:27:30,630 --> 00:27:37,140
static global object to a class file

00:27:33,650 --> 00:27:40,410
we're going to somehow send it over to

00:27:37,140 --> 00:27:42,900
the remote jaeyun and then we are going

00:27:40,410 --> 00:27:44,940
to ask for remote JVM hey can you can

00:27:42,900 --> 00:27:47,030
grab a dot exact with the right

00:27:44,940 --> 00:27:50,240
arguments

00:27:47,030 --> 00:27:51,440
so as a shortcut I'm going to pretend

00:27:50,240 --> 00:27:55,010
this thing is in the standard library

00:27:51,440 --> 00:27:58,430
because I put it in the dirty library so

00:27:55,010 --> 00:28:01,520
this thing is just about doing remote

00:27:58,430 --> 00:28:04,900
code execution on any random program you

00:28:01,520 --> 00:28:06,860
have by sending it across path and

00:28:04,900 --> 00:28:09,230
ourself and the list of local variables

00:28:06,860 --> 00:28:12,680
and then using class reading tricks to

00:28:09,230 --> 00:28:14,870
run that code at runtime so basically

00:28:12,680 --> 00:28:18,230
what we want to do is figure out the

00:28:14,870 --> 00:28:23,900
class path of the object which was

00:28:18,230 --> 00:28:26,480
compiled find the reference to this in

00:28:23,900 --> 00:28:28,130
the stack frame make a map of all the

00:28:26,480 --> 00:28:31,820
local variables in a stack frame and

00:28:28,130 --> 00:28:38,680
then do a remote kind of the buggy eval

00:28:31,820 --> 00:28:41,510
with all this stuff and it's really

00:28:38,680 --> 00:28:45,160
terrible a bit code but it's doable

00:28:41,510 --> 00:28:48,200
using the Java is virtually IEP eyes so

00:28:45,160 --> 00:28:51,650
I won't go through the details but

00:28:48,200 --> 00:28:54,500
basically you you can resolve the thing

00:28:51,650 --> 00:29:00,110
into executing that stuff and by the way

00:28:54,500 --> 00:29:02,960
to contrast this with house a rascal ID

00:29:00,110 --> 00:29:05,240
does debugging the sky ID does debugging

00:29:02,960 --> 00:29:08,960
by basically taking your expression and

00:29:05,240 --> 00:29:11,780
then doing about 20 compiler phases of

00:29:08,960 --> 00:29:15,800
transformations to try to transform that

00:29:11,780 --> 00:29:20,960
into expressions but can into basically

00:29:15,800 --> 00:29:23,450
calls to the JDI api's so every scanner

00:29:20,960 --> 00:29:25,940
feature basically very implement using

00:29:23,450 --> 00:29:28,220
the GDI api's so as you can imagine

00:29:25,940 --> 00:29:31,850
that's like very complicated and very

00:29:28,220 --> 00:29:35,150
fermentation is 8,000 grams of god

00:29:31,850 --> 00:29:39,650
whereas this is this hike is like a few

00:29:35,150 --> 00:29:44,900
hundred miles I think and just to show

00:29:39,650 --> 00:29:48,230
you that this actually works I'm going

00:29:44,900 --> 00:29:51,610
to try to do a second demo because I'm

00:29:48,230 --> 00:29:51,610
very daring today

00:29:53,560 --> 00:30:03,680
so this is BS card again but this time

00:29:57,440 --> 00:30:05,840
we're using it on dotty itself so the

00:30:03,680 --> 00:30:08,300
way debugging works is you have launched

00:30:05,840 --> 00:30:10,400
the JSON file which is automatically

00:30:08,300 --> 00:30:12,890
generated at the first time you you do

00:30:10,400 --> 00:30:18,890
will run the debugger or you can specify

00:30:12,890 --> 00:30:21,500
say what the main class is what the

00:30:18,890 --> 00:30:22,550
project name is the arguments it's a is

00:30:21,500 --> 00:30:25,280
a Java class path

00:30:22,550 --> 00:30:28,130
so we're going to run using our debugger

00:30:25,280 --> 00:30:32,240
which is a compiler or compiler itself

00:30:28,130 --> 00:30:38,480
to compare something so we're going to

00:30:32,240 --> 00:30:42,170
compile obvious is to be just a dummy

00:30:38,480 --> 00:30:48,230
object with a field of type any that

00:30:42,170 --> 00:30:51,020
contains an int and this example is

00:30:48,230 --> 00:30:54,950
non-trivial because this is a primitive

00:30:51,020 --> 00:30:56,630
and this becomes object on the JVM so

00:30:54,950 --> 00:31:00,830
there's something that happens somewhere

00:30:56,630 --> 00:31:04,100
in the compiler and this something is

00:31:00,830 --> 00:31:05,960
called boxing it happens in Roger so if

00:31:04,100 --> 00:31:08,300
you go to a Roger your phantom effort

00:31:05,960 --> 00:31:13,580
word bucks so we can put a breakpoint on

00:31:08,300 --> 00:31:16,960
that method and then we can press f5 and

00:31:13,580 --> 00:31:16,960
hope little crashes

00:31:18,260 --> 00:31:25,220
yes so on the left you already have so

00:31:23,570 --> 00:31:27,260
obvious stuff is basically what we get

00:31:25,220 --> 00:31:30,350
for free thanks to Microsoft Java debug

00:31:27,260 --> 00:31:33,350
server this is the stack frame and you

00:31:30,350 --> 00:31:35,390
can like dig deep into a stack frame if

00:31:33,350 --> 00:31:37,669
you want so we have a tree which has a

00:31:35,390 --> 00:31:42,710
field called crunched which has a few

00:31:37,669 --> 00:31:45,440
code tag we have a car stack of all the

00:31:42,710 --> 00:31:51,230
methods we called in jump back and forth

00:31:45,440 --> 00:31:52,669
and on this side we have a code and we

00:31:51,230 --> 00:31:55,100
already have these cool things where I

00:31:52,669 --> 00:31:57,230
can hover over some variable and if it's

00:31:55,100 --> 00:32:03,530
something which is on the stack frame I

00:31:57,230 --> 00:32:06,440
see its content right now but then the

00:32:03,530 --> 00:32:07,850
interesting part the the thing I

00:32:06,440 --> 00:32:11,510
actually did and did not steal from

00:32:07,850 --> 00:32:19,220
Microsoft let's see

00:32:11,510 --> 00:32:23,350
I can type pointer and and prints foo

00:32:19,220 --> 00:32:30,400
and return something of type box units

00:32:23,350 --> 00:32:30,400
we can type 3 and I get back my tree

00:32:38,020 --> 00:32:48,580
I don't get back my trick cause 3 is not

00:32:40,539 --> 00:32:50,380
in scope but anyway so we can go deep

00:32:48,580 --> 00:32:55,179
into that method and just look at what

00:32:50,380 --> 00:32:57,730
is going to return in the end so in the

00:32:55,179 --> 00:33:04,929
end we get to that line and can shake

00:32:57,730 --> 00:33:08,919
that in fact Arg is empty we get the

00:33:04,929 --> 00:33:10,690
breanne and we honest first yeah that's

00:33:08,919 --> 00:33:13,320
all gasp boxing going on you can also

00:33:10,690 --> 00:33:13,320
like do print

00:33:20,300 --> 00:33:29,870
all right now so what's going on here so

00:33:24,540 --> 00:33:35,940
class what's that for just some symbol

00:33:29,870 --> 00:33:37,410
if I print it I see what symbolic as int

00:33:35,940 --> 00:33:41,610
which makes sense right

00:33:37,410 --> 00:33:45,270
and then invisible Doc's method and then

00:33:41,610 --> 00:33:47,190
we call - rats so you can probably

00:33:45,270 --> 00:33:50,960
already guess about that kind of those

00:33:47,190 --> 00:33:50,960
but we can run it and see

00:34:04,549 --> 00:34:11,869
so we got i dint of box so ident is a

00:34:08,750 --> 00:34:13,730
kind of tree but this isn't a very nice

00:34:11,869 --> 00:34:16,669
representation of a tree because it just

00:34:13,730 --> 00:34:18,169
roll abstract syntax tree and usually

00:34:16,669 --> 00:34:20,179
what we want to do is pretty print it

00:34:18,169 --> 00:34:22,069
for debugging so we have a dodge from

00:34:20,179 --> 00:34:24,760
efforts from pretty painting but the

00:34:22,069 --> 00:34:27,829
dojo method takes an implicit context ah

00:34:24,760 --> 00:34:29,510
and they'll be very annoying to pass

00:34:27,829 --> 00:34:31,129
back by hand but a we're actually

00:34:29,510 --> 00:34:33,109
running the full compiler here so you

00:34:31,129 --> 00:34:35,779
can just type dot show and you're going

00:34:33,109 --> 00:34:39,379
to do implicit resolution by itself at

00:34:35,779 --> 00:34:39,980
one time yes so here we get scared in

00:34:39,379 --> 00:34:42,440
that box

00:34:39,980 --> 00:34:47,510
which is pretty printed a representation

00:34:42,440 --> 00:34:50,270
of a tree and now we can go further and

00:34:47,510 --> 00:34:51,649
say well what does this thing apply to

00:34:50,270 --> 00:34:57,109
this thing do well you can probably

00:34:51,649 --> 00:35:00,020
guess which is going to apply the two

00:34:57,109 --> 00:35:06,500
things together so I do apply it to

00:35:00,020 --> 00:35:10,039
three and I get a dot in that box of 42

00:35:06,500 --> 00:35:11,839
and maybe you don't know what sky that

00:35:10,039 --> 00:35:17,990
in that box does so you can also type

00:35:11,839 --> 00:35:25,150
that here you survive I guess an integer

00:35:17,990 --> 00:35:25,150
whose value is 42 all right

00:35:27,340 --> 00:35:33,469
[Applause]

00:35:35,210 --> 00:35:39,960
so there's a bunch of more things we

00:35:38,640 --> 00:35:42,980
want to do when we haven't done yet

00:35:39,960 --> 00:35:42,980
Timmy's ations

00:35:43,010 --> 00:35:50,900
more features because this is what we're

00:35:46,170 --> 00:35:53,940
all about adding features everywhere

00:35:50,900 --> 00:35:57,390
so when big one is documentation and a

00:35:53,940 --> 00:35:59,160
hover which is coming very soon and of

00:35:57,390 --> 00:36:01,320
course we're also interested in a better

00:35:59,160 --> 00:36:04,440
ability to integration of with the bits

00:36:01,320 --> 00:36:11,609
of a protocol let's swim but hopefully

00:36:04,440 --> 00:36:15,590
soon ish and there might be even more

00:36:11,609 --> 00:36:19,230
things we can do say what we have in the

00:36:15,590 --> 00:36:21,020
debugging panel in vs code is kind of a

00:36:19,230 --> 00:36:23,400
wrapper but it's a very limited record

00:36:21,020 --> 00:36:26,609
because you don't have all your own

00:36:23,400 --> 00:36:29,369
syntax writing of your apparel features

00:36:26,609 --> 00:36:33,330
a lot so I think it'd make a lot of

00:36:29,369 --> 00:36:36,150
sense if we made a weapon also a

00:36:33,330 --> 00:36:38,760
client-server model so we could use the

00:36:36,150 --> 00:36:41,460
regular scalar weapon to connect to your

00:36:38,760 --> 00:36:45,210
debugger and to get all the experience

00:36:41,460 --> 00:36:46,589
you get from the regular wrapper and

00:36:45,210 --> 00:36:52,890
maybe you could even connect that to the

00:36:46,589 --> 00:36:56,849
AK a Jupiter kernel or something all

00:36:52,890 --> 00:36:58,830
right so to conclude I think it's

00:36:56,849 --> 00:37:00,480
important to design your companion with

00:36:58,830 --> 00:37:02,490
interactivity in mind because a lot of

00:37:00,480 --> 00:37:05,580
features we're seeing here only works

00:37:02,490 --> 00:37:08,099
because we've tried to take our

00:37:05,580 --> 00:37:10,050
interactivity into account when

00:37:08,099 --> 00:37:13,050
designing various parts of dotty

00:37:10,050 --> 00:37:14,520
for example tasty was not at all

00:37:13,050 --> 00:37:17,970
designed for the idea features

00:37:14,520 --> 00:37:21,210
originally and it sort of worked but we

00:37:17,970 --> 00:37:25,020
had to be very careful to preserve all

00:37:21,210 --> 00:37:28,170
the shape of trees of the user world and

00:37:25,020 --> 00:37:29,970
over position much more precisely for

00:37:28,170 --> 00:37:32,520
the ID features event well that doesn't

00:37:29,970 --> 00:37:36,359
really help for any other kind of usage

00:37:32,520 --> 00:37:38,369
of tasty so far ensure cities on your

00:37:36,359 --> 00:37:39,010
bit of interactivity in mind because if

00:37:38,369 --> 00:37:41,230
you don't

00:37:39,010 --> 00:37:46,570
when everyone has to hack around it's in

00:37:41,230 --> 00:37:49,060
terrible ways and I think once we do

00:37:46,570 --> 00:37:52,960
that then we get roughly to like expand

00:37:49,060 --> 00:37:55,060
online and make interactivity go beyond

00:37:52,960 --> 00:37:57,940
what idea is and repress your aunty

00:37:55,060 --> 00:37:59,920
affair and if you haven't read it you

00:37:57,940 --> 00:38:02,410
should check out the book time driven

00:37:59,920 --> 00:38:05,890
development with Idris by Edwin Brady

00:38:02,410 --> 00:38:08,770
which is sort of a glimpse of the kind

00:38:05,890 --> 00:38:10,780
of things we could do if we didn't have

00:38:08,770 --> 00:38:13,570
to solve the basic problems over and

00:38:10,780 --> 00:38:15,400
over again so hopefully we'll gather and

00:38:13,570 --> 00:38:32,230
with a more interesting stuff in your

00:38:15,400 --> 00:38:35,050
future thank you hey great work I might

00:38:32,230 --> 00:38:40,270
have missed this you mentioned in the

00:38:35,050 --> 00:38:41,820
beginning when you mentioned canceled on

00:38:40,270 --> 00:38:44,590
non-cancelable compilation when you're

00:38:41,820 --> 00:38:49,590
when the idea is doing a per keystroke

00:38:44,590 --> 00:38:52,690
compilation is the tasty tree being

00:38:49,590 --> 00:38:56,200
recreated upon every keystroke or is it

00:38:52,690 --> 00:38:57,850
just being incrementally added upon so

00:38:56,200 --> 00:39:00,510
the tasty tree is only generated

00:38:57,850 --> 00:39:02,680
currently when we do a full completion

00:39:00,510 --> 00:39:05,590
for things which are just opening your

00:39:02,680 --> 00:39:09,130
IDs in buffers we just type check them

00:39:05,590 --> 00:39:10,810
and we keep that in memory we only go to

00:39:09,130 --> 00:39:16,240
tasty when we need to read something

00:39:10,810 --> 00:39:19,150
from disk and also where can we fern

00:39:16,240 --> 00:39:22,980
find the current work in progress for

00:39:19,150 --> 00:39:22,980
taste to use it on a branch on dolly

00:39:23,520 --> 00:39:32,350
so most of it is just in master already

00:39:28,780 --> 00:39:34,530
lost of duty of AC and then stuff like

00:39:32,350 --> 00:39:36,880
the documentation support is also

00:39:34,530 --> 00:39:41,080
something that will become part of tasty

00:39:36,880 --> 00:39:43,600
and that's a poor request by matter by

00:39:41,080 --> 00:39:45,780
whom by Martin ahem who's sitting right

00:39:43,600 --> 00:39:45,780
there

00:39:54,040 --> 00:40:01,570
this is a question about tasty so are we

00:39:58,960 --> 00:40:04,690
you know right now we have all these

00:40:01,570 --> 00:40:07,450
class files I mean we have jars stored

00:40:04,690 --> 00:40:11,440
in maven repository right I mean in the

00:40:07,450 --> 00:40:13,599
archive are any of the repositories we

00:40:11,440 --> 00:40:17,560
have in the organization so will we

00:40:13,599 --> 00:40:19,180
start storing teste trees also house

00:40:17,560 --> 00:40:22,930
house that won't work

00:40:19,180 --> 00:40:25,210
yeah so the question is about how is

00:40:22,930 --> 00:40:27,460
tasty enough because you might have a

00:40:25,210 --> 00:40:30,609
lot of casa files from existing projects

00:40:27,460 --> 00:40:33,460
from maven Java projects and the Ansari

00:40:30,609 --> 00:40:35,079
is probably not so I didn't mention it

00:40:33,460 --> 00:40:37,770
in the talk I guess I should have but

00:40:35,079 --> 00:40:42,730
first this project called semantic TB

00:40:37,770 --> 00:40:44,740
which is about generating basically what

00:40:42,730 --> 00:40:47,920
happens to an index of the kind of

00:40:44,740 --> 00:40:50,589
things you could do for ID for semantic

00:40:47,920 --> 00:40:52,420
features in an IDE so like for every

00:40:50,589 --> 00:40:53,849
symbol what are all the positions for

00:40:52,420 --> 00:40:59,369
its reference what kind of things and

00:40:53,849 --> 00:40:59,369
semantics DB is language independence

00:40:59,550 --> 00:41:05,829
there's a java implementation which

00:41:02,770 --> 00:41:09,190
reads classifiers I think and there's a

00:41:05,829 --> 00:41:11,020
skeleton origin or so and so what kind

00:41:09,190 --> 00:41:14,829
of things can missing a sort of an index

00:41:11,020 --> 00:41:17,470
of what you could get from current st

00:41:14,829 --> 00:41:20,560
directly so i think that in the end we

00:41:17,470 --> 00:41:22,270
want sort of a mix of the to use teste

00:41:20,560 --> 00:41:25,599
for your local project and for all your

00:41:22,270 --> 00:41:27,550
dependencies you'd use some index which

00:41:25,599 --> 00:41:30,640
might be the semantic DVD or some of our

00:41:27,550 --> 00:41:32,859
formats so the distributions will

00:41:30,640 --> 00:41:36,819
continue to be classified me jars

00:41:32,859 --> 00:41:40,780
actually also so for 30 projects we we

00:41:36,819 --> 00:41:42,790
basically ship the tasty as part of the

00:41:40,780 --> 00:41:45,250
classifiers as an extra section in the

00:41:42,790 --> 00:41:47,980
classifiers we might become separate

00:41:45,250 --> 00:41:49,359
files also in the jars but they're

00:41:47,980 --> 00:41:52,150
always being the dress because you need

00:41:49,359 --> 00:41:54,849
them just for separate compilation they

00:41:52,150 --> 00:41:57,790
don't add too much to the size of the

00:41:54,849 --> 00:42:00,099
jar because where they are pretty well

00:41:57,790 --> 00:42:03,369
compressed so it's a reasonable thing to

00:42:00,099 --> 00:42:06,070
have in all your trust so the second

00:42:03,369 --> 00:42:08,800
question is about the remote

00:42:06,070 --> 00:42:10,450
occasion of the cords right is that do

00:42:08,800 --> 00:42:11,830
you see any potential security issues

00:42:10,450 --> 00:42:15,040
with respect to them

00:42:11,830 --> 00:42:17,710
seniority issues for the film or debug

00:42:15,040 --> 00:42:26,140
if a question is about security issues

00:42:17,710 --> 00:42:28,480
with remote debugging stuff so the Casa

00:42:26,140 --> 00:42:30,520
added to the standard library for my

00:42:28,480 --> 00:42:32,350
experiment is kind of questionable which

00:42:30,520 --> 00:42:35,580
is actually not necessary we could do

00:42:32,350 --> 00:42:38,590
everything I do with distress using just

00:42:35,580 --> 00:42:42,960
Java debugging interface API remote

00:42:38,590 --> 00:42:47,740
procedure calls so just manually calling

00:42:42,960 --> 00:42:51,220
Java dodd/frank ass loader that whatever

00:42:47,740 --> 00:42:53,440
we can do that using remote cars so it's

00:42:51,220 --> 00:42:58,240
not more of a security issue than

00:42:53,440 --> 00:43:01,180
everything in the JVM already is there

00:42:58,240 --> 00:43:03,040
any path by which any of this work could

00:43:01,180 --> 00:43:10,920
benefit small to users

00:43:03,040 --> 00:43:14,260
yes so on the general idea front where

00:43:10,920 --> 00:43:16,780
it's kind of hard to reuse because we

00:43:14,260 --> 00:43:19,480
depend on tasty we depend on the

00:43:16,780 --> 00:43:22,450
internals of duty but I don't think we

00:43:19,480 --> 00:43:24,760
need to because they are over the edge

00:43:22,450 --> 00:43:28,930
server implementation for Scala - I'm

00:43:24,760 --> 00:43:31,600
especially thinking of metals which

00:43:28,930 --> 00:43:35,410
already deliver very similar kind of

00:43:31,600 --> 00:43:39,130
features and which are very like tuned

00:43:35,410 --> 00:43:43,440
for skeleton but for the debugger the

00:43:39,130 --> 00:43:48,430
basic principles I use of hiking around

00:43:43,440 --> 00:43:50,680
the Java debug API is to shove code into

00:43:48,430 --> 00:43:53,980
your remote VM that's like something

00:43:50,680 --> 00:43:58,080
that could be easily reused in any

00:43:53,980 --> 00:43:58,080

YouTube URL: https://www.youtube.com/watch?v=R77XYOtuomE


