Title: Functional Interpreters and You by Mark Mynsted
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/functional-interpreters-and-you
Captions: 
	00:00:04,809 --> 00:00:09,469
okay so this talk is about the

00:00:07,220 --> 00:00:10,969
interpreter pattern you can use it to

00:00:09,469 --> 00:00:12,889
make your skull programs more modular

00:00:10,969 --> 00:00:15,559
and easier to maintain I'll go through

00:00:12,889 --> 00:00:19,519
all the details as we go has anyone

00:00:15,559 --> 00:00:25,340
heard of free monads show hands please

00:00:19,519 --> 00:00:27,830
okay good tag goes final okay so we'll

00:00:25,340 --> 00:00:29,660
get to that those are parts of the

00:00:27,830 --> 00:00:35,030
interpreter pattern and we compose them

00:00:29,660 --> 00:00:38,870
from some simpler concepts so this work

00:00:35,030 --> 00:00:40,760
is this talk is largely the work of Dave

00:00:38,870 --> 00:00:44,449
Grinnell who gave the talk in Berlin

00:00:40,760 --> 00:00:46,010
with some my own modifications so you

00:00:44,449 --> 00:00:51,399
can give positive feedback to me and

00:00:46,010 --> 00:00:51,399
critiques you can send it Dave alright

00:00:52,089 --> 00:01:02,889
so show of hands who knows cats anyone I

00:00:56,479 --> 00:01:06,979
know okay cats okay good all right and

00:01:02,889 --> 00:01:11,360
for the rest of you that's a cat all

00:01:06,979 --> 00:01:13,220
right so a cat is an inert creature as

00:01:11,360 --> 00:01:18,560
you know cats don't prepare their own

00:01:13,220 --> 00:01:21,350
food but they do eat so they just

00:01:18,560 --> 00:01:24,290
indicate their need for food to their

00:01:21,350 --> 00:01:26,150
handlers or their staff and then it's

00:01:24,290 --> 00:01:29,060
the staffs responsibility to interpret

00:01:26,150 --> 00:01:35,060
the need and carry out the actions to

00:01:29,060 --> 00:01:37,850
address the problem so and when you do

00:01:35,060 --> 00:01:44,270
crisis is averted and cat is well fed

00:01:37,850 --> 00:01:46,250
and it looks very relaxed okay so Scala

00:01:44,270 --> 00:01:51,080
Scala is a general-purpose programming

00:01:46,250 --> 00:01:52,670
language that means that you could do

00:01:51,080 --> 00:01:54,920
all kinds of things with it for this

00:01:52,670 --> 00:01:59,090
talk I'm going to confine what we mean

00:01:54,920 --> 00:02:02,420
by a program a little bit so for this

00:01:59,090 --> 00:02:06,100
we're going to say that a program is a

00:02:02,420 --> 00:02:06,100
block of code that computes a result

00:02:06,760 --> 00:02:11,840
this could be a command line application

00:02:08,810 --> 00:02:15,459
endpoint web service or some kind of

00:02:11,840 --> 00:02:15,459
piece of a larger application

00:02:15,770 --> 00:02:20,450
general-purpose programming languages

00:02:18,200 --> 00:02:21,070
are Jack's of all trades but master of

00:02:20,450 --> 00:02:27,400
none

00:02:21,070 --> 00:02:29,750
so a typical program has you know

00:02:27,400 --> 00:02:32,150
incorporates a lot of implementation

00:02:29,750 --> 00:02:33,800
details and these details clutter the

00:02:32,150 --> 00:02:36,980
program making it harder to read and to

00:02:33,800 --> 00:02:38,540
reason about so one way of getting rid

00:02:36,980 --> 00:02:41,270
of the details is to create a higher

00:02:38,540 --> 00:02:42,530
level domain-specific language that is

00:02:41,270 --> 00:02:44,330
tailored to the particular type of

00:02:42,530 --> 00:02:47,240
problem so you create this

00:02:44,330 --> 00:02:51,320
domain-specific language it's tailored

00:02:47,240 --> 00:02:53,900
and confined to your problem domain we

00:02:51,320 --> 00:02:56,150
choose a set of atomic steps to hide the

00:02:53,900 --> 00:03:01,880
implementation details and make the code

00:02:56,150 --> 00:03:05,570
easier to read the drawback is that a

00:03:01,880 --> 00:03:11,030
DSL has no compiler and no runtime

00:03:05,570 --> 00:03:12,590
environment so so we split the code base

00:03:11,030 --> 00:03:14,780
into two parts we have a program that

00:03:12,590 --> 00:03:16,660
represents a set of steps to run an

00:03:14,780 --> 00:03:19,880
interpreter that takes a program as

00:03:16,660 --> 00:03:26,660
input does the work it produces the

00:03:19,880 --> 00:03:28,400
result ok programs like cats are inert

00:03:26,660 --> 00:03:29,630
they represent the structure of

00:03:28,400 --> 00:03:32,959
computation but they don't do anything

00:03:29,630 --> 00:03:34,459
on their own they can't the interpreter

00:03:32,959 --> 00:03:37,310
provides the implementation details

00:03:34,459 --> 00:03:39,830
necessary for the program to run and has

00:03:37,310 --> 00:03:41,420
the semantics the host language has a

00:03:39,830 --> 00:03:44,270
compiler and a runtime environment to

00:03:41,420 --> 00:03:46,490
make all this work so splitting our code

00:03:44,270 --> 00:03:49,430
base into two has numerous advantages in

00:03:46,490 --> 00:03:51,100
terms of modularity and reuse so you can

00:03:49,430 --> 00:03:54,680
separate your concerns and then you can

00:03:51,100 --> 00:03:57,260
make it much more reasonably better so

00:03:54,680 --> 00:03:59,270
from the interpreters point of view you

00:03:57,260 --> 00:04:02,180
can write an interpreter and reuse it

00:03:59,270 --> 00:04:04,760
with lots of programs so you can have

00:04:02,180 --> 00:04:06,680
the same interpreter and you've composed

00:04:04,760 --> 00:04:12,830
these different programs with this DSL

00:04:06,680 --> 00:04:15,020
and you get different results and it's

00:04:12,830 --> 00:04:16,489
easier to understand because we've taken

00:04:15,020 --> 00:04:19,340
care of all the implementation details

00:04:16,489 --> 00:04:21,620
in one place from all in one place from

00:04:19,340 --> 00:04:23,090
the program's point of view we can have

00:04:21,620 --> 00:04:26,200
a different set of interpreters that

00:04:23,090 --> 00:04:28,950
interpret the program in different ways

00:04:26,200 --> 00:04:35,220
so you have one program many in

00:04:28,950 --> 00:04:36,390
there's different results so we can

00:04:35,220 --> 00:04:38,280
create interpreters that produce

00:04:36,390 --> 00:04:39,450
different kinds of results like you

00:04:38,280 --> 00:04:42,330
could have something that does pretty

00:04:39,450 --> 00:04:45,480
printing you could explain the results

00:04:42,330 --> 00:04:48,230
as you run through them you can do other

00:04:45,480 --> 00:04:48,230
things as well

00:04:48,470 --> 00:04:55,440
another way is you are another thing you

00:04:51,150 --> 00:04:56,970
could do is to abstract over effects for

00:04:55,440 --> 00:04:59,670
example you could write an asynchronous

00:04:56,970 --> 00:05:02,100
interpreter that runs branches in

00:04:59,670 --> 00:05:05,970
parallel you can also abstract over

00:05:02,100 --> 00:05:11,880
monads which I mean do bees connection

00:05:05,970 --> 00:05:13,770
i/o and so forth finally we can write

00:05:11,880 --> 00:05:15,480
interpreters a consume one program and

00:05:13,770 --> 00:05:19,020
produce output of another program which

00:05:15,480 --> 00:05:23,220
would be a compiler essentially even

00:05:19,020 --> 00:05:24,570
though that would be more complicated so

00:05:23,220 --> 00:05:27,600
the interpreter pattern has numerous

00:05:24,570 --> 00:05:30,470
benefits for modularity and reuse you

00:05:27,600 --> 00:05:33,090
get these you know reuse of interpreters

00:05:30,470 --> 00:05:35,100
multiple interpreters abstraction over

00:05:33,090 --> 00:05:38,040
effects these are the things you kind of

00:05:35,100 --> 00:05:41,340
get for free when you when you do this

00:05:38,040 --> 00:05:43,410
if you want inspection rewriting and

00:05:41,340 --> 00:05:45,420
compiling programs there's going to be a

00:05:43,410 --> 00:05:50,340
little bit of extra work to make that

00:05:45,420 --> 00:05:52,200
happen but we'll see that later there's

00:05:50,340 --> 00:05:54,150
a couple of big approaches to defining

00:05:52,200 --> 00:05:55,350
defining dsls

00:05:54,150 --> 00:06:04,770
and we'll go through each of them in the

00:05:55,350 --> 00:06:07,890
talk okay the two main approaches would

00:06:04,770 --> 00:06:11,610
be reification in church and coding so

00:06:07,890 --> 00:06:13,500
reification is modeling the program as

00:06:11,610 --> 00:06:15,900
data and church encoding is an

00:06:13,500 --> 00:06:19,320
alternative to reification and we

00:06:15,900 --> 00:06:22,460
represent the the program as a sequence

00:06:19,320 --> 00:06:22,460
of abstract method calls

00:06:24,390 --> 00:06:31,510
if we look at various ways of refining

00:06:27,280 --> 00:06:36,160
of reef I'd dsls we eventually end up

00:06:31,510 --> 00:06:38,650
finding the free monad so reification to

00:06:36,160 --> 00:06:40,840
free so that's where your if you've

00:06:38,650 --> 00:06:42,580
heard a free monad and you want to see

00:06:40,840 --> 00:06:44,800
how that applies to interpreter pattern

00:06:42,580 --> 00:06:47,980
then that's the reification where we

00:06:44,800 --> 00:06:49,360
model programs this data if you look at

00:06:47,980 --> 00:06:53,620
church encoding where you have the

00:06:49,360 --> 00:06:55,570
abstract method calls you know then that

00:06:53,620 --> 00:07:02,410
leads us down the route of tagless final

00:06:55,570 --> 00:07:06,010
that's how we implement tagless final so

00:07:02,410 --> 00:07:08,620
there's another axis of consideration

00:07:06,010 --> 00:07:12,940
for creating dsls you know like how

00:07:08,620 --> 00:07:18,540
closely does the DSL align with the the

00:07:12,940 --> 00:07:22,270
host language in this case Scala so

00:07:18,540 --> 00:07:24,510
there's advantages to each so at one end

00:07:22,270 --> 00:07:27,940
of the spectrum you have a standalone

00:07:24,510 --> 00:07:29,860
which is completely custom independent

00:07:27,940 --> 00:07:32,200
of the host language or you can have it

00:07:29,860 --> 00:07:34,810
be embedded which aligns with the host

00:07:32,200 --> 00:07:39,250
language reuse the host and reuses the

00:07:34,810 --> 00:07:41,470
host language features so you probably

00:07:39,250 --> 00:07:43,840
want something along the lines of the

00:07:41,470 --> 00:07:46,420
embedded style so that you can reuse the

00:07:43,840 --> 00:07:48,040
semantics of the host language unless

00:07:46,420 --> 00:07:50,560
you have a need to be completely

00:07:48,040 --> 00:07:52,270
standalone and if you do then you you

00:07:50,560 --> 00:07:54,940
would know why and then you would pay

00:07:52,270 --> 00:08:01,080
the penalty of writing all the semantics

00:07:54,940 --> 00:08:05,710
yourself okay so we're gonna go through

00:08:01,080 --> 00:08:10,000
various types of DSL and coatings so

00:08:05,710 --> 00:08:12,070
we're gonna do the reified first so the

00:08:10,000 --> 00:08:14,200
hello world of DSL is always a

00:08:12,070 --> 00:08:22,240
calculator so we're going to start with

00:08:14,200 --> 00:08:25,090
that so this lot we're going to do

00:08:22,240 --> 00:08:28,590
addition and multiplication like this

00:08:25,090 --> 00:08:32,860
this is our it's a good starting point

00:08:28,590 --> 00:08:35,760
so let's figure out how we can represent

00:08:32,860 --> 00:08:38,200
programs this way you know type in Scala

00:08:35,760 --> 00:08:44,020
simplest representation is to wrap it

00:08:38,200 --> 00:08:52,540
an expression and a function so so here

00:08:44,020 --> 00:08:55,620
we have a program and you it works this

00:08:52,540 --> 00:08:57,730
it works as a program because it

00:08:55,620 --> 00:08:59,890
represents what we want to do but it

00:08:57,730 --> 00:09:02,620
doesn't actually do anything you have to

00:08:59,890 --> 00:09:09,550
call it in order to make a function and

00:09:02,620 --> 00:09:10,780
execute but rather than call a function

00:09:09,550 --> 00:09:14,560
directly we're gonna create an

00:09:10,780 --> 00:09:19,150
interpreter to run them so we have

00:09:14,560 --> 00:09:23,260
created an interpreter and we execute

00:09:19,150 --> 00:09:26,340
the program so does anyone see anything

00:09:23,260 --> 00:09:30,790
that might be wrong what this at all

00:09:26,340 --> 00:09:35,080
right there's not very much that we can

00:09:30,790 --> 00:09:39,120
do with with this evaluation this

00:09:35,080 --> 00:09:42,370
interpreter the the programs takes

00:09:39,120 --> 00:09:45,910
nothing and returns an int and so the

00:09:42,370 --> 00:09:48,760
only interpreter we can do is take a

00:09:45,910 --> 00:09:51,570
program that takes a null value or takes

00:09:48,760 --> 00:09:53,560
nothing and then returns an int and so

00:09:51,570 --> 00:09:56,110
there's not much that we can reason

00:09:53,560 --> 00:09:57,760
about we can't look inside the program

00:09:56,110 --> 00:10:01,930
the function to see what's happening

00:09:57,760 --> 00:10:05,560
it's opaque and then to execute it you

00:10:01,930 --> 00:10:07,990
know to evaluate this program the only

00:10:05,560 --> 00:10:13,590
thing that we can do is just execute the

00:10:07,990 --> 00:10:13,590
function so it's not great okay

00:10:16,720 --> 00:10:22,900
so here's one candidate encoding it's a

00:10:20,740 --> 00:10:26,560
program as an expression has three

00:10:22,900 --> 00:10:30,700
concrete things so we've got this sealed

00:10:26,560 --> 00:10:32,920
trait and we have the the literal and an

00:10:30,700 --> 00:10:34,150
addition and multiplication and so we

00:10:32,920 --> 00:10:35,980
need the literal so that we can have the

00:10:34,150 --> 00:10:38,530
values we need the addition so that we

00:10:35,980 --> 00:10:40,420
can add together the two expressions and

00:10:38,530 --> 00:10:42,700
we have multiplication so that we can

00:10:40,420 --> 00:10:44,290
multiply the two expressions and you can

00:10:42,700 --> 00:10:46,450
see there they are all expressions

00:10:44,290 --> 00:10:49,690
because they these case classes all

00:10:46,450 --> 00:10:50,940
extend the expression trait so we have

00:10:49,690 --> 00:10:57,030
defined this as

00:10:50,940 --> 00:10:58,620
data okay so with this DSL we can

00:10:57,030 --> 00:11:00,360
represent the same steps that we saw

00:10:58,620 --> 00:11:03,270
before where we had just you know like

00:11:00,360 --> 00:11:05,880
one plus three and multiplied it out

00:11:03,270 --> 00:11:07,080
we've just written it out with the

00:11:05,880 --> 00:11:09,180
expressions so we have like

00:11:07,080 --> 00:11:12,060
multiplication addition and the literals

00:11:09,180 --> 00:11:14,790
in place so we have literal one literal

00:11:12,060 --> 00:11:17,490
to add them all together so now we have

00:11:14,790 --> 00:11:26,730
a program that's a little a little

00:11:17,490 --> 00:11:28,260
better so the program represents the

00:11:26,730 --> 00:11:32,430
same calculation is a Scala function we

00:11:28,260 --> 00:11:34,110
had before but we can no longer run it

00:11:32,430 --> 00:11:35,790
directly that's right we need to

00:11:34,110 --> 00:11:37,560
introduce an interpreter because the

00:11:35,790 --> 00:11:39,300
expression is an algebraic data type of

00:11:37,560 --> 00:11:41,670
fixed set of subtypes it's easy to

00:11:39,300 --> 00:11:45,300
implement values encountered matching so

00:11:41,670 --> 00:11:47,580
that's what we've done so we can see

00:11:45,300 --> 00:11:50,010
with the interpreter which is eval

00:11:47,580 --> 00:11:52,890
method we're pattern matching on the

00:11:50,010 --> 00:11:54,750
expression and then you know we have the

00:11:52,890 --> 00:11:56,370
case class and in excel it's this way

00:11:54,750 --> 00:11:58,440
and then we actually executed at the

00:11:56,370 --> 00:11:59,820
bottom where we take the eval and then

00:11:58,440 --> 00:12:04,860
take the program as a parameter and

00:11:59,820 --> 00:12:06,900
execute it and get a result so there's

00:12:04,860 --> 00:12:09,320
lots of benefits for in terms of

00:12:06,900 --> 00:12:09,320
modularity

00:12:16,680 --> 00:12:21,670
we can write an asynchronous interpreter

00:12:19,690 --> 00:12:24,670
that evaluates the branches in our DSL

00:12:21,670 --> 00:12:26,680
in parallel so instead of you know just

00:12:24,670 --> 00:12:29,050
getting an expression we can model

00:12:26,680 --> 00:12:31,210
things with this future so that we can

00:12:29,050 --> 00:12:36,250
have things in parallel and it still

00:12:31,210 --> 00:12:37,630
works we can write a pretty print

00:12:36,250 --> 00:12:39,190
interpreter that traverses the

00:12:37,630 --> 00:12:42,160
expressions and prints them in string

00:12:39,190 --> 00:12:43,660
form and you can see that all we did you

00:12:42,160 --> 00:12:45,970
know we've modified this out and the

00:12:43,660 --> 00:12:48,880
return is the string so it's a pretty

00:12:45,970 --> 00:12:51,190
printable and we know how to pretty

00:12:48,880 --> 00:12:52,960
print because when we're pattern

00:12:51,190 --> 00:12:55,390
matching we go through we can see that

00:12:52,960 --> 00:12:57,220
we add things together you know we hit

00:12:55,390 --> 00:12:59,230
the case of ad and we know that it's in

00:12:57,220 --> 00:13:03,880
addition and we write out the string

00:12:59,230 --> 00:13:05,590
that we want it works nicely okay we can

00:13:03,880 --> 00:13:07,720
even write in compiler that alters the

00:13:05,590 --> 00:13:10,000
structure of the program that's what we

00:13:07,720 --> 00:13:13,300
talked about earlier where we had this

00:13:10,000 --> 00:13:15,160
compiler option this simplified method

00:13:13,300 --> 00:13:19,120
inspects and reorders the expressions to

00:13:15,160 --> 00:13:21,160
multiply out the brackets okay and we

00:13:19,120 --> 00:13:25,720
can do that because we know what all the

00:13:21,160 --> 00:13:27,610
things are we get all this flexibility

00:13:25,720 --> 00:13:29,950
because we've simplified the input

00:13:27,610 --> 00:13:31,780
language so by constraining the input of

00:13:29,950 --> 00:13:33,040
our interpreter we open up more options

00:13:31,780 --> 00:13:35,410
for its implementation

00:13:33,040 --> 00:13:43,120
so the first interpreter that we saw a

00:13:35,410 --> 00:13:46,510
saw was not very constrained and so we

00:13:43,120 --> 00:13:48,070
have much more options now let's see so

00:13:46,510 --> 00:13:52,240
a wise man once said constraints

00:13:48,070 --> 00:13:58,030
liberate and Liberty constraints words

00:13:52,240 --> 00:14:03,040
to live by an example providing it as

00:13:58,030 --> 00:14:04,150
simple let's see okay so what about

00:14:03,040 --> 00:14:07,240
types

00:14:04,150 --> 00:14:07,240
[Music]

00:14:08,880 --> 00:14:16,270
if things get more complicated then you

00:14:12,850 --> 00:14:26,230
probably want types let's see this by

00:14:16,270 --> 00:14:27,730
seeing an untyped yourself so we'll to

00:14:26,230 --> 00:14:29,020
discuss this we'll modify our program to

00:14:27,730 --> 00:14:34,690
remain a little by introducing

00:14:29,020 --> 00:14:42,520
comparisons and boolean operations so we

00:14:34,690 --> 00:14:43,870
have integers in billions here we can

00:14:42,520 --> 00:14:50,470
represent the program's exactly as

00:14:43,870 --> 00:14:53,470
before however we can represent invalid

00:14:50,470 --> 00:14:55,600
expressions also you can see that this

00:14:53,470 --> 00:14:57,790
doesn't make sense right if you have

00:14:55,600 --> 00:15:02,350
this less than and you have this and

00:14:57,790 --> 00:15:05,100
inside of it the you know how are you

00:15:02,350 --> 00:15:07,330
going to do an and of two literals or

00:15:05,100 --> 00:15:09,820
this just doesn't make sense

00:15:07,330 --> 00:15:12,270
but there's nothing preventing us from

00:15:09,820 --> 00:15:12,270
doing it

00:15:27,880 --> 00:15:32,529
so you could see like it you know what

00:15:31,180 --> 00:15:41,940
do you know about it from this

00:15:32,529 --> 00:15:41,940
expression you can pattern match through

00:15:43,740 --> 00:15:47,829
now if you get type errors you might

00:15:46,360 --> 00:15:51,339
want to handle the type errors with an

00:15:47,829 --> 00:15:53,949
either or you might want to handle the

00:15:51,339 --> 00:15:56,649
the errors within either and you could

00:15:53,949 --> 00:15:59,170
do that we could invent some arrow type

00:15:56,649 --> 00:16:04,199
here other than either but at least

00:15:59,170 --> 00:16:04,199
we're capturing it adds more structure

00:16:07,110 --> 00:16:12,310
we can handle the disjunction between

00:16:09,730 --> 00:16:13,959
the result types bringing by introducing

00:16:12,310 --> 00:16:18,220
an algebraic data type to wrap up the

00:16:13,959 --> 00:16:20,709
integer or a boolean the value of some

00:16:18,220 --> 00:16:28,089
type of expression is either an int

00:16:20,709 --> 00:16:30,730
value or a boolean value we can use some

00:16:28,089 --> 00:16:35,699
helper methods to make things a little

00:16:30,730 --> 00:16:35,699
bit better so you go through there

00:16:37,139 --> 00:16:43,420
there's a complete implementation that's

00:16:41,620 --> 00:16:45,880
that's provided where you could see all

00:16:43,420 --> 00:16:48,730
this stuff out but you probably want to

00:16:45,880 --> 00:16:52,259
help your methods if you want to get to

00:16:48,730 --> 00:16:58,029
pull out the value for the correct type

00:16:52,259 --> 00:16:59,620
so here's the key point the key point is

00:16:58,029 --> 00:17:01,779
that there's a mismatch between our DSL

00:16:59,620 --> 00:17:04,120
there's an impedance mismatch between

00:17:01,779 --> 00:17:06,760
our DSL which is untyped in the SKA

00:17:04,120 --> 00:17:09,189
language which is definitely tight so

00:17:06,760 --> 00:17:10,360
because we're not using the types we can

00:17:09,189 --> 00:17:15,909
represent things that we wouldn't

00:17:10,360 --> 00:17:20,919
normally represent in Scala how can we

00:17:15,909 --> 00:17:23,829
make this simpler so so the way to make

00:17:20,919 --> 00:17:25,870
it simpler would be to use types so

00:17:23,829 --> 00:17:28,089
rather than having to inspect everything

00:17:25,870 --> 00:17:31,710
and have potential errors and all this

00:17:28,089 --> 00:17:31,710
kind of stuff is we can use the types

00:17:33,220 --> 00:17:39,669
just recall this is what our untyped DSL

00:17:35,980 --> 00:17:42,280
looked like so to type two ad types to

00:17:39,669 --> 00:17:45,789
it we just add a type parameter so we

00:17:42,280 --> 00:17:49,990
have this parameter a and it's just the

00:17:45,789 --> 00:17:51,970
type that the expression will compute so

00:17:49,990 --> 00:17:55,630
literal can return any type less and

00:17:51,970 --> 00:17:58,270
returns a boolean and expects operands

00:17:55,630 --> 00:18:06,280
that return integers and boolean expects

00:17:58,270 --> 00:18:08,470
our answer turns billions so the good

00:18:06,280 --> 00:18:12,429
thing is that a type DSL allows us to

00:18:08,470 --> 00:18:16,299
express and valid programs with exactly

00:18:12,429 --> 00:18:18,130
the same syntax as the untyped DSL but

00:18:16,299 --> 00:18:23,169
it protects us because it has the types

00:18:18,130 --> 00:18:24,429
and the Scala compiler is checking the

00:18:23,169 --> 00:18:26,470
result types whenever we need an

00:18:24,429 --> 00:18:30,730
expression it makes it impossible for us

00:18:26,470 --> 00:18:33,100
to represent them with proper code it

00:18:30,730 --> 00:18:40,690
won't compile if we have a type error so

00:18:33,100 --> 00:18:43,990
that's good the advantage is that the

00:18:40,690 --> 00:18:46,240
types in our DSL mapped directly onto

00:18:43,990 --> 00:18:47,909
the types in Scala so the implementation

00:18:46,240 --> 00:18:51,760
of our interpreter becomes trivial

00:18:47,909 --> 00:18:53,409
because we're leaning on the Scala host

00:18:51,760 --> 00:18:55,330
language we can take advantage of the

00:18:53,409 --> 00:18:58,210
type system and we can make our stuff a

00:18:55,330 --> 00:18:59,710
lot simpler we don't have to we use the

00:18:58,210 --> 00:19:03,850
type system to handle these

00:18:59,710 --> 00:19:05,770
implementation details so we can easily

00:19:03,850 --> 00:19:07,270
create an asynchronous version of the

00:19:05,770 --> 00:19:12,250
interpreter like we did before we just

00:19:07,270 --> 00:19:14,200
add future here and we wrap up that a we

00:19:12,250 --> 00:19:20,289
can do the pretty print expressions in

00:19:14,200 --> 00:19:22,840
the same way and we can inspect and

00:19:20,289 --> 00:19:24,309
rewrite expressions the interpreter pre

00:19:22,840 --> 00:19:26,710
computes the results of less than an

00:19:24,309 --> 00:19:28,419
expression produces a program containing

00:19:26,710 --> 00:19:30,870
only boolean literals and logical

00:19:28,419 --> 00:19:30,870
operators

00:19:35,530 --> 00:19:41,690
so the deeper that we embed our DSL in

00:19:40,220 --> 00:19:44,900
the host language the simple the

00:19:41,690 --> 00:19:45,980
interpreter is because if you look at

00:19:44,900 --> 00:19:49,940
the opposite way

00:19:45,980 --> 00:19:51,740
the farther that we move our remove it

00:19:49,940 --> 00:19:53,780
from the host language than the more

00:19:51,740 --> 00:19:56,030
semantics that we have to provide in the

00:19:53,780 --> 00:19:59,510
interpreter ourselves so if you want it

00:19:56,030 --> 00:20:01,040
to be simpler and your semantics align

00:19:59,510 --> 00:20:03,050
with Scala then there's no reason not to

00:20:01,040 --> 00:20:06,350
have it be closer to the SKA make it

00:20:03,050 --> 00:20:12,320
more deeply embedded okay

00:20:06,350 --> 00:20:18,800
so ordering we had an implicit ordering

00:20:12,320 --> 00:20:21,830
in our original design so when we did it

00:20:18,800 --> 00:20:24,770
before we because of the host language

00:20:21,830 --> 00:20:26,870
we interpreted our less than and we

00:20:24,770 --> 00:20:30,950
evaluated from the left-hand side before

00:20:26,870 --> 00:20:37,480
the right it was trivial in the in this

00:20:30,950 --> 00:20:40,850
particular demo DSL but in more complex

00:20:37,480 --> 00:20:42,620
problem domains then you probably want

00:20:40,850 --> 00:20:46,070
to give someone the ability to have

00:20:42,620 --> 00:20:47,750
explicit ordering so I sure you can

00:20:46,070 --> 00:20:53,900
imagine somewhere where having explicit

00:20:47,750 --> 00:20:57,380
ordering would be important oh I gave

00:20:53,900 --> 00:21:01,220
away that this so imagine that you

00:20:57,380 --> 00:21:03,110
didn't see that okay so how would we in

00:21:01,220 --> 00:21:08,450
a functional programming language model

00:21:03,110 --> 00:21:13,250
explicit ordering okay that's alright

00:21:08,450 --> 00:21:18,890
monads we got it that's good so let's

00:21:13,250 --> 00:21:23,600
make our DSL monadic so here's the type

00:21:18,890 --> 00:21:25,610
DSL from before and we're going to add

00:21:23,600 --> 00:21:28,460
another one in here to be able to

00:21:25,610 --> 00:21:31,520
sequence it using monads we're going to

00:21:28,460 --> 00:21:32,810
create a flat map so it's it's maybe not

00:21:31,520 --> 00:21:39,670
gonna be a perfect monad but it's gonna

00:21:32,810 --> 00:21:39,670
work for us so yeah

00:21:42,490 --> 00:21:47,830
so you can create this this flat map to

00:21:45,440 --> 00:21:50,150
have arbitrarily long sequences because

00:21:47,830 --> 00:21:55,760
that's how you would sequence them all

00:21:50,150 --> 00:21:59,300
together you seen that monad okay so we

00:21:55,760 --> 00:22:01,640
no longer need arguments less than and

00:21:59,300 --> 00:22:03,020
to be instances of expressions because

00:22:01,640 --> 00:22:10,940
we're using the flat map to do this

00:22:03,020 --> 00:22:17,900
sequence ooh yeah let me show you this

00:22:10,940 --> 00:22:21,770
so if you look at this literal it looks

00:22:17,900 --> 00:22:23,870
very much like the pure or the point the

00:22:21,770 --> 00:22:25,160
pure from cats or the point from Scala

00:22:23,870 --> 00:22:28,040
Zed's so we'll just go ahead and rename

00:22:25,160 --> 00:22:30,590
it so it looks like that it's exactly

00:22:28,040 --> 00:22:34,490
equivalent the same idea putting things

00:22:30,590 --> 00:22:36,050
in context so you have that arbitrary

00:22:34,490 --> 00:22:44,630
value a and then you end up with this

00:22:36,050 --> 00:22:47,090
expression of a okay so because we've

00:22:44,630 --> 00:22:49,550
changed the DSL to use this flat map we

00:22:47,090 --> 00:22:51,620
can't directly nest the sub-expressions

00:22:49,550 --> 00:22:57,560
anymore we're using flat map to do the

00:22:51,620 --> 00:23:00,610
sequencing so what would it look like it

00:22:57,560 --> 00:23:00,610
would look great like that

00:23:00,969 --> 00:23:09,080
alright ok so we get all this sequencing

00:23:06,590 --> 00:23:11,239
and this sequencing is something that

00:23:09,080 --> 00:23:12,769
the user defines with their program they

00:23:11,239 --> 00:23:14,509
put all the flat maps in they figure out

00:23:12,769 --> 00:23:17,109
how they want it all to work and it

00:23:14,509 --> 00:23:21,320
unwinds exactly the way they designate

00:23:17,109 --> 00:23:23,179
and it looks great so if we add a few

00:23:21,320 --> 00:23:24,769
methods then we can use a for

00:23:23,179 --> 00:23:28,219
comprehension and then it looks like

00:23:24,769 --> 00:23:30,950
what you probably want alright it's got

00:23:28,219 --> 00:23:32,049
to be this relief there right see it

00:23:30,950 --> 00:23:35,239
like that

00:23:32,049 --> 00:23:36,529
okay so we have pride we have precise

00:23:35,239 --> 00:23:38,659
control over the ordering of the

00:23:36,529 --> 00:23:40,639
statements and we can shuffle them

00:23:38,659 --> 00:23:42,349
arbitrarily with the sequence as long as

00:23:40,639 --> 00:23:43,309
we never use the value of the variable

00:23:42,349 --> 00:23:47,769
before we introduce it

00:23:43,309 --> 00:23:58,159
so just same as any for comprehension

00:23:47,769 --> 00:24:02,330
okay so the flat map does what we expect

00:23:58,159 --> 00:24:06,049
it interprets the the first step of a

00:24:02,330 --> 00:24:09,379
and then it passes a result to the

00:24:06,049 --> 00:24:11,450
function which we've named FN here to

00:24:09,379 --> 00:24:12,859
calculate the second step and then it

00:24:11,450 --> 00:24:22,549
interprets the second step and returns

00:24:12,859 --> 00:24:24,950
the result great it's trivial still to

00:24:22,549 --> 00:24:28,869
write implementations to handle

00:24:24,950 --> 00:24:30,919
different effects we can no longer

00:24:28,869 --> 00:24:33,019
execute branches in parallel because

00:24:30,919 --> 00:24:36,589
we've only encoded sequencing using flat

00:24:33,019 --> 00:24:39,619
map but you know you can as an exercise

00:24:36,589 --> 00:24:43,089
you can do it using a parallel step as

00:24:39,619 --> 00:24:47,749
an implicit a functor or the equivalent

00:24:43,089 --> 00:24:49,399
okay one big negative consequence to

00:24:47,749 --> 00:24:52,820
flat map is that we lose the ability to

00:24:49,399 --> 00:24:58,999
form certain types of inspections so

00:24:52,820 --> 00:25:01,039
before yeah so before we could we could

00:24:58,999 --> 00:25:04,909
look at different things because we had

00:25:01,039 --> 00:25:06,739
these we can inspect the code and now

00:25:04,909 --> 00:25:08,389
the all the sequencing is happening on

00:25:06,739 --> 00:25:10,970
flat map we don't really know what's

00:25:08,389 --> 00:25:12,650
happening as much it's no longer

00:25:10,970 --> 00:25:15,290
possible to pretty print our code

00:25:12,650 --> 00:25:21,980
we don't have the same ability to know

00:25:15,290 --> 00:25:24,400
what to print okay and the same problem

00:25:21,980 --> 00:25:26,630
occurs with compilers like simplify

00:25:24,400 --> 00:25:29,000
they're difficult to implement because

00:25:26,630 --> 00:25:30,590
everything is now like this is sequenced

00:25:29,000 --> 00:25:36,650
with flatmap instead of being able to

00:25:30,590 --> 00:25:39,200
see what's behind it so the big take

00:25:36,650 --> 00:25:40,340
home here is that introducing a monadic

00:25:39,200 --> 00:25:42,470
step has two effects

00:25:40,340 --> 00:25:45,260
it makes our DSL much more general and

00:25:42,470 --> 00:25:48,980
powerful and a lot of ways more useful

00:25:45,260 --> 00:25:51,800
but it with that increased generality

00:25:48,980 --> 00:25:54,380
we've restricted or reduce our ability

00:25:51,800 --> 00:25:57,470
to inspect what's going on and so we

00:25:54,380 --> 00:25:59,360
lose some ability to do things like we

00:25:57,470 --> 00:26:01,429
showed you can't do the pretty print

00:25:59,360 --> 00:26:03,020
printing print pretty printing anymore

00:26:01,429 --> 00:26:04,910
and you can't do the compiler anymore

00:26:03,020 --> 00:26:07,670
and those kinds of things because you

00:26:04,910 --> 00:26:11,320
just don't have the inspect ability to

00:26:07,670 --> 00:26:15,080
be able to see what to put okay so

00:26:11,320 --> 00:26:17,300
here's the question do we have to

00:26:15,080 --> 00:26:20,330
implement flatmap ourselves I mean would

00:26:17,300 --> 00:26:21,800
we write that ourselves and you run your

00:26:20,330 --> 00:26:25,700
application you just go ahead and write

00:26:21,800 --> 00:26:33,710
flatmap anybody I mean you could we just

00:26:25,700 --> 00:26:35,840
did it but the answer is no we can use

00:26:33,710 --> 00:26:39,890
free monad because why not that's what

00:26:35,840 --> 00:26:42,320
it's for the idea of free is that per

00:26:39,890 --> 00:26:45,200
provides an abstract flat map and pure

00:26:42,320 --> 00:26:46,670
constructs so we don't have to create

00:26:45,200 --> 00:26:48,620
our own flat map we don't have to create

00:26:46,670 --> 00:26:51,110
our own pure we don't have to make sure

00:26:48,620 --> 00:26:53,360
that they follow the laws the same way

00:26:51,110 --> 00:26:55,340
it's already provided for as long as we

00:26:53,360 --> 00:26:58,160
implement them properly then we can just

00:26:55,340 --> 00:27:03,470
inject our own steps into the constructs

00:26:58,160 --> 00:27:06,410
and we're good okay so let's rewrite the

00:27:03,470 --> 00:27:12,170
code using free monad so we've got this

00:27:06,410 --> 00:27:13,820
expression it looks you know largely the

00:27:12,170 --> 00:27:15,620
same let's see we'll start by separating

00:27:13,820 --> 00:27:17,570
our DSL into two the individual steps

00:27:15,620 --> 00:27:20,660
and the pure and flatmap

00:27:17,570 --> 00:27:22,010
that'll become part of the monad by

00:27:20,660 --> 00:27:24,730
separating it out it makes it a little

00:27:22,010 --> 00:27:31,010
bit easier to see I think

00:27:24,730 --> 00:27:34,610
okay we'll do we'll rename the steps

00:27:31,010 --> 00:27:35,690
expression algebra since it's an algebra

00:27:34,610 --> 00:27:40,520
that's kind of like the common

00:27:35,690 --> 00:27:43,880
terminology for this and we'll rename

00:27:40,520 --> 00:27:45,440
the monadic part to expression monad so

00:27:43,880 --> 00:27:49,030
that we can also designate this is the

00:27:45,440 --> 00:27:51,200
monadic part okay

00:27:49,030 --> 00:27:52,730
so you would need a new type of

00:27:51,200 --> 00:27:54,890
expression monad to wrap up the

00:27:52,730 --> 00:27:57,920
expression algebra and cats this is

00:27:54,890 --> 00:28:04,160
called suspend so we'll introduce this

00:27:57,920 --> 00:28:05,990
as well so we have this suspend that has

00:28:04,160 --> 00:28:16,130
the value we're saying here extends

00:28:05,990 --> 00:28:17,990
expression okay it's okay this is

00:28:16,130 --> 00:28:19,730
hard-coded to the expression algebra but

00:28:17,990 --> 00:28:22,550
you know we can generalize it to any

00:28:19,730 --> 00:28:23,710
algebra within with any sets of steps in

00:28:22,550 --> 00:28:27,010
it if you want

00:28:23,710 --> 00:28:27,010
so oops

00:28:28,330 --> 00:28:35,300
okay we'll introduce a second type

00:28:32,330 --> 00:28:37,130
parameter F that's a single type

00:28:35,300 --> 00:28:39,860
argument like expression house where

00:28:37,130 --> 00:28:45,410
does this been now wraps up the this F

00:28:39,860 --> 00:28:48,260
as an instance of the algebra so that

00:28:45,410 --> 00:28:50,000
works the same way as it did before we

00:28:48,260 --> 00:28:51,650
can combine this with expression algebra

00:28:50,000 --> 00:28:57,429
and end up with the DSL that represents

00:28:51,650 --> 00:29:00,260
a program like this okay

00:28:57,429 --> 00:29:01,910
this is almost the same as the MANET

00:29:00,260 --> 00:29:03,830
monadic expression that we had before

00:29:01,910 --> 00:29:06,500
except for the instances of left and an

00:29:03,830 --> 00:29:11,929
is wrapped in suspend so we still have

00:29:06,500 --> 00:29:16,040
this this nice flat map thing here and

00:29:11,929 --> 00:29:17,390
we had a bit more syntax and with for

00:29:16,040 --> 00:29:21,020
comprehension the structure the program

00:29:17,390 --> 00:29:25,300
becomes clear and the difference being

00:29:21,020 --> 00:29:25,300
that you could see the pure bits there

00:29:28,039 --> 00:29:31,980
this is how you would import it

00:29:30,659 --> 00:29:33,840
typically we'd find our algebra as

00:29:31,980 --> 00:29:35,400
before and port free from our favorite

00:29:33,840 --> 00:29:37,770
functional programming library and

00:29:35,400 --> 00:29:40,980
create a type alias that specifies free

00:29:37,770 --> 00:29:44,270
to our algebra so you get the free and

00:29:40,980 --> 00:29:52,049
then you specify how you're using it

00:29:44,270 --> 00:29:54,059
okay so smart constructors so we could

00:29:52,049 --> 00:29:55,500
we then write a set of helper methods

00:29:54,059 --> 00:29:57,270
called smart constructors that produce

00:29:55,500 --> 00:29:59,970
an instance of any given term in our

00:29:57,270 --> 00:30:03,330
algebra pre-wrapped and necess bund so

00:29:59,970 --> 00:30:06,500
the smart constructors just give you the

00:30:03,330 --> 00:30:09,150
ability to have a little more control

00:30:06,500 --> 00:30:11,760
with these helpers and programs looks a

00:30:09,150 --> 00:30:13,350
little simpler but what about the

00:30:11,760 --> 00:30:16,409
interpreter the interpreter split into

00:30:13,350 --> 00:30:18,090
two sets of codes a code excuse me the

00:30:16,409 --> 00:30:19,470
code to interpret the purusa span and

00:30:18,090 --> 00:30:23,309
flatmap and the code you interpret the

00:30:19,470 --> 00:30:28,500
instances of the algebra first it needs

00:30:23,309 --> 00:30:33,299
to provide it for free okay here's how

00:30:28,500 --> 00:30:35,429
we do it so the technical name for this

00:30:33,299 --> 00:30:36,780
is the natural transformation which is a

00:30:35,429 --> 00:30:41,309
little bit beyond what we're covering

00:30:36,780 --> 00:30:43,409
right now we can go after if you'd like

00:30:41,309 --> 00:30:45,750
the important part is that the apply

00:30:43,409 --> 00:30:47,429
method in the middle which transports an

00:30:45,750 --> 00:30:49,289
instance of the expression algebra into

00:30:47,429 --> 00:30:59,370
an instance of some other monad in this

00:30:49,289 --> 00:31:00,690
case we're showing it with future so

00:30:59,370 --> 00:31:02,070
once we've defined our natural

00:31:00,690 --> 00:31:04,559
transformation we can pass it on to a

00:31:02,070 --> 00:31:06,510
method called fold map on free that

00:31:04,559 --> 00:31:09,000
handles the interpretation of pure

00:31:06,510 --> 00:31:12,270
suspend and flat map and if you've used

00:31:09,000 --> 00:31:18,140
you know as this anyone used fold map

00:31:12,270 --> 00:31:18,140
before yes okay

00:31:20,310 --> 00:31:23,800
so if you want to interpret a plane

00:31:22,240 --> 00:31:25,420
value rather than a value wrapped in a

00:31:23,800 --> 00:31:28,180
monad we can use this thing called

00:31:25,420 --> 00:31:29,800
identity and the identity monad or it

00:31:28,180 --> 00:31:32,970
takes plane values and makes them look

00:31:29,800 --> 00:31:35,110
like monads so that's what you would do

00:31:32,970 --> 00:31:36,700
if you don't know how this works don't

00:31:35,110 --> 00:31:40,180
worry about it and you can we can talk

00:31:36,700 --> 00:31:42,190
after key take-home point about free is

00:31:40,180 --> 00:31:44,020
that it factors out the sequencing

00:31:42,190 --> 00:31:46,090
aspects of our programs allows us to

00:31:44,020 --> 00:31:49,690
plug in implementations of the

00:31:46,090 --> 00:31:51,430
individual steps it's kind of what you

00:31:49,690 --> 00:31:53,410
were wanting to do before and now

00:31:51,430 --> 00:31:55,840
instead of implementing your own flat

00:31:53,410 --> 00:32:06,210
map and stuff you get it for free with

00:31:55,840 --> 00:32:06,210
implementing the free monad ok let's see

00:32:14,000 --> 00:32:17,419
five times

00:32:17,720 --> 00:32:24,179
okay so I'm just there's the one

00:32:21,720 --> 00:32:26,909
drawback from using one of the drawbacks

00:32:24,179 --> 00:32:28,649
of using free monad is all the extra

00:32:26,909 --> 00:32:31,260
boilerplate so we went through some

00:32:28,649 --> 00:32:32,610
extra steps when or we went through a

00:32:31,260 --> 00:32:34,289
lot of steps anyway when we were

00:32:32,610 --> 00:32:36,990
implementing free monad with the natural

00:32:34,289 --> 00:32:38,610
transformation bit in particular there

00:32:36,990 --> 00:32:40,350
are some libraries that get rid of the

00:32:38,610 --> 00:32:42,059
boilerplate a little bit you implement

00:32:40,350 --> 00:32:45,990
the library and some of the boilerplate

00:32:42,059 --> 00:32:47,730
is given to you for free and and you can

00:32:45,990 --> 00:32:51,090
use that free style is one example I

00:32:47,730 --> 00:32:58,590
think there's another freak but there

00:32:51,090 --> 00:33:00,240
are other options so that's all I want

00:32:58,590 --> 00:33:01,590
to look at for the Raya Phi encodings

00:33:00,240 --> 00:33:04,049
because we got all the way to flat out

00:33:01,590 --> 00:33:07,190
to free monads so we're good so now

00:33:04,049 --> 00:33:10,190
let's talk about church and coatings so

00:33:07,190 --> 00:33:15,710
with Church and coatings we represent

00:33:10,190 --> 00:33:19,470
expressions excuse me with with ratified

00:33:15,710 --> 00:33:21,510
with reification we represented programs

00:33:19,470 --> 00:33:23,880
this data with church and coatings we

00:33:21,510 --> 00:33:30,720
represent programs as a sequence of

00:33:23,880 --> 00:33:32,610
abstract method calls so it's strictly

00:33:30,720 --> 00:33:35,700
equivalent it's just the way that we

00:33:32,610 --> 00:33:37,409
implement it is different so and we can

00:33:35,700 --> 00:33:38,970
even convert back and forth between them

00:33:37,409 --> 00:33:44,750
so you may have situations where you

00:33:38,970 --> 00:33:46,919
want to do that and it works fine okay

00:33:44,750 --> 00:33:48,120
we're gonna look at some examples of

00:33:46,919 --> 00:33:49,860
Church encoding we'll start with a

00:33:48,120 --> 00:33:53,700
simple example it shows a correlation

00:33:49,860 --> 00:33:57,539
with reification and then we'll and end

00:33:53,700 --> 00:34:01,399
up with tagless final at the end so you

00:33:57,539 --> 00:34:01,399
can see that okay

00:34:02,140 --> 00:34:06,280
okay with Church encoding any sometime

00:34:04,750 --> 00:34:11,139
can be converted to an object with a

00:34:06,280 --> 00:34:13,480
method for its some type it was compared

00:34:11,139 --> 00:34:16,470
the two versions the DSL that we four

00:34:13,480 --> 00:34:20,080
equivalents so we had here's data and

00:34:16,470 --> 00:34:25,300
here is a church encoded version where

00:34:20,080 --> 00:34:26,980
we have methods so data methods our

00:34:25,300 --> 00:34:28,600
sealed trait becomes an object we've

00:34:26,980 --> 00:34:31,119
renamed object slightly to avoid

00:34:28,600 --> 00:34:33,879
confusion each case class becomes a

00:34:31,119 --> 00:34:36,730
method and each field becomes a

00:34:33,879 --> 00:34:40,240
parameter so it's just method so it's

00:34:36,730 --> 00:34:42,550
also a little bit more comfortable

00:34:40,240 --> 00:34:44,649
probably for some if you've come from an

00:34:42,550 --> 00:34:46,780
imperative programming language and you

00:34:44,649 --> 00:34:52,510
probably are more comfortable seeing the

00:34:46,780 --> 00:34:54,399
methods instead of the data okay we

00:34:52,510 --> 00:34:56,770
build the program by taking instance or

00:34:54,399 --> 00:34:58,420
DSL as a parameter and running various

00:34:56,770 --> 00:35:04,900
methods from the DSL and program

00:34:58,420 --> 00:35:06,850
specific order so similar we've taken

00:35:04,900 --> 00:35:09,190
the DSL and then we do import it and we

00:35:06,850 --> 00:35:12,820
pulled in all the details and that's how

00:35:09,190 --> 00:35:15,070
we sequence the stuff together we give

00:35:12,820 --> 00:35:18,210
the steps meaning by creating a concrete

00:35:15,070 --> 00:35:18,210
instance of the DSL

00:35:22,440 --> 00:35:28,319
so I'm mapping it to the simplest

00:35:25,079 --> 00:35:30,030
expression you could with Scala so the

00:35:28,319 --> 00:35:33,630
result is like it's just a regular Scala

00:35:30,030 --> 00:35:37,140
expression and then we just run the

00:35:33,630 --> 00:35:38,760
program by calling it it's method so we

00:35:37,140 --> 00:35:40,260
we have that interpreter and we had the

00:35:38,760 --> 00:35:47,869
program we pass it and we call it and

00:35:40,260 --> 00:35:49,980
you get the result okay we can't

00:35:47,869 --> 00:35:51,569
implement can't really implement many

00:35:49,980 --> 00:35:53,520
different versions of the interpreter

00:35:51,569 --> 00:35:55,589
hear the message signature is too

00:35:53,520 --> 00:35:59,430
specific we also can't abstract over the

00:35:55,589 --> 00:36:03,660
effects to do this we need to introduce

00:35:59,430 --> 00:36:05,990
another level of indirection so you

00:36:03,660 --> 00:36:09,559
probably can imagine how that would look

00:36:05,990 --> 00:36:10,910
and that brings us to the tagless final

00:36:09,559 --> 00:36:14,549
okay

00:36:10,910 --> 00:36:15,829
or is it finally tagless it's you'll

00:36:14,549 --> 00:36:19,410
hear it a lot of different ways

00:36:15,829 --> 00:36:21,240
regardless it's the same as what we had

00:36:19,410 --> 00:36:24,270
before so tagless final is church

00:36:21,240 --> 00:36:26,520
encoding with an additional type grammar

00:36:24,270 --> 00:36:32,190
that allows us to abstract over effects

00:36:26,520 --> 00:36:35,250
that's all that it is and if you look at

00:36:32,190 --> 00:36:39,119
our existing DSL as comparison it looks

00:36:35,250 --> 00:36:40,950
like that and then we just add the type

00:36:39,119 --> 00:36:47,069
parameter so that we can abstract over

00:36:40,950 --> 00:36:49,230
the effects so you know this F we

00:36:47,069 --> 00:36:51,150
combined the F to different concrete

00:36:49,230 --> 00:36:54,319
types for different different

00:36:51,150 --> 00:36:54,319
interpreters to get different results

00:36:54,470 --> 00:36:58,920
here's an interpreter that binds F to

00:36:57,029 --> 00:37:04,079
future creating a synchronous version of

00:36:58,920 --> 00:37:08,039
our DSL so we've just in the interpreter

00:37:04,079 --> 00:37:13,980
we have found that a type parameter F to

00:37:08,039 --> 00:37:16,680
a future to a particular future and then

00:37:13,980 --> 00:37:19,170
we can have it work the same way we just

00:37:16,680 --> 00:37:21,299
instead of returning the direct results

00:37:19,170 --> 00:37:23,099
like a minus B we now have future

00:37:21,299 --> 00:37:24,960
successful T minus B and that

00:37:23,099 --> 00:37:26,640
interpreter is the synchronous

00:37:24,960 --> 00:37:27,660
interpreter and as we saw before you

00:37:26,640 --> 00:37:29,309
could have numerous different

00:37:27,660 --> 00:37:32,390
interpreters this would just be one of

00:37:29,309 --> 00:37:35,130
them this is one that uses future okay

00:37:32,390 --> 00:37:36,500
so here's one that doesn't use feature

00:37:35,130 --> 00:37:40,700
so we

00:37:36,500 --> 00:37:45,090
take this interpreter and bind it to ID

00:37:40,700 --> 00:37:47,940
so now we have a synchronous DSL so I

00:37:45,090 --> 00:37:50,010
think of this in terms of you know maybe

00:37:47,940 --> 00:37:52,590
maybe you have an interpreter that you

00:37:50,010 --> 00:37:55,230
run in production with future and maybe

00:37:52,590 --> 00:37:58,280
you have an interpreter that you use for

00:37:55,230 --> 00:38:00,359
testing that you don't want the

00:37:58,280 --> 00:38:03,150
asynchronous behavior so you only want

00:38:00,359 --> 00:38:05,280
to test what you're doing instead of you

00:38:03,150 --> 00:38:06,900
know what you're doing with the

00:38:05,280 --> 00:38:08,940
concurrency bit in there that added

00:38:06,900 --> 00:38:10,230
complication but I'm sure you can

00:38:08,940 --> 00:38:11,490
imagine like a bunch of different things

00:38:10,230 --> 00:38:13,740
like maybe you want to test out

00:38:11,490 --> 00:38:16,470
different effects and see how they react

00:38:13,740 --> 00:38:18,300
in your particular environment and you

00:38:16,470 --> 00:38:19,650
can totally do this because you just

00:38:18,300 --> 00:38:22,200
implement different interpreters with

00:38:19,650 --> 00:38:25,440
different effects you just bind them to

00:38:22,200 --> 00:38:26,910
the different effects so when we create

00:38:25,440 --> 00:38:30,810
a program we still pass an interpreter

00:38:26,910 --> 00:38:32,760
as a parameter as we did before but we

00:38:30,810 --> 00:38:34,680
also have to pass the constraints to

00:38:32,760 --> 00:38:37,170
give us more functionality in F here

00:38:34,680 --> 00:38:39,900
we're passing a monad F which allows us

00:38:37,170 --> 00:38:42,000
to map and flatmap in our program as

00:38:39,900 --> 00:38:43,260
well as call the methods of the DSL so

00:38:42,000 --> 00:38:46,710
we want to be able to do four

00:38:43,260 --> 00:38:49,109
comprehensions so that we can have nice

00:38:46,710 --> 00:38:52,790
code that looks like this so we need the

00:38:49,109 --> 00:38:55,859
monad so we grab the implicit monad and

00:38:52,790 --> 00:38:57,570
we still pulled in our DSL and still

00:38:55,859 --> 00:39:04,080
pull in all the details of you DSL and

00:38:57,570 --> 00:39:05,849
it all just works okay all right so we

00:39:04,080 --> 00:39:07,410
can call our program we bind F to a

00:39:05,849 --> 00:39:09,359
particular type as long as there's an

00:39:07,410 --> 00:39:11,190
interpreter and a Mon and an instance

00:39:09,359 --> 00:39:13,109
for that type our program will run and

00:39:11,190 --> 00:39:17,880
we get a result and you can see the

00:39:13,109 --> 00:39:19,170
proof there of that comment all right

00:39:17,880 --> 00:39:19,920
passing a different interpreter gives us

00:39:19,170 --> 00:39:21,359
the same result

00:39:19,920 --> 00:39:23,250
wrapped in a different effect as we

00:39:21,359 --> 00:39:25,260
expected before so we had two different

00:39:23,250 --> 00:39:27,030
interpreters we ran them we get

00:39:25,260 --> 00:39:28,440
different results because we had

00:39:27,030 --> 00:39:34,250
different interpreters because we bound

00:39:28,440 --> 00:39:34,250
two different effects okay

00:39:35,510 --> 00:39:43,380
so if you look at the hassle that we had

00:39:40,350 --> 00:39:47,160
of combining DSL with free and I I did

00:39:43,380 --> 00:39:48,420
kind of gloss over it a little bit you

00:39:47,160 --> 00:39:51,660
know it's interesting to note that

00:39:48,420 --> 00:39:52,710
combining the dsl x' in tagless final is

00:39:51,660 --> 00:39:57,240
trivial

00:39:52,710 --> 00:40:00,720
i mean less boilerplate it's a lot

00:39:57,240 --> 00:40:03,480
easier okay we simply pass - we can we

00:40:00,720 --> 00:40:07,170
can combine - dsls together so we can

00:40:03,480 --> 00:40:09,630
like we can just pass to DSL to a

00:40:07,170 --> 00:40:12,480
programmer instead of one we restrict on

00:40:09,630 --> 00:40:14,670
with the same type F and we get the same

00:40:12,480 --> 00:40:21,210
sharing a flat map and map as we as free

00:40:14,670 --> 00:40:24,210
gave us okay so like free our programs

00:40:21,210 --> 00:40:28,440
are somewhat opaque and difficult to

00:40:24,210 --> 00:40:30,570
inspect but if you're going to be using

00:40:28,440 --> 00:40:32,550
this then you probably don't need that

00:40:30,570 --> 00:40:34,920
kind of type inspection so you're going

00:40:32,550 --> 00:40:37,050
to be using this in a place where that

00:40:34,920 --> 00:40:39,510
difficulty of inspection isn't necessary

00:40:37,050 --> 00:40:43,080
like you want this ability to have this

00:40:39,510 --> 00:40:46,500
abstraction and it's worth it

00:40:43,080 --> 00:40:49,410
I think tag was final it produces a

00:40:46,500 --> 00:40:51,500
really elegant encoding for combining T

00:40:49,410 --> 00:41:00,630
s l's and abstracting over effects and

00:40:51,500 --> 00:41:03,270
does it with less boilerplate so that's

00:41:00,630 --> 00:41:04,860
really all there is to tagless final so

00:41:03,270 --> 00:41:07,620
let's just kind of recap what we talked

00:41:04,860 --> 00:41:09,540
about and tag was final is kind of like

00:41:07,620 --> 00:41:13,320
the ultimate for the church encodings

00:41:09,540 --> 00:41:14,820
for asan concern so we've been

00:41:13,320 --> 00:41:18,510
discussing various ways of implementing

00:41:14,820 --> 00:41:21,240
the interpreter pattern in Scala so this

00:41:18,510 --> 00:41:23,250
interpreter pattern is really just you

00:41:21,240 --> 00:41:26,820
know we created a program which is sort

00:41:23,250 --> 00:41:28,710
of confined and smaller domain and you

00:41:26,820 --> 00:41:30,660
know it's domain-specific it's a little

00:41:28,710 --> 00:41:31,770
bit more confined we created an

00:41:30,660 --> 00:41:35,070
interpreter to have all the

00:41:31,770 --> 00:41:39,030
implementation details and semantics and

00:41:35,070 --> 00:41:42,600
then we get a particular result that's

00:41:39,030 --> 00:41:46,080
all the interpreter pattern is okay and

00:41:42,600 --> 00:41:47,790
then we saw that this is this is good

00:41:46,080 --> 00:41:49,620
because you can have multiple probe

00:41:47,790 --> 00:41:52,110
in a single interpreter and get

00:41:49,620 --> 00:41:53,490
different results and you can go the

00:41:52,110 --> 00:41:56,220
other way as well you can have like one

00:41:53,490 --> 00:41:59,840
program and multiple interpreters and

00:41:56,220 --> 00:42:02,730
also get different results and of course

00:41:59,840 --> 00:42:04,500
you know I'm sure you have situations

00:42:02,730 --> 00:42:06,240
where you would have multiple programs

00:42:04,500 --> 00:42:09,410
and multiple interpreters and get all

00:42:06,240 --> 00:42:13,140
kinds of different results so

00:42:09,410 --> 00:42:17,310
reification lis is modeling the core as

00:42:13,140 --> 00:42:22,590
data and church encoding is modeling the

00:42:17,310 --> 00:42:24,780
as code as methods and you know

00:42:22,590 --> 00:42:33,750
reification leads to free and church

00:42:24,780 --> 00:42:35,880
encoding leads to tagless final okay and

00:42:33,750 --> 00:42:39,180
we also talked about the standalone

00:42:35,880 --> 00:42:42,330
versus being embedded and if you have a

00:42:39,180 --> 00:42:44,310
standalone you writing it's completely

00:42:42,330 --> 00:42:47,970
custom you have like some reason that

00:42:44,310 --> 00:42:49,770
you're deviating from the scala so so

00:42:47,970 --> 00:42:53,030
that it makes sense to pay the penalty

00:42:49,770 --> 00:42:56,610
of writing all your own semantics or

00:42:53,030 --> 00:42:58,350
embedded you just reuse some of the the

00:42:56,610 --> 00:43:01,310
host language features and then you

00:42:58,350 --> 00:43:04,890
don't have to implement those yourself

00:43:01,310 --> 00:43:06,360
and here's some links and there's

00:43:04,890 --> 00:43:10,350
there's other links that I can provide

00:43:06,360 --> 00:43:12,840
later and you know if you there's also

00:43:10,350 --> 00:43:15,540
slides and code samples that'll be

00:43:12,840 --> 00:43:17,310
available online and you can you can get

00:43:15,540 --> 00:43:20,700
them there now I could take questions

00:43:17,310 --> 00:43:23,610
there's a microphone somewhere nope okay

00:43:20,700 --> 00:43:25,650
I think we're out of time for questions

00:43:23,610 --> 00:43:28,380
so if you have questions find me after

00:43:25,650 --> 00:43:29,670
the talk and I'll do my best to get your

00:43:28,380 --> 00:43:35,140
answers

00:43:29,670 --> 00:43:35,140

YouTube URL: https://www.youtube.com/watch?v=HhNc9zKhLUQ


