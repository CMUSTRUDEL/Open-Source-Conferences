Title: Migrating to Scala 2.13 by Julien Richard Foy and  Stefan Zeiger
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/migrating-to-scala-2-13
Captions: 
	00:00:03,580 --> 00:00:10,090
well hello everyone I'm Stefan I work at

00:00:06,939 --> 00:00:14,289
at light band on the Scala compiler team

00:00:10,090 --> 00:00:16,750
and hello I'm Judy Sephora a word I work

00:00:14,289 --> 00:00:19,180
at scatter Center and thanks a lot for

00:00:16,750 --> 00:00:25,510
coming it's a last turk of the day you

00:00:19,180 --> 00:00:28,390
must be tired maybe so let's start with

00:00:25,510 --> 00:00:30,580
a quick look at Scala 213 you've

00:00:28,390 --> 00:00:33,190
probably seen the keynote so you you've

00:00:30,580 --> 00:00:35,760
learned a bit already and if you want to

00:00:33,190 --> 00:00:38,710
know more details about Scala 213

00:00:35,760 --> 00:00:42,850
Adrienne has a talk tomorrow at I think

00:00:38,710 --> 00:00:46,090
3:30 in this room so I just give you a

00:00:42,850 --> 00:00:48,309
quick overview the main topic for Scala

00:00:46,090 --> 00:00:50,680
to 13 on the roadmap is the new

00:00:48,309 --> 00:00:53,739
collections library it's the first time

00:00:50,680 --> 00:00:57,969
since Scala 2.8 that we're redesigning

00:00:53,739 --> 00:01:00,280
it so about 10 years now and we're also

00:00:57,969 --> 00:01:02,469
improving compiler performance beyond

00:01:00,280 --> 00:01:06,070
what we already did in the scholar 212

00:01:02,469 --> 00:01:08,170
series well we've done some more work on

00:01:06,070 --> 00:01:10,840
modularizing the standard library and

00:01:08,170 --> 00:01:13,990
we'll see a bit of the fallout later in

00:01:10,840 --> 00:01:16,359
this talk and finally we're improving

00:01:13,990 --> 00:01:18,310
user friendliness which means in

00:01:16,359 --> 00:01:21,639
particular improvements to the repple

00:01:18,310 --> 00:01:24,459
and error messages and documentation you

00:01:21,639 --> 00:01:26,590
can find a link here to the roadmap on

00:01:24,459 --> 00:01:29,079
our scholar death issues tracker if you

00:01:26,590 --> 00:01:31,600
want to see more details about this and

00:01:29,079 --> 00:01:35,499
as I said otherwise go see Adrienne's

00:01:31,600 --> 00:01:39,459
talk tomorrow so the current status is

00:01:35,499 --> 00:01:42,729
that we just released Scala 2:13 o m4

00:01:39,459 --> 00:01:45,399
almost exactly 1 months ago on the first

00:01:42,729 --> 00:01:47,979
day of Scala days Berlin we were aiming

00:01:45,399 --> 00:01:49,689
for that day to have a immersion with

00:01:47,979 --> 00:01:53,289
the new collections library out and we

00:01:49,689 --> 00:01:57,549
managed to do it and there will be one

00:01:53,289 --> 00:02:01,029
more milestone before the RC kicks off

00:01:57,549 --> 00:02:04,569
and that's milestone 5 scheduled to be

00:02:01,029 --> 00:02:07,209
released on August 10 this will contain

00:02:04,569 --> 00:02:10,810
some minor API changes that we're still

00:02:07,209 --> 00:02:13,900
doing to the collections and naturally

00:02:10,810 --> 00:02:16,160
more bug fixes we're also working on

00:02:13,900 --> 00:02:19,340
performance testing at the

00:02:16,160 --> 00:02:21,140
and we're trying to catch possible

00:02:19,340 --> 00:02:24,830
performance regressions and fix them in

00:02:21,140 --> 00:02:26,690
time for m5 and since we now have the

00:02:24,830 --> 00:02:30,350
chance to get feedback from people who

00:02:26,690 --> 00:02:32,450
are using the new collections in m4 we

00:02:30,350 --> 00:02:37,460
can do further improvements to

00:02:32,450 --> 00:02:39,730
compatibility and cross building so

00:02:37,460 --> 00:02:42,080
since you're here at this talk about

00:02:39,730 --> 00:02:44,660
migrating to Scala 2:13

00:02:42,080 --> 00:02:47,240
I assume you currently have a project

00:02:44,660 --> 00:02:50,450
that works on Scala 2:12 that's our

00:02:47,240 --> 00:02:53,780
starting point for this exercise and you

00:02:50,450 --> 00:02:56,240
want to target Scala 2:13 milestone 4 or

00:02:53,780 --> 00:03:00,020
higher so anything that has the new

00:02:56,240 --> 00:03:01,340
collections library and the examples

00:03:00,020 --> 00:03:05,380
that we're showing are going to be for

00:03:01,340 --> 00:03:05,380
SBT because that's what we use ourselves

00:03:05,830 --> 00:03:13,130
so before diving into the migration and

00:03:10,100 --> 00:03:15,620
just switching your build over to 2:13

00:03:13,130 --> 00:03:18,650
it's easier if you actually start on

00:03:15,620 --> 00:03:22,220
scala 212 and make a few preparations

00:03:18,650 --> 00:03:24,940
there so the first thing you want to do

00:03:22,220 --> 00:03:27,230
is remove calls to deprecated API so

00:03:24,940 --> 00:03:29,090
there's a lot of stuff in the Scala

00:03:27,230 --> 00:03:32,510
library that is deprecated a lot of

00:03:29,090 --> 00:03:35,690
types and methods and we removed many of

00:03:32,510 --> 00:03:37,670
them in Scala 213 in particular so that

00:03:35,690 --> 00:03:39,650
we wouldn't have to port already

00:03:37,670 --> 00:03:41,570
deprecated methods to the new design and

00:03:39,650 --> 00:03:43,459
the collections library so things like

00:03:41,570 --> 00:03:46,250
Java conversions which was already

00:03:43,459 --> 00:03:48,140
deprecated in 212 has been removed so if

00:03:46,250 --> 00:03:51,130
you're still using that you should

00:03:48,140 --> 00:03:53,959
change your calls accordingly you can

00:03:51,130 --> 00:03:57,860
see how to turn this on in the SBT built

00:03:53,959 --> 00:03:59,540
by passing the - deprecation flag to the

00:03:57,860 --> 00:04:01,489
compiler so you'll get the error

00:03:59,540 --> 00:04:04,580
messages to tell you how to get rid of

00:04:01,489 --> 00:04:06,470
the deprecated calls and once you have a

00:04:04,580 --> 00:04:08,300
clean build without deprecations it's

00:04:06,470 --> 00:04:13,580
going to be much easier to migrate to

00:04:08,300 --> 00:04:16,520
213 another thing that we removed is a

00:04:13,580 --> 00:04:19,549
bunch of compiler flags most people

00:04:16,520 --> 00:04:22,600
probably don't bother with them but some

00:04:19,549 --> 00:04:25,880
may have used these flags in their build

00:04:22,600 --> 00:04:28,580
those are all flags that changed the

00:04:25,880 --> 00:04:29,479
semantics of the source language that

00:04:28,580 --> 00:04:31,879
you can use

00:04:29,479 --> 00:04:35,059
and we want to get rid of those to avoid

00:04:31,879 --> 00:04:37,759
fragmentation there are experimental

00:04:35,059 --> 00:04:41,270
features or stuff that didn't really

00:04:37,759 --> 00:04:45,589
work well in practice and from now on

00:04:41,270 --> 00:04:49,939
the the goal is to rely on the X dash

00:04:45,589 --> 00:04:52,520
axis flag in order to set a source level

00:04:49,939 --> 00:04:55,789
so you can still tell the compiler in

00:04:52,520 --> 00:04:58,610
213 to parse the source as to 12 or as

00:04:55,789 --> 00:05:01,309
to 14 with some features that we

00:04:58,610 --> 00:05:04,819
anticipate 4 to 14 but we are going want

00:05:01,309 --> 00:05:07,159
to avoid further fragmentation I at the

00:05:04,819 --> 00:05:10,009
bottom here you can see the link to the

00:05:07,159 --> 00:05:11,779
pull request that removed these flags so

00:05:10,009 --> 00:05:13,639
if you've used any of them you can find

00:05:11,779 --> 00:05:17,029
more discussions about this in the end

00:05:13,639 --> 00:05:19,969
the actual pull request I'd like to

00:05:17,029 --> 00:05:21,919
point out one a flag in particular that

00:05:19,969 --> 00:05:25,460
we removed and that's the - y know

00:05:21,919 --> 00:05:28,939
adapted arts and some people like that

00:05:25,460 --> 00:05:31,819
because it prevents an accidental

00:05:28,939 --> 00:05:35,689
argument adaptation that Scala is doing

00:05:31,819 --> 00:05:38,779
so you may have opted to turn that off

00:05:35,689 --> 00:05:40,759
to make your code safer there will be a

00:05:38,779 --> 00:05:42,680
few changes to argument adaptation in

00:05:40,759 --> 00:05:45,529
particular to the handling of auto

00:05:42,680 --> 00:05:49,249
toppling coming in dotty or scholar 3

00:05:45,529 --> 00:05:52,389
and we try to get closer aligned with

00:05:49,249 --> 00:05:56,089
that in to 13 and going further into 14

00:05:52,389 --> 00:05:59,300
so the goal is to always allow the safe

00:05:56,089 --> 00:06:01,759
kinds of adaptation and always prohibit

00:05:59,300 --> 00:06:04,339
the unsafe one that can lead to

00:06:01,759 --> 00:06:07,069
accidental behavior so that you wouldn't

00:06:04,339 --> 00:06:09,139
have to choose between allowing

00:06:07,069 --> 00:06:13,550
everything or not allowing anything

00:06:09,139 --> 00:06:15,080
anymore and in Scala 214 we want to

00:06:13,550 --> 00:06:17,919
align this completely with the rules

00:06:15,080 --> 00:06:21,199
that Dottie has already implemented and

00:06:17,919 --> 00:06:24,999
you can already get a preview of that in

00:06:21,199 --> 00:06:28,399
213 if you set the source level 2 to 14

00:06:24,999 --> 00:06:31,310
then the automatic ADA expansion of 0

00:06:28,399 --> 00:06:33,409
arc methods will be disabled so if you

00:06:31,310 --> 00:06:35,300
used no adapt that arcs before that's

00:06:33,409 --> 00:06:38,709
one thing you will probably want to do

00:06:35,300 --> 00:06:42,319
so you get a bit of the safety pack and

00:06:38,709 --> 00:06:43,130
4 methods that are that have an argument

00:06:42,319 --> 00:06:45,680
list

00:06:43,130 --> 00:06:50,140
we're pushing for more aggressive ADA

00:06:45,680 --> 00:06:50,140
expansion like Donny already implemented

00:06:51,100 --> 00:06:59,450
okay the final change is regarding

00:06:54,980 --> 00:07:01,820
modules in 213 we removed the Scala

00:06:59,450 --> 00:07:08,120
library all modules anyone here actually

00:07:01,820 --> 00:07:09,710
using that I don't see any hands I this

00:07:08,120 --> 00:07:12,050
is the third time we're giving this talk

00:07:09,710 --> 00:07:14,960
so far nobody has raised a hand at this

00:07:12,050 --> 00:07:17,480
question so nobody should be affected by

00:07:14,960 --> 00:07:19,250
the removal of this module in case

00:07:17,480 --> 00:07:20,750
you're using it maybe you don't know

00:07:19,250 --> 00:07:22,790
about it you have to replace it with

00:07:20,750 --> 00:07:26,720
individual dependencies on the

00:07:22,790 --> 00:07:28,730
individual modules we're also we have

00:07:26,720 --> 00:07:30,980
also moved a parallel collections

00:07:28,730 --> 00:07:32,690
library into a separate repository so

00:07:30,980 --> 00:07:37,190
it's now published as a separate module

00:07:32,690 --> 00:07:41,180
and there are instructions linked in

00:07:37,190 --> 00:07:43,970
this issue here for cross building up to

00:07:41,180 --> 00:07:45,890
milestone 3 so this will not work at the

00:07:43,970 --> 00:07:47,570
moment for milestone for because the

00:07:45,890 --> 00:07:49,310
parallel collections have not yet been

00:07:47,570 --> 00:07:52,520
rewritten for the new collections

00:07:49,310 --> 00:07:54,650
library this is a work in progress and

00:07:52,520 --> 00:07:57,620
will have parallel collections working

00:07:54,650 --> 00:07:59,180
again on milestone 5 and by that time

00:07:57,620 --> 00:08:03,980
cross building should also be

00:07:59,180 --> 00:08:06,110
straightforward and finally Scala XML is

00:08:03,980 --> 00:08:10,220
no longer a transitive dependency of the

00:08:06,110 --> 00:08:12,230
Scala compiler module so if you relied

00:08:10,220 --> 00:08:15,200
on that you'll have to add an explicit

00:08:12,230 --> 00:08:16,730
dependency you probably don't really

00:08:15,200 --> 00:08:18,620
care about that and are not excited

00:08:16,730 --> 00:08:21,140
unless you're working on the Scala

00:08:18,620 --> 00:08:22,880
compiler itself in which case I find

00:08:21,140 --> 00:08:26,000
this very exciting because it means that

00:08:22,880 --> 00:08:27,470
Scala talk no longer needs Scala XML and

00:08:26,000 --> 00:08:35,349
it will make bootstrapping the Scala

00:08:27,470 --> 00:08:35,349
compiler a lot easier for us alright

00:08:36,810 --> 00:08:44,650
so now how can you build with 213

00:08:41,289 --> 00:08:46,930
well since milestone for has been

00:08:44,650 --> 00:08:50,530
published on snow type you can just add

00:08:46,930 --> 00:08:51,460
it to your build as you can as you do

00:08:50,530 --> 00:08:57,580
with the other

00:08:51,460 --> 00:09:00,520
scatter versions and then if you want to

00:08:57,580 --> 00:09:03,640
use different compiler options according

00:09:00,520 --> 00:09:05,260
to the scalar version of your build in

00:09:03,640 --> 00:09:07,780
case you are cross building for several

00:09:05,260 --> 00:09:12,760
scalar versions you can use this

00:09:07,780 --> 00:09:17,470
expression and here the important part

00:09:12,760 --> 00:09:21,690
is here where we check that the minor

00:09:17,470 --> 00:09:24,520
version of Scala is higher than 13 and

00:09:21,690 --> 00:09:27,040
here you can see how you can for

00:09:24,520 --> 00:09:30,370
instance adapt the compiler option to

00:09:27,040 --> 00:09:37,720
get a similar behavior between before

00:09:30,370 --> 00:09:41,730
2:13 and after 2:13 and then if you try

00:09:37,720 --> 00:09:49,570
to compile most likely you will get some

00:09:41,730 --> 00:09:52,950
either computation error or warnings in

00:09:49,570 --> 00:09:56,650
places where you use collections and

00:09:52,950 --> 00:10:02,730
otherwise you can maybe hit some corner

00:09:56,650 --> 00:10:06,100
cases where type inference is in

00:10:02,730 --> 00:10:10,750
intertwined with the usage of singleton

00:10:06,100 --> 00:10:12,940
types because some rules have changed in

00:10:10,750 --> 00:10:18,370
the compiler so maybe you will see some

00:10:12,940 --> 00:10:20,470
error message in that cases and maybe

00:10:18,370 --> 00:10:23,650
you will have some you will you will hit

00:10:20,470 --> 00:10:26,770
some other incompatibilities because the

00:10:23,650 --> 00:10:30,010
level of sauce language has changed so a

00:10:26,770 --> 00:10:35,740
short term solution to overcome this

00:10:30,010 --> 00:10:37,450
problem is to use the X source - 12 -

00:10:35,740 --> 00:10:40,390
temporarily

00:10:37,450 --> 00:10:48,640
use a level of sauce language that's

00:10:40,390 --> 00:10:51,310
compatible with 212 and in case you are

00:10:48,640 --> 00:10:56,200
using a project that cross build with

00:10:51,310 --> 00:10:59,710
several scale versions you might hit

00:10:56,200 --> 00:11:01,690
some problems because in the new

00:10:59,710 --> 00:11:05,470
Corrections the API is sometimes

00:11:01,690 --> 00:11:08,650
different from what it used to be in the

00:11:05,470 --> 00:11:10,180
old collections and we cannot change the

00:11:08,650 --> 00:11:14,110
old Corrections because they have to

00:11:10,180 --> 00:11:16,690
remain binary compatible so what we did

00:11:14,110 --> 00:11:18,670
is that we created a compatibility

00:11:16,690 --> 00:11:23,620
library named scatter correction compat

00:11:18,670 --> 00:11:27,970
and this compatibility library provides

00:11:23,620 --> 00:11:37,420
a unified syntax that works in to twelve

00:11:27,970 --> 00:11:40,390
to eleven or so and to thirteen you can

00:11:37,420 --> 00:11:42,400
use it like this just just add a

00:11:40,390 --> 00:11:46,660
dependency to the scalar correction

00:11:42,400 --> 00:11:50,670
compat module to your build and here I'm

00:11:46,660 --> 00:11:54,970
showing an example of difference of

00:11:50,670 --> 00:11:58,210
incompatibility between 212 and 213 so

00:11:54,970 --> 00:12:00,760
this is how in the old collection we

00:11:58,210 --> 00:12:04,060
used to convert a correction to new code

00:12:00,760 --> 00:12:06,490
to another type of Correction and in the

00:12:04,060 --> 00:12:09,940
new correction instead of type instead

00:12:06,490 --> 00:12:12,940
of passing type here like list we now

00:12:09,940 --> 00:12:14,250
pass a value the companion object of

00:12:12,940 --> 00:12:20,110
list

00:12:14,250 --> 00:12:24,340
so obviously this line the last line

00:12:20,110 --> 00:12:26,590
does not compile in to 12 but thanks to

00:12:24,340 --> 00:12:29,230
the compatibility library and thanks to

00:12:26,590 --> 00:12:35,920
this import that provides implicit

00:12:29,230 --> 00:12:41,070
definitions into twelve this code now

00:12:35,920 --> 00:12:43,590
can compile with 212 and to 11 or so and

00:12:41,070 --> 00:12:47,280
on to 13 the

00:12:43,590 --> 00:12:52,350
Scarah correction compat object package

00:12:47,280 --> 00:12:58,530
object is empty it's just here so that

00:12:52,350 --> 00:13:02,400
the import works so now what's new in

00:12:58,530 --> 00:13:05,280
the new Corrections well let's start

00:13:02,400 --> 00:13:07,620
with a quick overview of the design

00:13:05,280 --> 00:13:11,130
goals for the new collections so that

00:13:07,620 --> 00:13:13,650
you get an idea of what we actually want

00:13:11,130 --> 00:13:15,660
to do with it and what the good parts

00:13:13,650 --> 00:13:20,670
are because before we get into the ugly

00:13:15,660 --> 00:13:23,520
parts of migrating so the main goal here

00:13:20,670 --> 00:13:25,890
was to have a simpler user facing API in

00:13:23,520 --> 00:13:27,810
particular getting rid of the ugly can

00:13:25,890 --> 00:13:30,780
build from that always pops up an error

00:13:27,810 --> 00:13:32,970
messages and that required us to hide

00:13:30,780 --> 00:13:37,350
the real signatures of methods in the

00:13:32,970 --> 00:13:40,170
scala doc in the past we also made some

00:13:37,350 --> 00:13:42,420
internal changes that make it easier to

00:13:40,170 --> 00:13:45,600
implement non-strict collections like

00:13:42,420 --> 00:13:47,820
stream in scala 212 you had to override

00:13:45,600 --> 00:13:49,470
basically every method if you

00:13:47,820 --> 00:13:52,500
implemented a non strict collection

00:13:49,470 --> 00:13:54,420
otherwise you would accidentally force

00:13:52,500 --> 00:13:56,970
the collection because all the default

00:13:54,420 --> 00:13:59,430
implementations assumed a strict

00:13:56,970 --> 00:14:01,440
collection so we reversed that now the

00:13:59,430 --> 00:14:03,390
default is lazy and we have special

00:14:01,440 --> 00:14:06,720
optimized versions that you can use for

00:14:03,390 --> 00:14:08,760
strict collections we also simplified

00:14:06,720 --> 00:14:10,680
the internal hierarchy a bit this is

00:14:08,760 --> 00:14:13,140
useful for implementers of course

00:14:10,680 --> 00:14:15,630
because your collections become simpler

00:14:13,140 --> 00:14:17,730
to write but it also benefits everyone

00:14:15,630 --> 00:14:20,010
because the simpler internal hierarchy

00:14:17,730 --> 00:14:21,780
with fewer types means that the Scala

00:14:20,010 --> 00:14:23,700
compiler has an easier job compiling

00:14:21,780 --> 00:14:30,570
your code and therefore it compiles

00:14:23,700 --> 00:14:33,600
faster ok let's move on to the problems

00:14:30,570 --> 00:14:35,490
that this redesign causes this one is

00:14:33,600 --> 00:14:36,660
actually a problem but many of us have

00:14:35,490 --> 00:14:39,630
been looking forward to

00:14:36,660 --> 00:14:42,120
scarlet seek is now scour collection

00:14:39,630 --> 00:14:44,640
immutable seek so we finally made the

00:14:42,120 --> 00:14:47,610
default seek immutable which many people

00:14:44,640 --> 00:14:50,640
have wanted for years and the same goes

00:14:47,610 --> 00:14:54,030
for indexed seek it is now consistent

00:14:50,640 --> 00:14:55,740
with Scarlett set and Scarlett map which

00:14:54,030 --> 00:14:56,310
already pointed to the immutable

00:14:55,740 --> 00:15:00,660
versions

00:14:56,310 --> 00:15:02,670
past only sequels the outlier there I

00:15:00,660 --> 00:15:04,890
can't give you a general guideline on

00:15:02,670 --> 00:15:07,470
which one you use it you really have to

00:15:04,890 --> 00:15:09,450
decide that on a case-by-case basis in

00:15:07,470 --> 00:15:12,060
many cases your code will just continue

00:15:09,450 --> 00:15:14,790
to compile as it did because you already

00:15:12,060 --> 00:15:17,130
assumed that the default seek would be

00:15:14,790 --> 00:15:19,500
immutable and that's all you cared about

00:15:17,130 --> 00:15:21,450
and in this case you're fine but in some

00:15:19,500 --> 00:15:23,580
cases you really want to abstract over

00:15:21,450 --> 00:15:25,320
both mutable and immutable collections

00:15:23,580 --> 00:15:27,360
so you'll have to use scholar

00:15:25,320 --> 00:15:29,640
collections seek explicitly if that's

00:15:27,360 --> 00:15:31,320
what you want and of course in order to

00:15:29,640 --> 00:15:33,390
cross build you can just reference

00:15:31,320 --> 00:15:35,370
scholar collection see course color

00:15:33,390 --> 00:15:38,390
collection immutable seek directly

00:15:35,370 --> 00:15:42,240
instead of relying on scholar dot seek

00:15:38,390 --> 00:15:44,430
so we're doing this change now in 213

00:15:42,240 --> 00:15:47,640
why wasn't it always that way

00:15:44,430 --> 00:15:49,200
why was scholar dot seek not immutable

00:15:47,640 --> 00:15:51,600
in the first place like the other

00:15:49,200 --> 00:15:55,410
collection types were well the reason

00:15:51,600 --> 00:15:58,080
for that is VAR args marks are part of

00:15:55,410 --> 00:16:00,540
the scholar language specification which

00:15:58,080 --> 00:16:02,850
is supposed to refer only to types in

00:16:00,540 --> 00:16:05,430
the scholar package so scholar dot seek

00:16:02,850 --> 00:16:09,150
is okay to use something like scholar

00:16:05,430 --> 00:16:10,860
collection seek is not and for Barack's

00:16:09,150 --> 00:16:12,810
itself it would not be a problem we can

00:16:10,860 --> 00:16:15,240
just use an immutable seek but we have

00:16:12,810 --> 00:16:18,570
to interoperate with job of our arcs on

00:16:15,240 --> 00:16:21,930
the JVM and Java Barack's use rays which

00:16:18,570 --> 00:16:25,080
are mutable and therefore Scala dot seek

00:16:21,930 --> 00:16:27,390
was defined to be the generic seek so it

00:16:25,080 --> 00:16:30,390
could abstract over both immutable

00:16:27,390 --> 00:16:34,830
sequences and mutable ones like Java VAR

00:16:30,390 --> 00:16:37,980
arc arrays of course in Java while

00:16:34,830 --> 00:16:40,470
arrays are technically mutable everyone

00:16:37,980 --> 00:16:43,260
who uses Vioxx relies on them being

00:16:40,470 --> 00:16:45,690
effectively immutable you don't expect

00:16:43,260 --> 00:16:47,730
to be able to pass an array to a method

00:16:45,690 --> 00:16:50,160
that takes var arcs and then modify it

00:16:47,730 --> 00:16:52,529
possibly concurrently nobody is prepared

00:16:50,160 --> 00:16:54,870
for that so they already have to be

00:16:52,529 --> 00:16:57,270
effectively immutable so we're treating

00:16:54,870 --> 00:16:59,339
them as effectively immutable so if you

00:16:57,270 --> 00:17:01,800
interoperate with Java or arcs now we've

00:16:59,339 --> 00:17:03,450
just pretend the array is immutable and

00:17:01,800 --> 00:17:05,670
wrap it in a new type that's called

00:17:03,450 --> 00:17:08,160
Scala collection immutable array seek

00:17:05,670 --> 00:17:10,169
and you can do the same for your own

00:17:08,160 --> 00:17:12,359
erase if for efficient

00:17:10,169 --> 00:17:14,879
reasons you want to have an array

00:17:12,359 --> 00:17:16,889
constructed in a mutable way and then

00:17:14,879 --> 00:17:21,089
wrap it as an immutable seek you can

00:17:16,889 --> 00:17:24,359
call erase it or unsafe wrap array we

00:17:21,089 --> 00:17:28,249
still have the implicit conversion from

00:17:24,359 --> 00:17:30,629
array to Scala collection seek as before

00:17:28,249 --> 00:17:32,399
this is not going to change but of

00:17:30,629 --> 00:17:35,549
course it's not a scholar dot seek

00:17:32,399 --> 00:17:37,379
anymore because it's mutable so there's

00:17:35,549 --> 00:17:39,989
another implicit conversion because

00:17:37,379 --> 00:17:42,299
there are many of these cases in your in

00:17:39,989 --> 00:17:45,359
at least in the code bases that we

00:17:42,299 --> 00:17:48,179
migrated so we added this deprecated

00:17:45,359 --> 00:17:50,669
implicit conversion that makes a copy of

00:17:48,179 --> 00:17:53,159
the array this is usually not what you

00:17:50,669 --> 00:17:56,309
want because in these cases the array

00:17:53,159 --> 00:17:57,419
often is effectively immutable so if you

00:17:56,309 --> 00:17:59,749
still have the deprecation warnings

00:17:57,419 --> 00:18:03,419
turned on from the first step of

00:17:59,749 --> 00:18:05,190
upgrading to 213 you will get this error

00:18:03,419 --> 00:18:08,519
message or this warning message here

00:18:05,190 --> 00:18:10,679
that tells you to call erasing the

00:18:08,519 --> 00:18:13,529
unsafe wrap array if you want to avoid

00:18:10,679 --> 00:18:15,629
copying or if copying is really what you

00:18:13,529 --> 00:18:22,139
want and add an explicit to index the

00:18:15,629 --> 00:18:24,389
call ok this one is the biggest change

00:18:22,139 --> 00:18:27,269
in the new collections there is no can

00:18:24,389 --> 00:18:30,840
build from anymore well actually there

00:18:27,269 --> 00:18:34,049
is one it's called built from it it

00:18:30,840 --> 00:18:35,909
looks almost the same the the type is

00:18:34,049 --> 00:18:38,369
exactly the same actually the methods

00:18:35,909 --> 00:18:41,340
are a bit different the new builder

00:18:38,369 --> 00:18:43,379
method used to be called apply and the

00:18:41,340 --> 00:18:45,419
from specific iterable and method is new

00:18:43,379 --> 00:18:47,850
that's the one that allows lazy building

00:18:45,419 --> 00:18:50,249
instead of only strict building as a new

00:18:47,850 --> 00:18:53,059
builder the crucial difference between

00:18:50,249 --> 00:18:56,070
can build from and build from is that

00:18:53,059 --> 00:18:57,210
built from always requires an instance

00:18:56,070 --> 00:19:00,210
of the source type

00:18:57,210 --> 00:19:02,369
that's the from argument here can build

00:19:00,210 --> 00:19:04,049
from had another apply method that you

00:19:02,369 --> 00:19:08,009
could call without giving it a source

00:19:04,049 --> 00:19:10,559
and if you use built from the source

00:19:08,009 --> 00:19:12,659
collection determines what to build so

00:19:10,559 --> 00:19:16,859
you always have to use an instance of

00:19:12,659 --> 00:19:18,749
that but in many cases you don't care

00:19:16,859 --> 00:19:19,710
about it because you're not you going to

00:19:18,749 --> 00:19:22,859
use it anymore

00:19:19,710 --> 00:19:24,300
methods inside the collections library

00:19:22,859 --> 00:19:27,060
itself like

00:19:24,300 --> 00:19:29,820
that map on collection classes no longer

00:19:27,060 --> 00:19:32,820
use built from or can build from they

00:19:29,820 --> 00:19:35,910
are overloaded now to produce different

00:19:32,820 --> 00:19:37,590
results depending on the source type we

00:19:35,910 --> 00:19:41,160
had to make some changes to the compiler

00:19:37,590 --> 00:19:44,190
to enable this in 212 you would have to

00:19:41,160 --> 00:19:45,960
have to add many many explicit type

00:19:44,190 --> 00:19:46,770
annotations to make it work with

00:19:45,960 --> 00:19:48,480
overloading

00:19:46,770 --> 00:19:50,970
so we improved the compiler to handle

00:19:48,480 --> 00:19:53,520
those cases and how we can implement it

00:19:50,970 --> 00:19:55,980
that way there are methods however that

00:19:53,520 --> 00:19:57,690
use it mostly methods outside of the

00:19:55,980 --> 00:20:00,630
collections library like future dot

00:19:57,690 --> 00:20:02,400
sequence you could implement future dot

00:20:00,630 --> 00:20:05,280
sequence in the same way with

00:20:02,400 --> 00:20:09,600
overloading but you would have to write

00:20:05,280 --> 00:20:12,270
for almost identical methods for almost

00:20:09,600 --> 00:20:14,490
identical overloads to handle just the

00:20:12,270 --> 00:20:16,700
basic for collection kinds and then when

00:20:14,490 --> 00:20:20,000
it comes to collection kinds like

00:20:16,700 --> 00:20:22,830
special cases like int map or long map

00:20:20,000 --> 00:20:25,800
you still couldn't use them in the way

00:20:22,830 --> 00:20:30,990
you want to so that's why we use built

00:20:25,800 --> 00:20:33,270
from photos there's a second type which

00:20:30,990 --> 00:20:37,980
also looks almost like can build from

00:20:33,270 --> 00:20:41,070
and that's called Factory and unlike

00:20:37,980 --> 00:20:42,830
built from factory does not take an

00:20:41,070 --> 00:20:47,280
instance of the source collection type

00:20:42,830 --> 00:20:49,890
so instead of using this matrix of

00:20:47,280 --> 00:20:52,020
possibilities with can build from that

00:20:49,890 --> 00:20:54,360
you can build based on the target type

00:20:52,020 --> 00:20:56,550
or the source type or whatever the

00:20:54,360 --> 00:20:59,370
source collection tells you we have to

00:20:56,550 --> 00:21:01,320
clean paths now if you use built from

00:20:59,370 --> 00:21:03,570
the source collection instance

00:21:01,320 --> 00:21:06,120
determines what to build if you use

00:21:03,570 --> 00:21:11,420
Factory the type determines what to

00:21:06,120 --> 00:21:17,970
build so the general rule here is to use

00:21:11,420 --> 00:21:20,510
built from - to rebuild a source

00:21:17,970 --> 00:21:23,910
collection with the best matching type

00:21:20,510 --> 00:21:26,070
otherwise you use factory I would like

00:21:23,910 --> 00:21:28,020
to give you an even simpler rule which

00:21:26,070 --> 00:21:30,090
is if you have an instance of the source

00:21:28,020 --> 00:21:34,200
collection then use built from otherwise

00:21:30,090 --> 00:21:36,540
use Factory but of course the one one

00:21:34,200 --> 00:21:37,720
important example that we use it that we

00:21:36,540 --> 00:21:40,059
use it

00:21:37,720 --> 00:21:41,620
factory for in the collections library

00:21:40,059 --> 00:21:44,409
is a counterexample to that and that's

00:21:41,620 --> 00:21:47,230
the method to an iterable if you want to

00:21:44,409 --> 00:21:48,850
convert an iterable to something you

00:21:47,230 --> 00:21:50,049
already have an instance of the source

00:21:48,850 --> 00:21:51,909
collection that's what you want to

00:21:50,049 --> 00:21:53,559
convert but you don't care what that is

00:21:51,909 --> 00:21:56,320
because all you care about what to

00:21:53,559 --> 00:22:01,029
convert it to so you use Factory and not

00:21:56,320 --> 00:22:03,340
build from but in either case it's

00:22:01,029 --> 00:22:04,990
usually easy to change your code that

00:22:03,340 --> 00:22:07,480
users can build from if you have your

00:22:04,990 --> 00:22:09,429
own methods like future dot sequence

00:22:07,480 --> 00:22:12,039
that take it can build from in most

00:22:09,429 --> 00:22:13,870
cases all it takes is replacing that

00:22:12,039 --> 00:22:20,370
either with a build from over the

00:22:13,870 --> 00:22:23,860
factory so with can build from gun

00:22:20,370 --> 00:22:25,419
there's also no break out anymore break

00:22:23,860 --> 00:22:27,100
out is what you use when you want to

00:22:25,419 --> 00:22:29,830
avoid building an intermediate

00:22:27,100 --> 00:22:33,970
collection in a method that takes it can

00:22:29,830 --> 00:22:37,990
build from like flatmap or well in this

00:22:33,970 --> 00:22:39,549
case we're using map that's map doesn't

00:22:37,990 --> 00:22:41,590
actually take a camp out from so the

00:22:39,549 --> 00:22:44,200
example doesn't quite work but if you

00:22:41,590 --> 00:22:47,289
assume it's flat map and you have access

00:22:44,200 --> 00:22:49,750
dot flat flat map and then you can pass

00:22:47,289 --> 00:22:52,750
a breakout to it to build a vector if

00:22:49,750 --> 00:22:55,029
you annotate the type so in general just

00:22:52,750 --> 00:22:56,500
use an iterator for that that's the

00:22:55,029 --> 00:22:58,840
efficient way to avoid building an

00:22:56,500 --> 00:23:01,029
intermediate collection there are cases

00:22:58,840 --> 00:23:02,620
where an iterator doesn't actually have

00:23:01,029 --> 00:23:04,720
the method you're trying to call for

00:23:02,620 --> 00:23:06,909
example when you have start with a map

00:23:04,720 --> 00:23:10,500
and you want to call map values on it in

00:23:06,909 --> 00:23:10,500
that case you have to use a view

00:23:14,780 --> 00:23:25,850
so if you have a method that takes it

00:23:20,420 --> 00:23:29,540
built from or a factory which does not

00:23:25,850 --> 00:23:34,460
really occur in the in the current 212

00:23:29,540 --> 00:23:36,830
library then you can you rely on the

00:23:34,460 --> 00:23:40,550
implicit conversion of a factory object

00:23:36,830 --> 00:23:42,680
to build from our factory so the this

00:23:40,550 --> 00:23:44,570
example doesn't quite work in 212 but

00:23:42,680 --> 00:23:48,800
what we're trying to do here is you

00:23:44,570 --> 00:23:50,600
start with with a list of future of int

00:23:48,800 --> 00:23:53,450
and you want to convert it to a future

00:23:50,600 --> 00:23:57,350
of vector of int so you use future dot

00:23:53,450 --> 00:24:00,290
sequence for that and instead of relying

00:23:57,350 --> 00:24:03,350
on it to infer an implicit can't build

00:24:00,290 --> 00:24:05,780
from you pass it a breakout value and

00:24:03,350 --> 00:24:07,520
then annotate the result type as future

00:24:05,780 --> 00:24:09,770
of vector of int the only reason that

00:24:07,520 --> 00:24:11,750
this doesn't work in 212 is that the

00:24:09,770 --> 00:24:13,400
type of the can build from is

00:24:11,750 --> 00:24:16,730
constrained to much but it could be

00:24:13,400 --> 00:24:20,600
easily made work and made to work in 212

00:24:16,730 --> 00:24:23,570
and what you do in 213 and this actually

00:24:20,600 --> 00:24:26,030
compiles it's you just pass vector

00:24:23,570 --> 00:24:29,150
instead of having having it infer an

00:24:26,030 --> 00:24:30,770
implicit built from instance and it's

00:24:29,150 --> 00:24:32,180
actually shorter than it to 12 because

00:24:30,770 --> 00:24:34,340
you don't have to spell out the whole

00:24:32,180 --> 00:24:36,050
result type anymore you just have to

00:24:34,340 --> 00:24:43,580
give me the value for the type

00:24:36,050 --> 00:24:45,500
constructor so I already briefly

00:24:43,580 --> 00:24:48,860
mentioned views as a replacement for

00:24:45,500 --> 00:24:51,290
breakout use in 213 are very different

00:24:48,860 --> 00:24:53,150
from from the old views we basically

00:24:51,290 --> 00:24:55,610
removed the old views entirely and

00:24:53,150 --> 00:24:57,860
started from scratch fortunately not

00:24:55,610 --> 00:25:00,830
many people are actually using views and

00:24:57,860 --> 00:25:03,110
if you are using them you may not even

00:25:00,830 --> 00:25:06,680
notice the differences in practice in

00:25:03,110 --> 00:25:09,980
the way you are using the views so views

00:25:06,680 --> 00:25:12,290
in 213 are essentially reified iterator

00:25:09,980 --> 00:25:14,510
operations if you're familiar with the

00:25:12,290 --> 00:25:16,670
Java 8 streams API you can think of the

00:25:14,510 --> 00:25:19,340
distinction between view and iterator as

00:25:16,670 --> 00:25:22,990
being similar to stream versus splitter

00:25:19,340 --> 00:25:26,090
ater so you use view to compose your

00:25:22,990 --> 00:25:27,080
operations on collections and they are

00:25:26,090 --> 00:25:31,070
implemented

00:25:27,080 --> 00:25:33,289
iterators so you can just compose your

00:25:31,070 --> 00:25:34,700
operations in the abstract and then when

00:25:33,289 --> 00:25:36,320
you actually want to get the data

00:25:34,700 --> 00:25:38,450
iterate over it

00:25:36,320 --> 00:25:40,580
the view goes to the source collection

00:25:38,450 --> 00:25:43,580
and fetches the current data from that

00:25:40,580 --> 00:25:45,559
so you always get reliable semantics for

00:25:43,580 --> 00:25:49,879
a mutable and immutable collections

00:25:45,559 --> 00:25:52,159
alike one difference with this design is

00:25:49,879 --> 00:25:54,379
that views are no longer tied to the

00:25:52,159 --> 00:25:56,480
source collection type or value in

00:25:54,379 --> 00:25:58,909
particular they do not remember the

00:25:56,480 --> 00:26:01,190
source collection type there is still a

00:25:58,909 --> 00:26:03,859
method called force which is deprecated

00:26:01,190 --> 00:26:05,720
now that you can use to force the

00:26:03,859 --> 00:26:08,119
contents of a view but now it always

00:26:05,720 --> 00:26:11,239
builds an index seek because we do not

00:26:08,119 --> 00:26:13,129
remember the exact type so usually what

00:26:11,239 --> 00:26:16,549
you want to do is call one of the

00:26:13,129 --> 00:26:19,100
explicit two operations like a specific

00:26:16,549 --> 00:26:21,019
to list or to array or just a generic -

00:26:19,100 --> 00:26:25,460
in order to convert the view to whatever

00:26:21,019 --> 00:26:27,289
you want one case where you actually may

00:26:25,460 --> 00:26:30,440
have encountered views even if you

00:26:27,289 --> 00:26:33,559
didn't know it is in map values and

00:26:30,440 --> 00:26:36,799
filter keys on map so if you use those

00:26:33,559 --> 00:26:38,749
methods they pretend to return a map but

00:26:36,799 --> 00:26:41,600
it's actually lazy so it should really

00:26:38,749 --> 00:26:43,639
be a view and due to thirteen we made it

00:26:41,600 --> 00:26:45,739
a view so if you see an error message

00:26:43,639 --> 00:26:48,049
when you're compiling on to 13 that you

00:26:45,739 --> 00:26:50,149
get a map view where we expected a map

00:26:48,049 --> 00:26:52,820
that's probably what's happening you

00:26:50,149 --> 00:26:54,950
called filter keys or map values on it

00:26:52,820 --> 00:26:59,230
so if you really want a map then you

00:26:54,950 --> 00:26:59,230
have to call a day to map call to it

00:27:01,629 --> 00:27:07,279
okay this is probably the biggest

00:27:03,919 --> 00:27:08,659
incompatibility but not many people are

00:27:07,279 --> 00:27:11,809
going to implement custom collection

00:27:08,659 --> 00:27:13,820
types who hear us is doing that in their

00:27:11,809 --> 00:27:15,679
codebase do we have anyone who's

00:27:13,820 --> 00:27:19,970
implementing their own collection one

00:27:15,679 --> 00:27:21,440
person I see one yes one reason for for

00:27:19,970 --> 00:27:23,779
that is of course that it's really hard

00:27:21,440 --> 00:27:26,330
to implement custom collection types at

00:27:23,779 --> 00:27:29,859
the moment so this is going to be easier

00:27:26,330 --> 00:27:34,450
in 213 we simplified the type hierarchy

00:27:29,859 --> 00:27:37,299
there's less boilerplate in general and

00:27:34,450 --> 00:27:40,100
there are a few other changes that are

00:27:37,299 --> 00:27:41,100
not necessarily easier but make it

00:27:40,100 --> 00:27:44,340
different like

00:27:41,100 --> 00:27:46,799
all this simple symbolic operators are

00:27:44,340 --> 00:27:49,320
only aliases for alphanumeric names now

00:27:46,799 --> 00:27:52,890
so instead of overriding the plus plus

00:27:49,320 --> 00:27:55,169
method you now override concat and of

00:27:52,890 --> 00:27:57,870
course instead of writing a flat map

00:27:55,169 --> 00:27:59,909
that takes a candle from you write

00:27:57,870 --> 00:28:02,460
multiple overloaded versions of flat map

00:27:59,909 --> 00:28:05,789
or just a single one that augments the

00:28:02,460 --> 00:28:10,140
existing overloaded versions but this

00:28:05,789 --> 00:28:12,659
means there's no realistic chance to be

00:28:10,140 --> 00:28:13,460
able to cross build on 212 and 213 if

00:28:12,659 --> 00:28:16,230
you're off your own collection

00:28:13,460 --> 00:28:19,110
implementation so what you generally do

00:28:16,230 --> 00:28:22,529
is that you use different source files

00:28:19,110 --> 00:28:27,419
for those and just have two different

00:28:22,529 --> 00:28:30,600
implementations so the way to do this in

00:28:27,419 --> 00:28:34,110
SBT is to have different source folders

00:28:30,600 --> 00:28:37,649
where you can place those files you may

00:28:34,110 --> 00:28:40,620
not have used this feature before or may

00:28:37,649 --> 00:28:43,830
not even be aware of it I I didn't know

00:28:40,620 --> 00:28:46,590
this for for a long time myself but SBT

00:28:43,830 --> 00:28:49,500
already provides these this feature out

00:28:46,590 --> 00:28:52,620
of the box so in addition to your source

00:28:49,500 --> 00:28:55,320
main Scala for example you already get a

00:28:52,620 --> 00:28:56,760
source main Scala - with the Scala

00:28:55,320 --> 00:28:59,279
binary version where you can put your

00:28:56,760 --> 00:29:01,559
sources so if you compile against

00:28:59,279 --> 00:29:03,510
multiple scholar versions SPT will

00:29:01,559 --> 00:29:06,029
automatically pick up the sources from

00:29:03,510 --> 00:29:07,889
the right folder out of the box now the

00:29:06,029 --> 00:29:09,899
problem with that is it's tied to the

00:29:07,889 --> 00:29:11,190
binary version but that's not what we

00:29:09,899 --> 00:29:12,750
care about we care about source

00:29:11,190 --> 00:29:16,230
compatibility here not binary

00:29:12,750 --> 00:29:18,090
compatibility so it's not very useful in

00:29:16,230 --> 00:29:21,230
practice unless you only want to build

00:29:18,090 --> 00:29:24,090
against exactly two different versions

00:29:21,230 --> 00:29:25,830
if you want more than you have to wire

00:29:24,090 --> 00:29:28,860
this up yourself so we're doing it in

00:29:25,830 --> 00:29:31,350
the same way as we did with the compiler

00:29:28,860 --> 00:29:33,600
flags example earlier we look at the

00:29:31,350 --> 00:29:36,000
scala version and then add to the

00:29:33,600 --> 00:29:39,000
so-called unmanaged sauce directories in

00:29:36,000 --> 00:29:41,039
compile so in the example here we have

00:29:39,000 --> 00:29:45,570
add two different directories called

00:29:41,039 --> 00:29:48,029
Scala - 213 plus and Scala - 212 -

00:29:45,570 --> 00:29:50,669
depending on whether you're compiling on

00:29:48,029 --> 00:29:53,299
Scala to 13 and ha or higher or Scala to

00:29:50,669 --> 00:29:53,299
12 or lower

00:29:55,160 --> 00:30:00,270
so this was an overview of the probably

00:29:58,830 --> 00:30:03,450
the biggest or most important

00:30:00,270 --> 00:30:05,640
incompatibilities there are a few other

00:30:03,450 --> 00:30:07,950
ones that you may encounter we have an

00:30:05,640 --> 00:30:11,580
FAQ on the old collection Strom and

00:30:07,950 --> 00:30:13,080
repository that we used to develop the

00:30:11,580 --> 00:30:15,570
new collections library where you can

00:30:13,080 --> 00:30:22,860
find more information about possible

00:30:15,570 --> 00:30:27,440
incompatibilities Stefan presented the

00:30:22,860 --> 00:30:33,030
incompatibilities that require some some

00:30:27,440 --> 00:30:36,480
soaked to solve and hopefully most of

00:30:33,030 --> 00:30:38,370
the most of the incompatibilities not

00:30:36,480 --> 00:30:41,610
like that and they are quite simple

00:30:38,370 --> 00:30:45,390
actually to to migrate in most of the

00:30:41,610 --> 00:30:47,940
case that's just deprecation so it tells

00:30:45,390 --> 00:30:52,550
us instead of using that just use that

00:30:47,940 --> 00:30:52,550
because we have renamed something and

00:30:53,060 --> 00:31:00,450
when when we have a simple case like

00:30:56,400 --> 00:31:05,100
that we can automate them so we are

00:31:00,450 --> 00:31:08,160
working on automatic migration tool the

00:31:05,100 --> 00:31:10,200
idea is that if you have you application

00:31:08,160 --> 00:31:14,010
that works with 212 that compiles with

00:31:10,200 --> 00:31:17,940
212 then you apply the migration tool to

00:31:14,010 --> 00:31:22,290
your code to use source code and it

00:31:17,940 --> 00:31:25,770
produced the it updates the source code

00:31:22,290 --> 00:31:29,880
in place so that the application now

00:31:25,770 --> 00:31:33,060
compiles with 213 this migration tool is

00:31:29,880 --> 00:31:35,580
implemented as a scatter fix rewrite

00:31:33,060 --> 00:31:39,990
rule in case you don't know scatter fix

00:31:35,580 --> 00:31:44,360
that code manipulation tool that has

00:31:39,990 --> 00:31:47,940
been developed at the scalar center and

00:31:44,360 --> 00:31:50,820
so hopefully after you apply the

00:31:47,940 --> 00:31:54,419
migration rule to your code you have

00:31:50,820 --> 00:31:56,970
a project that comparative is 213 but

00:31:54,419 --> 00:31:59,210
maybe you will still have to migrate

00:31:56,970 --> 00:32:05,789
some of the remaining corner cases

00:31:59,210 --> 00:32:08,820
manually in practice this looks like

00:32:05,789 --> 00:32:13,440
that so first you add the scatter fix

00:32:08,820 --> 00:32:14,700
SBT plug-in to your project then you run

00:32:13,440 --> 00:32:18,570
a few SBT command

00:32:14,700 --> 00:32:21,210
so first skala fix unable to just enable

00:32:18,570 --> 00:32:25,529
scatter fix and then you run the

00:32:21,210 --> 00:32:29,820
migration rule so this is the identifier

00:32:25,529 --> 00:32:34,019
of the migration rule and that update

00:32:29,820 --> 00:32:37,200
your source code in place then you

00:32:34,019 --> 00:32:41,070
change the scatter version in your build

00:32:37,200 --> 00:32:45,149
and finally you reload the the SBT build

00:32:41,070 --> 00:32:47,460
and you try to compile you can find the

00:32:45,149 --> 00:32:54,000
detailed documentation in the github

00:32:47,460 --> 00:32:58,559
repository so what kind of migration do

00:32:54,000 --> 00:33:01,409
we support typically renaming as I've

00:32:58,559 --> 00:33:05,070
said so for instance for instance here

00:33:01,409 --> 00:33:08,909
we can see two migration rules working

00:33:05,070 --> 00:33:12,629
at the same time stream has been renamed

00:33:08,909 --> 00:33:18,509
it into lazy list and append has been

00:33:12,629 --> 00:33:20,730
renamed into lazy appended all so those

00:33:18,509 --> 00:33:23,240
kind of rule are quite simple to

00:33:20,730 --> 00:33:26,100
implement if you want to contribute

00:33:23,240 --> 00:33:28,340
migration your migration rules you are

00:33:26,100 --> 00:33:32,100
welcome

00:33:28,340 --> 00:33:35,269
okay maybe this this is not the best

00:33:32,100 --> 00:33:39,090
example because actually lazy list is

00:33:35,269 --> 00:33:41,720
slightly different from stream the

00:33:39,090 --> 00:33:46,970
semantics is slightly different because

00:33:41,720 --> 00:33:51,419
stream has lazy tail but has a strict

00:33:46,970 --> 00:33:55,350
head and in the case of laziness both

00:33:51,419 --> 00:33:58,169
the head and the tail are lazy so that's

00:33:55,350 --> 00:34:01,789
a small difference that can change the

00:33:58,169 --> 00:34:05,160
behavior of your program so actually the

00:34:01,789 --> 00:34:08,850
migration hole that rewrites stream into

00:34:05,160 --> 00:34:11,070
lazy list will become optional so it

00:34:08,850 --> 00:34:14,609
will not be on a blade by default and

00:34:11,070 --> 00:34:16,169
then what kind of other migration will

00:34:14,609 --> 00:34:20,100
do we have well

00:34:16,169 --> 00:34:22,260
basically anything that rewrites some

00:34:20,100 --> 00:34:25,919
expression into something else for

00:34:22,260 --> 00:34:29,820
example instead of calling capital

00:34:25,919 --> 00:34:32,730
buffer now you just concatenate all the

00:34:29,820 --> 00:34:37,169
element to the buffer so this is one

00:34:32,730 --> 00:34:39,300
example and unfortunately the more

00:34:37,169 --> 00:34:45,119
complex the expression to rewrite the

00:34:39,300 --> 00:34:52,350
harder to implement the rule so there is

00:34:45,119 --> 00:34:56,639
a trade off that we have to do and and

00:34:52,350 --> 00:35:00,090
because of that some things are not in

00:34:56,639 --> 00:35:05,210
the scope of the migration rules for

00:35:00,090 --> 00:35:08,100
instance I will start with this one

00:35:05,210 --> 00:35:11,670
advanced usage of can build from because

00:35:08,100 --> 00:35:15,510
they might involved very complex

00:35:11,670 --> 00:35:18,540
expressions so we cannot find a generic

00:35:15,510 --> 00:35:21,450
way to say how we should rewrite some

00:35:18,540 --> 00:35:26,280
usage of can bid from in to the new the

00:35:21,450 --> 00:35:30,359
new way also custom collection

00:35:26,280 --> 00:35:32,340
implementations because the API is a

00:35:30,359 --> 00:35:36,720
little bit too different it's how to

00:35:32,340 --> 00:35:38,369
find a an automatic way to to migrate

00:35:36,720 --> 00:35:42,810
from the old correction to the new

00:35:38,369 --> 00:35:45,660
correction and finally the usage of

00:35:42,810 --> 00:35:48,810
scattered seek because as Stefan

00:35:45,660 --> 00:35:50,640
explained now Scala dot C is a dot

00:35:48,810 --> 00:35:56,790
correction that immutable that's sick

00:35:50,640 --> 00:36:00,240
and we we cannot automatically migrate

00:35:56,790 --> 00:36:02,580
existing code because it really depends

00:36:00,240 --> 00:36:05,280
in in some cases you really want to

00:36:02,580 --> 00:36:07,680
still continue using

00:36:05,280 --> 00:36:09,510
schuyler that correction that seek but

00:36:07,680 --> 00:36:12,720
maybe in some other cases you are happy

00:36:09,510 --> 00:36:17,310
to to use the new cat scatter correction

00:36:12,720 --> 00:36:21,990
immutable seek so we are not going to

00:36:17,310 --> 00:36:25,470
take that decision for you and in the

00:36:21,990 --> 00:36:27,750
faq you can find the exhaustive list of

00:36:25,470 --> 00:36:34,710
what is currently supported by the

00:36:27,750 --> 00:36:37,560
migration rules the examples that I've

00:36:34,710 --> 00:36:39,000
shown was about migrating migrating an

00:36:37,560 --> 00:36:41,790
application in the case of an

00:36:39,000 --> 00:36:45,690
application usually you only care about

00:36:41,790 --> 00:36:49,290
compiling with one version of Scala but

00:36:45,690 --> 00:36:50,550
in the case of migrating a library the

00:36:49,290 --> 00:36:52,260
story is a little bit different because

00:36:50,550 --> 00:36:54,930
usually we want your library to cross

00:36:52,260 --> 00:36:57,570
compile with several version of SCARA at

00:36:54,930 --> 00:37:00,680
the same time so for example if you have

00:36:57,570 --> 00:37:05,040
a library that compiles with 211 and 212

00:37:00,680 --> 00:37:11,400
then you want that your library compile

00:37:05,040 --> 00:37:15,830
with with 211 212 and 213 after after

00:37:11,400 --> 00:37:20,460
you apply the migration rules on it and

00:37:15,830 --> 00:37:25,140
so we plan to provide a rule that will

00:37:20,460 --> 00:37:32,190
produce a cut that that cross compiled

00:37:25,140 --> 00:37:35,850
with 211 212 and 213 but we we have not

00:37:32,190 --> 00:37:39,320
released that yet and yeah just that's

00:37:35,850 --> 00:37:39,320
something that we are working on

00:37:43,160 --> 00:37:52,470
did I make it so I think this is it

00:37:49,110 --> 00:37:57,570
right so in case you want to know more

00:37:52,470 --> 00:38:00,510
about the internal changes of the new

00:37:57,570 --> 00:38:02,130
collections you can read the

00:38:00,510 --> 00:38:06,600
documentation that has that is already

00:38:02,130 --> 00:38:09,840
online and you can also check out this

00:38:06,600 --> 00:38:13,440
example of project that shows how to

00:38:09,840 --> 00:38:16,440
write code that cross-compile between 21

00:38:13,440 --> 00:38:20,610
to 12 and 213 using the correction

00:38:16,440 --> 00:38:23,640
compatibility library of course you can

00:38:20,610 --> 00:38:27,540
have a look at the FAQ which is to date

00:38:23,640 --> 00:38:29,340
the most exhaustive source of changes

00:38:27,540 --> 00:38:34,880
between the old collections and the new

00:38:29,340 --> 00:38:38,250
collections and also we have two links

00:38:34,880 --> 00:38:55,770
to our previous talks about the new

00:38:38,250 --> 00:38:58,790
collections thanks do we have time for

00:38:55,770 --> 00:39:03,720
questions or are there any question

00:38:58,790 --> 00:39:10,020
maybe not yes I think you have to do

00:39:03,720 --> 00:39:13,140
take the microphone I noticed on the

00:39:10,020 --> 00:39:15,840
slide where you suggest how to migrate

00:39:13,140 --> 00:39:19,410
codes that used breakout that you

00:39:15,840 --> 00:39:22,080
recommended using dot iterator did you

00:39:19,410 --> 00:39:24,510
recommend that iterator only because we

00:39:22,080 --> 00:39:27,630
might be cross building with old Scala

00:39:24,510 --> 00:39:30,330
versions where views don't work or even

00:39:27,630 --> 00:39:31,980
if I'm only in Scala 213 would you still

00:39:30,330 --> 00:39:36,780
sometimes recommend using iterator

00:39:31,980 --> 00:39:40,050
overview yeah that's a very good point

00:39:36,780 --> 00:39:43,650
so indeed if you use the iterator

00:39:40,050 --> 00:39:47,220
instead of you you you are guaranteed to

00:39:43,650 --> 00:39:51,410
to have the behavior the behavior that

00:39:47,220 --> 00:39:53,780
you expect to have because sometimes in

00:39:51,410 --> 00:40:00,110
in the old collections views do not

00:39:53,780 --> 00:40:04,580
behave as expected and so I think as

00:40:00,110 --> 00:40:06,830
long as it fits in 1 9 going with

00:40:04,580 --> 00:40:07,280
iterator instead of you I think it's

00:40:06,830 --> 00:40:10,540
fine

00:40:07,280 --> 00:40:14,600
but if you have something more complex

00:40:10,540 --> 00:40:18,280
maybe it's just safer to go with the

00:40:14,600 --> 00:40:21,560
views yeah I don't know what you

00:40:18,280 --> 00:40:23,660
iterators also can also be a tiny bit

00:40:21,560 --> 00:40:26,270
more efficient yeah because view is a

00:40:23,660 --> 00:40:28,850
wrapper around iterator it's another

00:40:26,270 --> 00:40:31,640
layer on top of it so if you only need

00:40:28,850 --> 00:40:34,280
to consume it once you can avoid

00:40:31,640 --> 00:40:36,470
creating that extra layer by creating an

00:40:34,280 --> 00:40:40,720
iterator directly but the difference is

00:40:36,470 --> 00:40:40,720

YouTube URL: https://www.youtube.com/watch?v=pHHKUKubs1Q


