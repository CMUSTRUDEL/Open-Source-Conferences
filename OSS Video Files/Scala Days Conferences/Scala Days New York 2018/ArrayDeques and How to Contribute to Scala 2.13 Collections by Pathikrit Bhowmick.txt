Title: ArrayDeques and How to Contribute to Scala 2.13 Collections by Pathikrit Bhowmick
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/arraydeques-and-how-to-contribute-to-scala-2-13-collections
Captions: 
	00:00:04,580 --> 00:00:09,650
so I hope you guys are in the right crew

00:00:07,370 --> 00:00:12,709
this talk is about Scala

00:00:09,650 --> 00:00:14,869
213 collections and in general and in

00:00:12,709 --> 00:00:19,190
particular about a new collection called

00:00:14,869 --> 00:00:20,480
array decks so yeah I actually recently

00:00:19,190 --> 00:00:22,910
learned these these things are called

00:00:20,480 --> 00:00:25,430
air attacks not array DQ's there was

00:00:22,910 --> 00:00:28,580
someone pointed me to a English dart

00:00:25,430 --> 00:00:29,930
Stack Exchange link which there was like

00:00:28,580 --> 00:00:32,239
a massive discussion what's the correct

00:00:29,930 --> 00:00:34,250
way but area Dex is the correct

00:00:32,239 --> 00:00:38,020
pronunciation all right

00:00:34,250 --> 00:00:40,430
so bought me my name is Patti Chris I

00:00:38,020 --> 00:00:43,520
work in a hedge fund located a couple of

00:00:40,430 --> 00:00:45,980
blocks away I've been doing scala for a

00:00:43,520 --> 00:00:47,149
bunch of years really love data

00:00:45,980 --> 00:00:51,280
structures and functional programming

00:00:47,149 --> 00:00:55,700
and how they can come together so yeah

00:00:51,280 --> 00:00:58,700
so yeah so as you may or may not know

00:00:55,700 --> 00:01:00,760
that 2.13 has a lot of new a lot of

00:00:58,700 --> 00:01:04,219
changes especially the way collections

00:01:00,760 --> 00:01:06,560
are implemented there have been almost a

00:01:04,219 --> 00:01:10,209
complete rewrite of the collections with

00:01:06,560 --> 00:01:13,159
thankfully minimal API changes so the

00:01:10,209 --> 00:01:16,759
the upgrade might shouldn't be that hard

00:01:13,159 --> 00:01:19,069
as is needed but this stuff I will

00:01:16,759 --> 00:01:20,810
introduce you to what's new and what

00:01:19,069 --> 00:01:25,340
changed and in particular talk about a

00:01:20,810 --> 00:01:28,039
red X so that's another talk by Stefan

00:01:25,340 --> 00:01:29,719
and Julian tomorrow where they'll be

00:01:28,039 --> 00:01:32,659
talking about migrating to stuffs color

00:01:29,719 --> 00:01:34,520
213 and that would also focus a lot

00:01:32,659 --> 00:01:36,560
about the new collections so I would try

00:01:34,520 --> 00:01:38,359
to keep this talk slightly different

00:01:36,560 --> 00:01:41,539
from that and talking particularly more

00:01:38,359 --> 00:01:43,899
about data structures and then about IED

00:01:41,539 --> 00:01:47,689
attacks in particular instead of

00:01:43,899 --> 00:01:49,689
material covered by that top so ok so

00:01:47,689 --> 00:01:56,319
what's changed

00:01:49,689 --> 00:02:00,469
sorry it's today as so what's changed so

00:01:56,319 --> 00:02:04,410
one thing that's gone is Kendall from if

00:02:00,469 --> 00:02:07,740
you don't know about it you're lucky

00:02:04,410 --> 00:02:10,840
so this has been the joke of pretty much

00:02:07,740 --> 00:02:12,580
anyone who's new to scour and points it

00:02:10,840 --> 00:02:18,070
out like haha look at the signature of

00:02:12,580 --> 00:02:19,690
map what is that but okay and there's a

00:02:18,070 --> 00:02:21,430
there was a very good reason for it to

00:02:19,690 --> 00:02:24,910
be there but that we could have done it

00:02:21,430 --> 00:02:27,850
better and now it's much simpler this is

00:02:24,910 --> 00:02:29,740
this map looks a lot like the kind of

00:02:27,850 --> 00:02:34,890
functor maps that you're used to looking

00:02:29,740 --> 00:02:39,340
at so that's one a couple of new api's

00:02:34,890 --> 00:02:40,720
this one I really like I always and I'm

00:02:39,340 --> 00:02:41,980
not going to waste too much time going

00:02:40,720 --> 00:02:44,080
to the scholar dog saying these are the

00:02:41,980 --> 00:02:46,840
new API is but just telling you this one

00:02:44,080 --> 00:02:48,850
this is one that was mentioned and I

00:02:46,840 --> 00:02:52,810
really like it because I always find

00:02:48,850 --> 00:02:55,360
myself doing so in other things that's

00:02:52,810 --> 00:02:56,680
new are in place mutable ap is so

00:02:55,360 --> 00:02:59,380
immutable collections if you want to

00:02:56,680 --> 00:03:01,600
transform them in a place filter in

00:02:59,380 --> 00:03:03,459
place map in place without allocating

00:03:01,600 --> 00:03:06,310
new collections are getting new things

00:03:03,459 --> 00:03:09,090
and back back so these are you think

00:03:06,310 --> 00:03:12,190
that's new there are some more things

00:03:09,090 --> 00:03:15,820
for example streams are deprecated as

00:03:12,190 --> 00:03:18,190
lazy lists are the way to go views are

00:03:15,820 --> 00:03:20,739
first-class citizens we put more views

00:03:18,190 --> 00:03:24,310
were like this weird thing that had a

00:03:20,739 --> 00:03:27,940
bunch of corner cases and didn't really

00:03:24,310 --> 00:03:32,950
work properly but now they should and

00:03:27,940 --> 00:03:36,549
it's a really nice way to chain your

00:03:32,950 --> 00:03:41,320
cord right fluent style code and it not

00:03:36,549 --> 00:03:42,459
have your runtime be multiple it

00:03:41,320 --> 00:03:47,160
shouldn't traverse the collections

00:03:42,459 --> 00:03:49,959
multiple times we got rid of the

00:03:47,160 --> 00:03:52,630
distinction between traversable x' and

00:03:49,959 --> 00:03:56,110
iterators that was a fine distinction

00:03:52,630 --> 00:03:57,610
that very few people actually knew on

00:03:56,110 --> 00:04:01,000
the top of the head which was to with

00:03:57,610 --> 00:04:04,360
use when the preferable is just iterable

00:04:01,000 --> 00:04:07,269
now that's the single abstraction that

00:04:04,360 --> 00:04:10,810
you should keep track of and there are

00:04:07,269 --> 00:04:12,710
some new collections so specifically

00:04:10,810 --> 00:04:16,040
I'll talk about one

00:04:12,710 --> 00:04:17,270
cholera deaths this is a new collection

00:04:16,040 --> 00:04:20,150
in Scala 2:13

00:04:17,270 --> 00:04:21,830
it's a mutable collection some people in

00:04:20,150 --> 00:04:25,730
the literature also refer to as a

00:04:21,830 --> 00:04:28,040
circularbuffer so it can serve as a

00:04:25,730 --> 00:04:31,700
replacement for most mutable collections

00:04:28,040 --> 00:04:34,220
and it's faster than an array buffer

00:04:31,700 --> 00:04:35,810
when used as an array and it's faster

00:04:34,220 --> 00:04:39,340
than a linked list when used as a linked

00:04:35,810 --> 00:04:41,750
list in almost all the operations

00:04:39,340 --> 00:04:50,990
there's also my first contribution to

00:04:41,750 --> 00:04:56,000
actual Scala so so a little data

00:04:50,990 --> 00:04:58,160
structure is 101 so as you know there

00:04:56,000 --> 00:05:00,850
are two big flavors of linear data

00:04:58,160 --> 00:05:03,410
structures arrays and linked lists

00:05:00,850 --> 00:05:05,330
arrays have this nice property that you

00:05:03,410 --> 00:05:07,040
can do random indexing if you have a

00:05:05,330 --> 00:05:09,320
million items you can index into the

00:05:07,040 --> 00:05:12,290
100th I Emma ten millionth item in

00:05:09,320 --> 00:05:13,850
constant time you can update the ayat

00:05:12,290 --> 00:05:18,470
item in constant time so that's random

00:05:13,850 --> 00:05:20,780
indexing but prepending to an array is

00:05:18,470 --> 00:05:23,450
not constant time it's linear because

00:05:20,780 --> 00:05:25,160
when you put something in the head of

00:05:23,450 --> 00:05:27,440
the array you have to ship everything

00:05:25,160 --> 00:05:30,680
else to the right and there you go your

00:05:27,440 --> 00:05:32,660
runtime is linear if you have a linked

00:05:30,680 --> 00:05:35,740
list it's kind of the dual of the array

00:05:32,660 --> 00:05:37,910
in that sense where you don't have a

00:05:35,740 --> 00:05:39,770
constant time random indexing because

00:05:37,910 --> 00:05:41,540
you only have a start pointer and maybe

00:05:39,770 --> 00:05:45,170
an end pointer and you have to traverse

00:05:41,540 --> 00:05:48,830
and find the 100 element or the million

00:05:45,170 --> 00:05:50,870
in a million items but prepends and

00:05:48,830 --> 00:05:54,170
appends are constant time because you

00:05:50,870 --> 00:05:55,760
can simply do change where the pointers

00:05:54,170 --> 00:05:58,010
are pointing and you can in quickly

00:05:55,760 --> 00:05:59,540
insert things if you actually have a

00:05:58,010 --> 00:06:02,780
pointer to the middle of the linked list

00:05:59,540 --> 00:06:07,190
you could conceivably insert in constant

00:06:02,780 --> 00:06:10,730
time too and to make a distinction Scala

00:06:07,190 --> 00:06:12,620
lists is not a classical linked list

00:06:10,730 --> 00:06:14,240
because it's implemented as a consulate

00:06:12,620 --> 00:06:17,600
but that's an implementation detail but

00:06:14,240 --> 00:06:19,820
in general we have to make this

00:06:17,600 --> 00:06:22,410
distinction of choosing arrays of linked

00:06:19,820 --> 00:06:23,740
lists for mutable data structures when

00:06:22,410 --> 00:06:26,450
[Music]

00:06:23,740 --> 00:06:27,800
when you you can't have best of both

00:06:26,450 --> 00:06:29,330
worlds you cannot have constant and

00:06:27,800 --> 00:06:32,210
random index ena and but also have

00:06:29,330 --> 00:06:35,720
constant time deletes from the beginning

00:06:32,210 --> 00:06:38,360
or prepense to the beginning so this is

00:06:35,720 --> 00:06:40,970
the chart I would like to point you

00:06:38,360 --> 00:06:45,580
point out to so array decks exist in

00:06:40,970 --> 00:06:49,430
Java standard collections since Java 7

00:06:45,580 --> 00:06:51,590
but it has couple of things that are

00:06:49,430 --> 00:06:55,580
slightly inferior to the one that is now

00:06:51,590 --> 00:06:57,320
in Scala 213 one the actual random

00:06:55,580 --> 00:07:00,950
indexing is for whatever reason is a

00:06:57,320 --> 00:07:03,650
private method in the Java one so they

00:07:00,950 --> 00:07:08,240
could have and it is Oh one but it's

00:07:03,650 --> 00:07:10,639
just private so I don't know why that's

00:07:08,240 --> 00:07:13,550
like long chain of discussion why I

00:07:10,639 --> 00:07:16,389
don't understand why that it makes sense

00:07:13,550 --> 00:07:20,570
another thing is the insert and deletes

00:07:16,389 --> 00:07:24,889
for a array deck implemented correctly

00:07:20,570 --> 00:07:27,650
can be made faster if error inserts and

00:07:24,889 --> 00:07:30,050
deletes happen at the eyath index so the

00:07:27,650 --> 00:07:31,940
way there ones in at least in the Oracle

00:07:30,050 --> 00:07:36,350
and the open JDK is implemented it's

00:07:31,940 --> 00:07:39,169
actually linear runtime the one in the

00:07:36,350 --> 00:07:41,630
scala 2.13 is actually if you want to

00:07:39,169 --> 00:07:45,410
insert some element at the eye at index

00:07:41,630 --> 00:07:47,240
is actually men of I and n minus I so if

00:07:45,410 --> 00:07:49,070
you're in if you have 10 million items

00:07:47,240 --> 00:07:52,280
and inserting on the thirty-third cell

00:07:49,070 --> 00:07:54,229
it's not gonna actually move 10 million

00:07:52,280 --> 00:07:56,090
items somewhere it will actually move

00:07:54,229 --> 00:07:59,210
only the smallest possible chunk in this

00:07:56,090 --> 00:08:03,200
case the 33 items left so yeah

00:07:59,210 --> 00:08:05,570
toward recap so apply get random

00:08:03,200 --> 00:08:09,830
indexing random index update append

00:08:05,570 --> 00:08:12,560
prepend delete first delete last install

00:08:09,830 --> 00:08:15,260
constant time and insert and delete at

00:08:12,560 --> 00:08:18,080
arbitrary indexes are men of the index

00:08:15,260 --> 00:08:19,400
it's and they end - it's a min of the

00:08:18,080 --> 00:08:23,570
distance of the index from the start at

00:08:19,400 --> 00:08:27,760
the end all right so why are they called

00:08:23,570 --> 00:08:30,500
array decks not array DQ's so some

00:08:27,760 --> 00:08:33,270
English I learned so DQ is actually the

00:08:30,500 --> 00:08:36,450
verb to

00:08:33,270 --> 00:08:38,880
say that you are dequeuing something and

00:08:36,450 --> 00:08:40,740
array that's is not array DQ because

00:08:38,880 --> 00:08:42,959
it's actually an acronym it's an acronym

00:08:40,740 --> 00:08:49,170
for array double-ended queue so that's

00:08:42,959 --> 00:08:51,980
what I read XR and this is a very

00:08:49,170 --> 00:08:55,980
vanilla implementation of an array deck

00:08:51,980 --> 00:08:57,480
it the way it's implemented is you

00:08:55,980 --> 00:09:00,209
basically have a classical array

00:08:57,480 --> 00:09:04,709
underneath and you have start and end

00:09:00,209 --> 00:09:07,620
pointers which point to instead of in a

00:09:04,709 --> 00:09:09,270
classic array you start is the zero and

00:09:07,620 --> 00:09:12,779
your end is wherever the size of the

00:09:09,270 --> 00:09:14,279
array is in red X the start could be

00:09:12,779 --> 00:09:17,399
anywhere in the array and end could be

00:09:14,279 --> 00:09:21,450
anywhere else in the array and the way

00:09:17,399 --> 00:09:24,600
to to get an element or update an

00:09:21,450 --> 00:09:27,120
element you at the I at index you add it

00:09:24,600 --> 00:09:29,640
to the start pointer and you do module

00:09:27,120 --> 00:09:31,200
modular arithmetic on the length of the

00:09:29,640 --> 00:09:35,100
array so that you don't overrun and

00:09:31,200 --> 00:09:38,820
that's how you index so you basically

00:09:35,100 --> 00:09:41,880
offset from the start index I'll have a

00:09:38,820 --> 00:09:43,610
better demo of this after this slide so

00:09:41,880 --> 00:09:49,200
don't worry too much about it

00:09:43,610 --> 00:09:51,750
so what about append I before I

00:09:49,200 --> 00:09:55,230
obviously this is constant time because

00:09:51,750 --> 00:09:59,550
this is just math we are doing to index

00:09:55,230 --> 00:10:01,500
into an array append so we have constant

00:09:59,550 --> 00:10:03,540
temp and because what you can do is you

00:10:01,500 --> 00:10:05,670
can simply add an element and increment

00:10:03,540 --> 00:10:10,320
the end pointer and again we're doing

00:10:05,670 --> 00:10:11,730
modular arithmetic here prepend so this

00:10:10,320 --> 00:10:13,829
is the interesting one because this is

00:10:11,730 --> 00:10:16,529
the one that is not a constant time in

00:10:13,829 --> 00:10:20,070
arrays so in for prepend you can simply

00:10:16,529 --> 00:10:22,770
decrement the start pointer and update

00:10:20,070 --> 00:10:28,050
the element over there I hope you still

00:10:22,770 --> 00:10:30,450
convinced that doing this still keeps

00:10:28,050 --> 00:10:32,399
the update and apply semantics correct

00:10:30,450 --> 00:10:35,430
and constant time and we still have

00:10:32,399 --> 00:10:36,290
constant time append apply a pendant

00:10:35,430 --> 00:10:38,730
repent

00:10:36,290 --> 00:10:40,470
similarly delete last is trivial you

00:10:38,730 --> 00:10:43,140
just move the end pointer back delete

00:10:40,470 --> 00:10:45,390
first is also easy you move the start

00:10:43,140 --> 00:10:47,910
pointer to the right

00:10:45,390 --> 00:10:51,060
Claire you set the start and end point

00:10:47,910 --> 00:10:54,360
her to the same location and size is

00:10:51,060 --> 00:10:57,029
kind of cute it's end - start again

00:10:54,360 --> 00:10:59,990
everything is done modulo n where n is

00:10:57,029 --> 00:11:02,450
the size of the underlying array and

00:10:59,990 --> 00:11:04,440
obviously this is not the real

00:11:02,450 --> 00:11:08,519
implementation because it doesn't handle

00:11:04,440 --> 00:11:10,519
resizing it doesn't handle slicing and

00:11:08,519 --> 00:11:12,959
all the other operations but this is a

00:11:10,519 --> 00:11:16,050
proof of concept implementation that

00:11:12,959 --> 00:11:20,550
would work to better understand using a

00:11:16,050 --> 00:11:22,500
diagram this is how the an array deck

00:11:20,550 --> 00:11:25,170
looks like when you instantiate an empty

00:11:22,500 --> 00:11:27,959
one you have a start and end pointers

00:11:25,170 --> 00:11:34,050
they both point to zero so in this case

00:11:27,959 --> 00:11:35,940
I'm allocating a car array deck and it

00:11:34,050 --> 00:11:37,890
yellow Kate's a small character array

00:11:35,940 --> 00:11:41,399
which is which all has nulls in it

00:11:37,890 --> 00:11:44,880
so what happens when you append a 1

00:11:41,399 --> 00:11:49,740
append a single element so then we

00:11:44,880 --> 00:11:51,089
increment the and we insert it at the

00:11:49,740 --> 00:11:53,640
start element and increment the end

00:11:51,089 --> 00:11:56,130
pointer so the invariant is that the end

00:11:53,640 --> 00:11:58,110
pointers and end is now 1 start is still

00:11:56,130 --> 00:12:01,560
0 the end always points to the cell that

00:11:58,110 --> 00:12:02,880
is fillable next and start always points

00:12:01,560 --> 00:12:07,019
to the first element that is actually

00:12:02,880 --> 00:12:09,449
occupied okay spend a B you know you see

00:12:07,019 --> 00:12:11,130
start goes to 2 and your array is

00:12:09,449 --> 00:12:13,500
throwing up with 0 - and this is

00:12:11,130 --> 00:12:14,610
actually the indices of the array attack

00:12:13,500 --> 00:12:21,120
and this is the indices of the

00:12:14,610 --> 00:12:24,300
underlying array so ok C D E so this is

00:12:21,120 --> 00:12:25,980
interesting so I called so this is what

00:12:24,300 --> 00:12:28,320
it looks like after inserted e so the

00:12:25,980 --> 00:12:31,769
first five elements in both the

00:12:28,320 --> 00:12:34,589
underlying array and the expose API are

00:12:31,769 --> 00:12:36,690
ABCDE but what would happen when I try

00:12:34,589 --> 00:12:38,850
to call remove head I mean this case

00:12:36,690 --> 00:12:43,320
remove head option because it will

00:12:38,850 --> 00:12:45,120
return none if it's empty would return

00:12:43,320 --> 00:12:50,250
the first element in this case a and

00:12:45,120 --> 00:12:55,050
increment the start pointer so yeah so

00:12:50,250 --> 00:12:58,199
remove head option returns a and now the

00:12:55,050 --> 00:12:59,040
start is 1 and is 5 your array still

00:12:58,199 --> 00:13:00,750
looks like the

00:12:59,040 --> 00:13:02,880
so your air attack still looks like this

00:13:00,750 --> 00:13:05,940
your 0th element is B if you do dot

00:13:02,880 --> 00:13:08,610
apply B or dot get so dot apply 0 or dot

00:13:05,940 --> 00:13:11,160
get 0 it will return correctly the first

00:13:08,610 --> 00:13:13,860
element which is now B even though we

00:13:11,160 --> 00:13:18,780
did a remove head optional remove head

00:13:13,860 --> 00:13:25,860
operation so yeah we just remove headers

00:13:18,780 --> 00:13:28,290
or one and apply still oh one so so

00:13:25,860 --> 00:13:32,580
again we're doing a remove head again it

00:13:28,290 --> 00:13:34,920
removes it pops of B it pops up B now

00:13:32,580 --> 00:13:37,650
we're doing a preprint so at this state

00:13:34,920 --> 00:13:40,230
in the array the start is at four end is

00:13:37,650 --> 00:13:42,360
at five and we're doing a prepend so

00:13:40,230 --> 00:13:47,690
what prepend does it decrements the

00:13:42,360 --> 00:13:52,500
start pointer and fills Excel up and

00:13:47,690 --> 00:13:55,350
yeah so I'm not going to walk through it

00:13:52,500 --> 00:13:59,360
every step but you get the idea so this

00:13:55,350 --> 00:14:03,260
fills up so now the array is almost full

00:13:59,360 --> 00:14:08,580
and we want to insert one more element

00:14:03,260 --> 00:14:11,190
and doing some more work right so this

00:14:08,580 --> 00:14:14,220
is the I'm demoing that if you do it a

00:14:11,190 --> 00:14:16,380
move head option and start and end are

00:14:14,220 --> 00:14:18,540
the same so this is the condition when

00:14:16,380 --> 00:14:20,040
the size of the array is empty which is

00:14:18,540 --> 00:14:23,730
n minus start and they don't necessarily

00:14:20,040 --> 00:14:25,200
have to point to 0 because 4 depending

00:14:23,730 --> 00:14:26,670
on your sequence of operations you could

00:14:25,200 --> 00:14:28,200
end up with it just start and end

00:14:26,670 --> 00:14:30,570
pointing to any arbitrary place in the

00:14:28,200 --> 00:14:33,360
array so you do a remove head option you

00:14:30,570 --> 00:14:38,370
get nan back all right we're gonna

00:14:33,360 --> 00:14:40,880
append so the array is almost full and

00:14:38,370 --> 00:14:46,370
we want to append some more elements and

00:14:40,880 --> 00:14:46,370
it resizes see

00:14:47,240 --> 00:14:55,009
right it resizes it goes from eight to

00:14:51,980 --> 00:14:58,699
sixteen elements and this resize is

00:14:55,009 --> 00:15:02,420
incredibly efficient during the resize

00:14:58,699 --> 00:15:05,269
operation it will at most do two mem

00:15:02,420 --> 00:15:07,939
copies it if end is greater than start

00:15:05,269 --> 00:15:11,720
it would just select that slice of

00:15:07,939 --> 00:15:14,600
memory from start to end and put it in

00:15:11,720 --> 00:15:17,209
the new array of double the size or if

00:15:14,600 --> 00:15:20,269
and if this is a wraparound case it will

00:15:17,209 --> 00:15:26,949
mem copy from start to the end and from

00:15:20,269 --> 00:15:30,050
end to the last element this is uses

00:15:26,949 --> 00:15:32,179
Java's array dot copy which in most

00:15:30,050 --> 00:15:34,220
systems actually is a mem copy so this

00:15:32,179 --> 00:15:38,410
is really fast so you don't actually go

00:15:34,220 --> 00:15:42,259
one by one fill up the cells so yeah we

00:15:38,410 --> 00:15:49,939
resized and some more operations append

00:15:42,259 --> 00:15:55,639
prepend x' so and so forth by appending

00:15:49,939 --> 00:16:00,649
more cells and yeah so now we want to

00:15:55,639 --> 00:16:02,959
call Claire so again what what Claire

00:16:00,649 --> 00:16:06,529
does it simply sets this start to the

00:16:02,959 --> 00:16:10,009
end so when I call this you it start an

00:16:06,529 --> 00:16:13,009
end at 17-17 but there is actually a

00:16:10,009 --> 00:16:14,809
currently a bug you need to actually go

00:16:13,009 --> 00:16:16,459
and clear out all the cells because else

00:16:14,809 --> 00:16:19,670
you'd be holding references to the

00:16:16,459 --> 00:16:24,649
memory and that's a bug that actually

00:16:19,670 --> 00:16:26,629
exists in even in current scholar

00:16:24,649 --> 00:16:29,629
collections and mutable collections but

00:16:26,629 --> 00:16:34,040
if you call Claire it will actually hold

00:16:29,629 --> 00:16:35,839
references unless interesting that they

00:16:34,040 --> 00:16:39,589
array the mutable references itself is

00:16:35,839 --> 00:16:41,269
thrown away but so here the way to do it

00:16:39,589 --> 00:16:44,089
is okay you set start to end and you

00:16:41,269 --> 00:16:47,029
have to actually do another mem copy or

00:16:44,089 --> 00:16:50,689
mem set to fill up the array with now so

00:16:47,029 --> 00:16:54,740
you don't actually hold references but

00:16:50,689 --> 00:16:57,199
you see there's a problem we we started

00:16:54,740 --> 00:17:00,180
out with an array of size 8 and we hit

00:16:57,199 --> 00:17:03,810
Claire and we're stuck with this

00:17:00,180 --> 00:17:06,870
to size array so this is a memory leak

00:17:03,810 --> 00:17:09,809
and it's not clear which API should we

00:17:06,870 --> 00:17:11,370
resize it down or imagine have a million

00:17:09,809 --> 00:17:13,500
items and you call clear on a mutable

00:17:11,370 --> 00:17:14,880
collection should we resize it down to

00:17:13,500 --> 00:17:16,579
eight items because what if you wanted

00:17:14,880 --> 00:17:20,819
to start adding things again you need to

00:17:16,579 --> 00:17:23,640
regrow the collection it's not clear

00:17:20,819 --> 00:17:26,790
which one is the correct so in so there

00:17:23,640 --> 00:17:29,670
are two api's now and 2.13 array decks

00:17:26,790 --> 00:17:31,350
you can call clear which does not resize

00:17:29,670 --> 00:17:32,760
the collection so this is imagine for a

00:17:31,350 --> 00:17:35,640
use case where your collection is

00:17:32,760 --> 00:17:38,309
growing in unpredictable ways resizing

00:17:35,640 --> 00:17:41,880
so you don't want to repeatedly allocate

00:17:38,309 --> 00:17:43,679
8 16 32 64 so on and so forth but if you

00:17:41,880 --> 00:17:47,370
do actually know the OU's case like hey

00:17:43,679 --> 00:17:50,130
I want to clear out I go back to the

00:17:47,370 --> 00:17:52,770
original default size there's a new API

00:17:50,130 --> 00:17:58,200
called clear and shrink so this would

00:17:52,770 --> 00:18:01,380
actually this would actually shrink it

00:17:58,200 --> 00:18:08,850
back to as if it was the initial empty

00:18:01,380 --> 00:18:16,410
array call so that's all the diagrams I

00:18:08,850 --> 00:18:19,290
had okay so yeah if you look at the

00:18:16,410 --> 00:18:23,910
actual source code of a ready deck it's

00:18:19,290 --> 00:18:26,340
this is much longer than those cute 20

00:18:23,910 --> 00:18:31,380
lines I presented and there are reasons

00:18:26,340 --> 00:18:34,770
for that one is as I mentioned we

00:18:31,380 --> 00:18:37,920
optimized almost all the operations in

00:18:34,770 --> 00:18:40,320
by using array dot copy which is a mem

00:18:37,920 --> 00:18:44,670
copy underneath which is fast on most

00:18:40,320 --> 00:18:47,760
CPUs so if you insert at the eyath index

00:18:44,670 --> 00:18:51,210
we as I said before we figure out the

00:18:47,760 --> 00:18:52,500
most the smallest chunk to move and we

00:18:51,210 --> 00:18:56,160
do that

00:18:52,500 --> 00:18:59,010
clone again that's that it is you is

00:18:56,160 --> 00:19:03,720
using at most to array copies all these

00:18:59,010 --> 00:19:06,960
slice operations are using array copies

00:19:03,720 --> 00:19:10,770
at most two array copies to achieve all

00:19:06,960 --> 00:19:14,369
this and this needs a lot of typical

00:19:10,770 --> 00:19:18,090
incorrect pointer array copy

00:19:14,369 --> 00:19:21,450
chord which that long called is another

00:19:18,090 --> 00:19:22,950
thing that we do to make it fast is to

00:19:21,450 --> 00:19:24,869
do pre-emptive allocations of the

00:19:22,950 --> 00:19:27,690
correct size so imagine if you have a

00:19:24,869 --> 00:19:32,029
mutable array deck of size hundred and

00:19:27,690 --> 00:19:34,229
you're inserting ten million items as

00:19:32,029 --> 00:19:35,909
implemented that as the scholar

00:19:34,229 --> 00:19:37,379
interfaces has the default

00:19:35,909 --> 00:19:39,960
implementation it goes one by one

00:19:37,379 --> 00:19:43,889
inserting so you do repeated resizing

00:19:39,960 --> 00:19:46,589
your recess 228 then you resize to 256

00:19:43,889 --> 00:19:49,589
and so on and so forth but you could do

00:19:46,589 --> 00:19:51,690
better if you if your right side is not

00:19:49,589 --> 00:19:53,669
a traversable once you can traverse it

00:19:51,690 --> 00:19:55,080
twice to figure out the size or if it

00:19:53,669 --> 00:19:57,349
has all one size you don't even need to

00:19:55,080 --> 00:20:00,179
traverse it and you can preemptively

00:19:57,349 --> 00:20:02,460
allocate the array the underlying array

00:20:00,179 --> 00:20:05,249
of the correct size and just do a

00:20:02,460 --> 00:20:07,469
leather mem copy from the traversable

00:20:05,249 --> 00:20:10,409
that your pending or prepending to

00:20:07,469 --> 00:20:14,820
fulfill in that array and in effectively

00:20:10,409 --> 00:20:17,279
constant time another trick this is a

00:20:14,820 --> 00:20:20,339
really cute trick which is if your size

00:20:17,279 --> 00:20:23,639
of the array is a power of two you don't

00:20:20,339 --> 00:20:26,339
actually need to do mod modulus using

00:20:23,639 --> 00:20:28,710
the mod operator you can actually use a

00:20:26,339 --> 00:20:33,509
bit trick so and it's a power of two

00:20:28,710 --> 00:20:42,839
then I mod n is actually I bet bet and

00:20:33,509 --> 00:20:44,759
with n minus one so this is cute so

00:20:42,839 --> 00:20:50,279
these are some benchmarks

00:20:44,759 --> 00:20:54,200
I have I'll point to a github repo which

00:20:50,279 --> 00:20:57,179
actually has slides of gifts of

00:20:54,200 --> 00:21:00,749
operations benchmarks comparing array

00:20:57,179 --> 00:21:06,210
buffer lists buffer and array decks with

00:21:00,749 --> 00:21:08,339
the size of the array as one one axis in

00:21:06,210 --> 00:21:12,719
almost all cases array decks are

00:21:08,339 --> 00:21:15,929
incredibly faster the prepend as you can

00:21:12,719 --> 00:21:20,190
see it's a millisecond in array decks

00:21:15,929 --> 00:21:23,190
and the same operation takes ten seconds

00:21:20,190 --> 00:21:25,769
on nine seconds in array buffers because

00:21:23,190 --> 00:21:27,529
of this trick and this this this is

00:21:25,769 --> 00:21:32,809
obviously

00:21:27,529 --> 00:21:36,450
averages of some benchmarks that I ran

00:21:32,809 --> 00:21:39,480
which looks at various hour with just

00:21:36,450 --> 00:21:42,330
some various random operations the only

00:21:39,480 --> 00:21:44,399
thing that is slower is the random

00:21:42,330 --> 00:21:46,139
indexing is slightly slower because in

00:21:44,399 --> 00:21:48,330
array buffers you can actually just

00:21:46,139 --> 00:21:50,309
random index here you are doing some

00:21:48,330 --> 00:21:52,739
modular arithmetic you are adding the

00:21:50,309 --> 00:21:54,929
index to the start and then doing mod so

00:21:52,739 --> 00:22:02,039
but I don't think anyone would ever

00:21:54,929 --> 00:22:04,980
notice that so I would also like to give

00:22:02,039 --> 00:22:08,999
a shout-out to this rough tree library I

00:22:04,980 --> 00:22:11,249
used that to generate that diagrams I

00:22:08,999 --> 00:22:14,820
didn't actually spend hours making those

00:22:11,249 --> 00:22:17,999
images I wrote code to generate those

00:22:14,820 --> 00:22:19,919
images so it's really cool library this

00:22:17,999 --> 00:22:22,739
is all the code that I had to write to

00:22:19,919 --> 00:22:25,889
generate those images which is pretty

00:22:22,739 --> 00:22:27,929
cool it has it comes with little utils

00:22:25,889 --> 00:22:30,809
which gives you access to the private

00:22:27,929 --> 00:22:33,269
fields of any data structure so here I'm

00:22:30,809 --> 00:22:36,210
getting out the array the start and the

00:22:33,269 --> 00:22:38,789
end indices and and then I can choose

00:22:36,210 --> 00:22:40,529
how to render it and it and then I just

00:22:38,789 --> 00:22:43,259
do my sequence of operations and call

00:22:40,529 --> 00:22:46,710
render and it renders the and it

00:22:43,259 --> 00:22:49,019
generates those pngs for you the sort

00:22:46,710 --> 00:22:51,480
this source code is I will have a link

00:22:49,019 --> 00:22:55,470
to it it's on get help so and you can

00:22:51,480 --> 00:23:00,570
check it out after the talk so some

00:22:55,470 --> 00:23:02,999
takeaways please contribute I I part

00:23:00,570 --> 00:23:05,100
country contributing to Scala is you

00:23:02,999 --> 00:23:07,590
know kind of cool and scary but now I

00:23:05,100 --> 00:23:14,159
think it's just cool not scary anymore

00:23:07,590 --> 00:23:15,989
it's it it's it's way more accepting of

00:23:14,159 --> 00:23:17,580
new code contributions than any some

00:23:15,989 --> 00:23:19,019
other languages like Java I don't even

00:23:17,580 --> 00:23:22,259
know how to do that contribute anything

00:23:19,019 --> 00:23:23,850
to there and there's a lot of scope

00:23:22,259 --> 00:23:27,539
there's a lot of things to be that we

00:23:23,850 --> 00:23:29,909
can improve I love data structures and

00:23:27,539 --> 00:23:32,970
collections and that's where I found my

00:23:29,909 --> 00:23:35,730
way to contribute to Scala but please do

00:23:32,970 --> 00:23:38,340
and since we have a major version change

00:23:35,730 --> 00:23:41,520
coming up there are things you can do

00:23:38,340 --> 00:23:45,220
more influence than others

00:23:41,520 --> 00:23:47,890
in general I think their structures are

00:23:45,220 --> 00:23:50,230
cooler than algorithms the reason being

00:23:47,890 --> 00:23:54,280
that is incredibly hard to write a

00:23:50,230 --> 00:23:55,510
general-purpose library where which has

00:23:54,280 --> 00:23:57,820
algorithms which everyone can use

00:23:55,510 --> 00:24:00,040
because everyone needs some custom use

00:23:57,820 --> 00:24:01,630
case but data structures you can write

00:24:00,040 --> 00:24:03,490
in a generic way and make it a library

00:24:01,630 --> 00:24:05,830
that people would be able to use specced

00:24:03,490 --> 00:24:07,060
specially since the Scala standard

00:24:05,830 --> 00:24:09,990
library gives you interfaces like

00:24:07,060 --> 00:24:12,580
traversable z' and sorry iterables and

00:24:09,990 --> 00:24:15,010
map like so you just have to implement

00:24:12,580 --> 00:24:18,790
them and add maybe add some few new

00:24:15,010 --> 00:24:21,340
methods and well I you have some new

00:24:18,790 --> 00:24:22,990
data structures and there are a lot of

00:24:21,340 --> 00:24:25,360
cool data structures out there I read X

00:24:22,990 --> 00:24:27,100
was the contribution Institute 13 but

00:24:25,360 --> 00:24:28,990
you can check out a lot of functional

00:24:27,100 --> 00:24:30,220
data structures or even non-functional

00:24:28,990 --> 00:24:34,840
data structures from your algorithms

00:24:30,220 --> 00:24:36,730
class visualize your code as a point as

00:24:34,840 --> 00:24:39,310
I said the ref tree library is really

00:24:36,730 --> 00:24:41,980
cool you can write 20 lines

00:24:39,310 --> 00:24:44,320
it comes with visualizations for any

00:24:41,980 --> 00:24:45,790
case classes any data structures or you

00:24:44,320 --> 00:24:47,860
can write custom ones like the one I did

00:24:45,790 --> 00:24:50,710
at 50 lines of code and it generates

00:24:47,860 --> 00:24:53,650
beautiful animation which makes for good

00:24:50,710 --> 00:24:55,540
presentation and yeah scholar 2.13 is

00:24:53,650 --> 00:24:57,130
around the corner please check it out if

00:24:55,540 --> 00:25:00,220
you're a library author try building

00:24:57,130 --> 00:25:02,860
against it and see where that goes

00:25:00,220 --> 00:25:06,400
else yeah just try it out in a small

00:25:02,860 --> 00:25:08,770
sample project so that's that's my talk

00:25:06,400 --> 00:25:10,240
that's the link you can check out the

00:25:08,770 --> 00:25:12,220
source code to generate the

00:25:10,240 --> 00:25:14,950
visualizations you can check out the

00:25:12,220 --> 00:25:16,690
source code it actually has a minimal

00:25:14,950 --> 00:25:19,090
implementation of array decks that you

00:25:16,690 --> 00:25:25,030
can drop into your scholar code today in

00:25:19,090 --> 00:25:32,580
211 or 210 or 212 it also has the

00:25:25,030 --> 00:25:32,580
benchmark code yeah one last thing is

00:25:32,850 --> 00:25:38,080
this is the recruiting slide we're

00:25:35,200 --> 00:25:41,110
hiring I work at a hedge fund located

00:25:38,080 --> 00:25:43,120
two blocks away we do a lot of quant

00:25:41,110 --> 00:25:44,710
rating data science functional

00:25:43,120 --> 00:25:47,710
programming Scala spark if you

00:25:44,710 --> 00:25:51,790
interested come talk to me or send me an

00:25:47,710 --> 00:25:53,650
email at this address but yeah that's it

00:25:51,790 --> 00:25:56,890
for now

00:25:53,650 --> 00:25:59,860
if you have any questions the question

00:25:56,890 --> 00:26:02,440
was who how more about the benchmarks

00:25:59,860 --> 00:26:05,680
what was it benchmarking so there were

00:26:02,440 --> 00:26:09,100
the benchmark was doing fuzzy operations

00:26:05,680 --> 00:26:11,500
like starting with an empty array or a

00:26:09,100 --> 00:26:13,809
small array of size hundred and doing a

00:26:11,500 --> 00:26:15,940
lot of random deletes and insert and

00:26:13,809 --> 00:26:18,000
prepends and then doing an append and

00:26:15,940 --> 00:26:22,000
growing it up to a size of 10 million

00:26:18,000 --> 00:26:23,950
and taking averages on the way up for

00:26:22,000 --> 00:26:25,929
both for all the data structures

00:26:23,950 --> 00:26:29,980
involved and running it over and over

00:26:25,929 --> 00:26:31,240
and doing a JVM warm-up before and the

00:26:29,980 --> 00:26:34,780
default implementation

00:26:31,240 --> 00:26:37,630
I believe starts with the internal if

00:26:34,780 --> 00:26:42,760
you create an empty one in Scala 2.13 it

00:26:37,630 --> 00:26:47,290
allocates a size 16 underneath and

00:26:42,760 --> 00:26:49,000
that's the one Java 8 allocates I think

00:26:47,290 --> 00:26:51,790
and I just used that default size I

00:26:49,000 --> 00:26:55,260
don't do too much research on that yeah

00:26:51,790 --> 00:26:58,690
the question is when you actually resize

00:26:55,260 --> 00:27:01,030
how long does it take I mean if you

00:26:58,690 --> 00:27:02,770
actually do the method for random

00:27:01,030 --> 00:27:04,809
sequence of operations you can actually

00:27:02,770 --> 00:27:07,150
mathematically prove that it's amortized

00:27:04,809 --> 00:27:10,570
constant time but to do the actual

00:27:07,150 --> 00:27:13,240
recess when you go from 128 to 256

00:27:10,570 --> 00:27:15,700
elements there are only three steps

00:27:13,240 --> 00:27:18,309
involved you need to do memory

00:27:15,700 --> 00:27:20,710
allocation of 256 elements and then you

00:27:18,309 --> 00:27:23,320
do a to mem copies so mem copies are

00:27:20,710 --> 00:27:24,910
mostly peers have very native

00:27:23,320 --> 00:27:26,860
instructions where you can say given

00:27:24,910 --> 00:27:29,290
this memory indices of start and end and

00:27:26,860 --> 00:27:31,960
these others started and memory indices

00:27:29,290 --> 00:27:34,540
copy this data sector data set there so

00:27:31,960 --> 00:27:37,660
the way array that's implemented you can

00:27:34,540 --> 00:27:40,179
do it using at most two mem copies most

00:27:37,660 --> 00:27:41,620
operations so if you actually check out

00:27:40,179 --> 00:27:44,020
the source code that's what all the

00:27:41,620 --> 00:27:48,570
operations do they just do mem to mem

00:27:44,020 --> 00:27:50,780
copies even for clone copy sliding slice

00:27:48,570 --> 00:27:54,080
the

00:27:50,780 --> 00:27:58,700
I forgot other app API they all do at

00:27:54,080 --> 00:28:00,800
most two mem copies including resize it

00:27:58,700 --> 00:28:04,160
always doubles that's a good heuristic

00:28:00,800 --> 00:28:05,780
that many other data structures use and

00:28:04,160 --> 00:28:11,320
it also makes the modular arithmetic

00:28:05,780 --> 00:28:16,680
very cute all right thank you

00:28:11,320 --> 00:28:16,680

YouTube URL: https://www.youtube.com/watch?v=I2zVN2GWYgg


