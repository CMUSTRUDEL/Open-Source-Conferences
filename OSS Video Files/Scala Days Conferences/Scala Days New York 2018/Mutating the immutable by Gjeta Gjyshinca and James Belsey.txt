Title: Mutating the immutable by Gjeta Gjyshinca and James Belsey
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/mutating-the-immutable--how-we-manage-change-in-large-scale-applications
Captions: 
	00:00:04,840 --> 00:00:11,389
thank you all for coming my name is

00:00:08,090 --> 00:00:13,820
Jetta and this is James James and I are

00:00:11,389 --> 00:00:16,699
part of a team at Morgan Stanley that

00:00:13,820 --> 00:00:19,300
has built a platform on which other

00:00:16,699 --> 00:00:21,470
developers across the bank can write

00:00:19,300 --> 00:00:26,359
applications to support the business

00:00:21,470 --> 00:00:28,699
directly our team also controls the

00:00:26,359 --> 00:00:31,730
runtime so that we ensure that these

00:00:28,699 --> 00:00:33,110
apps that the developers write can run

00:00:31,730 --> 00:00:35,570
in the way that developers want them to

00:00:33,110 --> 00:00:37,969
run so our clients are first and

00:00:35,570 --> 00:00:40,460
foremost other developers and our

00:00:37,969 --> 00:00:42,320
overarching aim is to build our platform

00:00:40,460 --> 00:00:43,789
in such a way that our developers can

00:00:42,320 --> 00:00:46,129
write the code that they want to write

00:00:43,789 --> 00:00:48,530
and to control the execution of that

00:00:46,129 --> 00:00:51,230
code so that it runs the way they want

00:00:48,530 --> 00:00:53,680
it to run so our developers get to focus

00:00:51,230 --> 00:00:56,719
on business logic without concern for

00:00:53,680 --> 00:00:59,390
parallelization or batched batching or

00:00:56,719 --> 00:01:01,969
caching or distribution or any other

00:00:59,390 --> 00:01:05,150
infrastructure the execution concerns

00:01:01,969 --> 00:01:10,160
don't pollute the type system and that's

00:01:05,150 --> 00:01:11,840
our main aim I am a developer on the

00:01:10,160 --> 00:01:14,330
core technology that we're presenting to

00:01:11,840 --> 00:01:15,920
you today so that covers a compiler plug

00:01:14,330 --> 00:01:18,260
in the scheduler and the cache and a

00:01:15,920 --> 00:01:20,500
load of other cool things and I joined

00:01:18,260 --> 00:01:23,510
the team about a year and a half ago

00:01:20,500 --> 00:01:25,310
James has been involved with the project

00:01:23,510 --> 00:01:28,030
since it began about seven years ago and

00:01:25,310 --> 00:01:31,550
I don't really know what he does all day

00:01:28,030 --> 00:01:33,470
but she has seen the project's grow into

00:01:31,550 --> 00:01:35,780
one of the biggest scarlet code bases in

00:01:33,470 --> 00:01:38,570
the world with over three million lines

00:01:35,780 --> 00:01:40,430
of code and more than 20,000 pull

00:01:38,570 --> 00:01:44,720
requests into our main branch by over

00:01:40,430 --> 00:01:47,150
500 active developers worldwide of those

00:01:44,720 --> 00:01:48,770
3 million lines of code about 60,000

00:01:47,150 --> 00:01:50,810
cover the core technology of the

00:01:48,770 --> 00:01:53,540
platform itself and the rest is

00:01:50,810 --> 00:01:57,730
application code built by developers on

00:01:53,540 --> 00:02:01,190
top of the platform and this ranges from

00:01:57,730 --> 00:02:04,400
trade to desktop applications to risk

00:02:01,190 --> 00:02:06,520
calculations that run at the end of

00:02:04,400 --> 00:02:10,310
every day or throughout the day

00:02:06,520 --> 00:02:13,719
and off of the 500 developers only about

00:02:10,310 --> 00:02:16,370
50 work on the core technology itself

00:02:13,719 --> 00:02:18,920
some of you here may have seen our first

00:02:16,370 --> 00:02:22,040
talk back in London in Schuyler exchange

00:02:18,920 --> 00:02:24,050
about six months ago and there we

00:02:22,040 --> 00:02:25,760
introduced our platform as a technology

00:02:24,050 --> 00:02:28,640
that could automatically parallelize

00:02:25,760 --> 00:02:30,050
user code but that wasn't the whole

00:02:28,640 --> 00:02:33,230
story and that's kind of why we're back

00:02:30,050 --> 00:02:34,340
again today doing another talk the

00:02:33,230 --> 00:02:37,040
problem is that we can't talk about

00:02:34,340 --> 00:02:38,870
parallelization or multi-threading

00:02:37,040 --> 00:02:40,220
without talking about thread safety and

00:02:38,870 --> 00:02:43,910
we can't talk about thread safety

00:02:40,220 --> 00:02:46,010
without talking about change as someone

00:02:43,910 --> 00:02:47,990
wise once said I forget the name some

00:02:46,010 --> 00:02:50,959
Greek guy change is the only constant

00:02:47,990 --> 00:02:52,790
and that means that as developers we

00:02:50,959 --> 00:02:55,640
have to deal with change do you hear

00:02:52,790 --> 00:02:58,790
music yeah that wasn't planned

00:02:55,640 --> 00:03:02,270
there's someone over there going on cool

00:02:58,790 --> 00:03:05,540
ok so as developers we have to deal with

00:03:02,270 --> 00:03:07,700
change and change is inevitable in any

00:03:05,540 --> 00:03:09,050
real system any long-running application

00:03:07,700 --> 00:03:11,090
that's live for more than like two

00:03:09,050 --> 00:03:13,190
seconds we have state and that state is

00:03:11,090 --> 00:03:15,800
immutable and the things that cause this

00:03:13,190 --> 00:03:18,410
change might be as simple as time

00:03:15,800 --> 00:03:20,420
ticking forwards or prices and

00:03:18,410 --> 00:03:23,660
temperatures fluctuating or users

00:03:20,420 --> 00:03:31,880
updating their preferences wow there's

00:03:23,660 --> 00:03:33,590
the music again oh you oh it's the other

00:03:31,880 --> 00:03:36,190
room oh you guys should all go there it

00:03:33,590 --> 00:03:36,190
sounds way more fun

00:03:36,430 --> 00:03:41,420
so yeah change can be caused by a lot of

00:03:39,560 --> 00:03:41,840
different things and we have to deal

00:03:41,420 --> 00:03:45,650
with it

00:03:41,840 --> 00:03:48,470
but our challenge is to use the benefits

00:03:45,650 --> 00:03:51,380
of immutable state in a multi-threaded

00:03:48,470 --> 00:03:53,750
environment but without forcing

00:03:51,380 --> 00:03:55,670
developers the ability to easily deal

00:03:53,750 --> 00:03:57,650
with change and without incurring some

00:03:55,670 --> 00:04:00,140
of the costs that different programming

00:03:57,650 --> 00:04:02,390
paradigms enforce on us when we try to

00:04:00,140 --> 00:04:07,160
deal with change and James is going to

00:04:02,390 --> 00:04:09,019
talk about that next just before I do

00:04:07,160 --> 00:04:11,120
there's lots of people standing up if

00:04:09,019 --> 00:04:12,830
can you switch to the middle if there's

00:04:11,120 --> 00:04:14,180
a seat to like to the middle of you can

00:04:12,830 --> 00:04:15,560
you just move in so that people can sit

00:04:14,180 --> 00:04:20,320
down there's like a bunch of seats down

00:04:15,560 --> 00:04:23,590
the front like yeah good idea

00:04:20,320 --> 00:04:23,590
thanks very much

00:04:28,639 --> 00:04:34,800
okay so I'm going to talk a little bit

00:04:32,130 --> 00:04:37,560
about how we manage change and I'm going

00:04:34,800 --> 00:04:42,319
to focus on the kind of two

00:04:37,560 --> 00:04:45,150
big programming paradigms procedural and

00:04:42,319 --> 00:04:46,919
subsequently functional so I first talk

00:04:45,150 --> 00:04:49,289
about dealing with change in procedural

00:04:46,919 --> 00:04:51,569
programs like when we mutate things in

00:04:49,289 --> 00:04:53,520
procedural programs like in single

00:04:51,569 --> 00:04:55,319
threaded procedural code things are

00:04:53,520 --> 00:04:56,819
actually quite nice right the the stack

00:04:55,319 --> 00:04:58,740
frame marches forward you can put

00:04:56,819 --> 00:05:00,900
breakpoints in the code they typically

00:04:58,740 --> 00:05:02,490
is highly repeatable if they're if there

00:05:00,900 --> 00:05:04,639
aren't threading concerns and that's

00:05:02,490 --> 00:05:07,110
really good in when you're trying to

00:05:04,639 --> 00:05:08,780
like find problems figure out how the

00:05:07,110 --> 00:05:12,300
state got into the state that it's in

00:05:08,780 --> 00:05:14,520
but with procedural programming when you

00:05:12,300 --> 00:05:17,340
introduce many threads and I don't know

00:05:14,520 --> 00:05:20,400
how many people of debug multi-threaded

00:05:17,340 --> 00:05:22,020
code you kind of work wind up in this

00:05:20,400 --> 00:05:23,220
thing where your mind is trying to track

00:05:22,020 --> 00:05:25,889
all these things that are happening

00:05:23,220 --> 00:05:27,960
simultaneously and it's really hard to

00:05:25,889 --> 00:05:30,030
find out sometimes like this how you got

00:05:27,960 --> 00:05:32,280
into a state that you got into and it's

00:05:30,030 --> 00:05:34,590
really difficult then also because you

00:05:32,280 --> 00:05:35,880
can't put breakpoints always in an

00:05:34,590 --> 00:05:37,380
individual thread because if you stop

00:05:35,880 --> 00:05:39,210
that thread from progressing it won't

00:05:37,380 --> 00:05:41,070
replicate the problem that you that

00:05:39,210 --> 00:05:43,039
you're trying to debug so you get into

00:05:41,070 --> 00:05:45,630
these kind of nasty situations with

00:05:43,039 --> 00:05:47,759
procedural programming and change where

00:05:45,630 --> 00:05:49,349
it can become like a bug hunt from hell

00:05:47,759 --> 00:05:52,680
and it takes a very long time to get to

00:05:49,349 --> 00:05:54,090
the bottom of a problem so procedural

00:05:52,680 --> 00:05:56,880
programming definitely hasn't nailed it

00:05:54,090 --> 00:05:58,919
I do want it before I move on to talk

00:05:56,880 --> 00:06:00,270
about functional programming just talk

00:05:58,919 --> 00:06:01,650
about the syntax it's like with

00:06:00,270 --> 00:06:04,770
procedural programming it's actually

00:06:01,650 --> 00:06:06,630
like very clean and simple like at the

00:06:04,770 --> 00:06:08,340
kind of change sites at the point where

00:06:06,630 --> 00:06:11,099
you make a change really easy to

00:06:08,340 --> 00:06:12,599
understand what's happening you know all

00:06:11,099 --> 00:06:13,680
the locking and all the message

00:06:12,599 --> 00:06:14,729
processing all the other things that go

00:06:13,680 --> 00:06:15,900
along with that and not easy to

00:06:14,729 --> 00:06:17,460
understand but the actual point where

00:06:15,900 --> 00:06:20,580
you make the change that's a very easy

00:06:17,460 --> 00:06:24,810
easy thing to understand so let's talk a

00:06:20,580 --> 00:06:26,520
bit about functional programming we want

00:06:24,810 --> 00:06:28,710
to kind of go through like two

00:06:26,520 --> 00:06:29,699
significant problems that you run into

00:06:28,710 --> 00:06:33,900
when you use the functional programming

00:06:29,699 --> 00:06:36,430
paradigm with and and you try and have

00:06:33,900 --> 00:06:38,320
change in your system so the first

00:06:36,430 --> 00:06:41,740
problem is it creates code that's hard

00:06:38,320 --> 00:06:43,420
to read and difficult to write and so to

00:06:41,740 --> 00:06:44,890
illustrate this we're going to bring

00:06:43,420 --> 00:06:47,380
back some code that we used in our first

00:06:44,890 --> 00:06:48,790
talk so people who saw our first talk in

00:06:47,380 --> 00:06:50,380
our first all we like paralyzed the

00:06:48,790 --> 00:06:51,490
execution of this code in this talk

00:06:50,380 --> 00:06:54,310
we're going to talk about how we deal

00:06:51,490 --> 00:06:56,080
with change or on this code so this is a

00:06:54,310 --> 00:06:58,240
pretty simple example and there are

00:06:56,080 --> 00:07:01,120
three classes and would create one of

00:06:58,240 --> 00:07:02,890
each so that'd be three objects the

00:07:01,120 --> 00:07:04,270
flight object creates a few context

00:07:02,890 --> 00:07:05,800
sorry the flight object contains a fuel

00:07:04,270 --> 00:07:08,260
cost object and fuel cost object

00:07:05,800 --> 00:07:11,110
contains an x-ray object it's a pretty

00:07:08,260 --> 00:07:13,360
simple ABC relationship but even this

00:07:11,110 --> 00:07:15,880
when you start to want to introduce

00:07:13,360 --> 00:07:18,250
change it's not straightforward the

00:07:15,880 --> 00:07:19,900
functional approach paradigm so in a

00:07:18,250 --> 00:07:22,990
functional paradigm you don't actually

00:07:19,900 --> 00:07:25,630
change anything you always create new so

00:07:22,990 --> 00:07:27,490
in that model if I want to for example

00:07:25,630 --> 00:07:29,860
change this rate variable inside of the

00:07:27,490 --> 00:07:31,420
inside of the FX rate like once I've

00:07:29,860 --> 00:07:33,160
created this thing I want to go in there

00:07:31,420 --> 00:07:37,660
and change it I have to write this kind

00:07:33,160 --> 00:07:39,160
of code so I have to create a new a and

00:07:37,660 --> 00:07:41,290
ubian and you see in this case it's a

00:07:39,160 --> 00:07:42,880
new flight and new fuel cost and a new

00:07:41,290 --> 00:07:44,620
FX rate and blonde those together and

00:07:42,880 --> 00:07:47,050
now I've got my new state which has got

00:07:44,620 --> 00:07:49,510
this one change in it now there are

00:07:47,050 --> 00:07:51,310
helpers for this people there are things

00:07:49,510 --> 00:07:52,960
like lenses and I've got an example here

00:07:51,310 --> 00:07:55,600
which shows how Len syntax isn't much

00:07:52,960 --> 00:07:57,700
it's much nicer but you still have this

00:07:55,600 --> 00:07:58,540
this isn't really like expressing the

00:07:57,700 --> 00:08:00,820
change that you're trying to make

00:07:58,540 --> 00:08:02,740
because you're manipulating the flight

00:08:00,820 --> 00:08:03,970
object which is really nothing to do

00:08:02,740 --> 00:08:06,520
with your light intend to change which

00:08:03,970 --> 00:08:09,210
is to change this FX rate right so so so

00:08:06,520 --> 00:08:11,530
so there's a kind of it's not a great

00:08:09,210 --> 00:08:15,010
for me from a programming usability

00:08:11,530 --> 00:08:16,690
perspective and the the other thing is

00:08:15,010 --> 00:08:18,310
that even though you can put these nice

00:08:16,690 --> 00:08:19,570
wrappers and help us around these things

00:08:18,310 --> 00:08:21,670
it doesn't change the underlying

00:08:19,570 --> 00:08:25,570
mechanics and I'll talk a bit about why

00:08:21,670 --> 00:08:27,400
that's problematic as well so I've also

00:08:25,570 --> 00:08:29,590
put up what be the simplest case where

00:08:27,400 --> 00:08:31,000
which is what I'd like to write but I

00:08:29,590 --> 00:08:33,820
but we don't have ways to write this

00:08:31,000 --> 00:08:38,560
kind of simply a simple thing so let's

00:08:33,820 --> 00:08:40,720
talk about the actual complexity that

00:08:38,560 --> 00:08:42,910
you encounter in a real system so I

00:08:40,720 --> 00:08:44,590
showed you three objects but really like

00:08:42,910 --> 00:08:46,840
real system they're like numerous

00:08:44,590 --> 00:08:49,380
objects so I've sort of made this coast

00:08:46,840 --> 00:08:52,590
slightly more complicated

00:08:49,380 --> 00:08:54,420
so now the flight contains an occupancy

00:08:52,590 --> 00:08:55,740
score and this occupancy score is

00:08:54,420 --> 00:08:57,360
something that airlines use quite a lot

00:08:55,740 --> 00:08:59,640
so that you know they'll work out you

00:08:57,360 --> 00:09:00,660
know is your is it more likely that

00:08:59,640 --> 00:09:02,280
people are going to hook onto this

00:09:00,660 --> 00:09:03,720
aeroplane you know depending on one

00:09:02,280 --> 00:09:06,090
people people have holidays and things

00:09:03,720 --> 00:09:08,070
like this but some occupancy schools are

00:09:06,090 --> 00:09:09,420
affected by exchange rates so for

00:09:08,070 --> 00:09:11,550
example like when the pound dollar

00:09:09,420 --> 00:09:13,170
exchange rate goes favorable to people

00:09:11,550 --> 00:09:14,190
from the UK like lots of people from LAN

00:09:13,170 --> 00:09:17,070
and get on a plane and come get shopping

00:09:14,190 --> 00:09:18,540
in New York right so so it's reasonable

00:09:17,070 --> 00:09:20,280
to assume that various things are

00:09:18,540 --> 00:09:22,950
affected by the FX rate not not just

00:09:20,280 --> 00:09:27,600
just just one thing so let's look at the

00:09:22,950 --> 00:09:30,780
object graph for that we do not have an

00:09:27,600 --> 00:09:33,570
art budget so I got my children to draw

00:09:30,780 --> 00:09:36,570
the art or the object graph but it's an

00:09:33,570 --> 00:09:38,250
accurate rendition the big object on the

00:09:36,570 --> 00:09:39,930
left there that's the that's the flight

00:09:38,250 --> 00:09:42,540
and then the flight contains the fuel

00:09:39,930 --> 00:09:44,010
cost and the and the occupancy score and

00:09:42,540 --> 00:09:47,220
the fuel cost and the aqua score both

00:09:44,010 --> 00:09:49,530
reference the FX rate but one that only

00:09:47,220 --> 00:09:50,970
one of them represent references the

00:09:49,530 --> 00:09:52,860
local price so you wind up with this

00:09:50,970 --> 00:09:55,380
kind of it's a pretty simple object

00:09:52,860 --> 00:09:57,360
graph right so let's talk about now what

00:09:55,380 --> 00:09:58,950
happens in this still relatively simple

00:09:57,360 --> 00:10:01,020
object graph if I want to change the FX

00:09:58,950 --> 00:10:03,660
rate right I have to do something like

00:10:01,020 --> 00:10:04,770
this so I got to create like I got to

00:10:03,660 --> 00:10:06,240
work out which of the new objects to

00:10:04,770 --> 00:10:07,350
create and then I have to actually

00:10:06,240 --> 00:10:08,970
create an interim variable cuz otherwise

00:10:07,350 --> 00:10:11,250
it's kind of hard to write and then I

00:10:08,970 --> 00:10:13,140
have to do this now you what you can do

00:10:11,250 --> 00:10:15,180
is if you if you want to follow the

00:10:13,140 --> 00:10:16,890
functional parrot paradigm is you can

00:10:15,180 --> 00:10:18,270
kind of contort your object model so

00:10:16,890 --> 00:10:20,190
that you you mostly deal with direct

00:10:18,270 --> 00:10:21,810
like a directed graph so that then you

00:10:20,190 --> 00:10:23,580
can always use the lens type construct

00:10:21,810 --> 00:10:25,800
but then it's kind of the you know the

00:10:23,580 --> 00:10:27,120
code that you've got above there that's

00:10:25,800 --> 00:10:29,010
kind of nice to read because it's a good

00:10:27,120 --> 00:10:31,140
representation of the business problem

00:10:29,010 --> 00:10:33,930
that you're trying to solve so that's

00:10:31,140 --> 00:10:37,500
not great either so in terms of express

00:10:33,930 --> 00:10:39,090
ability it can be hard to create code

00:10:37,500 --> 00:10:40,290
that's easy to read and expresses the

00:10:39,090 --> 00:10:42,090
problem that you're trying to solve and

00:10:40,290 --> 00:10:43,560
I also gotten to draw this picture just

00:10:42,090 --> 00:10:45,660
to light represent what really happens

00:10:43,560 --> 00:10:47,070
in a real system and so you know you can

00:10:45,660 --> 00:10:50,070
imagine that what I want to change the

00:10:47,070 --> 00:10:51,690
value of one of these light orbs it's a

00:10:50,070 --> 00:10:52,830
big deal and I can there's a lot of code

00:10:51,690 --> 00:10:55,830
that's involved in that it's hard to

00:10:52,830 --> 00:10:58,050
understand so that's the first problem

00:10:55,830 --> 00:11:01,680
with functional model the second problem

00:10:58,050 --> 00:11:02,850
is really around efficiency like copying

00:11:01,680 --> 00:11:05,220
things it's not free

00:11:02,850 --> 00:11:06,689
like when you copy something you you

00:11:05,220 --> 00:11:07,889
will always pay the price later when the

00:11:06,689 --> 00:11:11,249
garbage collector comes along to like

00:11:07,889 --> 00:11:13,049
Hoover it up so you know when you build

00:11:11,249 --> 00:11:14,489
like very high-performance java system

00:11:13,049 --> 00:11:16,229
you spend a lot of time trying to reduce

00:11:14,489 --> 00:11:19,339
the amount of allocations that you're

00:11:16,229 --> 00:11:22,979
doing because it makes things faster and

00:11:19,339 --> 00:11:24,449
well Rory isn't here but Rory built this

00:11:22,979 --> 00:11:26,669
profile for us and this is like just a

00:11:24,449 --> 00:11:29,160
profile extraction from the scarlet

00:11:26,669 --> 00:11:30,959
scarlet compiler and you know those guys

00:11:29,160 --> 00:11:32,309
that like Bend they really know what

00:11:30,959 --> 00:11:34,229
they're doing and they spend a lot of

00:11:32,309 --> 00:11:36,149
time optimizing the compiler but still

00:11:34,229 --> 00:11:37,470
the use of functional constructs are

00:11:36,149 --> 00:11:40,549
still driven that thing to generate

00:11:37,470 --> 00:11:44,519
quite a lot of objects so this is like a

00:11:40,549 --> 00:11:47,039
output from compiling a cur so that's a

00:11:44,519 --> 00:11:49,649
three thousand lines of Scala and during

00:11:47,039 --> 00:11:52,739
that compile the compiler like allocates

00:11:49,649 --> 00:11:54,449
75 million objects so you know that's

00:11:52,739 --> 00:11:56,069
all stuff that then the garbage collect

00:11:54,449 --> 00:12:00,739
has to come along afterwards and clear

00:11:56,069 --> 00:12:03,029
up so for these reasons they are kind of

00:12:00,739 --> 00:12:04,889
what what our source starting point is

00:12:03,029 --> 00:12:07,109
that when you manage change in life and

00:12:04,889 --> 00:12:13,129
that we haven't as a industry we don't

00:12:07,109 --> 00:12:15,779
really nailed a good way to do it say

00:12:13,129 --> 00:12:16,979
all right if there's one thing I've

00:12:15,779 --> 00:12:19,079
learned from coming to these conferences

00:12:16,979 --> 00:12:20,489
is that it's the no scarlet presentation

00:12:19,079 --> 00:12:22,769
is complete without a little bit of

00:12:20,489 --> 00:12:24,839
theory so I'm gonna spend a few minutes

00:12:22,769 --> 00:12:26,909
talking to you about an idea that is

00:12:24,839 --> 00:12:28,909
really crucial to our solution and it's

00:12:26,909 --> 00:12:30,869
become this all-powerful building block

00:12:28,909 --> 00:12:33,419
on top of which we've built in

00:12:30,869 --> 00:12:35,549
everything and that's represented here

00:12:33,419 --> 00:12:37,199
by this software superhero referential

00:12:35,549 --> 00:12:40,499
transparency man again thank you to

00:12:37,199 --> 00:12:42,269
James's children so a lot of you may be

00:12:40,499 --> 00:12:43,589
familiar with this idea already but I'm

00:12:42,269 --> 00:12:46,350
gonna take a few minutes to explain

00:12:43,589 --> 00:12:48,359
anyway just cuz it's so important so a

00:12:46,350 --> 00:12:50,189
function is referentially transparent if

00:12:48,359 --> 00:12:52,259
it returns the same result every time I

00:12:50,189 --> 00:12:54,449
call it so given the same input I'm

00:12:52,259 --> 00:12:56,279
guaranteed to give the same out to get

00:12:54,449 --> 00:12:59,399
the same output no matter where or when

00:12:56,279 --> 00:13:01,799
I call it or to put it yet another way a

00:12:59,399 --> 00:13:03,989
function is referentially transparent if

00:13:01,799 --> 00:13:06,389
I can substitute calls to that function

00:13:03,989 --> 00:13:08,879
in my program directly with the result

00:13:06,389 --> 00:13:11,249
without any observable impact on the

00:13:08,879 --> 00:13:14,609
behavior of the program so let's take a

00:13:11,249 --> 00:13:16,060
look at a couple of examples in this

00:13:14,609 --> 00:13:17,980
case my function X

00:13:16,060 --> 00:13:20,440
some input parameter I and just computes

00:13:17,980 --> 00:13:22,210
3 plus the log of a and in foo I'm

00:13:20,440 --> 00:13:24,820
calling X with an input parameter of 10

00:13:22,210 --> 00:13:26,770
and as I mentioned substitutability is

00:13:24,820 --> 00:13:30,370
key so in this case we can just replace

00:13:26,770 --> 00:13:32,650
that call with its result and we have no

00:13:30,370 --> 00:13:34,440
impact on the behavior of food so this

00:13:32,650 --> 00:13:37,000
is good X is referentially transparent

00:13:34,440 --> 00:13:40,660
so let's take a look at a counter

00:13:37,000 --> 00:13:43,480
example this time X is a call to get the

00:13:40,660 --> 00:13:45,340
current time and foo is a function that

00:13:43,480 --> 00:13:47,080
takes some input parameter another time

00:13:45,340 --> 00:13:51,580
and just checks whether your input is

00:13:47,080 --> 00:13:53,560
after X so the time now is 230 so let's

00:13:51,580 --> 00:13:56,820
say I run this function foo with an

00:13:53,560 --> 00:13:59,110
input parameter of y equals 3 o'clock

00:13:56,820 --> 00:14:03,040
three years after 2 and so this function

00:13:59,110 --> 00:14:05,410
returns true but let's say that now I

00:14:03,040 --> 00:14:07,960
try that trick again where I substitute

00:14:05,410 --> 00:14:11,230
the method body this time wherever I see

00:14:07,960 --> 00:14:12,880
X in my program so now I'm making calls

00:14:11,230 --> 00:14:14,950
to get the current time directly and

00:14:12,880 --> 00:14:17,020
let's say that I run this function again

00:14:14,950 --> 00:14:20,410
now at 2:30 with the same input

00:14:17,020 --> 00:14:22,270
parameter y equals 3 o'clock and foo is

00:14:20,410 --> 00:14:24,040
gonna return true and I can keep running

00:14:22,270 --> 00:14:25,630
foo and it's gonna keep returning true

00:14:24,040 --> 00:14:28,090
for a little while but as soon as the

00:14:25,630 --> 00:14:30,400
clock hits 3 it's gonna start returning

00:14:28,090 --> 00:14:32,050
false so even though I am calling foo

00:14:30,400 --> 00:14:34,240
with that same input parameter of y

00:14:32,050 --> 00:14:35,860
equals 3 o'clock suddenly it's returning

00:14:34,240 --> 00:14:37,570
a different result and that's because

00:14:35,860 --> 00:14:39,720
I'm relying on behavior that's

00:14:37,570 --> 00:14:43,120
inherently not referentially transparent

00:14:39,720 --> 00:14:44,860
but why do we care at all well like any

00:14:43,120 --> 00:14:46,390
good superhero referential transparency

00:14:44,860 --> 00:14:48,580
man has some super powers

00:14:46,390 --> 00:14:50,950
what referential transparency gives us

00:14:48,580 --> 00:14:52,420
is a number of immediate benefits the

00:14:50,950 --> 00:14:54,130
first of these is order independence

00:14:52,420 --> 00:14:56,020
because these functions are guaranteed

00:14:54,130 --> 00:14:58,060
to return the same result every time I

00:14:56,020 --> 00:14:59,560
call them I can run them in any order it

00:14:58,060 --> 00:15:01,980
doesn't really matter so we're free to

00:14:59,560 --> 00:15:04,210
reorder execution and that leads to

00:15:01,980 --> 00:15:05,710
parallelism we can run these functions

00:15:04,210 --> 00:15:08,050
in parallel they won't interfere with

00:15:05,710 --> 00:15:09,460
each other they're independent and we

00:15:08,050 --> 00:15:10,750
can run them asynchronously it doesn't

00:15:09,460 --> 00:15:12,430
matter whether I block to wait for the

00:15:10,750 --> 00:15:14,170
result or whether I get a call back and

00:15:12,430 --> 00:15:16,690
get that result later it's still the

00:15:14,170 --> 00:15:18,490
same result the other thing we get is

00:15:16,690 --> 00:15:20,770
portability so just like I can run this

00:15:18,490 --> 00:15:22,840
function across multiple CPUs I can also

00:15:20,770 --> 00:15:24,370
run the function across an entire grid

00:15:22,840 --> 00:15:26,040
of machines and I'm still guaranteed to

00:15:24,370 --> 00:15:27,910
get the same result every time I call it

00:15:26,040 --> 00:15:29,270
but the benefit that we're going to

00:15:27,910 --> 00:15:31,910
focus on today is

00:15:29,270 --> 00:15:33,560
caching or memorization so because these

00:15:31,910 --> 00:15:36,320
functions are guaranteed to give the

00:15:33,560 --> 00:15:38,090
same result I can look up the call to

00:15:36,320 --> 00:15:39,560
the function in a cache and just

00:15:38,090 --> 00:15:39,710
retrieve the result if I've already got

00:15:39,560 --> 00:15:42,320
it

00:15:39,710 --> 00:15:44,150
rather than recalculating and you can

00:15:42,320 --> 00:15:46,280
imagine the benefit so if my function is

00:15:44,150 --> 00:15:48,800
CPU intensive or is making lots of Io

00:15:46,280 --> 00:15:50,630
calls I can save a lot of time by just

00:15:48,800 --> 00:15:53,390
going straight to the cache and getting

00:15:50,630 --> 00:15:55,730
back the result and I know that people

00:15:53,390 --> 00:15:57,050
are kind of scared of caching and cache

00:15:55,730 --> 00:15:59,480
coherence is one of the hardest problems

00:15:57,050 --> 00:16:01,790
in computer science and everything but

00:15:59,480 --> 00:16:03,110
we don't worry about that because of the

00:16:01,790 --> 00:16:05,810
guarantees of referential transparency

00:16:03,110 --> 00:16:07,730
my functions are guaranteed to return

00:16:05,810 --> 00:16:09,890
the same results every time I call them

00:16:07,730 --> 00:16:15,710
and so I can just retrieve those results

00:16:09,890 --> 00:16:17,630
from the cache so so far this idea of

00:16:15,710 --> 00:16:20,270
referential transparency maybe conflicts

00:16:17,630 --> 00:16:22,700
a bit with the idea of change but it

00:16:20,270 --> 00:16:25,250
allows me to introduce our solution so I

00:16:22,700 --> 00:16:27,710
can talk about it later so we've created

00:16:25,250 --> 00:16:29,510
this construct the node and this is an

00:16:27,710 --> 00:16:30,860
annotation that extends the scala

00:16:29,510 --> 00:16:33,590
language and we've implemented it

00:16:30,860 --> 00:16:35,510
ourselves using a compiler plugin so

00:16:33,590 --> 00:16:37,460
when you the developers annotate your

00:16:35,510 --> 00:16:39,290
function as a node you're guaranteeing

00:16:37,460 --> 00:16:42,380
to the compiler that that function is

00:16:39,290 --> 00:16:43,790
referentially transparent and that's up

00:16:42,380 --> 00:16:45,230
to the developer to ensure and we were

00:16:43,790 --> 00:16:46,910
kind of paranoid about this when the

00:16:45,230 --> 00:16:48,410
project first started out and so we

00:16:46,910 --> 00:16:49,880
built tools to check whether functions

00:16:48,410 --> 00:16:52,130
actually are referentially transparent

00:16:49,880 --> 00:16:53,990
but in in practice we haven't had to use

00:16:52,130 --> 00:16:55,610
those because it turns out that most

00:16:53,990 --> 00:16:57,590
people are able to do this easily and

00:16:55,610 --> 00:16:59,480
most referentially transparent functions

00:16:57,590 --> 00:17:01,370
just make calls to lots of other

00:16:59,480 --> 00:17:07,150
referentially transparent functions and

00:17:01,370 --> 00:17:11,300
then glue together the results so we

00:17:07,150 --> 00:17:14,930
when we see a node in in the code or a

00:17:11,300 --> 00:17:16,250
function annotated as a node we can we

00:17:14,930 --> 00:17:20,089
don't compile it using the the

00:17:16,250 --> 00:17:21,680
conventional Scala compiler we use

00:17:20,089 --> 00:17:23,390
something called scarlet async and that

00:17:21,680 --> 00:17:26,990
generates like a state machine

00:17:23,390 --> 00:17:28,610
representation of the function and in

00:17:26,990 --> 00:17:32,690
our last talk we we talked about how

00:17:28,610 --> 00:17:35,990
that lets us automatically paralyze and

00:17:32,690 --> 00:17:37,390
a synchronize this code so at compile

00:17:35,990 --> 00:17:39,830
time where we're forming these

00:17:37,390 --> 00:17:41,690
representations of referentially

00:17:39,830 --> 00:17:42,590
transparent functions and these

00:17:41,690 --> 00:17:45,020
representations

00:17:42,590 --> 00:17:46,640
let us at run-time make advantage of

00:17:45,020 --> 00:17:48,620
like take take advantage of some of

00:17:46,640 --> 00:17:51,470
these benefits of referential

00:17:48,620 --> 00:17:53,059
transparency but at runtime we need

00:17:51,470 --> 00:17:55,010
something smart to actually control

00:17:53,059 --> 00:17:58,580
execution of these things and that's

00:17:55,010 --> 00:18:00,650
where our scheduler comes in so the the

00:17:58,580 --> 00:18:04,159
nodes or the functions on the right of

00:18:00,650 --> 00:18:05,630
the screen for work items and they put

00:18:04,159 --> 00:18:07,460
them into the schedulers work queue and

00:18:05,630 --> 00:18:09,590
the scheduler can look ahead in that

00:18:07,460 --> 00:18:11,809
queue and it can make intelligent

00:18:09,590 --> 00:18:14,090
decisions about how to execute the code

00:18:11,809 --> 00:18:15,770
so if it seems like lots of calls to a

00:18:14,090 --> 00:18:16,760
database it can Batchelor schools and we

00:18:15,770 --> 00:18:22,309
talked a bit about that in our last

00:18:16,760 --> 00:18:24,049
presentation but it it can decide to run

00:18:22,309 --> 00:18:26,690
these nodes in parallel or even across a

00:18:24,049 --> 00:18:28,520
grid of machines and this goes back to

00:18:26,690 --> 00:18:31,039
our aim we don't want the developer

00:18:28,520 --> 00:18:34,549
themselves to worry about execution plan

00:18:31,039 --> 00:18:36,049
they focus on business logic and it's

00:18:34,549 --> 00:18:38,000
kind of a trade-off they hand over a

00:18:36,049 --> 00:18:41,149
responsibility for execution to the

00:18:38,000 --> 00:18:42,919
platform itself but the key thing to

00:18:41,149 --> 00:18:44,059
note here is that the scheduler is cache

00:18:42,919 --> 00:18:45,770
aware and that's what we're going to

00:18:44,059 --> 00:18:49,490
focus on in today's presentation so

00:18:45,770 --> 00:18:51,559
before we actually run any code we look

00:18:49,490 --> 00:18:53,659
up a result for that function in the

00:18:51,559 --> 00:18:55,460
cache and if it's already in the cache

00:18:53,659 --> 00:18:57,080
because we've run it before and we know

00:18:55,460 --> 00:18:58,640
it's referentially transparent we can

00:18:57,080 --> 00:19:00,320
retrieve it directly from the cache

00:18:58,640 --> 00:19:03,620
rather than executing the body of the

00:19:00,320 --> 00:19:04,700
method again but you guys don't have to

00:19:03,620 --> 00:19:08,120
believe me because we're going to show

00:19:04,700 --> 00:19:10,100
you how this works in a demo and for

00:19:08,120 --> 00:19:11,870
this next part I am gonna keep talking

00:19:10,100 --> 00:19:13,610
while James types because we can't

00:19:11,870 --> 00:19:15,320
multitask we're going to start off with

00:19:13,610 --> 00:19:17,690
a very basic example then build up from

00:19:15,320 --> 00:19:19,669
there so suppose I have some function

00:19:17,690 --> 00:19:21,640
calc and it just multiplies two numbers

00:19:19,669 --> 00:19:24,440
together and prints of calculating line

00:19:21,640 --> 00:19:26,120
and I've annotated this as a node

00:19:24,440 --> 00:19:27,950
because it's referentially transparent

00:19:26,120 --> 00:19:31,100
that result there is never going to

00:19:27,950 --> 00:19:32,299
change so we call calc and you see what

00:19:31,100 --> 00:19:34,220
you expect to see we print that

00:19:32,299 --> 00:19:36,500
calculating and then we multiply the two

00:19:34,220 --> 00:19:38,120
numbers and return the result but now

00:19:36,500 --> 00:19:42,080
let's see what happens when we try and

00:19:38,120 --> 00:19:43,970
calc again this time the only difference

00:19:42,080 --> 00:19:45,559
is we don't see calculating and that's

00:19:43,970 --> 00:19:47,690
because we're not actually executing any

00:19:45,559 --> 00:19:49,730
code we've looked it up in the cache and

00:19:47,690 --> 00:19:51,230
we get a cache hit and we retrieve the

00:19:49,730 --> 00:19:53,419
result directly from the cache and we

00:19:51,230 --> 00:19:55,039
can do that again and again the

00:19:53,419 --> 00:19:55,820
scheduler looks up in the cache before

00:19:55,039 --> 00:19:58,250
it runs the code

00:19:55,820 --> 00:20:00,320
and we get the result so I've been

00:19:58,250 --> 00:20:02,360
talking about caching but to actually be

00:20:00,320 --> 00:20:03,770
able to address something in a cache you

00:20:02,360 --> 00:20:06,110
need a dress ability and that's what

00:20:03,770 --> 00:20:07,700
referential transparency gives us it

00:20:06,110 --> 00:20:10,820
kind of gives us this concept of being

00:20:07,700 --> 00:20:12,560
able to address a function and give it

00:20:10,820 --> 00:20:14,600
some identity and give us a cache key

00:20:12,560 --> 00:20:17,420
and in this very simple case the

00:20:14,600 --> 00:20:19,640
function name itself is enough as a

00:20:17,420 --> 00:20:22,580
cache key because every time we call the

00:20:19,640 --> 00:20:24,290
same function calc we look it up by that

00:20:22,580 --> 00:20:27,110
function name and we retrieve it

00:20:24,290 --> 00:20:30,020
directly from the cache so let's make

00:20:27,110 --> 00:20:32,600
this a little bit more exciting this

00:20:30,020 --> 00:20:34,850
time this function calc once James

00:20:32,600 --> 00:20:39,230
figures out put all my girls I think you

00:20:34,850 --> 00:20:42,200
can hold something ok so this time oh

00:20:39,230 --> 00:20:46,490
yeah it doesn't really matter just to

00:20:42,200 --> 00:20:49,070
stop it yeah ok

00:20:46,490 --> 00:20:50,390
so this time that's the big square yeah

00:20:49,070 --> 00:20:52,910
I don't know but I don't see this Creek

00:20:50,390 --> 00:20:55,280
actually the lighter this time my

00:20:52,910 --> 00:20:58,100
function calc takes some input parameter

00:20:55,280 --> 00:20:59,930
quantity and it prints that print line

00:20:58,100 --> 00:21:02,360
again and then it multiplies a number by

00:20:59,930 --> 00:21:05,300
quantity so we can call calc with an

00:21:02,360 --> 00:21:08,030
input of 20 and we run the we run the

00:21:05,300 --> 00:21:09,560
calculation and we return a result but

00:21:08,030 --> 00:21:12,740
now let's say we try and call calc again

00:21:09,560 --> 00:21:13,640
with that same input parameter if you're

00:21:12,740 --> 00:21:16,280
following me so far

00:21:13,640 --> 00:21:17,900
you will guess that now we don't print

00:21:16,280 --> 00:21:19,550
that calculating and that's because

00:21:17,900 --> 00:21:20,810
we're not running the method body

00:21:19,550 --> 00:21:23,180
we're just retrieving this result

00:21:20,810 --> 00:21:24,470
directly from the cache but let's see

00:21:23,180 --> 00:21:27,400
what happens if we try and call calc

00:21:24,470 --> 00:21:30,320
with some different input parameter 40

00:21:27,400 --> 00:21:31,640
well 40 years not in our cache yet so we

00:21:30,320 --> 00:21:34,430
haven't run this one before with this

00:21:31,640 --> 00:21:36,200
input parameter and so we print line

00:21:34,430 --> 00:21:38,990
calculating and then we return the

00:21:36,200 --> 00:21:41,390
result but now if we try again to caulk

00:21:38,990 --> 00:21:43,940
out with that input parameter of 40 we

00:21:41,390 --> 00:21:46,550
retrieve it from the cache directly so

00:21:43,940 --> 00:21:48,380
the key thing here is that calc is still

00:21:46,550 --> 00:21:49,910
referentially transparent even though

00:21:48,380 --> 00:21:51,740
its output is changing it's only

00:21:49,910 --> 00:21:54,020
changing as a function of that input so

00:21:51,740 --> 00:21:56,750
given the same input I am guaranteed

00:21:54,020 --> 00:21:58,970
still to get the same output but the

00:21:56,750 --> 00:22:01,750
parameters now need to form part of the

00:21:58,970 --> 00:22:01,750
address space yep

00:22:03,040 --> 00:22:12,380
yeah it's from the cash so just to

00:22:10,940 --> 00:22:13,940
repeat it for anyone hidden here if we

00:22:12,380 --> 00:22:19,070
run this again with an input parameter

00:22:13,940 --> 00:22:23,500
of 40 is it going to hit the cache this

00:22:19,070 --> 00:22:26,360
one so there's 20 that's a cache hit

00:22:23,500 --> 00:22:28,790
yeah and 40 as well as a cache hit and

00:22:26,360 --> 00:22:31,910
any new parameter is going to be a cache

00:22:28,790 --> 00:22:34,520
miss because we haven't done it yet yeah

00:22:31,910 --> 00:22:39,110
14 is cache miss so we see the print

00:22:34,520 --> 00:22:40,970
line again right so our function name on

00:22:39,110 --> 00:22:42,560
its own is no longer enough to form the

00:22:40,970 --> 00:22:46,160
cache key and we now need to include

00:22:42,560 --> 00:22:47,630
that parameter but with that if we call

00:22:46,160 --> 00:22:49,160
the same function with the same input

00:22:47,630 --> 00:22:50,960
parameter it's still referentially

00:22:49,160 --> 00:22:54,260
transparent and so that is now enough to

00:22:50,960 --> 00:22:56,150
form the cache key we can get a cache

00:22:54,260 --> 00:22:59,420
hit and retrieve directly from the cache

00:22:56,150 --> 00:23:01,730
rather than run the calculation okay so

00:22:59,420 --> 00:23:05,170
now let's suppose that this function

00:23:01,730 --> 00:23:10,000
calc is actually a method on some

00:23:05,170 --> 00:23:13,130
instance so we have this fuel cost class

00:23:10,000 --> 00:23:16,370
and that contains an FX rate and a price

00:23:13,130 --> 00:23:18,320
and our function calc from before now

00:23:16,370 --> 00:23:19,730
depends on one of the things well

00:23:18,320 --> 00:23:22,010
actually both constructor parameters

00:23:19,730 --> 00:23:25,220
price and the rate and on our input

00:23:22,010 --> 00:23:27,260
parameter quantity so let's say we

00:23:25,220 --> 00:23:30,260
construct some fuel cost we've already

00:23:27,260 --> 00:23:33,560
got an FX to save us typing that's it

00:23:30,260 --> 00:23:37,070
there and typing we can construct a fuel

00:23:33,560 --> 00:23:44,060
cost using that FX rate and some price

00:23:37,070 --> 00:23:46,100
20 for example 30 okay okay so we have

00:23:44,060 --> 00:23:48,770
our fuel cost and we can now call this

00:23:46,100 --> 00:23:50,300
method calc on the instance F of fuel

00:23:48,770 --> 00:23:53,150
cost and we can call it with the same

00:23:50,300 --> 00:23:56,030
input parameter 20 as before but this

00:23:53,150 --> 00:23:58,160
time our function calc depends on the

00:23:56,030 --> 00:24:00,020
constructor parameters and so we haven't

00:23:58,160 --> 00:24:02,030
actually calculated this before so we

00:24:00,020 --> 00:24:03,830
see that print line calculating and we

00:24:02,030 --> 00:24:06,470
get the result but if we try this again

00:24:03,830 --> 00:24:08,180
with the same input parameters we

00:24:06,470 --> 00:24:10,100
retrieved directly from the cache and

00:24:08,180 --> 00:24:13,430
that's because we're now taking into

00:24:10,100 --> 00:24:15,900
account instance identity and we can

00:24:13,430 --> 00:24:19,920
construct well yeah okay we

00:24:15,900 --> 00:24:22,110
we can run this calc again with some

00:24:19,920 --> 00:24:23,880
different input parameter 40 and again

00:24:22,110 --> 00:24:26,160
we'll have to actually run the execution

00:24:23,880 --> 00:24:27,810
because it's not yet in the cache but

00:24:26,160 --> 00:24:30,090
the key thing is that calc is still

00:24:27,810 --> 00:24:31,620
referentially transparent given the same

00:24:30,090 --> 00:24:34,350
instance identity and the same

00:24:31,620 --> 00:24:37,620
parameters so if we construct a

00:24:34,350 --> 00:24:41,990
different fuel cost G where the price is

00:24:37,620 --> 00:24:44,670
now 42 then because calc depends on that

00:24:41,990 --> 00:24:46,710
that constructor parameter if we try to

00:24:44,670 --> 00:24:49,830
call calc with the same input parameters

00:24:46,710 --> 00:24:51,420
again again we get a cache miss so we

00:24:49,830 --> 00:24:53,580
have to actually run the calculation and

00:24:51,420 --> 00:24:56,550
return the result but again if we call

00:24:53,580 --> 00:24:58,110
it with the same input then we're going

00:24:56,550 --> 00:25:04,350
to get the same output directly from the

00:24:58,110 --> 00:25:07,650
cache so yeah so this time again we get

00:25:04,350 --> 00:25:09,150
a cache hit so it's no longer enough for

00:25:07,650 --> 00:25:10,800
us just to take into account the

00:25:09,150 --> 00:25:13,770
function name and the parameters now we

00:25:10,800 --> 00:25:15,570
need some concept of instance and we've

00:25:13,770 --> 00:25:16,920
created this construct called an entity

00:25:15,570 --> 00:25:19,260
you see the annotation on the class

00:25:16,920 --> 00:25:22,020
there that gives us instance identity

00:25:19,260 --> 00:25:24,480
and case class equality and identity

00:25:22,020 --> 00:25:28,440
works similarly to Scala as to Scala

00:25:24,480 --> 00:25:30,570
case classes for entities so now given

00:25:28,440 --> 00:25:33,570
the same instance and the same function

00:25:30,570 --> 00:25:36,300
with the same input our function calc

00:25:33,570 --> 00:25:39,540
our node is guaranteed to give the same

00:25:36,300 --> 00:25:41,460
output and that means that we can cache

00:25:39,540 --> 00:25:43,590
that result rather than looking it up

00:25:41,460 --> 00:25:46,980
and we can address calls to this

00:25:43,590 --> 00:25:51,540
function in order to be able to get that

00:25:46,980 --> 00:25:52,890
cache key ok let's make it a little bit

00:25:51,540 --> 00:25:54,390
more complicated well actually you know

00:25:52,890 --> 00:25:57,780
let's get to the point and do the thing

00:25:54,390 --> 00:26:00,570
where we deal with change so so far

00:25:57,780 --> 00:26:02,490
we've kind of shown you the build up but

00:26:00,570 --> 00:26:04,860
now let's suppose that we want to be

00:26:02,490 --> 00:26:10,320
able to change the FX rate like James

00:26:04,860 --> 00:26:14,160
did in his example beforehand so we have

00:26:10,320 --> 00:26:18,960
constructed this thing called a scenario

00:26:14,160 --> 00:26:20,910
and a scenario holds a bunch of intense

00:26:18,960 --> 00:26:24,780
to make a change and those intents are

00:26:20,910 --> 00:26:27,240
called tweaks so a tweak represents your

00:26:24,780 --> 00:26:29,190
intent to make a change to a node and

00:26:27,240 --> 00:26:32,790
the scenario then holds

00:26:29,190 --> 00:26:37,410
collection of those things you've got a

00:26:32,790 --> 00:26:38,940
typo should be pal so we're trying to

00:26:37,410 --> 00:26:41,370
keep in line with the functional

00:26:38,940 --> 00:26:43,170
paradigm where our code is as expressive

00:26:41,370 --> 00:26:45,150
as possible we want to express what

00:26:43,170 --> 00:26:49,410
we're trying to do rather than how we're

00:26:45,150 --> 00:26:52,110
gonna do it so we can write a scenario

00:26:49,410 --> 00:26:55,020
and a scenario I feel I need to make a

00:26:52,110 --> 00:26:56,520
feel as fast don't you have one no

00:26:55,020 --> 00:26:57,210
that's true I've got one we've got our

00:26:56,520 --> 00:27:01,230
fuel cost

00:26:57,210 --> 00:27:04,320
that's called F yep okay so we can

00:27:01,230 --> 00:27:06,810
construct a scenario and a scenario will

00:27:04,320 --> 00:27:16,170
hold a bunch of tweaks one of which will

00:27:06,810 --> 00:27:19,500
be F dot F X F X right no dot local

00:27:16,170 --> 00:27:22,020
currency yep don't write right so this

00:27:19,500 --> 00:27:25,620
tweak expresses our intent to change the

00:27:22,020 --> 00:27:29,580
rate to 8.13 you've got a taper yeah

00:27:25,620 --> 00:27:31,710
this is good teamwork okay and then

00:27:29,580 --> 00:27:33,150
close bracket yeah so we have a scenario

00:27:31,710 --> 00:27:36,210
and the scenario is holding on to all of

00:27:33,150 --> 00:27:38,430
our intents to make a change so that's

00:27:36,210 --> 00:27:41,760
kind of where we're constructing this

00:27:38,430 --> 00:27:42,900
one extra object the scenario but we

00:27:41,760 --> 00:27:47,400
haven't actually applied the change

00:27:42,900 --> 00:27:49,200
anywhere else I'm sorry to do this I

00:27:47,400 --> 00:27:51,770
forgot to mention that some of you will

00:27:49,200 --> 00:27:54,150
have noticed rate is marked as a note

00:27:51,770 --> 00:27:57,450
and that that's what it allows us to do

00:27:54,150 --> 00:27:59,760
this this tweaking so if we just run F

00:27:57,450 --> 00:28:02,820
calc with that same input parameter of

00:27:59,760 --> 00:28:04,680
20 again nothing will have changed and

00:28:02,820 --> 00:28:07,500
in fact we can look at the rate that's

00:28:04,680 --> 00:28:10,830
on this fuel cost object I've got local

00:28:07,500 --> 00:28:12,930
currency yep the rate is the original

00:28:10,830 --> 00:28:15,720
rate that we constructed it with 8.88

00:28:12,930 --> 00:28:18,930
and our scenario contains our intent to

00:28:15,720 --> 00:28:20,850
change this rate to 8.13 but now we need

00:28:18,930 --> 00:28:22,290
to actually apply the change and so we

00:28:20,850 --> 00:28:24,360
have a construct called a given block

00:28:22,290 --> 00:28:26,100
and a given takes a scenario and then

00:28:24,360 --> 00:28:29,550
runs any computation in that scenario

00:28:26,100 --> 00:28:30,690
with the change applied so if we run

00:28:29,550 --> 00:28:33,450
this again with the same input

00:28:30,690 --> 00:28:36,840
parameters this time under this new

00:28:33,450 --> 00:28:39,360
scenario we see that we have to run the

00:28:36,840 --> 00:28:40,830
body of that method again so we see the

00:28:39,360 --> 00:28:42,340
print line - calculating and a new

00:28:40,830 --> 00:28:44,919
result but

00:28:42,340 --> 00:28:47,080
we're in that same scenario again and we

00:28:44,919 --> 00:28:52,150
run F calc again you're just gonna copy

00:28:47,080 --> 00:28:53,980
paste them this time we're gonna get a

00:28:52,150 --> 00:28:56,289
cache hit and that's because my function

00:28:53,980 --> 00:28:58,900
calc is still referentially transparent

00:28:56,289 --> 00:29:01,750
under certain conditions so in the same

00:28:58,900 --> 00:29:03,220
scenario on the same instance the same

00:29:01,750 --> 00:29:05,799
function with the same parameters is

00:29:03,220 --> 00:29:08,140
referentially transparent so when we run

00:29:05,799 --> 00:29:14,529
it again we get just the result directly

00:29:08,140 --> 00:29:16,990
from the cache we can can what you want

00:29:14,529 --> 00:29:18,669
to do well we can actually show that if

00:29:16,990 --> 00:29:21,220
we come back out of this scenario so if

00:29:18,669 --> 00:29:22,000
we just run F calc with the same input

00:29:21,220 --> 00:29:24,429
of 20

00:29:22,000 --> 00:29:26,140
we haven't irreversibly changed the rate

00:29:24,429 --> 00:29:28,809
there's no mutation that we've done here

00:29:26,140 --> 00:29:31,480
but the platform itself has managed the

00:29:28,809 --> 00:29:33,429
propagation of change throughout our

00:29:31,480 --> 00:29:35,409
dependency graph so this time we don't

00:29:33,429 --> 00:29:36,669
need to understand the whole dependency

00:29:35,409 --> 00:29:39,490
graph we don't need to kind of bend it

00:29:36,669 --> 00:29:41,770
into shape to make it easier to do this

00:29:39,490 --> 00:29:44,020
with lenses and so on the platform

00:29:41,770 --> 00:29:46,210
itself manages the change for us and all

00:29:44,020 --> 00:29:47,590
we do is Express our intent to change

00:29:46,210 --> 00:29:51,760
and then apply the change in a given

00:29:47,590 --> 00:29:53,649
block but so this is pretty close to

00:29:51,760 --> 00:29:55,299
what developers want to write but it's

00:29:53,649 --> 00:29:57,010
still not quite there and so we've added

00:29:55,299 --> 00:29:58,929
some syntactic sugar and are given

00:29:57,010 --> 00:30:02,799
blocks that allows us to tweak nodes

00:29:58,929 --> 00:30:04,179
directly so we can address this node

00:30:02,799 --> 00:30:08,620
again yeah a good

00:30:04,179 --> 00:30:10,210
and directly tweak it to 8.13 and then

00:30:08,620 --> 00:30:12,490
we can run that same calculation again

00:30:10,210 --> 00:30:14,890
so the underlying mechanics are still

00:30:12,490 --> 00:30:17,230
the same we still have a scenario but

00:30:14,890 --> 00:30:20,470
we're much closer to that nice mutable

00:30:17,230 --> 00:30:22,270
procedural way of changing stuff and we

00:30:20,470 --> 00:30:24,580
think it's much easier to read this kind

00:30:22,270 --> 00:30:30,700
of code than to read functional style

00:30:24,580 --> 00:30:33,220
change so our cache key is no longer

00:30:30,700 --> 00:30:35,380
sufficient as it is we need to take into

00:30:33,220 --> 00:30:37,750
account now the scenario and that's

00:30:35,380 --> 00:30:39,340
because our function changes depending

00:30:37,750 --> 00:30:42,429
on the scenario that we're in depending

00:30:39,340 --> 00:30:44,470
on the value of this node so as long as

00:30:42,429 --> 00:30:46,090
well as well as instance identity and

00:30:44,470 --> 00:30:47,860
all the other things we now take into

00:30:46,090 --> 00:30:50,169
account the scenario and this kind of

00:30:47,860 --> 00:30:53,260
completes our cache key this means that

00:30:50,169 --> 00:30:55,660
we can look up a function with certain

00:30:53,260 --> 00:30:58,210
input parameter on a certain instance

00:30:55,660 --> 00:31:00,940
within a certain scenario and still get

00:30:58,210 --> 00:31:02,320
cash hits against that and that's a

00:31:00,940 --> 00:31:04,990
pretty huge saving I mean this is a

00:31:02,320 --> 00:31:07,510
dummy example but it's a huge saving

00:31:04,990 --> 00:31:09,730
when you're running big CPU intensive

00:31:07,510 --> 00:31:13,570
calculations that can potentially reuse

00:31:09,730 --> 00:31:15,190
a lot of data from cash okay so let's

00:31:13,570 --> 00:31:16,600
take a look at the more complicated

00:31:15,190 --> 00:31:19,510
example that James showed you before

00:31:16,600 --> 00:31:22,180
where we had the hands holding onto the

00:31:19,510 --> 00:31:24,640
objects so this time we have this flight

00:31:22,180 --> 00:31:29,920
and I think we've already constructed

00:31:24,640 --> 00:31:31,510
one and a flight contains a fuel costs

00:31:29,920 --> 00:31:33,910
that we had before but it also contains

00:31:31,510 --> 00:31:37,750
occupancy score and occupancy score also

00:31:33,910 --> 00:31:40,480
has an FX rate we've defined two methods

00:31:37,750 --> 00:31:42,760
on flight one of them is fuel cost and

00:31:40,480 --> 00:31:44,760
that just calls calc like we were

00:31:42,760 --> 00:31:47,830
calling before on our fuel cost object

00:31:44,760 --> 00:31:49,500
with an input parameter of if I hover

00:31:47,830 --> 00:31:52,750
over this we should be able to see Oh

00:31:49,500 --> 00:31:58,720
fuel quantity which is in our

00:31:52,750 --> 00:32:01,300
constructor parameter okay yeah 30 and

00:31:58,720 --> 00:32:04,450
we we also have some other function and

00:32:01,300 --> 00:32:07,210
occupancy score but we can still change

00:32:04,450 --> 00:32:08,980
the rate in our fuel cost without

00:32:07,210 --> 00:32:12,820
understanding the entire dependency

00:32:08,980 --> 00:32:14,830
graph so we can kind of do it in the in

00:32:12,820 --> 00:32:17,800
the procedural style where we reference

00:32:14,830 --> 00:32:20,440
the flight dot fuel cost local currency

00:32:17,800 --> 00:32:22,660
dot rate directly inside a given block

00:32:20,440 --> 00:32:30,960
and we can set that to some new value

00:32:22,660 --> 00:32:30,960
and then run our calculation again yep

00:32:32,980 --> 00:32:38,860
and within that scenario the the changes

00:32:36,790 --> 00:32:41,650
applied and we only invalidate the parts

00:32:38,860 --> 00:32:43,510
of the graph that need to be invalidated

00:32:41,650 --> 00:32:47,530
which means that we don't lose out on

00:32:43,510 --> 00:32:48,850
any cash reuse but the key benefit is

00:32:47,530 --> 00:32:51,910
that we don't have to understand the

00:32:48,850 --> 00:32:53,950
dependency graph so our developers write

00:32:51,910 --> 00:32:56,440
the code that's as close to the code

00:32:53,950 --> 00:32:58,330
that they want to write as we can but we

00:32:56,440 --> 00:33:01,840
keep all of the benefits of immutable

00:32:58,330 --> 00:33:05,230
state and referential transparency in a

00:33:01,840 --> 00:33:07,650
multi-threaded environment you know

00:33:05,230 --> 00:33:14,700
think so

00:33:07,650 --> 00:33:19,740
Oh didn't pass a lockdown bar so to

00:33:14,700 --> 00:33:23,010
summarize what we have is we have a way

00:33:19,740 --> 00:33:25,680
of allowing people to write change in a

00:33:23,010 --> 00:33:27,780
way that's really easy to read but also

00:33:25,680 --> 00:33:30,630
we can execute that efficiency

00:33:27,780 --> 00:33:32,220
efficiently our you know the number of

00:33:30,630 --> 00:33:33,420
objects we're creating is linearly

00:33:32,220 --> 00:33:37,170
proportional to the change that we're

00:33:33,420 --> 00:33:39,240
making and then as Jetta said you know

00:33:37,170 --> 00:33:41,070
as we then run the calculation we can

00:33:39,240 --> 00:33:42,750
see which things we need to rerun

00:33:41,070 --> 00:33:44,550
because we know where the where the

00:33:42,750 --> 00:33:47,670
change is and that's all handled this

00:33:44,550 --> 00:33:49,710
side of the the scheduler this means

00:33:47,670 --> 00:33:51,000
that we think developers are more

00:33:49,710 --> 00:33:53,610
productive because it can write code

00:33:51,000 --> 00:33:57,030
that's easy to read and the easier to

00:33:53,610 --> 00:33:58,350
write in the first place and this is all

00:33:57,030 --> 00:34:01,620
really comes back to the fact that we

00:33:58,350 --> 00:34:03,059
can logically address a function so you

00:34:01,620 --> 00:34:05,100
know you can view it as like a

00:34:03,059 --> 00:34:06,780
mathematical universe where we can

00:34:05,100 --> 00:34:09,179
address the function inside of there and

00:34:06,780 --> 00:34:11,370
because we can address it we can cash it

00:34:09,179 --> 00:34:14,190
but also because we can address it we

00:34:11,370 --> 00:34:15,419
can simulate change on it and that and

00:34:14,190 --> 00:34:17,820
that's really the kind of underlying

00:34:15,419 --> 00:34:20,520
premise of the whole thing and that

00:34:17,820 --> 00:34:21,960
matched with like an understanding of

00:34:20,520 --> 00:34:24,990
referential transparency is extremely

00:34:21,960 --> 00:34:26,070
powerful around about now a lot of

00:34:24,990 --> 00:34:29,760
people are thinking well how much

00:34:26,070 --> 00:34:32,940
overhead is there so I asked Sergey who

00:34:29,760 --> 00:34:35,159
is here - we have a profiler that we

00:34:32,940 --> 00:34:37,770
that we built and second Dmitri are

00:34:35,159 --> 00:34:40,520
working on at the moment and he like ran

00:34:37,770 --> 00:34:44,159
some apps for about a minute

00:34:40,520 --> 00:34:46,230
Multi multi threaded apps and you know

00:34:44,159 --> 00:34:49,649
in one case they're they're about 4

00:34:46,230 --> 00:34:52,050
million node functions and it took about

00:34:49,649 --> 00:34:56,100
13 seconds to do the cache in the cups

00:34:52,050 --> 00:35:00,780
but those cash flow cups saved I think

00:34:56,100 --> 00:35:02,970
like 16 minutes so and then in another

00:35:00,780 --> 00:35:05,280
more extreme case again run for about a

00:35:02,970 --> 00:35:06,510
minute about 2 million no functions that

00:35:05,280 --> 00:35:10,050
are about a million hits and million

00:35:06,510 --> 00:35:11,850
misses but the hits that so all the

00:35:10,050 --> 00:35:15,660
lookups cost about 20 seconds in that

00:35:11,850 --> 00:35:19,230
run aggregate CPU time I think was a

00:35:15,660 --> 00:35:21,150
cause but the saving of like run time

00:35:19,230 --> 00:35:24,390
was about an hour and 12 minutes

00:35:21,150 --> 00:35:26,819
so the thing is like I think initially

00:35:24,390 --> 00:35:28,349
you-you-you kind of understandably are

00:35:26,819 --> 00:35:30,749
worried about the overhead but you know

00:35:28,349 --> 00:35:33,599
the reality is that in most programs you

00:35:30,749 --> 00:35:35,519
know localities real and actually being

00:35:33,599 --> 00:35:38,099
able to reuse things and having a very

00:35:35,519 --> 00:35:40,349
pervasive runtime which caches things is

00:35:38,099 --> 00:35:44,490
make some massive difference to it to

00:35:40,349 --> 00:35:47,849
efficiency so I think we've got enough

00:35:44,490 --> 00:35:49,319
time we've got enough time so there are

00:35:47,849 --> 00:35:51,299
lots of other great things you can do

00:35:49,319 --> 00:35:52,710
once you have address ability so we're

00:35:51,299 --> 00:35:54,839
just going to give you like a very quick

00:35:52,710 --> 00:35:57,269
demo of like what of one of those things

00:35:54,839 --> 00:36:00,359
which is that you can build like much

00:35:57,269 --> 00:36:03,359
more declarative uise so we now have

00:36:00,359 --> 00:36:05,490
like a code that we can address we also

00:36:03,359 --> 00:36:07,200
you can build a like a DSL to address

00:36:05,490 --> 00:36:08,999
the UI in this case you know the window

00:36:07,200 --> 00:36:11,640
is the outer thing in a tree and and

00:36:08,999 --> 00:36:13,680
that contains some kind of container

00:36:11,640 --> 00:36:17,309
object which itself contains some labels

00:36:13,680 --> 00:36:19,109
and some and some text right so that's

00:36:17,309 --> 00:36:20,730
that's great because now you have you

00:36:19,109 --> 00:36:22,380
have something that's addressable but on

00:36:20,730 --> 00:36:24,720
the other side now we know the code is

00:36:22,380 --> 00:36:26,400
addressable so so we have this code

00:36:24,720 --> 00:36:29,549
which which we showed you which somebody

00:36:26,400 --> 00:36:31,410
wrote but what we can do is we can pick

00:36:29,549 --> 00:36:34,380
up that code and we can we call it

00:36:31,410 --> 00:36:36,960
binding so we can bind these variables

00:36:34,380 --> 00:36:39,089
into the UI so we have these magic arrow

00:36:36,960 --> 00:36:41,670
operators which are part of a DSL and

00:36:39,089 --> 00:36:44,519
the arrow operators show that when the

00:36:41,670 --> 00:36:47,099
textbox changes we want the UI to like

00:36:44,519 --> 00:36:49,859
force its values into the running code

00:36:47,099 --> 00:36:51,089
and when the running code when the value

00:36:49,859 --> 00:36:53,339
of the function the bottom thing when

00:36:51,089 --> 00:36:55,529
that changes we want that value to be

00:36:53,339 --> 00:36:56,970
pushed back out into the UI now when we

00:36:55,529 --> 00:36:58,890
run this thing we run it in a completely

00:36:56,970 --> 00:37:01,079
different environment but because the

00:36:58,890 --> 00:37:02,369
scheduler owns the execution we're still

00:37:01,079 --> 00:37:04,499
running the same code that the user

00:37:02,369 --> 00:37:06,989
originally wrote but now we can detect

00:37:04,499 --> 00:37:08,759
when you when you call fuel cost like

00:37:06,989 --> 00:37:10,559
what do you depend on when you call fuel

00:37:08,759 --> 00:37:12,210
cost and that's that function runs we

00:37:10,559 --> 00:37:16,049
can detect all you do eventually depend

00:37:12,210 --> 00:37:17,609
on rate so now when the rate changes we

00:37:16,049 --> 00:37:21,829
know that we have to reevaluate the fuel

00:37:17,609 --> 00:37:21,829
cost so we can we can actually show that

00:37:28,150 --> 00:37:32,540
so here like justice it change to the

00:37:31,430 --> 00:37:38,450
number you need to have for them that's

00:37:32,540 --> 00:37:42,710
what they what sorry you are it's hard

00:37:38,450 --> 00:37:46,460
to see the lights very bright so so here

00:37:42,710 --> 00:37:48,250
when we change these values the the UI

00:37:46,460 --> 00:37:50,660
is pushing the new values into the

00:37:48,250 --> 00:37:52,910
calculation engine but the calculation

00:37:50,660 --> 00:37:55,700
engine knows which values on the screen

00:37:52,910 --> 00:37:57,770
are affected by the changes that it's

00:37:55,700 --> 00:38:00,050
receiving because when it ran the

00:37:57,770 --> 00:38:03,290
initial state it could record what was

00:38:00,050 --> 00:38:05,930
touched so now we can like create you

00:38:03,290 --> 00:38:07,609
eyes we also like we've got a kind of

00:38:05,930 --> 00:38:09,080
demo which we can't show the code for

00:38:07,609 --> 00:38:10,460
close a bit longer but just to show that

00:38:09,080 --> 00:38:15,410
we can build that much more complex you

00:38:10,460 --> 00:38:17,300
eyes we have this demo which is just to

00:38:15,410 --> 00:38:19,550
show that you know this isn't a toy you

00:38:17,300 --> 00:38:21,170
can build like very extensive

00:38:19,550 --> 00:38:23,990
applications that we have like sitting

00:38:21,170 --> 00:38:25,550
on numerous desktops at inside and

00:38:23,990 --> 00:38:28,609
Morgan Stanley there use it on daily

00:38:25,550 --> 00:38:30,590
basis and that's like a very it's a very

00:38:28,609 --> 00:38:33,950
powerful construct to be able to mix

00:38:30,590 --> 00:38:35,330
paradigms like UI and sequential

00:38:33,950 --> 00:38:41,420
processing together but still use the

00:38:35,330 --> 00:38:46,040
same original business logic code got it

00:38:41,420 --> 00:38:49,820
right okay so this is the code that the

00:38:46,040 --> 00:38:51,770
user writes and you know our big aim on

00:38:49,820 --> 00:38:53,720
this platform is to make it so that the

00:38:51,770 --> 00:38:54,710
code that people write is that is more

00:38:53,720 --> 00:38:56,300
like the code that they want to write

00:38:54,710 --> 00:38:59,119
and hopefully we've shown that in this

00:38:56,300 --> 00:39:00,950
talk today I did want to just talk a

00:38:59,119 --> 00:39:02,810
little bit about how we did it we have

00:39:00,950 --> 00:39:05,030
an extremely supportive stakeholder

00:39:02,810 --> 00:39:06,980
group within the bank they've backed us

00:39:05,030 --> 00:39:08,900
it's been a very difficult project but

00:39:06,980 --> 00:39:12,170
they're also very demanding and I think

00:39:08,900 --> 00:39:13,790
that you know you kind of need people to

00:39:12,170 --> 00:39:14,930
be to be a bit demanding because when

00:39:13,790 --> 00:39:16,670
you give them something that isn't quite

00:39:14,930 --> 00:39:18,830
right you they need to speak up and be

00:39:16,670 --> 00:39:20,660
vocal and I think that's what that that

00:39:18,830 --> 00:39:22,280
tensions worked really well we

00:39:20,660 --> 00:39:24,440
definitely didn't have kind of start

00:39:22,280 --> 00:39:26,210
with a plan we tried things and they

00:39:24,440 --> 00:39:28,700
didn't work and that we've come to this

00:39:26,210 --> 00:39:32,630
conclusion and and we think it's a very

00:39:28,700 --> 00:39:34,190
valuable one because we're able to do we

00:39:32,630 --> 00:39:36,170
were able to paralyze these things we

00:39:34,190 --> 00:39:39,770
were able to manage change we're able to

00:39:36,170 --> 00:39:40,430
execute across many machines an extreme

00:39:39,770 --> 00:39:43,250
scale

00:39:40,430 --> 00:39:45,260
I think that's really good we we do have

00:39:43,250 --> 00:39:47,030
a booth here and some of the people who

00:39:45,260 --> 00:39:49,790
worked on this project who made massive

00:39:47,030 --> 00:39:51,650
contributions are here today then thank

00:39:49,790 --> 00:39:55,040
you very much there's actually so many

00:39:51,650 --> 00:39:56,690
of you I can't list you but it is a it's

00:39:55,040 --> 00:40:00,890
a massive team effort to build something

00:39:56,690 --> 00:40:02,600
of this size and complexity but it's not

00:40:00,890 --> 00:40:06,610
all over we've got loads of stuff we

00:40:02,600 --> 00:40:08,960
still need to do we we really need to

00:40:06,610 --> 00:40:10,670
improve the way that we manage all of

00:40:08,960 --> 00:40:12,320
our execution so we can drive you for

00:40:10,670 --> 00:40:14,150
more efficiency for the applications

00:40:12,320 --> 00:40:16,250
that sit on our platform there are

00:40:14,150 --> 00:40:18,770
things that we can do to kind of improve

00:40:16,250 --> 00:40:21,140
the readability of the code because

00:40:18,770 --> 00:40:22,700
because at the moment there are

00:40:21,140 --> 00:40:24,650
decisions that we made early in the

00:40:22,700 --> 00:40:25,910
project about openness and you know

00:40:24,650 --> 00:40:28,490
everything can tweak everything and

00:40:25,910 --> 00:40:29,930
that's not necessarily great and then

00:40:28,490 --> 00:40:31,610
there are other optimizations that

00:40:29,930 --> 00:40:32,870
people are working on around the project

00:40:31,610 --> 00:40:36,200
and retreating towards you about pgo

00:40:32,870 --> 00:40:37,730
it's going to be awesome and there are

00:40:36,200 --> 00:40:40,400
other things like search can talk to you

00:40:37,730 --> 00:40:41,980
about how we move dates move processing

00:40:40,400 --> 00:40:43,640
on to other machines inside of the grid

00:40:41,980 --> 00:40:48,110
there are things that we can improve

00:40:43,640 --> 00:40:49,610
there and we are hiring so if you're

00:40:48,110 --> 00:40:51,320
interested in this stuff if you're

00:40:49,610 --> 00:40:53,000
interested in building applications on a

00:40:51,320 --> 00:40:55,120
platform like this or you're interested

00:40:53,000 --> 00:40:58,100
in building this platform we are hiring

00:40:55,120 --> 00:41:01,160
which I think it's a great project to

00:40:58,100 --> 00:41:03,230
work on and casillas we understand and

00:41:01,160 --> 00:41:05,240
there will be numerous people we are

00:41:03,230 --> 00:41:07,100
gonna do some questions now but if we

00:41:05,240 --> 00:41:09,290
don't get time to get to your question

00:41:07,100 --> 00:41:11,600
like come to our stand or kind of find

00:41:09,290 --> 00:41:13,520
us afterwards I I'm not sure how long we

00:41:11,600 --> 00:41:15,820
go up but we'll take some questions now

00:41:13,520 --> 00:41:19,660
thank you

00:41:15,820 --> 00:41:22,610
reimplementation of Monique's tasks

00:41:19,660 --> 00:41:25,190
backed by a this seems like a

00:41:22,610 --> 00:41:26,840
reemployment a ssin of Monique's tasks

00:41:25,190 --> 00:41:30,200
backed with a scheduler

00:41:26,840 --> 00:41:32,330
with some lazy valves thrown in it

00:41:30,200 --> 00:41:34,160
reminds me a lot of your pure functional

00:41:32,330 --> 00:41:38,260
programming maybe a little own scholar

00:41:34,160 --> 00:41:38,260
zio with effects how is it different

00:41:41,070 --> 00:41:46,900
okay so I think the big difference is

00:41:43,390 --> 00:41:50,650
that the there is not the invasion of

00:41:46,900 --> 00:41:52,300
hype system of the runtime constructs so

00:41:50,650 --> 00:41:53,710
in all those things you mentioned you

00:41:52,300 --> 00:41:55,840
know like in my examples they're mostly

00:41:53,710 --> 00:41:57,580
floats right so or doubles so in my

00:41:55,840 --> 00:41:59,560
examples the type that the program is

00:41:57,580 --> 00:42:03,369
dealing with is a double it's not a

00:41:59,560 --> 00:42:04,930
future of cancelable of double mm-hmm

00:42:03,369 --> 00:42:05,980
and so I think the biggest difference is

00:42:04,930 --> 00:42:08,200
that from a programming perspective

00:42:05,980 --> 00:42:09,190
you're much closer to dealing with the

00:42:08,200 --> 00:42:10,510
actual problem you're trying to solve

00:42:09,190 --> 00:42:13,180
which is that you're dealing with these

00:42:10,510 --> 00:42:15,490
doubles and these runtime execution

00:42:13,180 --> 00:42:18,160
concerns are not dominating your code so

00:42:15,490 --> 00:42:21,160
it's example like cash activity you know

00:42:18,160 --> 00:42:23,740
we had somebody we decommission the

00:42:21,160 --> 00:42:25,900
system then was the with with this and

00:42:23,740 --> 00:42:27,160
they and somebody very diligently went

00:42:25,900 --> 00:42:29,080
through all of the code in the old

00:42:27,160 --> 00:42:31,600
system and kind of classified what it

00:42:29,080 --> 00:42:34,330
was doing and you know 20% of that code

00:42:31,600 --> 00:42:35,680
was actually doing cash management right

00:42:34,330 --> 00:42:37,359
so now that code doesn't exist at all in

00:42:35,680 --> 00:42:39,100
that system and we obviously exist in

00:42:37,359 --> 00:42:40,450
the infrastructure but in the same way

00:42:39,100 --> 00:42:42,250
that you know memory management code

00:42:40,450 --> 00:42:43,990
doesn't exist in the Java program cash

00:42:42,250 --> 00:42:45,520
management program doesn't it's quite a

00:42:43,990 --> 00:42:47,650
cash management code doesn't exist in in

00:42:45,520 --> 00:42:48,910
that so I think that's the key

00:42:47,650 --> 00:42:50,109
difference is that we don't invade the

00:42:48,910 --> 00:42:52,750
type system with the concerns of

00:42:50,109 --> 00:42:56,080
execution which i think is one of the

00:42:52,750 --> 00:42:57,820
reasons why it's hard for the very good

00:42:56,080 --> 00:42:59,320
ideas that exist inside of functional

00:42:57,820 --> 00:43:00,790
programming to make traction with the

00:42:59,320 --> 00:43:04,270
kind of general population of

00:43:00,790 --> 00:43:06,300
programmers in the world hmm okay thank

00:43:04,270 --> 00:43:06,300

YouTube URL: https://www.youtube.com/watch?v=BW8S92jP5sE


