Title: 5 Things you Need to Know About Scala Compilation by Iulian Dragos
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/5-things-you-need-to-know-about-scala-compilation
Captions: 
	00:00:04,810 --> 00:00:08,280
thank you for your patience thanks for

00:00:06,760 --> 00:00:10,360
coming to my talk

00:00:08,280 --> 00:00:11,590
finally the five minutes are just great

00:00:10,360 --> 00:00:13,450
because I don't think I have enough

00:00:11,590 --> 00:00:18,160
material for 45 minutes this will just

00:00:13,450 --> 00:00:20,470
make it perfectly on time to finish my

00:00:18,160 --> 00:00:23,350
name is Julie Andra gosh I'm gonna talk

00:00:20,470 --> 00:00:26,260
today about a few things that you should

00:00:23,350 --> 00:00:30,700
know about the Scala compiler I've been

00:00:26,260 --> 00:00:33,879
working on Scala for probably since 2004

00:00:30,700 --> 00:00:36,460
so do the math I worked on the 2.0

00:00:33,879 --> 00:00:39,100
release which sounds a bit unbelievable

00:00:36,460 --> 00:00:41,589
now but there was a 2.0 release and

00:00:39,100 --> 00:00:43,839
afterwards I worked at live band for the

00:00:41,589 --> 00:00:45,789
Scala IDE for Eclipse I believe that's

00:00:43,839 --> 00:00:48,999
how it was if the full name was color ID

00:00:45,789 --> 00:00:51,609
for Eclipse to avoid confusion with

00:00:48,999 --> 00:00:54,309
other IDs and for the past year and a

00:00:51,609 --> 00:00:57,129
half I'm working on on a compiler called

00:00:54,309 --> 00:00:59,050
Hydra which is parallel Scala compiler

00:00:57,129 --> 00:01:02,499
but more about that later

00:00:59,050 --> 00:01:05,590
so I guess Scala a bit more than other

00:01:02,499 --> 00:01:07,240
languages require us to think in terms

00:01:05,590 --> 00:01:09,219
of what the Scala compiler would do from

00:01:07,240 --> 00:01:11,200
time to time and one of the reasons is

00:01:09,219 --> 00:01:13,299
that compilation is color can be slow

00:01:11,200 --> 00:01:17,229
it's not always slow but it can be slow

00:01:13,299 --> 00:01:21,070
and that usually depends on what kind of

00:01:17,229 --> 00:01:23,560
programs be writing oh and I should not

00:01:21,070 --> 00:01:25,329
forget the second part of this talk is

00:01:23,560 --> 00:01:27,130
going to be a quiz so make sure you have

00:01:25,329 --> 00:01:28,899
your phone ready and you're connected to

00:01:27,130 --> 00:01:31,119
the Internet we'll see then who paid

00:01:28,899 --> 00:01:34,299
attention I think that's the perfect

00:01:31,119 --> 00:01:36,039
antidote to the effect of having lunch

00:01:34,299 --> 00:01:40,149
and then working straight into a talk

00:01:36,039 --> 00:01:42,280
about compilers all right the first

00:01:40,149 --> 00:01:44,289
thing is actually quite of quite obvious

00:01:42,280 --> 00:01:47,469
but I think most people complain about

00:01:44,289 --> 00:01:48,880
scale of build times thinking that is

00:01:47,469 --> 00:01:51,340
really the compiler that's slowing them

00:01:48,880 --> 00:01:54,460
down but build time is not really

00:01:51,340 --> 00:01:56,170
compilation time and SBT is in the

00:01:54,460 --> 00:01:58,119
example in this case but I take any

00:01:56,170 --> 00:02:00,399
build tool and there's a bunch of things

00:01:58,119 --> 00:02:03,119
that happen every time you use it so

00:02:00,399 --> 00:02:05,890
before even getting to the compiler

00:02:03,119 --> 00:02:07,869
you'll have to do some steps like

00:02:05,890 --> 00:02:10,000
dependency resolution so on the right

00:02:07,869 --> 00:02:13,060
side you see a screenshot of SBT

00:02:10,000 --> 00:02:14,890
compiling itself so it will do

00:02:13,060 --> 00:02:17,140
dependency resolution which which says

00:02:14,890 --> 00:02:17,910
well I have these libraries that I

00:02:17,140 --> 00:02:19,680
depend on

00:02:17,910 --> 00:02:21,810
see if they changed or if the versions

00:02:19,680 --> 00:02:23,880
that I have are up-to-date you might

00:02:21,810 --> 00:02:25,860
have source generators maybe protocol

00:02:23,880 --> 00:02:28,500
buffers they need to generate some Scala

00:02:25,860 --> 00:02:30,510
code those are usually not the fastest

00:02:28,500 --> 00:02:32,760
things on the planet either you might

00:02:30,510 --> 00:02:34,980
have a formatter in this example the

00:02:32,760 --> 00:02:36,960
formatter even printed a very useful a

00:02:34,980 --> 00:02:38,370
message saying search state exploded

00:02:36,960 --> 00:02:40,530
around line a hundred seventy seven

00:02:38,370 --> 00:02:43,260
there cannot be good right it exploded

00:02:40,530 --> 00:02:45,210
so probably time is going in there also

00:02:43,260 --> 00:02:46,860
so I don't know if you want to format

00:02:45,210 --> 00:02:49,440
your sources everytime you compile but

00:02:46,860 --> 00:02:50,760
certainly this project does it then

00:02:49,440 --> 00:02:52,740
there's all the Settings graph

00:02:50,760 --> 00:02:54,950
evaluation that's not as fast as you

00:02:52,740 --> 00:02:54,950
might think

00:02:55,110 --> 00:03:00,540
then let's say we've done all these

00:02:57,960 --> 00:03:02,340
things and we start to compile so SBT

00:03:00,540 --> 00:03:05,610
will try to be really smart about what

00:03:02,340 --> 00:03:07,830
it compiles so first it will try to find

00:03:05,610 --> 00:03:10,530
out what changed since the last time so

00:03:07,830 --> 00:03:11,970
caching obviously it will go through

00:03:10,530 --> 00:03:14,400
your class but it will go through your

00:03:11,970 --> 00:03:16,740
sources it will hash them all but that

00:03:14,400 --> 00:03:18,330
means a lot of input output depending on

00:03:16,740 --> 00:03:20,190
your file system and operating system

00:03:18,330 --> 00:03:22,500
that can and of course the size of a

00:03:20,190 --> 00:03:25,590
project that can actually mean seconds

00:03:22,500 --> 00:03:28,350
it can take a lot of time then all this

00:03:25,590 --> 00:03:30,300
analysis that is loaded and saved on

00:03:28,350 --> 00:03:32,400
disk needs to be loaded and compared so

00:03:30,300 --> 00:03:36,600
if the project is large this can also be

00:03:32,400 --> 00:03:38,910
a now a number of seconds now finally

00:03:36,600 --> 00:03:41,640
SBT starts calling the Scala compiler

00:03:38,910 --> 00:03:43,830
and it starts compiling because it

00:03:41,640 --> 00:03:47,070
extracts additional information about

00:03:43,830 --> 00:03:49,110
what file depends on what it will slow

00:03:47,070 --> 00:03:52,290
down the regular Scala compiler so it

00:03:49,110 --> 00:03:55,680
needs to register or call back into its

00:03:52,290 --> 00:03:57,360
components whenever some dependency is

00:03:55,680 --> 00:03:58,970
detected between files and actually it's

00:03:57,360 --> 00:04:02,489
much more fine-grained than just files

00:03:58,970 --> 00:04:04,500
so that's overall 15 percent overhead

00:04:02,489 --> 00:04:05,910
I've seen a lot I've seen higher numbers

00:04:04,500 --> 00:04:08,459
but that's roughly what you're paying

00:04:05,910 --> 00:04:10,320
of course you're hoping that you would

00:04:08,459 --> 00:04:12,300
get back this time when you do an

00:04:10,320 --> 00:04:14,100
incremental compilation step because it

00:04:12,300 --> 00:04:16,140
will detect the minimum amount of

00:04:14,100 --> 00:04:18,570
sources it needs to compile without

00:04:16,140 --> 00:04:20,580
going through all of them probably on

00:04:18,570 --> 00:04:21,959
the CI though this is just wasted time I

00:04:20,580 --> 00:04:26,100
don't think on the CI you get

00:04:21,959 --> 00:04:29,160
incremental builds very often what can

00:04:26,100 --> 00:04:31,770
what lessons can we draw from this is I

00:04:29,160 --> 00:04:31,950
think at least that's how I do it are

00:04:31,770 --> 00:04:34,440
you

00:04:31,950 --> 00:04:36,660
an ID to build so the build tool is

00:04:34,440 --> 00:04:38,130
great if you do come a release or if you

00:04:36,660 --> 00:04:40,500
build on a command line the first time

00:04:38,130 --> 00:04:42,390
bring in all the dependencies format

00:04:40,500 --> 00:04:45,120
your sources if you want but for regular

00:04:42,390 --> 00:04:47,190
development an IDE can cut through all

00:04:45,120 --> 00:04:49,740
of those steps and just do compilations

00:04:47,190 --> 00:04:51,480
so you'll have a much faster cycle I

00:04:49,740 --> 00:04:53,250
think there's another tool called bloop

00:04:51,480 --> 00:04:54,750
so if you don't want to use an IDE you

00:04:53,250 --> 00:04:57,270
can use bloop on the command line for

00:04:54,750 --> 00:05:02,690
roughly the same thing and you'll get

00:04:57,270 --> 00:05:05,190
faster feedback all right number two

00:05:02,690 --> 00:05:07,440
type classes and macro derivation this

00:05:05,190 --> 00:05:09,120
is a very powerful combination and I

00:05:07,440 --> 00:05:13,200
think a lot of people use this day by

00:05:09,120 --> 00:05:15,210
day daily and one of the use cases is I

00:05:13,200 --> 00:05:17,220
guess JSON serialization so you have

00:05:15,210 --> 00:05:20,850
your nice case classes and you want to

00:05:17,220 --> 00:05:22,680
derive from them some type class you

00:05:20,850 --> 00:05:24,210
should be a JSON sterilizer while these

00:05:22,680 --> 00:05:28,410
things can work very well but they're

00:05:24,210 --> 00:05:31,320
also a ticking bomb so and one thing you

00:05:28,410 --> 00:05:33,360
have to be aware of is that you do not

00:05:31,320 --> 00:05:36,030
want to derive the type class every time

00:05:33,360 --> 00:05:37,710
you use it you would ideally generate it

00:05:36,030 --> 00:05:40,350
just once because if you have a case

00:05:37,710 --> 00:05:42,990
class and you have a JSON coder and

00:05:40,350 --> 00:05:47,100
decoder and encoder for that case class

00:05:42,990 --> 00:05:50,990
1 is enough but what one what one thing

00:05:47,100 --> 00:05:54,210
that happens often is that you have your

00:05:50,990 --> 00:05:56,700
imports that bring in those implicit

00:05:54,210 --> 00:06:00,000
that construct the type class derivation

00:05:56,700 --> 00:06:02,190
on the spot and you might also have one

00:06:00,000 --> 00:06:04,200
of these type class derived things in a

00:06:02,190 --> 00:06:06,480
companion object and your hope would be

00:06:04,200 --> 00:06:08,940
that it will go and pick up that one but

00:06:06,480 --> 00:06:10,860
actually import state precedence so what

00:06:08,940 --> 00:06:13,800
the compiler will do it will keep read

00:06:10,860 --> 00:06:16,470
generating the same type type class each

00:06:13,800 --> 00:06:19,230
time you need it which can really

00:06:16,470 --> 00:06:21,540
explode your your code size so the cost

00:06:19,230 --> 00:06:23,310
is not only the implicit resolution time

00:06:21,540 --> 00:06:25,110
which sometimes is slow and macro

00:06:23,310 --> 00:06:26,970
expansion but there's also additional

00:06:25,110 --> 00:06:28,980
code that needs to be generated

00:06:26,970 --> 00:06:30,870
afterwards all the way to the code

00:06:28,980 --> 00:06:35,210
generation phase through the compiler

00:06:30,870 --> 00:06:37,740
pipeline so if we take one example a

00:06:35,210 --> 00:06:40,170
class a case class for the full name

00:06:37,740 --> 00:06:42,780
with two fields and a shipping address

00:06:40,170 --> 00:06:45,850
with three fields and two of them are

00:06:42,780 --> 00:06:48,130
the full name now when we generate

00:06:45,850 --> 00:06:51,580
decoder for this class or let's say we

00:06:48,130 --> 00:06:53,260
need it twice the compiler help very

00:06:51,580 --> 00:06:56,790
helpful you will generate it twice so

00:06:53,260 --> 00:06:58,780
the code size if I if I comment both

00:06:56,790 --> 00:07:00,370
decoders in there it's going to be

00:06:58,780 --> 00:07:03,150
around eight kilobytes so I just did a

00:07:00,370 --> 00:07:05,890
print of the ASDs after type checking

00:07:03,150 --> 00:07:07,780
that becomes 31 kilobytes after

00:07:05,890 --> 00:07:09,670
uncommenting one of them and if i

00:07:07,780 --> 00:07:13,330
uncomment the second one it will double

00:07:09,670 --> 00:07:16,300
almost double again so why is that

00:07:13,330 --> 00:07:18,310
happening let's say that the compiler

00:07:16,300 --> 00:07:20,500
sees I need a decoder for this class

00:07:18,310 --> 00:07:23,320
shipping address I'm going to use

00:07:20,500 --> 00:07:25,690
probably shapeless to get out from the

00:07:23,320 --> 00:07:27,700
case class definition what are the

00:07:25,690 --> 00:07:30,010
components so in this case there are

00:07:27,700 --> 00:07:31,390
three of them and says well I need a

00:07:30,010 --> 00:07:33,370
decoder for full name

00:07:31,390 --> 00:07:36,190
I need a decoder for full name and I

00:07:33,370 --> 00:07:38,500
need a decoder for string it doesn't

00:07:36,190 --> 00:07:41,320
know at this point that H they could be

00:07:38,500 --> 00:07:44,380
the same anonymous class and then it

00:07:41,320 --> 00:07:46,000
goes down one more level and it sees

00:07:44,380 --> 00:07:50,020
that for full name it needs decoders for

00:07:46,000 --> 00:07:51,970
strings and that's about it now by

00:07:50,020 --> 00:07:54,310
default what you'll get is anonymous

00:07:51,970 --> 00:07:55,840
classes for these things being anonymous

00:07:54,310 --> 00:07:57,910
they can't be reused because there's no

00:07:55,840 --> 00:08:00,010
way to refer to the coder of full name

00:07:57,910 --> 00:08:03,810
unless you give it a name somewhere so

00:08:00,010 --> 00:08:07,990
this will basically generate several

00:08:03,810 --> 00:08:13,960
perfectly identical decoders for for

00:08:07,990 --> 00:08:17,710
full name alright moving on at number

00:08:13,960 --> 00:08:18,940
three we have white box macros and you

00:08:17,710 --> 00:08:20,860
guys know what's the difference between

00:08:18,940 --> 00:08:25,420
a macro that's white box and one that's

00:08:20,860 --> 00:08:28,750
black box all right oh I see one nodding

00:08:25,420 --> 00:08:31,420
head so a white box macro is allowed to

00:08:28,750 --> 00:08:33,610
introduce new types into your program

00:08:31,420 --> 00:08:36,610
that can be referred to by others or in

00:08:33,610 --> 00:08:38,469
other words once you expand the macro

00:08:36,610 --> 00:08:41,440
you might find that the resulting

00:08:38,469 --> 00:08:45,130
expression has a more precise type than

00:08:41,440 --> 00:08:47,320
before and and actually that can help

00:08:45,130 --> 00:08:49,240
the compiler in the next steps for

00:08:47,320 --> 00:08:52,600
example overload resolution or type

00:08:49,240 --> 00:08:54,490
inference black box macros though and I

00:08:52,600 --> 00:08:57,130
believe this is the only ones that will

00:08:54,490 --> 00:08:58,690
you know make the transition to Scala 3

00:08:57,130 --> 00:09:01,540
are much simpler

00:08:58,690 --> 00:09:03,310
concepts once a marker is expanded the

00:09:01,540 --> 00:09:05,410
expression that you get has the same

00:09:03,310 --> 00:09:09,850
type as what you had before you can't

00:09:05,410 --> 00:09:11,320
refine that to something more precise so

00:09:09,850 --> 00:09:13,570
this is a screenshot from the actual

00:09:11,320 --> 00:09:16,240
source code of the Scala compiler so you

00:09:13,570 --> 00:09:18,580
can easily see that the blackbox one is

00:09:16,240 --> 00:09:21,460
easily type checked by by invoking the

00:09:18,580 --> 00:09:23,350
type checker just once while for for a

00:09:21,460 --> 00:09:26,650
white box one it goes through three

00:09:23,350 --> 00:09:29,770
rounds it doesn't automatically mean

00:09:26,650 --> 00:09:32,800
it's three times slower but it does mean

00:09:29,770 --> 00:09:35,770
that it is a lot more work going on for

00:09:32,800 --> 00:09:38,500
a white box macro and shapeless markers

00:09:35,770 --> 00:09:41,230
are white box so I believe a lot of the

00:09:38,500 --> 00:09:44,230
ecosystem right now depends or uses

00:09:41,230 --> 00:09:46,710
replaced macros indirectly maybe so you

00:09:44,230 --> 00:09:49,150
are exposed to this potential

00:09:46,710 --> 00:09:53,620
compilation time explosion because of

00:09:49,150 --> 00:09:55,780
this this effects so I keep talking

00:09:53,620 --> 00:09:58,780
about type checking and how how long it

00:09:55,780 --> 00:10:02,380
takes to type check roughly the type

00:09:58,780 --> 00:10:04,690
checking phase should be around 30% of

00:10:02,380 --> 00:10:09,250
course the compiler will not report this

00:10:04,690 --> 00:10:11,110
to you but what you can do if you feel

00:10:09,250 --> 00:10:14,770
that compilation times are getting out

00:10:11,110 --> 00:10:17,710
of hand is to run Scala C once with -

00:10:14,770 --> 00:10:20,380
verbose on the command line and it will

00:10:17,710 --> 00:10:23,590
print timings for each phase if the type

00:10:20,380 --> 00:10:26,110
checking phase is really out of out of

00:10:23,590 --> 00:10:28,570
line so let's say it's 80% of your time

00:10:26,110 --> 00:10:31,180
then you should probably investigate and

00:10:28,570 --> 00:10:34,180
see what files are the ones that bring

00:10:31,180 --> 00:10:36,010
in either macro expansions implicit

00:10:34,180 --> 00:10:38,340
resolutions or generate a lot of code

00:10:36,010 --> 00:10:41,170
and try to break them down or

00:10:38,340 --> 00:10:44,470
potentially just make sure that you

00:10:41,170 --> 00:10:46,630
don't have the ticking bomb imports in

00:10:44,470 --> 00:10:52,060
there they just start regenerating all

00:10:46,630 --> 00:10:54,070
these type classes all the time so yeah

00:10:52,060 --> 00:10:56,980
I think I already mentioned in case this

00:10:54,070 --> 00:11:00,100
happens micro expansions are actually

00:10:56,980 --> 00:11:03,100
sometimes disguised so there are certain

00:11:00,100 --> 00:11:05,500
features in the standard library that

00:11:03,100 --> 00:11:07,780
are implemented as macros so quasi codes

00:11:05,500 --> 00:11:09,350
type tags some form of string

00:11:07,780 --> 00:11:11,650
interpolation

00:11:09,350 --> 00:11:13,880
they're all implemented as macros so

00:11:11,650 --> 00:11:16,340
project codes are actually relatively

00:11:13,880 --> 00:11:22,730
slow when you use them if you implement

00:11:16,340 --> 00:11:27,740
your own macros of course so we came up

00:11:22,730 --> 00:11:30,620
with one number to sort of summarize

00:11:27,740 --> 00:11:33,200
this this explosion factor and it's the

00:11:30,620 --> 00:11:34,880
typer 2 parser node factor that that

00:11:33,200 --> 00:11:37,100
means if I look at my program

00:11:34,880 --> 00:11:40,460
after just parsing the source code which

00:11:37,100 --> 00:11:44,060
is as close as it gets to what you wrote

00:11:40,460 --> 00:11:45,920
the programming Road and then you look

00:11:44,060 --> 00:11:47,540
at the same tree after type checking

00:11:45,920 --> 00:11:49,490
where all the macro expansions have

00:11:47,540 --> 00:11:51,370
happened type inference has kicked in

00:11:49,490 --> 00:11:53,300
and more or less the program is

00:11:51,370 --> 00:11:56,060
considered correct and ready for

00:11:53,300 --> 00:11:58,820
cogeneration a few phases down the line

00:11:56,060 --> 00:12:01,730
now what is this factor usually it

00:11:58,820 --> 00:12:04,700
shouldn't be much more than one you

00:12:01,730 --> 00:12:11,270
would expect it to be around more or

00:12:04,700 --> 00:12:14,060
less one well generally speaking type

00:12:11,270 --> 00:12:16,490
checking but not only for example case

00:12:14,060 --> 00:12:18,200
classes generate a lot more code for

00:12:16,490 --> 00:12:21,290
example a case class has a companion

00:12:18,200 --> 00:12:22,670
object which has a copy method and I'm

00:12:21,290 --> 00:12:24,200
sorry that's the case class itself it

00:12:22,670 --> 00:12:27,050
has a copy method it has a lot of

00:12:24,200 --> 00:12:29,260
default parameters as well and those are

00:12:27,050 --> 00:12:31,940
method definitions that themselves are

00:12:29,260 --> 00:12:33,770
implemented and so on so case classes

00:12:31,940 --> 00:12:36,650
add to the code that gets generated as

00:12:33,770 --> 00:12:38,690
well the bottom line is that more nodes

00:12:36,650 --> 00:12:41,630
need more time to type check and more

00:12:38,690 --> 00:12:43,550
coffee to drink so typically we see that

00:12:41,630 --> 00:12:46,460
this value is 1.2 sometimes

00:12:43,550 --> 00:12:48,770
interestingly it can be lower than 1 any

00:12:46,460 --> 00:12:53,930
guesses as to when that happens or why

00:12:48,770 --> 00:12:57,740
would that happen well it can still be

00:12:53,930 --> 00:13:00,440
macros macros can remove the some of the

00:12:57,740 --> 00:13:02,120
code you're passing to them but I think

00:13:00,440 --> 00:13:05,510
more often it happens when you have a

00:13:02,120 --> 00:13:07,340
lot of explicit types and after type

00:13:05,510 --> 00:13:08,810
checking all of those the large 3 is the

00:13:07,340 --> 00:13:10,460
described explicit type are replaced

00:13:08,810 --> 00:13:13,670
with one symbol and the type and those

00:13:10,460 --> 00:13:15,860
were are not counted by as an ast node

00:13:13,670 --> 00:13:19,570
so it's more more of an artifact of how

00:13:15,860 --> 00:13:19,570
how these nodes are counted

00:13:20,750 --> 00:13:25,910
so at number six we have the scholar

00:13:23,870 --> 00:13:28,490
compiler is single-threaded and I think

00:13:25,910 --> 00:13:30,620
this is relatively a common case form

00:13:28,490 --> 00:13:33,230
for many compilers but I was surprised

00:13:30,620 --> 00:13:34,670
to talk to people yesterday and they

00:13:33,230 --> 00:13:37,010
were actually surprised and said no

00:13:34,670 --> 00:13:39,860
others that cannot be true so why is

00:13:37,010 --> 00:13:43,790
that the case well it's a batch compiler

00:13:39,860 --> 00:13:47,450
it was written probably more than ten

00:13:43,790 --> 00:13:49,730
years ago it started and in the interest

00:13:47,450 --> 00:13:53,510
of performance and the hardware that was

00:13:49,730 --> 00:13:54,589
available 10 12 years ago it uses

00:13:53,510 --> 00:13:56,870
mutability

00:13:54,589 --> 00:13:59,660
for good reasons it makes certain things

00:13:56,870 --> 00:14:02,149
faster and for correctness or because of

00:13:59,660 --> 00:14:04,790
the language it also has to use laziness

00:14:02,149 --> 00:14:07,490
in in type checking in order to allow

00:14:04,790 --> 00:14:09,290
circular references I like Ali like a

00:14:07,490 --> 00:14:11,480
class referring back to itself you

00:14:09,290 --> 00:14:14,180
cannot be too eager when you type check

00:14:11,480 --> 00:14:16,070
those things so laziness is required it

00:14:14,180 --> 00:14:18,560
ability for performance if you put the

00:14:16,070 --> 00:14:21,170
two together you probably don't want to

00:14:18,560 --> 00:14:24,970
add multi-threading as well it will make

00:14:21,170 --> 00:14:27,500
for a very complicated piece of software

00:14:24,970 --> 00:14:29,930
but I have to say that that into twelve

00:14:27,500 --> 00:14:32,390
six I believe into 12 six not earlier

00:14:29,930 --> 00:14:34,790
there's an experimental experimental

00:14:32,390 --> 00:14:37,250
multi-threaded classifier generation

00:14:34,790 --> 00:14:38,959
phase which tries to use more more

00:14:37,250 --> 00:14:41,180
threads when the code is generated

00:14:38,959 --> 00:14:43,910
because at that point you do not have to

00:14:41,180 --> 00:14:45,770
worry about or so much about type

00:14:43,910 --> 00:14:50,420
checking and laziness in the types and

00:14:45,770 --> 00:14:52,250
symbols and so on but one consequence of

00:14:50,420 --> 00:14:54,860
that is that bigger and more powerful

00:14:52,250 --> 00:14:58,880
machines won't really make a dent in

00:14:54,860 --> 00:15:03,050
compilation times so my MacBook is from

00:14:58,880 --> 00:15:05,420
2016 my colleague has one from 2013 we'd

00:15:03,050 --> 00:15:09,130
have exactly the same compilation times

00:15:05,420 --> 00:15:12,920
with Scala on every project I tried it

00:15:09,130 --> 00:15:15,290
so unless you have a way to utilize more

00:15:12,920 --> 00:15:18,470
coarse single-threaded performance is

00:15:15,290 --> 00:15:19,970
not really improving anymore so unless

00:15:18,470 --> 00:15:23,990
you have a parallel Scala compiler you

00:15:19,970 --> 00:15:25,760
won't be really be able to improve well

00:15:23,990 --> 00:15:28,029
to improve compilation speeds or you

00:15:25,760 --> 00:15:30,380
need to have some other ways of

00:15:28,029 --> 00:15:33,260
utilizing the harder to get faster

00:15:30,380 --> 00:15:35,300
compilation so there is one that

00:15:33,260 --> 00:15:38,720
today of course that's that's Hydra but

00:15:35,300 --> 00:15:40,430
that's not why I'm here so how fast is

00:15:38,720 --> 00:15:41,990
color see this is also a question that

00:15:40,430 --> 00:15:44,960
comes up and people debate it is it

00:15:41,990 --> 00:15:46,730
compiling I don't know three thousand

00:15:44,960 --> 00:15:48,350
lines of code per second or five hundred

00:15:46,730 --> 00:15:50,960
lines of code per second and it's really

00:15:48,350 --> 00:15:52,850
dependent on the project so I put

00:15:50,960 --> 00:15:54,380
together a few numbers I think the more

00:15:52,850 --> 00:15:56,330
interesting part is the relative

00:15:54,380 --> 00:16:00,730
distance between them not the exact

00:15:56,330 --> 00:16:03,800
absolute number these are lines of code

00:16:00,730 --> 00:16:05,870
excluding comments and whitespace those

00:16:03,800 --> 00:16:07,610
are irrelevant so you might find higher

00:16:05,870 --> 00:16:12,110
numbers if you count those but I think

00:16:07,610 --> 00:16:15,170
that's a little bit uninformative so I

00:16:12,110 --> 00:16:17,870
said simple code which is sort of using

00:16:15,170 --> 00:16:19,490
Scala as a better Java and I take SPARC

00:16:17,870 --> 00:16:21,890
as an example of a large code base

00:16:19,490 --> 00:16:23,660
written in that style we've seen about a

00:16:21,890 --> 00:16:27,140
thousand two hundred lines of code per

00:16:23,660 --> 00:16:30,140
second average speed if we take

00:16:27,140 --> 00:16:33,170
functional programming sort of heavy

00:16:30,140 --> 00:16:35,840
kind of project like cats that goes down

00:16:33,170 --> 00:16:39,950
quite dramatically so 480 lines of code

00:16:35,840 --> 00:16:42,710
a second even less than half an

00:16:39,950 --> 00:16:46,040
interesting thing to note is that a play

00:16:42,710 --> 00:16:48,500
project has quite different compilation

00:16:46,040 --> 00:16:50,660
speeds and I guess it boils down to the

00:16:48,500 --> 00:16:53,150
kind of code you write so views which

00:16:50,660 --> 00:16:54,770
are roughly HTML embellished with some

00:16:53,150 --> 00:16:57,890
Scala expressions here and there they're

00:16:54,770 --> 00:16:59,590
quite fast to compile it with skylights

00:16:57,890 --> 00:17:01,490
2,000 eyes of code the second and

00:16:59,590 --> 00:17:03,320
controllers where there's a lot more

00:17:01,490 --> 00:17:06,829
logic and a lot more types involved

00:17:03,320 --> 00:17:10,070
those are again on the on par with with

00:17:06,829 --> 00:17:16,400
cats and functional programming style

00:17:10,070 --> 00:17:18,050
coding so so the numbers are with 212

00:17:16,400 --> 00:17:20,030
for I don't think there's a huge

00:17:18,050 --> 00:17:21,980
difference if you move to 212 6 the

00:17:20,030 --> 00:17:25,690
latest release correct me if I'm wrong

00:17:21,980 --> 00:17:30,530
for leech as I used to 11 11 because

00:17:25,690 --> 00:17:34,210
yeah the leech s is still on play 2.5 I

00:17:30,530 --> 00:17:38,870
believe and that's only supporting 211

00:17:34,210 --> 00:17:41,480
all right so at this point I will test

00:17:38,870 --> 00:17:44,410
your knowledge of Scala compilation so

00:17:41,480 --> 00:17:46,360
take out your

00:17:44,410 --> 00:17:50,920
phones and connect to let me see if this

00:17:46,360 --> 00:17:57,940
works so this is I'm taking here a bit

00:17:50,920 --> 00:18:00,520
of a risk so you should go to the hood

00:17:57,940 --> 00:18:03,940
IT website and enter the game pin that

00:18:00,520 --> 00:18:05,260
you see and I'll give you a few minutes

00:18:03,940 --> 00:18:09,310
to do that and then we have eight

00:18:05,260 --> 00:18:12,520
questions multiple answer and at the end

00:18:09,310 --> 00:18:16,960
we'll see who's who knows the most about

00:18:12,520 --> 00:18:19,750
colour compilation by the way the yeah

00:18:16,960 --> 00:18:26,220
the IDS are automatically generated by

00:18:19,750 --> 00:18:26,220
Kahoot so I hope that they're all nice

00:19:05,820 --> 00:19:15,370
seventy-nine players I didn't know the

00:19:07,630 --> 00:19:26,560
room is so big okay somebody's we seem

00:19:15,370 --> 00:19:28,570
to be capping at 80 81 okay let's start

00:19:26,560 --> 00:19:33,010
80 players I think that's that's not bad

00:19:28,570 --> 00:19:37,360
at all 81 anyone having troubles

00:19:33,010 --> 00:19:39,070
connecting can I start okay let's go so

00:19:37,360 --> 00:19:44,440
the first question should be easy it's

00:19:39,070 --> 00:19:49,110
gonna be a warm-up question so what was

00:19:44,440 --> 00:19:49,110
the host country of the World Cup 1994

00:19:49,470 --> 00:19:53,950
Italy Brazil USA or Russia by the way

00:19:52,360 --> 00:19:57,240
the fastest your answer the more points

00:19:53,950 --> 00:19:57,240
you get if I'm not mistaken

00:20:17,820 --> 00:20:28,330
all right so USA was the host country in

00:20:22,420 --> 00:20:31,510
1994 not Brazil not Brazil that was more

00:20:28,330 --> 00:20:35,230
recent I think ok radiant ferret good

00:20:31,510 --> 00:20:37,600
job so the next question is how many

00:20:35,230 --> 00:20:40,720
instances of decoder of full-name are

00:20:37,600 --> 00:20:44,160
generated in this code so full name not

00:20:40,720 --> 00:20:47,850
shipping address right the one up here

00:20:44,160 --> 00:20:47,850
1 2 3 or 4

00:21:07,470 --> 00:21:14,370
we have 83 answers but I thought there

00:21:09,940 --> 00:21:14,370
were only 81 players what's happening

00:21:16,830 --> 00:21:21,970
can I can I close no I don't want to

00:21:20,650 --> 00:21:25,090
skip because I actually want to see the

00:21:21,970 --> 00:21:37,690
answers but let's wait let's wait

00:21:25,090 --> 00:21:40,300
another 10 seconds all right

00:21:37,690 --> 00:21:43,150
most people got it so 4 4 4 instances

00:21:40,300 --> 00:21:46,020
and the reason is because this recursive

00:21:43,150 --> 00:21:48,280
expansion is generating anonymous

00:21:46,020 --> 00:21:50,530
instances of this decoder so they can't

00:21:48,280 --> 00:21:52,270
really be reused each one will be just

00:21:50,530 --> 00:21:55,270
an anonymous class that gets passed

00:21:52,270 --> 00:21:58,530
right there where it's needed good let's

00:21:55,270 --> 00:22:01,180
see stellar Falcon has taken the lead

00:21:58,530 --> 00:22:04,600
what was the most important new feature

00:22:01,180 --> 00:22:07,060
in Scala dude 2.9 dot zero so we have

00:22:04,600 --> 00:22:09,820
new collections library parallel

00:22:07,060 --> 00:22:12,090
collections xml literals or triple

00:22:09,820 --> 00:22:12,090
quotes

00:22:32,450 --> 00:22:38,940
our collections correct new collections

00:22:36,030 --> 00:22:40,800
library is coming up in 213 if I'm or

00:22:38,940 --> 00:22:45,660
there was okay again the old new

00:22:40,800 --> 00:22:49,530
collections were in 2 8 0 I think speedy

00:22:45,660 --> 00:22:51,390
speedy egrant alright

00:22:49,530 --> 00:22:53,520
we're halfway through how many lines of

00:22:51,390 --> 00:22:59,190
code per second does Scala see compile

00:22:53,520 --> 00:23:00,960
in a typical project so twelve hundred

00:22:59,190 --> 00:23:03,780
lines of code three thousand five

00:23:00,960 --> 00:23:06,230
thousand three hundred it should be an

00:23:03,780 --> 00:23:06,230
easy one

00:23:22,940 --> 00:23:29,130
all right the large majority got it

00:23:27,600 --> 00:23:32,630
right somebody was very pessimistic

00:23:29,130 --> 00:23:35,220
saying only 309th of coal per second and

00:23:32,630 --> 00:23:41,370
we also had four very optimistic people

00:23:35,220 --> 00:23:43,350
at 5,000 lines of code I wish how many

00:23:41,370 --> 00:23:46,320
lines of code of course next question I

00:23:43,350 --> 00:23:49,320
think it was pretty obvious the scholar

00:23:46,320 --> 00:23:53,130
companion a typical purely functional

00:23:49,320 --> 00:24:05,160
programming style so four hundred eight

00:23:53,130 --> 00:24:07,260
hundred thousand or five thousand can

00:24:05,160 --> 00:24:08,730
anyone guess since I see all the answers

00:24:07,260 --> 00:24:15,840
are up there where is this screenshot

00:24:08,730 --> 00:24:19,920
taken from what library Katz correct

00:24:15,840 --> 00:24:22,590
okay so again a four people are

00:24:19,920 --> 00:24:31,040
consistently very optimistic 5,000 eyes

00:24:22,590 --> 00:24:33,330
of God per second yeah you think

00:24:31,040 --> 00:24:35,340
all right speedy a great seems to be

00:24:33,330 --> 00:24:37,350
consolidating the advantage and staying

00:24:35,340 --> 00:24:38,910
ahead which ones of the following

00:24:37,350 --> 00:24:42,710
scholar features are implemented as

00:24:38,910 --> 00:24:45,060
macros so string interpolation type tags

00:24:42,710 --> 00:24:50,310
formatted string interpolation and quasi

00:24:45,060 --> 00:24:52,500
quotes well more than one is correct

00:24:50,310 --> 00:24:54,740
here there's not just one answer that's

00:24:52,500 --> 00:24:54,740
correct

00:25:31,620 --> 00:25:36,610
so there is one that's not a macro in

00:25:34,300 --> 00:25:38,310
there there is one answer that's not

00:25:36,610 --> 00:25:44,920
correct

00:25:38,310 --> 00:25:47,260
okay so just plain string interpolation

00:25:44,920 --> 00:25:49,120
is actually not the macro it's formatted

00:25:47,260 --> 00:25:50,830
string interpolation that that needs to

00:25:49,120 --> 00:25:53,470
be a macro because you want to make sure

00:25:50,830 --> 00:25:55,420
that whatever you're passing and fits

00:25:53,470 --> 00:25:57,940
into the string is actually the right

00:25:55,420 --> 00:26:01,750
type so percent in percent D it actually

00:25:57,940 --> 00:26:03,160
takes an int and so on type tags they

00:26:01,750 --> 00:26:05,550
must be a macro because you want to

00:26:03,160 --> 00:26:08,110
verify a type into something that can be

00:26:05,550 --> 00:26:11,050
inspected at runtime by the by your

00:26:08,110 --> 00:26:18,430
program and fuzzy cause roughly the same

00:26:11,050 --> 00:26:20,110
the same reasons alright let's go to the

00:26:18,430 --> 00:26:22,060
seventh question what implicit is

00:26:20,110 --> 00:26:27,180
selected here and what does this program

00:26:22,060 --> 00:26:27,180
print so this is a minute and a half

00:27:02,300 --> 00:27:07,940
so essentially there are two ways to get

00:27:04,280 --> 00:27:09,410
that implicit one is from the companion

00:27:07,940 --> 00:27:11,980
object of foo and the other one is from

00:27:09,410 --> 00:27:11,980
the import

00:27:53,370 --> 00:27:59,770
correct though most people got it it's

00:27:56,290 --> 00:28:01,930
the one from the import so the I think

00:27:59,770 --> 00:28:04,150
the confusing part is that if you're

00:28:01,930 --> 00:28:06,640
going the import route you actually have

00:28:04,150 --> 00:28:08,680
to jump through two hops so there's an

00:28:06,640 --> 00:28:10,240
implicit that needs a second implicit in

00:28:08,680 --> 00:28:13,320
order to give you the value you need

00:28:10,240 --> 00:28:15,820
list the fool while the companion object

00:28:13,320 --> 00:28:17,680
gives it in one hop which it actually

00:28:15,820 --> 00:28:19,090
has a field with the right type but

00:28:17,680 --> 00:28:21,940
that's not how implicit the resolution

00:28:19,090 --> 00:28:25,810
works implicit resolution takes imports

00:28:21,940 --> 00:28:27,640
as a higher priority if you want so it

00:28:25,810 --> 00:28:29,920
goes down the import route and it

00:28:27,640 --> 00:28:33,040
constructs the implicit even though it's

00:28:29,920 --> 00:28:35,380
a more complicated so to say term that

00:28:33,040 --> 00:28:36,970
it creates that way then if it was then

00:28:35,380 --> 00:28:41,220
then taking the one from the companion

00:28:36,970 --> 00:28:43,900
object so and it does compile I checked

00:28:41,220 --> 00:28:46,720
speedy a great still ahead and royal

00:28:43,900 --> 00:28:49,780
elephant is actually second now cool

00:28:46,720 --> 00:28:52,990
last question when was Scala first

00:28:49,780 --> 00:28:57,580
publicly announced so January 20 2004

00:28:52,990 --> 00:29:02,220
July 1st 2006 September 1st 2020 so it's

00:28:57,580 --> 00:29:05,220
it's from the future or January 23rd

00:29:02,220 --> 00:29:05,220
00:29:33,910 --> 00:29:40,970
all right most people guessed right this

00:29:38,480 --> 00:29:42,590
2004 I guess if you actually could read

00:29:40,970 --> 00:29:46,280
the announcement email you would see

00:29:42,590 --> 00:29:48,320
that it requires Java 1.4 so again it

00:29:46,280 --> 00:29:52,160
gives the gives at least some reference

00:29:48,320 --> 00:29:55,010
point anybody knows what happened on

00:29:52,160 --> 00:30:00,590
January 23 1996 what was released on

00:29:55,010 --> 00:30:02,650
that date Java exactly all right I think

00:30:00,590 --> 00:30:03,920
that's it so speedy a grits

00:30:02,650 --> 00:30:07,309
congratulations

00:30:03,920 --> 00:30:09,350
yeah come by our booth and you can get a

00:30:07,309 --> 00:30:14,120
hydro license to speed up your

00:30:09,350 --> 00:30:15,530
compilation even more thanks for

00:30:14,120 --> 00:30:17,660
participating I think it's great I'm

00:30:15,530 --> 00:30:20,840
very glad that everyone could connect

00:30:17,660 --> 00:30:24,350
and had had access to the to the

00:30:20,840 --> 00:30:26,300
Internet in time to summarize I guess

00:30:24,350 --> 00:30:28,670
what this talk is about this compilation

00:30:26,300 --> 00:30:30,920
times are unpredictable and you can

00:30:28,670 --> 00:30:33,590
often have one single file account for a

00:30:30,920 --> 00:30:37,850
really 80% of compilation time and most

00:30:33,590 --> 00:30:40,550
of that goes into macro expansions and

00:30:37,850 --> 00:30:42,380
implicit search and and things like that

00:30:40,550 --> 00:30:45,440
so compilation speed really varies

00:30:42,380 --> 00:30:48,020
according to your coding style and then

00:30:45,440 --> 00:30:50,230
macro expansion if use and will they can

00:30:48,020 --> 00:30:53,510
really increase your code size

00:30:50,230 --> 00:30:55,670
impressively so thank you a lot thanks

00:30:53,510 --> 00:30:58,070
thanks a lot for your attention

00:30:55,670 --> 00:31:00,080
Hydra is our product a parallel Scala

00:30:58,070 --> 00:31:02,000
compiler that goes faster so if you're

00:31:00,080 --> 00:31:03,470
interested in what we do come by our

00:31:02,000 --> 00:31:05,360
booth we are next to the light Bank

00:31:03,470 --> 00:31:08,110
booth and I'd be happy to talk to you

00:31:05,360 --> 00:31:08,110
about it some more

00:31:08,210 --> 00:31:13,700

YouTube URL: https://www.youtube.com/watch?v=YFXoNTp6YmM


