Title: Unshaped Protos Beyond Code Generation for Protocol Buffers by Nadav Samet
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/unshaped-protos-beyond-code-generation-for-protocol-buffers
Captions: 
	00:00:04,910 --> 00:00:11,879
hi everyone welcome to my talk

00:00:09,030 --> 00:00:14,099
my name is Nadav summit I'm an

00:00:11,879 --> 00:00:16,049
engineering manager in a start-up called

00:00:14,099 --> 00:00:18,119
the two blue labs and I'm also the

00:00:16,049 --> 00:00:21,240
author of a library called Scala PB

00:00:18,119 --> 00:00:24,420
which makes it fun and easy to use

00:00:21,240 --> 00:00:26,310
protocol buffers in Scala so in case you

00:00:24,420 --> 00:00:28,679
didn't know protocol buffers is a

00:00:26,310 --> 00:00:30,750
technology developed by Google that

00:00:28,679 --> 00:00:34,230
allows distributed systems to exchange

00:00:30,750 --> 00:00:36,839
messages in an efficient binary format

00:00:34,230 --> 00:00:39,030
I developed scalloped EB because I

00:00:36,839 --> 00:00:41,850
wanted to have an idiomatic way to use

00:00:39,030 --> 00:00:44,309
protocol buffers in Scala I started this

00:00:41,850 --> 00:00:45,930
project about four years ago and it's

00:00:44,309 --> 00:00:47,879
been growing in popularity

00:00:45,930 --> 00:00:49,199
ever since then one of the things I

00:00:47,879 --> 00:00:51,260
really liked in coming to conferences

00:00:49,199 --> 00:00:55,229
like this one is that I get to meet a

00:00:51,260 --> 00:00:56,820
actual users of my project and this is

00:00:55,229 --> 00:00:58,290
one of the more rewarding things that

00:00:56,820 --> 00:00:59,640
happen when you do open source so you

00:00:58,290 --> 00:01:00,809
actually see that the people that you're

00:00:59,640 --> 00:01:05,430
working with a deal and they actually

00:01:00,809 --> 00:01:05,939
exist so my story is that about six

00:01:05,430 --> 00:01:09,750
months ago

00:01:05,939 --> 00:01:12,210
a user tells me that they want to use

00:01:09,750 --> 00:01:15,210
kara PB but without giving it any

00:01:12,210 --> 00:01:18,390
protocol buffers and asks me if it's

00:01:15,210 --> 00:01:20,429
possible to do it now the entire point

00:01:18,390 --> 00:01:22,920
of Scala PB is that it's a tool that

00:01:20,429 --> 00:01:24,479
take protocol buffers and it generate

00:01:22,920 --> 00:01:25,490
case classes for them with the

00:01:24,479 --> 00:01:28,320
serialization and deserialization

00:01:25,490 --> 00:01:30,270
methods so telling me that somebody

00:01:28,320 --> 00:01:32,280
wants to use scar PB but without giving

00:01:30,270 --> 00:01:33,749
it any protocol buffers it's like

00:01:32,280 --> 00:01:35,399
telling me that they want to make a

00:01:33,749 --> 00:01:37,200
peanut butter and jelly sandwich but

00:01:35,399 --> 00:01:39,270
without the peanut butter so that

00:01:37,200 --> 00:01:41,340
sounded a little bit crazy to me but

00:01:39,270 --> 00:01:44,159
then I kind of took a big breath and I

00:01:41,340 --> 00:01:46,469
come down and they thought about it and

00:01:44,159 --> 00:01:48,630
I figured out that there is a actually

00:01:46,469 --> 00:01:50,520
an interesting problem to solve here

00:01:48,630 --> 00:01:51,899
basically what this user is saying I

00:01:50,520 --> 00:01:53,939
don't know write protocol buffers I

00:01:51,899 --> 00:01:57,420
already have my case classes with my

00:01:53,939 --> 00:01:59,189
domain model I would like you to infer

00:01:57,420 --> 00:02:02,159
the protocol buffer schema from my case

00:01:59,189 --> 00:02:04,350
classes and from that generate

00:02:02,159 --> 00:02:05,759
serializers initializes for me I just

00:02:04,350 --> 00:02:08,160
want to I don't want to deal with

00:02:05,759 --> 00:02:09,509
protocol buffers so as I was exploring

00:02:08,160 --> 00:02:12,330
this

00:02:09,509 --> 00:02:14,400
this users problem and trying to figure

00:02:12,330 --> 00:02:16,290
out how to do how to how to do this I

00:02:14,400 --> 00:02:19,349
learned a few interesting techniques

00:02:16,290 --> 00:02:22,829
about dealing with the use of data types

00:02:19,349 --> 00:02:24,689
the case classes in a generic way and

00:02:22,829 --> 00:02:26,400
the beauty of these techniques which I

00:02:24,689 --> 00:02:28,890
want to show you today is that they're

00:02:26,400 --> 00:02:31,140
not specific to Scala PBO to protocol

00:02:28,890 --> 00:02:34,290
buffers they can be applied in any

00:02:31,140 --> 00:02:35,790
situation where you need to deal with

00:02:34,290 --> 00:02:37,409
the datatype that the user gives you and

00:02:35,790 --> 00:02:39,209
you kind of wanna go field by field may

00:02:37,409 --> 00:02:41,700
be serialized may be print may be do

00:02:39,209 --> 00:02:44,430
things like that so what I'd like to ask

00:02:41,700 --> 00:02:46,920
from you as we go through the my path of

00:02:44,430 --> 00:02:48,540
exploring this try to think if this is

00:02:46,920 --> 00:02:50,010
relevant to anything that you're walking

00:02:48,540 --> 00:02:52,709
on because these techniques are really

00:02:50,010 --> 00:02:54,359
powerful if you can master them they can

00:02:52,709 --> 00:02:55,829
save you a lot of repetitive code and

00:02:54,359 --> 00:02:58,200
you know fuel code means fewer bugs

00:02:55,829 --> 00:03:03,540
fuels better life in general

00:02:58,200 --> 00:03:05,370
so a pay attention so and I briefly told

00:03:03,540 --> 00:03:07,139
you what protocol buffers are but let's

00:03:05,370 --> 00:03:08,849
cover this in a bit more detail in case

00:03:07,139 --> 00:03:11,519
you haven't never seen them before

00:03:08,849 --> 00:03:13,260
so protocol buffers is a language to

00:03:11,519 --> 00:03:15,989
describe data structure it's a format to

00:03:13,260 --> 00:03:18,269
define messages and it comes with a

00:03:15,989 --> 00:03:19,739
binary specific binary format that is

00:03:18,269 --> 00:03:23,160
well understood well document quite

00:03:19,739 --> 00:03:24,989
simple and there are code generators

00:03:23,160 --> 00:03:27,900
that already exist the official ones for

00:03:24,989 --> 00:03:32,879
Java C++ and Python and my library Scala

00:03:27,900 --> 00:03:34,799
PB as a support for Scala and the beauty

00:03:32,879 --> 00:03:37,500
of this system is that you can start

00:03:34,799 --> 00:03:39,299
with a protocol buffer and generate code

00:03:37,500 --> 00:03:41,160
in Java and another one for superpowers

00:03:39,299 --> 00:03:43,230
and Python and different themes in your

00:03:41,160 --> 00:03:45,449
organization can just use the same

00:03:43,230 --> 00:03:47,340
protocol buffer as a reference and the

00:03:45,449 --> 00:03:48,599
different languages different platforms

00:03:47,340 --> 00:03:51,180
different projects can just exchange

00:03:48,599 --> 00:03:52,919
messages UC relies on one side you dis

00:03:51,180 --> 00:03:54,329
really in a different place when you

00:03:52,919 --> 00:03:57,480
just get essentially the same data but

00:03:54,329 --> 00:03:59,970
in a different language here is an

00:03:57,480 --> 00:04:02,750
example of a very simple protocol buffer

00:03:59,970 --> 00:04:06,030
we have a definition of a person message

00:04:02,750 --> 00:04:08,010
and it has three fields first name which

00:04:06,030 --> 00:04:10,680
is a string a last name which is another

00:04:08,010 --> 00:04:12,540
string an age which is an integer and

00:04:10,680 --> 00:04:14,159
you notice that every field is followed

00:04:12,540 --> 00:04:17,010
by a tag number it's a running number

00:04:14,159 --> 00:04:18,690
this 1 2 3 at the right side and these

00:04:17,010 --> 00:04:20,970
are used when you serialize the message

00:04:18,690 --> 00:04:23,610
we actually encode the

00:04:20,970 --> 00:04:25,860
in a binary format that number this is

00:04:23,610 --> 00:04:28,020
unlike Jason when we encode the field

00:04:25,860 --> 00:04:30,840
name that the key and this results in a

00:04:28,020 --> 00:04:32,940
m-- in a more efficient a binary format

00:04:30,840 --> 00:04:34,800
but it also allows us to the name

00:04:32,940 --> 00:04:37,200
messages because the number is a part of

00:04:34,800 --> 00:04:38,820
the of the of the encoding so if your

00:04:37,200 --> 00:04:40,350
message gets renamed you can still walk

00:04:38,820 --> 00:04:43,950
with things you already persisted

00:04:40,350 --> 00:04:45,870
because it's just about the number and

00:04:43,950 --> 00:04:47,670
once you have this a this protocol

00:04:45,870 --> 00:04:50,660
buffer defined you can use the proto C

00:04:47,670 --> 00:04:52,860
command-line tool to generate a

00:04:50,660 --> 00:04:56,430
serializers and deserialize in different

00:04:52,860 --> 00:04:58,710
languages like Java Python and C++ and

00:04:56,430 --> 00:05:00,150
if you are using SBT there is an SBT

00:04:58,710 --> 00:05:03,030
plug-in which I wrote that lets you

00:05:00,150 --> 00:05:08,250
generate for those languages as well as

00:05:03,030 --> 00:05:09,870
well as Scala and so on the left side

00:05:08,250 --> 00:05:11,880
you'll see the protocol baffle and and

00:05:09,870 --> 00:05:13,200
the right side you see like a simplified

00:05:11,880 --> 00:05:15,930
version of the code that gets generated

00:05:13,200 --> 00:05:17,640
you will see a case class that basically

00:05:15,930 --> 00:05:20,190
as a field that corresponds to every

00:05:17,640 --> 00:05:22,200
field in the protocol buffer and there

00:05:20,190 --> 00:05:24,990
is a method there called two byte array

00:05:22,200 --> 00:05:27,570
that would take the the instance and the

00:05:24,990 --> 00:05:29,580
return an array of byte a in a binary

00:05:27,570 --> 00:05:32,040
format a the protocol buffer binary

00:05:29,580 --> 00:05:34,800
format in the companion object there is

00:05:32,040 --> 00:05:37,230
an inverse method a called parse from

00:05:34,800 --> 00:05:38,910
which takes an array of byte and gives

00:05:37,230 --> 00:05:42,870
us back the instance of a person we just

00:05:38,910 --> 00:05:44,820
realized here's how you out the BOK in

00:05:42,870 --> 00:05:48,150
practice you instantiate a person object

00:05:44,820 --> 00:05:49,770
in scala you call two byte array you get

00:05:48,150 --> 00:05:52,680
back an array of bytes I call it two

00:05:49,770 --> 00:05:54,780
vector just with randos more nicely and

00:05:52,680 --> 00:05:57,570
but you get a bunch of numbers that

00:05:54,780 --> 00:05:59,340
represents the message and you can go

00:05:57,570 --> 00:06:01,530
also in the opposite direction you start

00:05:59,340 --> 00:06:03,810
on the array of bytes you pass it to a

00:06:01,530 --> 00:06:06,450
parse from and you get back to original

00:06:03,810 --> 00:06:07,950
instance you've had that's everything

00:06:06,450 --> 00:06:11,730
you need to know about protocol buffers

00:06:07,950 --> 00:06:13,890
for this talk so and this problem mostly

00:06:11,730 --> 00:06:16,919
what water is to it so remember the guy

00:06:13,890 --> 00:06:18,510
that wanted to use a scallop abhi but

00:06:16,919 --> 00:06:20,820
without writing any protocol buffers so

00:06:18,510 --> 00:06:24,060
let's first understand why would anybody

00:06:20,820 --> 00:06:26,520
want to do that there are a few reasons

00:06:24,060 --> 00:06:28,410
so some people have an allergic reaction

00:06:26,520 --> 00:06:30,750
to cogeneration every time the code

00:06:28,410 --> 00:06:32,610
generation they feel that they can deal

00:06:30,750 --> 00:06:34,260
with it they don't like this step that

00:06:32,610 --> 00:06:36,000
comes before you compile that suddenly

00:06:34,260 --> 00:06:38,280
additional source files appear I

00:06:36,000 --> 00:06:41,610
understand that we disagree but I

00:06:38,280 --> 00:06:43,530
understand it and another reason for

00:06:41,610 --> 00:06:44,850
having protocol buffers is that when you

00:06:43,530 --> 00:06:46,979
have multiple teams work in different

00:06:44,850 --> 00:06:48,810
languages different code bases and they

00:06:46,979 --> 00:06:51,360
want to share some some some interface

00:06:48,810 --> 00:06:53,400
some some spec but sometimes you just

00:06:51,360 --> 00:06:55,380
have Scala code and everything is

00:06:53,400 --> 00:06:57,390
transient and you don't need all these

00:06:55,380 --> 00:06:59,760
say features that come with portable

00:06:57,390 --> 00:07:01,020
buffers and this interval probability is

00:06:59,760 --> 00:07:04,740
just not the concern that you have in

00:07:01,020 --> 00:07:06,120
your project and they finally when you

00:07:04,740 --> 00:07:08,520
generate code you don't have a lot of

00:07:06,120 --> 00:07:10,770
control about what methods goes it go

00:07:08,520 --> 00:07:12,479
inside what it extends so if you start

00:07:10,770 --> 00:07:15,120
with your own case classes you can just

00:07:12,479 --> 00:07:16,620
do whatever you want and the aspect of

00:07:15,120 --> 00:07:23,039
serialization this realization is just

00:07:16,620 --> 00:07:24,360
like outside of that case class so this

00:07:23,039 --> 00:07:25,950
is what we're gonna do we're going to

00:07:24,360 --> 00:07:27,599
let the user define their own case class

00:07:25,950 --> 00:07:29,630
this way they're just gonna say case

00:07:27,599 --> 00:07:32,310
class they find the fields they want a

00:07:29,630 --> 00:07:35,010
maybe they add the methods they want and

00:07:32,310 --> 00:07:36,750
then they gonna instantiate it and now

00:07:35,010 --> 00:07:38,460
we need to give them a way to serialize

00:07:36,750 --> 00:07:40,770
the protocol buffers so we need to give

00:07:38,460 --> 00:07:42,840
them a way to call to byte array but

00:07:40,770 --> 00:07:44,340
this doesn't compile right now right

00:07:42,840 --> 00:07:46,800
because this is just the case class does

00:07:44,340 --> 00:07:49,080
not two byte array method on it and this

00:07:46,800 --> 00:07:51,030
is our problem to solve so a common

00:07:49,080 --> 00:07:54,630
idiom in Scala in situations like this

00:07:51,030 --> 00:07:58,530
is to introduce a type class pattern so

00:07:54,630 --> 00:08:00,390
the idea would be to define a trait

00:07:58,530 --> 00:08:02,849
called message serializer that takes a

00:08:00,390 --> 00:08:04,349
type parameter T and T would be the

00:08:02,849 --> 00:08:06,750
thing that we want to serialize the

00:08:04,349 --> 00:08:08,729
person in our example and it will have a

00:08:06,750 --> 00:08:10,860
two byte array method inside it that

00:08:08,729 --> 00:08:14,610
would take an instance and return an

00:08:10,860 --> 00:08:16,380
array of bytes and another idiom that

00:08:14,610 --> 00:08:18,960
you'd see with with type classes is they

00:08:16,380 --> 00:08:20,990
apply method inside the companion object

00:08:18,960 --> 00:08:23,190
that acts as a sort of the constructor

00:08:20,990 --> 00:08:25,110
but instead of really building a new

00:08:23,190 --> 00:08:27,660
object it's it runs an implicit search

00:08:25,110 --> 00:08:30,390
and it returns back the instance that it

00:08:27,660 --> 00:08:32,459
finds so this is enabling the syntax

00:08:30,390 --> 00:08:34,530
that you sing on the on the first line

00:08:32,459 --> 00:08:35,969
in the second window where we just write

00:08:34,530 --> 00:08:38,849
message still eyes of a person it

00:08:35,969 --> 00:08:41,070
actually calls apply and starts the

00:08:38,849 --> 00:08:42,940
implicit search assuming we are done and

00:08:41,070 --> 00:08:45,730
we have a message serializer for

00:08:42,940 --> 00:08:48,820
any type T we can just use it to

00:08:45,730 --> 00:08:50,830
civilize the array of whites so how can

00:08:48,820 --> 00:08:53,920
we go about doing those message

00:08:50,830 --> 00:08:55,750
serializers for type T for any user

00:08:53,920 --> 00:08:59,470
provided a type I we go generically

00:08:55,750 --> 00:09:01,300
about this problem so it turns out that

00:08:59,470 --> 00:09:04,690
the two byte array is normally

00:09:01,300 --> 00:09:07,630
implemented in terms of two lower-level

00:09:04,690 --> 00:09:09,220
methods what you really need to do is to

00:09:07,630 --> 00:09:10,690
find the size of the message that how

00:09:09,220 --> 00:09:12,580
many byte is going to be once you know

00:09:10,690 --> 00:09:15,040
that you are locating an array of bytes

00:09:12,580 --> 00:09:16,780
on that size then you wrap it up in

00:09:15,040 --> 00:09:19,150
something called coded output stream

00:09:16,780 --> 00:09:20,830
which basically it's a class that just

00:09:19,150 --> 00:09:23,260
knows how to write the primitive fields

00:09:20,830 --> 00:09:24,910
into the array of bytes and then the

00:09:23,260 --> 00:09:28,840
actual work happens in the right to

00:09:24,910 --> 00:09:30,730
method that that has a that takes the

00:09:28,840 --> 00:09:31,840
output stream and and the message and

00:09:30,730 --> 00:09:33,910
writes the message into the output

00:09:31,840 --> 00:09:36,400
stream and eventually at the end you

00:09:33,910 --> 00:09:38,320
return the array of bytes so basically

00:09:36,400 --> 00:09:40,240
all the interesting stuff is happening

00:09:38,320 --> 00:09:42,760
in the right two method and they were

00:09:40,240 --> 00:09:44,260
going to focus a on that one serialized

00:09:42,760 --> 00:09:46,390
size is similar but easier to implement

00:09:44,260 --> 00:09:47,560
so we're just gonna for now and just

00:09:46,390 --> 00:09:49,510
look at how we're going to implement

00:09:47,560 --> 00:09:50,740
this right to method that takes an

00:09:49,510 --> 00:09:54,910
instance and write it to the output

00:09:50,740 --> 00:09:56,650
stream so the first way to do it is

00:09:54,910 --> 00:09:58,300
basically not doing it at all so this is

00:09:56,650 --> 00:10:00,640
the copying out method that says this is

00:09:58,300 --> 00:10:02,650
a manual definition you if you want to

00:10:00,640 --> 00:10:04,210
have your own method serializer for your

00:10:02,650 --> 00:10:07,180
classes you just gonna have to write it

00:10:04,210 --> 00:10:11,770
yourself and basically this is like the

00:10:07,180 --> 00:10:13,990
Bart Simpson punishment thing a and

00:10:11,770 --> 00:10:15,100
we're basically telling the user it is

00:10:13,990 --> 00:10:17,050
what you need to do to sterilize a

00:10:15,100 --> 00:10:19,960
person write your own implicit personal

00:10:17,050 --> 00:10:21,700
person sterilizer a you're gonna have

00:10:19,960 --> 00:10:24,430
every right to method inside it and then

00:10:21,700 --> 00:10:26,350
you go field by field and they write it

00:10:24,430 --> 00:10:27,820
manually it into the output stream so

00:10:26,350 --> 00:10:29,530
output dot writes doing for the first

00:10:27,820 --> 00:10:33,880
name and other one for the last name and

00:10:29,530 --> 00:10:35,950
write in 32 for the age and what do we

00:10:33,880 --> 00:10:37,570
think about it this is basically we're

00:10:35,950 --> 00:10:40,390
expecting our users to go over like for

00:10:37,570 --> 00:10:43,690
each of the case classes and do it so

00:10:40,390 --> 00:10:46,210
this is quite boring it's a tedious it's

00:10:43,690 --> 00:10:47,470
aerophone it's not fun but we have to

00:10:46,210 --> 00:10:51,130
say this so we're going to move on this

00:10:47,470 --> 00:10:53,230
is motivating us to automate this so the

00:10:51,130 --> 00:10:54,910
first thing that comes to mind is

00:10:53,230 --> 00:10:56,710
runtime reflection and you will see a

00:10:54,910 --> 00:11:02,920
little picture of one time of life

00:10:56,710 --> 00:11:06,310
and and and basically with Lantern

00:11:02,920 --> 00:11:07,990
reflection we are we are using

00:11:06,310 --> 00:11:12,070
information that's available to our

00:11:07,990 --> 00:11:14,920
program at runtime we can basically ask

00:11:12,070 --> 00:11:17,710
in run time we're given a class object

00:11:14,920 --> 00:11:19,930
what met what fields do we have inside

00:11:17,710 --> 00:11:21,400
can we give you the values of them we

00:11:19,930 --> 00:11:23,710
can ask what the types of these values

00:11:21,400 --> 00:11:25,990
are and use that to serialize the object

00:11:23,710 --> 00:11:28,420
so runtime reflection of a code tends to

00:11:25,990 --> 00:11:30,460
be very verbose so I can't summarize it

00:11:28,420 --> 00:11:32,800
here but what you see is that we call a

00:11:30,460 --> 00:11:35,080
type of T for the type we get some

00:11:32,800 --> 00:11:37,180
object that contains all the runtime

00:11:35,080 --> 00:11:40,030
information that that the points that we

00:11:37,180 --> 00:11:42,310
have at runtime for type T we go through

00:11:40,030 --> 00:11:45,190
the members one by one and for each one

00:11:42,310 --> 00:11:47,590
of them we check the type if it's a

00:11:45,190 --> 00:11:50,470
string we call write string if it's an

00:11:47,590 --> 00:11:52,690
int we call write int and if it's none

00:11:50,470 --> 00:11:56,080
of the types that we planned in advance

00:11:52,690 --> 00:11:58,330
what we're going to do we have two

00:11:56,080 --> 00:12:00,640
options we can just drop it on the floor

00:11:58,330 --> 00:12:04,030
and ignore it right or we can throw an

00:12:00,640 --> 00:12:05,830
exception or you know nothing that is

00:12:04,030 --> 00:12:07,990
that is really appealing it's it sounds

00:12:05,830 --> 00:12:09,790
a bit bad to me because like with an

00:12:07,990 --> 00:12:11,620
environment like you know in Scala

00:12:09,790 --> 00:12:14,200
there's a strong type system there are a

00:12:11,620 --> 00:12:15,820
lot of a lot of tools that we have we

00:12:14,200 --> 00:12:17,470
don't need to bring those problems wait

00:12:15,820 --> 00:12:18,640
with them to one time we can find those

00:12:17,470 --> 00:12:20,680
problems at compile time

00:12:18,640 --> 00:12:22,840
we know everything about our case

00:12:20,680 --> 00:12:26,500
classes when we compile so that

00:12:22,840 --> 00:12:28,720
shouldn't happen so so let's review the

00:12:26,500 --> 00:12:30,220
pros and cons of this approach so on the

00:12:28,720 --> 00:12:31,720
good side we made progress from the Bart

00:12:30,220 --> 00:12:34,120
Simpson approach right so this is not

00:12:31,720 --> 00:12:35,680
manual anymore we have a we wrote the

00:12:34,120 --> 00:12:37,450
code basically couldn't deal with the

00:12:35,680 --> 00:12:38,980
most case classes as long as we know

00:12:37,450 --> 00:12:41,290
what types we have and it's contained

00:12:38,980 --> 00:12:44,200
problem we're done and it's we have just

00:12:41,290 --> 00:12:47,410
one case one a sterilizer that can deal

00:12:44,200 --> 00:12:50,350
with all the types so this is what the

00:12:47,410 --> 00:12:52,030
good side on the down side like we said

00:12:50,350 --> 00:12:54,670
they all discovered at runtime if there

00:12:52,030 --> 00:12:57,850
is a a field of type we didn't except

00:12:54,670 --> 00:12:59,470
expect like a UUID or add a time this is

00:12:57,850 --> 00:13:01,690
just going to blow up at compile at

00:12:59,470 --> 00:13:03,100
runtime the other problems runtime

00:13:01,690 --> 00:13:06,540
reflection is that if you actually tried

00:13:03,100 --> 00:13:08,670
out it it's really slow it's a

00:13:06,540 --> 00:13:11,399
so slow that we're just gonna move on to

00:13:08,670 --> 00:13:12,779
them to the next method which I call

00:13:11,399 --> 00:13:15,269
generic derivation which is called

00:13:12,779 --> 00:13:17,730
generic derivation so this is finally

00:13:15,269 --> 00:13:20,190
when we get to the cool stuff and to me

00:13:17,730 --> 00:13:21,959
this is one of the most interesting

00:13:20,190 --> 00:13:25,380
programming techniques that I learned

00:13:21,959 --> 00:13:28,350
about recently and this is a this is

00:13:25,380 --> 00:13:32,190
basically combining three advanced

00:13:28,350 --> 00:13:34,649
concepts in a way to manipulate the

00:13:32,190 --> 00:13:37,079
compiler to actually do things it was a

00:13:34,649 --> 00:13:40,500
design for so this is awesome

00:13:37,079 --> 00:13:42,630
the three things are H lists a shapeless

00:13:40,500 --> 00:13:44,699
generic and the inductive implicit

00:13:42,630 --> 00:13:46,889
search and if you haven't heard about

00:13:44,699 --> 00:13:48,899
these concepts before just don't worry

00:13:46,889 --> 00:13:50,130
because you're gonna become an expert on

00:13:48,899 --> 00:13:51,899
all the three of them and generic

00:13:50,130 --> 00:13:58,889
derivation in just four minutes from now

00:13:51,899 --> 00:14:01,709
so a bear with me so let's start with H

00:13:58,889 --> 00:14:03,860
lists in general the the lists that come

00:14:01,709 --> 00:14:05,820
with the Scala standard library are

00:14:03,860 --> 00:14:07,230
designed to be homogeneous that you're

00:14:05,820 --> 00:14:07,949
supposed to put things in them of the

00:14:07,230 --> 00:14:10,410
same type

00:14:07,949 --> 00:14:12,690
so if you do one two three nil you're

00:14:10,410 --> 00:14:14,040
getting the type of interest we

00:14:12,690 --> 00:14:16,589
correctly tell you that you have a list

00:14:14,040 --> 00:14:20,310
of integers but if you go crazy and do

00:14:16,589 --> 00:14:21,990
42 false foo and put the things of

00:14:20,310 --> 00:14:23,790
different type the compiler will

00:14:21,990 --> 00:14:27,149
basically infer the least common

00:14:23,790 --> 00:14:28,740
denominator which is any and and this is

00:14:27,149 --> 00:14:30,300
good but a little bit sad because we

00:14:28,740 --> 00:14:32,310
lost all the information that we had

00:14:30,300 --> 00:14:35,610
about the individual types that we had

00:14:32,310 --> 00:14:38,010
inside our lists so this is where H list

00:14:35,610 --> 00:14:40,290
enters and they they come from a library

00:14:38,010 --> 00:14:44,069
called shapeless and this is basically

00:14:40,290 --> 00:14:45,779
called at Virginia's linked list and by

00:14:44,069 --> 00:14:46,800
importing shapeless you can write

00:14:45,779 --> 00:14:48,600
something like this

00:14:46,800 --> 00:14:51,089
and you'll notice at the end of the list

00:14:48,600 --> 00:14:53,250
we have H Neil instead of Neil which is

00:14:51,089 --> 00:14:56,910
the empty element or the last element of

00:14:53,250 --> 00:14:59,130
a autogenous list and when you run that

00:14:56,910 --> 00:15:01,079
and you assign this to things list the

00:14:59,130 --> 00:15:04,079
type inference a over intellij whatever

00:15:01,079 --> 00:15:06,690
you're using will tell you that you ever

00:15:04,079 --> 00:15:09,990
an instance of a int column colon

00:15:06,690 --> 00:15:11,850
boolean colon colon string : : h Neil so

00:15:09,990 --> 00:15:14,430
the compiler actually knows what you

00:15:11,850 --> 00:15:15,779
have in every index in the list and as a

00:15:14,430 --> 00:15:18,660
consequence of that he actually knows

00:15:15,779 --> 00:15:20,540
the length of the list so this is really

00:15:18,660 --> 00:15:22,650
cool we don't lose type information

00:15:20,540 --> 00:15:24,510
and this is how you can use something

00:15:22,650 --> 00:15:26,310
this is just a very simple example of

00:15:24,510 --> 00:15:29,520
how to use it you can create a type

00:15:26,310 --> 00:15:31,860
alias called HL and they assign it to

00:15:29,520 --> 00:15:33,870
some type like this and then you can

00:15:31,860 --> 00:15:37,770
define a function that takes an instance

00:15:33,870 --> 00:15:39,630
of this type and then you call my

00:15:37,770 --> 00:15:42,060
function and pass a specific list to it

00:15:39,630 --> 00:15:44,610
and it's only going to compile if the

00:15:42,060 --> 00:15:46,320
list instance that you're passing has

00:15:44,610 --> 00:15:51,450
the right types in the right place

00:15:46,320 --> 00:15:53,220
otherwise it just doesn't compile the

00:15:51,450 --> 00:15:54,900
next thing I want to show you which is

00:15:53,220 --> 00:15:57,870
the second advanced concept of out of

00:15:54,900 --> 00:16:00,450
the three is the generic type class and

00:15:57,870 --> 00:16:03,420
so a generic tea comes from shapeless as

00:16:00,450 --> 00:16:05,700
well and it's a type class that knows

00:16:03,420 --> 00:16:08,490
how to convert form a type like any type

00:16:05,700 --> 00:16:11,090
of the user give you to an its generic

00:16:08,490 --> 00:16:14,450
representation so so let's unpack this

00:16:11,090 --> 00:16:17,190
let's say that they we have a person Gen

00:16:14,450 --> 00:16:19,500
we we have a we want to have a generic

00:16:17,190 --> 00:16:22,200
for a person so we instantiate it like

00:16:19,500 --> 00:16:24,240
this and the type inference L will tell

00:16:22,200 --> 00:16:27,120
you that what we got is a person Gen of

00:16:24,240 --> 00:16:28,980
type generic person and it has a nested

00:16:27,120 --> 00:16:31,590
type inside that's called wrapper which

00:16:28,980 --> 00:16:34,380
is the representation of a person which

00:16:31,590 --> 00:16:35,580
is a string string int H Neil anybody

00:16:34,380 --> 00:16:40,890
knows why this is the generic

00:16:35,580 --> 00:16:43,320
representation of a person exactly so

00:16:40,890 --> 00:16:44,730
what I heard is that there is basically

00:16:43,320 --> 00:16:46,380
we have a fourth person we have a first

00:16:44,730 --> 00:16:48,330
name which is a string a last name which

00:16:46,380 --> 00:16:51,090
is string in an age that is an integer

00:16:48,330 --> 00:16:53,190
so you can basically represent every

00:16:51,090 --> 00:16:55,140
pair Sahn case class with this with list

00:16:53,190 --> 00:16:56,490
of this type and if you have a list of

00:16:55,140 --> 00:16:59,070
this type you can go back to the case

00:16:56,490 --> 00:17:00,870
that is essentially the same thing so

00:16:59,070 --> 00:17:03,000
you can do something like this you can

00:17:00,870 --> 00:17:05,640
do person gender too and give it an

00:17:03,000 --> 00:17:07,589
instance of a person John Smith 37 and

00:17:05,640 --> 00:17:10,140
you will get an H list with John Smith

00:17:07,589 --> 00:17:12,060
service 7 and it's very typed so we know

00:17:10,140 --> 00:17:14,880
it is it's an H list of string string

00:17:12,060 --> 00:17:18,089
int and you can also go in the opposite

00:17:14,880 --> 00:17:19,800
direction we can do person gendered form

00:17:18,089 --> 00:17:21,510
and fascinates lists that represent

00:17:19,800 --> 00:17:23,699
Justin Bieber which is my favorite

00:17:21,510 --> 00:17:26,970
person on earth and then it would just

00:17:23,699 --> 00:17:29,440
give us back an actual Justin Bieber out

00:17:26,970 --> 00:17:32,149
of the age list

00:17:29,440 --> 00:17:34,549
and this is the formal definition of a

00:17:32,149 --> 00:17:36,860
generic so it has the nested the

00:17:34,549 --> 00:17:39,470
representation type inside it and it has

00:17:36,860 --> 00:17:41,179
two methods - and form - would take an

00:17:39,470 --> 00:17:43,370
instance and give you the generic

00:17:41,179 --> 00:17:45,019
representation and form would go the

00:17:43,370 --> 00:17:46,720
other way around it will start from the

00:17:45,019 --> 00:17:48,769
from the general presentation we

00:17:46,720 --> 00:17:51,320
construct your your type

00:17:48,769 --> 00:17:53,179
and inside the companion object is

00:17:51,320 --> 00:17:55,279
something called aux which is auxilia

00:17:53,179 --> 00:17:58,370
auxiliary and it takes to type

00:17:55,279 --> 00:18:01,700
parameters TNR and it's assigned it's

00:17:58,370 --> 00:18:04,370
defined to be a generic of type T with a

00:18:01,700 --> 00:18:06,019
representation type R so this is letting

00:18:04,370 --> 00:18:07,490
us capture both the type and the

00:18:06,019 --> 00:18:09,260
representation type in a single

00:18:07,490 --> 00:18:11,000
definition and it's going to be very

00:18:09,260 --> 00:18:14,510
useful when we want to pass this thing

00:18:11,000 --> 00:18:16,010
around so it you're set in a bit last

00:18:14,510 --> 00:18:17,990
ingredient is the inductive implicit

00:18:16,010 --> 00:18:20,389
search so a lot of people know what

00:18:17,990 --> 00:18:21,919
implicit search is but I think that not

00:18:20,389 --> 00:18:23,659
a lot of people realize that when the

00:18:21,919 --> 00:18:25,549
Scala compiler is doing implicit search

00:18:23,659 --> 00:18:28,010
it's actually starting a recursive

00:18:25,549 --> 00:18:30,380
process so let's say that you have a

00:18:28,010 --> 00:18:33,380
function that's called a this function

00:18:30,380 --> 00:18:35,480
that takes an X integer and an implicit

00:18:33,380 --> 00:18:38,299
a of type a and you call it like this

00:18:35,480 --> 00:18:40,190
you call func of 17 now the compiler as

00:18:38,299 --> 00:18:42,470
a as a mission in life it needs to find

00:18:40,190 --> 00:18:44,840
somehow it is a to to give it to you

00:18:42,470 --> 00:18:46,279
when you call this function so it starts

00:18:44,840 --> 00:18:49,039
the implicit search it goes out to the

00:18:46,279 --> 00:18:54,350
usual places and it finds this make a

00:18:49,039 --> 00:18:58,039
but this make a knit an implicit B - to

00:18:54,350 --> 00:18:59,860
be manufactured so now the compiler is a

00:18:58,039 --> 00:19:02,840
new mission in life it needs to find a

00:18:59,860 --> 00:19:04,970
way to get a B so it's starting implicit

00:19:02,840 --> 00:19:08,750
search for B and it might find make B

00:19:04,970 --> 00:19:11,450
that needs a C and then it might find

00:19:08,750 --> 00:19:13,010
this makes a that returns a C and then

00:19:11,450 --> 00:19:13,760
it's done because this makes it doesn't

00:19:13,010 --> 00:19:15,889
need anything

00:19:13,760 --> 00:19:18,919
so the compiler is now happy it found a

00:19:15,889 --> 00:19:22,429
way to give me an A by training calls

00:19:18,919 --> 00:19:24,590
with a make a make B maxi and every time

00:19:22,429 --> 00:19:26,240
you are you write func of 17 the code

00:19:24,590 --> 00:19:29,360
that actually gets emitted by the

00:19:26,240 --> 00:19:32,480
compiler is this is the longer version

00:19:29,360 --> 00:19:34,159
that you see on the side so basically by

00:19:32,480 --> 00:19:35,990
using implicit search we can get the

00:19:34,159 --> 00:19:39,470
compiler we can send it on a mission to

00:19:35,990 --> 00:19:41,750
to use those rules for us and and find a

00:19:39,470 --> 00:19:42,590
way to get to give us what we want so

00:19:41,750 --> 00:19:44,360
we're going to manipulate

00:19:42,590 --> 00:19:49,429
the compiler to build type classes for

00:19:44,360 --> 00:19:50,720
us for whatever we want to serialize so

00:19:49,429 --> 00:19:52,520
before we do that I just want to

00:19:50,720 --> 00:19:54,529
introduce another type class called

00:19:52,520 --> 00:19:56,539
failed serializer that takes a type

00:19:54,529 --> 00:19:58,789
parameter H so filled serializer is just

00:19:56,539 --> 00:20:01,279
a type last to civilize the primitives I

00:19:58,789 --> 00:20:02,960
have the strings the integers it has a

00:20:01,279 --> 00:20:05,240
single serialized method that takes the

00:20:02,960 --> 00:20:07,429
output stream and a tag number this is

00:20:05,240 --> 00:20:09,320
the running number for my fields and a

00:20:07,429 --> 00:20:11,929
single value of type H that we want to

00:20:09,320 --> 00:20:13,130
get see realized so I can define this

00:20:11,929 --> 00:20:15,409
way an in civilizer

00:20:13,130 --> 00:20:17,419
that takes an integer and write it to

00:20:15,409 --> 00:20:18,799
the output stream but just all it does

00:20:17,419 --> 00:20:21,649
is calling the write method on the

00:20:18,799 --> 00:20:24,799
output stream and I can similarly define

00:20:21,649 --> 00:20:27,590
the string sterilizer which calls write

00:20:24,799 --> 00:20:31,760
string and notice that I tagged all the

00:20:27,590 --> 00:20:33,919
implicit methods with a anyway I talked

00:20:31,760 --> 00:20:36,140
them with the implicit keyword so those

00:20:33,919 --> 00:20:37,730
are going to be found a at the right

00:20:36,140 --> 00:20:39,770
like when when we compile and we'll

00:20:37,730 --> 00:20:43,070
quite a few lines of string the compiler

00:20:39,770 --> 00:20:44,840
is going to find them okay

00:20:43,070 --> 00:20:47,179
so let's figure out how to create a

00:20:44,840 --> 00:20:50,120
message civilise of type t the new idea

00:20:47,179 --> 00:20:53,740
in generic derivation is that we are

00:20:50,120 --> 00:20:57,559
going to reduce the problem into a

00:20:53,740 --> 00:21:00,020
basically two two phases we're going to

00:20:57,559 --> 00:21:03,049
get a generic that going to convert I'll

00:21:00,020 --> 00:21:04,669
type the user type from T to some age

00:21:03,049 --> 00:21:08,149
list out to some generic representation

00:21:04,669 --> 00:21:08,960
and if we can create a message

00:21:08,149 --> 00:21:11,120
serializer

00:21:08,960 --> 00:21:13,669
for the edge list for the generic

00:21:11,120 --> 00:21:15,500
representation then we are done we're

00:21:13,669 --> 00:21:16,820
basically for every type that we get we

00:21:15,500 --> 00:21:19,159
convert it to an age list then we

00:21:16,820 --> 00:21:20,990
civilize the edge list we're done so our

00:21:19,159 --> 00:21:22,669
new problem now the reduced problem is

00:21:20,990 --> 00:21:26,390
to create message sterilizers just for H

00:21:22,669 --> 00:21:29,270
list this is our new problem so how do

00:21:26,390 --> 00:21:32,240
we encode using implicit functions what

00:21:29,270 --> 00:21:34,880
I just said this is what it looks like

00:21:32,240 --> 00:21:38,330
it's not very pretty but but this is

00:21:34,880 --> 00:21:39,919
basically the rule we get a we write an

00:21:38,330 --> 00:21:41,630
implicit function that returns the

00:21:39,919 --> 00:21:43,730
message sterilise of t which is what we

00:21:41,630 --> 00:21:46,429
want how do create a message sterilizer

00:21:43,730 --> 00:21:49,100
of T we need to give it two inputs two

00:21:46,429 --> 00:21:51,770
implicit inputs a generic that converts

00:21:49,100 --> 00:21:54,320
from T to an R and a message sterilizer

00:21:51,770 --> 00:21:55,490
for an R so if we can get those two

00:21:54,320 --> 00:21:58,040
implicit when we come

00:21:55,490 --> 00:22:00,500
pal we can just compose them we can

00:21:58,040 --> 00:22:03,470
convert a we cannot call generic to two

00:22:00,500 --> 00:22:06,650
of t so we get the user provided data

00:22:03,470 --> 00:22:08,750
type we convert it to an H list of type

00:22:06,650 --> 00:22:11,660
al and then we call the method serialize

00:22:08,750 --> 00:22:14,690
of Type R to get to serialize it and

00:22:11,660 --> 00:22:17,150
this is it so our new problem is how to

00:22:14,690 --> 00:22:18,860
serialize H lists in general this is how

00:22:17,150 --> 00:22:20,900
we take any user data type convert it to

00:22:18,860 --> 00:22:25,460
an HS and C realize now the problem is

00:22:20,900 --> 00:22:26,809
how do we say lies H lists so in case of

00:22:25,460 --> 00:22:28,309
a person it would look like this a

00:22:26,809 --> 00:22:31,100
message utilized of a person will have a

00:22:28,309 --> 00:22:33,710
generic of a string string int remember

00:22:31,100 --> 00:22:36,559
first name last name age and we need a

00:22:33,710 --> 00:22:37,850
message serializer for the h list so how

00:22:36,559 --> 00:22:39,440
do we gonna get the message steriliser

00:22:37,850 --> 00:22:40,910
for the HS so it turns out that

00:22:39,440 --> 00:22:43,280
civilising list is very easy you just

00:22:40,910 --> 00:22:44,510
have two cases the first case is

00:22:43,280 --> 00:22:46,960
sterilizing an empty list

00:22:44,510 --> 00:22:49,280
sterilizing an empty list is super easy

00:22:46,960 --> 00:22:50,780
right because all you have to do is a

00:22:49,280 --> 00:22:52,760
right to right to function that does

00:22:50,780 --> 00:22:54,530
nothing and you're done so we just

00:22:52,760 --> 00:22:58,150
covered half the walk for doing a

00:22:54,530 --> 00:23:00,740
civilizing a h list the second part is

00:22:58,150 --> 00:23:02,559
serializing a non-empty list what is a

00:23:00,740 --> 00:23:05,240
non-empty list it has a head in a tail

00:23:02,559 --> 00:23:07,309
what is in the head it's just some

00:23:05,240 --> 00:23:08,750
primitive field what it's saying it's an

00:23:07,309 --> 00:23:11,210
integer it's just the first thing you

00:23:08,750 --> 00:23:13,070
have in your case class a so if we can

00:23:11,210 --> 00:23:15,530
get our hands on a field sterilizer for

00:23:13,070 --> 00:23:17,900
the head and a message sterilizer for

00:23:15,530 --> 00:23:20,690
the tail for the rest of the list we're

00:23:17,900 --> 00:23:22,340
done we just serialize the head and then

00:23:20,690 --> 00:23:23,809
make this call to the another message

00:23:22,340 --> 00:23:26,330
sterilizer for the tail passing in the

00:23:23,809 --> 00:23:28,010
tail of the h list and it's all

00:23:26,330 --> 00:23:32,270
civilized now that's the beauty of

00:23:28,010 --> 00:23:35,240
induction right so you'll see the second

00:23:32,270 --> 00:23:36,980
window the rule to create the message

00:23:35,240 --> 00:23:38,720
serialize of a head followed by a tail

00:23:36,980 --> 00:23:40,130
we have an implicit function that

00:23:38,720 --> 00:23:43,010
returns a message serializer

00:23:40,130 --> 00:23:45,110
of a head followed by a tail and it gets

00:23:43,010 --> 00:23:46,700
in the inputs a field civilizer for the

00:23:45,110 --> 00:23:50,410
head and a message civilizer for the

00:23:46,700 --> 00:23:53,210
tail and all it does is a calling them

00:23:50,410 --> 00:23:54,650
super simple so we basically have just

00:23:53,210 --> 00:23:58,220
we just defined three rules

00:23:54,650 --> 00:24:01,220
want to convert any user case class to

00:23:58,220 --> 00:24:03,110
way to add h list and tools for h list

00:24:01,220 --> 00:24:05,900
the neal case and the end and a

00:24:03,110 --> 00:24:07,790
non-empty case and those the rules let

00:24:05,900 --> 00:24:09,020
the compiler do all of this for us when

00:24:07,790 --> 00:24:11,360
we compile

00:24:09,020 --> 00:24:13,850
we basically request a message

00:24:11,360 --> 00:24:15,650
sterilizer of a person in our code and

00:24:13,850 --> 00:24:17,930
the compiler starts to check all the

00:24:15,650 --> 00:24:21,020
implicit that are around it arrives to

00:24:17,930 --> 00:24:22,550
this three and so it go to the generic

00:24:21,020 --> 00:24:25,040
and then a message sterilizer for the

00:24:22,550 --> 00:24:27,050
age list and then one step at times it

00:24:25,040 --> 00:24:28,940
shaves the head of the list until you it

00:24:27,050 --> 00:24:31,640
ends up with an empty H list which is

00:24:28,940 --> 00:24:33,620
our base case and all of this together

00:24:31,640 --> 00:24:35,570
we've got the compiler to do quite a bit

00:24:33,620 --> 00:24:38,570
of work for us and give us the type

00:24:35,570 --> 00:24:40,370
class that does what we want so in my

00:24:38,570 --> 00:24:42,440
view this is like magic this is I mean

00:24:40,370 --> 00:24:45,020
it's not magical that we understood but

00:24:42,440 --> 00:24:48,260
this is quite awesome machinery that we

00:24:45,020 --> 00:24:52,120
have you're at work and I think it's

00:24:48,260 --> 00:24:55,250
very impressive so let's review this

00:24:52,120 --> 00:24:56,930
what's good what's bad so the

00:24:55,250 --> 00:25:00,230
improvement over reflection is that we

00:24:56,930 --> 00:25:02,540
get our arrows at compile time a so for

00:25:00,230 --> 00:25:05,270
example if you have a some field in your

00:25:02,540 --> 00:25:06,890
in your in your case class that is a

00:25:05,270 --> 00:25:08,570
UUID or something you didn't have a

00:25:06,890 --> 00:25:10,100
filter eliezer for that implicit is not

00:25:08,570 --> 00:25:12,530
going to be found you're gonna get a

00:25:10,100 --> 00:25:14,180
compile time error the approach is

00:25:12,530 --> 00:25:15,890
relatively fast it's way faster than

00:25:14,180 --> 00:25:19,970
reflection like two orders of magnitude

00:25:15,890 --> 00:25:21,860
faster and you can use custom sterilizer

00:25:19,970 --> 00:25:23,600
so as a user because it were relying on

00:25:21,860 --> 00:25:26,750
implicit search you can have your

00:25:23,600 --> 00:25:28,310
implicit field sterilizer defined in the

00:25:26,750 --> 00:25:29,390
right place and the implicit search is

00:25:28,310 --> 00:25:31,430
going to pick it up and it's going to

00:25:29,390 --> 00:25:32,870
become part of this machinery so it's

00:25:31,430 --> 00:25:37,060
very easy to customize it for your own

00:25:32,870 --> 00:25:40,280
type downside I love downsides

00:25:37,060 --> 00:25:41,750
unhelpful compiler arrows so the problem

00:25:40,280 --> 00:25:43,390
with what I just said is that if it's

00:25:41,750 --> 00:25:45,290
not gonna find your field serializer

00:25:43,390 --> 00:25:46,430
it's not going to tell you that it

00:25:45,290 --> 00:25:48,080
couldn't find your fields I realize that

00:25:46,430 --> 00:25:50,080
I just gonna tell you I cannot get a

00:25:48,080 --> 00:25:52,460
message to Eliza for a person implicit

00:25:50,080 --> 00:25:54,830
implicit not found but it's not gonna

00:25:52,460 --> 00:25:56,840
tell you for what field at the bottom of

00:25:54,830 --> 00:25:59,810
the tree its felled on so that can be

00:25:56,840 --> 00:26:01,400
quite annoying to deal with and there

00:25:59,810 --> 00:26:03,230
are ways to get the compiler to give you

00:26:01,400 --> 00:26:04,730
more verbose arrows but then basically

00:26:03,230 --> 00:26:06,920
the compilers tells you everything it

00:26:04,730 --> 00:26:10,700
had for breakfast and it's kind of a

00:26:06,920 --> 00:26:14,000
little bit hard to deal with and the

00:26:10,700 --> 00:26:15,680
code that gets generated this way is

00:26:14,000 --> 00:26:17,930
slower than the generated code that

00:26:15,680 --> 00:26:19,610
Scala PB already has and it's a bit

00:26:17,930 --> 00:26:21,950
tough to deal code has been optimized

00:26:19,610 --> 00:26:25,880
for four years now

00:26:21,950 --> 00:26:28,550
but I think that this can be improved on

00:26:25,880 --> 00:26:30,530
the calculate of the slowness from from

00:26:28,550 --> 00:26:32,000
the research I did was the construction

00:26:30,530 --> 00:26:34,130
of the H this basic allocation

00:26:32,000 --> 00:26:35,840
construction and also the boxing that

00:26:34,130 --> 00:26:38,780
was going on of all the primitive fields

00:26:35,840 --> 00:26:40,310
in the process and finally I showed you

00:26:38,780 --> 00:26:43,130
how to do encoding and it works really

00:26:40,310 --> 00:26:45,050
well but in the case of decoding is

00:26:43,130 --> 00:26:47,300
unclear in the protocol buffer world a

00:26:45,050 --> 00:26:48,560
the bytes can the fields can come in any

00:26:47,300 --> 00:26:50,540
order when you get a binary

00:26:48,560 --> 00:26:52,940
representation and it's a bit unclear

00:26:50,540 --> 00:26:55,160
how to construct an H list when things

00:26:52,940 --> 00:26:57,320
efficiently when things just come in the

00:26:55,160 --> 00:26:59,600
order that you don't expect them so this

00:26:57,320 --> 00:27:00,830
does a little bit of an clarity there so

00:26:59,600 --> 00:27:02,720
given all of that

00:27:00,830 --> 00:27:06,020
I said look how can I improve I really

00:27:02,720 --> 00:27:08,060
like this and how can I improve this to

00:27:06,020 --> 00:27:09,890
solve the problems that we see here so I

00:27:08,060 --> 00:27:12,710
read how generic is implemented inside

00:27:09,890 --> 00:27:14,150
shapeless and turns out it it's a macro

00:27:12,710 --> 00:27:16,970
and that took me to the world of

00:27:14,150 --> 00:27:18,680
understanding a scholar Marcos so

00:27:16,970 --> 00:27:20,390
scholar Marcos like you see in the

00:27:18,680 --> 00:27:22,730
picture they have this reputation of

00:27:20,390 --> 00:27:26,660
being a like a black magic like

00:27:22,730 --> 00:27:29,330
supernatural a evil power that's only

00:27:26,660 --> 00:27:31,610
reserved for a small group of Scala

00:27:29,330 --> 00:27:34,010
gurus that know what they're doing and

00:27:31,610 --> 00:27:36,140
so I spent a few weeks with them and a

00:27:34,010 --> 00:27:39,830
lot of time on Stack Overflow and I can

00:27:36,140 --> 00:27:41,630
tell you that this is partly true but to

00:27:39,830 --> 00:27:42,860
be honest joking aside it's it's more

00:27:41,630 --> 00:27:44,360
it's more accessible than what I

00:27:42,860 --> 00:27:46,310
imagined there's a lot of stuff on Stack

00:27:44,360 --> 00:27:49,460
Overflow you can read source code that

00:27:46,310 --> 00:27:51,770
does it I found it I found it more

00:27:49,460 --> 00:27:54,680
approachable than what I thought when I

00:27:51,770 --> 00:27:57,260
started so what I want to do next is is

00:27:54,680 --> 00:27:59,840
give you kind of the the gist of what it

00:27:57,260 --> 00:28:01,220
like what it's like to do item and Marco

00:27:59,840 --> 00:28:02,090
show you that it's not that bad but

00:28:01,220 --> 00:28:05,150
there are a few things that you should

00:28:02,090 --> 00:28:08,980
be a you know should notice or worried

00:28:05,150 --> 00:28:12,170
about when when you write a scala Marco

00:28:08,980 --> 00:28:14,120
so every every scholar Marco starts with

00:28:12,170 --> 00:28:16,730
this you you define it's a it's called a

00:28:14,120 --> 00:28:18,200
implicit a Marco's you write an implicit

00:28:16,730 --> 00:28:21,230
function that returns of the type that

00:28:18,200 --> 00:28:23,360
you actually want to get and the body of

00:28:21,230 --> 00:28:25,700
that method is the world Marco followed

00:28:23,360 --> 00:28:27,320
by a some function name which is

00:28:25,700 --> 00:28:30,470
basically the where the macro is

00:28:27,320 --> 00:28:32,480
implemented and then you define this

00:28:30,470 --> 00:28:34,700
method in in this case we call it G an

00:28:32,480 --> 00:28:37,750
input which is the generic it's

00:28:34,700 --> 00:28:41,180
the implementation is and it takes a

00:28:37,750 --> 00:28:42,950
type parameter T and an implicit week

00:28:41,180 --> 00:28:47,120
type tag that gives us at compile time

00:28:42,950 --> 00:28:49,580
all the information that we need to to

00:28:47,120 --> 00:28:52,130
know about the type T and it returns a

00:28:49,580 --> 00:28:55,550
tree this tree is basically abstract

00:28:52,130 --> 00:28:58,100
abstract syntax tree in the for for the

00:28:55,550 --> 00:29:00,140
for Scala and that tree is just going to

00:28:58,100 --> 00:29:03,520
get injected during compile time at the

00:29:00,140 --> 00:29:06,650
call site what this macro is invoked a

00:29:03,520 --> 00:29:08,390
and the current implementation of the

00:29:06,650 --> 00:29:10,040
macro a three question marks so when you

00:29:08,390 --> 00:29:11,260
actually if you want this macro right

00:29:10,040 --> 00:29:13,880
now it's going to throw an exception

00:29:11,260 --> 00:29:15,620
inside the compiler at compile time so

00:29:13,880 --> 00:29:17,690
don't do it like so don't do this

00:29:15,620 --> 00:29:21,650
discoid dangerous but they will actually

00:29:17,690 --> 00:29:24,470
gonna implement it in a minute and you

00:29:21,650 --> 00:29:26,360
might think that creating those trees

00:29:24,470 --> 00:29:28,340
you know that basically represents color

00:29:26,360 --> 00:29:30,680
code is is hard but turns out it's

00:29:28,340 --> 00:29:33,200
actually easy using a technique called

00:29:30,680 --> 00:29:35,590
the quasi quotes which is the block of

00:29:33,200 --> 00:29:38,360
red text that you see right now and

00:29:35,590 --> 00:29:39,890
basically you put Q and you put double

00:29:38,360 --> 00:29:42,230
quotes and then you can write Scala code

00:29:39,890 --> 00:29:44,990
and what actually ends up happening is

00:29:42,230 --> 00:29:46,640
that that's calico that you have inside

00:29:44,990 --> 00:29:48,260
the quote the quote is converted to it

00:29:46,640 --> 00:29:51,500
exactly the tree that you need to return

00:29:48,260 --> 00:29:53,300
so it's a little easy and what we have

00:29:51,500 --> 00:29:56,780
in those in the red text is that we

00:29:53,300 --> 00:29:58,940
define a class with some a name that we

00:29:56,780 --> 00:30:00,860
get from an outside variable and it

00:29:58,940 --> 00:30:03,290
extend extend the message sterilizer of

00:30:00,860 --> 00:30:05,510
the users type and it has a right to

00:30:03,290 --> 00:30:09,320
method that currently does nothing and

00:30:05,510 --> 00:30:10,730
then return an instance of this class so

00:30:09,320 --> 00:30:12,860
if a user is going to write something

00:30:10,730 --> 00:30:14,840
like this implicitly message serialize

00:30:12,860 --> 00:30:17,960
of a person the maku is gonna get

00:30:14,840 --> 00:30:19,850
invoked and the code that gets returned

00:30:17,960 --> 00:30:22,490
the tree that gets returned is just

00:30:19,850 --> 00:30:24,290
gonna be injected at the call side so

00:30:22,490 --> 00:30:26,120
the outcome would be the third window

00:30:24,290 --> 00:30:30,770
what you see in the third window that's

00:30:26,120 --> 00:30:33,200
that's basic what macros do so notice

00:30:30,770 --> 00:30:34,850
how we kind of went a full circle right

00:30:33,200 --> 00:30:36,170
we started with cogeneration and wanted

00:30:34,850 --> 00:30:38,540
to avoid it but it was code generation

00:30:36,170 --> 00:30:40,910
before compile time now we're doing

00:30:38,540 --> 00:30:46,130
cogeneration do in compile time but this

00:30:40,910 --> 00:30:47,570
is better so our next step is basically

00:30:46,130 --> 00:30:48,140
implement a try to method that

00:30:47,570 --> 00:30:51,440
sterilizer

00:30:48,140 --> 00:30:52,640
say the user the user type so first we

00:30:51,440 --> 00:30:54,980
need to get our hands on the field

00:30:52,640 --> 00:30:57,560
sterilizers those things that know how

00:30:54,980 --> 00:30:59,900
to serialize the individual fields so

00:30:57,560 --> 00:31:01,460
turns out they there is a method that's

00:30:59,900 --> 00:31:03,350
available to you when you write Marcos

00:31:01,460 --> 00:31:05,330
that's called in faerie implicit value

00:31:03,350 --> 00:31:06,890
that you can give it the type that you

00:31:05,330 --> 00:31:09,460
want and it will give you the employee

00:31:06,890 --> 00:31:12,760
implicit instance of off a of that type

00:31:09,460 --> 00:31:15,920
M and basically we're creating a

00:31:12,760 --> 00:31:17,840
sequence of assignment operations that

00:31:15,920 --> 00:31:20,690
assign those civilizer Xin to values

00:31:17,840 --> 00:31:22,760
that we are going to use later so

00:31:20,690 --> 00:31:24,320
basically for every field that we have

00:31:22,760 --> 00:31:26,510
we're gonna have an implicit sterilizer

00:31:24,320 --> 00:31:28,730
defined and we're creating a sequence of

00:31:26,510 --> 00:31:34,040
Val something equals something

00:31:28,730 --> 00:31:37,010
statements and we're also going to

00:31:34,040 --> 00:31:39,200
generate a sequence of function calls to

00:31:37,010 --> 00:31:41,900
call those serializers own values that

00:31:39,200 --> 00:31:44,210
we can extract from the case class so we

00:31:41,900 --> 00:31:47,120
go field by field again and we call the

00:31:44,210 --> 00:31:50,900
sterilizer dot serialize give it the

00:31:47,120 --> 00:31:52,550
output stream an extract a value a dot m

00:31:50,900 --> 00:31:54,710
dot name basically we extract a value

00:31:52,550 --> 00:32:00,350
from each from for the field from the

00:31:54,710 --> 00:32:01,820
case class okay once we have that we

00:32:00,350 --> 00:32:03,500
have the implicit that we need we have

00:32:01,820 --> 00:32:05,840
the writers that write calls that we

00:32:03,500 --> 00:32:08,300
need we can just use the dot dollar

00:32:05,840 --> 00:32:10,910
syntax which basically explodes the the

00:32:08,300 --> 00:32:12,800
sequence of statements into the right

00:32:10,910 --> 00:32:16,270
place like just doing substitution but

00:32:12,800 --> 00:32:19,250
for lists and this is basically

00:32:16,270 --> 00:32:21,140
everything you need to do to get to get

00:32:19,250 --> 00:32:22,970
this macro walking what happens in

00:32:21,140 --> 00:32:25,340
practice you do like message civilizer

00:32:22,970 --> 00:32:28,160
of a person and this is the code that

00:32:25,340 --> 00:32:29,840
ends up being generated by the macro it

00:32:28,160 --> 00:32:31,340
will create the string civilizer and the

00:32:29,840 --> 00:32:32,930
inside eyes on the top assign them to

00:32:31,340 --> 00:32:35,750
values and then it's going to generate

00:32:32,930 --> 00:32:37,520
the serialized calls inside the right to

00:32:35,750 --> 00:32:39,590
method and this is it and it's actually

00:32:37,520 --> 00:32:41,390
walking so this is pretty cool and

00:32:39,590 --> 00:32:43,820
that's that's basically what you need to

00:32:41,390 --> 00:32:46,250
do to item alcohol well well problem

00:32:43,820 --> 00:32:48,080
starts to happen is when you have those

00:32:46,250 --> 00:32:49,760
cases where you have a self references

00:32:48,080 --> 00:32:51,680
or you have a method at reference itself

00:32:49,760 --> 00:32:53,270
and then the macro starts to go a

00:32:51,680 --> 00:32:54,950
cursive Lea it's had itself inside the

00:32:53,270 --> 00:32:57,290
compiler when you have to somehow stop

00:32:54,950 --> 00:32:59,030
it there are ways to do it and I will

00:32:57,290 --> 00:33:00,380
really recommend that you give a try to

00:32:59,030 --> 00:33:02,330
a library called Magnolia

00:33:00,380 --> 00:33:03,830
the tries to systematically deal

00:33:02,330 --> 00:33:05,720
with those problems and make your life

00:33:03,830 --> 00:33:09,950
easy when you write when you in

00:33:05,720 --> 00:33:14,029
situations like this let's view the

00:33:09,950 --> 00:33:16,250
approach or the support so the markets

00:33:14,029 --> 00:33:18,080
are faster similar they have similar

00:33:16,250 --> 00:33:20,059
speed to the generated code and why

00:33:18,080 --> 00:33:21,289
because they end up generating code

00:33:20,059 --> 00:33:24,230
that's very similar to the original

00:33:21,289 --> 00:33:25,970
generated code that scallop EP has you

00:33:24,230 --> 00:33:27,710
can use custom sterilizers because we

00:33:25,970 --> 00:33:30,200
are relying on the implicit search and

00:33:27,710 --> 00:33:32,570
all the built in Scala mechanisms and

00:33:30,200 --> 00:33:34,610
you get better compiler errors and the

00:33:32,570 --> 00:33:37,429
reason is that when you write a macro

00:33:34,610 --> 00:33:38,779
you can detect all those like conditions

00:33:37,429 --> 00:33:40,580
where the implicit SAR not found and you

00:33:38,779 --> 00:33:42,769
can give any error or warning that you

00:33:40,580 --> 00:33:44,750
want in your own words so so you can

00:33:42,769 --> 00:33:49,250
have very precise and useful error

00:33:44,750 --> 00:33:52,669
messages downsides limited debugging

00:33:49,250 --> 00:33:55,340
tools so the ideas of today don't let

00:33:52,669 --> 00:33:58,100
users put black points or just even not

00:33:55,340 --> 00:34:00,110
even see the code that gets generated by

00:33:58,100 --> 00:34:01,250
by the macro and this can be a bit

00:34:00,110 --> 00:34:04,940
annoying for users that want to

00:34:01,250 --> 00:34:06,559
understand what's going on so that's the

00:34:04,940 --> 00:34:09,500
basic that's the only downside they have

00:34:06,559 --> 00:34:10,790
but this is also true for like when you

00:34:09,500 --> 00:34:12,080
write a Mac code you don't have a lot of

00:34:10,790 --> 00:34:13,879
tools to understand what's happening

00:34:12,080 --> 00:34:16,790
inside the compiler so it was a little

00:34:13,879 --> 00:34:19,040
bit of a trial and error to do that but

00:34:16,790 --> 00:34:21,349
generally after dealing with this I

00:34:19,040 --> 00:34:23,149
think that Marcos is the right solution

00:34:21,349 --> 00:34:25,129
for I mean it depends on the problem for

00:34:23,149 --> 00:34:26,839
scolipede be when the emphasis is on

00:34:25,129 --> 00:34:29,000
speed and flexibility I think it's it's

00:34:26,839 --> 00:34:30,080
a good use case we do need to get to

00:34:29,000 --> 00:34:32,990
figure out how to solve a few problems

00:34:30,080 --> 00:34:34,669
and and the a may be create something

00:34:32,990 --> 00:34:37,760
useful that for everybody that rides a

00:34:34,669 --> 00:34:38,780
compiler this type of macros but I feel

00:34:37,760 --> 00:34:42,649
that this is the right approach in

00:34:38,780 --> 00:34:44,929
general what I want to do now is show

00:34:42,649 --> 00:34:46,190
you a the performance benchmark ahead

00:34:44,929 --> 00:34:48,980
when I compare there all these

00:34:46,190 --> 00:34:51,710
approaches so what you see here on the

00:34:48,980 --> 00:34:53,810
y-axis is time in nanoseconds so

00:34:51,710 --> 00:34:55,339
everything we're doing is a super fast

00:34:53,810 --> 00:34:58,700
this is the time that it takes to

00:34:55,339 --> 00:35:00,800
serialize a one single message and on

00:34:58,700 --> 00:35:03,230
the on the x-axis is the size of the

00:35:00,800 --> 00:35:05,990
message so obviously big your messages

00:35:03,230 --> 00:35:08,599
message with more fields are slower to

00:35:05,990 --> 00:35:11,240
civilize the name and smaller messages

00:35:08,599 --> 00:35:14,150
and of course this is done with a

00:35:11,240 --> 00:35:15,890
something like jmh where we basically

00:35:14,150 --> 00:35:19,009
see realize millions of messages and we

00:35:15,890 --> 00:35:20,619
warm up to JVM and get you know get take

00:35:19,009 --> 00:35:23,930
care of all the usual problems on

00:35:20,619 --> 00:35:25,490
benchmarks on day on the JVM the black

00:35:23,930 --> 00:35:28,940
line is the generated code this is the

00:35:25,490 --> 00:35:30,680
baseline of what ahead a and then it's

00:35:28,940 --> 00:35:33,140
followed by the MCOs which is really

00:35:30,680 --> 00:35:35,029
really close the overhead comes from the

00:35:33,140 --> 00:35:36,230
field serializers which the generated

00:35:35,029 --> 00:35:37,999
code doesn't have to do it just cause

00:35:36,230 --> 00:35:40,430
exactly what it needs it doesn't need to

00:35:37,999 --> 00:35:43,450
go through this abstraction at all and

00:35:40,430 --> 00:35:46,369
the red line is the generic deprivation

00:35:43,450 --> 00:35:48,349
and like I said this is the overhead

00:35:46,369 --> 00:35:50,960
there there comes from the H list and

00:35:48,349 --> 00:35:54,410
the boxing and unboxing and any guess

00:35:50,960 --> 00:35:55,970
what where reflection is it's in the

00:35:54,410 --> 00:35:57,259
next laugh because it didn't it couldn't

00:35:55,970 --> 00:35:58,839
get into this one we have to zoom out

00:35:57,259 --> 00:36:02,450
two orders of magnitude

00:35:58,839 --> 00:36:04,190
IRA's reflection it is still pretty fast

00:36:02,450 --> 00:36:07,220
but we are talking now microseconds not

00:36:04,190 --> 00:36:11,170
nanoseconds okay

00:36:07,220 --> 00:36:13,700
but it's substantially slower and so

00:36:11,170 --> 00:36:16,009
this is basically what I wanted to show

00:36:13,700 --> 00:36:19,099
you today three interesting techniques

00:36:16,009 --> 00:36:21,380
to deal with user data types in a

00:36:19,099 --> 00:36:22,970
generic way so think about this when

00:36:21,380 --> 00:36:24,619
every time that you go and you have

00:36:22,970 --> 00:36:26,180
something and you go like field by field

00:36:24,619 --> 00:36:29,450
and doing something one of these

00:36:26,180 --> 00:36:31,430
techniques can help you so figure figure

00:36:29,450 --> 00:36:33,710
out you know how to you can use one of

00:36:31,430 --> 00:36:36,529
them to eliminate this repetitive code

00:36:33,710 --> 00:36:38,420
and use these genetic approaches to save

00:36:36,529 --> 00:36:40,430
time and money and bugs and have like

00:36:38,420 --> 00:36:43,190
happier life so no matter what your

00:36:40,430 --> 00:36:46,809
peanut butter is just find a way to tell

00:36:43,190 --> 00:36:46,809
to get rid of it thank you

00:36:50,780 --> 00:37:06,900
I'll take questions now and there's a

00:36:53,430 --> 00:37:08,640
mic over there oh thank you so you said

00:37:06,900 --> 00:37:10,590
you didn't do anything about the

00:37:08,640 --> 00:37:12,570
decentralization part is there work

00:37:10,590 --> 00:37:14,040
you're planning to do or is there any

00:37:12,570 --> 00:37:16,320
code that is there for deserialization

00:37:14,040 --> 00:37:18,630
yes for this talk I just wanted to focus

00:37:16,320 --> 00:37:20,370
on one aspect but obviously when this is

00:37:18,630 --> 00:37:22,710
gonna become something that I'd like to

00:37:20,370 --> 00:37:24,120
release then it would have to take care

00:37:22,710 --> 00:37:30,180
of both directions otherwise it's not

00:37:24,120 --> 00:37:31,740
gonna be as useful yeah hey thanks a lot

00:37:30,180 --> 00:37:34,440
for the talk this is not really a

00:37:31,740 --> 00:37:36,600
question I just wanted to say thank you

00:37:34,440 --> 00:37:38,160
so much for your work let's call up EB

00:37:36,600 --> 00:37:40,080
is the foundation for Symantec Libya

00:37:38,160 --> 00:37:41,850
this is you know the platform for tools

00:37:40,080 --> 00:37:44,220
and stuff that I was presented here

00:37:41,850 --> 00:37:45,810
yesterday and you know over the whole

00:37:44,220 --> 00:37:47,460
time we were using Scala PP we didn't

00:37:45,810 --> 00:37:49,620
encounter any you know weird exceptions

00:37:47,460 --> 00:37:51,840
or errors I mean this thing is super

00:37:49,620 --> 00:37:53,340
stable and every time we needed some

00:37:51,840 --> 00:37:55,500
functionality for instance Scala native

00:37:53,340 --> 00:37:57,600
support since we needed to cross compile

00:37:55,500 --> 00:37:59,580
to Scala native well here you were and

00:37:57,600 --> 00:38:01,380
you just hacked it in a couple days I

00:37:59,580 --> 00:38:04,790
was like wow how is this even possible

00:38:01,380 --> 00:38:04,790
so thanks so much

00:38:05,360 --> 00:38:13,289
[Applause]

00:38:17,770 --> 00:38:25,869
hi I have a question about version of

00:38:20,950 --> 00:38:29,130
protobuf so do you plan to infer some

00:38:25,869 --> 00:38:32,290
kind of version of objects to safely

00:38:29,130 --> 00:38:35,560
draw an exception if you think this

00:38:32,290 --> 00:38:38,440
should not be dislodged so it's a great

00:38:35,560 --> 00:38:40,750
question and this is basically what

00:38:38,440 --> 00:38:42,760
you're giving up when you are moving

00:38:40,750 --> 00:38:45,520
away from a protocol battle file where

00:38:42,760 --> 00:38:48,250
you can maintain a you know the target

00:38:45,520 --> 00:38:49,540
numbers and all of that you have told

00:38:48,250 --> 00:38:51,670
that the way when you move to the case

00:38:49,540 --> 00:38:55,119
classes and my thought there is to

00:38:51,670 --> 00:38:56,470
actually a the default would be to go

00:38:55,119 --> 00:38:58,420
with the sequential tag numbers

00:38:56,470 --> 00:38:59,890
automatically but then you have this

00:38:58,420 --> 00:39:00,940
problem if your users remove the field

00:38:59,890 --> 00:39:02,350
somewhere in the middle and all the

00:39:00,940 --> 00:39:04,840
numbers start to kind of like fall

00:39:02,350 --> 00:39:06,430
backwards then things are just going to

00:39:04,840 --> 00:39:09,160
break and it's very hard to detect it we

00:39:06,430 --> 00:39:10,540
Foley start passing and and even when

00:39:09,160 --> 00:39:12,520
you start when you are passing you might

00:39:10,540 --> 00:39:13,750
end up somehow passing correctly but

00:39:12,520 --> 00:39:16,930
something that you know but you get

00:39:13,750 --> 00:39:18,820
garbage data and so my thing is that if

00:39:16,930 --> 00:39:22,480
a user's really has a concern they'll

00:39:18,820 --> 00:39:24,550
have a way somehow to to tell what is

00:39:22,480 --> 00:39:26,560
the target number next to the field I'm

00:39:24,550 --> 00:39:29,140
not sure exactly how it's gonna be

00:39:26,560 --> 00:39:31,420
probably like an annotation but it might

00:39:29,140 --> 00:39:33,070
be some you know a tag type for someone

00:39:31,420 --> 00:39:35,850
that ran that's gonna be one of the ways

00:39:33,070 --> 00:39:35,850
to complete that

00:39:38,560 --> 00:39:42,790
[Music]

00:39:40,410 --> 00:39:44,470
yeah I had the decode question when I

00:39:42,790 --> 00:39:46,300
heard that I was thinking one of the

00:39:44,470 --> 00:39:48,730
things with versioning that you could do

00:39:46,300 --> 00:39:51,760
with the PB is have each of these case

00:39:48,730 --> 00:39:53,710
class classes use a trait and in the

00:39:51,760 --> 00:39:56,500
tray put that meta version information

00:39:53,710 --> 00:39:58,870
and maybe a list of the order and if

00:39:56,500 --> 00:40:01,480
it's if it's non-standard and assume

00:39:58,870 --> 00:40:06,630
unless it's explicitly said then

00:40:01,480 --> 00:40:06,630
one-to-one is the first field etc okay

00:40:18,000 --> 00:40:25,429
cool

00:40:20,400 --> 00:40:25,429

YouTube URL: https://www.youtube.com/watch?v=nr45haff4IA


