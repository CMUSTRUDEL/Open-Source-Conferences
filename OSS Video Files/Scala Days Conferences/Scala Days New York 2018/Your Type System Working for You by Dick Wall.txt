Title: Your Type System Working for You by Dick Wall
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/your-type-system-working-for-you
Captions: 
	00:00:03,750 --> 00:00:07,800
so I wanted to set a couple of

00:00:06,330 --> 00:00:11,730
expectations about this this is Matt

00:00:07,800 --> 00:00:14,280
this is in the thingamajiggy the program

00:00:11,730 --> 00:00:16,350
as an expert course it's really more of

00:00:14,280 --> 00:00:18,000
an intermediate but there wasn't an

00:00:16,350 --> 00:00:20,789
intermediate setting and it's definitely

00:00:18,000 --> 00:00:23,279
not a foundations one so expect

00:00:20,789 --> 00:00:25,890
something pitched between intermediate

00:00:23,279 --> 00:00:27,720
and advanced here but I think you'll

00:00:25,890 --> 00:00:30,449
hopefully pick up some useful tricks

00:00:27,720 --> 00:00:33,390
along the way things that I've learned

00:00:30,449 --> 00:00:36,900
to do I'm also more nervous than usual

00:00:33,390 --> 00:00:38,550
about this talk because and I was kind

00:00:36,900 --> 00:00:40,860
of I put it into words with Adrian this

00:00:38,550 --> 00:00:43,650
morning this one really matters to me

00:00:40,860 --> 00:00:45,630
like more than a talk has in a long time

00:00:43,650 --> 00:00:49,080
and I hope you don't think that my

00:00:45,630 --> 00:00:54,090
baby's ugly so at least my approach is

00:00:49,080 --> 00:00:57,450
ugly so we're going to dig into kind of

00:00:54,090 --> 00:01:00,020
really using the scholar type system for

00:00:57,450 --> 00:01:03,000
simplicity but also for correctness and

00:01:00,020 --> 00:01:06,360
I work in a mixed environment where we

00:01:03,000 --> 00:01:09,090
have amongst you know we're very scholar

00:01:06,360 --> 00:01:12,930
based in the company cebo that I work

00:01:09,090 --> 00:01:15,330
for but we have a mix of kind of levels

00:01:12,930 --> 00:01:17,100
where we have a lot of soil scientists

00:01:15,330 --> 00:01:18,990
and weather scientists and people like

00:01:17,100 --> 00:01:22,440
that but really don't want to deal with

00:01:18,990 --> 00:01:23,550
the kind of vague URIs of a lot of the

00:01:22,440 --> 00:01:27,450
functional programming stuff they just

00:01:23,550 --> 00:01:28,710
want something that works and I am going

00:01:27,450 --> 00:01:30,540
to have to run oh that's better I can

00:01:28,710 --> 00:01:34,140
see I'm just wondering does it is

00:01:30,540 --> 00:01:36,360
anybody here a flat earther go on don't

00:01:34,140 --> 00:01:38,520
be shy stick your hands up I see one I

00:01:36,360 --> 00:01:40,500
see at least one hand okay I think this

00:01:38,520 --> 00:01:43,080
talk will convince you that the earth is

00:01:40,500 --> 00:01:44,670
not flat because no one in their right

00:01:43,080 --> 00:01:47,580
mind would go to these levels of

00:01:44,670 --> 00:01:53,820
complexity to perpetrate the hoax like

00:01:47,580 --> 00:01:56,270
that so the earth is not flat okay I'm

00:01:53,820 --> 00:01:58,950
gonna start with that as a preposition

00:01:56,270 --> 00:02:01,430
but most of the ways that we look at the

00:01:58,950 --> 00:02:03,600
earth are flat we deal with

00:02:01,430 --> 00:02:06,650
2-dimensional data a lot I've got a

00:02:03,600 --> 00:02:10,049
couple of examples here bottom left is a

00:02:06,650 --> 00:02:14,040
relief shaded topographic map from I

00:02:10,049 --> 00:02:15,270
think Google Maps its simulates 3d by

00:02:14,040 --> 00:02:17,190
having the shading and if you move

00:02:15,270 --> 00:02:19,860
around you actually see the kind of high

00:02:17,190 --> 00:02:22,350
the the elevation model change a bit in

00:02:19,860 --> 00:02:25,230
the middle it's really the best way to

00:02:22,350 --> 00:02:26,970
look at the earth is a globe okay it

00:02:25,230 --> 00:02:28,740
really represents how things are laid

00:02:26,970 --> 00:02:32,670
out you get to see the countries without

00:02:28,740 --> 00:02:34,470
them being all squished and smooshed of

00:02:32,670 --> 00:02:36,000
course this isn't a globe this is a flat

00:02:34,470 --> 00:02:37,470
picture of a globe and you can see how

00:02:36,000 --> 00:02:40,050
much things have been squished and

00:02:37,470 --> 00:02:42,780
smushed there right and then in the top

00:02:40,050 --> 00:02:44,910
is what I work with a lot this is data

00:02:42,780 --> 00:02:48,630
from a satellite called Landsat that

00:02:44,910 --> 00:02:51,030
orbits the earth every 16 days produces

00:02:48,630 --> 00:02:53,100
these reasonably high-resolution images

00:02:51,030 --> 00:02:55,980
about 30 meter pixels it's looking

00:02:53,100 --> 00:02:57,780
approximately straight down and there's

00:02:55,980 --> 00:02:59,820
a lot of approximations in this stuff so

00:02:57,780 --> 00:03:03,960
will will kind of get into that as we go

00:02:59,820 --> 00:03:05,340
through okay so it gets a bit more

00:03:03,960 --> 00:03:07,290
complex because the earth is not an

00:03:05,340 --> 00:03:08,910
exact spear either I don't know how many

00:03:07,290 --> 00:03:11,310
of you know this but this really matters

00:03:08,910 --> 00:03:13,290
when you're doing maps of it okay

00:03:11,310 --> 00:03:15,810
because of the spin it actually has a

00:03:13,290 --> 00:03:16,590
bit of a spare tire we can all relate to

00:03:15,810 --> 00:03:18,840
that I think

00:03:16,590 --> 00:03:20,280
but it's caused by the rotation of the

00:03:18,840 --> 00:03:23,010
earth so it's slightly wider at the

00:03:20,280 --> 00:03:25,200
equator than it is if you go around the

00:03:23,010 --> 00:03:29,070
poles and this makes the maps sorry it

00:03:25,200 --> 00:03:31,290
makes the math harder to make the maps I

00:03:29,070 --> 00:03:33,150
will talk at the end if this time and

00:03:31,290 --> 00:03:35,220
hopefully there will be about web

00:03:33,150 --> 00:03:39,060
Mercator which is the most common

00:03:35,220 --> 00:03:40,290
display projection or coordinate

00:03:39,060 --> 00:03:42,780
reference system they use these days

00:03:40,290 --> 00:03:44,970
that's in Google Maps and Bing and all

00:03:42,780 --> 00:03:47,160
of those it assumes the earth is a

00:03:44,970 --> 00:03:49,080
sphere and that means that Finland is

00:03:47,160 --> 00:03:50,550
approximately 35 miles from where it

00:03:49,080 --> 00:03:53,070
should be and a whole bunch of other

00:03:50,550 --> 00:03:54,900
things like that so we tend not to use

00:03:53,070 --> 00:03:57,959
web Mercator for like real processing

00:03:54,900 --> 00:04:01,110
work but it is really part of what you

00:03:57,959 --> 00:04:04,290
know the display stuff so that's the

00:04:01,110 --> 00:04:06,930
it's it's not exactly round either all

00:04:04,290 --> 00:04:08,459
right so how do we reference some

00:04:06,930 --> 00:04:10,350
location on Earth well probably

00:04:08,459 --> 00:04:12,900
everybody here if they've ever used the

00:04:10,350 --> 00:04:15,239
Sat Nav or any kind of GPS is familiar

00:04:12,900 --> 00:04:15,780
with lat/longs okay and this is how they

00:04:15,239 --> 00:04:17,790
work

00:04:15,780 --> 00:04:20,549
choose a point in the center of the

00:04:17,790 --> 00:04:22,740
earth okay you have two angles one of

00:04:20,549 --> 00:04:25,080
them is an angle from the prime meridian

00:04:22,740 --> 00:04:28,169
which runs through London because that's

00:04:25,080 --> 00:04:30,240
where they set it up and the other is an

00:04:28,169 --> 00:04:31,240
angle from the equator up towards or

00:04:30,240 --> 00:04:34,750
down so

00:04:31,240 --> 00:04:36,490
one of the polls okay not long a - ders

00:04:34,750 --> 00:04:39,520
it's known which is the X that goes

00:04:36,490 --> 00:04:44,230
around the the earth from the meridian

00:04:39,520 --> 00:04:48,340
is - 180 to 180 and the latitude is - 90

00:04:44,230 --> 00:04:50,890
- 90 if you take those two angles and

00:04:48,340 --> 00:04:53,230
draw a vector and then intersect it with

00:04:50,890 --> 00:04:55,600
the model that you have of this of the

00:04:53,230 --> 00:04:59,230
ellipsoid of the earth you get a point

00:04:55,600 --> 00:05:01,030
on the surface of the earth okay that's

00:04:59,230 --> 00:05:03,850
all there is to it it's very simple it's

00:05:01,030 --> 00:05:06,400
actually a really good scheme because no

00:05:03,850 --> 00:05:07,960
matter what kind of as the models of the

00:05:06,400 --> 00:05:10,360
earth get more complicated you end up

00:05:07,960 --> 00:05:12,850
with geoids so it gets even more

00:05:10,360 --> 00:05:13,990
complicated than an ellipsoid you start

00:05:12,850 --> 00:05:16,720
building in all sorts of other

00:05:13,990 --> 00:05:18,790
complexities to it but with a lat/long

00:05:16,720 --> 00:05:21,460
no matter how far you draw it based on

00:05:18,790 --> 00:05:23,530
your model it's always the same

00:05:21,460 --> 00:05:28,830
alignment right it's just height is the

00:05:23,530 --> 00:05:28,830
difference so so this worked great for

00:05:28,980 --> 00:05:34,000
vector data as we call it point polygons

00:05:32,110 --> 00:05:36,460
lines stuff like that as long as they're

00:05:34,000 --> 00:05:37,930
not too big when you get really big if

00:05:36,460 --> 00:05:40,000
you've been on a plane and you notice

00:05:37,930 --> 00:05:42,400
that the the plane never flies in a

00:05:40,000 --> 00:05:44,440
straight line it flies like a curve

00:05:42,400 --> 00:05:45,610
that's because of the curvature of the

00:05:44,440 --> 00:05:47,650
earth okay

00:05:45,610 --> 00:05:52,330
that's point one in the anti flat

00:05:47,650 --> 00:05:52,660
earther facts there but the real problem

00:05:52,330 --> 00:05:54,550
with it

00:05:52,660 --> 00:05:56,530
is all of those things I showed you at

00:05:54,550 --> 00:05:58,870
the beginning are what we tend to deal

00:05:56,530 --> 00:06:01,600
with in computers which is raster data

00:05:58,870 --> 00:06:05,050
and then it's two-dimensional and it

00:06:01,600 --> 00:06:07,960
assumes things like equal-area pixels

00:06:05,050 --> 00:06:11,320
and if you look at this you'll see that

00:06:07,960 --> 00:06:12,730
as you move latitude which is the Y

00:06:11,320 --> 00:06:15,730
dimension okay

00:06:12,730 --> 00:06:18,190
the longitude values the longitude

00:06:15,730 --> 00:06:22,300
angles cover less ground as you approach

00:06:18,190 --> 00:06:24,760
the poles okay so at the equator lat and

00:06:22,300 --> 00:06:27,610
long one degree is approximately the

00:06:24,760 --> 00:06:31,360
same but as you approach the poles one

00:06:27,610 --> 00:06:33,910
degree covers a lot a lot more no a lot

00:06:31,360 --> 00:06:38,770
less I always get that mixed up covers a

00:06:33,910 --> 00:06:41,020
lot less distance okay so basically it's

00:06:38,770 --> 00:06:42,550
no good for this raster data that we

00:06:41,020 --> 00:06:44,810
have to deal with we have to come up

00:06:42,550 --> 00:06:47,180
with some other way of

00:06:44,810 --> 00:06:48,830
the data out of that and these are the

00:06:47,180 --> 00:06:51,169
two two types of data that we deal with

00:06:48,830 --> 00:06:54,400
vector is great when you can get it has

00:06:51,169 --> 00:06:57,110
a lot of structure it scales very nicely

00:06:54,400 --> 00:06:58,910
raster data is what pretty much

00:06:57,110 --> 00:07:00,470
everything that a satellite produces

00:06:58,910 --> 00:07:02,660
will do because that's what we have we

00:07:00,470 --> 00:07:05,740
have image sensors and they they take

00:07:02,660 --> 00:07:10,280
pictures and photons go in two boxes and

00:07:05,740 --> 00:07:11,600
that's what you get okay so raster

00:07:10,280 --> 00:07:13,250
images tend to assume constant

00:07:11,600 --> 00:07:18,680
measurements the reason I'm belaboring

00:07:13,250 --> 00:07:21,350
all this is that we have to deal with

00:07:18,680 --> 00:07:22,669
the fact that when we're going to be

00:07:21,350 --> 00:07:23,330
dealing with something other than

00:07:22,669 --> 00:07:25,130
lat/longs

00:07:23,330 --> 00:07:27,050
okay and that's where all of this comes

00:07:25,130 --> 00:07:28,610
in coordinate reference systems and

00:07:27,050 --> 00:07:32,360
projections between coordinate reference

00:07:28,610 --> 00:07:34,790
systems so some definitions a coordinate

00:07:32,360 --> 00:07:36,080
reference system or a CRS as it will be

00:07:34,790 --> 00:07:38,600
called from now on because it's a lot

00:07:36,080 --> 00:07:40,669
easier to say is anything that takes

00:07:38,600 --> 00:07:42,830
numbers and makes a location out of them

00:07:40,669 --> 00:07:45,680
on the earth or on the moon or in the

00:07:42,830 --> 00:07:48,110
galaxy whatever it is a projection is

00:07:45,680 --> 00:07:49,850
anything that takes one CRS and turns it

00:07:48,110 --> 00:07:52,640
into another CRS okay it's a

00:07:49,850 --> 00:07:55,850
mathematical transform the projection

00:07:52,640 --> 00:07:58,520
plus the datum so some center point or

00:07:55,850 --> 00:08:00,020
other things you know the radius of the

00:07:58,520 --> 00:08:03,800
earth all of these things are considered

00:08:00,020 --> 00:08:05,450
the datums define how one CRS relates to

00:08:03,800 --> 00:08:07,370
another mathematically and we can

00:08:05,450 --> 00:08:10,190
convert between the CRS --is with

00:08:07,370 --> 00:08:12,169
varying amounts of error and the error

00:08:10,190 --> 00:08:13,580
tends to be smaller for vector data than

00:08:12,169 --> 00:08:15,470
harass the data we have to resample

00:08:13,580 --> 00:08:18,440
raster's and that means moving pixels

00:08:15,470 --> 00:08:20,450
around and literally a pixel is like a

00:08:18,440 --> 00:08:22,010
bunch of ping-pong balls that have been

00:08:20,450 --> 00:08:23,600
captured in a box and now you have to

00:08:22,010 --> 00:08:26,690
redistribute the ping-pong balls and

00:08:23,600 --> 00:08:28,400
this it's it's difficult to do that so

00:08:26,690 --> 00:08:30,770
therefore we resist transforming or

00:08:28,400 --> 00:08:34,490
resampling raster data more than we do

00:08:30,770 --> 00:08:35,599
transforming vector data a few examples

00:08:34,490 --> 00:08:36,469
I'm not going to spend a lot of time on

00:08:35,599 --> 00:08:40,190
these because I want to get to the

00:08:36,469 --> 00:08:43,099
scalar stuff but these are sort of some

00:08:40,190 --> 00:08:44,690
of the different ways that CRS is or

00:08:43,099 --> 00:08:48,470
projections are made for the earth

00:08:44,690 --> 00:08:50,330
there's conical there's the polar kind

00:08:48,470 --> 00:08:52,279
they're conical is sort of like a hat

00:08:50,330 --> 00:08:53,900
that the earth wears it's very good for

00:08:52,279 --> 00:08:57,690
the US because the u.s. is kind of wide

00:08:53,900 --> 00:09:01,340
and not too high so Albers

00:08:57,690 --> 00:09:04,320
conical elbows one is commonly used for

00:09:01,340 --> 00:09:06,090
the whole US and in the top is the

00:09:04,320 --> 00:09:07,950
transverse mercator that pretty much

00:09:06,090 --> 00:09:10,560
everybody learns about in school and the

00:09:07,950 --> 00:09:12,090
way transverse mercator works is it's

00:09:10,560 --> 00:09:13,440
like a cylinder wrapped around the earth

00:09:12,090 --> 00:09:16,590
there's actually two of them one for

00:09:13,440 --> 00:09:19,050
north and one for south and every six

00:09:16,590 --> 00:09:20,580
degrees you get a new cylinder and then

00:09:19,050 --> 00:09:22,650
you kind of unwrap the cylinder and you

00:09:20,580 --> 00:09:25,250
unwrap the cylinder this way and the

00:09:22,650 --> 00:09:28,440
result is something that approximates

00:09:25,250 --> 00:09:30,210
equal area for the pixels in it okay now

00:09:28,440 --> 00:09:32,190
the problem is we're going to bunch

00:09:30,210 --> 00:09:35,880
these across the United States because

00:09:32,190 --> 00:09:39,180
the states is pretty pretty large the

00:09:35,880 --> 00:09:42,570
contiguous 48 the lower 48 have nine

00:09:39,180 --> 00:09:44,520
zones that cover them Alaska has oh I

00:09:42,570 --> 00:09:47,460
don't know I think it has five of its

00:09:44,520 --> 00:09:49,020
own that's a little bit disingenuous you

00:09:47,460 --> 00:09:51,360
know Alaska is more than twice as big as

00:09:49,020 --> 00:09:52,830
Texas they love to point that out this

00:09:51,360 --> 00:09:56,690
makes it look like it's smaller I think

00:09:52,830 --> 00:09:59,730
this would made by Texan this map anyway

00:09:56,690 --> 00:10:01,380
so this is the meat of it why do we care

00:09:59,730 --> 00:10:03,170
about all these CRS is well there are

00:10:01,380 --> 00:10:07,560
thousands of these they're actually

00:10:03,170 --> 00:10:09,720
defined they've been standardized now by

00:10:07,560 --> 00:10:11,550
Big Oil funny enough the European

00:10:09,720 --> 00:10:14,940
petroleum standards group now has a

00:10:11,550 --> 00:10:16,920
reference repository for all of these

00:10:14,940 --> 00:10:20,190
CRS a--'s that you have to deal with and

00:10:16,920 --> 00:10:23,160
the real but the real evil here is if

00:10:20,190 --> 00:10:26,220
you get the wrong CRS a lot of the a lot

00:10:23,160 --> 00:10:28,680
of the the the CRS coordinates overlap

00:10:26,220 --> 00:10:30,630
in mathematical space so here's an

00:10:28,680 --> 00:10:33,840
example of a polygon drawn around a

00:10:30,630 --> 00:10:36,420
field and if I get the CRS the field is

00:10:33,840 --> 00:10:38,880
now in the middle of Lake Michigan okay

00:10:36,420 --> 00:10:40,920
it doesn't even give you an exception it

00:10:38,880 --> 00:10:43,620
just gives you the wrong data back this

00:10:40,920 --> 00:10:46,320
is like the worst possible outcome and

00:10:43,620 --> 00:10:49,500
it's really common in geospatial data

00:10:46,320 --> 00:10:52,080
people ignore the CRS or get confused

00:10:49,500 --> 00:10:54,750
about it drop it it gets lost somewhere

00:10:52,080 --> 00:10:56,190
along the way and the result is you

00:10:54,750 --> 00:10:58,230
don't get bad data you just get

00:10:56,190 --> 00:11:00,450
incorrect data returned to you okay so

00:10:58,230 --> 00:11:02,010
this is obviously very bad I had to make

00:11:00,450 --> 00:11:04,320
it really small there because it's right

00:11:02,010 --> 00:11:05,400
in the middle of the lake and you would

00:11:04,320 --> 00:11:09,930
have just seen a whole bunch of blue

00:11:05,400 --> 00:11:11,220
otherwise so all right most systems most

00:11:09,930 --> 00:11:15,269
languages

00:11:11,220 --> 00:11:18,000
work like this they do runtime CRS

00:11:15,269 --> 00:11:19,529
checking so they'd you'd do something

00:11:18,000 --> 00:11:23,250
like this here's all the different codes

00:11:19,529 --> 00:11:28,470
for three to six is lat/longs WGS 84 lat

00:11:23,250 --> 00:11:31,319
Long's 3 to 6 1 5 is UTM zone 15 if you

00:11:28,470 --> 00:11:33,209
get them mixed up you get nonsense or

00:11:31,319 --> 00:11:35,790
you get weird things happening the wrong

00:11:33,209 --> 00:11:38,939
data whatever it is so what a lot of

00:11:35,790 --> 00:11:41,189
code will do is it will have something

00:11:38,939 --> 00:11:42,420
that does a ensure the same CRS

00:11:41,189 --> 00:11:44,310
something like that will throw an

00:11:42,420 --> 00:11:46,350
exception and you need to put this all

00:11:44,310 --> 00:11:48,660
over your code and haven't helped you if

00:11:46,350 --> 00:11:50,399
you forget because now you're dealing

00:11:48,660 --> 00:11:54,569
with something that you don't know what

00:11:50,399 --> 00:11:56,759
ok so my idea when I came into this and

00:11:54,569 --> 00:11:59,310
actually I have a background in GIS so

00:11:56,759 --> 00:12:01,079
coming to do this current job kind of

00:11:59,310 --> 00:12:02,310
brought me back into it and it's really

00:12:01,079 --> 00:12:03,930
exciting to bring my two passions

00:12:02,310 --> 00:12:07,850
together now it's one of the reasons why

00:12:03,930 --> 00:12:10,529
this is kind of important to me but some

00:12:07,850 --> 00:12:12,959
type parameters in Scala become part of

00:12:10,529 --> 00:12:14,879
the type this is great I don't think

00:12:12,959 --> 00:12:16,319
this will be a surprise to anyone set is

00:12:14,879 --> 00:12:19,230
a great example because it's invariant

00:12:16,319 --> 00:12:20,910
and so if you have a set of int and a

00:12:19,230 --> 00:12:22,589
set of string they're two totally

00:12:20,910 --> 00:12:24,180
different types as far as the Scala

00:12:22,589 --> 00:12:25,500
compiler is concerned you can't change

00:12:24,180 --> 00:12:27,899
the male you can't use them

00:12:25,500 --> 00:12:30,509
interchangeably and with a set you can't

00:12:27,899 --> 00:12:32,880
just make a set of any that will take a

00:12:30,509 --> 00:12:34,259
set of in a function with a set of any

00:12:32,880 --> 00:12:36,120
that takes a set of interest set of

00:12:34,259 --> 00:12:38,850
string they're just not related in the

00:12:36,120 --> 00:12:41,730
Scala type system so I thought well

00:12:38,850 --> 00:12:42,839
let's see oh and I should say we're

00:12:41,730 --> 00:12:44,579
gonna go a little bit into Scala

00:12:42,839 --> 00:12:46,230
variants I'm not going to cover all of

00:12:44,579 --> 00:12:48,269
Scala variants in this there's quite a

00:12:46,230 --> 00:12:50,220
lot to learn there what you really need

00:12:48,269 --> 00:12:53,699
to know is in variant and covariant for

00:12:50,220 --> 00:12:56,309
this talk invariant means that given two

00:12:53,699 --> 00:12:58,639
different types type parameters inside

00:12:56,309 --> 00:13:02,519
of a type they are just different types

00:12:58,639 --> 00:13:05,459
covariant means that if B extends a and

00:13:02,519 --> 00:13:07,620
you have say a list of B that is an

00:13:05,459 --> 00:13:10,559
extension of a list of a or a subclass

00:13:07,620 --> 00:13:12,990
of a list of a so they're related by the

00:13:10,559 --> 00:13:14,639
the type parameters we're not going to

00:13:12,990 --> 00:13:17,220
do contravariance in this one but

00:13:14,639 --> 00:13:20,670
there's plenty of stuff out there if you

00:13:17,220 --> 00:13:23,819
want to see more on that okay so what I

00:13:20,670 --> 00:13:24,960
thought was we can now take those CRS

00:13:23,819 --> 00:13:28,740
a--'s that are this problem

00:13:24,960 --> 00:13:30,210
this this easy mixed-up thing and we'll

00:13:28,740 --> 00:13:32,190
make the compiler do the work for us

00:13:30,210 --> 00:13:35,610
it's going to track the CRS s through

00:13:32,190 --> 00:13:38,520
the system so that if somebody tries to

00:13:35,610 --> 00:13:42,300
use the wrong CRS the code won't compile

00:13:38,520 --> 00:13:44,310
anymore and so we start as all these

00:13:42,300 --> 00:13:47,670
things and I think this is really kind

00:13:44,310 --> 00:13:48,590
of the art of API design for me is doing

00:13:47,670 --> 00:13:51,450
something clever

00:13:48,590 --> 00:13:53,520
clovis not bad by itself but you

00:13:51,450 --> 00:13:55,260
shouldn't you shouldn't impress that

00:13:53,520 --> 00:13:57,150
cleverness on everybody else you should

00:13:55,260 --> 00:13:59,550
make it so simple that everybody else

00:13:57,150 --> 00:14:01,470
uses it and they are completely unaware

00:13:59,550 --> 00:14:03,360
of how clever you've been I know it goes

00:14:01,470 --> 00:14:05,820
against the grain we all want to do hah

00:14:03,360 --> 00:14:07,370
look at this it's so cool but if you can

00:14:05,820 --> 00:14:10,770
make it completely invisible

00:14:07,370 --> 00:14:13,560
it's amazing how how good that makes you

00:14:10,770 --> 00:14:15,360
feel and in particular after a

00:14:13,560 --> 00:14:16,980
particularly long project somebody did

00:14:15,360 --> 00:14:19,020
some work on some stuff in Brazil

00:14:16,980 --> 00:14:20,280
recently at work and they're like hey

00:14:19,020 --> 00:14:21,390
the data just came out and is in the

00:14:20,280 --> 00:14:24,720
right place and everything and I'm like

00:14:21,390 --> 00:14:27,690
that's pretty rare in GIS that somebody

00:14:24,720 --> 00:14:31,260
didn't drop a CRC RS in there along the

00:14:27,690 --> 00:14:33,810
way so case classes make a great stake a

00:14:31,260 --> 00:14:36,500
great place to start for API so I've

00:14:33,810 --> 00:14:38,340
always thought here's a CRS definition

00:14:36,500 --> 00:14:40,440
for now we're just going to look up

00:14:38,340 --> 00:14:42,030
codes from a library and this is all

00:14:40,440 --> 00:14:43,740
based on a library that's done all this

00:14:42,030 --> 00:14:48,450
definition it's a Java library it has no

00:14:43,740 --> 00:14:50,250
type safety to speak of of its own so

00:14:48,450 --> 00:14:52,170
we're trying to build that in it's

00:14:50,250 --> 00:14:54,390
called geo tools but it is extremely

00:14:52,170 --> 00:14:56,490
well tested and you do not want to get

00:14:54,390 --> 00:14:59,280
into writing a whole bunch of CRS isn't

00:14:56,490 --> 00:15:03,120
testing them yourself so we have a case

00:14:59,280 --> 00:15:06,210
class this is lat/long wgs84 also known

00:15:03,120 --> 00:15:10,010
as epsg for 3:00 to 6:00 and we decode

00:15:06,210 --> 00:15:12,330
it and that becomes a type in our system

00:15:10,010 --> 00:15:14,160
some of you may be wondering why I made

00:15:12,330 --> 00:15:17,160
that a case class and not a case object

00:15:14,160 --> 00:15:19,650
at this point right so why did I make it

00:15:17,160 --> 00:15:21,750
a case class well there's a trick you

00:15:19,650 --> 00:15:23,910
can do with the companion if you do this

00:15:21,750 --> 00:15:27,380
and this is something I do probably too

00:15:23,910 --> 00:15:30,450
much but it's a really neat trick so I

00:15:27,380 --> 00:15:33,420
can now register on the aim here is to

00:15:30,450 --> 00:15:36,150
make a type for the CRS but to be able

00:15:33,420 --> 00:15:38,819
to pair it with an implementation of

00:15:36,150 --> 00:15:41,910
value that I can pull out using the

00:15:38,819 --> 00:15:44,309
type at any point so I pass around the

00:15:41,910 --> 00:15:46,289
type e PSG for three to six and when I

00:15:44,309 --> 00:15:48,539
need the definition of whatever the CRS

00:15:46,289 --> 00:15:51,089
is I can easily just pull that out from

00:15:48,539 --> 00:15:55,439
the type okay the way we can do that is

00:15:51,089 --> 00:15:57,749
an implicit companion so here I create

00:15:55,439 --> 00:16:00,389
the case class I define it and then I

00:15:57,749 --> 00:16:04,439
immediately say object epsg for three to

00:16:00,389 --> 00:16:07,129
six extends CRS type of that case class

00:16:04,439 --> 00:16:09,779
type and inside of the implementation

00:16:07,129 --> 00:16:13,229
I'm walking over here so I can point

00:16:09,779 --> 00:16:18,689
oops but don't fall off I don't know

00:16:13,229 --> 00:16:19,979
Martin so what we can do is we know

00:16:18,689 --> 00:16:21,929
there's going to be an apply method

00:16:19,979 --> 00:16:24,539
right with a case class because that's

00:16:21,929 --> 00:16:26,039
what apply methods do they generate case

00:16:24,539 --> 00:16:28,139
classes do they generate apply and

00:16:26,039 --> 00:16:30,600
unapplied we know the type signature of

00:16:28,139 --> 00:16:33,059
that so we can harness that so I can use

00:16:30,600 --> 00:16:35,279
the apply method to create an instance

00:16:33,059 --> 00:16:38,129
internally and do a few other things in

00:16:35,279 --> 00:16:40,859
there so you can here say see here that

00:16:38,129 --> 00:16:42,809
I've got the CRS death which is just a

00:16:40,859 --> 00:16:45,749
vowel that is the call to that apply

00:16:42,809 --> 00:16:47,609
when I need it the rest of this stuff is

00:16:45,749 --> 00:16:49,409
not that interesting apart from the last

00:16:47,609 --> 00:16:50,759
line it's just things like you know

00:16:49,409 --> 00:16:53,489
giving the actual coordinate reference

00:16:50,759 --> 00:16:56,369
system and the ID the last line is a

00:16:53,489 --> 00:16:59,220
nice little trick that again I can't

00:16:56,369 --> 00:17:01,619
believe I got away with it by making a

00:16:59,220 --> 00:17:03,959
cell appointed back to yourself the

00:17:01,619 --> 00:17:06,870
companion object is always checked for

00:17:03,959 --> 00:17:08,429
implicit when it when the scholar type

00:17:06,870 --> 00:17:10,949
oh when the Scala compiler needs to

00:17:08,429 --> 00:17:13,529
solve a type problem by making this

00:17:10,949 --> 00:17:16,829
thing extend the type class and then

00:17:13,529 --> 00:17:19,620
making a pointer back to ourselves we

00:17:16,829 --> 00:17:20,789
make it its own implicit okay it will be

00:17:19,620 --> 00:17:22,919
an implicit that's always found because

00:17:20,789 --> 00:17:24,169
it's in the companion object does that

00:17:22,919 --> 00:17:29,399
make sense

00:17:24,169 --> 00:17:32,190
so basically by just saying objects epsg

00:17:29,399 --> 00:17:34,860
extend CRS type of four three two six

00:17:32,190 --> 00:17:37,409
that now becomes the implicit type class

00:17:34,860 --> 00:17:41,580
and these two are paired in the type

00:17:37,409 --> 00:17:43,139
system now the type and the definition

00:17:41,580 --> 00:17:45,419
are in a harmony so if we make a

00:17:43,139 --> 00:17:48,299
geometry type an abstract geometry type

00:17:45,419 --> 00:17:50,549
and within that we specify that the CRS

00:17:48,299 --> 00:17:50,820
has to be a CRS type it has to have an

00:17:50,549 --> 00:17:54,360
it

00:17:50,820 --> 00:17:57,330
contexts bound of CRS type we can get

00:17:54,360 --> 00:17:59,520
that CRS and it's like we're passing in

00:17:57,330 --> 00:18:01,860
the CRS as a constructor parameter but

00:17:59,520 --> 00:18:03,750
we're passing it in as a type right now

00:18:01,860 --> 00:18:05,400
there's things in the type system but we

00:18:03,750 --> 00:18:07,800
can still get to the definition whenever

00:18:05,400 --> 00:18:09,270
we want to and here you can see a bit of

00:18:07,800 --> 00:18:12,630
code that is just looking up the math

00:18:09,270 --> 00:18:15,570
transform for another CRS that comes in

00:18:12,630 --> 00:18:17,610
some other CRS type and it will look up

00:18:15,570 --> 00:18:22,680
the transform and then it will return it

00:18:17,610 --> 00:18:24,120
so to use that let's say we have a

00:18:22,680 --> 00:18:26,550
coordinate let's start with the simplest

00:18:24,120 --> 00:18:30,120
thing so a 2d coordinate has an X and a

00:18:26,550 --> 00:18:34,110
Y and it has a CRS type so any

00:18:30,120 --> 00:18:35,730
coordinate we make now has epsg four

00:18:34,110 --> 00:18:37,350
three two six and then in this case

00:18:35,730 --> 00:18:39,690
along and a lat

00:18:37,350 --> 00:18:42,240
something I don't think you guys really

00:18:39,690 --> 00:18:44,040
care about but for sanity's sake we

00:18:42,240 --> 00:18:47,040
always put X first so it's always long

00:18:44,040 --> 00:18:49,800
lats in G is when we work with this

00:18:47,040 --> 00:18:52,920
stuff otherwise it gets too confusing

00:18:49,800 --> 00:18:54,780
within here the behind the scenes we use

00:18:52,920 --> 00:18:56,670
JT s which is another Java library

00:18:54,780 --> 00:18:59,460
that's very well tested and not at all

00:18:56,670 --> 00:19:02,070
type safe it string ly typed in fact a

00:18:59,460 --> 00:19:03,870
lot of it so we want to hide that as

00:19:02,070 --> 00:19:05,910
much as possible but it is used behind

00:19:03,870 --> 00:19:08,040
the scenes because again we don't want

00:19:05,910 --> 00:19:09,510
to deal with a lot of the stuff that's

00:19:08,040 --> 00:19:12,930
already been written and well tested

00:19:09,510 --> 00:19:15,480
there but I can take a coordinate in

00:19:12,930 --> 00:19:18,330
some CRS and I can transform it to

00:19:15,480 --> 00:19:22,050
another CRS at which point we get back a

00:19:18,330 --> 00:19:24,000
new type okay let's say I take four

00:19:22,050 --> 00:19:26,490
three two six and I want to convert it

00:19:24,000 --> 00:19:31,170
to three two six one five I would say

00:19:26,490 --> 00:19:34,110
coordinate transform CRS epsg three two

00:19:31,170 --> 00:19:36,180
six one five that gives me back the new

00:19:34,110 --> 00:19:39,540
type and it does the transformation

00:19:36,180 --> 00:19:43,410
behind the scenes right so somebody

00:19:39,540 --> 00:19:46,260
coming in they get some CRS in some

00:19:43,410 --> 00:19:49,230
random or some point in some random CRS

00:19:46,260 --> 00:19:51,150
they need it in another CRS to satisfy

00:19:49,230 --> 00:19:52,470
another part of the program in order to

00:19:51,150 --> 00:19:53,970
get that they do the transformation

00:19:52,470 --> 00:19:56,820
whether they want to or not because they

00:19:53,970 --> 00:19:58,860
have to to get it to compile all right

00:19:56,820 --> 00:20:02,060
and pretty much the rest of that is the

00:19:58,860 --> 00:20:04,110
is the plumbing everybody with me so far

00:20:02,060 --> 00:20:04,650
there were time for questions at the end

00:20:04,110 --> 00:20:07,260
but

00:20:04,650 --> 00:20:09,059
if anybody is really having like a

00:20:07,260 --> 00:20:09,650
burning question right now you can't

00:20:09,059 --> 00:20:13,590
stop me

00:20:09,650 --> 00:20:16,200
all right so by doing this the compiler

00:20:13,590 --> 00:20:19,410
Nair has your back we can create a

00:20:16,200 --> 00:20:20,790
coordinate in epsg for three to six you

00:20:19,410 --> 00:20:24,300
can see it up there that is in the type

00:20:20,790 --> 00:20:26,940
so everything has a CRS now this is one

00:20:24,300 --> 00:20:30,420
of the rules of GIS nothing gets even in

00:20:26,940 --> 00:20:31,800
like non typed solutions nothing is

00:20:30,420 --> 00:20:33,450
allowed in the system without a

00:20:31,800 --> 00:20:36,030
coordinate reference system attached to

00:20:33,450 --> 00:20:38,010
it and in our case we don't allow

00:20:36,030 --> 00:20:40,559
anything in without a CRS type anymore

00:20:38,010 --> 00:20:43,830
so everything we create has a CRS type

00:20:40,559 --> 00:20:47,040
and it's tracked through the system so

00:20:43,830 --> 00:20:49,380
coordinates 2d in lat/longs there we go

00:20:47,040 --> 00:20:52,020
I have down here a method that requires

00:20:49,380 --> 00:20:56,190
a coordinate 2d in lat/longs for three

00:20:52,020 --> 00:20:58,410
to six I can call it with a show map and

00:20:56,190 --> 00:21:00,360
that works okay it says oh I'm showing

00:20:58,410 --> 00:21:03,690
the map at those coordinates if I try

00:21:00,360 --> 00:21:06,690
and call it with a coordinate in three

00:21:03,690 --> 00:21:11,280
to six one zero in this case which is

00:21:06,690 --> 00:21:12,720
the California UTM zone it will give me

00:21:11,280 --> 00:21:14,550
a compile error at that point even

00:21:12,720 --> 00:21:16,380
better IntelliJ will tell me what's

00:21:14,550 --> 00:21:18,990
wrong and look it's actually a readable

00:21:16,380 --> 00:21:20,670
error message as well this is great

00:21:18,990 --> 00:21:23,160
right don't underestimate the power of

00:21:20,670 --> 00:21:25,530
this to somebody who is just a soil

00:21:23,160 --> 00:21:28,110
scientist and they're like oh it says it

00:21:25,530 --> 00:21:30,290
needs a coordinate in four three two six

00:21:28,110 --> 00:21:32,460
and it's got one in three two six one Oh

00:21:30,290 --> 00:21:36,000
at least at that point they know where

00:21:32,460 --> 00:21:38,160
to start looking so and of course you

00:21:36,000 --> 00:21:44,030
can make it work by transforming it just

00:21:38,160 --> 00:21:45,990
in time to the CRS that you want so

00:21:44,030 --> 00:21:48,090
somebody at this point should have said

00:21:45,990 --> 00:21:50,640
but there's a floor okay all of this

00:21:48,090 --> 00:21:54,750
assumes that you know what the CRS is at

00:21:50,640 --> 00:21:56,610
compile time and it's a harsh world out

00:21:54,750 --> 00:21:58,230
there the scholar type system only

00:21:56,610 --> 00:22:00,480
exists in one place and that's inside

00:21:58,230 --> 00:22:02,610
the Scala compiler right the rest of the

00:22:00,480 --> 00:22:05,370
world doesn't give a damn about the

00:22:02,610 --> 00:22:07,590
Scala type system so at some point you

00:22:05,370 --> 00:22:10,050
have to bring this thing in and when you

00:22:07,590 --> 00:22:11,850
do it could be from some source and you

00:22:10,050 --> 00:22:14,850
just don't know what the CRS type is

00:22:11,850 --> 00:22:17,080
going to be so for this we need some

00:22:14,850 --> 00:22:20,410
kind of type a

00:22:17,080 --> 00:22:23,980
you know literally you'd say it as I've

00:22:20,410 --> 00:22:27,040
got this coordinate for some type for

00:22:23,980 --> 00:22:29,440
some CRS okay anybody heard for some

00:22:27,040 --> 00:22:30,330
recently I know it's going away but you

00:22:29,440 --> 00:22:33,550
know what that is

00:22:30,330 --> 00:22:37,750
anyone said yep

00:22:33,550 --> 00:22:39,070
I didn't hear it but it's I'm gonna

00:22:37,750 --> 00:22:41,110
assume you were right it's an

00:22:39,070 --> 00:22:42,670
existential type right it means there's

00:22:41,110 --> 00:22:45,970
some type here but I don't really know

00:22:42,670 --> 00:22:49,000
what it is but it is unique in the

00:22:45,970 --> 00:22:52,270
scalar type system so where you need to

00:22:49,000 --> 00:22:54,610
make an existential CRS you're saying

00:22:52,270 --> 00:22:56,080
there's some CRS here it's valid I don't

00:22:54,610 --> 00:22:58,270
know what the type is but what I want to

00:22:56,080 --> 00:23:00,190
make sure is that it is unique within

00:22:58,270 --> 00:23:01,810
the scalar type system there's a really

00:23:00,190 --> 00:23:03,970
easy way to do this you can make a trait

00:23:01,810 --> 00:23:06,430
within the trait you can define the type

00:23:03,970 --> 00:23:08,890
and you can define its implicit

00:23:06,430 --> 00:23:10,150
companion right there with it you can

00:23:08,890 --> 00:23:12,270
give them the same name and then when

00:23:10,150 --> 00:23:15,550
you import them they come in as a pair

00:23:12,270 --> 00:23:17,080
okay and you can use them now this CRS

00:23:15,550 --> 00:23:19,660
we don't know what it is but we know

00:23:17,080 --> 00:23:21,340
it's valid because there's an implicit

00:23:19,660 --> 00:23:22,960
companion with it the only way we can

00:23:21,340 --> 00:23:25,660
create that is to actually find

00:23:22,960 --> 00:23:29,020
something that satisfies that coordinate

00:23:25,660 --> 00:23:31,420
reference system that we need so we have

00:23:29,020 --> 00:23:33,940
some type it's unique because it's path

00:23:31,420 --> 00:23:35,980
dependent okay whatever we access this

00:23:33,940 --> 00:23:38,790
thing through when we create an instance

00:23:35,980 --> 00:23:41,920
of one of these some CRS is that

00:23:38,790 --> 00:23:43,570
capitals all capitals some CRS there is

00:23:41,920 --> 00:23:46,720
going to be unique in the scalar type

00:23:43,570 --> 00:23:48,850
system and I probably shouldn't do that

00:23:46,720 --> 00:23:51,160
because it looks bad on the camera but I

00:23:48,850 --> 00:23:54,100
can't see anywhere you say

00:23:51,160 --> 00:23:56,410
so this lets us do something like this

00:23:54,100 --> 00:23:59,410
we can go we can write something which

00:23:56,410 --> 00:24:02,110
just looks up a CRS whatever it is from

00:23:59,410 --> 00:24:04,420
say a string an ID and it will give us

00:24:02,110 --> 00:24:06,940
back you know in this case an option or

00:24:04,420 --> 00:24:09,520
it will throw an exception but it gives

00:24:06,940 --> 00:24:12,280
us back the type and the implicit that

00:24:09,520 --> 00:24:15,160
satisfies that type so now when we come

00:24:12,280 --> 00:24:17,380
to use this we can say oh I've got a

00:24:15,160 --> 00:24:20,620
point coming in you know here I've

00:24:17,380 --> 00:24:22,270
written it in a test but it might be

00:24:20,620 --> 00:24:23,620
defined at the top of a shape file or

00:24:22,270 --> 00:24:25,810
something like that or I know in a

00:24:23,620 --> 00:24:29,680
sidecar file usually with shape files

00:24:25,810 --> 00:24:30,700
and we can look that up we can create a

00:24:29,680 --> 00:24:33,130
type for it that's

00:24:30,700 --> 00:24:34,810
Niq we can look up the details for it

00:24:33,130 --> 00:24:38,020
and we can give all that back then what

00:24:34,810 --> 00:24:40,720
we can do is with that item that we get

00:24:38,020 --> 00:24:44,830
back with some CRS instance there we can

00:24:40,720 --> 00:24:47,020
import dot some CRS from it that brings

00:24:44,830 --> 00:24:49,510
in the type and its companion that makes

00:24:47,020 --> 00:24:52,870
it a real CRS type in our system it's

00:24:49,510 --> 00:24:55,540
now unique ok at this point we need to

00:24:52,870 --> 00:24:57,640
reify with what we know so this is where

00:24:55,540 --> 00:24:59,530
we do the transform and if you've

00:24:57,640 --> 00:25:01,390
written the transform correctly and it

00:24:59,530 --> 00:25:03,190
can say oh well this is already one of

00:25:01,390 --> 00:25:04,390
those then you can do a simple cast

00:25:03,190 --> 00:25:06,340
behind the scenes you don't need to

00:25:04,390 --> 00:25:07,870
transform anything but otherwise you can

00:25:06,340 --> 00:25:10,480
transform it just in time to what you

00:25:07,870 --> 00:25:12,790
need ok the other way of doing this is

00:25:10,480 --> 00:25:15,580
sometimes you'd never find out what the

00:25:12,790 --> 00:25:18,850
CRS is it's still a unique type it

00:25:15,580 --> 00:25:20,380
starts in one UTM zone and you go quite

00:25:18,850 --> 00:25:23,770
happily through your entire programming

00:25:20,380 --> 00:25:25,420
program using that unique type okay it

00:25:23,770 --> 00:25:27,670
doesn't matter what it is it's still

00:25:25,420 --> 00:25:29,890
consistent we know that everything else

00:25:27,670 --> 00:25:33,070
has to be converted to that type in

00:25:29,890 --> 00:25:35,110
order to work so it works both ways it's

00:25:33,070 --> 00:25:36,730
great so when we're dealing with

00:25:35,110 --> 00:25:38,440
raster's as I said at the beginning we

00:25:36,730 --> 00:25:41,020
tend to resist resampling them because

00:25:38,440 --> 00:25:42,880
it's a lossy operation so everything

00:25:41,020 --> 00:25:45,550
else that we deal with gets converted to

00:25:42,880 --> 00:25:47,470
that existential CRS instead as we go

00:25:45,550 --> 00:25:49,210
through it gets the transformation and

00:25:47,470 --> 00:25:52,420
goes through to it there's probably a

00:25:49,210 --> 00:25:54,190
bit small but this is a polygon you can

00:25:52,420 --> 00:25:57,280
see the slides afterwards the main thing

00:25:54,190 --> 00:25:59,980
about this is it uses the coordinates it

00:25:57,280 --> 00:26:01,510
uses the coordinates inside and it uses

00:25:59,980 --> 00:26:03,610
the transformation on each coordinate

00:26:01,510 --> 00:26:08,100
and then you can see that in the

00:26:03,610 --> 00:26:08,100
transform CRS there so that takes its

00:26:08,340 --> 00:26:13,030
context bound and these contexts bounds

00:26:11,230 --> 00:26:14,770
chained out right they automatically

00:26:13,030 --> 00:26:16,150
they're done through implicit they

00:26:14,770 --> 00:26:18,970
automatically chain up through the

00:26:16,150 --> 00:26:21,520
system so we know because we've got that

00:26:18,970 --> 00:26:23,200
CRS type on there that the coordinates

00:26:21,520 --> 00:26:24,850
can be converted and then at the end of

00:26:23,200 --> 00:26:29,590
it we can just give back a polygon in

00:26:24,850 --> 00:26:32,830
that new CRS alright the result of this

00:26:29,590 --> 00:26:35,200
is that the the API is now really hard

00:26:32,830 --> 00:26:37,750
to get wrong it's just about foolproof

00:26:35,200 --> 00:26:40,660
it really is about the only way you can

00:26:37,750 --> 00:26:42,820
screw it up is when you make the pairing

00:26:40,660 --> 00:26:43,700
between the CRS and the implicit

00:26:42,820 --> 00:26:46,190
companion

00:26:43,700 --> 00:26:47,929
that you type in something wrong so

00:26:46,190 --> 00:26:50,510
don't do that don't do a typo there or

00:26:47,929 --> 00:26:52,610
your you'll end up pairing the wrong

00:26:50,510 --> 00:26:54,559
type with the wrong definition but as

00:26:52,610 --> 00:26:55,820
long as you don't do that the rest of

00:26:54,559 --> 00:26:57,559
its pretty good they pout the only other

00:26:55,820 --> 00:26:59,299
way you can go wrong is to put something

00:26:57,559 --> 00:27:00,799
in your system without a CRS type on it

00:26:59,299 --> 00:27:03,320
and that doesn't make it pass code

00:27:00,799 --> 00:27:05,840
review so that's that's how we get

00:27:03,320 --> 00:27:07,639
around that so something just something

00:27:05,840 --> 00:27:09,830
I wanted to point out here is that Scala

00:27:07,639 --> 00:27:10,970
test has a really nice feature for this

00:27:09,830 --> 00:27:12,889
which is if you want to check that

00:27:10,970 --> 00:27:14,210
something doesn't compile you can write

00:27:12,889 --> 00:27:14,899
a test for that I'm not sure if you've

00:27:14,210 --> 00:27:16,639
seen that before

00:27:14,899 --> 00:27:18,649
but you can put a string with the code

00:27:16,639 --> 00:27:21,799
in and then you can say that should not

00:27:18,649 --> 00:27:23,419
type check and if it does type check it

00:27:21,799 --> 00:27:24,740
means that you've failed the test okay

00:27:23,419 --> 00:27:28,130
and you can see down at the bottom there

00:27:24,740 --> 00:27:30,799
I wrote out that same that same thing

00:27:28,130 --> 00:27:33,470
and you can see what it tells you is

00:27:30,799 --> 00:27:37,130
type mismatch expected coordinate in EPS

00:27:33,470 --> 00:27:40,010
d3 2 6 1 5 it actually got 1 in 3 2 6 1

00:27:37,130 --> 00:27:43,870
6 we now don't have data in the middle

00:27:40,010 --> 00:27:46,100
of Lake Michigan which is good alright a

00:27:43,870 --> 00:27:47,960
little bit more nuance actually I'm

00:27:46,100 --> 00:27:51,200
doing one on time so this is going going

00:27:47,960 --> 00:27:53,720
good a little bit more nuance at the

00:27:51,200 --> 00:27:54,860
beginning I showed you the angles the

00:27:53,720 --> 00:27:59,059
angle types lat/longs

00:27:54,860 --> 00:28:01,480
and the UTM zones are meter based okay

00:27:59,059 --> 00:28:03,169
everything you give the X and the y are

00:28:01,480 --> 00:28:04,549
approximately meters and there's

00:28:03,169 --> 00:28:07,010
actually a guarantee of how accurate

00:28:04,549 --> 00:28:08,929
they are this there are math people that

00:28:07,010 --> 00:28:11,870
love this stuff man everything's defined

00:28:08,929 --> 00:28:15,889
the accuracy of the thing how much how

00:28:11,870 --> 00:28:17,450
much the the pixels can drift in terms

00:28:15,889 --> 00:28:18,919
of their size from one place to another

00:28:17,450 --> 00:28:21,620
one thing you learn very quickly is that

00:28:18,919 --> 00:28:23,840
all spatial data is an approximation but

00:28:21,620 --> 00:28:25,669
you're trying to keep that approximation

00:28:23,840 --> 00:28:30,350
as close as possible and minimize the

00:28:25,669 --> 00:28:31,789
errors so within a UTM zone I think it's

00:28:30,350 --> 00:28:34,220
like something like point 1 of a

00:28:31,789 --> 00:28:36,380
millimeter for every meter is the

00:28:34,220 --> 00:28:37,850
maximum drift that you can get or sum or

00:28:36,380 --> 00:28:39,679
is it no it's more than that it's like

00:28:37,850 --> 00:28:45,409
one millimeter per kilometer it's a tiny

00:28:39,679 --> 00:28:47,600
tiny error in there so one of the other

00:28:45,409 --> 00:28:49,760
things if you think of the lat/longs and

00:28:47,600 --> 00:28:52,519
you remember how I said that as you go

00:28:49,760 --> 00:28:55,669
up in latitude the longitude values

00:28:52,519 --> 00:28:56,669
change the the amount of area you cover

00:28:55,669 --> 00:28:59,340
on the ground based

00:28:56,669 --> 00:29:03,720
the angle changes that affects the area

00:28:59,340 --> 00:29:05,759
an area on an angle based CRS is really

00:29:03,720 --> 00:29:07,350
weird because you can take the same

00:29:05,759 --> 00:29:09,690
field and move it to a different

00:29:07,350 --> 00:29:11,850
latitude and get a totally different

00:29:09,690 --> 00:29:13,859
number for the area right or you know at

00:29:11,850 --> 00:29:15,989
least the area on the ground so it's

00:29:13,859 --> 00:29:20,269
kind of weird to ask for an area like

00:29:15,989 --> 00:29:23,639
that and so what we can do instead is

00:29:20,269 --> 00:29:25,470
introduce some new abstract classes in

00:29:23,639 --> 00:29:27,119
there and we can say well this is a

00:29:25,470 --> 00:29:28,499
nearly dinner Martin again it's easy to

00:29:27,119 --> 00:29:31,710
do

00:29:28,499 --> 00:29:33,509
anybody who's wondering so we can say

00:29:31,710 --> 00:29:36,239
there's an angle CRS type and a meter

00:29:33,509 --> 00:29:38,970
CRS type and they are both CRS types and

00:29:36,239 --> 00:29:42,840
then when we define these things we

00:29:38,970 --> 00:29:45,299
would say 436 is an angle type three two

00:29:42,840 --> 00:29:48,450
six one zero is a meter type and if we

00:29:45,299 --> 00:29:51,480
do that we can say things like this area

00:29:48,450 --> 00:29:54,539
in square meters and we will only accept

00:29:51,480 --> 00:29:57,179
CRS is now that our meter based okay and

00:29:54,539 --> 00:29:59,039
it won't compile if you use something

00:29:57,179 --> 00:30:00,869
else it will tell you what it says down

00:29:59,039 --> 00:30:05,039
the bottom there could not find evidence

00:30:00,869 --> 00:30:07,639
that epsg four three two six is a meter

00:30:05,039 --> 00:30:10,649
based is effectively what that's saying

00:30:07,639 --> 00:30:12,179
so you can take it further you can

00:30:10,649 --> 00:30:14,789
introduce a lot of these coding nuances

00:30:12,179 --> 00:30:15,899
another thing you could do here although

00:30:14,789 --> 00:30:18,749
we resist it that's a whole other

00:30:15,899 --> 00:30:21,419
conversation but you could introduce

00:30:18,749 --> 00:30:25,159
squats units here right you can actually

00:30:21,419 --> 00:30:29,460
say this is the unit for this this thing

00:30:25,159 --> 00:30:30,899
okay so that's CRS is that's about as

00:30:29,460 --> 00:30:33,539
far as I'm going to go but it really

00:30:30,899 --> 00:30:35,009
does work this thing like I said I think

00:30:33,539 --> 00:30:36,659
during the beginning there was a bit of

00:30:35,009 --> 00:30:38,639
grumbling because there was all of these

00:30:36,659 --> 00:30:41,759
compile errors that people didn't used

00:30:38,639 --> 00:30:43,200
to see and after a while you know I

00:30:41,759 --> 00:30:44,850
would point out to people well this was

00:30:43,200 --> 00:30:47,249
a bug and you would have got the wrong

00:30:44,850 --> 00:30:49,200
data back and nobody complains about it

00:30:47,249 --> 00:30:52,649
anymore it's actually worked out really

00:30:49,200 --> 00:30:55,139
well people people seem to like this so

00:30:52,649 --> 00:30:57,899
let's switch tracks another place where

00:30:55,139 --> 00:30:59,700
we don't have enough type safety in GIS

00:30:57,899 --> 00:31:03,799
we deal with things called features a

00:30:59,700 --> 00:31:06,960
lot features are things like fields and

00:31:03,799 --> 00:31:09,119
counties and maybe a country boundary

00:31:06,960 --> 00:31:09,960
maybe it's a point of interest maybe

00:31:09,119 --> 00:31:12,929
it's the nearest

00:31:09,960 --> 00:31:15,720
mcDonald's point of interest on your GPS

00:31:12,929 --> 00:31:18,539
whatever that's a feature and it's a

00:31:15,720 --> 00:31:22,970
geometry with attributes of it and the

00:31:18,539 --> 00:31:26,010
attributes long story lotta history here

00:31:22,970 --> 00:31:27,779
for the most part the accepted types for

00:31:26,010 --> 00:31:31,230
those are whatever fits into a visual

00:31:27,779 --> 00:31:32,880
FoxPro or an old foxpro database that's

00:31:31,230 --> 00:31:34,320
just because that's what shape files

00:31:32,880 --> 00:31:36,360
were based on in the first place and

00:31:34,320 --> 00:31:39,510
then that grew into pretty much

00:31:36,360 --> 00:31:43,500
everything else but within the API

00:31:39,510 --> 00:31:45,330
within the Java geo tools API then those

00:31:43,500 --> 00:31:47,159
attributes end up being a map of string

00:31:45,330 --> 00:31:49,200
to any and that's where you play the sad

00:31:47,159 --> 00:31:50,940
trombone because that's where things go

00:31:49,200 --> 00:31:53,250
horribly wrong when you see a type

00:31:50,940 --> 00:31:55,200
signature like that and it leads to all

00:31:53,250 --> 00:31:57,960
sorts of abuses we've just hit several

00:31:55,200 --> 00:31:59,610
in the past few weeks where people get

00:31:57,960 --> 00:32:02,580
the attributes and they're like save it

00:31:59,610 --> 00:32:03,809
out to a shapefile and you know it hits

00:32:02,580 --> 00:32:05,520
and it's a map of strength to any

00:32:03,809 --> 00:32:06,870
nobody's broken any rules up until that

00:32:05,520 --> 00:32:10,730
point and it's like I don't know how to

00:32:06,870 --> 00:32:14,700
save a you know 365 day weather array

00:32:10,730 --> 00:32:16,500
into a shapefile so this leads to all

00:32:14,700 --> 00:32:19,169
sorts of abuses and we can do a lot

00:32:16,500 --> 00:32:21,840
better we can of course make it

00:32:19,169 --> 00:32:23,490
completely type safe and we could do a

00:32:21,840 --> 00:32:25,529
lot of things with type classes and

00:32:23,490 --> 00:32:28,289
stuff like that but it's nice to have

00:32:25,529 --> 00:32:30,299
this as I'm going through processing the

00:32:28,289 --> 00:32:32,340
ability to just kind of lop attributes

00:32:30,299 --> 00:32:35,279
in there still and retain the type

00:32:32,340 --> 00:32:36,690
information and for this many many years

00:32:35,279 --> 00:32:39,720
ago a good friend of mine called Chris

00:32:36,690 --> 00:32:41,010
void showed me some actually this is the

00:32:39,720 --> 00:32:45,059
future definition let's go through this

00:32:41,010 --> 00:32:49,200
first very quickly it has a CRS

00:32:45,059 --> 00:32:51,960
everything has a CRS the attributes at

00:32:49,200 --> 00:32:54,809
the end there that the tea is covariant

00:32:51,960 --> 00:32:57,029
it's a covariant type parameter and we

00:32:54,809 --> 00:32:59,940
have a method in there that allows us to

00:32:57,029 --> 00:33:04,080
take a tee a function from C to you and

00:32:59,940 --> 00:33:05,640
it will give back a new feature with the

00:33:04,080 --> 00:33:08,880
transformed attributes but everything

00:33:05,640 --> 00:33:10,440
else the same okay that's just a little

00:33:08,880 --> 00:33:14,370
bit of a little bit of mechanism they're

00:33:10,440 --> 00:33:16,020
so simple covariant behavior we can look

00:33:14,370 --> 00:33:18,360
at this week because list is also

00:33:16,020 --> 00:33:20,639
covariant we could make a function that

00:33:18,360 --> 00:33:23,460
takes a feature that requires a list of

00:33:20,639 --> 00:33:26,640
any and now we can call that with

00:33:23,460 --> 00:33:29,010
any of the any feature that has a list

00:33:26,640 --> 00:33:30,420
of some kind as its attributes and it'll

00:33:29,010 --> 00:33:32,610
work so in this case it's just returning

00:33:30,420 --> 00:33:34,470
size so it works for a list of him it

00:33:32,610 --> 00:33:36,030
works for a list of string it doesn't

00:33:34,470 --> 00:33:38,300
work if we pass it an int that's a

00:33:36,030 --> 00:33:43,290
compile error because that's not a

00:33:38,300 --> 00:33:44,700
subtype of list there this is what I was

00:33:43,290 --> 00:33:45,960
telling telling you my friend Chris

00:33:44,700 --> 00:33:47,850
showed me many years ago and I've come

00:33:45,960 --> 00:33:49,440
back to them just occasionally and it's

00:33:47,850 --> 00:33:51,150
a very few lines of code and some of

00:33:49,440 --> 00:33:53,670
them aren't even necessary for it here

00:33:51,150 --> 00:33:56,790
their convenience is this is a type

00:33:53,670 --> 00:33:59,490
index map and you can sort of think of

00:33:56,790 --> 00:34:03,480
it as approximately what an H Lass's to

00:33:59,490 --> 00:34:05,850
our list this is to a map okay the the

00:34:03,480 --> 00:34:09,600
difference here is that the keys in the

00:34:05,850 --> 00:34:12,900
map are types and their type tagged type

00:34:09,600 --> 00:34:14,640
tags are not a part of this although I'm

00:34:12,900 --> 00:34:15,840
happy to go into them another time when

00:34:14,640 --> 00:34:17,760
there's more time but they are

00:34:15,840 --> 00:34:20,640
effectively a conversation between the

00:34:17,760 --> 00:34:23,340
compiler and the runtime it's a bundle

00:34:20,640 --> 00:34:24,660
of stuff that the compiler knows about

00:34:23,340 --> 00:34:26,850
the type that you're talking about

00:34:24,660 --> 00:34:30,270
shoved into the runtime so that you can

00:34:26,850 --> 00:34:34,380
examine it okay and we can use this as

00:34:30,270 --> 00:34:36,690
our as the key to our map and we can do

00:34:34,380 --> 00:34:39,000
some behind the scenes some casting now

00:34:36,690 --> 00:34:41,520
everybody's like all casting let me tell

00:34:39,000 --> 00:34:43,590
you the scalar type system doesn't exist

00:34:41,520 --> 00:34:46,980
in the real world it only exists in the

00:34:43,590 --> 00:34:49,290
Scala compiler anytime you get a type

00:34:46,980 --> 00:34:50,580
from no type there has to be a cast

00:34:49,290 --> 00:34:52,740
somewhere it doesn't matter how well

00:34:50,580 --> 00:34:56,580
it's it's hidden something somewhere is

00:34:52,740 --> 00:34:58,020
doing a typecast so we do this here okay

00:34:56,580 --> 00:35:02,250
and what we do is there's a bunch of

00:34:58,020 --> 00:35:03,810
type safety here but I'll show you how

00:35:02,250 --> 00:35:05,550
it works in a minute not make more sense

00:35:03,810 --> 00:35:07,440
the main thing that I want you to see is

00:35:05,550 --> 00:35:09,690
that when you create something you pass

00:35:07,440 --> 00:35:12,900
in a value with some type it was the

00:35:09,690 --> 00:35:16,020
summer tribute type it implicitly passes

00:35:12,900 --> 00:35:22,460
in the type tag it uses that type tag to

00:35:16,020 --> 00:35:25,140
store the to store the type in there and

00:35:22,460 --> 00:35:28,200
you what you can pull it out by that

00:35:25,140 --> 00:35:31,080
type again so you can do a get square

00:35:28,200 --> 00:35:32,970
brackets E and what's I think more

00:35:31,080 --> 00:35:35,670
interesting is at least for the actually

00:35:32,970 --> 00:35:37,140
not the get but the apply is that we use

00:35:35,670 --> 00:35:40,140
lower bounds here

00:35:37,140 --> 00:35:43,050
II the type coming in must be a super

00:35:40,140 --> 00:35:44,670
type of tea okay we use that to make

00:35:43,050 --> 00:35:46,290
sure that it won't compile if you try

00:35:44,670 --> 00:35:46,680
and ask for a type that isn't in the tea

00:35:46,290 --> 00:35:48,300
map

00:35:46,680 --> 00:35:50,880
this will makes more sense when I show

00:35:48,300 --> 00:35:54,180
you how it runs so here's an example of

00:35:50,880 --> 00:35:57,720
it and hopefully this will now make

00:35:54,180 --> 00:36:00,150
sense particularly look at the middle

00:35:57,720 --> 00:36:03,300
one we start with the tea map that is

00:36:00,150 --> 00:36:05,730
just a tea map of int okay and then we

00:36:03,300 --> 00:36:08,820
can add a string to it we just do T map

00:36:05,730 --> 00:36:13,590
one plus hello the type at that point is

00:36:08,820 --> 00:36:15,270
now intersected and actually one of the

00:36:13,590 --> 00:36:18,270
things I'm going to do when I have time

00:36:15,270 --> 00:36:19,290
and that'll be very soon now is take

00:36:18,270 --> 00:36:21,120
this and put in dotty

00:36:19,290 --> 00:36:23,460
and see how things change and how things

00:36:21,120 --> 00:36:25,980
work I'll talk about that if there's

00:36:23,460 --> 00:36:28,230
time in a minute but when we add the

00:36:25,980 --> 00:36:30,000
string to it the T map that the type

00:36:28,230 --> 00:36:32,250
that we get back is now a new T map and

00:36:30,000 --> 00:36:34,950
the type is now an int with a string

00:36:32,250 --> 00:36:37,080
okay if we had a list of things to it a

00:36:34,950 --> 00:36:38,850
list of int to it we now end up with it

00:36:37,080 --> 00:36:41,730
of a T map of

00:36:38,850 --> 00:36:45,150
int with string with list of int okay

00:36:41,730 --> 00:36:51,060
and we can see down the bottom here

00:36:45,150 --> 00:36:51,510
actually there's a method missing here T

00:36:51,060 --> 00:36:53,130
map

00:36:51,510 --> 00:36:55,200
oh no that's okay that's just showing

00:36:53,130 --> 00:36:58,140
you access okay here's what we care

00:36:55,200 --> 00:37:00,950
about let's say we have some calc method

00:36:58,140 --> 00:37:03,780
and it needs the list of int and the int

00:37:00,950 --> 00:37:06,390
attributes from that T map but doesn't

00:37:03,780 --> 00:37:09,480
care what else is in there okay because

00:37:06,390 --> 00:37:12,570
it's covariant something with a string

00:37:09,480 --> 00:37:15,060
an int and a list of int is a subtype of

00:37:12,570 --> 00:37:16,740
that so we can pass it in and it will

00:37:15,060 --> 00:37:19,650
use just the things it needs it will

00:37:16,740 --> 00:37:22,290
grab them so you can see here team out

00:37:19,650 --> 00:37:24,270
three which is their int with string

00:37:22,290 --> 00:37:26,970
with list of int that works when we try

00:37:24,270 --> 00:37:29,240
and call team call calc but passing T

00:37:26,970 --> 00:37:31,650
map to in which is an int with a string

00:37:29,240 --> 00:37:34,020
doesn't match the type signature in this

00:37:31,650 --> 00:37:36,570
and the compiler tells us that that's no

00:37:34,020 --> 00:37:37,700
good this can be extended of course I

00:37:36,570 --> 00:37:40,680
don't think it's much of a stretch to

00:37:37,700 --> 00:37:42,120
take it to serialization for example

00:37:40,680 --> 00:37:45,240
where we want to write something out to

00:37:42,120 --> 00:37:46,620
a shapefile we now have to show we still

00:37:45,240 --> 00:37:48,990
have all the type information we now

00:37:46,620 --> 00:37:52,260
need to show that we can turn whatever

00:37:48,990 --> 00:37:57,810
this thing is into a type signature into

00:37:52,260 --> 00:38:02,280
a shapefile attribute and so on here it

00:37:57,810 --> 00:38:04,020
is with attributes the feature now and

00:38:02,280 --> 00:38:05,550
this I think this is where it gets to be

00:38:04,020 --> 00:38:07,980
quite interesting there's a lot of type

00:38:05,550 --> 00:38:10,830
stuff going on in this one features we

00:38:07,980 --> 00:38:13,140
don't want to limit to just being T maps

00:38:10,830 --> 00:38:15,600
that would be silly we could put rich

00:38:13,140 --> 00:38:17,520
types we can and many times we do T maps

00:38:15,600 --> 00:38:19,290
are kind of a they're not to be overused

00:38:17,520 --> 00:38:20,730
they're convenient but a lot of the time

00:38:19,290 --> 00:38:22,380
if you can get away with a case class

00:38:20,730 --> 00:38:25,620
that represents all of your attributes

00:38:22,380 --> 00:38:27,510
do that that's a much stronger it's a

00:38:25,620 --> 00:38:29,730
much stronger more readable way of doing

00:38:27,510 --> 00:38:31,200
things but if we're just lopping things

00:38:29,730 --> 00:38:33,960
in there kind of throwing things in a

00:38:31,200 --> 00:38:38,190
bucket maybe we have something like this

00:38:33,960 --> 00:38:39,780
so the feature Neal take some type T and

00:38:38,190 --> 00:38:42,630
then you can see down here there's a

00:38:39,780 --> 00:38:48,240
private def add attribute inner and that

00:38:42,630 --> 00:38:52,020
says if the TM if the the TM here is and

00:38:48,240 --> 00:38:55,230
this is new type is a subtype of TM t as

00:38:52,020 --> 00:38:57,570
type map of the inner type of that thing

00:38:55,230 --> 00:39:06,540
whatever that is and I've got evidence

00:38:57,570 --> 00:39:09,780
that T is a subtype yes of the TM T is

00:39:06,540 --> 00:39:11,760
the subtype of that TM then we can call

00:39:09,780 --> 00:39:14,100
this operation and what this means this

00:39:11,760 --> 00:39:15,600
is pretty typical use of like equals

00:39:14,100 --> 00:39:18,510
colon equals or less than colon less

00:39:15,600 --> 00:39:20,610
then it means that this method can only

00:39:18,510 --> 00:39:23,550
be called when it's a T map in there

00:39:20,610 --> 00:39:26,010
basically and if it's not a T map it

00:39:23,550 --> 00:39:28,650
won't compile and then down the bottom

00:39:26,010 --> 00:39:30,900
you'll notice that's private and down

00:39:28,650 --> 00:39:33,210
the bottom I've got a rich class around

00:39:30,900 --> 00:39:37,650
it I'll talk about why in a second all

00:39:33,210 --> 00:39:40,500
right so in use in the stuff I do we

00:39:37,650 --> 00:39:42,630
have harvesters high tech harvesters

00:39:40,500 --> 00:39:44,820
that Rumble around fields and they count

00:39:42,630 --> 00:39:46,920
the when they're harvesting they count

00:39:44,820 --> 00:39:49,110
the amount of stuff coming in and how

00:39:46,920 --> 00:39:51,180
long it came in for so it's a flow rate

00:39:49,110 --> 00:39:52,830
and a duration if you multiply the flow

00:39:51,180 --> 00:39:55,620
rate by that the duration you get a

00:39:52,830 --> 00:39:57,240
yield for that particular period of time

00:39:55,620 --> 00:39:59,160
you get how much stuff came through the

00:39:57,240 --> 00:40:01,500
harvester in that particular period of

00:39:59,160 --> 00:40:02,200
time so if you take it flow in a

00:40:01,500 --> 00:40:03,670
duration

00:40:02,200 --> 00:40:05,560
you can get a yield out of it there's a

00:40:03,670 --> 00:40:07,720
function that does that it takes a team

00:40:05,560 --> 00:40:09,099
app of flow with duration and it doesn't

00:40:07,720 --> 00:40:11,290
matter what other actory routes are in

00:40:09,099 --> 00:40:14,079
there we just need those two types in

00:40:11,290 --> 00:40:17,680
there we get back a yield and then down

00:40:14,079 --> 00:40:20,740
here in the code somewhere there it is

00:40:17,680 --> 00:40:24,820
we say actually no it's not that one

00:40:20,740 --> 00:40:28,690
it's the one down here we say feature

00:40:24,820 --> 00:40:30,700
with you with no right up there feature

00:40:28,690 --> 00:40:32,589
with flow and duration we can add the

00:40:30,700 --> 00:40:35,380
attribute and the attribute we're adding

00:40:32,589 --> 00:40:37,480
is the calculated yield okay that whole

00:40:35,380 --> 00:40:39,970
thing's typesafe you'll notice that

00:40:37,480 --> 00:40:43,540
after that the whole feature becomes now

00:40:39,970 --> 00:40:45,250
a team app with a field name with field

00:40:43,540 --> 00:40:47,020
name with flow with duration with the

00:40:45,250 --> 00:40:49,390
yield whereas before it was field name

00:40:47,020 --> 00:40:50,920
with flow with duration so we are

00:40:49,390 --> 00:40:55,079
accumulating these things in a tight

00:40:50,920 --> 00:40:57,250
safe way as we go through and everything

00:40:55,079 --> 00:40:59,440
everything compiles when it should and

00:40:57,250 --> 00:41:01,690
does not compile when it shouldn't if we

00:40:59,440 --> 00:41:05,320
give it field name with just yield we

00:41:01,690 --> 00:41:07,150
can't call the the calc on there okay

00:41:05,320 --> 00:41:09,089
this all making sense

00:41:07,150 --> 00:41:12,910
or have I lost everybody at this point

00:41:09,089 --> 00:41:14,170
hopefully this is neat all right why

00:41:12,910 --> 00:41:15,940
don't we have the implicit extension

00:41:14,170 --> 00:41:18,310
class I have three minutes left so we

00:41:15,940 --> 00:41:19,720
should get through this and there may be

00:41:18,310 --> 00:41:22,329
a better way to do this I stopped

00:41:19,720 --> 00:41:23,920
looking after I made this work and it

00:41:22,329 --> 00:41:25,119
occurs to me then I probably shouldn't

00:41:23,920 --> 00:41:26,589
have done that because I bet somebody

00:41:25,119 --> 00:41:28,869
else has a really neat way of doing this

00:41:26,589 --> 00:41:33,069
but this is my solution to this problem

00:41:28,869 --> 00:41:34,930
first of all because T is covariant you

00:41:33,069 --> 00:41:38,020
can't use equals colon equals there

00:41:34,930 --> 00:41:40,599
because both of the type parameters in

00:41:38,020 --> 00:41:42,940
equals colon equals are invariant so

00:41:40,599 --> 00:41:44,589
that breaks the contract okay the only

00:41:42,940 --> 00:41:47,829
one you can use is less than colon less

00:41:44,589 --> 00:41:50,170
than less than colon less than has some

00:41:47,829 --> 00:41:53,589
interaction with the scholar type

00:41:50,170 --> 00:41:56,470
inferencing that breaks it being able to

00:41:53,589 --> 00:41:59,680
inference properly here so when you do

00:41:56,470 --> 00:42:02,650
this if you do it using the add

00:41:59,680 --> 00:42:05,200
attribute directly in there you'll get

00:42:02,650 --> 00:42:07,119
this error cannot prove and it's not

00:42:05,200 --> 00:42:11,040
just an intelligent this is from the

00:42:07,119 --> 00:42:15,970
scholar compiler cannot prove that T map

00:42:11,040 --> 00:42:20,619
of from escalate whatever the field name

00:42:15,970 --> 00:42:25,660
is a subtype of team up with nothing

00:42:20,619 --> 00:42:27,460
right and is it super type isn't it's

00:42:25,660 --> 00:42:30,760
the it's up the hierarchy you get the

00:42:27,460 --> 00:42:34,450
idea anyway it it infers nothing and it

00:42:30,760 --> 00:42:36,849
can't fix that in time so by introducing

00:42:34,450 --> 00:42:38,920
oh and if you use equals equals come on

00:42:36,849 --> 00:42:40,540
equals as I said those are invariant

00:42:38,920 --> 00:42:44,109
here's the here's the signatures from

00:42:40,540 --> 00:42:46,630
the scarlet source like Oh from the

00:42:44,109 --> 00:42:49,000
Scala core libraries and you can see

00:42:46,630 --> 00:42:51,310
from and to are invariant there whereas

00:42:49,000 --> 00:42:54,480
in the case of the second one two is

00:42:51,310 --> 00:43:00,190
covariance so we can use T in that place

00:42:54,480 --> 00:43:04,450
alright so the rich feature if I go back

00:43:00,190 --> 00:43:08,440
to that what that does is right here it

00:43:04,450 --> 00:43:11,080
allows us to fix the type T so this

00:43:08,440 --> 00:43:13,090
thing's created and when we create it we

00:43:11,080 --> 00:43:16,119
fix the type so there's no longer any

00:43:13,090 --> 00:43:17,500
need to infer it and get this nothing

00:43:16,119 --> 00:43:20,589
that's at the bottom of the hierarchy

00:43:17,500 --> 00:43:22,089
anymore so at that point it freezes that

00:43:20,589 --> 00:43:23,980
type in place and then we can call the

00:43:22,089 --> 00:43:25,540
add attribute and we have the original

00:43:23,980 --> 00:43:28,660
type when we have the new attribute and

00:43:25,540 --> 00:43:31,480
we Union them together sorry we

00:43:28,660 --> 00:43:34,420
intersect them and that becomes the new

00:43:31,480 --> 00:43:37,660
type alright so the one last one I'm

00:43:34,420 --> 00:43:39,910
going to hit in the dying seconds is a

00:43:37,660 --> 00:43:42,550
couple of safety latches easy things to

00:43:39,910 --> 00:43:44,890
do but inspired by sip 18 which is the

00:43:42,550 --> 00:43:46,960
import language features we wanted to

00:43:44,890 --> 00:43:49,420
make it so that it's not impossible to

00:43:46,960 --> 00:43:50,800
resample but you have to really want to

00:43:49,420 --> 00:43:54,280
do it and you're not going to do it by

00:43:50,800 --> 00:43:56,440
accident for raster's or coverages as we

00:43:54,280 --> 00:43:58,900
call them so you just make an object

00:43:56,440 --> 00:44:01,930
called resample CRS and inside of that

00:43:58,900 --> 00:44:04,420
there's another implicit class that adds

00:44:01,930 --> 00:44:06,790
the resample methods that you need then

00:44:04,420 --> 00:44:10,599
in order to resample something you have

00:44:06,790 --> 00:44:15,010
to say import resample what did I call

00:44:10,599 --> 00:44:17,740
it resample CRS yeah resample CRS dot

00:44:15,010 --> 00:44:20,890
underscore and when you do that you're

00:44:17,740 --> 00:44:23,589
then able to say dot resample CRS to

00:44:20,890 --> 00:44:25,570
some new CRS or provide it with

00:44:23,589 --> 00:44:27,610
resolution and an interpolation that you

00:44:25,570 --> 00:44:29,260
want to use to resample it

00:44:27,610 --> 00:44:31,060
I think at the beginning I mentioned web

00:44:29,260 --> 00:44:33,010
Mercator this is the definition of web

00:44:31,060 --> 00:44:35,170
Mercator it's under something called

00:44:33,010 --> 00:44:37,810
display only to give the hint that you

00:44:35,170 --> 00:44:39,190
have to import display only if you want

00:44:37,810 --> 00:44:40,900
to use web Mercator and that's a

00:44:39,190 --> 00:44:44,140
reminder to people that they shouldn't

00:44:40,900 --> 00:44:48,160
ever be used as part of the processing

00:44:44,140 --> 00:44:50,620
pipeline all right so the puff pieces

00:44:48,160 --> 00:44:52,150
the the mandatory bits if you like this

00:44:50,620 --> 00:44:54,550
idea or other stuff or you like

00:44:52,150 --> 00:44:57,100
programming Escala we're hiring

00:44:54,550 --> 00:44:58,360
there's the career the the one you want

00:44:57,100 --> 00:45:01,570
is really the one at the bottom SIBO

00:44:58,360 --> 00:45:03,580
technologies comm slash careers and if

00:45:01,570 --> 00:45:05,860
this whetted your appetite and you want

00:45:03,580 --> 00:45:08,710
to brush up on your types we do training

00:45:05,860 --> 00:45:11,170
escalate and the training links you can

00:45:08,710 --> 00:45:14,410
find up here this online and we can do

00:45:11,170 --> 00:45:16,750
in person by arrangement so that's it

00:45:14,410 --> 00:45:18,070
any questions I can't believe I time

00:45:16,750 --> 00:45:20,680
that quite as well as I did it's

00:45:18,070 --> 00:45:26,580
literally like 46 minutes so I over end

00:45:20,680 --> 00:45:26,580
just by one but thanks anyway

00:45:30,540 --> 00:45:34,540
[Music]

00:45:31,920 --> 00:45:37,510
this is excellent work

00:45:34,540 --> 00:45:40,660
are you planning to open source this yes

00:45:37,510 --> 00:45:42,280
oh good thank you for reminding me it

00:45:40,660 --> 00:45:42,970
will be open sourced I hope by this

00:45:42,280 --> 00:45:45,670
weekend

00:45:42,970 --> 00:45:48,820
it is based on work that I've done at

00:45:45,670 --> 00:45:51,100
Sabo so being a kind of conscientious

00:45:48,820 --> 00:45:52,060
person I did run it through legal and

00:45:51,100 --> 00:45:54,640
the other bigwigs

00:45:52,060 --> 00:45:56,410
and I'm certain though I mean the codes

00:45:54,640 --> 00:45:59,770
up on the slides right what are they

00:45:56,410 --> 00:46:01,030
gonna do now but there that's part one

00:45:59,770 --> 00:46:02,560
of the reason part two of the reason is

00:46:01,030 --> 00:46:04,300
there's some changes than I left on my

00:46:02,560 --> 00:46:05,470
laptop at home and forgot to check in

00:46:04,300 --> 00:46:07,480
before I left so I'm going to check

00:46:05,470 --> 00:46:08,890
those in by the weekend should be up

00:46:07,480 --> 00:46:11,590
there open sourced what will it be

00:46:08,890 --> 00:46:14,980
called well how do we find it it will be

00:46:11,590 --> 00:46:16,660
under Eska how do I get that out there

00:46:14,980 --> 00:46:19,780
to people it will be under Escalades

00:46:16,660 --> 00:46:23,860
Ofcom the organization on github and

00:46:19,780 --> 00:46:25,900
it's called scala types but i don't know

00:46:23,860 --> 00:46:27,610
how to like message that to people

00:46:25,900 --> 00:46:33,400
afterwards somebody here must know that

00:46:27,610 --> 00:46:35,020
we'll figure out a way sorry Scarlett

00:46:33,400 --> 00:46:36,340
announced list okay I'll put it on the

00:46:35,020 --> 00:46:37,300
scanner announce list that will work

00:46:36,340 --> 00:46:39,520
okay

00:46:37,300 --> 00:46:41,290
can you tweet out the slides - Oh yep

00:46:39,520 --> 00:46:43,390
absolutely I think the slides come as

00:46:41,290 --> 00:46:45,790
part of the package with Scala days

00:46:43,390 --> 00:46:48,630
anyway but yes I can I can

00:46:45,790 --> 00:46:52,810
PDF them and put them out there for sure

00:46:48,630 --> 00:46:55,300
okay great um it is literally just what

00:46:52,810 --> 00:46:58,330
you see there's not an API here right it

00:46:55,300 --> 00:47:00,790
may grow into one most of this is based

00:46:58,330 --> 00:47:03,070
on kind of cleaned up versions of

00:47:00,790 --> 00:47:05,440
internal code at the moment so it's just

00:47:03,070 --> 00:47:07,510
enough to show the types and stuff like

00:47:05,440 --> 00:47:12,270
that but I hope it will grow into a type

00:47:07,510 --> 00:47:12,270
safe open-source geo API in time

00:47:12,690 --> 00:47:21,340
anything else yeah I'm planning on

00:47:17,830 --> 00:47:27,370
reviving these collar wags podcast the

00:47:21,340 --> 00:47:29,170
Scala it's kind of worked oh yeah we get

00:47:27,370 --> 00:47:33,280
asked that question a lot I'm not saying

00:47:29,170 --> 00:47:35,320
no but Josh was really the anchorman he

00:47:33,280 --> 00:47:36,970
did he was the driving force and he's

00:47:35,320 --> 00:47:39,070
been super busy and he's had lots of

00:47:36,970 --> 00:47:42,670
other really good reasons why he's not

00:47:39,070 --> 00:47:44,920
doing that I think the next in line for

00:47:42,670 --> 00:47:46,270
the anchorperson would be me and I've

00:47:44,920 --> 00:47:48,580
been kind of busy too so I've been

00:47:46,270 --> 00:47:50,170
unwilling to take on the responsibility

00:47:48,580 --> 00:47:52,390
but we're not saying no I'd like to do

00:47:50,170 --> 00:47:57,190
it again I miss talking with my scalawag

00:47:52,390 --> 00:48:01,720
buddies so maybe but no promises all

00:47:57,190 --> 00:48:03,610
right one more yeah so a lot of this

00:48:01,720 --> 00:48:05,650
work for using type systems to enforce

00:48:03,610 --> 00:48:06,610
business logic is really awesome but

00:48:05,650 --> 00:48:08,170
from the soil scientists perspective

00:48:06,610 --> 00:48:10,330
some of the type signatures can be

00:48:08,170 --> 00:48:12,820
pretty verbose how well does the Scala

00:48:10,330 --> 00:48:13,830
type inference or work for you know what

00:48:12,820 --> 00:48:16,840
you've done here

00:48:13,830 --> 00:48:18,460
skl skl the type oh yeah I put all of

00:48:16,840 --> 00:48:21,430
the explicit types on there to show you

00:48:18,460 --> 00:48:23,740
guys what was going on almost none of

00:48:21,430 --> 00:48:25,410
them are aware were required it will it

00:48:23,740 --> 00:48:28,390
will infer you don't have to put

00:48:25,410 --> 00:48:29,590
coordinate 2d epsg for three to six or

00:48:28,390 --> 00:48:32,770
anything like that it will all be

00:48:29,590 --> 00:48:34,810
inferred it's very rare to get something

00:48:32,770 --> 00:48:36,790
in this that doesn't get inferred like

00:48:34,810 --> 00:48:38,290
that like I said I mainly did it to demo

00:48:36,790 --> 00:48:40,000
it on the slides and make it explicit

00:48:38,290 --> 00:48:43,630
for you guys

00:48:40,000 --> 00:48:44,920
and as far as the verbosity goes people

00:48:43,630 --> 00:48:46,540
have asked this they're like why do I

00:48:44,920 --> 00:48:50,080
have to put one of these CRS is on

00:48:46,540 --> 00:48:53,410
everything and my my answer to that is

00:48:50,080 --> 00:48:57,040
you would have a CRS parameter there if

00:48:53,410 --> 00:48:58,630
you didn't have the type right you it's

00:48:57,040 --> 00:49:00,550
it's one of our golden rules that

00:48:58,630 --> 00:49:02,020
nothing enters this system with our CRS

00:49:00,550 --> 00:49:07,030
attached so you're gonna have to have

00:49:02,020 --> 00:49:09,490
the the parameter in there at least by

00:49:07,030 --> 00:49:11,110
making it a type yeah you pay a cost

00:49:09,490 --> 00:49:12,610
when you're defining a method that you

00:49:11,110 --> 00:49:14,950
wouldn't otherwise you could kind of

00:49:12,610 --> 00:49:17,500
gloss over it there but in anything that

00:49:14,950 --> 00:49:19,420
you define it's really no extra cost

00:49:17,500 --> 00:49:22,300
you're just moving something that was a

00:49:19,420 --> 00:49:26,830
runtime parameter into a type parameter

00:49:22,300 --> 00:49:28,900
and it's now type safe and you know

00:49:26,830 --> 00:49:31,240
compiler checked but not that much more

00:49:28,900 --> 00:49:34,450
typing so it makes sense thank you

00:49:31,240 --> 00:49:37,950
sure all right well I think that's it

00:49:34,450 --> 00:49:37,950

YouTube URL: https://www.youtube.com/watch?v=B7SajlbCS1s


