Title: Ramnivas Laddad   Succeeding with Full Stack Scala
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
Captions: 
	00:00:04,950 --> 00:00:11,110
I'm Romney was Romney misled art and I'm

00:00:08,980 --> 00:00:14,559
going to talk about how to succeed with

00:00:11,110 --> 00:00:15,850
full-stack Scala so last three three and

00:00:14,559 --> 00:00:19,539
a half years we have been working on a

00:00:15,850 --> 00:00:21,010
product that is targeted for learners of

00:00:19,539 --> 00:00:24,310
Indian classical music it's a very niche

00:00:21,010 --> 00:00:27,010
market but I'm a student and I want I

00:00:24,310 --> 00:00:28,800
face certain set of problems that I

00:00:27,010 --> 00:00:33,070
think modern technology could help to

00:00:28,800 --> 00:00:34,210
make me learn more effectively so I

00:00:33,070 --> 00:00:35,800
actually give two years back a

00:00:34,210 --> 00:00:37,479
presentation when we had just started

00:00:35,800 --> 00:00:40,510
out saying why did we choose colleges

00:00:37,479 --> 00:00:41,859
and how are we going about doing it this

00:00:40,510 --> 00:00:44,800
is more about like where are we right

00:00:41,859 --> 00:00:47,649
now what are the problems we found and

00:00:44,800 --> 00:00:50,219
what are the opportunities we found and

00:00:47,649 --> 00:00:54,010
how did we use them to get where we are

00:00:50,219 --> 00:00:55,539
so one of the interesting thing is you

00:00:54,010 --> 00:00:57,429
know a typical hello world application

00:00:55,539 --> 00:00:59,350
in any language and any technology will

00:00:57,429 --> 00:01:01,359
look basically the same you will be you

00:00:59,350 --> 00:01:02,799
will be fine with any of this any of the

00:01:01,359 --> 00:01:04,900
stock that you choose but when you use a

00:01:02,799 --> 00:01:07,000
complex application the things things

00:01:04,900 --> 00:01:08,440
become really interesting is in if you

00:01:07,000 --> 00:01:10,240
chose the right technology you start to

00:01:08,440 --> 00:01:13,450
get benefit out of it if you did not

00:01:10,240 --> 00:01:14,680
then you start to suffer so this is we

00:01:13,450 --> 00:01:17,920
are going to find out what what what it

00:01:14,680 --> 00:01:20,850
what happen with us so product that we

00:01:17,920 --> 00:01:22,750
have is called learn raga so raga is a

00:01:20,850 --> 00:01:26,380
fundamental concept in Indian classical

00:01:22,750 --> 00:01:29,130
music and so if you want to learn raga

00:01:26,380 --> 00:01:31,660
then well you come to learn rather calm

00:01:29,130 --> 00:01:33,430
I'll give you a quick demo just to give

00:01:31,660 --> 00:01:36,340
you an idea of what kind of application

00:01:33,430 --> 00:01:39,190
we are talking about and that way you'll

00:01:36,340 --> 00:01:41,440
have the context of how to go about

00:01:39,190 --> 00:01:45,250
doing this app so if you go to learn

00:01:41,440 --> 00:01:47,020
vigor calm we basically offer typical as

00:01:45,250 --> 00:01:49,330
you would expect introduction to the

00:01:47,020 --> 00:01:52,230
application and what does this do about

00:01:49,330 --> 00:01:52,230
it so if I log in

00:01:54,690 --> 00:01:58,920
I can go to this this different so we

00:01:57,960 --> 00:02:00,650
are we offer something called

00:01:58,920 --> 00:02:02,880
composition view so compositions is a

00:02:00,650 --> 00:02:04,440
fundamental concept again in in

00:02:02,880 --> 00:02:07,590
classical music very much like western

00:02:04,440 --> 00:02:08,840
music typically when you when there's a

00:02:07,590 --> 00:02:11,760
presentation in of Indian classical

00:02:08,840 --> 00:02:13,170
music it's based on a composition and

00:02:11,760 --> 00:02:14,640
compositions are usually four or five

00:02:13,170 --> 00:02:18,390
lines of elaboration so four or five

00:02:14,640 --> 00:02:20,490
cycles of a beat cycle but then there is

00:02:18,390 --> 00:02:21,990
a elaboration around it so typically the

00:02:20,490 --> 00:02:26,130
present in the presentation goes about

00:02:21,990 --> 00:02:29,460
half an hour or so so when you want to

00:02:26,130 --> 00:02:30,750
create an application position we offer

00:02:29,460 --> 00:02:33,570
a compression view which looks like a

00:02:30,750 --> 00:02:35,460
spreadsheet but it's very specialized in

00:02:33,570 --> 00:02:37,410
the sense you can type in the particular

00:02:35,460 --> 00:02:40,200
nodes that you want so if I want to add

00:02:37,410 --> 00:02:46,200
a note here then I get a piano like

00:02:40,200 --> 00:02:50,750
interface and I can type in notes that I

00:02:46,200 --> 00:02:53,520
want and that's how I create composition

00:02:50,750 --> 00:02:55,740
so you will see some of the notes are

00:02:53,520 --> 00:02:57,750
grayed out because in each of firaga

00:02:55,740 --> 00:02:59,880
raga is a structure which restricts

00:02:57,750 --> 00:03:02,040
certain use of certain notes in certain

00:02:59,880 --> 00:03:03,840
manner so note that are not allowed in

00:03:02,040 --> 00:03:09,750
this particular rack or pooja Kalyan are

00:03:03,840 --> 00:03:11,400
not enabled I will keep it this way

00:03:09,750 --> 00:03:13,620
because I don't want to play it so now

00:03:11,400 --> 00:03:15,770
if you create a composition you can play

00:03:13,620 --> 00:03:15,770
it

00:03:16,760 --> 00:03:28,020
[Music]

00:03:31,630 --> 00:03:35,540
all right I will stop this because I

00:03:33,950 --> 00:03:37,250
might start to enjoy more and just keep

00:03:35,540 --> 00:03:39,260
playing but that's that's the

00:03:37,250 --> 00:03:40,370
fundamental about composition then based

00:03:39,260 --> 00:03:42,860
on this composition there are other

00:03:40,370 --> 00:03:44,890
views we offer one is practicing so if

00:03:42,860 --> 00:03:46,970
you want to develop your chops of

00:03:44,890 --> 00:03:48,590
developing pitch accuracy or playing

00:03:46,970 --> 00:03:50,750
certain patterns then these are the

00:03:48,590 --> 00:03:52,130
patterns those are familiar with Indian

00:03:50,750 --> 00:03:55,160
classical music will recognize it very

00:03:52,130 --> 00:03:58,450
easily it's a straightforward notes that

00:03:55,160 --> 00:03:58,450
bow in ascending and descending manner

00:04:00,560 --> 00:04:03,420
[Music]

00:04:01,710 --> 00:04:05,800
[Applause]

00:04:03,420 --> 00:04:08,360
[Music]

00:04:05,800 --> 00:04:10,550
and the idea here is you play this

00:04:08,360 --> 00:04:12,650
pattern and along with you sing it so

00:04:10,550 --> 00:04:14,150
and then that way you remember the

00:04:12,650 --> 00:04:17,150
patterns and there a pattern complexity

00:04:14,150 --> 00:04:18,530
goes as much as you want so you can play

00:04:17,150 --> 00:04:22,310
more complex pattern and so in this case

00:04:18,530 --> 00:04:24,169
it's one two pattern and so on and on we

00:04:22,310 --> 00:04:25,820
also have visualization so if you want

00:04:24,169 --> 00:04:27,890
to see what pattern how the notes are

00:04:25,820 --> 00:04:29,090
progressing as you are going along that

00:04:27,890 --> 00:04:32,630
you can see it will come to this view

00:04:29,090 --> 00:04:33,890
bit later so moving back to the

00:04:32,630 --> 00:04:36,770
presentation

00:04:33,890 --> 00:04:38,840
so which was collages partly because I

00:04:36,770 --> 00:04:40,729
know Scala I've been doing Scala forum

00:04:38,840 --> 00:04:45,290
for very long time this is my eighth

00:04:40,729 --> 00:04:46,910
Scala yes kala this conference and so

00:04:45,290 --> 00:04:48,740
obviously when the first time I wanted

00:04:46,910 --> 00:04:50,180
to say okay I want to do front end and I

00:04:48,740 --> 00:04:53,900
already have had experience in

00:04:50,180 --> 00:04:55,310
JavaScript and it wasn't great and back

00:04:53,900 --> 00:04:56,900
then JavaScript was even more primitive

00:04:55,310 --> 00:04:58,760
now with es6 I think things are much

00:04:56,900 --> 00:05:00,620
better but back then it was a plain

00:04:58,760 --> 00:05:03,740
JavaScript I mean things were really

00:05:00,620 --> 00:05:06,500
really complicated so I wanted to choose

00:05:03,740 --> 00:05:08,660
something that is I'm familiar with for

00:05:06,500 --> 00:05:12,380
also certain things such as statically

00:05:08,660 --> 00:05:14,780
typed nature so it offers car obviously

00:05:12,380 --> 00:05:16,669
as you all know Scala for statically

00:05:14,780 --> 00:05:18,680
typed combined with functional

00:05:16,669 --> 00:05:21,140
programming and that's that that

00:05:18,680 --> 00:05:22,729
combination is very very powerful it is

00:05:21,140 --> 00:05:25,130
a fairly mature system around Scala

00:05:22,729 --> 00:05:26,990
jeaious so most of the libraries that

00:05:25,130 --> 00:05:29,120
can work with colleges work with

00:05:26,990 --> 00:05:30,560
colleges so if you want a tags library

00:05:29,120 --> 00:05:32,540
to create a let's say template there's a

00:05:30,560 --> 00:05:34,460
Scala tags if you want a state

00:05:32,540 --> 00:05:36,420
management in a

00:05:34,460 --> 00:05:38,010
modern-style then there is a dire

00:05:36,420 --> 00:05:39,720
library and there are a bunch of

00:05:38,010 --> 00:05:42,840
libraries all the scholar artists work

00:05:39,720 --> 00:05:45,570
with scholar J's and so on it also

00:05:42,840 --> 00:05:47,360
operates really well with JavaScript so

00:05:45,570 --> 00:05:50,010
if you want to use JavaScript library

00:05:47,360 --> 00:05:51,720
from Scala that's extremely easy to do

00:05:50,010 --> 00:05:55,410
and in fact that's one of the key

00:05:51,720 --> 00:05:57,900
feature of colleges also its support

00:05:55,410 --> 00:06:00,150
supports isomorphism isomorphism in this

00:05:57,900 --> 00:06:02,550
case it means you can run the same code

00:06:00,150 --> 00:06:06,180
on JVM and Jaso you can compile the same

00:06:02,550 --> 00:06:08,070
code which our an JVM run it there and

00:06:06,180 --> 00:06:10,620
then later on if you want it do it on

00:06:08,070 --> 00:06:13,290
JavaScript as well and we exploit this

00:06:10,620 --> 00:06:15,840
isomorphism to the fullest extent

00:06:13,290 --> 00:06:17,460
in fact without this it would be really

00:06:15,840 --> 00:06:22,290
difficult for us to develop this

00:06:17,460 --> 00:06:23,700
application then we use react react is a

00:06:22,290 --> 00:06:25,500
framework written in JavaScript

00:06:23,700 --> 00:06:28,140
developed by phrase Facebook and it's

00:06:25,500 --> 00:06:29,910
right now pretty much the most popular

00:06:28,140 --> 00:06:31,620
framework out there as far as developing

00:06:29,910 --> 00:06:35,340
single single page applications is

00:06:31,620 --> 00:06:39,330
concerned it's very mature very widely

00:06:35,340 --> 00:06:40,800
used it uses promotes imitability so

00:06:39,330 --> 00:06:44,430
earlier if you look at angularjs

00:06:40,800 --> 00:06:46,050
framework at least angularjs 1.0 it's

00:06:44,430 --> 00:06:47,450
really everything is mutable effectively

00:06:46,050 --> 00:06:49,920
because you are essentially changing

00:06:47,450 --> 00:06:52,260
model and that reflects into Dom and

00:06:49,920 --> 00:06:54,360
vice versa since there is a very strong

00:06:52,260 --> 00:06:57,180
actually emphasis on meat ability

00:06:54,360 --> 00:06:59,540
it also supports react supports multiple

00:06:57,180 --> 00:07:03,330
platform web is what we use right now

00:06:59,540 --> 00:07:06,090
but we are we will have to at some point

00:07:03,330 --> 00:07:09,480
go to native application because people

00:07:06,090 --> 00:07:11,370
want native application on phone we are

00:07:09,480 --> 00:07:13,710
it supports it I don't see how we will

00:07:11,370 --> 00:07:16,350
use it at least not in any time anytime

00:07:13,710 --> 00:07:19,380
soon how many of you are familiar with

00:07:16,350 --> 00:07:21,810
react what a few so I can go through

00:07:19,380 --> 00:07:23,610
this next slide a little bit faster so

00:07:21,810 --> 00:07:25,770
react a fundamentally is a

00:07:23,610 --> 00:07:28,140
transformation between state and view so

00:07:25,770 --> 00:07:30,180
if you have a state then you have a

00:07:28,140 --> 00:07:33,360
function that goes from your state to

00:07:30,180 --> 00:07:35,640
view when you apply a stimuli such as

00:07:33,360 --> 00:07:39,270
user interaction or Network event or

00:07:35,640 --> 00:07:42,390
time are going off then you modify the

00:07:39,270 --> 00:07:45,490
state so you go from states s0 to s1 and

00:07:42,390 --> 00:07:48,069
then you reapply the same function

00:07:45,490 --> 00:07:49,599
that makes you give a new view now this

00:07:48,069 --> 00:07:52,479
is actually nothing new in fact this is

00:07:49,599 --> 00:07:56,620
how PHP applications work on JSP and all

00:07:52,479 --> 00:07:58,120
the earlier versions of server-side

00:07:56,620 --> 00:07:59,740
render applications work because

00:07:58,120 --> 00:08:01,210
essentially what happens right you you

00:07:59,740 --> 00:08:02,949
go to a particular form you submit

00:08:01,210 --> 00:08:04,630
submit the form and then you get a new

00:08:02,949 --> 00:08:06,520
state and you don't really think that I

00:08:04,630 --> 00:08:08,889
was on a form and then I'm now on a

00:08:06,520 --> 00:08:10,900
different different screen that you get

00:08:08,889 --> 00:08:13,780
back a page from the back end and you

00:08:10,900 --> 00:08:16,810
render the whole page again so obviously

00:08:13,780 --> 00:08:18,729
if we do that style then the performance

00:08:16,810 --> 00:08:20,650
is going to be very very bad like if I

00:08:18,729 --> 00:08:22,840
for every keystroke if I were to read

00:08:20,650 --> 00:08:24,130
render the whole page it's not going to

00:08:22,840 --> 00:08:28,030
be a pleasant experience

00:08:24,130 --> 00:08:30,069
so what react does is react compute the

00:08:28,030 --> 00:08:33,550
difference between two subsequent views

00:08:30,069 --> 00:08:36,760
and then it basically based on that view

00:08:33,550 --> 00:08:46,510
it calculates da mutation needed to get

00:08:36,760 --> 00:08:49,420
from v-0 to v1 taking a bit more this

00:08:46,510 --> 00:08:52,360
one is more conceptual view in react you

00:08:49,420 --> 00:08:53,980
have an a component component receives

00:08:52,360 --> 00:08:55,390
properties so if it is a top-level

00:08:53,980 --> 00:08:58,570
application the property could be just

00:08:55,390 --> 00:09:01,000
the URL that you typed in and component

00:08:58,570 --> 00:09:02,440
can keep its own State so for example

00:09:01,000 --> 00:09:07,779
where is the cursor located or which

00:09:02,440 --> 00:09:09,790
element has focus then it may have other

00:09:07,779 --> 00:09:12,220
components in it so for example we needs

00:09:09,790 --> 00:09:15,550
our composition it the composition had

00:09:12,220 --> 00:09:17,829
sections as components each of the

00:09:15,550 --> 00:09:19,209
sections had lines as a component and

00:09:17,829 --> 00:09:21,040
each of the lines are clusters the

00:09:19,209 --> 00:09:23,350
individual parts that you saw playing

00:09:21,040 --> 00:09:26,050
all of those are individual components

00:09:23,350 --> 00:09:28,270
so in this case say if you have multiple

00:09:26,050 --> 00:09:30,370
components as a certain children then

00:09:28,270 --> 00:09:33,040
they themselves may receive property but

00:09:30,370 --> 00:09:35,320
those properties are computed from it's

00:09:33,040 --> 00:09:37,600
their parent component component in fact

00:09:35,320 --> 00:09:40,120
parent component passes those property

00:09:37,600 --> 00:09:42,339
down to the children a child and it's a

00:09:40,120 --> 00:09:45,190
sum function sum derived function of

00:09:42,339 --> 00:09:47,410
that parent component State and

00:09:45,190 --> 00:09:49,209
properties as well as some additional

00:09:47,410 --> 00:09:50,589
property that it may pass a constant

00:09:49,209 --> 00:09:52,810
property so for example if I'm showing

00:09:50,589 --> 00:09:54,550
Google login versus Facebook

00:09:52,810 --> 00:09:57,130
text itself I may have a component

00:09:54,550 --> 00:09:59,410
called login button and text itself like

00:09:57,130 --> 00:10:01,420
Google login or facebook login may be a

00:09:59,410 --> 00:10:07,630
constant property that I pass on and

00:10:01,420 --> 00:10:09,970
then continues like this so this is this

00:10:07,630 --> 00:10:14,500
is a very simplified view of react

00:10:09,970 --> 00:10:16,980
component tree so now let's go into some

00:10:14,500 --> 00:10:19,260
of the challenges that we faced when we

00:10:16,980 --> 00:10:22,600
started use this technology stack

00:10:19,260 --> 00:10:24,460
scholar J's and react and how did we

00:10:22,600 --> 00:10:26,320
overcome those challenges in fact how we

00:10:24,460 --> 00:10:30,010
took advantage of certain properties as

00:10:26,320 --> 00:10:32,770
well so one is utilizing developer

00:10:30,010 --> 00:10:34,480
skillset typical Scala developer is very

00:10:32,770 --> 00:10:36,760
familiar with back-end so they are very

00:10:34,480 --> 00:10:40,930
very comfortable experience with

00:10:36,760 --> 00:10:44,650
back-end when you want to hire web

00:10:40,930 --> 00:10:46,600
developer you need a bunch of skill sets

00:10:44,650 --> 00:10:48,880
in this particular if you were

00:10:46,600 --> 00:10:50,470
especially where to use colleges so you

00:10:48,880 --> 00:10:52,120
need to use of course they need to know

00:10:50,470 --> 00:10:53,950
Scala the nutrional functional

00:10:52,120 --> 00:10:55,330
programming but they also need to use

00:10:53,950 --> 00:10:57,340
JavaScript because they are going to

00:10:55,330 --> 00:10:59,050
read documentation of react that is in

00:10:57,340 --> 00:11:02,230
written in targeted for JavaScript

00:10:59,050 --> 00:11:05,170
developers they also need to familiar

00:11:02,230 --> 00:11:06,460
with CSS because designer might create

00:11:05,170 --> 00:11:08,290
design but then you have to realize that

00:11:06,460 --> 00:11:10,990
design so you need to understand enough

00:11:08,290 --> 00:11:12,430
of CSS to be able to do that you also

00:11:10,990 --> 00:11:13,930
need to have good taste in UI

00:11:12,430 --> 00:11:16,540
development because not everything is

00:11:13,930 --> 00:11:20,440
done by designer so you need to add your

00:11:16,540 --> 00:11:24,040
own elements to it so when we face this

00:11:20,440 --> 00:11:26,680
problem we decided to try to go saying

00:11:24,040 --> 00:11:29,350
let's use colleges but try to match

00:11:26,680 --> 00:11:32,380
tools and technologies to J's as much as

00:11:29,350 --> 00:11:34,990
possible so don't go for let's say plain

00:11:32,380 --> 00:11:37,450
Java scream work but use something like

00:11:34,990 --> 00:11:40,540
react that will be part of it so for

00:11:37,450 --> 00:11:42,100
tools we use for bundling and everything

00:11:40,540 --> 00:11:43,810
from JavaScript point of view web pack

00:11:42,100 --> 00:11:47,260
web pack is the most popular frame

00:11:43,810 --> 00:11:48,700
bundling a tool right now so it what it

00:11:47,260 --> 00:11:52,810
does is it takes you all your assets

00:11:48,700 --> 00:11:55,540
JavaScript CSS image files and creates a

00:11:52,810 --> 00:11:59,530
bundle that browser will download and

00:11:55,540 --> 00:12:00,970
use and we have we use bunch of it has

00:11:59,530 --> 00:12:03,160
bunch of plugins so for example if you

00:12:00,970 --> 00:12:04,630
have to deal with CSS or s CSS there is

00:12:03,160 --> 00:12:06,139
a loader for that loader you can think

00:12:04,630 --> 00:12:07,790
of as a plugin

00:12:06,139 --> 00:12:09,800
if you want to do image compression on

00:12:07,790 --> 00:12:15,170
the way this image image loader and so

00:12:09,800 --> 00:12:16,899
on for the scholar side we use SBT which

00:12:15,170 --> 00:12:20,240
colleges plug-in obviously and

00:12:16,899 --> 00:12:22,490
scholarships bundler plug-in which

00:12:20,240 --> 00:12:23,720
basically allows you to use webpack from

00:12:22,490 --> 00:12:27,699
within SBT so you don't have to believe

00:12:23,720 --> 00:12:30,620
the comfort of SBT

00:12:27,699 --> 00:12:33,259
for frameworks point of view we started

00:12:30,620 --> 00:12:35,420
out with using Scala G's react and it's

00:12:33,259 --> 00:12:36,740
a great framework I absolutely have

00:12:35,420 --> 00:12:39,709
great respect for the developers

00:12:36,740 --> 00:12:43,699
developers of that framework but when we

00:12:39,709 --> 00:12:46,910
hired a few consultants to work on our

00:12:43,699 --> 00:12:49,910
product what we found is the news react

00:12:46,910 --> 00:12:51,319
quite well but not as much of deep

00:12:49,910 --> 00:12:54,170
functional programming concept arts

00:12:51,319 --> 00:12:56,420
colleges react and refusing so what we

00:12:54,170 --> 00:12:59,480
decided is to let's just try a framework

00:12:56,420 --> 00:13:01,190
called slinky and it happens to be a

00:12:59,480 --> 00:13:03,889
homegrown framework my son actually made

00:13:01,190 --> 00:13:05,420
it he gave a talk to the morning so if

00:13:03,889 --> 00:13:08,720
you haven't then you can watch this

00:13:05,420 --> 00:13:10,250
recording so slinky basically allows you

00:13:08,720 --> 00:13:11,810
to basic a simple proposition if you

00:13:10,250 --> 00:13:15,410
know react a little bit of JavaScript

00:13:11,810 --> 00:13:18,290
and little bit of Scala you can use it

00:13:15,410 --> 00:13:19,519
you don't need to go to a deeper

00:13:18,290 --> 00:13:23,329
functional programming concept right

00:13:19,519 --> 00:13:25,100
away you can if later on if you want it

00:13:23,329 --> 00:13:26,959
has direct mapping between react

00:13:25,100 --> 00:13:29,209
concepts and Scala code and I will I

00:13:26,959 --> 00:13:30,680
will show examples of that it also has

00:13:29,209 --> 00:13:32,000
great support for external components

00:13:30,680 --> 00:13:34,279
because let's face it if you want to

00:13:32,000 --> 00:13:35,930
really work on a real product then you

00:13:34,279 --> 00:13:37,490
have limited time and now we have been

00:13:35,930 --> 00:13:40,699
working for this for three or three

00:13:37,490 --> 00:13:44,209
years and we are right now going into

00:13:40,699 --> 00:13:45,529
public beta but it takes time and you

00:13:44,209 --> 00:13:47,089
know there are lots of lots of things

00:13:45,529 --> 00:13:48,500
you have to take here so you don't want

00:13:47,089 --> 00:13:51,920
to develop widgets such as calendar

00:13:48,500 --> 00:13:53,750
widget or is a colossal component you

00:13:51,920 --> 00:13:55,569
want to leverage as many components that

00:13:53,750 --> 00:13:57,800
other people have developed as possible

00:13:55,569 --> 00:13:59,240
so slinky has a great support for

00:13:57,800 --> 00:14:02,269
external component that you can just

00:13:59,240 --> 00:14:05,959
suck it in and use it so it is a typical

00:14:02,269 --> 00:14:08,029
component that in slinky so here we are

00:14:05,959 --> 00:14:10,660
showing a volume meter so it's just

00:14:08,029 --> 00:14:13,220
shows a slider of current amplitude and

00:14:10,660 --> 00:14:16,370
if you if it's clipping if it is

00:14:13,220 --> 00:14:18,829
reaching to the maximum value then you

00:14:16,370 --> 00:14:19,580
want to start showing in red so all this

00:14:18,829 --> 00:14:21,710
is Daisy

00:14:19,580 --> 00:14:23,270
it basically you provide the properties

00:14:21,710 --> 00:14:25,960
that this component will take amplitude

00:14:23,270 --> 00:14:27,950
as a property max amplitude so far and

00:14:25,960 --> 00:14:29,060
clipping threshold that you want to set

00:14:27,950 --> 00:14:32,029
when you want to start showing the red

00:14:29,060 --> 00:14:33,830
and then you calculate some some

00:14:32,029 --> 00:14:35,750
property such as is it clipping or and

00:14:33,830 --> 00:14:37,190
what amplitude to display so if it is

00:14:35,750 --> 00:14:38,720
not clipping then you want to show RMS

00:14:37,190 --> 00:14:41,420
value if it is clipping then you want to

00:14:38,720 --> 00:14:43,100
show the maximum value and other than

00:14:41,420 --> 00:14:45,380
that then you simply Shea said there's a

00:14:43,100 --> 00:14:47,000
div I'm going to create and then within

00:14:45,380 --> 00:14:50,000
that Dave I'm going to show the another

00:14:47,000 --> 00:14:52,640
do for slider the the red or green part

00:14:50,000 --> 00:14:54,350
and that will have a width that is

00:14:52,640 --> 00:14:56,210
proportionate to the amplitude that you

00:14:54,350 --> 00:14:57,740
want to display and then the CSS will

00:14:56,210 --> 00:15:00,290
take care of making it red green other

00:14:57,740 --> 00:15:04,160
things I will show example when we give

00:15:00,290 --> 00:15:06,680
another demo stateful component so here

00:15:04,160 --> 00:15:09,020
is a Google login button so the

00:15:06,680 --> 00:15:11,870
difference is is the render method is

00:15:09,020 --> 00:15:14,720
very similar it just renders few few

00:15:11,870 --> 00:15:17,870
deals and on click it's going to do

00:15:14,720 --> 00:15:20,589
certain other things and so on but you

00:15:17,870 --> 00:15:22,970
want to initialize the Google API itself

00:15:20,589 --> 00:15:25,520
somewhere and that somewhere placed in

00:15:22,970 --> 00:15:28,310
reacts life cycle is called component

00:15:25,520 --> 00:15:30,589
did mount means component has actually

00:15:28,310 --> 00:15:33,200
be realized on the screen and that is

00:15:30,589 --> 00:15:35,870
your time to go and initialize whatever

00:15:33,200 --> 00:15:39,800
you need to do such as initializing an

00:15:35,870 --> 00:15:42,020
external library if you want to use an

00:15:39,800 --> 00:15:46,850
external component and this component I

00:15:42,020 --> 00:15:51,410
will show you log it log out and so this

00:15:46,850 --> 00:15:54,320
is where we have this slider so this is

00:15:51,410 --> 00:15:59,180
something called slick slider nothing to

00:15:54,320 --> 00:16:02,170
do with Scala slick I will log in copy

00:15:59,180 --> 00:16:02,170
ready for the next one

00:16:02,500 --> 00:16:06,740
and this component when we want to use

00:16:05,150 --> 00:16:08,180
it there are two parts to it one is to

00:16:06,740 --> 00:16:10,160
declare like this is the JavaScript

00:16:08,180 --> 00:16:13,370
library I would like to use these are

00:16:10,160 --> 00:16:17,000
the CSS our in this case s CSS which is

00:16:13,370 --> 00:16:18,890
really super set of CSS files I want to

00:16:17,000 --> 00:16:21,830
use so this is something that will not

00:16:18,890 --> 00:16:23,510
is nothing to do with slick mmm slinky

00:16:21,830 --> 00:16:25,250
it's really essentially you are saying

00:16:23,510 --> 00:16:27,320
what my this is let me describe the

00:16:25,250 --> 00:16:30,070
external assets so that I can use it

00:16:27,320 --> 00:16:32,240
from within slinky

00:16:30,070 --> 00:16:34,310
typically react components don't have

00:16:32,240 --> 00:16:36,680
any behavior there are no methods to

00:16:34,310 --> 00:16:38,600
call a react component if they're all

00:16:36,680 --> 00:16:41,060
declarative as in you simply say here

00:16:38,600 --> 00:16:44,150
are properties here is a state and go

00:16:41,060 --> 00:16:46,010
render yourself but sometimes components

00:16:44,150 --> 00:16:49,760
offer an API that you can call it on a

00:16:46,010 --> 00:16:51,590
component so in this case slicker

00:16:49,760 --> 00:16:54,050
Russell happens to be that where you if

00:16:51,590 --> 00:16:55,850
I click on certain certain items then I

00:16:54,050 --> 00:16:56,630
can go and show that so for that there's

00:16:55,850 --> 00:16:59,060
a slick go-to

00:16:56,630 --> 00:17:02,150
given an index it can go to that

00:16:59,060 --> 00:17:06,860
particular index so after this setup all

00:17:02,150 --> 00:17:08,990
we have to do is declare properties so

00:17:06,860 --> 00:17:11,570
in this case you could look at the slick

00:17:08,990 --> 00:17:13,579
aerosols proper documentation and

00:17:11,570 --> 00:17:14,900
declare property so in this case I want

00:17:13,579 --> 00:17:17,600
to say well do I want to show the dots

00:17:14,900 --> 00:17:21,500
below do I want arrows so that I can go

00:17:17,600 --> 00:17:23,050
left and right what speed do I want to

00:17:21,500 --> 00:17:26,150
Kharis all that and so on and on and

00:17:23,050 --> 00:17:28,610
some callbacks so you are essentially

00:17:26,150 --> 00:17:30,680
looking at the documentation of slick

00:17:28,610 --> 00:17:33,380
aerosol and transforming into scala

00:17:30,680 --> 00:17:34,880
equivalent of each of those and then you

00:17:33,380 --> 00:17:36,710
are basically done all other things are

00:17:34,880 --> 00:17:38,480
essentially saying those first two lines

00:17:36,710 --> 00:17:42,290
are showing that I do want to refer to

00:17:38,480 --> 00:17:45,440
those CSS so that when web goes and runs

00:17:42,290 --> 00:17:47,480
it is not going to think as a dead code

00:17:45,440 --> 00:17:50,990
and it won't eliminate that so you need

00:17:47,480 --> 00:17:52,220
hold on some reference and the last line

00:17:50,990 --> 00:17:59,660
basically simply says what is the

00:17:52,220 --> 00:18:02,480
underlying JavaScript like method so the

00:17:59,660 --> 00:18:06,440
second issue we faced is extracting

00:18:02,480 --> 00:18:09,080
performance so let me so when we do our

00:18:06,440 --> 00:18:10,910
some real-time requirements so for

00:18:09,080 --> 00:18:14,210
example pitch detection and let me start

00:18:10,910 --> 00:18:15,770
the demo and then come back so I will go

00:18:14,210 --> 00:18:17,720
to something called practice room this

00:18:15,770 --> 00:18:20,720
is where you are expected to just

00:18:17,720 --> 00:18:22,970
practice so you get support for it is

00:18:20,720 --> 00:18:24,700
instrument bit instrument called table

00:18:22,970 --> 00:18:27,670
so

00:18:24,700 --> 00:18:30,720
but you can also go and do a free-form

00:18:27,670 --> 00:18:32,920
which basically means all I have is I

00:18:30,720 --> 00:18:35,460
don't have any beats but I want to

00:18:32,920 --> 00:18:38,380
explore it in a free-form manner and

00:18:35,460 --> 00:18:40,510
then you can go and look at this pitch

00:18:38,380 --> 00:18:43,390
visualization so in this case I'm going

00:18:40,510 --> 00:18:43,780
to actually play a rock composition

00:18:43,390 --> 00:18:47,350
called

00:18:43,780 --> 00:18:51,130
rock Duga let me just play it and then

00:18:47,350 --> 00:18:52,750
explain me along the way so I'm playing

00:18:51,130 --> 00:18:55,280
through sound floor that way even if I

00:18:52,750 --> 00:19:00,309
talk it won't pick up

00:18:55,280 --> 00:19:00,309
[Music]

00:19:04,110 --> 00:19:09,059
this is because of some flow that cut

00:19:06,210 --> 00:19:15,600
ticktick zone oops

00:19:09,059 --> 00:19:18,570
and I'm not even so it's showing you

00:19:15,600 --> 00:19:20,460
pitch how it's going up and down so this

00:19:18,570 --> 00:19:22,860
particular piece is played by one of our

00:19:20,460 --> 00:19:24,480
music advisor Nagaraj negative so he's a

00:19:22,860 --> 00:19:27,120
professional player that way you can see

00:19:24,480 --> 00:19:29,090
his pitch is matching the expected lines

00:19:27,120 --> 00:19:31,470
[Music]

00:19:29,090 --> 00:19:35,750
I'll let it play for maybe half a minute

00:19:31,470 --> 00:19:35,750
and then start continuing

00:19:36,670 --> 00:19:40,219
[Music]

00:19:42,100 --> 00:19:47,750
so I was mentioning raga has certain

00:19:46,010 --> 00:19:49,670
notes that he comes you could see it on

00:19:47,750 --> 00:19:51,500
piano there certain notes were only

00:19:49,670 --> 00:19:54,290
displayed the same notes that is played

00:19:51,500 --> 00:19:57,740
here as well and probably you cannot see

00:19:54,290 --> 00:19:59,570
but there are notes faint lines here and

00:19:57,740 --> 00:20:01,070
those are the notes you are not supposed

00:19:59,570 --> 00:20:02,750
to touch so as you can see he is never

00:20:01,070 --> 00:20:05,360
touching anything other than he is not

00:20:02,750 --> 00:20:09,230
resting on any other notes than the

00:20:05,360 --> 00:20:11,420
highlighted notes so this is our pitch

00:20:09,230 --> 00:20:12,980
detection so basically the idea is here

00:20:11,420 --> 00:20:15,170
in this case I am playing the sample but

00:20:12,980 --> 00:20:17,810
usually I would pick up my flute and

00:20:15,170 --> 00:20:19,850
play it and when I played it's never as

00:20:17,810 --> 00:20:21,710
good as this one you know so I then I

00:20:19,850 --> 00:20:23,870
get feedback like okay my particular

00:20:21,710 --> 00:20:26,540
note is going high so I can try to lower

00:20:23,870 --> 00:20:28,580
it down and if I am NOT able to hold

00:20:26,540 --> 00:20:30,230
note as long as is expected that I can

00:20:28,580 --> 00:20:43,580
try to improve my breathing technique

00:20:30,230 --> 00:20:44,930
and so on all right so what we want in

00:20:43,580 --> 00:20:47,840
this case is there is a microphone input

00:20:44,930 --> 00:20:51,050
the microphone input is acquired by

00:20:47,840 --> 00:20:53,780
audio source then we want to do which

00:20:51,050 --> 00:20:57,440
detection so we want to figure out what

00:20:53,780 --> 00:21:00,950
pitch is being played and finally drive

00:20:57,440 --> 00:21:04,400
the chart out of it and the challenge is

00:21:00,950 --> 00:21:07,160
to do everything at 60fps so basically

00:21:04,400 --> 00:21:10,850
you get to do 16 milliseconds roughly 16

00:21:07,160 --> 00:21:12,200
milliseconds per update and when we try

00:21:10,850 --> 00:21:14,900
it first with the straightforward

00:21:12,200 --> 00:21:18,650
approach it did not work we got

00:21:14,900 --> 00:21:20,330
something like 20 fps and even there

00:21:18,650 --> 00:21:23,330
there was a bunch of other problems I'll

00:21:20,330 --> 00:21:26,090
talk about that so challenge is how to

00:21:23,330 --> 00:21:27,920
how to extract it so one is we all know

00:21:26,090 --> 00:21:31,970
imitability is great right you know in

00:21:27,920 --> 00:21:34,850
fact we almost most our our program we

00:21:31,970 --> 00:21:36,560
do not have any where we use case

00:21:34,850 --> 00:21:38,270
classes very strongly without any funny

00:21:36,560 --> 00:21:40,490
business so this case classes are

00:21:38,270 --> 00:21:43,280
immutable objects and when we make a

00:21:40,490 --> 00:21:45,080
straight state transition we go from one

00:21:43,280 --> 00:21:47,660
object or other object do not modify the

00:21:45,080 --> 00:21:49,670
existing object so everybody's happy

00:21:47,660 --> 00:21:52,250
happy react is happy Scala is happy and

00:21:49,670 --> 00:21:53,870
it's very easy to reason about and for

00:21:52,250 --> 00:21:55,820
example implementing undo loop

00:21:53,870 --> 00:21:57,800
did not show you but in compression when

00:21:55,820 --> 00:22:00,650
I was making modification I could just

00:21:57,800 --> 00:22:02,900
hit ctrl Z or RZ and it will go back to

00:22:00,650 --> 00:22:05,480
the old composition if you immutable

00:22:02,900 --> 00:22:07,070
state then you are going from one

00:22:05,480 --> 00:22:09,260
composition to other composition to

00:22:07,070 --> 00:22:11,300
other composition so undo means simply

00:22:09,260 --> 00:22:13,250
going back one so rather than throwing

00:22:11,300 --> 00:22:14,990
out that particular object all you are

00:22:13,250 --> 00:22:16,370
doing is putting on a stack and you can

00:22:14,990 --> 00:22:19,130
go back and forth on that stack and

00:22:16,370 --> 00:22:24,700
that's how you get unloaded Oh almost 15

00:22:19,130 --> 00:22:28,309
minutes of work can you get under it but

00:22:24,700 --> 00:22:32,440
if you are not careful in certain

00:22:28,309 --> 00:22:34,340
critical portion it can cause problems

00:22:32,440 --> 00:22:35,600
you're not going to get as good

00:22:34,340 --> 00:22:38,210
performance as you want and more

00:22:35,600 --> 00:22:41,210
importantly and this is a much bigger

00:22:38,210 --> 00:22:43,100
problem that we faced is the GC can go

00:22:41,210 --> 00:22:46,010
the garbage collector character can go

00:22:43,100 --> 00:22:48,830
in overdrive so what we found is when we

00:22:46,010 --> 00:22:50,809
did first implementation where each of

00:22:48,830 --> 00:22:52,910
the stages we are producing a new output

00:22:50,809 --> 00:22:55,520
so we got a audio buffer from audio

00:22:52,910 --> 00:22:57,380
buffer we will calculate pitch and pitch

00:22:55,520 --> 00:23:00,110
calculation typically there are lots of

00:22:57,380 --> 00:23:01,280
ways to do it and everything has some

00:23:00,110 --> 00:23:03,170
advantages and disadvantage but

00:23:01,280 --> 00:23:05,600
everything eventually involves some sort

00:23:03,170 --> 00:23:08,390
of autocorrelation which involves some

00:23:05,600 --> 00:23:10,280
sort of calculating FFT so what we did

00:23:08,390 --> 00:23:11,690
is in each of the step calculating FFT

00:23:10,280 --> 00:23:14,350
then calculating power spectrum then

00:23:11,690 --> 00:23:16,220
calculating inverse FFT we did the first

00:23:14,350 --> 00:23:20,330
straightforward implementation where

00:23:16,220 --> 00:23:23,090
each was a map and then basically each

00:23:20,330 --> 00:23:27,530
stake stage we are producing a new data

00:23:23,090 --> 00:23:29,870
new a new array and that was it was

00:23:27,530 --> 00:23:34,309
pretty lot of garbage so because this

00:23:29,870 --> 00:23:38,030
frame is like a 4000 size 4000 floats so

00:23:34,309 --> 00:23:40,250
about 16 kilobytes of data and 16

00:23:38,030 --> 00:23:42,500
kilobyte of data if I using it and every

00:23:40,250 --> 00:23:44,660
16 milliseconds if I am producing lots

00:23:42,500 --> 00:23:46,070
and lots of buffers like this then I'm

00:23:44,660 --> 00:23:49,070
going to G's I would have to pay the

00:23:46,070 --> 00:23:52,429
price somewhere down the line so what we

00:23:49,070 --> 00:23:55,220
did was use mutability don't shy away

00:23:52,429 --> 00:23:58,130
from using mutability if you have proved

00:23:55,220 --> 00:23:59,660
that it is actually the reason the

00:23:58,130 --> 00:24:03,110
immutability is the reason it's causing

00:23:59,660 --> 00:24:05,060
is causing some problem and if you

00:24:03,110 --> 00:24:07,280
measure it and in this case we use cone

00:24:05,060 --> 00:24:09,100
profiling tool and what we found is

00:24:07,280 --> 00:24:13,070
the chart will go on and on for a while

00:24:09,100 --> 00:24:15,049
slow but not very perceptible but

00:24:13,070 --> 00:24:16,610
suddenly it will stop and that is a time

00:24:15,049 --> 00:24:20,539
when the garbage collection collector

00:24:16,610 --> 00:24:22,100
hits so you that that kind of interface

00:24:20,539 --> 00:24:24,140
was not the righted right way to it it

00:24:22,100 --> 00:24:26,210
will not it was very jarring even even

00:24:24,140 --> 00:24:28,580
when you start to look at 20 FPS graph

00:24:26,210 --> 00:24:31,669
it's very jerky and it's it's actually

00:24:28,580 --> 00:24:35,140
causes little bit of eye eye eye trouble

00:24:31,669 --> 00:24:35,140
you don't want to look at it for long

00:24:35,409 --> 00:24:42,470
second thing we did was we explored use

00:24:39,799 --> 00:24:44,330
of a SM dot GS and we will we are

00:24:42,470 --> 00:24:48,470
switching look looking at switching to

00:24:44,330 --> 00:24:51,470
grab assembly Bassem the reason was when

00:24:48,470 --> 00:24:56,900
we calculated FFT in Scala and this is a

00:24:51,470 --> 00:24:58,669
four thousand data size FFT 4k buffer

00:24:56,900 --> 00:25:01,370
frame then it took approximately three

00:24:58,669 --> 00:25:03,940
milliseconds the same FFT when we could

00:25:01,370 --> 00:25:10,010
compile using javascript to JavaScript

00:25:03,940 --> 00:25:11,480
it did I took about 14 milliseconds so

00:25:10,010 --> 00:25:13,460
this 14 milliseconds is a bit of a

00:25:11,480 --> 00:25:18,320
problem because our budget total budget

00:25:13,460 --> 00:25:19,700
is 16 milliseconds for 60fps because

00:25:18,320 --> 00:25:25,190
then we have only 2 milliseconds for UI

00:25:19,700 --> 00:25:27,020
update and that's not good enough so

00:25:25,190 --> 00:25:30,260
what we did is we looked at an

00:25:27,020 --> 00:25:32,390
implementation of F of T and in using

00:25:30,260 --> 00:25:35,390
ASM dot J's which is a restricted format

00:25:32,390 --> 00:25:38,690
of JavaScript which browsers can heavily

00:25:35,390 --> 00:25:40,309
optimized with that we could cut back to

00:25:38,690 --> 00:25:42,380
4 milliseconds and a very predictable

00:25:40,309 --> 00:25:46,159
performance on even small devices we

00:25:42,380 --> 00:25:49,820
don't get that bad performance so we we

00:25:46,159 --> 00:25:51,770
use ASM photos at a which is not very

00:25:49,820 --> 00:25:53,720
different than if you were to use a

00:25:51,770 --> 00:25:55,610
scholar program and suppose you found

00:25:53,720 --> 00:25:57,950
extremely tight loop that you have to do

00:25:55,610 --> 00:26:00,200
it a real time you could write a it

00:25:57,950 --> 00:26:04,179
isn't see and use gni and drive it from

00:26:00,200 --> 00:26:04,179
Scala that's very very similar idea here

00:26:04,419 --> 00:26:08,419
second is the remember this picture

00:26:06,320 --> 00:26:09,830
where you go from one state to another

00:26:08,419 --> 00:26:12,590
state and then there is a two different

00:26:09,830 --> 00:26:15,950
views and then react is going to do the

00:26:12,590 --> 00:26:17,659
dipping of two virtual dorms and then

00:26:15,950 --> 00:26:19,710
apply the mutations as needed

00:26:17,659 --> 00:26:23,220
to create a new view

00:26:19,710 --> 00:26:30,810
the thing is for example let's see if I

00:26:23,220 --> 00:26:33,450
go here lets me go to a competition go

00:26:30,810 --> 00:26:36,690
back to the same composition if I'm

00:26:33,450 --> 00:26:39,300
typing a note here what I'm really doing

00:26:36,690 --> 00:26:43,680
is conceptually is I'm changing that

00:26:39,300 --> 00:26:45,810
particular cluster v beat then that I

00:26:43,680 --> 00:26:48,360
cannot change because the line that is

00:26:45,810 --> 00:26:49,890
holding that the whole line that itself

00:26:48,360 --> 00:26:52,800
is immutable that means I have to change

00:26:49,890 --> 00:26:55,080
transform into new line but then there

00:26:52,800 --> 00:26:58,590
is a section and that section has to be

00:26:55,080 --> 00:26:59,790
changed but section is immutable so the

00:26:58,590 --> 00:27:02,250
composition has to change

00:26:59,790 --> 00:27:03,570
what composition is immutable so what

00:27:02,250 --> 00:27:05,880
you can do is then that you take a

00:27:03,570 --> 00:27:10,110
create a new composition for one change

00:27:05,880 --> 00:27:12,480
and then put it on the stack and react

00:27:10,110 --> 00:27:14,370
has to then respond to it so it'll react

00:27:12,480 --> 00:27:15,570
from react sportif e-o composition has

00:27:14,370 --> 00:27:17,790
changed let me read render the whole

00:27:15,570 --> 00:27:19,680
thing so what it is going to do is going

00:27:17,790 --> 00:27:21,540
to ask composition to say give me your

00:27:19,680 --> 00:27:23,820
virtual DOM which in turn will ask each

00:27:21,540 --> 00:27:26,550
sections to give it their virtual dorms

00:27:23,820 --> 00:27:28,500
and then lines and cluster and so on and

00:27:26,550 --> 00:27:30,210
then after that is going to find like

00:27:28,500 --> 00:27:32,400
okay most of the things haven't changed

00:27:30,210 --> 00:27:34,200
so it's going to go for example second

00:27:32,400 --> 00:27:36,270
line and it's going to say nothing has

00:27:34,200 --> 00:27:41,280
changed there so I don't have any

00:27:36,270 --> 00:27:43,470
mutations to run but doing this process

00:27:41,280 --> 00:27:45,960
just doing this simple process of saying

00:27:43,470 --> 00:27:47,940
give me the virtual Dom for before and

00:27:45,960 --> 00:27:49,980
after and calculate lit so that I can

00:27:47,940 --> 00:27:54,060
calculate the div it's expensive process

00:27:49,980 --> 00:27:56,850
especially for large screens like this

00:27:54,060 --> 00:27:59,610
so this is 16 lines in each one and then

00:27:56,850 --> 00:28:01,590
this can run like probably 200 lines so

00:27:59,610 --> 00:28:06,420
you get lots and lots of changes

00:28:01,590 --> 00:28:08,340
potentially so what you do react also

00:28:06,420 --> 00:28:09,750
offers reacts I understand this problem

00:28:08,340 --> 00:28:11,970
and this is we are not the only one

00:28:09,750 --> 00:28:14,820
so it offers something called should

00:28:11,970 --> 00:28:16,710
component update so basically at any

00:28:14,820 --> 00:28:18,810
tree level any component level you can

00:28:16,710 --> 00:28:21,120
intercept and saying given old

00:28:18,810 --> 00:28:24,780
properties and old state and given new

00:28:21,120 --> 00:28:27,860
properties and new state should this

00:28:24,780 --> 00:28:30,390
component it has anything change that is

00:28:27,860 --> 00:28:32,920
useful for this component that is

00:28:30,390 --> 00:28:34,720
meaningful for this component

00:28:32,920 --> 00:28:36,640
so the simplest implementation is to

00:28:34,720 --> 00:28:38,830
just compare properties and state but

00:28:36,640 --> 00:28:41,140
what we found is that is not always

00:28:38,830 --> 00:28:43,720
enough you may have to like for example

00:28:41,140 --> 00:28:46,690
say for example if I am doing a

00:28:43,720 --> 00:28:49,510
selection here if I want to get here

00:28:46,690 --> 00:28:51,570
smooth performance like this then I want

00:28:49,510 --> 00:28:54,820
to say okay there is a selection change

00:28:51,570 --> 00:28:56,770
but all I want to do is as I'm moving

00:28:54,820 --> 00:28:59,020
into new cluster only the in this case

00:28:56,770 --> 00:29:01,120
for example if I move to the 8b then

00:28:59,020 --> 00:29:04,270
8-bit is the only one that should go and

00:29:01,120 --> 00:29:07,510
get really rendered all other bits

00:29:04,270 --> 00:29:09,100
should remain the same so then for that

00:29:07,510 --> 00:29:11,380
you do additional checks saying okay has

00:29:09,100 --> 00:29:13,090
selection change from my person of my

00:29:11,380 --> 00:29:13,620
point of view so this is at the cluster

00:29:13,090 --> 00:29:16,450
level

00:29:13,620 --> 00:29:19,840
similarly if I'm playing then you are

00:29:16,450 --> 00:29:21,910
highlighting one beat at a time then you

00:29:19,840 --> 00:29:23,380
want to ask the question or you state a

00:29:21,910 --> 00:29:24,550
change that's wonderful but has it

00:29:23,380 --> 00:29:27,250
changed from my point of view so that

00:29:24,550 --> 00:29:28,810
means should i re-render or not so you

00:29:27,250 --> 00:29:29,920
get a lot of benefit by doing at high

00:29:28,810 --> 00:29:31,450
level so essentially you can if you can

00:29:29,920 --> 00:29:33,580
knock down the whole tree saying okay

00:29:31,450 --> 00:29:35,290
the second section 2 has not changed at

00:29:33,580 --> 00:29:37,000
all so don't even worry about you don't

00:29:35,290 --> 00:29:40,900
calculate the virtual Dom don't do it if

00:29:37,000 --> 00:29:43,270
that's extremely useful the next

00:29:40,900 --> 00:29:47,350
challenge we have had to face was build

00:29:43,270 --> 00:29:48,820
times sociology is unlike JavaScript if

00:29:47,350 --> 00:29:50,080
you if you compare if there is no

00:29:48,820 --> 00:29:51,820
compilation so you basically are

00:29:50,080 --> 00:29:53,350
straightaway loading it and even if you

00:29:51,820 --> 00:29:54,880
go through es6 and babel and those

00:29:53,350 --> 00:29:57,520
things they're usually pretty fast

00:29:54,880 --> 00:29:58,900
because type checking isn't there so the

00:29:57,520 --> 00:30:02,100
work that they have to do is rather

00:29:58,900 --> 00:30:04,840
limited but scholar gist is little bit

00:30:02,100 --> 00:30:09,700
more work so in this case I am compiling

00:30:04,840 --> 00:30:12,720
a I am running a test in JavaScript and

00:30:09,700 --> 00:30:16,450
it takes about in this case 11 seconds

00:30:12,720 --> 00:30:18,370
so fast op GS takes some time then web

00:30:16,450 --> 00:30:19,930
pack which takes the JavaScript or other

00:30:18,370 --> 00:30:21,460
other assets and compiles them and

00:30:19,930 --> 00:30:23,770
before it can run it take some

00:30:21,460 --> 00:30:27,970
additional time but total it takes about

00:30:23,770 --> 00:30:30,100
11 minutes at 13 seconds if you do the

00:30:27,970 --> 00:30:35,340
same thing Java Virtual Machine same

00:30:30,100 --> 00:30:35,340
test same code it takes about one second

00:30:35,660 --> 00:30:40,760
so what we do is therefore we want to

00:30:38,420 --> 00:30:42,260
say we don't want to especially pitch

00:30:40,760 --> 00:30:44,990
detection is extremely hard problem

00:30:42,260 --> 00:30:46,790
because you may get octave errors and a

00:30:44,990 --> 00:30:48,650
lot of other burden you want to say what

00:30:46,790 --> 00:30:50,800
is this noise or indeed was somebody

00:30:48,650 --> 00:30:53,630
just covering and wasn't producing

00:30:50,800 --> 00:30:56,150
musical note so all this filtering takes

00:30:53,630 --> 00:30:57,320
takes a lot of effort so what we want to

00:30:56,150 --> 00:30:58,990
do is when you are working on pitch

00:30:57,320 --> 00:31:01,280
detection we don't want to worry about

00:30:58,990 --> 00:31:04,730
how it's going to be here on JavaScript

00:31:01,280 --> 00:31:07,760
we just want to make it work and because

00:31:04,730 --> 00:31:09,800
Java Scala is isomorphism very strong we

00:31:07,760 --> 00:31:12,470
have not encountered a situation where a

00:31:09,800 --> 00:31:14,680
certain algorithm Bolton JVM and then

00:31:12,470 --> 00:31:17,180
that code failed to work on JavaScript

00:31:14,680 --> 00:31:19,910
so what we do is we move or time we are

00:31:17,180 --> 00:31:23,150
working on JVM we run our tests we make

00:31:19,910 --> 00:31:24,890
changes and keep going through the cycle

00:31:23,150 --> 00:31:26,810
and we never happy with that part then

00:31:24,890 --> 00:31:31,040
we just look at a JavaScript and usually

00:31:26,810 --> 00:31:33,440
just new hips so we share as much as

00:31:31,040 --> 00:31:34,910
core possible and in certain part is

00:31:33,440 --> 00:31:36,920
very natural so for example our pitch

00:31:34,910 --> 00:31:39,290
detection we want to make it work on

00:31:36,920 --> 00:31:41,720
server-side for batch processing but

00:31:39,290 --> 00:31:43,640
also on UI side so there it's very

00:31:41,720 --> 00:31:47,510
natural for us to want to share code

00:31:43,640 --> 00:31:50,390
between JVM and Jas but even the places

00:31:47,510 --> 00:31:52,190
where we do not imagine any reason that

00:31:50,390 --> 00:31:54,860
why would we share why would we need

00:31:52,190 --> 00:31:57,290
that code on JVM we still go extra mile

00:31:54,860 --> 00:31:59,660
to make that code work on JVM for

00:31:57,290 --> 00:32:01,850
example if I am doing selection logic if

00:31:59,660 --> 00:32:03,890
when I was moving the cursor there is no

00:32:01,850 --> 00:32:06,740
possible JVM application I can think of

00:32:03,890 --> 00:32:10,070
but that logic of is this custard

00:32:06,740 --> 00:32:11,540
relevant if I were to double click on a

00:32:10,070 --> 00:32:14,390
line what what clusters will get

00:32:11,540 --> 00:32:19,520
selected all that logic we do it such

00:32:14,390 --> 00:32:23,170
that it works on JVM as well so the

00:32:19,520 --> 00:32:25,940
problem you face therefore is JVM NGS

00:32:23,170 --> 00:32:27,260
logic logic but the algorithm part it

00:32:25,940 --> 00:32:29,420
works straight away there is nothing

00:32:27,260 --> 00:32:30,830
more need to be done but there are some

00:32:29,420 --> 00:32:32,810
interaction with the platform that you

00:32:30,830 --> 00:32:34,880
have to abstract out so for example if

00:32:32,810 --> 00:32:36,950
you are doing HTTP interaction then

00:32:34,880 --> 00:32:40,010
there is a different way of doing a JVM

00:32:36,950 --> 00:32:41,900
than through a browser or you want to do

00:32:40,010 --> 00:32:43,730
cookie store for authentication related

00:32:41,900 --> 00:32:46,430
tests the

00:32:43,730 --> 00:32:48,110
that you have to abstract out or what I

00:32:46,430 --> 00:32:51,200
showed you that we have FFT

00:32:48,110 --> 00:32:53,660
implementation in Scala and FFT

00:32:51,200 --> 00:32:55,160
implementation in SM dot Jas and

00:32:53,660 --> 00:32:58,190
therefore we have to abstract that

00:32:55,160 --> 00:32:59,750
algorithm out to say okay if your gvm

00:32:58,190 --> 00:33:02,330
then call certain part of code if you're

00:32:59,750 --> 00:33:07,190
in jazz concert another code but that

00:33:02,330 --> 00:33:08,950
has to be abstracted out so abstracting

00:33:07,190 --> 00:33:11,150
is not that hard and there's nothing

00:33:08,950 --> 00:33:13,430
exactly very novel concept so in this

00:33:11,150 --> 00:33:15,380
case there is an HTTP trade which

00:33:13,430 --> 00:33:17,630
basically has one method execute that

00:33:15,380 --> 00:33:22,700
takes the request and this is a feature

00:33:17,630 --> 00:33:24,800
of response and we have rich interface

00:33:22,700 --> 00:33:26,630
over it that will do get post delete and

00:33:24,800 --> 00:33:29,540
so on but fundamentally is the only only

00:33:26,630 --> 00:33:31,750
one method so we have a J's

00:33:29,540 --> 00:33:36,380
implementation that basically uses Ajax

00:33:31,750 --> 00:33:38,720
and we have Java implementation that

00:33:36,380 --> 00:33:41,150
uses okay HTTP to do the exactly same

00:33:38,720 --> 00:33:44,720
thing so from clients point of view they

00:33:41,150 --> 00:33:46,300
use the same just at rate HTTP and the

00:33:44,720 --> 00:33:51,650
factory will create appropriate

00:33:46,300 --> 00:33:54,020
implementation and use it similarly and

00:33:51,650 --> 00:33:55,610
this is different example where we want

00:33:54,020 --> 00:33:59,150
to produce we want to do audio

00:33:55,610 --> 00:34:02,390
processing on JVM side now as well as

00:33:59,150 --> 00:34:04,510
GSI so we want to take an mp3 file run

00:34:02,390 --> 00:34:06,710
through the our algorithm and do some

00:34:04,510 --> 00:34:08,870
assertions such as if I'm transcribing

00:34:06,710 --> 00:34:12,080
it then I'm producing the right node at

00:34:08,870 --> 00:34:15,050
the right time how do you deal with it

00:34:12,080 --> 00:34:17,390
and the problem here is unlike HTTP

00:34:15,050 --> 00:34:19,640
where even though mechanism is different

00:34:17,390 --> 00:34:21,500
the goal and the interaction is

00:34:19,640 --> 00:34:24,200
identical you make a request you get

00:34:21,500 --> 00:34:25,910
back a response but on JavaScript side

00:34:24,200 --> 00:34:27,440
there is no file system you do not have

00:34:25,910 --> 00:34:30,140
access to file system especially if you

00:34:27,440 --> 00:34:32,930
are in a browser environment so what we

00:34:30,140 --> 00:34:34,580
do is we play a trick so on JVM side

00:34:32,930 --> 00:34:36,760
nothing special we just create a file

00:34:34,580 --> 00:34:40,540
audio source based on a file given URL

00:34:36,760 --> 00:34:40,540
but on JavaScript side

00:34:45,170 --> 00:34:52,170
instead of file we use URL so what we do

00:34:49,920 --> 00:34:55,560
is we fire a local server HTTP server

00:34:52,170 --> 00:34:59,070
that basically points to the directory

00:34:55,560 --> 00:35:00,540
where we have our files and then when we

00:34:59,070 --> 00:35:03,570
are we are asked to produce an audio

00:35:00,540 --> 00:35:05,880
source we simply use that URL and give

00:35:03,570 --> 00:35:09,320
you the file source based on that URL

00:35:05,880 --> 00:35:12,000
audio file source based on that URL

00:35:09,320 --> 00:35:17,520
next is dealing with bundle size you see

00:35:12,000 --> 00:35:22,250
how am I doing with time so actually let

00:35:17,520 --> 00:35:22,250
me just open it in browser

00:35:27,800 --> 00:35:37,410
so when you run web back and through a

00:35:32,099 --> 00:35:39,150
plugin it will produce you give the how

00:35:37,410 --> 00:35:41,430
is your bundle comprised off so in this

00:35:39,150 --> 00:35:43,349
case your learned raga web opt which is

00:35:41,430 --> 00:35:45,480
optimized version of JavaScript code and

00:35:43,349 --> 00:35:46,770
then there are a bunch of module that we

00:35:45,480 --> 00:35:50,150
depend on Braintree for payment

00:35:46,770 --> 00:35:54,030
processing and draft J's for doing rich

00:35:50,150 --> 00:35:56,790
rich editor so you will see here that at

00:35:54,030 --> 00:36:00,060
the top level the gzipped the whole

00:35:56,790 --> 00:36:03,930
bundle gzip is about 800 kilobytes 780

00:36:00,060 --> 00:36:06,599
kilobytes and off which the JavaScript

00:36:03,930 --> 00:36:09,810
part thus collages part is about 580

00:36:06,599 --> 00:36:11,369
kilobytes which is not bad at all given

00:36:09,810 --> 00:36:13,470
the composit of this application it's

00:36:11,369 --> 00:36:16,380
doing all the editor stuff is doing all

00:36:13,470 --> 00:36:18,089
the pattern creation stuff it's creating

00:36:16,380 --> 00:36:21,180
pitch detection is doing all the graphs

00:36:18,089 --> 00:36:22,440
it's not at all bad and it's very it's a

00:36:21,180 --> 00:36:31,710
very typical size that you will see in

00:36:22,440 --> 00:36:33,420
the wild problem however is when I load

00:36:31,710 --> 00:36:35,730
for it for example the front page

00:36:33,420 --> 00:36:37,710
I don't need most of its I need like

00:36:35,730 --> 00:36:39,720
couple of buttons and I maybe carousel

00:36:37,710 --> 00:36:42,329
and that's it so I don't need to have to

00:36:39,720 --> 00:36:44,069
pay the price for creating editor the

00:36:42,329 --> 00:36:47,099
code for editor code for pitch detection

00:36:44,069 --> 00:36:48,780
and everything so what just in plain

00:36:47,099 --> 00:36:50,819
JavaScript what people do is they use

00:36:48,780 --> 00:36:53,280
something called code splitting so

00:36:50,819 --> 00:36:55,410
essentially in if you are using es6 then

00:36:53,280 --> 00:36:56,760
you each of your javascript file will

00:36:55,410 --> 00:36:58,380
declare dependents in another one

00:36:56,760 --> 00:37:00,089
because it's say okay I'm going to use

00:36:58,380 --> 00:37:03,480
code from this other file I need to use

00:37:00,089 --> 00:37:06,589
the J's the import or required statement

00:37:03,480 --> 00:37:11,069
and that way it essentially creates a a

00:37:06,589 --> 00:37:12,900
tree of dependency and then in

00:37:11,069 --> 00:37:14,400
conjunction with the web pack and router

00:37:12,900 --> 00:37:16,020
you are going to see it okay if I'm

00:37:14,400 --> 00:37:18,329
going to hit this route if I'm hitting

00:37:16,020 --> 00:37:20,640
the front page for example what are the

00:37:18,329 --> 00:37:24,569
what parts of code I need and only load

00:37:20,640 --> 00:37:26,220
that part for now so that makes life

00:37:24,569 --> 00:37:28,290
really really easy because you can

00:37:26,220 --> 00:37:30,510
develop a very complex application but

00:37:28,290 --> 00:37:32,099
you can know that when you load a

00:37:30,510 --> 00:37:33,990
particular functionality you are only

00:37:32,099 --> 00:37:36,450
loading what is required strictly for

00:37:33,990 --> 00:37:39,700
that particular functionality

00:37:36,450 --> 00:37:43,089
that is not currently possible in s

00:37:39,700 --> 00:37:44,980
colleges there is a issue open there and

00:37:43,089 --> 00:37:46,809
hopefully that gets addressed soon but

00:37:44,980 --> 00:37:50,230
we do like use of mitigation strategies

00:37:46,809 --> 00:37:52,599
so we apply long term cashing of all

00:37:50,230 --> 00:37:54,819
assets and it's extremely easy to do in

00:37:52,599 --> 00:37:58,839
webpack so essentially all we do is

00:37:54,819 --> 00:38:00,970
content hash of the asset is embedded

00:37:58,839 --> 00:38:02,890
into file system and then we give

00:38:00,970 --> 00:38:07,089
expiration for that particular assets to

00:38:02,890 --> 00:38:08,829
be infinite and therefore if content

00:38:07,089 --> 00:38:13,690
changes the next time client will load

00:38:08,829 --> 00:38:16,119
the new new content we are exploring

00:38:13,690 --> 00:38:18,489
pre-rendering of front page at least so

00:38:16,119 --> 00:38:21,099
front page gets loaded in HTML it

00:38:18,489 --> 00:38:22,720
without any JavaScript and then when the

00:38:21,099 --> 00:38:25,359
background will load the all of the

00:38:22,720 --> 00:38:27,190
bundle that I showed you but ultimate

00:38:25,359 --> 00:38:33,460
solution is to force colleges to really

00:38:27,190 --> 00:38:35,049
offer code splitting as a possibility I

00:38:33,460 --> 00:38:39,190
think I'm running out of time so I'm

00:38:35,049 --> 00:38:40,779
going to run through this fast ok yeah

00:38:39,190 --> 00:38:42,369
this is this is important point is one

00:38:40,779 --> 00:38:44,319
other thing is if you go to college s

00:38:42,369 --> 00:38:45,759
gator periodically you get the question

00:38:44,319 --> 00:38:48,400
like how am I going to make this work

00:38:45,759 --> 00:38:50,289
with play framework so idea is you will

00:38:48,400 --> 00:38:52,900
have Scala GS code that you put it into

00:38:50,289 --> 00:38:54,519
a particular directory of play framework

00:38:52,900 --> 00:38:56,859
or attach TTP or whichever one you use

00:38:54,519 --> 00:38:58,690
and just making this whole thing work

00:38:56,859 --> 00:39:00,999
together it's it takes time and it takes

00:38:58,690 --> 00:39:02,799
effort so what we did is from the get-go

00:39:00,999 --> 00:39:04,599
we simply said okay there is there are

00:39:02,799 --> 00:39:07,329
two different concerns one is producing

00:39:04,599 --> 00:39:10,269
data and preserving that data and that

00:39:07,329 --> 00:39:11,799
we do to API server we use rest and we

00:39:10,269 --> 00:39:16,420
are transitioning slowly over to graph

00:39:11,799 --> 00:39:18,880
QL and that will respond and that will

00:39:16,420 --> 00:39:22,299
do the JSON serving and then we have a

00:39:18,880 --> 00:39:24,309
separate node.js application which is

00:39:22,299 --> 00:39:27,930
really like ten line of code that all

00:39:24,309 --> 00:39:31,900
says is serves a static static content

00:39:27,930 --> 00:39:35,019
HTML Javascript CSS etcetera so this is

00:39:31,900 --> 00:39:36,789
much better experience because even for

00:39:35,019 --> 00:39:38,230
us like when during our development we

00:39:36,789 --> 00:39:39,819
typically in one mindset either we are

00:39:38,230 --> 00:39:42,400
working on UI or we are working on

00:39:39,819 --> 00:39:46,040
server so typically when we are working

00:39:42,400 --> 00:39:48,530
on UI it goes that for the day's a data

00:39:46,040 --> 00:39:50,420
at a stretch we never have to restart

00:39:48,530 --> 00:39:53,119
the server so we simply work on the

00:39:50,420 --> 00:39:56,150
front front page and it's much much

00:39:53,119 --> 00:39:58,430
simpler experience last is quickly is

00:39:56,150 --> 00:40:00,500
like when you look at errors in

00:39:58,430 --> 00:40:01,850
production I don't think you can read it

00:40:00,500 --> 00:40:03,500
but even if you could that would not be

00:40:01,850 --> 00:40:05,359
very useful it's a very cryptically

00:40:03,500 --> 00:40:08,930
written code that says like this error

00:40:05,359 --> 00:40:11,869
has occurred at this particular line and

00:40:08,930 --> 00:40:13,250
if you click that on that line you get

00:40:11,869 --> 00:40:17,050
further cryptic this is the JavaScript

00:40:13,250 --> 00:40:18,430
and it is saying that on line 50 column

00:40:17,050 --> 00:40:23,560
00:40:18,430 --> 00:40:25,369
and 162 there is an error and this is

00:40:23,560 --> 00:40:26,900
useless writer and thinks sometimes

00:40:25,369 --> 00:40:28,970
things go wrong things go wrong in

00:40:26,900 --> 00:40:31,520
production especially in production so

00:40:28,970 --> 00:40:33,590
what you want to do is you want to

00:40:31,520 --> 00:40:36,140
actually have source map enabled in

00:40:33,590 --> 00:40:37,490
production as well but if you enable

00:40:36,140 --> 00:40:39,710
source map in production essentially

00:40:37,490 --> 00:40:44,119
you're exposing your source code so what

00:40:39,710 --> 00:40:47,720
we do is we enable sourced maps but

00:40:44,119 --> 00:40:49,310
point to a local host URL and then when

00:40:47,720 --> 00:40:50,810
we load it now you will get a nice like

00:40:49,310 --> 00:40:54,619
saying ok there is an error on main

00:40:50,810 --> 00:40:56,540
router line 120 mm dot Scala line 129 if

00:40:54,619 --> 00:40:59,990
you open it then you see a source of

00:40:56,540 --> 00:41:02,810
your error and hopefully can fix it so

00:40:59,990 --> 00:41:06,920
very simple to setup all you do is when

00:41:02,810 --> 00:41:10,490
you create in SBT you will simply that I

00:41:06,920 --> 00:41:12,109
say that I need a source map and in web

00:41:10,490 --> 00:41:14,800
pack you will say that I want to use

00:41:12,109 --> 00:41:19,430
this particular localhost 10,000 as a

00:41:14,800 --> 00:41:22,190
prefix for my loading the source map so

00:41:19,430 --> 00:41:23,420
now I don't put this into production I

00:41:22,190 --> 00:41:25,850
just put it up keep it locally these

00:41:23,420 --> 00:41:27,380
files and whenever I want I haven't

00:41:25,850 --> 00:41:30,680
production error I just start this local

00:41:27,380 --> 00:41:32,240
server in the last line as I shown last

00:41:30,680 --> 00:41:36,619
line and then I get good good error

00:41:32,240 --> 00:41:38,900
messages so that's my presentation so

00:41:36,619 --> 00:41:40,700
it's a very complex application that we

00:41:38,900 --> 00:41:44,210
are very proud of it's really helping

00:41:40,700 --> 00:41:45,920
already a lot of people it took some

00:41:44,210 --> 00:41:47,869
effort for us to do it but we are happy

00:41:45,920 --> 00:41:49,430
that we use colleges I don't think I

00:41:47,869 --> 00:41:51,680
don't believe we would have gotten as

00:41:49,430 --> 00:41:53,570
successful as we are without using Scala

00:41:51,680 --> 00:41:55,670
JS because in JavaScript especially

00:41:53,570 --> 00:41:58,510
refactoring when you pivot from one

00:41:55,670 --> 00:42:01,240
doing one way off to other other way

00:41:58,510 --> 00:42:04,300
your model refactoring can be extremely

00:42:01,240 --> 00:42:06,310
scary experience without type helping

00:42:04,300 --> 00:42:08,100
you along the way with collages when a

00:42:06,310 --> 00:42:10,630
we have refactor it is so many times and

00:42:08,100 --> 00:42:12,640
it's almost always the case where we

00:42:10,630 --> 00:42:15,010
make the change that we want let

00:42:12,640 --> 00:42:17,080
compiler tell us what what what errors

00:42:15,010 --> 00:42:19,120
we made and just chase down those errors

00:42:17,080 --> 00:42:21,850
for next whatever however long it long

00:42:19,120 --> 00:42:24,670
it takes and by the end of it we it's

00:42:21,850 --> 00:42:26,260
all working again alright with that I

00:42:24,670 --> 00:42:28,750
think I can take some questions thank

00:42:26,260 --> 00:42:30,430
you so the question is what they do for

00:42:28,750 --> 00:42:32,440
our pre-rendering what kind of tools you

00:42:30,430 --> 00:42:34,810
end up using so what we are exploring

00:42:32,440 --> 00:42:37,060
right now is there is a plugin for web

00:42:34,810 --> 00:42:39,070
pack called static site generator

00:42:37,060 --> 00:42:42,220
plug-in and that basically simply

00:42:39,070 --> 00:42:44,080
essentially crawls the page and that

00:42:42,220 --> 00:42:45,610
creates the static file now there is

00:42:44,080 --> 00:42:47,590
less some other details there that you

00:42:45,610 --> 00:42:50,680
have to say what data got used for that

00:42:47,590 --> 00:42:52,300
particular generation so all that thing

00:42:50,680 --> 00:42:54,730
but it's a web pack so to answer your

00:42:52,300 --> 00:42:56,770
question it's mostly web pack little bit

00:42:54,730 --> 00:43:00,130
codings colleges to essentially hydrate

00:42:56,770 --> 00:43:02,590
and rehydrate your data yeah the

00:43:00,130 --> 00:43:04,300
question is given that we are we we have

00:43:02,590 --> 00:43:07,600
desire to share code between server and

00:43:04,300 --> 00:43:09,970
client how do we manage that so we keep

00:43:07,600 --> 00:43:11,410
the code into a same repository so our

00:43:09,970 --> 00:43:13,420
typical project looks like there are

00:43:11,410 --> 00:43:16,240
three there are three directories one is

00:43:13,420 --> 00:43:19,180
shared one is GS one is JVM most of the

00:43:16,240 --> 00:43:21,210
code resides in shared and it's done

00:43:19,180 --> 00:43:24,040
such that each project is cross

00:43:21,210 --> 00:43:27,670
something called cross project in Scala

00:43:24,040 --> 00:43:30,430
GS terminology it you can say that okay

00:43:27,670 --> 00:43:32,980
use there are essentially two natures of

00:43:30,430 --> 00:43:34,840
particular H sub project one is the JVM

00:43:32,980 --> 00:43:37,300
nature and other one is J's nature and

00:43:34,840 --> 00:43:39,100
then you can and top-level there are two

00:43:37,300 --> 00:43:41,050
separate projects one is a learn raga

00:43:39,100 --> 00:43:43,000
server another one is learn raga web and

00:43:41,050 --> 00:43:45,310
learn Onaga web is a pure project it's

00:43:43,000 --> 00:43:46,870
just as JavaScript and it declares

00:43:45,310 --> 00:43:49,330
dependency on other all other projects

00:43:46,870 --> 00:43:50,980
but implicitly it means it depends on

00:43:49,330 --> 00:43:53,890
the GS part of all other projects

00:43:50,980 --> 00:43:55,540
whereas server it means it depends on

00:43:53,890 --> 00:43:57,250
the JVM nature of all other projects so

00:43:55,540 --> 00:43:58,840
it works beautifully so it's a it's the

00:43:57,250 --> 00:44:00,960
same repository to answer your question

00:43:58,840 --> 00:44:03,310
it's the same repository

00:44:00,960 --> 00:44:05,380
even in IntelliJ we load it in this at

00:44:03,310 --> 00:44:07,780
the same time it just that there are two

00:44:05,380 --> 00:44:09,170
top level project that one is JVM only

00:44:07,780 --> 00:44:12,279
one is J's only

00:44:09,170 --> 00:44:15,289
yeah the question is are we looking into

00:44:12,279 --> 00:44:17,000
getting MIDI input presumably for

00:44:15,289 --> 00:44:19,549
transcription and typing in the notes

00:44:17,000 --> 00:44:21,440
purpose we are exploring it the

00:44:19,549 --> 00:44:23,900
complexity in walls in Aenon and

00:44:21,440 --> 00:44:26,210
classical music is often we were

00:44:23,900 --> 00:44:29,299
watching the chart he was taking like

00:44:26,210 --> 00:44:30,559
long transition between the notes and

00:44:29,299 --> 00:44:32,269
that's a very characteristic is called

00:44:30,559 --> 00:44:34,910
mean it's a like essentially going from

00:44:32,269 --> 00:44:38,119
one no to other node so usually all the

00:44:34,910 --> 00:44:41,510
instruments that are very in key nature

00:44:38,119 --> 00:44:43,700
like P&O aren't exactly very suitable so

00:44:41,510 --> 00:44:47,690
even MIDI can capture only some details

00:44:43,700 --> 00:44:51,319
but we are exploring it through the yeah

00:44:47,690 --> 00:44:52,519
to make the transition yeah yeah but we

00:44:51,319 --> 00:44:54,260
are looking into that actually we are

00:44:52,519 --> 00:44:57,319
looking into that interface saying yo

00:44:54,260 --> 00:44:59,539
can we make transition easy our ideal

00:44:57,319 --> 00:45:02,240
goal is for somebody to just simply sing

00:44:59,539 --> 00:45:04,160
and that transcribes into the notes or

00:45:02,240 --> 00:45:06,410
play the instrument and transcribe but

00:45:04,160 --> 00:45:11,079
media might be a good intermediate

00:45:06,410 --> 00:45:13,250
solution any other questions

00:45:11,079 --> 00:45:14,630
all right I will be hanging out so if

00:45:13,250 --> 00:45:16,730
you want to ask any question about Scala

00:45:14,630 --> 00:45:18,680
GS or even Indian classical music I'll

00:45:16,730 --> 00:45:20,060
be more than happy to do so all right

00:45:18,680 --> 00:45:23,110
thank you

00:45:20,060 --> 00:45:23,110

YouTube URL: https://www.youtube.com/watch?v=G4GQIbzMfjU


