Title: Functional Programming with Effects by Rob Norris
Publication date: 2018-09-22
Playlist: Scala Days New York 2018
Description: 
	This video was recorded at Scala Days New York 2018
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

More information and the abstract can be found here:
https://na.scaladays.org/schedule/functional-programming-with-effects
Captions: 
	00:00:04,549 --> 00:00:11,990
okay so our goals for today don't panic

00:00:09,650 --> 00:00:13,849
the so I'm gonna go through a lot of

00:00:11,990 --> 00:00:16,640
code today and a lot of code

00:00:13,849 --> 00:00:20,090
manipulation and drive a lot of ideas

00:00:16,640 --> 00:00:22,310
from first principles so the goal is not

00:00:20,090 --> 00:00:23,779
to follow every single step that I make

00:00:22,310 --> 00:00:27,199
but to understand that what we're doing

00:00:23,779 --> 00:00:28,759
is very systematic and there's a big

00:00:27,199 --> 00:00:32,300
picture that all this stuff fits into

00:00:28,759 --> 00:00:33,290
and it all sort of clicks together once

00:00:32,300 --> 00:00:36,230
you understand how to take the

00:00:33,290 --> 00:00:38,000
individual steps the more you learn

00:00:36,230 --> 00:00:40,309
about this stuff the more directions you

00:00:38,000 --> 00:00:42,379
hear it coming from the clearer the

00:00:40,309 --> 00:00:46,040
picture will become and you'll start to

00:00:42,379 --> 00:00:46,940
be able to fill in stuff on your own we

00:00:46,040 --> 00:00:48,290
want to understand what functional

00:00:46,940 --> 00:00:50,900
programming is and we'll spend a lot of

00:00:48,290 --> 00:00:52,129
time talking about that gained some

00:00:50,900 --> 00:00:53,900
insight into the way functional

00:00:52,129 --> 00:00:58,070
programmers think about things and

00:00:53,900 --> 00:01:00,019
that's important you know the mechanical

00:00:58,070 --> 00:01:01,640
aspects the technical aspects of

00:01:00,019 --> 00:01:03,379
functional programming are not hard I

00:01:01,640 --> 00:01:05,540
mean they're they're almost by

00:01:03,379 --> 00:01:07,520
definition very simple but learning how

00:01:05,540 --> 00:01:09,380
to apply them to different situations is

00:01:07,520 --> 00:01:11,359
hard and it's just helpful sometimes to

00:01:09,380 --> 00:01:13,340
just see somebody manipulating code like

00:01:11,359 --> 00:01:16,119
a functional programmer would to get

00:01:13,340 --> 00:01:18,770
into the sort of the swing of things

00:01:16,119 --> 00:01:19,969
understand why monads are useful and

00:01:18,770 --> 00:01:22,280
where they come from so this is a talk

00:01:19,969 --> 00:01:24,249
about monads if you already know

00:01:22,280 --> 00:01:28,310
everything there is to know about monads

00:01:24,249 --> 00:01:29,539
if this is too easy for you or if it's

00:01:28,310 --> 00:01:32,600
too hard for you or you're not

00:01:29,539 --> 00:01:34,310
interesting for whatever reason there

00:01:32,600 --> 00:01:36,049
are two other really good talks going on

00:01:34,310 --> 00:01:37,509
right now so if you if you decide to

00:01:36,049 --> 00:01:40,789
change rooms I will not be offended

00:01:37,509 --> 00:01:42,759
we're here to learn so let's be sure we

00:01:40,789 --> 00:01:45,890
keep doing it

00:01:42,759 --> 00:01:47,090
and I want everybody to be inspired to

00:01:45,890 --> 00:01:49,399
be curious about functional programming

00:01:47,090 --> 00:01:50,539
umm this stuff is interesting and it's

00:01:49,399 --> 00:01:52,159
fun and it will make you a better

00:01:50,539 --> 00:01:54,499
programmer if you learn it even if you

00:01:52,159 --> 00:01:57,729
don't use it every day it's a helpful

00:01:54,499 --> 00:01:57,729
way to think about things

00:01:58,410 --> 00:02:04,510
okay so people are interested in the

00:02:02,860 --> 00:02:06,160
kind of work that I do I get a lot of

00:02:04,510 --> 00:02:08,110
questions about it so I'm going to share

00:02:06,160 --> 00:02:10,479
some pictures with you today

00:02:08,110 --> 00:02:13,150
from work so all the pictures that I'm

00:02:10,479 --> 00:02:16,510
going to show you where we're we're

00:02:13,150 --> 00:02:17,740
taken by by our telescopes will start

00:02:16,510 --> 00:02:21,150
nearby this is the Gemini North

00:02:17,740 --> 00:02:24,100
telescope it's on Mauna Kea in Hawaii

00:02:21,150 --> 00:02:26,170
it's about five thousand miles from here

00:02:24,100 --> 00:02:28,770
our southern telescope is in chill it's

00:02:26,170 --> 00:02:31,860
about five thousand miles south of here

00:02:28,770 --> 00:02:34,330
the software that I work on helps

00:02:31,860 --> 00:02:36,820
astronomers use these amazingly

00:02:34,330 --> 00:02:38,140
complicated machines to do science and

00:02:36,820 --> 00:02:41,230
we have a really small team we have a

00:02:38,140 --> 00:02:43,020
lot of software and we have found that

00:02:41,230 --> 00:02:45,040
functional programming has dramatically

00:02:43,020 --> 00:02:47,410
increased our code quality and

00:02:45,040 --> 00:02:50,670
maintainability and it's a lot more fun

00:02:47,410 --> 00:02:53,200
to I mean it's okay to have fun at work

00:02:50,670 --> 00:02:55,030
so I do this in real life and I really

00:02:53,200 --> 00:02:57,220
believe in it and I'm happy to help

00:02:55,030 --> 00:03:00,100
people who are interested in learning so

00:02:57,220 --> 00:03:03,630
I'm easy to find as I said reach out and

00:03:00,100 --> 00:03:03,630
talk to me if this stuff interests you

00:03:03,959 --> 00:03:09,480
alright let's talk about functional

00:03:06,489 --> 00:03:14,410
programming what is it

00:03:09,480 --> 00:03:18,220
so at the very bottom we just have

00:03:14,410 --> 00:03:18,820
values we have things and because this

00:03:18,220 --> 00:03:20,590
is Scala

00:03:18,820 --> 00:03:22,390
it's a typed language we classify them

00:03:20,590 --> 00:03:25,300
into different types and we can think of

00:03:22,390 --> 00:03:27,340
types of sets so in type theory we

00:03:25,300 --> 00:03:32,380
typically just treat types the same way

00:03:27,340 --> 00:03:34,959
that we treat treat sets and then we

00:03:32,380 --> 00:03:36,640
have functions that map values from one

00:03:34,959 --> 00:03:38,140
type to another and notice this is a

00:03:36,640 --> 00:03:40,959
mathematical function that I'm talking

00:03:38,140 --> 00:03:44,350
about it Maps every value in a to some

00:03:40,959 --> 00:03:46,840
value over in B okay exactly one value

00:03:44,350 --> 00:03:48,700
of R in B it's not necessarily clear

00:03:46,840 --> 00:03:51,040
from the picture but that's all the

00:03:48,700 --> 00:03:52,570
function does okay it doesn't increment

00:03:51,040 --> 00:03:55,120
a counter doesn't check the system clock

00:03:52,570 --> 00:03:56,890
it doesn't write to a file a function is

00:03:55,120 --> 00:03:59,860
a mapping from values to values and

00:03:56,890 --> 00:04:02,820
that's it so let's preserve some things

00:03:59,860 --> 00:04:02,820
about this

00:04:05,360 --> 00:04:09,980
so functions like this are said to be

00:04:07,250 --> 00:04:12,610
pure and the output is determined

00:04:09,980 --> 00:04:15,170
entirely by the input and nothing else

00:04:12,610 --> 00:04:17,239
and consequences of programming in this

00:04:15,170 --> 00:04:18,709
way are that evaluating expression will

00:04:17,239 --> 00:04:20,620
always give you the same answer no

00:04:18,709 --> 00:04:23,840
matter how many times you're evaluated

00:04:20,620 --> 00:04:25,850
so that means that we can always inline

00:04:23,840 --> 00:04:27,830
a function call and then we can always

00:04:25,850 --> 00:04:29,630
factor one out because we know it

00:04:27,830 --> 00:04:31,130
doesn't matter how many times we

00:04:29,630 --> 00:04:33,770
evaluate it it's always going to give us

00:04:31,130 --> 00:04:36,320
the same answer and more generally we

00:04:33,770 --> 00:04:39,620
can always substitute a variable for the

00:04:36,320 --> 00:04:42,410
expression it's bound to so we can we

00:04:39,620 --> 00:04:44,600
can factor out any common sub-expression

00:04:42,410 --> 00:04:46,190
or we can inline any variable to what

00:04:44,600 --> 00:04:48,410
it's bound to and this property this

00:04:46,190 --> 00:04:51,080
ability to do this two expressions is

00:04:48,410 --> 00:04:55,130
called referential transparency so let's

00:04:51,080 --> 00:04:57,320
look at some examples of that so the

00:04:55,130 --> 00:05:00,050
question here is are these programs the

00:04:57,320 --> 00:05:01,820
same we have a valet that's bound to

00:05:00,050 --> 00:05:04,580
some expression and then we compute the

00:05:01,820 --> 00:05:06,320
pair of a and the second one has just in

00:05:04,580 --> 00:05:08,120
line to a and we're computing that

00:05:06,320 --> 00:05:11,510
expression two times and the question is

00:05:08,120 --> 00:05:12,710
are those the same program and the key

00:05:11,510 --> 00:05:14,380
observation is that in functional

00:05:12,710 --> 00:05:18,110
programming the answer is always yes

00:05:14,380 --> 00:05:19,760
they're always the same program okay and

00:05:18,110 --> 00:05:21,919
ultimately the benefits of functional

00:05:19,760 --> 00:05:23,840
programming all flow from that fact

00:05:21,919 --> 00:05:26,990
everything we do is built on this

00:05:23,840 --> 00:05:28,640
ability to perform substitutions we can

00:05:26,990 --> 00:05:31,070
manipulate our problems our programs

00:05:28,640 --> 00:05:32,870
symbolically like mathematical objects

00:05:31,070 --> 00:05:36,830
without fear of accidentally changing

00:05:32,870 --> 00:05:38,000
what our program does but in general

00:05:36,830 --> 00:05:41,300
depends

00:05:38,000 --> 00:05:43,280
this is Scala and we have side effects

00:05:41,300 --> 00:05:46,700
in Scala so let's let's look at some

00:05:43,280 --> 00:05:48,800
more examples what about this program

00:05:46,700 --> 00:05:51,380
where a is 42 are these two programs the

00:05:48,800 --> 00:05:54,830
same what do you think yeah I think they

00:05:51,380 --> 00:05:58,190
are what about this one are these

00:05:54,830 --> 00:05:59,930
programs the same no all right one of

00:05:58,190 --> 00:06:01,880
them prints hi once and the other prints

00:05:59,930 --> 00:06:04,000
height why so you can't swap one for the

00:06:01,880 --> 00:06:04,000
other

00:06:04,330 --> 00:06:09,760
what about this one we're giving an

00:06:05,980 --> 00:06:12,850
iterator and you're calling next no no

00:06:09,760 --> 00:06:14,590
all right so the second one advances the

00:06:12,850 --> 00:06:17,490
iterator twice there's internal state

00:06:14,590 --> 00:06:21,400
that's being changed when you call next

00:06:17,490 --> 00:06:22,350
what about this one this one's a little

00:06:21,400 --> 00:06:26,020
trickier

00:06:22,350 --> 00:06:27,880
listen depends this is pure as long as

00:06:26,020 --> 00:06:29,950
he never mutate the result is never as

00:06:27,880 --> 00:06:32,050
long as you don't mutate the array in

00:06:29,950 --> 00:06:33,580
some other part of your program it but

00:06:32,050 --> 00:06:35,350
if you do have code later on that

00:06:33,580 --> 00:06:36,850
mutates one and not the other then you

00:06:35,350 --> 00:06:39,070
can detect the difference between these

00:06:36,850 --> 00:06:41,590
two programs so there's some subtlety to

00:06:39,070 --> 00:06:43,300
it and in Scala you have to be careful

00:06:41,590 --> 00:06:46,240
and you have to think about things the

00:06:43,300 --> 00:06:49,690
compiler doesn't help us a lot so let's

00:06:46,240 --> 00:06:51,160
review this real fast ever expression

00:06:49,690 --> 00:06:52,930
your program is either referentially

00:06:51,160 --> 00:06:56,080
transparent it has the substitutability

00:06:52,930 --> 00:06:58,450
property or it's not and if it's not we

00:06:56,080 --> 00:07:00,490
call it a side-effect it's either one or

00:06:58,450 --> 00:07:03,550
the other every expression so this is a

00:07:00,490 --> 00:07:05,560
syntactic property of your programs okay

00:07:03,550 --> 00:07:07,360
so saying something as a side-effect is

00:07:05,560 --> 00:07:08,860
really kind of an indirect statement

00:07:07,360 --> 00:07:12,160
about runtime behavior what we're really

00:07:08,860 --> 00:07:14,800
talking about is whether this inlining

00:07:12,160 --> 00:07:16,390
and factoring out substitution is legal

00:07:14,800 --> 00:07:19,210
or not and if you think about

00:07:16,390 --> 00:07:21,280
side-effects in those terms I think it's

00:07:19,210 --> 00:07:22,600
pretty easy to see looking at a piece of

00:07:21,280 --> 00:07:24,730
code whether something as a side-effect

00:07:22,600 --> 00:07:26,650
or not instead of trying to think about

00:07:24,730 --> 00:07:28,420
what the program is doing just say are

00:07:26,650 --> 00:07:31,210
these the same program under this

00:07:28,420 --> 00:07:33,130
transformation and we care about

00:07:31,210 --> 00:07:34,390
substitution rules for expressions

00:07:33,130 --> 00:07:37,030
because in functional programming this

00:07:34,390 --> 00:07:38,650
is the world we live in we are out of

00:07:37,030 --> 00:07:42,730
the world of statements we're in the

00:07:38,650 --> 00:07:45,430
world of expressions functional programs

00:07:42,730 --> 00:07:48,220
are expressions running a functional

00:07:45,430 --> 00:07:51,300
program is the process of reducing a

00:07:48,220 --> 00:07:53,590
evaluating expression to get an answer

00:07:51,300 --> 00:07:56,410
we reason about our program is by

00:07:53,590 --> 00:07:57,640
substitution and by reasoning I mean the

00:07:56,410 --> 00:07:59,980
same way we would reason about a

00:07:57,640 --> 00:08:01,840
mathematical expression we move things

00:07:59,980 --> 00:08:05,290
around mechanically and algebraically

00:08:01,840 --> 00:08:07,420
and then we build larger programs from

00:08:05,290 --> 00:08:10,120
smaller ones by composing them together

00:08:07,420 --> 00:08:11,980
ok and because the only thing we have

00:08:10,120 --> 00:08:13,690
available right now our values and pure

00:08:11,980 --> 00:08:15,559
functions let's talk about function

00:08:13,690 --> 00:08:17,149
composition

00:08:15,559 --> 00:08:19,729
okay so here's the function that we had

00:08:17,149 --> 00:08:23,329
before and now we can introduce another

00:08:19,729 --> 00:08:27,079
function from B to C and we can compose

00:08:23,329 --> 00:08:29,029
them end to end so if we do F and then

00:08:27,079 --> 00:08:35,120
we do G we have a new function called F

00:08:29,029 --> 00:08:38,079
and then G okay so how do we define this

00:08:35,120 --> 00:08:42,110
and then operator in Scala

00:08:38,079 --> 00:08:43,639
so here's how we could define it it's a

00:08:42,110 --> 00:08:45,319
method it has three type parameters it

00:08:43,639 --> 00:08:46,819
takes a function from A to B one from B

00:08:45,319 --> 00:08:49,309
to C and it gives us back a function

00:08:46,819 --> 00:08:53,350
from A to C and the implementation is

00:08:49,309 --> 00:08:55,309
just takes the a and applies G of F of a

00:08:53,350 --> 00:08:56,870
it's very straightforward and in fact

00:08:55,309 --> 00:08:58,939
that's the only way you can write it a

00:08:56,870 --> 00:09:03,589
pure function of this type that will

00:08:58,939 --> 00:09:04,819
type check and because we're in the

00:09:03,589 --> 00:09:06,829
world of expressions and we're thinking

00:09:04,819 --> 00:09:08,480
mathematically we see an operator like

00:09:06,829 --> 00:09:10,430
this we might ask questions about the

00:09:08,480 --> 00:09:14,029
properties of this operation for

00:09:10,430 --> 00:09:15,829
instance is it associative if you have F

00:09:14,029 --> 00:09:17,540
and then G and then H does it matter

00:09:15,829 --> 00:09:21,319
where the parentheses go in that

00:09:17,540 --> 00:09:22,509
expression and if we can show that it

00:09:21,319 --> 00:09:24,740
doesn't matter then we have another

00:09:22,509 --> 00:09:27,740
substitution we can add to our library

00:09:24,740 --> 00:09:29,300
of tools so how do we figure this out

00:09:27,740 --> 00:09:31,309
let's do some equational reasoning

00:09:29,300 --> 00:09:33,170
we'll use the substitution model and

00:09:31,309 --> 00:09:36,230
just expand things out and see what it

00:09:33,170 --> 00:09:39,019
looks like so here's the right

00:09:36,230 --> 00:09:42,319
associative expression so what we'll do

00:09:39,019 --> 00:09:44,899
is we'll inline the and then the outer

00:09:42,319 --> 00:09:47,959
one and then we'll inline the inner one

00:09:44,899 --> 00:09:50,120
and now we have B to H of G of be

00:09:47,959 --> 00:09:53,809
applied to F of a so we can just

00:09:50,120 --> 00:09:56,240
substitute F of a in and we get that and

00:09:53,809 --> 00:09:58,610
that looks right to me let's look at the

00:09:56,240 --> 00:10:00,829
left-hand case well in line the outer

00:09:58,610 --> 00:10:04,579
end then and then the inner one and

00:10:00,829 --> 00:10:07,429
again we have H of this function applied

00:10:04,579 --> 00:10:07,939
to a we can inline a and we get the same

00:10:07,429 --> 00:10:10,309
thing

00:10:07,939 --> 00:10:13,160
okay we've proved it we proved that

00:10:10,309 --> 00:10:14,870
function composition is associative by

00:10:13,160 --> 00:10:20,809
doing this reduction and coming out with

00:10:14,870 --> 00:10:22,100
the same the same program and we can do

00:10:20,809 --> 00:10:23,660
the substitution now anywhere in our

00:10:22,100 --> 00:10:25,370
program right purity gives us this

00:10:23,660 --> 00:10:26,899
ability to inline in fact our things out

00:10:25,370 --> 00:10:29,390
and we can use it to drive new

00:10:26,899 --> 00:10:30,710
substitutions that we can use later on

00:10:29,390 --> 00:10:34,030
and this is where FB becomes really

00:10:30,710 --> 00:10:36,890
powerful what else can we ask about this

00:10:34,030 --> 00:10:37,940
it's a binary operator so maybe it has

00:10:36,890 --> 00:10:40,820
an identity

00:10:37,940 --> 00:10:41,990
so maybe my conjecture here is that if

00:10:40,820 --> 00:10:43,760
we have a function that does nothing but

00:10:41,990 --> 00:10:46,400
return what you give it you can compose

00:10:43,760 --> 00:10:47,840
it with any other function and the net

00:10:46,400 --> 00:10:51,110
effect will be you haven't done anything

00:10:47,840 --> 00:10:54,370
so let's try that so we have this ID

00:10:51,110 --> 00:10:56,360
method that takes a value and returns it

00:10:54,370 --> 00:10:59,240
let's see if it's an identity on the

00:10:56,360 --> 00:11:05,060
right so we in line and then we in line

00:10:59,240 --> 00:11:07,970
ID we we apply it to f of a so a to f of

00:11:05,060 --> 00:11:11,150
a is just F so right identity works and

00:11:07,970 --> 00:11:13,700
similarly we can inline left identity

00:11:11,150 --> 00:11:15,890
and also get F in case we have this

00:11:13,700 --> 00:11:17,720
other substitution a pair of them if you

00:11:15,890 --> 00:11:20,000
compose with the identity function on

00:11:17,720 --> 00:11:21,910
either end you can just forget that

00:11:20,000 --> 00:11:23,540
you've done it and get rid of that

00:11:21,910 --> 00:11:28,310
composition because it doesn't do

00:11:23,540 --> 00:11:30,380
anything okay so now we have functions

00:11:28,310 --> 00:11:32,420
between types we have an associative

00:11:30,380 --> 00:11:35,150
composition operator with an identity

00:11:32,420 --> 00:11:37,160
function at each type okay and we've

00:11:35,150 --> 00:11:39,560
proved that it's true by function or by

00:11:37,160 --> 00:11:41,720
by by the definition of function

00:11:39,560 --> 00:11:43,400
composition because there's only one way

00:11:41,720 --> 00:11:46,550
to write it all of this follows from the

00:11:43,400 --> 00:11:48,080
types which is cool so it turns out

00:11:46,550 --> 00:11:50,870
there's a mathematical structure that

00:11:48,080 --> 00:11:54,140
describes the situation exactly it's

00:11:50,870 --> 00:11:57,200
called a category ok category has four

00:11:54,140 --> 00:12:00,500
things as objects in this case they're

00:11:57,200 --> 00:12:03,290
Scala types it has arrows or morphisms

00:12:00,500 --> 00:12:04,970
in this case they're pure functions it

00:12:03,290 --> 00:12:07,760
has an associative composition operator

00:12:04,970 --> 00:12:09,920
which is our and then operator and it

00:12:07,760 --> 00:12:11,690
has identity arrows at each object which

00:12:09,920 --> 00:12:13,520
we've defined by our polymorphic ID

00:12:11,690 --> 00:12:17,060
function that gives us an identity

00:12:13,520 --> 00:12:19,730
function for every type okay well right

00:12:17,060 --> 00:12:22,730
why do we care it just it turns out that

00:12:19,730 --> 00:12:24,530
mathematics is useful so by identifying

00:12:22,730 --> 00:12:26,330
these connections between types and

00:12:24,530 --> 00:12:27,650
programs and mathematical structures

00:12:26,330 --> 00:12:31,970
we've been able to do a lot of really

00:12:27,650 --> 00:12:34,310
cool stuff in NFP and I think one of the

00:12:31,970 --> 00:12:36,620
benefits of programming this way is that

00:12:34,310 --> 00:12:39,080
the connections with mathematics are

00:12:36,620 --> 00:12:41,270
much more apparent the gap between

00:12:39,080 --> 00:12:42,510
theory and practice is quite narrow we

00:12:41,270 --> 00:12:45,360
can apply these ideas

00:12:42,510 --> 00:12:46,440
very directly and this is where we

00:12:45,360 --> 00:12:48,570
started to see the benefits of

00:12:46,440 --> 00:12:50,040
functional programming we can be more

00:12:48,570 --> 00:12:52,650
confident that our programs are correct

00:12:50,040 --> 00:12:56,580
because we can say very precisely what

00:12:52,650 --> 00:12:58,410
things mean and then we can refactor

00:12:56,580 --> 00:13:00,210
confidently because we have these

00:12:58,410 --> 00:13:01,710
transformations that we can perform on

00:13:00,210 --> 00:13:03,330
our code that we know will not change

00:13:01,710 --> 00:13:05,730
what the program does it might make it

00:13:03,330 --> 00:13:07,110
easier to read or more efficient but it

00:13:05,730 --> 00:13:09,240
won't change the values that are

00:13:07,110 --> 00:13:11,310
computed so that's very powerful and

00:13:09,240 --> 00:13:13,110
that's kind of the value proposition for

00:13:11,310 --> 00:13:14,730
functional programming it helps our

00:13:13,110 --> 00:13:16,860
programs start off correct and stay

00:13:14,730 --> 00:13:20,900
correct as they evolve the second point

00:13:16,860 --> 00:13:24,060
is much more important in my in my mind

00:13:20,900 --> 00:13:25,770
so but in exchange for what we've just

00:13:24,060 --> 00:13:28,830
done we lost a huge amount of

00:13:25,770 --> 00:13:32,250
expressiveness right it's a much weaker

00:13:28,830 --> 00:13:34,620
language to describe our programs so how

00:13:32,250 --> 00:13:38,460
do we square this with with what happens

00:13:34,620 --> 00:13:40,020
in the real world so partiality

00:13:38,460 --> 00:13:41,820
functions always have to return an

00:13:40,020 --> 00:13:43,440
answer and we don't always do that in

00:13:41,820 --> 00:13:45,920
Java you might return null or something

00:13:43,440 --> 00:13:48,420
right sometimes there are exceptions

00:13:45,920 --> 00:13:50,610
sometimes we can't compute a value and

00:13:48,420 --> 00:13:53,760
we have a reason why we can't the we

00:13:50,610 --> 00:13:56,100
encoding and an exception functions can

00:13:53,760 --> 00:14:00,630
only return one answer but sometimes you

00:13:56,100 --> 00:14:03,870
can compute multiple answers things like

00:14:00,630 --> 00:14:07,350
things like dependency injection you

00:14:03,870 --> 00:14:10,140
have this non-local scope that can

00:14:07,350 --> 00:14:11,670
inject things that that will change the

00:14:10,140 --> 00:14:15,980
behavior or they'll affect the behavior

00:14:11,670 --> 00:14:18,900
of your functions and doing that

00:14:15,980 --> 00:14:20,760
prevents you from reasoning locally so

00:14:18,900 --> 00:14:23,130
that's a problem but it's useful so how

00:14:20,760 --> 00:14:24,480
do we deal with that logging for

00:14:23,130 --> 00:14:26,490
instance it's a side effect the whole

00:14:24,480 --> 00:14:27,990
point is to tell you about when things

00:14:26,490 --> 00:14:29,430
are happening but in functional

00:14:27,990 --> 00:14:30,450
programming this we don't care when

00:14:29,430 --> 00:14:35,250
things happen

00:14:30,450 --> 00:14:35,850
we're just computing values so what do

00:14:35,250 --> 00:14:38,610
we do about that

00:14:35,850 --> 00:14:39,930
immutable state obviously there there

00:14:38,610 --> 00:14:41,730
are a lot of things that are just easier

00:14:39,930 --> 00:14:44,690
to express in terms of mutable state an

00:14:41,730 --> 00:14:47,430
imperative programming generally

00:14:44,690 --> 00:14:49,560
sometimes it's easier just to say do

00:14:47,430 --> 00:14:52,170
this do this do this do this and not

00:14:49,560 --> 00:14:52,990
think about things in terms of chains

00:14:52,170 --> 00:14:56,590
and

00:14:52,990 --> 00:14:58,150
branching function calls so how do we

00:14:56,590 --> 00:14:59,440
recover this expressiveness and that's

00:14:58,150 --> 00:15:05,670
that's really what I want to talk about

00:14:59,440 --> 00:15:08,530
today so let's take a little pause

00:15:05,670 --> 00:15:09,760
there's some pictures from work does

00:15:08,530 --> 00:15:13,870
anybody want to guess what we're looking

00:15:09,760 --> 00:15:17,350
at this is IO it's one of the moons of

00:15:13,870 --> 00:15:19,450
Jupiter and it is violently volcanic all

00:15:17,350 --> 00:15:22,930
those flares you see are either volcanic

00:15:19,450 --> 00:15:25,300
eruptions or lava lakes and the the big

00:15:22,930 --> 00:15:27,880
lava lake in the middle of the larger

00:15:25,300 --> 00:15:29,590
images is so big they give it a name

00:15:27,880 --> 00:15:33,450
they call it Loki which is pretty cool

00:15:29,590 --> 00:15:40,750
and this is all happening right now

00:15:33,450 --> 00:15:42,880
about 390 million miles from here okay

00:15:40,750 --> 00:15:44,740
where are we we have a programming model

00:15:42,880 --> 00:15:46,630
with pure functions and function

00:15:44,740 --> 00:15:48,070
composition and we know how to reason

00:15:46,630 --> 00:15:49,570
about that we've done some reasoning

00:15:48,070 --> 00:15:50,890
with it and we're comfortable with it

00:15:49,570 --> 00:15:52,750
we've left behind a lot of

00:15:50,890 --> 00:15:56,260
expressiveness that we would get in Java

00:15:52,750 --> 00:15:58,420
or Python or or whatever and the way we

00:15:56,260 --> 00:16:01,180
recover this expressiveness is by using

00:15:58,420 --> 00:16:03,370
effects okay and effect is kind of a

00:16:01,180 --> 00:16:04,630
vague term it's okay we're kind of

00:16:03,370 --> 00:16:07,410
trying to describe something that's

00:16:04,630 --> 00:16:10,990
outside what the language can talk about

00:16:07,410 --> 00:16:12,700
and it should say if there's one thing

00:16:10,990 --> 00:16:14,410
you take away today it's that effects

00:16:12,700 --> 00:16:16,120
and side effects are not the same thing

00:16:14,410 --> 00:16:18,190
it's unfortunate they sound the same

00:16:16,120 --> 00:16:20,140
effects are good and side effects are

00:16:18,190 --> 00:16:22,720
bugs so just remember that and you'll

00:16:20,140 --> 00:16:25,210
you'll be okay so what I want to do is

00:16:22,720 --> 00:16:27,130
talk about the six effects that you sort

00:16:25,210 --> 00:16:28,870
of learn there's sort of the first six

00:16:27,130 --> 00:16:30,070
that you put in your toolbox when you

00:16:28,870 --> 00:16:32,530
learn functional programming

00:16:30,070 --> 00:16:34,090
there are a ton more and there are lots

00:16:32,530 --> 00:16:36,250
of ways to classify them but we'll start

00:16:34,090 --> 00:16:38,190
off with the the basic ones that you'll

00:16:36,250 --> 00:16:39,940
get a lot of mileage out of immediately

00:16:38,190 --> 00:16:42,310
what we're gonna do is we're gonna look

00:16:39,940 --> 00:16:44,590
at six effects and talk about what they

00:16:42,310 --> 00:16:47,380
mean and what they have in common and

00:16:44,590 --> 00:16:48,880
we'll try to reach a description that's

00:16:47,380 --> 00:16:51,090
very precise about what they have in

00:16:48,880 --> 00:16:51,090
common

00:16:51,120 --> 00:16:56,350
all right so let's talk about option

00:16:53,259 --> 00:16:58,420
we're all Scala programmers we know

00:16:56,350 --> 00:17:00,070
about option there are two cases

00:16:58,420 --> 00:17:05,020
you either have none or you have some

00:17:00,070 --> 00:17:07,419
value and if you have functions like F

00:17:05,020 --> 00:17:08,860
and G the intuition there is what we're

00:17:07,419 --> 00:17:12,189
encoding is functions that might not

00:17:08,860 --> 00:17:14,559
return a value okay it encodes this

00:17:12,189 --> 00:17:17,049
notion of partiality so we get that

00:17:14,559 --> 00:17:19,750
expressiveness back by computing values

00:17:17,049 --> 00:17:22,390
in option the problem is we can't

00:17:19,750 --> 00:17:26,559
compose those functions together anymore

00:17:22,390 --> 00:17:29,830
what we would want is if you have an 8

00:17:26,559 --> 00:17:31,480
and option B and a B to option C and you

00:17:29,830 --> 00:17:33,040
give it an if you were able to compose

00:17:31,480 --> 00:17:35,169
them together and give it an a you

00:17:33,040 --> 00:17:37,330
either get a C out if everything went

00:17:35,169 --> 00:17:38,980
okay along the way or you get none if

00:17:37,330 --> 00:17:40,900
there was something that couldn't be

00:17:38,980 --> 00:17:42,160
computed along the way if you could

00:17:40,900 --> 00:17:43,799
somehow compose those effects together

00:17:42,160 --> 00:17:49,350
but we don't have a way to do that so

00:17:43,799 --> 00:17:51,790
let's go on everybody has seen either

00:17:49,350 --> 00:17:52,929
it's another very common type from

00:17:51,790 --> 00:17:54,250
standard library we either have

00:17:52,929 --> 00:17:58,270
something on the left or something on

00:17:54,250 --> 00:17:59,490
the right it's very similar to option

00:17:58,270 --> 00:18:02,230
but the intuition is we have

00:17:59,490 --> 00:18:04,960
computations that can give us a reason

00:18:02,230 --> 00:18:07,570
why they don't didn't compute a value so

00:18:04,960 --> 00:18:10,690
this gives us this notion of exceptions

00:18:07,570 --> 00:18:13,270
back and if we were able to compose F

00:18:10,690 --> 00:18:15,730
and G together the idea is either we

00:18:13,270 --> 00:18:18,460
would get our C out if everything worked

00:18:15,730 --> 00:18:19,960
okay or we would get an error back on

00:18:18,460 --> 00:18:22,210
the left hand side and we would get the

00:18:19,960 --> 00:18:25,210
first error that was encountered in

00:18:22,210 --> 00:18:26,890
during evaluation because as soon as

00:18:25,210 --> 00:18:28,240
there's an error you don't have a value

00:18:26,890 --> 00:18:31,059
to pass on to the next function that

00:18:28,240 --> 00:18:32,470
you've composed okay but we can't do

00:18:31,059 --> 00:18:37,390
that we don't we don't have the means to

00:18:32,470 --> 00:18:41,950
compose these functions intend yet let's

00:18:37,390 --> 00:18:43,929
talk about lists so this is an inductive

00:18:41,950 --> 00:18:46,210
data type it has an empty case and then

00:18:43,929 --> 00:18:47,919
a case where you have a head followed by

00:18:46,210 --> 00:18:52,360
a list and I think everybody's probably

00:18:47,919 --> 00:18:53,320
seen lists in in Scala the intuition we

00:18:52,360 --> 00:18:57,010
have a functional programming is a

00:18:53,320 --> 00:18:58,690
little different than the way you might

00:18:57,010 --> 00:19:00,130
normally think about lists it's a way to

00:18:58,690 --> 00:19:00,750
think about a kind of non determinism

00:19:00,130 --> 00:19:03,990
where you can

00:19:00,750 --> 00:19:08,190
a function that can produce many answers

00:19:03,990 --> 00:19:10,470
and if we were to compose these together

00:19:08,190 --> 00:19:12,690
and to end if we were able to what you

00:19:10,470 --> 00:19:15,300
would get if you have the ADA list be

00:19:12,690 --> 00:19:17,820
composed with G list with Vito list see

00:19:15,300 --> 00:19:19,890
you get every possible seeding that

00:19:17,820 --> 00:19:21,720
could be computed from those two

00:19:19,890 --> 00:19:24,110
functions so the computations that you

00:19:21,720 --> 00:19:26,910
perform with lists sort of give you a

00:19:24,110 --> 00:19:30,030
just every possible universe of answers

00:19:26,910 --> 00:19:34,680
back but we don't know how to do that

00:19:30,030 --> 00:19:36,630
yet okay let's talk about reader this is

00:19:34,680 --> 00:19:39,390
a new type for a lot of you probably but

00:19:36,630 --> 00:19:42,390
it's a very simple type we just have a

00:19:39,390 --> 00:19:44,460
we'll call it in its it's just a wrapper

00:19:42,390 --> 00:19:48,210
for a function from some environment

00:19:44,460 --> 00:19:49,920
type e to an answer a and so if we have

00:19:48,210 --> 00:19:52,740
a function that goes from a to reader of

00:19:49,920 --> 00:19:56,700
config B the intuition there is that

00:19:52,740 --> 00:19:59,520
we're we're computing a computation

00:19:56,700 --> 00:20:01,800
that's dependent on on some value that

00:19:59,520 --> 00:20:05,370
we don't have yet so let's show it looks

00:20:01,800 --> 00:20:07,740
like an example of that so we have this

00:20:05,370 --> 00:20:10,040
path method it takes a string and what

00:20:07,740 --> 00:20:12,930
it returns is a reader of host to string

00:20:10,040 --> 00:20:16,920
and when it once it gets the host it can

00:20:12,930 --> 00:20:18,630
construct our URL so the the the idea

00:20:16,920 --> 00:20:21,920
there is that this computation is

00:20:18,630 --> 00:20:24,120
something that is awaiting awaiting a

00:20:21,920 --> 00:20:25,770
configuration to be passed in before it

00:20:24,120 --> 00:20:28,110
can finish its work so what this gives

00:20:25,770 --> 00:20:29,910
us is dependency injection okay we have

00:20:28,110 --> 00:20:31,650
a computation it's all ready to go but

00:20:29,910 --> 00:20:34,070
you've got to give it the the

00:20:31,650 --> 00:20:37,260
configuration before it can actually

00:20:34,070 --> 00:20:39,120
compute its answer okay and if we had

00:20:37,260 --> 00:20:43,080
two functions like this composed end to

00:20:39,120 --> 00:20:47,640
end the idea was would be you would get

00:20:43,080 --> 00:20:49,770
an a2 reader of config C and you compute

00:20:47,640 --> 00:20:51,210
that and then you pass in the config and

00:20:49,770 --> 00:20:52,740
it gets piped through all your

00:20:51,210 --> 00:20:56,340
computations and everybody gets to see

00:20:52,740 --> 00:21:01,410
it on the way to computing a C but again

00:20:56,340 --> 00:21:04,110
we can't compute that if there's a

00:21:01,410 --> 00:21:05,580
reader there's got to be a writer I'm

00:21:04,110 --> 00:21:07,980
actually going to skip writer in the

00:21:05,580 --> 00:21:10,379
interest of time it's not super

00:21:07,980 --> 00:21:13,239
interesting

00:21:10,379 --> 00:21:14,529
because I want to talk about state this

00:21:13,239 --> 00:21:17,559
is the hard one and it's a really

00:21:14,529 --> 00:21:21,309
interesting one so state is another

00:21:17,559 --> 00:21:23,739
wrapper around a function what it does

00:21:21,309 --> 00:21:26,799
is it takes some input state and it

00:21:23,739 --> 00:21:36,909
computes an answer a and also a new

00:21:26,799 --> 00:21:38,139
state okay so the idea here is that is

00:21:36,909 --> 00:21:39,999
this if you if you have a state

00:21:38,139 --> 00:21:42,609
transition if you have some some mutable

00:21:39,999 --> 00:21:43,779
computation you can model it as

00:21:42,609 --> 00:21:45,129
something that takes the initial state

00:21:43,779 --> 00:21:46,899
does something and returns the answer

00:21:45,129 --> 00:21:48,549
along with the new state and you pass

00:21:46,899 --> 00:21:50,649
that new state along to the next company

00:21:48,549 --> 00:21:52,509
computation and that's what our notion

00:21:50,649 --> 00:21:55,029
of composition would be like and we can

00:21:52,509 --> 00:21:57,369
look at an example of that we have this

00:21:55,029 --> 00:22:00,129
greet method that takes somebody's name

00:21:57,369 --> 00:22:02,320
and returns a state of a counter and a

00:22:00,129 --> 00:22:04,960
string so what it does is it will greet

00:22:02,320 --> 00:22:07,090
the person and tell you how many people

00:22:04,960 --> 00:22:11,019
have been greeted and it will return the

00:22:07,090 --> 00:22:12,879
new updated count so we can create that

00:22:11,019 --> 00:22:14,559
computation and we can run it with an

00:22:12,879 --> 00:22:17,019
initial value of 1 or initial value of

00:22:14,559 --> 00:22:21,249
20 and we get the string back and in the

00:22:17,019 --> 00:22:23,019
new state in a pair if we were able to

00:22:21,249 --> 00:22:24,820
compose them we would be able to thread

00:22:23,019 --> 00:22:29,169
this state throughout our computation

00:22:24,820 --> 00:22:33,429
and it would be entirely excellent but

00:22:29,169 --> 00:22:35,200
we can't do it we don't know how so the

00:22:33,429 --> 00:22:37,090
question here is what all these effects

00:22:35,200 --> 00:22:39,460
have in common they look they look quite

00:22:37,090 --> 00:22:41,909
different but all of them compute some

00:22:39,460 --> 00:22:45,179
answer and there's some ancillary stuff

00:22:41,909 --> 00:22:47,229
there's just some extra kind of

00:22:45,179 --> 00:22:49,570
machinery associated with the

00:22:47,229 --> 00:22:52,479
computation and this is what we call an

00:22:49,570 --> 00:22:53,559
effect but it's still very vague so

00:22:52,479 --> 00:22:56,529
let's let's try and be a little more

00:22:53,559 --> 00:22:58,899
precise about it so let's observe all of

00:22:56,529 --> 00:23:03,369
these types have the same shape it's on

00:22:58,899 --> 00:23:05,590
f of a for the types like either or read

00:23:03,369 --> 00:23:07,269
or write or state there's an extra type

00:23:05,590 --> 00:23:11,559
parameter on the left and we just fix it

00:23:07,269 --> 00:23:15,510
to something so reader of config is an

00:23:11,559 --> 00:23:19,690
effect a state of int as in effect

00:23:15,510 --> 00:23:21,280
okay and and kind of the punchline it's

00:23:19,690 --> 00:23:22,930
not very satisfying but in effect is

00:23:21,280 --> 00:23:25,060
whatever distinguishes F of a from a

00:23:22,930 --> 00:23:32,320
it's just that extra machinery that's

00:23:25,060 --> 00:23:35,950
associated with the computation we will

00:23:32,320 --> 00:23:39,220
sometimes say that this is a program in

00:23:35,950 --> 00:23:41,580
F that computes a value of type a so we

00:23:39,220 --> 00:23:43,960
will talk about computations or programs

00:23:41,580 --> 00:23:45,520
and it might seem weird to think of

00:23:43,960 --> 00:23:48,040
something like option of string as a

00:23:45,520 --> 00:23:51,670
program but if you think of something

00:23:48,040 --> 00:23:52,840
like a reader or state that actually has

00:23:51,670 --> 00:23:54,160
a little function that's running inside

00:23:52,840 --> 00:23:56,080
of then it might make more sense to

00:23:54,160 --> 00:23:58,210
think about it as a program but that's a

00:23:56,080 --> 00:24:01,300
good general way a generic way to talk

00:23:58,210 --> 00:24:03,790
about these values but our problem is as

00:24:01,300 --> 00:24:07,060
as we've said they don't compose so what

00:24:03,790 --> 00:24:09,370
we have this function that goes from

00:24:07,060 --> 00:24:13,180
string to option care it just goes and

00:24:09,370 --> 00:24:17,230
tries to find the the character at index

00:24:13,180 --> 00:24:19,540
10 which might fail and then one that

00:24:17,230 --> 00:24:22,360
gives the what does it do it gives the

00:24:19,540 --> 00:24:23,980
the character code if it's a letter

00:24:22,360 --> 00:24:27,400
otherwise it doesn't and we can't

00:24:23,980 --> 00:24:29,700
compose those into end so this is kind

00:24:27,400 --> 00:24:29,700
of an issue

00:24:30,900 --> 00:24:38,380
anybody want to guess what this is no

00:24:35,500 --> 00:24:41,590
guesses there's a Pluto and its moon

00:24:38,380 --> 00:24:46,510
Charon these are the sharpest

00:24:41,590 --> 00:24:49,510
ground-based images ever taken at least

00:24:46,510 --> 00:24:52,330
at the time they were taken and this is

00:24:49,510 --> 00:24:59,080
happening right now about 4.6 billion

00:24:52,330 --> 00:25:01,270
miles from here it's a long way okay so

00:24:59,080 --> 00:25:03,010
what's the problem the issue that we're

00:25:01,270 --> 00:25:05,290
dealing with is that effect full

00:25:03,010 --> 00:25:06,790
function don't compose we've found ways

00:25:05,290 --> 00:25:09,640
to recover a lot of the expressiveness

00:25:06,790 --> 00:25:11,980
that we gave up but we've lost function

00:25:09,640 --> 00:25:13,900
composition in the process so what we're

00:25:11,980 --> 00:25:17,050
gonna try and do is recover that as well

00:25:13,900 --> 00:25:22,720
so let's look at our model of

00:25:17,050 --> 00:25:24,130
composition from simple functions so

00:25:22,720 --> 00:25:26,680
here's our category of Scala types and

00:25:24,130 --> 00:25:29,980
functions and if we understand the

00:25:26,680 --> 00:25:31,390
category rules we understand everything

00:25:29,980 --> 00:25:35,200
there is to say about function

00:25:31,390 --> 00:25:36,670
composition so what we can do is frame

00:25:35,200 --> 00:25:38,230
our question about effects will affect

00:25:36,670 --> 00:25:40,150
all functions and a little in a

00:25:38,230 --> 00:25:42,970
different way let's just say what would

00:25:40,150 --> 00:25:44,770
it take to make the same rules apply to

00:25:42,970 --> 00:25:46,990
effect for functions let's just change

00:25:44,770 --> 00:25:51,940
our diagram so everywhere we have an A

00:25:46,990 --> 00:25:56,050
to B we have an A to F of B so I D is a

00:25:51,940 --> 00:25:57,580
to F of a instead of just a to a and so

00:25:56,050 --> 00:25:59,710
we don't confuse ourselves let's let's

00:25:57,580 --> 00:26:01,420
rename these operations so and then

00:25:59,710 --> 00:26:04,990
we'll become this thing that looks kind

00:26:01,420 --> 00:26:08,530
of like a fish and then I D we've call

00:26:04,990 --> 00:26:10,480
it we rename to pure the intuition there

00:26:08,530 --> 00:26:11,650
is that it takes a value and it turns it

00:26:10,480 --> 00:26:16,060
takes a pure value and it turns it into

00:26:11,650 --> 00:26:17,170
a program that computes that value so

00:26:16,060 --> 00:26:19,390
here's the game the game is we're gonna

00:26:17,170 --> 00:26:21,490
make an eclis write down what this means

00:26:19,390 --> 00:26:24,790
in Scala and just follow the types and

00:26:21,490 --> 00:26:26,590
see and see what we have to do and

00:26:24,790 --> 00:26:28,480
because the behavior depends on a

00:26:26,590 --> 00:26:29,620
particular F we're gonna parameterize

00:26:28,480 --> 00:26:32,560
it's going to be type class

00:26:29,620 --> 00:26:32,980
parameterised on F okay we'll call it

00:26:32,560 --> 00:26:34,840
fishy

00:26:32,980 --> 00:26:37,150
it's parameterised on some type

00:26:34,840 --> 00:26:38,770
constructor F so we have two things that

00:26:37,150 --> 00:26:40,450
we need to implement we have our

00:26:38,770 --> 00:26:42,850
identity a - FA and we have this

00:26:40,450 --> 00:26:46,060
composition operator

00:26:42,850 --> 00:26:47,770
it we can if you look at the the fish

00:26:46,060 --> 00:26:50,620
operator we can actually start to

00:26:47,770 --> 00:26:52,960
implement it we know we have to take an

00:26:50,620 --> 00:26:55,840
A and we have something that we can pass

00:26:52,960 --> 00:26:58,270
the a to so we can say F of a and now we

00:26:55,840 --> 00:27:01,030
have an F of B and a B to F of C and

00:26:58,270 --> 00:27:02,770
what we're on one is an F of C so can

00:27:01,030 --> 00:27:06,370
anybody think of something they've seen

00:27:02,770 --> 00:27:09,370
before that has that signature i'm

00:27:06,370 --> 00:27:14,800
standard library somebody said it flat

00:27:09,370 --> 00:27:16,300
map looks like flat map to me okay so it

00:27:14,800 --> 00:27:17,770
turns out this fish operator is kind of

00:27:16,300 --> 00:27:19,980
something we can derive later and what

00:27:17,770 --> 00:27:26,530
we really need to define is flat map

00:27:19,980 --> 00:27:28,510
okay and we can create for instance a

00:27:26,530 --> 00:27:32,880
implicit class that adds the fish

00:27:28,510 --> 00:27:36,550
operator to affect full functions by

00:27:32,880 --> 00:27:38,920
wrapping a function from A to F of B and

00:27:36,550 --> 00:27:41,110
then adding a method that takes a be def

00:27:38,920 --> 00:27:43,510
of C along with evidence that there's

00:27:41,110 --> 00:27:47,070
fishy behavior for this F and then we

00:27:43,510 --> 00:27:50,140
just delegate to it so that gives us our

00:27:47,070 --> 00:27:51,850
that gives us our fish operator we can

00:27:50,140 --> 00:27:55,120
define an instance of this type class

00:27:51,850 --> 00:27:57,550
for option so we need to define pure and

00:27:55,120 --> 00:27:59,140
we'll just say sum of a is is is our

00:27:57,550 --> 00:28:00,400
implementation of pure and flatmap we'll

00:27:59,140 --> 00:28:03,040
just delegate to standard library

00:28:00,400 --> 00:28:04,810
flatmap and now we go back to our

00:28:03,040 --> 00:28:07,660
functions that don't compose any it

00:28:04,810 --> 00:28:11,440
don't compose with and then but they do

00:28:07,660 --> 00:28:15,130
compose with the fish okay so we've

00:28:11,440 --> 00:28:17,250
solved that problem so we can construct

00:28:15,130 --> 00:28:20,650
this this function and we can apply it

00:28:17,250 --> 00:28:22,900
so we apply it to foo there is no tenth

00:28:20,650 --> 00:28:25,480
there's no character to index ten so we

00:28:22,900 --> 00:28:27,220
get none if we apply it to the longer

00:28:25,480 --> 00:28:30,760
stream with string we get the character

00:28:27,220 --> 00:28:34,120
code for the Z or the another Q I don't

00:28:30,760 --> 00:28:35,590
know which for the U and then if we

00:28:34,120 --> 00:28:38,040
change the you to something's not a

00:28:35,590 --> 00:28:43,080
letter we get none again so the the the

00:28:38,040 --> 00:28:46,630
failure mode exists in both places

00:28:43,080 --> 00:28:48,190
across this composition okay so that's

00:28:46,630 --> 00:28:49,570
cool we have these operations and they

00:28:48,190 --> 00:28:53,440
work but the thing we've forgotten about

00:28:49,570 --> 00:28:55,420
is the rules so here's our diagram again

00:28:53,440 --> 00:28:56,470
and what we've forgotten is category

00:28:55,420 --> 00:28:58,330
laws say

00:28:56,470 --> 00:29:03,310
we need these three things we need left

00:28:58,330 --> 00:29:04,960
identity so pure fishy F has to be F F

00:29:03,310 --> 00:29:08,110
fishy pure has to be F and then

00:29:04,960 --> 00:29:09,730
associativity has to hold those

00:29:08,110 --> 00:29:13,060
compositions have to have to mean the

00:29:09,730 --> 00:29:15,010
same thing so what does this mean in

00:29:13,060 --> 00:29:19,240
terms of flatmap let's expand these out

00:29:15,010 --> 00:29:22,990
and see what we're looking at so pure

00:29:19,240 --> 00:29:24,940
fishy F we'll just inline the

00:29:22,990 --> 00:29:28,840
implementation of fish so it's pure a

00:29:24,940 --> 00:29:31,570
flat map F we can expand the other side

00:29:28,840 --> 00:29:33,280
out to a de FA to kind of the kind of

00:29:31,570 --> 00:29:36,360
matchup where that's just a de expansion

00:29:33,280 --> 00:29:38,410
and then we can we can treat this a as a

00:29:36,360 --> 00:29:40,060
kind of a free variable doesn't matter

00:29:38,410 --> 00:29:41,860
where it comes from so we have this rule

00:29:40,060 --> 00:29:44,500
pure a flat map F has to be the same

00:29:41,860 --> 00:29:46,630
thing as F of a all right let's look at

00:29:44,500 --> 00:29:51,330
the right identity we can expand this

00:29:46,630 --> 00:29:54,250
out in a similar way and then we can

00:29:51,330 --> 00:29:55,960
treat this a as a free variable doesn't

00:29:54,250 --> 00:29:58,240
matter and F of a we can treat is just

00:29:55,960 --> 00:29:59,710
any any free variable so this M flat map

00:29:58,240 --> 00:30:04,540
pure is the same thing as M means if you

00:29:59,710 --> 00:30:07,000
flat map and appear nothing happens left

00:30:04,540 --> 00:30:11,730
associativity same thing we can inline

00:30:07,000 --> 00:30:16,300
the outer one in line the inner one and

00:30:11,730 --> 00:30:18,760
substitute so we get a a flat map G flat

00:30:16,300 --> 00:30:20,760
map H all right and let's look at the

00:30:18,760 --> 00:30:23,860
right side and these have to be the same

00:30:20,760 --> 00:30:27,040
so we can inline the outer one in line

00:30:23,860 --> 00:30:29,320
the inner one substitute okay and now we

00:30:27,040 --> 00:30:32,440
have F of a flat map G flat F H has to

00:30:29,320 --> 00:30:35,740
be the same as F of a flat map B 2 G a B

00:30:32,440 --> 00:30:37,270
flat B so so in Scala this isn't super

00:30:35,740 --> 00:30:39,040
apparent but it's just the associativity

00:30:37,270 --> 00:30:41,320
rules it's just where it's just the

00:30:39,040 --> 00:30:42,400
order in which you do the flat map and

00:30:41,320 --> 00:30:44,950
again we can just treat that as an

00:30:42,400 --> 00:30:47,380
arbitrary value okay so we have these

00:30:44,950 --> 00:30:50,290
three rules that we've come up with just

00:30:47,380 --> 00:30:53,320
by looking at the category laws okay

00:30:50,290 --> 00:30:54,250
and this isn't something arbitrary so

00:30:53,320 --> 00:30:56,410
that's the point I'm trying to get

00:30:54,250 --> 00:30:59,140
across these things followed directly

00:30:56,410 --> 00:31:01,390
from the category laws and they're

00:30:59,140 --> 00:31:03,220
analogous to the rules for just simple

00:31:01,390 --> 00:31:05,800
function composition that we drive to

00:31:03,220 --> 00:31:07,450
the beginning of the talk I will tell

00:31:05,800 --> 00:31:08,650
you what we've been doing the category

00:31:07,450 --> 00:31:09,660
that we've been looking at is called the

00:31:08,650 --> 00:31:11,550
closely-- category

00:31:09,660 --> 00:31:13,260
F so when you hear functional

00:31:11,550 --> 00:31:15,840
programmers talk about closley blah blah

00:31:13,260 --> 00:31:18,270
blah it's just arrows from A to F of

00:31:15,840 --> 00:31:20,940
whatever it's an intimidating name but

00:31:18,270 --> 00:31:24,120
it's it's a very simple idea in order

00:31:20,940 --> 00:31:27,560
for this to be a category F has to have

00:31:24,120 --> 00:31:27,560
this fishy behavior that we've defined

00:31:27,770 --> 00:31:33,660
and this fishy type class that we divide

00:31:30,270 --> 00:31:35,360
it we came up with from nothing is

00:31:33,660 --> 00:31:40,710
called

00:31:35,360 --> 00:31:43,470
monad that's right and remember would

00:31:40,710 --> 00:31:45,810
also drive the Monad laws okay we got

00:31:43,470 --> 00:31:50,220
the whole thing everything you can say

00:31:45,810 --> 00:31:52,290
about monads is on this slide okay and

00:31:50,220 --> 00:31:53,880
it all followed from the rules of

00:31:52,290 --> 00:31:54,900
category theory the rules of composition

00:31:53,880 --> 00:31:57,090
that we learned in the first five

00:31:54,900 --> 00:31:59,250
minutes of talking about category three

00:31:57,090 --> 00:32:00,960
so now you know where they come from

00:31:59,250 --> 00:32:02,940
and you know why they're useful because

00:32:00,960 --> 00:32:09,600
they give us back function composition

00:32:02,940 --> 00:32:11,820
for effect 'fl Fortin to remember or to

00:32:09,600 --> 00:32:13,860
note that unlike the rules for function

00:32:11,820 --> 00:32:17,670
composition which are necessarily true

00:32:13,860 --> 00:32:19,590
from the types the Monad laws and type

00:32:17,670 --> 00:32:21,390
class laws in general do not follow

00:32:19,590 --> 00:32:24,270
directly from the types Scala is not

00:32:21,390 --> 00:32:27,690
expressive enough to do to prove that so

00:32:24,270 --> 00:32:29,520
when we implement a monad instance you

00:32:27,690 --> 00:32:31,110
can't just satisfy the type and call it

00:32:29,520 --> 00:32:35,010
good you have to run tests you have to

00:32:31,110 --> 00:32:36,810
ensure that these laws are met okay in

00:32:35,010 --> 00:32:39,600
Scala we do this by property based

00:32:36,810 --> 00:32:41,160
testing and there's a pretty elaborate

00:32:39,600 --> 00:32:43,200
set up in cats that allows you to do

00:32:41,160 --> 00:32:46,350
that very simply which is which is great

00:32:43,200 --> 00:32:47,880
and Chris Phelps right here has given a

00:32:46,350 --> 00:32:50,280
talk on this and has promised he will

00:32:47,880 --> 00:32:51,870
give it many more times so it's

00:32:50,280 --> 00:32:57,450
something that you it's important to

00:32:51,870 --> 00:33:00,660
learn okay so we have pure and flatmap

00:32:57,450 --> 00:33:02,610
and and something you may remember from

00:33:00,660 --> 00:33:04,140
standard library anyways everything that

00:33:02,610 --> 00:33:05,010
has flatmap always seems to have a map

00:33:04,140 --> 00:33:08,100
too

00:33:05,010 --> 00:33:10,320
so it seems like probably we can add map

00:33:08,100 --> 00:33:12,180
there it turns out that map is defined

00:33:10,320 --> 00:33:14,010
on an even more general abstraction

00:33:12,180 --> 00:33:16,530
called a functor and all monads are

00:33:14,010 --> 00:33:18,270
functors so the structure actually looks

00:33:16,530 --> 00:33:20,670
like this monad extends functor and

00:33:18,270 --> 00:33:21,600
functor has this map operation I don't

00:33:20,670 --> 00:33:23,510
have time to define

00:33:21,600 --> 00:33:27,750
categorically so you'll just have to

00:33:23,510 --> 00:33:29,250
trust me that this is the case but we

00:33:27,750 --> 00:33:31,080
we've already said that we've completely

00:33:29,250 --> 00:33:33,150
defined what monad means so we should be

00:33:31,080 --> 00:33:38,309
able to find map in terms of pure and

00:33:33,150 --> 00:33:41,910
flat map okay and we can so that type

00:33:38,309 --> 00:33:43,830
checks and basically instead of you

00:33:41,910 --> 00:33:47,730
can't you can't flat map F but you can

00:33:43,830 --> 00:33:50,850
flat map F if you lift the result by

00:33:47,730 --> 00:33:52,650
calling by passing it to pure so this

00:33:50,850 --> 00:33:56,070
type checks but is it the right

00:33:52,650 --> 00:34:00,600
implementation we don't know all we know

00:33:56,070 --> 00:34:01,890
that is that a type checks so in the

00:34:00,600 --> 00:34:04,020
same way there was a composition and

00:34:01,890 --> 00:34:05,640
identity rule for monad there are also

00:34:04,020 --> 00:34:07,049
laws for functors and I'm just going to

00:34:05,640 --> 00:34:09,419
tell you what they are we could derive

00:34:07,049 --> 00:34:11,850
them as we just did but we don't have

00:34:09,419 --> 00:34:13,350
time and here's what they are if you

00:34:11,850 --> 00:34:15,659
have something and you map identity it

00:34:13,350 --> 00:34:17,879
does nothing and then if you map F map G

00:34:15,659 --> 00:34:20,010
it's the same as mapping over F and then

00:34:17,879 --> 00:34:22,919
G okay and that's a cool substitution

00:34:20,010 --> 00:34:24,840
because that's a very obvious gain and

00:34:22,919 --> 00:34:28,109
efficiency if you go from the one to the

00:34:24,840 --> 00:34:29,429
right to the one on the left so can we

00:34:28,109 --> 00:34:32,850
show that the implementation that we

00:34:29,429 --> 00:34:35,240
wrote obeys this law okay I claim we can

00:34:32,850 --> 00:34:39,119
and will use equational reasoning again

00:34:35,240 --> 00:34:40,919
so here's the identity rule so what we

00:34:39,119 --> 00:34:45,450
do is well just inline our definition of

00:34:40,919 --> 00:34:49,109
map then we'll inline identity and we'll

00:34:45,450 --> 00:34:52,409
apply a and then a to pure of a is just

00:34:49,109 --> 00:34:54,600
pure and we remember that the right

00:34:52,409 --> 00:34:57,660
identity law says a flat map pure is

00:34:54,600 --> 00:35:00,990
just a so we're done the identity law

00:34:57,660 --> 00:35:05,130
necessarily holds okay composition is a

00:35:00,990 --> 00:35:07,619
little more involved so we have a map FF

00:35:05,130 --> 00:35:11,100
map G will in line the definition of map

00:35:07,619 --> 00:35:14,609
and then we'll use our associativity

00:35:11,100 --> 00:35:16,680
rule to move the parentheses around okay

00:35:14,609 --> 00:35:19,830
it's it's a subtle change but it's

00:35:16,680 --> 00:35:22,020
important we reassociate and now we have

00:35:19,830 --> 00:35:24,690
an expression pure of something flat map

00:35:22,020 --> 00:35:27,090
something that looks like the left

00:35:24,690 --> 00:35:29,369
identity rule so we can just substitute

00:35:27,090 --> 00:35:32,810
f of a in for a on the right hand side

00:35:29,369 --> 00:35:32,810
and we get this

00:35:36,310 --> 00:35:43,150
okay and then the left rule a map FN and

00:35:40,090 --> 00:35:51,310
H will in line what map means in line

00:35:43,150 --> 00:35:52,600
and then look they're the same okay so

00:35:51,310 --> 00:35:54,070
we've proved it we prove that if you

00:35:52,600 --> 00:35:55,780
have a lawful monad then our

00:35:54,070 --> 00:35:58,570
implementation of map is necessarily

00:35:55,780 --> 00:36:01,840
correct okay for any Monat at all which

00:35:58,570 --> 00:36:04,240
is really cool okay so we have pure flat

00:36:01,840 --> 00:36:05,590
map and map and the reason I want to

00:36:04,240 --> 00:36:07,870
show you this it's just to show that

00:36:05,590 --> 00:36:10,630
it's all the stuff builds on itself it's

00:36:07,870 --> 00:36:12,310
very systematic and they're very

00:36:10,630 --> 00:36:13,840
precisely defined relationships between

00:36:12,310 --> 00:36:15,580
these abstractions that we use in

00:36:13,840 --> 00:36:17,440
functional programming and once you kind

00:36:15,580 --> 00:36:19,060
of get your feet wet you find that

00:36:17,440 --> 00:36:22,090
everything ends up being very

00:36:19,060 --> 00:36:23,650
predictable and very consistent and the

00:36:22,090 --> 00:36:26,920
ability to lower your blood pressure is

00:36:23,650 --> 00:36:29,590
a very underrated feature of functional

00:36:26,920 --> 00:36:32,500
programming so let's look at one more

00:36:29,590 --> 00:36:34,810
operation and I won't move on here's one

00:36:32,500 --> 00:36:37,570
called tuple it takes an F of a and F of

00:36:34,810 --> 00:36:39,490
B and it gives you an F of the pair type

00:36:37,570 --> 00:36:44,140
of an B and we can define that in terms

00:36:39,490 --> 00:36:45,910
of flat map this is a an operation from

00:36:44,140 --> 00:36:48,070
applicative functors which we aren't

00:36:45,910 --> 00:36:50,260
going to talk about but again I could

00:36:48,070 --> 00:36:53,590
prove to you that this implementation

00:36:50,260 --> 00:36:56,500
has to be correct in the same way we did

00:36:53,590 --> 00:36:58,480
it for functors so carrying on we can

00:36:56,500 --> 00:37:02,680
find a syntax class and this just says

00:36:58,480 --> 00:37:04,540
for any for any type that has a monad

00:37:02,680 --> 00:37:08,110
instance we can give you flat map map

00:37:04,540 --> 00:37:10,210
and tupple just by a syntax extension

00:37:08,110 --> 00:37:11,790
and now anything with a monad instance

00:37:10,210 --> 00:37:13,690
can be used in a for comprehension

00:37:11,790 --> 00:37:16,540
that's pretty cool anything with a

00:37:13,690 --> 00:37:20,020
monoid instance and let's add two more

00:37:16,540 --> 00:37:21,520
derived operations so I call these left

00:37:20,020 --> 00:37:23,710
shark and right shark the idea is that

00:37:21,520 --> 00:37:25,390
you're sort of swallowing the value on

00:37:23,710 --> 00:37:27,640
one side or the other

00:37:25,390 --> 00:37:29,260
so what this does is this tuples the

00:37:27,640 --> 00:37:31,060
things together and then throws away the

00:37:29,260 --> 00:37:33,040
left side or the right side and we'll

00:37:31,060 --> 00:37:36,180
play around with that in a minute when

00:37:33,040 --> 00:37:36,180
we look back at our effects

00:37:37,780 --> 00:37:45,110
so this is kind of cool this is a debris

00:37:41,840 --> 00:37:48,200
ring it's around a star half of a binary

00:37:45,110 --> 00:37:50,270
system it's kind of like the Kuiper belt

00:37:48,200 --> 00:37:52,940
in our own solar system but much much

00:37:50,270 --> 00:37:54,850
bigger the star itself is hidden behind

00:37:52,940 --> 00:37:58,400
a mask so the light from the star

00:37:54,850 --> 00:38:03,680
doesn't overwhelm the dark stuff around

00:37:58,400 --> 00:38:05,060
it that we're looking at it's getting

00:38:03,680 --> 00:38:07,460
harder for us to say this is happening

00:38:05,060 --> 00:38:10,970
right now because the light from the

00:38:07,460 --> 00:38:11,960
star takes 237 years to get here we're

00:38:10,970 --> 00:38:13,790
now at the point where we're running out

00:38:11,960 --> 00:38:17,060
of words to describe the distance this

00:38:13,790 --> 00:38:23,840
is roughly fourteen hundred trillion

00:38:17,060 --> 00:38:25,340
miles from here all right so now we know

00:38:23,840 --> 00:38:28,010
all about monads and let's see what we

00:38:25,340 --> 00:38:33,050
can do with our effects now let's talk

00:38:28,010 --> 00:38:36,020
about option again so option gives you a

00:38:33,050 --> 00:38:37,130
flat map out of the box from standard

00:38:36,020 --> 00:38:40,160
library but I'll show you how it's

00:38:37,130 --> 00:38:43,100
defined if we take an option A and an

00:38:40,160 --> 00:38:44,870
eighth option B we pattern match on the

00:38:43,100 --> 00:38:47,390
option and if we have an A we apply F to

00:38:44,870 --> 00:38:49,040
it and if we don't then we pass none we

00:38:47,390 --> 00:38:52,460
don't have an A to pass along so we have

00:38:49,040 --> 00:38:54,260
to stop and presumably most of us have

00:38:52,460 --> 00:38:55,550
used options and for comprehensions so

00:38:54,260 --> 00:38:56,840
I'm not going to talk about that let's

00:38:55,550 --> 00:38:59,720
talk about the blowfish operators

00:38:56,840 --> 00:39:01,880
because they're interesting or the sharp

00:38:59,720 --> 00:39:04,340
operator so we have this validate method

00:39:01,880 --> 00:39:06,590
it takes a string and it validates the

00:39:04,340 --> 00:39:08,060
string is non-empty so it's not empty

00:39:06,590 --> 00:39:10,490
you get some if it's empty you get none

00:39:08,060 --> 00:39:12,410
so we can say validate Bob tuple

00:39:10,490 --> 00:39:16,070
validate dull and we get some of the

00:39:12,410 --> 00:39:18,680
pair of both because they both are valid

00:39:16,070 --> 00:39:21,950
if either of them is empty is in the

00:39:18,680 --> 00:39:24,410
second example you get none back we can

00:39:21,950 --> 00:39:26,450
validate in the next example we can

00:39:24,410 --> 00:39:28,490
validate both and throw away the answer

00:39:26,450 --> 00:39:30,710
to the first one we only care about the

00:39:28,490 --> 00:39:32,960
second one in the next example we do the

00:39:30,710 --> 00:39:37,670
same thing we throw away the first one

00:39:32,960 --> 00:39:39,680
and we get none back the validate with

00:39:37,670 --> 00:39:41,780
the empty string there is only therefore

00:39:39,680 --> 00:39:43,310
its effect so even if we don't care

00:39:41,780 --> 00:39:45,580
about the value that we compute the

00:39:43,310 --> 00:39:49,920
effects can be important

00:39:45,580 --> 00:39:52,920
the last example a results 17

00:39:49,920 --> 00:39:54,510
is the same thing as a result 15 is just

00:39:52,920 --> 00:39:55,829
flipped around we flipped the arguments

00:39:54,510 --> 00:39:58,380
and flip the shark and we got the same

00:39:55,829 --> 00:40:00,510
thing back which is kind of cool this is

00:39:58,380 --> 00:40:02,420
not true in general it's true of option

00:40:00,510 --> 00:40:04,380
because option is a commutative monad

00:40:02,420 --> 00:40:06,599
okay we'll look at some other types

00:40:04,380 --> 00:40:09,390
where this doesn't hold okay

00:40:06,599 --> 00:40:10,740
so what this gives us back is partiality

00:40:09,390 --> 00:40:13,589
we're programming is if we have

00:40:10,740 --> 00:40:15,630
something like null or something that

00:40:13,589 --> 00:40:18,210
represents no answer okay but in an

00:40:15,630 --> 00:40:22,250
entirely pure setting so we can program

00:40:18,210 --> 00:40:27,599
that way again let's talk about either

00:40:22,250 --> 00:40:34,230
again you get flat map out of the box in

00:40:27,599 --> 00:40:36,180
212 so the implementation just says if

00:40:34,230 --> 00:40:39,059
you fix the left side I can define flat

00:40:36,180 --> 00:40:41,430
map over the right hand side if there's

00:40:39,059 --> 00:40:44,010
a left value then we just pass it along

00:40:41,430 --> 00:40:45,569
if there is a value on the right we

00:40:44,010 --> 00:40:49,440
apply our function to it and get the

00:40:45,569 --> 00:40:51,390
next either that we pass along so let's

00:40:49,440 --> 00:40:54,630
look at an example of that we have a

00:40:51,390 --> 00:40:57,079
validate method now that takes a tag so

00:40:54,630 --> 00:41:00,000
if the value is non-empty it returns it

00:40:57,079 --> 00:41:04,109
as success otherwise it gives you a

00:41:00,000 --> 00:41:05,609
reason why it failed now we can write

00:41:04,109 --> 00:41:07,619
this method validate name it takes a

00:41:05,609 --> 00:41:09,450
first name and a last name it validates

00:41:07,619 --> 00:41:12,059
the first one and validates the last one

00:41:09,450 --> 00:41:14,819
and it returns a string that that's the

00:41:12,059 --> 00:41:16,049
concatenation of them okay and notice

00:41:14,819 --> 00:41:18,750
that we're not mentioning the failure

00:41:16,049 --> 00:41:20,280
cases anywhere in validate name we're

00:41:18,750 --> 00:41:24,150
just sort of writing out the nominal

00:41:20,280 --> 00:41:26,160
case okay so if we run validate name for

00:41:24,150 --> 00:41:28,710
bob dole we get a write with the string

00:41:26,160 --> 00:41:31,829
if either is empty we get a message

00:41:28,710 --> 00:41:34,410
telling us which one is empty which is

00:41:31,829 --> 00:41:36,660
pretty cool so now basically we have

00:41:34,410 --> 00:41:43,010
exceptions back okay but this is totally

00:41:36,660 --> 00:41:46,470
pure let's talk about lists again the

00:41:43,010 --> 00:41:48,630
the Monod for lists just smashes all the

00:41:46,470 --> 00:41:51,140
lists together with with with flat map

00:41:48,630 --> 00:41:54,390
so I'm not going to talk about the

00:41:51,140 --> 00:41:56,339
implementation for it let's look at

00:41:54,390 --> 00:41:58,319
tuple it's kind of interesting if you

00:41:56,339 --> 00:42:00,750
take two lists and two plum together you

00:41:58,319 --> 00:42:02,549
get the Cartesian product you get every

00:42:00,750 --> 00:42:03,599
combination which is the way we had

00:42:02,549 --> 00:42:06,960
described it before it

00:42:03,599 --> 00:42:08,910
possible answer and the next two

00:42:06,960 --> 00:42:11,309
examples just demonstrate that this

00:42:08,910 --> 00:42:15,690
shark reversibility doesn't hold in

00:42:11,309 --> 00:42:17,910
general if we use one list or the other

00:42:15,690 --> 00:42:20,160
just for its effect you can tell the

00:42:17,910 --> 00:42:22,170
difference you get X Y X Y verses xxx

00:42:20,160 --> 00:42:23,999
yyy this is just to show the

00:42:22,170 --> 00:42:26,609
commutativity does not hold in general

00:42:23,999 --> 00:42:30,869
for those operations let's talk about

00:42:26,609 --> 00:42:35,249
reader so the implementation for reader

00:42:30,869 --> 00:42:37,140
says I take some environment and I

00:42:35,249 --> 00:42:38,430
compute a value and then I compute the

00:42:37,140 --> 00:42:40,920
next reader and I passed that same

00:42:38,430 --> 00:42:43,499
environment to it so it just threads the

00:42:40,920 --> 00:42:45,359
environment through here's an example

00:42:43,499 --> 00:42:50,160
here's our path method again that takes

00:42:45,359 --> 00:42:51,779
a host here is a second a second method

00:42:50,160 --> 00:42:54,299
that just tells us the length of the

00:42:51,779 --> 00:42:58,109
host so now I can write this program

00:42:54,299 --> 00:43:00,599
that says we'll create a path from

00:42:58,109 --> 00:43:01,170
foobar and we'll get the name of the

00:43:00,599 --> 00:43:02,190
host

00:43:01,170 --> 00:43:03,509
we'll get the length of the name of the

00:43:02,190 --> 00:43:06,299
host and we'll compute a string that

00:43:03,509 --> 00:43:10,499
talks about those things and when we run

00:43:06,299 --> 00:43:12,180
it with Google comm we we find that that

00:43:10,499 --> 00:43:13,890
environment that Google comm is

00:43:12,180 --> 00:43:15,569
available to all the computations that

00:43:13,890 --> 00:43:18,719
we've composed together but we're not

00:43:15,569 --> 00:43:20,430
talking about it okay so in this prog

00:43:18,719 --> 00:43:23,670
definition we don't mention the

00:43:20,430 --> 00:43:25,650
configuration at all okay so this kind

00:43:23,670 --> 00:43:28,109
of gives us the ability to program as if

00:43:25,650 --> 00:43:30,059
we have dependency injections a

00:43:28,109 --> 00:43:31,769
dependency injection but we're really

00:43:30,059 --> 00:43:33,839
just passing arguments to functions so

00:43:31,769 --> 00:43:35,460
we have not lost the ability to recover

00:43:33,839 --> 00:43:36,930
easin locally about we're doing so we

00:43:35,460 --> 00:43:38,339
get the noise reduction but without

00:43:36,930 --> 00:43:41,819
infecting our program with this big

00:43:38,339 --> 00:43:45,450
global scope let's skip writer since we

00:43:41,819 --> 00:43:49,979
didn't talk about it okay state is the

00:43:45,450 --> 00:43:52,619
really interesting one so remember we

00:43:49,979 --> 00:43:54,180
take some input state we compute a value

00:43:52,619 --> 00:43:58,499
and we turn the output state along with

00:43:54,180 --> 00:44:00,809
it so to compose these into n we run the

00:43:58,499 --> 00:44:03,690
first state computation and then we run

00:44:00,809 --> 00:44:05,009
the second computation with the newly

00:44:03,690 --> 00:44:06,960
computed state and then we pass the

00:44:05,009 --> 00:44:10,049
answer to that along I'll show you an

00:44:06,960 --> 00:44:12,329
example of that so we have this rnd

00:44:10,049 --> 00:44:15,329
program that's a state from seed to int

00:44:12,329 --> 00:44:16,290
and what it does is it computes a new

00:44:15,329 --> 00:44:20,099
random number

00:44:16,290 --> 00:44:22,440
new pseudo-random number so now we can

00:44:20,099 --> 00:44:25,770
define a little program called d6 that

00:44:22,440 --> 00:44:28,200
rolls a die I guess it should be it's

00:44:25,770 --> 00:44:30,420
actually 0 to 5 it's not it's not 1 to 6

00:44:28,200 --> 00:44:32,280
but so we're taking this random program

00:44:30,420 --> 00:44:34,800
that make that gives you any number and

00:44:32,280 --> 00:44:37,740
we're using map to reduce it to a value

00:44:34,800 --> 00:44:39,510
between 0 and 5 and now we can use that

00:44:37,740 --> 00:44:41,550
and compose we can create another

00:44:39,510 --> 00:44:44,130
program called damage that rolls to dice

00:44:41,550 --> 00:44:45,450
and adds two together and returns the

00:44:44,130 --> 00:44:46,800
answer to you and notice that these are

00:44:45,450 --> 00:44:51,780
vowels these are not depth these are

00:44:46,800 --> 00:44:53,280
values we can run this with a seed of 17

00:44:51,780 --> 00:44:56,430
and we get 10 as the answer and then

00:44:53,280 --> 00:44:59,040
this huge number is our next seed we can

00:44:56,430 --> 00:45:00,630
run we can compose again and and have a

00:44:59,040 --> 00:45:04,170
program that runs this damage thing

00:45:00,630 --> 00:45:06,329
twice and we can run that with 17 and

00:45:04,170 --> 00:45:07,940
take the first part of the answer which

00:45:06,329 --> 00:45:10,560
is this that string we've constructed

00:45:07,940 --> 00:45:12,060
okay or we can to pull it together and

00:45:10,560 --> 00:45:14,910
or use any of these common errors that

00:45:12,060 --> 00:45:17,310
we've that we've defined so we want

00:45:14,910 --> 00:45:18,839
wrote this one definition of our nd that

00:45:17,310 --> 00:45:20,819
understands how to propagate the seed

00:45:18,839 --> 00:45:22,650
around and then we forgot about it and

00:45:20,819 --> 00:45:24,180
for the rest of our program we're

00:45:22,650 --> 00:45:25,500
programming as if we have a mutable

00:45:24,180 --> 00:45:29,010
random number generator but it's

00:45:25,500 --> 00:45:32,099
entirely pure okay so I think state is

00:45:29,010 --> 00:45:34,140
kind of the exit exam for for monads 101

00:45:32,099 --> 00:45:35,670
if you understand state then you

00:45:34,140 --> 00:45:38,010
understand monads and you understand

00:45:35,670 --> 00:45:39,990
effects and there's no stopping you once

00:45:38,010 --> 00:45:42,359
you get this so a lot of people find the

00:45:39,990 --> 00:45:44,010
state monad to be sort of the the

00:45:42,359 --> 00:45:45,000
mind-blowing thing when they're getting

00:45:44,010 --> 00:45:49,680
into functional programming so I

00:45:45,000 --> 00:45:52,050
encourage you to study it okay this is

00:45:49,680 --> 00:45:54,329
our last stop it doesn't look like much

00:45:52,050 --> 00:45:56,910
that red smudge in the middle of the

00:45:54,329 --> 00:45:58,950
grainy image is a gamma-ray burst it's

00:45:56,910 --> 00:46:01,890
one of the most distant objects ever

00:45:58,950 --> 00:46:03,630
imaged the amount of energy released was

00:46:01,890 --> 00:46:08,069
estimated to be three and a half times

00:46:03,630 --> 00:46:10,020
10 to the 52 eggs which is a billion

00:46:08,069 --> 00:46:13,260
billion billion times brighter than the

00:46:10,020 --> 00:46:14,700
Sun it's a very high redshift which is

00:46:13,260 --> 00:46:16,530
the only way to talk about distance for

00:46:14,700 --> 00:46:18,960
things that are thus far away because

00:46:16,530 --> 00:46:20,640
the universe has expanded so much in the

00:46:18,960 --> 00:46:23,160
11 billion years that it took the light

00:46:20,640 --> 00:46:25,720
to get to the earth

00:46:23,160 --> 00:46:28,960
the light travel distance itself is on

00:46:25,720 --> 00:46:31,120
the order of 10 to the 23rd miles so we

00:46:28,960 --> 00:46:35,350
can call it a billion trillion trillion

00:46:31,120 --> 00:46:39,310
trillion miles give or take okay Big

00:46:35,350 --> 00:46:43,390
Finish is that no that is not it this is

00:46:39,310 --> 00:46:44,800
just 8a the barest taste of the kinds of

00:46:43,390 --> 00:46:47,080
effects that you can model in functional

00:46:44,800 --> 00:46:49,420
programming and the kinds of things you

00:46:47,080 --> 00:46:51,730
can express with monads and monads are

00:46:49,420 --> 00:46:53,980
just one family of effects they just

00:46:51,730 --> 00:46:55,630
happen to be really useful because they

00:46:53,980 --> 00:46:57,820
give us the structure of imperative

00:46:55,630 --> 00:47:00,340
programs which is something that most

00:46:57,820 --> 00:47:02,800
people are immediately missing when they

00:47:00,340 --> 00:47:05,560
move to functional programming so it's

00:47:02,800 --> 00:47:07,450
good to be able to get to monads because

00:47:05,560 --> 00:47:10,480
that'll give you a lot of your brain

00:47:07,450 --> 00:47:12,250
power back so it turns out the

00:47:10,480 --> 00:47:15,250
operations we've been talking about form

00:47:12,250 --> 00:47:17,110
a hierarchy of increasing power there

00:47:15,250 --> 00:47:19,210
are lots of things that have map and

00:47:17,110 --> 00:47:20,650
slightly fewer that also have zip

00:47:19,210 --> 00:47:23,520
slightly fewer that also have pure

00:47:20,650 --> 00:47:26,320
slightly fewer that also have flat map

00:47:23,520 --> 00:47:32,050
so it forms a subtyping relationship and

00:47:26,320 --> 00:47:33,220
in Scala we use subtyping so this is

00:47:32,050 --> 00:47:35,620
kind of what we have we talked about

00:47:33,220 --> 00:47:37,390
functor a little bit we talked about

00:47:35,620 --> 00:47:40,780
monad there's also applicative and apply

00:47:37,390 --> 00:47:42,430
that correspond to a peer and sieve and

00:47:40,780 --> 00:47:45,970
these are just for families effect of

00:47:42,430 --> 00:47:48,850
effects and in in in cats there are

00:47:45,970 --> 00:47:50,650
quite a few more I'll give you a link to

00:47:48,850 --> 00:47:53,230
this graphic at the end if the stuff

00:47:50,650 --> 00:47:56,500
interests you look at it find monad find

00:47:53,230 --> 00:47:58,480
functor and look at other structures

00:47:56,500 --> 00:48:00,100
that are nearby because they will be

00:47:58,480 --> 00:48:01,810
similar but different in interesting

00:48:00,100 --> 00:48:07,660
ways and and it's a good way to start

00:48:01,810 --> 00:48:09,550
exploring so let's review huh that said

00:48:07,660 --> 00:48:12,520
review my intent was not to have a back

00:48:09,550 --> 00:48:13,930
tic at the top so we've talked about

00:48:12,520 --> 00:48:15,700
functional programming we know what it

00:48:13,930 --> 00:48:17,130
is and we know why it's useful we've

00:48:15,700 --> 00:48:19,930
talked about referential transparency

00:48:17,130 --> 00:48:21,220
effect types we've talked about monads

00:48:19,930 --> 00:48:24,300
we know everything there is to know

00:48:21,220 --> 00:48:26,290
about monads we computed it from nothing

00:48:24,300 --> 00:48:31,540
we talked a little bit about functions

00:48:26,290 --> 00:48:33,280
as well things that you will hit next if

00:48:31,540 --> 00:48:35,140
you learn this stuff and want to take

00:48:33,280 --> 00:48:36,430
another step applicative into reversible

00:48:35,140 --> 00:48:38,260
functor

00:48:36,430 --> 00:48:40,210
they're related they end up being very

00:48:38,260 --> 00:48:41,440
very useful very quickly once you start

00:48:40,210 --> 00:48:44,619
doing this kind of programming so that

00:48:41,440 --> 00:48:46,780
is a likely next step for you we did not

00:48:44,619 --> 00:48:48,760
talk about composing effects so you can

00:48:46,780 --> 00:48:50,559
stack effects up you may not have a

00:48:48,760 --> 00:48:53,349
future of option or an option of either

00:48:50,559 --> 00:48:55,119
and you might want to compose functions

00:48:53,349 --> 00:48:56,650
that are computing in those composed

00:48:55,119 --> 00:48:58,359
effects and there are ways to do that

00:48:56,650 --> 00:49:01,540
but we haven't talked about that today

00:48:58,359 --> 00:49:06,000
and and there's a lifetime's worth of

00:49:01,540 --> 00:49:09,609
stuff to learn so here's some resources

00:49:06,000 --> 00:49:12,130
for cats type level org slash cats is

00:49:09,609 --> 00:49:15,250
the top level website there's a getter

00:49:12,130 --> 00:49:17,770
channel the infographic is in my github

00:49:15,250 --> 00:49:20,680
if you want to orient yourself with all

00:49:17,770 --> 00:49:22,990
the type classes Scala with cats is a

00:49:20,680 --> 00:49:24,790
great book it's by NOLA well she's here

00:49:22,990 --> 00:49:26,319
somewhere maybe not in the rim and Dave

00:49:24,790 --> 00:49:29,260
Grinnell it's available at underscored

00:49:26,319 --> 00:49:30,550
IO and it's free and functional

00:49:29,260 --> 00:49:32,829
programming in Scala which is kind of

00:49:30,550 --> 00:49:34,930
the master work on this on this stuff in

00:49:32,829 --> 00:49:37,240
Scala and it's a brilliant book and

00:49:34,930 --> 00:49:37,569
everyone should read it and that is all

00:49:37,240 --> 00:49:38,710
I've got

00:49:37,569 --> 00:49:44,239
thank you for your time

00:49:38,710 --> 00:49:44,239

YouTube URL: https://www.youtube.com/watch?v=30q6BkBv5MY


