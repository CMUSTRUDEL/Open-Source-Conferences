Title: Principles of Elegance by Jon Pretty
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
Scala combines a comprehensive array of syntactic features with a rich static type system. At the intersection between Scala's syntactic versatility and its reliable type-level constraints, there exists a narrow window of opportunity for designing APIs that are both expressive and safe; for writing code that is elegant.

We will explore this unique "elegance zone" offered by Scala, with useful real-world examples from Rapture, a collection of libraries for familiar everyday programming tasks, such as working with JSON, XML, HTML and CSV, time, internationalization, logging and I/O. Rapture's philosophy is to drive forwards the state of the art in typesafety, whilst at the same time maintaining the most intuitive syntax.

Ultimately, we will show that features of Scala like implicits and type inference offer some very exciting possibilities for developing software that provides both clearer code and offers more static guarantees, and that writing elegant code in Scala is within everyone's graspâ€”this is Scala's great chance to outshine other languages!
Captions: 
	00:00:04,840 --> 00:00:11,420
welcome I'm I'm gonna give a talk today

00:00:07,970 --> 00:00:13,850
which I'm calling principles of elegance

00:00:11,420 --> 00:00:16,010
which is probably just a bit of a

00:00:13,850 --> 00:00:18,830
departure from many of the talks I do in

00:00:16,010 --> 00:00:24,830
that I often I often like to talk about

00:00:18,830 --> 00:00:26,330
very precise technical topics and I like

00:00:24,830 --> 00:00:28,789
to work with with code and show you

00:00:26,330 --> 00:00:31,760
sample code and today I'm going I'm

00:00:28,789 --> 00:00:35,660
going to talk more about sort of very

00:00:31,760 --> 00:00:38,630
vague principles of coding and a lot of

00:00:35,660 --> 00:00:41,829
the ideas you'll probably think that you

00:00:38,630 --> 00:00:46,220
maybe you maybe find out how to get a

00:00:41,829 --> 00:00:49,790
grasp on the sort of generality of what

00:00:46,220 --> 00:00:53,030
I'm saying this is this is rather I'm

00:00:49,790 --> 00:00:56,170
gonna go even further back could you can

00:00:53,030 --> 00:00:59,329
you hear me okay what how about now

00:00:56,170 --> 00:01:04,040
you're okay with that okay I'm getting

00:00:59,329 --> 00:01:06,320
feedback in my ears yeah so I'm going to

00:01:04,040 --> 00:01:09,289
dot a few examples through the

00:01:06,320 --> 00:01:10,909
presentation from from rapture which is

00:01:09,289 --> 00:01:13,009
a library I've been writing for the last

00:01:10,909 --> 00:01:14,810
few years which will hopefully

00:01:13,009 --> 00:01:17,719
demonstrate or give give some

00:01:14,810 --> 00:01:21,469
credibility to some of the the more the

00:01:17,719 --> 00:01:25,219
more general claims I'll make but by by

00:01:21,469 --> 00:01:29,420
all means challenge me on the only on

00:01:25,219 --> 00:01:32,240
the assertions tweet tweet to me at a

00:01:29,420 --> 00:01:34,909
propensity have any thoughts on some of

00:01:32,240 --> 00:01:36,649
the things I'm saying I'm going to go

00:01:34,909 --> 00:01:39,349
through a number of these these these

00:01:36,649 --> 00:01:45,049
principles which by no means are

00:01:39,349 --> 00:01:49,609
exhaustive so I'm very open to do

00:01:45,049 --> 00:01:52,490
suggestions and criticisms so don't hold

00:01:49,609 --> 00:01:56,179
back so first of all maybe I should

00:01:52,490 --> 00:01:57,770
define what I think elegance is I lips

00:01:56,179 --> 00:02:01,429
up in the dictionary and it says

00:01:57,770 --> 00:02:04,669
combining simplicity power and a certain

00:02:01,429 --> 00:02:08,149
ineffable grace of design so that that's

00:02:04,669 --> 00:02:10,039
a dictionary which which claims

00:02:08,149 --> 00:02:12,020
something is ineffable is is not really

00:02:10,039 --> 00:02:14,300
doing its job it's meant it's meant to

00:02:12,020 --> 00:02:17,310
tell you what it is rather than say that

00:02:14,300 --> 00:02:21,540
it can't be can't be explained

00:02:17,310 --> 00:02:23,690
but we'll try to explore that in my mind

00:02:21,540 --> 00:02:29,520
when it comes to writing Scala code

00:02:23,690 --> 00:02:33,000
there are a couple of things which which

00:02:29,520 --> 00:02:35,160
kind of combine to form my idea of

00:02:33,000 --> 00:02:37,080
elegance one of them is having code

00:02:35,160 --> 00:02:38,760
which is intuitive which is readable

00:02:37,080 --> 00:02:40,769
code which you can look at and

00:02:38,760 --> 00:02:44,840
immediately understand or at least have

00:02:40,769 --> 00:02:44,840
a good idea about what it's doing and

00:02:44,959 --> 00:02:50,940
the other is type safety having your

00:02:47,940 --> 00:02:53,340
code be robust and allowing you to be

00:02:50,940 --> 00:02:56,069
confident in your code and often these

00:02:53,340 --> 00:02:59,069
things don't mesh well and I think if

00:02:56,069 --> 00:03:00,989
you can if you can work to combine these

00:02:59,069 --> 00:03:03,330
two things well I think you have what I

00:03:00,989 --> 00:03:07,799
would call elegant code that that is

00:03:03,330 --> 00:03:09,450
that is my my basis for this talk so one

00:03:07,799 --> 00:03:12,000
question you can ask is how is Scarlett

00:03:09,450 --> 00:03:15,480
if Iran from other languages that does

00:03:12,000 --> 00:03:17,910
does elegant supply to to Python or or

00:03:15,480 --> 00:03:20,819
Haskell it does but I think there are

00:03:17,910 --> 00:03:22,350
ways in which the specific ways in which

00:03:20,819 --> 00:03:25,680
scholar is different from from those

00:03:22,350 --> 00:03:28,370
other languages one thing is that I

00:03:25,680 --> 00:03:31,440
think more than most languages Scala

00:03:28,370 --> 00:03:33,690
transcends different abilities you can

00:03:31,440 --> 00:03:37,590
approach scholar coming from coming from

00:03:33,690 --> 00:03:40,530
just some Java experience and and have a

00:03:37,590 --> 00:03:43,859
reason idea about some some but some

00:03:40,530 --> 00:03:46,139
basic basic basic concepts you can write

00:03:43,859 --> 00:03:49,620
code that works very quickly if you know

00:03:46,139 --> 00:03:51,450
you know Java but at the same time you

00:03:49,620 --> 00:03:53,069
can do some really advanced things you

00:03:51,450 --> 00:03:54,389
can you can you can do some type level

00:03:53,069 --> 00:03:56,670
programming and it's the same language

00:03:54,389 --> 00:03:58,889
it's the same same domain you're working

00:03:56,670 --> 00:04:01,620
in but we're using the same language

00:03:58,889 --> 00:04:04,019
from from the very basic stuff to the to

00:04:01,620 --> 00:04:05,280
the most advanced and scholar i think is

00:04:04,019 --> 00:04:07,410
better than many languages are doing

00:04:05,280 --> 00:04:09,900
that not it's by no means perfect i'm

00:04:07,410 --> 00:04:12,780
sure many of you are thinking scarlett

00:04:09,900 --> 00:04:15,090
makes loads of mistakes at trying to

00:04:12,780 --> 00:04:22,260
appeal to to broader at a church of

00:04:15,090 --> 00:04:24,419
users and scholars a big language and in

00:04:22,260 --> 00:04:27,560
being such a large language with with

00:04:24,419 --> 00:04:29,470
with many features it kind of encourages

00:04:27,560 --> 00:04:31,760
inventiveness

00:04:29,470 --> 00:04:33,800
it encourages you to try combining

00:04:31,760 --> 00:04:35,660
features in different ways I mean it I

00:04:33,800 --> 00:04:38,510
mean it encourages me I don't know if

00:04:35,660 --> 00:04:41,870
you feel the same way but I i frequently

00:04:38,510 --> 00:04:44,300
end up whenever whenever a new major

00:04:41,870 --> 00:04:47,540
version of scarlet comes out and some

00:04:44,300 --> 00:04:49,639
new new features get added to the added

00:04:47,540 --> 00:04:51,199
to its powers I think well how can I use

00:04:49,639 --> 00:04:54,560
this feature with all of the other

00:04:51,199 --> 00:04:56,720
features I've got and an a major in

00:04:54,560 --> 00:04:59,389
hates this because I then I then go and

00:04:56,720 --> 00:05:07,039
find find like esoteric corner cases

00:04:59,389 --> 00:05:08,930
that that no be considered and being

00:05:07,039 --> 00:05:10,850
being this this language what I think is

00:05:08,930 --> 00:05:15,260
is unique there are some unique

00:05:10,850 --> 00:05:17,810
solutions it needs as well so i'm going

00:05:15,260 --> 00:05:20,240
to as i said this isn't exhaustive but i

00:05:17,810 --> 00:05:24,770
got to try and put into eight core

00:05:20,240 --> 00:05:26,990
principles by my thoughts about how you

00:05:24,770 --> 00:05:32,539
can design better libraries better api's

00:05:26,990 --> 00:05:33,919
in scala some of these do actually work

00:05:32,539 --> 00:05:36,260
with some some of these principles do

00:05:33,919 --> 00:05:38,919
apply to other other domains as well but

00:05:36,260 --> 00:05:41,599
but but many are quite specific to scala

00:05:38,919 --> 00:05:44,270
and as i said beginning their their work

00:05:41,599 --> 00:05:47,150
in progress feedback is is very welcome

00:05:44,270 --> 00:05:50,960
and another thing another thing to note

00:05:47,150 --> 00:05:53,990
is these principles are with the goal of

00:05:50,960 --> 00:05:57,620
writing elephant code you may have other

00:05:53,990 --> 00:06:00,620
goals you may have performance as a as a

00:05:57,620 --> 00:06:03,590
key goal in code or writing in which

00:06:00,620 --> 00:06:06,229
case you can you can maybe sacrifice or

00:06:03,590 --> 00:06:07,639
compromise on some of these ideas if you

00:06:06,229 --> 00:06:09,770
want code to be readable and you wanted

00:06:07,639 --> 00:06:14,810
to be robust and type safe and

00:06:09,770 --> 00:06:16,340
maintainable then this this is my

00:06:14,810 --> 00:06:20,620
definition of elegance this is what

00:06:16,340 --> 00:06:23,930
these principles are for so number one

00:06:20,620 --> 00:06:29,780
keep your keep your public API is small

00:06:23,930 --> 00:06:32,740
keep them minimal and this this

00:06:29,780 --> 00:06:35,870
obviously applies to too many languages

00:06:32,740 --> 00:06:37,789
we want we want things to be easily

00:06:35,870 --> 00:06:40,340
understood we want to be simple and by

00:06:37,789 --> 00:06:41,650
keeping keeping API is small having

00:06:40,340 --> 00:06:45,290
fewer methods

00:06:41,650 --> 00:06:48,440
we we allow them to be easier to

00:06:45,290 --> 00:06:52,310
maintain easier to understand and also

00:06:48,440 --> 00:06:54,470
easier to compose and this this is this

00:06:52,310 --> 00:06:56,840
gives us a lot of flexibility to combine

00:06:54,470 --> 00:06:59,630
things in in different ways without

00:06:56,840 --> 00:07:05,450
introducing more complicated corner

00:06:59,630 --> 00:07:07,130
cases we want to avoid I'm totally using

00:07:05,450 --> 00:07:11,360
the word polluting here polluting public

00:07:07,130 --> 00:07:13,070
api's with details that the end users

00:07:11,360 --> 00:07:17,750
don't need to see that they don't need

00:07:13,070 --> 00:07:19,220
to be aware of hide stuff from your use

00:07:17,750 --> 00:07:24,500
if it's not relevant to them keep

00:07:19,220 --> 00:07:26,900
internals internal you can expect users

00:07:24,500 --> 00:07:28,610
to import stuff with wild card input

00:07:26,900 --> 00:07:30,140
this easiest way if you're if you're

00:07:28,610 --> 00:07:33,380
using a lot of things from the same

00:07:30,140 --> 00:07:35,420
package so don't have additional things

00:07:33,380 --> 00:07:37,880
in those in those packages that aren't

00:07:35,420 --> 00:07:41,240
aren't relevant make sure that every

00:07:37,880 --> 00:07:44,330
type beard a class straight case class

00:07:41,240 --> 00:07:46,790
object every every value every method

00:07:44,330 --> 00:07:49,970
every implicit that is imported in a

00:07:46,790 --> 00:07:55,880
particular from a particular package has

00:07:49,970 --> 00:07:58,310
justification for being there in general

00:07:55,880 --> 00:08:01,370
try to have fewer methods rather than

00:07:58,310 --> 00:08:03,950
more don't don't provide specific

00:08:01,370 --> 00:08:08,680
convenience methods provide general

00:08:03,950 --> 00:08:08,680
versions make them generic if you can

00:08:09,190 --> 00:08:16,820
take advantage of public and as a

00:08:12,140 --> 00:08:18,230
private and protected modifies if stuff

00:08:16,820 --> 00:08:20,320
shouldn't be accessible to be out on the

00:08:18,230 --> 00:08:27,740
outside then then then take advantage of

00:08:20,320 --> 00:08:30,920
these instead of using overloading be

00:08:27,740 --> 00:08:32,900
more general use type classes who here

00:08:30,920 --> 00:08:36,700
is currently just put your hands up who

00:08:32,900 --> 00:08:39,800
is familiar with type classes that is

00:08:36,700 --> 00:08:41,450
encouraging I that the number of people

00:08:39,800 --> 00:08:44,810
who put their hand up I think goes up

00:08:41,450 --> 00:08:48,200
every every year I do a talk and I

00:08:44,810 --> 00:08:50,480
remember about four years ago it was

00:08:48,200 --> 00:08:51,920
just like a cluster of a few people who

00:08:50,480 --> 00:08:54,950
would would raise their hand when I

00:08:51,920 --> 00:08:59,180
asked about type classes and I think

00:08:54,950 --> 00:09:02,300
think as a community where we're sort of

00:08:59,180 --> 00:09:05,450
learning of the benefits of type classes

00:09:02,300 --> 00:09:07,420
over some of the more more more

00:09:05,450 --> 00:09:11,470
traditional ways of doing similar things

00:09:07,420 --> 00:09:15,110
I'll talk more Rokk psych classes later

00:09:11,470 --> 00:09:17,210
one really simple trick it's not i don't

00:09:15,110 --> 00:09:21,140
i don't claim this is profound in any

00:09:17,210 --> 00:09:24,950
way but hide types inside others nest

00:09:21,140 --> 00:09:28,970
them so for example if we if we start

00:09:24,950 --> 00:09:30,590
off with with code like this i don't

00:09:28,970 --> 00:09:32,150
know if ooh does but we brought a foo

00:09:30,590 --> 00:09:35,480
we've got subclasses of food called

00:09:32,150 --> 00:09:38,000
basic foo and advanced fee who knows

00:09:35,480 --> 00:09:40,310
what they are but we've got three types

00:09:38,000 --> 00:09:43,100
that are visible in our project package

00:09:40,310 --> 00:09:46,340
there instead we'd write these like the

00:09:43,100 --> 00:09:48,500
second second half of the slide put the

00:09:46,340 --> 00:09:52,070
basic and advanced versions inside the

00:09:48,500 --> 00:09:54,200
foo object again this is this is not

00:09:52,070 --> 00:09:57,620
profound this is just saying nest things

00:09:54,200 --> 00:10:01,670
more deeply hi stuff away take advantage

00:09:57,620 --> 00:10:04,310
of of keeping of the namespace

00:10:01,670 --> 00:10:09,980
facilities of scholar to keep keep api's

00:10:04,310 --> 00:10:12,640
clean on to the second second principal

00:10:09,980 --> 00:10:16,130
licit this is one you probably know well

00:10:12,640 --> 00:10:18,770
choose your names wisely naming stuff is

00:10:16,130 --> 00:10:21,230
difficult or is I think think someone

00:10:18,770 --> 00:10:22,460
tweeted recently make me stuff isn't

00:10:21,230 --> 00:10:26,300
difficult but we just can't be bothered

00:10:22,460 --> 00:10:28,670
to do it most of the time it's kind of

00:10:26,300 --> 00:10:33,380
fun to name stuff but it comes with

00:10:28,670 --> 00:10:35,480
risks and rewards so everything we

00:10:33,380 --> 00:10:37,130
everything we work with early all the

00:10:35,480 --> 00:10:39,020
entities the types and the terms in

00:10:37,130 --> 00:10:40,760
Scala they need names we need we need a

00:10:39,020 --> 00:10:43,280
way of describing them both when we're

00:10:40,760 --> 00:10:45,800
communicating with with colleagues and

00:10:43,280 --> 00:10:47,680
co-workers and when we're writing when

00:10:45,800 --> 00:10:49,940
women when we refer to them in code so

00:10:47,680 --> 00:10:51,530
we need to we need to pick these names

00:10:49,940 --> 00:10:52,730
to be to be convenient and there's this

00:10:51,530 --> 00:10:57,860
deserve a number of different factors

00:10:52,730 --> 00:11:01,160
which should should implement that the

00:10:57,860 --> 00:11:04,040
name should communicate something it

00:11:01,160 --> 00:11:06,740
should be possible as myself as a

00:11:04,040 --> 00:11:08,090
speaker of English you you as speakers

00:11:06,740 --> 00:11:08,870
of a variety of different languages but

00:11:08,090 --> 00:11:10,580
I

00:11:08,870 --> 00:11:14,800
students things are listening to me also

00:11:10,580 --> 00:11:19,100
English you you should be aware of the

00:11:14,800 --> 00:11:21,500
what the word means and unfortunately or

00:11:19,100 --> 00:11:24,110
maybe fortunately English comes with a

00:11:21,500 --> 00:11:27,140
large vocabulary of different words with

00:11:24,110 --> 00:11:30,470
each with subtle nuances that may infer

00:11:27,140 --> 00:11:34,040
other things as well as the the core

00:11:30,470 --> 00:11:38,180
meaning and we get these preconceptions

00:11:34,040 --> 00:11:40,900
about preconceptions of meanings of

00:11:38,180 --> 00:11:43,460
words when we when we see when we see a

00:11:40,900 --> 00:11:45,560
noun or a verb in code for the first

00:11:43,460 --> 00:11:48,529
time and this can be both good and bad

00:11:45,560 --> 00:11:52,310
sometimes the meaning the other the more

00:11:48,529 --> 00:11:55,850
nuanced meaning aligns with our desired

00:11:52,310 --> 00:11:56,810
meaning our intentions for that but we

00:11:55,850 --> 00:12:00,020
have to be careful because sometimes

00:11:56,810 --> 00:12:02,710
other people can assume something else

00:12:00,020 --> 00:12:06,400
about about the empty intended meaning

00:12:02,710 --> 00:12:09,500
we have a big vocabulary but we have to

00:12:06,400 --> 00:12:12,320
but it we have to be careful out the

00:12:09,500 --> 00:12:14,480
words we choose within that to apply to

00:12:12,320 --> 00:12:18,529
different diff different different

00:12:14,480 --> 00:12:21,980
scenarios so some questions you can ask

00:12:18,529 --> 00:12:23,570
does if we're naming a method does does

00:12:21,980 --> 00:12:26,630
the method implement something we're

00:12:23,570 --> 00:12:29,390
already familiar with can we reuse an

00:12:26,630 --> 00:12:31,580
existing name or do we need to actually

00:12:29,390 --> 00:12:34,339
branch off and choose a different name

00:12:31,580 --> 00:12:36,020
that is decidedly distinct from the one

00:12:34,339 --> 00:12:39,920
we're familiar with this is this the

00:12:36,020 --> 00:12:41,390
choice we have to make for methods for

00:12:39,920 --> 00:12:43,970
objects were types that are very

00:12:41,390 --> 00:12:47,270
pervasive through a lot of code they're

00:12:43,970 --> 00:12:48,440
going to appear very often short names

00:12:47,270 --> 00:12:50,890
are generally better we don't want to

00:12:48,440 --> 00:12:56,839
have to refer to very long names

00:12:50,890 --> 00:12:59,270
frequently but if there's if there's

00:12:56,839 --> 00:13:01,100
ambiguity if there are if there's the

00:12:59,270 --> 00:13:03,470
opportunity to misinterpret something

00:13:01,100 --> 00:13:08,750
then we should probably prefer longer

00:13:03,470 --> 00:13:12,670
names one specific case is with implicit

00:13:08,750 --> 00:13:16,940
since carla now if you have to implicit

00:13:12,670 --> 00:13:21,990
in scope at the same time with identical

00:13:16,940 --> 00:13:24,630
names then one will shadow the other

00:13:21,990 --> 00:13:27,480
you won't be able to see the one that's

00:13:24,630 --> 00:13:30,959
imported or defined first the one which

00:13:27,480 --> 00:13:32,570
is imported or defined last wins now

00:13:30,959 --> 00:13:34,589
this happens if they have the same name

00:13:32,570 --> 00:13:37,130
so you have to be careful about your

00:13:34,589 --> 00:13:40,440
about about how you name implicit

00:13:37,130 --> 00:13:42,260
generally if you have a longer name more

00:13:40,440 --> 00:13:45,060
specific name and more descriptive name

00:13:42,260 --> 00:13:46,709
there's less chance it will flash with

00:13:45,060 --> 00:13:51,630
somebody else's implicit or even your

00:13:46,709 --> 00:13:53,640
own implicit and one convenient thing in

00:13:51,630 --> 00:13:56,459
particular with implicit is you you

00:13:53,640 --> 00:13:58,200
really need to refers them directly you

00:13:56,459 --> 00:14:00,930
can import them maybe an hour maybe in a

00:13:58,200 --> 00:14:02,580
package with a wild card so you don't

00:14:00,930 --> 00:14:06,380
need to refer to that long name so give

00:14:02,580 --> 00:14:08,250
it if given plis it's a long name

00:14:06,380 --> 00:14:11,279
there's probably a lot more I could say

00:14:08,250 --> 00:14:14,279
about about naming things how you Lee

00:14:11,279 --> 00:14:16,260
actually did a very good blog post on on

00:14:14,279 --> 00:14:18,360
on naming stuff which goes into a lot

00:14:16,260 --> 00:14:21,360
more detail I've got time for so if you

00:14:18,360 --> 00:14:25,050
can if you can find a consciousness and

00:14:21,360 --> 00:14:29,790
names take a look at that it's it's well

00:14:25,050 --> 00:14:31,680
worth reading so this is this is very

00:14:29,790 --> 00:14:33,990
this idea is very dear to my heart

00:14:31,680 --> 00:14:36,240
embrace the type type system the type

00:14:33,990 --> 00:14:39,209
system is your friend often your best

00:14:36,240 --> 00:14:43,279
friend in in the in there in the

00:14:39,209 --> 00:14:47,700
programming world what does this mean I

00:14:43,279 --> 00:14:51,360
find that having a type system empowers

00:14:47,700 --> 00:14:54,750
me the constraints it provides the the

00:14:51,360 --> 00:14:58,529
force forcing me to go down a straight

00:14:54,750 --> 00:15:00,630
and narrow path liberate me to try stuff

00:14:58,529 --> 00:15:03,390
because I know the compiler will be

00:15:00,630 --> 00:15:05,370
watching my back I know that if I've to

00:15:03,390 --> 00:15:10,020
find if I've defined my types correctly

00:15:05,370 --> 00:15:11,370
the type system will constrain what I

00:15:10,020 --> 00:15:13,980
can do with us it'll stop me doing

00:15:11,370 --> 00:15:19,620
things that are guaranteed to fail at

00:15:13,980 --> 00:15:21,779
runtime and this gives gives us

00:15:19,620 --> 00:15:23,399
confidence to reason about our code it

00:15:21,779 --> 00:15:26,730
means if you were if we attempt to large

00:15:23,399 --> 00:15:28,950
refactoring and we're working entirely

00:15:26,730 --> 00:15:32,550
with very tight safe code we can make

00:15:28,950 --> 00:15:34,440
all those changes we can and I've said

00:15:32,550 --> 00:15:36,150
this many times before I've done it on

00:15:34,440 --> 00:15:39,260
numerous occasions

00:15:36,150 --> 00:15:42,870
I've spent a day sometimes a week

00:15:39,260 --> 00:15:45,450
refactoring code changing types moving

00:15:42,870 --> 00:15:49,350
methods moving classes splitting stuff

00:15:45,450 --> 00:15:51,510
up or all sorts of changes and every

00:15:49,350 --> 00:15:53,130
iteration I will compile I'll get a

00:15:51,510 --> 00:15:57,930
whole screen full or multiple screen

00:15:53,130 --> 00:15:59,850
falls of compiler type errors but once

00:15:57,930 --> 00:16:01,230
I've gone fixed all of those and the

00:15:59,850 --> 00:16:03,030
compiler tells me exactly which line I

00:16:01,230 --> 00:16:06,570
need to go to you to make the fix once

00:16:03,030 --> 00:16:08,730
I've done it it still seems remarkable

00:16:06,570 --> 00:16:11,910
to me that this code will often work

00:16:08,730 --> 00:16:19,080
first time and that is the type system

00:16:11,910 --> 00:16:23,270
that is that is helping you there so

00:16:19,080 --> 00:16:26,190
here's a few specific specific thoughts

00:16:23,270 --> 00:16:28,290
how do we how can we take advantage of

00:16:26,190 --> 00:16:33,920
the type system more than the may breach

00:16:28,290 --> 00:16:37,590
already so avoid if you can referring to

00:16:33,920 --> 00:16:41,280
primitive types like int and and also to

00:16:37,590 --> 00:16:47,550
do two strings strings using a string to

00:16:41,280 --> 00:16:49,620
store data is it's not very precise what

00:16:47,550 --> 00:16:52,440
you have an int what what is the int is

00:16:49,620 --> 00:16:56,640
it is it representing length is it an

00:16:52,440 --> 00:16:59,040
age could we could we actually introduce

00:16:56,640 --> 00:17:01,920
types to represent more precisely what

00:16:59,040 --> 00:17:03,660
the semantic information we're

00:17:01,920 --> 00:17:06,150
representing is rather than just having

00:17:03,660 --> 00:17:11,430
the very generic idea of an int or a

00:17:06,150 --> 00:17:14,339
string or a double you can extend this a

00:17:11,430 --> 00:17:17,100
bit further to to structural types and

00:17:14,339 --> 00:17:21,330
let not lots um not not not structural

00:17:17,100 --> 00:17:22,530
types in the sense of you maybe know the

00:17:21,330 --> 00:17:24,959
feature of scarlet that you can define a

00:17:22,530 --> 00:17:30,240
type in terms of the members structural

00:17:24,959 --> 00:17:33,120
types in terms of examples being option

00:17:30,240 --> 00:17:37,740
option on either and tuples why use a

00:17:33,120 --> 00:17:39,450
tuple when you can use a case class you

00:17:37,740 --> 00:17:41,040
can convey some additional semantic

00:17:39,450 --> 00:17:43,320
information with case class you can give

00:17:41,040 --> 00:17:45,840
it a name you can make that case class

00:17:43,320 --> 00:17:47,940
distinct from another case class with a

00:17:45,840 --> 00:17:49,840
different name you don't get that with

00:17:47,940 --> 00:17:52,510
with two to two different tuples

00:17:49,840 --> 00:17:55,480
as far as the compiler is concerned as

00:17:52,510 --> 00:17:59,610
long as the parameters are all all have

00:17:55,480 --> 00:17:59,610
matching types they are the same type

00:18:01,080 --> 00:18:09,669
and generally I would say set a very low

00:18:06,970 --> 00:18:13,840
bar to introducing new types to your

00:18:09,669 --> 00:18:19,690
code types are cheap debugging is

00:18:13,840 --> 00:18:21,279
expensive if you're representing a

00:18:19,690 --> 00:18:22,539
different concept if you're representing

00:18:21,279 --> 00:18:26,590
something that you have no

00:18:22,539 --> 00:18:33,640
representation for yet maybe a new type

00:18:26,590 --> 00:18:35,679
is is that is the solution and one of

00:18:33,640 --> 00:18:38,950
the most important things about when you

00:18:35,679 --> 00:18:41,799
design types is to ensure that they're

00:18:38,950 --> 00:18:46,840
representing only the states only the

00:18:41,799 --> 00:18:48,880
states of data that are possible don't

00:18:46,840 --> 00:18:53,409
allow your type to represent impossible

00:18:48,880 --> 00:18:54,880
states because if you can't create an in

00:18:53,409 --> 00:18:57,850
if you can't create an instance of that

00:18:54,880 --> 00:18:59,559
type you can't possibly be passing

00:18:57,850 --> 00:19:03,730
around data that is that is impossible

00:18:59,559 --> 00:19:06,970
that is broken you can't your your your

00:19:03,730 --> 00:19:10,659
failure if you have an impossible state

00:19:06,970 --> 00:19:12,279
in some in some in some way your planner

00:19:10,659 --> 00:19:15,070
had fade it happens at the point you try

00:19:12,279 --> 00:19:17,320
to put that data into a value if you

00:19:15,070 --> 00:19:21,580
can't do it if the type can't represent

00:19:17,320 --> 00:19:22,990
it then that is the point you need to

00:19:21,580 --> 00:19:24,429
fix it and you discover that a

00:19:22,990 --> 00:19:33,700
compile-time you don't discover it a

00:19:24,429 --> 00:19:36,090
runtime 11 side note is that especially

00:19:33,700 --> 00:19:39,250
regarding not using primitive types

00:19:36,090 --> 00:19:43,390
obviously primitive types are are faster

00:19:39,250 --> 00:19:47,320
in many circumstances value classes can

00:19:43,390 --> 00:19:49,539
help sometimes with this so if you're

00:19:47,320 --> 00:19:52,690
not familiar with the feature of value

00:19:49,539 --> 00:19:54,909
classes in Scala and performances is

00:19:52,690 --> 00:19:58,059
important you don't have to compromise

00:19:54,909 --> 00:19:59,559
on performance a lot of the time when

00:19:58,059 --> 00:20:02,809
you're representing primitive like

00:19:59,559 --> 00:20:06,200
things with with with

00:20:02,809 --> 00:20:10,399
with other types finding classes may be

00:20:06,200 --> 00:20:11,990
able to help and also not so much

00:20:10,399 --> 00:20:14,570
related to the type system but you can

00:20:11,990 --> 00:20:17,090
also you can also use macros to enforce

00:20:14,570 --> 00:20:20,559
some constraints so I've got an example

00:20:17,090 --> 00:20:24,679
here from from rapture of the

00:20:20,559 --> 00:20:28,730
representation i use for CSS is anyone

00:20:24,679 --> 00:20:34,610
here to any web programming you lucky

00:20:28,730 --> 00:20:37,879
Bunch you are probably at least aware

00:20:34,610 --> 00:20:41,960
that styles on on web pages are

00:20:37,879 --> 00:20:43,460
generally very written in CSS and I have

00:20:41,960 --> 00:20:47,299
a type in Scott in enraptured

00:20:43,460 --> 00:20:49,429
representing CSS and this here I don't

00:20:47,299 --> 00:20:52,820
even see the pointer this this looks

00:20:49,429 --> 00:20:56,990
like a string but it is prefixed with

00:20:52,820 --> 00:21:00,799
CSS now what this does is this is like

00:20:56,990 --> 00:21:02,360
the interpreter strings with a way we

00:21:00,799 --> 00:21:05,720
prefix string with an S and it will

00:21:02,360 --> 00:21:07,240
substitute values inside that I've

00:21:05,720 --> 00:21:10,340
prefixed it with CSS which actually

00:21:07,240 --> 00:21:12,649
invokes a macro on the contents of this

00:21:10,340 --> 00:21:16,009
string literal here and what that will

00:21:12,649 --> 00:21:18,679
do at compile time is read through this

00:21:16,009 --> 00:21:20,720
text here and it will pass it and it

00:21:18,679 --> 00:21:25,789
will check that border color is a valid

00:21:20,720 --> 00:21:29,299
CSS a true name it'll it'll validate

00:21:25,789 --> 00:21:33,019
that border width is is exists as well

00:21:29,299 --> 00:21:38,869
if you were if for example you wrote

00:21:33,019 --> 00:21:40,490
border WI DHT you made a simple simple

00:21:38,869 --> 00:21:42,710
spelling mistake that's a compile error

00:21:40,490 --> 00:21:45,740
you find out a compile-time you don't

00:21:42,710 --> 00:21:48,110
find out when you you produce the CSS

00:21:45,740 --> 00:21:51,490
stylesheet and your your border with is

00:21:48,110 --> 00:21:51,490
the wrong the wrong value

00:21:54,940 --> 00:22:02,800
as API designers you should be thinking

00:21:58,540 --> 00:22:07,750
about the user experience the users are

00:22:02,800 --> 00:22:12,970
programmers and many of the same ideas

00:22:07,750 --> 00:22:14,950
that exist in in UX design completely

00:22:12,970 --> 00:22:16,570
different discipline or largely

00:22:14,950 --> 00:22:19,000
different discipline from from

00:22:16,570 --> 00:22:22,660
programming many of the same principles

00:22:19,000 --> 00:22:25,000
apply equally maybe maybe they need to

00:22:22,660 --> 00:22:27,250
be contorted a little bit too to fit the

00:22:25,000 --> 00:22:33,250
domain but many of the same ideas will

00:22:27,250 --> 00:22:36,040
apply to designing api's the people

00:22:33,250 --> 00:22:37,510
using your your users are our our

00:22:36,040 --> 00:22:40,510
programmers so you can make you can make

00:22:37,510 --> 00:22:45,550
some some guesses as to their

00:22:40,510 --> 00:22:47,590
expectations and also within within

00:22:45,550 --> 00:22:48,490
their expectations that there are there

00:22:47,590 --> 00:22:52,540
are different users with different

00:22:48,490 --> 00:22:55,480
abilities and you can take advantage of

00:22:52,540 --> 00:22:57,280
these you can you can presume certain

00:22:55,480 --> 00:22:58,420
things about your users they have

00:22:57,280 --> 00:23:01,050
certain expectations they have

00:22:58,420 --> 00:23:03,100
familiarity with with certain ideas and

00:23:01,050 --> 00:23:06,460
sometimes you should take advantage of

00:23:03,100 --> 00:23:09,610
those you should you should try and have

00:23:06,460 --> 00:23:13,570
some it comes down in in some sense to

00:23:09,610 --> 00:23:15,550
having emotional intelligence about what

00:23:13,570 --> 00:23:16,930
your users will experience when they

00:23:15,550 --> 00:23:18,520
when they see your library when they

00:23:16,930 --> 00:23:23,080
when they try to use your API what their

00:23:18,520 --> 00:23:24,370
expectations are sometimes you need to

00:23:23,080 --> 00:23:28,260
kind of go against the grain a little

00:23:24,370 --> 00:23:33,010
bit sometimes you can acknowledge that

00:23:28,260 --> 00:23:36,220
the the status quo of people or the

00:23:33,010 --> 00:23:40,810
general understanding is wrong or maybe

00:23:36,220 --> 00:23:43,630
just not perfect and you need to you

00:23:40,810 --> 00:23:46,270
need to you need to educate people you

00:23:43,630 --> 00:23:50,500
need to go against the the common wisdom

00:23:46,270 --> 00:23:55,120
and actually say we're doing it this way

00:23:50,500 --> 00:23:57,670
because some some reason which you you

00:23:55,120 --> 00:24:00,100
you can hopefully justify but but don't

00:23:57,670 --> 00:24:03,430
don't do what other people to simply

00:24:00,100 --> 00:24:05,650
because other people to it do do what's

00:24:03,430 --> 00:24:07,680
right go against the grain when you need

00:24:05,650 --> 00:24:07,680
to

00:24:08,270 --> 00:24:12,960
you should keep boilerplate to to omit

00:24:11,460 --> 00:24:15,930
them I mean you own that you all know

00:24:12,960 --> 00:24:17,610
this everyone hates boilerplate it's

00:24:15,930 --> 00:24:21,930
it's frustrating to write it's

00:24:17,610 --> 00:24:25,260
frustrating to maintain so every line in

00:24:21,930 --> 00:24:27,210
your code every every line you write

00:24:25,260 --> 00:24:29,190
every line you read should have some

00:24:27,210 --> 00:24:30,990
significant meaning I mean maybe that

00:24:29,190 --> 00:24:33,030
meaning changes the context maybe it's

00:24:30,990 --> 00:24:35,940
an import which which changes the

00:24:33,030 --> 00:24:42,270
context of the the the the subsequent

00:24:35,940 --> 00:24:44,310
code maybe it's calling some side

00:24:42,270 --> 00:24:45,480
affecting operation but but every line

00:24:44,310 --> 00:24:52,260
should be significant it shouldn't just

00:24:45,480 --> 00:24:59,090
be perfunctory code which which exists

00:24:52,260 --> 00:25:04,080
only to satisfy the the the the compiler

00:24:59,090 --> 00:25:12,540
and there's anyone here programmed in

00:25:04,080 --> 00:25:16,650
COBOL come on any more of you I think

00:25:12,540 --> 00:25:20,220
this may be 33 hands so so kobold was

00:25:16,650 --> 00:25:24,390
designed to to be very readable to be or

00:25:20,220 --> 00:25:28,440
to ordinary people and he would write

00:25:24,390 --> 00:25:31,860
code like at 72 x I think I never read

00:25:28,440 --> 00:25:33,600
nico ball but I saw some once and that's

00:25:31,860 --> 00:25:35,130
all I remember and it was very very

00:25:33,600 --> 00:25:36,330
verbose but you could you could look at

00:25:35,130 --> 00:25:38,070
it you could read it and you could

00:25:36,330 --> 00:25:41,700
understand what it was doing it was in

00:25:38,070 --> 00:25:44,430
plain english and the libraries and

00:25:41,700 --> 00:25:46,050
api's that we designed should should try

00:25:44,430 --> 00:25:49,140
and do the same thing I mean not

00:25:46,050 --> 00:25:53,520
necessarily converting into into English

00:25:49,140 --> 00:25:55,530
prose the operations you're doing but

00:25:53,520 --> 00:25:56,700
you should be able to to to read it

00:25:55,530 --> 00:25:59,090
without much knowledge of the language

00:25:56,700 --> 00:26:02,520
and have an idea as to what is happening

00:25:59,090 --> 00:26:04,220
that that's very very desirable so I'm

00:26:02,520 --> 00:26:09,420
very quickly going to run through some

00:26:04,220 --> 00:26:12,390
some usability heuristics draw parallels

00:26:09,420 --> 00:26:14,160
with the real world' real world' try and

00:26:12,390 --> 00:26:17,220
associate things in your code with with

00:26:14,160 --> 00:26:21,870
things in in real life consistency and

00:26:17,220 --> 00:26:24,909
standards error prevention these are all

00:26:21,870 --> 00:26:28,779
what what what I'm calling heuristics

00:26:24,909 --> 00:26:33,760
for for usability recognition not recall

00:26:28,779 --> 00:26:35,890
so in in a in a program in context this

00:26:33,760 --> 00:26:38,590
maybe means recognizing what a method

00:26:35,890 --> 00:26:42,190
does not so much by its name which you

00:26:38,590 --> 00:26:43,360
can recall but by the type the return

00:26:42,190 --> 00:26:46,480
type the types of the parameters

00:26:43,360 --> 00:26:50,230
recognize the the method by its shape

00:26:46,480 --> 00:26:52,600
not by its by its name flexibility and

00:26:50,230 --> 00:26:58,059
efficiency of use aesthetic and

00:26:52,600 --> 00:26:59,470
minimalist design these written in a

00:26:58,059 --> 00:27:02,740
blog post which has nothing to do with

00:26:59,470 --> 00:27:04,779
programming these came straight from 10

00:27:02,740 --> 00:27:07,720
usability heuristics for user interface

00:27:04,779 --> 00:27:10,840
design but reading for that list a lot

00:27:07,720 --> 00:27:13,090
of these seem very very applicable to 22

00:27:10,840 --> 00:27:15,909
programming in Scala i think the word

00:27:13,090 --> 00:27:17,710
vote there were 10 of them and I've got

00:27:15,909 --> 00:27:20,740
I've got six seven other four weren't so

00:27:17,710 --> 00:27:25,600
relevant but we did at least fine fine

00:27:20,740 --> 00:27:28,240
six now one thing I do when I'm when I'm

00:27:25,600 --> 00:27:34,330
designing a library is I want to

00:27:28,240 --> 00:27:36,850
optimize my my code for the you cite the

00:27:34,330 --> 00:27:38,980
complexity should go in the library so

00:27:36,850 --> 00:27:43,029
that the so the users of that library

00:27:38,980 --> 00:27:45,149
benefit the most I don't want to force

00:27:43,029 --> 00:27:47,289
my my end users to write boilerplate

00:27:45,149 --> 00:27:53,710
just to make my job as a library

00:27:47,289 --> 00:27:56,140
designer easier and one way I do this is

00:27:53,710 --> 00:27:58,210
to first think about the code i want to

00:27:56,140 --> 00:28:02,679
write at the use site and i'll write

00:27:58,210 --> 00:28:04,330
some sample code i will and you the more

00:28:02,679 --> 00:28:06,010
experience you have at this the better

00:28:04,330 --> 00:28:09,010
you get at doing it doing it right first

00:28:06,010 --> 00:28:11,110
time or second time but first of all

00:28:09,010 --> 00:28:13,179
right write down some code that won't

00:28:11,110 --> 00:28:14,770
compile because it's got no it's calling

00:28:13,179 --> 00:28:19,419
a prize which don't exist but but write

00:28:14,770 --> 00:28:21,610
it down and make make sure it term it

00:28:19,419 --> 00:28:24,970
meets as many of those heuristics on the

00:28:21,610 --> 00:28:26,350
previous sliders as you can maybe also

00:28:24,970 --> 00:28:28,899
write some code you don't want to

00:28:26,350 --> 00:28:30,549
compile write write some code that you

00:28:28,899 --> 00:28:32,380
expect to fail and that you want the

00:28:30,549 --> 00:28:34,940
compiler to help you catch

00:28:32,380 --> 00:28:40,150
and then then try and fill in the

00:28:34,940 --> 00:28:42,410
definitions that make it work and

00:28:40,150 --> 00:28:45,050
iterate when it doesn't work maybe you

00:28:42,410 --> 00:28:46,430
have to after a while you you persevere

00:28:45,050 --> 00:28:48,500
for a long time trying to get your

00:28:46,430 --> 00:28:49,970
definitions to to compile your sample

00:28:48,500 --> 00:28:51,800
code maybe the times when you have to

00:28:49,970 --> 00:28:55,250
compromise you have to say well actually

00:28:51,800 --> 00:28:58,370
it's not possible to write by my end

00:28:55,250 --> 00:29:00,830
user code exactly like this so change it

00:28:58,370 --> 00:29:03,650
a little bit change change the change

00:29:00,830 --> 00:29:07,070
the dsl slightly and then have another

00:29:03,650 --> 00:29:11,720
go and this is a little bit like test

00:29:07,070 --> 00:29:14,050
first development except except test

00:29:11,720 --> 00:29:17,660
first development is typically testing

00:29:14,050 --> 00:29:20,090
the methods do the right thing at

00:29:17,660 --> 00:29:23,830
runtime we're not so concerned about

00:29:20,090 --> 00:29:29,390
that I mean I'm if things can pile on I

00:29:23,830 --> 00:29:32,500
think they probably work which is which

00:29:29,390 --> 00:29:35,450
is one reason why they often don't but

00:29:32,500 --> 00:29:40,580
the hardest bit is often getting them to

00:29:35,450 --> 00:29:42,380
to compile and it I'm being I'm being

00:29:40,580 --> 00:29:44,630
quite frivolous with that that comment

00:29:42,380 --> 00:29:47,180
but a lot of the time if you if you can

00:29:44,630 --> 00:29:49,370
get the types to work if you can get

00:29:47,180 --> 00:29:51,110
this compile getting it to work at

00:29:49,370 --> 00:29:58,640
runtime does actually become very

00:29:51,110 --> 00:30:00,170
trivial so I I very much promote you

00:29:58,640 --> 00:30:03,290
site first as I know I'll show an

00:30:00,170 --> 00:30:05,930
example of one library that was part of

00:30:03,290 --> 00:30:08,630
rapture where I did this I wanted to

00:30:05,930 --> 00:30:12,440
represent HTML to go with my CSS of

00:30:08,630 --> 00:30:14,480
course and I wanted to make it look like

00:30:12,440 --> 00:30:19,730
this this is this is this is some code I

00:30:14,480 --> 00:30:21,680
wrote before I wrote or similar to some

00:30:19,730 --> 00:30:26,030
code I wrote before I wrote the library

00:30:21,680 --> 00:30:28,070
I wanted to be able to write HTML tags

00:30:26,030 --> 00:30:29,720
with a head tag and a body tag but I

00:30:28,070 --> 00:30:35,650
wanted to look like method calls I

00:30:29,720 --> 00:30:38,960
wanted to have for example P tag with a

00:30:35,650 --> 00:30:42,760
style attribute there I wanted content

00:30:38,960 --> 00:30:42,760
to go inside that as a string

00:30:43,600 --> 00:30:50,020
and I went ahead I've worked for several

00:30:47,799 --> 00:30:52,690
days and I managed to get this to

00:30:50,020 --> 00:30:56,080
compile and you see we've got the the

00:30:52,690 --> 00:30:58,570
type safe CSS in there on that on the

00:30:56,080 --> 00:31:00,340
style tag as well and I I managed to get

00:30:58,570 --> 00:31:05,140
this to compile after after a lot of

00:31:00,340 --> 00:31:06,789
work additionally we do some additional

00:31:05,140 --> 00:31:11,620
checking on here that that's not obvious

00:31:06,789 --> 00:31:14,880
from the sample but the library will

00:31:11,620 --> 00:31:19,080
check that the tags you nest inside

00:31:14,880 --> 00:31:22,210
other tags are valid in that position I

00:31:19,080 --> 00:31:25,690
implemented the html5 spec in the type

00:31:22,210 --> 00:31:28,150
system you can put a head inside an HTML

00:31:25,690 --> 00:31:30,190
you can put a body inside HTML you can

00:31:28,150 --> 00:31:32,110
put a title inside a body that doesn't

00:31:30,190 --> 00:31:36,130
work it's compiler you get a you get a

00:31:32,110 --> 00:31:38,590
net an error message so that that was

00:31:36,130 --> 00:31:41,919
that was the consequence of writing

00:31:38,590 --> 00:31:44,049
writing these these these these samples

00:31:41,919 --> 00:31:45,610
first and then trying to compile them

00:31:44,049 --> 00:31:47,590
and then then trying to make sure that

00:31:45,610 --> 00:31:52,110
the the failure case is definitely

00:31:47,590 --> 00:31:55,690
failed I use this as an example because

00:31:52,110 --> 00:32:01,120
it was a lot of work to make this kind

00:31:55,690 --> 00:32:04,210
of syntax work I had to use a set of

00:32:01,120 --> 00:32:07,590
syntax which may be many of you don't

00:32:04,210 --> 00:32:11,770
know Scala has this syntax for defining

00:32:07,590 --> 00:32:15,549
setters look it up it's been Scala since

00:32:11,770 --> 00:32:17,620
since the very early days varargs I had

00:32:15,549 --> 00:32:20,820
to use implicit parameters that was

00:32:17,620 --> 00:32:24,220
feature i used implicit conversions I

00:32:20,820 --> 00:32:28,270
needed chained in places I had to use

00:32:24,220 --> 00:32:30,909
existential types I had to use both use

00:32:28,270 --> 00:32:34,780
site and definition site variants this

00:32:30,909 --> 00:32:37,480
is all in the same library I use

00:32:34,780 --> 00:32:38,770
dependent method types I can't but how

00:32:37,480 --> 00:32:42,520
many more of these singles and types we

00:32:38,770 --> 00:32:44,620
use every almost everything everything

00:32:42,520 --> 00:32:47,500
went in here and and because because

00:32:44,620 --> 00:32:50,799
that didn't work by itself I just hacked

00:32:47,500 --> 00:32:53,340
it until it did and all of this log

00:32:50,799 --> 00:32:56,610
combined gave me this HTML library and

00:32:53,340 --> 00:32:56,610
it works

00:32:59,129 --> 00:33:06,190
some chick I'm short on time aren't I

00:33:03,729 --> 00:33:13,769
got 10 minutes I'm going to skip over

00:33:06,190 --> 00:33:19,119
this point 5 and go straight two point

00:33:13,769 --> 00:33:22,899
six map modularity modularity well first

00:33:19,119 --> 00:33:25,509
I'll define it how easily can components

00:33:22,899 --> 00:33:30,309
be separated and recombined that's the

00:33:25,509 --> 00:33:35,589
dictionary helping me out again type

00:33:30,309 --> 00:33:37,809
classes are the one word solution to or

00:33:35,589 --> 00:33:43,719
as close as we have to a solution to two

00:33:37,809 --> 00:33:51,209
modularity use type classes as much as

00:33:43,719 --> 00:33:56,049
you can I I can't in term in terms of

00:33:51,209 --> 00:34:00,519
specific concrete ideas go first type

00:33:56,049 --> 00:34:02,739
glasses forget inheritance it's it take

00:34:00,519 --> 00:34:08,379
me 10 years to to start thinking like

00:34:02,739 --> 00:34:12,789
this and I I normally I normally jump

00:34:08,379 --> 00:34:15,579
straight to using type classes rather

00:34:12,789 --> 00:34:18,460
than rather than overloading rather than

00:34:15,579 --> 00:34:21,460
in inheritance and a few other places

00:34:18,460 --> 00:34:22,839
that they they can apply as well so not

00:34:21,460 --> 00:34:24,399
everybody put their hand up when I asked

00:34:22,839 --> 00:34:26,619
about thai plaster so i'll give a very

00:34:24,399 --> 00:34:29,849
brief overview of one reason why they're

00:34:26,619 --> 00:34:29,849
they give you a lot more flexibility

00:34:30,029 --> 00:34:34,720
imagine we're writing a we've got a

00:34:32,679 --> 00:34:36,490
project which i'll say this is this is

00:34:34,720 --> 00:34:40,029
your project you ought you're writing a

00:34:36,490 --> 00:34:45,039
JSON library because who isn't these

00:34:40,029 --> 00:34:47,169
days and from your your Jason project

00:34:45,039 --> 00:34:49,450
has dependencies these are the the

00:34:47,169 --> 00:34:51,159
upstream projects and maybe in the

00:34:49,450 --> 00:34:55,720
upstream projects for example the

00:34:51,159 --> 00:34:58,720
standard library a type like string is

00:34:55,720 --> 00:35:01,420
to find we're defining jason and then

00:34:58,720 --> 00:35:03,819
people using our library would maybe

00:35:01,420 --> 00:35:06,950
define a type like invoice we're going

00:35:03,819 --> 00:35:09,619
to represent invoices in in Jason

00:35:06,950 --> 00:35:12,020
so I think it's fundamental when you're

00:35:09,619 --> 00:35:13,670
trying to understand the relevance of

00:35:12,020 --> 00:35:15,260
type classes and why that why they're

00:35:13,670 --> 00:35:21,230
beneficial is you think in terms of

00:35:15,260 --> 00:35:26,329
upstream and downstream dependencies now

00:35:21,230 --> 00:35:27,829
using inheritance we could define the

00:35:26,329 --> 00:35:30,619
capability of being able to write

00:35:27,829 --> 00:35:34,220
something to be able to write your your

00:35:30,619 --> 00:35:36,829
your data or your your type somewhere

00:35:34,220 --> 00:35:38,660
maybe you're writing it to disk imagine

00:35:36,829 --> 00:35:42,020
that's what what writable means in this

00:35:38,660 --> 00:35:44,780
in this context if we wanted to make our

00:35:42,020 --> 00:35:45,920
JSON type writable using inheritance we

00:35:44,780 --> 00:35:48,829
would just extend something called

00:35:45,920 --> 00:35:51,829
writable that's how we would say that

00:35:48,829 --> 00:35:55,190
Jason stuff is writable and we would

00:35:51,829 --> 00:35:56,359
define that in the Jason project in our

00:35:55,190 --> 00:35:58,700
down screen project if you wanted to

00:35:56,359 --> 00:36:02,960
make invoice is writable then we could

00:35:58,700 --> 00:36:07,700
extend writable and an hour invoices

00:36:02,960 --> 00:36:11,720
would be writable now we can't we can't

00:36:07,700 --> 00:36:13,750
down here say that Jason is writable so

00:36:11,720 --> 00:36:17,470
if the person who wrote the JSON library

00:36:13,750 --> 00:36:20,119
didn't anticipate right ability of Jason

00:36:17,470 --> 00:36:21,589
then there's no way down here in our

00:36:20,119 --> 00:36:24,920
downstream project to actually say that

00:36:21,589 --> 00:36:26,510
Jason is writable and we can't ever say

00:36:24,920 --> 00:36:31,010
that strings are writable because they

00:36:26,510 --> 00:36:33,170
don't inherit this writable trade so

00:36:31,010 --> 00:36:35,300
we're limited in growing movie we can't

00:36:33,170 --> 00:36:39,650
we can't retrofit these capabilities to

00:36:35,300 --> 00:36:42,890
two types we don't already own now with

00:36:39,650 --> 00:36:47,089
type classes we can define a a writer

00:36:42,890 --> 00:36:48,619
type class and in our Jason project we

00:36:47,089 --> 00:36:50,510
can define a writer for Jason but we can

00:36:48,619 --> 00:36:53,060
also go back and define a writer for

00:36:50,510 --> 00:36:56,660
Strings even though we didn't define

00:36:53,060 --> 00:37:00,800
string string is in there in the in the

00:36:56,660 --> 00:37:04,060
Java standard library we can still

00:37:00,800 --> 00:37:07,579
define a writer in our Jason project

00:37:04,060 --> 00:37:10,369
going downstream to our somebody else's

00:37:07,579 --> 00:37:11,780
in invoice projects they can take him to

00:37:10,369 --> 00:37:14,060
find the writer for invoices they can

00:37:11,780 --> 00:37:15,740
define the writer for Jason they can

00:37:14,060 --> 00:37:17,150
find the right of the screen and it

00:37:15,740 --> 00:37:18,290
doesn't just apply to write it you can

00:37:17,150 --> 00:37:20,390
you can have any number of different

00:37:18,290 --> 00:37:24,799
capabilities represented by type

00:37:20,390 --> 00:37:35,299
and you have the flexibility of adding

00:37:24,799 --> 00:37:39,410
that capability to existing types so the

00:37:35,299 --> 00:37:42,440
idea is that tie + allow you to separate

00:37:39,410 --> 00:37:44,450
data types from the capabilities that

00:37:42,440 --> 00:37:49,220
they have you can define them in

00:37:44,450 --> 00:37:51,740
different projects at different times we

00:37:49,220 --> 00:37:54,950
can take this little step further and

00:37:51,740 --> 00:37:57,529
use extension methods extension methods

00:37:54,950 --> 00:37:58,730
aren't aren't really a feature in their

00:37:57,529 --> 00:38:02,180
own right in skul it's just an

00:37:58,730 --> 00:38:07,549
application of it to patent if you like

00:38:02,180 --> 00:38:09,710
of use using implicit to to add if it

00:38:07,549 --> 00:38:11,119
looks like you add methods to types that

00:38:09,710 --> 00:38:16,309
weren't designed with those methods

00:38:11,119 --> 00:38:18,260
originally you extend them we we do this

00:38:16,309 --> 00:38:22,369
in Scala with with implicit that's

00:38:18,260 --> 00:38:29,660
that's the means and generally we're

00:38:22,369 --> 00:38:32,089
providing more more way it's ad hoc

00:38:29,660 --> 00:38:34,960
polymorphism for all four types it's not

00:38:32,089 --> 00:38:40,730
it's not polymorphism defined by

00:38:34,960 --> 00:38:43,640
subtyping and key key point is you can

00:38:40,730 --> 00:38:48,339
retrofit this functionality to to two

00:38:43,640 --> 00:38:50,869
types that that you don't own or control

00:38:48,339 --> 00:38:56,660
I'm going to skip over this because

00:38:50,869 --> 00:39:06,609
we're short on time and i will also skip

00:38:56,660 --> 00:39:06,609
2.8 you're not missing much don't worry

00:39:06,880 --> 00:39:12,769
back-to-back two types and and and how

00:39:09,980 --> 00:39:16,579
much i love types / values you should as

00:39:12,769 --> 00:39:18,890
much as possible prefer types give your

00:39:16,579 --> 00:39:21,140
give forgive the compiler more

00:39:18,890 --> 00:39:22,430
information at compile time it can't

00:39:21,140 --> 00:39:25,549
help you about the stuff it doesn't know

00:39:22,430 --> 00:39:29,029
about it can't help you with information

00:39:25,549 --> 00:39:31,250
that's only available at runtime so if

00:39:29,029 --> 00:39:33,200
you can promote a value to a type and

00:39:31,250 --> 00:39:34,309
i'll show you how this could potentially

00:39:33,200 --> 00:39:38,239
work later

00:39:34,309 --> 00:39:40,459
if you can pro to value to a type then

00:39:38,239 --> 00:39:43,249
there is a chance that the compiler can

00:39:40,459 --> 00:39:45,650
help you and that's something you should

00:39:43,249 --> 00:39:48,019
you should take advantage of its type

00:39:45,650 --> 00:39:51,259
level programming basically it's not

00:39:48,019 --> 00:39:53,599
your you're taking failures away from

00:39:51,259 --> 00:39:57,799
runtime and converting them into compile

00:39:53,599 --> 00:40:02,660
errors H lists are a well-known example

00:39:57,799 --> 00:40:07,670
of type level programming and scholar

00:40:02,660 --> 00:40:09,859
has currently some limited support for

00:40:07,670 --> 00:40:12,529
singles and types so this is a type

00:40:09,859 --> 00:40:15,589
representing an exact value like a

00:40:12,529 --> 00:40:17,390
string so the string foo in quotes has a

00:40:15,589 --> 00:40:19,099
type associated with it there's only one

00:40:17,390 --> 00:40:22,670
instance of that type it's the value foo

00:40:19,099 --> 00:40:24,199
as a string but there's a type a singles

00:40:22,670 --> 00:40:26,779
and type representing that and that's

00:40:24,199 --> 00:40:28,160
that's a feature of Scarlett it's little

00:40:26,779 --> 00:40:32,630
bit complicated access at the moment it

00:40:28,160 --> 00:40:34,969
might become easier in the future but at

00:40:32,630 --> 00:40:38,119
the moment it's it's usable and there

00:40:34,969 --> 00:40:40,640
are things we can do with it of course

00:40:38,119 --> 00:40:43,699
we can't completely eliminate runtime

00:40:40,640 --> 00:40:46,699
values and this we write a very boring

00:40:43,699 --> 00:40:49,309
completely deterministic program we have

00:40:46,699 --> 00:40:51,529
inputs so there's no there's no silver

00:40:49,309 --> 00:40:56,569
bullet here you still have to work with

00:40:51,529 --> 00:40:58,459
some dynamic dynamic data so here's an

00:40:56,569 --> 00:41:01,489
example of what would I described before

00:40:58,459 --> 00:41:03,529
is promoting a value to a type this is

00:41:01,489 --> 00:41:07,039
from the internationalisation library in

00:41:03,529 --> 00:41:08,689
rapture which allows you to have a

00:41:07,039 --> 00:41:14,449
representation of an internationalized

00:41:08,689 --> 00:41:17,119
string now this this string here we use

00:41:14,449 --> 00:41:18,769
the string context again and I've got

00:41:17,119 --> 00:41:20,869
different different string context

00:41:18,769 --> 00:41:23,809
representing dozens of different

00:41:20,869 --> 00:41:27,859
languages so this is an English string

00:41:23,809 --> 00:41:29,869
en says hello world and I'm combining it

00:41:27,859 --> 00:41:35,059
with the the ampersand with a French

00:41:29,869 --> 00:41:37,099
string board or the Monde and we combine

00:41:35,059 --> 00:41:39,619
them into a single value message so the

00:41:37,099 --> 00:41:44,239
messages saying hello and we we can have

00:41:39,619 --> 00:41:46,339
an English and French version now we can

00:41:44,239 --> 00:41:48,030
try and access this is this like a map

00:41:46,339 --> 00:41:51,240
think of it as a map

00:41:48,030 --> 00:41:56,310
from from language to to do an actual

00:41:51,240 --> 00:41:58,530
string we call message en now notice

00:41:56,310 --> 00:42:02,280
that the en is in square brackets that's

00:41:58,530 --> 00:42:03,840
because ian is a type here and the type

00:42:02,280 --> 00:42:05,850
of message which is inferred we don't

00:42:03,840 --> 00:42:08,700
have to specify the type but it'll be

00:42:05,850 --> 00:42:10,230
inferred knows that because it was

00:42:08,700 --> 00:42:11,700
created from combining english stream

00:42:10,230 --> 00:42:16,260
with the French string that it is a

00:42:11,700 --> 00:42:18,990
message an insert five string of English

00:42:16,260 --> 00:42:21,330
and French that is encoded in the type

00:42:18,990 --> 00:42:23,580
which which we don't see but it's it's

00:42:21,330 --> 00:42:24,660
there the type system knows about it so

00:42:23,580 --> 00:42:26,670
when we try and access the English

00:42:24,660 --> 00:42:30,000
version and print it out that's fine

00:42:26,670 --> 00:42:33,240
that works if we try to access the

00:42:30,000 --> 00:42:35,490
German version this is not a runtime

00:42:33,240 --> 00:42:38,250
error it's a compile error so this is an

00:42:35,490 --> 00:42:42,270
example of promoting what would

00:42:38,250 --> 00:42:49,400
typically be a value to a a compile-time

00:42:42,270 --> 00:42:53,640
checked type so that those those worthy

00:42:49,400 --> 00:42:55,950
those were that I do 706 of the of the

00:42:53,640 --> 00:42:58,200
eight principles it was a different it

00:42:55,950 --> 00:42:59,520
was a different six from the six I did

00:42:58,200 --> 00:43:03,450
in New York when I ran out of time as

00:42:59,520 --> 00:43:08,430
well there are some hurdles and caveats

00:43:03,450 --> 00:43:10,290
to point out on on these a lot of this

00:43:08,430 --> 00:43:13,980
is difficult and that the tooling isn't

00:43:10,290 --> 00:43:15,690
great so we have for example situations

00:43:13,980 --> 00:43:17,460
where there's an implicit being used

00:43:15,690 --> 00:43:18,630
from somewhere and we just looking at

00:43:17,460 --> 00:43:23,160
the code you can't see where it comes

00:43:18,630 --> 00:43:25,140
from we can ask questions like what do I

00:43:23,160 --> 00:43:26,730
need to do to what would I need to

00:43:25,140 --> 00:43:28,260
import to get an implicit that will

00:43:26,730 --> 00:43:32,490
satisfy this method that's asking for

00:43:28,260 --> 00:43:34,170
one we don't have we don't yet have good

00:43:32,490 --> 00:43:37,830
solutions to this but it's an area where

00:43:34,170 --> 00:43:40,920
we're tooling can help and also there's

00:43:37,830 --> 00:43:44,850
the implicit not found annotation we if

00:43:40,920 --> 00:43:46,980
we have a type that is being used as for

00:43:44,850 --> 00:43:49,560
for implicit parameters we can annotate

00:43:46,980 --> 00:43:50,850
they the definition of that type with

00:43:49,560 --> 00:43:54,450
implicit not found that will get a

00:43:50,850 --> 00:43:55,950
custom error message that can maybe give

00:43:54,450 --> 00:43:57,630
advice on on what you need to import

00:43:55,950 --> 00:44:00,230
this is what happens if you try to use a

00:43:57,630 --> 00:44:03,300
future without importing

00:44:00,230 --> 00:44:04,620
the the necessary packages and I can

00:44:03,300 --> 00:44:06,120
never remember the packages are so I

00:44:04,620 --> 00:44:08,730
just try and use the future and then

00:44:06,120 --> 00:44:13,230
copy paste the copy paste the import

00:44:08,730 --> 00:44:16,530
that i need and obviously improving

00:44:13,230 --> 00:44:20,610
documentation and hauling wood would

00:44:16,530 --> 00:44:23,250
help there this is possibly of naming

00:44:20,610 --> 00:44:28,920
conflicts i had one of the principles as

00:44:23,250 --> 00:44:32,100
naming stuff is is difficult and the

00:44:28,920 --> 00:44:35,340
chance of having a clash with 22

00:44:32,100 --> 00:44:40,470
different libraries is real but it's

00:44:35,340 --> 00:44:41,580
it's um also infrequent but it's kind of

00:44:40,470 --> 00:44:43,710
a problem if you have two libraries

00:44:41,580 --> 00:44:45,660
which define a type that has the same

00:44:43,710 --> 00:44:48,090
name that does different things any want

00:44:45,660 --> 00:44:50,970
to use those two libraries in some other

00:44:48,090 --> 00:44:52,080
project there's a conflict and maybe

00:44:50,970 --> 00:44:54,500
something's got to give one of those

00:44:52,080 --> 00:44:56,790
libraries has to has to change its name

00:44:54,500 --> 00:44:58,860
otay gentle name of that particular type

00:44:56,790 --> 00:45:00,660
but it's an evolutionary process it will

00:44:58,860 --> 00:45:05,730
it will happen slowly the ecosystem will

00:45:00,660 --> 00:45:10,410
we'll deal with it now I mentioned for

00:45:05,730 --> 00:45:12,510
that types often get inferred and we

00:45:10,410 --> 00:45:16,380
don't have to see the types types get

00:45:12,510 --> 00:45:18,390
inferred they conferred for return types

00:45:16,380 --> 00:45:22,980
types get inferred for type parameters

00:45:18,390 --> 00:45:25,890
and it's kind of convenient if we're

00:45:22,980 --> 00:45:28,860
working with large complex structured

00:45:25,890 --> 00:45:29,820
types it's convenient that we don't see

00:45:28,860 --> 00:45:32,820
them a lot of the time that we never

00:45:29,820 --> 00:45:37,590
have to write them down in certain in

00:45:32,820 --> 00:45:40,230
certain cases but they'll get exposed

00:45:37,590 --> 00:45:45,060
when we have a type mismatch if we try

00:45:40,230 --> 00:45:47,570
to use the wrong kind of H list in when

00:45:45,060 --> 00:45:51,360
a different age list is it is expected

00:45:47,570 --> 00:45:53,640
that's a type error it's quite quite

00:45:51,360 --> 00:45:55,170
correctly a type error but it's actually

00:45:53,640 --> 00:45:59,250
quite hard to read those error messages

00:45:55,170 --> 00:46:02,160
and work out what mistake we made and to

00:45:59,250 --> 00:46:06,450
know how to fix it so this is a question

00:46:02,160 --> 00:46:09,270
can we can we do better than this so I'm

00:46:06,450 --> 00:46:12,950
overtime but I'm still going through one

00:46:09,270 --> 00:46:19,170
one weird trick to to give you nicer

00:46:12,950 --> 00:46:23,220
type error messages so first of all look

00:46:19,170 --> 00:46:25,020
at the type you find find find the

00:46:23,220 --> 00:46:28,880
subset of types in your in your system

00:46:25,020 --> 00:46:31,050
that you want to that you want to handle

00:46:28,880 --> 00:46:35,070
that you want to handle the mismatches

00:46:31,050 --> 00:46:37,860
for and then write a write an implicit

00:46:35,070 --> 00:46:39,900
conversion from from one type to the

00:46:37,860 --> 00:46:44,610
other from from the bad type to the good

00:46:39,900 --> 00:46:49,410
type so this in itself won't solve the

00:46:44,610 --> 00:46:51,690
problem what we need to do I mean it'll

00:46:49,410 --> 00:46:53,040
it'll make a compile sure your coke will

00:46:51,690 --> 00:46:54,960
compile then depending on your

00:46:53,040 --> 00:46:57,990
implementation label which is presumably

00:46:54,960 --> 00:46:59,970
to implement it with with Mel or triple

00:46:57,990 --> 00:47:01,230
? it will fail at runtime so we need see

00:46:59,970 --> 00:47:04,320
Morgan is we need to implement it with a

00:47:01,230 --> 00:47:05,880
macro so we've got that it that implicit

00:47:04,320 --> 00:47:08,040
which will convert from bad type to the

00:47:05,880 --> 00:47:10,740
good type and we going to implement it

00:47:08,040 --> 00:47:13,560
with a macro and the macro will then

00:47:10,740 --> 00:47:14,940
look at the parameter type of that

00:47:13,560 --> 00:47:17,400
implicit conversion and it'll look at

00:47:14,940 --> 00:47:19,980
the expected return type of the implicit

00:47:17,400 --> 00:47:23,670
conversion and when the macro gets

00:47:19,980 --> 00:47:28,530
instantiated we can see those types we

00:47:23,670 --> 00:47:30,210
can distract them we can work out I mean

00:47:28,530 --> 00:47:32,310
it's a bit of work to dig into those

00:47:30,210 --> 00:47:35,330
types to get the get the information you

00:47:32,310 --> 00:47:39,840
need but you can then compare them at

00:47:35,330 --> 00:47:42,930
runtime in the macro and then you can

00:47:39,840 --> 00:47:45,150
print out a nice error message based on

00:47:42,930 --> 00:47:48,360
based on whatever analysis you decide to

00:47:45,150 --> 00:47:50,850
do on the mismatch between the types so

00:47:48,360 --> 00:47:52,740
in the case of mismatch H lists one

00:47:50,850 --> 00:47:54,570
thing you could do is find out if

00:47:52,740 --> 00:47:56,730
there's you could do a diff parameter

00:47:54,570 --> 00:48:01,940
boy parameter diff on the two age lists

00:47:56,730 --> 00:48:06,150
and find out what the problem is and say

00:48:01,940 --> 00:48:08,580
writes nice message out say mr.

00:48:06,150 --> 00:48:13,980
parameter here we expected a string in

00:48:08,580 --> 00:48:15,420
this gap and then most importantly after

00:48:13,980 --> 00:48:18,260
printing the Knights error message the

00:48:15,420 --> 00:48:20,520
macro must fail and must fail to expand

00:48:18,260 --> 00:48:22,650
now what this is what this means in the

00:48:20,520 --> 00:48:23,300
compiler the macro will get run it will

00:48:22,650 --> 00:48:25,670
print out the

00:48:23,300 --> 00:48:31,010
error message but the compiler does not

00:48:25,670 --> 00:48:32,300
see that as a successful compilation we

00:48:31,010 --> 00:48:34,130
can't have a successful compilation

00:48:32,300 --> 00:48:35,450
because we've got we still generally do

00:48:34,130 --> 00:48:38,180
have a type mismatch we haven't fixed

00:48:35,450 --> 00:48:40,430
that we've just we've just done

00:48:38,180 --> 00:48:44,600
something useful in reporting the error

00:48:40,430 --> 00:48:47,510
message before we abort so this is this

00:48:44,600 --> 00:48:51,710
is one called one one weird trick for

00:48:47,510 --> 00:48:54,470
fixing your your type error messages one

00:48:51,710 --> 00:48:58,580
caveat is that this this doesn't work so

00:48:54,470 --> 00:49:00,350
well if you're using covariance but but

00:48:58,580 --> 00:49:03,920
for invariant types this works very well

00:49:00,350 --> 00:49:08,320
and I use it use it in a few places so

00:49:03,920 --> 00:49:08,320
very quickly to run through the

00:49:08,440 --> 00:49:15,320
principles of elegance keeping your API

00:49:11,990 --> 00:49:19,120
minimal mainly stuff well focus on the

00:49:15,320 --> 00:49:21,770
user experience try to be modular

00:49:19,120 --> 00:49:25,850
embrace embrace the type system as much

00:49:21,770 --> 00:49:27,530
as you can accommodate accommodate users

00:49:25,850 --> 00:49:31,820
learning as they are as they are

00:49:27,530 --> 00:49:33,170
starting to use your user API think

00:49:31,820 --> 00:49:36,860
about scoping and organizing this this

00:49:33,170 --> 00:49:42,380
was the one I didn't do and and where

00:49:36,860 --> 00:49:44,810
possible use types rather than values so

00:49:42,380 --> 00:49:47,240
going back to the back to the original

00:49:44,810 --> 00:49:51,080
dictionary quote elegance is combining

00:49:47,240 --> 00:49:54,470
simplicity power and a certain ineffable

00:49:51,080 --> 00:49:56,690
grace of design I don't think I've I

00:49:54,470 --> 00:50:02,420
don't know fully explained the way that

00:49:56,690 --> 00:50:04,750
that ineffability of elegance but

00:50:02,420 --> 00:50:08,960
hopefully I've made some progress into

00:50:04,750 --> 00:50:11,660
Indian to understanding it and that's

00:50:08,960 --> 00:50:12,860
all I've got I think someone will

00:50:11,660 --> 00:50:20,750
probably confirm I don't have time for

00:50:12,860 --> 00:50:23,300
questions do I have time okay so stop

00:50:20,750 --> 00:50:25,340
stop me if in fact if I'm going way over

00:50:23,300 --> 00:50:28,880
but if anyone's last question is there's

00:50:25,340 --> 00:50:33,050
microphones there and there if you want

00:50:28,880 --> 00:50:34,430
to run forward and then ask thanks for

00:50:33,050 --> 00:50:38,030
the awesome talk

00:50:34,430 --> 00:50:41,329
have one question in one of the slides

00:50:38,030 --> 00:50:43,460
you said that to your advice to avoid

00:50:41,329 --> 00:50:45,920
the structural type such as option

00:50:43,460 --> 00:50:48,290
either and tuple for example yeah and

00:50:45,920 --> 00:50:50,720
use the case places for example case

00:50:48,290 --> 00:50:52,520
pass instead of them but for optional

00:50:50,720 --> 00:50:55,670
either we have a monadic instance and

00:50:52,520 --> 00:50:57,589
for WP factor which we don't have by

00:50:55,670 --> 00:51:00,530
default for the case classes moreover

00:50:57,589 --> 00:51:02,569
just by looking at the signature for

00:51:00,530 --> 00:51:04,670
example at the option you immediately

00:51:02,569 --> 00:51:07,280
got the meaning that like the available

00:51:04,670 --> 00:51:09,920
for example might not exist and if you

00:51:07,280 --> 00:51:12,170
want incorporate it in the case class

00:51:09,920 --> 00:51:14,450
you would like you would need to like

00:51:12,170 --> 00:51:17,510
name something I don't know something or

00:51:14,450 --> 00:51:21,829
nothing whatever to bring the same like

00:51:17,510 --> 00:51:24,500
the reasoning from the type so who yeah

00:51:21,829 --> 00:51:28,160
so this basically my my concerns about

00:51:24,500 --> 00:51:29,869
the admins III didn't I didn't hear all

00:51:28,160 --> 00:51:32,180
of the points that baby but you you you

00:51:29,869 --> 00:51:34,460
raised the question yes the first thing

00:51:32,180 --> 00:51:36,680
that if we would use the just case

00:51:34,460 --> 00:51:39,170
classes we would not have default

00:51:36,680 --> 00:51:41,780
monadic instances and the defunct ER

00:51:39,170 --> 00:51:44,089
which we have for the double for example

00:51:41,780 --> 00:51:46,490
or for the options and we're overlooking

00:51:44,089 --> 00:51:48,230
at the just for example as an option we

00:51:46,490 --> 00:51:50,240
immediately understand that this value

00:51:48,230 --> 00:51:52,940
might not be present so we should arise

00:51:50,240 --> 00:51:54,200
so I right there is there is a bit of a

00:51:52,940 --> 00:51:56,690
trade-off there and you get a lot of

00:51:54,200 --> 00:52:00,400
stuff for free if you're using the more

00:51:56,690 --> 00:52:04,839
generic more generic types I did have

00:52:00,400 --> 00:52:09,140
identical slides on on chaining implicit

00:52:04,839 --> 00:52:11,030
which give us a way to take an existing

00:52:09,140 --> 00:52:15,799
type class and existing set of type

00:52:11,030 --> 00:52:21,220
classes and have them transformed by by

00:52:15,799 --> 00:52:21,220
by chaining through another type class

00:52:21,250 --> 00:52:26,359
which does allow us to make some

00:52:23,569 --> 00:52:28,780
progress in to automatically providing a

00:52:26,359 --> 00:52:32,240
lot of the functionality that exists

00:52:28,780 --> 00:52:35,510
that the other people are provided for

00:52:32,240 --> 00:52:38,750
for our own our own new types that we

00:52:35,510 --> 00:52:42,109
introduced I would also raise the

00:52:38,750 --> 00:52:45,420
question as to whether we want to get

00:52:42,109 --> 00:52:47,970
all that stuff free or not

00:52:45,420 --> 00:52:53,700
that this there's the risk that maybe

00:52:47,970 --> 00:52:55,079
you shouldn't be you shouldn't be when

00:52:53,700 --> 00:53:00,480
you're working with very very generic

00:52:55,079 --> 00:53:02,190
structural things often often you you

00:53:00,480 --> 00:53:06,180
you don't want to be interchangeable I

00:53:02,190 --> 00:53:08,130
think that that's that's kind of the key

00:53:06,180 --> 00:53:10,200
the key point I was trying to make but I

00:53:08,130 --> 00:53:13,140
do i do appreciate that there are some

00:53:10,200 --> 00:53:16,980
there are some trade-offs there yeah

00:53:13,140 --> 00:53:18,569
question there yeah it might be I don't

00:53:16,980 --> 00:53:21,020
know if it was in the slides that you

00:53:18,569 --> 00:53:24,089
skipped over but do you have any

00:53:21,020 --> 00:53:27,540
guidelines for exceptions like sugar

00:53:24,089 --> 00:53:29,880
library author expose exceptions to do I

00:53:27,540 --> 00:53:39,240
have any advice or principles for your

00:53:29,880 --> 00:53:41,819
exceptions that this is another talk

00:53:39,240 --> 00:53:45,660
I've done on this in fact the talk I did

00:53:41,819 --> 00:53:47,940
at scala days last year i think i did

00:53:45,660 --> 00:53:51,299
talk a lot about exceptions I don't know

00:53:47,940 --> 00:54:00,030
about formulating him into a principle

00:53:51,299 --> 00:54:03,059
but yeah I talked do it do a I think

00:54:00,030 --> 00:54:04,650
look on the phone YouTube 40 if if the

00:54:03,059 --> 00:54:09,960
if the Scarlet a stalking last year

00:54:04,650 --> 00:54:12,020
online check check them out oh yeah I've

00:54:09,960 --> 00:54:15,780
talked a lot about exceptions before I

00:54:12,020 --> 00:54:17,910
think last last question okay yeah you

00:54:15,780 --> 00:54:21,690
said don't put too many methods in the

00:54:17,910 --> 00:54:23,910
API and I so it's ever again don't put

00:54:21,690 --> 00:54:26,180
too many methods in the api RP to me

00:54:23,910 --> 00:54:29,130
records in the eighth and I think it's

00:54:26,180 --> 00:54:31,710
important to not to put too few methods

00:54:29,130 --> 00:54:34,530
so I know this anti-pattern in the c

00:54:31,710 --> 00:54:37,650
library of this method io control which

00:54:34,530 --> 00:54:40,410
is basically hundred methods in one and

00:54:37,650 --> 00:54:42,930
you just have a lot of ifs there and so

00:54:40,410 --> 00:54:46,049
I think if you have a implemented method

00:54:42,930 --> 00:54:48,720
that already starts with an if to go to

00:54:46,049 --> 00:54:50,369
two quite different implementations and

00:54:48,720 --> 00:54:55,170
I would rather put two different methods

00:54:50,369 --> 00:54:56,549
there yeah I mean it's DVDs aren't these

00:54:55,170 --> 00:54:57,600
are never going to be hard and fast

00:54:56,549 --> 00:55:07,020
rules

00:54:57,600 --> 00:55:10,470
I I would maybe add to add at the ads

00:55:07,020 --> 00:55:12,720
that in saying that maybe if you are

00:55:10,470 --> 00:55:16,470
finding the adding lots of methods to

00:55:12,720 --> 00:55:19,760
the same type you should potentially be

00:55:16,470 --> 00:55:23,430
having two three four types representing

00:55:19,760 --> 00:55:25,920
those those those those different things

00:55:23,430 --> 00:55:27,510
like shut try and try and work out what

00:55:25,920 --> 00:55:31,550
the concept is you're trying to

00:55:27,510 --> 00:55:34,350
represent and keep each of them small

00:55:31,550 --> 00:55:36,810
again the lease of a concept they're

00:55:34,350 --> 00:55:38,940
they're kind of abstract in that I'm

00:55:36,810 --> 00:55:41,550
talking about the arbitrary concept of a

00:55:38,940 --> 00:55:46,020
method and a type without really I mean

00:55:41,550 --> 00:55:49,290
I know I know you mentioned iio but yeah

00:55:46,020 --> 00:55:50,850
that there are a few different different

00:55:49,290 --> 00:55:53,790
domains where different things but it

00:55:50,850 --> 00:55:55,920
would apply and I've tried to be as

00:55:53,790 --> 00:55:57,300
general as possible but but haven't to

00:55:55,920 --> 00:56:02,240
have missed the recent season in all

00:55:57,300 --> 00:56:02,240

YouTube URL: https://www.youtube.com/watch?v=V0u58_-7r4E


