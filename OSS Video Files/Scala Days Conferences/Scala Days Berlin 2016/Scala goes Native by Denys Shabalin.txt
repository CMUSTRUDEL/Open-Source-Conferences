Title: Scala goes Native by Denys Shabalin
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
Scala has historically been a JVM-centric programming language. The situation has started to change with appearance of the Scala.js that opened a door of front-end development to Scala programmers. This talk will expand the horizons of Scala even more. Weâ€™re going to announce a new ahead-of-time compiler and lightweight managed runtime designed specifically for Scala.
Captions: 
	00:00:06,060 --> 00:00:15,270
hello everyone my name is Dennis I am a

00:00:11,770 --> 00:00:17,050
busy student at Martin's lab at EPFL and

00:00:15,270 --> 00:00:20,020
today I would like to tell you a story

00:00:17,050 --> 00:00:23,500
about how a piece of software came to be

00:00:20,020 --> 00:00:25,630
and as many I stories about software it

00:00:23,500 --> 00:00:28,419
starts with someone being pissed off at

00:00:25,630 --> 00:00:31,960
something really bad and this one is not

00:00:28,419 --> 00:00:34,329
going to be an exception so and before

00:00:31,960 --> 00:00:36,250
we start like I would really want to

00:00:34,329 --> 00:00:37,660
tell you a bit like my background in

00:00:36,250 --> 00:00:41,770
programming and how it all started for

00:00:37,660 --> 00:00:44,890
me as primal experience my very first

00:00:41,770 --> 00:00:47,620
programming language was Pascal so how

00:00:44,890 --> 00:00:51,520
many of you here know Pascal can you ok

00:00:47,620 --> 00:00:52,630
so good excellent so to be honest

00:00:51,520 --> 00:00:55,060
actually have some kind of like

00:00:52,630 --> 00:00:57,310
irrational feelings toward Pascal even

00:00:55,060 --> 00:01:00,940
though it's weird extremely extremely

00:00:57,310 --> 00:01:02,680
verbose language even though it's like a

00:01:00,940 --> 00:01:05,830
version of pasco I used was still

00:01:02,680 --> 00:01:07,509
without GC with low level was really

00:01:05,830 --> 00:01:08,770
kind of like see style language it was

00:01:07,509 --> 00:01:11,080
actually quite hard to shoot yourself

00:01:08,770 --> 00:01:12,340
because a version was sober both so you

00:01:11,080 --> 00:01:13,960
would actually have to be very explicit

00:01:12,340 --> 00:01:15,970
about shooting yourself so you would be

00:01:13,960 --> 00:01:19,330
like I am shooting myself in the foot

00:01:15,970 --> 00:01:21,130
right now and even though it was a

00:01:19,330 --> 00:01:24,659
low-level language it was really hard to

00:01:21,130 --> 00:01:27,820
shoot yourself though after Pascal I

00:01:24,659 --> 00:01:30,100
learned see and my first experience like

00:01:27,820 --> 00:01:32,320
when I just like started like coding

00:01:30,100 --> 00:01:33,820
stuff and she was like I'm so much more

00:01:32,320 --> 00:01:35,950
productive now i can write so much more

00:01:33,820 --> 00:01:38,290
code because everything is so tense and

00:01:35,950 --> 00:01:40,120
like so compact there's a nice

00:01:38,290 --> 00:01:42,610
foundation for everything until you

00:01:40,120 --> 00:01:45,960
realize that all this nice entation can

00:01:42,610 --> 00:01:49,510
explode in weird arbitrary ways and it's

00:01:45,960 --> 00:01:51,729
surprisingly easy to he has its my back

00:01:49,510 --> 00:01:56,040
ok it's surprisingly it's nighttime

00:01:51,729 --> 00:01:58,299
training it's surprisingly easy to

00:01:56,040 --> 00:02:01,600
accidentally just do somethin rollin

00:01:58,299 --> 00:02:03,850
because its language is optimized for

00:02:01,600 --> 00:02:07,720
some weird like assembly like coding and

00:02:03,850 --> 00:02:10,360
most apps are not like that after see I

00:02:07,720 --> 00:02:14,139
learned C sharp and was my first object

00:02:10,360 --> 00:02:15,939
oriented and it was actually kind of one

00:02:14,139 --> 00:02:16,930
of the biggest wow moments I've had in

00:02:15,939 --> 00:02:19,420
my like / amex

00:02:16,930 --> 00:02:21,370
because classes were like really not a

00:02:19,420 --> 00:02:24,010
trivial concept and took a while to

00:02:21,370 --> 00:02:25,329
grasp but still in c-sharp actually even

00:02:24,010 --> 00:02:27,069
though not many people use those

00:02:25,329 --> 00:02:28,840
features you still have all of the nice

00:02:27,069 --> 00:02:31,299
low level stuff like strikes and

00:02:28,840 --> 00:02:34,000
pointers and you can use to optimize

00:02:31,299 --> 00:02:35,799
stuff if you want to and in c-sharp I

00:02:34,000 --> 00:02:38,409
never felt like the language is too high

00:02:35,799 --> 00:02:40,510
level because there is always they can

00:02:38,409 --> 00:02:42,189
make an obvious choice to use pointers

00:02:40,510 --> 00:02:45,849
in C sharp and it works perfectly as

00:02:42,189 --> 00:02:48,519
fast and he heard was also my first

00:02:45,849 --> 00:02:50,470
language with IDEs and it was kind of

00:02:48,519 --> 00:02:52,389
the only idea experiences I ever liked

00:02:50,470 --> 00:02:55,239
because everything was so integrated I

00:02:52,389 --> 00:02:59,200
guess everything else doesn't quite live

00:02:55,239 --> 00:03:01,480
up to this experience anymore after that

00:02:59,200 --> 00:03:04,030
I learn Python and my main reason for

00:03:01,480 --> 00:03:05,650
switching from City Hall was because it

00:03:04,030 --> 00:03:07,840
wasn't going anywhere it was a Microsoft

00:03:05,650 --> 00:03:09,790
only saying that lived in Microsoft only

00:03:07,840 --> 00:03:14,290
Aiken system at the time and there was

00:03:09,790 --> 00:03:16,510
no way to run run apps outside of

00:03:14,290 --> 00:03:18,760
Windows and mana was just starting at

00:03:16,510 --> 00:03:22,150
the time and it was really kind of like

00:03:18,760 --> 00:03:25,060
hard to justify using C sharp for non

00:03:22,150 --> 00:03:27,790
Windows apps so I look at Lauren pison

00:03:25,060 --> 00:03:30,190
it looks really cool and it was again

00:03:27,790 --> 00:03:32,169
even more productive and but at the same

00:03:30,190 --> 00:03:34,419
time it was only productive until a

00:03:32,169 --> 00:03:37,720
certain specific threshold like

00:03:34,419 --> 00:03:40,299
somewhere around from one k-25 k lines

00:03:37,720 --> 00:03:43,299
of code suddenly start losing touch with

00:03:40,299 --> 00:03:44,979
spoke with your code because lack of

00:03:43,299 --> 00:03:47,530
types actually starts hurting you

00:03:44,979 --> 00:03:48,970
probably until like a few k lines of

00:03:47,530 --> 00:03:49,959
code bison is actually my experience

00:03:48,970 --> 00:03:53,049
more productive than type language

00:03:49,959 --> 00:03:55,659
because you can still hold everything in

00:03:53,049 --> 00:03:58,209
your head until the debt limit but but

00:03:55,659 --> 00:03:59,829
when you get too big abs like 10k and

00:03:58,209 --> 00:04:01,659
more or even like something horrible

00:03:59,829 --> 00:04:06,340
like I've heard horrible numbers about

00:04:01,659 --> 00:04:07,720
Dropbox code base in Python and so when

00:04:06,340 --> 00:04:08,919
it gets this big you cannot hold stuff

00:04:07,720 --> 00:04:11,530
in your head anymore so you really need

00:04:08,919 --> 00:04:13,509
a tool to help you out and it was really

00:04:11,530 --> 00:04:17,259
obvious in bison bison doesn't quite

00:04:13,509 --> 00:04:19,150
work for this kind of use case and at

00:04:17,259 --> 00:04:21,370
the time I was just writing apps in

00:04:19,150 --> 00:04:23,919
bison and QT with pie cutie and like

00:04:21,370 --> 00:04:28,090
just doing like some consulting and

00:04:23,919 --> 00:04:29,840
stones of course and and I stumbled upon

00:04:28,090 --> 00:04:31,699
a video by the

00:04:29,840 --> 00:04:33,680
crimson conference by Daniel spirit that

00:04:31,699 --> 00:04:36,230
explained how higher current types work

00:04:33,680 --> 00:04:38,360
and for me is the time it was completely

00:04:36,230 --> 00:04:40,460
incomprehensible because I was just

00:04:38,360 --> 00:04:41,990
normal Python developer I actually I

00:04:40,460 --> 00:04:44,620
didn't even know that such a thing

00:04:41,990 --> 00:04:46,760
existed before because it's sharp like

00:04:44,620 --> 00:04:49,520
Jenks are simple there is no higher kind

00:04:46,760 --> 00:04:51,320
types and I was completely blown with

00:04:49,520 --> 00:04:53,870
all kinds and so on so forth and it

00:04:51,320 --> 00:04:55,760
looks so hard and like that it actually

00:04:53,870 --> 00:04:57,470
made sense to learn it because I was

00:04:55,760 --> 00:05:01,070
like it looks so awesome it's probably

00:04:57,470 --> 00:05:03,229
cool right so there's no way Samson this

00:05:01,070 --> 00:05:06,610
great-looking can be bad and just how I

00:05:03,229 --> 00:05:09,889
kind of happened to learn Scala and

00:05:06,610 --> 00:05:11,570
actually I came I just call it because

00:05:09,889 --> 00:05:13,850
of the weird obscure features that i

00:05:11,570 --> 00:05:15,590
didn't even know how how you should use

00:05:13,850 --> 00:05:18,110
but I stay here for all of the nice

00:05:15,590 --> 00:05:20,450
stuff that you also have like a types

00:05:18,110 --> 00:05:22,550
which don't get any way I was nice

00:05:20,450 --> 00:05:25,130
typing friends actually in first most of

00:05:22,550 --> 00:05:28,639
the think you actually are so horribly

00:05:25,130 --> 00:05:33,850
complicated in languages like C sharp of

00:05:28,639 --> 00:05:36,740
the day and a version is fast until

00:05:33,850 --> 00:05:38,510
before the ever since warmed up you kind

00:05:36,740 --> 00:05:41,389
of feel is it really a fast language

00:05:38,510 --> 00:05:43,580
because GV m is really weird beast and

00:05:41,389 --> 00:05:45,200
but after its warm up it's fast of

00:05:43,580 --> 00:05:47,539
course and you have all the nice prior

00:05:45,200 --> 00:05:49,520
libraries and so on so forth so I really

00:05:47,539 --> 00:05:52,280
kind of like game for higher current

00:05:49,520 --> 00:05:54,950
types State Fair is Nelson's column but

00:05:52,280 --> 00:05:58,280
still I like the language but there was

00:05:54,950 --> 00:06:00,979
something that kind of felt like out of

00:05:58,280 --> 00:06:02,270
place for me after having had experience

00:06:00,979 --> 00:06:05,270
with all the previous languages as I

00:06:02,270 --> 00:06:07,639
said before and this part was kind of

00:06:05,270 --> 00:06:10,910
environment where scholar runs and I

00:06:07,639 --> 00:06:12,260
prefer to refer to this environment is a

00:06:10,910 --> 00:06:16,460
golden cage because it's really really

00:06:12,260 --> 00:06:19,160
nice actually but is a cage so there are

00:06:16,460 --> 00:06:22,190
a few kind of announces them not quite

00:06:19,160 --> 00:06:25,490
super found of the first of all I warm

00:06:22,190 --> 00:06:28,849
up time is my absolutely least favorite

00:06:25,490 --> 00:06:30,770
feature of JVM and it really takes a

00:06:28,849 --> 00:06:32,840
while to warm up it really takes a while

00:06:30,770 --> 00:06:35,300
to it really takes a lot of effort to

00:06:32,840 --> 00:06:39,050
make a proper benchmark on JVM because

00:06:35,300 --> 00:06:42,249
of the weird highly predictable stabs at

00:06:39,050 --> 00:06:46,149
it though and I really kind of like

00:06:42,249 --> 00:06:47,469
to really dislike jits after jvm even

00:06:46,149 --> 00:06:51,609
though they have some very good jets

00:06:47,469 --> 00:06:53,319
which are not as slow to start also I

00:06:51,609 --> 00:06:55,539
kind of like interaction between jets

00:06:53,319 --> 00:06:57,489
and income and compilation your code and

00:06:55,539 --> 00:06:59,759
how it's all kind of like doesn't happen

00:06:57,489 --> 00:07:02,969
to be predictable at all is it's

00:06:59,759 --> 00:07:05,679
something that actually dislike and

00:07:02,969 --> 00:07:07,329
another thing is as on jvm you're kind

00:07:05,679 --> 00:07:09,429
of like first live in the sandbox where

00:07:07,329 --> 00:07:10,599
everything super-safe super high level

00:07:09,429 --> 00:07:13,209
and if you want to do anything

00:07:10,599 --> 00:07:15,849
arbitrarily just a little bit more level

00:07:13,209 --> 00:07:18,429
like you want to use row memory access

00:07:15,849 --> 00:07:21,399
suddenly becomes extremely hard because

00:07:18,429 --> 00:07:23,860
GV m has this like ultimate vision of

00:07:21,399 --> 00:07:25,659
being the safest platform with all of

00:07:23,860 --> 00:07:27,819
the security management with all of the

00:07:25,659 --> 00:07:30,639
safe features and so on so forth so they

00:07:27,819 --> 00:07:33,369
their goal is not to expose you any kind

00:07:30,639 --> 00:07:34,689
of detail about how platform work and

00:07:33,369 --> 00:07:37,809
sometimes you really need that because

00:07:34,689 --> 00:07:39,789
for some apps like GC is not enough like

00:07:37,809 --> 00:07:41,499
for some apps and you would really want

00:07:39,789 --> 00:07:43,749
to kind of do something more level and

00:07:41,499 --> 00:07:45,639
on GV m is extremely hard of course you

00:07:43,749 --> 00:07:49,019
can use sounds like son mis can save but

00:07:45,639 --> 00:07:51,489
this is like even worse than C so I know

00:07:49,019 --> 00:07:55,089
another thing this really really hard on

00:07:51,489 --> 00:07:57,610
JVM is it's really hard to interoperate

00:07:55,089 --> 00:08:00,519
with anything but Colin's JVM so if you

00:07:57,610 --> 00:08:03,249
want to kind of call to like Python code

00:08:00,519 --> 00:08:05,679
or C code or C++ code or any other code

00:08:03,249 --> 00:08:09,039
which is not in gvl maker system which

00:08:05,679 --> 00:08:11,459
is not compiled with some JP dyson or

00:08:09,039 --> 00:08:13,779
San Luis it's not only impossibly hard

00:08:11,459 --> 00:08:16,119
and the reason why is impossibly hard

00:08:13,779 --> 00:08:18,669
this because Jane I and jenna is like

00:08:16,119 --> 00:08:21,549
the most complicated intro player I've

00:08:18,669 --> 00:08:26,549
ever seen in my life and that's the only

00:08:21,549 --> 00:08:30,699
layer you can use some JVM of course so

00:08:26,549 --> 00:08:32,800
so now you know stuff stuff I'd dislikes

00:08:30,699 --> 00:08:35,559
let's kind of day dream for a second i

00:08:32,800 --> 00:08:38,469
really like daydreaming sometimes I

00:08:35,559 --> 00:08:40,569
daydream so much that I that lose a

00:08:38,469 --> 00:08:43,300
distinction between which features are

00:08:40,569 --> 00:08:47,439
real and which are not and yeah but

00:08:43,300 --> 00:08:50,110
that's another problem and so first of

00:08:47,439 --> 00:08:52,059
all I would like Scala to be immediate I

00:08:50,110 --> 00:08:55,000
would like to start my apps and have

00:08:52,059 --> 00:08:57,730
them run just as a set you know in

00:08:55,000 --> 00:09:00,580
thousand sixteen we have extremely fast

00:08:57,730 --> 00:09:03,040
machines with extremely fast SSDs and it

00:09:00,580 --> 00:09:06,430
still takes seconds to start SBT you

00:09:03,040 --> 00:09:10,570
know this should not happen in 2016

00:09:06,430 --> 00:09:13,540
anymore and also I would really like to

00:09:10,570 --> 00:09:15,310
have something apart from a reference

00:09:13,540 --> 00:09:19,540
classes I would like to have some way to

00:09:15,310 --> 00:09:20,980
have some reasonably powerful value

00:09:19,540 --> 00:09:22,570
types in a system so I would really want

00:09:20,980 --> 00:09:25,660
to have structs I would really want to

00:09:22,570 --> 00:09:29,650
have low level like backs of things I

00:09:25,660 --> 00:09:32,200
set up right now if you want to have any

00:09:29,650 --> 00:09:34,690
kind of like non-value sing like a

00:09:32,200 --> 00:09:37,120
single value like most Amanda like

00:09:34,690 --> 00:09:40,080
reports they have a point in 3d space

00:09:37,120 --> 00:09:42,880
like this represented by three numbers

00:09:40,080 --> 00:09:44,980
it's you have to allocate and the sky

00:09:42,880 --> 00:09:48,070
not good you really need to be able to

00:09:44,980 --> 00:09:49,240
have values and al-qaeda much tag and

00:09:48,070 --> 00:09:50,320
pass them by value and so on so forth

00:09:49,240 --> 00:09:52,630
because it's actually a thing that

00:09:50,320 --> 00:09:56,650
actually works very well and compilers

00:09:52,630 --> 00:10:01,660
can optimize it to produce impressively

00:09:56,650 --> 00:10:03,040
fast code and lastly and I really want

00:10:01,660 --> 00:10:05,680
to have a bit more control over memory

00:10:03,040 --> 00:10:08,530
management because for some apps you

00:10:05,680 --> 00:10:12,190
really need to go lower levels and your

00:10:08,530 --> 00:10:14,500
normal GC stuff and so far as experience

00:10:12,190 --> 00:10:18,130
with GC has daughters on JVM and that

00:10:14,500 --> 00:10:19,960
there is no perfect GC whatever you do

00:10:18,130 --> 00:10:23,500
is always a trade-off you're always

00:10:19,960 --> 00:10:26,890
either sacrifice latency or throughput

00:10:23,500 --> 00:10:28,450
or flexibility or sometimes you'll never

00:10:26,890 --> 00:10:31,750
have everything like you can never have

00:10:28,450 --> 00:10:33,700
a dull with DC and the signals you get

00:10:31,750 --> 00:10:38,050
always with GC is like nice ease of use

00:10:33,700 --> 00:10:39,550
and kind of no burden on a primer even

00:10:38,050 --> 00:10:42,820
though you actually do have a burden

00:10:39,550 --> 00:10:44,740
when you get performance issues but

00:10:42,820 --> 00:10:46,839
actually in some apps it's actually

00:10:44,740 --> 00:10:49,540
surprisingly easy to do some a bit of

00:10:46,839 --> 00:10:52,240
lower level memory management and you

00:10:49,540 --> 00:10:57,490
have no issues are common in to see

00:10:52,240 --> 00:10:58,839
systems and lastly i really want to call

00:10:57,490 --> 00:11:01,089
other languages i really want to call

00:10:58,839 --> 00:11:04,480
see libraries which are fast i really

00:11:01,089 --> 00:11:07,180
want it to be easy and not to take me

00:11:04,480 --> 00:11:08,200
more than like a few hours to write the

00:11:07,180 --> 00:11:10,300
bindings for some library

00:11:08,200 --> 00:11:14,610
don't want to kind of like deal with

00:11:10,300 --> 00:11:17,230
gene I ever again but you know

00:11:14,610 --> 00:11:18,640
daydreaming slice but sometimes you just

00:11:17,230 --> 00:11:19,930
need to wake up and realize that like

00:11:18,640 --> 00:11:24,550
what are we dreamed it's not real right

00:11:19,930 --> 00:11:29,380
and you just go back to your day job and

00:11:24,550 --> 00:11:31,120
and just you know go there and just get

00:11:29,380 --> 00:11:34,300
a new task from boss that says you know

00:11:31,120 --> 00:11:36,070
we have this old legacy code base in C++

00:11:34,300 --> 00:11:37,570
and now we have everything in scarlet so

00:11:36,070 --> 00:11:40,690
it has obviously has to report the

00:11:37,570 --> 00:11:43,270
Scarlet because it's better so guess

00:11:40,690 --> 00:11:45,040
it's like ugly large massive code base

00:11:43,270 --> 00:11:47,350
which does some really weird

00:11:45,040 --> 00:11:49,270
domain-specific knowledge thing so you

00:11:47,350 --> 00:11:50,680
try to understand what does you split

00:11:49,270 --> 00:11:52,420
apart trying to understand what our

00:11:50,680 --> 00:11:54,340
pieces do when you see that here or here

00:11:52,420 --> 00:11:57,610
we have a vector which is actually just

00:11:54,340 --> 00:12:01,150
a struct bug those three values together

00:11:57,610 --> 00:12:02,470
and has nice match leukemic operation

00:12:01,150 --> 00:12:04,810
some time so it's actually quite simple

00:12:02,470 --> 00:12:07,930
then you have this racing you have this

00:12:04,810 --> 00:12:09,610
enum and it's actually like slowly you

00:12:07,930 --> 00:12:12,010
reach to the code and you realize it's

00:12:09,610 --> 00:12:13,390
actually even though it's C++ it's

00:12:12,010 --> 00:12:20,160
actually possible to understand what

00:12:13,390 --> 00:12:22,600
does yeah so you start just maybe like a

00:12:20,160 --> 00:12:25,390
factor it a bit like maybe add some

00:12:22,600 --> 00:12:27,670
Commons tests and before we poured it so

00:12:25,390 --> 00:12:29,590
you see the three some weird like bits

00:12:27,670 --> 00:12:32,410
and pieces and and then you start an

00:12:29,590 --> 00:12:33,820
Istanbul on this like same which is a

00:12:32,410 --> 00:12:34,810
large piece of the main specific

00:12:33,820 --> 00:12:39,940
knowledge that you cannot touch of

00:12:34,810 --> 00:12:42,400
course yeah so so on the first and just

00:12:39,940 --> 00:12:44,020
slowly connected it takes you a few

00:12:42,400 --> 00:12:46,930
weeks to understand what it does and

00:12:44,020 --> 00:12:48,970
then in a few weeks you come back to the

00:12:46,930 --> 00:12:51,160
boss and say oh yeah i ported it so now

00:12:48,970 --> 00:12:55,000
it since college so it must be fast

00:12:51,160 --> 00:12:58,570
right so so we poured everything to

00:12:55,000 --> 00:13:00,970
scala the vector we've had before it

00:12:58,570 --> 00:13:03,880
becomes a class vector because we don't

00:13:00,970 --> 00:13:05,470
have structs right and everything else

00:13:03,880 --> 00:13:07,870
become a class and everything else

00:13:05,470 --> 00:13:10,570
becomes like high level and nice and it

00:13:07,870 --> 00:13:12,700
like and the main specific thing we've

00:13:10,570 --> 00:13:15,280
seen before it's almost fine because we

00:13:12,700 --> 00:13:19,090
actually split it into like like more or

00:13:15,280 --> 00:13:22,050
less manageable code and it all looks

00:13:19,090 --> 00:13:24,570
good until you realize that

00:13:22,050 --> 00:13:27,000
what you've had before actually is not

00:13:24,570 --> 00:13:29,250
the same as that's what you have now so

00:13:27,000 --> 00:13:31,560
you compile the previous one I try to

00:13:29,250 --> 00:13:33,570
see how much it takes and you see it's

00:13:31,560 --> 00:13:36,180
like it's a small thing it takes a few

00:13:33,570 --> 00:13:39,450
seconds and it's not too bad so it's

00:13:36,180 --> 00:13:42,630
like seven seconds to run it's nice yeah

00:13:39,450 --> 00:13:48,060
the sunny come back to your port in a

00:13:42,630 --> 00:13:49,680
scarlet JVM and on JVM and you just try

00:13:48,060 --> 00:13:54,209
to compile first it takes a while of

00:13:49,680 --> 00:13:58,410
course because this SBT uh-huh and then

00:13:54,209 --> 00:14:01,320
you launch it um and you see a reason

00:13:58,410 --> 00:14:02,940
noticeable slow down somehow we you're

00:14:01,320 --> 00:14:05,040
not quite sure so it takes a while to

00:14:02,940 --> 00:14:07,740
understand why it's slower you try to

00:14:05,040 --> 00:14:09,480
benchmark as you use profilers you try

00:14:07,740 --> 00:14:12,810
to understand what actually happens and

00:14:09,480 --> 00:14:15,209
why is almost to them slower then after

00:14:12,810 --> 00:14:18,690
a while you just realize that this

00:14:15,209 --> 00:14:21,240
vector things are causing extreme GC

00:14:18,690 --> 00:14:23,459
pressure and you ABS it used to use 10

00:14:21,240 --> 00:14:26,130
megabytes of memory now typically is

00:14:23,459 --> 00:14:31,770
able to consume do you have I to memory

00:14:26,130 --> 00:14:33,839
somehow and you just really want to cry

00:14:31,770 --> 00:14:35,250
a bit because there is no other way to

00:14:33,839 --> 00:14:36,870
do it so you start considering other

00:14:35,250 --> 00:14:39,750
options like doing maybe some kind of of

00:14:36,870 --> 00:14:41,880
heap memory using like byte buffers to

00:14:39,750 --> 00:14:45,270
store this vector sayings and basically

00:14:41,880 --> 00:14:48,089
at that point your code base becomes C

00:14:45,270 --> 00:14:50,029
code only like backwards because in C

00:14:48,089 --> 00:14:52,740
actually have nice index for the sinks

00:14:50,029 --> 00:14:55,260
in Java when you deal with this low

00:14:52,740 --> 00:14:58,260
level stuff you end up doing some kind

00:14:55,260 --> 00:15:00,810
of weird and aromatics on offset in a

00:14:58,260 --> 00:15:01,890
byte buffer or something that doesn't

00:15:00,810 --> 00:15:04,260
quite help with your code

00:15:01,890 --> 00:15:06,540
maintainability so you get really

00:15:04,260 --> 00:15:08,670
depressed after this and you go

00:15:06,540 --> 00:15:11,520
somewhere like in suitland in some

00:15:08,670 --> 00:15:14,040
village and try to figure out how to

00:15:11,520 --> 00:15:16,350
make stuff better and no one sees you

00:15:14,040 --> 00:15:19,560
for nine months and so you come back in

00:15:16,350 --> 00:15:21,990
nine months again and in nine months you

00:15:19,560 --> 00:15:24,180
have like Samsung and you always wanted

00:15:21,990 --> 00:15:26,310
so first of all have this ad struct

00:15:24,180 --> 00:15:29,310
thing is it almost the same code as

00:15:26,310 --> 00:15:30,990
before but it's a struct now and you can

00:15:29,310 --> 00:15:33,120
actually not allocate it on hip now

00:15:30,990 --> 00:15:35,040
because it's actually just the value of

00:15:33,120 --> 00:15:38,459
three other values it's actually quite

00:15:35,040 --> 00:15:42,720
simple and basically have a very similar

00:15:38,459 --> 00:15:48,560
code roughly unchanged and you can

00:15:42,720 --> 00:15:48,560
actually compile it and compile it him

00:15:49,520 --> 00:15:59,850
wait for it yeah okay and then you

00:15:57,569 --> 00:16:02,390
launch it NEC this like a nice swiftness

00:15:59,850 --> 00:16:04,949
of code that you've had before without

00:16:02,390 --> 00:16:06,569
random GC style that happens behind the

00:16:04,949 --> 00:16:09,180
scenes because now you actually don't

00:16:06,569 --> 00:16:11,459
really do any DC here because your app

00:16:09,180 --> 00:16:13,709
doesn't need you see for this like you

00:16:11,459 --> 00:16:16,440
have some domain specific message we act

00:16:13,709 --> 00:16:18,089
up here so it doesn't need to GC um so

00:16:16,440 --> 00:16:21,209
you're kind of like it's a bit slower

00:16:18,089 --> 00:16:26,010
than C++ but it's like twenty to thirty

00:16:21,209 --> 00:16:28,800
percent slower not 2x slower so it's

00:16:26,010 --> 00:16:31,500
kind of more than good enough and you're

00:16:28,800 --> 00:16:34,399
happy now because you can finally get

00:16:31,500 --> 00:16:37,560
your stuff that you always wanted and

00:16:34,399 --> 00:16:39,690
then you open sources sing and then

00:16:37,560 --> 00:16:41,490
suddenly randomly lots of people come

00:16:39,690 --> 00:16:44,490
and try to use it even before it's

00:16:41,490 --> 00:16:47,490
released and people do lots of cool

00:16:44,490 --> 00:16:50,550
stuff even though it just started so so

00:16:47,490 --> 00:16:52,260
first of all like the thing was just a

00:16:50,550 --> 00:16:55,589
small team effort by me in Sebastian

00:16:52,260 --> 00:16:59,190
even those Sebastian did not submit any

00:16:55,589 --> 00:17:02,490
committee at the repo he and like scary

00:16:59,190 --> 00:17:04,890
is largely inspired by psychologists

00:17:02,490 --> 00:17:07,199
architecture and skyla geez design

00:17:04,890 --> 00:17:10,679
principles and economy would not be

00:17:07,199 --> 00:17:13,140
possible without Scala GS and I kind of

00:17:10,679 --> 00:17:15,300
like sink as Sebastian as a second guy

00:17:13,140 --> 00:17:17,490
on a team but then all this kind of

00:17:15,300 --> 00:17:19,470
people appeared and just started doing

00:17:17,490 --> 00:17:21,839
like cool stuff with book with

00:17:19,470 --> 00:17:24,150
unreleased and working for his software

00:17:21,839 --> 00:17:25,740
i know i just started open a pull

00:17:24,150 --> 00:17:30,179
request to change many different things

00:17:25,740 --> 00:17:31,950
and we've merged like um how many a 36

00:17:30,179 --> 00:17:34,380
boy request from 10 people from 12

00:17:31,950 --> 00:17:37,050
people in past months and this pull

00:17:34,380 --> 00:17:39,330
request really do different like it they

00:17:37,050 --> 00:17:42,780
start from small typos and changes here

00:17:39,330 --> 00:17:47,220
and there to really cool stuff like

00:17:42,780 --> 00:17:48,659
freebsd support who here uses freebsd

00:17:47,220 --> 00:17:53,309
can you please raise your hand

00:17:48,659 --> 00:17:58,649
10 K 2 K 3 okay so we need to support

00:17:53,309 --> 00:18:00,749
freebies deicing and they also try to

00:17:58,649 --> 00:18:03,960
use it and they even managed to somehow

00:18:00,749 --> 00:18:05,639
and make it compile on iOS even though

00:18:03,960 --> 00:18:07,739
I've never tried personally but

00:18:05,639 --> 00:18:10,919
apparently domestic claim was able to do

00:18:07,739 --> 00:18:12,720
it so it's cool they also write

00:18:10,919 --> 00:18:15,450
documentation for you which is also

00:18:12,720 --> 00:18:18,539
quite surprising and it writes its nice

00:18:15,450 --> 00:18:20,489
guys on how to use it even if you if

00:18:18,539 --> 00:18:22,820
there is no official docs yet but this

00:18:20,489 --> 00:18:25,979
boxcar native is probably the best place

00:18:22,820 --> 00:18:27,899
to to clone the best thing to clone if

00:18:25,979 --> 00:18:30,960
you want to try out culinary right now

00:18:27,899 --> 00:18:35,220
before we are before we actually release

00:18:30,960 --> 00:18:36,809
anything publicly we also implement

00:18:35,220 --> 00:18:38,629
non-trivial stop support non trivial

00:18:36,809 --> 00:18:41,989
stuff and it's really kind of cool that

00:18:38,629 --> 00:18:44,299
people just contribute things and and

00:18:41,989 --> 00:18:46,559
the velocity of project improved

00:18:44,299 --> 00:18:51,929
dramatically since its colleges in New

00:18:46,559 --> 00:18:54,989
York but that's kind of like the story

00:18:51,929 --> 00:18:56,279
of culinary if until today but what is

00:18:54,989 --> 00:18:59,789
actually likes currently how does it

00:18:56,279 --> 00:19:02,279
work under the hood like and the short

00:18:59,789 --> 00:19:06,269
answer is it's an lvm compiler so it's

00:19:02,279 --> 00:19:08,909
olivium based compilers that makes your

00:19:06,269 --> 00:19:10,440
Scala code produce native binaries

00:19:08,909 --> 00:19:13,320
anyway I say native bynars I just say

00:19:10,440 --> 00:19:15,539
one nice binary that you can just take

00:19:13,320 --> 00:19:18,090
in like a ship two different machines

00:19:15,539 --> 00:19:21,509
will just work there is no vm there is

00:19:18,090 --> 00:19:23,970
snow kind of like set up you only need

00:19:21,509 --> 00:19:25,859
all of the libraries that your project

00:19:23,970 --> 00:19:27,090
depends on so if you depend on some

00:19:25,859 --> 00:19:29,609
native libraries of course you'll need

00:19:27,090 --> 00:19:32,220
to have that but it's basically a simple

00:19:29,609 --> 00:19:38,759
thing there is no vm anymore even though

00:19:32,220 --> 00:19:40,889
ldm has a vm in it we can also optimize

00:19:38,759 --> 00:19:42,059
telcos will lv m which is I think it's a

00:19:40,889 --> 00:19:45,389
very important feature for from

00:19:42,059 --> 00:19:47,989
functional code that we I used not to

00:19:45,389 --> 00:19:51,379
have properly on JVM we used to have a

00:19:47,989 --> 00:19:55,289
subset of tail course we would not have

00:19:51,379 --> 00:19:56,639
mutual tail calls before and that

00:19:55,289 --> 00:19:57,899
question which is like a very common is

00:19:56,639 --> 00:19:59,849
it the same language you probably

00:19:57,899 --> 00:20:01,889
changed everything so you because we

00:19:59,849 --> 00:20:02,500
have this like new stuff like struction

00:20:01,889 --> 00:20:04,090
pointers now

00:20:02,500 --> 00:20:06,850
it probably has completely different

00:20:04,090 --> 00:20:09,190
thing but not really a skylight south is

00:20:06,850 --> 00:20:11,470
the same same scholars that you already

00:20:09,190 --> 00:20:13,210
know and actually library is that we use

00:20:11,470 --> 00:20:15,580
are also same libraries nothing

00:20:13,210 --> 00:20:18,730
ultimately surprising about what we do

00:20:15,580 --> 00:20:22,420
it's just another way to compile your

00:20:18,730 --> 00:20:24,010
code and as I'm is just like it's

00:20:22,420 --> 00:20:26,410
probably like just the back end right

00:20:24,010 --> 00:20:29,560
you know back and like how hard can it

00:20:26,410 --> 00:20:31,780
be to make it back end just make it like

00:20:29,560 --> 00:20:33,820
a piece and a compiler and it's kind of

00:20:31,780 --> 00:20:37,120
Miss whatever you want to admit and and

00:20:33,820 --> 00:20:39,310
that's it right but it turns out to make

00:20:37,120 --> 00:20:42,640
a nice kind of like experience for any

00:20:39,310 --> 00:20:44,680
non GV m I completion target you really

00:20:42,640 --> 00:20:46,330
need to be a bit more in the back end in

00:20:44,680 --> 00:20:48,670
to be a bit more of a platform you to

00:20:46,330 --> 00:20:50,170
have some internal representation some

00:20:48,670 --> 00:20:56,050
internal kind of language that you use

00:20:50,170 --> 00:20:59,830
to maintain all of this magic behind the

00:20:56,050 --> 00:21:02,080
scenes because actually having just back

00:20:59,830 --> 00:21:04,000
end only works for JVM because Scala was

00:21:02,080 --> 00:21:05,620
designed with JVM in mind but if you

00:21:04,000 --> 00:21:06,910
want to compare anything trivial you

00:21:05,620 --> 00:21:08,290
really need to do something like that so

00:21:06,910 --> 00:21:09,880
you need to have intermediary

00:21:08,290 --> 00:21:11,200
presentation you need to like all of

00:21:09,880 --> 00:21:13,180
your front ends you support like 4am

00:21:11,200 --> 00:21:14,970
post ecology and dotty should a

00:21:13,180 --> 00:21:17,320
misrepresentation and it should be

00:21:14,970 --> 00:21:19,570
reasonably high level and then you have

00:21:17,320 --> 00:21:22,660
peace that combines everything together

00:21:19,570 --> 00:21:27,880
and produces your target thing this is

00:21:22,660 --> 00:21:30,610
architecture originally originally first

00:21:27,880 --> 00:21:33,190
happened in Scala GS and we just took it

00:21:30,610 --> 00:21:35,710
over as a nice working thing and was

00:21:33,190 --> 00:21:38,020
nice working thing and as you can see

00:21:35,710 --> 00:21:42,100
here also we will support both Coliseum

00:21:38,020 --> 00:21:45,310
dotty and it's actually quite important

00:21:42,100 --> 00:21:47,290
too because in dotty we have lots of new

00:21:45,310 --> 00:21:50,290
cool things going on like four ample

00:21:47,290 --> 00:21:53,230
hear this lto box is this cool new

00:21:50,290 --> 00:21:56,740
things that Dimitri is working on and

00:21:53,230 --> 00:21:58,060
it's a link time optimizer that does all

00:21:56,740 --> 00:21:59,320
of the cool stuff with a coward to

00:21:58,060 --> 00:22:01,570
remove all of the high level features

00:21:59,320 --> 00:22:03,880
and replace it with lower level features

00:22:01,570 --> 00:22:06,310
so that when asked allah native happens

00:22:03,880 --> 00:22:07,960
it can compile low-level features into

00:22:06,310 --> 00:22:10,570
moral all the features the demise the

00:22:07,960 --> 00:22:12,390
way to a constant again as some of you

00:22:10,570 --> 00:22:16,390
might have seen on Doug dimas

00:22:12,390 --> 00:22:19,430
presentation but generally it's a

00:22:16,390 --> 00:22:21,560
dr. linker is a very cool thing that is

00:22:19,430 --> 00:22:24,200
going to happen in dodgy and we would

00:22:21,560 --> 00:22:27,260
really want to support that yet as much

00:22:24,200 --> 00:22:32,180
as possible and have it the first class

00:22:27,260 --> 00:22:34,220
citizen so another question is like does

00:22:32,180 --> 00:22:37,100
it GC so decide that it's not have GC

00:22:34,220 --> 00:22:38,960
issues but did you probably still have a

00:22:37,100 --> 00:22:41,720
GC and the answer is yet we still have a

00:22:38,960 --> 00:22:44,810
GC we currently use something called boy

00:22:41,720 --> 00:22:47,480
mgc it's quite a bit slower like two to

00:22:44,810 --> 00:22:50,720
three times slower GT itself than GV

00:22:47,480 --> 00:22:55,430
MVC's but it can only get better from

00:22:50,720 --> 00:22:57,290
the right so we already have some plans

00:22:55,430 --> 00:22:59,450
to improve this thing so stay tuned

00:22:57,290 --> 00:23:03,680
we'll probably do something else in this

00:22:59,450 --> 00:23:06,050
area in the space in your future and of

00:23:03,680 --> 00:23:08,060
course once calling anything you don't

00:23:06,050 --> 00:23:10,880
always need to GC because if you can

00:23:08,060 --> 00:23:13,070
express your Ted loops in a lower level

00:23:10,880 --> 00:23:16,130
concepts you can easily make no GC at

00:23:13,070 --> 00:23:21,260
all and then GC performance doesn't

00:23:16,130 --> 00:23:25,130
matter because you don't do GC otherwise

00:23:21,260 --> 00:23:30,110
we we've had an interest in our man

00:23:25,130 --> 00:23:32,300
dental both 32 and 64-bit on unix-like

00:23:30,110 --> 00:23:34,940
operating systems and currently we're

00:23:32,300 --> 00:23:37,700
we're mostly developing on intel 64 bit

00:23:34,940 --> 00:23:41,840
what we plan to expand this in the

00:23:37,700 --> 00:23:44,480
future well library wise like i said

00:23:41,840 --> 00:23:45,890
before scala native doesn't try to be

00:23:44,480 --> 00:23:47,750
the completely different like these that

00:23:45,890 --> 00:23:49,610
you would need to learn actually it's

00:23:47,750 --> 00:23:51,050
kind of tries to be the most least

00:23:49,610 --> 00:23:53,780
surprising seeing you can possibly get

00:23:51,050 --> 00:23:56,360
and and for this we actually take an

00:23:53,780 --> 00:23:59,600
effort to port java libraries and just

00:23:56,360 --> 00:24:02,510
make them work as if they were like on

00:23:59,600 --> 00:24:04,430
JVM so we really take effort to make

00:24:02,510 --> 00:24:07,070
least surprising environment for

00:24:04,430 --> 00:24:08,660
existing scholar developers and it also

00:24:07,070 --> 00:24:10,610
should make quite easy to port existing

00:24:08,660 --> 00:24:12,680
libraries to ask allah native because

00:24:10,610 --> 00:24:17,540
you'll be able just use a basically the

00:24:12,680 --> 00:24:20,090
same code without any changes and lastly

00:24:17,540 --> 00:24:21,950
this question of when is very popular

00:24:20,090 --> 00:24:25,610
one when is going to be released

00:24:21,950 --> 00:24:27,950
whenever when can we try it so I first

00:24:25,610 --> 00:24:29,870
stable thing like more or less stable

00:24:27,950 --> 00:24:30,140
thing like first preview is going to

00:24:29,870 --> 00:24:32,660
release

00:24:30,140 --> 00:24:34,960
the near future you can already try it

00:24:32,660 --> 00:24:37,820
like this thing I've shown you before

00:24:34,960 --> 00:24:38,870
boac escala native is a nice repose that

00:24:37,820 --> 00:24:41,810
you can clone and you can actually

00:24:38,870 --> 00:24:44,180
follow the instructions and and have it

00:24:41,810 --> 00:24:46,610
built basically already it will be a bit

00:24:44,180 --> 00:24:48,350
nicer in the future in 0.1 because we

00:24:46,610 --> 00:24:50,210
will add some the contextual

00:24:48,350 --> 00:24:54,620
documentation and so on the force and

00:24:50,210 --> 00:24:58,310
from then on we we plan to stick to

00:24:54,620 --> 00:25:02,840
monthly updates to kind of to make sure

00:24:58,310 --> 00:25:07,040
like that we can quickly about the

00:25:02,840 --> 00:25:08,930
project just a stable thing so if you

00:25:07,040 --> 00:25:10,580
want to get updated when this happens we

00:25:08,930 --> 00:25:13,490
will most definitely post this on

00:25:10,580 --> 00:25:15,530
Twitter and an hour like scar native

00:25:13,490 --> 00:25:16,880
Twitter account so if you follow that

00:25:15,530 --> 00:25:20,150
you will most definitely see a twit

00:25:16,880 --> 00:25:22,820
about how we became stable for some

00:25:20,150 --> 00:25:26,320
definition of stable of course that's

00:25:22,820 --> 00:25:26,320
about it thanks

00:25:36,010 --> 00:25:48,370
so questions so I think where people

00:25:43,340 --> 00:25:53,360
with mics are walking around can I ok

00:25:48,370 --> 00:25:56,870
yes I will there be some compiler for

00:25:53,360 --> 00:25:59,179
java source code or byte code so you can

00:25:56,870 --> 00:26:00,950
port other libraries as well so right

00:25:59,179 --> 00:26:03,650
now we don't plan on having anything

00:26:00,950 --> 00:26:06,409
like this in near future so at the

00:26:03,650 --> 00:26:08,120
moment our current strategy is to work

00:26:06,409 --> 00:26:10,340
stuff to scala it's actually quite easy

00:26:08,120 --> 00:26:13,179
so most of the time when we pour stuff

00:26:10,340 --> 00:26:15,230
it takes better like a few hours per

00:26:13,179 --> 00:26:17,330
1,000 line of code resumption because

00:26:15,230 --> 00:26:20,030
code usually get smaller when you do

00:26:17,330 --> 00:26:23,990
this so it's nice we don't plan to have

00:26:20,030 --> 00:26:30,200
java bytecode or Java source support in

00:26:23,990 --> 00:26:32,900
any near future ok thanks so thanks

00:26:30,200 --> 00:26:35,150
going forward do you think that you want

00:26:32,900 --> 00:26:37,880
to go in the same direction as modulus

00:26:35,150 --> 00:26:40,490
rust language they have this power

00:26:37,880 --> 00:26:42,470
checker which is essentially it kind of

00:26:40,490 --> 00:26:44,450
feels to me like all the Scala type

00:26:42,470 --> 00:26:46,820
safety boots applied to memory

00:26:44,450 --> 00:26:48,919
primitives yep so do you want to do

00:26:46,820 --> 00:26:51,770
something similar or really just provide

00:26:48,919 --> 00:26:53,990
a way for me to allocate a struct on the

00:26:51,770 --> 00:26:56,000
stack on the heap so it's a very good

00:26:53,990 --> 00:26:57,950
question so this question was do we want

00:26:56,000 --> 00:27:00,289
to be more like rust in the future and

00:26:57,950 --> 00:27:02,179
the answer is we can all be more like la

00:27:00,289 --> 00:27:05,990
la crosse unless we completely change

00:27:02,179 --> 00:27:08,900
language in a non obvious ways so russ

00:27:05,990 --> 00:27:10,429
has a very interesting extremely

00:27:08,900 --> 00:27:13,549
extremely powerful type system to

00:27:10,429 --> 00:27:15,710
control ownership in the type system so

00:27:13,549 --> 00:27:18,650
any types that you know for each and

00:27:15,710 --> 00:27:20,570
every allocation is it owned by any by

00:27:18,650 --> 00:27:23,179
tomorrow location and this allows this

00:27:20,570 --> 00:27:24,580
kind of nice to construct this nice to

00:27:23,179 --> 00:27:28,610
use of allocations automatically

00:27:24,580 --> 00:27:31,270
deallocated when your tree road

00:27:28,610 --> 00:27:34,700
disappears the problem is that in scala

00:27:31,270 --> 00:27:36,049
very often you don't have to like graphs

00:27:34,700 --> 00:27:38,630
of allocations you where you often have

00:27:36,049 --> 00:27:40,490
loops and it's extremely easy to get

00:27:38,630 --> 00:27:42,380
loops with closures it's extremely easy

00:27:40,490 --> 00:27:45,409
to get loops with inner classes and

00:27:42,380 --> 00:27:47,059
generally it will be from like

00:27:45,409 --> 00:27:47,940
borderline impossible to make it work

00:27:47,059 --> 00:27:50,429
with scallion my opinio

00:27:47,940 --> 00:27:51,870
because rust only works because it was

00:27:50,429 --> 00:27:55,500
designed with this kind of concept in

00:27:51,870 --> 00:27:58,220
mind I really want to explore a bit more

00:27:55,500 --> 00:28:01,350
in a space of memory management in like

00:27:58,220 --> 00:28:03,809
semi manual semi automatic memory

00:28:01,350 --> 00:28:05,490
management I think a concept of regions

00:28:03,809 --> 00:28:08,519
will probably work better for skylar

00:28:05,490 --> 00:28:11,460
Laine tears because original actually

00:28:08,519 --> 00:28:13,379
impress cycles and they're also quite

00:28:11,460 --> 00:28:16,409
fast so we will probably explore

00:28:13,379 --> 00:28:18,179
something in a more lower level memory

00:28:16,409 --> 00:28:20,070
management techniques but it will most

00:28:18,179 --> 00:28:22,320
likely not be something like Ross

00:28:20,070 --> 00:28:27,330
because that doesn't work for skull

00:28:22,320 --> 00:28:29,370
unfortunately yes so so one of your

00:28:27,330 --> 00:28:33,120
motivations behind this was to either

00:28:29,370 --> 00:28:35,850
reduce GC or remove it in there in the

00:28:33,120 --> 00:28:39,049
resulting binary so as a user is there a

00:28:35,850 --> 00:28:44,340
way for me to find out how much GC my

00:28:39,049 --> 00:28:46,950
skull a native application is using such

00:28:44,340 --> 00:28:49,529
question was like do you have any kind

00:28:46,950 --> 00:28:54,240
of infrastructure to profile right now

00:28:49,529 --> 00:28:56,070
and connive we already work with native

00:28:54,240 --> 00:28:57,649
profilers like sample on Apple operating

00:28:56,070 --> 00:29:00,179
system you can use instruments

00:28:57,649 --> 00:29:02,610
instruments is nice graphical profilers

00:29:00,179 --> 00:29:04,470
that lets you kind of shows you where

00:29:02,610 --> 00:29:06,870
you're like hot spots and so on the

00:29:04,470 --> 00:29:09,629
first in your native apps it just works

00:29:06,870 --> 00:29:12,179
with scholarly and in our case GC is

00:29:09,629 --> 00:29:15,059
just library and it's actually possible

00:29:12,179 --> 00:29:16,740
to see if something DC is too much

00:29:15,059 --> 00:29:19,950
because you will have too much time

00:29:16,740 --> 00:29:23,879
spent in functions named GC underscore

00:29:19,950 --> 00:29:27,120
different names and it actually should

00:29:23,879 --> 00:29:29,460
be quite easy but to see how bad GC

00:29:27,120 --> 00:29:37,860
impacts your app just looking at the

00:29:29,460 --> 00:29:40,350
profiles yeah me yeah I have a mic

00:29:37,860 --> 00:29:42,899
because that's me so I see your

00:29:40,350 --> 00:29:45,179
implemented several namespaces from Java

00:29:42,899 --> 00:29:48,780
so when do you expect a lawsuit from

00:29:45,179 --> 00:29:52,060
Oracle I'm sorry I would

00:29:48,780 --> 00:29:53,650
sorry maybe a lot of successful joke but

00:29:52,060 --> 00:29:57,550
I mean apparently you're implemented

00:29:53,650 --> 00:30:00,280
certain like classes from Java and space

00:29:57,550 --> 00:30:02,140
yeah right so and we all know that there

00:30:00,280 --> 00:30:04,420
was a story about the google and Oracle

00:30:02,140 --> 00:30:06,250
lawsuit recently and yeah it seems quite

00:30:04,420 --> 00:30:08,020
similar case for me isn't it so all I

00:30:06,250 --> 00:30:10,960
can say is that in a final case google

00:30:08,020 --> 00:30:14,530
versus oracle google's use of java api

00:30:10,960 --> 00:30:17,170
ice was fair use Oh computed yeah so

00:30:14,530 --> 00:30:20,470
it's fair use I guess but generally like

00:30:17,170 --> 00:30:21,670
no comments I'm not a legal person so

00:30:20,470 --> 00:30:41,920
you should probably ask these questions

00:30:21,670 --> 00:30:45,220
to a really good person yeah what about

00:30:41,920 --> 00:30:47,470
spark and Scala native spark is very

00:30:45,220 --> 00:30:49,600
interesting app we want to run

00:30:47,470 --> 00:30:52,060
eventually right now we are blocked

00:30:49,600 --> 00:30:54,790
basically by how much we implement up

00:30:52,060 --> 00:30:56,770
jdk to makes library sex parkour acha

00:30:54,790 --> 00:30:59,980
happen but i'm definitely interested in

00:30:56,770 --> 00:31:01,570
seeing like large frameworks we already

00:30:59,980 --> 00:31:03,520
have to run on Scola native so it

00:31:01,570 --> 00:31:05,800
basically is bound by us having a

00:31:03,520 --> 00:31:07,780
reasonably complete implementation of

00:31:05,800 --> 00:31:10,210
those once we have those it should be

00:31:07,780 --> 00:31:11,890
doable to pour stuff we already have a

00:31:10,210 --> 00:31:13,720
cone JavaScript so it should not be

00:31:11,890 --> 00:31:18,010
friend bull to impossible to have a

00:31:13,720 --> 00:31:20,830
cooling alternative and for spark is a

00:31:18,010 --> 00:31:22,420
bigger code base I cannot definitely say

00:31:20,830 --> 00:31:24,760
how is it is but I would say we probably

00:31:22,420 --> 00:31:26,860
see account native before we see Sparkle

00:31:24,760 --> 00:31:34,090
native and it from zero knee it can only

00:31:26,860 --> 00:31:37,180
get better any more questions 11 here

00:31:34,090 --> 00:31:39,430
yeah you mentioned you don't like the J

00:31:37,180 --> 00:31:41,800
and I I think nobody likes it but what

00:31:39,430 --> 00:31:43,900
are your ideas on how to get interrupt

00:31:41,800 --> 00:31:45,790
with other languages okay go on on

00:31:43,900 --> 00:31:47,740
scholar it's a very question i'll just

00:31:45,790 --> 00:31:53,620
show you a small snippets that we

00:31:47,740 --> 00:31:55,960
actually have basically interop we see

00:31:53,620 --> 00:31:58,300
is right now we are starting with see

00:31:55,960 --> 00:32:00,880
the first language group we interrupt

00:31:58,300 --> 00:32:01,970
nicely with this is how it looks to call

00:32:00,880 --> 00:32:04,010
a see funk

00:32:01,970 --> 00:32:06,350
from Scott native the define thing

00:32:04,010 --> 00:32:08,180
called external object external object

00:32:06,350 --> 00:32:09,620
is basically just a place where you put

00:32:08,180 --> 00:32:11,840
all of the signatures for see stuff you

00:32:09,620 --> 00:32:13,550
want to call and that's it that's all

00:32:11,840 --> 00:32:16,250
you need you don't need to write any

00:32:13,550 --> 00:32:18,200
rapper sequel you don't need to do any

00:32:16,250 --> 00:32:20,210
kind of weird magic that like any weird

00:32:18,200 --> 00:32:22,370
environments that gene I makes you do

00:32:20,210 --> 00:32:23,930
it's all you need to do basically all of

00:32:22,370 --> 00:32:25,850
the code tour across is required to call

00:32:23,930 --> 00:32:28,520
malloc and it will automatically you can

00:32:25,850 --> 00:32:30,590
also specify what libraries you would

00:32:28,520 --> 00:32:32,060
like to link with I'm going to use this

00:32:30,590 --> 00:32:34,700
function for example when you use malloc

00:32:32,060 --> 00:32:37,280
bramble I can imagine people using GE

00:32:34,700 --> 00:32:38,930
Malik which is a better Malik and you

00:32:37,280 --> 00:32:41,090
can annotate your external objects with

00:32:38,930 --> 00:32:42,710
link it will automatically also linked

00:32:41,090 --> 00:32:45,650
with native libraries that are necessary

00:32:42,710 --> 00:32:48,500
so it's super easy and in the future

00:32:45,650 --> 00:32:50,570
we'll were interested in supporting more

00:32:48,500 --> 00:32:52,700
languages I cannot promise you anything

00:32:50,570 --> 00:32:59,110
sorry but we have an issue in the

00:32:52,700 --> 00:32:59,110
backlog called objective-c intro yeah

00:33:04,429 --> 00:33:10,580
so my question is also about Intel

00:33:07,509 --> 00:33:14,240
ability but in the other way do plan to

00:33:10,580 --> 00:33:17,330
make it easy to use scar native

00:33:14,240 --> 00:33:19,970
developed modules from inside the JVM

00:33:17,330 --> 00:33:21,860
scholar so scott- likes question was

00:33:19,970 --> 00:33:23,509
like how do you call colony from jvm and

00:33:21,860 --> 00:33:26,149
the other way around and the answer is

00:33:23,509 --> 00:33:30,409
scar native lets you expose a stop-over

00:33:26,149 --> 00:33:33,769
see ABI and JVM lets you consume stour

00:33:30,409 --> 00:33:36,470
stuff over see ABI so it should be quite

00:33:33,769 --> 00:33:41,779
doable to just use gene is boundary if

00:33:36,470 --> 00:33:43,700
you are brave enough but short of that

00:33:41,779 --> 00:33:46,220
we don't plan to have anything more than

00:33:43,700 --> 00:33:48,350
that because again there is only one way

00:33:46,220 --> 00:33:53,529
into JVM from native code is Jane I and

00:33:48,350 --> 00:33:53,529
that's basically kind of the thing yeah

00:33:53,889 --> 00:33:56,889
yeah

00:34:00,859 --> 00:34:06,749
okay as the question was how do you

00:34:04,379 --> 00:34:10,589
distribute collins car native as the

00:34:06,749 --> 00:34:13,109
answer to that is this nir thing or over

00:34:10,589 --> 00:34:15,149
here is basically you can think of it as

00:34:13,109 --> 00:34:18,179
our own bytecode like its culinary byte

00:34:15,149 --> 00:34:20,819
code which is the things that you will

00:34:18,179 --> 00:34:22,139
distribute in jars so it's like it's

00:34:20,819 --> 00:34:24,899
very similar to ecology as it's called

00:34:22,139 --> 00:34:28,289
Jesse published SGS I are in Scala

00:34:24,899 --> 00:34:30,419
meticulously nir so basically you

00:34:28,289 --> 00:34:32,909
publish bytecode and then you only

00:34:30,419 --> 00:34:36,329
compiled native code like when you get

00:34:32,909 --> 00:34:41,700
all the by squad for everything and then

00:34:36,329 --> 00:34:44,639
you link it and you get an ad binary yes

00:34:41,700 --> 00:34:48,269
what about network and Freddie network

00:34:44,639 --> 00:34:50,450
and was reading starting on so at the

00:34:48,269 --> 00:34:53,490
moment in 0.1 we're going to be

00:34:50,450 --> 00:34:55,169
single-stranded likes colleges but it's

00:34:53,490 --> 00:34:57,390
an inflammation restriction that we will

00:34:55,169 --> 00:35:02,480
most definitely fix before 1.0 so will

00:34:57,390 --> 00:35:06,000
lend to have her lism so basically

00:35:02,480 --> 00:35:09,000
starting part and networking so we'll

00:35:06,000 --> 00:35:11,279
have Java and I of stuff and I of stuff

00:35:09,000 --> 00:35:13,650
and javan and stuff so basically all the

00:35:11,279 --> 00:35:21,210
api's you already know it will not need

00:35:13,650 --> 00:35:26,700
to learn anything you yes so you're

00:35:21,210 --> 00:35:27,990
speaking about sorry sorry yes the

00:35:26,700 --> 00:35:30,089
basically the question was like tasty

00:35:27,990 --> 00:35:31,410
what happens when tasty happens so when

00:35:30,089 --> 00:35:33,660
tasty happens this picture again

00:35:31,410 --> 00:35:36,829
potentially simplifying we'll just need

00:35:33,660 --> 00:35:39,569
will not need to publish java classes

00:35:36,829 --> 00:35:41,400
colleges classes and nir classes and

00:35:39,569 --> 00:35:45,210
everything like in many many different

00:35:41,400 --> 00:35:48,480
like cross projects hopefully and never

00:35:45,210 --> 00:35:50,759
by like right now it's like not in the

00:35:48,480 --> 00:35:53,099
state yet but hopefully when tasty is

00:35:50,759 --> 00:35:54,569
finally there in stable will be able to

00:35:53,099 --> 00:35:56,640
just published HT basically that's kind

00:35:54,569 --> 00:36:00,000
of like the thing i would like to see in

00:35:56,640 --> 00:36:01,950
the future but it's long run to roll

00:36:00,000 --> 00:36:03,930
together and we'll have this nir think

00:36:01,950 --> 00:36:05,430
before it happens but that tastes

00:36:03,930 --> 00:36:07,980
definitely looks like a thing that can

00:36:05,430 --> 00:36:10,049
potentially make it easier to distribute

00:36:07,980 --> 00:36:12,920
stout just once but it's yet to be seen

00:36:10,049 --> 00:36:12,920
if it works out

00:36:13,310 --> 00:36:21,329
yes yes okay you hear me oh so I wanted

00:36:19,920 --> 00:36:23,520
to ask you you've been the detailing

00:36:21,329 --> 00:36:25,589
what is the translation that they that

00:36:23,520 --> 00:36:27,570
we this is car native you save a lot of

00:36:25,589 --> 00:36:30,420
a locational that you make it more

00:36:27,570 --> 00:36:32,550
quicker than day on the using of a stack

00:36:30,420 --> 00:36:34,829
memory / heap memory that's part of the

00:36:32,550 --> 00:36:38,220
motivation the system there's a few

00:36:34,829 --> 00:36:41,060
member mm-hmm I wanted to ask how we see

00:36:38,220 --> 00:36:43,740
is there any difficulty or is there any

00:36:41,060 --> 00:36:46,099
are they which will be the challenges

00:36:43,740 --> 00:36:50,550
that you can find in the translation a

00:36:46,099 --> 00:36:52,859
regarding any other issue like a basic

00:36:50,550 --> 00:36:55,980
arithmetic instructions from the GV m to

00:36:52,859 --> 00:36:58,530
the llvm intermediate representation or

00:36:55,980 --> 00:37:02,010
in particularly concurrency primitives

00:36:58,530 --> 00:37:03,510
do you have any difficulty Bezos short

00:37:02,010 --> 00:37:05,790
mask so the answer my question correctly

00:37:03,510 --> 00:37:07,530
she asking why can't we just do it on

00:37:05,790 --> 00:37:10,920
JVM like to experiment with memory

00:37:07,530 --> 00:37:13,130
management no no what I'm doing is which

00:37:10,920 --> 00:37:15,089
are the challenges you may have found a

00:37:13,130 --> 00:37:17,160
regarding a basic arithmetic

00:37:15,089 --> 00:37:19,260
instructions the semantics of basic

00:37:17,160 --> 00:37:22,099
arithmetic instructions and types when

00:37:19,260 --> 00:37:24,750
translation from they gave him to the

00:37:22,099 --> 00:37:28,560
llvm the intermediate representation of

00:37:24,750 --> 00:37:30,980
the okay so you're asking what kind of

00:37:28,560 --> 00:37:33,930
instruction we are missing on JVM

00:37:30,980 --> 00:37:36,990
basically answer available and Olivia

00:37:33,930 --> 00:37:38,460
miss right if you had any problem or any

00:37:36,990 --> 00:37:41,190
mismatch between the meaning of the

00:37:38,460 --> 00:37:45,690
instructions between give a kvm or the

00:37:41,190 --> 00:37:47,250
llvm so basically as arcing is our own

00:37:45,690 --> 00:37:50,160
like essentially our own instructions

00:37:47,250 --> 00:37:53,220
that we map to lv m it has more features

00:37:50,160 --> 00:37:54,960
in JVM bytecode and not all of them are

00:37:53,220 --> 00:37:56,819
expressible in JVM bytecode examples

00:37:54,960 --> 00:37:58,260
trucks and pointers at the moment are

00:37:56,819 --> 00:38:01,079
not easily expressible in JVM bytecode

00:37:58,260 --> 00:38:03,960
and in lv m because it's essentially a

00:38:01,079 --> 00:38:06,180
high-level assembly it's like lower

00:38:03,960 --> 00:38:08,190
level c or something I know higher level

00:38:06,180 --> 00:38:09,810
assembly this also happens to be most

00:38:08,190 --> 00:38:11,430
about from dependent it can actually

00:38:09,810 --> 00:38:14,369
express anything you want to lv m there

00:38:11,430 --> 00:38:15,900
is no have restriction what you can do a

00:38:14,369 --> 00:38:17,730
lithium is basically like you're only

00:38:15,900 --> 00:38:22,200
constrained by your own kind of like

00:38:17,730 --> 00:38:24,569
creative vision of something random one

00:38:22,200 --> 00:38:26,309
more question about it a is it is here

00:38:24,569 --> 00:38:28,680
in the llvm to represent a

00:38:26,309 --> 00:38:30,479
alumnus in particular or anonymous

00:38:28,680 --> 00:38:33,869
function or any in general function

00:38:30,479 --> 00:38:36,469
objects so now just sinks existing

00:38:33,869 --> 00:38:39,150
Lillian lvm is super low level it has

00:38:36,469 --> 00:38:42,059
top level functions it has pointers it

00:38:39,150 --> 00:38:46,920
has struct and this about it that's what

00:38:42,059 --> 00:38:48,449
we compile to ok I am asking because i

00:38:46,920 --> 00:38:51,239
think that the opponent for the gaba

00:38:48,449 --> 00:38:53,039
developed for together for the people

00:38:51,239 --> 00:38:55,289
who develop the java compiler getting

00:38:53,039 --> 00:38:57,180
lambda anonymous function at listen to

00:38:55,289 --> 00:39:00,059
the language and i don't know if it will

00:38:57,180 --> 00:39:01,140
relate it to the GBM i think you I think

00:39:00,059 --> 00:39:15,059
I don't quite understand what you mean

00:39:01,140 --> 00:39:17,099
 I take it offline yes uh-huh so I

00:39:15,059 --> 00:39:18,630
can show you how it looks like it is

00:39:17,099 --> 00:39:25,259
human readable for some definition of

00:39:18,630 --> 00:39:27,689
human readable yeah we have a docs

00:39:25,259 --> 00:39:29,999
branch which is a bit outdated this is

00:39:27,689 --> 00:39:34,979
why it's not merge deals so in this dogs

00:39:29,999 --> 00:39:36,569
Browns you have nir md and how it looks

00:39:34,979 --> 00:39:41,339
like is basically a bit like a suit

00:39:36,569 --> 00:39:43,049
given this source file over here so we

00:39:41,339 --> 00:39:45,869
have an object that says hello world

00:39:43,049 --> 00:39:48,179
again this is how it looks in nir so

00:39:45,869 --> 00:39:51,179
first of all it's an SS a basic block

00:39:48,179 --> 00:39:53,009
ashing similar to llvm but the main

00:39:51,179 --> 00:39:55,559
difference is that it has high level

00:39:53,009 --> 00:39:57,779
features like classes modules as instant

00:39:55,559 --> 00:39:59,969
selves is instant selves and all of the

00:39:57,779 --> 00:40:01,709
things that we need to do scarlett it

00:39:59,969 --> 00:40:04,400
also has closures and and so on so forth

00:40:01,709 --> 00:40:08,130
so it's actually quite a bit of stuff

00:40:04,400 --> 00:40:10,769
over lvm and our main challenge in that

00:40:08,130 --> 00:40:12,059
in the tool chain is to remove all of

00:40:10,769 --> 00:40:13,799
the high level features on the place and

00:40:12,059 --> 00:40:16,699
with lower features and as I said

00:40:13,799 --> 00:40:18,959
features and olivium a very low level in

00:40:16,699 --> 00:40:21,689
so you can actually like look through

00:40:18,959 --> 00:40:24,900
it's a bit out of date but just slightly

00:40:21,689 --> 00:40:27,199
so it's topic docs basically web dogs

00:40:24,900 --> 00:40:27,199
okay

00:40:32,250 --> 00:40:37,810
so right now we've had like in our like

00:40:35,680 --> 00:40:41,440
getter community Singh people running it

00:40:37,810 --> 00:40:44,290
on freebsd linux and mac at least that's

00:40:41,440 --> 00:40:46,210
what that's this one's they know if

00:40:44,290 --> 00:40:49,150
maybe someone managed to like and also

00:40:46,210 --> 00:40:51,130
i've seen like iOS demo so generally we

00:40:49,150 --> 00:40:53,770
are not very bound by the hardware

00:40:51,130 --> 00:40:55,150
architecture because llvm is quite we

00:40:53,770 --> 00:40:58,090
use lvm in ways which is not very

00:40:55,150 --> 00:40:59,920
platform dependent so we basically it's

00:40:58,090 --> 00:41:04,120
very easy to port it to market actors if

00:40:59,920 --> 00:41:05,230
someone wants to lately basically the

00:41:04,120 --> 00:41:09,700
only thing we don't support now with

00:41:05,230 --> 00:41:13,180
windows again are you going to provide

00:41:09,700 --> 00:41:15,790
any debugging tools I me on the native

00:41:13,180 --> 00:41:18,040
layer like so the question is like how

00:41:15,790 --> 00:41:22,540
do you debug this thing and the answer

00:41:18,040 --> 00:41:23,920
is right now is used ldb it will not be

00:41:22,540 --> 00:41:26,380
super high level it will show you stack

00:41:23,920 --> 00:41:28,180
traces it will let you look at the

00:41:26,380 --> 00:41:31,390
assembly and soon you'll also be able to

00:41:28,180 --> 00:41:33,580
correlate assembly to a source code in

00:41:31,390 --> 00:41:35,590
Scotland so it will get a bit better

00:41:33,580 --> 00:41:37,330
over time and get a bit more high level

00:41:35,590 --> 00:41:39,160
over time and I think Apple tools are

00:41:37,330 --> 00:41:40,720
built on llvm infrastructure so you

00:41:39,160 --> 00:41:46,540
might also be able to apple juice apple

00:41:40,720 --> 00:41:53,020
juice eventually to the boxes thing any

00:41:46,540 --> 00:41:55,170
more questions ok I guess not ok cool

00:41:53,020 --> 00:41:55,170
thanks

00:41:59,340 --> 00:42:01,400

YouTube URL: https://www.youtube.com/watch?v=KZejtgdniqc


