Title: Beyond the Buzzword: A Reactive Web Application in Practice by Manuel Bernhardt
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
In this talk/live-coding session, we will have a practical look at how a reactive web application is different from a "normal" one and how resilience, elasticity and responsiveness translate into code. We will start by having a quick theoretical introduction to asynchronous computation and then build, run, deploy and load-test a small reactive web application built with the Play Framework, exploring a few key concepts such as Futures, Actors and Circuit Breakers along the way.
Captions: 
	00:00:02,370 --> 00:00:09,480
I'd like to talk about reactive web

00:00:07,080 --> 00:00:12,089
applications and what they mean

00:00:09,480 --> 00:00:15,509
beyond the buzz word because reactive

00:00:12,089 --> 00:00:17,700
has been hyped quite a bit and there is

00:00:15,509 --> 00:00:20,369
a there's an application after this talk

00:00:17,700 --> 00:00:22,380
if you like this or please rate it so

00:00:20,369 --> 00:00:25,529
what we're going to take about a talk

00:00:22,380 --> 00:00:27,720
about here is that's word first design

00:00:25,529 --> 00:00:29,730
is how do you build your software

00:00:27,720 --> 00:00:31,469
infrastructure using only things you've

00:00:29,730 --> 00:00:35,370
heard in the media and on your Twitter

00:00:31,469 --> 00:00:37,260
streams don't do this

00:00:35,370 --> 00:00:39,179
you can do it at home but don't do this

00:00:37,260 --> 00:00:41,070
for your job now what I want to talk

00:00:39,179 --> 00:00:43,920
about is is reactive which has been

00:00:41,070 --> 00:00:45,480
hyped quite a bit and now slowly we see

00:00:43,920 --> 00:00:49,589
that it's actually something more than

00:00:45,480 --> 00:00:52,170
just a hype and this talk will be in two

00:00:49,589 --> 00:00:54,210
parts there will be the first part which

00:00:52,170 --> 00:00:55,469
is rather short on theory of the

00:00:54,210 --> 00:00:57,539
evolution of web application

00:00:55,469 --> 00:01:00,179
architecture and the evolution of

00:00:57,539 --> 00:01:02,339
hardware and then there will be some

00:01:00,179 --> 00:01:05,339
live coding most of the rest of the talk

00:01:02,339 --> 00:01:06,810
and if there is some time left I will

00:01:05,339 --> 00:01:09,330
talk a bit about deployment and load

00:01:06,810 --> 00:01:12,840
testing if at any point you have a

00:01:09,330 --> 00:01:14,520
question please interrupt me and ask it

00:01:12,840 --> 00:01:16,470
I like the sessions to be interactive

00:01:14,520 --> 00:01:18,300
don't be shy just if you don't

00:01:16,470 --> 00:01:23,070
understand something if I go too fast

00:01:18,300 --> 00:01:25,170
just let me know what about myself my

00:01:23,070 --> 00:01:27,180
name is mano bernhard what I do is to

00:01:25,170 --> 00:01:28,650
help established companies getting

00:01:27,180 --> 00:01:29,340
started with using reactive web

00:01:28,650 --> 00:01:32,010
applications

00:01:29,340 --> 00:01:33,750
and mostly with distributed systems

00:01:32,010 --> 00:01:36,870
which is because that's what reactive

00:01:33,750 --> 00:01:39,180
applications are all about and you can

00:01:36,870 --> 00:01:42,090
find more about I'm doing on my website

00:01:39,180 --> 00:01:45,030
Manuel Bernard IO and that's me scuba

00:01:42,090 --> 00:01:47,940
diving and I live in Vienna and Austria

00:01:45,030 --> 00:01:52,170
and this is not the Danube I wish it was

00:01:47,940 --> 00:01:54,810
and so scuba diving is one thing I do as

00:01:52,170 --> 00:01:57,510
a passion when I'm not doing computery

00:01:54,810 --> 00:02:00,510
things I wrote a book called reactive

00:01:57,510 --> 00:02:03,030
web applications which covers play akka

00:02:00,510 --> 00:02:07,200
wreck two streams the examples are in

00:02:03,030 --> 00:02:10,010
Scala and today you're lucky today I

00:02:07,200 --> 00:02:13,550
just got from my publisher

00:02:10,010 --> 00:02:16,400
an email that it's half it's 50% of

00:02:13,550 --> 00:02:18,170
today with this code so if at the end of

00:02:16,400 --> 00:02:21,170
the talk if you're interested in this

00:02:18,170 --> 00:02:24,650
you can use this code to get 50% off

00:02:21,170 --> 00:02:26,630
which is awesome and it was almost going

00:02:24,650 --> 00:02:28,790
to be in print at this conference okay

00:02:26,630 --> 00:02:31,610
we almost made it with the production

00:02:28,790 --> 00:02:32,960
team but we didn't quite make it so it

00:02:31,610 --> 00:02:34,670
would have been you would have been able

00:02:32,960 --> 00:02:40,160
to see it in print and get some copies

00:02:34,670 --> 00:02:42,650
but yeah it's not so sorry about that so

00:02:40,160 --> 00:02:47,150
let's go and talk about the architecture

00:02:42,650 --> 00:02:47,600
and history of how the web application

00:02:47,150 --> 00:02:52,220
architect

00:02:47,600 --> 00:02:57,080
architecture has evolved in the good old

00:02:52,220 --> 00:03:01,430
days who remembers this who has been

00:02:57,080 --> 00:03:03,530
building websites with this okay lots of

00:03:01,430 --> 00:03:07,040
people this was cool you had your stash

00:03:03,530 --> 00:03:09,500
of gif images that were animated and you

00:03:07,040 --> 00:03:11,090
would have turning back buttons and on

00:03:09,500 --> 00:03:14,360
every side there was a compulsory

00:03:11,090 --> 00:03:16,670
construction gif with this little guided

00:03:14,360 --> 00:03:17,930
was digging and showing that the site

00:03:16,670 --> 00:03:19,760
was under construction

00:03:17,930 --> 00:03:21,500
we don't do this nowadays anymore I

00:03:19,760 --> 00:03:25,370
don't know why I like this but um I

00:03:21,500 --> 00:03:29,300
think that times have changed so we had

00:03:25,370 --> 00:03:31,910
HTM files because DOS was not supporting

00:03:29,300 --> 00:03:34,220
more than three letters we had not HTML

00:03:31,910 --> 00:03:36,440
but HTM files and all you had to do in

00:03:34,220 --> 00:03:40,160
order to deploy this application was to

00:03:36,440 --> 00:03:42,140
upload it via FTP to some server and

00:03:40,160 --> 00:03:44,000
then it was running and that's it that's

00:03:42,140 --> 00:03:47,410
the end of the story it was great it was

00:03:44,000 --> 00:03:51,739
so easy yeah

00:03:47,410 --> 00:03:57,410
fast forward a few years later we had a

00:03:51,739 --> 00:03:59,360
very very how shall I say popular

00:03:57,410 --> 00:04:02,810
architecture so three-tier we have an

00:03:59,360 --> 00:04:04,880
apache HTTP server on in the front and

00:04:02,810 --> 00:04:07,220
application server in the middle or

00:04:04,880 --> 00:04:10,310
servlet server like Apache Tomcat and my

00:04:07,220 --> 00:04:13,370
sequel back-end database who used

00:04:10,310 --> 00:04:16,340
exactly this set up who has worked with

00:04:13,370 --> 00:04:18,229
exactly this yeah it was very popular it

00:04:16,340 --> 00:04:20,510
was great you know you had only two

00:04:18,229 --> 00:04:22,180
arrows there this is an arrow here

00:04:20,510 --> 00:04:26,570
and this is an arrow and an arrow

00:04:22,180 --> 00:04:28,610
represents a network connection and and

00:04:26,570 --> 00:04:30,440
that worked nicely you know you could do

00:04:28,610 --> 00:04:34,130
things but you couldn't do other things

00:04:30,440 --> 00:04:40,360
so and who can tell me what the next big

00:04:34,130 --> 00:04:43,850
thing is what happened after that PHP I

00:04:40,360 --> 00:04:46,490
always get PHP I don't know why everyone

00:04:43,850 --> 00:04:48,890
tells me that PHP happens I know it

00:04:46,490 --> 00:04:57,860
happened but no need to talk about it

00:04:48,890 --> 00:05:00,050
and sorry it's single page application

00:04:57,860 --> 00:05:01,790
yeah that's a bit that's also part of

00:05:00,050 --> 00:05:04,580
this thing but I'm talking in terms of

00:05:01,790 --> 00:05:06,110
architecture like a bigger change where

00:05:04,580 --> 00:05:11,000
you move your lip well how you deploy

00:05:06,110 --> 00:05:16,580
things application servers that that was

00:05:11,000 --> 00:05:22,910
more is the same a sorry without Apache

00:05:16,580 --> 00:05:25,130
in there yeah that's also so yeah okay

00:05:22,910 --> 00:05:26,600
yeah that's and that's not well this is

00:05:25,130 --> 00:05:29,680
hard to guess I don't know why nobody

00:05:26,600 --> 00:05:34,870
it's a buzz word as well that's a true

00:05:29,680 --> 00:05:34,870
cloud cloud cloud cloud

00:05:35,319 --> 00:05:41,469
so I did not make this up by the way

00:05:38,839 --> 00:05:44,509
this is a client project I came in and

00:05:41,469 --> 00:05:46,309
that was the thing we migrated away from

00:05:44,509 --> 00:05:48,799
and we need you to extract the data from

00:05:46,309 --> 00:05:52,909
this so you can count you have my sequel

00:05:48,799 --> 00:05:54,799
simple DB Redis then you have date

00:05:52,909 --> 00:05:55,219
metadata in SoundCloud YouTube and

00:05:54,799 --> 00:05:58,219
Mixcloud

00:05:55,219 --> 00:06:00,229
and there is some PHP in the middle and

00:05:58,219 --> 00:06:03,439
all of this we needed to extract the

00:06:00,229 --> 00:06:06,019
data from this stuff and we managed with

00:06:03,439 --> 00:06:08,119
that car thank you akka but that was

00:06:06,019 --> 00:06:15,409
that was interesting so cloud what

00:06:08,119 --> 00:06:17,209
happens when you use cloud is you you

00:06:15,409 --> 00:06:18,499
have a lot more arrows you have a lot

00:06:17,209 --> 00:06:19,999
more connections between things

00:06:18,499 --> 00:06:22,099
everything is in the cloud and

00:06:19,999 --> 00:06:27,709
everything talks to everything else in

00:06:22,099 --> 00:06:30,709
the cloud and beyond you know picking

00:06:27,709 --> 00:06:33,110
things at random what I really mean to

00:06:30,709 --> 00:06:35,659
say here is that there is a lot more IO

00:06:33,110 --> 00:06:38,929
a lot more network traffic happening

00:06:35,659 --> 00:06:40,610
that's the key that there is a lot more

00:06:38,929 --> 00:06:46,489
network traffic so if you're lucky and

00:06:40,610 --> 00:06:48,259
you deploy things in on some Amazon

00:06:46,489 --> 00:06:49,999
thing and everything is in the same data

00:06:48,259 --> 00:06:53,479
center all the other services you use

00:06:49,999 --> 00:06:55,369
are in the same data center it's kind of

00:06:53,479 --> 00:06:57,169
ok but if things span across data

00:06:55,369 --> 00:06:59,929
centers across the globe you start to

00:06:57,169 --> 00:07:03,709
see some hiccups and things start to be

00:06:59,929 --> 00:07:07,969
less smooth and so that's where where

00:07:03,709 --> 00:07:10,279
things become interesting so the next

00:07:07,969 --> 00:07:12,739
thing we have is and everyone talks

00:07:10,279 --> 00:07:14,299
about is micro services so you take the

00:07:12,739 --> 00:07:17,509
idea of the cloud and you multiply it

00:07:14,299 --> 00:07:22,449
times thousands and you end up with even

00:07:17,509 --> 00:07:26,749
more of this of this network connection

00:07:22,449 --> 00:07:28,309
traffic exchanges etc and if you if you

00:07:26,749 --> 00:07:32,869
look at this the first time I saw this I

00:07:28,309 --> 00:07:34,249
was like this reminds me of you know the

00:07:32,869 --> 00:07:37,699
Flying Spaghetti Monster kind of thing

00:07:34,249 --> 00:07:39,829
because somehow you know you have to be

00:07:37,699 --> 00:07:42,969
able to track what whatever happens I

00:07:39,829 --> 00:07:46,909
mean you see it's not only me is it so

00:07:42,969 --> 00:07:48,350
you kind of need to track now where your

00:07:46,909 --> 00:07:53,000
calls are going what

00:07:48,350 --> 00:07:55,160
what is going on at all and I'm making a

00:07:53,000 --> 00:07:57,650
bit fun of microservices there I really

00:07:55,160 --> 00:07:59,590
I think they're a really good invention

00:07:57,650 --> 00:08:03,140
and they're going to be really useful

00:07:59,590 --> 00:08:05,570
for large organizations with a big

00:08:03,140 --> 00:08:08,990
engineering team I think a cure services

00:08:05,570 --> 00:08:10,700
are useful when you have a large team if

00:08:08,990 --> 00:08:12,080
you don't have a large team don't use

00:08:10,700 --> 00:08:13,160
micro services I would say because

00:08:12,080 --> 00:08:16,250
you're shooting yourself in the foot

00:08:13,160 --> 00:08:18,740
deploying and operating micro services

00:08:16,250 --> 00:08:20,990
are is hard there is an overhead there

00:08:18,740 --> 00:08:23,990
micro services help you scale a large

00:08:20,990 --> 00:08:27,320
team by making it possible to work at a

00:08:23,990 --> 00:08:30,410
faster pace by having everyone work on a

00:08:27,320 --> 00:08:32,330
small subset of micro services and in my

00:08:30,410 --> 00:08:34,729
opinion that's why micro services are

00:08:32,330 --> 00:08:38,090
useful but again what we see is we have

00:08:34,729 --> 00:08:39,770
a lot more network traffic so when we

00:08:38,090 --> 00:08:41,930
think of network traffic and in the

00:08:39,770 --> 00:08:43,039
internet we think of the internet like

00:08:41,930 --> 00:08:43,550
this yeah we're the master of the

00:08:43,039 --> 00:08:46,070
Internet

00:08:43,550 --> 00:08:49,580
so I worked as study telecommunication I

00:08:46,070 --> 00:08:51,020
worked at a telco and networks they

00:08:49,580 --> 00:08:55,520
don't look like this networks look like

00:08:51,020 --> 00:08:58,940
this networks fail all the time networks

00:08:55,520 --> 00:09:01,370
are very flaky there are teams that work

00:08:58,940 --> 00:09:05,510
all around the clock and three times H

00:09:01,370 --> 00:09:08,720
hour shifts to keep the networks up so

00:09:05,510 --> 00:09:10,010
then the question is since everyone now

00:09:08,720 --> 00:09:13,130
builds this network distributed

00:09:10,010 --> 00:09:15,260
applications how do we maintain a level

00:09:13,130 --> 00:09:18,760
of quality on top of this shaky

00:09:15,260 --> 00:09:21,650
foundation and that is where reactive

00:09:18,760 --> 00:09:23,510
applications come in so I this is not an

00:09:21,650 --> 00:09:25,580
architecture itself is more of an

00:09:23,510 --> 00:09:28,430
architectural pattern that you apply on

00:09:25,580 --> 00:09:32,060
to something and it has four traits who

00:09:28,430 --> 00:09:34,220
have seen this before by the way most of

00:09:32,060 --> 00:09:35,990
you I'm gonna go quickly through it you

00:09:34,220 --> 00:09:39,740
want to build responsive applications

00:09:35,990 --> 00:09:41,690
that are always there and that are fast

00:09:39,740 --> 00:09:44,330
to load because if they don't load fast

00:09:41,690 --> 00:09:47,240
people will skip your site let's be

00:09:44,330 --> 00:09:49,790
honest I mean but I think who was it

00:09:47,240 --> 00:09:52,910
Amazon has done a great study and showed

00:09:49,790 --> 00:09:56,630
how the page load time influenced the

00:09:52,910 --> 00:09:58,100
amount of sales and orders of million

00:09:56,630 --> 00:10:00,740
hundreds of milliseconds of difference

00:09:58,100 --> 00:10:02,180
made had an impact on the sales it's

00:10:00,740 --> 00:10:04,880
completely crazy but it's

00:10:02,180 --> 00:10:06,830
what happens in order to be responsive

00:10:04,880 --> 00:10:09,980
you need two things on one hand you need

00:10:06,830 --> 00:10:13,010
to be resilient to failure if one third

00:10:09,980 --> 00:10:14,870
party service fails it doesn't mean that

00:10:13,010 --> 00:10:17,930
your whole site has to go down it just

00:10:14,870 --> 00:10:20,330
means that this this part you will not

00:10:17,930 --> 00:10:23,260
show it in your front page or you will

00:10:20,330 --> 00:10:26,660
use you will fall back to something else

00:10:23,260 --> 00:10:29,720
you want to be elastic in order to be

00:10:26,660 --> 00:10:31,670
able to scale out and scale back in when

00:10:29,720 --> 00:10:33,470
there is a higher load when you're when

00:10:31,670 --> 00:10:36,110
you're launching something when your

00:10:33,470 --> 00:10:38,450
site gets crowded by something you want

00:10:36,110 --> 00:10:40,070
to be able to quickly deploy your

00:10:38,450 --> 00:10:43,970
application or have it run on more

00:10:40,070 --> 00:10:46,130
resources and lastly in order to support

00:10:43,970 --> 00:10:48,080
all of this the idea is to be message

00:10:46,130 --> 00:10:50,779
driven which is to say that everything

00:10:48,080 --> 00:10:53,270
happens by messages being sent around

00:10:50,779 --> 00:10:56,959
your system including errors failure

00:10:53,270 --> 00:11:02,300
errors failures etc yet get propagated

00:10:56,959 --> 00:11:06,010
using messages so that was for the

00:11:02,300 --> 00:11:08,240
software part now in terms of hardware

00:11:06,010 --> 00:11:11,570
because hardware as we know it never

00:11:08,240 --> 00:11:14,209
involves and almost never this is great

00:11:11,570 --> 00:11:18,800
you know this is like 566 mega Hertz

00:11:14,209 --> 00:11:23,560
it's never absolutely and it has it even

00:11:18,800 --> 00:11:26,540
has 32 megabytes of RAM or something so

00:11:23,560 --> 00:11:29,690
on one hand we have CPUs that have been

00:11:26,540 --> 00:11:32,029
evolving so now what we have is not

00:11:29,690 --> 00:11:35,630
anymore single core CPUs or dual core or

00:11:32,029 --> 00:11:39,830
quad core we entered the era of many

00:11:35,630 --> 00:11:43,580
cores so this is the telluric Atom CPU

00:11:39,830 --> 00:11:47,360
it's not a GPU it's a CPU it has 72

00:11:43,580 --> 00:11:50,300
cores 72 Hardware core so you get 72

00:11:47,360 --> 00:11:51,920
Hardware threads this is great when you

00:11:50,300 --> 00:11:54,230
want to do things in real time or when

00:11:51,920 --> 00:11:58,029
you process things in parallel you know

00:11:54,230 --> 00:12:00,620
how you now have this power to do things

00:11:58,029 --> 00:12:03,410
at this kind of scale and this kind of

00:12:00,620 --> 00:12:06,290
really concurrent setting now don't and

00:12:03,410 --> 00:12:09,200
our phone so this phone has I think for

00:12:06,290 --> 00:12:12,740
course many phones that have eight cores

00:12:09,200 --> 00:12:14,930
my machine here has four cores and with

00:12:12,740 --> 00:12:16,240
hyper-threading they can virtually eight

00:12:14,930 --> 00:12:19,640
course and

00:12:16,240 --> 00:12:23,510
we have all this course what do we do

00:12:19,640 --> 00:12:27,230
with all of our course we have this

00:12:23,510 --> 00:12:29,300
which you do not see because it's but I

00:12:27,230 --> 00:12:29,870
will it's too bad that you cannot see it

00:12:29,300 --> 00:12:39,860
so I will

00:12:29,870 --> 00:12:44,750
I'll make this load anyway bye so this

00:12:39,860 --> 00:12:46,910
is what happens I have one guy in the

00:12:44,750 --> 00:12:49,900
middle and he's dancing and he's really

00:12:46,910 --> 00:12:52,430
like and everyone awkwardly around like

00:12:49,900 --> 00:12:55,040
nothing else happens on the other CPUs

00:12:52,430 --> 00:12:57,140
and that that's the sad reality of most

00:12:55,040 --> 00:12:59,990
software that we build especially on on

00:12:57,140 --> 00:13:02,510
phones and so on nobody uses really the

00:12:59,990 --> 00:13:07,250
power that's there because well it's not

00:13:02,510 --> 00:13:13,430
easy and but yeah this is a great one I

00:13:07,250 --> 00:13:14,900
could watch this all day so on the other

00:13:13,430 --> 00:13:17,300
hand we have this on one hand with this

00:13:14,900 --> 00:13:20,990
on the other hand we we know that in the

00:13:17,300 --> 00:13:23,390
future we will get the connection

00:13:20,990 --> 00:13:26,360
breakdown between machines will be even

00:13:23,390 --> 00:13:29,960
smaller like there is your opto

00:13:26,360 --> 00:13:31,730
electronic CPUs that so you get you get

00:13:29,960 --> 00:13:34,220
basically you get connections between

00:13:31,730 --> 00:13:36,650
machines and between the CPUs that are

00:13:34,220 --> 00:13:42,380
much faster okay that are much much

00:13:36,650 --> 00:13:44,420
faster and and so what it really will

00:13:42,380 --> 00:13:46,790
matter at some point the bottleneck will

00:13:44,420 --> 00:13:50,030
really be our ability to use the

00:13:46,790 --> 00:13:52,670
resources that we have that's on the end

00:13:50,030 --> 00:13:55,190
of them the CPU and when we talk about

00:13:52,670 --> 00:13:59,510
memory now there's a website called yes

00:13:55,190 --> 00:14:02,750
your data fits and run and you enter a

00:13:59,510 --> 00:14:05,090
number and you choose you know like here

00:14:02,750 --> 00:14:06,980
I selected terabytes and then the

00:14:05,090 --> 00:14:08,870
website says yes your data fits in RAM

00:14:06,980 --> 00:14:11,300
and if you click on yes you get a page

00:14:08,870 --> 00:14:14,210
of Dell which tells you a machine with

00:14:11,300 --> 00:14:17,630
six terabytes of RAM and your is I think

00:14:14,210 --> 00:14:20,840
here at Packard you can buy servers with

00:14:17,630 --> 00:14:23,740
six terabytes of main memory and then

00:14:20,840 --> 00:14:26,480
the whole big data game changes because

00:14:23,740 --> 00:14:28,880
that's why things like spark is are

00:14:26,480 --> 00:14:29,470
taking off because all the intermediates

00:14:28,880 --> 00:14:32,470
that

00:14:29,470 --> 00:14:34,810
that Hadoop is saving on disk that's it

00:14:32,470 --> 00:14:37,090
you don't want this anymore you have six

00:14:34,810 --> 00:14:39,160
terabytes of memory you just save

00:14:37,090 --> 00:14:41,350
everything in memory you just compute in

00:14:39,160 --> 00:14:42,010
memory and you only save it as the end

00:14:41,350 --> 00:14:43,660
result

00:14:42,010 --> 00:14:47,740
this is completely changing the game

00:14:43,660 --> 00:14:50,230
it's like so many big data problems and

00:14:47,740 --> 00:14:52,480
people are how we have we have hundreds

00:14:50,230 --> 00:14:54,160
of gigabytes well you know you can buy a

00:14:52,480 --> 00:14:55,900
machine with six terabytes of main

00:14:54,160 --> 00:14:57,790
memory and you can do all your

00:14:55,900 --> 00:15:00,280
computation memory it's much much faster

00:14:57,790 --> 00:15:03,130
than doing it on disk so that's also

00:15:00,280 --> 00:15:04,570
entirely changing the game what's also

00:15:03,130 --> 00:15:06,870
changing the game I don't know I think

00:15:04,570 --> 00:15:10,330
this is something many people missed

00:15:06,870 --> 00:15:12,820
last year that came out I remember I was

00:15:10,330 --> 00:15:17,350
sitting in a cafe in Zurich and Intel

00:15:12,820 --> 00:15:19,570
and what was it six point no micron

00:15:17,350 --> 00:15:21,520
technology they announced a new child of

00:15:19,570 --> 00:15:25,120
memory there hasn't been a new kind of

00:15:21,520 --> 00:15:27,190
memory after NAND in 89 is the first and

00:15:25,120 --> 00:15:30,060
there's a new type of memory all of the

00:15:27,190 --> 00:15:33,400
memory we have is an and NAND flash so

00:15:30,060 --> 00:15:37,300
missus tells up 2,000 times faster and

00:15:33,400 --> 00:15:39,910
up 2,000 times more durable than land

00:15:37,300 --> 00:15:42,850
and also it's much denser than convent

00:15:39,910 --> 00:15:45,850
that the memory that we have this is

00:15:42,850 --> 00:15:48,610
gonna be coming this is coming to a new

00:15:45,850 --> 00:15:50,830
line of Intel CPUs soon and this will

00:15:48,610 --> 00:15:53,050
you know cache lines things like this

00:15:50,830 --> 00:15:56,800
this will really affect the way that we

00:15:53,050 --> 00:15:59,350
will be able to use to use our computers

00:15:56,800 --> 00:16:02,590
this is really a game changer I know

00:15:59,350 --> 00:16:04,660
it's not I say this now it's not visible

00:16:02,590 --> 00:16:10,720
now right away but this is a game game

00:16:04,660 --> 00:16:13,540
changer so on the one hand we have

00:16:10,720 --> 00:16:15,850
hardware that's keeping on getting

00:16:13,540 --> 00:16:18,100
better and better Hardware tries so hard

00:16:15,850 --> 00:16:21,430
to make software fast software tries so

00:16:18,100 --> 00:16:24,730
hard to make Hardware slow so we have

00:16:21,430 --> 00:16:27,910
all these great things and our hardware

00:16:24,730 --> 00:16:31,630
but we really waste resources like there

00:16:27,910 --> 00:16:33,340
is no tomorrow and this is sad it's a I

00:16:31,630 --> 00:16:36,310
don't know but my impression is when I

00:16:33,340 --> 00:16:39,040
load a website these days it's slow it

00:16:36,310 --> 00:16:41,089
loads all these fonts it loads loads all

00:16:39,040 --> 00:16:44,659
these pop-up windows and these ads and

00:16:41,089 --> 00:16:45,799
and at the end of the day you you get an

00:16:44,659 --> 00:16:47,629
impression that things are getting

00:16:45,799 --> 00:16:50,959
slower and slower rather than faster

00:16:47,629 --> 00:16:53,599
which is completely insane anyhow in

00:16:50,959 --> 00:16:55,279
conclusion we're definitely moving

00:16:53,599 --> 00:16:56,899
towards many core and distributed

00:16:55,279 --> 00:16:59,119
systems there is no way back from there

00:16:56,899 --> 00:17:00,829
I don't think we can back after that and

00:16:59,119 --> 00:17:02,959
go back to single machine kind of

00:17:00,829 --> 00:17:04,959
deployments we have also hardware but

00:17:02,959 --> 00:17:08,209
the software is kind of like in behind

00:17:04,959 --> 00:17:10,399
so in my opinion what we need now is to

00:17:08,209 --> 00:17:13,689
developers is to have on one hand

00:17:10,399 --> 00:17:16,220
explicit asynchronous programming

00:17:13,689 --> 00:17:18,589
asynchronous programming and explicit

00:17:16,220 --> 00:17:20,809
failure handling if we want to do great

00:17:18,589 --> 00:17:22,970
software these are two building blocks

00:17:20,809 --> 00:17:26,539
that we need and so in the remaining

00:17:22,970 --> 00:17:30,200
time and let's build together as more

00:17:26,539 --> 00:17:32,360
reactive web application and our web

00:17:30,200 --> 00:17:35,779
application will look like this we'll

00:17:32,360 --> 00:17:38,990
have a view a controller they will talk

00:17:35,779 --> 00:17:43,220
by a WebSocket there will be an actor

00:17:38,990 --> 00:17:46,519
and we'll talk with the Twitter API and

00:17:43,220 --> 00:17:49,429
there will be message passing around

00:17:46,519 --> 00:17:54,409
here we'll use the concept of a future

00:17:49,429 --> 00:17:56,240
here and an actor down there all of this

00:17:54,409 --> 00:17:57,980
and oh yeah and and the thing called a

00:17:56,240 --> 00:18:01,460
circuit breaker towards the end which is

00:17:57,980 --> 00:18:03,619
a normal little tool this is all going

00:18:01,460 --> 00:18:11,509
to be built with the play framework akka

00:18:03,619 --> 00:18:14,869
and on scanner so let's get started let

00:18:11,509 --> 00:18:17,330
me show you just the start of our

00:18:14,869 --> 00:18:18,889
application or let me show you this this

00:18:17,330 --> 00:18:22,360
is the application it's the user

00:18:18,889 --> 00:18:22,360
interface I hope you can see it

00:18:22,480 --> 00:18:34,039
that's an input box and that's the send

00:18:26,720 --> 00:18:36,289
button okay yeah so um and what happens

00:18:34,039 --> 00:18:37,700
when you click when you enter a text and

00:18:36,289 --> 00:18:41,529
you click on the send button is that

00:18:37,700 --> 00:18:44,779
it's sending that via WebSocket to the

00:18:41,529 --> 00:18:46,249
server so on the server side we have

00:18:44,779 --> 00:18:48,619
first view that I just showed you

00:18:46,249 --> 00:18:52,879
there's the input box here there's the

00:18:48,619 --> 00:18:54,770
send button here and then there's a div

00:18:52,879 --> 00:18:57,410
in which I'm going to append whatever

00:18:54,770 --> 00:18:58,790
so I have a bit of JavaScript down here

00:18:57,410 --> 00:19:01,280
I set up a WebSocket

00:18:58,790 --> 00:19:04,460
when I receive a message I printed out

00:19:01,280 --> 00:19:06,830
in the console and I append it to this

00:19:04,460 --> 00:19:09,050
div as an HTML element nothing really

00:19:06,830 --> 00:19:13,040
exciting and when I click on the button

00:19:09,050 --> 00:19:17,060
I send the message over to the socket to

00:19:13,040 --> 00:19:19,280
the server in my controller

00:19:17,060 --> 00:19:24,110
I have nothing so let's do something

00:19:19,280 --> 00:19:26,030
about this so what I will first need in

00:19:24,110 --> 00:19:32,600
order to the set of a WebSocket

00:19:26,030 --> 00:19:39,530
connection is I need an actor and an

00:19:32,600 --> 00:19:42,710
actor is a small tool or an actor is let

00:19:39,530 --> 00:19:45,440
me show you what an actor is an actor is

00:19:42,710 --> 00:19:47,150
a very tiny object lightweight you can

00:19:45,440 --> 00:19:50,840
have millions of actors running in one

00:19:47,150 --> 00:19:52,850
single JVM that sends messages and

00:19:50,840 --> 00:19:54,560
receives messages so here we have an

00:19:52,850 --> 00:19:57,320
actor that sends a message to another

00:19:54,560 --> 00:19:59,390
actor each actor has a mailbox in which

00:19:57,320 --> 00:20:02,000
they receive their messages they receive

00:19:59,390 --> 00:20:05,260
them and process them in order so inside

00:20:02,000 --> 00:20:08,060
of an actor you get the illusion of of

00:20:05,260 --> 00:20:10,190
everything happening in order not

00:20:08,060 --> 00:20:12,230
concurrently but in a synchronous way

00:20:10,190 --> 00:20:14,390
you get an illusion inside of the actor

00:20:12,230 --> 00:20:16,580
you're in a safe world in which you

00:20:14,390 --> 00:20:19,190
think inside of an actor that everything

00:20:16,580 --> 00:20:21,050
happens in order when these actors

00:20:19,190 --> 00:20:23,330
interact outside of this world

00:20:21,050 --> 00:20:26,570
everything is concurrent but inside of

00:20:23,330 --> 00:20:28,730
the actor you get to work in a

00:20:26,570 --> 00:20:32,360
synchronous fashion which means that

00:20:28,730 --> 00:20:35,180
it's much simpler on on as frail humans

00:20:32,360 --> 00:20:37,520
to reason in terms of concurrency when

00:20:35,180 --> 00:20:39,530
we have this illusion there they're

00:20:37,520 --> 00:20:42,230
meant for long believed asynchronous

00:20:39,530 --> 00:20:44,840
computation actors

00:20:42,230 --> 00:20:49,370
acha actors have an address they all

00:20:44,840 --> 00:20:51,650
live in an actor system and use the

00:20:49,370 --> 00:20:55,930
address to basically send messages from

00:20:51,650 --> 00:21:02,450
one actor to another so here I'm I'm

00:20:55,930 --> 00:21:03,680
building an actor and I say when I have

00:21:02,450 --> 00:21:08,000
a message when I receive a message

00:21:03,680 --> 00:21:08,559
that's the reception part I 1/2 for the

00:21:08,000 --> 00:21:10,960
moment for

00:21:08,559 --> 00:21:14,769
first thing I want to reply to whomever

00:21:10,960 --> 00:21:17,440
sent me this and and act as a pawn kind

00:21:14,769 --> 00:21:21,899
of ping-pong kind of thing so I start I

00:21:17,440 --> 00:21:27,460
log out that I received a message here

00:21:21,899 --> 00:21:29,200
and then I will reply it and out is the

00:21:27,460 --> 00:21:32,169
out words channel a WebSocket is

00:21:29,200 --> 00:21:35,830
bi-directional thing and so out is the

00:21:32,169 --> 00:21:39,210
the path back to the to the browser okay

00:21:35,830 --> 00:21:41,619
so here when I want to reply I say out

00:21:39,210 --> 00:21:46,570
exclamation mark so this is actually

00:21:41,619 --> 00:21:49,259
tell so this method is tell or this used

00:21:46,570 --> 00:21:52,869
to be called bang so you say out bang

00:21:49,259 --> 00:21:54,460
message these days you call it tell so

00:21:52,869 --> 00:21:56,769
this is a fire-and-forget

00:21:54,460 --> 00:21:58,240
operation you send this off and you

00:21:56,769 --> 00:22:00,490
forget about it you don't care whether

00:21:58,240 --> 00:22:02,139
it you know it's being processed you

00:22:00,490 --> 00:22:08,769
just send it off and you forget about it

00:22:02,139 --> 00:22:12,249
and and I will just say I will make this

00:22:08,769 --> 00:22:17,470
a bit more explicit that this is being a

00:22:12,249 --> 00:22:21,220
pong here okay

00:22:17,470 --> 00:22:23,889
I made an actor here it's pretty simple

00:22:21,220 --> 00:22:27,369
pretty small I need to hook it up to the

00:22:23,889 --> 00:22:29,350
WebSocket so in the play framework there

00:22:27,369 --> 00:22:32,110
is a thing called a WebSocket handler I

00:22:29,350 --> 00:22:33,999
can say except with actor I need to tell

00:22:32,110 --> 00:22:36,730
it what comes in and what comes out what

00:22:33,999 --> 00:22:39,700
type do I receive I could have XML Jason

00:22:36,730 --> 00:22:41,740
what so not your own format I'm going to

00:22:39,700 --> 00:22:45,490
be lazy here and I'm going to receive

00:22:41,740 --> 00:22:47,529
strings and send strings out okay but

00:22:45,490 --> 00:22:50,320
you could go and have some JSON

00:22:47,529 --> 00:22:53,289
something more fancy here so in there I

00:22:50,320 --> 00:22:54,909
get now the request the HTTP request

00:22:53,289 --> 00:22:57,309
when you establish a WebSocket

00:22:54,909 --> 00:22:59,769
connection you first have an HTTP

00:22:57,309 --> 00:23:01,869
request and then you say upgrade and you

00:22:59,769 --> 00:23:03,999
get back a WebSocket Channel that's how

00:23:01,869 --> 00:23:06,879
it works and the platform work then sets

00:23:03,999 --> 00:23:09,850
up an actor that represents the

00:23:06,879 --> 00:23:13,059
connection from the server to the actor

00:23:09,850 --> 00:23:17,529
that's called out here and then I can I

00:23:13,059 --> 00:23:18,879
pass it in my my actor in order to pass

00:23:17,529 --> 00:23:20,860
it in my actor I need a sort of

00:23:18,879 --> 00:23:21,960
constructor for the actor which are

00:23:20,860 --> 00:23:24,359
called prop

00:23:21,960 --> 00:23:27,389
props are serialized it's a sort of a

00:23:24,359 --> 00:23:31,529
serializable constructor of the actor

00:23:27,389 --> 00:23:34,460
and there I go and I say WebSocket

00:23:31,529 --> 00:23:38,700
client Oh

00:23:34,460 --> 00:23:41,519
props class of web circuit line and I

00:23:38,700 --> 00:23:43,950
pass it in out and these are the props

00:23:41,519 --> 00:23:46,019
so sort of a serializable constructor

00:23:43,950 --> 00:23:50,249
and a year I just go WebSocket client

00:23:46,019 --> 00:23:52,369
props out the last thing I need to do or

00:23:50,249 --> 00:23:55,379
there's two more things I need to do

00:23:52,369 --> 00:23:58,320
place an MVC framework I have routes so

00:23:55,379 --> 00:24:00,629
I go in there and let's say at slash

00:23:58,320 --> 00:24:06,479
socket you will get your WebSocket and

00:24:00,629 --> 00:24:09,859
in here I use this notation and then I

00:24:06,479 --> 00:24:13,799
get my socket and one last thing before

00:24:09,859 --> 00:24:16,469
I'm ready to go in my view I also need

00:24:13,799 --> 00:24:18,479
to infer just say what address it is and

00:24:16,469 --> 00:24:22,399
there again this is all very types a so

00:24:18,479 --> 00:24:25,469
I go routes application sockets

00:24:22,399 --> 00:24:27,269
WebSocket URL and this generates the URL

00:24:25,469 --> 00:24:30,479
if anything changes in the routes file

00:24:27,269 --> 00:24:32,519
or in my methods in my controller it's

00:24:30,479 --> 00:24:35,159
all compiled so if I make a mistake this

00:24:32,519 --> 00:24:38,519
will know this the compiler will warn me

00:24:35,159 --> 00:24:42,929
about it let's see if this works

00:24:38,519 --> 00:24:45,479
it doesn't oh my god so this is IntelliJ

00:24:42,929 --> 00:24:51,029
that was not helping here this is not a

00:24:45,479 --> 00:24:55,169
unit this is a receive method so here I

00:24:51,029 --> 00:24:55,529
go let's see if that works it works ok

00:24:55,169 --> 00:25:00,299
great

00:24:55,529 --> 00:25:02,460
so we did the first step good and let's

00:25:00,299 --> 00:25:04,289
start and and do something more

00:25:02,460 --> 00:25:06,029
interesting which is connecting to

00:25:04,289 --> 00:25:10,649
Twitter if you want to connect to

00:25:06,029 --> 00:25:12,330
Twitter you need both credentials and I

00:25:10,649 --> 00:25:14,940
don't want you to watch me type in all

00:25:12,330 --> 00:25:20,399
sorts of earth credentials so what I did

00:25:14,940 --> 00:25:23,429
here I fast forwarded and now one more

00:25:20,399 --> 00:25:25,830
and here I get my credentials ok this is

00:25:23,429 --> 00:25:29,059
boring stuff this is a API keys sort of

00:25:25,830 --> 00:25:31,470
things we don't need to do this in life

00:25:29,059 --> 00:25:34,499
I'm going to change this here and now

00:25:31,470 --> 00:25:35,530
I'm going to make a call using the WS

00:25:34,499 --> 00:25:41,380
library of

00:25:35,530 --> 00:25:44,230
play to the to the Search API of Twitter

00:25:41,380 --> 00:25:46,480
and I'm going to say with query string

00:25:44,230 --> 00:25:50,250
and my query will be the message that I

00:25:46,480 --> 00:25:57,060
receive in the actor and I'm going to

00:25:50,250 --> 00:26:06,100
sign this thing with a key I with a Roth

00:25:57,060 --> 00:26:08,860
W a signature so it's a calculator which

00:26:06,100 --> 00:26:12,640
can has a key and a token keys and

00:26:08,860 --> 00:26:20,230
tokens I have down there so I just go in

00:26:12,640 --> 00:26:22,630
there and they say case key token I move

00:26:20,230 --> 00:26:27,550
all of this in here now I have my key

00:26:22,630 --> 00:26:31,750
and token and I I make a get request

00:26:27,550 --> 00:26:35,290
here okay so I'm just basically

00:26:31,750 --> 00:26:38,230
instructing this thing to pass in Q to

00:26:35,290 --> 00:26:45,040
this API and assign the request and this

00:26:38,230 --> 00:26:47,650
is a future this thing here it's a

00:26:45,040 --> 00:26:49,990
future of our ws response is I will

00:26:47,650 --> 00:26:56,860
eventually get this in the future not

00:26:49,990 --> 00:26:59,800
right now but in the future so it's not

00:26:56,860 --> 00:27:02,710
a calm son korver future it's incredible

00:26:59,800 --> 00:27:08,980
at core Brazil is in there and a future

00:27:02,710 --> 00:27:12,010
is is a kind of a box that once it's

00:27:08,980 --> 00:27:14,710
completed either contains a successful

00:27:12,010 --> 00:27:16,960
WS response in my case what I was

00:27:14,710 --> 00:27:19,300
expecting or it doesn't contain anything

00:27:16,960 --> 00:27:21,520
but it keeps it keeps hold on the

00:27:19,300 --> 00:27:23,380
exception that I have it keeps the

00:27:21,520 --> 00:27:26,410
failure doesn't throw it out okay it

00:27:23,380 --> 00:27:28,360
keeps it it's for short-lived

00:27:26,410 --> 00:27:29,920
asynchronous computation you you do this

00:27:28,360 --> 00:27:32,980
once and then it evaluates and you're

00:27:29,920 --> 00:27:35,200
done the only state it holds is whatever

00:27:32,980 --> 00:27:38,020
it completed to at the very end and

00:27:35,200 --> 00:27:40,660
futures can be composed together and

00:27:38,020 --> 00:27:44,020
we'll see how failure how we do fail

00:27:40,660 --> 00:27:46,660
you're handling with this and so what I

00:27:44,020 --> 00:27:49,580
will do here is I will just take

00:27:46,660 --> 00:27:54,389
whatever response I have

00:27:49,580 --> 00:27:57,509
and I will send that out yeah I will

00:27:54,389 --> 00:28:01,559
send the body out to my browser so if I

00:27:57,509 --> 00:28:04,859
do this now it will fail because I need

00:28:01,559 --> 00:28:06,809
next an execution context an execution

00:28:04,859 --> 00:28:09,090
context is the thing you run your future

00:28:06,809 --> 00:28:11,519
against it's a threat it's backed by a

00:28:09,090 --> 00:28:16,229
thread pool it's something that is going

00:28:11,519 --> 00:28:18,210
to run your future so if I if I'm in it

00:28:16,229 --> 00:28:20,039
side of an actor I already have one of

00:28:18,210 --> 00:28:21,989
these execution contexts available

00:28:20,039 --> 00:28:29,239
because also the actor needs something

00:28:21,989 --> 00:28:29,239
to keep it running and this is the

00:28:30,019 --> 00:28:37,129
implicit execution context each actor

00:28:34,889 --> 00:28:39,840
has a context and this one contains the

00:28:37,129 --> 00:28:42,419
dispatcher which is itself an execution

00:28:39,840 --> 00:28:45,299
context and then I can use that in order

00:28:42,419 --> 00:28:46,889
to run my future inside of my actor so

00:28:45,299 --> 00:28:53,190
let's see if that works so what do we

00:28:46,889 --> 00:28:57,659
search on Twitter Scalla days usually I

00:28:53,190 --> 00:28:58,799
get cats but it's counted days okay

00:28:57,659 --> 00:29:02,580
great

00:28:58,799 --> 00:29:05,460
yeah so we get a result but it's not

00:29:02,580 --> 00:29:12,359
very nice so let's make this a bit nicer

00:29:05,460 --> 00:29:16,080
so I will do this the fast way all I did

00:29:12,359 --> 00:29:18,149
here I'm not I'm kind of cheating to go

00:29:16,080 --> 00:29:21,059
faster what I did here is just I'm

00:29:18,149 --> 00:29:24,029
parsing the Jason and I extract the text

00:29:21,059 --> 00:29:32,580
of the status okay there's nothing very

00:29:24,029 --> 00:29:33,799
fancy but if I reload now here we go and

00:29:32,580 --> 00:29:40,249
we have our latest

00:29:33,799 --> 00:29:43,049
Scalla days tweets okay cool except that

00:29:40,249 --> 00:29:44,429
this is not reactive yet because we

00:29:43,049 --> 00:29:47,429
haven't handled any kind of failure

00:29:44,429 --> 00:29:49,229
let's suppose that Twitter goes down so

00:29:47,429 --> 00:29:52,529
I will just call them and ask them to it

00:29:49,229 --> 00:29:54,509
no and Twitter going down is something

00:29:52,529 --> 00:29:57,419
we can kind of simulate by simulating

00:29:54,509 --> 00:30:02,789
that the request takes a long time to

00:29:57,419 --> 00:30:05,669
proceed okay so here or rather we will

00:30:02,789 --> 00:30:09,509
set an unrealistic expectation as to how

00:30:05,669 --> 00:30:11,399
fast the request is supposed to proceed

00:30:09,509 --> 00:30:13,349
so I will say I'm expecting my request

00:30:11,399 --> 00:30:16,679
to take one millisecond to complete

00:30:13,349 --> 00:30:19,830
which is completely unrealistic and what

00:30:16,679 --> 00:30:25,999
happens then can anyone tell me what

00:30:19,830 --> 00:30:28,440
will happen now when I run this sorry I

00:30:25,999 --> 00:30:30,239
will have a failure in the future yes

00:30:28,440 --> 00:30:33,029
how will that many fast

00:30:30,239 --> 00:30:35,639
will I see how will I see that here or

00:30:33,029 --> 00:30:38,369
in the console or anything you see

00:30:35,639 --> 00:30:40,289
nothing yeah exactly so I can do this

00:30:38,369 --> 00:30:43,019
many times I can look in my console and

00:30:40,289 --> 00:30:45,929
I see absolutely nothing and that is

00:30:43,019 --> 00:30:47,879
because the future keeps the exception

00:30:45,929 --> 00:30:51,539
inside it doesn't blow up it keeps it

00:30:47,879 --> 00:30:55,019
and that is how when you work with

00:30:51,539 --> 00:30:57,839
futures you need to handle failures you

00:30:55,019 --> 00:30:59,729
have a recovery here I mean then you can

00:30:57,839 --> 00:31:02,220
match the kind of exception that you

00:30:59,729 --> 00:31:06,479
have I use non-fatal non-fatal is a

00:31:02,220 --> 00:31:08,220
utility that basically it says as long

00:31:06,479 --> 00:31:10,559
as it's not something like a virtual

00:31:08,220 --> 00:31:12,330
machine or or an out of memory error a

00:31:10,559 --> 00:31:15,029
stack of things you cannot possibly

00:31:12,330 --> 00:31:16,019
recover from then it will not catch them

00:31:15,029 --> 00:31:17,039
because these things it doesn't make

00:31:16,019 --> 00:31:21,539
sense to catch them because you're

00:31:17,039 --> 00:31:25,529
screwed anyway so we use we use this

00:31:21,539 --> 00:31:29,849
matcher here and then instead of then I

00:31:25,529 --> 00:31:36,179
will just tell the client oops something

00:31:29,849 --> 00:31:38,879
went wrong and I give him the reason and

00:31:36,179 --> 00:31:41,940
then the only thing I need to do is here

00:31:38,879 --> 00:31:43,409
since this is expecting now Jason this

00:31:41,940 --> 00:31:45,389
is not very nice I could give it back

00:31:43,409 --> 00:31:47,789
Jason but I'm lazy so I'm not giving

00:31:45,389 --> 00:32:00,570
back Jason I just catch this thing and

00:31:47,789 --> 00:32:03,379
then I say append message and then okay

00:32:00,570 --> 00:32:03,379
let's try this

00:32:06,059 --> 00:32:09,100
yep

00:32:07,270 --> 00:32:10,960
here we go we get our exception back

00:32:09,100 --> 00:32:13,210
that's great but it's not good enough

00:32:10,960 --> 00:32:15,250
because this is not how you should do

00:32:13,210 --> 00:32:18,549
failure handling of a future inside of

00:32:15,250 --> 00:32:21,490
an actor this is how you do an exception

00:32:18,549 --> 00:32:24,250
handling of or failure handling of a

00:32:21,490 --> 00:32:26,380
future when you are using a future

00:32:24,250 --> 00:32:28,090
standalone but if you're inside an actor

00:32:26,380 --> 00:32:30,220
there is something else much better that

00:32:28,090 --> 00:32:33,850
you can use and that is called the pipe

00:32:30,220 --> 00:32:36,400
pattern the pipe pattern is a bridge

00:32:33,850 --> 00:32:39,000
between futures and actors and what it

00:32:36,400 --> 00:32:41,169
does is that it kind of takes the

00:32:39,000 --> 00:32:43,390
completed the result of the completed

00:32:41,169 --> 00:32:45,190
future and sends it to another actor

00:32:43,390 --> 00:32:47,350
that's the idea between actors and

00:32:45,190 --> 00:32:52,210
actresses that you send things around

00:32:47,350 --> 00:32:54,450
from one actor to another and this is

00:32:52,210 --> 00:32:58,870
called a pipe so how do we use a pipe

00:32:54,450 --> 00:33:01,210
let's see that first I need when I send

00:32:58,870 --> 00:33:04,960
something from one method actor to

00:33:01,210 --> 00:33:11,280
another I need a protocol so I will

00:33:04,960 --> 00:33:18,100
devise a small protocol search results

00:33:11,280 --> 00:33:23,980
here with my text and and K is in the

00:33:18,100 --> 00:33:26,260
search failure with my yes and then

00:33:23,980 --> 00:33:32,370
instead of sending this out directly I

00:33:26,260 --> 00:33:35,890
just wrap it in my protocol result and

00:33:32,370 --> 00:33:39,100
when I recover I wrap this in the search

00:33:35,890 --> 00:33:43,419
failure so I wrap this in my message my

00:33:39,100 --> 00:33:50,950
message protocol and then I use the pack

00:33:43,419 --> 00:33:54,130
pattern and this result here

00:33:50,950 --> 00:33:56,409
I say pipe to the actor I want to send

00:33:54,130 --> 00:33:58,270
this to and the actor I want to send

00:33:56,409 --> 00:34:00,370
this to I'm not going to create another

00:33:58,270 --> 00:34:02,380
actor here I'm just going to send this

00:34:00,370 --> 00:34:04,480
to myself because I'm going to do the

00:34:02,380 --> 00:34:05,860
error handling here and I real other

00:34:04,480 --> 00:34:07,750
scenario you would send this maybe to

00:34:05,860 --> 00:34:11,710
someone else now I just want to send it

00:34:07,750 --> 00:34:14,320
to myself so how do I do this well I

00:34:11,710 --> 00:34:16,450
match this message so I say okay search

00:34:14,320 --> 00:34:19,119
results

00:34:16,450 --> 00:34:29,139
with my result I am sending this out to

00:34:19,119 --> 00:34:33,639
the client and case search failure case

00:34:29,139 --> 00:34:35,740
search failure I'm sending this same

00:34:33,639 --> 00:34:40,379
thing out so in principle we should get

00:34:35,740 --> 00:34:40,379
the same results here the same returned

00:34:41,099 --> 00:34:50,220
scarlet ace yeah this is still failing

00:34:47,220 --> 00:34:50,220
yeah

00:34:59,060 --> 00:35:09,150
why I'm using the pipe pattern okay it's

00:35:05,970 --> 00:35:11,970
it's it's producing the same result but

00:35:09,150 --> 00:35:14,850
it's the philosophy of the actor model

00:35:11,970 --> 00:35:16,860
is to work with messages so here in this

00:35:14,850 --> 00:35:19,710
very simple result yes I'm completely

00:35:16,860 --> 00:35:21,660
with you this is not really this is not

00:35:19,710 --> 00:35:22,680
you don't see the value here because

00:35:21,660 --> 00:35:25,500
maybe it's too soon

00:35:22,680 --> 00:35:27,090
that's something you wouldn't see but if

00:35:25,500 --> 00:35:28,620
you work with the actor model you really

00:35:27,090 --> 00:35:32,750
want to build actors in such a way that

00:35:28,620 --> 00:35:35,430
what all they do is receive messages and

00:35:32,750 --> 00:35:39,570
you you don't want to have another kind

00:35:35,430 --> 00:35:42,450
of model of doing the failure handling

00:35:39,570 --> 00:35:44,610
then model that you have in your a new

00:35:42,450 --> 00:35:49,380
message does that make any sense does

00:35:44,610 --> 00:35:54,630
that answer your question or yeah it's

00:35:49,380 --> 00:35:55,980
an it's something that you start to see

00:35:54,630 --> 00:36:00,360
the value when you have a larger actor

00:35:55,980 --> 00:36:03,290
system and you have you do want to for

00:36:00,360 --> 00:36:05,700
example centralized error handling and

00:36:03,290 --> 00:36:08,790
move error handling for example to one

00:36:05,700 --> 00:36:10,950
actor that sort of keeps track of all

00:36:08,790 --> 00:36:12,840
the errors and and does are handling all

00:36:10,950 --> 00:36:14,700
you propagate this to the supervisor of

00:36:12,840 --> 00:36:17,580
the actor or something like this so when

00:36:14,700 --> 00:36:20,850
you when you do the future recovery

00:36:17,580 --> 00:36:23,040
inside of the actor directly with the

00:36:20,850 --> 00:36:25,980
future with the recover method you kind

00:36:23,040 --> 00:36:29,880
of lose this ability its to use always

00:36:25,980 --> 00:36:32,700
this kind of channel use the messages as

00:36:29,880 --> 00:36:36,510
a message passing as as a means for

00:36:32,700 --> 00:36:39,780
failure handling as well it's more of a

00:36:36,510 --> 00:36:41,520
yeah of the design idea of behind the

00:36:39,780 --> 00:36:46,920
actor model that you everything is a

00:36:41,520 --> 00:36:48,390
message okay and we can talk more about

00:36:46,920 --> 00:36:50,580
it later I can show you some more

00:36:48,390 --> 00:36:57,300
concrete examples of of how it actually

00:36:50,580 --> 00:37:00,810
looks in that yep so let's just check if

00:36:57,300 --> 00:37:04,620
it still works yeah I still get my

00:37:00,810 --> 00:37:07,070
results here okay cool so this was the

00:37:04,620 --> 00:37:07,070
pipe pattern

00:37:08,360 --> 00:37:13,880
we still have some time and let's talk

00:37:11,990 --> 00:37:16,520
about something which is circuit breaker

00:37:13,880 --> 00:37:18,920
we all have circuit breakers in our

00:37:16,520 --> 00:37:22,210
homes I mean at least I do when you use

00:37:18,920 --> 00:37:26,720
electricity you have circuit breakers

00:37:22,210 --> 00:37:28,850
these things are what you hear when you

00:37:26,720 --> 00:37:32,840
plug in your dishwasher you vacuum

00:37:28,850 --> 00:37:34,370
cleaner in your electric oven and the

00:37:32,840 --> 00:37:37,060
hairdryer on your toaster at the same

00:37:34,370 --> 00:37:42,920
time and then the circuit breaker trips

00:37:37,060 --> 00:37:44,750
so this is the same idea here there are

00:37:42,920 --> 00:37:47,200
three states the closed state where

00:37:44,750 --> 00:37:50,540
everything works well the open state

00:37:47,200 --> 00:37:52,040
where it just dripped and then after it

00:37:50,540 --> 00:37:53,720
trips the circuit breaker will attempt

00:37:52,040 --> 00:37:55,400
to reset itself it's going to be in

00:37:53,720 --> 00:37:58,070
health open State it's kind of unsure

00:37:55,400 --> 00:38:00,950
yet if things are okay and then after a

00:37:58,070 --> 00:38:03,710
while if requests come back in and and

00:38:00,950 --> 00:38:05,570
do not fail then it will close itself

00:38:03,710 --> 00:38:10,940
completely and it will everything will

00:38:05,570 --> 00:38:12,830
be fine again this thing is tremendously

00:38:10,940 --> 00:38:15,590
interesting when you have a legacy

00:38:12,830 --> 00:38:20,660
back-end system that you expose on the

00:38:15,590 --> 00:38:23,780
web or our tool another place where it

00:38:20,660 --> 00:38:27,020
there is a much higher set of much

00:38:23,780 --> 00:38:28,790
higher of pace let's say because you do

00:38:27,020 --> 00:38:30,350
not want to overload your back-end

00:38:28,790 --> 00:38:32,360
system because otherwise you end up with

00:38:30,350 --> 00:38:35,060
cascading failures everything sort of is

00:38:32,360 --> 00:38:37,460
over whelmed and so this thing will trip

00:38:35,060 --> 00:38:39,530
and effectively protect your your

00:38:37,460 --> 00:38:42,260
back-end system from being overwhelmed

00:38:39,530 --> 00:38:44,300
now in our example the back-end system

00:38:42,260 --> 00:38:48,410
is Twitter so it's going to be hard to

00:38:44,300 --> 00:38:50,780
overwhelm it but just in order to show

00:38:48,410 --> 00:38:53,450
you that we can use circuit breakers I

00:38:50,780 --> 00:38:58,340
will show you how I would use this here

00:38:53,450 --> 00:39:03,050
so I will create a breaker which a cold

00:38:58,340 --> 00:39:05,900
circuit circuit breaker and a breaker

00:39:03,050 --> 00:39:07,490
needs a scheduler as scheduled tells it

00:39:05,900 --> 00:39:11,630
how to use the time so I can use just

00:39:07,490 --> 00:39:13,460
the one that the system gives us the

00:39:11,630 --> 00:39:20,960
maximum failures before a trip I will

00:39:13,460 --> 00:39:21,900
say to call time out before I also say

00:39:20,960 --> 00:39:23,460
that disk

00:39:21,900 --> 00:39:26,730
doesn't work anymore I will use five

00:39:23,460 --> 00:39:29,040
seconds and the reset time out before I

00:39:26,730 --> 00:39:32,580
have confidence enough to reset myself I

00:39:29,040 --> 00:39:35,340
will also use five seconds and here I

00:39:32,580 --> 00:39:37,410
just need to teach this about the

00:39:35,340 --> 00:39:40,670
concept of a duration here we go

00:39:37,410 --> 00:39:44,460
so the breaker is something that I will

00:39:40,670 --> 00:39:49,680
put between my coal myself here and my

00:39:44,460 --> 00:39:52,050
coal to Twitter okay so in here I will

00:39:49,680 --> 00:39:53,700
not do the failure handling anymore

00:39:52,050 --> 00:39:55,470
because that's what I want my breaker to

00:39:53,700 --> 00:39:57,630
do it's when something it's not

00:39:55,470 --> 00:40:00,240
happening as according to plan I want my

00:39:57,630 --> 00:40:03,990
breaker to take care of this and then

00:40:00,240 --> 00:40:10,470
what I say okay and what I say here is I

00:40:03,990 --> 00:40:19,260
have my mapped result and then I use the

00:40:10,470 --> 00:40:27,570
breaker to invoke this and the result I

00:40:19,260 --> 00:40:28,500
pipe to myself okay let's reload this oh

00:40:27,570 --> 00:40:31,560
okay

00:40:28,500 --> 00:40:33,900
what I also want to do sorry about that

00:40:31,560 --> 00:40:36,180
is I want to actually show that

00:40:33,900 --> 00:40:38,280
something is going on so when when I

00:40:36,180 --> 00:40:39,710
trip I will print that out I will say

00:40:38,280 --> 00:40:45,440
logger dot error

00:40:39,710 --> 00:40:57,030
breaker open when I say on health open I

00:40:45,440 --> 00:41:03,060
say warning breaker health open hang in

00:40:57,030 --> 00:41:12,060
there and when I am closed again I am

00:41:03,060 --> 00:41:15,080
going to also say breaker closed so this

00:41:12,060 --> 00:41:18,330
will give us a sense of of this breaker

00:41:15,080 --> 00:41:20,820
happening or doing its job so I said I'm

00:41:18,330 --> 00:41:23,070
not going to overwhelm Twitter here is

00:41:20,820 --> 00:41:26,070
not something I can I can try you know I

00:41:23,070 --> 00:41:27,240
can go in here and click really fast but

00:41:26,070 --> 00:41:29,340
that will not work

00:41:27,240 --> 00:41:31,800
I'm not going to overwhelm them so

00:41:29,340 --> 00:41:34,320
instead what I will do is again I will

00:41:31,800 --> 00:41:35,160
use my trick from before I will set an

00:41:34,320 --> 00:41:40,079
unrealistic

00:41:35,160 --> 00:41:40,079
request timeout so this future will fail

00:41:41,039 --> 00:41:50,920
okay so now if I do this a few times

00:41:47,859 --> 00:41:54,249
more than two and they look at my logs

00:41:50,920 --> 00:41:56,349
you see the breaker is open then after

00:41:54,249 --> 00:41:58,900
some time it attempts to reset itself so

00:41:56,349 --> 00:42:01,799
it goes in health open State but if I

00:41:58,900 --> 00:42:04,119
continue now since all I get back are

00:42:01,799 --> 00:42:05,049
exceptions because all I do is failing

00:42:04,119 --> 00:42:08,349
all the time

00:42:05,049 --> 00:42:10,720
I will never be able to close myself so

00:42:08,349 --> 00:42:12,279
how do we how do I prove to you that I'm

00:42:10,720 --> 00:42:17,910
not just making things up and this

00:42:12,279 --> 00:42:17,910
really works well I'm going to yeah oh

00:42:21,660 --> 00:42:24,549
okay

00:42:22,839 --> 00:42:26,200
which code doesn't run this is not being

00:42:24,549 --> 00:42:29,470
rerun this is not being re-evaluated

00:42:26,200 --> 00:42:32,140
okay sorry about that so you get a

00:42:29,470 --> 00:42:34,269
message in here okay you get a message

00:42:32,140 --> 00:42:38,650
in here every time I click I get a new

00:42:34,269 --> 00:42:43,029
message and then this thing is being or

00:42:38,650 --> 00:42:44,559
should I say this thing okay now now it

00:42:43,029 --> 00:42:46,359
makes sense so now I made this a

00:42:44,559 --> 00:42:51,130
definition and not the value sorry about

00:42:46,359 --> 00:42:55,059
that so this is gonna be again this is

00:42:51,130 --> 00:42:57,339
going to be evaluated here and then yeah

00:42:55,059 --> 00:42:58,900
you okay yes sorry I forgot to change

00:42:57,339 --> 00:43:00,940
the valve in depth if I keep it eval

00:42:58,900 --> 00:43:03,660
it's gonna be running anyway so I lost

00:43:00,940 --> 00:43:07,239
anyway but from one thing to another

00:43:03,660 --> 00:43:11,529
okay so what I'm going to do here is I'm

00:43:07,239 --> 00:43:15,549
just going to say a bar timeout I put

00:43:11,529 --> 00:43:19,690
this on one or that's a bit too high in

00:43:15,549 --> 00:43:22,059
here okay let's put it in here so I

00:43:19,690 --> 00:43:24,489
start with what no that actually sorry

00:43:22,059 --> 00:43:26,499
about that I started with the

00:43:24,489 --> 00:43:29,619
unrealistic expectation that true the

00:43:26,499 --> 00:43:32,170
will answer in one millisecond and if

00:43:29,619 --> 00:43:36,480
I'm half open I will set that to

00:43:32,170 --> 00:43:39,099
something more realistic like one second

00:43:36,480 --> 00:43:41,319
and I'm going to use this year so that

00:43:39,099 --> 00:43:43,690
after we have have been in half open

00:43:41,319 --> 00:43:44,950
state once we will reset will change the

00:43:43,690 --> 00:43:47,259
timeout and then things should work

00:43:44,950 --> 00:43:49,420
again so let's do if that let's see if

00:43:47,259 --> 00:43:55,190
that works

00:43:49,420 --> 00:43:57,920
Scala days okay once twice and we trip

00:43:55,190 --> 00:43:59,809
now we need more traffic coming in in

00:43:57,920 --> 00:44:02,420
order for the breaker to attend to its

00:43:59,809 --> 00:44:03,710
reset itself and after a while we see

00:44:02,420 --> 00:44:07,160
that the breakers closed and we get

00:44:03,710 --> 00:44:09,079
messages back so this is a tool that you

00:44:07,160 --> 00:44:10,970
can use in order to protect your legacy

00:44:09,079 --> 00:44:15,140
systems and avoid cascading failure

00:44:10,970 --> 00:44:18,549
zones pretty pretty neat we have 10 more

00:44:15,140 --> 00:44:24,019
minutes left so let's talk a bit about

00:44:18,549 --> 00:44:26,749
any more questions on this or do we move

00:44:24,019 --> 00:44:28,640
too fast or not or maybe there is time

00:44:26,749 --> 00:44:33,200
for questions in the end anyway so let's

00:44:28,640 --> 00:44:35,529
talk just a bit about deployment so how

00:44:33,200 --> 00:44:38,269
do you deploy a reactive web application

00:44:35,529 --> 00:44:39,799
well if you deploy it only on one host

00:44:38,269 --> 00:44:42,349
you kind of lost because that's not the

00:44:39,799 --> 00:44:44,960
idea right if your host is it's down if

00:44:42,349 --> 00:44:47,150
your machine burns then then you're not

00:44:44,960 --> 00:44:49,099
reactive so what you want is deploying

00:44:47,150 --> 00:44:51,859
several machines you want this to be

00:44:49,099 --> 00:44:54,380
elastic and doing this on your own is

00:44:51,859 --> 00:44:56,029
hard if you do this on your own good I

00:44:54,380 --> 00:44:59,769
mean this is hard their whole companies

00:44:56,029 --> 00:45:02,089
that do only this this kind of ops and

00:44:59,769 --> 00:45:04,279
building LSE ups is hard so what I

00:45:02,089 --> 00:45:06,980
always say is use a managed service or

00:45:04,279 --> 00:45:09,710
even a solution that that does this for

00:45:06,980 --> 00:45:13,190
example light band has this thing called

00:45:09,710 --> 00:45:15,710
the conductor that lets that sets up a

00:45:13,190 --> 00:45:17,930
cluster and the great thing about the

00:45:15,710 --> 00:45:20,089
light button so you can run a play acha

00:45:17,930 --> 00:45:21,799
but also other kind of applications you

00:45:20,089 --> 00:45:23,299
can run docker on this so you can run

00:45:21,799 --> 00:45:25,039
any kind of applications or legacy

00:45:23,299 --> 00:45:26,930
application that you have it will send

00:45:25,039 --> 00:45:29,269
it up in a clustered environment and the

00:45:26,930 --> 00:45:31,130
great thing about this is that it has

00:45:29,269 --> 00:45:33,289
automatic network partition resolution

00:45:31,130 --> 00:45:34,759
if your cluster is cut off because one

00:45:33,289 --> 00:45:36,559
data center is cut off from the other

00:45:34,759 --> 00:45:40,009
one or something bad happens on a

00:45:36,559 --> 00:45:42,499
network it is able to sort of detect

00:45:40,009 --> 00:45:46,160
which partition is in minority which we

00:45:42,499 --> 00:45:48,109
should turn itself off because a cluster

00:45:46,160 --> 00:45:51,349
node will otherwise keep on humming

00:45:48,109 --> 00:45:54,410
along and when when the network is back

00:45:51,349 --> 00:45:55,880
again and these faulty nodes are up

00:45:54,410 --> 00:45:58,099
they're going to be able to sync and you

00:45:55,880 --> 00:45:59,299
will have havoc between your run between

00:45:58,099 --> 00:46:00,800
your cluster nodes so you don't want

00:45:59,299 --> 00:46:02,720
this and this does this

00:46:00,800 --> 00:46:05,119
network partition resolution

00:46:02,720 --> 00:46:09,000
automatically is pretty great

00:46:05,119 --> 00:46:13,880
then deployment wise a managed service

00:46:09,000 --> 00:46:17,130
that I use quite a bit is clever cloud

00:46:13,880 --> 00:46:19,920
because what they have is automatic

00:46:17,130 --> 00:46:22,500
scalability horizontally and and

00:46:19,920 --> 00:46:24,540
vertically I do because horeb Heroku

00:46:22,500 --> 00:46:24,990
doesn't have this at least not that I

00:46:24,540 --> 00:46:27,930
know of

00:46:24,990 --> 00:46:29,190
I didn't check yesterday but the lesson

00:46:27,930 --> 00:46:30,450
that they I know they don't have this so

00:46:29,190 --> 00:46:33,030
what does it mean is that you have two

00:46:30,450 --> 00:46:34,740
sliders here the horizontal scaling how

00:46:33,030 --> 00:46:36,690
many nodes you want and what kind of

00:46:34,740 --> 00:46:40,319
vertical scaling you want in terms of

00:46:36,690 --> 00:46:43,560
instance sizes and when you have this

00:46:40,319 --> 00:46:45,930
enabled the algorithm that clever cloud

00:46:43,560 --> 00:46:47,609
users will try to optimize the price so

00:46:45,930 --> 00:46:50,819
that you pay the less the least amount

00:46:47,609 --> 00:46:52,920
money as possible in terms of when more

00:46:50,819 --> 00:46:54,780
load comes in it brings up e either more

00:46:52,920 --> 00:46:59,069
nodes or it scales up the different

00:46:54,780 --> 00:47:01,980
nodes so that the pricing is optimum and

00:46:59,069 --> 00:47:05,250
then lately lastly the last thing I want

00:47:01,980 --> 00:47:09,089
to talk about this load testing this

00:47:05,250 --> 00:47:11,970
node is on top of real Hardware so it's

00:47:09,089 --> 00:47:13,470
not Amazon this is this is really you

00:47:11,970 --> 00:47:17,069
know why you I mean this is a pretty

00:47:13,470 --> 00:47:20,310
solid stuff and they make awesome

00:47:17,069 --> 00:47:22,349
t-shirts and stickers they're not here

00:47:20,310 --> 00:47:26,430
today I thought I don't think but did

00:47:22,349 --> 00:47:31,910
they have awesome t-shirts so that's why

00:47:26,430 --> 00:47:31,910
you should use it so load testing

00:47:32,150 --> 00:47:36,510
because how do you test I mean you can

00:47:34,530 --> 00:47:38,010
do the usual kind of unit testing and

00:47:36,510 --> 00:47:39,720
integration testing but what is really

00:47:38,010 --> 00:47:41,700
interesting when you have a reactive web

00:47:39,720 --> 00:47:43,880
application is or a reactive application

00:47:41,700 --> 00:47:46,740
is how do you load test it and for this

00:47:43,880 --> 00:47:48,660
we there is this rule called Gatling

00:47:46,740 --> 00:47:52,230
that's built on top of Scala I can't and

00:47:48,660 --> 00:47:56,790
Metis and it fires at your application

00:47:52,230 --> 00:47:59,700
so what you do is you record a real user

00:47:56,790 --> 00:48:02,030
scenario and most testing or load

00:47:59,700 --> 00:48:05,550
testing tools like if you use a be

00:48:02,030 --> 00:48:07,170
Apache benchmark then you only throw

00:48:05,550 --> 00:48:09,960
requests at it it's not very realistic

00:48:07,170 --> 00:48:12,210
users they behave in different ways so

00:48:09,960 --> 00:48:14,520
here you set up Gatling which acts as a

00:48:12,210 --> 00:48:17,250
proxy you configure it as a prop

00:48:14,520 --> 00:48:20,490
see on your web server and then you can

00:48:17,250 --> 00:48:22,170
go in the server in your web browser and

00:48:20,490 --> 00:48:24,180
then you can go on your application

00:48:22,170 --> 00:48:26,550
click around and simulate a user doing

00:48:24,180 --> 00:48:28,230
something filling in forms clicking on

00:48:26,550 --> 00:48:30,450
buttons what's or not browsing pages

00:48:28,230 --> 00:48:32,520
reloading pages and all of this is being

00:48:30,450 --> 00:48:34,940
recorded at the end what you get is a

00:48:32,520 --> 00:48:37,620
large file with all the what user does

00:48:34,940 --> 00:48:40,290
and you can use that in order to

00:48:37,620 --> 00:48:43,080
simulate these users coming in so you

00:48:40,290 --> 00:48:45,810
say I do nothing for 4 seconds then I

00:48:43,080 --> 00:48:48,420
ramp up 200 users over the time of 10

00:48:45,810 --> 00:48:50,430
seconds then I add 10 users at once a

00:48:48,420 --> 00:48:52,170
you have many different ways in which

00:48:50,430 --> 00:48:55,080
you can simulate and add more users to

00:48:52,170 --> 00:48:56,910
this you can be really creative you can

00:48:55,080 --> 00:48:58,950
record different kind of scenarios and

00:48:56,910 --> 00:49:01,310
you can really try to simulate real

00:48:58,950 --> 00:49:03,960
users using your application and then

00:49:01,310 --> 00:49:07,290
launching them towards your application

00:49:03,960 --> 00:49:09,090
what you get after running the whole

00:49:07,290 --> 00:49:11,400
thing on your application is nice graphs

00:49:09,090 --> 00:49:13,680
showing that this application completely

00:49:11,400 --> 00:49:15,480
failed here and all the requests are

00:49:13,680 --> 00:49:17,930
failing I mean most of them are failing

00:49:15,480 --> 00:49:20,430
this is really not what you want you get

00:49:17,930 --> 00:49:22,680
no response time distribution graphs

00:49:20,430 --> 00:49:25,890
which is really useful it's a bit better

00:49:22,680 --> 00:49:28,380
here actually because you have only a

00:49:25,890 --> 00:49:32,670
very small percentage that's that's not

00:49:28,380 --> 00:49:33,360
too slow and it's like at around 1

00:49:32,670 --> 00:49:35,160
second here

00:49:33,360 --> 00:49:37,890
that's so much this is this is not the

00:49:35,160 --> 00:49:42,000
graph for this one is much better and so

00:49:37,890 --> 00:49:44,540
what you have really is you get a good

00:49:42,000 --> 00:49:46,890
notion of how your application is doing

00:49:44,540 --> 00:49:48,390
now the only thing with gatling is that

00:49:46,890 --> 00:49:50,820
you can only launch it from one machine

00:49:48,390 --> 00:49:54,000
you can only run it on one machine you

00:49:50,820 --> 00:49:56,340
can take an Amazon x6 excel instance and

00:49:54,000 --> 00:49:57,870
throw that against your application but

00:49:56,340 --> 00:50:01,020
what's also interesting is what happens

00:49:57,870 --> 00:50:02,520
when you have many real machines talking

00:50:01,020 --> 00:50:04,230
to you and so the next thing that I'm

00:50:02,520 --> 00:50:07,260
going to tell you is something that is

00:50:04,230 --> 00:50:09,780
only for educational purposes so because

00:50:07,260 --> 00:50:13,590
this is working with bees with machine

00:50:09,780 --> 00:50:15,240
guns and in effect what I'm going to

00:50:13,590 --> 00:50:19,550
tell you is how to run a distributed

00:50:15,240 --> 00:50:22,800
denial of service attack on on a site so

00:50:19,550 --> 00:50:25,550
this is a Python script that you can use

00:50:22,800 --> 00:50:27,410
you hand it over you your Amazon ec2

00:50:25,550 --> 00:50:28,760
credentials so you trust

00:50:27,410 --> 00:50:32,380
whole thing to do the right thing and

00:50:28,760 --> 00:50:34,819
then use you start up a swarm of bees

00:50:32,380 --> 00:50:37,940
yeah these are the credentials is how

00:50:34,819 --> 00:50:39,799
you configure the credentials and don't

00:50:37,940 --> 00:50:41,900
forget if you ever want to do this to

00:50:39,799 --> 00:50:45,109
set the debug flag - - so that you don't

00:50:41,900 --> 00:50:48,770
get a notion of what's going on and use

00:50:45,109 --> 00:50:51,890
you set up a swarm of bees and then you

00:50:48,770 --> 00:50:54,079
say I attack this target and it said you

00:50:51,890 --> 00:50:56,690
know it starts 400 ms on ec2 micro

00:50:54,079 --> 00:51:00,170
instances and launches them with a be

00:50:56,690 --> 00:51:04,099
against your your your page where

00:51:00,170 --> 00:51:07,220
whatever you told it to attack if you do

00:51:04,099 --> 00:51:09,890
this and I talk because I done this and

00:51:07,220 --> 00:51:11,839
by experience is that do not show you

00:51:09,890 --> 00:51:14,500
what you do after the attack you say

00:51:11,839 --> 00:51:17,869
bees down so you call off your swarm

00:51:14,500 --> 00:51:22,460
okay but don't forget to log in to

00:51:17,869 --> 00:51:24,920
Amazon and delete the instances because

00:51:22,460 --> 00:51:29,799
an instance that's not running still

00:51:24,920 --> 00:51:32,390
costs something so I had a nice bill and

00:51:29,799 --> 00:51:34,190
not running but the hard drive so this

00:51:32,390 --> 00:51:36,140
is something don't forget to do this if

00:51:34,190 --> 00:51:38,779
you use this don't forget to delete the

00:51:36,140 --> 00:51:40,940
instances afterwards and so this is a

00:51:38,779 --> 00:51:45,619
tool that you can use as well and I

00:51:40,940 --> 00:51:47,950
think we're true okay well thank you

00:51:45,619 --> 00:51:47,950

YouTube URL: https://www.youtube.com/watch?v=xZraNGzAX48


