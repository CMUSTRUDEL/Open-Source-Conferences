Title: Scylla, Charybdis, and the mystery of Quill by Flavio Brasil
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
Quill (http://getquill.io/) is a compile-time language integrated query library with a powerful query compilation mechanism based on the paper "A Practical Theory of Language-Integrated Query" (http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf).

This talk will give an overview of the "Scylla and Charybdis" theorem that supports the query compilation, present the Quoted Domain Specific Language (QDSL) (http://homepages.inf.ed.ac.uk/wadler/papers/qdsl/qdsl.pdf) approach used by the API, and give a quick view of Quill's functionality.
Captions: 
	00:00:03,760 --> 00:00:09,820
okay so let's get started thank you for

00:00:07,540 --> 00:00:11,980
attaining my talk today my name is flora

00:00:09,820 --> 00:00:15,490
Brazil and this is a talk cielo Carrie

00:00:11,980 --> 00:00:17,080
please and the Ministry of coil so it's

00:00:15,490 --> 00:00:19,480
a talk about language interpreted

00:00:17,080 --> 00:00:21,670
queries I'll be talking about Earth here

00:00:19,480 --> 00:00:25,600
n that is a theorem of Scylla and

00:00:21,670 --> 00:00:28,060
Charybdis and also about a library that

00:00:25,600 --> 00:00:32,259
I've been working on based on this

00:00:28,060 --> 00:00:33,940
theorem called wheel ok so Who am I I

00:00:32,259 --> 00:00:37,929
work as a software engineer and Twitter

00:00:33,940 --> 00:00:40,179
I work on the core services team I work

00:00:37,929 --> 00:00:43,089
more specifically with the tweets Marco

00:00:40,179 --> 00:00:45,729
service I've doing we've I've been doing

00:00:43,089 --> 00:00:49,210
scala since 2011 and i really love

00:00:45,729 --> 00:00:52,210
open-source work so since 2011 I've been

00:00:49,210 --> 00:00:54,190
publishing new projects so there is cool

00:00:52,210 --> 00:00:56,019
that I will be talking about today it's

00:00:54,190 --> 00:00:59,079
a compile-time language interpreted

00:00:56,019 --> 00:01:01,600
query library for a scholar the idea is

00:00:59,079 --> 00:01:03,909
being able to express queries using the

00:01:01,600 --> 00:01:06,369
host language for in our case scala so

00:01:03,909 --> 00:01:08,890
using scholars type system and syntax

00:01:06,369 --> 00:01:10,990
and then execute these queries against a

00:01:08,890 --> 00:01:13,480
target language for instance sequel

00:01:10,990 --> 00:01:14,710
queries I also works on club that is a

00:01:13,480 --> 00:01:16,780
free monitor for service composition

00:01:14,710 --> 00:01:19,330
when you have to call multiple services

00:01:16,780 --> 00:01:22,330
it's a good tool to optimize batching of

00:01:19,330 --> 00:01:24,540
calls and I also worked on a solution

00:01:22,330 --> 00:01:27,610
that is more or less the same space as

00:01:24,540 --> 00:01:30,550
oil that is a persistent solution called

00:01:27,610 --> 00:01:33,100
activate it's a distributed durable

00:01:30,550 --> 00:01:36,810
software transactional memory sounds

00:01:33,100 --> 00:01:39,220
very scary right so basically the idea

00:01:36,810 --> 00:01:41,230
you can think of it as a better way of

00:01:39,220 --> 00:01:44,440
building an object-relational mapping

00:01:41,230 --> 00:01:46,270
and I also worked on other type small

00:01:44,440 --> 00:01:49,030
libraries like bones to the type level

00:01:46,270 --> 00:01:51,909
validation ends it to define rest

00:01:49,030 --> 00:01:56,710
interfaces that are strong contracts

00:01:51,909 --> 00:02:00,040
between clients and servers so enough of

00:01:56,710 --> 00:02:02,650
my projects let's talk about the main

00:02:00,040 --> 00:02:05,920
topic of my talk today I would like to

00:02:02,650 --> 00:02:08,500
open with a quote from Dykstra so thanks

00:02:05,920 --> 00:02:11,409
press said simplicity is a great future

00:02:08,500 --> 00:02:14,739
but it requires hard work to achieve it

00:02:11,409 --> 00:02:17,430
and education to appreciate it intermec

00:02:14,739 --> 00:02:21,000
to make matters worse complexity cells

00:02:17,430 --> 00:02:23,069
other so it's a strong quote right and I

00:02:21,000 --> 00:02:24,959
think this is something that I always

00:02:23,069 --> 00:02:28,319
have in mind when I'm design solutions

00:02:24,959 --> 00:02:31,349
even my day-to-day job or designing new

00:02:28,319 --> 00:02:34,290
projects new libraries and I think like

00:02:31,349 --> 00:02:36,090
before i started doing scala i was doing

00:02:34,290 --> 00:02:37,859
small talk I don't know if you have

00:02:36,090 --> 00:02:40,260
heard of small talk it's a very old

00:02:37,859 --> 00:02:43,049
language and I always had this feeling

00:02:40,260 --> 00:02:45,090
of like being using something that's

00:02:43,049 --> 00:02:47,730
simple that's easy to reason about and

00:02:45,090 --> 00:02:50,639
they started doing Scala and I didn't

00:02:47,730 --> 00:02:52,620
have this same feeling at first I

00:02:50,639 --> 00:02:55,169
thought like it was because I was

00:02:52,620 --> 00:02:57,540
adapting to new to the functional

00:02:55,169 --> 00:03:00,629
programming and etc but I do think that

00:02:57,540 --> 00:03:03,659
now that I understand better things in

00:03:00,629 --> 00:03:06,239
Scala I do think that we as a community

00:03:03,659 --> 00:03:08,549
need to get better at designing

00:03:06,239 --> 00:03:10,680
solutions especially libraries that are

00:03:08,549 --> 00:03:12,780
easy to understand easy to reason about

00:03:10,680 --> 00:03:16,769
and not something that sells just

00:03:12,780 --> 00:03:18,480
because its conflicts and like the code

00:03:16,769 --> 00:03:21,540
says increasing something that's hard to

00:03:18,480 --> 00:03:25,079
achieve and it's also hard to appreciate

00:03:21,540 --> 00:03:26,099
it and for a long time I didn't realize

00:03:25,079 --> 00:03:28,590
something that's important about

00:03:26,099 --> 00:03:30,269
simplicity is that it also depends on

00:03:28,590 --> 00:03:32,609
the context that you are using a

00:03:30,269 --> 00:03:35,909
solution so let's say let's see one

00:03:32,609 --> 00:03:38,609
example I worked on these resistance

00:03:35,909 --> 00:03:41,400
library called activate and it's a very

00:03:38,609 --> 00:03:43,769
simple and easy solution to deal with

00:03:41,400 --> 00:03:46,049
persistence in scholar so we have their

00:03:43,769 --> 00:03:47,909
persistence context and then we in part

00:03:46,049 --> 00:03:51,109
from it and then there is this entity

00:03:47,909 --> 00:03:53,879
that is a person and it has a name and

00:03:51,109 --> 00:03:55,409
the name is mutable here because with

00:03:53,879 --> 00:03:57,599
the software in sectional memory

00:03:55,409 --> 00:04:00,120
approach you're basically map the states

00:03:57,599 --> 00:04:03,209
of the database in memory and then you

00:04:00,120 --> 00:04:06,150
can or use emote immutable entities or

00:04:03,209 --> 00:04:10,229
use the dermo techniques that we have to

00:04:06,150 --> 00:04:11,879
deal with mutability and then there's

00:04:10,229 --> 00:04:14,430
this migration so it's a very powerful

00:04:11,879 --> 00:04:17,759
and easy way of dealing with databases

00:04:14,430 --> 00:04:19,799
and this is the interesting part of my

00:04:17,759 --> 00:04:22,169
point here that is when we are using

00:04:19,799 --> 00:04:24,479
activate it's a very simple way of

00:04:22,169 --> 00:04:26,430
dealing with database and persistence so

00:04:24,479 --> 00:04:29,720
here i have this transactional block and

00:04:26,430 --> 00:04:32,120
it's creating a new instance of person

00:04:29,720 --> 00:04:35,960
and as you can see there is no need to

00:04:32,120 --> 00:04:38,630
call person dot save it has something

00:04:35,960 --> 00:04:42,110
that is transparent persistence so you

00:04:38,630 --> 00:04:44,360
don't need to worry about say like now

00:04:42,110 --> 00:04:48,080
police Percy's this new object that I've

00:04:44,360 --> 00:04:49,880
just created and then this is called

00:04:48,080 --> 00:04:53,000
transparent persistence it's a very

00:04:49,880 --> 00:04:55,040
powerful mechanism and then there is

00:04:53,000 --> 00:04:57,770
another transaction they're running a

00:04:55,040 --> 00:04:59,630
query and the prairies in activate are

00:04:57,770 --> 00:05:01,790
consistent so this is a very common

00:04:59,630 --> 00:05:03,980
problem when you are dealing with object

00:05:01,790 --> 00:05:05,960
relational mapping Garvey's don't take

00:05:03,980 --> 00:05:07,820
in consideration objects that are being

00:05:05,960 --> 00:05:09,860
created by the transaction are being

00:05:07,820 --> 00:05:12,410
modified by the transaction and with

00:05:09,860 --> 00:05:14,510
activates the crevices are consistent so

00:05:12,410 --> 00:05:16,220
they take in consideration that there

00:05:14,510 --> 00:05:18,980
are new objects being created or being

00:05:16,220 --> 00:05:20,840
modified so they are consistent so this

00:05:18,980 --> 00:05:23,780
means that you can deal with the

00:05:20,840 --> 00:05:25,390
persistence persistence layer in a way

00:05:23,780 --> 00:05:27,440
that you don't need to worry about

00:05:25,390 --> 00:05:29,480
knowing that there is a remote system

00:05:27,440 --> 00:05:31,580
that is a database that you are going to

00:05:29,480 --> 00:05:33,680
talk to so it's a very simple and

00:05:31,580 --> 00:05:37,130
elegant way of dealing with databases

00:05:33,680 --> 00:05:38,990
but like I said simplicity also depends

00:05:37,130 --> 00:05:41,000
on the context where you are using the

00:05:38,990 --> 00:05:43,669
solution I wrote the solution when I was

00:05:41,000 --> 00:05:46,280
working with monolithic applications so

00:05:43,669 --> 00:05:48,229
they used to have very rich entities

00:05:46,280 --> 00:05:51,800
with very rich transactional business

00:05:48,229 --> 00:05:54,890
logic and simple and increased database

00:05:51,800 --> 00:05:57,979
interaction but at some point I started

00:05:54,890 --> 00:06:00,830
doing microservices i joined soundcloud

00:05:57,979 --> 00:06:02,720
here in berlin and I saw that the

00:06:00,830 --> 00:06:05,150
solution is actually not so simple for

00:06:02,720 --> 00:06:07,729
this kind of environment because instead

00:06:05,150 --> 00:06:09,890
of having rich entities with simple

00:06:07,729 --> 00:06:13,130
database interaction you have simple

00:06:09,890 --> 00:06:15,100
entities to three entities with three

00:06:13,130 --> 00:06:18,680
columns I don't know very simple

00:06:15,100 --> 00:06:21,860
transactional logic but with explicit in

00:06:18,680 --> 00:06:23,870
a database interaction so I saw that ok

00:06:21,860 --> 00:06:26,300
this is not a good solution and it's not

00:06:23,870 --> 00:06:28,460
simple to use this kind of solution like

00:06:26,300 --> 00:06:30,950
X plates for these environments and then

00:06:28,460 --> 00:06:33,190
I have I had this idea of building

00:06:30,950 --> 00:06:36,169
something for this level of abstraction

00:06:33,190 --> 00:06:38,479
at the time I try to use his league from

00:06:36,169 --> 00:06:41,060
typesafe but it wasn't possible to use

00:06:38,479 --> 00:06:42,810
it because of performance issues with my

00:06:41,060 --> 00:06:44,970
sequel so

00:06:42,810 --> 00:06:47,400
I was planning to work on on this

00:06:44,970 --> 00:06:49,740
problem and some day I was watching some

00:06:47,400 --> 00:06:54,630
talks from strange loop i think and i

00:06:49,740 --> 00:06:57,540
watched a talk from this guy and it was

00:06:54,630 --> 00:06:59,850
a talk exactly on how to build this kind

00:06:57,540 --> 00:07:02,940
of library solving most of the problems

00:06:59,850 --> 00:07:05,669
that i was worried about and when i was

00:07:02,940 --> 00:07:07,770
planning to develop the dissolution so

00:07:05,669 --> 00:07:10,530
for those who don't know he's got this

00:07:07,770 --> 00:07:11,820
guy this is philip water he's a very

00:07:10,530 --> 00:07:13,620
important person for the functional

00:07:11,820 --> 00:07:15,960
programming community he worked on

00:07:13,620 --> 00:07:19,290
defining things like monads defining the

00:07:15,960 --> 00:07:22,200
haskell language and he also worked on

00:07:19,290 --> 00:07:25,200
something i think there were three talks

00:07:22,200 --> 00:07:26,820
during Scotty's about type classes and I

00:07:25,200 --> 00:07:29,430
have some history here about type

00:07:26,820 --> 00:07:32,580
classes and background so he Phillip

00:07:29,430 --> 00:07:34,470
water used to attend these meetings that

00:07:32,580 --> 00:07:36,240
were about functional programming and

00:07:34,470 --> 00:07:38,700
some day he was talking to another

00:07:36,240 --> 00:07:40,950
person Sophie father is the guy on the

00:07:38,700 --> 00:07:43,139
left with the very nice looking beard

00:07:40,950 --> 00:07:45,090
and then he was talking to another guy

00:07:43,139 --> 00:07:47,190
and they were discussing how they could

00:07:45,090 --> 00:07:50,880
extend the functionality of a function

00:07:47,190 --> 00:07:53,850
and he misunderstood what this other guy

00:07:50,880 --> 00:07:55,890
was saying and then he went home with

00:07:53,850 --> 00:07:59,280
this misunderstanding and from this

00:07:55,890 --> 00:08:01,260
misunderstanding he bring he brought he

00:07:59,280 --> 00:08:03,990
discovered something that our type

00:08:01,260 --> 00:08:06,330
classes now so it's interesting to see

00:08:03,990 --> 00:08:07,860
like that sometimes amuser than sending

00:08:06,330 --> 00:08:09,870
something that you think like that

00:08:07,860 --> 00:08:11,690
doesn't make any sense can be something

00:08:09,870 --> 00:08:14,130
that produces a very nice result

00:08:11,690 --> 00:08:15,450
infinite water is not only this very

00:08:14,130 --> 00:08:21,419
important person for the functional

00:08:15,450 --> 00:08:25,110
community he's also the lambda man so he

00:08:21,419 --> 00:08:27,210
does these drink he stalks and besides

00:08:25,110 --> 00:08:28,680
being something very cool and funny and

00:08:27,210 --> 00:08:31,590
he's trying to make a point with this

00:08:28,680 --> 00:08:34,560
he's saying he says that the lambda is

00:08:31,590 --> 00:08:36,900
your friend so when we are designing

00:08:34,560 --> 00:08:40,380
solutions when we are solving problems

00:08:36,900 --> 00:08:42,930
he says that we should look for the

00:08:40,380 --> 00:08:45,330
theory that's behind that problem we

00:08:42,930 --> 00:08:49,589
should look for papers and this will

00:08:45,330 --> 00:08:51,959
make our solutions merge Sinkler much

00:08:49,589 --> 00:08:55,380
more generic and this is what I saw

00:08:51,959 --> 00:08:55,990
trying to build something on top of his

00:08:55,380 --> 00:08:59,200
work

00:08:55,990 --> 00:09:02,050
so I could share with you like please

00:08:59,200 --> 00:09:05,620
look for the theory behind the problems

00:09:02,050 --> 00:09:10,300
and we will be a better industry if we

00:09:05,620 --> 00:09:12,730
start to do that so now my talk has

00:09:10,300 --> 00:09:15,550
three main parts so i'll be presenting

00:09:12,730 --> 00:09:17,500
the theorem from the paper the tool box

00:09:15,550 --> 00:09:20,140
that comes from the paper as well and

00:09:17,500 --> 00:09:23,860
then i'll be talking about crew this is

00:09:20,140 --> 00:09:25,959
a short talk I don't have many slides so

00:09:23,860 --> 00:09:28,709
I'm actually opening for questions

00:09:25,959 --> 00:09:32,529
during the talk so let's discuss that

00:09:28,709 --> 00:09:34,779
understand what we have to do discuss

00:09:32,529 --> 00:09:36,790
here today so we have a microphone here

00:09:34,779 --> 00:09:39,070
and another there please come to the

00:09:36,790 --> 00:09:43,120
microphone and I will open for questions

00:09:39,070 --> 00:09:46,089
at any point if you have questions okay

00:09:43,120 --> 00:09:49,990
please ask questions so the paper that

00:09:46,089 --> 00:09:52,300
the talk i watched is based on this

00:09:49,990 --> 00:09:55,630
paper ab ethical theory of language

00:09:52,300 --> 00:09:57,820
integrated query you have the link or

00:09:55,630 --> 00:10:01,690
you can just google it you'll find it

00:09:57,820 --> 00:10:04,630
and there is a theorem that is a theorem

00:10:01,690 --> 00:10:07,420
of Scylla and Charybdis it's based on

00:10:04,630 --> 00:10:10,029
this very old metaphor so we have this

00:10:07,420 --> 00:10:12,250
island and to get to this island we have

00:10:10,029 --> 00:10:15,910
two problems that we can hit so we can

00:10:12,250 --> 00:10:19,120
hit a rock that is Scylla or we can be

00:10:15,910 --> 00:10:22,480
dragged by this whirlpool that is Korea

00:10:19,120 --> 00:10:24,700
bitties okay so it represents that

00:10:22,480 --> 00:10:26,380
sometimes you get to do something we

00:10:24,700 --> 00:10:30,339
need to be aware that there are two

00:10:26,380 --> 00:10:33,010
possible evils so when we are talking

00:10:30,339 --> 00:10:36,160
about developing language interpreted

00:10:33,010 --> 00:10:38,529
query these two evils our Zilla would be

00:10:36,160 --> 00:10:42,070
the case when the cadbury fails to be

00:10:38,529 --> 00:10:45,040
generated or be executed and Charybdis

00:10:42,070 --> 00:10:47,050
would be one when acquiring the host

00:10:45,040 --> 00:10:49,690
language becomes multiple queries in the

00:10:47,050 --> 00:10:52,480
target language so these are the two

00:10:49,690 --> 00:10:53,860
evils that we need to be aware of so we

00:10:52,480 --> 00:10:55,510
need to get there we need to generate

00:10:53,860 --> 00:10:57,579
the query from the host language the

00:10:55,510 --> 00:11:00,070
target language and we need to be aware

00:10:57,579 --> 00:11:02,050
that we can fail or we can generate

00:11:00,070 --> 00:11:06,100
multiple queries person go host language

00:11:02,050 --> 00:11:08,800
query and the theorem says that there

00:11:06,100 --> 00:11:09,820
are a set of transformations that you

00:11:08,800 --> 00:11:13,780
can apply to gain

00:11:09,820 --> 00:11:15,400
t that we are going to get there and to

00:11:13,780 --> 00:11:17,560
apply these rules there are three

00:11:15,400 --> 00:11:20,560
restrictions that we need to make sure

00:11:17,560 --> 00:11:23,800
that the parade in the host language is

00:11:20,560 --> 00:11:25,900
as fine so the restrictions are first

00:11:23,800 --> 00:11:28,270
the query must use a single database

00:11:25,900 --> 00:11:30,280
because it's not possible to have a

00:11:28,270 --> 00:11:33,610
single query that goes that executes

00:11:30,280 --> 00:11:36,910
through multiple databases right so it

00:11:33,610 --> 00:11:39,670
must use a single database it must

00:11:36,910 --> 00:11:42,670
return a flat relation tag type because

00:11:39,670 --> 00:11:45,700
in sicko we don't have like NASA objects

00:11:42,670 --> 00:11:49,900
or lists we only have scholar values

00:11:45,700 --> 00:11:52,630
just simple tables and the last

00:11:49,900 --> 00:11:54,340
restriction is that the query in the

00:11:52,630 --> 00:11:55,810
host language must have only none

00:11:54,340 --> 00:11:57,700
operations in the target language

00:11:55,810 --> 00:12:00,190
because if there's something that I

00:11:57,700 --> 00:12:03,850
can't translate it's not possible to

00:12:00,190 --> 00:12:06,030
generate the query and applying the the

00:12:03,850 --> 00:12:09,040
transformations from the paper and

00:12:06,030 --> 00:12:11,860
guaranteeing these restrictions will

00:12:09,040 --> 00:12:15,910
produce anything that is a successful

00:12:11,860 --> 00:12:18,460
quarry in the target language okay if

00:12:15,910 --> 00:12:23,980
you have questions please come to the

00:12:18,460 --> 00:12:26,610
microphones and stop me okay come to the

00:12:23,980 --> 00:12:26,610
microphone please

00:12:33,420 --> 00:12:41,190
by generating multiple queries in target

00:12:36,780 --> 00:12:43,320
line which is a problem because for

00:12:41,190 --> 00:12:46,170
instance like the paper talks about

00:12:43,320 --> 00:12:47,460
Microsoft Lync you and for some cases a

00:12:46,170 --> 00:12:53,550
single query in the host language

00:12:47,460 --> 00:12:56,340
becomes like to elevated the number of

00:12:53,550 --> 00:12:58,560
rows at runtime so it's a very common

00:12:56,340 --> 00:13:00,510
problem in the microsoft solutions it's

00:12:58,560 --> 00:13:06,510
not so common for Skylar solutions in

00:13:00,510 --> 00:13:09,210
database libraries and then i'll show

00:13:06,510 --> 00:13:12,450
you how we could apply these in scholar

00:13:09,210 --> 00:13:14,850
okay so we have this very simple query

00:13:12,450 --> 00:13:18,000
from the paper it's selecting the name

00:13:14,850 --> 00:13:20,400
of the person a the difference of age

00:13:18,000 --> 00:13:23,340
between person a and B and then it

00:13:20,400 --> 00:13:27,540
selects from couples people a people be

00:13:23,340 --> 00:13:30,390
and then joins by the couple's table the

00:13:27,540 --> 00:13:33,720
two people and then selects people

00:13:30,390 --> 00:13:36,450
couples where one of the person is older

00:13:33,720 --> 00:13:39,120
than the other person very simple query

00:13:36,450 --> 00:13:42,930
right how can we express this query in

00:13:39,120 --> 00:13:45,150
Scala there's a very interesting way of

00:13:42,930 --> 00:13:48,030
expressing it that is very similar to

00:13:45,150 --> 00:13:52,710
the structure of a sequel statement that

00:13:48,030 --> 00:13:56,490
is using for comprehensions okay so sex

00:13:52,710 --> 00:13:58,800
from couple's area see people ages a B

00:13:56,490 --> 00:14:01,950
and then the same filtering the same

00:13:58,800 --> 00:14:04,140
rules and then use the final result if

00:14:01,950 --> 00:14:06,210
you see here it's almost the same

00:14:04,140 --> 00:14:08,280
structure right you have the Select as

00:14:06,210 --> 00:14:09,630
the yield Clause you'll have the throne

00:14:08,280 --> 00:14:11,700
as the upper part of the for

00:14:09,630 --> 00:14:13,770
comprehension and then the filtering

00:14:11,700 --> 00:14:19,290
inside of our comprehension is the where

00:14:13,770 --> 00:14:20,940
clause sicko so it's a very simple and

00:14:19,290 --> 00:14:23,220
interesting way because this way we can

00:14:20,940 --> 00:14:25,050
express we can write systems using a

00:14:23,220 --> 00:14:27,420
simple language that is this color and

00:14:25,050 --> 00:14:30,330
not worry about writing other language

00:14:27,420 --> 00:14:33,840
that is sequel but there's a problem

00:14:30,330 --> 00:14:35,700
with the solution right here couples

00:14:33,840 --> 00:14:38,300
would be I don't know I scholar

00:14:35,700 --> 00:14:41,070
collection in memory people would be a

00:14:38,300 --> 00:14:42,720
scholar collection in memory and this

00:14:41,070 --> 00:14:44,610
doesn't make sense because we don't want

00:14:42,720 --> 00:14:46,980
to load everything from the database it

00:14:44,610 --> 00:14:49,740
would be very inefficient

00:14:46,980 --> 00:14:51,750
for most kasem like some systems have

00:14:49,740 --> 00:14:54,269
everything in memory and make sense to

00:14:51,750 --> 00:14:57,690
do that but it's not the common case we

00:14:54,269 --> 00:14:59,940
want to not load everything from the

00:14:57,690 --> 00:15:03,269
database just in order to run something

00:14:59,940 --> 00:15:04,949
just to run a query so what k what can

00:15:03,269 --> 00:15:07,860
we do about that there is something that

00:15:04,949 --> 00:15:11,760
is a very old concept from organic

00:15:07,860 --> 00:15:13,949
languages that is quotation okay so

00:15:11,760 --> 00:15:18,779
instead of having these as a normal for

00:15:13,949 --> 00:15:20,959
comprehension we quote this code okay so

00:15:18,779 --> 00:15:23,820
we have this method called quote and

00:15:20,959 --> 00:15:27,449
this is a this is the way that I

00:15:23,820 --> 00:15:29,579
implemented quotation with coil and this

00:15:27,449 --> 00:15:31,949
means that these scholar code instead of

00:15:29,579 --> 00:15:35,160
being actually Scala code that will be

00:15:31,949 --> 00:15:38,029
executed at runtime this is actually

00:15:35,160 --> 00:15:40,740
something that will become a parse tree

00:15:38,029 --> 00:15:43,350
so we will have these it's not possible

00:15:40,740 --> 00:15:46,490
to read here but it's a very simple ASV

00:15:43,350 --> 00:15:49,279
representing the structure of that code

00:15:46,490 --> 00:15:52,709
so we have enough information to

00:15:49,279 --> 00:15:56,220
normalize this query and generate the

00:15:52,709 --> 00:15:57,569
sequel statement you have any questions

00:15:56,220 --> 00:15:59,610
please come to the microphone will come

00:15:57,569 --> 00:16:03,750
to the microphone and then a paper

00:15:59,610 --> 00:16:06,779
brings these set of rules it seems to be

00:16:03,750 --> 00:16:08,940
something hard to follow right but it's

00:16:06,779 --> 00:16:12,149
just because it's a different notation

00:16:08,940 --> 00:16:14,819
it's not something very complex it's

00:16:12,149 --> 00:16:16,290
something very simple and elegant if you

00:16:14,819 --> 00:16:19,050
see the same transformation that's being

00:16:16,290 --> 00:16:21,870
defined here implemented by microsoft

00:16:19,050 --> 00:16:24,510
lync you or buys league in scala it's

00:16:21,870 --> 00:16:26,490
like thousands and thousands of lines of

00:16:24,510 --> 00:16:29,100
code and this set of rules can be

00:16:26,490 --> 00:16:31,889
implemented in less than a thousand nine

00:16:29,100 --> 00:16:34,529
in less than thousand lines of code in

00:16:31,889 --> 00:16:36,810
scholar so it's a very very elegant and

00:16:34,529 --> 00:16:39,269
simple way of normalizing Paris in our

00:16:36,810 --> 00:16:41,459
robust because if you see the way that

00:16:39,269 --> 00:16:44,250
means normalizes microsoft lync you and

00:16:41,459 --> 00:16:45,930
slick work they are very ad hoc so they

00:16:44,250 --> 00:16:47,760
sometimes work they sometimes sometimes

00:16:45,930 --> 00:16:50,940
not work and with these normalization

00:16:47,760 --> 00:16:53,760
rules they generally work so unless i

00:16:50,940 --> 00:16:55,040
wrote something i introduced above when

00:16:53,760 --> 00:16:58,860
translating disc of these

00:16:55,040 --> 00:17:00,190
transformations oh I won't be able to go

00:16:58,860 --> 00:17:01,990
through all organization

00:17:00,190 --> 00:17:03,550
here but I will be able to show you one

00:17:01,990 --> 00:17:06,160
of them that is one of the most

00:17:03,550 --> 00:17:07,810
important ones and so we have these left

00:17:06,160 --> 00:17:11,170
hand side at the pattern that we are

00:17:07,810 --> 00:17:14,470
looking for in a query and the right

00:17:11,170 --> 00:17:17,470
hand side is the normalized form of that

00:17:14,470 --> 00:17:19,870
pattern and we could try to translate

00:17:17,470 --> 00:17:21,910
these two for complications in Scala it

00:17:19,870 --> 00:17:24,250
would be more or less like this but this

00:17:21,910 --> 00:17:26,439
is not actually Scala code this is not

00:17:24,250 --> 00:17:29,230
actual syntax the best way of

00:17:26,439 --> 00:17:33,820
translating this rule to scala is using

00:17:29,230 --> 00:17:36,730
flat map calls so it's basically be flat

00:17:33,820 --> 00:17:39,400
map chuki flat map to our this is the

00:17:36,730 --> 00:17:42,940
left hand side of the transformation in

00:17:39,400 --> 00:17:46,180
the right hand side the normalized form

00:17:42,940 --> 00:17:49,510
of this composition is bringing the

00:17:46,180 --> 00:17:53,050
second flat map as a flat map inside the

00:17:49,510 --> 00:17:55,000
initial flat map okay so it's a very

00:17:53,050 --> 00:17:57,670
slight change if you see it's just a

00:17:55,000 --> 00:17:59,860
parenthesis that's being changed so a

00:17:57,670 --> 00:18:03,220
flat map from outside comes to the

00:17:59,860 --> 00:18:05,110
inside of the body of the first flat map

00:18:03,220 --> 00:18:08,740
and it's very interesting because the

00:18:05,110 --> 00:18:10,450
paper doesn't say that this is possible

00:18:08,740 --> 00:18:13,540
to apply because there is something

00:18:10,450 --> 00:18:15,310
monas that is the associativity law that

00:18:13,540 --> 00:18:18,540
guarantees that both forms of this

00:18:15,310 --> 00:18:21,100
composition have same the same meaning

00:18:18,540 --> 00:18:23,950
so we can apply this information and

00:18:21,100 --> 00:18:27,340
what it won't change it will not change

00:18:23,950 --> 00:18:30,490
the meaning of this composition so and

00:18:27,340 --> 00:18:32,500
but the second form of the the the

00:18:30,490 --> 00:18:35,020
composition is easier to translate to

00:18:32,500 --> 00:18:36,820
sequel queries and then the other rules

00:18:35,020 --> 00:18:41,410
are very similar to the same approach

00:18:36,820 --> 00:18:42,700
and then having these ast we have all

00:18:41,410 --> 00:18:45,130
the information about the query the

00:18:42,700 --> 00:18:47,710
structure of the query we can bring can

00:18:45,130 --> 00:18:50,860
create an organization engine based on

00:18:47,710 --> 00:18:53,590
the normalization rules and it's very

00:18:50,860 --> 00:18:59,710
easy to generate the same sequel

00:18:53,590 --> 00:19:02,860
statement from this cold so this is the

00:18:59,710 --> 00:19:04,870
theorem of psyllium credits and this is

00:19:02,860 --> 00:19:07,360
the transformation that we do in quill

00:19:04,870 --> 00:19:09,280
okay so with occultation with the

00:19:07,360 --> 00:19:12,540
normalization rules any questions

00:19:09,280 --> 00:19:15,450
regarding that okay

00:19:12,540 --> 00:19:19,080
so now I'll show you the tool box that

00:19:15,450 --> 00:19:22,260
comes with this approach so the first

00:19:19,080 --> 00:19:27,690
thing that we can do with quotations is

00:19:22,260 --> 00:19:29,190
abstract / values so here there is a

00:19:27,690 --> 00:19:31,200
quotation but there's something

00:19:29,190 --> 00:19:33,480
different about this quotation except

00:19:31,200 --> 00:19:36,060
instead of just being a for convention

00:19:33,480 --> 00:19:38,790
it's actually a function so it's a

00:19:36,060 --> 00:19:41,880
quoted function it has two inputs a and

00:19:38,790 --> 00:19:45,960
B and it will worry all people that are

00:19:41,880 --> 00:19:50,220
using the range of age a and B and then

00:19:45,960 --> 00:19:54,270
we can execute this quotation passing 10

00:19:50,220 --> 00:19:56,960
and 20 as the value for a and B and

00:19:54,270 --> 00:19:59,850
there will be a process of normalization

00:19:56,960 --> 00:20:02,820
that's called beta reduction it's a very

00:19:59,850 --> 00:20:05,100
old transformation even like it was

00:20:02,820 --> 00:20:07,650
defined before computers were born that

00:20:05,100 --> 00:20:10,950
is basically we have to formals that are

00:20:07,650 --> 00:20:14,040
a and B and we have to actual that are

00:20:10,950 --> 00:20:17,550
10 and 20 and we are going to replace

00:20:14,040 --> 00:20:22,170
replace everything that is a inside the

00:20:17,550 --> 00:20:24,600
function by 10 and what is B by 20 okay

00:20:22,170 --> 00:20:27,180
so this means that we have a mess and we

00:20:24,600 --> 00:20:29,400
have a function in the quotation but the

00:20:27,180 --> 00:20:32,610
final sequel statement won't have this

00:20:29,400 --> 00:20:34,860
function it will be just applying 10 and

00:20:32,610 --> 00:20:37,440
20 to a and B and we will have all

00:20:34,860 --> 00:20:44,030
people that are within the range of age

00:20:37,440 --> 00:20:47,010
10 and 20 we also can abstract / redcats

00:20:44,030 --> 00:20:49,140
so here we have a quotation and this

00:20:47,010 --> 00:20:50,100
quotation is also a function but there

00:20:49,140 --> 00:20:52,410
is another thing that's interesting

00:20:50,100 --> 00:20:55,740
about it the function receives a

00:20:52,410 --> 00:20:58,170
function as its input so we are using

00:20:55,740 --> 00:21:02,040
high order functions within quotations

00:20:58,170 --> 00:21:04,350
here and it's squaring all people where

00:21:02,040 --> 00:21:07,320
the age of the person satisfies this

00:21:04,350 --> 00:21:11,370
predicate so very simple and then we can

00:21:07,320 --> 00:21:13,140
execute these quotation again passing an

00:21:11,370 --> 00:21:15,420
actual implementation of the function

00:21:13,140 --> 00:21:18,150
and the same process of normalization

00:21:15,420 --> 00:21:21,390
will be it will be the same process of

00:21:18,150 --> 00:21:24,450
normalization beta reduction so we have

00:21:21,390 --> 00:21:26,580
B that is the formal we will replace by

00:21:24,450 --> 00:21:30,029
X to the body of the phone

00:21:26,580 --> 00:21:33,210
so it will be be to the body of the

00:21:30,029 --> 00:21:34,980
function being applied to you dot H when

00:21:33,210 --> 00:21:38,580
we are applying we are applying you'd of

00:21:34,980 --> 00:21:44,100
age we are going to also apply beta

00:21:38,580 --> 00:21:45,690
reduction replacing X by you'd of age so

00:21:44,100 --> 00:21:47,789
this high order function that we are

00:21:45,690 --> 00:21:49,980
using here in the quotation will be

00:21:47,789 --> 00:21:52,679
abstracted away when we generate the

00:21:49,980 --> 00:21:55,110
final sequel statement any questions

00:21:52,679 --> 00:21:57,000
yeah why weren't you why aren't you

00:21:55,110 --> 00:21:59,100
writing the satisfiers as a function

00:21:57,000 --> 00:22:01,620
like this satisfies that takes an int

00:21:59,100 --> 00:22:03,779
and returns the ball and why we are

00:22:01,620 --> 00:22:05,909
writing clarify the function yeah as a

00:22:03,779 --> 00:22:09,059
function I mean you're declaring it as a

00:22:05,909 --> 00:22:11,159
valve that tastes a parameter int and

00:22:09,059 --> 00:22:14,070
returns the ball n but can't you define

00:22:11,159 --> 00:22:16,200
it as a death yeah we can define it in

00:22:14,070 --> 00:22:18,659
place so we can have a single quotation

00:22:16,200 --> 00:22:21,179
with all the rules all the structure of

00:22:18,659 --> 00:22:24,240
the query but this is something that

00:22:21,179 --> 00:22:26,760
will allow us to refactor quotations and

00:22:24,240 --> 00:22:29,220
refactor queries basically so we can get

00:22:26,760 --> 00:22:32,789
something that's very complex a very big

00:22:29,220 --> 00:22:34,950
query and break into multiple pieces so

00:22:32,789 --> 00:22:36,659
that are easy to reason about reason

00:22:34,950 --> 00:22:39,480
easy to understand i will show you some

00:22:36,659 --> 00:22:41,549
examples of more complex queries but you

00:22:39,480 --> 00:22:44,870
are right we could even write directly

00:22:41,549 --> 00:22:47,850
inside the query how do you handle

00:22:44,870 --> 00:22:52,200
closures of what if it was X greater

00:22:47,850 --> 00:22:54,809
than math.random are it was referring to

00:22:52,200 --> 00:22:57,000
something that is completely outside the

00:22:54,809 --> 00:22:59,549
scope of the core yeah that's a good

00:22:57,000 --> 00:23:01,559
question because here when we are

00:22:59,549 --> 00:23:05,149
calling the betta run this is also a

00:23:01,559 --> 00:23:09,659
quotation so we will have access to the

00:23:05,149 --> 00:23:13,620
satisfying quotation aest and we will

00:23:09,659 --> 00:23:15,330
also have access to the function asd ok

00:23:13,620 --> 00:23:17,730
so we can just apply the beta reduction

00:23:15,330 --> 00:23:21,299
with identifiers and etc ok good

00:23:17,730 --> 00:23:25,350
question thank you I think it's a simple

00:23:21,299 --> 00:23:27,960
one but quotes are all white box macros

00:23:25,350 --> 00:23:30,960
blackboard macros how are you doing the

00:23:27,960 --> 00:23:33,029
getting the HTS and what limitations you

00:23:30,960 --> 00:23:35,870
have on the it's possible to do

00:23:33,029 --> 00:23:38,390
quotations using only black box macros

00:23:35,870 --> 00:23:41,330
okay but we are using white black white

00:23:38,390 --> 00:23:43,940
box macros because it's the only way of

00:23:41,330 --> 00:23:47,360
having information from the original

00:23:43,940 --> 00:23:49,190
quotation to another quotation it's a

00:23:47,360 --> 00:23:50,960
very H add a little bit complex the

00:23:49,190 --> 00:23:53,030
transformation the way that it gets the

00:23:50,960 --> 00:23:55,580
original AST I'm planning to give

00:23:53,030 --> 00:24:01,580
another talk just on this topic thank

00:23:55,580 --> 00:24:07,580
you if you go back to slides there if

00:24:01,580 --> 00:24:11,420
you go back to slides okay yeah is it

00:24:07,580 --> 00:24:13,520
possible to use this if this 10 and 20

00:24:11,420 --> 00:24:16,370
there were sort of values you pass in at

00:24:13,520 --> 00:24:18,890
runtime are you doing anything the crew

00:24:16,370 --> 00:24:21,830
even if the parameters can on 20 there

00:24:18,890 --> 00:24:24,320
if they were values passing at runtime

00:24:21,830 --> 00:24:25,970
would it work down yeah that's a good

00:24:24,320 --> 00:24:28,220
question as well we have a way of

00:24:25,970 --> 00:24:30,260
lifting runtime values inside the

00:24:28,220 --> 00:24:33,010
quotation and that i will be showing

00:24:30,260 --> 00:24:34,970
bigger okay so you can use sort of

00:24:33,010 --> 00:24:36,830
parameterize can you generate

00:24:34,970 --> 00:24:38,780
parameterised SQL queries okay and there

00:24:36,830 --> 00:24:44,150
will be buying variables in the target

00:24:38,780 --> 00:24:45,710
language thanks and then the less that

00:24:44,150 --> 00:24:48,860
another thing that we can do with

00:24:45,710 --> 00:24:51,110
quotations is compose rotations compose

00:24:48,860 --> 00:24:53,900
queries so I have here age from name

00:24:51,110 --> 00:24:55,790
that is given a name we turn the age of

00:24:53,900 --> 00:24:58,790
the person with that name or the people

00:24:55,790 --> 00:25:02,270
with that name and then I can we used

00:24:58,790 --> 00:25:05,690
the quotations that I defined before so

00:25:02,270 --> 00:25:09,110
I can have two names SNT get the age of

00:25:05,690 --> 00:25:10,910
name as age of name T and then get all

00:25:09,110 --> 00:25:15,650
people that are using the range of

00:25:10,910 --> 00:25:17,809
people of of age of person a and B so

00:25:15,650 --> 00:25:21,160
this I think answers the one of the

00:25:17,809 --> 00:25:24,440
questions because this query without

00:25:21,160 --> 00:25:26,240
like breaking the implementation into

00:25:24,440 --> 00:25:28,790
multiple quotations it's something very

00:25:26,240 --> 00:25:30,530
hard to reason about and having these

00:25:28,790 --> 00:25:33,650
dismal quotations that are reusable

00:25:30,530 --> 00:25:37,250
makes it much better and easier to

00:25:33,650 --> 00:25:39,350
understand and the last thing that comes

00:25:37,250 --> 00:25:42,440
with these two blogs are dynamically

00:25:39,350 --> 00:25:45,140
generated queries and this is more like

00:25:42,440 --> 00:25:47,760
an edge case it's not so common to see

00:25:45,140 --> 00:25:49,910
this case but it's also supported

00:25:47,760 --> 00:25:52,230
so let's say that we have these

00:25:49,910 --> 00:25:53,930
predicates implementation that is

00:25:52,230 --> 00:25:56,640
something that will be a runtime value

00:25:53,930 --> 00:25:58,650
something that comes either from user

00:25:56,640 --> 00:26:01,440
interaction and it has movement

00:25:58,650 --> 00:26:03,690
limitations and we also have these

00:26:01,440 --> 00:26:07,710
interesting kind of implementation like

00:26:03,690 --> 00:26:11,790
ends that have they have other pet cat

00:26:07,710 --> 00:26:14,780
as its definition so how can we

00:26:11,790 --> 00:26:17,490
translate this to a quotation to a query

00:26:14,780 --> 00:26:21,060
it's possible to define this method evil

00:26:17,490 --> 00:26:23,610
it will receive the bad cat and then for

00:26:21,060 --> 00:26:27,060
each implementation I can define a new

00:26:23,610 --> 00:26:30,360
function and for instance let's see the

00:26:27,060 --> 00:26:33,600
case of and here we will implement a

00:26:30,360 --> 00:26:35,690
function calls a function and it's very

00:26:33,600 --> 00:26:39,870
interesting because it's calling evil

00:26:35,690 --> 00:26:42,540
recursively alright so we are using

00:26:39,870 --> 00:26:45,600
recursion here even though simple

00:26:42,540 --> 00:26:48,300
statements don't have recursion we can

00:26:45,600 --> 00:26:50,460
express these using quotations but the

00:26:48,300 --> 00:26:53,520
final worry that we generate will be

00:26:50,460 --> 00:26:56,150
just a normal query in C go without any

00:26:53,520 --> 00:27:03,390
recursion so this is very powerful in

00:26:56,150 --> 00:27:06,870
other questions come true thank you for

00:27:03,390 --> 00:27:09,630
each recursion you just add the new line

00:27:06,870 --> 00:27:11,850
to the sequel statement you don't worry

00:27:09,630 --> 00:27:13,950
each time right yeah exactly the

00:27:11,850 --> 00:27:17,910
quotation is something that's building

00:27:13,950 --> 00:27:20,910
the query right and it will execute only

00:27:17,910 --> 00:27:24,630
when you call the beach run ok won't

00:27:20,910 --> 00:27:26,850
this lead to a huge worries that it can

00:27:24,630 --> 00:27:28,340
be something we already compounded let's

00:27:26,850 --> 00:27:30,780
say that we have a very complex

00:27:28,340 --> 00:27:33,210
predicate here it will be a very big

00:27:30,780 --> 00:27:35,670
query so like I said this is not a

00:27:33,210 --> 00:27:40,140
common case right I don't see many cases

00:27:35,670 --> 00:27:41,430
where you would use this cool so now I

00:27:40,140 --> 00:27:44,880
will show you the implementation that

00:27:41,430 --> 00:27:47,250
I've been working on in Scala based on

00:27:44,880 --> 00:27:50,580
this paper that is the name of the

00:27:47,250 --> 00:27:54,810
library is quill and I have these

00:27:50,580 --> 00:27:57,690
demonstrations so this is the way that

00:27:54,810 --> 00:28:00,160
you define a model in quill so you can

00:27:57,690 --> 00:28:03,220
define person with name and age

00:28:00,160 --> 00:28:06,730
and it's a simple case class there is no

00:28:03,220 --> 00:28:09,880
need to have mapping cold anything else

00:28:06,730 --> 00:28:11,440
you just need this case class okay so

00:28:09,880 --> 00:28:15,510
it's different from other solutions in

00:28:11,440 --> 00:28:19,540
Scala and then i can define a quotation

00:28:15,510 --> 00:28:22,060
if we query all people that have the

00:28:19,540 --> 00:28:27,460
name John and then map the map to the

00:28:22,060 --> 00:28:37,030
age of the person and please pay

00:28:27,460 --> 00:28:38,590
attention to this light now so this is

00:28:37,030 --> 00:28:41,650
the most important difference from the

00:28:38,590 --> 00:28:44,380
paper quill is a compile-time language

00:28:41,650 --> 00:28:47,230
integrated query so this means that for

00:28:44,380 --> 00:28:49,480
queries that are static grill will

00:28:47,230 --> 00:28:54,240
generate the final sequel statement at

00:28:49,480 --> 00:28:54,240
compile time okay

00:29:00,130 --> 00:29:07,960
this means that we calling the bit of

00:29:04,840 --> 00:29:10,240
RAM is a very low overhead operation

00:29:07,960 --> 00:29:12,540
there is no normalization there is no

00:29:10,240 --> 00:29:16,090
query generation it's basically calling

00:29:12,540 --> 00:29:18,370
it's very close to calling the database

00:29:16,090 --> 00:29:21,160
driver directly with that sequel

00:29:18,370 --> 00:29:23,290
statement and we have very interesting

00:29:21,160 --> 00:29:25,060
feedback because we can see the final

00:29:23,290 --> 00:29:27,460
card that's being generated generated

00:29:25,060 --> 00:29:29,350
and because we are using quotations we

00:29:27,460 --> 00:29:31,810
can also generate the final sequence a

00:29:29,350 --> 00:29:35,470
plant using the same identifier that you

00:29:31,810 --> 00:29:38,050
used to define the quotation so we can

00:29:35,470 --> 00:29:41,830
see p we can see p dot name it's very

00:29:38,050 --> 00:29:46,270
easy to see from our called how the

00:29:41,830 --> 00:29:49,150
quotation was was generated I think we

00:29:46,270 --> 00:29:51,460
have a question I what's your story on

00:29:49,150 --> 00:29:54,580
making sure that the case class fields

00:29:51,460 --> 00:29:56,110
match the columns on the database all

00:29:54,580 --> 00:29:59,350
right well so what what's your story on

00:29:56,110 --> 00:30:01,540
making the column fields match the case

00:29:59,350 --> 00:30:02,830
class making sure that they're

00:30:01,540 --> 00:30:06,730
consistent the case class on the

00:30:02,830 --> 00:30:09,250
database table mm-hmm so here we are

00:30:06,730 --> 00:30:10,960
only taking sideration the codes that we

00:30:09,250 --> 00:30:13,500
you wrote so we are only taking

00:30:10,960 --> 00:30:16,240
consideration the case class you wrote

00:30:13,500 --> 00:30:18,130
okay it's not like I don't know if I

00:30:16,240 --> 00:30:20,970
understood correctly the question do you

00:30:18,130 --> 00:30:24,760
ensure that the database actually has a

00:30:20,970 --> 00:30:28,030
table that ok we are you getting into

00:30:24,760 --> 00:30:31,990
that right now so here I'm going to

00:30:28,030 --> 00:30:33,910
change one column so we have h here i'm

00:30:31,990 --> 00:30:36,700
going to change this column to a wrong

00:30:33,910 --> 00:30:39,910
name so instead of being a chai change

00:30:36,700 --> 00:30:45,160
to H E and the query will fail to

00:30:39,910 --> 00:30:46,810
compile at compile time okay so this is

00:30:45,160 --> 00:30:49,450
something that we are going to release

00:30:46,810 --> 00:30:51,880
as an experimental feature for the 150

00:30:49,450 --> 00:30:54,130
beliefs because it's not so easy to set

00:30:51,880 --> 00:30:56,380
up the environment and we want to have a

00:30:54,130 --> 00:30:58,960
very good solution for this it's not yet

00:30:56,380 --> 00:31:02,070
there for at least but it's what we

00:30:58,960 --> 00:31:05,070
think but it's a very powerful way of

00:31:02,070 --> 00:31:07,630
validating that the queries are correct

00:31:05,070 --> 00:31:11,290
validating the modules isn't interesting

00:31:07,630 --> 00:31:12,450
you can validate that the person case

00:31:11,290 --> 00:31:15,210
class correct score

00:31:12,450 --> 00:31:17,190
etc but it's much more powerful if you

00:31:15,210 --> 00:31:20,910
can guarantee that all queries will

00:31:17,190 --> 00:31:23,820
actually execute so we can we have

00:31:20,910 --> 00:31:26,940
issues to for instance if the query has

00:31:23,820 --> 00:31:30,530
a cost that is more than you would

00:31:26,940 --> 00:31:33,930
expect we could even file the completion

00:31:30,530 --> 00:31:36,360
right all in compile time you reach the

00:31:33,930 --> 00:31:38,670
database structure yeah a compile-time

00:31:36,360 --> 00:31:41,670
because with macros we have we can

00:31:38,670 --> 00:31:43,800
execute arbitrary is color code so we

00:31:41,670 --> 00:31:45,180
are connecting to the database and for

00:31:43,800 --> 00:31:56,250
instance here Mexico is complaining

00:31:45,180 --> 00:31:58,710
because this column doesn't exist I'll

00:31:56,250 --> 00:32:00,800
show you the status of the we have

00:31:58,710 --> 00:32:04,080
another question sorry yeah no problem

00:32:00,800 --> 00:32:08,010
compared to lifted embedding in slick

00:32:04,080 --> 00:32:10,920
what would you say is the most powerful

00:32:08,010 --> 00:32:13,140
tool and why I'm not sure how to compare

00:32:10,920 --> 00:32:15,330
both approaches yeah that's a good

00:32:13,140 --> 00:32:17,580
question actually because we've lifted

00:32:15,330 --> 00:32:20,100
embedding we have some limitations and

00:32:17,580 --> 00:32:23,340
we are lifting things that could happen

00:32:20,100 --> 00:32:24,690
at compile time to run time right so

00:32:23,340 --> 00:32:27,030
this is a solution that small

00:32:24,690 --> 00:32:28,920
competition is a solution more powerful

00:32:27,030 --> 00:32:31,860
we can for instance use just a normal

00:32:28,920 --> 00:32:34,650
vehicles call instead of Tripoli calls

00:32:31,860 --> 00:32:37,080
we can like just have normal scale code

00:32:34,650 --> 00:32:40,800
when you call for instance when you are

00:32:37,080 --> 00:32:43,410
typing a query with a stake in Teddy J

00:32:40,800 --> 00:32:46,280
it will have to like apply this

00:32:43,410 --> 00:32:49,230
resolution a lot of things so it's very

00:32:46,280 --> 00:32:51,330
low to for instance show the next method

00:32:49,230 --> 00:32:53,310
that you can call because of that and

00:32:51,330 --> 00:32:55,410
the completion is also is lower because

00:32:53,310 --> 00:32:57,330
of that and with quotations it's just

00:32:55,410 --> 00:32:59,880
like a simple Scala method because the

00:32:57,330 --> 00:33:02,040
transformation will be after you define

00:32:59,880 --> 00:33:07,020
your query when you called the entire

00:33:02,040 --> 00:33:09,780
block of code thanks well sorry one

00:33:07,020 --> 00:33:11,460
another problem so you just said that

00:33:09,780 --> 00:33:13,770
compilation will be slower so with

00:33:11,460 --> 00:33:17,690
continuous compiling SBT it will take

00:33:13,770 --> 00:33:20,450
longer is there an option to set it

00:33:17,690 --> 00:33:22,429
do a check-up every tenth compile or

00:33:20,450 --> 00:33:25,070
front like that so in terms of

00:33:22,429 --> 00:33:26,990
performance for completion yeah I mean I

00:33:25,070 --> 00:33:31,879
just want to see that the code compiles

00:33:26,990 --> 00:33:33,950
and I maybe I don't modify the queries

00:33:31,879 --> 00:33:35,360
all the time and that's a that's a good

00:33:33,950 --> 00:33:38,029
thing that we could do like for instance

00:33:35,360 --> 00:33:39,710
if the completion takes too long we can

00:33:38,029 --> 00:33:42,500
even fell because we have control of the

00:33:39,710 --> 00:33:44,840
compilation with macros yeah yeah this

00:33:42,500 --> 00:33:46,970
is interesting we can even track study

00:33:44,840 --> 00:33:48,529
stats and her get stats from computer

00:33:46,970 --> 00:33:50,269
exactly because you don't change the

00:33:48,529 --> 00:33:56,179
database that often yeah that's a good

00:33:50,269 --> 00:33:58,789
idea hey so of a question it kind of

00:33:56,179 --> 00:34:01,399
looks strange that we compile errors /

00:33:58,789 --> 00:34:04,399
weds Quigley is where you run the query

00:34:01,399 --> 00:34:07,549
so wouldn't it make sense technically to

00:34:04,399 --> 00:34:10,540
have the quote be a part of the test DB

00:34:07,549 --> 00:34:14,839
because this way you can actually check

00:34:10,540 --> 00:34:16,490
that the fields match the database when

00:34:14,839 --> 00:34:19,579
you build vikhroli not when you execute

00:34:16,490 --> 00:34:22,280
it so I know it's compiled yeah but I'd

00:34:19,579 --> 00:34:25,159
like to have a wet squiggly and dad yeah

00:34:22,280 --> 00:34:26,750
that's a very good question like this is

00:34:25,159 --> 00:34:28,730
something that we are discussing because

00:34:26,750 --> 00:34:31,520
the right now quotations are not

00:34:28,730 --> 00:34:33,200
dependent on the database so you can

00:34:31,520 --> 00:34:35,690
define a quotation without knowing

00:34:33,200 --> 00:34:37,760
anything about a database and then when

00:34:35,690 --> 00:34:40,010
we call a database we are actually

00:34:37,760 --> 00:34:44,359
vintage translational realization and

00:34:40,010 --> 00:34:47,149
also if the Prairie probing is enabled

00:34:44,359 --> 00:34:48,619
it will also execute it and we are

00:34:47,149 --> 00:34:50,480
planning to make the quotations

00:34:48,619 --> 00:34:53,179
dependent on the database so we could

00:34:50,480 --> 00:34:55,159
apply this kind of validations but

00:34:53,179 --> 00:34:56,960
there's a problem because if we apply

00:34:55,159 --> 00:34:58,670
the additions for each part of the

00:34:56,960 --> 00:35:03,319
quotation the completion time will

00:34:58,670 --> 00:35:08,450
increase probably a lot so we need to

00:35:03,319 --> 00:35:11,750
experiment with that hi I'm wondering if

00:35:08,450 --> 00:35:15,410
the person cluster has a say a method is

00:35:11,750 --> 00:35:19,190
old or something therefore it is all

00:35:15,410 --> 00:35:22,910
that compares its age to say over 30 or

00:35:19,190 --> 00:35:24,920
something then you couldn't use that in

00:35:22,910 --> 00:35:27,290
the quotation right because the code for

00:35:24,920 --> 00:35:27,760
that is not included in the quotation it

00:35:27,290 --> 00:35:29,890
refer

00:35:27,760 --> 00:35:32,610
to like a death on the person instead

00:35:29,890 --> 00:35:35,710
you say for instance when we are

00:35:32,610 --> 00:35:37,210
evolving the scheme of the database no

00:35:35,710 --> 00:35:39,490
I'm thinking about it today the person

00:35:37,210 --> 00:35:40,990
has a method on it that does something

00:35:39,490 --> 00:35:42,880
with these fields compares them to

00:35:40,990 --> 00:35:45,160
something I doing something could you

00:35:42,880 --> 00:35:48,940
use that from within your filter like

00:35:45,160 --> 00:35:51,550
say he is old or something like I think

00:35:48,940 --> 00:35:53,200
call a method on the yeah this is

00:35:51,550 --> 00:35:55,450
something very important when we are

00:35:53,200 --> 00:35:57,580
defining quotations everything that we

00:35:55,450 --> 00:36:00,340
are using with in quotations must be

00:35:57,580 --> 00:36:03,060
something that's quoted as well so if we

00:36:00,340 --> 00:36:06,880
call method it must return a quotation

00:36:03,060 --> 00:36:09,550
but we can also lift runtime values in

00:36:06,880 --> 00:36:12,210
the quotation using the lift method so

00:36:09,550 --> 00:36:14,560
they will be just bind variables but

00:36:12,210 --> 00:36:16,180
it's a pattern that you can use so for

00:36:14,560 --> 00:36:18,070
instance I can add a new method to

00:36:16,180 --> 00:36:19,330
person there is a quotation that will

00:36:18,070 --> 00:36:26,050
have like something that will feature

00:36:19,330 --> 00:36:29,110
the person oh so now the status of the

00:36:26,050 --> 00:36:32,350
project we have quite a few modules just

00:36:29,110 --> 00:36:34,570
a ok one more question because of the

00:36:32,350 --> 00:36:38,950
previous slide do we have the

00:36:34,570 --> 00:36:42,180
possibility to actually map the column

00:36:38,950 --> 00:36:46,780
names to this case class properties

00:36:42,180 --> 00:36:49,660
because somehow you could have more ugly

00:36:46,780 --> 00:36:52,600
names in the database yes endless cars

00:36:49,660 --> 00:36:55,360
or perhaps provide and default mapping

00:36:52,600 --> 00:36:57,430
like camel case or some GPS for

00:36:55,360 --> 00:36:59,490
underscores we have some naming

00:36:57,430 --> 00:37:01,870
strategies that will translate these

00:36:59,490 --> 00:37:05,530
properties from the entities from the

00:37:01,870 --> 00:37:09,130
case classes and you can also define a

00:37:05,530 --> 00:37:11,470
custom name for table name or event for

00:37:09,130 --> 00:37:14,140
columns so you would create a quotation

00:37:11,470 --> 00:37:18,730
that is a query of person passing saying

00:37:14,140 --> 00:37:21,400
like column X has this name in the

00:37:18,730 --> 00:37:24,010
target language and then you can reuse

00:37:21,400 --> 00:37:28,450
this quotation to query people from

00:37:24,010 --> 00:37:31,450
anywhere of your code base cool so now

00:37:28,450 --> 00:37:33,550
the status of the project we have quite

00:37:31,450 --> 00:37:36,970
a few modules already so there is cool

00:37:33,550 --> 00:37:38,800
car it has the quotations implementation

00:37:36,970 --> 00:37:42,580
normalization rules and

00:37:38,800 --> 00:37:44,170
macros so it's a very generic car it

00:37:42,580 --> 00:37:46,150
doesn't know anything about Cinco

00:37:44,170 --> 00:37:49,420
statements doesn't know anything about

00:37:46,150 --> 00:37:52,120
jdbc or any database driver so we could

00:37:49,420 --> 00:37:54,820
use we use this car to build things that

00:37:52,120 --> 00:37:58,720
are for instance we could run quotations

00:37:54,820 --> 00:38:02,770
using this car we could generate graph

00:37:58,720 --> 00:38:04,810
ql queries from this car we could

00:38:02,770 --> 00:38:07,900
because there is this problem with spark

00:38:04,810 --> 00:38:10,390
because we can define our dd's and these

00:38:07,900 --> 00:38:12,190
are dd's don't like spark doesn't know

00:38:10,390 --> 00:38:14,800
about the structure of the code that

00:38:12,190 --> 00:38:18,190
will be executed we could use quotation

00:38:14,800 --> 00:38:20,920
to basically know about the structure of

00:38:18,190 --> 00:38:23,530
the code and then execute it so it's a

00:38:20,920 --> 00:38:26,140
very generic solution there is an an

00:38:23,530 --> 00:38:28,150
interesting idea of using quotations

00:38:26,140 --> 00:38:29,650
because in Scala we can have for

00:38:28,150 --> 00:38:32,530
instance very large collections in

00:38:29,650 --> 00:38:34,960
memory and it's very very expensive to

00:38:32,530 --> 00:38:37,870
call methods like for each map and etc

00:38:34,960 --> 00:38:40,180
it is far with the current version of

00:38:37,870 --> 00:38:42,190
scholar and we could use quotations to

00:38:40,180 --> 00:38:43,930
build a prairie and then execute this

00:38:42,190 --> 00:38:46,030
query using wire loops and things that

00:38:43,930 --> 00:38:48,820
are efficient and don't require

00:38:46,030 --> 00:38:51,010
allocation so it's a very the

00:38:48,820 --> 00:38:53,080
possibilities are here are very broad

00:38:51,010 --> 00:38:55,090
and if you are interested we are for

00:38:53,080 --> 00:38:58,510
instance we are going planning to work

00:38:55,090 --> 00:39:01,330
on spark integration after the 1.0

00:38:58,510 --> 00:39:02,710
release if you know a spark you want to

00:39:01,330 --> 00:39:07,390
work on something interesting please

00:39:02,710 --> 00:39:10,930
come talk to us and then we also have

00:39:07,390 --> 00:39:13,030
cool SQL it's a driver at agnostic

00:39:10,930 --> 00:39:14,980
sequel generation it doesn't know

00:39:13,030 --> 00:39:17,070
anything about a database driver it's

00:39:14,980 --> 00:39:19,750
just extending the car to see Co

00:39:17,070 --> 00:39:22,350
statements and then there's quill 18

00:39:19,750 --> 00:39:24,850
that is on top of fully non-working

00:39:22,350 --> 00:39:29,140
asynchronous drivers for all surgeries

00:39:24,850 --> 00:39:32,350
and my sicko it's not just only an async

00:39:29,140 --> 00:39:34,320
async wrapper on top of blocking I oh

00:39:32,350 --> 00:39:37,660
it's a fully non-blocking i/o

00:39:34,320 --> 00:39:40,690
implementation there's also quill

00:39:37,660 --> 00:39:44,110
finagle Mexico that is also a nonworking

00:39:40,690 --> 00:39:46,720
using finaid oh there's the good old

00:39:44,110 --> 00:39:48,430
blocking jdbc it's a good solution if

00:39:46,720 --> 00:39:49,580
you have if you don't have like a very

00:39:48,430 --> 00:39:51,710
large scale

00:39:49,580 --> 00:39:54,470
your application won't run like with a

00:39:51,710 --> 00:39:59,840
lot of requests but you can have very

00:39:54,470 --> 00:40:01,370
serious problems using jdbc and the last

00:39:59,840 --> 00:40:03,710
one this is very exciting because it's

00:40:01,370 --> 00:40:06,170
one module that doesn't generate c koi

00:40:03,710 --> 00:40:09,620
statements so it's a new Cassandra

00:40:06,170 --> 00:40:11,870
module it's building its producing cql

00:40:09,620 --> 00:40:14,570
Cassandra queries on top of the Java

00:40:11,870 --> 00:40:17,090
driver and it has something new this is

00:40:14,570 --> 00:40:19,690
cool as well that is reactive streams

00:40:17,090 --> 00:40:23,270
integration Liam onyx there's a

00:40:19,690 --> 00:40:26,120
observable library and it's very cool to

00:40:23,270 --> 00:40:28,520
have reactive streams integration and

00:40:26,120 --> 00:40:31,970
support and we are planning after the

00:40:28,520 --> 00:40:34,550
1.0 release on working on extending

00:40:31,970 --> 00:40:38,090
reactive streams integration to the

00:40:34,550 --> 00:40:41,870
other modules as well if you don't use

00:40:38,090 --> 00:40:43,190
phonics for reactive streams I think you

00:40:41,870 --> 00:40:47,600
should use it because it's a very good

00:40:43,190 --> 00:40:49,310
library and this is something I'm very

00:40:47,600 --> 00:40:51,620
excited by this because I normally work

00:40:49,310 --> 00:40:54,020
on projects and it's very hard to build

00:40:51,620 --> 00:40:56,210
like a maintainer community around the

00:40:54,020 --> 00:40:59,480
project around open source projects and

00:40:56,210 --> 00:41:02,870
even though who is a very young project

00:40:59,480 --> 00:41:05,120
we already have a mantener seem so this

00:41:02,870 --> 00:41:09,770
is awesome I'm working on the project

00:41:05,120 --> 00:41:12,590
there's Louis working from from Europe

00:41:09,770 --> 00:41:15,110
Gustavo who is here is working on from

00:41:12,590 --> 00:41:18,170
South America there is Gillian she's

00:41:15,110 --> 00:41:21,290
working from China and also noah is

00:41:18,170 --> 00:41:24,470
working from the US and if you want to

00:41:21,290 --> 00:41:26,750
use quill you are welcome we are going

00:41:24,470 --> 00:41:30,050
to do our best to give you support but

00:41:26,750 --> 00:41:32,990
if you are going to be a nun taner you

00:41:30,050 --> 00:41:34,940
are more than welcome so we are looking

00:41:32,990 --> 00:41:37,370
for maintainer we are willing to give

00:41:34,940 --> 00:41:39,410
you support and mentoring if necessary

00:41:37,370 --> 00:41:41,030
so we are looking for people that's

00:41:39,410 --> 00:41:44,630
interested in working with this

00:41:41,030 --> 00:41:47,870
interesting solution and we are planning

00:41:44,630 --> 00:41:51,700
to release the 1.0 version this summer

00:41:47,870 --> 00:41:56,180
you can follow the progress on our

00:41:51,700 --> 00:42:00,110
website I think that's all I have any

00:41:56,180 --> 00:42:02,150
other questions I have a co

00:42:00,110 --> 00:42:05,120
question about queer Cassandra diver

00:42:02,150 --> 00:42:06,830
driver I mean which versions of

00:42:05,120 --> 00:42:10,250
Cassandra diver are currently supported

00:42:06,830 --> 00:42:13,010
and how partner Griffin over quick

00:42:10,250 --> 00:42:15,020
Cassandra with versions of driver are

00:42:13,010 --> 00:42:16,880
currently supported and helped reduce

00:42:15,020 --> 00:42:22,420
were using the latest version of the

00:42:16,880 --> 00:42:25,970
driver so your baby recently okay think

00:42:22,420 --> 00:42:28,040
pi i also have a question well actually

00:42:25,970 --> 00:42:30,140
we are using quill cassandra and

00:42:28,040 --> 00:42:32,930
production right oh really that's great

00:42:30,140 --> 00:42:35,120
you might be the first one strike i read

00:42:32,930 --> 00:42:37,940
into and yeah it's very cool and I

00:42:35,120 --> 00:42:39,980
really like this so so it's nice but I

00:42:37,940 --> 00:42:42,320
do have a question about it because i

00:42:39,980 --> 00:42:45,320
looked at the sources and queer car is

00:42:42,320 --> 00:42:47,510
basically ninety percent macros and with

00:42:45,320 --> 00:42:50,180
the macros going bye-bye soon so was

00:42:47,510 --> 00:42:52,640
your strategy on this that's a good

00:42:50,180 --> 00:42:55,040
question I didn't know when to use car

00:42:52,640 --> 00:42:57,830
they should be honest I didn't see the

00:42:55,040 --> 00:43:01,130
talks and what will happen but right now

00:42:57,830 --> 00:43:04,040
with Scala meta and tasty we will be

00:43:01,130 --> 00:43:06,260
possible and it will be better because

00:43:04,040 --> 00:43:09,230
with tasty we don't need white box

00:43:06,260 --> 00:43:12,020
macros and we can access the quotation

00:43:09,230 --> 00:43:13,790
from other completion units so the code

00:43:12,020 --> 00:43:16,190
will be better and it will be possible

00:43:13,790 --> 00:43:17,780
to build crew we I mean obviously it

00:43:16,190 --> 00:43:20,540
will be possible but you will have to

00:43:17,780 --> 00:43:23,330
rewrite it positive from scratch right

00:43:20,540 --> 00:43:26,990
no that's not true because most of the

00:43:23,330 --> 00:43:30,850
cold Inc wheel is not macro called so

00:43:26,990 --> 00:43:33,230
the normalization engine everything is

00:43:30,850 --> 00:43:34,780
something that's normal Scala code so

00:43:33,230 --> 00:43:37,820
that's why when we have a dynamic

00:43:34,780 --> 00:43:39,620
quotation we can execute it and the

00:43:37,820 --> 00:43:42,650
normalization query generation will

00:43:39,620 --> 00:43:45,080
happen at runtime so let's say I was

00:43:42,650 --> 00:43:47,030
thinking on like the worst case scenario

00:43:45,080 --> 00:43:49,250
it's not possible to do what we do with

00:43:47,030 --> 00:43:50,930
macros anymore in quill we could just

00:43:49,250 --> 00:43:54,470
switch to run time for our generation

00:43:50,930 --> 00:43:56,990
and it will be continued to be a good

00:43:54,470 --> 00:43:59,330
library because compile time is actually

00:43:56,990 --> 00:44:00,620
a nice to have you can also exactly i

00:43:59,330 --> 00:44:01,680
mean it's going to be a different

00:44:00,620 --> 00:44:03,210
library than right

00:44:01,680 --> 00:44:05,720
so all right it's going to be a

00:44:03,210 --> 00:44:08,369
completely different library because the

00:44:05,720 --> 00:44:11,460
kind of a killer feature here is the

00:44:08,369 --> 00:44:13,109
fact that you get the Queen oh it's fun

00:44:11,460 --> 00:44:15,270
times the same library let's say that we

00:44:13,109 --> 00:44:19,280
want to remove because what's being

00:44:15,270 --> 00:44:23,510
removed not going to be supported is

00:44:19,280 --> 00:44:26,130
white box macros okay it would be like

00:44:23,510 --> 00:44:29,309
Idaho obtained lines change to make

00:44:26,130 --> 00:44:32,940
everything run time and not use white

00:44:29,309 --> 00:44:34,800
box macros so yeah but I mean though the

00:44:32,940 --> 00:44:36,599
reason we are using this in production

00:44:34,800 --> 00:44:38,670
the reason we are feeling safe about it

00:44:36,599 --> 00:44:41,339
is because we can see those queries

00:44:38,670 --> 00:44:43,980
generated while compiling so we feel

00:44:41,339 --> 00:44:47,579
that this is safe for us but like using

00:44:43,980 --> 00:44:49,589
every while a young library on

00:44:47,579 --> 00:44:50,910
production down there when the code

00:44:49,589 --> 00:44:53,089
generation is being done in runtime

00:44:50,910 --> 00:44:56,700
that's a whole different story right so

00:44:53,089 --> 00:44:58,770
yeah if you like but like I said at

00:44:56,700 --> 00:45:00,480
least from what I've seen here it's in

00:44:58,770 --> 00:45:05,670
Scotties it will be possible to do the

00:45:00,480 --> 00:45:09,660
same thing Lodi okay great thanks our

00:45:05,670 --> 00:45:11,670
questions hi so sometimes when you're

00:45:09,660 --> 00:45:14,130
using a library like this like a an SQL

00:45:11,670 --> 00:45:16,500
they speak louder sorry I'm sorry from

00:45:14,130 --> 00:45:19,200
here it hit hard sometimes when you're

00:45:16,500 --> 00:45:21,299
using an SQL rapper library like this

00:45:19,200 --> 00:45:23,130
you just occasionally need to write

00:45:21,299 --> 00:45:25,470
plain old SQL if you need to do some

00:45:23,130 --> 00:45:27,089
weird aggregation or whatever so is

00:45:25,470 --> 00:45:28,260
there support for that yeah this is

00:45:27,089 --> 00:45:31,530
something very cool because for instance

00:45:28,260 --> 00:45:33,079
when we are when we use this league and

00:45:31,530 --> 00:45:35,579
if there is something that's not

00:45:33,079 --> 00:45:37,859
supported by the library you normally

00:45:35,579 --> 00:45:40,559
have to write playing seco statements

00:45:37,859 --> 00:45:47,130
right with quill there something I can

00:45:40,559 --> 00:45:49,410
show you now we have some time there's

00:45:47,130 --> 00:45:53,430
something that is in figs and you can

00:45:49,410 --> 00:45:57,319
insert arbitrary statements in the

00:45:53,430 --> 00:46:00,809
target language in your quotation so

00:45:57,319 --> 00:46:03,420
show you here so let's say that wheel

00:46:00,809 --> 00:46:07,620
doesn't have support for Isis right

00:46:03,420 --> 00:46:12,960
there oh okay

00:46:07,620 --> 00:46:15,780
I can move the window okay so let's say

00:46:12,960 --> 00:46:18,660
that we have we don't have support for

00:46:15,780 --> 00:46:22,080
for update in quail it's easy to just

00:46:18,660 --> 00:46:24,420
use in figs and have support for it or

00:46:22,080 --> 00:46:27,150
let's say that you have a function or a

00:46:24,420 --> 00:46:30,030
group condition that's not supported by

00:46:27,150 --> 00:46:32,580
cool you can also create any fix for it

00:46:30,030 --> 00:46:33,750
and you just need to say like this is an

00:46:32,580 --> 00:46:37,680
effects and this is the type of

00:46:33,750 --> 00:46:39,360
decoration that will would be this in

00:46:37,680 --> 00:46:43,050
figs basically and then you can use

00:46:39,360 --> 00:46:45,740
identifiers as interpolator values and

00:46:43,050 --> 00:46:48,540
it will be using beta reduction

00:46:45,740 --> 00:46:54,260
normalization and everything for these

00:46:48,540 --> 00:46:57,240
values thank you do you have support for

00:46:54,260 --> 00:46:58,770
updating database likes or update on

00:46:57,240 --> 00:47:01,020
insert and delete statement things

00:46:58,770 --> 00:47:04,650
before sorry could you have support for

00:47:01,020 --> 00:47:07,740
updating database like delete insert in

00:47:04,650 --> 00:47:11,540
SQL we also have action supports support

00:47:07,740 --> 00:47:15,320
for updates and deletes and etc yep and

00:47:11,540 --> 00:47:18,600
you can do something inslee you can't

00:47:15,320 --> 00:47:21,420
update something using a value of the

00:47:18,600 --> 00:47:23,640
table I don't know if you used stick but

00:47:21,420 --> 00:47:26,850
with queries very trivial you can just

00:47:23,640 --> 00:47:29,730
define an insert or that it's using

00:47:26,850 --> 00:47:31,590
another sequel statement or any update

00:47:29,730 --> 00:47:39,060
that's using one of the columns of the

00:47:31,590 --> 00:47:42,080
table oh I think that's it thank you up

00:47:39,060 --> 00:47:42,080
from work

00:47:45,789 --> 00:47:51,890
it's an idea just a question that popped

00:47:49,010 --> 00:47:54,680
up you said that's interesting to go

00:47:51,890 --> 00:47:57,230
back to the theory so what was what did

00:47:54,680 --> 00:47:59,690
you feel the articles gave you what what

00:47:57,230 --> 00:48:02,660
did what did really come out of that

00:47:59,690 --> 00:48:05,180
that you say yeah I used to read papers

00:48:02,660 --> 00:48:07,970
and look for theory behind problems but

00:48:05,180 --> 00:48:09,589
I wasn't like to strict about it I was

00:48:07,970 --> 00:48:11,720
like okay I could couldn't find

00:48:09,589 --> 00:48:14,510
something right now like I'm really

00:48:11,720 --> 00:48:16,670
looking for papers and theory behind

00:48:14,510 --> 00:48:18,880
problems like this this particular case

00:48:16,670 --> 00:48:21,380
what do you think really was the best

00:48:18,880 --> 00:48:24,730
lesson to you about what you read in the

00:48:21,380 --> 00:48:28,520
paper how you applied it in in quill

00:48:24,730 --> 00:48:31,460
sorry how we can apply paper though what

00:48:28,520 --> 00:48:33,230
was your what did you think was the best

00:48:31,460 --> 00:48:35,240
thing that you got from the paper and

00:48:33,230 --> 00:48:37,940
applied in quill in organization rules

00:48:35,240 --> 00:48:39,920
like I was like okay how can i implement

00:48:37,940 --> 00:48:42,440
this and it was like basically saying

00:48:39,920 --> 00:48:45,170
this is the way that you do and it's

00:48:42,440 --> 00:48:47,299
solved so it's really great what's

00:48:45,170 --> 00:48:49,390
really great Oh think that's it thank

00:48:47,299 --> 00:48:49,390

YouTube URL: https://www.youtube.com/watch?v=nqSYccoSeio


