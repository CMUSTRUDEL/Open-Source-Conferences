Title: Roll Your Own Shapeless by Daniel Spiewak
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
Shapeless is a remarkable framework.  It gives us the power to represent astonishingly rich constraints and generalize code over very broad structural classes, but it isn't magic!  The tools with which shapeless is crafted are present in your version of scalac just as much as they are in Miles Sabin's, and learning to take advantage of them unlocks a rich palette of expression otherwise untapped in the language.  In this talk, we will recreate some of the major elements of shapeless, learning how to harness a fully armed and operational type system, all while avoiding any hint of macro programming!  Particular focus will be given to understanding the general patterns and ideas involved, and not just the end result.
Captions: 
	00:00:02,810 --> 00:00:06,920
I'm Daniel Spiewak this is my talk on

00:00:05,000 --> 00:00:07,819
shapeless so if that's not the talk you

00:00:06,920 --> 00:00:10,510
were expecting you're in the wrong room

00:00:07,819 --> 00:00:12,709
and we're going to start off with a game

00:00:10,510 --> 00:00:17,810
look at these four slides and tell me

00:00:12,709 --> 00:00:23,359
which one was taken most recently I I

00:00:17,810 --> 00:00:26,240
can't really tell of course the all the

00:00:23,359 --> 00:00:28,369
answer to this is ismail Saban who is

00:00:26,240 --> 00:00:31,579
best known for his work on the Scala

00:00:28,369 --> 00:00:32,810
Eclipse IDE but in his spare time he's

00:00:31,579 --> 00:00:35,990
been working on a project called

00:00:32,810 --> 00:00:38,330
shapeless and shapeless is probably best

00:00:35,990 --> 00:00:40,790
known for things like H list and co

00:00:38,330 --> 00:00:42,020
product which Martin kind of referenced

00:00:40,790 --> 00:00:44,090
yesterday with the whole scrappier

00:00:42,020 --> 00:00:46,940
boilerplate thing that Dottie is doing

00:00:44,090 --> 00:00:48,740
but these these tools are really just a

00:00:46,940 --> 00:00:52,430
demonstration of some tools and

00:00:48,740 --> 00:00:54,200
techniques for library authors to to

00:00:52,430 --> 00:00:56,090
build better generic interfaces right

00:00:54,200 --> 00:00:58,640
and then it's not it's not tools and

00:00:56,090 --> 00:01:00,230
techniques as in thou shalt use H list

00:00:58,640 --> 00:01:02,240
and make your libraries awesome its

00:01:00,230 --> 00:01:04,009
tools and techniques like here's what

00:01:02,240 --> 00:01:05,900
you can do with the type system and oh

00:01:04,009 --> 00:01:08,270
yeah H list is one of the things that we

00:01:05,900 --> 00:01:09,979
can do with that shapeless is an

00:01:08,270 --> 00:01:11,719
exploration of some idioms for

00:01:09,979 --> 00:01:13,820
programming at the type level idioms and

00:01:11,719 --> 00:01:15,530
patterns that allow us to leverage

00:01:13,820 --> 00:01:16,759
scholars type system as a powerful

00:01:15,530 --> 00:01:19,490
programming language in and of itself

00:01:16,759 --> 00:01:23,090
and most importantly of all shapeless is

00:01:19,490 --> 00:01:25,280
not magic miles does not have a special

00:01:23,090 --> 00:01:27,289
copy of scala see that Martin Adair ski

00:01:25,280 --> 00:01:29,210
gave him breasts from on high to do all

00:01:27,289 --> 00:01:31,399
of this stuff right we can do all of it

00:01:29,210 --> 00:01:33,950
ourselves in our own copy of Scala see

00:01:31,399 --> 00:01:35,689
for fun and profit and so that's exactly

00:01:33,950 --> 00:01:38,810
what we're going to do we're going to

00:01:35,689 --> 00:01:41,240
create our own shapeless and and

00:01:38,810 --> 00:01:42,829
obviously we can't do all of it in this

00:01:41,240 --> 00:01:45,139
talk but I think we can do some things

00:01:42,829 --> 00:01:48,380
and I think we can learn a lot in the

00:01:45,139 --> 00:01:50,719
process so a few years ago I gave a talk

00:01:48,380 --> 00:01:53,600
entitled hi wizardry in the land of

00:01:50,719 --> 00:01:55,909
Scott and in this talk one of the things

00:01:53,600 --> 00:01:57,770
that we did was we built an H list a

00:01:55,909 --> 00:02:00,560
very very very straightforward H list

00:01:57,770 --> 00:02:02,240
basically all it had was append which

00:02:00,560 --> 00:02:03,829
was more or less the most complicated

00:02:02,240 --> 00:02:06,079
thing that you could do with H list back

00:02:03,829 --> 00:02:08,959
in Scala 2.7 which is when I gave this

00:02:06,079 --> 00:02:10,280
talk but I think this is a pretty good

00:02:08,959 --> 00:02:13,159
building block it's a pretty good place

00:02:10,280 --> 00:02:15,019
to start and we'll start with this H

00:02:13,159 --> 00:02:16,140
list kernel and build up some more

00:02:15,019 --> 00:02:19,020
functions on top of

00:02:16,140 --> 00:02:21,150
that exemplify various techniques in

00:02:19,020 --> 00:02:23,670
idioms that we can use to do generic

00:02:21,150 --> 00:02:26,010
programming in Skyler's type system so

00:02:23,670 --> 00:02:27,270
here's H list this is what we left off I

00:02:26,010 --> 00:02:30,480
don't know eight years ago or whenever

00:02:27,270 --> 00:02:33,270
it was we have an H list trait that has

00:02:30,480 --> 00:02:34,920
an append function both of the value

00:02:33,270 --> 00:02:36,450
level and at the type level these are

00:02:34,920 --> 00:02:38,730
both abstract both the type in the value

00:02:36,450 --> 00:02:41,330
and the function and we're gonna have an

00:02:38,730 --> 00:02:45,150
H cons and an H Neal implementation i

00:02:41,330 --> 00:02:46,290
defined HDL is H Neal not there's a

00:02:45,150 --> 00:02:47,730
reason for this that i'll get to in a

00:02:46,290 --> 00:02:49,980
second but basically it's to get around

00:02:47,730 --> 00:02:51,450
a bug and scholars type system you're

00:02:49,980 --> 00:02:53,130
going to find a lot of that sort of

00:02:51,450 --> 00:02:54,690
thing in these patterns for type level

00:02:53,130 --> 00:02:56,280
programming is you just like well we

00:02:54,690 --> 00:02:57,720
just do it in exactly this way because

00:02:56,280 --> 00:02:59,570
if we do it in this other way that seems

00:02:57,720 --> 00:03:01,950
more natural Skala see kind of explodes

00:02:59,570 --> 00:03:04,410
so we don't want to i'll see to explode

00:03:01,950 --> 00:03:06,120
anyway h cons NH nail so the append

00:03:04,410 --> 00:03:07,650
cases for h&L are very straightforward

00:03:06,120 --> 00:03:09,570
they just return to list their past and

00:03:07,650 --> 00:03:11,550
the append cases for H cons are

00:03:09,570 --> 00:03:13,920
basically what you would expect you know

00:03:11,550 --> 00:03:15,269
we deconstruct the list append to our

00:03:13,920 --> 00:03:17,220
tail and I'm just to put it back

00:03:15,269 --> 00:03:19,110
together again and you notice that the

00:03:17,220 --> 00:03:20,400
append type level function is doing

00:03:19,110 --> 00:03:22,470
something a little bit weird where it's

00:03:20,400 --> 00:03:24,390
doing this sort of projection on the t

00:03:22,470 --> 00:03:27,690
where t is a variable that was given to

00:03:24,390 --> 00:03:29,190
the sort of type constructor h cons this

00:03:27,690 --> 00:03:30,840
is one of the things that's grown and

00:03:29,190 --> 00:03:32,940
dottie so we wouldn't be able to do this

00:03:30,840 --> 00:03:34,140
in dotty but we're still in Scotland so

00:03:32,940 --> 00:03:36,170
we're capable of doing this and we'll

00:03:34,140 --> 00:03:38,160
come back to this technique in a second

00:03:36,170 --> 00:03:40,079
we're going to need a package object

00:03:38,160 --> 00:03:42,150
that has some utilities in it to make

00:03:40,079 --> 00:03:46,230
things a little bit easier we're going

00:03:42,150 --> 00:03:48,480
to have a cons type alias and icons

00:03:46,230 --> 00:03:50,040
function and the cons function you'll

00:03:48,480 --> 00:03:51,660
see this a lot with with type level

00:03:50,040 --> 00:03:53,670
programming where instead of having

00:03:51,660 --> 00:03:55,019
member functions or methods you have to

00:03:53,670 --> 00:03:56,190
actually put it on an implicit

00:03:55,019 --> 00:03:57,780
enrichment which is what we're doing

00:03:56,190 --> 00:04:00,150
right here with this implicit syntax

00:03:57,780 --> 00:04:02,430
class and the reason we're doing this is

00:04:00,150 --> 00:04:03,720
so we can get the specific type of the

00:04:02,430 --> 00:04:06,540
list which is the thing that we're

00:04:03,720 --> 00:04:08,040
dispatching on type l and you do this a

00:04:06,540 --> 00:04:09,600
lot because in type level programming

00:04:08,040 --> 00:04:11,730
you spend all of this time trying to get

00:04:09,600 --> 00:04:13,230
a really really precise type only to

00:04:11,730 --> 00:04:15,900
have you know the compiler throw it away

00:04:13,230 --> 00:04:17,489
because subtyping we don't want that to

00:04:15,900 --> 00:04:19,169
happen so we use implicit conversions

00:04:17,489 --> 00:04:21,810
here to kind of get the cons function on

00:04:19,169 --> 00:04:23,160
to the list so this is all this is all

00:04:21,810 --> 00:04:24,539
just syntax though right we're not doing

00:04:23,160 --> 00:04:26,070
anything useful we're not doing anything

00:04:24,539 --> 00:04:27,870
interesting the interesting thing was

00:04:26,070 --> 00:04:29,400
kind of sort of a slight ago and it's

00:04:27,870 --> 00:04:30,750
this append function right

00:04:29,400 --> 00:04:32,580
this is a type level function it's the

00:04:30,750 --> 00:04:34,229
first of several type level functions

00:04:32,580 --> 00:04:36,030
that we will be seeing in this talk and

00:04:34,229 --> 00:04:37,979
it's completely different than all of

00:04:36,030 --> 00:04:40,440
the others because this is a context

00:04:37,979 --> 00:04:42,060
independent type level function the very

00:04:40,440 --> 00:04:43,139
special sort of type level function and

00:04:42,060 --> 00:04:45,840
again it's one of those things that's

00:04:43,139 --> 00:04:47,130
going away because in a sense we don't

00:04:45,840 --> 00:04:48,419
really need it anymore once we get a

00:04:47,130 --> 00:04:51,120
little bit more power in the language

00:04:48,419 --> 00:04:52,470
but as things currently stand context

00:04:51,120 --> 00:04:54,360
independent type level functions are

00:04:52,470 --> 00:04:56,039
very special they are structurally

00:04:54,360 --> 00:04:57,930
definitional this is a property that

00:04:56,039 --> 00:05:00,419
they give us that that is very very

00:04:57,930 --> 00:05:02,280
powerful this structurally definitional

00:05:00,419 --> 00:05:03,900
nature and by the way what I mean by

00:05:02,280 --> 00:05:06,840
that is it is like there's really only

00:05:03,900 --> 00:05:08,130
one way to define append right you you

00:05:06,840 --> 00:05:10,289
could you could either define it like

00:05:08,130 --> 00:05:12,300
the HLA or you define it like the H cons

00:05:10,289 --> 00:05:14,729
way and it's it's kind of it is kind of

00:05:12,300 --> 00:05:16,080
only one way to go and it falls out very

00:05:14,729 --> 00:05:17,580
very naturally from the structure of the

00:05:16,080 --> 00:05:19,380
data that we're working on and this

00:05:17,580 --> 00:05:22,680
allows us to do some pretty powerful

00:05:19,380 --> 00:05:23,910
things like separation of concerns is

00:05:22,680 --> 00:05:25,740
something that we think about when we're

00:05:23,910 --> 00:05:27,750
doing programming just in general right

00:05:25,740 --> 00:05:29,190
this is an important sort of thing that

00:05:27,750 --> 00:05:30,810
we internalize when we're architecting

00:05:29,190 --> 00:05:33,150
software and when you're doing software

00:05:30,810 --> 00:05:35,580
at the type level it's also an important

00:05:33,150 --> 00:05:37,830
property so separation concerns in this

00:05:35,580 --> 00:05:40,849
context means we are allowed to define

00:05:37,830 --> 00:05:45,030
some sort of complex data complex a

00:05:40,849 --> 00:05:46,740
construct at complex structure and we

00:05:45,030 --> 00:05:48,030
can separate the nature of that

00:05:46,740 --> 00:05:49,979
structure from the nature of the

00:05:48,030 --> 00:05:51,990
operations we're performing over it by

00:05:49,979 --> 00:05:54,180
using a context independent function to

00:05:51,990 --> 00:05:55,680
define the structure this is really

00:05:54,180 --> 00:05:58,199
really powerful if we didn't have

00:05:55,680 --> 00:06:00,330
context independent functions anytime we

00:05:58,199 --> 00:06:02,520
defined a complex structure we would

00:06:00,330 --> 00:06:04,500
have to redefine and reprove how to

00:06:02,520 --> 00:06:06,720
decompose that structure in every single

00:06:04,500 --> 00:06:08,280
operation so that's really a pain and

00:06:06,720 --> 00:06:10,260
context independent functions allow us

00:06:08,280 --> 00:06:12,120
to get around that they give us the same

00:06:10,260 --> 00:06:13,949
result regardless of scope no one can

00:06:12,120 --> 00:06:16,080
import something and change what a type

00:06:13,949 --> 00:06:17,400
alias means so that's that's a really

00:06:16,080 --> 00:06:18,840
nice property and the compiler takes

00:06:17,400 --> 00:06:21,900
advantage of that we can take advantage

00:06:18,840 --> 00:06:23,130
of that too it is a type right so this

00:06:21,900 --> 00:06:24,570
there's a pen thing that we had on the

00:06:23,130 --> 00:06:25,740
previous screen it's just a type alias

00:06:24,570 --> 00:06:27,720
you can use it anywhere you can use a

00:06:25,740 --> 00:06:28,919
type whereas implicit switch are the

00:06:27,720 --> 00:06:30,419
other mechanism that you use for

00:06:28,919 --> 00:06:32,669
programming the type system in fact you

00:06:30,419 --> 00:06:34,320
use it most of the time implicit SAR

00:06:32,669 --> 00:06:36,270
tied to function signatures so you don't

00:06:34,320 --> 00:06:38,520
really have that option and as I said

00:06:36,270 --> 00:06:40,229
basically all of this stuff is gone and

00:06:38,520 --> 00:06:42,450
dottie right we still have type aliases

00:06:40,229 --> 00:06:43,150
but we don't have arbitrary sort of

00:06:42,450 --> 00:06:44,800
unbound

00:06:43,150 --> 00:06:47,290
projection because as Martin said that's

00:06:44,800 --> 00:06:49,120
completely unsound so we can't do this

00:06:47,290 --> 00:06:50,560
anymore well we won't be able to do this

00:06:49,120 --> 00:06:55,060
anymore but we can do it now which is

00:06:50,560 --> 00:06:57,280
what matters so make hay while the Sun

00:06:55,060 --> 00:07:00,250
shines there are some limitations here

00:06:57,280 --> 00:07:02,290
and there they're a doozy right context

00:07:00,250 --> 00:07:04,270
independent functions are limited in the

00:07:02,290 --> 00:07:06,040
way that they induct you can only induct

00:07:04,270 --> 00:07:08,500
by open recursion which is that sort of

00:07:06,040 --> 00:07:10,030
like unbounded type projection on the

00:07:08,500 --> 00:07:11,950
the parameter thing that we did in mage

00:07:10,030 --> 00:07:13,420
cons that was super super weird right

00:07:11,950 --> 00:07:15,280
that was like recursion in some sort of

00:07:13,420 --> 00:07:17,560
type alias you'd like that's the only

00:07:15,280 --> 00:07:19,360
mechanism for induction that you have in

00:07:17,560 --> 00:07:20,920
a context independent function you don't

00:07:19,360 --> 00:07:23,830
get branching there's no if then else

00:07:20,920 --> 00:07:25,810
you can't say like oh if this type is a

00:07:23,830 --> 00:07:27,130
string do this one thing you're produced

00:07:25,810 --> 00:07:28,780
this one type otherwise produces other

00:07:27,130 --> 00:07:31,450
thing that's not an option when you're

00:07:28,780 --> 00:07:33,940
just using type aliases and you can't

00:07:31,450 --> 00:07:36,730
pair it with any complex value level

00:07:33,940 --> 00:07:38,500
transformations the append function that

00:07:36,730 --> 00:07:40,390
we had on the preview that we've been

00:07:38,500 --> 00:07:42,250
working with that's paired with a value

00:07:40,390 --> 00:07:45,280
level transformation ie appending to

00:07:42,250 --> 00:07:47,080
sort of lists of consoles together but

00:07:45,280 --> 00:07:49,570
the transformation is really trivial

00:07:47,080 --> 00:07:51,820
it's so trivial that Scala see is able

00:07:49,570 --> 00:07:53,320
to track the equivalencies kind of beat

00:07:51,820 --> 00:07:54,460
at every step of the proof and it

00:07:53,320 --> 00:07:57,640
doesn't lose track of its information

00:07:54,460 --> 00:07:58,780
this is a very rare situation most of

00:07:57,640 --> 00:08:00,190
the time when you're programming at the

00:07:58,780 --> 00:08:01,950
type level and you're doing a type and

00:08:00,190 --> 00:08:04,930
value level transformation in synchrony

00:08:01,950 --> 00:08:06,760
Scala see just loses its mind almost

00:08:04,930 --> 00:08:08,830
immediately and you have to kind of

00:08:06,760 --> 00:08:10,390
prove things very very carefully along

00:08:08,830 --> 00:08:12,190
the way and keep track of that

00:08:10,390 --> 00:08:14,230
information yourself Scala see can't do

00:08:12,190 --> 00:08:15,970
it for you so context independent

00:08:14,230 --> 00:08:17,590
functions are very very limited they're

00:08:15,970 --> 00:08:19,600
very powerful to give us the separation

00:08:17,590 --> 00:08:21,820
of concerns in this way there are nice

00:08:19,600 --> 00:08:24,310
abstraction here but they're really not

00:08:21,820 --> 00:08:26,530
applicable to very many problems now

00:08:24,310 --> 00:08:27,940
type constructors are context

00:08:26,530 --> 00:08:29,260
independent functions these are the type

00:08:27,940 --> 00:08:31,300
level functions that I talked about in

00:08:29,260 --> 00:08:34,270
my talk you know eight years ago type

00:08:31,300 --> 00:08:36,160
classes are the way that we program the

00:08:34,270 --> 00:08:37,660
type system now these are the cool new

00:08:36,160 --> 00:08:40,450
thing but which has been around forever

00:08:37,660 --> 00:08:41,800
and this is the only mechanism that will

00:08:40,450 --> 00:08:43,450
have for programming the type system and

00:08:41,800 --> 00:08:45,940
dotty and they are context-dependent

00:08:43,450 --> 00:08:48,040
functions so contacts independent

00:08:45,940 --> 00:08:49,930
functions are good but they're very very

00:08:48,040 --> 00:08:52,030
very limited because they're basically

00:08:49,930 --> 00:08:53,830
giving us lambda calculus at the type

00:08:52,030 --> 00:08:55,390
level and anyone who knows lambda

00:08:53,830 --> 00:08:56,390
calculus knows that it is Turing

00:08:55,390 --> 00:08:58,370
complete

00:08:56,390 --> 00:09:01,100
god it's going to suck to prove that

00:08:58,370 --> 00:09:03,350
right like you can encode anything you

00:09:01,100 --> 00:09:05,990
want enter it in lambda calculus but you

00:09:03,350 --> 00:09:09,850
don't want to turn complete not Turing

00:09:05,990 --> 00:09:12,590
pleasant context-dependent functions are

00:09:09,850 --> 00:09:14,480
really messy kind of the syntax is a

00:09:12,590 --> 00:09:16,580
little bit arcane you're working kind of

00:09:14,480 --> 00:09:18,970
with this sideways abstraction thing but

00:09:16,580 --> 00:09:21,170
they're way way more powerful and

00:09:18,970 --> 00:09:22,910
ninety-nine percent of the stuff that we

00:09:21,170 --> 00:09:24,350
do with the type system we're going to

00:09:22,910 --> 00:09:26,810
be doing with context-dependent

00:09:24,350 --> 00:09:28,520
functions because rather than encoding

00:09:26,810 --> 00:09:30,410
lambda calculus at the type level they

00:09:28,520 --> 00:09:32,360
give us prologue at the type level and

00:09:30,410 --> 00:09:33,950
everyone who knows prologue knows that

00:09:32,360 --> 00:09:35,570
you know it it's still not the most

00:09:33,950 --> 00:09:37,730
pleasant thing to work with but it's

00:09:35,570 --> 00:09:40,700
traumatically dramatically more pleasant

00:09:37,730 --> 00:09:42,500
than the lambda calculus so in the

00:09:40,700 --> 00:09:44,840
context dependent function we lose some

00:09:42,500 --> 00:09:47,060
flexibility you know we're tied to

00:09:44,840 --> 00:09:49,130
function declarations dadi fixes this

00:09:47,060 --> 00:09:51,740
again but like you know right now we're

00:09:49,130 --> 00:09:53,150
tied to function declarations structural

00:09:51,740 --> 00:09:54,170
decomposition that's you know what I was

00:09:53,150 --> 00:09:56,300
talking about before where you're

00:09:54,170 --> 00:09:57,950
defining the shape of your data that's

00:09:56,300 --> 00:09:59,510
time to be operation you're performing

00:09:57,950 --> 00:10:00,770
with a context-dependent function and

00:09:59,510 --> 00:10:02,510
you have to re-encode it in every

00:10:00,770 --> 00:10:05,030
operation so you're basically stuck with

00:10:02,510 --> 00:10:06,290
really really simple data structures not

00:10:05,030 --> 00:10:09,530
as much of a limitation as you would

00:10:06,290 --> 00:10:11,510
think but still limitation but in

00:10:09,530 --> 00:10:13,910
accepting these limitations we gained

00:10:11,510 --> 00:10:16,310
the ability to express arbitrary proofs

00:10:13,910 --> 00:10:18,400
at the type level we express facts as

00:10:16,310 --> 00:10:20,900
implicit values and then Scala see

00:10:18,400 --> 00:10:23,090
solves this proof for us by sort of

00:10:20,900 --> 00:10:24,830
traversing the exponential search space

00:10:23,090 --> 00:10:27,920
which it takes about as much time as you

00:10:24,830 --> 00:10:30,200
would think and one of the sort of

00:10:27,920 --> 00:10:32,030
random factoids of this is that problems

00:10:30,200 --> 00:10:33,950
like towers of annoy or and queens do I

00:10:32,030 --> 00:10:35,510
like the hello world of prologue like

00:10:33,950 --> 00:10:38,480
those are actually relatively easy to

00:10:35,510 --> 00:10:41,270
express in Skyler's type system so yeah

00:10:38,480 --> 00:10:45,530
all of you who make money solving towers

00:10:41,270 --> 00:10:46,790
of Hanoi just got a new tool so all

00:10:45,530 --> 00:10:48,410
right with all that out of the way in

00:10:46,790 --> 00:10:49,910
this talk we've already looked at a pen

00:10:48,410 --> 00:10:51,110
we're going to look at three more type

00:10:49,910 --> 00:10:54,320
level functions we're going to look at

00:10:51,110 --> 00:10:56,270
remove map and n these are functions

00:10:54,320 --> 00:10:58,040
that we're going to perform on H listen

00:10:56,270 --> 00:10:59,960
10th could could you could also call

00:10:58,040 --> 00:11:02,030
this apply or index or something like

00:10:59,960 --> 00:11:03,560
that or maybe get you know any of those

00:11:02,030 --> 00:11:04,700
would be valid so we're going to look at

00:11:03,560 --> 00:11:08,390
the implementations of all three of

00:11:04,700 --> 00:11:11,570
these functions starting with remove now

00:11:08,390 --> 00:11:14,480
I'll remove on H list is a type index

00:11:11,570 --> 00:11:15,560
deletion function you take an H list you

00:11:14,480 --> 00:11:17,480
take the remove function you give it a

00:11:15,560 --> 00:11:19,490
type and it will remove all instances of

00:11:17,480 --> 00:11:21,440
that type so in this case the result of

00:11:19,490 --> 00:11:24,200
the calling remove int is going to be

00:11:21,440 --> 00:11:26,450
false cons H now if we had more ants in

00:11:24,200 --> 00:11:27,680
here like you know 23 another one

00:11:26,450 --> 00:11:29,240
something like that just sort of

00:11:27,680 --> 00:11:31,820
sprinkled around the result would still

00:11:29,240 --> 00:11:33,920
be false cons H no removes all instance

00:11:31,820 --> 00:11:37,370
of it and if you don't have an intern

00:11:33,920 --> 00:11:38,600
your H list it fails to compile clearly

00:11:37,370 --> 00:11:40,880
this function is going to require a

00:11:38,600 --> 00:11:43,430
context dependence because we're doing

00:11:40,880 --> 00:11:44,930
type equivalency right you know that we

00:11:43,430 --> 00:11:46,370
have to be able to check as to whether

00:11:44,930 --> 00:11:48,290
or not we're looking at the type that we

00:11:46,370 --> 00:11:51,440
asked to remove we're also doing

00:11:48,290 --> 00:11:53,450
non-structural value manipulation so NH

00:11:51,440 --> 00:11:55,280
console is an H console regardless of

00:11:53,450 --> 00:11:56,600
whether or not it has an inter at it

00:11:55,280 --> 00:11:59,690
there's nothing that structurally

00:11:56,600 --> 00:12:01,070
differentiates those two and you know so

00:11:59,690 --> 00:12:03,020
in order to be able to manipulate those

00:12:01,070 --> 00:12:04,970
two things differently we need context

00:12:03,020 --> 00:12:06,590
dependent functions so how are we going

00:12:04,970 --> 00:12:09,140
to implement this what we're going to do

00:12:06,590 --> 00:12:10,600
is we're going to take the the remove

00:12:09,140 --> 00:12:13,370
function and we're going to pull it out

00:12:10,600 --> 00:12:15,680
into an implicit syntax class just like

00:12:13,370 --> 00:12:17,600
we did with the H cons and then we'll

00:12:15,680 --> 00:12:19,430
define a type class that will have the

00:12:17,600 --> 00:12:23,120
implementation this is very very very

00:12:19,430 --> 00:12:24,950
common idiom you take the method and you

00:12:23,120 --> 00:12:26,930
put it in the implicit syntax and then

00:12:24,950 --> 00:12:29,360
all of the definition of the method is

00:12:26,930 --> 00:12:32,720
tied up in the implicit value that you

00:12:29,360 --> 00:12:34,430
get from the type system and think of

00:12:32,720 --> 00:12:35,900
this think of remover which is going to

00:12:34,430 --> 00:12:38,300
have the implementation not as a type

00:12:35,900 --> 00:12:40,430
class in like sort of monad or functor

00:12:38,300 --> 00:12:43,430
think of it like an implicit proof the

00:12:40,430 --> 00:12:45,680
compiler is going to prove to us that it

00:12:43,430 --> 00:12:47,630
can remove a specific type from a

00:12:45,680 --> 00:12:49,700
specific list and in the process of

00:12:47,630 --> 00:12:52,370
generating that proof it will perform

00:12:49,700 --> 00:12:53,480
the removal and now sometimes when

00:12:52,370 --> 00:12:55,190
you're programming at the type level you

00:12:53,480 --> 00:12:57,860
don't actually have values because who

00:12:55,190 --> 00:12:59,780
cares about values so if you're in that

00:12:57,860 --> 00:13:01,610
situation you can actually just do the

00:12:59,780 --> 00:13:03,170
proof alone and you don't have to do the

00:13:01,610 --> 00:13:06,080
value level transformation which is kind

00:13:03,170 --> 00:13:07,520
of fun you end up throwing as instance

00:13:06,080 --> 00:13:10,940
of in there and it's it's really random

00:13:07,520 --> 00:13:13,580
and feels kind of grody so it's less

00:13:10,940 --> 00:13:15,800
syntax all right this is a you know sort

00:13:13,580 --> 00:13:17,210
of boilerplate e right we this is the

00:13:15,800 --> 00:13:19,220
implicit enrichment that we had earlier

00:13:17,210 --> 00:13:20,579
we're adding the remove function to it

00:13:19,220 --> 00:13:23,220
that takes some type parameter

00:13:20,579 --> 00:13:25,529
an implicit remover for a and the

00:13:23,220 --> 00:13:26,819
ageless that we're targeting L and right

00:13:25,529 --> 00:13:28,379
away you'll notice something really

00:13:26,819 --> 00:13:30,749
bizarre here which is that we have this

00:13:28,379 --> 00:13:32,279
r dot out thing this is a feature of

00:13:30,749 --> 00:13:34,670
scholars type system called dependent

00:13:32,279 --> 00:13:37,529
method types and what we're doing is

00:13:34,670 --> 00:13:41,009
we're getting the specific instance of

00:13:37,529 --> 00:13:43,319
the out type member from the our

00:13:41,009 --> 00:13:46,019
instance right so the instance of our

00:13:43,319 --> 00:13:48,119
that was generated by the type system by

00:13:46,019 --> 00:13:49,980
this implicit and passed into this

00:13:48,119 --> 00:13:51,959
function that specific instance of our

00:13:49,980 --> 00:13:54,959
has it out on it we're getting that out

00:13:51,959 --> 00:13:56,699
and that's the type that we return so

00:13:54,959 --> 00:13:58,589
the definition of remover of course has

00:13:56,699 --> 00:13:59,970
this out type that we talked about I

00:13:58,589 --> 00:14:02,519
mean it has the apply that we were

00:13:59,970 --> 00:14:04,649
calling within the body and and this is

00:14:02,519 --> 00:14:06,569
this is basically the structure of it we

00:14:04,649 --> 00:14:08,399
also whenever we're using these out

00:14:06,569 --> 00:14:11,160
member types these dependent output

00:14:08,399 --> 00:14:12,629
types we we generally have an aux type

00:14:11,160 --> 00:14:14,129
on the companion object that's what you

00:14:12,629 --> 00:14:16,019
see at the bottom here if you see this

00:14:14,129 --> 00:14:17,429
an age in shapeless this is what this

00:14:16,019 --> 00:14:18,619
means this is one of those patterns that

00:14:17,429 --> 00:14:21,299
you can kind of have in your mind

00:14:18,619 --> 00:14:22,709
because it's really really useful to be

00:14:21,299 --> 00:14:25,499
able to take this dependent output type

00:14:22,709 --> 00:14:27,989
and sort of lift it back into you know

00:14:25,499 --> 00:14:29,669
sort of a type parameter position that's

00:14:27,989 --> 00:14:31,439
a little bit easier to work with and it

00:14:29,669 --> 00:14:33,779
makes some of the definition sites a

00:14:31,439 --> 00:14:35,610
little bit less syntactically verbose so

00:14:33,779 --> 00:14:37,709
of course the obvious question is why

00:14:35,610 --> 00:14:39,209
are we using a dependent output type

00:14:37,709 --> 00:14:41,100
rather than just having a third type

00:14:39,209 --> 00:14:43,980
parameter on remover well that's an

00:14:41,100 --> 00:14:45,839
excellent question so with type

00:14:43,980 --> 00:14:49,259
parameters and type parameters

00:14:45,839 --> 00:14:51,869
specifically on the implicit the

00:14:49,259 --> 00:14:54,509
implicit sort of fact sites the compiler

00:14:51,869 --> 00:14:56,369
has to solve all of the type parameters

00:14:54,509 --> 00:14:58,230
right it basically has to take every

00:14:56,369 --> 00:15:00,119
type parameter and put it into a fact

00:14:58,230 --> 00:15:02,850
set and then find a solution which

00:15:00,119 --> 00:15:05,579
manages all of those constraints so a

00:15:02,850 --> 00:15:06,929
like really in the case of remove right

00:15:05,579 --> 00:15:09,029
this is kind of a trivial example so

00:15:06,929 --> 00:15:12,029
with remove we're actually specifying

00:15:09,029 --> 00:15:13,470
what we want a to be an int right but in

00:15:12,029 --> 00:15:14,999
the general case the compiler is going

00:15:13,470 --> 00:15:17,339
to have to solve this stuff and so a

00:15:14,999 --> 00:15:19,079
becomes part of a fact set that the

00:15:17,339 --> 00:15:21,059
compiler is trying to solve and it's

00:15:19,079 --> 00:15:22,919
going to solve it more or less from left

00:15:21,059 --> 00:15:24,239
to right there are some exceptions to

00:15:22,919 --> 00:15:25,470
this but it basically just drills

00:15:24,239 --> 00:15:29,699
through the parameter list and kind of

00:15:25,470 --> 00:15:31,980
goes in that direction and the problem

00:15:29,699 --> 00:15:34,259
is that partially due to bugs in Scala

00:15:31,980 --> 00:15:34,410
see some types can't actually be solved

00:15:34,259 --> 00:15:37,680
like

00:15:34,410 --> 00:15:39,690
this some of this is kind of due to the

00:15:37,680 --> 00:15:42,629
infamous SI 2712 which is of course

00:15:39,690 --> 00:15:44,610
fixed now some of it is due to various

00:15:42,629 --> 00:15:46,829
other d aliasing things but basically as

00:15:44,610 --> 00:15:49,709
a general rule scala see can't do it all

00:15:46,829 --> 00:15:51,480
the time dependent method dependent type

00:15:49,709 --> 00:15:53,040
members are done a little bit

00:15:51,480 --> 00:15:55,050
differently they don't go through the

00:15:53,040 --> 00:15:56,730
same d aliasing steps and so i think of

00:15:55,050 --> 00:15:58,110
them as being computed rather than

00:15:56,730 --> 00:16:00,930
solved that's not a completely accurate

00:15:58,110 --> 00:16:02,879
metaphor but it's close enough and it's

00:16:00,930 --> 00:16:04,500
basically follows what we want to do

00:16:02,879 --> 00:16:07,589
here right so whenever we want to

00:16:04,500 --> 00:16:09,810
produce a result from an implicit

00:16:07,589 --> 00:16:11,550
computation normally you want to stick

00:16:09,810 --> 00:16:13,620
that result in a dependent output type

00:16:11,550 --> 00:16:15,600
rather than an additional type parameter

00:16:13,620 --> 00:16:18,149
this is again one of those patterns for

00:16:15,600 --> 00:16:19,889
programming the type system now when you

00:16:18,149 --> 00:16:21,750
do this you do except a few limitations

00:16:19,889 --> 00:16:23,750
and those limitations are precisely why

00:16:21,750 --> 00:16:26,040
the compiler is able to do what it does

00:16:23,750 --> 00:16:27,990
the most notable of them is that you

00:16:26,040 --> 00:16:30,240
can't actually use it in a computational

00:16:27,990 --> 00:16:33,480
continuation what I mean by that is you

00:16:30,240 --> 00:16:36,120
can't derive new implicit from this

00:16:33,480 --> 00:16:38,160
output type right so the out type on

00:16:36,120 --> 00:16:40,620
remover like you can't take that and go

00:16:38,160 --> 00:16:42,630
find a new implicit that uses it as a as

00:16:40,620 --> 00:16:45,060
a parameter unless you use the aux type

00:16:42,630 --> 00:16:46,589
ok so the aux type is basically why we

00:16:45,060 --> 00:16:48,389
have this but again the aux type then

00:16:46,589 --> 00:16:50,699
kind of goes back into you know sort of

00:16:48,389 --> 00:16:51,870
D aliasing weirdness land so you know

00:16:50,699 --> 00:16:53,639
you give up some of those benefits

00:16:51,870 --> 00:16:56,610
whenever you do it multiple implicit

00:16:53,639 --> 00:16:58,740
blocks which dotty is getting do solve

00:16:56,610 --> 00:17:01,620
this problem so dotty is kind of the

00:16:58,740 --> 00:17:04,289
promised land but we don't have them yet

00:17:01,620 --> 00:17:06,179
and so because we don't have them yet we

00:17:04,289 --> 00:17:07,980
have to accept these limitations you can

00:17:06,179 --> 00:17:09,600
also do something miles calls

00:17:07,980 --> 00:17:12,380
continuation passing at the type level

00:17:09,600 --> 00:17:15,089
this is exactly as insane as it sounds

00:17:12,380 --> 00:17:17,730
but if you're if you're familiar with

00:17:15,089 --> 00:17:19,289
scholars ads or Katz's unapplied type

00:17:17,730 --> 00:17:21,179
class that's basically what it's doing

00:17:19,289 --> 00:17:22,770
we're not going to go really into this

00:17:21,179 --> 00:17:24,929
but just kind of know that you know if

00:17:22,770 --> 00:17:26,130
you hit this limitation there are some

00:17:24,929 --> 00:17:29,640
support groups out there that you can

00:17:26,130 --> 00:17:30,659
talk to remove our ok how are we going

00:17:29,640 --> 00:17:32,429
to implement this we're going to break

00:17:30,659 --> 00:17:33,720
it up into three different cases and

00:17:32,429 --> 00:17:34,890
this basically mirrors how you would

00:17:33,720 --> 00:17:36,390
implement this function if you were

00:17:34,890 --> 00:17:38,940
implementing it at the value level we

00:17:36,390 --> 00:17:41,370
have a base case which is the right most

00:17:38,940 --> 00:17:42,929
instance of the type to remove so in

00:17:41,370 --> 00:17:44,669
other words if you sort of deconstruct

00:17:42,929 --> 00:17:46,590
the list it's the very very last

00:17:44,669 --> 00:17:47,940
instance of that type we're going to

00:17:46,590 --> 00:17:50,070
have an inductive rebuild

00:17:47,940 --> 00:17:51,360
old case which is not matching the type

00:17:50,070 --> 00:17:53,159
that we preserve so in other words we

00:17:51,360 --> 00:17:54,299
found a type to remove we removed it now

00:17:53,159 --> 00:17:56,669
we're putting the list back together

00:17:54,299 --> 00:17:58,440
again and we're passing over types that

00:17:56,669 --> 00:17:59,669
we you know sort of don't care about

00:17:58,440 --> 00:18:01,169
right types that we just want to put

00:17:59,669 --> 00:18:02,850
back at the list and we're going to have

00:18:01,169 --> 00:18:04,289
an inductive remove case which is where

00:18:02,850 --> 00:18:06,360
we're putting the list back together and

00:18:04,289 --> 00:18:08,220
we're passing over types that we do care

00:18:06,360 --> 00:18:10,320
about types of additional instances of

00:18:08,220 --> 00:18:12,809
the type to remove so we pull them out

00:18:10,320 --> 00:18:14,700
of the list and if you notice there's

00:18:12,809 --> 00:18:17,220
actually an ambiguity here right between

00:18:14,700 --> 00:18:20,340
the base case which is you know remove

00:18:17,220 --> 00:18:22,080
the rightmost thing and the inductive

00:18:20,340 --> 00:18:24,000
case the inductive remove you sort of

00:18:22,080 --> 00:18:25,950
remove remove the thing once we've

00:18:24,000 --> 00:18:27,210
already removed a thing this is an

00:18:25,950 --> 00:18:29,309
ambiguity that we're going to have to

00:18:27,210 --> 00:18:31,139
teach the compiler how to solve and to

00:18:29,309 --> 00:18:35,100
do that we're going to use implicit

00:18:31,139 --> 00:18:37,019
prioritization so when Skala see looks

00:18:35,100 --> 00:18:38,730
for implicit one of the places it looks

00:18:37,019 --> 00:18:40,909
is the companion object of the type

00:18:38,730 --> 00:18:43,080
class that it's looking for and

00:18:40,909 --> 00:18:45,090
specifically it will look first at the

00:18:43,080 --> 00:18:47,279
companion object then it will look at

00:18:45,090 --> 00:18:49,169
the super type of the companion object

00:18:47,279 --> 00:18:52,139
then the super type of the supertype and

00:18:49,169 --> 00:18:53,370
so on and so on until it hits any this

00:18:52,139 --> 00:18:55,620
is actually really really powerful

00:18:53,370 --> 00:18:57,000
because it allows you to do because you

00:18:55,620 --> 00:19:00,419
know that it's going to go in that order

00:18:57,000 --> 00:19:03,659
you can put more specific implicit types

00:19:00,419 --> 00:19:05,549
implicit facts in the subtype ie in the

00:19:03,659 --> 00:19:07,980
companion object itself and less

00:19:05,549 --> 00:19:10,710
specific more general fallback cases in

00:19:07,980 --> 00:19:12,179
the supertype and this allows you to

00:19:10,710 --> 00:19:14,129
kind of arrange things and deal with

00:19:12,179 --> 00:19:17,700
these ambiguities so in this case we're

00:19:14,129 --> 00:19:20,190
going to put the the base case in a low

00:19:17,700 --> 00:19:21,990
priority implicit straight and you

00:19:20,190 --> 00:19:23,610
notice there's no this base case doesn't

00:19:21,990 --> 00:19:24,960
take any implicit parameters which is

00:19:23,610 --> 00:19:27,210
your hint that you know there's no

00:19:24,960 --> 00:19:30,779
constraints here right it applies to any

00:19:27,210 --> 00:19:32,700
any type a and any type a that's at the

00:19:30,779 --> 00:19:34,379
head of the H list right that's that's

00:19:32,700 --> 00:19:37,259
basically the only constraints that it

00:19:34,379 --> 00:19:39,600
has so this is the more general fall

00:19:37,259 --> 00:19:42,690
back case and the more specific case the

00:19:39,600 --> 00:19:44,789
recursive removed case hat is it looks

00:19:42,690 --> 00:19:47,549
basically the same we got an eight and a

00:19:44,789 --> 00:19:49,440
thatthat's at the head of the list but

00:19:47,549 --> 00:19:51,629
we additionally take this implicit

00:19:49,440 --> 00:19:53,909
parameter that is well somewhere in that

00:19:51,629 --> 00:19:56,279
list we also removed so we removed

00:19:53,909 --> 00:19:58,129
another type so this is the more

00:19:56,279 --> 00:20:01,259
specific case we put it in the subtype

00:19:58,129 --> 00:20:01,770
and you notice what we're doing here

00:20:01,259 --> 00:20:03,630
this this

00:20:01,770 --> 00:20:05,100
sort of definition here right this is

00:20:03,630 --> 00:20:06,180
that when you when you're reading these

00:20:05,100 --> 00:20:08,310
type signatures when you're reading

00:20:06,180 --> 00:20:10,320
these implicit your eyes should always

00:20:08,310 --> 00:20:12,150
be drawn to the return type because the

00:20:10,320 --> 00:20:14,280
return type is going to tell you how to

00:20:12,150 --> 00:20:15,930
interpret this fact how to interpret the

00:20:14,280 --> 00:20:17,880
structure of this fact so we're saying

00:20:15,930 --> 00:20:21,330
here is we're declaring a remover for

00:20:17,880 --> 00:20:23,730
type a on some list that starts with

00:20:21,330 --> 00:20:27,420
type A and has a tail that's l and in

00:20:23,730 --> 00:20:30,150
the return type the return result is the

00:20:27,420 --> 00:20:31,860
output of you're removing from the tail

00:20:30,150 --> 00:20:33,450
which is what you would expect right if

00:20:31,860 --> 00:20:35,190
you're trying to remove some element and

00:20:33,450 --> 00:20:36,480
you find it in the list you remove it

00:20:35,190 --> 00:20:38,760
from the list and then you remove it

00:20:36,480 --> 00:20:41,970
from the tail and the return result is

00:20:38,760 --> 00:20:43,830
the remove from the tail the third case

00:20:41,970 --> 00:20:46,020
that we have is the recursive rebuild

00:20:43,830 --> 00:20:47,550
where we have two types a and B a is the

00:20:46,020 --> 00:20:49,650
type of removing B is the type that's at

00:20:47,550 --> 00:20:51,840
the head of the list and when we do the

00:20:49,650 --> 00:20:53,700
removal we just have to put be back onto

00:20:51,840 --> 00:20:56,220
that list right so this is again draw

00:20:53,700 --> 00:20:56,940
your eye to the output type and for

00:20:56,220 --> 00:20:58,230
those of you who've been reading the

00:20:56,940 --> 00:20:59,790
value level you notice that we actually

00:20:58,230 --> 00:21:01,440
did do that implementation there but

00:20:59,790 --> 00:21:02,430
again no one cares about the value level

00:21:01,440 --> 00:21:06,270
it's not that we're paid to do that

00:21:02,430 --> 00:21:08,130
stuff for anything so so this is this is

00:21:06,270 --> 00:21:10,410
basically remover this is all there is

00:21:08,130 --> 00:21:12,360
to it and believe it or not this is the

00:21:10,410 --> 00:21:13,700
most complicated type level function

00:21:12,360 --> 00:21:16,890
that we will be seeing today

00:21:13,700 --> 00:21:18,900
congratulations and everything else we

00:21:16,890 --> 00:21:20,460
do today will actually be simpler which

00:21:18,900 --> 00:21:21,720
is really really cool and kind of

00:21:20,460 --> 00:21:22,890
indicative of what's going on because

00:21:21,720 --> 00:21:24,630
when you start doing this stuff

00:21:22,890 --> 00:21:26,520
programming the type system you actually

00:21:24,630 --> 00:21:28,590
realize that it's a lot easier than

00:21:26,520 --> 00:21:30,930
everybody kind of made it out to sound

00:21:28,590 --> 00:21:33,450
you kind of do it and then it works and

00:21:30,930 --> 00:21:37,140
you're like really that's it this is

00:21:33,450 --> 00:21:39,060
this is it so uh so we can move on to

00:21:37,140 --> 00:21:42,390
two functions that sound cooler but are

00:21:39,060 --> 00:21:44,340
actually much much simpler like map now

00:21:42,390 --> 00:21:46,560
map is a map as an interesting function

00:21:44,340 --> 00:21:47,940
because whenever I talk to people you're

00:21:46,560 --> 00:21:50,850
right conferences or meet ups or things

00:21:47,940 --> 00:21:53,190
about about shapeless the invariably

00:21:50,850 --> 00:21:55,950
they will ask me how does H list have

00:21:53,190 --> 00:21:58,080
map like how is it even possible for

00:21:55,950 --> 00:21:59,700
that function to exist and you know it's

00:21:58,080 --> 00:22:01,080
a good question and the confusion is

00:21:59,700 --> 00:22:02,760
really obvious because if we look at

00:22:01,080 --> 00:22:06,060
functor which is sort of the defining

00:22:02,760 --> 00:22:07,680
type class for the map operation you'll

00:22:06,060 --> 00:22:10,020
we take a type constructor f of a and

00:22:07,680 --> 00:22:13,800
add a function from A to B and we return

00:22:10,020 --> 00:22:15,240
a type constructor f of B really really

00:22:13,800 --> 00:22:17,550
straightforward stuff but

00:22:15,240 --> 00:22:19,890
when you have an H list there's an

00:22:17,550 --> 00:22:23,610
obvious problem and that problem is what

00:22:19,890 --> 00:22:25,440
is a right H list has many many a is

00:22:23,610 --> 00:22:27,360
inside of it like how do you how do you

00:22:25,440 --> 00:22:28,620
answer this question like what is a what

00:22:27,360 --> 00:22:31,800
do you substitute in here is it going to

00:22:28,620 --> 00:22:34,830
be any I hope not like when here what do

00:22:31,800 --> 00:22:37,440
you do so so this is a really really

00:22:34,830 --> 00:22:38,610
obvious conundrum so we have to solve

00:22:37,440 --> 00:22:40,530
this problem if we want to implement

00:22:38,610 --> 00:22:42,600
math by an H list we have to find a way

00:22:40,530 --> 00:22:45,840
of encoding a function that can take

00:22:42,600 --> 00:22:48,000
many different sorts of a's and return

00:22:45,840 --> 00:22:50,250
potentially many different sorts of bees

00:22:48,000 --> 00:22:52,860
and it has to choose which

00:22:50,250 --> 00:22:55,320
implementation it's going for based on

00:22:52,860 --> 00:22:57,870
the type that it's given so if we can

00:22:55,320 --> 00:22:59,880
define this construct that is basically

00:22:57,870 --> 00:23:02,210
sort of fundamentally a set of functions

00:22:59,880 --> 00:23:04,230
indexed by type and we choose the

00:23:02,210 --> 00:23:06,210
implementation of this function the body

00:23:04,230 --> 00:23:08,250
of the function effectively based on the

00:23:06,210 --> 00:23:10,080
type that we are applying to we make

00:23:08,250 --> 00:23:11,340
this choice at compile time you know we

00:23:10,080 --> 00:23:14,160
don't want to be throwing match error

00:23:11,340 --> 00:23:16,290
like you know doing ugly runtime things

00:23:14,160 --> 00:23:17,400
lack like we don't want to do any of

00:23:16,290 --> 00:23:20,280
that stuff right we want to do this at

00:23:17,400 --> 00:23:22,470
compile time and if we don't have a case

00:23:20,280 --> 00:23:24,990
for a particular type we want to just

00:23:22,470 --> 00:23:27,150
have a compile error you know we want it

00:23:24,990 --> 00:23:29,309
to we want that to blow up so if we

00:23:27,150 --> 00:23:30,690
could build this construct that in

00:23:29,309 --> 00:23:32,220
theory we could implement map right

00:23:30,690 --> 00:23:34,740
because the hard thing about H list map

00:23:32,220 --> 00:23:36,690
is literally the function so this would

00:23:34,740 --> 00:23:39,000
be the function so how do we do this how

00:23:36,690 --> 00:23:40,440
is this possible well as with most

00:23:39,000 --> 00:23:43,830
things in programming the type system

00:23:40,440 --> 00:23:45,840
the answer comes down to implicit so

00:23:43,830 --> 00:23:47,670
remember I said earlier that implicit

00:23:45,840 --> 00:23:49,440
search considers the companions and

00:23:47,670 --> 00:23:52,320
specifically it considers the companions

00:23:49,440 --> 00:23:54,929
for all component types so for example

00:23:52,320 --> 00:23:56,250
if you're looking for a remover it will

00:23:54,929 --> 00:23:57,870
consider the companion object for

00:23:56,250 --> 00:23:59,640
remover and if you're looking for a list

00:23:57,870 --> 00:24:01,020
of remover it will also consider the

00:23:59,640 --> 00:24:02,460
companion object for remover which is

00:24:01,020 --> 00:24:04,760
really weird but the collections library

00:24:02,460 --> 00:24:07,500
actually needs that functionality now

00:24:04,760 --> 00:24:10,200
classes have companion objects right and

00:24:07,500 --> 00:24:13,530
objects are singleton instances of other

00:24:10,200 --> 00:24:15,750
classes right this is Scala 101 so this

00:24:13,530 --> 00:24:17,460
raises a really obvious question that is

00:24:15,750 --> 00:24:20,070
so obvious that I didn't think of it for

00:24:17,460 --> 00:24:25,200
like 10 years what is the companion

00:24:20,070 --> 00:24:28,100
object for an object's class the answer

00:24:25,200 --> 00:24:31,770
is the object itself

00:24:28,100 --> 00:24:33,990
that's weird objects are like kind of

00:24:31,770 --> 00:24:36,510
this weird meta circular thing they are

00:24:33,990 --> 00:24:38,940
their own companion which is really

00:24:36,510 --> 00:24:41,070
really bizarre and we could totally take

00:24:38,940 --> 00:24:43,740
advantage of that so what we're going to

00:24:41,070 --> 00:24:45,990
do is we're going to have the object the

00:24:43,740 --> 00:24:48,000
object self type so that the type of the

00:24:45,990 --> 00:24:50,520
class that is the object sort of

00:24:48,000 --> 00:24:51,810
instance of the object self-type will be

00:24:50,520 --> 00:24:53,520
a component of the type that we're

00:24:51,810 --> 00:24:56,670
trying to look up and the object will

00:24:53,520 --> 00:24:58,620
contain an implicit case for each type

00:24:56,670 --> 00:25:00,690
that we're trying to index are our

00:24:58,620 --> 00:25:02,430
polymorphic function on and when we

00:25:00,690 --> 00:25:04,320
apply our polymorphic function will look

00:25:02,430 --> 00:25:06,270
up that particular case based on the

00:25:04,320 --> 00:25:08,970
inferred type at the application site

00:25:06,270 --> 00:25:11,220
it's easy to give a compiler when we

00:25:08,970 --> 00:25:13,740
don't find the type in question it's

00:25:11,220 --> 00:25:15,540
simply implicit not found right and we

00:25:13,740 --> 00:25:17,400
can even annotate with ADD implicit not

00:25:15,540 --> 00:25:18,870
found and give our users a nice error

00:25:17,400 --> 00:25:20,160
message that says don't apply the

00:25:18,870 --> 00:25:22,530
function to something that we don't have

00:25:20,160 --> 00:25:24,180
a case for so we can we can kind of make

00:25:22,530 --> 00:25:26,280
this really nice to work with it's very

00:25:24,180 --> 00:25:27,750
easy to have polymorphic functions that

00:25:26,280 --> 00:25:30,330
can be applied to many different types

00:25:27,750 --> 00:25:32,700
all you say is like implicit def you

00:25:30,330 --> 00:25:34,440
know foo for some type a and then you

00:25:32,700 --> 00:25:37,800
know now your polymorphic on all types a

00:25:34,440 --> 00:25:40,680
pretty great right and very very very

00:25:37,800 --> 00:25:42,420
good syntax and type inference I can't

00:25:40,680 --> 00:25:44,550
stress enough how important this point

00:25:42,420 --> 00:25:47,580
is if you come up with some crazy

00:25:44,550 --> 00:25:49,410
kitschy idea for like here's some trick

00:25:47,580 --> 00:25:51,540
that I can do with the sky language that

00:25:49,410 --> 00:25:53,670
programs the type system but if users

00:25:51,540 --> 00:25:56,720
have to write down types that are like

00:25:53,670 --> 00:25:59,580
six pages long no one will ever use it

00:25:56,720 --> 00:26:01,560
like if it's really unpleasant no one

00:25:59,580 --> 00:26:03,900
will touch it so it's really important

00:26:01,560 --> 00:26:05,550
that you consider what is the syntax one

00:26:03,900 --> 00:26:08,070
is the type inference if you can't make

00:26:05,550 --> 00:26:09,990
both of those good then it's you're just

00:26:08,070 --> 00:26:11,400
wasting your time so this has really

00:26:09,990 --> 00:26:14,160
good syntax and really good type

00:26:11,400 --> 00:26:15,660
inference and it looks like this so here

00:26:14,160 --> 00:26:17,490
we're defining a polymorphic function

00:26:15,660 --> 00:26:20,310
called square that has three different

00:26:17,490 --> 00:26:21,930
cases 14 in 14 float 14 double and it's

00:26:20,310 --> 00:26:23,910
just going to multiply the numbers by

00:26:21,930 --> 00:26:26,190
themselves and return the specific type

00:26:23,910 --> 00:26:28,320
so if we apply it to an int it returns

00:26:26,190 --> 00:26:30,870
an int we brought apply it to a double

00:26:28,320 --> 00:26:33,960
it returns a double if we apply it to a

00:26:30,870 --> 00:26:38,340
string it does not compile because we

00:26:33,960 --> 00:26:39,720
didn't define a case for string right so

00:26:38,340 --> 00:26:41,280
this is this is basically the

00:26:39,720 --> 00:26:43,020
polymorphic function contacts

00:26:41,280 --> 00:26:44,970
I mean this is not the most concise

00:26:43,020 --> 00:26:47,490
thing but I think it's pretty good and

00:26:44,970 --> 00:26:50,430
clearly like at the call site that the

00:26:47,490 --> 00:26:52,020
the syntax for it is excellent so how do

00:26:50,430 --> 00:26:55,080
we define this when we're going to start

00:26:52,020 --> 00:26:56,660
off with a poly trait poly is going to

00:26:55,080 --> 00:26:59,820
be a trait and it's going to have a

00:26:56,660 --> 00:27:01,260
inner type called case which has to type

00:26:59,820 --> 00:27:03,030
parameters a and B this is at the bottom

00:27:01,260 --> 00:27:04,230
here and it has an apply method that

00:27:03,030 --> 00:27:06,360
takes an A and returns to be this is

00:27:04,230 --> 00:27:07,860
literally function one but it's it's

00:27:06,360 --> 00:27:10,290
it's a different function one it's our

00:27:07,860 --> 00:27:12,690
function one and critically it's an

00:27:10,290 --> 00:27:15,510
inner class of poly that's actually very

00:27:12,690 --> 00:27:17,760
very important we're going to have this

00:27:15,510 --> 00:27:20,010
at function which is how we define cases

00:27:17,760 --> 00:27:23,130
and it takes a type parameter a and then

00:27:20,010 --> 00:27:24,750
returns a new type which has an apply

00:27:23,130 --> 00:27:26,490
method that takes time parameter B if

00:27:24,750 --> 00:27:29,610
you're not familiar with this new curly

00:27:26,490 --> 00:27:32,790
brace syntax good keep it that way this

00:27:29,610 --> 00:27:35,730
syntax is very slide optimized it turns

00:27:32,790 --> 00:27:36,720
into reflection at at a run time so you

00:27:35,730 --> 00:27:39,240
definitely don't want to do this in

00:27:36,720 --> 00:27:40,680
production but I'm just doing it to kind

00:27:39,240 --> 00:27:42,480
of fit things out of side you don't have

00:27:40,680 --> 00:27:44,400
to use that syntax basically it just

00:27:42,480 --> 00:27:46,830
means return a new anonymous inner class

00:27:44,400 --> 00:27:48,900
and I'm doing this sort of hide the

00:27:46,830 --> 00:27:50,970
apply method inside of there just so

00:27:48,900 --> 00:27:53,490
that I can make it so that users specify

00:27:50,970 --> 00:27:55,860
only type a if I didn't do this they

00:27:53,490 --> 00:27:56,940
would have to specify type A and type B

00:27:55,860 --> 00:27:59,940
and I don't want them to have to do that

00:27:56,940 --> 00:28:03,420
remember syntax is important supply

00:27:59,940 --> 00:28:04,830
taipei infer type B and the apply method

00:28:03,420 --> 00:28:07,110
just takes the function which is the

00:28:04,830 --> 00:28:10,200
body of this particular case wraps it up

00:28:07,110 --> 00:28:13,020
inside of a case and returns it so when

00:28:10,200 --> 00:28:15,120
someone says at int and then lambda you

00:28:13,020 --> 00:28:17,220
know sort of I blah blah blah blah that

00:28:15,120 --> 00:28:19,830
is actually going to be of type case int

00:28:17,220 --> 00:28:21,900
to end and then we define the implicit

00:28:19,830 --> 00:28:23,430
operator so that the type system can

00:28:21,900 --> 00:28:27,060
find it later which we'll get to in a

00:28:23,430 --> 00:28:29,700
second so the question is how do we

00:28:27,060 --> 00:28:32,190
define the application site right how do

00:28:29,700 --> 00:28:33,690
we apply this polymorphic function this

00:28:32,190 --> 00:28:35,040
is this is how we define it how do we

00:28:33,690 --> 00:28:37,560
apply it well that's actually very

00:28:35,040 --> 00:28:39,270
straightforward poly is going to have an

00:28:37,560 --> 00:28:42,560
apply method that takes to type

00:28:39,270 --> 00:28:45,360
parameters a and B and it infers the a

00:28:42,560 --> 00:28:47,730
from from the type of the thing that

00:28:45,360 --> 00:28:50,070
we're applying the function to and then

00:28:47,730 --> 00:28:52,260
the B it's going to go off into the

00:28:50,070 --> 00:28:54,460
implicit scope and find something of

00:28:52,260 --> 00:28:57,310
type this dot k

00:28:54,460 --> 00:29:00,430
this is really really important this dot

00:28:57,310 --> 00:29:03,520
case now this is a component of the type

00:29:00,430 --> 00:29:05,320
and in our previous example this is

00:29:03,520 --> 00:29:07,780
going to be instantiated with square

00:29:05,320 --> 00:29:10,930
type and the companion of square type is

00:29:07,780 --> 00:29:13,150
simply square so the compiler will look

00:29:10,930 --> 00:29:15,010
in square to see if it could find a case

00:29:13,150 --> 00:29:18,040
for the type a that we apply to

00:29:15,010 --> 00:29:21,250
producing some type B and it finds it it

00:29:18,040 --> 00:29:23,470
will allow us to apply it so that allows

00:29:21,250 --> 00:29:25,990
this to work which is really really cool

00:29:23,470 --> 00:29:27,700
we now have a polymorphic function we

00:29:25,990 --> 00:29:30,610
can use this to do a lot of crazy things

00:29:27,700 --> 00:29:33,760
like emulate JavaScript's you know

00:29:30,610 --> 00:29:38,080
addition semantics which is exactly what

00:29:33,760 --> 00:29:40,390
everyone wants but aside from trolling

00:29:38,080 --> 00:29:43,360
your co-workers this is this does have a

00:29:40,390 --> 00:29:46,420
few other downsides notably you can't

00:29:43,360 --> 00:29:48,100
parameterize these functions right so

00:29:46,420 --> 00:29:49,960
remember in that previous slide where we

00:29:48,100 --> 00:29:52,150
were emulating JavaScript that that

00:29:49,960 --> 00:29:54,340
function was called add one it wasn't

00:29:52,150 --> 00:29:58,180
called a den it took we couldn't take a

00:29:54,340 --> 00:29:59,650
parameter this is not as much of a

00:29:58,180 --> 00:30:03,280
limitation as you would think in

00:29:59,650 --> 00:30:04,690
practice but it is slightly annoying now

00:30:03,280 --> 00:30:05,800
and again so it's just just something to

00:30:04,690 --> 00:30:08,770
think about it's a limitation of the

00:30:05,800 --> 00:30:10,000
encoding a more annoying limitation for

00:30:08,770 --> 00:30:13,600
me is that we don't have an anonymous

00:30:10,000 --> 00:30:16,330
syntax right effectively we have def we

00:30:13,600 --> 00:30:20,200
do not have lambda because there's no

00:30:16,330 --> 00:30:21,310
anonymous objects so that's that's a

00:30:20,200 --> 00:30:23,200
little bit more annoying it just means

00:30:21,310 --> 00:30:24,730
your code is more verbose it's hard to

00:30:23,200 --> 00:30:26,110
pass things these things around as a

00:30:24,730 --> 00:30:28,150
value because you have to kind of

00:30:26,110 --> 00:30:30,310
capture the precise type and we've been

00:30:28,150 --> 00:30:32,860
doing that all along with our sort of H

00:30:30,310 --> 00:30:34,960
list syntax thing the L extends H list

00:30:32,860 --> 00:30:37,150
that's the getting the precise type but

00:30:34,960 --> 00:30:38,890
it's a little weird so like remember

00:30:37,150 --> 00:30:40,330
syntax is important inference is

00:30:38,890 --> 00:30:42,400
important these are things that affect

00:30:40,330 --> 00:30:43,660
syntax and inference so just like keep

00:30:42,400 --> 00:30:45,760
in mind that there are some trade-offs

00:30:43,660 --> 00:30:47,470
at us so if someone can find like some

00:30:45,760 --> 00:30:49,180
sort of magically clever polymorphic

00:30:47,470 --> 00:30:51,190
function and coding that that solves

00:30:49,180 --> 00:30:52,690
these problems without sort of trading

00:30:51,190 --> 00:30:56,890
off other things that would be really

00:30:52,690 --> 00:30:57,850
great go talk to miles as an exercise if

00:30:56,890 --> 00:30:59,830
you're interested in those sorts of

00:30:57,850 --> 00:31:02,230
things you can implement the sort of

00:30:59,830 --> 00:31:04,660
function composition on polymorphic

00:31:02,230 --> 00:31:06,730
functions and also Union which sort of

00:31:04,660 --> 00:31:07,990
takes the set of cases from one side on

00:31:06,730 --> 00:31:10,150
the set of cases for the other side

00:31:07,990 --> 00:31:11,890
turns a poly that has both sets of cases

00:31:10,150 --> 00:31:13,150
Union together these are very very

00:31:11,890 --> 00:31:14,530
straightforward functions to implement

00:31:13,150 --> 00:31:16,809
they teach you a lot about type level

00:31:14,530 --> 00:31:19,450
programming when you do them so yeah

00:31:16,809 --> 00:31:21,370
stuff to do at home later so anyway

00:31:19,450 --> 00:31:22,809
we've got Polly and I made the claim

00:31:21,370 --> 00:31:25,480
that we could use this to implement map

00:31:22,809 --> 00:31:28,000
so let's see how that works hls syntax

00:31:25,480 --> 00:31:31,330
is going to define our map method and

00:31:28,000 --> 00:31:32,290
we'll have a p extends Polly and then

00:31:31,330 --> 00:31:34,300
we're going to look up some implicit

00:31:32,290 --> 00:31:35,890
proof called mapper that for this

00:31:34,300 --> 00:31:38,950
particular polymorphic function we can

00:31:35,890 --> 00:31:40,480
nap over the list basically the

00:31:38,950 --> 00:31:42,120
boilerplate that we had for remove but

00:31:40,480 --> 00:31:44,890
with a different type little proof

00:31:42,120 --> 00:31:46,660
mappers definition is almost exactly the

00:31:44,890 --> 00:31:48,280
same as remover this is a really common

00:31:46,660 --> 00:31:49,360
theme by the way almost all of your type

00:31:48,280 --> 00:31:52,120
level proofs are going to look like this

00:31:49,360 --> 00:31:53,620
in some way shape or form so what about

00:31:52,120 --> 00:31:56,080
the definition what are the cases well

00:31:53,620 --> 00:31:57,670
like I said it's simpler than remove we

00:31:56,080 --> 00:31:59,230
have a base case which is simply mapping

00:31:57,670 --> 00:32:00,640
over the empty list and it doesn't

00:31:59,230 --> 00:32:02,380
there's no restrictions on this right

00:32:00,640 --> 00:32:03,910
regardless of what function you map over

00:32:02,380 --> 00:32:06,850
the empty list it's just the empty list

00:32:03,910 --> 00:32:09,250
so really really easy to do the

00:32:06,850 --> 00:32:10,990
recursive case is we have a polymorphic

00:32:09,250 --> 00:32:13,990
function we have a list that starts with

00:32:10,990 --> 00:32:17,830
type A we need to find a case or

00:32:13,990 --> 00:32:19,600
specifically a P hash case remember get

00:32:17,830 --> 00:32:22,600
the tet the self type into the type

00:32:19,600 --> 00:32:25,179
component a p hash case for taipei that

00:32:22,600 --> 00:32:27,130
produces type b and the resulting now

00:32:25,179 --> 00:32:29,260
remember have your eyes drawn to the

00:32:27,130 --> 00:32:33,460
sort of return type of the recursive

00:32:29,260 --> 00:32:36,460
case map or aux the return type is going

00:32:33,460 --> 00:32:38,679
to be B cons m dot out so map over the

00:32:36,460 --> 00:32:41,440
tail and take B which is the output the

00:32:38,679 --> 00:32:43,929
results of the application and put it

00:32:41,440 --> 00:32:47,650
back into the list and this is actually

00:32:43,929 --> 00:32:49,630
all we need map now works we can define

00:32:47,650 --> 00:32:51,670
an ageless that has an into boolean in a

00:32:49,630 --> 00:32:53,770
string define a polymorphic function

00:32:51,670 --> 00:32:56,710
that transforms each of those cases and

00:32:53,770 --> 00:32:59,530
lo and behold we can map over it that is

00:32:56,710 --> 00:33:02,350
really cool and this is all we needed to

00:32:59,530 --> 00:33:07,059
do right see no magic no magic at all a

00:33:02,350 --> 00:33:12,429
lot of strange tricks but no magic so

00:33:07,059 --> 00:33:14,440
what about F now n is is probably the

00:33:12,429 --> 00:33:16,510
weirdest function of all because end and

00:33:14,440 --> 00:33:19,000
seems like it should be categorically

00:33:16,510 --> 00:33:20,559
impossible right because what we're

00:33:19,000 --> 00:33:23,919
trying to do here

00:33:20,559 --> 00:33:27,429
is take an integer literal and use it to

00:33:23,919 --> 00:33:29,169
index into an age list and get out the

00:33:27,429 --> 00:33:31,830
element that's at that particular part

00:33:29,169 --> 00:33:34,960
in the H list with the specific type

00:33:31,830 --> 00:33:38,620
that corresponds to that element so if I

00:33:34,960 --> 00:33:41,440
say H list you know n0 I want to get 42

00:33:38,620 --> 00:33:42,999
of type int if I seance one I want to

00:33:41,440 --> 00:33:45,340
get 42 I'm gonna get false of type

00:33:42,999 --> 00:33:47,529
boolean if I say em too I don't want it

00:33:45,340 --> 00:33:50,470
to compile so how the heck can we make

00:33:47,529 --> 00:33:52,779
this work how is that even possible how

00:33:50,470 --> 00:33:54,279
do you index into an H list well clearly

00:33:52,779 --> 00:33:57,299
we're going to need some way of

00:33:54,279 --> 00:34:00,639
representing numbers at the type level

00:33:57,299 --> 00:34:03,659
so I guess you sort of as a as a first

00:34:00,639 --> 00:34:07,450
start we could define case object 1 and

00:34:03,659 --> 00:34:11,109
case object to and maybe case object 3

00:34:07,450 --> 00:34:14,109
and this is a train wreck don't do this

00:34:11,109 --> 00:34:16,389
it clearly does represent numbers it

00:34:14,109 --> 00:34:18,520
will work you know there's certainly

00:34:16,389 --> 00:34:20,649
nothing nothing that says that but you'd

00:34:18,520 --> 00:34:23,829
have to be typing literally for infinity

00:34:20,649 --> 00:34:25,319
to represent all of the numbers so what

00:34:23,829 --> 00:34:28,240
would be a better thing to do is

00:34:25,319 --> 00:34:30,700
consider some prior art here right let's

00:34:28,240 --> 00:34:32,800
go and see if there is a framework that

00:34:30,700 --> 00:34:35,169
maybe mathematicians or logicians have

00:34:32,800 --> 00:34:37,810
been using for years to structurally

00:34:35,169 --> 00:34:39,669
represent natural numbers which is what

00:34:37,810 --> 00:34:41,020
we really need to index into things and

00:34:39,669 --> 00:34:42,190
it turns out that there's a very

00:34:41,020 --> 00:34:44,589
well-known system called piano

00:34:42,190 --> 00:34:48,069
arithmetic which has been around for you

00:34:44,589 --> 00:34:50,200
know 100 plus years and piano arithmetic

00:34:48,069 --> 00:34:52,030
decomposes the natural numbers into two

00:34:50,200 --> 00:34:54,010
structural cases one of them is

00:34:52,030 --> 00:34:56,530
conventionally called zero in this case

00:34:54,010 --> 00:34:58,329
I call it 00 just to be really emphatic

00:34:56,530 --> 00:35:03,069
and also make the type or not hate me

00:34:58,329 --> 00:35:05,319
and successor right so you have a zero

00:35:03,069 --> 00:35:07,390
and then you have a successor which

00:35:05,319 --> 00:35:09,460
contains a natural number inside of it

00:35:07,390 --> 00:35:12,670
so clearly if you have this then you can

00:35:09,460 --> 00:35:13,810
generate all of the natural numbers by

00:35:12,670 --> 00:35:15,190
just you know sort of having more and

00:35:13,810 --> 00:35:17,230
more and more and more and more and more

00:35:15,190 --> 00:35:18,460
successors right relatively

00:35:17,230 --> 00:35:21,579
straightforward everybody should believe

00:35:18,460 --> 00:35:23,650
that and if once we have this

00:35:21,579 --> 00:35:25,480
representation it should be clear that

00:35:23,650 --> 00:35:27,609
we could define we can manipulate this

00:35:25,480 --> 00:35:29,410
and you sort of convert things back into

00:35:27,609 --> 00:35:31,869
intz if we want it to right we define

00:35:29,410 --> 00:35:33,820
this to int function that takes an

00:35:31,869 --> 00:35:36,730
implicit proof to end

00:35:33,820 --> 00:35:38,320
or some natural number n and you know

00:35:36,730 --> 00:35:40,930
it's very easy to define this right the

00:35:38,320 --> 00:35:43,360
base case is simply 0 right and the

00:35:40,930 --> 00:35:45,430
successor case is well do the recursive

00:35:43,360 --> 00:35:48,190
sort of tail thing and then add one to

00:35:45,430 --> 00:35:50,440
that no problem at all and once we have

00:35:48,190 --> 00:35:53,140
this we can take suck-up suck-up suck-up

00:35:50,440 --> 00:35:56,680
zero and it will tell us that that

00:35:53,140 --> 00:35:58,030
corresponds to integer 3 right so so

00:35:56,680 --> 00:36:00,700
everybody agrees should agree here that

00:35:58,030 --> 00:36:03,790
we you know have represented numbers at

00:36:00,700 --> 00:36:05,560
the type level and they do these numbers

00:36:03,790 --> 00:36:06,970
do have some sort of valuable

00:36:05,560 --> 00:36:09,760
representation right suck is a case

00:36:06,970 --> 00:36:12,940
class 0 is a crazed object but this is

00:36:09,760 --> 00:36:14,440
not the most pleasant like value level

00:36:12,940 --> 00:36:16,810
representation at all right and if our

00:36:14,440 --> 00:36:18,400
users are having to write like suck-up

00:36:16,810 --> 00:36:19,990
suck-up psycho Saku Saku Saku sock to

00:36:18,400 --> 00:36:22,060
get the you know so 40 second element

00:36:19,990 --> 00:36:23,320
out of our age less like they're just

00:36:22,060 --> 00:36:26,350
going to go away and leave us a bad

00:36:23,320 --> 00:36:29,170
review on Yelp so so what we really want

00:36:26,350 --> 00:36:33,430
to do here is we want to use int right

00:36:29,170 --> 00:36:35,440
so can we convert from int into a

00:36:33,430 --> 00:36:38,170
natural number or at least an in literal

00:36:35,440 --> 00:36:40,630
is that possible is there some way that

00:36:38,170 --> 00:36:44,920
we can make the compiler do this for us

00:36:40,630 --> 00:36:53,290
and the answer is yeah yeah there is a

00:36:44,920 --> 00:36:55,990
way that way is macros yay no macros

00:36:53,290 --> 00:36:57,550
macros are terrible don't use them but

00:36:55,990 --> 00:37:01,480
we're going to use them they allow you

00:36:57,550 --> 00:37:03,280
to introduce new primitives into the

00:37:01,480 --> 00:37:04,750
language and in fact we're going to be

00:37:03,280 --> 00:37:06,610
using a special type of macros called

00:37:04,750 --> 00:37:08,680
white box macros which allow you to

00:37:06,610 --> 00:37:11,950
introduce new primitives into the type

00:37:08,680 --> 00:37:15,460
system just categorically insane they do

00:37:11,950 --> 00:37:18,640
not replace the existing type level

00:37:15,460 --> 00:37:20,740
facilities right so this is really

00:37:18,640 --> 00:37:22,840
important you come up with some crazy

00:37:20,740 --> 00:37:25,120
idea that's like you know I want to

00:37:22,840 --> 00:37:29,050
represent you know Bob's thingamajiggy

00:37:25,120 --> 00:37:31,990
at the type level do not do not do not

00:37:29,050 --> 00:37:33,850
just write a macro right you write a

00:37:31,990 --> 00:37:35,710
macro to introduce a new primitive and

00:37:33,850 --> 00:37:38,110
then you compose that primitive using

00:37:35,710 --> 00:37:40,360
implicit do as much as you possibly can

00:37:38,110 --> 00:37:42,670
with the functionality that's already in

00:37:40,360 --> 00:37:46,260
the type system macros are your last

00:37:42,670 --> 00:37:49,320
resort why because they're terrible and

00:37:46,260 --> 00:37:52,260
they're probably going away so don't use

00:37:49,320 --> 00:37:55,410
them until you absolutely have to in our

00:37:52,260 --> 00:37:57,810
case we absolutely have to so here's how

00:37:55,410 --> 00:38:00,090
here's what it looks like we'll find

00:37:57,810 --> 00:38:01,530
this from int function on that that

00:38:00,090 --> 00:38:05,820
takes an int and returns an at

00:38:01,530 --> 00:38:07,440
supposedly and the definition of this

00:38:05,820 --> 00:38:09,870
from end is going to be defined by this

00:38:07,440 --> 00:38:12,450
materialized macro this is valid Scala

00:38:09,870 --> 00:38:13,980
by the way so if it looks weird your

00:38:12,450 --> 00:38:17,340
eyes yeah it should look weird it's back

00:38:13,980 --> 00:38:19,290
rows and on the next page we have a

00:38:17,340 --> 00:38:21,900
mountain of boilerplate which is also

00:38:19,290 --> 00:38:23,460
macros and basically what you should see

00:38:21,900 --> 00:38:25,050
here so reading from the top is we have

00:38:23,460 --> 00:38:27,000
a white box context which should tell

00:38:25,050 --> 00:38:29,100
you Dame's your danger will robinson and

00:38:27,000 --> 00:38:32,340
then on the next line we import the

00:38:29,100 --> 00:38:33,540
entire freaking compiler and I'm going

00:38:32,340 --> 00:38:35,040
to fade this out because we really

00:38:33,540 --> 00:38:37,440
shouldn't be looking at that here's the

00:38:35,040 --> 00:38:39,060
body of the macro here's the actual

00:38:37,440 --> 00:38:42,120
definition here's what we're doing we're

00:38:39,060 --> 00:38:43,860
taking the integer as a tree that's I

00:38:42,120 --> 00:38:46,680
and we're pattern matching on it and

00:38:43,860 --> 00:38:49,260
we're saying oh is it a literal constant

00:38:46,680 --> 00:38:52,470
integer whose value is greater than or

00:38:49,260 --> 00:38:55,140
equal to 0 if yes then use Kwazii quotes

00:38:52,470 --> 00:38:57,150
to create a zero and then loop and sort

00:38:55,140 --> 00:38:59,100
of wrap around that zero and just create

00:38:57,150 --> 00:39:01,200
more and more and more Kwazii quotes are

00:38:59,100 --> 00:39:03,600
like if you're familiar with with sort

00:39:01,200 --> 00:39:05,850
of Lisp and how you use macros there in

00:39:03,600 --> 00:39:09,030
quotations Kwazii quotes are kind of

00:39:05,850 --> 00:39:10,380
like quotations in EM scallop and we

00:39:09,030 --> 00:39:12,120
just build up this tree and then we're

00:39:10,380 --> 00:39:14,490
going to return that tree and the

00:39:12,120 --> 00:39:17,250
compiler will will sort of realize that

00:39:14,490 --> 00:39:19,140
that is in fact meant to be a series of

00:39:17,250 --> 00:39:22,110
constructors which is kind of cool if

00:39:19,140 --> 00:39:23,250
we're not a literal constant in a jerb

00:39:22,110 --> 00:39:26,160
whose value is greater than or equal to

00:39:23,250 --> 00:39:28,170
0 we're just going to produce a compile

00:39:26,160 --> 00:39:29,640
error which is what you want right if

00:39:28,170 --> 00:39:32,100
you're trying to do create a natural

00:39:29,640 --> 00:39:36,330
number from negative for you want that

00:39:32,100 --> 00:39:39,180
to explode at compile time and with this

00:39:36,330 --> 00:39:43,410
functionality we can call the function

00:39:39,180 --> 00:39:45,330
it works which is cool you call from int

00:39:43,410 --> 00:39:48,630
of 3 and you get suck-up suck-up suck-up

00:39:45,330 --> 00:39:50,820
zero so we can now convert in both

00:39:48,630 --> 00:39:52,320
directions from integer literals to

00:39:50,820 --> 00:39:53,910
natural numbers and from natural numbers

00:39:52,320 --> 00:39:56,100
back to integer literals but that's

00:39:53,910 --> 00:39:58,590
still not quite enough machinery because

00:39:56,100 --> 00:39:59,680
remember what we're doing here it like

00:39:58,590 --> 00:40:03,490
our motive

00:39:59,680 --> 00:40:06,640
syntax does not include from int I don't

00:40:03,490 --> 00:40:08,710
see any NAT from int 0 nap from int 1 or

00:40:06,640 --> 00:40:10,900
any madness like that i like all we're

00:40:08,710 --> 00:40:13,900
doing is using integer literals so our

00:40:10,900 --> 00:40:17,050
conversion here is not explicit if only

00:40:13,900 --> 00:40:19,900
there were some mechanism in scala for

00:40:17,050 --> 00:40:22,569
taking conversions between two types

00:40:19,900 --> 00:40:26,579
that are explicit and making them I

00:40:22,569 --> 00:40:28,720
don't know not explicit like some some

00:40:26,579 --> 00:40:30,579
functionality that normally you wouldn't

00:40:28,720 --> 00:40:33,490
use but this is evil day so we're going

00:40:30,579 --> 00:40:35,500
to use it and of course implicit

00:40:33,490 --> 00:40:40,030
conversions hard the answer to our

00:40:35,500 --> 00:40:42,490
problems said no one ever we just add

00:40:40,030 --> 00:40:44,230
the implicit modifier and magic happens

00:40:42,490 --> 00:40:47,200
which is what everybody does when they

00:40:44,230 --> 00:40:50,500
add the implicit modifier hilariously

00:40:47,200 --> 00:40:54,910
and insanely this works I have no idea

00:40:50,500 --> 00:40:56,619
why this works I'm pretty sure that at

00:40:54,910 --> 00:40:58,599
some point the compiler will just stop

00:40:56,619 --> 00:41:01,210
cooperating with me and and it will no

00:40:58,599 --> 00:41:03,730
longer work but for now for now we can

00:41:01,210 --> 00:41:06,220
do magic so implicit def from it that's

00:41:03,730 --> 00:41:07,750
pretty cool and that allows us to sort

00:41:06,220 --> 00:41:09,520
of wherever we have an int we can get an

00:41:07,750 --> 00:41:13,030
at just sort of magically from the

00:41:09,520 --> 00:41:14,740
compiler so we've got our functionality

00:41:13,030 --> 00:41:16,450
now we've got the ability to take

00:41:14,740 --> 00:41:18,190
integer literals and sort of push them

00:41:16,450 --> 00:41:21,490
up into the type level in a way that has

00:41:18,190 --> 00:41:22,780
really good syntax because implicit so

00:41:21,490 --> 00:41:24,040
how could we use that to implement em

00:41:22,780 --> 00:41:25,780
well we're going to go back to our

00:41:24,040 --> 00:41:27,880
ageless in tax class we're going to add

00:41:25,780 --> 00:41:29,680
this and thing boilerplate just like we

00:41:27,880 --> 00:41:31,480
have capture the precise type of the

00:41:29,680 --> 00:41:33,880
natural number get an implicit prove

00:41:31,480 --> 00:41:35,619
called enthor right all of us know how

00:41:33,880 --> 00:41:36,970
we're going to define anther like we've

00:41:35,619 --> 00:41:38,799
seen it a hundred times or at least

00:41:36,970 --> 00:41:41,859
three so you know we're not going to do

00:41:38,799 --> 00:41:46,930
it again and and and this should work

00:41:41,859 --> 00:41:49,900
right almost almost the problem is

00:41:46,930 --> 00:41:52,180
because n is a polymorphic type here

00:41:49,900 --> 00:41:53,950
right so n is this type parameters

00:41:52,180 --> 00:41:56,349
constrain to be a subtype of NAT it

00:41:53,950 --> 00:41:58,660
turns out that the compiler will not

00:41:56,349 --> 00:42:01,030
trigger implicit conversions when you

00:41:58,660 --> 00:42:03,250
are in this situation we just kind of

00:42:01,030 --> 00:42:06,520
weird and I actually not know that but

00:42:03,250 --> 00:42:08,109
we you know if we do this we can't use

00:42:06,520 --> 00:42:10,059
our magical magic thing that probably

00:42:08,109 --> 00:42:12,220
shouldn't ever work but soooo somehow

00:42:10,059 --> 00:42:13,360
works anyway so we have to do something

00:42:12,220 --> 00:42:14,980
a little more clever

00:42:13,360 --> 00:42:16,780
what we're going to do is we're going to

00:42:14,980 --> 00:42:18,610
go back to our NAT trait and we're going

00:42:16,780 --> 00:42:21,400
to put a tight member on it and the

00:42:18,610 --> 00:42:24,370
subtype of nap and this type member n is

00:42:21,400 --> 00:42:28,270
going to be the specific type of the NAT

00:42:24,370 --> 00:42:30,970
itself right so 40 this is yo type n is

00:42:28,270 --> 00:42:33,490
simply going to equal zero for suck of

00:42:30,970 --> 00:42:35,050
you know and not type n is going to

00:42:33,490 --> 00:42:36,940
equal sucker bet not it's going to be

00:42:35,050 --> 00:42:38,650
the self type of the map and what we can

00:42:36,940 --> 00:42:40,660
do now is we can go back to our

00:42:38,650 --> 00:42:42,850
dependent method types and we could just

00:42:40,660 --> 00:42:45,190
take a gnat and then when we look for

00:42:42,850 --> 00:42:47,710
the entha proof we look for the end of

00:42:45,190 --> 00:42:51,130
proof of lower case n dot upper case at

00:42:47,710 --> 00:42:55,890
all of our variable names are confined

00:42:51,130 --> 00:42:58,450
to the same thing apparently n nnnnn and

00:42:55,890 --> 00:43:00,820
this this actually works so the implicit

00:42:58,450 --> 00:43:02,590
conversion now triggers and because

00:43:00,820 --> 00:43:04,690
we're just looking for nat and we have

00:43:02,590 --> 00:43:07,090
the specific self type in our hand so we

00:43:04,690 --> 00:43:10,000
can find the proof for the piano numeral

00:43:07,090 --> 00:43:17,560
and lo and behold our syntax now

00:43:10,000 --> 00:43:19,720
functions as advertised yay what this is

00:43:17,560 --> 00:43:21,700
this is insane all right let's take a

00:43:19,720 --> 00:43:23,050
step back like we're kind of way down in

00:43:21,700 --> 00:43:24,970
the weeds here let's take a step back

00:43:23,050 --> 00:43:27,340
and think about the horror that we just

00:43:24,970 --> 00:43:29,650
inflicted on the world right so 42 cons

00:43:27,340 --> 00:43:31,600
HT length of 0 what is going on here

00:43:29,650 --> 00:43:34,240
well there's an implicit conversion from

00:43:31,600 --> 00:43:38,260
int to NAT that triggers a white box

00:43:34,240 --> 00:43:40,540
macro that generates a piano numeral

00:43:38,260 --> 00:43:42,670
which is represented as nested type

00:43:40,540 --> 00:43:45,220
constructors and then we use dependent

00:43:42,670 --> 00:43:47,650
method types to carry these this type to

00:43:45,220 --> 00:43:50,080
the implicit block and we find a proof

00:43:47,650 --> 00:43:53,140
that indexing is valid for the specific

00:43:50,080 --> 00:43:55,620
ageless and just for fun we return the

00:43:53,140 --> 00:43:55,620
result

00:44:01,650 --> 00:44:08,289
abracadabra so so this this begs an

00:44:06,160 --> 00:44:10,329
interesting question right we're doing

00:44:08,289 --> 00:44:12,430
things here that look very distinctly

00:44:10,329 --> 00:44:14,440
like a dress very distinctly like AG de

00:44:12,430 --> 00:44:16,089
we're taking these sort of these integer

00:44:14,440 --> 00:44:17,859
literals these numbers we're moving them

00:44:16,089 --> 00:44:19,269
into the type system and working with

00:44:17,859 --> 00:44:20,829
them at the type level and then going

00:44:19,269 --> 00:44:23,199
back into the value over with those

00:44:20,829 --> 00:44:25,239
results that's very much like a

00:44:23,199 --> 00:44:26,859
dependently typed language where you

00:44:25,239 --> 00:44:28,959
know the value level in the type level

00:44:26,859 --> 00:44:31,959
kind of merged together and this sort of

00:44:28,959 --> 00:44:33,819
unholy synthesis of mass effect you know

00:44:31,959 --> 00:44:36,099
is is that actually what we're doing

00:44:33,819 --> 00:44:38,229
here Julie really is Scala really

00:44:36,099 --> 00:44:41,589
somewhat like Idris somewhat like Agha

00:44:38,229 --> 00:44:44,699
is that actually what it is yeah yeah I

00:44:41,589 --> 00:44:47,979
think it is that's not scary or anything

00:44:44,699 --> 00:44:49,420
you know the syntax is is kind of bulky

00:44:47,979 --> 00:44:51,039
and awkward like we have to do this

00:44:49,420 --> 00:44:53,709
implicit stuff and you know all these

00:44:51,039 --> 00:44:57,009
white marks macros and things but yeah

00:44:53,709 --> 00:45:02,469
actually this this sort of works that's

00:44:57,009 --> 00:45:04,690
cool so yeah tell your friends so to

00:45:02,469 --> 00:45:06,009
wrap all of this up we talked about

00:45:04,690 --> 00:45:07,779
context-dependent and contacts

00:45:06,009 --> 00:45:09,309
independent functions and what you can

00:45:07,779 --> 00:45:11,589
do with them and why you would want to

00:45:09,309 --> 00:45:13,660
do one versus the other we talked about

00:45:11,589 --> 00:45:15,099
forming implicit proofs right when you

00:45:13,660 --> 00:45:17,019
write a type level function you form an

00:45:15,099 --> 00:45:19,839
implicit proof of your action encode

00:45:17,019 --> 00:45:21,640
rules as implicit values that the

00:45:19,839 --> 00:45:23,589
compiler will solve and then use

00:45:21,640 --> 00:45:26,079
dependent output types to move the

00:45:23,589 --> 00:45:28,059
computed result from the implicit scope

00:45:26,079 --> 00:45:31,029
to the output type of your function

00:45:28,059 --> 00:45:32,650
speaking of the implicit scope abuse the

00:45:31,029 --> 00:45:34,569
heck out of it this is not your

00:45:32,650 --> 00:45:36,880
girlfriend there are skeletons in the

00:45:34,569 --> 00:45:39,039
closet find them tuck a note behind it

00:45:36,880 --> 00:45:40,869
it's really like there's a lot of random

00:45:39,039 --> 00:45:44,680
stuff that you can do with the implicit

00:45:40,869 --> 00:45:47,799
scope that's really really crazy and you

00:45:44,680 --> 00:45:51,160
can get a lot done that way and if all

00:45:47,799 --> 00:45:53,049
else fails use a macro really really if

00:45:51,160 --> 00:45:56,289
all else fails really really really

00:45:53,049 --> 00:45:59,019
everything else failing use a macro but

00:45:56,289 --> 00:46:00,789
it's there for you if you need it I

00:45:59,019 --> 00:46:03,989
think I don't know how much time we have

00:46:00,789 --> 00:46:03,989
but are there are there any questions

00:46:09,180 --> 00:46:23,140
I don't know if we have a microphone I

00:46:11,860 --> 00:46:24,520
can just repeat the question how do how

00:46:23,140 --> 00:46:26,260
do I come up with it well that's better

00:46:24,520 --> 00:46:29,680
a question for miles because I come up

00:46:26,260 --> 00:46:31,510
with it by looking at his stuff so so

00:46:29,680 --> 00:46:35,220
miles do these things just come to you

00:46:31,510 --> 00:46:35,220
in visions or like how does it work

00:46:35,910 --> 00:46:40,870
miles miles hangouts are looking

00:46:37,690 --> 00:46:47,500
microphones coming so right at the

00:46:40,870 --> 00:46:48,880
beginning basically kind of some kind of

00:46:47,500 --> 00:46:50,320
stochastic search process I think

00:46:48,880 --> 00:46:51,460
basically sort of kind of you know if

00:46:50,320 --> 00:46:53,950
you imagine an infinite number of

00:46:51,460 --> 00:46:57,310
monkeys typing on keyboards lots and

00:46:53,950 --> 00:47:00,280
lots of trying things which seemed like

00:46:57,310 --> 00:47:01,600
they might might possibly work realizing

00:47:00,280 --> 00:47:03,280
that they didn't backing off and try

00:47:01,600 --> 00:47:04,720
again running into roadblocks like the

00:47:03,280 --> 00:47:06,490
one for example that Daniel was

00:47:04,720 --> 00:47:09,760
describing with the implicit conversions

00:47:06,490 --> 00:47:11,170
from from integer literals to turn at I

00:47:09,760 --> 00:47:13,480
thought my goodness I've got this it

00:47:11,170 --> 00:47:15,310
will work I have this this this this

00:47:13,480 --> 00:47:17,950
this white box macro which will which

00:47:15,310 --> 00:47:20,560
will convert an integer an institute it

00:47:17,950 --> 00:47:21,880
will work it will work what does work i

00:47:20,560 --> 00:47:23,470
can do it by hand and it works and then

00:47:21,880 --> 00:47:24,610
try it in the context of an implicit

00:47:23,470 --> 00:47:27,010
conversion suddenly it doesn't work

00:47:24,610 --> 00:47:28,930
anymore no all this work I've done the

00:47:27,010 --> 00:47:31,060
last few days none of it actually works

00:47:28,930 --> 00:47:32,200
and then rose okay okay let's try again

00:47:31,060 --> 00:47:35,920
there must be some other so it's

00:47:32,200 --> 00:47:37,090
basically a very because really really

00:47:35,920 --> 00:47:38,680
there is nothing there is nothing I mean

00:47:37,090 --> 00:47:40,060
there are Thurid that there's a lot of

00:47:38,680 --> 00:47:42,610
stuff here which is very principled so

00:47:40,060 --> 00:47:43,990
it's using the type system so a lot of

00:47:42,610 --> 00:47:45,490
the stuff that Daniel is describing in

00:47:43,990 --> 00:47:47,080
terms of thinking of implicit says

00:47:45,490 --> 00:47:49,260
proofs and making analogies with actor

00:47:47,080 --> 00:47:52,420
and interest that's all true however

00:47:49,260 --> 00:47:55,090
mapping that onto the concrete reality

00:47:52,420 --> 00:47:57,940
that is the Skyler compiler is not is

00:47:55,090 --> 00:48:00,430
not a logical or mathematical process is

00:47:57,940 --> 00:48:03,940
very it's very empirical it's very trial

00:48:00,430 --> 00:48:06,640
and error and so basically a ton of a

00:48:03,940 --> 00:48:07,900
ton of third that the process is mostly

00:48:06,640 --> 00:48:09,250
I think at the time when I was first

00:48:07,900 --> 00:48:10,810
doing this it was it was just trial and

00:48:09,250 --> 00:48:12,040
error in terms of you know what what's

00:48:10,810 --> 00:48:13,360
what's going to work just treating

00:48:12,040 --> 00:48:16,570
treating the Scala compiler as a black

00:48:13,360 --> 00:48:17,770
box certainly since then yes a certain

00:48:16,570 --> 00:48:19,640
amount of looking at what's going on in

00:48:17,770 --> 00:48:23,240
the compiler internals

00:48:19,640 --> 00:48:26,870
definitely I think that basically

00:48:23,240 --> 00:48:28,430
answers the question all right any any

00:48:26,870 --> 00:48:30,620
further questions we got one back there

00:48:28,430 --> 00:48:32,060
by the camera you should buy wait for

00:48:30,620 --> 00:48:38,540
the microphone as it Sprint's towards

00:48:32,060 --> 00:48:41,090
you if we lose arbitrary type regret

00:48:38,540 --> 00:48:45,620
projections and macros how much of this

00:48:41,090 --> 00:48:47,750
remains possible almost all of it so we

00:48:45,620 --> 00:48:49,070
lose type projections but as I mentioned

00:48:47,750 --> 00:48:50,720
daddy is getting multiple implicit

00:48:49,070 --> 00:48:52,850
parameter box and if you have multiple

00:48:50,720 --> 00:48:54,380
implicit parameter blocks the advantages

00:48:52,850 --> 00:48:56,450
of type projections actually kind of go

00:48:54,380 --> 00:48:58,490
away because this whole context

00:48:56,450 --> 00:49:00,320
dependence context independence thing no

00:48:58,490 --> 00:49:02,510
longer matters if you have the ability

00:49:00,320 --> 00:49:04,700
to define your structural decomposition

00:49:02,510 --> 00:49:07,070
as one implicit and then carry it via

00:49:04,700 --> 00:49:09,440
dependent type to the next parameter

00:49:07,070 --> 00:49:10,940
block and resolve more things on it so

00:49:09,440 --> 00:49:13,550
it's basically the fact that we don't

00:49:10,940 --> 00:49:16,160
have type level continuations yet that

00:49:13,550 --> 00:49:18,250
forces us to use type projection that's

00:49:16,160 --> 00:49:20,690
not an issue in dotty so that goes away

00:49:18,250 --> 00:49:22,790
the lack of white box macros is a more

00:49:20,690 --> 00:49:25,790
serious problem so that's going to be a

00:49:22,790 --> 00:49:27,800
problem for obviously int to NAT because

00:49:25,790 --> 00:49:30,410
we can't materialize that type without

00:49:27,800 --> 00:49:32,990
it it's also a problem for shapeless is

00:49:30,410 --> 00:49:34,940
generic miles has things that he wants

00:49:32,990 --> 00:49:39,770
to say you can help why don't you just

00:49:34,940 --> 00:49:42,440
come forward you have a microphone um so

00:49:39,770 --> 00:49:43,910
just just on those two specific things

00:49:42,440 --> 00:49:45,230
and so there's one thing that daniel

00:49:43,910 --> 00:49:46,520
said at the beginning which was that

00:49:45,230 --> 00:49:49,100
miles doesn't have his own version the

00:49:46,520 --> 00:49:51,570
Scarlet compiler he does now although I

00:49:49,100 --> 00:49:54,850
do now

00:49:51,570 --> 00:49:56,020
and Bert Bert Bert but it's not it's not

00:49:54,850 --> 00:49:57,550
it's not unique it's not going to be

00:49:56,020 --> 00:49:58,840
unique to me for long so I've been doing

00:49:57,550 --> 00:50:01,450
a certain amount of work as well as the

00:49:58,840 --> 00:50:05,170
SI 2712 stuff some stuff I've been doing

00:50:01,450 --> 00:50:07,960
more recently is reviving the thus it

00:50:05,170 --> 00:50:09,970
fought sorry the twenty forty two titles

00:50:07,960 --> 00:50:13,330
otherwise known as sit 23 which is the

00:50:09,970 --> 00:50:16,210
ability to basically treat literals as

00:50:13,330 --> 00:50:17,980
types directly and surface in taxes

00:50:16,210 --> 00:50:19,480
Carla so so Adrian malls did some work

00:50:17,980 --> 00:50:21,750
on that back year and a half ago it's

00:50:19,480 --> 00:50:25,570
been parked I've recently picked it up

00:50:21,750 --> 00:50:27,280
I'm aiming to get that in a usable Scala

00:50:25,570 --> 00:50:29,470
compiler either the light bends garlic

00:50:27,280 --> 00:50:32,050
compiler or a type type levels garlic

00:50:29,470 --> 00:50:34,930
compiler very very shortly so that that

00:50:32,050 --> 00:50:36,460
addresses that particular one in terms

00:50:34,930 --> 00:50:38,680
of multiple implicit promotable it's

00:50:36,460 --> 00:50:39,850
what I do also have a I a match against

00:50:38,680 --> 00:50:41,290
the Scylla compiler which provides

00:50:39,850 --> 00:50:43,180
multiple input parameter blocks for

00:50:41,290 --> 00:50:46,440
Scarlett's actually all that many many

00:50:43,180 --> 00:50:49,060
of these things are surprisingly small

00:50:46,440 --> 00:50:50,530
changes to the current Skylar compiler I

00:50:49,060 --> 00:50:52,570
think this there's actually a lot of

00:50:50,530 --> 00:50:54,220
opportunities for us to make this kind

00:50:52,570 --> 00:50:56,320
of idioms and the kind of idioms that

00:50:54,220 --> 00:50:58,090
you find in sort of type level skyla

00:50:56,320 --> 00:50:59,860
projects generally very much very much

00:50:58,090 --> 00:51:03,250
easier to use I think and I think

00:50:59,860 --> 00:51:05,350
certainly my plan is to over over the

00:51:03,250 --> 00:51:07,720
next the next six months to a years is

00:51:05,350 --> 00:51:09,370
to is to basically see how much of this

00:51:07,720 --> 00:51:10,930
stuff can be usefully and generally be

00:51:09,370 --> 00:51:13,000
rolled into into into the scholar

00:51:10,930 --> 00:51:14,230
programming language as opposed to kind

00:51:13,000 --> 00:51:19,200
of waiting for some waiting sir bobby's

00:51:14,230 --> 00:51:21,760
away all right another question here I

00:51:19,200 --> 00:51:23,020
don't know how long it will take that to

00:51:21,760 --> 00:51:26,860
sort of percolate to you through the

00:51:23,020 --> 00:51:29,140
layers of Astroturf thank you have a

00:51:26,860 --> 00:51:30,730
question about the context and

00:51:29,140 --> 00:51:33,730
dependence of the type little functions

00:51:30,730 --> 00:51:35,560
I mean it sounds relatively simple but

00:51:33,730 --> 00:51:37,180
could you maybe you know explain this

00:51:35,560 --> 00:51:39,460
one what once more in the more like

00:51:37,180 --> 00:51:42,450
simple language so what exactly this

00:51:39,460 --> 00:51:45,940
means so are you interested more and

00:51:42,450 --> 00:51:47,170
sort of why I call them that or are you

00:51:45,940 --> 00:51:49,930
interested in why you would use one

00:51:47,170 --> 00:51:52,150
versus the other the first one okay i

00:51:49,930 --> 00:51:55,870
called it context independent versus

00:51:52,150 --> 00:51:58,240
context dependent because a contact

00:51:55,870 --> 00:52:01,150
independent function is is a type elias

00:51:58,240 --> 00:52:03,880
that cannot be changed by imports it

00:52:01,150 --> 00:52:05,050
produces the same result regardless of

00:52:03,880 --> 00:52:07,930
the position you use it

00:52:05,050 --> 00:52:10,000
in the program whereas implicit SAR

00:52:07,930 --> 00:52:10,930
subject to implicit scope right so for

00:52:10,000 --> 00:52:12,910
all of this stuff that we're talking

00:52:10,930 --> 00:52:15,070
about like defining the cases for mapper

00:52:12,910 --> 00:52:18,040
and whatnot it's always possible for a

00:52:15,070 --> 00:52:20,230
user to just you know sort of define

00:52:18,040 --> 00:52:23,080
implicit mapper equals null and like

00:52:20,230 --> 00:52:24,580
completely screw us up so that makes it

00:52:23,080 --> 00:52:25,900
context dependent right you can do

00:52:24,580 --> 00:52:28,780
import so you do things like that and

00:52:25,900 --> 00:52:31,540
this actually prevents the compiler

00:52:28,780 --> 00:52:33,640
rightfully so from proving certain

00:52:31,540 --> 00:52:34,990
things about these functions so with a

00:52:33,640 --> 00:52:36,660
context independent function the

00:52:34,990 --> 00:52:38,890
compiler can actually make those proofs

00:52:36,660 --> 00:52:40,690
which allows you to do certain things

00:52:38,890 --> 00:52:44,860
that you can't do with implicit right

00:52:40,690 --> 00:52:46,270
now the best example of what you can't

00:52:44,860 --> 00:52:47,470
do with implicit right now is basically

00:52:46,270 --> 00:52:49,180
what I've been talking about with

00:52:47,470 --> 00:52:51,070
structure right each list is a very

00:52:49,180 --> 00:52:52,960
simple structure you have a console and

00:52:51,070 --> 00:52:54,400
you know sort of an ill and it's very

00:52:52,960 --> 00:52:56,050
very straightforward but if you define

00:52:54,400 --> 00:52:57,760
something more intricate that sort of

00:52:56,050 --> 00:52:59,440
maybe some sort of grafische thing or

00:52:57,760 --> 00:53:00,790
like a tree that has sort of conditional

00:52:59,440 --> 00:53:02,920
branches things like that which I've

00:53:00,790 --> 00:53:05,680
done if you do that at the type level it

00:53:02,920 --> 00:53:07,240
becomes very painful to do everything

00:53:05,680 --> 00:53:09,580
with implicit because you have to do

00:53:07,240 --> 00:53:12,070
redefine the way in which you decompose

00:53:09,580 --> 00:53:14,530
the structure in every single operation

00:53:12,070 --> 00:53:16,450
so this is like take wobblers expression

00:53:14,530 --> 00:53:18,070
problem and then choose like the worst

00:53:16,450 --> 00:53:22,000
possible answer to it that's what you

00:53:18,070 --> 00:53:23,650
end up with so type projections give you

00:53:22,000 --> 00:53:25,210
a way around that right now multiple

00:53:23,650 --> 00:53:26,920
implicit parameter blocks give you a way

00:53:25,210 --> 00:53:28,360
around it for the future because then

00:53:26,920 --> 00:53:30,580
you can define an implicit that proves

00:53:28,360 --> 00:53:32,080
how you decompose things and then carry

00:53:30,580 --> 00:53:34,450
that to your operation which proves how

00:53:32,080 --> 00:53:37,060
you apply to that decomposition I don't

00:53:34,450 --> 00:53:38,830
know if that makes sense but I'm trying

00:53:37,060 --> 00:53:41,140
some people think about it okay thank

00:53:38,830 --> 00:53:43,450
you I i think the hook is coming from

00:53:41,140 --> 00:53:45,510
offstage so thank you very much for your

00:53:43,450 --> 00:53:45,510
time

00:53:46,240 --> 00:53:48,300

YouTube URL: https://www.youtube.com/watch?v=zKRNMyo3wzg


