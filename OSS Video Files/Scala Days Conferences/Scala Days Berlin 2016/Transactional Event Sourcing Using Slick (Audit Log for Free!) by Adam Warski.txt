Title: Transactional Event Sourcing Using Slick (Audit Log for Free!) by Adam Warski
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
Event sourcing is a great alternative to traditional "CRUD"-type architectures. The central concept is a persistent stream of events, which drives all changes to the read model and running any kind of business logic. There’s a lot of technical and business benefits to such an approach, such as being able to re-create the state of the system at any point in time, or keeping a detailed *audit log* of all actions. Typically, implementations of event sourcing are presented using a NoSQL data storage, which is great for many use cases (e.g. using Akka Persistence + Cassandra). However, nothing stops us from using a relational database and SQL! In many applications (especially “enterprise”), this brings many benefits, such as powerful and familiar query capabilities and higher guarantees around data consistency. 

In this mainly live-coding talk we’ll see one way of implementing transactional event sourcing using the 'slick-eventsourcing' micro-framework, introducing the core concepts: command handlers, read model updates and event listeners, and how to use them to build an event-sourced application. We’ll see how Slick’s 'DBAction' and Scala flexibility makes it possible to provide an elegant DSL to build the system from simple functions with minimum dependencies.
Captions: 
	00:00:04,890 --> 00:00:08,799
okay I guess we can start thank you all

00:00:08,200 --> 00:00:10,930
for coming

00:00:08,799 --> 00:00:14,320
it's great to be here thank you for

00:00:10,930 --> 00:00:17,259
having me and so I would like to talk a

00:00:14,320 --> 00:00:19,810
bit today on how to do event sourcing

00:00:17,259 --> 00:00:23,430
using a slick and leveraging

00:00:19,810 --> 00:00:26,140
transactions my name is Adam Barsky so

00:00:23,430 --> 00:00:28,300
if I start there's this conference

00:00:26,140 --> 00:00:30,309
application and that I guess you'll have

00:00:28,300 --> 00:00:32,710
on your phones and I think the way it

00:00:30,309 --> 00:00:34,719
works it is after the talk you have to

00:00:32,710 --> 00:00:38,740
go and press the green button over there

00:00:34,719 --> 00:00:41,200
so so yeah but most small seriously

00:00:38,740 --> 00:00:42,910
piece please do that as feedback is very

00:00:41,200 --> 00:00:44,980
important both for the organizers so

00:00:42,910 --> 00:00:47,170
that they know who not to invite next

00:00:44,980 --> 00:00:49,320
time and and for me as well if you have

00:00:47,170 --> 00:00:52,630
any questions throughout the talk please

00:00:49,320 --> 00:00:57,550
please ask right away I will try to

00:00:52,630 --> 00:01:00,550
answer if I can okay so what is I've

00:00:57,550 --> 00:01:02,920
been sourcing I guess we already more or

00:01:00,550 --> 00:01:05,229
less have some feeling what this means

00:01:02,920 --> 00:01:08,740
there's a lot of good articles on the

00:01:05,229 --> 00:01:10,330
web by people like Martin Fowler or Greg

00:01:08,740 --> 00:01:13,600
young and I'm not going to try to

00:01:10,330 --> 00:01:16,750
compete with them but for our purposes I

00:01:13,600 --> 00:01:19,900
guess we can define it event sourcing as

00:01:16,750 --> 00:01:22,390
an approach and architecture where all

00:01:19,900 --> 00:01:24,670
changes in our system are captured as a

00:01:22,390 --> 00:01:28,900
sequence of events and the events are

00:01:24,670 --> 00:01:30,820
the main driver of of what happens in

00:01:28,900 --> 00:01:32,470
our application so you see more

00:01:30,820 --> 00:01:37,540
concretely what this means of course

00:01:32,470 --> 00:01:42,970
later so why would we consider using an

00:01:37,540 --> 00:01:46,420
event source or architecture so in many

00:01:42,970 --> 00:01:48,909
cases event sourcing is used for

00:01:46,420 --> 00:01:50,740
scalability and performance reasons so

00:01:48,909 --> 00:01:54,460
when using a relational database that's

00:01:50,740 --> 00:01:57,250
maybe not the main factor as the DB can

00:01:54,460 --> 00:01:59,380
be the limiting thing here so but there

00:01:57,250 --> 00:02:01,720
are also other reasons so for me one of

00:01:59,380 --> 00:02:03,700
the reasons is that I'm working in IT

00:02:01,720 --> 00:02:07,379
which stands for information technology

00:02:03,700 --> 00:02:10,989
and very often and traditional crud

00:02:07,379 --> 00:02:13,989
applications what happens especially

00:02:10,989 --> 00:02:17,160
with the RMD U is that data gets

00:02:13,989 --> 00:02:20,010
destroyed right guys it's data oh oh

00:02:17,160 --> 00:02:23,130
right existing data and so we lose we

00:02:20,010 --> 00:02:25,470
lost in it we lose in information and

00:02:23,130 --> 00:02:28,050
you never know when that information can

00:02:25,470 --> 00:02:30,390
be useful in the future so maybe it's a

00:02:28,050 --> 00:02:33,630
good idea to actually keep as much as

00:02:30,390 --> 00:02:35,910
possible okay and also this approach

00:02:33,630 --> 00:02:38,130
actually has or can have a business

00:02:35,910 --> 00:02:40,680
benefit so unlike offense a new web

00:02:38,130 --> 00:02:42,510
framework using event sourcing can have

00:02:40,680 --> 00:02:45,510
a business benefit because you

00:02:42,510 --> 00:02:47,850
automatically get an audit log of all

00:02:45,510 --> 00:02:50,580
the actions in the system and this very

00:02:47,850 --> 00:02:52,380
often comes as a requirement maybe not

00:02:50,580 --> 00:02:55,410
in the initial stages of a project but

00:02:52,380 --> 00:02:58,590
maybe later on and then you can say hey

00:02:55,410 --> 00:03:01,290
it's it's it's ready so it's already in

00:02:58,590 --> 00:03:03,210
the database another thing for testing

00:03:01,290 --> 00:03:05,940
you can quite easily recreate the system

00:03:03,210 --> 00:03:07,770
state at any point in time when using

00:03:05,940 --> 00:03:09,840
event sourcing so that can be quite

00:03:07,770 --> 00:03:12,930
useful for debugging when you have that

00:03:09,840 --> 00:03:16,890
nasty production issue so that's quite a

00:03:12,930 --> 00:03:20,820
lot of reasons besides scalability and

00:03:16,890 --> 00:03:23,790
performance to use event sourcing and so

00:03:20,820 --> 00:03:27,030
I actually have a history with auditing

00:03:23,790 --> 00:03:29,940
and so I guess you don't often see

00:03:27,030 --> 00:03:34,440
hibernate on the screen on a scholar

00:03:29,940 --> 00:03:36,810
conference so but here this so like a

00:03:34,440 --> 00:03:37,650
couple of years ago I wrote back when I

00:03:36,810 --> 00:03:39,900
was a drama coder

00:03:37,650 --> 00:03:42,240
I wrote this extension hibernate called

00:03:39,900 --> 00:03:44,850
hibernate and verse and the way it

00:03:42,240 --> 00:03:48,270
worked is each time you saved and and

00:03:44,850 --> 00:03:50,790
you knew that you saved an entity to the

00:03:48,270 --> 00:03:53,600
database you merged it with a hibernates

00:03:50,790 --> 00:03:56,459
session era was added to the history

00:03:53,600 --> 00:03:58,320
table and that way you've got an audit

00:03:56,459 --> 00:04:00,000
of all the past states and you can read

00:03:58,320 --> 00:04:02,130
the history and so on so this was like

00:04:00,000 --> 00:04:04,500
the other way around right so in an

00:04:02,130 --> 00:04:07,130
averse you did the changes making a

00:04:04,500 --> 00:04:09,630
typical crud fashion and then in

00:04:07,130 --> 00:04:11,700
reaction to that the history was was

00:04:09,630 --> 00:04:13,380
written in an event sourcing it's the

00:04:11,700 --> 00:04:14,430
other way around and we will be doing

00:04:13,380 --> 00:04:16,770
things to the other way around

00:04:14,430 --> 00:04:19,620
so first come the events which update

00:04:16,770 --> 00:04:22,410
our model as we will see in a bit and

00:04:19,620 --> 00:04:23,700
when we are talking about me that's the

00:04:22,410 --> 00:04:26,070
short introduction so that you know

00:04:23,700 --> 00:04:28,080
who's talking to I'm an software

00:04:26,070 --> 00:04:30,450
engineers optimal I called mainly in

00:04:28,080 --> 00:04:31,980
Scala which probably is not a surprise

00:04:30,450 --> 00:04:34,260
my company is a light denticles

00:04:31,980 --> 00:04:36,240
consulting partner so we do we a

00:04:34,260 --> 00:04:39,540
software house with the Scala software

00:04:36,240 --> 00:04:43,140
for clients all over the world using

00:04:39,540 --> 00:04:46,020
Scala but also Java and groovy we have a

00:04:43,140 --> 00:04:48,540
newsletter Scala times which maybe you

00:04:46,020 --> 00:04:51,240
have heard about if not please check it

00:04:48,540 --> 00:04:54,810
out mmm I'm involved in some open source

00:04:51,240 --> 00:04:58,230
projects and I have a blog and a Twitter

00:04:54,810 --> 00:05:03,830
account so we can follow me ok so what's

00:04:58,230 --> 00:05:06,150
what's our goal so we want by using

00:05:03,830 --> 00:05:08,130
slick transactions and events sourcing

00:05:06,150 --> 00:05:10,830
so we want to get the benefits of event

00:05:08,130 --> 00:05:12,900
sourcing plus we still want to let we

00:05:10,830 --> 00:05:15,750
still want to leverage what the database

00:05:12,900 --> 00:05:17,340
gives us so we want to somehow take

00:05:15,750 --> 00:05:19,590
advantage of the fact that we do have

00:05:17,340 --> 00:05:21,930
the transactions which are an expensive

00:05:19,590 --> 00:05:24,450
thing right but they do give us for

00:05:21,930 --> 00:05:26,970
example some consistency some

00:05:24,450 --> 00:05:29,760
consistency guarantees so we want to use

00:05:26,970 --> 00:05:31,650
that right and we want to use the way we

00:05:29,760 --> 00:05:33,150
can define the schema and most

00:05:31,650 --> 00:05:36,090
importantly I think we wants to be able

00:05:33,150 --> 00:05:38,670
to issue sequel queries to explore our

00:05:36,090 --> 00:05:41,130
data we want to make it possible for

00:05:38,670 --> 00:05:44,130
business analysts to use sequel as they

00:05:41,130 --> 00:05:48,000
did before to query the data so how are

00:05:44,130 --> 00:05:50,840
we going to do that and now there are

00:05:48,000 --> 00:05:53,910
also a number of other approaches and

00:05:50,840 --> 00:05:55,980
which usually use a no simple data store

00:05:53,910 --> 00:05:57,270
and they are eventually consistent so

00:05:55,980 --> 00:05:59,970
they have different challenges and

00:05:57,270 --> 00:06:02,580
different benefits so for example events

00:05:59,970 --> 00:06:05,490
store ARCA persistence on and eventuate

00:06:02,580 --> 00:06:07,530
and it's our great great solutions but

00:06:05,490 --> 00:06:10,920
they maybe fit a bit of different use

00:06:07,530 --> 00:06:13,320
cases than the ones that fit like as a

00:06:10,920 --> 00:06:16,500
replacement for crud application so what

00:06:13,320 --> 00:06:20,480
we are going to try to do here ok

00:06:16,500 --> 00:06:23,330
so being most more more specific and

00:06:20,480 --> 00:06:26,280
events in our case it will always be

00:06:23,330 --> 00:06:29,580
immutable so once an event happens it

00:06:26,280 --> 00:06:32,700
never changes it says something about

00:06:29,580 --> 00:06:35,340
what already happened so events will be

00:06:32,700 --> 00:06:37,950
always expressed in past tense right for

00:06:35,340 --> 00:06:39,870
example user registered which means that

00:06:37,950 --> 00:06:41,820
a user has registered in our system and

00:06:39,870 --> 00:06:43,620
the events will be the primary source of

00:06:41,820 --> 00:06:45,150
truth in

00:06:43,620 --> 00:06:49,290
in another system everything else will

00:06:45,150 --> 00:06:53,220
be derived on a more implementation

00:06:49,290 --> 00:06:55,560
level so events will be modeled as case

00:06:53,220 --> 00:06:58,169
classes and they will be sterilized to

00:06:55,560 --> 00:07:01,380
JSON for storage in the database each

00:06:58,169 --> 00:07:02,940
event has a certain type the type would

00:07:01,380 --> 00:07:05,760
typically be the name of the case class

00:07:02,940 --> 00:07:10,199
and now each events has such as user

00:07:05,760 --> 00:07:12,330
user registered can be bound to some

00:07:10,199 --> 00:07:14,330
aggregate so the aggregate for example

00:07:12,330 --> 00:07:17,310
can be used right so this event is about

00:07:14,330 --> 00:07:19,680
something some entity in our system some

00:07:17,310 --> 00:07:21,830
aggregate so we can have many events for

00:07:19,680 --> 00:07:25,650
a single aggregate like user registered

00:07:21,830 --> 00:07:27,900
user added a friend and and and so on so

00:07:25,650 --> 00:07:29,729
of course an event has a unique ID a

00:07:27,900 --> 00:07:33,210
timestamp so we can you know track it

00:07:29,729 --> 00:07:35,340
track 11 time and many events can happen

00:07:33,210 --> 00:07:37,710
in a single transaction so we will also

00:07:35,340 --> 00:07:38,850
capture the transaction ID so all events

00:07:37,710 --> 00:07:41,370
in a single transaction would have the

00:07:38,850 --> 00:07:43,260
same front transaction ID and auditing

00:07:41,370 --> 00:07:46,410
purposes we may also for example want to

00:07:43,260 --> 00:07:49,910
capture the user ID which was log who

00:07:46,410 --> 00:07:52,830
was logged in and when the event was was

00:07:49,910 --> 00:07:55,229
created so that can be useful for for

00:07:52,830 --> 00:07:59,160
tracking and for blaming users for what

00:07:55,229 --> 00:08:02,010
they did okay so how are we going to do

00:07:59,160 --> 00:08:03,419
that so we have a relational database so

00:08:02,010 --> 00:08:07,289
of course with the events will be stored

00:08:03,419 --> 00:08:10,220
in in there so that will be a dedicated

00:08:07,289 --> 00:08:13,410
table where we will start the events and

00:08:10,220 --> 00:08:15,900
like a single table with all the events

00:08:13,410 --> 00:08:19,229
in them and now basing on the events

00:08:15,900 --> 00:08:22,349
will create a read model okay but what

00:08:19,229 --> 00:08:24,570
is important is is that we will update

00:08:22,349 --> 00:08:26,160
the read model basing on the event in

00:08:24,570 --> 00:08:28,740
the same transaction as writing the

00:08:26,160 --> 00:08:30,780
event so this gives us some quite nice

00:08:28,740 --> 00:08:33,390
consistency guarantees we don't have the

00:08:30,780 --> 00:08:34,950
gap between persisting the event and

00:08:33,390 --> 00:08:37,979
updating the read model that we have in

00:08:34,950 --> 00:08:39,900
other event sourcing architectures what

00:08:37,979 --> 00:08:44,640
this comes as a cost because we have to

00:08:39,900 --> 00:08:46,800
use transactions so the read model is

00:08:44,640 --> 00:08:50,790
quite similar to what a traditional crud

00:08:46,800 --> 00:08:52,770
model might be okay so when you will be

00:08:50,790 --> 00:08:56,420
issuing our sequel queries to explore

00:08:52,770 --> 00:09:03,740
the data we will be using our read model

00:08:56,420 --> 00:09:06,800
yes okay drink so going even on a more

00:09:03,740 --> 00:09:09,470
technical level and to talk to the

00:09:06,800 --> 00:09:11,720
database we will you're slick so slick

00:09:09,470 --> 00:09:14,570
has the concept of a dpi election and

00:09:11,720 --> 00:09:17,000
that's actually a description of actions

00:09:14,570 --> 00:09:18,740
that should be done to the database so

00:09:17,000 --> 00:09:21,790
for example if you asks like please

00:09:18,740 --> 00:09:24,920
insert this row or please run this query

00:09:21,790 --> 00:09:27,320
what you get is a is an action and

00:09:24,920 --> 00:09:29,870
Adebayo action and that's a description

00:09:27,320 --> 00:09:32,210
nothing is being actually run against

00:09:29,870 --> 00:09:34,970
the database yet it's only a description

00:09:32,210 --> 00:09:38,000
you can then execute that action and

00:09:34,970 --> 00:09:41,180
that will go to the database so why this

00:09:38,000 --> 00:09:43,820
two-step process well it's kind of like

00:09:41,180 --> 00:09:46,370
a three-mor not saying if you are if you

00:09:43,820 --> 00:09:48,830
are familiar with these things so the

00:09:46,370 --> 00:09:50,480
nice thing here is that you can get for

00:09:48,830 --> 00:09:52,190
example a bunch of actions from various

00:09:50,480 --> 00:09:53,810
places of your code and these are only

00:09:52,190 --> 00:09:56,990
like descriptions like they don't do

00:09:53,810 --> 00:09:59,660
anything right justice does descriptions

00:09:56,990 --> 00:10:01,910
so you can get a bunch of these sequence

00:09:59,660 --> 00:10:03,680
them into one big action and say that's

00:10:01,910 --> 00:10:07,370
transactional and that will be running

00:10:03,680 --> 00:10:09,290
as in a single transaction okay so this

00:10:07,370 --> 00:10:12,350
layer of abstraction that Slick's gives

00:10:09,290 --> 00:10:13,820
us that we will be using and these

00:10:12,350 --> 00:10:15,710
actions can be suppressed using flat

00:10:13,820 --> 00:10:20,090
maps over they form a monad but that's

00:10:15,710 --> 00:10:22,460
not really important right now okay so

00:10:20,090 --> 00:10:25,700
before we get coding just a quick

00:10:22,460 --> 00:10:28,340
overview of the flow that that we will

00:10:25,700 --> 00:10:31,430
see here so what we'll see is that some

00:10:28,340 --> 00:10:33,290
user data comes into our system like the

00:10:31,430 --> 00:10:35,300
user name for the user to be ready to be

00:10:33,290 --> 00:10:37,490
registered and now everything will

00:10:35,300 --> 00:10:40,070
happen in a single transaction okay so

00:10:37,490 --> 00:10:41,960
that user data comes into a comment so

00:10:40,070 --> 00:10:45,470
the comment is a normal SCARA method

00:10:41,960 --> 00:10:47,630
accepting some some user data so the

00:10:45,470 --> 00:10:50,960
comment like tells the system what to do

00:10:47,630 --> 00:10:53,840
right so the command can now use the

00:10:50,960 --> 00:10:55,580
read model which is populated by the

00:10:53,840 --> 00:10:57,890
events right is it's a secondary thing

00:10:55,580 --> 00:11:00,800
and so the comment can use the read

00:10:57,890 --> 00:11:02,420
model to validate the user data for

00:11:00,800 --> 00:11:06,980
example check if the user with that

00:11:02,420 --> 00:11:09,200
username doesn't already exist so once

00:11:06,980 --> 00:11:10,270
that validation is done the command

00:11:09,200 --> 00:11:13,270
emits and

00:11:10,270 --> 00:11:15,430
of events okay so these events would

00:11:13,270 --> 00:11:19,000
persist it in the database but they also

00:11:15,430 --> 00:11:22,360
go into the event processor so the event

00:11:19,000 --> 00:11:25,360
processor now uses the registry the

00:11:22,360 --> 00:11:29,170
registry is just a bunch of maps from

00:11:25,360 --> 00:11:30,760
events type into to actions saying what

00:11:29,170 --> 00:11:33,820
should be done when this event is

00:11:30,760 --> 00:11:36,340
emitted and what can be done well to

00:11:33,820 --> 00:11:39,730
kind of things the first is a model

00:11:36,340 --> 00:11:42,100
update so basing on an event we can

00:11:39,730 --> 00:11:45,630
update our read model right so we can

00:11:42,100 --> 00:11:48,280
write new data to the read model and

00:11:45,630 --> 00:11:50,500
when we want to example recreate the

00:11:48,280 --> 00:11:52,650
system state at some point in time we

00:11:50,500 --> 00:11:57,430
will only run these model update

00:11:52,650 --> 00:11:58,630
functions okay yeah the other kind of

00:11:57,430 --> 00:12:01,270
thing that can happen is an event

00:11:58,630 --> 00:12:03,730
listener so an event listener will run

00:12:01,270 --> 00:12:05,530
some arbitrary side effects and business

00:12:03,730 --> 00:12:07,900
logic in reaction to an event and we

00:12:05,530 --> 00:12:10,270
wanted to run these events listeners

00:12:07,900 --> 00:12:12,160
only once when the event happens for

00:12:10,270 --> 00:12:14,140
example an event listener can send an

00:12:12,160 --> 00:12:16,420
email right we don't want to send an

00:12:14,140 --> 00:12:20,620
email every time we recreate our system

00:12:16,420 --> 00:12:23,320
State okay and so if the sum of the

00:12:20,620 --> 00:12:25,480
event listeners can you can use the

00:12:23,320 --> 00:12:27,730
other other data present in the read

00:12:25,480 --> 00:12:30,340
module and they can emit more events and

00:12:27,730 --> 00:12:33,820
they can interact with external systems

00:12:30,340 --> 00:12:36,580
okay now all of these components as we

00:12:33,820 --> 00:12:39,490
see in code they will usually be modeled

00:12:36,580 --> 00:12:40,780
by simple Scala methods and functions

00:12:39,490 --> 00:12:43,270
okay

00:12:40,780 --> 00:12:46,960
not just please make a kind of a mental

00:12:43,270 --> 00:12:51,100
picture as it might be useful like when

00:12:46,960 --> 00:12:53,050
we will translate this to code okay so

00:12:51,100 --> 00:12:58,420
now let's get to the actual coding part

00:12:53,050 --> 00:13:01,150
so I will be using a library which is

00:12:58,420 --> 00:13:04,930
called slick event sourcing so I think

00:13:01,150 --> 00:13:07,240
more of it about as a as a template not

00:13:04,930 --> 00:13:10,150
a really not a frame or anything like

00:13:07,240 --> 00:13:12,160
that it's more like a template that you

00:13:10,150 --> 00:13:15,430
probably will have to copy and customize

00:13:12,160 --> 00:13:17,500
when you want to to write your own

00:13:15,430 --> 00:13:21,160
application in that way it's just there

00:13:17,500 --> 00:13:22,230
some it's very short it's a quite simple

00:13:21,160 --> 00:13:23,820
code

00:13:22,230 --> 00:13:26,250
but I'm not going to write it all

00:13:23,820 --> 00:13:28,230
because I don't have time for that

00:13:26,250 --> 00:13:32,010
but well you want to see wanted confines

00:13:28,230 --> 00:13:33,870
okay so the first entry point where

00:13:32,010 --> 00:13:39,470
commands right so first what we need to

00:13:33,870 --> 00:13:44,760
do is we need to write our commands and

00:13:39,470 --> 00:13:46,500
so what what what what is definition

00:13:44,760 --> 00:13:48,660
what is the application going to do and

00:13:46,500 --> 00:13:51,020
so we are going to write a simple app

00:13:48,660 --> 00:13:54,090
for

00:13:51,020 --> 00:13:55,800
signing up to buy a Tesla Model 3 car

00:13:54,090 --> 00:13:57,870
that's a very fashionable thing to do

00:13:55,800 --> 00:14:02,820
right after you buy an iPhone iPad you

00:13:57,870 --> 00:14:05,070
then you go buy a Tesla so and so we are

00:14:02,820 --> 00:14:07,520
we going to get to write an app which

00:14:05,070 --> 00:14:10,380
allows you to register to buy one and

00:14:07,520 --> 00:14:14,310
because it's a very scarce thing we were

00:14:10,380 --> 00:14:16,200
only allowed to buy one at a time ok so

00:14:14,310 --> 00:14:18,990
we will have a command called price

00:14:16,200 --> 00:14:22,800
place order it's a normal scalar method

00:14:18,990 --> 00:14:26,580
so far and that's the name of the person

00:14:22,800 --> 00:14:29,550
actually ordering the car ok so what

00:14:26,580 --> 00:14:33,810
should be the result type of this method

00:14:29,550 --> 00:14:35,880
and so the our command can either fail

00:14:33,810 --> 00:14:37,950
or succeed right because it can fail

00:14:35,880 --> 00:14:40,290
because you have already ordered one or

00:14:37,950 --> 00:14:43,320
not so the result type should be

00:14:40,290 --> 00:14:45,480
something either error so on the Left we

00:14:43,320 --> 00:14:47,760
have the error oh you'll need meaning

00:14:45,480 --> 00:14:51,270
that everything is fine and order is

00:14:47,760 --> 00:14:53,340
placed and however together with the

00:14:51,270 --> 00:14:56,040
with the result we also want to omit

00:14:53,340 --> 00:14:58,200
some events right so the command

00:14:56,040 --> 00:15:00,540
validates the data and emits some events

00:14:58,200 --> 00:15:04,440
so when it should return a topple and

00:15:00,540 --> 00:15:07,710
the list of event ok but it can also

00:15:04,440 --> 00:15:11,510
validate against the database so we have

00:15:07,710 --> 00:15:15,680
to wrap all of this into a DB IO action

00:15:11,510 --> 00:15:18,870
now that's quite an ugly type okay so

00:15:15,680 --> 00:15:21,450
that's why in the library I was I was

00:15:18,870 --> 00:15:24,960
mentioning there's a nice alias for that

00:15:21,450 --> 00:15:27,330
called command result string unit it I

00:15:24,960 --> 00:15:30,270
guess it kind of reveals the intention

00:15:27,330 --> 00:15:31,610
butter so we can go to the source and

00:15:30,270 --> 00:15:35,160
you can see that it's a type alias

00:15:31,610 --> 00:15:38,880
nothing magical just an areas

00:15:35,160 --> 00:15:42,030
saying exactly what we wrote in the code

00:15:38,880 --> 00:15:44,700
before okay so that's a command which

00:15:42,030 --> 00:15:48,060
either returns a string describing the

00:15:44,700 --> 00:15:49,800
failure or a unit meaning success okay

00:15:48,060 --> 00:15:51,240
so the first thing we are going to do is

00:15:49,800 --> 00:15:53,160
we actually have to check against the

00:15:51,240 --> 00:15:59,730
database if the person ordered a car or

00:15:53,160 --> 00:16:02,430
not and so um I have a class ready which

00:15:59,730 --> 00:16:05,720
allows us to read the the model but

00:16:02,430 --> 00:16:09,120
first let me show you the model so that

00:16:05,720 --> 00:16:11,640
is going to be our read model for the

00:16:09,120 --> 00:16:14,040
placed orders okay that's a very simple

00:16:11,640 --> 00:16:16,470
simple type of ID name and equipment

00:16:14,040 --> 00:16:18,210
which is optional okay I guess nobody

00:16:16,470 --> 00:16:19,650
should be surprised seeing that so

00:16:18,210 --> 00:16:22,140
that's one table that we are going that

00:16:19,650 --> 00:16:24,660
we have in our database the other table

00:16:22,140 --> 00:16:28,290
are events okay

00:16:24,660 --> 00:16:31,070
so events each event has an ID as I said

00:16:28,290 --> 00:16:34,050
that's the that's the service payload

00:16:31,070 --> 00:16:38,010
name of the case class the logged in

00:16:34,050 --> 00:16:40,890
user ID the timestamp and so on and also

00:16:38,010 --> 00:16:44,340
I have a mapping for the orders table

00:16:40,890 --> 00:16:47,190
into Scala and I have it read over here

00:16:44,340 --> 00:16:50,460
because it's a bit of a slick code right

00:16:47,190 --> 00:16:56,750
let me just go over it very quickly so

00:16:50,460 --> 00:17:00,120
that's how you map a table to a to a to

00:16:56,750 --> 00:17:03,440
Scala code so here you can see the table

00:17:00,120 --> 00:17:07,860
name and here we have the three columns

00:17:03,440 --> 00:17:11,340
defined as Scala metadata and you also

00:17:07,860 --> 00:17:12,930
ants like you have to say like which

00:17:11,340 --> 00:17:15,990
three columns should be used when

00:17:12,930 --> 00:17:18,420
selecting every all the the whole thing

00:17:15,990 --> 00:17:19,800
so I think ID name it and equipment I

00:17:18,420 --> 00:17:22,320
mean we say that these three columns

00:17:19,800 --> 00:17:25,140
should be converted to a Tesla order

00:17:22,320 --> 00:17:27,780
case class which is over here so the

00:17:25,140 --> 00:17:30,510
Tesla order is a representation of a

00:17:27,780 --> 00:17:33,930
single row from our read model I guess

00:17:30,510 --> 00:17:36,840
it's quite simple right so we have the

00:17:33,930 --> 00:17:40,170
read model over here right and here we

00:17:36,840 --> 00:17:42,600
have this color representation and so

00:17:40,170 --> 00:17:44,910
that's the Tesla order model that's our

00:17:42,600 --> 00:17:46,470
read model right it also has some helper

00:17:44,910 --> 00:17:48,510
classes so for example we can find all

00:17:46,470 --> 00:17:53,340
orders right and this

00:17:48,510 --> 00:17:55,140
which is an action which so with the

00:17:53,340 --> 00:17:57,300
action when run will give us a list of

00:17:55,140 --> 00:17:59,520
the or of all the orders right we can

00:17:57,300 --> 00:18:02,040
find by name which will give us an

00:17:59,520 --> 00:18:04,500
optional single order and we can also

00:18:02,040 --> 00:18:06,930
update the read model later with a new

00:18:04,500 --> 00:18:08,340
order but we will see that it okay so

00:18:06,930 --> 00:18:11,450
now what we want to do now the command

00:18:08,340 --> 00:18:17,900
wants to use the Tesla order model and

00:18:11,450 --> 00:18:21,360
we wants to find by find by name and

00:18:17,900 --> 00:18:24,690
that gives an action so we flat flat map

00:18:21,360 --> 00:18:27,420
it so you always flat map its color in

00:18:24,690 --> 00:18:29,690
case an order has been found for that

00:18:27,420 --> 00:18:36,480
person with we returned a failure

00:18:29,690 --> 00:18:39,420
command result of failure you already

00:18:36,480 --> 00:18:44,150
ordered one and the failed is a gonna

00:18:39,420 --> 00:18:46,740
and a convenience thing it just returns

00:18:44,150 --> 00:18:49,770
successful action which contains a left

00:18:46,740 --> 00:18:54,780
of the either no events no events the

00:18:49,770 --> 00:18:57,990
same okay going back here so if there

00:18:54,780 --> 00:19:00,510
are no orders in there are no orders

00:18:57,990 --> 00:19:02,430
well then we create our event right we

00:19:00,510 --> 00:19:04,890
want to omit an event so first we wants

00:19:02,430 --> 00:19:07,230
to we have to write that event so event

00:19:04,890 --> 00:19:11,610
will be a simple case class Tesla

00:19:07,230 --> 00:19:14,790
ordered for a given person okay so

00:19:11,610 --> 00:19:16,560
that's our event payload and it's in

00:19:14,790 --> 00:19:17,850
past tense right because this test has

00:19:16,560 --> 00:19:19,710
been ordered all right then

00:19:17,850 --> 00:19:22,700
that's going to be our event so our

00:19:19,710 --> 00:19:25,380
event is going to be we create the event

00:19:22,700 --> 00:19:27,420
that's the payload but we also have to

00:19:25,380 --> 00:19:30,780
wrap it in the metadata right the ID the

00:19:27,420 --> 00:19:33,090
time stamps and so on so that's where

00:19:30,780 --> 00:19:35,280
the library again comes in there's an

00:19:33,090 --> 00:19:37,560
event wrapper and we say that it's a new

00:19:35,280 --> 00:19:39,630
aggregate root so we can also bind it an

00:19:37,560 --> 00:19:41,520
existing arrogance right and this only

00:19:39,630 --> 00:19:43,740
populates the metadata fields

00:19:41,520 --> 00:19:45,600
automatically will also automatically

00:19:43,740 --> 00:19:48,090
create an ID for example using a

00:19:45,600 --> 00:19:50,700
generator so that we don't have to do it

00:19:48,090 --> 00:19:54,240
every time and now we say that it's a

00:19:50,700 --> 00:19:56,550
commands result dot accessible and we

00:19:54,240 --> 00:20:00,420
return a unit saying that everything is

00:19:56,550 --> 00:20:01,830
fine plus we omit the event well we

00:20:00,420 --> 00:20:02,340
don't be amid the event we just return

00:20:01,830 --> 00:20:05,419
it from the

00:20:02,340 --> 00:20:08,429
right so the the method will return

00:20:05,419 --> 00:20:11,909
right unit plus a list of events a

00:20:08,429 --> 00:20:18,750
single event okay we are wiring it all

00:20:11,909 --> 00:20:21,630
up a bit later so now the second thing

00:20:18,750 --> 00:20:23,279
to do is we have to say what should

00:20:21,630 --> 00:20:27,809
happen in the reaction to our events

00:20:23,279 --> 00:20:30,360
okay so remember that over here we had

00:20:27,809 --> 00:20:32,880
our model updates and our event

00:20:30,360 --> 00:20:36,059
listeners so let's write those right we

00:20:32,880 --> 00:20:39,270
have the command we omit the event now

00:20:36,059 --> 00:20:44,429
we have to write those so so let's do it

00:20:39,270 --> 00:20:46,409
mmm event listeners and we will need an

00:20:44,429 --> 00:20:48,029
implicit execution context that's

00:20:46,409 --> 00:20:50,700
something you always need in Scala as

00:20:48,029 --> 00:20:52,919
well and now event listener we will

00:20:50,700 --> 00:20:56,600
simply send us an email to the customer

00:20:52,919 --> 00:21:01,580
saying that it was successful sent

00:20:56,600 --> 00:21:05,580
customers and customer notification and

00:21:01,580 --> 00:21:09,450
it's an event listener for the Tesla

00:21:05,580 --> 00:21:11,250
ordered event so let's again a type

00:21:09,450 --> 00:21:14,429
alias so what is it

00:21:11,250 --> 00:21:16,679
let's go so an event listener is a

00:21:14,429 --> 00:21:17,549
function it's a plain scalar function

00:21:16,679 --> 00:21:20,429
okay

00:21:17,549 --> 00:21:23,490
it takes an event like we have defined

00:21:20,429 --> 00:21:26,100
before with payload of type T and what

00:21:23,490 --> 00:21:29,039
it does it returns an action because we

00:21:26,100 --> 00:21:31,470
can use the read model in our event

00:21:29,039 --> 00:21:34,919
it turns an action which can you know

00:21:31,470 --> 00:21:37,890
run any side-effects and it can also

00:21:34,919 --> 00:21:39,510
emit some events okay so this

00:21:37,890 --> 00:21:41,760
corresponds so the list of events

00:21:39,510 --> 00:21:43,230
emitted corresponds to this arrow and we

00:21:41,760 --> 00:21:44,700
can also run some side effects which

00:21:43,230 --> 00:21:47,789
isn't very visible in the type of

00:21:44,700 --> 00:21:49,890
function but whether you can we'll see

00:21:47,789 --> 00:21:51,299
in a second how okay so that's that

00:21:49,890 --> 00:21:55,890
that's a function since it's a function

00:21:51,299 --> 00:21:59,970
we take in an event let's see and and

00:21:55,890 --> 00:22:02,450
now we have an email service ready send

00:21:59,970 --> 00:22:04,590
email so we can go check out the

00:22:02,450 --> 00:22:06,210
implementation it's not doing a print

00:22:04,590 --> 00:22:08,880
line it's a very simple email service

00:22:06,210 --> 00:22:11,909
but it works and it doesn't send send

00:22:08,880 --> 00:22:15,710
email though so we will sign the email

00:22:11,909 --> 00:22:19,940
your Tesla Model 3

00:22:15,710 --> 00:22:26,600
Sorry Sorry Oh we'll be ready in a

00:22:19,940 --> 00:22:27,380
couple of years yeah okay so well we are

00:22:26,600 --> 00:22:31,400
not ready yet

00:22:27,380 --> 00:22:33,620
they send email oh that's small so the

00:22:31,400 --> 00:22:35,750
same email it's like it just returns a

00:22:33,620 --> 00:22:38,120
future right it's an a synchronous email

00:22:35,750 --> 00:22:41,030
service it doesn't return Adebayo action

00:22:38,120 --> 00:22:42,920
luckily we can convert a future into the

00:22:41,030 --> 00:22:48,890
bi-election saying give me your action

00:22:42,920 --> 00:22:50,780
dot from and this wraps a future and

00:22:48,890 --> 00:22:53,900
returns like a fake D by your action

00:22:50,780 --> 00:22:56,870
okay but it we can use it together with

00:22:53,900 --> 00:23:01,730
other video actions just as well okay so

00:22:56,870 --> 00:23:04,730
that's our event listener and now that's

00:23:01,730 --> 00:23:06,950
not everything because we have to return

00:23:04,730 --> 00:23:09,920
a list of events to emit so we mapped

00:23:06,950 --> 00:23:12,800
the unit to an empty list no no no no

00:23:09,920 --> 00:23:16,700
further events emitted so for example

00:23:12,800 --> 00:23:18,140
here we could emit like add some extra

00:23:16,700 --> 00:23:19,520
equipment right because they are

00:23:18,140 --> 00:23:21,290
ordering early and that would be a new

00:23:19,520 --> 00:23:25,250
event which will be again processed by

00:23:21,290 --> 00:23:29,030
the same machinery and so model updates

00:23:25,250 --> 00:23:34,550
now and we need the test order model

00:23:29,030 --> 00:23:41,120
here and ok and again we will have an

00:23:34,550 --> 00:23:43,520
ordered updated and that will be a model

00:23:41,120 --> 00:23:48,140
update and we will see what is in a

00:23:43,520 --> 00:23:50,630
second order that's our events type ok

00:23:48,140 --> 00:23:54,290
so the model update again it's an alias

00:23:50,630 --> 00:23:57,140
for function so the function is quite

00:23:54,290 --> 00:23:59,420
similar it takes an event and it does

00:23:57,140 --> 00:24:01,640
something to the database right it

00:23:59,420 --> 00:24:04,760
doesn't return anything but what's

00:24:01,640 --> 00:24:07,640
important is the D bio action here has

00:24:04,760 --> 00:24:09,620
an additional effects type parameter

00:24:07,640 --> 00:24:13,070
saying what the direction can actually

00:24:09,620 --> 00:24:15,410
go to the database right and you can

00:24:13,070 --> 00:24:18,230
notice that in the event listener can

00:24:15,410 --> 00:24:20,180
only read from the database and the

00:24:18,230 --> 00:24:22,160
model update we actually wants to write

00:24:20,180 --> 00:24:24,920
as well right because we update the read

00:24:22,160 --> 00:24:27,830
model so we have read we read with with

00:24:24,920 --> 00:24:29,270
right so on a type level you can also

00:24:27,830 --> 00:24:32,000
control what kind of

00:24:29,270 --> 00:24:38,930
you can do to the database unless you do

00:24:32,000 --> 00:24:41,870
a cost so then yeah that's that's quite

00:24:38,930 --> 00:24:43,490
easy Tesla or their mother update no now

00:24:41,870 --> 00:24:46,400
we have to create a representation of

00:24:43,490 --> 00:24:48,740
the row in the database so from the

00:24:46,400 --> 00:24:53,120
Tesla ordered event we create a Tesla

00:24:48,740 --> 00:24:55,340
order database row right so we take the

00:24:53,120 --> 00:24:56,960
aggregate ID which will be automatically

00:24:55,340 --> 00:24:59,930
generated because we said it's a new

00:24:56,960 --> 00:25:01,370
aggregate and from the data from from

00:24:59,930 --> 00:25:06,280
from the payload we will extract the

00:25:01,370 --> 00:25:09,740
name so the name here is this one and

00:25:06,280 --> 00:25:12,260
there's no extra equipment and it types

00:25:09,740 --> 00:25:16,070
okay that's good so now we have the

00:25:12,260 --> 00:25:19,040
three cases now what we need is this

00:25:16,070 --> 00:25:25,040
event processor and this this registry

00:25:19,040 --> 00:25:28,250
right so again here comes in the library

00:25:25,040 --> 00:25:29,690
that I mentioned you can take a look at

00:25:28,250 --> 00:25:32,540
the source code of it later is three

00:25:29,690 --> 00:25:34,970
very simple so the registry is here and

00:25:32,540 --> 00:25:37,040
it is just a wrapper for a bunch of maps

00:25:34,970 --> 00:25:40,600
from event type to a list of model

00:25:37,040 --> 00:25:40,600
updates and from event type the list of

00:25:40,990 --> 00:25:48,410
event listeners so let's let's use that

00:25:44,890 --> 00:25:53,890
so I'll just instantiate our commands

00:25:48,410 --> 00:25:56,570
here and commands this order model and

00:25:53,890 --> 00:26:01,640
we will need an instance of event

00:25:56,570 --> 00:26:03,920
listeners so it's just plain just plain

00:26:01,640 --> 00:26:06,110
scala objects nothing really complicated

00:26:03,920 --> 00:26:13,520
right just plain scary objects and

00:26:06,110 --> 00:26:14,060
functions so far updates that's our

00:26:13,520 --> 00:26:17,120
motto

00:26:14,060 --> 00:26:19,610
okay so yeah this that's just a normal

00:26:17,120 --> 00:26:21,200
scarlet class right and it contains a

00:26:19,610 --> 00:26:24,290
value which is a which is a function

00:26:21,200 --> 00:26:26,030
right you can even well maybe not unit

00:26:24,290 --> 00:26:29,450
tested because it touches the database

00:26:26,030 --> 00:26:31,580
but right a quite lightweight test which

00:26:29,450 --> 00:26:33,020
verifies that this function does what it

00:26:31,580 --> 00:26:35,150
should do okay

00:26:33,020 --> 00:26:40,010
it doesn't have any dependencies except

00:26:35,150 --> 00:26:43,070
the read model okay so now we are going

00:26:40,010 --> 00:26:44,860
to register an event listener

00:26:43,070 --> 00:26:49,280
so we are just passing in the function

00:26:44,860 --> 00:26:54,380
and we are going to register the model

00:26:49,280 --> 00:27:00,520
update okay so we have our our registry

00:26:54,380 --> 00:27:03,110
and now the last piece of the puzzle is

00:27:00,520 --> 00:27:05,120
so we have it command which returns the

00:27:03,110 --> 00:27:06,620
events that was just a tuple right it

00:27:05,120 --> 00:27:08,330
just returns the event and not nothing

00:27:06,620 --> 00:27:10,250
happened to them so we need to somehow

00:27:08,330 --> 00:27:13,220
feed them into the event processor and

00:27:10,250 --> 00:27:15,110
we are going to do that in a second okay

00:27:13,220 --> 00:27:18,110
so what we are going to do is I have a

00:27:15,110 --> 00:27:23,300
simple rest a wellness rest API doesn't

00:27:18,110 --> 00:27:26,630
HTTP API which we'll use for a demo in a

00:27:23,300 --> 00:27:28,160
second so let's in the routes so here I

00:27:26,630 --> 00:27:31,040
would have two endpoints for placing an

00:27:28,160 --> 00:27:34,040
order and listing on orders so the list

00:27:31,040 --> 00:27:38,000
on orders one is quite simple I'm using

00:27:34,040 --> 00:27:44,270
a package CP if if you don't recognize

00:27:38,000 --> 00:27:45,470
this beautiful API it's okay so what we

00:27:44,270 --> 00:27:46,820
need a minute here

00:27:45,470 --> 00:27:50,450
this will be our routes we need a couple

00:27:46,820 --> 00:27:52,280
of dependencies I will just quickly add

00:27:50,450 --> 00:27:55,490
them and explain in a second what they

00:27:52,280 --> 00:27:57,680
do we need the read model and we need

00:27:55,490 --> 00:27:59,840
the commands okay

00:27:57,680 --> 00:28:02,210
so first the endpoint bullet for listing

00:27:59,840 --> 00:28:05,210
orders so when we list orders what we do

00:28:02,210 --> 00:28:09,110
is we take the Tesla order model and we

00:28:05,210 --> 00:28:11,180
find all but this that's a description

00:28:09,110 --> 00:28:16,490
and now we have to run that against the

00:28:11,180 --> 00:28:19,250
database so we use the that's that's the

00:28:16,490 --> 00:28:25,550
slick DB object okay just wrap the neck

00:28:19,250 --> 00:28:29,360
configured configured class so we we use

00:28:25,550 --> 00:28:32,390
the run method to actually run the the

00:28:29,360 --> 00:28:36,200
action this kit has a future so now we

00:28:32,390 --> 00:28:39,440
wait and we wait until the future is

00:28:36,200 --> 00:28:46,169
done and when the future is done orders

00:28:39,440 --> 00:28:48,899
we just returned to the color complete

00:28:46,169 --> 00:28:51,649
and orders don't map by a single order

00:28:48,899 --> 00:28:54,330
we are going to just map it to its name

00:28:51,649 --> 00:28:57,809
and we are just going to return them as

00:28:54,330 --> 00:29:00,570
a list separated by new lines so not

00:28:57,809 --> 00:29:01,850
anything very sophisticated even the

00:29:00,570 --> 00:29:05,609
other way around very unsophisticated

00:29:01,850 --> 00:29:07,019
okay so let's that's listing the others

00:29:05,609 --> 00:29:10,049
now the more interesting part of course

00:29:07,019 --> 00:29:13,159
is actually running the command and

00:29:10,049 --> 00:29:18,119
fitting it into an event event processor

00:29:13,159 --> 00:29:20,249
okay so when we have when the place

00:29:18,119 --> 00:29:23,580
order endpoint is invoked right it's a

00:29:20,249 --> 00:29:26,279
post so that we somebody posted to our

00:29:23,580 --> 00:29:28,710
endpoint we extract the name of the

00:29:26,279 --> 00:29:30,509
person from the entity so again a very

00:29:28,710 --> 00:29:34,320
simple thing probably not what you would

00:29:30,509 --> 00:29:35,879
do in production but here it is so so

00:29:34,320 --> 00:29:39,690
the first thing we do is we take our

00:29:35,879 --> 00:29:41,940
commands and we invoke the place order

00:29:39,690 --> 00:29:45,149
method that we have just written okay

00:29:41,940 --> 00:29:47,009
with the name so that's that's the name

00:29:45,149 --> 00:29:50,850
that's the method here right which we

00:29:47,009 --> 00:29:54,570
have the command result so what we get

00:29:50,850 --> 00:29:56,220
here is a description of some DP actions

00:29:54,570 --> 00:29:59,460
which will result in either fail or

00:29:56,220 --> 00:30:01,200
success plus a list of events so nothing

00:29:59,460 --> 00:30:03,419
yet happened okay we just created a

00:30:01,200 --> 00:30:06,149
description nothing happened so what we

00:30:03,419 --> 00:30:09,239
want to do is we somehow want to convert

00:30:06,149 --> 00:30:12,809
a command result with fellow success

00:30:09,239 --> 00:30:16,649
into a future fail a success right but

00:30:12,809 --> 00:30:20,100
also running all the events as a as a

00:30:16,649 --> 00:30:22,889
side process so let's that's what the

00:30:20,100 --> 00:30:25,950
event machine does the event machine has

00:30:22,889 --> 00:30:28,799
a run method which takes in a command

00:30:25,950 --> 00:30:32,249
result and produces a future of an

00:30:28,799 --> 00:30:34,529
either FS right so let's Morris what

00:30:32,249 --> 00:30:39,359
what what what what want but it also

00:30:34,529 --> 00:30:40,590
uses the registry where all the mappings

00:30:39,359 --> 00:30:42,269
for the model updates and the event

00:30:40,590 --> 00:30:44,970
listeners are defined to actually run

00:30:42,269 --> 00:30:48,659
all the event logic ok again that class

00:30:44,970 --> 00:30:50,429
you can see that it's not long it's

00:30:48,659 --> 00:30:53,549
quite simple it's just you know

00:30:50,429 --> 00:30:55,919
forgiving it takes the command it takes

00:30:53,549 --> 00:31:00,000
the events looks up the model updates

00:30:55,919 --> 00:31:02,220
the event listeners invokes them

00:31:00,000 --> 00:31:05,970
puts it all in a single transaction and

00:31:02,220 --> 00:31:11,129
and runs it okay so we will run our

00:31:05,970 --> 00:31:12,750
command okay so we have now our command

00:31:11,129 --> 00:31:15,419
is run so we get the future so again we

00:31:12,750 --> 00:31:16,860
wait until the future is is done so this

00:31:15,419 --> 00:31:21,259
one's on success if you're not familiar

00:31:16,860 --> 00:31:23,460
with our HTTP that's a directive which

00:31:21,259 --> 00:31:25,049
waits until the future is well which

00:31:23,460 --> 00:31:31,980
runs called when the future is complete

00:31:25,049 --> 00:31:35,789
and responds to the to the caller and so

00:31:31,980 --> 00:31:40,919
when we get an error from our command we

00:31:35,789 --> 00:31:44,220
do a complete status code by the request

00:31:40,919 --> 00:31:46,590
and we send back the error and if

00:31:44,220 --> 00:31:50,580
everything moves fine we complete with

00:31:46,590 --> 00:31:55,230
them okay okay let's work let's try

00:31:50,580 --> 00:31:58,980
compile it it will find hopefully if it

00:31:55,230 --> 00:32:00,450
doesn't fail I'll be surprised it's

00:31:58,980 --> 00:32:03,419
failed because I didn't put in the

00:32:00,450 --> 00:32:05,759
dependencies here and so I need to wire

00:32:03,419 --> 00:32:10,399
this up if I was using an aversive

00:32:05,759 --> 00:32:14,730
course would be different then what okay

00:32:10,399 --> 00:32:16,980
and it will fail again but that's you

00:32:14,730 --> 00:32:17,399
know it's color doing the job for us

00:32:16,980 --> 00:32:20,190
right

00:32:17,399 --> 00:32:22,769
okay so what's last missing piece here

00:32:20,190 --> 00:32:25,409
is that we have to specify what is the

00:32:22,769 --> 00:32:27,120
aggregate for this event so there's a

00:32:25,409 --> 00:32:29,730
couple of ways to do it I'm going to do

00:32:27,120 --> 00:32:31,379
it with an implicit it's not very

00:32:29,730 --> 00:32:33,179
important that it's not like anything

00:32:31,379 --> 00:32:35,129
crucial it's just a technical

00:32:33,179 --> 00:32:39,659
requirement for of this library so

00:32:35,129 --> 00:32:42,139
implicit is an aggregate for event so we

00:32:39,659 --> 00:32:48,120
specify that for the Tesla ordered event

00:32:42,139 --> 00:32:50,370
the Tesla order is is our aggregate

00:32:48,120 --> 00:32:54,120
route okay so that's the event let's our

00:32:50,370 --> 00:32:58,799
aggregate okay so now let's try running

00:32:54,120 --> 00:33:01,820
it and we are missing an implicit

00:32:58,799 --> 00:33:01,820
execution context

00:33:04,059 --> 00:33:10,640
okay now I will be really surprised if

00:33:07,340 --> 00:33:13,880
it fails okay I did all the plant

00:33:10,640 --> 00:33:18,039
failures are used okay so we can see

00:33:13,880 --> 00:33:18,039
that something is running server started

00:33:19,120 --> 00:33:32,000
let me put a new okay localhost 8080 mmm

00:33:28,720 --> 00:33:34,399
okay so I didn't delete the testing data

00:33:32,000 --> 00:33:40,269
so that is there but we can place an

00:33:34,399 --> 00:33:44,870
order for let's say Kate order paste now

00:33:40,269 --> 00:33:48,169
so it's not very very dramatic but we

00:33:44,870 --> 00:33:50,659
can see what's happening in the logs so

00:33:48,169 --> 00:33:52,880
in the logs you can see that for example

00:33:50,659 --> 00:33:57,260
the event machine said that is handling

00:33:52,880 --> 00:34:00,080
an event right the event was sort here

00:33:57,260 --> 00:34:02,450
handling event right we have an

00:34:00,080 --> 00:34:04,669
auto-generated event ID that's the

00:34:02,450 --> 00:34:07,909
events type that's the aggregate type

00:34:04,669 --> 00:34:10,879
right sorry

00:34:07,909 --> 00:34:12,290
and that's our payload here okay so this

00:34:10,879 --> 00:34:14,030
is the event that we have written okay

00:34:12,290 --> 00:34:16,940
so what happened the command was run

00:34:14,030 --> 00:34:19,970
right the event was created and we can

00:34:16,940 --> 00:34:22,070
also see that our email service is

00:34:19,970 --> 00:34:26,000
working as expected it's print lining it

00:34:22,070 --> 00:34:29,869
sent the email that that it should we

00:34:26,000 --> 00:34:33,589
can navigate and it worked again but now

00:34:29,869 --> 00:34:36,440
if I try to add it for myself I will get

00:34:33,589 --> 00:34:40,669
an error because I already place and all

00:34:36,440 --> 00:34:43,490
right so that's that's when this branch

00:34:40,669 --> 00:34:46,310
kicked in and no event where omit that

00:34:43,490 --> 00:34:52,190
you can see that the only two events for

00:34:46,310 --> 00:35:01,339
the kites right okay actually not out of

00:34:52,190 --> 00:35:02,599
time so it's not all that nice there are

00:35:01,339 --> 00:35:06,800
some potential problems

00:35:02,599 --> 00:35:09,770
so one problems is that when we recreate

00:35:06,800 --> 00:35:11,690
the state of our system from existing

00:35:09,770 --> 00:35:13,619
events and when they are concurrent

00:35:11,690 --> 00:35:17,130
events

00:35:13,619 --> 00:35:18,990
the same aggregate root so there's some

00:35:17,130 --> 00:35:22,319
subtleties in how they should be ordered

00:35:18,990 --> 00:35:24,450
right so if we don't do anything it may

00:35:22,319 --> 00:35:26,430
end up that in the real system they have

00:35:24,450 --> 00:35:29,160
been ordered differently then when we

00:35:26,430 --> 00:35:31,499
when we restore the state so this can be

00:35:29,160 --> 00:35:32,970
mitigated using either optimistic or

00:35:31,499 --> 00:35:37,259
pessimistic clocking in the database

00:35:32,970 --> 00:35:40,710
like so so the usual solutions and when

00:35:37,259 --> 00:35:42,660
when using a relational DB another thing

00:35:40,710 --> 00:35:44,730
that some people don't like is that the

00:35:42,660 --> 00:35:47,970
DB of action the leaks quite high as an

00:35:44,730 --> 00:35:50,640
abstraction in your code right so in our

00:35:47,970 --> 00:35:53,220
case the bearer action went or all the

00:35:50,640 --> 00:35:55,499
way up to the roots in our demo right so

00:35:53,220 --> 00:35:59,819
well that was just a demo that's one

00:35:55,499 --> 00:36:02,099
thing another is that it can be a

00:35:59,819 --> 00:36:03,839
problem it can be a feature I sometimes

00:36:02,099 --> 00:36:06,390
see there's a feature because you see

00:36:03,839 --> 00:36:09,779
exactly which what code touches the

00:36:06,390 --> 00:36:11,400
database okay and I think it's gonna be

00:36:09,779 --> 00:36:13,499
a good saying that you look at something

00:36:11,400 --> 00:36:16,170
and you can see that this actually will

00:36:13,499 --> 00:36:17,309
talk to the database and the future

00:36:16,170 --> 00:36:19,489
wrapping that I'm showing you know if

00:36:17,309 --> 00:36:22,890
the sending image is also not perfect

00:36:19,489 --> 00:36:25,049
because the DBR action should describe

00:36:22,890 --> 00:36:26,940
actions which are not yet running right

00:36:25,049 --> 00:36:29,549
and we have wrapped an existing a

00:36:26,940 --> 00:36:31,410
running future there's no way to wrap

00:36:29,549 --> 00:36:33,390
like a future producer or something like

00:36:31,410 --> 00:36:35,460
that so what these are like

00:36:33,390 --> 00:36:39,049
problems that you I guess I can overcome

00:36:35,460 --> 00:36:42,539
so to summing up like our main approach

00:36:39,049 --> 00:36:45,119
like taking the library away so it's

00:36:42,539 --> 00:36:46,289
it's very small it's it's not needed to

00:36:45,119 --> 00:36:48,059
implement that approach just one

00:36:46,289 --> 00:36:50,099
proposition of how you can realize it in

00:36:48,059 --> 00:36:53,849
scala but the main thing that we have

00:36:50,099 --> 00:36:56,130
used are three functions okay these are

00:36:53,849 --> 00:36:59,519
simple functions which can be like

00:36:56,130 --> 00:37:01,829
almost unit tested so the first one was

00:36:59,519 --> 00:37:03,269
was the command when the comment was

00:37:01,829 --> 00:37:05,819
asked our method which took in some user

00:37:03,269 --> 00:37:07,609
data and produce a command result which

00:37:05,819 --> 00:37:09,749
is and the con result is a pair

00:37:07,609 --> 00:37:11,549
describing either failure or success and

00:37:09,749 --> 00:37:14,279
the list of events to be emitted okay so

00:37:11,549 --> 00:37:16,400
it's a quite a simple function and you

00:37:14,279 --> 00:37:18,269
don't really get any of that

00:37:16,400 --> 00:37:20,460
infrastructure in there right so you

00:37:18,269 --> 00:37:23,099
don't in the command you don't see the

00:37:20,460 --> 00:37:25,529
event machine you don't see end of the

00:37:23,099 --> 00:37:27,290
event processing and so on so just quite

00:37:25,529 --> 00:37:28,580
pure logic you

00:37:27,290 --> 00:37:30,470
so I have the eventlistener which

00:37:28,580 --> 00:37:33,140
describe the side-effects which should

00:37:30,470 --> 00:37:34,910
happen right so far it's a function

00:37:33,140 --> 00:37:36,590
which takes in an event and returns a

00:37:34,910 --> 00:37:39,080
list of further events which should be

00:37:36,590 --> 00:37:40,700
emitted - plus some side effects and it

00:37:39,080 --> 00:37:42,050
can use the database and you have the

00:37:40,700 --> 00:37:45,770
model updates which can be safely

00:37:42,050 --> 00:37:47,840
recreated many times so also for example

00:37:45,770 --> 00:37:51,920
if you want at some point to introduce a

00:37:47,840 --> 00:37:56,000
new projection of of your events to a

00:37:51,920 --> 00:37:59,600
new planet a new read model you can just

00:37:56,000 --> 00:38:01,460
you know rerun all of your events using

00:37:59,600 --> 00:38:03,770
only these new model update functions

00:38:01,460 --> 00:38:05,450
right so we can amend an existing read

00:38:03,770 --> 00:38:07,970
model with a new table let's say a new

00:38:05,450 --> 00:38:09,890
projection which you need for efficiency

00:38:07,970 --> 00:38:12,470
reasons or something that and you can

00:38:09,890 --> 00:38:14,540
just rerun all the events to populate it

00:38:12,470 --> 00:38:16,850
there's no reason why you can do that

00:38:14,540 --> 00:38:18,170
right so the the read model does have to

00:38:16,850 --> 00:38:19,970
be normalized in any way you can

00:38:18,170 --> 00:38:22,550
d normalize as much as you can because

00:38:19,970 --> 00:38:26,450
it is secondary anyway it's not the

00:38:22,550 --> 00:38:28,250
primary source of truth and okay so some

00:38:26,450 --> 00:38:31,220
links this presentation of course is

00:38:28,250 --> 00:38:34,160
available on github and the code they

00:38:31,220 --> 00:38:36,910
saw the library and I was using is also

00:38:34,160 --> 00:38:39,170
on github I would again outside small

00:38:36,910 --> 00:38:44,270
skeleton which you should customize then

00:38:39,170 --> 00:38:46,250
a library so to use unchanged this along

00:38:44,270 --> 00:38:49,580
with me it was probably longer than the

00:38:46,250 --> 00:38:52,790
actual code explained to explain what it

00:38:49,580 --> 00:38:55,610
does for clinically away and ok so

00:38:52,790 --> 00:38:57,920
thanks I'm here until tomorrow so if you

00:38:55,610 --> 00:39:01,310
have any questions please please catch

00:38:57,920 --> 00:39:04,280
me and I have some also some stickers

00:39:01,310 --> 00:39:06,290
with me with of Scala times and we even

00:39:04,280 --> 00:39:09,550
have I think five minutes for questions

00:39:06,290 --> 00:39:09,550
if you if you would have

00:39:18,510 --> 00:39:25,240
hi one question wouldn't make sense to

00:39:21,610 --> 00:39:29,830
to model this as reactive streams like

00:39:25,240 --> 00:39:32,970
the events with with maybe yes so

00:39:29,830 --> 00:39:36,160
luckily that's already done and so slick

00:39:32,970 --> 00:39:38,530
one of the variants of the DBR action is

00:39:36,160 --> 00:39:40,120
you can get a streaming result so you

00:39:38,530 --> 00:39:41,860
can for example get a stream of events

00:39:40,120 --> 00:39:44,230
like Iraq two stream of events quite

00:39:41,860 --> 00:39:49,000
easily so that's actually there's a

00:39:44,230 --> 00:39:52,390
third type parameter in there so in the

00:39:49,000 --> 00:39:55,060
DBR action you can see that there's the

00:39:52,390 --> 00:39:57,730
pipe that's wrapped there's the effects

00:39:55,060 --> 00:40:01,090
and there's this streaming specification

00:39:57,730 --> 00:40:04,450
okay so here's we we don't have the

00:40:01,090 --> 00:40:06,100
streaming but you can get as reactive

00:40:04,450 --> 00:40:11,500
stream of events reading from the

00:40:06,100 --> 00:40:13,120
database quite easily using sick yes I

00:40:11,500 --> 00:40:17,830
think in the beginning you said

00:40:13,120 --> 00:40:19,690
something about that one of the benefits

00:40:17,830 --> 00:40:21,850
from using event sourcing is that you

00:40:19,690 --> 00:40:24,280
can get increased scalability and that's

00:40:21,850 --> 00:40:27,190
something I've heard others say as well

00:40:24,280 --> 00:40:32,440
but I don't really see how you get that

00:40:27,190 --> 00:40:35,500
with this approach that's true oh okay

00:40:32,440 --> 00:40:37,450
so yeah I said that usually when you're

00:40:35,500 --> 00:40:40,150
talking about event source architectures

00:40:37,450 --> 00:40:43,240
the main benefit is that you get

00:40:40,150 --> 00:40:44,770
scalability so here it's it's it's not

00:40:43,240 --> 00:40:47,230
it's true because we are using a

00:40:44,770 --> 00:40:50,050
relational database and as we know it's

00:40:47,230 --> 00:40:52,210
very often limits how how far can we

00:40:50,050 --> 00:40:54,610
scale and limits it's the main

00:40:52,210 --> 00:40:57,340
bottleneck in our performance right so

00:40:54,610 --> 00:40:59,260
if you want to scale beyond even a

00:40:57,340 --> 00:41:00,820
relational database cluster then you

00:40:59,260 --> 00:41:04,330
probably want to go and Cassandra or

00:41:00,820 --> 00:41:06,240
something that or Kafka or whatever then

00:41:04,330 --> 00:41:09,010
you should probably use at the other

00:41:06,240 --> 00:41:12,120
event sourcing libraries which I which I

00:41:09,010 --> 00:41:15,250
pointed out which are somewhere here and

00:41:12,120 --> 00:41:18,010
so yeah again it's it depends on your

00:41:15,250 --> 00:41:20,310
specific problem right so if you do need

00:41:18,010 --> 00:41:22,450
that scalability and that performance

00:41:20,310 --> 00:41:23,860
that's also a good reason to use event

00:41:22,450 --> 00:41:25,750
sourcing and then I would use for

00:41:23,860 --> 00:41:29,430
example a cup resistance or event rate

00:41:25,750 --> 00:41:31,230
if you want to add a few

00:41:29,430 --> 00:41:34,170
think that event sourcing is a good fit

00:41:31,230 --> 00:41:36,510
for your like more no no business

00:41:34,170 --> 00:41:38,850
process application something that as a

00:41:36,510 --> 00:41:41,520
replacement for a crowd architecture

00:41:38,850 --> 00:41:44,910
then I would go with that approach and

00:41:41,520 --> 00:41:46,170
also what is important is that like

00:41:44,910 --> 00:41:48,000
don't have to eventsource

00:41:46,170 --> 00:41:49,620
everything right you can have a couple

00:41:48,000 --> 00:41:51,630
of endpoints which actually use the

00:41:49,620 --> 00:41:55,980
whole event machinery and so on right

00:41:51,630 --> 00:41:57,660
the events and and and you know generate

00:41:55,980 --> 00:41:59,730
the event the read model and so on but

00:41:57,660 --> 00:42:01,440
some endpoints can just be traditional

00:41:59,730 --> 00:42:03,810
crowd endpoints where I don't need the

00:42:01,440 --> 00:42:07,740
history so let's this can coexist

00:42:03,810 --> 00:42:09,600
one one one by one but so this approach

00:42:07,740 --> 00:42:11,580
then you're basically are starting your

00:42:09,600 --> 00:42:15,210
audit log to a relational database or

00:42:11,580 --> 00:42:16,560
yeah well it the data so here is the

00:42:15,210 --> 00:42:18,900
relational database so that's what

00:42:16,560 --> 00:42:25,410
limits us in terms of scalability so

00:42:18,900 --> 00:42:27,840
that's here the event sourcing which I

00:42:25,410 --> 00:42:29,910
was hoping to explain on this slide so

00:42:27,840 --> 00:42:31,440
we are not trying to use event sourcing

00:42:29,910 --> 00:42:34,740
for scalability but for other reasons

00:42:31,440 --> 00:42:37,230
for not losing not to lose information

00:42:34,740 --> 00:42:38,940
to get an audit log and to be able to

00:42:37,230 --> 00:42:42,080
recreate the system state and probably

00:42:38,940 --> 00:42:42,080
for a couple of other reasons

00:42:52,579 --> 00:42:59,400
Thanks I'm an avid reader of your blog

00:42:55,499 --> 00:43:01,979
as you might know so yeah it's great but

00:42:59,400 --> 00:43:05,279
I can help but notice that does the same

00:43:01,979 --> 00:43:07,589
thing that you did with free moments but

00:43:05,279 --> 00:43:10,559
without free moments now that's okay but

00:43:07,589 --> 00:43:11,339
in if you can I'm saving material for

00:43:10,559 --> 00:43:14,059
another talk

00:43:11,339 --> 00:43:17,279
yeah but few times you mentioned that

00:43:14,059 --> 00:43:20,130
that that the methods used are almost

00:43:17,279 --> 00:43:21,900
unit testable I think that they are

00:43:20,130 --> 00:43:23,759
almost unit testable as you said

00:43:21,900 --> 00:43:26,059
precisely because you didn't use free

00:43:23,759 --> 00:43:29,069
moment and you fixed yourself on the PIO

00:43:26,059 --> 00:43:30,869
action which is a monarch whereas had

00:43:29,069 --> 00:43:33,269
you used free mana you would have had

00:43:30,869 --> 00:43:37,680
perfect just ability more or less

00:43:33,269 --> 00:43:40,650
because oh yes then you could write an

00:43:37,680 --> 00:43:44,400
interpreter which right so my question

00:43:40,650 --> 00:43:48,420
is why why sham the free Mona's out of

00:43:44,400 --> 00:43:50,699
the picture and well okay so I think the

00:43:48,420 --> 00:43:58,289
few Mona's a complicated thing a bit

00:43:50,699 --> 00:43:59,729
more than here so this is already some

00:43:58,289 --> 00:44:02,039
prize like transferring from a crowd

00:43:59,729 --> 00:44:03,959
architecture to you know the writing

00:44:02,039 --> 00:44:07,680
these functions and dissidents that's

00:44:03,959 --> 00:44:10,859
already some change of how we write

00:44:07,680 --> 00:44:13,109
things and I'm not sure I think Ramona's

00:44:10,859 --> 00:44:18,239
would be that beneficial in like a

00:44:13,109 --> 00:44:20,670
general use case so I think that this

00:44:18,239 --> 00:44:23,729
applies to much wider range of systems

00:44:20,670 --> 00:44:25,680
then the feminine approach would like I

00:44:23,729 --> 00:44:27,329
I know the benefits of free Mona's but

00:44:25,680 --> 00:44:29,699
they don't come for free they have their

00:44:27,329 --> 00:44:32,969
price in terms of like the mental

00:44:29,699 --> 00:44:34,410
complex you have to you know the time I

00:44:32,969 --> 00:44:36,599
have to spend reading the code so I

00:44:34,410 --> 00:44:38,489
understand that I I think at least

00:44:36,599 --> 00:44:41,009
that's that's that's my case I know

00:44:38,489 --> 00:44:43,890
maybe it's only me but it takes me

00:44:41,009 --> 00:44:46,709
longer to parse whatever the code does

00:44:43,890 --> 00:44:50,849
with a few Mona although you get all the

00:44:46,709 --> 00:44:54,900
benefits so and I know I hope the

00:44:50,849 --> 00:44:57,859
smallest answers hi

00:44:54,900 --> 00:45:00,660
how would you model the evolution of the

00:44:57,859 --> 00:45:03,060
the commands and of the events so maybe

00:45:00,660 --> 00:45:04,560
we want to add telephone number

00:45:03,060 --> 00:45:08,160
- our other how would you do that

00:45:04,560 --> 00:45:15,360
because question and so I guess what I

00:45:08,160 --> 00:45:16,620
would do is let's let's our logic here

00:45:15,360 --> 00:45:18,560
so hmm

00:45:16,620 --> 00:45:21,540
well for sure I would keep that class

00:45:18,560 --> 00:45:26,130
okay well maybe rename it to something

00:45:21,540 --> 00:45:29,220
like old but I would add anyone here as

00:45:26,130 --> 00:45:30,630
well with a phone number probably with

00:45:29,220 --> 00:45:36,480
our with the current library I would

00:45:30,630 --> 00:45:38,550
skip that name and probably not the good

00:45:36,480 --> 00:45:40,560
that's not a good idea but you would

00:45:38,550 --> 00:45:43,080
have again to change that so a phone

00:45:40,560 --> 00:45:45,270
number over here right and well you have

00:45:43,080 --> 00:45:48,540
these old events in the database right

00:45:45,270 --> 00:45:51,000
so you need to keep the modern updates

00:45:48,540 --> 00:45:53,550
and the modern update functions for

00:45:51,000 --> 00:45:55,020
these right so once whenever you you

00:45:53,550 --> 00:45:57,120
recreate the model you have to be able

00:45:55,020 --> 00:45:58,950
to handle that event and a bit read

00:45:57,120 --> 00:46:00,660
model may be using a default phone

00:45:58,950 --> 00:46:02,430
number something that and I would add a

00:46:00,660 --> 00:46:07,650
second model update function which would

00:46:02,430 --> 00:46:09,330
handle that well in a I guess it's

00:46:07,650 --> 00:46:11,310
always an option to you know modify the

00:46:09,330 --> 00:46:14,130
event but it kind of goes against the

00:46:11,310 --> 00:46:16,050
philosophy so and this also you know

00:46:14,130 --> 00:46:18,360
shows that there was once such an event

00:46:16,050 --> 00:46:22,140
right but then we added a phone number

00:46:18,360 --> 00:46:25,470
right this may be also important for

00:46:22,140 --> 00:46:27,750
example in the in the in the audit right

00:46:25,470 --> 00:46:29,100
that at some point in time our system

00:46:27,750 --> 00:46:30,780
didn't have the phone numbers and then

00:46:29,100 --> 00:46:33,180
we added the default ones or something

00:46:30,780 --> 00:46:34,440
like that so this can be this also is a

00:46:33,180 --> 00:46:39,240
piece of information that can be

00:46:34,440 --> 00:46:40,440
valuable I think so so yeah you can you

00:46:39,240 --> 00:46:43,590
know you're probably would need to add

00:46:40,440 --> 00:46:45,540
some support into the library for now

00:46:43,590 --> 00:46:47,520
it's a 1:1 mapping so the case last name

00:46:45,540 --> 00:46:48,870
is always the events type maybe there

00:46:47,520 --> 00:46:51,360
should be like in the registry maybe

00:46:48,870 --> 00:46:54,360
like an extra mapping which would allow

00:46:51,360 --> 00:47:02,070
you to rename this class to it to

00:46:54,360 --> 00:47:06,050
another events type okay I guess we're

00:47:02,070 --> 00:47:06,050

YouTube URL: https://www.youtube.com/watch?v=zxgWuO1LEF0


