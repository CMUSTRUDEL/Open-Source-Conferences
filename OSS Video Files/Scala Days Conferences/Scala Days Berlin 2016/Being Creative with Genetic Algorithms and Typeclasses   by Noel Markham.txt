Title: Being Creative with Genetic Algorithms and Typeclasses   by Noel Markham
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Typeclasses are a hidden gem of the Scala language. They provide an immense power not seen in imperative languages, and so their approach might be unusual or alien to those approaching Scala from an imperative background. I will show how typeclasses allow developers to effectively attach their own interfaces to code written by others. In this talk, I describe what a genetic algorithm is and provide an example implementation in Scala. Using this implementation, I will demonstrate how to define a specific typeclass for our problem. I will then derive several different implementations, showing how to get rock solid confidence in testing our algorithm - with the help of ScalaCheck - and then provide a completely different typeclass to provide a fun, visual and creative solution, illustrating the iterations and improvements as the genetic algorithmâ€™s fitness function runs. The talk will be particularly hands-on, with plenty of examples run directly from the REPL.
Captions: 
	00:00:03,210 --> 00:00:09,190
hi everyone thanks for coming my name is

00:00:06,850 --> 00:00:11,469
null there's a few faces in here I've

00:00:09,190 --> 00:00:13,990
met and seen before for those who don't

00:00:11,469 --> 00:00:16,000
know me like I said my name is null work

00:00:13,990 --> 00:00:17,410
for a company called 47 degrees where

00:00:16,000 --> 00:00:19,029
we're one of the gold sponsors on this

00:00:17,410 --> 00:00:23,320
conference we also made the Scala days

00:00:19,029 --> 00:00:25,060
app so 47 degrees mainly a company that

00:00:23,320 --> 00:00:28,180
deals in in consulting and developing

00:00:25,060 --> 00:00:30,090
and training so if that's something of

00:00:28,180 --> 00:00:32,320
interest and we have a booth here and

00:00:30,090 --> 00:00:33,670
think we've got about seven guys as well

00:00:32,320 --> 00:00:36,039
so we're all we're all pretty friendly

00:00:33,670 --> 00:00:37,749
so come and say hello if that's not

00:00:36,039 --> 00:00:40,390
enough we're also running a couple of

00:00:37,749 --> 00:00:41,949
competitions so there's a chance to win

00:00:40,390 --> 00:00:45,460
some headphones some beats headphones

00:00:41,949 --> 00:00:48,729
and also we run our own conference in

00:00:45,460 --> 00:00:50,069
october in southern spain which is a

00:00:48,729 --> 00:00:52,329
great time of year to go there so

00:00:50,069 --> 00:00:53,949
there's a chance to win some tickets to

00:00:52,329 --> 00:00:56,679
that and an accommodation for the

00:00:53,949 --> 00:01:00,670
conference ok so what i'm going to talk

00:00:56,679 --> 00:01:03,729
about today i want to introduce what

00:01:00,670 --> 00:01:05,290
type classes are some times when i've

00:01:03,729 --> 00:01:06,700
spoken with people who are particularly

00:01:05,290 --> 00:01:08,530
new to scala they kind of don't

00:01:06,700 --> 00:01:10,690
understand them and they're a little bit

00:01:08,530 --> 00:01:12,610
of a different concept from if you've

00:01:10,690 --> 00:01:14,590
come from Sayer a more object-oriented

00:01:12,610 --> 00:01:16,540
you know Java or C sharp background

00:01:14,590 --> 00:01:18,430
they're kind of that there are some

00:01:16,540 --> 00:01:21,370
similarities and the patterns do appear

00:01:18,430 --> 00:01:24,760
which I'll show but but to complete

00:01:21,370 --> 00:01:26,260
newcomers that they're not always not

00:01:24,760 --> 00:01:28,900
always intuitive and always what you

00:01:26,260 --> 00:01:31,210
expect and well I've done I've done a

00:01:28,900 --> 00:01:32,470
few talks in the past and I've always

00:01:31,210 --> 00:01:34,600
found them I've found them interesting

00:01:32,470 --> 00:01:36,370
but they've always been maybe a little

00:01:34,600 --> 00:01:39,070
bit dry you know it's how you use this

00:01:36,370 --> 00:01:41,680
library or here's some nice ways to work

00:01:39,070 --> 00:01:43,620
with enterprise libraries in a

00:01:41,680 --> 00:01:46,420
functional way and things like that and

00:01:43,620 --> 00:01:49,360
maybe it may be a little bit dry so I

00:01:46,420 --> 00:01:52,720
thought while I'm explaining type

00:01:49,360 --> 00:01:55,960
classes I'll do this hopefully in a more

00:01:52,720 --> 00:01:57,430
interesting way and maybe introduce a

00:01:55,960 --> 00:02:00,430
new concept around what genetic

00:01:57,430 --> 00:02:02,290
algorithm is and things like that so and

00:02:00,430 --> 00:02:05,440
see see how I got on with with making

00:02:02,290 --> 00:02:07,990
the two things work ok so here's what we

00:02:05,440 --> 00:02:09,700
going to talk about today well start

00:02:07,990 --> 00:02:12,460
with a pretty pretty clear definition

00:02:09,700 --> 00:02:14,319
hopefully of what a type class is well

00:02:12,460 --> 00:02:16,069
then take a bit of a sidestep and look

00:02:14,319 --> 00:02:18,920
at what genetic algorithm is

00:02:16,069 --> 00:02:21,920
and then we'll put the two together and

00:02:18,920 --> 00:02:24,650
hopefully make that work okay so type

00:02:21,920 --> 00:02:27,700
class what is a type class well it's

00:02:24,650 --> 00:02:30,680
quite clear adhoc polymorphism right

00:02:27,700 --> 00:02:32,180
well no right we need we need a bit

00:02:30,680 --> 00:02:34,280
better definition than this right you

00:02:32,180 --> 00:02:36,170
know when you start looking around and

00:02:34,280 --> 00:02:37,760
trying to get definitions of what time

00:02:36,170 --> 00:02:40,849
classes are this is a phrase you often

00:02:37,760 --> 00:02:42,709
come across and I mean it's correct and

00:02:40,849 --> 00:02:43,969
it's quite quite clear what it means but

00:02:42,709 --> 00:02:46,489
if you're not sure of this terminology

00:02:43,969 --> 00:02:48,739
or it's a completely new domain then it

00:02:46,489 --> 00:02:50,689
may be maybe a little bit strange okay

00:02:48,739 --> 00:02:53,900
so so that's less thing well where can

00:02:50,689 --> 00:02:57,010
we start well uh who in the room is

00:02:53,900 --> 00:03:01,549
maybe a Java background before scholar

00:02:57,010 --> 00:03:02,840
but who's right who's not okay right

00:03:01,549 --> 00:03:05,989
well that's good because we're gonna

00:03:02,840 --> 00:03:07,370
start with Java right okay so if you

00:03:05,989 --> 00:03:10,939
cast your mind back to the dark days

00:03:07,370 --> 00:03:13,370
when you were Java programmers you might

00:03:10,939 --> 00:03:16,879
remember there was a there's a class

00:03:13,370 --> 00:03:20,060
called a raise it had a method called

00:03:16,879 --> 00:03:22,069
salt on it still does actually and for

00:03:20,060 --> 00:03:23,750
those not from the Java background all

00:03:22,069 --> 00:03:26,419
that all this this definition is saying

00:03:23,750 --> 00:03:29,299
is that we've got a general type T and

00:03:26,419 --> 00:03:32,599
that we want to sort sort an array of

00:03:29,299 --> 00:03:34,669
teas but in order to sort the array of

00:03:32,599 --> 00:03:38,449
teas we need to know how to compare some

00:03:34,669 --> 00:03:41,060
teas and that's it right so clearly we

00:03:38,449 --> 00:03:42,560
don't know what a tears you know the

00:03:41,060 --> 00:03:44,449
compiler doesn't know nobody knows what

00:03:42,560 --> 00:03:47,000
the tears until until we want to

00:03:44,449 --> 00:03:48,979
actually use this but if we look at this

00:03:47,000 --> 00:03:51,530
comparator type it's it's got one real

00:03:48,979 --> 00:03:55,099
method on it and that's this compare

00:03:51,530 --> 00:03:58,699
takes a couple of teas and returns an

00:03:55,099 --> 00:04:00,439
int okay so you would imagine here if

00:03:58,699 --> 00:04:03,799
the two T's are equal and that integer

00:04:00,439 --> 00:04:05,689
is going to return 0 if one T is less

00:04:03,799 --> 00:04:08,900
than the other it be negative and vice

00:04:05,689 --> 00:04:12,259
versa okay so the nice thing is is that

00:04:08,900 --> 00:04:14,719
we can create our own types and then we

00:04:12,259 --> 00:04:17,359
can use that comparator to sort a raise

00:04:14,719 --> 00:04:20,509
of our type so say for instance still in

00:04:17,359 --> 00:04:21,799
Java land when we were writing pojos of

00:04:20,509 --> 00:04:24,380
course we'd have had getters and setters

00:04:21,799 --> 00:04:25,849
and equals and two string and some

00:04:24,380 --> 00:04:28,070
constructors probably and all that fun

00:04:25,849 --> 00:04:29,370
but let's just let's keep it slightly

00:04:28,070 --> 00:04:30,990
slightly saying

00:04:29,370 --> 00:04:32,490
okay I just want to create a new type

00:04:30,990 --> 00:04:34,380
here this you know the compiler Java

00:04:32,490 --> 00:04:36,330
doesn't know anything about this type we

00:04:34,380 --> 00:04:38,430
wrote this and all it does it holds an

00:04:36,330 --> 00:04:40,410
integer so clearly because this is not

00:04:38,430 --> 00:04:42,690
an integer it doesn't know you know Java

00:04:40,410 --> 00:04:44,910
doesn't know how to sort this if you get

00:04:42,690 --> 00:04:48,090
to int olders it doesn't know what

00:04:44,910 --> 00:04:50,130
sorting the means okay but we can create

00:04:48,090 --> 00:04:51,710
our own comparator here so again we're

00:04:50,130 --> 00:04:53,880
still still just right in plain old java

00:04:51,710 --> 00:04:56,940
we implement this comparator interface

00:04:53,880 --> 00:05:00,180
for our in told er we grab the integers

00:04:56,940 --> 00:05:02,880
we subtract one from the other so now

00:05:00,180 --> 00:05:05,360
now we can use this for our own type

00:05:02,880 --> 00:05:08,430
okay we can now sort collections or

00:05:05,360 --> 00:05:10,560
arrays that contain our type so here's

00:05:08,430 --> 00:05:12,000
an example using the scholar Apple

00:05:10,560 --> 00:05:14,850
because it's quite handy for things like

00:05:12,000 --> 00:05:18,690
this so we got an array with a couple of

00:05:14,850 --> 00:05:21,120
these in and as you'd expect you know 50

00:05:18,690 --> 00:05:23,850
is less than 100 so if we sorted this

00:05:21,120 --> 00:05:26,100
we'd expect the order to change of

00:05:23,850 --> 00:05:28,770
course the sort method is mutable which

00:05:26,100 --> 00:05:32,100
makes me twitch but we can then sort

00:05:28,770 --> 00:05:33,930
this using our comparator and then when

00:05:32,100 --> 00:05:37,289
we inspect what's in our in our array

00:05:33,930 --> 00:05:38,669
you can see now that that that's that's

00:05:37,289 --> 00:05:41,010
what's happened is that these have been

00:05:38,669 --> 00:05:43,800
sorted the sort method used our

00:05:41,010 --> 00:05:45,990
comparator to to iterate over over the

00:05:43,800 --> 00:05:48,930
values in the array and work out where

00:05:45,990 --> 00:05:50,400
the ordering should go and so I mean I'm

00:05:48,930 --> 00:05:52,590
going to I'm going to you know this is

00:05:50,400 --> 00:05:54,510
not a full type class definition and

00:05:52,590 --> 00:05:57,060
we'll look at this in a bit more detail

00:05:54,510 --> 00:05:59,520
now and maybe we'll see how this works

00:05:57,060 --> 00:06:01,320
works in Scala and what I'm going to

00:05:59,520 --> 00:06:03,690
show is a very similar example to what

00:06:01,320 --> 00:06:06,000
we just looked at in Java land but I've

00:06:03,690 --> 00:06:09,240
taken this straight from Martins paper

00:06:06,000 --> 00:06:11,669
which was introducing implicit into the

00:06:09,240 --> 00:06:13,199
language so I'll send these slides

00:06:11,669 --> 00:06:15,660
around afterwards I put them on Twitter

00:06:13,199 --> 00:06:17,310
and they'll be as part of the video and

00:06:15,660 --> 00:06:21,150
things and you know this links directly

00:06:17,310 --> 00:06:23,430
through to to the to the paper ok so in

00:06:21,150 --> 00:06:25,949
the paper we have this this trait here

00:06:23,430 --> 00:06:28,289
called odd again it's parameterised on

00:06:25,949 --> 00:06:30,330
this type T and then we have a compare

00:06:28,289 --> 00:06:32,280
method and you might remember the java

00:06:30,330 --> 00:06:34,680
the java method it returned identity

00:06:32,280 --> 00:06:36,120
this returns a boolean and I mean that

00:06:34,680 --> 00:06:38,370
you can debate and whether this is a

00:06:36,120 --> 00:06:40,770
good API or what but that's kind of not

00:06:38,370 --> 00:06:41,760
why we're here but the raw we can take

00:06:40,770 --> 00:06:45,840
from this is that

00:06:41,760 --> 00:06:47,910
this will compare to tease and if if a

00:06:45,840 --> 00:06:49,920
is less than B it will return true okay

00:06:47,910 --> 00:06:54,180
whatever whatever that means for the

00:06:49,920 --> 00:06:57,030
type we want to use it for okay so we

00:06:54,180 --> 00:06:58,620
need to create an awed instance now for

00:06:57,030 --> 00:07:01,230
the specific type we want to be

00:06:58,620 --> 00:07:03,510
comparing with so here's how we do it

00:07:01,230 --> 00:07:06,740
with integers we just implement the

00:07:03,510 --> 00:07:10,800
audio interface or the odd trait sorry

00:07:06,740 --> 00:07:13,290
it's a simple simple implementation as

00:07:10,800 --> 00:07:15,060
you'd expect and now we can use this

00:07:13,290 --> 00:07:18,570
wherever we want so say we wrote our own

00:07:15,060 --> 00:07:21,600
sort method and we parameterize this is

00:07:18,570 --> 00:07:24,090
that if we have a list of some type T

00:07:21,600 --> 00:07:26,850
and as long as we can provide some kind

00:07:24,090 --> 00:07:29,400
of ordering for that type T then we can

00:07:26,850 --> 00:07:31,740
use this method here so this will take a

00:07:29,400 --> 00:07:34,710
list sort it and return us a new list in

00:07:31,740 --> 00:07:37,590
sorted order for whatever sorted means

00:07:34,710 --> 00:07:38,820
for that type T and this this you know

00:07:37,590 --> 00:07:41,820
this would work as expect with what

00:07:38,820 --> 00:07:44,130
we've looked at here we give an array we

00:07:41,820 --> 00:07:46,650
give a list in reverse order we pass our

00:07:44,130 --> 00:07:49,800
ordering and it returns us one in the in

00:07:46,650 --> 00:07:53,490
the correct way so what you can see

00:07:49,800 --> 00:07:55,500
maybe this is like the Java one as well

00:07:53,490 --> 00:07:56,700
this is a bit it's a bit cumbersome it's

00:07:55,500 --> 00:07:58,710
a bit ugly you know we've got this

00:07:56,700 --> 00:08:00,900
backpack we've got to carry around with

00:07:58,710 --> 00:08:02,220
with all our orderings in it to make

00:08:00,900 --> 00:08:05,250
sure that we want to order things

00:08:02,220 --> 00:08:09,600
correctly and so it'd be quite nice if

00:08:05,250 --> 00:08:11,880
if that just wasn't there and so Skylar

00:08:09,600 --> 00:08:14,490
Skylar gives us the ability to do this

00:08:11,880 --> 00:08:16,890
and so we'll make a couple of tweaks to

00:08:14,490 --> 00:08:20,550
our implementation and all will do here

00:08:16,890 --> 00:08:24,810
is make our in toward object implicit

00:08:20,550 --> 00:08:26,790
and then we'll change our sort signature

00:08:24,810 --> 00:08:29,160
to have an implicit parameter for our

00:08:26,790 --> 00:08:32,340
ordering and then what we're saying here

00:08:29,160 --> 00:08:36,540
for our sort method is a compilation

00:08:32,340 --> 00:08:39,180
time we want to use this but whatever we

00:08:36,540 --> 00:08:42,210
whenever we call sort with the compiler

00:08:39,180 --> 00:08:44,940
must be able to find an implicit type

00:08:42,210 --> 00:08:48,120
for ordering of the type that we're

00:08:44,940 --> 00:08:51,300
looking for and that that's it so in

00:08:48,120 --> 00:08:53,850
this case we have an implicit in toward

00:08:51,300 --> 00:08:54,870
so that's for ordering int and so if we

00:08:53,850 --> 00:08:57,970
call this

00:08:54,870 --> 00:08:59,459
for integers we can see that this works

00:08:57,970 --> 00:09:01,660
and this kind of works as you'd expect

00:08:59,459 --> 00:09:02,890
this type parameter here I didn't need

00:09:01,660 --> 00:09:04,690
to put this here because the compiler

00:09:02,890 --> 00:09:06,730
smart enough to work out we're dealing

00:09:04,690 --> 00:09:09,550
with int I just wanted to be maybe a

00:09:06,730 --> 00:09:12,100
little bit clearer and so the nice thing

00:09:09,550 --> 00:09:14,500
is is that we we we have the ability to

00:09:12,100 --> 00:09:16,630
sort but we don't need that full context

00:09:14,500 --> 00:09:19,180
in in our faces but for something as

00:09:16,630 --> 00:09:20,529
simple as this and then the nice thing

00:09:19,180 --> 00:09:22,620
is is that if there's no implicit in

00:09:20,529 --> 00:09:24,640
scope say we wanted to sort with strings

00:09:22,620 --> 00:09:30,100
what do you does anyone have an idea

00:09:24,640 --> 00:09:34,480
what's going to happen here say again

00:09:30,100 --> 00:09:36,760
sorry yep so what what's going to happen

00:09:34,480 --> 00:09:40,779
if I try and try and do this if there's

00:09:36,760 --> 00:09:44,730
no implicit for Strings I can't hear

00:09:40,779 --> 00:09:48,430
sorry yep compiler yep so there's no

00:09:44,730 --> 00:09:51,310
there's no magic here there's no default

00:09:48,430 --> 00:09:53,620
action there's nothing that that will

00:09:51,310 --> 00:09:55,480
happen in place there's no magic nothing

00:09:53,620 --> 00:09:57,519
like that literally we need to have an

00:09:55,480 --> 00:10:01,209
implicit there for the type in which we

00:09:57,519 --> 00:10:02,410
want to work with and so let's just try

00:10:01,209 --> 00:10:04,329
and make this a bit more general because

00:10:02,410 --> 00:10:07,810
what we've seen here is is a tight class

00:10:04,329 --> 00:10:10,570
and so for a function which is

00:10:07,810 --> 00:10:12,250
parameterised for a certain type if we

00:10:10,570 --> 00:10:15,610
have an implicit parameter which needs

00:10:12,250 --> 00:10:17,519
to use that implicit that that type that

00:10:15,610 --> 00:10:19,810
is generally what a type classes and

00:10:17,519 --> 00:10:22,510
this might look a bit cumbersome in a

00:10:19,810 --> 00:10:25,149
bit strange and maybe you kind of don't

00:10:22,510 --> 00:10:26,350
like this but once you notice this and

00:10:25,149 --> 00:10:28,449
once you realize that this is where the

00:10:26,350 --> 00:10:32,440
type class is is that you start to see

00:10:28,449 --> 00:10:34,269
this pattern everywhere and the way to

00:10:32,440 --> 00:10:36,820
think about this and this is quite a

00:10:34,269 --> 00:10:39,790
nice way I like to work with type

00:10:36,820 --> 00:10:42,610
classes is you think of this as

00:10:39,790 --> 00:10:45,610
enhancing the type is that we've taken

00:10:42,610 --> 00:10:48,519
integers in our example here and we've

00:10:45,610 --> 00:10:52,029
provided our own way to sort these by

00:10:48,519 --> 00:10:54,699
the rules that we've set so what this is

00:10:52,029 --> 00:10:57,310
really saying is we can add our own

00:10:54,699 --> 00:11:00,010
interface on to other people's classes

00:10:57,310 --> 00:11:02,290
you know we didn't write the int type

00:11:00,010 --> 00:11:04,600
but we've managed to sort it to the

00:11:02,290 --> 00:11:06,610
rules we want to and then if we create

00:11:04,600 --> 00:11:08,230
our own brand new type like I did with

00:11:06,610 --> 00:11:11,860
the int older for Java

00:11:08,230 --> 00:11:14,530
is that we can then provide ordering for

00:11:11,860 --> 00:11:16,120
that we can use another library which

00:11:14,530 --> 00:11:18,340
gives us our own types and if we want

00:11:16,120 --> 00:11:20,200
ordering four types in that library we

00:11:18,340 --> 00:11:21,580
can provide that here and I think this

00:11:20,200 --> 00:11:24,160
is really quite powerful this is not

00:11:21,580 --> 00:11:27,130
something you generally get with Java I

00:11:24,160 --> 00:11:29,170
mean I showed a way to do it but it's

00:11:27,130 --> 00:11:31,420
not really the way things are done in

00:11:29,170 --> 00:11:33,220
the kind of object-oriented world is

00:11:31,420 --> 00:11:35,950
that things tend to work with

00:11:33,220 --> 00:11:37,890
inheritance so you would have to inherit

00:11:35,950 --> 00:11:41,200
you know you'd have to extend say

00:11:37,890 --> 00:11:43,240
comparable or similar and what that

00:11:41,200 --> 00:11:45,730
means is that that needs to be set at

00:11:43,240 --> 00:11:48,220
the compilation time of the original

00:11:45,730 --> 00:11:51,160
type but now we've got this way to add

00:11:48,220 --> 00:11:52,750
our own implementations onto a given

00:11:51,160 --> 00:11:55,780
type and then we can make this really

00:11:52,750 --> 00:11:57,280
really comfortable by using the enhanced

00:11:55,780 --> 00:11:59,020
my library techniques that come with

00:11:57,280 --> 00:12:01,630
Scarlett you know where it looks like

00:11:59,020 --> 00:12:03,640
we've got our own methods on these types

00:12:01,630 --> 00:12:06,880
as well and this is what libraries like

00:12:03,640 --> 00:12:09,220
cats and scholars add did is that it

00:12:06,880 --> 00:12:11,740
gives us these extra functionalities on

00:12:09,220 --> 00:12:14,470
given types that are not part of that

00:12:11,740 --> 00:12:15,820
type in the first place but allows us to

00:12:14,470 --> 00:12:18,400
work with them in such a way and it's

00:12:15,820 --> 00:12:21,310
really quite powerful and so i'll just

00:12:18,400 --> 00:12:23,350
show another exam examples that you may

00:12:21,310 --> 00:12:25,840
be familiar with already those you play

00:12:23,350 --> 00:12:28,150
play and play Jason I mean the reeds

00:12:25,840 --> 00:12:30,220
type is a type class so it allows us to

00:12:28,150 --> 00:12:33,400
do things like this so we can extract

00:12:30,220 --> 00:12:35,170
some Jason some part of a Jason and then

00:12:33,400 --> 00:12:36,790
we can automatically convert this to a

00:12:35,170 --> 00:12:39,370
type and that's our type you know we

00:12:36,790 --> 00:12:41,470
wrote person you know we we have the

00:12:39,370 --> 00:12:44,380
ability to do this and if we drill down

00:12:41,470 --> 00:12:46,570
into how this actually works we come

00:12:44,380 --> 00:12:47,920
across a method that looks like this and

00:12:46,570 --> 00:12:50,020
this is what I was just saying this from

00:12:47,920 --> 00:12:53,770
Jason is parameterised on this tight tee

00:12:50,020 --> 00:12:55,810
and then we need an implicit reads t and

00:12:53,770 --> 00:12:58,030
then if we were to look at what that

00:12:55,810 --> 00:12:59,890
meant is that we could go into the reeds

00:12:58,030 --> 00:13:02,800
object and when we need to implement our

00:12:59,890 --> 00:13:05,170
own reads implicit for our type person

00:13:02,800 --> 00:13:06,790
will have to provide the rules that when

00:13:05,170 --> 00:13:08,980
we get some Jason we're going to have to

00:13:06,790 --> 00:13:10,930
drill in and find all the fields that

00:13:08,980 --> 00:13:12,850
make it a person and then there might be

00:13:10,930 --> 00:13:14,710
some rules for if the Jason is wrong and

00:13:12,850 --> 00:13:16,210
things like that but all it gives us

00:13:14,710 --> 00:13:18,880
then is that the ability to use this

00:13:16,210 --> 00:13:19,230
from Jason so go straight from Jason to

00:13:18,880 --> 00:13:21,960
any

00:13:19,230 --> 00:13:23,520
type and as long as we create created

00:13:21,960 --> 00:13:26,040
the rules for how to get to that type

00:13:23,520 --> 00:13:27,660
this will work and it's a really nice

00:13:26,040 --> 00:13:31,380
separation you know we've managed to

00:13:27,660 --> 00:13:34,410
keep the the use of extracting the the

00:13:31,380 --> 00:13:46,920
field into our object in the rules of

00:13:34,410 --> 00:13:50,220
how to do it as well okay hi yeah yeah

00:13:46,920 --> 00:13:51,690
that's that's a typo sorry yeah so yeah

00:13:50,220 --> 00:13:53,760
that's absolutely right that reads

00:13:51,690 --> 00:13:57,840
should be reads person sorry about that

00:13:53,760 --> 00:13:59,640
yep and then of course that you know

00:13:57,840 --> 00:14:02,970
there's the same thing works for rights

00:13:59,640 --> 00:14:06,030
as well okay another example if we look

00:14:02,970 --> 00:14:07,830
at same type level cats library the

00:14:06,030 --> 00:14:10,740
title of a cat's library makes a lot of

00:14:07,830 --> 00:14:12,180
use of type classes and so now that

00:14:10,740 --> 00:14:14,190
we're all familiar with type classes we

00:14:12,180 --> 00:14:16,400
might see some some signatures like this

00:14:14,190 --> 00:14:19,980
and hopefully this will make sense now

00:14:16,400 --> 00:14:21,480
no no it doesn't really does it but but

00:14:19,980 --> 00:14:24,540
what what what I really wanted to show

00:14:21,480 --> 00:14:27,270
here was that if we want to use this

00:14:24,540 --> 00:14:30,210
method or whatever whatever this means

00:14:27,270 --> 00:14:32,130
whatever these types mean is that we

00:14:30,210 --> 00:14:35,070
just need to make sure that we have this

00:14:32,130 --> 00:14:37,200
semigroup type in scope for whatever

00:14:35,070 --> 00:14:38,310
we're doing here and then you'll find

00:14:37,200 --> 00:14:40,260
that when you start to use these

00:14:38,310 --> 00:14:41,820
libraries a bit more you start to

00:14:40,260 --> 00:14:43,550
understand what what it means to work

00:14:41,820 --> 00:14:46,730
with a writer which is effectively a

00:14:43,550 --> 00:14:48,990
pending or writing to something and

00:14:46,730 --> 00:14:52,830
semigroups give us the ability to

00:14:48,990 --> 00:14:55,140
generically append so while we could

00:14:52,830 --> 00:14:56,910
have provided lots of ways to work with

00:14:55,140 --> 00:14:59,070
this you know we want to append to

00:14:56,910 --> 00:15:01,410
strings we want to append to files we

00:14:59,070 --> 00:15:03,600
want to append to lists we can just

00:15:01,410 --> 00:15:06,000
forget about that and say if you want to

00:15:03,600 --> 00:15:07,890
append to something just provide a

00:15:06,000 --> 00:15:09,510
semigroup for it and then if someone

00:15:07,890 --> 00:15:10,830
finds this really funky way in the

00:15:09,510 --> 00:15:13,440
future of doing these really cool

00:15:10,830 --> 00:15:19,380
appends it will work with this out of

00:15:13,440 --> 00:15:21,540
the box no questions asked okay so I

00:15:19,380 --> 00:15:24,150
have a bit of a proposal here is that I

00:15:21,540 --> 00:15:26,820
believe that implementing a genetic

00:15:24,150 --> 00:15:29,630
algorithm is actually a really really

00:15:26,820 --> 00:15:31,680
nice opportunity to use type classes

00:15:29,630 --> 00:15:33,510
okay so

00:15:31,680 --> 00:15:35,580
we'll take a sidestep and we'll look at

00:15:33,510 --> 00:15:38,430
exactly what the definition of what a

00:15:35,580 --> 00:15:41,760
genetic algorithm is okay so if we look

00:15:38,430 --> 00:15:43,680
from what wikipedia says it's a search

00:15:41,760 --> 00:15:47,370
heuristic that mimics the process of

00:15:43,680 --> 00:15:49,110
natural selection okay so we're really

00:15:47,370 --> 00:15:50,610
saying is that we're going to we're

00:15:49,110 --> 00:15:53,250
going to work with a population of

00:15:50,610 --> 00:15:54,690
something and the fitter one survived

00:15:53,250 --> 00:15:56,850
and then we're going to kind of

00:15:54,690 --> 00:16:01,970
reproduce this population and and see

00:15:56,850 --> 00:16:05,070
where we get us okay sorry question nope

00:16:01,970 --> 00:16:06,839
okay so okay let's look at what we're

00:16:05,070 --> 00:16:10,380
gonna do we're going to randomly

00:16:06,839 --> 00:16:13,890
generate some stuff work out which is

00:16:10,380 --> 00:16:16,050
the best then use that best to generate

00:16:13,890 --> 00:16:19,230
some more stuff and then we're just

00:16:16,050 --> 00:16:21,390
going to repeat that forever so this is

00:16:19,230 --> 00:16:24,480
the classic monkeys on typewriters doing

00:16:21,390 --> 00:16:26,070
Shakespeare isn't it but okay I mean I'm

00:16:24,480 --> 00:16:28,709
being I'm being a bit silly obviously

00:16:26,070 --> 00:16:30,300
but we'll we'll delve delve bit deeper

00:16:28,709 --> 00:16:33,029
into this so we need a way to kind of

00:16:30,300 --> 00:16:36,510
represent this this stuff what these

00:16:33,029 --> 00:16:39,060
things are so I think a nice thing we

00:16:36,510 --> 00:16:43,320
could do is is maybe have a binary

00:16:39,060 --> 00:16:46,740
string and so I suggest here we we use

00:16:43,320 --> 00:16:48,240
maybe a list of boolean's so I've used a

00:16:46,740 --> 00:16:50,490
vector here because that's a bit bit

00:16:48,240 --> 00:16:52,950
easier for random access if you're not

00:16:50,490 --> 00:16:54,540
comfortable with vectors they bait they

00:16:52,950 --> 00:16:57,959
have the same and kind of interfaces as

00:16:54,540 --> 00:17:00,270
working with a list okay and so just

00:16:57,959 --> 00:17:02,820
going back to my my basic slide a minute

00:17:00,270 --> 00:17:03,720
ago few more steps of what this is going

00:17:02,820 --> 00:17:07,110
to do so we're going to take a

00:17:03,720 --> 00:17:08,970
population of these chromosomes we're

00:17:07,110 --> 00:17:10,860
going to measure each of these

00:17:08,970 --> 00:17:12,660
chromosomes against some kind of fitness

00:17:10,860 --> 00:17:15,689
function and we'll look at what that

00:17:12,660 --> 00:17:17,220
means in a minute and then clearly the

00:17:15,689 --> 00:17:19,490
fitter ones are the ones that are more

00:17:17,220 --> 00:17:22,949
successful running against this function

00:17:19,490 --> 00:17:25,650
we're then going to take these

00:17:22,949 --> 00:17:27,660
chromosomes with their waiting and we're

00:17:25,650 --> 00:17:29,700
going to randomly select from them but

00:17:27,660 --> 00:17:31,740
what we want to do is we want to say the

00:17:29,700 --> 00:17:34,470
ones that were fitter are going to have

00:17:31,740 --> 00:17:37,770
a higher chance of being selected okay

00:17:34,470 --> 00:17:39,750
and then we're going to do some kind of

00:17:37,770 --> 00:17:42,179
mutation and reproduction within this

00:17:39,750 --> 00:17:43,130
pool to hopefully create even stronger

00:17:42,179 --> 00:17:45,560
ones

00:17:43,130 --> 00:17:47,600
and then we might just kind of add a few

00:17:45,560 --> 00:17:50,840
strange mutations in just to see where

00:17:47,600 --> 00:17:52,970
that gets us as well and that's our new

00:17:50,840 --> 00:17:56,480
population and so that's effectively one

00:17:52,970 --> 00:17:58,940
iteration of this algorithm okay so

00:17:56,480 --> 00:18:00,680
here's the here's a proposal for what

00:17:58,940 --> 00:18:02,690
this this algorithm will look like this

00:18:00,680 --> 00:18:05,270
it's a rate function we're going to need

00:18:02,690 --> 00:18:07,190
some kind of fitness function given a

00:18:05,270 --> 00:18:10,070
population it returns us a new

00:18:07,190 --> 00:18:11,570
population that that's it so clearly the

00:18:10,070 --> 00:18:14,120
fitness function will depend on what our

00:18:11,570 --> 00:18:16,670
algorithm actually is representing

00:18:14,120 --> 00:18:18,830
because we've been quite abstract so far

00:18:16,670 --> 00:18:20,780
about this so what we need to do is we

00:18:18,830 --> 00:18:23,000
need to a way to convert from this

00:18:20,780 --> 00:18:25,790
binary string which is supposed to

00:18:23,000 --> 00:18:29,090
represent stuff in the real world into

00:18:25,790 --> 00:18:30,350
actual real-world stuff so here's here's

00:18:29,090 --> 00:18:32,900
a way we could do that we create a

00:18:30,350 --> 00:18:36,980
little little trait here just with a

00:18:32,900 --> 00:18:39,170
single method on it as a which takes a

00:18:36,980 --> 00:18:40,820
single chromosome and is able to

00:18:39,170 --> 00:18:43,340
understand what that binary string is

00:18:40,820 --> 00:18:44,870
supposed to mean and then create that

00:18:43,340 --> 00:18:47,210
type for us and we'll look at some

00:18:44,870 --> 00:18:49,160
concrete examples in a little while just

00:18:47,210 --> 00:18:51,440
to kind of hopefully make this a bit

00:18:49,160 --> 00:18:53,480
clearer so we just need to change our

00:18:51,440 --> 00:18:56,300
iterates signature just ever so slightly

00:18:53,480 --> 00:18:58,910
and so I'm going to add this this new

00:18:56,300 --> 00:19:00,620
new parameter on here so we need our

00:18:58,910 --> 00:19:03,680
fitness function in our population again

00:19:00,620 --> 00:19:06,230
but then we also need a way to convert

00:19:03,680 --> 00:19:10,340
from the chromosome 22 the real thing

00:19:06,230 --> 00:19:13,390
and so we can have this implicit genetic

00:19:10,340 --> 00:19:16,220
type here genetic parameter here and

00:19:13,390 --> 00:19:18,050
hopefully you start see now that this is

00:19:16,220 --> 00:19:20,270
actually a type class you know we're

00:19:18,050 --> 00:19:24,290
using this in the way that type classes

00:19:20,270 --> 00:19:25,550
are here for okay so now that we have a

00:19:24,290 --> 00:19:28,580
fitness function and we have the

00:19:25,550 --> 00:19:32,900
population we can we can look to create

00:19:28,580 --> 00:19:35,900
a pool to pick our new population from

00:19:32,900 --> 00:19:38,000
and so what we want to do is we want to

00:19:35,900 --> 00:19:40,370
randomly select from this population

00:19:38,000 --> 00:19:42,140
giving a higher chance to the fit of

00:19:40,370 --> 00:19:44,420
chromosomes so say we had a population

00:19:42,140 --> 00:19:46,130
that looks something like this you can

00:19:44,420 --> 00:19:48,470
see here that one of these chromosomes

00:19:46,130 --> 00:19:51,290
was really really fitter than the rest

00:19:48,470 --> 00:19:53,740
of them and so when we randomly pick

00:19:51,290 --> 00:19:56,030
from here we want to really

00:19:53,740 --> 00:19:58,690
have a higher chance of picking that

00:19:56,030 --> 00:20:01,910
this orange one at the bottom and so a

00:19:58,690 --> 00:20:03,590
possible implementation or the the

00:20:01,910 --> 00:20:05,690
definition of the implementation could

00:20:03,590 --> 00:20:07,520
look something like this this is often

00:20:05,690 --> 00:20:10,640
called a roulette wheel maybe a dart

00:20:07,520 --> 00:20:12,680
board and things like that and so given

00:20:10,640 --> 00:20:15,170
given a list of these chromosomes with

00:20:12,680 --> 00:20:17,150
that with their weightings that

00:20:15,170 --> 00:20:20,540
effectively gives us a function and that

00:20:17,150 --> 00:20:24,650
function is like our ability to randomly

00:20:20,540 --> 00:20:26,480
pick from the pool so you can think of

00:20:24,650 --> 00:20:29,360
this as it would pick a number between 0

00:20:26,480 --> 00:20:31,430
and 1 a double and then that will pick a

00:20:29,360 --> 00:20:33,260
point on the chart of where we would

00:20:31,430 --> 00:20:36,020
where would go from so obviously this

00:20:33,260 --> 00:20:38,750
would be 0 this would be 0 point 2 5

00:20:36,020 --> 00:20:41,930
half three quarters and then you know

00:20:38,750 --> 00:20:44,480
point 99 so we can just look at the the

00:20:41,930 --> 00:20:47,750
non significant digits from from a

00:20:44,480 --> 00:20:50,660
double okay but being all diligent

00:20:47,750 --> 00:20:51,740
professional programmers that we are you

00:20:50,660 --> 00:20:53,720
know we want to make sure that we're

00:20:51,740 --> 00:20:55,400
testing this properly because what we're

00:20:53,720 --> 00:20:56,950
dealing with here is effectively a you

00:20:55,400 --> 00:20:59,150
know with this is a very random

00:20:56,950 --> 00:21:00,380
situation you know we're dealing with

00:20:59,150 --> 00:21:03,170
random things that have been generated

00:21:00,380 --> 00:21:05,990
randomly and we want to pick from this

00:21:03,170 --> 00:21:07,970
pool at random and so the best thing to

00:21:05,990 --> 00:21:10,790
work with something random is to use

00:21:07,970 --> 00:21:16,760
even more randomness a people familiar

00:21:10,790 --> 00:21:19,160
with scarlet check our people not okay

00:21:16,760 --> 00:21:21,320
I'll give up I don't want to get too

00:21:19,160 --> 00:21:22,520
sidetracked by what Skyler check is

00:21:21,320 --> 00:21:27,920
because I could speak about that for

00:21:22,520 --> 00:21:30,710
hours I often do but a brief brief intro

00:21:27,920 --> 00:21:32,510
is scholar check is is a very different

00:21:30,710 --> 00:21:35,060
library to something like specs or j

00:21:32,510 --> 00:21:37,130
unit and that you tend to provide rules

00:21:35,060 --> 00:21:39,650
or properties for your for your

00:21:37,130 --> 00:21:41,990
implementation the you are sure must

00:21:39,650 --> 00:21:44,270
hold at all times so if we were say

00:21:41,990 --> 00:21:46,670
implementing an absolute function you

00:21:44,270 --> 00:21:48,200
know we want to make sure that the the

00:21:46,670 --> 00:21:49,610
property of our function is that it

00:21:48,200 --> 00:21:52,640
never returns a negative number of

00:21:49,610 --> 00:21:54,230
things like that so what we would do is

00:21:52,640 --> 00:21:57,050
we would think of some properties and

00:21:54,230 --> 00:21:59,660
then the library will provide random

00:21:57,050 --> 00:22:02,270
values for us to test that these

00:21:59,660 --> 00:22:04,010
properties always hold so that that's in

00:22:02,270 --> 00:22:05,420
a nutshell what it is and what I've got

00:22:04,010 --> 00:22:06,440
some code that looks at some Skyler

00:22:05,420 --> 00:22:08,269
check implementation

00:22:06,440 --> 00:22:09,830
a bit and hopefully don't get too bogged

00:22:08,269 --> 00:22:11,870
down on the details but I just wanted to

00:22:09,830 --> 00:22:13,309
show that this is quite a nice neat way

00:22:11,870 --> 00:22:15,440
to actually test this we're using

00:22:13,309 --> 00:22:18,590
something random to also test something

00:22:15,440 --> 00:22:20,360
random okay so one thing we need to

00:22:18,590 --> 00:22:22,429
think about is what what's a property of

00:22:20,360 --> 00:22:23,779
this this roulette wheel this dart board

00:22:22,429 --> 00:22:25,879
that we've seen that will always hold

00:22:23,779 --> 00:22:29,509
like something we can do we could

00:22:25,879 --> 00:22:32,629
provide some kind of random set of a

00:22:29,509 --> 00:22:35,649
population and then work out what will

00:22:32,629 --> 00:22:39,799
always hold true for for our population

00:22:35,649 --> 00:22:43,250
okay so here's one idea is that if our

00:22:39,799 --> 00:22:46,309
population has a single chromosome in it

00:22:43,250 --> 00:22:48,799
within it that is so much fitter than

00:22:46,309 --> 00:22:52,039
the rest that it takes over half of that

00:22:48,799 --> 00:22:54,379
wheel then the midpoint of the wheel

00:22:52,039 --> 00:22:57,259
will always return that chromosome okay

00:22:54,379 --> 00:23:00,230
so if we imagine the midpoint is here

00:22:57,259 --> 00:23:02,389
and so we would always select point five

00:23:00,230 --> 00:23:05,120
on that function you can see here that

00:23:02,389 --> 00:23:07,519
wherever we pick if we if we give

00:23:05,120 --> 00:23:10,519
different implementations that as long

00:23:07,519 --> 00:23:12,080
as the we have a chromosome that's

00:23:10,519 --> 00:23:14,120
always bigger than half of the

00:23:12,080 --> 00:23:17,149
population we should always get that

00:23:14,120 --> 00:23:22,309
picked and here's a here's a way to test

00:23:17,149 --> 00:23:24,980
this ok so we provide some chromosomes

00:23:22,309 --> 00:23:27,080
here that we don't care about and then

00:23:24,980 --> 00:23:28,879
we also give them their waiting and so

00:23:27,080 --> 00:23:31,159
Skylar check gives us all of that

00:23:28,879 --> 00:23:32,779
information just randomly and then the

00:23:31,159 --> 00:23:35,750
nice thing here sometimes these lists

00:23:32,779 --> 00:23:37,519
will be empty as well and then also in

00:23:35,750 --> 00:23:39,110
the middle of this we provide our own

00:23:37,519 --> 00:23:41,600
chromosome and that's the one we're

00:23:39,110 --> 00:23:44,659
looking for and what we do is we take

00:23:41,600 --> 00:23:46,580
the chromosomes that the other

00:23:44,659 --> 00:23:48,919
chromosomes and we find out the total of

00:23:46,580 --> 00:23:50,990
their there waiting and we add one to

00:23:48,919 --> 00:23:53,779
that so that's bigger than the sum of

00:23:50,990 --> 00:23:56,450
both of them and then that's the waiting

00:23:53,779 --> 00:23:58,730
we give to this chromosome here and then

00:23:56,450 --> 00:24:00,230
this is just explaining what I said and

00:23:58,730 --> 00:24:03,200
then when we look at this roulette wheel

00:24:00,230 --> 00:24:05,659
at the midpoint it should return this

00:24:03,200 --> 00:24:07,279
midpoint here again that that's a bit of

00:24:05,659 --> 00:24:09,740
a whirlwind tour especially if you're

00:24:07,279 --> 00:24:11,690
not familiar with Skylar check but that

00:24:09,740 --> 00:24:13,700
that's quite nice because Skylar chat

00:24:11,690 --> 00:24:16,279
will run this at least a hundred times

00:24:13,700 --> 00:24:18,169
and the nice thing is this this then

00:24:16,279 --> 00:24:18,890
passes so we get a nice level of

00:24:18,169 --> 00:24:21,110
confidence

00:24:18,890 --> 00:24:24,320
yea though our implementation is

00:24:21,110 --> 00:24:25,970
actually quite a good one okay and this

00:24:24,320 --> 00:24:28,310
is this is not this is not all

00:24:25,970 --> 00:24:29,480
encompassing this is not a test that

00:24:28,310 --> 00:24:31,220
proves that everything we've written

00:24:29,480 --> 00:24:33,170
works but that's just one property and

00:24:31,220 --> 00:24:36,590
the more properties we can think of the

00:24:33,170 --> 00:24:38,450
the better this will be so what we've

00:24:36,590 --> 00:24:41,180
done here is that we had to provide a

00:24:38,450 --> 00:24:44,120
way to pass this double into our

00:24:41,180 --> 00:24:45,770
implementation and what we'll have to do

00:24:44,120 --> 00:24:48,050
is in other tests which maybe I haven't

00:24:45,770 --> 00:24:51,710
shown here is that we want the ability

00:24:48,050 --> 00:24:53,240
to control this value that is passed so

00:24:51,710 --> 00:24:56,090
that when we look at other integration

00:24:53,240 --> 00:24:58,280
tests we can pass in the values we want

00:24:56,090 --> 00:25:01,850
to make sure that this is getting

00:24:58,280 --> 00:25:05,630
returned as we would expect so we want

00:25:01,850 --> 00:25:07,990
to we want to just maybe write yes we

00:25:05,630 --> 00:25:09,920
want to maybe just change our

00:25:07,990 --> 00:25:12,170
implementation of our iterate function

00:25:09,920 --> 00:25:14,810
ever so slightly and that we call this

00:25:12,170 --> 00:25:16,790
next double here so now we can create

00:25:14,810 --> 00:25:19,580
these generate we can generate streams

00:25:16,790 --> 00:25:21,500
of known doubles and then when we test

00:25:19,580 --> 00:25:23,600
this we know what numbers are going to

00:25:21,500 --> 00:25:25,430
be passed to that roulette wheel so we

00:25:23,600 --> 00:25:26,660
can then determine what chromosomes

00:25:25,430 --> 00:25:28,910
should always be picked and that would

00:25:26,660 --> 00:25:30,220
make testing this a lot easier but then

00:25:28,910 --> 00:25:33,710
of course for the reel or real

00:25:30,220 --> 00:25:35,780
production live implementation we can

00:25:33,710 --> 00:25:38,330
just give it a different function say

00:25:35,780 --> 00:25:40,490
the next double and that will just work

00:25:38,330 --> 00:25:41,900
especially and then we don't really have

00:25:40,490 --> 00:25:45,020
to think about where these doubles are

00:25:41,900 --> 00:25:46,580
coming from okay so this was creating

00:25:45,020 --> 00:25:49,010
our mutation pool this is not our new

00:25:46,580 --> 00:25:51,110
population yet but what we found are the

00:25:49,010 --> 00:25:53,390
really really strong chromosomes and the

00:25:51,110 --> 00:25:54,920
ones which were really strong have a

00:25:53,390 --> 00:25:56,330
higher chance of being picked and they

00:25:54,920 --> 00:25:59,330
may be picked more than once as well

00:25:56,330 --> 00:26:01,730
which is nice so now we need to do we

00:25:59,330 --> 00:26:03,440
need to effectively marry or mate or or

00:26:01,730 --> 00:26:06,500
you know you use these chromosomes

00:26:03,440 --> 00:26:09,140
together to create our new population so

00:26:06,500 --> 00:26:11,270
how this works is we take a chromosome

00:26:09,140 --> 00:26:13,880
from the pool and then we take another

00:26:11,270 --> 00:26:16,430
one from the original population and we

00:26:13,880 --> 00:26:18,410
line them up side by side and at some

00:26:16,430 --> 00:26:22,190
arbitrary points we flip the bits round

00:26:18,410 --> 00:26:24,380
so we get part of the fitter the fit

00:26:22,190 --> 00:26:26,360
chromosome and then part of another one

00:26:24,380 --> 00:26:28,130
and that gives us a brand-new chromosome

00:26:26,360 --> 00:26:29,590
and then that might be fitter or it

00:26:28,130 --> 00:26:32,200
might be not but

00:26:29,590 --> 00:26:34,960
we'll see where that takes us and so we

00:26:32,200 --> 00:26:38,260
take a couple of a couple of chromosomes

00:26:34,960 --> 00:26:41,289
we pick an arbitrary point we flip the

00:26:38,260 --> 00:26:43,360
bits and then we just throw the original

00:26:41,289 --> 00:26:46,120
one way and this is our new chromosome

00:26:43,360 --> 00:26:49,179
that and then again we can test this

00:26:46,120 --> 00:26:51,580
with Skylar check as well and so one

00:26:49,179 --> 00:26:55,870
property of this is that if we provide

00:26:51,580 --> 00:26:58,000
two fragments of a chromosome we can

00:26:55,870 --> 00:27:01,120
then pass we can put them together and

00:26:58,000 --> 00:27:02,710
pass that to our crossover method and we

00:27:01,120 --> 00:27:05,320
can tell the function where the

00:27:02,710 --> 00:27:06,909
crossover happens and then we know what

00:27:05,320 --> 00:27:08,620
will return because we've given it all

00:27:06,909 --> 00:27:12,520
the information and we knew that upfront

00:27:08,620 --> 00:27:15,100
so this is a slightly more involved test

00:27:12,520 --> 00:27:16,659
but basically here's our crossover point

00:27:15,100 --> 00:27:18,399
that we take from Skylar check and that

00:27:16,659 --> 00:27:21,640
just gives us the full length of the

00:27:18,399 --> 00:27:23,919
chromosome and then here we pass in

00:27:21,640 --> 00:27:29,230
effectively full chromosomes that have

00:27:23,919 --> 00:27:31,120
been split we stick them together we

00:27:29,230 --> 00:27:33,370
then call crossover and then we know the

00:27:31,120 --> 00:27:35,260
expectation will be the left of the

00:27:33,370 --> 00:27:38,230
first chromosome and the right of the

00:27:35,260 --> 00:27:41,020
second chromosome and again this works

00:27:38,230 --> 00:27:43,990
quite nicely and again just as an aside

00:27:41,020 --> 00:27:47,529
because now we've we're relying on this

00:27:43,990 --> 00:27:49,390
integer to pass where the crossover

00:27:47,529 --> 00:27:51,370
point happens because we want to be

00:27:49,390 --> 00:27:53,830
explicit about that in our tests so that

00:27:51,370 --> 00:27:56,529
we know where it actually happened so

00:27:53,830 --> 00:27:59,020
that just means we need to add this unit

00:27:56,529 --> 00:28:01,450
to integer function to our iterate

00:27:59,020 --> 00:28:03,580
signature so that we can use that in our

00:28:01,450 --> 00:28:06,159
tests but then also we could use say the

00:28:03,580 --> 00:28:09,370
the random functions we get with the

00:28:06,159 --> 00:28:11,350
scylla utils and then finally we get

00:28:09,370 --> 00:28:13,120
some random mutations so what happens

00:28:11,350 --> 00:28:15,279
here is that if our algorithm is

00:28:13,120 --> 00:28:17,470
iterating towards a point where it looks

00:28:15,279 --> 00:28:19,240
like we're quite strong this might be a

00:28:17,470 --> 00:28:20,799
local maximum and there might be an even

00:28:19,240 --> 00:28:24,549
stronger point somewhere else in our

00:28:20,799 --> 00:28:26,830
solution space and so if our population

00:28:24,549 --> 00:28:28,480
is some reason quite biased towards a

00:28:26,830 --> 00:28:30,700
particular solution we might be missing

00:28:28,480 --> 00:28:33,580
out and so we'll just throw in some

00:28:30,700 --> 00:28:35,260
random bit flips or mutations and that

00:28:33,580 --> 00:28:37,210
might take us away and maybe put us

00:28:35,260 --> 00:28:42,100
closer to it and even more successful

00:28:37,210 --> 00:28:42,919
goal and so will just simply randomly

00:28:42,100 --> 00:28:46,220
select a few bit

00:28:42,919 --> 00:28:47,749
to flip and so pick three here and we

00:28:46,220 --> 00:28:49,879
flip them around and this is on your

00:28:47,749 --> 00:28:51,289
chromosome and then another thing to

00:28:49,879 --> 00:28:53,330
mention here is that maybe we don't

00:28:51,289 --> 00:28:56,749
always want to do this so sometimes will

00:28:53,330 --> 00:28:59,029
mutate sometimes we won't and I won't

00:28:56,749 --> 00:29:00,850
show a test for that but that that

00:28:59,029 --> 00:29:04,429
should be quite straightforward to test

00:29:00,850 --> 00:29:05,809
and we're done and we ship it and so our

00:29:04,429 --> 00:29:07,429
final iteration signature looks

00:29:05,809 --> 00:29:09,409
something like this so we have our

00:29:07,429 --> 00:29:11,960
fitness function for the type we want to

00:29:09,409 --> 00:29:14,389
work with we have some way to control

00:29:11,960 --> 00:29:18,139
the the randomness one we want to and

00:29:14,389 --> 00:29:20,539
then basically give it a population we

00:29:18,139 --> 00:29:23,690
get a new population as long as we know

00:29:20,539 --> 00:29:26,899
how to convert from a binary string into

00:29:23,690 --> 00:29:28,820
what we're actually dealing with so

00:29:26,899 --> 00:29:31,609
really what I want to say here is as

00:29:28,820 --> 00:29:34,519
long as we have a type class for that

00:29:31,609 --> 00:29:35,929
binary string we can use this algorithm

00:29:34,519 --> 00:29:39,440
and this should work for any

00:29:35,929 --> 00:29:41,809
implementation okay so that's really

00:29:39,440 --> 00:29:44,600
kind of boring dry stuff so we'd have a

00:29:41,809 --> 00:29:47,619
quick look at this algorithm in action

00:29:44,600 --> 00:29:50,059
okay so one thing we could do is maybe

00:29:47,619 --> 00:29:52,309
find the optimal solution to a function

00:29:50,059 --> 00:29:56,059
and I mean clearly we know where the

00:29:52,309 --> 00:29:59,029
optimal solution is for this but yeah

00:29:56,059 --> 00:30:01,700
but we can we could maybe plug this into

00:29:59,029 --> 00:30:03,799
our genetic algorithm you know if we

00:30:01,700 --> 00:30:05,929
know the function of this graph which is

00:30:03,799 --> 00:30:07,609
quite simple to calculate we can then

00:30:05,929 --> 00:30:10,159
provide that as a fitness function and

00:30:07,609 --> 00:30:11,929
then work with some numbers so the graph

00:30:10,159 --> 00:30:13,909
is our fitness function and all we need

00:30:11,929 --> 00:30:17,960
is a way to convert from a binary string

00:30:13,909 --> 00:30:19,730
to a number and that that's you know

00:30:17,960 --> 00:30:22,220
that's relatively straightforward so we

00:30:19,730 --> 00:30:24,080
need our implicit implementation for

00:30:22,220 --> 00:30:26,779
genetic of the genetic type class for

00:30:24,080 --> 00:30:28,730
integers and then we need to provide our

00:30:26,779 --> 00:30:30,289
implementation here so given a

00:30:28,730 --> 00:30:32,779
chromosome how do we make that to an

00:30:30,289 --> 00:30:35,049
integer and we simply spin through all

00:30:32,779 --> 00:30:38,450
the bits and we shift right with each

00:30:35,049 --> 00:30:40,129
iteration and then if it turns out that

00:30:38,450 --> 00:30:42,019
the bit at that point was true we add

00:30:40,129 --> 00:30:45,499
one and then we'll find that that gives

00:30:42,019 --> 00:30:47,059
us a number for a given chromosome and

00:30:45,499 --> 00:30:50,869
then we can look at how this does so

00:30:47,059 --> 00:30:53,509
here's here's an example so this is

00:30:50,869 --> 00:30:55,099
running for a thousand iterations and we

00:30:53,509 --> 00:30:55,630
can see here that at the start because

00:30:55,099 --> 00:30:57,460
the

00:30:55,630 --> 00:30:59,710
the numbers are all over the place the

00:30:57,460 --> 00:31:02,470
binary strings are all over the place

00:30:59,710 --> 00:31:05,500
that it really is quite random and then

00:31:02,470 --> 00:31:08,740
at some point during the iteration one

00:31:05,500 --> 00:31:10,360
of one or a few of the of the binary

00:31:08,740 --> 00:31:12,970
strings we're very close to the target

00:31:10,360 --> 00:31:14,560
we were looking for and then we get very

00:31:12,970 --> 00:31:16,960
very close here and actually if we zoom

00:31:14,560 --> 00:31:18,520
in we can see here that it's not it's

00:31:16,960 --> 00:31:20,230
not just sitting on the number of the

00:31:18,520 --> 00:31:22,690
target we were looking for because

00:31:20,230 --> 00:31:24,520
they're still inherent randomness and we

00:31:22,690 --> 00:31:26,080
might find mutations and things like

00:31:24,520 --> 00:31:29,830
that that maybe take us away slightly

00:31:26,080 --> 00:31:32,470
and then bring us back to the number and

00:31:29,830 --> 00:31:34,240
then maybe just another one and this is

00:31:32,470 --> 00:31:36,370
a similar number just another run

00:31:34,240 --> 00:31:38,830
another run and it actually this found

00:31:36,370 --> 00:31:41,500
the the target maybe a little bit

00:31:38,830 --> 00:31:46,900
quicker so I did this with a population

00:31:41,500 --> 00:31:48,580
size of 30 so there were 30 chromosomes

00:31:46,900 --> 00:31:50,730
in each iteration and I did this for a

00:31:48,580 --> 00:31:53,230
thousand iterations of the algorithm and

00:31:50,730 --> 00:31:57,040
then maybe a slightly more interesting

00:31:53,230 --> 00:32:00,160
one for to finish off with is maybe we

00:31:57,040 --> 00:32:02,050
could do some some modern art and so

00:32:00,160 --> 00:32:05,830
like I said what you know we're really

00:32:02,050 --> 00:32:07,810
at the mercy of our of our imaginations

00:32:05,830 --> 00:32:10,570
here and that as long as we can provide

00:32:07,810 --> 00:32:12,550
a genetic type class for any type then

00:32:10,570 --> 00:32:14,980
we can use our algorithm which is really

00:32:12,550 --> 00:32:19,510
really quite cool so how about creating

00:32:14,980 --> 00:32:23,050
one for this type okay and then here's

00:32:19,510 --> 00:32:26,710
here's the idea so we'll use this binary

00:32:23,050 --> 00:32:30,730
string to create 50 triangles on a

00:32:26,710 --> 00:32:33,460
canvas so each triangle will have three

00:32:30,730 --> 00:32:36,760
set of XY coordinates and it will also

00:32:33,460 --> 00:32:38,850
have a color and so what we need to do

00:32:36,760 --> 00:32:42,040
assuming assuming a picture of this size

00:32:38,850 --> 00:32:45,310
we need 60 bits per triangle for 50

00:32:42,040 --> 00:32:47,830
triangles 24 bits to say what the color

00:32:45,310 --> 00:32:49,840
is and we'll throw in one more color

00:32:47,830 --> 00:32:52,600
just to give the canvas a background

00:32:49,840 --> 00:32:54,280
color and so forth for this

00:32:52,600 --> 00:32:56,130
implementation we would need a binary

00:32:54,280 --> 00:33:00,040
string of just over four thousand bits

00:32:56,130 --> 00:33:02,530
okay and so well what's our fitness

00:33:00,040 --> 00:33:04,150
function you know when we looked at this

00:33:02,530 --> 00:33:06,970
graph a minute ago it was quite clear

00:33:04,150 --> 00:33:08,470
that if we had a number well it's quite

00:33:06,970 --> 00:33:12,190
easy to put it into the graph

00:33:08,470 --> 00:33:13,480
see how close we are and you know we

00:33:12,190 --> 00:33:14,950
were looking at you know all we wanted

00:33:13,480 --> 00:33:18,210
to do is get the highest Y value

00:33:14,950 --> 00:33:21,159
possible in our in our previous

00:33:18,210 --> 00:33:22,870
iteration of this but now what does it

00:33:21,159 --> 00:33:25,990
what does it mean for one picture to be

00:33:22,870 --> 00:33:27,520
fitter than another well we can just

00:33:25,990 --> 00:33:30,490
compare this to an image that already

00:33:27,520 --> 00:33:33,700
exists and say as we get a bit closer we

00:33:30,490 --> 00:33:36,520
can maybe see just how close we get okay

00:33:33,700 --> 00:33:38,409
so so we our fitness function is

00:33:36,520 --> 00:33:41,950
basically going to just compare some

00:33:38,409 --> 00:33:44,650
images okay so given both images for

00:33:41,950 --> 00:33:47,230
each pixel compare the RGB values

00:33:44,650 --> 00:33:49,750
subtract one from the other do this for

00:33:47,230 --> 00:33:51,370
all the pixels and then get the sum the

00:33:49,750 --> 00:33:55,270
smaller the total the closer we are to

00:33:51,370 --> 00:33:56,770
to our target now I know I know that

00:33:55,270 --> 00:34:00,220
this is not the best image comparison

00:33:56,770 --> 00:34:01,330
algorithm ever written and you know we

00:34:00,220 --> 00:34:04,960
could probably have a whole conference

00:34:01,330 --> 00:34:07,210
on image comparison algorithms but it

00:34:04,960 --> 00:34:10,090
hopefully we'll see hopefully this will

00:34:07,210 --> 00:34:11,830
work for now but clearly this is not the

00:34:10,090 --> 00:34:13,990
most efficient so there's one more

00:34:11,830 --> 00:34:15,940
problem we need to overcome it's not

00:34:13,990 --> 00:34:18,129
very big problem really but our fitness

00:34:15,940 --> 00:34:22,899
function for our algorithm was was a too

00:34:18,129 --> 00:34:26,470
long but now we want to use this with

00:34:22,899 --> 00:34:28,810
two images so what we can't really

00:34:26,470 --> 00:34:29,679
change our algorithm to accommodate this

00:34:28,810 --> 00:34:31,810
because it would break other

00:34:29,679 --> 00:34:34,119
implementations of the algorithm but of

00:34:31,810 --> 00:34:36,099
course this is pretty simple we can just

00:34:34,119 --> 00:34:37,389
provide a curried function so our

00:34:36,099 --> 00:34:40,000
fitness function would look something

00:34:37,389 --> 00:34:41,500
like this and then the Mona Lisa or

00:34:40,000 --> 00:34:43,780
whatever would be the first parameter

00:34:41,500 --> 00:34:45,970
and that gives us a new function of

00:34:43,780 --> 00:34:48,820
bufferedimage too long and then we can

00:34:45,970 --> 00:34:53,470
provide our iterated values with that to

00:34:48,820 --> 00:34:56,169
give us a to give us hopefully a value

00:34:53,470 --> 00:35:01,390
and so let's have a look let's have a

00:34:56,169 --> 00:35:04,619
look at how this went okay so you know

00:35:01,390 --> 00:35:09,099
so that was a thousand iterations okay

00:35:04,619 --> 00:35:11,640
and so this is 20 you can see load the

00:35:09,099 --> 00:35:13,990
backgrounds changed and that's gay I

00:35:11,640 --> 00:35:15,430
know the picture isn't great on the

00:35:13,990 --> 00:35:18,160
screen but it's got a little bit darker

00:35:15,430 --> 00:35:18,820
and let the triangles are getting out to

00:35:18,160 --> 00:35:21,380
the corner

00:35:18,820 --> 00:35:24,080
and that's five thousand seven hundred

00:35:21,380 --> 00:35:29,690
iterations yeah and that took me three

00:35:24,080 --> 00:35:31,400
days so I am I'm pulling my hair out

00:35:29,690 --> 00:35:34,270
this is just before I went to New York

00:35:31,400 --> 00:35:37,130
to give this talk i was like no but i

00:35:34,270 --> 00:35:39,080
think what this goes to show is that you

00:35:37,130 --> 00:35:41,810
know if you have other ways to get

00:35:39,080 --> 00:35:43,820
solutions then genetic algorithms are

00:35:41,810 --> 00:35:45,800
not always the most efficient if you

00:35:43,820 --> 00:35:47,570
don't know your solution space then

00:35:45,800 --> 00:35:51,820
genetic algorithms can be really quite

00:35:47,570 --> 00:35:57,460
fruitful and i think people like NASA

00:35:51,820 --> 00:35:59,870
use this for creating say antenna

00:35:57,460 --> 00:36:02,180
configurations for work out the best way

00:35:59,870 --> 00:36:03,680
and things like that so there's some

00:36:02,180 --> 00:36:05,540
quite interesting images of these white

00:36:03,680 --> 00:36:07,160
really bendy wires and things that

00:36:05,540 --> 00:36:10,730
apparently are very good at receiving

00:36:07,160 --> 00:36:12,200
signals but what has been nice here is

00:36:10,730 --> 00:36:14,330
that the type classes provided this

00:36:12,200 --> 00:36:17,120
really neat interface into our algorithm

00:36:14,330 --> 00:36:19,670
both of the things I showed their use

00:36:17,120 --> 00:36:21,200
the exact same algorithm but all we did

00:36:19,670 --> 00:36:23,180
was change the fitness function and

00:36:21,200 --> 00:36:26,110
provided a way to convert from the

00:36:23,180 --> 00:36:29,210
binary string into our representation

00:36:26,110 --> 00:36:31,970
okay and another little side effect of

00:36:29,210 --> 00:36:33,490
this project has been although we're

00:36:31,970 --> 00:36:36,770
dealing in an inherently random

00:36:33,490 --> 00:36:38,870
situation using another random tool

00:36:36,770 --> 00:36:41,630
works quite well as long as you have

00:36:38,870 --> 00:36:43,460
control and it shows that you can be

00:36:41,630 --> 00:36:46,820
deterministic and what really is a kind

00:36:43,460 --> 00:36:48,950
of non deterministic setting and so will

00:36:46,820 --> 00:36:50,840
like what else what else could we have

00:36:48,950 --> 00:36:53,420
done here so some other suggestions

00:36:50,840 --> 00:36:56,030
maybe maybe you can think of your own so

00:36:53,420 --> 00:36:57,890
here's here's one I thought of we could

00:36:56,030 --> 00:37:00,590
write a genetic algorithm and provide a

00:36:57,890 --> 00:37:03,710
fitness function of maybe a set of unit

00:37:00,590 --> 00:37:06,740
tests and then let it randomly generate

00:37:03,710 --> 00:37:10,340
an ast and maybe write us out of a job

00:37:06,740 --> 00:37:13,010
or racing cars this is quite cool

00:37:10,340 --> 00:37:14,300
actually this what so this is it this is

00:37:13,010 --> 00:37:16,940
done in JavaScript and these are all

00:37:14,300 --> 00:37:19,850
randomly generated and then this will

00:37:16,940 --> 00:37:21,260
crash in a minute and then and then it

00:37:19,850 --> 00:37:23,510
starts again it knows this was the

00:37:21,260 --> 00:37:26,140
fittest because it went further along is

00:37:23,510 --> 00:37:26,140
it ever going to stop

00:37:26,809 --> 00:37:31,440
give it so there we go and so that's

00:37:29,789 --> 00:37:33,509
died there and now these are more

00:37:31,440 --> 00:37:34,799
closely related to that one and things

00:37:33,509 --> 00:37:38,119
if you leave this for a couple of hours

00:37:34,799 --> 00:37:43,319
it gets quite it gets quite good so I

00:37:38,119 --> 00:37:45,479
need to disclose them or maybe I don't

00:37:43,319 --> 00:37:48,650
know maybe a kind of poker bot or

00:37:45,479 --> 00:37:51,739
counter-strike balls and i don't know

00:37:48,650 --> 00:37:54,329
maybe maybe you can think of your own

00:37:51,739 --> 00:37:56,099
you know it's been it's been quite a

00:37:54,329 --> 00:37:58,410
little interesting experiment that's

00:37:56,099 --> 00:38:00,839
basically all i had time to talk about I

00:37:58,410 --> 00:38:02,249
leave up some links here and there these

00:38:00,839 --> 00:38:05,069
are these are all clickable through the

00:38:02,249 --> 00:38:07,049
slides so this top one is kind of the

00:38:05,069 --> 00:38:09,989
inspiration for the talk really as this

00:38:07,049 --> 00:38:11,599
fellow who did it erations of the Mona

00:38:09,989 --> 00:38:13,650
Lisa and he did it in c-sharp

00:38:11,599 --> 00:38:15,809
technically it wasn't a genetic

00:38:13,650 --> 00:38:19,499
algorithm and all he was doing was kind

00:38:15,809 --> 00:38:21,239
of iterating on random bits and not

00:38:19,499 --> 00:38:23,279
really having the kind of mutations and

00:38:21,239 --> 00:38:24,539
crossover and things but he did he did

00:38:23,279 --> 00:38:27,869
really well much better than I did

00:38:24,539 --> 00:38:30,059
actually this book here is kind of the

00:38:27,869 --> 00:38:31,170
de facto Bible for dealing with genetic

00:38:30,059 --> 00:38:33,959
algorithms think it was written in the

00:38:31,170 --> 00:38:37,079
80s and then I also put up a link to to

00:38:33,959 --> 00:38:39,690
my talk that's all that's all I really

00:38:37,079 --> 00:38:41,430
had if you have any questions I'd love

00:38:39,690 --> 00:38:42,749
to hear them and I hope I hope you

00:38:41,430 --> 00:38:46,999
enjoyed it and I hoped you learned

00:38:42,749 --> 00:38:46,999

YouTube URL: https://www.youtube.com/watch?v=lshIBfmsktk


