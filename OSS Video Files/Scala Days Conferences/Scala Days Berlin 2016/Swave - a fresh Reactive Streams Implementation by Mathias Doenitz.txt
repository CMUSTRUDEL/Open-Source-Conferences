Title: Swave - a fresh Reactive Streams Implementation by Mathias Doenitz
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Anstract:
Since its inception more than 2 years ago the effort for establishing a standard protocol for asynchronous stream processing under the name "Reactive Streams" (RS) has received a lot of attention. Many users and organizations are excited by this powerful new abstraction for defining and scaling pipelined processing logic in a fully asynchronous, non-blocking and generally reactive fashion.
Typically applications built on RS thereby rely on an RS infrastructure implementation to provide the general building blocks for defining arbitrarily complex business logic as a series of stream transformations. An RS infrastructure implementation also forms the "glue" that's required for interfacing with RS-compatible domain adapters (e.g. for databases, HTTP APIs and messaging systems).
While the number of RS-compatible domain adapters has been rising steadily over the course of the last year the range of available RS infrastructure implementations is still limited.
For Scala users there is currently only a single one, akka-stream, which is solidly engineered towards a particular set of design goals.
In order to further explore the design space of the still young Reactive Streams domain another fully-featured Reactive Streams infrastructure toolkit for Scala, called "Swave", has been built from scratch with a clear focus on maximum performance, a simple and powerful API as well as minimal dependencies.
This talk will introduce you to the project, its general design approach, feature set and core implementation choices as well as basic benchmark and performance figures.
We'll contrast with other RS implementations and highlight pros and cons from a user's perspective.
So the next time you are faced with the question of which Reactive Streams implementation to use you'll have one more choice to pick from.
And even if you can't decide you're still good! After all, the "Reactive Streams" label means: Interoperability for the win!
Captions: 
	00:00:00,260 --> 00:00:07,379
hello everyone thank you for coming i'm

00:00:03,929 --> 00:00:08,970
mateus and in the next 45 minutes i will

00:00:07,379 --> 00:00:12,120
introduce you to a project that i'm very

00:00:08,970 --> 00:00:14,219
excited about it's called slave and it's

00:00:12,120 --> 00:00:18,060
a reactive streams infrastructure

00:00:14,219 --> 00:00:19,970
toolkit for scala but before we dive

00:00:18,060 --> 00:00:22,500
into the content a quick show of hands

00:00:19,970 --> 00:00:25,820
who view would say that you have a rough

00:00:22,500 --> 00:00:28,470
idea of what reactive streams are

00:00:25,820 --> 00:00:34,500
excellent almost everyone who has no

00:00:28,470 --> 00:00:37,770
idea of reactive streams no one wow this

00:00:34,500 --> 00:00:40,500
is catching on very nice who has played

00:00:37,770 --> 00:00:44,219
with acha stream so far at least played

00:00:40,500 --> 00:00:45,300
every wow cool very nice because I'm not

00:00:44,219 --> 00:00:47,430
going to be really talking about

00:00:45,300 --> 00:00:49,140
reactive streams in any great detail

00:00:47,430 --> 00:00:52,079
there's lots of material already online

00:00:49,140 --> 00:00:54,710
and you know it anyway but we will still

00:00:52,079 --> 00:00:57,360
spend the first part of the talk on

00:00:54,710 --> 00:01:01,170
looking at where in the general

00:00:57,360 --> 00:01:05,150
streaming world this fits in and why you

00:01:01,170 --> 00:01:07,799
might be interested in it alright so as

00:01:05,150 --> 00:01:09,689
you know since you've all been using

00:01:07,799 --> 00:01:13,110
reactive streams already there is quite

00:01:09,689 --> 00:01:15,180
a lot of excitement about stream

00:01:13,110 --> 00:01:18,750
processing in general in the recent

00:01:15,180 --> 00:01:20,909
years much more than for you know 10 20

00:01:18,750 --> 00:01:23,640
years ago and there are few key drivers

00:01:20,909 --> 00:01:26,700
why that's the case and clearly one big

00:01:23,640 --> 00:01:28,860
driver is the big data that we now have

00:01:26,700 --> 00:01:31,350
we really do have more data than we used

00:01:28,860 --> 00:01:33,479
to we're dealing with masses of video

00:01:31,350 --> 00:01:36,240
streams audio streams tweet streams you

00:01:33,479 --> 00:01:38,280
know machine learning training data and

00:01:36,240 --> 00:01:40,229
all kinds of stuff that doesn't fit into

00:01:38,280 --> 00:01:42,090
memory and for these types of

00:01:40,229 --> 00:01:44,340
applications stream processing

00:01:42,090 --> 00:01:46,380
processing lends itself naturally okay

00:01:44,340 --> 00:01:48,270
so that's one driver but there are other

00:01:46,380 --> 00:01:50,340
drivers as well because stream

00:01:48,270 --> 00:01:53,180
processing is a very nice and general

00:01:50,340 --> 00:01:55,380
programming abstraction that helps us in

00:01:53,180 --> 00:01:56,939
the new challenges or with the

00:01:55,380 --> 00:02:00,329
challenges in the distributed and

00:01:56,939 --> 00:02:02,729
concurrent programming environment that

00:02:00,329 --> 00:02:05,280
we find ourselves in now much more than

00:02:02,729 --> 00:02:08,879
10 years ago and in 20 years or 10 years

00:02:05,280 --> 00:02:11,370
that will change even more so we always

00:02:08,879 --> 00:02:13,460
need a powerful in general programming

00:02:11,370 --> 00:02:16,050
abstraction and that's why

00:02:13,460 --> 00:02:19,880
things likes wave and many of the other

00:02:16,050 --> 00:02:23,040
tools that you have played with exist

00:02:19,880 --> 00:02:25,970
now when we look at what is out there in

00:02:23,040 --> 00:02:28,980
the space there's really a ton of stuff

00:02:25,970 --> 00:02:31,890
you can't really name them all I've just

00:02:28,980 --> 00:02:34,890
put down two things on the on the left

00:02:31,890 --> 00:02:36,330
there but if you if you look at what is

00:02:34,890 --> 00:02:37,530
available in the stream processing world

00:02:36,330 --> 00:02:41,310
and you can put them on a chart like

00:02:37,530 --> 00:02:42,690
this where we have on the left tools

00:02:41,310 --> 00:02:46,020
that are more geared it for the

00:02:42,690 --> 00:02:48,750
distributed scenario so for the for the

00:02:46,020 --> 00:02:50,790
scenario we have really big problems

00:02:48,750 --> 00:02:53,820
that you need to scale across several

00:02:50,790 --> 00:02:55,080
machines then there is the space in the

00:02:53,820 --> 00:02:57,690
middle where you say okay stream

00:02:55,080 --> 00:02:58,980
processing between two things or several

00:02:57,690 --> 00:03:01,650
things that live maybe on different

00:02:58,980 --> 00:03:03,570
threads and then we can really go to the

00:03:01,650 --> 00:03:05,700
very right where we become really local

00:03:03,570 --> 00:03:09,600
so within one thread and there there's

00:03:05,700 --> 00:03:12,270
very little so we can ask ourselves why

00:03:09,600 --> 00:03:15,900
is everything that's available all the

00:03:12,270 --> 00:03:17,850
big tools mostly targeted at the

00:03:15,900 --> 00:03:20,490
distributed scenario and it's simply

00:03:17,850 --> 00:03:22,140
because that's where the problems are

00:03:20,490 --> 00:03:24,630
the hardest traditionally where you have

00:03:22,140 --> 00:03:26,340
the most data and we just need to scale

00:03:24,630 --> 00:03:28,260
across machines and those solutions are

00:03:26,340 --> 00:03:31,470
usually quite big they're complicated

00:03:28,260 --> 00:03:33,180
they're very powerful but they they are

00:03:31,470 --> 00:03:35,760
just something that you wouldn't just

00:03:33,180 --> 00:03:38,040
use for for a quick job you know in one

00:03:35,760 --> 00:03:39,780
thread let me sort some stuff you

00:03:38,040 --> 00:03:42,420
wouldn't you know fire up a spark

00:03:39,780 --> 00:03:44,670
cluster for that clearly now where does

00:03:42,420 --> 00:03:47,280
reactive streams fit in reactive streams

00:03:44,670 --> 00:03:50,070
as you know is just a standard it's not

00:03:47,280 --> 00:03:53,970
a solution it's a protocol the protocol

00:03:50,070 --> 00:03:55,980
for just defining how to hand atta

00:03:53,970 --> 00:03:58,230
between the producer and the consumer in

00:03:55,980 --> 00:03:59,540
a proper ways that allows them both to

00:03:58,230 --> 00:04:01,620
run in their own time and space

00:03:59,540 --> 00:04:03,630
completely asynchronously and without

00:04:01,620 --> 00:04:06,750
any blocking that's the idea right so as

00:04:03,630 --> 00:04:09,690
such it doesn't really fit on this chart

00:04:06,750 --> 00:04:11,760
in one corner because it doesn't concern

00:04:09,690 --> 00:04:13,530
itself whether the producer or the

00:04:11,760 --> 00:04:15,239
consumer or in the consumer live on

00:04:13,530 --> 00:04:17,549
different nodes and different threads or

00:04:15,239 --> 00:04:19,650
maybe on the same thread so that's why

00:04:17,549 --> 00:04:21,419
it's the whole area and if we look at

00:04:19,650 --> 00:04:24,630
solutions like acha stream then there's

00:04:21,419 --> 00:04:26,610
traditionally or the core focus was so

00:04:24,630 --> 00:04:28,949
far the inter thread solution

00:04:26,610 --> 00:04:30,689
within one machine the concurrent

00:04:28,949 --> 00:04:32,879
scenario we have a producer that maybe

00:04:30,689 --> 00:04:36,030
lives on a different threat than T then

00:04:32,879 --> 00:04:38,639
the consumer and how do we how do we use

00:04:36,030 --> 00:04:40,770
that properly and my guess would be that

00:04:38,639 --> 00:04:42,270
maybe in the future we'll see akka

00:04:40,770 --> 00:04:44,669
stream develop a little bit further to

00:04:42,270 --> 00:04:47,879
the left because it naturally lends

00:04:44,669 --> 00:04:50,129
itself their slave on the other hand has

00:04:47,879 --> 00:04:52,919
a focus also the core focus for the

00:04:50,129 --> 00:04:55,050
inter threat scenario but it actually my

00:04:52,919 --> 00:04:56,849
goal is to move it further to the to the

00:04:55,050 --> 00:04:58,949
right because there's value to be

00:04:56,849 --> 00:05:01,919
captured there as well so become small

00:04:58,949 --> 00:05:03,240
and that's why I've always also put down

00:05:01,919 --> 00:05:05,039
the scholar collections on this chart

00:05:03,240 --> 00:05:07,680
they're not a streaming solution so far

00:05:05,039 --> 00:05:10,560
but it's what we use when we are on our

00:05:07,680 --> 00:05:13,050
thread in our small you know local

00:05:10,560 --> 00:05:15,990
environment where everything is ours we

00:05:13,050 --> 00:05:18,539
tend to use lists vectors and whatnot

00:05:15,990 --> 00:05:22,110
and that's a space that's interesting

00:05:18,539 --> 00:05:23,340
also for a streaming solution now since

00:05:22,110 --> 00:05:27,539
we're we're contrasting a bit

00:05:23,340 --> 00:05:29,729
collections and and streams of streaming

00:05:27,539 --> 00:05:31,199
solutions let's understand that a bit

00:05:29,729 --> 00:05:33,860
further because it's quite important to

00:05:31,199 --> 00:05:36,120
really know what we're talking about so

00:05:33,860 --> 00:05:39,860
the scala collections are really the

00:05:36,120 --> 00:05:43,020
workhorse that we use all the time and

00:05:39,860 --> 00:05:47,129
what us or at least me and probably you

00:05:43,020 --> 00:05:48,800
as well it's very attractive or what we

00:05:47,129 --> 00:05:51,900
are very attracted to is code like this

00:05:48,800 --> 00:05:53,580
very concise code that's scholar

00:05:51,900 --> 00:05:56,430
collections that's how we want to write

00:05:53,580 --> 00:05:58,289
our business logic it's concise its

00:05:56,430 --> 00:06:00,210
expressive there's no boilerplate it's

00:05:58,289 --> 00:06:03,240
easy to read and maintain that's great

00:06:00,210 --> 00:06:05,370
that's also the gateway drug into Scylla

00:06:03,240 --> 00:06:07,770
form for many people that come maybe

00:06:05,370 --> 00:06:10,889
from Java because that's cool and that's

00:06:07,770 --> 00:06:14,460
what I like to keep like that and maybe

00:06:10,889 --> 00:06:16,020
expand on that give it more power but

00:06:14,460 --> 00:06:19,529
this is the code that i would like to

00:06:16,020 --> 00:06:21,210
write so what is interesting when we

00:06:19,529 --> 00:06:23,430
look at how we deal with collections

00:06:21,210 --> 00:06:26,219
then the approaches that we choose when

00:06:23,430 --> 00:06:28,919
we write collection based code they're

00:06:26,219 --> 00:06:31,050
really shaped by the experience that we

00:06:28,919 --> 00:06:33,270
had so far our heritage so to speak and

00:06:31,050 --> 00:06:35,159
since many of us probably come from a

00:06:33,270 --> 00:06:38,880
java or imperative background who would

00:06:35,159 --> 00:06:39,689
say that you have a imperative java like

00:06:38,880 --> 00:06:44,549
background

00:06:39,689 --> 00:06:46,169
most yeah so let me let me just give a

00:06:44,549 --> 00:06:48,360
small example how do you would how would

00:06:46,169 --> 00:06:51,179
you generate 10 random strings say you

00:06:48,360 --> 00:06:53,159
need them for a for a test you just need

00:06:51,179 --> 00:06:54,839
to cycle through 10 random strings and

00:06:53,159 --> 00:06:57,360
the point is not how do you create a

00:06:54,839 --> 00:07:00,019
random string but more like how do you

00:06:57,360 --> 00:07:02,069
generate 10 of them and kind of you know

00:07:00,019 --> 00:07:03,899
encapsulate them so that you can use

00:07:02,069 --> 00:07:06,629
them take a second to think about how

00:07:03,899 --> 00:07:09,239
you would do that like for yourself if

00:07:06,629 --> 00:07:10,589
you come from a fresh from the Java

00:07:09,239 --> 00:07:14,099
world maybe you would reach for

00:07:10,589 --> 00:07:16,019
something like that perfectly fine you

00:07:14,099 --> 00:07:17,550
create a buffer you add ten strings done

00:07:16,019 --> 00:07:20,069
then you have the ten strings right

00:07:17,550 --> 00:07:21,629
there works no problem with that of

00:07:20,069 --> 00:07:25,409
course in the Scala world it's a little

00:07:21,629 --> 00:07:27,479
bit frowned upon because of the explicit

00:07:25,409 --> 00:07:29,610
mutability that we have there okay so

00:07:27,479 --> 00:07:30,779
maybe if you know scale a bit more and

00:07:29,610 --> 00:07:32,699
you know the collections library you

00:07:30,779 --> 00:07:35,339
probably reach for something like that

00:07:32,699 --> 00:07:37,289
there's a fancy method called fill that

00:07:35,339 --> 00:07:38,819
kind of hides it all away and you get a

00:07:37,289 --> 00:07:41,239
method that's already filled with ten

00:07:38,819 --> 00:07:43,649
random strings cool that's good right

00:07:41,239 --> 00:07:45,809
but there's also another solution

00:07:43,649 --> 00:07:49,949
available with the scholar collections

00:07:45,809 --> 00:07:51,539
that you can use and that's this that's

00:07:49,949 --> 00:07:53,639
available you don't need to import

00:07:51,539 --> 00:07:56,939
anything or depend on any library there

00:07:53,639 --> 00:08:00,689
is a there's Scala immutable stream that

00:07:56,939 --> 00:08:03,629
you can use and that is a streaming

00:08:00,689 --> 00:08:06,149
based approach so you first create with

00:08:03,629 --> 00:08:07,979
stream continually an infinite stream of

00:08:06,149 --> 00:08:10,469
random strings and then you just take

00:08:07,979 --> 00:08:13,559
the first 10 so that works just the same

00:08:10,469 --> 00:08:18,329
who would have used the approach at the

00:08:13,559 --> 00:08:20,519
bottom a few write a few but I think

00:08:18,329 --> 00:08:22,919
those those tools are actually underused

00:08:20,519 --> 00:08:24,569
a little bit because they are cool they

00:08:22,919 --> 00:08:26,129
have benefits in this scenario for

00:08:24,569 --> 00:08:27,629
example for 10 that doesn't really

00:08:26,129 --> 00:08:30,569
matter but suppose you need to generate

00:08:27,629 --> 00:08:32,789
a million strings if you go for the list

00:08:30,569 --> 00:08:34,889
approach then you will actually need the

00:08:32,789 --> 00:08:36,750
memory for a million strings because

00:08:34,889 --> 00:08:38,009
they will be pre-allocated everything

00:08:36,750 --> 00:08:40,019
will be filled that will take some time

00:08:38,009 --> 00:08:42,120
and then you'll cycle through them in

00:08:40,019 --> 00:08:44,069
the approach at the bottom you don't

00:08:42,120 --> 00:08:46,620
need any memory you just create a

00:08:44,069 --> 00:08:48,720
description of what you want and then it

00:08:46,620 --> 00:08:51,389
gets pulled out and generated as you

00:08:48,720 --> 00:08:52,829
need it so it's lazy so in there are

00:08:51,389 --> 00:08:53,209
many scenarios where that's actually a

00:08:52,829 --> 00:08:55,759
better

00:08:53,209 --> 00:08:59,209
approach it's just different thinking

00:08:55,759 --> 00:09:01,730
and that my point here is that stream

00:08:59,209 --> 00:09:05,179
based solutions are not really confined

00:09:01,730 --> 00:09:07,639
to applications where you really deal

00:09:05,179 --> 00:09:09,920
with large amounts of clearly streaming

00:09:07,639 --> 00:09:13,639
data like video streams or audio streams

00:09:09,920 --> 00:09:15,800
there are many many applications of

00:09:13,639 --> 00:09:17,360
stream based solutions in your ordinary

00:09:15,800 --> 00:09:18,949
code that you write everyday that you

00:09:17,360 --> 00:09:23,119
just don't see because you're not used

00:09:18,949 --> 00:09:24,139
to it and many times they're better they

00:09:23,119 --> 00:09:26,119
can be better they're not necessarily

00:09:24,139 --> 00:09:28,279
and always better but it's good to have

00:09:26,119 --> 00:09:29,689
in mind that there might be a stream

00:09:28,279 --> 00:09:31,970
based solution somewhere around the

00:09:29,689 --> 00:09:34,249
corner right and that's the area that's

00:09:31,970 --> 00:09:35,959
wave is targeting kind of explore that

00:09:34,249 --> 00:09:43,240
give you more tools in that in that

00:09:35,959 --> 00:09:45,860
space okay when we look at stream-based

00:09:43,240 --> 00:09:47,269
transformations or stream

00:09:45,860 --> 00:09:48,920
transformations and we can really group

00:09:47,269 --> 00:09:50,990
them into five different areas there are

00:09:48,920 --> 00:09:52,189
five basic types of dreams stream

00:09:50,990 --> 00:09:54,819
transformations that you have there is a

00:09:52,189 --> 00:09:57,319
simple map for example you have a stream

00:09:54,819 --> 00:09:59,089
you apply a transformation you get back

00:09:57,319 --> 00:10:01,069
another stream then there is something

00:09:59,089 --> 00:10:03,170
that we call fan in where you have

00:10:01,069 --> 00:10:05,720
several streams that with some kind of

00:10:03,170 --> 00:10:07,129
logic get merged into one merge might be

00:10:05,720 --> 00:10:09,199
one but there might be other strategies

00:10:07,129 --> 00:10:11,869
for how you you know merge those data

00:10:09,199 --> 00:10:13,730
and the opposite is a fan out where you

00:10:11,869 --> 00:10:16,279
have one upstream and several down

00:10:13,730 --> 00:10:18,230
streams and some logic that distributes

00:10:16,279 --> 00:10:20,600
the incoming elements and then there are

00:10:18,230 --> 00:10:23,209
two types of interesting stream of

00:10:20,600 --> 00:10:26,329
stream operations one that is that I

00:10:23,209 --> 00:10:28,910
that I call inject which takes a stream

00:10:26,329 --> 00:10:32,689
of elements and produces a stream of

00:10:28,910 --> 00:10:35,269
stream of of elements so every element

00:10:32,689 --> 00:10:38,329
that comes out of this transformation is

00:10:35,269 --> 00:10:39,889
itself a stream that has elements just

00:10:38,329 --> 00:10:41,839
you can nest streams like you can list

00:10:39,889 --> 00:10:43,670
lists or any other type of abstractions

00:10:41,839 --> 00:10:47,299
and then of course you need a way to

00:10:43,670 --> 00:10:49,519
flatten those out again so those are the

00:10:47,299 --> 00:10:52,670
five basic times of stream stream

00:10:49,519 --> 00:10:54,079
transformations and we already use them

00:10:52,670 --> 00:10:56,600
on the collections that are available

00:10:54,079 --> 00:10:59,299
you can group all the things that you

00:10:56,600 --> 00:11:00,559
can use on the collections into those

00:10:59,299 --> 00:11:03,499
five things so they're they're not

00:11:00,559 --> 00:11:06,000
something new or strange but you don't

00:11:03,499 --> 00:11:07,500
necessarily think about them in that way

00:11:06,000 --> 00:11:09,030
I won't go through all of them you'll

00:11:07,500 --> 00:11:12,000
recognize them but that's what they do

00:11:09,030 --> 00:11:13,740
essentially so there's there's a close

00:11:12,000 --> 00:11:15,420
relationship between streams and

00:11:13,740 --> 00:11:18,240
collections and we need to understand

00:11:15,420 --> 00:11:21,210
better like how they how they really

00:11:18,240 --> 00:11:23,340
relate so one important distinction is

00:11:21,210 --> 00:11:26,130
of course strict versus lazy collections

00:11:23,340 --> 00:11:28,440
I would my guess is that most of us use

00:11:26,130 --> 00:11:30,420
the strict ones much more that's the

00:11:28,440 --> 00:11:33,630
go-to tool that we just reach for like

00:11:30,420 --> 00:11:35,430
you know list vector set map and so on

00:11:33,630 --> 00:11:37,050
but there are two types of lazy

00:11:35,430 --> 00:11:38,840
collections that scada already gives us

00:11:37,050 --> 00:11:42,570
which is immutable stream and iterator

00:11:38,840 --> 00:11:44,910
collection iterator exists you can use

00:11:42,570 --> 00:11:46,680
that most of you probably have have done

00:11:44,910 --> 00:11:48,600
that before and if we contrast them then

00:11:46,680 --> 00:11:51,450
the strict ones are really about storage

00:11:48,600 --> 00:11:54,120
it's about having something as we said

00:11:51,450 --> 00:11:56,490
before the list is there it exists and I

00:11:54,120 --> 00:11:58,350
can just use it we have storage for that

00:11:56,490 --> 00:12:00,390
and the lazy ones they don't have any

00:11:58,350 --> 00:12:02,910
storage it's more about transformation

00:12:00,390 --> 00:12:04,770
that's the idea right so I described a

00:12:02,910 --> 00:12:07,170
way for how I want my data to be

00:12:04,770 --> 00:12:08,730
transformed rather than they were stored

00:12:07,170 --> 00:12:10,530
here in this format and then store it in

00:12:08,730 --> 00:12:13,140
another format somewhere else and

00:12:10,530 --> 00:12:14,880
because the strict ones are a storage

00:12:13,140 --> 00:12:17,580
space they really kind of stand alone

00:12:14,880 --> 00:12:21,660
once I have a list I can you know do

00:12:17,580 --> 00:12:24,060
whatever I want with it and the the lazy

00:12:21,660 --> 00:12:26,040
collections they they really get their

00:12:24,060 --> 00:12:27,720
power when you connect the

00:12:26,040 --> 00:12:30,930
transformations rather than look at them

00:12:27,720 --> 00:12:32,760
in isolation we can connect them to

00:12:30,930 --> 00:12:34,560
pipelines and graphs and really big

00:12:32,760 --> 00:12:36,810
things as we as you can do with our

00:12:34,560 --> 00:12:38,160
stream of course the district' ones

00:12:36,810 --> 00:12:39,450
because memory is bounded the strict

00:12:38,160 --> 00:12:41,280
ones need to be bounded and the other

00:12:39,450 --> 00:12:43,560
ones can be potentially unbounded even

00:12:41,280 --> 00:12:45,600
in yeah totally unfair in finite like

00:12:43,560 --> 00:12:47,910
the stream of all natural numbers for

00:12:45,600 --> 00:12:49,320
example because they're a storage space

00:12:47,910 --> 00:12:51,600
the straight ones are repeatable

00:12:49,320 --> 00:12:53,100
automatically I can if they're immutable

00:12:51,600 --> 00:12:55,560
I can just you know look at them as

00:12:53,100 --> 00:12:57,000
often as I want and for the lazy ones

00:12:55,560 --> 00:12:59,310
there is immutable stream which is

00:12:57,000 --> 00:13:02,850
repeatable because it's immutable but

00:12:59,310 --> 00:13:05,190
iterator is consumed when you use it

00:13:02,850 --> 00:13:07,230
it's spent you need to recreate it in

00:13:05,190 --> 00:13:09,690
order to be able to go through it again

00:13:07,230 --> 00:13:13,620
okay so there's a there's important

00:13:09,690 --> 00:13:15,270
distinctions between the two now what

00:13:13,620 --> 00:13:17,310
reactor streams what the reactor streams

00:13:15,270 --> 00:13:19,590
protocol allows and what's wave

00:13:17,310 --> 00:13:22,710
implements is really a generalization

00:13:19,590 --> 00:13:24,480
of lazy collections what does that mean

00:13:22,710 --> 00:13:26,720
it's actually it's it's something more

00:13:24,480 --> 00:13:29,130
powerful or you could say differently

00:13:26,720 --> 00:13:31,800
lazy collections are essentially a

00:13:29,130 --> 00:13:34,500
special kind of what reactive streams

00:13:31,800 --> 00:13:36,330
allow so a subset of everything that you

00:13:34,500 --> 00:13:38,910
can build with reactive streams i infect

00:13:36,330 --> 00:13:42,150
lazy collections what is important is

00:13:38,910 --> 00:13:49,200
it's not the other way around it's not

00:13:42,150 --> 00:13:53,810
that reactive streams are always lazy

00:13:49,200 --> 00:13:57,090
collections right one is a subset so

00:13:53,810 --> 00:13:59,310
let's contrast lazy collections and wave

00:13:57,090 --> 00:14:01,290
versus or reactive streams what they

00:13:59,310 --> 00:14:04,470
allow lazy collections they're always

00:14:01,290 --> 00:14:06,690
synchronous they always run they never

00:14:04,470 --> 00:14:08,010
they never dispatch to any other threat

00:14:06,690 --> 00:14:10,170
they always run on your threat if you

00:14:08,010 --> 00:14:11,670
ask in a stream on iterator to give you

00:14:10,170 --> 00:14:14,370
next element and that will happen on

00:14:11,670 --> 00:14:15,830
your threat reactor streams allows both

00:14:14,370 --> 00:14:18,480
with synchronous as well as asynchronous

00:14:15,830 --> 00:14:21,560
operations and that's what's wave or

00:14:18,480 --> 00:14:24,420
also does then because it's not active

00:14:21,560 --> 00:14:27,330
the lazy collections you need all you

00:14:24,420 --> 00:14:30,240
always need to pull whereas reactive

00:14:27,330 --> 00:14:31,610
streams allows a dynamic push pull and

00:14:30,240 --> 00:14:33,660
you probably heard that before in other

00:14:31,610 --> 00:14:35,460
presentations or introduction material I

00:14:33,660 --> 00:14:37,860
won't go into details what exactly that

00:14:35,460 --> 00:14:42,390
is but it allows active components to

00:14:37,860 --> 00:14:44,430
push if they are active right lazy

00:14:42,390 --> 00:14:45,870
collections usually never lose elements

00:14:44,430 --> 00:14:47,280
and unless you really mess around when

00:14:45,870 --> 00:14:49,800
it erator you shouldn't lose any

00:14:47,280 --> 00:14:51,990
elements now if you're in the reactor

00:14:49,800 --> 00:14:54,330
streams world it might happen that you

00:14:51,990 --> 00:14:57,150
don't observe all elements maybe because

00:14:54,330 --> 00:14:58,260
you're you're not fast enough right if

00:14:57,150 --> 00:15:00,720
you're if you're consuming the Twitter

00:14:58,260 --> 00:15:02,040
fire hose then it's probably a good

00:15:00,720 --> 00:15:04,320
thing if you don't have to consume

00:15:02,040 --> 00:15:05,940
everything right but generally this

00:15:04,320 --> 00:15:08,100
doesn't happen just out of the blue

00:15:05,940 --> 00:15:09,930
normally you should know when there's a

00:15:08,100 --> 00:15:12,570
risk that stuff might disappear for

00:15:09,930 --> 00:15:14,370
example the Twitter files end might tell

00:15:12,570 --> 00:15:16,260
you if you can't keep up with drop

00:15:14,370 --> 00:15:17,880
elements all right then it's up to you

00:15:16,260 --> 00:15:20,460
to kind of build something that can keep

00:15:17,880 --> 00:15:22,710
up with it so but it might happen in the

00:15:20,460 --> 00:15:24,300
general case maybe you are too late to

00:15:22,710 --> 00:15:26,520
subscribe to a stream and there might be

00:15:24,300 --> 00:15:29,940
elements already gone by its life it

00:15:26,520 --> 00:15:32,550
might be a live thing lazy collections

00:15:29,940 --> 00:15:33,480
they have really a linear thing linea

00:15:32,550 --> 00:15:35,459
our dsl various

00:15:33,480 --> 00:15:38,250
one if you look at immutable stream then

00:15:35,459 --> 00:15:41,430
you can map flatmap and those things but

00:15:38,250 --> 00:15:43,410
there's no graph really whereas with

00:15:41,430 --> 00:15:45,630
acha stream as you know you can build

00:15:43,410 --> 00:15:48,389
graphs arbitrarily large ones and it's

00:15:45,630 --> 00:15:51,930
more modular you can kind of draw boxes

00:15:48,389 --> 00:15:53,730
and reuse them if you have a lazy

00:15:51,930 --> 00:15:55,230
collection like a number of

00:15:53,730 --> 00:15:57,060
transformations on a mutable stream then

00:15:55,230 --> 00:15:59,000
that's really in pec you just get back a

00:15:57,060 --> 00:16:01,680
stream there's nothing you can inspect

00:15:59,000 --> 00:16:04,380
without a stream and also with slave you

00:16:01,680 --> 00:16:06,240
can actually look inside of that

00:16:04,380 --> 00:16:08,790
transformation chain as we will see

00:16:06,240 --> 00:16:11,130
later and kind of inspect what is

00:16:08,790 --> 00:16:13,529
happening like what what is this trans

00:16:11,130 --> 00:16:15,870
does this graph this pipeline what does

00:16:13,529 --> 00:16:18,500
it consist of which is very helpful if

00:16:15,870 --> 00:16:21,899
you want to debug and other things and

00:16:18,500 --> 00:16:24,139
as we said before iterators can be

00:16:21,899 --> 00:16:27,510
consumed or is consumed always wear as

00:16:24,139 --> 00:16:30,170
immutable stream is repeatable and in

00:16:27,510 --> 00:16:32,459
acha as you as you know generally

00:16:30,170 --> 00:16:34,589
components try to be reusable but you

00:16:32,459 --> 00:16:36,959
don't know necessarily that they always

00:16:34,589 --> 00:16:39,899
are reusable it might be for example if

00:16:36,959 --> 00:16:41,850
they wrap a socket on the network then

00:16:39,899 --> 00:16:43,260
the data that come out of there they're

00:16:41,850 --> 00:16:44,940
not buffered if you not actively

00:16:43,260 --> 00:16:47,100
buffered buffering them then they're not

00:16:44,940 --> 00:16:50,220
repeatable so you don't really know

00:16:47,100 --> 00:16:52,350
enslave you everything will always be

00:16:50,220 --> 00:16:53,910
consumed so you always need to recreate

00:16:52,350 --> 00:16:55,980
recreate everything so there's no

00:16:53,910 --> 00:16:57,839
question about whether it's reusable or

00:16:55,980 --> 00:17:01,709
not it's just never reusable just like a

00:16:57,839 --> 00:17:04,010
future or an iterator we'll see so

00:17:01,709 --> 00:17:08,720
before we dive into the into an example

00:17:04,010 --> 00:17:11,699
there these are the RP the API basics

00:17:08,720 --> 00:17:15,419
basically we have a stream a pipe and

00:17:11,699 --> 00:17:19,380
the drain which roughly corresponds to

00:17:15,419 --> 00:17:20,730
what acha calls source flow and sink and

00:17:19,380 --> 00:17:23,819
the reason why I gave a different name

00:17:20,730 --> 00:17:26,669
so far is because I assume that you will

00:17:23,819 --> 00:17:29,570
often have both on your classpath and

00:17:26,669 --> 00:17:32,790
just to make interoperability easier

00:17:29,570 --> 00:17:34,320
different names are kind of helpful this

00:17:32,790 --> 00:17:35,820
might not always be like that but

00:17:34,320 --> 00:17:37,290
currently that's what it is so there's a

00:17:35,820 --> 00:17:38,880
sway of course stream which is similar

00:17:37,290 --> 00:17:41,700
to the source there's a pipe which is

00:17:38,880 --> 00:17:44,100
similar to the flow and has a drain

00:17:41,700 --> 00:17:46,169
which is not to the sink and as you know

00:17:44,100 --> 00:17:47,070
as you can see already here there's no

00:17:46,169 --> 00:17:48,960
additional

00:17:47,070 --> 00:17:50,610
type parameter like you have it in ARCA

00:17:48,960 --> 00:17:52,440
stream where there's the materialization

00:17:50,610 --> 00:17:54,870
value as type parameter this doesn't

00:17:52,440 --> 00:17:57,390
exist in this wave and we'll see that

00:17:54,870 --> 00:17:58,650
later why that's the case okay so now

00:17:57,390 --> 00:18:00,570
let's let's actually switch to an

00:17:58,650 --> 00:18:02,640
example so some of you might know this

00:18:00,570 --> 00:18:05,100
is gap in this example I've used that

00:18:02,640 --> 00:18:07,170
several times already and the basic very

00:18:05,100 --> 00:18:10,470
basic simulation we just say okay we

00:18:07,170 --> 00:18:12,600
want to simulate pie and we are estimate

00:18:10,470 --> 00:18:15,210
pie and we do that with the monte carlo

00:18:12,600 --> 00:18:17,610
method so we generate random points in

00:18:15,210 --> 00:18:19,920
this unit square and then we just look

00:18:17,610 --> 00:18:21,630
are we inside of a circle or aren't we

00:18:19,920 --> 00:18:23,250
on the outside so in which area are we

00:18:21,630 --> 00:18:24,930
and then by counting the samples that we

00:18:23,250 --> 00:18:27,540
have we can approximate pie in a very

00:18:24,930 --> 00:18:30,570
simple way so that's just a model

00:18:27,540 --> 00:18:32,430
moderately interesting example the goal

00:18:30,570 --> 00:18:34,260
is to build something like a streaming

00:18:32,430 --> 00:18:37,620
operational stream based application

00:18:34,260 --> 00:18:39,090
that exercises all types of stream

00:18:37,620 --> 00:18:42,000
transformations as we've seen them

00:18:39,090 --> 00:18:44,340
before so we want to exercise Fanon's

00:18:42,000 --> 00:18:46,050
fan-out stream of streams and so on so I

00:18:44,340 --> 00:18:47,400
implemented this you can implement that

00:18:46,050 --> 00:18:50,910
in in Scala if you want to in a few

00:18:47,400 --> 00:18:53,130
lines maybe that's a nice you no small

00:18:50,910 --> 00:18:56,100
task for yourself how can you implement

00:18:53,130 --> 00:18:57,750
that in the shortest way with for

00:18:56,100 --> 00:18:58,980
example with the collections so the goal

00:18:57,750 --> 00:19:00,480
here is not to build something that's

00:18:58,980 --> 00:19:02,700
really short but just build something

00:19:00,480 --> 00:19:07,800
that works and exercises as much as

00:19:02,700 --> 00:19:10,890
possible ok so this is the translation

00:19:07,800 --> 00:19:13,530
into a stream graph so we start by

00:19:10,890 --> 00:19:15,600
generating random double values infinite

00:19:13,530 --> 00:19:17,430
stream of random double value so that's

00:19:15,600 --> 00:19:20,400
the elements that come out of here will

00:19:17,430 --> 00:19:22,950
be doubles and then we do a group into

00:19:20,400 --> 00:19:26,190
two so we get back the stream elements

00:19:22,950 --> 00:19:28,710
will be a sec of doubles then we can map

00:19:26,190 --> 00:19:30,540
to a point which is a case class so now

00:19:28,710 --> 00:19:33,120
we have semantic value x and y values

00:19:30,540 --> 00:19:35,370
that's the point inside the unit unit

00:19:33,120 --> 00:19:39,420
square and then we just do a fan out

00:19:35,370 --> 00:19:42,090
just in order to do a find out then we

00:19:39,420 --> 00:19:44,190
have two branches one we are filtering

00:19:42,090 --> 00:19:46,530
whether the the point is in the circle

00:19:44,190 --> 00:19:48,930
and on the other side we filter if it's

00:19:46,530 --> 00:19:51,270
not in the circle then we map once more

00:19:48,930 --> 00:19:55,290
and then we fan in with a merge so both

00:19:51,270 --> 00:19:57,000
branches get merged back in and we end

00:19:55,290 --> 00:19:58,890
up with a common super type of inner

00:19:57,000 --> 00:20:00,730
sample and outer sample which is sample

00:19:58,890 --> 00:20:03,160
and then we do a scan upper

00:20:00,730 --> 00:20:05,049
that you might know from the collections

00:20:03,160 --> 00:20:06,700
it's the same kind of logic similar to a

00:20:05,049 --> 00:20:10,030
fold but it actually admits every

00:20:06,700 --> 00:20:13,840
element we drop the first then we inject

00:20:10,030 --> 00:20:17,559
so we create a stream of streams and let

00:20:13,840 --> 00:20:21,309
the next element decide when to end an

00:20:17,559 --> 00:20:25,570
inner stream so we map across the stream

00:20:21,309 --> 00:20:28,090
of stream of straight this is actually

00:20:25,570 --> 00:20:30,760
not quite right well it's true the

00:20:28,090 --> 00:20:33,280
extreme elements is a stream of state so

00:20:30,760 --> 00:20:35,230
we have a stream of stream of state so

00:20:33,280 --> 00:20:37,030
we always drop 1 million and take one

00:20:35,230 --> 00:20:39,010
basically we just want to see every

00:20:37,030 --> 00:20:40,929
million element that's what we want to

00:20:39,010 --> 00:20:42,669
see all the others we just drop so we

00:20:40,929 --> 00:20:45,100
let the simulation run in every million

00:20:42,669 --> 00:20:48,040
element we are interested in then we

00:20:45,100 --> 00:20:50,650
flatten the opposite of the inject we

00:20:48,040 --> 00:20:52,559
map to string we take a certain number

00:20:50,650 --> 00:20:55,780
and then we just say for each print line

00:20:52,559 --> 00:20:58,240
so what this does when it runs it just

00:20:55,780 --> 00:20:59,919
instantiates the graph it will run run

00:20:58,240 --> 00:21:02,710
run and after a million samples have

00:20:59,919 --> 00:21:04,690
have run will see a line pop up and it

00:21:02,710 --> 00:21:08,350
will continue running until you know in

00:21:04,690 --> 00:21:11,740
this case ten lines reprint so let's see

00:21:08,350 --> 00:21:17,250
so that's the app that's all it is

00:21:11,740 --> 00:21:19,600
nothing else and we start by importing

00:21:17,250 --> 00:21:22,480
this that's all you need to do really

00:21:19,600 --> 00:21:25,059
most of the time then this line gives us

00:21:22,480 --> 00:21:27,100
an streaming environment it's pretty

00:21:25,059 --> 00:21:29,350
similar to an actor system that you know

00:21:27,100 --> 00:21:31,470
from from from acha it just gives you

00:21:29,350 --> 00:21:33,880
you know the kind of all-encompassing

00:21:31,470 --> 00:21:35,919
world on the outside contains

00:21:33,880 --> 00:21:37,870
configurations and dispatches and/or

00:21:35,919 --> 00:21:39,970
everything that you probably need then

00:21:37,870 --> 00:21:42,790
we instantiate a random and we start off

00:21:39,970 --> 00:21:44,200
with this one so we have a continued

00:21:42,790 --> 00:21:47,710
that's the stream that we've just seen

00:21:44,200 --> 00:21:51,100
random next double we group we map this

00:21:47,710 --> 00:21:52,960
is a fan out we'll see later what exact

00:21:51,100 --> 00:21:55,630
how exactly that works but basically it

00:21:52,960 --> 00:21:58,690
allows you to write in a in affluent way

00:21:55,630 --> 00:22:00,610
your graph with acha stream you can't

00:21:58,690 --> 00:22:02,890
really do that in that world you need to

00:22:00,610 --> 00:22:04,900
break out and kind of use the graph dsl

00:22:02,890 --> 00:22:07,330
to build a graph like that with with

00:22:04,900 --> 00:22:09,040
sway for many simple graphs even more

00:22:07,330 --> 00:22:11,950
complicated ones you can use a fluent

00:22:09,040 --> 00:22:14,140
dsl to write that up so here this is the

00:22:11,950 --> 00:22:15,460
first branch and that's

00:22:14,140 --> 00:22:17,350
the second branch that we've seen and

00:22:15,460 --> 00:22:20,500
here we say okay now we want to merge

00:22:17,350 --> 00:22:23,110
that we scan we drop we inject that's

00:22:20,500 --> 00:22:25,420
exactly as it was just on the chart so

00:22:23,110 --> 00:22:27,430
that's the nice thing we can draw the

00:22:25,420 --> 00:22:29,650
logic on a white board and then

00:22:27,430 --> 00:22:32,320
translate that into the into the code

00:22:29,650 --> 00:22:36,730
almost one by one one to one and that's

00:22:32,320 --> 00:22:39,100
great so we flattened concat we map we

00:22:36,730 --> 00:22:40,960
take 50 in this case and then we for

00:22:39,100 --> 00:22:46,660
each print line now what is interesting

00:22:40,960 --> 00:22:48,910
here is all of this runs on the color

00:22:46,660 --> 00:22:50,830
thread because there's nothing in there

00:22:48,910 --> 00:22:53,740
that requires a synchronous dispatch

00:22:50,830 --> 00:22:55,870
necessarily there's there's no operation

00:22:53,740 --> 00:22:58,150
in there that needs a concept of time

00:22:55,870 --> 00:23:00,580
for example if you put in a throttle

00:22:58,150 --> 00:23:02,560
that somehow says okay every hundred

00:23:00,580 --> 00:23:04,450
milliseconds I only allow one element

00:23:02,560 --> 00:23:06,240
for example then you need a synchronous

00:23:04,450 --> 00:23:08,500
dispatch because there will be a timing

00:23:06,240 --> 00:23:09,880
question but here there is nothing like

00:23:08,500 --> 00:23:12,610
that so if there is nothing that

00:23:09,880 --> 00:23:15,610
requires a synchronous dispatch and you

00:23:12,610 --> 00:23:17,170
don't actively tell it to dispatch to

00:23:15,610 --> 00:23:20,980
some dispatcher then it won't it will

00:23:17,170 --> 00:23:24,040
just run on your thread so once this is

00:23:20,980 --> 00:23:26,920
all completed then we just print total

00:23:24,040 --> 00:23:30,220
time and we measure the chupah ok so

00:23:26,920 --> 00:23:33,130
let's see so I compile I have a nice

00:23:30,220 --> 00:23:36,730
alias so everything is good and then I

00:23:33,130 --> 00:23:41,170
just run main so let's see what happens

00:23:36,730 --> 00:23:44,320
and as you see it starts and it

00:23:41,170 --> 00:23:46,150
approximates pi like that actually the

00:23:44,320 --> 00:23:49,270
the technique the Monte Carlo technique

00:23:46,150 --> 00:23:52,300
is pretty crappy for approximating pi

00:23:49,270 --> 00:23:54,850
because you it's exponential if you need

00:23:52,300 --> 00:23:57,100
if you want one more digit of accuracy

00:23:54,850 --> 00:23:59,770
you need to write run 10 times as many

00:23:57,100 --> 00:24:02,110
samples so you don't really get very far

00:23:59,770 --> 00:24:04,270
but it helps us here and it shows okay

00:24:02,110 --> 00:24:05,980
the 50 million samples will go through

00:24:04,270 --> 00:24:09,280
the total thing in 16 seconds so we have

00:24:05,980 --> 00:24:11,320
about 3 million elements per second that

00:24:09,280 --> 00:24:13,060
we can shoot through this so that gives

00:24:11,320 --> 00:24:15,930
us a rough indication for what the

00:24:13,060 --> 00:24:21,430
performance is of how this thing can run

00:24:15,930 --> 00:24:26,260
just so maybe let's look at the same

00:24:21,430 --> 00:24:27,730
thing in in acha stream so this is this

00:24:26,260 --> 00:24:30,370
basically the same

00:24:27,730 --> 00:24:32,610
example just a nucca stream it looks

00:24:30,370 --> 00:24:34,600
very similar there's a little bit of

00:24:32,610 --> 00:24:37,840
different stuff for example the

00:24:34,600 --> 00:24:39,310
broadcast filter emerged part I had to

00:24:37,840 --> 00:24:42,640
write like this there might be another

00:24:39,310 --> 00:24:44,410
way to do this now but this is this is

00:24:42,640 --> 00:24:48,000
how you do it so that's basically the

00:24:44,410 --> 00:24:51,130
diamond in between that we had there and

00:24:48,000 --> 00:24:52,900
we can use split win here which creates

00:24:51,130 --> 00:24:55,060
a stream of streams and so on and we can

00:24:52,900 --> 00:24:57,220
do khong catsup streams it's a new new

00:24:55,060 --> 00:25:00,550
way that allows everything to run in in

00:24:57,220 --> 00:25:04,630
a fused fashion and will take 30 so if

00:25:00,550 --> 00:25:08,050
we want to we can also run that so let's

00:25:04,630 --> 00:25:09,760
see how that works this will now need to

00:25:08,050 --> 00:25:11,140
dispatch it won't run on your caller

00:25:09,760 --> 00:25:14,650
threat because that's not what occurred

00:25:11,140 --> 00:25:16,870
stream does but it's it's configured in

00:25:14,650 --> 00:25:19,060
a way to run as fast as it can on one

00:25:16,870 --> 00:25:21,550
thread alone so without it with this

00:25:19,060 --> 00:25:25,030
little dispatch as possible and you see

00:25:21,550 --> 00:25:27,220
it it's not that there's no that that

00:25:25,030 --> 00:25:30,850
much of a difference it's currently it's

00:25:27,220 --> 00:25:32,230
about maybe you know half half the

00:25:30,850 --> 00:25:35,530
throughput but that doesn't really say

00:25:32,230 --> 00:25:37,030
much because as usual this is not a

00:25:35,530 --> 00:25:38,740
proper benchmark and we don't really

00:25:37,030 --> 00:25:40,510
know where this different comes from

00:25:38,740 --> 00:25:42,070
there might be some components that are

00:25:40,510 --> 00:25:44,530
actually faster than on the other side

00:25:42,070 --> 00:25:47,200
and so on so this is a very very

00:25:44,530 --> 00:25:51,310
artificial one kind of thing but for for

00:25:47,200 --> 00:25:55,440
this application we we can see that this

00:25:51,310 --> 00:25:58,420
wave is about twice as fast if we go to

00:25:55,440 --> 00:26:01,180
yeah let's go back to the example and

00:25:58,420 --> 00:26:05,200
turn it asynchronously so turn it into

00:26:01,180 --> 00:26:07,890
something a sink so if we want to make

00:26:05,200 --> 00:26:10,090
this now let's say we want to actually

00:26:07,890 --> 00:26:11,800
paralyzed this currently it's not

00:26:10,090 --> 00:26:14,170
paralyzed it runs all in one thread as

00:26:11,800 --> 00:26:16,150
we said we could for example add an

00:26:14,170 --> 00:26:18,430
asynchronous boundary here and we could

00:26:16,150 --> 00:26:21,340
say okay let's split the whole pipeline

00:26:18,430 --> 00:26:24,160
into two parts the upper part runs in

00:26:21,340 --> 00:26:25,840
its own thread or thread pool and the

00:26:24,160 --> 00:26:27,820
lower part also so we could put an

00:26:25,840 --> 00:26:31,390
asynchronous boundary at that point so

00:26:27,820 --> 00:26:33,400
that makes everything be dispatched now

00:26:31,390 --> 00:26:35,080
in order to be able to then look at

00:26:33,400 --> 00:26:39,010
those things we need to change a few

00:26:35,080 --> 00:26:40,690
things so for example I'll print down

00:26:39,010 --> 00:26:41,500
here when the main thread exits because

00:26:40,690 --> 00:26:46,150
it will immediately

00:26:41,500 --> 00:26:48,580
exit and we need to so if we look at

00:26:46,150 --> 00:26:51,370
this for example what the type of this

00:26:48,580 --> 00:26:53,560
is then IntelliJ tells us this is a

00:26:51,370 --> 00:26:54,910
future of unit so this actually produces

00:26:53,560 --> 00:26:56,710
something at the end it's a future of

00:26:54,910 --> 00:26:57,940
unit there's no result but the future

00:26:56,710 --> 00:27:01,450
will be completed when everything is

00:26:57,940 --> 00:27:07,330
done so and we use that signal to to

00:27:01,450 --> 00:27:10,900
print our our end result so here we need

00:27:07,330 --> 00:27:13,690
to import to new things that we had had

00:27:10,900 --> 00:27:17,500
before that's fine so we only because

00:27:13,690 --> 00:27:19,060
it's slower we only do 30 okay then

00:27:17,500 --> 00:27:22,660
because we are here we're doing an

00:27:19,060 --> 00:27:24,850
uncomplete and that needs an executor so

00:27:22,660 --> 00:27:28,240
dispatcher we need to import one more

00:27:24,850 --> 00:27:30,100
thing which is the default dispatcher

00:27:28,240 --> 00:27:33,310
which is pretty much similar to what you

00:27:30,100 --> 00:27:37,080
have in our car so let's see whether

00:27:33,310 --> 00:27:43,480
that runs see whether compile first

00:27:37,080 --> 00:27:48,550
might be something missing no so let's

00:27:43,480 --> 00:27:49,900
run it so it still runs but it as we

00:27:48,550 --> 00:27:52,120
said we split the pipeline into

00:27:49,900 --> 00:27:54,010
relatively easily just by saying we want

00:27:52,120 --> 00:27:56,230
an asynchronous boundary at that point

00:27:54,010 --> 00:27:58,780
and now two things can run in parallel

00:27:56,230 --> 00:28:01,300
theoretically it could be faster but in

00:27:58,780 --> 00:28:03,100
fact it's a bit slower because the

00:28:01,300 --> 00:28:05,980
overhead of the a sunken is boundary at

00:28:03,100 --> 00:28:07,630
this point outweighs the benefits of

00:28:05,980 --> 00:28:10,570
parallelization because those things are

00:28:07,630 --> 00:28:12,670
so lightweight that a single thread can

00:28:10,570 --> 00:28:14,080
actually do it faster now in your real

00:28:12,670 --> 00:28:15,700
world applications you probably are

00:28:14,080 --> 00:28:17,980
going to have more heavyweight

00:28:15,700 --> 00:28:21,430
transformations and then the

00:28:17,980 --> 00:28:23,170
paralyzation might buy you something but

00:28:21,430 --> 00:28:24,700
it's important this shows it's important

00:28:23,170 --> 00:28:26,500
to not just you know slap in

00:28:24,700 --> 00:28:29,650
asynchronous boundaries at some point

00:28:26,500 --> 00:28:31,180
but place them consciously and maybe you

00:28:29,650 --> 00:28:33,580
know tune a little bit try taking

00:28:31,180 --> 00:28:35,950
outputting at the different positions to

00:28:33,580 --> 00:28:40,690
see for your applications and your load

00:28:35,950 --> 00:28:42,910
what's the best way to to to paralyze

00:28:40,690 --> 00:28:46,330
the stream but the key point is that you

00:28:42,910 --> 00:28:48,370
have very high level tools to say

00:28:46,330 --> 00:28:50,530
exactly where you want those

00:28:48,370 --> 00:28:52,000
asynchronous boundaries you contrast

00:28:50,530 --> 00:28:55,610
that for example with an actor based

00:28:52,000 --> 00:28:57,790
application then this is much more Lola

00:28:55,610 --> 00:29:00,230
then you would have to really you know

00:28:57,790 --> 00:29:02,720
think first where do you want it and

00:29:00,230 --> 00:29:04,070
then write everything so that you have

00:29:02,720 --> 00:29:05,390
an asynchronous boundary at that point

00:29:04,070 --> 00:29:07,460
if you want to move it somewhere else

00:29:05,390 --> 00:29:09,590
then that's a major undertaking in an

00:29:07,460 --> 00:29:11,630
ecto based application here it's very

00:29:09,590 --> 00:29:15,110
simple I just move the line you know to

00:29:11,630 --> 00:29:16,970
two lines down that's it so that's the

00:29:15,110 --> 00:29:19,010
kind of high-level power that that I'm

00:29:16,970 --> 00:29:20,630
looking for or that we all like in the

00:29:19,010 --> 00:29:21,740
in the collections and this basically

00:29:20,630 --> 00:29:23,570
gives you everything that the

00:29:21,740 --> 00:29:25,610
collections already have plus more

00:29:23,570 --> 00:29:27,700
that's where the generalization is and

00:29:25,610 --> 00:29:33,950
that's where the sexiness comes from

00:29:27,700 --> 00:29:36,080
okay so let's move on that was a demo

00:29:33,950 --> 00:29:39,110
now let's look at the dsl basics a bit

00:29:36,080 --> 00:29:42,140
more so the basics as we've seen before

00:29:39,110 --> 00:29:44,030
so the simple one is you have a stream

00:29:42,140 --> 00:29:48,830
you attach a few transformations and

00:29:44,030 --> 00:29:51,830
then you can do you say to and the drain

00:29:48,830 --> 00:29:53,510
and that gives you a package stream

00:29:51,830 --> 00:29:55,760
that's not running yet but it's

00:29:53,510 --> 00:29:57,770
everything is set up and all you need to

00:29:55,760 --> 00:29:59,960
do is push the button and say go and

00:29:57,770 --> 00:30:01,520
that's what you do with run pretty

00:29:59,960 --> 00:30:02,780
similar to what you have what you have

00:30:01,520 --> 00:30:04,520
with our constrain where you set up the

00:30:02,780 --> 00:30:06,200
blueprint first and then when you say

00:30:04,520 --> 00:30:08,330
run it will materialize and actually

00:30:06,200 --> 00:30:12,980
actually do the running when you when

00:30:08,330 --> 00:30:14,960
you when you change or separate those

00:30:12,980 --> 00:30:20,169
steps like that it gives us the ability

00:30:14,960 --> 00:30:23,299
for example to take the ready to be run

00:30:20,169 --> 00:30:25,640
description of the graph and not run it

00:30:23,299 --> 00:30:29,870
but may be inspected maybe you know do

00:30:25,640 --> 00:30:32,809
something with it as we'll see so how do

00:30:29,870 --> 00:30:36,260
fan ins work so if you have a fan in

00:30:32,809 --> 00:30:38,390
then you can do something like that this

00:30:36,260 --> 00:30:41,690
shows the logic of this if you have a

00:30:38,390 --> 00:30:44,840
stream you can call attached and you can

00:30:41,690 --> 00:30:47,270
take other streams and you know attach

00:30:44,840 --> 00:30:50,330
them and you get like a bunch of open

00:30:47,270 --> 00:30:52,340
streams and you can define you know

00:30:50,330 --> 00:30:53,750
which in which order they should be

00:30:52,340 --> 00:30:55,309
attached but they're they're a bunch of

00:30:53,750 --> 00:30:58,490
open streams and if you have several

00:30:55,309 --> 00:31:00,380
open you can call dot fan in connect

00:30:58,490 --> 00:31:03,200
concat for example and that will

00:31:00,380 --> 00:31:05,330
concatenate and merge them all or you

00:31:03,200 --> 00:31:07,220
could say fine and merge or fan in

00:31:05,330 --> 00:31:09,500
whatever there are several different

00:31:07,220 --> 00:31:11,180
logic alternatives

00:31:09,500 --> 00:31:14,330
how you can merge streams and that's but

00:31:11,180 --> 00:31:19,100
that's a simple fan in alright so that's

00:31:14,330 --> 00:31:21,260
how the dsl works there you could also

00:31:19,100 --> 00:31:23,180
have heterogeneous fan and so they don't

00:31:21,260 --> 00:31:25,010
all have to have the same type if they

00:31:23,180 --> 00:31:27,200
have different types like here for

00:31:25,010 --> 00:31:29,060
example we have a stream of strings we

00:31:27,200 --> 00:31:30,620
attach an in-stream and the float stream

00:31:29,060 --> 00:31:32,840
so you have three different streams open

00:31:30,620 --> 00:31:35,630
and then you could say fan into tupple

00:31:32,840 --> 00:31:38,510
and that would create a stream of the

00:31:35,630 --> 00:31:40,520
tupple of those three things it could

00:31:38,510 --> 00:31:43,130
also you know fan into an H list you can

00:31:40,520 --> 00:31:47,060
fan into a product which is nice because

00:31:43,130 --> 00:31:49,790
that's just a case class and it's wave

00:31:47,060 --> 00:31:51,500
relies on shapeless to kind of do all

00:31:49,790 --> 00:31:52,940
the boiler plate underneath so you don't

00:31:51,500 --> 00:31:55,160
have to concern you yourselves with

00:31:52,940 --> 00:31:56,930
actually creating those case classes you

00:31:55,160 --> 00:31:59,150
just attach those streams and the

00:31:56,930 --> 00:32:01,880
financial product will you know take one

00:31:59,150 --> 00:32:03,860
of everything and once it has from every

00:32:01,880 --> 00:32:05,300
upstream one value it will create a case

00:32:03,860 --> 00:32:08,480
class instance and push that downstream

00:32:05,300 --> 00:32:11,680
that's helpful there's also that you can

00:32:08,480 --> 00:32:14,030
also do fan into a some type for example

00:32:11,680 --> 00:32:15,670
into when you have a stream of left's

00:32:14,030 --> 00:32:19,340
and a stream of rights you can actually

00:32:15,670 --> 00:32:20,900
merge them into a stream of either so

00:32:19,340 --> 00:32:23,570
that's that's nice so you have we have

00:32:20,900 --> 00:32:26,750
fan ins I Toro genius or homogeneous as

00:32:23,570 --> 00:32:28,820
you want this is the same kind of idea

00:32:26,750 --> 00:32:31,400
here now let's look at the other side

00:32:28,820 --> 00:32:34,850
how does a fan-out work fennel is a bit

00:32:31,400 --> 00:32:36,560
more might seem initially a bit more

00:32:34,850 --> 00:32:38,600
difficult so if you have a fan-out you

00:32:36,560 --> 00:32:42,470
call a fan-out broadcast and that gives

00:32:38,600 --> 00:32:45,560
you the ability to say dotsub and that

00:32:42,470 --> 00:32:47,360
attaches a sub stream so one of the

00:32:45,560 --> 00:32:49,340
branches underneath and then you can

00:32:47,360 --> 00:32:51,170
just continue writing whatever you would

00:32:49,340 --> 00:32:53,000
want to write on that sub branch and

00:32:51,170 --> 00:32:54,290
then in the end you have to ability you

00:32:53,000 --> 00:32:57,410
have two possibilities you can either

00:32:54,290 --> 00:32:59,870
say to drain which kind of sinks this

00:32:57,410 --> 00:33:02,930
dream away to somewhere or you can leave

00:32:59,870 --> 00:33:04,970
it open by just saying the end if you

00:33:02,930 --> 00:33:06,710
leave it open it will just stay open and

00:33:04,970 --> 00:33:08,600
there are several ways to deal with

00:33:06,710 --> 00:33:10,790
those open streams one of them is for

00:33:08,600 --> 00:33:13,250
example you could just at the end you

00:33:10,790 --> 00:33:14,870
just say continue which allows you to if

00:33:13,250 --> 00:33:18,410
you have a single open stream to just

00:33:14,870 --> 00:33:20,179
continue writing you know your DSL with

00:33:18,410 --> 00:33:22,820
the one open substream that you left

00:33:20,179 --> 00:33:23,270
open as is the case here and the order

00:33:22,820 --> 00:33:24,650
doesn't matter

00:33:23,270 --> 00:33:26,240
it could be you know you could have the

00:33:24,650 --> 00:33:27,620
one that's open as the first or the

00:33:26,240 --> 00:33:31,760
second or whatever you want because

00:33:27,620 --> 00:33:34,400
sometimes the order matters if you have

00:33:31,760 --> 00:33:36,020
several sub streams open then you get

00:33:34,400 --> 00:33:38,030
into a situation where you have that you

00:33:36,020 --> 00:33:40,340
can mix fan in and fan out and that's

00:33:38,030 --> 00:33:43,100
what we had in our in our example right

00:33:40,340 --> 00:33:46,700
before so here for example we have this

00:33:43,100 --> 00:33:49,850
kind of situation you have a fan out we

00:33:46,700 --> 00:33:52,690
attached a sub a sub stream do something

00:33:49,850 --> 00:33:57,380
with it and then leave it open then we

00:33:52,690 --> 00:33:59,270
attach an external integer stream and we

00:33:57,380 --> 00:34:01,190
can have another sub to the to the fan

00:33:59,270 --> 00:34:03,950
out broadcast here for example so this

00:34:01,190 --> 00:34:06,380
one is just another attachment to this

00:34:03,950 --> 00:34:10,130
one and we just sync it just for fun to

00:34:06,380 --> 00:34:11,899
ignore that's what I show here you can

00:34:10,130 --> 00:34:14,720
also attach something from the outside

00:34:11,899 --> 00:34:16,669
on the left if you want right so that

00:34:14,720 --> 00:34:18,470
you can kind of plug and play this thing

00:34:16,669 --> 00:34:20,450
together how you want it and then at the

00:34:18,470 --> 00:34:22,070
end we could just say fan into tuple for

00:34:20,450 --> 00:34:26,080
example and that ends up with a stream

00:34:22,070 --> 00:34:28,520
of a couple of float string and it and

00:34:26,080 --> 00:34:30,800
so what this is supposed to show is that

00:34:28,520 --> 00:34:34,190
it's quite flexible of how you can you

00:34:30,800 --> 00:34:37,730
know create fanon's and work with them

00:34:34,190 --> 00:34:39,560
and then maybe take a sub subset of the

00:34:37,730 --> 00:34:41,120
open sub streams that you have and kind

00:34:39,560 --> 00:34:44,540
of merge them in and pipe them somewhere

00:34:41,120 --> 00:34:46,399
else and so that's it's it's nice

00:34:44,540 --> 00:34:48,350
because the idea is as I've said in the

00:34:46,399 --> 00:34:49,970
beginning is to allow you to write very

00:34:48,350 --> 00:34:53,270
concise code with a very little

00:34:49,970 --> 00:34:54,740
boilerplate so this is powerful enough

00:34:53,270 --> 00:34:57,500
to allow you to write a lot of the

00:34:54,740 --> 00:35:00,290
graphs that you would maybe sometimes

00:34:57,500 --> 00:35:02,420
need to construct by hand now it with 1

00:35:00,290 --> 00:35:04,760
dsl it's it's not powerful enough to go

00:35:02,420 --> 00:35:06,620
to create all kinds of graphs there are

00:35:04,760 --> 00:35:08,690
some situations for example when you

00:35:06,620 --> 00:35:10,670
have recursion well you can't you know

00:35:08,690 --> 00:35:12,470
only rely on that so there's something

00:35:10,670 --> 00:35:14,930
else that we need in order to be

00:35:12,470 --> 00:35:17,390
arbitrarily powerful and that's just a

00:35:14,930 --> 00:35:19,400
simple coupling a coupling is just a

00:35:17,390 --> 00:35:21,050
piece of pipe that you can freely

00:35:19,400 --> 00:35:23,600
connect from both sides once you have

00:35:21,050 --> 00:35:25,490
that you can construct anything and here

00:35:23,600 --> 00:35:27,530
in this example it's actually a bit

00:35:25,490 --> 00:35:30,560
involved it's not a lot of code but

00:35:27,530 --> 00:35:33,560
let's let's see what is the output of

00:35:30,560 --> 00:35:36,710
this small snippet so we have a stream

00:35:33,560 --> 00:35:39,830
of ins 1 2 3 and we conquer

00:35:36,710 --> 00:35:41,750
which is just another simpler way of

00:35:39,830 --> 00:35:44,869
saying you know have a fan in attached

00:35:41,750 --> 00:35:46,910
one and then do flattened concord so we

00:35:44,869 --> 00:35:50,119
attach the output piece of the coupling

00:35:46,910 --> 00:35:55,040
all right afterwards and then we fan out

00:35:50,119 --> 00:35:57,380
broadcast with two sub streams the first

00:35:55,040 --> 00:35:59,150
one in the first substream underneath to

00:35:57,380 --> 00:36:02,630
find out we drop now we take the first

00:35:59,150 --> 00:36:05,570
element we add three and then we attach

00:36:02,630 --> 00:36:08,330
it to the input of the coupling okay so

00:36:05,570 --> 00:36:12,830
there is your loop there's a loop there

00:36:08,330 --> 00:36:15,830
can you see that loop now okay and here

00:36:12,830 --> 00:36:17,240
we just say we attach another output to

00:36:15,830 --> 00:36:18,800
the fan out and we say we want to

00:36:17,240 --> 00:36:21,349
continue writing with that it's just

00:36:18,800 --> 00:36:23,359
it's just a shortcut for attaching an

00:36:21,349 --> 00:36:25,190
empty substream and do continue and then

00:36:23,359 --> 00:36:29,960
we do for each print line so so what's

00:36:25,190 --> 00:36:31,940
the output going to be so it's one two

00:36:29,960 --> 00:36:33,680
three four yeah one two three four

00:36:31,940 --> 00:36:35,839
that's the idea if i run this I want to

00:36:33,680 --> 00:36:37,670
see one two three four because the first

00:36:35,839 --> 00:36:40,700
one that goes in here is going to be a

00:36:37,670 --> 00:36:43,430
one we we attached now we add three and

00:36:40,700 --> 00:36:45,619
then concatenate that at the end so it

00:36:43,430 --> 00:36:50,900
should be one two three four now when

00:36:45,619 --> 00:36:52,820
you run this it doesn't do anything now

00:36:50,900 --> 00:36:54,440
why is that and that's the the purpose

00:36:52,820 --> 00:36:56,900
of the text of this example is to show

00:36:54,440 --> 00:36:58,580
you that there are some tricky bits

00:36:56,900 --> 00:37:00,500
about streaming that you probably have

00:36:58,580 --> 00:37:04,430
noticed maybe already in your working

00:37:00,500 --> 00:37:07,280
with acha stream sometimes it's not

00:37:04,430 --> 00:37:10,190
quite as easy to see where there is a

00:37:07,280 --> 00:37:13,369
problem now why does this deadlock the

00:37:10,190 --> 00:37:16,280
reason is the fan-out broadcast here

00:37:13,369 --> 00:37:19,520
will only request from its upstream if

00:37:16,280 --> 00:37:21,770
both of its sub streams signal that they

00:37:19,520 --> 00:37:24,140
want something signal demand otherwise

00:37:21,770 --> 00:37:26,900
it won't signal to its upstream give me

00:37:24,140 --> 00:37:32,180
an element now one of its sub streams

00:37:26,900 --> 00:37:35,540
the first one actually you know feedback

00:37:32,180 --> 00:37:38,570
on top of the of the broadcast so it

00:37:35,540 --> 00:37:40,730
will only demand if the fan-out demands

00:37:38,570 --> 00:37:44,000
but the fan-out will not demand until it

00:37:40,730 --> 00:37:46,250
demands you see so there is there is in

00:37:44,000 --> 00:37:48,410
this loop that we've created there's

00:37:46,250 --> 00:37:49,940
just no demand and if there's no demand

00:37:48,410 --> 00:37:52,550
nothing will run

00:37:49,940 --> 00:37:54,560
so once we have realized that we can we

00:37:52,550 --> 00:37:57,290
also see how we can fix this we just

00:37:54,560 --> 00:37:59,180
need to add a buffer just a buffer

00:37:57,290 --> 00:38:01,250
element of size one is enough to

00:37:59,180 --> 00:38:03,440
generate the initial bit of demand that

00:38:01,250 --> 00:38:06,109
we need to get the get the cycle going

00:38:03,440 --> 00:38:08,119
right now that's not something that is

00:38:06,109 --> 00:38:09,560
very easy to see in the beginning of you

00:38:08,119 --> 00:38:14,750
if you're not used to how those things

00:38:09,560 --> 00:38:16,400
work and in our in our work on acha HTTP

00:38:14,750 --> 00:38:18,680
with acha stream we had several time

00:38:16,400 --> 00:38:20,930
situations like that where you set up a

00:38:18,680 --> 00:38:23,119
nice fancy pipeline a big graph and you

00:38:20,930 --> 00:38:24,980
you started and for some reason it

00:38:23,119 --> 00:38:28,430
doesn't behave as you want so it's

00:38:24,980 --> 00:38:31,819
important to be able to inspect what is

00:38:28,430 --> 00:38:34,069
happening to visualize maybe even the

00:38:31,819 --> 00:38:37,069
state of this graph and this pipeline

00:38:34,069 --> 00:38:39,050
like where is the pressure in the hose

00:38:37,069 --> 00:38:41,900
so to speak and where is no pressure you

00:38:39,050 --> 00:38:43,910
once you see that it's easy right if you

00:38:41,900 --> 00:38:45,650
have a visualization of the state of

00:38:43,910 --> 00:38:49,220
this graph and are in the in its

00:38:45,650 --> 00:38:50,720
runnable shape it becomes easy to see if

00:38:49,220 --> 00:38:54,920
you don't have it you need to build it

00:38:50,720 --> 00:38:59,150
in your head and then that's tough I'll

00:38:54,920 --> 00:39:00,829
show you the more more on that in a

00:38:59,150 --> 00:39:03,079
second there is more that I could be

00:39:00,829 --> 00:39:06,440
talking about in terms of the the dsl

00:39:03,079 --> 00:39:08,240
and house wave gives you features that

00:39:06,440 --> 00:39:09,410
are that are helpful for example one

00:39:08,240 --> 00:39:11,540
important thing that you probably

00:39:09,410 --> 00:39:14,810
already used with acha stream is the

00:39:11,540 --> 00:39:17,359
ability to group a piece of your total

00:39:14,810 --> 00:39:19,790
graph together give it a name and kind

00:39:17,359 --> 00:39:22,640
of encapsulated so that you say okay

00:39:19,790 --> 00:39:24,260
this this set up I'll just you know draw

00:39:22,640 --> 00:39:26,540
a fence around to give it a name and

00:39:24,260 --> 00:39:29,119
kind of store it away so that you can

00:39:26,540 --> 00:39:32,270
build composable layers and become more

00:39:29,119 --> 00:39:34,760
and more high level without having to

00:39:32,270 --> 00:39:37,010
build everything in one go that's it

00:39:34,760 --> 00:39:38,630
exists since wavin is called modules we

00:39:37,010 --> 00:39:39,530
won't have time to go into that but

00:39:38,630 --> 00:39:41,240
there are several types there are

00:39:39,530 --> 00:39:43,010
forward modules that only go forward

00:39:41,240 --> 00:39:44,810
they're ones that you may be known from

00:39:43,010 --> 00:39:46,430
Marcus trim as well which is called BD

00:39:44,810 --> 00:39:47,780
flow where you have two things that go

00:39:46,430 --> 00:39:48,829
in opposite directions as it's often the

00:39:47,780 --> 00:39:51,560
case when you work with Network for

00:39:48,829 --> 00:39:52,940
example so we could be talking about

00:39:51,560 --> 00:39:54,770
this but we don't have time there's a

00:39:52,940 --> 00:39:56,329
test kit and so on there's one thing

00:39:54,770 --> 00:39:58,130
that I want to still go into because

00:39:56,329 --> 00:40:02,060
this is important to me debugging

00:39:58,130 --> 00:40:03,620
inspection and rendering so let's go

00:40:02,060 --> 00:40:07,670
back to our example that we

00:40:03,620 --> 00:40:11,630
out here and change it so that we can

00:40:07,670 --> 00:40:17,960
actually render it so what we do is take

00:40:11,630 --> 00:40:20,390
this away and we just say we say this so

00:40:17,960 --> 00:40:23,240
we don't run it we just create the whole

00:40:20,390 --> 00:40:27,020
thing so we do it we attach a drain then

00:40:23,240 --> 00:40:29,990
we give it a name call Val piping for

00:40:27,020 --> 00:40:32,450
example so that's the piping that's the

00:40:29,990 --> 00:40:35,690
type of this of this whole thing if I

00:40:32,450 --> 00:40:38,180
ask idea what the type is it's a piping

00:40:35,690 --> 00:40:42,200
it's just the name of a runnable graph

00:40:38,180 --> 00:40:46,040
and what we want to do is we want to we

00:40:42,200 --> 00:40:47,930
want to see what it looks like we

00:40:46,040 --> 00:40:50,210
there's a method called currently pipe

00:40:47,930 --> 00:40:51,590
element render it's just don't worry

00:40:50,210 --> 00:40:53,450
about the names there might be they

00:40:51,590 --> 00:40:56,420
might change but the idea is we want to

00:40:53,450 --> 00:40:58,580
render the structure of the graph and

00:40:56,420 --> 00:41:02,480
look at it so let's see whether the

00:40:58,580 --> 00:41:05,570
compiles probably doesn't because I'm

00:41:02,480 --> 00:41:09,740
still here I still have unused imports

00:41:05,570 --> 00:41:12,020
here one good thing that I always do now

00:41:09,740 --> 00:41:14,300
in my project is I always enabled fatal

00:41:12,020 --> 00:41:15,920
warnings because that really helps so

00:41:14,300 --> 00:41:17,030
the compiler will not actually compile

00:41:15,920 --> 00:41:19,750
if I have a warning and there is a

00:41:17,030 --> 00:41:24,320
warning in there if I don't if I have

00:41:19,750 --> 00:41:28,310
unused imports so this works so it puts

00:41:24,320 --> 00:41:30,740
out an ASCII rendering an ASCII graph of

00:41:28,310 --> 00:41:32,900
what this pipeline looks like I was not

00:41:30,740 --> 00:41:35,570
extremely pretty here but you can see

00:41:32,900 --> 00:41:38,660
exactly what we had before you can now

00:41:35,570 --> 00:41:41,030
see this on your console in ascii art so

00:41:38,660 --> 00:41:44,810
to speak so this here it's rendered in

00:41:41,030 --> 00:41:46,550
seven bit 7-bit ascii the core point is

00:41:44,810 --> 00:41:48,290
to give every element in your in your

00:41:46,550 --> 00:41:50,840
stream every transformation its own line

00:41:48,290 --> 00:41:53,690
so that we have space to actually attach

00:41:50,840 --> 00:41:55,300
attributes and do what not and render

00:41:53,690 --> 00:41:56,960
there's a complete graph renderer

00:41:55,300 --> 00:41:59,240
implemented here that can render

00:41:56,960 --> 00:42:01,520
arbitrarily arbitrary graphs in ascii

00:41:59,240 --> 00:42:02,840
art like that and i thought i can do

00:42:01,520 --> 00:42:08,060
that in three days but it took a lot

00:42:02,840 --> 00:42:09,380
longer let me tell you that yeah so for

00:42:08,060 --> 00:42:11,180
example here's another example this is

00:42:09,380 --> 00:42:13,070
the coupling example we had before but

00:42:11,180 --> 00:42:15,950
this time rendered with a different type

00:42:13,070 --> 00:42:16,859
of glue set as i call it which is kind

00:42:15,950 --> 00:42:19,739
of like the font

00:42:16,859 --> 00:42:22,470
and this is for example a 2 by 2 utf-8

00:42:19,739 --> 00:42:24,509
rendering so every every little element

00:42:22,470 --> 00:42:26,970
in the graph is two by two and it's

00:42:24,509 --> 00:42:28,859
utf-8 and it looks much prettier than if

00:42:26,970 --> 00:42:30,329
you do a 7-bit ascii rendering and you

00:42:28,859 --> 00:42:33,329
can just influence that yourself you can

00:42:30,329 --> 00:42:34,710
pick your there are few predefined kind

00:42:33,329 --> 00:42:36,900
of ways to render graph you can define

00:42:34,710 --> 00:42:38,849
your own and then you can you have

00:42:36,900 --> 00:42:42,210
complete freedom what you want to show

00:42:38,849 --> 00:42:47,789
for every transformation now this is the

00:42:42,210 --> 00:42:49,440
basic the basic the basic stuff that we

00:42:47,789 --> 00:42:52,980
need in order to be able to do exactly

00:42:49,440 --> 00:42:57,269
what I said before show the city of the

00:42:52,980 --> 00:42:58,710
the current state of the of the pipeline

00:42:57,269 --> 00:43:00,029
when it's running so that's currently

00:42:58,710 --> 00:43:02,239
that's not yet implemented but it's not

00:43:00,029 --> 00:43:05,099
much anymore to actually at runtime

00:43:02,239 --> 00:43:07,499
render this and for example color

00:43:05,099 --> 00:43:09,539
according to pressure so that you can

00:43:07,499 --> 00:43:12,960
see in this color example ah there's no

00:43:09,539 --> 00:43:14,309
pressure right which means there's a

00:43:12,960 --> 00:43:16,109
dead log that's the reason for the dead

00:43:14,309 --> 00:43:18,390
log that's the idea behind this

00:43:16,109 --> 00:43:23,009
rendering so that's one for example one

00:43:18,390 --> 00:43:25,859
interesting feature in enslave the basic

00:43:23,009 --> 00:43:28,950
design goals were so far really runtime

00:43:25,859 --> 00:43:30,359
performance so just be fast because

00:43:28,950 --> 00:43:32,009
that's what everyone wants even though

00:43:30,359 --> 00:43:34,589
you don't need it you still want it to

00:43:32,009 --> 00:43:36,660
be fast that's just the way it is and

00:43:34,589 --> 00:43:40,799
the synchronous mode is we is really

00:43:36,660 --> 00:43:42,690
crucial we need to explore more how far

00:43:40,799 --> 00:43:44,339
we can push this like what exactly we

00:43:42,690 --> 00:43:46,289
can we can really run synchronously on

00:43:44,339 --> 00:43:48,180
the caller thread but if you don't need

00:43:46,289 --> 00:43:50,670
to ditch this patch and you can run

00:43:48,180 --> 00:43:52,380
synchronously then you really move into

00:43:50,670 --> 00:43:54,299
the space that is currently occupied all

00:43:52,380 --> 00:43:56,670
by the collections that we use on our

00:43:54,299 --> 00:43:59,609
local thread because then the overhead

00:43:56,670 --> 00:44:01,259
becomes really really small and we can

00:43:59,609 --> 00:44:03,239
reach for those tools where we would

00:44:01,259 --> 00:44:07,589
otherwise reach for you know vectors

00:44:03,239 --> 00:44:10,019
lists and so on that's the idea the dsl

00:44:07,589 --> 00:44:12,210
supposed to be as concise as possible

00:44:10,019 --> 00:44:14,279
without you know sacrificing too much

00:44:12,210 --> 00:44:16,769
readability and of course it's a

00:44:14,279 --> 00:44:18,930
trade-off so it's the first idea we

00:44:16,769 --> 00:44:20,819
wanted to be lightweight no dependencies

00:44:18,930 --> 00:44:22,920
or as few dependencies as possible

00:44:20,819 --> 00:44:25,259
currently there's there's basically only

00:44:22,920 --> 00:44:27,420
shapeless that's for example no alka and

00:44:25,259 --> 00:44:28,720
debug ability very important because

00:44:27,420 --> 00:44:32,350
we've been

00:44:28,720 --> 00:44:37,510
yeah with yeah we've been through the

00:44:32,350 --> 00:44:41,050
crap okay quick comparisons wave versus

00:44:37,510 --> 00:44:42,550
acha streams akka stream wave is non

00:44:41,050 --> 00:44:44,530
lifted as we've said before so

00:44:42,550 --> 00:44:46,630
everything runs once and is consumed

00:44:44,530 --> 00:44:49,090
akka stream is lifted this wave can be

00:44:46,630 --> 00:44:51,370
synchronous or asynchronous depending on

00:44:49,090 --> 00:44:56,560
what you need what you want akka stream

00:44:51,370 --> 00:44:58,420
is always a sink which means it akka

00:44:56,560 --> 00:45:01,240
stream runs on actors underneath which

00:44:58,420 --> 00:45:02,530
of course run on executives and wave

00:45:01,240 --> 00:45:05,350
runs it on the call the threat or an

00:45:02,530 --> 00:45:09,960
executive the slave is scala only so

00:45:05,350 --> 00:45:12,460
there's no java side which has benefits

00:45:09,960 --> 00:45:15,160
not all not to everyone but especially

00:45:12,460 --> 00:45:18,910
for the maintainer zit has certain

00:45:15,160 --> 00:45:22,090
serious benefits the dsl is shapeless

00:45:18,910 --> 00:45:24,640
based force wave annika stream we

00:45:22,090 --> 00:45:28,060
currently have a combination of you know

00:45:24,640 --> 00:45:31,210
affluent dsl and the graph dsl and the

00:45:28,060 --> 00:45:33,040
point is that we my goal is to have

00:45:31,210 --> 00:45:34,840
something that we can innovate quickly

00:45:33,040 --> 00:45:36,790
on that could just you know because the

00:45:34,840 --> 00:45:38,920
space is so new there's so much to still

00:45:36,790 --> 00:45:40,120
explore and learn that it's great to

00:45:38,920 --> 00:45:43,060
have something that we can just change

00:45:40,120 --> 00:45:45,940
that we're not really bound by binary

00:45:43,060 --> 00:45:47,650
compatibility and long-term support and

00:45:45,940 --> 00:45:49,860
so on but just you know be able to try

00:45:47,650 --> 00:45:54,880
out things because it's tremendously

00:45:49,860 --> 00:45:56,650
interesting and attractive a quick quick

00:45:54,880 --> 00:45:58,000
comparison to understand what the lifted

00:45:56,650 --> 00:46:02,470
versus non lift that means basically

00:45:58,000 --> 00:46:04,930
enslave the dsl creates directly the

00:46:02,470 --> 00:46:07,270
runnable structure its single use but

00:46:04,930 --> 00:46:09,040
it's in spectabile innaka stream the dsl

00:46:07,270 --> 00:46:11,740
creates a blueprint which is reusable

00:46:09,040 --> 00:46:13,660
and inspect able and that gets

00:46:11,740 --> 00:46:17,440
materialized into the runnable structure

00:46:13,660 --> 00:46:18,790
you can see how this might the stuff on

00:46:17,440 --> 00:46:20,800
the left side might be faster in certain

00:46:18,790 --> 00:46:22,450
situations depending on whether you re

00:46:20,800 --> 00:46:23,890
materializing and existing blueprint or

00:46:22,450 --> 00:46:26,350
not and then of course there are

00:46:23,890 --> 00:46:27,880
benefits to having a blueprint so this

00:46:26,350 --> 00:46:30,070
is not an invalid approach at all it's a

00:46:27,880 --> 00:46:32,560
very valid approach for for our co

00:46:30,070 --> 00:46:35,950
stream it's just with waves we want to

00:46:32,560 --> 00:46:37,450
explore the other side what happens if

00:46:35,950 --> 00:46:39,230
we don't have blueprints for like what

00:46:37,450 --> 00:46:42,200
can we do what can we not do

00:46:39,230 --> 00:46:45,260
the road map I just released version 05

00:46:42,200 --> 00:46:47,480
mm one this morning it's on maven

00:46:45,260 --> 00:46:49,190
central you can go play with it next we

00:46:47,480 --> 00:46:51,650
need documentation documentation and

00:46:49,190 --> 00:46:53,150
documentation that's the next big thing

00:46:51,650 --> 00:46:55,400
there are few remaining holes in terms

00:46:53,150 --> 00:46:56,780
of operations and we need more

00:46:55,400 --> 00:46:58,760
performance tuning and of course we can

00:46:56,780 --> 00:47:00,530
add all kinds of features but we want to

00:46:58,760 --> 00:47:03,410
get the core right there's one small

00:47:00,530 --> 00:47:06,680
thing I want to before we finish I want

00:47:03,410 --> 00:47:09,290
to point to the development process for

00:47:06,680 --> 00:47:11,240
this I also decided that we want to

00:47:09,290 --> 00:47:13,340
change this a little bit over what we

00:47:11,240 --> 00:47:15,920
had for example with spray where we

00:47:13,340 --> 00:47:19,070
didn't quite manage to really expand the

00:47:15,920 --> 00:47:22,690
core maintainer group as much as what

00:47:19,070 --> 00:47:24,920
maybe have been beneficial so this time

00:47:22,690 --> 00:47:26,630
we'll try that collective code

00:47:24,920 --> 00:47:28,640
construction contract is something that

00:47:26,630 --> 00:47:32,450
Peter Hinton's that you might have known

00:47:28,640 --> 00:47:34,970
that you might know has wrote written up

00:47:32,450 --> 00:47:37,250
for zeromq where it worked exceptionally

00:47:34,970 --> 00:47:39,530
well we're going to try that here so the

00:47:37,250 --> 00:47:41,480
cool thing is to just make it very easy

00:47:39,530 --> 00:47:43,010
for contributors to come in common board

00:47:41,480 --> 00:47:47,780
become maintain us and really drive this

00:47:43,010 --> 00:47:51,640
forward resources you can find them you

00:47:47,780 --> 00:47:51,640
know them probably thank you very much

00:47:58,260 --> 00:48:03,600
if we still have time for quick

00:48:00,930 --> 00:48:09,450
questions I know I think time is up but

00:48:03,600 --> 00:48:12,090
does anyone have questions yes so quick

00:48:09,450 --> 00:48:14,430
one about the a synchronized it wasn't

00:48:12,090 --> 00:48:15,900
it supposed to be akka strange supposed

00:48:14,430 --> 00:48:19,950
to be weak either a synchronous or

00:48:15,900 --> 00:48:22,200
possibly synchron's I mean from the

00:48:19,950 --> 00:48:24,540
blueprint you could possibly build to

00:48:22,200 --> 00:48:26,400
your probably could yeah it's not

00:48:24,540 --> 00:48:29,070
something that is currently in there and

00:48:26,400 --> 00:48:33,810
I've I don't know whether that was ever

00:48:29,070 --> 00:48:35,430
really a target or goal or maybe yeah we

00:48:33,810 --> 00:48:37,520
could ask the the aqha team whether

00:48:35,430 --> 00:48:39,680
that's potentially interesting or not

00:48:37,520 --> 00:48:42,240
but it's definitely not off the

00:48:39,680 --> 00:48:43,380
impossible to you know to materialize

00:48:42,240 --> 00:48:44,820
the blueprint to something that runs

00:48:43,380 --> 00:48:47,070
synchronously that's true it's just not

00:48:44,820 --> 00:48:49,410
currently something that I did I don't

00:48:47,070 --> 00:48:55,560
know whether it's a golden up anyone

00:48:49,410 --> 00:48:56,910
else yes two monix yes how does it

00:48:55,560 --> 00:48:59,970
compare to monic since the question I

00:48:56,910 --> 00:49:01,470
don't know good question I haven't had

00:48:59,970 --> 00:49:04,200
time to relook at mnemonics I know it

00:49:01,470 --> 00:49:07,740
exists so that's another example that

00:49:04,200 --> 00:49:10,530
there is lots of interest in this in

00:49:07,740 --> 00:49:12,240
this space and i think it's it's good if

00:49:10,530 --> 00:49:14,390
we have more implementations right we

00:49:12,240 --> 00:49:17,040
need more to kind of more people on this

00:49:14,390 --> 00:49:19,350
explore it because it's tremendously

00:49:17,040 --> 00:49:21,150
interesting i guess we'll see much more

00:49:19,350 --> 00:49:22,740
of this in the future and so the more

00:49:21,150 --> 00:49:24,900
projects we have the more we can learn

00:49:22,740 --> 00:49:26,310
from each other so we don't actually see

00:49:24,900 --> 00:49:28,320
each other as competitors at all it's

00:49:26,310 --> 00:49:31,610
more like explore the space together in

00:49:28,320 --> 00:49:34,730
different ways that's the basic idea

00:49:31,610 --> 00:49:34,730

YouTube URL: https://www.youtube.com/watch?v=htwmROeki0c


