Title: Implementing Microservices with Scale and Akka   by Vaughn Vernon
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
What are microservices all about, and are they practical for your enterprise? How granular should a microservice be, and what approach should you use to determine the proper and appropriate boundaries between microservices? How can each microservice communicate with others in a distributed computing environment to correctly fulfill business objectives? How can my microservices adhere to the tenets of reactive software, being responsive, resilient, elastic, and message driven? Using Scala and Akka to implement microservices, this talk will demonstrate how you can implement microservices while answering all of the questions posed, and more. The talk will show you how to carefully craft microservices and to model the business domain within. You will experience advanced use of Akka throughout.
Captions: 
	00:00:01,860 --> 00:00:08,189
welcome everyone thank you for attending

00:00:04,200 --> 00:00:10,469
I'm going to be giving away this book my

00:00:08,189 --> 00:00:14,039
latest book domain-driven design

00:00:10,469 --> 00:00:18,780
distilled after my talk so if you want

00:00:14,039 --> 00:00:20,970
to maybe hand your name to someone at

00:00:18,780 --> 00:00:24,710
the end of the row who could bring it up

00:00:20,970 --> 00:00:29,990
later so we don't interrupt the the talk

00:00:24,710 --> 00:00:34,100
welcome to do that this is implementing

00:00:29,990 --> 00:00:38,730
microservices with scala and akka and

00:00:34,100 --> 00:00:42,239
don't forget to turn in your rating of

00:00:38,730 --> 00:00:44,280
the session just to give you a little

00:00:42,239 --> 00:00:49,739
bit of information about myself you can

00:00:44,280 --> 00:00:53,160
contact me by email using Vaughn at for

00:00:49,739 --> 00:01:00,450
comprehension calm and follow me on

00:00:53,160 --> 00:01:03,799
twitter at von Vernon Vernon and for

00:01:00,450 --> 00:01:07,799
comprehension is both an online learning

00:01:03,799 --> 00:01:10,290
site and also I provide live training

00:01:07,799 --> 00:01:13,460
around domain-driven design and go

00:01:10,290 --> 00:01:16,170
reactive with acha i'm the author of

00:01:13,460 --> 00:01:18,240
implementing domain driven design this

00:01:16,170 --> 00:01:21,479
is a best-seller that's been out for

00:01:18,240 --> 00:01:23,850
about three and a half years now and I'm

00:01:21,479 --> 00:01:25,409
also the author of reactive messaging

00:01:23,850 --> 00:01:28,200
patterns with the actor model this is

00:01:25,409 --> 00:01:32,220
specifically asked Allah and akka book

00:01:28,200 --> 00:01:34,500
that discusses various design patterns

00:01:32,220 --> 00:01:39,990
and integration patterns that you can

00:01:34,500 --> 00:01:42,030
use for implementing applications and it

00:01:39,990 --> 00:01:44,759
has a domain driven design slant and

00:01:42,030 --> 00:01:46,619
then this is my latest book domain

00:01:44,759 --> 00:01:50,340
driven design distill which I'll be

00:01:46,619 --> 00:01:52,189
giving away after this one thing that I

00:01:50,340 --> 00:01:57,650
have noticed I don't know about you but

00:01:52,189 --> 00:02:02,310
we seem to be an industry of extremes

00:01:57,650 --> 00:02:05,130
developers seem to go from one extreme

00:02:02,310 --> 00:02:08,340
to another and one of the extremes that

00:02:05,130 --> 00:02:13,489
I see is that acid has to apply

00:02:08,340 --> 00:02:13,489
everywhere acid transactions right

00:02:14,190 --> 00:02:21,720
your application must be acid if you

00:02:17,880 --> 00:02:24,540
integrate with other applications we

00:02:21,720 --> 00:02:28,500
have to mimic acid through XA or global

00:02:24,540 --> 00:02:32,040
transactions why is this the case why do

00:02:28,500 --> 00:02:35,100
we seem to think that acid is necessary

00:02:32,040 --> 00:02:38,340
everywhere if you actually go to the

00:02:35,100 --> 00:02:40,410
business that you work in if this

00:02:38,340 --> 00:02:44,250
business existed or something like it

00:02:40,410 --> 00:02:48,840
existed before computers existed you

00:02:44,250 --> 00:02:51,720
would probably find that businesses did

00:02:48,840 --> 00:02:55,310
not have consistency in their business

00:02:51,720 --> 00:03:00,420
processes ever their business processes

00:02:55,310 --> 00:03:04,890
worked by handing and circulating memos

00:03:00,420 --> 00:03:10,230
and work orders and so forth from one

00:03:04,890 --> 00:03:11,670
inbox to another you could sort of say

00:03:10,230 --> 00:03:15,510
that you could mimic the same thing

00:03:11,670 --> 00:03:19,860
today using email imagine running a

00:03:15,510 --> 00:03:21,390
business entirely by email well it's not

00:03:19,860 --> 00:03:25,560
that we recommend that you run a

00:03:21,390 --> 00:03:28,050
business by email but in essence that is

00:03:25,560 --> 00:03:31,440
the way businesses ran and almost

00:03:28,050 --> 00:03:34,290
nothing was consistent before computers

00:03:31,440 --> 00:03:37,610
so that question is where did we get the

00:03:34,290 --> 00:03:40,080
idea that business had to be

00:03:37,610 --> 00:03:44,030
transactionally consistent all over the

00:03:40,080 --> 00:03:46,950
place at all times consistency is

00:03:44,030 --> 00:03:50,790
overrated because actually the business

00:03:46,950 --> 00:03:56,100
most likely doesn't need to have acid

00:03:50,790 --> 00:03:58,680
transactions or XA in all cases you know

00:03:56,100 --> 00:04:03,780
where to get the answer ask the business

00:03:58,680 --> 00:04:07,440
how much time would be acceptable for me

00:04:03,780 --> 00:04:09,720
to allow our our team to allow between

00:04:07,440 --> 00:04:12,570
the consistency of this data and the

00:04:09,720 --> 00:04:16,080
consistency of this data a few seconds a

00:04:12,570 --> 00:04:18,380
few minutes a few days sometimes

00:04:16,080 --> 00:04:21,780
consistency is it required for many days

00:04:18,380 --> 00:04:26,420
so why do we think that we have to build

00:04:21,780 --> 00:04:28,800
in transactional consistency everywhere

00:04:26,420 --> 00:04:32,510
everything used to be eventually

00:04:28,800 --> 00:04:36,480
consistent and one of the big advantages

00:04:32,510 --> 00:04:39,330
to eventual consistency is it actually

00:04:36,480 --> 00:04:45,000
matches the business needs in many many

00:04:39,330 --> 00:04:48,810
cases another extreme that we see today

00:04:45,000 --> 00:04:52,530
is in the size of a service what is the

00:04:48,810 --> 00:04:56,820
size of a service should a service be a

00:04:52,530 --> 00:05:01,310
monolith that's one extreme or should a

00:04:56,820 --> 00:05:05,370
service be micro or nano sized and if so

00:05:01,310 --> 00:05:08,940
what is a micro service after all what

00:05:05,370 --> 00:05:12,540
is microservice represent is it a number

00:05:08,940 --> 00:05:15,060
of lines of code or is it some other

00:05:12,540 --> 00:05:18,540
measurement how do we measure what is

00:05:15,060 --> 00:05:22,170
the right size of a service on the one

00:05:18,540 --> 00:05:25,680
extreme we have the monolith or worse

00:05:22,170 --> 00:05:30,030
than a monolith what most applications

00:05:25,680 --> 00:05:32,580
turn into is a big ball of mud this

00:05:30,030 --> 00:05:35,810
pattern is seen everywhere and I do a

00:05:32,580 --> 00:05:39,390
lot of consulting I teach at a lot of

00:05:35,810 --> 00:05:43,140
organizations fortune 500 fortune ten

00:05:39,390 --> 00:05:46,200
companies and everywhere I go I see the

00:05:43,140 --> 00:05:47,820
big ball of mud lurking and everybody

00:05:46,200 --> 00:05:49,740
has to integrate with the big ball of

00:05:47,820 --> 00:05:52,380
mud or everybody has to get their hands

00:05:49,740 --> 00:05:54,720
dirty with the big ball of mud nobody

00:05:52,380 --> 00:05:58,380
wants to but why did we build it that

00:05:54,720 --> 00:06:03,150
way in the first place I described big

00:05:58,380 --> 00:06:06,090
ball of mud as being worse than a

00:06:03,150 --> 00:06:08,040
monolith because at least usually a

00:06:06,090 --> 00:06:11,190
monolith that is well designed well

00:06:08,040 --> 00:06:14,310
modeled can be reasoned about whereas a

00:06:11,190 --> 00:06:18,450
big ball of mud is several tangled

00:06:14,310 --> 00:06:22,500
models that are implicit instead of

00:06:18,450 --> 00:06:24,990
explicit and the models are not well

00:06:22,500 --> 00:06:27,570
defined and so if you go to one place to

00:06:24,990 --> 00:06:29,730
try to understand what happens here

00:06:27,570 --> 00:06:32,060
actually if you touch this piece of code

00:06:29,730 --> 00:06:35,010
it's going to have a ripple on something

00:06:32,060 --> 00:06:38,310
unseen and another part of this large

00:06:35,010 --> 00:06:39,810
tangled model that is implicitly maybe

00:06:38,310 --> 00:06:44,570
five six seven eight

00:06:39,810 --> 00:06:47,310
models actually but what about

00:06:44,570 --> 00:06:50,220
microservices if you are going to

00:06:47,310 --> 00:06:51,990
implement microservices how do you go

00:06:50,220 --> 00:06:55,320
about doing that well we'll talk about

00:06:51,990 --> 00:07:00,450
some general guidance that others have

00:06:55,320 --> 00:07:03,240
given about micro services and this is

00:07:00,450 --> 00:07:06,990
one of those what are these numbers have

00:07:03,240 --> 00:07:14,130
in common one hundred four hundred one

00:07:06,990 --> 00:07:17,310
thousand lines of code right this is how

00:07:14,130 --> 00:07:19,710
many lines of code your micro service

00:07:17,310 --> 00:07:23,940
should be and I've heard all of these

00:07:19,710 --> 00:07:27,030
they conflict so if I write a micro

00:07:23,940 --> 00:07:31,020
service that's 450 lines long is it too

00:07:27,030 --> 00:07:33,240
big if I write a micro service that's

00:07:31,020 --> 00:07:37,260
100 lines long does it mean it's a good

00:07:33,240 --> 00:07:39,479
microservice should we use 1000 as an

00:07:37,260 --> 00:07:41,220
upper bound and say that if your micro

00:07:39,479 --> 00:07:43,919
service is more than one thousand lines

00:07:41,220 --> 00:07:47,850
of code it's a bad microservice it

00:07:43,919 --> 00:07:49,830
shouldn't be out there I actually don't

00:07:47,850 --> 00:07:52,620
know the answer to that because i don't

00:07:49,830 --> 00:07:56,610
believe that line of code count is a

00:07:52,620 --> 00:08:01,500
good metric to use for determining what

00:07:56,610 --> 00:08:03,870
your micro service should be now if

00:08:01,500 --> 00:08:07,919
you've heard of Fred George Fred George

00:08:03,870 --> 00:08:10,500
claims to be the originator of the idea

00:08:07,919 --> 00:08:13,710
of micro services I don't know if that's

00:08:10,500 --> 00:08:16,410
true but he claims to be and and Fred

00:08:13,710 --> 00:08:20,340
George says that actually one page of

00:08:16,410 --> 00:08:23,010
code or he also uses the term 100 lines

00:08:20,340 --> 00:08:26,220
of code is a good size for a micro

00:08:23,010 --> 00:08:28,530
service one page of code what does that

00:08:26,220 --> 00:08:31,169
even mean what is one page of code does

00:08:28,530 --> 00:08:35,310
that mean sixty two lines if you use the

00:08:31,169 --> 00:08:37,469
old you know dot matrix printer I really

00:08:35,310 --> 00:08:40,440
don't know what if your lines break and

00:08:37,469 --> 00:08:42,270
you know what is one page of code does

00:08:40,440 --> 00:08:44,910
that mean what you can see on a screen

00:08:42,270 --> 00:08:48,120
what if my eyesight isn't as good as

00:08:44,910 --> 00:08:53,529
yours does that give us a good code line

00:08:48,120 --> 00:08:55,720
of code count and how many microservices

00:08:53,529 --> 00:08:59,230
he makes sense if you're going to

00:08:55,720 --> 00:09:02,439
develop microservices should you have

00:08:59,230 --> 00:09:04,660
thousands of microservices hundreds of

00:09:02,439 --> 00:09:08,019
microservices tens of thousands of

00:09:04,660 --> 00:09:10,420
microservices Fred George actually says

00:09:08,019 --> 00:09:13,389
that in the enterprise's where he works

00:09:10,420 --> 00:09:15,240
they have so many micro services that

00:09:13,389 --> 00:09:18,939
they don't actually know which

00:09:15,240 --> 00:09:21,509
microservices are still useful they're

00:09:18,939 --> 00:09:25,209
still deployed they're still running

00:09:21,509 --> 00:09:27,670
they still receive messages and act on

00:09:25,209 --> 00:09:31,649
things but they may not mean anything to

00:09:27,670 --> 00:09:35,499
the business what justifies that

00:09:31,649 --> 00:09:37,360
according to his guidance it's forty

00:09:35,499 --> 00:09:40,629
dollars a month to run that service in

00:09:37,360 --> 00:09:42,430
the cloud so who cares I don't think

00:09:40,629 --> 00:09:45,879
that that's a good measurement for a

00:09:42,430 --> 00:09:47,980
micro service so when you start thinking

00:09:45,879 --> 00:09:51,790
about the infrastructure to run these

00:09:47,980 --> 00:09:55,120
things the cognitive dissonance that and

00:09:51,790 --> 00:09:58,089
overload that that we have when we try

00:09:55,120 --> 00:10:00,339
to reason about a system with thousands

00:09:58,089 --> 00:10:02,589
and thousands of services that may not

00:10:00,339 --> 00:10:05,740
have any use to the organization any

00:10:02,589 --> 00:10:08,050
longer they're just running because it's

00:10:05,740 --> 00:10:11,319
cheap and we can continue to run them

00:10:08,050 --> 00:10:15,579
without any impact what do we do about

00:10:11,319 --> 00:10:18,639
that actually what is practical what is

00:10:15,579 --> 00:10:21,100
the good size for a micro service and

00:10:18,639 --> 00:10:24,730
what does domain driven design have to

00:10:21,100 --> 00:10:27,069
offer so as an author of two domain

00:10:24,730 --> 00:10:29,399
driven design books and consultant

00:10:27,069 --> 00:10:31,509
around domain driven design you probably

00:10:29,399 --> 00:10:33,819
imagine that I'm going to say that

00:10:31,509 --> 00:10:36,699
domain driven design has a lot to offer

00:10:33,819 --> 00:10:40,809
and I believe that is the case the

00:10:36,699 --> 00:10:43,750
answer is bounded context with domain

00:10:40,809 --> 00:10:47,920
driven design we have a notion of a

00:10:43,750 --> 00:10:51,639
bounded context this is where a specific

00:10:47,920 --> 00:10:56,110
domain model has relevance where the

00:10:51,639 --> 00:10:57,910
terms and expressions that we use in a

00:10:56,110 --> 00:11:03,670
business setting where a business

00:10:57,910 --> 00:11:07,000
context are bound within a specific area

00:11:03,670 --> 00:11:07,720
of the business and this is what we

00:11:07,000 --> 00:11:10,649
consider

00:11:07,720 --> 00:11:14,860
to be a domain model and it is often

00:11:10,649 --> 00:11:17,579
around what we refer to as a core domain

00:11:14,860 --> 00:11:20,410
the thing that is most competitively

00:11:17,579 --> 00:11:25,060
advantageous for your organization to

00:11:20,410 --> 00:11:29,399
put its resource developer investment

00:11:25,060 --> 00:11:29,399
into in order to create the most

00:11:29,730 --> 00:11:35,589
beneficial payback for your company in

00:11:33,459 --> 00:11:37,810
terms of competing with other

00:11:35,589 --> 00:11:40,649
organizations and a few if you're

00:11:37,810 --> 00:11:44,199
familiar with this book by sam newman

00:11:40,649 --> 00:11:47,740
building microservices sam newman talks

00:11:44,199 --> 00:11:51,730
about in his book using domain driven

00:11:47,740 --> 00:11:55,420
design bounded context as the basic

00:11:51,730 --> 00:11:59,069
boundary for each microservice now i

00:11:55,420 --> 00:12:02,319
think that sam Newman has a little bit

00:11:59,069 --> 00:12:06,279
definition of what a bounded context is

00:12:02,319 --> 00:12:09,519
I've talked to Sam briefly through

00:12:06,279 --> 00:12:13,029
Twitter actually what what size is

00:12:09,519 --> 00:12:15,790
abounded context then and Sam's answer

00:12:13,029 --> 00:12:17,350
is something like well it's as big as it

00:12:15,790 --> 00:12:19,149
needs to be in when it starts to feel

00:12:17,350 --> 00:12:21,490
like it's getting to be too big then you

00:12:19,149 --> 00:12:24,490
need a new bounded context and I think

00:12:21,490 --> 00:12:27,730
that that is actually not a good answer

00:12:24,490 --> 00:12:29,649
for what is the size of a bounded

00:12:27,730 --> 00:12:33,100
context and therefore what is the size

00:12:29,649 --> 00:12:36,279
of a micro service if it is a bounded

00:12:33,100 --> 00:12:39,459
context according to Fred George it

00:12:36,279 --> 00:12:42,040
should be just one entity in essence and

00:12:39,459 --> 00:12:45,730
many others have picked up on that if

00:12:42,040 --> 00:12:48,040
you actually look at the general

00:12:45,730 --> 00:12:50,319
guidance for the legume framework that

00:12:48,040 --> 00:12:53,290
that light then has just come out with

00:12:50,319 --> 00:12:56,470
in essence they're saying that a bounded

00:12:53,290 --> 00:12:59,649
context is roughly one entity type I

00:12:56,470 --> 00:13:02,620
know that that you know might not be

00:12:59,649 --> 00:13:04,329
exactly accurate but in essence that's

00:13:02,620 --> 00:13:08,139
what they're calling it a bounded

00:13:04,329 --> 00:13:11,050
context this is what a bounded context

00:13:08,139 --> 00:13:13,860
is this is the size of your bounded

00:13:11,050 --> 00:13:17,220
context ask your ubiquitous language

00:13:13,860 --> 00:13:20,829
what is the size of my bounded context

00:13:17,220 --> 00:13:21,070
what does that actually mean what is

00:13:20,829 --> 00:13:23,860
your

00:13:21,070 --> 00:13:29,320
ubiquitous language this language is

00:13:23,860 --> 00:13:33,960
developed by business experts who carry

00:13:29,320 --> 00:13:38,100
the vision of what will this product

00:13:33,960 --> 00:13:43,600
have why will this product make us

00:13:38,100 --> 00:13:47,920
competitively strategically superior to

00:13:43,600 --> 00:13:50,470
our competition and it's also shared

00:13:47,920 --> 00:13:54,310
with the developers on the team so we

00:13:50,470 --> 00:13:55,930
put together a group of domain experts

00:13:54,310 --> 00:14:00,760
and developers at least one domain

00:13:55,930 --> 00:14:03,970
expert probably one and maybe three four

00:14:00,760 --> 00:14:06,550
five developers on a team and they work

00:14:03,970 --> 00:14:08,500
out what the vision is what is the

00:14:06,550 --> 00:14:11,650
domain model and what does our

00:14:08,500 --> 00:14:15,340
ubiquitous language hold and oftentimes

00:14:11,650 --> 00:14:18,580
we think in terms of our ubiquitous

00:14:15,340 --> 00:14:23,230
language being a set of nouns developers

00:14:18,580 --> 00:14:25,110
say well its product if we're talking in

00:14:23,230 --> 00:14:28,270
scrum and application that helps

00:14:25,110 --> 00:14:31,740
developers manage scrum then it's the

00:14:28,270 --> 00:14:36,520
nouns it's the product it's the backlog

00:14:31,740 --> 00:14:39,250
it's the sprints it's the releases it's

00:14:36,520 --> 00:14:43,350
the team that's our ubiquitous language

00:14:39,250 --> 00:14:47,140
but actually the ubiquitous language is

00:14:43,350 --> 00:14:49,690
written much richer than that think of a

00:14:47,140 --> 00:14:51,850
ubiquitous language as being the

00:14:49,690 --> 00:14:55,990
linguistics the language that the team

00:14:51,850 --> 00:15:00,910
speaks that are all cohesive expressions

00:14:55,990 --> 00:15:06,010
that you can't actually make or state

00:15:00,910 --> 00:15:08,830
unless you use cohesive expression or

00:15:06,010 --> 00:15:11,890
terms together so the terms of your

00:15:08,830 --> 00:15:15,460
ubiquitous language will be together so

00:15:11,890 --> 00:15:20,250
for example I just used a scrum

00:15:15,460 --> 00:15:23,560
application for a bound of context in

00:15:20,250 --> 00:15:28,210
this case our bounded context would have

00:15:23,560 --> 00:15:30,820
product backlog item release sprint team

00:15:28,210 --> 00:15:33,670
team member and product owners sort of

00:15:30,820 --> 00:15:34,780
as a minimum size of our ubiquitous

00:15:33,670 --> 00:15:36,670
language

00:15:34,780 --> 00:15:39,730
but our ubiquitous language is not

00:15:36,670 --> 00:15:43,060
limited only to the entities or the

00:15:39,730 --> 00:15:46,300
aggregates within the micro service but

00:15:43,060 --> 00:15:49,540
if you want to see a decent size of a

00:15:46,300 --> 00:15:53,470
micro service this is a decent size of a

00:15:49,540 --> 00:15:57,040
micro service therefore the other parts

00:15:53,470 --> 00:16:00,460
that are not core that are not part of

00:15:57,040 --> 00:16:03,010
that ubiquitous language belong to a

00:16:00,460 --> 00:16:05,560
different bounded context and so in this

00:16:03,010 --> 00:16:07,630
case we have issue tracker which is a

00:16:05,560 --> 00:16:10,780
different bounded context we have

00:16:07,630 --> 00:16:13,000
collaboration which provides forums and

00:16:10,780 --> 00:16:16,120
discussions and we will actually use

00:16:13,000 --> 00:16:19,210
forums and discussions in the agile

00:16:16,120 --> 00:16:21,430
project management core context but they

00:16:19,210 --> 00:16:23,350
will not be part of that micro service

00:16:21,430 --> 00:16:25,720
they will be part of a different micro

00:16:23,350 --> 00:16:28,600
service and finally so that we don't

00:16:25,720 --> 00:16:30,790
silo our users and the roles that they

00:16:28,600 --> 00:16:33,790
play we have a separate micro service

00:16:30,790 --> 00:16:37,540
which is the identity and access bounded

00:16:33,790 --> 00:16:43,050
context okay now think about those as

00:16:37,540 --> 00:16:47,230
the practical size of micro services and

00:16:43,050 --> 00:16:49,870
compare that to what how many micro

00:16:47,230 --> 00:16:53,380
services we would have if we had one

00:16:49,870 --> 00:16:57,100
entity per micro service if you count

00:16:53,380 --> 00:17:01,150
the yellow circles in each of those

00:16:57,100 --> 00:17:05,710
bounded context it comes out to 35 okay

00:17:01,150 --> 00:17:10,720
is it exactly 35 maybe it's going to be

00:17:05,710 --> 00:17:14,100
40 or 50 but imagine deploying 35 to 50

00:17:10,720 --> 00:17:17,200
micro services in order to implement

00:17:14,100 --> 00:17:21,880
logically the same thing that you have

00:17:17,200 --> 00:17:26,050
here so which would you rather deploy 5

00:17:21,880 --> 00:17:29,860
micro services or 35 microservices or 50

00:17:26,050 --> 00:17:33,340
micro services so a micro service as a

00:17:29,860 --> 00:17:37,030
bounded context is larger than one

00:17:33,340 --> 00:17:40,240
entity but it's also much smaller than a

00:17:37,030 --> 00:17:43,150
monolith and definitely very difficult

00:17:40,240 --> 00:17:45,930
to turn into a big ball of mud because

00:17:43,150 --> 00:17:48,760
there just isn't that much to it on the

00:17:45,930 --> 00:17:52,570
other hand it is greater

00:17:48,760 --> 00:17:55,420
than a single entity so are ubiquitous

00:17:52,570 --> 00:17:59,590
language is greater than a single entity

00:17:55,420 --> 00:18:03,190
again use linguistics to determine what

00:17:59,590 --> 00:18:05,440
is cohesive within the discussions that

00:18:03,190 --> 00:18:09,610
we have on a team with our domain

00:18:05,440 --> 00:18:12,370
experts and our developers so are

00:18:09,610 --> 00:18:16,540
ubiquitous language includes entities it

00:18:12,370 --> 00:18:23,260
includes commands commands are the

00:18:16,540 --> 00:18:26,650
statement or intent to process some

00:18:23,260 --> 00:18:28,870
action and event messages are also part

00:18:26,650 --> 00:18:32,890
of the ubiquitous language this is a

00:18:28,870 --> 00:18:36,250
fact it's an outcome of a command that

00:18:32,890 --> 00:18:39,970
has been executed so you're ubiquitous

00:18:36,250 --> 00:18:42,520
language within a scrum or agile project

00:18:39,970 --> 00:18:46,870
management bounded context or micro

00:18:42,520 --> 00:18:52,560
service would include a product yes that

00:18:46,870 --> 00:18:57,010
receives a command plan backlog item and

00:18:52,560 --> 00:19:02,080
emits backlog item planned out of the

00:18:57,010 --> 00:19:06,960
product a backlog item entity receives a

00:19:02,080 --> 00:19:11,440
defined task command and it emits an

00:19:06,960 --> 00:19:13,840
event task defined these are all part of

00:19:11,440 --> 00:19:15,430
your ubiquitous language and you should

00:19:13,840 --> 00:19:18,760
have be able to have reasonable

00:19:15,430 --> 00:19:22,930
discussions with your domain experts

00:19:18,760 --> 00:19:25,600
about products about backlog items and

00:19:22,930 --> 00:19:30,250
the commands that they receive and the

00:19:25,600 --> 00:19:33,730
events that they commit also a very very

00:19:30,250 --> 00:19:38,100
important aspect of micro services is

00:19:33,730 --> 00:19:42,430
that each microservice must own its own

00:19:38,100 --> 00:19:45,280
database schema so in the case of our

00:19:42,430 --> 00:19:48,940
agile project management context it has

00:19:45,280 --> 00:19:51,850
its own database at least one in fact it

00:19:48,940 --> 00:19:54,580
has two databases and has one database

00:19:51,850 --> 00:19:57,520
that stores all of its events and it has

00:19:54,580 --> 00:20:00,790
a different database through which we

00:19:57,520 --> 00:20:01,389
perform queries so a query model and a

00:20:00,790 --> 00:20:04,059
command

00:20:01,389 --> 00:20:06,879
and we'll discuss that a little bit more

00:20:04,059 --> 00:20:09,729
later but also those other micro

00:20:06,879 --> 00:20:12,190
services that we saw before to the issue

00:20:09,729 --> 00:20:14,889
tracker the collaboration context the

00:20:12,190 --> 00:20:17,820
identity and access context and so forth

00:20:14,889 --> 00:20:21,489
each of those also have their own

00:20:17,820 --> 00:20:25,989
bounded content or their own databases

00:20:21,489 --> 00:20:28,869
within their bounded context so again we

00:20:25,989 --> 00:20:31,269
have an event Journal this is one

00:20:28,869 --> 00:20:33,549
database that holds all the events all

00:20:31,269 --> 00:20:35,679
the facts about what has ever happened

00:20:33,549 --> 00:20:39,219
within the micro service or bounded

00:20:35,679 --> 00:20:41,979
context so all events going in and those

00:20:39,219 --> 00:20:46,239
events can also go out and become

00:20:41,979 --> 00:20:50,079
stimulus to other bounded context then

00:20:46,239 --> 00:20:52,809
we have our query model and pardon me

00:20:50,079 --> 00:20:57,519
our query model is the model through

00:20:52,809 --> 00:21:01,059
which we have optimized queries that in

00:20:57,519 --> 00:21:05,619
essence are in the shape that the user

00:21:01,059 --> 00:21:08,769
needs to see on their screen and overall

00:21:05,619 --> 00:21:11,049
this this pattern is called see QRS

00:21:08,769 --> 00:21:13,929
perhaps you've heard of it stands for

00:21:11,049 --> 00:21:20,379
command query responsibility segregation

00:21:13,929 --> 00:21:24,159
which is kind of a mysterious name for a

00:21:20,379 --> 00:21:26,979
very powerful pattern that allows you to

00:21:24,159 --> 00:21:31,509
query in the form that the user needs to

00:21:26,979 --> 00:21:34,899
see and I'm also promoting the use of

00:21:31,509 --> 00:21:38,559
actors so actor model and akka are

00:21:34,899 --> 00:21:42,249
asynchronous services so you have

00:21:38,559 --> 00:21:46,599
service endpoints you have within the

00:21:42,249 --> 00:21:50,499
service itself your entities themselves

00:21:46,599 --> 00:21:52,929
are actors and other parts basically the

00:21:50,499 --> 00:21:57,159
entire microservice is implemented

00:21:52,929 --> 00:22:02,950
mostly of actors and one thing that I

00:21:57,159 --> 00:22:06,879
want to emphasize with developing

00:22:02,950 --> 00:22:09,700
microservices as bounded context is not

00:22:06,879 --> 00:22:11,489
to do this don't put your brain on acid

00:22:09,700 --> 00:22:13,419
when you need to integrate with another

00:22:11,489 --> 00:22:15,049
microservice and this is what I mean

00:22:13,419 --> 00:22:18,529
when you have

00:22:15,049 --> 00:22:20,419
an incoming request into one micro

00:22:18,529 --> 00:22:23,149
service this would be in the upper

00:22:20,419 --> 00:22:26,029
left-hand corner this micro service so

00:22:23,149 --> 00:22:30,110
an entity received some stimulus as a

00:22:26,029 --> 00:22:35,230
command and the command causes some

00:22:30,110 --> 00:22:37,759
state mutation or update in your service

00:22:35,230 --> 00:22:41,659
now you need to make another

00:22:37,759 --> 00:22:45,499
microservice consistent with that how do

00:22:41,659 --> 00:22:49,389
you do it do you emit a command from

00:22:45,499 --> 00:22:52,330
your micro service in order to balance

00:22:49,389 --> 00:22:55,009
the entity in the lower right-hand

00:22:52,330 --> 00:22:58,999
microservice that would be the wrong

00:22:55,009 --> 00:23:02,049
choice because if there is ever failure

00:22:58,999 --> 00:23:04,879
you will have inconsistent models

00:23:02,049 --> 00:23:08,059
between your micro services or bounded

00:23:04,879 --> 00:23:10,369
contacts now I already saw some of you

00:23:08,059 --> 00:23:14,359
shaking your head obviously no don't do

00:23:10,369 --> 00:23:16,970
that but what I find when I walk in to

00:23:14,359 --> 00:23:21,289
consult with companies is that this is

00:23:16,970 --> 00:23:24,950
done all the time actually and because

00:23:21,289 --> 00:23:31,039
of this organizations hire entire teams

00:23:24,950 --> 00:23:33,169
of developers just to patch data every

00:23:31,039 --> 00:23:36,679
day because of intermittent failures

00:23:33,169 --> 00:23:39,980
between services and they're also trying

00:23:36,679 --> 00:23:42,019
to find where did the leak happen why

00:23:39,980 --> 00:23:44,059
did something fail and they're trying to

00:23:42,019 --> 00:23:48,369
patch the code every day while the

00:23:44,059 --> 00:23:51,619
mainstream developers who actually are

00:23:48,369 --> 00:23:53,739
working on feet new features of the

00:23:51,619 --> 00:23:57,679
product that's actually a different team

00:23:53,739 --> 00:24:00,379
so that's a sad situation to be in but

00:23:57,679 --> 00:24:03,859
very commonly you'll find this at the

00:24:00,379 --> 00:24:06,289
root of problems like that so this is

00:24:03,859 --> 00:24:09,289
actually something that I agree with

00:24:06,289 --> 00:24:12,559
that Fred George says ok Fred George

00:24:09,289 --> 00:24:16,129
says that you should have Rapids rivers

00:24:12,559 --> 00:24:21,859
and ponds among your micro services and

00:24:16,129 --> 00:24:25,519
actually the rapids are where you

00:24:21,859 --> 00:24:28,730
publish all events so you actually have

00:24:25,519 --> 00:24:31,690
a place where all of your domain

00:24:28,730 --> 00:24:35,840
events from all your microservices go

00:24:31,690 --> 00:24:39,679
into an essence a high-performance bus

00:24:35,840 --> 00:24:43,429
so for example the micro service in the

00:24:39,679 --> 00:24:46,940
upper left-hand corner produces a domain

00:24:43,429 --> 00:24:49,309
event the domain event is part of the

00:24:46,940 --> 00:24:52,220
ubiquitous language of that bounded

00:24:49,309 --> 00:24:56,570
context that micro service that domain

00:24:52,220 --> 00:24:58,419
event is then fed to a topics let's call

00:24:56,570 --> 00:25:01,750
it all for the sake of illustration

00:24:58,419 --> 00:25:05,330
there's a topic out there called all and

00:25:01,750 --> 00:25:07,880
this all topic is collecting all domain

00:25:05,330 --> 00:25:11,150
events from all micro services and then

00:25:07,880 --> 00:25:13,970
it's up to each microservice to

00:25:11,150 --> 00:25:17,480
determine is this a domain event that

00:25:13,970 --> 00:25:20,179
I'm interested in is it something that I

00:25:17,480 --> 00:25:24,500
care about is it a fact that I need to

00:25:20,179 --> 00:25:27,500
react to if it does then it can react to

00:25:24,500 --> 00:25:30,500
those domain events and this requires

00:25:27,500 --> 00:25:32,990
that your topic of all be on a

00:25:30,500 --> 00:25:36,590
high-performance bus this could actually

00:25:32,990 --> 00:25:39,980
be done through a restful kind of

00:25:36,590 --> 00:25:43,610
interface where topic is taking in new

00:25:39,980 --> 00:25:47,030
domain events building them up into atom

00:25:43,610 --> 00:25:50,919
feeds or event logs notification logs

00:25:47,030 --> 00:25:55,070
that are then distributed whenever a

00:25:50,919 --> 00:25:59,809
consumer pings the domains or the topic

00:25:55,070 --> 00:26:02,720
service and says i need the the current

00:25:59,809 --> 00:26:04,669
state of the event logs it could be

00:26:02,720 --> 00:26:07,990
through kafka very high-performance

00:26:04,669 --> 00:26:11,750
message bus it could be through RabbitMQ

00:26:07,990 --> 00:26:14,240
it's really not my desire to tell you

00:26:11,750 --> 00:26:17,929
what you should use for this

00:26:14,240 --> 00:26:20,450
high-performance topics message bus but

00:26:17,929 --> 00:26:24,169
in essence you could use a variety of

00:26:20,450 --> 00:26:28,960
different tools to accomplish that the

00:26:24,169 --> 00:26:31,549
rivers are basically where each

00:26:28,960 --> 00:26:34,490
microservice determines I'm going to

00:26:31,549 --> 00:26:36,799
pull this information off of the rapids

00:26:34,490 --> 00:26:39,080
I'm going to divert it into my micro

00:26:36,799 --> 00:26:39,760
service river and I'm going to consume

00:26:39,080 --> 00:26:42,700
it there

00:26:39,760 --> 00:26:46,090
and typically what happens when you

00:26:42,700 --> 00:26:48,970
consume a domain event in an interested

00:26:46,090 --> 00:26:51,880
party microservice so I am now consuming

00:26:48,970 --> 00:26:53,790
a domain event that occurred either in

00:26:51,880 --> 00:26:57,280
my micro service or in another

00:26:53,790 --> 00:27:01,090
microservice I'm going to turn that

00:26:57,280 --> 00:27:03,700
domain event into a command because

00:27:01,090 --> 00:27:07,390
there's a difference between a command

00:27:03,700 --> 00:27:10,180
and a domain event again a domain event

00:27:07,390 --> 00:27:13,180
is a fact that cannot be denied you

00:27:10,180 --> 00:27:15,460
can't deny that a domain event has

00:27:13,180 --> 00:27:18,610
occurred that there was some stimulus

00:27:15,460 --> 00:27:21,760
that occurred in some micro service or

00:27:18,610 --> 00:27:24,250
bounded context and this happened and so

00:27:21,760 --> 00:27:26,800
we have a fact about that whether or not

00:27:24,250 --> 00:27:29,770
you will actually react to that fact is

00:27:26,800 --> 00:27:31,900
a determination within your micro

00:27:29,770 --> 00:27:33,970
service and therefore you create a

00:27:31,900 --> 00:27:36,070
command that corresponds to the event

00:27:33,970 --> 00:27:38,230
that happened and you have the

00:27:36,070 --> 00:27:42,310
opportunity to reject the command if

00:27:38,230 --> 00:27:46,360
that command is inappropriate at that

00:27:42,310 --> 00:27:48,880
point in time and one simple example of

00:27:46,360 --> 00:27:51,760
rejecting a command is if you have

00:27:48,880 --> 00:27:54,010
already processed in essence that domain

00:27:51,760 --> 00:27:55,810
event before and you have an item

00:27:54,010 --> 00:27:57,970
potency check that says I'm going to

00:27:55,810 --> 00:28:00,730
reject this command because i actually

00:27:57,970 --> 00:28:04,900
have already seen it so that's just one

00:28:00,730 --> 00:28:09,280
example so in essence what we have is

00:28:04,900 --> 00:28:11,830
the topics is feeding events to of

00:28:09,280 --> 00:28:16,120
interested party microservice and the

00:28:11,830 --> 00:28:18,970
event is turned into a command which is

00:28:16,120 --> 00:28:22,600
then produced on the entity so our

00:28:18,970 --> 00:28:27,700
entities are always producing or always

00:28:22,600 --> 00:28:31,540
reacting to commands the ponds I believe

00:28:27,700 --> 00:28:34,360
are analogous to the aggregate actors

00:28:31,540 --> 00:28:38,380
themselves the the entities if you will

00:28:34,360 --> 00:28:40,840
the states within your micro services so

00:28:38,380 --> 00:28:43,620
we have an incoming command this command

00:28:40,840 --> 00:28:47,320
could be produced by a user that is

00:28:43,620 --> 00:28:49,930
submitting an action request which is

00:28:47,320 --> 00:28:52,750
interpreted as a command it's given to

00:28:49,930 --> 00:28:55,180
an entity the entity produces an event

00:28:52,750 --> 00:29:00,340
event ends up in the event log or event

00:28:55,180 --> 00:29:04,000
journal and so actors amid events to the

00:29:00,340 --> 00:29:06,610
rapids so this same entity that has just

00:29:04,000 --> 00:29:08,560
received a command emits an event saved

00:29:06,610 --> 00:29:11,350
to its event journal the event journal

00:29:08,560 --> 00:29:19,420
is then read and the event is put on to

00:29:11,350 --> 00:29:21,310
and all topics central bus I just want

00:29:19,420 --> 00:29:24,460
to make one comment about channel

00:29:21,310 --> 00:29:29,590
services that channel services may in

00:29:24,460 --> 00:29:32,470
fact be smaller they're ubiquitous

00:29:29,590 --> 00:29:33,820
language maybe a bit smaller and this is

00:29:32,470 --> 00:29:36,040
what I mean let's say that we have a

00:29:33,820 --> 00:29:39,870
bound of context or micro service that

00:29:36,040 --> 00:29:43,390
we imagine should have offers detector

00:29:39,870 --> 00:29:45,520
resort offers resort reservation resort

00:29:43,390 --> 00:29:50,980
reservation process which is a process

00:29:45,520 --> 00:29:54,730
manager and a member query service do

00:29:50,980 --> 00:29:58,000
those actually have cohesion in a

00:29:54,730 --> 00:29:59,950
ubiquitous language possibly not we

00:29:58,000 --> 00:30:03,040
might actually want to model those as

00:29:59,950 --> 00:30:05,380
separate services where are you bikila

00:30:03,040 --> 00:30:07,840
slanguage is really quite small and this

00:30:05,380 --> 00:30:10,780
is where a micro service then would be

00:30:07,840 --> 00:30:13,330
quite small because you probably want

00:30:10,780 --> 00:30:15,550
different services dealing with the

00:30:13,330 --> 00:30:18,160
reservations and a different service

00:30:15,550 --> 00:30:21,400
dealing with the actual detection that

00:30:18,160 --> 00:30:29,440
some user qualifies for a special offer

00:30:21,400 --> 00:30:32,530
for example so reactive what is reactive

00:30:29,440 --> 00:30:36,370
reactive is responsive resilient elastic

00:30:32,530 --> 00:30:40,300
and message driven and when I say

00:30:36,370 --> 00:30:45,060
responsive I see commonly within the

00:30:40,300 --> 00:30:45,060
architecture that I am discussing here

00:30:45,390 --> 00:30:53,970
you know time benchmark times of an

00:30:48,850 --> 00:30:58,450
incoming rest request going through the

00:30:53,970 --> 00:31:01,000
command the modification the state and

00:30:58,450 --> 00:31:05,260
modification of the aggregate actor or

00:31:01,000 --> 00:31:06,380
entity and the production of a domain

00:31:05,260 --> 00:31:10,550
event

00:31:06,380 --> 00:31:14,030
and then a reply response to that of

00:31:10,550 --> 00:31:15,920
somewhere between 12 and 20 milliseconds

00:31:14,030 --> 00:31:20,600
I'll allow you to judge if that's

00:31:15,920 --> 00:31:23,030
responsive i think it is resilient the

00:31:20,600 --> 00:31:25,700
thing about using actors everywhere is

00:31:23,030 --> 00:31:29,200
not only that they are responsive and

00:31:25,700 --> 00:31:31,550
asynchronous and message driven but

00:31:29,200 --> 00:31:35,150
resiliency is something that has

00:31:31,550 --> 00:31:39,220
afforded actors by nature because it is

00:31:35,150 --> 00:31:42,800
the parent of a created actor that

00:31:39,220 --> 00:31:47,540
intercepts some sort of crash which in

00:31:42,800 --> 00:31:50,690
essence is an exception so if an

00:31:47,540 --> 00:31:52,940
exception occurs in a child actor it's

00:31:50,690 --> 00:31:59,030
not every client that needs to

00:31:52,940 --> 00:32:02,660
understand how that exception should be

00:31:59,030 --> 00:32:04,910
dealt with instead it's the parent that

00:32:02,660 --> 00:32:08,360
leads the client to only be concerned

00:32:04,910 --> 00:32:11,360
with does the actor that I made a

00:32:08,360 --> 00:32:14,390
request of respond to me in a certain

00:32:11,360 --> 00:32:17,180
period of time or doesn't it and if it

00:32:14,390 --> 00:32:19,550
doesn't I can simply retry the request

00:32:17,180 --> 00:32:22,610
and that's all that I need to know is

00:32:19,550 --> 00:32:26,570
either it has responded to my request or

00:32:22,610 --> 00:32:30,250
it hasn't and then I can retry whereas

00:32:26,570 --> 00:32:33,740
the parent is a specialty component that

00:32:30,250 --> 00:32:36,500
understands every way that an actor

00:32:33,740 --> 00:32:40,790
might crash and is in perfect condition

00:32:36,500 --> 00:32:43,610
or a position to also understand how

00:32:40,790 --> 00:32:45,890
that actor should be recovered elastic

00:32:43,610 --> 00:32:49,280
I'm not going to say much about this but

00:32:45,890 --> 00:32:53,380
you can read about great examples with

00:32:49,280 --> 00:32:56,750
acha where there's a 2400 node cluster

00:32:53,380 --> 00:33:00,290
that was deployed on Google compute

00:32:56,750 --> 00:33:03,260
engine and the good thing about a 2400

00:33:00,290 --> 00:33:05,600
node cluster is it only needs to be 2400

00:33:03,260 --> 00:33:09,200
nodes if it needs to be 2400 nodes and

00:33:05,600 --> 00:33:12,260
if it only needs to be 500 nodes at this

00:33:09,200 --> 00:33:14,510
point in time then it can only be 500

00:33:12,260 --> 00:33:17,720
nodes that's what I'm talking about with

00:33:14,510 --> 00:33:20,029
elastic and of course actors our message

00:33:17,720 --> 00:33:23,599
driven their message driven through both

00:33:20,029 --> 00:33:27,019
the commands messages in coming and the

00:33:23,599 --> 00:33:29,179
messages that are our event messages

00:33:27,019 --> 00:33:32,679
which end up going through the rapids

00:33:29,179 --> 00:33:35,539
process by other actors and other

00:33:32,679 --> 00:33:37,549
contexts so what I wanted to do and

00:33:35,539 --> 00:33:40,549
hopefully hopefully I've succeeded is

00:33:37,549 --> 00:33:43,159
leave about 10 minutes to walk you

00:33:40,549 --> 00:33:46,580
through how to implement microservices

00:33:43,159 --> 00:33:49,219
with scala and akka so this is the

00:33:46,580 --> 00:33:54,289
distributed use case that we're going to

00:33:49,219 --> 00:33:56,359
walk through encode we have the agile

00:33:54,289 --> 00:33:59,049
project management context or micro

00:33:56,359 --> 00:34:03,049
service in the upper left-hand corner a

00:33:59,049 --> 00:34:08,690
create product command comes in as a

00:34:03,049 --> 00:34:11,929
stimulus to this micro service and we're

00:34:08,690 --> 00:34:15,409
going to create a new product based on

00:34:11,929 --> 00:34:19,279
this stimulus the product is actually

00:34:15,409 --> 00:34:21,289
going to produce to domain events it's

00:34:19,279 --> 00:34:23,990
going to produce a product created

00:34:21,289 --> 00:34:29,049
domain event it is a fact the product

00:34:23,990 --> 00:34:33,109
was created but also if the product

00:34:29,049 --> 00:34:36,799
command create product command has in it

00:34:33,109 --> 00:34:39,440
a request to create a corresponding

00:34:36,799 --> 00:34:42,020
forum and discussion so that the team

00:34:39,440 --> 00:34:46,220
that's using this scrum product can have

00:34:42,020 --> 00:34:49,429
forum discussions about the product then

00:34:46,220 --> 00:34:53,599
we're also going to emit a discussion

00:34:49,429 --> 00:34:56,329
requested domain event that domain event

00:34:53,599 --> 00:34:59,930
discussion requested is going to be

00:34:56,329 --> 00:35:03,650
acknowledged as interest as of interest

00:34:59,930 --> 00:35:05,960
to the collaboration context and that

00:35:03,650 --> 00:35:09,020
collaboration context when it sees that

00:35:05,960 --> 00:35:11,630
domain event will create a command that

00:35:09,020 --> 00:35:14,180
will cause the forum and discussion to

00:35:11,630 --> 00:35:16,700
be created in the other micro service or

00:35:14,180 --> 00:35:20,329
the other bounded context it will then

00:35:16,700 --> 00:35:22,970
emit a discussion started domain event

00:35:20,329 --> 00:35:26,240
which will go back into the topics and

00:35:22,970 --> 00:35:28,880
that is of interest to the agile project

00:35:26,240 --> 00:35:30,770
management microservice and as you can

00:35:28,880 --> 00:35:33,740
see as the fifth step the discussion

00:35:30,770 --> 00:35:36,700
started is going back in

00:35:33,740 --> 00:35:41,810
to that micro service and that allows

00:35:36,700 --> 00:35:44,690
that micro service to harmonize the fact

00:35:41,810 --> 00:35:47,720
that we now have a product with a

00:35:44,690 --> 00:35:50,840
discussion that was created for it in

00:35:47,720 --> 00:35:55,070
another microservice okay so let's look

00:35:50,840 --> 00:35:57,830
first of all at the code example for

00:35:55,070 --> 00:36:00,260
starting a service every micro service

00:35:57,830 --> 00:36:04,070
should have a way to bootstrap the

00:36:00,260 --> 00:36:08,210
service or boot the service so this is

00:36:04,070 --> 00:36:14,600
actually using play the play framework

00:36:08,210 --> 00:36:19,010
and this is using injection and this

00:36:14,600 --> 00:36:21,500
specific example is an eager singleton

00:36:19,010 --> 00:36:24,440
which allows us to bootstrap when the

00:36:21,500 --> 00:36:27,920
service is is actually being started and

00:36:24,440 --> 00:36:31,130
we take care of some common housekeeping

00:36:27,920 --> 00:36:33,920
things like we're going to attach to

00:36:31,130 --> 00:36:37,100
some other services like our quote feeds

00:36:33,920 --> 00:36:39,140
and so forth i won't i won't bore you

00:36:37,100 --> 00:36:43,640
with this but basically there's a

00:36:39,140 --> 00:36:46,700
heartbeat that every few seconds we're

00:36:43,640 --> 00:36:52,180
going to broadcast our micro service

00:36:46,700 --> 00:36:54,560
interface our restful interface out to a

00:36:52,180 --> 00:36:58,430
service registry and that service

00:36:54,560 --> 00:37:00,590
registry will then be capable of telling

00:36:58,430 --> 00:37:03,080
other micro services when they inquire

00:37:00,590 --> 00:37:07,220
where does this microservice live what

00:37:03,080 --> 00:37:09,710
router is it behind or or whatever the

00:37:07,220 --> 00:37:13,940
the next step though of interest to us

00:37:09,710 --> 00:37:17,119
is where the product command comes in so

00:37:13,940 --> 00:37:20,030
this is a play controller now you could

00:37:17,119 --> 00:37:23,930
use acha HTTP for this but I've chosen

00:37:20,030 --> 00:37:29,750
to use play framework and we simply have

00:37:23,930 --> 00:37:32,630
a mapping of an incoming URI with the

00:37:29,750 --> 00:37:37,220
request a post request to create a new

00:37:32,630 --> 00:37:40,460
product the product the create product

00:37:37,220 --> 00:37:45,720
method is invoked by play and we read

00:37:40,460 --> 00:37:51,660
some JSON off of the incoming request

00:37:45,720 --> 00:37:55,050
and then we create a new product with a

00:37:51,660 --> 00:37:59,460
unique ID as an actor and then we

00:37:55,050 --> 00:38:05,060
dispatch this command create product to

00:37:59,460 --> 00:38:12,000
the product actor alright oh is it not I

00:38:05,060 --> 00:38:16,760
was hoping that would be big enough let

00:38:12,000 --> 00:38:16,760
me see oh sorry

00:38:31,740 --> 00:38:42,530
okay text get it let's see let's hope

00:38:49,700 --> 00:38:59,580
does that work I hope and I will

00:38:56,150 --> 00:39:02,400
maximize the tabs okay so we've got this

00:38:59,580 --> 00:39:07,170
controller and this controller is going

00:39:02,400 --> 00:39:09,780
to create a new actor and this actor has

00:39:07,170 --> 00:39:11,850
a unique identity we're then going to

00:39:09,780 --> 00:39:17,160
send a command to that actor a command

00:39:11,850 --> 00:39:19,740
message saying create product we then

00:39:17,160 --> 00:39:22,950
get a future because we're actually

00:39:19,740 --> 00:39:27,840
using the ask pattern we get a future

00:39:22,950 --> 00:39:31,800
and the future is mapped to a create

00:39:27,840 --> 00:39:35,940
product result and the result will in

00:39:31,800 --> 00:39:40,470
essence create a JSON response that puts

00:39:35,940 --> 00:39:42,510
a location header so it's using restful

00:39:40,470 --> 00:39:45,120
approach which is the product location

00:39:42,510 --> 00:39:47,370
and the product location is provided by

00:39:45,120 --> 00:39:49,820
the result it's a unique identity and

00:39:47,370 --> 00:39:53,700
you'll see this functioning in a moment

00:39:49,820 --> 00:39:56,160
okay back to the slides per second so

00:39:53,700 --> 00:39:59,970
that's our service endpoint also what we

00:39:56,160 --> 00:40:02,790
have possibly behind the controller is a

00:39:59,970 --> 00:40:06,360
process manager that is if there is a

00:40:02,790 --> 00:40:09,480
multi-step process involved in handling

00:40:06,360 --> 00:40:13,890
a single command and what I will show

00:40:09,480 --> 00:40:16,500
you next is in the collaboration context

00:40:13,890 --> 00:40:19,110
we have this situation because what

00:40:16,500 --> 00:40:23,190
we're going to do is actually create a

00:40:19,110 --> 00:40:26,550
forum entity and a discussion entity so

00:40:23,190 --> 00:40:30,450
it's a two-step process and so what we

00:40:26,550 --> 00:40:34,740
do is we have a forum discussion starter

00:40:30,450 --> 00:40:37,170
actor that is a process manager this

00:40:34,740 --> 00:40:39,890
process manager begins its process by

00:40:37,170 --> 00:40:45,450
taking in a start forum discussion

00:40:39,890 --> 00:40:48,570
command and then it creates a command or

00:40:45,450 --> 00:40:54,480
I mean I'm sorry a form using the start

00:40:48,570 --> 00:40:57,840
forum command and then it uses become so

00:40:54,480 --> 00:40:59,069
the actors contexts become to become a

00:40:57,840 --> 00:41:02,069
listener

00:40:59,069 --> 00:41:04,890
or that specific forum started event

00:41:02,069 --> 00:41:08,039
that's going to be emitted from the

00:41:04,890 --> 00:41:11,789
start forum command the request for that

00:41:08,039 --> 00:41:14,630
command when that forum started event is

00:41:11,789 --> 00:41:17,609
received by the process manager then

00:41:14,630 --> 00:41:22,229
it's going to create a new discussion

00:41:17,609 --> 00:41:25,140
actor entity and tell that discussion to

00:41:22,229 --> 00:41:28,049
start a discussion then we're going to

00:41:25,140 --> 00:41:32,160
become a discussion started listener

00:41:28,049 --> 00:41:34,440
which is this one this receive block and

00:41:32,160 --> 00:41:37,049
when this receive block receives a

00:41:34,440 --> 00:41:39,900
discussion started domain event then we

00:41:37,049 --> 00:41:42,390
can tell our original sender that this

00:41:39,900 --> 00:41:44,819
entire process has completed that the

00:41:42,390 --> 00:41:48,420
start forum discussion result is the

00:41:44,819 --> 00:41:50,579
outcome alright so that's how you can do

00:41:48,420 --> 00:41:53,579
at least a process manager within a

00:41:50,579 --> 00:41:55,589
single microservice there is also the

00:41:53,579 --> 00:41:58,049
chance that you need a process manager

00:41:55,589 --> 00:42:02,339
that spans microservices that's another

00:41:58,049 --> 00:42:06,890
topic also we have aggregate actors in

00:42:02,339 --> 00:42:09,809
this case we have our product which is a

00:42:06,890 --> 00:42:13,769
persistent actor so this is using acha

00:42:09,809 --> 00:42:17,699
persistence and this persistent actor

00:42:13,769 --> 00:42:22,709
takes as a command so in its receive

00:42:17,699 --> 00:42:26,039
command block receives a create product

00:42:22,709 --> 00:42:28,650
command and it's going to emit possibly

00:42:26,039 --> 00:42:31,680
two events it's definitely going to omit

00:42:28,650 --> 00:42:33,239
this product created event and we're

00:42:31,680 --> 00:42:36,930
going to create a sequence of events

00:42:33,239 --> 00:42:40,499
because if the command says that we are

00:42:36,930 --> 00:42:46,339
requesting a discussion to be created in

00:42:40,499 --> 00:42:49,410
it in order to partner with that product

00:42:46,339 --> 00:42:54,719
then we're also going to emit a

00:42:49,410 --> 00:42:58,170
discussion requested event and then

00:42:54,719 --> 00:43:05,339
we're going to persist those two domain

00:42:58,170 --> 00:43:09,359
events and as an outcome we're going to

00:43:05,339 --> 00:43:12,660
update our state based on a product

00:43:09,359 --> 00:43:14,069
created and a discussion requested

00:43:12,660 --> 00:43:17,280
and then we're going to reply to our

00:43:14,069 --> 00:43:20,450
sender which in this case is the

00:43:17,280 --> 00:43:23,690
controller the create product result

00:43:20,450 --> 00:43:28,819
okay so all of this is happening

00:43:23,690 --> 00:43:32,640
asynchronously and the because the the

00:43:28,819 --> 00:43:35,940
controller is working with a future it

00:43:32,640 --> 00:43:40,589
is not blocking but it's actually just

00:43:35,940 --> 00:43:43,500
ready to receive this this message when

00:43:40,589 --> 00:43:46,410
it returns to it okay so that's

00:43:43,500 --> 00:43:48,390
basically how to implement or at least

00:43:46,410 --> 00:43:51,390
the very high level how to implement an

00:43:48,390 --> 00:43:54,780
actor aggregate and now we're going to

00:43:51,390 --> 00:44:00,119
look at how we implement see QRS in a

00:43:54,780 --> 00:44:04,640
view so actually what we have is a timer

00:44:00,119 --> 00:44:08,609
a scheduled timer event or message

00:44:04,640 --> 00:44:11,430
products views projection tick and this

00:44:08,609 --> 00:44:14,730
for the sake of teaching only occurs

00:44:11,430 --> 00:44:17,010
every two seconds it could be much more

00:44:14,730 --> 00:44:18,900
granular than that in an actual

00:44:17,010 --> 00:44:21,119
production environment but basically

00:44:18,900 --> 00:44:25,190
every two seconds what we're going to do

00:44:21,119 --> 00:44:28,230
is use acha streams through the aqha

00:44:25,190 --> 00:44:31,079
persistence query library and we're

00:44:28,230 --> 00:44:34,670
going to get a materializer and read the

00:44:31,079 --> 00:44:37,770
new domain events that have occurred

00:44:34,670 --> 00:44:39,900
within our own journal within our micro

00:44:37,770 --> 00:44:42,450
service and then what we're going to do

00:44:39,900 --> 00:44:44,760
is project each of those new domain

00:44:42,450 --> 00:44:48,059
events if they're applicable to this

00:44:44,760 --> 00:44:50,549
particular products view and we're going

00:44:48,059 --> 00:44:52,980
to project those domain events into the

00:44:50,549 --> 00:44:56,240
shape and structure of data that we need

00:44:52,980 --> 00:45:00,240
for the user who may be interested in

00:44:56,240 --> 00:45:03,569
what this product looks like in terms of

00:45:00,240 --> 00:45:07,109
its view and you're going to see how

00:45:03,569 --> 00:45:11,309
that works in a moment and then we have

00:45:07,109 --> 00:45:16,559
the notion of a topics feeder so similar

00:45:11,309 --> 00:45:21,900
to the products view the feeder is on a

00:45:16,559 --> 00:45:23,880
recurring basis and in this case again

00:45:21,900 --> 00:45:25,720
we're operating at every two seconds

00:45:23,880 --> 00:45:28,840
again this is not the kind

00:45:25,720 --> 00:45:30,880
of timer granularity that you would use

00:45:28,840 --> 00:45:33,070
in production but it allows the human

00:45:30,880 --> 00:45:37,900
eye to detect when things happen when

00:45:33,070 --> 00:45:41,170
I'm running this demo but we also have

00:45:37,900 --> 00:45:44,140
used the aqha persistence query to read

00:45:41,170 --> 00:45:49,210
the events out and then what we're going

00:45:44,140 --> 00:45:51,400
to do is go to that central bus and feed

00:45:49,210 --> 00:45:58,810
all new domain events to that central

00:45:51,400 --> 00:46:01,200
bus and then we have a topics reader so

00:45:58,810 --> 00:46:07,119
every microservice has a topics reader

00:46:01,200 --> 00:46:11,200
again that on intervals is reading from

00:46:07,119 --> 00:46:13,180
the topics the all topics any do new

00:46:11,200 --> 00:46:16,960
domain events that it hasn't seen yet

00:46:13,180 --> 00:46:21,359
and it's going to dispatch those to a

00:46:16,960 --> 00:46:27,310
registered topics reader consumer and

00:46:21,359 --> 00:46:30,130
that consumer will do a case match on

00:46:27,310 --> 00:46:31,660
whatever new domain event were

00:46:30,130 --> 00:46:34,270
interested in this case we're in the

00:46:31,660 --> 00:46:36,730
agile project management context or

00:46:34,270 --> 00:46:41,010
micro service and we're interested in

00:46:36,730 --> 00:46:43,839
the discussion started domain event and

00:46:41,010 --> 00:46:46,380
this will allow us to reconcile the

00:46:43,839 --> 00:46:48,880
product with the domain with the

00:46:46,380 --> 00:46:51,369
discussion and forum that's just been

00:46:48,880 --> 00:46:56,550
created for it so what I want to do now

00:46:51,369 --> 00:46:56,550
is go over here to our

00:47:01,850 --> 00:47:08,670
to a demo and what i have here i have

00:47:06,360 --> 00:47:10,800
the service registry running so all

00:47:08,670 --> 00:47:13,470
microservices register with the service

00:47:10,800 --> 00:47:15,270
registry i have the central topics

00:47:13,470 --> 00:47:17,840
service these are just too technical

00:47:15,270 --> 00:47:19,970
services then i have the actual business

00:47:17,840 --> 00:47:22,080
microservice of the collaboration

00:47:19,970 --> 00:47:24,660
context and i have a business

00:47:22,080 --> 00:47:28,710
microservice of the agile project

00:47:24,660 --> 00:47:33,540
management context and what i want to do

00:47:28,710 --> 00:47:37,050
is just use a curl command i'm going to

00:47:33,540 --> 00:47:39,180
run curl which i guess you're not seeing

00:47:37,050 --> 00:47:41,730
too well and I'm not going to try to

00:47:39,180 --> 00:47:43,590
teach myself how to zoom this right now

00:47:41,730 --> 00:47:45,210
but trust me you're welcome to come up

00:47:43,590 --> 00:47:47,820
and see this afterwards there's plenty

00:47:45,210 --> 00:47:50,220
of time but this is a curl command that

00:47:47,820 --> 00:47:52,160
is requesting a new product to be

00:47:50,220 --> 00:47:56,910
created in the agile project management

00:47:52,160 --> 00:48:00,120
context again just to remind you this is

00:47:56,910 --> 00:48:02,910
what we're looking for in the use case

00:48:00,120 --> 00:48:05,460
when I execute that command it's going

00:48:02,910 --> 00:48:07,560
to cause to domain events one of those

00:48:05,460 --> 00:48:10,230
domain events is going to flow over to

00:48:07,560 --> 00:48:12,150
the collaboration context it's going to

00:48:10,230 --> 00:48:15,000
create a forum a discussion through that

00:48:12,150 --> 00:48:16,740
process manager that discussion started

00:48:15,000 --> 00:48:20,460
domain event will flow back to the

00:48:16,740 --> 00:48:22,980
topics the topics will then feed it to

00:48:20,460 --> 00:48:25,110
the interested party which is the agile

00:48:22,980 --> 00:48:28,970
project management context so let's run

00:48:25,110 --> 00:48:36,660
that and what you can see here is that a

00:48:28,970 --> 00:48:38,730
discussion a I apologize for this I did

00:48:36,660 --> 00:48:41,250
I didn't think about the zooming on on

00:48:38,730 --> 00:48:44,340
this from the beginning but basically

00:48:41,250 --> 00:48:47,310
what we have is a domain event that says

00:48:44,340 --> 00:48:51,860
that a product was created and that a

00:48:47,310 --> 00:48:58,290
discussion was requested all right in

00:48:51,860 --> 00:49:03,590
the collaboration context we see the

00:48:58,290 --> 00:49:06,990
incoming the reader has just read that a

00:49:03,590 --> 00:49:09,270
product was created and that a

00:49:06,990 --> 00:49:11,370
discussion was requested in the case of

00:49:09,270 --> 00:49:13,980
the collaboration context it doesn't

00:49:11,370 --> 00:49:14,789
care about product created it still sees

00:49:13,980 --> 00:49:16,769
it but

00:49:14,789 --> 00:49:20,039
doesn't care about it so it filters it

00:49:16,769 --> 00:49:23,640
out but it is interested in this fact

00:49:20,039 --> 00:49:25,979
that a discussion was requested a form

00:49:23,640 --> 00:49:29,939
and discussion are created and then

00:49:25,979 --> 00:49:36,439
we're going to feed the outcoming or the

00:49:29,939 --> 00:49:39,660
emitted domain event forum started and

00:49:36,439 --> 00:49:44,569
discussion started this is being fed to

00:49:39,660 --> 00:49:47,660
the all topics and then finally in our

00:49:44,569 --> 00:49:57,959
agile project management context we have

00:49:47,660 --> 00:50:04,019
the incoming discussion started event

00:49:57,959 --> 00:50:08,910
and I know even I can't see this here it

00:50:04,019 --> 00:50:11,489
is here it is incoming discussion

00:50:08,910 --> 00:50:18,630
started so that kind of terminates the

00:50:11,489 --> 00:50:21,359
the long-running process or the the the

00:50:18,630 --> 00:50:24,569
full distributed use case is it time

00:50:21,359 --> 00:50:26,789
okay sorry about that all right any any

00:50:24,569 --> 00:50:29,339
questions I think actually we have time

00:50:26,789 --> 00:50:35,039
for questions because this is no this is

00:50:29,339 --> 00:50:36,719
not the last session it's the last

00:50:35,039 --> 00:50:41,630
session I think you should be able to

00:50:36,719 --> 00:50:41,630
ask questions it's not the last session

00:50:42,469 --> 00:50:47,819
well I'm a whole one minute overtime so

00:50:45,569 --> 00:50:50,959
sorry about that if if you would like oh

00:50:47,819 --> 00:50:50,959
I need to do the drawing

00:51:09,100 --> 00:51:15,550

YouTube URL: https://www.youtube.com/watch?v=eiKQxWxwSzs


