Title: Polymorphic Record Types in a Limited Embedding by Stefan Zeiger
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
Follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
This talk gives an overview of the "lifted embedding" at the core of the Scala DSL in Slick, Lightbend's relational database library. With standard Scala language features we can provide a DSL that allows you to work with database tables using a syntax similar to Scala collections. Of particular interest are abstractions for record types, such as tuples. While earlier versions of Slick had to get by with custom types for all tuple sizes to represent flat tuples of individual columns, the "Shape" abstraction paved the way for using standard Scala tuples in the DSL, with arbitrary nesting. The same abstraction is used to support Slick's own HList implementation, and with only a few lines of code, your own custom record types or other HList implementations. The core language feature behind this design is called "functional dependencies". It was added to Scala in release 2.8 to be able to implement the "CanBuildFrom" abstraction in the new collections framework.
Captions: 
	00:00:02,490 --> 00:00:07,170
welcome everyone the title of this talk

00:00:04,770 --> 00:00:08,820
is polymorphic record types and your

00:00:07,170 --> 00:00:11,730
lifted and bedding and I'm glad so many

00:00:08,820 --> 00:00:13,469
of you showed up despite this rather

00:00:11,730 --> 00:00:15,599
unwieldy title i briefly considered

00:00:13,469 --> 00:00:17,640
calling it putting the fun into

00:00:15,599 --> 00:00:22,320
functional dependencies maybe I could

00:00:17,640 --> 00:00:24,330
have felt a bigger room that way so by

00:00:22,320 --> 00:00:26,609
the way please Lou use this color is up

00:00:24,330 --> 00:00:30,740
to rate this if you like it also if you

00:00:26,609 --> 00:00:33,900
don't like it but that's not mandatory

00:00:30,740 --> 00:00:36,690
so uh if you don't know me my name is

00:00:33,900 --> 00:00:41,130
Jeff font Tyga I am the tech lead for

00:00:36,690 --> 00:00:44,190
slick and I now work mostly on the Scala

00:00:41,130 --> 00:00:46,590
compiler team so I'm giving a talk which

00:00:44,190 --> 00:00:48,870
is in the intersection of Scala and

00:00:46,590 --> 00:00:52,500
slick so we're really talking about a

00:00:48,870 --> 00:00:55,020
scholar feature but the topic of the

00:00:52,500 --> 00:00:58,350
talk is slick because we're using a part

00:00:55,020 --> 00:01:00,600
of slick to explain this feature how

00:00:58,350 --> 00:01:03,210
many of you have not used slick can you

00:01:00,600 --> 00:01:05,220
raise your hands oh wow that's actually

00:01:03,210 --> 00:01:07,229
a lot more than we in New York most of

00:01:05,220 --> 00:01:10,369
them had used it so I'll briefly recap

00:01:07,229 --> 00:01:12,719
so slick is a database framework for

00:01:10,369 --> 00:01:15,090
accessing relational databases from

00:01:12,719 --> 00:01:17,490
scholar so the idea is that you write

00:01:15,090 --> 00:01:19,530
your database query like a scholar

00:01:17,490 --> 00:01:23,009
collect like using scholar collections

00:01:19,530 --> 00:01:25,679
API like here we have this Val q4 query

00:01:23,009 --> 00:01:28,859
its users users table that filter some

00:01:25,679 --> 00:01:32,670
filter criteria dot map and we mapped to

00:01:28,859 --> 00:01:34,499
the first name of the user and the code

00:01:32,670 --> 00:01:36,479
looks the same as if you wrote it on a

00:01:34,499 --> 00:01:39,719
scholar collection and then you run this

00:01:36,479 --> 00:01:41,490
on the database you just say DB run give

00:01:39,719 --> 00:01:44,219
it your query and you get a result back

00:01:41,490 --> 00:01:45,569
and the whole thing is of course as we

00:01:44,219 --> 00:01:47,939
expect from a good scholar API

00:01:45,569 --> 00:01:50,490
statically typed so the result in this

00:01:47,939 --> 00:01:53,579
case is a future of vector of string

00:01:50,490 --> 00:01:55,799
because this first up here this is a

00:01:53,579 --> 00:01:57,979
string and yeah we're doing something

00:01:55,799 --> 00:02:03,090
collection valued so you get a vector

00:01:57,979 --> 00:02:05,159
okay so how is this implemented that's

00:02:03,090 --> 00:02:07,859
the basic idea here to follow this plan

00:02:05,159 --> 00:02:10,680
you write the query and slicks lifted

00:02:07,859 --> 00:02:12,270
embedding scholar dsl it used to be

00:02:10,680 --> 00:02:14,160
called lifted embedding if you go to the

00:02:12,270 --> 00:02:15,840
new documentation it's actually not

00:02:14,160 --> 00:02:16,410
called that anymore we just call it a

00:02:15,840 --> 00:02:19,020
scholar

00:02:16,410 --> 00:02:20,760
because it's the only one we have but we

00:02:19,020 --> 00:02:22,560
used to have another direct embedding

00:02:20,760 --> 00:02:24,570
and this one is the lifted embedding

00:02:22,560 --> 00:02:27,030
it's plain scholar code there's there's

00:02:24,570 --> 00:02:29,040
no macros in there no pre-processing or

00:02:27,030 --> 00:02:30,600
any other tricks well actually there

00:02:29,040 --> 00:02:32,850
there are macros but we're not going to

00:02:30,600 --> 00:02:35,130
use them and they can eliminate some

00:02:32,850 --> 00:02:37,280
additional boilerplate but it's not

00:02:35,130 --> 00:02:40,110
important for what we're doing here and

00:02:37,280 --> 00:02:44,010
this lifted embedding then builds a

00:02:40,110 --> 00:02:46,710
slick AST that reifies the computation

00:02:44,010 --> 00:02:48,120
so you can see exactly the original

00:02:46,710 --> 00:02:51,120
computation that you wrote in your

00:02:48,120 --> 00:02:54,030
scholar code in an AST that we compute

00:02:51,120 --> 00:02:57,360
from this lifted embedding at runtime

00:02:54,030 --> 00:03:00,480
and then the other boring part we

00:02:57,360 --> 00:03:03,720
compile this ast2 sequel coat with a

00:03:00,480 --> 00:03:07,170
large compiler of 20 stages or so and we

00:03:03,720 --> 00:03:09,690
executed on a database via JDBC and it's

00:03:07,170 --> 00:03:11,850
all done in mostly asynchronous way so

00:03:09,690 --> 00:03:13,950
you get it back as a future or reactive

00:03:11,850 --> 00:03:16,620
stream we don't care about all this

00:03:13,950 --> 00:03:19,800
stuff at the bottom there today so if

00:03:16,620 --> 00:03:22,350
you want to find out more go to slick

00:03:19,800 --> 00:03:25,620
lightbank com that's our new website on

00:03:22,350 --> 00:03:29,840
the new light mint domain so what are we

00:03:25,620 --> 00:03:32,940
going to use today is depth toy slick

00:03:29,840 --> 00:03:35,340
and you can also see the link here this

00:03:32,940 --> 00:03:37,080
is directly to get up and if you look at

00:03:35,340 --> 00:03:39,660
the history I actually started with the

00:03:37,080 --> 00:03:41,220
current slick master branch and removed

00:03:39,660 --> 00:03:43,290
everything we don't need here and

00:03:41,220 --> 00:03:45,120
simplified it further so there's no

00:03:43,290 --> 00:03:48,630
query execution there's no query

00:03:45,120 --> 00:03:50,880
compilation there are simpler untyped a

00:03:48,630 --> 00:03:53,340
STS with only a few features there are

00:03:50,880 --> 00:03:56,340
no profiles for different databases just

00:03:53,340 --> 00:03:58,220
a few operations no option types in the

00:03:56,340 --> 00:04:01,020
lifted embedding that's a big

00:03:58,220 --> 00:04:03,000
complication usually there are no type

00:04:01,020 --> 00:04:04,830
constructors so we always you seek and

00:04:03,000 --> 00:04:06,840
give you a vector when you execute it

00:04:04,830 --> 00:04:09,239
and there are no shape levels in case

00:04:06,840 --> 00:04:10,920
you've seen this feature in slick like

00:04:09,239 --> 00:04:14,790
when it shows up in an error message or

00:04:10,920 --> 00:04:16,650
something all we do is a write code in

00:04:14,790 --> 00:04:21,600
the simplified lifted embedding and then

00:04:16,650 --> 00:04:23,610
transform that to a simplified AST so

00:04:21,600 --> 00:04:27,930
let's start with this AST the abstract

00:04:23,610 --> 00:04:29,940
syntax tree we have a base class or

00:04:27,930 --> 00:04:33,810
trade called note

00:04:29,940 --> 00:04:36,570
and then a few child nodes that we need

00:04:33,810 --> 00:04:38,790
for our toy slick AST so there's a

00:04:36,570 --> 00:04:41,490
literal node that contains any literal

00:04:38,790 --> 00:04:44,040
value like a constant and we have a

00:04:41,490 --> 00:04:46,770
product node that represents a tuple

00:04:44,040 --> 00:04:49,530
like a couple constructor so you can

00:04:46,770 --> 00:04:53,100
topple up multiple values and we have a

00:04:49,530 --> 00:04:56,160
table note representing a table and map

00:04:53,100 --> 00:04:59,070
and filter our operations ref refers to

00:04:56,160 --> 00:05:01,380
a variable select select the field

00:04:59,070 --> 00:05:04,680
inside something some other path and

00:05:01,380 --> 00:05:06,360
apply apply the function I'm going

00:05:04,680 --> 00:05:08,760
through this very quickly because we can

00:05:06,360 --> 00:05:12,350
see it in an example here this uses all

00:05:08,760 --> 00:05:15,810
of them except for the product note so

00:05:12,350 --> 00:05:19,320
that's a set the example from before so

00:05:15,810 --> 00:05:23,070
here we have users that's a table node

00:05:19,320 --> 00:05:25,520
so we see table users down here and then

00:05:23,070 --> 00:05:29,070
we do a filter operation on top so

00:05:25,520 --> 00:05:32,060
that's this one and the filter has a

00:05:29,070 --> 00:05:34,980
from clause that's of course users and

00:05:32,060 --> 00:05:37,740
in the in the where clause we have this

00:05:34,980 --> 00:05:42,120
computation here under Scott ID less

00:05:37,740 --> 00:05:45,990
than 42 so that's the way of class so

00:05:42,120 --> 00:05:50,040
under strode ID becomes select ID in ref

00:05:45,990 --> 00:05:53,669
s 1 whereas one is the name we've given

00:05:50,040 --> 00:05:56,820
to this lambda to the to the variable in

00:05:53,669 --> 00:06:00,120
the lambda and literal note 42 and the

00:05:56,820 --> 00:06:03,510
apply for the function call or for the

00:06:00,120 --> 00:06:07,470
operator and the same for maps on top of

00:06:03,510 --> 00:06:09,270
the filter we have a map and here we've

00:06:07,470 --> 00:06:12,510
written out the lambda so the you in

00:06:09,270 --> 00:06:15,180
this case that's the s2 gets a new

00:06:12,510 --> 00:06:19,560
simple name and then we have u dot first

00:06:15,180 --> 00:06:22,320
this becomes select first in rfs2 that's

00:06:19,560 --> 00:06:28,110
pretty much all we do for this toy slick

00:06:22,320 --> 00:06:30,240
example so let's talk about the lifted

00:06:28,110 --> 00:06:33,210
embedding first of all why is it called

00:06:30,240 --> 00:06:35,430
the lifted embedding well it's called an

00:06:33,210 --> 00:06:38,070
embedding because the query language is

00:06:35,430 --> 00:06:42,150
embedded in scala it's an internal dsl

00:06:38,070 --> 00:06:42,900
and it's called lifted embedding unlike

00:06:42,150 --> 00:06:46,169
say that

00:06:42,900 --> 00:06:48,690
reading because every type T is lifted

00:06:46,169 --> 00:06:52,530
into a type rep of T a reference lifted

00:06:48,690 --> 00:06:56,310
representation so when you think you

00:06:52,530 --> 00:06:57,960
have a value that's an int like say this

00:06:56,310 --> 00:07:00,479
thing here that you're comparing against

00:06:57,960 --> 00:07:03,720
42 this looks like an int but it's

00:07:00,479 --> 00:07:07,080
actually not it's really a rep event so

00:07:03,720 --> 00:07:09,750
that's the lifted embedding okay so

00:07:07,080 --> 00:07:11,850
let's see how this rep looks that's

00:07:09,750 --> 00:07:15,000
that's the class we use for everything

00:07:11,850 --> 00:07:17,880
every expression in our lifted embedding

00:07:15,000 --> 00:07:21,690
is of type rep of something at least

00:07:17,880 --> 00:07:24,120
initially so we have a trade rep of T as

00:07:21,690 --> 00:07:27,229
a super trade and it needs two basic

00:07:24,120 --> 00:07:30,600
operations one is called to note

00:07:27,229 --> 00:07:32,729
obviously because our only goal here is

00:07:30,600 --> 00:07:35,430
to build an AST so we give it a two node

00:07:32,729 --> 00:07:39,270
method which builds the AST for this

00:07:35,430 --> 00:07:42,990
specific rep value and another one we

00:07:39,270 --> 00:07:45,539
need is encode ref so every rep has an

00:07:42,990 --> 00:07:47,910
intrinsic AST that you get when you just

00:07:45,539 --> 00:07:51,199
call to note on it but you can also

00:07:47,910 --> 00:07:55,260
encode a different AST into the rep and

00:07:51,199 --> 00:07:58,229
the contract is that you can call encode

00:07:55,260 --> 00:08:01,169
ref with some AST we call it path here

00:07:58,229 --> 00:08:03,870
because it represents a path like a dot

00:08:01,169 --> 00:08:05,940
B dot Z and then when you call to node

00:08:03,870 --> 00:08:10,169
again you get exactly that path out of

00:08:05,940 --> 00:08:12,900
it and we use that in the map and filter

00:08:10,169 --> 00:08:16,979
functions that will will look into later

00:08:12,900 --> 00:08:19,860
and in most cases just having a simple

00:08:16,979 --> 00:08:22,409
rep of T is okay like for an in to get

00:08:19,860 --> 00:08:24,539
just any rep of int the exact subtype

00:08:22,409 --> 00:08:27,210
doesn't matter and for this we have a

00:08:24,539 --> 00:08:29,430
nice apply method in the companion

00:08:27,210 --> 00:08:31,949
object here that we can use to build at

00:08:29,430 --> 00:08:34,650
a simple AST so we just give it a note

00:08:31,949 --> 00:08:36,450
the intrinsic note to return and when

00:08:34,650 --> 00:08:38,909
you call to note you get that back and

00:08:36,450 --> 00:08:42,209
when you call in code ref you get a new

00:08:38,909 --> 00:08:48,600
new simple rep of T which will return

00:08:42,209 --> 00:08:50,339
whatever you encode it into it so when

00:08:48,600 --> 00:08:54,230
we look at this and code revv what we

00:08:50,339 --> 00:08:55,390
really mean here is to have a specific

00:08:54,230 --> 00:08:57,640
subtype

00:08:55,390 --> 00:08:59,170
of rap that we'd like to return so if

00:08:57,640 --> 00:09:01,990
you go back to the old version it just

00:08:59,170 --> 00:09:04,300
as rep of tea what we actually need in

00:09:01,990 --> 00:09:07,390
some cases is a type r which is a

00:09:04,300 --> 00:09:09,610
subtype of rep of t comma R but this

00:09:07,390 --> 00:09:12,130
would hugely complicate the encoding and

00:09:09,610 --> 00:09:14,170
maybe even make it impossible for the

00:09:12,130 --> 00:09:18,490
compiler to do the type inference

00:09:14,170 --> 00:09:20,410
incorrectly so we're playing a bit fast

00:09:18,490 --> 00:09:22,240
and loose of the types here so you need

00:09:20,410 --> 00:09:23,980
some casts I don't know if you've

00:09:22,240 --> 00:09:25,750
already seen so now we'll seen some will

00:09:23,980 --> 00:09:28,000
see some casts later that are needed

00:09:25,750 --> 00:09:29,380
because of this simplification but we

00:09:28,000 --> 00:09:31,090
have a different way of ensuring that

00:09:29,380 --> 00:09:33,430
the types are actually correct that you

00:09:31,090 --> 00:09:39,370
really do get the correct subtype that

00:09:33,430 --> 00:09:42,790
you want okay so let's start with the

00:09:39,370 --> 00:09:46,180
simplest rep values the primitive values

00:09:42,790 --> 00:09:48,760
there's a class literal rep that can

00:09:46,180 --> 00:09:51,880
contain a primitive value lift it into a

00:09:48,760 --> 00:09:55,230
wrap and it just contains the value and

00:09:51,880 --> 00:09:57,700
you can use it for every type that has a

00:09:55,230 --> 00:10:02,650
for which you have an evidence of type

00:09:57,700 --> 00:10:04,930
typed type of tea this is rather find a

00:10:02,650 --> 00:10:07,150
funny name especially in toy slick

00:10:04,930 --> 00:10:09,820
because typed type is the only type we

00:10:07,150 --> 00:10:12,250
have in toy slick the real slick has a

00:10:09,820 --> 00:10:14,470
class type that represents any type in

00:10:12,250 --> 00:10:17,380
the slick AST we don't use that here and

00:10:14,470 --> 00:10:20,800
typed type is a special type that has a

00:10:17,380 --> 00:10:23,380
scholar type parameter so you cannot get

00:10:20,800 --> 00:10:25,690
an implicit typed type for a scholar

00:10:23,380 --> 00:10:27,310
type and these are available for all the

00:10:25,690 --> 00:10:30,340
primitive types that you can use for a

00:10:27,310 --> 00:10:32,860
column so boolean int string and a

00:10:30,340 --> 00:10:35,770
couple of others those are the types you

00:10:32,860 --> 00:10:38,170
can use for a column possibly an option

00:10:35,770 --> 00:10:43,480
of this but we don't have options here

00:10:38,170 --> 00:10:45,970
and of course the to note returns a

00:10:43,480 --> 00:10:49,270
literal note when you call it on this

00:10:45,970 --> 00:10:51,160
literal wrap and encode ref just gives

00:10:49,270 --> 00:10:53,230
you any rep we don't need a letter or

00:10:51,160 --> 00:10:58,590
literal rep because for these simple

00:10:53,230 --> 00:11:02,320
types having any rep is enough and

00:10:58,590 --> 00:11:05,830
you've seen this underscore ID less than

00:11:02,320 --> 00:11:07,800
42 which looks like a regular less than

00:11:05,830 --> 00:11:09,420
method defined on int

00:11:07,800 --> 00:11:12,450
actually not that's what we have the

00:11:09,420 --> 00:11:16,880
extension methods for so there's an

00:11:12,450 --> 00:11:21,420
implicit class column extension methods

00:11:16,880 --> 00:11:24,959
that works for any rep of t where t is a

00:11:21,420 --> 00:11:27,709
typed type so for any primitive column

00:11:24,959 --> 00:11:30,329
and you get methods like less than and

00:11:27,709 --> 00:11:33,959
equals we have to use the triple equals

00:11:30,329 --> 00:11:35,820
because scala already grabs the double

00:11:33,959 --> 00:11:38,550
equals and puts it into object so

00:11:35,820 --> 00:11:39,839
there's no way we can enrich it with an

00:11:38,550 --> 00:11:41,880
implicit conversion to give you a

00:11:39,839 --> 00:11:44,100
different double equals but for all

00:11:41,880 --> 00:11:47,100
other operators like less than we can

00:11:44,100 --> 00:11:50,510
just give you the correct name that you

00:11:47,100 --> 00:11:53,220
expect so what do these operators return

00:11:50,510 --> 00:11:55,079
well of course they return a rep again

00:11:53,220 --> 00:11:58,170
in this case both returning rep of

00:11:55,079 --> 00:11:59,880
boolean usually the base operators would

00:11:58,170 --> 00:12:01,890
return a simple boolean so here it's a

00:11:59,880 --> 00:12:04,410
wrap of bouillon and what does it do

00:12:01,890 --> 00:12:06,839
well it gives you an apply because it's

00:12:04,410 --> 00:12:10,350
a function application we create a

00:12:06,839 --> 00:12:13,050
symbol that represents the function

00:12:10,350 --> 00:12:15,120
symbols are just wrappers for four

00:12:13,050 --> 00:12:18,990
strings in toys lick the real slick has

00:12:15,120 --> 00:12:20,579
more complicated symbols again and this

00:12:18,990 --> 00:12:24,870
function application has two parameters

00:12:20,579 --> 00:12:28,620
on the left hand side that's oh that's n

00:12:24,870 --> 00:12:31,470
dot to note where n comes from here and

00:12:28,620 --> 00:12:35,089
on the right-hand side there is a doctor

00:12:31,470 --> 00:12:39,920
note so we just refi this computation

00:12:35,089 --> 00:12:39,920
left side and less than the right side

00:12:41,450 --> 00:12:48,720
ok those are the scalar primitive values

00:12:45,180 --> 00:12:51,390
like boolean indian string we also need

00:12:48,720 --> 00:12:53,459
to represent tables these are still

00:12:51,390 --> 00:12:56,279
scalar value so they're not collections

00:12:53,459 --> 00:13:00,329
but they have they consist of multiple

00:12:56,279 --> 00:13:04,829
fields and for this we have a super

00:13:00,329 --> 00:13:09,329
class called table a table of t is a rep

00:13:04,829 --> 00:13:11,579
of tea and you give it a table name

00:13:09,329 --> 00:13:14,430
that's the name it has in a database and

00:13:11,579 --> 00:13:16,800
it has a method called column which you

00:13:14,430 --> 00:13:19,170
used to construct a column and of course

00:13:16,800 --> 00:13:20,790
a column is a rep of whatever type you

00:13:19,170 --> 00:13:24,240
give it and that type needs

00:13:20,790 --> 00:13:26,210
to have a typed type as expected what

00:13:24,240 --> 00:13:31,740
does it return when you call to note

00:13:26,210 --> 00:13:34,740
well it returns a select and a select in

00:13:31,740 --> 00:13:39,470
the to note which is the to note of the

00:13:34,740 --> 00:13:43,260
table itself and it selects a symbol of

00:13:39,470 --> 00:13:45,980
the column name so when you say u dot

00:13:43,260 --> 00:13:48,810
first you get a select of symbol first

00:13:45,980 --> 00:13:51,930
in whatever this table currently

00:13:48,810 --> 00:13:54,420
represents and you can see an example at

00:13:51,930 --> 00:13:57,420
the bottom we have the table users which

00:13:54,420 --> 00:14:00,300
extends table of couple of int string

00:13:57,420 --> 00:14:03,720
and string and it's called users and

00:14:00,300 --> 00:14:05,820
then we have three columns ID first and

00:14:03,720 --> 00:14:14,610
last they got their type and their name

00:14:05,820 --> 00:14:17,250
and this rep here the superclass that's

00:14:14,610 --> 00:14:21,510
just a rep of couple of int comma string

00:14:17,250 --> 00:14:23,580
comma string now if you want to do

00:14:21,510 --> 00:14:26,430
computations in the lifted embedding on

00:14:23,580 --> 00:14:29,700
these user values that's not really

00:14:26,430 --> 00:14:32,070
sufficient that you know it's a rep of

00:14:29,700 --> 00:14:34,800
couple of int string and string you want

00:14:32,070 --> 00:14:37,500
to be able to say u dot first and u dot

00:14:34,800 --> 00:14:40,230
last so so you really want to keep the

00:14:37,500 --> 00:14:44,070
information that it is an instance of

00:14:40,230 --> 00:14:45,930
users so unlike the primitive reps we

00:14:44,070 --> 00:14:48,270
actually have to keep the knowledge of

00:14:45,930 --> 00:14:50,130
this concrete subtype around when we

00:14:48,270 --> 00:14:52,110
process this we you have to know that

00:14:50,130 --> 00:14:54,330
it's actually a user's instance and not

00:14:52,110 --> 00:14:55,950
just a rep of something otherwise you

00:14:54,330 --> 00:15:00,350
could only refer to these fields as

00:14:55,950 --> 00:15:00,350
underscore one underscore 2 and under 03

00:15:00,560 --> 00:15:06,930
so how do we do this that's where we use

00:15:03,680 --> 00:15:12,060
this table tag that you've seen in the

00:15:06,930 --> 00:15:16,230
in the table class so that the tricky

00:15:12,060 --> 00:15:19,860
bit is that encode ref needs to build in

00:15:16,230 --> 00:15:21,390
a new instance of the correct type so in

00:15:19,860 --> 00:15:26,070
this case it needs to build a new

00:15:21,390 --> 00:15:28,200
instance of the same table class and we

00:15:26,070 --> 00:15:34,019
do this with a tag which contains the

00:15:28,200 --> 00:15:36,329
constructor so that's here users of

00:15:34,019 --> 00:15:39,569
back that's the constructor and you pass

00:15:36,329 --> 00:15:43,170
that to the tag to encapsulate it and

00:15:39,569 --> 00:15:46,079
attack also can encapsulate any path you

00:15:43,170 --> 00:15:49,739
encode into it any note so the two note

00:15:46,079 --> 00:15:52,679
in table just asks its table tag for the

00:15:49,739 --> 00:15:55,350
note if it has any non intrinsic node

00:15:52,679 --> 00:15:57,779
encoded into it and otherwise you get a

00:15:55,350 --> 00:16:02,100
table note with the table name as the

00:15:57,779 --> 00:16:05,189
intrinsic note and encode ref delegates

00:16:02,100 --> 00:16:07,619
to encode ref in the table tag and here

00:16:05,189 --> 00:16:11,639
you consider this ugly ugly cast because

00:16:07,619 --> 00:16:13,589
we don't have the exact types so at

00:16:11,639 --> 00:16:17,040
least as far as the values are concerned

00:16:13,589 --> 00:16:19,319
we now know that any primitive rep of T

00:16:17,040 --> 00:16:22,110
will give us another rep of t1 recalling

00:16:19,319 --> 00:16:23,489
code ref but if we call it on a table we

00:16:22,110 --> 00:16:25,769
will get an instance of the correct

00:16:23,489 --> 00:16:33,089
table instance the correct table row

00:16:25,769 --> 00:16:35,699
class so what about tuples tuples are

00:16:33,089 --> 00:16:38,399
sort of similar to tables because they

00:16:35,699 --> 00:16:42,240
can also contain different fields

00:16:38,399 --> 00:16:44,730
different individual columns this is the

00:16:42,240 --> 00:16:50,610
naive encoding we used in Scala query

00:16:44,730 --> 00:16:52,619
and what we do here is because a basic

00:16:50,610 --> 00:16:56,519
assumption is that anything in the

00:16:52,619 --> 00:17:00,509
lifted embedding is of type rep a couple

00:16:56,519 --> 00:17:04,199
of T 1 comma T 2 is represented as a rep

00:17:00,509 --> 00:17:06,120
of tupple of T 1 comma T 2 alright so

00:17:04,199 --> 00:17:08,549
that's what we do we have a special rep

00:17:06,120 --> 00:17:12,000
chapel class rep top of 2 in this case

00:17:08,549 --> 00:17:15,809
it has to type parameters T 1 and T 2

00:17:12,000 --> 00:17:19,049
and it contains two values of rep and t1

00:17:15,809 --> 00:17:22,079
and t2 and it is a rep of couple of t1

00:17:19,049 --> 00:17:24,360
and t2 it's not a real scholar topple so

00:17:22,079 --> 00:17:27,779
it's it's our own implementation of

00:17:24,360 --> 00:17:30,480
something similar to a topper so we can

00:17:27,779 --> 00:17:32,700
define some methods like this toppling

00:17:30,480 --> 00:17:35,639
operator that actually comes from scala

00:17:32,700 --> 00:17:40,080
query so when you have any primitive

00:17:35,639 --> 00:17:42,720
value you can say a tilde be and we will

00:17:40,080 --> 00:17:46,409
get a rep topple two of these two all

00:17:42,720 --> 00:17:47,580
right so you topple them up and then if

00:17:46,409 --> 00:17:50,820
you do

00:17:47,580 --> 00:17:53,250
tilda operator and another value you're

00:17:50,820 --> 00:17:55,950
down here you call this one and then you

00:17:53,250 --> 00:17:57,990
can build a rep topper 3 so you can

00:17:55,950 --> 00:18:01,350
append multiple columns to the topper

00:17:57,990 --> 00:18:05,880
and we did that for all air it is up to

00:18:01,350 --> 00:18:08,490
22 just auto generate those and that

00:18:05,880 --> 00:18:10,980
gives us something like this so now we

00:18:08,490 --> 00:18:13,470
can build tuples we have our users

00:18:10,980 --> 00:18:16,860
instance you and we can build a sort of

00:18:13,470 --> 00:18:20,910
a topple composed of you i D u dot first

00:18:16,860 --> 00:18:23,160
and you don't last that's nice but what

00:18:20,910 --> 00:18:26,010
we really want is this right we want to

00:18:23,160 --> 00:18:28,770
be able to use plain Scala code here we

00:18:26,010 --> 00:18:32,070
want to be able to use real tuples just

00:18:28,770 --> 00:18:34,920
call a real topic instructor and we also

00:18:32,070 --> 00:18:36,810
want this not just put individual

00:18:34,920 --> 00:18:40,140
columns into a couple we want to be able

00:18:36,810 --> 00:18:44,450
to put arbitrary complex things into a

00:18:40,140 --> 00:18:47,220
temple like the whole users row here and

00:18:44,450 --> 00:18:50,550
if we can put a whole row inside a

00:18:47,220 --> 00:18:52,410
temple why not another couple so there's

00:18:50,550 --> 00:18:56,220
a couple to that as one of its elements

00:18:52,410 --> 00:18:58,380
contains another tablet or and some

00:18:56,220 --> 00:19:01,590
people have really huge tables with more

00:18:58,380 --> 00:19:03,480
than twenty two columns and of course we

00:19:01,590 --> 00:19:05,430
need something for those as well if they

00:19:03,480 --> 00:19:08,370
really want to represent it in a flat

00:19:05,430 --> 00:19:11,310
way so why not use H lists they can be

00:19:08,370 --> 00:19:13,080
arbitrarily large now all these things

00:19:11,310 --> 00:19:16,860
have unfortunately one thing in common

00:19:13,080 --> 00:19:20,130
that was a basic assumption so far those

00:19:16,860 --> 00:19:21,750
are not rep of tea there are all kinds

00:19:20,130 --> 00:19:24,300
of different types couple types and

00:19:21,750 --> 00:19:28,200
ageless types but not a rep of tea so

00:19:24,300 --> 00:19:30,810
how do we solve this well we need

00:19:28,200 --> 00:19:32,790
polymorphic record types that's the

00:19:30,810 --> 00:19:35,370
second increment comprehensible part of

00:19:32,790 --> 00:19:37,230
the title so what does it mean if you go

00:19:35,370 --> 00:19:39,630
to Wikipedia you'll find out that a

00:19:37,230 --> 00:19:42,060
record type as a fixed number of

00:19:39,630 --> 00:19:44,550
elements with a known type and these

00:19:42,060 --> 00:19:46,590
elements also have names but we can kind

00:19:44,550 --> 00:19:48,750
of count underscore one underscore to

00:19:46,590 --> 00:19:51,960
underscore three as names right so

00:19:48,750 --> 00:19:54,210
tuples qualify and they're polymorphic

00:19:51,960 --> 00:19:57,330
so that means they abstract / element

00:19:54,210 --> 00:19:59,399
types in particular if you have a tuple

00:19:57,330 --> 00:20:01,200
you can put an int into it

00:19:59,399 --> 00:20:03,179
and you can also with a different type

00:20:01,200 --> 00:20:05,219
parameter put a rep of int into it

00:20:03,179 --> 00:20:08,369
that's a proud we care about the same

00:20:05,219 --> 00:20:14,460
container type can contain an int and a

00:20:08,369 --> 00:20:17,309
wrap of int so here are some examples of

00:20:14,460 --> 00:20:20,009
this polymorphic record types of course

00:20:17,309 --> 00:20:22,379
tuples as we've seen before that's what

00:20:20,009 --> 00:20:24,809
we want most of all you can have a

00:20:22,379 --> 00:20:26,999
couple of in string and string and you

00:20:24,809 --> 00:20:30,269
can have a couple of rep of n drip of

00:20:26,999 --> 00:20:32,789
string and drop off string and you can

00:20:30,269 --> 00:20:34,710
also mix it like have an end and a wrap

00:20:32,789 --> 00:20:37,879
of string and the users instance inside

00:20:34,710 --> 00:20:41,009
a couple that works and we can have

00:20:37,879 --> 00:20:42,929
product like types that are not tuples

00:20:41,009 --> 00:20:45,539
but they're all isomorphic to tablets or

00:20:42,929 --> 00:20:47,429
if we look at this class pair that's

00:20:45,539 --> 00:20:49,769
pretty much the same as at apple too so

00:20:47,429 --> 00:20:53,309
we should be able to use it in the same

00:20:49,769 --> 00:20:56,700
way and we can also have h list types

00:20:53,309 --> 00:20:59,759
because we already allow nested tuples

00:20:56,700 --> 00:21:02,190
at least we want to allow them so if we

00:20:59,759 --> 00:21:04,320
can manage Nesta tuples we can manage h

00:21:02,190 --> 00:21:06,269
lists because age lists are basically

00:21:04,320 --> 00:21:09,479
nessa tuples their isomorphic to Nestor

00:21:06,269 --> 00:21:13,320
tuples so why not let's see if we get

00:21:09,479 --> 00:21:16,969
there so you will need to take a little

00:21:13,320 --> 00:21:19,950
detour to functional dependencies

00:21:16,969 --> 00:21:22,049
because that's a an important feature of

00:21:19,950 --> 00:21:25,440
the scholar language that is required to

00:21:22,049 --> 00:21:27,269
implement this so what we mean by

00:21:25,440 --> 00:21:31,289
functional dependencies are dependencies

00:21:27,269 --> 00:21:33,539
between type parameters here's an

00:21:31,289 --> 00:21:35,820
example actually one that doesn't use

00:21:33,539 --> 00:21:40,460
functional dependencies yet but we'll

00:21:35,820 --> 00:21:43,379
get to that in a moment so we have this

00:21:40,460 --> 00:21:46,229
class convert which represents some

00:21:43,379 --> 00:21:49,229
conversion with a type from and a type

00:21:46,229 --> 00:21:51,779
two and a conversion function and then

00:21:49,229 --> 00:21:54,629
we have implicit values like int to long

00:21:51,779 --> 00:21:56,519
long to string string to int if you've

00:21:54,629 --> 00:21:58,499
seen Martin's keynote you know that you

00:21:56,519 --> 00:22:00,779
never define an implicit function from

00:21:58,499 --> 00:22:02,639
into string or something but you can

00:22:00,779 --> 00:22:05,009
define a convert that wraps this

00:22:02,639 --> 00:22:09,520
function and that can be implicit that's

00:22:05,009 --> 00:22:11,740
a legal use of implicit

00:22:09,520 --> 00:22:14,950
and then we can have a function f which

00:22:11,740 --> 00:22:17,440
takes to type parameters t1 and t2 takes

00:22:14,950 --> 00:22:20,050
the value of t1 and returns it t 2 and

00:22:17,440 --> 00:22:22,450
how does it do that it takes a convert

00:22:20,050 --> 00:22:25,390
implicit convert from T 1 and 2 2 and

00:22:22,450 --> 00:22:27,340
calls that so it's not really surprising

00:22:25,390 --> 00:22:31,180
that the three lines at the bottom

00:22:27,340 --> 00:22:36,190
compile and run right the first one gets

00:22:31,180 --> 00:22:40,590
an int so this is an int we know that t1

00:22:36,190 --> 00:22:45,880
is int and it expects a long as a result

00:22:40,590 --> 00:22:49,180
so that is t2 we now know t2 so we know

00:22:45,880 --> 00:22:52,180
we need a convert of T 1 comma T to wear

00:22:49,180 --> 00:22:55,180
this is int and long and we find that

00:22:52,180 --> 00:22:58,020
and plug it back in and everything works

00:22:55,180 --> 00:23:01,720
and the same for the other two now the

00:22:58,020 --> 00:23:04,450
not-so-obvious part is this still works

00:23:01,720 --> 00:23:07,390
we do not need to annotate these result

00:23:04,450 --> 00:23:11,080
types and that's due to functional

00:23:07,390 --> 00:23:13,600
dependencies so what happens here well

00:23:11,080 --> 00:23:16,840
we again start with this value for the

00:23:13,600 --> 00:23:21,760
two of type int so now we know this t1

00:23:16,840 --> 00:23:24,550
is int this is known and we do not know

00:23:21,760 --> 00:23:28,000
the result type we just say Val l equals

00:23:24,550 --> 00:23:30,070
f of 42 and the compiler is not either

00:23:28,000 --> 00:23:34,420
smart or stupid enough to assume that L

00:23:30,070 --> 00:23:37,240
stands for long so this is undefined at

00:23:34,420 --> 00:23:40,690
this point it's an undetermined type

00:23:37,240 --> 00:23:43,420
parameter but we can still perform an

00:23:40,690 --> 00:23:45,340
implicit search and even older scholar

00:23:43,420 --> 00:23:47,190
versions were able to do that so you

00:23:45,340 --> 00:23:50,440
perform an implicit search of an

00:23:47,190 --> 00:23:53,410
instance of convert where the first type

00:23:50,440 --> 00:23:56,590
parameter is int and there's exactly one

00:23:53,410 --> 00:23:58,240
of them it's this one in too long that's

00:23:56,590 --> 00:24:01,900
the only one where the first parameter

00:23:58,240 --> 00:24:04,140
is int so we find it that's not too hard

00:24:01,900 --> 00:24:07,600
now the interesting part is after

00:24:04,140 --> 00:24:10,030
resolving this implicit the compiler now

00:24:07,600 --> 00:24:14,970
knows that the other type parameter this

00:24:10,030 --> 00:24:19,330
t2 is long so this one is now known

00:24:14,970 --> 00:24:22,120
which means we know it here and we know

00:24:19,330 --> 00:24:22,930
the return type so the return type is

00:24:22,120 --> 00:24:28,360
actually

00:24:22,930 --> 00:24:31,000
inferred from this convert instance so

00:24:28,360 --> 00:24:33,700
convert act as a type level function

00:24:31,000 --> 00:24:36,190
here one we give it one of the type

00:24:33,700 --> 00:24:38,770
parameters and it computes the other one

00:24:36,190 --> 00:24:41,650
through implicit search and then we can

00:24:38,770 --> 00:24:46,630
use this other type parameter in the

00:24:41,650 --> 00:24:50,230
return value this feature was actually

00:24:46,630 --> 00:24:52,930
added to scala in version 2.8 for the

00:24:50,230 --> 00:24:55,360
big collections redesign scala had a

00:24:52,930 --> 00:24:58,000
different kind of collections library up

00:24:55,360 --> 00:25:01,570
to 2.7 and then martin rewrote

00:24:58,000 --> 00:25:03,760
everything for 2.8 with this neat can

00:25:01,570 --> 00:25:05,920
build from type class that you can

00:25:03,760 --> 00:25:07,810
frequently see in questions on stack

00:25:05,920 --> 00:25:11,170
overflow where people wonder what kind

00:25:07,810 --> 00:25:14,110
of error messages they get and this also

00:25:11,170 --> 00:25:16,270
uses functional dependencies and they

00:25:14,110 --> 00:25:19,210
were added for this so for an example

00:25:16,270 --> 00:25:22,420
you have in a collection like vector of

00:25:19,210 --> 00:25:24,610
int but you want to call map on it this

00:25:22,420 --> 00:25:26,620
map method is actually defined and

00:25:24,610 --> 00:25:28,450
implemented way up in the inherent

00:25:26,620 --> 00:25:33,270
inheritance hierarchy so you have like

00:25:28,450 --> 00:25:38,800
vector extends immutable sig extends

00:25:33,270 --> 00:25:40,840
generic seek extends iterable extent

00:25:38,800 --> 00:25:42,820
know extent seek extends iterable

00:25:40,840 --> 00:25:45,070
extends traversable extends traversable

00:25:42,820 --> 00:25:48,400
like and that's finally where we find

00:25:45,070 --> 00:25:50,530
the map method and when you call map you

00:25:48,400 --> 00:25:52,570
still get a vector back even though it's

00:25:50,530 --> 00:25:54,790
implemented way up and the inheritance

00:25:52,570 --> 00:25:57,130
hierarchy and that's using the same

00:25:54,790 --> 00:26:00,850
mechanism so if we have a vector of int

00:25:57,130 --> 00:26:07,270
then a in this case is int and this

00:26:00,850 --> 00:26:11,500
rapper be that's the vector of end so we

00:26:07,270 --> 00:26:14,140
call map and it has to type parameters

00:26:11,500 --> 00:26:17,290
be and that we give it an F from A to B

00:26:14,140 --> 00:26:19,660
so we know the rapper already we know

00:26:17,290 --> 00:26:22,270
the beef from the mapping function we do

00:26:19,660 --> 00:26:25,870
not know that that which is the return

00:26:22,270 --> 00:26:28,030
type so we use a can built from instance

00:26:25,870 --> 00:26:30,430
which is determined uniquely by the

00:26:28,030 --> 00:26:32,470
first two type parameters and the third

00:26:30,430 --> 00:26:33,080
one the return type is computed from

00:26:32,470 --> 00:26:35,210
those

00:26:33,080 --> 00:26:39,650
to implicit search that's exactly the

00:26:35,210 --> 00:26:41,930
same mechanism we saw before and that's

00:26:39,650 --> 00:26:45,380
also the mechanism we're going to use

00:26:41,930 --> 00:26:49,490
for slick and the class we haven't slick

00:26:45,380 --> 00:26:52,790
is called a shape so instead of

00:26:49,490 --> 00:26:54,830
requiring that every value that we deal

00:26:52,790 --> 00:26:59,000
with in the lifted embedding is a rep of

00:26:54,830 --> 00:27:01,430
some type we now require any type as

00:26:59,000 --> 00:27:05,090
long as we have a shape of that type of

00:27:01,430 --> 00:27:07,040
a laboy which is a useful thing to do in

00:27:05,090 --> 00:27:10,220
general if you want to abstract further

00:27:07,040 --> 00:27:12,290
move from inheritance to type classes do

00:27:10,220 --> 00:27:15,320
not require something to be an instance

00:27:12,290 --> 00:27:18,680
of whatever just take an implicit value

00:27:15,320 --> 00:27:22,240
of some evidence type so that's what we

00:27:18,680 --> 00:27:24,800
do we have a shape and we can look it up

00:27:22,240 --> 00:27:26,960
exclusively by the mixed type this first

00:27:24,800 --> 00:27:29,780
type parameter here and from that we

00:27:26,960 --> 00:27:32,600
compute the unpacked type so previously

00:27:29,780 --> 00:27:35,270
the mixed type would always be a rep of

00:27:32,600 --> 00:27:37,580
T and the unpacked type would always be

00:27:35,270 --> 00:27:38,750
the t and then we also have the packet

00:27:37,580 --> 00:27:40,430
type which is the opposite

00:27:38,750 --> 00:27:42,800
transformation if you give it a tea as

00:27:40,430 --> 00:27:44,510
the mixed up you will get a rep of T of

00:27:42,800 --> 00:27:47,720
the packet type so there's basically

00:27:44,510 --> 00:27:49,670
reps everywhere we'll see in a bit why

00:27:47,720 --> 00:27:56,180
we need that first of all we only need

00:27:49,670 --> 00:27:58,930
to mix an unpacked so the simplest kind

00:27:56,180 --> 00:28:01,520
of shapes are those for primitive values

00:27:58,930 --> 00:28:03,530
or primitive types will first look at

00:28:01,520 --> 00:28:06,110
the at the type level stuff here not at

00:28:03,530 --> 00:28:08,960
the implementations so we have our

00:28:06,110 --> 00:28:13,340
example query again users filter map and

00:28:08,960 --> 00:28:16,310
so on and for every expression in there

00:28:13,340 --> 00:28:19,460
we can get the right shape so for this

00:28:16,310 --> 00:28:22,250
underscore ID which is a rep of int we

00:28:19,460 --> 00:28:24,530
get a column shaped shape a column shape

00:28:22,250 --> 00:28:27,530
which is available for every type T

00:28:24,530 --> 00:28:34,490
which has has a type type and gives you

00:28:27,530 --> 00:28:37,400
a oops a rep of T a shape of rep of T

00:28:34,490 --> 00:28:41,090
right and for primitive values like 42

00:28:37,400 --> 00:28:43,370
we have primitive shape again also 80

00:28:41,090 --> 00:28:46,470
which is a typed type and you get a

00:28:43,370 --> 00:28:51,240
shape of tea and of course

00:28:46,470 --> 00:28:53,580
both unpack to tea so the Intel unpacks

00:28:51,240 --> 00:28:56,580
to int and the wrap oven int also

00:28:53,580 --> 00:29:00,299
untaxed to int if you run it and both

00:28:56,580 --> 00:29:04,070
pack to wrap of tea and then we have the

00:29:00,299 --> 00:29:06,780
table shape for our users table row and

00:29:04,070 --> 00:29:08,880
that's almost the same as a column shape

00:29:06,780 --> 00:29:11,220
we need to do use some tricky encoding

00:29:08,880 --> 00:29:13,169
there with this implicit evidence what

00:29:11,220 --> 00:29:16,320
we really want to say is we have AC

00:29:13,169 --> 00:29:17,610
which is a subtype of table of tea but

00:29:16,320 --> 00:29:19,890
we cannot just write it like that

00:29:17,610 --> 00:29:21,630
because Scala cannot infer it so we use

00:29:19,890 --> 00:29:24,870
this this little trick with the extra

00:29:21,630 --> 00:29:28,140
implicit and then we get a shape of C

00:29:24,870 --> 00:29:32,760
comma T comma C the same as the column

00:29:28,140 --> 00:29:35,460
shape in the sense that well we'll get

00:29:32,760 --> 00:29:40,260
to that in a moment let's look at apple

00:29:35,460 --> 00:29:44,909
shapes first so what we do here is we

00:29:40,260 --> 00:29:48,120
map from a user's rho 2 u dot Apple of

00:29:44,909 --> 00:29:51,929
you first comma 42 so we put a a rep of

00:29:48,120 --> 00:29:55,110
string and an int inside it now when you

00:29:51,929 --> 00:29:58,230
call map there's an implicit shape

00:29:55,110 --> 00:30:00,299
required for the return type so this

00:29:58,230 --> 00:30:03,570
this will give you an implicit look up

00:30:00,299 --> 00:30:06,210
of a shape of couple of rep of string

00:30:03,570 --> 00:30:08,880
comma int and the other two we don't

00:30:06,210 --> 00:30:11,280
care about we don't need them so for

00:30:08,880 --> 00:30:14,880
this we have eight apple to shape which

00:30:11,280 --> 00:30:20,549
gives us a shape of eight apple so we

00:30:14,880 --> 00:30:23,100
need eight apple here and this is the

00:30:20,549 --> 00:30:26,070
topple shape so we can get a shape of

00:30:23,100 --> 00:30:28,320
any tupple provided that we have a shape

00:30:26,070 --> 00:30:31,049
for the left side and a shape for the

00:30:28,320 --> 00:30:34,830
right side the left side here is a rep

00:30:31,049 --> 00:30:37,230
of string so this you one has to be a

00:30:34,830 --> 00:30:41,990
column shape and the right side is an

00:30:37,230 --> 00:30:44,610
int so the u2 is a primitive shape and

00:30:41,990 --> 00:30:48,809
since we have functional dependencies

00:30:44,610 --> 00:30:53,159
you know already that these other types

00:30:48,809 --> 00:30:57,539
that are computed they flow up in the in

00:30:53,159 --> 00:30:59,290
the implicit resolution so now we are we

00:30:57,539 --> 00:31:02,650
know all these types and can use the

00:30:59,290 --> 00:31:05,170
later on and of course we don't write

00:31:02,650 --> 00:31:14,290
these tuples shapes by hand they are

00:31:05,170 --> 00:31:18,010
still generated for all energies so what

00:31:14,290 --> 00:31:20,140
about nested tuples well there isn't

00:31:18,010 --> 00:31:22,510
really anything to do for nested tuples

00:31:20,140 --> 00:31:25,450
because this encoding they just work

00:31:22,510 --> 00:31:29,500
automatically out of the box let's see

00:31:25,450 --> 00:31:32,800
how here we have a typo to which on the

00:31:29,500 --> 00:31:34,860
left side contains a string a rep of

00:31:32,800 --> 00:31:41,080
string you dot first is a rep of string

00:31:34,860 --> 00:31:45,250
so first we get a tuple to shape and for

00:31:41,080 --> 00:31:49,480
you one we need a column shape and then

00:31:45,250 --> 00:31:55,390
for you too you too is of type couple of

00:31:49,480 --> 00:31:58,480
rep of int comma int so that's another

00:31:55,390 --> 00:32:02,770
type of to shape so the left hand side

00:31:58,480 --> 00:32:04,870
of that is a wrap of int and the right

00:32:02,770 --> 00:32:07,990
hand side is an int so we take that one

00:32:04,870 --> 00:32:11,170
here and we got the shape it's done

00:32:07,990 --> 00:32:13,000
recursively and of course the pack and

00:32:11,170 --> 00:32:16,300
untell unpacked types flow up

00:32:13,000 --> 00:32:22,180
recursively in the computation so this

00:32:16,300 --> 00:32:23,650
just works like that so let's look at

00:32:22,180 --> 00:32:25,420
the shape implementations you only

00:32:23,650 --> 00:32:27,640
looked at the type so far and that's

00:32:25,420 --> 00:32:30,460
already enough to get the result type of

00:32:27,640 --> 00:32:32,680
a database computation inferred but we

00:32:30,460 --> 00:32:36,210
want to be able to build an AST so we

00:32:32,680 --> 00:32:40,120
need to do something with the values now

00:32:36,210 --> 00:32:43,240
since a shape generalized rep and two

00:32:40,120 --> 00:32:45,670
basic operations in rep were two node

00:32:43,240 --> 00:32:48,130
and encode ref we need the same thing in

00:32:45,670 --> 00:32:50,920
shape so shape gets to note and encode

00:32:48,130 --> 00:32:54,250
ref but a rep stands for a specific

00:32:50,920 --> 00:32:58,480
value a shape only for a type so these

00:32:54,250 --> 00:33:01,560
two take values as parameters in

00:32:58,480 --> 00:33:04,660
addition to whatever else they take and

00:33:01,560 --> 00:33:07,630
the second pair of operations we have

00:33:04,660 --> 00:33:10,990
here is called pack and packed shape so

00:33:07,630 --> 00:33:13,420
for a mixed value we can return

00:33:10,990 --> 00:33:15,429
packed value and we can also return the

00:33:13,420 --> 00:33:20,080
matching shape for that that's something

00:33:15,429 --> 00:33:22,929
we'll need to do later on now this is

00:33:20,080 --> 00:33:25,809
the simplest shape implementation that's

00:33:22,929 --> 00:33:28,420
the rep shake and it's the simplest one

00:33:25,809 --> 00:33:31,270
because shape is a generalization of rep

00:33:28,420 --> 00:33:33,580
so whenever we already have a rep it

00:33:31,270 --> 00:33:35,800
should be trivial to return in shape for

00:33:33,580 --> 00:33:38,140
that and this is true for both column

00:33:35,800 --> 00:33:40,600
shape and table shape both are just rep

00:33:38,140 --> 00:33:42,490
shapes with different implicit because

00:33:40,600 --> 00:33:45,730
we need to constrain the implicit shape

00:33:42,490 --> 00:33:48,429
here for a typed type and here new we

00:33:45,730 --> 00:33:52,600
need a table but they both returned rep

00:33:48,429 --> 00:33:55,030
shape so a rep shape has a the same

00:33:52,600 --> 00:33:58,059
mixed and patched types and both are

00:33:55,030 --> 00:34:00,250
reps so to note just delegates to value

00:33:58,059 --> 00:34:03,670
duck to node and encode ref delegates to

00:34:00,250 --> 00:34:06,010
value encode breath and since the type

00:34:03,670 --> 00:34:09,159
is already packed the mix and pack type

00:34:06,010 --> 00:34:12,010
are identical pack and packed shape or

00:34:09,159 --> 00:34:16,659
just identity operations nothing more to

00:34:12,010 --> 00:34:19,960
do so what about primitive shapes well

00:34:16,659 --> 00:34:23,379
we can define a shape for a primitive

00:34:19,960 --> 00:34:26,260
type T with unpacks to itself packs to

00:34:23,379 --> 00:34:29,560
rep of T we can implement pack which

00:34:26,260 --> 00:34:31,570
gives us a literal rep we can create a

00:34:29,560 --> 00:34:35,109
packed shape which is the rep shape

00:34:31,570 --> 00:34:37,149
again we can get a two node operation

00:34:35,109 --> 00:34:40,600
with just cheat we call to note on

00:34:37,149 --> 00:34:42,879
whatever we pack too but we have a

00:34:40,600 --> 00:34:45,040
problem with in code revv because the

00:34:42,879 --> 00:34:49,389
constraint was that the contract was

00:34:45,040 --> 00:34:52,139
that encode r f+ to note as to give us

00:34:49,389 --> 00:34:54,820
the same path again but here this this

00:34:52,139 --> 00:34:57,340
value we could be an Intel do you encode

00:34:54,820 --> 00:34:59,830
a path into the number 42 you cannot do

00:34:57,340 --> 00:35:02,290
that so we just have to give up and

00:34:59,830 --> 00:35:07,359
throw an exception which might become a

00:35:02,290 --> 00:35:09,760
problem later on so we've looked at at

00:35:07,359 --> 00:35:15,010
scalar values now what about queries a

00:35:09,760 --> 00:35:18,160
query represents a sequence of value so

00:35:15,010 --> 00:35:22,420
that's a collection so a query of e of

00:35:18,160 --> 00:35:24,000
you is a rep of seek of you but we also

00:35:22,420 --> 00:35:25,920
encode the

00:35:24,000 --> 00:35:28,260
type in here so E is the mixed type

00:35:25,920 --> 00:35:30,540
whatever you wrote in your in your

00:35:28,260 --> 00:35:34,140
lifted embedding and you is the unpack

00:35:30,540 --> 00:35:37,500
type we keep both of them here so it has

00:35:34,140 --> 00:35:39,180
a it wraps a note which is conveniently

00:35:37,500 --> 00:35:41,480
called to node so we don't have to

00:35:39,180 --> 00:35:45,390
implement a separate method for that and

00:35:41,480 --> 00:35:47,360
it wraps a shaped value I'm not showing

00:35:45,390 --> 00:35:50,100
the source code for that it's just a a

00:35:47,360 --> 00:35:55,110
combination of a shape plus its value of

00:35:50,100 --> 00:35:57,780
some convenience methods on it so we

00:35:55,110 --> 00:36:00,360
still need in code revv well that just

00:35:57,780 --> 00:36:03,300
built a new query so for a query what we

00:36:00,360 --> 00:36:05,280
need as a rep of whatever is actually a

00:36:03,300 --> 00:36:06,990
query that's good enough there are

00:36:05,280 --> 00:36:09,210
subtypes of query but we never care

00:36:06,990 --> 00:36:11,240
about them query has the operations

00:36:09,210 --> 00:36:14,430
defined on it so that's what we need and

00:36:11,240 --> 00:36:16,770
to encode a path we just give it a new

00:36:14,430 --> 00:36:18,810
path here in the constructor and the

00:36:16,770 --> 00:36:20,250
shaped value stays the same we don't

00:36:18,810 --> 00:36:22,620
have to do anything with that because

00:36:20,250 --> 00:36:23,940
it's really just a proxy it's only

00:36:22,620 --> 00:36:27,060
relevant when we want to encode

00:36:23,940 --> 00:36:29,190
something into it we need to be able to

00:36:27,060 --> 00:36:32,490
create an initial query for a table

00:36:29,190 --> 00:36:34,350
that's called a table query and yeah we

00:36:32,490 --> 00:36:36,740
give it a constructor of the table and

00:36:34,350 --> 00:36:39,030
then it goes through the tag and so on

00:36:36,740 --> 00:36:41,540
you can see the details here you can

00:36:39,030 --> 00:36:44,700
also try it out if you run the code

00:36:41,540 --> 00:36:46,560
doesn't really matter that much more

00:36:44,700 --> 00:36:50,310
interesting is the operations that we

00:36:46,560 --> 00:36:54,600
implement so his filter defined on a

00:36:50,310 --> 00:36:56,400
query that's the simplest higher-order

00:36:54,600 --> 00:36:58,860
function that you can have so it takes

00:36:56,400 --> 00:37:01,710
the regular filter collection takes a

00:36:58,860 --> 00:37:03,390
function from E to boolean so here it

00:37:01,710 --> 00:37:05,340
takes a function from E to rep of

00:37:03,390 --> 00:37:06,990
boolean we don't have to bother with

00:37:05,340 --> 00:37:09,660
abstracting through shapes because

00:37:06,990 --> 00:37:11,760
bullying is a primitive type so we

00:37:09,660 --> 00:37:15,900
always have a rep of boolean it's it's

00:37:11,760 --> 00:37:17,880
that simple and what do we want to build

00:37:15,900 --> 00:37:20,490
well we want to build the AST on the

00:37:17,880 --> 00:37:25,170
right which contains a filter note it

00:37:20,490 --> 00:37:29,190
has a symbol we call that s9 here on the

00:37:25,170 --> 00:37:31,410
right it's this is the you down here you

00:37:29,190 --> 00:37:32,760
cannot call it you because scala doesn't

00:37:31,410 --> 00:37:34,800
tell us the name of the variable you

00:37:32,760 --> 00:37:36,750
don't see that we just generate a new

00:37:34,800 --> 00:37:41,400
name for it

00:37:36,750 --> 00:37:45,870
and we have our sheykh value we call

00:37:41,400 --> 00:37:48,240
encode ref and encode the ref 2s9 into

00:37:45,870 --> 00:37:51,120
it so whenever you call you in this

00:37:48,240 --> 00:37:55,260
expression like you ID this use now

00:37:51,120 --> 00:37:57,960
stands for ref 2s9 so here we have you

00:37:55,260 --> 00:38:02,690
ID less than forty two so this u dot ID

00:37:57,960 --> 00:38:07,410
itself is now select ID in ref s9 and

00:38:02,690 --> 00:38:13,410
the s9 is here and we have a literal

00:38:07,410 --> 00:38:16,410
value so that works right and map should

00:38:13,410 --> 00:38:18,980
work the same way this is filter of this

00:38:16,410 --> 00:38:21,960
is map the they're almost the same

00:38:18,980 --> 00:38:24,030
there's one minor complication map

00:38:21,960 --> 00:38:27,900
returns it has a different return types

00:38:24,030 --> 00:38:30,810
so now we need to take a shape map has a

00:38:27,900 --> 00:38:32,910
transformation from type E to F and for

00:38:30,810 --> 00:38:35,040
F we need a shape so we can also get the

00:38:32,910 --> 00:38:39,330
unpacked type which we call T and then

00:38:35,040 --> 00:38:41,040
we return a query of F comma T the

00:38:39,330 --> 00:38:43,770
implementation is almost the same again

00:38:41,040 --> 00:38:47,790
we create a fresh symbol it's called s8

00:38:43,770 --> 00:38:52,260
here we encode that into the shape value

00:38:47,790 --> 00:38:55,920
we call our function on it we package

00:38:52,260 --> 00:38:58,610
those up into a new shaped value and put

00:38:55,920 --> 00:39:03,000
that into the query and what we actually

00:38:58,610 --> 00:39:05,820
want as an AST is a map note that has

00:39:03,000 --> 00:39:08,430
the symbol it has the original to note

00:39:05,820 --> 00:39:13,710
so that's whatever we call map on and it

00:39:08,430 --> 00:39:16,710
has the mapping functions note okay that

00:39:13,710 --> 00:39:19,890
looks reasonable so let's try it what

00:39:16,710 --> 00:39:23,610
happens in this example here so we call

00:39:19,890 --> 00:39:25,440
map once and return a tuple and then we

00:39:23,610 --> 00:39:28,830
call map again on the top oh this is

00:39:25,440 --> 00:39:32,010
something you expect to work but the

00:39:28,830 --> 00:39:34,290
problem is we put 42 in this it's an int

00:39:32,010 --> 00:39:37,110
the right hand side of this tuple is an

00:39:34,290 --> 00:39:39,810
end and this is a tappa which contains

00:39:37,110 --> 00:39:43,410
an int and when you call map it calls

00:39:39,810 --> 00:39:45,210
encode ref to encode this path to sa

00:39:43,410 --> 00:39:48,870
door as nine or whatever it was into it

00:39:45,210 --> 00:39:50,230
and this blows up so this cannot work

00:39:48,870 --> 00:39:52,990
because we cannot encode

00:39:50,230 --> 00:39:55,210
anything into an end so how do we fix

00:39:52,990 --> 00:39:57,790
that well that's what we need the

00:39:55,210 --> 00:40:00,820
package types for we can encode

00:39:57,790 --> 00:40:03,880
something into a rep event so we make

00:40:00,820 --> 00:40:07,359
sure that everything that comes out of a

00:40:03,880 --> 00:40:11,020
map call is actually packed so now we

00:40:07,359 --> 00:40:13,900
get this G here as the pact type and we

00:40:11,020 --> 00:40:17,200
don't return a query of F comma T we

00:40:13,900 --> 00:40:20,140
return a query of G comity so we pack it

00:40:17,200 --> 00:40:22,840
after every transformation step that we

00:40:20,140 --> 00:40:24,520
need to do and we do that by calling

00:40:22,840 --> 00:40:26,700
packed value on the shaped value which

00:40:24,520 --> 00:40:30,310
just called pack and packed shape and

00:40:26,700 --> 00:40:31,720
pass them up again and the rest is the

00:40:30,310 --> 00:40:34,090
same this is the actual map

00:40:31,720 --> 00:40:37,840
implementation that we do and now when

00:40:34,090 --> 00:40:39,580
we run that this is a rep of end because

00:40:37,840 --> 00:40:45,580
that's what came out of the first nap

00:40:39,580 --> 00:40:46,540
call and everything works so we don't

00:40:45,580 --> 00:40:49,900
really have to go into the

00:40:46,540 --> 00:40:53,320
implementations of topple shapes just a

00:40:49,900 --> 00:40:56,220
quick overview here there's a superclass

00:40:53,320 --> 00:40:58,750
called product node shape which has some

00:40:56,220 --> 00:41:01,240
auxiliary functions and we also generate

00:40:58,750 --> 00:41:04,530
some code but the domain gist is in to

00:41:01,240 --> 00:41:07,390
note what you want to do for a couple is

00:41:04,530 --> 00:41:10,420
you take the individual element shapes

00:41:07,390 --> 00:41:13,950
you sip them up with the elements

00:41:10,420 --> 00:41:17,470
element values and then for each of them

00:41:13,950 --> 00:41:19,420
for each pair you call to note and you

00:41:17,470 --> 00:41:23,619
put the whole thing into a product node

00:41:19,420 --> 00:41:27,030
and similarly in encode ref you take the

00:41:23,619 --> 00:41:29,560
element shapes you sip it with the

00:41:27,030 --> 00:41:33,690
elements and you sip it with the index

00:41:29,560 --> 00:41:37,810
and then you can call encode riff on

00:41:33,690 --> 00:41:40,210
each pair of element and it's matching

00:41:37,810 --> 00:41:42,160
shape but but what you encode into it is

00:41:40,210 --> 00:41:46,420
not the original path that comes from up

00:41:42,160 --> 00:41:49,660
here but it's a select in this path with

00:41:46,420 --> 00:41:51,820
a symbol underscore and the position so

00:41:49,660 --> 00:41:53,920
when you have a a top align encode a

00:41:51,820 --> 00:41:55,930
path into it each element of the table

00:41:53,920 --> 00:41:58,830
actually is a select of the correct

00:41:55,930 --> 00:41:58,830
index in that path

00:42:00,640 --> 00:42:05,300
so there's one final feature we haven't

00:42:03,440 --> 00:42:10,609
looked at yet that's heterogeneous lists

00:42:05,300 --> 00:42:13,099
or H lists so if you haven't used those

00:42:10,609 --> 00:42:16,400
yet they're almost like a regular

00:42:13,099 --> 00:42:19,820
scholar list a list is a implemented as

00:42:16,400 --> 00:42:22,040
a contest so there are two cases you

00:42:19,820 --> 00:42:25,480
have nil which represents an empty list

00:42:22,040 --> 00:42:27,980
and you have cons which represents a

00:42:25,480 --> 00:42:30,859
concatenation of an element to the front

00:42:27,980 --> 00:42:32,990
of another list so cons has a head value

00:42:30,859 --> 00:42:35,300
which is an actual element in the list

00:42:32,990 --> 00:42:37,400
and it has a tail value which is the

00:42:35,300 --> 00:42:40,700
rest of the whole list so you have like

00:42:37,400 --> 00:42:43,250
cons of a comic cons of B comma and so

00:42:40,700 --> 00:42:45,380
on in the end you have deal and you do

00:42:43,250 --> 00:42:47,570
the same thing for H list except that

00:42:45,380 --> 00:42:49,820
you keep the types of all these elements

00:42:47,570 --> 00:42:52,730
here it has type parameters for the head

00:42:49,820 --> 00:42:55,849
in the tail so you can write types like

00:42:52,730 --> 00:42:59,080
H cons of int comma H cons of string

00:42:55,849 --> 00:43:03,380
comma H nilda type that's like a tuple

00:42:59,080 --> 00:43:05,990
which represents an int history just an

00:43:03,380 --> 00:43:08,089
industry that's it then comes h0 two

00:43:05,990 --> 00:43:09,980
elements here and we can add some

00:43:08,089 --> 00:43:13,070
syntactic sugar and then you can write

00:43:09,980 --> 00:43:17,030
types like int colon colon string colon

00:43:13,070 --> 00:43:21,680
colon h9 and the definition is recursive

00:43:17,030 --> 00:43:24,050
so the tail here t is an H list so we

00:43:21,680 --> 00:43:28,640
can arbitrarily nest them for recursion

00:43:24,050 --> 00:43:32,030
and this is the shape that's really all

00:43:28,640 --> 00:43:36,680
you need to implement a support 4-h

00:43:32,030 --> 00:43:39,050
lists in toy slick so we can ignore the

00:43:36,680 --> 00:43:40,820
actual implementation up here there's if

00:43:39,050 --> 00:43:43,790
there's a superclass that does most of

00:43:40,820 --> 00:43:46,730
the work the rest is straightforward

00:43:43,790 --> 00:43:51,050
what we really care about is the types

00:43:46,730 --> 00:43:53,780
so to represent this we need we need to

00:43:51,050 --> 00:43:57,140
be able to get a shape for every kind of

00:43:53,780 --> 00:43:59,540
H list so we follow the same recursion

00:43:57,140 --> 00:44:03,080
scheme as the H list itself we first

00:43:59,540 --> 00:44:06,560
define a shape for H no that's called H

00:44:03,080 --> 00:44:10,119
nail shape and it gives us an ageless

00:44:06,560 --> 00:44:12,530
che purchase yeah it's a subclass of

00:44:10,119 --> 00:44:15,500
shape where are we extend

00:44:12,530 --> 00:44:19,520
yeah so this this extends shape off of

00:44:15,500 --> 00:44:23,330
em in the end so you get a shape of H no

00:44:19,520 --> 00:44:25,100
type which packs and unpacks 2h0 type

00:44:23,330 --> 00:44:28,160
it's just an empty list the types are

00:44:25,100 --> 00:44:30,520
always the same and then you need an H

00:44:28,160 --> 00:44:34,580
cone shape which represents the

00:44:30,520 --> 00:44:38,990
concatenation case so H cone shape gives

00:44:34,580 --> 00:44:42,380
you an ageless shape for every type M 1

00:44:38,990 --> 00:44:47,660
colon colon m2 provided that you have a

00:44:42,380 --> 00:44:51,350
shape for the element type for m1 and an

00:44:47,660 --> 00:44:53,420
ageless shape for m2 we don't really

00:44:51,350 --> 00:44:56,030
need to say H lyst shape here but it

00:44:53,420 --> 00:44:59,450
makes the lookup faster because there's

00:44:56,030 --> 00:45:02,900
nothing else it could be and that's it

00:44:59,450 --> 00:45:06,590
already so with these few lines of code

00:45:02,900 --> 00:45:09,080
we can now use H list wherever we want

00:45:06,590 --> 00:45:11,150
in slick wherever we could use regular

00:45:09,080 --> 00:45:13,910
tuples or nested tuples or other

00:45:11,150 --> 00:45:18,110
structures so we have a table of an H

00:45:13,910 --> 00:45:22,340
list type and we use H list here for our

00:45:18,110 --> 00:45:23,720
star projection and use H list here and

00:45:22,340 --> 00:45:25,850
of course when you run this thing the

00:45:23,720 --> 00:45:31,970
result you get is also an H list so it

00:45:25,850 --> 00:45:35,120
works everywhere I've compiled the lists

00:45:31,970 --> 00:45:37,280
the links for you again so there's the

00:45:35,120 --> 00:45:39,530
link to slick and two toys lick of

00:45:37,280 --> 00:45:43,040
course and we'll publish the slides as

00:45:39,530 --> 00:45:45,320
usual I think I'm out of time by one

00:45:43,040 --> 00:45:47,480
minute but maybe we can still take some

00:45:45,320 --> 00:45:50,740
questions if you have some otherwise

00:45:47,480 --> 00:45:50,740

YouTube URL: https://www.youtube.com/watch?v=_QyRHlhVNQ4


