Title: Keynote: Scala's Road Ahead by Martin Odersky
Publication date: 2016-07-04
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract: 
After a fairly quiet 2015, things are heating up this year. To name
just three major developments among many: A major new release, Scala
2.12, is about to be completed. The Scala Center provides a new focus
point for community collaboration. And there's a new experimental
platform, dotty, which lets us prototype designs for the next
generation of the language.

In my talk I'd like to look a bit further ahead and focus on where I
see Scala in the next 5 years, touching topics like: What is Scala's
unique identity as a programming language? How should it evolve? What
exciting new technologies are on the horizon?
Captions: 
	00:00:04,590 --> 00:00:10,230
so my talk is about Scylla of the road

00:00:07,859 --> 00:00:12,719
ahead and that's what I'm gonna talk

00:00:10,230 --> 00:00:17,070
about it's great to be back in Berlin

00:00:12,719 --> 00:00:18,960
after I think a two-year hiatus I can

00:00:17,070 --> 00:00:20,310
tell exactly because we're always coming

00:00:18,960 --> 00:00:22,279
to Berlin when there's a World

00:00:20,310 --> 00:00:24,539
Championship or European Championship

00:00:22,279 --> 00:00:26,759
last time I gave the talk it was

00:00:24,539 --> 00:00:29,279
actually right before the first game of

00:00:26,759 --> 00:00:30,900
the of the German team first game in the

00:00:29,279 --> 00:00:32,810
World Championship and we know how that

00:00:30,900 --> 00:00:35,579
ended so that was a very nice experience

00:00:32,810 --> 00:00:37,380
we all watched the first game at the at

00:00:35,579 --> 00:00:38,670
the reception afterwards so I don't

00:00:37,380 --> 00:00:41,760
think there's a German games I'm not

00:00:38,670 --> 00:00:44,580
competing with anyone today so I have

00:00:41,760 --> 00:00:45,810
everything for the whole stage for me

00:00:44,580 --> 00:00:49,050
thank you for that

00:00:45,810 --> 00:00:52,260
so Scala the road ahead so I'm gonna

00:00:49,050 --> 00:00:56,160
talk a little bit about what's coming up

00:00:52,260 --> 00:00:58,980
for Scala first what has been the recent

00:00:56,160 --> 00:01:03,890
past has been I think more on the quiet

00:00:58,980 --> 00:01:06,119
side there was steady movement of

00:01:03,890 --> 00:01:09,060
essentially all the indicators were

00:01:06,119 --> 00:01:11,340
going upwards quite steadily so on the

00:01:09,060 --> 00:01:13,920
left-hand side you see the jobs of

00:01:11,340 --> 00:01:16,200
indeed calm and people are always

00:01:13,920 --> 00:01:17,999
laughing to say well if you look at Java

00:01:16,200 --> 00:01:20,399
jobs and scholar jobs in Scala it

00:01:17,999 --> 00:01:22,859
doesn't even get off the line so now I'm

00:01:20,399 --> 00:01:25,950
very glad to say it goes a little bit of

00:01:22,859 --> 00:01:29,219
the line so Java scholar jobs are now

00:01:25,950 --> 00:01:31,499
about 5% of Java jobs in in that index

00:01:29,219 --> 00:01:33,569
and I think that's of course not the

00:01:31,499 --> 00:01:35,579
same thing as Java but it is respectable

00:01:33,569 --> 00:01:38,069
the other nice trend is Google Trends

00:01:35,579 --> 00:01:40,109
got a tutorial which is quite

00:01:38,069 --> 00:01:43,409
interesting for its smoothness so it

00:01:40,109 --> 00:01:45,659
just goes very smoothly ups without big

00:01:43,409 --> 00:01:47,939
excitements but steady progress and I

00:01:45,659 --> 00:01:49,859
leave it up to you to just relate that

00:01:47,939 --> 00:01:52,079
to some of the graphs of let's say other

00:01:49,859 --> 00:01:53,249
technologies of languages and there you

00:01:52,079 --> 00:01:55,679
see that this is actually quite

00:01:53,249 --> 00:01:57,630
untypical that normally it goes up and

00:01:55,679 --> 00:02:00,420
then it goes down again but first card

00:01:57,630 --> 00:02:02,670
sort of I would say we're probably

00:02:00,420 --> 00:02:04,380
beyond the hype and in the in the face

00:02:02,670 --> 00:02:07,649
of essentially steady adoption and

00:02:04,380 --> 00:02:11,700
that's very nice to see so 2016 things

00:02:07,649 --> 00:02:13,470
will heat up again and so what is what

00:02:11,700 --> 00:02:16,050
is in store and what has already

00:02:13,470 --> 00:02:18,750
happened are many

00:02:16,050 --> 00:02:21,750
many interesting things the first one is

00:02:18,750 --> 00:02:22,710
the Scala center the new release of

00:02:21,750 --> 00:02:25,530
SCARA 212

00:02:22,710 --> 00:02:28,980
the next major scale release we are

00:02:25,530 --> 00:02:31,440
starting to rethink our libraries there

00:02:28,980 --> 00:02:34,890
have been exciting new developments in

00:02:31,440 --> 00:02:36,870
the target platforms and finally last

00:02:34,890 --> 00:02:39,540
but not least there has been a lot of

00:02:36,870 --> 00:02:42,240
new work on dot the foundation of Scala

00:02:39,540 --> 00:02:44,130
and Dottie the experimental compiler to

00:02:42,240 --> 00:02:47,580
implement that foundation so I'm going

00:02:44,130 --> 00:02:50,400
to talk about all of that in in the next

00:02:47,580 --> 00:02:52,080
half an hour of 45 minutes first Gera

00:02:50,400 --> 00:02:54,150
Center I'm not going to talk about much

00:02:52,080 --> 00:02:57,570
because Heather actually will give the

00:02:54,150 --> 00:03:00,780
keynote tomorrow and will explain you

00:02:57,570 --> 00:03:03,900
all of that in great detail just one

00:03:00,780 --> 00:03:06,030
word it is Gala Center's mission is to

00:03:03,900 --> 00:03:08,280
undertake projects that benefit all of

00:03:06,030 --> 00:03:11,160
the scholar community so it's vendor

00:03:08,280 --> 00:03:13,470
neutral it has industrial support from a

00:03:11,160 --> 00:03:16,230
number of sponsors sponsor companies

00:03:13,470 --> 00:03:20,489
including light bank Goldman Sachs nitro

00:03:16,230 --> 00:03:22,170
IBM 47Â° where eyes on tap odd and we get

00:03:20,489 --> 00:03:24,510
new interest for interest for more

00:03:22,170 --> 00:03:26,970
companies essentially every week and

00:03:24,510 --> 00:03:30,120
every month now so I expect that list to

00:03:26,970 --> 00:03:31,860
grow until the end of the year the other

00:03:30,120 --> 00:03:34,350
big mission of the Scala Center is the

00:03:31,860 --> 00:03:36,390
MOOCs massive open online courses which

00:03:34,350 --> 00:03:39,870
you might have noticed that they have

00:03:36,390 --> 00:03:41,580
restarted in Concours era and despite

00:03:39,870 --> 00:03:43,290
the recent fright that know they are

00:03:41,580 --> 00:03:46,800
still free so you can still do the

00:03:43,290 --> 00:03:48,480
courses without paying for them and you

00:03:46,800 --> 00:03:49,980
can also get the assignments graded

00:03:48,480 --> 00:03:51,959
without paying for them but of course if

00:03:49,980 --> 00:03:55,530
you want to enroll and get a certificate

00:03:51,959 --> 00:03:57,930
of to specialization then that there's a

00:03:55,530 --> 00:04:00,450
fee to pay and the Scala center gets as

00:03:57,930 --> 00:04:02,340
far as I know about half of the revenue

00:04:00,450 --> 00:04:04,560
that essentially there's a revenue split

00:04:02,340 --> 00:04:06,870
between cause I ran to Scala center so

00:04:04,560 --> 00:04:09,750
by enrolling in these courses you also

00:04:06,870 --> 00:04:12,900
do your bit to actually support the

00:04:09,750 --> 00:04:15,480
scholar center here it's got a 212

00:04:12,900 --> 00:04:17,700
that's the release that's right

00:04:15,480 --> 00:04:21,570
literally around the corner I think the

00:04:17,700 --> 00:04:23,730
the gala 212 team is very close to do

00:04:21,570 --> 00:04:25,590
the last milestone cut the first release

00:04:23,730 --> 00:04:29,850
candidate

00:04:25,590 --> 00:04:32,910
the main new things in Scala 212 is that

00:04:29,850 --> 00:04:35,490
it is optimized for Java 8

00:04:32,910 --> 00:04:37,740
so SCARA 211 could already work you can

00:04:35,490 --> 00:04:40,950
run it on Java 8 of course and I think

00:04:37,740 --> 00:04:43,770
many of you do but it didn't really take

00:04:40,950 --> 00:04:46,500
advantage of the new features in Java 8

00:04:43,770 --> 00:04:47,970
which is in particular the lambdas so

00:04:46,500 --> 00:04:50,910
essentially the native support for

00:04:47,970 --> 00:04:54,120
first-class functions and the default

00:04:50,910 --> 00:04:55,710
methods so the lambdas of course are

00:04:54,120 --> 00:04:57,930
very good fit for this kind of functions

00:04:55,710 --> 00:05:00,330
and default methods are very good fit

00:04:57,930 --> 00:05:02,220
for Scala straits because they give you

00:05:00,330 --> 00:05:04,680
a much more lightweight encoding of

00:05:02,220 --> 00:05:06,780
Scala strengths so Scala to 12 is the

00:05:04,680 --> 00:05:10,200
release that actually makes use of these

00:05:06,780 --> 00:05:12,780
two things and by consequence it will

00:05:10,200 --> 00:05:16,230
require Java 8 because it can't run on

00:05:12,780 --> 00:05:19,650
an older Java version so that means that

00:05:16,230 --> 00:05:22,860
to make to use to 2 to 12 you need Java

00:05:19,650 --> 00:05:27,090
8 and I don't know how many people here

00:05:22,860 --> 00:05:29,490
are already on Java 8 the majority I

00:05:27,090 --> 00:05:32,160
think but I think there's the size of a

00:05:29,490 --> 00:05:34,970
minority that's not yet there and we

00:05:32,160 --> 00:05:37,740
know that it often takes longer and

00:05:34,970 --> 00:05:40,530
there's a long tail so for that reason

00:05:37,740 --> 00:05:43,740
there's a longer than usual maintenance

00:05:40,530 --> 00:05:46,830
period for Scala 211 so 211 will be

00:05:43,740 --> 00:05:49,050
maintained longer to make a good to help

00:05:46,830 --> 00:05:52,169
those people who actually cannot yet

00:05:49,050 --> 00:05:55,380
move to Java 8 that also meant that for

00:05:52,169 --> 00:05:57,630
the language feature releases the

00:05:55,380 --> 00:05:59,460
current trend was to be very very

00:05:57,630 --> 00:06:02,610
conservative because we didn't want to

00:05:59,460 --> 00:06:05,340
12 and to 11 to diverge too much because

00:06:02,610 --> 00:06:07,590
we knew that essentially we had to kind

00:06:05,340 --> 00:06:09,990
of team knew that they had to maintain

00:06:07,590 --> 00:06:12,330
them in in lockstep for for quite a

00:06:09,990 --> 00:06:14,340
while so that's why maybe to 12

00:06:12,330 --> 00:06:16,919
except for this really great support for

00:06:14,340 --> 00:06:20,390
Java 8 is or rather on the conservative

00:06:16,919 --> 00:06:23,520
side on what concerns new features

00:06:20,390 --> 00:06:26,160
that's said there's still 33 features in

00:06:23,520 --> 00:06:29,820
the release notes so you'll find it all

00:06:26,160 --> 00:06:32,130
on github and the Scala team has done an

00:06:29,820 --> 00:06:33,930
excellent job in actually stabilizing

00:06:32,130 --> 00:06:36,450
the whole code base and make really I

00:06:33,930 --> 00:06:39,270
what we all hope is a rock-solid release

00:06:36,450 --> 00:06:41,550
for 212 so here you see the top

00:06:39,270 --> 00:06:43,830
top committers Lucas Lee it's Jason's

00:06:41,550 --> 00:06:46,230
elk and other mores and there were many

00:06:43,830 --> 00:06:48,720
many others and we are also very happy

00:06:46,230 --> 00:06:50,790
to say that many of these commuters are

00:06:48,720 --> 00:06:53,550
coming from the community so they're not

00:06:50,790 --> 00:06:57,180
like the employees they really

00:06:53,550 --> 00:07:00,350
contributors from from epfl from outside

00:06:57,180 --> 00:07:04,110
from third parties and so on

00:07:00,350 --> 00:07:06,240
finally I can say that programming in

00:07:04,110 --> 00:07:07,890
Scala third edition is out that took a

00:07:06,240 --> 00:07:10,080
long time there was a long time in the

00:07:07,890 --> 00:07:14,100
making the last edition we covered I

00:07:10,080 --> 00:07:17,250
think was 210 so that death Edition now

00:07:14,100 --> 00:07:19,200
actually contains the latest parts that

00:07:17,250 --> 00:07:21,810
actually covered the 212 bits and

00:07:19,200 --> 00:07:25,260
there's a book signing on Thursday

00:07:21,810 --> 00:07:27,270
during lunch 1222 1320 at the Lightman

00:07:25,260 --> 00:07:31,110
booth where me and Bill - who's also

00:07:27,270 --> 00:07:33,240
here will sign your programming in Scala

00:07:31,110 --> 00:07:37,020
third edition books if you give them to

00:07:33,240 --> 00:07:39,690
us so those are sort of these things

00:07:37,020 --> 00:07:43,770
that have are almost already out there

00:07:39,690 --> 00:07:45,390
so immediate so I think now it's a time

00:07:43,770 --> 00:07:46,770
to think about well what will come

00:07:45,390 --> 00:07:50,580
afterwards what are the next steps

00:07:46,770 --> 00:07:53,580
beyond 212 the next step beyond 212 is

00:07:50,580 --> 00:07:56,610
213 of course and for that language

00:07:53,580 --> 00:07:58,950
version we decided to focus more on the

00:07:56,610 --> 00:08:01,280
libraries so we're 212 was essentially a

00:07:58,950 --> 00:08:04,590
version that was more the compiler

00:08:01,280 --> 00:08:07,620
compiler internals compiler optimization

00:08:04,590 --> 00:08:09,420
compiler code generation parts 213 will

00:08:07,620 --> 00:08:12,810
be more user visible because it will be

00:08:09,420 --> 00:08:15,270
part of will focus on the libraries in

00:08:12,810 --> 00:08:18,570
particular we plan to have a second look

00:08:15,270 --> 00:08:21,380
at the scholar collections to make them

00:08:18,570 --> 00:08:24,090
where we can even more simple to use

00:08:21,380 --> 00:08:27,030
where we can bring them more in line

00:08:24,090 --> 00:08:29,400
with spark usage maybe by making it

00:08:27,030 --> 00:08:33,120
easier and more robust to use lazy

00:08:29,400 --> 00:08:35,010
collections and to maybe add some of the

00:08:33,120 --> 00:08:36,780
features that you find in spark and that

00:08:35,010 --> 00:08:39,120
you don't find in standard scholar

00:08:36,780 --> 00:08:40,980
collections like the nice support for

00:08:39,120 --> 00:08:43,800
pears collections over pears and terry

00:08:40,980 --> 00:08:46,740
VAR d DS and things like that that said

00:08:43,800 --> 00:08:49,050
we definitely want to remain largely

00:08:46,740 --> 00:08:52,500
backwards compatible so for a normal

00:08:49,050 --> 00:08:54,820
user of collections like if you don't do

00:08:52,500 --> 00:08:56,830
fancy stuffs like implement your own

00:08:54,820 --> 00:08:58,810
collections frameworks and things like

00:08:56,830 --> 00:09:01,000
that nothing should change so it should

00:08:58,810 --> 00:09:03,220
just essentially PPP become a little bit

00:09:01,000 --> 00:09:05,260
more streamlined and simplified the

00:09:03,220 --> 00:09:07,810
current status is that we have some

00:09:05,260 --> 00:09:10,840
straumann proposals under study that

00:09:07,810 --> 00:09:13,030
means what we tried to do was to say

00:09:10,840 --> 00:09:15,040
well let's study the architecture in

00:09:13,030 --> 00:09:17,380
something that can be done in reasonable

00:09:15,040 --> 00:09:19,780
time in space so currently the line

00:09:17,380 --> 00:09:22,330
limit of this drum and proposals is 500

00:09:19,780 --> 00:09:24,280
lines so I want to essentially capture

00:09:22,330 --> 00:09:25,870
the essence of what we try to achieve in

00:09:24,280 --> 00:09:27,940
something like 500 lines and have

00:09:25,870 --> 00:09:30,070
several of them so that we can compare

00:09:27,940 --> 00:09:31,690
them and essentially then decide what a

00:09:30,070 --> 00:09:37,060
good architecture for going forward

00:09:31,690 --> 00:09:40,260
would be the other thing we are

00:09:37,060 --> 00:09:43,780
considering and thinking about is to

00:09:40,260 --> 00:09:45,640
read modularize a little bit the scholar

00:09:43,780 --> 00:09:47,920
standard library the scholars a tenant

00:09:45,640 --> 00:09:50,830
library is something that has grown

00:09:47,920 --> 00:09:52,420
historically and the way it has grown

00:09:50,830 --> 00:09:54,160
historically that essentially there was

00:09:52,420 --> 00:09:56,260
this explosion phase in the very very

00:09:54,160 --> 00:09:58,030
early years probably before most of you

00:09:56,260 --> 00:10:00,910
got involved in SCADA that was like two

00:09:58,030 --> 00:10:02,920
thousand five six seven around when

00:10:00,910 --> 00:10:05,200
essentially we took every module that

00:10:02,920 --> 00:10:06,880
somebody would call would contribute to

00:10:05,200 --> 00:10:08,620
say yeah great we need that we need that

00:10:06,880 --> 00:10:11,500
we have nothing so let's just put it all

00:10:08,620 --> 00:10:13,000
in and then I guess nobody realized that

00:10:11,500 --> 00:10:14,800
these things would stay with us forever

00:10:13,000 --> 00:10:16,720
or at the time we didn't even realize

00:10:14,800 --> 00:10:19,120
that the language would stay with us for

00:10:16,720 --> 00:10:23,730
that long so you don't you don't really

00:10:19,120 --> 00:10:26,200
plan ahead for these things so that's

00:10:23,730 --> 00:10:28,900
inevitable that's just how things grew

00:10:26,200 --> 00:10:30,840
but the question is can we do now get

00:10:28,900 --> 00:10:35,770
some improvements by maybe better

00:10:30,840 --> 00:10:37,720
modernization can we it's still the core

00:10:35,770 --> 00:10:39,250
of this library where we say well we're

00:10:37,720 --> 00:10:41,560
really happy with that and that should

00:10:39,250 --> 00:10:44,560
be sort of part of ares gallico Pyrus

00:10:41,560 --> 00:10:46,870
toolbox and maybe have modules for parts

00:10:44,560 --> 00:10:49,320
that maybe are more optional and that

00:10:46,870 --> 00:10:53,530
wouldn't be part of what what everyone

00:10:49,320 --> 00:10:56,110
wants to use and in particular one idea

00:10:53,530 --> 00:10:58,390
that has been floated is to actually

00:10:56,110 --> 00:11:00,460
have a scholar core library which is

00:10:58,390 --> 00:11:02,470
sort of what everybody agrees and then

00:11:00,460 --> 00:11:04,510
have to something which is probably much

00:11:02,470 --> 00:11:06,970
larger than the current library

00:11:04,510 --> 00:11:09,660
the Scala platform Escada batteries

00:11:06,970 --> 00:11:12,430
included that it said she would have

00:11:09,660 --> 00:11:14,710
state-of-the-art solutions for a lot of

00:11:12,430 --> 00:11:17,530
the application areas that people want

00:11:14,710 --> 00:11:19,900
to use modules in I think that would be

00:11:17,530 --> 00:11:21,790
for personally I think that would be a

00:11:19,900 --> 00:11:24,190
very very good development but it's

00:11:21,790 --> 00:11:26,770
something that I can't do myself and

00:11:24,190 --> 00:11:29,350
essentially the core teams can't do

00:11:26,770 --> 00:11:31,960
themselves so if that should happen then

00:11:29,350 --> 00:11:34,060
it would evolve you the community what

00:11:31,960 --> 00:11:35,890
they would need to would need a lot a

00:11:34,060 --> 00:11:37,900
lot of people to get involved and say

00:11:35,890 --> 00:11:40,140
well let's get together and make this

00:11:37,900 --> 00:11:43,540
happen so that's something that

00:11:40,140 --> 00:11:45,940
hopefully we can plant the seeds but

00:11:43,540 --> 00:11:49,540
then to a large degree we will have to

00:11:45,940 --> 00:11:52,830
rely on you new platforms

00:11:49,540 --> 00:11:55,630
so there's college is zero six nine out

00:11:52,830 --> 00:11:58,330
it's a steady progress of this garage is

00:11:55,630 --> 00:12:01,240
releases in the latest one we have

00:11:58,330 --> 00:12:03,850
native anonymous classes support for

00:12:01,240 --> 00:12:07,660
tuples j-unit support for j units and

00:12:03,850 --> 00:12:09,640
much faster cogeneration and the other

00:12:07,660 --> 00:12:12,730
thing that sort of dark horse in the

00:12:09,640 --> 00:12:15,640
platform is scholar native which is a

00:12:12,730 --> 00:12:17,590
very very young project still but it

00:12:15,640 --> 00:12:19,990
made that the day it was announced that

00:12:17,590 --> 00:12:22,900
the holidays New York I think it make

00:12:19,990 --> 00:12:25,540
the top of the hacker news list and

00:12:22,900 --> 00:12:28,030
stayed there for a while so obviously we

00:12:25,540 --> 00:12:30,130
were quite overwhelmed by enormous

00:12:28,030 --> 00:12:31,900
interest so I think nobody could have

00:12:30,130 --> 00:12:34,480
foreseen that that the interest would be

00:12:31,900 --> 00:12:36,340
so strong and I think now the the

00:12:34,480 --> 00:12:38,980
question is just how to follow up on

00:12:36,340 --> 00:12:41,050
that and really get something out but I

00:12:38,980 --> 00:12:44,620
think it's it's very very promising and

00:12:41,050 --> 00:12:47,260
we looking forward to what the current

00:12:44,620 --> 00:12:50,890
status is and again then is Charlene he

00:12:47,260 --> 00:12:52,840
will tell you more about this later on

00:12:50,890 --> 00:12:54,910
in the conference I should say also

00:12:52,840 --> 00:12:56,950
force garage is of course Sebastian

00:12:54,910 --> 00:12:58,660
Duran he will also give you the latest

00:12:56,950 --> 00:13:01,270
that I think he will give you at the

00:12:58,660 --> 00:13:04,120
conference sort of the inside story how

00:13:01,270 --> 00:13:06,630
this college is compiler works

00:13:04,120 --> 00:13:09,760
internally to get the very very

00:13:06,630 --> 00:13:12,010
impressive speed speed that you get out

00:13:09,760 --> 00:13:14,230
of Scala on on the draya's platform so

00:13:12,010 --> 00:13:16,270
what essentially the secret sauce that

00:13:14,230 --> 00:13:18,010
the compiler uses to make it all happen

00:13:16,270 --> 00:13:20,170
so that's the two talks

00:13:18,010 --> 00:13:24,250
about the platform that you will get

00:13:20,170 --> 00:13:24,880
later in the conference and then there's

00:13:24,250 --> 00:13:29,260
the dot

00:13:24,880 --> 00:13:32,320
so the dot the dot is the foundation of

00:13:29,260 --> 00:13:36,160
Scala it's an acronym for dependent

00:13:32,320 --> 00:13:38,080
object types it's a little calculus so

00:13:36,160 --> 00:13:40,510
that means sort of a mini language a

00:13:38,080 --> 00:13:43,300
tiny language that can sort of fit on a

00:13:40,510 --> 00:13:45,790
page in the definition and the reason

00:13:43,300 --> 00:13:48,850
for doing that is that it should be

00:13:45,790 --> 00:13:51,040
small enough that we can make formal

00:13:48,850 --> 00:13:53,350
statements about what it is what

00:13:51,040 --> 00:13:55,510
properties it has and that we can prove

00:13:53,350 --> 00:13:57,070
these statements and the current gold

00:13:55,510 --> 00:13:59,200
standard improving these statements is

00:13:57,070 --> 00:14:01,600
actually prove them mechanically that

00:13:59,200 --> 00:14:03,940
means the proof itself is a program that

00:14:01,600 --> 00:14:06,490
gets checked by a computer the proof

00:14:03,940 --> 00:14:08,560
happens to be written in a in Cocke

00:14:06,490 --> 00:14:10,630
which is essentially an automatic proof

00:14:08,560 --> 00:14:12,730
system that essentially you want to

00:14:10,630 --> 00:14:15,220
essentially get to a point where you can

00:14:12,730 --> 00:14:19,600
establish these properties and be 100%

00:14:15,220 --> 00:14:22,240
sure that they hold the other reason for

00:14:19,600 --> 00:14:24,400
picking a new calculus is not something

00:14:22,240 --> 00:14:26,830
standard like lambda calculus is that we

00:14:24,400 --> 00:14:28,510
want to encourage much of the rest of

00:14:26,830 --> 00:14:30,340
the language in it we want to be sure

00:14:28,510 --> 00:14:32,860
that what we prove here actually relates

00:14:30,340 --> 00:14:34,000
to Scala the language and not

00:14:32,860 --> 00:14:35,710
essentially to something that's

00:14:34,000 --> 00:14:38,020
completely different from it so that

00:14:35,710 --> 00:14:40,960
calculus was chosen to be sort of an

00:14:38,020 --> 00:14:44,800
essence of what what Scala is and what

00:14:40,960 --> 00:14:48,700
they were T what the core of Scala is so

00:14:44,800 --> 00:14:50,830
that thing concludes an eight year

00:14:48,700 --> 00:14:53,080
effort so we have been trying to get

00:14:50,830 --> 00:14:55,720
there for eight years where essentially

00:14:53,080 --> 00:14:57,820
we were that she studying this calculi

00:14:55,720 --> 00:15:00,990
and trying to prove the core theorem

00:14:57,820 --> 00:15:03,640
which is type soundness and that took us

00:15:00,990 --> 00:15:06,130
like I said an enormous amount of time

00:15:03,640 --> 00:15:08,140
and we're very very glad that we finally

00:15:06,130 --> 00:15:10,750
succeeded and we've learned a lot over

00:15:08,140 --> 00:15:12,490
those eight years so it wasn't that it

00:15:10,750 --> 00:15:14,650
was wasted time but their words was

00:15:12,490 --> 00:15:17,590
really a lot of techniques in a lot of

00:15:14,650 --> 00:15:19,660
concepts and ideas to learn so now that

00:15:17,590 --> 00:15:22,150
it's done it opens the door to do

00:15:19,660 --> 00:15:24,310
language work with which with much

00:15:22,150 --> 00:15:26,050
better confidence than before where

00:15:24,310 --> 00:15:28,030
before we essentially we're unsure

00:15:26,050 --> 00:15:29,230
whether this thing is sound this thing

00:15:28,030 --> 00:15:30,700
is correct now we actually have

00:15:29,230 --> 00:15:31,230
something that we can put these things

00:15:30,700 --> 00:15:33,510
to the

00:15:31,230 --> 00:15:36,750
so this should help us a lot going

00:15:33,510 --> 00:15:39,120
forward so I just wanted to give you a

00:15:36,750 --> 00:15:41,700
quick rundown of what this dot thing is

00:15:39,120 --> 00:15:45,270
just just to give you an idea what these

00:15:41,700 --> 00:15:49,740
academics are up to in their ivory tower

00:15:45,270 --> 00:15:51,930
so the if you translate it to scholar

00:15:49,740 --> 00:15:54,660
notation the actual publication uses a

00:15:51,930 --> 00:15:56,730
lot more Greek than that but since it's

00:15:54,660 --> 00:15:58,590
a scholar notation the language by dot

00:15:56,730 --> 00:16:00,870
is essentially this thing you have

00:15:58,590 --> 00:16:02,910
values so you have essentially these

00:16:00,870 --> 00:16:05,250
anonymous functions those are values and

00:16:02,910 --> 00:16:06,810
then you have these anonymous objects so

00:16:05,250 --> 00:16:08,730
that thing is a cell type that thing is

00:16:06,810 --> 00:16:10,650
some definitions that are values so

00:16:08,730 --> 00:16:12,620
functions and values okay that looks

00:16:10,650 --> 00:16:15,450
pretty pretty much like Scarah

00:16:12,620 --> 00:16:17,460
definitions are just parameterless

00:16:15,450 --> 00:16:19,190
methods we don't need more because the

00:16:17,460 --> 00:16:22,110
rest you can do with lambdas right and

00:16:19,190 --> 00:16:24,300
type definitions so type definitions

00:16:22,110 --> 00:16:26,670
sort of are an extract of what we would

00:16:24,300 --> 00:16:29,700
use to also define classes and traits

00:16:26,670 --> 00:16:31,500
and then the terms are essentially a

00:16:29,700 --> 00:16:32,730
value like these things are terms so

00:16:31,500 --> 00:16:34,680
that's the expressions you can write

00:16:32,730 --> 00:16:37,620
variables are expressions function

00:16:34,680 --> 00:16:39,330
application is an expression the dots or

00:16:37,620 --> 00:16:41,670
selection is an expression and then you

00:16:39,330 --> 00:16:43,620
have blocks and local definitions and

00:16:41,670 --> 00:16:46,800
that's it so you could say well that's

00:16:43,620 --> 00:16:48,750
really looks looks pretty small and but

00:16:46,800 --> 00:16:51,330
it's also something which turns out that

00:16:48,750 --> 00:16:55,320
we can actually encode the essential

00:16:51,330 --> 00:16:58,110
concepts of Scala in it the types of dot

00:16:55,320 --> 00:17:00,780
so you also have to do them so we have

00:16:58,110 --> 00:17:05,010
the familiar any and nothing we have

00:17:00,780 --> 00:17:09,350
type selection we have function types so

00:17:05,010 --> 00:17:11,730
method we have then essentially

00:17:09,350 --> 00:17:13,710
structural types which is just a single

00:17:11,730 --> 00:17:16,980
definition or a single type definition

00:17:13,710 --> 00:17:20,520
and we have intersection oops that used

00:17:16,980 --> 00:17:22,680
to be called width so I am getting to

00:17:20,520 --> 00:17:25,020
that and finally we have recursion which

00:17:22,680 --> 00:17:27,780
is not a primitive in the language which

00:17:25,020 --> 00:17:30,240
is sort of indirectly you can define

00:17:27,780 --> 00:17:33,780
that by using these refinement types so

00:17:30,240 --> 00:17:36,210
that's what the formal system is about

00:17:33,780 --> 00:17:39,450
and what we have what have we shown

00:17:36,210 --> 00:17:42,560
about it well simply this that we say

00:17:39,450 --> 00:17:46,160
well if a term an expression has a type

00:17:42,560 --> 00:17:48,140
and the evaluation of T by the computer

00:17:46,160 --> 00:17:51,650
terminates so you get a result and the

00:17:48,140 --> 00:17:55,070
result will be a value of the same type

00:17:51,650 --> 00:17:57,230
T so a value means it will be something

00:17:55,070 --> 00:17:59,360
that is actually a useable result one of

00:17:57,230 --> 00:18:01,070
these things here it won't be some some

00:17:59,360 --> 00:18:02,750
weird things that like a crash or

00:18:01,070 --> 00:18:04,940
something like that and furthermore it

00:18:02,750 --> 00:18:06,290
tells you that types don't lie that

00:18:04,940 --> 00:18:09,260
essentially the final result of the

00:18:06,290 --> 00:18:11,930
program has the type that the the type

00:18:09,260 --> 00:18:14,570
checker and the compiler has computed

00:18:11,930 --> 00:18:17,900
for this and that result to us ideas to

00:18:14,570 --> 00:18:19,070
establish with many many iterations so

00:18:17,900 --> 00:18:21,740
why is this important

00:18:19,070 --> 00:18:24,470
well I think it's important because it

00:18:21,740 --> 00:18:26,900
gives us a technique to reason about the

00:18:24,470 --> 00:18:29,780
correctness of other language features

00:18:26,900 --> 00:18:33,890
and some of the examples we've already

00:18:29,780 --> 00:18:35,570
seen for instance we could see that one

00:18:33,890 --> 00:18:38,630
of the core features of scalar

00:18:35,570 --> 00:18:39,500
projection the hash thing is in general

00:18:38,630 --> 00:18:42,170
unsound

00:18:39,500 --> 00:18:44,050
so but it's actually not that much of a

00:18:42,170 --> 00:18:47,180
core feature it's used in some of the

00:18:44,050 --> 00:18:49,220
essentially computations that lift

00:18:47,180 --> 00:18:50,660
computation to the type level but

00:18:49,220 --> 00:18:53,000
fortunately there are other ways to do

00:18:50,660 --> 00:18:55,280
that so it showed that that this is sort

00:18:53,000 --> 00:18:56,660
of irredeemably unsound and there's

00:18:55,280 --> 00:18:58,070
nothing we can do about it and we should

00:18:56,660 --> 00:18:59,690
drop the feature if you want to have a

00:18:58,070 --> 00:19:02,090
sound language and the fact that

00:18:59,690 --> 00:19:04,400
essentially we knew about the proof

00:19:02,090 --> 00:19:06,410
principles now that we have done and we

00:19:04,400 --> 00:19:08,930
can project this into the language helps

00:19:06,410 --> 00:19:10,790
us a lot by contrast it also gives us

00:19:08,930 --> 00:19:13,640
much more confidence with other things

00:19:10,790 --> 00:19:15,800
that might be much more advanced to say

00:19:13,640 --> 00:19:17,540
well this thing is sound and we know

00:19:15,800 --> 00:19:19,810
that we can do this in good conscience

00:19:17,540 --> 00:19:24,680
confidence so it gives us essentially a

00:19:19,810 --> 00:19:29,030
water fat and a guideline where to where

00:19:24,680 --> 00:19:32,330
to go with with the language design now

00:19:29,030 --> 00:19:35,270
the practical off instantiation of this

00:19:32,330 --> 00:19:37,580
language design is dirty sub dirty comes

00:19:35,270 --> 00:19:41,120
from dot so it's a working name for our

00:19:37,580 --> 00:19:44,390
new Scala compiler that he builds on dot

00:19:41,120 --> 00:19:46,610
in its internal data structures so what

00:19:44,390 --> 00:19:48,380
you've seen in the calculus is very much

00:19:46,610 --> 00:19:50,770
what you would find in the compiler as

00:19:48,380 --> 00:19:56,290
well basically one-to-one in that

00:19:50,770 --> 00:19:58,960
and it actually does this encoding quite

00:19:56,290 --> 00:20:00,850
literally for instance in the scholar

00:19:58,960 --> 00:20:02,770
the language of course you have generics

00:20:00,850 --> 00:20:04,420
you have type parameters type parameters

00:20:02,770 --> 00:20:07,390
are everywhere you have type parameters

00:20:04,420 --> 00:20:08,470
of classes of trades of abstract types

00:20:07,390 --> 00:20:11,560
and things like that

00:20:08,470 --> 00:20:13,810
in dottie most of these type parameters

00:20:11,560 --> 00:20:16,660
get actually expressed as type members

00:20:13,810 --> 00:20:18,040
so essentially the dirty compiler will

00:20:16,660 --> 00:20:20,170
essentially compile out the type

00:20:18,040 --> 00:20:22,750
parameters immediately and replace them

00:20:20,170 --> 00:20:28,060
by the refinements and pipe members that

00:20:22,750 --> 00:20:30,280
you have seen that keeps the foundation

00:20:28,060 --> 00:20:32,560
simple because it turns out that if you

00:20:30,280 --> 00:20:34,600
write a type checker then the hardest

00:20:32,560 --> 00:20:36,250
part is always feature interaction so

00:20:34,600 --> 00:20:38,800
you have essentially many different

00:20:36,250 --> 00:20:40,810
types and then you have operations on

00:20:38,800 --> 00:20:43,030
these types but then how the types work

00:20:40,810 --> 00:20:45,550
together so it's usually pretty simple

00:20:43,030 --> 00:20:47,260
to say operation let's say membership on

00:20:45,550 --> 00:20:48,790
this type should give you that on this

00:20:47,260 --> 00:20:50,620
type should give you that but then you

00:20:48,790 --> 00:20:53,110
say well if what if it's a composition

00:20:50,620 --> 00:20:55,330
of an existential over a type projection

00:20:53,110 --> 00:20:57,940
and it said I don't really know so

00:20:55,330 --> 00:21:00,430
that's that's the main problem so the

00:20:57,940 --> 00:21:03,100
solution the answer to that is to say

00:21:00,430 --> 00:21:05,260
well let's reduce all these things into

00:21:03,100 --> 00:21:07,210
a very very minimal core and then we can

00:21:05,260 --> 00:21:08,980
define these concepts over the minimal

00:21:07,210 --> 00:21:11,230
core and have a much better sure and

00:21:08,980 --> 00:21:14,080
said things are correct and that we

00:21:11,230 --> 00:21:17,430
essentially don't introduce new bugs by

00:21:14,080 --> 00:21:20,230
by in our algorithms and so on

00:21:17,430 --> 00:21:22,960
Doni supports an evolution of the Scala

00:21:20,230 --> 00:21:24,490
programming language first we are sort

00:21:22,960 --> 00:21:26,290
of working I think we have snapshot

00:21:24,490 --> 00:21:29,740
releases now so we're working on a

00:21:26,290 --> 00:21:32,400
Developer Preview and so currently the

00:21:29,740 --> 00:21:34,840
state of Dottie is that it's targeted at

00:21:32,400 --> 00:21:37,210
contributors and experimenters so I

00:21:34,840 --> 00:21:39,700
don't really want to propose you use

00:21:37,210 --> 00:21:42,160
this as a next language for your for

00:21:39,700 --> 00:21:43,750
your application yet but if you want to

00:21:42,160 --> 00:21:46,420
like get involved and say well this is

00:21:43,750 --> 00:21:48,610
cool stuff I want to see what I want to

00:21:46,420 --> 00:21:50,320
have a faster-moving platform where new

00:21:48,610 --> 00:21:51,790
things can be implemented very quickly

00:21:50,320 --> 00:21:55,630
because we don't have half a million

00:21:51,790 --> 00:21:58,090
users yet then Dottie might be for you

00:21:55,630 --> 00:22:00,610
technical data is so it's a new compiler

00:21:58,090 --> 00:22:02,550
it's about a bit more than half the size

00:22:00,610 --> 00:22:04,440
of the current Scala compiler so about

00:22:02,550 --> 00:22:08,730
45,000 lines of

00:22:04,440 --> 00:22:10,290
it's currently about twice faster so

00:22:08,730 --> 00:22:12,360
this is very welcome so it's a much

00:22:10,290 --> 00:22:14,730
faster compiler and I think that should

00:22:12,360 --> 00:22:16,230
improve in significantly in the future

00:22:14,730 --> 00:22:18,270
because right now we have a lot of

00:22:16,230 --> 00:22:20,370
instrumentation code there that we know

00:22:18,270 --> 00:22:22,650
slows things down because right now

00:22:20,370 --> 00:22:24,600
essentially debug ability is much more

00:22:22,650 --> 00:22:26,700
important than raw speed but I think we

00:22:24,600 --> 00:22:30,600
can improve that significantly in the

00:22:26,700 --> 00:22:35,250
future the architecture is you see on

00:22:30,600 --> 00:22:38,160
this diagram here so essentially we have

00:22:35,250 --> 00:22:40,380
the color sources that can now go into

00:22:38,160 --> 00:22:42,750
the different two different front-end

00:22:40,380 --> 00:22:46,260
compilers so here's the old one or the

00:22:42,750 --> 00:22:48,450
current one NSC NAC stands for new Scala

00:22:46,260 --> 00:22:53,790
compiler but it's really the old Scala

00:22:48,450 --> 00:22:57,330
compiler and essentially it takes your

00:22:53,790 --> 00:23:00,840
sources it pickups sorry it types it

00:22:57,330 --> 00:23:02,750
type checks them it produces an ASD

00:23:00,840 --> 00:23:06,060
which is called abstract syntax tree

00:23:02,750 --> 00:23:09,150
then it does some transforms quite a few

00:23:06,060 --> 00:23:11,610
of them about 20 that gives you finally

00:23:09,150 --> 00:23:14,490
an ast a tree that looks pretty much

00:23:11,610 --> 00:23:16,440
like a Java program and then you go into

00:23:14,490 --> 00:23:18,690
a code generator called Gen B code which

00:23:16,440 --> 00:23:21,210
uses Gen ASM standard cogeneration

00:23:18,690 --> 00:23:22,890
framework for java bytecodes and put

00:23:21,210 --> 00:23:25,800
users class files and there's

00:23:22,890 --> 00:23:27,510
essentially a pickled format too for

00:23:25,800 --> 00:23:29,070
essentially separate compilation which

00:23:27,510 --> 00:23:31,320
doesn't really have a name we just say

00:23:29,070 --> 00:23:35,010
it's a pick up these serialized symbol

00:23:31,320 --> 00:23:36,570
tables which you need to do if your

00:23:35,010 --> 00:23:39,630
compiler wants to essentially make sense

00:23:36,570 --> 00:23:41,760
of the program in another compilation

00:23:39,630 --> 00:23:44,520
unit that doesn't get compiled a source

00:23:41,760 --> 00:23:46,740
with it in the totally front end it's

00:23:44,520 --> 00:23:49,800
pretty much the same architecture only

00:23:46,740 --> 00:23:52,620
we have a much richer format called

00:23:49,800 --> 00:23:54,210
tasty typed abstract syntax trees so

00:23:52,620 --> 00:23:55,650
essentially that allows us to

00:23:54,210 --> 00:23:58,440
essentially do whole program

00:23:55,650 --> 00:24:00,900
optimizations because we can see the

00:23:58,440 --> 00:24:02,310
other code in detail not just the

00:24:00,900 --> 00:24:05,730
signatures of the functions but

00:24:02,310 --> 00:24:08,250
everything and so pasty is essentially

00:24:05,730 --> 00:24:10,140
typed ast so the Ice T's you see here

00:24:08,250 --> 00:24:12,330
and then everything gets translated into

00:24:10,140 --> 00:24:14,760
tasty then we have the dotty

00:24:12,330 --> 00:24:17,020
transformations which are a lot more

00:24:14,760 --> 00:24:20,380
about 60 so we essentially

00:24:17,020 --> 00:24:22,030
a lot finer faces but we bunched them so

00:24:20,380 --> 00:24:24,220
essentially a lot of these faces get

00:24:22,030 --> 00:24:25,960
fused into a single traversal so overall

00:24:24,220 --> 00:24:28,660
the transformations are much faster

00:24:25,960 --> 00:24:30,970
because you have to go through it to the

00:24:28,660 --> 00:24:33,430
tree much less often and that's part of

00:24:30,970 --> 00:24:35,530
the reason why the Dottie is currently

00:24:33,430 --> 00:24:37,480
faster and Scala see but and then

00:24:35,530 --> 00:24:39,820
afterwards we go into the same jiggly

00:24:37,480 --> 00:24:44,050
and be called back-end as parents

00:24:39,820 --> 00:24:46,240
colossi so Interop works by essentially

00:24:44,050 --> 00:24:48,250
that the fact that we can reduce the

00:24:46,240 --> 00:24:50,590
particle Pilar can also read the pickled

00:24:48,250 --> 00:24:52,690
information from this galaxy compiler

00:24:50,590 --> 00:24:54,310
but in the reverse currently that does

00:24:52,690 --> 00:24:56,170
not work so essentially you have to

00:24:54,310 --> 00:25:00,280
cross build to make to make it work for

00:24:56,170 --> 00:25:03,280
both things the Scala NEC compiler can

00:25:00,280 --> 00:25:06,910
not make sense yet of tasty the

00:25:03,280 --> 00:25:11,350
intermediate format of data so that's

00:25:06,910 --> 00:25:14,830
the compiler architecture what we want

00:25:11,350 --> 00:25:17,140
to use that for impart essentially is to

00:25:14,830 --> 00:25:20,440
say well can we get write a compiler

00:25:17,140 --> 00:25:22,390
that sort of is more understandable it's

00:25:20,440 --> 00:25:24,340
smaller it's faster so that's of course

00:25:22,390 --> 00:25:26,860
Bertie by itself but also in part it is

00:25:24,340 --> 00:25:29,170
to have a good basis for language

00:25:26,860 --> 00:25:31,390
evolution for evolving the language and

00:25:29,170 --> 00:25:33,430
here my goal has always been is still to

00:25:31,390 --> 00:25:36,310
make Scala the best programming language

00:25:33,430 --> 00:25:38,920
I know how to make of course there's no

00:25:36,310 --> 00:25:41,880
agreement what is best so different

00:25:38,920 --> 00:25:44,950
people have different tastes and

00:25:41,880 --> 00:25:47,740
requirements so all we can really do is

00:25:44,950 --> 00:25:50,320
try to find a local optimum so to say

00:25:47,740 --> 00:25:51,970
well if what you're after is in this

00:25:50,320 --> 00:25:53,590
space then that solution is clearly

00:25:51,970 --> 00:25:55,450
better than the other but we can't

00:25:53,590 --> 00:25:58,720
really say a programming language that's

00:25:55,450 --> 00:26:00,910
best for all possible use cases finding

00:25:58,720 --> 00:26:04,780
that local optimum is what drives me

00:26:00,910 --> 00:26:07,030
these days so the essential elements so

00:26:04,780 --> 00:26:10,390
essentially the space where Scala is

00:26:07,030 --> 00:26:13,330
where what we can play with I believe

00:26:10,390 --> 00:26:15,730
it's a language that has both functions

00:26:13,330 --> 00:26:19,210
and classes and objects that has strict

00:26:15,730 --> 00:26:21,070
evaluation so I don't think we have

00:26:19,210 --> 00:26:23,440
laziness as an option but I think the

00:26:21,070 --> 00:26:26,230
default mode is clearly strict that has

00:26:23,440 --> 00:26:28,620
local type inference so empty memories

00:26:26,230 --> 00:26:30,900
out and it has implicit

00:26:28,620 --> 00:26:33,540
and currently many languages are moving

00:26:30,900 --> 00:26:36,540
in that space whether you say Swift or C

00:26:33,540 --> 00:26:39,080
sharp or Kotlin or many many others and

00:26:36,540 --> 00:26:41,670
she are migrating towards that core

00:26:39,080 --> 00:26:43,890
definitely for the first four functions

00:26:41,670 --> 00:26:47,760
classes object strictness local type

00:26:43,890 --> 00:26:50,910
inference is sort of on the on the list

00:26:47,760 --> 00:26:53,220
for for all of these implicit not yet so

00:26:50,910 --> 00:26:55,770
much but I expect once

00:26:53,220 --> 00:26:57,630
okano has adopted implicit they have a

00:26:55,770 --> 00:27:00,059
proposal out there and they probably

00:26:57,630 --> 00:27:01,770
will be implemented soon the floodgates

00:27:00,059 --> 00:27:05,929
will open and everybody will want them

00:27:01,770 --> 00:27:07,170
or at least that's one can dream right

00:27:05,929 --> 00:27:10,650
okay

00:27:07,170 --> 00:27:13,080
so the goals I have for the evolution is

00:27:10,650 --> 00:27:15,540
first to deepen the synthesis of

00:27:13,080 --> 00:27:19,050
functional programming and modular

00:27:15,540 --> 00:27:21,410
programming improve the connection of

00:27:19,050 --> 00:27:23,640
Scala with its theoretical foundations

00:27:21,410 --> 00:27:26,309
improve the guarantees of the type

00:27:23,640 --> 00:27:28,800
system and at the same time stay simple

00:27:26,309 --> 00:27:31,470
and approachable essentially we want to

00:27:28,800 --> 00:27:33,240
make bring out what makes Scala is

00:27:31,470 --> 00:27:36,320
special and that I believe is this

00:27:33,240 --> 00:27:38,400
combination of functional and modular

00:27:36,320 --> 00:27:40,020
object-oriented programming that's sort

00:27:38,400 --> 00:27:43,050
of the core of it and we want to sort of

00:27:40,020 --> 00:27:45,420
what my my aim always was to say well

00:27:43,050 --> 00:27:47,670
let's try to make this sort of as good

00:27:45,420 --> 00:27:50,880
as we can instead of trying to emulate

00:27:47,670 --> 00:27:52,440
something else and Scala is great it's a

00:27:50,880 --> 00:27:55,410
great language to emulate lots of other

00:27:52,440 --> 00:27:58,140
bu cells and things like that but that

00:27:55,410 --> 00:27:59,520
it shouldn't be it's only purpose I

00:27:58,140 --> 00:28:03,179
think the purpose should be to actually

00:27:59,520 --> 00:28:05,010
work work on the core so what I want to

00:28:03,179 --> 00:28:08,340
give you is essentially a whirlwind tour

00:28:05,010 --> 00:28:12,720
of dottie so where we currently are

00:28:08,340 --> 00:28:15,270
what's what's in store and there's gonna

00:28:12,720 --> 00:28:17,160
be a lot a lot of materials so if some

00:28:15,270 --> 00:28:20,280
of that goes a little bit fast and

00:28:17,160 --> 00:28:23,730
approached me afterwards and I can give

00:28:20,280 --> 00:28:26,400
you more details so first we don't

00:28:23,730 --> 00:28:29,340
really want to have a huge language in

00:28:26,400 --> 00:28:31,650
fact small is beautiful so before we

00:28:29,340 --> 00:28:33,540
start adding stuff let's see you of what

00:28:31,650 --> 00:28:36,720
what we can drop so these are things

00:28:33,540 --> 00:28:39,870
that are dropped or about to be dropped

00:28:36,720 --> 00:28:41,250
first thing is procedures in tax so

00:28:39,870 --> 00:28:43,500
that's I think a

00:28:41,250 --> 00:28:46,830
thinking I believe everybody agrees on

00:28:43,500 --> 00:28:48,480
so this special syntax here of the run

00:28:46,830 --> 00:28:52,770
method that you see up here that's

00:28:48,480 --> 00:28:55,140
that's really it's it's not not really

00:28:52,770 --> 00:28:57,150
doesn't doesn't gain you a lot and it

00:28:55,140 --> 00:28:59,100
gives you an awkward choice should I use

00:28:57,150 --> 00:29:01,049
one or the other so in the future you're

00:28:59,100 --> 00:29:03,360
always use the thing that's at the

00:29:01,049 --> 00:29:06,210
bottom so you always use an explicit

00:29:03,360 --> 00:29:07,740
unit because hey you're will functional

00:29:06,210 --> 00:29:10,049
programmers right we don't have many

00:29:07,740 --> 00:29:12,000
unit producing functions anyway in our

00:29:10,049 --> 00:29:15,980
program because they all they can do

00:29:12,000 --> 00:29:19,409
with side-effects right so of course

00:29:15,980 --> 00:29:21,750
doing so manually would be very tedious

00:29:19,409 --> 00:29:23,159
because I mean even though we're

00:29:21,750 --> 00:29:25,470
function programmers there are a lot of

00:29:23,159 --> 00:29:28,890
these instances in existing code so

00:29:25,470 --> 00:29:30,419
there will be a rewrite tool migration

00:29:28,890 --> 00:29:32,460
tools that will do that automatically

00:29:30,419 --> 00:29:34,470
for the source codes and the rewrite

00:29:32,460 --> 00:29:36,870
tool will also take care of a lot of the

00:29:34,470 --> 00:29:41,520
other transitions that I'm going to talk

00:29:36,870 --> 00:29:43,159
about next thing is delight in it I

00:29:41,520 --> 00:29:45,840
think there was another thing that

00:29:43,159 --> 00:29:50,039
probably didn't care carry it's way too

00:29:45,840 --> 00:29:53,309
much the big thing here

00:29:50,039 --> 00:29:57,179
next thing is macros so the current

00:29:53,309 --> 00:29:58,799
version of macros will be dropped that

00:29:57,179 --> 00:30:01,320
version to tell the truth has been

00:29:58,799 --> 00:30:03,330
labeled experimental for ever since its

00:30:01,320 --> 00:30:05,789
inception for five years so I think it's

00:30:03,330 --> 00:30:08,370
about the longest-running experiment in

00:30:05,789 --> 00:30:10,740
language design and it's an experiment

00:30:08,370 --> 00:30:13,289
we're going to discontinue and then I

00:30:10,740 --> 00:30:16,350
realized that that that's probably going

00:30:13,289 --> 00:30:20,039
to be a problem for a lot of people but

00:30:16,350 --> 00:30:21,600
I just wait hold your breath and in a

00:30:20,039 --> 00:30:24,809
couple of slides we will present an

00:30:21,600 --> 00:30:29,090
alternative early initial hops

00:30:24,809 --> 00:30:29,090
what what happens now

00:30:31,659 --> 00:30:38,120
okay coming back okay

00:30:35,110 --> 00:30:42,289
early initializes who knows what early

00:30:38,120 --> 00:30:43,549
initializes are good for those of you

00:30:42,289 --> 00:30:46,159
who don't know which is the absolute

00:30:43,549 --> 00:30:48,409
majority that's what they are so that's

00:30:46,159 --> 00:30:50,360
that's the syntax so let me just explain

00:30:48,409 --> 00:30:55,610
it to you before we remove them

00:30:50,360 --> 00:30:58,639
so essentially you so essentially we can

00:30:55,610 --> 00:31:00,889
have a Class C and it can before it

00:30:58,639 --> 00:31:02,360
extends any any class we can exchange

00:31:00,889 --> 00:31:04,820
you have definitions here like this

00:31:02,360 --> 00:31:07,580
VALIC s-- so what does it mean so what

00:31:04,820 --> 00:31:09,379
it meant was that if you do that so

00:31:07,580 --> 00:31:11,990
normally if you have definitions here

00:31:09,379 --> 00:31:13,549
under they will be initialized after the

00:31:11,990 --> 00:31:15,139
superclass will be initialized and

00:31:13,549 --> 00:31:17,269
sometimes that's inconvenient so

00:31:15,139 --> 00:31:18,950
sometimes do you want two things to be

00:31:17,269 --> 00:31:21,019
initialized before you have the

00:31:18,950 --> 00:31:24,710
superclass initializer and that's what

00:31:21,019 --> 00:31:27,049
the early initializes did that said it

00:31:24,710 --> 00:31:29,090
was a kind of a weird feature most of

00:31:27,049 --> 00:31:30,559
you don't even know it exists and you

00:31:29,090 --> 00:31:33,080
now have something which I believe it's

00:31:30,559 --> 00:31:35,299
much more conventional and and better

00:31:33,080 --> 00:31:37,549
and simpler to use and it's just trade

00:31:35,299 --> 00:31:40,129
parameters so you can pass parameters to

00:31:37,549 --> 00:31:42,350
traits and when you do that they also

00:31:40,129 --> 00:31:44,840
will essentially be evaluated before the

00:31:42,350 --> 00:31:46,610
trade gets initialized so there you have

00:31:44,840 --> 00:31:49,389
the same initialization order with a

00:31:46,610 --> 00:31:51,470
much more conventional and standard

00:31:49,389 --> 00:31:53,690
syntax and of course trade parameters

00:31:51,470 --> 00:31:58,309
are useful for lots of other reasons as

00:31:53,690 --> 00:32:00,950
well existential types are these things

00:31:58,309 --> 00:32:02,990
that you I believe that if you go to

00:32:00,950 --> 00:32:06,500
complicated existential types like

00:32:02,990 --> 00:32:09,590
things like that then it's probably a

00:32:06,500 --> 00:32:11,240
code smell and you probably soon after

00:32:09,590 --> 00:32:13,909
you probably see that your type checker

00:32:11,240 --> 00:32:15,590
will give you weird errors that you

00:32:13,909 --> 00:32:16,730
don't really fully understand and things

00:32:15,590 --> 00:32:20,419
like that so it's probably much better

00:32:16,730 --> 00:32:24,409
to actually say well that probably was a

00:32:20,419 --> 00:32:26,389
feature that is too too fragile and in

00:32:24,409 --> 00:32:28,070
general not a good idea there's simple

00:32:26,389 --> 00:32:31,149
existential types that we can express

00:32:28,070 --> 00:32:33,080
with wildcards will still remain

00:32:31,149 --> 00:32:35,539
supported because I think that's

00:32:33,080 --> 00:32:37,820
absolutely essential but sort of the

00:32:35,539 --> 00:32:39,679
over your top complicated thing where

00:32:37,820 --> 00:32:41,380
you have complicated for some classes

00:32:39,679 --> 00:32:43,960
will be dropped

00:32:41,380 --> 00:32:45,940
two general type projections so I talked

00:32:43,960 --> 00:32:48,040
about that already in the dark context

00:32:45,940 --> 00:32:49,720
so the hash we're on the left-hand side

00:32:48,040 --> 00:32:52,270
of the hash you can have an arbitrary

00:32:49,720 --> 00:32:55,030
complicated type was shown to be unsound

00:32:52,270 --> 00:32:56,650
in the dark context so the only thing

00:32:55,030 --> 00:33:00,670
we're going to keep is projection from

00:32:56,650 --> 00:33:04,030
classes so if that T is a Class C then

00:33:00,670 --> 00:33:06,220
that essentially models an inner class

00:33:04,030 --> 00:33:08,020
in Java so we have to keep it in order

00:33:06,220 --> 00:33:10,120
to be able to talk about inner classes

00:33:08,020 --> 00:33:12,400
and it also turns out that this special

00:33:10,120 --> 00:33:17,100
use case is perfectly sound so we can

00:33:12,400 --> 00:33:21,280
keep it okay so that's sort of all we

00:33:17,100 --> 00:33:24,040
shed so what do we propose to add

00:33:21,280 --> 00:33:26,610
instead so the first thing is

00:33:24,040 --> 00:33:29,320
intersection and union types so

00:33:26,610 --> 00:33:35,140
intersection is essentially just as a

00:33:29,320 --> 00:33:37,150
small syntactic variation on the width

00:33:35,140 --> 00:33:40,300
thing yeah so instead of tea with you

00:33:37,150 --> 00:33:42,190
you now write T and u and now of course

00:33:40,300 --> 00:33:45,670
they're rewriting to will take care to

00:33:42,190 --> 00:33:48,130
do that for you so why use an ant

00:33:45,670 --> 00:33:51,490
instead of a width now the ant has a

00:33:48,130 --> 00:33:54,520
different semantics a different meaning

00:33:51,490 --> 00:33:56,980
and it has much nicer algebraic laws in

00:33:54,520 --> 00:33:59,800
particular the ant the new intersection

00:33:56,980 --> 00:34:02,290
types are commutative so T and U is the

00:33:59,800 --> 00:34:05,410
same thing as U and T which is very nice

00:34:02,290 --> 00:34:07,420
which was emphatically not the case for

00:34:05,410 --> 00:34:10,629
tea with you tea with you and you with

00:34:07,420 --> 00:34:12,700
with you with you with tea where two

00:34:10,629 --> 00:34:14,710
different types that resolve differently

00:34:12,700 --> 00:34:17,320
because they essentially underwent the

00:34:14,710 --> 00:34:20,320
linearization of class inheritance where

00:34:17,320 --> 00:34:22,899
user with so linearization means well it

00:34:20,320 --> 00:34:27,159
order matters so it's not commutative

00:34:22,899 --> 00:34:30,250
so that was a big thing which in the end

00:34:27,159 --> 00:34:31,659
also makes code cleaner and simpler so I

00:34:30,250 --> 00:34:34,540
give I believe it's a big simplification

00:34:31,659 --> 00:34:35,440
to go from compound types with with two

00:34:34,540 --> 00:34:39,190
intersections

00:34:35,440 --> 00:34:41,980
once you have intersection the dual of

00:34:39,190 --> 00:34:44,830
that would be Union types so Union types

00:34:41,980 --> 00:34:47,050
are written T or U and that essentially

00:34:44,830 --> 00:34:48,940
gives you an untagged union of two two

00:34:47,050 --> 00:34:52,240
types so you can write for instance

00:34:48,940 --> 00:34:54,560
string or number and that's a type

00:34:52,240 --> 00:34:56,870
that's either a string or a number it

00:34:54,560 --> 00:34:58,970
have a tag like left or right or things

00:34:56,870 --> 00:35:00,920
like that but you can always find out

00:34:58,970 --> 00:35:03,440
what it is with a pattern match if X is

00:35:00,920 --> 00:35:06,200
a string if if X is a number then you

00:35:03,440 --> 00:35:10,160
can do that the main reason for having

00:35:06,200 --> 00:35:12,350
unions was well it's a nice dual of

00:35:10,160 --> 00:35:14,750
intersections okay but the main

00:35:12,350 --> 00:35:18,290
practical reason is that with unions we

00:35:14,750 --> 00:35:20,180
can avoid exploding labs so probably a

00:35:18,290 --> 00:35:23,050
lot of you have already seen them using

00:35:20,180 --> 00:35:25,490
examples of error messages that span

00:35:23,050 --> 00:35:27,680
dozens or maybe even hundreds of pages

00:35:25,490 --> 00:35:30,560
of code because you have absolutely

00:35:27,680 --> 00:35:33,230
humongous types maybe some of you have

00:35:30,560 --> 00:35:35,540
experienced them in practice already so

00:35:33,230 --> 00:35:38,030
that was also always the problem that to

00:35:35,540 --> 00:35:40,070
compute the upper bound of two types

00:35:38,030 --> 00:35:43,310
let's say you have an if-then-else and

00:35:40,070 --> 00:35:45,650
you need to say well if in the if branch

00:35:43,310 --> 00:35:47,600
I have P in the else branch I have a U

00:35:45,650 --> 00:35:49,490
and I say well what's the type of the

00:35:47,600 --> 00:35:51,770
whole thing well it must be sort of the

00:35:49,490 --> 00:35:54,020
least upper bound of the T and the U

00:35:51,770 --> 00:35:55,490
with T or you you have a concise way to

00:35:54,020 --> 00:35:57,800
write that that's what the type is

00:35:55,490 --> 00:35:59,870
without it you have to essentially

00:35:57,800 --> 00:36:01,700
compute it differently with the types

00:35:59,870 --> 00:36:03,410
that's there the spec is quite clear it

00:36:01,700 --> 00:36:05,780
has to be the least upper bound of those

00:36:03,410 --> 00:36:08,180
two types the problem is that that least

00:36:05,780 --> 00:36:11,480
upper bound can sometimes be infinitely

00:36:08,180 --> 00:36:13,010
large even or very very very large and

00:36:11,480 --> 00:36:15,320
that's essentially these exploding labs

00:36:13,010 --> 00:36:18,080
that you have seen which in practice are

00:36:15,320 --> 00:36:19,970
very very annoying and also just don't

00:36:18,080 --> 00:36:22,760
really make for a faster compiler if it

00:36:19,970 --> 00:36:26,480
is to compute types like that so the or

00:36:22,760 --> 00:36:30,320
types should should help here function

00:36:26,480 --> 00:36:33,800
arity adaptation that's sort of a minor

00:36:30,320 --> 00:36:36,380
annoyance but I think it will help a lot

00:36:33,800 --> 00:36:38,240
so what we would like to write and what

00:36:36,380 --> 00:36:40,540
I guess a lot of us already wrote is

00:36:38,240 --> 00:36:43,100
let's say you have a list of pairs and

00:36:40,540 --> 00:36:45,830
you want to map a function like that

00:36:43,100 --> 00:36:48,740
just sum the two parts of the path can't

00:36:45,830 --> 00:36:50,900
do that because that's a function that

00:36:48,740 --> 00:36:52,700
takes two arguments and what you have is

00:36:50,900 --> 00:36:55,040
a list of paths and a pair is just one

00:36:52,700 --> 00:36:57,830
thing right so the trick that I guess a

00:36:55,040 --> 00:36:59,900
lot of us have learned is that you write

00:36:57,830 --> 00:37:02,930
it like this you say pairs map and then

00:36:59,900 --> 00:37:05,000
you say it case X Y X plus y so you just

00:37:02,930 --> 00:37:07,580
put a case in front of the thing and

00:37:05,000 --> 00:37:08,390
that's a cute trick and it helps a lot

00:37:07,580 --> 00:37:09,619
but

00:37:08,390 --> 00:37:11,869
we should we shouldn't have to think

00:37:09,619 --> 00:37:13,490
about these things so that's probably a

00:37:11,869 --> 00:37:15,829
thing that the compiler should be able

00:37:13,490 --> 00:37:18,410
to take care of so function adaptation a

00:37:15,829 --> 00:37:19,760
functionary adaptation does that so

00:37:18,410 --> 00:37:22,880
that's another thing that we have in

00:37:19,760 --> 00:37:25,490
here trade parameters I already

00:37:22,880 --> 00:37:28,130
mentioned them so we can now pass value

00:37:25,490 --> 00:37:33,920
parameters to traits as we can to

00:37:28,130 --> 00:37:36,589
classes static methods in fields so

00:37:33,920 --> 00:37:39,589
there's a static annotation that makes

00:37:36,589 --> 00:37:41,329
and you can only use it in an object but

00:37:39,589 --> 00:37:43,880
it means that the implementation of this

00:37:41,329 --> 00:37:46,039
well and this death will be a true

00:37:43,880 --> 00:37:49,190
static method in the Java sense not just

00:37:46,039 --> 00:37:51,529
a member method of the object the main

00:37:49,190 --> 00:37:53,510
reason for having this is really Java

00:37:51,529 --> 00:37:55,309
interrupts because quite a few Java

00:37:53,510 --> 00:37:57,200
frameworks just demand that it's a

00:37:55,309 --> 00:38:01,220
static and not an instance view the

00:37:57,200 --> 00:38:03,049
field of a record so it's useful to be

00:38:01,220 --> 00:38:11,210
able to write that in in a you know

00:38:03,049 --> 00:38:14,809
general context whoops

00:38:11,210 --> 00:38:16,640
lazy vowels so we did some improvements

00:38:14,809 --> 00:38:19,690
in store for lazy vowels and the things

00:38:16,640 --> 00:38:23,180
some of them will already come in 213

00:38:19,690 --> 00:38:25,640
the first thing is that lazy vowels now

00:38:23,180 --> 00:38:28,279
have this problem that they lock the

00:38:25,640 --> 00:38:30,619
object during the evaluation of the lazy

00:38:28,279 --> 00:38:33,440
vowel and this locking can in the worst

00:38:30,619 --> 00:38:35,599
case least lead to dead locks so we have

00:38:33,440 --> 00:38:38,710
a revised scheme that is and she uses

00:38:35,599 --> 00:38:41,539
much shorter locking so essentially it's

00:38:38,710 --> 00:38:44,000
essentially locked free there just to

00:38:41,539 --> 00:38:45,259
lock periods which are of bounded length

00:38:44,000 --> 00:38:48,049
they're just a couple of instructions

00:38:45,259 --> 00:38:50,029
each and the rest of these things

00:38:48,049 --> 00:38:52,819
wouldn't use locking anymore so that

00:38:50,029 --> 00:38:54,740
should essentially remove and in the

00:38:52,819 --> 00:38:57,410
void all the problems with lazy vowels

00:38:54,740 --> 00:39:01,039
and deadlocks the other thing we want to

00:38:57,410 --> 00:39:03,259
do now not in 213 but only in dotty once

00:39:01,039 --> 00:39:05,420
we have the rewrite tool is to make the

00:39:03,259 --> 00:39:09,230
default behavior of lazy vowels to be

00:39:05,420 --> 00:39:10,430
thread-local so right now the deadlocks

00:39:09,230 --> 00:39:12,289
and essentially the whole thing with

00:39:10,430 --> 00:39:14,269
lazy vowels meant that in order to

00:39:12,289 --> 00:39:16,400
access a lazy value have to go through a

00:39:14,269 --> 00:39:19,160
fairly complicated and cost the locking

00:39:16,400 --> 00:39:21,210
protocol because different threads could

00:39:19,160 --> 00:39:25,230
access the same lazy bail and

00:39:21,210 --> 00:39:27,150
that leads can can lead to problems so

00:39:25,230 --> 00:39:30,510
essentially it means that everybody pays

00:39:27,150 --> 00:39:32,460
the price of having lazy belts because a

00:39:30,510 --> 00:39:34,050
few applications want to access lazy

00:39:32,460 --> 00:39:36,750
valves from different contexts from

00:39:34,050 --> 00:39:38,460
different tribe contexts so what we want

00:39:36,750 --> 00:39:40,230
to do is essentially flip the default

00:39:38,460 --> 00:39:42,390
and say well if something should be

00:39:40,230 --> 00:39:44,040
thread safe then market with volatile

00:39:42,390 --> 00:39:45,930
like you would do for all strict swell

00:39:44,040 --> 00:39:48,569
values if you wanted them to be safely

00:39:45,930 --> 00:39:50,280
published and use lazy valves only for

00:39:48,569 --> 00:39:52,589
active state local things so that's

00:39:50,280 --> 00:39:54,329
essentially one thing we want to do and

00:39:52,589 --> 00:39:56,069
again a rewriting tool will help of

00:39:54,329 --> 00:40:01,200
course because it can add these

00:39:56,069 --> 00:40:04,910
volatiles for you automatically and the

00:40:01,200 --> 00:40:07,680
next thing is multiversal equality so

00:40:04,910 --> 00:40:10,859
that's essentially a way to get type

00:40:07,680 --> 00:40:12,750
safe equals and not equals so in the

00:40:10,859 --> 00:40:15,000
future when you compare two things that

00:40:12,750 --> 00:40:17,640
are incomparable like let's say a string

00:40:15,000 --> 00:40:19,319
and a number the compiler will tell you

00:40:17,640 --> 00:40:21,510
that you can't do that we have a

00:40:19,319 --> 00:40:23,220
compiler warning now that does these

00:40:21,510 --> 00:40:25,740
things but that warning is pretty leaky

00:40:23,220 --> 00:40:27,480
so it only works for some types and some

00:40:25,740 --> 00:40:29,609
combinations and it lets a lot of other

00:40:27,480 --> 00:40:31,910
things go through with multiversal

00:40:29,609 --> 00:40:34,589
equality we give you essentially the

00:40:31,910 --> 00:40:35,970
power in the libraries to do that for

00:40:34,589 --> 00:40:37,650
your own types so essentially you can

00:40:35,970 --> 00:40:39,750
define in the library what types are

00:40:37,650 --> 00:40:41,940
comparable to what other types and the

00:40:39,750 --> 00:40:44,099
compiler will essentially give you an

00:40:41,940 --> 00:40:45,869
error if you do different things the

00:40:44,099 --> 00:40:47,450
design of that was very subtle because

00:40:45,869 --> 00:40:50,099
again we want to be backwards compatible

00:40:47,450 --> 00:40:52,650
so it means that if now you compare on

00:40:50,099 --> 00:40:55,470
any to something else then it could be

00:40:52,650 --> 00:40:57,690
equal so multiverse equality also has to

00:40:55,470 --> 00:40:59,940
let you do that so a lot of the other

00:40:57,690 --> 00:41:01,740
proposals of the triple equals the

00:40:59,940 --> 00:41:03,510
essentially they're the ones you see are

00:41:01,740 --> 00:41:04,680
in a sense stricter because they don't

00:41:03,510 --> 00:41:06,780
have to have this backwards

00:41:04,680 --> 00:41:10,170
compatibility requirement that you say

00:41:06,780 --> 00:41:12,150
you still need to be able to essentially

00:41:10,170 --> 00:41:14,400
compare everything with everything but

00:41:12,150 --> 00:41:17,520
if it's obviously stupid then you should

00:41:14,400 --> 00:41:22,650
be told by the compiler and finally

00:41:17,520 --> 00:41:25,170
their name pop name parameters so it

00:41:22,650 --> 00:41:27,390
means for method parameters we have the

00:41:25,170 --> 00:41:29,069
name parameter syntax right so named and

00:41:27,390 --> 00:41:31,829
default parameters and they're quite

00:41:29,069 --> 00:41:33,400
useful so the question is why not do

00:41:31,829 --> 00:41:35,710
that for type parameters

00:41:33,400 --> 00:41:39,070
and obviously will be useful as well

00:41:35,710 --> 00:41:41,770
first if you write map key equals int

00:41:39,070 --> 00:41:43,690
it's probably quite legible to say well

00:41:41,770 --> 00:41:45,640
I mean the key parameter and not the

00:41:43,690 --> 00:41:47,260
value parameter maybe need to be

00:41:45,640 --> 00:41:50,290
forgotten in what order they come

00:41:47,260 --> 00:41:51,940
so it helps legibility and furthermore

00:41:50,290 --> 00:41:54,160
it also helps you to leave these

00:41:51,940 --> 00:41:55,960
parameters out so here I have only

00:41:54,160 --> 00:41:58,060
specified the key parameter and of the

00:41:55,960 --> 00:42:00,640
value parameter which will mean that the

00:41:58,060 --> 00:42:02,830
value parameter will be inferred so the

00:42:00,640 --> 00:42:05,020
compiler will say well the key is

00:42:02,830 --> 00:42:07,840
explicit the value is inferred because

00:42:05,020 --> 00:42:12,160
you haven't given them given them them

00:42:07,840 --> 00:42:15,340
explicitly okay so the motivation for

00:42:12,160 --> 00:42:18,250
all these was a better closer to the

00:42:15,340 --> 00:42:20,530
Foundation's better contact with the

00:42:18,250 --> 00:42:26,980
Foundation's make them easier and safer

00:42:20,530 --> 00:42:29,920
to use and more orthogonal the

00:42:26,980 --> 00:42:32,650
improvements in detail are in the type

00:42:29,920 --> 00:42:34,420
system so essentially we revamp the type

00:42:32,650 --> 00:42:37,360
system it's now strongly influenced by

00:42:34,420 --> 00:42:39,640
dot and there's a much better

00:42:37,360 --> 00:42:40,900
integration of type refinements which

00:42:39,640 --> 00:42:44,020
are made essentially the basis of

00:42:40,900 --> 00:42:47,620
everything now the type inference got

00:42:44,020 --> 00:42:50,680
also revamped so where before it was

00:42:47,620 --> 00:42:53,410
relatively a talk now we have a pretty

00:42:50,680 --> 00:42:56,410
systematic way to map types into

00:42:53,410 --> 00:42:58,600
constraints and then to solve these

00:42:56,410 --> 00:43:00,220
constraints or constraints are typically

00:42:58,600 --> 00:43:02,020
sub type constraints and we have a sub

00:43:00,220 --> 00:43:04,320
type constraint solver to take care of

00:43:02,020 --> 00:43:07,450
type inference that hopefully should

00:43:04,320 --> 00:43:10,330
make a type inference much simpler to

00:43:07,450 --> 00:43:11,920
specify than has been the case so far so

00:43:10,330 --> 00:43:14,830
it's another goal to actually get to a

00:43:11,920 --> 00:43:16,810
point where we can specify exactly what

00:43:14,830 --> 00:43:20,350
type inference not just type checking

00:43:16,810 --> 00:43:22,150
but what type inference does for the

00:43:20,350 --> 00:43:24,970
implicit search we have a faster search

00:43:22,150 --> 00:43:27,460
algorithm which is better behaved for

00:43:24,970 --> 00:43:30,190
contravariant types and for value

00:43:27,460 --> 00:43:31,750
classes we now support both nested value

00:43:30,190 --> 00:43:34,450
classes and in the very near future

00:43:31,750 --> 00:43:35,800
arrays of value classes so value classes

00:43:34,450 --> 00:43:38,500
should be much more usable and

00:43:35,800 --> 00:43:41,800
performant than they were before so

00:43:38,500 --> 00:43:43,960
who's working on all this so so far the

00:43:41,800 --> 00:43:46,099
main contributors are from epfl

00:43:43,960 --> 00:43:48,190
dimitri p - co who's going to

00:43:46,099 --> 00:43:50,499
talk about some of the optimizing

00:43:48,190 --> 00:43:52,960
optimizer work on the compiler later

00:43:50,499 --> 00:43:56,089
going on mattress Vladimir Nikolayevich

00:43:52,960 --> 00:43:58,220
mother and the skeleton matte light band

00:43:56,089 --> 00:44:00,380
also helps with very good discussions

00:43:58,220 --> 00:44:03,079
infrastructure you reviews and

00:44:00,380 --> 00:44:05,960
suggestions and very much is in the loop

00:44:03,079 --> 00:44:07,970
of all this development and it's a

00:44:05,960 --> 00:44:11,029
community project so if you want to get

00:44:07,970 --> 00:44:16,450
your hands dirty very welcome and let's

00:44:11,029 --> 00:44:19,069
talk after the talk there's some tooling

00:44:16,450 --> 00:44:21,440
tooling is still pretty rudimentary but

00:44:19,069 --> 00:44:23,720
some of the things already there so we

00:44:21,440 --> 00:44:26,479
have SBT integration so you can launch a

00:44:23,720 --> 00:44:29,690
dirty project from SBT we have a wrapper

00:44:26,479 --> 00:44:32,569
and it even has syntax highlighting we

00:44:29,690 --> 00:44:34,339
have on the IDE that's not that much yet

00:44:32,569 --> 00:44:38,390
but JetBrains is working on

00:44:34,339 --> 00:44:41,180
unintelligible again we have the

00:44:38,390 --> 00:44:44,680
prototype for a dotty dock so

00:44:41,180 --> 00:44:47,420
essentially a Java doc a Scala doc

00:44:44,680 --> 00:44:50,269
adapted to the compiler and we have this

00:44:47,420 --> 00:44:53,239
whole program or analyze and optimizer

00:44:50,269 --> 00:44:55,329
called the linker which uses tasty for

00:44:53,239 --> 00:44:57,049
serialization and that should make

00:44:55,329 --> 00:44:59,630
specialization and a lot of other

00:44:57,049 --> 00:45:01,700
optimizations much cheaper and more

00:44:59,630 --> 00:45:05,089
robust and Dimitri will talk more about

00:45:01,700 --> 00:45:07,130
that later in the conference so I should

00:45:05,089 --> 00:45:09,650
I just want to spend a couple of words

00:45:07,130 --> 00:45:12,019
on essentially what are the more far-out

00:45:09,650 --> 00:45:14,359
things that we are on the horizon here

00:45:12,019 --> 00:45:16,339
so what you've seen so far is

00:45:14,359 --> 00:45:18,349
essentially things that are implemented

00:45:16,339 --> 00:45:19,819
so we have them in dotty you can try

00:45:18,349 --> 00:45:22,910
them out I'm not saying it's production

00:45:19,819 --> 00:45:24,529
quality yet but it's there so these are

00:45:22,910 --> 00:45:27,650
things that are not yet implemented but

00:45:24,529 --> 00:45:32,630
that we hopefully will have in the near

00:45:27,650 --> 00:45:36,440
future and midterm future just got stuck

00:45:32,630 --> 00:45:37,999
on ok so the first thing and very

00:45:36,440 --> 00:45:41,900
important thing I realized for the

00:45:37,999 --> 00:45:43,519
future releases is Scala meta so I said

00:45:41,900 --> 00:45:46,339
macros were experimental they

00:45:43,519 --> 00:45:48,289
essentially too much tied into with the

00:45:46,339 --> 00:45:50,029
existing compiler they expose a lot of

00:45:48,289 --> 00:45:54,349
compiler internals that should have been

00:45:50,029 --> 00:45:56,839
hidden Eugene has been working on for

00:45:54,349 --> 00:45:58,849
some time now on the scholar meta

00:45:56,839 --> 00:45:59,290
project which should be a much more

00:45:58,849 --> 00:46:02,200
print

00:45:59,290 --> 00:46:04,420
approach to metaprogramming and macros

00:46:02,200 --> 00:46:06,610
in particular instead of exploring

00:46:04,420 --> 00:46:10,420
imposing a lot of compiler internals you

00:46:06,610 --> 00:46:12,040
work mostly with classic quotes so it

00:46:10,420 --> 00:46:14,080
should that be a higher level of

00:46:12,040 --> 00:46:16,900
abstraction but you should still be able

00:46:14,080 --> 00:46:19,690
to do the essential things that you did

00:46:16,900 --> 00:46:21,520
at least with sane macros so the

00:46:19,690 --> 00:46:23,800
proposed syntax for that is actually to

00:46:21,520 --> 00:46:25,900
split it to have essentially an inline

00:46:23,800 --> 00:46:27,700
modifier for the function inlining so

00:46:25,900 --> 00:46:29,170
you can use it for your regular function

00:46:27,700 --> 00:46:30,130
as well it will just guarantee that

00:46:29,170 --> 00:46:33,370
there will be inlined

00:46:30,130 --> 00:46:35,170
and then that inlining could already do

00:46:33,370 --> 00:46:37,330
a lot of things a lot of program

00:46:35,170 --> 00:46:39,160
optimization things if you want to but

00:46:37,330 --> 00:46:40,750
if you then want to inspect the code

00:46:39,160 --> 00:46:43,000
like your pattern matcher when your

00:46:40,750 --> 00:46:44,800
trees using a quasi quote then you would

00:46:43,000 --> 00:46:48,040
do it in a meta block so essentially

00:46:44,800 --> 00:46:51,340
inside meta you can actually see the

00:46:48,040 --> 00:46:54,490
things that are in your environment as

00:46:51,340 --> 00:46:56,950
trees but if something is an inline like

00:46:54,490 --> 00:46:58,780
an inline parameter then that would be a

00:46:56,950 --> 00:47:00,880
compile time constants of the meta block

00:46:58,780 --> 00:47:04,870
would see it as an int and not as an

00:47:00,880 --> 00:47:08,260
expression tree of it so the change the

00:47:04,870 --> 00:47:10,090
reason for the change is it hopefully is

00:47:08,260 --> 00:47:12,730
much simpler they're fewer

00:47:10,090 --> 00:47:14,800
implementation dependencies and it

00:47:12,730 --> 00:47:16,690
should also be safer because we should

00:47:14,800 --> 00:47:23,460
be able to sandbox this thing much

00:47:16,690 --> 00:47:26,530
better then next thing on the horizon is

00:47:23,460 --> 00:47:29,470
implicit function types so this looks

00:47:26,530 --> 00:47:32,590
like a pretty smallish feature so what

00:47:29,470 --> 00:47:34,960
it is is that that's a function type and

00:47:32,590 --> 00:47:37,510
we let you write implicit in front of it

00:47:34,960 --> 00:47:38,770
so that's like an implicit method takes

00:47:37,510 --> 00:47:40,510
an implicit parameter but it's a

00:47:38,770 --> 00:47:44,200
function type so it means it's a type of

00:47:40,510 --> 00:47:46,840
a value you can add have this type in as

00:47:44,200 --> 00:47:51,790
a part of another type and you can

00:47:46,840 --> 00:47:54,820
compose these things so what it means is

00:47:51,790 --> 00:47:57,010
that if you then declare a function

00:47:54,820 --> 00:48:00,070
let's say which is of this CT access

00:47:57,010 --> 00:48:02,200
context XS then you can write implicitly

00:48:00,070 --> 00:48:04,840
context and we'll pick up the context

00:48:02,200 --> 00:48:08,690
from from that time so essentially oops

00:48:04,840 --> 00:48:10,970
sorry if you write it that way then

00:48:08,690 --> 00:48:13,190
that gives you the implicit parameter

00:48:10,970 --> 00:48:17,930
but the implicit parameter is now type

00:48:13,190 --> 00:48:19,700
part of your return type and on the

00:48:17,930 --> 00:48:22,400
other hand if you write F of e so you

00:48:19,700 --> 00:48:25,040
apply the function then you also need to

00:48:22,400 --> 00:48:26,660
find the context and as usual for

00:48:25,040 --> 00:48:29,900
imprecise the compiler will find it for

00:48:26,660 --> 00:48:31,700
you so why why the change it's actually

00:48:29,900 --> 00:48:34,099
as it looks very small but it's really

00:48:31,700 --> 00:48:37,099
huge because it's the first time that we

00:48:34,099 --> 00:48:39,680
can abstract over implicit abstract

00:48:37,099 --> 00:48:41,510
means you have a concept you name it and

00:48:39,680 --> 00:48:43,970
afterwards you use just the name instead

00:48:41,510 --> 00:48:45,950
of writing out the code all the time so

00:48:43,970 --> 00:48:48,290
here for for the first time you can

00:48:45,950 --> 00:48:50,060
actually say this thing implicit this

00:48:48,290 --> 00:48:51,829
thing is implicitly parameterised give

00:48:50,060 --> 00:48:53,900
it a name use the name instead of

00:48:51,829 --> 00:48:57,890
repeating that same implicit over and

00:48:53,900 --> 00:49:00,079
over again in all your code so it gives

00:48:57,890 --> 00:49:02,210
you a lot of reduction in boilerplate it

00:49:00,079 --> 00:49:04,430
gives you a lot of increase in safety

00:49:02,210 --> 00:49:06,170
because what if you forgot the implicit

00:49:04,430 --> 00:49:08,329
somewhere then maybe it won't be picked

00:49:06,170 --> 00:49:10,579
up somewhere else now you can put it in

00:49:08,329 --> 00:49:12,650
a box and be sure it's there and it

00:49:10,579 --> 00:49:13,970
eliminates a lot of boilerplate so once

00:49:12,650 --> 00:49:16,010
you give people abstraction they

00:49:13,970 --> 00:49:17,720
couldn't do anything so once you give

00:49:16,010 --> 00:49:19,640
people abstraction over Blissett psy

00:49:17,720 --> 00:49:23,660
believes there is a lot of things to be

00:49:19,640 --> 00:49:27,319
gained the next thing is even further

00:49:23,660 --> 00:49:31,310
out but at least as exciting and that's

00:49:27,319 --> 00:49:33,770
an effect system so effect checking is

00:49:31,310 --> 00:49:36,260
of course very much in demand I think we

00:49:33,770 --> 00:49:38,420
all have a sort of haskell Envy to say

00:49:36,260 --> 00:49:40,970
well Haskell is pure and we would so

00:49:38,420 --> 00:49:43,640
much like to be pure but we can't or at

00:49:40,970 --> 00:49:46,040
least the language doesn't enforce it

00:49:43,640 --> 00:49:48,319
and we don't really have a good good

00:49:46,040 --> 00:49:50,390
essentially type checker that tells us

00:49:48,319 --> 00:49:52,579
we are pure unless we essentially have

00:49:50,390 --> 00:49:55,819
put in a lot of conventions go over a

00:49:52,579 --> 00:49:57,800
lot of monads and so on so I think we

00:49:55,819 --> 00:50:00,740
can do a lot of better than monads to

00:49:57,800 --> 00:50:02,869
achieve effect checking and actually I'm

00:50:00,740 --> 00:50:04,819
as you might have noticed by now I'm

00:50:02,869 --> 00:50:06,290
very fond of implicit parameters not

00:50:04,819 --> 00:50:07,940
implicit conversions but inclusive

00:50:06,290 --> 00:50:10,990
parameters and I think they they are

00:50:07,940 --> 00:50:13,579
natural fit so the idea is that

00:50:10,990 --> 00:50:15,440
essentially an implicit instead of

00:50:13,579 --> 00:50:17,810
having an it saying you have an effect

00:50:15,440 --> 00:50:19,819
like you throw an exception you say well

00:50:17,810 --> 00:50:20,910
I need the capability to throw an

00:50:19,819 --> 00:50:23,040
exception

00:50:20,910 --> 00:50:25,530
and you get that capability with an

00:50:23,040 --> 00:50:26,820
implicit parameter and you essentially

00:50:25,530 --> 00:50:28,290
don't need to write the implicit

00:50:26,820 --> 00:50:30,120
parameter because we have implicit

00:50:28,290 --> 00:50:32,370
functions so that's essentially the gist

00:50:30,120 --> 00:50:34,860
of it on the function types it means

00:50:32,370 --> 00:50:36,930
that we will have two function types the

00:50:34,860 --> 00:50:40,560
pure ones which are which are written

00:50:36,930 --> 00:50:43,110
ups with a single arrow and the impure

00:50:40,560 --> 00:50:46,110
ones so if you ever wondered why is God

00:50:43,110 --> 00:50:48,960
I've reserved didn't use the single

00:50:46,110 --> 00:50:51,030
arrow for functions like Haskell and ml

00:50:48,960 --> 00:50:52,770
does now you have the answer we wanted

00:50:51,030 --> 00:51:02,970
to reserve it all along for pure

00:50:52,770 --> 00:51:04,640
functions okay once we have effects and

00:51:02,970 --> 00:51:08,070
union types it actually turns out that

00:51:04,640 --> 00:51:11,160
we can model malleability in a very very

00:51:08,070 --> 00:51:14,400
cheap and natural way so that's another

00:51:11,160 --> 00:51:17,520
thing that we're thinking of the idea is

00:51:14,400 --> 00:51:20,160
to say well that's another embarrassment

00:51:17,520 --> 00:51:22,050
of Scala right so a lot of languages now

00:51:20,160 --> 00:51:25,080
have essentially explicit treatment of

00:51:22,050 --> 00:51:26,670
nulls or non nullable types and Scala is

00:51:25,080 --> 00:51:28,680
sort of one of the last languages it

00:51:26,670 --> 00:51:31,770
holds out and say we are impure every

00:51:28,680 --> 00:51:33,480
type can can have none so the idea is to

00:51:31,770 --> 00:51:36,900
get rid of that and say well types no

00:51:33,480 --> 00:51:40,080
types don't have now by default so if

00:51:36,900 --> 00:51:42,240
you want a default and now by default

00:51:40,080 --> 00:51:44,640
then you add a question mark to the end

00:51:42,240 --> 00:51:47,250
of the type so print stream question

00:51:44,640 --> 00:51:50,430
mark would be essentially the type

00:51:47,250 --> 00:51:51,870
that's a print stream or no and what the

00:51:50,430 --> 00:51:54,120
question mark really means is just a

00:51:51,870 --> 00:51:56,880
syntactic abbreviation for saying well

00:51:54,120 --> 00:51:59,700
it's the type or not so it's a union

00:51:56,880 --> 00:52:02,180
type of the type or now which is a a

00:51:59,700 --> 00:52:05,010
type that has it now as a single object

00:52:02,180 --> 00:52:07,110
okay now you can say well I can do that

00:52:05,010 --> 00:52:09,030
but it would mean that I have to write

00:52:07,110 --> 00:52:11,460
system that out this print stream

00:52:09,030 --> 00:52:14,030
question mark and then how do I write

00:52:11,460 --> 00:52:16,410
print on because obviously once you have

00:52:14,030 --> 00:52:18,510
types that are nullable then you

00:52:16,410 --> 00:52:20,880
shouldn't be essentially be allowed to

00:52:18,510 --> 00:52:22,500
just refer to them as if they were not

00:52:20,880 --> 00:52:25,590
now so that's where things get awkward

00:52:22,500 --> 00:52:27,750
usually but the nice the beautiful thing

00:52:25,590 --> 00:52:29,670
is with an effect system you can

00:52:27,750 --> 00:52:31,589
actually delay that moment where you

00:52:29,670 --> 00:52:34,049
sort of get the embarrassment until

00:52:31,589 --> 00:52:36,949
very far away because you can say well

00:52:34,049 --> 00:52:39,390
we let you write print them but

00:52:36,949 --> 00:52:41,400
essentially what it means is that the

00:52:39,390 --> 00:52:42,689
program will now be able to raise a

00:52:41,400 --> 00:52:45,559
nullpointerexception

00:52:42,689 --> 00:52:47,939
because the out thing can be now and

00:52:45,559 --> 00:52:49,739
raising a null point exception is an

00:52:47,939 --> 00:52:51,689
effect so your program will now have an

00:52:49,739 --> 00:52:53,819
effect and essentially with the effect

00:52:51,689 --> 00:52:55,650
checking if you declare can you can

00:52:53,819 --> 00:52:57,900
declare it I set that in a very very

00:52:55,650 --> 00:53:00,779
lightweight manner but in the future at

00:52:57,900 --> 00:53:03,089
some point you will probably want to

00:53:00,779 --> 00:53:05,609
declare it that say well my program has

00:53:03,089 --> 00:53:07,469
a nullpointerexception effect the beauty

00:53:05,609 --> 00:53:09,180
is you can do that once at the top of

00:53:07,469 --> 00:53:11,339
your program and say well I mean I have

00:53:09,180 --> 00:53:12,839
impure code it could be lots of null

00:53:11,339 --> 00:53:14,670
pointer exceptions and I can't be

00:53:12,839 --> 00:53:16,410
bothered to rewrite this thing you

00:53:14,670 --> 00:53:18,449
declare it as a top to say I have the

00:53:16,410 --> 00:53:20,640
effect of no possible effect of not null

00:53:18,449 --> 00:53:22,170
pointer exceptions and the compiler is

00:53:20,640 --> 00:53:24,410
fine with it so use implicit

00:53:22,170 --> 00:53:27,839
capabilities give you a much more

00:53:24,410 --> 00:53:30,689
flexible way to explain it the effects

00:53:27,839 --> 00:53:33,449
then you would then what what the

00:53:30,689 --> 00:53:34,019
alternatives like more nuts could give

00:53:33,449 --> 00:53:38,849
you here

00:53:34,019 --> 00:53:41,969
okay generic programming the idea here

00:53:38,849 --> 00:53:44,849
is to get rid of these famous 22 things

00:53:41,969 --> 00:53:47,969
right couple 22 product 22 function 22

00:53:44,849 --> 00:53:51,089
will be history so there will be

00:53:47,969 --> 00:53:52,920
essentially tuples will be H list so

00:53:51,089 --> 00:53:54,869
essentially equivalent to H lists but

00:53:52,920 --> 00:53:57,660
will be implemented more efficiently so

00:53:54,869 --> 00:54:00,959
in the flat representation like like

00:53:57,660 --> 00:54:03,809
they are now and the the other thing it

00:54:00,959 --> 00:54:06,390
should give us is it should give us much

00:54:03,809 --> 00:54:08,519
better support for ADT so what we want

00:54:06,390 --> 00:54:10,619
to do is essentially take a lot of the

00:54:08,519 --> 00:54:12,779
good ideas of shapeless and put the core

00:54:10,619 --> 00:54:16,499
in the language to actually make them

00:54:12,779 --> 00:54:20,729
available in a more performant and a

00:54:16,499 --> 00:54:23,670
natural way the last thing is better

00:54:20,729 --> 00:54:25,380
records where the idea as well

00:54:23,670 --> 00:54:27,719
essentially it's also shapeless inspired

00:54:25,380 --> 00:54:29,729
to say well if you have tuples we also

00:54:27,719 --> 00:54:32,069
want to have records with labels and

00:54:29,729 --> 00:54:35,219
they should be implementable by hash

00:54:32,069 --> 00:54:37,609
maps and they should also be something

00:54:35,219 --> 00:54:42,029
that integrates well with essentially

00:54:37,609 --> 00:54:44,660
databases sparc things we're currently

00:54:42,029 --> 00:54:48,289
the limitations of tuples become very

00:54:44,660 --> 00:54:53,450
paying for okay good so that was sort of

00:54:48,289 --> 00:54:55,220
the blue sky future but I guess maybe a

00:54:53,450 --> 00:54:57,380
lot of you say well that's not really my

00:54:55,220 --> 00:55:00,369
main concern my main concern this gala

00:54:57,380 --> 00:55:04,460
is how do I not fall off the road

00:55:00,369 --> 00:55:06,530
what about guardrails so the issue here

00:55:04,460 --> 00:55:09,260
is that I think scara's premise from the

00:55:06,530 --> 00:55:12,440
start was we trust developers to do the

00:55:09,260 --> 00:55:15,079
right thing we're very optimistic very

00:55:12,440 --> 00:55:18,079
idealistic in that way but what if they

00:55:15,079 --> 00:55:21,950
don't and what if we can cannot even

00:55:18,079 --> 00:55:23,630
agree what the right thing is and I

00:55:21,950 --> 00:55:25,640
think that's challenges that a lot of

00:55:23,630 --> 00:55:28,069
teams are facing now to say what is the

00:55:25,640 --> 00:55:30,680
right way to code SCADA how do we avoid

00:55:28,069 --> 00:55:32,750
abuses because the language is very very

00:55:30,680 --> 00:55:34,940
flexible and very permissive in a way so

00:55:32,750 --> 00:55:37,400
it you can write all sorts of scholar

00:55:34,940 --> 00:55:40,369
code and you might not like the scholar

00:55:37,400 --> 00:55:42,920
code that you see from a library that

00:55:40,369 --> 00:55:45,260
you see or maybe from your teammates so

00:55:42,920 --> 00:55:47,569
my first advice here would be read this

00:55:45,260 --> 00:55:50,420
everybody read this every team read this

00:55:47,569 --> 00:55:54,589
and follow it so that's a from Lee

00:55:50,420 --> 00:55:56,329
Howie's block the he has a lot of very

00:55:54,589 --> 00:55:58,730
good articles in the block but that was

00:55:56,329 --> 00:56:01,430
one of the first ones strategic scholars

00:55:58,730 --> 00:56:03,529
style principle of least power so the

00:56:01,430 --> 00:56:06,440
idea is a well-known principle and says

00:56:03,529 --> 00:56:08,869
we should take the least always the

00:56:06,440 --> 00:56:11,180
least powerful tool that there's a given

00:56:08,869 --> 00:56:13,520
job so for instance if I want to staple

00:56:11,180 --> 00:56:16,130
papers I use a stapler I don't use a

00:56:13,520 --> 00:56:18,470
power drill right in the physical world

00:56:16,130 --> 00:56:20,089
that would be completely obvious of

00:56:18,470 --> 00:56:22,160
course I don't use a power drill why

00:56:20,089 --> 00:56:23,809
well it would be too expensive we would

00:56:22,160 --> 00:56:26,270
take take too long and I might do a lot

00:56:23,809 --> 00:56:28,010
of damage doing that in programming

00:56:26,270 --> 00:56:30,200
somehow we done we don't think about

00:56:28,010 --> 00:56:32,539
that we say well let's just throw the

00:56:30,200 --> 00:56:34,609
most heavy heavy we have these

00:56:32,539 --> 00:56:37,039
abstractions to the simplest problems

00:56:34,609 --> 00:56:38,750
and let's make things as general as

00:56:37,039 --> 00:56:41,089
possible because we might need it later

00:56:38,750 --> 00:56:43,369
yeah we probably won't need won't need

00:56:41,089 --> 00:56:45,500
it later and the problem in doing that

00:56:43,369 --> 00:56:49,309
is that somebody who approaches your

00:56:45,500 --> 00:56:51,440
code your API your library they won't

00:56:49,309 --> 00:56:53,000
know essentially what it does the more

00:56:51,440 --> 00:56:56,599
powerful tools you have in the library

00:56:53,000 --> 00:56:58,070
the least transparent is what it's does

00:56:56,599 --> 00:57:00,560
what what it does

00:56:58,070 --> 00:57:03,200
so the important thing here is to say if

00:57:00,560 --> 00:57:05,900
you take the least powerful tool then

00:57:03,200 --> 00:57:08,000
essentially you get the least

00:57:05,900 --> 00:57:09,470
astonishment of the readers of your code

00:57:08,000 --> 00:57:11,870
as well you say yeah well of course

00:57:09,470 --> 00:57:14,660
there's nothing fancy the library does

00:57:11,870 --> 00:57:15,560
because it's just written as a plain

00:57:14,660 --> 00:57:17,720
object

00:57:15,560 --> 00:57:19,430
there's no parameterization there's

00:57:17,720 --> 00:57:20,690
nothing there's no instantiation there's

00:57:19,430 --> 00:57:23,330
no reflection there's no meta

00:57:20,690 --> 00:57:25,220
programming it's just um keep dump

00:57:23,330 --> 00:57:26,990
object so it means you won't have to

00:57:25,220 --> 00:57:28,910
surprise that it does something that you

00:57:26,990 --> 00:57:31,580
wouldn't expect that it didn't that by

00:57:28,910 --> 00:57:36,290
itself is very very valuable so read

00:57:31,580 --> 00:57:38,630
this the second problem is containment

00:57:36,290 --> 00:57:40,310
so even if our code base uses that

00:57:38,630 --> 00:57:42,200
principle of least power we do not know

00:57:40,310 --> 00:57:45,410
whether the libraries that we depend on

00:57:42,200 --> 00:57:47,470
do the same so fur god forbid but the

00:57:45,410 --> 00:57:52,130
library could do something like that

00:57:47,470 --> 00:57:53,660
implicit def I to s X and converted into

00:57:52,130 --> 00:57:55,520
a string might be inspired by the

00:57:53,660 --> 00:57:57,560
JavaScript because somebody thought that

00:57:55,520 --> 00:57:59,360
was a cool cool idea to do these things

00:57:57,560 --> 00:58:01,490
and actually you might laugh but

00:57:59,360 --> 00:58:03,800
patterns like this are more common in

00:58:01,490 --> 00:58:05,300
practice than you'd like to think so

00:58:03,800 --> 00:58:09,320
instead of least power here you get

00:58:05,300 --> 00:58:11,990
maximal surprise and the problem is this

00:58:09,320 --> 00:58:14,690
could right now be in any library that

00:58:11,990 --> 00:58:17,690
you use you could lurk anywhere and you

00:58:14,690 --> 00:58:19,790
could like accidentally import that with

00:58:17,690 --> 00:58:21,290
with like an wild card import you could

00:58:19,790 --> 00:58:24,410
get it in your coat and suddenly your

00:58:21,290 --> 00:58:27,320
code converts into strings so how do you

00:58:24,410 --> 00:58:29,390
guard against that so a modest proposal

00:58:27,320 --> 00:58:32,330
would be to say well if you have an

00:58:29,390 --> 00:58:34,550
implicit conversion from A to B then you

00:58:32,330 --> 00:58:36,680
should require that either the

00:58:34,550 --> 00:58:38,240
conversion is defined in the package

00:58:36,680 --> 00:58:40,130
where a is defined

00:58:38,240 --> 00:58:42,380
well then presumably they know what they

00:58:40,130 --> 00:58:49,250
do or in the package where B is defined

00:58:42,380 --> 00:58:51,440
or the conversion is itself hidden in a

00:58:49,250 --> 00:58:54,410
package then again I say well if you

00:58:51,440 --> 00:58:56,420
want to do dirt then do it but at least

00:58:54,410 --> 00:58:58,670
it doesn't leak out out of your package

00:58:56,420 --> 00:59:00,830
so that's sort of the rules so it has to

00:58:58,670 --> 00:59:03,200
be essentially the conversions we can't

00:59:00,830 --> 00:59:05,330
have a third package that says I can

00:59:03,200 --> 00:59:07,340
work from A to B like from string to end

00:59:05,330 --> 00:59:09,260
and I'm public for everyone to see that

00:59:07,340 --> 00:59:10,120
should be an error at least the style

00:59:09,260 --> 00:59:11,890
error we

00:59:10,120 --> 00:59:15,400
have to define what these style errors

00:59:11,890 --> 00:59:18,070
are the second thing is probably also

00:59:15,400 --> 00:59:22,330
something that that a lot of people have

00:59:18,070 --> 00:59:24,550
come across and I found myself a lot of

00:59:22,330 --> 00:59:27,730
times did during because well should I

00:59:24,550 --> 00:59:31,480
write X s dot map F or XS space map

00:59:27,730 --> 00:59:35,200
space s maybe just a quick poll who here

00:59:31,480 --> 00:59:39,040
uses dot syntax for things like that we

00:59:35,200 --> 00:59:40,780
use a space syntax ok a little bit more

00:59:39,040 --> 00:59:43,030
than in New York but I'm very glad that

00:59:40,780 --> 00:59:45,550
the majority of use if you still use

00:59:43,030 --> 00:59:47,170
this dot syntax I use space syntax for a

00:59:45,550 --> 00:59:49,450
long time and now I'm coming to regret

00:59:47,170 --> 00:59:51,850
it because I think it's just essentially

00:59:49,450 --> 00:59:56,950
it gives me too much choice in picking

00:59:51,850 --> 00:59:59,440
one or the other so the because there

00:59:56,950 --> 01:00:00,910
are a lot of concerns so you can hear

00:59:59,440 --> 01:00:03,940
you might say well this looks kind of

01:00:00,910 --> 01:00:05,710
neat but what about this so that is

01:00:03,940 --> 01:00:07,420
clearly structured that is much less

01:00:05,710 --> 01:00:09,400
structured in particular if the F gets

01:00:07,420 --> 01:00:10,900
longer than suddenly you get long

01:00:09,400 --> 01:00:13,090
sentences where you don't know what the

01:00:10,900 --> 01:00:15,670
subject and what their work is anymore

01:00:13,090 --> 01:00:18,490
on the other hand what about this and

01:00:15,670 --> 01:00:20,680
that so I think yeah I definitely would

01:00:18,490 --> 01:00:22,930
prefer that syntax because the min is in

01:00:20,680 --> 01:00:25,090
a sense an operator and it's commutative

01:00:22,930 --> 01:00:27,580
and it just doesn't make sense to have a

01:00:25,090 --> 01:00:29,170
syntax that sort of emphasizes the left

01:00:27,580 --> 01:00:31,180
argument over the right one it's

01:00:29,170 --> 01:00:32,770
community of both arguments are treated

01:00:31,180 --> 01:00:34,450
the same way so you see there's a

01:00:32,770 --> 01:00:36,370
difficult trade-off and for awhile I've

01:00:34,450 --> 01:00:39,640
come up sort of with an ironclad rule

01:00:36,370 --> 01:00:41,800
when to write what and found that cannot

01:00:39,640 --> 01:00:44,380
be a language imposed rules so a

01:00:41,800 --> 01:00:46,510
proposal would be to I think that's sort

01:00:44,380 --> 01:00:48,880
of taking an idea from but that was also

01:00:46,510 --> 01:00:51,010
it's also in Copeland to add an

01:00:48,880 --> 01:00:52,960
annotation in fix that indicates that an

01:00:51,010 --> 01:00:56,620
operator is supposed to be used in fix

01:00:52,960 --> 01:00:58,960
so if I want to say men should be used

01:00:56,620 --> 01:01:01,030
in fix I put it in the definition site

01:00:58,960 --> 01:01:04,510
and then I should make it a style error

01:01:01,030 --> 01:01:09,010
if an operator is used in the wrong mode

01:01:04,510 --> 01:01:11,170
so X minus y would be okay but X as map

01:01:09,010 --> 01:01:13,030
as would give you a warning

01:01:11,170 --> 01:01:15,220
so that way at least we get it's

01:01:13,030 --> 01:01:17,680
actually more uniformity over code bases

01:01:15,220 --> 01:01:19,360
the designer of a library decides how

01:01:17,680 --> 01:01:21,700
these things should be used in fix or

01:01:19,360 --> 01:01:23,170
operator and then essentially the users

01:01:21,700 --> 01:01:27,640
of the library would have to follow

01:01:23,170 --> 01:01:29,410
that or gets get these stylus once we

01:01:27,640 --> 01:01:31,059
are there then we can address the

01:01:29,410 --> 01:01:35,230
essentially another thing which is has

01:01:31,059 --> 01:01:36,910
been a big issue in Scala an issue

01:01:35,230 --> 01:01:39,579
that's actually receding I think we have

01:01:36,910 --> 01:01:41,440
much less disagreement about symbolic

01:01:39,579 --> 01:01:44,109
operators now than we had two or three

01:01:41,440 --> 01:01:47,170
years ago so the question is essentially

01:01:44,109 --> 01:01:49,359
what methods when to use operator names

01:01:47,170 --> 01:01:52,270
or methods and I think a lot of us went

01:01:49,359 --> 01:01:54,579
over through this face of exuberance

01:01:52,270 --> 01:01:56,799
where is our symbolic operators are cool

01:01:54,579 --> 01:01:59,109
they make code so precise so concise and

01:01:56,799 --> 01:02:01,270
then afterwards we've come to regret it

01:01:59,109 --> 01:02:03,040
because enough people told us what is

01:02:01,270 --> 01:02:08,680
this weird twiddle thing here I don't

01:02:03,040 --> 01:02:10,450
even know how to pronounce it so so the

01:02:08,680 --> 01:02:12,640
idea here would be that to say well if

01:02:10,450 --> 01:02:15,579
you write a symbolic operator what you

01:02:12,640 --> 01:02:18,700
also should do is essentially it's an

01:02:15,579 --> 01:02:22,960
operator use in fix and then essentially

01:02:18,700 --> 01:02:24,970
give it a legible name as an argument to

01:02:22,960 --> 01:02:27,339
this annotation so we could require that

01:02:24,970 --> 01:02:29,650
so to say well if I write plus equals

01:02:27,339 --> 01:02:31,990
that's a well-known operator and in the

01:02:29,650 --> 01:02:34,750
future you also have to explain what it

01:02:31,990 --> 01:02:38,020
is and write append and and I would

01:02:34,750 --> 01:02:39,819
would challenge the scholars at library

01:02:38,020 --> 01:02:42,839
to come up with essentially Drupal names

01:02:39,819 --> 01:02:42,839
for all their operators

01:02:46,910 --> 01:02:50,730
but I think it's good because it would

01:02:49,109 --> 01:02:53,160
at least help this argument how to

01:02:50,730 --> 01:02:54,990
pronounce things right so I have to

01:02:53,160 --> 01:02:56,580
pronounce things so we should and we

01:02:54,990 --> 01:02:59,339
should agree how to pronounce them of

01:02:56,580 --> 01:03:03,540
course so and of course if you want to

01:02:59,339 --> 01:03:06,930
just pronounce them X Y Z X 13 then

01:03:03,540 --> 01:03:08,910
that's up to you but then that's

01:03:06,930 --> 01:03:10,859
essentially as a as a language designer

01:03:08,910 --> 01:03:12,900
and compiler writer you can't really

01:03:10,859 --> 01:03:14,760
force people to use good names but you

01:03:12,900 --> 01:03:17,849
can give them the hooks that sort of

01:03:14,760 --> 01:03:20,880
encourage them to do that so it's a

01:03:17,849 --> 01:03:22,980
conclusion I think what we are seeing is

01:03:20,880 --> 01:03:26,280
that the well Apollo world as a whole is

01:03:22,980 --> 01:03:29,010
moving to Scala or more specifically

01:03:26,280 --> 01:03:32,190
this space cala occupies so functional

01:03:29,010 --> 01:03:34,530
strict pragmatics is very much sort of

01:03:32,190 --> 01:03:36,330
the alter du jour it's very much sort of

01:03:34,530 --> 01:03:39,270
the trend where a lot of languages are

01:03:36,330 --> 01:03:40,890
going and what we want to make sure and

01:03:39,270 --> 01:03:44,430
I personally want to make sure is to

01:03:40,890 --> 01:03:46,380
that Scala remains state of the art not

01:03:44,430 --> 01:03:48,510
because I care that much that scarra

01:03:46,380 --> 01:03:50,220
needs to be super popular and needs to

01:03:48,510 --> 01:03:52,440
be on top but because I think there are

01:03:50,220 --> 01:03:53,940
a lot of exciting new developments in

01:03:52,440 --> 01:03:55,770
the language space and in the

01:03:53,940 --> 01:03:58,800
programming space in programming method

01:03:55,770 --> 01:04:01,020
space and Scala is a great foundation to

01:03:58,800 --> 01:04:03,359
implement these things so we should

01:04:01,020 --> 01:04:05,730
essentially take advantage of that

01:04:03,359 --> 01:04:08,160
foundation and do great stuff at the

01:04:05,730 --> 01:04:09,960
same time I also agree that evolution is

01:04:08,160 --> 01:04:12,089
a scary thing and we have to manage it

01:04:09,960 --> 01:04:13,710
carefully so that will be the challenge

01:04:12,089 --> 01:04:16,550
that we're facing over the next year's

01:04:13,710 --> 01:04:16,550
thank you

01:04:22,609 --> 01:04:24,670
you

01:04:32,780 --> 01:04:34,840

YouTube URL: https://www.youtube.com/watch?v=GHzWqJKFCk4


