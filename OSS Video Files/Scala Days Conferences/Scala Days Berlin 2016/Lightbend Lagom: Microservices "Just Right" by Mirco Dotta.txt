Title: Lightbend Lagom: Microservices "Just Right" by Mirco Dotta
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
Microservices architecture are becoming a de-facto industry standard, but are you satisfied with the current state of the art? We are not, as we believe that building microservices today is more challenging than it should be. Lagom is here to take on this challenge. First, Lagom is opinionated and it will take some of the hard decisions for you, guiding you to produce microservices that adheres to the Reactive tenents. Second, Lagom was built from the ground up around you, the developer, to push your productivity to the next level. If you are familiar with the Play Framework's development environment, imagine that but tuned for building microservices; we are sure you are going to love it! Third, Lagom comes with batteries included for deploying in production: going from development to production could not be easier.
In this session you will get an introduction to the Lightbend Lagom framework. There will be code and live demos to show you in practice how it works and what you can do with it, making you fully equipped to build your next microservices with Lightbend Lagom.
Captions: 
	00:00:04,350 --> 00:00:09,100
today I'm extremely excited to present

00:00:07,180 --> 00:00:13,600
you our latest open-source framework

00:00:09,100 --> 00:00:16,180
like Ben McGann Lagaan is a framework

00:00:13,600 --> 00:00:19,810
for building reacting micro services on

00:00:16,180 --> 00:00:21,460
the JVM so maybe you wonder why we pick

00:00:19,810 --> 00:00:24,249
that name so let's start by that and

00:00:21,460 --> 00:00:26,710
then get into the technical details so

00:00:24,249 --> 00:00:28,749
legume is a Swedish word and as you may

00:00:26,710 --> 00:00:31,599
know we get a lot of people that are

00:00:28,749 --> 00:00:33,760
Swedish in like then but that's not the

00:00:31,599 --> 00:00:35,289
reason what being like I'm actually so

00:00:33,760 --> 00:00:39,910
Lego means the Swedish word meaning

00:00:35,289 --> 00:00:42,789
adequate sufficient just right depending

00:00:39,910 --> 00:00:44,920
maybe on your culture being adequate

00:00:42,789 --> 00:00:47,109
could also be a negative quality it

00:00:44,920 --> 00:00:49,629
doesn't always feel like it doesn't

00:00:47,109 --> 00:00:52,210
always look like a positive thing but

00:00:49,629 --> 00:00:55,719
actually for a Swedish to be like on us

00:00:52,210 --> 00:00:59,109
definitely a positive attitude and I

00:00:55,719 --> 00:01:01,960
can't really explain you what it really

00:00:59,109 --> 00:01:05,980
means to a Swedish person to be like all

00:01:01,960 --> 00:01:09,160
but some extent means to be just not too

00:01:05,980 --> 00:01:11,530
small or not too little not to be you

00:01:09,160 --> 00:01:15,130
just want to be humble and somewhat

00:01:11,530 --> 00:01:17,890
right and that is pretty much what Lego

00:01:15,130 --> 00:01:19,750
means and we thought that Lagoon was a

00:01:17,890 --> 00:01:22,390
really good name for a micro services

00:01:19,750 --> 00:01:25,330
framework because often people get

00:01:22,390 --> 00:01:27,370
focused on the micro part of the micro

00:01:25,330 --> 00:01:29,020
services name when they discuss micro

00:01:27,370 --> 00:01:32,050
service and that is really not the

00:01:29,020 --> 00:01:36,070
essence of what micro services is legume

00:01:32,050 --> 00:01:38,950
is about right-sized services you should

00:01:36,070 --> 00:01:40,990
be focusing on finding the right binary

00:01:38,950 --> 00:01:43,390
requirements of your services you should

00:01:40,990 --> 00:01:46,150
be thinking about what needs to be

00:01:43,390 --> 00:01:47,920
together and what actually can be

00:01:46,150 --> 00:01:49,930
separate so that doesn't need to depend

00:01:47,920 --> 00:01:55,000
on each other so you should try to build

00:01:49,930 --> 00:01:56,920
our own services here's yet enough we

00:01:55,000 --> 00:01:59,440
start with a rational why did we create

00:01:56,920 --> 00:02:01,900
it like on why did we create them yet

00:01:59,440 --> 00:02:04,540
another micro services framework and

00:02:01,900 --> 00:02:07,750
then we'll dive into its main components

00:02:04,540 --> 00:02:10,840
the development environment the service

00:02:07,750 --> 00:02:11,890
API and the persistence API my goal with

00:02:10,840 --> 00:02:14,290
the presentation is

00:02:11,890 --> 00:02:16,720
to give you a broad overview about all

00:02:14,290 --> 00:02:18,730
the different components that make up my

00:02:16,720 --> 00:02:21,370
goal so that then you should be fully

00:02:18,730 --> 00:02:22,569
equipped to just go and explore the

00:02:21,370 --> 00:02:25,720
sample application that we have

00:02:22,569 --> 00:02:28,510
available and start from there and build

00:02:25,720 --> 00:02:30,820
your first sample app using Lego and at

00:02:28,510 --> 00:02:35,380
the end I'll also discussed how you can

00:02:30,820 --> 00:02:37,600
run in production Lego so like all gives

00:02:35,380 --> 00:02:40,510
you an opinionated view on now you

00:02:37,600 --> 00:02:43,450
should be building micro-services that

00:02:40,510 --> 00:02:47,080
adhere to the reactive tenant

00:02:43,450 --> 00:02:50,680
legume is built with akka and white so

00:02:47,080 --> 00:02:51,640
it is fully asynchronous and unblocking

00:02:50,680 --> 00:02:54,459
a t-score

00:02:51,640 --> 00:02:57,400
and furthermore we advocate the use of

00:02:54,459 --> 00:02:59,110
even sourcing and secure s and the

00:02:57,400 --> 00:03:02,110
reason for doing that is because we feel

00:02:59,110 --> 00:03:05,260
and in our experience it is the case

00:03:02,110 --> 00:03:08,709
that it is easier with this architecture

00:03:05,260 --> 00:03:12,910
pattern to build systems that are truly

00:03:08,709 --> 00:03:15,970
reactive another point that we actually

00:03:12,910 --> 00:03:17,739
spend a considerable considerable amount

00:03:15,970 --> 00:03:20,290
of time designing is the development

00:03:17,739 --> 00:03:22,510
experience we want you to be at the

00:03:20,290 --> 00:03:25,030
center of the own experience and it

00:03:22,510 --> 00:03:30,130
should be that simple to run your

00:03:25,030 --> 00:03:31,989
services while right developing it so we

00:03:30,130 --> 00:03:34,870
have built a development environment

00:03:31,989 --> 00:03:36,610
that to some extent feels like light if

00:03:34,870 --> 00:03:39,100
you're familiar with play there's gonna

00:03:36,610 --> 00:03:41,049
be things like pop reload whenever you

00:03:39,100 --> 00:03:43,150
make a change in your services so that

00:03:41,049 --> 00:03:44,140
you never have to switch from your

00:03:43,150 --> 00:03:46,810
prefer

00:03:44,140 --> 00:03:48,310
you just keep coding and underneath the

00:03:46,810 --> 00:03:50,829
system will take care of reloading

00:03:48,310 --> 00:03:53,049
things so that if one you can just open

00:03:50,829 --> 00:03:55,360
the browser and test or yeah from the

00:03:53,049 --> 00:03:59,380
common line and just test what you just

00:03:55,360 --> 00:04:01,150
changed there's gonna be not Street that

00:03:59,380 --> 00:04:04,600
you like to maintain across your teams

00:04:01,150 --> 00:04:08,829
and possibly across different machine

00:04:04,600 --> 00:04:11,950
you we we have seen people having these

00:04:08,829 --> 00:04:14,109
horrible scripts to maintain for all

00:04:11,950 --> 00:04:16,060
different kind of environments and that

00:04:14,109 --> 00:04:18,549
usually never works when there is a new

00:04:16,060 --> 00:04:20,959
guy coming to your project and that he

00:04:18,549 --> 00:04:23,060
has a slightly different environment and

00:04:20,959 --> 00:04:25,310
maybe four days before it can actually

00:04:23,060 --> 00:04:26,539
be up and running on your project well

00:04:25,310 --> 00:04:28,669
with Lagaan

00:04:26,539 --> 00:04:31,460
it should take literally minutes thread

00:04:28,669 --> 00:04:34,539
a new guy in your team being able to be

00:04:31,460 --> 00:04:37,220
productive and last but not least

00:04:34,539 --> 00:04:39,729
inter-service communication elegant just

00:04:37,220 --> 00:04:42,500
works it means that it is really simple

00:04:39,729 --> 00:04:44,300
for you to add one service to

00:04:42,500 --> 00:04:45,020
communicate with another and we'll see

00:04:44,300 --> 00:04:48,979
how that works

00:04:45,020 --> 00:04:52,880
and finally it actually doesn't just

00:04:48,979 --> 00:04:55,039
takes care of the development it doesn't

00:04:52,880 --> 00:04:57,830
just help you development systems or

00:04:55,039 --> 00:05:00,500
micro services it also helps you running

00:04:57,830 --> 00:05:02,270
them introduction so I'd say that when

00:05:00,500 --> 00:05:03,740
you evaluate a new micro services

00:05:02,270 --> 00:05:05,330
framework one thing that you should be

00:05:03,740 --> 00:05:07,820
paying attention since the very

00:05:05,330 --> 00:05:09,710
beginning is are you gonna run these

00:05:07,820 --> 00:05:11,900
things in production you should ask

00:05:09,710 --> 00:05:13,759
yourself question like are your service

00:05:11,900 --> 00:05:18,949
is going to locate that communicate with

00:05:13,759 --> 00:05:21,919
each other are they going to are will

00:05:18,949 --> 00:05:23,449
you monitor them how will you upgrade

00:05:21,919 --> 00:05:25,180
that right there are plenty of questions

00:05:23,449 --> 00:05:27,409
that you need to ask yourself and

00:05:25,180 --> 00:05:29,690
willecombe we also have an answer to

00:05:27,409 --> 00:05:32,090
that and that is light bank conductor

00:05:29,690 --> 00:05:35,960
it's our orchestration tool I talk a bit

00:05:32,090 --> 00:05:39,050
more about this toward you so under they

00:05:35,960 --> 00:05:42,199
would it's we're using SBT so you're

00:05:39,050 --> 00:05:45,169
liable as an SBT build file we're using

00:05:42,199 --> 00:05:47,060
SBT also because it's an extremely

00:05:45,169 --> 00:05:48,740
powerful tool if you want to build a

00:05:47,060 --> 00:05:50,389
developer experience a development

00:05:48,740 --> 00:05:53,750
environment and that's what we are we

00:05:50,389 --> 00:05:55,460
did it in the gaunt as I mentioned we

00:05:53,750 --> 00:05:57,440
use play and I can specifically play to

00:05:55,460 --> 00:05:59,060
the five and acted to the for the

00:05:57,440 --> 00:06:03,560
components of fact that were using is

00:05:59,060 --> 00:06:06,199
clustering streams and persistence

00:06:03,560 --> 00:06:09,229
Cassandra is the default data store I

00:06:06,199 --> 00:06:10,580
just emphasize that that doesn't mean

00:06:09,229 --> 00:06:12,020
that you can't use lagoon with a

00:06:10,580 --> 00:06:14,120
different data store you can use

00:06:12,020 --> 00:06:16,039
whatever data store what but Cassandra

00:06:14,120 --> 00:06:17,060
is the default and we see and I've

00:06:16,039 --> 00:06:19,490
showed you that we build some

00:06:17,060 --> 00:06:22,030
abstraction around it to simplify doing

00:06:19,490 --> 00:06:24,979
event sourcing and security

00:06:22,030 --> 00:06:26,150
Jackson is used for JSON sterilization

00:06:24,979 --> 00:06:30,460
and Jews for the

00:06:26,150 --> 00:06:32,570
Injection just like imply enough light

00:06:30,460 --> 00:06:38,229
it's time to have a look at the

00:06:32,570 --> 00:06:40,760
development environment so here at a

00:06:38,229 --> 00:06:43,630
cheaper allocation that we bill is a

00:06:40,760 --> 00:06:48,350
twitter-like application basically and

00:06:43,630 --> 00:06:51,830
just type SPT this will know the SPT

00:06:48,350 --> 00:06:54,139
console and once it's loaded we will be

00:06:51,830 --> 00:06:57,680
able to see how you can with a single

00:06:54,139 --> 00:06:59,630
task so with a single command you can

00:06:57,680 --> 00:07:01,699
run all your services you don't have to

00:06:59,630 --> 00:07:07,520
do any this is actually out a new guy

00:07:01,699 --> 00:07:14,900
coming to your project but do it yes yes

00:07:07,520 --> 00:07:20,810
sorry is that is it better then this is

00:07:14,900 --> 00:07:23,180
even better I guess good so the final is

00:07:20,810 --> 00:07:24,680
the one thing you want to remember when

00:07:23,180 --> 00:07:25,760
you are in the development environment

00:07:24,680 --> 00:07:28,850
of logoff

00:07:25,760 --> 00:07:30,680
so I'll just type run all and hit enter

00:07:28,850 --> 00:07:32,419
and as you can see it's going to start

00:07:30,680 --> 00:07:34,970
doing stuff so what's happening

00:07:32,419 --> 00:07:37,190
underneath is that we're going to start

00:07:34,970 --> 00:07:40,400
all the different components that are

00:07:37,190 --> 00:07:42,500
needed by your services so in this case

00:07:40,400 --> 00:07:46,039
we're think we have four or five

00:07:42,500 --> 00:07:48,620
services defined in our lagaan project

00:07:46,039 --> 00:07:50,810
and so because some of them for instance

00:07:48,620 --> 00:07:54,349
meet Cassandra what's happening at the

00:07:50,810 --> 00:07:55,970
very beginning what's happening at the

00:07:54,349 --> 00:07:57,740
very beginning is that we're starting on

00:07:55,970 --> 00:07:59,750
the bedded Cassandra server so that you

00:07:57,740 --> 00:08:02,990
don't have to install one ago for your

00:07:59,750 --> 00:08:04,400
local machine once that is started it

00:08:02,990 --> 00:08:06,289
gives you the address on which you can

00:08:04,400 --> 00:08:07,669
reach it and right after that we start

00:08:06,289 --> 00:08:09,770
the service locator and the service

00:08:07,669 --> 00:08:12,289
gateway these are two components that we

00:08:09,770 --> 00:08:14,060
built for expressively for the

00:08:12,289 --> 00:08:16,280
development environment they're not to

00:08:14,060 --> 00:08:17,840
be used in production in production as I

00:08:16,280 --> 00:08:20,180
said there is conductor and it already

00:08:17,840 --> 00:08:22,130
takes care of these things it already it

00:08:20,180 --> 00:08:25,099
already has a service locator you don't

00:08:22,130 --> 00:08:26,990
have to worry about these things but in

00:08:25,099 --> 00:08:28,760
the Battlement we have started this

00:08:26,990 --> 00:08:30,710
service locator and the reason for

00:08:28,760 --> 00:08:32,120
having a service locator is because you

00:08:30,710 --> 00:08:32,780
want your services to be able to

00:08:32,120 --> 00:08:35,419
communicate

00:08:32,780 --> 00:08:38,510
with each other right so what happens is

00:08:35,419 --> 00:08:40,610
that whenever we're gonna start these

00:08:38,510 --> 00:08:43,310
different services which you can see on

00:08:40,610 --> 00:08:44,780
different ports they're started the

00:08:43,310 --> 00:08:47,210
first thing they're going to be doing is

00:08:44,780 --> 00:08:50,180
registering themselves so their name and

00:08:47,210 --> 00:08:52,280
their IP to the service locator so that

00:08:50,180 --> 00:08:54,110
later on I'll show you what is the API

00:08:52,280 --> 00:08:55,850
for having services to communicate one

00:08:54,110 --> 00:08:57,890
to the other but basically what's gonna

00:08:55,850 --> 00:09:00,650
happen underneath is that these services

00:08:57,890 --> 00:09:02,240
will be contacting the service locator

00:09:00,650 --> 00:09:03,740
and say hey I want to talk to this guy

00:09:02,240 --> 00:09:05,690
can you give me his address

00:09:03,740 --> 00:09:07,910
and once I have the others I can

00:09:05,690 --> 00:09:10,250
actually call the endpoints it goes by

00:09:07,910 --> 00:09:12,290
that service and it's all happening

00:09:10,250 --> 00:09:15,550
underneath you don't have to do anything

00:09:12,290 --> 00:09:19,040
it's all taken care of for you

00:09:15,550 --> 00:09:21,820
so services are are up and running so

00:09:19,040 --> 00:09:25,990
let's see how these application works

00:09:21,820 --> 00:09:25,990
let me take a bigger

00:09:29,170 --> 00:09:36,189
so here it is it's a very simple

00:09:32,290 --> 00:09:41,350
twitter-like application I just have a

00:09:36,189 --> 00:09:43,989
couple tweets I compose new messages so

00:09:41,350 --> 00:09:46,779
yes i'm yorker i say hey everybody

00:09:43,989 --> 00:09:50,259
you can add friends i can look out and

00:09:46,779 --> 00:09:53,429
you can see the feed of different user

00:09:50,259 --> 00:09:57,339
if you want so very simple

00:09:53,429 --> 00:09:58,929
good let's get back to so one thing i

00:09:57,339 --> 00:10:01,359
want to showcase now is that I'm gonna

00:09:58,929 --> 00:10:03,910
make a change in the code and you see

00:10:01,359 --> 00:10:05,049
that it will automatically be a big big

00:10:03,910 --> 00:10:07,869
fat by the development environment

00:10:05,049 --> 00:10:10,839
you're the service that I changed will

00:10:07,869 --> 00:10:12,069
be recompiled and reloaded automatically

00:10:10,839 --> 00:10:13,869
for you you don't have to do anything

00:10:12,069 --> 00:10:17,529
you see that there's gonna be a change

00:10:13,869 --> 00:10:21,279
when i refresh the application so again

00:10:17,529 --> 00:10:26,379
for the purpose of showing you all these

00:10:21,279 --> 00:10:29,169
works I just have a very simple hello so

00:10:26,379 --> 00:10:30,790
the moment I say I'll just switch to the

00:10:29,169 --> 00:10:32,949
comment line and you see that the

00:10:30,790 --> 00:10:37,480
changes being picked up so it's being

00:10:32,949 --> 00:10:43,480
precompiled and it's been really so

00:10:37,480 --> 00:10:45,610
right now if I reload this page and I

00:10:43,480 --> 00:10:48,279
need to reload it only because well the

00:10:45,610 --> 00:10:49,660
hello print line that I added it would

00:10:48,279 --> 00:10:50,139
be triggered only at the moment I

00:10:49,660 --> 00:10:52,269
reloaded

00:10:50,139 --> 00:10:56,019
that's why otherwise if it was something

00:10:52,269 --> 00:10:57,669
that would be I'd say trigger eagerly by

00:10:56,019 --> 00:11:00,489
the application of reload we would have

00:10:57,669 --> 00:11:03,819
already seen the side effect so now I've

00:11:00,489 --> 00:11:06,100
reloaded and if I go back to my command

00:11:03,819 --> 00:11:08,079
line I see that the alone print line is

00:11:06,100 --> 00:11:09,699
there so that really means that you

00:11:08,079 --> 00:11:11,739
never need to focus on that command line

00:11:09,699 --> 00:11:15,480
you're listening the code and possibly

00:11:11,739 --> 00:11:18,579
in the browser if you're testing things

00:11:15,480 --> 00:11:19,119
good so there are a couple of other

00:11:18,579 --> 00:11:21,879
things

00:11:19,119 --> 00:11:26,739
I want you to notice one is that we're

00:11:21,879 --> 00:11:32,760
actually accessing our service through

00:11:26,739 --> 00:11:35,260
localhost not 9000 so I just

00:11:32,760 --> 00:11:38,110
so we had a service we have a service

00:11:35,260 --> 00:11:40,810
gateway that is being start on localhost

00:11:38,110 --> 00:11:44,590
9000 as you can see there so the service

00:11:40,810 --> 00:11:47,320
for the gateway is just I say a proxy to

00:11:44,590 --> 00:11:50,140
your services so what it means is that

00:11:47,320 --> 00:11:54,070
you have a stable port that you can use

00:11:50,140 --> 00:11:56,830
for accessing all all all your services

00:11:54,070 --> 00:11:59,590
that are being exposed on different

00:11:56,830 --> 00:12:01,570
ports as you can see there like there

00:11:59,590 --> 00:12:03,310
are all these random ports that are

00:12:01,570 --> 00:12:05,560
being used and you don't actually want

00:12:03,310 --> 00:12:06,700
to remember the sports for instance you

00:12:05,560 --> 00:12:08,950
can imagine that you have an application

00:12:06,700 --> 00:12:10,480
where you want insert data in this

00:12:08,950 --> 00:12:12,940
application before maybe running some

00:12:10,480 --> 00:12:14,620
tests from the common line well you

00:12:12,940 --> 00:12:16,390
don't want to remember the sports

00:12:14,620 --> 00:12:17,950
because those scripts you may want to

00:12:16,390 --> 00:12:20,410
share them across your team because

00:12:17,950 --> 00:12:22,450
they're just useful to load the testing

00:12:20,410 --> 00:12:25,480
environment and so you can just do that

00:12:22,450 --> 00:12:27,280
through the service gateway and another

00:12:25,480 --> 00:12:29,380
thing I want you to notice is that the

00:12:27,280 --> 00:12:31,930
actual port that are being selected for

00:12:29,380 --> 00:12:33,520
running the project are going to be

00:12:31,930 --> 00:12:36,070
consistent not just in your machine so

00:12:33,520 --> 00:12:38,170
meaning that if I stop the development

00:12:36,070 --> 00:12:40,030
environment and I quit running it's

00:12:38,170 --> 00:12:42,720
still gonna be the same port assuming

00:12:40,030 --> 00:12:46,420
it's open it's a assuming it's available

00:12:42,720 --> 00:12:48,700
if and and the other thing is that

00:12:46,420 --> 00:12:51,550
across your team actually the same port

00:12:48,700 --> 00:12:53,920
is selected for the same service this

00:12:51,550 --> 00:12:55,510
again it's all taken care for you by the

00:12:53,920 --> 00:12:56,860
development environment you don't have

00:12:55,510 --> 00:12:59,770
to think about these things but I

00:12:56,860 --> 00:13:02,290
thought it was nice to know and other

00:12:59,770 --> 00:13:04,450
random things is that of course you have

00:13:02,290 --> 00:13:06,670
lots of flexibility for instance if you

00:13:04,450 --> 00:13:08,500
want to run your own local Cassandra you

00:13:06,670 --> 00:13:10,150
can do that and you can just turn off

00:13:08,500 --> 00:13:12,370
the one that is embedded and there are

00:13:10,150 --> 00:13:19,360
all sort of flights that you can go in

00:13:12,370 --> 00:13:23,190
and cover in the SBT plugin good so

00:13:19,360 --> 00:13:23,190
let's get back to the presentation

00:13:23,560 --> 00:13:32,300
is there any question about the

00:13:25,640 --> 00:13:34,280
development environment or so this

00:13:32,300 --> 00:13:37,070
actually got prompt project shouldn't be

00:13:34,280 --> 00:13:40,790
highlighted so just look at it as it as

00:13:37,070 --> 00:13:43,700
if it was annihilated so the idea is

00:13:40,790 --> 00:13:46,820
this actually gives you the anatomy of a

00:13:43,700 --> 00:13:47,930
lagoon project so what you see the one

00:13:46,820 --> 00:13:50,390
thing that I really want to emphasize

00:13:47,930 --> 00:13:52,850
and that is why it is emphasized is that

00:13:50,390 --> 00:13:55,070
for every service you like an API

00:13:52,850 --> 00:13:55,970
project and an implementation project

00:13:55,070 --> 00:13:58,520
yay

00:13:55,970 --> 00:13:59,810
API project will declare the interface

00:13:58,520 --> 00:14:02,150
of your service

00:13:59,810 --> 00:14:04,070
so the endpoints and now these endpoints

00:14:02,150 --> 00:14:05,720
will you know what is the serialization

00:14:04,070 --> 00:14:07,880
that you're going to be using and all

00:14:05,720 --> 00:14:09,980
these I would say make the data about

00:14:07,880 --> 00:14:12,110
your service and all your services can

00:14:09,980 --> 00:14:13,100
be accessed an implementation project

00:14:12,110 --> 00:14:15,410
well it actually provides

00:14:13,100 --> 00:14:16,610
implementations of that API so you

00:14:15,410 --> 00:14:20,420
always said that the implementation

00:14:16,610 --> 00:14:22,700
project depends on the API project and

00:14:20,420 --> 00:14:25,760
in this case we only have one service in

00:14:22,700 --> 00:14:30,620
this LaCount project so the other were

00:14:25,760 --> 00:14:32,900
service but in you know you led more and

00:14:30,620 --> 00:14:35,390
more services in your project and you'll

00:14:32,900 --> 00:14:37,430
just continue adding them within the

00:14:35,390 --> 00:14:40,160
same build file and the reason why you

00:14:37,430 --> 00:14:41,990
want to try to build to add them within

00:14:40,160 --> 00:14:44,680
the same bill file is because you get

00:14:41,990 --> 00:14:47,150
this really nice development experience

00:14:44,680 --> 00:14:49,460
meaning that you have a single command

00:14:47,150 --> 00:14:51,170
to run all of them and that is really

00:14:49,460 --> 00:14:53,720
convenient of course there is a point

00:14:51,170 --> 00:14:56,420
after which one machine won't make it

00:14:53,720 --> 00:14:58,190
like it's just too much resources that

00:14:56,420 --> 00:15:01,700
are gonna be consumed and there are ways

00:14:58,190 --> 00:15:04,900
to split it and still be able to use the

00:15:01,700 --> 00:15:08,030
development environment that we provided

00:15:04,900 --> 00:15:10,250
and a couple of things I don't I didn't

00:15:08,030 --> 00:15:14,210
mention about the legume build is that

00:15:10,250 --> 00:15:17,210
we're using skeletor 11 and Java 8 Java

00:15:14,210 --> 00:15:19,340
8 well for many reason but a simple one

00:15:17,210 --> 00:15:21,830
is that what I cut to the foreign supply

00:15:19,340 --> 00:15:25,580
to the file use Java 8 so yet

00:15:21,830 --> 00:15:27,200
anyway and even though we wanted to ask

00:15:25,580 --> 00:15:30,890
a litter 11 for the moment so not

00:15:27,200 --> 00:15:33,590
support for Scalla to that time all

00:15:30,890 --> 00:15:39,140
right let's get into the service of the

00:15:33,590 --> 00:15:41,480
eye so we want to create a really simple

00:15:39,140 --> 00:15:42,980
hello world service so this is what

00:15:41,480 --> 00:15:46,040
we're gonna be doing here

00:15:42,980 --> 00:15:48,410
so the first thing we want to do is we

00:15:46,040 --> 00:15:50,030
have a noir API project as I mentioned

00:15:48,410 --> 00:15:52,850
before and in that project we're gonna

00:15:50,030 --> 00:15:56,030
add this single trait we named it a low

00:15:52,850 --> 00:15:59,750
service that extends the legumes service

00:15:56,030 --> 00:16:01,160
tray so far so good and now we need to

00:15:59,750 --> 00:16:03,590
provide an implementation for this

00:16:01,160 --> 00:16:05,930
descriptor method that is inherited from

00:16:03,590 --> 00:16:09,860
the legume service interface and a

00:16:05,930 --> 00:16:12,740
descriptor it's just basically providing

00:16:09,860 --> 00:16:14,750
the name of your service together with

00:16:12,740 --> 00:16:17,660
the set of ten points that your service

00:16:14,750 --> 00:16:20,690
is exposing apple with metadata about

00:16:17,660 --> 00:16:21,110
other services and it's calls are to be

00:16:20,690 --> 00:16:24,410
served

00:16:21,110 --> 00:16:28,010
so for creating a descriptor reasons we

00:16:24,410 --> 00:16:30,020
have fluent API so you start by

00:16:28,010 --> 00:16:32,990
providing the name of your service in

00:16:30,020 --> 00:16:35,690
this case it's and the service and then

00:16:32,990 --> 00:16:37,490
you have this call to wit calls and this

00:16:35,690 --> 00:16:40,730
is where you provide the set of

00:16:37,490 --> 00:16:43,340
endpoints that you want to expose here

00:16:40,730 --> 00:16:45,710
we have only one in this case it's they

00:16:43,340 --> 00:16:48,020
can be reached at the static pipe hello

00:16:45,710 --> 00:16:49,460
that is why we're using named Cole then

00:16:48,020 --> 00:16:52,150
I'll show you something different it

00:16:49,460 --> 00:16:54,830
will get clearer as we get through the

00:16:52,150 --> 00:16:56,090
the talk but at the moment named Cole

00:16:54,830 --> 00:17:00,440
just means that I want to expose a

00:16:56,090 --> 00:17:02,150
static but that Pat is a low and then on

00:17:00,440 --> 00:17:05,360
the right hand side I'm at the second

00:17:02,150 --> 00:17:06,800
argument I'm passing the method so if

00:17:05,360 --> 00:17:09,709
you're again if you're familiar with

00:17:06,800 --> 00:17:12,140
play it could be your action method that

00:17:09,709 --> 00:17:15,100
you want to execute when that static pad

00:17:12,140 --> 00:17:18,920
is being called so just a small

00:17:15,100 --> 00:17:21,560
syntactic thing the underscore after the

00:17:18,920 --> 00:17:23,900
say hello method call is needed because

00:17:21,560 --> 00:17:26,170
we want to lift the method into a

00:17:23,900 --> 00:17:30,290
function object that's why it's there

00:17:26,170 --> 00:17:32,420
and then we have a single abstract

00:17:30,290 --> 00:17:34,340
method declared in our service and this

00:17:32,420 --> 00:17:36,200
is basically what a very

00:17:34,340 --> 00:17:38,539
project will need to implement right it

00:17:36,200 --> 00:17:41,440
has to provide the logic so what is that

00:17:38,539 --> 00:17:45,710
our service should be doing when the say

00:17:41,440 --> 00:17:47,679
hello method is being called and the

00:17:45,710 --> 00:17:50,210
type of this method is a service called

00:17:47,679 --> 00:17:53,990
string with a type parameter string

00:17:50,210 --> 00:17:57,760
string the first one is the request type

00:17:53,990 --> 00:18:00,620
and the second one is the response time

00:17:57,760 --> 00:18:03,770
so I was just telling you about service

00:18:00,620 --> 00:18:07,520
call as I said to type parameters and as

00:18:03,770 --> 00:18:09,919
a single method invoke that takes the

00:18:07,520 --> 00:18:11,450
request message and returns a response

00:18:09,919 --> 00:18:14,630
sometime in the future

00:18:11,450 --> 00:18:16,970
so I seen asynchronously so request is a

00:18:14,630 --> 00:18:19,549
type of the economy message before in

00:18:16,970 --> 00:18:22,990
our l word example it was a string it

00:18:19,549 --> 00:18:28,010
can be any Skala type and response is

00:18:22,990 --> 00:18:31,130
the type of fabric or message Jason is

00:18:28,010 --> 00:18:33,559
the default sir is Asian format so when

00:18:31,130 --> 00:18:35,210
I say it can be any Scalla tied I mean

00:18:33,559 --> 00:18:37,070
that it can be any type as long as you

00:18:35,210 --> 00:18:39,320
can sterilize it basically as long as

00:18:37,070 --> 00:18:40,960
there is a way for either a framework or

00:18:39,320 --> 00:18:43,880
you provide an explicit way

00:18:40,960 --> 00:18:46,279
serialization and that there are two

00:18:43,880 --> 00:18:48,289
kind of requests and response messages

00:18:46,279 --> 00:18:50,330
what we have seen before it's a straight

00:18:48,289 --> 00:18:52,340
message and we say what it means and

00:18:50,330 --> 00:18:54,710
then we also have support built-in

00:18:52,340 --> 00:18:56,570
support for spring and we're actually

00:18:54,710 --> 00:18:57,470
see an example of this too so this is

00:18:56,570 --> 00:19:01,039
what we've seen before

00:18:57,470 --> 00:19:03,409
this is declaring streak message so the

00:19:01,039 --> 00:19:05,510
service for the fact that I'm passing a

00:19:03,409 --> 00:19:07,820
plain Scalla type string it can be any

00:19:05,510 --> 00:19:09,590
other type that means that the type of

00:19:07,820 --> 00:19:12,200
the requests and response types will be

00:19:09,590 --> 00:19:15,230
Street messages and that basically means

00:19:12,200 --> 00:19:17,750
that your your messages will be fully

00:19:15,230 --> 00:19:21,890
buffered into memory before your logic

00:19:17,750 --> 00:19:23,270
is going to be executed but you know

00:19:21,890 --> 00:19:27,950
there are cases where you actually want

00:19:23,270 --> 00:19:30,080
this tree and well we don't really like

00:19:27,950 --> 00:19:32,330
I haven't personally seen any and any

00:19:30,080 --> 00:19:34,190
other framework that react well any

00:19:32,330 --> 00:19:36,169
other might be services framework that

00:19:34,190 --> 00:19:39,289
allows you to do that as a built-in

00:19:36,169 --> 00:19:43,490
feature and what you can do is say like

00:19:39,289 --> 00:19:45,590
I want to actually stream not just I

00:19:43,490 --> 00:19:47,240
I don't want to just send one response I

00:19:45,590 --> 00:19:49,580
want to send a stream of responses

00:19:47,240 --> 00:19:52,580
because this will happen maybe as some

00:19:49,580 --> 00:19:55,250
interval like it's a surprise in this

00:19:52,580 --> 00:19:58,250
service and what I all I need to do as a

00:19:55,250 --> 00:20:01,670
user is saying that is a source of some

00:19:58,250 --> 00:20:03,470
time so source is an extreme source if

00:20:01,670 --> 00:20:04,850
you're familiar with it if you're not

00:20:03,470 --> 00:20:06,500
familiar with it and you want to know

00:20:04,850 --> 00:20:08,030
more about at the stream there is

00:20:06,500 --> 00:20:09,590
actually a session I believe tomorrow

00:20:08,030 --> 00:20:13,580
like Colorado at 11:00

00:20:09,590 --> 00:20:16,240
I'd idly encourage you to go so what a

00:20:13,580 --> 00:20:19,010
casting gives you is backpressure

00:20:16,240 --> 00:20:22,179
asynchronous handling of messages so

00:20:19,010 --> 00:20:24,530
meaning what that means is that the

00:20:22,179 --> 00:20:28,100
sender of the message will never

00:20:24,530 --> 00:20:30,559
overwhelm the receiver of those messages

00:20:28,100 --> 00:20:32,900
basically we'll always go at the speed

00:20:30,559 --> 00:20:35,600
that the mess well for almost at the

00:20:32,900 --> 00:20:37,790
speed that our consumer can consume

00:20:35,600 --> 00:20:41,780
those messages and this is a very nice

00:20:37,790 --> 00:20:44,300
product and for stream Lagoon will

00:20:41,780 --> 00:20:47,090
select the transport protocol and in

00:20:44,300 --> 00:20:49,250
this case will be WebSockets so in the

00:20:47,090 --> 00:20:51,410
future we do plan to provide alternative

00:20:49,250 --> 00:20:53,870
so that you comply a different streaming

00:20:51,410 --> 00:20:56,179
protocol if you want but at the moment

00:20:53,870 --> 00:21:00,410
it's only WebSockets and for strict

00:20:56,179 --> 00:21:02,630
messages underneath we're using HTTP for

00:21:00,410 --> 00:21:04,490
the moment again we let other transport

00:21:02,630 --> 00:21:07,940
protocol in the future but that's what

00:21:04,490 --> 00:21:10,610
it is at the moment so another things is

00:21:07,940 --> 00:21:13,370
before we talked about name call in our

00:21:10,610 --> 00:21:16,309
service here we're using pot Cole right

00:21:13,370 --> 00:21:18,410
so before it was a static packet now

00:21:16,309 --> 00:21:21,200
it's a dynamic one in fact we want to

00:21:18,410 --> 00:21:23,240
extract a portion of that path and pass

00:21:21,200 --> 00:21:24,170
it as an argument to our method and

00:21:23,240 --> 00:21:26,510
that's how you do it

00:21:24,170 --> 00:21:29,480
okay if you're familiar we play I think

00:21:26,510 --> 00:21:35,210
these syntax should be very familiar to

00:21:29,480 --> 00:21:37,130
you it should be straightforward okay so

00:21:35,210 --> 00:21:40,100
remember the service definition we had

00:21:37,130 --> 00:21:41,870
before this was in our API project now

00:21:40,100 --> 00:21:43,600
we defined it now we need to provide an

00:21:41,870 --> 00:21:45,910
implementation of that in our income

00:21:43,600 --> 00:21:49,559
addition project right that depends on

00:21:45,910 --> 00:21:52,450
our API so the implementation is

00:21:49,559 --> 00:21:55,929
straightforward in this case what we

00:21:52,450 --> 00:21:58,240
want to do is just we get a request

00:21:55,929 --> 00:22:00,970
message that is the name of the user as

00:21:58,240 --> 00:22:03,340
part of the the path as per the well

00:22:00,970 --> 00:22:06,490
it's the request body and we just return

00:22:03,340 --> 00:22:08,740
a future with some tax and that's it

00:22:06,490 --> 00:22:10,630
basically that is all we had to do to

00:22:08,740 --> 00:22:14,309
implement our hello world service will

00:22:10,630 --> 00:22:22,000
ago is there any questions so far

00:22:14,309 --> 00:22:25,059
yes yes so perfect so the question is

00:22:22,000 --> 00:22:27,880
basically I don't understand how well

00:22:25,059 --> 00:22:31,780
what this syntax exactly needs so main

00:22:27,880 --> 00:22:36,070
is the request body that is being sent

00:22:31,780 --> 00:22:39,010
to when when calling this well this this

00:22:36,070 --> 00:22:41,020
endpoint right so in this case name the

00:22:39,010 --> 00:22:42,490
type of name is a string and we don't

00:22:41,020 --> 00:22:46,240
need to type that because it's already

00:22:42,490 --> 00:22:48,549
well clear and expressed in the types so

00:22:46,240 --> 00:22:50,530
we have a service called of string to

00:22:48,549 --> 00:22:53,679
string and we said the first type

00:22:50,530 --> 00:22:55,419
parameter is the request message so it's

00:22:53,679 --> 00:22:58,120
the type of the request message so it's

00:22:55,419 --> 00:23:02,520
a string and the second one is the

00:22:58,120 --> 00:23:02,520
response message right yes

00:23:06,519 --> 00:23:12,229
right that is a good point so the time

00:23:09,769 --> 00:23:12,679
of that would actually not be a service

00:23:12,229 --> 00:23:15,700
call

00:23:12,679 --> 00:23:19,489
so I've tell you that maybe a bit later

00:23:15,700 --> 00:23:21,259
why it is the case but there is an

00:23:19,489 --> 00:23:24,549
implicit conversion that going on so

00:23:21,259 --> 00:23:26,799
it's basically taking a function and

00:23:24,549 --> 00:23:29,599
transforming that into a service call

00:23:26,799 --> 00:23:34,309
but I tell you why we do that or I do

00:23:29,599 --> 00:23:38,839
that here later on is that good enough

00:23:34,309 --> 00:23:41,119
good so now let's say that I have a

00:23:38,839 --> 00:23:42,950
different service I just call it my

00:23:41,119 --> 00:23:46,239
service implementation let's imagine

00:23:42,950 --> 00:23:50,059
that we are you know the usual the usual

00:23:46,239 --> 00:23:52,039
service a well my service API project

00:23:50,059 --> 00:23:53,779
and then I have this my service

00:23:52,039 --> 00:23:56,989
implementation project that implements

00:23:53,779 --> 00:23:58,849
this API and the the point of this light

00:23:56,989 --> 00:24:01,039
is that I want to show you how you can

00:23:58,849 --> 00:24:04,519
communicate with the end of our service

00:24:01,039 --> 00:24:07,009
how is it it so all you need to do in

00:24:04,519 --> 00:24:11,119
the my service implementation is inject

00:24:07,009 --> 00:24:14,330
the hello service trait that we defined

00:24:11,119 --> 00:24:17,749
before and then you can just use it you

00:24:14,330 --> 00:24:20,479
can just invoke basically the endpoint

00:24:17,749 --> 00:24:22,729
that the end of service provides and

00:24:20,479 --> 00:24:25,549
that's all you have to do this is

00:24:22,729 --> 00:24:27,559
actually going and communicating for a

00:24:25,549 --> 00:24:29,739
service aid to a service be it will be

00:24:27,559 --> 00:24:33,529
that it you don't have to do anything

00:24:29,739 --> 00:24:34,789
underneath as I told you before when we

00:24:33,529 --> 00:24:37,669
were exploring the development

00:24:34,789 --> 00:24:40,879
environment what will happen is that the

00:24:37,669 --> 00:24:43,639
implementation of that of your service

00:24:40,879 --> 00:24:45,679
will basically go and contact the

00:24:43,639 --> 00:24:47,479
service locator and say hey I want to

00:24:45,679 --> 00:24:49,609
talk to a low service can you give me

00:24:47,479 --> 00:24:52,159
his ID and it will send you back the IP

00:24:49,609 --> 00:24:54,739
and then you will just make a web

00:24:52,159 --> 00:24:58,639
service called to the ten point I

00:24:54,739 --> 00:25:00,409
suppose by by the ELMO service but these

00:24:58,639 --> 00:25:05,029
all happen underneath you don't see it's

00:25:00,409 --> 00:25:07,279
all basically working so is there anyone

00:25:05,029 --> 00:25:12,559
of you seeing a problem with this kind

00:25:07,279 --> 00:25:14,450
of communication I know this is a tricky

00:25:12,559 --> 00:25:18,309
question it's fine I mean it's always

00:25:14,450 --> 00:25:21,729
are transfer questions but there is post

00:25:18,309 --> 00:25:23,320
a problem when you're doing that kind of

00:25:21,729 --> 00:25:25,629
communication with a different service

00:25:23,320 --> 00:25:30,099
so I'll give you think what happen if

00:25:25,629 --> 00:25:32,669
the other service is that if the ELA

00:25:30,099 --> 00:25:35,139
service is down or is unresponsive or

00:25:32,669 --> 00:25:38,320
you have a network problem whatever

00:25:35,139 --> 00:25:40,840
reason this basically this service will

00:25:38,320 --> 00:25:43,330
will also look like it as a problem it

00:25:40,840 --> 00:25:45,340
may look like this it's now it may look

00:25:43,330 --> 00:25:48,070
like it's taking a lot of time to answer

00:25:45,340 --> 00:25:50,289
and all that not because this service

00:25:48,070 --> 00:25:52,059
has a problem but because the problem

00:25:50,289 --> 00:25:55,799
the other service is actually basically

00:25:52,059 --> 00:25:57,909
causing myself having a problem right so

00:25:55,799 --> 00:25:59,349
the reason for that is that because

00:25:57,909 --> 00:26:00,700
somehow you're doing synchronous

00:25:59,349 --> 00:26:02,320
communication even though you're using

00:26:00,700 --> 00:26:05,229
future and everything you're still

00:26:02,320 --> 00:26:07,029
making order texts and waiting for a

00:26:05,229 --> 00:26:08,769
response even though this will happen

00:26:07,029 --> 00:26:12,039
somehow in the future you're not using

00:26:08,769 --> 00:26:13,869
any thread and resources the user that

00:26:12,039 --> 00:26:16,599
made that request your service is still

00:26:13,869 --> 00:26:18,339
waiting for the response right and so if

00:26:16,599 --> 00:26:21,219
that a lot of service doesn't answer

00:26:18,339 --> 00:26:22,779
you're like well the user would say well

00:26:21,219 --> 00:26:24,549
this is really taking too much time I

00:26:22,779 --> 00:26:26,649
mean it's not it's not normal so failure

00:26:24,549 --> 00:26:28,509
is propagating down to the color which

00:26:26,649 --> 00:26:31,059
is not something that you want when

00:26:28,509 --> 00:26:32,200
you're building micro services or at

00:26:31,059 --> 00:26:33,759
least it's something that you usually

00:26:32,200 --> 00:26:35,799
you would really don't want the knurl

00:26:33,759 --> 00:26:39,989
always trade-offs that you like to

00:26:35,799 --> 00:26:42,700
consider so my point in your ear is that

00:26:39,989 --> 00:26:48,339
we have inter communication that is

00:26:42,700 --> 00:26:50,259
extremely simple to do but maybe you

00:26:48,339 --> 00:26:52,779
shouldn't abuse it and there are

00:26:50,259 --> 00:26:57,099
alternatives for avoiding the problem

00:26:52,779 --> 00:26:59,409
that I just described I talked a bit

00:26:57,099 --> 00:27:01,450
more toward the end about this and if

00:26:59,409 --> 00:27:04,149
you have questions feel free to during

00:27:01,450 --> 00:27:06,009
the Q&A or later on to just grab me and

00:27:04,149 --> 00:27:08,109
ask question I just want to mention this

00:27:06,009 --> 00:27:09,969
because when you go and look in the in

00:27:08,109 --> 00:27:12,279
the sample application you see things

00:27:09,969 --> 00:27:14,919
like that if you think okay this is the

00:27:12,279 --> 00:27:16,839
way to do it well in a real application

00:27:14,919 --> 00:27:18,639
you like to think about you know our

00:27:16,839 --> 00:27:21,129
killer is going to propagate to the

00:27:18,639 --> 00:27:23,440
color and what that is going to mean for

00:27:21,129 --> 00:27:27,960
me and you know your user so always be

00:27:23,440 --> 00:27:27,960
careful yes

00:27:29,520 --> 00:27:34,419
good yes actually

00:27:31,840 --> 00:27:38,110
thanks for the question it's about

00:27:34,419 --> 00:27:40,390
circuit breakers actually we like Alma's

00:27:38,110 --> 00:27:44,169
built-in circuit breakers so it means

00:27:40,390 --> 00:27:47,169
that that coal if we see that actually

00:27:44,169 --> 00:27:48,220
is not responsive well we're just gonna

00:27:47,169 --> 00:27:50,679
feel it right away

00:27:48,220 --> 00:27:52,540
instead of waiting that happens but

00:27:50,679 --> 00:27:55,090
failure is still propagating somehow

00:27:52,540 --> 00:27:59,669
right so there are ways to avoid that

00:27:55,090 --> 00:28:02,020
and the way you you will want to do is I

00:27:59,669 --> 00:28:03,880
mean something that allows for

00:28:02,020 --> 00:28:07,150
asynchronous communication so that means

00:28:03,880 --> 00:28:09,340
maybe you want to replicate some of the

00:28:07,150 --> 00:28:11,860
state of the other services and share it

00:28:09,340 --> 00:28:13,179
with this service so that maybe I didn't

00:28:11,860 --> 00:28:14,559
even need to make that call because I

00:28:13,179 --> 00:28:16,750
already have the information maybe it's

00:28:14,559 --> 00:28:19,000
not the most up-to-date information but

00:28:16,750 --> 00:28:20,530
it's good enough for our use so as I

00:28:19,000 --> 00:28:22,299
said I'll talk a bit more about this

00:28:20,530 --> 00:28:26,230
later on and you're free to ask question

00:28:22,299 --> 00:28:30,940
at the end or after the session all

00:28:26,230 --> 00:28:32,500
right persistence API so this is a

00:28:30,940 --> 00:28:35,950
really important principle when

00:28:32,500 --> 00:28:39,220
designing my services each service owns

00:28:35,950 --> 00:28:41,910
is beta there is no other service that

00:28:39,220 --> 00:28:44,860
is going to go into my database and

00:28:41,910 --> 00:28:47,830
basically take information from it

00:28:44,860 --> 00:28:49,900
directly you don't want basically to go

00:28:47,830 --> 00:28:52,330
back to the le bonheur it's right where

00:28:49,900 --> 00:28:54,580
everyone has access to the database and

00:28:52,330 --> 00:28:56,230
then you have no clue who's using it and

00:28:54,580 --> 00:28:58,150
so it's basically helped to refactor

00:28:56,230 --> 00:29:00,100
things or change and you don't want to

00:28:58,150 --> 00:29:01,929
do any changes just because you don't

00:29:00,100 --> 00:29:03,940
want to be blamed for those changes so

00:29:01,929 --> 00:29:05,950
you're very conservative you don't make

00:29:03,940 --> 00:29:07,510
any change and that is why they we get

00:29:05,950 --> 00:29:09,250
into these problems of well these

00:29:07,510 --> 00:29:11,530
monoliths that grows and grows and grows

00:29:09,250 --> 00:29:14,799
and they become what other in order to

00:29:11,530 --> 00:29:18,280
maintain right so principle each service

00:29:14,799 --> 00:29:22,419
owns it's there and if another service

00:29:18,280 --> 00:29:25,630
needs the data of that service well

00:29:22,419 --> 00:29:28,240
either it will ask for the data through

00:29:25,630 --> 00:29:29,779
the service endpoint or there is going

00:29:28,240 --> 00:29:32,029
to be some other mechanism like

00:29:29,779 --> 00:29:35,989
message broker Bertha sir the service

00:29:32,029 --> 00:29:37,759
just sure each state or part of the

00:29:35,989 --> 00:29:39,859
state that he believes is interesting

00:29:37,759 --> 00:29:44,389
for other services to consume and the

00:29:39,859 --> 00:29:46,429
other services will consume those this

00:29:44,389 --> 00:29:48,639
information if they want to so that you

00:29:46,429 --> 00:29:52,279
have this decoupled architecture right

00:29:48,639 --> 00:29:54,109
and then on editing as a setting like

00:29:52,279 --> 00:29:57,169
all we had okay the use of event

00:29:54,109 --> 00:29:59,029
sourcing and CQRS again that does not

00:29:57,169 --> 00:30:02,509
mean that this is the only way of

00:29:59,029 --> 00:30:04,399
building like armed services but it's

00:30:02,509 --> 00:30:07,039
aunty that we believe it's a really nice

00:30:04,399 --> 00:30:09,019
fee for micro services and Sandy that

00:30:07,039 --> 00:30:11,330
you should think and consider then maybe

00:30:09,019 --> 00:30:13,219
it's not gonna be a good for your

00:30:11,330 --> 00:30:15,409
specific use case but it's good to think

00:30:13,219 --> 00:30:16,070
about it and consider it as a good

00:30:15,409 --> 00:30:20,269
alternative

00:30:16,070 --> 00:30:24,379
so in a nutshell even sourcing is about

00:30:20,269 --> 00:30:26,659
capturing all state changes as events so

00:30:24,379 --> 00:30:29,739
if you compare that with well the way we

00:30:26,659 --> 00:30:31,909
are at least I was used to do

00:30:29,739 --> 00:30:33,649
development is that I would only know

00:30:31,909 --> 00:30:35,509
what is the current state in the

00:30:33,649 --> 00:30:37,580
database would only know what is the

00:30:35,509 --> 00:30:39,710
current state here would have no clue

00:30:37,580 --> 00:30:41,539
well did I get there and I would have

00:30:39,710 --> 00:30:43,609
actually novice ability to know how did

00:30:41,539 --> 00:30:45,979
I get there in the first place right I

00:30:43,609 --> 00:30:48,320
only know what is the current state well

00:30:45,979 --> 00:30:51,229
event sourcing is about I want to

00:30:48,320 --> 00:30:53,809
capture all state transitions and those

00:30:51,229 --> 00:30:56,779
are actually what I'm going to store in

00:30:53,809 --> 00:30:59,239
my database because if I want to go back

00:30:56,779 --> 00:31:01,460
and check the state at some previous

00:30:59,239 --> 00:31:05,389
point I can just easily do that

00:31:01,460 --> 00:31:08,960
basically the old story is stored in

00:31:05,389 --> 00:31:11,830
your database and security is about in

00:31:08,960 --> 00:31:16,219
different models for read and write and

00:31:11,830 --> 00:31:19,399
we'll see why that is interesting so

00:31:16,219 --> 00:31:22,940
here are some of the benefits of even

00:31:19,399 --> 00:31:25,070
sourcing and cigarettes I mentioned some

00:31:22,940 --> 00:31:27,649
of them it allows you to time travel as

00:31:25,070 --> 00:31:28,039
I said you haven't lost any information

00:31:27,649 --> 00:31:31,519
about you

00:31:28,039 --> 00:31:33,139
system about well about how you go to

00:31:31,519 --> 00:31:35,299
the current state so you can always

00:31:33,139 --> 00:31:35,629
throw it back and check how did you get

00:31:35,299 --> 00:31:39,019
there

00:31:35,629 --> 00:31:40,940
it's a nolle lot for free future

00:31:39,019 --> 00:31:43,279
business opportunities it's again all

00:31:40,940 --> 00:31:45,729
related since you didn't decide what you

00:31:43,279 --> 00:31:48,590
don't need you have stored everything

00:31:45,729 --> 00:31:50,479
your business can actually say well you

00:31:48,590 --> 00:31:52,999
know what we would really want to expose

00:31:50,479 --> 00:31:54,830
this functionality and well it turns out

00:31:52,999 --> 00:31:57,979
that we already have a lot of history

00:31:54,830 --> 00:32:00,169
about that so basically since day one we

00:31:57,979 --> 00:32:02,809
can offer a very interesting function a

00:32:00,169 --> 00:32:06,529
new functionality to our users there is

00:32:02,809 --> 00:32:10,309
there is no need for our M not at abase

00:32:06,529 --> 00:32:13,909
migration screaming yes because there is

00:32:10,309 --> 00:32:17,690
no conversion or mapping that you need

00:32:13,909 --> 00:32:20,539
to do between your well domain objects

00:32:17,690 --> 00:32:22,549
and the representation that you have in

00:32:20,539 --> 00:32:25,129
the database so the reason is because

00:32:22,549 --> 00:32:27,940
you're actually storing the event and

00:32:25,129 --> 00:32:30,320
the events are what you use in your

00:32:27,940 --> 00:32:31,999
application to determine what is the

00:32:30,320 --> 00:32:33,739
current state of the application this

00:32:31,999 --> 00:32:35,809
will get a lot clearer I think when we

00:32:33,739 --> 00:32:37,639
see the code like I I actually have an

00:32:35,809 --> 00:32:39,830
example we wanted to implement a

00:32:37,639 --> 00:32:41,149
functionality of our template and we'll

00:32:39,830 --> 00:32:43,070
see how we can do that with even

00:32:41,149 --> 00:32:46,159
sourcing at cigarettes Gilligan

00:32:43,070 --> 00:32:49,009
pretty soon yeah there are like other

00:32:46,159 --> 00:32:50,720
ones that yeah

00:32:49,009 --> 00:32:55,549
we can discuss about it later on each

00:32:50,720 --> 00:32:59,090
one so there are basically two parts one

00:32:55,549 --> 00:33:02,269
is out we write and the other one will

00:32:59,090 --> 00:33:05,330
be allowed to be read right so we start

00:33:02,269 --> 00:33:09,229
with a bright inside first we'll have to

00:33:05,330 --> 00:33:11,149
create command and event classes so in

00:33:09,229 --> 00:33:13,399
even sourcing command are things that

00:33:11,149 --> 00:33:14,659
I'd like the system to do it doesn't

00:33:13,399 --> 00:33:16,909
mean that it will happen but they're

00:33:14,659 --> 00:33:20,149
like desires I'd like for instance to

00:33:16,909 --> 00:33:22,639
add a friend this is a design and events

00:33:20,149 --> 00:33:24,590
are actually class about your

00:33:22,639 --> 00:33:26,210
application like I desire to add a

00:33:24,590 --> 00:33:28,639
friend if the system was successfully

00:33:26,210 --> 00:33:31,039
able to add that friend then it means

00:33:28,639 --> 00:33:34,240
that a friend added event will be

00:33:31,039 --> 00:33:36,910
generated and this is the event that is

00:33:34,240 --> 00:33:39,550
the friend has been added it is a fact

00:33:36,910 --> 00:33:42,430
he does afternoon alright

00:33:39,550 --> 00:33:44,050
and in the second thing so commandant

00:33:42,430 --> 00:33:45,700
events will be just playing Scout

00:33:44,050 --> 00:33:48,700
classes again we'll see it in a moment

00:33:45,700 --> 00:33:51,370
and the other team will have to do is

00:33:48,700 --> 00:33:53,700
sub classing this persistent entity

00:33:51,370 --> 00:33:57,550
which is a class that is part of the

00:33:53,700 --> 00:34:00,580
Lacombe api and a persistent entity will

00:33:57,550 --> 00:34:03,130
all the current state the memory state

00:34:00,580 --> 00:34:06,220
of the application so we'll have many

00:34:03,130 --> 00:34:08,679
personalities and all owning a portion

00:34:06,220 --> 00:34:11,530
of that say for instance and we see it

00:34:08,679 --> 00:34:14,760
soon I will have a friend entity that

00:34:11,530 --> 00:34:20,679
will know what are the Friends of a user

00:34:14,760 --> 00:34:24,280
ok and in this persistent entity we will

00:34:20,679 --> 00:34:26,980
define command and event handlers so we

00:34:24,280 --> 00:34:30,760
have command Anders or saying okay I

00:34:26,980 --> 00:34:34,780
want to add a friend to my to my user

00:34:30,760 --> 00:34:37,450
list that persistent entity will handle

00:34:34,780 --> 00:34:40,060
that command and if it all succeed so I

00:34:37,450 --> 00:34:42,610
can actually add that friend I will

00:34:40,060 --> 00:34:44,320
generate an event so by generating and

00:34:42,610 --> 00:34:46,090
then then my persistent entity what we

00:34:44,320 --> 00:34:48,010
want to do is updating the current state

00:34:46,090 --> 00:34:50,260
of the persistent entity and that is why

00:34:48,010 --> 00:34:52,390
we will add an event handler also

00:34:50,260 --> 00:34:54,850
declared in this persistent entity again

00:34:52,390 --> 00:34:57,850
if this is looking complex will see the

00:34:54,850 --> 00:35:00,910
code and I think you see it squeezed and

00:34:57,850 --> 00:35:03,790
a persistent entity can be accessed from

00:35:00,910 --> 00:35:06,670
anywhere in the cluster as long as you

00:35:03,790 --> 00:35:10,090
have the entity ID so you will be

00:35:06,670 --> 00:35:12,550
defining entities ID so unique IDs for

00:35:10,090 --> 00:35:15,550
accessing the persistent entities that

00:35:12,550 --> 00:35:18,220
are needed to carry out the task attack

00:35:15,550 --> 00:35:20,710
and if you are familiar with BDD a

00:35:18,220 --> 00:35:22,480
persistent entity actually corresponds

00:35:20,710 --> 00:35:24,670
to an aggregate group if you're not

00:35:22,480 --> 00:35:26,200
familiar with it it's fine I was just

00:35:24,670 --> 00:35:30,010
gonna keep this in for people that are

00:35:26,200 --> 00:35:31,660
from the program ok so we want to

00:35:30,010 --> 00:35:35,380
implement this functionality add a

00:35:31,660 --> 00:35:41,010
friend to add a friend in our children

00:35:35,380 --> 00:35:43,109
so I'll just move that to here

00:35:41,010 --> 00:35:47,070
let's see how do we add a friend in

00:35:43,109 --> 00:35:49,380
practice we have this and I think I have

00:35:47,070 --> 00:35:55,290
a friend but there is someone named

00:35:49,380 --> 00:35:58,680
Norma phone ago and now the gun is in

00:35:55,290 --> 00:36:01,190
our feed right so this is the

00:35:58,680 --> 00:36:05,550
functionality that we want to implement

00:36:01,190 --> 00:36:09,090
so let's go back to the slides so let's

00:36:05,550 --> 00:36:12,450
split this into different steps you want

00:36:09,090 --> 00:36:14,280
to create add friend comment class why

00:36:12,450 --> 00:36:16,470
because we want to express the desire of

00:36:14,280 --> 00:36:19,020
having a friend to the system now we

00:36:16,470 --> 00:36:21,390
have a friend added event because that

00:36:19,020 --> 00:36:23,640
that defines the fact that yes I was

00:36:21,390 --> 00:36:27,810
able to add a friend so that happened

00:36:23,640 --> 00:36:30,060
and finally we have a friend entity that

00:36:27,810 --> 00:36:33,240
we like to manage these commands and

00:36:30,060 --> 00:36:36,840
produce events for these commands all

00:36:33,240 --> 00:36:39,150
right and update the state of well the

00:36:36,840 --> 00:36:40,470
persistent entity and the son of all the

00:36:39,150 --> 00:36:44,130
persistent entities that find the

00:36:40,470 --> 00:36:45,750
current state of the application so

00:36:44,130 --> 00:36:49,230
let's start with the first thing let's

00:36:45,750 --> 00:36:52,440
create a command class really easy we

00:36:49,230 --> 00:36:54,060
just defined trait it's sealed because

00:36:52,440 --> 00:36:57,480
we don't want anyone to extend it

00:36:54,060 --> 00:37:00,240
outside of our completion unit and it

00:36:57,480 --> 00:37:03,300
extends JSON apple because we want these

00:37:00,240 --> 00:37:05,400
commands to be sent possibly across the

00:37:03,300 --> 00:37:08,640
wire to entities that are not living in

00:37:05,400 --> 00:37:10,920
our node maybe because we have we are in

00:37:08,640 --> 00:37:14,160
this distributed environment and so

00:37:10,920 --> 00:37:16,440
Jason is going to be the default certain

00:37:14,160 --> 00:37:19,830
ization format for these messages as

00:37:16,440 --> 00:37:22,380
well and we defined our class that is

00:37:19,830 --> 00:37:27,630
just a plain is class it takes a friend

00:37:22,380 --> 00:37:31,350
ID and this reply type is the reply that

00:37:27,630 --> 00:37:34,560
will be sent by the command handler if

00:37:31,350 --> 00:37:37,080
we were successful if the add friend

00:37:34,560 --> 00:37:39,750
command was successful so in this case

00:37:37,080 --> 00:37:42,600
when the command the add friend command

00:37:39,750 --> 00:37:45,390
is successful the color will just

00:37:42,600 --> 00:37:46,720
receive at this time object which just

00:37:45,390 --> 00:37:48,670
mean I was able to

00:37:46,720 --> 00:37:52,810
and it's just a value that you discard

00:37:48,670 --> 00:37:54,490
and our ad friend it extends friend

00:37:52,810 --> 00:37:56,530
comment again I didn't have to create a

00:37:54,490 --> 00:37:58,210
super well actually not yes I mean I

00:37:56,530 --> 00:38:00,970
wanted to create a super class because I

00:37:58,210 --> 00:38:02,920
can add more than just one command right

00:38:00,970 --> 00:38:04,810
and we see that when I declared the

00:38:02,920 --> 00:38:06,400
persistent entity I actually need to

00:38:04,810 --> 00:38:08,200
define what is the class of command that

00:38:06,400 --> 00:38:10,270
this persistent entity will accept this

00:38:08,200 --> 00:38:12,280
also is all type check basically as

00:38:10,270 --> 00:38:14,500
opposed as if you're if you've been

00:38:12,280 --> 00:38:16,990
using akka where when you're sending

00:38:14,500 --> 00:38:21,089
messages your actor don't really know

00:38:16,990 --> 00:38:21,089
what kind of messages that the end like

00:38:21,930 --> 00:38:28,720
okay second thing we need to create a

00:38:25,599 --> 00:38:32,369
friend added event that will basically

00:38:28,720 --> 00:38:36,460
that we like and if I receive a command

00:38:32,369 --> 00:38:38,349
at Frank man and I was able to and I'm

00:38:36,460 --> 00:38:41,770
able to add a friend then Fred added

00:38:38,349 --> 00:38:43,720
event will be sent to the system again

00:38:41,770 --> 00:38:45,310
it's pretty similar I just have a

00:38:43,720 --> 00:38:49,180
different hierarchy it's friend event

00:38:45,310 --> 00:38:52,720
she'll pray but yeah again it's a plain

00:38:49,180 --> 00:38:55,480
case class with a couple fields not

00:38:52,720 --> 00:38:57,400
really important I my point is that it's

00:38:55,480 --> 00:39:01,180
just a pain applying case class and it's

00:38:57,400 --> 00:39:03,040
extremely sick and finally we need to

00:39:01,180 --> 00:39:07,150
define this friend entity the friend

00:39:03,040 --> 00:39:11,380
entity holds the state of basically what

00:39:07,150 --> 00:39:14,050
are the friends of a given user so we

00:39:11,380 --> 00:39:16,060
define class try an entity that extends

00:39:14,050 --> 00:39:17,530
persistent entity the first I parameters

00:39:16,060 --> 00:39:19,900
is the set of command that this

00:39:17,530 --> 00:39:22,030
persistent entity is going to handle the

00:39:19,900 --> 00:39:24,220
second type are type parameter is the

00:39:22,030 --> 00:39:26,770
class of events that will be generated

00:39:24,220 --> 00:39:29,020
so for an event and friend Frank state

00:39:26,770 --> 00:39:31,180
is the state that will be all by this

00:39:29,020 --> 00:39:32,890
persistent is the in-memory stay that

00:39:31,180 --> 00:39:35,109
will be owned by this persistent entity

00:39:32,890 --> 00:39:37,000
and all we need to do is provide an

00:39:35,109 --> 00:39:40,839
implementation of this initial behavior

00:39:37,000 --> 00:39:44,230
method that us basically to define the

00:39:40,839 --> 00:39:46,329
command any many listeners so the France

00:39:44,230 --> 00:39:50,230
state so this is the state that will be

00:39:46,329 --> 00:39:52,869
held by our personality it's again

00:39:50,230 --> 00:39:53,710
simple we have a user well if we have a

00:39:52,869 --> 00:39:56,859
user name

00:39:53,710 --> 00:39:59,230
like I can add friends to this day and

00:39:56,859 --> 00:40:01,599
the French state will keep track of what

00:39:59,230 --> 00:40:04,540
are friends of a user and this will be

00:40:01,599 --> 00:40:06,430
told by the persistent entity by this

00:40:04,540 --> 00:40:11,410
friend persistent entity that we

00:40:06,430 --> 00:40:13,990
interested good so command and learn we

00:40:11,410 --> 00:40:17,980
need to handle this ad friend command

00:40:13,990 --> 00:40:20,020
right so we are this is inside

00:40:17,980 --> 00:40:22,810
implementation of the initial behavior

00:40:20,020 --> 00:40:24,670
method of the persistent entity we're

00:40:22,810 --> 00:40:30,070
just saying well when we do when we get

00:40:24,670 --> 00:40:34,830
an that friend class type of of command

00:40:30,070 --> 00:40:39,190
well if we have a user in the state then

00:40:34,830 --> 00:40:41,109
we're going to create an event and we're

00:40:39,190 --> 00:40:44,440
actually going to be perceiving that

00:40:41,109 --> 00:40:47,349
event and if that was successful then

00:40:44,440 --> 00:40:50,980
we'll tell the color that it was done

00:40:47,349 --> 00:40:52,930
but if we don't have a user in the state

00:40:50,980 --> 00:40:55,690
that we can't add a friend and this is

00:40:52,930 --> 00:40:58,300
our usual validation of the command so a

00:40:55,690 --> 00:41:02,770
command may or may not generate anything

00:40:58,300 --> 00:41:05,320
as you can see here and finally well

00:41:02,770 --> 00:41:08,320
finally what happen is that we persisted

00:41:05,320 --> 00:41:10,720
an event but the state of the persistent

00:41:08,320 --> 00:41:13,300
entity even changed right so we need to

00:41:10,720 --> 00:41:16,030
define an event handler that say well

00:41:13,300 --> 00:41:18,580
when a friend is added I want to update

00:41:16,030 --> 00:41:20,740
the state of the persistent entity and

00:41:18,580 --> 00:41:23,619
in this case again it's straightforward

00:41:20,740 --> 00:41:24,820
I just want to add the friend to my

00:41:23,619 --> 00:41:29,020
parents place so that the persistent

00:41:24,820 --> 00:41:31,599
entity now as the the right state right

00:41:29,020 --> 00:41:33,880
if I'm going to query the persistent

00:41:31,599 --> 00:41:36,130
entity for like can you give me the

00:41:33,880 --> 00:41:39,010
friend of this user the persistent

00:41:36,130 --> 00:41:41,109
people know what is what people know

00:41:39,010 --> 00:41:42,700
about this like this user that this

00:41:41,109 --> 00:41:44,890
friend of that we just added to the

00:41:42,700 --> 00:41:47,710
persistent one important thing is that

00:41:44,890 --> 00:41:51,910
you don't have to do you must not do

00:41:47,710 --> 00:41:55,359
side-effects here and the reason is

00:41:51,910 --> 00:42:00,700
because you're storing all events right

00:41:55,359 --> 00:42:02,800
and the idea behind even sourcing and

00:42:00,700 --> 00:42:03,610
securest is that you can pre-built the

00:42:02,800 --> 00:42:05,590
current state

00:42:03,610 --> 00:42:07,300
by just looking at the events right so

00:42:05,590 --> 00:42:08,050
what is the problem before you do side

00:42:07,300 --> 00:42:10,780
effect sir

00:42:08,050 --> 00:42:12,520
well this persistent entity let's say

00:42:10,780 --> 00:42:14,410
that an old crash and then a need to

00:42:12,520 --> 00:42:16,090
spawn up a new machine and I need to

00:42:14,410 --> 00:42:18,310
reveal the current state so what how do

00:42:16,090 --> 00:42:20,230
I do that well I just replay all the

00:42:18,310 --> 00:42:22,390
events that I've been stored in before

00:42:20,230 --> 00:42:24,370
the persistent entity right and if I do

00:42:22,390 --> 00:42:25,870
side effects there like I'm sending

00:42:24,370 --> 00:42:28,450
let's say yeah let's think about like

00:42:25,870 --> 00:42:31,030
people do I have a persistent entity for

00:42:28,450 --> 00:42:33,070
an order and I'm sending an email there

00:42:31,030 --> 00:42:33,790
to the user like yes your order was

00:42:33,070 --> 00:42:35,470
carried out

00:42:33,790 --> 00:42:37,060
well then I'm revealing the state and

00:42:35,470 --> 00:42:38,740
I'm going to send the same email over

00:42:37,060 --> 00:42:39,820
and over and over and over and over so

00:42:38,740 --> 00:42:41,530
that's not where you want to do

00:42:39,820 --> 00:42:42,940
side-effects there is a different place

00:42:41,530 --> 00:42:46,270
where you want to do a side effect and

00:42:42,940 --> 00:42:47,920
that is actually here this this is the

00:42:46,270 --> 00:42:49,990
place where you can do side effects

00:42:47,920 --> 00:42:52,270
because it's the only it's only going to

00:42:49,990 --> 00:42:54,850
be called once when the event is

00:42:52,270 --> 00:43:00,910
persistent and event is only persisted

00:42:54,850 --> 00:43:01,900
parts okay so now that we have all these

00:43:00,910 --> 00:43:04,450
different things

00:43:01,900 --> 00:43:07,780
let's bring in them together we have a

00:43:04,450 --> 00:43:10,330
friend service again pretty similar

00:43:07,780 --> 00:43:11,980
before we have an endpoint and we have

00:43:10,330 --> 00:43:13,930
an ad friend method that we need to

00:43:11,980 --> 00:43:16,330
implement and this is the interesting

00:43:13,930 --> 00:43:18,130
part this is how we implement it so we

00:43:16,330 --> 00:43:22,090
like to inject a persistent if you

00:43:18,130 --> 00:43:23,740
registry that basically knows how to how

00:43:22,090 --> 00:43:25,410
to contact and locate the persistent

00:43:23,740 --> 00:43:30,580
entities that are existing in your

00:43:25,410 --> 00:43:32,140
system and this is how the reference to

00:43:30,580 --> 00:43:34,960
the persistent entity to the friend

00:43:32,140 --> 00:43:37,810
entity that we created the second one if

00:43:34,960 --> 00:43:40,450
the user ID meaning that is the entity

00:43:37,810 --> 00:43:43,210
ID that were interested in because we

00:43:40,450 --> 00:43:45,130
want the entity that owns the state for

00:43:43,210 --> 00:43:48,430
this particular user not for any user

00:43:45,130 --> 00:43:52,360
right and then we just called us and

00:43:48,430 --> 00:43:55,480
past big man and eventually we either

00:43:52,360 --> 00:43:57,070
get a problem so as we've seen before

00:43:55,480 --> 00:44:00,520
there is validation so you will either

00:43:57,070 --> 00:44:05,770
succeed or not but anyway something we

00:44:00,520 --> 00:44:08,980
like so yes I'm running out of time so I

00:44:05,770 --> 00:44:13,690
be fairly quick on the red side this was

00:44:08,980 --> 00:44:16,270
the right side but you'll also want

00:44:13,690 --> 00:44:20,300
possibly

00:44:16,270 --> 00:44:22,730
obviously like usually when you want to

00:44:20,300 --> 00:44:25,010
query your crew databases what happens

00:44:22,730 --> 00:44:27,680
is that your possibly joins across

00:44:25,010 --> 00:44:29,540
tables and your tables you have you only

00:44:27,680 --> 00:44:31,160
have one kind of table right it's the

00:44:29,540 --> 00:44:33,800
one that you can write you use for free

00:44:31,160 --> 00:44:36,290
so the idea here is that well for

00:44:33,800 --> 00:44:39,230
writing we use event sourcing for

00:44:36,290 --> 00:44:41,270
certain events and that may not be the

00:44:39,230 --> 00:44:43,460
best format when I agree just because I

00:44:41,270 --> 00:44:44,869
want to manual this information in a

00:44:43,460 --> 00:44:47,540
slightly different way that's would be

00:44:44,869 --> 00:44:49,490
adapted to the view that I'm going to

00:44:47,540 --> 00:44:51,170
present to the user and also that view

00:44:49,490 --> 00:44:52,700
may evolve over time so the actual

00:44:51,170 --> 00:44:54,109
representation might be different so

00:44:52,700 --> 00:44:56,000
that's taking about having different

00:44:54,109 --> 00:44:58,640
representation for pride and greed and

00:44:56,000 --> 00:45:00,740
if I go for the red side what you will

00:44:58,640 --> 00:45:02,809
do is that you will subclass Cassandra

00:45:00,740 --> 00:45:07,160
grid side processor it's just a class

00:45:02,809 --> 00:45:09,770
that allows you to define tables in this

00:45:07,160 --> 00:45:11,839
specific case it's tied to Cassandra so

00:45:09,770 --> 00:45:14,599
it will be Cassandra tables and you will

00:45:11,839 --> 00:45:17,180
declare event under static update your

00:45:14,599 --> 00:45:19,730
tables right so the persistent entity as

00:45:17,180 --> 00:45:21,260
we've seen generate events and then here

00:45:19,730 --> 00:45:22,940
on the read side what we will do is that

00:45:21,260 --> 00:45:25,549
we will listen to those events and

00:45:22,940 --> 00:45:27,500
update our tables our query tables so

00:45:25,549 --> 00:45:29,390
that then in our service if we need to

00:45:27,500 --> 00:45:31,099
access these tables we can do that

00:45:29,390 --> 00:45:36,559
through Cassandra it will be just

00:45:31,099 --> 00:45:39,170
through the Cassandra player language so

00:45:36,559 --> 00:45:44,530
running a production of like I'll use

00:45:39,170 --> 00:45:48,890
native packager for yeah for creating

00:45:44,530 --> 00:45:51,680
executables to run your your account

00:45:48,890 --> 00:45:54,440
services in production like on yes

00:45:51,680 --> 00:45:56,089
conductor is the preferred path just

00:45:54,440 --> 00:45:59,510
because it has built-in support for

00:45:56,089 --> 00:46:01,609
background it is not the only path by

00:45:59,510 --> 00:46:05,380
this definitely is this part like a

00:46:01,609 --> 00:46:08,329
conductor is free for development and

00:46:05,380 --> 00:46:09,500
it's actually not free for play for

00:46:08,329 --> 00:46:11,180
using connections so if you're

00:46:09,500 --> 00:46:12,780
interested on that happy to talk more

00:46:11,180 --> 00:46:15,240
about it we actually have the

00:46:12,780 --> 00:46:16,530
team here at skala days as well so I'm

00:46:15,240 --> 00:46:19,890
sure they'll be able to talk to you

00:46:16,530 --> 00:46:21,390
about it more and by using connector and

00:46:19,890 --> 00:46:22,800
our reactive platform you look at

00:46:21,390 --> 00:46:25,110
monitoring split plate and play a

00:46:22,800 --> 00:46:27,960
resolver and lots of other things

00:46:25,110 --> 00:46:30,240
support and lots of other things so

00:46:27,960 --> 00:46:32,580
currently gone is that we're in our c1

00:46:30,240 --> 00:46:34,380
so it is definitely the right moment to

00:46:32,580 --> 00:46:35,760
try it out and tell us if there is any

00:46:34,380 --> 00:46:38,790
problem because it's gonna be final soon

00:46:35,760 --> 00:46:40,620
and that is actually to answer your

00:46:38,790 --> 00:46:42,540
initial question right now there is only

00:46:40,620 --> 00:46:44,760
a Java API so everything I show you

00:46:42,540 --> 00:46:47,010
actually complies it's all fine but

00:46:44,760 --> 00:46:49,290
that's why we need a couple of implicit

00:46:47,010 --> 00:46:51,720
conversion here there are to adapt the

00:46:49,290 --> 00:46:53,940
skeletons to the Java types but

00:46:51,720 --> 00:46:55,890
hopefully you'll feel like me that

00:46:53,940 --> 00:46:59,430
actually using like on through the Java

00:46:55,890 --> 00:47:00,930
API with Scala it's pretty ok like yeah

00:46:59,430 --> 00:47:03,420
at least I feel that way it's actually

00:47:00,930 --> 00:47:05,640
pretty ok I can read all the benefits of

00:47:03,420 --> 00:47:08,490
using Scala all the nice syntax things

00:47:05,640 --> 00:47:10,200
that we get from skeleton and this is a

00:47:08,490 --> 00:47:12,360
link to the sample app that I've been

00:47:10,200 --> 00:47:15,030
using in the slides so that you can

00:47:12,360 --> 00:47:17,010
explore it more I'll actually tweet this

00:47:15,030 --> 00:47:19,350
light soon so if you follow me you don't

00:47:17,010 --> 00:47:22,230
have to write down any of these links

00:47:19,350 --> 00:47:23,370
this is the future so we can add Milan

00:47:22,230 --> 00:47:25,530
support and may even support maybe

00:47:23,370 --> 00:47:27,480
nothing that interesting for some of you

00:47:25,530 --> 00:47:30,600
but we think that it's really important

00:47:27,480 --> 00:47:33,510
for getting companies into using my god

00:47:30,600 --> 00:47:35,880
since it's a well fine standard maybe if

00:47:33,510 --> 00:47:38,280
there is no order in this list there are

00:47:35,880 --> 00:47:40,230
things that we want to do message broker

00:47:38,280 --> 00:47:41,580
integration which is for resolving the

00:47:40,230 --> 00:47:43,950
initial problem that I mentioned about

00:47:41,580 --> 00:47:45,960
having services communicating

00:47:43,950 --> 00:47:48,960
synchronously again I could talk a bit

00:47:45,960 --> 00:47:51,690
more after during the Q&A or after

00:47:48,960 --> 00:47:53,790
Scalla API support for other position

00:47:51,690 --> 00:47:55,950
tools water integrations for providing

00:47:53,790 --> 00:47:57,990
integration tech support support for

00:47:55,950 --> 00:48:00,690
other databases and lots of other things

00:47:57,990 --> 00:48:03,780
and of course you're welcome to suggest

00:48:00,690 --> 00:48:07,620
your own prefer feature these are a few

00:48:03,780 --> 00:48:09,720
links that may be useful again you I

00:48:07,620 --> 00:48:12,930
think you can just look at the slides

00:48:09,720 --> 00:48:15,860
later on and yes thanks everybody

00:48:12,930 --> 00:48:15,860
sorry for being a

00:48:31,119 --> 00:48:36,950
we can have a little Q&A so if you want

00:48:35,000 --> 00:48:42,430
to ask questions

00:48:36,950 --> 00:48:45,200
just raise your hand really good talk

00:48:42,430 --> 00:48:46,790
quick question on your cluster manager

00:48:45,200 --> 00:48:48,890
integration summit do you have any plans

00:48:46,790 --> 00:48:51,080
of integrating it with I love meat sauce

00:48:48,890 --> 00:48:52,820
sphere or the DCOs

00:48:51,080 --> 00:48:56,089
of meat sauce fear of making it as a

00:48:52,820 --> 00:48:58,970
service so a really good question

00:48:56,089 --> 00:49:01,280
they're definitely plans in the

00:48:58,970 --> 00:49:04,790
connector team for integrating and actor

00:49:01,280 --> 00:49:06,800
releases I don't know the details so I

00:49:04,790 --> 00:49:09,080
don't want to say anything right so I'd

00:49:06,800 --> 00:49:10,700
actually encourage you to come to the

00:49:09,080 --> 00:49:12,349
Lightning booth and talk to the

00:49:10,700 --> 00:49:15,310
conductor team who definitely us a

00:49:12,349 --> 00:49:17,660
better answer for this kind of question

00:49:15,310 --> 00:49:19,369
but there are plans as far as I you know

00:49:17,660 --> 00:49:23,109
hopefully I'm not wrong if Christopher

00:49:19,369 --> 00:49:23,109
is in the room you can correct me when

00:49:23,800 --> 00:49:28,119
will the scholar right here I realized

00:49:28,210 --> 00:49:35,510
that it's like James I don't know so our

00:49:33,619 --> 00:49:38,990
tech lead is working on that but it's

00:49:35,510 --> 00:49:42,140
being at least one on anyway we're

00:49:38,990 --> 00:49:45,109
working on it so we have one person

00:49:42,140 --> 00:49:48,589
working on the skylight guide it's it's

00:49:45,109 --> 00:49:50,720
it's a massive work in order to provide

00:49:48,589 --> 00:49:53,660
an API that actually deals idiomatic for

00:49:50,720 --> 00:50:01,790
skeletons so it would be there hopefully

00:49:53,660 --> 00:50:04,630
hopefully soon yes there is one person

00:50:01,790 --> 00:50:04,630
here in one year

00:50:07,619 --> 00:50:12,420
how easy is it to integrate with Norman

00:50:09,990 --> 00:50:13,440
with services that aren't in my column

00:50:12,420 --> 00:50:18,840
yes

00:50:13,440 --> 00:50:20,670
so in the Battlement we actually have a

00:50:18,840 --> 00:50:23,190
couple of things that you can do to

00:50:20,670 --> 00:50:25,740
integrate with external services looking

00:50:23,190 --> 00:50:27,900
for Pearson's to integrate services into

00:50:25,740 --> 00:50:29,670
the development environment there is an

00:50:27,900 --> 00:50:34,890
SBT setting where you can just provide

00:50:29,670 --> 00:50:37,140
an HTTP well link through your service

00:50:34,890 --> 00:50:38,790
together with a name so that it gets

00:50:37,140 --> 00:50:41,010
registered to the service locator so

00:50:38,790 --> 00:50:44,100
that you get the same kind of benefits

00:50:41,010 --> 00:50:46,260
as if the service was written in like

00:50:44,100 --> 00:50:48,270
all and we have a couple more things

00:50:46,260 --> 00:51:00,990
that we'll be doing for facilitating

00:50:48,270 --> 00:51:03,060
integrating with services I mean really

00:51:00,990 --> 00:51:05,319
complicated question nobody can answer

00:51:03,060 --> 00:51:08,799
and

00:51:05,319 --> 00:51:10,869
with us but good mood possible flirts

00:51:08,799 --> 00:51:17,160
are fallible Michael service car water

00:51:10,869 --> 00:51:17,160
feature one could be future of all this

00:51:25,829 --> 00:51:30,130
it is a pretty good question alike I

00:51:28,420 --> 00:51:31,959
think we have the same problem without

00:51:30,130 --> 00:51:34,180
talking about microservices we have the

00:51:31,959 --> 00:51:35,890
same problem when we design a class and

00:51:34,180 --> 00:51:37,660
we wonder like is this something that

00:51:35,890 --> 00:51:40,979
should be a responsibility of this class

00:51:37,660 --> 00:51:43,719
or should we put it somewhere else

00:51:40,979 --> 00:51:47,920
it is a question that has an doesn't

00:51:43,719 --> 00:51:49,930
like a straight answer I think that one

00:51:47,920 --> 00:51:54,880
interesting way to look at it is to

00:51:49,930 --> 00:51:58,150
think in terms of PVD and so look at DDD

00:51:54,880 --> 00:52:00,489
as a way of defining your boundaries and

00:51:58,150 --> 00:52:04,930
now you should be explaining your

00:52:00,489 --> 00:52:08,739
services so I have a great answer but I

00:52:04,930 --> 00:52:11,109
suggest you to look into DDD as a

00:52:08,739 --> 00:52:15,099
possible ways or you know other ones

00:52:11,109 --> 00:52:17,709
plate your services is it possible to

00:52:15,099 --> 00:52:23,589
use Lancome without subscription to

00:52:17,709 --> 00:52:25,779
light absolutely thanks for the question

00:52:23,589 --> 00:52:28,119
yes like all these open sourcing can be

00:52:25,779 --> 00:52:31,150
definitely used without any of our

00:52:28,119 --> 00:52:34,690
commercial offering so yes you can use

00:52:31,150 --> 00:52:37,539
like home without a lightning connector

00:52:34,690 --> 00:52:40,239
you can use it that connector is part of

00:52:37,539 --> 00:52:42,190
our subscription so you can use these

00:52:40,239 --> 00:52:44,170
free for the pendant so you can use it

00:52:42,190 --> 00:52:47,619
for your family but it's not for free in

00:52:44,170 --> 00:52:50,259
production yeah come I their companies

00:52:47,619 --> 00:52:54,579
have been using things like websphere

00:52:50,259 --> 00:52:55,050
and you know other runtime environments

00:52:54,579 --> 00:52:58,110
and if

00:52:55,050 --> 00:53:00,210
fine thing for those things and this is

00:52:58,110 --> 00:53:02,730
part of our how we actually can survive

00:53:00,210 --> 00:53:06,090
and that's why connector is part of our

00:53:02,730 --> 00:53:08,360
commercial offering but you know if your

00:53:06,090 --> 00:53:11,760
company doesn't want or kind of for

00:53:08,360 --> 00:53:13,920
conductor there are alternatives there

00:53:11,760 --> 00:53:16,230
is actually the conductor technically

00:53:13,920 --> 00:53:18,450
that I started a project or providing

00:53:16,230 --> 00:53:22,950
support in kubernetes it's early days

00:53:18,450 --> 00:53:25,410
but you're welcome to contribute to that

00:53:22,950 --> 00:53:27,720
it burn it is you can lose it for free

00:53:25,410 --> 00:53:29,340
for instance and there are also ways for

00:53:27,720 --> 00:53:32,490
running it outside of an orchestra

00:53:29,340 --> 00:53:34,980
classroom to invite connectors our uber

00:53:32,490 --> 00:53:37,920
name is like the only thing that you

00:53:34,980 --> 00:53:39,840
actually need to run like on the

00:53:37,920 --> 00:53:41,760
production is an implementation of the

00:53:39,840 --> 00:53:43,440
service locator interface that we

00:53:41,760 --> 00:53:45,390
provide in a common so as long as you

00:53:43,440 --> 00:53:47,790
have any permutation that you can do it

00:53:45,390 --> 00:53:49,620
but then you let problems with you know

00:53:47,790 --> 00:53:51,690
how what happens when one of your

00:53:49,620 --> 00:53:53,820
services crashes if you're using things

00:53:51,690 --> 00:53:57,150
like a connector or what it takes care

00:53:53,820 --> 00:53:59,490
of that for youth while if you don't use

00:53:57,150 --> 00:54:01,350
one of these schools and generally like

00:53:59,490 --> 00:54:04,020
to manually do something in these phases

00:54:01,350 --> 00:54:06,410
so it really can't be tension what are

00:54:04,020 --> 00:54:06,410

YouTube URL: https://www.youtube.com/watch?v=b6ZzBKrWyAg


