Title: Reactors   Road to Composable Distributed Computing   by Aleksandar Prokopec
Publication date: 2016-07-22
Playlist: Scala Days Berlin 2016
Description: 
	This video was recorded at Scala Days Berlin 2016
follow us on Twitter @ScalaDays or visit our website for more information http://scaladays.org 

Abstract:
The actor model is one of the de-facto standards when it comes to building reliable distributed systems. There are many reasons why actors are so attractive. On one hand, actors ensure that message-processing is serialized within each actor, preserving the familiar sequential programming model. On the other hand, programs written in the actor model are location-transparent, which is one of the prerequisites for scaling systems. Importantly, the actor model is sufficiently low-level to express arbitrary message protocols. However, composing these message protocols is the key to high-level abstractions, and it is difficult to reuse or compose message protocols with actors. Lack of simple composition is an obstacle to building complex systems.
The reactor model is the new answer to the challenges of distributed computing. This model simplifies protocol composition with first-class typed channels and event streams. In this talk, I will present the Reactors.IO framework which is based on the reactor programming model. I will compare the reactor and the actor models on concrete Scala programs. I will show specific obstacles for composition in the classic actor model, and how to overcome them. I will then show how to build reusable, composable distributed computing components in the new model.
Captions: 
	00:00:02,660 --> 00:00:07,880
my name is alexander pro puppets i will

00:00:05,270 --> 00:00:10,160
talk about my new model for distributed

00:00:07,880 --> 00:00:12,860
computing which is basically a new

00:00:10,160 --> 00:00:15,740
programming model but before i get there

00:00:12,860 --> 00:00:17,920
basically i want to i want to ask one

00:00:15,740 --> 00:00:20,930
kind of rhetorical question which is

00:00:17,920 --> 00:00:24,199
what does make a programming model good

00:00:20,930 --> 00:00:26,840
and this is a very subjective question

00:00:24,199 --> 00:00:28,970
because unlike other areas of computer

00:00:26,840 --> 00:00:31,820
science and information technology

00:00:28,970 --> 00:00:34,250
basically don't have good metrics on

00:00:31,820 --> 00:00:36,140
which to measure if a programming model

00:00:34,250 --> 00:00:40,760
is good or not and it comes to

00:00:36,140 --> 00:00:42,710
algorithms or when it comes to some kind

00:00:40,760 --> 00:00:44,870
of other formal models basically you can

00:00:42,710 --> 00:00:47,390
you can improve something about and we

00:00:44,870 --> 00:00:49,699
can prove their correctness or you can

00:00:47,390 --> 00:00:52,670
prove you can prove their scalability

00:00:49,699 --> 00:00:54,410
you can compare the complexity of two

00:00:52,670 --> 00:00:57,230
algorithms if you're talking about a

00:00:54,410 --> 00:00:59,480
system or a framework you can measure

00:00:57,230 --> 00:01:01,280
its performance you can do an empirical

00:00:59,480 --> 00:01:03,739
evaluation and then say according to

00:01:01,280 --> 00:01:05,600
this metric this framework a is better

00:01:03,739 --> 00:01:07,880
than framework be but then it comes to

00:01:05,600 --> 00:01:09,730
programming models things often get a

00:01:07,880 --> 00:01:12,890
little bit more subjective and

00:01:09,730 --> 00:01:15,200
nevertheless I want to highlight some of

00:01:12,890 --> 00:01:17,360
the properties of programming model

00:01:15,200 --> 00:01:20,600
which people usually find useful and

00:01:17,360 --> 00:01:25,370
nice to program in right so one of the

00:01:20,600 --> 00:01:28,490
first first properties that I want to

00:01:25,370 --> 00:01:29,930
cover and talk about a bit is that a

00:01:28,490 --> 00:01:33,740
programming model should be

00:01:29,930 --> 00:01:35,480
comprehensible and by that I mean that

00:01:33,740 --> 00:01:38,270
the programming model should be

00:01:35,480 --> 00:01:39,890
sufficiently small and simple so that

00:01:38,270 --> 00:01:42,560
people can easily understand it and

00:01:39,890 --> 00:01:45,740
remember it and we can see a couple of

00:01:42,560 --> 00:01:47,300
examples of this one of them is x86

00:01:45,740 --> 00:01:49,550
assembly which is a particular

00:01:47,300 --> 00:01:53,390
programming model and I can show your

00:01:49,550 --> 00:01:55,460
program in this programming model and I

00:01:53,390 --> 00:01:57,650
guess nobody in the room probably cannot

00:01:55,460 --> 00:01:59,420
answer what this program does and I can

00:01:57,650 --> 00:02:02,480
claim to you that this programming model

00:01:59,420 --> 00:02:04,730
into this program outputs a particular

00:02:02,480 --> 00:02:08,479
pixel at a particular point in the

00:02:04,730 --> 00:02:10,220
screen of a particular color but without

00:02:08,479 --> 00:02:12,620
reading these two manuals which is the

00:02:10,220 --> 00:02:15,760
Intel Architecture software developers

00:02:12,620 --> 00:02:17,769
manual you probably can't be sure if

00:02:15,760 --> 00:02:18,849
done you the truth or not so this

00:02:17,769 --> 00:02:21,099
programming model has a lot of

00:02:18,849 --> 00:02:24,220
instructions a lot of special cases and

00:02:21,099 --> 00:02:27,819
it's certainly very comprehensive but

00:02:24,220 --> 00:02:29,590
it's not very comprehensible on the

00:02:27,819 --> 00:02:31,900
other side of the spectrum you have this

00:02:29,590 --> 00:02:33,790
very very classical programming model

00:02:31,900 --> 00:02:35,620
called the lambda calculus which

00:02:33,790 --> 00:02:37,269
probably many people heard about and

00:02:35,620 --> 00:02:39,190
this is basically the programming model

00:02:37,269 --> 00:02:42,400
which is at the core of functional

00:02:39,190 --> 00:02:44,950
programming and what's interesting is

00:02:42,400 --> 00:02:48,280
that this lambda calculus is exactly

00:02:44,950 --> 00:02:50,290
this exactly as expressive as x86

00:02:48,280 --> 00:02:53,799
assembly so you can write any kind of

00:02:50,290 --> 00:02:57,700
program in it but it has very few rules

00:02:53,799 --> 00:02:59,109
unlike the x86 assembly and here they

00:02:57,700 --> 00:03:00,959
are let's listen so one of them is

00:02:59,109 --> 00:03:04,000
called obstruction so you can write

00:03:00,959 --> 00:03:08,519
expressions terms in this language in

00:03:04,000 --> 00:03:11,349
which basically you declare a variable

00:03:08,519 --> 00:03:13,480
but with is lambda X part and then you

00:03:11,349 --> 00:03:15,489
declare some body which is potentially

00:03:13,480 --> 00:03:18,790
using this this variable this is called

00:03:15,489 --> 00:03:20,980
obstruction and actually in in plain in

00:03:18,790 --> 00:03:22,870
plain terms this is declaring a function

00:03:20,980 --> 00:03:26,290
you say here's an argument here's the

00:03:22,870 --> 00:03:28,540
body another term that you can write in

00:03:26,290 --> 00:03:30,370
this model is called application which

00:03:28,540 --> 00:03:33,069
says basically if I have a function and

00:03:30,370 --> 00:03:35,379
if I have some variable or some value to

00:03:33,069 --> 00:03:37,540
apply it on then I can call that

00:03:35,379 --> 00:03:39,819
function and the third one is a variable

00:03:37,540 --> 00:03:41,590
well if I declare the variable then I

00:03:39,819 --> 00:03:44,709
can use it in that in the body of that

00:03:41,590 --> 00:03:46,569
function and how do you did so this is

00:03:44,709 --> 00:03:48,549
one question what does the programming

00:03:46,569 --> 00:03:50,440
model look like but this is it this is

00:03:48,549 --> 00:03:52,299
how you write programs and the second

00:03:50,440 --> 00:03:54,519
question is how do they evaluate how do

00:03:52,299 --> 00:03:56,859
they progress so let's take a look at a

00:03:54,519 --> 00:03:58,690
simple example where basically what you

00:03:56,859 --> 00:04:01,419
do is then when you see a large program

00:03:58,690 --> 00:04:03,190
you take a look and you look in the end

00:04:01,419 --> 00:04:05,470
you search for this application patterns

00:04:03,190 --> 00:04:07,930
which basically say if I have some kind

00:04:05,470 --> 00:04:09,699
of a lambda on the left and then I have

00:04:07,930 --> 00:04:12,040
some kind of a value on the right then I

00:04:09,699 --> 00:04:15,069
can apply the lambda to the value and

00:04:12,040 --> 00:04:18,400
this under on the left side here this c

00:04:15,069 --> 00:04:20,349
lambda x is x which took on a source of

00:04:18,400 --> 00:04:22,780
functional programming should be also

00:04:20,349 --> 00:04:25,120
known as the identity function it takes

00:04:22,780 --> 00:04:27,010
the argument and just returns it and all

00:04:25,120 --> 00:04:29,590
the right side is some variability or

00:04:27,010 --> 00:04:32,680
value T and what you do here

00:04:29,590 --> 00:04:34,960
is when you see something like this you

00:04:32,680 --> 00:04:37,840
cross out this lambda X and then in the

00:04:34,960 --> 00:04:39,670
body you replace all the occurrences of

00:04:37,840 --> 00:04:41,890
X with the thing which is on the right

00:04:39,670 --> 00:04:44,080
side and surprise surprise you get back

00:04:41,890 --> 00:04:47,410
a tea after applying the identity

00:04:44,080 --> 00:04:49,570
function okay so it seems like this is

00:04:47,410 --> 00:04:52,600
sufficiently comprehensible because it's

00:04:49,570 --> 00:04:54,190
easy to explain and pick up another

00:04:52,600 --> 00:04:56,890
property that I want to highlight here

00:04:54,190 --> 00:04:58,540
is conciseness so a programming model

00:04:56,890 --> 00:05:03,280
should be concise and by this I mean

00:04:58,540 --> 00:05:05,920
that programs written in this model must

00:05:03,280 --> 00:05:07,390
be quick and easy to understand it's not

00:05:05,920 --> 00:05:09,190
just the programming model but this time

00:05:07,390 --> 00:05:12,340
is the programs that result from this

00:05:09,190 --> 00:05:15,460
programming model and let's take a look

00:05:12,340 --> 00:05:18,630
at how well lambda calculus does in this

00:05:15,460 --> 00:05:21,220
in this regard here's a question for you

00:05:18,630 --> 00:05:27,130
does anybody in the audience know what

00:05:21,220 --> 00:05:30,940
is this program do since since there's a

00:05:27,130 --> 00:05:34,120
silence maybe I turn to functional

00:05:30,940 --> 00:05:36,490
programming experts in the room there's

00:05:34,120 --> 00:05:45,190
one sitting over there may be marking

00:05:36,490 --> 00:05:48,520
nose no okay it's okay so the adrian has

00:05:45,190 --> 00:05:51,100
a identified if then else here it's true

00:05:48,520 --> 00:05:52,630
it's something that in a higher level

00:05:51,100 --> 00:05:56,800
functional programming model you would

00:05:52,630 --> 00:05:58,960
write like this and this basically says

00:05:56,800 --> 00:06:00,820
if you give me a boolean then if it's

00:05:58,960 --> 00:06:03,010
boolean is true I'll return false if

00:06:00,820 --> 00:06:04,900
it's false I'll return true which to

00:06:03,010 --> 00:06:07,480
most people is known as the negation

00:06:04,900 --> 00:06:09,490
operator which you apply to two boolean

00:06:07,480 --> 00:06:11,410
right very very simple so the point is

00:06:09,490 --> 00:06:14,230
sometimes you don't want to be too

00:06:11,410 --> 00:06:16,510
minimal because it results in programs

00:06:14,230 --> 00:06:18,070
which are not concise so you need

00:06:16,510 --> 00:06:20,470
something a bit more high-level than

00:06:18,070 --> 00:06:23,340
that so since you're talking about

00:06:20,470 --> 00:06:26,200
distributed programming models here I

00:06:23,340 --> 00:06:28,240
want to highlight one other property

00:06:26,200 --> 00:06:30,280
that which is really important in this

00:06:28,240 --> 00:06:32,950
area and its location transparency and

00:06:30,280 --> 00:06:35,290
basically what this means is that the

00:06:32,950 --> 00:06:38,470
program must run correctly irrespective

00:06:35,290 --> 00:06:40,690
of how it is deployed basically which

00:06:38,470 --> 00:06:42,230
program which machines physical machines

00:06:40,690 --> 00:06:49,730
it runs on and what are the relation

00:06:42,230 --> 00:06:51,230
chips roughly speaking and 111

00:06:49,730 --> 00:06:54,110
programming model that was particularly

00:06:51,230 --> 00:06:56,900
successful in this regard is the actor

00:06:54,110 --> 00:06:59,120
model and here is a particular

00:06:56,900 --> 00:07:00,770
implementation of the actor model or

00:06:59,120 --> 00:07:04,070
basically we have two things first we

00:07:00,770 --> 00:07:05,810
say what is our unit of computing see

00:07:04,070 --> 00:07:08,150
here and that's that's an actor which is

00:07:05,810 --> 00:07:11,180
an independent thing that executes and

00:07:08,150 --> 00:07:14,780
then within this body of this pink actor

00:07:11,180 --> 00:07:17,420
we say we receive whenever we receive a

00:07:14,780 --> 00:07:18,590
message which is how actors communicate

00:07:17,420 --> 00:07:23,420
so when we receive a message from

00:07:18,590 --> 00:07:25,760
another actor say punk then we sent with

00:07:23,420 --> 00:07:29,090
this exclamation operator called Bank

00:07:25,760 --> 00:07:30,740
the response pink to whoever the sender

00:07:29,090 --> 00:07:32,270
was so we actually have a special

00:07:30,740 --> 00:07:35,060
dynamic variable called the sender which

00:07:32,270 --> 00:07:37,670
tells us who sent us the message and the

00:07:35,060 --> 00:07:40,100
way it looks like is if this unit of

00:07:37,670 --> 00:07:42,980
computing serious punk it sends back a

00:07:40,100 --> 00:07:44,690
pink and now if you want to play

00:07:42,980 --> 00:07:46,910
ping-pong between two actors then we

00:07:44,690 --> 00:07:48,350
have to just kind of like reverse the

00:07:46,910 --> 00:07:50,420
implementation on the top say if you

00:07:48,350 --> 00:07:53,000
receive a pink we send centre-back a

00:07:50,420 --> 00:07:55,460
punk and this is a very this is usually

00:07:53,000 --> 00:07:57,020
a useful benchmark to look at when

00:07:55,460 --> 00:08:00,500
you're in your testing director systems

00:07:57,020 --> 00:08:03,320
how would they perform and okay so in

00:08:00,500 --> 00:08:05,000
the last last property that I want to

00:08:03,320 --> 00:08:08,420
cover in this introduction is

00:08:05,000 --> 00:08:10,660
composability a programming model should

00:08:08,420 --> 00:08:14,060
be composable and by this I mean

00:08:10,660 --> 00:08:16,700
programs must be you must be able to

00:08:14,060 --> 00:08:21,020
build programs from smaller independent

00:08:16,700 --> 00:08:23,240
programs and let's take an example of

00:08:21,020 --> 00:08:26,060
that let's study on a particular use

00:08:23,240 --> 00:08:28,790
case how well does the actor model do

00:08:26,060 --> 00:08:30,380
with in this regard how well the

00:08:28,790 --> 00:08:34,090
programs written in the actor model

00:08:30,380 --> 00:08:37,340
compose so let's take a very famous

00:08:34,090 --> 00:08:40,970
protocol which a product by a protocol I

00:08:37,340 --> 00:08:43,250
mean an exchange of messages in which is

00:08:40,970 --> 00:08:45,680
called the server client model so here

00:08:43,250 --> 00:08:47,150
basically have one unit of computing see

00:08:45,680 --> 00:08:48,950
call the client which says sends a

00:08:47,150 --> 00:08:51,650
request to the server server does

00:08:48,950 --> 00:08:54,680
something and sends back a response what

00:08:51,650 --> 00:08:55,640
we're interested in is in expressing the

00:08:54,680 --> 00:08:58,040
server and the client

00:08:55,640 --> 00:09:00,350
and somehow generically has generic

00:08:58,040 --> 00:09:02,930
components in this model so that we can

00:09:00,350 --> 00:09:05,030
later use them and here's how we could

00:09:02,930 --> 00:09:09,050
do we could encode the server basically

00:09:05,030 --> 00:09:11,690
the same a server is an actor which for

00:09:09,050 --> 00:09:13,850
some to type parameters T which is the

00:09:11,690 --> 00:09:16,160
type of the request and s which is the

00:09:13,850 --> 00:09:18,920
type of the reply takes a mapping

00:09:16,160 --> 00:09:21,800
function from t2 s and then sends this

00:09:18,920 --> 00:09:23,510
reply back to the client and very simple

00:09:21,800 --> 00:09:26,870
way to implement this is by saying this

00:09:23,510 --> 00:09:29,740
in the receive if the incoming request

00:09:26,870 --> 00:09:32,780
is of type T we sent the sender back and

00:09:29,740 --> 00:09:35,720
application of function f to this to

00:09:32,780 --> 00:09:37,970
this request okay so how can we

00:09:35,720 --> 00:09:39,560
implement a generic client well similar

00:09:37,970 --> 00:09:42,410
it's slightly more complicated but still

00:09:39,560 --> 00:09:44,480
rather simple first we say that the

00:09:42,410 --> 00:09:47,030
client also takes to type parameters TNS

00:09:44,480 --> 00:09:49,190
it needs a reference to the server to

00:09:47,030 --> 00:09:51,860
which it will send a request then it

00:09:49,190 --> 00:09:53,330
needs a request itself and then it needs

00:09:51,860 --> 00:09:56,090
some kind of a function which is the

00:09:53,330 --> 00:09:58,330
action if I receive a reply from the

00:09:56,090 --> 00:10:00,770
server here's what I have to do an

00:09:58,330 --> 00:10:03,530
implementation of this is as follows

00:10:00,770 --> 00:10:06,890
when the actor starts it sends the

00:10:03,530 --> 00:10:09,790
request to the server and then waits for

00:10:06,890 --> 00:10:12,890
the reply and when the reply receives

00:10:09,790 --> 00:10:16,010
arrives if it arrives it applies the

00:10:12,890 --> 00:10:17,750
action and it's it is there are two main

00:10:16,010 --> 00:10:20,690
components generic components that we

00:10:17,750 --> 00:10:23,510
can hopefully reuse so let's take a look

00:10:20,690 --> 00:10:26,990
how we can reuse these components on an

00:10:23,510 --> 00:10:29,000
instance of a particular protocol which

00:10:26,990 --> 00:10:31,190
is the name server protocol this

00:10:29,000 --> 00:10:34,070
protocol you're keeping a mapping

00:10:31,190 --> 00:10:36,110
between the names two locations kind of

00:10:34,070 --> 00:10:37,580
where locations are your actor reference

00:10:36,110 --> 00:10:41,090
is something that you can later send

00:10:37,580 --> 00:10:44,450
messages to so basically what we can do

00:10:41,090 --> 00:10:47,060
is declare a map from string to actor

00:10:44,450 --> 00:10:49,880
reference and then since this map is a

00:10:47,060 --> 00:10:52,460
function in Scala just as it happens we

00:10:49,880 --> 00:10:55,400
can use it in the server protocol to

00:10:52,460 --> 00:10:57,170
instantiate a new server and then

00:10:55,400 --> 00:10:59,480
started with a special actor of

00:10:57,170 --> 00:11:01,760
construct is basically for an actor

00:10:59,480 --> 00:11:04,310
template that we did previously starts

00:11:01,760 --> 00:11:06,530
one instance of this template this gives

00:11:04,310 --> 00:11:08,420
us the connector reference called NS

00:11:06,530 --> 00:11:09,270
name server which we can send messages

00:11:08,420 --> 00:11:12,010
to

00:11:09,270 --> 00:11:14,620
so this is it so we reused our generic

00:11:12,010 --> 00:11:16,660
component to create a more specific

00:11:14,620 --> 00:11:20,830
component the name server which is a

00:11:16,660 --> 00:11:23,800
special very special kind of server now

00:11:20,830 --> 00:11:25,870
we can also in the same day instant she

00:11:23,800 --> 00:11:28,330
ate a client and by with a client in

00:11:25,870 --> 00:11:30,700
this case we say take the reference to

00:11:28,330 --> 00:11:33,640
the name server and then as the name

00:11:30,700 --> 00:11:36,040
server for a particular actor reference

00:11:33,640 --> 00:11:39,400
which is mapped under the key p under

00:11:36,040 --> 00:11:40,960
the name p and then when you get the

00:11:39,400 --> 00:11:43,720
answer back than just printed to the

00:11:40,960 --> 00:11:46,600
standard output for simplicity and the

00:11:43,720 --> 00:11:51,220
way this looks is the client sends the

00:11:46,600 --> 00:11:53,980
message p and the server responds so it

00:11:51,220 --> 00:11:56,110
looks like our actor model here is

00:11:53,980 --> 00:11:59,980
composable in the sense that we were

00:11:56,110 --> 00:12:01,960
able to create a bigger program by

00:11:59,980 --> 00:12:04,150
composing together smaller components

00:12:01,960 --> 00:12:06,520
namely this case server and client which

00:12:04,150 --> 00:12:08,620
are independent from each other but now

00:12:06,520 --> 00:12:13,570
let's add a little twist to this

00:12:08,620 --> 00:12:16,330
protocol let's say that our distributed

00:12:13,570 --> 00:12:18,580
system needs to scale and by this I mean

00:12:16,330 --> 00:12:20,890
there are a lot of clients which now

00:12:18,580 --> 00:12:23,050
want to access this name server and this

00:12:20,890 --> 00:12:25,360
is typically the case in practice right

00:12:23,050 --> 00:12:27,190
you have one dns server but you have

00:12:25,360 --> 00:12:30,130
many people across the world asking it

00:12:27,190 --> 00:12:31,960
for for actual IP addresses right so in

00:12:30,130 --> 00:12:35,260
the same sense what we want to do we

00:12:31,960 --> 00:12:38,230
want to cash divide the name spin the

00:12:35,260 --> 00:12:41,620
namespace of all the names and then we

00:12:38,230 --> 00:12:45,490
want to put intermediate actors called

00:12:41,620 --> 00:12:47,670
cash caches which serve just parts of

00:12:45,490 --> 00:12:50,800
that namespace so in particular this

00:12:47,670 --> 00:12:53,710
intermediate actor cash should now serve

00:12:50,800 --> 00:12:58,060
just then the director reference under

00:12:53,710 --> 00:13:00,070
this key p2 all the clients so let's see

00:12:58,060 --> 00:13:01,810
how we can do this and let's retry let's

00:13:00,070 --> 00:13:04,980
try to use the existing components that

00:13:01,810 --> 00:13:08,170
we have so the first thing to notice is

00:13:04,980 --> 00:13:11,770
the disk cache actor itself it is a

00:13:08,170 --> 00:13:14,290
client why well because further day when

00:13:11,770 --> 00:13:15,700
you create a new cache actor it is

00:13:14,290 --> 00:13:18,700
initially empty it has some kind of

00:13:15,700 --> 00:13:20,980
state and this state is this embodied in

00:13:18,700 --> 00:13:21,860
this variable C of type actor reference

00:13:20,980 --> 00:13:25,100
it is initially

00:13:21,860 --> 00:13:27,440
and then when the cash starts it should

00:13:25,100 --> 00:13:29,660
actually as the name server for its

00:13:27,440 --> 00:13:33,470
initial value so it should send to the

00:13:29,660 --> 00:13:36,050
name server a request for this name p

00:13:33,470 --> 00:13:38,269
and when it gets a request reply back it

00:13:36,050 --> 00:13:40,760
should store it to this to this local

00:13:38,269 --> 00:13:43,339
variable and we can do this so we can

00:13:40,760 --> 00:13:45,260
reuse client and now you did this part

00:13:43,339 --> 00:13:48,470
of the part of the story and and seems

00:13:45,260 --> 00:13:51,200
like this is reusable so far but in the

00:13:48,470 --> 00:13:53,839
next step we have to notice that cash is

00:13:51,200 --> 00:13:56,060
also a server because after the point

00:13:53,839 --> 00:13:58,160
that it gets some initial value of the

00:13:56,060 --> 00:14:03,140
cash it now needs to serve its clients

00:13:58,160 --> 00:14:08,300
and what we'd like to do is now mixing

00:14:03,140 --> 00:14:09,709
add this other class that plus of actors

00:14:08,300 --> 00:14:12,170
that we define which is called server

00:14:09,709 --> 00:14:14,089
but we can't really do that in

00:14:12,170 --> 00:14:15,589
particular we can't do it because we

00:14:14,089 --> 00:14:17,839
don't have for example multiple

00:14:15,589 --> 00:14:19,940
inheritance so we cannot merge these

00:14:17,839 --> 00:14:22,040
things together we could alternatively

00:14:19,940 --> 00:14:23,630
define these two things client and

00:14:22,040 --> 00:14:26,899
server straights then we could mix them

00:14:23,630 --> 00:14:29,839
together again but the question is they

00:14:26,899 --> 00:14:32,060
both the problem is they both declare

00:14:29,839 --> 00:14:33,320
the method called receive and which is

00:14:32,060 --> 00:14:34,850
the right method receive that they

00:14:33,320 --> 00:14:38,480
should receive how do you merge them

00:14:34,850 --> 00:14:39,800
together it's very unclear so the best

00:14:38,480 --> 00:14:44,029
thing that we can do in this situation

00:14:39,800 --> 00:14:45,500
is to say okay we're override the method

00:14:44,029 --> 00:14:48,860
receive and we'll define it ourselves

00:14:45,500 --> 00:14:51,170
and then we'll say okay this is the

00:14:48,860 --> 00:14:54,560
method receive by default it should

00:14:51,170 --> 00:14:56,269
propagate all the requests to the super

00:14:54,560 --> 00:14:59,570
receive to the receive defined in the

00:14:56,269 --> 00:15:02,420
client but then if the client since its

00:14:59,570 --> 00:15:04,550
a partial function if it doesn't handle

00:15:02,420 --> 00:15:08,690
some of the requests then you should

00:15:04,550 --> 00:15:11,810
apply the second partial function which

00:15:08,690 --> 00:15:14,120
if it says if I get a string then I

00:15:11,810 --> 00:15:15,829
should reply to the sender which is the

00:15:14,120 --> 00:15:18,680
client bit whatever I cashed in the

00:15:15,829 --> 00:15:22,430
field c and this is the best i can do

00:15:18,680 --> 00:15:25,370
and the problem here is that basically i

00:15:22,430 --> 00:15:28,519
didn't reuse my generic component which

00:15:25,370 --> 00:15:30,440
is called server so i'm already

00:15:28,519 --> 00:15:32,870
repeating myself and this is a very

00:15:30,440 --> 00:15:34,069
minimal example so you might say okay it

00:15:32,870 --> 00:15:35,209
doesn't matter we just repeated

00:15:34,069 --> 00:15:37,459
ourselves a little

00:15:35,209 --> 00:15:39,259
but generally this server could be huge

00:15:37,459 --> 00:15:41,449
and you want to avoid this you really

00:15:39,259 --> 00:15:45,199
want to reuse existing components to

00:15:41,449 --> 00:15:47,869
have better code and things get a little

00:15:45,199 --> 00:15:50,209
bit worse if you add a second list to

00:15:47,869 --> 00:15:52,129
this couch protocol saying that from

00:15:50,209 --> 00:15:54,800
time to time this name server may may

00:15:52,129 --> 00:15:56,509
fail and when it fails we need to

00:15:54,800 --> 00:15:58,730
invalidate the cash and then repopulate

00:15:56,509 --> 00:16:01,249
it so somebody might say okay let's

00:15:58,730 --> 00:16:03,920
modify this cache implementation now and

00:16:01,249 --> 00:16:09,220
let's say whenever I send the cash and

00:16:03,920 --> 00:16:12,399
actor reference then this then this

00:16:09,220 --> 00:16:16,100
connector reference to the new server

00:16:12,399 --> 00:16:18,699
then the cash should again send this

00:16:16,100 --> 00:16:22,129
initial message p to the new server and

00:16:18,699 --> 00:16:25,429
wait for the response to actually build

00:16:22,129 --> 00:16:28,339
up its cash again and the problem is

00:16:25,429 --> 00:16:30,490
this won't even work does anybody see

00:16:28,339 --> 00:16:30,490
why

00:16:34,830 --> 00:16:42,580
yes it will receive the this server the

00:16:39,310 --> 00:16:45,640
sensor from the server if it sends it a

00:16:42,580 --> 00:16:49,350
new request right but the question is

00:16:45,640 --> 00:16:49,350
will this case even be handled ever

00:16:49,890 --> 00:16:55,720
exactly it's already handled this super

00:16:52,720 --> 00:16:58,210
receive because when they according to

00:16:55,720 --> 00:17:00,610
the implementation of the client if this

00:16:58,210 --> 00:17:02,080
actor receives an actor reference then

00:17:00,610 --> 00:17:03,970
the super receive will already do

00:17:02,080 --> 00:17:05,800
something with it and we don't see this

00:17:03,970 --> 00:17:08,170
from this implementation so we have to

00:17:05,800 --> 00:17:10,540
know something we have to know the exact

00:17:08,170 --> 00:17:11,920
implementation of receiving the super

00:17:10,540 --> 00:17:14,560
client to know that they're not allowed

00:17:11,920 --> 00:17:17,530
to do this and this is problematic in

00:17:14,560 --> 00:17:20,410
practice I argue and the conclusion here

00:17:17,530 --> 00:17:25,600
is that the actor model does not compose

00:17:20,410 --> 00:17:27,220
well and to answer this problem what I

00:17:25,600 --> 00:17:29,830
want to talk about after this long

00:17:27,220 --> 00:17:32,410
introduction in the rest of of this talk

00:17:29,830 --> 00:17:34,870
is a new programming model called the

00:17:32,410 --> 00:17:38,170
reactor model which is designed to

00:17:34,870 --> 00:17:40,060
address these problems and when you're

00:17:38,170 --> 00:17:41,590
talking about concurrency models or

00:17:40,060 --> 00:17:43,270
distributed computing models usually

00:17:41,590 --> 00:17:46,570
there are two main questions that you

00:17:43,270 --> 00:17:48,640
need to answer the first question is how

00:17:46,570 --> 00:17:52,540
do you express concurrency in the system

00:17:48,640 --> 00:17:55,240
so how do I say that 11 computation is

00:17:52,540 --> 00:17:57,670
computing to another computation and the

00:17:55,240 --> 00:18:00,160
second question is that of information

00:17:57,670 --> 00:18:01,810
exchange how do i make concurrent

00:18:00,160 --> 00:18:03,550
entities in the system exchange

00:18:01,810 --> 00:18:06,490
information with each other to basically

00:18:03,550 --> 00:18:08,320
synchronize so let's take a look at the

00:18:06,490 --> 00:18:10,450
easier one and that's expressing

00:18:08,320 --> 00:18:13,080
concurrency so this is one thing that

00:18:10,450 --> 00:18:15,250
worked rather well in the actor model

00:18:13,080 --> 00:18:17,230
because basically what we did we

00:18:15,250 --> 00:18:19,840
extended an actor class and by this we

00:18:17,230 --> 00:18:22,270
said everything that executes in this

00:18:19,840 --> 00:18:24,010
template should always execute as a

00:18:22,270 --> 00:18:26,050
separate unit of computing see and

00:18:24,010 --> 00:18:27,400
things that happen inside they should

00:18:26,050 --> 00:18:30,040
always serialize there should never be

00:18:27,400 --> 00:18:32,380
two threads executing code within within

00:18:30,040 --> 00:18:34,270
this within this block this is a very

00:18:32,380 --> 00:18:36,160
useful property because it guarantees

00:18:34,270 --> 00:18:37,750
you that you will never have raised

00:18:36,160 --> 00:18:39,460
conditions you will never have data

00:18:37,750 --> 00:18:41,560
races so you want me to use locks

00:18:39,460 --> 00:18:45,550
another synchronization which is error

00:18:41,560 --> 00:18:48,140
prone and and and often expensive so for

00:18:45,550 --> 00:18:51,080
example if we wanted to declare a cash

00:18:48,140 --> 00:18:52,760
reactor this time we will just declare

00:18:51,080 --> 00:18:54,650
like local state same as in the actor

00:18:52,760 --> 00:18:56,600
model for some reason you would have an

00:18:54,650 --> 00:18:58,460
additional type parameter here and I'm

00:18:56,600 --> 00:19:00,020
going to cover that in a second I'm

00:18:58,460 --> 00:19:02,450
going to come back to it so just just

00:19:00,020 --> 00:19:04,400
please ignore it for now let's take a

00:19:02,450 --> 00:19:07,190
look at this more important and bigger

00:19:04,400 --> 00:19:08,930
piece of the puzzle which is how do you

00:19:07,190 --> 00:19:12,980
send and receive information between

00:19:08,930 --> 00:19:16,450
this between these reactors the basic

00:19:12,980 --> 00:19:19,040
construct in this model is called open

00:19:16,450 --> 00:19:22,610
basically what open does it creates a

00:19:19,040 --> 00:19:24,590
pipe between the actor reactor in this

00:19:22,610 --> 00:19:26,890
case and the end the outer world and the

00:19:24,590 --> 00:19:29,870
rest of the world so when you call open

00:19:26,890 --> 00:19:32,600
with some particular type parameter T

00:19:29,870 --> 00:19:35,480
you're saying i want to send exchange

00:19:32,600 --> 00:19:37,820
messages receive messages from other

00:19:35,480 --> 00:19:40,760
reactors in the system which are of type

00:19:37,820 --> 00:19:42,890
T and what I'll get back in order to

00:19:40,760 --> 00:19:44,570
achieve this is to objects one is called

00:19:42,890 --> 00:19:46,340
the event stream this is this first

00:19:44,570 --> 00:19:50,060
thing and the second is called the

00:19:46,340 --> 00:19:51,950
channel and what's important to note

00:19:50,060 --> 00:19:55,430
here is that this event stream is the

00:19:51,950 --> 00:19:58,580
reading end of this pipe to the reactor

00:19:55,430 --> 00:20:00,740
that called open director that called

00:19:58,580 --> 00:20:04,040
open is the only reactor in the system

00:20:00,740 --> 00:20:05,600
that can read from this event stream the

00:20:04,040 --> 00:20:07,430
channel on the other head is the writing

00:20:05,600 --> 00:20:09,590
and this is something that the reactor

00:20:07,430 --> 00:20:12,050
can share with all the other reactors in

00:20:09,590 --> 00:20:14,630
the system in order to receive messages

00:20:12,050 --> 00:20:16,430
from it and shown graphically it looks

00:20:14,630 --> 00:20:19,460
like this so basically we have some kind

00:20:16,430 --> 00:20:20,900
of boundary of an offer reactor and on

00:20:19,460 --> 00:20:22,850
the left hand side you have this event

00:20:20,900 --> 00:20:25,190
stream which you listen to events in

00:20:22,850 --> 00:20:27,230
which you listen to events and hear any

00:20:25,190 --> 00:20:29,450
other reactor in the system can put

00:20:27,230 --> 00:20:32,300
events in the urn tease that they will

00:20:29,450 --> 00:20:36,650
eventually be delivered to the left hand

00:20:32,300 --> 00:20:38,570
side so let's see an example of that but

00:20:36,650 --> 00:20:40,880
in particular if you want to open a pipe

00:20:38,570 --> 00:20:43,130
that delivers string events and we call

00:20:40,880 --> 00:20:45,290
this open method with the type parameter

00:20:43,130 --> 00:20:47,540
string we get back an event stream and a

00:20:45,290 --> 00:20:49,850
channel and with the event string we can

00:20:47,540 --> 00:20:52,760
call a special method called an event

00:20:49,850 --> 00:20:55,790
which registers a callback which says

00:20:52,760 --> 00:20:57,530
every time you receive an event you can

00:20:55,790 --> 00:21:00,860
do something with it for example printed

00:20:57,530 --> 00:21:01,430
and if you if another reactor wants to

00:21:00,860 --> 00:21:03,470
send

00:21:01,430 --> 00:21:06,230
particular events through this channel

00:21:03,470 --> 00:21:09,200
then it just uses the bank operator just

00:21:06,230 --> 00:21:12,920
as before and if you take a look at if

00:21:09,200 --> 00:21:15,260
you imagine a distributed system then it

00:21:12,920 --> 00:21:17,330
looks kind of as follows so you have

00:21:15,260 --> 00:21:19,220
multiple reactors in the system with

00:21:17,330 --> 00:21:21,020
different roles for example you could

00:21:19,220 --> 00:21:24,140
have a timer on the right hand side

00:21:21,020 --> 00:21:26,120
which produce produces some kind of

00:21:24,140 --> 00:21:28,100
timing events you have a keyboard which

00:21:26,120 --> 00:21:30,860
produces input events and there's one

00:21:28,100 --> 00:21:33,470
channel down here which sends these

00:21:30,860 --> 00:21:35,600
events to the event stream belonging to

00:21:33,470 --> 00:21:37,730
this UI logic reactor and there's

00:21:35,600 --> 00:21:39,200
another one up here this is very

00:21:37,730 --> 00:21:41,240
different for what you hear in an actor

00:21:39,200 --> 00:21:43,280
model where they're basically sending

00:21:41,240 --> 00:21:45,590
all these events to the same entry point

00:21:43,280 --> 00:21:48,380
but here there are two different entry

00:21:45,590 --> 00:21:50,810
points and they have the guarantee that

00:21:48,380 --> 00:21:53,660
when processing events that arrived here

00:21:50,810 --> 00:21:57,140
I will never process them within this

00:21:53,660 --> 00:21:58,760
box at the same time so it's this is

00:21:57,140 --> 00:22:01,430
called serializability it basically

00:21:58,760 --> 00:22:04,630
tells you that it will never happen that

00:22:01,430 --> 00:22:07,460
I'm modifying state in the own event

00:22:04,630 --> 00:22:10,220
block here and here at the same time

00:22:07,460 --> 00:22:11,900
this is very useful but still what's

00:22:10,220 --> 00:22:13,760
also useful is that these two events

00:22:11,900 --> 00:22:15,560
dreams they don't not need to know about

00:22:13,760 --> 00:22:17,450
each other so that there can be no name

00:22:15,560 --> 00:22:20,290
clash that there cannot be any miss

00:22:17,450 --> 00:22:22,610
delivered events coming to this upper

00:22:20,290 --> 00:22:25,670
entry point and this lower entry point

00:22:22,610 --> 00:22:28,910
they're totally independent okay so this

00:22:25,670 --> 00:22:30,620
is this is what the what the programming

00:22:28,910 --> 00:22:32,780
model looks like you're just declaring

00:22:30,620 --> 00:22:35,600
the reactor and this open method and

00:22:32,780 --> 00:22:38,540
that's it and now let's let's try to

00:22:35,600 --> 00:22:40,580
evaluate and see if it's good and people

00:22:38,540 --> 00:22:42,650
try to do here I'll try to argue that

00:22:40,580 --> 00:22:45,380
this does solve the problems that are

00:22:42,650 --> 00:22:47,780
that we previously saw by implementing

00:22:45,380 --> 00:22:51,710
the same kind of server client protocol

00:22:47,780 --> 00:22:54,530
in this model so let's start with the

00:22:51,710 --> 00:22:56,930
server the first thing that when you

00:22:54,530 --> 00:22:59,660
have to notice is not that in this

00:22:56,930 --> 00:23:02,810
particular model we don't have the

00:22:59,660 --> 00:23:04,910
sender dynamic variable anymore so if

00:23:02,810 --> 00:23:07,010
the server wants to reply something to

00:23:04,910 --> 00:23:11,090
the client it needs to know which

00:23:07,010 --> 00:23:12,950
channel to the plot to reply on so

00:23:11,090 --> 00:23:15,020
basically when the server receives

00:23:12,950 --> 00:23:17,960
events that is requests

00:23:15,020 --> 00:23:19,880
from the client shouldn't just receive T

00:23:17,960 --> 00:23:22,430
should shoot you should also receive

00:23:19,880 --> 00:23:24,920
this channel of s which is the channel

00:23:22,430 --> 00:23:27,140
on which it can send the day events back

00:23:24,920 --> 00:23:29,360
this is basically the sender and because

00:23:27,140 --> 00:23:30,920
this type is kind of clunky and long we

00:23:29,360 --> 00:23:33,020
can introduce the type a lease for it

00:23:30,920 --> 00:23:37,610
and say this is called a request channel

00:23:33,020 --> 00:23:39,410
of four types TNS and this time when

00:23:37,610 --> 00:23:42,290
implementing the server we're going to

00:23:39,410 --> 00:23:44,270
take a really different approach than

00:23:42,290 --> 00:23:47,990
what we had in the actor model we're not

00:23:44,270 --> 00:23:49,940
going to extend the reactor abstract

00:23:47,990 --> 00:23:52,430
class to say that this is the reactor

00:23:49,940 --> 00:23:56,690
will encode this protocol in a method

00:23:52,430 --> 00:23:58,970
and here we'll say here's a method

00:23:56,690 --> 00:24:00,740
called server you should give me to type

00:23:58,970 --> 00:24:02,330
parameters of the request and a reply

00:24:00,740 --> 00:24:04,790
should you should again give me a

00:24:02,330 --> 00:24:10,940
mapping function and what I'll give you

00:24:04,790 --> 00:24:12,800
back is a channel of this type by well

00:24:10,940 --> 00:24:16,040
because if I share this channel with

00:24:12,800 --> 00:24:18,470
other reactors they will be able to send

00:24:16,040 --> 00:24:21,290
me requests and the response channels

00:24:18,470 --> 00:24:23,480
and I'll be able to answer them so the

00:24:21,290 --> 00:24:26,960
contract of this method has to be that

00:24:23,480 --> 00:24:31,310
whatever event comes on this channel it

00:24:26,960 --> 00:24:33,290
has to reply back with this reply on the

00:24:31,310 --> 00:24:36,770
response channel so let's try to

00:24:33,290 --> 00:24:39,470
implement this and the first thing that

00:24:36,770 --> 00:24:43,220
we can notice is that this screen is a

00:24:39,470 --> 00:24:45,410
little bit too narrow but if this were

00:24:43,220 --> 00:24:47,810
one line basically it would say we want

00:24:45,410 --> 00:24:49,460
to open a new channel well obviously if

00:24:47,810 --> 00:24:51,680
you return a new channel we have to call

00:24:49,460 --> 00:24:53,830
this open method at least once in the in

00:24:51,680 --> 00:24:56,870
the implementation here right so we can

00:24:53,830 --> 00:24:59,330
recall this open to open a new channel

00:24:56,870 --> 00:25:01,970
which has exactly this type of events

00:24:59,330 --> 00:25:04,190
that we declared up here request and

00:25:01,970 --> 00:25:06,890
response channel and then we get back an

00:25:04,190 --> 00:25:09,620
event stream and a channel and this

00:25:06,890 --> 00:25:13,010
event stream should have the property

00:25:09,620 --> 00:25:15,830
that whatever event comes in here we

00:25:13,010 --> 00:25:17,750
have to respond back and this is how we

00:25:15,830 --> 00:25:19,580
write this so now we're not using one

00:25:17,750 --> 00:25:21,500
event if you're using on match but it's

00:25:19,580 --> 00:25:23,180
the same thing just you can just put a

00:25:21,500 --> 00:25:24,580
partial function here but it's basically

00:25:23,180 --> 00:25:28,440
the same thing it tells you that

00:25:24,580 --> 00:25:30,780
whenever you receive a particular

00:25:28,440 --> 00:25:33,570
and which has the request and the

00:25:30,780 --> 00:25:35,730
response channel you can map the request

00:25:33,570 --> 00:25:39,030
and send it back to the response channel

00:25:35,730 --> 00:25:41,610
and now that we encoded the contract of

00:25:39,030 --> 00:25:44,430
this special channel we can just return

00:25:41,610 --> 00:25:45,570
this channel and we're done and this is

00:25:44,430 --> 00:25:51,930
the implementation of the server

00:25:45,570 --> 00:25:54,300
protocol let's try to implement the

00:25:51,930 --> 00:25:57,330
client protocol so again we have this

00:25:54,300 --> 00:26:02,820
helper type up here and now we will

00:25:57,330 --> 00:26:05,820
encode the the client protocol as this !

00:26:02,820 --> 00:26:09,240
method which takes to type parameters T

00:26:05,820 --> 00:26:11,490
and s and then it says give me a server

00:26:09,240 --> 00:26:13,710
channel because I have to send this

00:26:11,490 --> 00:26:16,830
request somewhere and then give me just

00:26:13,710 --> 00:26:19,200
a request that you want to send i will

00:26:16,830 --> 00:26:21,540
give you back an event stream to which

00:26:19,200 --> 00:26:25,500
if you subscribe to you will eventually

00:26:21,540 --> 00:26:27,720
get the answer if it arrives and again

00:26:25,500 --> 00:26:29,880
since you returned a new event stream we

00:26:27,720 --> 00:26:32,610
have to call open at least once and a

00:26:29,880 --> 00:26:35,100
good indication since the type is the S

00:26:32,610 --> 00:26:37,140
which is the type of the replies you

00:26:35,100 --> 00:26:40,890
have to call open with s and now we have

00:26:37,140 --> 00:26:42,660
an event stream and a channel and what

00:26:40,890 --> 00:26:46,680
we can do with that we can use the

00:26:42,660 --> 00:26:50,670
request channel to send the server our

00:26:46,680 --> 00:26:53,370
request of type T and the channel to get

00:26:50,670 --> 00:26:54,930
the response from remember from the

00:26:53,370 --> 00:26:57,540
previous slide that the responses will

00:26:54,930 --> 00:26:58,890
come on this channel that means that

00:26:57,540 --> 00:27:01,140
they will eventually be propagated to

00:26:58,890 --> 00:27:02,520
these events and it means that this

00:27:01,140 --> 00:27:05,610
event stream is the thing that we need

00:27:02,520 --> 00:27:11,460
to return and that's it this is the

00:27:05,610 --> 00:27:14,130
client protocol now to see if this thing

00:27:11,460 --> 00:27:15,750
is really composable let's try to

00:27:14,130 --> 00:27:20,010
implement the cache protocol which we

00:27:15,750 --> 00:27:21,780
had trouble with the last time and let's

00:27:20,010 --> 00:27:24,030
first think about what akash protocol is

00:27:21,780 --> 00:27:26,280
first again we're not going to encode it

00:27:24,030 --> 00:27:29,250
as a reactor will encode it as a method

00:27:26,280 --> 00:27:30,750
this method should tell us it should

00:27:29,250 --> 00:27:33,390
basically get some information first

00:27:30,750 --> 00:27:36,120
about where the real server is whose

00:27:33,390 --> 00:27:38,790
type is request yes and then you should

00:27:36,120 --> 00:27:40,590
get some information about what what

00:27:38,790 --> 00:27:41,850
what is the value that we cash in what

00:27:40,590 --> 00:27:43,830
should we ask the server

00:27:41,850 --> 00:27:46,620
you know in order to get the cash value

00:27:43,830 --> 00:27:51,059
back and this is this X and then what we

00:27:46,620 --> 00:27:53,610
get back is a request channel of type T

00:27:51,059 --> 00:27:56,340
s which is exactly the same type as the

00:27:53,610 --> 00:27:58,710
server channel but this request channel

00:27:56,340 --> 00:28:00,450
will not contact with its request the

00:27:58,710 --> 00:28:04,860
main server if you just serve back the

00:28:00,450 --> 00:28:08,549
cached values so how do we do this we

00:28:04,860 --> 00:28:10,860
first declare some local state in this

00:28:08,549 --> 00:28:14,190
case cached which is just a variable of

00:28:10,860 --> 00:28:16,230
type s which wishes which has no initial

00:28:14,190 --> 00:28:21,929
value at no meaningful value initially

00:28:16,230 --> 00:28:24,150
and then we use the client protocol the

00:28:21,929 --> 00:28:27,240
request protocol that we defined earlier

00:28:24,150 --> 00:28:28,950
to ask the real server what is the value

00:28:27,240 --> 00:28:31,440
that we should be cashing and when we

00:28:28,950 --> 00:28:33,720
get a reply back we just say okay this

00:28:31,440 --> 00:28:39,419
cached field should be initialized to to

00:28:33,720 --> 00:28:42,210
this value Y and then after that we need

00:28:39,419 --> 00:28:43,799
to return the new you new kind of server

00:28:42,210 --> 00:28:45,809
channel but this server channel

00:28:43,799 --> 00:28:48,330
shouldn't be the real server channel

00:28:45,809 --> 00:28:49,980
shouldn't just call the real server or

00:28:48,330 --> 00:28:52,320
an order mapping function to compute the

00:28:49,980 --> 00:28:57,630
reply it should just always return this

00:28:52,320 --> 00:29:00,059
cash value and it's if this is our

00:28:57,630 --> 00:29:02,789
generic cash protocol and notice that in

00:29:00,059 --> 00:29:04,530
this generic cash protocol we reused the

00:29:02,789 --> 00:29:06,840
two components that we defined

00:29:04,530 --> 00:29:09,330
previously namely the client and the

00:29:06,840 --> 00:29:12,059
server and now if you want to

00:29:09,330 --> 00:29:14,460
instantiate the sketch protocol in a

00:29:12,059 --> 00:29:17,309
special concurrency unit the actual cash

00:29:14,460 --> 00:29:20,039
in our in our name server protocol then

00:29:17,309 --> 00:29:24,360
we do the following first we help

00:29:20,039 --> 00:29:26,549
ourselves again by saying that when we

00:29:24,360 --> 00:29:28,140
whenever we have a reactor whose input

00:29:26,549 --> 00:29:30,750
type is something that looks like

00:29:28,140 --> 00:29:33,090
channel channel events basically a

00:29:30,750 --> 00:29:34,080
request and response channel then we

00:29:33,090 --> 00:29:35,700
actually want to have a shorthand

00:29:34,080 --> 00:29:37,950
convenient name for it we want to call

00:29:35,700 --> 00:29:41,039
it the server 40s which is reasonable

00:29:37,950 --> 00:29:42,659
and then we can write this shorter so

00:29:41,039 --> 00:29:46,169
that it fits on this slide in this time

00:29:42,659 --> 00:29:48,000
so we can say that class cash is a

00:29:46,169 --> 00:29:52,620
special kind of reactor which is a

00:29:48,000 --> 00:29:55,440
server and then in its body we should

00:29:52,620 --> 00:29:56,879
say the following so first of all

00:29:55,440 --> 00:29:59,700
I think that I didn't they promised to

00:29:56,879 --> 00:30:02,429
show earlier is to explain why do we

00:29:59,700 --> 00:30:04,049
have type parameters with reactors when

00:30:02,429 --> 00:30:06,899
we didn't have type type parameters with

00:30:04,049 --> 00:30:08,340
actors we're basically in this model you

00:30:06,899 --> 00:30:11,789
have the guarantee that whenever you

00:30:08,340 --> 00:30:14,429
create a reactor initially the open

00:30:11,789 --> 00:30:16,019
method gets called for you once it

00:30:14,429 --> 00:30:18,419
doesn't have to be but you did it this

00:30:16,019 --> 00:30:20,279
way because this is convenient at most

00:30:18,419 --> 00:30:22,980
reactors will communicate at least with

00:30:20,279 --> 00:30:24,809
somebody so it's so that so that you

00:30:22,980 --> 00:30:28,070
don't have to write this open in every

00:30:24,809 --> 00:30:31,860
reactor you get one for free and

00:30:28,070 --> 00:30:34,529
basically there is a predefined main

00:30:31,860 --> 00:30:35,970
kind of channel for every reactor which

00:30:34,529 --> 00:30:38,490
has the following type the type that you

00:30:35,970 --> 00:30:41,789
wrote here basically and to access its

00:30:38,490 --> 00:30:43,860
event stream you just call events and

00:30:41,789 --> 00:30:45,509
this is this default event stream it

00:30:43,860 --> 00:30:48,000
comes for events that come through this

00:30:45,509 --> 00:30:52,769
channel and now we want to forward all

00:30:48,000 --> 00:30:54,929
these events to the cash protocol and we

00:30:52,769 --> 00:30:56,879
just instantiate the cash protocol with

00:30:54,929 --> 00:30:59,730
a real name server and the value that's

00:30:56,879 --> 00:31:01,409
supposed to be cashing and this time we

00:30:59,730 --> 00:31:03,809
just read it from left to right so it

00:31:01,409 --> 00:31:05,879
says all the incoming events should be

00:31:03,809 --> 00:31:08,659
forwarded to the cash protocol which

00:31:05,879 --> 00:31:12,000
cashes the entropy from this name server

00:31:08,659 --> 00:31:15,740
and I argue this is this is concise

00:31:12,000 --> 00:31:18,299
according to the previous definition and

00:31:15,740 --> 00:31:20,879
this this is good because it shows us

00:31:18,299 --> 00:31:22,470
that there is some potential in this in

00:31:20,879 --> 00:31:25,289
this new model in the sense that

00:31:22,470 --> 00:31:28,230
programs do compose better than what we

00:31:25,289 --> 00:31:30,000
could do before but you know to really

00:31:28,230 --> 00:31:34,230
prove that you should take alyssa brief

00:31:30,000 --> 00:31:35,820
look at more complex protocols so let's

00:31:34,230 --> 00:31:37,500
take a look let's quickly take a look at

00:31:35,820 --> 00:31:38,879
one example of a more complex protocol

00:31:37,500 --> 00:31:41,129
let's say that we're implementing a

00:31:38,879 --> 00:31:44,009
google doc application so in a google

00:31:41,129 --> 00:31:48,230
developer application you have some kind

00:31:44,009 --> 00:31:50,519
of a document and this document has

00:31:48,230 --> 00:31:53,659
certain contents in this case better

00:31:50,519 --> 00:31:56,970
scholar so two lines and now multiple

00:31:53,659 --> 00:31:58,289
sites multiple machines they share their

00:31:56,970 --> 00:31:59,970
supposed to share the same google

00:31:58,289 --> 00:32:01,649
document the same contents and what's

00:31:59,970 --> 00:32:04,379
important is that the same contents

00:32:01,649 --> 00:32:08,060
should at least eventually be replicated

00:32:04,379 --> 00:32:10,730
on the add all the sides so if

00:32:08,060 --> 00:32:13,580
this user behind the machine a makes a

00:32:10,730 --> 00:32:16,460
change to the document then you should

00:32:13,580 --> 00:32:18,320
first update his local version for

00:32:16,460 --> 00:32:20,600
example by writing Java better Scala and

00:32:18,320 --> 00:32:22,430
then he should tell the other

00:32:20,600 --> 00:32:26,210
participants all of the other

00:32:22,430 --> 00:32:28,970
participants that he inserted a new word

00:32:26,210 --> 00:32:33,260
at location 0 which is Java and that

00:32:28,970 --> 00:32:35,840
they can update their own cops and this

00:32:33,260 --> 00:32:38,090
protocol in which you're sending the

00:32:35,840 --> 00:32:40,340
same value not to one target location

00:32:38,090 --> 00:32:42,470
but the multiple target location is

00:32:40,340 --> 00:32:44,240
called the broadcast and there are many

00:32:42,470 --> 00:32:47,060
kinds of broadcast so let's take a look

00:32:44,240 --> 00:32:49,280
at a very simple one how do we implement

00:32:47,060 --> 00:32:52,570
the broadcast protocol where basically

00:32:49,280 --> 00:32:56,720
the broadcast protocol is again a method

00:32:52,570 --> 00:33:00,070
which creates it's supposed to give you

00:32:56,720 --> 00:33:03,590
back an event stream and a channel pair

00:33:00,070 --> 00:33:05,600
which has the property that if you send

00:33:03,590 --> 00:33:09,260
a certain event of type T to this

00:33:05,600 --> 00:33:11,210
channel then all the participants in

00:33:09,260 --> 00:33:14,420
this protocol all the remote sites

00:33:11,210 --> 00:33:17,500
should receive this event including

00:33:14,420 --> 00:33:19,970
yourself which will see at this event

00:33:17,500 --> 00:33:21,290
event stream that it gives back so you

00:33:19,970 --> 00:33:24,770
can see that this broadcast actually

00:33:21,290 --> 00:33:26,240
looks very similar to open but it takes

00:33:24,770 --> 00:33:29,240
some arguments in addition and it has

00:33:26,240 --> 00:33:31,100
different semantics and what we actually

00:33:29,240 --> 00:33:33,350
want to give back is basically this

00:33:31,100 --> 00:33:35,120
layer in the application which is the

00:33:33,350 --> 00:33:38,540
following guarantees if you send

00:33:35,120 --> 00:33:40,700
something on this engine channel it

00:33:38,540 --> 00:33:43,610
should eventually end up at every remote

00:33:40,700 --> 00:33:46,160
side and if you get something from any

00:33:43,610 --> 00:33:47,900
of these remote participants then you

00:33:46,160 --> 00:33:50,360
should get that event on this event

00:33:47,900 --> 00:33:52,940
stream as well as everybody else and

00:33:50,360 --> 00:33:55,490
that means that you will be able to call

00:33:52,940 --> 00:33:58,390
on event on this event stream and then

00:33:55,490 --> 00:34:00,710
in use these contents that you send to

00:33:58,390 --> 00:34:02,540
modify your local state which is the

00:34:00,710 --> 00:34:05,360
document inserting the string at a

00:34:02,540 --> 00:34:08,330
particular location so how do we

00:34:05,360 --> 00:34:14,000
implement this well first we need to

00:34:08,330 --> 00:34:15,800
notice that this method takes a set of

00:34:14,000 --> 00:34:19,550
all the channels which are participating

00:34:15,800 --> 00:34:21,890
in this protocol that means this targets

00:34:19,550 --> 00:34:25,370
includes all the other reactors

00:34:21,890 --> 00:34:27,170
including ourselves so for convenience

00:34:25,370 --> 00:34:29,570
let's let's assume that we have this

00:34:27,170 --> 00:34:32,150
method called fine self in events to

00:34:29,570 --> 00:34:33,890
make things simple for now which takes

00:34:32,150 --> 00:34:36,050
these targets and returns that event

00:34:33,890 --> 00:34:38,720
stream among the corresponding two

00:34:36,050 --> 00:34:42,860
channels in this in this set which which

00:34:38,720 --> 00:34:45,650
is our our event stream okay and then we

00:34:42,860 --> 00:34:47,690
say we need to open a new pair of a send

00:34:45,650 --> 00:34:52,960
channel and an event stream will call

00:34:47,690 --> 00:34:56,480
them st. Jean and sense and then we say

00:34:52,960 --> 00:34:58,340
whenever somebody uses the ascension to

00:34:56,480 --> 00:35:00,320
send it a message we know that this

00:34:58,340 --> 00:35:01,520
message will end up in sense because

00:35:00,320 --> 00:35:03,440
there's the semantics of this event

00:35:01,520 --> 00:35:06,950
streams and channels but then we can add

00:35:03,440 --> 00:35:09,440
an additional own event on this event

00:35:06,950 --> 00:35:12,410
stream here saying that you should eat

00:35:09,440 --> 00:35:14,480
rate through all the targets and send

00:35:12,410 --> 00:35:17,330
the value X to all these channels and

00:35:14,480 --> 00:35:19,100
get delivered to all of them and that's

00:35:17,330 --> 00:35:20,720
it at this point we can return the

00:35:19,100 --> 00:35:23,930
things which are on this left boundary

00:35:20,720 --> 00:35:25,730
of this of this protocol which is events

00:35:23,930 --> 00:35:28,520
intention and we're done and we

00:35:25,730 --> 00:35:30,680
implemented broadcast and what you can

00:35:28,520 --> 00:35:32,360
notice here is there to there are two

00:35:30,680 --> 00:35:35,150
layers of abstraction there is one on

00:35:32,360 --> 00:35:37,340
the left which is the high level view of

00:35:35,150 --> 00:35:39,650
this of this protocol and this is the

00:35:37,340 --> 00:35:41,540
implementation layer behind it and this

00:35:39,650 --> 00:35:43,970
is not visible to the user the user just

00:35:41,540 --> 00:35:48,800
thinks this is a normal channel because

00:35:43,970 --> 00:35:50,990
this is what your return and generally

00:35:48,800 --> 00:35:53,120
this is a very simple form of a

00:35:50,990 --> 00:35:55,040
broadcast and generally broadcast don't

00:35:53,120 --> 00:35:56,710
offer too much ordering so for example

00:35:55,040 --> 00:36:01,160
you could have a situation like this

00:35:56,710 --> 00:36:02,990
this Java 0 Java message gets delivered

00:36:01,160 --> 00:36:06,080
to see before it gets delivered to be

00:36:02,990 --> 00:36:07,820
and then cici's Java better Scala and

00:36:06,080 --> 00:36:09,350
the things that this you know the

00:36:07,820 --> 00:36:11,180
contents of this document a little bit a

00:36:09,350 --> 00:36:13,610
little bit too provocative so what he

00:36:11,180 --> 00:36:16,610
might do is then say okay I'll insert

00:36:13,610 --> 00:36:19,160
kind of a question at the beginning say

00:36:16,610 --> 00:36:21,620
say is in Java better Scala that doesn't

00:36:19,160 --> 00:36:24,050
sound so provocative anymore and at this

00:36:21,620 --> 00:36:26,570
point he has to do a broadcast so he

00:36:24,050 --> 00:36:31,910
does broadcast back to a and a broadcast

00:36:26,570 --> 00:36:35,120
to be and now this 0 isn't arrives to be

00:36:31,910 --> 00:36:38,750
even before this message 0 Java arrived

00:36:35,120 --> 00:36:40,550
be so basically what B C's is just isn't

00:36:38,750 --> 00:36:42,050
better scholar it doesn't understand

00:36:40,550 --> 00:36:44,720
what is this means but if he waits a

00:36:42,050 --> 00:36:47,570
little bit you'll get basically contents

00:36:44,720 --> 00:36:49,430
Java isn't better scholar and now if you

00:36:47,570 --> 00:36:51,680
compare these two documents that I got

00:36:49,430 --> 00:36:53,990
basically give very very different

00:36:51,680 --> 00:36:55,250
contents here the one says Java isn't

00:36:53,990 --> 00:36:57,440
better scholar which sounds provocative

00:36:55,250 --> 00:37:01,190
and this one is milder on the right and

00:36:57,440 --> 00:37:02,870
by this B might mean that C is some kind

00:37:01,190 --> 00:37:05,570
of a troll for writing something like

00:37:02,870 --> 00:37:07,820
this trying to start a flame war it and

00:37:05,570 --> 00:37:10,430
the point in this in this simple example

00:37:07,820 --> 00:37:13,400
is that operations for this kind of

00:37:10,430 --> 00:37:17,120
application must be commutative that's

00:37:13,400 --> 00:37:19,400
one solution another one is that

00:37:17,120 --> 00:37:20,870
messages that arrive at all the end

00:37:19,400 --> 00:37:22,520
points at the same time in the same

00:37:20,870 --> 00:37:25,640
order not at the same time in the same

00:37:22,520 --> 00:37:27,170
order right and you can think of these

00:37:25,640 --> 00:37:28,940
things there's more complex protocols

00:37:27,170 --> 00:37:30,950
because what we just implemented in the

00:37:28,940 --> 00:37:32,840
previous slide is it something called

00:37:30,950 --> 00:37:35,180
the best effort broadcast it just says

00:37:32,840 --> 00:37:37,250
things will arrive at the target and

00:37:35,180 --> 00:37:40,760
they will arrive in any order at

00:37:37,250 --> 00:37:42,440
different sides on the other hand you

00:37:40,760 --> 00:37:44,810
have a more complex protocol which is

00:37:42,440 --> 00:37:46,400
actually much more complicated to

00:37:44,810 --> 00:37:48,080
implement and harder to implement in the

00:37:46,400 --> 00:37:50,330
previous one which is called total order

00:37:48,080 --> 00:37:53,150
which guarantees that messages will be

00:37:50,330 --> 00:37:55,670
will be delivered in the same order at

00:37:53,150 --> 00:37:58,130
all the sides another way to solve this

00:37:55,670 --> 00:37:59,990
problem is the other third protocol

00:37:58,130 --> 00:38:03,080
called the commutative replicated data

00:37:59,990 --> 00:38:05,870
type which says give I'll give you some

00:38:03,080 --> 00:38:08,210
kind of a state replica at each side for

00:38:05,870 --> 00:38:10,850
which if you update it it doesn't matter

00:38:08,210 --> 00:38:14,210
in which in which order the updates

00:38:10,850 --> 00:38:16,460
arrive but what what L guarantee you if

00:38:14,210 --> 00:38:19,040
they all arrive you will see the exactly

00:38:16,460 --> 00:38:21,530
same state of each replica and these are

00:38:19,040 --> 00:38:24,290
different protocols and what's important

00:38:21,530 --> 00:38:26,930
to say is that these protocols are all

00:38:24,290 --> 00:38:28,460
implemented in yet a simple protocol the

00:38:26,930 --> 00:38:31,040
best effort broadcast which we saw

00:38:28,460 --> 00:38:33,350
previously and they don't have time to

00:38:31,040 --> 00:38:35,480
go through them but the analogy I want

00:38:33,350 --> 00:38:37,160
to leave you with is that this

00:38:35,480 --> 00:38:43,010
programming model is basically like this

00:38:37,160 --> 00:38:45,770
onion because in the middle it has some

00:38:43,010 --> 00:38:47,770
kind of state and that around the state

00:38:45,770 --> 00:38:49,500
you basically have layers of abstraction

00:38:47,770 --> 00:38:51,990
such that each layer

00:38:49,500 --> 00:38:55,170
is well defined as well understandable

00:38:51,990 --> 00:38:56,970
and composable and at some point when

00:38:55,170 --> 00:38:59,160
you when you stop stacking these layers

00:38:56,970 --> 00:39:01,530
you can say I'm done now and I have my

00:38:59,160 --> 00:39:03,540
reactor and then I can build my

00:39:01,530 --> 00:39:05,910
distributed system with several such

00:39:03,540 --> 00:39:08,070
reactors in which this protocols

00:39:05,910 --> 00:39:09,510
different layers are implemented

00:39:08,070 --> 00:39:11,460
potentially by different people and

00:39:09,510 --> 00:39:13,550
tested by different people and then

00:39:11,460 --> 00:39:16,230
composed by eight different people again

00:39:13,550 --> 00:39:20,130
where is the plastic actor model is more

00:39:16,230 --> 00:39:23,370
like this garlic in it there are no

00:39:20,130 --> 00:39:25,170
layers there just one monolithic little

00:39:23,370 --> 00:39:27,690
component and then if you want to

00:39:25,170 --> 00:39:30,480
compose systems you have to group

00:39:27,690 --> 00:39:33,300
multiple such monolithic components

00:39:30,480 --> 00:39:35,370
together in a somewhat artificial way by

00:39:33,300 --> 00:39:37,890
creating this envelope around them but

00:39:35,370 --> 00:39:39,600
if you try to break them apart this is

00:39:37,890 --> 00:39:43,230
this is what you end up with you can go

00:39:39,600 --> 00:39:46,200
further than this and yet that's that's

00:39:43,230 --> 00:39:48,180
basically the analogy that is the most

00:39:46,200 --> 00:39:51,710
important to remember from this docker I

00:39:48,180 --> 00:39:55,350
would say so thanks for listening

00:39:51,710 --> 00:39:57,120
basically you can find a prototype

00:39:55,350 --> 00:40:00,060
implementation of this programming model

00:39:57,120 --> 00:40:02,370
on github add at this address so i

00:40:00,060 --> 00:40:05,640
welcome you to star as readers like us

00:40:02,370 --> 00:40:08,820
share us and so on and give us feedback

00:40:05,640 --> 00:40:10,290
of course and contributions hopefully

00:40:08,820 --> 00:40:12,480
and i want to thank you for listening

00:40:10,290 --> 00:40:14,810
and if you have any questions I'd be

00:40:12,480 --> 00:40:14,810
happy to

00:40:27,339 --> 00:40:32,359
thank you for that I was just wondering

00:40:30,560 --> 00:40:34,790
if effort if I would take your

00:40:32,359 --> 00:40:37,609
presentation slides and replace

00:40:34,790 --> 00:40:44,030
everywhere you said channel with actor

00:40:37,609 --> 00:40:47,960
ref then how much would differ so the

00:40:44,030 --> 00:40:49,430
fundamental difference is that if you

00:40:47,960 --> 00:40:50,990
replace this fact with actor reference

00:40:49,430 --> 00:40:53,690
and that's a very good analogy channel

00:40:50,990 --> 00:40:56,690
basically is an actor reference in the

00:40:53,690 --> 00:41:01,099
sense that every you could say that

00:40:56,690 --> 00:41:02,780
every actor has a single channel or

00:41:01,099 --> 00:41:06,490
it'll always has a single channel it

00:41:02,780 --> 00:41:09,380
doesn't have multiple and Jack Thurston

00:41:06,490 --> 00:41:11,599
which are not ha yeah yeah so if i would

00:41:09,380 --> 00:41:13,070
use actors i could do the same thing if

00:41:11,599 --> 00:41:15,800
i would encode the actor I've seen my

00:41:13,070 --> 00:41:18,680
messages this is the thing so you could

00:41:15,800 --> 00:41:20,570
only go that far because you wouldn't be

00:41:18,680 --> 00:41:23,510
able to encode different protocols

00:41:20,570 --> 00:41:25,130
within the same actor because at some

00:41:23,510 --> 00:41:27,800
point you would have to install

00:41:25,130 --> 00:41:30,020
callbacks to the same channel to the

00:41:27,800 --> 00:41:32,150
event stream of the same channel and at

00:41:30,020 --> 00:41:34,040
that point you these different protocols

00:41:32,150 --> 00:41:36,890
they wouldn't know how to handle each

00:41:34,040 --> 00:41:38,960
other's messages our events basically

00:41:36,890 --> 00:41:42,770
they would need to be aware of each

00:41:38,960 --> 00:41:45,530
other not to use the messages and events

00:41:42,770 --> 00:41:47,300
which are potentially clashing in this

00:41:45,530 --> 00:41:50,050
namespace and when you have multiple

00:41:47,300 --> 00:41:52,339
events dreams there is multiple channels

00:41:50,050 --> 00:41:54,500
then you can use the same type of a

00:41:52,339 --> 00:41:58,640
message at two different events dreams

00:41:54,500 --> 00:42:00,980
and they can never clash together so

00:41:58,640 --> 00:42:03,530
basically when I set composability at

00:42:00,980 --> 00:42:06,020
the beginning i say i meant they really

00:42:03,530 --> 00:42:07,339
they should be this bigger program

00:42:06,020 --> 00:42:10,250
should be composed from smaller

00:42:07,339 --> 00:42:12,710
independent programs but if these two

00:42:10,250 --> 00:42:15,349
components need to be aware of each

00:42:12,710 --> 00:42:17,599
other not to reuse each other's message

00:42:15,349 --> 00:42:19,760
types then they're not independent

00:42:17,599 --> 00:42:22,730
anymore they have to be aware of each

00:42:19,760 --> 00:42:25,690
other and that hinders i argue that that

00:42:22,730 --> 00:42:25,690
hinders reusability

00:42:36,740 --> 00:42:44,230
hi how does this relate with CSP and

00:42:41,660 --> 00:42:49,250
Nicole concurrency model is it the same

00:42:44,230 --> 00:42:51,860
implemented in Scala or so if I know the

00:42:49,250 --> 00:42:53,450
CSP remember the CSP concurrency model

00:42:51,860 --> 00:42:58,760
better one big difference is that these

00:42:53,450 --> 00:43:03,520
channels are not typed right and the

00:42:58,760 --> 00:43:05,869
other is that basically in the so in the

00:43:03,520 --> 00:43:08,510
that's a good question there is one

00:43:05,869 --> 00:43:10,430
difference and that is that in the goal

00:43:08,510 --> 00:43:12,680
congruence model which is similar to CSP

00:43:10,430 --> 00:43:14,750
you basically for each of these channels

00:43:12,680 --> 00:43:18,650
in the execution flow of the program

00:43:14,750 --> 00:43:22,130
have to say ok stop now and listen to

00:43:18,650 --> 00:43:23,480
this particular channel just one that

00:43:22,130 --> 00:43:25,430
means that if there are potentially

00:43:23,480 --> 00:43:27,500
different channels and different

00:43:25,430 --> 00:43:29,830
computing the executing programs within

00:43:27,500 --> 00:43:33,530
that thread or within that fiber

00:43:29,830 --> 00:43:35,420
goroutine other call domingo then they

00:43:33,530 --> 00:43:37,220
will not get a chance to execute because

00:43:35,420 --> 00:43:41,119
you're only waiting in a particular one

00:43:37,220 --> 00:43:44,990
so if you're a cache and you're waiting

00:43:41,119 --> 00:43:46,940
for a response from the server then it

00:43:44,990 --> 00:43:49,070
means that the clients cannot cannot

00:43:46,940 --> 00:43:50,660
come they can send messages to the cash

00:43:49,070 --> 00:43:52,310
but the cache won't be replying to them

00:43:50,660 --> 00:43:54,890
because it's not extracting the client

00:43:52,310 --> 00:43:58,670
messages and it means again that these

00:43:54,890 --> 00:44:00,290
two protocols running within the cache

00:43:58,670 --> 00:44:02,510
need to be aware of each other they have

00:44:00,290 --> 00:44:04,970
to somehow supplemented chatter and give

00:44:02,510 --> 00:44:06,080
each other a chance to execute and it

00:44:04,970 --> 00:44:09,380
means that they're not they're not

00:44:06,080 --> 00:44:11,869
really independent it and what what's

00:44:09,380 --> 00:44:14,210
the equivalent for selectors when you

00:44:11,869 --> 00:44:17,150
the selectors you you want to wait until

00:44:14,210 --> 00:44:19,550
any of these kind of events it triggers

00:44:17,150 --> 00:44:21,859
exactly it's like this figure that I

00:44:19,550 --> 00:44:24,710
shot basically there are multiple entry

00:44:21,859 --> 00:44:27,560
points and when an event arrives at some

00:44:24,710 --> 00:44:30,619
of the entry points it triggers but in a

00:44:27,560 --> 00:44:32,270
way such that two such processing of the

00:44:30,619 --> 00:44:34,910
events to such entry points are

00:44:32,270 --> 00:44:36,320
serialized with each other because

00:44:34,910 --> 00:44:38,150
otherwise you don't have a guarantee

00:44:36,320 --> 00:44:41,090
that you're not me rating the same state

00:44:38,150 --> 00:44:43,250
at the same time so they can they can

00:44:41,090 --> 00:44:46,160
execute whenever they're like a mind of

00:44:43,250 --> 00:44:49,750
micro threads within the reactor but

00:44:46,160 --> 00:44:49,750
they happen one after the other

00:44:51,490 --> 00:44:56,210
thanks Alex for the bundle wonderful

00:44:54,890 --> 00:45:00,109
presentation I think it's right

00:44:56,210 --> 00:45:02,750
brilliant thank you um one thought with

00:45:00,109 --> 00:45:05,420
this cash the first who asks we'll get

00:45:02,750 --> 00:45:08,329
back and null because you didn't make it

00:45:05,420 --> 00:45:10,339
wait until you get the first result from

00:45:08,329 --> 00:45:12,200
the server back so how would you do the

00:45:10,339 --> 00:45:15,920
synchronization of multiple protocols

00:45:12,200 --> 00:45:18,380
within one reactor ok so basically I

00:45:15,920 --> 00:45:20,930
would modify this a little bit so

00:45:18,380 --> 00:45:22,940
basically the thing is you say kind of

00:45:20,930 --> 00:45:24,799
implying that actor model has

00:45:22,940 --> 00:45:26,750
disadvantage where you can when you

00:45:24,799 --> 00:45:28,490
change from one received to another type

00:45:26,750 --> 00:45:31,069
of receive your kind of encoding the

00:45:28,490 --> 00:45:33,349
states of your actor like you your first

00:45:31,069 --> 00:45:35,029
yeah ideally in this use case that you

00:45:33,349 --> 00:45:38,359
describe you first want to wait from the

00:45:35,029 --> 00:45:41,630
reply from the server and when you are

00:45:38,359 --> 00:45:45,799
sure that the cash is populated then you

00:45:41,630 --> 00:45:48,740
can reply to the client right well yes

00:45:45,799 --> 00:45:50,569
you have to code this stashing or

00:45:48,740 --> 00:45:52,519
whatever you have to have put the bound

00:45:50,569 --> 00:45:54,440
on the number of requests you keep and

00:45:52,519 --> 00:45:56,960
so right you would have to implement it

00:45:54,440 --> 00:45:58,789
in either way in either model so how how

00:45:56,960 --> 00:46:00,470
does it work ok but that's a problem of

00:45:58,789 --> 00:46:03,289
race conditions basically you want to

00:46:00,470 --> 00:46:07,490
avoid you have two choices either you

00:46:03,289 --> 00:46:09,529
delay the answer to your clients or you

00:46:07,490 --> 00:46:11,299
give your clients basically response you

00:46:09,529 --> 00:46:12,980
should we try later immediately so you

00:46:11,299 --> 00:46:14,269
have these two choices and I think you

00:46:12,980 --> 00:46:16,730
have to make this two choices in either

00:46:14,269 --> 00:46:19,519
model right so what you will do here is

00:46:16,730 --> 00:46:22,700
you would first make a request to the

00:46:19,519 --> 00:46:24,829
server and then the server basically

00:46:22,700 --> 00:46:26,299
this ? would give you back an event

00:46:24,829 --> 00:46:28,819
stream to which you install your own

00:46:26,299 --> 00:46:31,279
event and then instead of independently

00:46:28,819 --> 00:46:33,230
instant sharing a server at the end of

00:46:31,279 --> 00:46:35,690
your cash you would just put it inside

00:46:33,230 --> 00:46:39,230
this on event call back so if I just

00:46:35,690 --> 00:46:43,759
quickly go back to this slide basically

00:46:39,230 --> 00:46:46,839
what you do is the following so instead

00:46:43,759 --> 00:46:50,390
of putting this server here at the end

00:46:46,839 --> 00:46:53,240
would basically put it inside here so

00:46:50,390 --> 00:46:56,059
after you care say cash equals y then

00:46:53,240 --> 00:46:57,980
you start the server protocol or replace

00:46:56,059 --> 00:47:02,740
it an existing one which gives basically

00:46:57,980 --> 00:47:02,740
a retry later message put to the clients

00:47:09,580 --> 00:47:13,000
any further questions

00:47:15,130 --> 00:47:20,310
okay so thanks a lot for listening and

00:47:17,140 --> 00:47:20,310

YouTube URL: https://www.youtube.com/watch?v=7lulYWWD4Qo


