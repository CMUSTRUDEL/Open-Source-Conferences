Title: Raymond Hettinger - Dataclasses:  The code generator to end all code generators - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Raymond Hettinger

The PEP 557 dataclasses module is available in starting in Python 3.7.   It will become an essential part of every Python programmer's toolkit.  This talk shows what problem the module solves, explains its key design decisions, and provides practical examples of how to put it to work.

Dataclasses are shown to be the next step in a progression of data aggregation tools: tuple, dict, simple class, bunch recipe, named tuples, records, attrs, and then dataclasses. Each builds upon the one that came before, adding expressiveness at the expense of complexity.

Dataclasses are unique in that they let you selectively turn-on or turn-off its various capabilities and it lets the user choose the underlying data store (either instance dictionary, instance slots, or an inherited base class).

Dataclasses and typing.NamedTuple both use variable annotations which were new in Python 3.6.









Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:00,060 --> 00:00:06,270
all right everyone let's try and pack in

00:00:03,899 --> 00:00:08,250
defrag yourselves if you can save some

00:00:06,270 --> 00:00:11,429
room on the end possible it's gonna be

00:00:08,250 --> 00:00:13,830
standing room only so all right let's

00:00:11,429 --> 00:00:14,730
get started with the talk I'd like to

00:00:13,830 --> 00:00:16,350
introduce to you

00:00:14,730 --> 00:00:16,850
Raven heading J let's give a round

00:00:16,350 --> 00:00:27,280
applause

00:00:16,850 --> 00:00:27,280
[Applause]

00:00:27,770 --> 00:00:32,790
sphynx for slides it's awesome

00:00:30,660 --> 00:00:35,850
it's the fastest easiest way to make

00:00:32,790 --> 00:00:38,660
slides so hello my name is Eric Smith

00:00:35,850 --> 00:00:38,660
it's nice to meet you

00:00:38,780 --> 00:00:42,510
usually when I stand up and talk I talk

00:00:41,070 --> 00:00:44,129
about something I wrote but now I'm

00:00:42,510 --> 00:00:46,170
talking about something that other

00:00:44,129 --> 00:00:48,629
people are wrote and did a fantastic job

00:00:46,170 --> 00:00:52,670
at and I get to be the vehicle who

00:00:48,629 --> 00:00:56,280
hopefully does justice to their creation

00:00:52,670 --> 00:00:59,010
I've prepared the talk as a what is this

00:00:56,280 --> 00:01:00,720
all about something for us to think

00:00:59,010 --> 00:01:02,159
about together what does this mean for

00:01:00,720 --> 00:01:04,440
us what does it do so I'd like this to

00:01:02,159 --> 00:01:06,750
be a thinking exercise for us as we look

00:01:04,440 --> 00:01:08,670
at it I'd like it to be a tutorial and

00:01:06,750 --> 00:01:13,320
I'd like my slides for you to be a

00:01:08,670 --> 00:01:16,290
recipe book of how to use it to great

00:01:13,320 --> 00:01:20,100
effect so without further ado let's see

00:01:16,290 --> 00:01:23,130
anything on this page interesting no no

00:01:20,100 --> 00:01:31,200
no no okay

00:01:23,130 --> 00:01:38,210
on to interesting things I'll start with

00:01:31,200 --> 00:01:38,210
the makefile

00:01:42,350 --> 00:01:46,220
introduction here we go

00:01:46,820 --> 00:01:52,860
rebuilding slides on stage alright so

00:01:51,030 --> 00:01:54,990
the title of the talk is the code

00:01:52,860 --> 00:01:56,880
generator to indulge code generators

00:01:54,990 --> 00:01:59,159
what does the code generator do for you

00:01:56,880 --> 00:02:02,670
you give it a list of specifications and

00:01:59,159 --> 00:02:04,890
it writes code for you is that good if

00:02:02,670 --> 00:02:06,840
your specifications are good and the

00:02:04,890 --> 00:02:09,179
code it generates is what you want then

00:02:06,840 --> 00:02:11,160
it's good if your specifications are bad

00:02:09,179 --> 00:02:13,739
probably not going to work out so well

00:02:11,160 --> 00:02:15,120
if the code generator does something

00:02:13,739 --> 00:02:18,060
different than what you expect it's

00:02:15,120 --> 00:02:19,739
going to do not so well so when you work

00:02:18,060 --> 00:02:21,600
with code generators your goal is to be

00:02:19,739 --> 00:02:24,330
in harmony with the code generator and

00:02:21,600 --> 00:02:27,180
think about its world view because it's

00:02:24,330 --> 00:02:29,730
going to write code on your behalf now

00:02:27,180 --> 00:02:31,560
in theory your unit testing everything

00:02:29,730 --> 00:02:34,230
you do but people tend to miss a fair

00:02:31,560 --> 00:02:37,560
number of cases that are covered well by

00:02:34,230 --> 00:02:40,380
the this tool so it helps to really

00:02:37,560 --> 00:02:42,360
become one with this tool one of the

00:02:40,380 --> 00:02:44,250
things I'd like to about name tuples is

00:02:42,360 --> 00:02:47,120
they have a near zero learning curve on

00:02:44,250 --> 00:02:49,860
the other hand they had very limited

00:02:47,120 --> 00:02:52,470
capabilities so this is exactly the

00:02:49,860 --> 00:02:55,320
opposite situation the data classes

00:02:52,470 --> 00:02:57,450
module is the amount of code is several

00:02:55,320 --> 00:02:59,459
times larger than that for named tuples

00:02:57,450 --> 00:03:01,530
but it provides a much richer set of

00:02:59,459 --> 00:03:03,930
functionality which means it's kind of

00:03:01,530 --> 00:03:05,459
an entire ecosystem of tools that are

00:03:03,930 --> 00:03:07,350
work together and tools and

00:03:05,459 --> 00:03:09,150
possibilities one of the things that I

00:03:07,350 --> 00:03:11,370
really like where some excellent design

00:03:09,150 --> 00:03:13,170
choices were made so that right out of

00:03:11,370 --> 00:03:16,470
the box if you use it in the simplest

00:03:13,170 --> 00:03:18,959
possible way it mostly does for you what

00:03:16,470 --> 00:03:20,610
you wanted to do most of the time but

00:03:18,959 --> 00:03:24,000
then it grows with you as you start to

00:03:20,610 --> 00:03:26,549
have more exotic needs so why do we want

00:03:24,000 --> 00:03:28,079
a code generator because it could save

00:03:26,549 --> 00:03:31,859
you time the time you would have spent

00:03:28,079 --> 00:03:34,109
writing that code it's paid back right

00:03:31,859 --> 00:03:37,170
away also code generators reduce

00:03:34,109 --> 00:03:39,390
wordiness a lot of Python classes when

00:03:37,170 --> 00:03:40,799
people first learn Python they feel like

00:03:39,390 --> 00:03:42,540
there's a lot of boilerplate in their

00:03:40,799 --> 00:03:44,609
writing the wrapper right in the dunder

00:03:42,540 --> 00:03:49,199
init writing it under eq'd writing it

00:03:44,609 --> 00:03:51,989
under hash etc and that feeling of

00:03:49,199 --> 00:03:52,950
boilerplate never really goes away you

00:03:51,989 --> 00:03:55,319
get used to not

00:03:52,950 --> 00:03:57,720
that code quickly but you feel like that

00:03:55,319 --> 00:03:59,700
code isn't contributing the expression

00:03:57,720 --> 00:04:01,709
of your business logic the idea of this

00:03:59,700 --> 00:04:04,260
code generator is to get you past that

00:04:01,709 --> 00:04:06,870
step next question is what are data

00:04:04,260 --> 00:04:10,530
classes for it depends on who you ask

00:04:06,870 --> 00:04:11,400
there are two worldviews and of those

00:04:10,530 --> 00:04:13,470
two worldviews

00:04:11,400 --> 00:04:15,720
the people who see it one way don't send

00:04:13,470 --> 00:04:18,630
it tendecy at another there are those of

00:04:15,720 --> 00:04:21,389
us those people who want who think data

00:04:18,630 --> 00:04:23,940
classes are primarily about data which

00:04:21,389 --> 00:04:25,950
means I need a holder for data I need an

00:04:23,940 --> 00:04:29,100
aggregate data structure something like

00:04:25,950 --> 00:04:31,350
a struct in another language if that is

00:04:29,100 --> 00:04:33,300
your world view data classes support

00:04:31,350 --> 00:04:35,310
that world view they are data holders

00:04:33,300 --> 00:04:36,810
but there's another world view that says

00:04:35,310 --> 00:04:38,880
I spend a lot of time writing classes

00:04:36,810 --> 00:04:41,280
putting interesting functionality in it

00:04:38,880 --> 00:04:42,960
and I'd like the boilerplate to go away

00:04:41,280 --> 00:04:45,479
so I could focus on the business logic

00:04:42,960 --> 00:04:47,190
if you think of it as a tool to help you

00:04:45,479 --> 00:04:49,380
write classes and you're going to write

00:04:47,190 --> 00:04:51,630
lots of methods anyway it just takes out

00:04:49,380 --> 00:04:54,540
the boilerplate for you data classes are

00:04:51,630 --> 00:04:56,280
for you as well so the word data in data

00:04:54,540 --> 00:04:58,260
classes has to do with it being a data

00:04:56,280 --> 00:05:00,720
holder and the classes part has to do

00:04:58,260 --> 00:05:02,610
with it is a class generator it is both

00:05:00,720 --> 00:05:05,100
things and it means different things to

00:05:02,610 --> 00:05:07,200
different people at different times so

00:05:05,100 --> 00:05:10,229
I'd like this to be a thing joint

00:05:07,200 --> 00:05:12,090
thinking I exercise together for us to

00:05:10,229 --> 00:05:14,880
explore this and instead of me just

00:05:12,090 --> 00:05:17,220
putting up one way I give you

00:05:14,880 --> 00:05:19,380
information I would like you to assess

00:05:17,220 --> 00:05:22,260
each piece as it comes to you here's

00:05:19,380 --> 00:05:23,669
what to think about one of the things

00:05:22,260 --> 00:05:26,280
you want to learn is how to use the code

00:05:23,669 --> 00:05:27,690
generator also when you use a code

00:05:26,280 --> 00:05:30,539
generator the most critical thing to

00:05:27,690 --> 00:05:31,770
know is what code it writes for you one

00:05:30,539 --> 00:05:34,590
of the things that I had really liked

00:05:31,770 --> 00:05:36,960
about name tuples one of it's what I

00:05:34,590 --> 00:05:38,849
thought was a best feature was a head of

00:05:36,960 --> 00:05:40,710
verbose option and when you used to name

00:05:38,849 --> 00:05:43,260
tupple it showed you the code that it

00:05:40,710 --> 00:05:45,599
wrote for you a benefit for that is no

00:05:43,260 --> 00:05:46,740
one ever had a question what code was

00:05:45,599 --> 00:05:49,830
written for me ever

00:05:46,740 --> 00:05:51,900
Wow on the other hand no one has ever

00:05:49,830 --> 00:05:57,900
said anything nice to me about that

00:05:51,900 --> 00:06:01,349
feature ever so Eric didn't copy that

00:05:57,900 --> 00:06:03,720
into data classes and I took it out in

00:06:01,349 --> 00:06:05,130
Python 3 7 so you no longer get to see

00:06:03,720 --> 00:06:06,220
the code that's generated unless you

00:06:05,130 --> 00:06:10,180
come to this talk

00:06:06,220 --> 00:06:11,560
okay so ah if you don't say that you

00:06:10,180 --> 00:06:15,040
like something it might disappear

00:06:11,560 --> 00:06:16,660
someday all right so what code does it

00:06:15,040 --> 00:06:18,490
write for you and the next question

00:06:16,660 --> 00:06:20,290
you've been more important what you know

00:06:18,490 --> 00:06:24,370
what code eraser is that what you really

00:06:20,290 --> 00:06:26,980
wanted sometimes yes sometimes no this

00:06:24,370 --> 00:06:29,920
is a somewhat opinionated data structure

00:06:26,980 --> 00:06:31,780
and it has some opinions that I really

00:06:29,920 --> 00:06:35,170
like but they may not reflect your

00:06:31,780 --> 00:06:36,760
worldview at all and then any tool you

00:06:35,170 --> 00:06:38,770
essentially have to ask the question is

00:06:36,760 --> 00:06:40,720
the time spent invested learning the

00:06:38,770 --> 00:06:43,540
tool teaching other people to use it and

00:06:40,720 --> 00:06:46,360
to read it is that worth the time that

00:06:43,540 --> 00:06:48,520
it saved you some tools have a broad net

00:06:46,360 --> 00:06:52,150
increase in complexity some have add a

00:06:48,520 --> 00:06:55,030
net decrease in complexity and like a

00:06:52,150 --> 00:06:57,910
rainbow each person sees their own

00:06:55,030 --> 00:07:00,100
rainbow and whether this tool is

00:06:57,910 --> 00:07:03,040
beneficial for you or not very much

00:07:00,100 --> 00:07:05,740
depends on your point of view one

00:07:03,040 --> 00:07:08,380
challenge for me is I train lots of

00:07:05,740 --> 00:07:12,220
people enormous numbers of people to use

00:07:08,380 --> 00:07:14,500
Python and these folks benefit a great

00:07:12,220 --> 00:07:16,419
deal by having the classes completely

00:07:14,500 --> 00:07:19,360
spelled out so that they can learn how

00:07:16,419 --> 00:07:21,910
Python operates the language teaches you

00:07:19,360 --> 00:07:23,530
what it does on the other hand when they

00:07:21,910 --> 00:07:26,650
need to do it on their own they often

00:07:23,530 --> 00:07:29,320
don't do it well and leave parts out so

00:07:26,650 --> 00:07:31,630
if I introduced data classes to them on

00:07:29,320 --> 00:07:33,280
the one hand the likelihood of them

00:07:31,630 --> 00:07:35,169
doing it correctly the first time is

00:07:33,280 --> 00:07:36,700
very high on the other hand the

00:07:35,169 --> 00:07:39,030
likelihood of them understanding what

00:07:36,700 --> 00:07:41,470
happens behind the scene goes down

00:07:39,030 --> 00:07:43,300
imagine a world where you have used

00:07:41,470 --> 00:07:45,430
Python classes and have never written a

00:07:43,300 --> 00:07:47,740
dunder init yourself never written a

00:07:45,430 --> 00:07:49,750
dunder hash and never written a dunder

00:07:47,740 --> 00:07:52,180
repper how would you even begin to

00:07:49,750 --> 00:07:54,310
comprehend this tool it is possible in

00:07:52,180 --> 00:07:55,480
an organization that if you adopt this

00:07:54,310 --> 00:07:58,090
tool wholesale

00:07:55,480 --> 00:08:00,760
all of the examples in the code won't

00:07:58,090 --> 00:08:02,830
have done during its dunder rippers

00:08:00,760 --> 00:08:05,290
dunder hash and so there's nothing to

00:08:02,830 --> 00:08:07,450
teach the users about what it does on

00:08:05,290 --> 00:08:09,730
the other hand education problems are

00:08:07,450 --> 00:08:12,370
problems that are easy to solve have a

00:08:09,730 --> 00:08:14,620
Tech Talk for lunch take a look at this

00:08:12,370 --> 00:08:16,210
tutorial and it'll show you the code so

00:08:14,620 --> 00:08:17,590
if the engineering problem is we don't

00:08:16,210 --> 00:08:19,810
know something the solution is just

00:08:17,590 --> 00:08:21,730
teaching you but

00:08:19,810 --> 00:08:25,750
I can't see in advance how it's going to

00:08:21,730 --> 00:08:28,210
work out in your world and also we have

00:08:25,750 --> 00:08:29,650
this realization that while it's nice to

00:08:28,210 --> 00:08:31,960
have a code generator saving its time

00:08:29,650 --> 00:08:34,029
writing code we spend more time reading

00:08:31,960 --> 00:08:36,130
and debugging code than we spend writing

00:08:34,029 --> 00:08:38,710
code so a question you want to ask

00:08:36,130 --> 00:08:41,650
yourself is this improve your debugging

00:08:38,710 --> 00:08:44,500
experience our does it make it worse

00:08:41,650 --> 00:08:46,779
on the one hand any tool that introduces

00:08:44,500 --> 00:08:48,760
an abstraction makes debugging worse

00:08:46,779 --> 00:08:51,670
because it hides something behind the

00:08:48,760 --> 00:08:53,230
abstraction on the other hand if it

00:08:51,670 --> 00:08:55,360
automatically does a lot of things

00:08:53,230 --> 00:08:58,900
correctly for you and it's a well tested

00:08:55,360 --> 00:09:00,940
tool as this one is usually your bug is

00:08:58,900 --> 00:09:03,430
somewhere else so it precludes those

00:09:00,940 --> 00:09:05,529
bugs being there to begin with but again

00:09:03,430 --> 00:09:07,990
whether this is a net win for you or not

00:09:05,529 --> 00:09:09,430
really depends on your worldview and

00:09:07,990 --> 00:09:10,870
what you're doing with it at the time so

00:09:09,430 --> 00:09:14,890
these are the questions you should ask

00:09:10,870 --> 00:09:16,600
yourself as it's coming up so I'm going

00:09:14,890 --> 00:09:19,630
to do something terrible here which is

00:09:16,600 --> 00:09:24,220
to quickly recount the history beginning

00:09:19,630 --> 00:09:27,400
up going up to the creation of data

00:09:24,220 --> 00:09:29,800
classes I've got Eric the creator the

00:09:27,400 --> 00:09:31,900
the tool here to correct me on any of

00:09:29,800 --> 00:09:34,270
this but this is a dangerous undertaking

00:09:31,900 --> 00:09:36,010
because the last time I did it I left

00:09:34,270 --> 00:09:38,410
someone out and they were quite angry

00:09:36,010 --> 00:09:41,800
about it so they are now included in

00:09:38,410 --> 00:09:44,380
this one that said history is quite

00:09:41,800 --> 00:09:46,930
difficult because there are very few new

00:09:44,380 --> 00:09:48,430
ideas under the Sun every time we think

00:09:46,930 --> 00:09:50,020
we've done something original you don't

00:09:48,430 --> 00:09:51,550
have to look too far back in time to

00:09:50,020 --> 00:09:53,530
where someone else had the same problem

00:09:51,550 --> 00:09:55,000
and came up with a solution this might

00:09:53,530 --> 00:09:57,850
be the first time all the pieces were

00:09:55,000 --> 00:10:01,330
put together so in a very brief history

00:09:57,850 --> 00:10:03,940
of time probably omitting some people in

00:10:01,330 --> 00:10:06,730
the beginning there were dicks tuples

00:10:03,940 --> 00:10:08,440
and handwritten classes we do use

00:10:06,730 --> 00:10:10,180
dictionaries for lookups tuples for

00:10:08,440 --> 00:10:12,190
structures and handwritten classes when

00:10:10,180 --> 00:10:13,800
we wanted more functionality and the

00:10:12,190 --> 00:10:17,140
world was just fine

00:10:13,800 --> 00:10:20,140
later we added a code generator for you

00:10:17,140 --> 00:10:22,660
named tuples it wrote some code for you

00:10:20,140 --> 00:10:25,480
that essentially its goal was to take a

00:10:22,660 --> 00:10:28,450
couple and add names to the fields to

00:10:25,480 --> 00:10:30,910
this end it succeeded however if you

00:10:28,450 --> 00:10:32,890
wanted something else like not having a

00:10:30,910 --> 00:10:33,640
couple underneath the hood of course it

00:10:32,890 --> 00:10:35,830
didn't work too well

00:10:33,640 --> 00:10:38,740
for you because it's a named tupple and

00:10:35,830 --> 00:10:41,020
if you hate tuples then you're not going

00:10:38,740 --> 00:10:44,470
to like name couple as well tuples being

00:10:41,020 --> 00:10:46,960
unmute a bull in being unpack a ball

00:10:44,470 --> 00:10:49,990
being hashable might be things that you

00:10:46,960 --> 00:10:52,060
want or I might not later we got

00:10:49,990 --> 00:10:54,700
something called type simple namespace

00:10:52,060 --> 00:10:58,710
which is just a very quick way to make a

00:10:54,700 --> 00:11:01,600
data holder as far as a code generator

00:10:58,710 --> 00:11:03,610
it generates very very little for you

00:11:01,600 --> 00:11:05,830
but a lot of people really like it

00:11:03,610 --> 00:11:08,230
because it's so lightweight I'm the

00:11:05,830 --> 00:11:10,420
opposite end of the lightweight scale we

00:11:08,230 --> 00:11:14,110
had ohms things like Django sequel

00:11:10,420 --> 00:11:15,910
alchemy peewee as far as I know these

00:11:14,110 --> 00:11:18,610
were the tools that pioneered using

00:11:15,910 --> 00:11:20,650
field specifications to generate more

00:11:18,610 --> 00:11:22,510
complex data structures behind the scene

00:11:20,650 --> 00:11:24,340
I know where I am being something you

00:11:22,510 --> 00:11:26,500
make a class with field specifications

00:11:24,340 --> 00:11:29,140
and it generates the database behind the

00:11:26,500 --> 00:11:31,810
scenes for you that's fantastic

00:11:29,140 --> 00:11:33,280
another tool that is very old and famous

00:11:31,810 --> 00:11:35,350
in the Python world is the trait let's

00:11:33,280 --> 00:11:40,390
module so treat let's was all about

00:11:35,350 --> 00:11:42,970
validating data as it came in and trait

00:11:40,390 --> 00:11:45,640
let's was well loved not as popular as

00:11:42,970 --> 00:11:48,220
some of these new tools but it was very

00:11:45,640 --> 00:11:51,690
good at his job and it appeared the idea

00:11:48,220 --> 00:11:53,800
of using class variables for

00:11:51,690 --> 00:11:57,370
specifications of what should go in data

00:11:53,800 --> 00:11:59,860
or what not in the past few versions of

00:11:57,370 --> 00:12:02,410
Python we've gone through this evolution

00:11:59,860 --> 00:12:06,220
of adding type annotations to the

00:12:02,410 --> 00:12:07,870
language so first we just had a notation

00:12:06,220 --> 00:12:10,420
for attaching it directly to a function

00:12:07,870 --> 00:12:12,910
or a class and it was inert it didn't do

00:12:10,420 --> 00:12:14,980
anything later we got the typing module

00:12:12,910 --> 00:12:17,290
and third-party tools like my PI that

00:12:14,980 --> 00:12:20,080
could scan all of other types and

00:12:17,290 --> 00:12:23,830
perform static typing checking for you

00:12:20,080 --> 00:12:26,110
and then cuido and Lisa wrote work

00:12:23,830 --> 00:12:29,020
together on a pep to create a new and

00:12:26,110 --> 00:12:34,450
clean stent acts for it and as of Python

00:12:29,020 --> 00:12:38,290
3 6 you can just right visitor count in

00:12:34,450 --> 00:12:40,420
to essentially declare without creating

00:12:38,290 --> 00:12:43,330
this variable just declaring it's a data

00:12:40,420 --> 00:12:45,910
type that was a beautiful notation there

00:12:43,330 --> 00:12:47,110
was also a third-party module a library

00:12:45,910 --> 00:12:50,530
called adder

00:12:47,110 --> 00:12:52,120
I am NOT a user of the adders module but

00:12:50,530 --> 00:12:55,000
I know it's very popular and it was an

00:12:52,120 --> 00:12:56,440
inspiration for a data classes put all

00:12:55,000 --> 00:12:58,450
of these things together it was time to

00:12:56,440 --> 00:13:01,450
put in some standard library support and

00:12:58,450 --> 00:13:03,010
Eric foolishly volunteered he thought

00:13:01,450 --> 00:13:04,330
how hard could it be

00:13:03,010 --> 00:13:08,320
did you end up putting a little effort

00:13:04,330 --> 00:13:12,490
into a Derek over a hundred hours over

00:13:08,320 --> 00:13:14,620
200 hours over 200 hours and he's not

00:13:12,490 --> 00:13:16,210
done yet I've developed a number of

00:13:14,620 --> 00:13:18,310
collections classes before and I know if

00:13:16,210 --> 00:13:20,650
they live with you forever you will have

00:13:18,310 --> 00:13:22,840
a lifetime of feature requests this for

00:13:20,650 --> 00:13:24,730
everything you decided not to do someone

00:13:22,840 --> 00:13:26,140
will request it for every design

00:13:24,730 --> 00:13:27,730
decision where you went left

00:13:26,140 --> 00:13:29,890
someone will argue that you should have

00:13:27,730 --> 00:13:32,290
gone right there will be bugs in there

00:13:29,890 --> 00:13:35,890
that you cannot have imagined at this

00:13:32,290 --> 00:13:37,780
phase and five years from now somebody

00:13:35,890 --> 00:13:41,620
will go it's too slow we need to write

00:13:37,780 --> 00:13:44,610
the whole thing in C someone will

00:13:41,620 --> 00:13:52,450
protest that it uses exec inside ow

00:13:44,610 --> 00:13:54,670
and in fact it does and you will never

00:13:52,450 --> 00:13:56,860
get any love for it except for right now

00:13:54,670 --> 00:14:00,330
we love you for what you did it was a

00:13:56,860 --> 00:14:00,330
really a magnificent thing

00:14:04,840 --> 00:14:10,270
I do have some good news for you based

00:14:07,690 --> 00:14:11,800
on my history in Python every year that

00:14:10,270 --> 00:14:12,400
I contributed something useful to the

00:14:11,800 --> 00:14:14,080
language

00:14:12,400 --> 00:14:15,790
Cueto came to talk to me and said I

00:14:14,080 --> 00:14:19,180
really liked it and he said I'll double

00:14:15,790 --> 00:14:24,160
your salary and for 18 years every year

00:14:19,180 --> 00:14:25,810
he's doubled my salary being an

00:14:24,160 --> 00:14:30,490
open-source contributor pays really

00:14:25,810 --> 00:14:32,470
really well not okay the goals of this

00:14:30,490 --> 00:14:35,080
according to the pep data classes are

00:14:32,470 --> 00:14:37,390
roughly very roughly immutable named

00:14:35,080 --> 00:14:38,830
couple with defaults there's more to it

00:14:37,390 --> 00:14:40,510
than that but if you need to file it

00:14:38,830 --> 00:14:42,940
away in your law mind with one little

00:14:40,510 --> 00:14:44,410
phrase what is it that's an answer it

00:14:42,940 --> 00:14:46,510
built on the success of the adders

00:14:44,410 --> 00:14:49,420
package it writes boilerplate code for

00:14:46,510 --> 00:14:51,400
you and it provides an elegant syntax

00:14:49,420 --> 00:14:52,000
for data holders ok I'm done any

00:14:51,400 --> 00:14:57,150
questions

00:14:52,000 --> 00:15:00,100
Oh would you like to see it all right

00:14:57,150 --> 00:15:03,220
I'm coming section comparing it with

00:15:00,100 --> 00:15:04,660
name tuples I would like this to have

00:15:03,220 --> 00:15:06,940
been a talk that was only about in the

00:15:04,660 --> 00:15:09,490
data classes and not named tuples but

00:15:06,940 --> 00:15:10,930
named tuples is what people know and the

00:15:09,490 --> 00:15:12,820
first question that comes to mind when

00:15:10,930 --> 00:15:15,880
you use data classes is what's different

00:15:12,820 --> 00:15:18,550
and what's the same so the goal of this

00:15:15,880 --> 00:15:20,800
is to answer that and the goal is to hit

00:15:18,550 --> 00:15:23,440
what is the common case the simplest

00:15:20,800 --> 00:15:27,070
case of using other data classes so

00:15:23,440 --> 00:15:30,340
without further ado here is a data class

00:15:27,070 --> 00:15:33,430
and the goal is to store a color in the

00:15:30,340 --> 00:15:37,090
HSL system reporting the hue the

00:15:33,430 --> 00:15:38,700
saturation and lightness hues the number

00:15:37,090 --> 00:15:40,750
of degrees and the color wheel

00:15:38,700 --> 00:15:42,280
saturation and lightness are typically

00:15:40,750 --> 00:15:45,760
expressed as a floating-point number a

00:15:42,280 --> 00:15:47,860
percentage of saturation so the way you

00:15:45,760 --> 00:15:50,890
make that using a data class as you use

00:15:47,860 --> 00:15:53,200
a class decorator at data class you've

00:15:50,890 --> 00:15:56,400
write a normal class you use that

00:15:53,200 --> 00:15:58,710
notation created by Lisa and cuido

00:15:56,400 --> 00:16:01,600
to indicate that he was an integer

00:15:58,710 --> 00:16:03,430
saturations is a float one really nice

00:16:01,600 --> 00:16:06,910
thing is you can specify default value

00:16:03,430 --> 00:16:10,090
for the flow let's compare that to the

00:16:06,910 --> 00:16:13,570
named tuple version you also have to do

00:16:10,090 --> 00:16:16,600
an import and these three lines are

00:16:13,570 --> 00:16:18,460
exactly the same as these three lines so

00:16:16,600 --> 00:16:22,860
the only part that is different is

00:16:18,460 --> 00:16:22,860
instead of at data class you have

00:16:23,130 --> 00:16:28,720
inherit from name tupple so do they look

00:16:26,800 --> 00:16:29,080
very structurally very similar to each

00:16:28,720 --> 00:16:31,720
other

00:16:29,080 --> 00:16:33,250
I agree one of the questions we were

00:16:31,720 --> 00:16:35,380
going to ask ourselves this is easy to

00:16:33,250 --> 00:16:37,840
use this is somewhat beautiful and

00:16:35,380 --> 00:16:41,260
elegant that's a nice way to specify a

00:16:37,840 --> 00:16:42,850
data holder so so far the only evident

00:16:41,260 --> 00:16:44,680
distinction is that there's a complete

00:16:42,850 --> 00:16:47,230
difference in approach data classes use

00:16:44,680 --> 00:16:49,150
a class decorator and named tuples

00:16:47,230 --> 00:16:51,430
inherited class that has a different

00:16:49,150 --> 00:16:54,880
meta class that goes in and fills in all

00:16:51,430 --> 00:16:58,780
of the values for you so how do you work

00:16:54,880 --> 00:17:00,610
with this data class well you create an

00:16:58,780 --> 00:17:04,420
instance of it much as you would is data

00:17:00,610 --> 00:17:06,550
a named tuple which waits the question I

00:17:04,420 --> 00:17:08,740
passed in two arguments how many

00:17:06,550 --> 00:17:12,400
arguments are there in the hls HSL

00:17:08,740 --> 00:17:15,520
system h SNL it's not intended to be a

00:17:12,400 --> 00:17:19,209
hard question three okay where did the

00:17:15,520 --> 00:17:22,770
third one come from not intended to be a

00:17:19,209 --> 00:17:22,770
hard question I'm pointing at the answer

00:17:23,610 --> 00:17:29,950
okay so there was a default value so one

00:17:28,180 --> 00:17:32,830
of the nice features of it is the Ripper

00:17:29,950 --> 00:17:34,510
came for free and it shows you how it

00:17:32,830 --> 00:17:36,370
was made and it gives you a self

00:17:34,510 --> 00:17:39,880
explanatory look this greatly helps

00:17:36,370 --> 00:17:42,280
during debugging oh also it lets you

00:17:39,880 --> 00:17:43,810
access the fields by name this is really

00:17:42,280 --> 00:17:45,610
nice if you've ever worked with straight

00:17:43,810 --> 00:17:48,190
tuples and have to refer to square

00:17:45,610 --> 00:17:50,940
brackets 3 or square brackets 0 you'll

00:17:48,190 --> 00:17:53,470
find that this is a great improvement

00:17:50,940 --> 00:17:55,960
can you build one of them off of another

00:17:53,470 --> 00:17:58,210
there's a function called replace that

00:17:55,960 --> 00:18:00,190
takes in a instance of a data class and

00:17:58,210 --> 00:18:03,730
lets you replace one or more fields

00:18:00,190 --> 00:18:05,890
this says model off of one color and

00:18:03,730 --> 00:18:07,660
make another color this color has the

00:18:05,890 --> 00:18:10,120
same saturation and lightness but a

00:18:07,660 --> 00:18:13,570
different hue so we're just spinning it

00:18:10,120 --> 00:18:15,160
around the color wheel oh we also have

00:18:13,570 --> 00:18:16,660
the ability to turn it into a regular

00:18:15,160 --> 00:18:18,730
dictionary this is important

00:18:16,660 --> 00:18:20,710
conceptually anything that's a key value

00:18:18,730 --> 00:18:24,040
store should be easy to turn into a

00:18:20,710 --> 00:18:26,140
dictionary however how this thing is

00:18:24,040 --> 00:18:28,990
ordered like a tuple and once in a while

00:18:26,140 --> 00:18:31,000
you're going to want to unpack it or use

00:18:28,990 --> 00:18:32,320
it in a tuples circumstance this gives

00:18:31,000 --> 00:18:36,940
you the ability to

00:18:32,320 --> 00:18:38,620
put it back into a tuple if you need one

00:18:36,940 --> 00:18:40,720
of the nice things about data classes is

00:18:38,620 --> 00:18:42,610
it builds type annotations for you so we

00:18:40,720 --> 00:18:45,610
can record some information some

00:18:42,610 --> 00:18:48,789
metadata about the class here's

00:18:45,610 --> 00:18:52,029
something new you can assign a value to

00:18:48,789 --> 00:18:56,259
it our data classes by default mutable

00:18:52,029 --> 00:19:00,399
or immutable immutable hey who remembers

00:18:56,259 --> 00:19:02,649
the name of my company mutable minds all

00:19:00,399 --> 00:19:04,480
I need to teach people is to have people

00:19:02,649 --> 00:19:08,860
in the audience with mutable minds if

00:19:04,480 --> 00:19:11,259
you have an immutable mind get out and

00:19:08,860 --> 00:19:13,120
so if I'm going to build a student I

00:19:11,259 --> 00:19:15,070
want to use data classes for it because

00:19:13,120 --> 00:19:18,009
I need them to be mutable so I can put

00:19:15,070 --> 00:19:20,049
in new information now let's see how big

00:19:18,009 --> 00:19:22,539
it is import sis and we'll see that this

00:19:20,049 --> 00:19:25,389
instance is 168 bytes

00:19:22,539 --> 00:19:29,080
I'd also like to use time--it to see how

00:19:25,389 --> 00:19:30,580
fast does it take to access the hue by

00:19:29,080 --> 00:19:32,470
default this does emit million

00:19:30,580 --> 00:19:34,210
iterations so we're looking at 33

00:19:32,470 --> 00:19:37,450
nanoseconds here on my five-year-old

00:19:34,210 --> 00:19:40,059
machine now let's compare that with

00:19:37,450 --> 00:19:42,460
working with a name tuple notice we make

00:19:40,059 --> 00:19:45,549
the color the same way notice it has the

00:19:42,460 --> 00:19:49,360
same appearance notice that it has the

00:19:45,549 --> 00:19:51,580
same field name access but now we get to

00:19:49,360 --> 00:19:54,340
a difference one difference is that in

00:19:51,580 --> 00:19:57,460
name tuples the methods start with an

00:19:54,340 --> 00:19:58,990
underscore I regret this choice I wish I

00:19:57,460 --> 00:20:01,419
had still used an underscore but a

00:19:58,990 --> 00:20:03,370
trailing underscore but because this has

00:20:01,419 --> 00:20:05,379
a stretch a strong hint that it's a

00:20:03,370 --> 00:20:08,710
private method it's not private at all

00:20:05,379 --> 00:20:11,200
it was just put in there to complain to

00:20:08,710 --> 00:20:14,500
prevent a namespace conflicts with

00:20:11,200 --> 00:20:16,720
actual fields name our replace so this

00:20:14,500 --> 00:20:19,029
is not pretty but it does have an

00:20:16,720 --> 00:20:21,669
advantage it's discoverable if you do a

00:20:19,029 --> 00:20:23,799
Durer of the object you'll see this

00:20:21,669 --> 00:20:25,690
method but if you do adder the data

00:20:23,799 --> 00:20:27,759
class you won't see the functions that

00:20:25,690 --> 00:20:30,129
operate it on it at all this is a normal

00:20:27,759 --> 00:20:33,399
relationship between objects and our

00:20:30,129 --> 00:20:35,230
methods and functions so as dict is also

00:20:33,399 --> 00:20:37,720
a method and here's a difference it

00:20:35,230 --> 00:20:39,340
returns an ordered date we would

00:20:37,720 --> 00:20:40,629
actually like to switch that to return

00:20:39,340 --> 00:20:42,279
our regular dix

00:20:40,629 --> 00:20:44,289
but there's a chance that people rely on

00:20:42,279 --> 00:20:46,519
it being an order dick so I'm going to

00:20:44,289 --> 00:20:48,409
have to go through a deprecations

00:20:46,519 --> 00:20:50,630
before I can actually switch this to a

00:20:48,409 --> 00:20:53,000
regular date so in this case data

00:20:50,630 --> 00:20:56,720
classes will lead us because they don't

00:20:53,000 --> 00:20:58,549
have any legacy code to to model after

00:20:56,720 --> 00:21:00,350
and if you want to CERN turn something

00:20:58,549 --> 00:21:03,230
into a tuples it's the same way as you

00:21:00,350 --> 00:21:06,740
turn it into a list its annotations are

00:21:03,230 --> 00:21:08,690
exactly the same here's a superpower of

00:21:06,740 --> 00:21:11,330
name tuples that data classes don't have

00:21:08,690 --> 00:21:13,940
they unpack can you do that with data

00:21:11,330 --> 00:21:16,970
classes the answer is yes but you have

00:21:13,940 --> 00:21:19,490
to first wrap this in a call to as tuple

00:21:16,970 --> 00:21:22,130
which is a quite reasonable thing unless

00:21:19,490 --> 00:21:24,590
you're going to be doing this a lot if

00:21:22,130 --> 00:21:27,080
we check the size of this instance it's

00:21:24,590 --> 00:21:30,380
significantly smaller only 72 bytes

00:21:27,080 --> 00:21:32,960
versus the 168 unfortunately we run a

00:21:30,380 --> 00:21:35,090
timing on it the name tuple field access

00:21:32,960 --> 00:21:39,769
is slower by quite a bit

00:21:35,090 --> 00:21:41,360
61 on nanoseconds I do have a fix for

00:21:39,769 --> 00:21:46,159
this but I wasn't able to get it into

00:21:41,360 --> 00:21:50,299
three seven really only 15 minutes oh my

00:21:46,159 --> 00:21:53,690
goodness we will speed up so I have a

00:21:50,299 --> 00:21:57,380
fix for this so as of 3/8 I can make

00:21:53,690 --> 00:21:59,510
this access faster than data classes but

00:21:57,380 --> 00:22:01,549
it's going to take some C code to do it

00:21:59,510 --> 00:22:04,039
running through property an item getter

00:22:01,549 --> 00:22:06,799
is pretty fast but not as fast as this

00:22:04,039 --> 00:22:09,169
one up here so here's the summary of all

00:22:06,799 --> 00:22:10,970
of the differences we have a replace

00:22:09,169 --> 00:22:13,399
function in a data class it's a replace

00:22:10,970 --> 00:22:15,710
method as dict is a function instead of

00:22:13,399 --> 00:22:18,260
a method we get a regular dick instead

00:22:15,710 --> 00:22:20,990
of an order date the method versus

00:22:18,260 --> 00:22:24,590
function again data classes are mutable

00:22:20,990 --> 00:22:29,929
name tuples are immutable or frozen data

00:22:24,590 --> 00:22:32,090
classes can't be hashed by default Oh in

00:22:29,929 --> 00:22:33,440
general that's a good thing because we

00:22:32,090 --> 00:22:35,570
don't know in advance whether you're

00:22:33,440 --> 00:22:37,669
going to put hashable fields inside

00:22:35,570 --> 00:22:41,029
whereas name tuples presume that you're

00:22:37,669 --> 00:22:43,309
putting something hashable inside by

00:22:41,029 --> 00:22:45,799
default they don't iterate which means

00:22:43,309 --> 00:22:48,740
that you can't unpack them by default

00:22:45,799 --> 00:22:51,860
they have no comparison methods where as

00:22:48,740 --> 00:22:53,419
named tuples sort just like tuples they

00:22:51,860 --> 00:22:55,760
have a different underlying data store

00:22:53,419 --> 00:22:57,679
the data is stored in an instance dict

00:22:55,760 --> 00:22:59,450
for data classes and it's stored in a

00:22:57,679 --> 00:23:02,450
tuple for name tuple

00:22:59,450 --> 00:23:04,580
the size of the data class is more than

00:23:02,450 --> 00:23:06,650
twice as large on the other hand it's

00:23:04,580 --> 00:23:09,080
more than twice as fast if you'd like a

00:23:06,650 --> 00:23:12,020
quick rundown of all differences it is

00:23:09,080 --> 00:23:14,180
on this table all right so let's go look

00:23:12,020 --> 00:23:16,040
at the code that gets generated so here

00:23:14,180 --> 00:23:19,280
it was a common case that we just looked

00:23:16,040 --> 00:23:22,010
at this is the code you write what do

00:23:19,280 --> 00:23:24,950
you get for that what does it do for you

00:23:22,010 --> 00:23:27,500
well as we look below we'll find the

00:23:24,950 --> 00:23:32,480
code that it generated and the most

00:23:27,500 --> 00:23:36,260
important part is these first this top

00:23:32,480 --> 00:23:38,900
section up here so let's what we see

00:23:36,260 --> 00:23:41,540
what we get like name tuples it gives

00:23:38,900 --> 00:23:44,930
you a nice doc string in fact the same

00:23:41,540 --> 00:23:46,280
doc string I really like that it's

00:23:44,930 --> 00:23:48,590
dunder init has the type annotations

00:23:46,280 --> 00:23:51,800
built directly inside so it's centered

00:23:48,590 --> 00:23:54,350
and respectable it has a nice Ripper and

00:23:51,800 --> 00:23:56,900
the Ripper is exactly what you would

00:23:54,350 --> 00:23:58,580
write by a hand except that a lot of

00:23:56,900 --> 00:24:02,300
people would have leave off the dunder

00:23:58,580 --> 00:24:05,060
cual name this is a case of the

00:24:02,300 --> 00:24:06,860
generated code being nicer than what

00:24:05,060 --> 00:24:08,540
most people would write by hand it's

00:24:06,860 --> 00:24:13,600
incorporating a best practice for you

00:24:08,540 --> 00:24:16,490
the equal method is really interesting

00:24:13,600 --> 00:24:19,730
what name tuples would do is this

00:24:16,490 --> 00:24:22,520
comparison here on the second line it's

00:24:19,730 --> 00:24:24,710
what most classes would do this one is

00:24:22,520 --> 00:24:27,620
somewhat interesting though it checks to

00:24:24,710 --> 00:24:30,410
see if the other method is of our the

00:24:27,620 --> 00:24:32,260
other object is of the same class so it

00:24:30,410 --> 00:24:34,430
refuses to compare apples to oranges

00:24:32,260 --> 00:24:36,770
this gives us a much stronger

00:24:34,430 --> 00:24:38,450
relationship between types is something

00:24:36,770 --> 00:24:40,640
that I wish had been done for enums

00:24:38,450 --> 00:24:44,090
because it is possible now for us to

00:24:40,640 --> 00:24:48,380
have the enum color red equal one be

00:24:44,090 --> 00:24:50,960
equal to an enum size small medium and

00:24:48,380 --> 00:24:52,550
large were small as one and of course

00:24:50,960 --> 00:24:55,930
those things should be non comparable

00:24:52,550 --> 00:24:58,640
and so this best practice is built into

00:24:55,930 --> 00:25:00,680
data classes by default and I think this

00:24:58,640 --> 00:25:02,960
is a really nice win is something most

00:25:00,680 --> 00:25:05,450
people wouldn't think to do well it will

00:25:02,960 --> 00:25:07,880
improve code quality and help you avoid

00:25:05,450 --> 00:25:09,650
some really hard to find bugs another

00:25:07,880 --> 00:25:11,480
thing that people commonly forget is

00:25:09,650 --> 00:25:12,110
whenever you write an equality method

00:25:11,480 --> 00:25:14,299
you all

00:25:12,110 --> 00:25:16,520
need to say something about hashing and

00:25:14,299 --> 00:25:18,890
so this makes a fairly bold statement

00:25:16,520 --> 00:25:21,170
I'm not hashable at all what would

00:25:18,890 --> 00:25:22,940
happen if with this were left out it

00:25:21,170 --> 00:25:25,250
would hatch but it would compare on

00:25:22,940 --> 00:25:27,679
identity and for a lot of people that is

00:25:25,250 --> 00:25:30,559
a surprise and it's rarely what you want

00:25:27,679 --> 00:25:32,660
so once again data classes are making a

00:25:30,559 --> 00:25:34,970
choice for you that is mostly what you

00:25:32,660 --> 00:25:37,940
want most of the time whether you knew

00:25:34,970 --> 00:25:40,330
it or not so I think we can conclude at

00:25:37,940 --> 00:25:44,179
this point how much work did it save you

00:25:40,330 --> 00:25:47,630
you wrote four lines of code what did it

00:25:44,179 --> 00:25:49,880
right for you it wrote about nine lines

00:25:47,630 --> 00:25:52,010
of code or ten lines of code so there's

00:25:49,880 --> 00:25:54,260
about a six line of code savings but

00:25:52,010 --> 00:25:56,690
along the way it improved quality by

00:25:54,260 --> 00:25:59,240
doing things that other people forget by

00:25:56,690 --> 00:26:01,940
making a tighter checks making a

00:25:59,240 --> 00:26:03,380
higher-quality repper and adding type

00:26:01,940 --> 00:26:05,990
annotations which are things that we'll

00:26:03,380 --> 00:26:08,390
forget so I think of the win in terms of

00:26:05,990 --> 00:26:10,700
code saved being very minor here but the

00:26:08,390 --> 00:26:14,000
win in terms of quality by default is a

00:26:10,700 --> 00:26:16,610
nice win there's also all of this other

00:26:14,000 --> 00:26:20,900
stuff down here and I'm trying to avoid

00:26:16,610 --> 00:26:23,210
a pejorative term junk it is not junk

00:26:20,900 --> 00:26:29,000
it is supports introspection of the

00:26:23,210 --> 00:26:30,320
class but it looks junky in the help so

00:26:29,000 --> 00:26:31,790
one of the nice things says is it

00:26:30,320 --> 00:26:34,190
records the parameters for you it tells

00:26:31,790 --> 00:26:36,470
you how the data class was built this is

00:26:34,190 --> 00:26:38,450
really nice lots of other code

00:26:36,470 --> 00:26:40,250
generators leave this information out

00:26:38,450 --> 00:26:43,010
and you have to guess what parameters

00:26:40,250 --> 00:26:45,559
used to make them in addition it has

00:26:43,010 --> 00:26:49,040
detailed information about each field

00:26:45,559 --> 00:26:51,290
and seeing including the metadata so if

00:26:49,040 --> 00:26:53,350
you were writing the code by hand you

00:26:51,290 --> 00:26:57,620
would probably have written only about

00:26:53,350 --> 00:26:59,390
six or seven lines of this if you were

00:26:57,620 --> 00:27:02,450
smart in doing it you would have written

00:26:59,390 --> 00:27:04,010
all of these lines almost certainly

00:27:02,450 --> 00:27:05,809
though you wouldn't have written any of

00:27:04,010 --> 00:27:07,760
this and this stuff is actually left in

00:27:05,809 --> 00:27:09,590
your class and when you're hand writing

00:27:07,760 --> 00:27:11,510
code you would probably have never put

00:27:09,590 --> 00:27:13,400
these attributes in there interestingly

00:27:11,510 --> 00:27:16,010
this one actually creates a class

00:27:13,400 --> 00:27:17,840
variable for you so you now have a class

00:27:16,010 --> 00:27:19,880
variable and an instance variable that

00:27:17,840 --> 00:27:22,309
might disagree with each other not

00:27:19,880 --> 00:27:24,169
really problematic but different from

00:27:22,309 --> 00:27:26,460
what we would write by hand so the

00:27:24,169 --> 00:27:28,470
interesting points are

00:27:26,460 --> 00:27:29,970
it matches our handwritten code for

00:27:28,470 --> 00:27:31,610
three of the methods the docstring

00:27:29,970 --> 00:27:34,170
matches what you would write by hand

00:27:31,610 --> 00:27:36,720
equality comparison does an exact match

00:27:34,170 --> 00:27:40,490
head is set to none so you don't get

00:27:36,720 --> 00:27:42,750
accidental hash ability generated code

00:27:40,490 --> 00:27:44,900
includes everything from the original

00:27:42,750 --> 00:27:47,640
plus the default as a class variable

00:27:44,900 --> 00:27:50,040
probably not what you want and some nice

00:27:47,640 --> 00:27:52,440
introspection whose only downside is it

00:27:50,040 --> 00:27:57,120
looks a little bit junky and the help

00:27:52,440 --> 00:27:59,730
and that is the common case who wants

00:27:57,120 --> 00:28:01,140
uncommon cases that's good how many

00:27:59,730 --> 00:28:04,440
minutes do I have left for in common

00:28:01,140 --> 00:28:06,270
cases so one of the really nice things

00:28:04,440 --> 00:28:08,550
about data classes that makes them a

00:28:06,270 --> 00:28:10,740
little bit more complex are more complex

00:28:08,550 --> 00:28:12,840
and all the other code generators in

00:28:10,740 --> 00:28:15,060
Python is it allows extensive

00:28:12,840 --> 00:28:17,490
customization so all the things I said

00:28:15,060 --> 00:28:22,100
it didn't do by default some of them it

00:28:17,490 --> 00:28:22,100
does but you have to say what you want

00:28:23,210 --> 00:28:31,230
so I want to extend this example we're

00:28:28,440 --> 00:28:33,270
going to cover freezing in order so data

00:28:31,230 --> 00:28:37,140
classes are by default mutable this is a

00:28:33,270 --> 00:28:39,120
nice benefit Oh on the other hand you

00:28:37,140 --> 00:28:42,120
can't use it as a set element or as a

00:28:39,120 --> 00:28:44,850
dictionary key which often is what we

00:28:42,120 --> 00:28:46,710
want also they're not orderable which

00:28:44,850 --> 00:28:49,440
means that you can't sort this in some

00:28:46,710 --> 00:28:51,870
nice consistent our print order but if

00:28:49,440 --> 00:28:54,570
you need these all you have to do is say

00:28:51,870 --> 00:28:57,930
what you want so the only change to our

00:28:54,570 --> 00:29:00,390
previous our recipe is saying order

00:28:57,930 --> 00:29:01,620
equal true and frozen equal true who

00:29:00,390 --> 00:29:04,050
thinks it's kind of nice you can just

00:29:01,620 --> 00:29:05,640
say what you want and get it and if you

00:29:04,050 --> 00:29:08,670
don't say what you want you get what you

00:29:05,640 --> 00:29:11,520
usually need this is a really nice

00:29:08,670 --> 00:29:13,530
benefit the only problem from this is if

00:29:11,520 --> 00:29:16,620
you think that the default is something

00:29:13,530 --> 00:29:18,300
than what actually is if you're testing

00:29:16,620 --> 00:29:19,680
you'll learn it the hard way on the

00:29:18,300 --> 00:29:22,050
other hand there's some really nice

00:29:19,680 --> 00:29:25,800
tooltips that go along with us

00:29:22,050 --> 00:29:28,590
so now let's use that new data class

00:29:25,800 --> 00:29:30,990
it's pretty easy this time I make four

00:29:28,590 --> 00:29:32,820
colors and then we can now do something

00:29:30,990 --> 00:29:36,660
new with them we can sort them

00:29:32,820 --> 00:29:38,670
previously that wasn't possible also we

00:29:36,660 --> 00:29:39,809
can you make a set of the colors which

00:29:38,670 --> 00:29:42,119
eliminates

00:29:39,809 --> 00:29:45,840
the to duplicate colors the one at 66

00:29:42,119 --> 00:29:47,549
degrees and 75 percent saturation these

00:29:45,840 --> 00:29:49,830
two capabilities were previously not

00:29:47,549 --> 00:29:52,799
there if you need those capabilities are

00:29:49,830 --> 00:29:57,570
they easy to turn on yeah which is a

00:29:52,799 --> 00:29:59,909
fairly nice win now back to the question

00:29:57,570 --> 00:30:03,179
how much work does you say does it save

00:29:59,909 --> 00:30:05,609
you in this case a lot more so there are

00:30:03,179 --> 00:30:07,320
several comparison methods that get

00:30:05,609 --> 00:30:09,570
written for you these are no fun to

00:30:07,320 --> 00:30:12,450
write by hand we already had a solution

00:30:09,570 --> 00:30:14,460
for that problem in funk tools total

00:30:12,450 --> 00:30:18,899
ordering also implemented as a class

00:30:14,460 --> 00:30:20,909
decorator however it didn't have this by

00:30:18,899 --> 00:30:22,979
default this stronger check to make sure

00:30:20,909 --> 00:30:25,519
that the classes are the same to predict

00:30:22,979 --> 00:30:28,049
i'll prevent accidental comparison

00:30:25,519 --> 00:30:30,359
another interesting thing is when we

00:30:28,049 --> 00:30:32,909
made it frozen we wanted to be immutable

00:30:30,359 --> 00:30:36,389
so you can't write to it or delete a an

00:30:32,909 --> 00:30:38,219
attribute so this is fantastic there's a

00:30:36,389 --> 00:30:40,799
number of ways to achieve that one is

00:30:38,219 --> 00:30:42,450
through a meta class another is quite

00:30:40,799 --> 00:30:44,460
common in the Python world if you look

00:30:42,450 --> 00:30:47,009
at the fractions module we make the

00:30:44,460 --> 00:30:49,769
numerator and denominator no denominator

00:30:47,009 --> 00:30:52,529
unraidable the way we do so is by using

00:30:49,769 --> 00:30:56,099
up read-only property in this case

00:30:52,529 --> 00:30:57,149
though we extend senator something

00:30:56,099 --> 00:30:59,489
fairly interesting when you compare

00:30:57,149 --> 00:31:01,830
these the ones here at the top don't

00:30:59,489 --> 00:31:04,289
call super and we don't really want them

00:31:01,830 --> 00:31:07,139
to because the parent class object will

00:31:04,289 --> 00:31:09,239
return I forgot what it returns none are

00:31:07,139 --> 00:31:11,339
not implemented or something like that

00:31:09,239 --> 00:31:14,639
so we really don't want to call those

00:31:11,339 --> 00:31:16,679
there but set at her and D letter we

00:31:14,639 --> 00:31:20,159
actually really do mostly want what the

00:31:16,679 --> 00:31:24,149
parents have so if you're attempting to

00:31:20,159 --> 00:31:26,460
modify one of the fields that is blocked

00:31:24,149 --> 00:31:30,659
it'll go ahead and raise an exception

00:31:26,460 --> 00:31:32,309
otherwise it'll go ahead and call the

00:31:30,659 --> 00:31:34,919
parent which means that a class can be

00:31:32,309 --> 00:31:37,529
partially writable so this is really

00:31:34,919 --> 00:31:39,269
nice this is beyond the code here is

00:31:37,529 --> 00:31:41,219
beyond the skill lever

00:31:39,269 --> 00:31:42,989
skill level of most everyday Python

00:31:41,219 --> 00:31:46,139
programmers so they're getting a really

00:31:42,989 --> 00:31:48,479
nice a win for this also it's fairly

00:31:46,139 --> 00:31:50,050
common for people to be challenged in

00:31:48,479 --> 00:31:52,210
writing and underlying

00:31:50,050 --> 00:31:54,400
hash function and by default it includes

00:31:52,210 --> 00:31:57,730
all of the fields so what were the

00:31:54,400 --> 00:31:59,650
interesting points here in a way this is

00:31:57,730 --> 00:32:02,710
better than funk tools total ordering

00:31:59,650 --> 00:32:05,830
because it's type-specific we can't call

00:32:02,710 --> 00:32:08,110
super for for the comparison methods

00:32:05,830 --> 00:32:11,260
because object has ones that we don't

00:32:08,110 --> 00:32:13,750
want the frozen behavior is implemented

00:32:11,260 --> 00:32:16,210
in an interesting way by extending get a

00:32:13,750 --> 00:32:17,500
door and a ladder this is different from

00:32:16,210 --> 00:32:19,510
what most people would write by hand

00:32:17,500 --> 00:32:23,560
like what you see in the fractions

00:32:19,510 --> 00:32:25,720
module so these extended methods do call

00:32:23,560 --> 00:32:27,190
super so that we don't accidentally turn

00:32:25,720 --> 00:32:30,490
off an important behavior in the parent

00:32:27,190 --> 00:32:32,050
class and the hats method does write

00:32:30,490 --> 00:32:35,920
what you match what you would write by

00:32:32,050 --> 00:32:38,050
hand as a quick comparison to name

00:32:35,920 --> 00:32:40,570
tuples all of these behaviors become

00:32:38,050 --> 00:32:43,300
come for free because they're inherited

00:32:40,570 --> 00:32:44,860
for tupple and the ones in tupple are

00:32:43,300 --> 00:32:47,620
written in c so there are quite a bit

00:32:44,860 --> 00:32:49,660
faster so you get all of these behaviors

00:32:47,620 --> 00:32:51,580
which would make you think that for

00:32:49,660 --> 00:32:53,230
something that's frozen named Tempel

00:32:51,580 --> 00:32:55,920
might be what you wanted to begin with

00:32:53,230 --> 00:32:58,210
and i believe that that is mostly true

00:32:55,920 --> 00:33:03,220
however the world's more complex than

00:32:58,210 --> 00:33:05,860
that be mutable or immutable or a mix of

00:33:03,220 --> 00:33:08,590
both I'll have peanut butter and

00:33:05,860 --> 00:33:10,570
chocolate and have some races and

00:33:08,590 --> 00:33:12,880
sometimes there's legitimate use cases

00:33:10,570 --> 00:33:15,790
for a mix of those what about do I want

00:33:12,880 --> 00:33:17,590
or durable or not or durable is good if

00:33:15,790 --> 00:33:21,520
my data is orderable or durable it's bad

00:33:17,590 --> 00:33:23,230
if it's not what if I have a mix in that

00:33:21,520 --> 00:33:25,510
more complex world we have something

00:33:23,230 --> 00:33:27,760
data classes can do for you that name

00:33:25,510 --> 00:33:29,620
tuples can name tuples are somewhat

00:33:27,760 --> 00:33:31,750
limited in their capability remember

00:33:29,620 --> 00:33:34,540
their goal is to do whatever tuples do

00:33:31,750 --> 00:33:38,140
and not to extend that notion they just

00:33:34,540 --> 00:33:45,700
take tuples ad types default values and

00:33:38,140 --> 00:33:50,200
name via lookups you're kidding me where

00:33:45,700 --> 00:33:53,260
did it go okay

00:33:50,200 --> 00:33:55,180
we did type me right all right so here's

00:33:53,260 --> 00:33:57,220
things that you might want that are

00:33:55,180 --> 00:34:01,240
outside the defaults you might want to

00:33:57,220 --> 00:34:03,550
customize a field specification and so

00:34:01,240 --> 00:34:04,160
in my example we have trying to pick a

00:34:03,550 --> 00:34:06,170
real world

00:34:04,160 --> 00:34:09,710
example an employee class at stores an

00:34:06,170 --> 00:34:12,350
employee ID name gender salary and age

00:34:09,710 --> 00:34:14,540
we also want to keep a list that grows

00:34:12,350 --> 00:34:16,910
over time recording everyone who has

00:34:14,540 --> 00:34:21,560
viewed the employee record so we know

00:34:16,910 --> 00:34:24,080
who's seen it so that creates a fairly

00:34:21,560 --> 00:34:26,330
rich problem for us that will exercise

00:34:24,080 --> 00:34:28,640
all of the powerful capabilities of data

00:34:26,330 --> 00:34:30,679
classes one thing we want is a field

00:34:28,640 --> 00:34:33,470
Factory instead of a default value of

00:34:30,679 --> 00:34:37,100
0.5 we'd like to make a new empty list

00:34:33,470 --> 00:34:39,200
every time this is very easy to do we'll

00:34:37,100 --> 00:34:41,830
just say the default Factory is a list

00:34:39,200 --> 00:34:44,000
you use this very much like default Dix

00:34:41,830 --> 00:34:46,280
also what if you want to add custom

00:34:44,000 --> 00:34:48,980
methods to the class this is a regular

00:34:46,280 --> 00:34:50,929
class and so just write your method done

00:34:48,980 --> 00:34:53,090
normally in this case we'll write an

00:34:50,929 --> 00:34:56,300
access method to record who viewed the

00:34:53,090 --> 00:34:58,040
data now we'd like this to be hashable

00:34:56,300 --> 00:35:00,410
so we could use employees in a

00:34:58,040 --> 00:35:03,710
dictionary however only three of the

00:35:00,410 --> 00:35:05,630
fields are immutable a person's age will

00:35:03,710 --> 00:35:09,980
change from year to year hopefully their

00:35:05,630 --> 00:35:12,770
salary will increase as well and so we'd

00:35:09,980 --> 00:35:14,330
like to exclude those in addition we

00:35:12,770 --> 00:35:18,440
really don't want the list to be

00:35:14,330 --> 00:35:20,180
included because it is not hashable if

00:35:18,440 --> 00:35:22,430
we specify a default factory it's

00:35:20,180 --> 00:35:25,070
automatically excluded from the hash

00:35:22,430 --> 00:35:27,380
function also you don't necessarily

00:35:25,070 --> 00:35:30,410
always want to display all the data in

00:35:27,380 --> 00:35:31,850
the wrapper in particular the salary

00:35:30,410 --> 00:35:33,940
information we don't want that to show

00:35:31,850 --> 00:35:39,550
by default because it's sensitive

00:35:33,940 --> 00:35:41,810
likewise the field information will be

00:35:39,550 --> 00:35:43,520
for all of the people who viewed the

00:35:41,810 --> 00:35:45,380
record that might be a rather long list

00:35:43,520 --> 00:35:47,060
and we don't want it to be part of the

00:35:45,380 --> 00:35:49,880
repper that'll get in the way of debug

00:35:47,060 --> 00:35:51,800
ability this is easy to achieve you just

00:35:49,880 --> 00:35:54,890
say I want this field to have its ripper

00:35:51,800 --> 00:35:57,320
turned off also we want to limit the

00:35:54,890 --> 00:35:59,060
fields used in comparisons there are

00:35:57,320 --> 00:36:01,970
some things like complex numbers are

00:35:59,060 --> 00:36:03,710
functions that are orderable and they

00:36:01,970 --> 00:36:06,830
would raise a type error if we included

00:36:03,710 --> 00:36:08,840
so we need to exclude them also we want

00:36:06,830 --> 00:36:10,550
to include the metadata like that list

00:36:08,840 --> 00:36:14,060
of accessors that is no basis for

00:36:10,550 --> 00:36:16,210
comparison this is also easy to do if

00:36:14,060 --> 00:36:18,030
you don't want comparison turn it off

00:36:16,210 --> 00:36:21,150
also and from the day

00:36:18,030 --> 00:36:23,520
based world we know that we sometimes

00:36:21,150 --> 00:36:26,580
want data dictionaries to describe our

00:36:23,520 --> 00:36:28,680
records a mechanisms provided called the

00:36:26,580 --> 00:36:32,040
metadata parameter and there's a viewer

00:36:28,680 --> 00:36:35,040
function called fields so we attach a

00:36:32,040 --> 00:36:37,680
metadata that lets us specify in this

00:36:35,040 --> 00:36:39,450
case the spell ah I pay people in

00:36:37,680 --> 00:36:41,010
bitcoins they never know how much

00:36:39,450 --> 00:36:43,560
they're going to make I'll say I'll

00:36:41,010 --> 00:36:46,170
offer you uh ten bitcoins for a year's

00:36:43,560 --> 00:36:49,770
worth of work my rich for I am poor well

00:36:46,170 --> 00:36:53,700
it varies from day to day so I've given

00:36:49,770 --> 00:36:56,430
you a fairly rich set of constraints and

00:36:53,700 --> 00:36:58,380
if I ask you to write that by hand you

00:36:56,430 --> 00:37:00,420
might ask for a couple hours of time and

00:36:58,380 --> 00:37:02,550
a couple hours of testing time the

00:37:00,420 --> 00:37:04,860
question is does data classes make it

00:37:02,550 --> 00:37:07,380
easier for you yes all of those

00:37:04,860 --> 00:37:10,050
specifications are quite readable let's

00:37:07,380 --> 00:37:13,140
look at how we do it they say I want

00:37:10,050 --> 00:37:15,420
this data class to be ordered this is an

00:37:13,140 --> 00:37:17,040
interesting name unsafe hash and all

00:37:15,420 --> 00:37:21,140
that Eric talked to that if you have any

00:37:17,040 --> 00:37:24,170
questions about it is a thorny subject

00:37:21,140 --> 00:37:26,190
roughly it is named that so that people

00:37:24,170 --> 00:37:28,860
realize that they're up to something

00:37:26,190 --> 00:37:29,040
tricky and don't do anything crazy with

00:37:28,860 --> 00:37:32,040
it

00:37:29,040 --> 00:37:33,180
and it says of all the parameters this

00:37:32,040 --> 00:37:35,550
is one where you're going to look up

00:37:33,180 --> 00:37:38,100
what it does before you use it hence the

00:37:35,550 --> 00:37:40,380
word unsafe it doesn't mean actually

00:37:38,100 --> 00:37:43,980
unsafe it just means more complex and

00:37:40,380 --> 00:37:45,960
you might expect at our first look so

00:37:43,980 --> 00:37:48,480
listing out all of the fields was easy

00:37:45,960 --> 00:37:50,760
notice how to add a method I just write

00:37:48,480 --> 00:37:54,240
it like a normal method so we want to

00:37:50,760 --> 00:37:56,340
add a viewer ID oh these three field

00:37:54,240 --> 00:37:58,620
specifications are straightforward the

00:37:56,340 --> 00:37:59,460
salary I don't want it to display so I

00:37:58,620 --> 00:38:00,870
turn that off

00:37:59,460 --> 00:38:03,180
I don't want it included as part of the

00:38:00,870 --> 00:38:06,540
hash and I would like to record that

00:38:03,180 --> 00:38:10,920
it's I'm paying people in Bitcoin also

00:38:06,540 --> 00:38:13,620
age is not part of the hash as as well

00:38:10,920 --> 00:38:16,740
but it is part of the comparison the

00:38:13,620 --> 00:38:18,510
viewed by list will be every time we

00:38:16,740 --> 00:38:20,700
create a new instance it creates a new

00:38:18,510 --> 00:38:22,260
list for us this is the default Factory

00:38:20,700 --> 00:38:24,660
we don't want that to be part of the

00:38:22,260 --> 00:38:26,640
comparison or part of the repper that is

00:38:24,660 --> 00:38:28,230
pretty darn easy and to me this is the

00:38:26,640 --> 00:38:31,970
most impressive example of what data

00:38:28,230 --> 00:38:31,970
classes can do how many of you like it

00:38:32,180 --> 00:38:40,560
very cool so let's just work with that

00:38:36,750 --> 00:38:43,050
example I will put my wife in and rather

00:38:40,560 --> 00:38:46,580
than give away her age in normal units

00:38:43,050 --> 00:38:49,080
I'll give it in hexadecimal there we go

00:38:46,580 --> 00:38:53,460
I'm already in trouble for missing

00:38:49,080 --> 00:38:58,560
Mother's Day tomorrow and our wedding

00:38:53,460 --> 00:39:00,420
anniversary last week not cool all right

00:38:58,560 --> 00:39:03,320
notice that I didn't have to specify the

00:39:00,420 --> 00:39:06,990
viewers that is created for us by the

00:39:03,320 --> 00:39:09,330
factory mod default okay so nothing

00:39:06,990 --> 00:39:11,070
exciting on the instance creation I go

00:39:09,330 --> 00:39:13,680
ahead and call my methods who's

00:39:11,070 --> 00:39:17,820
accessing this record so we record to

00:39:13,680 --> 00:39:19,530
viewers if I pretty print the viewed bye

00:39:17,820 --> 00:39:22,050
you can now see the two people who

00:39:19,530 --> 00:39:25,170
accessed the record and when they

00:39:22,050 --> 00:39:30,360
accessed it what did you know and when

00:39:25,170 --> 00:39:32,670
did you know it okay and we can now sort

00:39:30,360 --> 00:39:34,410
it why because it's orderable but when

00:39:32,670 --> 00:39:36,030
it orders it's not going to order on all

00:39:34,410 --> 00:39:38,250
the fields just the field so we

00:39:36,030 --> 00:39:40,650
specified the ones that makes sense and

00:39:38,250 --> 00:39:43,950
when we look at the reppers of these are

00:39:40,650 --> 00:39:46,050
the the data like who is viewed by is

00:39:43,950 --> 00:39:50,280
excluded from the repper as is the

00:39:46,050 --> 00:39:53,010
salary per our specs in addition we can

00:39:50,280 --> 00:39:56,610
use the employees as dictionary keys so

00:39:53,010 --> 00:39:58,920
I can assign our Rachel to gather all of

00:39:56,610 --> 00:40:01,710
the requirements and Martin to write all

00:39:58,920 --> 00:40:03,330
of the tests and that's possible because

00:40:01,710 --> 00:40:05,160
we've marked certain fields as hashable

00:40:03,330 --> 00:40:07,620
keep in mind not all of the fields were

00:40:05,160 --> 00:40:10,500
hashable and so we needed all this power

00:40:07,620 --> 00:40:13,050
in addition the fields functions lets us

00:40:10,500 --> 00:40:15,660
introspect are the field specifications

00:40:13,050 --> 00:40:18,150
and we can see that the salary field are

00:40:15,660 --> 00:40:20,160
the payment is in a Bitcoin the code

00:40:18,150 --> 00:40:21,840
that's generated here is this is very

00:40:20,160 --> 00:40:24,660
close to what you would write by hand

00:40:21,840 --> 00:40:27,260
for the anit to create a new list the

00:40:24,660 --> 00:40:30,060
repper is what you would write by hand

00:40:27,260 --> 00:40:32,760
the equality's we discussed before is

00:40:30,060 --> 00:40:34,920
type specific as are the other

00:40:32,760 --> 00:40:36,480
comparison functions what's interesting

00:40:34,920 --> 00:40:38,640
about the comparison functions is not

00:40:36,480 --> 00:40:40,500
how they're written is what they exclude

00:40:38,640 --> 00:40:42,750
they don't include all of the fields and

00:40:40,500 --> 00:40:43,550
likewise the hash doesn't include all of

00:40:42,750 --> 00:40:47,780
the

00:40:43,550 --> 00:40:49,910
so some quick closing thoughts and then

00:40:47,780 --> 00:40:51,980
to defend myself during the question and

00:40:49,910 --> 00:40:54,500
answer period I've called in for backup

00:40:51,980 --> 00:40:56,540
and reinforcements so if I either tell

00:40:54,500 --> 00:40:59,390
you any lies are done to the answer the

00:40:56,540 --> 00:41:01,250
person who knows the truth and may be

00:40:59,390 --> 00:41:03,650
willing to sell it share it with you is

00:41:01,250 --> 00:41:05,990
here so I'll invite to Eric to come on

00:41:03,650 --> 00:41:08,060
up and we'll give him a round of

00:41:05,990 --> 00:41:11,120
applause when he gets here so here are

00:41:08,060 --> 00:41:13,580
the challenges with using it one is it's

00:41:11,120 --> 00:41:15,500
currently tricky to add slots to a data

00:41:13,580 --> 00:41:17,420
class and slots is a pretty darn

00:41:15,500 --> 00:41:19,790
important optimization it'll save you a

00:41:17,420 --> 00:41:22,010
lot of space and speed and prove the

00:41:19,790 --> 00:41:24,320
speed of access of the fields so slots

00:41:22,010 --> 00:41:27,230
works just fine until you have default

00:41:24,320 --> 00:41:29,360
values and for deep reasons they fight

00:41:27,230 --> 00:41:31,850
each other this is hard to fix but

00:41:29,360 --> 00:41:34,070
probably will be fixed if we fix it

00:41:31,850 --> 00:41:35,660
though almost certainly we're going to

00:41:34,070 --> 00:41:37,700
have to have the classic decorator not

00:41:35,660 --> 00:41:40,460
modify the class in place but make a

00:41:37,700 --> 00:41:41,390
brand new class this will be irritating

00:41:40,460 --> 00:41:43,670
at so many levels

00:41:41,390 --> 00:41:46,010
the dunder and NIT that's generated

00:41:43,670 --> 00:41:47,780
doesn't call super because most of the

00:41:46,010 --> 00:41:49,460
time that's not what we want but if you

00:41:47,780 --> 00:41:51,500
incur it from a classes and it does to

00:41:49,460 --> 00:41:53,390
be to call there's a interesting

00:41:51,500 --> 00:41:55,010
gundermutt they call post in it that

00:41:53,390 --> 00:41:56,540
calls what you need there was some

00:41:55,010 --> 00:41:58,610
debate about whether to include a pre in

00:41:56,540 --> 00:42:00,320
it but that probably won't happen unless

00:41:58,610 --> 00:42:04,520
somebody asked for it with a compelling

00:42:00,320 --> 00:42:07,160
use case also data classes were designed

00:42:04,520 --> 00:42:08,750
to wrap around existing classes and it

00:42:07,160 --> 00:42:10,280
works really well with mutable classes

00:42:08,750 --> 00:42:12,590
but if the immutable there's an

00:42:10,280 --> 00:42:14,750
immutable parent we don't have an easy

00:42:12,590 --> 00:42:17,270
way to overwrite or extend that under

00:42:14,750 --> 00:42:19,910
new method it is really all about things

00:42:17,270 --> 00:42:22,250
that we're putting the data in so I

00:42:19,910 --> 00:42:24,740
tried to reinvent name tupple using data

00:42:22,250 --> 00:42:25,220
classes and it essentially did nothing

00:42:24,740 --> 00:42:27,170
for me

00:42:25,220 --> 00:42:29,960
other than create the repper and not in

00:42:27,170 --> 00:42:32,960
the way it's clean away as the name

00:42:29,960 --> 00:42:35,270
couple did so there's some things that

00:42:32,960 --> 00:42:37,400
it's not good at mostly it's good for a

00:42:35,270 --> 00:42:39,650
lot of things future directions I

00:42:37,400 --> 00:42:41,330
expected over time people will request

00:42:39,650 --> 00:42:43,940
things that are in the adders package

00:42:41,330 --> 00:42:45,440
will come to be present in data classes

00:42:43,940 --> 00:42:47,840
so at some point we'll probably have

00:42:45,440 --> 00:42:49,660
data validators at some point we'll

00:42:47,840 --> 00:42:53,330
probably have better support for slots

00:42:49,660 --> 00:42:55,010
so I hope you enjoyed that tutorial and

00:42:53,330 --> 00:42:56,960
walkthrough I tried to give you simple

00:42:55,010 --> 00:43:00,589
cases slightly improve

00:42:56,960 --> 00:43:03,320
more common cases and then the corner

00:43:00,589 --> 00:43:06,170
case it said we took a challenging

00:43:03,320 --> 00:43:07,490
problem that had many specifications to

00:43:06,170 --> 00:43:09,500
it and boiled it down to something

00:43:07,490 --> 00:43:11,060
simple and I hope I presented a

00:43:09,500 --> 00:43:13,210
compelling set of use cases in our

00:43:11,060 --> 00:43:16,070
tutorial for you how did I do

00:43:13,210 --> 00:43:19,369
[Applause]

00:43:16,070 --> 00:43:19,369
[Music]

00:43:20,430 --> 00:43:24,839
the challenge for you now is that was a

00:43:22,890 --> 00:43:26,490
nice round of applause I challenge you

00:43:24,839 --> 00:43:28,140
to do better I'd like you to double that

00:43:26,490 --> 00:43:31,700
for the person who actually did all the

00:43:28,140 --> 00:43:31,700
work Eric do you want to come up with me

00:43:32,650 --> 00:43:43,980
[Applause]

00:43:36,090 --> 00:43:46,440
you'll need a microphone so right Derek

00:43:43,980 --> 00:43:49,940
Smeath we have time for about one

00:43:46,440 --> 00:43:49,940
question so make it a good one

00:43:50,930 --> 00:43:56,700
hi Raymond thanks for the talk there's

00:43:54,840 --> 00:43:59,820
one thing I can do if I hand write that

00:43:56,700 --> 00:44:02,460
under in it I can make arguments key

00:43:59,820 --> 00:44:05,910
word only by putting in an Asterix in

00:44:02,460 --> 00:44:08,400
the function signature is there any

00:44:05,910 --> 00:44:11,070
support for that in declarative data

00:44:08,400 --> 00:44:13,410
clause I'll say no and then I will get

00:44:11,070 --> 00:44:16,920
the right answer there's not and part of

00:44:13,410 --> 00:44:19,260
the reason is because it has to be

00:44:16,920 --> 00:44:20,550
arguments for dunder init or the order

00:44:19,260 --> 00:44:25,170
you declare them it doesn't really

00:44:20,550 --> 00:44:26,700
necessarily make sense that that you

00:44:25,170 --> 00:44:28,710
somewhere in the list of fields you'd

00:44:26,700 --> 00:44:32,580
have to say oh and everything after here

00:44:28,710 --> 00:44:34,890
is keyword only and it also doesn't work

00:44:32,580 --> 00:44:36,540
well with inheritance where if you

00:44:34,890 --> 00:44:38,280
inherit from something that had only

00:44:36,540 --> 00:44:40,770
keyword arguments and everything you had

00:44:38,280 --> 00:44:42,210
would suddenly have to become keyword

00:44:40,770 --> 00:44:44,760
arguments if you have a data class

00:44:42,210 --> 00:44:46,830
inherits from another data class it adds

00:44:44,760 --> 00:44:51,000
that under an it to the child class it

00:44:46,830 --> 00:44:54,300
just depends all of the fields together

00:44:51,000 --> 00:44:55,710
on the inherited classes dunder init so

00:44:54,300 --> 00:44:57,840
it has to have everything in it because

00:44:55,710 --> 00:45:01,530
it doesn't call the base class executive

00:44:57,840 --> 00:45:02,790
summary it's harder than it looks all

00:45:01,530 --> 00:45:03,380
right let's give them one last round of

00:45:02,790 --> 00:45:09,249
applause

00:45:03,380 --> 00:45:09,249

YouTube URL: https://www.youtube.com/watch?v=T-TwcmT6Rcw


