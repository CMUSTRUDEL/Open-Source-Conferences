Title: Nicolle Cysneiros - Graph Databases: Talking about your Data Relationships with Python - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Nicolle Cysneiros

Have you ever considered how many relationships you have in your virtual life? Every friend or page liked on Facebook, each connection in LinkedIn or Twitter account followed is a new relationship not only between two people, but also between their data. In Brazil only, we have 160 millions Facebook users. How can we represent and manipulate all these relationships? Graph Databases are storage systems that use graph structure (nodes and edges) to represent and store data in a semantic way.

This talk will begin approaching the challenge in representing relationships in Relational Databases and introducing a more friendly solution using graph. The definition of Graph Database, its pros and cons and some available tools (Neo4J, OrientDB and TitanDB) will be shown during the presentation, as well as how these tools can be integrated with Python.


Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:01,159 --> 00:00:08,040
Nicole Cisneros is going to tell us

00:00:04,560 --> 00:00:21,900
about graph databases please help me

00:00:08,040 --> 00:00:25,680
give her a warm welcome a little Wilder

00:00:21,900 --> 00:00:29,070
okay sorry sorry if I sound a little bit

00:00:25,680 --> 00:00:31,980
nervous it's because I am this is my

00:00:29,070 --> 00:00:34,620
first PyCon so I'm really excited to be

00:00:31,980 --> 00:00:37,980
here thank you all for receiving me it's

00:00:34,620 --> 00:00:40,559
been amazing this experience before I've

00:00:37,980 --> 00:00:42,300
been to Europe Python last year in

00:00:40,559 --> 00:00:47,969
Rimini I don't know if anyone here was

00:00:42,300 --> 00:00:50,039
there no no not this really far but it

00:00:47,969 --> 00:00:54,090
was amazing too and I gave the same talk

00:00:50,039 --> 00:00:56,670
and I I always like to introduce graph

00:00:54,090 --> 00:00:58,379
databases to people I always find

00:00:56,670 --> 00:01:03,809
someone either in the audience that

00:00:58,379 --> 00:01:06,420
could use it in their application has

00:01:03,809 --> 00:01:08,850
anyone here heard about graph databases

00:01:06,420 --> 00:01:11,460
please it's Oh a lot of people that's

00:01:08,850 --> 00:01:16,200
great it's not like a new thing anymore

00:01:11,460 --> 00:01:17,880
it's like old news I guess but yeah I

00:01:16,200 --> 00:01:22,380
want to talk to you about graph

00:01:17,880 --> 00:01:25,049
databases and how these these two can

00:01:22,380 --> 00:01:27,960
help you with your data relationships in

00:01:25,049 --> 00:01:31,650
your application and my name is Nicola

00:01:27,960 --> 00:01:32,310
Cisneros if everyone is wondering so Who

00:01:31,650 --> 00:01:34,979
am I

00:01:32,310 --> 00:01:39,000
I am a full-stack developer at lab coats

00:01:34,979 --> 00:01:43,049
and I work mainly with Python and

00:01:39,000 --> 00:01:44,659
JavaScript we develop web solutions for

00:01:43,049 --> 00:01:47,700
our clients

00:01:44,659 --> 00:01:50,399
I'm also very I really like the

00:01:47,700 --> 00:01:53,909
community that's why we are all here I

00:01:50,399 --> 00:01:57,570
guess so I'm a member of a pile of the

00:01:53,909 --> 00:02:01,619
Python user group in Pernambuco and I am

00:01:57,570 --> 00:02:04,350
also pilotis in Recife I also helped

00:02:01,619 --> 00:02:06,270
organize jungle girls in my city it was

00:02:04,350 --> 00:02:08,970
really amazing the best experience ever

00:02:06,270 --> 00:02:11,590
we helped a lot of girls to get into

00:02:08,970 --> 00:02:13,510
coding it was really cool

00:02:11,590 --> 00:02:15,819
and leather coats is the company that I

00:02:13,510 --> 00:02:20,140
work for it's a software studio from

00:02:15,819 --> 00:02:23,319
Recife and we work as I said before we

00:02:20,140 --> 00:02:25,870
work with Python JavaScript we also work

00:02:23,319 --> 00:02:28,299
with elastic search some of the backend

00:02:25,870 --> 00:02:30,489
technologies and we work bringing

00:02:28,299 --> 00:02:32,830
solutions to our clients we are a

00:02:30,489 --> 00:02:34,989
software studio so our clients come up

00:02:32,830 --> 00:02:36,910
to us with a problem when we work with

00:02:34,989 --> 00:02:40,209
them through all the process since

00:02:36,910 --> 00:02:43,900
designing the solution and actually very

00:02:40,209 --> 00:02:46,420
deliberate that's our job and I work

00:02:43,900 --> 00:02:47,670
with this real cute nice people that I

00:02:46,420 --> 00:02:50,500
miss so much already

00:02:47,670 --> 00:02:52,840
and leather coats actually came from the

00:02:50,500 --> 00:02:56,290
community it was born in one of the pike

00:02:52,840 --> 00:02:59,379
homes in Brazil it was born in one of

00:02:56,290 --> 00:03:01,450
the one of the pecans in Brazil and we

00:02:59,379 --> 00:03:04,360
also like to give back so we are always

00:03:01,450 --> 00:03:07,510
at Pike homes in Brazil this is the

00:03:04,360 --> 00:03:11,260
second time that Renato is here in

00:03:07,510 --> 00:03:14,019
Python we we went to your own Python we

00:03:11,260 --> 00:03:16,750
are going to jungle Europe also so we

00:03:14,019 --> 00:03:18,670
also like I always like to get into the

00:03:16,750 --> 00:03:21,160
community it's really cool

00:03:18,670 --> 00:03:24,160
so I talked about about Recife

00:03:21,160 --> 00:03:27,010
Pernambuco you guys I think you didn't

00:03:24,160 --> 00:03:29,609
send anything I'm from Brazil and I

00:03:27,010 --> 00:03:32,920
traveled all the way from Recife to

00:03:29,609 --> 00:03:35,940
Cleveland that's Recife that's Cleveland

00:03:32,920 --> 00:03:41,470
it was a really long journey

00:03:35,940 --> 00:03:44,230
American Airlines didn't help but I was

00:03:41,470 --> 00:03:46,329
able to get here and it was really

00:03:44,230 --> 00:03:48,519
exciting so that's my CD it's in the

00:03:46,329 --> 00:03:51,599
northeast parts of Brazil it's really

00:03:48,519 --> 00:03:54,609
sunny it's really hot so I'm kind of

00:03:51,599 --> 00:03:57,700
getting cold here it's really cold for

00:03:54,609 --> 00:03:59,950
me when you receive we are really sunny

00:03:57,700 --> 00:04:02,349
and rainy sometimes but really funny

00:03:59,950 --> 00:04:04,690
most of the time it's a really nice city

00:04:02,349 --> 00:04:07,060
you should come visit please it's

00:04:04,690 --> 00:04:09,220
amazing give it give it a shout-out in

00:04:07,060 --> 00:04:12,519
there I walk you around really it's

00:04:09,220 --> 00:04:14,919
amazing so okay let's get to the

00:04:12,519 --> 00:04:16,660
presentation this is what I plan to talk

00:04:14,919 --> 00:04:20,140
to you about today about relationships

00:04:16,660 --> 00:04:21,849
and what it means with your data then we

00:04:20,140 --> 00:04:23,910
are going to go further into graph

00:04:21,849 --> 00:04:26,640
databases and

00:04:23,910 --> 00:04:28,740
I will introduce you to new 4j I guess

00:04:26,640 --> 00:04:31,380
all the people that raised their hands

00:04:28,740 --> 00:04:33,750
about web databases heard about neo4j

00:04:31,380 --> 00:04:35,760
right it's pretty common

00:04:33,750 --> 00:04:38,190
I'll give her a small comparison between

00:04:35,760 --> 00:04:41,520
u4j and relational databases for those

00:04:38,190 --> 00:04:43,400
who are not familiar with and then I

00:04:41,520 --> 00:04:50,900
will walk through some applications of

00:04:43,400 --> 00:04:55,080
graph databases so relationships so

00:04:50,900 --> 00:04:57,570
every whenever you are you become

00:04:55,080 --> 00:05:00,060
friends with someone on Facebook or you

00:04:57,570 --> 00:05:02,670
follow someone on Twitter or you're

00:05:00,060 --> 00:05:05,100
connected to someone in linking these

00:05:02,670 --> 00:05:10,890
creates a relationship between you and

00:05:05,100 --> 00:05:15,300
that person but not only in our real

00:05:10,890 --> 00:05:18,900
world but also visually your data is now

00:05:15,300 --> 00:05:21,630
connected to that other data like your

00:05:18,900 --> 00:05:24,900
profile data for free from Facebook is

00:05:21,630 --> 00:05:27,210
now connected it has a relationship now

00:05:24,900 --> 00:05:31,800
with the profile data of that other

00:05:27,210 --> 00:05:33,630
person so how can we manage this how can

00:05:31,800 --> 00:05:36,300
we manage all these connections that we

00:05:33,630 --> 00:05:39,780
have now in northern social networks

00:05:36,300 --> 00:05:42,480
that we have today what I'm going to

00:05:39,780 --> 00:05:45,990
propose here is more scenario a social

00:05:42,480 --> 00:05:51,840
network where a user can be friends with

00:05:45,990 --> 00:05:54,360
another user and like a page like

00:05:51,840 --> 00:05:56,550
Facebook like the the the some of the

00:05:54,360 --> 00:05:59,020
basic features of Facebook so let's

00:05:56,550 --> 00:06:00,140
imagine this scenario and let's try to

00:05:59,020 --> 00:06:04,370
[Music]

00:06:00,140 --> 00:06:06,900
organize this in a relational databases

00:06:04,370 --> 00:06:09,270
how many of you here have worked with

00:06:06,900 --> 00:06:13,290
relational databases like sequel

00:06:09,270 --> 00:06:15,090
post grace yeah great so you guys know

00:06:13,290 --> 00:06:18,300
that relational databases work with

00:06:15,090 --> 00:06:22,440
tables so let's create some tables to

00:06:18,300 --> 00:06:25,860
store our data from our social network

00:06:22,440 --> 00:06:28,110
let's say we will have a table called

00:06:25,860 --> 00:06:31,380
user that will store all the information

00:06:28,110 --> 00:06:33,280
about our users they have named ginger

00:06:31,380 --> 00:06:39,790
in gender

00:06:33,280 --> 00:06:44,080
eh maybe we also need another table to

00:06:39,790 --> 00:06:47,740
keep track of who is friend with you so

00:06:44,080 --> 00:06:51,070
we have that friends with table over

00:06:47,740 --> 00:06:53,860
there we also have pages in our social

00:06:51,070 --> 00:06:56,230
network so we have a table to store that

00:06:53,860 --> 00:06:58,690
information a page has name has category

00:06:56,230 --> 00:07:02,800
and also we would like to store the

00:06:58,690 --> 00:07:05,890
information of which user liked likes

00:07:02,800 --> 00:07:12,160
which page so we have another likes

00:07:05,890 --> 00:07:15,340
table over there sorry so okay now we

00:07:12,160 --> 00:07:18,130
have our users you have some pages so

00:07:15,340 --> 00:07:21,669
this is a pre-populated database so

00:07:18,130 --> 00:07:26,169
let's see what are the pages that the

00:07:21,669 --> 00:07:28,810
user with name John likes so to answer

00:07:26,169 --> 00:07:32,350
that question we have to go back here

00:07:28,810 --> 00:07:37,060
and get the ID for the user named John

00:07:32,350 --> 00:07:40,600
it's ID ID 1 and then we have to go to

00:07:37,060 --> 00:07:44,410
that other table called likes and check

00:07:40,600 --> 00:07:48,789
all the pages that have the ID one

00:07:44,410 --> 00:07:51,039
related with so we have two and one and

00:07:48,789 --> 00:07:53,800
then we have to go back to the table

00:07:51,039 --> 00:07:57,280
page and see which one are those so we

00:07:53,800 --> 00:08:01,539
have that John likes Coca Cola in the

00:07:57,280 --> 00:08:03,100
videos so we had to join to answer that

00:08:01,539 --> 00:08:06,340
question he had we had to join

00:08:03,100 --> 00:08:09,550
information from more than one table so

00:08:06,340 --> 00:08:12,310
we had to move from table to table so

00:08:09,550 --> 00:08:15,760
how can we improve this process it is

00:08:12,310 --> 00:08:18,669
possible to improve it it is that's the

00:08:15,760 --> 00:08:25,300
lead for us to get to know what grabs

00:08:18,669 --> 00:08:27,850
our graph is a data structure and this

00:08:25,300 --> 00:08:33,880
is the mathematical model of a graph

00:08:27,850 --> 00:08:38,490
graph is a graph G of any name is formed

00:08:33,880 --> 00:08:42,880
by a set of vertices and a set of edges

00:08:38,490 --> 00:08:46,990
so let me show you how our scenario

00:08:42,880 --> 00:08:52,340
would look using set of tables use

00:08:46,990 --> 00:08:55,160
vertices and edges so all the same data

00:08:52,340 --> 00:08:58,970
that we had before scattered around with

00:08:55,160 --> 00:09:04,630
Sables now we have in a graph and it's a

00:08:58,970 --> 00:09:08,360
more visual representation of our data

00:09:04,630 --> 00:09:12,010
the circles represent the vertices and

00:09:08,360 --> 00:09:17,410
the lines represent the edges the green

00:09:12,010 --> 00:09:23,360
circles are the users vertices and the

00:09:17,410 --> 00:09:26,540
red ones are represents the pages so we

00:09:23,360 --> 00:09:28,580
have this connection labeled friends

00:09:26,540 --> 00:09:35,590
with that indicates the relationship

00:09:28,580 --> 00:09:39,140
between two users or the the likes edge

00:09:35,590 --> 00:09:41,120
labeled that connects one user to a page

00:09:39,140 --> 00:09:44,120
two indicates that that user liked that

00:09:41,120 --> 00:09:46,670
page so if you want from here

00:09:44,120 --> 00:09:50,450
to check what are the pages that the

00:09:46,670 --> 00:09:52,670
user John likes we can just find the ad

00:09:50,450 --> 00:09:57,740
find the node with named John and then

00:09:52,670 --> 00:10:00,290
follow that path follow that edge to the

00:09:57,740 --> 00:10:02,660
pages that the user Joe max it's very

00:10:00,290 --> 00:10:08,270
visual you can see you can retrieve that

00:10:02,660 --> 00:10:10,820
information really directly so why not

00:10:08,270 --> 00:10:13,850
use this structure this visual structure

00:10:10,820 --> 00:10:16,820
that we have here why we are not why not

00:10:13,850 --> 00:10:18,800
use it to actually store your

00:10:16,820 --> 00:10:21,680
information for your application and

00:10:18,800 --> 00:10:22,780
that's where graph databases comes to

00:10:21,680 --> 00:10:25,940
the rescue

00:10:22,780 --> 00:10:29,150
so graph databases is just a system that

00:10:25,940 --> 00:10:32,570
stores data in graph structures which

00:10:29,150 --> 00:10:35,210
allows the expressed storage of the

00:10:32,570 --> 00:10:38,000
relationship between the data with this

00:10:35,210 --> 00:10:40,100
relationship very explicit like this

00:10:38,000 --> 00:10:43,640
with this connection with this line

00:10:40,100 --> 00:10:46,630
connecting the nodes we can get a direct

00:10:43,640 --> 00:10:50,150
information retrieval from our database

00:10:46,630 --> 00:10:55,670
there are also other advantages of graph

00:10:50,150 --> 00:10:58,940
databases they also allow more

00:10:55,670 --> 00:11:00,710
elaborated data analysis using common

00:10:58,940 --> 00:11:04,460
algorithms know

00:11:00,710 --> 00:11:08,030
in graph theory area how many of you

00:11:04,460 --> 00:11:12,880
have heard about graph theory or have

00:11:08,030 --> 00:11:16,520
studied algorithms that uses graphs as

00:11:12,880 --> 00:11:20,270
the data structure so yeah with this

00:11:16,520 --> 00:11:21,890
kind of research filled with these kinds

00:11:20,270 --> 00:11:24,020
of algorithms we can get some really

00:11:21,890 --> 00:11:27,440
good information from some really good

00:11:24,020 --> 00:11:30,080
knowledge from our data that using a

00:11:27,440 --> 00:11:33,320
relational database would become hard to

00:11:30,080 --> 00:11:37,720
do so we can get community detection we

00:11:33,320 --> 00:11:40,970
can have pattern recognition we can

00:11:37,720 --> 00:11:42,710
calculate some centrality measures by

00:11:40,970 --> 00:11:45,020
the end of the talk I'm going to give

00:11:42,710 --> 00:11:47,900
some examples some applications that

00:11:45,020 --> 00:11:52,240
used some of these algorithms that got

00:11:47,900 --> 00:11:55,100
some really nice insights from the data

00:11:52,240 --> 00:11:58,690
another advantage of graph database is

00:11:55,100 --> 00:12:01,580
that it has a flexible data model so

00:11:58,690 --> 00:12:04,220
they allow the insertion of new eighties

00:12:01,580 --> 00:12:09,260
new type of nodes new type of vertices

00:12:04,220 --> 00:12:12,260
new type of connections edges without

00:12:09,260 --> 00:12:14,420
the need to like redo all the databases

00:12:12,260 --> 00:12:18,280
so you have already existing database

00:12:14,420 --> 00:12:22,250
you then go in let's say we want to add

00:12:18,280 --> 00:12:24,380
if the concept of group in our social

00:12:22,250 --> 00:12:26,510
network that we had before we had user

00:12:24,380 --> 00:12:30,970
of pages and now you want to have groups

00:12:26,510 --> 00:12:33,320
group of discussion so here we have our

00:12:30,970 --> 00:12:39,530
existing database we then just need to

00:12:33,320 --> 00:12:42,470
add a new node say this node is of type

00:12:39,530 --> 00:12:47,540
group and then create a new relationship

00:12:42,470 --> 00:12:51,710
label that easy another difference is

00:12:47,540 --> 00:12:56,000
that the recent graph databases that we

00:12:51,710 --> 00:12:59,360
have in available today they perform

00:12:56,000 --> 00:13:04,760
using no sequel based start storage

00:12:59,360 --> 00:13:07,100
mechanisms so they are really good to -

00:13:04,760 --> 00:13:10,460
they're really good performing or reason

00:13:07,100 --> 00:13:13,880
service capability so you can have small

00:13:10,460 --> 00:13:16,850
machines more small cheaper machines

00:13:13,880 --> 00:13:20,060
in your database and we can get like a

00:13:16,850 --> 00:13:28,370
distributed processing of these this

00:13:20,060 --> 00:13:33,070
database in several machines okay so now

00:13:28,370 --> 00:13:35,480
we know what a graph databases is and

00:13:33,070 --> 00:13:38,810
I'm going to talk to you a little bit

00:13:35,480 --> 00:13:41,180
about new for J because it's a why did I

00:13:38,810 --> 00:13:43,940
choose new for J because it's the most

00:13:41,180 --> 00:13:47,390
popular graph database according to the

00:13:43,940 --> 00:13:49,100
D beings insight website this is a

00:13:47,390 --> 00:13:51,470
website that lists all the information

00:13:49,100 --> 00:13:54,260
about all the databases available today

00:13:51,470 --> 00:13:56,960
and it's the most popular graph

00:13:54,260 --> 00:13:59,480
databases that is known it is

00:13:56,960 --> 00:14:03,290
implemented in Java and it has its own

00:13:59,480 --> 00:14:06,650
query language that cipher so those of

00:14:03,290 --> 00:14:08,510
you who are used to work with relation

00:14:06,650 --> 00:14:13,190
that the database and you know sequel I

00:14:08,510 --> 00:14:15,230
guess really well and so new fridge a it

00:14:13,190 --> 00:14:18,890
doesn't work with sequel it works with

00:14:15,230 --> 00:14:22,970
cipher in the data in that database can

00:14:18,890 --> 00:14:26,350
be access to a REST API or through Java

00:14:22,970 --> 00:14:29,480
API but we also have a libraries that

00:14:26,350 --> 00:14:35,390
manages this connection especially with

00:14:29,480 --> 00:14:38,740
fighter 2 so let's have let's take a

00:14:35,390 --> 00:14:42,320
look at some examples of creating a

00:14:38,740 --> 00:14:45,800
vertex or a node how we also call it you

00:14:42,320 --> 00:14:50,420
can call vertex or nodes how we would

00:14:45,800 --> 00:14:56,120
create a node in using cipher so we

00:14:50,420 --> 00:14:58,310
could submit this create a node this is

00:14:56,120 --> 00:15:02,720
this is the syntax to create a node and

00:14:58,310 --> 00:15:04,370
then we say after the the columns we say

00:15:02,720 --> 00:15:05,510
the type of that node and I'm saying

00:15:04,370 --> 00:15:07,600
that the type of this load that I'm

00:15:05,510 --> 00:15:11,120
creating is the type of user and

00:15:07,600 --> 00:15:12,710
following that I can pass all the

00:15:11,120 --> 00:15:16,340
parameters that I want I want to create

00:15:12,710 --> 00:15:18,950
them with a name with gender with age I

00:15:16,340 --> 00:15:21,380
could create them with social security

00:15:18,950 --> 00:15:25,800
number with whatever you want you can

00:15:21,380 --> 00:15:28,960
pass all the properties that a user has

00:15:25,800 --> 00:15:30,970
between the bristles and then here I'm

00:15:28,960 --> 00:15:34,060
just asking to return the note so I can

00:15:30,970 --> 00:15:38,380
see that it actually created so once you

00:15:34,060 --> 00:15:40,390
install new 4j on your machine you we

00:15:38,380 --> 00:15:42,610
have like a community version of it and

00:15:40,390 --> 00:15:45,090
you can install for free and play around

00:15:42,610 --> 00:15:49,750
with it as soon as you do that and you

00:15:45,090 --> 00:15:52,060
run it it will open a browser interface

00:15:49,750 --> 00:15:54,790
for you to play around and so we need

00:15:52,060 --> 00:15:56,800
some cipher queries so if you submit

00:15:54,790 --> 00:16:02,400
this query then this is the result that

00:15:56,800 --> 00:16:04,840
you would get you will get this is the

00:16:02,400 --> 00:16:07,030
graphic interface for neo4j it's really

00:16:04,840 --> 00:16:08,440
really nice and you can see all the

00:16:07,030 --> 00:16:09,040
notes and this is the note that we just

00:16:08,440 --> 00:16:14,590
created

00:16:09,040 --> 00:16:17,020
it's an old name for the user job that's

00:16:14,590 --> 00:16:21,160
simple but how we would receive that we

00:16:17,020 --> 00:16:26,490
if we want to create through the API so

00:16:21,160 --> 00:16:29,350
we would receive a JSON object back and

00:16:26,490 --> 00:16:32,590
inside of this JSON we have a graph

00:16:29,350 --> 00:16:35,020
object that lists all the nodes and all

00:16:32,590 --> 00:16:38,950
the relationships that we have in our

00:16:35,020 --> 00:16:41,590
database so our database was empty and

00:16:38,950 --> 00:16:47,800
now it has only one node that's for the

00:16:41,590 --> 00:16:50,440
user job so now let's create a

00:16:47,800 --> 00:16:52,780
relationship let's say that I have

00:16:50,440 --> 00:16:55,540
already two nodes in my database one

00:16:52,780 --> 00:16:56,680
called one for the user John and another

00:16:55,540 --> 00:16:59,590
for the user Mary

00:16:56,680 --> 00:17:03,310
so first I'm retrieving I'm matching

00:16:59,590 --> 00:17:06,310
these nodes that's the keyword match

00:17:03,310 --> 00:17:09,339
over there and I'm getting those two

00:17:06,310 --> 00:17:12,040
nodes that are for the type user and I

00:17:09,339 --> 00:17:14,140
want the first one to match the user

00:17:12,040 --> 00:17:18,160
with name John and the second one to

00:17:14,140 --> 00:17:21,640
match with the user with name Eric once

00:17:18,160 --> 00:17:24,670
I had those nodes retrieved I can then

00:17:21,640 --> 00:17:28,060
create a relationship and label this

00:17:24,670 --> 00:17:30,460
relationship with the label friends with

00:17:28,060 --> 00:17:34,180
to indicate that John is friends with

00:17:30,460 --> 00:17:37,780
Mary and I am returning the result of

00:17:34,180 --> 00:17:39,100
this relationship so before we had those

00:17:37,780 --> 00:17:41,200
two nodes separate

00:17:39,100 --> 00:17:43,510
you know you know database you could

00:17:41,200 --> 00:17:48,970
also access them but now we created a

00:17:43,510 --> 00:17:56,160
relationship between them having this

00:17:48,970 --> 00:18:02,590
edge that goes from one to another sorry

00:17:56,160 --> 00:18:04,630
and as a mission before we can have JSON

00:18:02,590 --> 00:18:09,039
object as written when we access them

00:18:04,630 --> 00:18:13,240
through the REST API and now our graph

00:18:09,039 --> 00:18:18,100
object has two nodes in regulation ship

00:18:13,240 --> 00:18:22,600
in the list of our JSON object that's

00:18:18,100 --> 00:18:24,700
when we call so now I loaded all the

00:18:22,600 --> 00:18:26,590
data that we had before in those tables

00:18:24,700 --> 00:18:30,309
in that first scenario that I showed you

00:18:26,590 --> 00:18:33,250
and I loaded everything too new for J

00:18:30,309 --> 00:18:36,730
and this is what our database looks like

00:18:33,250 --> 00:18:38,650
now we have three users and three pages

00:18:36,730 --> 00:18:42,370
and other relationships between them and

00:18:38,650 --> 00:18:45,850
now we want to ask the question what are

00:18:42,370 --> 00:18:48,070
the pages that the user Jeong likes how

00:18:45,850 --> 00:18:52,330
he would retrieve that information so we

00:18:48,070 --> 00:18:55,030
match the node user that has the name

00:18:52,330 --> 00:18:57,370
John and then I want to get all the

00:18:55,030 --> 00:19:02,650
pages that are connected to that node

00:18:57,370 --> 00:19:07,960
with the label likes and then I'm

00:19:02,650 --> 00:19:11,590
returning this so this is the result I

00:19:07,960 --> 00:19:14,620
can get that information pretty easy and

00:19:11,590 --> 00:19:16,780
I can look I have a visual

00:19:14,620 --> 00:19:19,809
representation of that question that I

00:19:16,780 --> 00:19:24,460
was asking the user John and the pages

00:19:19,809 --> 00:19:28,570
that he likes in our the the REST API

00:19:24,460 --> 00:19:30,669
would return a JSON like this with an

00:19:28,570 --> 00:19:35,500
object data that would return all the

00:19:30,669 --> 00:19:38,860
rows for our for our query so the first

00:19:35,500 --> 00:19:41,230
one is from John to PTO's the page

00:19:38,860 --> 00:19:46,780
beatles and the other one is from john

00:19:41,230 --> 00:19:49,740
to the page coca-cola okay but this is

00:19:46,780 --> 00:19:53,220
fine it is school to play around with

00:19:49,740 --> 00:19:57,990
just checking how the future works but

00:19:53,220 --> 00:20:01,530
how could we integrate neo4j these

00:19:57,990 --> 00:20:04,170
databases to our to our Python

00:20:01,530 --> 00:20:09,270
application so this is where PI to New

00:20:04,170 --> 00:20:11,790
York comes to comes in handy so pipe

00:20:09,270 --> 00:20:14,340
pipe to new is a Python module that

00:20:11,790 --> 00:20:17,640
works with new 4j from applications or

00:20:14,340 --> 00:20:21,300
fro common line it supports both by two

00:20:17,640 --> 00:20:22,559
two and three and supports oh sorry it's

00:20:21,300 --> 00:20:27,750
a type of there and see pythons

00:20:22,559 --> 00:20:29,429
distributions so now let's try to

00:20:27,750 --> 00:20:31,679
recreate those examples that I showed

00:20:29,429 --> 00:20:34,890
you we use the cypher now how you would

00:20:31,679 --> 00:20:38,100
do the same thing using the page to

00:20:34,890 --> 00:20:40,620
narrow using Python to do that so here

00:20:38,100 --> 00:20:42,960
I'm accessing the graph and I'm past the

00:20:40,620 --> 00:20:45,440
password over there and then I start a

00:20:42,960 --> 00:20:48,300
transaction just as we would do

00:20:45,440 --> 00:20:51,929
transactions in regular relational

00:20:48,300 --> 00:20:55,340
database so we start a transaction in

00:20:51,929 --> 00:20:58,020
the net we create a node object telling

00:20:55,340 --> 00:21:01,050
passing what's the type of that node and

00:20:58,020 --> 00:21:03,059
then all the parameters that the nodes

00:21:01,050 --> 00:21:05,520
should should have and then we create a

00:21:03,059 --> 00:21:06,990
node and then we commit all the changes

00:21:05,520 --> 00:21:09,750
that we have done before in the

00:21:06,990 --> 00:21:12,350
transaction and it gets pushed to the

00:21:09,750 --> 00:21:17,150
database and now our node is created

00:21:12,350 --> 00:21:20,160
same same similar thing happens with

00:21:17,150 --> 00:21:22,740
create relationships suppose that we

00:21:20,160 --> 00:21:24,690
have already unknown name John in a node

00:21:22,740 --> 00:21:29,520
named Mary and then we just create a

00:21:24,690 --> 00:21:33,030
relationship object with this two of

00:21:29,520 --> 00:21:33,720
these two nodes objects and give a label

00:21:33,030 --> 00:21:36,150
to it

00:21:33,720 --> 00:21:39,960
that's friends with and then push all

00:21:36,150 --> 00:21:42,929
the changes to the database and how

00:21:39,960 --> 00:21:44,640
would we answer that question to get the

00:21:42,929 --> 00:21:45,929
information of what are the pages that

00:21:44,640 --> 00:21:48,929
the users relax

00:21:45,929 --> 00:21:56,040
we can have this node node selector

00:21:48,929 --> 00:21:58,230
object and then we can select node based

00:21:56,040 --> 00:22:01,140
on the label and on one of the

00:21:58,230 --> 00:22:03,570
parameters of that label so from the

00:22:01,140 --> 00:22:05,879
selector we call their functions

00:22:03,570 --> 00:22:08,369
we passed what's the label of the note

00:22:05,879 --> 00:22:11,340
that we want to select from the database

00:22:08,369 --> 00:22:13,979
and we pass the parameter that we want

00:22:11,340 --> 00:22:16,649
to match so we want to match the user

00:22:13,979 --> 00:22:18,570
with name Jean and here since you can

00:22:16,649 --> 00:22:21,109
have more than one John in your database

00:22:18,570 --> 00:22:26,159
we are getting the first one that is

00:22:21,109 --> 00:22:28,559
returned by this list and then we are

00:22:26,159 --> 00:22:29,580
matching we are getting the graph and

00:22:28,559 --> 00:22:33,749
then we are matching

00:22:29,580 --> 00:22:37,200
oh the paths that goes from John that's

00:22:33,749 --> 00:22:40,529
John is the start node and goes through

00:22:37,200 --> 00:22:44,999
pets that are labeled as relationships

00:22:40,529 --> 00:22:48,479
likes so we are getting all the eight

00:22:44,999 --> 00:22:51,599
nodes that are at the end of this path

00:22:48,479 --> 00:22:54,090
and over there I'm just going over these

00:22:51,599 --> 00:22:56,460
results in preteen and this is what what

00:22:54,090 --> 00:23:01,049
you would get if run this program you

00:22:56,460 --> 00:23:03,720
would get two page objects and their

00:23:01,049 --> 00:23:09,929
properties the category in the name of

00:23:03,720 --> 00:23:12,239
the page so now that we are good we can

00:23:09,929 --> 00:23:14,340
start thinking about this not that

00:23:12,239 --> 00:23:17,039
complicated to start using yo for J

00:23:14,340 --> 00:23:21,779
there is a line curve to learn a little

00:23:17,039 --> 00:23:26,489
bit of cipher because it's not quite

00:23:21,779 --> 00:23:29,460
similar to sequel and we can integrate

00:23:26,489 --> 00:23:32,700
these to our Python applications use

00:23:29,460 --> 00:23:35,519
invite to know but let's compare

00:23:32,700 --> 00:23:39,929
actually new 4j with relational

00:23:35,519 --> 00:23:42,239
databases just the ones that has having

00:23:39,929 --> 00:23:44,519
the chance to work with neo4j has a

00:23:42,239 --> 00:23:48,690
better idea of the differences between

00:23:44,519 --> 00:23:50,460
them so I brought here the same same

00:23:48,690 --> 00:23:53,129
query that we've been working on the

00:23:50,460 --> 00:23:55,619
pages that user John all right show you

00:23:53,129 --> 00:23:58,769
this cipher query that we had at the

00:23:55,619 --> 00:24:01,919
beginning to line of code very easy very

00:23:58,769 --> 00:24:05,869
simple to retrieve but if you want to

00:24:01,919 --> 00:24:08,940
get the same information with sequel

00:24:05,869 --> 00:24:12,690
using that structure that we had before

00:24:08,940 --> 00:24:14,399
we would have to go through a lot of

00:24:12,690 --> 00:24:17,200
Northern Line codes

00:24:14,399 --> 00:24:20,880
to do that we you had to select

00:24:17,200 --> 00:24:26,679
from where do some table join over there

00:24:20,880 --> 00:24:29,710
to get this information so I mean sicko

00:24:26,679 --> 00:24:33,460
has more you have two to four more to

00:24:29,710 --> 00:24:36,279
get that information but this is not

00:24:33,460 --> 00:24:38,019
like this is really great to have cipher

00:24:36,279 --> 00:24:43,539
to help you retrieve that information

00:24:38,019 --> 00:24:46,720
but we have to be conscious of the pros

00:24:43,539 --> 00:24:51,309
and cons of using a graph database so

00:24:46,720 --> 00:24:57,490
for instance this is a experiment run by

00:24:51,309 --> 00:25:00,940
I think it was Mississippi University

00:24:57,490 --> 00:25:05,010
I'm not sure sorry but there is a link

00:25:00,940 --> 00:25:10,240
in the presentation to the article that

00:25:05,010 --> 00:25:12,789
released this this experiment and then

00:25:10,240 --> 00:25:18,190
what they did was they want to compare

00:25:12,789 --> 00:25:21,760
the time that one that Mexico and the OJ

00:25:18,190 --> 00:25:23,710
would perform to perform to two

00:25:21,760 --> 00:25:25,870
different kinds of queries one is a

00:25:23,710 --> 00:25:31,029
structured query that would be more like

00:25:25,870 --> 00:25:33,639
a death search into your data like going

00:25:31,029 --> 00:25:37,179
from node to node and the other one was

00:25:33,639 --> 00:25:40,990
just a data query like give me all the

00:25:37,179 --> 00:25:43,269
nodes that have this property above a

00:25:40,990 --> 00:25:47,470
threshold like a simple query that we do

00:25:43,269 --> 00:25:49,269
usually and here they show that for a

00:25:47,470 --> 00:25:53,370
structural query that the one that you

00:25:49,269 --> 00:25:53,370
need to navigate through your notes

00:25:55,529 --> 00:26:00,850
neo4j performed better because it took

00:25:58,690 --> 00:26:03,789
less time to respond to that query

00:26:00,850 --> 00:26:07,419
while my sequel you had this overhead of

00:26:03,789 --> 00:26:10,570
III I structural query on the other hand

00:26:07,419 --> 00:26:14,950
for data queries we see that neo4j

00:26:10,570 --> 00:26:17,110
falls way behind so my Seco is very

00:26:14,950 --> 00:26:21,450
optimal for this kind this kind of query

00:26:17,110 --> 00:26:24,580
so what you should pay attention to when

00:26:21,450 --> 00:26:27,100
deciding if you want to move to the

00:26:24,580 --> 00:26:29,770
graph databases or not is what kind of

00:26:27,100 --> 00:26:32,170
query are you going to be

00:26:29,770 --> 00:26:35,680
for me or what's the structure of your

00:26:32,170 --> 00:26:37,480
data in the real life if it makes sense

00:26:35,680 --> 00:26:40,480
for you to help them in the graph

00:26:37,480 --> 00:26:43,390
databases because you can't be like hype

00:26:40,480 --> 00:26:45,790
driven development right you need to to

00:26:43,390 --> 00:26:48,910
understand what the purpose of your

00:26:45,790 --> 00:26:51,970
application and other or else you could

00:26:48,910 --> 00:26:54,700
get something like this like you use

00:26:51,970 --> 00:26:57,250
graph databases but you do like data

00:26:54,700 --> 00:26:59,530
query that's not really optimal for

00:26:57,250 --> 00:27:03,010
neo4j and then your application

00:26:59,530 --> 00:27:07,390
performance goes down so that's my piece

00:27:03,010 --> 00:27:09,130
of advice for you guys so now that I

00:27:07,390 --> 00:27:11,200
talked everything let's see some

00:27:09,130 --> 00:27:13,360
applications I brought you two examples

00:27:11,200 --> 00:27:15,330
of applications using graph databases so

00:27:13,360 --> 00:27:19,270
you guys can have a better idea of where

00:27:15,330 --> 00:27:21,760
it's applicable first there are several

00:27:19,270 --> 00:27:23,950
areas that can benefit from graph

00:27:21,760 --> 00:27:25,990
databases a special social network

00:27:23,950 --> 00:27:28,990
that's the example that I'll be using

00:27:25,990 --> 00:27:31,000
during this presentation also

00:27:28,990 --> 00:27:34,630
bioinformatics I'm not from this area

00:27:31,000 --> 00:27:37,150
but I've known a lot of people that was

00:27:34,630 --> 00:27:40,660
to work like works with bioinformatics

00:27:37,150 --> 00:27:43,840
and really I could use graph database

00:27:40,660 --> 00:27:46,020
because molecules and particles are

00:27:43,840 --> 00:27:48,610
connected to each other and

00:27:46,020 --> 00:27:51,310
disconnection gives some information and

00:27:48,610 --> 00:27:54,190
that's important for them for their kind

00:27:51,310 --> 00:27:56,620
of research also genetic analysis this

00:27:54,190 --> 00:28:00,510
connection between the genes it's

00:27:56,620 --> 00:28:04,120
important to in communications like

00:28:00,510 --> 00:28:06,610
phone companies internet companies they

00:28:04,120 --> 00:28:09,670
could use this because they have verbs

00:28:06,610 --> 00:28:14,020
of communications and towers and they

00:28:09,670 --> 00:28:16,510
could see this information better in a

00:28:14,020 --> 00:28:19,000
graph database because they they could

00:28:16,510 --> 00:28:21,790
see the users that are connected to a

00:28:19,000 --> 00:28:25,410
certain herb in a certain proxy and they

00:28:21,790 --> 00:28:30,760
could manage better their network of

00:28:25,410 --> 00:28:33,070
towers basically so about to you two

00:28:30,760 --> 00:28:35,920
applications the first one is a really

00:28:33,070 --> 00:28:38,830
interesting one about corruption in

00:28:35,920 --> 00:28:43,720
Brazil I don't know if you guys know it

00:28:38,830 --> 00:28:45,909
but Brazil is really bad at our

00:28:43,720 --> 00:28:50,789
at these corruption perception index

00:28:45,909 --> 00:28:50,789
brought by Transparency International

00:28:51,000 --> 00:29:00,700
we are orange that means that as the

00:28:56,350 --> 00:29:03,159
more red the worst more corrupted the

00:29:00,700 --> 00:29:05,350
culture is so you see that Brazil is not

00:29:03,159 --> 00:29:08,080
that good it's really bad and there are

00:29:05,350 --> 00:29:12,789
worse there is this journalist in Brazil

00:29:08,080 --> 00:29:16,600
called Leonardo Salas and he wrote and

00:29:12,789 --> 00:29:20,100
he researched with the data to find out

00:29:16,600 --> 00:29:23,679
how the Congress Brazilian Congress is

00:29:20,100 --> 00:29:27,549
indirectly kind of contributing to

00:29:23,679 --> 00:29:31,299
deputies campaigns donation it's really

00:29:27,549 --> 00:29:34,240
interesting I did a link for this

00:29:31,299 --> 00:29:36,580
article it's in Portuguese but you can

00:29:34,240 --> 00:29:40,690
kind of see the images the images become

00:29:36,580 --> 00:29:44,799
further south for themselves so so what

00:29:40,690 --> 00:29:47,590
what this application is we have each

00:29:44,799 --> 00:29:50,740
Congress person in Brazil they receive a

00:29:47,590 --> 00:29:54,610
unique amount of money to pay for

00:29:50,740 --> 00:29:58,260
expenses related to parliamentary

00:29:54,610 --> 00:29:59,500
activities mark that that part

00:29:58,260 --> 00:30:02,230
exclusively

00:29:59,500 --> 00:30:05,289
parliamentary activities so they would

00:30:02,230 --> 00:30:07,659
pay for like I don't know some off

00:30:05,289 --> 00:30:10,510
supplies stuff like this that they need

00:30:07,659 --> 00:30:12,580
for their preliminary activity it's a

00:30:10,510 --> 00:30:17,049
lot of money trust me

00:30:12,580 --> 00:30:19,900
so what Leonardo did was he did analysis

00:30:17,049 --> 00:30:26,380
over all the congresses the Congress

00:30:19,900 --> 00:30:30,730
expenses from 2013 to 2017 and he cross

00:30:26,380 --> 00:30:35,320
related those expenses with the campaign

00:30:30,730 --> 00:30:38,890
donations for the deputies for the 2014

00:30:35,320 --> 00:30:41,559
election that we had in Brazil all this

00:30:38,890 --> 00:30:44,200
data he took is available at the

00:30:41,559 --> 00:30:47,740
Congress transparency portal in Brazil

00:30:44,200 --> 00:30:50,530
we have done pretty decent transparency

00:30:47,740 --> 00:30:54,760
portals for the public services that we

00:30:50,530 --> 00:30:57,830
have the data is not very well formed

00:30:54,760 --> 00:31:01,030
it's really hard to get some information

00:30:57,830 --> 00:31:04,700
if you guys are interesting this kind of

00:31:01,030 --> 00:31:07,010
this kind of analysis also to Rica's is

00:31:04,700 --> 00:31:09,620
one of the guys that are here they are

00:31:07,010 --> 00:31:12,320
he he gave a talk yesterday about these

00:31:09,620 --> 00:31:14,330
two and you can tweet him about this

00:31:12,320 --> 00:31:15,710
because he really knows how to get this

00:31:14,330 --> 00:31:18,320
information from distance for his

00:31:15,710 --> 00:31:20,720
supporters his work is amazing and he

00:31:18,320 --> 00:31:24,320
helps a lot of the journalists including

00:31:20,720 --> 00:31:28,670
this one and for this analysis Leonardo

00:31:24,320 --> 00:31:31,700
used Python with Network X it was not

00:31:28,670 --> 00:31:33,530
new 4G but it was network at X another

00:31:31,700 --> 00:31:36,890
Python library that you can just

00:31:33,530 --> 00:31:38,990
organize your data in a graph model but

00:31:36,890 --> 00:31:39,550
it's not a graph database it's just a

00:31:38,990 --> 00:31:43,310
memory

00:31:39,550 --> 00:31:48,080
so what long I do find out found out is

00:31:43,310 --> 00:31:52,250
that there are he found these circles in

00:31:48,080 --> 00:31:54,710
the graph that he had so sillas camera

00:31:52,250 --> 00:31:57,920
is one of the congressperson that we

00:31:54,710 --> 00:32:01,850
have in brazil and that huge number is

00:31:57,920 --> 00:32:07,100
the idea of a company and what happens

00:32:01,850 --> 00:32:11,410
is sillas got some donations from that

00:32:07,100 --> 00:32:16,190
company during the election of 2014 and

00:32:11,410 --> 00:32:18,200
after that he kind of paid back the

00:32:16,190 --> 00:32:23,800
donation that he received a lot more

00:32:18,200 --> 00:32:27,920
actually paid back to the company as and

00:32:23,800 --> 00:32:32,030
it was paid using public money through

00:32:27,920 --> 00:32:36,530
the congress expenses kind of thing so

00:32:32,030 --> 00:32:39,560
he find out these using graph graph

00:32:36,530 --> 00:32:41,180
analysis in a graph structure that he

00:32:39,560 --> 00:32:43,010
had this data

00:32:41,180 --> 00:32:46,160
he also find out another kind of

00:32:43,010 --> 00:32:48,650
structure where one Congress person got

00:32:46,160 --> 00:32:50,780
the nation from one company then done

00:32:48,650 --> 00:32:53,300
they then paid back using Congress

00:32:50,780 --> 00:32:56,420
expenses to another company but that

00:32:53,300 --> 00:32:58,580
other company donated to another

00:32:56,420 --> 00:33:01,550
Congress person and that that Congress

00:32:58,580 --> 00:33:03,710
person paid back to the first company so

00:33:01,550 --> 00:33:06,260
they kind of not directly it was in

00:33:03,710 --> 00:33:08,090
direct leads so this is kind of an

00:33:06,260 --> 00:33:10,820
interesting result for us to see that

00:33:08,090 --> 00:33:12,380
actually the the donation that our

00:33:10,820 --> 00:33:15,399
they are receiving it's kind of paid

00:33:12,380 --> 00:33:18,080
back with our money with Texas money

00:33:15,399 --> 00:33:20,899
that's not good so it was a really

00:33:18,080 --> 00:33:23,570
interesting analysis that he did using a

00:33:20,899 --> 00:33:27,500
graphic structure for his data which was

00:33:23,570 --> 00:33:32,419
really good but let's talk about some

00:33:27,500 --> 00:33:33,649
other applications not as serious as

00:33:32,419 --> 00:33:36,289
this one it was a really good

00:33:33,649 --> 00:33:39,230
application but from it's really serious

00:33:36,289 --> 00:33:42,380
it's worth it Game of Thrones some

00:33:39,230 --> 00:33:45,950
really serious come on and this is

00:33:42,380 --> 00:33:48,139
really interesting there was these two

00:33:45,950 --> 00:33:51,409
guys yeah I I think you guys heard of it

00:33:48,139 --> 00:33:54,679
it was pretty big graph of drones

00:33:51,409 --> 00:33:56,830
the guy the guys found it amazing so

00:33:54,679 --> 00:34:01,330
these two guys called a new beverage is

00:33:56,830 --> 00:34:04,730
just shun-chan sorry I mispronounce it

00:34:01,330 --> 00:34:08,690
they kind of analyzed a network formed

00:34:04,730 --> 00:34:12,399
by all the characters of I Storm of

00:34:08,690 --> 00:34:18,260
Swords the third book in the series and

00:34:12,399 --> 00:34:20,300
what they did was they find out all the

00:34:18,260 --> 00:34:23,899
the interactions between characters of

00:34:20,300 --> 00:34:26,510
the book and gave a weight like if two

00:34:23,899 --> 00:34:29,629
characters just said like hi it was like

00:34:26,510 --> 00:34:33,429
a small weight it was not that big but

00:34:29,629 --> 00:34:37,490
it was like German Daenerys they kind of

00:34:33,429 --> 00:34:39,919
went down to it the last season so they

00:34:37,490 --> 00:34:44,300
the way it would be really big I would

00:34:39,919 --> 00:34:46,310
say so those guys did this to all the

00:34:44,300 --> 00:34:48,829
characters of the third book it's like

00:34:46,310 --> 00:34:50,929
an amazing work and they had a table

00:34:48,829 --> 00:34:52,250
like this with the sauce the target in

00:34:50,929 --> 00:34:55,940
the weight of the relationship between

00:34:52,250 --> 00:34:59,690
these characters and William Ian he

00:34:55,940 --> 00:35:02,630
loaded the data to neo4j and ran some

00:34:59,690 --> 00:35:04,849
analysis onto it it was really good and

00:35:02,630 --> 00:35:07,490
this is a also there is a link to the

00:35:04,849 --> 00:35:10,010
article of William Lyon that where he

00:35:07,490 --> 00:35:15,079
showed his work it's really good I

00:35:10,010 --> 00:35:17,660
recommend you to read it so what what

00:35:15,079 --> 00:35:19,790
William used was I graph a graph is a

00:35:17,660 --> 00:35:21,859
Python module that allows graph

00:35:19,790 --> 00:35:23,460
manipulation using known algorithms such

00:35:21,859 --> 00:35:26,849
as centrality measures

00:35:23,460 --> 00:35:31,140
in community detection so what he did is

00:35:26,849 --> 00:35:35,220
he loaded all the data to neo4j and then

00:35:31,140 --> 00:35:38,369
he retrieved that data using a graph and

00:35:35,220 --> 00:35:43,530
then ran some algorithms some analysis

00:35:38,369 --> 00:35:46,260
using the i graph facility so this is

00:35:43,530 --> 00:35:48,530
the code that I took the some kind of

00:35:46,260 --> 00:35:51,420
the code that I took from here and then

00:35:48,530 --> 00:35:53,790
what he did is he ran this query

00:35:51,420 --> 00:35:57,930
decipher query that now we know it's a

00:35:53,790 --> 00:36:01,170
cipher query here in that two neo4j and

00:35:57,930 --> 00:36:06,869
then we he retrieved all the data and

00:36:01,170 --> 00:36:09,780
then he ran a i graph method called

00:36:06,869 --> 00:36:14,819
community work trap to kind of detect

00:36:09,780 --> 00:36:17,750
all the communities of the the of the

00:36:14,819 --> 00:36:21,450
graph and they created some clusters and

00:36:17,750 --> 00:36:24,930
this is the these are the cursors that

00:36:21,450 --> 00:36:27,359
he found so he named it the first

00:36:24,930 --> 00:36:30,990
cluster number one number two and so on

00:36:27,359 --> 00:36:32,760
and then the output would be a list of

00:36:30,990 --> 00:36:37,890
all the characters that belongs to that

00:36:32,760 --> 00:36:41,069
cluster of course these for the ones who

00:36:37,890 --> 00:36:44,760
already studied graph theory they know

00:36:41,069 --> 00:36:46,680
that's not always precise this kind of

00:36:44,760 --> 00:36:49,559
algorithms is not very deterministic

00:36:46,680 --> 00:36:53,309
sometimes and of course we have like one

00:36:49,559 --> 00:36:55,349
cell over there by himself in a separate

00:36:53,309 --> 00:36:59,819
cluster but this is like an outliner

00:36:55,349 --> 00:37:01,650
it's not it's not quite correct but the

00:36:59,819 --> 00:37:05,099
other ones you guys will see the results

00:37:01,650 --> 00:37:07,109
that he got from it and then after he

00:37:05,099 --> 00:37:10,500
did this community detection he also

00:37:07,109 --> 00:37:12,059
used the weight of the relationship

00:37:10,500 --> 00:37:16,170
between the characters to come up with

00:37:12,059 --> 00:37:18,930
this graph that he created and it's

00:37:16,170 --> 00:37:22,140
amazing because each color represents a

00:37:18,930 --> 00:37:24,410
cluster we have like low so over over

00:37:22,140 --> 00:37:29,069
that down there alone by himself and

00:37:24,410 --> 00:37:30,930
also we have the size of the nodes the

00:37:29,069 --> 00:37:33,809
size of the nodes represent the

00:37:30,930 --> 00:37:36,839
centrality measure of that character so

00:37:33,809 --> 00:37:41,789
it's kind the degree of importance of

00:37:36,839 --> 00:37:47,180
character and the thickness of the edge

00:37:41,789 --> 00:37:49,589
between two nodes represent the the

00:37:47,180 --> 00:37:52,049
weight of the relationship between those

00:37:49,589 --> 00:37:53,880
characters so here for the most who

00:37:52,049 --> 00:37:56,609
watch Game of Thrones can realize that

00:37:53,880 --> 00:38:00,359
this green part here is the like

00:37:56,609 --> 00:38:07,739
Daenerys cluster we have Daenerys we

00:38:00,359 --> 00:38:11,339
have Vasari's Rhaegar we have Jorah miss

00:38:07,739 --> 00:38:13,559
Yura and then we have blue one this Jon

00:38:11,339 --> 00:38:17,549
it's over there so the people from the

00:38:13,559 --> 00:38:21,119
the wall and over there the the yellow

00:38:17,549 --> 00:38:23,130
one is all the mass in the in the

00:38:21,119 --> 00:38:25,829
kingdom like we have Roberts we have

00:38:23,130 --> 00:38:29,279
Tyrone we have other the people in the

00:38:25,829 --> 00:38:31,410
city so that's really amazing work in

00:38:29,279 --> 00:38:35,670
sevilla bo in the english there i shared

00:38:31,410 --> 00:38:37,529
over there and yeah i guess that's it

00:38:35,670 --> 00:38:38,390
thank you very much for listening and um

00:38:37,529 --> 00:38:48,159
questions

00:38:38,390 --> 00:38:48,159
[Applause]

00:38:50,839 --> 00:38:56,329
we still have a few minutes for

00:38:52,880 --> 00:38:59,829
questions if you have any question

00:38:56,329 --> 00:39:08,329
please stop step up to the mic and ask

00:38:59,829 --> 00:39:11,390
your question hi thank you for a

00:39:08,329 --> 00:39:15,589
wonderful presentation Nicole so I

00:39:11,390 --> 00:39:17,150
happen to use Arango DB in a cluster at

00:39:15,589 --> 00:39:19,430
a large enterprise

00:39:17,150 --> 00:39:21,320
I consider neo4j but I was disappointed

00:39:19,430 --> 00:39:24,230
that their Community Edition didn't

00:39:21,320 --> 00:39:26,530
happen to support cluster deployment

00:39:24,230 --> 00:39:29,599
have you used it in that context before

00:39:26,530 --> 00:39:32,800
no I haven't I haven't had a chance to

00:39:29,599 --> 00:39:35,690
use new Fuji like for production

00:39:32,800 --> 00:39:38,599
environments like to scale it up I

00:39:35,690 --> 00:39:40,400
haven't but I actually have heard that

00:39:38,599 --> 00:39:42,920
it's really difficult as I mentioned

00:39:40,400 --> 00:39:45,349
I've heard some other people comments to

00:39:42,920 --> 00:39:48,500
me that it's kind of hard to get the

00:39:45,349 --> 00:39:50,500
support to do to do so yeah I really I'm

00:39:48,500 --> 00:39:54,170
really looking for it to come to this

00:39:50,500 --> 00:39:56,930
kind of situation where I should scale

00:39:54,170 --> 00:39:58,460
up to see if we have other options we I

00:39:56,930 --> 00:40:04,160
know that we have other options in the

00:39:58,460 --> 00:40:06,980
market we have we have Title II bit it's

00:40:04,160 --> 00:40:10,790
kind of dead now but it has like it it

00:40:06,980 --> 00:40:13,339
kind of shift but you can also go look

00:40:10,790 --> 00:40:15,550
for that and we have other options also

00:40:13,339 --> 00:40:19,369
in the market that may be the answer for

00:40:15,550 --> 00:40:24,950
for scaling up a database like this yeah

00:40:19,369 --> 00:40:27,230
but I haven't I have it sorry I want to

00:40:24,950 --> 00:40:28,670
say thank you for the talk and my

00:40:27,230 --> 00:40:30,470
questions related to if I want to move

00:40:28,670 --> 00:40:32,750
away from a relational database to a

00:40:30,470 --> 00:40:34,369
graph database do you have any

00:40:32,750 --> 00:40:37,550
recommendations for how to structure the

00:40:34,369 --> 00:40:39,410
data so that my data queries don't take

00:40:37,550 --> 00:40:47,119
as long I can spend more time making

00:40:39,410 --> 00:40:49,430
relation queries yeah so so you you

00:40:47,119 --> 00:40:54,079
wouldn't need to like organize your data

00:40:49,430 --> 00:40:57,280
and see what kind of really what kind of

00:40:54,079 --> 00:41:00,470
data you should import from

00:40:57,280 --> 00:41:04,250
from geo relational to your graph

00:41:00,470 --> 00:41:06,530
database maybe you could work with some

00:41:04,250 --> 00:41:08,780
if you really need to run some data

00:41:06,530 --> 00:41:10,760
query and it's a very common in your

00:41:08,780 --> 00:41:13,280
application but also structural query

00:41:10,760 --> 00:41:16,040
maybe we could use some kind of

00:41:13,280 --> 00:41:18,050
duplication mechanisms so you can also

00:41:16,040 --> 00:41:20,090
keep track of everything and make

00:41:18,050 --> 00:41:23,360
everything like duplicate but in sync

00:41:20,090 --> 00:41:27,830
and then go through and go to another if

00:41:23,360 --> 00:41:29,510
the data query does not really push down

00:41:27,830 --> 00:41:32,420
your performance of our application

00:41:29,510 --> 00:41:34,310
if some times then I think loads

00:41:32,420 --> 00:41:37,160
everything to neo4j and then use it

00:41:34,310 --> 00:41:39,320
there but if you really test and see

00:41:37,160 --> 00:41:41,480
that the performance is going down then

00:41:39,320 --> 00:41:44,240
I think duplicate and then work with

00:41:41,480 --> 00:41:46,610
some mechanisms to sync everything up so

00:41:44,240 --> 00:41:48,440
you can run your analysis in the graph

00:41:46,610 --> 00:41:50,030
that's really common - like you have

00:41:48,440 --> 00:41:51,950
your operational database in a

00:41:50,030 --> 00:41:53,690
relational database and then some time

00:41:51,950 --> 00:41:55,970
to time you load everything to a new

00:41:53,690 --> 00:41:57,410
fridge a run your analysis get your

00:41:55,970 --> 00:42:00,230
information get your knowledge in you

00:41:57,410 --> 00:42:04,660
and then keep leaving like this so you

00:42:00,230 --> 00:42:07,850
you have the - two sets of information

00:42:04,660 --> 00:42:12,110
all right thank you so much thank you um

00:42:07,850 --> 00:42:13,910
I noticed that neo4j has its own query

00:42:12,110 --> 00:42:16,910
language cipher is that that's what you

00:42:13,910 --> 00:42:20,600
had said yes yeah are you noticing a

00:42:16,910 --> 00:42:22,870
trend of different graph databases to

00:42:20,600 --> 00:42:27,260
make their own query language or to

00:42:22,870 --> 00:42:30,440
prefer other API such as I'm you know

00:42:27,260 --> 00:42:32,600
native language API that Java and rest

00:42:30,440 --> 00:42:34,970
api type thing or is there some sort of

00:42:32,600 --> 00:42:39,260
sort of hopeful trend towards a more

00:42:34,970 --> 00:42:40,910
structured sort of approach to a general

00:42:39,260 --> 00:42:45,740
query language that can work for graph

00:42:40,910 --> 00:42:48,590
databases in general yeah actually a lot

00:42:45,740 --> 00:42:51,440
of people went from like rejecting

00:42:48,590 --> 00:42:54,170
sequel all the way with the no sequel

00:42:51,440 --> 00:42:56,600
movement and now we see that there is a

00:42:54,170 --> 00:42:59,810
lot of new solutions that try to come up

00:42:56,600 --> 00:43:02,600
with sequel again so like they are

00:42:59,810 --> 00:43:04,700
trying to go back to sickle and I and I

00:43:02,600 --> 00:43:07,040
understand because either way you would

00:43:04,700 --> 00:43:10,460
need to learn cipher in cipher can have

00:43:07,040 --> 00:43:12,920
some pretty tricky parts for you too

00:43:10,460 --> 00:43:16,720
to run a query like perform ethically

00:43:12,920 --> 00:43:20,570
good and I see that there is a lot of

00:43:16,720 --> 00:43:22,760
shift towards sicko again I'm not sure

00:43:20,570 --> 00:43:24,619
if in graph databases we will come up to

00:43:22,760 --> 00:43:27,440
see one of these actually there is one

00:43:24,619 --> 00:43:31,099
that just missed the name I was trying

00:43:27,440 --> 00:43:33,050
to tell the guy that s about the scalene

00:43:31,099 --> 00:43:35,630
and therefore J you know just for God

00:43:33,050 --> 00:43:39,080
it's our goal to be oh my god I forgot

00:43:35,630 --> 00:43:41,810
yeah I got to be they have like these

00:43:39,080 --> 00:43:43,849
and the the query language that they use

00:43:41,810 --> 00:43:46,580
is really really similar to sicko it's

00:43:43,849 --> 00:43:50,060
basically sicko extended they just added

00:43:46,580 --> 00:43:53,420
a new keyword here and there to work

00:43:50,060 --> 00:43:55,640
with graphs and then use that so I see

00:43:53,420 --> 00:44:04,880
this kind of shift back to you sicko

00:43:55,640 --> 00:44:06,730
basically it's along the lines of some

00:44:04,880 --> 00:44:09,109
of the analyses that you're showing so

00:44:06,730 --> 00:44:10,609
with graph analysis with the graph

00:44:09,109 --> 00:44:12,800
database is coming out what are you

00:44:10,609 --> 00:44:15,380
really excited about and like along the

00:44:12,800 --> 00:44:17,420
lines of like analyses for the social

00:44:15,380 --> 00:44:21,230
good like the corruption analysis like

00:44:17,420 --> 00:44:23,359
what gets you really excited yeah so we

00:44:21,230 --> 00:44:27,050
we had this one it's really good

00:44:23,359 --> 00:44:30,589
ADA means it doesn't use a lot of facing

00:44:27,050 --> 00:44:32,960
algorithms but I also kind I did my

00:44:30,589 --> 00:44:34,730
Master's using graph databases and I was

00:44:32,960 --> 00:44:37,520
really excited about business

00:44:34,730 --> 00:44:40,940
intelligence using graph databases so

00:44:37,520 --> 00:44:43,580
all the vision of dimensions of your

00:44:40,940 --> 00:44:45,920
application like product and vendor and

00:44:43,580 --> 00:44:50,750
all the dimensions that we have in a

00:44:45,920 --> 00:44:55,700
company we could do some kind of use

00:44:50,750 --> 00:44:58,839
graph databases to run bi analysis in

00:44:55,700 --> 00:45:01,599
your data and also run these kind of

00:44:58,839 --> 00:45:05,570
centrality measure analysis and

00:45:01,599 --> 00:45:08,330
community analysis so my my research was

00:45:05,570 --> 00:45:10,640
to kind of join these tools like bi

00:45:08,330 --> 00:45:12,950
analysis and graph analysis and we can

00:45:10,640 --> 00:45:15,440
have everything to one application that

00:45:12,950 --> 00:45:19,339
could benefit from it so that's the best

00:45:15,440 --> 00:45:22,710
that that I went to kind of mix and

00:45:19,339 --> 00:45:25,730
match with graph analysis thank you

00:45:22,710 --> 00:45:31,219
Thank You Nicole we've helped me

00:45:25,730 --> 00:45:31,219

YouTube URL: https://www.youtube.com/watch?v=J8LvW-tyLRc


