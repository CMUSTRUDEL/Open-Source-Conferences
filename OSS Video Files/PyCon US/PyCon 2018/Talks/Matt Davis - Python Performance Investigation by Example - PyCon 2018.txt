Title: Matt Davis - Python Performance Investigation by Example - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Matt Davis

Occasionally we’ll find that some bit of Python we’ve written doesn’t run as fast as we’d like, what can we do? Performance bottlenecks aren’t always intuitive or easy to spot by reading code so we need to collect data with [profiling](https://docs.python.org/3.6/library/profile.html). Once we’ve identified the bottleneck we’ll need to change our approach, but what options are faster than others?

This talk illustrates a Python performance investigation and improvements using an [Advent of Code](http://www.adventofcode.com/) programming challenge. I’ll walk through starting from a slow (but correct) solution, look at profiling data to investigate _why_ it’s slow, and explore multiple paths for improving performance, including more efficient algorithms and using third-party tools like [Cython](http://cython.org/). You’ll leave this talk with a recipe for analyzing Python performance and information about some options for improved performance.

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:00,000 --> 00:00:07,919
welcome this is the last session of the

00:00:02,790 --> 00:00:10,200
day this is Matt Davis and he's talking

00:00:07,919 --> 00:00:20,010
about Python performance investigation

00:00:10,200 --> 00:00:22,680
by example thank you everyone for coming

00:00:20,010 --> 00:00:26,880
I appreciate you all being here this

00:00:22,680 --> 00:00:29,099
afternoon my name is Matt Davis I go by

00:00:26,880 --> 00:00:30,929
Jaffe Club on the internet because Matt

00:00:29,099 --> 00:00:34,110
Davis is an incredibly common name and

00:00:30,929 --> 00:00:35,670
it's impossible to find me I'm a data

00:00:34,110 --> 00:00:37,620
engineer at Clover health in San

00:00:35,670 --> 00:00:39,120
Francisco we're hiring we'll be at the

00:00:37,620 --> 00:00:41,610
job fair tomorrow if he'd like to come

00:00:39,120 --> 00:00:45,360
learn more a couple of links up there

00:00:41,610 --> 00:00:48,180
that the the github link will come up

00:00:45,360 --> 00:00:50,610
again at the end of the talk you're

00:00:48,180 --> 00:00:54,510
welcome to take photos and tweet them at

00:00:50,610 --> 00:00:57,930
me I would love that that we great so

00:00:54,510 --> 00:01:00,120
before we get started this is to talk

00:00:57,930 --> 00:01:02,399
about performance and I want to give a

00:01:00,120 --> 00:01:05,430
couple of caveats performance is a huge

00:01:02,399 --> 00:01:08,070
topic with tons of facets there are many

00:01:05,430 --> 00:01:10,020
ways that code can be slow and there are

00:01:08,070 --> 00:01:13,049
many ways that you can make it faster

00:01:10,020 --> 00:01:16,560
we're focused right here in this talk on

00:01:13,049 --> 00:01:18,930
I have a pretty small amount of Python

00:01:16,560 --> 00:01:22,619
code I would like it to be faster in

00:01:18,930 --> 00:01:24,150
isolation no systems no databases no

00:01:22,619 --> 00:01:28,049
networks anything like that

00:01:24,150 --> 00:01:30,270
that said the tools I'm going to show

00:01:28,049 --> 00:01:31,710
you will be useful in almost every

00:01:30,270 --> 00:01:34,619
problem you have at least at the

00:01:31,710 --> 00:01:37,650
beginning of the investigation and the

00:01:34,619 --> 00:01:40,500
process the recipe that I'm going to

00:01:37,650 --> 00:01:43,310
show is the number one thing I want you

00:01:40,500 --> 00:01:45,960
to take away from this so any

00:01:43,310 --> 00:01:48,149
performance investigation no matter what

00:01:45,960 --> 00:01:51,180
involved what is involved will be a

00:01:48,149 --> 00:01:53,850
scientific process you are going to

00:01:51,180 --> 00:01:55,829
collect data you are going to analyze

00:01:53,850 --> 00:01:57,869
that data and try to understand what is

00:01:55,829 --> 00:02:00,990
going on you're going to experiment

00:01:57,869 --> 00:02:03,840
change things and then you are going to

00:02:00,990 --> 00:02:06,420
collect data again and see if it works

00:02:03,840 --> 00:02:12,349
and you're going to do that until you're

00:02:06,420 --> 00:02:15,049
happy with things so a little backstory

00:02:12,349 --> 00:02:17,719
last year in December I was doing this

00:02:15,049 --> 00:02:20,959
thing called the advent of code where a

00:02:17,719 --> 00:02:22,700
person named Eric Wasel posted a

00:02:20,959 --> 00:02:26,239
programming challenge every day between

00:02:22,700 --> 00:02:27,920
December 1st and December 25th and there

00:02:26,239 --> 00:02:30,200
are a lot of fun you can you do them in

00:02:27,920 --> 00:02:33,920
any language I was using Python on day

00:02:30,200 --> 00:02:38,359
13 I was doing the problem I wrote some

00:02:33,920 --> 00:02:41,510
code it worked but it was real slow

00:02:38,359 --> 00:02:44,060
so I decided to make it faster and then

00:02:41,510 --> 00:02:45,980
make it faster again and so I ended up

00:02:44,060 --> 00:02:47,629
kind of doing this process and I thought

00:02:45,980 --> 00:02:49,069
it would be an interesting story it was

00:02:47,629 --> 00:02:50,900
really fun you can go and do it right

00:02:49,069 --> 00:02:52,340
now all the problems for the last couple

00:02:50,900 --> 00:02:53,870
of years are still up if you just want

00:02:52,340 --> 00:02:56,329
to go do some silly little programming

00:02:53,870 --> 00:03:00,200
challenges so I'll tell you about the

00:02:56,329 --> 00:03:02,359
one I was doing um there's a little

00:03:00,200 --> 00:03:04,879
packet in the lower left corner of this

00:03:02,359 --> 00:03:06,439
that wants to get across a firewall to

00:03:04,879 --> 00:03:09,230
the lower right corner

00:03:06,439 --> 00:03:11,000
following the bottom row there are these

00:03:09,230 --> 00:03:15,439
scanners in each of those colored

00:03:11,000 --> 00:03:17,479
columns going up and down and if you get

00:03:15,439 --> 00:03:19,819
caught if you move into a square while a

00:03:17,479 --> 00:03:22,489
scanner is there you're caught you

00:03:19,819 --> 00:03:24,979
didn't make it across and the the

00:03:22,489 --> 00:03:26,419
problem was to figure out how long you

00:03:24,979 --> 00:03:28,729
sit over there on the left

00:03:26,419 --> 00:03:30,620
doing nothing before you start crossing

00:03:28,729 --> 00:03:32,449
the firewall to get to the other side

00:03:30,620 --> 00:03:34,459
undetected because once you start moving

00:03:32,449 --> 00:03:40,069
you can't stop so you have to find this

00:03:34,459 --> 00:03:45,799
magical moment to get started we can see

00:03:40,069 --> 00:03:48,859
it in action here up in the top left

00:03:45,799 --> 00:03:50,720
corner is a counter of time steps each

00:03:48,859 --> 00:03:53,750
one is divided into two on the first

00:03:50,720 --> 00:03:57,319
phase the packet can move in the second

00:03:53,750 --> 00:04:00,409
phase the scanners move the solution in

00:03:57,319 --> 00:04:02,540
this example was is to wait for ten

00:04:00,409 --> 00:04:04,669
steps so on the tenth step it starts

00:04:02,540 --> 00:04:06,829
moving you'll notice it interacts with

00:04:04,669 --> 00:04:08,750
the scanner in the second column that

00:04:06,829 --> 00:04:11,750
was okay by the rules because it wasn't

00:04:08,750 --> 00:04:14,810
there when we moved into that square the

00:04:11,750 --> 00:04:17,769
actual problem that we're trying to

00:04:14,810 --> 00:04:20,659
solve involved a much bigger firewall

00:04:17,769 --> 00:04:24,700
with much deeper rows so a much more

00:04:20,659 --> 00:04:24,700
complex system than this example

00:04:25,939 --> 00:04:30,620
so I was thinking about the problem and

00:04:28,460 --> 00:04:33,590
the only thing I ever came up with the

00:04:30,620 --> 00:04:35,689
only solution I ever came up with was to

00:04:33,590 --> 00:04:38,659
brute force it to try to cross the

00:04:35,689 --> 00:04:40,759
firewall and see if I get caught and if

00:04:38,659 --> 00:04:42,740
I got caught to go back to the beginning

00:04:40,759 --> 00:04:45,169
advance the state of the firewall

00:04:42,740 --> 00:04:47,150
firewall by one step and try again and

00:04:45,169 --> 00:04:48,650
do that until I made it all the way

00:04:47,150 --> 00:04:51,770
across the firewall without getting

00:04:48,650 --> 00:04:53,569
caught so here's kind of the outline of

00:04:51,770 --> 00:04:56,930
that in code there's an infinite loop

00:04:53,569 --> 00:04:58,759
that's counting up from zero there's an

00:04:56,930 --> 00:05:02,060
if check that's saying did we get caught

00:04:58,759 --> 00:05:04,310
passing in so you'll notice a I have a

00:05:02,060 --> 00:05:06,979
firewall variable that represents like

00:05:04,310 --> 00:05:10,370
the firewall where they are and how big

00:05:06,979 --> 00:05:11,569
they are and then there's a break in

00:05:10,370 --> 00:05:14,659
there to get out of this infinite loop

00:05:11,569 --> 00:05:18,949
in the event that the clock crossing

00:05:14,659 --> 00:05:20,629
function returns false so when my first

00:05:18,949 --> 00:05:24,289
try I was like okay I'm gonna write a

00:05:20,629 --> 00:05:26,810
Class A Scanner class that represents

00:05:24,289 --> 00:05:29,120
these scanners moving up and down they

00:05:26,810 --> 00:05:31,789
know how big their ranges their vertical

00:05:29,120 --> 00:05:34,099
extent they know where they are within

00:05:31,789 --> 00:05:35,930
that extent their position they know if

00:05:34,099 --> 00:05:37,310
they're moving up or down because the

00:05:35,930 --> 00:05:39,919
scanners go up and then they turn around

00:05:37,310 --> 00:05:42,199
and go down and News knows how to move

00:05:39,919 --> 00:05:45,589
itself forward one step and it knows how

00:05:42,199 --> 00:05:47,659
to make a copy of itself and then I

00:05:45,589 --> 00:05:50,599
represent the firewall as a dictionary

00:05:47,659 --> 00:05:52,310
mapping the scanner position so the 0th

00:05:50,599 --> 00:05:55,279
position is the first scanner on the

00:05:52,310 --> 00:05:57,289
left and then 0 1 2 3 going forward not

00:05:55,279 --> 00:05:59,710
all positions have scanners and them

00:05:57,289 --> 00:06:02,120
some of them are empty and freebies and

00:05:59,710 --> 00:06:04,520
then each of those is a scanner with

00:06:02,120 --> 00:06:10,190
some state about what position that's in

00:06:04,520 --> 00:06:12,469
and so on oops by the way I'm gonna show

00:06:10,190 --> 00:06:14,449
you a lot of code in this talk it's not

00:06:12,469 --> 00:06:17,000
important that you read every line of it

00:06:14,449 --> 00:06:18,949
don't worry about that I will explain

00:06:17,000 --> 00:06:21,979
the important parts and you can go read

00:06:18,949 --> 00:06:23,509
it later so this is the first

00:06:21,979 --> 00:06:26,750
implementation of the clock Crossing

00:06:23,509 --> 00:06:28,669
function so it's there's a loop over the

00:06:26,750 --> 00:06:31,789
width of the firewall so going through

00:06:28,669 --> 00:06:33,529
every position for every position we

00:06:31,789 --> 00:06:35,659
check is there even a scanner there and

00:06:33,529 --> 00:06:37,169
if there is is the scanner in that

00:06:35,659 --> 00:06:39,479
bottom layer that we're crossing

00:06:37,169 --> 00:06:41,400
in the event that there is a scanner

00:06:39,479 --> 00:06:44,009
there we were caught right surance this

00:06:41,400 --> 00:06:46,319
function returns true down at the bottom

00:06:44,009 --> 00:06:47,729
is a return false so if we make it all

00:06:46,319 --> 00:06:49,379
the way through that loop without ever

00:06:47,729 --> 00:06:54,120
getting caught we were turned false we

00:06:49,379 --> 00:06:56,219
were never caught after every time we do

00:06:54,120 --> 00:06:58,259
a check for whether we were caught we

00:06:56,219 --> 00:07:00,629
had go through this firewall and

00:06:58,259 --> 00:07:02,610
advanced the state of every scanner

00:07:00,629 --> 00:07:04,939
one-step so that the next loop through

00:07:02,610 --> 00:07:08,759
everything is ready for the next check

00:07:04,939 --> 00:07:11,250
so you'll notice that we're changing the

00:07:08,759 --> 00:07:15,029
inputs here we're changing the firewall

00:07:11,250 --> 00:07:17,400
state so back up a level in this fine

00:07:15,029 --> 00:07:18,689
start function the clock crossing

00:07:17,400 --> 00:07:20,180
function we were just looking at is

00:07:18,689 --> 00:07:22,830
called kind of in the middle of this

00:07:20,180 --> 00:07:26,550
because that caught crossing function is

00:07:22,830 --> 00:07:30,599
changing the inputs I'm making a copy of

00:07:26,550 --> 00:07:33,629
the firewall before calling caught

00:07:30,599 --> 00:07:35,189
crossing so that in the event that it's

00:07:33,629 --> 00:07:37,080
caught I don't have to kind of read

00:07:35,189 --> 00:07:39,719
arrive the state of the firewall from

00:07:37,080 --> 00:07:42,210
step zero I can make a copy of the state

00:07:39,719 --> 00:07:44,039
before I did the check advance it one

00:07:42,210 --> 00:07:48,150
step and then try to make the crossing

00:07:44,039 --> 00:07:52,889
again so that's kind of the gist

00:07:48,150 --> 00:07:55,740
did it work it did the answer is you sit

00:07:52,889 --> 00:07:57,870
there for a bit over 3.8 million time

00:07:55,740 --> 00:08:02,430
steps and then you start to get across

00:07:57,870 --> 00:08:05,639
and you make it how long did it take it

00:08:02,430 --> 00:08:08,189
took around 1012 minutes to run through

00:08:05,639 --> 00:08:11,819
all of that in in different attempts

00:08:08,189 --> 00:08:15,029
that I made but hey you got the right

00:08:11,819 --> 00:08:18,659
answer so I do want to pause kind of

00:08:15,029 --> 00:08:20,669
there and think about that like if you

00:08:18,659 --> 00:08:28,139
write some code that gets the right

00:08:20,669 --> 00:08:30,569
answer that you can understand like good

00:08:28,139 --> 00:08:33,060
work that's not bad

00:08:30,569 --> 00:08:34,669
and certainly like in in this kind of

00:08:33,060 --> 00:08:38,699
environment

00:08:34,669 --> 00:08:42,029
nobody was timing me I could have moved

00:08:38,699 --> 00:08:45,510
on with my life at this point and in any

00:08:42,029 --> 00:08:46,920
situation you have where you're working

00:08:45,510 --> 00:08:48,690
on performance or thinking that

00:08:46,920 --> 00:08:50,850
something is slow it is worth like

00:08:48,690 --> 00:08:53,130
taking a deep breath and thinking like

00:08:50,850 --> 00:08:56,040
is this the best use of my time right

00:08:53,130 --> 00:08:58,440
now is this really slow because a lot of

00:08:56,040 --> 00:09:02,160
the time you might find that in fact you

00:08:58,440 --> 00:09:03,990
could have move on or you might kind of

00:09:02,160 --> 00:09:06,269
go down the path that we're gonna talk

00:09:03,990 --> 00:09:08,730
about and not really find any easy

00:09:06,269 --> 00:09:11,069
answers not find any easy solutions and

00:09:08,730 --> 00:09:13,079
again kind of be like is this really

00:09:11,069 --> 00:09:13,889
worth it or can I move on and things

00:09:13,079 --> 00:09:16,550
will be okay

00:09:13,889 --> 00:09:20,759
so don't be afraid to ask that question

00:09:16,550 --> 00:09:22,019
so we got into this point where we've

00:09:20,759 --> 00:09:24,300
got some code and we would like it to be

00:09:22,019 --> 00:09:26,850
faster and you know the story about the

00:09:24,300 --> 00:09:29,459
code so we got to collect data that's

00:09:26,850 --> 00:09:31,139
often called profiling we're gonna be

00:09:29,459 --> 00:09:33,329
using a tool called C profile that's

00:09:31,139 --> 00:09:36,569
built into Python it's in the standard

00:09:33,329 --> 00:09:39,269
library it tracks how much time is spent

00:09:36,569 --> 00:09:41,459
in functions that your code calls and

00:09:39,269 --> 00:09:44,459
you get a report afterwards we'll look

00:09:41,459 --> 00:09:46,139
at it that says this this function was

00:09:44,459 --> 00:09:48,259
called this many times when it was

00:09:46,139 --> 00:09:51,990
called this much time was spent in it

00:09:48,259 --> 00:09:53,490
both total and per call it's not the

00:09:51,990 --> 00:09:55,800
only tool out there there are a lot of

00:09:53,490 --> 00:09:57,480
them line profiler is cool because it

00:09:55,800 --> 00:10:00,750
will show you how much time was spent on

00:09:57,480 --> 00:10:03,630
individual lines of code these other

00:10:00,750 --> 00:10:05,639
tools on the right are meant to be low

00:10:03,630 --> 00:10:07,560
overhead profilers that you can run kind

00:10:05,639 --> 00:10:09,689
of in a production environment see

00:10:07,560 --> 00:10:11,550
profile and line profiler both out of

00:10:09,689 --> 00:10:14,000
quite a bit of overhead and slow down

00:10:11,550 --> 00:10:16,410
your code so they affect the execution

00:10:14,000 --> 00:10:18,689
so depending you might want to pick one

00:10:16,410 --> 00:10:21,360
of these other tools and even things

00:10:18,689 --> 00:10:23,850
like new relic honeycomb data dog

00:10:21,360 --> 00:10:25,410
logging can be used in performance

00:10:23,850 --> 00:10:28,290
investigation anything that gives you

00:10:25,410 --> 00:10:30,329
data about your code or your system but

00:10:28,290 --> 00:10:32,670
the important thing is you are

00:10:30,329 --> 00:10:34,439
collecting data and in a lot of

00:10:32,670 --> 00:10:35,970
situations like with C profile and this

00:10:34,439 --> 00:10:37,470
thing we're doing today we have we can

00:10:35,970 --> 00:10:39,389
collect data after the fact in

00:10:37,470 --> 00:10:42,360
production systems you have to think

00:10:39,389 --> 00:10:46,589
about this ahead of time and set up data

00:10:42,360 --> 00:10:48,269
collection beforehand so working with C

00:10:46,589 --> 00:10:49,939
profile these are my two favorite ways

00:10:48,269 --> 00:10:53,670
of running it one at the command line

00:10:49,939 --> 00:10:56,759
one I spend a lot of time in ipython via

00:10:53,670 --> 00:10:59,480
Jupiter so I like to use this magic

00:10:56,759 --> 00:11:01,960
magic command they call all of their

00:10:59,480 --> 00:11:06,730
special commands that start with print

00:11:01,960 --> 00:11:08,890
the % MAGIX that's actually the word so

00:11:06,730 --> 00:11:12,399
if you google like P run magic you'll

00:11:08,890 --> 00:11:14,200
get the right thing there are other ways

00:11:12,399 --> 00:11:16,350
to run this too you can look them up in

00:11:14,200 --> 00:11:18,520
the documentation

00:11:16,350 --> 00:11:20,800
so you'll notice both of these commands

00:11:18,520 --> 00:11:22,300
are creating an output file so next step

00:11:20,800 --> 00:11:26,410
is we're going to look at the data in

00:11:22,300 --> 00:11:27,970
that file P stats is a module built into

00:11:26,410 --> 00:11:30,820
the Python standard library that gives

00:11:27,970 --> 00:11:32,680
you a text-based view on that data so

00:11:30,820 --> 00:11:35,320
the first line here is loading it into a

00:11:32,680 --> 00:11:38,920
stats object and then you can sort and

00:11:35,320 --> 00:11:40,029
print it and filter it the arguments to

00:11:38,920 --> 00:11:44,910
the print stats method there are

00:11:40,029 --> 00:11:47,410
filtering by the name and to a number of

00:11:44,910 --> 00:11:50,920
functions you can filter by a percentage

00:11:47,410 --> 00:11:53,140
of functions the sort stats argument is

00:11:50,920 --> 00:11:56,040
sorting by a specific column cumulative

00:11:53,140 --> 00:11:58,510
time in this case cumulative time is the

00:11:56,040 --> 00:12:01,570
total amount of time spent under a

00:11:58,510 --> 00:12:04,180
function so that function plus anything

00:12:01,570 --> 00:12:07,870
it calls is the cumulative time and you

00:12:04,180 --> 00:12:09,670
get both like a total and a per call you

00:12:07,870 --> 00:12:11,020
can also sort by the other columns in

00:12:09,670 --> 00:12:13,000
this case it's sorting by total time

00:12:11,020 --> 00:12:15,310
total time is how much time is spent

00:12:13,000 --> 00:12:20,170
inside of a function but not calling the

00:12:15,310 --> 00:12:21,940
things it calls so you can get a fair

00:12:20,170 --> 00:12:24,070
bit of information from this but I like

00:12:21,940 --> 00:12:25,870
to know kind of both of those things at

00:12:24,070 --> 00:12:27,970
the same time I like to know kind of

00:12:25,870 --> 00:12:30,160
like the hierarchical relationship of my

00:12:27,970 --> 00:12:31,930
code and the thing that's slow because

00:12:30,160 --> 00:12:34,450
it's a lot easier to kind of diagnose

00:12:31,930 --> 00:12:37,690
what's going on when you can see what's

00:12:34,450 --> 00:12:39,190
slow and what called it and what called

00:12:37,690 --> 00:12:41,350
that and so on and sort of see those

00:12:39,190 --> 00:12:43,029
things in tandem you can kind of get

00:12:41,350 --> 00:12:46,120
that information from some other stuff

00:12:43,029 --> 00:12:50,260
inside of P stats but it's not quick to

00:12:46,120 --> 00:12:53,500
look at I like a graphical view so I

00:12:50,260 --> 00:12:55,810
wrote a tool called snake vis that runs

00:12:53,500 --> 00:12:59,079
in your browser and gives you this

00:12:55,810 --> 00:13:01,980
graphical display of your programs

00:12:59,079 --> 00:13:04,540
execution where things are sized

00:13:01,980 --> 00:13:07,870
horizontally by how much time they take

00:13:04,540 --> 00:13:09,459
and it also has this the table below it

00:13:07,870 --> 00:13:11,200
so you can go back and forth and all I'm

00:13:09,459 --> 00:13:14,680
going to show you this this is the scary

00:13:11,200 --> 00:13:19,699
part where I switch there it is okay

00:13:14,680 --> 00:13:21,980
it's my mouse go over there okay so this

00:13:19,699 --> 00:13:24,350
is kind of the top level so like this

00:13:21,980 --> 00:13:26,720
code called this code called this code

00:13:24,350 --> 00:13:28,519
called this code and so you can see

00:13:26,720 --> 00:13:31,850
we're spending over half of the time

00:13:28,519 --> 00:13:33,259
here in the copy firewall function so

00:13:31,850 --> 00:13:35,810
we're spending a lot of time copying the

00:13:33,259 --> 00:13:39,949
firewall we're also spending a lot of

00:13:35,810 --> 00:13:42,319
time in crossing and this is the advance

00:13:39,949 --> 00:13:45,920
like scanner advanced so a bit of time

00:13:42,319 --> 00:13:48,589
there within caught firewall we're

00:13:45,920 --> 00:13:51,639
spending a lot of time copying code okay

00:13:48,589 --> 00:13:54,339
so cool we've narrowed that down

00:13:51,639 --> 00:13:57,139
scrolling down a little bit this is the

00:13:54,339 --> 00:13:59,029
P stats data so the number of calls

00:13:57,139 --> 00:14:01,459
total time per call total time

00:13:59,029 --> 00:14:04,399
cumulative and protocol cumulative for

00:14:01,459 --> 00:14:06,139
each of these functions and here's the

00:14:04,399 --> 00:14:09,230
slow stuff it's sorted by it you can

00:14:06,139 --> 00:14:12,170
sort these into different orders it's

00:14:09,230 --> 00:14:14,360
sorted by total time right now and so

00:14:12,170 --> 00:14:16,339
the things that spend the most amount of

00:14:14,360 --> 00:14:21,019
time kind of on their own are it's

00:14:16,339 --> 00:14:23,899
sorted to the top of this list and the

00:14:21,019 --> 00:14:25,759
per call time is interesting here

00:14:23,899 --> 00:14:30,410
because individually these functions are

00:14:25,759 --> 00:14:33,009
very fast they are taking ten millionths

00:14:30,410 --> 00:14:35,300
of a second ten thousandths of a second

00:14:33,009 --> 00:14:39,410
but they're being called hundreds of

00:14:35,300 --> 00:14:41,899
millions of time times and what that's

00:14:39,410 --> 00:14:43,490
telling me is we're not gonna have an

00:14:41,899 --> 00:14:46,610
easy time making those functions

00:14:43,490 --> 00:14:48,709
individually much faster we need to

00:14:46,610 --> 00:14:50,810
target the fact that they're being

00:14:48,709 --> 00:14:54,170
called at all or being called so many

00:14:50,810 --> 00:14:57,470
times and all of this stuff is related

00:14:54,170 --> 00:14:59,689
to the state management of the firewall

00:14:57,470 --> 00:15:01,730
keeping track of what state the firewall

00:14:59,689 --> 00:15:03,500
is in and managing its state between

00:15:01,730 --> 00:15:09,500
different checks of whether we made it

00:15:03,500 --> 00:15:13,220
across so the solution I came up with to

00:15:09,500 --> 00:15:16,459
manage this was can I not manage the

00:15:13,220 --> 00:15:18,769
state of the firewall so it turns out we

00:15:16,459 --> 00:15:23,920
can so let me see if I can switch back

00:15:18,769 --> 00:15:26,620
to keynote here if I can find where my

00:15:23,920 --> 00:15:30,860
okay

00:15:26,620 --> 00:15:33,500
so thinking about how the scanners move

00:15:30,860 --> 00:15:36,710
up and down they move very predictably

00:15:33,500 --> 00:15:39,980
they all start at the bottom and on the

00:15:36,710 --> 00:15:41,240
time time step they move up up until

00:15:39,980 --> 00:15:42,970
they get to the top and then they move

00:15:41,240 --> 00:15:45,710
back down so they kind of move in this

00:15:42,970 --> 00:15:49,460
pyramid-shaped and it's cyclical it's

00:15:45,710 --> 00:15:52,100
the same forever and we can use this

00:15:49,460 --> 00:15:55,670
we've got two lines there we can use

00:15:52,100 --> 00:16:00,110
good old y equals MX plus B from algebra

00:15:55,670 --> 00:16:03,680
to like calculate where the scanner is

00:16:00,110 --> 00:16:07,160
at a given time step if we know two

00:16:03,680 --> 00:16:09,410
things we need to know how tall how big

00:16:07,160 --> 00:16:13,280
that range is and what the time step is

00:16:09,410 --> 00:16:15,620
so we figure out so there's kind of the

00:16:13,280 --> 00:16:17,630
constants at the top there the first

00:16:15,620 --> 00:16:20,120
step is figuring out where in that cycle

00:16:17,630 --> 00:16:22,790
the scanner is using the modulus

00:16:20,120 --> 00:16:24,380
operator so we're doing a modulus with

00:16:22,790 --> 00:16:26,690
the time step and the width of that

00:16:24,380 --> 00:16:28,610
cycle to figure out where the scanner is

00:16:26,690 --> 00:16:30,650
and then depending on whether the

00:16:28,610 --> 00:16:32,720
scanner is on the left or the right side

00:16:30,650 --> 00:16:36,440
of that peak you use a different

00:16:32,720 --> 00:16:38,870
equation for the line and calculate how

00:16:36,440 --> 00:16:41,330
high it is so in this case its height is

00:16:38,870 --> 00:16:41,930
three here's another example where it's

00:16:41,330 --> 00:16:46,010
on the left

00:16:41,930 --> 00:16:50,000
with a height of one but some fairly

00:16:46,010 --> 00:16:51,770
straightforward math and there it is in

00:16:50,000 --> 00:16:53,900
code don't try to read it too closely

00:16:51,770 --> 00:16:56,420
but it's exactly this process it's

00:16:53,900 --> 00:17:00,050
figuring out where is the peak of that

00:16:56,420 --> 00:17:02,240
cycle how wide is the cycle where is the

00:17:00,050 --> 00:17:04,970
scanner within the cycle and then

00:17:02,240 --> 00:17:10,130
calculating based on that where the

00:17:04,970 --> 00:17:11,930
scanner is within that position now I've

00:17:10,130 --> 00:17:14,420
totally done away with this that scanner

00:17:11,930 --> 00:17:17,030
class it's never gonna be gone so I've

00:17:14,420 --> 00:17:19,430
rewritten the reframe the firewall as

00:17:17,030 --> 00:17:22,850
it's still a dictionary mapping the

00:17:19,430 --> 00:17:25,490
scanner the scanners horizontal position

00:17:22,850 --> 00:17:29,840
but now only on the on the value side

00:17:25,490 --> 00:17:33,740
only how high those things are so this

00:17:29,840 --> 00:17:35,920
is an integer to an integer the caught

00:17:33,740 --> 00:17:38,240
crossing function looks pretty similar

00:17:35,920 --> 00:17:40,410
we've taken out the part where it's

00:17:38,240 --> 00:17:42,300
advancing the firewall so

00:17:40,410 --> 00:17:43,890
the loop over the firewall and calling

00:17:42,300 --> 00:17:46,350
advance that's gone because we don't

00:17:43,890 --> 00:17:48,030
have that scanner class anymore but

00:17:46,350 --> 00:17:49,590
otherwise it's pretty much the same it's

00:17:48,030 --> 00:17:51,750
checking if there's a scanner in every

00:17:49,590 --> 00:17:54,390
any given position as it traverses the

00:17:51,750 --> 00:17:56,880
width of the firewall and it's checking

00:17:54,390 --> 00:17:58,350
if the scanner is at the bottom of the

00:17:56,880 --> 00:18:00,810
the bottom layer when we got there

00:17:58,350 --> 00:18:02,040
returning true if so and if it makes it

00:18:00,810 --> 00:18:03,870
all the way to the end of the loop all

00:18:02,040 --> 00:18:08,610
the way across the firewall it returns

00:18:03,870 --> 00:18:10,260
false the fine start function again has

00:18:08,610 --> 00:18:12,270
the same basic elements but it's much

00:18:10,260 --> 00:18:14,880
much shorter now because it's taking out

00:18:12,270 --> 00:18:16,020
all of the stuff about managing the

00:18:14,880 --> 00:18:18,420
state of the firewall

00:18:16,020 --> 00:18:22,590
no more copying the firewall no more

00:18:18,420 --> 00:18:25,050
advancing the firewall only the infinite

00:18:22,590 --> 00:18:27,210
loop checking if we were caught trying

00:18:25,050 --> 00:18:28,770
to cross and the breakout of the

00:18:27,210 --> 00:18:34,430
infinite loop when we finally make it

00:18:28,770 --> 00:18:38,730
across without being caught so it worked

00:18:34,430 --> 00:18:40,680
it took six seconds so we went that's a

00:18:38,730 --> 00:18:42,860
factor of a hundred improvement from the

00:18:40,680 --> 00:18:44,970
previous solution still running Python

00:18:42,860 --> 00:18:47,070
nothing fancy

00:18:44,970 --> 00:18:48,900
I haven't imported anything that's not

00:18:47,070 --> 00:18:50,730
in the standard library I'm the only

00:18:48,900 --> 00:18:54,570
thing that that I'm even importing is

00:18:50,730 --> 00:18:57,390
itertools in these examples so to kind

00:18:54,570 --> 00:19:00,510
of reframing the problem going with math

00:18:57,390 --> 00:19:03,090
instead of state tracking got us a

00:19:00,510 --> 00:19:05,610
factor of 100 improvement in speed if I

00:19:03,090 --> 00:19:07,830
had written this version of this I

00:19:05,610 --> 00:19:09,960
probably would not have done any of the

00:19:07,830 --> 00:19:11,580
stuff that I'm about to show you next

00:19:09,960 --> 00:19:15,840
because I would have been like cool I'm

00:19:11,580 --> 00:19:16,470
done moving on but since I was kind of

00:19:15,840 --> 00:19:21,450
on a roll

00:19:16,470 --> 00:19:26,010
I kept it going so how do we go faster

00:19:21,450 --> 00:19:28,470
so I have not in when I was working on

00:19:26,010 --> 00:19:30,840
this or in the time sense thought of a

00:19:28,470 --> 00:19:32,610
better way to solve this problem like a

00:19:30,840 --> 00:19:35,220
more efficient way to solve this problem

00:19:32,610 --> 00:19:38,460
so let's say for the sake of argument

00:19:35,220 --> 00:19:40,140
that in fact I have coded up the most

00:19:38,460 --> 00:19:44,880
efficient algorithm for solving this

00:19:40,140 --> 00:19:46,410
problem that means like we have to do

00:19:44,880 --> 00:19:48,630
all these loops right there's at least

00:19:46,410 --> 00:19:51,900
3.8 million loops in there plus all of

00:19:48,630 --> 00:19:53,430
the loops over the firewall we're not

00:19:51,900 --> 00:19:54,190
going to get any faster in Python

00:19:53,430 --> 00:19:56,500
because we have

00:19:54,190 --> 00:19:59,559
the limit of how fast Python can go

00:19:56,500 --> 00:20:01,230
through a loop and calculate things so

00:19:59,559 --> 00:20:04,809
to go any faster

00:20:01,230 --> 00:20:06,070
we're gonna have to use not Python so

00:20:04,809 --> 00:20:08,080
the rest of the talk is just going to be

00:20:06,070 --> 00:20:10,120
kind of going pretty quickly through

00:20:08,080 --> 00:20:13,419
some things that are not Python but very

00:20:10,120 --> 00:20:16,600
closely related to Python that can help

00:20:13,419 --> 00:20:21,159
make this faster they all involve

00:20:16,600 --> 00:20:25,659
compiling code but in different ways so

00:20:21,159 --> 00:20:29,350
the first thing I tried was pi PI so pi

00:20:25,659 --> 00:20:33,490
PI is an alternate implementation of

00:20:29,350 --> 00:20:35,340
Python that can do some compilation

00:20:33,490 --> 00:20:40,450
behind the scenes transparently to you

00:20:35,340 --> 00:20:42,610
of loops and repeated things and it runs

00:20:40,450 --> 00:20:44,740
on Python you don't have to like change

00:20:42,610 --> 00:20:47,590
the syntax at all so I took the exact

00:20:44,740 --> 00:20:50,139
same code and ran it through pi PI and

00:20:47,590 --> 00:20:51,610
it took so now this is in millisecond so

00:20:50,139 --> 00:20:52,929
that you can see the order of magnitude

00:20:51,610 --> 00:20:59,350
changes here it took around half a

00:20:52,929 --> 00:21:01,169
second in in pi pi for the other four

00:20:59,350 --> 00:21:04,899
number and scythe on these are both

00:21:01,169 --> 00:21:07,570
numeric tools and again i my goal here

00:21:04,899 --> 00:21:10,299
was to get as far from python as

00:21:07,570 --> 00:21:12,879
possible like not know python so I had

00:21:10,299 --> 00:21:14,860
to reframe the firewall representation a

00:21:12,879 --> 00:21:17,230
little bit before it's been a dictionary

00:21:14,860 --> 00:21:21,220
mapping a position to information about

00:21:17,230 --> 00:21:23,980
each position of the the firewall but a

00:21:21,220 --> 00:21:26,110
dictionary is a Python thing and in

00:21:23,980 --> 00:21:28,740
order to connect Simoni use numba and

00:21:26,110 --> 00:21:31,600
scythe on I needed know Python things

00:21:28,740 --> 00:21:33,879
involved so I changed it into an array

00:21:31,600 --> 00:21:36,879
sort of representation I'm representing

00:21:33,879 --> 00:21:39,250
here as a list but you can think of it

00:21:36,879 --> 00:21:41,649
as something that can it's a list of

00:21:39,250 --> 00:21:46,840
numbers that can be easily made into a C

00:21:41,649 --> 00:21:50,070
type array and there are zeros now in

00:21:46,840 --> 00:21:55,570
the positions where there is no scanner

00:21:50,070 --> 00:21:59,860
so first number number is a neat tool

00:21:55,570 --> 00:22:03,100
that gives you a decorator you can put

00:21:59,860 --> 00:22:07,119
on python code and then you run your

00:22:03,100 --> 00:22:07,870
code as normal but the number decorator

00:22:07,119 --> 00:22:11,950
kind of enter

00:22:07,870 --> 00:22:15,790
ceps calls to your code and compiles

00:22:11,950 --> 00:22:17,980
your your Python function using LLVM to

00:22:15,790 --> 00:22:20,740
be compiled and operate on the inputs on

00:22:17,980 --> 00:22:22,300
which it was called so it kind of like

00:22:20,740 --> 00:22:24,280
will let your function be called in

00:22:22,300 --> 00:22:26,200
Python once and inspect the types

00:22:24,280 --> 00:22:28,500
involved and then make a compiled

00:22:26,200 --> 00:22:30,880
version of it that handles those types

00:22:28,500 --> 00:22:33,970
so it's plain Python you put on a

00:22:30,880 --> 00:22:36,400
decorator run your code like normal you

00:22:33,970 --> 00:22:39,370
do have to have like LLVM installed

00:22:36,400 --> 00:22:42,850
which can be a little tricky for a long

00:22:39,370 --> 00:22:44,830
time the really the only recommended way

00:22:42,850 --> 00:22:47,170
of installing number was to use anaconda

00:22:44,830 --> 00:22:49,570
or the Conda package manager but they're

00:22:47,170 --> 00:22:52,960
getting close or maybe have already made

00:22:49,570 --> 00:22:54,070
this possible to install with pip and

00:22:52,960 --> 00:22:56,940
it's but it's pretty much used

00:22:54,070 --> 00:23:00,010
exclusively with numb by numpy for maths

00:22:56,940 --> 00:23:01,990
this particular problem can be reframed

00:23:00,010 --> 00:23:04,300
as a mathematical problem as we've seen

00:23:01,990 --> 00:23:06,580
so I was able to make use of number you

00:23:04,300 --> 00:23:08,200
can throw the number decorator on

00:23:06,580 --> 00:23:10,950
anything you want and it will give it

00:23:08,200 --> 00:23:16,290
its its best shot at making it faster

00:23:10,950 --> 00:23:18,309
but if you involve Python objects it can

00:23:16,290 --> 00:23:19,570
sometimes there's only so much it can do

00:23:18,309 --> 00:23:21,280
because it will have to go back and

00:23:19,570 --> 00:23:23,559
forth be kind of between the compiled

00:23:21,280 --> 00:23:26,110
layer and the Python layer which I did

00:23:23,559 --> 00:23:28,420
not want so over on the right side of

00:23:26,110 --> 00:23:31,150
this is the know Python equals true

00:23:28,420 --> 00:23:34,420
that's really the key to getting like as

00:23:31,150 --> 00:23:36,910
much performance as you can as saying no

00:23:34,420 --> 00:23:39,070
Python objects will ever be involved in

00:23:36,910 --> 00:23:41,610
the execution of this code and if there

00:23:39,070 --> 00:23:43,660
ever are you should throw an error

00:23:41,610 --> 00:23:46,179
because if you leave this as the default

00:23:43,660 --> 00:23:48,130
false it will go ahead and you can like

00:23:46,179 --> 00:23:49,900
have a dictionary in there and it will

00:23:48,130 --> 00:23:51,640
be like this is fine I'm going to run

00:23:49,900 --> 00:23:53,559
this for you but it won't be as fast as

00:23:51,640 --> 00:23:58,929
possible

00:23:53,559 --> 00:24:00,790
the type annotations are optional like I

00:23:58,929 --> 00:24:03,660
said number will analyze how your

00:24:00,790 --> 00:24:06,370
function is called check the types and

00:24:03,660 --> 00:24:08,230
construct a compiled version based on

00:24:06,370 --> 00:24:10,780
the types of detects but you can

00:24:08,230 --> 00:24:12,610
optionally also say this is how my

00:24:10,780 --> 00:24:17,440
function works it returns a boolean some

00:24:12,610 --> 00:24:20,610
integers go in so here's the caught

00:24:17,440 --> 00:24:23,180
crossing function annotated it's

00:24:20,610 --> 00:24:26,880
almost exactly the same as before

00:24:23,180 --> 00:24:28,770
instead of a dictionary now the check

00:24:26,880 --> 00:24:31,980
for a scanner is checking whether that

00:24:28,770 --> 00:24:34,440
value is equal to zero otherwise

00:24:31,980 --> 00:24:36,600
basically the same you see the decorator

00:24:34,440 --> 00:24:40,310
there at the top I also decorated the

00:24:36,600 --> 00:24:44,100
other functions involved so fine start

00:24:40,310 --> 00:24:45,900
remember I was using itertools count

00:24:44,100 --> 00:24:47,550
here I got rid of that and turned it

00:24:45,900 --> 00:24:50,100
into a while loop so that that could be

00:24:47,550 --> 00:24:51,810
compiled into a fast mode so now I've

00:24:50,100 --> 00:24:54,420
got an extra counter in there counting

00:24:51,810 --> 00:24:57,210
what time the time step is but otherwise

00:24:54,420 --> 00:24:58,650
basically the same I'm not going to show

00:24:57,210 --> 00:25:01,650
it to you but I also put the JIT

00:24:58,650 --> 00:25:05,700
decorator on the check on the check

00:25:01,650 --> 00:25:12,750
capture function I need to update this

00:25:05,700 --> 00:25:16,620
slide and as we saw on the timing once I

00:25:12,750 --> 00:25:18,360
got this all compiled it ran in like two

00:25:16,620 --> 00:25:24,350
milliseconds so another factor of a

00:25:18,360 --> 00:25:29,610
hundred improvement over pi PI and

00:25:24,350 --> 00:25:31,440
lastly siphon siphon is a actually kind

00:25:29,610 --> 00:25:34,620
of a separate language from Python but

00:25:31,440 --> 00:25:38,640
it looks a lot like Python and the

00:25:34,620 --> 00:25:41,400
psyphon tooling compiles that code to

00:25:38,640 --> 00:25:44,940
see which is then compiled by like your

00:25:41,400 --> 00:25:48,330
systems C compiler so this involves a

00:25:44,940 --> 00:25:50,370
bit more build tooling than then numba

00:25:48,330 --> 00:25:51,990
numba you throw a decorator on there and

00:25:50,370 --> 00:25:54,750
then run as normal with psyphon you

00:25:51,990 --> 00:25:55,860
actually have a compilation step you

00:25:54,750 --> 00:25:58,020
have to go through ahead of time

00:25:55,860 --> 00:26:00,780
especially if you're distributing code

00:25:58,020 --> 00:26:04,020
or using pythons packaging there is a

00:26:00,780 --> 00:26:05,910
syphon ipython magic that helps you

00:26:04,020 --> 00:26:08,520
circumvent all of that and write some

00:26:05,910 --> 00:26:09,960
psyphon in a in a notebook or in the

00:26:08,520 --> 00:26:12,180
ipython console that you can then

00:26:09,960 --> 00:26:16,740
immediately call that's how I did this

00:26:12,180 --> 00:26:18,770
assignment very handy but you do have to

00:26:16,740 --> 00:26:21,780
go through this process but because it's

00:26:18,770 --> 00:26:24,930
it's kind of like writing C but in

00:26:21,780 --> 00:26:27,270
Python and it makes it a lot easier to

00:26:24,930 --> 00:26:29,100
wrap C libraries so if you have some

00:26:27,270 --> 00:26:30,720
other like external C library that

00:26:29,100 --> 00:26:32,550
you're trying to wrap up and you want to

00:26:30,720 --> 00:26:33,810
call into and like path and pass in

00:26:32,550 --> 00:26:35,610
python things

00:26:33,810 --> 00:26:38,450
scythe on is great for that it has

00:26:35,610 --> 00:26:42,530
built-in pretty native understanding of

00:26:38,450 --> 00:26:45,210
numpy I didn't end up using so in the

00:26:42,530 --> 00:26:48,030
number example I had to convert that

00:26:45,210 --> 00:26:49,770
array of firewall heights to a numpy

00:26:48,030 --> 00:26:53,040
array in order for number two kind of

00:26:49,770 --> 00:26:55,050
properly recognize it for this Forsyth

00:26:53,040 --> 00:26:56,790
on I used pythons built-in array module

00:26:55,050 --> 00:26:58,380
instead but both of those are

00:26:56,790 --> 00:27:01,170
essentially a way of getting that list

00:26:58,380 --> 00:27:05,430
of numbers describing the firewall into

00:27:01,170 --> 00:27:08,490
a contiguous C array that then the the

00:27:05,430 --> 00:27:12,060
compiled code could work with so this is

00:27:08,490 --> 00:27:14,580
caught crossing with with some sites on

00:27:12,060 --> 00:27:17,040
stuff on it one was turning off some

00:27:14,580 --> 00:27:19,050
safety stuff python is a really

00:27:17,040 --> 00:27:21,600
developer friendly language in part

00:27:19,050 --> 00:27:23,850
because it has checks it checks whether

00:27:21,600 --> 00:27:27,150
you are indexing beyond the end of a

00:27:23,850 --> 00:27:29,810
list it checks it allows you to index

00:27:27,150 --> 00:27:32,220
from the back of a list with the - 1 - 2

00:27:29,810 --> 00:27:36,120
part of getting performance improvement

00:27:32,220 --> 00:27:38,820
out of saipan can be turning that stuff

00:27:36,120 --> 00:27:40,860
off and being like don't worry about it

00:27:38,820 --> 00:27:44,640
I know what I'm doing

00:27:40,860 --> 00:27:46,470
no checks please in in my case this

00:27:44,640 --> 00:27:48,030
didn't really I tried it both with and

00:27:46,470 --> 00:27:51,540
without these decorators and like it

00:27:48,030 --> 00:27:53,670
didn't really change the performance but

00:27:51,540 --> 00:27:56,580
just in case that comes up for you

00:27:53,670 --> 00:27:58,500
you're trading safety for performance a

00:27:56,580 --> 00:28:02,280
lot of times this happens a lot

00:27:58,500 --> 00:28:03,570
especially when you go into n2c and the

00:28:02,280 --> 00:28:05,880
other thing you have to do is put types

00:28:03,570 --> 00:28:07,920
what you don't have to but if you want

00:28:05,880 --> 00:28:10,230
performance again like you put types on

00:28:07,920 --> 00:28:13,080
everything and the more types that are

00:28:10,230 --> 00:28:15,330
there the Moores I thought can go I know

00:28:13,080 --> 00:28:17,670
exactly what this is and see like there

00:28:15,330 --> 00:28:19,710
isn't exactly an analogous thing in C

00:28:17,670 --> 00:28:22,320
for this thing in the scythe on code and

00:28:19,710 --> 00:28:25,170
then it writes C code that is exactly

00:28:22,320 --> 00:28:25,770
that and like you end up again like the

00:28:25,170 --> 00:28:29,190
goal here

00:28:25,770 --> 00:28:32,250
no Python you never want you don't I'm

00:28:29,190 --> 00:28:34,440
sorry I didn't want scythe on ever

00:28:32,250 --> 00:28:37,530
having to do something with a Python

00:28:34,440 --> 00:28:39,900
object but it will you can also like

00:28:37,530 --> 00:28:42,540
take plain Python with no type

00:28:39,900 --> 00:28:44,340
annotations and no decorators run it

00:28:42,540 --> 00:28:47,200
through scythe on and it will compile it

00:28:44,340 --> 00:28:49,409
and it just won't be as fast but

00:28:47,200 --> 00:28:52,149
could be still a lot faster than plain

00:28:49,409 --> 00:28:55,179
plain Python like there was a talk from

00:28:52,149 --> 00:28:58,450
Instagram last year where they took part

00:28:55,179 --> 00:29:00,399
of Django's URL routing code and without

00:28:58,450 --> 00:29:02,230
changing it at all ran it through scythe

00:29:00,399 --> 00:29:04,149
on and got a pretty significant

00:29:02,230 --> 00:29:07,929
performance boost on their django URL

00:29:04,149 --> 00:29:10,570
routing so both both numba and scythe on

00:29:07,929 --> 00:29:12,220
will like give it a try if you throw it

00:29:10,570 --> 00:29:14,620
at things you don't have to go through

00:29:12,220 --> 00:29:17,350
this process but part of getting the

00:29:14,620 --> 00:29:18,490
performance is that like what C type is

00:29:17,350 --> 00:29:21,730
this kind of thing

00:29:18,490 --> 00:29:23,440
thinking scythe on has a really cool

00:29:21,730 --> 00:29:26,080
tool especially in the notebook that

00:29:23,440 --> 00:29:27,730
will annotate the code this saw us again

00:29:26,080 --> 00:29:31,510
collecting data and profiling and kind

00:29:27,730 --> 00:29:33,909
of say this line I was able to make

00:29:31,510 --> 00:29:35,110
efficient this line I was not so you can

00:29:33,909 --> 00:29:39,549
kind of cycle through that and get

00:29:35,110 --> 00:29:42,190
things going so again look at this that

00:29:39,549 --> 00:29:45,880
my first try was running in hundreds of

00:29:42,190 --> 00:29:49,000
seconds improving that algorithm got us

00:29:45,880 --> 00:29:51,730
a hundred factor of 100 and then going

00:29:49,000 --> 00:29:55,029
with compilation different compilation

00:29:51,730 --> 00:29:57,399
tools got us variously another factor of

00:29:55,029 --> 00:30:00,789
ten or another factor of a thousand

00:29:57,399 --> 00:30:02,019
improvements in performance and when

00:30:00,789 --> 00:30:03,399
you're using number and scythe on you

00:30:02,019 --> 00:30:06,220
kind of want to take this approach of

00:30:03,399 --> 00:30:09,070
like finding a small part of your code

00:30:06,220 --> 00:30:12,370
that is the slow part and optimizing

00:30:09,070 --> 00:30:14,649
that using these tools so thank you very

00:30:12,370 --> 00:30:17,019
much remember the recipe this is the

00:30:14,649 --> 00:30:19,240
important bit be a scientist be a

00:30:17,019 --> 00:30:22,389
detective and and collect data analyze

00:30:19,240 --> 00:30:24,100
it experiment there's the link for the

00:30:22,389 --> 00:30:26,679
talk I don't have time for questions

00:30:24,100 --> 00:30:29,170
here but I'm happy to take them outside

00:30:26,679 --> 00:30:36,849
or elsewhere thank you very much

00:30:29,170 --> 00:30:36,849

YouTube URL: https://www.youtube.com/watch?v=yrRqNzJTBjk


