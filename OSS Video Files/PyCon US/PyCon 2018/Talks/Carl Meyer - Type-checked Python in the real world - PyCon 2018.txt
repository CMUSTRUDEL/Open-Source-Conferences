Title: Carl Meyer - Type-checked Python in the real world - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Carl Meyer

You've heard about Python type annotations, but wondered if they're useful in the real world? Worried you've got too much code and can't afford to annotate it?  Type-checked Python is here, it's for real, and it can help you catch bugs and make your code easier to understand. Come learn from our experience gradually typing a million-LOC production Python application!

Type checking solves real world problems in production Python systems. We'll cover the benefits, how type checking in Python works, how to introduce it gradually and sustainably in a production Python application, and how to measure success and avoid common pitfalls. We'll even demonstrate how modern Python typechecking goes hand-in-hand with duck-typing! Join us for a deep dive into type-checked Python in the real world.

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:02,149 --> 00:00:06,839
hey folks let's all give a round of

00:00:04,859 --> 00:00:08,580
applause for Carl Meyer who was here to

00:00:06,839 --> 00:00:15,389
talk to us about type Tec Python in the

00:00:08,580 --> 00:00:19,140
real world Thank You Rami welcome to the

00:00:15,389 --> 00:00:21,570
final session of talks at PyCon 2018 I

00:00:19,140 --> 00:00:22,859
hope that after three days of PyCon and

00:00:21,570 --> 00:00:24,560
three nights of enjoying the best of

00:00:22,859 --> 00:00:27,150
Cleveland you're all awake enough to

00:00:24,560 --> 00:00:28,590
process some Python code on slides

00:00:27,150 --> 00:00:31,769
because we're gonna see a lot of it in

00:00:28,590 --> 00:00:33,690
the next half hour I'm Carl Meyer I work

00:00:31,769 --> 00:00:39,750
in instagrams server core infrastructure

00:00:33,690 --> 00:00:42,000
and I'm here to talk about type-check

00:00:39,750 --> 00:00:43,399
Python so if you see me around the

00:00:42,000 --> 00:00:46,530
internet I probably looked like this

00:00:43,399 --> 00:00:48,329
this is me and my sister prototyping

00:00:46,530 --> 00:00:51,210
some eyewear designs of our own creation

00:00:48,329 --> 00:00:53,340
that never took off I'm Carl JM pretty

00:00:51,210 --> 00:00:55,469
much everywhere on the internet I've

00:00:53,340 --> 00:00:57,059
been writing Python code now since the

00:00:55,469 --> 00:00:58,800
well since before the turn of the

00:00:57,059 --> 00:01:01,350
millennium which I'm fairly sure makes

00:00:58,800 --> 00:01:02,820
me officially old for the last couple

00:01:01,350 --> 00:01:05,100
years I've been working at Instagram

00:01:02,820 --> 00:01:07,200
most recently on adding type-checking

00:01:05,100 --> 00:01:11,070
type annotations to our server code base

00:01:07,200 --> 00:01:12,930
so a rough plan for the next half hour

00:01:11,070 --> 00:01:14,810
we'll talk a little bit about why you

00:01:12,930 --> 00:01:17,310
might want to type your Python code

00:01:14,810 --> 00:01:20,009
we'll go into how you would go about it

00:01:17,310 --> 00:01:22,860
a sort of a brief tour of pythons type

00:01:20,009 --> 00:01:25,110
system and lastly we'll talk about

00:01:22,860 --> 00:01:30,689
gradual typing what it means and why it

00:01:25,110 --> 00:01:32,369
matters so Y type your Python code if

00:01:30,689 --> 00:01:33,930
some of you in here are coming from a

00:01:32,369 --> 00:01:37,110
static typing background you might have

00:01:33,930 --> 00:01:39,450
the opposite question like how is Python

00:01:37,110 --> 00:01:41,490
even usable without static typing but

00:01:39,450 --> 00:01:43,470
since we're at PyCon we'll take the

00:01:41,490 --> 00:01:45,570
question from the opposite side I've

00:01:43,470 --> 00:01:47,130
been using Python for years it's fine

00:01:45,570 --> 00:01:53,040
why do I care why do I need type

00:01:47,130 --> 00:01:55,170
annotations so in this method process

00:01:53,040 --> 00:02:01,350
method on some class it takes an item's

00:01:55,170 --> 00:02:03,840
argument what is items in Python we have

00:02:01,350 --> 00:02:05,729
this idea of duck typing if it walks

00:02:03,840 --> 00:02:08,489
like a duck and quacks like a duck it

00:02:05,729 --> 00:02:10,530
may as well be a duck so we can give a

00:02:08,489 --> 00:02:13,470
duck typing answer to our question what

00:02:10,530 --> 00:02:13,620
is items items is some collection that

00:02:13,470 --> 00:02:15,959
we

00:02:13,620 --> 00:02:18,390
can iterate over each item in the

00:02:15,959 --> 00:02:21,680
collection should have a value attribute

00:02:18,390 --> 00:02:23,970
which itself should have an ID attribute

00:02:21,680 --> 00:02:25,980
that's great that's a very flexible

00:02:23,970 --> 00:02:28,110
answer to the question it could allow us

00:02:25,980 --> 00:02:29,849
to reuse this process method in various

00:02:28,110 --> 00:02:31,860
contexts past different kinds of

00:02:29,849 --> 00:02:33,959
collections maybe even containing

00:02:31,860 --> 00:02:40,500
different kinds of objects as long as

00:02:33,959 --> 00:02:42,840
they all conform to this contract with a

00:02:40,500 --> 00:02:46,739
type int look the problem with this

00:02:42,840 --> 00:02:49,500
though is code is written once but

00:02:46,739 --> 00:02:52,260
maintained for a long time so what if I

00:02:49,500 --> 00:02:53,670
come back to this code in six months and

00:02:52,260 --> 00:02:56,040
I've forgotten everything I knew when I

00:02:53,670 --> 00:02:56,819
wrote it the contract that we just

00:02:56,040 --> 00:02:59,069
described

00:02:56,819 --> 00:03:01,170
I have to reestablish by reading through

00:02:59,069 --> 00:03:05,579
every line of code in the function line

00:03:01,170 --> 00:03:07,680
by line it's entirely implicit or what

00:03:05,579 --> 00:03:09,329
if how do I know that I'm conforming to

00:03:07,680 --> 00:03:11,640
this contract everywhere my code base

00:03:09,329 --> 00:03:13,680
may be somewhere in some dark corner and

00:03:11,640 --> 00:03:15,420
passing in some object where it's value

00:03:13,680 --> 00:03:17,040
attribute could in some cases be none

00:03:15,420 --> 00:03:19,319
and then I'm gonna get an attribute

00:03:17,040 --> 00:03:21,389
error how would I catch that or maybe I

00:03:19,319 --> 00:03:23,970
need to add some new functionality to

00:03:21,389 --> 00:03:25,680
this function I have a new requirement I

00:03:23,970 --> 00:03:27,840
want to access a new attribute on my

00:03:25,680 --> 00:03:29,700
items how do I know that everywhere that

00:03:27,840 --> 00:03:31,349
I'm currently passing in objects to this

00:03:29,700 --> 00:03:33,959
function that they have this new

00:03:31,349 --> 00:03:36,349
attribute if I have a large code base in

00:03:33,959 --> 00:03:39,000
some cases answering that question

00:03:36,349 --> 00:03:40,530
satisfactorily could require digging

00:03:39,000 --> 00:03:42,599
through layers and layers of code not

00:03:40,530 --> 00:03:44,250
only the call sites of this method but

00:03:42,599 --> 00:03:46,889
perhaps their call sites and their call

00:03:44,250 --> 00:03:48,629
sites until I track down the origin of

00:03:46,889 --> 00:03:53,010
the collection that ultimately is

00:03:48,629 --> 00:03:54,870
getting passed to this method where the

00:03:53,010 --> 00:03:56,940
type annotation all of that goes away

00:03:54,870 --> 00:03:58,980
now I know exactly what I can expect to

00:03:56,940 --> 00:04:01,109
receive a sequence of this particular

00:03:58,980 --> 00:04:02,849
item class I can go directly to the

00:04:01,109 --> 00:04:08,340
class I know where it is I can see what

00:04:02,849 --> 00:04:10,230
attributes and methods it has this is

00:04:08,340 --> 00:04:11,879
nothing new of course people have been

00:04:10,230 --> 00:04:14,970
putting the same information into

00:04:11,879 --> 00:04:17,070
docstrings for years or into comments

00:04:14,970 --> 00:04:19,220
there's multiple standards even EP doc

00:04:17,070 --> 00:04:22,229
and others for how you can represent

00:04:19,220 --> 00:04:25,349
argument and return types in your doc

00:04:22,229 --> 00:04:27,000
strings in Python so it's clearly useful

00:04:25,349 --> 00:04:28,200
information for maintained errs

00:04:27,000 --> 00:04:30,600
the problem with the docs Turing

00:04:28,200 --> 00:04:32,280
annotation is that at some point it's

00:04:30,600 --> 00:04:34,140
guaranteed that someone will update the

00:04:32,280 --> 00:04:36,180
signature of the function and forget to

00:04:34,140 --> 00:04:39,140
update the doc string at which point

00:04:36,180 --> 00:04:42,500
it's obsolete and arguably worse than

00:04:39,140 --> 00:04:42,500
worse than useless

00:04:42,530 --> 00:04:46,230
whereas this type annotation can

00:04:44,670 --> 00:04:48,240
automatically be checked for correctness

00:04:46,230 --> 00:04:53,850
so it has to remain up-to-date with the

00:04:48,240 --> 00:04:55,830
code so I I can almost hear someone in

00:04:53,850 --> 00:04:57,690
the room thinking that's great but I

00:04:55,830 --> 00:04:59,880
don't need it I could catch those things

00:04:57,690 --> 00:05:01,650
with a test which is great I love tests

00:04:59,880 --> 00:05:03,600
I've written a lot of tests I've given

00:05:01,650 --> 00:05:05,490
Python talks on writing tests in Python

00:05:03,600 --> 00:05:06,930
there's this trope of the dynamic

00:05:05,490 --> 00:05:08,400
language programmer claiming they don't

00:05:06,930 --> 00:05:10,710
need static types because they write

00:05:08,400 --> 00:05:12,480
tests or the static typing programmer

00:05:10,710 --> 00:05:13,830
claiming they don't need to write tests

00:05:12,480 --> 00:05:16,830
because the compiler catches all of

00:05:13,830 --> 00:05:19,140
their bugs both are right and both are

00:05:16,830 --> 00:05:21,419
of course wrong if we imagine a two

00:05:19,140 --> 00:05:23,520
argument function and this plot is the

00:05:21,419 --> 00:05:26,460
space of all possible inputs to the

00:05:23,520 --> 00:05:28,440
function so one argument on the x-axis

00:05:26,460 --> 00:05:31,140
one on the y-axis we have the space of

00:05:28,440 --> 00:05:33,900
all possible arguments if we write a

00:05:31,140 --> 00:05:35,640
test case it's a single example we give

00:05:33,900 --> 00:05:37,980
two argument values one for each

00:05:35,640 --> 00:05:40,320
argument we assert the correct return

00:05:37,980 --> 00:05:42,750
value we've covered exactly one point in

00:05:40,320 --> 00:05:44,970
this plot typically we write test cases

00:05:42,750 --> 00:05:47,490
for a variety of points on this plot

00:05:44,970 --> 00:05:49,890
that we think or hope or maybe even know

00:05:47,490 --> 00:05:51,510
are representative of the space of

00:05:49,890 --> 00:05:54,479
possible inputs that we think we care

00:05:51,510 --> 00:05:56,160
about maybe if we're especially clever

00:05:54,479 --> 00:05:58,590
we can write a parametrized test case

00:05:56,160 --> 00:06:00,780
cover a whole range of inputs with a

00:05:58,590 --> 00:06:02,820
single test maybe even a quick check

00:06:00,780 --> 00:06:06,270
style or property based test cover an

00:06:02,820 --> 00:06:09,030
even wider array of possible inputs with

00:06:06,270 --> 00:06:10,350
type annotations we can add just a few

00:06:09,030 --> 00:06:13,650
characters to our function definition

00:06:10,350 --> 00:06:15,240
and instantly eliminate entire sways of

00:06:13,650 --> 00:06:17,310
this area to cover i annotate that my

00:06:15,240 --> 00:06:19,050
function takes two integers and all of

00:06:17,310 --> 00:06:23,340
this area out here for all the possible

00:06:19,050 --> 00:06:26,010
strings and lists and dictionaries isn't

00:06:23,340 --> 00:06:28,200
is eliminated I can focus all my testing

00:06:26,010 --> 00:06:31,200
effort on ensuring correctness with high

00:06:28,200 --> 00:06:33,660
granularity in this area where it really

00:06:31,200 --> 00:06:36,890
matters we're even the best type system

00:06:33,660 --> 00:06:36,890
can't fully ensure correctness

00:06:39,540 --> 00:06:43,750
so let's say I've convinced you and you

00:06:42,400 --> 00:06:45,670
want to start type checking your Python

00:06:43,750 --> 00:06:47,410
how do you make it happen let's take a

00:06:45,670 --> 00:06:51,430
little tour of what typing looks like in

00:06:47,410 --> 00:06:52,840
Python so we have a simple function a

00:06:51,430 --> 00:06:54,400
square function it takes an integer

00:06:52,840 --> 00:06:57,700
returns an integer the square of the

00:06:54,400 --> 00:07:00,220
argument we've seen the syntax for this

00:06:57,700 --> 00:07:01,450
in previous slides after each argument

00:07:00,220 --> 00:07:03,580
we can have a colon and then the type

00:07:01,450 --> 00:07:06,280
after the argument list we can have an

00:07:03,580 --> 00:07:08,830
arrow and then the return type so let's

00:07:06,280 --> 00:07:11,140
call the function a few times we'll take

00:07:08,830 --> 00:07:13,780
the square of 3 we'll take the square of

00:07:11,140 --> 00:07:16,260
a string just for kicks we'll take the

00:07:13,780 --> 00:07:18,810
square of 4 and then add it to a string

00:07:16,260 --> 00:07:22,780
now let's try type checking this code

00:07:18,810 --> 00:07:24,640
will pip install my PI my PI is a open

00:07:22,780 --> 00:07:26,290
source Python type checker written and

00:07:24,640 --> 00:07:29,230
maintained by a team at Dropbox

00:07:26,290 --> 00:07:31,210
it's the by far today the most commonly

00:07:29,230 --> 00:07:34,150
used Python type checker so we'll use it

00:07:31,210 --> 00:07:36,610
in our examples for this talk so let's

00:07:34,150 --> 00:07:38,710
run my PI on our file and we get a

00:07:36,610 --> 00:07:41,800
couple of type errors let's dig into

00:07:38,710 --> 00:07:43,390
them a little bit we get a 1 type error

00:07:41,800 --> 00:07:46,930
because we tried to pass in a string

00:07:43,390 --> 00:07:48,970
where an integer is expected and another

00:07:46,930 --> 00:07:51,910
type error because we tried to add an

00:07:48,970 --> 00:07:54,400
integer the annotated return type of the

00:07:51,910 --> 00:07:57,100
square function to a string which is a

00:07:54,400 --> 00:07:58,960
type error in Python and we got both of

00:07:57,100 --> 00:08:00,520
those errors without having to set up

00:07:58,960 --> 00:08:01,780
any kind of test harness or write any

00:08:00,520 --> 00:08:03,820
kind of test case that would exercise

00:08:01,780 --> 00:08:08,920
this code just by running a static

00:08:03,820 --> 00:08:10,960
analyzer over the code so the type

00:08:08,920 --> 00:08:12,820
checker asks us to annotate our function

00:08:10,960 --> 00:08:14,440
signatures in order to validate our

00:08:12,820 --> 00:08:16,420
assumptions about input and output types

00:08:14,440 --> 00:08:19,750
in between there's a lot it can infer

00:08:16,420 --> 00:08:21,520
for instance in this class because it

00:08:19,750 --> 00:08:23,140
knows that the we've told it that the

00:08:21,520 --> 00:08:25,720
type of the width and height arguments

00:08:23,140 --> 00:08:27,160
to the initializer are both integers it

00:08:25,720 --> 00:08:29,830
can infer through the assignments to

00:08:27,160 --> 00:08:32,410
self and understand that every photo

00:08:29,830 --> 00:08:36,250
instance will have a width and a height

00:08:32,410 --> 00:08:37,870
attribute that are integers and if we

00:08:36,250 --> 00:08:39,580
need another method we try to return

00:08:37,870 --> 00:08:40,840
self dot width and self dot height and

00:08:39,580 --> 00:08:42,850
claim that they're a couple of strings

00:08:40,840 --> 00:08:47,080
the type checker can catch that and tell

00:08:42,850 --> 00:08:49,060
us no that's a couple of integers we can

00:08:47,080 --> 00:08:51,760
also infer the types of containers if we

00:08:49,060 --> 00:08:53,950
create a list of photo objects

00:08:51,760 --> 00:08:55,510
try to append a string to it the type

00:08:53,950 --> 00:08:57,430
checker will tell us hey maybe that's

00:08:55,510 --> 00:08:58,810
not what you intended to do this is of

00:08:57,430 --> 00:09:01,450
course the type checker being a little

00:08:58,810 --> 00:09:03,880
bit opinionated in Python it's perfectly

00:09:01,450 --> 00:09:05,530
legal to have a heterogeneous list but

00:09:03,880 --> 00:09:07,810
the type checker assumes that if we

00:09:05,530 --> 00:09:09,550
initialized it with a homogeneous set of

00:09:07,810 --> 00:09:11,350
objects that probably that's what we

00:09:09,550 --> 00:09:13,420
intended and it was probably a mistake

00:09:11,350 --> 00:09:15,100
to add a different type we can use an

00:09:13,420 --> 00:09:19,750
explicit type annotation if we want to

00:09:15,100 --> 00:09:23,230
give a broader type to the list in some

00:09:19,750 --> 00:09:24,310
cases type inference won't be enough to

00:09:23,230 --> 00:09:25,840
understand the type of every variable

00:09:24,310 --> 00:09:27,370
for instance if we create an empty

00:09:25,840 --> 00:09:29,320
container the type checker doesn't know

00:09:27,370 --> 00:09:33,340
what we intend to put into it so it asks

00:09:29,320 --> 00:09:34,900
us to be explicit we can add a type

00:09:33,340 --> 00:09:36,820
annotation for the variable like this

00:09:34,900 --> 00:09:38,830
and say this is intended to be a list of

00:09:36,820 --> 00:09:41,860
strings then the type checker is happy

00:09:38,830 --> 00:09:43,540
this particular syntax with a colon

00:09:41,860 --> 00:09:45,700
after the variable name then the type

00:09:43,540 --> 00:09:47,980
annotation before the equals sign is new

00:09:45,700 --> 00:09:49,750
in Python 3 6 if you're on an older

00:09:47,980 --> 00:09:52,510
version there's an alternative comment

00:09:49,750 --> 00:09:56,950
based syntax you can use I won't go over

00:09:52,510 --> 00:10:00,190
it here but it's in the documentation so

00:09:56,950 --> 00:10:01,960
that's pretty much the basics to review

00:10:00,190 --> 00:10:03,490
what we've covered mostly you want to

00:10:01,960 --> 00:10:06,000
annotate your function signatures the

00:10:03,490 --> 00:10:07,870
arguments and the return values and

00:10:06,000 --> 00:10:09,580
occasionally you might have to annotate

00:10:07,870 --> 00:10:11,640
a variable but usually you only want to

00:10:09,580 --> 00:10:15,040
do this if the type checker asks you to

00:10:11,640 --> 00:10:16,870
otherwise you'll end up with a bunch of

00:10:15,040 --> 00:10:17,950
redundant variable annotations for

00:10:16,870 --> 00:10:25,930
things the type checker could have

00:10:17,950 --> 00:10:28,360
inferred correctly anyway so let's go a

00:10:25,930 --> 00:10:30,340
little deeper sometimes we write

00:10:28,360 --> 00:10:32,710
functions that can take or return more

00:10:30,340 --> 00:10:34,030
than one type we can handle this the

00:10:32,710 --> 00:10:36,280
simplest way to handle this is with a

00:10:34,030 --> 00:10:38,740
union type so for this function it could

00:10:36,280 --> 00:10:40,510
return a foo or a bar so we annotate the

00:10:38,740 --> 00:10:42,550
return type as a union of foo and bar

00:10:40,510 --> 00:10:45,130
that means it could return either a foo

00:10:42,550 --> 00:10:47,140
or a bar very common case of this is a

00:10:45,130 --> 00:10:49,810
function that can return something or

00:10:47,140 --> 00:10:53,440
none it's so common in fact that there's

00:10:49,810 --> 00:10:55,750
a special form for that optional foo

00:10:53,440 --> 00:10:57,970
means the same thing as union of foo and

00:10:55,750 --> 00:11:02,020
none this function could return a foo or

00:10:57,970 --> 00:11:03,300
it could return a none so here we have a

00:11:02,020 --> 00:11:06,779
function

00:11:03,300 --> 00:11:08,430
foo that takes a foo ID which is an

00:11:06,779 --> 00:11:10,260
optional integer either an integer or

00:11:08,430 --> 00:11:11,450
none and returns an optional foo either

00:11:10,260 --> 00:11:15,630
a foo or none

00:11:11,450 --> 00:11:17,970
so let's get a few instance my foo and

00:11:15,630 --> 00:11:20,970
let's access that's ID oops we have a

00:11:17,970 --> 00:11:22,380
type error because we told the type

00:11:20,970 --> 00:11:24,570
checker that this function could return

00:11:22,380 --> 00:11:26,610
none and we didn't check whether my foo

00:11:24,570 --> 00:11:29,010
was in fact a none so accessing the ID

00:11:26,610 --> 00:11:31,079
attribute could be an attribute error at

00:11:29,010 --> 00:11:33,630
runtime so we get an error from the type

00:11:31,079 --> 00:11:35,610
checker this illustrates why you want to

00:11:33,630 --> 00:11:38,370
avoid using unions and optionals

00:11:35,610 --> 00:11:41,070
particularly as return types because

00:11:38,370 --> 00:11:43,880
every time if your function returns a

00:11:41,070 --> 00:11:46,290
Union or optional every caller has to

00:11:43,880 --> 00:11:48,959
check what they got back before they can

00:11:46,290 --> 00:11:51,180
safely make use of the return value in

00:11:48,959 --> 00:11:53,010
this case though that's a sad outcome if

00:11:51,180 --> 00:11:55,800
we look at the code forget foo we can

00:11:53,010 --> 00:11:57,750
see that if we give it a none it will

00:11:55,800 --> 00:12:01,140
always return none if we give it an

00:11:57,750 --> 00:12:02,279
integer it will always return a foo so

00:12:01,140 --> 00:12:03,930
we know that but the type checker

00:12:02,279 --> 00:12:05,670
doesn't so even though we call it with

00:12:03,930 --> 00:12:07,620
an integer the type checker thinks the

00:12:05,670 --> 00:12:10,020
return value might be none and this is

00:12:07,620 --> 00:12:12,000
going to cause us to have to add extra

00:12:10,020 --> 00:12:13,860
redundant checks into our code that are

00:12:12,000 --> 00:12:16,290
useless at runtime just to satisfy the

00:12:13,860 --> 00:12:18,329
type checker there's a better option in

00:12:16,290 --> 00:12:20,490
this case using the overload decorator

00:12:18,329 --> 00:12:22,079
from the typing module we can give the

00:12:20,490 --> 00:12:23,430
type checker more information about the

00:12:22,079 --> 00:12:27,029
invariants of our function for instance

00:12:23,430 --> 00:12:29,579
we can say overload allows a kind of

00:12:27,029 --> 00:12:32,100
pattern matching similar to overloaded

00:12:29,579 --> 00:12:35,279
functions in other languages so you can

00:12:32,100 --> 00:12:37,850
say in this case if foo ID is none then

00:12:35,279 --> 00:12:40,800
the return value will always be none if

00:12:37,850 --> 00:12:43,890
foo ID is an integer the return type

00:12:40,800 --> 00:12:45,779
will always be foo and then lastly we

00:12:43,890 --> 00:12:47,370
give the actual definition of get foo

00:12:45,779 --> 00:12:50,190
now it's important to note that there's

00:12:47,370 --> 00:12:51,660
nothing there's no kind of dynamic

00:12:50,190 --> 00:12:53,160
dispatch or anything happening here at

00:12:51,660 --> 00:12:54,930
runtime this is purely additional

00:12:53,160 --> 00:12:56,640
information for the type checker at

00:12:54,930 --> 00:12:59,250
runtime the only thing that's used is

00:12:56,640 --> 00:13:00,839
the final definition of get foo that's

00:12:59,250 --> 00:13:02,730
why the other two you don't need a body

00:13:00,839 --> 00:13:04,199
they can just use pass they're just

00:13:02,730 --> 00:13:06,720
additional information for the type

00:13:04,199 --> 00:13:08,339
checker to better understand the type

00:13:06,720 --> 00:13:12,500
invariants that are actually implemented

00:13:08,339 --> 00:13:15,060
by the function so with this definition

00:13:12,500 --> 00:13:16,560
if we call get through none the type

00:13:15,060 --> 00:13:17,030
checker will understand that the return

00:13:16,560 --> 00:13:19,220
value

00:13:17,030 --> 00:13:20,840
none and if we call get through with an

00:13:19,220 --> 00:13:23,030
integer it will understand that the

00:13:20,840 --> 00:13:24,650
return value is a foo and so we won't

00:13:23,030 --> 00:13:32,810
have to check before we access its ID

00:13:24,650 --> 00:13:33,860
attribute or whatever else another way

00:13:32,810 --> 00:13:36,560
that we can make the type checker

00:13:33,860 --> 00:13:39,710
smarter about understanding our code is

00:13:36,560 --> 00:13:42,260
generic functions so to define a generic

00:13:39,710 --> 00:13:43,790
function we can define a type variable

00:13:42,260 --> 00:13:45,770
which is like a placeholder for a type

00:13:43,790 --> 00:13:48,530
so here we define a type variable called

00:13:45,770 --> 00:13:50,870
any string which is a placeholder for

00:13:48,530 --> 00:13:53,180
either string or bytes type variables

00:13:50,870 --> 00:13:55,310
can be unbounded where they could match

00:13:53,180 --> 00:13:58,250
any type or in this case this type

00:13:55,310 --> 00:14:01,310
variable is as a bound of string and

00:13:58,250 --> 00:14:04,160
bytes so we can define a concatenate

00:14:01,310 --> 00:14:06,260
function that takes to any string and

00:14:04,160 --> 00:14:08,140
returns in any string and then

00:14:06,260 --> 00:14:10,700
concatenates them and returns the result

00:14:08,140 --> 00:14:12,800
now this is different from using a union

00:14:10,700 --> 00:14:14,870
of string and bytes because the type

00:14:12,800 --> 00:14:18,260
checker will ensure that the type

00:14:14,870 --> 00:14:21,970
variable is binds to the same type

00:14:18,260 --> 00:14:24,980
throughout any any call to the function

00:14:21,970 --> 00:14:26,960
so it will give us a type error if we

00:14:24,980 --> 00:14:29,360
try to call concat with a string and a

00:14:26,960 --> 00:14:33,410
bytes which is good because adding a

00:14:29,360 --> 00:14:35,030
string to a bytes as a type error and of

00:14:33,410 --> 00:14:36,800
course because the type variable is

00:14:35,030 --> 00:14:38,870
bound it will also give us a type error

00:14:36,800 --> 00:14:40,550
if we try to call concat with two

00:14:38,870 --> 00:14:44,300
objects that are neither string nor

00:14:40,550 --> 00:14:46,490
bytes and perhaps most importantly if we

00:14:44,300 --> 00:14:48,110
concatenate two strings together the

00:14:46,490 --> 00:14:50,060
type checker will understand that the

00:14:48,110 --> 00:14:52,160
return value must be a string not a

00:14:50,060 --> 00:14:53,660
string or a bytes and similarly with

00:14:52,160 --> 00:14:58,640
bytes we can catenate two bytes we

00:14:53,660 --> 00:15:00,620
definitely get a bytes back in fact this

00:14:58,640 --> 00:15:02,780
any string type variable is useful

00:15:00,620 --> 00:15:04,310
enough for defining functions that can

00:15:02,780 --> 00:15:05,720
handle strings or bytes that it's built

00:15:04,310 --> 00:15:07,220
into the typing module we don't need to

00:15:05,720 --> 00:15:14,600
define it ourselves we can just import

00:15:07,220 --> 00:15:17,230
it so to review again we can use unions

00:15:14,600 --> 00:15:19,520
and optionals but sparingly and

00:15:17,230 --> 00:15:21,260
overloads and jerax allow us to keep

00:15:19,520 --> 00:15:24,520
that each the type checker more about

00:15:21,260 --> 00:15:27,010
the invariance of our type signatures

00:15:24,520 --> 00:15:29,600
compared to using unions or optionals

00:15:27,010 --> 00:15:30,350
generics or overloads can make your

00:15:29,600 --> 00:15:31,940
functions much

00:15:30,350 --> 00:15:36,890
are usable for callers without needing

00:15:31,940 --> 00:15:39,620
redundant checks so at this point

00:15:36,890 --> 00:15:43,760
somebody might be wondering what about

00:15:39,620 --> 00:15:45,680
my ducks I like duck typing in this new

00:15:43,760 --> 00:15:47,300
type safe world how do I write a

00:15:45,680 --> 00:15:49,460
function that can take any type at all

00:15:47,300 --> 00:15:52,970
as long as it has the right methods and

00:15:49,460 --> 00:15:55,460
attributes for instance maybe I want to

00:15:52,970 --> 00:15:57,170
define a render a function that can take

00:15:55,460 --> 00:15:59,330
an object and will call its render

00:15:57,170 --> 00:16:02,030
method any object that defines a render

00:15:59,330 --> 00:16:03,820
method no matter its type this is

00:16:02,030 --> 00:16:06,470
actually similar to a number of built-in

00:16:03,820 --> 00:16:09,440
protocols in Python for instance the

00:16:06,470 --> 00:16:12,080
land' function glen built-in will call

00:16:09,440 --> 00:16:14,600
the dunder len method on on any object

00:16:12,080 --> 00:16:19,790
or the next built-in will call dunder

00:16:14,600 --> 00:16:21,680
next etc so how can I type this we could

00:16:19,790 --> 00:16:24,740
try to use object since we know that

00:16:21,680 --> 00:16:27,260
every object every type in Python is a

00:16:24,740 --> 00:16:31,640
subtype of object but this won't work

00:16:27,260 --> 00:16:33,500
object has no attribute render or we

00:16:31,640 --> 00:16:35,210
could try to use the any type the any

00:16:33,500 --> 00:16:37,460
type is a sort of escape hatch the

00:16:35,210 --> 00:16:39,320
typing system provides any type is

00:16:37,460 --> 00:16:41,030
compatible with anything in type system

00:16:39,320 --> 00:16:43,190
terms it's both the top type and a

00:16:41,030 --> 00:16:45,170
bottom type it's a sub type and a super

00:16:43,190 --> 00:16:47,000
type of everything or you could think of

00:16:45,170 --> 00:16:48,650
it as it has every attribute and method

00:16:47,000 --> 00:16:51,200
basically it will never cause a type

00:16:48,650 --> 00:16:54,080
error this makes our function type check

00:16:51,200 --> 00:16:55,580
okay but it's a bit sad because now we

00:16:54,080 --> 00:16:57,650
can pass in something that doesn't have

00:16:55,580 --> 00:16:59,330
a render method which will throw an

00:16:57,650 --> 00:17:01,010
error at runtime but the type checker

00:16:59,330 --> 00:17:02,390
won't catch it these are the kinds of

00:17:01,010 --> 00:17:06,890
bugs we want our type checker to catch

00:17:02,390 --> 00:17:08,780
for us so I mentioned that this this

00:17:06,890 --> 00:17:11,120
pattern is similar to built-in protocols

00:17:08,780 --> 00:17:13,310
in Python and the type system solution

00:17:11,120 --> 00:17:14,870
for it is also called protocol it's

00:17:13,310 --> 00:17:16,880
still technically experimental you have

00:17:14,870 --> 00:17:19,670
to pip install typing extensions and

00:17:16,880 --> 00:17:21,110
import it from typing extensions but in

00:17:19,670 --> 00:17:22,700
practice it's very unlikely to change

00:17:21,110 --> 00:17:25,730
and will soon be in the built-in typing

00:17:22,700 --> 00:17:27,890
module so if we import protocol we can

00:17:25,730 --> 00:17:31,340
define renderable as a subclass of

00:17:27,890 --> 00:17:32,720
protocol and give it a render method we

00:17:31,340 --> 00:17:34,400
don't need to provide a body for the

00:17:32,720 --> 00:17:37,280
method all we're giving here is an

00:17:34,400 --> 00:17:39,170
interface what matters is the attributes

00:17:37,280 --> 00:17:41,900
and their types and the methods and

00:17:39,170 --> 00:17:43,790
their type signatures so once we have

00:17:41,900 --> 00:17:44,419
this protocol defined we can say that

00:17:43,790 --> 00:17:46,639
our render method

00:17:44,419 --> 00:17:49,580
it takes an object of type renderable

00:17:46,639 --> 00:17:51,679
and then if we have some random class

00:17:49,580 --> 00:17:53,600
which has no explicit relationship to

00:17:51,679 --> 00:17:55,669
renderable simply because it has a

00:17:53,600 --> 00:17:57,830
render method with the correct signature

00:17:55,669 --> 00:18:00,619
the type checker will accept this call

00:17:57,830 --> 00:18:02,239
it will allow us to pass a foo object to

00:18:00,619 --> 00:18:04,700
a render method because it sees that it

00:18:02,239 --> 00:18:06,109
matches the protocol if we try to pass

00:18:04,700 --> 00:18:08,210
some other object without a render

00:18:06,109 --> 00:18:12,049
method we'll get a type error so this is

00:18:08,210 --> 00:18:12,909
exactly what we want and we found our

00:18:12,049 --> 00:18:15,769
duck

00:18:12,909 --> 00:18:18,109
you might hear this feature also

00:18:15,769 --> 00:18:21,619
referred to as structural subtyping so

00:18:18,109 --> 00:18:23,509
with typical inheritance we have nominal

00:18:21,619 --> 00:18:25,669
subtyping because if foo inherits Bar

00:18:23,509 --> 00:18:27,769
we've named our super tight bar so

00:18:25,669 --> 00:18:30,139
that's nominal subtyping with structural

00:18:27,769 --> 00:18:32,330
subtyping foo is a subtype of renderable

00:18:30,139 --> 00:18:33,679
because it matches the structure of

00:18:32,330 --> 00:18:36,019
renderable it has the same attributes

00:18:33,679 --> 00:18:41,509
and methods so that's structural

00:18:36,019 --> 00:18:44,419
subtyping so strict static typing tends

00:18:41,509 --> 00:18:45,799
to be really good for like 90 to 95% of

00:18:44,419 --> 00:18:49,129
your code that's pretty straightforward

00:18:45,799 --> 00:18:51,769
it's not doing anything too dynamic if

00:18:49,129 --> 00:18:53,840
you're writing production code or

00:18:51,769 --> 00:18:55,129
production application you probably want

00:18:53,840 --> 00:18:56,539
most of your code to be like this

00:18:55,129 --> 00:19:00,109
because it's also going to be easier for

00:18:56,539 --> 00:19:01,970
your co-workers to read and maintain but

00:19:00,109 --> 00:19:04,070
there may still be those few cases where

00:19:01,970 --> 00:19:05,899
you really do want to take advantage of

00:19:04,070 --> 00:19:07,609
pythons dynamic nature you really do

00:19:05,899 --> 00:19:09,139
want a meta class or to generate a bunch

00:19:07,609 --> 00:19:11,600
of classes on the fly or whatever other

00:19:09,139 --> 00:19:13,489
off-the-wall thing you might be doing or

00:19:11,600 --> 00:19:14,899
like us at Instagram you may have a lot

00:19:13,489 --> 00:19:16,820
of legacy code that was written long

00:19:14,899 --> 00:19:18,470
before type-checking existed and you

00:19:16,820 --> 00:19:20,539
need to continue supporting that code

00:19:18,470 --> 00:19:22,159
even if it's doing some things that

00:19:20,539 --> 00:19:25,399
don't quite fit into the static typing

00:19:22,159 --> 00:19:27,259
world so pythons type system feels that

00:19:25,399 --> 00:19:28,789
pain and provide some escape hatches

00:19:27,259 --> 00:19:30,200
that you can use when you really just

00:19:28,789 --> 00:19:34,879
need to tell the type checker to go take

00:19:30,200 --> 00:19:38,299
a hike so the first one we already saw

00:19:34,879 --> 00:19:40,460
it's the any type one sample case where

00:19:38,299 --> 00:19:42,109
you might use the any type is some kind

00:19:40,460 --> 00:19:43,850
of get attribute wrapping proxy where

00:19:42,109 --> 00:19:45,980
you're wrapping some object and proxying

00:19:43,850 --> 00:19:47,450
every attribute access you have no idea

00:19:45,980 --> 00:19:48,769
what you might be proxying or what

00:19:47,450 --> 00:19:50,779
attributes it might have or what their

00:19:48,769 --> 00:19:52,849
types are so maybe the best you can do

00:19:50,779 --> 00:19:55,009
is just say that your proxy returns any

00:19:52,849 --> 00:19:55,999
from its get attribute it's not great

00:19:55,009 --> 00:19:57,840
because it means you lose all the

00:19:55,999 --> 00:20:00,000
benefits of type checking

00:19:57,840 --> 00:20:03,920
those wrapped objects but in some cases

00:20:00,000 --> 00:20:03,920
it may be the best option you have a

00:20:05,150 --> 00:20:09,450
second escape hatch is the cast function

00:20:07,830 --> 00:20:10,770
it basically lets you lie to the type

00:20:09,450 --> 00:20:14,520
checker about the type of some

00:20:10,770 --> 00:20:16,950
expression so for example at Instagram

00:20:14,520 --> 00:20:20,120
we have a configuration system and we

00:20:16,950 --> 00:20:22,380
can get a configuration value by key and

00:20:20,120 --> 00:20:24,360
basically their JSON struck stare

00:20:22,380 --> 00:20:25,980
dictionaries or lists or whatever and we

00:20:24,360 --> 00:20:29,190
don't know what shape any given config

00:20:25,980 --> 00:20:31,800
far will have so the best that our get

00:20:29,190 --> 00:20:33,450
configure our function can do is be

00:20:31,800 --> 00:20:34,770
typed to return any because we don't

00:20:33,450 --> 00:20:38,310
know what shape of object it might

00:20:34,770 --> 00:20:40,530
return but in practice given a

00:20:38,310 --> 00:20:42,150
particular config it's some specific

00:20:40,530 --> 00:20:43,860
call site we probably do know what the

00:20:42,150 --> 00:20:45,180
shape of that config he will be

00:20:43,860 --> 00:20:47,220
otherwise we wouldn't be able to make

00:20:45,180 --> 00:20:49,260
use of it so we can use the cast

00:20:47,220 --> 00:20:51,090
function to tell the type checker look

00:20:49,260 --> 00:20:52,950
actually I know this function says it

00:20:51,090 --> 00:20:54,600
returns any but in this case I know it

00:20:52,950 --> 00:20:57,780
returns a dictionary mapping strings

00:20:54,600 --> 00:20:59,790
integers and the type checker will

00:20:57,780 --> 00:21:01,590
believe us so of course since you're

00:20:59,790 --> 00:21:02,850
lying to the type checker you want to

00:21:01,590 --> 00:21:04,080
make sure that you're right because if

00:21:02,850 --> 00:21:05,790
you lie to the type checker and you're

00:21:04,080 --> 00:21:09,840
wrong well you can expect the type

00:21:05,790 --> 00:21:11,570
checker to lie right back the third

00:21:09,840 --> 00:21:14,700
escape hatch is kind of a nuclear option

00:21:11,570 --> 00:21:17,160
type ignore says ignore any type error

00:21:14,700 --> 00:21:20,130
on this line no matter what the cause we

00:21:17,160 --> 00:21:22,320
try to reserve this one for bugs in the

00:21:20,130 --> 00:21:23,970
type checker or limitations of the type

00:21:22,320 --> 00:21:26,970
checker that we can't work around any

00:21:23,970 --> 00:21:28,320
other way so one example is my PI

00:21:26,970 --> 00:21:30,480
currently has a bug where it can't

00:21:28,320 --> 00:21:32,880
handle a property decorator stacked on

00:21:30,480 --> 00:21:34,500
top of another decorator so we just

00:21:32,880 --> 00:21:36,240
stick a type ignore on the line where it

00:21:34,500 --> 00:21:38,580
throws an error add an explanatory

00:21:36,240 --> 00:21:43,200
comment linking to the bug and move on

00:21:38,580 --> 00:21:45,870
so if the cast function is a way to lie

00:21:43,200 --> 00:21:47,100
to the type checker stub files or how

00:21:45,870 --> 00:21:50,610
you lie to the type checker at

00:21:47,100 --> 00:21:53,310
industrial-scale so at Instagram we use

00:21:50,610 --> 00:21:55,590
a lot of syphon and C extensions for

00:21:53,310 --> 00:21:57,000
performance hotspots and of course the

00:21:55,590 --> 00:21:58,920
type checker can't see into any of that

00:21:57,000 --> 00:22:01,470
code it can't read psyphon syntax it

00:21:58,920 --> 00:22:04,620
can't read C code of course so it has no

00:22:01,470 --> 00:22:07,650
idea what functions and classes are in

00:22:04,620 --> 00:22:10,200
our siphon or C code and what signatures

00:22:07,650 --> 00:22:11,220
they might have so for example say we

00:22:10,200 --> 00:22:14,070
have a fast math

00:22:11,220 --> 00:22:17,789
jool compiled module with some fast math

00:22:14,070 --> 00:22:19,049
functions in it and we won't if we put

00:22:17,789 --> 00:22:20,760
those functions in there it's probably

00:22:19,049 --> 00:22:22,289
because we call them a lot and if we

00:22:20,760 --> 00:22:23,640
call them a lot we'd really like our

00:22:22,289 --> 00:22:27,390
calls to them to be type checked of

00:22:23,640 --> 00:22:30,210
course so we can solve this problem by

00:22:27,390 --> 00:22:33,480
putting a py file next to the compiled

00:22:30,210 --> 00:22:35,190
module so py is Python interface it's

00:22:33,480 --> 00:22:37,740
sort of like a C header file but for

00:22:35,190 --> 00:22:39,960
Python code it just provides the type

00:22:37,740 --> 00:22:41,580
signatures the interfaces of our

00:22:39,960 --> 00:22:43,500
functions and classes that are in the

00:22:41,580 --> 00:22:45,809
compiled module so that the type checker

00:22:43,500 --> 00:22:48,360
is aware of them so for instance our

00:22:45,809 --> 00:22:51,030
fast math Pui if we had a square

00:22:48,360 --> 00:22:54,780
function in our compiled module we could

00:22:51,030 --> 00:22:57,360
put this this interface this definition

00:22:54,780 --> 00:22:59,159
line in our py file and now the type

00:22:57,360 --> 00:23:01,500
checker understands that fast math

00:22:59,159 --> 00:23:03,289
module has a square function that takes

00:23:01,500 --> 00:23:06,480
an integer and returns an integer

00:23:03,289 --> 00:23:08,250
similarly we could put class interfaces

00:23:06,480 --> 00:23:10,950
in there now it knows that we have a

00:23:08,250 --> 00:23:16,559
complex class with these two attributes

00:23:10,950 --> 00:23:18,150
of these types so now the type checker

00:23:16,559 --> 00:23:21,260
will be able to check the correctness of

00:23:18,150 --> 00:23:23,970
our uses of those functions and classes

00:23:21,260 --> 00:23:27,110
ok so that's the end of our tour through

00:23:23,970 --> 00:23:29,820
pythons type system last review here

00:23:27,110 --> 00:23:32,970
protocols are statically checked duck

00:23:29,820 --> 00:23:34,260
typing or structural typing and then we

00:23:32,970 --> 00:23:36,990
have a number of escape hatches that we

00:23:34,260 --> 00:23:38,789
can use if we need to escape from the

00:23:36,990 --> 00:23:45,179
restrictions of the type checker we can

00:23:38,789 --> 00:23:46,590
use any cast ignore stub files so we've

00:23:45,179 --> 00:23:48,500
talked about why you might want to type

00:23:46,590 --> 00:23:50,909
check and how you go about type checking

00:23:48,500 --> 00:23:53,159
lastly what do we mean by gradual typing

00:23:50,909 --> 00:23:54,720
and what does it matter we've actually

00:23:53,159 --> 00:23:57,120
already started talking about gradual

00:23:54,720 --> 00:23:59,520
typing so gradual typing just means you

00:23:57,120 --> 00:24:01,230
can type check your program even though

00:23:59,520 --> 00:24:02,909
not all expressions in the program are

00:24:01,230 --> 00:24:04,710
fully typed so when we look at something

00:24:02,909 --> 00:24:07,200
like the any type that's already an

00:24:04,710 --> 00:24:09,360
example of gradual typing but we can go

00:24:07,200 --> 00:24:11,669
beyond that gradual typing also allows

00:24:09,360 --> 00:24:13,950
us to incrementally add type checking to

00:24:11,669 --> 00:24:16,049
our code base as we're ready to deal

00:24:13,950 --> 00:24:17,340
with the consequences so for instance

00:24:16,049 --> 00:24:19,740
here's our code base bunch of Python

00:24:17,340 --> 00:24:22,470
modules arrows showing dependencies

00:24:19,740 --> 00:24:23,520
between the modules we introduce type

00:24:22,470 --> 00:24:24,530
checking and this is what we're gonna

00:24:23,520 --> 00:24:26,570
see

00:24:24,530 --> 00:24:28,220
errors everywhere it's not because the

00:24:26,570 --> 00:24:29,990
code is bad it's just the nature of

00:24:28,220 --> 00:24:32,510
introducing type-checking to a codebase

00:24:29,990 --> 00:24:33,590
that was never type check before but

00:24:32,510 --> 00:24:35,480
this is a problem we can't deal with

00:24:33,590 --> 00:24:37,730
this we have too much code too much to

00:24:35,480 --> 00:24:41,390
do we can't stop the world while we fix

00:24:37,730 --> 00:24:43,730
thousands of type errors so gradual

00:24:41,390 --> 00:24:45,980
typing in Python is implemented with a

00:24:43,730 --> 00:24:48,440
simple rule only functions with type

00:24:45,980 --> 00:24:50,690
annotations are checked a function that

00:24:48,440 --> 00:24:53,570
has no annotation is considered to take

00:24:50,690 --> 00:24:55,400
any return any and the body of it isn't

00:24:53,570 --> 00:24:56,660
even checked at all nothing inside the

00:24:55,400 --> 00:24:58,460
type checker won't even look at anything

00:24:56,660 --> 00:25:01,850
inside the body of a function without

00:24:58,460 --> 00:25:05,000
type annotations so this rule allows us

00:25:01,850 --> 00:25:05,900
to introduce type annotations where

00:25:05,000 --> 00:25:06,830
we're ready to deal with the

00:25:05,900 --> 00:25:09,320
consequences

00:25:06,830 --> 00:25:10,640
step by step function by function and of

00:25:09,320 --> 00:25:12,890
course there's a network effect as we

00:25:10,640 --> 00:25:16,310
add more and more type annotations so we

00:25:12,890 --> 00:25:18,140
annotate one module and we will catch

00:25:16,310 --> 00:25:19,820
some type errors in internal calls

00:25:18,140 --> 00:25:22,370
within that module maybe some calls to

00:25:19,820 --> 00:25:24,320
standard library functions and as we

00:25:22,370 --> 00:25:26,720
annotate more modules we'll be able to

00:25:24,320 --> 00:25:28,580
catch more and more type errors and

00:25:26,720 --> 00:25:29,990
calls between those modules and of

00:25:28,580 --> 00:25:31,880
course the number of errors we can catch

00:25:29,990 --> 00:25:35,330
increases super linearly with the

00:25:31,880 --> 00:25:37,910
network effect you'll want to start with

00:25:35,330 --> 00:25:39,680
your most used functions or modules

00:25:37,910 --> 00:25:43,060
because that's where you'll get the most

00:25:39,680 --> 00:25:44,840
immediate benefit from type checking and

00:25:43,060 --> 00:25:46,640
you'll want to use continuous

00:25:44,840 --> 00:25:48,530
integration to defend your progress once

00:25:46,640 --> 00:25:49,970
you've started adding type annotations

00:25:48,530 --> 00:25:51,470
and fixing type errors you really want

00:25:49,970 --> 00:25:53,630
to make sure that nobody's adding new

00:25:51,470 --> 00:25:54,890
type errors back into that same code so

00:25:53,630 --> 00:25:56,330
you'll want the type checker running in

00:25:54,890 --> 00:26:00,200
your continuous integration to prevent

00:25:56,330 --> 00:26:02,600
that my PI also provides a lot of

00:26:00,200 --> 00:26:04,970
options for various strictness levels

00:26:02,600 --> 00:26:07,580
and you can apply those options per

00:26:04,970 --> 00:26:09,530
module so once you have a module that's

00:26:07,580 --> 00:26:11,060
fully type checked all the functions are

00:26:09,530 --> 00:26:13,850
type annotated there's no type errors

00:26:11,060 --> 00:26:15,740
you can tell my PI don't allow any

00:26:13,850 --> 00:26:18,230
untyped function to be introduced into

00:26:15,740 --> 00:26:19,850
this module from now on and protect your

00:26:18,230 --> 00:26:21,890
progress that way you can even go one

00:26:19,850 --> 00:26:23,600
step further and say don't allow any

00:26:21,890 --> 00:26:25,040
usage of the any type within this module

00:26:23,600 --> 00:26:30,980
if you really wanted to keep it strictly

00:26:25,040 --> 00:26:33,170
typed so that's all great there's still

00:26:30,980 --> 00:26:35,570
a problem I mentioned at the beginning

00:26:33,170 --> 00:26:36,950
of the talk how painful it can be if you

00:26:35,570 --> 00:26:38,210
come back to code that you're not

00:26:36,950 --> 00:26:39,830
familiar with

00:26:38,210 --> 00:26:42,200
and you try to figure out what types

00:26:39,830 --> 00:26:43,610
some function can take and this may

00:26:42,200 --> 00:26:45,769
require digging through layers and

00:26:43,610 --> 00:26:47,059
layers of code to find all of the call

00:26:45,769 --> 00:26:48,950
sites of the call sites of the call

00:26:47,059 --> 00:26:51,649
sites it turns out that this painful

00:26:48,950 --> 00:26:53,899
process is exactly the same painful

00:26:51,649 --> 00:26:55,580
process that you have to go through when

00:26:53,899 --> 00:26:57,259
you're adding type annotations to code

00:26:55,580 --> 00:26:58,700
you're trying to look through it you're

00:26:57,259 --> 00:27:00,830
trying to understand what are the types

00:26:58,700 --> 00:27:02,600
what could be passed in here how do i

00:27:00,830 --> 00:27:03,889
type annotate this correctly how do I

00:27:02,600 --> 00:27:05,419
know if I am type annotating it

00:27:03,889 --> 00:27:06,769
correctly maybe I'm adding a type

00:27:05,419 --> 00:27:11,090
annotation but doesn't actually match

00:27:06,769 --> 00:27:12,710
what I'm doing in production so our CTO

00:27:11,090 --> 00:27:14,929
at Instagram Mike Krieger was actually

00:27:12,710 --> 00:27:16,519
the first person to dive into type

00:27:14,929 --> 00:27:18,740
annotations at the beginning of last

00:27:16,519 --> 00:27:20,659
year and tried annotating one of our big

00:27:18,740 --> 00:27:22,759
core modules a thousand lines of code or

00:27:20,659 --> 00:27:25,190
so and came back two weeks later and was

00:27:22,759 --> 00:27:27,559
like I'm done this is ridiculous

00:27:25,190 --> 00:27:30,139
so he suggested that maybe we could

00:27:27,559 --> 00:27:30,700
build something that would trace at

00:27:30,139 --> 00:27:33,049
runtime

00:27:30,700 --> 00:27:34,909
what types were being passed into all of

00:27:33,049 --> 00:27:36,679
our functions and then dump that

00:27:34,909 --> 00:27:38,570
information out in a really usable way

00:27:36,679 --> 00:27:40,850
to make it much easier to add accurate

00:27:38,570 --> 00:27:42,649
type annotations so a couple of us set

00:27:40,850 --> 00:27:45,259
out to built that and it turned out to

00:27:42,649 --> 00:27:46,759
work great and last fall we released it

00:27:45,259 --> 00:27:50,389
as open source so you can also use it

00:27:46,759 --> 00:27:52,279
it's called monkey type so an example of

00:27:50,389 --> 00:27:54,350
how you could use monkey type pip

00:27:52,279 --> 00:27:56,600
install monkey type of course and then

00:27:54,350 --> 00:27:58,249
you can use monkey type run to run any

00:27:56,600 --> 00:27:59,990
script it could be your tests or it

00:27:58,249 --> 00:28:01,909
could be any other script that exercises

00:27:59,990 --> 00:28:04,519
your code or there's even ways you can

00:28:01,909 --> 00:28:05,960
install it to run in production which is

00:28:04,519 --> 00:28:07,730
what we do at Instagram we sample a

00:28:05,960 --> 00:28:10,419
small percentage of production requests

00:28:07,730 --> 00:28:12,710
and run them under monkey type tracing

00:28:10,419 --> 00:28:15,230
once you've collected some data using

00:28:12,710 --> 00:28:17,509
monkey type run monkey type tracing then

00:28:15,230 --> 00:28:19,909
you can run monkey type stub some module

00:28:17,509 --> 00:28:22,460
and it will print out a stub file just

00:28:19,909 --> 00:28:24,710
like the pyi files we saw earlier that's

00:28:22,460 --> 00:28:27,019
directly usable and it will show exactly

00:28:24,710 --> 00:28:29,720
what types were recorded at runtime when

00:28:27,019 --> 00:28:31,610
your code ran and then if you want to go

00:28:29,720 --> 00:28:33,919
further you can use monkey type apply

00:28:31,610 --> 00:28:35,869
and take that stub and it will apply it

00:28:33,919 --> 00:28:37,820
to your code and rewrite your code with

00:28:35,869 --> 00:28:41,149
the type annotations applied then you

00:28:37,820 --> 00:28:45,690
can review that commit it and your type

00:28:41,149 --> 00:28:46,769
annotated so

00:28:45,690 --> 00:28:50,340
what's coming next in the world of

00:28:46,769 --> 00:28:54,870
Python typing we already mentioned yeah

00:28:50,340 --> 00:28:56,750
in in Python 3.7 there will be a future

00:28:54,870 --> 00:28:59,519
import that will allow you to get rid of

00:28:56,750 --> 00:29:00,840
some ugly string forward references that

00:28:59,519 --> 00:29:02,789
are currently necessary when you have

00:29:00,840 --> 00:29:04,850
circular type references in your code so

00:29:02,789 --> 00:29:06,870
that's one thing that's coming

00:29:04,850 --> 00:29:09,899
potentially in the future this isn't for

00:29:06,870 --> 00:29:11,460
sure yet but we may be able to also get

00:29:09,899 --> 00:29:13,139
rid of some of these extra imports from

00:29:11,460 --> 00:29:15,029
the typing module like the capital D

00:29:13,139 --> 00:29:16,860
dict and instead just use the lowercase

00:29:15,029 --> 00:29:20,159
Indic that's already built in in our

00:29:16,860 --> 00:29:22,350
type annotations there's also a pep that

00:29:20,159 --> 00:29:23,490
was recently accepted for a standard for

00:29:22,350 --> 00:29:25,500
how to bundle type stubs with

00:29:23,490 --> 00:29:27,480
third-party packages which will make it

00:29:25,500 --> 00:29:31,940
much easier to distribute type

00:29:27,480 --> 00:29:31,940
annotations with your libraries on IPI

00:29:32,750 --> 00:29:36,750
conclusions from our experience at

00:29:34,710 --> 00:29:39,059
instagram over the last year type check

00:29:36,750 --> 00:29:40,769
python is here it works there are some

00:29:39,059 --> 00:29:45,139
warts still but it's been very

00:29:40,769 --> 00:29:48,299
productive for us in production use we

00:29:45,139 --> 00:29:50,100
prevent landing diffs in our code base

00:29:48,299 --> 00:29:52,289
if they have type errors so we're using

00:29:50,100 --> 00:29:55,259
type check Python actively in

00:29:52,289 --> 00:29:58,019
development everyday our experience also

00:29:55,259 --> 00:30:00,269
is that developers love it we've

00:29:58,019 --> 00:30:01,980
received basically no pushback from

00:30:00,269 --> 00:30:03,480
anyone in our team of hundreds of

00:30:01,980 --> 00:30:06,240
developers working on our Python code

00:30:03,480 --> 00:30:07,860
base and our type coverage has grown

00:30:06,240 --> 00:30:09,210
almost entirely organically as

00:30:07,860 --> 00:30:11,009
developers choose to add type

00:30:09,210 --> 00:30:13,169
annotations because they see the

00:30:11,009 --> 00:30:16,500
benefits of reading and maintaining code

00:30:13,169 --> 00:30:19,230
that has annotations using monkey type

00:30:16,500 --> 00:30:21,509
you can annotate large legacy code bases

00:30:19,230 --> 00:30:22,980
we've gone from 0 to about half of our

00:30:21,509 --> 00:30:25,850
million and half lines of Python code

00:30:22,980 --> 00:30:30,090
annotated over the last eight months

00:30:25,850 --> 00:30:32,309
mostly by using Monkey type so it's

00:30:30,090 --> 00:30:35,009
early days it's far from perfect but it

00:30:32,309 --> 00:30:36,450
is good enough for use and it will get

00:30:35,009 --> 00:30:40,500
better in the future it's being actively

00:30:36,450 --> 00:30:42,509
worked on a few thanks before I go to

00:30:40,500 --> 00:30:43,799
the team at Dropbox for creating and

00:30:42,509 --> 00:30:46,470
maintaining my PI which has been a

00:30:43,799 --> 00:30:47,940
critical tool for us and to everyone in

00:30:46,470 --> 00:30:50,659
the Python community who's contributed

00:30:47,940 --> 00:30:53,549
to writing and reviewing typing peps I

00:30:50,659 --> 00:30:55,769
should mention quick we did recently

00:30:53,549 --> 00:30:58,019
switch at Instagram from my PI to a new

00:30:55,769 --> 00:30:59,520
type checker Peyer that was developed by

00:30:58,019 --> 00:31:01,410
a team at Facebook

00:30:59,520 --> 00:31:03,750
because it's faster for very large code

00:31:01,410 --> 00:31:05,760
bases so if you have a very large code

00:31:03,750 --> 00:31:08,870
base or you want to experiment with

00:31:05,760 --> 00:31:12,060
alternatives you can also try pyre for

00:31:08,870 --> 00:31:13,380
our code base my Pi took about five and

00:31:12,060 --> 00:31:15,060
a half minutes and pyre takes about

00:31:13,380 --> 00:31:18,810
forty five seconds for a full from

00:31:15,060 --> 00:31:20,280
scratch type check if you're working

00:31:18,810 --> 00:31:21,780
with type check Python there's lots of

00:31:20,280 --> 00:31:24,840
resources available I won't list them

00:31:21,780 --> 00:31:26,730
all out loud in detail but both for my

00:31:24,840 --> 00:31:28,590
PI and for pyre and for the reference

00:31:26,730 --> 00:31:32,460
standards and there's real-time support

00:31:28,590 --> 00:31:36,420
and get er the pepp places you can file

00:31:32,460 --> 00:31:40,590
issues monkey type issues on github as

00:31:36,420 --> 00:31:43,140
well and that's it if you would like to

00:31:40,590 --> 00:31:44,760
follow up with me afterwards and explain

00:31:43,140 --> 00:31:47,280
to me the many failings of this talk I

00:31:44,760 --> 00:31:49,140
would welcome that I'm Carl jam on

00:31:47,280 --> 00:31:50,700
almost everywhere except of course on

00:31:49,140 --> 00:31:54,840
Instagram itself where I was too late to

00:31:50,700 --> 00:31:56,100
the game and yeah I'll be taking

00:31:54,840 --> 00:31:57,480
questions outside in the hallway after

00:31:56,100 --> 00:31:59,200
the talk if you want to chat I'd love to

00:31:57,480 --> 00:32:09,150
talk to you thank you very much

00:31:59,200 --> 00:32:09,150

YouTube URL: https://www.youtube.com/watch?v=pMgmKJyWKn8


