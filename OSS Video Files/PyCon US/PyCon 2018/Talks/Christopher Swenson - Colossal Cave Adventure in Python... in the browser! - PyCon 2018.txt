Title: Christopher Swenson - Colossal Cave Adventure in Python... in the browser! - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Christopher Swenson

Colossal Cave, also known as Adventure or ADVENT, is the original text adventure. It was written in FORTRAN IV and there is practically no way to run the original program without translating it. We'll explore software archeology to write a Python interpreter to run the FORTRAN code as-is, without translating it. Come learn about pre-ASCII and 36-bit integers and writing interpreters in Python!

And, we'll show how to use BeeWare's Batavia Python interpreter (in JavaScript) to execute the program. FORTRAN IV in Python in JavaScript in your browser!

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:09,889 --> 00:00:16,500
for a last talk of the morning we have

00:00:13,670 --> 00:00:20,490
something that promises to be full of

00:00:16,500 --> 00:00:23,039
fun and adventure please join me in

00:00:20,490 --> 00:00:25,670
welcoming Christopher Swanson with

00:00:23,039 --> 00:00:27,990
Colossal Cave adventure and pipe in

00:00:25,670 --> 00:00:38,670
Python of course this is a Python

00:00:27,990 --> 00:00:41,219
conference in the browser okay like she

00:00:38,670 --> 00:00:42,510
said my name is Christopher Swenson and

00:00:41,219 --> 00:00:45,450
we'll be talking about Colossal Cave

00:00:42,510 --> 00:00:48,059
adventure so what exactly are we talking

00:00:45,450 --> 00:00:49,350
about Colossal Cave adventure is I'll

00:00:48,059 --> 00:00:50,700
get to some of the details in minute but

00:00:49,350 --> 00:00:53,820
it's one of the first text adventures

00:00:50,700 --> 00:00:55,320
ever made it's written in Fortran for

00:00:53,820 --> 00:01:00,300
for the pdp-10 which was a mainframe

00:00:55,320 --> 00:01:02,010
like 1960s and 70s era mainframe and I

00:01:00,300 --> 00:01:05,670
wrote a Python interpreter to interpret

00:01:02,010 --> 00:01:07,560
that and also interpreted that in

00:01:05,670 --> 00:01:09,030
JavaScript but we'll get to that

00:01:07,560 --> 00:01:10,409
it's talks for everyone there's not I

00:01:09,030 --> 00:01:12,840
mean there's a lot of code in it but

00:01:10,409 --> 00:01:14,909
it's Fortran code mostly so no one can

00:01:12,840 --> 00:01:17,640
read it it doesn't matter it's like it's

00:01:14,909 --> 00:01:21,060
a really old Fortran code it's great and

00:01:17,640 --> 00:01:22,320
the slides are available on github I'll

00:01:21,060 --> 00:01:25,020
leave that up there for just a second

00:01:22,320 --> 00:01:30,000
yeah it's it's on my github Swensen is

00:01:25,020 --> 00:01:31,409
my is my username yeah so some

00:01:30,000 --> 00:01:32,970
alternative titles for this talk I

00:01:31,409 --> 00:01:35,130
thought were is this is sort of like

00:01:32,970 --> 00:01:36,900
being lazy in the hardest way possible

00:01:35,130 --> 00:01:38,659
like which I'll get to exactly why that

00:01:36,900 --> 00:01:40,680
is it's also a programming turducken

00:01:38,659 --> 00:01:44,159
because there's just so many layers of

00:01:40,680 --> 00:01:47,810
really awful things put together forth

00:01:44,159 --> 00:01:50,970
on script or a full stack Fortran for

00:01:47,810 --> 00:01:53,159
Who am I so I'm Christopher Swenson I'm

00:01:50,970 --> 00:01:55,350
currently working at Twilio one of the

00:01:53,159 --> 00:01:56,939
sponsors I've previously worked at

00:01:55,350 --> 00:02:00,960
places like Google in the US government

00:01:56,939 --> 00:02:02,850
I am sometimes a beware core contributor

00:02:00,960 --> 00:02:04,649
beware is an open source project and

00:02:02,850 --> 00:02:06,229
I'll get to that how we use some of

00:02:04,649 --> 00:02:08,369
those components in this and

00:02:06,229 --> 00:02:10,170
occasionally organize a conference

00:02:08,369 --> 00:02:12,420
called PI DX which is a Portland Python

00:02:10,170 --> 00:02:14,330
conference probably not happening this

00:02:12,420 --> 00:02:16,940
year but it happened some years

00:02:14,330 --> 00:02:18,530
and I like programming and stuff like

00:02:16,940 --> 00:02:21,110
this is just sort of just random stuff

00:02:18,530 --> 00:02:23,470
so so the motivation for this was when

00:02:21,110 --> 00:02:26,570
you start a Tullio you sort of have to

00:02:23,470 --> 00:02:29,210
create a project with a Tullio api as

00:02:26,570 --> 00:02:30,230
you're like as like a starter project

00:02:29,210 --> 00:02:31,070
like something you do like your first

00:02:30,230 --> 00:02:33,020
couple of weeks you're there or

00:02:31,070 --> 00:02:34,940
something like that and so I was like

00:02:33,020 --> 00:02:37,190
well that sounds like fun but maybe I

00:02:34,940 --> 00:02:39,110
want to do some sort of game and Twilio

00:02:37,190 --> 00:02:40,850
as main api's or like text messaging and

00:02:39,110 --> 00:02:42,620
voice calls and things like that and so

00:02:40,850 --> 00:02:44,750
I was like I want to make a game with

00:02:42,620 --> 00:02:47,090
text messages and like what kind of game

00:02:44,750 --> 00:02:49,100
am I gonna make well obviously I should

00:02:47,090 --> 00:02:50,780
make a text adventure right because

00:02:49,100 --> 00:02:53,180
that's the most straightforward sort of

00:02:50,780 --> 00:02:54,200
game but again I'm really lazy and so I

00:02:53,180 --> 00:02:55,460
didn't want to actually write a whole

00:02:54,200 --> 00:02:57,530
new game from scratch because that just

00:02:55,460 --> 00:02:59,330
sounds tiring so why not why don't I

00:02:57,530 --> 00:03:01,760
just take the first text adventure ever

00:02:59,330 --> 00:03:04,940
made and poured it into Twilio and like

00:03:01,760 --> 00:03:06,140
so that you can use it with SMS and so I

00:03:04,940 --> 00:03:07,820
thought I would do that how hard can it

00:03:06,140 --> 00:03:11,060
be to like read some old Fortran code

00:03:07,820 --> 00:03:12,740
and run it that's where adventure comes

00:03:11,060 --> 00:03:15,560
in sometimes called colossal cave or

00:03:12,740 --> 00:03:17,420
Colossal Cave adventure it is a text

00:03:15,560 --> 00:03:19,490
adventure written probably about 1976

00:03:17,420 --> 00:03:22,730
the first version we have source code

00:03:19,490 --> 00:03:24,680
for is from 1977 it was probably the

00:03:22,730 --> 00:03:26,360
first text adventure there's some

00:03:24,680 --> 00:03:28,460
contention around that but definitely

00:03:26,360 --> 00:03:30,290
one of the very first extremely

00:03:28,460 --> 00:03:31,520
addictive games like this is the first

00:03:30,290 --> 00:03:33,860
time I've ever read reports of people

00:03:31,520 --> 00:03:35,720
like missing classes in college because

00:03:33,860 --> 00:03:37,430
they were so like into a game and like

00:03:35,720 --> 00:03:39,680
you know stayed up all night kind of

00:03:37,430 --> 00:03:41,120
things it was extremely popular and

00:03:39,680 --> 00:03:44,210
influential it launched like a whole

00:03:41,120 --> 00:03:47,270
genre of adventure games and I wrote it

00:03:44,210 --> 00:03:48,980
in sorry what I did not write it it was

00:03:47,270 --> 00:03:51,470
written way before my time in Fortran

00:03:48,980 --> 00:03:53,750
for for the pdp-10 mainframe like I said

00:03:51,470 --> 00:03:55,730
if you want to play it now you can text

00:03:53,750 --> 00:03:58,190
that number right there plus one six six

00:03:55,730 --> 00:04:00,050
nine two three eight three six eight

00:03:58,190 --> 00:04:02,210
three and you can play it on your phone

00:04:00,050 --> 00:04:04,190
like it will send a text message to my

00:04:02,210 --> 00:04:06,020
server my server will like load up the

00:04:04,190 --> 00:04:07,250
code and then like run it until it

00:04:06,020 --> 00:04:08,960
outputs something and send you the

00:04:07,250 --> 00:04:10,820
response back and then like you can play

00:04:08,960 --> 00:04:12,500
it like a normal game you can also play

00:04:10,820 --> 00:04:14,930
it in the browser and I'll get to how I

00:04:12,500 --> 00:04:18,590
made that magic happen later that awful

00:04:14,930 --> 00:04:20,030
awful magic and yeah and also I'll share

00:04:18,590 --> 00:04:22,340
that link again but yeah that's the

00:04:20,030 --> 00:04:24,229
number yeah it'll probably like way

00:04:22,340 --> 00:04:25,430
overload the server if everybody texts

00:04:24,229 --> 00:04:26,860
right now because the code is very

00:04:25,430 --> 00:04:29,710
inefficient but

00:04:26,860 --> 00:04:31,930
you know it works and so how does a

00:04:29,710 --> 00:04:34,210
venture start so typically whenever you

00:04:31,930 --> 00:04:35,680
started up you see you know this this

00:04:34,210 --> 00:04:37,060
little message here somewhere nearby as

00:04:35,680 --> 00:04:40,090
colossal K where others have found

00:04:37,060 --> 00:04:41,710
fortunes and treasure and gold and so

00:04:40,090 --> 00:04:42,909
forth whatnot use commands of one or two

00:04:41,710 --> 00:04:45,099
words like these sort of like very

00:04:42,909 --> 00:04:46,689
classic text adventure words it also

00:04:45,099 --> 00:04:48,729
like I literally did not change the

00:04:46,689 --> 00:04:51,039
source code even one tiny bits of typos

00:04:48,729 --> 00:04:53,110
and all and it still tells you to send

00:04:51,039 --> 00:04:54,699
complaints and suggestions to Crowther

00:04:53,110 --> 00:04:56,050
who's guy named will Crowther who wrote

00:04:54,699 --> 00:04:58,509
it back in the 70s I don't recommend

00:04:56,050 --> 00:05:00,039
bothering him he is still around but I

00:04:58,509 --> 00:05:01,569
don't think he cares to hear your

00:05:00,039 --> 00:05:05,289
complaints anymore about this game from

00:05:01,569 --> 00:05:06,460
41 years ago and you can type help for

00:05:05,289 --> 00:05:08,770
hints and then it gives you like a

00:05:06,460 --> 00:05:10,919
little description of where you are and

00:05:08,770 --> 00:05:16,210
then you enter in commands and play it

00:05:10,919 --> 00:05:17,740
pretty straightforward yeah what does

00:05:16,210 --> 00:05:19,629
the pdp-10 peeped in like I said as a

00:05:17,740 --> 00:05:20,590
mainframe it's made by the Digital

00:05:19,629 --> 00:05:22,870
Equipment Corporation

00:05:20,590 --> 00:05:27,219
I think the first versions were in 1966

00:05:22,870 --> 00:05:29,560
or 67 or so and then they kept making it

00:05:27,219 --> 00:05:31,479
for about 15 years or so so it's very

00:05:29,560 --> 00:05:33,039
popular a lot of games a lot of the

00:05:31,479 --> 00:05:34,900
first computer games are written on it

00:05:33,039 --> 00:05:37,750
because it was a big time shared system

00:05:34,900 --> 00:05:39,310
that a lot of people could use yeah and

00:05:37,750 --> 00:05:42,279
it took up like a whole rooms it was a

00:05:39,310 --> 00:05:43,960
big computer and Fortran for for the

00:05:42,279 --> 00:05:46,060
pdp-10 is like we're talking like all

00:05:43,960 --> 00:05:47,319
these classic programmer things you

00:05:46,060 --> 00:05:50,050
thought you would never see again

00:05:47,319 --> 00:05:51,460
like all caps everything is all caps no

00:05:50,050 --> 00:05:53,770
recursion you can't have recursion

00:05:51,460 --> 00:05:55,330
because it doesn't like Fortran for just

00:05:53,770 --> 00:05:58,210
couldn't do recursion just doesn't

00:05:55,330 --> 00:06:00,490
support it indentation is like a it's

00:05:58,210 --> 00:06:02,259
like it doesn't matter like you can

00:06:00,490 --> 00:06:03,069
indent but it did nobody did because it

00:06:02,259 --> 00:06:05,169
doesn't matter and you'd waste

00:06:03,069 --> 00:06:06,639
punch-card space because punch cards

00:06:05,169 --> 00:06:09,400
worse this is still designed for punch

00:06:06,639 --> 00:06:11,439
cards spaces don't matter like you can

00:06:09,400 --> 00:06:13,060
remove every space from the program and

00:06:11,439 --> 00:06:16,539
it will still compile just fine for the

00:06:13,060 --> 00:06:18,699
most part and I think tabs are a little

00:06:16,539 --> 00:06:19,779
weird like they're like six spaces or

00:06:18,699 --> 00:06:22,060
something I don't know they're really

00:06:19,779 --> 00:06:24,219
strange it sort of doesn't matter but I

00:06:22,060 --> 00:06:25,629
think there's six spaces and there's

00:06:24,219 --> 00:06:28,089
line numbers like you need line numbers

00:06:25,629 --> 00:06:30,129
to do pretty much any kind of branching

00:06:28,089 --> 00:06:34,029
logic although they are technically

00:06:30,129 --> 00:06:34,959
optional for everything else so like

00:06:34,029 --> 00:06:37,270
what does this look like we're gonna see

00:06:34,959 --> 00:06:38,529
a bit of Fortran code now it looks quite

00:06:37,270 --> 00:06:40,480
a bit different than I think like we

00:06:38,529 --> 00:06:41,950
probably are used to seeing any code now

00:06:40,480 --> 00:06:45,250
like Python code or anything like that

00:06:41,950 --> 00:06:47,440
but you can sort of like see the core

00:06:45,250 --> 00:06:50,170
programming things there if the line

00:06:47,440 --> 00:06:51,490
starts with C it means the comment or an

00:06:50,170 --> 00:06:53,920
asterisk I think it also works for that

00:06:51,490 --> 00:06:56,520
you have like some defining some

00:06:53,920 --> 00:06:59,050
implicit variables this is all defining

00:06:56,520 --> 00:07:00,790
defining variables although ran I think

00:06:59,050 --> 00:07:03,790
is a random number generator function

00:07:00,790 --> 00:07:05,800
that's specific to the pdp-10 I couldn't

00:07:03,790 --> 00:07:07,210
find a lot of documentation on it so I

00:07:05,800 --> 00:07:10,540
just guessed on how to implement it it

00:07:07,210 --> 00:07:12,790
seems to work yeah you can see like it

00:07:10,540 --> 00:07:14,860
has multi-dimensional arrays and it has

00:07:12,790 --> 00:07:17,200
line continuations you see like this 1 2

00:07:14,860 --> 00:07:19,270
3 4 or 5 on the side there that means

00:07:17,200 --> 00:07:21,330
that that's actually one long line that

00:07:19,270 --> 00:07:23,500
just has all those declarations in it

00:07:21,330 --> 00:07:25,090
that's pretty common and actually like

00:07:23,500 --> 00:07:27,610
some documentation seems to imply that

00:07:25,090 --> 00:07:29,440
that should come slightly before the

00:07:27,610 --> 00:07:31,090
beginning of the line but the source

00:07:29,440 --> 00:07:33,970
code that I have puts it at the

00:07:31,090 --> 00:07:35,830
beginning of the line instead so the

00:07:33,970 --> 00:07:38,230
source code may look like look like that

00:07:35,830 --> 00:07:39,850
or like this it's not a hundred percent

00:07:38,230 --> 00:07:41,020
clear what it what it really should look

00:07:39,850 --> 00:07:45,160
like or what it might have looked like

00:07:41,020 --> 00:07:46,630
on the punch cards column 6 yeah well

00:07:45,160 --> 00:07:49,030
column 6 is definitely the specification

00:07:46,630 --> 00:07:50,800
but it has tabs at the beginning of the

00:07:49,030 --> 00:07:53,440
source file that I have and I didn't

00:07:50,800 --> 00:07:55,750
touch anything so be a column 6 is where

00:07:53,440 --> 00:08:00,160
the code starts columns 1 through 5 are

00:07:55,750 --> 00:08:02,140
the line number yeah things like that so

00:08:00,160 --> 00:08:04,090
here's some more setup code so read the

00:08:02,140 --> 00:08:06,100
parameters this is like where like a

00:08:04,090 --> 00:08:09,280
basic if statements says like you know

00:08:06,100 --> 00:08:10,960
if dot any so they this is met before we

00:08:09,280 --> 00:08:14,770
had like keyboards like we have today so

00:08:10,960 --> 00:08:18,040
you had to do any dot or dot X or dot or

00:08:14,770 --> 00:08:19,660
dot and dot like none of this fancy like

00:08:18,040 --> 00:08:22,720
ampersand character those didn't exist

00:08:19,660 --> 00:08:24,250
yet so you had to use head use all that

00:08:22,720 --> 00:08:25,600
yet use go-to statements if you wanted

00:08:24,250 --> 00:08:28,450
to do more than one thing on an if

00:08:25,600 --> 00:08:30,880
statement so and then you had some

00:08:28,450 --> 00:08:32,860
simple variable declaration they're not

00:08:30,880 --> 00:08:34,660
declarations but assignments there it

00:08:32,860 --> 00:08:37,330
also supported some really kind of

00:08:34,660 --> 00:08:38,800
powerful ways of defining like arrays so

00:08:37,330 --> 00:08:40,660
you could initialize a whole array at

00:08:38,800 --> 00:08:44,770
once using this kind of strange slash

00:08:40,660 --> 00:08:46,660
syntax that's kind of cool you can do

00:08:44,770 --> 00:08:49,180
simple loops so it didn't really have

00:08:46,660 --> 00:08:51,340
while or for but it had do so you could

00:08:49,180 --> 00:08:53,410
just say do and then until you tell at

00:08:51,340 --> 00:08:55,949
the end line that you want 1,001

00:08:53,410 --> 00:08:58,690
and I'm gonna execute this for 300 times

00:08:55,949 --> 00:09:01,000
with I set to that each time and then

00:08:58,690 --> 00:09:04,690
you do each of those in turn and then

00:09:01,000 --> 00:09:06,129
when you're done you the last line that

00:09:04,690 --> 00:09:07,660
it's execute will be 1001 and then a

00:09:06,129 --> 00:09:09,910
little skip to the next line whenever

00:09:07,660 --> 00:09:13,269
it's completely done so this is just

00:09:09,910 --> 00:09:15,879
setting all the arrays to 0 so 0 moving

00:09:13,269 --> 00:09:19,480
out everything before it reads in data

00:09:15,879 --> 00:09:22,149
from a tape and the way you read in data

00:09:19,480 --> 00:09:24,730
is you have to do it in two lines so you

00:09:22,149 --> 00:09:27,819
have read one is like the it's sort of

00:09:24,730 --> 00:09:30,220
like the UNIX will decide UNIX but it's

00:09:27,819 --> 00:09:31,870
it's like the file number like device

00:09:30,220 --> 00:09:34,110
number or something so one I believe is

00:09:31,870 --> 00:09:36,790
tape drive in this particular system

00:09:34,110 --> 00:09:39,370
1003 says you're going to use the format

00:09:36,790 --> 00:09:41,350
defined on line 1003 and read it into

00:09:39,370 --> 00:09:47,649
this variable I kind and the format

00:09:41,350 --> 00:09:49,180
gee-gees naturally stands for integer so

00:09:47,649 --> 00:09:52,060
computed go-to is one of my favorites

00:09:49,180 --> 00:09:54,339
because it's really just very strange to

00:09:52,060 --> 00:09:55,629
like our modern eyes but it like a super

00:09:54,339 --> 00:09:57,250
convenient for the things like this so

00:09:55,629 --> 00:09:59,709
what it says is it takes it says take I

00:09:57,250 --> 00:10:02,470
kind plus one take the value of that and

00:09:59,709 --> 00:10:04,720
if it's like 1 2 3 4 or 5 or 6 or

00:10:02,470 --> 00:10:07,389
however many that is then it will go to

00:10:04,720 --> 00:10:10,569
the line number specified by that index

00:10:07,389 --> 00:10:13,000
so if I kind plus 1 is 1 then it'll go

00:10:10,569 --> 00:10:14,829
to 1,100 and if it's 2 then it's one

00:10:13,000 --> 00:10:16,889
thousand four and so forth so it's sort

00:10:14,829 --> 00:10:21,009
of like a like little quick jump table

00:10:16,889 --> 00:10:23,860
that's kind of cool so reading data can

00:10:21,009 --> 00:10:25,180
also be pretty complicated like so again

00:10:23,860 --> 00:10:27,490
it says the same basic format but you

00:10:25,180 --> 00:10:29,709
can also mix variables and like arrays

00:10:27,490 --> 00:10:33,250
of things and then specify that I want

00:10:29,709 --> 00:10:37,029
to read in 1 integer and then 20 ASCII

00:10:33,250 --> 00:10:39,819
words and word is like five letters

00:10:37,029 --> 00:10:42,220
we'll get to all that you can do

00:10:39,819 --> 00:10:44,199
subroutine calling so subroutines are

00:10:42,220 --> 00:10:45,939
really strange though so they you don't

00:10:44,199 --> 00:10:48,100
just pass parameters in but because of

00:10:45,939 --> 00:10:50,290
the way Fortran 4 thinks of subroutines

00:10:48,100 --> 00:10:53,319
you can also pass things back so you're

00:10:50,290 --> 00:10:55,000
calling it with 65 1 0 and then yay and

00:10:53,319 --> 00:10:56,769
then yeah is actually going to return a

00:10:55,000 --> 00:10:58,689
value because you're specifying a

00:10:56,769 --> 00:11:01,209
variable instead of a literal value so

00:10:58,689 --> 00:11:04,930
we can return things to as you can see

00:11:01,209 --> 00:11:06,189
here's the subroutine itself yeah it's

00:11:04,930 --> 00:11:07,120
it's it's a little strange you can also

00:11:06,189 --> 00:11:09,010
reuse line

00:11:07,120 --> 00:11:12,100
numbers inside of subroutines which is

00:11:09,010 --> 00:11:13,180
kind of confusing but you know make some

00:11:12,100 --> 00:11:14,680
sort of sense once you get used to it

00:11:13,180 --> 00:11:17,140
you can see it actually assigning a

00:11:14,680 --> 00:11:18,970
equal one and a equal to and passing it

00:11:17,140 --> 00:11:20,050
back we can start to see how like all

00:11:18,970 --> 00:11:21,580
this is kind of coming together

00:11:20,050 --> 00:11:24,130
fortunate for is not particularly

00:11:21,580 --> 00:11:26,680
complicated I'd say like each each piece

00:11:24,130 --> 00:11:28,960
of it isn't but it kind of is a mess to

00:11:26,680 --> 00:11:31,900
read sometimes when we're so used to

00:11:28,960 --> 00:11:34,570
things like indentation and you know

00:11:31,900 --> 00:11:38,350
like loops like that aren't just

00:11:34,570 --> 00:11:39,810
manually done okay so I talked a little

00:11:38,350 --> 00:11:43,360
bit about like how there were like 20

00:11:39,810 --> 00:11:46,180
ASCII words there so before before about

00:11:43,360 --> 00:11:49,720
1980 or so people weren't really sure

00:11:46,180 --> 00:11:52,660
exactly what a byte or what a word meant

00:11:49,720 --> 00:11:54,580
so it could be 8 bits it could be 16 it

00:11:52,660 --> 00:11:57,460
could be 64 are all over the place now

00:11:54,580 --> 00:12:00,060
but before that like Dec was really

00:11:57,460 --> 00:12:02,710
known for using 12 bit or 36 bit words

00:12:00,060 --> 00:12:04,630
and they defined I think the pdp-10

00:12:02,710 --> 00:12:07,390
manual said that a byte is any

00:12:04,630 --> 00:12:10,720
collection of bits between 1 and 36 so

00:12:07,390 --> 00:12:12,880
like I don't know and they sometimes use

00:12:10,720 --> 00:12:15,400
32 bit and like they're VAX I think so

00:12:12,880 --> 00:12:17,290
the pdp-10 used 36 bit words and they

00:12:15,400 --> 00:12:21,430
did it did technically come out after

00:12:17,290 --> 00:12:23,529
ASCII so it does use ASCII sort of it's

00:12:21,430 --> 00:12:26,020
it's mostly about the ASCII we would

00:12:23,529 --> 00:12:28,120
recognize today but it had it had some

00:12:26,020 --> 00:12:31,540
weirdness in it and then they packed it

00:12:28,120 --> 00:12:32,830
into a 36 bit word five letters at a

00:12:31,540 --> 00:12:33,880
time and they had one left over at the

00:12:32,830 --> 00:12:35,709
end but you can see there's like a

00:12:33,880 --> 00:12:37,839
little zero hanging off but they packed

00:12:35,709 --> 00:12:40,690
them left to right inside of a ward so

00:12:37,839 --> 00:12:43,630
you can see how ABCDE would be packed in

00:12:40,690 --> 00:12:46,089
so it also Fortran four doesn't really

00:12:43,630 --> 00:12:48,490
have types everything is an integer and

00:12:46,089 --> 00:12:51,520
so even an ASCII word and ASCII like

00:12:48,490 --> 00:12:52,810
five letter word is an integer it's just

00:12:51,520 --> 00:12:54,700
like you're just having shorthand

00:12:52,810 --> 00:12:56,860
between the two and so it doesn't really

00:12:54,700 --> 00:12:58,800
matter what you put it in you could put

00:12:56,860 --> 00:13:02,709
it as an integer or as a where's a five

00:12:58,800 --> 00:13:03,040
five letter word there why why does this

00:13:02,709 --> 00:13:05,020
matter

00:13:03,040 --> 00:13:07,390
well because Fortran four also does not

00:13:05,020 --> 00:13:09,130
have like a built-in library and so the

00:13:07,390 --> 00:13:11,650
code has to actually parse the user

00:13:09,130 --> 00:13:13,420
input itself and this code is amazing by

00:13:11,650 --> 00:13:14,500
the way like I spent a long time like

00:13:13,420 --> 00:13:15,910
staring at this code trying to

00:13:14,500 --> 00:13:17,770
understand what in the world is going on

00:13:15,910 --> 00:13:18,400
like and how is this parsing it and it's

00:13:17,770 --> 00:13:21,080
really beautiful

00:13:18,400 --> 00:13:22,820
I love how quotes indicate this is an

00:13:21,080 --> 00:13:24,440
kettle number right this is something

00:13:22,820 --> 00:13:28,070
you don't see nowadays like obviously

00:13:24,440 --> 00:13:29,990
quotes mean octal right and then it goes

00:13:28,070 --> 00:13:31,820
through and it reads in a bunch of words

00:13:29,990 --> 00:13:33,980
at a time and then it tries to split

00:13:31,820 --> 00:13:35,720
them up by spaces and you can sort of

00:13:33,980 --> 00:13:38,360
see like this really strange like

00:13:35,720 --> 00:13:40,280
shifting mask structure in there and

00:13:38,360 --> 00:13:42,980
what I found out what that's doing is it

00:13:40,280 --> 00:13:46,760
is looking for the ASCII space character

00:13:42,980 --> 00:13:48,410
which is hex 20 or so so or 32 I think

00:13:46,760 --> 00:13:51,440
is the decimal number so it's actually

00:13:48,410 --> 00:13:53,390
like going through like chunks of chunks

00:13:51,440 --> 00:13:55,580
in them at a time and looking for the

00:13:53,390 --> 00:13:58,070
space character and then trying to split

00:13:55,580 --> 00:13:59,750
it based on that and it's I could I

00:13:58,070 --> 00:14:01,250
could have a whole talk probably just on

00:13:59,750 --> 00:14:03,470
looking at this function and how just

00:14:01,250 --> 00:14:05,900
neat it is and like how like almost

00:14:03,470 --> 00:14:09,830
elegantly beautiful it is and completely

00:14:05,900 --> 00:14:10,940
incomprehensible at first glance you

00:14:09,830 --> 00:14:12,350
know so that's one of my favorite pieces

00:14:10,940 --> 00:14:15,170
of code it's a little maybe hard to read

00:14:12,350 --> 00:14:19,040
but it's your support rank code lots of

00:14:15,170 --> 00:14:20,240
Fortran okay so that's sort of like most

00:14:19,040 --> 00:14:22,280
the Fortran code I'm going to talk about

00:14:20,240 --> 00:14:24,260
I think so if you kind of a feel for

00:14:22,280 --> 00:14:27,440
what we're dealing with here

00:14:24,260 --> 00:14:28,910
and so my project was I'm going to again

00:14:27,440 --> 00:14:31,340
take all this Fortran code and I just

00:14:28,910 --> 00:14:34,370
want to run it as is naturally this code

00:14:31,340 --> 00:14:36,560
is is so like in a such an old Fortran

00:14:34,370 --> 00:14:38,750
for variant and specifically written for

00:14:36,560 --> 00:14:41,930
the pdp-10 that you can't just compile

00:14:38,750 --> 00:14:43,700
it with GCC or or F 77 or something like

00:14:41,930 --> 00:14:46,040
that and expect anything to come out so

00:14:43,700 --> 00:14:49,250
I had to write a compiler from scratch

00:14:46,040 --> 00:14:50,390
which seems like a fun thing to me so if

00:14:49,250 --> 00:14:52,850
you if you're familiar with how a normal

00:14:50,390 --> 00:14:55,820
compiler would work you normally like

00:14:52,850 --> 00:14:57,410
scan the text in two tokens you parse

00:14:55,820 --> 00:14:59,000
those tokens into like a syntax tree

00:14:57,410 --> 00:15:00,650
there's some other talks they've talked

00:14:59,000 --> 00:15:02,630
about this I think this weekend you

00:15:00,650 --> 00:15:04,250
optimize the syntax tree to try to speed

00:15:02,630 --> 00:15:06,200
things up and remove dead pieces and

00:15:04,250 --> 00:15:08,630
stuff and then you generate or execute

00:15:06,200 --> 00:15:10,490
the code but that that all sounds way to

00:15:08,630 --> 00:15:11,960
a card like I'm doing this for like a

00:15:10,490 --> 00:15:13,430
fun little work project I've only got a

00:15:11,960 --> 00:15:15,410
couple of days I don't got time for all

00:15:13,430 --> 00:15:17,150
that compiler nonsense like that sounds

00:15:15,410 --> 00:15:19,070
like a whole semesters worth of work and

00:15:17,150 --> 00:15:22,100
ain't nobody got time for that

00:15:19,070 --> 00:15:23,600
so the Swensen general strategy for

00:15:22,100 --> 00:15:25,910
coding up a really quick and dirty

00:15:23,600 --> 00:15:27,800
compiler is to split all the lines out

00:15:25,910 --> 00:15:30,020
and then you split each of the lines by

00:15:27,800 --> 00:15:31,460
whitespace and commas and parens just

00:15:30,020 --> 00:15:32,570
using like the little python split

00:15:31,460 --> 00:15:33,820
function like that we're not gonna make

00:15:32,570 --> 00:15:36,130
this too hard

00:15:33,820 --> 00:15:37,870
and then check like try to just parse

00:15:36,130 --> 00:15:39,880
that line and then execute it as it is

00:15:37,870 --> 00:15:41,949
like just kind of just hack it until it

00:15:39,880 --> 00:15:43,209
works like this is a one-off this is not

00:15:41,949 --> 00:15:44,290
going to be a general Fortran for

00:15:43,209 --> 00:15:46,389
interpreter this is just meant to run

00:15:44,290 --> 00:15:48,639
this one program it doesn't have to be

00:15:46,389 --> 00:15:51,630
perfect as long as it you know

00:15:48,639 --> 00:15:53,529
technically works good enough for me

00:15:51,630 --> 00:15:55,779
whenever writing a quick and dirty

00:15:53,529 --> 00:15:58,329
compiler I recommend named tuple named

00:15:55,779 --> 00:16:00,160
tuple is just your best friend like you

00:15:58,329 --> 00:16:02,709
can just use it to quickly generate like

00:16:00,160 --> 00:16:04,750
a little class that has like a bunch of

00:16:02,709 --> 00:16:06,820
fields in it so like every line is

00:16:04,750 --> 00:16:08,470
either a comment or it has a label maybe

00:16:06,820 --> 00:16:09,820
or it's a continuation line and then

00:16:08,470 --> 00:16:11,980
otherwise it just as much a statements

00:16:09,820 --> 00:16:13,209
on it and that's that's all it is and so

00:16:11,980 --> 00:16:15,760
I just say I want to create a class that

00:16:13,209 --> 00:16:17,470
just contains those fields so that I can

00:16:15,760 --> 00:16:19,269
easily use it and create them and pass

00:16:17,470 --> 00:16:20,800
them around and things and ditto for

00:16:19,269 --> 00:16:22,779
when I go into the lexical analysis I'm

00:16:20,800 --> 00:16:24,430
gonna split them into tokens and tokens

00:16:22,779 --> 00:16:27,160
will have like a name and then like some

00:16:24,430 --> 00:16:29,910
stuff associated with them and so I sort

00:16:27,160 --> 00:16:33,010
of build my grammar based out of these

00:16:29,910 --> 00:16:34,329
named tuples so like if I have an if

00:16:33,010 --> 00:16:35,459
statement it's gonna have an expression

00:16:34,329 --> 00:16:37,540
and then it's gonna have a statement

00:16:35,459 --> 00:16:39,670
there's also one thing I didn't talk

00:16:37,540 --> 00:16:41,800
about much which is a numerical if which

00:16:39,670 --> 00:16:43,449
has an expression and then it has three

00:16:41,800 --> 00:16:45,940
statements it could execute or actually

00:16:43,449 --> 00:16:48,069
three labels that'll depending on if

00:16:45,940 --> 00:16:51,579
it's negative zero or positive sort of

00:16:48,069 --> 00:16:54,370
like the compare operator in Python and

00:16:51,579 --> 00:16:56,290
other places there's go-to which could

00:16:54,370 --> 00:16:59,440
have labels and maybe a choice if it's a

00:16:56,290 --> 00:17:00,730
computed go-to and then assignments and

00:16:59,440 --> 00:17:02,110
stuff like that and so forth like you

00:17:00,730 --> 00:17:03,970
can have basically all these different

00:17:02,110 --> 00:17:05,819
kinds of statements and I sort of define

00:17:03,970 --> 00:17:07,959
kind of a really rough grammar that way

00:17:05,819 --> 00:17:10,030
then I have to load the tape drive

00:17:07,959 --> 00:17:11,829
because remember this is pdp-10 like

00:17:10,030 --> 00:17:13,780
it's expecting to have the source code

00:17:11,829 --> 00:17:15,339
in like one tape drive and then maybe

00:17:13,780 --> 00:17:17,470
have the data and another or something

00:17:15,339 --> 00:17:19,240
like that or the the binary code in one

00:17:17,470 --> 00:17:21,490
tape drive and the data in another so

00:17:19,240 --> 00:17:23,380
you have to read all that in and then

00:17:21,490 --> 00:17:24,549
combine all the lines together because

00:17:23,380 --> 00:17:26,020
you have all those lines split out and

00:17:24,549 --> 00:17:27,970
there's those continuations and so you

00:17:26,020 --> 00:17:28,750
need to make longer lines then your

00:17:27,970 --> 00:17:32,910
80-column

00:17:28,750 --> 00:17:35,500
you know punch card could do and then so

00:17:32,910 --> 00:17:36,610
my lexical analysis is very basic I'm

00:17:35,500 --> 00:17:38,679
just going to give you some pieces of it

00:17:36,610 --> 00:17:40,179
here so it just goes through and it

00:17:38,679 --> 00:17:42,460
parses all the lines just using a

00:17:40,179 --> 00:17:44,620
standard a little comprehension there

00:17:42,460 --> 00:17:46,210
and then it goes through and checks to

00:17:44,620 --> 00:17:47,320
see if it's a comment it marks it as a

00:17:46,210 --> 00:17:48,790
comment and then

00:17:47,320 --> 00:17:50,320
kind of ignores it it checks to see if

00:17:48,790 --> 00:17:52,330
it has a label and it marks the label

00:17:50,320 --> 00:17:54,640
check to see if it's a continuation and

00:17:52,330 --> 00:17:56,950
then splits them all back together and

00:17:54,640 --> 00:17:58,270
then it returns the line so very basic

00:17:56,950 --> 00:18:02,050
there like this is a very

00:17:58,270 --> 00:18:05,920
straightforward way to split things into

00:18:02,050 --> 00:18:07,600
lines I'd say and then then it has to go

00:18:05,920 --> 00:18:09,250
through and do a basic execution so I

00:18:07,600 --> 00:18:11,050
kind of like skip almost all the rest of

00:18:09,250 --> 00:18:13,000
the of the compiler and just go straight

00:18:11,050 --> 00:18:16,600
to execution like whatever don't need

00:18:13,000 --> 00:18:18,280
don't need all those extra steps so we

00:18:16,600 --> 00:18:20,530
go through we execute the next statement

00:18:18,280 --> 00:18:21,940
and then the rest logic is basically

00:18:20,530 --> 00:18:24,250
like if the statement told us to go

00:18:21,940 --> 00:18:25,990
somewhere else like a go-to or if it

00:18:24,250 --> 00:18:28,210
ended a loop like if I'm in a do loop

00:18:25,990 --> 00:18:30,460
and I reach the last line and I'm done

00:18:28,210 --> 00:18:32,230
then I need to like pop something off

00:18:30,460 --> 00:18:34,330
the stack and then like retrace my steps

00:18:32,230 --> 00:18:36,850
to figure out where to go next

00:18:34,330 --> 00:18:38,020
and then when I execute the statement I

00:18:36,850 --> 00:18:40,570
basically just go through and say like

00:18:38,020 --> 00:18:44,170
is this an if and if it's an if executed

00:18:40,570 --> 00:18:46,090
just done like yeah nothing nothing too

00:18:44,170 --> 00:18:48,040
too fancy there just is it an if

00:18:46,090 --> 00:18:50,350
statement did it give me a boolean or an

00:18:48,040 --> 00:18:53,280
integer argument whenever I evaluate

00:18:50,350 --> 00:18:55,180
that expression and just do what it says

00:18:53,280 --> 00:18:56,620
very straightforward you evaluate

00:18:55,180 --> 00:18:59,170
expression if it's if it's a Python

00:18:56,620 --> 00:19:02,140
integer Python string then I just return

00:18:59,170 --> 00:19:03,700
it as is and then if it's an operator

00:19:02,140 --> 00:19:05,620
meaning like if it's like a plus or an

00:19:03,700 --> 00:19:07,180
and or an X or or something like that

00:19:05,620 --> 00:19:08,590
then I have to evaluate that like I have

00:19:07,180 --> 00:19:10,960
to convert all strings to decimal

00:19:08,590 --> 00:19:12,280
numbers and like add them together XOR

00:19:10,960 --> 00:19:13,900
them together and things like that and

00:19:12,280 --> 00:19:15,790
the rest of it just looks all like this

00:19:13,900 --> 00:19:17,620
like you know if if it's this operator

00:19:15,790 --> 00:19:20,980
then do this it's a next operator do

00:19:17,620 --> 00:19:22,420
that and then and then I do have to

00:19:20,980 --> 00:19:24,550
parse the things together so that I can

00:19:22,420 --> 00:19:27,250
take those lines and make sure that I'm

00:19:24,550 --> 00:19:29,500
converting them to like the ifs and the

00:19:27,250 --> 00:19:31,780
operators correctly and this is all just

00:19:29,500 --> 00:19:33,130
a bunch of really dirty hacks just to

00:19:31,780 --> 00:19:36,130
make sure that it works for this one

00:19:33,130 --> 00:19:37,840
program and then ever again so like in

00:19:36,130 --> 00:19:41,290
this case I know that every if statement

00:19:37,840 --> 00:19:43,390
starts with a F space or I F left

00:19:41,290 --> 00:19:45,040
parenthesis like you never uses like two

00:19:43,390 --> 00:19:48,040
spaces or anything like that and so I

00:19:45,040 --> 00:19:49,630
can just write my if parser specifically

00:19:48,040 --> 00:19:52,270
for this program even though this would

00:19:49,630 --> 00:19:53,920
not necessarily work in general so I

00:19:52,270 --> 00:19:55,390
parse it and then I have to match

00:19:53,920 --> 00:19:57,070
parentheses up to make sure that

00:19:55,390 --> 00:19:58,870
everything's good and then I have to

00:19:57,070 --> 00:20:01,300
check if it's a numerical if like I

00:19:58,870 --> 00:20:03,160
mentioned and then return it

00:20:01,300 --> 00:20:05,680
and the rest of them are all very

00:20:03,160 --> 00:20:08,080
similar just a bunch of dirty hacks so

00:20:05,680 --> 00:20:10,330
I'm going to all those printing is

00:20:08,080 --> 00:20:12,730
really fun so they have a type function

00:20:10,330 --> 00:20:15,190
or it's a type statement I guess you

00:20:12,730 --> 00:20:16,510
have to yeah basically just go through

00:20:15,190 --> 00:20:18,100
and it gives you a list of things to

00:20:16,510 --> 00:20:19,060
like print out and you have to print

00:20:18,100 --> 00:20:21,430
them out and it's probably like a

00:20:19,060 --> 00:20:23,680
variable or like an array of words that

00:20:21,430 --> 00:20:24,940
you have to print out I won't go into

00:20:23,680 --> 00:20:26,440
all that but you can tell there's a

00:20:24,940 --> 00:20:27,610
super high quality code because if I

00:20:26,440 --> 00:20:29,140
find something I don't understand I

00:20:27,610 --> 00:20:31,540
print and then I just exit just crash

00:20:29,140 --> 00:20:34,560
the whole program like sign of super

00:20:31,540 --> 00:20:37,120
high-quality production code here

00:20:34,560 --> 00:20:39,190
there's a an outer loop sort of that

00:20:37,120 --> 00:20:40,540
just executes things just over and over

00:20:39,190 --> 00:20:42,010
again while while while it's busy

00:20:40,540 --> 00:20:45,790
executing it'll just go and loop forever

00:20:42,010 --> 00:20:47,530
nothing nothing too fancy there it does

00:20:45,790 --> 00:20:49,810
have to accept keyboard input so

00:20:47,530 --> 00:20:52,240
normally a pdp-10 was hooked up to a

00:20:49,810 --> 00:20:53,680
line printer which was what the type

00:20:52,240 --> 00:20:55,750
function do like when it says type it

00:20:53,680 --> 00:20:58,240
means literally type it out onto like a

00:20:55,750 --> 00:20:59,440
printer and then the you've got a

00:20:58,240 --> 00:21:01,570
keyboard that you wouldn't put things

00:20:59,440 --> 00:21:05,650
into and so I have a simple little loop

00:21:01,570 --> 00:21:08,260
here that just converts user input from

00:21:05,650 --> 00:21:10,780
somewhere into a way that this Fortran

00:21:08,260 --> 00:21:12,130
code can then read it like it'll look

00:21:10,780 --> 00:21:15,600
for see if it needs to assign it to a

00:21:12,130 --> 00:21:15,600
variable or something along those lines

00:21:15,690 --> 00:21:19,300
so we need to have a tape which we

00:21:18,100 --> 00:21:21,700
already showed how we sort of load the

00:21:19,300 --> 00:21:24,040
tape and then any interface we write be

00:21:21,700 --> 00:21:25,600
it an SMS or in the browser needs to

00:21:24,040 --> 00:21:27,670
have to Whitney needs to have an input

00:21:25,600 --> 00:21:30,550
and output like which are assumed to be

00:21:27,670 --> 00:21:32,290
connected to like a teletype but as so

00:21:30,550 --> 00:21:34,120
as long as it sort of vaguely looks like

00:21:32,290 --> 00:21:35,980
a teletype then it should work and it

00:21:34,120 --> 00:21:38,320
turns out SMS looks sort of like a

00:21:35,980 --> 00:21:40,300
teletype like teletypes had like 80

00:21:38,320 --> 00:21:42,040
width columns and you could type in like

00:21:40,300 --> 00:21:44,410
a line at a time and hit enter this

00:21:42,040 --> 00:21:47,050
behaves almost exactly like SMS does SMS

00:21:44,410 --> 00:21:48,820
is actually more flexible so this is

00:21:47,050 --> 00:21:50,650
fine so I was like ok I can I can like

00:21:48,820 --> 00:21:53,650
write the basic engine and then I wrote

00:21:50,650 --> 00:21:55,450
a specific handler for flask that works

00:21:53,650 --> 00:21:56,920
on Heroku and then I can hook that up to

00:21:55,450 --> 00:21:58,870
Twilio and then basically it just

00:21:56,920 --> 00:22:01,720
translates text messages back and forth

00:21:58,870 --> 00:22:04,510
as teletype input and perfect there we

00:22:01,720 --> 00:22:06,250
go I also just happened to design it so

00:22:04,510 --> 00:22:08,380
that the state can be easily serialized

00:22:06,250 --> 00:22:10,030
so that you can have each phone number

00:22:08,380 --> 00:22:11,500
hat is playing a different game like

00:22:10,030 --> 00:22:12,640
every time you like go in and type

00:22:11,500 --> 00:22:14,650
something you'll be like oh this phone

00:22:12,640 --> 00:22:16,600
number has texted me before

00:22:14,650 --> 00:22:17,560
I'll just load up that that state and

00:22:16,600 --> 00:22:18,910
then they can continue playing where

00:22:17,560 --> 00:22:20,530
they left off so you can come back

00:22:18,910 --> 00:22:23,320
months later and still play the same

00:22:20,530 --> 00:22:24,340
game I'll show the little fastcap now

00:22:23,320 --> 00:22:26,440
it's pretty straightforward it has

00:22:24,340 --> 00:22:28,450
basically one method which is that you

00:22:26,440 --> 00:22:30,940
sent it in an SMS it has to pull apart

00:22:28,450 --> 00:22:32,680
and see like okay who's it from what did

00:22:30,940 --> 00:22:34,000
you type you can't type more than 20

00:22:32,680 --> 00:22:34,600
characters because you know this is a

00:22:34,000 --> 00:22:36,610
pdp-10

00:22:34,600 --> 00:22:38,110
so just strips that out and like you

00:22:36,610 --> 00:22:40,870
know converts it to all caps and stuff

00:22:38,110 --> 00:22:44,140
because again okay who needs more than

00:22:40,870 --> 00:22:46,330
all caps and then it goes through and

00:22:44,140 --> 00:22:48,400
checks the database for the state and

00:22:46,330 --> 00:22:50,020
then you know fetches it it checks to

00:22:48,400 --> 00:22:51,670
see if you're asking it to reset or quit

00:22:50,020 --> 00:22:52,990
because if you get stuck somewhere in

00:22:51,670 --> 00:22:54,970
the game or you die then you need to

00:22:52,990 --> 00:22:56,590
reset and start over so you have to have

00:22:54,970 --> 00:22:58,750
a way to do that so we have to delete

00:22:56,590 --> 00:22:59,740
the state then and then if nothing else

00:22:58,750 --> 00:23:01,900
has happened then it means we're

00:22:59,740 --> 00:23:04,440
starting a new game and so we start a

00:23:01,900 --> 00:23:07,090
new game by like booting one up and then

00:23:04,440 --> 00:23:09,610
yeah setting up a new state inside of it

00:23:07,090 --> 00:23:10,960
and then you know again super high

00:23:09,610 --> 00:23:12,340
quality code here just sleeping one

00:23:10,960 --> 00:23:14,710
millisecond at a time until the game's

00:23:12,340 --> 00:23:16,900
finished booting you know having a nice

00:23:14,710 --> 00:23:22,300
little while while while dot times sleep

00:23:16,900 --> 00:23:23,830
there perfect code do that always and

00:23:22,300 --> 00:23:25,540
then again like once it's once it's

00:23:23,830 --> 00:23:27,580
finished spinning up and you like give

00:23:25,540 --> 00:23:29,440
it input you have to then like wait for

00:23:27,580 --> 00:23:33,280
the game to respond with something and

00:23:29,440 --> 00:23:34,720
so you just again wait time dot sleep

00:23:33,280 --> 00:23:36,580
it's fine

00:23:34,720 --> 00:23:40,240
and then yeah lots of time dot sleep

00:23:36,580 --> 00:23:41,680
super high quality and then and then

00:23:40,240 --> 00:23:44,380
this is a simple little execution to

00:23:41,680 --> 00:23:45,940
like get the code sorry get the state in

00:23:44,380 --> 00:23:47,320
and out there so either you're updating

00:23:45,940 --> 00:23:50,650
it because they just did something or

00:23:47,320 --> 00:23:53,710
you're yeah or inserting it because it's

00:23:50,650 --> 00:23:55,300
the first thing they did and of course

00:23:53,710 --> 00:23:56,830
so again super high quality code here

00:23:55,300 --> 00:23:58,720
the state is just a big dictionary

00:23:56,830 --> 00:24:01,450
did we just pickle and then compress and

00:23:58,720 --> 00:24:04,120
stick in the database like it's fine

00:24:01,450 --> 00:24:05,410
like nothing nothing wrong with pickling

00:24:04,120 --> 00:24:07,810
things and put them in a database and

00:24:05,410 --> 00:24:09,640
like unhandled you know like user input

00:24:07,810 --> 00:24:11,830
that we never check for knots it's all

00:24:09,640 --> 00:24:13,720
good like whatever it's just like like

00:24:11,830 --> 00:24:15,400
twelve kilobytes or something like just

00:24:13,720 --> 00:24:16,000
in a row in a database like there's

00:24:15,400 --> 00:24:17,770
nothing wrong with that

00:24:16,000 --> 00:24:21,130
oh yeah that's how good programmers

00:24:17,770 --> 00:24:23,080
program right because that was that was

00:24:21,130 --> 00:24:25,180
the sort of text messaging version was

00:24:23,080 --> 00:24:26,650
this little like flask app and stuff but

00:24:25,180 --> 00:24:28,419
I wanted I also have this in the browser

00:24:26,650 --> 00:24:30,309
because the texting is

00:24:28,419 --> 00:24:32,559
fun but it also overloads my server very

00:24:30,309 --> 00:24:34,600
easily and so my next step was like how

00:24:32,559 --> 00:24:36,100
can how can I take this beautiful

00:24:34,600 --> 00:24:38,200
perfect code and make it even more

00:24:36,100 --> 00:24:40,539
beautiful and perfect and I was like I

00:24:38,200 --> 00:24:42,999
know how I'm gonna throw it into the

00:24:40,539 --> 00:24:46,090
browser and how do I do that oh beware

00:24:42,999 --> 00:24:50,379
is a really nice suite of tools that

00:24:46,090 --> 00:24:51,970
lets you run code run Python it's its

00:24:50,379 --> 00:24:53,769
goal I guess has to run Python code

00:24:51,970 --> 00:24:55,899
anywhere so you can run it in the

00:24:53,769 --> 00:24:58,059
browser you can run it in the JVM you

00:24:55,899 --> 00:24:59,470
can build gooeys with native feels

00:24:58,059 --> 00:25:01,149
look and feels in them so there's a lot

00:24:59,470 --> 00:25:02,830
of different components to beware but

00:25:01,149 --> 00:25:05,499
the beware piece that I wanted to use

00:25:02,830 --> 00:25:08,919
was Batavia Batavia is the component

00:25:05,499 --> 00:25:12,460
that execute Python byte code in an

00:25:08,919 --> 00:25:13,960
interpreter written in JavaScript so

00:25:12,460 --> 00:25:15,759
that you can run it in Python or in the

00:25:13,960 --> 00:25:17,980
or so you can run it in the browser or a

00:25:15,759 --> 00:25:19,210
node.js if you want but generally you

00:25:17,980 --> 00:25:21,759
want to run it in the browser so that

00:25:19,210 --> 00:25:23,649
you could basically just theoretically

00:25:21,759 --> 00:25:26,259
in the future maybe just say like script

00:25:23,649 --> 00:25:27,909
text equals or script type equals text

00:25:26,259 --> 00:25:29,950
slash Python and just like run Python

00:25:27,909 --> 00:25:30,489
code and magically it'll work that's the

00:25:29,950 --> 00:25:32,470
dream

00:25:30,489 --> 00:25:35,739
the ship is sailing towards that dream

00:25:32,470 --> 00:25:36,940
Batavia is the name of the ship there's

00:25:35,739 --> 00:25:44,109
a funny story behind it that I never

00:25:36,940 --> 00:25:45,609
remember it crashed but yeah so the yeah

00:25:44,109 --> 00:25:47,830
it runs it in a so there's a Python

00:25:45,609 --> 00:25:49,859
bytecode interpreter basically it's it's

00:25:47,830 --> 00:25:53,080
a reimplementation of the python vm in

00:25:49,859 --> 00:25:54,460
javascript and it technically works

00:25:53,080 --> 00:25:56,559
which is the most important part

00:25:54,460 --> 00:26:00,749
technically working is the best kind of

00:25:56,559 --> 00:26:02,830
working so it just it just barely works

00:26:00,749 --> 00:26:05,320
so there's some challenges though to

00:26:02,830 --> 00:26:06,730
make it work so so far Batavia is still

00:26:05,320 --> 00:26:09,789
I think it's still very early stages I'm

00:26:06,730 --> 00:26:11,559
a contributor to it and it still has

00:26:09,789 --> 00:26:13,659
some issues like the first way we design

00:26:11,559 --> 00:26:15,850
did JavaScript and Python concurrency is

00:26:13,659 --> 00:26:18,549
like don't don't make any sense together

00:26:15,850 --> 00:26:20,739
at all like javascript is like this big

00:26:18,549 --> 00:26:22,239
callback mess like it expects you to

00:26:20,739 --> 00:26:24,009
like execute a little bit of code and

00:26:22,239 --> 00:26:25,899
then give us something a callback and

00:26:24,009 --> 00:26:27,519
then it will return like and then you

00:26:25,899 --> 00:26:29,320
sort of just follow a million callbacks

00:26:27,519 --> 00:26:32,230
all over the place forever and that way

00:26:29,320 --> 00:26:33,879
the JavaScript VM can interrupt you and

00:26:32,230 --> 00:26:35,320
like switch which callbacks that's

00:26:33,879 --> 00:26:36,759
executing at various times and that's

00:26:35,320 --> 00:26:38,559
how it sort of gets concurrency and

00:26:36,759 --> 00:26:39,940
Python doesn't expect that Python

00:26:38,559 --> 00:26:40,980
expects to be like running just a big

00:26:39,940 --> 00:26:42,900
chunk of code

00:26:40,980 --> 00:26:44,370
and for the VM to just interrupt it

00:26:42,900 --> 00:26:47,520
constantly like without it doing a

00:26:44,370 --> 00:26:50,070
callback and if you the way we did this

00:26:47,520 --> 00:26:52,710
initially was sort of like we just

00:26:50,070 --> 00:26:54,630
called Python code like as a JavaScript

00:26:52,710 --> 00:26:56,130
function and then that function would

00:26:54,630 --> 00:26:58,200
just like never return and so the code

00:26:56,130 --> 00:26:59,309
would just lock up or seem to lock up

00:26:58,200 --> 00:27:02,610
and you wouldn't you like your browser

00:26:59,309 --> 00:27:04,049
would hang and that's no fun so we sort

00:27:02,610 --> 00:27:05,429
of I sort of just hacked that to make

00:27:04,049 --> 00:27:07,020
that work for this talk like I figured

00:27:05,429 --> 00:27:09,630
out a way to add asynchronous callbacks

00:27:07,020 --> 00:27:11,370
into JavaScript in a way that just it

00:27:09,630 --> 00:27:12,870
sort of it technically works it

00:27:11,370 --> 00:27:16,440
technically works could also be a title

00:27:12,870 --> 00:27:18,450
for this talk like I said early stages

00:27:16,440 --> 00:27:20,970
can only execute by code it cannot parse

00:27:18,450 --> 00:27:23,100
Python as it turns out is a bit of a

00:27:20,970 --> 00:27:24,990
problem but otherwise it basically works

00:27:23,100 --> 00:27:26,460
but if you have the byte code like then

00:27:24,990 --> 00:27:29,820
it will it will generally just run it

00:27:26,460 --> 00:27:31,169
now there's an exception to this so name

00:27:29,820 --> 00:27:33,390
tuple the first thing that I talked

00:27:31,169 --> 00:27:36,330
about that you know like the sort of

00:27:33,390 --> 00:27:37,620
core to running writing these sort of

00:27:36,330 --> 00:27:40,470
things like to build classes really

00:27:37,620 --> 00:27:42,600
quickly in rapidly prototype if you were

00:27:40,470 --> 00:27:45,030
a Python dev like and you thought about

00:27:42,600 --> 00:27:46,980
like I wonder what kind of master

00:27:45,030 --> 00:27:48,330
programmer wrote the name tuple

00:27:46,980 --> 00:27:49,799
implementation I have no idea who it is

00:27:48,330 --> 00:27:50,970
by the way I'm not actually trying to

00:27:49,799 --> 00:27:52,470
like say anything about anyone together

00:27:50,970 --> 00:27:55,049
but I would have assumed this is like

00:27:52,470 --> 00:27:57,929
some hard core Python meta programming

00:27:55,049 --> 00:27:59,429
like building classes at runtime and

00:27:57,929 --> 00:28:01,230
like doing like all sorts of like

00:27:59,429 --> 00:28:03,390
wonderful meta programming and stuff and

00:28:01,230 --> 00:28:04,679
it turns out they're doing it the way

00:28:03,390 --> 00:28:06,690
that I would do it which is you just

00:28:04,679 --> 00:28:08,700
build literally a string that has like

00:28:06,690 --> 00:28:10,620
class such and such and literally like

00:28:08,700 --> 00:28:13,679
types out all the different fields and

00:28:10,620 --> 00:28:15,000
then just runs exec on it it's like no

00:28:13,679 --> 00:28:16,710
there's no magic secret here it just

00:28:15,000 --> 00:28:18,809
literally writes a Python program with

00:28:16,710 --> 00:28:20,610
your coat with a class function in it

00:28:18,809 --> 00:28:23,070
and then just calls it it was like the

00:28:20,610 --> 00:28:26,340
laziest way to do it but I guess it

00:28:23,070 --> 00:28:27,630
technically works so yeah I was really I

00:28:26,340 --> 00:28:29,100
was really kind of disappointed in this

00:28:27,630 --> 00:28:31,110
because it means that I couldn't use

00:28:29,100 --> 00:28:33,360
named tuple anymore because I can't use

00:28:31,110 --> 00:28:35,429
the exact statement in in Batavia

00:28:33,360 --> 00:28:36,990
because we can't parse Python code turns

00:28:35,429 --> 00:28:38,790
out parsing Python code is actually more

00:28:36,990 --> 00:28:42,360
difficult than executing byte code

00:28:38,790 --> 00:28:44,580
sometimes so yeah like this this is like

00:28:42,360 --> 00:28:46,350
a slightly abbreviated version of a name

00:28:44,580 --> 00:28:48,840
tuple it's really fascinating that like

00:28:46,350 --> 00:28:50,370
no this is not like significantly like

00:28:48,840 --> 00:28:54,480
advanced Python this is like a simple

00:28:50,370 --> 00:28:56,460
template thing like yeah any any I'd say

00:28:54,480 --> 00:29:00,030
intermediate Python developer could

00:28:56,460 --> 00:29:01,380
probably write this so yeah just

00:29:00,030 --> 00:29:02,840
disappointing that I won't be able to do

00:29:01,380 --> 00:29:05,780
that there's also some really fun

00:29:02,840 --> 00:29:09,240
JavaScript isms I love programming watts

00:29:05,780 --> 00:29:12,270
and I'll give you a million points if

00:29:09,240 --> 00:29:13,980
you can tell me like what this statement

00:29:12,270 --> 00:29:15,380
outputs in JavaScript so like if you

00:29:13,980 --> 00:29:17,520
type this into a browser don't cheat

00:29:15,380 --> 00:29:18,840
what do you think it outputs and so we

00:29:17,520 --> 00:29:20,730
have to be able to convert between

00:29:18,840 --> 00:29:23,010
JavaScript and Python to make this whole

00:29:20,730 --> 00:29:25,980
thing work and so what what magic do you

00:29:23,010 --> 00:29:30,270
think javascript outputs any any takers

00:29:25,980 --> 00:29:32,190
on what it's gonna output zero I heard

00:29:30,270 --> 00:29:33,390
zero so it's gonna be like false times

00:29:32,190 --> 00:29:35,429
negative one you'd hope that would be

00:29:33,390 --> 00:29:37,169
zero right maybe or maybe not a number I

00:29:35,429 --> 00:29:39,630
don't know false time something is maybe

00:29:37,169 --> 00:29:44,760
not a number right like what would you

00:29:39,630 --> 00:29:47,270
guess that it's negative zero I didn't

00:29:44,760 --> 00:29:49,679
even know JavaScript had negative zero

00:29:47,270 --> 00:29:51,419
like that's it just a totally new one to

00:29:49,679 --> 00:29:53,730
me and so getting like so I had to fix

00:29:51,419 --> 00:29:55,650
just a bunch of bugs to get any of this

00:29:53,730 --> 00:29:57,900
stuff to work because when you go from

00:29:55,650 --> 00:29:59,340
Fortran to Python to JavaScript you just

00:29:57,900 --> 00:30:03,780
get a lot of really weird messy

00:29:59,340 --> 00:30:06,150
translation stuff going on and so yeah

00:30:03,780 --> 00:30:08,100
negative negative zero I had to add like

00:30:06,150 --> 00:30:10,400
it turns out the code did rely on this

00:30:08,100 --> 00:30:12,900
behavior at some point and I had to like

00:30:10,400 --> 00:30:14,419
rewrite some things and it was just a

00:30:12,900 --> 00:30:17,070
huge nightmare but it technically works

00:30:14,419 --> 00:30:20,070
got it all to work you can go to this

00:30:17,070 --> 00:30:21,540
website here Swinson github do slash

00:30:20,070 --> 00:30:23,790
adventure jeaious and play it right now

00:30:21,540 --> 00:30:25,590
I can if you if you start up right now

00:30:23,790 --> 00:30:27,270
do not start it on your phones it will

00:30:25,590 --> 00:30:29,580
start spinning up all of the fans in

00:30:27,270 --> 00:30:31,710
your laptop like it will take 30 minutes

00:30:29,580 --> 00:30:33,809
to load it's really great luckily I

00:30:31,710 --> 00:30:35,790
pre-loaded it before I got here and I

00:30:33,809 --> 00:30:37,440
hope yes it's loaded so it looks like

00:30:35,790 --> 00:30:39,720
this it has like a little progress bar

00:30:37,440 --> 00:30:41,640
so you can watch it like just chew

00:30:39,720 --> 00:30:44,730
through your battery life trying to like

00:30:41,640 --> 00:30:46,230
spin up this the Fortran here like it's

00:30:44,730 --> 00:30:48,059
really cool but so like I got it to

00:30:46,230 --> 00:30:49,620
start and you can play it and it says

00:30:48,059 --> 00:30:53,700
welcome to adventure would you like some

00:30:49,620 --> 00:30:55,440
instructions see if I can actually scoot

00:30:53,700 --> 00:30:56,880
that down a little there we go it has

00:30:55,440 --> 00:30:58,410
like a little debug console so you can

00:30:56,880 --> 00:31:00,419
see each line of Fortran as it's

00:30:58,410 --> 00:31:01,799
executing it and it really it just takes

00:31:00,419 --> 00:31:03,600
it to eat time so I would say yes I

00:31:01,799 --> 00:31:04,860
would like instructions why don't you

00:31:03,600 --> 00:31:06,990
can like see it like just chugging

00:31:04,860 --> 00:31:08,250
through there like trying it's a little

00:31:06,990 --> 00:31:10,530
hard out to like

00:31:08,250 --> 00:31:12,360
no parse that into some sort of text

00:31:10,530 --> 00:31:14,460
it's pretty great it took me longer to

00:31:12,360 --> 00:31:15,840
give this it took me less time to give

00:31:14,460 --> 00:31:18,650
this talk and it probably did to start

00:31:15,840 --> 00:31:20,700
up this VM like or this VM within a VM

00:31:18,650 --> 00:31:22,650
but yeah you can see it like outputting

00:31:20,700 --> 00:31:24,180
like text now is like if you need help

00:31:22,650 --> 00:31:26,910
blah blah blah that sort of message we

00:31:24,180 --> 00:31:28,620
saw from the beginning so I think the

00:31:26,910 --> 00:31:30,180
the correct thing to do at this point in

00:31:28,620 --> 00:31:31,980
the game is you enter the building so

00:31:30,180 --> 00:31:33,120
you can just type in enter and then we

00:31:31,980 --> 00:31:34,410
gotta wait a lot while because it's

00:31:33,120 --> 00:31:35,850
gonna it's got has to figure out what

00:31:34,410 --> 00:31:38,190
you typed and then to try to match it up

00:31:35,850 --> 00:31:39,660
with its giant list and it doesn't it

00:31:38,190 --> 00:31:41,040
doesn't use any like fancy programming

00:31:39,660 --> 00:31:42,270
techniques like hash tables or anything

00:31:41,040 --> 00:31:43,680
like that to like figure out where you

00:31:42,270 --> 00:31:46,230
did so it's like it's just like a giant

00:31:43,680 --> 00:31:47,850
if of like every single like word it has

00:31:46,230 --> 00:31:50,070
if it has to check through every single

00:31:47,850 --> 00:31:51,540
time so it like it you can like really

00:31:50,070 --> 00:31:53,970
see it go into their own to begin in the

00:31:51,540 --> 00:31:55,560
building we got in the building so yeah

00:31:53,970 --> 00:31:58,260
there's some keys we can grab there's

00:31:55,560 --> 00:31:59,490
like a shiny brass lamp there so we need

00:31:58,260 --> 00:32:01,890
to take all these things right in order

00:31:59,490 --> 00:32:03,750
to play so we didn't take food and then

00:32:01,890 --> 00:32:06,450
you know again just give it a few

00:32:03,750 --> 00:32:08,100
minutes to like go through the SMS is

00:32:06,450 --> 00:32:09,600
actually a little faster because I don't

00:32:08,100 --> 00:32:11,340
have the extra JavaScript layer of

00:32:09,600 --> 00:32:12,960
goodness in there so it only takes about

00:32:11,340 --> 00:32:16,500
two seconds or so to do at each of these

00:32:12,960 --> 00:32:20,400
things rather than like 60 or so that

00:32:16,500 --> 00:32:21,570
this takes anyway yeah you don't need

00:32:20,400 --> 00:32:22,740
the food and water till later I haven't

00:32:21,570 --> 00:32:24,930
actually beaten this game but I'm pretty

00:32:22,740 --> 00:32:28,530
sure you can beat it like there's just

00:32:24,930 --> 00:32:29,880
enough bugs to get it through ya know

00:32:28,530 --> 00:32:30,840
yeah it's definitely fun they're

00:32:29,880 --> 00:32:32,220
definitely lot of people playing it

00:32:30,840 --> 00:32:33,810
because I get like thousands of text

00:32:32,220 --> 00:32:36,480
messages a month still of people playing

00:32:33,810 --> 00:32:40,590
this game so that's cool but I work for

00:32:36,480 --> 00:32:41,940
Twilio so it's all free so text away in

00:32:40,590 --> 00:32:44,520
that and now you can run it for free in

00:32:41,940 --> 00:32:45,540
your browser yeah so it's gonna take a

00:32:44,520 --> 00:32:47,580
while because it's got to figure out

00:32:45,540 --> 00:32:49,350
which item you just asked it to grab

00:32:47,580 --> 00:32:50,760
there so it's like literally going

00:32:49,350 --> 00:32:52,620
through and checking every item that it

00:32:50,760 --> 00:32:56,460
knows about in the game and like is it

00:32:52,620 --> 00:32:59,090
is it keys is it lamp you know so forth

00:32:56,460 --> 00:33:02,940
and yeah and that is basically my talk

00:32:59,090 --> 00:33:06,230
Fortran in Python in in JavaScript full

00:33:02,940 --> 00:33:06,230
full stack Fortran for

00:33:11,870 --> 00:33:15,440
I believe we are taking some questions

00:33:14,090 --> 00:33:17,120
like for a few minutes here we still

00:33:15,440 --> 00:33:18,710
have a few minutes left so if you do

00:33:17,120 --> 00:33:22,490
have any questions our moderator I think

00:33:18,710 --> 00:33:24,980
will accept those I promise you I do not

00:33:22,490 --> 00:33:26,720
know hardly any Fortran for answers I

00:33:24,980 --> 00:33:28,850
only knew just enough to get this talk

00:33:26,720 --> 00:33:32,059
to work and then I was like mission

00:33:28,850 --> 00:33:33,559
accomplished Thank You Christopher as he

00:33:32,059 --> 00:33:34,850
mentioned please feel free to bring your

00:33:33,559 --> 00:33:37,030
questions up to one of these microphones

00:33:34,850 --> 00:33:41,570
we have a few minutes left

00:33:37,030 --> 00:33:43,220
hi a question about the Fortran to

00:33:41,570 --> 00:33:45,500
Python interpreter mm-hmm

00:33:43,220 --> 00:33:48,110
in the course of writing a Fortran

00:33:45,500 --> 00:33:50,900
interpreter in Python you used as your

00:33:48,110 --> 00:33:53,809
base case of examination the adventure

00:33:50,900 --> 00:33:56,300
code itself right yes did it contain

00:33:53,809 --> 00:33:58,220
bugs and if so is it difficult to

00:33:56,300 --> 00:34:00,860
disambiguate whether your interpreter is

00:33:58,220 --> 00:34:02,720
incorrect or the actual code that you're

00:34:00,860 --> 00:34:04,910
interpreting is incorrect so the code

00:34:02,720 --> 00:34:06,710
definitely has some bugs and there were

00:34:04,910 --> 00:34:08,840
like some weird syntax anomalies like I

00:34:06,710 --> 00:34:10,879
said like the tab thing being either six

00:34:08,840 --> 00:34:12,740
spaces or eight spaces and you sort of

00:34:10,879 --> 00:34:15,080
were expected like indent each line with

00:34:12,740 --> 00:34:16,340
six spaces at the beginning the code

00:34:15,080 --> 00:34:17,870
didn't do that and I've seen other

00:34:16,340 --> 00:34:20,120
versions of the code that came later

00:34:17,870 --> 00:34:22,490
that did do that correctly and so I sort

00:34:20,120 --> 00:34:23,960
of had like I don't I don't know if this

00:34:22,490 --> 00:34:25,909
is like an error in translation like

00:34:23,960 --> 00:34:27,770
when somebody converted it to ASCII or

00:34:25,909 --> 00:34:29,659
something like way later on they messed

00:34:27,770 --> 00:34:31,159
up the conversion but I wanted to

00:34:29,659 --> 00:34:33,050
interpret like the file that I had so I

00:34:31,159 --> 00:34:35,450
definitely had to work around like the

00:34:33,050 --> 00:34:36,889
weird indentation issues sometimes and

00:34:35,450 --> 00:34:39,590
they're definitely some kind of dirty

00:34:36,889 --> 00:34:41,300
hacks around around things like that in

00:34:39,590 --> 00:34:42,770
the code and I know that there are bugs

00:34:41,300 --> 00:34:44,480
in the logic of the code although I

00:34:42,770 --> 00:34:45,919
don't know a super lot about them

00:34:44,480 --> 00:34:47,389
because this is the earliest version I

00:34:45,919 --> 00:34:50,990
could find and so they're definitely

00:34:47,389 --> 00:34:52,070
like typos and things and you know in

00:34:50,990 --> 00:34:57,650
there somewhere oh look we finally got

00:34:52,070 --> 00:35:00,880
the food another question anyway so when

00:34:57,650 --> 00:35:05,600
you were working on the Fortran part

00:35:00,880 --> 00:35:08,570
other any pdp-10 simulators available

00:35:05,600 --> 00:35:10,550
and if there are is it possible to still

00:35:08,570 --> 00:35:13,730
compile and run this program the

00:35:10,550 --> 00:35:17,210
simulator is I'm sorry I could it's

00:35:13,730 --> 00:35:20,420
possible to run a compiler on the pdp-10

00:35:17,210 --> 00:35:23,120
simulator available or yeah yeah so

00:35:20,420 --> 00:35:25,349
there are a few PDP like 10 and it might

00:35:23,120 --> 00:35:27,300
even work on the PDP 6 i'm not sure

00:35:25,349 --> 00:35:28,829
because the pdp-10 and pdb six are very

00:35:27,300 --> 00:35:30,359
similar yeah you could probably could

00:35:28,829 --> 00:35:32,520
find a compiler running on those I know

00:35:30,359 --> 00:35:35,700
it's very tricky because compilers are

00:35:32,520 --> 00:35:37,020
very sensitive to like everything cuz

00:35:35,700 --> 00:35:39,119
they're very complex pieces of software

00:35:37,020 --> 00:35:42,119
I did not try to run it on a pdp-10

00:35:39,119 --> 00:35:43,349
simulator exactly but that would be that

00:35:42,119 --> 00:35:46,020
would be fun or even getting it to run

00:35:43,349 --> 00:35:48,599
on an actual pdp-10 I know that there's

00:35:46,020 --> 00:35:50,339
at least one or two still running in

00:35:48,599 --> 00:35:51,599
existence there kind of because they're

00:35:50,339 --> 00:35:53,579
the larger mainframes they're a lot

00:35:51,599 --> 00:35:55,050
harder to find in working condition

00:35:53,579 --> 00:35:57,809
these days and they're very expensive to

00:35:55,050 --> 00:36:00,329
run so yeah we're somewhat like the

00:35:57,809 --> 00:36:02,160
pdp-11 and other ones like are a lot

00:36:00,329 --> 00:36:04,619
smaller and so you see a lot more those

00:36:02,160 --> 00:36:06,180
still around but I have not seen a

00:36:04,619 --> 00:36:10,170
working pdp-10 in person I've seen a

00:36:06,180 --> 00:36:11,099
working p p1 in PDP 11 yeah it would be

00:36:10,170 --> 00:36:12,510
it would be fun to run this in a

00:36:11,099 --> 00:36:15,440
simulator to see if it would compile I

00:36:12,510 --> 00:36:20,220
have not tried thank you

00:36:15,440 --> 00:36:24,920
so did you implement everything in the

00:36:20,220 --> 00:36:27,930
game cuz as I recall there was a like a

00:36:24,920 --> 00:36:30,319
something that you could type in X Y Z Z

00:36:27,930 --> 00:36:36,089
Y no no no no something else that would

00:36:30,319 --> 00:36:38,579
open up the internal you could you could

00:36:36,089 --> 00:36:44,880
get it to a point where you could alter

00:36:38,579 --> 00:36:47,220
the game by getting directly into a list

00:36:44,880 --> 00:36:48,450
that it was using oh I would like the

00:36:47,220 --> 00:36:50,609
buffer overflow or something like that

00:36:48,450 --> 00:36:52,140
like it I don't know that might be

00:36:50,609 --> 00:36:54,150
possible either there was a there was a

00:36:52,140 --> 00:36:56,520
way to cheat at it basically it's like

00:36:54,150 --> 00:37:00,390
oh look I've opened up the insides of it

00:36:56,520 --> 00:37:01,559
and I can just change it yeah no I'm

00:37:00,390 --> 00:37:03,180
sure that there's a way to do that this

00:37:01,559 --> 00:37:05,040
is as far as I know the earliest version

00:37:03,180 --> 00:37:06,329
that was ever published and so if there

00:37:05,040 --> 00:37:07,680
was a bug like that this probably

00:37:06,329 --> 00:37:08,790
contains it I didn't I did not know

00:37:07,680 --> 00:37:10,619
about that bug so I don't know how to

00:37:08,790 --> 00:37:12,150
check for it but if I bet if I typed in

00:37:10,619 --> 00:37:13,859
the right magic word and take or

00:37:12,150 --> 00:37:15,420
something it would overflow something

00:37:13,859 --> 00:37:17,430
and overwrite some word and I could

00:37:15,420 --> 00:37:19,020
modify things or you know I'm sure

00:37:17,430 --> 00:37:22,880
something like that is possible well I

00:37:19,020 --> 00:37:26,010
was playing it on a deck system 10 in

00:37:22,880 --> 00:37:29,880
1979 so I think it was a pretty early

00:37:26,010 --> 00:37:34,079
version yeah yeah and it wasn't a bug it

00:37:29,880 --> 00:37:36,990
was sort of a you know admin mode okay

00:37:34,079 --> 00:37:37,470
it was intentional it was just very well

00:37:36,990 --> 00:37:38,820
hidden

00:37:37,470 --> 00:37:39,990
I don't I

00:37:38,820 --> 00:37:41,400
not look at the source code in that

00:37:39,990 --> 00:37:44,010
level of detail and mostly was just

00:37:41,400 --> 00:37:45,630
getting it to parse and compile that is

00:37:44,010 --> 00:37:46,980
very possible that is in there and I

00:37:45,630 --> 00:37:49,800
either didn't see it or did not know

00:37:46,980 --> 00:37:51,090
what I was looking for X Y Z Z Y you can

00:37:49,800 --> 00:37:56,060
definitely see hard-coded in there

00:37:51,090 --> 00:37:58,730
though that's pretty cool in clover yeah

00:37:56,060 --> 00:38:03,750
clovers six letters though isn't it yeah

00:37:58,730 --> 00:38:06,150
no clover clover yes yes um so the games

00:38:03,750 --> 00:38:07,470
been ported to some other forms that

00:38:06,150 --> 00:38:09,090
might be easier to run in Python or

00:38:07,470 --> 00:38:10,260
JavaScript did you consider using those

00:38:09,090 --> 00:38:12,330
for this project or write more

00:38:10,260 --> 00:38:13,890
absolutely did not consider running any

00:38:12,330 --> 00:38:16,800
fancier code I don't need that fancy

00:38:13,890 --> 00:38:18,990
code I like to I like to go I wanted to

00:38:16,800 --> 00:38:20,100
go back to the original form as much as

00:38:18,990 --> 00:38:22,560
possible but ya know it's been ported

00:38:20,100 --> 00:38:24,420
all over the place like every system had

00:38:22,560 --> 00:38:26,220
a copy of adventure starting like in the

00:38:24,420 --> 00:38:28,170
late 70s because it was such a popular

00:38:26,220 --> 00:38:30,120
game and people like tweaked it and made

00:38:28,170 --> 00:38:31,170
it their own and like changed it and you

00:38:30,120 --> 00:38:32,760
get things like this'll work and stuff

00:38:31,170 --> 00:38:34,620
like that but I wanted I wanted the

00:38:32,760 --> 00:38:36,960
original one because like if you wanted

00:38:34,620 --> 00:38:38,670
to play a copy of the original code as

00:38:36,960 --> 00:38:41,160
it is like there's unless you boot up a

00:38:38,670 --> 00:38:43,080
pdp-10 simulator you can't like there's

00:38:41,160 --> 00:38:45,420
no there's nothing that has the original

00:38:43,080 --> 00:38:47,880
Fortran code running essentially so I

00:38:45,420 --> 00:38:51,060
was like I want to run it as originally

00:38:47,880 --> 00:38:53,850
as you could run it it's still waiting

00:38:51,060 --> 00:38:54,960
to take the lamp to the crash oh no it's

00:38:53,850 --> 00:38:58,200
still it's still just doing its thing

00:38:54,960 --> 00:39:00,210
thank you for the talk uh quickly what

00:38:58,200 --> 00:39:03,510
steps would you take to make this more

00:39:00,210 --> 00:39:04,770
performant there are many steps I could

00:39:03,510 --> 00:39:06,780
take to make this more for one thing

00:39:04,770 --> 00:39:08,580
profiling it like at all it would be

00:39:06,780 --> 00:39:11,460
really good like I haven't I didn't even

00:39:08,580 --> 00:39:13,020
try like yeah like that there's a lot of

00:39:11,460 --> 00:39:14,760
there's a lot of loose threads

00:39:13,020 --> 00:39:16,560
especially in the in the JavaScript part

00:39:14,760 --> 00:39:18,180
where you know it's executing the

00:39:16,560 --> 00:39:20,160
bytecode but it definitely does not have

00:39:18,180 --> 00:39:21,690
a lot of optimizations like I know

00:39:20,160 --> 00:39:23,760
especially because I implemented a lot

00:39:21,690 --> 00:39:26,220
of D optimizations into the JavaScript

00:39:23,760 --> 00:39:28,200
layer like you know in Python like all

00:39:26,220 --> 00:39:30,060
integers can automatically expand to be

00:39:28,200 --> 00:39:32,310
arbitrary precision and JavaScript

00:39:30,060 --> 00:39:33,630
everything is a double so initially the

00:39:32,310 --> 00:39:36,000
first implementations we had we use

00:39:33,630 --> 00:39:38,040
integers as doubles everywhere and that

00:39:36,000 --> 00:39:40,980
works great until someone types in 10

00:39:38,040 --> 00:39:42,480
star star 200 and then you get like some

00:39:40,980 --> 00:39:44,520
nonsense answer instead of what you

00:39:42,480 --> 00:39:45,690
actually want and so then you sort of

00:39:44,520 --> 00:39:47,430
have to be really careful about when you

00:39:45,690 --> 00:39:49,410
switch between and which ones you use as

00:39:47,430 --> 00:39:51,960
indices and that slows everything down a

00:39:49,410 --> 00:39:52,620
whole lot so like probably like looking

00:39:51,960 --> 00:39:54,930
more carefully at

00:39:52,620 --> 00:39:56,910
like that would probably be a good place

00:39:54,930 --> 00:39:58,950
to start I know that was a source of a

00:39:56,910 --> 00:40:02,040
huge slowdown but necessary to get

00:39:58,950 --> 00:40:03,690
anything to work yeah there's there's a

00:40:02,040 --> 00:40:04,950
lot of oh did I finally get the I got

00:40:03,690 --> 00:40:06,630
the lamp yeah there's a lot of places to

00:40:04,950 --> 00:40:08,730
look for for optimization if I were

00:40:06,630 --> 00:40:10,890
trying to like seriously do this and

00:40:08,730 --> 00:40:12,390
make it not a giant hack yeah that would

00:40:10,890 --> 00:40:15,740
be a lot of fun what else is here the

00:40:12,390 --> 00:40:15,740
keys the keys

00:40:16,940 --> 00:40:22,920
run for a while I think thanks a lot for

00:40:19,410 --> 00:40:25,200
your talk I um I really love Python used

00:40:22,920 --> 00:40:26,610
forensic ly like this it's a lot of fun

00:40:25,200 --> 00:40:29,610
Thanks

00:40:26,610 --> 00:40:32,100
keeping in your spirit of being lazy

00:40:29,610 --> 00:40:35,160
have you considered writing an AI to

00:40:32,100 --> 00:40:37,980
text your phone and have it solved the

00:40:35,160 --> 00:40:40,260
game for you I mean you certainly could

00:40:37,980 --> 00:40:42,030
I don't know yeah ARS are really tricky

00:40:40,260 --> 00:40:43,620
right because you either have to make

00:40:42,030 --> 00:40:45,210
the algorithms very smart or you have to

00:40:43,620 --> 00:40:47,520
have a lot of input data for a machine

00:40:45,210 --> 00:40:48,360
learning and I don't I'm really lazy so

00:40:47,520 --> 00:40:50,670
I don't want to make a really smart

00:40:48,360 --> 00:40:52,800
model and I don't have like machine

00:40:50,670 --> 00:40:55,140
learning would be really I think text

00:40:52,800 --> 00:40:56,940
adventures are not a great set up for

00:40:55,140 --> 00:40:58,830
for machine learning I know that they

00:40:56,940 --> 00:41:01,620
have done some successful AIS for some

00:40:58,830 --> 00:41:03,360
roguelikes like there's like Angband has

00:41:01,620 --> 00:41:05,550
like egg bot or something like that

00:41:03,360 --> 00:41:07,830
where it will automatically play Angband

00:41:05,550 --> 00:41:09,360
and sometimes it could even win but I

00:41:07,830 --> 00:41:11,280
think that's more like the sophisticated

00:41:09,360 --> 00:41:13,620
algorithm approach rather than the huge

00:41:11,280 --> 00:41:14,640
machine learning data approach but yeah

00:41:13,620 --> 00:41:16,650
that could that could be kind of fun but

00:41:14,640 --> 00:41:19,320
I don't know if this if a text adventure

00:41:16,650 --> 00:41:21,150
is the right format for that because

00:41:19,320 --> 00:41:22,650
like you this is almost scripted like

00:41:21,150 --> 00:41:23,940
there's only a few parts where it

00:41:22,650 --> 00:41:24,990
actually will pull a random number but

00:41:23,940 --> 00:41:26,940
other than that everything is like you

00:41:24,990 --> 00:41:32,430
can follow the exact same thing and you

00:41:26,940 --> 00:41:34,650
can always win right Thanks sure looks

00:41:32,430 --> 00:41:36,450
like that's it for questions so let's

00:41:34,650 --> 00:41:43,510
thank Christopher one more time

00:41:36,450 --> 00:41:43,510

YouTube URL: https://www.youtube.com/watch?v=RojaWIoBfOo


